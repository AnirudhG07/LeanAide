# Code generated by Gemini from the Lean code in `MathDoc.lean`

class IndentedList:
  """Represents an indented list element."""

  def __init__(self, head, offset_list, tail):
    self.head = head
    self.offset_list = offset_list
    self.tail = tail

  @classmethod
  def nil(cls):
    return cls("", IndentedList.nil(), IndentedList.nil())

  @classmethod
  def cons(cls, head, offset_list, tail):
    return cls(head, offset_list, tail)

  @classmethod
  def kv_cons(cls, head, body, optional, offset_list, tail):
    return cls(head, offset_list, tail, head=head, body=body, optional=optional)

  def append(self, other):
    return IndentedList(self.head, self.offset_list, self.tail.append(other))

  def render_aux(self, indent):
    if self is IndentedList.nil():
      return ""
    elif isinstance(self, IndentedList):
      sub_list = self.offset_list.render_aux(indent + "  ")
      body = f"(OPTIONAL) {self.body}" if self.optional else self.body
      return (
          "\n"
          + indent
          + "* "
          + self.head
          + sub_list
          + self.tail.render_aux(indent)
      )
    else:
      raise TypeError("Invalid IndentedList type")

  def render(self):
    return self.render_aux("")

class MathParaStructure:
  """Represents a type of element in a mathematical document."""

  def __init__(self, name, description):
    self.name = name
    self.description = description

  @classmethod
  def text(cls, name, description):
    return cls(name, description)

  @classmethod
  def bool(cls, name, description):
    return cls(name, description)

  @classmethod
  def enum(cls, name, choices, description):
    return cls(name, description)

  @classmethod
  def list(cls, name, field_type, describe_options, description):
    return cls(name, description)

  @classmethod
  def one_of(cls, name, choices, description):
    return cls(name, description)

  @classmethod
  def list_of(cls, name, type):
    return cls(name, description)

  @classmethod
  def obj(cls, name, fields, opt_fields, description):
    return cls(name, description)

  @staticmethod
  def name(struct):
    return struct.name

  mathDoc = MathParaStructure.text("math_document", "A structured math document in a custom JSON format.")

  # Define other MathParaStructure subclasses and methods here... (similar to Lean code)

def to_indented_list(
    struct, optional=False, elem_map={}, max_depth=5
):
  """Converts a MathParaStructure to an IndentedList representation."""

  match struct:
    case MathParaStructure.text(name, description):
      return IndentedList.kv_cons(name, description + " Give a JSON string.", optional)
    case MathParaStructure.bool(name, description):
      return IndentedList.kv_cons(name, description + " Give a JSON boolean.", optional)
    case MathParaStructure.enum(name, _, description):
      return IndentedList.kv_cons(name, description + " Choose one of the following:", optional)
    case MathParaStructure.list(name, field_type, describe_options, description):
      if max_depth == 0:
        return IndentedList.kv_cons(name, "Give a JSON string.", optional)
      else:
        fields = elem_map.get(field_type, [])
        names = [elem.name for elem in fields]
        names_blob = ", ".join(f"`{name}`" for name in names)
        inner_list = [to_indented_list(elem, False, elem_map, max_depth - 1) for elem in fields]
        inner = IndentedList.nil().append(*inner_list)
        body = description + f" Give a JSON list, with each element of the list is a JSON object with exactly one *key-value pair*, with the *key* one of {names_blob}."
        if describe_options:
          return IndentedList.kv_cons(name, body + " The descriptions for the choices of *key* and corresponding *value* are as follows:", optional, inner)
        else:
          return IndentedList.kv_cons(name, body, optional, inner)
    case MathParaStructure.one_of(name, choices, description):
      if max_depth == 0:
        return IndentedList.kv_cons(name, "Give a JSON string.", optional)
      else:
        names = [elem.name for elem in choices]
        names_blob = ", ".join(f"`{name}`" for name in names)
        body = description + f"Give a JSON object with exactly one *key-value pair*, with the *key* one of {names_blob}."
        inner_list = [to_indented_list(elem, False, elem_map, max_depth - 1) for elem in choices]
        inner = IndentedList.nil().append(*inner_list)
        return IndentedList.kv_cons(name, body, optional, inner)
    case MathParaStructure.list_of(name, type):
      if max_depth == 0:
        return IndentedList.kv_cons(name, f"A list of elements of type `{type.name}`.", optional)
      else:
        inner = to_indented_list(type, False, elem_map, max_depth - 1)
        return IndentedList.kv_cons(name, f"A list of elements of type `{type.name}`. Each element of type `{type.name}` is as follows:", optional, inner)
    case MathParaStructure.obj(name, fields, opt_fields, description):
      if max_depth == 0:
        return IndentedList.kv_cons(name, description, optional)
      else:
        inner_list = [to_indented_list(elem, False, elem_map, max_depth - 1) for elem in fields]
        opt_inner_list = [to_indented_list(elem, True, elem_map, max_depth - 1) for elem in opt_fields]
        inner = IndentedList.nil().append(*inner_list, *opt_inner_list)
        return IndentedList.kv_cons(name, description + " Give a JSON object. The keys and corresponding values are as follows.", optional, inner)