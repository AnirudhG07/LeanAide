

======================


PROMPT: One can reformulate smoothness as continuity and smoothness in any extended chart.


Top 10 most similar prompts from the entire corpus:
One can reformulate smoothness as continuity and smoothness in any extended chart. (Score: 1.0000)
 One can reformulate smoothness on a set as continuity on this set, and smoothness in any extended chart. (Score: 0.9579)
 One can reformulate smoothness as continuity and smoothness in any extended chart in the target. (Score: 0.9458)
 One can reformulate smoothness on a set as continuity on this set, and smoothness in any extended chart in the target. (Score: 0.9369)
 One can reformulate smoothness within a set at a point as continuity within this set at this point, and smoothness in the corresponding extended chart. (Score: 0.9263)
 One can reformulate smoothness within a set at a point as continuity within this set at this point, and smoothness in the corresponding extended chart. (Score: 0.9263)
 One can reformulate smoothness within a set at a point as continuity within this set at this point, and smoothness in the corresponding extended chart in the target. (Score: 0.9065)
 One can reformulate smoothness within a set at a point as continuity within this set at this point, and smoothness in the corresponding extended chart. This form states smoothness of `f` written in the `ext_chart_at`s within the set `(ext_chart_at I x).symm ⁻¹' s ∩ range I`. This set is larger than the set `(ext_chart_at I x).target ∩ (ext_chart_at I x).symm ⁻¹' (s ∩ f ⁻¹' (ext_chart_at I' (f x)).source)` used in `cont_mdiff_within_at_iff` but their germs at `ext_chart_at I x x` are equal. It may be useful to rewrite using `cont_mdiff_within_at_iff''` in the *assumptions* of a lemma and using `cont_mdiff_within_at_iff` in the goal. (Score: 0.6837)
 If `f : smooth_bump_function I c` is a smooth bump function and `g : M → G` is a function smooth on the source of the chart at `c`, then `f • g` is smooth on the whole manifold. (Score: 0.5996)
A smooth bump function is infinitely smooth. (Score: 0.5584)


======================


PROMPT: Triangle inequality for the nonnegative distance


Top 10 most similar prompts from the entire corpus:
Triangle inequality for the nonnegative distance (Score: 1.0000)
Triangle inequality for the extended distance (Score: 0.8526)
A sort of triangle inequality. (Score: 0.8078)
**Triangle inequality** for the norm. (Score: 0.7145)
the minimal distance is always nonnegative (Score: 0.6574)
The **triangle inequality** for complex numbers. (Score: 0.6469)
The absolute value satisfies the triangle inequality. (Score: 0.6430)
The Hausdorff distance satisfies the triangular inequality (Score: 0.6297)
The Hausdorff distance satisfies the triangular inequality (Score: 0.6297)
The Hausdorff distance satisfies the triangular inequality (Score: 0.6297)


======================


PROMPT: A module over a division ring is noetherian if and only if its dimension (as a cardinal) is strictly less than the first infinite cardinal `ℵ₀`.


Top 10 most similar prompts from the entire corpus:
A module over a division ring is noetherian if and only if its dimension (as a cardinal) is strictly less than the first infinite cardinal `ℵ₀`. (Score: 1.0000)
 The dimension of a noetherian module over a division ring, as a cardinal, is strictly less than the first infinite cardinal `ℵ₀`. (Score: 0.9392)
A module over a division ring is noetherian if and only if it is finitely generated. (Score: 0.8195)
 In a noetherian module over a division ring, if a basis is indexed by a set, that set is finite. (Score: 0.7184)
A generalization of the theorem that if `N` is a submodule of `M` and  `N` and `M / N` are both Noetherian, then `M` is Noetherian. (Score: 0.6884)
An R-module is Noetherian iff all its submodules are finitely-generated. (Score: 0.6870)
A module is Noetherian iff every nonempty set of submodules has a maximal submodule among them. (Score: 0.6723)
A division_ring is one-dimensional as a vector space over itself. (Score: 0.6564)
 In a module over a noetherian ring, the submodule generated by finitely many vectors is noetherian. (Score: 0.6552)
A ring is Noetherian if and only if all its ideals are finitely-generated. (Score: 0.6208)


======================


PROMPT:  If every element belongs to at most `n` finsets, then the sum of their sizes is at most `n` times how many they are.


Top 10 most similar prompts from the entire corpus:
 If every element belongs to at most `n` finsets, then the sum of their sizes is at most `n` times how many they are. (Score: 1.0000)
 If every element belongs to at most `n` finsets, then the sum of their sizes is at most `n` times how many they are. (Score: 1.0000)
 If every element belongs to at least `n` finsets, then the sum of their sizes is at least `n` times how many they are. (Score: 0.9849)
 If every element belongs to at least `n` finsets, then the sum of their sizes is at least `n` times how many they are. (Score: 0.9849)
 If every element belongs to exactly `n` finsets, then the sum of their sizes is `n` times how many they are. (Score: 0.9604)
 If every element belongs to exactly `n` finsets, then the sum of their sizes is `n` times how many they are. (Score: 0.9604)
If a sum of a `finset` of size at most 1 has a given value, so do the terms in that sum. (Score: 0.6595)
If a finset has cardinality larger than `finrank + 1`, then there is a nontrivial linear relation amongst its elements, such that the coefficients of the relation sum to zero. (Score: 0.6331)
To prove a proposition about an arbitrary `finset α`, it suffices to prove it for the empty `finset`, and to show that if it holds for some `finset α`, then it holds for the `finset` obtained by inserting a new element. (Score: 0.5791)
 If a product of a `finset` of size at most 1 has a given value, so do the terms in that product. (Score: 0.5765)


======================


PROMPT:  Two multilinear maps indexed by `fin n` are equal if they are equal when all arguments are basis vectors.


Top 10 most similar prompts from the entire corpus:
 Two multilinear maps indexed by `fin n` are equal if they are equal when all arguments are basis vectors. (Score: 1.0000)
Two bilinear maps are equal when they are equal on all basis vectors. (Score: 0.7671)
Two linear maps are equal if they are equal on basis vectors. (Score: 0.7612)
 Two alternating maps indexed by a `fintype` are equal if they are equal when all arguments are distinct basis vectors. (Score: 0.7189)
 Two multilinear maps indexed by a `fintype` are equal if they are equal when all arguments are basis vectors. Unlike `basis.ext_multilinear_fin`, this only uses a single basis; a dependently-typed version would still be true, but the proof would need a dependently-typed version of `dom_dom_congr`. (Score: 0.6997)
If two linear maps are equal, they are equal at each point. (Score: 0.6765)
 Composing a multilinear map with a linear equiv on each argument gives the zero map if and only if the multilinear map is the zero map. (Score: 0.6698)
 Composing a multilinear map twice with a linear map in each argument is the same as composing with their composition. (Score: 0.6504)
Two bilinear forms are equal when they are equal on all basis vectors. (Score: 0.6456)
Composing a multilinear map with the identity linear map in each argument. (Score: 0.6341)


======================


PROMPT: The tangent bundle projection on the basis is an open map.


Top 10 most similar prompts from the entire corpus:
The tangent bundle projection on the basis is an open map. (Score: 1.0000)
The tangent bundle projection on the basis is a continuous map. (Score: 0.8845)
The projection from a topological fiber bundle to its base is an open map. (Score: 0.7435)
The projection on the base of a topological vector bundle created from core is an open map (Score: 0.6969)
The projection on the base of a topological bundle created from core is an open map (Score: 0.6850)
The projection from a topological fiber bundle to its base is continuous. (Score: 0.6242)
In the domain of a bundle trivialization, the projection is continuous (Score: 0.6141)
 In a smooth fiber bundle constructed from core, the preimage under the projection of a set with unique differential in the basis also has unique differential. (Score: 0.5953)
 The projection from a topological fiber bundle with a nonempty fiber to its base is a surjective map. (Score: 0.5870)
The projection on the base of a topological vector bundle created from core is continuous (Score: 0.5807)


======================


PROMPT: Let `F` be a sheaf valued in a concrete category, whose forgetful functor reflects isomorphisms, preserves limits and filtered colimits. Then two sections who agree on every stalk must be equal.


Top 10 most similar prompts from the entire corpus:
Let `F` be a sheaf valued in a concrete category, whose forgetful functor reflects isomorphisms, preserves limits and filtered colimits. Then two sections who agree on every stalk must be equal. (Score: 1.0000)
Let `F` and `G` be sheaves valued in a concrete category, whose forgetful functor reflects isomorphisms, preserves limits and filtered colimits. Then if the stalk maps of a morphism `f : F ⟶ G` are all isomorphisms, `f` must be an isomorphism. (Score: 0.9024)
Let `F` and `G` be sheaves valued in a concrete category, whose forgetful functor reflects isomorphisms, preserves limits and filtered colimits. Then a morphism `f : F ⟶ G` is an isomorphism if and only if all of its stalk maps are isomorphisms. (Score: 0.8929)
Suppose `X Y : SheafedSpace C`, where `C` is a concrete category, whose forgetful functor reflects isomorphisms, preserves limits and filtered colimits. Then a morphism `X ⟶ Y` that is a topological open embedding is an open immersion iff every stalk map is an iso. (Score: 0.7540)
For presheaves valued in a concrete category whose forgetful functor preserves filtered colimits, every element of the stalk is the germ of a section. (Score: 0.7471)
For presheaves valued in a concrete category, whose forgetful functor reflects isomorphisms and preserves limits, the sheaf condition in terms of unique gluings is equivalent to the usual one in terms of equalizer diagrams. (Score: 0.7305)
If `G : C ⥤ D` is a functor which reflects isomorphisms and preserves limits (we assume all limits exist in both `C` and `D`), then checking the sheaf condition for a presheaf `F : presheaf C X` is equivalent to checking the sheaf condition for `F ⋙ G`.  The important special case is when `C` is a concrete category with a forgetful functor that preserves limits and reflects isomorphisms. Then to check the sheaf condition it suffices to check it on the underlying sheaf of types.  Another useful example is the forgetful functor `TopCommRing ⥤ Top`.  See <https://stacks.math.columbia.edu/tag/0073>. In fact we prove a stronger version with arbitrary complete target category. (Score: 0.6956)
The property of being a sheaf is preserved by isomorphism. (Score: 0.6621)
If a presieve `R` on `X` has a subsieve `S` such that:  * `P` is a sheaf for `S`. * For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,  then `P` is a sheaf for `R`.  This is closely related to [Elephant] C2.1.6(i). (Score: 0.6532)
For a concrete category `(A, s)` where the forgetful functor `s : A ⥤ Type v` preserves limits and reflects isomorphisms, and `A` has limits, an `A`-valued presheaf `P : Cᵒᵖ ⥤ A` is a sheaf iff its underlying `Type`-valued presheaf `P ⋙ s : Cᵒᵖ ⥤ Type` is a sheaf.  Note this lemma applies for "algebraic" categories, eg groups, abelian groups and rings, but not for the category of topological spaces, topological rings, etc since reflecting isomorphisms doesn't hold. (Score: 0.6438)


======================


PROMPT: Counterpart to `list.sum_take_succ` when we have an negation operation


Top 10 most similar prompts from the entire corpus:
Counterpart to `list.sum_take_succ` when we have an negation operation (Score: 1.0000)
This is the `list.sum` version of `add_neg` (Score: 0.7052)
Counterpart to `list.prod_take_succ` when we have an inverse operation (Score: 0.6329)
An 'unapplied' analogue of `finset.sum_apply`. (Score: 0.6027)
A variant of `sum_range_succ` which pulls off the first term in the sum   rather than the last. (Score: 0.6008)
A non-commutative variant of `list.sum_reverse` (Score: 0.5961)
Prefer `neg_zero` if `subtraction_monoid` is available. (Score: 0.5667)
This is the `list.sum` version of `add_neg_rev` (Score: 0.5558)
Same as `nth_zero_add_tail_sum`, but avoiding the `list.head` garbage complication by requiring the list to be nonempty. (Score: 0.5470)
Alternative version of `list.sum_update_nth` when the list is over a group (Score: 0.5424)


======================


PROMPT: **Alias** of sub_neg`.


Top 10 most similar prompts from the entire corpus:
**Alias** of sub_neg`. (Score: 1.0000)
**Alias** of the reverse direction of sub_neg`. (Score: 0.9523)
**Alias** of the forward direction of sub_neg`. (Score: 0.9256)
**Alias** of the reverse direction of sub_nonneg`. (Score: 0.8824)
**Alias** of the forward direction of sub_nonneg`. (Score: 0.8367)
**Alias** of left.neg_lt_self`. (Score: 0.8176)
**Alias** of neg_sq`. (Score: 0.8168)
**Alias** of `left.add_neg_of_nonpos_of_neg`. (Score: 0.8010)
**Alias** of `left.add_neg`. (Score: 0.7983)
**Alias** of `left.add_neg'`. (Score: 0.7962)


======================


PROMPT: Scalar multiplication (by possibly different types) of a balanced set is monotone.


Top 10 most similar prompts from the entire corpus:
Scalar multiplication (by possibly different types) of a balanced set is monotone. (Score: 1.0000)
The product of two monotone functions is monotone. (Score: 0.5227)
The sum of two monotone functions is monotone. (Score: 0.5191)
The product of two strictly monotone functions is strictly monotone. (Score: 0.5160)
`affine_span` is monotone. (Score: 0.5090)
The sum of two strictly monotone functions is strictly monotone. (Score: 0.5071)
The union of `{0}` with the interior of a balanced set is balanced. (Score: 0.5046)
Seminorm-balls at the origin are balanced. (Score: 0.4972)
A balanced set absorbs itself. (Score: 0.4964)
The product of a monotone function and a strictly monotone function is strictly monotone. (Score: 0.4945)


======================


PROMPT:  An equivalent characterization for right lifting with respect to a map `i` whose source is initial. ∅ → X ↓   ↓ B → Y has a lifting iff there is a map B → X making the right part commute.


Top 10 most similar prompts from the entire corpus:
 An equivalent characterization for right lifting with respect to a map `i` whose source is initial. ∅ → X ↓   ↓ B → Y has a lifting iff there is a map B → X making the right part commute. (Score: 1.0000)
 Any isomorphism has the right lifting property with respect to any map. A    → X ↓i    ↓p≅ B    → Y (Score: 0.7322)
Any identity has the right lifting property with respect to any map. (Score: 0.7018)
Auxiliary lemma for `lift`. (Score: 0.5998)
 Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, if a `comm_monoid` map `g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N, v w : P`, we have `f.lift hg z * w = v ↔ g x * w = g y * v`, where `x : M, y ∈ S` are such that `z * f y = f x`. (Score: 0.5700)
Given a localization map `f : M →+ N` for a submonoid `S ⊆ M`, if an `add_comm_monoid` map `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all `z : N, v : P`, we have `f.lift hg z = v ↔ g x = g y + v`, where `x : M, y ∈ S` are such that `z + f y = f x`. (Score: 0.5672)
Given a localization map `f : M →+ N` for a submonoid `S ⊆ M`, if an `add_comm_monoid` map `g : M →+ P` induces a map `f.lift hg : N →+ P` then for all `z : N, v w : P`, we have `f.lift hg z + w = v ↔ g x + w = g y + v`, where `x : M, y ∈ S` are such that `z + f y = f x`. (Score: 0.5655)
 Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, if a `comm_monoid` map `g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N, v : P`, we have `f.lift hg z = v ↔ g x = g y * v`, where `x : M, y ∈ S` are such that `z * f y = f x`. (Score: 0.5647)
 Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, if a `comm_monoid` map `g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N`, we have `f.lift hg z * g y = g x`, where `x : M, y ∈ S` are such that `z * f y = f x`. (Score: 0.5642)
 Given a localization map `f : M →* N` for a submonoid `S ⊆ M`, if a `comm_monoid` map `g : M →* P` induces a map `f.lift hg : N →* P` then for all `z : N`, we have `g y * f.lift hg z = g x`, where `x : M, y ∈ S` are such that `z * f y = f x`. (Score: 0.5626)


======================


PROMPT: Assumes left covariance.


Top 10 most similar prompts from the entire corpus:
Assumes left covariance. (Score: 1.0000)
Assumes left covariance. (Score: 1.0000)
Assumes left covariance. (Score: 1.0000)
Assumes left covariance. (Score: 1.0000)
Assumes left covariance. (Score: 1.0000)
Assumes left covariance. (Score: 1.0000)
Assumes left covariance. (Score: 1.0000)
Assumes left covariance. (Score: 1.0000)
Assumes left covariance. (Score: 1.0000)
Assumes left covariance. (Score: 1.0000)


======================


PROMPT:  If `m` is a proper divisor of `n`, then `X ^ m - 1` divides `∏ i in nat.proper_divisors n, cyclotomic i R`.


Top 10 most similar prompts from the entire corpus:
 If `m` is a proper divisor of `n`, then `X ^ m - 1` divides `∏ i in nat.proper_divisors n, cyclotomic i R`. (Score: 1.0000)
`∏ i in nat.divisors n, cyclotomic i R = X ^ n - 1`. (Score: 0.7808)
 If there is a primitive `n`-th root of unity in `K`, then `∏ i in nat.divisors n, cyclotomic' i K = X ^ n - 1`. (Score: 0.7163)
 If there is a primitive `n`-th root of unity in `K`, then `cyclotomic' n K = (X ^ k - 1) /ₘ (∏ i in nat.proper_divisors k, cyclotomic' i K)`. (Score: 0.6876)
 We have `cyclotomic n R = (X ^ k - 1) /ₘ (∏ i in nat.proper_divisors k, cyclotomic i K)`. (Score: 0.6843)
If `n ≠ m`, then `(cyclotomic n ℚ)` and `(cyclotomic m ℚ)` are coprime. (Score: 0.6416)
The degree of `cyclotomic n R` is positive. (Score: 0.6358)
 The natural degree of `cyclotomic' n R` is `totient n` if there is a primitive root of unity in `R`. (Score: 0.6263)
The degree of `cyclotomic' n R` is `totient n` if there is a primitive root of unity in `R`. (Score: 0.6227)
 If `R` is of characteristic `p` and `¬p ∣ m`, then `cyclotomic (p ^ k * m) R = (cyclotomic m R) ^ (p ^ k - p ^ (k - 1))`. (Score: 0.6110)


======================


PROMPT: `e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`.


Top 10 most similar prompts from the entire corpus:
`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`. (Score: 1.0000)
`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`. (Score: 1.0000)
`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`. (Score: 0.9820)
`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`. (Score: 0.9820)
By definition, if `f` is invertible then `inverse f = f.symm`. (Score: 0.5687)
If `u` is a solution to `E` and `init` designates its first `E.order` values,  then `u = E.mk_sol init`. This proves that `E.mk_sol init` is the only solution  of `E` whose first `E.order` values are given by `init`. (Score: 0.5662)
Abbreviation for `single_eq_of_ne h.symm`, for ease of use by `simp`. (Score: 0.5521)
 If `e` is also a permutation, we can write `perm_congr` completely in terms of the group structure. (Score: 0.5445)
If `u` is a solution to `E` and `init` designates its first `E.order` values,  then `∀ n, u n = E.mk_sol init n`. (Score: 0.5416)
Abbreviation for `mul_single_eq_of_ne h.symm`, for ease of use by `simp`. (Score: 0.5170)


======================


PROMPT: `witt_vector.verschiebung` has polynomial structure given by `witt_vector.verschiebung_poly`.


Top 10 most similar prompts from the entire corpus:
`witt_vector.verschiebung` has polynomial structure given by `witt_vector.verschiebung_poly`. (Score: 1.0000)
`witt_vector.verschiebung` is a polynomial function. (Score: 0.8606)
`witt_vector.init n x` is polynomial in the coefficients of `x`. (Score: 0.7066)
Verschiebung is the same as multiplication by `p` on the ring of Witt vectors of `zmod p`. (Score: 0.6642)
Multiplication of Witt vectors is a polynomial function. (Score: 0.6479)
Addition of Witt vectors is a polynomial function. (Score: 0.6396)
A key numerical identity needed for the proof of `witt_vector.map_frobenius_poly`. (Score: 0.6312)
Over the ring `zmod (p^(n+1))`, we produce the `n+1`st Witt polynomial by expanding the `n`th Witt polynomial by `p`. (Score: 0.5830)
A key divisibility fact for the proof of `witt_vector.map_frobenius_poly`. (Score: 0.5810)
A variant of `matrix.mv_polynomial_X_map_eval₂` with a bundled `ring_hom` on the LHS. (Score: 0.5228)


======================


PROMPT: Composition by continuous linear maps on the left preserves `C^n` functions.


Top 10 most similar prompts from the entire corpus:
Composition by continuous linear maps on the left preserves `C^n` functions. (Score: 1.0000)
Composition by continuous linear maps on the right preserves `C^n` functions. (Score: 0.9931)
 Composition by continuous linear maps on the left preserves `C^n` functions in a domain at a point. (Score: 0.9677)
 Composition by continuous linear maps on the left preserves `C^n` functions in a domain at a point. (Score: 0.9677)
 Composition by continuous linear maps on the right preserves `C^n` functions at a point on a domain. (Score: 0.9588)
Composition by continuous linear maps on the left preserves `C^n` functions on domains. (Score: 0.9566)
Composition by continuous linear maps on the right preserves `C^n` functions on domains. (Score: 0.9507)
 Composition by continuous linear equivs on the right respects higher differentiability on domains. (Score: 0.7249)
 Composition by continuous linear equivs on the right respects higher differentiability at a point in a domain. (Score: 0.7205)
 Composition by continuous linear equivs on the left respects higher differentiability on domains. (Score: 0.7171)


======================


PROMPT: If `R` is an additive monoid, an element in `add_units R` is add-regular.


Top 10 most similar prompts from the entire corpus:
If `R` is an additive monoid, an element in `add_units R` is add-regular. (Score: 1.0000)
An additive unit in an additive monoid is add-regular. (Score: 0.8860)
If `R` is a monoid, an element in `Rˣ` is regular. (Score: 0.7979)
 An additive monoid `M` is finitely generated if and only if `add_monoid_algebra R M` is of finite type. (Score: 0.7507)
 If a set `S` generates an additive monoid `M`, then the image of `M` generates, as algebra, `add_monoid_algebra R M`. (Score: 0.7264)
The set of natural number multiples of an element of an `add_monoid` is closed under addition. (Score: 0.7161)
An additive monoid homomorphism preserves addition. (Score: 0.7012)
A unit in a monoid is regular. (Score: 0.6978)
Right multiplication in a ring is an additive monoid morphism. (Score: 0.6852)
The sum of a multiset of elements of an `add_submonoid` of an `add_comm_monoid` is an element of the `add_submonoid`. (Score: 0.6825)


======================


PROMPT: A space is quasi sober if it can be covered by open quasi sober subsets.


Top 10 most similar prompts from the entire corpus:
A space is quasi sober if it can be covered by open quasi sober subsets. (Score: 1.0000)
 If `X` is a normal topological space and `U i`, `i : ι`, is a locally finite open covering of a closed set `s`, then there exists a `bump_covering ι X s` that is subordinate to `U`. If `X` is a paracompact space, then the assumption `hf : locally_finite U` can be omitted, see `bump_covering.exists_is_subordinate`. This version assumes that `p : (X → ℝ) → Prop` is a predicate that satisfies Urysohn's lemma, and provides a `bump_covering` such that each function of the covering satisfies `p`. (Score: 0.4853)
 If `X` is a paracompact normal topological space and `U` is an open covering of a closed set `s`, then there exists a `bump_covering ι X s` that is subordinate to `U`. This version assumes that `p : (X → ℝ) → Prop` is a predicate that satisfies Urysohn's lemma, and provides a `bump_covering` such that each function of the covering satisfies `p`. (Score: 0.4726)
 Given an inducing map of a topological space into a pseudo metrizable space, the source space is also pseudo metrizable. (Score: 0.4654)
The basic open sets for the topology on ultrafilters are open. (Score: 0.4589)
 If `X` is a normal topological space and `U i`, `i : ι`, is a locally finite open covering of a closed set `s`, then there exists a `bump_covering ι X s` that is subordinate to `U`. If `X` is a paracompact space, then the assumption `hf : locally_finite U` can be omitted, see `bump_covering.exists_is_subordinate`. (Score: 0.4519)
 For point `x` in a discrete subset `s` of a topological space, there is a set `U` such that 1. `U` is a punctured neighborhood of `x` (ie. `U ∪ {x}` is a neighbourhood of `x`), 2. `U` is disjoint from `s`. (Score: 0.4481)
 In a second-countable space, an open set, given as a union of open sets, is equal to the union of countably many of those sets. (Score: 0.4469)
 A countable open cover induces a second-countable topology if all open covers are themselves second countable. (Score: 0.4442)
 Let `s` be a dense set in a topological space `α` with partial order structure. If `s` is a separable space (e.g., if `α` has a second countable topology), then there exists a countable dense subset `t ⊆ s` such that `t` contains bottom/top element of `α` when they exist and belong to `s`. For a dense subset containing neither bot nor top elements, see `dense.exists_countable_dense_subset_no_bot_top`. (Score: 0.4395)


======================


PROMPT: Every matrix indexed by a subsingleton is diagonal.


Top 10 most similar prompts from the entire corpus:
Every matrix indexed by a subsingleton is diagonal. (Score: 1.0000)
Every identity matrix is diagonal. (Score: 0.6999)
If `A` is subterminal, its diagonal morphism is an isomorphism. The converse of `is_subterminal_of_is_iso_diag`. (Score: 0.6342)
Every zero matrix is diagonal. (Score: 0.6329)
If the diagonal morphism of `A` is an isomorphism, then it is subterminal. The converse of `is_subterminal.is_iso_diag`. (Score: 0.6039)
Given a `(m × m)` diagonal matrix defined by a map `d : m → α`, if the reindexing map `e` is  injective, then the resulting matrix is again diagonal. (Score: 0.5932)
Diagonal matrices are generated by the `matrix.diagonal` of their `matrix.diag`. (Score: 0.5839)
The diagonal matrix `diagonal v` is symmetric. (Score: 0.5599)
 The union of an entourage of the diagonal in each set of a disjoint union is again an entourage of the diagonal. (Score: 0.5542)
Any matrix can be reduced to diagonal form by elementary operations. (Score: 0.5080)


======================


PROMPT: Expressing locally uniform convergence using `dist`.


Top 10 most similar prompts from the entire corpus:
Expressing locally uniform convergence using `dist`. (Score: 1.0000)
Expressing locally uniform convergence on a set using `dist`. (Score: 0.9542)
Expressing uniform convergence using `dist`. (Score: 0.9237)
Expressing uniform convergence on a set using `dist`. (Score: 0.8811)
Expressing locally uniform convergence using `edist`. (Score: 0.8097)
Expressing locally uniform convergence on a set using `edist`. (Score: 0.7824)
Expressing uniform convergence using `edist`. (Score: 0.7202)
Expressing uniform convergence on a set using `edist`. (Score: 0.7123)
On a compact space, locally uniform convergence is just uniform convergence. (Score: 0.6315)
Composing on the right by a function preserves uniform convergence (Score: 0.6156)
