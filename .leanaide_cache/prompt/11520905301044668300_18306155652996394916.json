[["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.Limits.HasZeroObject C] → Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.96527980292518122951150871813297271728515625}],[" The center of the group of units of a `GroupWithZero` type `M` equals the preimage of the center of `M` under the underlying value function.",{"type":"∀ {M : Type u_1} [inst : GroupWithZero M], Set.center Mˣ = Units.val ⁻¹' Set.center M","name":"Set.center_units_eq","isProp":true,"docString":" The center of the group of units of a `GroupWithZero` type `M` equals the preimage of the center of `M` under the underlying value function.","distance":1.9798827042230568995506700957776047289371490478515625}],["This theorem, `neg_zero`, states that for any type `G` that is a member of the `NegZeroClass`, the negation of zero equals zero. In mathematical terms, it means that if `G` has a negation operation and a zero element, then the negation of the zero element is equal to the zero element itself.",{"type":"∀ {G : Type u_1} [inst : NegZeroClass G], -0 = 0","name":"neg_zero","isProp":true,"docString":"This theorem, `neg_zero`, states that for any type `G` that is a member of the `NegZeroClass`, the negation of zero equals zero. In mathematical terms, it means that if `G` has a negation operation and a zero element, then the negation of the zero element is equal to the zero element itself.","distance":1.9901867061662705804536699361051432788372039794921875}],["Computes `⌊max 0 (log₂ n)⌋`.\n\n`log2 0 = log2 1 = 0`, `log2 2 = 1`, ..., `log2 (2^i) = i`, etc.\n",{"type":"ℕ → ℕ","name":"Nat.log2","isProp":false,"docString":"Computes `⌊max 0 (log₂ n)⌋`.\n\n`log2 0 = log2 1 = 0`, `log2 2 = 1`, ..., `log2 (2^i) = i`, etc.\n","distance":1.966927224410021768363776573096401989459991455078125}],[" In a Henstock prepartition, the number of boxes with the same tag value under the tagging function is bounded by 2 raised to the power of the number of indices.",{"type":"∀ {ι : Type u_1} {I : BoxIntegral.Box ι} {π : BoxIntegral.TaggedPrepartition I} [inst : Fintype ι],\n  π.IsHenstock → ∀ (x : ι → ℝ), (Finset.filter (fun J => π.tag J = x) π.boxes).card ≤ 2 ^ Fintype.card ι","name":"BoxIntegral.TaggedPrepartition.IsHenstock.card_filter_tag_eq_le","isProp":true,"docString":" In a Henstock prepartition, the number of boxes with the same tag value under the tagging function is bounded by 2 raised to the power of the number of indices.","distance":1.987450021132659561118316560168750584125518798828125}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":1.9920307995983586035748658105148933827877044677734375}],["An estimator for the priority of the key.\n(We will assume we have `[∀ a : α, Estimator (prio a) (ε a)]`.) ",{"type":"{α : Sort u_1} → {ω : Type u_2} → {prio : α → Thunk ω} → {ε : α → Type} → (self : BestFirstNode prio ε) → ε self.key","name":"BestFirstNode.estimator","isProp":false,"docString":"An estimator for the priority of the key.\n(We will assume we have `[∀ a : α, Estimator (prio a) (ε a)]`.) ","distance":1.9705800431769879832444303247029893100261688232421875}],["If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ",{"type":"{α : Type u} → Task α → α","name":"Task.get","isProp":false,"docString":"If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ","distance":1.9717203890633026031053987026098184287548065185546875}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9720199521461083680407000429113395512104034423828125}],["Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ",{"type":"{E : ℕ → Type u_2} → ((n : ℕ) → E n) → Set ((n : ℕ) → E n) → ℕ","name":"PiNat.longestPrefix","isProp":false,"docString":"Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ","distance":1.9727901996282837249196973061771132051944732666015625}],["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] → [inst_1 : MetricSpace P] → [inst_2 : NormedAddTorsor V P] → AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.976854706804306527345715949195437133312225341796875}],["Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n",{"type":"(α : Sort u) → α → Sort u","name":"optParam","isProp":false,"docString":"Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n","distance":1.9782978694047728129845609146286733448505401611328125}],["**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConvexOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → f z ≤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_segment","isProp":true,"docString":"**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9785874334472028923670450240024365484714508056640625}],["Retrieves the value of `a : Part α` if it exists, and return the provided default value\notherwise. ",{"type":"{α : Type u_1} → (a : Part α) → [inst : Decidable a.Dom] → α → α","name":"Part.getOrElse","isProp":false,"docString":"Retrieves the value of `a : Part α` if it exists, and return the provided default value\notherwise. ","distance":1.9788101480072450844005516046308912336826324462890625}],["Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ",{"type":"{α : Prop} → {p : α → Prop} → {C : Sort u_1} → C → ((a : α) → p a → C) → C","name":"Classical.existsCases","isProp":false,"docString":"Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ","distance":1.9794636130770688620117425671196542680263519287109375}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData → Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":1.9809652594270434899925703575718216598033905029296875}],["Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n",{"type":"Lean.ParserDescr","name":"Mathlib.CountHeartbeats.commandCount_heartbeatsIn__","isProp":false,"docString":"Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n","distance":1.9810461448749736579344471465446986258029937744140625}],["Returns the current max variable. ",{"type":"Linarith.LinarithM ℕ","name":"Linarith.getMaxVar","isProp":false,"docString":"Returns the current max variable. ","distance":1.98173639908535204057216105866245925426483154296875}],["Name to use for the declaration for a type that is `Equiv` to the given type. ",{"type":"Mathlib.ProxyType.ProxyEquivConfig → Lean.Name","name":"Mathlib.ProxyType.ProxyEquivConfig.proxyName","isProp":false,"docString":"Name to use for the declaration for a type that is `Equiv` to the given type. ","distance":1.98249596657847870773139220545999705791473388671875}],["Converts an `Int` to a `ZNum`. ",{"type":"ℤ → ZNum","name":"ZNum.ofInt'","isProp":false,"docString":"Converts an `Int` to a `ZNum`. ","distance":1.9830715964883911528460203044232912361621856689453125}],["`f : α →+* β` has a trivial codomain iff its range is `{0}`. ",{"type":"∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β),\n  0 = 1 ↔ Set.range ⇑f = {0}","name":"RingHom.codomain_trivial_iff_range_eq_singleton_zero","isProp":true,"docString":"`f : α →+* β` has a trivial codomain iff its range is `{0}`. ","distance":1.9833918255821647580461331017431803047657012939453125}],["`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n",{"type":"{α : Sort u} → [i : α] → α","name":"inferInstance","isProp":false,"docString":"`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n","distance":1.983543773460036963030006518238224089145660400390625}],["An arbitrary `RayVector` giving a ray. ",{"type":"{R : Type u_1} →\n  [inst : StrictOrderedCommSemiring R] →\n    {M : Type u_2} → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Module.Ray R M → RayVector R M","name":"Module.Ray.someRayVector","isProp":false,"docString":"An arbitrary `RayVector` giving a ray. ","distance":1.9837130169563457204873202499584294855594635009765625}],["Given two integers, return their GCD and an equality proof.\nPanics if `ex` or `ey` aren't integer literals. ",{"type":"(ex ey : Q(ℤ)) → (ed : Q(ℕ)) × Q(Int.gcd «$ex» «$ey» = «$ed»)","name":"Tactic.NormNum.proveIntGCD","isProp":false,"docString":"Given two integers, return their GCD and an equality proof.\nPanics if `ex` or `ey` aren't integer literals. ","distance":1.984219614341645954169734977767802774906158447265625}]]