[["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ interior (⇑(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9608541716702860835397359551279805600643157958984375}],[" For any compact set in a metric space and any open cover, there exists a positive number δ such that for each point in the set, there is an open set in the cover containing a ball of radius δ around that point.",{"type":"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {ι : Sort u_3} {c : ι → Set α},\n  IsCompact s → (∀ (i : ι), IsOpen (c i)) → s ⊆ ⋃ i, c i → ∃ δ > 0, ∀ x ∈ s, ∃ i, Metric.ball x δ ⊆ c i","name":"lebesgue_number_lemma_of_metric","isProp":true,"docString":" For any compact set in a metric space and any open cover, there exists a positive number δ such that for each point in the set, there is an open set in the cover containing a ball of radius δ around that point.","distance":1.99881592703102572983198115252889692783355712890625}],["This theorem states that for any positive number `n` of type `PosNum`, the double coercion of `n` to natural number and then to integer is equal to the direct coercion of `n` to integer. Essentially, it ensures that converting a positive number to a natural number and then to an integer yields the same result as directly converting the positive number to an integer.",{"type":"∀ (n : PosNum), ↑↑n = ↑n","name":"PosNum.to_nat_to_int","isProp":true,"docString":"This theorem states that for any positive number `n` of type `PosNum`, the double coercion of `n` to natural number and then to integer is equal to the direct coercion of `n` to integer. Essentially, it ensures that converting a positive number to a natural number and then to an integer yields the same result as directly converting the positive number to an integer.","distance":1.999437014275683655029069996089674532413482666015625}],["A link that, when clicked, makes the specified edit\nand potentially moves the cursor\nor makes a selection. ",{"type":"ProofWidgets.Component ProofWidgets.MakeEditLinkProps","name":"ProofWidgets.MakeEditLink","isProp":false,"docString":"A link that, when clicked, makes the specified edit\nand potentially moves the cursor\nor makes a selection. ","distance":1.963106095257102001738758190185762941837310791015625}],[" For all natural numbers n, pred(1 + n) = n.",{"type":"∀ (n : ℕ), (1 + n).pred = n","name":"Nat.pred_one_add","isProp":true,"docString":" For all natural numbers n, pred(1 + n) = n.","distance":2.000367448732760511376227441360242664813995361328125}],["The theorem `Nat.Linear.ExprCnstr.denote_toNormPoly` states that for any context from the set of natural numbers (`Nat.Linear.Context`) and any expression constraint (`Nat.Linear.ExprCnstr`), the denotation of the normalized polynomial constraint derived from this expression constraint (`Nat.Linear.ExprCnstr.toNormPoly c`) within the given context is equivalent to the denotation of the original expression constraint within the same context (`Nat.Linear.ExprCnstr.denote ctx c`). In simple terms, normalizing an expression constraint does not change its denotation (interpretation) within a given context.",{"type":"∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx c.toNormPoly = Nat.Linear.ExprCnstr.denote ctx c","name":"Nat.Linear.ExprCnstr.denote_toNormPoly","isProp":true,"docString":"The theorem `Nat.Linear.ExprCnstr.denote_toNormPoly` states that for any context from the set of natural numbers (`Nat.Linear.Context`) and any expression constraint (`Nat.Linear.ExprCnstr`), the denotation of the normalized polynomial constraint derived from this expression constraint (`Nat.Linear.ExprCnstr.toNormPoly c`) within the given context is equivalent to the denotation of the original expression constraint within the same context (`Nat.Linear.ExprCnstr.denote ctx c`). In simple terms, normalizing an expression constraint does not change its denotation (interpretation) within a given context.","distance":2.002252970540357779327678144909441471099853515625}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ ⇑(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9688295634840979886348577565513551235198974609375}],["`castPosNum` casts a `PosNum` into any type which has `1` and `+`. ",{"type":"{α : Type u_1} → [inst : One α] → [inst : Add α] → PosNum → α","name":"castPosNum","isProp":false,"docString":"`castPosNum` casts a `PosNum` into any type which has `1` and `+`. ","distance":1.9690754260652052476388007562491111457347869873046875}],["Which textual range to select after the edit.\nThe range is interpreted in the file that `edit` applies to.\nIf present and `start == end`, the cursor is moved to `start` and nothing is selected.\nIf not present, the selection is not changed. ",{"type":"ProofWidgets.MakeEditLinkProps → Option Lean.Lsp.Range","name":"ProofWidgets.MakeEditLinkProps.newSelection?","isProp":false,"docString":"Which textual range to select after the edit.\nThe range is interpreted in the file that `edit` applies to.\nIf present and `start == end`, the cursor is moved to `start` and nothing is selected.\nIf not present, the selection is not changed. ","distance":1.9694291455456423012293498686631210148334503173828125}],["Converts a `ZNum` to a `PosNum`, mapping all out of range values to `1`. ",{"type":"ZNum → PosNum","name":"PosNum.ofZNum","isProp":false,"docString":"Converts a `ZNum` to a `PosNum`, mapping all out of range values to `1`. ","distance":1.969560599388691546351992656127549707889556884765625}],["the condition that `premap` is in the presieve ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {F : CategoryTheory.Functor C D} {X : C} {S : CategoryTheory.Presieve X} {Y : D} {f : Y ⟶ F.obj X}\n  (self : CategoryTheory.Presieve.FunctorPushforwardStructure F S f), S self.premap","name":"CategoryTheory.Presieve.FunctorPushforwardStructure.cover","isProp":true,"docString":"the condition that `premap` is in the presieve ","distance":1.9734437789511487526539212922216393053531646728515625}],["The universal set `Set.univ` in a preconnected space is a preconnected set. ",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] [self : PreconnectedSpace α], IsPreconnected Set.univ","name":"PreconnectedSpace.isPreconnected_univ","isProp":true,"docString":"The universal set `Set.univ` in a preconnected space is a preconnected set. ","distance":1.9743442300196785144095201758318580687046051025390625}],["The predecessor of a `PosNum` as a `Num`. ",{"type":"PosNum → Num","name":"PosNum.pred'","isProp":false,"docString":"The predecessor of a `PosNum` as a `Num`. ","distance":1.975794367802648832110889998148195445537567138671875}],["Right-shift the binary representation of a `PosNum`. ",{"type":"PosNum → ℕ → Num","name":"PosNum.shiftr","isProp":false,"docString":"Right-shift the binary representation of a `PosNum`. ","distance":1.976130869433084580322201873059384524822235107421875}],["Convert a pre-set to a `set` of pre-sets. ",{"type":"PSet → Set PSet","name":"PSet.toSet","isProp":false,"docString":"Convert a pre-set to a `set` of pre-sets. ","distance":1.9763089189813580759391697938553988933563232421875}],["Converts `x : Num` to `-x : ZNum`. ",{"type":"Num → ZNum","name":"Num.toZNumNeg","isProp":false,"docString":"Converts `x : Num` to `-x : ZNum`. ","distance":1.9781386116260193386295895834336988627910614013671875}],["This is the `List.sum` version of `add_neg`",{"type":"∀ {G : Type u_7} [inst : AddCommGroup G] (L : List G), -List.sum L = List.sum (List.map (fun x => -x) L)","name":"List.sum_neg","isProp":true,"docString":"This is the `List.sum` version of `add_neg`","distance":1.9790967239253645093555178391397930681705474853515625}],["**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ",{"type":"{α : Type u_1} → Ordnode α → α → Ordnode α → Ordnode α","name":"Ordnode.node'","isProp":false,"docString":"**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ","distance":1.980339913761241188439043980906717479228973388671875}],["The restriction of a presheafed space along an open embedding into the space.\n",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {U : TopCat} →\n      (X : AlgebraicGeometry.PresheafedSpace C) → {f : U ⟶ ↑X} → OpenEmbedding ⇑f → AlgebraicGeometry.PresheafedSpace C","name":"AlgebraicGeometry.PresheafedSpace.restrict","isProp":false,"docString":"The restriction of a presheafed space along an open embedding into the space.\n","distance":1.981288358943336991302430760697461664676666259765625}],["Restrict a prepartition to a box. ",{"type":"{ι : Type u_1} →\n  {I : BoxIntegral.Box ι} → BoxIntegral.Prepartition I → (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J","name":"BoxIntegral.Prepartition.restrict","isProp":false,"docString":"Restrict a prepartition to a box. ","distance":1.9842192157217566350624338156194426119327545166015625}],["Left-shift the binary representation of a `PosNum`. ",{"type":"PosNum → ℕ → PosNum","name":"PosNum.shiftl","isProp":false,"docString":"Left-shift the binary representation of a `PosNum`. ","distance":1.984430405283517995229658481548540294170379638671875}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name → Array Simps.ParsedProjectionData → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.9847248432649811089589775292552076280117034912109375}],["`centroidWeights` gives the weights for the centroid as a\nconstant function, which is suitable when summing over the points\nwhose centroid is being taken.  This function gives the weights in a\nform suitable for summing over a larger set of points, as an indicator\nfunction that is zero outside the set whose centroid is being taken.\nIn the case of a `Fintype`, the sum may be over `univ`. ",{"type":"(k : Type u_1) → [inst : DivisionRing k] → {ι : Type u_4} → Finset ι → ι → k","name":"Finset.centroidWeightsIndicator","isProp":false,"docString":"`centroidWeights` gives the weights for the centroid as a\nconstant function, which is suitable when summing over the points\nwhose centroid is being taken.  This function gives the weights in a\nform suitable for summing over a larger set of points, as an indicator\nfunction that is zero outside the set whose centroid is being taken.\nIn the case of a `Fintype`, the sum may be over `univ`. ","distance":1.985553788997834079310678134788759052753448486328125}],["The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. ",{"type":"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) {s₁ s₂ : Finset ι},\n  s₁ ⊆ s₂ → (Finset.weightedVSub s₁ p) w = (Finset.weightedVSub s₂ p) (Set.indicator (↑s₁) w)","name":"Finset.weightedVSub_indicator_subset","isProp":true,"docString":"The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. ","distance":1.9856820863596487125590783762163482606410980224609375}]]