[["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9310949251474642807124837418086826801300048828125}],[" Given a simple graph and replacing a vertex with another non-equal vertex preserves adjacency for all other vertices.",{"type":"∀ {V : Type u_1} [inst : DecidableEq V] (G : SimpleGraph V) (s : V) {t w : V},\n  w ≠ t → ((G.replaceVertex s t).Adj s w ↔ G.Adj s w)","name":"SimpleGraph.adj_replaceVertex_iff_of_ne_left","isProp":true,"docString":" Given a simple graph and replacing a vertex with another non-equal vertex preserves adjacency for all other vertices.","distance":1.94357882232204826067345493356697261333465576171875}],["This theorem states that for all types `α` and for any set `a` of type `α`, the intersection of the universal set `Set.univ` with the set `a` is equal to `a` itself. In other words, when you intersect any set with the universal set (which contains all elements of the type), you simply get the original set back. In mathematical notation, this can be written as: ∀α, ∀a ∈ Set α, Set.univ ∩ a = a.",{"type":"∀ {α : Type u} (a : Set α), Set.univ ∩ a = a","name":"Set.univ_inter","isProp":true,"docString":"This theorem states that for all types `α` and for any set `a` of type `α`, the intersection of the universal set `Set.univ` with the set `a` is equal to `a` itself. In other words, when you intersect any set with the universal set (which contains all elements of the type), you simply get the original set back. In mathematical notation, this can be written as: ∀α, ∀a ∈ Set α, Set.univ ∩ a = a.","distance":1.962924771590638162166442270972765982151031494140625}],["Insert a new name alignment into the rename extension. ",{"type":"Lean.Name → Lean.Name → optParam Bool false → optParam String \"\" → Lean.CoreM Unit","name":"Mathlib.Prelude.Rename.addNameAlignment","isProp":false,"docString":"Insert a new name alignment into the rename extension. ","distance":1.932578932434480645241592355887405574321746826171875}],[" For any type `α` and any `x : α`, `x ∈ Set.univ (α)`.",{"type":"∀ {α : Type u} (x : α), x ∈ Set.univ","name":"Set.mem_univ","isProp":true,"docString":" For any type `α` and any `x : α`, `x ∈ Set.univ (α)`.","distance":1.9440639205088687813116621327935717999935150146484375}],["This theorem states that the process of taking the equivalence closure of a relation is idempotent. In other words, for any type `α` and any relation `r` on `α`, taking the equivalence closure of the equivalence closure of `r` (that is, `EqvGen.Setoid (EqvGen.Setoid r).Rel`) is the same as taking the equivalence closure of `r` once (that is, `EqvGen.Setoid r`). This means applying the operation of taking the equivalence closure twice does not change the result beyond the initial application.",{"type":"∀ {α : Type u_1} (r : α → α → Prop), EqvGen.Setoid (EqvGen.Setoid r).Rel = EqvGen.Setoid r","name":"Setoid.eqvGen_idem","isProp":true,"docString":"This theorem states that the process of taking the equivalence closure of a relation is idempotent. In other words, for any type `α` and any relation `r` on `α`, taking the equivalence closure of the equivalence closure of `r` (that is, `EqvGen.Setoid (EqvGen.Setoid r).Rel`) is the same as taking the equivalence closure of `r` once (that is, `EqvGen.Setoid r`). This means applying the operation of taking the equivalence closure twice does not change the result beyond the initial application.","distance":1.967403111396340165129004162736237049102783203125}],["We verify that the presheaf representing natural transformations\nbetween `Type v`-enriched functors is actually represented by\nthe usual type of natural transformations!\n",{"type":"{C : Type v} →\n  [inst : CategoryTheory.EnrichedCategory (Type v) C] →\n    {D : Type v} →\n      [inst_1 : CategoryTheory.EnrichedCategory (Type v) D] →\n        (F G : CategoryTheory.EnrichedFunctor (Type v) C D) →\n          CategoryTheory.enrichedNatTransYoneda F G ≅\n            CategoryTheory.yoneda.obj\n              (CategoryTheory.enrichedFunctorTypeEquivFunctor F ⟶ CategoryTheory.enrichedFunctorTypeEquivFunctor G)","name":"CategoryTheory.enrichedNatTransYonedaTypeIsoYonedaNatTrans","isProp":false,"docString":"We verify that the presheaf representing natural transformations\nbetween `Type v`-enriched functors is actually represented by\nthe usual type of natural transformations!\n","distance":1.934960443313682443289280854514800012111663818359375}],["Turn `ParsedProjectionData` into `ProjectionData`. ",{"type":"Simps.ParsedProjectionData → Simps.ProjectionData","name":"Simps.ParsedProjectionData.toProjectionData","isProp":false,"docString":"Turn `ParsedProjectionData` into `ProjectionData`. ","distance":1.9382857176747858574117344687692821025848388671875}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ interior (⇑(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9397398365774718431708834032178856432437896728515625}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ ⇑(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.93999488870962988329438303480856120586395263671875}],["See Note [custom simps projection]. We specify this explicitly because we don't have a DFunLike\ninstance.\n",{"type":"{α : Type u} →\n  {β : Type v} → [inst : OmegaCompletePartialOrder α] → [inst_1 : OmegaCompletePartialOrder β] → (α →𝒄 β) → α → β","name":"OmegaCompletePartialOrder.ContinuousHom.Simps.apply","isProp":false,"docString":"See Note [custom simps projection]. We specify this explicitly because we don't have a DFunLike\ninstance.\n","distance":1.943673989144506730752937073702923953533172607421875}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name → Bool) → Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.94372343380156653580570491612888872623443603515625}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name → Array Simps.ParsedProjectionData → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.946328904947886240250909395399503409862518310546875}],["Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ",{"type":"(X : AlgebraicGeometry.Scheme) → AlgebraicGeometry.IsAffine X → AlgebraicGeometry.AffineScheme","name":"AlgebraicGeometry.AffineScheme.mk","isProp":false,"docString":"Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ","distance":1.94721508011213639832703847787342965602874755859375}],["Evaluates the `SetM` monad, yielding a `Set`.\nImplementation note: this is the identity function. ",{"type":"{α : Type u_1} → SetM α → Set α","name":"SetM.run","isProp":false,"docString":"Evaluates the `SetM` monad, yielding a `Set`.\nImplementation note: this is the identity function. ","distance":1.949336236734354077526631954242475330829620361328125}],["An embedding `e : α ↪ β` defines an embedding `(α → γ) ↪ (β → γ)` for any inhabited type `γ`.\nThis embedding sends each `f : α → γ` to a function `g : β → γ` such that `g ∘ e = f` and\n`g y = default` whenever `y ∉ range e`. ",{"type":"{α : Sort u} → {β : Sort v} → {γ : Sort w} → [inst : Inhabited γ] → (α ↪ β) → (α → γ) ↪ β → γ","name":"Function.Embedding.arrowCongrLeft","isProp":false,"docString":"An embedding `e : α ↪ β` defines an embedding `(α → γ) ↪ (β → γ)` for any inhabited type `γ`.\nThis embedding sends each `f : α → γ` to a function `g : β → γ` such that `g ∘ e = f` and\n`g y = default` whenever `y ∉ range e`. ","distance":1.951750877269218253928784179151989519596099853515625}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name → Simps.ParsedProjectionData → List Lean.Level → Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.951765007209891766848386396304704248905181884765625}],["**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ",{"type":"{α : Type u_1} → Ordnode α → α → Ordnode α → Ordnode α","name":"Ordnode.node'","isProp":false,"docString":"**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ","distance":1.9532032758318014220577651940402574837207794189453125}],["Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n",{"type":"{ω : Type u_1} →\n  {α : Type} →\n    (prio : α → Thunk ω) →\n      (ε : α → Type) →\n        [inst : LinearOrder ω] →\n          [inst_1 : (a : α) → Estimator (prio a) (ε a)] →\n            [I : ∀ (a : α), WellFoundedGT ↑(Set.range (EstimatorData.bound (prio a)))] →\n              [inst : Ord ω] →\n                [inst : Ord α] →\n                  {m : Type → Type} →\n                    [inst : Monad m] →\n                      [inst : Alternative m] →\n                        [inst : (a : α) → Bot (ε a)] → Option ℕ → (α → MLList m α) → α → MLList m α","name":"impl","isProp":false,"docString":"Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n","distance":1.953594139104767979375765207805670797824859619140625}],["Given an embedding of a topological space into a metrizable space, the source space is also\nmetrizable. ",{"type":"∀ {X : Type u_2} {Y : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : TopologicalSpace.MetrizableSpace Y] {f : X → Y}, Embedding f → TopologicalSpace.MetrizableSpace X","name":"Embedding.metrizableSpace","isProp":true,"docString":"Given an embedding of a topological space into a metrizable space, the source space is also\nmetrizable. ","distance":1.953976270037243612165411832393147051334381103515625}],["The universal set `Set.univ` in a preconnected space is a preconnected set. ",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] [self : PreconnectedSpace α], IsPreconnected Set.univ","name":"PreconnectedSpace.isPreconnected_univ","isProp":true,"docString":"The universal set `Set.univ` in a preconnected space is a preconnected set. ","distance":1.954396850591181067358093059738166630268096923828125}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{α : Type v} → Quotient.out (Cardinal.mk α) ≃ α","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":1.9549367379188617999119514934136532247066497802734375}],["The universal enveloping group for the rack R.\n",{"type":"(R : Type u_1) → [inst : Rack R] → Type u_1","name":"Rack.EnvelGroup","isProp":false,"docString":"The universal enveloping group for the rack R.\n","distance":1.9553227269253061759712863931781612336635589599609375}],["We verify that an enriched category in `Type u` is just the same thing as an honest category.\n",{"type":"(C : Type u₁) → CategoryTheory.EnrichedCategory (Type v) C ≃ CategoryTheory.Category.{v, u₁} C","name":"CategoryTheory.enrichedCategoryTypeEquivCategory","isProp":false,"docString":"We verify that an enriched category in `Type u` is just the same thing as an honest category.\n","distance":1.9554540931255843805303129556705243885517120361328125}]]