[["The set of vectors in the direction of a nonempty affine subspace is given by `vsub_set`. ",{"type":"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P}, Set.Nonempty ↑s → ↑(AffineSubspace.direction s) = ↑s -ᵥ ↑s","name":"AffineSubspace.coe_direction_eq_vsub_set","isProp":true,"docString":"The set of vectors in the direction of a nonempty affine subspace is given by `vsub_set`. ","distance":1.9517662822924746190977884907624684274196624755859375}],[" For any type `M` with a group structure, any type `α` with a `MulAction` of `M` on `α`, and a family of sets `s : ι → Sets`, the subgroup of `M` fixing the union of `s` equals the intersection of subgroups fixing each `s(i)`.",{"type":"∀ (M : Type u_1) (α : Type u_2) [inst : Group M] [inst_1 : MulAction M α] {ι : Sort u_3} {s : ι → Set α},\n  fixingSubgroup M (⋃ i, s i) = ⨅ i, fixingSubgroup M (s i)","name":"fixingSubgroup_iUnion","isProp":true,"docString":" For any type `M` with a group structure, any type `α` with a `MulAction` of `M` on `α`, and a family of sets `s : ι → Sets`, the subgroup of `M` fixing the union of `s` equals the intersection of subgroups fixing each `s(i)`.","distance":1.9481298721934319218007658491842448711395263671875}],["The theorem `Isometry.preimage_setOf_dist` states that for all types `α` and `β` that are instances of PseudoMetricSpace, for all functions `f` from `α` to `β` that are isometries, and for all `x` in `α` and predicate `p` on real numbers, the preimage of the set of elements in `β` that satisfy predicate `p` with the distance to `f(x)` under the function `f` is exactly the set of elements in `α` that satisfy predicate `p` with the distance to `x`. In simpler terms, this means that an isometry `f` preserves the property of distance: the set of points in `α` that have a certain property with respect to their distance to `x` is mapped by `f` onto the set of points in `β` that have the same property with respect to their distance to `f(x)`.",{"type":"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  Isometry f → ∀ (x : α) (p : ℝ → Prop), f ⁻¹' {y | p (dist y (f x))} = {y | p (dist y x)}","name":"Isometry.preimage_setOf_dist","isProp":true,"docString":"The theorem `Isometry.preimage_setOf_dist` states that for all types `α` and `β` that are instances of PseudoMetricSpace, for all functions `f` from `α` to `β` that are isometries, and for all `x` in `α` and predicate `p` on real numbers, the preimage of the set of elements in `β` that satisfy predicate `p` with the distance to `f(x)` under the function `f` is exactly the set of elements in `α` that satisfy predicate `p` with the distance to `x`. In simpler terms, this means that an isometry `f` preserves the property of distance: the set of points in `α` that have a certain property with respect to their distance to `x` is mapped by `f` onto the set of points in `β` that have the same property with respect to their distance to `f(x)`.","distance":1.97252170518114144925903019611723721027374267578125}],["In a real vector space of dimension `> 1`, any sphere of nonnegative radius is\npath connected. ",{"type":"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E],\n  1 < Module.rank ℝ E → ∀ (x : E) {r : ℝ}, 0 ≤ r → IsPathConnected (Metric.sphere x r)","name":"isPathConnected_sphere","isProp":true,"docString":"In a real vector space of dimension `> 1`, any sphere of nonnegative radius is\npath connected. ","distance":1.9518826132327620204165441464283503592014312744140625}],[" Given a subtractive, negatable monoid `M` with set `S` of its additive subgroups that respects scalars multiplication by integers, then `S` is a set of `M` that respects scalar multiplication by integers.",{"type":"∀ {S : Type u_1} {M : Type u_2} [inst : SubNegMonoid M] [inst_1 : SetLike S M] [inst_2 : AddSubgroupClass S M],\n  SMulMemClass S ℤ M","name":"AddSubgroupClass.zsmulMemClass","isProp":true,"docString":" Given a subtractive, negatable monoid `M` with set `S` of its additive subgroups that respects scalars multiplication by integers, then `S` is a set of `M` that respects scalar multiplication by integers.","distance":1.949820188578535340440112122450955212116241455078125}],["The theorem `MeasureTheory.SimpleFunc.measurableSet_preimage` states that for any types `α` and `β`, given a measurable space structure on `α`, a simple function `f` from `α` to `β`, and a set `s` of type `β`, the preimage of the set `s` under the function `f` is a measurable set. \n\nIn other words, if we apply the function `f` to some elements of `α` and consider the set of all such elements that map into `s`, that set of elements from `α` is measurable. This is a fundamental property in measure theory, which ensures that we can measure the \"size\" of the set of all elements that get mapped into a particular subset of the range of a simple function.",{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] (f : MeasureTheory.SimpleFunc α β) (s : Set β),\n  MeasurableSet (↑f ⁻¹' s)","name":"MeasureTheory.SimpleFunc.measurableSet_preimage","isProp":true,"docString":"The theorem `MeasureTheory.SimpleFunc.measurableSet_preimage` states that for any types `α` and `β`, given a measurable space structure on `α`, a simple function `f` from `α` to `β`, and a set `s` of type `β`, the preimage of the set `s` under the function `f` is a measurable set. \n\nIn other words, if we apply the function `f` to some elements of `α` and consider the set of all such elements that map into `s`, that set of elements from `α` is measurable. This is a fundamental property in measure theory, which ensures that we can measure the \"size\" of the set of all elements that get mapped into a particular subset of the range of a simple function.","distance":1.973504461800512199687318570795468986034393310546875}],["The base space of a vector bundle core, as a convenience function for dot notation",{"type":"{B : Type u_2} → Type u_2","name":"VectorBundleCore.Base","isProp":false,"docString":"The base space of a vector bundle core, as a convenience function for dot notation","distance":1.9524565638778932363806006833328865468502044677734375}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.95360301899524468893787343404255807399749755859375}],["The setoid of the `SameRay` relation for the subtype of nonzero vectors. ",{"type":"(R : Type u_1) →\n  [inst : StrictOrderedCommSemiring R] →\n    (M : Type u_2) → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Setoid (RayVector R M)","name":"RayVector.Setoid","isProp":false,"docString":"The setoid of the `SameRay` relation for the subtype of nonzero vectors. ","distance":1.95444642146946190308653967804275453090667724609375}],["If a subset of a real vector space contains an open segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ",{"type":"∀ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {s : Set G} {x y : G},\n  openSegment ℝ x y ⊆ s → y - x ∈ tangentConeAt ℝ s x","name":"mem_tangentCone_of_openSegment_subset","isProp":true,"docString":"If a subset of a real vector space contains an open segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ","distance":1.9546832266400395727856675875955261290073394775390625}],["If `k` is omitted from the set, its Schnirelmann density is upper bounded by `1 - k⁻¹`.\n",{"type":"∀ {A : Set ℕ} [inst : DecidablePred fun x => x ∈ A] {k : ℕ}, k ∉ A → schnirelmannDensity A ≤ 1 - (↑k)⁻¹","name":"schnirelmannDensity_le_of_not_mem","isProp":true,"docString":"If `k` is omitted from the set, its Schnirelmann density is upper bounded by `1 - k⁻¹`.\n","distance":1.9578511151904063325446259113959968090057373046875}],["Constructing an affine subspace from a point in a subspace and that subspace's direction\nyields the original subspace. ",{"type":"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p : P},\n  p ∈ s → AffineSubspace.mk' p (AffineSubspace.direction s) = s","name":"AffineSubspace.mk'_eq","isProp":true,"docString":"Constructing an affine subspace from a point in a subspace and that subspace's direction\nyields the original subspace. ","distance":1.9579569445727516008304291972308419644832611083984375}],["If vectors `v₁` and `v₂` are on the same ray, then they are nonnegative multiples of the same\nvector. Actually, this vector can be assumed to be `v₁ + v₂`, see `SameRay.exists_eq_smul_add`. ",{"type":"∀ {R : Type u_1} [inst : LinearOrderedField R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {v₁ v₂ : M}, SameRay R v₁ v₂ → ∃ u a b, 0 ≤ a ∧ 0 ≤ b ∧ a + b = 1 ∧ v₁ = a • u ∧ v₂ = b • u","name":"SameRay.exists_eq_smul","isProp":true,"docString":"If vectors `v₁` and `v₂` are on the same ray, then they are nonnegative multiples of the same\nvector. Actually, this vector can be assumed to be `v₁ + v₂`, see `SameRay.exists_eq_smul_add`. ","distance":1.9588920852824724949670098794740624725818634033203125}],["If a subset of a real vector space contains a segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ",{"type":"∀ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {s : Set G} {x y : G},\n  segment ℝ x y ⊆ s → y - x ∈ tangentConeAt ℝ s x","name":"mem_tangentCone_of_segment_subset","isProp":true,"docString":"If a subset of a real vector space contains a segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ","distance":1.9593823915441868077635945155634544789791107177734375}],["An alias of `ContinuousMultilinearMap.normedSpace` with non-dependent types to help typeclass\nsearch. ",{"type":"{𝕜 : Type u} →\n  {ι : Type v} →\n    {G : Type wG} →\n      {G' : Type wG'} →\n        [inst : Fintype ι] →\n          [inst_1 : NontriviallyNormedField 𝕜] →\n            [inst_2 : SeminormedAddCommGroup G] →\n              [inst_3 : NormedSpace 𝕜 G] →\n                [inst_4 : SeminormedAddCommGroup G'] →\n                  [inst_5 : NormedSpace 𝕜 G'] →\n                    {𝕜' : Type u_1} →\n                      [inst_6 : NormedField 𝕜'] →\n                        [inst_7 : NormedSpace 𝕜' G] →\n                          [inst_8 : SMulCommClass 𝕜 𝕜' G] → NormedSpace 𝕜' (ContinuousMultilinearMap 𝕜 (fun x => G') G)","name":"ContinuousMultilinearMap.normedSpace'","isProp":false,"docString":"An alias of `ContinuousMultilinearMap.normedSpace` with non-dependent types to help typeclass\nsearch. ","distance":1.959585608766023057114580296911299228668212890625}],["Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ",{"type":"(X : AlgebraicGeometry.Scheme) → AlgebraicGeometry.IsAffine X → AlgebraicGeometry.AffineScheme","name":"AlgebraicGeometry.AffineScheme.mk","isProp":false,"docString":"Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ","distance":1.9601256537920139777497752220369875431060791015625}],["The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{𝕜 : Type u_8} →\n  {𝕜' : Type u_9} →\n    {E : Type u_10} →\n      [inst : NormedField 𝕜'] →\n        [inst_1 : SeminormedAddCommGroup E] → [I : NormedSpace 𝕜' E] → NormedSpace 𝕜' (RestrictScalars 𝕜 𝕜' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.9603170698581726671960723251686431467533111572265625}],["The tangent bundle to a smooth manifold, as a Sigma type. Defined in terms of\n`Bundle.TotalSpace` to be able to put a suitable topology on it. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {E : Type u_2} →\n      [inst_1 : NormedAddCommGroup E] →\n        [inst_2 : NormedSpace 𝕜 E] →\n          {H : Type u_4} →\n            [inst_3 : TopologicalSpace H] →\n              (I : ModelWithCorners 𝕜 E H) →\n                (M : Type u_6) →\n                  [inst_4 : TopologicalSpace M] →\n                    [inst_5 : ChartedSpace H M] → [inst : SmoothManifoldWithCorners I M] → Type (max u_6 u_2)","name":"TangentBundle","isProp":false,"docString":"The tangent bundle to a smooth manifold, as a Sigma type. Defined in terms of\n`Bundle.TotalSpace` to be able to put a suitable topology on it. ","distance":1.9608252424833343408039354471839033067226409912109375}],["The projectivization of the `K`-vector space `V`.\nThe notation `ℙ K V` is preferred. ",{"type":"(K : Type u_1) → (V : Type u_2) → [inst : DivisionRing K] → [inst_1 : AddCommGroup V] → [inst : Module K V] → Type u_2","name":"Projectivization","isProp":false,"docString":"The projectivization of the `K`-vector space `V`.\nThe notation `ℙ K V` is preferred. ","distance":1.9610940040499682535113379344693385064601898193359375}],["In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. ",{"type":"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompleteSpace α], CompleteSpace (TopologicalSpace.Closeds α)","name":"EMetric.Closeds.completeSpace","isProp":true,"docString":"In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. ","distance":1.961268807984575257563619743450544774532318115234375}],["The trivial submonoid `{1}` of a monoid `M`. ",{"type":"{M : Type u_1} → [inst : MulOneClass M] → Bot (Submonoid M)","name":"Submonoid.instBotSubmonoid","isProp":false,"docString":"The trivial submonoid `{1}` of a monoid `M`. ","distance":1.9620628958889783088892500018118880689144134521484375}],["A closed ball in a product space is a product of closed balls. See also `closedBall_pi'`\nfor a version assuming `Nonempty β` instead of `0 ≤ r`. ",{"type":"∀ {β : Type v} {π : β → Type u_3} [inst : Fintype β] [inst_1 : (b : β) → PseudoMetricSpace (π b)] (x : (b : β) → π b)\n  {r : ℝ}, 0 ≤ r → Metric.closedBall x r = Set.pi Set.univ fun b => Metric.closedBall (x b) r","name":"closedBall_pi","isProp":true,"docString":"A closed ball in a product space is a product of closed balls. See also `closedBall_pi'`\nfor a version assuming `Nonempty β` instead of `0 ≤ r`. ","distance":1.962408561493080849658099396037869155406951904296875}],["The vector given in euclidean space by being `1 : 𝕜` at coordinate `i : ι` and `0 : 𝕜` at\nall other coordinates. ",{"type":"{ι : Type u_1} →\n  {𝕜 : Type u_3} → [inst : IsROrC 𝕜] → [inst_1 : Fintype ι] → [inst_2 : DecidableEq ι] → ι → 𝕜 → EuclideanSpace 𝕜 ι","name":"EuclideanSpace.single","isProp":false,"docString":"The vector given in euclidean space by being `1 : 𝕜` at coordinate `i : ι` and `0 : 𝕜` at\nall other coordinates. ","distance":1.9624413585681586003062193412915803492069244384765625}],["A vector is in the direction of a nonempty affine subspace if and only if it is the subtraction\nof two vectors in the subspace. ",{"type":"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P},\n  Set.Nonempty ↑s → ∀ (v : V), v ∈ AffineSubspace.direction s ↔ ∃ p1 ∈ s, ∃ p2 ∈ s, v = p1 -ᵥ p2","name":"AffineSubspace.mem_direction_iff_eq_vsub","isProp":true,"docString":"A vector is in the direction of a nonempty affine subspace if and only if it is the subtraction\nof two vectors in the subspace. ","distance":1.9627688846046407178391746128909289836883544921875}]]