[["Auxiliary function for find operation ",{"type":"(self : Batteries.UnionFind) → Fin self.size → Batteries.UnionFind.FindAux self.size","name":"Batteries.UnionFind.findAux","isProp":false,"docString":"Auxiliary function for find operation ","distance":1.040505699062931999065995114506222307682037353515625}],[" For any lists `ds` and `ds₂`, if `ds` is a prefix of the HolorIndex formed by appending `ds₂` to `ds`, then the first `List.length ds` elements in `ds` are less than or equal to their corresponding elements in the HolorIndex.",{"type":"∀ {ds₂ : List ℕ} (ds : List ℕ) (is : HolorIndex (ds ++ ds₂)),\n  List.Forall₂ (fun x x_1 => x < x_1) (List.take ds.length ↑is) ds","name":"HolorIndex.take.proof_1","isProp":true,"docString":" For any lists `ds` and `ds₂`, if `ds` is a prefix of the HolorIndex formed by appending `ds₂` to `ds`, then the first `List.length ds` elements in `ds` are less than or equal to their corresponding elements in the HolorIndex.","distance":1.351045152275279992437617693212814629077911376953125}],["The theorem `sup_sdiff_injOn` states that for any type `α` that forms a `GeneralizedBooleanAlgebra`, and any two elements `u` and `v` of `α`, the function `x` maps to `(x ⊔ u) \\ v` is injective on the set of elements `x` which are disjoint from `u` and greater than or equal to `v`. This is termed as UV-compression being injective on the elements it moves. Here, `\\` operation indicates the difference of two elements in the Boolean algebra context, `⊔` denotes the supremum or join operation, and `Disjoint` refers to two elements whose infimum is the bottom element.",{"type":"∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] (u v : α),\n  Set.InjOn (fun x => (x ⊔ u) \\ v) {x | Disjoint u x ∧ v ≤ x}","name":"sup_sdiff_injOn","isProp":true,"docString":"The theorem `sup_sdiff_injOn` states that for any type `α` that forms a `GeneralizedBooleanAlgebra`, and any two elements `u` and `v` of `α`, the function `x` maps to `(x ⊔ u) \\ v` is injective on the set of elements `x` which are disjoint from `u` and greater than or equal to `v`. This is termed as UV-compression being injective on the elements it moves. Here, `\\` operation indicates the difference of two elements in the Boolean algebra context, `⊔` denotes the supremum or join operation, and `Disjoint` refers to two elements whose infimum is the bottom element.","distance":1.3806060054131921166487018126645125448703765869140625}],["Bind operation for `SupIndep`. ",{"type":"∀ {α : Type u_1} {ι : Type u_3} [inst : DistribLattice α] [inst_1 : OrderBot α] {β : ι → Type u_5} {s : Finset ι}\n  {g : (i : ι) → Finset (β i)} {f : Sigma β → α},\n  (s.SupIndep fun i => (g i).sup fun b => f ⟨i, b⟩) →\n    (∀ i ∈ s, (g i).SupIndep fun b => f ⟨i, b⟩) → (s.sigma g).SupIndep f","name":"Finset.SupIndep.sigma","isProp":true,"docString":"Bind operation for `SupIndep`. ","distance":1.173935566000521735219308538944460451602935791015625}],[" Given a filter U on the product α × α, a linear order β, a value z in β, and a distance function D from α to β, U is the infimum over all ε > z of the principal filters of pairs (p.1, p.2) with D(p.1, p.2) < ε if and only if for every set s of pairs of α, s is in U if and only if there exists an ε > z such that for all (a, b) in α × α with D(a, b) < ε, (a, b) is in s.",{"type":"∀ {α : Type u} {β : Type v} [inst : LinearOrder β] {U : Filter (α × α)} (z : β) (D : α → α → β),\n  (∀ (s : Set (α × α)), s ∈ U ↔ ∃ ε > z, ∀ {a b : α}, D a b < ε → (a, b) ∈ s) →\n    U = ⨅ ε, ⨅ (_ : ε > z), Filter.principal {p | D p.1 p.2 < ε}","name":"uniformity_dist_of_mem_uniformity","isProp":true,"docString":" Given a filter U on the product α × α, a linear order β, a value z in β, and a distance function D from α to β, U is the infimum over all ε > z of the principal filters of pairs (p.1, p.2) with D(p.1, p.2) < ε if and only if for every set s of pairs of α, s is in U if and only if there exists an ε > z such that for all (a, b) in α × α with D(a, b) < ε, (a, b) is in s.","distance":1.3583139682769134193307536406791768968105316162109375}],["The theorem `List.mem_dlookup_kunion` states that for all types `α` and `β`, given the decidable equality on `α`, and for any `a` of type `α`, `b` of type `β a`, and `l₁` and `l₂` being lists of key-value pairs (Sigma types), the value `b` is in the list obtained by looking up the key `a` in the list formed by the key-union of `l₁` and `l₂` if and only if `b` is in the list obtained by looking up `a` in `l₁`, or `a` is not a key in `l₁` and `b` is in the list obtained by looking up `a` in `l₂`. In other words, this theorem describes the behavior of the `dlookup` operation with respect to the `kunion` operation on lists of key-value pairs.",{"type":"∀ {α : Type u} {β : α → Type v} [inst : DecidableEq α] {a : α} {b : β a} {l₁ l₂ : List (Sigma β)},\n  b ∈ List.dlookup a (l₁.kunion l₂) ↔ b ∈ List.dlookup a l₁ ∨ a ∉ l₁.keys ∧ b ∈ List.dlookup a l₂","name":"List.mem_dlookup_kunion","isProp":true,"docString":"The theorem `List.mem_dlookup_kunion` states that for all types `α` and `β`, given the decidable equality on `α`, and for any `a` of type `α`, `b` of type `β a`, and `l₁` and `l₂` being lists of key-value pairs (Sigma types), the value `b` is in the list obtained by looking up the key `a` in the list formed by the key-union of `l₁` and `l₂` if and only if `b` is in the list obtained by looking up `a` in `l₁`, or `a` is not a key in `l₁` and `b` is in the list obtained by looking up `a` in `l₂`. In other words, this theorem describes the behavior of the `dlookup` operation with respect to the `kunion` operation on lists of key-value pairs.","distance":1.4251791570154619392951644840650260448455810546875}],["Delaborator for indexed unions. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"Set.iUnion_delab","isProp":false,"docString":"Delaborator for indexed unions. ","distance":1.1945555434010817208445587311871349811553955078125}],["Equivalence relation from a `UnionFind` structure ",{"type":"Batteries.UnionFind → ℕ → ℕ → Prop","name":"Batteries.UnionFind.Equiv","isProp":false,"docString":"Equivalence relation from a `UnionFind` structure ","distance":1.2064464372317840190618198903393931686878204345703125}],["**Alias** of the forward direction of `hasFDerivWithinAt_univ`.",{"type":"∀ {\u0000\u0000 : Type u_1} [inst : NontriviallyNormedField \u0000\u0000] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace \u0000\u0000 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace \u0000\u0000 F] {f : E → F}\n  {f' : E →L[\u0000\u0000] F} {x : E}, HasFDerivWithinAt f f' Set.univ x → HasFDerivAt f f' x","name":"HasFDerivWithinAt.hasFDerivAt_of_univ","isProp":true,"docString":"**Alias** of the forward direction of `hasFDerivWithinAt_univ`.","distance":1.210209312981354035088088494376279413700103759765625}],["Empty union-find structure ",{"type":"Batteries.UnionFind","name":"Batteries.UnionFind.empty","isProp":false,"docString":"Empty union-find structure ","distance":1.2155360797325556188042128269444219768047332763671875}],["Auxiliary definition for `mergeUnsortedDedup`. ",{"type":"{α : Type u_1} → [eq : BEq α] → Array α → Array α → Array α","name":"Array.mergeUnsortedDedup.go","isProp":false,"docString":"Auxiliary definition for `mergeUnsortedDedup`. ","distance":1.2179876452311237944314825654146261513233184814453125}],["Link two union-find nodes ",{"type":"(self : Array Batteries.UFNode) → Fin self.size → Fin self.size → Array Batteries.UFNode","name":"Batteries.UnionFind.linkAux","isProp":false,"docString":"Link two union-find nodes ","distance":1.236811804024891880970926649752072989940643310546875}],["**Alias** of `iSupIndep_sUnion_of_directed`.",{"type":"∀ {α : Type u_2} [inst : CompleteLattice α] [inst_1 : IsCompactlyGenerated α] {s : Set (Set α)},\n  DirectedOn (fun x1 x2 => x1 ⊆ x2) s → (∀ a ∈ s, sSupIndep a) → sSupIndep (⋃₀ s)","name":"CompleteLattice.independent_sUnion_of_directed","isProp":true,"docString":"**Alias** of `iSupIndep_sUnion_of_directed`.","distance":1.2381082664014837479982134027522988617420196533203125}],["The binary union operation ",{"type":"ZFSet.{u} → ZFSet.{u} → ZFSet.{u}","name":"ZFSet.union","isProp":false,"docString":"The binary union operation ","distance":1.239230082991787273982708939001895487308502197265625}],["**Alias** of `List.getD_min?_eq_untop'_minimum`.",{"type":"∀ {α : Type u_1} [inst : LinearOrder α] (l : List α) (d : α), l.min?.getD d = WithTop.untop' d l.minimum","name":"List.getD_minimum?_eq_untop'_minimum","isProp":true,"docString":"**Alias** of `List.getD_min?_eq_untop'_minimum`.","distance":1.2413926946993247835138163281953893601894378662109375}],["Check whether two union-find nodes are equivalent, updating structure using path compression. ",{"type":"(self : Batteries.UnionFind) → Fin self.size → Fin self.size → Batteries.UnionFind × Bool","name":"Batteries.UnionFind.checkEquiv","isProp":false,"docString":"Check whether two union-find nodes are equivalent, updating structure using path compression. ","distance":1.24437610190919212271865035290829837322235107421875}],["**Alias** of `sdiff_sup_self`.",{"type":"∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] (a b : α), b \\ a ⊔ a = b ⊔ a","name":"sup_sdiff_self_left","isProp":true,"docString":"**Alias** of `sdiff_sup_self`.","distance":1.2443970601587517332831112071289680898189544677734375}],["**Alias** of the reverse direction of `hasFDerivWithinAt_insert`.",{"type":"∀ {\u0000\u0000 : Type u_1} [inst : NontriviallyNormedField \u0000\u0000] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace \u0000\u0000 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace \u0000\u0000 F] {f : E → F}\n  {f' : E →L[\u0000\u0000] F} {x : E} {s : Set E} {y : E}, HasFDerivWithinAt f f' s x → HasFDerivWithinAt f f' (insert y s) x","name":"HasFDerivWithinAt.insert'","isProp":true,"docString":"**Alias** of the reverse direction of `hasFDerivWithinAt_insert`.","distance":1.245714274605290494690734703908674418926239013671875}],["Check whether two union-find nodes are equivalent, updating structure using path compression.\nPanics if either index is out of bounds. ",{"type":"Batteries.UnionFind → ℕ → ℕ → Batteries.UnionFind × Bool","name":"Batteries.UnionFind.checkEquiv!","isProp":false,"docString":"Check whether two union-find nodes are equivalent, updating structure using path compression.\nPanics if either index is out of bounds. ","distance":1.2484395120018663138949932545074261724948883056640625}],["**Alias** of `Subspace.top_mem_of_biUnion_eq_univ`.",{"type":"∀ {k : Type u_1} {E : Type u_2} [inst : DivisionRing k] [inst_1 : Infinite k] [inst_2 : AddCommGroup E]\n  [inst_3 : Module k E] {s : Finset (Subspace k E)}, ⋃ p ∈ s, ↑p = Set.univ → ⊤ ∈ s","name":"Subspace.exists_eq_top_of_biUnion_eq_univ","isProp":true,"docString":"**Alias** of `Subspace.top_mem_of_biUnion_eq_univ`.","distance":1.248581461014419691224475172930397093296051025390625}],["`sUnion` is monotone under taking a subset of each set. ",{"type":"∀ {α : Type u_1} {s : Set (Set α)} {f : Set α → Set α}, (∀ (t : Set α), t ⊆ f t) → ⋃₀ s ⊆ ⋃₀ (f '' s)","name":"Set.sUnion_mono_subsets","isProp":true,"docString":"`sUnion` is monotone under taking a subset of each set. ","distance":1.2497171841665941638410686209681443870067596435546875}],["**Alias** of `sSupIndep_iUnion_of_directed`.",{"type":"∀ {α : Type u_2} [inst : CompleteLattice α] [inst_1 : IsCompactlyGenerated α] {η : Type u_3} {s : η → Set α},\n  Directed (fun x1 x2 => x1 ⊆ x2) s → (∀ (i : η), sSupIndep (s i)) → sSupIndep (⋃ i, s i)","name":"CompleteLattice.setIndependent_iUnion_of_directed","isProp":true,"docString":"**Alias** of `sSupIndep_iUnion_of_directed`.","distance":1.2511413732417098199078964171349070966243743896484375}],["There are as many `U`s as `D`s ",{"type":"∀ (self : DyckWord), List.count DyckStep.U ↑self = List.count DyckStep.D ↑self","name":"DyckWord.count_U_eq_count_D","isProp":true,"docString":"There are as many `U`s as `D`s ","distance":1.25595522067521425668701340327970683574676513671875}],["Fixing submonoid of iUnion is intersection ",{"type":"∀ (M : Type u_1) (α : Type u_2) [inst : Monoid M] [inst_1 : MulAction M α] {ι : Sort u_3} {s : ι → Set α},\n  fixingSubmonoid M (⋃ i, s i) = ⨅ i, fixingSubmonoid M (s i)","name":"fixingSubmonoid_iUnion","isProp":true,"docString":"Fixing submonoid of iUnion is intersection ","distance":1.256967252713035776423566858284175395965576171875}]]