[["The supremum of the principal segment ",{"type":"{α : Type u_4} → {β : Type u_5} → {r : α → α → Prop} → {s : β → β → Prop} → r ≺i s → β","name":"PrincipalSeg.top","isProp":false,"docString":"The supremum of the principal segment ","distance":0.3962934061799281426630159330670721828937530517578125}],[" In a convex set of an additive commutative monoid that is a module over an ordered semiring, any segment connecting two elements lies entirely within the set.",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E] [inst_2 : SMul 𝕜 E] {s : Set E},\n  Convex 𝕜 s → ∀ {x y : E}, x ∈ s → y ∈ s → segment 𝕜 x y ⊆ s","name":"Convex.segment_subset","isProp":true,"docString":" In a convex set of an additive commutative monoid that is a module over an ordered semiring, any segment connecting two elements lies entirely within the set.","distance":0.5097680658231837913518802452017553150653839111328125}],["The theorem `Convex.segment_subset` states that for any ordered semiring `𝕜` and any additive commutative monoid `E` that is also a `𝕜`-module, if `s` is a convex set in `E`, then for any two elements `x` and `y` in `s`, the segment from `x` to `y` (which is defined as the set of all points `z` that can be expressed as `a*x + b*y`, where `a` and `b` are nonnegative and sum to 1) is a subset of `s`. In other words, in a convex set, the entire line segment connecting any two points in the set also lies within the set.",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E] [inst_2 : SMul 𝕜 E] {s : Set E},\n  Convex 𝕜 s → ∀ {x y : E}, x ∈ s → y ∈ s → segment 𝕜 x y ⊆ s","name":"Convex.segment_subset","isProp":true,"docString":"The theorem `Convex.segment_subset` states that for any ordered semiring `𝕜` and any additive commutative monoid `E` that is also a `𝕜`-module, if `s` is a convex set in `E`, then for any two elements `x` and `y` in `s`, the segment from `x` to `y` (which is defined as the set of all points `z` that can be expressed as `a*x + b*y`, where `a` and `b` are nonnegative and sum to 1) is a subset of `s`. In other words, in a convex set, the entire line segment connecting any two points in the set also lies within the set.","distance":0.50463003172415732411337785379146225750446319580078125}],["Being a nonempty initial segment of colex is equivalent to being an `initSeg`. ",{"type":"∀ {α : Type u_1} [inst : LinearOrder α] {𝒜 : Finset (Finset α)} {r : ℕ} [inst_1 : Fintype α],\n  Finset.Colex.IsInitSeg 𝒜 r ∧ 𝒜.Nonempty ↔ ∃ s, s.card = r ∧ 𝒜 = Finset.Colex.initSeg s","name":"Finset.Colex.isInitSeg_iff_exists_initSeg","isProp":true,"docString":"Being a nonempty initial segment of colex is equivalent to being an `initSeg`. ","distance":0.40425271821916108905270448303781449794769287109375}],[" If the germ of a section is a unit in the stalk of a Ringed Space at a point, then the section is a unit in some neighborhood of that point.",{"type":"∀ (X : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens ↑↑X.toPresheafedSpace)\n  (f : ↑(X.presheaf.obj (Opposite.op U))) (x : ↥U),\n  IsUnit ((X.presheaf.germ x) f) → ∃ V i, ∃ (_ : ↑x ∈ V), IsUnit ((X.presheaf.map i.op) f)","name":"AlgebraicGeometry.RingedSpace.isUnit_res_of_isUnit_germ","isProp":true,"docString":" If the germ of a section is a unit in the stalk of a Ringed Space at a point, then the section is a unit in some neighborhood of that point.","distance":0.53434480710022735916453484605881385505199432373046875}],["This theorem in Algebraic Geometry, specifically in the context of Ringed Spaces, asserts that if the germ of a section `f` under a presheaf is a unit in the stalk at a point `x`, then the section `f` itself must be a unit in some small neighborhood around `x` in the underlying topological space of the Ringed Space. Here, a \"unit\" refers to an element having a two-sided inverse in the monoid structure. The germ of a section represents a local piece or an \"infinitesimal neighborhood\" around the point, and the theorem essentially states a sort of local-to-global principle: if a property holds at the 'infinitesimal' or germ level, then it also holds in some 'small' neighborhood.",{"type":"∀ (X : AlgebraicGeometry.RingedSpace) (U : TopologicalSpace.Opens ↑↑X.toPresheafedSpace)\n  (f : ↑(X.presheaf.obj (Opposite.op U))) (x : ↥U),\n  IsUnit ((X.presheaf.germ x) f) → ∃ V i, ∃ (_ : ↑x ∈ V), IsUnit ((X.presheaf.map i.op) f)","name":"AlgebraicGeometry.RingedSpace.isUnit_res_of_isUnit_germ","isProp":true,"docString":"This theorem in Algebraic Geometry, specifically in the context of Ringed Spaces, asserts that if the germ of a section `f` under a presheaf is a unit in the stalk at a point `x`, then the section `f` itself must be a unit in some small neighborhood around `x` in the underlying topological space of the Ringed Space. Here, a \"unit\" refers to an element having a two-sided inverse in the monoid structure. The germ of a section represents a local piece or an \"infinitesimal neighborhood\" around the point, and the theorem essentially states a sort of local-to-global principle: if a property holds at the 'infinitesimal' or germ level, then it also holds in some 'small' neighborhood.","distance":0.51612918058379297914228800436831079423427581787109375}],["The order embedding is an initial segment ",{"type":"∀ {α : Type u_4} {β : Type u_5} {r : α → α → Prop} {s : β → β → Prop} (self : r ≼i s) (a : α) (b : β),\n  s b (self.toRelEmbedding a) → ∃ a', self.toRelEmbedding a' = b","name":"InitialSeg.init'","isProp":true,"docString":"The order embedding is an initial segment ","distance":0.423410493358806150343554008941282518208026885986328125}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.424752164541491950000562383138458244502544403076171875}],["The ground set ",{"type":"{α : Type u_2} → IndepMatroid α → Set α","name":"IndepMatroid.E","isProp":false,"docString":"The ground set ","distance":0.43445417417146270366856697364710271358489990234375}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.438062123894817301295034894792479462921619415283203125}],["Finitely supported product of finsets. ",{"type":"{ι : Type u_1} → {α : Type u_2} → [inst : Zero α] → Finset ι → (ι → Finset α) → Finset (ι →₀ α)","name":"Finset.finsupp","isProp":false,"docString":"Finitely supported product of finsets. ","distance":0.44039294645374871262077931532985530793666839599609375}],["Composition of two principal segments as a principal segment ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {r : α → α → Prop} → {s : β → β → Prop} → {t : γ → γ → Prop} → [inst : IsTrans γ t] → r ≺i s → s ≺i t → r ≺i t","name":"PrincipalSeg.trans","isProp":false,"docString":"Composition of two principal segments as a principal segment ","distance":0.44077584016838866620702219734084792435169219970703125}],["a section of `S.g` ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S : CategoryTheory.ShortComplex C} → CategoryTheory.ShortComplex.Splitting S → (S.X₃ ⟶ S.X₂)","name":"CategoryTheory.ShortComplex.Splitting.s","isProp":false,"docString":"a section of `S.g` ","distance":0.443118957861752094107288257873733527958393096923828125}],["The cone itself ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} → CategoryTheory.Limits.LimitCone F → CategoryTheory.Limits.Cone F","name":"CategoryTheory.Limits.LimitCone.cone","isProp":false,"docString":"The cone itself ","distance":0.44364596328640681921484656413667835295200347900390625}],["the second row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₂","isProp":false,"docString":"the second row ","distance":0.445576466302514850870153395590023137629032135009765625}],["Semiring ⥤ ℕ-Alg ",{"type":"{R : Type u_1} → [inst : Semiring R] → Algebra ℕ R","name":"algebraNat","isProp":false,"docString":"Semiring ⥤ ℕ-Alg ","distance":0.446239462420369215056581424505566246807575225830078125}],["Seminorm-balls are convex. ",{"type":"∀ {𝕜 : Type u_3} {E : Type u_7} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : NormedSpace ℝ 𝕜]\n  [inst_3 : Module 𝕜 E] [inst_4 : Module ℝ E] [inst_5 : IsScalarTower ℝ 𝕜 E] (p : Seminorm 𝕜 E) (x : E) (r : ℝ),\n  Convex ℝ (Seminorm.ball p x r)","name":"Seminorm.convex_ball","isProp":true,"docString":"Seminorm-balls are convex. ","distance":0.4468729142507610330170564338914118707180023193359375}],["The right arrow of the walking cospan. ",{"type":"CategoryTheory.Limits.WalkingCospan.right ⟶ CategoryTheory.Limits.WalkingCospan.one","name":"CategoryTheory.Limits.WalkingCospan.Hom.inr","isProp":false,"docString":"The right arrow of the walking cospan. ","distance":0.447254832203899443943129199396935291588306427001953125}],["The set of good products. ",{"type":"{I : Type u} → [inst : LinearOrder I] → Set (I → Bool) → Set (Profinite.NobelingProof.Products I)","name":"Profinite.NobelingProof.GoodProducts","isProp":false,"docString":"The set of good products. ","distance":0.4476559423779189472725192899815738201141357421875}],["The family of Schwartz seminorms. ",{"type":"(𝕜 : Type u_1) →\n  (E : Type u_4) →\n    (F : Type u_5) →\n      [inst : NormedAddCommGroup E] →\n        [inst_1 : NormedSpace ℝ E] →\n          [inst_2 : NormedAddCommGroup F] →\n            [inst_3 : NormedSpace ℝ F] →\n              [inst_4 : NormedField 𝕜] →\n                [inst_5 : NormedSpace 𝕜 F] → [inst_6 : SMulCommClass ℝ 𝕜 F] → SeminormFamily 𝕜 (SchwartzMap E F) (ℕ × ℕ)","name":"schwartzSeminormFamily","isProp":false,"docString":"The family of Schwartz seminorms. ","distance":0.448003332136706566846129362602368928492069244384765625}],["By definition, a flag is a chain ",{"type":"∀ {α : Type u_3} [inst : LE α] (self : Flag α), IsChain (fun x x_1 => x ≤ x_1) self.carrier","name":"Flag.Chain'","isProp":true,"docString":"By definition, a flag is a chain ","distance":0.45103953691624176780550214971299283206462860107421875}],["The cocone itself ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} → CategoryTheory.Limits.ColimitCocone F → CategoryTheory.Limits.Cocone F","name":"CategoryTheory.Limits.ColimitCocone.cocone","isProp":false,"docString":"The cocone itself ","distance":0.451952278681670593929453616510727442800998687744140625}],["The category of semirings. ",{"type":"Type (u + 1)","name":"SemiRingCat","isProp":false,"docString":"The category of semirings. ","distance":0.452723762652449845944602202507667243480682373046875}],["The empty weak sequence ",{"type":"{α : Type u} → Stream'.WSeq α","name":"Stream'.WSeq.nil","isProp":false,"docString":"The empty weak sequence ","distance":0.453449865137987517815787441577413119375705718994140625}]]