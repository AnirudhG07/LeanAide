[["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] → [inst_1 : MetricSpace P] → [inst_2 : NormedAddTorsor V P] → AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.983883655754146158045614356524311006069183349609375}],[" If a function `f : α → E` reaches the maximum norm at a point `c` in a filter `l`, then the function `x => ||f x + y||` also reaches the maximum norm at `c` for any vector `y` on the ray through `fc`.",{"type":"∀ {α : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : α → E} {l : Filter α}\n  {c : α} {y : E}, IsMaxFilter (norm ∘ f) l c → SameRay ℝ (f c) y → IsMaxFilter (fun x => ‖f x + y‖) l c","name":"IsMaxFilter.norm_add_sameRay","isProp":true,"docString":" If a function `f : α → E` reaches the maximum norm at a point `c` in a filter `l`, then the function `x => ||f x + y||` also reaches the maximum norm at `c` for any vector `y` on the ray through `fc`.","distance":2.01910038622410326070166775025427341461181640625}],["This theorem, named `Path.Homotopic.proj_pi`, states that for all types `ι` and `as`, `bs` functions from `ι` to some type `X` (where each `X i` is a topological space), and any index `i` in `ι`, when we take a family of path homotopy classes `paths` (each path being from `as i` to `bs i` for some `i` in `ι`), and form a product of these path homotopy classes using the `Path.Homotopic.pi` function, projecting back to the `i`th coordinate using the `Path.Homotopic.proj` function gives us the original path homotopy class at `i` in the `paths` family. In other words, the projection operation is the inverse of the pi operation in the context of path homotopy classes.",{"type":"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {as bs : (i : ι) → X i} (i : ι)\n  (paths : (i : ι) → Path.Homotopic.Quotient (as i) (bs i)), Path.Homotopic.proj i (Path.Homotopic.pi paths) = paths i","name":"Path.Homotopic.proj_pi","isProp":true,"docString":"This theorem, named `Path.Homotopic.proj_pi`, states that for all types `ι` and `as`, `bs` functions from `ι` to some type `X` (where each `X i` is a topological space), and any index `i` in `ι`, when we take a family of path homotopy classes `paths` (each path being from `as i` to `bs i` for some `i` in `ι`), and form a product of these path homotopy classes using the `Path.Homotopic.pi` function, projecting back to the `i`th coordinate using the `Path.Homotopic.proj` function gives us the original path homotopy class at `i` in the `paths` family. In other words, the projection operation is the inverse of the pi operation in the context of path homotopy classes.","distance":2.01444007101866606745943499845452606678009033203125}],["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.Limits.HasZeroObject C] → Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.992822742021199911022222295287065207958221435546875}],[" A category has the initial-terminal object property (is an InitialMonoClass) if the unique morphism from the initial object to the terminal object is a monomorphism.",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\n  CategoryTheory.Limits.IsTerminal T → CategoryTheory.Mono (hI.to T) → CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.InitialMonoClass.of_isTerminal","isProp":true,"docString":" A category has the initial-terminal object property (is an InitialMonoClass) if the unique morphism from the initial object to the terminal object is a monomorphism.","distance":2.02354600177743026989674035576172173023223876953125}],["The theorem `Primrec.fst` states that for all types `α` and `β` which have a primitive recursive encoding (i.e., they are instances of the `Primcodable` class), the first projection function `Prod.fst` is a primitive recursive function. In other words, given a pair of elements `(a, b)` where `a` is from type `α` and `b` is from type `β`, the function that retrieves the first element `a` from the pair is a primitive recursive function.",{"type":"∀ {α : Type u_3} {β : Type u_4} [inst : Primcodable α] [inst_1 : Primcodable β], Primrec Prod.fst","name":"Primrec.fst","isProp":true,"docString":"The theorem `Primrec.fst` states that for all types `α` and `β` which have a primitive recursive encoding (i.e., they are instances of the `Primcodable` class), the first projection function `Prod.fst` is a primitive recursive function. In other words, given a pair of elements `(a, b)` where `a` is from type `α` and `b` is from type `β`, the function that retrieves the first element `a` from the pair is a primitive recursive function.","distance":2.02357097197155244572286392212845385074615478515625}],["A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit (F.mapCocone c) →\n                    [inst_3 : CategoryTheory.Limits.ReflectsColimit K F] → CategoryTheory.Limits.IsColimit c","name":"CategoryTheory.Limits.isColimitOfReflects","isProp":false,"docString":"A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":2.003524333185708439231120792101137340068817138671875}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData → Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":2.004089715433801099919719490571878850460052490234375}],["Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n",{"type":"Sort u → Sort u","name":"semiOutParam","isProp":false,"docString":"Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n","distance":2.0040938932809719830174799426458775997161865234375}],["Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n",{"type":"(α : Sort u) → α → Sort u","name":"optParam","isProp":false,"docString":"Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n","distance":2.0045555216644164175932019134052097797393798828125}],["If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ",{"type":"{α : Type u} → Task α → α","name":"Task.get","isProp":false,"docString":"If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ","distance":2.00609948688893524604281992651522159576416015625}],["Construct a bundled `MeasCat` from the underlying type and the typeclass. ",{"type":"(α : Type u) → [ms : MeasurableSpace α] → MeasCat","name":"MeasCat.of","isProp":false,"docString":"Construct a bundled `MeasCat` from the underlying type and the typeclass. ","distance":2.0071231828031006472201625001616775989532470703125}],["Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.",{"type":"Lean.Name → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.mkParsedProjectionData","isProp":false,"docString":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.","distance":2.00714955487135160439038372715003788471221923828125}],["Delaborator that prints the current application with universe parameters on the head symbol,\nunless `pp.universes` is explicitly set to `false`.\n",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"Mathlib.PPWithUniv.delabWithUniv","isProp":false,"docString":"Delaborator that prints the current application with universe parameters on the head symbol,\nunless `pp.universes` is explicitly set to `false`.\n","distance":2.00748467215182291312203233246691524982452392578125}],["Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ",{"type":"{α : Prop} → {p : α → Prop} → {C : Sort u_1} → C → ((a : α) → p a → C) → C","name":"Classical.existsCases","isProp":false,"docString":"Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ","distance":2.00816259424575083158970301155932247638702392578125}],["`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n",{"type":"{α : Sort u} → [i : α] → α","name":"inferInstance","isProp":false,"docString":"`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n","distance":2.0088252242411552828116327873431146144866943359375}],["Lists all instances with a long name beginning with `inst`,\ngathered according to the module they are defined in.\nThis is useful for finding automatically named instances with absurd names.\n\nUse as `#long_names` or `#long_names 100` to specify the length.\n",{"type":"Lean.ParserDescr","name":"«command#long_instances_»","isProp":false,"docString":"Lists all instances with a long name beginning with `inst`,\ngathered according to the module they are defined in.\nThis is useful for finding automatically named instances with absurd names.\n\nUse as `#long_names` or `#long_names 100` to specify the length.\n","distance":2.010378513149558177275366688263602554798126220703125}],["This instance exists to short circuit type class resolution because of problems with\ninference involving Π-types. ",{"type":"{ι : Type u_4} →\n  {R : ι → Type u_7} →\n    [inst : (i : ι) → NonUnitalNormedRing (R i)] → [inst_1 : (i : ι) → StarRing (R i)] → StarRing ((i : ι) → R i)","name":"Pi.starRing'","isProp":false,"docString":"This instance exists to short circuit type class resolution because of problems with\ninference involving Π-types. ","distance":2.010763773547036503686058495077304542064666748046875}],["The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. ",{"type":"{α : Sort u} → (x : α) → {β : Sort v} → [self : CoeDep α x β] → β","name":"CoeDep.coe","isProp":false,"docString":"The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. ","distance":2.01172280938881709033694278332404792308807373046875}],["The epimorphism `projective.π : projective.over X ⟶ X`\nfrom the arbitrarily chosen projective object over `X`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.EnoughProjectives C] → (X : C) → CategoryTheory.Projective.over X ⟶ X","name":"CategoryTheory.Projective.π","isProp":false,"docString":"The epimorphism `projective.π : projective.over X ⟶ X`\nfrom the arbitrarily chosen projective object over `X`.\n","distance":2.012410268580854033615423759329132735729217529296875}],["Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ",{"type":"{E : ℕ → Type u_2} → ((n : ℕ) → E n) → Set ((n : ℕ) → E n) → ℕ","name":"PiNat.longestPrefix","isProp":false,"docString":"Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ","distance":2.012636313668377585628377346438355743885040283203125}],["If a structure has a field that corresponds to a coercion to functions or sets, or corresponds\n  to notation, find the custom projection that uses this coercion or notation.\n  Returns the custom projection and the name of the projection used.\n\nWe catch most errors this function causes, so that we don't fail if an unrelated projection has\nan applicable name. (e.g. `Iso.inv`)\n\nImplementation note: getting rid of TermElabM is tricky, since `Expr.mkAppOptM` doesn't allow to\nkeep metavariables around, which are necessary for `OutParam`. ",{"type":"Lean.Name → Simps.ParsedProjectionData → Array Lean.Expr → Lean.Elab.TermElabM (Option (Lean.Expr × Lean.Name))","name":"Simps.findAutomaticProjectionsAux","isProp":false,"docString":"If a structure has a field that corresponds to a coercion to functions or sets, or corresponds\n  to notation, find the custom projection that uses this coercion or notation.\n  Returns the custom projection and the name of the projection used.\n\nWe catch most errors this function causes, so that we don't fail if an unrelated projection has\nan applicable name. (e.g. `Iso.inv`)\n\nImplementation note: getting rid of TermElabM is tricky, since `Expr.mkAppOptM` doesn't allow to\nkeep metavariables around, which are necessary for `OutParam`. ","distance":2.013012670199172848839452854008413851261138916015625}],["Construct a bundled `Cat` from the underlying type and the typeclass. ",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Cat","name":"CategoryTheory.Cat.of","isProp":false,"docString":"Construct a bundled `Cat` from the underlying type and the typeclass. ","distance":2.013192088898418052878014350426383316516876220703125}],["Matcher for processing `scoped` syntax. Assumes the expression to be matched\nagainst is in the `lit` variable.\n\nRuns `smatcher`, extracts the resulting `scopeId` variable, processes this value\n(which must be a lambda) to produce a binder, and loops. ",{"type":"Lean.Name → Lean.Name → Mathlib.Notation3.Matcher → Mathlib.Notation3.Matcher","name":"Mathlib.Notation3.matchScoped","isProp":false,"docString":"Matcher for processing `scoped` syntax. Assumes the expression to be matched\nagainst is in the `lit` variable.\n\nRuns `smatcher`, extracts the resulting `scopeId` variable, processes this value\n(which must be a lambda) to produce a binder, and loops. ","distance":2.01336717590441605096884813974611461162567138671875}]]