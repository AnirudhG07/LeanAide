[["If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ",{"type":"{α : Type u} → Task α → α","name":"Task.get","isProp":false,"docString":"If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ","distance":1.92968381890862250571672120713628828525543212890625}],[" For any field `K` and constant `c` in `K`, the denominator of the constant rational function `RatFunc.C c` is `1`.",{"type":"∀ {K : Type u} [inst : Field K] (c : K), (RatFunc.C c).denom = 1","name":"RatFunc.denom_C","isProp":true,"docString":" For any field `K` and constant `c` in `K`, the denominator of the constant rational function `RatFunc.C c` is `1`.","distance":1.9426995596790217479821194501710124313831329345703125}],["The theorem `GaloisConnection.u_top` states that for any types `α` and `β` which have a partial order and a predefined maximum element (top), if two functions `l : α → β` and `u : β → α` form a Galois connection, then the maximum element of type `β` when mapped through the function `u` gives the maximum element (top) of type `α`. In other words, for a Galois connection, the function `u` sends the top element of `β` to the top element of `α`.",{"type":"∀ {α : Type u} {β : Type v} [inst : PartialOrder α] [inst_1 : Preorder β] [inst_2 : OrderTop α] [inst_3 : OrderTop β]\n  {l : α → β} {u : β → α}, GaloisConnection l u → u ⊤ = ⊤","name":"GaloisConnection.u_top","isProp":true,"docString":"The theorem `GaloisConnection.u_top` states that for any types `α` and `β` which have a partial order and a predefined maximum element (top), if two functions `l : α → β` and `u : β → α` form a Galois connection, then the maximum element of type `β` when mapped through the function `u` gives the maximum element (top) of type `α`. In other words, for a Galois connection, the function `u` sends the top element of `β` to the top element of `α`.","distance":1.9558764726499149322336279510636813938617706298828125}],["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.Limits.HasZeroObject C] → Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.9302562076833156279320746762095950543880462646484375}],[" For any type `R` with a trivial `Star` operation satisfying `TrivialStar` property, `star r = r` for all `r` in `R`.",{"type":"∀ {R : Type u} [inst : Star R] [self : TrivialStar R] (r : R), star r = r","name":"TrivialStar.star_trivial","isProp":true,"docString":" For any type `R` with a trivial `Star` operation satisfying `TrivialStar` property, `star r = r` for all `r` in `R`.","distance":1.947048062101963683545591266010887920856475830078125}],["The theorem `isExtrFilter_const` states that for any type `α` and any preorder type `β`, given any filter `l` on `α`, any element `a` from `α`, and any element `b` from `β`, the constant function (which maps every `x` to `b`) is an extreme filter at `a` with respect to `l`. In other words, the constant function either achieves a minimum or a maximum at `a` under the filter `l`.",{"type":"∀ {α : Type u} {β : Type v} [inst : Preorder β] {l : Filter α} {a : α} {b : β}, IsExtrFilter (fun x => b) l a","name":"isExtrFilter_const","isProp":true,"docString":"The theorem `isExtrFilter_const` states that for any type `α` and any preorder type `β`, given any filter `l` on `α`, any element `a` from `α`, and any element `b` from `β`, the constant function (which maps every `x` to `b`) is an extreme filter at `a` with respect to `l`. In other words, the constant function either achieves a minimum or a maximum at `a` under the filter `l`.","distance":1.958924841260603511017279743100516498088836669921875}],["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] → [inst_1 : MetricSpace P] → [inst_2 : NormedAddTorsor V P] → AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.9323673042959244039451505159377120435237884521484375}],["A choice-free shortcut instance.",{"type":"∀ (α : Type u) [inst : OrderedAddCommGroup α],\n  ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1","name":"OrderedAddCommGroup.to_contravariantClass_right_le","isProp":true,"docString":"A choice-free shortcut instance.","distance":1.9352506238782869463221913974848575890064239501953125}],["Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ",{"type":"{α : Prop} → {p : α → Prop} → {C : Sort u_1} → C → ((a : α) → p a → C) → C","name":"Classical.existsCases","isProp":false,"docString":"Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ","distance":1.93895374173204171341922119609080255031585693359375}],["Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",{"type":"Lean.Syntax →\n  Lean.Name →\n    optParam Bool false →\n      optParam (Array Simps.ProjectionRule) #[] →\n        optParam Bool false → Lean.CoreM (List Lean.Name × Array Simps.ProjectionData)","name":"Simps.getRawProjections","isProp":false,"docString":"Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n","distance":1.94098362035671012648663236177526414394378662109375}],["Given a `G`-action on `H`, this is `k[H]` bundled with the natural representation\n`G →* End(k[H])` as a term of type `Rep k G`. ",{"type":"(k G : Type u) → [inst : CommRing k] → [inst_1 : Monoid G] → (H : Type u) → [inst_2 : MulAction G H] → Rep k G","name":"Rep.ofMulAction","isProp":false,"docString":"Given a `G`-action on `H`, this is `k[H]` bundled with the natural representation\n`G →* End(k[H])` as a term of type `Rep k G`. ","distance":1.9434927124103127393794920863001607358455657958984375}],["Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then\nimported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n",{"type":"Lean.ParserDescr","name":"«termCompile_time_search_path%»","isProp":false,"docString":"Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then\nimported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n","distance":1.94352309811352785828830747050233185291290283203125}],["A choice-free shortcut instance. ",{"type":"∀ (α : Type u) [inst : OrderedCommGroup α], ContravariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1","name":"OrderedCommGroup.to_contravariantClass_left_le","isProp":true,"docString":"A choice-free shortcut instance. ","distance":1.945875128659813935172451238031499087810516357421875}],["Cast a `SNum` to the corresponding integer. ",{"type":"SNum → ℤ","name":"Int.ofSnum","isProp":false,"docString":"Cast a `SNum` to the corresponding integer. ","distance":1.9465859822130884282387341954745352268218994140625}],["Provide a coercion to `Type u` for a concrete category. This is not marked as an instance\nas it could potentially apply to every type, and so is too expensive in typeclass search.\n\nYou can use it on particular examples as:\n```\ninstance : HasCoeToSort X := ConcreteCategory.hasCoeToSort X\n```\n",{"type":"(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.ConcreteCategory C] → CoeSort C (Type w)","name":"CategoryTheory.ConcreteCategory.hasCoeToSort","isProp":false,"docString":"Provide a coercion to `Type u` for a concrete category. This is not marked as an instance\nas it could potentially apply to every type, and so is too expensive in typeclass search.\n\nYou can use it on particular examples as:\n```\ninstance : HasCoeToSort X := ConcreteCategory.hasCoeToSort X\n```\n","distance":1.9472122558302198402913063546293415129184722900390625}],["The constant presheaf on `X` with value `Z`. ",{"type":"{C : Type u_1} → [inst : CategoryTheory.Category.{u_2, u_1} C] → TopCat → C → AlgebraicGeometry.PresheafedSpace C","name":"AlgebraicGeometry.PresheafedSpace.const","isProp":false,"docString":"The constant presheaf on `X` with value `Z`. ","distance":1.94745590715467908893288040417246520519256591796875}],["`get s` returns the result of a terminating computation ",{"type":"{α : Type u} → (s : Computation α) → [h : Computation.Terminates s] → α","name":"Computation.get","isProp":false,"docString":"`get s` returns the result of a terminating computation ","distance":1.94755211206455758343736306414939463138580322265625}],["Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.",{"type":"Lean.Name → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.mkParsedProjectionData","isProp":false,"docString":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.","distance":1.9487614323052662168578308410360477864742279052734375}],["Execute the projection renamings (and turning off projections) as specified by `rules`. ",{"type":"Array Simps.ParsedProjectionData → Array Simps.ProjectionRule → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.applyProjectionRules","isProp":false,"docString":"Execute the projection renamings (and turning off projections) as specified by `rules`. ","distance":1.949022924841984139021633382071740925312042236328125}],["Delaborator that prints the current application with universe parameters on the head symbol,\nunless `pp.universes` is explicitly set to `false`.\n",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"Mathlib.PPWithUniv.delabWithUniv","isProp":false,"docString":"Delaborator that prints the current application with universe parameters on the head symbol,\nunless `pp.universes` is explicitly set to `false`.\n","distance":1.9490557542317048511648636122117750346660614013671875}],["Produce a string for a given `InjectiveFunction`.\nThe output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, x ↦ x]`.\nUnlike for `TotalFunction`, the default value is not a constant\nbut the identity function.\n",{"type":"{α : Type u} → [inst : Repr α] → SlimCheck.InjectiveFunction α → String","name":"SlimCheck.InjectiveFunction.repr","isProp":false,"docString":"Produce a string for a given `InjectiveFunction`.\nThe output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, x ↦ x]`.\nUnlike for `TotalFunction`, the default value is not a constant\nbut the identity function.\n","distance":1.9491974270556842174784151211497373878955841064453125}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9497763145281179486545397594454698264598846435546875}],["Removes all occurrences of `ₓ` from the name.\nThis is the same processing used by mathport to generate name references,\nand declarations with `ₓ` are used to align declarations that do not defeq match the originals.\n",{"type":"Lean.Name → Lean.Name","name":"Mathlib.Prelude.Rename.removeX","isProp":false,"docString":"Removes all occurrences of `ₓ` from the name.\nThis is the same processing used by mathport to generate name references,\nand declarations with `ₓ` are used to align declarations that do not defeq match the originals.\n","distance":1.9498901399372503551177260305848903954029083251953125}],["The stalk at `x` of a `PresheafedSpace`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasColimits C] → (X : AlgebraicGeometry.PresheafedSpace C) → ↑↑X → C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"docString":"The stalk at `x` of a `PresheafedSpace`.\n","distance":1.950526570430934913957798926276154816150665283203125}]]