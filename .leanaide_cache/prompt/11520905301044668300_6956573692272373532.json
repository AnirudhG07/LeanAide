[["Create an equal copy of a subgraph (see `copy_eq`) with possibly different definitional equalities.\nSee Note [range copy pattern].\n",{"type":"{V : Type u} →\n  {G : SimpleGraph V} →\n    (G' : SimpleGraph.Subgraph G) →\n      (V'' : Set V) → V'' = G'.verts → (adj' : V → V → Prop) → adj' = G'.Adj → SimpleGraph.Subgraph G","name":"SimpleGraph.Subgraph.copy","isProp":false,"docString":"Create an equal copy of a subgraph (see `copy_eq`) with possibly different definitional equalities.\nSee Note [range copy pattern].\n","distance":1.869988850907501554132750243297778069972991943359375}],[" For a given type `k`, set `P` of points in the `AddTorsor` `V P`, and point `p` in `P`, the submodule `Submodule.span {x : P | x ≠ p} (x - p)` is equal to the vector space span of `{p} ∪ {x : P | x ≠ p}`.",{"type":"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] [inst_4 : DecidableEq P] [inst_5 : DecidableEq V] {s : Finset P} {p : P},\n  p ∈ s → vectorSpan k ↑s = Submodule.span k ↑(Finset.image (fun x => x -ᵥ p) (s.erase p))","name":"vectorSpan_eq_span_vsub_finset_right_ne","isProp":true,"docString":" For a given type `k`, set `P` of points in the `AddTorsor` `V P`, and point `p` in `P`, the submodule `Submodule.span {x : P | x ≠ p} (x - p)` is equal to the vector space span of `{p} ∪ {x : P | x ≠ p}`.","distance":1.875882293151539759179513566778041422367095947265625}],["The theorem `vectorSpan_eq_span_vsub_set_left` expresses that, given a set of points `s` in an additive torsor space `P` over a module `V`, and a point `p` within `s`, the vector span of `s` is equivalent to the span of the set of vectors formed by subtracting each point in `s` from `p`. Here, the vector subtraction `-ᵥ` returns a vector in `V`. In other words, in such a setting, we can create the vector span of `s` by looking at all vectors resulting from subtracting other points in `s` from a chosen point `p` in `s`, and then spanning over these vectors.",{"type":"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : P}, p ∈ s → vectorSpan k s = Submodule.span k ((fun x => p -ᵥ x) '' s)","name":"vectorSpan_eq_span_vsub_set_left","isProp":true,"docString":"The theorem `vectorSpan_eq_span_vsub_set_left` expresses that, given a set of points `s` in an additive torsor space `P` over a module `V`, and a point `p` within `s`, the vector span of `s` is equivalent to the span of the set of vectors formed by subtracting each point in `s` from `p`. Here, the vector subtraction `-ᵥ` returns a vector in `V`. In other words, in such a setting, we can create the vector span of `s` by looking at all vectors resulting from subtracting other points in `s` from a chosen point `p` in `s`, and then spanning over these vectors.","distance":1.8885301284913034169932188888196833431720733642578125}],["Coercion from `Subgraph G` to `SimpleGraph V`.  If `G'` is a spanning\nsubgraph, then `G'.spanningCoe` yields an isomorphic graph.\nIn general, this adds in all vertices from `V` as isolated vertices. ",{"type":"{V : Type u} → {G : SimpleGraph V} → SimpleGraph.Subgraph G → SimpleGraph V","name":"SimpleGraph.Subgraph.spanningCoe","isProp":false,"docString":"Coercion from `Subgraph G` to `SimpleGraph V`.  If `G'` is a spanning\nsubgraph, then `G'.spanningCoe` yields an isomorphic graph.\nIn general, this adds in all vertices from `V` as isolated vertices. ","distance":1.872558091018984072206876589916646480560302734375}],[" If a subset `s₁` of a coplanar set `s₂` of points in an affine space over a division ring `k` and its module `V`, then `s₁` is also coplanar.",{"type":"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s₁ s₂ : Set P}, s₁ ⊆ s₂ → Coplanar k s₂ → Coplanar k s₁","name":"Coplanar.subset","isProp":true,"docString":" If a subset `s₁` of a coplanar set `s₂` of points in an affine space over a division ring `k` and its module `V`, then `s₁` is also coplanar.","distance":1.886941459066933557409129207371734082698822021484375}],["The theorem `vectorSpan_eq_span_vsub_set_left_ne` states that, for a given ring `k`, the vector space `V` of some type, a point `P`, and a set `s` of points of type `P` which includes the point `p`, the `vectorSpan` of `s` (which represents the submodule generated by the differences of all pairs of points in the set) is equal to the `Submodule.span` of the set of differences between `p` and all other points in `s` (excluding the difference of `p` with itself). In other words, the set of all pairwise differences in `s` generates the same subspace as the set of differences between a fixed point `p` in `s` and all the other points in `s`.",{"type":"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : P},\n  p ∈ s → vectorSpan k s = Submodule.span k ((fun x => p -ᵥ x) '' (s \\ {p}))","name":"vectorSpan_eq_span_vsub_set_left_ne","isProp":true,"docString":"The theorem `vectorSpan_eq_span_vsub_set_left_ne` states that, for a given ring `k`, the vector space `V` of some type, a point `P`, and a set `s` of points of type `P` which includes the point `p`, the `vectorSpan` of `s` (which represents the submodule generated by the differences of all pairs of points in the set) is equal to the `Submodule.span` of the set of differences between `p` and all other points in `s` (excluding the difference of `p` with itself). In other words, the set of all pairwise differences in `s` generates the same subspace as the set of differences between a fixed point `p` in `s` and all the other points in `s`.","distance":1.89051812694729193253806442953646183013916015625}],["Canonical map from the stalk of `smoothSheaf IM I M N` at `x` to `N`, given by evaluating\nsections at `x`. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {EM : Type u_2} →\n      [inst_1 : NormedAddCommGroup EM] →\n        [inst_2 : NormedSpace 𝕜 EM] →\n          {HM : Type u_3} →\n            [inst_3 : TopologicalSpace HM] →\n              (IM : ModelWithCorners 𝕜 EM HM) →\n                {E : Type u_4} →\n                  [inst_4 : NormedAddCommGroup E] →\n                    [inst_5 : NormedSpace 𝕜 E] →\n                      {H : Type u_5} →\n                        [inst_6 : TopologicalSpace H] →\n                          (I : ModelWithCorners 𝕜 E H) →\n                            {M : Type u} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace HM M] →\n                                  (N : Type u) →\n                                    [inst_9 : TopologicalSpace N] →\n                                      [inst_10 : ChartedSpace H N] →\n                                        (x : M) →\n                                          TopCat.Presheaf.stalk (TopCat.Sheaf.presheaf (smoothSheaf IM I M N)) x → N","name":"smoothSheaf.eval","isProp":false,"docString":"Canonical map from the stalk of `smoothSheaf IM I M N` at `x` to `N`, given by evaluating\nsections at `x`. ","distance":1.8821450045853740373758000714587979018688201904296875}],["If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nSee also `LinearMap.eqOn_span'` for a version using `Set.EqOn`. ",{"type":"∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R₂] [inst_4 : AddCommMonoid M₂] [inst_5 : Module R₂ M₂] {F : Type u_8}\n  {σ₁₂ : R →+* R₂} [inst_6 : SemilinearMapClass F σ₁₂ M M₂] {s : Set M} {f g : F},\n  Set.EqOn (⇑f) (⇑g) s → ∀ ⦃x : M⦄, x ∈ Submodule.span R s → f x = g x","name":"LinearMap.eqOn_span","isProp":true,"docString":"If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nSee also `LinearMap.eqOn_span'` for a version using `Set.EqOn`. ","distance":1.883547252519485848409885875298641622066497802734375}],["If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nThis version uses `Set.EqOn`, and the hidden argument will expand to `h : x ∈ (span R s : Set M)`.\nSee `LinearMap.eqOn_span` for a version that takes `h : x ∈ span R s` as an argument. ",{"type":"∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R₂] [inst_4 : AddCommMonoid M₂] [inst_5 : Module R₂ M₂] {F : Type u_8}\n  {σ₁₂ : R →+* R₂} [inst_6 : SemilinearMapClass F σ₁₂ M M₂] {s : Set M} {f g : F},\n  Set.EqOn (⇑f) (⇑g) s → Set.EqOn ⇑f ⇑g ↑(Submodule.span R s)","name":"LinearMap.eqOn_span'","isProp":true,"docString":"If two linear maps are equal on a set `s`, then they are equal on `Submodule.span s`.\n\nThis version uses `Set.EqOn`, and the hidden argument will expand to `h : x ∈ (span R s : Set M)`.\nSee `LinearMap.eqOn_span` for a version that takes `h : x ∈ span R s` as an argument. ","distance":1.8852174025774512955422324012033641338348388671875}],["The `NonUnitalStarSubalgebra` obtained from `S : NonUnitalSubalgebra R A` by taking the\nsmallest non-unital subalgebra containing both `S` and `star S`. ",{"type":"{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : StarRing R] →\n        [inst_2 : NonUnitalSemiring A] →\n          [inst_3 : StarRing A] →\n            [inst_4 : Module R A] →\n              [inst_5 : IsScalarTower R A A] →\n                [inst_6 : SMulCommClass R A A] →\n                  [inst_7 : StarModule R A] → NonUnitalSubalgebra R A → NonUnitalStarSubalgebra R A","name":"NonUnitalSubalgebra.starClosure","isProp":false,"docString":"The `NonUnitalStarSubalgebra` obtained from `S : NonUnitalSubalgebra R A` by taking the\nsmallest non-unital subalgebra containing both `S` and `star S`. ","distance":1.8855509135672054998877911202725954353809356689453125}],["Repeated pointwise addition (not the same as pointwise repeated addition!) of a `Set`. See\nnote [pointwise nat action].",{"type":"{α : Type u_2} → [inst : Zero α] → [inst : Add α] → SMul ℕ (Set α)","name":"Set.NSMul","isProp":false,"docString":"Repeated pointwise addition (not the same as pointwise repeated addition!) of a `Set`. See\nnote [pointwise nat action].","distance":1.8863604861514813304523840997717343270778656005859375}],["Repeated pointwise addition/subtraction (not the same as pointwise repeated\naddition/subtraction!) of a `Set`. See note [pointwise nat action]. ",{"type":"{α : Type u_2} → [inst : Zero α] → [inst : Add α] → [inst : Neg α] → SMul ℤ (Set α)","name":"Set.ZSMul","isProp":false,"docString":"Repeated pointwise addition/subtraction (not the same as pointwise repeated\naddition/subtraction!) of a `Set`. See note [pointwise nat action]. ","distance":1.886957251440203098269421388977207243442535400390625}],["An equality of subobjects gives an isomorphism of the corresponding objects.\n(One could use `underlying.mapIso (eqToIso h))` here, but this is more readable.) ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {B : C} →\n      (X Y : CategoryTheory.Subobject B) →\n        X = Y → (CategoryTheory.Subobject.underlying.obj X ≅ CategoryTheory.Subobject.underlying.obj Y)","name":"CategoryTheory.Subobject.isoOfEq","isProp":false,"docString":"An equality of subobjects gives an isomorphism of the corresponding objects.\n(One could use `underlying.mapIso (eqToIso h))` here, but this is more readable.) ","distance":1.88741707466358743516821050434373319149017333984375}],["The `n+1`st term of the upper central series `H i` has underlying set equal to the `x` such\nthat `⁅x,G⁆ ⊆ H n`",{"type":"∀ (G : Type u_1) [inst : Group G] (n : ℕ) (x : G),\n  x ∈ upperCentralSeries G (n + 1) ↔ ∀ (y : G), x * y * x⁻¹ * y⁻¹ ∈ upperCentralSeries G n","name":"mem_upperCentralSeries_succ_iff","isProp":true,"docString":"The `n+1`st term of the upper central series `H i` has underlying set equal to the `x` such\nthat `⁅x,G⁆ ⊆ H n`","distance":1.8877830935275687895824603401706553995609283447265625}],["Canonical map from the stalk of `smoothSheaf IM I M N` at `x` to `N`, given by evaluating\nsections at `x`, considered as a morphism in the category of types. ",{"type":"{𝕜 : Type u_1} →\n  [inst : NontriviallyNormedField 𝕜] →\n    {EM : Type u_2} →\n      [inst_1 : NormedAddCommGroup EM] →\n        [inst_2 : NormedSpace 𝕜 EM] →\n          {HM : Type u_3} →\n            [inst_3 : TopologicalSpace HM] →\n              (IM : ModelWithCorners 𝕜 EM HM) →\n                {E : Type u_4} →\n                  [inst_4 : NormedAddCommGroup E] →\n                    [inst_5 : NormedSpace 𝕜 E] →\n                      {H : Type u_5} →\n                        [inst_6 : TopologicalSpace H] →\n                          (I : ModelWithCorners 𝕜 E H) →\n                            {M : Type u} →\n                              [inst_7 : TopologicalSpace M] →\n                                [inst_8 : ChartedSpace HM M] →\n                                  (N : Type u) →\n                                    [inst_9 : TopologicalSpace N] →\n                                      [inst_10 : ChartedSpace H N] →\n                                        (x : ↑(TopCat.of M)) →\n                                          TopCat.Presheaf.stalk (TopCat.Sheaf.presheaf (smoothSheaf IM I M N)) x ⟶ N","name":"smoothSheaf.evalHom","isProp":false,"docString":"Canonical map from the stalk of `smoothSheaf IM I M N` at `x` to `N`, given by evaluating\nsections at `x`, considered as a morphism in the category of types. ","distance":1.8878677838431248137140983089921064674854278564453125}],["The `dualAnnihilator` of a submodule `W` is the set of linear maps `φ` such\nthat `φ w = 0` for all `w ∈ W`. ",{"type":"{R : Type u} →\n  {M : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Submodule R M → Submodule R (Module.Dual R M)","name":"Submodule.dualAnnihilator","isProp":false,"docString":"The `dualAnnihilator` of a submodule `W` is the set of linear maps `φ` such\nthat `φ w = 0` for all `w ∈ W`. ","distance":1.887930998614084199260787499952130019664764404296875}],["Compile the definition `dv` by adding a second definition `dv✝` with the same body,\nand registering a `csimp`-lemma `dv = dv✝`.\n",{"type":"Lean.DefinitionVal → Lean.MetaM Unit","name":"Mathlib.Util.compileDefn","isProp":false,"docString":"Compile the definition `dv` by adding a second definition `dv✝` with the same body,\nand registering a `csimp`-lemma `dv = dv✝`.\n","distance":1.889129135437805029340552209760062396526336669921875}],["Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",{"type":"∀ {a b : Prop}, a ∧ b → b","name":"And.right","isProp":true,"docString":"Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ","distance":1.8905180610547980268876244736020453274250030517578125}],["A tactic (for use in default params) that applies `Set.toFinite` to synthesize a `Set.Finite`\nterm. ",{"type":"Lean.ParserDescr","name":"Set.tacticToFinite_tac","isProp":false,"docString":"A tactic (for use in default params) that applies `Set.toFinite` to synthesize a `Set.Finite`\nterm. ","distance":1.890828174403646588785932181053794920444488525390625}],["Construct a monad isomorphism from a natural isomorphism of functors where the forward\ndirection is a monad morphism. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {M N : CategoryTheory.Monad C} →\n      (f : M.toFunctor ≅ N.toFunctor) →\n        autoParam\n            (∀ (X : C),\n              CategoryTheory.CategoryStruct.comp ((CategoryTheory.Monad.η M).app X) (f.hom.app X) =\n                (CategoryTheory.Monad.η N).app X)\n            _auto✝ →\n          autoParam\n              (∀ (X : C),\n                CategoryTheory.CategoryStruct.comp ((CategoryTheory.Monad.μ M).app X) (f.hom.app X) =\n                  CategoryTheory.CategoryStruct.comp\n                    (CategoryTheory.CategoryStruct.comp (M.map (f.hom.app X)) (f.hom.app (N.obj X)))\n                    ((CategoryTheory.Monad.μ N).app X))\n              _auto✝¹ →\n            (M ≅ N)","name":"CategoryTheory.MonadIso.mk","isProp":false,"docString":"Construct a monad isomorphism from a natural isomorphism of functors where the forward\ndirection is a monad morphism. ","distance":1.890906589496527345772847183980047702789306640625}],["Let `E` be a TVS, `𝔖 : Set (Set α)` and `H` a submodule of `α →ᵤ[𝔖] E`. If the image of any\n`S ∈ 𝔖` by any `u ∈ H` is bounded (in the sense of `Bornology.IsVonNBounded`), then `H`,\nequipped with the topology of `𝔖`-convergence, is a TVS.\n\nFor convenience, we don't literally ask for `H : Submodule (α →ᵤ[𝔖] E)`. Instead, we prove the\nresult for any vector space `H` equipped with a linear inducing to `α →ᵤ[𝔖] E`, which is often\neasier to use. We also state the `Submodule` version as\n`UniformOnFun.continuousSMul_submodule_of_image_bounded`. ",{"type":"∀ (𝕜 : Type u_1) (α : Type u_2) (E : Type u_3) (H : Type u_4) {hom : Type u_5} [inst : NormedField 𝕜]\n  [inst_1 : AddCommGroup H] [inst_2 : Module 𝕜 H] [inst_3 : AddCommGroup E] [inst_4 : Module 𝕜 E]\n  [inst_5 : TopologicalSpace H] [inst_6 : UniformSpace E] [inst_7 : UniformAddGroup E] [inst_8 : ContinuousSMul 𝕜 E]\n  {𝔖 : Set (Set α)} [inst_9 : LinearMapClass hom 𝕜 H (UniformOnFun α E 𝔖)],\n  Set.Nonempty 𝔖 →\n    DirectedOn (fun x x_1 => x ⊆ x_1) 𝔖 →\n      ∀ (φ : hom), Inducing ⇑φ → (∀ (u : H), ∀ s ∈ 𝔖, Bornology.IsVonNBounded 𝕜 (φ u '' s)) → ContinuousSMul 𝕜 H","name":"UniformOnFun.continuousSMul_induced_of_image_bounded","isProp":true,"docString":"Let `E` be a TVS, `𝔖 : Set (Set α)` and `H` a submodule of `α →ᵤ[𝔖] E`. If the image of any\n`S ∈ 𝔖` by any `u ∈ H` is bounded (in the sense of `Bornology.IsVonNBounded`), then `H`,\nequipped with the topology of `𝔖`-convergence, is a TVS.\n\nFor convenience, we don't literally ask for `H : Submodule (α →ᵤ[𝔖] E)`. Instead, we prove the\nresult for any vector space `H` equipped with a linear inducing to `α →ᵤ[𝔖] E`, which is often\neasier to use. We also state the `Submodule` version as\n`UniformOnFun.continuousSMul_submodule_of_image_bounded`. ","distance":1.8916807450586834438155392490443773567676544189453125}],["See also `Subspace.dualAnnihilator_inf_eq` for vector subspaces. ",{"type":"∀ {R : Type u} {M : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (U V : Submodule R M), Submodule.dualAnnihilator U ⊔ Submodule.dualAnnihilator V ≤ Submodule.dualAnnihilator (U ⊓ V)","name":"Submodule.sup_dualAnnihilator_le_inf","isProp":true,"docString":"See also `Subspace.dualAnnihilator_inf_eq` for vector subspaces. ","distance":1.89336339085021077011106171994470059871673583984375}],["The `NonUnitalSubsemiring` generated by a set. ",{"type":"{R : Type u} → [inst : NonUnitalNonAssocSemiring R] → Set R → NonUnitalSubsemiring R","name":"NonUnitalSubsemiring.closure","isProp":false,"docString":"The `NonUnitalSubsemiring` generated by a set. ","distance":1.8936434813181344249954918268485926091670989990234375}],["Two linear maps are equal on `Submodule.span s` iff they are equal on `s`. ",{"type":"∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_4} {M₂ : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R₂] [inst_4 : AddCommMonoid M₂] [inst_5 : Module R₂ M₂] {F : Type u_8}\n  {σ₁₂ : R →+* R₂} [inst_6 : SemilinearMapClass F σ₁₂ M M₂] {s : Set M} {f g : F},\n  Set.EqOn ⇑f ⇑g ↑(Submodule.span R s) ↔ Set.EqOn (⇑f) (⇑g) s","name":"LinearMap.eqOn_span_iff","isProp":true,"docString":"Two linear maps are equal on `Submodule.span s` iff they are equal on `s`. ","distance":1.8940827914918241248187769087962806224822998046875}]]