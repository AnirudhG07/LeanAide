[["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.3609868273583816122851430918672122061252593994140625}],[" For any pre-games x and y, the birthday of their sum (x + y) equals the Hessenberg sum of their individual birthdays.",{"type":"∀ (x y : SetTheory.PGame), (x + y).birthday = x.birthday.nadd y.birthday","name":"SetTheory.PGame.birthday_add","isProp":true,"docString":" For any pre-games x and y, the birthday of their sum (x + y) equals the Hessenberg sum of their individual birthdays.","distance":0.4962271402583671164876477632788009941577911376953125}],["The theorem `MeasureTheory.AEEqFun.add_toGerm` establishes that for any two almost everywhere strongly measurable functions `f` and `g` from a type `α` to a type `γ` (where `α` has a measurable space structure, `γ` has an addition operation and topological structure, and addition operation is continuous), the germ at almost every point of the measure `μ` of the sum of `f` and `g` is equal to the sum of the germs of `f` and `g`. In other words, the operation of taking the germ commutes with the addition of functions.",{"type":"∀ {α : Type u_1} {γ : Type u_3} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : TopologicalSpace γ]\n  [inst_2 : Add γ] [inst_3 : ContinuousAdd γ] (f g : α →ₘ[μ] γ), (f + g).toGerm = f.toGerm + g.toGerm","name":"MeasureTheory.AEEqFun.add_toGerm","isProp":true,"docString":"The theorem `MeasureTheory.AEEqFun.add_toGerm` establishes that for any two almost everywhere strongly measurable functions `f` and `g` from a type `α` to a type `γ` (where `α` has a measurable space structure, `γ` has an addition operation and topological structure, and addition operation is continuous), the germ at almost every point of the measure `μ` of the sum of `f` and `g` is equal to the sum of the germs of `f` and `g`. In other words, the operation of taking the germ commutes with the addition of functions.","distance":0.476412840113657087837140124975121580064296722412109375}],["Eta rule for cocones. ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u₃} →\n      [inst_1 : CategoryTheory.Category.{v₃, u₃} C] →\n        {F : CategoryTheory.Functor J C} → (c : CategoryTheory.Limits.Cocone F) → c ≅ { pt := c.pt, ι := c.ι }","name":"CategoryTheory.Limits.Cocones.eta","isProp":false,"docString":"Eta rule for cocones. ","distance":0.38403224582685135946036325549357570707798004150390625}],[" For any finite set `ι`, and any additive commutative group `E` with a real number module structure, the parallelepiped spanned by a vector function mapping `ι` to `E` is equal to the convex hull of the set of points obtained by summing and scaling each vector in the function with 0 or 1.",{"type":"∀ {ι : Type u_1} {E : Type u_3} [inst : Fintype ι] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E] (v : ι → E),\n  parallelepiped v = (convexHull ℝ) (Finset.univ.sum fun i => {0, v i})","name":"parallelepiped_eq_convexHull","isProp":true,"docString":" For any finite set `ι`, and any additive commutative group `E` with a real number module structure, the parallelepiped spanned by a vector function mapping `ι` to `E` is equal to the convex hull of the set of points obtained by summing and scaling each vector in the function with 0 or 1.","distance":0.50212659095030776068568911796319298446178436279296875}],["This theorem states that in the field of set theory, for any given impartial game (represented by 'G'), one of two conditions is always true: either the game is equivalent to the zero game (meaning the first player always wins), or the game is 'fuzzy' at zero, meaning it is not distinguishable from the zero game within any finite number of moves, implying that the second player always wins. This theorem underlies the fundamental principle of impartial games.",{"type":"∀ (G : SetTheory.PGame) [inst : G.Impartial], G ≈ 0 ∨ G.Fuzzy 0","name":"SetTheory.PGame.Impartial.equiv_or_fuzzy_zero","isProp":true,"docString":"This theorem states that in the field of set theory, for any given impartial game (represented by 'G'), one of two conditions is always true: either the game is equivalent to the zero game (meaning the first player always wins), or the game is 'fuzzy' at zero, meaning it is not distinguishable from the zero game within any finite number of moves, implying that the second player always wins. This theorem underlies the fundamental principle of impartial games.","distance":0.4784111026377650954799491955782286822795867919921875}],["an endomorphism of the object ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] → (self : CategoryTheory.Idempotents.Karoubi C) → self.X ⟶ self.X","name":"CategoryTheory.Idempotents.Karoubi.p","isProp":false,"docString":"an endomorphism of the object ","distance":0.38975289001486423945408432700787670910358428955078125}],["Head term ",{"type":"{α : Type u_1} → GeneralizedContinuedFraction α → α","name":"GeneralizedContinuedFraction.h","isProp":false,"docString":"Head term ","distance":0.391426123436132311628199431652319617569446563720703125}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.4001625557099417473949642953812144696712493896484375}],["The cone itself ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} → CategoryTheory.Limits.LimitCone F → CategoryTheory.Limits.Cone F","name":"CategoryTheory.Limits.LimitCone.cone","isProp":false,"docString":"The cone itself ","distance":0.401329490801949406719728585812845267355442047119140625}],["the first row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₁","isProp":false,"docString":"the first row ","distance":0.40216729131512296557815488995402120053768157958984375}],["The unique empty cycle. ",{"type":"{α : Type u_1} → Cycle α","name":"Cycle.nil","isProp":false,"docString":"The unique empty cycle. ","distance":0.4028875164368226347022527988883666694164276123046875}],["Eta rule for cones. ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u₃} →\n      [inst_1 : CategoryTheory.Category.{v₃, u₃} C] →\n        {F : CategoryTheory.Functor J C} → (c : CategoryTheory.Limits.Cone F) → c ≅ { pt := c.pt, π := c.π }","name":"CategoryTheory.Limits.Cones.eta","isProp":false,"docString":"Eta rule for cones. ","distance":0.40426364930974478806291472210432402789592742919921875}],["The empty word ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} → {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.40439082083957089697179299037088640034198760986328125}],["The arrow itself. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {X : C} →\n      {J : CategoryTheory.GrothendieckTopology C} →\n        {S : CategoryTheory.GrothendieckTopology.Cover J X} →\n          (self : CategoryTheory.GrothendieckTopology.Cover.Arrow S) → self.Y ⟶ X","name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.f","isProp":false,"docString":"The arrow itself. ","distance":0.404424991401960032266771349895861931145191192626953125}],["The head type ",{"type":"PFunctor.{u} → Type u","name":"PFunctor.A","isProp":false,"docString":"The head type ","distance":0.4044923035258083388043814920820295810699462890625}],["The cocone itself ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u} →\n      [inst_1 : CategoryTheory.Category.{v, u} C] →\n        {F : CategoryTheory.Functor J C} → CategoryTheory.Limits.ColimitCocone F → CategoryTheory.Limits.Cocone F","name":"CategoryTheory.Limits.ColimitCocone.cocone","isProp":false,"docString":"The cocone itself ","distance":0.405800232426499818405574160351534374058246612548828125}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.407633004081476790769755780274863354861736297607421875}],["The tails are equal ",{"type":"∀ {F : PFunctor.{u}} {R : PFunctor.M F → PFunctor.M F → Prop},\n  PFunctor.M.IsBisimulation R →\n    ∀ {a : F.A} {f f' : PFunctor.B F a → PFunctor.M F},\n      R (PFunctor.M.mk { fst := a, snd := f }) (PFunctor.M.mk { fst := a, snd := f' }) →\n        ∀ (i : PFunctor.B F a), R (f i) (f' i)","name":"PFunctor.M.IsBisimulation.tail","isProp":true,"docString":"The tails are equal ","distance":0.4084776348613325946956820189370773732662200927734375}],["Young diagram from a sorted list ",{"type":"(w : List ℕ) → List.Sorted (fun x x_1 => x ≥ x_1) w → YoungDiagram","name":"YoungDiagram.ofRowLens","isProp":false,"docString":"Young diagram from a sorted list ","distance":0.40852255410919247058387782089994288980960845947265625}],["an object in the source category ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {F : CategoryTheory.Functor C D} →\n          {X : C} →\n            {S : CategoryTheory.Presieve X} →\n              {Y : D} → {f : Y ⟶ F.obj X} → CategoryTheory.Presieve.FunctorPushforwardStructure F S f → C","name":"CategoryTheory.Presieve.FunctorPushforwardStructure.preobj","isProp":false,"docString":"an object in the source category ","distance":0.408786967534779555055735045243636704981327056884765625}],["the zeroth row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₀","isProp":false,"docString":"the zeroth row ","distance":0.408835543858968419872468302855850197374820709228515625}],["The identity partial equiv ",{"type":"(α : Type u_5) → PartialEquiv α α","name":"PartialEquiv.refl","isProp":false,"docString":"The identity partial equiv ","distance":0.4092553283629316585034985109814442694187164306640625}],["The empty set is meagre. ",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X], IsMeagre ∅","name":"meagre_empty","isProp":true,"docString":"The empty set is meagre. ","distance":0.4099252383706268876295553127420134842395782470703125}]]