[["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] → [inst_1 : MetricSpace P] → [inst_2 : NormedAddTorsor V P] → AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.9409364677659797226993987351306714117527008056640625}],[" The hyperbolic sine function is defined as `sinh(x) = (e^x - e^(-x))/2`.",{"type":"∀ (x : ℝ), x.sinh = (x.exp - (-x).exp) / 2","name":"Real.sinh_eq","isProp":true,"docString":" The hyperbolic sine function is defined as `sinh(x) = (e^x - e^(-x))/2`.","distance":1.9492949707414854998432929278351366519927978515625}],["The theorem `GaloisConnection.u_top` states that for any types `α` and `β` which have a partial order and a predefined maximum element (top), if two functions `l : α → β` and `u : β → α` form a Galois connection, then the maximum element of type `β` when mapped through the function `u` gives the maximum element (top) of type `α`. In other words, for a Galois connection, the function `u` sends the top element of `β` to the top element of `α`.",{"type":"∀ {α : Type u} {β : Type v} [inst : PartialOrder α] [inst_1 : Preorder β] [inst_2 : OrderTop α] [inst_3 : OrderTop β]\n  {l : α → β} {u : β → α}, GaloisConnection l u → u ⊤ = ⊤","name":"GaloisConnection.u_top","isProp":true,"docString":"The theorem `GaloisConnection.u_top` states that for any types `α` and `β` which have a partial order and a predefined maximum element (top), if two functions `l : α → β` and `u : β → α` form a Galois connection, then the maximum element of type `β` when mapped through the function `u` gives the maximum element (top) of type `α`. In other words, for a Galois connection, the function `u` sends the top element of `β` to the top element of `α`.","distance":1.9623972842233980973247753354371525347232818603515625}],["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.Limits.HasZeroObject C] → Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.9426446654409428305143592297099530696868896484375}],[" If `A` is a set-like type, `M₁` has an identity element `e` for some operation, and `1` is in class `OneMemClass`, then `coe (1 : M₁) = e`.",{"type":"∀ {A : Type u_4} {M₁ : Type u_5} [inst : SetLike A M₁] [inst_1 : One M₁] [hA : OneMemClass A M₁] (S' : A), ↑1 = 1","name":"OneMemClass.coe_one","isProp":true,"docString":" If `A` is a set-like type, `M₁` has an identity element `e` for some operation, and `1` is in class `OneMemClass`, then `coe (1 : M₁) = e`.","distance":1.949766538679288618851614955929107964038848876953125}],["The theorem `isClopen_iff` states that for any type `α` equipped with a topology and assumed to be preconnected, and any set `s` of type `α`, the statement \"The set `s` is clopen\" is equivalent to \"The set `s` is either empty or equal to the universal set of `α`\". Here, a set is defined to be clopen if it is both closed and open in the given topological space. This theorem essentially says that in a preconnected topological space, the only clopen sets are the empty set and the entire space itself.",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : Set α}, IsClopen s ↔ s = ∅ ∨ s = Set.univ","name":"isClopen_iff","isProp":true,"docString":"The theorem `isClopen_iff` states that for any type `α` equipped with a topology and assumed to be preconnected, and any set `s` of type `α`, the statement \"The set `s` is clopen\" is equivalent to \"The set `s` is either empty or equal to the universal set of `α`\". Here, a set is defined to be clopen if it is both closed and open in the given topological space. This theorem essentially says that in a preconnected topological space, the only clopen sets are the empty set and the entire space itself.","distance":1.963732722891310178425783306010998785495758056640625}],["A choice-free shortcut instance.",{"type":"∀ (α : Type u) [inst : OrderedAddCommGroup α],\n  ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1","name":"OrderedAddCommGroup.to_contravariantClass_right_le","isProp":true,"docString":"A choice-free shortcut instance.","distance":1.9455306762621320526562840313999913632869720458984375}],["The stalk at `x` of a `PresheafedSpace`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasColimits C] → (X : AlgebraicGeometry.PresheafedSpace C) → ↑↑X → C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"docString":"The stalk at `x` of a `PresheafedSpace`.\n","distance":1.94765819620169278181265326566062867641448974609375}],["A modified evaluation for the code which returns an `Option ℕ` instead of a `Part ℕ`. To avoid\nundecidability, `evaln` takes a parameter `k` and fails if it encounters a number ≥ k in the course\nof its execution. Other than this, the semantics are the same as in `Nat.Partrec.Code.eval`.\n",{"type":"ℕ → Nat.Partrec.Code → ℕ → Option ℕ","name":"Nat.Partrec.Code.evaln","isProp":false,"docString":"A modified evaluation for the code which returns an `Option ℕ` instead of a `Part ℕ`. To avoid\nundecidability, `evaln` takes a parameter `k` and fails if it encounters a number ≥ k in the course\nof its execution. Other than this, the semantics are the same as in `Nat.Partrec.Code.eval`.\n","distance":1.9479899545595704690725824548280797898769378662109375}],["If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ",{"type":"{α : Type u} → Task α → α","name":"Task.get","isProp":false,"docString":"If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ","distance":1.9487499292377339354942478166776709258556365966796875}],["Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n",{"type":"Sort u → Sort u","name":"semiOutParam","isProp":false,"docString":"Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n","distance":1.9489540828686955364901223219931125640869140625}],["Euclidean center of the circle with center `z` and radius `r` in the hyperbolic metric. ",{"type":"UpperHalfPlane → ℝ → UpperHalfPlane","name":"UpperHalfPlane.center","isProp":false,"docString":"Euclidean center of the circle with center `z` and radius `r` in the hyperbolic metric. ","distance":1.949554957353850870305222997558303177356719970703125}],["Cast a `SNum` to the corresponding integer. ",{"type":"SNum → ℤ","name":"Int.ofSnum","isProp":false,"docString":"Cast a `SNum` to the corresponding integer. ","distance":1.9507872956413654375040778177208267152309417724609375}],["Provide a coercion to `Type u` for a concrete category. This is not marked as an instance\nas it could potentially apply to every type, and so is too expensive in typeclass search.\n\nYou can use it on particular examples as:\n```\ninstance : HasCoeToSort X := ConcreteCategory.hasCoeToSort X\n```\n",{"type":"(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.ConcreteCategory C] → CoeSort C (Type w)","name":"CategoryTheory.ConcreteCategory.hasCoeToSort","isProp":false,"docString":"Provide a coercion to `Type u` for a concrete category. This is not marked as an instance\nas it could potentially apply to every type, and so is too expensive in typeclass search.\n\nYou can use it on particular examples as:\n```\ninstance : HasCoeToSort X := ConcreteCategory.hasCoeToSort X\n```\n","distance":1.9510228393440496308386400414747186005115509033203125}],["Given an exact short complex `S` and a limit kernel fork `kf` for `S.g`, this is the\nleft homology data for `S` with `K := kf.pt` and `H := 0`. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S : CategoryTheory.ShortComplex C} →\n        CategoryTheory.ShortComplex.Exact S →\n          [inst_2 : CategoryTheory.Limits.HasZeroObject C] →\n            (kf : CategoryTheory.Limits.KernelFork S.g) →\n              CategoryTheory.Limits.IsLimit kf → CategoryTheory.ShortComplex.LeftHomologyData S","name":"CategoryTheory.ShortComplex.Exact.leftHomologyDataOfIsLimitKernelFork","isProp":false,"docString":"Given an exact short complex `S` and a limit kernel fork `kf` for `S.g`, this is the\nleft homology data for `S` with `K := kf.pt` and `H := 0`. ","distance":1.9519258994367729709296099827042780816555023193359375}],["The right homology of a short complex,\ngiven by the `H` field of a chosen right homology data. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] →\n      (S : CategoryTheory.ShortComplex C) → [inst : CategoryTheory.ShortComplex.HasRightHomology S] → C","name":"CategoryTheory.ShortComplex.rightHomology","isProp":false,"docString":"The right homology of a short complex,\ngiven by the `H` field of a chosen right homology data. ","distance":1.95220203615872467395320200012065470218658447265625}],["This is a temporary definition, because we will prove in `code_is_ok` that it always holds.\nIt asserts that `c` is semantically correct; that is, for any `k` and `v`,\n`eval (stepNormal c k v) = eval (Cfg.ret k (Code.eval c v))`, as an equality of partial values\n(so one diverges iff the other does).\n\nIn particular, we can let `k = Cont.halt`, and then this asserts that `stepNormal c Cont.halt v`\nevaluates to `Cfg.halt (Code.eval c v)`. ",{"type":"Turing.ToPartrec.Code → Prop","name":"Turing.ToPartrec.Code.Ok","isProp":false,"docString":"This is a temporary definition, because we will prove in `code_is_ok` that it always holds.\nIt asserts that `c` is semantically correct; that is, for any `k` and `v`,\n`eval (stepNormal c k v) = eval (Cfg.ret k (Code.eval c v))`, as an equality of partial values\n(so one diverges iff the other does).\n\nIn particular, we can let `k = Cont.halt`, and then this asserts that `stepNormal c Cont.halt v`\nevaluates to `Cfg.halt (Code.eval c v)`. ","distance":1.952505512321063729785919349524192512035369873046875}],["Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then\nimported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n",{"type":"Lean.ParserDescr","name":"«termCompile_time_search_path%»","isProp":false,"docString":"Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then\nimported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n","distance":1.95379021401123509349417872726917266845703125}],["Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",{"type":"Lean.Syntax →\n  Lean.Name →\n    optParam Bool false →\n      optParam (Array Simps.ProjectionRule) #[] →\n        optParam Bool false → Lean.CoreM (List Lean.Name × Array Simps.ProjectionData)","name":"Simps.getRawProjections","isProp":false,"docString":"Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n","distance":1.9538246719406739959623564573121257126331329345703125}],["`max:prec` as a term. It is equivalent to `eval_prec max` for `eval_prec` defined at `Meta.lean`.\nWe use `max_prec` to workaround bootstrapping issues.\n",{"type":"Lean.ParserDescr","name":"termMax_prec","isProp":false,"docString":"`max:prec` as a term. It is equivalent to `eval_prec max` for `eval_prec` defined at `Meta.lean`.\nWe use `max_prec` to workaround bootstrapping issues.\n","distance":1.9541660675428789151197861428954638540744781494140625}],["`ghost_calc` is a tactic for proving identities between polynomial functions.\nTypically, when faced with a goal like\n```lean\n∀ (x y : 𝕎 R), verschiebung (x * frobenius y) = verschiebung x * y\n```\nyou can\n1. call `ghost_calc`\n2. do a small amount of manual work -- maybe nothing, maybe `rintro`, etc\n3. call `ghost_simp`\n\nand this will close the goal.\n\n`ghost_calc` cannot detect whether you are dealing with unary or binary polynomial functions.\nYou must give it arguments to determine this.\nIf you are proving a universally quantified goal like the above,\ncall `ghost_calc _ _`.\nIf the variables are introduced already, call `ghost_calc x y`.\nIn the unary case, use `ghost_calc _` or `ghost_calc x`.\n\n`ghost_calc` is a light wrapper around type class inference.\nAll it does is apply the appropriate extensionality lemma and try to infer the resulting goals.\nThis is subtle and Lean's elaborator doesn't like it because of the HO unification involved,\nso it is easier (and prettier) to put it in a tactic script.\n",{"type":"Lean.ParserDescr","name":"WittVector.Tactic.ghostCalc","isProp":false,"docString":"`ghost_calc` is a tactic for proving identities between polynomial functions.\nTypically, when faced with a goal like\n```lean\n∀ (x y : 𝕎 R), verschiebung (x * frobenius y) = verschiebung x * y\n```\nyou can\n1. call `ghost_calc`\n2. do a small amount of manual work -- maybe nothing, maybe `rintro`, etc\n3. call `ghost_simp`\n\nand this will close the goal.\n\n`ghost_calc` cannot detect whether you are dealing with unary or binary polynomial functions.\nYou must give it arguments to determine this.\nIf you are proving a universally quantified goal like the above,\ncall `ghost_calc _ _`.\nIf the variables are introduced already, call `ghost_calc x y`.\nIn the unary case, use `ghost_calc _` or `ghost_calc x`.\n\n`ghost_calc` is a light wrapper around type class inference.\nAll it does is apply the appropriate extensionality lemma and try to infer the resulting goals.\nThis is subtle and Lean's elaborator doesn't like it because of the HO unification involved,\nso it is easier (and prettier) to put it in a tactic script.\n","distance":1.9548574377082299502461637530359439551830291748046875}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.954900367092644142275048579904250800609588623046875}],["If `k` is omitted from the set, its Schnirelmann density is upper bounded by `1 - k⁻¹`.\n",{"type":"∀ {A : Set ℕ} [inst : DecidablePred fun x => x ∈ A] {k : ℕ}, k ∉ A → schnirelmannDensity A ≤ 1 - (↑k)⁻¹","name":"schnirelmannDensity_le_of_not_mem","isProp":true,"docString":"If `k` is omitted from the set, its Schnirelmann density is upper bounded by `1 - k⁻¹`.\n","distance":1.9551394943923654512474286093492992222309112548828125}],["A local minimum of a convex function is a global minimum, restricted to a set `s`.\n",{"type":"∀ {E : Type u_1} {β : Type u_2} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E] [inst_2 : Module ℝ E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] [inst_5 : OrderedAddCommGroup β] [inst_6 : Module ℝ β]\n  [inst_7 : OrderedSMul ℝ β] {s : Set E} {f : E → β} {a : E},\n  a ∈ s → IsLocalMinOn f s a → ConvexOn ℝ s f → IsMinOn f s a","name":"IsMinOn.of_isLocalMinOn_of_convexOn","isProp":true,"docString":"A local minimum of a convex function is a global minimum, restricted to a set `s`.\n","distance":1.9553929119215653908980812047957442700862884521484375}]]