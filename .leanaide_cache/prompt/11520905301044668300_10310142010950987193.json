[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.96153881856999579014200207893736660480499267578125}],[" The real sine function evaluates to zero at zero: `Real.sin 0 = 0`.",{"type":"Real.sin 0 = 0","name":"Real.sin_zero","isProp":true,"docString":" The real sine function evaluates to zero at zero: `Real.sin 0 = 0`.","distance":2.01468826614337981339986072271130979061126708984375}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":2.002411520444263626217207274748943746089935302734375}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type ‚Üí Type} ‚Üí [inst : Monad m] ‚Üí [inst : Lean.MonadEnv m] ‚Üí [inst : Lean.MonadError m] ‚Üí Lean.Name ‚Üí m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.97295920719611928006997914053499698638916015625}],[" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ùïú`, a normed additive group `E` over `ùïú` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ‚Ü¶ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.",{"type":"‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ùïú E] {I : ModelWithCorners ùïú E H} {G : Type u_4}\n  [inst_4 : Inv G] [inst_5 : Zero G] [inst_6 : TopologicalSpace G] [inst_7 : ChartedSpace H G] [self : SmoothInv‚ÇÄ I G]\n  ‚¶Éx : G‚¶Ñ, x ‚â† 0 ‚Üí SmoothAt I I (fun y => y‚Åª¬π) x","name":"SmoothInv‚ÇÄ.smoothAt_inv‚ÇÄ","isProp":true,"docString":" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ùïú`, a normed additive group `E` over `ùïú` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ‚Ü¶ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.","distance":2.01484481230915424276872727205045521259307861328125}],["This theorem, named `sign_pos`, states that for any type `Œ±` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `Œ±` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.",{"type":"‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : Preorder Œ±] [inst_2 : DecidableRel fun x x_1 => x < x_1] {a : Œ±},\n  0 < a ‚Üí SignType.sign a = 1","name":"sign_pos","isProp":true,"docString":"This theorem, named `sign_pos`, states that for any type `Œ±` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `Œ±` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.","distance":2.011824100922762870169435700518079102039337158203125}],["Default definition of `min`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9904757728006148287391852136352099478244781494140625}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9918366667731828290044404639047570526599884033203125}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData ‚Üí String ‚Üí Lean.Name ‚Üí Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.993023759509686687607654675957746803760528564453125}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.9933926759444222653883116436190903186798095703125}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {K : Set F},\n  Convex ‚Ñù K ‚Üí ‚àÄ {u v : F}, v ‚àà K ‚Üí (‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9942019907597714478697525919415056705474853515625}],["Corresponds to `dist_pos`. ",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 < hammingDist x y ‚Üî x ‚â† y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.994241094280473358679728335118852555751800537109375}],["The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. ",{"type":"Lean.ParserDescr","name":"prioHigh","isProp":false,"docString":"The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. ","distance":1.9944353462778832142276996819418855011463165283203125}],["Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ",{"type":"{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ","distance":1.9952118277182560035498681827448308467864990234375}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {f : E ‚Üí Œ≤} {x y z : E}, ConcaveOn ùïú (segment ùïú x y) f ‚Üí z ‚àà segment ùïú x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9962698919660011309673564028344117105007171630859375}],["Helper function for `#long_names` and `#long_instances`. ",{"type":"Std.HashMap Lean.Name (Array Lean.Name) ‚Üí IO Unit","name":"printNameHashMap","isProp":false,"docString":"Helper function for `#long_names` and `#long_instances`. ","distance":1.9977835923977107501769978625816293060779571533203125}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.99821399201148164337382695521228015422821044921875}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module ùïú Œ≤] [inst_3 : OrderedSMul ùïú Œ≤] {f : ùïú ‚Üí Œ≤} {x y z : ùïú},\n  ConcaveOn ùïú (Set.Icc x y) f ‚Üí z ‚àà Set.Icc x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.99905343661687506795487934141419827938079833984375}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData ‚Üí Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":2.000056593268103366511923013604246079921722412109375}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"‚àÄ {d : ‚Ñ§} {a : Pell.Solution‚ÇÅ d}, a = 1 ‚à® a = -1 ‚Üî Pell.Solution‚ÇÅ.y a = 0","name":"Pell.Solution‚ÇÅ.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":2.001066149147391559637298996676690876483917236328125}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) ‚Üí (M : Type u_2) ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommGroup M] ‚Üí [inst : Module R M] ‚Üí ‚Ñï","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":2.00150150457120812319544711499474942684173583984375}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Œ± ‚Üí ‚àÄ {f : Œ± ‚Üí Y}, Continuous f ‚Üí ‚àÄ {x y : Œ±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":2.0026275854070103576987094129435718059539794921875}],["The minimum operation: `min x y`. ",{"type":"{Œ± : Type u} ‚Üí [self : Min Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":2.002860061443630268485094347852282226085662841796875}],["Returns a boolean for whether the `PosNum` is `one`. ",{"type":"PosNum ‚Üí Bool","name":"PosNum.isOne","isProp":false,"docString":"Returns a boolean for whether the `PosNum` is `one`. ","distance":2.003499892942513849192209818284027278423309326171875}]]