[["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.3881578045569338275555537620675750076770782470703125}],[" Schreier's Lemma: A subgroup of a group generated by a set is also generated by the elements obtained by multiplying each element in the product of the subgroup's right transversal and the generating set, with the inverse of the corresponding right transversal element.",{"type":"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} {R S : Set G} (hR : R ∈ Subgroup.rightTransversals ↑H),\n  1 ∈ R →\n    Subgroup.closure S = ⊤ →\n      Subgroup.closure ((fun g => g * (↑(Subgroup.MemRightTransversals.toFun hR g))⁻¹) '' (R * S)) = H","name":"Subgroup.closure_mul_image_eq","isProp":true,"docString":" Schreier's Lemma: A subgroup of a group generated by a set is also generated by the elements obtained by multiplying each element in the product of the subgroup's right transversal and the generating set, with the inverse of the corresponding right transversal element.","distance":0.4987981105361833922273717689677141606807708740234375}],["This theorem states that in a given topological space `X`, if we have a sequence of sets `(s n)` such that every `s n` is a \"meagre\" set, then the countable union of all these sets is also a \"meagre\" set. In mathematical terms, a set is \"meagre\" if its complement is a residual (or comeagre) set.",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X] {s : ℕ → Set X}, (∀ (n : ℕ), IsMeagre (s n)) → IsMeagre (⋃ n, s n)","name":"isMeagre_iUnion","isProp":true,"docString":"This theorem states that in a given topological space `X`, if we have a sequence of sets `(s n)` such that every `s n` is a \"meagre\" set, then the countable union of all these sets is also a \"meagre\" set. In mathematical terms, a set is \"meagre\" if its complement is a residual (or comeagre) set.","distance":0.4774748249611817652038325832108967006206512451171875}],["the underlying presieve ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] → {X : C} → CategoryTheory.Sieve X → CategoryTheory.Presieve X","name":"CategoryTheory.Sieve.arrows","isProp":false,"docString":"the underlying presieve ","distance":0.406871268598255675374986140013788826763629913330078125}],[" For any object X in a category C with a Grothendieck topology J, if S is a cover of X in J and self is a relation in S, then the second arrow of self is in the sieve generated by S.",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : J.Cover X} (self : S.Relation), S.sieve.arrows self.f₂","name":"CategoryTheory.GrothendieckTopology.Cover.Relation.h₂","isProp":true,"docString":" For any object X in a category C with a Grothendieck topology J, if S is a cover of X in J and self is a relation in S, then the second arrow of self is in the sieve generated by S.","distance":0.50276375162605579927088683689362369477748870849609375}],["This theorem states that, given any topological space X and two sets s and t of X, if s is a meagre set, then the intersection of s and t is also a meagre set. In other words, intersecting a meagre set with any other set results in a set that is also meagre.",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X] {s t : Set X}, IsMeagre s → IsMeagre (s ∩ t)","name":"IsMeagre.inter","isProp":true,"docString":"This theorem states that, given any topological space X and two sets s and t of X, if s is a meagre set, then the intersection of s and t is also a meagre set. In other words, intersecting a meagre set with any other set results in a set that is also meagre.","distance":0.484449204994312376815202014768146909773349761962890625}],["projection expression ",{"type":"Simps.ParsedProjectionData → Option Lean.Expr","name":"Simps.ParsedProjectionData.expr?","isProp":false,"docString":"projection expression ","distance":0.408276497306933661146643999018124304711818695068359375}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.410650737656647446538471513122203759849071502685546875}],["The empty pre-set ",{"type":"PSet","name":"PSet.empty","isProp":false,"docString":"The empty pre-set ","distance":0.412494869539075548203754806309007108211517333984375}],["the first row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₁","isProp":false,"docString":"the first row ","distance":0.4178959397819095311632509037735871970653533935546875}],["The empty word ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} → {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.41880590373458337349887870004749856889247894287109375}],["a section of `S.g` ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_3, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {S : CategoryTheory.ShortComplex C} → CategoryTheory.ShortComplex.Splitting S → (S.X₃ ⟶ S.X₂)","name":"CategoryTheory.ShortComplex.Splitting.s","isProp":false,"docString":"a section of `S.g` ","distance":0.420268340622201586054274002890451811254024505615234375}],["The congrm widget. ",{"type":"ProofWidgets.Component SelectInsertParams","name":"CongrmSelectionPanel","isProp":false,"docString":"The congrm widget. ","distance":0.42029690367614025436893143705674447119235992431640625}],["Continuity ",{"type":"∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {σ : outParam (R →+* S)} {M : outParam (Type u_4)} [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M]\n  {M₂ : outParam (Type u_5)} [inst_4 : TopologicalSpace M₂] [inst_5 : AddCommMonoid M₂] [inst_6 : Module R M]\n  [inst_7 : Module S M₂] [self : ContinuousSemilinearMapClass F σ M M₂] (f : F), Continuous ⇑f","name":"ContinuousSemilinearMapClass.map_continuous","isProp":true,"docString":"Continuity ","distance":0.420848919256772979746727969541097991168498992919921875}],["verschiebung is a natural transformation ",{"type":"∀ {p : ℕ} {R : Type u_1} {S : Type u_2} [hp : Fact (Nat.Prime p)] [inst : CommRing R] [inst_1 : CommRing S]\n  (f : R →+* S) (x : WittVector p R),\n  (WittVector.map f) (WittVector.verschiebung x) = WittVector.verschiebung ((WittVector.map f) x)","name":"WittVector.map_verschiebung","isProp":true,"docString":"verschiebung is a natural transformation ","distance":0.421672767816042348698601927026174962520599365234375}],["a morphism between the first lines ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C} →\n        CategoryTheory.ShortComplex.SnakeInput.Hom S₁ S₂ → (S₁.L₁ ⟶ S₂.L₁)","name":"CategoryTheory.ShortComplex.SnakeInput.Hom.f₁","isProp":false,"docString":"a morphism between the first lines ","distance":0.422724276828397638183787421439774334430694580078125}],["the underlying presheaf ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : CategoryTheory.GrothendieckTopology C} → CategoryTheory.SheafOfTypes J → CategoryTheory.Functor Cᵒᵖ (Type w)","name":"CategoryTheory.SheafOfTypes.val","isProp":false,"docString":"the underlying presheaf ","distance":0.42290726416441526414047302750987000763416290283203125}],["The glued scheme of a glued space. ",{"type":"AlgebraicGeometry.Scheme.GlueData → AlgebraicGeometry.Scheme","name":"AlgebraicGeometry.Scheme.GlueData.glued","isProp":false,"docString":"The glued scheme of a glued space. ","distance":0.4241622127317448143202227583969943225383758544921875}],["The ground set ",{"type":"{α : Type u_2} → IndepMatroid α → Set α","name":"IndepMatroid.E","isProp":false,"docString":"The ground set ","distance":0.424557056235242813446717491387971676886081695556640625}],["There is a splitting ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.424746701349525357382930224048322997987270355224609375}],["The underlying presheaf of a sheaf ",{"type":"{C : Type u} → [inst : CategoryTheory.Category.{v, u} C] → {X : TopCat} → TopCat.Sheaf C X → TopCat.Presheaf C X","name":"TopCat.Sheaf.presheaf","isProp":false,"docString":"The underlying presheaf of a sheaf ","distance":0.424758739316812461428440883537405170500278472900390625}],["The empty set is meagre. ",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X], IsMeagre ∅","name":"meagre_empty","isProp":true,"docString":"The empty set is meagre. ","distance":0.424992161255135891817502624689950607717037200927734375}],["tensorator ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            {F : C → D} →\n              [inst_4 : CategoryTheory.Functorial F] →\n                [self : CategoryTheory.LaxMonoidal F] →\n                  (X Y : C) →\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) ⟶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.μ","isProp":false,"docString":"tensorator ","distance":0.425780804703300430613666094359359703958034515380859375}],["a morphism between the second lines ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C} →\n        CategoryTheory.ShortComplex.SnakeInput.Hom S₁ S₂ → (S₁.L₂ ⟶ S₂.L₂)","name":"CategoryTheory.ShortComplex.SnakeInput.Hom.f₂","isProp":false,"docString":"a morphism between the second lines ","distance":0.4277004847828822509114843342103995382785797119140625}]]