[["`getRelSides e` returns the left and right hand sides of `e` if `e` is a comparison,\nand fails otherwise.\nThis function is more naturally in the `Option` monad, but it is convenient to put in `MetaM`\nfor compositionality.\n ",{"type":"Lean.Expr ‚Üí Lean.MetaM (Lean.Expr √ó Lean.Expr)","name":"Linarith.getRelSides","isProp":false,"docString":"`getRelSides e` returns the left and right hand sides of `e` if `e` is a comparison,\nand fails otherwise.\nThis function is more naturally in the `Option` monad, but it is convenient to put in `MetaM`\nfor compositionality.\n ","distance":1.9361905133165369097270058773574419319629669189453125}],[" Given types `Œ±` and `Œ≤` with preorders, scalar multiplication `SMul` between them, and positive reflection of inequality `SMulPosReflectLE`, if `a‚ÇÅ ‚Ä¢ b` ‚â§ `a‚ÇÇ ‚Ä¢ b` and `b` is positive, then `a‚ÇÅ` ‚â§ `a‚ÇÇ`.",{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {a‚ÇÅ a‚ÇÇ : Œ±} {b : Œ≤} [inst : SMul Œ± Œ≤] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤]\n  [inst_3 : Zero Œ≤] [inst_4 : SMulPosReflectLE Œ± Œ≤], a‚ÇÅ ‚Ä¢ b ‚â§ a‚ÇÇ ‚Ä¢ b ‚Üí 0 < b ‚Üí a‚ÇÅ ‚â§ a‚ÇÇ","name":"le_of_smul_le_smul_of_pos_right","isProp":true,"docString":" Given types `Œ±` and `Œ≤` with preorders, scalar multiplication `SMul` between them, and positive reflection of inequality `SMulPosReflectLE`, if `a‚ÇÅ ‚Ä¢ b` ‚â§ `a‚ÇÇ ‚Ä¢ b` and `b` is positive, then `a‚ÇÅ` ‚â§ `a‚ÇÇ`.","distance":1.9499201780890569324355965363793075084686279296875}],["The theorem `openSegment_symm` states that for any ordered semiring `ùïú` and any two elements `x` and `y` of an additive commutative monoid `E` endowed with a scalar multiplication `SMul` by `ùïú`, the open segment between `x` and `y` is the same as the open segment between `y` and `x`. In other words, the order of `x` and `y` does not matter when determining the open segment, symbolically represented as `openSegment ùïú x y = openSegment ùïú y x`. An open segment here refers to the set of all points that can be obtained as a convex combination of `x` and `y`, where the coefficients are strictly positive and sum to 1.",{"type":"‚àÄ (ùïú : Type u_1) {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : SMul ùïú E] (x y : E),\n  openSegment ùïú x y = openSegment ùïú y x","name":"openSegment_symm","isProp":true,"docString":"The theorem `openSegment_symm` states that for any ordered semiring `ùïú` and any two elements `x` and `y` of an additive commutative monoid `E` endowed with a scalar multiplication `SMul` by `ùïú`, the open segment between `x` and `y` is the same as the open segment between `y` and `x`. In other words, the order of `x` and `y` does not matter when determining the open segment, symbolically represented as `openSegment ùïú x y = openSegment ùïú y x`. An open segment here refers to the set of all points that can be obtained as a convex combination of `x` and `y`, where the coefficients are strictly positive and sum to 1.","distance":1.97534377322646292896024533547461032867431640625}],["An open ball in a product space is a product of open balls. See also `ball_pi'`\nfor a version assuming `Nonempty Œ≤` instead of `0 < r`. ",{"type":"‚àÄ {Œ≤ : Type v} {œÄ : Œ≤ ‚Üí Type u_3} [inst : Fintype Œ≤] [inst_1 : (b : Œ≤) ‚Üí PseudoMetricSpace (œÄ b)] (x : (b : Œ≤) ‚Üí œÄ b)\n  {r : ‚Ñù}, 0 < r ‚Üí Metric.ball x r = Set.pi Set.univ fun b => Metric.ball (x b) r","name":"ball_pi","isProp":true,"docString":"An open ball in a product space is a product of open balls. See also `ball_pi'`\nfor a version assuming `Nonempty Œ≤` instead of `0 < r`. ","distance":1.938798738699102131022300454787909984588623046875}],[" Given a non-unital normed ring `A` over a scalar field `ùïú`, where scalar multiplication commutes and `A` forms a scalar tower, the double centralizer maps commute, i.e., `self.toProd.1 (y * x) = self.toProd.2.1 y * x` for any `DoubleCentralizer` instance `self` and elements `x, y` in `A`.",{"type":"‚àÄ {ùïú : Type u} {A : Type v} [inst : NontriviallyNormedField ùïú] [inst_1 : NonUnitalNormedRing A]\n  [inst_2 : NormedSpace ùïú A] [inst_3 : SMulCommClass ùïú A A] [inst_4 : IsScalarTower ùïú A A]\n  (self : DoubleCentralizer ùïú A) (x y : A), self.toProd.2 x * y = x * self.toProd.1 y","name":"DoubleCentralizer.central","isProp":true,"docString":" Given a non-unital normed ring `A` over a scalar field `ùïú`, where scalar multiplication commutes and `A` forms a scalar tower, the double centralizer maps commute, i.e., `self.toProd.1 (y * x) = self.toProd.2.1 y * x` for any `DoubleCentralizer` instance `self` and elements `x, y` in `A`.","distance":1.950206255898774276857920995098538696765899658203125}],["The theorem `Subsemigroup.nonUnitalSubsemiringClosure_eq_closure` states that for any type `R` that forms a `NonUnitalNonAssocSemiring` (a non-associative and non-unital semiring), and for any `Subsemigroup` `M` of `R`, the `NonUnitalSubsemiring` generated by `M` is precisely the same as the `NonUnitalSubsemiring.closure` of the set underlying `M`. In other words, the `NonUnitalSubsemiring` that we can generate by taking the closure of `M` (the smallest `NonUnitalSubsemiring` of `R` that contains `M`) is the same as the `NonUnitalSubsemiring` we get directly from `M` itself.",{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] (M : Subsemigroup R),\n  M.nonUnitalSubsemiringClosure = NonUnitalSubsemiring.closure ‚ÜëM","name":"Subsemigroup.nonUnitalSubsemiringClosure_eq_closure","isProp":true,"docString":"The theorem `Subsemigroup.nonUnitalSubsemiringClosure_eq_closure` states that for any type `R` that forms a `NonUnitalNonAssocSemiring` (a non-associative and non-unital semiring), and for any `Subsemigroup` `M` of `R`, the `NonUnitalSubsemiring` generated by `M` is precisely the same as the `NonUnitalSubsemiring.closure` of the set underlying `M`. In other words, the `NonUnitalSubsemiring` that we can generate by taking the closure of `M` (the smallest `NonUnitalSubsemiring` of `R` that contains `M`) is the same as the `NonUnitalSubsemiring` we get directly from `M` itself.","distance":1.975603389465572234939827467314898967742919921875}],["Open segment in a vector space. Note that `openSegment ùïú x x = {x}` instead of being `‚àÖ` when\nthe base semiring has some element between `0` and `1`. ",{"type":"(ùïú : Type u_1) ‚Üí\n  {E : Type u_2} ‚Üí [inst : OrderedSemiring ùïú] ‚Üí [inst : AddCommMonoid E] ‚Üí [inst : SMul ùïú E] ‚Üí E ‚Üí E ‚Üí Set E","name":"openSegment","isProp":false,"docString":"Open segment in a vector space. Note that `openSegment ùïú x x = {x}` instead of being `‚àÖ` when\nthe base semiring has some element between `0` and `1`. ","distance":1.9411800820354099261777491847169585525989532470703125}],["An open ball in a product space is a product of open balls. See also `ball_pi`\nfor a version assuming `0 < r` instead of `Nonempty Œ≤`. ",{"type":"‚àÄ {Œ≤ : Type v} {œÄ : Œ≤ ‚Üí Type u_3} [inst : Fintype Œ≤] [inst_1 : (b : Œ≤) ‚Üí PseudoMetricSpace (œÄ b)] [inst_2 : Nonempty Œ≤]\n  (x : (b : Œ≤) ‚Üí œÄ b) (r : ‚Ñù), Metric.ball x r = Set.pi Set.univ fun b => Metric.ball (x b) r","name":"ball_pi'","isProp":true,"docString":"An open ball in a product space is a product of open balls. See also `ball_pi`\nfor a version assuming `0 < r` instead of `Nonempty Œ≤`. ","distance":1.941290392578297829828670728602446615695953369140625}],["The `NonUnitalStarSubalgebra` obtained from `S : NonUnitalSubalgebra R A` by taking the\nsmallest non-unital subalgebra containing both `S` and `star S`. ",{"type":"{R : Type u} ‚Üí\n  {A : Type v} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : StarRing R] ‚Üí\n        [inst_2 : NonUnitalSemiring A] ‚Üí\n          [inst_3 : StarRing A] ‚Üí\n            [inst_4 : Module R A] ‚Üí\n              [inst_5 : IsScalarTower R A A] ‚Üí\n                [inst_6 : SMulCommClass R A A] ‚Üí\n                  [inst_7 : StarModule R A] ‚Üí NonUnitalSubalgebra R A ‚Üí NonUnitalStarSubalgebra R A","name":"NonUnitalSubalgebra.starClosure","isProp":false,"docString":"The `NonUnitalStarSubalgebra` obtained from `S : NonUnitalSubalgebra R A` by taking the\nsmallest non-unital subalgebra containing both `S` and `star S`. ","distance":1.9509035786791428801478787136147730052471160888671875}],["Construct a `NonUnitalSubring R` from a set `s`, a subsemigroup `sm`, and an additive\nsubgroup `sa` such that `x ‚àà s ‚Üî x ‚àà sm ‚Üî x ‚àà sa`. ",{"type":"{R : Type u} ‚Üí\n  [inst : NonUnitalNonAssocRing R] ‚Üí\n    (s : Set R) ‚Üí (sm : Subsemigroup R) ‚Üí (sa : AddSubgroup R) ‚Üí ‚Üësm = s ‚Üí ‚Üësa = s ‚Üí NonUnitalSubring R","name":"NonUnitalSubring.mk'","isProp":false,"docString":"Construct a `NonUnitalSubring R` from a set `s`, a subsemigroup `sm`, and an additive\nsubgroup `sa` such that `x ‚àà s ‚Üî x ‚àà sm ‚Üî x ‚àà sa`. ","distance":1.95180065685892412119528671610169112682342529296875}],["A normed vector space over an infinite normed field is a noncompact space.\nThis cannot be an instance because in order to apply it,\nLean would have to search for `NormedSpace ùïú E` with unknown `ùïú`.\nWe register this as an instance in two cases: `ùïú = E` and `ùïú = ‚Ñù`. ",{"type":"‚àÄ (ùïú : Type u_5) (E : Type u_6) [inst : NormedField ùïú] [inst_1 : Infinite ùïú] [inst_2 : NormedAddCommGroup E]\n  [inst_3 : Nontrivial E] [inst : NormedSpace ùïú E], NoncompactSpace E","name":"NormedSpace.noncompactSpace","isProp":true,"docString":"A normed vector space over an infinite normed field is a noncompact space.\nThis cannot be an instance because in order to apply it,\nLean would have to search for `NormedSpace ùïú E` with unknown `ùïú`.\nWe register this as an instance in two cases: `ùïú = E` and `ùïú = ‚Ñù`. ","distance":1.9531481935455585752237084307125769555568695068359375}],["Construct a normed group from a norm, i.e., registering the distance and the metric\nspace structure from the norm properties. Note that in most cases this instance creates bad\ndefinitional equalities (e.g., it does not take into account a possibly existing `UniformSpace`\ninstance on `E`).",{"type":"{E : Type u_6} ‚Üí [inst : AddGroup E] ‚Üí AddGroupNorm E ‚Üí NormedAddGroup E","name":"AddGroupNorm.toNormedAddGroup","isProp":false,"docString":"Construct a normed group from a norm, i.e., registering the distance and the metric\nspace structure from the norm properties. Note that in most cases this instance creates bad\ndefinitional equalities (e.g., it does not take into account a possibly existing `UniformSpace`\ninstance on `E`).","distance":1.955324045850051373207634242135100066661834716796875}],["Lift a list of values to a nondeterministic value.\n(The backtrackable state in each will be identical:\nwhatever the state was when we first read from the result.)\n",{"type":"{œÉ : Type} ‚Üí {m : Type ‚Üí Type} ‚Üí [inst : Monad m] ‚Üí [inst : Lean.MonadBacktrack œÉ m] ‚Üí {Œ± : Type} ‚Üí List Œ± ‚Üí Nondet m Œ±","name":"Nondet.ofList","isProp":false,"docString":"Lift a list of values to a nondeterministic value.\n(The backtrackable state in each will be identical:\nwhatever the state was when we first read from the result.)\n","distance":1.9553708557230222719880430304328911006450653076171875}],["Type wrapper around ‚Ñö to make sure the absolute value uniform space instance is picked up\ninstead of the metric space one. We proved in rat.uniform_space_eq that they are equal,\nbut they are not definitionaly equal, so it would confuse the type class system (and probably\nalso human readers). ",{"type":"Type","name":"CompareReals.Q","isProp":false,"docString":"Type wrapper around ‚Ñö to make sure the absolute value uniform space instance is picked up\ninstead of the metric space one. We proved in rat.uniform_space_eq that they are equal,\nbut they are not definitionaly equal, so it would confuse the type class system (and probably\nalso human readers). ","distance":1.9555223173046305529254595967358909547328948974609375}],["A closed ball in a product space is a product of closed balls. See also `closedBall_pi'`\nfor a version assuming `Nonempty Œ≤` instead of `0 ‚â§ r`. ",{"type":"‚àÄ {Œ≤ : Type v} {œÄ : Œ≤ ‚Üí Type u_3} [inst : Fintype Œ≤] [inst_1 : (b : Œ≤) ‚Üí PseudoMetricSpace (œÄ b)] (x : (b : Œ≤) ‚Üí œÄ b)\n  {r : ‚Ñù}, 0 ‚â§ r ‚Üí Metric.closedBall x r = Set.pi Set.univ fun b => Metric.closedBall (x b) r","name":"closedBall_pi","isProp":true,"docString":"A closed ball in a product space is a product of closed balls. See also `closedBall_pi'`\nfor a version assuming `Nonempty Œ≤` instead of `0 ‚â§ r`. ","distance":1.9557483594962563611119321649312041699886322021484375}],["A set of linearly independent vectors in a module `M` over a semiring `K` is also linearly\nindependent over a subring `R` of `K`.\nThe implementation uses minimal assumptions about the relationship between `R`, `K` and `M`.\nThe version where `K` is an `R`-algebra is `LinearIndependent.restrict_scalars_algebras`.\n ",{"type":"‚àÄ {Œπ : Type u'} {R : Type u_2} {K : Type u_3} {M : Type u_4} {v : Œπ ‚Üí M} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring K] [inst_4 : SMulWithZero R K] [inst_5 : Module K M]\n  [inst_6 : IsScalarTower R K M], (Function.Injective fun r => r ‚Ä¢ 1) ‚Üí LinearIndependent K v ‚Üí LinearIndependent R v","name":"LinearIndependent.restrict_scalars","isProp":true,"docString":"A set of linearly independent vectors in a module `M` over a semiring `K` is also linearly\nindependent over a subring `R` of `K`.\nThe implementation uses minimal assumptions about the relationship between `R`, `K` and `M`.\nThe version where `K` is an `R`-algebra is `LinearIndependent.restrict_scalars_algebras`.\n ","distance":1.95654536528335309952808529487811028957366943359375}],["`univ.{u v}` is the order type of the ordinals of `Type u` as a member\nof `Ordinal.{v}` (when `u < v`). It is an inaccessible cardinal. ",{"type":"Ordinal.{max (u + 1) v}","name":"Ordinal.univ","isProp":false,"docString":"`univ.{u v}` is the order type of the ordinals of `Type u` as a member\nof `Ordinal.{v}` (when `u < v`). It is an inaccessible cardinal. ","distance":1.9567191652466016105194057672633789479732513427734375}],["The set of accessible machine states, assuming that the input machine is supported on `S`,\nare the normal states embedded from `S`, plus all write states accessible from these states. ",{"type":"{Œì : Type u_1} ‚Üí\n  {Œõ : Type u_2} ‚Üí\n    {œÉ : Type u_3} ‚Üí (Œõ ‚Üí Turing.TM1.Stmt Œì Œõ œÉ) ‚Üí [inst : Fintype Œì] ‚Üí Finset Œõ ‚Üí Finset Turing.TM1to1.Œõ'","name":"Turing.TM1to1.trSupp","isProp":false,"docString":"The set of accessible machine states, assuming that the input machine is supported on `S`,\nare the normal states embedded from `S`, plus all write states accessible from these states. ","distance":1.95809866743392912979970788001082837581634521484375}],["Extension of scalars turn an `R`-module into `S`-module by M ‚Ü¶ S ‚®Ç M\n",{"type":"{R : Type u‚ÇÅ} ‚Üí {S : Type u‚ÇÇ} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí ModuleCat R ‚Üí ModuleCat S","name":"ModuleCat.ExtendScalars.obj'","isProp":false,"docString":"Extension of scalars turn an `R`-module into `S`-module by M ‚Ü¶ S ‚®Ç M\n","distance":1.9587234201412464518199385565822012722492218017578125}],["In an R‚ÇÅ space, the `Specializes` relation is symmetric,\ni.e., an R‚ÇÅ space is an R‚ÇÄ space. ",{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : R1Space X] {x y : X}, x ‚§≥ y ‚Üî y ‚§≥ x","name":"specializes_comm","isProp":true,"docString":"In an R‚ÇÅ space, the `Specializes` relation is symmetric,\ni.e., an R‚ÇÅ space is an R‚ÇÄ space. ","distance":1.9592321298356143444152621668763458728790283203125}],["Construct a pseudo-metric space structure whose underlying topological space structure\n(definitionally) agrees which a pre-existing topology which is compatible with a given distance\nfunction. ",{"type":"{Œ± : Type u} ‚Üí\n  [inst : TopologicalSpace Œ±] ‚Üí\n    (dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù) ‚Üí\n      (‚àÄ (x : Œ±), dist x x = 0) ‚Üí\n        (‚àÄ (x y : Œ±), dist x y = dist y x) ‚Üí\n          (‚àÄ (x y z : Œ±), dist x z ‚â§ dist x y + dist y z) ‚Üí\n            (‚àÄ (s : Set Œ±), IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, ‚àÄ (y : Œ±), dist x y < Œµ ‚Üí y ‚àà s) ‚Üí PseudoMetricSpace Œ±","name":"PseudoMetricSpace.ofDistTopology","isProp":false,"docString":"Construct a pseudo-metric space structure whose underlying topological space structure\n(definitionally) agrees which a pre-existing topology which is compatible with a given distance\nfunction. ","distance":1.9596551070416403650398251556907780468463897705078125}],["If `univ` is complete, the space is a complete space ",{"type":"‚àÄ {Œ± : Type u} [uniformSpace : UniformSpace Œ±], IsComplete Set.univ ‚Üí CompleteSpace Œ±","name":"completeSpace_of_isComplete_univ","isProp":true,"docString":"If `univ` is complete, the space is a complete space ","distance":1.9599866353532562346373424588819034397602081298828125}],["Reinterpret a `NonUnitalStarSubalgebra` as a `NonUnitalSubalgebra`. ",{"type":"{R : Type u} ‚Üí\n  {A : Type v} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : NonUnitalNonAssocSemiring A] ‚Üí\n        [inst_2 : Module R A] ‚Üí [inst_3 : Star A] ‚Üí NonUnitalStarSubalgebra R A ‚Üí NonUnitalSubalgebra R A","name":"NonUnitalStarSubalgebra.toNonUnitalSubalgebra","isProp":false,"docString":"Reinterpret a `NonUnitalStarSubalgebra` as a `NonUnitalSubalgebra`. ","distance":1.9600158572175978566320964091573841869831085205078125}],["A natural number that is invertible when coerced to a commutative semiring `R`\nis also invertible when coerced to any polynomial ring with rational coefficients.\n\nShort-cut for typeclass resolution. ",{"type":"(œÉ : Type u_1) ‚Üí (R : Type u_2) ‚Üí (p : ‚Ñï) ‚Üí [inst : CommSemiring R] ‚Üí [inst_1 : Invertible ‚Üëp] ‚Üí Invertible ‚Üëp","name":"MvPolynomial.invertibleCoeNat","isProp":false,"docString":"A natural number that is invertible when coerced to a commutative semiring `R`\nis also invertible when coerced to any polynomial ring with rational coefficients.\n\nShort-cut for typeclass resolution. ","distance":1.9601847760916861762581220318679697811603546142578125}]]