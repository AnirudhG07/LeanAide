[["There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ","distance":0.89138358439297060709094466801616363227367401123046875}],[" For every neighborhood of 0 in the natural numbers, there exists a natural number `N` such that for all `n` greater than `N`, `(1/n)` is in that neighborhood.",{"type":"Filter.Tendsto (fun n => (↑n)⁻¹) Filter.atTop (nhds 0)","name":"tendsto_inverse_atTop_nhds_0_nat","isProp":true,"docString":" For every neighborhood of 0 in the natural numbers, there exists a natural number `N` such that for all `n` greater than `N`, `(1/n)` is in that neighborhood.","distance":0.92389124509845188537582316712359897792339324951171875}],["This theorem states that for any given non-negative integers `N` and `n`, the number of positive multiples of `n` that are less than or equal to `N` is precisely `⌊N/n⌋`. This is calculated by filtering out all the elements in the set of natural numbers from `0` to `N` (inclusive) that are divisible by `n` and not equal to `0`, and then counting the number of such elements. The theorem also suggests referring to a similar theorem, `Nat.card_multiples`, which might be a version shifted by one.",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"This theorem states that for any given non-negative integers `N` and `n`, the number of positive multiples of `n` that are less than or equal to `N` is precisely `⌊N/n⌋`. This is calculated by filtering out all the elements in the set of natural numbers from `0` to `N` (inclusive) that are divisible by `n` and not equal to `0`, and then counting the number of such elements. The theorem also suggests referring to a similar theorem, `Nat.card_multiples`, which might be a version shifted by one.","distance":0.95077073664928735130530412789084948599338531494140625}],["The `L`-function of the trivial character mod `N`. ",{"type":"(N : ℕ) → [inst : NeZero N] → ℂ → ℂ","name":"DirichletCharacter.LFunctionTrivChar","isProp":false,"docString":"The `L`-function of the trivial character mod `N`. ","distance":0.89846966312728115955366092748590745031833648681640625}],[" For any natural number `n`, the integer obtained by lifting `n` is non-negative, i.e., `↑n ≥ 0`.",{"type":"∀ (n : ℕ), 0 ≤ ↑n","name":"Int.ofNat_zero_le","isProp":true,"docString":" For any natural number `n`, the integer obtained by lifting `n` is non-negative, i.e., `↑n ≥ 0`.","distance":0.9378296530430356714447270860546268522739410400390625}],["This theorem states that for every natural number `n`, `n` is either equal to zero or greater than zero. In other words, it asserts that any natural number is either zero or a positive integer. This is a fundamental property of natural numbers in the standard mathematical system.",{"type":"∀ (n : ℕ), n = 0 ∨ n > 0","name":"Nat.eq_zero_or_pos","isProp":true,"docString":"This theorem states that for every natural number `n`, `n` is either equal to zero or greater than zero. In other words, it asserts that any natural number is either zero or a positive integer. This is a fundamental property of natural numbers in the standard mathematical system.","distance":0.96432420322977818738507949092308990657329559326171875}],["**Hermite Theorem**. Let `N` be an integer. There are only finitely many number fields\n(in some fixed extension of `ℚ`) of discriminant bounded by `N`. ",{"type":"∀ (A : Type u_2) [inst : Field A] [inst_1 : CharZero A] (N : ℕ), {K | |NumberField.discr ↥↑K| ≤ ↑N}.Finite","name":"NumberField.finite_of_discr_bdd","isProp":true,"docString":"**Hermite Theorem**. Let `N` be an integer. There are only finitely many number fields\n(in some fixed extension of `ℚ`) of discriminant bounded by `N`. ","distance":0.91512754657881212327907860526465810835361480712890625}],["The non-zero non-`N`-smooth numbers are `≥ N`. ",{"type":"∀ (N : ℕ), N.smoothNumbersᶜ \\ {0} ⊆ {n | N ≤ n}","name":"Nat.smoothNumbers_compl","isProp":true,"docString":"The non-zero non-`N`-smooth numbers are `≥ N`. ","distance":0.91823880686832415332077061975724063813686370849609375}],["The strict series `0 < … < n` in `ℕ`. ",{"type":"ℕ → LTSeries ℕ","name":"LTSeries.range","isProp":false,"docString":"The strict series `0 < … < n` in `ℕ`. ","distance":0.96001721676848761344302829456864856183528900146484375}],["If the left-most part is not `{0}`, then the part containing `0` has at least two elements:\neither because it's the left-most part, and then it's not just `0` by assumption, or because it's\nnot the left-most part and then, by increasingness of maximal elements in parts, it contains\na positive element. ",{"type":"∀ {n : ℕ} (c : OrderedFinpartition (n + 1)), Set.range (c.emb 0) ≠ {0} → 1 < c.partSize (c.index 0)","name":"OrderedFinpartition.one_lt_partSize_index_zero","isProp":true,"docString":"If the left-most part is not `{0}`, then the part containing `0` has at least two elements:\neither because it's the left-most part, and then it's not just `0` by assumption, or because it's\nnot the left-most part and then, by increasingness of maximal elements in parts, it contains\na positive element. ","distance":0.9635699881819694834206302402890287339687347412109375}],["The integers modulo `n : ℕ`. ",{"type":"ℕ → Type","name":"ZMod","isProp":false,"docString":"The integers modulo `n : ℕ`. ","distance":0.9905108617196887177414055258850567042827606201171875}],["The \"nondegenerate simplices\" `N n` for all `n : ℕ`. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X : CategoryTheory.SimplicialObject C} → SimplicialObject.Splitting X → ℕ → C","name":"SimplicialObject.Splitting.N","isProp":false,"docString":"The \"nondegenerate simplices\" `N n` for all `n : ℕ`. ","distance":0.99058553464185716830314731851103715598583221435546875}],["The type of integer numbers is equivalent to `ℕ ⊕ ℕ`. ",{"type":"ℤ ≃ ℕ ⊕ ℕ","name":"Equiv.intEquivNatSumNat","isProp":false,"docString":"The type of integer numbers is equivalent to `ℕ ⊕ ℕ`. ","distance":1.003304919940548156631621168344281613826751708984375}],["The \"inclusion\" `N n ⟶ X _[n]` for all `n : ℕ`. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X : CategoryTheory.SimplicialObject C} →\n      (self : SimplicialObject.Splitting X) → (n : ℕ) → self.N n ⟶ X.obj (Opposite.op (SimplexCategory.mk n))","name":"SimplicialObject.Splitting.ι","isProp":false,"docString":"The \"inclusion\" `N n ⟶ X _[n]` for all `n : ℕ`. ","distance":1.01172907041841941833126838901080191135406494140625}],["`N` is closed under additive conjugation ",{"type":"∀ {A : Type u_2} [inst : AddGroup A] {H : AddSubgroup A}, H.Normal → ∀ n ∈ H, ∀ (g : A), g + n + -g ∈ H","name":"AddSubgroup.Normal.conj_mem","isProp":true,"docString":"`N` is closed under additive conjugation ","distance":1.01175160507670280907177584595046937465667724609375}],["The positive non-`k`-smooth (so \"`k`-rough\") numbers up to and including `N` as a `Finset` ",{"type":"ℕ → ℕ → Finset ℕ","name":"Nat.roughNumbersUpTo","isProp":false,"docString":"The positive non-`k`-smooth (so \"`k`-rough\") numbers up to and including `N` as a `Finset` ","distance":1.0120275387100239328219686285592615604400634765625}],["`n₀` is always `> 0` ",{"type":"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Nonempty α] {T : ℕ → ℝ} {g : ℝ → ℝ} {a b : α → ℝ} {r : α → ℕ → ℕ}\n  (self : AkraBazziRecurrence T g a b r), 0 < self.n₀","name":"AkraBazziRecurrence.n₀_gt_zero","isProp":true,"docString":"`n₀` is always `> 0` ","distance":1.0134627927212107589838296917150728404521942138671875}],["An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is\nrequired to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove\nresults where you want to change each term in a polynomial to something else depending on the\n`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. ",{"type":"∀ {R : Type u_1} [inst : Semiring R] (P : Polynomial R → Prop) (N : ℕ),\n  P 0 →\n    (∀ (n : ℕ) (r : R), r ≠ 0 → n ≤ N → P (Polynomial.C r * Polynomial.X ^ n)) →\n      (∀ (f g : Polynomial R), f.natDegree < g.natDegree → g.natDegree ≤ N → P f → P g → P (f + g)) →\n        ∀ (f : Polynomial R), f.natDegree ≤ N → P f","name":"Polynomial.induction_with_natDegree_le","isProp":true,"docString":"An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is\nrequired to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove\nresults where you want to change each term in a polynomial to something else depending on the\n`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. ","distance":1.0148038931269665052781192571274004876613616943359375}],["A dependent induction principle for `NzsNum`, with base cases\n`0 : SNum` and `(-1) : SNum`. ",{"type":"{C : SNum → Sort u_1} →\n  ((b : Bool) → C (SNum.zero b)) → ((b : Bool) → (p : SNum) → C p → C (SNum.bit b p)) → (p : NzsNum) → C (SNum.nz p)","name":"NzsNum.drec'","isProp":false,"docString":"A dependent induction principle for `NzsNum`, with base cases\n`0 : SNum` and `(-1) : SNum`. ","distance":1.0169518905300727329432675105636008083820343017578125}],["`N` is closed under conjugation ",{"type":"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, H.Normal → ∀ n ∈ H, ∀ (g : G), g * n * g⁻¹ ∈ H","name":"Subgroup.Normal.conj_mem","isProp":true,"docString":"`N` is closed under conjugation ","distance":1.02198971904888225026297732256352901458740234375}],["Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). ",{"type":"Lean.ParserDescr","name":"finiteness?","isProp":false,"docString":"Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). ","distance":1.0262635985615826683670093188993632793426513671875}],["The constant function with value `n : ℤ`. ",{"type":"{α : Type u_1} → ℤ → Poly α","name":"Poly.const","isProp":false,"docString":"The constant function with value `n : ℤ`. ","distance":1.02743355060095087338822850142605602741241455078125}],["The proposition that `n` is not zero. ",{"type":"∀ {R : Type u_1} {inst : Zero R} {n : R} [self : NeZero n], n ≠ 0","name":"NeZero.out","isProp":true,"docString":"The proposition that `n` is not zero. ","distance":1.02825137983162750998644696664996445178985595703125}],["the predicate of objects that are `≤ n` for `n : ℤ`. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      [inst_2 : CategoryTheory.Limits.HasZeroObject C] →\n        [inst_3 : CategoryTheory.HasShift C ℤ] →\n          [inst_4 : ∀ (n : ℤ), (CategoryTheory.shiftFunctor C n).Additive] →\n            [inst_5 : CategoryTheory.Pretriangulated C] → CategoryTheory.Triangulated.TStructure C → ℤ → C → Prop","name":"CategoryTheory.Triangulated.TStructure.LE","isProp":false,"docString":"the predicate of objects that are `≤ n` for `n : ℤ`. ","distance":1.03156698022381032586736182565800845623016357421875}]]