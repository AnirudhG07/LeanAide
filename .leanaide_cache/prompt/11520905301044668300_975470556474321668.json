[["The constant function with value `n : ℤ`. ",{"type":"{α : Type u_1} → ℤ → Poly α","name":"Poly.const","isProp":false,"docString":"The constant function with value `n : ℤ`. ","distance":0.66425356198305640642587377442396245896816253662109375}],[" For all natural numbers n, n = n / 1.",{"type":"∀ (n : ℕ), n / 1 = n","name":"Nat.div_one","isProp":true,"docString":" For all natural numbers n, n = n / 1.","distance":0.63447279126713429509010211404529400169849395751953125}],["This theorem states that for any natural number `n`, the product of `1` and `n` is equal to `n`. In the language of mathematics, it asserts that 1 is the multiplicative identity in the set of natural numbers, i.e., multiplying any natural number by 1 results in the same number.",{"type":"∀ (n : ℕ), 1 * n = n","name":"Nat.one_mul","isProp":true,"docString":"This theorem states that for any natural number `n`, the product of `1` and `n` is equal to `n`. In the language of mathematics, it asserts that 1 is the multiplicative identity in the set of natural numbers, i.e., multiplying any natural number by 1 results in the same number.","distance":0.7959484716040117202595638445927761495113372802734375}],["A single variable `n` is represented by a sum with coefficient `1` and monomial `n`. ",{"type":"ℕ → Linarith.Sum","name":"Linarith.var","isProp":false,"docString":"A single variable `n` is represented by a sum with coefficient `1` and monomial `n`. ","distance":0.675608912686694651483776397071778774261474609375}],[" An integer `n` is a unit in the monoid of integers if and only if |n| = 1, where |n| represents the absolute value of `n`.",{"type":"∀ {n : ℤ}, IsUnit n ↔ n.natAbs = 1","name":"Int.isUnit_iff_natAbs_eq","isProp":true,"docString":" An integer `n` is a unit in the monoid of integers if and only if |n| = 1, where |n| represents the absolute value of `n`.","distance":0.6739647700546307351743280378286726772785186767578125}],["This theorem states that for any integer `n`, `n` is a unit in the monoid of integers if and only if the absolute value of `n` is `1`. In more mathematical terms, an integer `n` has a two-sided inverse (making it a unit) if and only if the absolute value of `n` (represented by `Int.natAbs n` in Lean) equals `1`. The two-sided inverse here would be the multiplicative inverse, as the integers form a monoid under multiplication.",{"type":"∀ {n : ℤ}, IsUnit n ↔ n.natAbs = 1","name":"Int.isUnit_iff_natAbs_eq","isProp":true,"docString":"This theorem states that for any integer `n`, `n` is a unit in the monoid of integers if and only if the absolute value of `n` is `1`. In more mathematical terms, an integer `n` has a two-sided inverse (making it a unit) if and only if the absolute value of `n` (represented by `Int.natAbs n` in Lean) equals `1`. The two-sided inverse here would be the multiplicative inverse, as the integers form a monoid under multiplication.","distance":0.8015899155844736778675496680079959332942962646484375}],["The integers modulo `n : ℕ`. ",{"type":"ℕ → Type","name":"ZMod","isProp":false,"docString":"The integers modulo `n : ℕ`. ","distance":0.739428317029887427480616679531522095203399658203125}],["Multiplication by `(n + 1 : ℕ)` behaves as expected. ",{"type":"∀ {M : Type u} [self : AddMonoid M] (n : ℕ) (x : M), AddMonoid.nsmul (n + 1) x = AddMonoid.nsmul n x + x","name":"AddMonoid.nsmul_succ","isProp":true,"docString":"Multiplication by `(n + 1 : ℕ)` behaves as expected. ","distance":0.756719531441327308840527621214278042316436767578125}],["There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ","distance":0.76746269487544049869853779455297626554965972900390625}],["Multiplication by `n` is a polynomial function. ",{"type":"∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ), WittVector.IsPoly p fun x _Rcr x_1 => x_1 * ↑n","name":"WittVector.mulN_isPoly","isProp":true,"docString":"Multiplication by `n` is a polynomial function. ","distance":0.79017078100503390647446622097049839794635772705078125}],["Multiplication modulo `n` ",{"type":"{n : ℕ} → Fin n → Fin n → Fin n","name":"Fin.mul","isProp":false,"docString":"Multiplication modulo `n` ","distance":0.79526933786967901607312114720116369426250457763671875}],["The limit of `n / (n + x)` is 1, for any constant `x` (valid in `ℝ` or any topological division\nalgebra over `ℝ`, e.g., `ℂ`).\n\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\nstatement simultaneously on `ℚ`, `ℝ` and `ℂ`. ",{"type":"∀ {\u0000\u0000 : Type u_4} [inst : DivisionRing \u0000\u0000] [inst_1 : TopologicalSpace \u0000\u0000] [inst_2 : CharZero \u0000\u0000] [inst_3 : Algebra ℝ \u0000\u0000]\n  [inst_4 : ContinuousSMul ℝ \u0000\u0000] [inst_5 : TopologicalDivisionRing \u0000\u0000] (x : \u0000\u0000),\n  Filter.Tendsto (fun n => ↑n / (↑n + x)) Filter.atTop (nhds 1)","name":"tendsto_natCast_div_add_atTop","isProp":true,"docString":"The limit of `n / (n + x)` is 1, for any constant `x` (valid in `ℝ` or any topological division\nalgebra over `ℝ`, e.g., `ℂ`).\n\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\nstatement simultaneously on `ℚ`, `ℝ` and `ℂ`. ","distance":0.795278579450452216548228534520603716373443603515625}],["If `n % 4 = 1`, then `(-1)^(n/2) = 1`. ",{"type":"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1","name":"ZMod.neg_one_pow_div_two_of_one_mod_four","isProp":true,"docString":"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. ","distance":0.81425219852637120698801709295366890728473663330078125}],["The sequence `n / (2 * n + 1)` tends to `1/2` ",{"type":"Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2))","name":"Stirling.tendsto_self_div_two_mul_self_add_one","isProp":true,"docString":"The sequence `n / (2 * n + 1)` tends to `1/2` ","distance":0.834524831228977692632042817422188818454742431640625}],["Simplification procedure for `#[...][n]` for `n` a `Nat` literal. ",{"type":"Lean.Meta.Simp.DSimproc","name":"Array.reduceGetElem","isProp":false,"docString":"Simplification procedure for `#[...][n]` for `n` a `Nat` literal. ","distance":0.83498436381053731114576521576964296400547027587890625}],["Multiplication by an integer `n` on a commutative additive group,\nconsidered as an additive group homomorphism.",{"type":"{α : Type u_1} → [inst : SubtractionCommMonoid α] → ℤ → α →+ α","name":"zsmulAddGroupHom","isProp":false,"docString":"Multiplication by an integer `n` on a commutative additive group,\nconsidered as an additive group homomorphism.","distance":0.84152658175829675446522060155984945595264434814453125}],["`ℤ` modulo multiples of `n : ℕ` is `ZMod n`. ",{"type":"(n : ℕ) → ℤ ⧸ AddSubgroup.zmultiples ↑n ≃+ ZMod n","name":"Int.quotientZMultiplesNatEquivZMod","isProp":false,"docString":"`ℤ` modulo multiples of `n : ℕ` is `ZMod n`. ","distance":0.84234657474129248644345580032677389681339263916015625}],["Simplification procedure for `#[...][n]?` for `n` a `Nat` literal. ",{"type":"Lean.Meta.Simp.DSimproc","name":"Array.reduceGetElem?","isProp":false,"docString":"Simplification procedure for `#[...][n]?` for `n` a `Nat` literal. ","distance":0.84503899780003610686662796069867908954620361328125}],["Compute `i / n`, where `n` is a `Nat` and inferred the type of `i`. ",{"type":"{n m : ℕ} → Fin (m * n) → Fin m","name":"Fin.divNat","isProp":false,"docString":"Compute `i / n`, where `n` is a `Nat` and inferred the type of `i`. ","distance":0.8487621837849268491282828108523972332477569580078125}],["A version of **Fubini's theorem** in `n` variables, for a natural number `n`. ",{"type":"∀ {\u0000\u0000 : Type u_1} [inst : RCLike \u0000\u0000] {n : ℕ} {E : Fin n → Type u_2}\n  [inst_1 : (i : Fin n) → MeasureTheory.MeasureSpace (E i)]\n  [inst_2 : ∀ (i : Fin n), MeasureTheory.SigmaFinite MeasureTheory.volume] (f : (i : Fin n) → E i → \u0000\u0000),\n  ∫ (x : (i : Fin n) → E i), ∏ i : Fin n, f i (x i) = ∏ i : Fin n, ∫ (x : E i), f i x","name":"MeasureTheory.integral_fin_nat_prod_eq_prod","isProp":true,"docString":"A version of **Fubini's theorem** in `n` variables, for a natural number `n`. ","distance":0.84978665212473725176778316381387412548065185546875}],["If `n % 4 = 3`, then `(-1)^(n/2) = -1`. ",{"type":"∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1","name":"ZMod.neg_one_pow_div_two_of_three_mod_four","isProp":true,"docString":"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. ","distance":0.8507995174499074497731498922803439199924468994140625}],["If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. ",{"type":"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'","name":"Nat.exists_eq_pow_mul_and_not_dvd","isProp":true,"docString":"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. ","distance":0.8535930362487362810242075283895246684551239013671875}],["Raising to the power `(n + 1 : ℕ)` behaves as expected. ",{"type":"∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] (n : ℕ) (x : α),\n  CanonicallyOrderedCommSemiring.npow (n + 1) x = CanonicallyOrderedCommSemiring.npow n x * x","name":"CanonicallyOrderedCommSemiring.npow_succ","isProp":true,"docString":"Raising to the power `(n + 1 : ℕ)` behaves as expected. ","distance":0.857885998395699456153806750080548226833343505859375}],["Inductively define a function on `ℤ` by defining it on `ℕ` and extending it from `n` to `-n`. ",{"type":"{C : ℤ → Sort u_1} → ((n : ℕ) → C ↑n) → (((n : ℕ) → C ↑n) → (n : ℕ) → C (-↑n)) → (n : ℤ) → C n","name":"Int.negInduction","isProp":false,"docString":"Inductively define a function on `ℤ` by defining it on `ℕ` and extending it from `n` to `-n`. ","distance":0.8616436608090658477721035524155013263225555419921875}]]