[["The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9431751928319778155440644695772789418697357177734375}],[" A set of vectors in a vector space is star-convex at a point if and only if the line segment between that point and any vector in the set is contained within the set.",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E] [inst_2 : SMul 𝕜 E] {x : E}\n  {s : Set E}, StarConvex 𝕜 x s ↔ ∀ ⦃y : E⦄, y ∈ s → segment 𝕜 x y ⊆ s","name":"starConvex_iff_segment_subset","isProp":true,"docString":" A set of vectors in a vector space is star-convex at a point if and only if the line segment between that point and any vector in the set is contained within the set.","distance":1.9605809998688730200200325270998291671276092529296875}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":1.9823545335784269472156893243663944303989410400390625}],["`WithTerminal.star` is terminal. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Limits.IsTerminal CategoryTheory.WithTerminal.star","name":"CategoryTheory.WithTerminal.starTerminal","isProp":false,"docString":"`WithTerminal.star` is terminal. ","distance":1.9484139735318282138365475475438870489597320556640625}],[" The sign of real number 0 is 0.",{"type":"Real.sign 0 = 0","name":"Real.sign_zero","isProp":true,"docString":" The sign of real number 0 is 0.","distance":1.9742698329184269478986379908747039735317230224609375}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":1.9832666465984101211716961188358254730701446533203125}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {K : Set F},\n  Convex ℝ K → ∀ {u v : F}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9522965760171027138625277075334452092647552490234375}],["The identity as a `StarAlgHom`. ",{"type":"(R : Type u_2) →\n  (A : Type u_3) →\n    [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → [inst_3 : Star A] → A →⋆ₐ[R] A","name":"StarAlgHom.id","isProp":false,"docString":"The identity as a `StarAlgHom`. ","distance":1.9620198663527299576259110835962928831577301025390625}],["A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit c →\n                    [inst_3 : CategoryTheory.Limits.PreservesColimit K F] →\n                      CategoryTheory.Limits.IsColimit (F.mapCocone c)","name":"CategoryTheory.Limits.isColimitOfPreserves","isProp":false,"docString":"A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":1.9620589334540088355396392216789536178112030029296875}],["An orthonormal set in a finite-dimensional `InnerProductSpace` is maximal, if and only if it\nis a basis. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {v : Set E} [inst_3 : FiniteDimensional 𝕜 E],\n  Orthonormal 𝕜 Subtype.val → ((∀ u ⊇ v, Orthonormal 𝕜 Subtype.val → u = v) ↔ ∃ b, ⇑b = Subtype.val)","name":"maximal_orthonormal_iff_basis_of_finiteDimensional","isProp":true,"docString":"An orthonormal set in a finite-dimensional `InnerProductSpace` is maximal, if and only if it\nis a basis. ","distance":1.9648923070089681086614064042805694043636322021484375}],["The initial object in the category of elements for a representable functor. In `isInitial` it is\nshown that this is initial.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.SmallCategory C] → (A : C) → CategoryTheory.Functor.Elements (CategoryTheory.yoneda.obj A)","name":"CategoryTheory.ColimitAdj.Elements.initial","isProp":false,"docString":"The initial object in the category of elements for a representable functor. In `isInitial` it is\nshown that this is initial.\n","distance":1.9651229488011916490819430691772140562534332275390625}],["The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ",{"type":"∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  (f : WithLp p (α × β)), edist f f = 0","name":"WithLp.prod_edist_self","isProp":true,"docString":"The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ","distance":1.9656677135705920012043179667671211063861846923828125}],["Characterization of minimizers in the projection on a subspace.\nLet `u` be a point in an inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `‖u - v‖` over points in `K` if and only if\nfor all `w ∈ K`, `⟪u - v, w⟫ = 0` (i.e., `u - v` is orthogonal to the subspace `K`)\n",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (K : Submodule 𝕜 E) {u v : E}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w⟫_𝕜 = 0)","name":"norm_eq_iInf_iff_inner_eq_zero","isProp":true,"docString":"Characterization of minimizers in the projection on a subspace.\nLet `u` be a point in an inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `‖u - v‖` over points in `K` if and only if\nfor all `w ∈ K`, `⟪u - v, w⟫ = 0` (i.e., `u - v` is orthogonal to the subspace `K`)\n","distance":1.966402032497448271186613055760972201824188232421875}],["In a strictly convex space, two vectors `x`, `y` are in the same ray if and only if the triangle\ninequality for `x` and `y` becomes an equality. ",{"type":"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\n  SameRay ℝ x y ↔ ‖x + y‖ = ‖x‖ + ‖y‖","name":"sameRay_iff_norm_add","isProp":true,"docString":"In a strictly convex space, two vectors `x`, `y` are in the same ray if and only if the triangle\ninequality for `x` and `y` becomes an equality. ","distance":1.967856191423563938514007531921379268169403076171875}],["The constant functor sending everything to `PUnit.star`. ",{"type":"(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{w + 1})","name":"CategoryTheory.Functor.star","isProp":false,"docString":"The constant functor sending everything to `PUnit.star`. ","distance":1.968595028189269680041206811438314616680145263671875}],["If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n ",{"type":"Linarith.GlobalBranchingPreprocessor","name":"Linarith.natToInt","isProp":false,"docString":"If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n ","distance":1.9709260467589724274972695639007724821567535400390625}],["The stalk at `x` of a `PresheafedSpace`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasColimits C] → (X : AlgebraicGeometry.PresheafedSpace C) → ↑↑X → C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"docString":"The stalk at `x` of a `PresheafedSpace`.\n","distance":1.9713068078808759775455428098211996257305145263671875}],["In a strictly convex space, two vectors `x`, `y` are not in the same ray if and only if the\ntriangle inequality for `x` and `y` is strict. ",{"type":"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\n  ¬SameRay ℝ x y ↔ ‖x + y‖ < ‖x‖ + ‖y‖","name":"not_sameRay_iff_norm_add_lt","isProp":true,"docString":"In a strictly convex space, two vectors `x`, `y` are not in the same ray if and only if the\ntriangle inequality for `x` and `y` is strict. ","distance":1.9723415195141005273882228721049614250659942626953125}],["Restriction of the codomain of a `StarAlgHom` to its range. ",{"type":"{R : Type u_2} →\n  {A : Type u_3} →\n    {B : Type u_4} →\n      [inst : CommSemiring R] →\n        [inst_1 : StarRing R] →\n          [inst_2 : Semiring A] →\n            [inst_3 : Algebra R A] →\n              [inst_4 : StarRing A] →\n                [inst_5 : Semiring B] →\n                  [inst_6 : Algebra R B] →\n                    [inst_7 : StarRing B] →\n                      [inst_8 : StarModule R B] → (f : A →⋆ₐ[R] B) → A →⋆ₐ[R] ↥(StarAlgHom.range f)","name":"StarAlgHom.rangeRestrict","isProp":false,"docString":"Restriction of the codomain of a `StarAlgHom` to its range. ","distance":1.9729311711776682525254500433220528066158294677734375}],["If `x < y`, then `(Set.Iic x)ᶜ` is star convex at `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module 𝕜 E]\n  [inst_3 : OrderedSMul 𝕜 E] {x y : E}, x < y → StarConvex 𝕜 y (Set.Iic x)ᶜ","name":"starConvex_compl_Iic","isProp":true,"docString":"If `x < y`, then `(Set.Iic x)ᶜ` is star convex at `y`. ","distance":1.9735241790528841310248253648751415312290191650390625}],["The leading sign in an `IntList`. ",{"type":"IntList → ℤ","name":"IntList.leadingSign","isProp":false,"docString":"The leading sign in an `IntList`. ","distance":1.975128236575743212455336106359027326107025146484375}],["Range of `Basis.flag` as a `Flag`. ",{"type":"{K : Type u_1} →\n  {V : Type u_2} →\n    [inst : DivisionRing K] →\n      [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → {n : ℕ} → Basis (Fin n) K V → Flag (Submodule K V)","name":"Basis.toFlag","isProp":false,"docString":"Range of `Basis.flag` as a `Flag`. ","distance":1.9753889257204948481927431203075684607028961181640625}],["For `p ≠ 1`, the `p`-adic valuation of an integer `z ≠ 0` is the largest natural number `k` such\nthat `p^k` divides `z`. If `x = 0` or `p = 1`, then `padicValInt p q` defaults to `0`. ",{"type":"ℕ → ℤ → ℕ","name":"padicValInt","isProp":false,"docString":"For `p ≠ 1`, the `p`-adic valuation of an integer `z ≠ 0` is the largest natural number `k` such\nthat `p^k` divides `z`. If `x = 0` or `p = 1`, then `padicValInt p q` defaults to `0`. ","distance":1.976127820234183207759315337170846760272979736328125}],["A class of almost everywhere equal functions is `Integrable` if its function representative\nis integrable. ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {m : MeasurableSpace α} → {μ : MeasureTheory.Measure α} → [inst : NormedAddCommGroup β] → (α →ₘ[μ] β) → Prop","name":"MeasureTheory.AEEqFun.Integrable","isProp":false,"docString":"A class of almost everywhere equal functions is `Integrable` if its function representative\nis integrable. ","distance":1.976820597153359670983263640664517879486083984375}]]