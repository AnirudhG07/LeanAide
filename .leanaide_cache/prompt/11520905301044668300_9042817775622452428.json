[["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] → [inst_1 : MetricSpace P] → [inst_2 : NormedAddTorsor V P] → AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.9533421605890903816060699682566337287425994873046875}],[" In a Henstock prepartition, the number of boxes with the same tag value under the tagging function is bounded by 2 raised to the power of the number of indices.",{"type":"∀ {ι : Type u_1} {I : BoxIntegral.Box ι} {π : BoxIntegral.TaggedPrepartition I} [inst : Fintype ι],\n  π.IsHenstock → ∀ (x : ι → ℝ), (Finset.filter (fun J => π.tag J = x) π.boxes).card ≤ 2 ^ Fintype.card ι","name":"BoxIntegral.TaggedPrepartition.IsHenstock.card_filter_tag_eq_le","isProp":true,"docString":" In a Henstock prepartition, the number of boxes with the same tag value under the tagging function is bounded by 2 raised to the power of the number of indices.","distance":1.986695619166793935761461398215033113956451416015625}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":1.9803951347418313755355256944312714040279388427734375}],["Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ",{"type":"{α : Prop} → {p : α → Prop} → {C : Sort u_1} → C → ((a : α) → p a → C) → C","name":"Classical.existsCases","isProp":false,"docString":"Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ","distance":1.963636076366402249959719483740627765655517578125}],[" If a function `f : α → E` reaches the maximum norm at a point `c` in a filter `l`, then the function `x => ||f x + y||` also reaches the maximum norm at `c` for any vector `y` on the ray through `fc`.",{"type":"∀ {α : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : α → E} {l : Filter α}\n  {c : α} {y : E}, IsMaxFilter (norm ∘ f) l c → SameRay ℝ (f c) y → IsMaxFilter (fun x => ‖f x + y‖) l c","name":"IsMaxFilter.norm_add_sameRay","isProp":true,"docString":" If a function `f : α → E` reaches the maximum norm at a point `c` in a filter `l`, then the function `x => ||f x + y||` also reaches the maximum norm at `c` for any vector `y` on the ray through `fc`.","distance":1.988921587872968022026043399819172918796539306640625}],["This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.denom 0 = 1","name":"RatFunc.denom_zero","isProp":true,"docString":"This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.","distance":1.986999997010320040402575614280067384243011474609375}],["Lists all instances with a long name beginning with `inst`,\ngathered according to the module they are defined in.\nThis is useful for finding automatically named instances with absurd names.\n\nUse as `#long_names` or `#long_names 100` to specify the length.\n",{"type":"Lean.ParserDescr","name":"«command#long_instances_»","isProp":false,"docString":"Lists all instances with a long name beginning with `inst`,\ngathered according to the module they are defined in.\nThis is useful for finding automatically named instances with absurd names.\n\nUse as `#long_names` or `#long_names 100` to specify the length.\n","distance":1.970214402881774073961196336313150823116302490234375}],["**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConvexOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → f z ≤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_segment","isProp":true,"docString":"**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9725122472323557420992301558726467192173004150390625}],["Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ",{"type":"{E : ℕ → Type u_2} → ((n : ℕ) → E n) → Set ((n : ℕ) → E n) → ℕ","name":"PiNat.longestPrefix","isProp":false,"docString":"Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ","distance":1.97380148833758450876985079958103597164154052734375}],["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.Limits.HasZeroObject C] → Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.975487922085214176348699766094796359539031982421875}],["A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit (F.mapCocone c) →\n                    [inst_3 : CategoryTheory.Limits.ReflectsColimit K F] → CategoryTheory.Limits.IsColimit c","name":"CategoryTheory.Limits.isColimitOfReflects","isProp":false,"docString":"A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":1.976035760426729126493228250183165073394775390625}],["`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n",{"type":"{α : Sort u} → [i : α] → α","name":"inferInstance","isProp":false,"docString":"`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n","distance":1.9761470992589493800295485925744287669658660888671875}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConcaveOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.978965763628192764400637315702624619007110595703125}],["A choice-free shortcut instance.",{"type":"∀ (α : Type u) [inst : OrderedAddCommGroup α],\n  ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1","name":"OrderedAddCommGroup.to_contravariantClass_right_le","isProp":true,"docString":"A choice-free shortcut instance.","distance":1.981040216494052597084873923449777066707611083984375}],["Construct a bundled `MeasCat` from the underlying type and the typeclass. ",{"type":"(α : Type u) → [ms : MeasurableSpace α] → MeasCat","name":"MeasCat.of","isProp":false,"docString":"Construct a bundled `MeasCat` from the underlying type and the typeclass. ","distance":1.981463893934998221624255165806971490383148193359375}],["Retrieves the value of `a : Part α` if it exists, and return the provided default value\notherwise. ",{"type":"{α : Type u_1} → (a : Part α) → [inst : Decidable a.Dom] → α → α","name":"Part.getOrElse","isProp":false,"docString":"Retrieves the value of `a : Part α` if it exists, and return the provided default value\notherwise. ","distance":1.9818954437438929261361408862285315990447998046875}],["If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ",{"type":"{α : Type u} → Task α → α","name":"Task.get","isProp":false,"docString":"If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ","distance":1.9823409841631207672918435491737909615039825439453125}],["Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",{"type":"Lean.Syntax →\n  Lean.Name →\n    optParam Bool false →\n      optParam (Array Simps.ProjectionRule) #[] →\n        optParam Bool false → Lean.CoreM (List Lean.Name × Array Simps.ProjectionData)","name":"Simps.getRawProjections","isProp":false,"docString":"Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n","distance":1.9823444831289265266605070792138576507568359375}],["(Implementation) The object part of the connected_components functor from compact Hausdorff spaces\nto Profinite spaces, given by quotienting a space by its connected components.\nSee: https://stacks.math.columbia.edu/tag/0900\n",{"type":"CompHaus → Profinite","name":"CompHaus.toProfiniteObj","isProp":false,"docString":"(Implementation) The object part of the connected_components functor from compact Hausdorff spaces\nto Profinite spaces, given by quotienting a space by its connected components.\nSee: https://stacks.math.columbia.edu/tag/0900\n","distance":1.983490193015802649512124844477511942386627197265625}],["Construct a bundled `FintypeCat` from the underlying type and typeclass. ",{"type":"(X : Type u_1) → [inst : Fintype X] → FintypeCat","name":"FintypeCat.of","isProp":false,"docString":"Construct a bundled `FintypeCat` from the underlying type and typeclass. ","distance":1.9837127171745361220445147409918718039989471435546875}],["Construct a bundled `SemigroupCat` from the underlying type and typeclass. ",{"type":"(M : Type u) → [inst : Semigroup M] → SemigroupCat","name":"SemigroupCat.of","isProp":false,"docString":"Construct a bundled `SemigroupCat` from the underlying type and typeclass. ","distance":1.984173982403075964242589179775677621364593505859375}],["Construct a bundled `UniformSpace` from the underlying type and the typeclass. ",{"type":"(α : Type u) → [inst : UniformSpace α] → UniformSpaceCat","name":"UniformSpaceCat.of","isProp":false,"docString":"Construct a bundled `UniformSpace` from the underlying type and the typeclass. ","distance":1.98424917423008206895929106394760310649871826171875}],["`sigmaFiberEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all fibres of `f` and the total space `α`. ",{"type":"{α : Type u_1} → {β : Type u_2} → (f : α → β) → (y : β) × { x // f x = y } ≃ α","name":"Equiv.sigmaFiberEquiv","isProp":false,"docString":"`sigmaFiberEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all fibres of `f` and the total space `α`. ","distance":1.9852650860498723961455880271387286484241485595703125}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData → Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":1.98532645391490003561330013326369225978851318359375}]]