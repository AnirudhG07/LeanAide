[["`WithTerminal.star` is terminal. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Limits.IsTerminal CategoryTheory.WithTerminal.star","name":"CategoryTheory.WithTerminal.starTerminal","isProp":false,"docString":"`WithTerminal.star` is terminal. ","distance":1.97060288096701530236032340326346457004547119140625}],[" A set of vectors in a vector space is star-convex at a point if and only if the line segment between that point and any vector in the set is contained within the set.",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E] [inst_2 : SMul 𝕜 E] {x : E}\n  {s : Set E}, StarConvex 𝕜 x s ↔ ∀ ⦃y : E⦄, y ∈ s → segment 𝕜 x y ⊆ s","name":"starConvex_iff_segment_subset","isProp":true,"docString":" A set of vectors in a vector space is star-convex at a point if and only if the line segment between that point and any vector in the set is contained within the set.","distance":2.001784437796827464950411012978293001651763916015625}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":2.00740512874147913890965355676598846912384033203125}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {K : Set F},\n  Convex ℝ K → ∀ {u v : F}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.99125865010552249856345952139236032962799072265625}],[" The sign of real number 0 is 0.",{"type":"Real.sign 0 = 0","name":"Real.sign_zero","isProp":true,"docString":" The sign of real number 0 is 0.","distance":2.009093734896067129369612302980385720729827880859375}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":2.018953095362063354656356750638224184513092041015625}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.992455247539516971500006548012606799602508544921875}],["The identity as a `StarAlgHom`. ",{"type":"(R : Type u_2) →\n  (A : Type u_3) →\n    [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → [inst_3 : Star A] → A →⋆ₐ[R] A","name":"StarAlgHom.id","isProp":false,"docString":"The identity as a `StarAlgHom`. ","distance":1.9938895245708285752783694988465867936611175537109375}],["If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n ",{"type":"Linarith.GlobalBranchingPreprocessor","name":"Linarith.natToInt","isProp":false,"docString":"If `h` is an equality or inequality between natural numbers,\n`natToInt` lifts this inequality to the integers.\nIt also adds the facts that the integers involved are nonnegative.\nTo avoid adding the same nonnegativity facts many times, it is a global preprocessor.\n ","distance":1.9940937538582856891622441253275610506534576416015625}],["The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ",{"type":"∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  (f : WithLp p (α × β)), edist f f = 0","name":"WithLp.prod_edist_self","isProp":true,"docString":"The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ","distance":1.994881052820334677022628966369666159152984619140625}],["`WithInitial.star` is initial. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Limits.IsInitial CategoryTheory.WithInitial.star","name":"CategoryTheory.WithInitial.starInitial","isProp":false,"docString":"`WithInitial.star` is initial. ","distance":1.99737112387442738992149315890856087207794189453125}],["The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.99848759806992237741951612406410276889801025390625}],["This instance is provided instead of `StarAlgHomClass` to avoid type class inference loops.\nSee note [lower instance priority] ",{"type":"{F : Type u_1} →\n  {A : Type u_2} →\n    [inst : NormedRing A] →\n      [inst_1 : NormedAlgebra ℂ A] →\n        [inst_2 : CompleteSpace A] →\n          [inst_3 : StarRing A] →\n            [inst_4 : CstarRing A] → [inst_5 : StarModule ℂ A] → [hF : AlgHomClass F ℂ A ℂ] → StarHomClass F A ℂ","name":"WeakDual.Complex.instStarHomClass","isProp":false,"docString":"This instance is provided instead of `StarAlgHomClass` to avoid type class inference loops.\nSee note [lower instance priority] ","distance":1.9998012356255163712859257429954595863819122314453125}],["Extend the scalars of an `AlgHom`. ",{"type":"{A : Type w} →\n  (B : Type u₁) →\n    {C : Type u_1} →\n      {D : Type u_2} →\n        [inst : CommSemiring A] →\n          [inst_1 : CommSemiring C] →\n            [inst_2 : CommSemiring D] →\n              [inst_3 : Algebra A C] →\n                [inst_4 : Algebra A D] →\n                  (f : C →ₐ[A] D) →\n                    [inst_5 : CommSemiring B] →\n                      [inst_6 : Algebra A B] → [inst_7 : Algebra B C] → [inst_8 : IsScalarTower A B C] → C →ₐ[B] D","name":"AlgHom.extendScalars","isProp":false,"docString":"Extend the scalars of an `AlgHom`. ","distance":2.0007098159085270339119233540259301662445068359375}],["The norm of the identity is at most `1`. It is in fact `1`, except when the space is trivial\nwhere it is `0`. It means that one can not do better than an inequality in general. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_4} [inst : SeminormedAddCommGroup E] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : NormedSpace 𝕜 E], ‖ContinuousLinearMap.id 𝕜 E‖ ≤ 1","name":"ContinuousLinearMap.norm_id_le","isProp":true,"docString":"The norm of the identity is at most `1`. It is in fact `1`, except when the space is trivial\nwhere it is `0`. It means that one can not do better than an inequality in general. ","distance":2.0022962298888291599041622248478233814239501953125}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name → Bool) → Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":2.002512977128358517830974960816092789173126220703125}],["Characterization of minimizers in the projection on a subspace.\nLet `u` be a point in an inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `‖u - v‖` over points in `K` if and only if\nfor all `w ∈ K`, `⟪u - v, w⟫ = 0` (i.e., `u - v` is orthogonal to the subspace `K`)\n",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (K : Submodule 𝕜 E) {u v : E}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w⟫_𝕜 = 0)","name":"norm_eq_iInf_iff_inner_eq_zero","isProp":true,"docString":"Characterization of minimizers in the projection on a subspace.\nLet `u` be a point in an inner product space, and let `K` be a nonempty subspace.\nThen point `v` minimizes the distance `‖u - v‖` over points in `K` if and only if\nfor all `w ∈ K`, `⟪u - v, w⟫ = 0` (i.e., `u - v` is orthogonal to the subspace `K`)\n","distance":2.003135586992858652166660249349661171436309814453125}],["An orthonormal set in a finite-dimensional `InnerProductSpace` is maximal, if and only if it\nis a basis. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {v : Set E} [inst_3 : FiniteDimensional 𝕜 E],\n  Orthonormal 𝕜 Subtype.val → ((∀ u ⊇ v, Orthonormal 𝕜 Subtype.val → u = v) ↔ ∃ b, ⇑b = Subtype.val)","name":"maximal_orthonormal_iff_basis_of_finiteDimensional","isProp":true,"docString":"An orthonormal set in a finite-dimensional `InnerProductSpace` is maximal, if and only if it\nis a basis. ","distance":2.0032818728674808284040409489534795284271240234375}],["Endowing the space `WithLp p (α × β)` with the `L^p` distance. We register this instance\nseparate from `WithLp.instProdPseudoMetricSpace` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future metric-like structure on `WithLp p (α × β)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ",{"type":"(p : ENNReal) → (α : Type u_2) → (β : Type u_3) → [inst : Dist α] → [inst : Dist β] → Dist (WithLp p (α × β))","name":"WithLp.instProdDist","isProp":false,"docString":"Endowing the space `WithLp p (α × β)` with the `L^p` distance. We register this instance\nseparate from `WithLp.instProdPseudoMetricSpace` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future metric-like structure on `WithLp p (α × β)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ","distance":2.003893806570620217399891771492548286914825439453125}],["`typeToPointed` is the free functor. ",{"type":"typeToPointed ⊣ CategoryTheory.forget Pointed","name":"typeToPointedForgetAdjunction","isProp":false,"docString":"`typeToPointed` is the free functor. ","distance":2.00465941597894659054190924507565796375274658203125}],["Endowing the space `WithLp p (α × β)` with the `L^p` edistance. We register this instance\nseparate from `WithLp.instProdPseudoEMetric` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future emetric-like structure on `WithLp p (α × β)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ",{"type":"(p : ENNReal) → (α : Type u_2) → (β : Type u_3) → [inst : EDist α] → [inst : EDist β] → EDist (WithLp p (α × β))","name":"WithLp.instProdEDist","isProp":false,"docString":"Endowing the space `WithLp p (α × β)` with the `L^p` edistance. We register this instance\nseparate from `WithLp.instProdPseudoEMetric` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future emetric-like structure on `WithLp p (α × β)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ","distance":2.00702361230474934927769936621189117431640625}],["A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit c →\n                    [inst_3 : CategoryTheory.Limits.PreservesColimit K F] →\n                      CategoryTheory.Limits.IsColimit (F.mapCocone c)","name":"CategoryTheory.Limits.isColimitOfPreserves","isProp":false,"docString":"A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":2.007109209056727738840208985493518412113189697265625}],["a class of triangle which are called `distinguished` ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasZeroObject C] →\n      [inst_2 : CategoryTheory.HasShift C ℤ] →\n        [inst_3 : CategoryTheory.Preadditive C] →\n          [inst_4 : ∀ (n : ℤ), CategoryTheory.Functor.Additive (CategoryTheory.shiftFunctor C n)] →\n            [self : CategoryTheory.Pretriangulated C] → Set (CategoryTheory.Pretriangulated.Triangle C)","name":"CategoryTheory.Pretriangulated.distinguishedTriangles","isProp":false,"docString":"a class of triangle which are called `distinguished` ","distance":2.007420833315863628598663126467727124691009521484375}],["In a strictly convex space, two vectors `x`, `y` are not in the same ray if and only if the\ntriangle inequality for `x` and `y` is strict. ",{"type":"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\n  ¬SameRay ℝ x y ↔ ‖x + y‖ < ‖x‖ + ‖y‖","name":"not_sameRay_iff_norm_add_lt","isProp":true,"docString":"In a strictly convex space, two vectors `x`, `y` are not in the same ray if and only if the\ntriangle inequality for `x` and `y` is strict. ","distance":2.008844981661164208475156556232832372188568115234375}]]