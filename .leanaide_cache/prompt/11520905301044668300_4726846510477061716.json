[["Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n",{"type":"ℕ → Linarith.PCompSet → Linarith.LinarithM Unit","name":"Linarith.update","isProp":false,"docString":"Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n","distance":1.9428817844892289912195337819866836071014404296875}],[" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.",{"type":"Cardinal.lift.{max v u, u} = Cardinal.lift.{v, u}","name":"Cardinal.lift_umax'","isProp":true,"docString":" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.","distance":1.962017092406954876793179209926165640354156494140625}],["This theorem, `isGreatest_univ`, states that for any type `α` that has a preorder and is also an ordered set with a maximum element (denoted as `⊤`), the maximum element is the greatest element of the universal set (i.e., the set that contains all elements of `α`). In other words, no element in the universal set of `α` is greater than the maximum element `⊤`.",{"type":"∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α], IsGreatest Set.univ ⊤","name":"isGreatest_univ","isProp":true,"docString":"This theorem, `isGreatest_univ`, states that for any type `α` that has a preorder and is also an ordered set with a maximum element (denoted as `⊤`), the maximum element is the greatest element of the universal set (i.e., the set that contains all elements of `α`). In other words, no element in the universal set of `α` is greater than the maximum element `⊤`.","distance":1.96160689283124867188234929926693439483642578125}],["The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.94611160392518200978884124197065830230712890625}],[" In the category of TypeVec, two functions with the same point-wise behavior at all indices are equal.",{"type":"∀ {n : ℕ} {α : TypeVec.{u_1} n} {β : TypeVec.{u_2} n} (f g : α.Arrow β), (∀ (i : Fin2 n), f i = g i) → f = g","name":"TypeVec.Arrow.ext","isProp":true,"docString":" In the category of TypeVec, two functions with the same point-wise behavior at all indices are equal.","distance":1.9696424185808731888158717993064783513545989990234375}],["This theorem, `max_zero_sub_max_neg_zero_eq_self`, states that for any type `α` that is an additive group and has a linear order and a covariant class, the maximum of a given element `a` and zero, subtracted by the maximum of the negative of `a` and zero, equals `a` itself. In mathematical notations, this can be represented as: max(a, 0) - max(-a, 0) = a. This theorem essentially provides a relationship between an element and its additive inverse in the context of maximum and subtraction operations.",{"type":"∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α), max a 0 - max (-a) 0 = a","name":"max_zero_sub_max_neg_zero_eq_self","isProp":true,"docString":"This theorem, `max_zero_sub_max_neg_zero_eq_self`, states that for any type `α` that is an additive group and has a linear order and a covariant class, the maximum of a given element `a` and zero, subtracted by the maximum of the negative of `a` and zero, equals `a` itself. In mathematical notations, this can be represented as: max(a, 0) - max(-a, 0) = a. This theorem essentially provides a relationship between an element and its additive inverse in the context of maximum and subtraction operations.","distance":1.9731810893392573991178551295888610184192657470703125}],["Tests whether `declName` has the `@[simp]` attribute in `env`. ",{"type":"Lean.Environment → Lean.Name → Bool","name":"hasSimpAttribute","isProp":false,"docString":"Tests whether `declName` has the `@[simp]` attribute in `env`. ","distance":1.94944471733256019518876200891099870204925537109375}],["**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConvexOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → f z ≤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_segment","isProp":true,"docString":"**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.950142245646555583249437404447235167026519775390625}],["The `𝟙_ V`-shaped generalized element giving the identity in a `V`-enriched category.\n",{"type":"(V : Type v) →\n  [inst : CategoryTheory.Category.{w, v} V] →\n    [inst_1 : CategoryTheory.MonoidalCategory V] →\n      {C : Type u₁} →\n        [inst_2 : CategoryTheory.EnrichedCategory V C] → (X : C) → 𝟙_ V ⟶ CategoryTheory.EnrichedCategory.Hom X X","name":"CategoryTheory.eId","isProp":false,"docString":"The `𝟙_ V`-shaped generalized element giving the identity in a `V`-enriched category.\n","distance":1.958864393464196052008219339768402278423309326171875}],["The maximum operation: `max x y`. ",{"type":"{α : Type u} → [self : Max α] → α → α → α","name":"Max.max","isProp":false,"docString":"The maximum operation: `max x y`. ","distance":1.9589843108338076405061656259931623935699462890625}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name → Bool) → Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.96222815515203397040977506549097597599029541015625}],["`pb.minpolyGen` is the minimal polynomial for `pb.gen`. ",{"type":"{S : Type u_2} →\n  [inst : Ring S] → {A : Type u_4} → [inst_1 : CommRing A] → [inst_2 : Algebra A S] → PowerBasis A S → Polynomial A","name":"PowerBasis.minpolyGen","isProp":false,"docString":"`pb.minpolyGen` is the minimal polynomial for `pb.gen`. ","distance":1.9633075838153590808587978244759142398834228515625}],["**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module 𝕜 β] [inst_3 : OrderedSMul 𝕜 β] {f : 𝕜 → β} {x y z : 𝕜},\n  ConvexOn 𝕜 (Set.Icc x y) f → z ∈ Set.Icc x y → f z ≤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_Icc","isProp":true,"docString":"**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9640095650342159760981530780554749071598052978515625}],["`WithTerminal.star` is terminal. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Limits.IsTerminal CategoryTheory.WithTerminal.star","name":"CategoryTheory.WithTerminal.starTerminal","isProp":false,"docString":"`WithTerminal.star` is terminal. ","distance":1.965129200907359763306203603860922157764434814453125}],["`typeToPointed` is the free functor. ",{"type":"typeToPointed ⊣ CategoryTheory.forget Pointed","name":"typeToPointedForgetAdjunction","isProp":false,"docString":"`typeToPointed` is the free functor. ","distance":1.9662924891172182118026512398500926792621612548828125}],["`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ",{"type":"(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop","name":"Contravariant","isProp":false,"docString":"`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ","distance":1.968369809304330697585783127578906714916229248046875}],["Default definition of `max`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":1.9699258434017592467313306769938208162784576416015625}],["The triangle `productTriangle T` satisfies the universal property of the categorical\nproduct of the triangles `T`. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.HasShift C ℤ] →\n      {J : Type u_1} →\n        (T : J → CategoryTheory.Pretriangulated.Triangle C) →\n          [inst_2 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₁] →\n            [inst_3 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₂] →\n              [inst_4 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₃] →\n                [inst_5 : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).obj₁] →\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Pretriangulated.productTriangle.fan T)","name":"CategoryTheory.Pretriangulated.productTriangle.isLimitFan","isProp":false,"docString":"The triangle `productTriangle T` satisfies the universal property of the categorical\nproduct of the triangles `T`. ","distance":1.9705680028087766419986337496084161102771759033203125}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name → Array Simps.ParsedProjectionData → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.970693008373750831907500469242222607135772705078125}],["The tautological action by `CentroidHom α` on `α`.\n\nThis generalizes `Function.End.applyMulAction`. ",{"type":"{α : Type u_5} → [inst : NonUnitalNonAssocSemiring α] → Module (CentroidHom α) α","name":"CentroidHom.applyModule","isProp":false,"docString":"The tautological action by `CentroidHom α` on `α`.\n\nThis generalizes `Function.End.applyMulAction`. ","distance":1.9709225819459661455113064221222884953022003173828125}],["The pointwise maximum of strictly convex functions is strictly convex. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid β] [inst_3 : SMul 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {s : Set E} {f g : E → β}, StrictConvexOn 𝕜 s f → StrictConvexOn 𝕜 s g → StrictConvexOn 𝕜 s (f ⊔ g)","name":"StrictConvexOn.sup","isProp":true,"docString":"The pointwise maximum of strictly convex functions is strictly convex. ","distance":1.971382700550609712308869347907602787017822265625}],["Bicoloring of a path graph ",{"type":"(n : ℕ) → SimpleGraph.Coloring (SimpleGraph.pathGraph n) Bool","name":"SimpleGraph.pathGraph.bicoloring","isProp":false,"docString":"Bicoloring of a path graph ","distance":1.97144193763418495990435985731892287731170654296875}],["`centroidWeights` equals a constant function. ",{"type":"∀ (k : Type u_1) [inst : DivisionRing k] {ι : Type u_4} (s : Finset ι),\n  Finset.centroidWeights k s = Function.const ι (↑s.card)⁻¹","name":"Finset.centroidWeights_eq_const","isProp":true,"docString":"`centroidWeights` equals a constant function. ","distance":1.971460122592343822134353104047477245330810546875}],["Auxiliary for `popMax`. ",{"type":"{α : Type u_1} →\n  {lt : α → α → Bool} → (self : BinaryHeap α lt) → { a' // BinaryHeap.size a' = BinaryHeap.size self - 1 }","name":"BinaryHeap.popMaxAux","isProp":false,"docString":"Auxiliary for `popMax`. ","distance":1.9722219458607976871888922687503509223461151123046875}]]