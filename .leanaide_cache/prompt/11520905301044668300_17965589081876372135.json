[["Turn `ParsedProjectionData` into `ProjectionData`. ",{"type":"Simps.ParsedProjectionData ‚Üí Simps.ProjectionData","name":"Simps.ParsedProjectionData.toProjectionData","isProp":false,"docString":"Turn `ParsedProjectionData` into `ProjectionData`. ","distance":1.9464767010970926985891082949819974601268768310546875}],[" For any type `Œ±` and any `x : Œ±`, `x ‚àà Set.univ (Œ±)`.",{"type":"‚àÄ {Œ± : Type u} (x : Œ±), x ‚àà Set.univ","name":"Set.mem_univ","isProp":true,"docString":" For any type `Œ±` and any `x : Œ±`, `x ‚àà Set.univ (Œ±)`.","distance":1.9409737905748531971994452760554850101470947265625}],["The theorem `Set.singleton_unop` states that for every type `Œ±` and for any term `x` of the opposite type `Œ±·µí·µñ`, the unary operation (unop) of a singleton set containing `x` is equal to the singleton set containing the unary operation of `x`. This essentially means that applying the unary operation to each member of a singleton set is the same as applying the unary operation to the singleton set itself.",{"type":"‚àÄ {Œ± : Type u_1} (x : Œ±·µí·µñ), {x}.unop = {x.unop}","name":"Set.singleton_unop","isProp":true,"docString":"The theorem `Set.singleton_unop` states that for every type `Œ±` and for any term `x` of the opposite type `Œ±·µí·µñ`, the unary operation (unop) of a singleton set containing `x` is equal to the singleton set containing the unary operation of `x`. This essentially means that applying the unary operation to each member of a singleton set is the same as applying the unary operation to the singleton set itself.","distance":1.97668911768264621287016780115664005279541015625}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name ‚Üí Bool) ‚Üí Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.948341488967375578766905164229683578014373779296875}],[" For any type `R` with a trivial `Star` operation satisfying `TrivialStar` property, `star r = r` for all `r` in `R`.",{"type":"‚àÄ {R : Type u} [inst : Star R] [self : TrivialStar R] (r : R), star r = r","name":"TrivialStar.star_trivial","isProp":true,"docString":" For any type `R` with a trivial `Star` operation satisfying `TrivialStar` property, `star r = r` for all `r` in `R`.","distance":1.9506130624023445552239763856050558388233184814453125}],["This theorem states that for all types `Œ±` and for any set `a` of type `Œ±`, the intersection of the universal set `Set.univ` with the set `a` is equal to `a` itself. In other words, when you intersect any set with the universal set (which contains all elements of the type), you simply get the original set back. In mathematical notation, this can be written as: ‚àÄŒ±, ‚àÄa ‚àà Set Œ±, Set.univ ‚à© a = a.",{"type":"‚àÄ {Œ± : Type u} (a : Set Œ±), Set.univ ‚à© a = a","name":"Set.univ_inter","isProp":true,"docString":"This theorem states that for all types `Œ±` and for any set `a` of type `Œ±`, the intersection of the universal set `Set.univ` with the set `a` is equal to `a` itself. In other words, when you intersect any set with the universal set (which contains all elements of the type), you simply get the original set back. In mathematical notation, this can be written as: ‚àÄŒ±, ‚àÄa ‚àà Set Œ±, Set.univ ‚à© a = a.","distance":1.9774270530674400436765836275299079716205596923828125}],["See Note [custom simps projection]. We specify this explicitly because we don't have a DFunLike\ninstance.\n",{"type":"{Œ± : Type u} ‚Üí\n  {Œ≤ : Type v} ‚Üí [inst : OmegaCompletePartialOrder Œ±] ‚Üí [inst_1 : OmegaCompletePartialOrder Œ≤] ‚Üí (Œ± ‚ÜíùíÑ Œ≤) ‚Üí Œ± ‚Üí Œ≤","name":"OmegaCompletePartialOrder.ContinuousHom.Simps.apply","isProp":false,"docString":"See Note [custom simps projection]. We specify this explicitly because we don't have a DFunLike\ninstance.\n","distance":1.9552592193889533067618913264595903456211090087890625}],["`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n",{"type":"Type (u + 1)","name":"NonemptyType","isProp":false,"docString":"`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n","distance":1.95732236080844845815818189294077455997467041015625}],["We verify that the presheaf representing natural transformations\nbetween `Type v`-enriched functors is actually represented by\nthe usual type of natural transformations!\n",{"type":"{C : Type v} ‚Üí\n  [inst : CategoryTheory.EnrichedCategory (Type v) C] ‚Üí\n    {D : Type v} ‚Üí\n      [inst_1 : CategoryTheory.EnrichedCategory (Type v) D] ‚Üí\n        (F G : CategoryTheory.EnrichedFunctor (Type v) C D) ‚Üí\n          CategoryTheory.enrichedNatTransYoneda F G ‚âÖ\n            CategoryTheory.yoneda.obj\n              (CategoryTheory.enrichedFunctorTypeEquivFunctor F ‚ü∂ CategoryTheory.enrichedFunctorTypeEquivFunctor G)","name":"CategoryTheory.enrichedNatTransYonedaTypeIsoYonedaNatTrans","isProp":false,"docString":"We verify that the presheaf representing natural transformations\nbetween `Type v`-enriched functors is actually represented by\nthe usual type of natural transformations!\n","distance":1.9600814699039037503069948797929100692272186279296875}],["Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m Œ±`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n",{"type":"{œâ : Type u_1} ‚Üí\n  {Œ± : Type} ‚Üí\n    (prio : Œ± ‚Üí Thunk œâ) ‚Üí\n      (Œµ : Œ± ‚Üí Type) ‚Üí\n        [inst : LinearOrder œâ] ‚Üí\n          [inst_1 : (a : Œ±) ‚Üí Estimator (prio a) (Œµ a)] ‚Üí\n            [I : ‚àÄ (a : Œ±), WellFoundedGT ‚Üë(Set.range (EstimatorData.bound (prio a)))] ‚Üí\n              [inst : Ord œâ] ‚Üí\n                [inst : Ord Œ±] ‚Üí\n                  {m : Type ‚Üí Type} ‚Üí\n                    [inst : Monad m] ‚Üí\n                      [inst : Alternative m] ‚Üí\n                        [inst : (a : Œ±) ‚Üí Bot (Œµ a)] ‚Üí Option ‚Ñï ‚Üí (Œ± ‚Üí MLList m Œ±) ‚Üí Œ± ‚Üí MLList m Œ±","name":"impl","isProp":false,"docString":"Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m Œ±`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n","distance":1.961523047458590074398898650542832911014556884765625}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData ‚Üí String ‚Üí Lean.Name ‚Üí Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9620018398994185648831489743315614759922027587890625}],["Turn a non-unital star subalgebra containing `1` into a `StarSubalgebra`. ",{"type":"{R : Type u_1} ‚Üí\n  {A : Type u_2} ‚Üí\n    [inst : CommSemiring R] ‚Üí\n      [inst_1 : StarRing R] ‚Üí\n        [inst_2 : Semiring A] ‚Üí\n          [inst_3 : StarRing A] ‚Üí\n            [inst_4 : Algebra R A] ‚Üí\n              [inst_5 : StarModule R A] ‚Üí (S : NonUnitalStarSubalgebra R A) ‚Üí 1 ‚àà S ‚Üí StarSubalgebra R A","name":"NonUnitalStarSubalgebra.toStarSubalgebra","isProp":false,"docString":"Turn a non-unital star subalgebra containing `1` into a `StarSubalgebra`. ","distance":1.962317026633300098836798497359268367290496826171875}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"‚àÄ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Convex ‚Ñù s ‚Üí ‚àÄ {x : E}, x ‚àà interior s ‚Üí ‚àÄ (t : ‚Ñù), 1 < t ‚Üí closure s ‚äÜ interior (‚áë(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9628276183340733762605623269337229430675506591796875}],["Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.",{"type":"Lean.Name ‚Üí Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.mkParsedProjectionData","isProp":false,"docString":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.","distance":1.9634441179862103243891624515526928007602691650390625}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name ‚Üí Array Simps.ParsedProjectionData ‚Üí Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.964265799359067532492417740286327898502349853515625}],["Insert a new name alignment into the rename extension. ",{"type":"Lean.Name ‚Üí Lean.Name ‚Üí optParam Bool false ‚Üí optParam String \"\" ‚Üí Lean.CoreM Unit","name":"Mathlib.Prelude.Rename.addNameAlignment","isProp":false,"docString":"Insert a new name alignment into the rename extension. ","distance":1.964340819498662682462963857688009738922119140625}],["Translate a sequence into a `LazyList`. Since `LazyList` and `List`\nare isomorphic as non-meta types, this function is necessarily meta. ",{"type":"{Œ± : Type u} ‚Üí Stream'.Seq Œ± ‚Üí LazyList Œ±","name":"Stream'.Seq.toLazyList","isProp":false,"docString":"Translate a sequence into a `LazyList`. Since `LazyList` and `List`\nare isomorphic as non-meta types, this function is necessarily meta. ","distance":1.9660376434112034615964148542843759059906005859375}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"‚àÄ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Convex ‚Ñù s ‚Üí ‚àÄ {x : E}, x ‚àà interior s ‚Üí ‚àÄ (t : ‚Ñù), 1 < t ‚Üí closure s ‚äÜ ‚áë(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9661597665803285384100718147237785160541534423828125}],["Canonical homomorphism from `Int` to a additive group `R` with a `1`.\nThis is just the bare function in order to aid in creating instances of `AddGroupWithOne`. ",{"type":"{R : Type u} ‚Üí [inst : IntCast R] ‚Üí ‚Ñ§ ‚Üí R","name":"Int.cast","isProp":false,"docString":"Canonical homomorphism from `Int` to a additive group `R` with a `1`.\nThis is just the bare function in order to aid in creating instances of `AddGroupWithOne`. ","distance":1.9662576928594914793535508579225279390811920166015625}],["Scaling by a positive unit is a no-op. ",{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (u : RÀ£), 0 < ‚Üëu ‚Üí ‚àÄ (v : Module.Ray R M), u ‚Ä¢ v = v","name":"Module.Ray.units_smul_of_pos","isProp":true,"docString":"Scaling by a positive unit is a no-op. ","distance":1.966873030526584908983522836933843791484832763671875}],["Evaluates the `SetM` monad, yielding a `Set`.\nImplementation note: this is the identity function. ",{"type":"{Œ± : Type u_1} ‚Üí SetM Œ± ‚Üí Set Œ±","name":"SetM.run","isProp":false,"docString":"Evaluates the `SetM` monad, yielding a `Set`.\nImplementation note: this is the identity function. ","distance":1.9674868264744016510547908183070831000804901123046875}],["We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [ùíû : CategoryTheory.EnrichedCategory (Type v) C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [ùíü : CategoryTheory.EnrichedCategory (Type v) D] ‚Üí\n        CategoryTheory.EnrichedFunctor (Type v) C D ‚âÉ CategoryTheory.Functor C D","name":"CategoryTheory.enrichedFunctorTypeEquivFunctor","isProp":false,"docString":"We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n","distance":1.96787334551669612636715100961737334728240966796875}],["Embeds the splitting field into any other field that splits the polynomial. ",{"type":"{K : Type v} ‚Üí\n  {L : Type w} ‚Üí\n    [inst : Field K] ‚Üí\n      [inst_1 : Field L] ‚Üí\n        (f : Polynomial K) ‚Üí\n          [inst_2 : Algebra K L] ‚Üí Polynomial.Splits (algebraMap K L) f ‚Üí Polynomial.SplittingField f ‚Üí‚Çê[K] L","name":"Polynomial.SplittingField.lift","isProp":false,"docString":"Embeds the splitting field into any other field that splits the polynomial. ","distance":1.9679257111264403246053689144900999963283538818359375}],["Generate a random natural number in the interval [lo, hi]. ",{"type":"{gen : Type u} ‚Üí [inst : RandomGen gen] ‚Üí gen ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï √ó gen","name":"randNat","isProp":false,"docString":"Generate a random natural number in the interval [lo, hi]. ","distance":1.967976716883662380297437266563065350055694580078125}]]