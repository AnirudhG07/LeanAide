[["`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ",{"type":"Lean.TrailingParserDescr","name":"«term_+_»","isProp":false,"docString":"`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ","distance":0.67637235016196850523328976123593747615814208984375}],[" For all integers `a` and `b`, the negation of `a` plus the sum of `a` and `b` equals `b`. In mathematical notation, $-a + (a + b) = b$.",{"type":"∀ (a b : ℤ), -a + (a + b) = b","name":"Int.neg_add_cancel_left","isProp":true,"docString":" For all integers `a` and `b`, the negation of `a` plus the sum of `a` and `b` equals `b`. In mathematical notation, $-a + (a + b) = b$.","distance":0.71894126957111870179772949995822273194789886474609375}],["This theorem states that for any two real numbers 'a' and 'b', the Cauchy sequence of the sum of 'a' and 'b' is equal to the sum of the Cauchy sequences of 'a' and 'b'. In other words, the operation of adding two real numbers commutes with the operation of taking their Cauchy sequences.",{"type":"∀ (a b : ℝ), (a + b).cauchy = a.cauchy + b.cauchy","name":"Real.cauchy_add","isProp":true,"docString":"This theorem states that for any two real numbers 'a' and 'b', the Cauchy sequence of the sum of 'a' and 'b' is equal to the sum of the Cauchy sequences of 'a' and 'b'. In other words, the operation of adding two real numbers commutes with the operation of taking their Cauchy sequences.","distance":0.74590467133476412442405489855445921421051025390625}],["`a +ᵥ b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ",{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HVAdd α β γ] → α → β → γ","name":"HVAdd.hVAdd","isProp":false,"docString":"`a +ᵥ b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ","distance":0.690470466570792584803939462290145456790924072265625}],[" For any natural numbers `a` and `b`, `(a + 1) + b = a + (b + 1)`.",{"type":"∀ (a b : ℕ), a.succ + b = a + b.succ","name":"Nat.succ_add_eq_add_succ","isProp":true,"docString":" For any natural numbers `a` and `b`, `(a + 1) + b = a + (b + 1)`.","distance":0.75605821708220222188145953623461537063121795654296875}],["This theorem states that for any two integers `a` and `b`, if you add `a` to the sum of `-a` and `b`, you will get `b`. In more formal mathematical terms, this is expressing the property that adding the additive inverse of a number to that number results in zero, which when added to any other number, leaves that number unchanged. Thus, `a + (-a + b) = b` for all integers `a` and `b`.",{"type":"∀ (a b : ℤ), a + (-a + b) = b","name":"Int.add_neg_cancel_left","isProp":true,"docString":"This theorem states that for any two integers `a` and `b`, if you add `a` to the sum of `-a` and `b`, you will get `b`. In more formal mathematical terms, this is expressing the property that adding the additive inverse of a number to that number results in zero, which when added to any other number, leaves that number unchanged. Thus, `a + (-a + b) = b` for all integers `a` and `b`.","distance":0.7496757287216875287327866317355073988437652587890625}],["`a +ᵥ b` computes the sum of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions. ",{"type":"{G : Type u} → {P : Type v} → [self : VAdd G P] → G → P → P","name":"VAdd.vadd","isProp":false,"docString":"`a +ᵥ b` computes the sum of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions. ","distance":0.699903694757476824150899119558744132518768310546875}],["`a + b` computes the sum of `a` and `b`. See `HAdd`. ",{"type":"{α : Type u} → [self : Add α] → α → α → α","name":"Add.add","isProp":false,"docString":"`a + b` computes the sum of `a` and `b`. See `HAdd`. ","distance":0.718596176033253097870101555599831044673919677734375}],["The sum of `f i` over `i ∈ {a, b}`, `a ≠ b`, is equal to `f a + f b`.",{"type":"∀ {α : Type u_1} {M : Type u_5} [inst : AddCommMonoid M] {f : α → M} {a b : α},\n  a ≠ b → ∑ᶠ (i : α) (_ : i ∈ {a, b}), f i = f a + f b","name":"finsum_mem_pair","isProp":true,"docString":"The sum of `f i` over `i ∈ {a, b}`, `a ≠ b`, is equal to `f a + f b`.","distance":0.72883978408248939473423888557590544223785400390625}],["Two elements additively commute if `a + b = b + a`",{"type":"{S : Type u_3} → [inst : Add S] → S → S → Prop","name":"AddCommute","isProp":false,"docString":"Two elements additively commute if `a + b = b + a`","distance":0.73449723513166598198864676305674947798252105712890625}],["If `a` commutes with both `b` and `c`, then it commutes with their sum.",{"type":"∀ {S : Type u_3} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)","name":"AddCommute.add_right","isProp":true,"docString":"If `a` commutes with both `b` and `c`, then it commutes with their sum.","distance":0.77637638878082626536780708192964084446430206298828125}],["Two elements `a` and `b` are add-regular if and only if both sums `a + b` and\n`b + a` are add-regular.",{"type":"∀ {R : Type u_1} [inst : AddSemigroup R] {a b : R},\n  IsAddRegular (a + b) ∧ IsAddRegular (b + a) ↔ IsAddRegular a ∧ IsAddRegular b","name":"isAddRegular_add_and_add_iff","isProp":true,"docString":"Two elements `a` and `b` are add-regular if and only if both sums `a + b` and\n`b + a` are add-regular.","distance":0.7854379618622162606556003083824180066585540771484375}],["Two elements commute if `a * b = b * a`. ",{"type":"{S : Type u_3} → [inst : Mul S] → S → S → Prop","name":"Commute","isProp":false,"docString":"Two elements commute if `a * b = b * a`. ","distance":0.8162995455507628950186926886090077459812164306640625}],["For `a - -b = a + b`, see `sub_neg_eq_add`.",{"type":"∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α] [inst_2 : AddRightStrictMono α] {a b : α}, a - b < 0 ↔ a < b","name":"sub_neg","isProp":true,"docString":"For `a - -b = a + b`, see `sub_neg_eq_add`.","distance":0.8452954638061285219663432144443504512310028076171875}],["Two elements `a` and `b` commute if `a * b = b * a`.\n",{"type":"∀ {S : Type u_3} [inst : Mul S] (a b : S), Commute a b ↔ a * b = b * a","name":"commute_iff_eq","isProp":true,"docString":"Two elements `a` and `b` commute if `a * b = b * a`.\n","distance":0.87058707021829506711441126753925345838069915771484375}],["If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a + b`\nsemiconjugates `x` to `z`.",{"type":"∀ {S : Type u_1} [inst : AddSemigroup S] {a b x y z : S},\n  AddSemiconjBy a y z → AddSemiconjBy b x y → AddSemiconjBy (a + b) x z","name":"AddSemiconjBy.add_left","isProp":true,"docString":"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a + b`\nsemiconjugates `x` to `z`.","distance":0.87720238082130286283444320361013524234294891357421875}],["`a • b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions. ",{"type":"{M : Type u} → {α : Type v} → [self : SMul M α] → M → α → α","name":"SMul.smul","isProp":false,"docString":"`a • b` computes the product of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions. ","distance":0.88045590909449933381125674713985063135623931884765625}],["The two ways of summing over `(i, j)` in the range `a ≤ i < j < b` are equal. ",{"type":"∀ {M : Type u_3} [inst : AddCommMonoid M] (a b : ℕ) (f : ℕ → ℕ → M),\n  ∑ i ∈ Finset.Ico a b, ∑ j ∈ Finset.Ico (i + 1) b, f i j = ∑ j ∈ Finset.Ico a b, ∑ i ∈ Finset.Ico a j, f i j","name":"Finset.sum_Ico_Ico_comm'","isProp":true,"docString":"The two ways of summing over `(i, j)` in the range `a ≤ i < j < b` are equal. ","distance":0.88398033707122769531139283571974374353885650634765625}],["`a • b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent, but it is intended to be used for left actions. ",{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSMul α β γ] → α → β → γ","name":"HSMul.hSMul","isProp":false,"docString":"`a • b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent, but it is intended to be used for left actions. ","distance":0.88464465476714904124122540451935492455959320068359375}],["The two ways of summing over `(i, j)` in the range `a ≤ i ≤ j < b` are equal. ",{"type":"∀ {M : Type u_3} [inst : AddCommMonoid M] (a b : ℕ) (f : ℕ → ℕ → M),\n  ∑ i ∈ Finset.Ico a b, ∑ j ∈ Finset.Ico i b, f i j = ∑ j ∈ Finset.Ico a b, ∑ i ∈ Finset.Ico a (j + 1), f i j","name":"Finset.sum_Ico_Ico_comm","isProp":true,"docString":"The two ways of summing over `(i, j)` in the range `a ≤ i ≤ j < b` are equal. ","distance":0.88476137415219568982394093836774118244647979736328125}],["The Jacobi symbol of `a` and `b` ",{"type":"Lean.ParserDescr","name":"NumberTheorySymbols.«termJ(_|_)»","isProp":false,"docString":"The Jacobi symbol of `a` and `b` ","distance":0.89009675902864826557703281650901772081851959228515625}],["Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ ",{"type":"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  (PowerSeries.rescale a) (PowerSeries.exp A) * (PowerSeries.rescale b) (PowerSeries.exp A) =\n    (PowerSeries.rescale (a + b)) (PowerSeries.exp A)","name":"PowerSeries.exp_mul_exp_eq_exp_add","isProp":true,"docString":"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ ","distance":0.90348352658477926180324857341474853456020355224609375}],["An element a divides the sum b + a if and only if a divides b. ",{"type":"∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ b + a ↔ a ∣ b","name":"dvd_add_self_right","isProp":true,"docString":"An element a divides the sum b + a if and only if a divides b. ","distance":0.90490169063329617404889404497225768864154815673828125}],["For `a ≤ b`, there is a `c` so `b = a + c`. ",{"type":"∀ {α : Type u} {inst : Add α} {inst_1 : LE α} [self : ExistsAddOfLE α] {a b : α}, a ≤ b → ∃ c, b = a + c","name":"ExistsAddOfLE.exists_add_of_le","isProp":true,"docString":"For `a ≤ b`, there is a `c` so `b = a + c`. ","distance":0.914634645719214489645310095511376857757568359375}]]