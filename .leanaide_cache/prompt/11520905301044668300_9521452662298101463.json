[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.940255066483532520038579605170525610446929931640625}],[" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ùïú`, a normed additive group `E` over `ùïú` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ‚Ü¶ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.",{"type":"‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ùïú E] {I : ModelWithCorners ùïú E H} {G : Type u_4}\n  [inst_4 : Inv G] [inst_5 : Zero G] [inst_6 : TopologicalSpace G] [inst_7 : ChartedSpace H G] [self : SmoothInv‚ÇÄ I G]\n  ‚¶Éx : G‚¶Ñ, x ‚â† 0 ‚Üí SmoothAt I I (fun y => y‚Åª¬π) x","name":"SmoothInv‚ÇÄ.smoothAt_inv‚ÇÄ","isProp":true,"docString":" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ùïú`, a normed additive group `E` over `ùïú` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ‚Ü¶ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.","distance":1.98913737731538642350415102555416524410247802734375}],["This theorem, `hammingDist_pos`, states that for any types `Œπ` and `Œ≤`, where `Œ≤` is a function from `Œπ` to another type and `Œπ` is a fintype, i.e., a finite type, and we have decidable equality for all `i : Œπ` over `Œ≤ i`, then the Hamming distance between two functions `x` and `y` (from `Œπ` to `Œ≤`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 < hammingDist x y ‚Üî x ‚â† y","name":"hammingDist_pos","isProp":true,"docString":"This theorem, `hammingDist_pos`, states that for any types `Œπ` and `Œ≤`, where `Œ≤` is a function from `Œπ` to another type and `Œπ` is a fintype, i.e., a finite type, and we have decidable equality for all `i : Œπ` over `Œ≤ i`, then the Hamming distance between two functions `x` and `y` (from `Œπ` to `Œ≤`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.","distance":1.971485511878688701159489937708713114261627197265625}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {K : Set F},\n  Convex ‚Ñù K ‚Üí ‚àÄ {u v : F}, v ‚àà K ‚Üí (‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9659138556593382940462788610602729022502899169921875}],[" For any nontrivially normed field `ùïú`, normed additive commutative group `E`, normed space `E` over `ùïú`, and topological space `H`, the function `I` from `ùïú` to `E` defined in a Model With Corners `I` of types `ùïú`, `E`, and `H` is uniquely differentiable on its entire range.",{"type":"‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ùïú E H),\n  UniqueDiffOn ùïú (Set.range ‚ÜëI)","name":"ModelWithCorners.unique_diff","isProp":true,"docString":" For any nontrivially normed field `ùïú`, normed additive commutative group `E`, normed space `E` over `ùïú`, and topological space `H`, the function `I` from `ùïú` to `E` defined in a Model With Corners `I` of types `ùïú`, `E`, and `H` is uniquely differentiable on its entire range.","distance":1.989468651609815452729890239425003528594970703125}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":1.9742445073095560292841810223762877285480499267578125}],["The value `BoxIntegral.IntegrationParams.GP = ‚ä•`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ‚ä•`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9691472039420057082992343566729687154293060302734375}],["Default definition of `min`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9701173283299360239340103362337686121463775634765625}],["Corresponds to `dist_pos`. ",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 < hammingDist x y ‚Üî x ‚â† y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.971413909569577072034007869660854339599609375}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData ‚Üí String ‚Üí Lean.Name ‚Üí Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9746226338206225303650853675208054482936859130859375}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module ùïú Œ≤] [inst_3 : OrderedSMul ùïú Œ≤] {f : ùïú ‚Üí Œ≤} {x y z : ùïú},\n  ConcaveOn ùïú (Set.Icc x y) f ‚Üí z ‚àà Set.Icc x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9758722198597309382961384471855126321315765380859375}],["Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : ‚Ñï ‚Üí Type u_2} ‚Üí ((n : ‚Ñï) ‚Üí E n) ‚Üí Set ((n : ‚Ñï) ‚Üí E n) ‚Üí ‚Ñï","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":1.97594368936130937441930655040778219699859619140625}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9766301660876395285271200918941758573055267333984375}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Œ≤ : TypeVec.Arrow Fin2.elim0 Fin2.elim0 ‚Üí Sort u_1} ‚Üí\n  Œ≤ TypeVec.nilFun ‚Üí (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) ‚Üí Œ≤ f","name":"TypeVec.typevecCasesNil‚ÇÇ","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.976895004035764458194535109214484691619873046875}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.976915318293418266648586723022162914276123046875}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {f : E ‚Üí Œ≤} {x y z : E}, ConcaveOn ùïú (segment ùïú x y) f ‚Üí z ‚àà segment ùïú x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9771277269809972576553036560653708875179290771484375}],["Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ",{"type":"{E : ‚Ñï ‚Üí Type u_2} ‚Üí ((n : ‚Ñï) ‚Üí E n) ‚Üí Set ((n : ‚Ñï) ‚Üí E n) ‚Üí ‚Ñï","name":"PiNat.longestPrefix","isProp":false,"docString":"Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ","distance":1.977538408566769323471135066938586533069610595703125}],["The distance between two vertices is the length of the shortest walk between them.\nIf no such walk exists, this uses the junk value of `0`. ",{"type":"{V : Type u_1} ‚Üí SimpleGraph V ‚Üí V ‚Üí V ‚Üí ‚Ñï","name":"SimpleGraph.dist","isProp":false,"docString":"The distance between two vertices is the length of the shortest walk between them.\nIf no such walk exists, this uses the junk value of `0`. ","distance":1.9798010051000767273166047743870876729488372802734375}],["`toReal x` returns `x` if it is real, `0` otherwise. ",{"type":"ENNReal ‚Üí ‚Ñù","name":"ENNReal.toReal","isProp":false,"docString":"`toReal x` returns `x` if it is real, `0` otherwise. ","distance":1.9802167489287338941750249432516284286975860595703125}],["Corresponds to `zero_eq_dist`. ",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 = hammingDist x y ‚Üî x = y","name":"hamming_zero_eq_dist","isProp":true,"docString":"Corresponds to `zero_eq_dist`. ","distance":1.9802637007239385358303707107552327215671539306640625}],["Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ",{"type":"{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ","distance":1.9816960965944472317090685464791022241115570068359375}],["**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module ùïú Œ≤] [inst_3 : OrderedSMul ùïú Œ≤] {f : ùïú ‚Üí Œ≤} {x y z : ùïú},\n  ConvexOn ùïú (Set.Icc x y) f ‚Üí z ‚àà Set.Icc x y ‚Üí f z ‚â§ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_Icc","isProp":true,"docString":"**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.981822627455801733020734900492243468761444091796875}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type ‚Üí Type} ‚Üí [inst : Monad m] ‚Üí [inst : Lean.MonadEnv m] ‚Üí [inst : Lean.MonadError m] ‚Üí Lean.Name ‚Üí m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9819115934268547452035136302583850920200347900390625}],["Default definition of `max`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":1.98254332393885501772956558852456510066986083984375}]]