[["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadEnv m] → [inst : Lean.MonadError m] → Lean.Name → m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9975946106663851065121662031742744147777557373046875}],[" For any topological space `α` and pseudo metric space `β` with defined zero, the constant function `0 : α → β` equals the zero function.",{"type":"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Zero β], ⇑0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":" For any topological space `α` and pseudo metric space `β` with defined zero, the constant function `0 : α → β` equals the zero function.","distance":2.015600654852949702444675494916737079620361328125}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":2.02298739691571238807910049217753112316131591796875}],["The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9978015905180159794696237440803088247776031494140625}],[" For any inner product space `(E, ⟨·, ·⟩)` over commutative scalar type `𝕜`, ⟨0, x⟩ = 0 for all `x ∈ E`.",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x : E), ⟪0, x⟫_𝕜 = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, ⟨·, ·⟩)` over commutative scalar type `𝕜`, ⟨0, x⟩ = 0 for all `x ∈ E`.","distance":2.018090355717576667160528813838027417659759521484375}],["This theorem states that for any types `α` and `β`, where `α` is a topological space and `β` is a pseudo metric space with a defined zero, the function that applies the zero constant function (denoted by `0` here) is equivalent to the zero function. In other words, in this particular setting, applying the zero constant to any input yields the zero value of the space.",{"type":"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Zero β], ⇑0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":"This theorem states that for any types `α` and `β`, where `α` is a topological space and `β` is a pseudo metric space with a defined zero, the function that applies the zero constant function (denoted by `0` here) is equivalent to the zero function. In other words, in this particular setting, applying the zero constant to any input yields the zero value of the space.","distance":2.024815889986177008807999300188384950160980224609375}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {K : Set F},\n  Convex ℝ K → ∀ {u v : F}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9989625948355127516009588362067006528377532958984375}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.99962531706737767223103219293989241123199462890625}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module 𝕜 β] [inst_3 : OrderedSMul 𝕜 β] {f : 𝕜 → β} {x y z : 𝕜},\n  ConcaveOn 𝕜 (Set.Icc x y) f → z ∈ Set.Icc x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9999881116479316656153741860180161893367767333984375}],["The information required to build morphisms for `UniformSpace`. ",{"type":"CategoryTheory.UnbundledHom @UniformContinuous","name":"UniformSpaceCat.instUnbundledHomTypeUniformSpaceUniformContinuous","isProp":true,"docString":"The information required to build morphisms for `UniformSpace`. ","distance":2.003097328493053996822936824173666536808013916015625}],["cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : (v : TypeVec.{u_2} 0) → (v' : TypeVec.{u_3} 0) → TypeVec.Arrow v v' → Sort u_1} →\n  β Fin2.elim0 Fin2.elim0 TypeVec.nilFun →\n    (v : TypeVec.{u_2} 0) → (v' : TypeVec.{u_3} 0) → (fs : TypeVec.Arrow v v') → β v v' fs","name":"TypeVec.typevecCasesNil₃","isProp":false,"docString":"cases distinction for an arrow in the category of 0-length type vectors ","distance":2.00381591008020709665515823871828615665435791015625}],["Help the typechecker by converting a path in a topological space to an arrow in the\nfundamental groupoid of that space. ",{"type":"{X : TopCat} → {x₀ x₁ : ↑X} → Path.Homotopic.Quotient x₀ x₁ → ({ as := x₀ } ⟶ { as := x₁ })","name":"FundamentalGroupoid.fromPath","isProp":false,"docString":"Help the typechecker by converting a path in a topological space to an arrow in the\nfundamental groupoid of that space. ","distance":2.0043967047484283483527178759686648845672607421875}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConcaveOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.005079477348852723395111752324737608432769775390625}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : TypeVec.Arrow Fin2.elim0 Fin2.elim0 → Sort u_1} →\n  β TypeVec.nilFun → (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) → β f","name":"TypeVec.typevecCasesNil₂","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":2.0075844815414551902676976169459521770477294921875}],["For maps between vector spaces, `MDifferentiable` and `Differentiable` coincide ",{"type":"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {E' : Type u_3} [inst_3 : NormedAddCommGroup E'] [inst_4 : NormedSpace 𝕜 E'] {f : E → E'},\n  MDifferentiable (modelWithCornersSelf 𝕜 E) (modelWithCornersSelf 𝕜 E') f ↔ Differentiable 𝕜 f","name":"mdifferentiable_iff_differentiable","isProp":true,"docString":"For maps between vector spaces, `MDifferentiable` and `Differentiable` coincide ","distance":2.00918970862381573994071004563011229038238525390625}],["Name to use for the declaration for a type that is `Equiv` to the given type. ",{"type":"Mathlib.ProxyType.ProxyEquivConfig → Lean.Name","name":"Mathlib.ProxyType.ProxyEquivConfig.proxyName","isProp":false,"docString":"Name to use for the declaration for a type that is `Equiv` to the given type. ","distance":2.009616043623294157072223242721520364284515380859375}],["Default definition of `min`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":2.011049816578150739587727002799510955810546875}],["Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : ℕ → Type u_2} → ((n : ℕ) → E n) → Set ((n : ℕ) → E n) → ℕ","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":2.01139690894915457164415784063749015331268310546875}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Zero M₁] →\n      [inst_1 : Neg M₁] →\n        [inst_2 : NegZeroClass M₂] →\n          (f : M₁ → M₂) → Function.Injective f → f 0 = 0 → (∀ (x : M₁), f (-x) = -f x) → NegZeroClass M₁","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":2.01192649060798345317380153574049472808837890625}],["For maps between vector spaces, `MDifferentiableOn` and `DifferentiableOn` coincide ",{"type":"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {E' : Type u_3} [inst_3 : NormedAddCommGroup E'] [inst_4 : NormedSpace 𝕜 E'] {f : E → E'}\n  {s : Set E}, MDifferentiableOn (modelWithCornersSelf 𝕜 E) (modelWithCornersSelf 𝕜 E') f s ↔ DifferentiableOn 𝕜 f s","name":"mdifferentiableOn_iff_differentiableOn","isProp":true,"docString":"For maps between vector spaces, `MDifferentiableOn` and `DifferentiableOn` coincide ","distance":2.01261319460113785595467561506666243076324462890625}],["Tests whether `declName` has the `@[simp]` attribute in `env`. ",{"type":"Lean.Environment → Lean.Name → Bool","name":"hasSimpAttribute","isProp":false,"docString":"Tests whether `declName` has the `@[simp]` attribute in `env`. ","distance":2.01261504117030920468778276699595153331756591796875}],["`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`α →ₛ ℝ≥0∞`. But since `ℝ≥0∞` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ",{"type":"∀ {α : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  {f : MeasureTheory.SimpleFunc α E} {g : E → ENNReal},\n  MeasureTheory.Integrable ↑f →\n    g 0 = 0 →\n      (∀ (b : E), g b ≠ ⊤) →\n        MeasureTheory.SimpleFunc.integral μ (MeasureTheory.SimpleFunc.map (ENNReal.toReal ∘ g) f) =\n          ENNReal.toReal (∫⁻ (a : α), g (↑f a) ∂μ)","name":"MeasureTheory.SimpleFunc.integral_eq_lintegral'","isProp":true,"docString":"`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`α →ₛ ℝ≥0∞`. But since `ℝ≥0∞` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ","distance":2.01310011537906774492512340657413005828857421875}],["Parse a rule for `initialize_simps_projections`. It is `<name>→<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.",{"type":"Lean.Syntax → Lean.Elab.Command.CommandElabM Simps.ProjectionRule","name":"Simps.elabSimpsRule","isProp":false,"docString":"Parse a rule for `initialize_simps_projections`. It is `<name>→<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.","distance":2.0132270457549754638648664695210754871368408203125}],["Builds a `Primcodable` instance from an equivalence to a `Primcodable` type. ",{"type":"(α : Type u_1) → {β : Type u_2} → [inst : Primcodable α] → β ≃ α → Primcodable β","name":"Primcodable.ofEquiv","isProp":false,"docString":"Builds a `Primcodable` instance from an equivalence to a `Primcodable` type. ","distance":2.013752562313006588823327547288499772548675537109375}]]