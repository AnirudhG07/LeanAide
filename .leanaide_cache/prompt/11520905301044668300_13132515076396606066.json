[["`q` is defined as the minimum factor of `mersenne p`, bundled as an `ℕ+`. ",{"type":"ℕ → ℕ+","name":"LucasLehmer.q","isProp":false,"docString":"`q` is defined as the minimum factor of `mersenne p`, bundled as an `ℕ+`. ","distance":0.889465654708104569436954989214427769184112548828125}],[" For every non-negative real number `q`, we have `q ≥ 0`.",{"type":"∀ {q : NNReal}, (0 ≤ ↑q) = True","name":"Mathlib.Data.Real.NNReal._auxLemma.29","isProp":true,"docString":" For every non-negative real number `q`, we have `q ≥ 0`.","distance":0.82967490366357832254351478695753030478954315185546875}],["A positive natural number `n` can be expressed as the sum of two squares if and only if for every prime number `q` in its prime factorization, where `q` modulo 4 equals 3, the `q`-adic valuation of `n` (the highest power of `q` that divides `n`) is an even number. Note that the assumption `n > 0` is not required since for `n = 0`, both conditions are automatically satisfied; the right-hand side is true because by definition `padicValNat q 0 = 0`.",{"type":"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∀ {q : ℕ}, q.Prime → q % 4 = 3 → Even (padicValNat q n)","name":"Nat.eq_sq_add_sq_iff","isProp":true,"docString":"A positive natural number `n` can be expressed as the sum of two squares if and only if for every prime number `q` in its prime factorization, where `q` modulo 4 equals 3, the `q`-adic valuation of `n` (the highest power of `q` that divides `n`) is an even number. Note that the assumption `n > 0` is not required since for `n = 0`, both conditions are automatically satisfied; the right-hand side is true because by definition `padicValNat q 0 = 0`.","distance":0.87724619056132391303748363498016260564327239990234375}],["`qp = q - 1` ",{"type":"PNat.XgcdType → ℕ","name":"PNat.XgcdType.qp","isProp":false,"docString":"`qp = q - 1` ","distance":0.900612169005164719948197671328671276569366455078125}],[" For any rational number `q` and natural number `n`, the numerator of the fractional part of the `(n+1)`-th element in the generalized continued fraction of `q` is strictly less than the numerator of the fractional part of the `n`-th element.",{"type":"∀ {q : ℚ} {n : ℕ} {ifp_n ifp_succ_n : GeneralizedContinuedFraction.IntFractPair ℚ},\n  GeneralizedContinuedFraction.IntFractPair.stream q n = some ifp_n →\n    GeneralizedContinuedFraction.IntFractPair.stream q (n + 1) = some ifp_succ_n → ifp_succ_n.fr.num < ifp_n.fr.num","name":"GeneralizedContinuedFraction.IntFractPair.stream_succ_nth_fr_num_lt_nth_fr_num_rat","isProp":true,"docString":" For any rational number `q` and natural number `n`, the numerator of the fractional part of the `(n+1)`-th element in the generalized continued fraction of `q` is strictly less than the numerator of the fractional part of the `n`-th element.","distance":0.87742694248083086261402741001802496612071990966796875}],["This theorem asserts that for any rational number `q`, if `q` is non-negative (i.e., `q` is greater than or equal to zero), then converting `q` to a non-negative rational number using the function `Rat.toNNRat` and then converting it back to a regular rational number yields the original value `q`. In mathematical terms, it states that for all `q` in the set of rational numbers, `ℚ`, such that `0 ≤ q`, the function `Rat.toNNRat` is effectively an identity operation.",{"type":"∀ (q : ℚ), 0 ≤ q → ↑q.toNNRat = q","name":"Rat.coe_toNNRat","isProp":true,"docString":"This theorem asserts that for any rational number `q`, if `q` is non-negative (i.e., `q` is greater than or equal to zero), then converting `q` to a non-negative rational number using the function `Rat.toNNRat` and then converting it back to a regular rational number yields the original value `q`. In mathematical terms, it states that for all `q` in the set of rational numbers, `ℚ`, such that `0 ≤ q`, the function `Rat.toNNRat` is effectively an identity operation.","distance":0.89721081997763485471608646548702381551265716552734375}],["A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) ",{"type":"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∀ {q : ℕ}, Nat.Prime q → q % 4 = 3 → Even (padicValNat q n)","name":"Nat.eq_sq_add_sq_iff","isProp":true,"docString":"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) ","distance":0.9048020760028270270680650355643592774868011474609375}],["Note that `0 : 0 →qᵢ Q` alone would not be well-typed as the RHS. ",{"type":"∀ {ι : Type u_1} {R : Type u_2} {P : Type u_7} {Mᵢ : ι → Type u_8} [inst : CommSemiring R]\n  [inst_1 : (i : ι) → AddCommMonoid (Mᵢ i)] [inst_2 : AddCommMonoid P] [inst_3 : (i : ι) → Module R (Mᵢ i)]\n  [inst_4 : Module R P] [inst_5 : Fintype ι] [inst_6 : DecidableEq ι] {i j : ι} (h : i ≠ j)\n  (Q : QuadraticMap R (Mᵢ i) P),\n  (QuadraticMap.Isometry.proj i Q).comp (QuadraticMap.Isometry.single (Pi.single i Q) j) =\n    QuadraticMap.Isometry.comp 0 (QuadraticMap.Isometry.ofEq ⋯)","name":"QuadraticMap.Isometry.proj_comp_single_of_ne","isProp":true,"docString":"Note that `0 : 0 →qᵢ Q` alone would not be well-typed as the RHS. ","distance":0.9150374968759493743419852762599475681781768798828125}],["The `L`-function of the trivial character mod `N`. ",{"type":"(N : ℕ) → [inst : NeZero N] → ℂ → ℂ","name":"DirichletCharacter.LFunctionTrivChar","isProp":false,"docString":"The `L`-function of the trivial character mod `N`. ","distance":0.92255257701624626687220143139711581170558929443359375}],["There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ","distance":0.92409362217227719593637402795138768851757049560546875}],["We can express `qrSign m n` as a power of `-1` when `m` and `n` are odd. ",{"type":"∀ {m n : ℕ}, Odd m → Odd n → qrSign m n = (-1) ^ (m / 2 * (n / 2))","name":"qrSign.neg_one_pow","isProp":true,"docString":"We can express `qrSign m n` as a power of `-1` when `m` and `n` are odd. ","distance":0.93876514033494407041047224993235431611537933349609375}],["If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\n`n` is not divisible by a prime `q` such that `q % 4 = 3`. ",{"type":"∀ {n : ℕ}, Squarefree n → (IsSquare (-1) ↔ ∀ {q : ℕ}, Nat.Prime q → q ∣ n → q % 4 ≠ 3)","name":"ZMod.isSquare_neg_one_iff","isProp":true,"docString":"If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\n`n` is not divisible by a prime `q` such that `q % 4 = 3`. ","distance":0.94156285782252557847726848194724880158901214599609375}],["We can approximate `a / b : L` with `q / r`, where `r` has finitely many options for `L`. ",{"type":"∀ {R : Type u_1} {S : Type u_2} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] {abv : AbsoluteValue R ℤ} {ι : Type u_5} [inst_4 : DecidableEq ι] [inst_5 : Fintype ι]\n  (bS : Basis ι R S) (adm : abv.IsAdmissible) [inst_6 : Infinite R] [inst_7 : DecidableEq R]\n  [inst_8 : Algebra.IsAlgebraic R S] (a : S) {b : S},\n  b ≠ 0 → ∃ q, ∃ r ∈ ClassGroup.finsetApprox bS adm, abv ((Algebra.norm R) (r • a - q * b)) < abv ((Algebra.norm R) b)","name":"ClassGroup.exists_mem_finset_approx'","isProp":true,"docString":"We can approximate `a / b : L` with `q / r`, where `r` has finitely many options for `L`. ","distance":0.95041850339390820945340010439394973218441009521484375}],["The L function of the trivial Dirichlet character mod `N` is obtained from the Riemann\nzeta function by multiplying with `∏ p ∈ N.primeFactors, (1 - (p : ℂ) ^ (-s))`. ",{"type":"∀ {N : ℕ} [inst : NeZero N] {s : ℂ},\n  s ≠ 1 → DirichletCharacter.LFunctionTrivChar N s = (∏ p ∈ N.primeFactors, (1 - ↑p ^ (-s))) * riemannZeta s","name":"DirichletCharacter.LFunctionTrivChar_eq_mul_riemannZeta","isProp":true,"docString":"The L function of the trivial Dirichlet character mod `N` is obtained from the Riemann\nzeta function by multiplying with `∏ p ∈ N.primeFactors, (1 - (p : ℂ) ^ (-s))`. ","distance":0.95240508379097821300973691904800944030284881591796875}],["The sum of `x ^ i` as `x` ranges over the units of a finite field of cardinality `q`\nis equal to `0` unless `(q - 1) ∣ i`, in which case the sum is `q - 1`. ",{"type":"∀ (K : Type u_1) [inst : Field K] [inst_1 : Fintype K] [inst_2 : DecidableEq K] (i : ℕ),\n  ∑ x : Kˣ, ↑x ^ i = if Fintype.card K - 1 ∣ i then -1 else 0","name":"FiniteField.sum_pow_units","isProp":true,"docString":"The sum of `x ^ i` as `x` ranges over the units of a finite field of cardinality `q`\nis equal to `0` unless `(q - 1) ∣ i`, in which case the sum is `q - 1`. ","distance":0.9534614290804508396348637688788585364818572998046875}],["Reinterpret a rational number `q` as a non-negative rational number. Returns `0` if `q ≤ 0`. ",{"type":"ℚ → ℚ≥0","name":"Rat.toNNRat","isProp":false,"docString":"Reinterpret a rational number `q` as a non-negative rational number. Returns `0` if `q ≤ 0`. ","distance":0.95538246492953982080820196642889641225337982177734375}],["The sum of `x ^ i` as `x` ranges over a finite field of cardinality `q`\nis equal to `0` if `i < q - 1`. ",{"type":"∀ (K : Type u_1) [inst : Field K] [inst_1 : Fintype K], ∀ i < Fintype.card K - 1, ∑ x : K, x ^ i = 0","name":"FiniteField.sum_pow_lt_card_sub_one","isProp":true,"docString":"The sum of `x ^ i` as `x` ranges over a finite field of cardinality `q`\nis equal to `0` if `i < q - 1`. ","distance":0.95627708106073894267495916210464201867580413818359375}],["If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\n`n` has no divisor `q` that is `≡ 3 mod 4`. ",{"type":"∀ {n : ℕ}, Squarefree n → (IsSquare (-1) ↔ ∀ {q : ℕ}, q ∣ n → q % 4 ≠ 3)","name":"ZMod.isSquare_neg_one_iff'","isProp":true,"docString":"If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\n`n` has no divisor `q` that is `≡ 3 mod 4`. ","distance":0.9604468955070697422371495122206397354602813720703125}],["**Hermite Theorem**. Let `N` be an integer. There are only finitely many number fields\n(in some fixed extension of `ℚ`) of discriminant bounded by `N`. ",{"type":"∀ (A : Type u_2) [inst : Field A] [inst_1 : CharZero A] (N : ℕ), {K | |NumberField.discr ↥↑K| ≤ ↑N}.Finite","name":"NumberField.finite_of_discr_bdd","isProp":true,"docString":"**Hermite Theorem**. Let `N` be an integer. There are only finitely many number fields\n(in some fixed extension of `ℚ`) of discriminant bounded by `N`. ","distance":0.968261418549192232063660412677563726902008056640625}],["If the division equation `d.toNat * q.toNat + r.toNat = n.toNat` holds,\nthen `n.umod d = r`. ",{"type":"∀ {w : ℕ} {d n q r : BitVec w}, r < d → d.toNat * q.toNat + r.toNat = n.toNat → n % d = r","name":"BitVec.umod_eq_of_mul_add_toNat","isProp":true,"docString":"If the division equation `d.toNat * q.toNat + r.toNat = n.toNat` holds,\nthen `n.umod d = r`. ","distance":0.9687345877670043847729175467975437641143798828125}],["Version of `sMod` that is `ℕ`-valued. One should have `q = 2 ^ p - 1`.\nThis can be reduced by the kernel. ",{"type":"ℕ → ℕ → ℕ","name":"LucasLehmer.norm_num_ext.sModNat","isProp":false,"docString":"Version of `sMod` that is `ℕ`-valued. One should have `q = 2 ^ p - 1`.\nThis can be reduced by the kernel. ","distance":0.97099214910133879730125272544682957231998443603515625}],["If the division equation `d.toNat * q.toNat + r.toNat = n.toNat` holds,\nthen `n.udiv d = q`. ",{"type":"∀ {w : ℕ} {d n q r : BitVec w}, 0 < d → r < d → d.toNat * q.toNat + r.toNat = n.toNat → n / d = q","name":"BitVec.udiv_eq_of_mul_add_toNat","isProp":true,"docString":"If the division equation `d.toNat * q.toNat + r.toNat = n.toNat` holds,\nthen `n.udiv d = q`. ","distance":0.97471361904837294787284918129444122314453125}],["For `p ≠ 1`, the `p`-adic valuation of a natural `n ≠ 0` is the largest natural number `k` such\nthat `p^k` divides `n`. If `n = 0` or `p = 1`, then `padicValNat p q` defaults to `0`. ",{"type":"ℕ → ℕ → ℕ","name":"padicValNat","isProp":false,"docString":"For `p ≠ 1`, the `p`-adic valuation of a natural `n ≠ 0` is the largest natural number `k` such\nthat `p^k` divides `n`. If `n = 0` or `p = 1`, then `padicValNat p q` defaults to `0`. ","distance":0.97530424116762126640622909690137021243572235107421875}],["If the `p`-adic norm of `q` is 0, then `q` is `0`. ",{"type":"∀ {p : ℕ} [hp : Fact (Nat.Prime p)] {q : ℚ}, padicNorm p q = 0 → q = 0","name":"padicNorm.zero_of_padicNorm_eq_zero","isProp":true,"docString":"If the `p`-adic norm of `q` is 0, then `q` is `0`. ","distance":0.97536600008947538231751650528167374432086944580078125}]]