[["The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{𝕜 : Type u_8} →\n  {𝕜' : Type u_9} →\n    {E : Type u_10} →\n      [inst : NormedField 𝕜'] →\n        [inst_1 : SeminormedAddCommGroup E] → [I : NormedSpace 𝕜' E] → NormedSpace 𝕜' (RestrictScalars 𝕜 𝕜' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.9408458930262513231213006292819045484066009521484375}],[" For any type `α` with a linear order and any `b` in `α`, the `Set.projIic` function maps elements in the left-infinite right-closed interval `(-∞, b]` to themselves.",{"type":"∀ {α : Type u_1} [inst : LinearOrder α] {b : α} (x : ↑(Set.Iic b)), Set.projIic b ↑x = x","name":"Set.projIic_coe","isProp":true,"docString":" For any type `α` with a linear order and any `b` in `α`, the `Set.projIic` function maps elements in the left-infinite right-closed interval `(-∞, b]` to themselves.","distance":1.968926532643166638081311248242855072021484375}],["This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.denom 0 = 1","name":"RatFunc.denom_zero","isProp":true,"docString":"This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.","distance":1.9445056939339055990245697103091515600681304931640625}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name → Simps.ParsedProjectionData → List Lean.Level → Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.949664243238036664962464783457107841968536376953125}],[" For any type vector `α` of length `n+1`, appending the last element of `α` to the subvector obtained by dropping the last element results in the original vector `α`.",{"type":"∀ {n : ℕ} (α : TypeVec.{u_1} (n + 1)), α.drop.append1 α.last = α","name":"TypeVec.append1_drop_last","isProp":true,"docString":" For any type vector `α` of length `n+1`, appending the last element of `α` to the subvector obtained by dropping the last element results in the original vector `α`.","distance":1.9710562240480651308160986445727758109569549560546875}],["This theorem states that for all natural numbers `p`, the `p`-adic norm of `1` is `1`. This means that regardless of the prime number `p` you choose, when you calculate the `p`-adic norm for the rational number `1`, the result will always be `1`.",{"type":"∀ {p : ℕ}, padicNorm p 1 = 1","name":"padicNorm.one","isProp":true,"docString":"This theorem states that for all natural numbers `p`, the `p`-adic norm of `1` is `1`. This means that regardless of the prime number `p` you choose, when you calculate the `p`-adic norm for the rational number `1`, the result will always be `1`.","distance":1.960107429523306077356892274110578000545501708984375}],["Given two ordinals `α < β`, then `principalSegOut α β` is the principal segment embedding\nof `α` to `β`, as map from a model type for `α` to a model type for `β`. ",{"type":"{α β : Ordinal.{u_3}} → α < β → (fun x x_1 => x < x_1) ≺i fun x x_1 => x < x_1","name":"Ordinal.principalSegOut","isProp":false,"docString":"Given two ordinals `α < β`, then `principalSegOut α β` is the principal segment embedding\nof `α` to `β`, as map from a model type for `α` to a model type for `β`. ","distance":1.950532738296401280564396074623800814151763916015625}],["Given two ordinals `α ≤ β`, then `initialSegOut α β` is the initial segment embedding\nof `α` to `β`, as map from a model type for `α` to a model type for `β`. ",{"type":"{α β : Ordinal.{u_3}} → α ≤ β → (fun x x_1 => x < x_1) ≼i fun x x_1 => x < x_1","name":"Ordinal.initialSegOut","isProp":false,"docString":"Given two ordinals `α ≤ β`, then `initialSegOut α β` is the initial segment embedding\nof `α` to `β`, as map from a model type for `α` to a model type for `β`. ","distance":1.9541532980161504529093008386553265154361724853515625}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{α : Type v} → Quotient.out (Cardinal.mk α) ≃ α","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":1.9549543937273530236353735745069570839405059814453125}],["Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n",{"type":"Lean.ParserDescr","name":"Mathlib.CountHeartbeats.commandCount_heartbeatsIn__","isProp":false,"docString":"Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n","distance":1.9551702276332552088433658354915678501129150390625}],["A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"ℕ → Type","name":"Affine.Simplex.PointsWithCircumcenterIndex.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.9556520945372657394045745604671537876129150390625}],["A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n",{"type":"(A : Type u_2) → [inst : CommRing A] → [inst : IsDomain A] → Prop","name":"IsDedekindDomainInv","isProp":false,"docString":"A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n","distance":1.956253173014495860826400530640967190265655517578125}],["Embedding of a subtype into the ambient type as an `OrderEmbedding`. ",{"type":"{α : Type u_2} → [inst : Preorder α] → (p : α → Prop) → Subtype p ↪o α","name":"OrderEmbedding.subtype","isProp":false,"docString":"Embedding of a subtype into the ambient type as an `OrderEmbedding`. ","distance":1.956567218382742279203512225649319589138031005859375}],["The `p`-adic norm of `p` is `p⁻¹` if `p > 1`.\n\nSee also `padicNorm.padicNorm_p_of_prime` for a version assuming `p` is prime. ",{"type":"∀ {p : ℕ}, 1 < p → padicNorm p ↑p = (↑p)⁻¹","name":"padicNorm.padicNorm_p","isProp":true,"docString":"The `p`-adic norm of `p` is `p⁻¹` if `p > 1`.\n\nSee also `padicNorm.padicNorm_p_of_prime` for a version assuming `p` is prime. ","distance":1.9575214379394763053454653345397673547267913818359375}],["Norm constructed from an `InnerProductSpace.Core` structure, defined to be the square root\nof the scalar product. ",{"type":"{𝕜 : Type u_1} →\n  {F : Type u_3} →\n    [inst : IsROrC 𝕜] → [inst_1 : AddCommGroup F] → [inst_2 : Module 𝕜 F] → [c : InnerProductSpace.Core 𝕜 F] → Norm F","name":"InnerProductSpace.Core.toNorm","isProp":false,"docString":"Norm constructed from an `InnerProductSpace.Core` structure, defined to be the square root\nof the scalar product. ","distance":1.95779866623440579331827393616549670696258544921875}],["Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n",{"type":"{ω : Type u_1} →\n  {α : Type} →\n    (prio : α → Thunk ω) →\n      (ε : α → Type) →\n        [inst : LinearOrder ω] →\n          [inst_1 : (a : α) → Estimator (prio a) (ε a)] →\n            [I : ∀ (a : α), WellFoundedGT ↑(Set.range (EstimatorData.bound (prio a)))] →\n              [inst : Ord ω] →\n                [inst : Ord α] →\n                  {m : Type → Type} →\n                    [inst : Monad m] →\n                      [inst : Alternative m] →\n                        [inst : (a : α) → Bot (ε a)] → Option ℕ → (α → MLList m α) → α → MLList m α","name":"impl","isProp":false,"docString":"Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n","distance":1.9580545995571714268379537315922789275646209716796875}],["A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"Type u_1 → Type u_2 → Type (max u_1 u_2)","name":"Symbol.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.9587537586859358196278435571002773940563201904296875}],["`LinearMap.bound_of_ball_bound` is a version of this over arbitrary nontrivially normed fields.\nIt produces a less precise bound so we keep both versions. ",{"type":"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] {r : ℝ},\n  0 < r → ∀ (c : ℝ) (f : E →ₗ[𝕜] 𝕜), (∀ z ∈ Metric.closedBall 0 r, ‖f z‖ ≤ c) → ∀ (z : E), ‖f z‖ ≤ c / r * ‖z‖","name":"LinearMap.bound_of_ball_bound'","isProp":true,"docString":"`LinearMap.bound_of_ball_bound` is a version of this over arbitrary nontrivially normed fields.\nIt produces a less precise bound so we keep both versions. ","distance":1.9598545273331833271868163137696683406829833984375}],["Any type is (classically) either a `Fintype`, or `Infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintypeOrInfinite α`.\n",{"type":"(α : Type u_4) → Fintype α ⊕' Infinite α","name":"fintypeOrInfinite","isProp":false,"docString":"Any type is (classically) either a `Fintype`, or `Infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintypeOrInfinite α`.\n","distance":1.96040481544140465786085769650526344776153564453125}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ≤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"ℤ → ℤ","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ≤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":1.96088857611396694125005524256266653537750244140625}],["`RatFunc.denom` is the denominator of a rational function,\nnormalized such that it is monic. ",{"type":"{K : Type u} → [inst : Field K] → RatFunc K → Polynomial K","name":"RatFunc.denom","isProp":false,"docString":"`RatFunc.denom` is the denominator of a rational function,\nnormalized such that it is monic. ","distance":1.9610480417950773013302523395395837724208831787109375}],["The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",{"type":"ℕ → ℕ","name":"Nat.pred","isProp":false,"docString":"The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n","distance":1.9616411746826212247896137341740541160106658935546875}],["Restrict the codomain of an initial segment ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} → {s : β → β → Prop} → (p : Set β) → (f : r ≼i s) → (∀ (a : α), f a ∈ p) → r ≼i Subrel s p","name":"InitialSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of an initial segment ","distance":1.9617182237560595314818101542186923325061798095703125}],["The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ",{"type":"{ι : Type u_1} → [inst : Fintype ι] → BoxIntegral.Box ι → NNReal","name":"BoxIntegral.Box.distortion","isProp":false,"docString":"The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ","distance":1.961780085027532205543820964521728456020355224609375}]]