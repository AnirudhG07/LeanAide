[["There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ","distance":0.89691979058365423060905641250428743660449981689453125}],[" The number of positive multiples of `n` less than or equal to `N` is equal to the integer part of `N` divided by `n`.",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":" The number of positive multiples of `n` less than or equal to `N` is equal to the integer part of `N` divided by `n`.","distance":0.95712507685027137238620298376190476119518280029296875}],["This theorem states that for any given non-negative integers `N` and `n`, the number of positive multiples of `n` that are less than or equal to `N` is precisely `⌊N/n⌋`. This is calculated by filtering out all the elements in the set of natural numbers from `0` to `N` (inclusive) that are divisible by `n` and not equal to `0`, and then counting the number of such elements. The theorem also suggests referring to a similar theorem, `Nat.card_multiples`, which might be a version shifted by one.",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"This theorem states that for any given non-negative integers `N` and `n`, the number of positive multiples of `n` that are less than or equal to `N` is precisely `⌊N/n⌋`. This is calculated by filtering out all the elements in the set of natural numbers from `0` to `N` (inclusive) that are divisible by `n` and not equal to `0`, and then counting the number of such elements. The theorem also suggests referring to a similar theorem, `Nat.card_multiples`, which might be a version shifted by one.","distance":0.95152104422113270576488730512210167944431304931640625}],["The `L`-function of the trivial character mod `N`. ",{"type":"(N : ℕ) → [inst : NeZero N] → ℂ → ℂ","name":"DirichletCharacter.LFunctionTrivChar","isProp":false,"docString":"The `L`-function of the trivial character mod `N`. ","distance":0.92166001097259542262918330379761755466461181640625}],[" For any natural number `n`, the integer obtained by lifting `n` is non-negative, i.e., `↑n ≥ 0`.",{"type":"∀ (n : ℕ), 0 ≤ ↑n","name":"Int.ofNat_zero_le","isProp":true,"docString":" For any natural number `n`, the integer obtained by lifting `n` is non-negative, i.e., `↑n ≥ 0`.","distance":0.9575082737131730414859021038864739239215850830078125}],["This theorem states that for every natural number `n`, `n` is either equal to zero or greater than zero. In other words, it asserts that any natural number is either zero or a positive integer. This is a fundamental property of natural numbers in the standard mathematical system.",{"type":"∀ (n : ℕ), n = 0 ∨ n > 0","name":"Nat.eq_zero_or_pos","isProp":true,"docString":"This theorem states that for every natural number `n`, `n` is either equal to zero or greater than zero. In other words, it asserts that any natural number is either zero or a positive integer. This is a fundamental property of natural numbers in the standard mathematical system.","distance":0.988439140759469037078588371514342725276947021484375}],["**Hermite Theorem**. Let `N` be an integer. There are only finitely many number fields\n(in some fixed extension of `ℚ`) of discriminant bounded by `N`. ",{"type":"∀ (A : Type u_2) [inst : Field A] [inst_1 : CharZero A] (N : ℕ), {K | |NumberField.discr ↥↑K| ≤ ↑N}.Finite","name":"NumberField.finite_of_discr_bdd","isProp":true,"docString":"**Hermite Theorem**. Let `N` be an integer. There are only finitely many number fields\n(in some fixed extension of `ℚ`) of discriminant bounded by `N`. ","distance":0.9311978589230047731462036608718335628509521484375}],["The non-zero non-`N`-smooth numbers are `≥ N`. ",{"type":"∀ (N : ℕ), N.smoothNumbersᶜ \\ {0} ⊆ {n | N ≤ n}","name":"Nat.smoothNumbers_compl","isProp":true,"docString":"The non-zero non-`N`-smooth numbers are `≥ N`. ","distance":0.94867877874129913351453069481067359447479248046875}],["If the left-most part is not `{0}`, then the part containing `0` has at least two elements:\neither because it's the left-most part, and then it's not just `0` by assumption, or because it's\nnot the left-most part and then, by increasingness of maximal elements in parts, it contains\na positive element. ",{"type":"∀ {n : ℕ} (c : OrderedFinpartition (n + 1)), Set.range (c.emb 0) ≠ {0} → 1 < c.partSize (c.index 0)","name":"OrderedFinpartition.one_lt_partSize_index_zero","isProp":true,"docString":"If the left-most part is not `{0}`, then the part containing `0` has at least two elements:\neither because it's the left-most part, and then it's not just `0` by assumption, or because it's\nnot the left-most part and then, by increasingness of maximal elements in parts, it contains\na positive element. ","distance":0.97753841782014305739068049661000259220600128173828125}],["The strict series `0 < … < n` in `ℕ`. ",{"type":"ℕ → LTSeries ℕ","name":"LTSeries.range","isProp":false,"docString":"The strict series `0 < … < n` in `ℕ`. ","distance":0.99999414054489477177156686593662016093730926513671875}],["The type of integer numbers is equivalent to `ℕ ⊕ ℕ`. ",{"type":"ℤ ≃ ℕ ⊕ ℕ","name":"Equiv.intEquivNatSumNat","isProp":false,"docString":"The type of integer numbers is equivalent to `ℕ ⊕ ℕ`. ","distance":1.0087485708780992155197964166291058063507080078125}],["The integers modulo `n : ℕ`. ",{"type":"ℕ → Type","name":"ZMod","isProp":false,"docString":"The integers modulo `n : ℕ`. ","distance":1.0117229064294956941694181296043097972869873046875}],["`N` is closed under additive conjugation ",{"type":"∀ {A : Type u_2} [inst : AddGroup A] {H : AddSubgroup A}, H.Normal → ∀ n ∈ H, ∀ (g : A), g + n + -g ∈ H","name":"AddSubgroup.Normal.conj_mem","isProp":true,"docString":"`N` is closed under additive conjugation ","distance":1.0192568102822077147351365056238137185573577880859375}],["The \"nondegenerate simplices\" `N n` for all `n : ℕ`. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X : CategoryTheory.SimplicialObject C} → SimplicialObject.Splitting X → ℕ → C","name":"SimplicialObject.Splitting.N","isProp":false,"docString":"The \"nondegenerate simplices\" `N n` for all `n : ℕ`. ","distance":1.02546802758661215193569660186767578125}],["The positive non-`k`-smooth (so \"`k`-rough\") numbers up to and including `N` as a `Finset` ",{"type":"ℕ → ℕ → Finset ℕ","name":"Nat.roughNumbersUpTo","isProp":false,"docString":"The positive non-`k`-smooth (so \"`k`-rough\") numbers up to and including `N` as a `Finset` ","distance":1.0257203867575623856822630841634236276149749755859375}],["`N` is closed under conjugation ",{"type":"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, H.Normal → ∀ n ∈ H, ∀ (g : G), g * n * g⁻¹ ∈ H","name":"Subgroup.Normal.conj_mem","isProp":true,"docString":"`N` is closed under conjugation ","distance":1.029385374031851707599116707569919526576995849609375}],["An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is\nrequired to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove\nresults where you want to change each term in a polynomial to something else depending on the\n`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. ",{"type":"∀ {R : Type u_1} [inst : Semiring R] (P : Polynomial R → Prop) (N : ℕ),\n  P 0 →\n    (∀ (n : ℕ) (r : R), r ≠ 0 → n ≤ N → P (Polynomial.C r * Polynomial.X ^ n)) →\n      (∀ (f g : Polynomial R), f.natDegree < g.natDegree → g.natDegree ≤ N → P f → P g → P (f + g)) →\n        ∀ (f : Polynomial R), f.natDegree ≤ N → P f","name":"Polynomial.induction_with_natDegree_le","isProp":true,"docString":"An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is\nrequired to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove\nresults where you want to change each term in a polynomial to something else depending on the\n`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. ","distance":1.0319226278224091775115311975241638720035552978515625}],["The \"inclusion\" `N n ⟶ X _[n]` for all `n : ℕ`. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    {X : CategoryTheory.SimplicialObject C} →\n      (self : SimplicialObject.Splitting X) → (n : ℕ) → self.N n ⟶ X.obj (Opposite.op (SimplexCategory.mk n))","name":"SimplicialObject.Splitting.ι","isProp":false,"docString":"The \"inclusion\" `N n ⟶ X _[n]` for all `n : ℕ`. ","distance":1.03462350884769715975153303588740527629852294921875}],["positive integers summing to `n`",{"type":"{n : ℕ} → n.Partition → Multiset ℕ","name":"Nat.Partition.parts","isProp":false,"docString":"positive integers summing to `n`","distance":1.036658506438463245302727955277077853679656982421875}],["Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). ",{"type":"Lean.ParserDescr","name":"finiteness?","isProp":false,"docString":"Tactic to solve goals of the form `*** < ∞` and (equivalently) `*** ≠ ∞` in the extended\nnonnegative reals (`ℝ≥0∞`). ","distance":1.04140291528891903993780942982994019985198974609375}],["The constant function with value `n : ℤ`. ",{"type":"{α : Type u_1} → ℤ → Poly α","name":"Poly.const","isProp":false,"docString":"The constant function with value `n : ℤ`. ","distance":1.0428587057815352778789019794203341007232666015625}],["`ℕ+` is the type of positive natural numbers. It is defined as a subtype,\nand the VM representation of `ℕ+` is the same as `ℕ` because the proof\nis not stored. ",{"type":"Lean.ParserDescr","name":"«termℕ+»","isProp":false,"docString":"`ℕ+` is the type of positive natural numbers. It is defined as a subtype,\nand the VM representation of `ℕ+` is the same as `ℕ` because the proof\nis not stored. ","distance":1.04301427129343782240766813629306852817535400390625}],["the predicate of objects that are `≤ n` for `n : ℤ`. ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      [inst_2 : CategoryTheory.Limits.HasZeroObject C] →\n        [inst_3 : CategoryTheory.HasShift C ℤ] →\n          [inst_4 : ∀ (n : ℤ), (CategoryTheory.shiftFunctor C n).Additive] →\n            [inst_5 : CategoryTheory.Pretriangulated C] → CategoryTheory.Triangulated.TStructure C → ℤ → C → Prop","name":"CategoryTheory.Triangulated.TStructure.LE","isProp":false,"docString":"the predicate of objects that are `≤ n` for `n : ℤ`. ","distance":1.045803197111782711914429455646313726902008056640625}],["A type equivalent to `ℕ` is denumerable. ",{"type":"{α : Type u_3} → α ≃ ℕ → Denumerable α","name":"Denumerable.mk'","isProp":false,"docString":"A type equivalent to `ℕ` is denumerable. ","distance":1.0475377441577429227237416853313334286212921142578125}]]