[["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadEnv m] → [inst : Lean.MonadError m] → Lean.Name → m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.968842206238570202714299739454872906208038330078125}],[" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `𝕜`, a normed additive group `E` over `𝕜` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ↦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.",{"type":"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] {I : ModelWithCorners 𝕜 E H} {G : Type u_4}\n  [inst_4 : Inv G] [inst_5 : Zero G] [inst_6 : TopologicalSpace G] [inst_7 : ChartedSpace H G] [self : SmoothInv₀ I G]\n  ⦃x : G⦄, x ≠ 0 → SmoothAt I I (fun y => y⁻¹) x","name":"SmoothInv₀.smoothAt_inv₀","isProp":true,"docString":" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `𝕜`, a normed additive group `E` over `𝕜` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ↦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.","distance":2.0049236823785605565717560239136219024658203125}],["The theorem `IsBot.isMin` states that for any type `α` that has a less than or equal to ordering (`LE`), if an element `a` of `α` is a bottom element (meaning it is less than or equal to every other element of `α`), then `a` is also a minimal element (meaning that there is no element strictly less than it). In other words, if `a` is at the bottom of the order, it also serves as a minimal bound for the set.",{"type":"∀ {α : Type u_1} [inst : LE α] {a : α}, IsBot a → IsMin a","name":"IsBot.isMin","isProp":true,"docString":"The theorem `IsBot.isMin` states that for any type `α` that has a less than or equal to ordering (`LE`), if an element `a` of `α` is a bottom element (meaning it is less than or equal to every other element of `α`), then `a` is also a minimal element (meaning that there is no element strictly less than it). In other words, if `a` is at the bottom of the order, it also serves as a minimal bound for the set.","distance":1.9957681607473476415037794140516780316829681396484375}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9742522802076241106306042638607323169708251953125}],[" If `f` is a continuous function between topological spaces `X` and `Y`, and `x` specializes to `y` in `X`, then `f(x)` specializes to `f(y)` in `Y`.",{"type":"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {x y : X} {f : X → Y},\n  x ⤳ y → Continuous f → f x ⤳ f y","name":"Specializes.map","isProp":true,"docString":" If `f` is a continuous function between topological spaces `X` and `Y`, and `x` specializes to `y` in `X`, then `f(x)` specializes to `f(y)` in `Y`.","distance":2.01214599478269651200434964266605675220489501953125}],["This theorem states that for any topological space `α` and any discrete topological space `Y`, if `α` is preconnected and `f` is a continuous function from `α` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `α`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace α → ∀ {f : α → Y}, Continuous f → ∀ {x y : α}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"This theorem states that for any topological space `α` and any discrete topological space `Y`, if `α` is preconnected and `f` is a continuous function from `α` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `α`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.","distance":1.997033412012326980544685284257866442203521728515625}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9742532941801471668696876804460771381855010986328125}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData → Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":1.980787743198292982782504623173736035823822021484375}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConcaveOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9866078022641111555657289500231854617595672607421875}],["Default definition of `min`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9897215856659233867986813493189401924610137939453125}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {K : Set F},\n  Convex ℝ K → ∀ {u v : F}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.992135325068838280770933124586008489131927490234375}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.9928382903828778527355325422831811010837554931640625}],["The minimum operation: `min x y`. ",{"type":"{α : Type u} → [self : Min α] → α → α → α","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":1.9933322412063170236962150738690979778766632080078125}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module 𝕜 β] [inst_3 : OrderedSMul 𝕜 β] {f : 𝕜 → β} {x y z : 𝕜},\n  ConcaveOn 𝕜 (Set.Icc x y) f → z ∈ Set.Icc x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.99351228943962421880087276804260909557342529296875}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"∀ {d : ℤ} {a : Pell.Solution₁ d}, a = 1 ∨ a = -1 ↔ Pell.Solution₁.y a = 0","name":"Pell.Solution₁.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":1.9953489254731768820505521944141946732997894287109375}],["The orthogonal projection of `y` on `U` minimizes the distance `‖y - x‖` for `x ∈ U`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U] (y : E), ‖y - ↑((orthogonalProjection U) y)‖ = ⨅ x, ‖y - ↑x‖","name":"orthogonalProjection_minimal","isProp":true,"docString":"The orthogonal projection of `y` on `U` minimizes the distance `‖y - x‖` for `x ∈ U`. ","distance":1.9955920717208883718996048628468997776508331298828125}],["Elaborate an `#align` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabAlign","isProp":false,"docString":"Elaborate an `#align` command. ","distance":1.997661642442895679749881310272030532360076904296875}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) → (M : Type u_2) → [inst : Semiring R] → [inst_1 : AddCommGroup M] → [inst : Module R M] → ℕ","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":1.997771732598433658267822465859353542327880859375}],["Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. ",{"type":"{K : semiOutParam (Type u_1)} → [self : IsROrC K] → K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. ","distance":2.000094473964397767673517591902054846286773681640625}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name → Simps.ParsedProjectionData → List Lean.Level → Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":2.0002874782064825609495528624393045902252197265625}],["Semigroup homomorphism between the function spaces `I → α` and `I → β`, induced by a semigroup\nhomomorphism `f` between `α` and `β`. ",{"type":"{α : Type u_3} → {β : Type u_4} → [inst : Mul α] → [inst_1 : Mul β] → (α →ₙ* β) → (I : Type u_5) → (I → α) →ₙ* I → β","name":"MulHom.compLeft","isProp":false,"docString":"Semigroup homomorphism between the function spaces `I → α` and `I → β`, induced by a semigroup\nhomomorphism `f` between `α` and `β`. ","distance":2.000332489818658299185472060344181954860687255859375}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : TypeVec.Arrow Fin2.elim0 Fin2.elim0 → Sort u_1} →\n  β TypeVec.nilFun → (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) → β f","name":"TypeVec.typevecCasesNil₂","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":2.001266428914515227432957544806413352489471435546875}],["**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull 𝕜 s` lies in `s`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {s : Set E} {f : E → β}, ConcaveOn 𝕜 ((convexHull 𝕜) s) f → ∀ {x : E}, x ∈ (convexHull 𝕜) s → ∃ y ∈ s, f y ≤ f x","name":"ConcaveOn.exists_le_of_mem_convexHull","isProp":true,"docString":"**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull 𝕜 s` lies in `s`. ","distance":2.001304679737286651430849815369583666324615478515625}],["Elaborate a `#noalign` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabNoAlign","isProp":false,"docString":"Elaborate a `#noalign` command. ","distance":2.00132106231963025066988848266191780567169189453125}]]