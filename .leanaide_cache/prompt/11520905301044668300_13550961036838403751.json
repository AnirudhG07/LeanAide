[["The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{ùïú : Type u_8} ‚Üí\n  {ùïú' : Type u_9} ‚Üí\n    {E : Type u_10} ‚Üí\n      [inst : NormedField ùïú'] ‚Üí\n        [inst_1 : SeminormedAddCommGroup E] ‚Üí [I : NormedSpace ùïú' E] ‚Üí NormedSpace ùïú' (RestrictScalars ùïú ùïú' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.9406687807206726148478992399759590625762939453125}],[" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.",{"type":"‚àÄ (n : ‚Ñï), ‚Üën = ‚Üën","name":"Nat.cast_withBot","isProp":true,"docString":" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.","distance":1.9745928067238882608336325574782676994800567626953125}],["This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.",{"type":"‚àÄ {K : Type u} [inst : Field K], RatFunc.denom 0 = 1","name":"RatFunc.denom_zero","isProp":true,"docString":"This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.","distance":1.97141072870758460311435555922798812389373779296875}],["Embedding of a subtype into the ambient type as an `OrderEmbedding`. ",{"type":"{Œ± : Type u_2} ‚Üí [inst : Preorder Œ±] ‚Üí (p : Œ± ‚Üí Prop) ‚Üí Subtype p ‚Ü™o Œ±","name":"OrderEmbedding.subtype","isProp":false,"docString":"Embedding of a subtype into the ambient type as an `OrderEmbedding`. ","distance":1.9514698882657486311842376380809582769870758056640625}],[" The constant function from type `Œ±` to natural numbers `Function.const (Œ± ‚Üí ‚Ñï) n` is Diophantine for any type `Œ±` and natural number `n`.",{"type":"‚àÄ {Œ± : Type} (n : ‚Ñï), Dioph.DiophFn (Function.const (Œ± ‚Üí ‚Ñï) n)","name":"Dioph.const_dioph","isProp":true,"docString":" The constant function from type `Œ±` to natural numbers `Function.const (Œ± ‚Üí ‚Ñï) n` is Diophantine for any type `Œ±` and natural number `n`.","distance":1.985526450691069033638314067502506077289581298828125}],["The theorem `not_isMax` asserts that for any type `Œ±` which has a preorder structure and also satisfies the `NoMaxOrder` condition (i.e., there is no maximal element in the set), any element `a` of type `Œ±` cannot be a maximal element. In other words, in a set with a preorder structure without a maximum element, there always exists some other element that is strictly greater than any given element.",{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : NoMaxOrder Œ±] (a : Œ±), ¬¨IsMax a","name":"not_isMax","isProp":true,"docString":"The theorem `not_isMax` asserts that for any type `Œ±` which has a preorder structure and also satisfies the `NoMaxOrder` condition (i.e., there is no maximal element in the set), any element `a` of type `Œ±` cannot be a maximal element. In other words, in a set with a preorder structure without a maximum element, there always exists some other element that is strictly greater than any given element.","distance":1.976546797695897250690677537932060658931732177734375}],["Converts a `ZNum` to a `PosNum`, mapping all out of range values to `1`. ",{"type":"ZNum ‚Üí PosNum","name":"PosNum.ofZNum","isProp":false,"docString":"Converts a `ZNum` to a `PosNum`, mapping all out of range values to `1`. ","distance":1.956810901498682309096466269693337380886077880859375}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{Œ± : Type v} ‚Üí Quotient.out (Cardinal.mk Œ±) ‚âÉ Œ±","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":1.9591888019807501830626961236703209578990936279296875}],["Restrict the codomain of a principal segment ",{"type":"{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí\n      {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí\n        (p : Set Œ≤) ‚Üí (f : r ‚â∫i s) ‚Üí (‚àÄ (a : Œ±), f.toRelEmbedding a ‚àà p) ‚Üí f.top ‚àà p ‚Üí r ‚â∫i Subrel s p","name":"PrincipalSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of a principal segment ","distance":1.9596606085960528442768691093078814446926116943359375}],["`IsSpecial'` is an alternative of `IsSpecial`. ",{"type":"PNat.XgcdType ‚Üí Prop","name":"PNat.XgcdType.IsSpecial'","isProp":false,"docString":"`IsSpecial'` is an alternative of `IsSpecial`. ","distance":1.96012158350293308473055731155909597873687744140625}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ‚â§ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ‚â§ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":1.9601884005094749596764813759364187717437744140625}],["Reverse of `Set.codRestrict_restrict`. ",{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : Œ± ‚Üí Œ≤} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h = Set.codRestrict (Set.restrict s f) t (_ : ‚àÄ (x : ‚Üës), f ‚Üëx ‚àà t)","name":"Set.MapsTo.restrict_eq_codRestrict","isProp":true,"docString":"Reverse of `Set.codRestrict_restrict`. ","distance":1.9614181402540749044050016891560517251491546630859375}],["A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"‚Ñï ‚Üí Type","name":"Affine.Simplex.PointsWithCircumcenterIndex.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.96157168445067942030846097622998058795928955078125}],["This is a special case of a more general instance that we define in a later file. ",{"type":"‚àÄ {R : Type u} (A : Type v) [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Subsingleton (R ‚Üí‚Çê[R] A)","name":"Algebra.subsingleton_id","isProp":true,"docString":"This is a special case of a more general instance that we define in a later file. ","distance":1.9621442382793079506342337481328286230564117431640625}],["Restrict the codomain of an initial segment ",{"type":"{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí (p : Set Œ≤) ‚Üí (f : r ‚âºi s) ‚Üí (‚àÄ (a : Œ±), f a ‚àà p) ‚Üí r ‚âºi Subrel s p","name":"InitialSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of an initial segment ","distance":1.9624678680785307971490283307502977550029754638671875}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"‚àÄ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Convex ‚Ñù s ‚Üí ‚àÄ {x : E}, x ‚àà interior s ‚Üí ‚àÄ (t : ‚Ñù), 1 < t ‚Üí closure s ‚äÜ interior (‚áë(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.962715762018660825560800731182098388671875}],["`WithInitial.star` is initial. ",{"type":"{C : Type u} ‚Üí\n  [inst : CategoryTheory.Category.{v, u} C] ‚Üí CategoryTheory.Limits.IsInitial CategoryTheory.WithInitial.star","name":"CategoryTheory.WithInitial.starInitial","isProp":false,"docString":"`WithInitial.star` is initial. ","distance":1.962751699921443826468703264254145324230194091796875}],["This is the `norm_num` plug-in that evaluates Legendre symbols. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalLegendreSym","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Legendre symbols. ","distance":1.9628820420438188865119855108787305653095245361328125}],["A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"Type u_1 ‚Üí Type u_2 ‚Üí Type (max u_1 u_2)","name":"Symbol.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.964609999259564698803615101496689021587371826171875}],["This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalJacobiSymNat","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ","distance":1.96478589244715440287336605251766741275787353515625}],["The class number of a principal ideal domain is `1`. ",{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R],\n  Fintype.card (ClassGroup R) = 1","name":"card_classGroup_eq_one","isProp":true,"docString":"The class number of a principal ideal domain is `1`. ","distance":1.964993087217366873886703615426085889339447021484375}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"‚àÄ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Convex ‚Ñù s ‚Üí ‚àÄ {x : E}, x ‚àà interior s ‚Üí ‚àÄ (t : ‚Ñù), 1 < t ‚Üí closure s ‚äÜ ‚áë(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.965278738078140907674651316483505070209503173828125}],["A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n",{"type":"(A : Type u_2) ‚Üí [inst : CommRing A] ‚Üí [inst : IsDomain A] ‚Üí Prop","name":"IsDedekindDomainInv","isProp":false,"docString":"A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n","distance":1.9661764274131259266908955396502278745174407958984375}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9670380573159744752587130278698168694972991943359375}]]