[["Given a subgraph and a set of vertices, delete all the vertices from the subgraph,\nif present. Any edges incident to the deleted vertices are deleted as well. ",{"type":"{V : Type u} → {G : SimpleGraph V} → SimpleGraph.Subgraph G → Set V → SimpleGraph.Subgraph G","name":"SimpleGraph.Subgraph.deleteVerts","isProp":false,"docString":"Given a subgraph and a set of vertices, delete all the vertices from the subgraph,\nif present. Any edges incident to the deleted vertices are deleted as well. ","distance":1.9040348881371951250685015111230313777923583984375}],[" Given a simple graph and replacing a vertex with another non-equal vertex preserves adjacency for all other vertices.",{"type":"∀ {V : Type u_1} [inst : DecidableEq V] (G : SimpleGraph V) (s : V) {t w : V},\n  w ≠ t → ((G.replaceVertex s t).Adj s w ↔ G.Adj s w)","name":"SimpleGraph.adj_replaceVertex_iff_of_ne_left","isProp":true,"docString":" Given a simple graph and replacing a vertex with another non-equal vertex preserves adjacency for all other vertices.","distance":1.8866457605325417379305008580558933317661285400390625}],["This theorem states that for any cardinal number `a`, the function `Cardinal.toENat a` equals the value `⊤` (which represents infinity in the context of the natural number extension `ℕ∞`) if and only if `a` is greater than or equal to `ℵ₀` (the smallest infinite cardinal, represented by the function `Cardinal.aleph0`). In other words, this function sends all infinite cardinal numbers to `⊤`, and finite cardinal numbers to their corresponding natural number.",{"type":"∀ {a : Cardinal.{u_1}}, Cardinal.toENat a = ⊤ ↔ Cardinal.aleph0 ≤ a","name":"Cardinal.toENat_eq_top","isProp":true,"docString":"This theorem states that for any cardinal number `a`, the function `Cardinal.toENat a` equals the value `⊤` (which represents infinity in the context of the natural number extension `ℕ∞`) if and only if `a` is greater than or equal to `ℵ₀` (the smallest infinite cardinal, represented by the function `Cardinal.aleph0`). In other words, this function sends all infinite cardinal numbers to `⊤`, and finite cardinal numbers to their corresponding natural number.","distance":1.9358371602439670144946148866438306868076324462890625}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name → Bool) → Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.909348245226297091647893466870300471782684326171875}],[" The set of prime numbers is unbounded.",{"type":"¬BddAbove {p | p.Prime}","name":"Nat.not_bddAbove_setOf_prime","isProp":true,"docString":" The set of prime numbers is unbounded.","distance":1.89818765860591742722363051143474876880645751953125}],["The theorem `Prod.fst_surjective` states that for all types `α` and `β`, given that `β` is nonempty, the first projection function `Prod.fst` is surjective. In other words, for every element of `α` in the product type `α × β`, there exists a pair in `α × β` such that when we apply the `Prod.fst` function (which extracts the first element of the pair), we can get any element of `α`. This means that we can reach every element of `α` by selecting some pair from `α × β` and taking its first component.",{"type":"∀ {α : Type u_1} {β : Type u_2} [h : Nonempty β], Function.Surjective Prod.fst","name":"Prod.fst_surjective","isProp":true,"docString":"The theorem `Prod.fst_surjective` states that for all types `α` and `β`, given that `β` is nonempty, the first projection function `Prod.fst` is surjective. In other words, for every element of `α` in the product type `α × β`, there exists a pair in `α × β` such that when we apply the `Prod.fst` function (which extracts the first element of the pair), we can get any element of `α`. This means that we can reach every element of `α` by selecting some pair from `α × β` and taking its first component.","distance":1.9384451763383865330325761533458717167377471923828125}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ ⇑(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9123663356830553627929702997789718210697174072265625}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ interior (⇑(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.913143695579062164568995285662822425365447998046875}],["Apply a function returning values inside the monad to a monadic lazy list,\nreturning only the first successful result.\n",{"type":"{m : Type u_1 → Type u_1} →\n  {α β : Type u_1} → [inst : Monad m] → [inst : Alternative m] → MLList m α → (α → m (Option β)) → m β","name":"MLList.firstM","isProp":false,"docString":"Apply a function returning values inside the monad to a monadic lazy list,\nreturning only the first successful result.\n","distance":1.9156678606842489909212190468679182231426239013671875}],["Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n",{"type":"{ω : Type u_1} →\n  {α : Type} →\n    (prio : α → Thunk ω) →\n      (ε : α → Type) →\n        [inst : LinearOrder ω] →\n          [inst_1 : (a : α) → Estimator (prio a) (ε a)] →\n            [I : ∀ (a : α), WellFoundedGT ↑(Set.range (EstimatorData.bound (prio a)))] →\n              [inst : Ord ω] →\n                [inst : Ord α] →\n                  {m : Type → Type} →\n                    [inst : Monad m] →\n                      [inst : Alternative m] →\n                        [inst : (a : α) → Bot (ε a)] → Option ℕ → (α → MLList m α) → α → MLList m α","name":"impl","isProp":false,"docString":"Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n","distance":1.9190809924577265643819146134774200618267059326171875}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name → Array Simps.ParsedProjectionData → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.9211047045298330626650340491323731839656829833984375}],["Given a presieve on `X`, and a sieve on each domain of an arrow in the presieve, we can bind to\nproduce a sieve on `X`.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {X : C} →\n      (S : CategoryTheory.Presieve X) → (⦃Y : C⦄ → ⦃f : Y ⟶ X⦄ → S f → CategoryTheory.Sieve Y) → CategoryTheory.Sieve X","name":"CategoryTheory.Sieve.bind","isProp":false,"docString":"Given a presieve on `X`, and a sieve on each domain of an arrow in the presieve, we can bind to\nproduce a sieve on `X`.\n","distance":1.923974418393368690516354035935364663600921630859375}],["This function sends finite cardinals to the corresponding natural, and infinite cardinals\nto 0. ",{"type":"ZeroHom Cardinal.{v} ℕ","name":"Cardinal.toNat","isProp":false,"docString":"This function sends finite cardinals to the corresponding natural, and infinite cardinals\nto 0. ","distance":1.9240346018752430001796938086044974625110626220703125}],["Scaling by a positive unit is a no-op. ",{"type":"∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (u : Rˣ), 0 < ↑u → ∀ (v : Module.Ray R M), u • v = v","name":"Module.Ray.units_smul_of_pos","isProp":true,"docString":"Scaling by a positive unit is a no-op. ","distance":1.9242702367669533014549188010278157889842987060546875}],["First samples a proxy value and interprets it. Especially useful if\nthe proxy and target type are the same. ",{"type":"(α : Type u) → [inst : SlimCheck.SampleableExt α] → SlimCheck.Gen α","name":"SlimCheck.SampleableExt.interpSample","isProp":false,"docString":"First samples a proxy value and interprets it. Especially useful if\nthe proxy and target type are the same. ","distance":1.9251352649924717841400934048579074442386627197265625}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.926083783663933512997346042538993060588836669921875}],["Embedding of the original ring `R` into `AdjoinRoot f`. ",{"type":"{R : Type u} → [inst : CommRing R] → (f : Polynomial R) → R →+* AdjoinRoot f","name":"AdjoinRoot.of","isProp":false,"docString":"Embedding of the original ring `R` into `AdjoinRoot f`. ","distance":1.9262406521767914124865228586713783442974090576171875}],["Produce a matrix with `f` applied to every pair of elements from `A` and `B`. ",{"type":"{α : Type u_2} →\n  {β : Type u_4} →\n    {γ : Type u_6} →\n      {l : Type u_8} →\n        {m : Type u_9} →\n          {n : Type u_10} → {p : Type u_11} → (α → β → γ) → Matrix l m α → Matrix n p β → Matrix (l × n) (m × p) γ","name":"Matrix.kroneckerMap","isProp":false,"docString":"Produce a matrix with `f` applied to every pair of elements from `A` and `B`. ","distance":1.9277221715034216220630014504422433674335479736328125}],["Given a set of vertex pairs, remove all of the corresponding edges from the\ngraph's edge set, if present.\n\nSee also: `SimpleGraph.Subgraph.deleteEdges`. ",{"type":"{V : Type u} → SimpleGraph V → Set (Sym2 V) → SimpleGraph V","name":"SimpleGraph.deleteEdges","isProp":false,"docString":"Given a set of vertex pairs, remove all of the corresponding edges from the\ngraph's edge set, if present.\n\nSee also: `SimpleGraph.Subgraph.deleteEdges`. ","distance":1.9279119416377656914818317090976051986217498779296875}],["The singleton presieve.  ",{"type":"{C : Type u₁} → [inst : CategoryTheory.Category.{v₁, u₁} C] → {X Y : C} → (Y ⟶ X) → CategoryTheory.Presieve X","name":"CategoryTheory.Presieve.singleton","isProp":false,"docString":"The singleton presieve.  ","distance":1.9288911965406778659115616392227821052074432373046875}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name → Simps.ParsedProjectionData → List Lean.Level → Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.92894822584206959703578831977210938930511474609375}],["A normal closure is always normal. ",{"type":"∀ {F : Type u_1} {K : Type u_2} {L : Type u_3} [inst : Field F] [inst_1 : Field K] [inst_2 : Field L]\n  [inst_3 : Algebra F K] [inst_4 : Algebra F L] [h : IsNormalClosure F K L], Normal F L","name":"IsNormalClosure.normal","isProp":true,"docString":"A normal closure is always normal. ","distance":1.92919924579710855283565251738764345645904541015625}],["Unbundled version of `Cardinal.toENat`. ",{"type":"Cardinal.{u} → ℕ∞","name":"Cardinal.toENatAux","isProp":false,"docString":"Unbundled version of `Cardinal.toENat`. ","distance":1.92933651219371693485982177662663161754608154296875}],["A dilation maps balls to balls and scales the radius by `ratio f`. ",{"type":"∀ {α : Type u_1} {β : Type u_2} {F : Type u_4} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β]\n  [inst_2 : DilationClass F α β] (f : F) (x : α) (r' : ℝ),\n  Set.MapsTo (⇑f) (Metric.ball x r') (Metric.ball (f x) (↑(Dilation.ratio f) * r'))","name":"Dilation.mapsTo_ball","isProp":true,"docString":"A dilation maps balls to balls and scales the radius by `ratio f`. ","distance":1.929478920358992155570376780815422534942626953125}]]