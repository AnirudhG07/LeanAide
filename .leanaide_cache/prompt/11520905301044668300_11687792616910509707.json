[["The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n",{"type":"Lean.ParserDescr","name":"commandSudoSet_option___","isProp":false,"docString":"The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n","distance":1.965295319334209533934654245967976748943328857421875}],[" For complex numbers `u` with positive real part and natural number `n`, the Beta function `Œ≤(u, n+1)` equals `fact(n) / prod(i in range (n+1), u + i)`.",{"type":"‚àÄ {u : ‚ÑÇ}, 0 < u.re ‚Üí ‚àÄ (n : ‚Ñï), u.betaIntegral (‚Üën + 1) = ‚Üën.factorial / (Finset.range (n + 1)).prod fun j => u + ‚Üëj","name":"Complex.betaIntegral_eval_nat_add_one_right","isProp":true,"docString":" For complex numbers `u` with positive real part and natural number `n`, the Beta function `Œ≤(u, n+1)` equals `fact(n) / prod(i in range (n+1), u + i)`.","distance":1.9975256449249398915668507470400072634220123291015625}],["This theorem provides an explicit formula for the Beta function in the complex plane when the second argument is a positive integer. For any complex number `u` with positive real part and any natural number `n`, the Beta function of `u` and `n + 1` is equal to the factorial of `n` divided by the product of `u` plus each natural number less than `n + 1`.",{"type":"‚àÄ {u : ‚ÑÇ}, 0 < u.re ‚Üí ‚àÄ (n : ‚Ñï), u.betaIntegral (‚Üën + 1) = ‚Üën.factorial / (Finset.range (n + 1)).prod fun j => u + ‚Üëj","name":"Complex.betaIntegral_eval_nat_add_one_right","isProp":true,"docString":"This theorem provides an explicit formula for the Beta function in the complex plane when the second argument is a positive integer. For any complex number `u` with positive real part and any natural number `n`, the Beta function of `u` and `n + 1` is equal to the factorial of `n` divided by the product of `u` plus each natural number less than `n + 1`.","distance":1.99076746368883306104180519469082355499267578125}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ‚â§ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ‚â§ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":1.9733686870264326440604918388999067246913909912109375}],[" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.",{"type":"‚àÄ (n : ‚Ñï), ‚Üën = ‚Üën","name":"Nat.cast_withBot","isProp":true,"docString":" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.","distance":1.9983461046184591847207911996520124375820159912109375}],["The theorem named 'Complex.betaIntegral_convergent' states that the Beta integral is convergent for all complex numbers `u` and `v` that have positive real parts. Specifically, the function that is being integrated is `x ^ (u - 1) * (1 - x) ^ (v - 1)`, over the interval from 0 to 1, with respect to the Lebesgue measure (denoted by `MeasureTheory.volume`). The Beta integral is said to be interval integrable, meaning it is integrable on both intervals `(0, 1]` and `(1, 0]`. Given that one of these intervals is always empty, this property is equivalent to the function being integrable on `(0, 1]`.",{"type":"‚àÄ {u v : ‚ÑÇ},\n  0 < u.re ‚Üí 0 < v.re ‚Üí IntervalIntegrable (fun x => ‚Üëx ^ (u - 1) * (1 - ‚Üëx) ^ (v - 1)) MeasureTheory.volume 0 1","name":"Complex.betaIntegral_convergent","isProp":true,"docString":"The theorem named 'Complex.betaIntegral_convergent' states that the Beta integral is convergent for all complex numbers `u` and `v` that have positive real parts. Specifically, the function that is being integrated is `x ^ (u - 1) * (1 - x) ^ (v - 1)`, over the interval from 0 to 1, with respect to the Lebesgue measure (denoted by `MeasureTheory.volume`). The Beta integral is said to be interval integrable, meaning it is integrable on both intervals `(0, 1]` and `(1, 0]`. Given that one of these intervals is always empty, this property is equivalent to the function being integrable on `(0, 1]`.","distance":1.997290777930467609024844932719133794307708740234375}],["Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n",{"type":"Lean.ParserDescr","name":"Mathlib.CountHeartbeats.commandCount_heartbeatsIn__","isProp":false,"docString":"Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n","distance":1.97747080399064056877023176639340817928314208984375}],["Reverse of `Set.codRestrict_restrict`. ",{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : Œ± ‚Üí Œ≤} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h = Set.codRestrict (Set.restrict s f) t (_ : ‚àÄ (x : ‚Üës), f ‚Üëx ‚àà t)","name":"Set.MapsTo.restrict_eq_codRestrict","isProp":true,"docString":"Reverse of `Set.codRestrict_restrict`. ","distance":1.9777290004665644129744350721011869609355926513671875}],["The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n",{"type":"Lean.ParserDescr","name":"termSudoSet_option___In_","isProp":false,"docString":"The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n","distance":1.980646396951211585246710455976426601409912109375}],["The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{ùïú : Type u_8} ‚Üí\n  {ùïú' : Type u_9} ‚Üí\n    {E : Type u_10} ‚Üí\n      [inst : NormedField ùïú'] ‚Üí\n        [inst_1 : SeminormedAddCommGroup E] ‚Üí [I : NormedSpace ùïú' E] ‚Üí NormedSpace ùïú' (RestrictScalars ùïú ùïú' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.98071210146114840000564072397537529468536376953125}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9827367389924426266389900774811394512653350830078125}],["`IsSpecial'` is an alternative of `IsSpecial`. ",{"type":"PNat.XgcdType ‚Üí Prop","name":"PNat.XgcdType.IsSpecial'","isProp":false,"docString":"`IsSpecial'` is an alternative of `IsSpecial`. ","distance":1.9867943719844836092391915371990762650966644287109375}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9877680252025571316920604658662341535091400146484375}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name ‚Üí Simps.ParsedProjectionData ‚Üí List Lean.Level ‚Üí Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.988849216159358501698761756415478885173797607421875}],["Create an element of type `Order.Ideal.PrimePair` from an ideal satisfying the predicate\n`Order.Ideal.IsPrime`. ",{"type":"{P : Type u_1} ‚Üí [inst : Preorder P] ‚Üí {I : Order.Ideal P} ‚Üí Order.Ideal.IsPrime I ‚Üí Order.Ideal.PrimePair P","name":"Order.Ideal.IsPrime.toPrimePair","isProp":false,"docString":"Create an element of type `Order.Ideal.PrimePair` from an ideal satisfying the predicate\n`Order.Ideal.IsPrime`. ","distance":1.989185094360607752861369590391404926776885986328125}],["Express `nndist` in terms of `dist`",{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x y : Œ±), nndist x y = Real.toNNReal (dist x y)","name":"nndist_dist","isProp":true,"docString":"Express `nndist` in terms of `dist`","distance":1.98935135588894329572440256015397608280181884765625}],["A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"‚Ñï ‚Üí Type","name":"Affine.Simplex.PointsWithCircumcenterIndex.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.98944904508475506332842996926046907901763916015625}],["This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalJacobiSymNat","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ","distance":1.989666631673293384352518842206336557865142822265625}],["This is the `norm_num` plug-in that evaluates Legendre symbols. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalLegendreSym","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Legendre symbols. ","distance":1.990068510745679031259669500286690890789031982421875}],["Return the current `maxHeartbeats`. ",{"type":"Lean.CoreM ‚Ñï","name":"getMaxHeartbeats","isProp":false,"docString":"Return the current `maxHeartbeats`. ","distance":1.99011350371449413643176740151830017566680908203125}],["The von Neumann bornology defined by the von Neumann bounded sets.\n\nNote that this is not registered as an instance, in order to avoid diamonds with the\nmetric bornology.",{"type":"(ùïú : Type u_1) ‚Üí\n  (E : Type u_3) ‚Üí\n    [inst : NormedField ùïú] ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module ùïú E] ‚Üí [inst_3 : TopologicalSpace E] ‚Üí [inst : ContinuousSMul ùïú E] ‚Üí Bornology E","name":"Bornology.vonNBornology","isProp":false,"docString":"The von Neumann bornology defined by the von Neumann bounded sets.\n\nNote that this is not registered as an instance, in order to avoid diamonds with the\nmetric bornology.","distance":1.9901651936845066170889140266808681190013885498046875}],["Returns a code for the constant function outputting a particular natural. ",{"type":"‚Ñï ‚Üí Nat.Partrec.Code","name":"Nat.Partrec.Code.const","isProp":false,"docString":"Returns a code for the constant function outputting a particular natural. ","distance":1.9918159003359809933186852504150010645389556884765625}],["The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ",{"type":"{Œπ : Type u_1} ‚Üí [inst : Fintype Œπ] ‚Üí BoxIntegral.Box Œπ ‚Üí NNReal","name":"BoxIntegral.Box.distortion","isProp":false,"docString":"The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ","distance":1.992028566250635179812888964079320430755615234375}],["Restrict the codomain of a principal segment ",{"type":"{Œ± : Type u_1} ‚Üí\n  {Œ≤ : Type u_2} ‚Üí\n    {r : Œ± ‚Üí Œ± ‚Üí Prop} ‚Üí\n      {s : Œ≤ ‚Üí Œ≤ ‚Üí Prop} ‚Üí\n        (p : Set Œ≤) ‚Üí (f : r ‚â∫i s) ‚Üí (‚àÄ (a : Œ±), f.toRelEmbedding a ‚àà p) ‚Üí f.top ‚àà p ‚Üí r ‚â∫i Subrel s p","name":"PrincipalSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of a principal segment ","distance":1.99215314873911975013243136345408856868743896484375}]]