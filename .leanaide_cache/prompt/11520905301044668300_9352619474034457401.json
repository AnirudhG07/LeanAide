[["Finite product of finite sets is finite. Note this is a variant of `Set.Finite.pi` without the\nextra `i ‚àà univ` binder. ",{"type":"‚àÄ {Œπ : Type u_1} [inst : Finite Œπ] {Œ∫ : Œπ ‚Üí Type u_2} {t : (i : Œπ) ‚Üí Set (Œ∫ i)},\n  (‚àÄ (i : Œπ), Set.Finite (t i)) ‚Üí Set.Finite {f | ‚àÄ (i : Œπ), f i ‚àà t i}","name":"Set.Finite.pi'","isProp":true,"docString":"Finite product of finite sets is finite. Note this is a variant of `Set.Finite.pi` without the\nextra `i ‚àà univ` binder. ","distance":1.919756674687747466379050820250995457172393798828125}],[" Given a non-unital normed ring `A` over a scalar field `ùïú`, where scalar multiplication commutes and `A` forms a scalar tower, the double centralizer maps commute, i.e., `self.toProd.1 (y * x) = self.toProd.2.1 y * x` for any `DoubleCentralizer` instance `self` and elements `x, y` in `A`.",{"type":"‚àÄ {ùïú : Type u} {A : Type v} [inst : NontriviallyNormedField ùïú] [inst_1 : NonUnitalNormedRing A]\n  [inst_2 : NormedSpace ùïú A] [inst_3 : SMulCommClass ùïú A A] [inst_4 : IsScalarTower ùïú A A]\n  (self : DoubleCentralizer ùïú A) (x y : A), self.toProd.2 x * y = x * self.toProd.1 y","name":"DoubleCentralizer.central","isProp":true,"docString":" Given a non-unital normed ring `A` over a scalar field `ùïú`, where scalar multiplication commutes and `A` forms a scalar tower, the double centralizer maps commute, i.e., `self.toProd.1 (y * x) = self.toProd.2.1 y * x` for any `DoubleCentralizer` instance `self` and elements `x, y` in `A`.","distance":1.9261619181964741986945455209934152662754058837890625}],["The theorem `IsPiSystem.prod` states that for any types `Œ±` and `Œ≤`, and for any sets `C` and `D` which are œÄ-systems (collections of subsets that are closed under binary intersection of non-disjoint sets), the set formed by the Cartesian product of elements from `C` and `D` is also a œÄ-system. More specifically, it uses the `Set.image2` function to construct the Cartesian product of the sets in `C` and `D`, and asserts that this is a œÄ-system. In other words, if we take any two rectangles (which are Cartesian products of sets), and if their intersection is nonempty, then this intersection also belongs to the collection of all such rectangles, thus making this collection a œÄ-system.",{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {C : Set (Set Œ±)} {D : Set (Set Œ≤)},\n  IsPiSystem C ‚Üí IsPiSystem D ‚Üí IsPiSystem (Set.image2 (fun x x_1 => x √óÀ¢ x_1) C D)","name":"IsPiSystem.prod","isProp":true,"docString":"The theorem `IsPiSystem.prod` states that for any types `Œ±` and `Œ≤`, and for any sets `C` and `D` which are œÄ-systems (collections of subsets that are closed under binary intersection of non-disjoint sets), the set formed by the Cartesian product of elements from `C` and `D` is also a œÄ-system. More specifically, it uses the `Set.image2` function to construct the Cartesian product of the sets in `C` and `D`, and asserts that this is a œÄ-system. In other words, if we take any two rectangles (which are Cartesian products of sets), and if their intersection is nonempty, then this intersection also belongs to the collection of all such rectangles, thus making this collection a œÄ-system.","distance":1.9111354665347912717976441854261793196201324462890625}],["A special case of `Set.image_finset_sum_pi` for `Finset.univ`. ",{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] [inst_1 : Fintype Œπ] (S : Œπ ‚Üí Set Œ±),\n  (fun f => Finset.sum Finset.univ fun i => f i) '' Set.pi Set.univ S = Finset.sum Finset.univ fun i => S i","name":"Set.image_fintype_sum_pi","isProp":true,"docString":"A special case of `Set.image_finset_sum_pi` for `Finset.univ`. ","distance":1.9207093980768570329331623725011013448238372802734375}],[" Given functions between sets and principal filters, the preimage filter of a function applied to a principal filter is equal to the principal filter of the preimage of the set under the function.",{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {m : Œ± ‚Üí Œ≤} {t : Set Œ≤}, Filter.comap m (Filter.principal t) = Filter.principal (m ‚Åª¬π' t)","name":"Filter.comap_principal","isProp":true,"docString":" Given functions between sets and principal filters, the preimage filter of a function applied to a principal filter is equal to the principal filter of the preimage of the set under the function.","distance":1.9333147502378726922955820555216632783412933349609375}],["The theorem `isPiSystem_pi` states that the collection of all boxes (i.e., Cartesian products of sets) forms a œÄ-system. In more detail, for any index type `Œπ` and a family of measurable types `Œ± i` indexed by `Œπ`, the image of the universal set under the function that forms the Cartesian product of all `s` such that `s` is a measurable set, forms a œÄ-system. In particular, this collection is closed under taking the intersection of any two of its non-disjoint subsets.",{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_3} [inst : (i : Œπ) ‚Üí MeasurableSpace (Œ± i)],\n  IsPiSystem (Set.univ.pi '' Set.univ.pi fun i => {s | MeasurableSet s})","name":"isPiSystem_pi","isProp":true,"docString":"The theorem `isPiSystem_pi` states that the collection of all boxes (i.e., Cartesian products of sets) forms a œÄ-system. In more detail, for any index type `Œπ` and a family of measurable types `Œ± i` indexed by `Œπ`, the image of the universal set under the function that forms the Cartesian product of all `s` such that `s` is a measurable set, forms a œÄ-system. In particular, this collection is closed under taking the intersection of any two of its non-disjoint subsets.","distance":1.9217361312245859750191812054254114627838134765625}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"‚àÄ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Convex ‚Ñù s ‚Üí ‚àÄ {x : E}, x ‚àà interior s ‚Üí ‚àÄ (t : ‚Ñù), 1 < t ‚Üí closure s ‚äÜ ‚áë(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9220235482921685932211630642996169626712799072265625}],["For a given compact subset `C` of `I ‚Üí Bool`, `spanFunctor` is the functor from the poset of finsets\nof `I` to `Profinite`, sending a finite subset set `J` to the image of `C` under the projection\n`Proj J`.\n",{"type":"{I : Type u} ‚Üí\n  {C : Set (I ‚Üí Bool)} ‚Üí\n    IsCompact C ‚Üí [inst : (s : Finset I) ‚Üí (i : I) ‚Üí Decidable (i ‚àà s)] ‚Üí CategoryTheory.Functor (Finset I)·µí·µñ Profinite","name":"Profinite.NobelingProof.spanFunctor","isProp":false,"docString":"For a given compact subset `C` of `I ‚Üí Bool`, `spanFunctor` is the functor from the poset of finsets\nof `I` to `Profinite`, sending a finite subset set `J` to the image of `C` under the projection\n`Proj J`.\n","distance":1.9227455589817907810612496177782304584980010986328125}],["The equivalence between a product of two dependent functions types and a single dependent\nfunction type. Basically a symmetric version of `Equiv.sumPiEquivProdPi`. ",{"type":"{Œπ : Type u_1} ‚Üí\n  {Œπ' : Type u_2} ‚Üí\n    (œÄ : Œπ ‚Üí Type u) ‚Üí (œÄ' : Œπ' ‚Üí Type u) ‚Üí ((i : Œπ) ‚Üí œÄ i) √ó ((i' : Œπ') ‚Üí œÄ' i') ‚âÉ ((i : Œπ ‚äï Œπ') ‚Üí Sum.elim œÄ œÄ' i)","name":"Equiv.prodPiEquivSumPi","isProp":false,"docString":"The equivalence between a product of two dependent functions types and a single dependent\nfunction type. Basically a symmetric version of `Equiv.sumPiEquivProdPi`. ","distance":1.9235567373753166275918147221091203391551971435546875}],["name for this projection used in the generated `simp` lemmas ",{"type":"Simps.ParsedProjectionData ‚Üí Lean.Name","name":"Simps.ParsedProjectionData.newName","isProp":false,"docString":"name for this projection used in the generated `simp` lemmas ","distance":1.9238322632705620041093652616837061941623687744140625}],["For a sum type `inductive Foo (Œ± : Type) | foo1 : List Œ± ‚Üí ‚Ñï ‚Üí Foo Œ± | ...`\n``traverseField `Foo f `Œ± `(x : List Œ±)`` synthesizes\n`traverse f x` as part of traversing `foo1`. ",{"type":"Lean.Name ‚Üí Lean.Expr ‚Üí Lean.Expr ‚Üí Lean.Expr ‚Üí Lean.Expr ‚Üí Lean.Elab.TermElabM (Bool √ó Lean.Expr)","name":"Mathlib.Deriving.Traversable.traverseField","isProp":false,"docString":"For a sum type `inductive Foo (Œ± : Type) | foo1 : List Œ± ‚Üí ‚Ñï ‚Üí Foo Œ± | ...`\n``traverseField `Foo f `Œ± `(x : List Œ±)`` synthesizes\n`traverse f x` as part of traversing `foo1`. ","distance":1.9244559669734966345089333117357455193996429443359375}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"‚àÄ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E},\n  Convex ‚Ñù s ‚Üí ‚àÄ {x : E}, x ‚àà interior s ‚Üí ‚àÄ (t : ‚Ñù), 1 < t ‚Üí closure s ‚äÜ interior (‚áë(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.924873836186785869273307980620302259922027587890625}],["A 'dite' producing a `Pi` type `Œ† a, œÉ a`, applied to a value `a : Œ±` is a `dite` that applies\neither branch to `a`. ",{"type":"‚àÄ {Œ± : Sort u_2} {œÉ : Œ± ‚Üí Sort u_1} (P : Prop) [inst : Decidable P] (f : P ‚Üí (a : Œ±) ‚Üí œÉ a) (g : ¬¨P ‚Üí (a : Œ±) ‚Üí œÉ a)\n  (a : Œ±), dite P f g a = if h : P then f h a else g h a","name":"dite_apply","isProp":true,"docString":"A 'dite' producing a `Pi` type `Œ† a, œÉ a`, applied to a value `a : Œ±` is a `dite` that applies\neither branch to `a`. ","distance":1.925085397800987419003604372846893966197967529296875}],["A variant of `ProjRestrict` with domain of the form `œÄ C K` ",{"type":"{I : Type u} ‚Üí\n  (C : Set (I ‚Üí Bool)) ‚Üí\n    {J K : I ‚Üí Prop} ‚Üí\n      [inst : (i : I) ‚Üí Decidable (J i)] ‚Üí\n        [inst_1 : (i : I) ‚Üí Decidable (K i)] ‚Üí\n          (‚àÄ (i : I), J i ‚Üí K i) ‚Üí ‚Üë(Profinite.NobelingProof.œÄ C K) ‚Üí ‚Üë(Profinite.NobelingProof.œÄ C J)","name":"Profinite.NobelingProof.ProjRestricts","isProp":false,"docString":"A variant of `ProjRestrict` with domain of the form `œÄ C K` ","distance":1.9256447782454788608674789429642260074615478515625}],["Canonical prefunctor from `B` to `free_bicategory B`. ",{"type":"{B : Type u} ‚Üí [inst : Quiver B] ‚Üí B ‚•§q CategoryTheory.FreeBicategory B","name":"CategoryTheory.FreeBicategory.of","isProp":false,"docString":"Canonical prefunctor from `B` to `free_bicategory B`. ","distance":1.9256612835216093682078053461736999452114105224609375}],["Given a presheaf `P` on the category of types, construct\na map `P(Œ±) ‚Üí (Œ± ‚Üí P(*))` for all type `Œ±`. ",{"type":"(P : CategoryTheory.Functor Type u·µí·µñ (Type u)) ‚Üí\n  (Œ± : Type u) ‚Üí P.obj (Opposite.op Œ±) ‚Üí Œ± ‚Üí P.obj (Opposite.op PUnit.{u + 1})","name":"CategoryTheory.eval","isProp":false,"docString":"Given a presheaf `P` on the category of types, construct\na map `P(Œ±) ‚Üí (Œ± ‚Üí P(*))` for all type `Œ±`. ","distance":1.9264566352822007910816637377138249576091766357421875}],["A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        {J : Type w} ‚Üí\n          [inst_2 : CategoryTheory.Category.{w', w} J] ‚Üí\n            {K : CategoryTheory.Functor J C} ‚Üí\n              (F : CategoryTheory.Functor C D) ‚Üí\n                {c : CategoryTheory.Limits.Cocone K} ‚Üí\n                  CategoryTheory.Limits.IsColimit c ‚Üí\n                    [inst_3 : CategoryTheory.Limits.PreservesColimit K F] ‚Üí\n                      CategoryTheory.Limits.IsColimit (F.mapCocone c)","name":"CategoryTheory.Limits.isColimitOfPreserves","isProp":false,"docString":"A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":1.926701296003319185956570436246693134307861328125}],["Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the sum is over `Finset.univ`. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"BigOperators.delabFinsetSum","isProp":false,"docString":"Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the sum is over `Finset.univ`. ","distance":1.9275061880317536644469100792775861918926239013671875}],["The preimage of polynomials on `[0,1]` under the pullback map by `x ‚Ü¶ (b-a) * x + a`\nis the polynomials on `[a,b]`. ",{"type":"‚àÄ (a b : ‚Ñù) (h : a < b),\n  Subalgebra.comap (ContinuousMap.compRightAlgHom ‚Ñù ‚Ñù (Homeomorph.toContinuousMap (Homeomorph.symm (iccHomeoI a b h))))\n      (polynomialFunctions unitInterval) =\n    polynomialFunctions (Set.Icc a b)","name":"polynomialFunctions.comap_compRightAlgHom_iccHomeoI","isProp":true,"docString":"The preimage of polynomials on `[0,1]` under the pullback map by `x ‚Ü¶ (b-a) * x + a`\nis the polynomials on `[a,b]`. ","distance":1.9296609802692101798271551160723902285099029541015625}],["A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas an infinite fiber.\n",{"type":"‚àÄ {Œ≤ Œ± : Type u} (f : Œ≤ ‚Üí Œ±), Cardinal.mk Œ± < Cardinal.mk Œ≤ ‚Üí Infinite Œ± ‚Üí ‚àÉ a, Infinite ‚Üë(f ‚Åª¬π' {a})","name":"Cardinal.exists_infinite_fiber","isProp":true,"docString":"A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas an infinite fiber.\n","distance":1.92997155808544551547356604714877903461456298828125}],["Given for all `a : Œ±` a finset `t a` of `Œ¥ a`, then one can define the\nfinset `Fintype.piFinset t` of all functions taking values in `t a` for all `a`. This is the\nanalogue of `Finset.pi` where the base finset is `univ` (but formally they are not the same, as\nthere is an additional condition `i ‚àà Finset.univ` in the `Finset.pi` definition). ",{"type":"{Œ± : Type u_1} ‚Üí\n  [inst : DecidableEq Œ±] ‚Üí [inst : Fintype Œ±] ‚Üí {Œ¥ : Œ± ‚Üí Type u_3} ‚Üí ((a : Œ±) ‚Üí Finset (Œ¥ a)) ‚Üí Finset ((a : Œ±) ‚Üí Œ¥ a)","name":"Fintype.piFinset","isProp":false,"docString":"Given for all `a : Œ±` a finset `t a` of `Œ¥ a`, then one can define the\nfinset `Fintype.piFinset t` of all functions taking values in `t a` for all `a`. This is the\nanalogue of `Finset.pi` where the base finset is `univ` (but formally they are not the same, as\nthere is an additional condition `i ‚àà Finset.univ` in the `Finset.pi` definition). ","distance":1.930192139649358207265095188631676137447357177734375}],["A `Sigma` with `fun i ‚Ü¶ ULift (PLift (P i))` fibers is equivalent to `{ x // P x }`.\nVariant of `sigmaPLiftEquivSubtype`.\n",{"type":"{Œ± : Type v} ‚Üí (P : Œ± ‚Üí Prop) ‚Üí (i : Œ±) √ó ULift.{u_1, 0} (PLift (P i)) ‚âÉ Subtype P","name":"Equiv.sigmaULiftPLiftEquivSubtype","isProp":false,"docString":"A `Sigma` with `fun i ‚Ü¶ ULift (PLift (P i))` fibers is equivalent to `{ x // P x }`.\nVariant of `sigmaPLiftEquivSubtype`.\n","distance":1.930198628585076736641212846734561026096343994140625}],["Outputs the list of partial sums plus one of the input list, that is\n`raise [a‚ÇÅ, a‚ÇÇ, a‚ÇÉ, ...] n = [n + a‚ÇÅ, n + a‚ÇÅ + a‚ÇÇ + 1, n + a‚ÇÅ + a‚ÇÇ + a‚ÇÉ + 2, ...]`. Adding one each\ntime ensures the elements are distinct. ",{"type":"List ‚Ñï ‚Üí ‚Ñï ‚Üí List ‚Ñï","name":"Denumerable.raise'","isProp":false,"docString":"Outputs the list of partial sums plus one of the input list, that is\n`raise [a‚ÇÅ, a‚ÇÇ, a‚ÇÉ, ...] n = [n + a‚ÇÅ, n + a‚ÇÅ + a‚ÇÇ + 1, n + a‚ÇÅ + a‚ÇÇ + a‚ÇÉ + 2, ...]`. Adding one each\ntime ensures the elements are distinct. ","distance":1.9303181611307866916149578173644840717315673828125}],["We can trivially extend a function defined on a subclass of objects (with codomain `‚Ñù‚â•0‚àû`)\nto all objects by defining it to be `‚àû` on the objects not in the class. ",{"type":"{Œ± : Type u_1} ‚Üí {P : Œ± ‚Üí Prop} ‚Üí ((s : Œ±) ‚Üí P s ‚Üí ENNReal) ‚Üí Œ± ‚Üí ENNReal","name":"MeasureTheory.extend","isProp":false,"docString":"We can trivially extend a function defined on a subclass of objects (with codomain `‚Ñù‚â•0‚àû`)\nto all objects by defining it to be `‚àû` on the objects not in the class. ","distance":1.930868270836607170082288575940765440464019775390625}]]