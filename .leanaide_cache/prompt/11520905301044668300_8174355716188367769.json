[["The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ",{"type":"{Œπ : Type u_1} ‚Üí [inst : Fintype Œπ] ‚Üí BoxIntegral.Box Œπ ‚Üí NNReal","name":"BoxIntegral.Box.distortion","isProp":false,"docString":"The distortion of a box `I` is the maximum of the ratios of the lengths of its edges.\nIt is defined as the maximum of the ratios\n`nndist I.lower I.upper / nndist (I.lower i) (I.upper i)`. ","distance":1.98266823596953134511977623333223164081573486328125}],[" For complex numbers `u` with positive real part and natural number `n`, the Beta function `Œ≤(u, n+1)` equals `fact(n) / prod(i in range (n+1), u + i)`.",{"type":"‚àÄ {u : ‚ÑÇ}, 0 < u.re ‚Üí ‚àÄ (n : ‚Ñï), u.betaIntegral (‚Üën + 1) = ‚Üën.factorial / (Finset.range (n + 1)).prod fun j => u + ‚Üëj","name":"Complex.betaIntegral_eval_nat_add_one_right","isProp":true,"docString":" For complex numbers `u` with positive real part and natural number `n`, the Beta function `Œ≤(u, n+1)` equals `fact(n) / prod(i in range (n+1), u + i)`.","distance":1.999664449294186407968254570732824504375457763671875}],["This theorem provides an explicit formula for the Beta function in the complex plane when the second argument is a positive integer. For any complex number `u` with positive real part and any natural number `n`, the Beta function of `u` and `n + 1` is equal to the factorial of `n` divided by the product of `u` plus each natural number less than `n + 1`.",{"type":"‚àÄ {u : ‚ÑÇ}, 0 < u.re ‚Üí ‚àÄ (n : ‚Ñï), u.betaIntegral (‚Üën + 1) = ‚Üën.factorial / (Finset.range (n + 1)).prod fun j => u + ‚Üëj","name":"Complex.betaIntegral_eval_nat_add_one_right","isProp":true,"docString":"This theorem provides an explicit formula for the Beta function in the complex plane when the second argument is a positive integer. For any complex number `u` with positive real part and any natural number `n`, the Beta function of `u` and `n + 1` is equal to the factorial of `n` divided by the product of `u` plus each natural number less than `n + 1`.","distance":1.995856062344979253708743271999992430210113525390625}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ‚â§ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ‚â§ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":1.982972913843372708697643247433006763458251953125}],[" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.",{"type":"‚àÄ (n : ‚Ñï), ‚Üën = ‚Üën","name":"Nat.cast_withBot","isProp":true,"docString":" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.","distance":2.002775176650331889760536796529777348041534423828125}],["This theorem states that for any types `Œ±`, `Œ≤`, and `F`, where `Œ±` and `Œ≤` are pseudo e-metric spaces, `F` is a function-like object from `Œ±` to `Œ≤`, and the dilation is defined for `F` in the context of `Œ±` and `Œ≤`, a dilation function `f` maps balls in `Œ±` to balls in `Œ≤` while scaling the radius by the `ratio f`. More specifically, for any ball centered at `x` with radius `r` in `Œ±`, its image under `f` is a ball in `Œ≤` centered at `f(x)` with radius equal to `ratio f` times `r`.",{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {F : Type u_4} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤]\n  [inst_2 : FunLike F Œ± Œ≤] [inst_3 : DilationClass F Œ± Œ≤] (f : F) (x : Œ±) (r : ENNReal),\n  Set.MapsTo (‚áëf) (EMetric.ball x r) (EMetric.ball (f x) (‚Üë(Dilation.ratio f) * r))","name":"Dilation.mapsTo_emetric_ball","isProp":true,"docString":"This theorem states that for any types `Œ±`, `Œ≤`, and `F`, where `Œ±` and `Œ≤` are pseudo e-metric spaces, `F` is a function-like object from `Œ±` to `Œ≤`, and the dilation is defined for `F` in the context of `Œ±` and `Œ≤`, a dilation function `f` maps balls in `Œ±` to balls in `Œ≤` while scaling the radius by the `ratio f`. More specifically, for any ball centered at `x` with radius `r` in `Œ±`, its image under `f` is a ball in `Œ≤` centered at `f(x)` with radius equal to `ratio f` times `r`.","distance":1.99877209381103160268366991658695042133331298828125}],["The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{ùïú : Type u_8} ‚Üí\n  {ùïú' : Type u_9} ‚Üí\n    {E : Type u_10} ‚Üí\n      [inst : NormedField ùïú'] ‚Üí\n        [inst_1 : SeminormedAddCommGroup E] ‚Üí [I : NormedSpace ùïú' E] ‚Üí NormedSpace ùïú' (RestrictScalars ùïú ùïú' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars ùïú ùïú' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.98360157476695508904640519176609814167022705078125}],["The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n",{"type":"Lean.ParserDescr","name":"commandSudoSet_option___","isProp":false,"docString":"The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n","distance":1.9837462976179354168237978228717111051082611083984375}],["`centroidWeights` gives the weights for the centroid as a\nconstant function, which is suitable when summing over the points\nwhose centroid is being taken.  This function gives the weights in a\nform suitable for summing over a larger set of points, as an indicator\nfunction that is zero outside the set whose centroid is being taken.\nIn the case of a `Fintype`, the sum may be over `univ`. ",{"type":"(k : Type u_1) ‚Üí [inst : DivisionRing k] ‚Üí {Œπ : Type u_4} ‚Üí Finset Œπ ‚Üí Œπ ‚Üí k","name":"Finset.centroidWeightsIndicator","isProp":false,"docString":"`centroidWeights` gives the weights for the centroid as a\nconstant function, which is suitable when summing over the points\nwhose centroid is being taken.  This function gives the weights in a\nform suitable for summing over a larger set of points, as an indicator\nfunction that is zero outside the set whose centroid is being taken.\nIn the case of a `Fintype`, the sum may be over `univ`. ","distance":1.986462796488657200910665778792463243007659912109375}],["The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at least as many pigeons as\nthe ceiling of the average number of pigeons across all pigeonholes.\n(\"The maximum is at least the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `Œ±` and `Œ≤` and a number `n` such that\n`card Œ≤ * n < card Œ±`, there exists an element `y : Œ≤` such that its preimage has more than `n`\nelements. ",{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤] (f : Œ± ‚Üí Œ≤) {n : ‚Ñï},\n  Fintype.card Œ≤ * n < Fintype.card Œ± ‚Üí ‚àÉ y, n < (Finset.filter (fun x => f x = y) Finset.univ).card","name":"Fintype.exists_lt_card_fiber_of_mul_lt_card","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at least as many pigeons as\nthe ceiling of the average number of pigeons across all pigeonholes.\n(\"The maximum is at least the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `Œ±` and `Œ≤` and a number `n` such that\n`card Œ≤ * n < card Œ±`, there exists an element `y : Œ≤` such that its preimage has more than `n`\nelements. ","distance":1.988083007845587335538084516883827745914459228515625}],["Return the current `maxHeartbeats`. ",{"type":"Lean.CoreM ‚Ñï","name":"getMaxHeartbeats","isProp":false,"docString":"Return the current `maxHeartbeats`. ","distance":1.98810955157943158866373778437264263629913330078125}],["Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n",{"type":"Lean.ParserDescr","name":"Mathlib.CountHeartbeats.commandCount_heartbeatsIn__","isProp":false,"docString":"Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n","distance":1.989334908314957406361145331175066530704498291015625}],["The von Neumann bornology defined by the von Neumann bounded sets.\n\nNote that this is not registered as an instance, in order to avoid diamonds with the\nmetric bornology.",{"type":"(ùïú : Type u_1) ‚Üí\n  (E : Type u_3) ‚Üí\n    [inst : NormedField ùïú] ‚Üí\n      [inst_1 : AddCommGroup E] ‚Üí\n        [inst_2 : Module ùïú E] ‚Üí [inst_3 : TopologicalSpace E] ‚Üí [inst : ContinuousSMul ùïú E] ‚Üí Bornology E","name":"Bornology.vonNBornology","isProp":false,"docString":"The von Neumann bornology defined by the von Neumann bounded sets.\n\nNote that this is not registered as an instance, in order to avoid diamonds with the\nmetric bornology.","distance":1.9898755270459915767133907138486392796039581298828125}],["The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at most as many pigeons as\nthe floor of the average number of pigeons across all pigeonholes.\n(\"The minimum is at most the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `Œ±` and `Œ≤` and a number `n` such that\n`card Œ± < card Œ≤ * n`, there exists an element `y : Œ≤` such that its preimage has less than `n`\nelements. ",{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤] (f : Œ± ‚Üí Œ≤) {n : ‚Ñï},\n  Fintype.card Œ± < Fintype.card Œ≤ * n ‚Üí ‚àÉ y, (Finset.filter (fun x => f x = y) Finset.univ).card < n","name":"Fintype.exists_card_fiber_lt_of_card_lt_mul","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at most as many pigeons as\nthe floor of the average number of pigeons across all pigeonholes.\n(\"The minimum is at most the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `Œ±` and `Œ≤` and a number `n` such that\n`card Œ± < card Œ≤ * n`, there exists an element `y : Œ≤` such that its preimage has less than `n`\nelements. ","distance":1.990788751588529859049003789550624787807464599609375}],["Returns a code for the constant function outputting a particular natural. ",{"type":"‚Ñï ‚Üí Nat.Partrec.Code","name":"Nat.Partrec.Code.const","isProp":false,"docString":"Returns a code for the constant function outputting a particular natural. ","distance":1.990943740488617219597244911710731685161590576171875}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name ‚Üí Simps.ParsedProjectionData ‚Üí List Lean.Level ‚Üí Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.99123694036976051080500837997533380985260009765625}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9929382249280624961329522193409502506256103515625}],["The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n",{"type":"Lean.ParserDescr","name":"termSudoSet_option___In_","isProp":false,"docString":"The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n","distance":1.993152012297154218600780950509943068027496337890625}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{Œ± : Type v} ‚Üí Quotient.out (Cardinal.mk Œ±) ‚âÉ Œ±","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":1.9934803427994791658051099147996865212917327880859375}],["Norm constructed from an `InnerProductSpace.Core` structure, defined to be the square root\nof the scalar product. ",{"type":"{ùïú : Type u_1} ‚Üí\n  {F : Type u_3} ‚Üí\n    [inst : IsROrC ùïú] ‚Üí [inst_1 : AddCommGroup F] ‚Üí [inst_2 : Module ùïú F] ‚Üí [c : InnerProductSpace.Core ùïú F] ‚Üí Norm F","name":"InnerProductSpace.Core.toNorm","isProp":false,"docString":"Norm constructed from an `InnerProductSpace.Core` structure, defined to be the square root\nof the scalar product. ","distance":1.993510239288088570219770190306007862091064453125}],["This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalJacobiSymNat","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ","distance":1.993826599601392413063649655668996274471282958984375}],["Reverse of `Set.codRestrict_restrict`. ",{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : Œ± ‚Üí Œ≤} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h = Set.codRestrict (Set.restrict s f) t (_ : ‚àÄ (x : ‚Üës), f ‚Üëx ‚àà t)","name":"Set.MapsTo.restrict_eq_codRestrict","isProp":true,"docString":"Reverse of `Set.codRestrict_restrict`. ","distance":1.993835631852365342098210021504200994968414306640625}],["Warning: This declaration should be used judiciously.\nPlease consider using `IsScalarTower` and/or `RestrictScalars ùïú ùïú' E` instead.\n\nThis definition allows the `RestrictScalars.normedSpace` instance to be put directly on `E`\nrather on `RestrictScalars ùïú ùïú' E`. This would be a very bad instance; both because `ùïú'` cannot be\ninferred, and because it is likely to create instance diamonds.\n",{"type":"(ùïú : Type u_5) ‚Üí\n  (ùïú' : Type u_6) ‚Üí\n    [inst : NormedField ùïú] ‚Üí\n      [inst_1 : NormedField ùïú'] ‚Üí\n        [inst_2 : NormedAlgebra ùïú ùïú'] ‚Üí\n          (E : Type u_7) ‚Üí [inst_3 : SeminormedAddCommGroup E] ‚Üí [inst_4 : NormedSpace ùïú' E] ‚Üí NormedSpace ùïú E","name":"NormedSpace.restrictScalars","isProp":false,"docString":"Warning: This declaration should be used judiciously.\nPlease consider using `IsScalarTower` and/or `RestrictScalars ùïú ùïú' E` instead.\n\nThis definition allows the `RestrictScalars.normedSpace` instance to be put directly on `E`\nrather on `RestrictScalars ùïú ùïú' E`. This would be a very bad instance; both because `ùïú'` cannot be\ninferred, and because it is likely to create instance diamonds.\n","distance":1.993930740129854939368669874966144561767578125}],["TODO: prove this in greater generality. ",{"type":"‚àÄ {m : Type u_2} {n : Type u_3} {R : Type u_5} [inst : Fintype n] [inst_1 : Fintype m] [inst_2 : LinearOrderedField R]\n  (A : Matrix m n R), Matrix.rank (Matrix.transpose A) = Matrix.rank A","name":"Matrix.rank_transpose","isProp":true,"docString":"TODO: prove this in greater generality. ","distance":1.995330127863583324909768634825013577938079833984375}]]