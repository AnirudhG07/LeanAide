[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9256236894794012126652660299441777169704437255859375}],[" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `𝕜`, a normed additive group `E` over `𝕜` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ↦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.",{"type":"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] {I : ModelWithCorners 𝕜 E H} {G : Type u_4}\n  [inst_4 : Inv G] [inst_5 : Zero G] [inst_6 : TopologicalSpace G] [inst_7 : ChartedSpace H G] [self : SmoothInv₀ I G]\n  ⦃x : G⦄, x ≠ 0 → SmoothAt I I (fun y => y⁻¹) x","name":"SmoothInv₀.smoothAt_inv₀","isProp":true,"docString":" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `𝕜`, a normed additive group `E` over `𝕜` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ↦ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.","distance":1.9778305678321872473901521516381762921810150146484375}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":1.9668001117408697719923793556517921388149261474609375}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace α → ∀ {f : α → Y}, Continuous f → ∀ {x y : α}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":1.965047472032199760150206202524714171886444091796875}],[" For any nontrivially normed field `𝕜`, normed additive commutative group `E`, normed space `E` over `𝕜`, and topological space `H`, the function `I` from `𝕜` to `E` defined in a Model With Corners `I` of types `𝕜`, `E`, and `H` is uniquely differentiable on its entire range.",{"type":"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners 𝕜 E H),\n  UniqueDiffOn 𝕜 (Set.range ↑I)","name":"ModelWithCorners.unique_diff","isProp":true,"docString":" For any nontrivially normed field `𝕜`, normed additive commutative group `E`, normed space `E` over `𝕜`, and topological space `H`, the function `I` from `𝕜` to `E` defined in a Model With Corners `I` of types `𝕜`, `E`, and `H` is uniquely differentiable on its entire range.","distance":1.98570522859132037041263174614869058132171630859375}],["This theorem, named `sign_pos`, states that for any type `α` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `α` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.",{"type":"∀ {α : Type u_1} [inst : Zero α] [inst_1 : Preorder α] [inst_2 : DecidableRel fun x x_1 => x < x_1] {a : α},\n  0 < a → SignType.sign a = 1","name":"sign_pos","isProp":true,"docString":"This theorem, named `sign_pos`, states that for any type `α` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `α` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.","distance":1.969254029338672662419185144244693219661712646484375}],["Default definition of `min`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.966106474448705565549744278541766107082366943359375}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadEnv m] → [inst : Lean.MonadError m] → Lean.Name → m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9677476903839814514896033870172686874866485595703125}],["Helper function for `#long_names` and `#long_instances`. ",{"type":"Std.HashMap Lean.Name (Array Lean.Name) → IO Unit","name":"printNameHashMap","isProp":false,"docString":"Helper function for `#long_names` and `#long_instances`. ","distance":1.96998217283716403613880174816586077213287353515625}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConcaveOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.971967616808177670151280835852958261966705322265625}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : TypeVec.Arrow Fin2.elim0 Fin2.elim0 → Sort u_1} →\n  β TypeVec.nilFun → (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) → β f","name":"TypeVec.typevecCasesNil₂","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.97199954526743059801674462505616247653961181640625}],["The set of functions on `X ⊕ Y` that are candidates distances to realize the\nminimum of the Hausdorff distances between `X` and `Y` in a coupling. ",{"type":"(X : Type u) → (Y : Type v) → [inst : MetricSpace X] → [inst : MetricSpace Y] → Set (GromovHausdorff.ProdSpaceFun X Y)","name":"GromovHausdorff.candidates","isProp":false,"docString":"The set of functions on `X ⊕ Y` that are candidates distances to realize the\nminimum of the Hausdorff distances between `X` and `Y` in a coupling. ","distance":1.972082908541775037036813955637626349925994873046875}],["Corresponds to `zero_eq_dist`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)] {x y : (i : ι) → β i},\n  0 = hammingDist x y ↔ x = y","name":"hamming_zero_eq_dist","isProp":true,"docString":"Corresponds to `zero_eq_dist`. ","distance":1.97227699923397548076309249154292047023773193359375}],["The distance between two vertices is the length of the shortest walk between them.\nIf no such walk exists, this uses the junk value of `0`. ",{"type":"{V : Type u_1} → SimpleGraph V → V → V → ℕ","name":"SimpleGraph.dist","isProp":false,"docString":"The distance between two vertices is the length of the shortest walk between them.\nIf no such walk exists, this uses the junk value of `0`. ","distance":1.973260173847533938129572561592794954776763916015625}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9733398861742903473981414208537898957729339599609375}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"∀ {d : ℤ} {a : Pell.Solution₁ d}, a = 1 ∨ a = -1 ↔ Pell.Solution₁.y a = 0","name":"Pell.Solution₁.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":1.973833326987151526310526605811901390552520751953125}],["The default cost structure, for which all operations cost `1`. ",{"type":"{α : Type u_1} → [inst : DecidableEq α] → Levenshtein.Cost α α ℕ","name":"Levenshtein.defaultCost","isProp":false,"docString":"The default cost structure, for which all operations cost `1`. ","distance":1.9743175508611103818878973470418713986873626708984375}],["cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : (v : TypeVec.{u_2} 0) → (v' : TypeVec.{u_3} 0) → TypeVec.Arrow v v' → Sort u_1} →\n  β Fin2.elim0 Fin2.elim0 TypeVec.nilFun →\n    (v : TypeVec.{u_2} 0) → (v' : TypeVec.{u_3} 0) → (fs : TypeVec.Arrow v v') → β v v' fs","name":"TypeVec.typevecCasesNil₃","isProp":false,"docString":"cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9748788850007226169935847792658023536205291748046875}],["Attribute for identifying `positivity` extensions. ",{"type":"Lean.ParserDescr","name":"positivity","isProp":false,"docString":"Attribute for identifying `positivity` extensions. ","distance":1.9756297249861329845543878036551177501678466796875}],["Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. ",{"type":"{K : semiOutParam (Type u_1)} → [self : IsROrC K] → K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. ","distance":1.9759738048818922262483965823776088654994964599609375}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {K : Set F},\n  Convex ℝ K → ∀ {u v : F}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9761483728488073996487628392060287296772003173828125}],["A tactic that solves `0 ≤ ↑x`, `0 ≤ 1 - ↑x`, `↑x ≤ 1`, and `1 - ↑x ≤ 1` for `x : I`. ",{"type":"Lean.ParserDescr","name":"Tactic.Interactive.tacticUnit_interval","isProp":false,"docString":"A tactic that solves `0 ≤ ↑x`, `0 ≤ 1 - ↑x`, `↑x ≤ 1`, and `1 - ↑x ≤ 1` for `x : I`. ","distance":1.9765411783015129909557572318590246140956878662109375}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9771998634814933470948972171754576265811920166015625}],["Corresponds to `dist_pos`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)] {x y : (i : ι) → β i},\n  0 < hammingDist x y ↔ x ≠ y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.9778946333573805826944180807913653552532196044921875}]]