[["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.8977858623515186931030029882094822824001312255859375}],[" For types `α` and `β` that are primitive recursively encodable, the first projection function `Prod.fst` on pairs of elements from types `α` and `β` is a primitive recursive function.",{"type":"∀ {α : Type u_3} {β : Type u_4} [inst : Primcodable α] [inst_1 : Primcodable β], Primrec Prod.fst","name":"Primrec.fst","isProp":true,"docString":" For types `α` and `β` that are primitive recursively encodable, the first projection function `Prod.fst` on pairs of elements from types `α` and `β` is a primitive recursive function.","distance":1.9127050967257372970919959698221646249294281005859375}],["The theorem `Primrec.fst` states that for all types `α` and `β` which have a primitive recursive encoding (i.e., they are instances of the `Primcodable` class), the first projection function `Prod.fst` is a primitive recursive function. In other words, given a pair of elements `(a, b)` where `a` is from type `α` and `b` is from type `β`, the function that retrieves the first element `a` from the pair is a primitive recursive function.",{"type":"∀ {α : Type u_3} {β : Type u_4} [inst : Primcodable α] [inst_1 : Primcodable β], Primrec Prod.fst","name":"Primrec.fst","isProp":true,"docString":"The theorem `Primrec.fst` states that for all types `α` and `β` which have a primitive recursive encoding (i.e., they are instances of the `Primcodable` class), the first projection function `Prod.fst` is a primitive recursive function. In other words, given a pair of elements `(a, b)` where `a` is from type `α` and `b` is from type `β`, the function that retrieves the first element `a` from the pair is a primitive recursive function.","distance":1.9121309516299211939127644654945470392704010009765625}],[" For any natural number `n` and prime number `p`, the multiplicity of `p` in the factorial of `p * n` is one more than the multiplicity of `p` in the factorial of `n`.",{"value":null,"type":"∀ {n p : ℕ}, p.Prime → multiplicity p (p * n).factorial = multiplicity p n.factorial + ↑n","statement":"theorem Nat.Prime.multiplicity_factorial_mul :\n    ∀ {n p : ℕ}, p.Prime → multiplicity p (p * n).factorial = multiplicity p n.factorial + ↑n := by sorry","name":"Nat.Prime.multiplicity_factorial_mul","isProp":true,"docString":"The multiplicity of `p` in `(p * n)!` is `n` more than that of `n!`. ","description":"This theorem states that for any natural numbers `n` and `p`, if `p` is a prime number, then the multiplicity of `p` in the factorial of `p * n` is equal to the multiplicity of `p` in the factorial of `n` plus `n`. Here, the multiplicity of `p` in a number is the highest power of `p` that divides the number. In other words, it counts the number of times `p` appears in the prime factorization of the number. So, this theorem means that if you multiply `n` by a prime number `p` and then take the factorial, the prime `p` will appear `n` more times in the prime factorization than if you just took the factorial of `n`.","concise-description":" For any natural number `n` and prime number `p`, the multiplicity of `p` in the factorial of `p * n` is one more than the multiplicity of `p` in the factorial of `n`."}],["A quick way to convert a `PreEnvelGroupRel'` to a `PreEnvelGroupRel`.\n",{"type":"∀ {R : Type u} [inst : Rack R] {a b : Rack.PreEnvelGroup R}, Rack.PreEnvelGroupRel' R a b → Rack.PreEnvelGroupRel R a b","name":"Rack.PreEnvelGroupRel'.rel","isProp":true,"docString":"A quick way to convert a `PreEnvelGroupRel'` to a `PreEnvelGroupRel`.\n","distance":1.903704458810192789997017825953662395477294921875}],[" For any `Concept` instance `self` with relation `r : α → β → Prop`, the intent closure of `self.toProd.1` with respect to `r` equals `self.toProd.2`.",{"type":"∀ {α : Type u_2} {β : Type u_3} {r : α → β → Prop} (self : Concept α β r), intentClosure r self.toProd.1 = self.toProd.2","name":"Concept.closure_fst","isProp":true,"docString":" For any `Concept` instance `self` with relation `r : α → β → Prop`, the intent closure of `self.toProd.1` with respect to `r` equals `self.toProd.2`.","distance":1.9153147052076120449015661506564356386661529541015625}],["The theorem `PrimrecRel.comp` states that for any types `α`, `β`, and `γ`, if all three are primitive encodable (as denoted by `Primcodable α`, `Primcodable β`, and `Primcodable γ`), and if we have a primitive recursive relation `R` between `β` and `γ` (with `R : β → γ → Prop`), and the relation `R` is decidable for all `a : β` and `b : γ`, then given any two functions `f : α → β` and `g : α → γ` which are both primitive recursive, the function that maps an element of type `α` to the boolean value of the relationship `R` applied to `(f a, g a)` is also primitive recursive. This implies that the composition of primitive recursive functions and relations retains the property of being primitive recursive.",{"type":"∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable β] [inst_2 : Primcodable γ]\n  {R : β → γ → Prop} [inst_3 : (a : β) → (b : γ) → Decidable (R a b)] {f : α → β} {g : α → γ},\n  PrimrecRel R → Primrec f → Primrec g → PrimrecPred fun a => R (f a) (g a)","name":"PrimrecRel.comp","isProp":true,"docString":"The theorem `PrimrecRel.comp` states that for any types `α`, `β`, and `γ`, if all three are primitive encodable (as denoted by `Primcodable α`, `Primcodable β`, and `Primcodable γ`), and if we have a primitive recursive relation `R` between `β` and `γ` (with `R : β → γ → Prop`), and the relation `R` is decidable for all `a : β` and `b : γ`, then given any two functions `f : α → β` and `g : α → γ` which are both primitive recursive, the function that maps an element of type `α` to the boolean value of the relationship `R` applied to `(f a, g a)` is also primitive recursive. This implies that the composition of primitive recursive functions and relations retains the property of being primitive recursive.","distance":1.921564531917688167794722176040522754192352294921875}],[" For any prime number `p` and natural numbers `n` and `b` with `log_p n < b`, the highest power of `p` dividing `n!` equals the sum of the quotients `\\frac{n}{p^i}` for `i` in the range `1` to `b`.",{"value":null,"type":"∀ {p : ℕ}, p.Prime → ∀ {n b : ℕ}, p.log n < b → multiplicity p n.factorial = ↑((Finset.Ico 1 b).sum fun i => n / p ^ i)","statement":"theorem Nat.Prime.multiplicity_factorial :\n    ∀ {p : ℕ},\n      p.Prime → ∀ {n b : ℕ}, p.log n < b → multiplicity p n.factorial = ↑((Finset.Ico 1 b).sum fun i => n / p ^ i) :=\n  by sorry","name":"Nat.Prime.multiplicity_factorial","isProp":true,"docString":"**Legendre's Theorem**\n\nThe multiplicity of a prime in `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. ","description":"**Legendre's Theorem**\n\nFor any prime number `p` and natural numbers `n` and `b`, where the logarithm of `n` in base `p` is less than `b`, the highest power of `p` that divides `n!` (the factorial of `n`) is equal to the sum of the quotients of `n` divided by `p` to the power `i`, where `i` ranges over the elements of the set of natural numbers between `1` and `b` (exclusive). Here `b` is any bound greater than `log p n`.","concise-description":" For any prime number `p` and natural numbers `n` and `b` with `log_p n < b`, the highest power of `p` dividing `n!` equals the sum of the quotients `\\frac{n}{p^i}` for `i` in the range `1` to `b`."}],["Polynomial representation of the projection functor ",{"type":"{n : ℕ} → Fin2 n → MvPFunctor.{u} n","name":"MvQPF.Prj.P","isProp":false,"docString":"Polynomial representation of the projection functor ","distance":1.9115232450480841297490997021668590605258941650390625}],[" If types `α` and `β` are Primcodable, then the function `Prod.fst` that extracts the first element from a pair of type `α × β` is a computable function.",{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : Primcodable α] [inst_1 : Primcodable β], Computable Prod.fst","name":"Computable.fst","isProp":true,"docString":" If types `α` and `β` are Primcodable, then the function `Prod.fst` that extracts the first element from a pair of type `α × β` is a computable function.","distance":1.9169588068165548389032437626156024634838104248046875}],["The theorem `Primrec₂.right` states that for any two types `α` and `β` that have a primitive recursive encoding (`Primcodable`), the second projection function (which takes a pair `(x, b)` and returns `b`) is a binary primitive recursive function. In other words, the function that retrieves the second component of a pair is primitive recursive.",{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : Primcodable α] [inst_1 : Primcodable β], Primrec₂ fun x b => b","name":"Primrec₂.right","isProp":true,"docString":"The theorem `Primrec₂.right` states that for any two types `α` and `β` that have a primitive recursive encoding (`Primcodable`), the second projection function (which takes a pair `(x, b)` and returns `b`) is a binary primitive recursive function. In other words, the function that retrieves the second component of a pair is primitive recursive.","distance":1.9274618602400550582132154886494390666484832763671875}],["Prefunctors between two `SingleObj` quivers correspond to functions between the corresponding\narrows types.\n",{"type":"{α : Type u_1} → {β : Type u_2} → (α → β) ≃ Quiver.SingleObj α ⥤q Quiver.SingleObj β","name":"Quiver.SingleObj.toPrefunctor","isProp":false,"docString":"Prefunctors between two `SingleObj` quivers correspond to functions between the corresponding\narrows types.\n","distance":1.91235876071837918033224923419766128063201904296875}],[" For any nonempty type `β`, the first projection function `Prod.fst` of the product type `α × β` is a surjection from `α`.",{"type":"∀ {α : Type u_1} {β : Type u_2} [h : Nonempty β], Function.Surjective Prod.fst","name":"Prod.fst_surjective","isProp":true,"docString":" For any nonempty type `β`, the first projection function `Prod.fst` of the product type `α × β` is a surjection from `α`.","distance":1.91908217249298562734338702284730970859527587890625}],["The theorem `Primrec.dom_bool` states that for any type `α`, which has a `Primcodable` instance, and for any function `f` from `Bool` to `α`, the function `f` is primitive recursive. In other words, whenever we have a function that takes a boolean value and produces an output in some type `α`, that function can be described using only the basic constructs of primitive recursion.",{"type":"∀ {α : Type u_1} [inst : Primcodable α] (f : Bool → α), Primrec f","name":"Primrec.dom_bool","isProp":true,"docString":"The theorem `Primrec.dom_bool` states that for any type `α`, which has a `Primcodable` instance, and for any function `f` from `Bool` to `α`, the function `f` is primitive recursive. In other words, whenever we have a function that takes a boolean value and produces an output in some type `α`, that function can be described using only the basic constructs of primitive recursion.","distance":1.928771924189663256044013905921019613742828369140625}],["A prefunctor induces a map of `Quiver.Star` at every vertex. ",{"type":"{U : Type u_1} →\n  [inst : Quiver U] →\n    {V : Type u_2} → [inst_1 : Quiver V] → (φ : U ⥤q V) → (u : U) → Quiver.Star u → Quiver.Star (φ.obj u)","name":"Prefunctor.star","isProp":false,"docString":"A prefunctor induces a map of `Quiver.Star` at every vertex. ","distance":1.916551824591621322468881771783344447612762451171875}],["A functor `F` preserves finite biproducts if it preserves biproducts of shape `J` whenever\n`J` is a fintype. ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n          [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] →\n            {F : CategoryTheory.Functor C D} →\n              [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms F] →\n                [self : CategoryTheory.Limits.PreservesFiniteBiproducts F] →\n                  {J : Type} → [inst_5 : Fintype J] → CategoryTheory.Limits.PreservesBiproductsOfShape J F","name":"CategoryTheory.Limits.PreservesFiniteBiproducts.preserves","isProp":false,"docString":"A functor `F` preserves finite biproducts if it preserves biproducts of shape `J` whenever\n`J` is a fintype. ","distance":1.9171568816153896630538611134397797286510467529296875}],["`centroidWeights` gives the weights for the centroid as a\nconstant function, which is suitable when summing over the points\nwhose centroid is being taken.  This function gives the weights in a\nform suitable for summing over a larger set of points, as an indicator\nfunction that is zero outside the set whose centroid is being taken.\nIn the case of a `Fintype`, the sum may be over `univ`. ",{"type":"(k : Type u_1) → [inst : DivisionRing k] → {ι : Type u_4} → Finset ι → ι → k","name":"Finset.centroidWeightsIndicator","isProp":false,"docString":"`centroidWeights` gives the weights for the centroid as a\nconstant function, which is suitable when summing over the points\nwhose centroid is being taken.  This function gives the weights in a\nform suitable for summing over a larger set of points, as an indicator\nfunction that is zero outside the set whose centroid is being taken.\nIn the case of a `Fintype`, the sum may be over `univ`. ","distance":1.91905697726037782757657623733393847942352294921875}],["The natural isomorphism expressing that functors `Karoubi C ⥤ Karoubi D` obtained\nusing `functorExtension₁` actually extends the original functors `C ⥤ Karoubi D`. ",{"type":"(C : Type u_1) →\n  (D : Type u_2) →\n    [inst : CategoryTheory.Category.{u_4, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_5, u_2} D] →\n        CategoryTheory.Functor.comp (CategoryTheory.Idempotents.functorExtension₁ C D)\n            ((CategoryTheory.whiskeringLeft C (CategoryTheory.Idempotents.Karoubi C)\n                  (CategoryTheory.Idempotents.Karoubi D)).obj\n              (CategoryTheory.Idempotents.toKaroubi C)) ≅\n          CategoryTheory.Functor.id (CategoryTheory.Functor C (CategoryTheory.Idempotents.Karoubi D))","name":"CategoryTheory.Idempotents.functorExtension₁CompWhiskeringLeftToKaroubiIso","isProp":false,"docString":"The natural isomorphism expressing that functors `Karoubi C ⥤ Karoubi D` obtained\nusing `functorExtension₁` actually extends the original functors `C ⥤ Karoubi D`. ","distance":1.9212722681730334262084625152056105434894561767578125}]]