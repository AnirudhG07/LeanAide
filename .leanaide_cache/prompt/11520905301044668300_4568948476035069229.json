[["If the neutral element of a group is not isolated, then a Haar measure on this group has\nno atoms.\n\nThe additive version of this instance applies in particular to show that an additive Haar\nmeasure on a nontrivial finite-dimensional real vector space has no atom. ",{"type":"∀ {G : Type u_2} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : TopologicalSpace G]\n  [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G] [inst_5 : T1Space G] [inst_6 : WeaklyLocallyCompactSpace G]\n  [inst_7 : Filter.NeBot (nhdsWithin 1 {1}ᶜ)] (μ : MeasureTheory.Measure G)\n  [inst_8 : MeasureTheory.Measure.IsHaarMeasure μ], MeasureTheory.NoAtoms μ","name":"MeasureTheory.Measure.IsHaarMeasure.noAtoms","isProp":true,"docString":"If the neutral element of a group is not isolated, then a Haar measure on this group has\nno atoms.\n\nThe additive version of this instance applies in particular to show that an additive Haar\nmeasure on a nontrivial finite-dimensional real vector space has no atom. ","distance":1.973376228511878327509521113825030624866485595703125}],[" For any `AddGroup` type `α`, any `AddAction` instance of `α` on type `β`, and any `α` element `a`, `a +ᵥ Set.univ = Set.univ` in type `β`.",{"type":"∀ {α : Type u_2} {β : Type u_3} [inst : AddGroup α] [inst_1 : AddAction α β] {a : α}, a +ᵥ Set.univ = Set.univ","name":"Set.vadd_set_univ","isProp":true,"docString":" For any `AddGroup` type `α`, any `AddAction` instance of `α` on type `β`, and any `α` element `a`, `a +ᵥ Set.univ = Set.univ` in type `β`.","distance":1.9958976308720501879889752672170288860797882080078125}],["This theorem, `neg_add_cancel_right`, states that for any type `G` that has an `AddGroup` structure (i.e., an additive group), for any two elements `a` and `b` from `G`, if we add the negation of `b` to `a` and then add `b`, we get `a` back. In mathematical terms, it states that for all `a` and `b` in the additive group `G`, the equation `a + -b + b = a` holds true. This is a basic property of additive groups, reflecting the fact that adding an element and its negation results in a neutral element of the group (usually denoted as zero), essentially canceling each other out.",{"type":"∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + -b + b = a","name":"neg_add_cancel_right","isProp":true,"docString":"This theorem, `neg_add_cancel_right`, states that for any type `G` that has an `AddGroup` structure (i.e., an additive group), for any two elements `a` and `b` from `G`, if we add the negation of `b` to `a` and then add `b`, we get `a` back. In mathematical terms, it states that for all `a` and `b` in the additive group `G`, the equation `a + -b + b = a` holds true. This is a basic property of additive groups, reflecting the fact that adding an element and its negation results in a neutral element of the group (usually denoted as zero), essentially canceling each other out.","distance":1.9971014365816646130014078153180889785289764404296875}],["Makes a `Language.empty.Hom` out of any function. ",{"type":"{M : Type w} → {N : Type w'} → (M → N) → FirstOrder.Language.Hom FirstOrder.Language.empty M N","name":"Function.emptyHom","isProp":false,"docString":"Makes a `Language.empty.Hom` out of any function. ","distance":1.985097180970624375362376667908392846584320068359375}],[" Given functions `f : α -> β`, `g : α -> γ`, `e' : β -> γ`, and `b : β`, if it is decidable which `a : α` satisfies `f a = b`, then `Function.extend f g e' b` is `g (the a | exists a, f a = b)` or `e' b` otherwise.",{"type":"∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β) (g : α → γ) (e' : β → γ) (b : β)\n  [inst : Decidable (∃ a, f a = b)],\n  Function.extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b","name":"Function.extend_def","isProp":true,"docString":" Given functions `f : α -> β`, `g : α -> γ`, `e' : β -> γ`, and `b : β`, if it is decidable which `a : α` satisfies `f a = b`, then `Function.extend f g e' b` is `g (the a | exists a, f a = b)` or `e' b` otherwise.","distance":2.00947538813061754581212881021201610565185546875}],["The theorem `Nat.Prime.ne_one` states that for every natural number `p`, if `p` is a prime number, then `p` cannot be equal to 1. In other words, no prime number can be 1. This is consistent with the definition of a prime number as a natural number at least 2 whose only divisors are itself and 1.",{"type":"∀ {p : ℕ}, p.Prime → p ≠ 1","name":"Nat.Prime.ne_one","isProp":true,"docString":"The theorem `Nat.Prime.ne_one` states that for every natural number `p`, if `p` is a prime number, then `p` cannot be equal to 1. In other words, no prime number can be 1. This is consistent with the definition of a prime number as a natural number at least 2 whose only divisors are itself and 1.","distance":2.00033694895254665624406698043458163738250732421875}],["Print (at most) 10 samples of a given type to stdout for debugging.\n",{"type":"{t : Type} → [inst : Repr t] → SlimCheck.Gen t → IO PUnit.{1}","name":"SlimCheck.printSamples","isProp":false,"docString":"Print (at most) 10 samples of a given type to stdout for debugging.\n","distance":1.9894674302648065467025162433856166899204254150390625}],["A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n",{"type":"(n m : ℕ) → Decidable (n = m)","name":"Nat.decEq","isProp":false,"docString":"A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n","distance":1.990078335889040150874507162370719015598297119140625}],["Strong recursor for `Nat`\n",{"type":"{motive : ℕ → Sort u_1} → ((n : ℕ) → ((m : ℕ) → m < n → motive m) → motive n) → (t : ℕ) → motive t","name":"Nat.strongRec","isProp":false,"docString":"Strong recursor for `Nat`\n","distance":1.99047858589946979890328293549828231334686279296875}],["A list enumerating every element of the type, which are all zero-argument constructors. (Generated by the `Fintype` deriving handler.)",{"type":"List Turing.PartrecToTM2.Γ'","name":"Turing.PartrecToTM2.Γ'.enumList","isProp":false,"docString":"A list enumerating every element of the type, which are all zero-argument constructors. (Generated by the `Fintype` deriving handler.)","distance":1.9905309449352726058890539206913672387599945068359375}],["The diagram of powers of `J` is initial in the diagram of all ideals with\nradical containing `J`. This uses noetherianness. ",{"type":"∀ {R : Type u} [inst : CommRing R] {J : Ideal R} [hR : IsNoetherian R R],\n  CategoryTheory.Functor.Initial (localCohomology.idealPowersToSelfLERadical J)","name":"localCohomology.ideal_powers_initial","isProp":true,"docString":"The diagram of powers of `J` is initial in the diagram of all ideals with\nradical containing `J`. This uses noetherianness. ","distance":1.9913927379028526498672135858214460313320159912109375}],["Lists all instances with a long name beginning with `inst`,\ngathered according to the module they are defined in.\nThis is useful for finding automatically named instances with absurd names.\n\nUse as `#long_names` or `#long_names 100` to specify the length.\n",{"type":"Lean.ParserDescr","name":"«command#long_instances_»","isProp":false,"docString":"Lists all instances with a long name beginning with `inst`,\ngathered according to the module they are defined in.\nThis is useful for finding automatically named instances with absurd names.\n\nUse as `#long_names` or `#long_names 100` to specify the length.\n","distance":1.994079058488300137952364821103401482105255126953125}],["Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that `P` is symmetric and `P x y` implies\n`P (-x) y` for all `x`, `y`. ",{"type":"∀ {P : EReal → EReal → Prop},\n  Symmetric P →\n    (∀ {x y : EReal}, P x y → P (-x) y) →\n      P ⊤ ⊤ → (∀ (x : ℝ), 0 < x → P ⊤ ↑x) → P ⊤ 0 → (∀ (x y : ℝ), P ↑x ↑y) → ∀ (x y : EReal), P x y","name":"EReal.induction₂_symm_neg","isProp":true,"docString":"Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that `P` is symmetric and `P x y` implies\n`P (-x) y` for all `x`, `y`. ","distance":1.9945194453140697721238439044100232422351837158203125}],["An element of a group acting on a Type is regular. This relies on the availability\nof the inverse given by groups, since there is no `LeftCancelSMul` typeclass. ",{"type":"∀ {R : Type u_1} {G : Type u_4} [inst : Group G] [inst_1 : MulAction G R] (g : G), IsSMulRegular R g","name":"isSMulRegular_of_group","isProp":true,"docString":"An element of a group acting on a Type is regular. This relies on the availability\nof the inverse given by groups, since there is no `LeftCancelSMul` typeclass. ","distance":1.994605866904033408815166694694198668003082275390625}],["Specialized destructor on `WPath` ",{"type":"{n : ℕ} →\n  (P : MvPFunctor.{u} (n + 1)) →\n    {α : TypeVec.{u_1} n} →\n      {a : P.A} →\n        {f : PFunctor.B (MvPFunctor.last P) a → PFunctor.W (MvPFunctor.last P)} →\n          TypeVec.Arrow (MvPFunctor.B (MvPFunctor.drop P) a) α →\n            ((j : PFunctor.B (MvPFunctor.last P) a) → TypeVec.Arrow (MvPFunctor.WPath P (f j)) α) →\n              TypeVec.Arrow (MvPFunctor.WPath P (WType.mk a f)) α","name":"MvPFunctor.wPathCasesOn","isProp":false,"docString":"Specialized destructor on `WPath` ","distance":1.9950728826226777901098330403328873217105865478515625}],["Define an `AddGroup` structure on a Type by proving `∀ a, 0 + a = a` and\n`∀ a, -a + a = 0`.\nNote that this uses the default definitions for `nsmul`, `zsmul` and `sub`.\nSee note [reducible non-instances].",{"type":"{G : Type u} →\n  [inst : Add G] →\n    [inst_1 : Neg G] →\n      [inst_2 : Zero G] →\n        (∀ (a b c : G), a + b + c = a + (b + c)) → (∀ (a : G), 0 + a = a) → (∀ (a : G), -a + a = 0) → AddGroup G","name":"AddGroup.ofLeftAxioms","isProp":false,"docString":"Define an `AddGroup` structure on a Type by proving `∀ a, 0 + a = a` and\n`∀ a, -a + a = 0`.\nNote that this uses the default definitions for `nsmul`, `zsmul` and `sub`.\nSee note [reducible non-instances].","distance":1.9950944160105896774126676973537541925907135009765625}],["Makes a `Language.empty.Equiv` out of any function. ",{"type":"{M : Type w} → {N : Type w'} → M ≃ N → FirstOrder.Language.Equiv FirstOrder.Language.empty M N","name":"Equiv.empty","isProp":false,"docString":"Makes a `Language.empty.Equiv` out of any function. ","distance":1.995115282020361036074973526410758495330810546875}],["If the zero element of an additive group is not isolated, then an additive Haar measure on this\ngroup has no atoms.\n\nThis applies in particular to show that an additive Haar measure on a nontrivial\nfinite-dimensional real vector space has no atom.",{"type":"∀ {G : Type u_2} [inst : MeasurableSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalSpace G]\n  [inst_3 : TopologicalAddGroup G] [inst_4 : BorelSpace G] [inst_5 : T1Space G] [inst_6 : WeaklyLocallyCompactSpace G]\n  [inst_7 : Filter.NeBot (nhdsWithin 0 {0}ᶜ)] (μ : MeasureTheory.Measure G)\n  [inst_8 : MeasureTheory.Measure.IsAddHaarMeasure μ], MeasureTheory.NoAtoms μ","name":"MeasureTheory.Measure.IsAddHaarMeasure.noAtoms","isProp":true,"docString":"If the zero element of an additive group is not isolated, then an additive Haar measure on this\ngroup has no atoms.\n\nThis applies in particular to show that an additive Haar measure on a nontrivial\nfinite-dimensional real vector space has no atom.","distance":1.9951208024443254362978450444643385708332061767578125}],["Save an object to disk.\nIf you need to write multiple objects from within a single declaration,\nyou will need to provide a unique `key` for each.\n",{"type":"{α : Type} → System.FilePath → α → autoParam Lean.Name _auto✝ → IO Unit","name":"pickle","isProp":false,"docString":"Save an object to disk.\nIf you need to write multiple objects from within a single declaration,\nyou will need to provide a unique `key` for each.\n","distance":1.9954456680571965865311767629464156925678253173828125}],["A constructor for languages with only constants, unary and binary functions, and\nunary and binary relations. ",{"type":"Type u → Type u → Type u → Type v → Type v → FirstOrder.Language","name":"FirstOrder.Language.mk₂","isProp":false,"docString":"A constructor for languages with only constants, unary and binary functions, and\nunary and binary relations. ","distance":1.995708352177889555179035596665926277637481689453125}],["The chosen section of a split epimorphism.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] → {X Y : C} → (f : X ⟶ Y) → [hf : CategoryTheory.IsSplitEpi f] → Y ⟶ X","name":"CategoryTheory.section_","isProp":false,"docString":"The chosen section of a split epimorphism.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n","distance":1.9957578200963854708760436551528982818126678466796875}],["Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that `P x y` implies `P (-x) y` for all\n`x`, `y`. ",{"type":"∀ {P : EReal → EReal → Prop},\n  (∀ {x y : EReal}, P x y → P (-x) y) →\n    P ⊤ ⊤ →\n      (∀ (x : ℝ), 0 < x → P ⊤ ↑x) →\n        P ⊤ 0 →\n          (∀ x < 0, P ⊤ ↑x) →\n            P ⊤ ⊥ →\n              P 0 ⊤ →\n                P 0 ⊥ →\n                  (∀ (x : ℝ), 0 < x → P ↑x ⊤) →\n                    (∀ (x : ℝ), 0 < x → P ↑x ⊥) → (∀ (x y : ℝ), P ↑x ↑y) → ∀ (x y : EReal), P x y","name":"EReal.induction₂_neg_left","isProp":true,"docString":"Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that `P x y` implies `P (-x) y` for all\n`x`, `y`. ","distance":1.9959898768163888416182771834428422152996063232421875}],["Generate a random natural number in the interval [lo, hi]. ",{"type":"{gen : Type u} → [inst : RandomGen gen] → gen → ℕ → ℕ → ℕ × gen","name":"randNat","isProp":false,"docString":"Generate a random natural number in the interval [lo, hi]. ","distance":1.997100660179862874343825751566328108310699462890625}],["Given a set of vertex pairs, remove all of the corresponding edges from the\ngraph's edge set, if present.\n\nSee also: `SimpleGraph.Subgraph.deleteEdges`. ",{"type":"{V : Type u} → SimpleGraph V → Set (Sym2 V) → SimpleGraph V","name":"SimpleGraph.deleteEdges","isProp":false,"docString":"Given a set of vertex pairs, remove all of the corresponding edges from the\ngraph's edge set, if present.\n\nSee also: `SimpleGraph.Subgraph.deleteEdges`. ","distance":1.9975548758077208422179182889522053301334381103515625}]]