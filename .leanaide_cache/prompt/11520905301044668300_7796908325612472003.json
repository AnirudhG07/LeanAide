[["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {K : Set F},\n  Convex ℝ K → ∀ {u v : F}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.909769126716095666296268973383121192455291748046875}],[" For any inner product space `(E, ⟨·, ·⟩)` over commutative scalar type `𝕜`, ⟨0, x⟩ = 0 for all `x ∈ E`.",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x : E), ⟪0, x⟫_𝕜 = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, ⟨·, ·⟩)` over commutative scalar type `𝕜`, ⟨0, x⟩ = 0 for all `x ∈ E`.","distance":1.9594785805486003571473929696367122232913970947265625}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":1.9437110638573911192139576087356545031070709228515625}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9240327679744495537050852362881414592266082763671875}],[" For any topological space `α` and pseudo metric space `β` with defined zero, the constant function `0 : α → β` equals the zero function.",{"type":"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Zero β], ⇑0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":" For any topological space `α` and pseudo metric space `β` with defined zero, the constant function `0 : α → β` equals the zero function.","distance":1.9611639994167411327197214632178656756877899169921875}],["The theorem `StrictConvexOn.eq_of_isMinOn` states that for any strictly convex function `f` from a set `s` in a linearly ordered field `𝕜`, if the function `f` has a global minimum on `s` at two different points `x` and `y`, then `x` and `y` must be the same. This means a strictly convex function can have at most one global minimum.",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : LinearOrderedField 𝕜] [inst_1 : OrderedAddCommMonoid β]\n  [inst_2 : AddCommMonoid E] [inst_3 : SMul 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β] {f : E → β}\n  {s : Set E} {x y : E}, StrictConvexOn 𝕜 s f → IsMinOn f s x → IsMinOn f s y → x ∈ s → y ∈ s → x = y","name":"StrictConvexOn.eq_of_isMinOn","isProp":true,"docString":"The theorem `StrictConvexOn.eq_of_isMinOn` states that for any strictly convex function `f` from a set `s` in a linearly ordered field `𝕜`, if the function `f` has a global minimum on `s` at two different points `x` and `y`, then `x` and `y` must be the same. This means a strictly convex function can have at most one global minimum.","distance":1.9446142925759877240210471427417360246181488037109375}],["Default definition of `min`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9279363427520086471389504367834888398647308349609375}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Zero M₁] →\n      [inst_1 : Neg M₁] →\n        [inst_2 : NegZeroClass M₂] →\n          (f : M₁ → M₂) → Function.Injective f → f 0 = 0 → (∀ (x : M₁), f (-x) = -f x) → NegZeroClass M₁","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":1.93059987382818309953336211037822067737579345703125}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9315535885394339299381272212485782802104949951171875}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : TypeVec.Arrow Fin2.elim0 Fin2.elim0 → Sort u_1} →\n  β TypeVec.nilFun → (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) → β f","name":"TypeVec.typevecCasesNil₂","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9339708110336035762344408794888295233249664306640625}],["The stalk at `x` of a `PresheafedSpace`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasColimits C] → (X : AlgebraicGeometry.PresheafedSpace C) → ↑↑X → C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"docString":"The stalk at `x` of a `PresheafedSpace`.\n","distance":1.9408381856709187029963459281134419143199920654296875}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name → Simps.ParsedProjectionData → List Lean.Level → Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.9414730403314550688520512267132289707660675048828125}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConcaveOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.942121259049347958836051475373096764087677001953125}],["Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : ℕ → Type u_2} → ((n : ℕ) → E n) → Set ((n : ℕ) → E n) → ℕ","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":1.9439329940187495271430861976114101707935333251953125}],["cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : (v : TypeVec.{u_2} 0) → (v' : TypeVec.{u_3} 0) → TypeVec.Arrow v v' → Sort u_1} →\n  β Fin2.elim0 Fin2.elim0 TypeVec.nilFun →\n    (v : TypeVec.{u_2} 0) → (v' : TypeVec.{u_3} 0) → (fs : TypeVec.Arrow v v') → β v v' fs","name":"TypeVec.typevecCasesNil₃","isProp":false,"docString":"cases distinction for an arrow in the category of 0-length type vectors ","distance":1.94436817788556748354267256218008697032928466796875}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module 𝕜 β] [inst_3 : OrderedSMul 𝕜 β] {f : 𝕜 → β} {x y z : 𝕜},\n  ConcaveOn 𝕜 (Set.Icc x y) f → z ∈ Set.Icc x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9444435627078926476229980835341848433017730712890625}],["With the optimal candidate, construct a premetric space structure on `X ⊕ Y`, on which the\npredistance is given by the candidate. Then, we will identify points at `0` predistance\nto obtain a genuine metric space. ",{"type":"(X : Type u) →\n  (Y : Type v) →\n    [inst : MetricSpace X] →\n      [inst : CompactSpace X] →\n        [inst : Nonempty X] →\n          [inst : MetricSpace Y] → [inst : CompactSpace Y] → [inst : Nonempty Y] → PseudoMetricSpace (X ⊕ Y)","name":"GromovHausdorff.premetricOptimalGHDist","isProp":false,"docString":"With the optimal candidate, construct a premetric space structure on `X ⊕ Y`, on which the\npredistance is given by the candidate. Then, we will identify points at `0` predistance\nto obtain a genuine metric space. ","distance":1.94481992309607232272128385375253856182098388671875}],["Corresponds to `dist_pos`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)] {x y : (i : ι) → β i},\n  0 < hammingDist x y ↔ x ≠ y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.9467469248158957295657955910428427159786224365234375}],["A type endowed with `0` and `+` is an `AddZeroClass`, if it admits an\ninjective map that preserves `0` and `+` to an `AddZeroClass`.",{"type":"{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₁] →\n      [inst_1 : Zero M₁] →\n        [inst_2 : AddZeroClass M₂] →\n          (f : M₁ → M₂) → Function.Injective f → f 0 = 0 → (∀ (x y : M₁), f (x + y) = f x + f y) → AddZeroClass M₁","name":"Function.Injective.addZeroClass","isProp":false,"docString":"A type endowed with `0` and `+` is an `AddZeroClass`, if it admits an\ninjective map that preserves `0` and `+` to an `AddZeroClass`.","distance":1.9470592777505004722371495518018491566181182861328125}],["Corresponds to `dist_zero_right`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)]\n  [inst_2 : (i : ι) → Zero (β i)] (x : (i : ι) → β i), hammingDist x 0 = hammingNorm x","name":"hammingDist_zero_right","isProp":true,"docString":"Corresponds to `dist_zero_right`. ","distance":1.94707592308634414024481884553097188472747802734375}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.94730922637157721766243412275798618793487548828125}],["A type endowed with `0` and `+` is an `AddZeroClass`, if it admits a\nsurjective map that preserves `0` and `+` to an `AddZeroClass`.",{"type":"{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Add M₂] →\n      [inst_1 : Zero M₂] →\n        [inst_2 : AddZeroClass M₁] →\n          (f : M₁ → M₂) → Function.Surjective f → f 0 = 0 → (∀ (x y : M₁), f (x + y) = f x + f y) → AddZeroClass M₂","name":"Function.Surjective.addZeroClass","isProp":false,"docString":"A type endowed with `0` and `+` is an `AddZeroClass`, if it admits a\nsurjective map that preserves `0` and `+` to an `AddZeroClass`.","distance":1.9476728033434209663710134918801486492156982421875}],["`sigmaPreimageEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all preimages of points under `f` and the total space `α`. ",{"type":"{α : Type u_1} → {β : Type u_2} → (f : α → β) → (b : β) × ↑(f ⁻¹' {b}) ≃ α","name":"Equiv.sigmaPreimageEquiv","isProp":false,"docString":"`sigmaPreimageEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all preimages of points under `f` and the total space `α`. ","distance":1.948200189318705088936667380039580166339874267578125}],["Find arguments for the `Zero` class. ",{"type":"Simps.findArgType","name":"Simps.findZeroArgs","isProp":false,"docString":"Find arguments for the `Zero` class. ","distance":1.94840821396857233338550940970890223979949951171875}]]