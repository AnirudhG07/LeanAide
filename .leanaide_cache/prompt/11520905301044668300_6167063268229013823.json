[["The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.963684070816043014673368816147558391094207763671875}],[" Given a finite type `β` and a function `π:` `β` → Type, where each `π b` is a pseudo metric space, the open ball in the product space `β × (π := Π b, π b)` centered at `(x: β) × (x₀: Π b, π b)` with radius `r` is equivalent to the product of open balls in each `π b` centered at `x b` with radius `r`.",{"type":"∀ {β : Type v} {π : β → Type u_3} [inst : Fintype β] [inst_1 : (b : β) → PseudoMetricSpace (π b)] [inst_2 : Nonempty β]\n  (x : (b : β) → π b) (r : ℝ), Metric.ball x r = Set.univ.pi fun b => Metric.ball (x b) r","name":"ball_pi'","isProp":true,"docString":" Given a finite type `β` and a function `π:` `β` → Type, where each `π b` is a pseudo metric space, the open ball in the product space `β × (π := Π b, π b)` centered at `(x: β) × (x₀: Π b, π b)` with radius `r` is equivalent to the product of open balls in each `π b` centered at `x b` with radius `r`.","distance":1.9801672902971152456785830509033985435962677001953125}],["This theorem states that the slit plane (which is the complex plane with the closed negative real axis removed) is star-convex at any positive number. In other words, for any positive complex number `z`, every line segment that starts at `z` and ends at any point in the slit plane is entirely contained within the slit plane.",{"type":"∀ {z : ℂ}, 0 < z → StarConvex ℝ z Complex.slitPlane","name":"Complex.starConvex_slitPlane","isProp":true,"docString":"This theorem states that the slit plane (which is the complex plane with the closed negative real axis removed) is star-convex at any positive number. In other words, for any positive complex number `z`, every line segment that starts at `z` and ends at any point in the slit plane is entirely contained within the slit plane.","distance":1.99004366169109569995043784729205071926116943359375}],["The stalk at `x` of a `PresheafedSpace`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasColimits C] → (X : AlgebraicGeometry.PresheafedSpace C) → ↑↑X → C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"docString":"The stalk at `x` of a `PresheafedSpace`.\n","distance":1.964506937360613658682950699585489928722381591796875}],[" If `A` is a set-like type, `M₁` has an identity element `e` for some operation, and `1` is in class `OneMemClass`, then `coe (1 : M₁) = e`.",{"type":"∀ {A : Type u_4} {M₁ : Type u_5} [inst : SetLike A M₁] [inst_1 : One M₁] [hA : OneMemClass A M₁] (S' : A), ↑1 = 1","name":"OneMemClass.coe_one","isProp":true,"docString":" If `A` is a set-like type, `M₁` has an identity element `e` for some operation, and `1` is in class `OneMemClass`, then `coe (1 : M₁) = e`.","distance":1.9816564361116626447056887627695687115192413330078125}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":1.990891046571473754767112041008658707141876220703125}],["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] → [inst_1 : MetricSpace P] → [inst_2 : NormedAddTorsor V P] → AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.965964903788016915342495849472470581531524658203125}],["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.Limits.HasZeroObject C] → Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.9677217875781927158840289848740212619304656982421875}],["**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConvexOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → f z ≤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_segment","isProp":true,"docString":"**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9707888154250634560327171129756607115268707275390625}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConcaveOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9718399502846331028393933593179099261760711669921875}],["Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n",{"type":"Sort u → Sort u","name":"semiOutParam","isProp":false,"docString":"Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n","distance":1.9740962763006841829138693356071598827838897705078125}],["Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",{"type":"Lean.Syntax →\n  Lean.Name →\n    optParam Bool false →\n      optParam (Array Simps.ProjectionRule) #[] →\n        optParam Bool false → Lean.CoreM (List Lean.Name × Array Simps.ProjectionData)","name":"Simps.getRawProjections","isProp":false,"docString":"Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n","distance":1.977615226053691888097318951622582972049713134765625}],["Euclidean center of the circle with center `z` and radius `r` in the hyperbolic metric. ",{"type":"UpperHalfPlane → ℝ → UpperHalfPlane","name":"UpperHalfPlane.center","isProp":false,"docString":"Euclidean center of the circle with center `z` and radius `r` in the hyperbolic metric. ","distance":1.977778572289373482107066593016497790813446044921875}],["Construct a bundled `SemigroupCat` from the underlying type and typeclass. ",{"type":"(M : Type u) → [inst : Semigroup M] → SemigroupCat","name":"SemigroupCat.of","isProp":false,"docString":"Construct a bundled `SemigroupCat` from the underlying type and typeclass. ","distance":1.97980559239891196199323530890978872776031494140625}],["A constructor for objects of the category `CompHaus`,\ntaking a type, and bundling the compact Hausdorff topology\nfound by typeclass inference. ",{"type":"(X : Type u_1) → [inst : TopologicalSpace X] → [inst_1 : CompactSpace X] → [inst : T2Space X] → CompHaus","name":"CompHaus.of","isProp":false,"docString":"A constructor for objects of the category `CompHaus`,\ntaking a type, and bundling the compact Hausdorff topology\nfound by typeclass inference. ","distance":1.9800850895859942735199865637696348130702972412109375}],["If `ε > 0`, then `BoxIntegral.Integrable.convergenceR` is a function `r : ℝ≥0 → ℝⁿ → (0, ∞)`\nsuch that for every `c : ℝ≥0`, for every tagged partition `π` subordinate to `r` (and satisfying\nadditional distortion estimates if `BoxIntegral.IntegrationParams.bDistortion l = true`), the\ncorresponding integral sum is `ε`-close to the integral.\n\nIf `BoxIntegral.IntegrationParams.bRiemann = true`, then `r c x` does not depend on `x`. If\n`ε ≤ 0`, then we use `r c x = 1`.  ",{"type":"{ι : Type u} →\n  {E : Type v} →\n    {F : Type w} →\n      [inst : NormedAddCommGroup E] →\n        [inst_1 : NormedSpace ℝ E] →\n          [inst_2 : NormedAddCommGroup F] →\n            [inst_3 : NormedSpace ℝ F] →\n              {I : BoxIntegral.Box ι} →\n                [inst_4 : Fintype ι] →\n                  {l : BoxIntegral.IntegrationParams} →\n                    {f : (ι → ℝ) → E} →\n                      {vol : BoxIntegral.BoxAdditiveMap ι (E →L[ℝ] F) ⊤} →\n                        BoxIntegral.Integrable I l f vol → ℝ → NNReal → (ι → ℝ) → ↑(Set.Ioi 0)","name":"BoxIntegral.Integrable.convergenceR","isProp":false,"docString":"If `ε > 0`, then `BoxIntegral.Integrable.convergenceR` is a function `r : ℝ≥0 → ℝⁿ → (0, ∞)`\nsuch that for every `c : ℝ≥0`, for every tagged partition `π` subordinate to `r` (and satisfying\nadditional distortion estimates if `BoxIntegral.IntegrationParams.bDistortion l = true`), the\ncorresponding integral sum is `ε`-close to the integral.\n\nIf `BoxIntegral.IntegrationParams.bRiemann = true`, then `r c x` does not depend on `x`. If\n`ε ≤ 0`, then we use `r c x = 1`.  ","distance":1.9802066863882752389969255091273225843906402587890625}],["Construct a bundled `UniformSpace` from the underlying type and the typeclass. ",{"type":"(α : Type u) → [inst : UniformSpace α] → UniformSpaceCat","name":"UniformSpaceCat.of","isProp":false,"docString":"Construct a bundled `UniformSpace` from the underlying type and the typeclass. ","distance":1.9812067710158187683333608219982124865055084228515625}],["**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module 𝕜 β] [inst_3 : OrderedSMul 𝕜 β] {f : 𝕜 → β} {x y z : 𝕜},\n  ConvexOn 𝕜 (Set.Icc x y) f → z ∈ Set.Icc x y → f z ≤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_Icc","isProp":true,"docString":"**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9817815182201135026929250670946203172206878662109375}],["```\n               X\n               |\n              (f)\n               |\n               \\/\n  Z ---(e)---> Y\n```\nIf `Z` is a Stonean space, `f : X ⟶ Y` an epi in `CompHaus` and `e : Z ⟶ Y` is arbitrary, then\n`lift e f` is a fixed (but arbitrary) lift of `e` to a morphism `Z ⟶ X`. It exists because\n`Z` is a projective object in `CompHaus`.\n",{"type":"{X Y : CompHaus} → {Z : Stonean} → (Z.compHaus ⟶ Y) → (f : X ⟶ Y) → [inst : CategoryTheory.Epi f] → Z.compHaus ⟶ X","name":"CompHaus.lift","isProp":false,"docString":"```\n               X\n               |\n              (f)\n               |\n               \\/\n  Z ---(e)---> Y\n```\nIf `Z` is a Stonean space, `f : X ⟶ Y` an epi in `CompHaus` and `e : Z ⟶ Y` is arbitrary, then\n`lift e f` is a fixed (but arbitrary) lift of `e` to a morphism `Z ⟶ X`. It exists because\n`Z` is a projective object in `CompHaus`.\n","distance":1.9819032560727176672799032530747354030609130859375}],["Construct a bundled `MeasCat` from the underlying type and the typeclass. ",{"type":"(α : Type u) → [ms : MeasurableSpace α] → MeasCat","name":"MeasCat.of","isProp":false,"docString":"Construct a bundled `MeasCat` from the underlying type and the typeclass. ","distance":1.9819220791590621555400275610736571252346038818359375}],["Construct a bundled `Cat` from the underlying type and the typeclass. ",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Cat","name":"CategoryTheory.Cat.of","isProp":false,"docString":"Construct a bundled `Cat` from the underlying type and the typeclass. ","distance":1.9819854742456282092888386614504270255565643310546875}],["Construct a bundled `UniformSpace` from the underlying type and the appropriate typeclasses. ",{"type":"(X : Type u) → [inst : UniformSpace X] → [inst_1 : CompleteSpace X] → [inst : SeparatedSpace X] → CpltSepUniformSpace","name":"CpltSepUniformSpace.of","isProp":false,"docString":"Construct a bundled `UniformSpace` from the underlying type and the appropriate typeclasses. ","distance":1.9822671762025283470620706793852150440216064453125}],["A `GlobalPreprocessor` lifts to a `GlobalBranchingPreprocessor` by producing only one branch.\n",{"type":"Linarith.GlobalPreprocessor → Linarith.GlobalBranchingPreprocessor","name":"Linarith.GlobalPreprocessor.branching","isProp":false,"docString":"A `GlobalPreprocessor` lifts to a `GlobalBranchingPreprocessor` by producing only one branch.\n","distance":1.982379918366201199120268938713707029819488525390625}],["A function `f : α → ℓ^∞(ι, ℝ)` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz\nextension to the whole space.\n\nTheorem 2.2 of [Assaf Naor, *Metric Embeddings and Lipschitz Extensions*][Naor-2015]\n\nThe same result for the case of a finite type `ι` is implemented in\n`LipschitzOnWith.extend_pi`.\n",{"type":"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {ι : Type u_1} {f : α → ↥(lp (fun i => ℝ) ⊤)} {K : NNReal},\n  LipschitzOnWith K f s → ∃ g, LipschitzWith K g ∧ Set.EqOn f g s","name":"LipschitzOnWith.extend_lp_infty","isProp":true,"docString":"A function `f : α → ℓ^∞(ι, ℝ)` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz\nextension to the whole space.\n\nTheorem 2.2 of [Assaf Naor, *Metric Embeddings and Lipschitz Extensions*][Naor-2015]\n\nThe same result for the case of a finite type `ι` is implemented in\n`LipschitzOnWith.extend_pi`.\n","distance":1.98278211614973809417961092549376189708709716796875}]]