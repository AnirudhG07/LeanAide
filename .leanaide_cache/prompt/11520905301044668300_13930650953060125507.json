[["A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n",{"type":"(n m : ℕ) → Decidable (n = m)","name":"Nat.decEq","isProp":false,"docString":"A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n","distance":2.000251633769985826205584089620970189571380615234375}],[" The greatest common divisor of 0 and any natural number `y` equals `y`.",{"type":"∀ (y : ℕ), Nat.gcd 0 y = y","name":"Nat.gcd_zero_left","isProp":true,"docString":" The greatest common divisor of 0 and any natural number `y` equals `y`.","distance":2.047499786827763568197724453057162463665008544921875}],["The theorem `Nat.Prime.ne_one` states that for every natural number `p`, if `p` is a prime number, then `p` cannot be equal to 1. In other words, no prime number can be 1. This is consistent with the definition of a prime number as a natural number at least 2 whose only divisors are itself and 1.",{"type":"∀ {p : ℕ}, p.Prime → p ≠ 1","name":"Nat.Prime.ne_one","isProp":true,"docString":"The theorem `Nat.Prime.ne_one` states that for every natural number `p`, if `p` is a prime number, then `p` cannot be equal to 1. In other words, no prime number can be 1. This is consistent with the definition of a prime number as a natural number at least 2 whose only divisors are itself and 1.","distance":2.04120983033956715502199585898779332637786865234375}],["Strong recursor for `Nat`\n",{"type":"{motive : ℕ → Sort u_1} → ((n : ℕ) → ((m : ℕ) → m < n → motive m) → motive n) → (t : ℕ) → motive t","name":"Nat.strongRec","isProp":false,"docString":"Strong recursor for `Nat`\n","distance":2.001029993785610638923344595241360366344451904296875}],[" The greatest common divisor of a natural number `n` and zero is equal to `n`. In Lean, this is expressed as `Nat.gcd_zero_right n`.",{"type":"∀ (n : ℕ), n.gcd 0 = n","name":"Nat.gcd_zero_right","isProp":true,"docString":" The greatest common divisor of a natural number `n` and zero is equal to `n`. In Lean, this is expressed as `Nat.gcd_zero_right n`.","distance":2.056642311424147440135357101098634302616119384765625}],["The theorem `Nat.prime_two` asserts that the number 2 is a prime number. In the context of natural numbers, a prime number is defined as a natural number greater than or equal to 2 whose only divisors are itself and 1. Therefore, this theorem is confirming that 2, which is divisible only by itself and 1, satisfies this property and is therefore a prime number.",{"type":"Nat.Prime 2","name":"Nat.prime_two","isProp":true,"docString":"The theorem `Nat.prime_two` asserts that the number 2 is a prime number. In the context of natural numbers, a prime number is defined as a natural number greater than or equal to 2 whose only divisors are itself and 1. Therefore, this theorem is confirming that 2, which is divisible only by itself and 1, satisfies this property and is therefore a prime number.","distance":2.053438168655045359400901361368596553802490234375}],["Simple diagonal recursor for `Nat`\n",{"type":"{motive : ℕ → ℕ → Sort u_1} →\n  ((n : ℕ) → motive 0 n) →\n    ((m : ℕ) → motive m 0) → ((m n : ℕ) → motive m n → motive (m + 1) (n + 1)) → (m n : ℕ) → motive m n","name":"Nat.recDiagAux","isProp":false,"docString":"Simple diagonal recursor for `Nat`\n","distance":2.005205141955434644529532306478358805179595947265625}],["Diagonal recursor for `Nat`\n",{"type":"{motive : ℕ → ℕ → Sort u_1} →\n  motive 0 0 →\n    ((n : ℕ) → motive 0 n → motive 0 (n + 1)) →\n      ((m : ℕ) → motive m 0 → motive (m + 1) 0) →\n        ((m n : ℕ) → motive m n → motive (m + 1) (n + 1)) → (m n : ℕ) → motive m n","name":"Nat.recDiag","isProp":false,"docString":"Diagonal recursor for `Nat`\n","distance":2.00912507389127714674259550520218908786773681640625}],["Save an object to disk.\nIf you need to write multiple objects from within a single declaration,\nyou will need to provide a unique `key` for each.\n",{"type":"{α : Type} → System.FilePath → α → autoParam Lean.Name _auto✝ → IO Unit","name":"pickle","isProp":false,"docString":"Save an object to disk.\nIf you need to write multiple objects from within a single declaration,\nyou will need to provide a unique `key` for each.\n","distance":2.017206955058707951167207284015603363513946533203125}],["Tail-recursive version of `Nat.any`. ",{"type":"(ℕ → Bool) → ℕ → Bool","name":"Nat.anyTR","isProp":false,"docString":"Tail-recursive version of `Nat.any`. ","distance":2.017312225180933893398105283267796039581298828125}],["A shorthand for tracing the types of a list of proof terms\nwhen the `trace.linarith` option is set to true.\n",{"type":"{α : Type} → [inst : Lean.ToMessageData α] → α → List Lean.Expr → Lean.MetaM Unit","name":"Linarith.linarithTraceProofs","isProp":false,"docString":"A shorthand for tracing the types of a list of proof terms\nwhen the `trace.linarith` option is set to true.\n","distance":2.027130433078841331706598793971352279186248779296875}],["A `Nat` denotes a valid unicode codepoint if it is less than `0x110000`, and\nit is also not a \"surrogate\" character (the range `0xd800` to `0xdfff` inclusive).\n",{"type":"ℕ → Prop","name":"Nat.isValidChar","isProp":false,"docString":"A `Nat` denotes a valid unicode codepoint if it is less than `0x110000`, and\nit is also not a \"surrogate\" character (the range `0xd800` to `0xdfff` inclusive).\n","distance":2.0272691278142218607172253541648387908935546875}],["Gets the word size of the platform. That is, whether the platform is 64 or 32 bits. ",{"type":"ℕ","name":"System.Platform.numBits","isProp":false,"docString":"Gets the word size of the platform. That is, whether the platform is 64 or 32 bits. ","distance":2.03105726769168715151181459077633917331695556640625}],["The power operation on natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n",{"type":"ℕ → ℕ → ℕ","name":"Nat.pow","isProp":false,"docString":"The power operation on natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n","distance":2.031755862323000538793849045759998261928558349609375}],["If any functor to a discrete category is constant on objects, J is connected.\nThe converse of `any_functor_const_on_obj`.\n",{"type":"∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] [inst_1 : Nonempty J],\n  (∀ {α : Type u₁} (F : CategoryTheory.Functor J (CategoryTheory.Discrete α)) (j j' : J), F.obj j = F.obj j') →\n    CategoryTheory.IsConnected J","name":"CategoryTheory.IsConnected.of_any_functor_const_on_obj","isProp":true,"docString":"If any functor to a discrete category is constant on objects, J is connected.\nThe converse of `any_functor_const_on_obj`.\n","distance":2.034134065026250492991266582976095378398895263671875}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadEnv m] → [inst : Lean.MonadError m] → Lean.Name → m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":2.03510464928788703531381543143652379512786865234375}],["Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then\nimported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n",{"type":"Lean.ParserDescr","name":"«termCompile_time_search_path%»","isProp":false,"docString":"Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then\nimported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n","distance":2.035234747298512392177372021251358091831207275390625}],["`Covariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `CovariantClass` doc-string for its meaning. ",{"type":"(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop","name":"Covariant","isProp":false,"docString":"`Covariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `CovariantClass` doc-string for its meaning. ","distance":2.039353928796332038331229341565631330013275146484375}],["Lists all declarations with a long name, gathered according to the module they are defined in.\nUse as `#long_names` or `#long_names 100` to specify the length.\n",{"type":"Lean.ParserDescr","name":"«command#long_names_»","isProp":false,"docString":"Lists all declarations with a long name, gathered according to the module they are defined in.\nUse as `#long_names` or `#long_names 100` to specify the length.\n","distance":2.039795430203280357517314769211225211620330810546875}],["This can't be an instance because Lean wouldn't know how to find `N`, but we can still use\nthis to manually derive `SMulMemClass` on specific types. ",{"type":"∀ (S : Type u_1) (M : Type u_2) (N : Type u_3) (α : Type u_4) [inst : SetLike S α] [inst_1 : SMul M N]\n  [inst_2 : SMul M α] [inst_3 : Monoid N] [inst_4 : MulAction N α] [inst_5 : SMulMemClass S N α]\n  [inst_6 : IsScalarTower M N α], SMulMemClass S M α","name":"SMulMemClass.ofIsScalarTower","isProp":true,"docString":"This can't be an instance because Lean wouldn't know how to find `N`, but we can still use\nthis to manually derive `SMulMemClass` on specific types. ","distance":2.04170147047846217702726789866574108600616455078125}],["**Alias** of `Decidable.em`.",{"type":"∀ (p : Prop) [inst : Decidable p], p ∨ ¬p","name":"dec_em","isProp":true,"docString":"**Alias** of `Decidable.em`.","distance":2.04188335394486397689206569339148700237274169921875}],["(Boolean) equality of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n",{"type":"ℕ → ℕ → Bool","name":"Nat.beq","isProp":false,"docString":"(Boolean) equality of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n","distance":2.04333433017169507905919090262614190578460693359375}],["Generate compiled code for the recursor for `iv`, excluding the `sizeOf` function.\n",{"type":"Lean.InductiveVal → optParam Bool true → Lean.MetaM Unit","name":"Mathlib.Util.compileInductiveOnly","isProp":false,"docString":"Generate compiled code for the recursor for `iv`, excluding the `sizeOf` function.\n","distance":2.0457373908138638540776810259558260440826416015625}],["An uncurried version of `Finset.prod_prod_type_right`. ",{"type":"∀ {γ : Type u_3} {α₁ : Type u_4} {α₂ : Type u_5} [inst : Fintype α₁] [inst_1 : Fintype α₂] [inst_2 : CommMonoid γ]\n  {f : α₁ → α₂ → γ},\n  (Finset.prod Finset.univ fun x => f x.1 x.2) = Finset.prod Finset.univ fun y => Finset.prod Finset.univ fun x => f x y","name":"Fintype.prod_prod_type_right'","isProp":true,"docString":"An uncurried version of `Finset.prod_prod_type_right`. ","distance":2.046501827179915355969797019497491419315338134765625}]]