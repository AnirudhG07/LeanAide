[["The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{𝕜 : Type u_8} →\n  {𝕜' : Type u_9} →\n    {E : Type u_10} →\n      [inst : NormedField 𝕜'] →\n        [inst_1 : SeminormedAddCommGroup E] → [I : NormedSpace 𝕜' E] → NormedSpace 𝕜' (RestrictScalars 𝕜 𝕜' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.9434392819182708667113956835237331688404083251953125}],[" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.",{"type":"∀ (n : ℕ), ↑n = ↑n","name":"Nat.cast_withBot","isProp":true,"docString":" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.","distance":1.9682077975166130112683049446786753833293914794921875}],["This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.denom 0 = 1","name":"RatFunc.denom_zero","isProp":true,"docString":"This theorem, `RatFunc.denom_zero`, states that for any type `K`, which is a field, the denominator of the zero rational function (`RatFunc 0`) is equal to `1`. In other words, in any field, the denominator of the rational function representing zero is normalized to be the monic polynomial `1`.","distance":1.96769843786131648499804214225150644779205322265625}],["Embedding of a subtype into the ambient type as an `OrderEmbedding`. ",{"type":"{α : Type u_2} → [inst : Preorder α] → (p : α → Prop) → Subtype p ↪o α","name":"OrderEmbedding.subtype","isProp":false,"docString":"Embedding of a subtype into the ambient type as an `OrderEmbedding`. ","distance":1.950345839375009493465995547012425959110260009765625}],[" A prime number does not divide 1.",{"type":"∀ {p : ℕ}, p.Prime → ¬p ∣ 1","name":"Nat.Prime.not_dvd_one","isProp":true,"docString":" A prime number does not divide 1.","distance":1.9743153338201684388053536167717538774013519287109375}],["This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.",{"type":"∀ {p : ℕ}, p.Prime → p.properDivisors = {1}","name":"Nat.Prime.properDivisors","isProp":true,"docString":"This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.","distance":1.9710474347449478127458633025526069104671478271484375}],["Converts a `ZNum` to a `PosNum`, mapping all out of range values to `1`. ",{"type":"ZNum → PosNum","name":"PosNum.ofZNum","isProp":false,"docString":"Converts a `ZNum` to a `PosNum`, mapping all out of range values to `1`. ","distance":1.9525308266800822654118974242010153830051422119140625}],["`IsSpecial'` is an alternative of `IsSpecial`. ",{"type":"PNat.XgcdType → Prop","name":"PNat.XgcdType.IsSpecial'","isProp":false,"docString":"`IsSpecial'` is an alternative of `IsSpecial`. ","distance":1.9550404718709248896857388899661600589752197265625}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{α : Type v} → Quotient.out (Cardinal.mk α) ≃ α","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":1.95832683022356235369443311356008052825927734375}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ≤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"ℤ → ℤ","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ≤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":1.958382803407439975984516422613523900508880615234375}],["Reverse of `Set.codRestrict_restrict`. ",{"type":"∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {f : α → β} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h = Set.codRestrict (Set.restrict s f) t (_ : ∀ (x : ↑s), f ↑x ∈ t)","name":"Set.MapsTo.restrict_eq_codRestrict","isProp":true,"docString":"Reverse of `Set.codRestrict_restrict`. ","distance":1.958560434433718189239925777656026184558868408203125}],["Restrict the codomain of a principal segment ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} →\n        (p : Set β) → (f : r ≺i s) → (∀ (a : α), f.toRelEmbedding a ∈ p) → f.top ∈ p → r ≺i Subrel s p","name":"PrincipalSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of a principal segment ","distance":1.9591377322847502995273316628299653530120849609375}],["A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"ℕ → Type","name":"Affine.Simplex.PointsWithCircumcenterIndex.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.959388211722842054740567618864588439464569091796875}],["This is a special case of a more general instance that we define in a later file. ",{"type":"∀ {R : Type u} (A : Type v) [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Subsingleton (R →ₐ[R] A)","name":"Algebra.subsingleton_id","isProp":true,"docString":"This is a special case of a more general instance that we define in a later file. ","distance":1.9596445393659838174471587990410625934600830078125}],["The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",{"type":"ℕ → ℕ","name":"Nat.pred","isProp":false,"docString":"The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n","distance":1.9602123811284648535746555353398434817790985107421875}],["A variant of `IsUnifLocDoublingMeasure.doublingConstant` which allows for scaling the\nradius by values other than `2`. ",{"type":"{α : Type u_1} →\n  [inst : MetricSpace α] →\n    [inst_1 : MeasurableSpace α] → (μ : MeasureTheory.Measure α) → [inst : IsUnifLocDoublingMeasure μ] → ℝ → NNReal","name":"IsUnifLocDoublingMeasure.scalingConstantOf","isProp":false,"docString":"A variant of `IsUnifLocDoublingMeasure.doublingConstant` which allows for scaling the\nradius by values other than `2`. ","distance":1.9604390736779804260692117168218828737735748291015625}],["A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"Type u_1 → Type u_2 → Type (max u_1 u_2)","name":"Symbol.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Symbol` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Symbol.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":1.9605144872105808584450414855382405221462249755859375}],["`properDivisors n` is the `Finset` of divisors of `n`, other than `n`.\nAs a special case, `properDivisors 0 = ∅`. ",{"type":"ℕ → Finset ℕ","name":"Nat.properDivisors","isProp":false,"docString":"`properDivisors n` is the `Finset` of divisors of `n`, other than `n`.\nAs a special case, `properDivisors 0 = ∅`. ","distance":1.9606687594029938992434836109168827533721923828125}],["This is the `norm_num` plug-in that evaluates Legendre symbols. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalLegendreSym","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Legendre symbols. ","distance":1.960760785160122754433587033418007194995880126953125}],["Restrict the codomain of an initial segment ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} → {s : β → β → Prop} → (p : Set β) → (f : r ≼i s) → (∀ (a : α), f a ∈ p) → r ≼i Subrel s p","name":"InitialSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of an initial segment ","distance":1.9613118974716552411763359486940316855907440185546875}],["`WithInitial.star` is initial. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Limits.IsInitial CategoryTheory.WithInitial.star","name":"CategoryTheory.WithInitial.starInitial","isProp":false,"docString":"`WithInitial.star` is initial. ","distance":1.9621607578122615134219586252584122121334075927734375}],["A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n",{"type":"(A : Type u_2) → [inst : CommRing A] → [inst : IsDomain A] → Prop","name":"IsDedekindDomainInv","isProp":false,"docString":"A Dedekind domain is an integral domain such that every fractional ideal has an inverse.\n\nThis is equivalent to `IsDedekindDomain`.\nIn particular we provide a `fractional_ideal.comm_group_with_zero` instance,\nassuming `IsDedekindDomain A`, which implies `IsDedekindDomainInv`. For **integral** ideals,\n`IsDedekindDomain`(`_inv`) implies only `Ideal.cancelCommMonoidWithZero`.\n","distance":1.9627224230844380059579634689725935459136962890625}],["This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ",{"type":"Mathlib.Meta.NormNum.NormNumExt","name":"Tactic.NormNum.evalJacobiSymNat","isProp":false,"docString":"This is the `norm_num` plug-in that evaluates Jacobi symbols on natural numbers. ","distance":1.962917319296770823910947001422755420207977294921875}],["A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ",{"type":"{α : Type u_2} → (β : α → Type u_1) → (i : α) ×' β i ≃ (i : α) × β i","name":"Equiv.psigmaEquivSigma","isProp":false,"docString":"A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ","distance":1.9635047726725749495102490982390008866786956787109375}]]