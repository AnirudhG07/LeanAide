[["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] → [inst_1 : MetricSpace P] → [inst_2 : NormedAddTorsor V P] → AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.941602321766575212080851997598074376583099365234375}],[" If `A` is a set-like type, `M₁` has an identity element `e` for some operation, and `1` is in class `OneMemClass`, then `coe (1 : M₁) = e`.",{"type":"∀ {A : Type u_4} {M₁ : Type u_5} [inst : SetLike A M₁] [inst_1 : One M₁] [hA : OneMemClass A M₁] (S' : A), ↑1 = 1","name":"OneMemClass.coe_one","isProp":true,"docString":" If `A` is a set-like type, `M₁` has an identity element `e` for some operation, and `1` is in class `OneMemClass`, then `coe (1 : M₁) = e`.","distance":1.97307390201831456266745590255595743656158447265625}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"∀ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":1.9730364471047325825026064194389618933200836181640625}],["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.Limits.HasZeroObject C] → Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.956725438031359232127215364016592502593994140625}],[" For any type `R` with a trivial `Star` operation satisfying `TrivialStar` property, `star r = r` for all `r` in `R`.",{"type":"∀ {R : Type u} [inst : Star R] [self : TrivialStar R] (r : R), star r = r","name":"TrivialStar.star_trivial","isProp":true,"docString":" For any type `R` with a trivial `Star` operation satisfying `TrivialStar` property, `star r = r` for all `r` in `R`.","distance":1.9739901794908558674279674960416741669178009033203125}],["This theorem, named `Path.Homotopic.proj_pi`, states that for all types `ι` and `as`, `bs` functions from `ι` to some type `X` (where each `X i` is a topological space), and any index `i` in `ι`, when we take a family of path homotopy classes `paths` (each path being from `as i` to `bs i` for some `i` in `ι`), and form a product of these path homotopy classes using the `Path.Homotopic.pi` function, projecting back to the `i`th coordinate using the `Path.Homotopic.proj` function gives us the original path homotopy class at `i` in the `paths` family. In other words, the projection operation is the inverse of the pi operation in the context of path homotopy classes.",{"type":"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {as bs : (i : ι) → X i} (i : ι)\n  (paths : (i : ι) → Path.Homotopic.Quotient (as i) (bs i)), Path.Homotopic.proj i (Path.Homotopic.pi paths) = paths i","name":"Path.Homotopic.proj_pi","isProp":true,"docString":"This theorem, named `Path.Homotopic.proj_pi`, states that for all types `ι` and `as`, `bs` functions from `ι` to some type `X` (where each `X i` is a topological space), and any index `i` in `ι`, when we take a family of path homotopy classes `paths` (each path being from `as i` to `bs i` for some `i` in `ι`), and form a product of these path homotopy classes using the `Path.Homotopic.pi` function, projecting back to the `i`th coordinate using the `Path.Homotopic.proj` function gives us the original path homotopy class at `i` in the `paths` family. In other words, the projection operation is the inverse of the pi operation in the context of path homotopy classes.","distance":1.975937816768547516943499431363306939601898193359375}],["Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",{"type":"Lean.Syntax →\n  Lean.Name →\n    optParam Bool false →\n      optParam (Array Simps.ProjectionRule) #[] →\n        optParam Bool false → Lean.CoreM (List Lean.Name × Array Simps.ProjectionData)","name":"Simps.getRawProjections","isProp":false,"docString":"Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n","distance":1.9674338656666312541432262150919996201992034912109375}],["A choice-free shortcut instance.",{"type":"∀ (α : Type u) [inst : OrderedAddCommGroup α],\n  ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1","name":"OrderedAddCommGroup.to_contravariantClass_right_le","isProp":true,"docString":"A choice-free shortcut instance.","distance":1.9675479470668779669040304725058376789093017578125}],["The stalk at `x` of a `PresheafedSpace`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasColimits C] → (X : AlgebraicGeometry.PresheafedSpace C) → ↑↑X → C","name":"AlgebraicGeometry.PresheafedSpace.stalk","isProp":false,"docString":"The stalk at `x` of a `PresheafedSpace`.\n","distance":1.9693433357830236740682039453531615436077117919921875}],["Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then\nimported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n",{"type":"Lean.ParserDescr","name":"«termCompile_time_search_path%»","isProp":false,"docString":"Term elaborator that retrieves the current `SearchPath`.\n\nTypical usage is `searchPathRef.set compile_time_search_path%`.\n\nThis must not be used in files that are potentially compiled on another machine and then\nimported.\n(That is, if used in an imported file it will embed the search path from whichever machine\ncompiled the `.olean`.)\n","distance":1.9695460435199987347942851556581445038318634033203125}],["Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n",{"type":"(α : Sort u) → α → Sort u","name":"optParam","isProp":false,"docString":"Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n","distance":1.9698023062410137118405373257701285183429718017578125}],["Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n",{"type":"Sort u → Sort u","name":"semiOutParam","isProp":false,"docString":"Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n","distance":1.9698865714744508981226545074605382978916168212890625}],["```\n               X\n               |\n              (f)\n               |\n               \\/\n  Z ---(e)---> Y\n```\nIf `Z` is a Stonean space, `f : X ⟶ Y` an epi in `CompHaus` and `e : Z ⟶ Y` is arbitrary, then\n`lift e f` is a fixed (but arbitrary) lift of `e` to a morphism `Z ⟶ X`. It exists because\n`Z` is a projective object in `CompHaus`.\n",{"type":"{X Y : CompHaus} → {Z : Stonean} → (Z.compHaus ⟶ Y) → (f : X ⟶ Y) → [inst : CategoryTheory.Epi f] → Z.compHaus ⟶ X","name":"CompHaus.lift","isProp":false,"docString":"```\n               X\n               |\n              (f)\n               |\n               \\/\n  Z ---(e)---> Y\n```\nIf `Z` is a Stonean space, `f : X ⟶ Y` an epi in `CompHaus` and `e : Z ⟶ Y` is arbitrary, then\n`lift e f` is a fixed (but arbitrary) lift of `e` to a morphism `Z ⟶ X`. It exists because\n`Z` is a projective object in `CompHaus`.\n","distance":1.9699516739451821134565534521243534982204437255859375}],["Cast a `SNum` to the corresponding integer. ",{"type":"SNum → ℤ","name":"Int.ofSnum","isProp":false,"docString":"Cast a `SNum` to the corresponding integer. ","distance":1.971208177703500208366449442110024392604827880859375}],["Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.",{"type":"Lean.Name → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.mkParsedProjectionData","isProp":false,"docString":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.","distance":1.9717541487873455618995421900763176381587982177734375}],["If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ",{"type":"{α : Type u} → Task α → α","name":"Task.get","isProp":false,"docString":"If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ","distance":1.9728549342514565267947546089999377727508544921875}],["Get the projections of a structure used by `@[simps]` applied to the appropriate arguments.\nReturns a list of tuples\n```\n(corresponding right-hand-side, given projection name, projection Expression,\n  future projection numbers, used by default, is prefix)\n```\n(where all fields except the first are packed in a `ProjectionData` structure)\none for each projection. The given projection name is the name for the projection used by the user\nused to generate (and parse) projection names. For example, in the structure\n\nExample 1: ``getProjectionExprs env `(α × β) `(⟨x, y⟩)`` will give the output\n```\n  [(`(x), `fst, `(@Prod.fst.{u v} α β), [], true, false),\n   (`(y), `snd, `(@Prod.snd.{u v} α β), [], true, false)]\n```\n\nExample 2: ``getProjectionExprs env `(α ≃ α) `(⟨id, id, fun _ ↦ rfl, fun _ ↦ rfl⟩)``\nwill give the output\n```\n  [(`(id), `apply, (Equiv.toFun), [], true, false),\n   (`(id), `symm_apply, (fun e ↦ e.symm.toFun), [], true, false),\n   ...,\n   ...]\n```\n",{"type":"Lean.Syntax → Lean.Expr → Lean.Expr → Simps.Config → Lean.MetaM (Array (Lean.Expr × Simps.ProjectionData))","name":"Simps.getProjectionExprs","isProp":false,"docString":"Get the projections of a structure used by `@[simps]` applied to the appropriate arguments.\nReturns a list of tuples\n```\n(corresponding right-hand-side, given projection name, projection Expression,\n  future projection numbers, used by default, is prefix)\n```\n(where all fields except the first are packed in a `ProjectionData` structure)\none for each projection. The given projection name is the name for the projection used by the user\nused to generate (and parse) projection names. For example, in the structure\n\nExample 1: ``getProjectionExprs env `(α × β) `(⟨x, y⟩)`` will give the output\n```\n  [(`(x), `fst, `(@Prod.fst.{u v} α β), [], true, false),\n   (`(y), `snd, `(@Prod.snd.{u v} α β), [], true, false)]\n```\n\nExample 2: ``getProjectionExprs env `(α ≃ α) `(⟨id, id, fun _ ↦ rfl, fun _ ↦ rfl⟩)``\nwill give the output\n```\n  [(`(id), `apply, (Equiv.toFun), [], true, false),\n   (`(id), `symm_apply, (fun e ↦ e.symm.toFun), [], true, false),\n   ...,\n   ...]\n```\n","distance":1.9734126953764867806739857769571244716644287109375}],["Return the `z` such that `x :: z :: _` appears in `xs`, or `default` if there is no such `z`. ",{"type":"{α : Type u_1} → [inst : DecidableEq α] → List α → α → α → α","name":"List.nextOr","isProp":false,"docString":"Return the `z` such that `x :: z :: _` appears in `xs`, or `default` if there is no such `z`. ","distance":1.9737606073242683901725058603915385901927947998046875}],["A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit (F.mapCocone c) →\n                    [inst_3 : CategoryTheory.Limits.ReflectsColimit K F] → CategoryTheory.Limits.IsColimit c","name":"CategoryTheory.Limits.isColimitOfReflects","isProp":false,"docString":"A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":1.9739647486035785117763907692278735339641571044921875}],["Produce a string for a given `InjectiveFunction`.\nThe output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, x ↦ x]`.\nUnlike for `TotalFunction`, the default value is not a constant\nbut the identity function.\n",{"type":"{α : Type u} → [inst : Repr α] → SlimCheck.InjectiveFunction α → String","name":"SlimCheck.InjectiveFunction.repr","isProp":false,"docString":"Produce a string for a given `InjectiveFunction`.\nThe output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, x ↦ x]`.\nUnlike for `TotalFunction`, the default value is not a constant\nbut the identity function.\n","distance":1.9741211665583602297147081117145717144012451171875}],["`simpsTac` derives `simp` lemmas for all (nested) non-Prop projections of the declaration.\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\nIf `shortNm` is true, the generated names will only use the last projection name.\nIf `trc` is true, trace as if `trace.simps.verbose` is true. ",{"type":"Lean.Syntax →\n  Lean.Name →\n    optParam Simps.Config\n        { isSimp := true, attrs := [], simpRhs := false, typeMd := Lean.Meta.TransparencyMode.instances,\n          rhsMd := Lean.Meta.TransparencyMode.reducible, fullyApplied := true,\n          notRecursive := [`Prod, `PProd, `Opposite, `PreOpposite], debug := false } →\n      optParam (List (String × Lean.Syntax)) [] → optParam Bool false → Lean.AttrM (Array Lean.Name)","name":"simpsTac","isProp":false,"docString":"`simpsTac` derives `simp` lemmas for all (nested) non-Prop projections of the declaration.\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\nIf `shortNm` is true, the generated names will only use the last projection name.\nIf `trc` is true, trace as if `trace.simps.verbose` is true. ","distance":1.9742733822063243120936704144696705043315887451171875}],["```\n               X\n               |\n              (f)\n               |\n               \\/\n  Z ---(e)---> Y\n```\nIf `Z` is a Stonean space, `f : X ⟶ Y` an epi in `Profinite` and `e : Z ⟶ Y` is arbitrary,\nthen `lift e f` is a fixed (but arbitrary) lift of `e` to a morphism `Z ⟶ X`. It is\n`CompHaus.lift e f` as a morphism in `Profinite`.\n",{"type":"{X Y : Profinite} →\n  {Z : Stonean} →\n    (Stonean.toProfinite.obj Z ⟶ Y) → (f : X ⟶ Y) → [inst : CategoryTheory.Epi f] → Stonean.toProfinite.obj Z ⟶ X","name":"Profinite.lift","isProp":false,"docString":"```\n               X\n               |\n              (f)\n               |\n               \\/\n  Z ---(e)---> Y\n```\nIf `Z` is a Stonean space, `f : X ⟶ Y` an epi in `Profinite` and `e : Z ⟶ Y` is arbitrary,\nthen `lift e f` is a fixed (but arbitrary) lift of `e` to a morphism `Z ⟶ X`. It is\n`CompHaus.lift e f` as a morphism in `Profinite`.\n","distance":1.9753952531354530552931692000129260122776031494140625}],["A shortcut instance for the common case ",{"type":"(R : Type u_2) →\n  [inst : CommRing R] →\n    [inst_1 : UniformSpace R] →\n      [inst_2 : UniformAddGroup R] → [inst_3 : TopologicalRing R] → Algebra R (UniformSpace.Completion R)","name":"UniformSpace.Completion.algebra'","isProp":false,"docString":"A shortcut instance for the common case ","distance":1.975412518929866134698158930405043065547943115234375}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConcaveOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.97553609991977197068990790285170078277587890625}]]