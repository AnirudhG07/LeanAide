[["The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from Lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",{"type":"Lean.ParserDescr","name":"termℕ","isProp":false,"docString":"The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from Lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n","distance":0.82352931599585776911709444902953691780567169189453125}],[" For any natural number `n`, `n` is less than 1 if and only if `n` equals 0. (Equivalently, `n < 1` if and only if `n = 0`.)",{"type":"∀ {n : ℕ}, n < 1 ↔ n = 0","name":"Nat.lt_one_iff","isProp":true,"docString":" For any natural number `n`, `n` is less than 1 if and only if `n` equals 0. (Equivalently, `n < 1` if and only if `n = 0`.)","distance":0.64233903659701130361980858651804737746715545654296875}],["This theorem states that for all natural numbers `n`, `n` is not less than zero. In other words, it's impossible for any natural number to be less than zero. This is intuitive, as the set of natural numbers starts from zero and includes all positive integers.",{"type":"∀ (n : ℕ), ¬n < 0","name":"Nat.not_lt_zero","isProp":true,"docString":"This theorem states that for all natural numbers `n`, `n` is not less than zero. In other words, it's impossible for any natural number to be less than zero. This is intuitive, as the set of natural numbers starts from zero and includes all positive integers.","distance":0.66205885026979227614418732628109864890575408935546875}],["The strict less than relation on natural numbers is defined as `n < m := n + 1 ≤ m`. ",{"type":"ℕ → ℕ → Prop","name":"Nat.lt","isProp":false,"docString":"The strict less than relation on natural numbers is defined as `n < m := n + 1 ≤ m`. ","distance":0.84578548186235191774784425433608703315258026123046875}],[" For any natural number `n`, `n` is not less than zero.",{"type":"∀ (n : ℕ), (n < 0) = False","name":"Mathlib.Data.Nat.Defs._auxLemma.1","isProp":true,"docString":" For any natural number `n`, `n` is not less than zero.","distance":0.65774498588871777027264897697023116052150726318359375}],["This theorem, `Mathlib.Data.Nat.Defs._auxLemma.1`, states that for any natural number `n`, the condition that `n` is less than zero is always `False`. In other words, it's asserting that no natural number can be less than zero. This aligns with the definition of natural numbers in mathematics, which includes all whole numbers from zero upwards.",{"type":"∀ (n : ℕ), (n < 0) = False","name":"Mathlib.Data.Nat.Defs._auxLemma.1","isProp":true,"docString":"This theorem, `Mathlib.Data.Nat.Defs._auxLemma.1`, states that for any natural number `n`, the condition that `n` is less than zero is always `False`. In other words, it's asserting that no natural number can be less than zero. This aligns with the definition of natural numbers in mathematics, which includes all whole numbers from zero upwards.","distance":0.676736905877325600755511914030648767948150634765625}],["Negation of a natural number. ",{"type":"ℕ → ℤ","name":"Int.negOfNat","isProp":false,"docString":"Negation of a natural number. ","distance":0.8624428981448895026318268719478510320186614990234375}],["Type of natural numbers with infinity (`⊤`) ",{"type":"Type","name":"PartENat","isProp":false,"docString":"Type of natural numbers with infinity (`⊤`) ","distance":0.87512745088719190444948026197380386292934417724609375}],["The (Boolean) less-equal relation on natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n",{"type":"ℕ → ℕ → Bool","name":"Nat.ble","isProp":false,"docString":"The (Boolean) less-equal relation on natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n","distance":0.880396809416649883672789655975066125392913818359375}],["The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",{"type":"ℕ → ℕ","name":"Nat.pred","isProp":false,"docString":"The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n","distance":0.88100143324489821328171501590986736118793487548828125}],["Boolean less-than of natural numbers. ",{"type":"ℕ → ℕ → Bool","name":"Nat.blt","isProp":false,"docString":"Boolean less-than of natural numbers. ","distance":0.89201294218160820381768871811800636351108551025390625}],["The strict series `0 < … < n` in `ℕ`. ",{"type":"ℕ → LTSeries ℕ","name":"LTSeries.range","isProp":false,"docString":"The strict series `0 < … < n` in `ℕ`. ","distance":0.8993597417649976666353950349730439484119415283203125}],["The sequence of natural numbers some 0, some 1, ... ",{"type":"Stream'.Seq ℕ","name":"Stream'.Seq.nats","isProp":false,"docString":"The sequence of natural numbers some 0, some 1, ... ","distance":0.908876963559157591276971288607455790042877197265625}],["The subtype of natural numbers `i` which have the property that\nno `j` less than `i` satisfies `p`. This is an initial segment of the\nnatural numbers, up to and including the first value satisfying `p`.\n\nWe will be particularly interested in the case where there exists a value\nsatisfying `p`, because in this case the `>` relation is well-founded. ",{"type":"(ℕ → Prop) → Type","name":"Nat.Upto","isProp":false,"docString":"The subtype of natural numbers `i` which have the property that\nno `j` less than `i` satisfies `p`. This is an initial segment of the\nnatural numbers, up to and including the first value satisfying `p`.\n\nWe will be particularly interested in the case where there exists a value\nsatisfying `p`, because in this case the `>` relation is well-founded. ","distance":0.9116834930079644738754041100037284195423126220703125}],["`range n` is the set of natural numbers less than `n`. ",{"type":"ℕ → Finset ℕ","name":"Finset.range","isProp":false,"docString":"`range n` is the set of natural numbers less than `n`. ","distance":0.921994620003619758108470705337822437286376953125}],["The minimum non-zero entry in a list of natural numbers, or zero if all entries are zero.\n\nWe completely characterize the function via\n`nonzeroMinimum_eq_zero_iff` and `nonzeroMinimum_eq_nonzero_iff` below.\n",{"type":"List ℕ → ℕ","name":"List.nonzeroMinimum","isProp":false,"docString":"The minimum non-zero entry in a list of natural numbers, or zero if all entries are zero.\n\nWe completely characterize the function via\n`nonzeroMinimum_eq_zero_iff` and `nonzeroMinimum_eq_nonzero_iff` below.\n","distance":0.92469961596289163008322020687046460807323455810546875}],["`Nat.find` is the minimum element of a nonempty set of natural numbers. ",{"type":"∀ {s : Set ℕ} [inst : DecidablePred fun x => x ∈ s] (hs : s.Nonempty), IsLeast s (Nat.find hs)","name":"Set.Nonempty.isLeast_natFind","isProp":true,"docString":"`Nat.find` is the minimum element of a nonempty set of natural numbers. ","distance":0.92613465110752313247388656236580573022365570068359375}],["The set of natural numbers is equivalent to `ℕ ⊕ PUnit`. ",{"type":"ℕ ≃ ℕ ⊕ PUnit.{u_9 + 1}","name":"Equiv.natEquivNatSumPUnit","isProp":false,"docString":"The set of natural numbers is equivalent to `ℕ ⊕ PUnit`. ","distance":0.92715357602331227582226347294636070728302001953125}],["`⌈a⌉₊` is the least natural `n` such that `a ≤ n` ",{"type":"Lean.ParserDescr","name":"Nat.«term⌈_⌉₊»","isProp":false,"docString":"`⌈a⌉₊` is the least natural `n` such that `a ≤ n` ","distance":0.92848099301339903632879213546402752399444580078125}],["Addition of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n",{"type":"ℕ → ℕ → ℕ","name":"Nat.add","isProp":false,"docString":"Addition of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n","distance":0.9302430079422283615286914937314577400684356689453125}],["`⌊a⌋₊` is the greatest natural `n` such that `n ≤ a`. If `a` is negative, then `⌊a⌋₊ = 0`. ",{"type":"{α : Type u_2} → [inst : OrderedSemiring α] → [inst : FloorSemiring α] → α → ℕ","name":"Nat.floor","isProp":false,"docString":"`⌊a⌋₊` is the greatest natural `n` such that `n ≤ a`. If `a` is negative, then `⌊a⌋₊ = 0`. ","distance":0.93081405166360864367192107238224707543849945068359375}],["A list of natural numbers is a Zeckendorf representation (of a natural number) if it is an\nincreasing sequence of non-consecutive numbers greater than or equal to `2`.\n\nThis is relevant for Zeckendorf's theorem, since if we write a natural `n` as a sum of Fibonacci\nnumbers `(l.map fib).sum`, `IsZeckendorfRep l` exactly means that we can't simplify any expression\nof the form `fib n + fib (n + 1) = fib (n + 2)`, `fib 1 = fib 2` or `fib 0 = 0` in the sum. ",{"type":"List ℕ → Prop","name":"List.IsZeckendorfRep","isProp":false,"docString":"A list of natural numbers is a Zeckendorf representation (of a natural number) if it is an\nincreasing sequence of non-consecutive numbers greater than or equal to `2`.\n\nThis is relevant for Zeckendorf's theorem, since if we write a natural `n` as a sum of Fibonacci\nnumbers `(l.map fib).sum`, `IsZeckendorfRep l` exactly means that we can't simplify any expression\nof the form `fib n + fib (n + 1) = fib (n + 2)`, `fib 1 = fib 2` or `fib 0 = 0` in the sum. ","distance":0.933834435897235248802417117985896766185760498046875}],["A natural number `n` is the **Frobenius number** of a set of natural numbers `s` if it is an\nupper bound on the complement of the additive submonoid generated by `s`.\nIn other words, it is the largest number that can not be expressed as a sum of numbers in `s`. ",{"type":"ℕ → Set ℕ → Prop","name":"FrobeniusNumber","isProp":false,"docString":"A natural number `n` is the **Frobenius number** of a set of natural numbers `s` if it is an\nupper bound on the complement of the additive submonoid generated by `s`.\nIn other words, it is the largest number that can not be expressed as a sum of numbers in `s`. ","distance":0.94552928429554639055965026273042894899845123291015625}],["A natural number `n` is smaller than `FloorSemiring.floor a` iff its coercion to `α` is\nsmaller than `a`. ",{"type":"∀ {α : Type u_4} {inst : OrderedSemiring α} [self : FloorSemiring α] {a : α} {n : ℕ},\n  0 ≤ a → (n ≤ FloorSemiring.floor a ↔ ↑n ≤ a)","name":"FloorSemiring.gc_floor","isProp":true,"docString":"A natural number `n` is smaller than `FloorSemiring.floor a` iff its coercion to `α` is\nsmaller than `a`. ","distance":0.946412316137985154540501753217540681362152099609375}]]