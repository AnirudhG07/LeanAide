[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9766406652970667234825441482826136052608489990234375}],[" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ùïú`, a normed additive group `E` over `ùïú` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ‚Ü¶ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.",{"type":"‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ùïú E] {I : ModelWithCorners ùïú E H} {G : Type u_4}\n  [inst_4 : Inv G] [inst_5 : Zero G] [inst_6 : TopologicalSpace G] [inst_7 : ChartedSpace H G] [self : SmoothInv‚ÇÄ I G]\n  ‚¶Éx : G‚¶Ñ, x ‚â† 0 ‚Üí SmoothAt I I (fun y => y‚Åª¬π) x","name":"SmoothInv‚ÇÄ.smoothAt_inv‚ÇÄ","isProp":true,"docString":" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ùïú`, a normed additive group `E` over `ùïú` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ‚Ü¶ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.","distance":2.008082998733962565296451430185697972774505615234375}],["This theorem states that for any topological space `Œ±` and any discrete topological space `Y`, if `Œ±` is preconnected and `f` is a continuous function from `Œ±` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `Œ±`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.",{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Œ± ‚Üí ‚àÄ {f : Œ± ‚Üí Y}, Continuous f ‚Üí ‚àÄ {x y : Œ±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"This theorem states that for any topological space `Œ±` and any discrete topological space `Y`, if `Œ±` is preconnected and `f` is a continuous function from `Œ±` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `Œ±`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.","distance":2.003565008647930856255925391451455652713775634765625}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type ‚Üí Type} ‚Üí [inst : Monad m] ‚Üí [inst : Lean.MonadEnv m] ‚Üí [inst : Lean.MonadError m] ‚Üí Lean.Name ‚Üí m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.980661073096880553379151024273596704006195068359375}],[" For any nontrivially normed field `ùïú`, normed additive commutative group `E`, normed space `E` over `ùïú`, and topological space `H`, the function `I` from `ùïú` to `E` defined in a Model With Corners `I` of types `ùïú`, `E`, and `H` is uniquely differentiable on its entire range.",{"type":"‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ùïú E H),\n  UniqueDiffOn ùïú (Set.range ‚ÜëI)","name":"ModelWithCorners.unique_diff","isProp":true,"docString":" For any nontrivially normed field `ùïú`, normed additive commutative group `E`, normed space `E` over `ùïú`, and topological space `H`, the function `I` from `ùïú` to `E` defined in a Model With Corners `I` of types `ùïú`, `E`, and `H` is uniquely differentiable on its entire range.","distance":2.01137008719689891478310528327710926532745361328125}],["The theorem `IsBot.isMin` states that for any type `Œ±` that has a less than or equal to ordering (`LE`), if an element `a` of `Œ±` is a bottom element (meaning it is less than or equal to every other element of `Œ±`), then `a` is also a minimal element (meaning that there is no element strictly less than it). In other words, if `a` is at the bottom of the order, it also serves as a minimal bound for the set.",{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±}, IsBot a ‚Üí IsMin a","name":"IsBot.isMin","isProp":true,"docString":"The theorem `IsBot.isMin` states that for any type `Œ±` that has a less than or equal to ordering (`LE`), if an element `a` of `Œ±` is a bottom element (meaning it is less than or equal to every other element of `Œ±`), then `a` is also a minimal element (meaning that there is no element strictly less than it). In other words, if `a` is at the bottom of the order, it also serves as a minimal bound for the set.","distance":2.008679624566979793343080018530599772930145263671875}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9885229119819534115976011889870278537273406982421875}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData ‚Üí Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":1.9904810934907237740532082170830108225345611572265625}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {K : Set F},\n  Convex ‚Ñù K ‚Üí ‚àÄ {u v : F}, v ‚àà K ‚Üí (‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9934316376847276419681520565063692629337310791015625}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {f : E ‚Üí Œ≤} {x y z : E}, ConcaveOn ùïú (segment ùïú x y) f ‚Üí z ‚àà segment ùïú x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9956170326579021345736464354558847844600677490234375}],["Default definition of `min`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.997519315101803361045540441409684717655181884765625}],["The minimum operation: `min x y`. ",{"type":"{Œ± : Type u} ‚Üí [self : Min Œ±] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":2.001348822187205112044239285751245915889739990234375}],["Turn an element of a type `F` satisfying `TopHomClass F Œ± Œ≤` into an actual\n`TopHom`. This is declared as the default coercion from `F` to `TopHom Œ± Œ≤`. ",{"type":"{F : Type u_1} ‚Üí\n  {Œ± : Type u_2} ‚Üí {Œ≤ : Type u_3} ‚Üí [inst : Top Œ±] ‚Üí [inst_1 : Top Œ≤] ‚Üí [inst_2 : TopHomClass F Œ± Œ≤] ‚Üí F ‚Üí TopHom Œ± Œ≤","name":"TopHomClass.toTopHom","isProp":false,"docString":"Turn an element of a type `F` satisfying `TopHomClass F Œ± Œ≤` into an actual\n`TopHom`. This is declared as the default coercion from `F` to `TopHom Œ± Œ≤`. ","distance":2.00220518680936176991735919727943837642669677734375}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"‚àÄ {d : ‚Ñ§} {a : Pell.Solution‚ÇÅ d}, a = 1 ‚à® a = -1 ‚Üî Pell.Solution‚ÇÅ.y a = 0","name":"Pell.Solution‚ÇÅ.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":2.00225320090402991723976811044849455356597900390625}],["Semigroup homomorphism between the function spaces `I ‚Üí Œ±` and `I ‚Üí Œ≤`, induced by a semigroup\nhomomorphism `f` between `Œ±` and `Œ≤`. ",{"type":"{Œ± : Type u_3} ‚Üí {Œ≤ : Type u_4} ‚Üí [inst : Mul Œ±] ‚Üí [inst_1 : Mul Œ≤] ‚Üí (Œ± ‚Üí‚Çô* Œ≤) ‚Üí (I : Type u_5) ‚Üí (I ‚Üí Œ±) ‚Üí‚Çô* I ‚Üí Œ≤","name":"MulHom.compLeft","isProp":false,"docString":"Semigroup homomorphism between the function spaces `I ‚Üí Œ±` and `I ‚Üí Œ≤`, induced by a semigroup\nhomomorphism `f` between `Œ±` and `Œ≤`. ","distance":2.002684569815902815292929517454467713832855224609375}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) ‚Üí (M : Type u_2) ‚Üí [inst : Semiring R] ‚Üí [inst_1 : AddCommGroup M] ‚Üí [inst : Module R M] ‚Üí ‚Ñï","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":2.003105281520417779717035955400206148624420166015625}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":2.003441366087160613318474133848212659358978271484375}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module ùïú Œ≤] [inst_3 : OrderedSMul ùïú Œ≤] {f : ùïú ‚Üí Œ≤} {x y z : ùïú},\n  ConcaveOn ùïú (Set.Icc x y) f ‚Üí z ‚àà Set.Icc x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.00383987911584160457323378068394958972930908203125}],["The value `BoxIntegral.IntegrationParams.GP = ‚ä•`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ‚ä•`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":2.00472874813026624707390510593540966510772705078125}],["Elaborate an `#align` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabAlign","isProp":false,"docString":"Elaborate an `#align` command. ","distance":2.00570292510378322958786156959831714630126953125}],["Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ",{"type":"{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ","distance":2.006419609310694074366665518027730286121368408203125}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name ‚Üí Simps.ParsedProjectionData ‚Üí List Lean.Level ‚Üí Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":2.006432985603556762299604088184423744678497314453125}],["The Bochner integral of a real-valued function `f : Œ± ‚Üí ‚Ñù` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ",{"type":"‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {f : Œ± ‚Üí ‚Ñù},\n  MeasureTheory.Integrable f ‚Üí\n    ‚à´ (a : Œ±), f a ‚àÇŒº =\n      ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (f a) ‚àÇŒº) - ENNReal.toReal (‚à´‚Åª (a : Œ±), ENNReal.ofReal (-f a) ‚àÇŒº)","name":"MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part","isProp":true,"docString":"The Bochner integral of a real-valued function `f : Œ± ‚Üí ‚Ñù` is the difference between the\nintegral of the positive part of `f` and the integral of the negative part of `f`.  ","distance":2.007200711290829442390304393484257161617279052734375}],["`kernImage f s` is the set of `y` such that `f ‚Åª¬π y ‚äÜ s`. ",{"type":"{Œ± : Type u} ‚Üí {Œ≤ : Type v} ‚Üí (Œ± ‚Üí Œ≤) ‚Üí Set Œ± ‚Üí Set Œ≤","name":"Set.kernImage","isProp":false,"docString":"`kernImage f s` is the set of `y` such that `f ‚Åª¬π y ‚äÜ s`. ","distance":2.007554841894258146339780068956315517425537109375}]]