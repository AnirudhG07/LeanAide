[["Lists all declarations with a long name, gathered according to the module they are defined in.\nUse as `#long_names` or `#long_names 100` to specify the length.\n",{"type":"Lean.ParserDescr","name":"«command#long_names_»","isProp":false,"docString":"Lists all declarations with a long name, gathered according to the module they are defined in.\nUse as `#long_names` or `#long_names 100` to specify the length.\n","distance":1.9652655029448580226159037920297123491764068603515625}],[" For any nontrivial type `α`, there exist `x` and `y` in `α` such that `x ≠ y`.",{"type":"∀ (α : Type u_3) [inst : Nontrivial α], ∃ x y, x ≠ y","name":"exists_pair_ne","isProp":true,"docString":" For any nontrivial type `α`, there exist `x` and `y` in `α` such that `x ≠ y`.","distance":1.9835481046557277284847486953367479145526885986328125}],["This theorem states that for any type `α` and any element `x` of that type, `α` is nontrivial if and only if there exists an element `y` in `α` which is not equal to `x`. In other words, a type is considered nontrivial when there's at least one instance of that type that's distinct from a given instance.",{"type":"∀ {α : Type u_1} (x : α), Nontrivial α ↔ ∃ y, y ≠ x","name":"nontrivial_iff_exists_ne","isProp":true,"docString":"This theorem states that for any type `α` and any element `x` of that type, `α` is nontrivial if and only if there exists an element `y` in `α` which is not equal to `x`. In other words, a type is considered nontrivial when there's at least one instance of that type that's distinct from a given instance.","distance":1.98422993754751164630079074413515627384185791015625}],["A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n",{"type":"(n m : ℕ) → Decidable (n = m)","name":"Nat.decEq","isProp":false,"docString":"A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n","distance":1.969328083156453690349962926120497286319732666015625}],[" If `α` is a nonempty type and `f : α -> β` is a function, then `β` is a nonempty type.",{"type":"∀ {α : Sort u_4} {β : Sort u_5}, (α → β) → Nonempty α → Nonempty β","name":"Nonempty.map","isProp":true,"docString":" If `α` is a nonempty type and `f : α -> β` is a function, then `β` is a nonempty type.","distance":1.9846509630270807722496329006389714777469635009765625}],["This theorem states that for all types `α` that are nontrivial (i.e., there are at least two distinct elements in `α`), given any element `x` from `α`, there exists another element `y` in `α` such that `y` is not equal to `x`. In other words, in any nontrivial type, for every element, there is always another distinct element.",{"type":"∀ {α : Type u_1} [inst : Nontrivial α] (x : α), ∃ y, y ≠ x","name":"exists_ne","isProp":true,"docString":"This theorem states that for all types `α` that are nontrivial (i.e., there are at least two distinct elements in `α`), given any element `x` from `α`, there exists another element `y` in `α` such that `y` is not equal to `x`. In other words, in any nontrivial type, for every element, there is always another distinct element.","distance":1.98791726416518610420780532876960933208465576171875}],["This can't be an instance because Lean wouldn't know how to find `N`, but we can still use\nthis to manually derive `SMulMemClass` on specific types. ",{"type":"∀ (S : Type u_1) (M : Type u_2) (N : Type u_3) (α : Type u_4) [inst : SetLike S α] [inst_1 : SMul M N]\n  [inst_2 : SMul M α] [inst_3 : Monoid N] [inst_4 : MulAction N α] [inst_5 : SMulMemClass S N α]\n  [inst_6 : IsScalarTower M N α], SMulMemClass S M α","name":"SMulMemClass.ofIsScalarTower","isProp":true,"docString":"This can't be an instance because Lean wouldn't know how to find `N`, but we can still use\nthis to manually derive `SMulMemClass` on specific types. ","distance":1.9756786826045338312241028688731603324413299560546875}],["An order is (noncomputably) either an `OrderBot` or a `NoBotOrder`. Use as\n`casesI botOrderOrNoBotOrder α`. ",{"type":"(α : Type u_3) → [inst : LE α] → OrderBot α ⊕' NoBotOrder α","name":"botOrderOrNoBotOrder","isProp":false,"docString":"An order is (noncomputably) either an `OrderBot` or a `NoBotOrder`. Use as\n`casesI botOrderOrNoBotOrder α`. ","distance":1.9769296773179423354349637520499527454376220703125}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name → Bool) → Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.9838566093529881317891749858972616493701934814453125}],["Find a synthetic typeclass metavariable with no expr metavariables in its type. ",{"type":"Lean.TSyntax `Lean.Parser.Term.bracketedBinder → Lean.Elab.TermElabM (Option Lean.MVarId)","name":"Mathlib.Command.Variable.pendingActionableSynthMVar","isProp":false,"docString":"Find a synthetic typeclass metavariable with no expr metavariables in its type. ","distance":1.9858922662004181436401495375321246683597564697265625}],["Creates a `TypeName` instance.\n\nFor safety, it is required that the constant `typeName` is definitionally equal\nto `α`.\n",{"type":"(α : Type u) → Lean.Name → TypeName α","name":"TypeName.mk","isProp":false,"docString":"Creates a `TypeName` instance.\n\nFor safety, it is required that the constant `typeName` is definitionally equal\nto `α`.\n","distance":1.9866219205218140775315305290860123932361602783203125}],["Generates a proxy type for the inductive type and an equivalence from the proxy type to the type.\n\nIf the declarations already exist, there is a check that they are correct.\n",{"type":"Mathlib.ProxyType.ProxyEquivConfig → Lean.InductiveVal → Lean.Elab.TermElabM Unit","name":"Mathlib.ProxyType.ensureProxyEquiv","isProp":false,"docString":"Generates a proxy type for the inductive type and an equivalence from the proxy type to the type.\n\nIf the declarations already exist, there is a check that they are correct.\n","distance":1.987949874095954694297461173846386373043060302734375}],["First samples a proxy value and interprets it. Especially useful if\nthe proxy and target type are the same. ",{"type":"(α : Type u) → [inst : SlimCheck.SampleableExt α] → SlimCheck.Gen α","name":"SlimCheck.SampleableExt.interpSample","isProp":false,"docString":"First samples a proxy value and interprets it. Especially useful if\nthe proxy and target type are the same. ","distance":1.98877379993127423318810542696155607700347900390625}],["Simple diagonal recursor for `Nat`\n",{"type":"{motive : ℕ → ℕ → Sort u_1} →\n  ((n : ℕ) → motive 0 n) →\n    ((m : ℕ) → motive m 0) → ((m n : ℕ) → motive m n → motive (m + 1) (n + 1)) → (m n : ℕ) → motive m n","name":"Nat.recDiagAux","isProp":false,"docString":"Simple diagonal recursor for `Nat`\n","distance":1.9900757568511995287963145528919994831085205078125}],["The order type of an element inside a well order. For the embedding as a principal segment, see\n`typein.principalSeg`. ",{"type":"{α : Type u} → (r : α → α → Prop) → [inst : IsWellOrder α r] → α → Ordinal.{u}","name":"Ordinal.typein","isProp":false,"docString":"The order type of an element inside a well order. For the embedding as a principal segment, see\n`typein.principalSeg`. ","distance":1.990146688758672066654753507464192807674407958984375}],["Gets the word size of the platform. That is, whether the platform is 64 or 32 bits. ",{"type":"ℕ","name":"System.Platform.numBits","isProp":false,"docString":"Gets the word size of the platform. That is, whether the platform is 64 or 32 bits. ","distance":1.990169574724799606002534346771426498889923095703125}],["Tail-recursive version of `Nat.any`. ",{"type":"(ℕ → Bool) → ℕ → Bool","name":"Nat.anyTR","isProp":false,"docString":"Tail-recursive version of `Nat.any`. ","distance":1.9906932449101493176613075775094330310821533203125}],["`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n",{"type":"Type (u + 1)","name":"NonemptyType","isProp":false,"docString":"`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n","distance":1.99106690216412562932646324043162167072296142578125}],["Generate a `Nat` example between `x` and `y` (exclusively). ",{"type":"(lo hi : ℕ) → lo < hi → SlimCheck.Gen { a // lo ≤ a ∧ a < hi }","name":"SlimCheck.Gen.chooseNatLt","isProp":false,"docString":"Generate a `Nat` example between `x` and `y` (exclusively). ","distance":1.991825261391710455427528358995914459228515625}],["A variation on `Classical.choice` that uses typeclass inference to\ninfer the proof of `Nonempty α`.\n",{"type":"{α : Sort u} → [inst : Nonempty α] → α","name":"Classical.ofNonempty","isProp":false,"docString":"A variation on `Classical.choice` that uses typeclass inference to\ninfer the proof of `Nonempty α`.\n","distance":1.99224753424269085400055701029486954212188720703125}],["`const x α` is an arrow that ignores its source and constructs a `TypeVec` that\ncontains nothing but `x` ",{"type":"{β : Type u_1} → β → {n : ℕ} → (α : TypeVec.{u_2} n) → TypeVec.Arrow α (TypeVec.repeat n β)","name":"TypeVec.const","isProp":false,"docString":"`const x α` is an arrow that ignores its source and constructs a `TypeVec` that\ncontains nothing but `x` ","distance":1.992306669061481017024561879225075244903564453125}],["Diagonal recursor for `Nat`\n",{"type":"{motive : ℕ → ℕ → Sort u_1} →\n  motive 0 0 →\n    ((n : ℕ) → motive 0 n → motive 0 (n + 1)) →\n      ((m : ℕ) → motive m 0 → motive (m + 1) 0) →\n        ((m n : ℕ) → motive m n → motive (m + 1) (n + 1)) → (m n : ℕ) → motive m n","name":"Nat.recDiag","isProp":false,"docString":"Diagonal recursor for `Nat`\n","distance":1.9931875662079947542082436484633944928646087646484375}],["`Erased α` is the same as `α`, except that the elements\nof `Erased α` are erased in the VM in the same way as types\nand proofs. This can be used to track data without storing it\nliterally. ",{"type":"Sort u → Sort (max 1 u)","name":"Erased","isProp":false,"docString":"`Erased α` is the same as `α`, except that the elements\nof `Erased α` are erased in the VM in the same way as types\nand proofs. This can be used to track data without storing it\nliterally. ","distance":1.996341130754719639384120455360971391201019287109375}],["Using `Classical.choice`, extracts a term from a `Nonempty` type. ",{"type":"{α : Sort u_2} → Nonempty α → α","name":"Nonempty.some","isProp":false,"docString":"Using `Classical.choice`, extracts a term from a `Nonempty` type. ","distance":1.9965863144699718123575848949258215725421905517578125}]]