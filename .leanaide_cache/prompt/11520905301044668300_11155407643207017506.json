[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9400351744358397265699522904469631612300872802734375}],[" If a type is both empty and a fintype, then its cardinality is zero.",{"type":"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : IsEmpty α], Fintype.card α = 0","name":"Fintype.card_of_isEmpty","isProp":true,"docString":" If a type is both empty and a fintype, then its cardinality is zero.","distance":1.9709971259473757498881241190247237682342529296875}],["This theorem states that for any topological space `α` and any discrete topological space `Y`, if `α` is preconnected and `f` is a continuous function from `α` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `α`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace α → ∀ {f : α → Y}, Continuous f → ∀ {x y : α}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"This theorem states that for any topological space `α` and any discrete topological space `Y`, if `α` is preconnected and `f` is a continuous function from `α` to `Y`, then the function `f` will produce the same output for any two inputs `x` and `y` from `α`. This is a version of `isPreconnected.constant` theorem specialized for `PreconnectedSpace`.","distance":1.9655857138273675754902569678961299359798431396484375}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.955967840638390242702371324412524700164794921875}],[" For any topological space `α` and pseudo metric space `β` with defined zero, the constant function `0 : α → β` equals the zero function.",{"type":"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : Zero β], ⇑0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":" For any topological space `α` and pseudo metric space `β` with defined zero, the constant function `0 : α → β` equals the zero function.","distance":1.9761411030580848802173932199366390705108642578125}],["The theorem `IsPreconnected.image` states that for any two types `α` and `β`, equipped with their respective topological spaces, and for any set `s` of type `α`, if `s` is preconnected and there is a function `f` from `α` to `β` that is continuous on `s`, then the image of `s` under `f` is also preconnected. In simpler terms, this theorem asserts that the continuous image of a preconnected set remains preconnected.",{"type":"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α},\n  IsPreconnected s → ∀ (f : α → β), ContinuousOn f s → IsPreconnected (f '' s)","name":"IsPreconnected.image","isProp":true,"docString":"The theorem `IsPreconnected.image` states that for any two types `α` and `β`, equipped with their respective topological spaces, and for any set `s` of type `α`, if `s` is preconnected and there is a function `f` from `α` to `β` that is continuous on `s`, then the image of `s` under `f` is also preconnected. In simpler terms, this theorem asserts that the continuous image of a preconnected set remains preconnected.","distance":1.9708777048038610413271953802905045449733734130859375}],["`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n",{"type":"Lean.Elab.Tactic.TacticM Unit → Lean.Expr → Lean.MetaM Lean.Expr","name":"Linarith.proveEqZeroUsing","isProp":false,"docString":"`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n","distance":1.9648581902519250963479180427384562790393829345703125}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadEnv m] → [inst : Lean.MonadError m] → Lean.Name → m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9662620955392691168839292004122398793697357177734375}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : TypeVec.Arrow Fin2.elim0 Fin2.elim0 → Sort u_1} →\n  β TypeVec.nilFun → (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) → β f","name":"TypeVec.typevecCasesNil₂","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9680667886926368481681492994539439678192138671875}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"∀ {d : ℤ} {a : Pell.Solution₁ d}, a = 1 ∨ a = -1 ↔ Pell.Solution₁.y a = 0","name":"Pell.Solution₁.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":1.9705726532965546216047414418426342308521270751953125}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace α → ∀ {f : α → Y}, Continuous f → ∀ {x y : α}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":1.9714569766048379850786886891000904142856597900390625}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) → (M : Type u_2) → [inst : Semiring R] → [inst_1 : AddCommGroup M] → [inst : Module R M] → ℕ","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":1.9717228399058008836419730869238264858722686767578125}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.97180141250779428219175315462052822113037109375}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Zero M₁] →\n      [inst_1 : Neg M₁] →\n        [inst_2 : NegZeroClass M₂] →\n          (f : M₁ → M₂) → Function.Injective f → f 0 = 0 → (∀ (x : M₁), f (-x) = -f x) → NegZeroClass M₁","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":1.971918276508315415185279562138020992279052734375}],["TODO: prove this in greater generality. ",{"type":"∀ {m : Type u_2} {n : Type u_3} {R : Type u_5} [inst : Fintype n] [inst_1 : Fintype m] [inst_2 : LinearOrderedField R]\n  (A : Matrix m n R), Matrix.rank (Matrix.transpose A) = Matrix.rank A","name":"Matrix.rank_transpose","isProp":true,"docString":"TODO: prove this in greater generality. ","distance":1.972225477015794314894492345047183334827423095703125}],["cases distinction for 0-length type vector ",{"type":"{β : TypeVec.{u_2} 0 → Sort u_1} → β Fin2.elim0 → (v : TypeVec.{u_2} 0) → β v","name":"TypeVec.casesNil","isProp":false,"docString":"cases distinction for 0-length type vector ","distance":1.9725389946907991856051012291572988033294677734375}],["Default definition of `min`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.972748424408480527603160226135514676570892333984375}],["Corresponds to `norm_zero`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)]\n  [inst_2 : (i : ι) → Zero (β i)], hammingNorm 0 = 0","name":"hammingNorm_zero","isProp":true,"docString":"Corresponds to `norm_zero`. ","distance":1.9735062427936569395825472383876331150531768798828125}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConcaveOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9740278996018882917695691503467969596385955810546875}],["The minimum operation: `min x y`. ",{"type":"{α : Type u} → [self : Min α] → α → α → α","name":"Min.min","isProp":false,"docString":"The minimum operation: `min x y`. ","distance":1.9750038680655876976999252292443998157978057861328125}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData → Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":1.9750182610669455574026187605340965092182159423828125}],["Semigroup homomorphism between the function spaces `I → α` and `I → β`, induced by a semigroup\nhomomorphism `f` between `α` and `β`. ",{"type":"{α : Type u_3} → {β : Type u_4} → [inst : Mul α] → [inst_1 : Mul β] → (α →ₙ* β) → (I : Type u_5) → (I → α) →ₙ* I → β","name":"MulHom.compLeft","isProp":false,"docString":"Semigroup homomorphism between the function spaces `I → α` and `I → β`, induced by a semigroup\nhomomorphism `f` between `α` and `β`. ","distance":1.97531979663736567687237766222096979618072509765625}],["Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. ",{"type":"{K : semiOutParam (Type u_1)} → [self : IsROrC K] → K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. ","distance":1.97592737457178291293757865787483751773834228515625}],["Elaborate an `#align` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabAlign","isProp":false,"docString":"Elaborate an `#align` command. ","distance":1.9767650772894460597939314538962207734584808349609375}]]