[["Tests whether `declName` has the `@[simp]` attribute in `env`. ",{"type":"Lean.Environment → Lean.Name → Bool","name":"hasSimpAttribute","isProp":false,"docString":"Tests whether `declName` has the `@[simp]` attribute in `env`. ","distance":1.98174289674613390843660454265773296356201171875}],[" If the product of a list of integers is `-1`, then the list contains an `-1`.",{"type":"∀ {l : List ℤ}, l.prod = -1 → -1 ∈ l","name":"List.neg_one_mem_of_prod_eq_neg_one","isProp":true,"docString":" If the product of a list of integers is `-1`, then the list contains an `-1`.","distance":1.995426758470219663621492145466618239879608154296875}],["The theorem `one_le_kstar` states that for any given type `α` which is an instance of `KleeneAlgebra`, and for any element `a` of type `α`, `1` is less than or equal to `kstar` of `a`. Here, `KStar.kstar` is a function that takes an element from the Kleene algebra and returns an element of the same type. The comparison `1 ≤ KStar.kstar a` is made with respect to the partial order defined by the Kleene algebra structure on `α`.",{"type":"∀ {α : Type u_1} [inst : KleeneAlgebra α] {a : α}, 1 ≤ KStar.kstar a","name":"one_le_kstar","isProp":true,"docString":"The theorem `one_le_kstar` states that for any given type `α` which is an instance of `KleeneAlgebra`, and for any element `a` of type `α`, `1` is less than or equal to `kstar` of `a`. Here, `KStar.kstar` is a function that takes an element from the Kleene algebra and returns an element of the same type. The comparison `1 ≤ KStar.kstar a` is made with respect to the partial order defined by the Kleene algebra structure on `α`.","distance":2.00107685468682472418322504381649196147918701171875}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9838114706685043842071536346338689327239990234375}],[" A category has the initial-terminal object property (is an InitialMonoClass) if the unique morphism from the initial object to the terminal object is a monomorphism.",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\n  CategoryTheory.Limits.IsTerminal T → CategoryTheory.Mono (hI.to T) → CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.InitialMonoClass.of_isTerminal","isProp":true,"docString":" A category has the initial-terminal object property (is an InitialMonoClass) if the unique morphism from the initial object to the terminal object is a monomorphism.","distance":1.996928171170850863092027793754823505878448486328125}],["The theorem `min_self` states that for all types `α` which have a `LinearOrder` instance, the minimum of a value `a` and itself is always `a`. In other words, for any type `α` that can be ordered in a linear fashion (like integers or real numbers), if you compare a value with itself, the smaller value is always going to be the value itself.",{"type":"∀ {α : Type u} [inst : LinearOrder α] (a : α), min a a = a","name":"min_self","isProp":true,"docString":"The theorem `min_self` states that for all types `α` which have a `LinearOrder` instance, the minimum of a value `a` and itself is always `a`. In other words, for any type `α` that can be ordered in a linear fashion (like integers or real numbers), if you compare a value with itself, the smaller value is always going to be the value itself.","distance":2.00701085652077981791308047831989824771881103515625}],["A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit c →\n                    [inst_3 : CategoryTheory.Limits.PreservesColimit K F] →\n                      CategoryTheory.Limits.IsColimit (F.mapCocone c)","name":"CategoryTheory.Limits.isColimitOfPreserves","isProp":false,"docString":"A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":1.9867804955967311997255819733254611492156982421875}],["Given an equality, extract a `Category` instance from it or raise an error.\nReturns the name of the category and its instance. ",{"type":"Lean.Expr → Lean.MetaM (Lean.Expr × Lean.Expr)","name":"Tactic.Elementwise.elementwiseExpr.extractCatInstance","isProp":false,"docString":"Given an equality, extract a `Category` instance from it or raise an error.\nReturns the name of the category and its instance. ","distance":1.990720986175671836093670208356343209743499755859375}],["`simpsTac` derives `simp` lemmas for all (nested) non-Prop projections of the declaration.\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\nIf `shortNm` is true, the generated names will only use the last projection name.\nIf `trc` is true, trace as if `trace.simps.verbose` is true. ",{"type":"Lean.Syntax →\n  Lean.Name →\n    optParam Simps.Config\n        { isSimp := true, attrs := [], simpRhs := false, typeMd := Lean.Meta.TransparencyMode.instances,\n          rhsMd := Lean.Meta.TransparencyMode.reducible, fullyApplied := true,\n          notRecursive := [`Prod, `PProd, `Opposite, `PreOpposite], debug := false } →\n      optParam (List (String × Lean.Syntax)) [] → optParam Bool false → Lean.AttrM (Array Lean.Name)","name":"simpsTac","isProp":false,"docString":"`simpsTac` derives `simp` lemmas for all (nested) non-Prop projections of the declaration.\nIf `todo` is non-empty, it will generate exactly the names in `todo`.\nIf `shortNm` is true, the generated names will only use the last projection name.\nIf `trc` is true, trace as if `trace.simps.verbose` is true. ","distance":1.9920782740139453270700187204056419432163238525390625}],["The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9923733820679012662679951972677372395992279052734375}],["A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit (F.mapCocone c) →\n                    [inst_3 : CategoryTheory.Limits.ReflectsColimit K F] → CategoryTheory.Limits.IsColimit c","name":"CategoryTheory.Limits.isColimitOfReflects","isProp":false,"docString":"A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":1.9923887341204256085092083594645373523235321044921875}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name → Bool) → Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.9947283483726032660143800967489369213581085205078125}],["Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : ℕ → Type u_2} → ((n : ℕ) → E n) → Set ((n : ℕ) → E n) → ℕ","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":1.996838907674675311909595620818436145782470703125}],["Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ",{"type":"{E : ℕ → Type u_2} → ((n : ℕ) → E n) → Set ((n : ℕ) → E n) → ℕ","name":"PiNat.longestPrefix","isProp":false,"docString":"Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ","distance":1.9971015589458007699619201957830227911472320556640625}],["A functor between preadditive categories preserves all equalizers if it preserves all kernels.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.Preadditive C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.Preadditive D] →\n            (F : CategoryTheory.Functor C D) →\n              [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms F] →\n                [inst_5 : CategoryTheory.Limits.HasBinaryBiproducts C] →\n                  [inst_6 :\n                      {X Y : C} →\n                        (f : X ⟶ Y) → CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F] →\n                    CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F","name":"CategoryTheory.Functor.preservesEqualizersOfPreservesKernels","isProp":false,"docString":"A functor between preadditive categories preserves all equalizers if it preserves all kernels.\n","distance":2.003700183630686471047965824254788458347320556640625}],["Checks whether `completionPos` points at a free space in the header. ",{"type":"Lean.Syntax → String.Pos → Bool","name":"ImportCompletion.isImportCmdCompletionRequest","isProp":false,"docString":"Checks whether `completionPos` points at a free space in the header. ","distance":2.003804441304676942081641755066812038421630859375}],["Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n",{"type":"{ω : Type u_1} →\n  {α : Type} →\n    (prio : α → Thunk ω) →\n      (ε : α → Type) →\n        [inst : LinearOrder ω] →\n          [inst_1 : (a : α) → Estimator (prio a) (ε a)] →\n            [I : ∀ (a : α), WellFoundedGT ↑(Set.range (EstimatorData.bound (prio a)))] →\n              [inst : Ord ω] →\n                [inst : Ord α] →\n                  {m : Type → Type} →\n                    [inst : Monad m] →\n                      [inst : Alternative m] →\n                        [inst : (a : α) → Bot (ε a)] → Option ℕ → (α → MLList m α) → α → MLList m α","name":"impl","isProp":false,"docString":"Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n","distance":2.0047608646724999204025152721442282199859619140625}],["Turn an element of a type `F` satisfying `StarAlgHomClass F R A B` into an actual\n`StarAlgHom`. This is declared as the default coercion from `F` to `A →⋆ₐ[R] B`. ",{"type":"{F : Type u_1} →\n  {R : Type u_2} →\n    {A : Type u_3} →\n      {B : Type u_4} →\n        [inst : CommSemiring R] →\n          [inst_1 : Semiring A] →\n            [inst_2 : Algebra R A] →\n              [inst_3 : Star A] →\n                [inst_4 : Semiring B] →\n                  [inst_5 : Algebra R B] → [inst_6 : Star B] → [hF : StarAlgHomClass F R A B] → F → A →⋆ₐ[R] B","name":"StarAlgHomClass.toStarAlgHom","isProp":false,"docString":"Turn an element of a type `F` satisfying `StarAlgHomClass F R A B` into an actual\n`StarAlgHom`. This is declared as the default coercion from `F` to `A →⋆ₐ[R] B`. ","distance":2.00531439278320267050048641976900398731231689453125}],["Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n",{"type":"Lean.Syntax →\n  Lean.Name →\n    optParam Bool false →\n      optParam (Array Simps.ProjectionRule) #[] →\n        optParam Bool false → Lean.CoreM (List Lean.Name × Array Simps.ProjectionData)","name":"Simps.getRawProjections","isProp":false,"docString":"Get the projections used by `simps` associated to a given structure `str`.\n\nThe returned information is also stored in the environment extension `Simps.structureExt`, which\nis given to `str`. If `str` already has this attribute, the information is read from this\nextension instead. See the documentation for this extension for the data this tactic returns.\n\nThe returned universe levels are the universe levels of the structure. For the projections there\nare three cases\n* If the declaration `{StructureName}.Simps.{projectionName}` has been declared, then the value\n  of this declaration is used (after checking that it is definitionally equal to the actual\n  projection. If you rename the projection name, the declaration should have the *new* projection\n  name.\n* You can also declare a custom projection that is a composite of multiple projections.\n* Otherwise, for every class with the `notation_class` attribute, and the structure has an\n  instance of that notation class, then the projection of that notation class is used for the\n  projection that is definitionally equal to it (if there is such a projection).\n  This means in practice that coercions to function types and sorts will be used instead of\n  a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n  notation classes like `Mul` and `Zero` those projections are used instead of the\n  corresponding projection.\n  Projections for coercions and notation classes are not automatically generated if they are\n  composites of multiple projections (for example when you use `extend` without the\n  `oldStructureCmd` (does this exist?)).\n* Otherwise, the projection of the structure is chosen.\n  For example: ``getRawProjections env `Prod`` gives the default projections.\n```\n  ([u, v], [(`fst, `(Prod.fst.{u v}), [0], true, false),\n     (`snd, `(@Prod.snd.{u v}), [1], true, false)])\n```\n\nOptionally, this command accepts three optional arguments:\n* If `traceIfExists` the command will always generate a trace message when the structure already\n  has an entry in `structureExt`.\n* The `rules` argument specifies whether projections should be added, renamed, used as prefix, and\n  not used by default.\n* if `trc` is true, this tactic will trace information just as if\n  `set_option trace.simps.verbose true` was set.\n","distance":2.005385109217838301987058002850972115993499755859375}],["A variant of `prod_range_succ` which pulls off the first\nterm in the product rather than the last.",{"type":"∀ {α : Type u} [inst : Monoid α] (f : ℕ → α) (n : ℕ),\n  List.prod (List.map f (List.range (Nat.succ n))) = f 0 * List.prod (List.map (fun i => f (Nat.succ i)) (List.range n))","name":"List.prod_range_succ'","isProp":true,"docString":"A variant of `prod_range_succ` which pulls off the first\nterm in the product rather than the last.","distance":2.00555828887959552986330891144461929798126220703125}],["The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ",{"type":"∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  (f : WithLp p (α × β)), edist f f = 0","name":"WithLp.prod_edist_self","isProp":true,"docString":"The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ","distance":2.005734109558098499093148348038084805011749267578125}],["`Lp.simpleFunc` is a subspace of Lp consisting of equivalence classes of an integrable simple\nfunction. ",{"type":"Lean.TrailingParserDescr","name":"MeasureTheory.«term_→₁ₛ[_]_»","isProp":false,"docString":"`Lp.simpleFunc` is a subspace of Lp consisting of equivalence classes of an integrable simple\nfunction. ","distance":2.00582360270842396943180574453435838222503662109375}],["The product comparison morphism from `F(A ⨯ -)` to `FA ⨯ F-`, whose components are given by\n`prodComparison`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{w, u₂} D] →\n        [inst_2 : CategoryTheory.Limits.HasBinaryProducts C] →\n          [inst_3 : CategoryTheory.Limits.HasBinaryProducts D] →\n            (F : CategoryTheory.Functor C D) →\n              (A : C) →\n                CategoryTheory.Functor.comp (CategoryTheory.Limits.prod.functor.obj A) F ⟶\n                  CategoryTheory.Functor.comp F (CategoryTheory.Limits.prod.functor.obj (F.obj A))","name":"CategoryTheory.Limits.prodComparisonNatTrans","isProp":false,"docString":"The product comparison morphism from `F(A ⨯ -)` to `FA ⨯ F-`, whose components are given by\n`prodComparison`.\n","distance":2.007309239439174053387660023872740566730499267578125}],["A simpler version of `Respects` when the state transition relation `tr` is a function. ",{"type":"{σ₁ : Type u_1} → {σ₂ : Type u_2} → (σ₂ → Option σ₂) → (σ₁ → σ₂) → σ₂ → Option σ₁ → Prop","name":"Turing.FRespects","isProp":false,"docString":"A simpler version of `Respects` when the state transition relation `tr` is a function. ","distance":2.00731615201031221573657603585161268711090087890625}]]