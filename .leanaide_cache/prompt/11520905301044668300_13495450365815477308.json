[["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) → [inst : CategoryTheory.Category.{v, u} C] → [inst : CategoryTheory.Limits.HasZeroObject C] → Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.98724491337078834618523615063168108463287353515625}],[" If a function `f : α → E` reaches the maximum norm at a point `c` in a filter `l`, then the function `x => ||f x + y||` also reaches the maximum norm at `c` for any vector `y` on the ray through `fc`.",{"type":"∀ {α : Type u_1} {E : Type u_3} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : α → E} {l : Filter α}\n  {c : α} {y : E}, IsMaxFilter (norm ∘ f) l c → SameRay ℝ (f c) y → IsMaxFilter (fun x => ‖f x + y‖) l c","name":"IsMaxFilter.norm_add_sameRay","isProp":true,"docString":" If a function `f : α → E` reaches the maximum norm at a point `c` in a filter `l`, then the function `x => ||f x + y||` also reaches the maximum norm at `c` for any vector `y` on the ray through `fc`.","distance":2.014637994168173573683588983840309083461761474609375}],["This theorem, named `Path.Homotopic.proj_pi`, states that for all types `ι` and `as`, `bs` functions from `ι` to some type `X` (where each `X i` is a topological space), and any index `i` in `ι`, when we take a family of path homotopy classes `paths` (each path being from `as i` to `bs i` for some `i` in `ι`), and form a product of these path homotopy classes using the `Path.Homotopic.pi` function, projecting back to the `i`th coordinate using the `Path.Homotopic.proj` function gives us the original path homotopy class at `i` in the `paths` family. In other words, the projection operation is the inverse of the pi operation in the context of path homotopy classes.",{"type":"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {as bs : (i : ι) → X i} (i : ι)\n  (paths : (i : ι) → Path.Homotopic.Quotient (as i) (bs i)), Path.Homotopic.proj i (Path.Homotopic.pi paths) = paths i","name":"Path.Homotopic.proj_pi","isProp":true,"docString":"This theorem, named `Path.Homotopic.proj_pi`, states that for all types `ι` and `as`, `bs` functions from `ι` to some type `X` (where each `X i` is a topological space), and any index `i` in `ι`, when we take a family of path homotopy classes `paths` (each path being from `as i` to `bs i` for some `i` in `ι`), and form a product of these path homotopy classes using the `Path.Homotopic.pi` function, projecting back to the `i`th coordinate using the `Path.Homotopic.proj` function gives us the original path homotopy class at `i` in the `paths` family. In other words, the projection operation is the inverse of the pi operation in the context of path homotopy classes.","distance":2.011918986450116353381645240006037056446075439453125}],["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] → [inst_1 : MetricSpace P] → [inst_2 : NormedAddTorsor V P] → AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.9877123435222305847247525889542885124683380126953125}],[" The sign of integer 0 is 0. (or equivalently, Int.sign 0 = 0)",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":" The sign of integer 0 is 0. (or equivalently, Int.sign 0 = 0)","distance":2.021557124486941692254049485200084745883941650390625}],["The theorem `Primrec.fst` states that for all types `α` and `β` which have a primitive recursive encoding (i.e., they are instances of the `Primcodable` class), the first projection function `Prod.fst` is a primitive recursive function. In other words, given a pair of elements `(a, b)` where `a` is from type `α` and `b` is from type `β`, the function that retrieves the first element `a` from the pair is a primitive recursive function.",{"type":"∀ {α : Type u_3} {β : Type u_4} [inst : Primcodable α] [inst_1 : Primcodable β], Primrec Prod.fst","name":"Primrec.fst","isProp":true,"docString":"The theorem `Primrec.fst` states that for all types `α` and `β` which have a primitive recursive encoding (i.e., they are instances of the `Primcodable` class), the first projection function `Prod.fst` is a primitive recursive function. In other words, given a pair of elements `(a, b)` where `a` is from type `α` and `b` is from type `β`, the function that retrieves the first element `a` from the pair is a primitive recursive function.","distance":2.020836669623232495496267802082002162933349609375}],["If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ",{"type":"{α : Type u} → Task α → α","name":"Task.get","isProp":false,"docString":"If `task : Task α` then `task.get : α` blocks the current thread until the\nvalue is available, and then returns the result of the task. ","distance":1.9944047749029383265195747299003414809703826904296875}],["Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n",{"type":"(α : Sort u) → α → Sort u","name":"optParam","isProp":false,"docString":"Gadget for optional parameter support.\n\nA binder like `(x : α := default)` in a declaration is syntax sugar for\n`x : optParam α default`, and triggers the elaborator to attempt to use\n`default` to supply the argument if it is not supplied.\n","distance":1.995286240005052835755350315594114363193511962890625}],["A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit (F.mapCocone c) →\n                    [inst_3 : CategoryTheory.Limits.ReflectsColimit K F] → CategoryTheory.Limits.IsColimit c","name":"CategoryTheory.Limits.isColimitOfReflects","isProp":false,"docString":"A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":1.999433423753384619914186259848065674304962158203125}],["Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ",{"type":"{α : Prop} → {p : α → Prop} → {C : Sort u_1} → C → ((a : α) → p a → C) → C","name":"Classical.existsCases","isProp":false,"docString":"Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate. ","distance":2.0007256282610708097990936948917806148529052734375}],["Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n",{"type":"Sort u → Sort u","name":"semiOutParam","isProp":false,"docString":"Gadget for marking semi output parameters in type classes.\n\nSemi-output parameters influence the order in which arguments to type class\ninstances are processed.  Lean determines an order where all non-(semi-)output\nparameters to the instance argument have to be figured out before attempting to\nsynthesize an argument (that is, they do not contain assignable metavariables\ncreated during TC synthesis). This rules out instances such as `[Mul β] : Add\nα` (because `β` could be anything). Marking a parameter as semi-output is a\npromise that instances of the type class will always fill in a value for that\nparameter.\n\nFor example, the `Coe` class is defined as:\n```\nclass Coe (α : semiOutParam (Sort u)) (β : Sort v)\n```\nThis means that all `Coe` instances should provide a concrete value for `α`\n(i.e., not an assignable metavariable). An instance like `Coe Nat Int` or `Coe\nα (Option α)` is fine, but `Coe α Nat` is not since it does not provide a value\nfor `α`.\n","distance":2.0007968027145697220703368657268583774566650390625}],["Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.",{"type":"Lean.Name → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.mkParsedProjectionData","isProp":false,"docString":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.","distance":2.002511308791422361963441289844922721385955810546875}],["Delaborator that prints the current application with universe parameters on the head symbol,\nunless `pp.universes` is explicitly set to `false`.\n",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"Mathlib.PPWithUniv.delabWithUniv","isProp":false,"docString":"Delaborator that prints the current application with universe parameters on the head symbol,\nunless `pp.universes` is explicitly set to `false`.\n","distance":2.003310345243813461735271630459465086460113525390625}],["Construct a bundled `MeasCat` from the underlying type and the typeclass. ",{"type":"(α : Type u) → [ms : MeasurableSpace α] → MeasCat","name":"MeasCat.of","isProp":false,"docString":"Construct a bundled `MeasCat` from the underlying type and the typeclass. ","distance":2.006904338413045163491688072099350392818450927734375}],["If a structure has a field that corresponds to a coercion to functions or sets, or corresponds\n  to notation, find the custom projection that uses this coercion or notation.\n  Returns the custom projection and the name of the projection used.\n\nWe catch most errors this function causes, so that we don't fail if an unrelated projection has\nan applicable name. (e.g. `Iso.inv`)\n\nImplementation note: getting rid of TermElabM is tricky, since `Expr.mkAppOptM` doesn't allow to\nkeep metavariables around, which are necessary for `OutParam`. ",{"type":"Lean.Name → Simps.ParsedProjectionData → Array Lean.Expr → Lean.Elab.TermElabM (Option (Lean.Expr × Lean.Name))","name":"Simps.findAutomaticProjectionsAux","isProp":false,"docString":"If a structure has a field that corresponds to a coercion to functions or sets, or corresponds\n  to notation, find the custom projection that uses this coercion or notation.\n  Returns the custom projection and the name of the projection used.\n\nWe catch most errors this function causes, so that we don't fail if an unrelated projection has\nan applicable name. (e.g. `Iso.inv`)\n\nImplementation note: getting rid of TermElabM is tricky, since `Expr.mkAppOptM` doesn't allow to\nkeep metavariables around, which are necessary for `OutParam`. ","distance":2.00700218139710440112821743241511285305023193359375}],["The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. ",{"type":"{α : Sort u} → (x : α) → {β : Sort v} → [self : CoeDep α x β] → β","name":"CoeDep.coe","isProp":false,"docString":"The resulting value of type `β`. The input `x : α` is a parameter to\nthe type class, so the value of type `β` may possibly depend on additional\ntypeclasses on `x`. ","distance":2.007309278729069834668052862980403006076812744140625}],["`f : α →+* β` has a trivial codomain iff its range is `{0}`. ",{"type":"∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β),\n  0 = 1 ↔ Set.range ⇑f = {0}","name":"RingHom.codomain_trivial_iff_range_eq_singleton_zero","isProp":true,"docString":"`f : α →+* β` has a trivial codomain iff its range is `{0}`. ","distance":2.007780192474246661049619433470070362091064453125}],["Given an element of the iterated product `l.Prod α`, take a projection into direction `i`.\nIf `i` appears multiple times in `l`, this chooses the first component in direction `i`. ",{"type":"{ι : Type u} → {α : ι → Type v} → [inst : DecidableEq ι] → {l : List ι} → List.TProd α l → {i : ι} → i ∈ l → α i","name":"List.TProd.elim","isProp":false,"docString":"Given an element of the iterated product `l.Prod α`, take a projection into direction `i`.\nIf `i` appears multiple times in `l`, this chooses the first component in direction `i`. ","distance":2.007946933153399005078654226963408291339874267578125}],["`className` is the name of the class we are looking for. ",{"type":"Simps.AutomaticProjectionData → Lean.Name","name":"Simps.AutomaticProjectionData.className","isProp":false,"docString":"`className` is the name of the class we are looking for. ","distance":2.00819996203444706139862319105304777622222900390625}],["Retrieves the value of `a : Part α` if it exists, and return the provided default value\notherwise. ",{"type":"{α : Type u_1} → (a : Part α) → [inst : Decidable a.Dom] → α → α","name":"Part.getOrElse","isProp":false,"docString":"Retrieves the value of `a : Part α` if it exists, and return the provided default value\notherwise. ","distance":2.00885253015648057584030539146624505519866943359375}],["An estimator for the priority of the key.\n(We will assume we have `[∀ a : α, Estimator (prio a) (ε a)]`.) ",{"type":"{α : Sort u_1} → {ω : Type u_2} → {prio : α → Thunk ω} → {ε : α → Type} → (self : BestFirstNode prio ε) → ε self.key","name":"BestFirstNode.estimator","isProp":false,"docString":"An estimator for the priority of the key.\n(We will assume we have `[∀ a : α, Estimator (prio a) (ε a)]`.) ","distance":2.00891414057497552647646443801932036876678466796875}],["Load an object from disk.\nNote: The returned `CompactedRegion` can be used to free the memory behind the value\nof type `α`, using `CompactedRegion.free` (which is only safe once all references to the `α` are\nreleased). Ignoring the `CompactedRegion` results in the data being leaked.\nUse `withUnpickle` to call `CompactedRegion.free` automatically.\n\nThis function is unsafe because the data being loaded may not actually have type `α`, and this\nmay cause crashes or other bad behavior.\n",{"type":"(α : Type) → System.FilePath → IO (α × Lean.CompactedRegion)","name":"unpickle","isProp":false,"docString":"Load an object from disk.\nNote: The returned `CompactedRegion` can be used to free the memory behind the value\nof type `α`, using `CompactedRegion.free` (which is only safe once all references to the `α` are\nreleased). Ignoring the `CompactedRegion` results in the data being leaked.\nUse `withUnpickle` to call `CompactedRegion.free` automatically.\n\nThis function is unsafe because the data being loaded may not actually have type `α`, and this\nmay cause crashes or other bad behavior.\n","distance":2.008926217790999668721951820771209895610809326171875}],["`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n",{"type":"{α : Sort u} → [i : α] → α","name":"inferInstance","isProp":false,"docString":"`inferInstance` synthesizes a value of any target type by typeclass\ninference. This function has the same type signature as the identity\nfunction, but the square brackets on the `[i : α]` argument means that it will\nattempt to construct this argument by typeclass inference. (This will fail if\n`α` is not a `class`.) Example:\n```\n#check (inferInstance : Inhabited Nat) -- Inhabited Nat\n\ndef foo : Inhabited (Nat × Nat) :=\n  inferInstance\n\nexample : foo.default = (default, default) :=\n  rfl\n```\n","distance":2.009288397561148631353944438160397112369537353515625}],["The epimorphism `projective.π : projective.over X ⟶ X`\nfrom the arbitrarily chosen projective object over `X`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.EnoughProjectives C] → (X : C) → CategoryTheory.Projective.over X ⟶ X","name":"CategoryTheory.Projective.π","isProp":false,"docString":"The epimorphism `projective.π : projective.over X ⟶ X`\nfrom the arbitrarily chosen projective object over `X`.\n","distance":2.009526418994631580261511771823279559612274169921875}]]