[["Additive closure of an additive submonoid `S` equals `S`",{"type":"∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), AddSubmonoid.closure ↑S = S","name":"AddSubmonoid.closure_eq","isProp":true,"docString":"Additive closure of an additive submonoid `S` equals `S`","distance":1.8652174448359810643438549959682859480381011962890625}],[" For any type `α` and `x` in `WithBot α`, if `x ≠ ⊥`, then `WithBot.unbot x = x.up`.",{"type":"∀ {α : Type u_1} (x : WithBot α) (hx : x ≠ ⊥), ↑(x.unbot hx) = x","name":"WithBot.coe_unbot","isProp":true,"docString":" For any type `α` and `x` in `WithBot α`, if `x ≠ ⊥`, then `WithBot.unbot x = x.up`.","distance":1.8566681564779659030506309136399067938327789306640625}],["This theorem, referred to as `TopHom.map_top'`, states that for any two types `α` and `β` that have a top element (denoted as `⊤`), any homomorphism from `α` to `β` (denoted as `self : TopHom α β`) will preserve the top element. In other words, applying the function `self.toFun` to the top element of `α` will yield the top element of `β`. This property is often referred to as \"mapping the top element\", hence the alternate name `map_top`.",{"type":"∀ {α : Type u_6} {β : Type u_7} [inst : Top α] [inst_1 : Top β] (self : TopHom α β), self.toFun ⊤ = ⊤","name":"TopHom.map_top'","isProp":true,"docString":"This theorem, referred to as `TopHom.map_top'`, states that for any two types `α` and `β` that have a top element (denoted as `⊤`), any homomorphism from `α` to `β` (denoted as `self : TopHom α β`) will preserve the top element. In other words, applying the function `self.toFun` to the top element of `α` will yield the top element of `β`. This property is often referred to as \"mapping the top element\", hence the alternate name `map_top`.","distance":1.8707412946266475106682491968967951834201812744140625}],["The underlying presheaf of `sheafHom F G`. It is isomorphic to `presheafHom F.1 G.1`\n(see `sheafHom'Iso`), but has better definitional properties. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {J : CategoryTheory.GrothendieckTopology C} →\n      {A : Type u'} →\n        [inst_1 : CategoryTheory.Category.{v', u'} A] →\n          CategoryTheory.Sheaf J A → CategoryTheory.Sheaf J A → CategoryTheory.Functor Cᵒᵖ (Type (max (max u v) v'))","name":"CategoryTheory.sheafHom'","isProp":false,"docString":"The underlying presheaf of `sheafHom F G`. It is isomorphic to `presheafHom F.1 G.1`\n(see `sheafHom'Iso`), but has better definitional properties. ","distance":1.8656144358956445739039509135182015597820281982421875}],[" For any type `R` with an `AddGroupWithOne` structure, the integer and natural number homomorphisms from `ℤ` and `ℕ` to `R` agree.",{"type":"∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ), IntCast.intCast ↑n = ↑n","name":"AddGroupWithOne.intCast_ofNat","isProp":true,"docString":" For any type `R` with an `AddGroupWithOne` structure, the integer and natural number homomorphisms from `ℤ` and `ℕ` to `R` agree.","distance":1.860477375685329004539880770607851445674896240234375}],["The theorem `InfTopHomClass.map_top` states that for any types `F`, `α`, and `β`, if `α` and `β` both have `Inf` and `Top` instances (meaning they have a least element and a greatest element, respectively), and `F` is a function-like object from `α` to `β` with an `InfTopHomClass` instance (meaning it preserves the operations of greatest and least elements), then applying a function `f` of type `F` to the greatest element of `α` yields the greatest element of `β`. In other words, an `InfTopHomClass` morphism preserves the top (greatest) element.",{"type":"∀ {F : Type u_7} {α : Type u_8} {β : Type u_9} [inst : Inf α] [inst_1 : Inf β] [inst_2 : Top α] [inst_3 : Top β]\n  [inst_4 : FunLike F α β] [self : InfTopHomClass F α β] (f : F), f ⊤ = ⊤","name":"InfTopHomClass.map_top","isProp":true,"docString":"The theorem `InfTopHomClass.map_top` states that for any types `F`, `α`, and `β`, if `α` and `β` both have `Inf` and `Top` instances (meaning they have a least element and a greatest element, respectively), and `F` is a function-like object from `α` to `β` with an `InfTopHomClass` instance (meaning it preserves the operations of greatest and least elements), then applying a function `f` of type `F` to the greatest element of `α` yields the greatest element of `β`. In other words, an `InfTopHomClass` morphism preserves the top (greatest) element.","distance":1.872353976178966039611850646906532347202301025390625}],["Additive closure of an additive subsemigroup `S` equals `S`",{"type":"∀ {M : Type u_1} [inst : Add M] (S : AddSubsemigroup M), AddSubsemigroup.closure ↑S = S","name":"AddSubsemigroup.closure_eq","isProp":true,"docString":"Additive closure of an additive subsemigroup `S` equals `S`","distance":1.868898752865252976818055685725994408130645751953125}],["Turn a non-unital star subalgebra containing `1` into a `StarSubalgebra`. ",{"type":"{R : Type u_1} →\n  {A : Type u_2} →\n    [inst : CommSemiring R] →\n      [inst_1 : StarRing R] →\n        [inst_2 : Semiring A] →\n          [inst_3 : StarRing A] →\n            [inst_4 : Algebra R A] →\n              [inst_5 : StarModule R A] → (S : NonUnitalStarSubalgebra R A) → 1 ∈ S → StarSubalgebra R A","name":"NonUnitalStarSubalgebra.toStarSubalgebra","isProp":false,"docString":"Turn a non-unital star subalgebra containing `1` into a `StarSubalgebra`. ","distance":1.8692681416941805405684817742439918220043182373046875}],["Define a non-unital star algebra homomorphism on a directed supremum of non-unital star\nsubalgebras by defining it on each non-unital star subalgebra, and proving that it agrees on the\nintersection of non-unital star subalgebras. ",{"type":"{R : Type u} →\n  {A : Type v} →\n    {B : Type w} →\n      [inst : CommSemiring R] →\n        [inst_1 : StarRing R] →\n          [inst_2 : NonUnitalSemiring A] →\n            [inst_3 : StarRing A] →\n              [inst_4 : Module R A] →\n                [inst_5 : IsScalarTower R A A] →\n                  [inst_6 : SMulCommClass R A A] →\n                    [inst_7 : StarModule R A] →\n                      [inst_8 : NonUnitalSemiring B] →\n                        [inst_9 : StarRing B] →\n                          [inst_10 : Module R B] →\n                            {ι : Type u_1} →\n                              [inst_11 : Nonempty ι] →\n                                (K : ι → NonUnitalStarSubalgebra R A) →\n                                  Directed (fun x x_1 => x ≤ x_1) K →\n                                    (f : (i : ι) → ↥(K i) →⋆ₙₐ[R] B) →\n                                      (∀ (i j : ι) (h : K i ≤ K j),\n                                          f i = NonUnitalStarAlgHom.comp (f j) (NonUnitalStarSubalgebra.inclusion h)) →\n                                        (T : NonUnitalStarSubalgebra R A) → T = iSup K → ↥T →⋆ₙₐ[R] B","name":"NonUnitalStarSubalgebra.iSupLift","isProp":false,"docString":"Define a non-unital star algebra homomorphism on a directed supremum of non-unital star\nsubalgebras by defining it on each non-unital star subalgebra, and proving that it agrees on the\nintersection of non-unital star subalgebras. ","distance":1.87061137801799493018961584311909973621368408203125}],["The predicate on products which we prove picks out a basis of `LocallyConstant C ℤ`. We call such a\nproduct \"good\".\n",{"type":"{I : Type u} → [inst : LinearOrder I] → Set (I → Bool) → Profinite.NobelingProof.Products I → Prop","name":"Profinite.NobelingProof.Products.isGood","isProp":false,"docString":"The predicate on products which we prove picks out a basis of `LocallyConstant C ℤ`. We call such a\nproduct \"good\".\n","distance":1.8709514917270679834615521031082607805728912353515625}],["The sup of two fg submodules is finite. Also see `Submodule.FG.sup`. ",{"type":"∀ {R : Type u_1} {V : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup V] [inst_2 : Module R V] (S₁ S₂ : Submodule R V)\n  [h₁ : Module.Finite R ↥S₁] [h₂ : Module.Finite R ↥S₂], Module.Finite R ↥(S₁ ⊔ S₂)","name":"Submodule.finite_sup","isProp":true,"docString":"The sup of two fg submodules is finite. Also see `Submodule.FG.sup`. ","distance":1.87099985627042020297494673286564648151397705078125}],["An additive group homomorphism sends 0 to 0.",{"type":"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0","name":"IsAddGroupHom.map_zero","isProp":true,"docString":"An additive group homomorphism sends 0 to 0.","distance":1.871845194119150956879593650228343904018402099609375}],["The type of arrows from `star α` to itself is equivalent to the original type `α`. ",{"type":"{α : Type u_1} → α ≃ (Quiver.SingleObj.star α ⟶ Quiver.SingleObj.star α)","name":"Quiver.SingleObj.toHom","isProp":false,"docString":"The type of arrows from `star α` to itself is equivalent to the original type `α`. ","distance":1.8737575157059982444707202375866472721099853515625}],["Additive closure of an additive subgroup `K` equals `K`",{"type":"∀ {G : Type u_1} [inst : AddGroup G] (K : AddSubgroup G), AddSubgroup.closure ↑K = K","name":"AddSubgroup.closure_eq","isProp":true,"docString":"Additive closure of an additive subgroup `K` equals `K`","distance":1.8740422431474001996321021579205989837646484375}],["If `A₁` is equivalent to `A₁'` and `A₂` is equivalent to `A₂'`, then the type of maps\n`A₁ →ₐ[R] A₂` is equivalent to the type of maps `A₁' →ₐ[R] A₂'`. ",{"type":"{R : Type uR} →\n  {A₁ : Type uA₁} →\n    {A₂ : Type uA₂} →\n      {A₁' : Type uA₁'} →\n        {A₂' : Type uA₂'} →\n          [inst : CommSemiring R] →\n            [inst_1 : Semiring A₁] →\n              [inst_2 : Semiring A₂] →\n                [inst_3 : Semiring A₁'] →\n                  [inst_4 : Semiring A₂'] →\n                    [inst_5 : Algebra R A₁] →\n                      [inst_6 : Algebra R A₂] →\n                        [inst_7 : Algebra R A₁'] →\n                          [inst_8 : Algebra R A₂'] → (A₁ ≃ₐ[R] A₁') → (A₂ ≃ₐ[R] A₂') → (A₁ →ₐ[R] A₂) ≃ (A₁' →ₐ[R] A₂')","name":"AlgEquiv.arrowCongr","isProp":false,"docString":"If `A₁` is equivalent to `A₁'` and `A₂` is equivalent to `A₂'`, then the type of maps\n`A₁ →ₐ[R] A₂` is equivalent to the type of maps `A₁' →ₐ[R] A₂'`. ","distance":1.8741908276027048341205727410851977765560150146484375}],["Create an equal copy of a subgraph (see `copy_eq`) with possibly different definitional equalities.\nSee Note [range copy pattern].\n",{"type":"{V : Type u} →\n  {G : SimpleGraph V} →\n    (G' : SimpleGraph.Subgraph G) →\n      (V'' : Set V) → V'' = G'.verts → (adj' : V → V → Prop) → adj' = G'.Adj → SimpleGraph.Subgraph G","name":"SimpleGraph.Subgraph.copy","isProp":false,"docString":"Create an equal copy of a subgraph (see `copy_eq`) with possibly different definitional equalities.\nSee Note [range copy pattern].\n","distance":1.87667227541530490242394080269150435924530029296875}],["`SemiNormedGroupCat₁` is a type synonym for `SemiNormedGroupCat`,\nwhich we shall equip with the category structure consisting only of the norm non-increasing maps.\n",{"type":"Type (u + 1)","name":"SemiNormedGroupCat₁","isProp":false,"docString":"`SemiNormedGroupCat₁` is a type synonym for `SemiNormedGroupCat`,\nwhich we shall equip with the category structure consisting only of the norm non-increasing maps.\n","distance":1.8769025626514268534350549089140258729457855224609375}],["Version of `succ_one_eq_two` to be used by `dsimp` ",{"type":"∀ {n : ℕ}, Fin.succ 1 = 2","name":"Fin.succ_one_eq_two","isProp":true,"docString":"Version of `succ_one_eq_two` to be used by `dsimp` ","distance":1.8777453699042256918261273312964476644992828369140625}],["For subgraphs `G₁`, `G₂`, `G₁ ≤ G₂` iff `G₁.verts ⊆ G₂.verts` and\n`∀ a b, G₁.adj a b → G₂.adj a b`. ",{"type":"{V : Type u} → {G : SimpleGraph V} → DistribLattice (SimpleGraph.Subgraph G)","name":"SimpleGraph.Subgraph.distribLattice","isProp":false,"docString":"For subgraphs `G₁`, `G₂`, `G₁ ≤ G₂` iff `G₁.verts ⊆ G₂.verts` and\n`∀ a b, G₁.adj a b → G₂.adj a b`. ","distance":1.8778400549903235816628921384108252823352813720703125}],["An additive subsemigroup `S` includes `closure s` if and only if it includes `s`",{"type":"∀ {M : Type u_1} [inst : Add M] {s : Set M} {S : AddSubsemigroup M}, AddSubsemigroup.closure s ≤ S ↔ s ⊆ ↑S","name":"AddSubsemigroup.closure_le","isProp":true,"docString":"An additive subsemigroup `S` includes `closure s` if and only if it includes `s`","distance":1.8779307387485599800669433534494601190090179443359375}],["If `α₁` is equivalent to `α₂` and `β₁` is equivalent to `β₂`, then the type of maps `α₁ → β₁`\nis equivalent to the type of maps `α₂ → β₂`. ",{"type":"{α₁ : Sort u_1} → {β₁ : Sort u_2} → {α₂ : Sort u_3} → {β₂ : Sort u_4} → α₁ ≃ α₂ → β₁ ≃ β₂ → (α₁ → β₁) ≃ (α₂ → β₂)","name":"Equiv.arrowCongr","isProp":false,"docString":"If `α₁` is equivalent to `α₂` and `β₁` is equivalent to `β₂`, then the type of maps `α₁ → β₁`\nis equivalent to the type of maps `α₂ → β₂`. ","distance":1.8781950387280199610273712096386589109897613525390625}],["We say that `t : Set β` is an image of `s : Set α` under a partial equivalence if\nany of the following equivalent conditions hold:\n\n* `e '' (e.source ∩ s) = e.target ∩ t`;\n* `e.source ∩ e ⁻¹ t = e.source ∩ s`;\n* `∀ x ∈ e.source, e x ∈ t ↔ x ∈ s` (this one is used in the definition).\n",{"type":"{α : Type u_1} → {β : Type u_2} → PartialEquiv α β → Set α → Set β → Prop","name":"PartialEquiv.IsImage","isProp":false,"docString":"We say that `t : Set β` is an image of `s : Set α` under a partial equivalence if\nany of the following equivalent conditions hold:\n\n* `e '' (e.source ∩ s) = e.target ∩ t`;\n* `e.source ∩ e ⁻¹ t = e.source ∩ s`;\n* `∀ x ∈ e.source, e x ∈ t ↔ x ∈ s` (this one is used in the definition).\n","distance":1.8785336632566538295208147246739827096462249755859375}],["Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ",{"type":"∀ {a b : Prop}, a ∧ b → b","name":"And.right","isProp":true,"docString":"Extract the right conjunct from a conjunction. `h : a ∧ b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. ","distance":1.8785874738969903230412228367640636861324310302734375}],["If `α` is equipped with the Scott topology, then it is homeomorphic to `WithScott α`.\n",{"type":"{α : Type u_1} →\n  [inst : Preorder α] → [inst_1 : TopologicalSpace α] → [inst_2 : Topology.IsScott α] → Topology.WithScott α ≃ₜ α","name":"Topology.WithScott.withScottHomeomorph","isProp":false,"docString":"If `α` is equipped with the Scott topology, then it is homeomorphic to `WithScott α`.\n","distance":1.878899426100028247077489140792749822139739990234375}]]