[["Given a subgraph and a set of vertices, delete all the vertices from the subgraph,\nif present. Any edges incident to the deleted vertices are deleted as well. ",{"type":"{V : Type u} → {G : SimpleGraph V} → SimpleGraph.Subgraph G → Set V → SimpleGraph.Subgraph G","name":"SimpleGraph.Subgraph.deleteVerts","isProp":false,"docString":"Given a subgraph and a set of vertices, delete all the vertices from the subgraph,\nif present. Any edges incident to the deleted vertices are deleted as well. ","distance":1.950683319691488559755043752375058829784393310546875}],[" Given a simple graph and replacing a vertex with another non-equal vertex preserves adjacency for all other vertices.",{"type":"∀ {V : Type u_1} [inst : DecidableEq V] (G : SimpleGraph V) (s : V) {t w : V},\n  w ≠ t → ((G.replaceVertex s t).Adj s w ↔ G.Adj s w)","name":"SimpleGraph.adj_replaceVertex_iff_of_ne_left","isProp":true,"docString":" Given a simple graph and replacing a vertex with another non-equal vertex preserves adjacency for all other vertices.","distance":1.97050528690056836467192624695599079132080078125}],["The theorem `Cardinal.toNat_lift` states that for any cardinal number `c` (from the universe `v`), the process of converting that cardinal to a natural number remains unchanged, whether the cardinal is first lifted to a higher universe (from `v` to `max v u`) or not. In other words, lifting the universe of the cardinal does not affect its conversion to a natural number. This theorem guarantees the compatibility of the cardinal number universe lifting operation with the function that maps cardinals to natural numbers.",{"type":"∀ (c : Cardinal.{v}), Cardinal.toNat (Cardinal.lift.{u, v} c) = Cardinal.toNat c","name":"Cardinal.toNat_lift","isProp":true,"docString":"The theorem `Cardinal.toNat_lift` states that for any cardinal number `c` (from the universe `v`), the process of converting that cardinal to a natural number remains unchanged, whether the cardinal is first lifted to a higher universe (from `v` to `max v u`) or not. In other words, lifting the universe of the cardinal does not affect its conversion to a natural number. This theorem guarantees the compatibility of the cardinal number universe lifting operation with the function that maps cardinals to natural numbers.","distance":2.006581157514635282979043040541000664234161376953125}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name → Bool) → Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.951242356710693126586875223438255488872528076171875}],[" The normalization of a natural number expression constraint does not change its denotation within a given context.",{"type":"∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx c.toNormPoly = Nat.Linear.ExprCnstr.denote ctx c","name":"Nat.Linear.ExprCnstr.denote_toNormPoly","isProp":true,"docString":" The normalization of a natural number expression constraint does not change its denotation within a given context.","distance":1.9770035700034795933532905110041610896587371826171875}],["The theorem `Vector.toList_cons` states that for any type `α`, any natural number `n`, any element `a` of type `α`, and any vector `v` of length `n` with elements of type `α`, if you construct a new vector by prepending `a` to `v` and then convert this vector to a list, you get the same result as if you first convert `v` to a list and then prepend `a` to this list. In other words, converting a vector to a list preserves the operation of prepending an element.",{"type":"∀ {α : Type u} {n : ℕ} (a : α) (v : Vector α n), (a ::ᵥ v).toList = a :: v.toList","name":"Vector.toList_cons","isProp":true,"docString":"The theorem `Vector.toList_cons` states that for any type `α`, any natural number `n`, any element `a` of type `α`, and any vector `v` of length `n` with elements of type `α`, if you construct a new vector by prepending `a` to `v` and then convert this vector to a list, you get the same result as if you first convert `v` to a list and then prepend `a` to this list. In other words, converting a vector to a list preserves the operation of prepending an element.","distance":2.007566133822100251649089841521345078945159912109375}],["Generate a random natural number in the interval [lo, hi]. ",{"type":"{gen : Type u} → [inst : RandomGen gen] → gen → ℕ → ℕ → ℕ × gen","name":"randNat","isProp":false,"docString":"Generate a random natural number in the interval [lo, hi]. ","distance":1.95531441045019693802942128968425095081329345703125}],["Lift a list of values to a nondeterministic value.\n(The backtrackable state in each will be identical:\nwhatever the state was when we first read from the result.)\n",{"type":"{σ : Type} → {m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadBacktrack σ m] → {α : Type} → List α → Nondet m α","name":"Nondet.ofList","isProp":false,"docString":"Lift a list of values to a nondeterministic value.\n(The backtrackable state in each will be identical:\nwhatever the state was when we first read from the result.)\n","distance":1.9632415945822245806340333729167468845844268798828125}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.96972520864432087961404249654151499271392822265625}],["Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n",{"type":"{ω : Type u_1} →\n  {α : Type} →\n    (prio : α → Thunk ω) →\n      (ε : α → Type) →\n        [inst : LinearOrder ω] →\n          [inst_1 : (a : α) → Estimator (prio a) (ε a)] →\n            [I : ∀ (a : α), WellFoundedGT ↑(Set.range (EstimatorData.bound (prio a)))] →\n              [inst : Ord ω] →\n                [inst : Ord α] →\n                  {m : Type → Type} →\n                    [inst : Monad m] →\n                      [inst : Alternative m] →\n                        [inst : (a : α) → Bot (ε a)] → Option ℕ → (α → MLList m α) → α → MLList m α","name":"impl","isProp":false,"docString":"Core implementation of `bestFirstSearch`, that works by iteratively updating an internal state,\nconsisting of a priority queue of `MLList m α`.\n\nAt each step we pop an element off the queue,\ncompute its children (lazily) and put these back on the queue.\n","distance":1.969834329407256223731792488251812756061553955078125}],["First samples a proxy value and interprets it. Especially useful if\nthe proxy and target type are the same. ",{"type":"(α : Type u) → [inst : SlimCheck.SampleableExt α] → SlimCheck.Gen α","name":"SlimCheck.SampleableExt.interpSample","isProp":false,"docString":"First samples a proxy value and interprets it. Especially useful if\nthe proxy and target type are the same. ","distance":1.970152747421675343275637715123593807220458984375}],["Given a vector `v` of length `n` whose product is 1, make a vector of length `n - 1`,\nby deleting the last entry of `v`. ",{"type":"(G : Type u_2) → [inst : Group G] → (n : ℕ) → ↑(Equiv.Perm.vectorsProdEqOne G n) ≃ Vector G (n - 1)","name":"Equiv.Perm.VectorsProdEqOne.equivVector","isProp":false,"docString":"Given a vector `v` of length `n` whose product is 1, make a vector of length `n - 1`,\nby deleting the last entry of `v`. ","distance":1.970697860405377088710565658402629196643829345703125}],["A single step of the best first search.\nPop an element, and insert its children back into the queue,\nwith a trivial estimator for their priority. ",{"type":"{ω : Type u_1} →\n  {α : Type} →\n    (prio : α → Thunk ω) →\n      (ε : α → Type) →\n        [inst : LinearOrder ω] →\n          [inst_1 : (a : α) → Estimator (prio a) (ε a)] →\n            [I : ∀ (a : α), WellFoundedGT ↑(Set.range (EstimatorData.bound (prio a)))] →\n              [inst_2 : Ord ω] →\n                [inst_3 : Ord α] →\n                  {m : Type → Type} →\n                    [inst_4 : Monad m] →\n                      [inst_5 : Alternative m] →\n                        [inst_6 : (a : α) → Bot (ε a)] →\n                          (maxSize : Option ℕ) →\n                            (α → MLList m α) →\n                              BestFirstQueue prio ε m α maxSize → m (α × BestFirstQueue prio ε m α maxSize)","name":"impl.go","isProp":false,"docString":"A single step of the best first search.\nPop an element, and insert its children back into the queue,\nwith a trivial estimator for their priority. ","distance":1.972840864772375635283196970704011619091033935546875}],["Remove the element at position `i` from a vector of length `n`. ",{"type":"{α : Type u} → {n : ℕ} → Fin n → Vector α n → Vector α (n - 1)","name":"Vector.removeNth","isProp":false,"docString":"Remove the element at position `i` from a vector of length `n`. ","distance":1.9733826994862704307109879664494656026363372802734375}],["Add the entry unless it already exists. Sets the `line` field to the next\navailable value. ",{"type":"Mathlib.Explode.Entries → Lean.Expr → Mathlib.Explode.Entry → Mathlib.Explode.Entry × Mathlib.Explode.Entries","name":"Mathlib.Explode.Entries.add","isProp":false,"docString":"Add the entry unless it already exists. Sets the `line` field to the next\navailable value. ","distance":1.9733964421256728893894205612014047801494598388671875}],["Given an element `x : α` of `l : List α` such that `x ∈ l`, get the next\nelement of `l`. This works from head to tail, (including a check for last element)\nso it will match on first hit, ignoring later duplicates.\n\nFor example:\n * `next [1, 2, 3] 2 _ = 3`\n * `next [1, 2, 3] 3 _ = 1`\n * `next [1, 2, 3, 2, 4] 2 _ = 3`\n * `next [1, 2, 3, 2] 2 _ = 3`\n * `next [1, 1, 2, 3, 2] 1 _ = 1`\n",{"type":"{α : Type u_1} → [inst : DecidableEq α] → (l : List α) → (x : α) → x ∈ l → α","name":"List.next","isProp":false,"docString":"Given an element `x : α` of `l : List α` such that `x ∈ l`, get the next\nelement of `l`. This works from head to tail, (including a check for last element)\nso it will match on first hit, ignoring later duplicates.\n\nFor example:\n * `next [1, 2, 3] 2 _ = 3`\n * `next [1, 2, 3] 3 _ = 1`\n * `next [1, 2, 3, 2, 4] 2 _ = 3`\n * `next [1, 2, 3, 2] 2 _ = 3`\n * `next [1, 1, 2, 3, 2] 1 _ = 1`\n","distance":1.9735494736917227331929325373494066298007965087890625}],["Given a set of vertex pairs, remove all of the corresponding edges from the\ngraph's edge set, if present.\n\nSee also: `SimpleGraph.Subgraph.deleteEdges`. ",{"type":"{V : Type u} → SimpleGraph V → Set (Sym2 V) → SimpleGraph V","name":"SimpleGraph.deleteEdges","isProp":false,"docString":"Given a set of vertex pairs, remove all of the corresponding edges from the\ngraph's edge set, if present.\n\nSee also: `SimpleGraph.Subgraph.deleteEdges`. ","distance":1.9736638643686033045554495402029715478420257568359375}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ interior (⇑(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.97616583269592549498838707222603261470794677734375}],["Construct a `Type v`-enriched category from an honest category.\n",{"type":"(C : Type u₁) → [𝒞 : CategoryTheory.Category.{v, u₁} C] → CategoryTheory.EnrichedCategory (Type v) C","name":"CategoryTheory.enrichedCategoryTypeOfCategory","isProp":false,"docString":"Construct a `Type v`-enriched category from an honest category.\n","distance":1.976893656395982912243880491587333381175994873046875}],["Apply a function returning values inside the monad to a monadic lazy list,\nreturning only the first successful result.\n",{"type":"{m : Type u_1 → Type u_1} →\n  {α β : Type u_1} → [inst : Monad m] → [inst : Alternative m] → MLList m α → (α → m (Option β)) → m β","name":"MLList.firstM","isProp":false,"docString":"Apply a function returning values inside the monad to a monadic lazy list,\nreturning only the first successful result.\n","distance":1.97689782329315022479931940324604511260986328125}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name → Simps.ParsedProjectionData → List Lean.Level → Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.977341360286221760844682648894377052783966064453125}],["`DMatrix.col u` is the column matrix whose entries are given by `u`. ",{"type":"{m : Type u_2} → [inst : Fintype m] → {α : m → Type v} → ((i : m) → α i) → DMatrix m Unit fun i _j => α i","name":"DMatrix.col","isProp":false,"docString":"`DMatrix.col u` is the column matrix whose entries are given by `u`. ","distance":1.97989149312707635175456744036637246608734130859375}],["Removes the first element of the lazy list.\n",{"type":"{α : Type u} → LazyList α → LazyList α","name":"LazyList.tail","isProp":false,"docString":"Removes the first element of the lazy list.\n","distance":1.9799678253651682435787506619817577302455902099609375}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ ⇑(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9804647206547760784900447106338106095790863037109375}]]