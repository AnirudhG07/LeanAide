[["The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{𝕜 : Type u_8} →\n  {𝕜' : Type u_9} →\n    {E : Type u_10} →\n      [inst : NormedField 𝕜'] →\n        [inst_1 : SeminormedAddCommGroup E] → [I : NormedSpace 𝕜' E] → NormedSpace 𝕜' (RestrictScalars 𝕜 𝕜' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":1.9892497890892471001933472507516853511333465576171875}],[" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.",{"type":"∀ (n : ℕ), ↑n = ↑n","name":"Nat.cast_withBot","isProp":true,"docString":" For all natural numbers `n`, converting `n` to another type and then back to a natural number results in the original natural number `n`.","distance":2.01731445551198884658106180722825229167938232421875}],["The theorem `Nat.prime_three` asserts that the natural number 3 is a prime number. In other words, 3 is a natural number which is at least 2 and its only divisors are 3 and 1.",{"type":"Nat.Prime 3","name":"Nat.prime_three","isProp":true,"docString":"The theorem `Nat.prime_three` asserts that the natural number 3 is a prime number. In other words, 3 is a natural number which is at least 2 and its only divisors are 3 and 1.","distance":2.010410790572125794284374933340586721897125244140625}],["Embedding of a subtype into the ambient type as an `OrderEmbedding`. ",{"type":"{α : Type u_2} → [inst : Preorder α] → (p : α → Prop) → Subtype p ↪o α","name":"OrderEmbedding.subtype","isProp":false,"docString":"Embedding of a subtype into the ambient type as an `OrderEmbedding`. ","distance":1.9909985078647169931542748599895276129245758056640625}],[" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.",{"type":"Cardinal.lift.{max v u, u} = Cardinal.lift.{v, u}","name":"Cardinal.lift_umax'","isProp":true,"docString":" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.","distance":2.0199596928254361927201898652128875255584716796875}],["This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.",{"type":"∀ {p : ℕ}, p.Prime → p.properDivisors = {1}","name":"Nat.Prime.properDivisors","isProp":true,"docString":"This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.","distance":2.013840074038205418816005476401187479496002197265625}],["Create an element of type `Order.Ideal.PrimePair` from an ideal satisfying the predicate\n`Order.Ideal.IsPrime`. ",{"type":"{P : Type u_1} → [inst : Preorder P] → {I : Order.Ideal P} → Order.Ideal.IsPrime I → Order.Ideal.PrimePair P","name":"Order.Ideal.IsPrime.toPrimePair","isProp":false,"docString":"Create an element of type `Order.Ideal.PrimePair` from an ideal satisfying the predicate\n`Order.Ideal.IsPrime`. ","distance":1.9931483765647624029071494078380055725574493408203125}],["The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n",{"type":"Lean.ParserDescr","name":"commandSudoSet_option___","isProp":false,"docString":"The command `sudo set_option name val` is similar to `set_option name val`,\nbut it also allows to set undeclared options.\n","distance":1.995075410882227284758982932544313371181488037109375}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.99961079052181123216769265127368271350860595703125}],["Reverse of `Set.codRestrict_restrict`. ",{"type":"∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β} {f : α → β} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h = Set.codRestrict (Set.restrict s f) t (_ : ∀ (x : ↑s), f ↑x ∈ t)","name":"Set.MapsTo.restrict_eq_codRestrict","isProp":true,"docString":"Reverse of `Set.codRestrict_restrict`. ","distance":1.9996313306024406930561099215992726385593414306640625}],["Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n",{"type":"Lean.ParserDescr","name":"Mathlib.CountHeartbeats.commandCount_heartbeatsIn__","isProp":false,"docString":"Count the heartbeats used in the enclosed command.\n\nThis is most useful for setting sufficient but reasonable limits via `set_option maxHeartbeats`\nfor long running declarations.\n\nIf you do so, please resist the temptation to set the limit as low as possible.\nAs the `simp` set and other features of the library evolve,\nother contributors will find that their (likely unrelated) changes\nhave pushed the declaration over the limit.\n`count_heartbearts in` will automatically suggest a `set_option maxHeartbeats` via \"Try this:\"\nusing the least number of the form `2^k * 200000` that suffices.\n\nNote that that internal heartbeat counter accessible via `IO.getNumHeartbeats`\nhas granularity 1000 times finer that the limits set by `set_option maxHeartbeats`.\nAs this is intended as a user command, we divide by 1000.\n","distance":1.9997208269462003471517164143733680248260498046875}],["Create an element of type `Order.Ideal.PrimePair` from a filter satisfying the predicate\n`Order.PFilter.IsPrime`. ",{"type":"{P : Type u_1} → [inst : Preorder P] → {F : Order.PFilter P} → Order.PFilter.IsPrime F → Order.Ideal.PrimePair P","name":"Order.PFilter.IsPrime.toPrimePair","isProp":false,"docString":"Create an element of type `Order.Ideal.PrimePair` from a filter satisfying the predicate\n`Order.PFilter.IsPrime`. ","distance":2.00108530038229925906989592476747930049896240234375}],["Restrict the codomain of a principal segment ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} →\n      {s : β → β → Prop} →\n        (p : Set β) → (f : r ≺i s) → (∀ (a : α), f.toRelEmbedding a ∈ p) → f.top ∈ p → r ≺i Subrel s p","name":"PrincipalSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of a principal segment ","distance":2.002044260744652692807221683324314653873443603515625}],["The representative of the cardinal of a type is equivalent to the original type. ",{"type":"{α : Type v} → Quotient.out (Cardinal.mk α) ≃ α","name":"Cardinal.outMkEquiv","isProp":false,"docString":"The representative of the cardinal of a type is equivalent to the original type. ","distance":2.0022493835211179202815401367843151092529296875}],["`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ≤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ",{"type":"ℤ → ℤ","name":"Int.sqrt","isProp":false,"docString":"`sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest\ninteger `r` such that `r * r ≤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`,\n`sqrt 1 = 1`, `sqrt 2 = 1` ","distance":2.003133087464672001942744827829301357269287109375}],["A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)",{"type":"ℕ → Type","name":"Affine.Simplex.PointsWithCircumcenterIndex.proxyType","isProp":false,"docString":"A \"proxy type\" equivalent to `Affine.Simplex.PointsWithCircumcenterIndex` that is constructed from `Unit`, `PLift`, `Sigma`, `Empty`, and `Sum`. See `Affine.Simplex.PointsWithCircumcenterIndex.proxyTypeEquiv` for the equivalence. (Generated by the `proxy_equiv%` elaborator.)","distance":2.003754877161629366355555248446762561798095703125}],["TODO: prove this in greater generality. ",{"type":"∀ {m : Type u_2} {n : Type u_3} {R : Type u_5} [inst : Fintype n] [inst_1 : Fintype m] [inst_2 : LinearOrderedField R]\n  (A : Matrix m n R), Matrix.rank (Matrix.transpose A) = Matrix.rank A","name":"Matrix.rank_transpose","isProp":true,"docString":"TODO: prove this in greater generality. ","distance":2.0039666547445360578194595291279256343841552734375}],["Restrict the codomain of an initial segment ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} → {s : β → β → Prop} → (p : Set β) → (f : r ≼i s) → (∀ (a : α), f a ∈ p) → r ≼i Subrel s p","name":"InitialSeg.codRestrict","isProp":false,"docString":"Restrict the codomain of an initial segment ","distance":2.0048342884338286040701859747059643268585205078125}],["The maximum degree of all vertices (and `0` if there are no vertices).\nThe key properties of this are given in `exists_maximal_degree_vertex`, `degree_le_maxDegree`\nand `maxDegree_le_of_forall_degree_le`. ",{"type":"{V : Type u} → (G : SimpleGraph V) → [inst : Fintype V] → [inst : DecidableRel G.Adj] → ℕ","name":"SimpleGraph.maxDegree","isProp":false,"docString":"The maximum degree of all vertices (and `0` if there are no vertices).\nThe key properties of this are given in `exists_maximal_degree_vertex`, `degree_le_maxDegree`\nand `maxDegree_le_of_forall_degree_le`. ","distance":2.00506677327964322188336154795251786708831787109375}],["Warning: This declaration should be used judiciously.\nPlease consider using `IsScalarTower` and/or `RestrictScalars 𝕜 𝕜' E` instead.\n\nThis definition allows the `RestrictScalars.normedSpace` instance to be put directly on `E`\nrather on `RestrictScalars 𝕜 𝕜' E`. This would be a very bad instance; both because `𝕜'` cannot be\ninferred, and because it is likely to create instance diamonds.\n",{"type":"(𝕜 : Type u_5) →\n  (𝕜' : Type u_6) →\n    [inst : NormedField 𝕜] →\n      [inst_1 : NormedField 𝕜'] →\n        [inst_2 : NormedAlgebra 𝕜 𝕜'] →\n          (E : Type u_7) → [inst_3 : SeminormedAddCommGroup E] → [inst_4 : NormedSpace 𝕜' E] → NormedSpace 𝕜 E","name":"NormedSpace.restrictScalars","isProp":false,"docString":"Warning: This declaration should be used judiciously.\nPlease consider using `IsScalarTower` and/or `RestrictScalars 𝕜 𝕜' E` instead.\n\nThis definition allows the `RestrictScalars.normedSpace` instance to be put directly on `E`\nrather on `RestrictScalars 𝕜 𝕜' E`. This would be a very bad instance; both because `𝕜'` cannot be\ninferred, and because it is likely to create instance diamonds.\n","distance":2.005976315833240430919204300153069198131561279296875}],["This is a special case of a more general instance that we define in a later file. ",{"type":"∀ {R : Type u} (A : Type v) [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Subsingleton (R →ₐ[R] A)","name":"Algebra.subsingleton_id","isProp":true,"docString":"This is a special case of a more general instance that we define in a later file. ","distance":2.0062619931406349138569567003287374973297119140625}],["The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n",{"type":"Lean.ParserDescr","name":"termSudoSet_option___In_","isProp":false,"docString":"The command `sudo set_option name val in term` is similar to `set_option name val in term`,\nbut it also allows to set undeclared options.\n","distance":2.007791658990380145866083694272674620151519775390625}],["The minimum degree of all vertices (and `0` if there are no vertices).\nThe key properties of this are given in `exists_minimal_degree_vertex`, `minDegree_le_degree`\nand `le_minDegree_of_forall_le_degree`. ",{"type":"{V : Type u} → (G : SimpleGraph V) → [inst : Fintype V] → [inst : DecidableRel G.Adj] → ℕ","name":"SimpleGraph.minDegree","isProp":false,"docString":"The minimum degree of all vertices (and `0` if there are no vertices).\nThe key properties of this are given in `exists_minimal_degree_vertex`, `minDegree_le_degree`\nand `le_minDegree_of_forall_le_degree`. ","distance":2.007931188494376240072369910194538533687591552734375}],["An `AddSubgroup` of an `AddGroup` inherits an integer scaling. ",{"type":"{G : Type u_5} → [inst : AddGroup G] → {H : AddSubgroup G} → SMul ℤ ↥H","name":"AddSubgroup.zsmul","isProp":false,"docString":"An `AddSubgroup` of an `AddGroup` inherits an integer scaling. ","distance":2.008029151287747726684074223157949745655059814453125}]]