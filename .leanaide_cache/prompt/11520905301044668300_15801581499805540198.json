[["The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9302716904702832412255020244629122316837310791015625}],[" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.",{"type":"Cardinal.lift.{max v u, u} = Cardinal.lift.{v, u}","name":"Cardinal.lift_umax'","isProp":true,"docString":" The lift operation on cardinals commutes with taking the maximum, i.e., `card.lift v (max u v) = max (card.lift u v) (card.lift u v)`.","distance":1.9513587877700009354242638437426649034023284912109375}],["This theorem, `isGreatest_univ`, states that for any type `α` that has a preorder and is also an ordered set with a maximum element (denoted as `⊤`), the maximum element is the greatest element of the universal set (i.e., the set that contains all elements of `α`). In other words, no element in the universal set of `α` is greater than the maximum element `⊤`.",{"type":"∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α], IsGreatest Set.univ ⊤","name":"isGreatest_univ","isProp":true,"docString":"This theorem, `isGreatest_univ`, states that for any type `α` that has a preorder and is also an ordered set with a maximum element (denoted as `⊤`), the maximum element is the greatest element of the universal set (i.e., the set that contains all elements of `α`). In other words, no element in the universal set of `α` is greater than the maximum element `⊤`.","distance":1.951522451925059353783353799371980130672454833984375}],["Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n",{"type":"ℕ → Linarith.PCompSet → Linarith.LinarithM Unit","name":"Linarith.update","isProp":false,"docString":"Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n","distance":1.9370642402449045338386213188641704618930816650390625}],[" The theorem asserts that the function `Vector.head` on types `α` with `Primcodable` instance and natural numbers is primitive recursive.",{"type":"∀ {α : Type u_1} [inst : Primcodable α] {n : ℕ}, Primrec Vector.head","name":"Primrec.vector_head","isProp":true,"docString":" The theorem asserts that the function `Vector.head` on types `α` with `Primcodable` instance and natural numbers is primitive recursive.","distance":1.9538373122830707817598749898024834692478179931640625}],["This theorem, `max_zero_sub_max_neg_zero_eq_self`, states that for any type `α` that is an additive group and has a linear order and a covariant class, the maximum of a given element `a` and zero, subtracted by the maximum of the negative of `a` and zero, equals `a` itself. In mathematical notations, this can be represented as: max(a, 0) - max(-a, 0) = a. This theorem essentially provides a relationship between an element and its additive inverse in the context of maximum and subtraction operations.",{"type":"∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] (a : α), max a 0 - max (-a) 0 = a","name":"max_zero_sub_max_neg_zero_eq_self","isProp":true,"docString":"This theorem, `max_zero_sub_max_neg_zero_eq_self`, states that for any type `α` that is an additive group and has a linear order and a covariant class, the maximum of a given element `a` and zero, subtracted by the maximum of the negative of `a` and zero, equals `a` itself. In mathematical notations, this can be represented as: max(a, 0) - max(-a, 0) = a. This theorem essentially provides a relationship between an element and its additive inverse in the context of maximum and subtraction operations.","distance":1.964753294726371724010505204205401241779327392578125}],["Tests whether `declName` has the `@[simp]` attribute in `env`. ",{"type":"Lean.Environment → Lean.Name → Bool","name":"hasSimpAttribute","isProp":false,"docString":"Tests whether `declName` has the `@[simp]` attribute in `env`. ","distance":1.9394811825647277903073018023860640823841094970703125}],["**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConvexOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → f z ≤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_segment","isProp":true,"docString":"**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9415061527481165537523111197515390813350677490234375}],["`pb.minpolyGen` is the minimal polynomial for `pb.gen`. ",{"type":"{S : Type u_2} →\n  [inst : Ring S] → {A : Type u_4} → [inst_1 : CommRing A] → [inst_2 : Algebra A S] → PowerBasis A S → Polynomial A","name":"PowerBasis.minpolyGen","isProp":false,"docString":"`pb.minpolyGen` is the minimal polynomial for `pb.gen`. ","distance":1.9491174243446636182852671481668949127197265625}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name → Bool) → Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.9499304510691277680933808369445614516735076904296875}],["The maximum operation: `max x y`. ",{"type":"{α : Type u} → [self : Max α] → α → α → α","name":"Max.max","isProp":false,"docString":"The maximum operation: `max x y`. ","distance":1.9530044482851334208817206672392785549163818359375}],["`typeToPointed` is the free functor. ",{"type":"typeToPointed ⊣ CategoryTheory.forget Pointed","name":"typeToPointedForgetAdjunction","isProp":false,"docString":"`typeToPointed` is the free functor. ","distance":1.9535701675217449491128718364052474498748779296875}],["`WithTerminal.star` is terminal. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Limits.IsTerminal CategoryTheory.WithTerminal.star","name":"CategoryTheory.WithTerminal.starTerminal","isProp":false,"docString":"`WithTerminal.star` is terminal. ","distance":1.9551979576524620707544954711920581758022308349609375}],["`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ",{"type":"(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop","name":"Contravariant","isProp":false,"docString":"`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ","distance":1.956089988402560653213413388584740459918975830078125}],["The pointwise maximum of strictly convex functions is strictly convex. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid β] [inst_3 : SMul 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {s : Set E} {f g : E → β}, StrictConvexOn 𝕜 s f → StrictConvexOn 𝕜 s g → StrictConvexOn 𝕜 s (f ⊔ g)","name":"StrictConvexOn.sup","isProp":true,"docString":"The pointwise maximum of strictly convex functions is strictly convex. ","distance":1.9561985263410530677674614707939326763153076171875}],["The triangle `productTriangle T` satisfies the universal property of the categorical\nproduct of the triangles `T`. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.HasShift C ℤ] →\n      {J : Type u_1} →\n        (T : J → CategoryTheory.Pretriangulated.Triangle C) →\n          [inst_2 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₁] →\n            [inst_3 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₂] →\n              [inst_4 : CategoryTheory.Limits.HasProduct fun j => (T j).obj₃] →\n                [inst_5 : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).obj₁] →\n                  CategoryTheory.Limits.IsLimit (CategoryTheory.Pretriangulated.productTriangle.fan T)","name":"CategoryTheory.Pretriangulated.productTriangle.isLimitFan","isProp":false,"docString":"The triangle `productTriangle T` satisfies the universal property of the categorical\nproduct of the triangles `T`. ","distance":1.9570416928424718694401462926180101931095123291015625}],["The `𝟙_ V`-shaped generalized element giving the identity in a `V`-enriched category.\n",{"type":"(V : Type v) →\n  [inst : CategoryTheory.Category.{w, v} V] →\n    [inst_1 : CategoryTheory.MonoidalCategory V] →\n      {C : Type u₁} →\n        [inst_2 : CategoryTheory.EnrichedCategory V C] → (X : C) → 𝟙_ V ⟶ CategoryTheory.EnrichedCategory.Hom X X","name":"CategoryTheory.eId","isProp":false,"docString":"The `𝟙_ V`-shaped generalized element giving the identity in a `V`-enriched category.\n","distance":1.957222781304859271500617978745140135288238525390625}],["**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module 𝕜 β] [inst_3 : OrderedSMul 𝕜 β] {f : 𝕜 → β} {x y z : 𝕜},\n  ConvexOn 𝕜 (Set.Icc x y) f → z ∈ Set.Icc x y → f z ≤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_Icc","isProp":true,"docString":"**Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9578569787502455579186744216713123023509979248046875}],["The tautological action by `CentroidHom α` on `α`.\n\nThis generalizes `Function.End.applyMulAction`. ",{"type":"{α : Type u_5} → [inst : NonUnitalNonAssocSemiring α] → Module (CentroidHom α) α","name":"CentroidHom.applyModule","isProp":false,"docString":"The tautological action by `CentroidHom α` on `α`.\n\nThis generalizes `Function.End.applyMulAction`. ","distance":1.958267172680240975068954867310822010040283203125}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name → Array Simps.ParsedProjectionData → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.9603856980290343958728271900326944887638092041015625}],["Convert a `BestFirstQueue` to a `MLList (α × β)`, by popping off all elements.\n",{"type":"{ω α : Type} →\n  {prio : α → Thunk ω} →\n    {ε : α → Type} →\n      [inst : LinearOrder ω] →\n        [inst_1 : (a : α) → Estimator (prio a) (ε a)] →\n          [I : ∀ (a : α), WellFoundedGT ↑(Set.range (EstimatorData.bound (prio a)))] →\n            {m : Type → Type} →\n              [inst_2 : Monad m] →\n                {β : Type} →\n                  [inst_3 : Ord ω] →\n                    [inst_4 : Ord α] → {maxSize : Option ℕ} → BestFirstQueue prio ε m β maxSize → MLList m (α × β)","name":"BestFirstQueue.toMLList","isProp":false,"docString":"Convert a `BestFirstQueue` to a `MLList (α × β)`, by popping off all elements.\n","distance":1.96093214662069836862201555049978196620941162109375}],["Auxiliary definition for `free_monoidal_category.project`. ",{"type":"{C : Type u} →\n  {D : Type u'} →\n    [inst : CategoryTheory.Category.{v', u'} D] →\n      [inst : CategoryTheory.MonoidalCategory D] → (C → D) → CategoryTheory.FreeMonoidalCategory C → D","name":"CategoryTheory.FreeMonoidalCategory.projectObj","isProp":false,"docString":"Auxiliary definition for `free_monoidal_category.project`. ","distance":1.9609465651547519637887262433650903403759002685546875}],["`centroidWeights` equals a constant function. ",{"type":"∀ (k : Type u_1) [inst : DivisionRing k] {ι : Type u_4} (s : Finset ι),\n  Finset.centroidWeights k s = Function.const ι (↑s.card)⁻¹","name":"Finset.centroidWeights_eq_const","isProp":true,"docString":"`centroidWeights` equals a constant function. ","distance":1.9613059588031702684673973635653965175151824951171875}],["Function elaborating `initialize_simps_projections`. ",{"type":"Lean.Elab.Command.CommandElab","name":"Simps.elabInitializeSimpsProjections","isProp":false,"docString":"Function elaborating `initialize_simps_projections`. ","distance":1.96180286642506729322121827863156795501708984375}]]