[["`bind x f` does a monad \"bind\" operation on the task `x` with function `f`:\nthat is, it constructs (and immediately launches) a new task which will wait\nfor the value of `x` to be available and then calls `f` on the result,\nresulting in a new task which is then run for a result.\n\n`prio`, if provided, is the priority of the task.\n",{"type":"{α : Type u} → {β : Type v} → Task α → (α → Task β) → optParam Task.Priority Task.Priority.default → Task β","name":"Task.bind","isProp":false,"docString":"`bind x f` does a monad \"bind\" operation on the task `x` with function `f`:\nthat is, it constructs (and immediately launches) a new task which will wait\nfor the value of `x` to be available and then calls `f` on the result,\nresulting in a new task which is then run for a result.\n\n`prio`, if provided, is the priority of the task.\n","distance":1.8901369924561730595513608932378701865673065185546875}],[" Given a simple graph and replacing a vertex with another non-equal vertex preserves adjacency for all other vertices.",{"type":"∀ {V : Type u_1} [inst : DecidableEq V] (G : SimpleGraph V) (s : V) {t w : V},\n  w ≠ t → ((G.replaceVertex s t).Adj s w ↔ G.Adj s w)","name":"SimpleGraph.adj_replaceVertex_iff_of_ne_left","isProp":true,"docString":" Given a simple graph and replacing a vertex with another non-equal vertex preserves adjacency for all other vertices.","distance":1.891814625965626106562922359444200992584228515625}],["This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.",{"type":"∀ {p : ℕ}, p.Prime → p.properDivisors = {1}","name":"Nat.Prime.properDivisors","isProp":true,"docString":"This theorem states that for every natural number `p`, if `p` is a prime number, then the set of proper divisors of `p` is the set that contains only the number `1`. In mathematical terms, it establishes that the proper divisors of a prime number `p` are only `1`, since prime numbers are defined as those natural numbers greater than 1 that have no other divisors besides `1` and themselves.","distance":1.923161516522560621211823672638274729251861572265625}],["`map f x` maps function `f` over the task `x`: that is, it constructs\n(and immediately launches) a new task which will wait for the value of `x` to\nbe available and then calls `f` on the result.\n\n`prio`, if provided, is the priority of the task.\n",{"type":"{α : Type u} → {β : Type v} → (α → β) → Task α → optParam Task.Priority Task.Priority.default → Task β","name":"Task.map","isProp":false,"docString":"`map f x` maps function `f` over the task `x`: that is, it constructs\n(and immediately launches) a new task which will wait for the value of `x` to\nbe available and then calls `f` on the result.\n\n`prio`, if provided, is the priority of the task.\n","distance":1.896841170420134670138168075936846435070037841796875}],[" A prime number does not divide 1.",{"type":"∀ {p : ℕ}, p.Prime → ¬p ∣ 1","name":"Nat.Prime.not_dvd_one","isProp":true,"docString":" A prime number does not divide 1.","distance":1.9009565888077812889633833037805743515491485595703125}],["The theorem `Nat.Prime.not_dvd_one` states that for all natural numbers `p`, if `p` is a prime number, then `p` does not divide `1`. In other words, no prime number can be a divisor of 1.",{"type":"∀ {p : ℕ}, p.Prime → ¬p ∣ 1","name":"Nat.Prime.not_dvd_one","isProp":true,"docString":"The theorem `Nat.Prime.not_dvd_one` states that for all natural numbers `p`, if `p` is a prime number, then `p` does not divide `1`. In other words, no prime number can be a divisor of 1.","distance":1.9260328180920343044135734089650213718414306640625}],["Given a subgraph and a set of vertices, delete all the vertices from the subgraph,\nif present. Any edges incident to the deleted vertices are deleted as well. ",{"type":"{V : Type u} → {G : SimpleGraph V} → SimpleGraph.Subgraph G → Set V → SimpleGraph.Subgraph G","name":"SimpleGraph.Subgraph.deleteVerts","isProp":false,"docString":"Given a subgraph and a set of vertices, delete all the vertices from the subgraph,\nif present. Any edges incident to the deleted vertices are deleted as well. ","distance":1.8985787374271498872957408821093849837779998779296875}],["`(start, stop).foldI f a` evaluates `f` on all the numbers\nfrom `start` (inclusive) to `stop` (exclusive) in increasing order:\n* `(5, 8).foldI f init = init |> f 5 |> f 6 |> f 7`\n",{"type":"{α : Type u} → (ℕ → α → α) → ℕ × ℕ → α → α","name":"Prod.foldI","isProp":false,"docString":"`(start, stop).foldI f a` evaluates `f` on all the numbers\nfrom `start` (inclusive) to `stop` (exclusive) in increasing order:\n* `(5, 8).foldI f init = init |> f 5 |> f 6 |> f 7`\n","distance":1.9006686390329721181302602417417801916599273681640625}],["The infinite lazy list `[x, f x, f (f x), ...]` of iterates of a function.\nThis definition is meta because it creates an infinite list.\n",{"type":"{α : Type u} → (α → α) → α → LazyList α","name":"LazyList.iterates","isProp":false,"docString":"The infinite lazy list `[x, f x, f (f x), ...]` of iterates of a function.\nThis definition is meta because it creates an infinite list.\n","distance":1.9016906334662186939254979733959771692752838134765625}],["Given a function from `X` to an `R`-algebra `A`, `lift_fun` provides a lift of `f` to a function\nfrom `Pre R X` to `A`. This is mainly used in the construction of `FreeAlgebra.lift`.\n",{"type":"(R : Type u_1) →\n  [inst : CommSemiring R] →\n    (X : Type u_2) → {A : Type u_3} → [inst_1 : Semiring A] → [inst : Algebra R A] → (X → A) → FreeAlgebra.Pre R X → A","name":"FreeAlgebra.liftFun","isProp":false,"docString":"Given a function from `X` to an `R`-algebra `A`, `lift_fun` provides a lift of `f` to a function\nfrom `Pre R X` to `A`. This is mainly used in the construction of `FreeAlgebra.lift`.\n","distance":1.9033438416823600380922698604990728199481964111328125}],["Apply a function returning values inside the monad to a monadic lazy list,\nreturning only the first successful result.\n",{"type":"{m : Type u_1 → Type u_1} →\n  {α β : Type u_1} → [inst : Monad m] → [inst : Alternative m] → MLList m α → (α → m (Option β)) → m β","name":"MLList.firstM","isProp":false,"docString":"Apply a function returning values inside the monad to a monadic lazy list,\nreturning only the first successful result.\n","distance":1.9033834863126919412223969629849307239055633544921875}],["A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. ",{"type":"Set.Infinite {p | Nat.Prime p}","name":"Nat.infinite_setOf_prime","isProp":true,"docString":"A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. ","distance":1.9036042871609748505790093986433930695056915283203125}],["Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y → p y → p x` then\nthe predicate is true everywhere in the chain and at `a`.\nThat is, we can propagate the predicate up the chain.\n",{"type":"∀ {α : Type u} {r : α → α → Prop} {a b : α} (p : α → Prop) (l : List α),\n  List.Chain r a l →\n    List.getLast (a :: l) (_ : a :: l ≠ []) = b → (∀ ⦃x y : α⦄, r x y → p y → p x) → p b → ∀ i ∈ a :: l, p i","name":"List.Chain.induction","isProp":true,"docString":"Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y → p y → p x` then\nthe predicate is true everywhere in the chain and at `a`.\nThat is, we can propagate the predicate up the chain.\n","distance":1.905083067911302219243907529744319617748260498046875}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ interior (⇑(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9077403622084589951413136077462695538997650146484375}],["Find the value of a monadic function on the first alternative in a nondeterministic value\nwhere the function succeeds.\n",{"type":"{σ : Type} →\n  {m : Type → Type} →\n    [inst : Monad m] →\n      [inst : Lean.MonadBacktrack σ m] → {α β : Type} → [inst_1 : Alternative m] → Nondet m α → (α → m (Option β)) → m β","name":"Nondet.firstM","isProp":false,"docString":"Find the value of a monadic function on the first alternative in a nondeterministic value\nwhere the function succeeds.\n","distance":1.908436665431835432826801479677669703960418701171875}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ ⇑(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9093112929793873977502016714424826204776763916015625}],["Folds a binary function across a monadic lazy list, from an initial starting value.\nThis will run forever if the list is infinite. ",{"type":"{m : Type u_1 → Type u_1} → {β α : Type u_1} → [inst : Monad m] → (β → α → m β) → β → MLList m α → m β","name":"MLList.foldM","isProp":false,"docString":"Folds a binary function across a monadic lazy list, from an initial starting value.\nThis will run forever if the list is infinite. ","distance":1.909668108612484704877942931489087641239166259765625}],["Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y → p y → p x` then\nthe predicate is true at `a`.\nThat is, we can propagate the predicate all the way up the chain.\n",{"type":"∀ {α : Type u} {r : α → α → Prop} {a b : α} (p : α → Prop) (l : List α),\n  List.Chain r a l → List.getLast (a :: l) (_ : a :: l ≠ []) = b → (∀ ⦃x y : α⦄, r x y → p y → p x) → p b → p a","name":"List.Chain.induction_head","isProp":true,"docString":"Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y → p y → p x` then\nthe predicate is true at `a`.\nThat is, we can propagate the predicate all the way up the chain.\n","distance":1.9096910122287871214297183541930280625820159912109375}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name → Array Simps.ParsedProjectionData → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.90969364723424828156339572160504758358001708984375}],["Iterate a function. ",{"type":"{α : Sort u} → (α → α) → ℕ → α → α","name":"Nat.iterate","isProp":false,"docString":"Iterate a function. ","distance":1.9099024013802334831524376568268053233623504638671875}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9108644299164001534307999463635496795177459716796875}],["The singleton presieve.  ",{"type":"{C : Type u₁} → [inst : CategoryTheory.Category.{v₁, u₁} C] → {X Y : C} → (Y ⟶ X) → CategoryTheory.Presieve X","name":"CategoryTheory.Presieve.singleton","isProp":false,"docString":"The singleton presieve.  ","distance":1.91091058814805858645513580995611846446990966796875}],["Turn a subgraph of a `SimpleGraph` into a member of its subgraph type. ",{"type":"{V : Type u} → {G : SimpleGraph V} → (H : SimpleGraph V) → H ≤ G → SimpleGraph.Subgraph G","name":"SimpleGraph.toSubgraph","isProp":false,"docString":"Turn a subgraph of a `SimpleGraph` into a member of its subgraph type. ","distance":1.91124476570559931332127234782092273235321044921875}],["Given an ideal `I` of `R[X]`, make the `R`-submodule of `I`\nconsisting of polynomials of degree ≤ `n`. ",{"type":"{R : Type u} → [inst : Semiring R] → Ideal (Polynomial R) → WithBot ℕ → Submodule R (Polynomial R)","name":"Ideal.degreeLE","isProp":false,"docString":"Given an ideal `I` of `R[X]`, make the `R`-submodule of `I`\nconsisting of polynomials of degree ≤ `n`. ","distance":1.9125258736221990574222218128852546215057373046875}]]