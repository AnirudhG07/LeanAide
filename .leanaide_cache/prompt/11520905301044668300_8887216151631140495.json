[["There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ","distance":0.8311901529597436333318682954995892941951751708984375}],[" The number of positive multiples of `n` less than or equal to `N` is equal to the integer part of `N` divided by `n`.",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":" The number of positive multiples of `n` less than or equal to `N` is equal to the integer part of `N` divided by `n`.","distance":0.78563513007048157987810554914176464080810546875}],["This theorem states that for any given non-negative integers `N` and `n`, the number of positive multiples of `n` that are less than or equal to `N` is precisely `⌊N/n⌋`. This is calculated by filtering out all the elements in the set of natural numbers from `0` to `N` (inclusive) that are divisible by `n` and not equal to `0`, and then counting the number of such elements. The theorem also suggests referring to a similar theorem, `Nat.card_multiples`, which might be a version shifted by one.",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"This theorem states that for any given non-negative integers `N` and `n`, the number of positive multiples of `n` that are less than or equal to `N` is precisely `⌊N/n⌋`. This is calculated by filtering out all the elements in the set of natural numbers from `0` to `N` (inclusive) that are divisible by `n` and not equal to `0`, and then counting the number of such elements. The theorem also suggests referring to a similar theorem, `Nat.card_multiples`, which might be a version shifted by one.","distance":0.812850268743471104926356929354369640350341796875}],["**Hermite Theorem**. Let `N` be an integer. There are only finitely many number fields\n(in some fixed extension of `ℚ`) of discriminant bounded by `N`. ",{"type":"∀ (A : Type u_2) [inst : Field A] [inst_1 : CharZero A] (N : ℕ), {K | |NumberField.discr ↥↑K| ≤ ↑N}.Finite","name":"NumberField.finite_of_discr_bdd","isProp":true,"docString":"**Hermite Theorem**. Let `N` be an integer. There are only finitely many number fields\n(in some fixed extension of `ℚ`) of discriminant bounded by `N`. ","distance":0.90170688874737059403940975244040600955486297607421875}],[" If a natural number `N` is not prime, then the sets of `N`-smooth numbers and `(N+1)`-smooth numbers are equal.",{"type":"∀ {N : ℕ}, ¬N.Prime → N.succ.smoothNumbers = N.smoothNumbers","name":"Nat.smoothNumbers_succ","isProp":true,"docString":" If a natural number `N` is not prime, then the sets of `N`-smooth numbers and `(N+1)`-smooth numbers are equal.","distance":0.932517347061405654784493890474550426006317138671875}],["This theorem states that for every integer `n`, `n` is either even or odd. In the context of the defined terms, an integer is even if it can be expressed as twice some integer, i.e., `n = 2*r` for some integer `r`. On the other hand, an integer is odd if it can be expressed in the form `n = 2*k + 1` for some integer `k`. This theorem is a reflection of the fundamental dichotomy of integers into even and odd numbers.",{"type":"∀ (n : ℤ), Even n ∨ Odd n","name":"Int.even_or_odd","isProp":true,"docString":"This theorem states that for every integer `n`, `n` is either even or odd. In the context of the defined terms, an integer is even if it can be expressed as twice some integer, i.e., `n = 2*r` for some integer `r`. On the other hand, an integer is odd if it can be expressed in the form `n = 2*k + 1` for some integer `k`. This theorem is a reflection of the fundamental dichotomy of integers into even and odd numbers.","distance":0.99740717466081274533706846341374330222606658935546875}],["The `L`-function of the trivial character mod `N`. ",{"type":"(N : ℕ) → [inst : NeZero N] → ℂ → ℂ","name":"DirichletCharacter.LFunctionTrivChar","isProp":false,"docString":"The `L`-function of the trivial character mod `N`. ","distance":0.92161485276343058092862747798790223896503448486328125}],["If a small natural number is divisible by a larger natural number,\nthe small number is zero. ",{"type":"∀ {a b : ℕ}, a ∣ b → b < a → b = 0","name":"Nat.eq_zero_of_dvd_of_lt","isProp":true,"docString":"If a small natural number is divisible by a larger natural number,\nthe small number is zero. ","distance":0.928905241607058229647009284235537052154541015625}],["The integers modulo `n : ℕ`. ",{"type":"ℕ → Type","name":"ZMod","isProp":false,"docString":"The integers modulo `n : ℕ`. ","distance":0.94184221118639899206215204685577191412448883056640625}],["The non-zero non-`N`-smooth numbers are `≥ N`. ",{"type":"∀ (N : ℕ), N.smoothNumbersᶜ \\ {0} ⊆ {n | N ≤ n}","name":"Nat.smoothNumbers_compl","isProp":true,"docString":"The non-zero non-`N`-smooth numbers are `≥ N`. ","distance":0.94748106104204732336171446149819530546665191650390625}],["The set of pairs of coprime integers congruent to `a` mod `N`. ",{"type":"(N : ℕ) → (Fin 2 → ZMod N) → Set (Fin 2 → ℤ)","name":"EisensteinSeries.gammaSet","isProp":false,"docString":"The set of pairs of coprime integers congruent to `a` mod `N`. ","distance":0.95556122208606508738881757381022907793521881103515625}],["A polynomial over the integers is divisible by `n : ℕ`\nif and only if it is zero over `ZMod n`. ",{"type":"∀ {σ : Type u_1} (n : ℕ) (φ : MvPolynomial σ ℤ),\n  MvPolynomial.C ↑n ∣ φ ↔ (MvPolynomial.map (Int.castRingHom (ZMod n))) φ = 0","name":"MvPolynomial.C_dvd_iff_zmod","isProp":true,"docString":"A polynomial over the integers is divisible by `n : ℕ`\nif and only if it is zero over `ZMod n`. ","distance":0.9613883817455779468019727573846466839313507080078125}],["`n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. ",{"type":"∀ (n : ℕ) {a : ℕ}, 0 < a → ((∃ k, a * k < n ∧ n < a * (k + 1)) ↔ ¬a ∣ n)","name":"Nat.not_dvd_iff_between_consec_multiples","isProp":true,"docString":"`n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. ","distance":0.9895936629993264954663345633889548480510711669921875}],["`n : ℕ` is _deficient_ if the sum of the proper divisors of `n` is less than `n`. ",{"type":"ℕ → Prop","name":"Nat.Deficient","isProp":false,"docString":"`n : ℕ` is _deficient_ if the sum of the proper divisors of `n` is less than `n`. ","distance":0.99867616437185124933506585875875316560268402099609375}],["If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. ",{"type":"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'","name":"Nat.exists_eq_pow_mul_and_not_dvd","isProp":true,"docString":"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. ","distance":0.99965222615490156865547533016069792211055755615234375}],["`div2 n = ⌊n/2⌋` the greatest integer smaller than `n/2`",{"type":"ℕ → ℕ","name":"Nat.div2","isProp":false,"docString":"`div2 n = ⌊n/2⌋` the greatest integer smaller than `n/2`","distance":1.003534792425267330173710433882661163806915283203125}],["If for all `n ≠ 0 ∈ ℤ`, `n • A = A`, then `A` is divisible.\n",{"type":"(A : Type u_1) → [inst : AddCommGroup A] → (∀ {n : ℤ}, n ≠ 0 → n • ⊤ = ⊤) → DivisibleBy A ℤ","name":"AddCommGroup.divisibleByIntOfSMulTopEqTop","isProp":false,"docString":"If for all `n ≠ 0 ∈ ℤ`, `n • A = A`, then `A` is divisible.\n","distance":1.006896970280156455856968022999353706836700439453125}],["If an integer with larger absolute value divides an integer, it is zero. ",{"type":"∀ {m n : ℤ}, m ∣ n → n.natAbs < m.natAbs → n = 0","name":"Int.eq_zero_of_dvd_of_natAbs_lt_natAbs","isProp":true,"docString":"If an integer with larger absolute value divides an integer, it is zero. ","distance":1.0106992910872687474466147250495851039886474609375}],["Multiplication modulo `n` ",{"type":"{n : ℕ} → Fin n → Fin n → Fin n","name":"Fin.mul","isProp":false,"docString":"Multiplication modulo `n` ","distance":1.0172165380961570857465403605601750314235687255859375}],["An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is\nrequired to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove\nresults where you want to change each term in a polynomial to something else depending on the\n`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. ",{"type":"∀ {R : Type u_1} [inst : Semiring R] (P : Polynomial R → Prop) (N : ℕ),\n  P 0 →\n    (∀ (n : ℕ) (r : R), r ≠ 0 → n ≤ N → P (Polynomial.C r * Polynomial.X ^ n)) →\n      (∀ (f g : Polynomial R), f.natDegree < g.natDegree → g.natDegree ≤ N → P f → P g → P (f + g)) →\n        ∀ (f : Polynomial R), f.natDegree ≤ N → P f","name":"Polynomial.induction_with_natDegree_le","isProp":true,"docString":"An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is\nrequired to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove\nresults where you want to change each term in a polynomial to something else depending on the\n`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. ","distance":1.0173924325729917228500198689289391040802001953125}],["The product of the prime factors of `n` that are less than `N` is an `N`-smooth number. ",{"type":"∀ (n N : ℕ), (List.filter (fun x => decide (x < N)) n.primeFactorsList).prod ∈ N.smoothNumbers","name":"Nat.prod_mem_smoothNumbers","isProp":true,"docString":"The product of the prime factors of `n` that are less than `N` is an `N`-smooth number. ","distance":1.022844442611867687986659802845679223537445068359375}],["The natural number less than `lcm n m` congruent to `a` mod `n` and `b` mod `m` ",{"type":"{m n a b : ℕ} → a ≡ b [MOD n.gcd m] → { k // k ≡ a [MOD n] ∧ k ≡ b [MOD m] }","name":"Nat.chineseRemainder'","isProp":false,"docString":"The natural number less than `lcm n m` congruent to `a` mod `n` and `b` mod `m` ","distance":1.0257789715738010460910345500451512634754180908203125}],["`n : ℕ` is perfect if and only the sum of the proper divisors of `n` is `n` and `n`\nis positive. ",{"type":"ℕ → Prop","name":"Nat.Perfect","isProp":false,"docString":"`n : ℕ` is perfect if and only the sum of the proper divisors of `n` is `n` and `n`\nis positive. ","distance":1.0380526785954844459780588294961489737033843994140625}],["Equivalence between `ℕ` and `ZMod N × ℕ`, sending `n` to `(n mod N, n / N)`. ",{"type":"(N : ℕ) → [inst : NeZero N] → ℕ ≃ ZMod N × ℕ","name":"Nat.residueClassesEquiv","isProp":false,"docString":"Equivalence between `ℕ` and `ZMod N × ℕ`, sending `n` to `(n mod N, n / N)`. ","distance":1.042978244880721216958363584126345813274383544921875}]]