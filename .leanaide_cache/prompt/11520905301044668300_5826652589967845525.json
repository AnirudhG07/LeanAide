[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9557023223642338027872256134287454187870025634765625}],[" For any paths $q\\_1$ in topological space $\\alpha$ and $q\\_2$ in topological space $\\beta$ from points $a\\_1$, $a\\_2$ in $\\alpha$ and $b\\_1$, $b\\_2$ in $\\beta$ respectively, the projection of the product path class $[q\\_1] \\times [q\\_2]$ in the product space onto its first coordinate is equal to the path class $[q\\_1]$ in $\\alpha$.",{"type":"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {a₁ a₂ : α} {b₁ b₂ : β}\n  (q₁ : Path.Homotopic.Quotient a₁ a₂) (q₂ : Path.Homotopic.Quotient b₁ b₂),\n  Path.Homotopic.projLeft (Path.Homotopic.prod q₁ q₂) = q₁","name":"Path.Homotopic.projLeft_prod","isProp":true,"docString":" For any paths $q\\_1$ in topological space $\\alpha$ and $q\\_2$ in topological space $\\beta$ from points $a\\_1$, $a\\_2$ in $\\alpha$ and $b\\_1$, $b\\_2$ in $\\beta$ respectively, the projection of the product path class $[q\\_1] \\times [q\\_2]$ in the product space onto its first coordinate is equal to the path class $[q\\_1]$ in $\\alpha$.","distance":1.9793032697620198678833958183531649410724639892578125}],["This theorem, named `sign_pos`, states that for any type `α` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `α` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.",{"type":"∀ {α : Type u_1} [inst : Zero α] [inst_1 : Preorder α] [inst_2 : DecidableRel fun x x_1 => x < x_1] {a : α},\n  0 < a → SignType.sign a = 1","name":"sign_pos","isProp":true,"docString":"This theorem, named `sign_pos`, states that for any type `α` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `α` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.","distance":1.988508046437726495270226223510690033435821533203125}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.9618293930718333495377692088368348777294158935546875}],[" In a preordered type without a maximum element, no element is maximal.",{"type":"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : NoMaxOrder α] (a : α), ¬IsMax a","name":"not_isMax","isProp":true,"docString":" In a preordered type without a maximum element, no element is maximal.","distance":1.9799132080444057368850963030126877129077911376953125}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":1.9891995104501039026700937029090709984302520751953125}],["Endowing the space `PiLp p β` with the `L^p` edistance. We register this instance\nseparate from `pi_Lp.pseudo_emetric` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future emetric-like structure on `PiLp p β` for `p < 1`\nsatisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ",{"type":"(p : ENNReal) →\n  {ι : Type u_2} → (β : ι → Type u_4) → [inst : Fintype ι] → [inst : (i : ι) → EDist (β i)] → EDist (PiLp p β)","name":"PiLp.instEDistPiLp","isProp":false,"docString":"Endowing the space `PiLp p β` with the `L^p` edistance. We register this instance\nseparate from `pi_Lp.pseudo_emetric` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future emetric-like structure on `PiLp p β` for `p < 1`\nsatisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ","distance":1.9712736850282748246598885089042596518993377685546875}],["Endowing the space `WithLp p (α × β)` with the `L^p` edistance. We register this instance\nseparate from `WithLp.instProdPseudoEMetric` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future emetric-like structure on `WithLp p (α × β)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ",{"type":"(p : ENNReal) → (α : Type u_2) → (β : Type u_3) → [inst : EDist α] → [inst : EDist β] → EDist (WithLp p (α × β))","name":"WithLp.instProdEDist","isProp":false,"docString":"Endowing the space `WithLp p (α × β)` with the `L^p` edistance. We register this instance\nseparate from `WithLp.instProdPseudoEMetric` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future emetric-like structure on `WithLp p (α × β)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ","distance":1.9726503801931294379556902640615589916706085205078125}],["Checks whether `completionPos` points at a free space in the header. ",{"type":"Lean.Syntax → String.Pos → Bool","name":"ImportCompletion.isImportCmdCompletionRequest","isProp":false,"docString":"Checks whether `completionPos` points at a free space in the header. ","distance":1.9750680849150732409924557941849343478679656982421875}],["Endowing the space `WithLp p (α × β)` with the `L^p` distance. We register this instance\nseparate from `WithLp.instProdPseudoMetricSpace` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future metric-like structure on `WithLp p (α × β)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ",{"type":"(p : ENNReal) → (α : Type u_2) → (β : Type u_3) → [inst : Dist α] → [inst : Dist β] → Dist (WithLp p (α × β))","name":"WithLp.instProdDist","isProp":false,"docString":"Endowing the space `WithLp p (α × β)` with the `L^p` distance. We register this instance\nseparate from `WithLp.instProdPseudoMetricSpace` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future metric-like structure on `WithLp p (α × β)` for\n`p < 1` satisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ","distance":1.9758028329606596162903997537796385586261749267578125}],["A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n",{"type":"(n m : ℕ) → Decidable (n = m)","name":"Nat.decEq","isProp":false,"docString":"A decision procedure for equality of natural numbers.\n\nThis definition is overridden in the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model.\n","distance":1.9763592947299988278331284163868986070156097412109375}],["The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ",{"type":"∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  (f : WithLp p (α × β)), edist f f = 0","name":"WithLp.prod_edist_self","isProp":true,"docString":"The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ","distance":1.976612947311540580130895250476896762847900390625}],["Retrieve all names in the environment satisfying a predicate.\n",{"type":"(Lean.Name → Bool) → Lean.CoreM (Array Lean.Name)","name":"allNames","isProp":false,"docString":"Retrieve all names in the environment satisfying a predicate.\n","distance":1.9772076013548538497843765071593225002288818359375}],["Tests whether `declName` has the `@[simp]` attribute in `env`. ",{"type":"Lean.Environment → Lean.Name → Bool","name":"hasSimpAttribute","isProp":false,"docString":"Tests whether `declName` has the `@[simp]` attribute in `env`. ","distance":1.9795480323741536654580386311863549053668975830078125}],["The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9803429132158913983374759482103399932384490966796875}],["**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConvexOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → f z ≤ max (f x) (f y)","name":"ConvexOn.le_max_of_mem_segment","isProp":true,"docString":"**Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.9815551419220234219409348952467553317546844482421875}],["`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ",{"type":"(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop","name":"Contravariant","isProp":false,"docString":"`Contravariant` is useful to formulate succinctly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `ContravariantClass` doc-string for its meaning. ","distance":1.98172384104731857945580486557446420192718505859375}],["Default definition of `max`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":1.9824123286982444636095124224084429442882537841796875}],["`WithTerminal.star` is terminal. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Limits.IsTerminal CategoryTheory.WithTerminal.star","name":"CategoryTheory.WithTerminal.starTerminal","isProp":false,"docString":"`WithTerminal.star` is terminal. ","distance":1.98408115504833659770156373269855976104736328125}],["Attribute for identifying `positivity` extensions. ",{"type":"Lean.ParserDescr","name":"positivity","isProp":false,"docString":"Attribute for identifying `positivity` extensions. ","distance":1.984186649469772856235749713960103690624237060546875}],["Endowing the space `PiLp p β` with the `L^p` distance. We register this instance\nseparate from `pi_Lp.pseudo_metric` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future metric-like structure on `PiLp p β` for `p < 1`\nsatisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ",{"type":"(p : ENNReal) →\n  {ι : Type u_2} → (α : ι → Type u_3) → [inst : Fintype ι] → [inst : (i : ι) → Dist (α i)] → Dist (PiLp p α)","name":"PiLp.instDistPiLp","isProp":false,"docString":"Endowing the space `PiLp p β` with the `L^p` distance. We register this instance\nseparate from `pi_Lp.pseudo_metric` since the latter requires the type class hypothesis\n`[Fact (1 ≤ p)]` in order to prove the triangle inequality.\n\nRegistering this separately allows for a future metric-like structure on `PiLp p β` for `p < 1`\nsatisfying a relaxed triangle inequality. The terminology for this varies throughout the\nliterature, but it is sometimes called a *quasi-metric* or *semi-metric*. ","distance":1.9843246291775908929366778465919196605682373046875}],["`O(1)`. Get the maximum element in a `BinaryHeap`. ",{"type":"{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → Option α","name":"BinaryHeap.max","isProp":false,"docString":"`O(1)`. Get the maximum element in a `BinaryHeap`. ","distance":1.9855844825636002060065266050514765083789825439453125}],["Turn a `SignType` into zero, one, or minus one. This is a coercion instance, but note it is\nonly a `CoeTC` instance: see note [use has_coe_t]. ",{"type":"{α : Type u_1} → [inst : Zero α] → [inst : One α] → [inst : Neg α] → SignType → α","name":"SignType.cast","isProp":false,"docString":"Turn a `SignType` into zero, one, or minus one. This is a coercion instance, but note it is\nonly a `CoeTC` instance: see note [use has_coe_t]. ","distance":1.985698799522514601534339817590080201625823974609375}],["The maximum operation: `max x y`. ",{"type":"{α : Type u} → [self : Max α] → α → α → α","name":"Max.max","isProp":false,"docString":"The maximum operation: `max x y`. ","distance":1.9858293578023322734082967144786380231380462646484375}]]