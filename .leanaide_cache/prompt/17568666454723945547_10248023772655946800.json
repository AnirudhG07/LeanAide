[["The first hexagon identity. ",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  [self : CategoryTheory.BraidedCategory C] (X Y Z : C),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Z).hom\n      (CategoryTheory.CategoryStruct.comp (β_ X (CategoryTheory.MonoidalCategory.tensorObj Y Z)).hom\n        (CategoryTheory.MonoidalCategory.associator Y Z X).hom) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (β_ X Y).hom (CategoryTheory.CategoryStruct.id Z))\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator Y X Z).hom\n        (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id Y) (β_ X Z).hom))","name":"CategoryTheory.BraidedCategory.hexagon_forward","isProp":true,"docString":"The first hexagon identity. ","distance":0.418510510833391469187603206592029891908168792724609375}],[" For any pre-games x and y, the birthday of their sum (x + y) equals the Hessenberg sum of their individual birthdays.",{"type":"∀ (x y : SetTheory.PGame), (x + y).birthday = x.birthday.nadd y.birthday","name":"SetTheory.PGame.birthday_add","isProp":true,"docString":" For any pre-games x and y, the birthday of their sum (x + y) equals the Hessenberg sum of their individual birthdays.","distance":0.50182531145503739278268540147109888494014739990234375}],["The **Chicken McNugget Theorem** states that for any two coprime natural numbers `m` and `n`, both greater than one, the Frobenius number (the largest number that cannot be expressed as a sum of any combination of `m` and `n`) is calculated by the formula `m * n - m - n`.",{"type":"∀ {m n : ℕ}, m.Coprime n → 1 < m → 1 < n → FrobeniusNumber (m * n - m - n) {m, n}","name":"frobeniusNumber_pair","isProp":true,"docString":"The **Chicken McNugget Theorem** states that for any two coprime natural numbers `m` and `n`, both greater than one, the Frobenius number (the largest number that cannot be expressed as a sum of any combination of `m` and `n`) is calculated by the formula `m * n - m - n`.","distance":0.496991389066649025263444627853459678590297698974609375}],["The second hexagon identity. ",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C]\n  [self : CategoryTheory.BraidedCategory C] (X Y Z : C),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Y Z).inv\n      (CategoryTheory.CategoryStruct.comp (β_ (CategoryTheory.MonoidalCategory.tensorObj X Y) Z).hom\n        (CategoryTheory.MonoidalCategory.associator Z X Y).inv) =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.CategoryStruct.id X) (β_ Y Z).hom)\n      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator X Z Y).inv\n        (CategoryTheory.MonoidalCategory.tensorHom (β_ X Z).hom (CategoryTheory.CategoryStruct.id Y)))","name":"CategoryTheory.BraidedCategory.hexagon_reverse","isProp":true,"docString":"The second hexagon identity. ","distance":0.418571725089993851298686422524042427539825439453125}],[" For any σ-finite measurable kernels η from β to γ and κ from α to β in probability theory, the composition of η and κ is equal to the product kernel of κ with η viewed as a kernel from α to γ.",{"type":"∀ {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {γ : Type u_4}\n  {mγ : MeasurableSpace γ} (η : ↥(ProbabilityTheory.kernel β γ)) [inst : ProbabilityTheory.IsSFiniteKernel η]\n  (κ : ↥(ProbabilityTheory.kernel α β)) [inst : ProbabilityTheory.IsSFiniteKernel κ],\n  ProbabilityTheory.kernel.comp η κ =\n    ProbabilityTheory.kernel.snd (ProbabilityTheory.kernel.compProd κ (ProbabilityTheory.kernel.prodMkLeft α η))","name":"ProbabilityTheory.kernel.comp_eq_snd_compProd","isProp":true,"docString":" For any σ-finite measurable kernels η from β to γ and κ from α to β in probability theory, the composition of η and κ is equal to the product kernel of κ with η viewed as a kernel from α to γ.","distance":0.51469453754540162027097949248855002224445343017578125}],["This theorem states that the Grundy value (which is a concept related to game theory, specifically impartial games) of the sum of two Nim games (where each game has a pile of stones, and players take turns removing a positive number of stones from the pile), where each game has a natural number of piles, is equal to the bitwise XOR of the number of piles in the two games. In other words, given two natural numbers 'n' and 'm' that represent the number of piles in two Nim games, the Grundy value of the game that results from adding these two games together is equal to the natural number that results from applying the bitwise XOR operation to 'n' and 'm'.",{"type":"∀ (n m : ℕ), (SetTheory.PGame.nim ↑n + SetTheory.PGame.nim ↑m).grundyValue = ↑(n ^^^ m)","name":"SetTheory.PGame.grundyValue_nim_add_nim","isProp":true,"docString":"This theorem states that the Grundy value (which is a concept related to game theory, specifically impartial games) of the sum of two Nim games (where each game has a pile of stones, and players take turns removing a positive number of stones from the pile), where each game has a natural number of piles, is equal to the bitwise XOR of the number of piles in the two games. In other words, given two natural numbers 'n' and 'm' that represent the number of piles in two Nim games, the Grundy value of the game that results from adding these two games together is equal to the natural number that results from applying the bitwise XOR operation to 'n' and 'm'.","distance":0.49721660708081938384594877788913436233997344970703125}],["Negation of games. ",{"type":"SetTheory.Game → SetTheory.Game","name":"SetTheory.Game.neg","isProp":false,"docString":"Negation of games. ","distance":0.419268531756499751583788793141138739883899688720703125}],["Eta rule for cocones. ",{"type":"{J : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} J] →\n    {C : Type u₃} →\n      [inst_1 : CategoryTheory.Category.{v₃, u₃} C] →\n        {F : CategoryTheory.Functor J C} → (c : CategoryTheory.Limits.Cocone F) → c ≅ { pt := c.pt, ι := c.ι }","name":"CategoryTheory.Limits.Cocones.eta","isProp":false,"docString":"Eta rule for cocones. ","distance":0.425166959005265965299003028121660463511943817138671875}],["The empty weak sequence ",{"type":"{α : Type u} → Stream'.WSeq α","name":"Stream'.WSeq.nil","isProp":false,"docString":"The empty weak sequence ","distance":0.426388963583908930932153680259943939745426177978515625}],["an endomorphism of the object ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] → (self : CategoryTheory.Idempotents.Karoubi C) → self.X ⟶ self.X","name":"CategoryTheory.Idempotents.Karoubi.p","isProp":false,"docString":"an endomorphism of the object ","distance":0.42689072879277745187209802679717540740966796875}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.429072901020546459971427566415513865649700164794921875}],["Young diagram from a sorted list ",{"type":"(w : List ℕ) → List.Sorted (fun x x_1 => x ≥ x_1) w → YoungDiagram","name":"YoungDiagram.ofRowLens","isProp":false,"docString":"Young diagram from a sorted list ","distance":0.430705587585722249333031186324660666286945343017578125}],["The unique empty cycle. ",{"type":"{α : Type u_1} → Cycle α","name":"Cycle.nil","isProp":false,"docString":"The unique empty cycle. ","distance":0.431473435789754666824791229373659007251262664794921875}],["The empty set is meagre. ",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X], IsMeagre ∅","name":"meagre_empty","isProp":true,"docString":"The empty set is meagre. ","distance":0.43152355381021301194977013437892310321331024169921875}],["There is some split coequalizer ",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f g : X ⟶ Y}\n  [self : CategoryTheory.HasSplitCoequalizer f g], ∃ Z h, Nonempty (CategoryTheory.IsSplitCoequalizer f g h)","name":"CategoryTheory.HasSplitCoequalizer.splittable","isProp":true,"docString":"There is some split coequalizer ","distance":0.432496601918933742947359633035375736653804779052734375}],["The empty finset ",{"type":"{α : Type u_1} → Finset α","name":"Finset.empty","isProp":false,"docString":"The empty finset ","distance":0.433262999247712110584274114444269798696041107177734375}],["Open balls are bounded ",{"type":"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α} {r : ℝ}, Bornology.IsBounded (Metric.ball x r)","name":"Metric.isBounded_ball","isProp":true,"docString":"Open balls are bounded ","distance":0.434432265755036628451790647886809892952442169189453125}],["multiplication commutes ",{"type":"∀ {M : Type u_1} [inst : Mul M] {z : M}, IsMulCentral z → ∀ (a : M), z * a = a * z","name":"IsMulCentral.comm","isProp":true,"docString":"multiplication commutes ","distance":0.434483457254680460746243397807120345532894134521484375}],["The empty reduced word. ",{"type":"(G : Type u_1) → [inst : Group G] → (A B : Subgroup G) → HNNExtension.NormalWord.ReducedWord G A B","name":"HNNExtension.NormalWord.ReducedWord.empty","isProp":false,"docString":"The empty reduced word. ","distance":0.436388199493475681389753617622773163020610809326171875}],["A heavily unfolded version of the definition of multiplication ",{"type":"∀ {ι : Type u_1} [inst : DecidableEq ι] (A : ι → Type u_2) [inst_1 : (i : ι) → AddCommMonoid (A i)]\n  [inst_2 : AddMonoid ι] [inst_3 : DirectSum.GSemiring A] [inst_4 : (i : ι) → (x : A i) → Decidable (x ≠ 0)]\n  (a a' : DirectSum ι fun i => A i),\n  a * a' =\n    Finset.sum (DFinsupp.support a ×ˢ DFinsupp.support a') fun ij =>\n      (DirectSum.of (fun i => A i) (ij.1 + ij.2)) (GradedMonoid.GMul.mul (a ij.1) (a' ij.2))","name":"DirectSum.mul_eq_sum_support_ghas_mul","isProp":true,"docString":"A heavily unfolded version of the definition of multiplication ","distance":0.4365962009801200860437120354617945849895477294921875}],["Seminorm-balls at the origin are balanced. ",{"type":"∀ {𝕜 : Type u_3} {E : Type u_7} [inst : SeminormedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (p : Seminorm 𝕜 E) (r : ℝ), Balanced 𝕜 (Seminorm.ball p 0 r)","name":"Seminorm.balanced_ball_zero","isProp":true,"docString":"Seminorm-balls at the origin are balanced. ","distance":0.437802548160764082307849776043440215289592742919921875}],["The empty pre-set ",{"type":"PSet","name":"PSet.empty","isProp":false,"docString":"The empty pre-set ","distance":0.437859819322116816664447469520382583141326904296875}],["The identity partial equiv ",{"type":"(α : Type u_5) → PartialEquiv α α","name":"PartialEquiv.refl","isProp":false,"docString":"The identity partial equiv ","distance":0.4379250270684611479055092786438763141632080078125}],["There is a splitting ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.43797818744364824805614944125409238040447235107421875}]]