[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9610192199566671700239339770632795989513397216796875}],[" A category has the initial-terminal object property (is an InitialMonoClass) if the unique morphism from the initial object to the terminal object is a monomorphism.",{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {I T : C} (hI : CategoryTheory.Limits.IsInitial I),\n  CategoryTheory.Limits.IsTerminal T ‚Üí CategoryTheory.Mono (hI.to T) ‚Üí CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.InitialMonoClass.of_isTerminal","isProp":true,"docString":" A category has the initial-terminal object property (is an InitialMonoClass) if the unique morphism from the initial object to the terminal object is a monomorphism.","distance":1.95689037894391137939464897499419748783111572265625}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":1.9779139802402740944131664946326054632663726806640625}],["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) ‚Üí [inst : CategoryTheory.Category.{v, u} C] ‚Üí [inst : CategoryTheory.Limits.HasZeroObject C] ‚Üí Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.9667893038026116325767134185298345983028411865234375}],[" The sign of integer 0 is 0. (or equivalently, Int.sign 0 = 0)",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":" The sign of integer 0 is 0. (or equivalently, Int.sign 0 = 0)","distance":1.976093836640014700378742418251931667327880859375}],["This theorem, `neg_zero`, states that for any type `G` that is a member of the `NegZeroClass`, the negation of zero equals zero. In mathematical terms, it means that if `G` has a negation operation and a zero element, then the negation of the zero element is equal to the zero element itself.",{"type":"‚àÄ {G : Type u_1} [inst : NegZeroClass G], -0 = 0","name":"neg_zero","isProp":true,"docString":"This theorem, `neg_zero`, states that for any type `G` that is a member of the `NegZeroClass`, the negation of zero equals zero. In mathematical terms, it means that if `G` has a negation operation and a zero element, then the negation of the zero element is equal to the zero element itself.","distance":1.99207260972252786501712762401439249515533447265625}],["Given an equality, extract a `Category` instance from it or raise an error.\nReturns the name of the category and its instance. ",{"type":"Lean.Expr ‚Üí Lean.MetaM (Lean.Expr √ó Lean.Expr)","name":"Tactic.Elementwise.elementwiseExpr.extractCatInstance","isProp":false,"docString":"Given an equality, extract a `Category` instance from it or raise an error.\nReturns the name of the category and its instance. ","distance":1.9698135695353127250228908451390452682971954345703125}],["This instance is provided instead of `StarAlgHomClass` to avoid type class inference loops.\nSee note [lower instance priority] ",{"type":"{F : Type u_1} ‚Üí\n  {A : Type u_2} ‚Üí\n    [inst : NormedRing A] ‚Üí\n      [inst_1 : NormedAlgebra ‚ÑÇ A] ‚Üí\n        [inst_2 : CompleteSpace A] ‚Üí\n          [inst_3 : StarRing A] ‚Üí\n            [inst_4 : CstarRing A] ‚Üí [inst_5 : StarModule ‚ÑÇ A] ‚Üí [hF : AlgHomClass F ‚ÑÇ A ‚ÑÇ] ‚Üí StarHomClass F A ‚ÑÇ","name":"WeakDual.Complex.instStarHomClass","isProp":false,"docString":"This instance is provided instead of `StarAlgHomClass` to avoid type class inference loops.\nSee note [lower instance priority] ","distance":1.9780546557570739540921067600720562040805816650390625}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{M‚ÇÅ : Type u_1} ‚Üí\n  {M‚ÇÇ : Type u_2} ‚Üí\n    [inst : Zero M‚ÇÅ] ‚Üí\n      [inst_1 : Neg M‚ÇÅ] ‚Üí\n        [inst_2 : NegZeroClass M‚ÇÇ] ‚Üí\n          (f : M‚ÇÅ ‚Üí M‚ÇÇ) ‚Üí Function.Injective f ‚Üí f 0 = 0 ‚Üí (‚àÄ (x : M‚ÇÅ), f (-x) = -f x) ‚Üí NegZeroClass M‚ÇÅ","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":1.9810446827813985581911992994719184935092926025390625}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {f : E ‚Üí Œ≤} {x y z : E}, ConcaveOn ùïú (segment ùïú x y) f ‚Üí z ‚àà segment ùïú x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.98253406431515255547992637730203568935394287109375}],["A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] ‚Üí\n    {D : Type u‚ÇÇ} ‚Üí\n      [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D] ‚Üí\n        {J : Type w} ‚Üí\n          [inst_2 : CategoryTheory.Category.{w', w} J] ‚Üí\n            {K : CategoryTheory.Functor J C} ‚Üí\n              (F : CategoryTheory.Functor C D) ‚Üí\n                {c : CategoryTheory.Limits.Cocone K} ‚Üí\n                  CategoryTheory.Limits.IsColimit (F.mapCocone c) ‚Üí\n                    [inst_3 : CategoryTheory.Limits.ReflectsColimit K F] ‚Üí CategoryTheory.Limits.IsColimit c","name":"CategoryTheory.Limits.isColimitOfReflects","isProp":false,"docString":"A convenience function for `ReflectsColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":1.984631258290358690743460101657547056674957275390625}],["This shortcut instance ensures we do not find `CommSemiring` via the noncomputable\n`Complex.field` instance. ",{"type":"CommSemiring ‚ÑÇ","name":"Complex.instCommSemiringComplex","isProp":false,"docString":"This shortcut instance ensures we do not find `CommSemiring` via the noncomputable\n`Complex.field` instance. ","distance":1.9847169040784982119163259994820691645145416259765625}],["Tests whether `declName` has the `@[simp]` attribute in `env`. ",{"type":"Lean.Environment ‚Üí Lean.Name ‚Üí Bool","name":"hasSimpAttribute","isProp":false,"docString":"Tests whether `declName` has the `@[simp]` attribute in `env`. ","distance":1.9857133517025165048153212410397827625274658203125}],["To show a category is an `InitialMonoClass` it suffices to give an initial object such that\nevery morphism out of it is a monomorphism. ",{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {I : C} (hI : CategoryTheory.Limits.IsInitial I),\n  (‚àÄ (X : C), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)) ‚Üí CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.InitialMonoClass.of_isInitial","isProp":true,"docString":"To show a category is an `InitialMonoClass` it suffices to give an initial object such that\nevery morphism out of it is a monomorphism. ","distance":1.9873121489799097094675062180613167583942413330078125}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9881512837685166861234620228060521185398101806640625}],["If the vector is zero, `secondInter` gives the original point. ",{"type":"‚àÄ (V : Type u_1) {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] (s : EuclideanGeometry.Sphere P) (p : P),\n  EuclideanGeometry.Sphere.secondInter s p 0 = p","name":"EuclideanGeometry.Sphere.secondInter_zero","isProp":true,"docString":"If the vector is zero, `secondInter` gives the original point. ","distance":1.9882296390569516031376906539662741124629974365234375}],["Specialize the existing `Action.œÅ`, changing the type to `Representation k G V`.\n",{"type":"{k G : Type u} ‚Üí [inst : CommRing k] ‚Üí [inst_1 : Monoid G] ‚Üí (V : Rep k G) ‚Üí Representation k G (CoeSort.coe V)","name":"Rep.œÅ","isProp":false,"docString":"Specialize the existing `Action.œÅ`, changing the type to `Representation k G V`.\n","distance":1.9885039646405922031391355631058104336261749267578125}],["Global integral curves are unique.\n\nIf a continuously differentiable vector field `v` admits two global integral curves\n`Œ≥ Œ≥' : ‚Ñù ‚Üí M`, and `Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ` for some `t‚ÇÄ`, then `Œ≥` and `Œ≥'` are equal. ",{"type":"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners ‚Ñù E H} {M : Type u_3} [inst_3 : TopologicalSpace M] [inst_4 : ChartedSpace H M]\n  [inst_5 : SmoothManifoldWithCorners I M] {Œ≥ Œ≥' : ‚Ñù ‚Üí M} {v : (x : M) ‚Üí TangentSpace I x} {t‚ÇÄ : ‚Ñù}\n  [inst_6 : T2Space M],\n  (‚àÄ (t : ‚Ñù), ModelWithCorners.IsInteriorPoint I (Œ≥ t)) ‚Üí\n    (ContMDiff I (ModelWithCorners.tangent I) 1 fun x => { proj := x, snd := v x }) ‚Üí\n      IsIntegralCurve Œ≥ v ‚Üí IsIntegralCurve Œ≥' v ‚Üí Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ ‚Üí Œ≥ = Œ≥'","name":"isIntegralCurve_eq_of_contMDiff","isProp":true,"docString":"Global integral curves are unique.\n\nIf a continuously differentiable vector field `v` admits two global integral curves\n`Œ≥ Œ≥' : ‚Ñù ‚Üí M`, and `Œ≥ t‚ÇÄ = Œ≥' t‚ÇÄ` for some `t‚ÇÄ`, then `Œ≥` and `Œ≥'` are equal. ","distance":1.9885566653505424294934300633030943572521209716796875}],["Construct a bundled `SemigroupCat` from the underlying type and typeclass. ",{"type":"(M : Type u) ‚Üí [inst : Semigroup M] ‚Üí SemigroupCat","name":"SemigroupCat.of","isProp":false,"docString":"Construct a bundled `SemigroupCat` from the underlying type and typeclass. ","distance":1.98856591915645974921744709718041121959686279296875}],["Creates a `TypeName` instance.\n\nFor safety, it is required that the constant `typeName` is definitionally equal\nto `Œ±`.\n",{"type":"(Œ± : Type u) ‚Üí Lean.Name ‚Üí TypeName Œ±","name":"TypeName.mk","isProp":false,"docString":"Creates a `TypeName` instance.\n\nFor safety, it is required that the constant `typeName` is definitionally equal\nto `Œ±`.\n","distance":1.988665892179274141682299159583635628223419189453125}],["An arbitrary `RayVector` giving a ray. ",{"type":"{R : Type u_1} ‚Üí\n  [inst : StrictOrderedCommSemiring R] ‚Üí\n    {M : Type u_2} ‚Üí [inst_1 : AddCommMonoid M] ‚Üí [inst_2 : Module R M] ‚Üí Module.Ray R M ‚Üí RayVector R M","name":"Module.Ray.someRayVector","isProp":false,"docString":"An arbitrary `RayVector` giving a ray. ","distance":1.9887968219502825117928068721084855496883392333984375}],["Reinterpret an `IntermediateField` as a `Subfield`. ",{"type":"{K : Type u_1} ‚Üí\n  {L : Type u_2} ‚Üí [inst : Field K] ‚Üí [inst_1 : Field L] ‚Üí [inst_2 : Algebra K L] ‚Üí IntermediateField K L ‚Üí Subfield L","name":"IntermediateField.toSubfield","isProp":false,"docString":"Reinterpret an `IntermediateField` as a `Subfield`. ","distance":1.9888226176587975313481138073257170617580413818359375}],["Construct a bundled `CommGroup` from the underlying type and typeclass. ",{"type":"(G : Type u) ‚Üí [inst : CommGroup G] ‚Üí CommGroupCat","name":"CommGroupCat.of","isProp":false,"docString":"Construct a bundled `CommGroup` from the underlying type and typeclass. ","distance":1.9889243893818413511098697199486196041107177734375}],["Turn a `SignType` into zero, one, or minus one. This is a coercion instance, but note it is\nonly a `CoeTC` instance: see note [use has_coe_t]. ",{"type":"{Œ± : Type u_1} ‚Üí [inst : Zero Œ±] ‚Üí [inst : One Œ±] ‚Üí [inst : Neg Œ±] ‚Üí SignType ‚Üí Œ±","name":"SignType.cast","isProp":false,"docString":"Turn a `SignType` into zero, one, or minus one. This is a coercion instance, but note it is\nonly a `CoeTC` instance: see note [use has_coe_t]. ","distance":1.9895460039865222601207506158971227705478668212890625}]]