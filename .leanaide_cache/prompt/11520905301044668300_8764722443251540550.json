[["**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ",{"type":"{α : Type u_1} → Ordnode α → α → Ordnode α → Ordnode α","name":"Ordnode.node'","isProp":false,"docString":"**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ","distance":1.9834250401142263786624653221224434673786163330078125}],[" For any rational number r, normalizing r using its numerator and denominator yields the same rational number (i.e., Rat.normalize (numerator r) (denominator r) = r).",{"type":"∀ (r : ℚ), Rat.normalize r.num r.den ⋯ = r","name":"Rat.normalize_self","isProp":true,"docString":" For any rational number r, normalizing r using its numerator and denominator yields the same rational number (i.e., Rat.normalize (numerator r) (denominator r) = r).","distance":2.005892273966873862178772469633258879184722900390625}],["This theorem, named `PadicSeq.lift_index_right`, is about manipulating indices of a `p`-adic sequence, where `p` is a prime number. Specifically, for a given `p`-adic sequence `f` that is not equivalent to the zero sequence, and any two natural numbers `v1` and `v2`, the `p`-adic norm of the `f`th term at the stationary point of `f` is equal to the `p`-adic norm of the `f`th term at the maximum of `v1`, `v2`, and the stationary point of `f`. The stationary point of a `p`-adic sequence is such that beyond this point, the `p`-adic norm of all further terms in the sequence is constant. This theorem allows for flexibility in selecting the index of the `p`-adic sequence while still preserving the `p`-adic norm value.",{"type":"∀ {p : ℕ} [inst : Fact p.Prime] {f : PadicSeq p} (hf : ¬f ≈ 0) (v1 v2 : ℕ),\n  padicNorm p (↑f (PadicSeq.stationaryPoint hf)) = padicNorm p (↑f (max v1 (max v2 (PadicSeq.stationaryPoint hf))))","name":"PadicSeq.lift_index_right","isProp":true,"docString":"This theorem, named `PadicSeq.lift_index_right`, is about manipulating indices of a `p`-adic sequence, where `p` is a prime number. Specifically, for a given `p`-adic sequence `f` that is not equivalent to the zero sequence, and any two natural numbers `v1` and `v2`, the `p`-adic norm of the `f`th term at the stationary point of `f` is equal to the `p`-adic norm of the `f`th term at the maximum of `v1`, `v2`, and the stationary point of `f`. The stationary point of a `p`-adic sequence is such that beyond this point, the `p`-adic norm of all further terms in the sequence is constant. This theorem allows for flexibility in selecting the index of the `p`-adic sequence while still preserving the `p`-adic norm value.","distance":2.025836844683952531198656288324855268001556396484375}],["An uncurried version of `Finset.prod_prod_type_right`. ",{"type":"∀ {γ : Type u_3} {α₁ : Type u_4} {α₂ : Type u_5} [inst : Fintype α₁] [inst_1 : Fintype α₂] [inst_2 : CommMonoid γ]\n  {f : α₁ → α₂ → γ},\n  (Finset.prod Finset.univ fun x => f x.1 x.2) = Finset.prod Finset.univ fun y => Finset.prod Finset.univ fun x => f x y","name":"Fintype.prod_prod_type_right'","isProp":true,"docString":"An uncurried version of `Finset.prod_prod_type_right`. ","distance":1.991690773065367903171818397822789847850799560546875}],[" The `Finset.range` function maps larger natural numbers to larger and unbounded finite sets.",{"type":"Filter.Tendsto Finset.range Filter.atTop Filter.atTop","name":"Filter.tendsto_finset_range","isProp":true,"docString":" The `Finset.range` function maps larger natural numbers to larger and unbounded finite sets.","distance":2.01905466177151371454101536073721945285797119140625}],["The theorem `PadicSeq.stationaryPoint_spec` states that for any prime number `p` and any `p`-adic Cauchy sequence `f` that is not equivalent to zero, if natural numbers `m` and `n` are greater than or equal to the stationary point of `f`, then the `p`-adic norm of `f` at the indices `m` and `n` is the same. In other words, beyond the stationary point of a `p`-adic Cauchy sequence, the `p`-adic norm remains constant.",{"type":"∀ {p : ℕ} [inst : Fact p.Prime] {f : PadicSeq p} (hf : ¬f ≈ 0) {m n : ℕ},\n  PadicSeq.stationaryPoint hf ≤ m → PadicSeq.stationaryPoint hf ≤ n → padicNorm p (↑f n) = padicNorm p (↑f m)","name":"PadicSeq.stationaryPoint_spec","isProp":true,"docString":"The theorem `PadicSeq.stationaryPoint_spec` states that for any prime number `p` and any `p`-adic Cauchy sequence `f` that is not equivalent to zero, if natural numbers `m` and `n` are greater than or equal to the stationary point of `f`, then the `p`-adic norm of `f` at the indices `m` and `n` is the same. In other words, beyond the stationary point of a `p`-adic Cauchy sequence, the `p`-adic norm remains constant.","distance":2.02943955611817017370412941090762615203857421875}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.993725671099874308112021026317961513996124267578125}],["A special case of `Set.image_finset_sum_pi` for `Finset.univ`. ",{"type":"∀ {ι : Type u_1} {α : Type u_2} [inst : AddCommMonoid α] [inst_1 : Fintype ι] (S : ι → Set α),\n  (fun f => Finset.sum Finset.univ fun i => f i) '' Set.pi Set.univ S = Finset.sum Finset.univ fun i => S i","name":"Set.image_fintype_sum_pi","isProp":true,"docString":"A special case of `Set.image_finset_sum_pi` for `Finset.univ`. ","distance":1.994452775785424680776714012608863413333892822265625}],["Restrict the codomain of an `NonUnitalAlgHom` `f` to `f.range`.\n\nThis is the bundled version of `Set.rangeFactorization`. ",{"type":"{F : Type v'} →\n  {R : Type u} →\n    {A : Type v} →\n      {B : Type w} →\n        [inst : CommSemiring R] →\n          [inst_1 : NonUnitalNonAssocSemiring A] →\n            [inst_2 : Module R A] →\n              [inst_3 : NonUnitalNonAssocSemiring B] →\n                [inst_4 : Module R B] →\n                  [inst_5 : NonUnitalAlgHomClass F R A B] → (f : F) → A →ₙₐ[R] ↥(NonUnitalAlgHom.range f)","name":"NonUnitalAlgHom.rangeRestrict","isProp":false,"docString":"Restrict the codomain of an `NonUnitalAlgHom` `f` to `f.range`.\n\nThis is the bundled version of `Set.rangeFactorization`. ","distance":1.9947291398015647434505126511794514954090118408203125}],["An uncurried version of `Finset.prod_product_right`. ",{"type":"∀ {β : Type u} {α : Type v} {γ : Type w} [inst : CommMonoid β] {s : Finset γ} {t : Finset α} {f : γ → α → β},\n  (Finset.prod (s ×ˢ t) fun x => f x.1 x.2) = Finset.prod t fun y => Finset.prod s fun x => f x y","name":"Finset.prod_product_right'","isProp":true,"docString":"An uncurried version of `Finset.prod_product_right`. ","distance":1.99707857136306632384048498352058231830596923828125}],["An uncurried version of `Finset.prod_prod_type`. ",{"type":"∀ {γ : Type u_3} {α₁ : Type u_4} {α₂ : Type u_5} [inst : Fintype α₁] [inst_1 : Fintype α₂] [inst_2 : CommMonoid γ]\n  {f : α₁ → α₂ → γ},\n  (Finset.prod Finset.univ fun x => f x.1 x.2) = Finset.prod Finset.univ fun x => Finset.prod Finset.univ fun y => f x y","name":"Fintype.prod_prod_type'","isProp":true,"docString":"An uncurried version of `Finset.prod_prod_type`. ","distance":1.9986454574002927575548937966232188045978546142578125}],["A version of `convexHull_prod` for `Set.reProdIm`. ",{"type":"∀ (s t : Set ℝ), (convexHull ℝ) (s ×ℂ t) = (convexHull ℝ) s ×ℂ (convexHull ℝ) t","name":"Complex.convexHull_reProdIm","isProp":true,"docString":"A version of `convexHull_prod` for `Set.reProdIm`. ","distance":2.000378822776374132530463612056337296962738037109375}],["A special case of `Set.image_finset_prod_pi` for `Finset.univ`. ",{"type":"∀ {ι : Type u_1} {α : Type u_2} [inst : CommMonoid α] [inst_1 : Fintype ι] (S : ι → Set α),\n  (fun f => Finset.prod Finset.univ fun i => f i) '' Set.pi Set.univ S = Finset.prod Finset.univ fun i => S i","name":"Set.image_fintype_prod_pi","isProp":true,"docString":"A special case of `Set.image_finset_prod_pi` for `Finset.univ`. ","distance":2.0004298765903332224525001947768032550811767578125}],["Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the product is over `Finset.univ`. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"BigOperators.delabFinsetProd","isProp":false,"docString":"Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the product is over `Finset.univ`. ","distance":2.001926362094997191576339901075698435306549072265625}],["Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the sum is over `Finset.univ`. ",{"type":"Lean.PrettyPrinter.Delaborator.Delab","name":"BigOperators.delabFinsetSum","isProp":false,"docString":"Delaborator for `Finset.prod`. The `pp.piBinderTypes` option controls whether\nto show the domain type when the sum is over `Finset.univ`. ","distance":2.002634170556992554423914043582044541835784912109375}],["A version of `Finset.centerMass_mem_convexHull` for when the weights are nonpositive. ",{"type":"∀ {R : Type u_1} {E : Type u_3} {ι : Type u_5} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E]\n  [inst_2 : Module R E] {s : Set E} {w : ι → R} {z : ι → E} (t : Finset ι),\n  (∀ i ∈ t, w i ≤ 0) → (Finset.sum t fun i => w i) < 0 → (∀ i ∈ t, z i ∈ s) → Finset.centerMass t w z ∈ (convexHull R) s","name":"Finset.centerMass_mem_convexHull_of_nonpos","isProp":true,"docString":"A version of `Finset.centerMass_mem_convexHull` for when the weights are nonpositive. ","distance":2.004487581280184560483803579700179398059844970703125}],["The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n",{"type":"{𝕜 : Type u_8} →\n  {𝕜' : Type u_9} →\n    {E : Type u_10} →\n      [inst : NormedField 𝕜'] →\n        [inst_1 : SeminormedAddCommGroup E] → [I : NormedSpace 𝕜' E] → NormedSpace 𝕜' (RestrictScalars 𝕜 𝕜' E)","name":"Module.RestrictScalars.normedSpaceOrig","isProp":false,"docString":"The action of the original normed_field on `RestrictScalars 𝕜 𝕜' E`.\nThis is not an instance as it would be contrary to the purpose of `RestrictScalars`.\n","distance":2.005833795907529637503330377512611448764801025390625}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name → Array Simps.ParsedProjectionData → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":2.005954129617441683564038612530566751956939697265625}],["An uncurried version of `Finset.prod_product`. ",{"type":"∀ {β : Type u} {α : Type v} {γ : Type w} [inst : CommMonoid β] {s : Finset γ} {t : Finset α} {f : γ → α → β},\n  (Finset.prod (s ×ˢ t) fun x => f x.1 x.2) = Finset.prod s fun x => Finset.prod t fun y => f x y","name":"Finset.prod_product'","isProp":true,"docString":"An uncurried version of `Finset.prod_product`. ","distance":2.007130798931559212405772996135056018829345703125}],["Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.",{"type":"Lean.Name → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.mkParsedProjectionData","isProp":false,"docString":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.","distance":2.00845268233283658076970823458395898342132568359375}],["A variant of `List.prod` that has `[x].prod = x` true definitionally.\nThe purpose is to make `FreeMonoid.lift_eval_of` true by `rfl`. ",{"type":"{M : Type u_6} → [inst : Monoid M] → List M → M","name":"FreeMonoid.prodAux","isProp":false,"docString":"A variant of `List.prod` that has `[x].prod = x` true definitionally.\nThe purpose is to make `FreeMonoid.lift_eval_of` true by `rfl`. ","distance":2.0086650093207527589811434154398739337921142578125}],["Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ",{"type":"(X : AlgebraicGeometry.Scheme) → AlgebraicGeometry.IsAffine X → AlgebraicGeometry.AffineScheme","name":"AlgebraicGeometry.AffineScheme.mk","isProp":false,"docString":"Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ","distance":2.009008062336051114726842570235021412372589111328125}],["A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit c →\n                    [inst_3 : CategoryTheory.Limits.PreservesColimit K F] →\n                      CategoryTheory.Limits.IsColimit (F.mapCocone c)","name":"CategoryTheory.Limits.isColimitOfPreserves","isProp":false,"docString":"A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":2.009708900049838486978615037514828145503997802734375}],["Restrict the codomain of a non-unital star algebra homomorphism `f` to `f.range`.\n\nThis is the bundled version of `Set.rangeFactorization`. ",{"type":"{F : Type v'} →\n  {R : Type u} →\n    {A : Type v} →\n      {B : Type w} →\n        [inst : CommSemiring R] →\n          [inst_1 : NonUnitalNonAssocSemiring A] →\n            [inst_2 : Module R A] →\n              [inst_3 : Star A] →\n                [inst_4 : NonUnitalNonAssocSemiring B] →\n                  [inst_5 : Module R B] →\n                    [inst_6 : Star B] →\n                      [inst_7 : NonUnitalStarAlgHomClass F R A B] → (f : F) → A →⋆ₙₐ[R] ↥(NonUnitalStarAlgHom.range f)","name":"NonUnitalStarAlgHom.rangeRestrict","isProp":false,"docString":"Restrict the codomain of a non-unital star algebra homomorphism `f` to `f.range`.\n\nThis is the bundled version of `Set.rangeFactorization`. ","distance":2.01060566887902236743457251577638089656829833984375}]]