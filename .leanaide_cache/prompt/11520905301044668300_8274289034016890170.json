[["A shortcut instance for the common case ",{"type":"(R : Type u_2) →\n  [inst : CommRing R] →\n    [inst_1 : UniformSpace R] →\n      [inst_2 : UniformAddGroup R] → [inst_3 : TopologicalRing R] → Algebra R (UniformSpace.Completion R)","name":"UniformSpace.Completion.algebra'","isProp":false,"docString":"A shortcut instance for the common case ","distance":1.2562638522635920512726670494885183870792388916015625}],[" If `g` is quasi-compact and `(f', g')` is the pullback of `(g, f)`, then `g'` is quasi-compact.",{"type":"CategoryTheory.MorphismProperty.StableUnderBaseChange @AlgebraicGeometry.QuasiCompact","name":"AlgebraicGeometry.quasiCompact_stableUnderBaseChange","isProp":true,"docString":" If `g` is quasi-compact and `(f', g')` is the pullback of `(g, f)`, then `g'` is quasi-compact.","distance":1.527093211580162535057070272159762680530548095703125}],["In the field of algebraic geometry, the **Qcqs lemma** (as introduced by R. Vakil in \"The rising sea\") establishes a key relationship between certain topological spaces and their localizations. Specifically, the theorem states that for any scheme `X` and any open subset `U` of `X` (as represented in the category of topological spaces), if the carrier of `U` is both compact and quasi-separated (abbreviated as qcqs), then for any section `f` of the structure sheaf of `X` over `U`, the space of global sections of `X` localized at the basic open set defined by `f` is isomorphic to the localization of the space of global sections of `X` over `U` at `f`. The localization here is with respect to the submonoid of `R` generated by `f`.",{"type":"∀ {X : AlgebraicGeometry.Scheme} {U : TopologicalSpace.Opens ↑↑X.toPresheafedSpace},\n  IsCompact U.carrier →\n    IsQuasiSeparated U.carrier →\n      ∀ (f : ↑(X.presheaf.obj (Opposite.op U))), IsLocalization.Away f ↑(X.presheaf.obj (Opposite.op (X.basicOpen f)))","name":"AlgebraicGeometry.is_localization_basicOpen_of_qcqs","isProp":true,"docString":"In the field of algebraic geometry, the **Qcqs lemma** (as introduced by R. Vakil in \"The rising sea\") establishes a key relationship between certain topological spaces and their localizations. Specifically, the theorem states that for any scheme `X` and any open subset `U` of `X` (as represented in the category of topological spaces), if the carrier of `U` is both compact and quasi-separated (abbreviated as qcqs), then for any section `f` of the structure sheaf of `X` over `U`, the space of global sections of `X` localized at the basic open set defined by `f` is isomorphic to the localization of the space of global sections of `X` over `U` at `f`. The localization here is with respect to the submonoid of `R` generated by `f`.","distance":1.59865337985065902870474019437097012996673583984375}],["Shortcut to help the elaborator in the common case. ",{"type":"{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → (P : Submodule R M) → SMul R (M ⧸ P)","name":"Submodule.Quotient.instSMul","isProp":false,"docString":"Shortcut to help the elaborator in the common case. ","distance":1.2642670283725385704798327424214221537113189697265625}],[" A small and locally small category is essentially small.",{"type":"∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : Small.{w, u} C]\n  [inst_2 : CategoryTheory.LocallySmall.{w, v, u} C], CategoryTheory.EssentiallySmall.{w, v, u} C","name":"CategoryTheory.essentiallySmall_of_small_of_locallySmall","isProp":true,"docString":" A small and locally small category is essentially small.","distance":1.5401101091853612867765832561417482793331146240234375}],["This theorem states that for any type `α` and any relation `r` on `α` that is irreflexive, if `a` (an element of `α`) is accessible under `r`, then the singleton set `{a}` is also accessible under the `CutExpand` of `r`. Here `Acc` stands for Accessibility, `CutExpand` is a operation on relations, and `IsIrrefl` checks if a relation is irreflexive. Essentially, if an element is accessible in a relation, then this single-element set is also accessible under the expanded cut of that relation, given that the relation is irreflexive.",{"type":"∀ {α : Type u_1} {r : α → α → Prop} [inst : IsIrrefl α r] {a : α}, Acc r a → Acc (Relation.CutExpand r) {a}","name":"Acc.cutExpand","isProp":true,"docString":"This theorem states that for any type `α` and any relation `r` on `α` that is irreflexive, if `a` (an element of `α`) is accessible under `r`, then the singleton set `{a}` is also accessible under the `CutExpand` of `r`. Here `Acc` stands for Accessibility, `CutExpand` is a operation on relations, and `IsIrrefl` checks if a relation is irreflexive. Essentially, if an element is accessible in a relation, then this single-element set is also accessible under the expanded cut of that relation, given that the relation is irreflexive.","distance":1.6408593226870771264458426230703480541706085205078125}],["(Impl) A preliminary definition to avoid timeouts. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    (B : C) →\n      {J : Type w} →\n        (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B)) →\n          CategoryTheory.Functor\n            (CategoryTheory.Limits.Cone (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F))\n            (CategoryTheory.Limits.Cone F)","name":"CategoryTheory.Over.ConstructProducts.conesEquivFunctor","isProp":false,"docString":"(Impl) A preliminary definition to avoid timeouts. ","distance":1.3001132530838208634094144144910387694835662841796875}],["A shortcut instance to prevent timing out. Hopefully to be removed in the future. ",{"type":"(R : Type u) →\n  (S : Type v) →\n    [inst : CommRing R] →\n      [inst_1 : CommRing S] → [inst_2 : Algebra R S] → Module R ↥(KaehlerDifferential.ideal R S).cotangentIdeal","name":"instR","isProp":false,"docString":"A shortcut instance to prevent timing out. Hopefully to be removed in the future. ","distance":1.305024595181699442747458306257613003253936767578125}],["A choice-free shortcut instance. ",{"type":"∀ (α : Type u) [inst : OrderedCommGroup α], MulRightReflectLE α","name":"OrderedCommGroup.toMulRightReflectLE","isProp":true,"docString":"A choice-free shortcut instance. ","distance":1.351680439561199431608429222251288592815399169921875}],["Shortcut instance to help typeclass inference out. ",{"type":"{V : Type u_1} →\n  {P : Type u_2} →\n    [inst : NormedAddCommGroup V] → [inst_1 : MetricSpace P] → [inst_2 : NormedAddTorsor V P] → AddTorsor V P","name":"NormedAddTorsor.toAddTorsor'","isProp":false,"docString":"Shortcut instance to help typeclass inference out. ","distance":1.3575045118200883553782887247507460415363311767578125}],["Shortcut instance, saving 8.5% of compilation time in\n`Mathlib.Analysis.InnerProductSpace.Adjoint`.\n\n(This instance was pinpointed by benchmarks; we didn't do an in depth investigation why it is\nspecifically needed.)\n",{"type":"{R : Type u_1} →\n  {R₂ : Type u_2} →\n    {E : Type u_5} →\n      {E₂ : Type u_6} →\n        [inst : Semiring R] →\n          [inst_1 : Semiring R₂] →\n            {σ₁₂ : R →+* R₂} →\n              {σ₂₁ : R₂ →+* R} →\n                [inst_2 : RingHomInvPair σ₁₂ σ₂₁] →\n                  [inst_3 : RingHomInvPair σ₂₁ σ₁₂] →\n                    [inst_4 : SeminormedAddCommGroup E] →\n                      [inst_5 : SeminormedAddCommGroup E₂] →\n                        [inst_6 : Module R E] → [inst_7 : Module R₂ E₂] → CoeFun (E ≃ₛₗᵢ[σ₁₂] E₂) fun x => E → E₂","name":"LinearIsometryEquiv.instCoeFun","isProp":false,"docString":"Shortcut instance, saving 8.5% of compilation time in\n`Mathlib.Analysis.InnerProductSpace.Adjoint`.\n\n(This instance was pinpointed by benchmarks; we didn't do an in depth investigation why it is\nspecifically needed.)\n","distance":1.36009502405463411633945725043304264545440673828125}],["A choice-free shortcut instance.",{"type":"∀ (α : Type u) [inst : OrderedAddCommGroup α], AddRightReflectLE α","name":"OrderedAddCommGroup.toAddRightReflectLE","isProp":true,"docString":"A choice-free shortcut instance.","distance":1.376646800125474801035352356848306953907012939453125}],["A wrapper for `omega` which prefaces it with some quick and useful attempts ",{"type":"Lean.ParserDescr","name":"CategoryTheory.ComposableArrows.tacticValid","isProp":false,"docString":"A wrapper for `omega` which prefaces it with some quick and useful attempts ","distance":1.393898057939130463722676722682081162929534912109375}],["The first dart of a walk. ",{"type":"{V : Type u} → {G : SimpleGraph V} → {v w : V} → (p : G.Walk v w) → ¬p.Nil → G.Dart","name":"SimpleGraph.Walk.firstDart","isProp":false,"docString":"The first dart of a walk. ","distance":1.39973728418712273224855380249209702014923095703125}],["`Quot1` is a QPF ",{"type":"{n : ℕ} →\n  {F : TypeVec.{u} n → Type u} →\n    (R : ⦃α : TypeVec.{u} n⦄ → F α → F α → Prop) →\n      [q : MvQPF F] →\n        (∀ ⦃α β : TypeVec.{u} n⦄ (a b : F α) (f : α.Arrow β), R a b → R (MvFunctor.map f a) (MvFunctor.map f b)) →\n          MvQPF (MvQPF.Quot1 R)","name":"MvQPF.relQuot","isProp":false,"docString":"`Quot1` is a QPF ","distance":1.401201402698282638681348544196225702762603759765625}],["convenient shortcut to avoid manipulating `ULift` ",{"type":"{F : Type (max u₀ v₀) → Type u₁} →\n  {G : Type v₀ → Type v₁} →\n    [L : ULiftable G F] → [inst : Monad F] → {α : Type (max u₀ v₀)} → {β : Type v₀} → F α → (α → G β) → G β","name":"ULiftable.adaptDown","isProp":false,"docString":"convenient shortcut to avoid manipulating `ULift` ","distance":1.4147958433897016572444726989488117396831512451171875}],["A tactic code action extension. ",{"type":"Type","name":"Batteries.CodeAction.TacticCodeAction","isProp":false,"docString":"A tactic code action extension. ","distance":1.42050021668660608753498308942653238773345947265625}],["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":1.4214977861745057285958182546892203390598297119140625}],["Shortcut version for the commonly arising special case when `p i = π * q i` for some other\nsequence `q`. ",{"type":"∀ {ι : Type u_1} [inst : Countable ι] {a : ι → ℂ} {q : ι → ℝ} {F : ℝ → ℂ} {s : ℂ},\n  (∀ (i : ι), a i = 0 ∨ 0 < q i) →\n    0 < s.re →\n      (∀ t ∈ Set.Ioi 0, HasSum (fun i => a i * ↑(Real.exp (-Real.pi * q i * t))) (F t)) →\n        (Summable fun i => ‖a i‖ / q i ^ s.re) →\n          HasSum (fun i => ↑Real.pi ^ (-s) * Complex.Gamma s * a i / ↑(q i) ^ s) (mellin F s)","name":"hasSum_mellin_pi_mul","isProp":true,"docString":"Shortcut version for the commonly arising special case when `p i = π * q i` for some other\nsequence `q`. ","distance":1.4268688787549776986196548023144714534282684326171875}],["This lemma has an abbreviated name because it is used frequently. ",{"type":"∀ {a : NNReal}, AddLECancellable ↑a","name":"ENNReal.cancel_coe","isProp":true,"docString":"This lemma has an abbreviated name because it is used frequently. ","distance":1.4285871091506321395314671462983824312686920166015625}],["**First moment method**. A measurable function is smaller than its mean on a set of positive\nmeasure. ",{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α} {f : α → ENNReal},\n  μ s ≠ 0 → μ s ≠ ⊤ → AEMeasurable f (μ.restrict s) → 0 < μ {x | x ∈ s ∧ f x ≤ ⨍⁻ (a : α) in s, f a ∂μ}","name":"MeasureTheory.measure_le_setLaverage_pos","isProp":true,"docString":"**First moment method**. A measurable function is smaller than its mean on a set of positive\nmeasure. ","distance":1.4337949542415013848284388586762361228466033935546875}],["Allows us to compare `Expr`s fast. ",{"type":"Mathlib.Explode.Entries → Lean.ExprMap Mathlib.Explode.Entry","name":"Mathlib.Explode.Entries.s","isProp":false,"docString":"Allows us to compare `Expr`s fast. ","distance":1.4339939350253361194376111598103307187557220458984375}],["A split short complex is short exact. ",{"type":"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Preadditive C]\n  {S : CategoryTheory.ShortComplex C} [inst_2 : CategoryTheory.Limits.HasZeroObject C], S.Splitting → S.ShortExact","name":"CategoryTheory.ShortComplex.Splitting.shortExact","isProp":true,"docString":"A split short complex is short exact. ","distance":1.4348825665534565843017844599671661853790283203125}],["A short complex equipped with a splitting is exact. ",{"type":"∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Preadditive C]\n  {S : CategoryTheory.ShortComplex C} [inst_2 : CategoryTheory.Limits.HasZeroObject C], S.Splitting → S.Exact","name":"CategoryTheory.ShortComplex.Splitting.exact","isProp":true,"docString":"A short complex equipped with a splitting is exact. ","distance":1.439475106882259769491838596877641975879669189453125}]]