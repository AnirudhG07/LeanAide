[["The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from Lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",{"type":"Lean.ParserDescr","name":"termℕ","isProp":false,"docString":"The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from Lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n","distance":0.78677740701519105481764881915296427905559539794921875}],[" For any natural number `n`, the zero element of the finite set of size `n` equals the natural number zero.",{"type":"∀ (n : ℕ), ↑0 = 0","name":"Fin.val_zero","isProp":true,"docString":" For any natural number `n`, the zero element of the finite set of size `n` equals the natural number zero.","distance":0.7109255838261165916236450357246212661266326904296875}],["This theorem states that for any natural number 'n', 0 is less than or equal to 'n'. In other words, zero is always less than or equal to any given natural number. This is a fundamental property of natural numbers in mathematics, as no natural number can be negative.",{"type":"∀ (n : ℕ), 0 ≤ n","name":"Nat.zero_le","isProp":true,"docString":"This theorem states that for any natural number 'n', 0 is less than or equal to 'n'. In other words, zero is always less than or equal to any given natural number. This is a fundamental property of natural numbers in mathematics, as no natural number can be negative.","distance":0.77451400523033886447166196376201696693897247314453125}],["The sequence of natural numbers some 0, some 1, ... ",{"type":"Stream'.Seq ℕ","name":"Stream'.Seq.nats","isProp":false,"docString":"The sequence of natural numbers some 0, some 1, ... ","distance":0.890594128928294370695084580802358686923980712890625}],[" For any natural number `n`, `n` is less than 1 if and only if `n` equals 0. (Equivalently, `n < 1` if and only if `n = 0`.)",{"type":"∀ {n : ℕ}, n < 1 ↔ n = 0","name":"Nat.lt_one_iff","isProp":true,"docString":" For any natural number `n`, `n` is less than 1 if and only if `n` equals 0. (Equivalently, `n < 1` if and only if `n = 0`.)","distance":0.7334570133764357624528429369092918932437896728515625}],["The theorem `Cardinal.nat_lt_aleph0` states that for every natural number `n`, the cardinality of `n` is less than `ℵ₀` (aleph null), which is the smallest infinite cardinal. In other words, the size of any finite set of natural numbers is always smaller than the size of the set of all natural numbers.",{"type":"∀ (n : ℕ), ↑n < Cardinal.aleph0","name":"Cardinal.nat_lt_aleph0","isProp":true,"docString":"The theorem `Cardinal.nat_lt_aleph0` states that for every natural number `n`, the cardinality of `n` is less than `ℵ₀` (aleph null), which is the smallest infinite cardinal. In other words, the size of any finite set of natural numbers is always smaller than the size of the set of all natural numbers.","distance":0.77988942112913850479571920004673302173614501953125}],["The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",{"type":"ℕ → ℕ","name":"Nat.pred","isProp":false,"docString":"The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n","distance":0.90653440790430594997673097168444655835628509521484375}],["Type of natural numbers with infinity (`⊤`) ",{"type":"Type","name":"PartENat","isProp":false,"docString":"Type of natural numbers with infinity (`⊤`) ","distance":0.9149776451957458700547931584878824651241302490234375}],["A natural number `n` is the **Frobenius number** of a set of natural numbers `s` if it is an\nupper bound on the complement of the additive submonoid generated by `s`.\nIn other words, it is the largest number that can not be expressed as a sum of numbers in `s`. ",{"type":"ℕ → Set ℕ → Prop","name":"FrobeniusNumber","isProp":false,"docString":"A natural number `n` is the **Frobenius number** of a set of natural numbers `s` if it is an\nupper bound on the complement of the additive submonoid generated by `s`.\nIn other words, it is the largest number that can not be expressed as a sum of numbers in `s`. ","distance":0.9162167349519878545294204741367138922214508056640625}],["Addition of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n",{"type":"ℕ → ℕ → ℕ","name":"Nat.add","isProp":false,"docString":"Addition of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n","distance":0.9182650335652338124958760090521536767482757568359375}],["The set of natural numbers is equivalent to `ℕ ⊕ PUnit`. ",{"type":"ℕ ≃ ℕ ⊕ PUnit.{u_9 + 1}","name":"Equiv.natEquivNatSumPUnit","isProp":false,"docString":"The set of natural numbers is equivalent to `ℕ ⊕ PUnit`. ","distance":0.92381499653773690994285061606205999851226806640625}],["The number of bits required to represent a `Num`, as a `Nat`. `size 0` is defined to be `0`. ",{"type":"Num → ℕ","name":"Num.natSize","isProp":false,"docString":"The number of bits required to represent a `Num`, as a `Nat`. `size 0` is defined to be `0`. ","distance":0.9242845642934245375954560586251318454742431640625}],["The strict series `0 < … < n` in `ℕ`. ",{"type":"ℕ → LTSeries ℕ","name":"LTSeries.range","isProp":false,"docString":"The strict series `0 < … < n` in `ℕ`. ","distance":0.924568060491033794079385188524611294269561767578125}],["The minimum non-zero entry in a list of natural numbers, or zero if all entries are zero.\n\nWe completely characterize the function via\n`nonzeroMinimum_eq_zero_iff` and `nonzeroMinimum_eq_nonzero_iff` below.\n",{"type":"List ℕ → ℕ","name":"List.nonzeroMinimum","isProp":false,"docString":"The minimum non-zero entry in a list of natural numbers, or zero if all entries are zero.\n\nWe completely characterize the function via\n`nonzeroMinimum_eq_zero_iff` and `nonzeroMinimum_eq_nonzero_iff` below.\n","distance":0.9337131334498696144663654195028357207775115966796875}],["`⌊a⌋₊` is the greatest natural `n` such that `n ≤ a`. If `a` is negative, then `⌊a⌋₊ = 0`. ",{"type":"{α : Type u_2} → [inst : OrderedSemiring α] → [inst : FloorSemiring α] → α → ℕ","name":"Nat.floor","isProp":false,"docString":"`⌊a⌋₊` is the greatest natural `n` such that `n ≤ a`. If `a` is negative, then `⌊a⌋₊ = 0`. ","distance":0.93572662143068630058451162767596542835235595703125}],["`Nat.find` is the minimum element of a nonempty set of natural numbers. ",{"type":"∀ {s : Set ℕ} [inst : DecidablePred fun x => x ∈ s] (hs : s.Nonempty), IsLeast s (Nat.find hs)","name":"Set.Nonempty.isLeast_natFind","isProp":true,"docString":"`Nat.find` is the minimum element of a nonempty set of natural numbers. ","distance":0.94523568700944216036674561109975911676883697509765625}],["The \"size\" of an element, a natural number which decreases on fields of\neach inductive type. ",{"type":"{α : Sort u} → [self : SizeOf α] → α → ℕ","name":"SizeOf.sizeOf","isProp":false,"docString":"The \"size\" of an element, a natural number which decreases on fields of\neach inductive type. ","distance":0.9461316630221470180828191587352193892002105712890625}],["The type of integers. It is defined as an inductive type based on the\nnatural number type `Nat` featuring two constructors: \"a natural\nnumber is an integer\", and \"the negation of a successor of a natural\nnumber is an integer\". The former represents integers between `0`\n(inclusive) and `∞`, and the latter integers between `-∞` and `-1`\n(inclusive).\n\nThis type is special-cased by the compiler. The runtime has a special\nrepresentation for `Int` which stores \"small\" signed numbers directly,\nand larger numbers use an arbitrary precision \"bignum\" library\n(usually [GMP](https://gmplib.org/)). A \"small number\" is an integer\nthat can be encoded with 63 bits (31 bits on 32-bits architectures).\n",{"type":"Lean.ParserDescr","name":"termℤ","isProp":false,"docString":"The type of integers. It is defined as an inductive type based on the\nnatural number type `Nat` featuring two constructors: \"a natural\nnumber is an integer\", and \"the negation of a successor of a natural\nnumber is an integer\". The former represents integers between `0`\n(inclusive) and `∞`, and the latter integers between `-∞` and `-1`\n(inclusive).\n\nThis type is special-cased by the compiler. The runtime has a special\nrepresentation for `Int` which stores \"small\" signed numbers directly,\nand larger numbers use an arbitrary precision \"bignum\" library\n(usually [GMP](https://gmplib.org/)). A \"small number\" is an integer\nthat can be encoded with 63 bits (31 bits on 32-bits architectures).\n","distance":0.953933322385801307774499946390278637409210205078125}],["(Truncated) subtraction of natural numbers. Because natural numbers are not\nclosed under subtraction, we define `n - m` to be `0` when `n < m`.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n",{"type":"ℕ → ℕ → ℕ","name":"Nat.sub","isProp":false,"docString":"(Truncated) subtraction of natural numbers. Because natural numbers are not\nclosed under subtraction, we define `n - m` to be `0` when `n < m`.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n","distance":0.9571594236046989667698881021351553499698638916015625}],["A list of natural numbers is a Zeckendorf representation (of a natural number) if it is an\nincreasing sequence of non-consecutive numbers greater than or equal to `2`.\n\nThis is relevant for Zeckendorf's theorem, since if we write a natural `n` as a sum of Fibonacci\nnumbers `(l.map fib).sum`, `IsZeckendorfRep l` exactly means that we can't simplify any expression\nof the form `fib n + fib (n + 1) = fib (n + 2)`, `fib 1 = fib 2` or `fib 0 = 0` in the sum. ",{"type":"List ℕ → Prop","name":"List.IsZeckendorfRep","isProp":false,"docString":"A list of natural numbers is a Zeckendorf representation (of a natural number) if it is an\nincreasing sequence of non-consecutive numbers greater than or equal to `2`.\n\nThis is relevant for Zeckendorf's theorem, since if we write a natural `n` as a sum of Fibonacci\nnumbers `(l.map fib).sum`, `IsZeckendorfRep l` exactly means that we can't simplify any expression\nof the form `fib n + fib (n + 1) = fib (n + 2)`, `fib 1 = fib 2` or `fib 0 = 0` in the sum. ","distance":0.960265782159059000377965276129543781280517578125}],["`⌈a⌉₊` is the least natural `n` such that `a ≤ n` ",{"type":"Lean.ParserDescr","name":"Nat.«term⌈_⌉₊»","isProp":false,"docString":"`⌈a⌉₊` is the least natural `n` such that `a ≤ n` ","distance":0.9611999217365034819948732547345571219921112060546875}],["The integers modulo `n : ℕ`. ",{"type":"ℕ → Type","name":"ZMod","isProp":false,"docString":"The integers modulo `n : ℕ`. ","distance":0.9634270414345691424529150026501156389713287353515625}],["Find the `n`-th natural number satisfying `p` (indexed from `0`, so `nth p 0` is the first\nnatural number satisfying `p`), or `0` if there is no such number. See also\n`Subtype.orderIsoOfNat` for the order isomorphism with ℕ when `p` is infinitely often true. ",{"type":"(ℕ → Prop) → ℕ → ℕ","name":"Nat.nth","isProp":false,"docString":"Find the `n`-th natural number satisfying `p` (indexed from `0`, so `nth p 0` is the first\nnatural number satisfying `p`), or `0` if there is no such number. See also\n`Subtype.orderIsoOfNat` for the order isomorphism with ℕ when `p` is infinitely often true. ","distance":0.96419478006393866120760094418074004352092742919921875}],["The underlying natural number ",{"type":"ℕ+ → ℕ","name":"PNat.val","isProp":false,"docString":"The underlying natural number ","distance":0.965717798420115958180076631833799183368682861328125}]]