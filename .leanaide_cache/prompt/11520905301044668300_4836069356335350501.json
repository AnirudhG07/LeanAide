[["A single variable `n` is represented by a sum with coefficient `1` and monomial `n`. ",{"type":"ℕ → Linarith.Sum","name":"Linarith.var","isProp":false,"docString":"A single variable `n` is represented by a sum with coefficient `1` and monomial `n`. ","distance":0.66131185442184181599856174216256476938724517822265625}],[" For all natural numbers n, n = n / 1.",{"type":"∀ (n : ℕ), n / 1 = n","name":"Nat.div_one","isProp":true,"docString":" For all natural numbers n, n = n / 1.","distance":0.6392018680017625964495664447895251214504241943359375}],["This theorem states that for any integer `n`, `n` is a unit in the monoid of integers if and only if the absolute value of `n` is `1`. In more mathematical terms, an integer `n` has a two-sided inverse (making it a unit) if and only if the absolute value of `n` (represented by `Int.natAbs n` in Lean) equals `1`. The two-sided inverse here would be the multiplicative inverse, as the integers form a monoid under multiplication.",{"type":"∀ {n : ℤ}, IsUnit n ↔ n.natAbs = 1","name":"Int.isUnit_iff_natAbs_eq","isProp":true,"docString":"This theorem states that for any integer `n`, `n` is a unit in the monoid of integers if and only if the absolute value of `n` is `1`. In more mathematical terms, an integer `n` has a two-sided inverse (making it a unit) if and only if the absolute value of `n` (represented by `Int.natAbs n` in Lean) equals `1`. The two-sided inverse here would be the multiplicative inverse, as the integers form a monoid under multiplication.","distance":0.77827475252987843301610837443149648606777191162109375}],["The constant function with value `n : ℤ`. ",{"type":"{α : Type u_1} → ℤ → Poly α","name":"Poly.const","isProp":false,"docString":"The constant function with value `n : ℤ`. ","distance":0.67385556315224715007161648827604949474334716796875}],[" An integer `n` is a unit in the monoid of integers if and only if |n| = 1, where |n| represents the absolute value of `n`.",{"type":"∀ {n : ℤ}, IsUnit n ↔ n.natAbs = 1","name":"Int.isUnit_iff_natAbs_eq","isProp":true,"docString":" An integer `n` is a unit in the monoid of integers if and only if |n| = 1, where |n| represents the absolute value of `n`.","distance":0.64117483688278353870515502421767450869083404541015625}],["This theorem states that for any natural number `n`, the product of `1` and `n` is equal to `n`. In the language of mathematics, it asserts that 1 is the multiplicative identity in the set of natural numbers, i.e., multiplying any natural number by 1 results in the same number.",{"type":"∀ (n : ℕ), 1 * n = n","name":"Nat.one_mul","isProp":true,"docString":"This theorem states that for any natural number `n`, the product of `1` and `n` is equal to `n`. In the language of mathematics, it asserts that 1 is the multiplicative identity in the set of natural numbers, i.e., multiplying any natural number by 1 results in the same number.","distance":0.78575098119597608370412444855901412665843963623046875}],["The integers modulo `n : ℕ`. ",{"type":"ℕ → Type","name":"ZMod","isProp":false,"docString":"The integers modulo `n : ℕ`. ","distance":0.72325624558600132285590689207310788333415985107421875}],["There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ",{"type":"∀ (N n : ℕ), (Finset.filter (fun k => k ≠ 0 ∧ n ∣ k) (Finset.range N.succ)).card = N / n","name":"Nat.card_multiples'","isProp":true,"docString":"There are exactly `⌊N/n⌋` positive multiples of `n` that are `≤ N`.\nSee `Nat.card_multiples` for a \"shifted-by-one\" version. ","distance":0.78353238572994088340095686362474225461483001708984375}],["Multiplication by `(n + 1 : ℕ)` behaves as expected. ",{"type":"∀ {M : Type u} [self : AddMonoid M] (n : ℕ) (x : M), AddMonoid.nsmul (n + 1) x = AddMonoid.nsmul n x + x","name":"AddMonoid.nsmul_succ","isProp":true,"docString":"Multiplication by `(n + 1 : ℕ)` behaves as expected. ","distance":0.784435032531479503603577541070990264415740966796875}],["The limit of `n / (n + x)` is 1, for any constant `x` (valid in `ℝ` or any topological division\nalgebra over `ℝ`, e.g., `ℂ`).\n\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\nstatement simultaneously on `ℚ`, `ℝ` and `ℂ`. ",{"type":"∀ {\u0000\u0000 : Type u_4} [inst : DivisionRing \u0000\u0000] [inst_1 : TopologicalSpace \u0000\u0000] [inst_2 : CharZero \u0000\u0000] [inst_3 : Algebra ℝ \u0000\u0000]\n  [inst_4 : ContinuousSMul ℝ \u0000\u0000] [inst_5 : TopologicalDivisionRing \u0000\u0000] (x : \u0000\u0000),\n  Filter.Tendsto (fun n => ↑n / (↑n + x)) Filter.atTop (nhds 1)","name":"tendsto_natCast_div_add_atTop","isProp":true,"docString":"The limit of `n / (n + x)` is 1, for any constant `x` (valid in `ℝ` or any topological division\nalgebra over `ℝ`, e.g., `ℂ`).\n\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\nstatement simultaneously on `ℚ`, `ℝ` and `ℂ`. ","distance":0.79238277335174200910472563919029198586940765380859375}],["Multiplication by `n` is a polynomial function. ",{"type":"∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ), WittVector.IsPoly p fun x _Rcr x_1 => x_1 * ↑n","name":"WittVector.mulN_isPoly","isProp":true,"docString":"Multiplication by `n` is a polynomial function. ","distance":0.80771019911689478920635565373231656849384307861328125}],["Multiplication modulo `n` ",{"type":"{n : ℕ} → Fin n → Fin n → Fin n","name":"Fin.mul","isProp":false,"docString":"Multiplication modulo `n` ","distance":0.808757722220069918961371513432823121547698974609375}],["If `n % 4 = 1`, then `(-1)^(n/2) = 1`. ",{"type":"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1","name":"ZMod.neg_one_pow_div_two_of_one_mod_four","isProp":true,"docString":"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. ","distance":0.8329243882031265311383094740449450910091400146484375}],["Multiplication by an integer `n` on a commutative additive group,\nconsidered as an additive group homomorphism.",{"type":"{α : Type u_1} → [inst : SubtractionCommMonoid α] → ℤ → α →+ α","name":"zsmulAddGroupHom","isProp":false,"docString":"Multiplication by an integer `n` on a commutative additive group,\nconsidered as an additive group homomorphism.","distance":0.83657276605489816478922193709877319633960723876953125}],["`ℤ` modulo multiples of `n : ℕ` is `ZMod n`. ",{"type":"(n : ℕ) → ℤ ⧸ AddSubgroup.zmultiples ↑n ≃+ ZMod n","name":"Int.quotientZMultiplesNatEquivZMod","isProp":false,"docString":"`ℤ` modulo multiples of `n : ℕ` is `ZMod n`. ","distance":0.84590162941520929962280206382274627685546875}],["The sequence `n / (2 * n + 1)` tends to `1/2` ",{"type":"Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2))","name":"Stirling.tendsto_self_div_two_mul_self_add_one","isProp":true,"docString":"The sequence `n / (2 * n + 1)` tends to `1/2` ","distance":0.8478997103351286757089155798894353210926055908203125}],["If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. ",{"type":"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'","name":"Nat.exists_eq_pow_mul_and_not_dvd","isProp":true,"docString":"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. ","distance":0.849091090307819484905849094502627849578857421875}],["Simplification procedure for `#[...][n]` for `n` a `Nat` literal. ",{"type":"Lean.Meta.Simp.DSimproc","name":"Array.reduceGetElem","isProp":false,"docString":"Simplification procedure for `#[...][n]` for `n` a `Nat` literal. ","distance":0.851209938002361443665222395793534815311431884765625}],["If the integer `n` is a sum of two squares of coprime integers,\nthen `-1` is a square modulo `n`. ",{"type":"∀ {n x y : ℤ}, n = x ^ 2 + y ^ 2 → IsCoprime x y → IsSquare (-1)","name":"ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_isCoprime","isProp":true,"docString":"If the integer `n` is a sum of two squares of coprime integers,\nthen `-1` is a square modulo `n`. ","distance":0.85483046134809004268362286893534474074840545654296875}],["Simplification procedure for `#[...][n]?` for `n` a `Nat` literal. ",{"type":"Lean.Meta.Simp.DSimproc","name":"Array.reduceGetElem?","isProp":false,"docString":"Simplification procedure for `#[...][n]?` for `n` a `Nat` literal. ","distance":0.859820577150733900140266996459104120731353759765625}],["Compute `i / n`, where `n` is a `Nat` and inferred the type of `i`. ",{"type":"{n m : ℕ} → Fin (m * n) → Fin m","name":"Fin.divNat","isProp":false,"docString":"Compute `i / n`, where `n` is a `Nat` and inferred the type of `i`. ","distance":0.86376930826524855877579511798103339970111846923828125}],["Equivalence between `ℕ` and `ZMod N × ℕ`, sending `n` to `(n mod N, n / N)`. ",{"type":"(N : ℕ) → [inst : NeZero N] → ℕ ≃ ZMod N × ℕ","name":"Nat.residueClassesEquiv","isProp":false,"docString":"Equivalence between `ℕ` and `ZMod N × ℕ`, sending `n` to `(n mod N, n / N)`. ","distance":0.8648266225568905785081597059615887701511383056640625}],["If `n % 4 = 3`, then `(-1)^(n/2) = -1`. ",{"type":"∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1","name":"ZMod.neg_one_pow_div_two_of_three_mod_four","isProp":true,"docString":"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. ","distance":0.86870467513144544735581575878313742578029632568359375}],["If `n` is non-zero, converting the value of a `Fin n` to `Fin n` results\nin the same value. ",{"type":"∀ {n : ℕ} [inst : NeZero n] (a : Fin n), ↑↑a = a","name":"Fin.cast_val_eq_self","isProp":true,"docString":"If `n` is non-zero, converting the value of a `Fin n` to `Fin n` results\nin the same value. ","distance":0.871220049929976259051045417436398565769195556640625}]]