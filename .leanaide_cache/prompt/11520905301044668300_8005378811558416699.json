[["Convert a pre-set to a `set` of pre-sets. ",{"type":"PSet → Set PSet","name":"PSet.toSet","isProp":false,"docString":"Convert a pre-set to a `set` of pre-sets. ","distance":1.9897072530655399713594988497789017856121063232421875}],[" The normalization of a natural number expression constraint does not change its denotation within a given context.",{"type":"∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx c.toNormPoly = Nat.Linear.ExprCnstr.denote ctx c","name":"Nat.Linear.ExprCnstr.denote_toNormPoly","isProp":true,"docString":" The normalization of a natural number expression constraint does not change its denotation within a given context.","distance":2.02475537427238183596500675776042044162750244140625}],["This theorem, `Rack.right_inv`, states that for any type `α` that has a `Rack` structure, and for any element `x` of this type `α`, the function `Rack.invAct x` is a right inverse to the function `Shelf.act x`. In other words, if you first apply `Shelf.act x` and then `Rack.invAct x`, you will get back the original element. This is expressed in functional terms as `Shelf.act x ∘ Rack.invAct x = id`, where `id` is the identity function.",{"type":"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.right_inv","isProp":true,"docString":"This theorem, `Rack.right_inv`, states that for any type `α` that has a `Rack` structure, and for any element `x` of this type `α`, the function `Rack.invAct x` is a right inverse to the function `Shelf.act x`. In other words, if you first apply `Shelf.act x` and then `Rack.invAct x`, you will get back the original element. This is expressed in functional terms as `Shelf.act x ∘ Rack.invAct x = id`, where `id` is the identity function.","distance":2.0443262519735352356065050116740167140960693359375}],["First samples a proxy value and interprets it. Especially useful if\nthe proxy and target type are the same. ",{"type":"(α : Type u) → [inst : SlimCheck.SampleableExt α] → SlimCheck.Gen α","name":"SlimCheck.SampleableExt.interpSample","isProp":false,"docString":"First samples a proxy value and interprets it. Especially useful if\nthe proxy and target type are the same. ","distance":1.9908548191941350946621014372794888913631439208984375}],[" For any non-negative integer `z`, normalizing `z` using Lean's `normalize` function returns `z`.",{"type":"∀ {z : ℤ}, 0 ≤ z → normalize z = z","name":"Int.normalize_of_nonneg","isProp":true,"docString":" For any non-negative integer `z`, normalizing `z` using Lean's `normalize` function returns `z`.","distance":2.036404519717311512039259469020180404186248779296875}],["The theorem `Nat.Linear.ExprCnstr.denote_toNormPoly` states that for any context from the set of natural numbers (`Nat.Linear.Context`) and any expression constraint (`Nat.Linear.ExprCnstr`), the denotation of the normalized polynomial constraint derived from this expression constraint (`Nat.Linear.ExprCnstr.toNormPoly c`) within the given context is equivalent to the denotation of the original expression constraint within the same context (`Nat.Linear.ExprCnstr.denote ctx c`). In simple terms, normalizing an expression constraint does not change its denotation (interpretation) within a given context.",{"type":"∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx c.toNormPoly = Nat.Linear.ExprCnstr.denote ctx c","name":"Nat.Linear.ExprCnstr.denote_toNormPoly","isProp":true,"docString":"The theorem `Nat.Linear.ExprCnstr.denote_toNormPoly` states that for any context from the set of natural numbers (`Nat.Linear.Context`) and any expression constraint (`Nat.Linear.ExprCnstr`), the denotation of the normalized polynomial constraint derived from this expression constraint (`Nat.Linear.ExprCnstr.toNormPoly c`) within the given context is equivalent to the denotation of the original expression constraint within the same context (`Nat.Linear.ExprCnstr.denote ctx c`). In simple terms, normalizing an expression constraint does not change its denotation (interpretation) within a given context.","distance":2.044940279622074807974740906502120196819305419921875}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name → Simps.ParsedProjectionData → List Lean.Level → Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.9981703216932213962309106136672198772430419921875}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":2.00506261792699813639728745329193770885467529296875}],["Reinterpret an `OpenSubgroup` as a `Subgroup`. ",{"type":"{G : Type u_1} → [inst : Group G] → [inst_1 : TopologicalSpace G] → OpenSubgroup G → Subgroup G","name":"OpenSubgroup.toSubgroup","isProp":false,"docString":"Reinterpret an `OpenSubgroup` as a `Subgroup`. ","distance":2.006868538039260574379341051098890602588653564453125}],["An uncurried version of `Finset.prod_prod_type_right`. ",{"type":"∀ {γ : Type u_3} {α₁ : Type u_4} {α₂ : Type u_5} [inst : Fintype α₁] [inst_1 : Fintype α₂] [inst_2 : CommMonoid γ]\n  {f : α₁ → α₂ → γ},\n  (Finset.prod Finset.univ fun x => f x.1 x.2) = Finset.prod Finset.univ fun y => Finset.prod Finset.univ fun x => f x y","name":"Fintype.prod_prod_type_right'","isProp":true,"docString":"An uncurried version of `Finset.prod_prod_type_right`. ","distance":2.009581931125257181491861047106795012950897216796875}],["Decode %HH escapings in the given string. Note that sometimes a consecutive\nsequence of multiple escapings can represent a utf-8 encoded sequence for\na single unicode code point and these will also be decoded correctly. ",{"type":"String → String","name":"System.Uri.UriEscape.decodeUri","isProp":false,"docString":"Decode %HH escapings in the given string. Note that sometimes a consecutive\nsequence of multiple escapings can represent a utf-8 encoded sequence for\na single unicode code point and these will also be decoded correctly. ","distance":2.010133686940140496091089516994543373584747314453125}],["Given an offset of a codepoint into the substring,\nreturn the offset there of the previous codepoint. ",{"type":"Substring → String.Pos → String.Pos","name":"Substring.prev","isProp":false,"docString":"Given an offset of a codepoint into the substring,\nreturn the offset there of the previous codepoint. ","distance":2.01079048771832891162603118573315441608428955078125}],["Replaces all %HH Uri escapings in the given string with their\ncorresponding unicode code points.  Note that sometimes a consecutive\nsequence of multiple escapings can represent a utf-8 encoded sequence for\na single unicode code point and these will also be decoded correctly. ",{"type":"String → String","name":"System.Uri.unescapeUri","isProp":false,"docString":"Replaces all %HH Uri escapings in the given string with their\ncorresponding unicode code points.  Note that sometimes a consecutive\nsequence of multiple escapings can represent a utf-8 encoded sequence for\na single unicode code point and these will also be decoded correctly. ","distance":2.01186246670268698011341257370077073574066162109375}],["Principal segment version of the `typein` function, embedding a well order into\nordinals as a principal segment. ",{"type":"{α : Type u} → (r : α → α → Prop) → [inst : IsWellOrder α r] → r ≺i fun x x_1 => x < x_1","name":"Ordinal.typein.principalSeg","isProp":false,"docString":"Principal segment version of the `typein` function, embedding a well order into\nordinals as a principal segment. ","distance":2.01189060382478945854245466762222349643707275390625}],["**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ",{"type":"{α : Type u_1} → Ordnode α → α → Ordnode α → Ordnode α","name":"Ordnode.node'","isProp":false,"docString":"**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ","distance":2.015491464921495889939251355826854705810546875}],["Add an inactive bit at the end of a `SNum`. This mimics `ZNum.bit0`. ",{"type":"SNum → SNum","name":"SNum.bit0","isProp":false,"docString":"Add an inactive bit at the end of a `SNum`. This mimics `ZNum.bit0`. ","distance":2.017867040788956956021138466894626617431640625}],["The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n",{"type":"ℕ → ℕ","name":"Nat.pred","isProp":false,"docString":"The predecessor function on natural numbers.\n\nThis definition is overridden in the compiler to use `n - 1` instead.\nThe definition provided here is the logical model.\n","distance":2.01786729746430015808300595381297171115875244140625}],["Replace the sub-expression at the given position by a fresh meta-variable. ",{"type":"Lean.Expr → Lean.SubExpr.Pos → Lean.MetaM Lean.Expr","name":"insertMetaVar","isProp":false,"docString":"Replace the sub-expression at the given position by a fresh meta-variable. ","distance":2.018765904216366369183788265218026936054229736328125}],["An uncurried version of `Finset.prod_product_right`. ",{"type":"∀ {β : Type u} {α : Type v} {γ : Type w} [inst : CommMonoid β] {s : Finset γ} {t : Finset α} {f : γ → α → β},\n  (Finset.prod (s ×ˢ t) fun x => f x.1 x.2) = Finset.prod t fun y => Finset.prod s fun x => f x y","name":"Finset.prod_product_right'","isProp":true,"docString":"An uncurried version of `Finset.prod_product_right`. ","distance":2.01929711522701627046672001597471535205841064453125}],["Canonical prefunctor from `B` to `free_bicategory B`. ",{"type":"{B : Type u} → [inst : Quiver B] → B ⥤q CategoryTheory.FreeBicategory B","name":"CategoryTheory.FreeBicategory.of","isProp":false,"docString":"Canonical prefunctor from `B` to `free_bicategory B`. ","distance":2.02012381910476079838190344162285327911376953125}],["A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    {D : Type u₂} →\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} D] →\n        {J : Type w} →\n          [inst_2 : CategoryTheory.Category.{w', w} J] →\n            {K : CategoryTheory.Functor J C} →\n              (F : CategoryTheory.Functor C D) →\n                {c : CategoryTheory.Limits.Cocone K} →\n                  CategoryTheory.Limits.IsColimit c →\n                    [inst_3 : CategoryTheory.Limits.PreservesColimit K F] →\n                      CategoryTheory.Limits.IsColimit (F.mapCocone c)","name":"CategoryTheory.Limits.isColimitOfPreserves","isProp":false,"docString":"A convenience function for `PreservesColimit`, which takes the functor as an explicit argument to\nguide typeclass resolution.\n","distance":2.020253216984297051084240592899732291698455810546875}],["Reinterpret an `OpenAddSubgroup` as an `AddSubgroup`. ",{"type":"{G : Type u_1} → [inst : AddGroup G] → [inst_1 : TopologicalSpace G] → OpenAddSubgroup G → AddSubgroup G","name":"OpenAddSubgroup.toAddSubgroup","isProp":false,"docString":"Reinterpret an `OpenAddSubgroup` as an `AddSubgroup`. ","distance":2.020583305479231928103445170563645660877227783203125}],["Translate a normal instruction. For the `write` command, we use a `goto` indirection so that\nwe can access the current value of the tape. ",{"type":"{Γ : Type u_1} →\n  {Λ : Type u_2} →\n    {σ : Type u_3} → {n : ℕ} → (Vector Bool n → Γ) → Turing.TM1.Stmt Γ Λ σ → Turing.TM1.Stmt Bool Turing.TM1to1.Λ' σ","name":"Turing.TM1to1.trNormal","isProp":false,"docString":"Translate a normal instruction. For the `write` command, we use a `goto` indirection so that\nwe can access the current value of the tape. ","distance":2.0207558586680658407885857741348445415496826171875}],["Prefunctors between two `SingleObj` quivers correspond to functions between the corresponding\narrows types.\n",{"type":"{α : Type u_1} → {β : Type u_2} → (α → β) ≃ Quiver.SingleObj α ⥤q Quiver.SingleObj β","name":"Quiver.SingleObj.toPrefunctor","isProp":false,"docString":"Prefunctors between two `SingleObj` quivers correspond to functions between the corresponding\narrows types.\n","distance":2.0212385731321571569196748896501958370208740234375}]]