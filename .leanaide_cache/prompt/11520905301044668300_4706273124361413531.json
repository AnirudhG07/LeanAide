[["If `a` commutes with both `b` and `c`, then it commutes with their sum.",{"type":"∀ {S : Type u_3} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)","name":"AddCommute.add_right","isProp":true,"docString":"If `a` commutes with both `b` and `c`, then it commutes with their sum.","distance":0.68658482041481405655503067464451305568218231201171875}],[" For extended nonnegative real numbers `a`, `b`, and `c`, the quotient of their sum by `c` equals the sum of their individual quotients by `c`. That is, $(a + b) / c = a / c + b / c$.",{"type":"∀ {a b c : ENNReal}, (a + b) / c = a / c + b / c","name":"ENNReal.add_div","isProp":true,"docString":" For extended nonnegative real numbers `a`, `b`, and `c`, the quotient of their sum by `c` equals the sum of their individual quotients by `c`. That is, $(a + b) / c = a / c + b / c$.","distance":0.6933942142177367262689813287579454481601715087890625}],["This theorem states that for any two real numbers 'a' and 'b', the Cauchy sequence of the sum of 'a' and 'b' is equal to the sum of the Cauchy sequences of 'a' and 'b'. In other words, the operation of adding two real numbers commutes with the operation of taking their Cauchy sequences.",{"type":"∀ (a b : ℝ), (a + b).cauchy = a.cauchy + b.cauchy","name":"Real.cauchy_add","isProp":true,"docString":"This theorem states that for any two real numbers 'a' and 'b', the Cauchy sequence of the sum of 'a' and 'b' is equal to the sum of the Cauchy sequences of 'a' and 'b'. In other words, the operation of adding two real numbers commutes with the operation of taking their Cauchy sequences.","distance":0.77714936056556005450346447105403058230876922607421875}],["`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ",{"type":"Lean.TrailingParserDescr","name":"«term_+_»","isProp":false,"docString":"`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ","distance":0.75067045067913384936986176398932002484798431396484375}],[" If `a` equals the sum of `b` and `c` (`a = b + c`), then `c` equals the difference between `a` and `b` (`c = a - b`).",{"type":"∀ {a b c : ℕ}, a = c + b → a - b = c","name":"Nat.sub_eq_of_eq_add","isProp":true,"docString":" If `a` equals the sum of `b` and `c` (`a = b + c`), then `c` equals the difference between `a` and `b` (`c = a - b`).","distance":0.69544374264839647903357899849652312695980072021484375}],["This theorem states that for any three natural numbers a, b, and c, the sum of the modulus of the sum of a and b by c and an additional term - which is c if c is less than or equal to the modulus of the sum of a and b, or 0 otherwise - is equal to the sum of the modulus of a and c and the modulus of b and c. In mathematical terms, this can be written as: `((a + b) mod c) + (c if c ≤ (a mod c + b mod c) else 0) = (a mod c + b mod c)`.",{"type":"∀ (a b c : ℕ), ((a + b) % c + if c ≤ a % c + b % c then c else 0) = a % c + b % c","name":"Nat.add_mod_add_ite","isProp":true,"docString":"This theorem states that for any three natural numbers a, b, and c, the sum of the modulus of the sum of a and b by c and an additional term - which is c if c is less than or equal to the modulus of the sum of a and b, or 0 otherwise - is equal to the sum of the modulus of a and c and the modulus of b and c. In mathematical terms, this can be written as: `((a + b) mod c) + (c if c ≤ (a mod c + b mod c) else 0) = (a mod c + b mod c)`.","distance":0.8103775383740299265156181718339212238788604736328125}],["`a +ᵥ b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ",{"type":"{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HVAdd α β γ] → α → β → γ","name":"HVAdd.hVAdd","isProp":false,"docString":"`a +ᵥ b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. ","distance":0.76681166312932280693104303281870670616626739501953125}],["`a +ᵥ b` computes the sum of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions. ",{"type":"{G : Type u} → {P : Type v} → [self : VAdd G P] → G → P → P","name":"VAdd.vadd","isProp":false,"docString":"`a +ᵥ b` computes the sum of `a` and `b`. The meaning of this notation is type-dependent,\nbut it is intended to be used for left actions. ","distance":0.8019362449635683010029651995864696800708770751953125}],["`a + b` computes the sum of `a` and `b`. See `HAdd`. ",{"type":"{α : Type u} → [self : Add α] → α → α → α","name":"Add.add","isProp":false,"docString":"`a + b` computes the sum of `a` and `b`. See `HAdd`. ","distance":0.80309169866025398309972160859615541994571685791015625}],["The sum of `f i` over `i ∈ {a, b}`, `a ≠ b`, is equal to `f a + f b`.",{"type":"∀ {α : Type u_1} {M : Type u_5} [inst : AddCommMonoid M] {f : α → M} {a b : α},\n  a ≠ b → ∑ᶠ (i : α) (_ : i ∈ {a, b}), f i = f a + f b","name":"finsum_mem_pair","isProp":true,"docString":"The sum of `f i` over `i ∈ {a, b}`, `a ≠ b`, is equal to `f a + f b`.","distance":0.80601656302064139669738551674527116119861602783203125}],["`Comp.add c1 c2` adds the expressions represented by `c1` and `c2`.\nThe coefficient of variable `a` in `c1.add c2`\nis the sum of the coefficients of `a` in `c1` and `c2`.\n ",{"type":"Linarith.Comp → Linarith.Comp → Linarith.Comp","name":"Linarith.Comp.add","isProp":false,"docString":"`Comp.add c1 c2` adds the expressions represented by `c1` and `c2`.\nThe coefficient of variable `a` in `c1.add c2`\nis the sum of the coefficients of `a` in `c1` and `c2`.\n ","distance":0.81192596696096297481659576078527607023715972900390625}],["Two elements `a` and `b` are add-regular if and only if both sums `a + b` and\n`b + a` are add-regular.",{"type":"∀ {R : Type u_1} [inst : AddSemigroup R] {a b : R},\n  IsAddRegular (a + b) ∧ IsAddRegular (b + a) ↔ IsAddRegular a ∧ IsAddRegular b","name":"isAddRegular_add_and_add_iff","isProp":true,"docString":"Two elements `a` and `b` are add-regular if and only if both sums `a + b` and\n`b + a` are add-regular.","distance":0.83531728990634823706074030269519425928592681884765625}],["Two elements additively commute if `a + b = b + a`",{"type":"{S : Type u_3} → [inst : Add S] → S → S → Prop","name":"AddCommute","isProp":false,"docString":"Two elements additively commute if `a + b = b + a`","distance":0.8416275580676455536632829534937627613544464111328125}],["For `a ≤ b`, there is a `c` so `b = a + c`. ",{"type":"∀ {α : Type u} {inst : Add α} {inst_1 : LE α} [self : ExistsAddOfLE α] {a b : α}, a ≤ b → ∃ c, b = a + c","name":"ExistsAddOfLE.exists_add_of_le","isProp":true,"docString":"For `a ≤ b`, there is a `c` so `b = a + c`. ","distance":0.84715365628103034278950644875294528901576995849609375}],["If both `a` and `b` commute with `c`, then their product commutes with `c`. ",{"type":"∀ {S : Type u_3} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c","name":"Commute.mul_left","isProp":true,"docString":"If both `a` and `b` commute with `c`, then their product commutes with `c`. ","distance":0.85221208606975118460269413844798691570758819580078125}],["If both `a` and `b` commute with `c`, then their product commutes with `c`.",{"type":"∀ {S : Type u_3} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c","name":"AddCommute.add_left","isProp":true,"docString":"If both `a` and `b` commute with `c`, then their product commutes with `c`.","distance":0.85422677029470450715820106779574416577816009521484375}],["If `c1` and `c2` both contain variable `a` with opposite coefficients,\nproduces `v1` and `v2` such that `a` has been cancelled in `v1*c1 + v2*c2`. ",{"type":"Linarith.Comp → Linarith.Comp → ℕ → Option (ℕ × ℕ)","name":"Linarith.elimVar","isProp":false,"docString":"If `c1` and `c2` both contain variable `a` with opposite coefficients,\nproduces `v1` and `v2` such that `a` has been cancelled in `v1*c1 + v2*c2`. ","distance":0.85663053256934496015873037322307936847209930419921875}],["If `a` commutes with both `b` and `c`, then it commutes with their product. ",{"type":"∀ {S : Type u_3} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)","name":"Commute.mul_right","isProp":true,"docString":"If `a` commutes with both `b` and `c`, then it commutes with their product. ","distance":0.86905449360216568965853412009892053902149200439453125}],["Notation for `CovBy a b`. ",{"type":"Lean.TrailingParserDescr","name":"«term_⋖_»","isProp":false,"docString":"Notation for `CovBy a b`. ","distance":0.87480975450633480239304162751068361103534698486328125}],["For `a ≤ b`, there is a `c` so `b = a * c`. ",{"type":"∀ {α : Type u_1} [self : CanonicallyOrderedCommMonoid α] {a b : α}, a ≤ b → ∃ c, b = a * c","name":"CanonicallyOrderedCommMonoid.exists_mul_of_le","isProp":true,"docString":"For `a ≤ b`, there is a `c` so `b = a * c`. ","distance":0.88076199101202712338221090249135158956050872802734375}],["For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` ",{"type":"∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c","name":"IsDirected.directed","isProp":true,"docString":"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` ","distance":0.88374423666264767529554546854342333972454071044921875}],["Two elements commute if `a * b = b * a`. ",{"type":"{S : Type u_3} → [inst : Mul S] → S → S → Prop","name":"Commute","isProp":false,"docString":"Two elements commute if `a * b = b * a`. ","distance":0.88774012176216865466216177082969807088375091552734375}],["`a - b` provides a lower bound on `c` such that `a ≤ c + b`. ",{"type":"∀ {α : Type u_2} {inst : LE α} {inst_1 : Add α} {inst_2 : Sub α} [self : OrderedSub α] (a b c : α),\n  a - b ≤ c ↔ a ≤ c + b","name":"OrderedSub.tsub_le_iff_right","isProp":true,"docString":"`a - b` provides a lower bound on `c` such that `a ≤ c + b`. ","distance":0.89371342684280830059861955305677838623523712158203125}],["We say that `a` is conjugate to `b` if for some unit `c` we have `c * a * c⁻¹ = b`. ",{"type":"{α : Type u} → [inst : Monoid α] → α → α → Prop","name":"IsConj","isProp":false,"docString":"We say that `a` is conjugate to `b` if for some unit `c` we have `c * a * c⁻¹ = b`. ","distance":0.89657535927852494150869233635603450238704681396484375}]]