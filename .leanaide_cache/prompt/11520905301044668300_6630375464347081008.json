[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9696489954408507028205121969222091138362884521484375}],[" For any nontrivially normed field `𝕜`, normed additive commutative group `E`, normed space `E` over `𝕜`, and topological space `H`, the function `I` from `𝕜` to `E` defined in a Model With Corners `I` of types `𝕜`, `E`, and `H` is uniquely differentiable on its entire range.",{"type":"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners 𝕜 E H),\n  UniqueDiffOn 𝕜 (Set.range ↑I)","name":"ModelWithCorners.unique_diff","isProp":true,"docString":" For any nontrivially normed field `𝕜`, normed additive commutative group `E`, normed space `E` over `𝕜`, and topological space `H`, the function `I` from `𝕜` to `E` defined in a Model With Corners `I` of types `𝕜`, `E`, and `H` is uniquely differentiable on its entire range.","distance":2.01765121082433029897629239712841808795928955078125}],["This theorem, `hammingDist_pos`, states that for any types `ι` and `β`, where `β` is a function from `ι` to another type and `ι` is a fintype, i.e., a finite type, and we have decidable equality for all `i : ι` over `β i`, then the Hamming distance between two functions `x` and `y` (from `ι` to `β`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)] {x y : (i : ι) → β i},\n  0 < hammingDist x y ↔ x ≠ y","name":"hammingDist_pos","isProp":true,"docString":"This theorem, `hammingDist_pos`, states that for any types `ι` and `β`, where `β` is a function from `ι` to another type and `ι` is a fintype, i.e., a finite type, and we have decidable equality for all `i : ι` over `β i`, then the Hamming distance between two functions `x` and `y` (from `ι` to `β`) is greater than zero if and only if `x` is not equal to `y`. In other words, the Hamming distance measures how different the two functions are, with a zero distance implying that the functions are the same.","distance":2.011905904885824991623621826875023543834686279296875}],["The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ⊥`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":1.9871219298994240443079206670518033206462860107421875}],[" For any inner product space `(E, ⟨·, ·⟩)` over commutative scalar type `𝕜`, ⟨0, x⟩ = 0 for all `x ∈ E`.",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x : E), ⟪0, x⟫_𝕜 = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, ⟨·, ·⟩)` over commutative scalar type `𝕜`, ⟨0, x⟩ = 0 for all `x ∈ E`.","distance":2.020823277088770186793453831342048943042755126953125}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":2.012335745210701798413310825708322227001190185546875}],["Default definition of `min`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.99871170091551153547015928779728710651397705078125}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadEnv m] → [inst : Lean.MonadError m] → Lean.Name → m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":2.003694208288225642178304042317904531955718994140625}],["**First moment method**. The minimum of a measurable function is smaller than its integral,\nwhile avoiding a null set. ",{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {N : Set α} {f : α → ENNReal}\n  [inst : MeasureTheory.IsProbabilityMeasure μ], AEMeasurable f → ↑↑μ N = 0 → ∃ x ∉ N, f x ≤ ∫⁻ (a : α), f a ∂μ","name":"MeasureTheory.exists_not_mem_null_le_lintegral","isProp":true,"docString":"**First moment method**. The minimum of a measurable function is smaller than its integral,\nwhile avoiding a null set. ","distance":2.005793447034877718948564506717957556247711181640625}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : TypeVec.Arrow Fin2.elim0 Fin2.elim0 → Sort u_1} →\n  β TypeVec.nilFun → (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) → β f","name":"TypeVec.typevecCasesNil₂","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":2.006922688020391642993445202591829001903533935546875}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":2.006924784492385871459418922313489019870758056640625}],["A solution is `1` or `-1` if and only if `y = 0`. ",{"type":"∀ {d : ℤ} {a : Pell.Solution₁ d}, a = 1 ∨ a = -1 ↔ Pell.Solution₁.y a = 0","name":"Pell.Solution₁.eq_one_or_neg_one_iff_y_eq_zero","isProp":true,"docString":"A solution is `1` or `-1` if and only if `y = 0`. ","distance":2.007515665087342693340133337187580764293670654296875}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":2.008529845998929364014884413336403667926788330078125}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {f : E → β} {x y z : E}, ConcaveOn 𝕜 (segment 𝕜 x y) f → z ∈ segment 𝕜 x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.00882051933557104206329313456080853939056396484375}],["Default definition of `max`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":2.00956689862469062290983856655657291412353515625}],["**First moment method**. The minimum of a measurable function is smaller than its integral. ",{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ENNReal}\n  [inst : MeasureTheory.IsProbabilityMeasure μ], AEMeasurable f → ∃ x, f x ≤ ∫⁻ (a : α), f a ∂μ","name":"MeasureTheory.exists_le_lintegral","isProp":true,"docString":"**First moment method**. The minimum of a measurable function is smaller than its integral. ","distance":2.0099785318477625395416907849721610546112060546875}],["If a functor preserves a certain right homology data of a short complex `S`, then it\npreserves the right homology of `S`. ",{"type":"{C : Type u_1} →\n  {D : Type u_2} →\n    [inst : CategoryTheory.Category.{u_3, u_1} C] →\n      [inst_1 : CategoryTheory.Category.{u_4, u_2} D] →\n        [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] →\n          [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] →\n            (F : CategoryTheory.Functor C D) →\n              [inst_4 : CategoryTheory.Functor.PreservesZeroMorphisms F] →\n                {S : CategoryTheory.ShortComplex C} →\n                  (h : CategoryTheory.ShortComplex.RightHomologyData S) →\n                    [inst_5 : CategoryTheory.ShortComplex.RightHomologyData.IsPreservedBy h F] →\n                      CategoryTheory.Functor.PreservesRightHomologyOf F S","name":"CategoryTheory.Functor.PreservesRightHomologyOf.mk'","isProp":false,"docString":"If a functor preserves a certain right homology data of a short complex `S`, then it\npreserves the right homology of `S`. ","distance":2.009985809585822291722934096469543874263763427734375}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"∀ {𝕜 : Type u_1} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module 𝕜 β] [inst_3 : OrderedSMul 𝕜 β] {f : 𝕜 → β} {x y z : 𝕜},\n  ConcaveOn 𝕜 (Set.Icc x y) f → z ∈ Set.Icc x y → min (f x) (f y) ≤ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":2.01008578179678210062775178812444210052490234375}],["Corresponds to `dist_pos`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)] {x y : (i : ι) → β i},\n  0 < hammingDist x y ↔ x ≠ y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":2.01010755952974928817411637282930314540863037109375}],["cases distinction for 0-length type vector ",{"type":"{β : TypeVec.{u_2} 0 → Sort u_1} → β Fin2.elim0 → (v : TypeVec.{u_2} 0) → β v","name":"TypeVec.casesNil","isProp":false,"docString":"cases distinction for 0-length type vector ","distance":2.0103100267040385773498201160691678524017333984375}],["**First moment method**. The minimum of an integrable function is smaller than its integral,\nwhile avoiding a null set. ",{"type":"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {N : Set α} {f : α → ℝ}\n  [inst : MeasureTheory.IsProbabilityMeasure μ],\n  MeasureTheory.Integrable f → ↑↑μ N = 0 → ∃ x ∉ N, f x ≤ ∫ (a : α), f a ∂μ","name":"MeasureTheory.exists_not_mem_null_le_integral","isProp":true,"docString":"**First moment method**. The minimum of an integrable function is smaller than its integral,\nwhile avoiding a null set. ","distance":2.01066523189164403362383382045663893222808837890625}],["cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{β : (v : TypeVec.{u_2} 0) → (v' : TypeVec.{u_3} 0) → TypeVec.Arrow v v' → Sort u_1} →\n  β Fin2.elim0 Fin2.elim0 TypeVec.nilFun →\n    (v : TypeVec.{u_2} 0) → (v' : TypeVec.{u_3} 0) → (fs : TypeVec.Arrow v v') → β v v' fs","name":"TypeVec.typevecCasesNil₃","isProp":false,"docString":"cases distinction for an arrow in the category of 0-length type vectors ","distance":2.010805639159177982122628236538730561733245849609375}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {K : Set F},\n  Convex ℝ K → ∀ {u v : F}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":2.011178128494141237325720794615335762500762939453125}],["Reinterpret a real number `r` as a non-negative real number. Returns `0` if `r < 0`. ",{"type":"ℝ → NNReal","name":"Real.toNNReal","isProp":false,"docString":"Reinterpret a real number `r` as a non-negative real number. Returns `0` if `r < 0`. ","distance":2.011445000767810853403716464526951313018798828125}]]