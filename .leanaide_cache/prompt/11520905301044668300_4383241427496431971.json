[["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {K : Set F},\n  Convex ‚Ñù K ‚Üí ‚àÄ {u v : F}, v ‚àà K ‚Üí (‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.925208913371490471178049119771458208560943603515625}],[" For any inner product space `(E, ‚ü®¬∑, ¬∑‚ü©)` over commutative scalar type `ùïú`, ‚ü®0, x‚ü© = 0 for all `x ‚àà E`.",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : RCLike ùïú] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ùïú E]\n  (x : E), ‚ü™0, x‚ü´_ùïú = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, ‚ü®¬∑, ¬∑‚ü©)` over commutative scalar type `ùïú`, ‚ü®0, x‚ü© = 0 for all `x ‚àà E`.","distance":1.9635972558221601591554872356937266886234283447265625}],["The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.",{"type":"‚àÄ {K : Type u} [inst : Field K], RatFunc.num 0 = 0","name":"RatFunc.num_zero","isProp":true,"docString":"The theorem `RatFunc.num_zero` states that for any type `K` that is a field, the numerator of the zero rational function (which is represented as `RatFunc.num 0`) is zero. In other words, if you have a rational function which is zero, then its numerator is also zero. This is applicable in any field `K`.","distance":1.9614310827496890254906247719191014766693115234375}],["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.939611206528012221639301060349680483341217041015625}],[" For any topological space `Œ±` and pseudo metric space `Œ≤` with defined zero, the constant function `0 : Œ± ‚Üí Œ≤` equals the zero function.",{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] [inst_2 : Zero Œ≤], ‚áë0 = 0","name":"BoundedContinuousFunction.coe_zero","isProp":true,"docString":" For any topological space `Œ±` and pseudo metric space `Œ≤` with defined zero, the constant function `0 : Œ± ‚Üí Œ≤` equals the zero function.","distance":1.967349869813009632935063564218580722808837890625}],["The theorem `innerDualCone_zero` states that for any type `H` that is a normed add commutative group and has an inner product space over the real numbers, the dual cone of the convex cone consisting only of the zero vector is the whole space `H`. In other words, any point `y` in space `H` satisfies the condition that the inner product of `y` and `0` is nonnegative, hence all points `y` in `H` belong to the dual cone of the zero vector.",{"type":"‚àÄ {H : Type u_5} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace ‚Ñù H], Set.innerDualCone 0 = ‚ä§","name":"innerDualCone_zero","isProp":true,"docString":"The theorem `innerDualCone_zero` states that for any type `H` that is a normed add commutative group and has an inner product space over the real numbers, the dual cone of the convex cone consisting only of the zero vector is the whole space `H`. In other words, any point `y` in space `H` satisfies the condition that the inner product of `y` and `0` is nonnegative, hence all points `y` in `H` belong to the dual cone of the zero vector.","distance":1.9672748104928998724716393553535453975200653076171875}],["Default definition of `min`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9472095846074368719058611532091163098812103271484375}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{M‚ÇÅ : Type u_1} ‚Üí\n  {M‚ÇÇ : Type u_2} ‚Üí\n    [inst : Zero M‚ÇÅ] ‚Üí\n      [inst_1 : Neg M‚ÇÅ] ‚Üí\n        [inst_2 : NegZeroClass M‚ÇÇ] ‚Üí\n          (f : M‚ÇÅ ‚Üí M‚ÇÇ) ‚Üí Function.Injective f ‚Üí f 0 = 0 ‚Üí (‚àÄ (x : M‚ÇÅ), f (-x) = -f x) ‚Üí NegZeroClass M‚ÇÅ","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":1.947214743574436912609826322295702993869781494140625}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData ‚Üí String ‚Üí Lean.Name ‚Üí Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.94810106029830709672978628077544271945953369140625}],["Builds a `Primcodable` instance from an equivalence to a `Primcodable` type. ",{"type":"(Œ± : Type u_1) ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : Primcodable Œ±] ‚Üí Œ≤ ‚âÉ Œ± ‚Üí Primcodable Œ≤","name":"Primcodable.ofEquiv","isProp":false,"docString":"Builds a `Primcodable` instance from an equivalence to a `Primcodable` type. ","distance":1.9482577098374347368547887526801787316799163818359375}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type ‚Üí Type} ‚Üí [inst : Monad m] ‚Üí [inst : Lean.MonadEnv m] ‚Üí [inst : Lean.MonadError m] ‚Üí Lean.Name ‚Üí m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9494088925705297388191183927119709551334381103515625}],["Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ",{"type":"Lean.Name ‚Üí Simps.ParsedProjectionData ‚Üí List Lean.Level ‚Üí Lean.CoreM Simps.ParsedProjectionData","name":"Simps.findProjection","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nGenerates the default projection, and looks for a custom projection declared by the user,\nand replaces the default projection with the custom one, if it can find it. ","distance":1.9495239521303135976637577186920680105686187744140625}],["Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : ‚Ñï ‚Üí Type u_2} ‚Üí ((n : ‚Ñï) ‚Üí E n) ‚Üí Set ((n : ‚Ñï) ‚Üí E n) ‚Üí ‚Ñï","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Œ† (n : ‚Ñï), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":1.9502270340827931871530154239735566079616546630859375}],["Find arguments for the `Zero` class. ",{"type":"Simps.findArgType","name":"Simps.findZeroArgs","isProp":false,"docString":"Find arguments for the `Zero` class. ","distance":1.950365966426189867632956520537845790386199951171875}],["With the optimal candidate, construct a premetric space structure on `X ‚äï Y`, on which the\npredistance is given by the candidate. Then, we will identify points at `0` predistance\nto obtain a genuine metric space. ",{"type":"(X : Type u) ‚Üí\n  (Y : Type v) ‚Üí\n    [inst : MetricSpace X] ‚Üí\n      [inst : CompactSpace X] ‚Üí\n        [inst : Nonempty X] ‚Üí\n          [inst : MetricSpace Y] ‚Üí [inst : CompactSpace Y] ‚Üí [inst : Nonempty Y] ‚Üí PseudoMetricSpace (X ‚äï Y)","name":"GromovHausdorff.premetricOptimalGHDist","isProp":false,"docString":"With the optimal candidate, construct a premetric space structure on `X ‚äï Y`, on which the\npredistance is given by the candidate. Then, we will identify points at `0` predistance\nto obtain a genuine metric space. ","distance":1.9506134514948174629722643658169545233249664306640625}],["Corresponds to `zero_eq_dist`. ",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 = hammingDist x y ‚Üî x = y","name":"hamming_zero_eq_dist","isProp":true,"docString":"Corresponds to `zero_eq_dist`. ","distance":1.9512395853328985406704987326520495116710662841796875}],["Tests whether `declName` has the `@[simp]` attribute in `env`. ",{"type":"Lean.Environment ‚Üí Lean.Name ‚Üí Bool","name":"hasSimpAttribute","isProp":false,"docString":"Tests whether `declName` has the `@[simp]` attribute in `env`. ","distance":1.9566759621201501584408788403379730880260467529296875}],["The `@[notation_class]` attribute specifies that this is a notation class,\nand this notation should be used instead of projections by `@[simps]`.\n* This is only important if the projection is written differently using notation, e.g.\n  `+` uses `HAdd.hAdd`, not `Add.add` and `0` uses `OfNat.ofNat` not `Zero.zero`.\n  We also add it to non-heterogenous notation classes, like `Neg`, but it doesn't do much for any\n  class that extends `Neg`.\n* `@[notation_class * <projName> Simps.findCoercionArgs]` is used to configure the\n  `SetLike` and `DFunLike` coercions.\n* The first name argument is the projection name we use as the key to search for this class\n  (default: name of first projection of the class).\n* The second argument is the name of a declaration that has type\n  `findArgType` which is defined to be `Name ‚Üí Name ‚Üí Array Expr ‚Üí MetaM (Array (Option Expr))`.\n  This declaration specifies how to generate the arguments of the notation class from the\n  arguments of classes that use the projection. ",{"type":"Lean.ParserDescr","name":"notation_class","isProp":false,"docString":"The `@[notation_class]` attribute specifies that this is a notation class,\nand this notation should be used instead of projections by `@[simps]`.\n* This is only important if the projection is written differently using notation, e.g.\n  `+` uses `HAdd.hAdd`, not `Add.add` and `0` uses `OfNat.ofNat` not `Zero.zero`.\n  We also add it to non-heterogenous notation classes, like `Neg`, but it doesn't do much for any\n  class that extends `Neg`.\n* `@[notation_class * <projName> Simps.findCoercionArgs]` is used to configure the\n  `SetLike` and `DFunLike` coercions.\n* The first name argument is the projection name we use as the key to search for this class\n  (default: name of first projection of the class).\n* The second argument is the name of a declaration that has type\n  `findArgType` which is defined to be `Name ‚Üí Name ‚Üí Array Expr ‚Üí MetaM (Array (Option Expr))`.\n  This declaration specifies how to generate the arguments of the notation class from the\n  arguments of classes that use the projection. ","distance":1.957135889235702475019706980674527585506439208984375}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Œ± ‚Üí ‚àÄ {f : Œ± ‚Üí Y}, Continuous f ‚Üí ‚àÄ {x y : Œ±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":1.957208976070144768044656302663497626781463623046875}],["Name to use for the declaration for a type that is `Equiv` to the given type. ",{"type":"Mathlib.ProxyType.ProxyEquivConfig ‚Üí Lean.Name","name":"Mathlib.ProxyType.ProxyEquivConfig.proxyName","isProp":false,"docString":"Name to use for the declaration for a type that is `Equiv` to the given type. ","distance":1.957363638213367895701821908005513250827789306640625}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9580695305119473204058522242121398448944091796875}],["Corresponds to `dist_pos`. ",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 < hammingDist x y ‚Üî x ‚â† y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.9585017616916309268759732731268741190433502197265625}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Œ≤ : TypeVec.Arrow Fin2.elim0 Fin2.elim0 ‚Üí Sort u_1} ‚Üí\n  Œ≤ TypeVec.nilFun ‚Üí (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) ‚Üí Œ≤ f","name":"TypeVec.typevecCasesNil‚ÇÇ","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9586499740754212961491020905668847262859344482421875}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name ‚Üí Array Simps.ParsedProjectionData ‚Üí Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.9591110402038030002813684404827654361724853515625}]]