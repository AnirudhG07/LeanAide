[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.938935600011093551842122906236909329891204833984375}],[" For an additive group `G` and its subgroup `H`, `coerce H to set = {-} : set G <=> H = G`.",{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G}, ‚ÜëH = Set.univ ‚Üî H = ‚ä§","name":"AddSubgroup.coe_eq_univ","isProp":true,"docString":" For an additive group `G` and its subgroup `H`, `coerce H to set = {-} : set G <=> H = G`.","distance":1.9873657732129910158391794539056718349456787109375}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":1.98261782634713856765529271797277033329010009765625}],["Default definition of `min`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9699095467318661345501595860696397721767425537109375}],[" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ùïú`, a normed additive group `E` over `ùïú` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ‚Ü¶ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.",{"type":"‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}\n  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ùïú E] {I : ModelWithCorners ùïú E H} {G : Type u_4}\n  [inst_4 : Inv G] [inst_5 : Zero G] [inst_6 : TopologicalSpace G] [inst_7 : ChartedSpace H G] [self : SmoothInv‚ÇÄ I G]\n  ‚¶Éx : G‚¶Ñ, x ‚â† 0 ‚Üí SmoothAt I I (fun y => y‚Åª¬π) x","name":"SmoothInv‚ÇÄ.smoothAt_inv‚ÇÄ","isProp":true,"docString":" Given a non-zero point `x` in a topological space `G` with inversion, a nontrivially normed field `ùïú`, a normed additive group `E` over `ùïú` as a normed space, another topological space `H`, and a model `I` with corners, the function `y ‚Ü¶ 1/y` is smooth at `x` in the function space from `E` to `E` and from `H` to `H`.","distance":1.99181228071865579209998031728900969028472900390625}],["This theorem, named `sign_pos`, states that for any type `Œ±` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `Œ±` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.",{"type":"‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : Preorder Œ±] [inst_2 : DecidableRel fun x x_1 => x < x_1] {a : Œ±},\n  0 < a ‚Üí SignType.sign a = 1","name":"sign_pos","isProp":true,"docString":"This theorem, named `sign_pos`, states that for any type `Œ±` that has a zero, a preorder (a binary relation that is reflexive and transitive), and a decidable relation for less than, if a certain element `a` of type `Œ±` is greater than zero, then the sign of `a` is 1. The sign is determined by the `SignType.sign` function, which assigns 1 if the element is positive, -1 if it is negative, and 0 otherwise.","distance":1.9854567546039854075701214242144487798213958740234375}],["Builds a `Primcodable` instance from an equivalence to a `Primcodable` type. ",{"type":"(Œ± : Type u_1) ‚Üí {Œ≤ : Type u_2} ‚Üí [inst : Primcodable Œ±] ‚Üí Œ≤ ‚âÉ Œ± ‚Üí Primcodable Œ≤","name":"Primcodable.ofEquiv","isProp":false,"docString":"Builds a `Primcodable` instance from an equivalence to a `Primcodable` type. ","distance":1.9706262198721546941015958509524352848529815673828125}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type ‚Üí Type} ‚Üí [inst : Monad m] ‚Üí [inst : Lean.MonadEnv m] ‚Üí [inst : Lean.MonadError m] ‚Üí Lean.Name ‚Üí m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9712355477127496694578212554915808141231536865234375}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Œ± ‚Üí ‚àÄ {f : Œ± ‚Üí Y}, Continuous f ‚Üí ‚àÄ {x y : Œ±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":1.9726935537771925766037384164519608020782470703125}],["Canonical prefunctor from `B` to `free_bicategory B`. ",{"type":"{B : Type u} ‚Üí [inst : Quiver B] ‚Üí B ‚•§q CategoryTheory.FreeBicategory B","name":"CategoryTheory.FreeBicategory.of","isProp":false,"docString":"Canonical prefunctor from `B` to `free_bicategory B`. ","distance":1.9757031495229717688033588274265639483928680419921875}],["cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Œ≤ : (v : TypeVec.{u_2} 0) ‚Üí (v' : TypeVec.{u_3} 0) ‚Üí TypeVec.Arrow v v' ‚Üí Sort u_1} ‚Üí\n  Œ≤ Fin2.elim0 Fin2.elim0 TypeVec.nilFun ‚Üí\n    (v : TypeVec.{u_2} 0) ‚Üí (v' : TypeVec.{u_3} 0) ‚Üí (fs : TypeVec.Arrow v v') ‚Üí Œ≤ v v' fs","name":"TypeVec.typevecCasesNil‚ÇÉ","isProp":false,"docString":"cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9763149549543796990036526040057651698589324951171875}],["The set of functions on `X ‚äï Y` that are candidates distances to realize the\nminimum of the Hausdorff distances between `X` and `Y` in a coupling. ",{"type":"(X : Type u) ‚Üí (Y : Type v) ‚Üí [inst : MetricSpace X] ‚Üí [inst : MetricSpace Y] ‚Üí Set (GromovHausdorff.ProdSpaceFun X Y)","name":"GromovHausdorff.candidates","isProp":false,"docString":"The set of functions on `X ‚äï Y` that are candidates distances to realize the\nminimum of the Hausdorff distances between `X` and `Y` in a coupling. ","distance":1.976347604787139999871214968152344226837158203125}],["Parse a rule for `initialize_simps_projections`. It is `<name>‚Üí<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.",{"type":"Lean.Syntax ‚Üí Lean.Elab.Command.CommandElabM Simps.ProjectionRule","name":"Simps.elabSimpsRule","isProp":false,"docString":"Parse a rule for `initialize_simps_projections`. It is `<name>‚Üí<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.","distance":1.977040434496860399349316139705479145050048828125}],["Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n",{"type":"(C : Type u) ‚Üí [inst : CategoryTheory.Category.{v, u} C] ‚Üí [inst : CategoryTheory.Limits.HasZeroObject C] ‚Üí Zero C","name":"CategoryTheory.Limits.HasZeroObject.zero'","isProp":false,"docString":"Construct a `Zero C` for a category with a zero object.\nThis can not be a global instance as it will trigger for every `Zero C` typeclass search.\n","distance":1.9773076654046943811948722213855944573879241943359375}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {K : Set F},\n  Convex ‚Ñù K ‚Üí ‚àÄ {u v : F}, v ‚àà K ‚Üí (‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.978034988499819402107959831482730805873870849609375}],["specialized cases distinction for an arrow in the category of 0-length type vectors ",{"type":"{Œ≤ : TypeVec.Arrow Fin2.elim0 Fin2.elim0 ‚Üí Sort u_1} ‚Üí\n  Œ≤ TypeVec.nilFun ‚Üí (f : TypeVec.Arrow Fin2.elim0 Fin2.elim0) ‚Üí Œ≤ f","name":"TypeVec.typevecCasesNil‚ÇÇ","isProp":false,"docString":"specialized cases distinction for an arrow in the category of 0-length type vectors ","distance":1.9784617536192252718052486670785583555698394775390625}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData ‚Üí String ‚Üí Lean.Name ‚Üí Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9788029287149291324254818391636945307254791259765625}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{M‚ÇÅ : Type u_1} ‚Üí\n  {M‚ÇÇ : Type u_2} ‚Üí\n    [inst : Zero M‚ÇÅ] ‚Üí\n      [inst_1 : Neg M‚ÇÅ] ‚Üí\n        [inst_2 : NegZeroClass M‚ÇÇ] ‚Üí\n          (f : M‚ÇÅ ‚Üí M‚ÇÇ) ‚Üí Function.Injective f ‚Üí f 0 = 0 ‚Üí (‚àÄ (x : M‚ÇÅ), f (-x) = -f x) ‚Üí NegZeroClass M‚ÇÅ","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":1.979639674142812832968729708227328956127166748046875}],["The initial object in the category of elements for a representable functor. In `isInitial` it is\nshown that this is initial.\n",{"type":"{C : Type u‚ÇÅ} ‚Üí\n  [inst : CategoryTheory.SmallCategory C] ‚Üí (A : C) ‚Üí CategoryTheory.Functor.Elements (CategoryTheory.yoneda.obj A)","name":"CategoryTheory.ColimitAdj.Elements.initial","isProp":false,"docString":"The initial object in the category of elements for a representable functor. In `isInitial` it is\nshown that this is initial.\n","distance":1.9799133964796868934143958540516905486583709716796875}],["Help the typechecker by converting a path in a topological space to an arrow in the\nfundamental groupoid of that space. ",{"type":"{X : TopCat} ‚Üí {x‚ÇÄ x‚ÇÅ : ‚ÜëX} ‚Üí Path.Homotopic.Quotient x‚ÇÄ x‚ÇÅ ‚Üí ({ as := x‚ÇÄ } ‚ü∂ { as := x‚ÇÅ })","name":"FundamentalGroupoid.fromPath","isProp":false,"docString":"Help the typechecker by converting a path in a topological space to an arrow in the\nfundamental groupoid of that space. ","distance":1.980487087731447548577534689684398472309112548828125}],["Attribute for identifying `positivity` extensions. ",{"type":"Lean.ParserDescr","name":"positivity","isProp":false,"docString":"Attribute for identifying `positivity` extensions. ","distance":1.9814596734947536038617954545770771801471710205078125}],["Corresponds to `zero_eq_dist`. ",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 = hammingDist x y ‚Üî x = y","name":"hamming_zero_eq_dist","isProp":true,"docString":"Corresponds to `zero_eq_dist`. ","distance":1.9828667952626475301514119564672000706195831298828125}],["Function elaborating `initialize_simps_projections`. ",{"type":"Lean.Elab.Command.CommandElab","name":"Simps.elabInitializeSimpsProjections","isProp":false,"docString":"Function elaborating `initialize_simps_projections`. ","distance":1.983623771220326847952719617751426994800567626953125}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {f : E ‚Üí Œ≤} {x y z : E}, ConcaveOn ùïú (segment ùïú x y) f ‚Üí z ‚àà segment ùïú x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.983700021507394328779128045425750315189361572265625}]]