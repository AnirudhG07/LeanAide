[["an arrow ",{"type":"{V : Type u} → [inst : Quiver V] → (self : Quiver.Total V) → self.left ⟶ self.right","name":"Quiver.Total.hom","isProp":false,"docString":"an arrow ","distance":0.39055166234961091742405869808862917125225067138671875}],[" For any bornology on a type M, scalar multiplication on a type α, and sets s of α, i : ι, and I a finite set of i, s absorbs the union of the sets ti if and only if it absorbs each ti. (Here, absorption means that each ti is contained in all but a bounded set of scalings of s by elements from M.)",{"type":"∀ {M : Type u_1} {α : Type u_2} [inst : Bornology M] [inst_1 : SMul M α] {s : Set α} {ι : Type u_3} {t : ι → Set α}\n  {I : Finset ι}, Absorbs M s (⋃ i ∈ I, t i) ↔ ∀ i ∈ I, Absorbs M s (t i)","name":"absorbs_iUnion_finset","isProp":true,"docString":" For any bornology on a type M, scalar multiplication on a type α, and sets s of α, i : ι, and I a finite set of i, s absorbs the union of the sets ti if and only if it absorbs each ti. (Here, absorption means that each ti is contained in all but a bounded set of scalings of s by elements from M.)","distance":0.51918598874843790991207015395048074424266815185546875}],["This theorem states that, given any topological space X and two sets s and t of X, if s is a meagre set, then the intersection of s and t is also a meagre set. In other words, intersecting a meagre set with any other set results in a set that is also meagre.",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X] {s t : Set X}, IsMeagre s → IsMeagre (s ∩ t)","name":"IsMeagre.inter","isProp":true,"docString":"This theorem states that, given any topological space X and two sets s and t of X, if s is a meagre set, then the intersection of s and t is also a meagre set. In other words, intersecting a meagre set with any other set results in a set that is also meagre.","distance":0.4825455762748287469321439857594668865203857421875}],["carrier of the coalgebra ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    {F : CategoryTheory.Functor C C} → CategoryTheory.Endofunctor.Coalgebra F → C","name":"CategoryTheory.Endofunctor.Coalgebra.V","isProp":false,"docString":"carrier of the coalgebra ","distance":0.412163571797447947364645415291306562721729278564453125}],[" For any object X in a category C with a Grothendieck topology J, if S is a cover of X in J and self is a relation in S, then the second arrow of self is in the sieve generated by S.",{"type":"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : J.Cover X} (self : S.Relation), S.sieve.arrows self.f₂","name":"CategoryTheory.GrothendieckTopology.Cover.Relation.h₂","isProp":true,"docString":" For any object X in a category C with a Grothendieck topology J, if S is a cover of X in J and self is a relation in S, then the second arrow of self is in the sieve generated by S.","distance":0.522832452759726340474344397080130875110626220703125}],["This theorem states that in a given topological space `X`, if we have a sequence of sets `(s n)` such that every `s n` is a \"meagre\" set, then the countable union of all these sets is also a \"meagre\" set. In mathematical terms, a set is \"meagre\" if its complement is a residual (or comeagre) set.",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X] {s : ℕ → Set X}, (∀ (n : ℕ), IsMeagre (s n)) → IsMeagre (⋃ n, s n)","name":"isMeagre_iUnion","isProp":true,"docString":"This theorem states that in a given topological space `X`, if we have a sequence of sets `(s n)` such that every `s n` is a \"meagre\" set, then the countable union of all these sets is also a \"meagre\" set. In mathematical terms, a set is \"meagre\" if its complement is a residual (or comeagre) set.","distance":0.48543628929023707740952886524610221385955810546875}],["the first row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₁","isProp":false,"docString":"the first row ","distance":0.4146916665491697795431491613271646201610565185546875}],["a morphism between the first lines ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C} →\n        CategoryTheory.ShortComplex.SnakeInput.Hom S₁ S₂ → (S₁.L₁ ⟶ S₂.L₁)","name":"CategoryTheory.ShortComplex.SnakeInput.Hom.f₁","isProp":false,"docString":"a morphism between the first lines ","distance":0.417436780725604805741824065989931114017963409423828125}],["tensorator ",{"type":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\n    [inst_1 : CategoryTheory.MonoidalCategory C] →\n      {D : Type u₂} →\n        [inst_2 : CategoryTheory.Category.{v₂, u₂} D] →\n          [inst_3 : CategoryTheory.MonoidalCategory D] →\n            {F : C → D} →\n              [inst_4 : CategoryTheory.Functorial F] →\n                [self : CategoryTheory.LaxMonoidal F] →\n                  (X Y : C) →\n                    CategoryTheory.MonoidalCategory.tensorObj (F X) (F Y) ⟶\n                      F (CategoryTheory.MonoidalCategory.tensorObj X Y)","name":"CategoryTheory.LaxMonoidal.μ","isProp":false,"docString":"tensorator ","distance":0.41976558433882316112573107602656818926334381103515625}],["The counit of the coalgebra ",{"type":"{R : Type u} →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [inst_1 : AddCommMonoid A] → [inst_2 : Module R A] → [self : CoalgebraStruct R A] → A →ₗ[R] R","name":"CoalgebraStruct.counit","isProp":false,"docString":"The counit of the coalgebra ","distance":0.423302363375007761892021562744048424065113067626953125}],["The empty set is meagre. ",{"type":"∀ {X : Type u_5} [inst : TopologicalSpace X], IsMeagre ∅","name":"meagre_empty","isProp":true,"docString":"The empty set is meagre. ","distance":0.42411464297759493558004351143608801066875457763671875}],["There is a splitting ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting ","distance":0.424564389399291142179748703711084090173244476318359375}],["Negation of games. ",{"type":"SetTheory.Game → SetTheory.Game","name":"SetTheory.Game.neg","isProp":false,"docString":"Negation of games. ","distance":0.42477418953597123607579533199896104633808135986328125}],["a morphism between the second lines ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C} →\n        CategoryTheory.ShortComplex.SnakeInput.Hom S₁ S₂ → (S₁.L₂ ⟶ S₂.L₂)","name":"CategoryTheory.ShortComplex.SnakeInput.Hom.f₂","isProp":false,"docString":"a morphism between the second lines ","distance":0.42601097336447468766351676094927825033664703369140625}],["The empty word ",{"type":"{G : Type u_1} →\n  [inst : Group G] →\n    {A B : Subgroup G} → {d : HNNExtension.NormalWord.TransversalPair G A B} → HNNExtension.NormalWord d","name":"HNNExtension.NormalWord.empty","isProp":false,"docString":"The empty word ","distance":0.42848342695954511061273706218344159424304962158203125}],["a morphism between the third lines ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] →\n      {S₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C} →\n        CategoryTheory.ShortComplex.SnakeInput.Hom S₁ S₂ → (S₁.L₃ ⟶ S₂.L₃)","name":"CategoryTheory.ShortComplex.SnakeInput.Hom.f₃","isProp":false,"docString":"a morphism between the third lines ","distance":0.429601930889643879307726592742255888879299163818359375}],["the second morphism of a triangle ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.HasShift C ℤ] → (self : CategoryTheory.Pretriangulated.Triangle C) → self.obj₂ ⟶ self.obj₃","name":"CategoryTheory.Pretriangulated.Triangle.mor₂","isProp":false,"docString":"the second morphism of a triangle ","distance":0.43001877976084035282156037283129990100860595703125}],["The empty weak sequence ",{"type":"{α : Type u} → Stream'.WSeq α","name":"Stream'.WSeq.nil","isProp":false,"docString":"The empty weak sequence ","distance":0.430782694189293546838115389618906192481517791748046875}],["the corestriction map to the image ",{"type":"{G H : AddCommGroupCat} → (f : G ⟶ H) → G ⟶ AddCommGroupCat.image f","name":"AddCommGroupCat.factorThruImage","isProp":false,"docString":"the corestriction map to the image ","distance":0.43120119435151693654262317068059928715229034423828125}],["the second row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₂","isProp":false,"docString":"the second row ","distance":0.43155025724090811944932966071064583957195281982421875}],["the underlying map ",{"type":"{X Y : Pointed} → Pointed.Hom X Y → X.X → Y.X","name":"Pointed.Hom.toFun","isProp":false,"docString":"the underlying map ","distance":0.43158536708185957220251793842180632054805755615234375}],["The thin skeleton is thin. ",{"type":"∀ (C : Type u₁) [inst : CategoryTheory.Category.{v₁, u₁} C], Quiver.IsThin (CategoryTheory.ThinSkeleton C)","name":"CategoryTheory.ThinSkeleton.thin","isProp":true,"docString":"The thin skeleton is thin. ","distance":0.431773091874381786947623140804353170096874237060546875}],["the third row ",{"type":"{C : Type u_1} →\n  [inst : CategoryTheory.Category.{u_2, u_1} C] →\n    [inst_1 : CategoryTheory.Abelian C] → CategoryTheory.ShortComplex.SnakeInput C → CategoryTheory.ShortComplex C","name":"CategoryTheory.ShortComplex.SnakeInput.L₃","isProp":false,"docString":"the third row ","distance":0.432356570914678772776795767640578560531139373779296875}],["Continuity ",{"type":"∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {σ : outParam (R →+* S)} {M : outParam (Type u_4)} [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M]\n  {M₂ : outParam (Type u_5)} [inst_4 : TopologicalSpace M₂] [inst_5 : AddCommMonoid M₂] [inst_6 : Module R M]\n  [inst_7 : Module S M₂] [self : ContinuousSemilinearMapClass F σ M M₂] (f : F), Continuous ⇑f","name":"ContinuousSemilinearMapClass.map_continuous","isProp":true,"docString":"Continuity ","distance":0.4324157901405616399870268651284277439117431640625}]]