[["An iterated form of the Kruskal-Katona theorem. In particular, the minimum possible iterated\nshadow size is attained by initial segments. ",{"type":"∀ {n r k : ℕ} {\u0000\u0000 \u0000\u0000 : Finset (Finset (Fin n))},\n  Set.Sized r ↑\u0000\u0000 →\n    \u0000\u0000.card ≤ \u0000\u0000.card → Finset.Colex.IsInitSeg \u0000\u0000 r → (Finset.shadow^[k] \u0000\u0000).card ≤ (Finset.shadow^[k] \u0000\u0000).card","name":"Finset.iterated_kk","isProp":true,"docString":"An iterated form of the Kruskal-Katona theorem. In particular, the minimum possible iterated\nshadow size is attained by initial segments. ","distance":1.095474983359797871429464066750369966030120849609375}],[" In a finite, non-empty SimpleGraph where the degree of every vertex is less than or equal to a natural number 'k', the minimum degree of the graph is also less than or equal to 'k'.",{"type":"∀ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V] (k : ℕ),\n  (∀ (v : V), k ≤ G.degree v) → k ≤ G.minDegree","name":"SimpleGraph.le_minDegree_of_forall_le_degree","isProp":true,"docString":" In a finite, non-empty SimpleGraph where the degree of every vertex is less than or equal to a natural number 'k', the minimum degree of the graph is also less than or equal to 'k'.","distance":1.2640941116887740580665422385209240019321441650390625}],["This theorem states that in a non-empty graph, if a natural number 'k' is less than or equal to the degree of every vertex in the graph, then 'k' is also less than or equal to the minimum degree of the graph. Here, the graph is represented by a SimpleGraph structure 'G', and 'degree' and 'minDegree' are functions that calculate the degree of a single vertex and the minimum degree in the graph respectively. The theorem assumes that the graph is finite (Fintype V) and that the adjacency relation (G.Adj) is decidable, meaning that for any two vertices, it can be determined whether or not they are connected. The condition that the graph is nonempty is necessary because the minimum degree 'G.minDegree' is defined to be a natural number.",{"type":"∀ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V] (k : ℕ),\n  (∀ (v : V), k ≤ G.degree v) → k ≤ G.minDegree","name":"SimpleGraph.le_minDegree_of_forall_le_degree","isProp":true,"docString":"This theorem states that in a non-empty graph, if a natural number 'k' is less than or equal to the degree of every vertex in the graph, then 'k' is also less than or equal to the minimum degree of the graph. Here, the graph is represented by a SimpleGraph structure 'G', and 'degree' and 'minDegree' are functions that calculate the degree of a single vertex and the minimum degree in the graph respectively. The theorem assumes that the graph is finite (Fintype V) and that the adjacency relation (G.Adj) is decidable, meaning that for any two vertices, it can be determined whether or not they are connected. The condition that the graph is nonempty is necessary because the minimum degree 'G.minDegree' is defined to be a natural number.","distance":1.210133853202880249710915450123138725757598876953125}],["The **Kruskal-Katona theorem**.\n\nGiven a set family `\u0000\u0000` consisting of `r`-sets, and `\u0000\u0000` an initial segment of the colex order of the\nsame size, the shadow of `\u0000\u0000` is smaller than the shadow of `\u0000\u0000`. In particular, this gives that the\nminimum shadow size is achieved by initial segments of colex. ",{"type":"∀ {n r : ℕ} {\u0000\u0000 \u0000\u0000 : Finset (Finset (Fin n))},\n  Set.Sized r ↑\u0000\u0000 → \u0000\u0000.card ≤ \u0000\u0000.card → Finset.Colex.IsInitSeg \u0000\u0000 r → \u0000\u0000.shadow.card ≤ \u0000\u0000.shadow.card","name":"Finset.kruskal_katona","isProp":true,"docString":"The **Kruskal-Katona theorem**.\n\nGiven a set family `\u0000\u0000` consisting of `r`-sets, and `\u0000\u0000` an initial segment of the colex order of the\nsame size, the shadow of `\u0000\u0000` is smaller than the shadow of `\u0000\u0000`. In particular, this gives that the\nminimum shadow size is achieved by initial segments of colex. ","distance":1.1142213791681696566371329026878811419010162353515625}],[" In every non-empty finite simple graph, there exists a vertex with the minimum degree.",{"type":"∀ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V],\n  ∃ v, G.minDegree = G.degree v","name":"SimpleGraph.exists_minimal_degree_vertex","isProp":true,"docString":" In every non-empty finite simple graph, there exists a vertex with the minimum degree.","distance":1.3076565972098261880773861776106059551239013671875}],["This theorem states that in a simple graph, if a natural number `k` is greater than or equal to the degree of every vertex, then `k` is also greater than or equal to the maximum degree of the graph. A simple graph is defined by a set of vertices `V` and an adjacency relation `Adj` that's decidable. The degree of a vertex is the number of edges connected to it, while the maximum degree of the graph is the highest degree among all vertices in the graph.",{"type":"∀ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (k : ℕ),\n  (∀ (v : V), G.degree v ≤ k) → G.maxDegree ≤ k","name":"SimpleGraph.maxDegree_le_of_forall_degree_le","isProp":true,"docString":"This theorem states that in a simple graph, if a natural number `k` is greater than or equal to the degree of every vertex, then `k` is also greater than or equal to the maximum degree of the graph. A simple graph is defined by a set of vertices `V` and an adjacency relation `Adj` that's decidable. The degree of a vertex is the number of edges connected to it, while the maximum degree of the graph is the highest degree among all vertices in the graph.","distance":1.3039133422818978136348277985234744846820831298828125}],["In a nonempty graph, if `k` is at most the degree of every vertex, it is at most the minimum\ndegree. Note the assumption that the graph is nonempty is necessary as long as `G.minDegree` is\ndefined to be a natural. ",{"type":"∀ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : Nonempty V] (k : ℕ),\n  (∀ (v : V), k ≤ G.degree v) → k ≤ G.minDegree","name":"SimpleGraph.le_minDegree_of_forall_le_degree","isProp":true,"docString":"In a nonempty graph, if `k` is at most the degree of every vertex, it is at most the minimum\ndegree. Note the assumption that the graph is nonempty is necessary as long as `G.minDegree` is\ndefined to be a natural. ","distance":1.1942280572102561553293753604521043598651885986328125}],["See `SimpleGraph.cliqueFree_of_chromaticNumber_lt` for a tighter bound. ",{"type":"∀ {α : Type u_1} {G : SimpleGraph α} {n : ℕ} [inst : Fintype α], Fintype.card α < n → G.CliqueFree n","name":"SimpleGraph.cliqueFree_of_card_lt","isProp":true,"docString":"See `SimpleGraph.cliqueFree_of_chromaticNumber_lt` for a tighter bound. ","distance":1.2390220993743554789290328699280507862567901611328125}],["The **Lovasz formulation of the Kruskal-Katona theorem**.\n\nIf `|\u0000\u0000| ≥ k choose r`, (and everything in `\u0000\u0000` has size `r`) then the initial segment we compare to\nis just all the subsets of `{0, ..., k - 1}` of size `r`. The `i`-th iterated shadow of this is all\nthe subsets of `{0, ..., k - 1}` of size `r - i`, so the `i`-th iterated shadow of `\u0000\u0000` has at least\n`k.choose (r - i)` elements. ",{"type":"∀ {n r k i : ℕ} {\u0000\u0000 : Finset (Finset (Fin n))},\n  i ≤ r → r ≤ k → k ≤ n → Set.Sized r ↑\u0000\u0000 → k.choose r ≤ \u0000\u0000.card → k.choose (r - i) ≤ (Finset.shadow^[i] \u0000\u0000).card","name":"Finset.kruskal_katona_lovasz_form","isProp":true,"docString":"The **Lovasz formulation of the Kruskal-Katona theorem**.\n\nIf `|\u0000\u0000| ≥ k choose r`, (and everything in `\u0000\u0000` has size `r`) then the initial segment we compare to\nis just all the subsets of `{0, ..., k - 1}` of size `r`. The `i`-th iterated shadow of this is all\nthe subsets of `{0, ..., k - 1}` of size `r - i`, so the `i`-th iterated shadow of `\u0000\u0000` has at least\n`k.choose (r - i)` elements. ","distance":1.2441617651863110527443723185569979250431060791015625}],["There are `min n r` parts in a graph on `n` vertices satisfying `G.IsTuranMaximal r`.\n`min` handles the `n < r` case, when `G` is complete but still `r + 1`-cliquefree\nfor having insufficiently many vertices. ",{"type":"∀ {V : Type u_1} [inst : Fintype V] {G : SimpleGraph V} [inst_1 : DecidableRel G.Adj] {r : ℕ} (h : G.IsTuranMaximal r)\n  [inst_2 : DecidableEq V], h.finpartition.parts.card = Fintype.card V ⊓ r","name":"SimpleGraph.IsTuranMaximal.card_parts","isProp":true,"docString":"There are `min n r` parts in a graph on `n` vertices satisfying `G.IsTuranMaximal r`.\n`min` handles the `n < r` case, when `G` is complete but still `r + 1`-cliquefree\nfor having insufficiently many vertices. ","distance":1.24523808844343353285921693895943462848663330078125}],["This is important for iterating Kruskal-Katona: the shadow of an initial segment is also an\ninitial segment. ",{"type":"∀ {α : Type u_1} [inst : LinearOrder α] {s : Finset α} [inst_1 : Fintype α] (hs : s.Nonempty),\n  (Finset.Colex.initSeg s).shadow = Finset.Colex.initSeg (s.erase (s.min' hs))","name":"Finset.Colex.shadow_initSeg","isProp":true,"docString":"This is important for iterating Kruskal-Katona: the shadow of an initial segment is also an\ninitial segment. ","distance":1.26204767676345586124853070941753685474395751953125}],["The intersection of two subgraphs. ",{"type":"{V : Type u} → {G : SimpleGraph V} → Min G.Subgraph","name":"SimpleGraph.Subgraph.instMin","isProp":false,"docString":"The intersection of two subgraphs. ","distance":1.2663923525017366511491445635329000651836395263671875}],["A subgraph is called a *spanning subgraph* if it contains all the vertices of `G`. ",{"type":"{V : Type u} → {G : SimpleGraph V} → G.Subgraph → Prop","name":"SimpleGraph.Subgraph.IsSpanning","isProp":false,"docString":"A subgraph is called a *spanning subgraph* if it contains all the vertices of `G`. ","distance":1.26934697206214952558411823702044785022735595703125}],["**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the minimum element from a nonempty tree. ",{"type":"{α : Type u_1} → Ordnode α → α → Ordnode α → α × Ordnode α","name":"Ordnode.splitMin'","isProp":false,"docString":"**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the minimum element from a nonempty tree. ","distance":1.272518909353200999845512342290021479129791259765625}],["A graph is preconnected if every pair of vertices is reachable from one another. ",{"type":"{V : Type u} → SimpleGraph V → Prop","name":"SimpleGraph.Preconnected","isProp":false,"docString":"A graph is preconnected if every pair of vertices is reachable from one another. ","distance":1.27257586073541073545811741496436297893524169921875}],["In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum\ndegree. ",{"type":"∀ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (k : ℕ),\n  (∀ (v : V), G.degree v ≤ k) → G.maxDegree ≤ k","name":"SimpleGraph.maxDegree_le_of_forall_degree_le","isProp":true,"docString":"In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum\ndegree. ","distance":1.2726237157148065914924472963321022689342498779296875}],["The minimum element of a tree is the left-most value. ",{"type":"{α : Type u_1} → Batteries.RBNode α → Option α","name":"Batteries.RBNode.min?","isProp":false,"docString":"The minimum element of a tree is the left-most value. ","distance":1.2898778055097477324153487643343396484851837158203125}],["Graph is connected. ",{"type":"∀ {V : Type u} {G : SimpleGraph V}, G.IsTree → G.Connected","name":"SimpleGraph.IsTree.isConnected","isProp":true,"docString":"Graph is connected. ","distance":1.3087699707819673289321826814557425677776336669921875}],["Given a subgraph and a set of vertices, delete all the vertices from the subgraph,\nif present. Any edges incident to the deleted vertices are deleted as well. ",{"type":"{V : Type u} → {G : SimpleGraph V} → G.Subgraph → Set V → G.Subgraph","name":"SimpleGraph.Subgraph.deleteVerts","isProp":false,"docString":"Given a subgraph and a set of vertices, delete all the vertices from the subgraph,\nif present. Any edges incident to the deleted vertices are deleted as well. ","distance":1.311197157958432502056211887975223362445831298828125}],["Given a walk that avoids a set of edges, produce a walk in the graph\nwith those edges deleted. ",{"type":"{V : Type u} →\n  {G : SimpleGraph V} →\n    (s : Set (Sym2 V)) → {v w : V} → (p : G.Walk v w) → (∀ e ∈ p.edges, e ∉ s) → (G.deleteEdges s).Walk v w","name":"SimpleGraph.Walk.toDeleteEdges","isProp":false,"docString":"Given a walk that avoids a set of edges, produce a walk in the graph\nwith those edges deleted. ","distance":1.3129514037356526667821299270144663751125335693359375}],["Density of edges of a graph between two finsets of vertices. ",{"type":"{α : Type u_4} → (G : SimpleGraph α) → [inst : DecidableRel G.Adj] → Finset α → Finset α → ℚ","name":"SimpleGraph.edgeDensity","isProp":false,"docString":"Density of edges of a graph between two finsets of vertices. ","distance":1.315119712831975373745763135957531630992889404296875}],["O(log n). Return the minimum element of the tree, if it exists.\n\nfindMin {1, 2, 3} = some 1\nfindMin ∅ = none ",{"type":"{α : Type u_1} → Ordnode α → Option α","name":"Ordnode.findMin","isProp":false,"docString":"O(log n). Return the minimum element of the tree, if it exists.\n\nfindMin {1, 2, 3} = some 1\nfindMin ∅ = none ","distance":1.32457112813263666595275935833342373371124267578125}],["The minimum degree in the graph is at most the degree of any particular vertex. ",{"type":"∀ {V : Type u_1} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V), G.minDegree ≤ G.degree v","name":"SimpleGraph.minDegree_le_degree","isProp":true,"docString":"The minimum degree in the graph is at most the degree of any particular vertex. ","distance":1.335926863441874612448145853704772889614105224609375}],["O(log n). Extract and remove the minimum element from the tree, if it exists.\n\nsplit_min {1, 2, 3} = some (1, {2, 3})\nsplit_min ∅ = none ",{"type":"{α : Type u_1} → Ordnode α → Option (α × Ordnode α)","name":"Ordnode.splitMin","isProp":false,"docString":"O(log n). Extract and remove the minimum element from the tree, if it exists.\n\nsplit_min {1, 2, 3} = some (1, {2, 3})\nsplit_min ∅ = none ","distance":1.3428499070490962363777498467243276536464691162109375}]]