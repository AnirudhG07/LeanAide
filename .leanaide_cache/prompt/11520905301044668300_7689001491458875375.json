[["The minimal positive integer with absolute value smaller than 1 is a prime number.",{"type":"∀ {f : MulRingNorm ℚ} {p : ℕ}, 0 < f ↑p → f ↑p < 1 → (∀ (m : ℕ), 0 < f ↑m ∧ f ↑m < 1 → p ≤ m) → Nat.Prime p","name":"Rat.MulRingNorm.is_prime_of_minimal_nat_zero_lt_mulRingNorm_lt_one","isProp":true,"docString":"The minimal positive integer with absolute value smaller than 1 is a prime number.","distance":0.88068231787710848923467210624949075281620025634765625}],[" The set of natural numbers less than 1 is equal to the singleton set {0}.",{"type":"Finset.range 1 = {0}","name":"Finset.range_one","isProp":true,"docString":" The set of natural numbers less than 1 is equal to the singleton set {0}.","distance":0.70672618976778256438819880713708698749542236328125}],["This theorem states that the infimum (greatest lower bound) of an empty set of natural numbers is 0. In other words, because 0 is the smallest natural number, it serves as the infimum for an empty set.",{"type":"sInf ∅ = 0","name":"Nat.sInf_empty","isProp":true,"docString":"This theorem states that the infimum (greatest lower bound) of an empty set of natural numbers is 0. In other words, because 0 is the smallest natural number, it serves as the infimum for an empty set.","distance":0.71292604822972116540569231801782734692096710205078125}],["The minimum non-zero entry in a list of natural numbers, or zero if all entries are zero.\n\nWe completely characterize the function via\n`nonzeroMinimum_eq_zero_iff` and `nonzeroMinimum_eq_nonzero_iff` below.\n",{"type":"List ℕ → ℕ","name":"List.nonzeroMinimum","isProp":false,"docString":"The minimum non-zero entry in a list of natural numbers, or zero if all entries are zero.\n\nWe completely characterize the function via\n`nonzeroMinimum_eq_zero_iff` and `nonzeroMinimum_eq_nonzero_iff` below.\n","distance":0.88769349483619375273946161541971378028392791748046875}],[" The infimum of a set of natural numbers is zero if and only if the set contains the natural number zero or is empty.",{"type":"∀ {s : Set ℕ}, sInf s = 0 ↔ 0 ∈ s ∨ s = ∅","name":"Nat.sInf_eq_zero","isProp":true,"docString":" The infimum of a set of natural numbers is zero if and only if the set contains the natural number zero or is empty.","distance":0.72216203627178610080505904988967813551425933837890625}],["This theorem states that the cardinal number one is less than or equal to aleph zero. Aleph zero, denoted as `ℵ₀`, is the smallest infinite cardinal number, typically corresponding to the cardinality (size) of the set of natural numbers. In other words, the size of any set with at least one element cannot be larger than the size of the set of natural numbers.",{"type":"1 ≤ Cardinal.aleph0","name":"Cardinal.one_le_aleph0","isProp":true,"docString":"This theorem states that the cardinal number one is less than or equal to aleph zero. Aleph zero, denoted as `ℵ₀`, is the smallest infinite cardinal number, typically corresponding to the cardinality (size) of the set of natural numbers. In other words, the size of any set with at least one element cannot be larger than the size of the set of natural numbers.","distance":0.77049053712705217744627361753373406827449798583984375}],["`Nat.find` is the minimum element of a nonempty set of natural numbers. ",{"type":"∀ {s : Set ℕ} [inst : DecidablePred fun x => x ∈ s] (hs : s.Nonempty), IsLeast s (Nat.find hs)","name":"Set.Nonempty.isLeast_natFind","isProp":true,"docString":"`Nat.find` is the minimum element of a nonempty set of natural numbers. ","distance":0.9241913658216571736403466275078244507312774658203125}],["If a small natural number is divisible by a larger natural number,\nthe small number is zero. ",{"type":"∀ {a b : ℕ}, a ∣ b → b < a → b = 0","name":"Nat.eq_zero_of_dvd_of_lt","isProp":true,"docString":"If a small natural number is divisible by a larger natural number,\nthe small number is zero. ","distance":0.9273996122882508519325028828461654484272003173828125}],["The sequence of natural numbers some 0, some 1, ... ",{"type":"Stream'.Seq ℕ","name":"Stream'.Seq.nats","isProp":false,"docString":"The sequence of natural numbers some 0, some 1, ... ","distance":0.935944771391799434923086664639413356781005859375}],["Type of natural numbers with infinity (`⊤`) ",{"type":"Type","name":"PartENat","isProp":false,"docString":"Type of natural numbers with infinity (`⊤`) ","distance":0.9531737923168492887526781487395055592060089111328125}],["Negation of a natural number. ",{"type":"ℕ → ℤ","name":"Int.negOfNat","isProp":false,"docString":"Negation of a natural number. ","distance":0.95941806528119288888234450496383942663669586181640625}],["In a monoid with zero, if zero equals one, then zero is the unique element.\n\nSomewhat arbitrarily, we define the default element to be `0`.\nAll other elements will be provably equal to it, but not necessarily definitionally equal. ",{"type":"{M₀ : Type u_1} → [inst : MulZeroOneClass M₀] → 0 = 1 → Unique M₀","name":"uniqueOfZeroEqOne","isProp":false,"docString":"In a monoid with zero, if zero equals one, then zero is the unique element.\n\nSomewhat arbitrarily, we define the default element to be `0`.\nAll other elements will be provably equal to it, but not necessarily definitionally equal. ","distance":0.9691978582681068932203061194741167128086090087890625}],["The underlying natural number ",{"type":"ℕ+ → ℕ","name":"PNat.val","isProp":false,"docString":"The underlying natural number ","distance":0.97738256765213360477417836591484956443309783935546875}],["There exists a minimal positive integer with absolute value smaller than 1. ",{"type":"∀ {f : MulRingNorm ℚ},\n  f ≠ 1 → (∀ (n : ℕ), f ↑n ≤ 1) → ∃ p, (0 < f ↑p ∧ f ↑p < 1) ∧ ∀ (m : ℕ), 0 < f ↑m ∧ f ↑m < 1 → p ≤ m","name":"Rat.MulRingNorm.exists_minimal_nat_zero_lt_mulRingNorm_lt_one","isProp":true,"docString":"There exists a minimal positive integer with absolute value smaller than 1. ","distance":0.98326482831983696986100085268844850361347198486328125}],["The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from Lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n",{"type":"Lean.ParserDescr","name":"termℕ","isProp":false,"docString":"The type of natural numbers, starting at zero. It is defined as an\ninductive type freely generated by \"zero is a natural number\" and\n\"the successor of a natural number is a natural number\".\n\nYou can prove a theorem `P n` about `n : Nat` by `induction n`, which will\nexpect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming\na proof of `P i`. The same method also works to define functions by recursion\non natural numbers: induction and recursion are two expressions of the same\noperation from Lean's point of view.\n\n```\nopen Nat\nexample (n : Nat) : n < succ n := by\n  induction n with\n  | zero =>\n    show 0 < 1\n    decide\n  | succ i ih => -- ih : i < succ i\n    show succ i < succ (succ i)\n    exact Nat.succ_lt_succ ih\n```\n\nThis type is special-cased by both the kernel and the compiler:\n* The type of expressions contains \"`Nat` literals\" as a primitive constructor,\n  and the kernel knows how to reduce zero/succ expressions to nat literals.\n* If implemented naively, this type would represent a numeral `n` in unary as a\n  linked list with `n` links, which is horribly inefficient. Instead, the\n  runtime itself has a special representation for `Nat` which stores numbers up\n  to 2^63 directly and larger numbers use an arbitrary precision \"bignum\"\n  library (usually [GMP](https://gmplib.org/)).\n","distance":0.984509540272666239246746044955216348171234130859375}],["`⌊a⌋₊` is the greatest natural `n` such that `n ≤ a`. If `a` is negative, then `⌊a⌋₊ = 0`. ",{"type":"{α : Type u_2} → [inst : OrderedSemiring α] → [inst : FloorSemiring α] → α → ℕ","name":"Nat.floor","isProp":false,"docString":"`⌊a⌋₊` is the greatest natural `n` such that `n ≤ a`. If `a` is negative, then `⌊a⌋₊ = 0`. ","distance":0.98615442336349357077551758266054093837738037109375}],["0 is in the set of natural number multiples of an element of an `AddMonoid`.",{"type":"∀ {M : Type u_1} [inst : AddMonoid M] {x : M}, 0 ∈ multiples x","name":"multiples.zero_mem","isProp":true,"docString":"0 is in the set of natural number multiples of an element of an `AddMonoid`.","distance":0.98742466830639497032962026423774659633636474609375}],["Any infinite set of naturals is denumerable. ",{"type":"(s : Set ℕ) → [inst : DecidablePred fun x => x ∈ s] → [inst : Infinite ↑s] → Denumerable ↑s","name":"Nat.Subtype.denumerable","isProp":false,"docString":"Any infinite set of naturals is denumerable. ","distance":0.99620230234995144069642947215470485389232635498046875}],["The number of bits required to represent a `Num`, as a `Nat`. `size 0` is defined to be `0`. ",{"type":"Num → ℕ","name":"Num.natSize","isProp":false,"docString":"The number of bits required to represent a `Num`, as a `Nat`. `size 0` is defined to be `0`. ","distance":0.99882229191236693299771332021919079124927520751953125}],["Notation for 0 ",{"type":"Zero ONote","name":"ONote.instZero","isProp":false,"docString":"Notation for 0 ","distance":0.9991397722992818586362773203290998935699462890625}],["The set of natural numbers is equivalent to `ℕ ⊕ PUnit`. ",{"type":"ℕ ≃ ℕ ⊕ PUnit.{u_9 + 1}","name":"Equiv.natEquivNatSumPUnit","isProp":false,"docString":"The set of natural numbers is equivalent to `ℕ ⊕ PUnit`. ","distance":1.0008895272172531054621913426672108471393585205078125}],["An element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. ",{"type":"{R : Type u_1} → [inst : Zero R] → [inst : Pow R ℕ] → R → Prop","name":"IsNilpotent","isProp":false,"docString":"An element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. ","distance":1.0056694538663741855799571567331440746784210205078125}],["Boolean less-than of natural numbers. ",{"type":"ℕ → ℕ → Bool","name":"Nat.blt","isProp":false,"docString":"Boolean less-than of natural numbers. ","distance":1.00678333707275502462152871885336935520172119140625}],["Addition of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n",{"type":"ℕ → ℕ → ℕ","name":"Nat.add","isProp":false,"docString":"Addition of natural numbers.\n\nThis definition is overridden in both the kernel and the compiler to efficiently\nevaluate using the \"bignum\" representation (see `Nat`). The definition provided\nhere is the logical model (and it is soundness-critical that they coincide).\n","distance":1.0087861262377746385254795313812792301177978515625}]]