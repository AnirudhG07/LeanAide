[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"‚Ñ§ ‚Üí ‚Ñ§","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9639482729247372816416827845387160778045654296875}],[" For an additive group `G` and its subgroup `H`, `coerce H to set = {-} : set G <=> H = G`.",{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G}, ‚ÜëH = Set.univ ‚Üî H = ‚ä§","name":"AddSubgroup.coe_eq_univ","isProp":true,"docString":" For an additive group `G` and its subgroup `H`, `coerce H to set = {-} : set G <=> H = G`.","distance":2.017728327413852440486152772791683673858642578125}],["The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.",{"type":"Int.sign 0 = 0","name":"Int.sign_zero","isProp":true,"docString":"The theorem `Int.sign_zero` asserts that the sign of the integer 0 is also 0. In other words, when the function `Int.sign` is applied to the integer 0, it returns 0, which is consistent with the definition of the sign function that assigns `0` to `0`, `1` to positive integers, and `-1` to negative integers.","distance":2.00791426198991285190231792512349784374237060546875}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type ‚Üí Type} ‚Üí [inst : Monad m] ‚Üí [inst : Lean.MonadEnv m] ‚Üí [inst : Lean.MonadError m] ‚Üí Lean.Name ‚Üí m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.9647203453025741115567370798089541494846343994140625}],[" In a preordered type, if `x` is less than `y`, then `x ‚â† y`.",{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {x y : Œ±}, x < y ‚Üí y ‚â† x","name":"LT.lt.ne'","isProp":true,"docString":" In a preordered type, if `x` is less than `y`, then `x ‚â† y`.","distance":2.019985459977239106166280180332250893115997314453125}],["The theorem `Homeomorph.isOpen_preimage` states that for any two types `X` and `Y` with their respective topological space instances, and for any homeomorphism `h` from `X` to `Y`, a set `s` in `Y` is open if and only if its preimage under `h` is open in `X`. Here, the preimage of `s` under `h` is the set of all elements in `X` that `h` maps to `s`. This theorem essentially characterizes one of the key properties of homeomorphisms in topology, which is that they preserve the open (and also closed) sets between the topological spaces.",{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (h : X ‚âÉ‚Çú Y) {s : Set Y},\n  IsOpen (‚áëh ‚Åª¬π' s) ‚Üî IsOpen s","name":"Homeomorph.isOpen_preimage","isProp":true,"docString":"The theorem `Homeomorph.isOpen_preimage` states that for any two types `X` and `Y` with their respective topological space instances, and for any homeomorphism `h` from `X` to `Y`, a set `s` in `Y` is open if and only if its preimage under `h` is open in `X`. Here, the preimage of `s` under `h` is the set of all elements in `X` that `h` maps to `s`. This theorem essentially characterizes one of the key properties of homeomorphisms in topology, which is that they preserve the open (and also closed) sets between the topological spaces.","distance":2.01803651533473082935188358533196151256561279296875}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData ‚Üí String ‚Üí Lean.Name ‚Üí Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9759164704754004215914164888090454041957855224609375}],["Default definition of `min`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.98502208912106237193029301124624907970428466796875}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"‚àÄ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {K : Set F},\n  Convex ‚Ñù K ‚Üí ‚àÄ {u v : F}, v ‚àà K ‚Üí (‚Äñu - v‚Äñ = ‚®Ö w, ‚Äñu - ‚Üëw‚Äñ ‚Üî ‚àÄ w ‚àà K, ‚ü™u - v, w - v‚ü´_‚Ñù ‚â§ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9873065720868137162824496044777333736419677734375}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.992859841083368888092763882013969123363494873046875}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9939838565013403570702621436794288456439971923828125}],["The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. ",{"type":"Lean.ParserDescr","name":"prioHigh","isProp":false,"docString":"The standardized \"high\" priority `high = 10000`, for things that should be higher than default priority. ","distance":1.9943539802590652953995231655426323413848876953125}],["Find the first minimal element of an array. If the array is empty, `default` is\nreturned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is\nconsidered.\n",{"type":"{Œ± : Type u_1} ‚Üí [ord : Ord Œ±] ‚Üí [inst : Inhabited Œ±] ‚Üí (xs : Array Œ±) ‚Üí optParam ‚Ñï 0 ‚Üí optParam ‚Ñï (Array.size xs) ‚Üí Œ±","name":"Array.minI","isProp":false,"docString":"Find the first minimal element of an array. If the array is empty, `default` is\nreturned. If `start` and `stop` are given, only the subarray `xs[start:stop]` is\nconsidered.\n","distance":1.9968991440426375749694898331654258072376251220703125}],["Corresponds to `dist_pos`. ",{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x y : (i : Œπ) ‚Üí Œ≤ i},\n  0 < hammingDist x y ‚Üî x ‚â† y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.997015193411815658919294946826994419097900390625}],["**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {f : E ‚Üí Œ≤} {x y z : E}, ConcaveOn ùïú (segment ùïú x y) f ‚Üí z ‚àà segment ùïú x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_segment","isProp":true,"docString":"**Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.997280473748123785782127015409059822559356689453125}],["**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ",{"type":"‚àÄ {ùïú : Type u_1} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module ùïú Œ≤] [inst_3 : OrderedSMul ùïú Œ≤] {f : ùïú ‚Üí Œ≤} {x y z : ùïú},\n  ConcaveOn ùïú (Set.Icc x y) f ‚Üí z ‚àà Set.Icc x y ‚Üí min (f x) (f y) ‚â§ f z","name":"ConcaveOn.min_le_of_mem_Icc","isProp":true,"docString":"**Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. ","distance":1.997451523590491273552061102236621081829071044921875}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9987402092509520823426782953902147710323333740234375}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace Œ± ‚Üí ‚àÄ {f : Œ± ‚Üí Y}, Continuous f ‚Üí ‚àÄ {x y : Œ±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":1.9995654098207225057848290816764347255229949951171875}],["Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ",{"type":"{K : semiOutParam (Type u_1)} ‚Üí [self : IsROrC K] ‚Üí K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = ‚Ñù`. ","distance":1.9999830640212963306368010307778604328632354736328125}],["The value `BoxIntegral.IntegrationParams.GP = ‚ä•`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ",{"type":"Inhabited BoxIntegral.IntegrationParams","name":"BoxIntegral.IntegrationParams.instInhabitedIntegrationParams","isProp":false,"docString":"The value `BoxIntegral.IntegrationParams.GP = ‚ä•`\n(`bRiemann = false`, `bHenstock = true`, `bDistortion = true`)\ncorresponds to a generalization of the Henstock integral such that the Divergence theorem holds true\nwithout additional integrability assumptions, see the module docstring for details. ","distance":2.000033832256477683841922043939121067523956298828125}],["Parse a rule for `initialize_simps_projections`. It is `<name>‚Üí<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.",{"type":"Lean.Syntax ‚Üí Lean.Elab.Command.CommandElabM Simps.ProjectionRule","name":"Simps.elabSimpsRule","isProp":false,"docString":"Parse a rule for `initialize_simps_projections`. It is `<name>‚Üí<name>`, `-<name>`, `+<name>`\nor `as_prefix <name>`.","distance":2.000224205972808366738036056631244719028472900390625}],["Default definition of `max`. ",{"type":"{Œ± : Type u} ‚Üí [inst : LE Œ±] ‚Üí [inst : DecidableRel fun x x_1 => x ‚â§ x_1] ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±","name":"maxDefault","isProp":false,"docString":"Default definition of `max`. ","distance":2.0015224430848217451739401440136134624481201171875}],["Attribute for identifying `positivity` extensions. ",{"type":"Lean.ParserDescr","name":"positivity","isProp":false,"docString":"Attribute for identifying `positivity` extensions. ","distance":2.001616295184305283072490055928938090801239013671875}],["Helper function for `#long_names` and `#long_instances`. ",{"type":"Std.HashMap Lean.Name (Array Lean.Name) ‚Üí IO Unit","name":"printNameHashMap","isProp":false,"docString":"Helper function for `#long_names` and `#long_instances`. ","distance":2.001825922871980356632093389634974300861358642578125}]]