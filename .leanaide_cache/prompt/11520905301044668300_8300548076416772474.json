[["Convert a pre-set to a `set` of pre-sets. ",{"type":"PSet → Set PSet","name":"PSet.toSet","isProp":false,"docString":"Convert a pre-set to a `set` of pre-sets. ","distance":1.9759126651216434300550872649182565510272979736328125}],[" The normalization of a natural number expression constraint does not change its denotation within a given context.",{"type":"∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx c.toNormPoly = Nat.Linear.ExprCnstr.denote ctx c","name":"Nat.Linear.ExprCnstr.denote_toNormPoly","isProp":true,"docString":" The normalization of a natural number expression constraint does not change its denotation within a given context.","distance":2.001266542757190070034312157076783478260040283203125}],["This theorem states that for any positive number `n` of type `PosNum`, the double coercion of `n` to natural number and then to integer is equal to the direct coercion of `n` to integer. Essentially, it ensures that converting a positive number to a natural number and then to an integer yields the same result as directly converting the positive number to an integer.",{"type":"∀ (n : PosNum), ↑↑n = ↑n","name":"PosNum.to_nat_to_int","isProp":true,"docString":"This theorem states that for any positive number `n` of type `PosNum`, the double coercion of `n` to natural number and then to integer is equal to the direct coercion of `n` to integer. Essentially, it ensures that converting a positive number to a natural number and then to an integer yields the same result as directly converting the positive number to an integer.","distance":2.004404314287445032505274866707623004913330078125}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9813177672951862717809490277431905269622802734375}],[" A set in a sigma-finite measurable space has positive measure if and only if there exists a finite measure spanning set index such that the intersection of the set with that spanning set has positive measure.",{"type":"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\n  (s : Set α), (∃ n, 0 < ↑↑μ (s ∩ MeasureTheory.spanningSets μ n)) ↔ 0 < ↑↑μ s","name":"MeasureTheory.Measure.exists_measure_inter_spanningSets_pos","isProp":true,"docString":" A set in a sigma-finite measurable space has positive measure if and only if there exists a finite measure spanning set index such that the intersection of the set with that spanning set has positive measure.","distance":2.0073567460882255630849613226018846035003662109375}],["This theorem states that for every positive number `n`, the double-coercion of `n` (which converts it first into a natural number and then into a number) gives the positive version of `n`. In other words, converting a positive number to a natural number and then to a generic number preserves its positivity. This can be symbolically represented in LaTeX as, for all positive numbers $n$, we have $n = \\text{Num.pos} \\ n$.",{"type":"∀ (n : PosNum), ↑↑n = Num.pos n","name":"PosNum.of_to_nat","isProp":true,"docString":"This theorem states that for every positive number `n`, the double-coercion of `n` (which converts it first into a natural number and then into a number) gives the positive version of `n`. In other words, converting a positive number to a natural number and then to a generic number preserves its positivity. This can be symbolically represented in LaTeX as, for all positive numbers $n$, we have $n = \\text{Num.pos} \\ n$.","distance":2.0094999730632014944831098546274006366729736328125}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ interior (⇑(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.981989186641133660060631882515735924243927001953125}],["`whatsnew in $command` executes the command and then prints the\ndeclarations that were added to the environment. ",{"type":"Lean.ParserDescr","name":"Mathlib.WhatsNew.commandWhatsnewIn__","isProp":false,"docString":"`whatsnew in $command` executes the command and then prints the\ndeclarations that were added to the environment. ","distance":1.9835947246217913164656465596635825932025909423828125}],["The edit to perform on the file. ",{"type":"ProofWidgets.MakeEditLinkProps → Lean.Lsp.TextDocumentEdit","name":"ProofWidgets.MakeEditLinkProps.edit","isProp":false,"docString":"The edit to perform on the file. ","distance":1.984303644917567499561528165941126644611358642578125}],["Restrict a prepartition to a box. ",{"type":"{ι : Type u_1} →\n  {I : BoxIntegral.Box ι} → BoxIntegral.Prepartition I → (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J","name":"BoxIntegral.Prepartition.restrict","isProp":false,"docString":"Restrict a prepartition to a box. ","distance":1.985420175772002693292961339466273784637451171875}],["The universal set `Set.univ` in a preconnected space is a preconnected set. ",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] [self : PreconnectedSpace α], IsPreconnected Set.univ","name":"PreconnectedSpace.isPreconnected_univ","isProp":true,"docString":"The universal set `Set.univ` in a preconnected space is a preconnected set. ","distance":1.9868046266668517585429754035430960357189178466796875}],["Elaborate a `#noalign` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabNoAlign","isProp":false,"docString":"Elaborate a `#noalign` command. ","distance":1.9884853231156214281583061165292747318744659423828125}],["If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ ⇑(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.990407481972321424024130465113557875156402587890625}],["the condition that `premap` is in the presieve ",{"type":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\n  {F : CategoryTheory.Functor C D} {X : C} {S : CategoryTheory.Presieve X} {Y : D} {f : Y ⟶ F.obj X}\n  (self : CategoryTheory.Presieve.FunctorPushforwardStructure F S f), S self.premap","name":"CategoryTheory.Presieve.FunctorPushforwardStructure.cover","isProp":true,"docString":"the condition that `premap` is in the presieve ","distance":1.9909010334703893807528629622538574039936065673828125}],["Elaborate an `#align` command. ",{"type":"Lean.Elab.Command.CommandElab","name":"Mathlib.Prelude.Rename.elabAlign","isProp":false,"docString":"Elaborate an `#align` command. ","distance":1.9909656043963313010181082063354551792144775390625}],["Which textual range to select after the edit.\nThe range is interpreted in the file that `edit` applies to.\nIf present and `start == end`, the cursor is moved to `start` and nothing is selected.\nIf not present, the selection is not changed. ",{"type":"ProofWidgets.MakeEditLinkProps → Option Lean.Lsp.Range","name":"ProofWidgets.MakeEditLinkProps.newSelection?","isProp":false,"docString":"Which textual range to select after the edit.\nThe range is interpreted in the file that `edit` applies to.\nIf present and `start == end`, the cursor is moved to `start` and nothing is selected.\nIf not present, the selection is not changed. ","distance":1.9910564029386372819629968944354914128780364990234375}],["index set of an open cover of a scheme `X` ",{"type":"{X : AlgebraicGeometry.Scheme} → AlgebraicGeometry.Scheme.OpenCover X → Type v","name":"AlgebraicGeometry.Scheme.OpenCover.J","isProp":false,"docString":"index set of an open cover of a scheme `X` ","distance":1.9919082568310824132851166723412461578845977783203125}],["A link that, when clicked, makes the specified edit\nand potentially moves the cursor\nor makes a selection. ",{"type":"ProofWidgets.Component ProofWidgets.MakeEditLinkProps","name":"ProofWidgets.MakeEditLink","isProp":false,"docString":"A link that, when clicked, makes the specified edit\nand potentially moves the cursor\nor makes a selection. ","distance":1.9920038969437958709107761023915372788906097412109375}],["Checks that `id` has not already been `#align`ed or `#noalign`ed. ",{"type":"{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadEnv m] → [inst : Lean.MonadError m] → Lean.Name → m Unit","name":"Mathlib.Prelude.Rename.ensureUnused","isProp":false,"docString":"Checks that `id` has not already been `#align`ed or `#noalign`ed. ","distance":1.992878825332840886375151967513374984264373779296875}],["The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. ",{"type":"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {ι : Type u_4} (w : ι → k) (p : ι → P) {s₁ s₂ : Finset ι},\n  s₁ ⊆ s₂ → (Finset.weightedVSub s₁ p) w = (Finset.weightedVSub s₂ p) (Set.indicator (↑s₁) w)","name":"Finset.weightedVSub_indicator_subset","isProp":true,"docString":"The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. ","distance":1.9933318035675282597907198578468523919582366943359375}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name → Array Simps.ParsedProjectionData → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.9933931243461582294429490502807311713695526123046875}],["Reinterpret a clopen as an open. ",{"type":"{α : Type u_2} → [inst : TopologicalSpace α] → TopologicalSpace.Clopens α → TopologicalSpace.Opens α","name":"TopologicalSpace.Clopens.toOpens","isProp":false,"docString":"Reinterpret a clopen as an open. ","distance":1.9940550757500361545027089960058219730854034423828125}],["Right-shift the binary representation of a `PosNum`. ",{"type":"PosNum → ℕ → Num","name":"PosNum.shiftr","isProp":false,"docString":"Right-shift the binary representation of a `PosNum`. ","distance":1.99475715881088877523552582715637981891632080078125}],["We construct an open cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original open cover. ",{"type":"{X : AlgebraicGeometry.Scheme} →\n  (𝒰 : AlgebraicGeometry.Scheme.OpenCover X) →\n    (J : Type u_1) →\n      (obj : J → AlgebraicGeometry.Scheme) →\n        (map : (i : J) → obj i ⟶ X) →\n          (e₁ : J ≃ 𝒰.J) →\n            (e₂ : (i : J) → obj i ≅ AlgebraicGeometry.Scheme.OpenCover.obj 𝒰 (e₁ i)) →\n              (∀ (i : J),\n                  map i =\n                    CategoryTheory.CategoryStruct.comp (e₂ i).hom (AlgebraicGeometry.Scheme.OpenCover.map 𝒰 (e₁ i))) →\n                AlgebraicGeometry.Scheme.OpenCover X","name":"AlgebraicGeometry.Scheme.OpenCover.copy","isProp":false,"docString":"We construct an open cover from another, by providing the needed fields and showing that the\nprovided fields are isomorphic with the original open cover. ","distance":1.99557838367231621390374129987321794033050537109375}]]