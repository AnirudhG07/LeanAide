[["Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n",{"type":"ℤ → ℤ","name":"Int.sign","isProp":false,"docString":"Returns the \"sign\" of the integer as another integer: `1` for positive numbers,\n`-1` for negative numbers, and `0` for `0`.\n","distance":1.9272968786111406291894354581017978489398956298828125}],[" For any inner product space `(E, ⟨·, ·⟩)` over commutative scalar type `𝕜`, ⟨0, x⟩ = 0 for all `x ∈ E`.",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x : E), ⟪0, x⟫_𝕜 = 0","name":"inner_zero_left","isProp":true,"docString":" For any inner product space `(E, ⟨·, ·⟩)` over commutative scalar type `𝕜`, ⟨0, x⟩ = 0 for all `x ∈ E`.","distance":1.953834794520084461311171253328211605548858642578125}],["The theorem `Metric.hausdorffDist_self_closure` states that for any set `s` in a space `α` (where `α` is a pseudo-metric space), the Hausdorff distance between the set `s` and its closure is zero. In other words, given a set within a space that follows the rules of a pseudo-metric space, the smallest nonnegative distance (`r`) such that each element of the set and its closure (the smallest closed set containing `s`) are within `r` of each other is always zero.",{"type":"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s (closure s) = 0","name":"Metric.hausdorffDist_self_closure","isProp":true,"docString":"The theorem `Metric.hausdorffDist_self_closure` states that for any set `s` in a space `α` (where `α` is a pseudo-metric space), the Hausdorff distance between the set `s` and its closure is zero. In other words, given a set within a space that follows the rules of a pseudo-metric space, the smallest nonnegative distance (`r`) such that each element of the set and its closure (the smallest closed set containing `s`) are within `r` of each other is always zero.","distance":1.9477899502673887699444321697228588163852691650390625}],["The default priority for spawned tasks, also the lowest priority: `0`. ",{"type":"Task.Priority","name":"Task.Priority.default","isProp":false,"docString":"The default priority for spawned tasks, also the lowest priority: `0`. ","distance":1.9426169242634261369317982826032675802707672119140625}],[" For any positive real number `y`, 0 raised to the power `y` equals 0.",{"type":"∀ {y : ℝ}, 0 < y → 0 ^ y = 0","name":"ENNReal.zero_rpow_of_pos","isProp":true,"docString":" For any positive real number `y`, 0 raised to the power `y` equals 0.","distance":1.9633309235160505412665088442736305296421051025390625}],["The theorem `Real.sign_zero` states that the sign function applied to the real number 0 is 0. In other words, according to our definition of the sign function for real numbers, where negative numbers are mapped to -1, positive numbers to 1, and 0 is left as is, when we apply this function on 0, we get 0 in return.",{"type":"Real.sign 0 = 0","name":"Real.sign_zero","isProp":true,"docString":"The theorem `Real.sign_zero` states that the sign function applied to the real number 0 is 0. In other words, according to our definition of the sign function for real numbers, where negative numbers are mapped to -1, positive numbers to 1, and 0 is left as is, when we apply this function on 0, we get 0 in return.","distance":1.9534305035697372421310546997119672596454620361328125}],["The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n",{"type":"Task.Priority","name":"Task.Priority.max","isProp":false,"docString":"The highest regular priority for spawned tasks: `8`.\n\nSpawning a task with a priority higher than `Task.Priority.max` is not an error but\nwill spawn a dedicated worker for the task, see `Task.Priority.dedicated`.\nRegular priority tasks are placed in a thread pool and worked on according to the priority order.\n","distance":1.9438462519659938099181317738839425146579742431640625}],["Default definition of `min`. ",{"type":"{α : Type u} → [inst : LE α] → [inst : DecidableRel fun x x_1 => x ≤ x_1] → α → α → α","name":"minDefault","isProp":false,"docString":"Default definition of `min`. ","distance":1.9469545706442989985163194432971067726612091064453125}],["Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ",{"type":"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {K : Set F},\n  Convex ℝ K → ∀ {u v : F}, v ∈ K → (‖u - v‖ = ⨅ w, ‖u - ↑w‖ ↔ ∀ w ∈ K, ⟪u - v, w - v⟫_ℝ ≤ 0)","name":"norm_eq_iInf_iff_real_inner_le_zero","isProp":true,"docString":"Characterization of minimizers for the projection on a convex set in a real inner product\nspace. ","distance":1.9479894988882413553454853172297589480876922607421875}],["Corresponds to `dist_pos`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)] {x y : (i : ι) → β i},\n  0 < hammingDist x y ↔ x ≠ y","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. ","distance":1.94898810220364371303958250791765749454498291015625}],["Corresponds to `zero_eq_dist`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)] {x y : (i : ι) → β i},\n  0 = hammingDist x y ↔ x = y","name":"hamming_zero_eq_dist","isProp":true,"docString":"Corresponds to `zero_eq_dist`. ","distance":1.9493384126284940549567181733436882495880126953125}],["The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n",{"type":"(R : Type u_1) → (M : Type u_2) → [inst : Semiring R] → [inst_1 : AddCommGroup M] → [inst : Module R M] → ℕ","name":"FiniteDimensional.finrank","isProp":false,"docString":"The rank of a module as a natural number.\n\nDefined by convention to be `0` if the space has infinite rank.\n\nFor a vector space `M` over a field `R`, this is the same as the finite dimension\nof `M` over `R`.\n","distance":1.9512843088611695474554608153994195163249969482421875}],["Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ",{"type":"{E : ℕ → Type u_2} → ((n : ℕ) → E n) → Set ((n : ℕ) → E n) → ℕ","name":"PiNat.shortestPrefixDiff","isProp":false,"docString":"Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`shortestPrefixDiff x s` if the smallest `n` for which there is no element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, then use `0` by convention. ","distance":1.9518766537567848740053477740730158984661102294921875}],["`toReal x` returns `x` if it is real, `0` otherwise. ",{"type":"ENNReal → ℝ","name":"ENNReal.toReal","isProp":false,"docString":"`toReal x` returns `x` if it is real, `0` otherwise. ","distance":1.9532146686738365293223296248470433056354522705078125}],["`toNNReal x` returns `x` if it is real, otherwise 0. ",{"type":"ENNReal → NNReal","name":"ENNReal.toNNReal","isProp":false,"docString":"`toNNReal x` returns `x` if it is real, otherwise 0. ","distance":1.9532609804567580003009652500622905790805816650390625}],["Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. ",{"type":"{K : semiOutParam (Type u_1)} → [self : IsROrC K] → K","name":"IsROrC.I","isProp":false,"docString":"Imaginary unit in `K`. Meant to be set to `0` for `K = ℝ`. ","distance":1.9533475463806038163738776347599923610687255859375}],["Corresponds to `dist_zero_right`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)]\n  [inst_2 : (i : ι) → Zero (β i)] (x : (i : ι) → β i), hammingDist x 0 = hammingNorm x","name":"hammingDist_zero_right","isProp":true,"docString":"Corresponds to `dist_zero_right`. ","distance":1.9540444043191314005269987319479696452617645263671875}],["The default priority `default = 1000`, which is used when no priority is set. ",{"type":"Lean.ParserDescr","name":"prioDefault","isProp":false,"docString":"The default priority `default = 1000`, which is used when no priority is set. ","distance":1.9541212646058723212405539015890099108219146728515625}],["Corresponds to `dist_eq_zero`. ",{"type":"∀ {ι : Type u_2} {β : ι → Type u_3} [inst : Fintype ι] [inst_1 : (i : ι) → DecidableEq (β i)] {x y : (i : ι) → β i},\n  hammingDist x y = 0 ↔ x = y","name":"hammingDist_eq_zero","isProp":true,"docString":"Corresponds to `dist_eq_zero`. ","distance":1.9543405980943766575563813603366725146770477294921875}],["A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.",{"type":"{M₁ : Type u_1} →\n  {M₂ : Type u_2} →\n    [inst : Zero M₁] →\n      [inst_1 : Neg M₁] →\n        [inst_2 : NegZeroClass M₂] →\n          (f : M₁ → M₂) → Function.Injective f → f 0 = 0 → (∀ (x : M₁), f (-x) = -f x) → NegZeroClass M₁","name":"Function.Injective.negZeroClass","isProp":false,"docString":"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.","distance":1.9546906425326320277946479109232313930988311767578125}],["A `PreconnectedSpace` version of `isPreconnected.constant` ",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] {Y : Type u_3} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y],\n  PreconnectedSpace α → ∀ {f : α → Y}, Continuous f → ∀ {x y : α}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` ","distance":1.954785535826803144487939789541997015476226806640625}],["`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n",{"type":"Lean.Elab.Tactic.TacticM Unit → Lean.Expr → Lean.MetaM Lean.Expr","name":"Linarith.proveEqZeroUsing","isProp":false,"docString":"`proveEqZeroUsing tac e` tries to use `tac` to construct a proof of `e = 0`.\n","distance":1.95507663824938138219522443250752985477447509765625}],["Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ",{"type":"{E : ℕ → Type u_2} → ((n : ℕ) → E n) → Set ((n : ℕ) → E n) → ℕ","name":"PiNat.longestPrefix","isProp":false,"docString":"Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then\n`longestPrefix x s` if the largest `n` for which there is an element of `s` having the same\nprefix of length `n` as `x`. If there is no such `n`, use `0` by convention. ","distance":1.95554319242628249497784054256044328212738037109375}],["**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull 𝕜 s` lies in `s`. ",{"type":"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]\n  {s : Set E} {f : E → β}, ConcaveOn 𝕜 ((convexHull 𝕜) s) f → ∀ {x : E}, x ∈ (convexHull 𝕜) s → ∃ y ∈ s, f y ≤ f x","name":"ConcaveOn.exists_le_of_mem_convexHull","isProp":true,"docString":"**Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull 𝕜 s` lies in `s`. ","distance":1.9562153696447863726604055045754648745059967041015625}]]