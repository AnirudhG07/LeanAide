[["`Set.projIcc` is a contraction. ",{"type":"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b c d : α} (h : a ≤ b),\n  |↑(Set.projIcc a b h c) - ↑(Set.projIcc a b h d)| ≤ |c - d|","name":"Set.abs_projIcc_sub_projIcc","isProp":true,"docString":"`Set.projIcc` is a contraction. ","distance":1.9233352947949471367650176034658215939998626708984375}],[" For any type `α` with a linear order and any `b` in `α`, the `Set.projIic` function maps elements in the left-infinite right-closed interval `(-∞, b]` to themselves.",{"type":"∀ {α : Type u_1} [inst : LinearOrder α] {b : α} (x : ↑(Set.Iic b)), Set.projIic b ↑x = x","name":"Set.projIic_coe","isProp":true,"docString":" For any type `α` with a linear order and any `b` in `α`, the `Set.projIic` function maps elements in the left-infinite right-closed interval `(-∞, b]` to themselves.","distance":1.9145514606873696994426836681668646633625030517578125}],["The theorem `Filter.principal_univ` states that for any type `α`, the principal filter of the universal set `Set.univ` (which includes all elements of type `α`) is equal to the top filter (often denoted as `⊤`). In other words, the collection of all supersets of the universal set for any given type is the same as the most inclusive filter, or top filter.",{"type":"∀ {α : Type u}, Filter.principal Set.univ = ⊤","name":"Filter.principal_univ","isProp":true,"docString":"The theorem `Filter.principal_univ` states that for any type `α`, the principal filter of the universal set `Set.univ` (which includes all elements of type `α`) is equal to the top filter (often denoted as `⊤`). In other words, the collection of all supersets of the universal set for any given type is the same as the most inclusive filter, or top filter.","distance":1.9434275723207570241157782220398075878620147705078125}],["The epimorphism `projective.π : projective.over X ⟶ X`\nfrom the arbitrarily chosen projective object over `X`.\n",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.EnoughProjectives C] → (X : C) → CategoryTheory.Projective.over X ⟶ X","name":"CategoryTheory.Projective.π","isProp":false,"docString":"The epimorphism `projective.π : projective.over X ⟶ X`\nfrom the arbitrarily chosen projective object over `X`.\n","distance":1.9272199906939351254919756684103049337863922119140625}],[" For any type `α` with a linear order, and any `b` in `α` and `x` in the interval `(-∞, b]`, the projection of `x` onto `(-∞, b]` using `Set.projIic` equals `x`.",{"type":"∀ {α : Type u_1} [inst : LinearOrder α] {b x : α} (hx : x ∈ Set.Iic b), Set.projIic b x = ⟨x, hx⟩","name":"Set.projIic_of_mem","isProp":true,"docString":" For any type `α` with a linear order, and any `b` in `α` and `x` in the interval `(-∞, b]`, the projection of `x` onto `(-∞, b]` using `Set.projIic` equals `x`.","distance":1.92715407942610728042609480326063930988311767578125}],["The theorem `Profinite.NobelingProof.continuous_proj` asserts that for any type `I`, any property `J` over `I`, and given that for each element `i` of type `I` it is decidable whether `J i` holds or not, the projection function `Profinite.NobelingProof.Proj J` that maps everything satisfying `J i` to itself and everything else to `false` is continuous. In mathematical terms, this essentially means that the projection function preserves the topological structure and does not disrupt the continuity of the underlying set.",{"type":"∀ {I : Type u} (J : I → Prop) [inst : (i : I) → Decidable (J i)], Continuous (Profinite.NobelingProof.Proj J)","name":"Profinite.NobelingProof.continuous_proj","isProp":true,"docString":"The theorem `Profinite.NobelingProof.continuous_proj` asserts that for any type `I`, any property `J` over `I`, and given that for each element `i` of type `I` it is decidable whether `J i` holds or not, the projection function `Profinite.NobelingProof.Proj J` that maps everything satisfying `J i` to itself and everything else to `false` is continuous. In mathematical terms, this essentially means that the projection function preserves the topological structure and does not disrupt the continuity of the underlying set.","distance":1.9440346455094117406048326301970519125461578369140625}],["`WithInitial.star` is initial. ",{"type":"{C : Type u} →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Limits.IsInitial CategoryTheory.WithInitial.star","name":"CategoryTheory.WithInitial.starInitial","isProp":false,"docString":"`WithInitial.star` is initial. ","distance":1.9272864833401797124423637797008268535137176513671875}],["If we multiply a positive solution with the inverse of a fundamental solution,\nthe `x`-coordinate stays positive. ",{"type":"∀ {d : ℤ} {a₁ : Pell.Solution₁ d},\n  Pell.IsFundamental a₁ →\n    ∀ {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → 0 < Pell.Solution₁.y a → 0 < Pell.Solution₁.x (a * a₁⁻¹)","name":"Pell.IsFundamental.mul_inv_x_pos","isProp":true,"docString":"If we multiply a positive solution with the inverse of a fundamental solution,\nthe `x`-coordinate stays positive. ","distance":1.9291504351353825352788362579303793609142303466796875}],["Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ",{"type":"(X : AlgebraicGeometry.Scheme) → AlgebraicGeometry.IsAffine X → AlgebraicGeometry.AffineScheme","name":"AlgebraicGeometry.AffineScheme.mk","isProp":false,"docString":"Construct an affine scheme from a scheme and the information that it is affine.\nAlso see `AffineScheme.of` for a typeclass version. ","distance":1.92919087638486441704799290164373815059661865234375}],["The constant functor sending everything to `PUnit.star`. ",{"type":"(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] → CategoryTheory.Functor C (CategoryTheory.Discrete PUnit.{w + 1})","name":"CategoryTheory.Functor.star","isProp":false,"docString":"The constant functor sending everything to `PUnit.star`. ","distance":1.930012661857864575409848839626647531986236572265625}],["`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n",{"type":"Type (u + 1)","name":"NonemptyType","isProp":false,"docString":"`NonemptyType.{u}` is the type of nonempty types in universe `u`.\nIt is mainly used in constant declarations where we wish to introduce a type\nand simultaneously assert that it is nonempty, but otherwise make the type\nopaque.\n","distance":1.930039039579869442064818940707482397556304931640625}],["Returns the projection information of a structure. ",{"type":"List Simps.ProjectionData → String → Lean.Name → Lean.MessageData","name":"Simps.projectionsInfo","isProp":false,"docString":"Returns the projection information of a structure. ","distance":1.9324898247188226907411490174126811325550079345703125}],["Given an order embedding into a well order, collapse the order embedding by filling the\ngaps, to obtain an initial segment. Here, we construct the collapsed order embedding pointwise,\nbut the proof of the fact that it is an initial segment will be given in `collapse`. ",{"type":"{α : Type u_1} →\n  {β : Type u_2} →\n    {r : α → α → Prop} → {s : β → β → Prop} → [inst : IsWellOrder β s] → (f : r ↪r s) → (a : α) → { b // ¬s (f a) b }","name":"RelEmbedding.collapseF","isProp":false,"docString":"Given an order embedding into a well order, collapse the order embedding by filling the\ngaps, to obtain an initial segment. Here, we construct the collapsed order embedding pointwise,\nbut the proof of the fact that it is an initial segment will be given in `collapse`. ","distance":1.9328422786001320243798318188055418431758880615234375}],["If we multiply a positive solution with the inverse of a fundamental solution,\nthe `y`-coordinate remains nonnegative. ",{"type":"∀ {d : ℤ} {a₁ : Pell.Solution₁ d},\n  Pell.IsFundamental a₁ →\n    ∀ {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → 0 < Pell.Solution₁.y a → 0 ≤ Pell.Solution₁.y (a * a₁⁻¹)","name":"Pell.IsFundamental.mul_inv_y_nonneg","isProp":true,"docString":"If we multiply a positive solution with the inverse of a fundamental solution,\nthe `y`-coordinate remains nonnegative. ","distance":1.93298073231990752418596457573585212230682373046875}],["`Matrix.SpecialLinearGroup n R` embeds into `GL_pos n R` ",{"type":"{n : Type u} →\n  [inst : DecidableEq n] →\n    [inst_1 : Fintype n] →\n      {R : Type v} → [inst_2 : LinearOrderedCommRing R] → Matrix.SpecialLinearGroup n R →* ↥(Matrix.GLPos n R)","name":"Matrix.SpecialLinearGroup.toGLPos","isProp":false,"docString":"`Matrix.SpecialLinearGroup n R` embeds into `GL_pos n R` ","distance":1.93380936124941626985673792660236358642578125}],["name for this projection used in the structure definition ",{"type":"Simps.ParsedProjectionData → Lean.Name","name":"Simps.ParsedProjectionData.strName","isProp":false,"docString":"name for this projection used in the structure definition ","distance":1.9345438653099107373378728880197741091251373291015625}],["Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ",{"type":"Lean.Name → Array Simps.ParsedProjectionData → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.findAutomaticProjections","isProp":false,"docString":"Auxiliary function for `getRawProjections`.\nFind custom projections, automatically found by simps.\nThese come from `DFunLike` and `SetLike` instances. ","distance":1.934950927235064455089741386473178863525390625}],["Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.",{"type":"Lean.Name → Lean.CoreM (Array Simps.ParsedProjectionData)","name":"Simps.mkParsedProjectionData","isProp":false,"docString":"Get the default `ParsedProjectionData` for structure `str`.\nIt first returns the direct fields of the structure in the right order, and then\nall (non-subobject fields) of all parent structures. The subobject fields are precisely the\nnon-default fields.","distance":1.9373905022409456666565574778360314667224884033203125}],["The constant function. If `a : α`, then `Function.const β a : β → α` is the\n\"constant function with value `a`\", that is, `Function.const β a b = a`.\n```\nexample (b : Bool) : Function.const Bool 10 b = 10 :=\n  rfl\n\n#check Function.const Bool 10\n-- Bool → Nat\n```\n",{"type":"{α : Sort u} → (β : Sort v) → α → β → α","name":"Function.const","isProp":false,"docString":"The constant function. If `a : α`, then `Function.const β a : β → α` is the\n\"constant function with value `a`\", that is, `Function.const β a b = a`.\n```\nexample (b : Bool) : Function.const Bool 10 b = 10 :=\n  rfl\n\n#check Function.const Bool 10\n-- Bool → Nat\n```\n","distance":1.9378581539038168823907426485675387084484100341796875}],["The universal set `Set.univ` in a preconnected space is a preconnected set. ",{"type":"∀ {α : Type u} [inst : TopologicalSpace α] [self : PreconnectedSpace α], IsPreconnected Set.univ","name":"PreconnectedSpace.isPreconnected_univ","isProp":true,"docString":"The universal set `Set.univ` in a preconnected space is a preconnected set. ","distance":1.9379632452358415140025726941530592739582061767578125}],["An induction principle for `Projectivization`.\nUse as `induction v using Projectivization.ind`. ",{"type":"∀ {K : Type u_1} {V : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  {P : Projectivization K V → Prop},\n  (∀ (v : V) (h : v ≠ 0), P (Projectivization.mk K v h)) → ∀ (p : Projectivization K V), P p","name":"Projectivization.ind","isProp":true,"docString":"An induction principle for `Projectivization`.\nUse as `induction v using Projectivization.ind`. ","distance":1.93844946527131067881555281928740441799163818359375}],["A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ",{"type":"{α : Type u_2} → (β : α → Type u_1) → (i : α) ×' β i ≃ (i : α) × β i","name":"Equiv.psigmaEquivSigma","isProp":false,"docString":"A `PSigma`-type is equivalent to the corresponding `Sigma`-type. ","distance":1.9398721896152706367644213969470001757144927978515625}],["If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ",{"type":"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → ∀ {x : E}, x ∈ interior s → ∀ (t : ℝ), 1 < t → closure s ⊆ interior (⇑(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. ","distance":1.9404114608239557693281085448688827455043792724609375}],["The order type of an element inside a well order. For the embedding as a principal segment, see\n`typein.principalSeg`. ",{"type":"{α : Type u} → (r : α → α → Prop) → [inst : IsWellOrder α r] → α → Ordinal.{u}","name":"Ordinal.typein","isProp":false,"docString":"The order type of an element inside a well order. For the embedding as a principal segment, see\n`typein.principalSeg`. ","distance":1.9414900565793276054904481497942470014095306396484375}]]