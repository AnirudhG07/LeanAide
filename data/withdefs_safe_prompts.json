[
  {
    "name": "set.add_zero_class",
    "statement": "def set.add_zero_class {α : Type u_2} [add_zero_class α] : add_zero_class (set α)",
    "theorem": "{α : Type u_2} [add_zero_class α] : add_zero_class (set α)",
    "args": "{α : Type u_2} [add_zero_class α]",
    "doc_string": "`set α` is an `add_zero_class` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_zero_class (set α)"
  },
  {
    "name": "nndist_triangle",
    "statement": "theorem nndist_triangle {α : Type u} [pseudo_metric_space α] (x y z : α) : has_nndist.nndist x z ≤ has_nndist.nndist x y + has_nndist.nndist y z",
    "theorem": "{α : Type u} [pseudo_metric_space α] (x y z : α) : has_nndist.nndist x z ≤ has_nndist.nndist x y + has_nndist.nndist y z",
    "args": "{α : Type u} [pseudo_metric_space α] (x y z : α)",
    "doc_string": "Triangle inequality for the nonnegative distance",
    "kind": "theorem",
    "type": "has_nndist.nndist x z ≤ has_nndist.nndist x y + has_nndist.nndist y z"
  },
  {
    "name": "emetric.Hausdorff_edist",
    "statement": "def emetric.Hausdorff_edist {α : Type u} [pseudo_emetric_space α] (s t : set α) : ennreal",
    "theorem": "{α : Type u} [pseudo_emetric_space α] (s t : set α) : ennreal",
    "args": "{α : Type u} [pseudo_emetric_space α] (s t : set α)",
    "doc_string": " The Hausdorff edistance between two sets is the smallest `r` such that each set is contained in the `r`-neighborhood of the other one",
    "kind": "def",
    "type": "ennreal"
  },
  {
    "name": "topological_group",
    "statement": "structure topological_group (G : Type u_1) [topological_space G] [group G] : Prop",
    "theorem": "(G : Type u_1) [topological_space G] [group G] : Prop",
    "args": "(G : Type u_1) [topological_space G] [group G]",
    "doc_string": " A topological group is a group in which the multiplication and inversion operations are continuous.  When you declare an instance that does not already have a `uniform_space` instance, you should also provide an instance of `uniform_space` and `uniform_group` using `topological_group.to_uniform_space` and `topological_group_is_uniform`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "partial_order",
    "statement": "structure partial_order (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A partial order is a reflexive, transitive, antisymmetric relation `≤`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "has_coe_t_aux",
    "statement": "structure has_coe_t_aux (a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))",
    "theorem": "(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))",
    "args": "(a : Sort u) (b : Sort v)",
    "doc_string": "Auxiliary transitive closure for `has_coe` which does not contain   instances such as `coe_option`.    They would produce non-termination when combined with `coe_fn_trans` and `coe_sort_trans`.",
    "kind": "structure",
    "type": "Sort (max 1 (imax u v))"
  },
  {
    "name": "measure_theory.filtration.const",
    "statement": "def measure_theory.filtration.const {α : Type u_1} (ι : Type u_3) {m : measurable_space α} [preorder ι] (m' : measurable_space α) (hm' : m' ≤ m) : measure_theory.filtration ι m",
    "theorem": "{α : Type u_1} (ι : Type u_3) {m : measurable_space α} [preorder ι] (m' : measurable_space α) (hm' : m' ≤ m) : measure_theory.filtration ι m",
    "args": "{α : Type u_1} (ι : Type u_3) {m : measurable_space α} [preorder ι] (m' : measurable_space α) (hm' : m' ≤ m)",
    "doc_string": "The constant filtration which is equal to `m` for all `i : ι`.",
    "kind": "def",
    "type": "measure_theory.filtration ι m"
  },
  {
    "name": "sub_lt_zero",
    "statement": "theorem sub_lt_zero {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 ↔ a < b",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 ↔ a < b",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of sub_neg`.",
    "kind": "theorem",
    "type": "a - b < 0 ↔ a < b"
  },
  {
    "name": "zero_lt.preorder.left.mul_le_one_of_le_of_le'",
    "statement": "theorem zero_lt.preorder.left.mul_le_one_of_le_of_le' {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b ≤ 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b ≤ 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "a * b ≤ 1"
  },
  {
    "name": "shelf_hom.comp",
    "statement": "def shelf_hom.comp {S₁ : Type u_1} {S₂ : Type u_2} {S₃ : Type u_3} [shelf S₁] [shelf S₂] [shelf S₃] (g : shelf_hom S₂ S₃) (f : shelf_hom S₁ S₂) : shelf_hom S₁ S₃",
    "theorem": "{S₁ : Type u_1} {S₂ : Type u_2} {S₃ : Type u_3} [shelf S₁] [shelf S₂] [shelf S₃] (g : shelf_hom S₂ S₃) (f : shelf_hom S₁ S₂) : shelf_hom S₁ S₃",
    "args": "{S₁ : Type u_1} {S₂ : Type u_2} {S₃ : Type u_3} [shelf S₁] [shelf S₂] [shelf S₃] (g : shelf_hom S₂ S₃) (f : shelf_hom S₁ S₂)",
    "doc_string": "The composition of shelf homomorphisms",
    "kind": "def",
    "type": "shelf_hom S₁ S₃"
  },
  {
    "name": "add_units.is_add_regular",
    "statement": "theorem add_units.is_add_regular {R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a",
    "theorem": "{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a",
    "args": "{R : Type u_1} [add_monoid R] (a : add_units R)",
    "doc_string": "If `R` is an additive monoid, an element in `add_units R` is add-regular.",
    "kind": "theorem",
    "type": "is_add_regular ↑a"
  },
  {
    "name": "unitization.has_coe_t",
    "statement": "def unitization.has_coe_t {R : Type u_1} {A : Type u_2} [has_zero R] : has_coe_t A (unitization R A)",
    "theorem": "{R : Type u_1} {A : Type u_2} [has_zero R] : has_coe_t A (unitization R A)",
    "args": "{R : Type u_1} {A : Type u_2} [has_zero R]",
    "doc_string": "The canonical inclusion `A → unitization R A`.",
    "kind": "def",
    "type": "has_coe_t A (unitization R A)"
  },
  {
    "name": "category_theory.limits.has_strict_initial_objects",
    "statement": "structure category_theory.limits.has_strict_initial_objects (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "We say `C` has strict initial objects if every initial object is strict, ie given any morphism `f : A ⟶ I` where `I` is initial, then `f` is an isomorphism.  Strictly speaking, this says that *any* initial object must be strict, rather than that strict initial objects exist.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "add_magma.free_add_semigroup.r",
    "statement": "inductive add_magma.free_add_semigroup.r (α : Type u) [has_add α] : α → α → Prop",
    "theorem": "(α : Type u) [has_add α] : α → α → Prop",
    "args": "(α : Type u) [has_add α]",
    "doc_string": "Associativity relations for an additive magma.",
    "kind": "inductive",
    "type": "α → α → Prop"
  },
  {
    "name": "module.to_mul_action_with_zero",
    "statement": "def module.to_mul_action_with_zero {R : Type u_2} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] : mul_action_with_zero R M",
    "theorem": "{R : Type u_2} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] : mul_action_with_zero R M",
    "args": "{R : Type u_2} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "A module over a semiring automatically inherits a `mul_action_with_zero` structure.",
    "kind": "def",
    "type": "mul_action_with_zero R M"
  },
  {
    "name": "environment",
    "statement": "constant environment  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "An __environment__ contains all of the declarations and notation that have been defined so far.",
    "kind": "constant",
    "type": "Type"
  },
  {
    "name": "order.ideal.prime_pair",
    "statement": "structure order.ideal.prime_pair (P : Type u_2) [preorder P] : Type u_2",
    "theorem": "(P : Type u_2) [preorder P] : Type u_2",
    "args": "(P : Type u_2) [preorder P]",
    "doc_string": "A pair of an `ideal` and a `pfilter` which form a partition of `P`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "ratfunc.mul",
    "statement": "def ratfunc.mul {K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K → ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K → ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K]",
    "doc_string": "Multiplication of rational functions.",
    "kind": "def",
    "type": "ratfunc K → ratfunc K → ratfunc K"
  },
  {
    "name": "filter.generate_sets",
    "statement": "inductive filter.generate_sets {α : Type u} (g : set (set α)) : set α → Prop",
    "theorem": "{α : Type u} (g : set (set α)) : set α → Prop",
    "args": "{α : Type u} (g : set (set α))",
    "doc_string": "`generate_sets g s`: `s` is in the filter closure of `g`.",
    "kind": "inductive",
    "type": "set α → Prop"
  },
  {
    "name": "tensor_algebra.tprod",
    "statement": "def tensor_algebra.tprod (R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (n : ℕ) : multilinear_map R (λ (i : fin n), M) (tensor_algebra R M)",
    "theorem": "(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (n : ℕ) : multilinear_map R (λ (i : fin n), M) (tensor_algebra R M)",
    "args": "(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (n : ℕ)",
    "doc_string": " Construct a product of `n` elements of the module within the tensor algebra.  See also `pi_tensor_product.tprod`.",
    "kind": "def",
    "type": "multilinear_map R (λ (i : fin n), M) (tensor_algebra R M)"
  },
  {
    "name": "tactic.eliminate.ih_name",
    "statement": "def tactic.eliminate.ih_name (arg_name : name) : name",
    "theorem": "(arg_name : name) : name",
    "args": "(arg_name : name)",
    "doc_string": "`ih_name arg_name` is the name `ih_<arg_name>`.",
    "kind": "def",
    "type": "name"
  },
  {
    "name": "fin_rotate",
    "statement": "def fin_rotate (n : ℕ) : equiv.perm (fin n)",
    "theorem": "(n : ℕ) : equiv.perm (fin n)",
    "args": "(n : ℕ)",
    "doc_string": "Rotate `fin n` one step to the right.",
    "kind": "def",
    "type": "equiv.perm (fin n)"
  },
  {
    "name": "exists_prime_add_order_of_dvd_card",
    "statement": "theorem exists_prime_add_order_of_dvd_card {G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), add_order_of x = p",
    "theorem": "{G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), add_order_of x = p",
    "args": "{G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G)",
    "doc_string": " For every prime `p` dividing the order of a finite additive group `G` there exists an element of order `p` in `G`. This is the additive version of Cauchy's theorem.",
    "kind": "theorem",
    "type": "∃ (x : G), add_order_of x = p"
  },
  {
    "name": "alist.extract",
    "statement": "def alist.extract {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : alist β) : option (β a) × alist β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : alist β) : option (β a) × alist β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : alist β)",
    "doc_string": "Erase a key from the map, and return the corresponding value, if found.",
    "kind": "def",
    "type": "option (β a) × alist β"
  },
  {
    "name": "cardinal.is_equivalent",
    "statement": "def cardinal.is_equivalent  : setoid (Type u)",
    "theorem": " : setoid (Type u)",
    "args": "",
    "doc_string": "The equivalence relation on types given by equivalence (bijective correspondence) of types.  Quotienting by this equivalence relation gives the cardinal numbers.",
    "kind": "def",
    "type": "setoid (Type u)"
  },
  {
    "name": "add_con_gen",
    "statement": "def add_con_gen {M : Type u_1} [has_add M] (r : M → M → Prop) : add_con M",
    "theorem": "{M : Type u_1} [has_add M] (r : M → M → Prop) : add_con M",
    "args": "{M : Type u_1} [has_add M] (r : M → M → Prop)",
    "doc_string": "The inductively defined smallest additive congruence relation containing a given binary relation.",
    "kind": "def",
    "type": "add_con M"
  },
  {
    "name": "io.random_series",
    "statement": "def io.random_series {α : Type} [random α] : io (stream α)",
    "theorem": "{α : Type} [random α] : io (stream α)",
    "args": "{α : Type} [random α]",
    "doc_string": "randomly generate an infinite series of value of type α",
    "kind": "def",
    "type": "io (stream α)"
  },
  {
    "name": "quiver.labelling",
    "statement": "def quiver.labelling (V : Type u) [quiver V] (L : Sort u_2) : Sort (imax (u+1) (u+1) u_1 u_2)",
    "theorem": "(V : Type u) [quiver V] (L : Sort u_2) : Sort (imax (u+1) (u+1) u_1 u_2)",
    "args": "(V : Type u) [quiver V] (L : Sort u_2)",
    "doc_string": "An `L`-labelling of a quiver assigns to every arrow an element of `L`.",
    "kind": "def",
    "type": "Sort (imax (u+1) (u+1) u_1 u_2)"
  },
  {
    "name": "ordnode.node4_l",
    "statement": "def ordnode.node4_l {α : Type u_1} : ordnode α → α → ordnode α → α → ordnode α → ordnode α",
    "theorem": "{α : Type u_1} : ordnode α → α → ordnode α → α → ordnode α → ordnode α",
    "args": "{α : Type u_1}",
    "doc_string": "Build a tree from three nodes, with `a () b -> (a ()) b` and `a (b c) d -> ((a b) (c d))`.",
    "kind": "def",
    "type": "ordnode α → α → ordnode α → α → ordnode α → ordnode α"
  },
  {
    "name": "topological_space.first_countable_topology",
    "statement": "structure topological_space.first_countable_topology (α : Type u) [t : topological_space α] : Prop",
    "theorem": "(α : Type u) [t : topological_space α] : Prop",
    "args": "(α : Type u) [t : topological_space α]",
    "doc_string": "A first-countable space is one in which every point has a  countable neighborhood basis.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordnode.of_list",
    "statement": "def ordnode.of_list {α : Type u} [has_le α] [decidable_rel has_le.le] (l : list α) : ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (l : list α) : ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (l : list α)",
    "doc_string": " O(n * log n). Build a set from a list, preferring elements that appear earlier in the list in the case of equivalent elements.      of_list [1, 2, 3] = {1, 2, 3}     of_list [2, 1, 1, 3] = {1, 2, 3}  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      of_list [(1, 1), (0, 1), (1, 2)] = {(0, 1), (1, 1)}",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "cardinal.lift",
    "statement": "def cardinal.lift (c : cardinal) : cardinal",
    "theorem": "(c : cardinal) : cardinal",
    "args": "(c : cardinal)",
    "doc_string": "The universe lift operation on cardinals. You can specify the universes explicitly with  `lift.{u v} : cardinal.{v} → cardinal.{max v u}`",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "classical.inhabited_of_nonempty'",
    "statement": "def classical.inhabited_of_nonempty' {α : Sort u_1} [h : nonempty α] : inhabited α",
    "theorem": "{α : Sort u_1} [h : nonempty α] : inhabited α",
    "args": "{α : Sort u_1} [h : nonempty α]",
    "doc_string": "Using `classical.choice`, lifts a (`Prop`-valued) `nonempty` instance to a (`Type`-valued)  `inhabited` instance. `classical.inhabited_of_nonempty` already exists, in  `core/init/classical.lean`, but the assumption is not a type class argument,  which makes it unsuitable for some applications.",
    "kind": "def",
    "type": "inhabited α"
  },
  {
    "name": "function_field.infty_valuation_def",
    "statement": "def function_field.infty_valuation_def (Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] (r : ratfunc Fq) : with_zero (multiplicative ℤ)",
    "theorem": "(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] (r : ratfunc Fq) : with_zero (multiplicative ℤ)",
    "args": "(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] (r : ratfunc Fq)",
    "doc_string": " The valuation at infinity is the nonarchimedean valuation on `Fq(t)` with uniformizer `1/t`. Explicitly, if `f/g ∈ Fq(t)` is a nonzero quotient of polynomials, its valuation at infinity is `multiplicative.of_add(degree(f) - degree(g))`.",
    "kind": "def",
    "type": "with_zero (multiplicative ℤ)"
  },
  {
    "name": "lt_add_of_sub_right_lt",
    "statement": "theorem lt_add_of_sub_right_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a - c < b → a < b + c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a - c < b → a < b + c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of sub_lt_iff_lt_add`.",
    "kind": "theorem",
    "type": "a - c < b → a < b + c"
  },
  {
    "name": "polynomial.card_pow_degree",
    "statement": "def polynomial.card_pow_degree {Fq : Type u_1} [field Fq] [fintype Fq] : absolute_value (polynomial Fq) ℤ",
    "theorem": "{Fq : Type u_1} [field Fq] [fintype Fq] : absolute_value (polynomial Fq) ℤ",
    "args": "{Fq : Type u_1} [field Fq] [fintype Fq]",
    "doc_string": " `card_pow_degree` is the absolute value on `𝔽_q[t]` sending `f` to `q ^ degree f`.  `card_pow_degree 0` is defined to be `0`.",
    "kind": "def",
    "type": "absolute_value (polynomial Fq) ℤ"
  },
  {
    "name": "mem_Icc_of_mem_std_simplex",
    "statement": "theorem mem_Icc_of_mem_std_simplex {R : Type u_1} {ι : Type u_4} [linear_ordered_field R] [fintype ι] {f : ι → R} (hf : f ∈ std_simplex R ι) (x : ι) : f x ∈ set.Icc 0 1",
    "theorem": "{R : Type u_1} {ι : Type u_4} [linear_ordered_field R] [fintype ι] {f : ι → R} (hf : f ∈ std_simplex R ι) (x : ι) : f x ∈ set.Icc 0 1",
    "args": "{R : Type u_1} {ι : Type u_4} [linear_ordered_field R] [fintype ι] {f : ι → R} (hf : f ∈ std_simplex R ι) (x : ι)",
    "doc_string": "All values of a function `f ∈ std_simplex 𝕜 ι` belong to `[0, 1]`.",
    "kind": "theorem",
    "type": "f x ∈ set.Icc 0 1"
  },
  {
    "name": "fractional_ideal",
    "statement": "def fractional_ideal {R : Type u_1} [comm_ring R] (S : submonoid R) (P : Type u_2) [comm_ring P] [algebra R P] : Type u_2",
    "theorem": "{R : Type u_1} [comm_ring R] (S : submonoid R) (P : Type u_2) [comm_ring P] [algebra R P] : Type u_2",
    "args": "{R : Type u_1} [comm_ring R] (S : submonoid R) (P : Type u_2) [comm_ring P] [algebra R P]",
    "doc_string": "The fractional ideals of a domain `R` are ideals of `R` divided by some `a ∈ R`.   More precisely, let `P` be a localization of `R` at some submonoid `S`,  then a fractional ideal `I ⊆ P` is an `R`-submodule of `P`,  such that there is a nonzero `a : R` with `a I ⊆ R`.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "category_theory.limits.has_limits_of_size",
    "statement": "structure category_theory.limits.has_limits_of_size (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`C` has all limits of size `v₁ u₁` (`has_limits_of_size.{v₁ u₁} C`) if it has limits of every shape `J : Type u₁` with `[category.{v₁} J]`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "totally_disconnected_space",
    "statement": "structure totally_disconnected_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A space is totally disconnected if all of its connected components are singletons.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "multiset.noncomm_sum",
    "statement": "def multiset.noncomm_sum {α : Type u_1} [add_monoid α] (s : multiset α) (comm : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → add_commute x y) : α",
    "theorem": "{α : Type u_1} [add_monoid α] (s : multiset α) (comm : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → add_commute x y) : α",
    "args": "{α : Type u_1} [add_monoid α] (s : multiset α) (comm : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → add_commute x y)",
    "doc_string": "Sum of a `s : multiset α` with `[add_monoid α]`, given a proof that `+` commutes on all elements `x ∈ s`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "equiv_like",
    "statement": "structure equiv_like (E : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3) (imax u_1 u_3 u_2))",
    "theorem": "(E : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3) (imax u_1 u_3 u_2))",
    "args": "(E : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (Sort u_3))",
    "doc_string": " The class `equiv_like E α β` expresses that terms of type `E` have an injective coercion to bijections between `α` and `β`.  This typeclass is used in the definition of the homomorphism typeclasses, such as `zero_equiv_class`, `mul_equiv_class`, `monoid_equiv_class`, ....",
    "kind": "structure",
    "type": "Sort (max 1 (imax u_1 u_2 u_3) (imax u_1 u_3 u_2))"
  },
  {
    "name": "finset.pi",
    "statement": "def finset.pi {α : Type u_1} {δ : α → Type u_2} [decidable_eq α] (s : finset α) (t : Π (a : α), finset (δ a)) : finset (Π (a : α), a ∈ s → δ a)",
    "theorem": "{α : Type u_1} {δ : α → Type u_2} [decidable_eq α] (s : finset α) (t : Π (a : α), finset (δ a)) : finset (Π (a : α), a ∈ s → δ a)",
    "args": "{α : Type u_1} {δ : α → Type u_2} [decidable_eq α] (s : finset α) (t : Π (a : α), finset (δ a))",
    "doc_string": " Given a finset `s` of `α` and for all `a : α` a finset `t a` of `δ a`, then one can define the finset `s.pi t` of all functions defined on elements of `s` taking values in `t a` for `a ∈ s`. Note that the elements of `s.pi t` are only partially defined, on `s`.",
    "kind": "def",
    "type": "finset (Π (a : α), a ∈ s → δ a)"
  },
  {
    "name": "wseq.filter",
    "statement": "def wseq.filter {α : Type u} (p : α → Prop) [decidable_pred p] : wseq α → wseq α",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] : wseq α → wseq α",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p]",
    "doc_string": "Select the elements of `s` that satisfy `p`.",
    "kind": "def",
    "type": "wseq α → wseq α"
  },
  {
    "name": "pred_order.of_le_pred_iff",
    "statement": "def pred_order.of_le_pred_iff {α : Type u_1} [linear_order α] (pred : α → α) (hle_pred_iff : ∀ {a b : α}, a ≤ pred b ↔ a < b) : pred_order α",
    "theorem": "{α : Type u_1} [linear_order α] (pred : α → α) (hle_pred_iff : ∀ {a b : α}, a ≤ pred b ↔ a < b) : pred_order α",
    "args": "{α : Type u_1} [linear_order α] (pred : α → α) (hle_pred_iff : ∀ {a b : α}, a ≤ pred b ↔ a < b)",
    "doc_string": "A constructor for `pred_order α` usable when `α` is a linear order with no minimal element.",
    "kind": "def",
    "type": "pred_order α"
  },
  {
    "name": "option.guard",
    "statement": "def option.guard {α : Type u_1} (p : α → Prop) [decidable_pred p] (a : α) : option α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (a : α) : option α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (a : α)",
    "doc_string": "`guard p a` returns `some a` if `p a` holds, otherwise `none`.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "free_lie_algebra.rel",
    "statement": "inductive free_lie_algebra.rel (R : Type u) (X : Type v) [comm_ring R] : free_non_unital_non_assoc_algebra R X → free_non_unital_non_assoc_algebra R X → Prop",
    "theorem": "(R : Type u) (X : Type v) [comm_ring R] : free_non_unital_non_assoc_algebra R X → free_non_unital_non_assoc_algebra R X → Prop",
    "args": "(R : Type u) (X : Type v) [comm_ring R]",
    "doc_string": " The quotient of `lib R X` by the equivalence relation generated by this relation will give us the free Lie algebra.",
    "kind": "inductive",
    "type": "free_non_unital_non_assoc_algebra R X → free_non_unital_non_assoc_algebra R X → Prop"
  },
  {
    "name": "pi.has_continuous_neg'",
    "statement": "def pi.has_continuous_neg' {G : Type w} [topological_space G] [has_neg G] [has_continuous_neg G] {ι : Type u_1} : has_continuous_neg (ι → G)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_continuous_neg G] {ι : Type u_1} : has_continuous_neg (ι → G)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_continuous_neg G] {ι : Type u_1}",
    "doc_string": "A version of `pi.has_continuous_neg` for non-dependent functions. It is needed because sometimes Lean fails to use `pi.has_continuous_neg` for non-dependent functions.",
    "kind": "def",
    "type": "has_continuous_neg (ι → G)"
  },
  {
    "name": "fin2.remap_left",
    "statement": "def fin2.remap_left {m n : ℕ} (f : fin2 m → fin2 n) (k : ℕ) : fin2 (m + k) → fin2 (n + k)",
    "theorem": "{m n : ℕ} (f : fin2 m → fin2 n) (k : ℕ) : fin2 (m + k) → fin2 (n + k)",
    "args": "{m n : ℕ} (f : fin2 m → fin2 n) (k : ℕ)",
    "doc_string": "`remap_left f k : fin2 (m + k) → fin2 (n + k)` applies the function  `f : fin2 m → fin2 n` to inputs less than `m`, and leaves the right part  on the right (that is, `remap_left f k (m + i) = n + i`).",
    "kind": "def",
    "type": "fin2 (m + k) → fin2 (n + k)"
  },
  {
    "name": "continuous.fst'",
    "statement": "theorem continuous.fst' {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → γ} (hf : continuous f) : continuous (λ (x : α × β), f x.fst)",
    "theorem": "{α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → γ} (hf : continuous f) : continuous (λ (x : α × β), f x.fst)",
    "args": "{α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : α → γ} (hf : continuous f)",
    "doc_string": "Precomposing `f` with `prod.fst` is continuous",
    "kind": "theorem",
    "type": "continuous (λ (x : α × β), f x.fst)"
  },
  {
    "name": "linear_ordered_comm_group_with_zero.directed_lt",
    "statement": "theorem linear_ordered_comm_group_with_zero.directed_lt (Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀})",
    "theorem": "(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀})",
    "args": "(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀]",
    "doc_string": " The neighbourhoods {γ | γ < γ₀} of 0 form a directed set indexed by the invertible elements γ₀.",
    "kind": "theorem",
    "type": "directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀})"
  },
  {
    "name": "power_series.inv.aux",
    "statement": "def power_series.inv.aux {R : Type u_1} [ring R] : R → power_series R → power_series R",
    "theorem": "{R : Type u_1} [ring R] : R → power_series R → power_series R",
    "args": "{R : Type u_1} [ring R]",
    "doc_string": "Auxiliary function used for computing inverse of a power series",
    "kind": "def",
    "type": "R → power_series R → power_series R"
  },
  {
    "name": "computation.run",
    "statement": "def computation.run {α : Type u} : computation α → α",
    "theorem": "{α : Type u} : computation α → α",
    "args": "{α : Type u}",
    "doc_string": "`run c` is an unsound meta function that runs `c` to completion, possibly  resulting in an infinite loop in the VM.",
    "kind": "def",
    "type": "computation α → α"
  },
  {
    "name": "category_theory.closed",
    "statement": "structure category_theory.closed {C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C)",
    "doc_string": "An object `X` is (right) closed if `(X ⊗ -)` is a left adjoint.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "surreal.pow_half",
    "statement": "def surreal.pow_half (n : ℕ) : surreal",
    "theorem": "(n : ℕ) : surreal",
    "args": "(n : ℕ)",
    "doc_string": "Powers of the surreal number `half`.",
    "kind": "def",
    "type": "surreal"
  },
  {
    "name": "left_mul",
    "statement": "def left_mul {G : Type u_1} [has_mul G] : G → G → G",
    "theorem": "{G : Type u_1} [has_mul G] : G → G → G",
    "args": "{G : Type u_1} [has_mul G]",
    "doc_string": "`left_mul g` denotes left multiplication by `g`",
    "kind": "def",
    "type": "G → G → G"
  },
  {
    "name": "bitvec.add",
    "statement": "def bitvec.add {n : ℕ} (x y : bitvec n) : bitvec n",
    "theorem": "{n : ℕ} (x y : bitvec n) : bitvec n",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "The sum of two bitvectors",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "holor.mul",
    "statement": "def holor.mul {α : Type} {ds₁ ds₂ : list ℕ} [s : has_mul α] (x : holor α ds₁) (y : holor α ds₂) : holor α (ds₁ ++ ds₂)",
    "theorem": "{α : Type} {ds₁ ds₂ : list ℕ} [s : has_mul α] (x : holor α ds₁) (y : holor α ds₂) : holor α (ds₁ ++ ds₂)",
    "args": "{α : Type} {ds₁ ds₂ : list ℕ} [s : has_mul α] (x : holor α ds₁) (y : holor α ds₂)",
    "doc_string": "The tensor product of two holors.",
    "kind": "def",
    "type": "holor α (ds₁ ++ ds₂)"
  },
  {
    "name": "invertible.copy",
    "statement": "def invertible.copy {α : Type u} [monoid α] {r : α} (hr : invertible r) (s : α) (hs : s = r) : invertible s",
    "theorem": "{α : Type u} [monoid α] {r : α} (hr : invertible r) (s : α) (hs : s = r) : invertible s",
    "args": "{α : Type u} [monoid α] {r : α} (hr : invertible r) (s : α) (hs : s = r)",
    "doc_string": "If `r` is invertible and `s = r`, then `s` is invertible.",
    "kind": "def",
    "type": "invertible s"
  },
  {
    "name": "zmod.legendre_sym_eq_zero_iff",
    "statement": "theorem zmod.legendre_sym_eq_zero_iff (p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = 0 ↔ ↑a = 0",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = 0 ↔ ↑a = 0",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ)",
    "doc_string": "The Legendre symbol of `p` and `a` is zero iff `p ∣ a`.",
    "kind": "theorem",
    "type": "zmod.legendre_sym p a = 0 ↔ ↑a = 0"
  },
  {
    "name": "order_bot",
    "statement": "structure order_bot (α : Type u) [has_le α] : Type u",
    "theorem": "(α : Type u) [has_le α] : Type u",
    "args": "(α : Type u) [has_le α]",
    "doc_string": " An order is an `order_bot` if it has a least element. We state this using a data mixin, holding the value of `⊥` and the least element constraint.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "computation.run_for",
    "statement": "def computation.run_for {α : Type u} : computation α → ℕ → option α",
    "theorem": "{α : Type u} : computation α → ℕ → option α",
    "args": "{α : Type u}",
    "doc_string": "`run_for c n` evaluates `c` for `n` steps and returns the result, or `none`  if it did not terminate after `n` steps.",
    "kind": "def",
    "type": "computation α → ℕ → option α"
  },
  {
    "name": "comm_semiring",
    "statement": "structure comm_semiring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a type with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative commutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law (`mul_zero_class`).",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "inf_top_hom.to_top_hom",
    "statement": "def inf_top_hom.to_top_hom {α : Type u_3} {β : Type u_4} [has_inf α] [has_top α] [has_inf β] [has_top β] (f : inf_top_hom α β) : top_hom α β",
    "theorem": "{α : Type u_3} {β : Type u_4} [has_inf α] [has_top α] [has_inf β] [has_top β] (f : inf_top_hom α β) : top_hom α β",
    "args": "{α : Type u_3} {β : Type u_4} [has_inf α] [has_top α] [has_inf β] [has_top β] (f : inf_top_hom α β)",
    "doc_string": "Reinterpret an `inf_top_hom` as a `top_hom`.",
    "kind": "def",
    "type": "top_hom α β"
  },
  {
    "name": "simple_graph.inc_matrix",
    "statement": "def simple_graph.inc_matrix (R : Type u_1) {α : Type u_2} (G : simple_graph α) [has_zero R] [has_one R] : matrix α (sym2 α) R",
    "theorem": "(R : Type u_1) {α : Type u_2} (G : simple_graph α) [has_zero R] [has_one R] : matrix α (sym2 α) R",
    "args": "(R : Type u_1) {α : Type u_2} (G : simple_graph α) [has_zero R] [has_one R]",
    "doc_string": " `G.inc_matrix R` is the `α × sym2 α` matrix whose `(a, e)`-entry is `1` if `e` is incident to `a` and `0` otherwise.",
    "kind": "def",
    "type": "matrix α (sym2 α) R"
  },
  {
    "name": "function_field",
    "statement": "def function_field (Fq F : Type) [field Fq] [field F] [algebra (ratfunc Fq) F] : Prop",
    "theorem": "(Fq F : Type) [field Fq] [field F] [algebra (ratfunc Fq) F] : Prop",
    "args": "(Fq F : Type) [field Fq] [field F] [algebra (ratfunc Fq) F]",
    "doc_string": " `F` is a function field over the finite field `Fq` if it is a finite extension of the field of rational functions in one variable over `Fq`.  Note that `F` can be a function field over multiple, non-isomorphic, `Fq`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "metric.Hausdorff_dist_nonneg",
    "statement": "theorem metric.Hausdorff_dist_nonneg {α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α}",
    "doc_string": "The Hausdorff distance is nonnegative",
    "kind": "theorem",
    "type": "0 ≤ metric.Hausdorff_dist s t"
  },
  {
    "name": "subfield.list_sum_mem",
    "statement": "theorem subfield.list_sum_mem {K : Type u} [field K] (s : subfield K) {l : list K} : (∀ (x : K), x ∈ l → x ∈ s) → l.sum ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) {l : list K} : (∀ (x : K), x ∈ l → x ∈ s) → l.sum ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K) {l : list K}",
    "doc_string": "Sum of a list of elements in a subfield is in the subfield.",
    "kind": "theorem",
    "type": "(∀ (x : K), x ∈ l → x ∈ s) → l.sum ∈ s"
  },
  {
    "name": "is_total",
    "statement": "structure is_total (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": " `is_total X r` means that the binary relation `r` on `X` is total, that is, that for any `x y : X` we have `r x y` or `r y x`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_regular_iff_ne_zero",
    "statement": "theorem is_regular_iff_ne_zero {R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a ↔ a ≠ 0",
    "theorem": "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a ↔ a ≠ 0",
    "args": "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R]",
    "doc_string": "In a non-trivial integral domain, an element is regular iff it is non-zero.",
    "kind": "theorem",
    "type": "is_regular a ↔ a ≠ 0"
  },
  {
    "name": "add_subgroup.has_bot",
    "statement": "def add_subgroup.has_bot {G : Type u_1} [add_group G] : has_bot (add_subgroup G)",
    "theorem": "{G : Type u_1} [add_group G] : has_bot (add_subgroup G)",
    "args": "{G : Type u_1} [add_group G]",
    "doc_string": "The trivial `add_subgroup` `{0}` of an `add_group` `G`.",
    "kind": "def",
    "type": "has_bot (add_subgroup G)"
  },
  {
    "name": "fish",
    "statement": "def fish {m : Type u_1 → Type u_2} [monad m] {α : Sort u_3} {β γ : Type u_1} (f : α → m β) (g : β → m γ) (x : α) : m γ",
    "theorem": "{m : Type u_1 → Type u_2} [monad m] {α : Sort u_3} {β γ : Type u_1} (f : α → m β) (g : β → m γ) (x : α) : m γ",
    "args": "{m : Type u_1 → Type u_2} [monad m] {α : Sort u_3} {β γ : Type u_1} (f : α → m β) (g : β → m γ) (x : α)",
    "doc_string": "This is the Kleisli composition",
    "kind": "def",
    "type": "m γ"
  },
  {
    "name": "free_comm_ring.of",
    "statement": "def free_comm_ring.of {α : Type u} (x : α) : free_comm_ring α",
    "theorem": "{α : Type u} (x : α) : free_comm_ring α",
    "args": "{α : Type u} (x : α)",
    "doc_string": "The canonical map from `α` to the free commutative ring on `α`.",
    "kind": "def",
    "type": "free_comm_ring α"
  },
  {
    "name": "bitvec.cong",
    "statement": "def bitvec.cong {a b : ℕ} (h : a = b) : bitvec a → bitvec b",
    "theorem": "{a b : ℕ} (h : a = b) : bitvec a → bitvec b",
    "args": "{a b : ℕ} (h : a = b)",
    "doc_string": "Create a bitvector from another with a provably equal length.",
    "kind": "def",
    "type": "bitvec a → bitvec b"
  },
  {
    "name": "module.ray",
    "statement": "def module.ray (R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type u_2",
    "theorem": "(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type u_2",
    "args": "(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M]",
    "doc_string": "A ray (equivalence class of nonzero vectors with common positive multiples) in a module.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "finset.sum",
    "statement": "def finset.sum {β : Type u} {α : Type v} [add_comm_monoid β] (s : finset α) (f : α → β) : β",
    "theorem": "{β : Type u} {α : Type v} [add_comm_monoid β] (s : finset α) (f : α → β) : β",
    "args": "{β : Type u} {α : Type v} [add_comm_monoid β] (s : finset α) (f : α → β)",
    "doc_string": "`∑ x in s, f x` is the sum of `f x` as `x` ranges over the elements of the finite set `s`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "combinatorics.line",
    "statement": "structure combinatorics.line (α : Type u_1) (ι : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (ι : Type u_2) : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (ι : Type u_2)",
    "doc_string": " The type of combinatorial lines. A line `l : line α ι` in the hypercube `ι → α` defines a function `α → ι → α` from `α` to the hypercube, such that for each coordinate `i : ι`, the function `λ x, l x i` is either `id` or constant. We require lines to be nontrivial in the sense that `λ x, l x i` is `id` for at least one `i`.  Formally, a line is represented by the function `l.idx_fun : ι → option α` which says whether `λ x, l x i` is `id` (corresponding to `l.idx_fun i = none`) or constantly `y` (corresponding to `l.idx_fun i = some y`).  When `α` has size `1` there can be many elements of `line α ι` defining the same function.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "subsemigroup.prod",
    "statement": "def subsemigroup.prod {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (s : subsemigroup M) (t : subsemigroup N) : subsemigroup (M × N)",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (s : subsemigroup M) (t : subsemigroup N) : subsemigroup (M × N)",
    "args": "{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (s : subsemigroup M) (t : subsemigroup N)",
    "doc_string": " Given `subsemigroup`s `s`, `t` of semigroups `M`, `N` respectively, `s × t` as a subsemigroup of `M × N`.",
    "kind": "def",
    "type": "subsemigroup (M × N)"
  },
  {
    "name": "bitraversable",
    "statement": "structure bitraversable (t : Type u → Type u → Type u) : Type (u+1)",
    "theorem": "(t : Type u → Type u → Type u) : Type (u+1)",
    "args": "(t : Type u → Type u → Type u)",
    "doc_string": "Lawless bitraversable bifunctor. This only holds data for the bimap and bitraverse.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "list.permutations_aux2",
    "statement": "def list.permutations_aux2 {α : Type u_1} {β : Type u_2} (t : α) (ts : list α) (r : list β) : list α → (list α → β) → list α × list β",
    "theorem": "{α : Type u_1} {β : Type u_2} (t : α) (ts : list α) (r : list β) : list α → (list α → β) → list α × list β",
    "args": "{α : Type u_1} {β : Type u_2} (t : α) (ts : list α) (r : list β)",
    "doc_string": " An auxiliary function for defining `permutations`. `permutations_aux2 t ts r ys f` is equal to `(ys ++ ts, (insert_left ys t ts).map f ++ r)`, where `insert_left ys t ts` (not explicitly defined) is the list of lists of the form `insert_nth n t (ys ++ ts)` for `0 ≤ n < length ys`.      permutations_aux2 10 [4, 5, 6] [] [1, 2, 3] id =       ([1, 2, 3, 4, 5, 6],        [[10, 1, 2, 3, 4, 5, 6],         [1, 10, 2, 3, 4, 5, 6],         [1, 2, 10, 3, 4, 5, 6]])",
    "kind": "def",
    "type": "list α → (list α → β) → list α × list β"
  },
  {
    "name": "PartialOrder.of",
    "statement": "def PartialOrder.of (α : Type u_1) [partial_order α] : PartialOrder",
    "theorem": "(α : Type u_1) [partial_order α] : PartialOrder",
    "args": "(α : Type u_1) [partial_order α]",
    "doc_string": "Construct a bundled PartialOrder from the underlying type and typeclass.",
    "kind": "def",
    "type": "PartialOrder"
  },
  {
    "name": "matrix.transpose",
    "statement": "def matrix.transpose {m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) : matrix n m α",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) : matrix n m α",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α)",
    "doc_string": "The transpose of a matrix.",
    "kind": "def",
    "type": "matrix n m α"
  },
  {
    "name": "uniform_continuous₂",
    "statement": "def uniform_continuous₂ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [uniform_space α] [uniform_space β] [uniform_space γ] (f : α → β → γ) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [uniform_space α] [uniform_space β] [uniform_space γ] (f : α → β → γ) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [uniform_space α] [uniform_space β] [uniform_space γ] (f : α → β → γ)",
    "doc_string": "Uniform continuity for functions of two variables.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "filter.add_zero_class",
    "statement": "def filter.add_zero_class {α : Type u_2} [add_zero_class α] : add_zero_class (filter α)",
    "theorem": "{α : Type u_2} [add_zero_class α] : add_zero_class (filter α)",
    "args": "{α : Type u_2} [add_zero_class α]",
    "doc_string": "`filter α` is an `add_zero_class` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_zero_class (filter α)"
  },
  {
    "name": "hahn_series.single",
    "statement": "def hahn_series.single {Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] (a : Γ) : zero_hom R (hahn_series Γ R)",
    "theorem": "{Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] (a : Γ) : zero_hom R (hahn_series Γ R)",
    "args": "{Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] (a : Γ)",
    "doc_string": "`single a r` is the Hahn series which has coefficient `r` at `a` and zero otherwise.",
    "kind": "def",
    "type": "zero_hom R (hahn_series Γ R)"
  },
  {
    "name": "weak_dual.character_space",
    "statement": "def weak_dual.character_space (𝕜 : Type u_1) (A : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [non_unital_non_assoc_semiring A] [topological_space A] [module 𝕜 A] : set (weak_dual 𝕜 A)",
    "theorem": "(𝕜 : Type u_1) (A : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [non_unital_non_assoc_semiring A] [topological_space A] [module 𝕜 A] : set (weak_dual 𝕜 A)",
    "args": "(𝕜 : Type u_1) (A : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [non_unital_non_assoc_semiring A] [topological_space A] [module 𝕜 A]",
    "doc_string": " The character space of a topological algebra is the subset of elements of the weak dual that are also algebra homomorphisms.",
    "kind": "def",
    "type": "set (weak_dual 𝕜 A)"
  },
  {
    "name": "list.prod",
    "statement": "def list.prod {α : Type u_1} [has_mul α] [has_one α] : list α → α",
    "theorem": "{α : Type u_1} [has_mul α] [has_one α] : list α → α",
    "args": "{α : Type u_1} [has_mul α] [has_one α]",
    "doc_string": "Product of a list.      prod [a, b, c] = ((1 * a) * b) * c",
    "kind": "def",
    "type": "list α → α"
  },
  {
    "name": "tactic.ring.normalize_mode",
    "statement": "inductive tactic.ring.normalize_mode  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " If `ring` fails to close the goal, it falls back on normalizing the expression to a \"pretty\" form so that you can see why it failed. This setting adjusts the resulting form:    * `raw` is the form that `ring` actually uses internally, with iterated applications of `horner`.     Not very readable but useful if you don't want any postprocessing.     This results in terms like `horner (horner (horner 3 y 1 0) x 2 1) x 1 (horner 1 y 1 0)`.   * `horner` maintains the Horner form structure, but it unfolds the `horner` definition itself,     and tries to otherwise minimize parentheses.     This results in terms like `(3 * x ^ 2 * y + 1) * x + y`.   * `SOP` means sum of products form, expanding everything to monomials.     This results in terms like `3 * x ^ 3 * y + x + y`.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "category_theory.limits.has_wide_coequalizers",
    "statement": "def category_theory.limits.has_wide_coequalizers (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_wide_coequalizers` represents a choice of wide coequalizer for every family of morphisms",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ennreal.coe_sub",
    "statement": "theorem ennreal.coe_sub {r p : nnreal} : ↑(r - p) = ↑r - ↑p",
    "theorem": "{r p : nnreal} : ↑(r - p) = ↑r - ↑p",
    "args": "{r p : nnreal}",
    "doc_string": "This is a special case of `with_top.coe_sub` in the `ennreal` namespace",
    "kind": "theorem",
    "type": "↑(r - p) = ↑r - ↑p"
  },
  {
    "name": "descending_central_series_ge_lower",
    "statement": "theorem descending_central_series_ge_lower {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n",
    "theorem": "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n",
    "args": "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ)",
    "doc_string": "Any descending central series for a group is bounded below by the lower central series.",
    "kind": "theorem",
    "type": "lower_central_series G n ≤ H n"
  },
  {
    "name": "submodule.comm_semiring",
    "statement": "def submodule.comm_semiring {R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : comm_semiring (submodule R A)",
    "theorem": "{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : comm_semiring (submodule R A)",
    "args": "{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A]",
    "doc_string": "Sub-R-modules of an R-algebra A form a semiring.",
    "kind": "def",
    "type": "comm_semiring (submodule R A)"
  },
  {
    "name": "preorder.lift",
    "statement": "def preorder.lift {α : Type u_1} {β : Type u_2} [preorder β] (f : α → β) : preorder α",
    "theorem": "{α : Type u_1} {β : Type u_2} [preorder β] (f : α → β) : preorder α",
    "args": "{α : Type u_1} {β : Type u_2} [preorder β] (f : α → β)",
    "doc_string": " Transfer a `preorder` on `β` to a `preorder` on `α` using a function `f : α → β`. See note [reducible non-instances].",
    "kind": "def",
    "type": "preorder α"
  },
  {
    "name": "regular_expression.map",
    "statement": "def regular_expression.map {α : Type u_1} {β : Type u_2} (f : α → β) : regular_expression α → regular_expression β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) : regular_expression α → regular_expression β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β)",
    "doc_string": "Map the alphabet of a regular expression.",
    "kind": "def",
    "type": "regular_expression α → regular_expression β"
  },
  {
    "name": "monotone_on",
    "statement": "def monotone_on {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α)",
    "doc_string": "A function `f` is monotone on `s` if, for all `a, b ∈ s`, `a ≤ b` implies `f a ≤ f b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "con.submonoid",
    "statement": "def con.submonoid (M : Type u_1) [mul_one_class M] (c : con M) : submonoid (M × M)",
    "theorem": "(M : Type u_1) [mul_one_class M] (c : con M) : submonoid (M × M)",
    "args": "(M : Type u_1) [mul_one_class M] (c : con M)",
    "doc_string": "The submonoid of `M × M` defined by a congruence relation on a monoid `M`.",
    "kind": "def",
    "type": "submonoid (M × M)"
  },
  {
    "name": "lie_ring_module",
    "statement": "structure lie_ring_module (L : Type v) (M : Type w) [lie_ring L] [add_comm_group M] : Type (max v w)",
    "theorem": "(L : Type v) (M : Type w) [lie_ring L] [add_comm_group M] : Type (max v w)",
    "args": "(L : Type v) (M : Type w) [lie_ring L] [add_comm_group M]",
    "doc_string": " A Lie ring module is an additive group, together with an additive action of a Lie ring on this group, such that the Lie bracket acts as the commutator of endomorphisms. (For representations of Lie *algebras* see `lie_module`.)",
    "kind": "structure",
    "type": "Type (max v w)"
  },
  {
    "name": "denumerable.raise'_finset",
    "statement": "def denumerable.raise'_finset (l : list ℕ) (n : ℕ) : finset ℕ",
    "theorem": "(l : list ℕ) (n : ℕ) : finset ℕ",
    "args": "(l : list ℕ) (n : ℕ)",
    "doc_string": "Makes `raise' l n` into a finset. Elements are distinct thanks to `raise'_sorted`.",
    "kind": "def",
    "type": "finset ℕ"
  },
  {
    "name": "antitone.ne_of_lt_of_lt_int",
    "statement": "theorem antitone.ne_of_lt_of_lt_int {α : Type u} [preorder α] {f : ℤ → α} (hf : antitone f) (n : ℤ) {x : α} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℤ) : f a ≠ x",
    "theorem": "{α : Type u} [preorder α] {f : ℤ → α} (hf : antitone f) (n : ℤ) {x : α} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℤ) : f a ≠ x",
    "args": "{α : Type u} [preorder α] {f : ℤ → α} (hf : antitone f) (n : ℤ) {x : α} (h1 : f (n + 1) < x) (h2 : x < f n) (a : ℤ)",
    "doc_string": " If `f` is an antitone function from `ℤ` to a preorder and `x` lies between `f (n + 1)` and `f n`, then `x` doesn't lie in the range of `f`.",
    "kind": "theorem",
    "type": "f a ≠ x"
  },
  {
    "name": "semi_normed_ring.to_non_unital_semi_normed_ring",
    "statement": "def semi_normed_ring.to_non_unital_semi_normed_ring {α : Type u_1} [β : semi_normed_ring α] : non_unital_semi_normed_ring α",
    "theorem": "{α : Type u_1} [β : semi_normed_ring α] : non_unital_semi_normed_ring α",
    "args": "{α : Type u_1} [β : semi_normed_ring α]",
    "doc_string": "A seminormed ring is a non-unital seminormed ring.",
    "kind": "def",
    "type": "non_unital_semi_normed_ring α"
  },
  {
    "name": "measurable_of_tendsto_ennreal",
    "statement": "theorem measurable_of_tendsto_ennreal {α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g",
    "theorem": "{α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g",
    "args": "{α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g))",
    "doc_string": "A sequential limit of measurable `ℝ≥0∞` valued functions is measurable.",
    "kind": "theorem",
    "type": "measurable g"
  },
  {
    "name": "category_theory.limits.bicone.is_bilimit",
    "statement": "structure category_theory.limits.bicone.is_bilimit {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F) : Type (max u v)",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F) : Type (max u v)",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F)",
    "doc_string": "Structure witnessing that a bicone is both a limit cone and a colimit cocone.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "filter.join",
    "statement": "def filter.join {α : Type u} (f : filter (filter α)) : filter α",
    "theorem": "{α : Type u} (f : filter (filter α)) : filter α",
    "args": "{α : Type u} (f : filter (filter α))",
    "doc_string": "The join of a filter of filters is defined by the relation `s ∈ join f ↔ {t | s ∈ t} ∈ f`.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "char_p_zero_or_prime_power",
    "statement": "theorem char_p_zero_or_prime_power (R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q] : q = 0 ∨ is_prime_pow q",
    "theorem": "(R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q] : q = 0 ∨ is_prime_pow q",
    "args": "(R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q]",
    "doc_string": "In a local ring the characteristics is either zero or a prime power.",
    "kind": "theorem",
    "type": "q = 0 ∨ is_prime_pow q"
  },
  {
    "name": "polynomial.is_separable_contraction",
    "statement": "def polynomial.is_separable_contraction {F : Type} [comm_semiring F] (q : ℕ) (f g : polynomial F) : Prop",
    "theorem": "{F : Type} [comm_semiring F] (q : ℕ) (f g : polynomial F) : Prop",
    "args": "{F : Type} [comm_semiring F] (q : ℕ) (f g : polynomial F)",
    "doc_string": " A separable contraction of a polynomial `f` is a separable polynomial `g` such that `g(x^(q^m)) = f(x)` for some `m : ℕ`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "SemilatticeInf",
    "statement": "structure SemilatticeInf  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of inf-semilattices with a top element.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "computation.corec",
    "statement": "def computation.corec {α : Type u} {β : Type v} (f : β → α ⊕ β) (b : β) : computation α",
    "theorem": "{α : Type u} {β : Type v} (f : β → α ⊕ β) (b : β) : computation α",
    "args": "{α : Type u} {β : Type v} (f : β → α ⊕ β) (b : β)",
    "doc_string": "`corec f b` is the corecursor for `computation α` as a coinductive type.  If `f b = inl a` then `corec f b = return a`, and if `f b = inl b'` then  `corec f b = think (corec f b')`.",
    "kind": "def",
    "type": "computation α"
  },
  {
    "name": "computation.empty",
    "statement": "def computation.empty (α : Type u_1) : computation α",
    "theorem": "(α : Type u_1) : computation α",
    "args": "(α : Type u_1)",
    "doc_string": "`empty α` is the computation that never returns, an infinite sequence of  `think`s.",
    "kind": "def",
    "type": "computation α"
  },
  {
    "name": "add_subgroup.characteristic",
    "statement": "structure add_subgroup.characteristic {A : Type u_2} [add_group A] (H : add_subgroup A) : Prop",
    "theorem": "{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop",
    "args": "{A : Type u_2} [add_group A] (H : add_subgroup A)",
    "doc_string": "A add_subgroup is characteristic if it is fixed by all automorphisms.  Several equivalent conditions are provided by lemmas of the form `characteristic.iff...`",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordered_smul",
    "statement": "structure ordered_smul (R : Type u_1) (M : Type u_2) [ordered_semiring R] [ordered_add_comm_monoid M] [smul_with_zero R M] : Prop",
    "theorem": "(R : Type u_1) (M : Type u_2) [ordered_semiring R] [ordered_add_comm_monoid M] [smul_with_zero R M] : Prop",
    "args": "(R : Type u_1) (M : Type u_2) [ordered_semiring R] [ordered_add_comm_monoid M] [smul_with_zero R M]",
    "doc_string": "The ordered scalar product property is when an ordered additive commutative monoid with a partial order has a scalar multiplication which is compatible with the order.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "list.prev",
    "statement": "def list.prev {α : Type u_1} [decidable_eq α] (l : list α) (x : α) (h : x ∈ l) : α",
    "theorem": "{α : Type u_1} [decidable_eq α] (l : list α) (x : α) (h : x ∈ l) : α",
    "args": "{α : Type u_1} [decidable_eq α] (l : list α) (x : α) (h : x ∈ l)",
    "doc_string": "Given an element `x : α` of `l : list α` such that `x ∈ l`, get the previous element of `l`. This works from head to tail, (including a check for last element) so it will match on first hit, ignoring later duplicates.   * `prev [1, 2, 3] 2 _ = 1`  * `prev [1, 2, 3] 1 _ = 3`  * `prev [1, 2, 3, 2, 4] 2 _ = 1`  * `prev [1, 2, 3, 4, 2] 2 _ = 1`  * `prev [1, 1, 2] 1 _ = 2`",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "right_add",
    "statement": "def right_add {G : Type u_1} [has_add G] : G → G → G",
    "theorem": "{G : Type u_1} [has_add G] : G → G → G",
    "args": "{G : Type u_1} [has_add G]",
    "doc_string": "`right_add g` denotes right addition by `g`",
    "kind": "def",
    "type": "G → G → G"
  },
  {
    "name": "typevec.repeat",
    "statement": "def typevec.repeat (n : ℕ) (t : Type u_1) : typevec n",
    "theorem": "(n : ℕ) (t : Type u_1) : typevec n",
    "args": "(n : ℕ) (t : Type u_1)",
    "doc_string": "`repeat n t` is a `n-length` type vector that contains `n` occurences of `t`",
    "kind": "def",
    "type": "typevec n"
  },
  {
    "name": "subgroup.inv_mem",
    "statement": "theorem subgroup.inv_mem {G : Type u_1} [group G] (H : subgroup G) {x : G} : x ∈ H → x⁻¹ ∈ H",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) {x : G} : x ∈ H → x⁻¹ ∈ H",
    "args": "{G : Type u_1} [group G] (H : subgroup G) {x : G}",
    "doc_string": "A subgroup is closed under inverse.",
    "kind": "theorem",
    "type": "x ∈ H → x⁻¹ ∈ H"
  },
  {
    "name": "cardinal.is_regular",
    "statement": "def cardinal.is_regular (c : cardinal) : Prop",
    "theorem": "(c : cardinal) : Prop",
    "args": "(c : cardinal)",
    "doc_string": "A cardinal is regular if it is infinite and it equals its own cofinality.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "linarith.global_preprocessor",
    "statement": "structure linarith.global_preprocessor  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Some preprocessors need to examine the full list of hypotheses instead of working item by item. As with `preprocessor`, the input to a `global_preprocessor` is replaced by, not added to, its output.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "category_theory.limits.has_strong_epi_images",
    "statement": "structure category_theory.limits.has_strong_epi_images (C : Type u) [category_theory.category C] [category_theory.limits.has_images C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_images C] : Prop",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_images C]",
    "doc_string": "A category has strong epi images if it has all images and `factor_thru_image f` is a strong    epimorphism for all `f`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "closure_operator.simps.apply",
    "statement": "def closure_operator.simps.apply (α : Type u_1) [preorder α] (f : closure_operator α) : α → α",
    "theorem": "(α : Type u_1) [preorder α] (f : closure_operator α) : α → α",
    "args": "(α : Type u_1) [preorder α] (f : closure_operator α)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "α → α"
  },
  {
    "name": "add_con.add_submonoid",
    "statement": "def add_con.add_submonoid (M : Type u_1) [add_zero_class M] (c : add_con M) : add_submonoid (M × M)",
    "theorem": "(M : Type u_1) [add_zero_class M] (c : add_con M) : add_submonoid (M × M)",
    "args": "(M : Type u_1) [add_zero_class M] (c : add_con M)",
    "doc_string": "The `add_submonoid` of `M × M` defined by an additive congruence relation on an `add_monoid` `M`.",
    "kind": "def",
    "type": "add_submonoid (M × M)"
  },
  {
    "name": "free_algebra.pre",
    "statement": "inductive free_algebra.pre (R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)",
    "args": "(R : Type u_1) [comm_semiring R] (X : Type u_2)",
    "doc_string": "This inductive type is used to express representatives of the free algebra.",
    "kind": "inductive",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "add_subsemigroup.gi",
    "statement": "def add_subsemigroup.gi (M : Type u_1) [has_add M] : galois_insertion add_subsemigroup.closure coe",
    "theorem": "(M : Type u_1) [has_add M] : galois_insertion add_subsemigroup.closure coe",
    "args": "(M : Type u_1) [has_add M]",
    "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
    "kind": "def",
    "type": "galois_insertion add_subsemigroup.closure coe"
  },
  {
    "name": "real.sq_cos_pi_div_six",
    "statement": "theorem real.sq_cos_pi_div_six  : real.cos (real.pi / 6) ^ 2 = 3 / 4",
    "theorem": " : real.cos (real.pi / 6) ^ 2 = 3 / 4",
    "args": "",
    "doc_string": " The square of the cosine of `π / 6` is `3 / 4` (this is sometimes more convenient than the result for cosine itself).",
    "kind": "theorem",
    "type": "real.cos (real.pi / 6) ^ 2 = 3 / 4"
  },
  {
    "name": "subgroup.has_bot",
    "statement": "def subgroup.has_bot {G : Type u_1} [group G] : has_bot (subgroup G)",
    "theorem": "{G : Type u_1} [group G] : has_bot (subgroup G)",
    "args": "{G : Type u_1} [group G]",
    "doc_string": "The trivial subgroup `{1}` of an group `G`.",
    "kind": "def",
    "type": "has_bot (subgroup G)"
  },
  {
    "name": "add_subgroup.closure",
    "statement": "def add_subgroup.closure {G : Type u_1} [add_group G] (k : set G) : add_subgroup G",
    "theorem": "{G : Type u_1} [add_group G] (k : set G) : add_subgroup G",
    "args": "{G : Type u_1} [add_group G] (k : set G)",
    "doc_string": "The `add_subgroup` generated by a set",
    "kind": "def",
    "type": "add_subgroup G"
  },
  {
    "name": "algebraic_geometry.SheafedSpace.punit",
    "statement": "def algebraic_geometry.SheafedSpace.punit (X : Top) : algebraic_geometry.SheafedSpace (category_theory.discrete punit)",
    "theorem": "(X : Top) : algebraic_geometry.SheafedSpace (category_theory.discrete punit)",
    "args": "(X : Top)",
    "doc_string": "The trivial `punit` valued sheaf on any topological space.",
    "kind": "def",
    "type": "algebraic_geometry.SheafedSpace (category_theory.discrete punit)"
  },
  {
    "name": "derivation.has_bracket",
    "statement": "def derivation.has_bracket {R : Type u_1} [comm_ring R] {A : Type u_2} [comm_ring A] [algebra R A] : has_bracket (derivation R A A) (derivation R A A)",
    "theorem": "{R : Type u_1} [comm_ring R] {A : Type u_2} [comm_ring A] [algebra R A] : has_bracket (derivation R A A) (derivation R A A)",
    "args": "{R : Type u_1} [comm_ring R] {A : Type u_2} [comm_ring A] [algebra R A]",
    "doc_string": "The commutator of derivations is again a derivation.",
    "kind": "def",
    "type": "has_bracket (derivation R A A) (derivation R A A)"
  },
  {
    "name": "list.minimum",
    "statement": "def list.minimum {α : Type u_1} [preorder α] [decidable_rel has_lt.lt] (l : list α) : with_top α",
    "theorem": "{α : Type u_1} [preorder α] [decidable_rel has_lt.lt] (l : list α) : with_top α",
    "args": "{α : Type u_1} [preorder α] [decidable_rel has_lt.lt] (l : list α)",
    "doc_string": " `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for `[]`",
    "kind": "def",
    "type": "with_top α"
  },
  {
    "name": "parser.sat",
    "statement": "def parser.sat (p : char → Prop) [decidable_pred p] : parser char",
    "theorem": "(p : char → Prop) [decidable_pred p] : parser char",
    "args": "(p : char → Prop) [decidable_pred p]",
    "doc_string": "Matches a single character satisfying the given predicate.",
    "kind": "def",
    "type": "parser char"
  },
  {
    "name": "zero_lt.pos_mul_reflect_lt",
    "statement": "def zero_lt.pos_mul_reflect_lt (X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop",
    "theorem": "(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop",
    "args": "(X : Type u) [has_mul X] [has_zero X] [has_lt X]",
    "doc_string": "  `zero_lt.pos_mul_reflect_lt α` is an abbreviation for `contravariant_class α>0 α (λ x y, x * y) (<)`, expressing that multiplication by positive elements on the left is strictly reverse monotone.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ring_quot",
    "statement": "structure ring_quot {R : Type u₁} [semiring R] (r : R → R → Prop) : Type u₁",
    "theorem": "{R : Type u₁} [semiring R] (r : R → R → Prop) : Type u₁",
    "args": "{R : Type u₁} [semiring R] (r : R → R → Prop)",
    "doc_string": "The quotient of a ring by an arbitrary relation.",
    "kind": "structure",
    "type": "Type u₁"
  },
  {
    "name": "associates.out",
    "statement": "def associates.out {α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] : associates α → α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] : associates α → α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α]",
    "doc_string": "Maps an element of `associates` back to the normalized element of its associate class",
    "kind": "def",
    "type": "associates α → α"
  },
  {
    "name": "mul_zero_one_class",
    "statement": "structure mul_zero_one_class (M₀ : Type u_4) : Type u_4",
    "theorem": "(M₀ : Type u_4) : Type u_4",
    "args": "(M₀ : Type u_4)",
    "doc_string": "A typeclass for non-associative monoids with zero elements.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "category_theory.yoneda.yoneda_faithful",
    "statement": "def category_theory.yoneda.yoneda_faithful {C : Type u₁} [category_theory.category C] : category_theory.faithful category_theory.yoneda",
    "theorem": "{C : Type u₁} [category_theory.category C] : category_theory.faithful category_theory.yoneda",
    "args": "{C : Type u₁} [category_theory.category C]",
    "doc_string": "The Yoneda embedding is faithful.  See <https://stacks.math.columbia.edu/tag/001P>.",
    "kind": "def",
    "type": "category_theory.faithful category_theory.yoneda"
  },
  {
    "name": "polynomial.has_separable_contraction.degree",
    "statement": "def polynomial.has_separable_contraction.degree {F : Type} [comm_semiring F] {q : ℕ} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : ℕ",
    "theorem": "{F : Type} [comm_semiring F] {q : ℕ} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : ℕ",
    "args": "{F : Type} [comm_semiring F] {q : ℕ} {f : polynomial F} (hf : polynomial.has_separable_contraction q f)",
    "doc_string": "The separable degree of a polynomial is the degree of a given separable contraction.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "PartialFun",
    "statement": "def PartialFun  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of types equipped with partial functions.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "lower_adjoint.id",
    "statement": "def lower_adjoint.id (α : Type u_1) [preorder α] : lower_adjoint id",
    "theorem": "(α : Type u_1) [preorder α] : lower_adjoint id",
    "args": "(α : Type u_1) [preorder α]",
    "doc_string": "The identity function as a lower adjoint to itself.",
    "kind": "def",
    "type": "lower_adjoint id"
  },
  {
    "name": "category_theory.Groupoid",
    "statement": "def category_theory.Groupoid  : Type (max (u+1) u (v+1))",
    "theorem": " : Type (max (u+1) u (v+1))",
    "args": "",
    "doc_string": "Category of groupoids",
    "kind": "def",
    "type": "Type (max (u+1) u (v+1))"
  },
  {
    "name": "function.injective2.left",
    "statement": "theorem function.injective2.left {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β) : function.injective (λ (a : α), f a b)",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β) : function.injective (λ (a : α), f a b)",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β)",
    "doc_string": "A binary injective function is injective when only the left argument varies.",
    "kind": "theorem",
    "type": "function.injective (λ (a : α), f a b)"
  },
  {
    "name": "function.is_periodic_pt_zero",
    "statement": "theorem function.is_periodic_pt_zero {α : Type u_1} (f : α → α) (x : α) : function.is_periodic_pt f 0 x",
    "theorem": "{α : Type u_1} (f : α → α) (x : α) : function.is_periodic_pt f 0 x",
    "args": "{α : Type u_1} (f : α → α) (x : α)",
    "doc_string": "Any point is a periodic point of period `0`.",
    "kind": "theorem",
    "type": "function.is_periodic_pt f 0 x"
  },
  {
    "name": "list.kunion",
    "statement": "def list.kunion {α : Type u} {β : α → Type v} [decidable_eq α] : list (sigma β) → list (sigma β) → list (sigma β)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] : list (sigma β) → list (sigma β) → list (sigma β)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α]",
    "doc_string": " `kunion l₁ l₂` is the append to l₁ of l₂ after, for each key in l₁, the first matching pair in l₂ is erased.",
    "kind": "def",
    "type": "list (sigma β) → list (sigma β) → list (sigma β)"
  },
  {
    "name": "finmap.erase",
    "statement": "def finmap.erase {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β) : finmap β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β) : finmap β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β)",
    "doc_string": "Erase a key from the map. If the key is not present it does nothing.",
    "kind": "def",
    "type": "finmap β"
  },
  {
    "name": "category_theory.projective_presentation",
    "statement": "structure category_theory.projective_presentation {C : Type u} [category_theory.category C] (X : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] (X : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] (X : C)",
    "doc_string": "A projective presentation of an object `X` consists of an epimorphism `f : P ⟶ X` from some projective object `P`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "ordnode.to_rev_list",
    "statement": "def ordnode.to_rev_list {α : Type u} (t : ordnode α) : list α",
    "theorem": "{α : Type u} (t : ordnode α) : list α",
    "args": "{α : Type u} (t : ordnode α)",
    "doc_string": "O(n). Build a list of elements in descending order from the tree.      to_rev_list {1, 2, 4} = [4, 2, 1]     to_rev_list {2, 1, 1, 4} = [4, 2, 1]",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "parser.eof",
    "statement": "def parser.eof  : parser unit",
    "theorem": " : parser unit",
    "args": "",
    "doc_string": "Matches the end of the input.",
    "kind": "def",
    "type": "parser unit"
  },
  {
    "name": "intermediate_field.copy",
    "statement": "def intermediate_field.copy {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (s : set L) (hs : s = ↑S) : intermediate_field K L",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (s : set L) (hs : s = ↑S) : intermediate_field K L",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) (s : set L) (hs : s = ↑S)",
    "doc_string": " Copy of an intermediate field with a new `carrier` equal to the old one. Useful to fix definitional equalities.",
    "kind": "def",
    "type": "intermediate_field K L"
  },
  {
    "name": "typevec.curry",
    "statement": "def typevec.curry {n : ℕ} (F : typevec (n + 1) → Type u_1) (α : Type u) (β : typevec n) : Type u_1",
    "theorem": "{n : ℕ} (F : typevec (n + 1) → Type u_1) (α : Type u) (β : typevec n) : Type u_1",
    "args": "{n : ℕ} (F : typevec (n + 1) → Type u_1) (α : Type u) (β : typevec n)",
    "doc_string": " given `F : typevec.{u} (n+1) → Type u`, `curry F : Type u → typevec.{u} → Type u`, i.e. its first argument can be fed in separately from the rest of the vector of arguments",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "is_add_right_regular",
    "statement": "def is_add_right_regular {R : Type u_1} [has_add R] (c : R) : Prop",
    "theorem": "{R : Type u_1} [has_add R] (c : R) : Prop",
    "args": "{R : Type u_1} [has_add R] (c : R)",
    "doc_string": "An add-right-regular element is an element `c` such that addition on the right by `c` is injective.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "semigroup_with_zero",
    "statement": "structure semigroup_with_zero (S₀ : Type u_4) : Type u_4",
    "theorem": "(S₀ : Type u_4) : Type u_4",
    "args": "(S₀ : Type u_4)",
    "doc_string": " A type `S₀` is a \"semigroup with zero” if it is a semigroup with zero element, and `0` is left and right absorbing.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "functor.supp",
    "statement": "def functor.supp {F : Type u → Type u} [functor F] {α : Type u} (x : F α) : set α",
    "theorem": "{F : Type u → Type u} [functor F] {α : Type u} (x : F α) : set α",
    "args": "{F : Type u → Type u} [functor F] {α : Type u} (x : F α)",
    "doc_string": " If we consider `x : F α` to, in some sense, contain values of type `α`, then `supp x` is the set of values of type `α` that `x` contains.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "cstar_ring.to_normed_star_group",
    "statement": "def cstar_ring.to_normed_star_group {E : Type u_2} [non_unital_normed_ring E] [star_ring E] [cstar_ring E] : normed_star_group E",
    "theorem": "{E : Type u_2} [non_unital_normed_ring E] [star_ring E] [cstar_ring E] : normed_star_group E",
    "args": "{E : Type u_2} [non_unital_normed_ring E] [star_ring E] [cstar_ring E]",
    "doc_string": "In a C*-ring, star preserves the norm.",
    "kind": "def",
    "type": "normed_star_group E"
  },
  {
    "name": "isometry_emetric_iff_metric",
    "statement": "theorem isometry_emetric_iff_metric {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} : isometry f ↔ ∀ (x y : α), has_dist.dist (f x) (f y) = has_dist.dist x y",
    "theorem": "{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} : isometry f ↔ ∀ (x y : α), has_dist.dist (f x) (f y) = has_dist.dist x y",
    "args": "{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β}",
    "doc_string": "On pseudometric spaces, a map is an isometry if and only if it preserves distances.",
    "kind": "theorem",
    "type": "isometry f ↔ ∀ (x y : α), has_dist.dist (f x) (f y) = has_dist.dist x y"
  },
  {
    "name": "function.injective.exists_ne",
    "statement": "theorem function.injective.exists_ne {α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β) : ∃ (x : α), f x ≠ y",
    "theorem": "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β) : ∃ (x : α), f x ≠ y",
    "args": "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β)",
    "doc_string": " An injective function from a nontrivial type has an argument at which it does not take a given value.",
    "kind": "theorem",
    "type": "∃ (x : α), f x ≠ y"
  },
  {
    "name": "tactic.squeeze_loc_attr_carrier",
    "statement": "def tactic.squeeze_loc_attr_carrier  : unit",
    "theorem": " : unit",
    "args": "",
    "doc_string": "dummy declaration used as target of `squeeze_loc` attribute",
    "kind": "def",
    "type": "unit"
  },
  {
    "name": "is_scalar_tower.invertible_algebra_coe_nat",
    "statement": "def is_scalar_tower.invertible_algebra_coe_nat (R : Type u) (A : Type w) [comm_semiring R] [semiring A] [algebra R A] (n : ℕ) [inv : invertible ↑n] : invertible ↑n",
    "theorem": "(R : Type u) (A : Type w) [comm_semiring R] [semiring A] [algebra R A] (n : ℕ) [inv : invertible ↑n] : invertible ↑n",
    "args": "(R : Type u) (A : Type w) [comm_semiring R] [semiring A] [algebra R A] (n : ℕ) [inv : invertible ↑n]",
    "doc_string": " A natural number that is invertible when coerced to `R` is also invertible when coerced to any `R`-algebra.",
    "kind": "def",
    "type": "invertible ↑n"
  },
  {
    "name": "nat.central_binom",
    "statement": "def nat.central_binom (n : ℕ) : ℕ",
    "theorem": "(n : ℕ) : ℕ",
    "args": "(n : ℕ)",
    "doc_string": "The central binomial coefficient, `nat.choose (2 * n) n`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "composition_series.snoc",
    "statement": "def composition_series.snoc {X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) (x : X) (hsat : jordan_holder_lattice.is_maximal s.top x) : composition_series X",
    "theorem": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) (x : X) (hsat : jordan_holder_lattice.is_maximal s.top x) : composition_series X",
    "args": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) (x : X) (hsat : jordan_holder_lattice.is_maximal s.top x)",
    "doc_string": "Add an element to the top of a `composition_series`",
    "kind": "def",
    "type": "composition_series X"
  },
  {
    "name": "ordnode.drop_aux",
    "statement": "def ordnode.drop_aux {α : Type u} : ordnode α → ℕ → ordnode α",
    "theorem": "{α : Type u} : ordnode α → ℕ → ordnode α",
    "args": "{α : Type u}",
    "doc_string": " Auxiliary definition for `drop`. (Can also be used in lieu of `drop` if you know the index is within the range of the data structure.)      drop_aux {a, b, c, d} 2 = {c, d}     drop_aux {a, b, c, d} 5 = ∅",
    "kind": "def",
    "type": "ordnode α → ℕ → ordnode α"
  },
  {
    "name": "comm_group_with_zero_of_is_unit_or_eq_zero",
    "statement": "def comm_group_with_zero_of_is_unit_or_eq_zero {M : Type u_5} [nontrivial M] [hM : comm_monoid_with_zero M] (h : ∀ (a : M), is_unit a ∨ a = 0) : comm_group_with_zero M",
    "theorem": "{M : Type u_5} [nontrivial M] [hM : comm_monoid_with_zero M] (h : ∀ (a : M), is_unit a ∨ a = 0) : comm_group_with_zero M",
    "args": "{M : Type u_5} [nontrivial M] [hM : comm_monoid_with_zero M] (h : ∀ (a : M), is_unit a ∨ a = 0)",
    "doc_string": "Constructs a `comm_group_with_zero` structure on a `comm_monoid_with_zero`  consisting only of units and 0.",
    "kind": "def",
    "type": "comm_group_with_zero M"
  },
  {
    "name": "multiples.is_add_submonoid",
    "statement": "theorem multiples.is_add_submonoid {M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)",
    "theorem": "{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)",
    "args": "{M : Type u_1} [add_monoid M] (x : M)",
    "doc_string": "The set of natural number multiples of an element of an `add_monoid` `M` is an `add_submonoid` of `M`.",
    "kind": "theorem",
    "type": "is_add_submonoid (multiples x)"
  },
  {
    "name": "opens_measurable_space",
    "statement": "structure opens_measurable_space (α : Type u_6) [topological_space α] [h : measurable_space α] : Prop",
    "theorem": "(α : Type u_6) [topological_space α] [h : measurable_space α] : Prop",
    "args": "(α : Type u_6) [topological_space α] [h : measurable_space α]",
    "doc_string": " A space with `measurable_space` and `topological_space` structures such that all open sets are measurable.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "algebraic_geometry.LocallyRingedSpace.to_RingedSpace",
    "statement": "def algebraic_geometry.LocallyRingedSpace.to_RingedSpace (X : algebraic_geometry.LocallyRingedSpace) : algebraic_geometry.RingedSpace",
    "theorem": "(X : algebraic_geometry.LocallyRingedSpace) : algebraic_geometry.RingedSpace",
    "args": "(X : algebraic_geometry.LocallyRingedSpace)",
    "doc_string": "An alias for `to_SheafedSpace`, where the result type is a `RingedSpace`. This allows us to use dot-notation for the `RingedSpace` namespace.",
    "kind": "def",
    "type": "algebraic_geometry.RingedSpace"
  },
  {
    "name": "nat.ppred",
    "statement": "def nat.ppred  : ℕ → option ℕ",
    "theorem": " : ℕ → option ℕ",
    "args": "",
    "doc_string": "Partial predecessor operation. Returns `ppred n = some m`  if `n = m + 1`, otherwise `none`.",
    "kind": "def",
    "type": "ℕ → option ℕ"
  },
  {
    "name": "is_open_map.to_quotient_map",
    "statement": "theorem is_open_map.to_quotient_map {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f)",
    "doc_string": "A continuous surjective open map is a quotient map.",
    "kind": "theorem",
    "type": "quotient_map f"
  },
  {
    "name": "subalgebra",
    "statement": "structure subalgebra (R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : Type v",
    "theorem": "(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : Type v",
    "args": "(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A]",
    "doc_string": "A subalgebra is a sub(semi)ring that includes the range of `algebra_map`.",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "category_theory.single_obj.groupoid",
    "statement": "def category_theory.single_obj.groupoid (α : Type u) [group α] : category_theory.groupoid (category_theory.single_obj α)",
    "theorem": "(α : Type u) [group α] : category_theory.groupoid (category_theory.single_obj α)",
    "args": "(α : Type u) [group α]",
    "doc_string": "Groupoid structure on `single_obj α`.  See <https://stacks.math.columbia.edu/tag/0019>.",
    "kind": "def",
    "type": "category_theory.groupoid (category_theory.single_obj α)"
  },
  {
    "name": "subsemigroup.mul_mem",
    "statement": "theorem subsemigroup.mul_mem {M : Type u_1} [has_mul M] (S : subsemigroup M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S",
    "theorem": "{M : Type u_1} [has_mul M] (S : subsemigroup M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S",
    "args": "{M : Type u_1} [has_mul M] (S : subsemigroup M) {x y : M}",
    "doc_string": "A subsemigroup is closed under multiplication.",
    "kind": "theorem",
    "type": "x ∈ S → y ∈ S → x * y ∈ S"
  },
  {
    "name": "int.cast",
    "statement": "def int.cast {α : Type u_1} [has_zero α] [has_one α] [has_add α] [has_neg α] : ℤ → α",
    "theorem": "{α : Type u_1} [has_zero α] [has_one α] [has_add α] [has_neg α] : ℤ → α",
    "args": "{α : Type u_1} [has_zero α] [has_one α] [has_add α] [has_neg α]",
    "doc_string": "Canonical homomorphism from the integers to any ring(-like) structure `α`",
    "kind": "def",
    "type": "ℤ → α"
  },
  {
    "name": "mvpfunctor.obj",
    "statement": "def mvpfunctor.obj {n : ℕ} (P : mvpfunctor n) (α : typevec n) : Type u",
    "theorem": "{n : ℕ} (P : mvpfunctor n) (α : typevec n) : Type u",
    "args": "{n : ℕ} (P : mvpfunctor n) (α : typevec n)",
    "doc_string": "Applying `P` to an object of `Type`",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "principal_seg.of_element",
    "statement": "def principal_seg.of_element {α : Type u_1} (r : α → α → Prop) (a : α) : principal_seg (subrel r {b : α | r b a}) r",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (a : α) : principal_seg (subrel r {b : α | r b a}) r",
    "args": "{α : Type u_1} (r : α → α → Prop) (a : α)",
    "doc_string": "Any element of a well order yields a principal segment",
    "kind": "def",
    "type": "principal_seg (subrel r {b : α | r b a}) r"
  },
  {
    "name": "computability.decode_bool",
    "statement": "def computability.decode_bool  : list bool → bool",
    "theorem": " : list bool → bool",
    "args": "",
    "doc_string": "A decoding function from `list bool` to bool.",
    "kind": "def",
    "type": "list bool → bool"
  },
  {
    "name": "enat.some",
    "statement": "def enat.some  : ℕ → enat",
    "theorem": " : ℕ → enat",
    "args": "",
    "doc_string": " The computable embedding `ℕ → enat`.  This coincides with the coercion `coe : ℕ → enat`, see `enat.some_eq_coe`. However, `coe` is noncomputable so `some` is preferable when computability is a concern.",
    "kind": "def",
    "type": "ℕ → enat"
  },
  {
    "name": "cardinal.ord_card_unbounded'",
    "statement": "theorem cardinal.ord_card_unbounded'  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}",
    "theorem": " : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}",
    "args": "",
    "doc_string": "Infinite ordinals that are cardinals are unbounded.",
    "kind": "theorem",
    "type": "set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}"
  },
  {
    "name": "localization.ring_topology",
    "statement": "def localization.ring_topology {R : Type u_1} [comm_ring R] [topological_space R] {M : submonoid R} : ring_topology (localization M)",
    "theorem": "{R : Type u_1} [comm_ring R] [topological_space R] {M : submonoid R} : ring_topology (localization M)",
    "args": "{R : Type u_1} [comm_ring R] [topological_space R] {M : submonoid R}",
    "doc_string": " The ring topology on `localization M` coinduced from the natural homomorphism sending `x : R` to the equivalence class of `(x, 1)`.",
    "kind": "def",
    "type": "ring_topology (localization M)"
  },
  {
    "name": "one_hom",
    "statement": "structure one_hom (M : Type u_9) (N : Type u_10) [has_one M] [has_one N] : Type (max u_10 u_9)",
    "theorem": "(M : Type u_9) (N : Type u_10) [has_one M] [has_one N] : Type (max u_10 u_9)",
    "args": "(M : Type u_9) (N : Type u_10) [has_one M] [has_one N]",
    "doc_string": " `one_hom M N` is the type of functions `M → N` that preserve one.  When possible, instead of parametrizing results over `(f : one_hom M N)`, you should parametrize over `(F : Type*) [one_hom_class F M N] (f : F)`.  When you extend this structure, make sure to also extend `one_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_10 u_9)"
  },
  {
    "name": "polynomial.cyclotomic_irreducible_of_irreducible_pow",
    "statement": "theorem polynomial.cyclotomic_irreducible_of_irreducible_pow {p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ℕ} (hn : n ≠ 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)",
    "theorem": "{p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ℕ} (hn : n ≠ 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)",
    "args": "{p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ℕ} (hn : n ≠ 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R))",
    "doc_string": "If `irreducible (cyclotomic (p ^ n) R)` then `irreducible (cyclotomic p R).`",
    "kind": "theorem",
    "type": "irreducible (polynomial.cyclotomic p R)"
  },
  {
    "name": "category_theory.is_preconnected",
    "statement": "structure category_theory.is_preconnected (J : Type u₁) [category_theory.category J] : Prop",
    "theorem": "(J : Type u₁) [category_theory.category J] : Prop",
    "args": "(J : Type u₁) [category_theory.category J]",
    "doc_string": "A possibly empty category for which every functor to a discrete category is constant.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nat.arithmetic_function.id",
    "statement": "def nat.arithmetic_function.id  : nat.arithmetic_function ℕ",
    "theorem": " : nat.arithmetic_function ℕ",
    "args": "",
    "doc_string": "The identity on `ℕ` as an `arithmetic_function`.",
    "kind": "def",
    "type": "nat.arithmetic_function ℕ"
  },
  {
    "name": "finmap.insert",
    "statement": "def finmap.insert {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : finmap β) : finmap β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : finmap β) : finmap β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : finmap β)",
    "doc_string": "Insert a key-value pair into a finite map, replacing any existing pair with  the same key.",
    "kind": "def",
    "type": "finmap β"
  },
  {
    "name": "fin2.insert_perm",
    "statement": "def fin2.insert_perm {n : ℕ} : fin2 n → fin2 n → fin2 n",
    "theorem": "{n : ℕ} : fin2 n → fin2 n → fin2 n",
    "args": "{n : ℕ}",
    "doc_string": "`insert_perm a` is a permutation of `fin2 n` with the following properties:  * `insert_perm a i = i+1` if `i < a`  * `insert_perm a a = 0`  * `insert_perm a i = i` if `i > a`",
    "kind": "def",
    "type": "fin2 n → fin2 n → fin2 n"
  },
  {
    "name": "lie_algebra.is_nilpotent",
    "statement": "def lie_algebra.is_nilpotent (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": " We say a Lie algebra is nilpotent when it is nilpotent as a Lie module over itself via the adjoint representation.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.of_digits_lt_base_pow_length'",
    "statement": "theorem nat.of_digits_lt_base_pow_length' {b : ℕ} {l : list ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length",
    "theorem": "{b : ℕ} {l : list ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length",
    "args": "{b : ℕ} {l : list ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2)",
    "doc_string": "an n-digit number in base b + 2 is less than (b + 2)^n",
    "kind": "theorem",
    "type": "nat.of_digits (b + 2) l < (b + 2) ^ l.length"
  },
  {
    "name": "lucas_lehmer.s",
    "statement": "def lucas_lehmer.s  : ℕ → ℤ",
    "theorem": " : ℕ → ℤ",
    "args": "",
    "doc_string": "The recurrence `s (i+1) = (s i)^2 - 2` in `ℤ`.",
    "kind": "def",
    "type": "ℕ → ℤ"
  },
  {
    "name": "category_theory.grothendieck_topology.discrete",
    "statement": "def category_theory.grothendieck_topology.discrete (C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C",
    "theorem": "(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "The discrete Grothendieck topology, in which every sieve is covering.  See https://en.wikipedia.org/wiki/Grothendieck_topology#The_discrete_and_indiscrete_topologies.",
    "kind": "def",
    "type": "category_theory.grothendieck_topology C"
  },
  {
    "name": "encodable.choose_x",
    "statement": "def encodable.choose_x {α : Type u_1} {p : α → Prop} [encodable α] [decidable_pred p] (h : ∃ (x : α), p x) : {a // p a}",
    "theorem": "{α : Type u_1} {p : α → Prop} [encodable α] [decidable_pred p] (h : ∃ (x : α), p x) : {a // p a}",
    "args": "{α : Type u_1} {p : α → Prop} [encodable α] [decidable_pred p] (h : ∃ (x : α), p x)",
    "doc_string": "Constructive choice function for a decidable subtype of an encodable type.",
    "kind": "def",
    "type": "{a // p a}"
  },
  {
    "name": "subfield.neg_mem",
    "statement": "theorem subfield.neg_mem {K : Type u} [field K] (s : subfield K) {x : K} : x ∈ s → -x ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) {x : K} : x ∈ s → -x ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K) {x : K}",
    "doc_string": "A subfield is closed under negation.",
    "kind": "theorem",
    "type": "x ∈ s → -x ∈ s"
  },
  {
    "name": "multiset.Ioo",
    "statement": "def multiset.Ioo {α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α)",
    "doc_string": " The multiset of elements `x` such that `a < x` and `x < b`. Basically `set.Ioo a b` as a multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "uniform_space.completion.has_coe_t",
    "statement": "def uniform_space.completion.has_coe_t (α : Type u_1) [uniform_space α] : has_coe_t α (uniform_space.completion α)",
    "theorem": "(α : Type u_1) [uniform_space α] : has_coe_t α (uniform_space.completion α)",
    "args": "(α : Type u_1) [uniform_space α]",
    "doc_string": "Automatic coercion from `α` to its completion. Not always injective.",
    "kind": "def",
    "type": "has_coe_t α (uniform_space.completion α)"
  },
  {
    "name": "directed.sequence",
    "statement": "def directed.sequence {α : Type u_1} {β : Type u_2} [encodable α] [inhabited α] {r : β → β → Prop} (f : α → β) (hf : directed r f) : ℕ → α",
    "theorem": "{α : Type u_1} {β : Type u_2} [encodable α] [inhabited α] {r : β → β → Prop} (f : α → β) (hf : directed r f) : ℕ → α",
    "args": "{α : Type u_1} {β : Type u_2} [encodable α] [inhabited α] {r : β → β → Prop} (f : α → β) (hf : directed r f)",
    "doc_string": " Given a `directed r` function `f : α → β` defined on an encodable inhabited type, construct a noncomputable sequence such that `r (f (x n)) (f (x (n + 1)))` and `r (f a) (f (x (encode a + 1))`.",
    "kind": "def",
    "type": "ℕ → α"
  },
  {
    "name": "add_submonoid_class",
    "statement": "structure add_submonoid_class (S : Type u_4) (M : out_param (Type u_5)) [add_zero_class M] [set_like S M] : Type",
    "theorem": "(S : Type u_4) (M : out_param (Type u_5)) [add_zero_class M] [set_like S M] : Type",
    "args": "(S : Type u_4) (M : out_param (Type u_5)) [add_zero_class M] [set_like S M]",
    "doc_string": " `add_submonoid_class S M` says `S` is a type of subsets `s ≤ M` that contain `0` and are closed under `(+)`",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "algebra_map_int_eq",
    "statement": "theorem algebra_map_int_eq (R : Type u_1) [ring R] : algebra_map ℤ R = int.cast_ring_hom R",
    "theorem": "(R : Type u_1) [ring R] : algebra_map ℤ R = int.cast_ring_hom R",
    "args": "(R : Type u_1) [ring R]",
    "doc_string": "A special case of `ring_hom.eq_int_cast'` that happens to be true definitionally",
    "kind": "theorem",
    "type": "algebra_map ℤ R = int.cast_ring_hom R"
  },
  {
    "name": "stieltjes_function",
    "statement": "structure stieltjes_function  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Bundled monotone right-continuous real functions, used to construct Stieltjes measures.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "nat.odd_mod_four_iff",
    "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3",
    "theorem": "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3",
    "args": "{n : ℕ}",
    "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`",
    "kind": "theorem",
    "type": "n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"
  },
  {
    "name": "submodule.orthogonal_gc",
    "statement": "theorem submodule.orthogonal_gc (𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] : galois_connection submodule.orthogonal submodule.orthogonal",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] : galois_connection submodule.orthogonal submodule.orthogonal",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E]",
    "doc_string": " `submodule.orthogonal` gives a `galois_connection` between `submodule 𝕜 E` and its `order_dual`.",
    "kind": "theorem",
    "type": "galois_connection submodule.orthogonal submodule.orthogonal"
  },
  {
    "name": "first_order.language.definable_set",
    "statement": "def first_order.language.definable_set (L : first_order.language) {M : Type w} [L.Structure M] (A : set M) (α : Type u_1) : Type (max u_1 w)",
    "theorem": "(L : first_order.language) {M : Type w} [L.Structure M] (A : set M) (α : Type u_1) : Type (max u_1 w)",
    "args": "(L : first_order.language) {M : Type w} [L.Structure M] (A : set M) (α : Type u_1)",
    "doc_string": "Definable sets are subsets of finite Cartesian products of a structure such that membership is  given by a first-order formula.",
    "kind": "def",
    "type": "Type (max u_1 w)"
  },
  {
    "name": "Class.to_Set",
    "statement": "def Class.to_Set (p : Set → Prop) (A : Class) : Prop",
    "theorem": "(p : Set → Prop) (A : Class) : Prop",
    "args": "(p : Set → Prop) (A : Class)",
    "doc_string": "Assert that `A` is a ZFC set satisfying `p`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function_field.ring_of_integers",
    "statement": "def function_field.ring_of_integers (Fq F : Type) [field Fq] [field F] [algebra (polynomial Fq) F] : subalgebra (polynomial Fq) F",
    "theorem": "(Fq F : Type) [field Fq] [field F] [algebra (polynomial Fq) F] : subalgebra (polynomial Fq) F",
    "args": "(Fq F : Type) [field Fq] [field F] [algebra (polynomial Fq) F]",
    "doc_string": " The function field analogue of `number_field.ring_of_integers`: `function_field.ring_of_integers Fq Fqt F` is the integral closure of `Fq[t]` in `F`.  We don't actually assume `F` is a function field over `Fq` in the definition, only when proving its properties.",
    "kind": "def",
    "type": "subalgebra (polynomial Fq) F"
  },
  {
    "name": "inf_hom.id",
    "statement": "def inf_hom.id (α : Type u_3) [has_inf α] : inf_hom α α",
    "theorem": "(α : Type u_3) [has_inf α] : inf_hom α α",
    "args": "(α : Type u_3) [has_inf α]",
    "doc_string": "`id` as an `inf_hom`.",
    "kind": "def",
    "type": "inf_hom α α"
  },
  {
    "name": "ennreal.to_nnreal",
    "statement": "def ennreal.to_nnreal  : ennreal → nnreal",
    "theorem": " : ennreal → nnreal",
    "args": "",
    "doc_string": "`to_nnreal x` returns `x` if it is real, otherwise 0.",
    "kind": "def",
    "type": "ennreal → nnreal"
  },
  {
    "name": "algebraic_geometry.PresheafedSpace.category_theory.limits.has_colimits",
    "statement": "def algebraic_geometry.PresheafedSpace.category_theory.limits.has_colimits {C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_colimits (algebraic_geometry.PresheafedSpace C)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_colimits (algebraic_geometry.PresheafedSpace C)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_limits C]",
    "doc_string": "When `C` has limits, the category of presheaved spaces with values in `C` itself has colimits.",
    "kind": "def",
    "type": "category_theory.limits.has_colimits (algebraic_geometry.PresheafedSpace C)"
  },
  {
    "name": "category_theory.shrink_homs",
    "statement": "def category_theory.shrink_homs (C : Type u) : Type u",
    "theorem": "(C : Type u) : Type u",
    "args": "(C : Type u)",
    "doc_string": "We define a type alias `shrink_homs C` for `C`. When we have `locally_small.{w} C`, we'll put a `category.{w}` instance on `shrink_homs C`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "category_theory.injective",
    "statement": "structure category_theory.injective {C : Type u} [category_theory.category C] (J : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (J : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (J : C)",
    "doc_string": "An object `J` is injective iff every morphism into `J` can be obtained by extending a monomorphism.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "path.homotopic.setoid",
    "statement": "def path.homotopic.setoid {X : Type u} [topological_space X] (x₀ x₁ : X) : setoid (path x₀ x₁)",
    "theorem": "{X : Type u} [topological_space X] (x₀ x₁ : X) : setoid (path x₀ x₁)",
    "args": "{X : Type u} [topological_space X] (x₀ x₁ : X)",
    "doc_string": "The setoid on `path`s defined by the equivalence relation `path.homotopic`. That is, two paths are equivalent if there is a `homotopy` between them.",
    "kind": "def",
    "type": "setoid (path x₀ x₁)"
  },
  {
    "name": "ideal.is_jacobson_localization",
    "statement": "theorem ideal.is_jacobson_localization {R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S",
    "theorem": "{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S",
    "args": "{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R]",
    "doc_string": " If `S` is the localization of the Jacobson ring `R` at the submonoid generated by `y : R`, then `S` is Jacobson.",
    "kind": "theorem",
    "type": "ideal.is_jacobson S"
  },
  {
    "name": "lie_algebra.derived_series_of_ideal",
    "statement": "def lie_algebra.derived_series_of_ideal (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ℕ) : lie_ideal R L → lie_ideal R L",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ℕ) : lie_ideal R L → lie_ideal R L",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ℕ)",
    "doc_string": " A generalisation of the derived series of a Lie algebra, whose zeroth term is a specified ideal.  It can be more convenient to work with this generalisation when considering the derived series of an ideal since it provides a type-theoretic expression of the fact that the terms of the ideal's derived series are also ideals of the enclosing algebra.  See also `lie_ideal.derived_series_eq_derived_series_of_ideal_comap` and `lie_ideal.derived_series_eq_derived_series_of_ideal_map` below.",
    "kind": "def",
    "type": "lie_ideal R L → lie_ideal R L"
  },
  {
    "name": "category_theory.ulift_hom",
    "statement": "def category_theory.ulift_hom (C : Type u) : Type u",
    "theorem": "(C : Type u) : Type u",
    "args": "(C : Type u)",
    "doc_string": "`ulift_hom.{w} C` is an alias for `C`, which is endowed with a category instance  whose morphisms are obtained by applying `ulift.{w}` to the morphisms from `C`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "sum.get_right",
    "statement": "def sum.get_right {α : Type u} {β : Type v} : α ⊕ β → option β",
    "theorem": "{α : Type u} {β : Type v} : α ⊕ β → option β",
    "args": "{α : Type u} {β : Type v}",
    "doc_string": "Check if a sum is `inr` and if so, retrieve its contents.",
    "kind": "def",
    "type": "α ⊕ β → option β"
  },
  {
    "name": "is_monoid_hom.inv",
    "statement": "theorem is_monoid_hom.inv {α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f) : is_monoid_hom (λ (a : α), (f a)⁻¹)",
    "theorem": "{α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f) : is_monoid_hom (λ (a : α), (f a)⁻¹)",
    "args": "{α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f)",
    "doc_string": " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative.",
    "kind": "theorem",
    "type": "is_monoid_hom (λ (a : α), (f a)⁻¹)"
  },
  {
    "name": "computable_pred",
    "statement": "def computable_pred {α : Type u_1} [primcodable α] (p : α → Prop) : Prop",
    "theorem": "{α : Type u_1} [primcodable α] (p : α → Prop) : Prop",
    "args": "{α : Type u_1} [primcodable α] (p : α → Prop)",
    "doc_string": "A computable predicate is one whose indicator function is computable.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pempty.elim",
    "statement": "def pempty.elim {C : Sort u_1} : pempty → C",
    "theorem": "{C : Sort u_1} : pempty → C",
    "args": "{C : Sort u_1}",
    "doc_string": "Ex falso, the nondependent eliminator for the `pempty` type.",
    "kind": "def",
    "type": "pempty → C"
  },
  {
    "name": "multiset.strong_induction_on",
    "statement": "def multiset.strong_induction_on {α : Type u_1} {p : multiset α → Sort u_2} (s : multiset α) : (Π (s : multiset α), (Π (t : multiset α), t < s → p t) → p s) → p s",
    "theorem": "{α : Type u_1} {p : multiset α → Sort u_2} (s : multiset α) : (Π (s : multiset α), (Π (t : multiset α), t < s → p t) → p s) → p s",
    "args": "{α : Type u_1} {p : multiset α → Sort u_2} (s : multiset α)",
    "doc_string": " A strong induction principle for multisets: If you construct a value for a particular multiset given values for all strictly smaller multisets, you can construct a value for any multiset.",
    "kind": "def",
    "type": "(Π (s : multiset α), (Π (t : multiset α), t < s → p t) → p s) → p s"
  },
  {
    "name": "setoid.partition.le",
    "statement": "def setoid.partition.le {α : Type u_1} : has_le (subtype setoid.is_partition)",
    "theorem": "{α : Type u_1} : has_le (subtype setoid.is_partition)",
    "args": "{α : Type u_1}",
    "doc_string": "Defining `≤` on partitions as the `≤` defined on their induced equivalence relations.",
    "kind": "def",
    "type": "has_le (subtype setoid.is_partition)"
  },
  {
    "name": "exp_char_one_of_char_zero",
    "statement": "theorem exp_char_one_of_char_zero (R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q] : q = 1",
    "theorem": "(R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q] : q = 1",
    "args": "(R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q]",
    "doc_string": "The exponential characteristic is one if the characteristic is zero.",
    "kind": "theorem",
    "type": "q = 1"
  },
  {
    "name": "tactic.rewrite_search.config",
    "statement": "structure tactic.rewrite_search.config  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration options for a rewrite search. `max_iterations` controls how many vertices are expanded in the graph search. `explain` generates Lean code to replace the call to `rewrite_search`. `explain_using_conv` changes the nature of the explanation.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "seq_closure",
    "statement": "def seq_closure {X : Type u_1} [topological_space X] (s : set X) : set X",
    "theorem": "{X : Type u_1} [topological_space X] (s : set X) : set X",
    "args": "{X : Type u_1} [topological_space X] (s : set X)",
    "doc_string": " The sequential closure of a set `s : set X` in a topological space `X` is the set of all `a : X` which arise as limit of sequences in `s`.",
    "kind": "def",
    "type": "set X"
  },
  {
    "name": "polynomial.next_coeff",
    "statement": "def polynomial.next_coeff {R : Type u} [semiring R] (p : polynomial R) : R",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : R",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": "The second-highest coefficient, or 0 for constants",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "fractional_ideal.span_singleton",
    "statement": "def fractional_ideal.span_singleton {R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P) : fractional_ideal S P",
    "theorem": "{R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P) : fractional_ideal S P",
    "args": "{R : Type u_1} [comm_ring R] (S : submonoid R) {P : Type u_2} [comm_ring P] [algebra R P] [loc : is_localization S P] (x : P)",
    "doc_string": "`span_singleton x` is the fractional ideal generated by `x` if `0 ∉ S`",
    "kind": "def",
    "type": "fractional_ideal S P"
  },
  {
    "name": "graded_monoid.grade_zero.monoid",
    "statement": "def graded_monoid.grade_zero.monoid {ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] : monoid (A 0)",
    "theorem": "{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] : monoid (A 0)",
    "args": "{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A]",
    "doc_string": "The `monoid` structure derived from `gmonoid A`.",
    "kind": "def",
    "type": "monoid (A 0)"
  },
  {
    "name": "ideal.has_quotient",
    "statement": "def ideal.has_quotient {R : Type u} [comm_ring R] : has_quotient R (ideal R)",
    "theorem": "{R : Type u} [comm_ring R] : has_quotient R (ideal R)",
    "args": "{R : Type u} [comm_ring R]",
    "doc_string": " The quotient `R/I` of a ring `R` by an ideal `I`.  The ideal quotient of `I` is defined to equal the quotient of `I` as an `R`-submodule of `R`. This definition is marked `reducible` so that typeclass instances can be shared between `ideal.quotient I` and `submodule.quotient I`.",
    "kind": "def",
    "type": "has_quotient R (ideal R)"
  },
  {
    "name": "is_add_group_hom",
    "statement": "structure is_add_group_hom {α : Type u} {β : Type v} [add_group α] [add_group β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] (f : α → β)",
    "doc_string": "Predicate for additive group homomorphism (deprecated -- use bundled `monoid_hom`).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "mul_sub_mul_div_mul_nonpos",
    "statement": "theorem mul_sub_mul_div_mul_nonpos {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0)",
    "doc_string": "**Alias** of the reverse direction of mul_sub_mul_div_mul_nonpos_iff`.",
    "kind": "theorem",
    "type": "a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0"
  },
  {
    "name": "matrix.special_linear_group.has_neg",
    "statement": "def matrix.special_linear_group.has_neg {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] [fact (even (fintype.card n))] : has_neg (matrix.special_linear_group n R)",
    "theorem": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] [fact (even (fintype.card n))] : has_neg (matrix.special_linear_group n R)",
    "args": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] [fact (even (fintype.card n))]",
    "doc_string": " Formal operation of negation on special linear group on even cardinality `n` given by negating each element.",
    "kind": "def",
    "type": "has_neg (matrix.special_linear_group n R)"
  },
  {
    "name": "submodule.canonically_ordered_add_monoid",
    "statement": "def submodule.canonically_ordered_add_monoid {R : Type u_2} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : canonically_ordered_add_monoid (submodule R M)",
    "theorem": "{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : canonically_ordered_add_monoid (submodule R M)",
    "args": "{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": " This is not an instance, as it would form a simp loop between `bot_eq_zero` and `submodule.zero_eq_bot`. It can be safely enabled with ```lean local attribute [-simp] submodule.zero_eq_bot local attribute [instance] canonically_ordered_add_monoid ```",
    "kind": "def",
    "type": "canonically_ordered_add_monoid (submodule R M)"
  },
  {
    "name": "lazy_list.for",
    "statement": "def lazy_list.for {α : Type u} {β : Type v} (l : lazy_list α) (f : α → β) : lazy_list β",
    "theorem": "{α : Type u} {β : Type v} (l : lazy_list α) (f : α → β) : lazy_list β",
    "args": "{α : Type u} {β : Type v} (l : lazy_list α) (f : α → β)",
    "doc_string": "Maps a function over a lazy list. Same as `lazy_list.map`, but with swapped arguments.",
    "kind": "def",
    "type": "lazy_list β"
  },
  {
    "name": "add_subgroup_class",
    "statement": "structure add_subgroup_class (S : Type u_3) (G : Type u_4) [sub_neg_monoid G] [set_like S G] : Type",
    "theorem": "(S : Type u_3) (G : Type u_4) [sub_neg_monoid G] [set_like S G] : Type",
    "args": "(S : Type u_3) (G : Type u_4) [sub_neg_monoid G] [set_like S G]",
    "doc_string": " `add_subgroup_class S G` states `S` is a type of subsets `s ⊆ G` that are additive subgroups of `G`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "first_order.language.is_ultrahomogeneous",
    "statement": "def first_order.language.is_ultrahomogeneous (L : first_order.language) (M : Type w) [L.Structure M] : Prop",
    "theorem": "(L : first_order.language) (M : Type w) [L.Structure M] : Prop",
    "args": "(L : first_order.language) (M : Type w) [L.Structure M]",
    "doc_string": " A structure `M` is ultrahomogeneous if every embedding of a finitely generated substructure into `M` extends to an automorphism of `M`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_biproduct.of_has_product",
    "statement": "theorem category_theory.limits.has_biproduct.of_has_product {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_product f]",
    "doc_string": "In a preadditive category, if the product over `f : J → C` exists,    then the biproduct over `f` exists.",
    "kind": "theorem",
    "type": "category_theory.limits.has_biproduct f"
  },
  {
    "name": "function_field.Fqt_infty",
    "statement": "def function_field.Fqt_infty (Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : Type",
    "theorem": "(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : Type",
    "args": "(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)]",
    "doc_string": "The completion `Fq((t⁻¹))`  of `Fq(t)` with respect to the valuation at infinity.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "has_continuous_mul",
    "statement": "structure has_continuous_mul (M : Type u) [topological_space M] [has_mul M] : Prop",
    "theorem": "(M : Type u) [topological_space M] [has_mul M] : Prop",
    "args": "(M : Type u) [topological_space M] [has_mul M]",
    "doc_string": " Basic hypothesis to talk about a topological monoid or a topological semigroup. A topological monoid over `M`, for example, is obtained by requiring both the instances `monoid M` and `has_continuous_mul M`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "connected_components",
    "statement": "def connected_components (α : Type u) [topological_space α] : Type u",
    "theorem": "(α : Type u) [topological_space α] : Type u",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "The quotient of a space by its connected components",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "W_type.elim",
    "statement": "def W_type.elim {α : Type u_1} {β : α → Type u_2} (γ : Type u_3) (fγ : (Σ (a : α), β a → γ) → γ) : W_type β → γ",
    "theorem": "{α : Type u_1} {β : α → Type u_2} (γ : Type u_3) (fγ : (Σ (a : α), β a → γ) → γ) : W_type β → γ",
    "args": "{α : Type u_1} {β : α → Type u_2} (γ : Type u_3) (fγ : (Σ (a : α), β a → γ) → γ)",
    "doc_string": "The canonical map from `W_type β` into any type `γ` given a map `(Σ a : α, β a → γ) → γ`.",
    "kind": "def",
    "type": "W_type β → γ"
  },
  {
    "name": "lie_ring.of_associative_ring",
    "statement": "def lie_ring.of_associative_ring {A : Type v} [ring A] : lie_ring A",
    "theorem": "{A : Type v} [ring A] : lie_ring A",
    "args": "{A : Type v} [ring A]",
    "doc_string": "An associative ring gives rise to a Lie ring by taking the bracket to be the ring commutator.",
    "kind": "def",
    "type": "lie_ring A"
  },
  {
    "name": "part.bind",
    "statement": "def part.bind {α : Type u_1} {β : Type u_2} (f : part α) (g : α → part β) : part β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : part α) (g : α → part β) : part β",
    "args": "{α : Type u_1} {β : Type u_2} (f : part α) (g : α → part β)",
    "doc_string": "The bind operation has value `g (f.get)`, and is defined when all the  parts are defined.",
    "kind": "def",
    "type": "part β"
  },
  {
    "name": "category_theory.arrow",
    "statement": "def category_theory.arrow (T : Type u) [category_theory.category T] : Type (max u v)",
    "theorem": "(T : Type u) [category_theory.category T] : Type (max u v)",
    "args": "(T : Type u) [category_theory.category T]",
    "doc_string": "The arrow category of `T` has as objects all morphisms in `T` and as morphisms commutative     squares in `T`.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "has_compl",
    "statement": "structure has_compl (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "Set / lattice complement",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "is_idempotent_elem",
    "statement": "def is_idempotent_elem {M : Type u_1} [has_mul M] (p : M) : Prop",
    "theorem": "{M : Type u_1} [has_mul M] (p : M) : Prop",
    "args": "{M : Type u_1} [has_mul M] (p : M)",
    "doc_string": "An element `p` is said to be idempotent if `p * p = p`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "first_order.language.countable_functions",
    "statement": "structure first_order.language.countable_functions (L : first_order.language) : Prop",
    "theorem": "(L : first_order.language) : Prop",
    "args": "(L : first_order.language)",
    "doc_string": "A language is countable when it has countably many symbols.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "right.one_lt_inv_iff",
    "statement": "theorem right.one_lt_inv_iff {α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "kind": "theorem",
    "type": "1 < a⁻¹ ↔ a < 1"
  },
  {
    "name": "tactic.rewrite_search.side",
    "statement": "inductive tactic.rewrite_search.side  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "`side` represents the side of an equation, either the left or the right.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "is_add_cyclic",
    "statement": "structure is_add_cyclic (α : Type u) [add_group α] : Prop",
    "theorem": "(α : Type u) [add_group α] : Prop",
    "args": "(α : Type u) [add_group α]",
    "doc_string": "A group is called *cyclic* if it is generated by a single element.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.of",
    "statement": "def generalized_continued_fraction.int_fract_pair.of {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction.int_fract_pair K",
    "theorem": "{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction.int_fract_pair K",
    "args": "{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K)",
    "doc_string": "Creates the integer and fractional part of a value `v`, i.e. `⟨⌊v⌋, v - ⌊v⌋⟩`.",
    "kind": "def",
    "type": "generalized_continued_fraction.int_fract_pair K"
  },
  {
    "name": "dvd_add_self_left",
    "statement": "theorem dvd_add_self_left {α : Type u} [ring α] {a b : α} : a ∣ a + b ↔ a ∣ b",
    "theorem": "{α : Type u} [ring α] {a b : α} : a ∣ a + b ↔ a ∣ b",
    "args": "{α : Type u} [ring α] {a b : α}",
    "doc_string": "An element a divides the sum a + b if and only if a divides b.",
    "kind": "theorem",
    "type": "a ∣ a + b ↔ a ∣ b"
  },
  {
    "name": "erased.out_proof",
    "statement": "theorem erased.out_proof {p : Prop} (a : erased p) : p",
    "theorem": "{p : Prop} (a : erased p) : p",
    "args": "{p : Prop} (a : erased p)",
    "doc_string": "Extracts the erased value, if it is a proof.",
    "kind": "theorem",
    "type": "p"
  },
  {
    "name": "star_semigroup_of_comm",
    "statement": "def star_semigroup_of_comm {R : Type u_1} [comm_monoid R] : star_semigroup R",
    "theorem": "{R : Type u_1} [comm_monoid R] : star_semigroup R",
    "args": "{R : Type u_1} [comm_monoid R]",
    "doc_string": "Any commutative monoid admits the trivial `*`-structure.  See note [reducible non-instances].",
    "kind": "def",
    "type": "star_semigroup R"
  },
  {
    "name": "generalized_continued_fraction.squash_seq",
    "statement": "def generalized_continued_fraction.squash_seq {K : Type u_1} [division_ring K] (s : seq (generalized_continued_fraction.pair K)) (n : ℕ) : seq (generalized_continued_fraction.pair K)",
    "theorem": "{K : Type u_1} [division_ring K] (s : seq (generalized_continued_fraction.pair K)) (n : ℕ) : seq (generalized_continued_fraction.pair K)",
    "args": "{K : Type u_1} [division_ring K] (s : seq (generalized_continued_fraction.pair K)) (n : ℕ)",
    "doc_string": "Given a sequence of gcf.pairs `s = [(a₀, bₒ), (a₁, b₁), ...]`, `squash_seq s n` combines `⟨aₙ, bₙ⟩` and `⟨aₙ₊₁, bₙ₊₁⟩` at position `n` to `⟨aₙ, bₙ + aₙ₊₁ / bₙ₊₁⟩`. For example, `squash_seq s 0 = [(a₀, bₒ + a₁ / b₁), (a₁, b₁),...]`. If `s.terminated_at (n + 1)`, then `squash_seq s n = s`.",
    "kind": "def",
    "type": "seq (generalized_continued_fraction.pair K)"
  },
  {
    "name": "subfield.copy",
    "statement": "def subfield.copy {K : Type u} [field K] (S : subfield K) (s : set K) (hs : s = ↑S) : subfield K",
    "theorem": "{K : Type u} [field K] (S : subfield K) (s : set K) (hs : s = ↑S) : subfield K",
    "args": "{K : Type u} [field K] (S : subfield K) (s : set K) (hs : s = ↑S)",
    "doc_string": " Copy of a subfield with a new `carrier` equal to the old one. Useful to fix definitional equalities.",
    "kind": "def",
    "type": "subfield K"
  },
  {
    "name": "linarith.pcomp",
    "statement": "structure linarith.pcomp  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A `pcomp` stores a linear comparison `Σ cᵢ*xᵢ R 0`, along with information about how this comparison was derived. The original expressions fed into `linarith` are each assigned a unique natural number label. The *historical set* `pcomp.history` stores the labels of expressions that were used in deriving the current `pcomp`. Variables are also indexed by natural numbers. The sets `pcomp.effective`, `pcomp.implicit`, and `pcomp.vars` contain variable indices. * `pcomp.vars` contains the variables that appear in `pcomp.c`. We store them in `pcomp` to   avoid recomputing the set, which requires folding over a list. (TODO: is this really needed?) * `pcomp.effective` contains the variables that have been effectively eliminated from `pcomp`.   A variable `n` is said to be *effectively eliminated* in `pcomp` if the elimination of `n`   produced at least one of the ancestors of `pcomp`. * `pcomp.implicit` contains the variables that have been implicitly eliminated from `pcomp`.   A variable `n` is said to be *implicitly eliminated* in `pcomp` if it satisfies the following   properties:   - There is some `ancestor` of `pcomp` such that `n` appears in `ancestor.vars`.   - `n` does not appear in `pcomp.vars`.   - `n` was not effectively eliminated.  We track these sets in order to compute whether the history of a `pcomp` is *minimal*. Checking this directly is expensive, but effective approximations can be defined in terms of these sets. During the variable elimination process, a `pcomp` with non-minimal history can be discarded.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "free_magma",
    "statement": "inductive free_magma (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Free magma over a given alphabet.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "division_def",
    "statement": "theorem division_def {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹",
    "theorem": "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹",
    "args": "{G : Type u_1} [div_inv_monoid G] (a b : G)",
    "doc_string": "**Alias** of div_eq_mul_inv`.",
    "kind": "theorem",
    "type": "a / b = a * b⁻¹"
  },
  {
    "name": "cont_diff_bump_of_inner",
    "statement": "structure cont_diff_bump_of_inner {E : Type u_1} (c : E) : Type",
    "theorem": "{E : Type u_1} (c : E) : Type",
    "args": "{E : Type u_1} (c : E)",
    "doc_string": " `f : cont_diff_bump_of_inner c`, where `c` is a point in an inner product space, is a bundled smooth function such that  - `f` is equal to `1` in `metric.closed_ball c f.r`; - `support f = metric.ball c f.R`; - `0 ≤ f x ≤ 1` for all `x`.  The structure `cont_diff_bump_of_inner` contains the data required to construct the function: real numbers `r`, `R`, and proofs of `0 < r < R`. The function itself is available through `coe_fn`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "order.pred_order.subsingleton",
    "statement": "def order.pred_order.subsingleton {α : Type u_1} [partial_order α] : subsingleton (pred_order α)",
    "theorem": "{α : Type u_1} [partial_order α] : subsingleton (pred_order α)",
    "args": "{α : Type u_1} [partial_order α]",
    "doc_string": "There is at most one way to define the predecessors in a `partial_order`.",
    "kind": "def",
    "type": "subsingleton (pred_order α)"
  },
  {
    "name": "representation.character",
    "statement": "def representation.character {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (ρ : representation k G V) (g : G) : k",
    "theorem": "{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (ρ : representation k G V) (g : G) : k",
    "args": "{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_ring k] [group G] [add_comm_group V] [module k V] (ρ : representation k G V) (g : G)",
    "doc_string": "The character associated to a representation of `G`, which as a map `G → k` sends each element to the trace of the corresponding linear map.",
    "kind": "def",
    "type": "k"
  },
  {
    "name": "int.nat_abs_pow_two",
    "statement": "theorem int.nat_abs_pow_two (x : ℤ) : ↑(x.nat_abs) ^ 2 = x ^ 2",
    "theorem": "(x : ℤ) : ↑(x.nat_abs) ^ 2 = x ^ 2",
    "args": "(x : ℤ)",
    "doc_string": "**Alias** of int.nat_abs_sq`.",
    "kind": "theorem",
    "type": "↑(x.nat_abs) ^ 2 = x ^ 2"
  },
  {
    "name": "perms_of_finset",
    "statement": "def perms_of_finset {α : Type u_1} [decidable_eq α] (s : finset α) : finset (equiv.perm α)",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : finset α) : finset (equiv.perm α)",
    "args": "{α : Type u_1} [decidable_eq α] (s : finset α)",
    "doc_string": "Given a finset, produce the finset of all permutations of its elements.",
    "kind": "def",
    "type": "finset (equiv.perm α)"
  },
  {
    "name": "normed_group.core",
    "statement": "structure normed_group.core (E : Type u_6) [add_comm_group E] [has_norm E] : Prop",
    "theorem": "(E : Type u_6) [add_comm_group E] [has_norm E] : Prop",
    "args": "(E : Type u_6) [add_comm_group E] [has_norm E]",
    "doc_string": " A normed group can be built from a norm that satisfies algebraic properties. This is formalised in this structure.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "omega.int.exprterm",
    "statement": "inductive omega.int.exprterm  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The shadow syntax for arithmetic terms. All constants are reified to `cst` (e.g., `-5` is reified to `cst -5`) and all other atomic terms are reified to `exp` (e.g., `-5 * (gcd 14 -7)` is reified to `exp -5 \\`(gcd 14 -7)`). `exp` accepts a coefficient of type `int` as its first argument because multiplication by constant is allowed by the omega test.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "filter.map",
    "statement": "def filter.map {α : Type u} {β : Type v} (m : α → β) (f : filter α) : filter β",
    "theorem": "{α : Type u} {β : Type v} (m : α → β) (f : filter α) : filter β",
    "args": "{α : Type u} {β : Type v} (m : α → β) (f : filter α)",
    "doc_string": "The forward map of a filter",
    "kind": "def",
    "type": "filter β"
  },
  {
    "name": "add_submonoid.simps.coe",
    "statement": "def add_submonoid.simps.coe {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : set M",
    "theorem": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : set M",
    "args": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "first_order.language.Theory.Model",
    "statement": "structure first_order.language.Theory.Model {L : first_order.language} (T : L.Theory) : Type (max u v (w+1))",
    "theorem": "{L : first_order.language} (T : L.Theory) : Type (max u v (w+1))",
    "args": "{L : first_order.language} (T : L.Theory)",
    "doc_string": "The type of nonempty models of a first-order theory.",
    "kind": "structure",
    "type": "Type (max u v (w+1))"
  },
  {
    "name": "fintype.field_of_domain",
    "statement": "def fintype.field_of_domain (R : Type u_1) [comm_ring R] [is_domain R] [decidable_eq R] [fintype R] : field R",
    "theorem": "(R : Type u_1) [comm_ring R] [is_domain R] [decidable_eq R] [fintype R] : field R",
    "args": "(R : Type u_1) [comm_ring R] [is_domain R] [decidable_eq R] [fintype R]",
    "doc_string": " Every finite commutative domain is a field.  TODO: Prove Wedderburn's little theorem, which shows a finite domain is automatically commutative, dropping one assumption from this theorem.",
    "kind": "def",
    "type": "field R"
  },
  {
    "name": "category_theory.zag",
    "statement": "def category_theory.zag {J : Type u₁} [category_theory.category J] (j₁ j₂ : J) : Prop",
    "theorem": "{J : Type u₁} [category_theory.category J] (j₁ j₂ : J) : Prop",
    "args": "{J : Type u₁} [category_theory.category J] (j₁ j₂ : J)",
    "doc_string": "j₁ and j₂ are related by `zag` if there is a morphism between them.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "cardinal.aleph_idx",
    "statement": "def cardinal.aleph_idx  : cardinal → ordinal",
    "theorem": " : cardinal → ordinal",
    "args": "",
    "doc_string": "The `aleph'` index function, which gives the ordinal index of a cardinal.  (The `aleph'` part is because unlike `aleph` this counts also the  finite stages. So `aleph_idx n = n`, `aleph_idx ω = ω`,  `aleph_idx ℵ₁ = ω + 1` and so on.)  For an upgraded version stating that the range is everything, see `aleph_idx.rel_iso`.",
    "kind": "def",
    "type": "cardinal → ordinal"
  },
  {
    "name": "real.sin_pi_div_six",
    "statement": "theorem real.sin_pi_div_six  : real.sin (real.pi / 6) = 1 / 2",
    "theorem": " : real.sin (real.pi / 6) = 1 / 2",
    "args": "",
    "doc_string": "The sine of `π / 6` is `1 / 2`.",
    "kind": "theorem",
    "type": "real.sin (real.pi / 6) = 1 / 2"
  },
  {
    "name": "submonoid.topological_closure",
    "statement": "def submonoid.topological_closure {M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] (s : submonoid M) : submonoid M",
    "theorem": "{M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] (s : submonoid M) : submonoid M",
    "args": "{M : Type u_4} [topological_space M] [monoid M] [has_continuous_mul M] (s : submonoid M)",
    "doc_string": " The (topological-space) closure of a submonoid of a space `M` with `has_continuous_mul` is itself a submonoid.",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "topological_space.opens.is_basis",
    "statement": "def topological_space.opens.is_basis {α : Type u_1} [topological_space α] (B : set (topological_space.opens α)) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] (B : set (topological_space.opens α)) : Prop",
    "args": "{α : Type u_1} [topological_space α] (B : set (topological_space.opens α))",
    "doc_string": "A set of `opens α` is a basis if the set of corresponding sets is a topological basis.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_irreducible",
    "statement": "def is_irreducible {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": " An irreducible set `s` is one that is nonempty and where there is no non-trivial pair of disjoint opens on `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bilin_form.is_ortho",
    "statement": "def bilin_form.is_ortho {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (x y : M) : Prop",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (x y : M) : Prop",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (x y : M)",
    "doc_string": " The proposition that two elements of a bilinear form space are orthogonal. For orthogonality of an indexed set of elements, use `bilin_form.is_Ortho`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "uniform_add_group",
    "statement": "structure uniform_add_group (α : Type u_3) [uniform_space α] [add_group α] : Prop",
    "theorem": "(α : Type u_3) [uniform_space α] [add_group α] : Prop",
    "args": "(α : Type u_3) [uniform_space α] [add_group α]",
    "doc_string": "A uniform additive group is an additive group in which addition  and negation are uniformly continuous.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "Magma.of",
    "statement": "def Magma.of (M : Type u) [has_mul M] : Magma",
    "theorem": "(M : Type u) [has_mul M] : Magma",
    "args": "(M : Type u) [has_mul M]",
    "doc_string": "Construct a bundled `Magma` from the underlying type and typeclass.",
    "kind": "def",
    "type": "Magma"
  },
  {
    "name": "continuous.measurable",
    "statement": "theorem continuous.measurable {α : Type u_1} {γ : Type u_3} [topological_space α] [measurable_space α] [opens_measurable_space α] [topological_space γ] [measurable_space γ] [borel_space γ] {f : α → γ} (hf : continuous f) : measurable f",
    "theorem": "{α : Type u_1} {γ : Type u_3} [topological_space α] [measurable_space α] [opens_measurable_space α] [topological_space γ] [measurable_space γ] [borel_space γ] {f : α → γ} (hf : continuous f) : measurable f",
    "args": "{α : Type u_1} {γ : Type u_3} [topological_space α] [measurable_space α] [opens_measurable_space α] [topological_space γ] [measurable_space γ] [borel_space γ] {f : α → γ} (hf : continuous f)",
    "doc_string": " A continuous function from an `opens_measurable_space` to a `borel_space` is measurable.",
    "kind": "theorem",
    "type": "measurable f"
  },
  {
    "name": "succ_order",
    "statement": "structure succ_order (α : Type u_2) [preorder α] : Type u_2",
    "theorem": "(α : Type u_2) [preorder α] : Type u_2",
    "args": "(α : Type u_2) [preorder α]",
    "doc_string": "Order equipped with a sensible successor function.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "add_monoid.fg",
    "statement": "structure add_monoid.fg (N : Type u_2) [add_monoid N] : Prop",
    "theorem": "(N : Type u_2) [add_monoid N] : Prop",
    "args": "(N : Type u_2) [add_monoid N]",
    "doc_string": " An additive monoid is finitely generated if it is finitely generated as an additive submonoid of itself.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.free_monoidal_category.normal_monoidal_object",
    "statement": "inductive category_theory.free_monoidal_category.normal_monoidal_object (C : Type u) : Type u",
    "theorem": "(C : Type u) : Type u",
    "args": "(C : Type u)",
    "doc_string": "We say an object in the free monoidal category is in normal form if it is of the form    `(((𝟙_ C) ⊗ X₁) ⊗ X₂) ⊗ ⋯`.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "function.maps_to_fixed_pts_comp",
    "statement": "theorem function.maps_to_fixed_pts_comp {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g))",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g))",
    "args": "{α : Type u} {β : Type v} (f : α → β) (g : β → α)",
    "doc_string": "Any map `f` sends fixed points of `g ∘ f` to fixed points of `f ∘ g`.",
    "kind": "theorem",
    "type": "set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g))"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts_of_finite_biproducts",
    "statement": "theorem category_theory.limits.has_binary_biproducts_of_finite_biproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C]",
    "doc_string": "A category with finite biproducts has binary biproducts.  This is not an instance as typically in concrete categories there will be an alternative construction with nicer definitional properties.",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_biproducts C"
  },
  {
    "name": "valuation.integer",
    "statement": "def valuation.integer {R : Type u} {Γ₀ : Type v} [ring R] [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : subring R",
    "theorem": "{R : Type u} {Γ₀ : Type v} [ring R] [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : subring R",
    "args": "{R : Type u} {Γ₀ : Type v} [ring R] [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀)",
    "doc_string": "The ring of integers under a given valuation is the subring of elements with valuation ≤ 1.",
    "kind": "def",
    "type": "subring R"
  },
  {
    "name": "function.End.apply_mul_action",
    "statement": "def function.End.apply_mul_action {α : Type u_6} : mul_action (function.End α) α",
    "theorem": "{α : Type u_6} : mul_action (function.End α) α",
    "args": "{α : Type u_6}",
    "doc_string": " The tautological action by `function.End α` on `α`.  This is generalized to bundled endomorphisms by: * `equiv.perm.apply_mul_action` * `add_monoid.End.apply_distrib_mul_action` * `add_aut.apply_distrib_mul_action` * `mul_aut.apply_mul_distrib_mul_action` * `ring_hom.apply_distrib_mul_action` * `linear_equiv.apply_distrib_mul_action` * `linear_map.apply_module` * `ring_hom.apply_mul_semiring_action` * `alg_equiv.apply_mul_semiring_action`",
    "kind": "def",
    "type": "mul_action (function.End α) α"
  },
  {
    "name": "euclidean_half_space",
    "statement": "def euclidean_half_space (n : ℕ) [has_zero (fin n)] : Type",
    "theorem": "(n : ℕ) [has_zero (fin n)] : Type",
    "args": "(n : ℕ) [has_zero (fin n)]",
    "doc_string": "The half-space in `ℝ^n`, used to model manifolds with boundary. We only define it when `1 ≤ n`, as the definition only makes sense in this case.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "contravariant.to_right_cancel_add_semigroup",
    "statement": "def contravariant.to_right_cancel_add_semigroup {α : Type u_1} [add_semigroup α] [partial_order α] [contravariant_class α α (function.swap has_add.add) has_le.le] : add_right_cancel_semigroup α",
    "theorem": "{α : Type u_1} [add_semigroup α] [partial_order α] [contravariant_class α α (function.swap has_add.add) has_le.le] : add_right_cancel_semigroup α",
    "args": "{α : Type u_1} [add_semigroup α] [partial_order α] [contravariant_class α α (function.swap has_add.add) has_le.le]",
    "doc_string": "An additive semigroup with a partial order and satisfying `right_cancel_add_semigroup` (`a + c < b + c → a < b`) is a `right_cancel add_semigroup`.",
    "kind": "def",
    "type": "add_right_cancel_semigroup α"
  },
  {
    "name": "add_lt_of_lt_neg_add",
    "statement": "theorem add_lt_of_lt_neg_add {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < -a + c → a + b < c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < -a + c → a + b < c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of lt_inv_mul_iff_mul_lt`.",
    "kind": "theorem",
    "type": "b < -a + c → a + b < c"
  },
  {
    "name": "num.ldiff",
    "statement": "def num.ldiff  : num → num → num",
    "theorem": " : num → num → num",
    "args": "",
    "doc_string": "Bitwise `λ a b, a && !b` for `num`. For example, `ldiff 5 9 = 4`:      101    1001    ----     100",
    "kind": "def",
    "type": "num → num → num"
  },
  {
    "name": "first_order.language.skolem₁_Structure",
    "statement": "def first_order.language.skolem₁_Structure {L : first_order.language} {M : Type w} [nonempty M] [L.Structure M] : L.skolem₁.Structure M",
    "theorem": "{L : first_order.language} {M : Type w} [nonempty M] [L.Structure M] : L.skolem₁.Structure M",
    "args": "{L : first_order.language} {M : Type w} [nonempty M] [L.Structure M]",
    "doc_string": " The structure assigning each function symbol of `L.skolem₁` to a skolem function generated with choice.",
    "kind": "def",
    "type": "L.skolem₁.Structure M"
  },
  {
    "name": "is_add_subgroup.trivial",
    "statement": "def is_add_subgroup.trivial (G : Type u_1) [add_group G] : set G",
    "theorem": "(G : Type u_1) [add_group G] : set G",
    "args": "(G : Type u_1) [add_group G]",
    "doc_string": "the trivial additive subgroup",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "add_submonoid.left_neg",
    "statement": "def add_submonoid.left_neg {M : Type u_1} [add_monoid M] (S : add_submonoid M) : add_submonoid M",
    "theorem": "{M : Type u_1} [add_monoid M] (S : add_submonoid M) : add_submonoid M",
    "args": "{M : Type u_1} [add_monoid M] (S : add_submonoid M)",
    "doc_string": "`S.left_neg` is the additive submonoid containing all the left additive inverses of `S`.",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "solvable_by_rad",
    "statement": "def solvable_by_rad (F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : intermediate_field F E",
    "theorem": "(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : intermediate_field F E",
    "args": "(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E]",
    "doc_string": "The intermediate field of solvable-by-radicals elements",
    "kind": "def",
    "type": "intermediate_field F E"
  },
  {
    "name": "two_pointing.Prop",
    "statement": "def two_pointing.Prop  : two_pointing Prop",
    "theorem": " : two_pointing Prop",
    "args": "",
    "doc_string": "The `false`, `true` two-pointing of `Prop`.",
    "kind": "def",
    "type": "two_pointing Prop"
  },
  {
    "name": "encodable.choose",
    "statement": "def encodable.choose {α : Type u_1} {p : α → Prop} [encodable α] [decidable_pred p] (h : ∃ (x : α), p x) : α",
    "theorem": "{α : Type u_1} {p : α → Prop} [encodable α] [decidable_pred p] (h : ∃ (x : α), p x) : α",
    "args": "{α : Type u_1} {p : α → Prop} [encodable α] [decidable_pred p] (h : ∃ (x : α), p x)",
    "doc_string": "Constructive choice function for a decidable predicate over an encodable type.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "filter.tendsto_mul_left_cobounded",
    "statement": "theorem filter.tendsto_mul_left_cobounded {α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "theorem": "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "args": "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0)",
    "doc_string": " Multiplication on the left by a nonzero element of a normed division ring tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`.",
    "kind": "theorem",
    "type": "filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"
  },
  {
    "name": "ordered_comm_group.mul_lt_mul_left'",
    "statement": "theorem ordered_comm_group.mul_lt_mul_left' {α : Type u_1} [has_mul α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α) : a * b < a * c",
    "theorem": "{α : Type u_1} [has_mul α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α) : a * b < a * c",
    "args": "{α : Type u_1} [has_mul α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α)",
    "doc_string": "**Alias** of mul_lt_mul_left'`.",
    "kind": "theorem",
    "type": "a * b < a * c"
  },
  {
    "name": "classical.arbitrary",
    "statement": "def classical.arbitrary (α : Sort u_1) [h : nonempty α] : α",
    "theorem": "(α : Sort u_1) [h : nonempty α] : α",
    "args": "(α : Sort u_1) [h : nonempty α]",
    "doc_string": "Using `classical.choice`, extracts a term from a `nonempty` type.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "pgame.first_wins",
    "statement": "def pgame.first_wins (G : pgame) : Prop",
    "theorem": "(G : pgame) : Prop",
    "args": "(G : pgame)",
    "doc_string": "The player who goes first wins",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "sequentially_complete.set_seq",
    "statement": "def sequentially_complete.set_seq {α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (n : ℕ) : set α",
    "theorem": "{α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (n : ℕ) : set α",
    "args": "{α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (n : ℕ)",
    "doc_string": " Given a Cauchy filter `f` and a sequence `U` of entourages, `set_seq` provides an antitone sequence of sets `s n ∈ f` such that `s n ×ˢ s n ⊆ U`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "finmap.extract",
    "statement": "def finmap.extract {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β) : option (β a) × finmap β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β) : option (β a) × finmap β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β)",
    "doc_string": "Erase a key from the map, and return the corresponding value, if found.",
    "kind": "def",
    "type": "option (β a) × finmap β"
  },
  {
    "name": "le_refl",
    "statement": "theorem le_refl {α : Type u} [preorder α] (a : α) : a ≤ a",
    "theorem": "{α : Type u} [preorder α] (a : α) : a ≤ a",
    "args": "{α : Type u} [preorder α] (a : α)",
    "doc_string": "The relation `≤` on a preorder is reflexive.",
    "kind": "theorem",
    "type": "a ≤ a"
  },
  {
    "name": "add_subgroup.normalizer",
    "statement": "def add_subgroup.normalizer {G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G)",
    "doc_string": "The `normalizer` of `H` is the largest subgroup of `G` inside which `H` is normal.",
    "kind": "def",
    "type": "add_subgroup G"
  },
  {
    "name": "ultrafilter.bind",
    "statement": "def ultrafilter.bind {α : Type u} {β : Type v} (f : ultrafilter α) (m : α → ultrafilter β) : ultrafilter β",
    "theorem": "{α : Type u} {β : Type v} (f : ultrafilter α) (m : α → ultrafilter β) : ultrafilter β",
    "args": "{α : Type u} {β : Type v} (f : ultrafilter α) (m : α → ultrafilter β)",
    "doc_string": " Monadic bind for ultrafilters, coming from the one on filters defined in terms of map and join.",
    "kind": "def",
    "type": "ultrafilter β"
  },
  {
    "name": "mul_lt_one",
    "statement": "theorem mul_lt_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": "**Alias** of left.mul_lt_one`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "ordnode.balance_l'",
    "statement": "def ordnode.balance_l' {α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "theorem": "{α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "args": "{α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α)",
    "doc_string": " A left balance operation. This will rebalance a concatenation, assuming the original nodes are not too far from balanced.",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "pos_num.succ",
    "statement": "def pos_num.succ  : pos_num → pos_num",
    "theorem": " : pos_num → pos_num",
    "args": "",
    "doc_string": "The successor of a `pos_num`.",
    "kind": "def",
    "type": "pos_num → pos_num"
  },
  {
    "name": "multiset.foldr",
    "statement": "def multiset.foldr {α : Type u_1} {β : Type u_2} (f : α → β → β) (H : left_commutative f) (b : β) (s : multiset α) : β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β → β) (H : left_commutative f) (b : β) (s : multiset α) : β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β → β) (H : left_commutative f) (b : β) (s : multiset α)",
    "doc_string": "`foldr f H b s` is the lift of the list operation `foldr f b l`,  which folds `f` over the multiset. It is well defined when `f` is left-commutative,  that is, `f a₁ (f a₂ b) = f a₂ (f a₁ b)`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "ordnode.drop_while",
    "statement": "def ordnode.drop_while {α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p]",
    "doc_string": " O(log n). Remove an initial segment of the set that satisfies the predicate `p`. `p` is required to be antitone, that is, `x < y → p y → p x`.      drop_while (λ x, x < 4) {1, 2, 3, 4, 5} = {4, 5}     drop_while (λ x, x > 4) {1, 2, 3, 4, 5} = precondition violation",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "matrix.star_add_monoid",
    "statement": "def matrix.star_add_monoid {n : Type u_3} {α : Type v} [add_monoid α] [star_add_monoid α] : star_add_monoid (matrix n n α)",
    "theorem": "{n : Type u_3} {α : Type v} [add_monoid α] [star_add_monoid α] : star_add_monoid (matrix n n α)",
    "args": "{n : Type u_3} {α : Type v} [add_monoid α] [star_add_monoid α]",
    "doc_string": "When `α` is a `*`-additive monoid, `matrix.has_star` is also a `*`-additive monoid.",
    "kind": "def",
    "type": "star_add_monoid (matrix n n α)"
  },
  {
    "name": "category_theory.limits.split_mono_coprod_inl",
    "statement": "def category_theory.limits.split_mono_coprod_inl {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inl",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inl",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)]",
    "doc_string": "In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms.",
    "kind": "def",
    "type": "category_theory.split_mono category_theory.limits.coprod.inl"
  },
  {
    "name": "category_theory.simple_iff_subobject_is_simple_order",
    "statement": "theorem category_theory.simple_iff_subobject_is_simple_order {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ↔ is_simple_order (category_theory.subobject X)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ↔ is_simple_order (category_theory.subobject X)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C)",
    "doc_string": "`X` is simple iff it has subobject lattice `{⊥, ⊤}`.",
    "kind": "theorem",
    "type": "category_theory.simple X ↔ is_simple_order (category_theory.subobject X)"
  },
  {
    "name": "category_theory.graded_object",
    "statement": "def category_theory.graded_object (β : Type w) (C : Type u) : Type (max w u)",
    "theorem": "(β : Type w) (C : Type u) : Type (max w u)",
    "args": "(β : Type w) (C : Type u)",
    "doc_string": "A type synonym for `β → C`, used for `β`-graded objects in a category `C`.",
    "kind": "def",
    "type": "Type (max w u)"
  },
  {
    "name": "partial_order.to_circular_partial_order",
    "statement": "def partial_order.to_circular_partial_order (α : Type u_1) [partial_order α] : circular_partial_order α",
    "theorem": "(α : Type u_1) [partial_order α] : circular_partial_order α",
    "args": "(α : Type u_1) [partial_order α]",
    "doc_string": " The circular partial order obtained from \"looping around\" a partial order. See note [reducible non-instances].",
    "kind": "def",
    "type": "circular_partial_order α"
  },
  {
    "name": "thunk",
    "statement": "def thunk (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Gadget for defining thunks, thunk parameters have special treatment. Example: given       def f (s : string) (t : thunk nat) : nat an application      f \"hello\" 10  is converted into      f \"hello\" (λ _, 10)",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "subsemiring.copy",
    "statement": "def subsemiring.copy {R : Type u} [non_assoc_semiring R] (S : subsemiring R) (s : set R) (hs : s = ↑S) : subsemiring R",
    "theorem": "{R : Type u} [non_assoc_semiring R] (S : subsemiring R) (s : set R) (hs : s = ↑S) : subsemiring R",
    "args": "{R : Type u} [non_assoc_semiring R] (S : subsemiring R) (s : set R) (hs : s = ↑S)",
    "doc_string": " Copy of a subsemiring with a new `carrier` equal to the old one. Useful to fix definitional equalities.",
    "kind": "def",
    "type": "subsemiring R"
  },
  {
    "name": "mk_simp_attr_decl_name",
    "statement": "constant mk_simp_attr_decl_name (attr_name : name) : name",
    "theorem": "(attr_name : name) : name",
    "args": "(attr_name : name)",
    "doc_string": "Prefix the given `attr_name` with `\"simp_attr\"`.",
    "kind": "constant",
    "type": "name"
  },
  {
    "name": "set.monotone_image",
    "statement": "theorem set.monotone_image {α : Type u_1} {β : Type u_2} {f : α → β} : monotone (set.image f)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} : monotone (set.image f)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β}",
    "doc_string": "`set.image` is monotone. See `set.image_image` for the statement in terms of `⊆`.",
    "kind": "theorem",
    "type": "monotone (set.image f)"
  },
  {
    "name": "prefunctor.id",
    "statement": "def prefunctor.id (V : Type u_1) [quiver V] : prefunctor V V",
    "theorem": "(V : Type u_1) [quiver V] : prefunctor V V",
    "args": "(V : Type u_1) [quiver V]",
    "doc_string": "The identity morphism between quivers.",
    "kind": "def",
    "type": "prefunctor V V"
  },
  {
    "name": "first_order.language.is_ordered",
    "statement": "structure first_order.language.is_ordered (L : first_order.language) : Type v",
    "theorem": "(L : first_order.language) : Type v",
    "args": "(L : first_order.language)",
    "doc_string": "A language is ordered if it has a symbol representing `≤`.",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "category_theory.exponentiable",
    "statement": "def category_theory.exponentiable {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] (X : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] (X : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] (X : C)",
    "doc_string": "An object `X` is *exponentiable* if `(X × -)` is a left adjoint. We define this as being `closed` in the cartesian monoidal structure.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "set_like.has_graded_one",
    "statement": "structure set_like.has_graded_one {ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_one R] [has_zero ι] (A : ι → S) : Prop",
    "theorem": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_one R] [has_zero ι] (A : ι → S) : Prop",
    "args": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_one R] [has_zero ι] (A : ι → S)",
    "doc_string": "A version of `graded_monoid.ghas_one` for internally graded objects.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "affine_subspace.pointwise_add_action",
    "statement": "def affine_subspace.pointwise_add_action {k : Type u_1} [ring k] {V : Type u_2} {P : Type u_3} [add_comm_group V] [module k V] [add_torsor V P] : add_action V (affine_subspace k P)",
    "theorem": "{k : Type u_1} [ring k] {V : Type u_2} {P : Type u_3} [add_comm_group V] [module k V] [add_torsor V P] : add_action V (affine_subspace k P)",
    "args": "{k : Type u_1} [ring k] {V : Type u_2} {P : Type u_3} [add_comm_group V] [module k V] [add_torsor V P]",
    "doc_string": " The additive action on an affine subspace corresponding to applying the action to every element.  This is available as an instance in the `pointwise` locale.",
    "kind": "def",
    "type": "add_action V (affine_subspace k P)"
  },
  {
    "name": "algebra_int",
    "statement": "def algebra_int (R : Type u_1) [ring R] : algebra ℤ R",
    "theorem": "(R : Type u_1) [ring R] : algebra ℤ R",
    "args": "(R : Type u_1) [ring R]",
    "doc_string": "Ring ⥤ ℤ-Alg",
    "kind": "def",
    "type": "algebra ℤ R"
  },
  {
    "name": "multiset",
    "statement": "def multiset (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "`multiset α` is the quotient of `list α` by list permutation. The result  is a type of finite sets with duplicates allowed.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "set.unbounded",
    "statement": "def set.unbounded {α : Type u} (r : α → α → Prop) (s : set α) : Prop",
    "theorem": "{α : Type u} (r : α → α → Prop) (s : set α) : Prop",
    "args": "{α : Type u} (r : α → α → Prop) (s : set α)",
    "doc_string": "An unbounded or cofinal set.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ring.inverse",
    "statement": "def ring.inverse {M₀ : Type u_1} [monoid_with_zero M₀] : M₀ → M₀",
    "theorem": "{M₀ : Type u_1} [monoid_with_zero M₀] : M₀ → M₀",
    "args": "{M₀ : Type u_1} [monoid_with_zero M₀]",
    "doc_string": " Introduce a function `inverse` on a monoid with zero `M₀`, which sends `x` to `x⁻¹` if `x` is invertible and to `0` otherwise.  This definition is somewhat ad hoc, but one needs a fully (rather than partially) defined inverse function for some purposes, including for calculus.  Note that while this is in the `ring` namespace for brevity, it requires the weaker assumption `monoid_with_zero M₀` instead of `ring M₀`.",
    "kind": "def",
    "type": "M₀ → M₀"
  },
  {
    "name": "real.tendsto_exp_neg_at_top_nhds_0",
    "statement": "theorem real.tendsto_exp_neg_at_top_nhds_0  : filter.tendsto (λ (x : ℝ), real.exp (-x)) filter.at_top (nhds 0)",
    "theorem": " : filter.tendsto (λ (x : ℝ), real.exp (-x)) filter.at_top (nhds 0)",
    "args": "",
    "doc_string": " The real exponential function tends to `0` at `-∞` or, equivalently, `exp(-x)` tends to `0` at `+∞`",
    "kind": "theorem",
    "type": "filter.tendsto (λ (x : ℝ), real.exp (-x)) filter.at_top (nhds 0)"
  },
  {
    "name": "continuous_add_monoid_hom.zero",
    "statement": "def continuous_add_monoid_hom.zero (A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A B",
    "theorem": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A B",
    "args": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The trivial continuous homomorphism.",
    "kind": "def",
    "type": "continuous_add_monoid_hom A B"
  },
  {
    "name": "clifford_algebra.graded_algebra",
    "statement": "def clifford_algebra.graded_algebra {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) : graded_algebra (clifford_algebra.even_odd Q)",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) : graded_algebra (clifford_algebra.even_odd Q)",
    "args": "{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M)",
    "doc_string": "The clifford algebra is graded by the even and odd parts.",
    "kind": "def",
    "type": "graded_algebra (clifford_algebra.even_odd Q)"
  },
  {
    "name": "add_hom.eq_mlocus",
    "statement": "def add_hom.eq_mlocus {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f g : add_hom M N) : add_subsemigroup M",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f g : add_hom M N) : add_subsemigroup M",
    "args": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f g : add_hom M N)",
    "doc_string": "The additive subsemigroup of elements `x : M` such that `f x = g x`",
    "kind": "def",
    "type": "add_subsemigroup M"
  },
  {
    "name": "list.next_or",
    "statement": "def list.next_or {α : Type u_1} [decidable_eq α] (xs : list α) (x default : α) : α",
    "theorem": "{α : Type u_1} [decidable_eq α] (xs : list α) (x default : α) : α",
    "args": "{α : Type u_1} [decidable_eq α] (xs : list α) (x default : α)",
    "doc_string": "Return the `z` such that `x :: z :: _` appears in `xs`, or `default` if there is no such `z`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "pseudo_metric_quot",
    "statement": "def pseudo_metric_quot (α : Type u) [pseudo_metric_space α] : Type u",
    "theorem": "(α : Type u) [pseudo_metric_space α] : Type u",
    "args": "(α : Type u) [pseudo_metric_space α]",
    "doc_string": "The canonical quotient of a pseudometric space, identifying points at distance `0`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "eq.ge",
    "statement": "theorem eq.ge {α : Type u} [preorder α] {x y : α} (h : x = y) : y ≤ x",
    "theorem": "{α : Type u} [preorder α] {x y : α} (h : x = y) : y ≤ x",
    "args": "{α : Type u} [preorder α] {x y : α} (h : x = y)",
    "doc_string": " If `x = y` then `y ≤ x`. Note: this lemma uses `y ≤ x` instead of `x ≥ y`, because `le` is used almost exclusively in mathlib.",
    "kind": "theorem",
    "type": "y ≤ x"
  },
  {
    "name": "mvfunctor.supp",
    "statement": "def mvfunctor.supp {n : ℕ} {F : typevec n → Type v} [mvfunctor F] {α : typevec n} (x : F α) (i : fin2 n) : set (α i)",
    "theorem": "{n : ℕ} {F : typevec n → Type v} [mvfunctor F] {α : typevec n} (x : F α) (i : fin2 n) : set (α i)",
    "args": "{n : ℕ} {F : typevec n → Type v} [mvfunctor F] {α : typevec n} (x : F α) (i : fin2 n)",
    "doc_string": " given `x : F α` and a projection `i` of type vector `α`, `supp x i` is the set of `α.i` contained in `x`",
    "kind": "def",
    "type": "set (α i)"
  },
  {
    "name": "add_monoid.exponent_exists",
    "statement": "def add_monoid.exponent_exists (G : Type u) [add_monoid G] : Prop",
    "theorem": "(G : Type u) [add_monoid G] : Prop",
    "args": "(G : Type u) [add_monoid G]",
    "doc_string": "A predicate on an additive monoid saying that there is a positive integer `n` such   that `n • g = 0` for all `g`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "polish_space.aux_copy",
    "statement": "def polish_space.aux_copy (α : Type u_1) {ι : Type u_2} (i : ι) : Type u_1",
    "theorem": "(α : Type u_1) {ι : Type u_2} (i : ι) : Type u_1",
    "args": "(α : Type u_1) {ι : Type u_2} (i : ι)",
    "doc_string": " A sequence of type synonyms of a given type `α`, useful in the proof of `exists_polish_space_forall_le` to endow each copy with a different topology.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "balanced.absorbs_self",
    "statement": "theorem balanced.absorbs_self {𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} (hA : balanced 𝕜 A) : absorbs 𝕜 A A",
    "theorem": "{𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} (hA : balanced 𝕜 A) : absorbs 𝕜 A A",
    "args": "{𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} (hA : balanced 𝕜 A)",
    "doc_string": "A balanced set absorbs itself.",
    "kind": "theorem",
    "type": "absorbs 𝕜 A A"
  },
  {
    "name": "function.bijective.exists_unique",
    "statement": "theorem function.bijective.exists_unique {α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : function.bijective f) (b : β) : ∃! (a : α), f a = b",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : function.bijective f) (b : β) : ∃! (a : α), f a = b",
    "args": "{α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : function.bijective f) (b : β)",
    "doc_string": "Shorthand for using projection notation with `function.bijective_iff_exists_unique`.",
    "kind": "theorem",
    "type": "∃! (a : α), f a = b"
  },
  {
    "name": "poly",
    "statement": "def poly (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "The type of multivariate integer polynomials",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "subgroup.of",
    "statement": "def subgroup.of {G : Type u_1} [group G] {s : set G} (h : is_subgroup s) : subgroup G",
    "theorem": "{G : Type u_1} [group G] {s : set G} (h : is_subgroup s) : subgroup G",
    "args": "{G : Type u_1} [group G] {s : set G} (h : is_subgroup s)",
    "doc_string": "Create a bundled subgroup from a set `s` and `[is_subgroup s]`.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "eq.le",
    "statement": "theorem eq.le {α : Type u} [preorder α] {a b : α} : a = b → a ≤ b",
    "theorem": "{α : Type u} [preorder α] {a b : α} : a = b → a ≤ b",
    "args": "{α : Type u} [preorder α] {a b : α}",
    "doc_string": "**Alias** of le_of_eq`.",
    "kind": "theorem",
    "type": "a = b → a ≤ b"
  },
  {
    "name": "category_theory.limits.walking_span",
    "statement": "def category_theory.limits.walking_span  : Type v",
    "theorem": " : Type v",
    "args": "",
    "doc_string": "The type of objects for the diagram indexing a pushout, defined as a special case of `wide_pushout_shape`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "pythagorean_triple.mul",
    "statement": "theorem pythagorean_triple.mul {x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ) : pythagorean_triple (k * x) (k * y) (k * z)",
    "theorem": "{x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ) : pythagorean_triple (k * x) (k * y) (k * z)",
    "args": "{x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ)",
    "doc_string": " A triple is still a triple if you multiply `x`, `y` and `z` by a constant `k`.",
    "kind": "theorem",
    "type": "pythagorean_triple (k * x) (k * y) (k * z)"
  },
  {
    "name": "omega.update_zero",
    "statement": "def omega.update_zero {α : Type} (a : α) (v : ℕ → α) : ℕ → α",
    "theorem": "{α : Type} (a : α) (v : ℕ → α) : ℕ → α",
    "args": "{α : Type} (a : α) (v : ℕ → α)",
    "doc_string": "Assign a new value to the zeroth variable, and push all    other assignments up by 1",
    "kind": "def",
    "type": "ℕ → α"
  },
  {
    "name": "le_csupr",
    "statement": "theorem le_csupr {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι)",
    "doc_string": "The indexed supremum of a function is bounded below by the value taken at one point",
    "kind": "theorem",
    "type": "f c ≤ supr f"
  },
  {
    "name": "cast_pos_num",
    "statement": "def cast_pos_num {α : Type u_1} [has_one α] [has_add α] : pos_num → α",
    "theorem": "{α : Type u_1} [has_one α] [has_add α] : pos_num → α",
    "args": "{α : Type u_1} [has_one α] [has_add α]",
    "doc_string": "`cast_pos_num` casts a `pos_num` into any type which has `1` and `+`.",
    "kind": "def",
    "type": "pos_num → α"
  },
  {
    "name": "part.fix.approx",
    "statement": "def part.fix.approx {α : Type u_1} {β : α → Type u_2} (f : (Π (a : α), part (β a)) → Π (a : α), part (β a)) : stream (Π (a : α), part (β a))",
    "theorem": "{α : Type u_1} {β : α → Type u_2} (f : (Π (a : α), part (β a)) → Π (a : α), part (β a)) : stream (Π (a : α), part (β a))",
    "args": "{α : Type u_1} {β : α → Type u_2} (f : (Π (a : α), part (β a)) → Π (a : α), part (β a))",
    "doc_string": " A series of successive, finite approximation of the fixed point of `f`, defined by `approx f n = f^[n] ⊥`. The limit of this chain is the fixed point of `f`.",
    "kind": "def",
    "type": "stream (Π (a : α), part (β a))"
  },
  {
    "name": "star_ring",
    "statement": "structure star_ring (R : Type u) [non_unital_semiring R] : Type u",
    "theorem": "(R : Type u) [non_unital_semiring R] : Type u",
    "args": "(R : Type u) [non_unital_semiring R]",
    "doc_string": "A `*`-ring `R` is a (semi)ring with an involutive `star` operation which is additive which makes `R` with its multiplicative structure into a `*`-semigroup (i.e. `star (r * s) = star s * star r`).",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "simple_graph.locally_finite",
    "statement": "def simple_graph.locally_finite {V : Type u} (G : simple_graph V) : Type u",
    "theorem": "{V : Type u} (G : simple_graph V) : Type u",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": "A graph is locally finite if every vertex has a finite neighbor set.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "category_theory.free_bicategory.inclusion_path_aux",
    "statement": "def category_theory.free_bicategory.inclusion_path_aux {B : Type u} [quiver B] {a b : B} : quiver.path a b → category_theory.free_bicategory.hom a b",
    "theorem": "{B : Type u} [quiver B] {a b : B} : quiver.path a b → category_theory.free_bicategory.hom a b",
    "args": "{B : Type u} [quiver B] {a b : B}",
    "doc_string": "Auxiliary definition for `inclusion_path`.",
    "kind": "def",
    "type": "quiver.path a b → category_theory.free_bicategory.hom a b"
  },
  {
    "name": "is_max.succ_eq",
    "statement": "theorem is_max.succ_eq {α : Type u_1} [partial_order α] [succ_order α] {a : α} : is_max a → order.succ a = a",
    "theorem": "{α : Type u_1} [partial_order α] [succ_order α] {a : α} : is_max a → order.succ a = a",
    "args": "{α : Type u_1} [partial_order α] [succ_order α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of order.succ_eq_iff_is_max`.",
    "kind": "theorem",
    "type": "is_max a → order.succ a = a"
  },
  {
    "name": "tactic.eliminate.inductive_info",
    "statement": "structure tactic.eliminate.inductive_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Information about an inductive type. Contains:  - `iname`: the type's name. - `constructors`: information about the type's constructors. - `num_constructors`: the length of `constructors`. - `type`: the type's type. - `num_param`: the type's number of parameters. - `num_indices`: the type's number of indices.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "real",
    "statement": "structure real  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The type `ℝ` of real numbers constructed as equivalence classes of Cauchy sequences of rational numbers.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "cau_seq.pos",
    "statement": "def cau_seq.pos {α : Type u_1} [linear_ordered_field α] (f : cau_seq α has_abs.abs) : Prop",
    "theorem": "{α : Type u_1} [linear_ordered_field α] (f : cau_seq α has_abs.abs) : Prop",
    "args": "{α : Type u_1} [linear_ordered_field α] (f : cau_seq α has_abs.abs)",
    "doc_string": "The entries of a positive Cauchy sequence eventually have a positive lower bound.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "structure_groupoid",
    "statement": "structure structure_groupoid (H : Type u) [topological_space H] : Type u",
    "theorem": "(H : Type u) [topological_space H] : Type u",
    "args": "(H : Type u) [topological_space H]",
    "doc_string": " A structure groupoid is a set of local homeomorphisms of a topological space stable under composition and inverse. They appear in the definition of the smoothness class of a manifold.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "vector.to_array",
    "statement": "def vector.to_array {n : ℕ} {α : Type u_1} : vector α n → array n α",
    "theorem": "{n : ℕ} {α : Type u_1} : vector α n → array n α",
    "args": "{n : ℕ} {α : Type u_1}",
    "doc_string": "Cast a vector to an array.",
    "kind": "def",
    "type": "vector α n → array n α"
  },
  {
    "name": "int.fract",
    "statement": "def int.fract {α : Type u_1} [linear_ordered_ring α] [floor_ring α] (a : α) : α",
    "theorem": "{α : Type u_1} [linear_ordered_ring α] [floor_ring α] (a : α) : α",
    "args": "{α : Type u_1} [linear_ordered_ring α] [floor_ring α] (a : α)",
    "doc_string": "`int.fract a`, the fractional part of `a`, is `a` minus its floor.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "CompHaus_to_Top.reflective",
    "statement": "def CompHaus_to_Top.reflective  : category_theory.reflective CompHaus_to_Top",
    "theorem": " : category_theory.reflective CompHaus_to_Top",
    "args": "",
    "doc_string": "The category of compact Hausdorff spaces is reflective in the category of topological spaces.",
    "kind": "def",
    "type": "category_theory.reflective CompHaus_to_Top"
  },
  {
    "name": "pos_num.mod'",
    "statement": "def pos_num.mod' (n d : pos_num) : num",
    "theorem": "(n d : pos_num) : num",
    "args": "(n d : pos_num)",
    "doc_string": "Modulus of `pos_num`s.",
    "kind": "def",
    "type": "num"
  },
  {
    "name": "monoid.exponent",
    "statement": "def monoid.exponent (G : Type u) [monoid G] : ℕ",
    "theorem": "(G : Type u) [monoid G] : ℕ",
    "args": "(G : Type u) [monoid G]",
    "doc_string": "The exponent of a group is the smallest positive integer `n` such that `g ^ n = 1` for all   `g ∈ G` if it exists, otherwise it is zero by convention.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "finset.subtype",
    "statement": "def finset.subtype {α : Type u_1} (p : α → Prop) [decidable_pred p] (s : finset α) : finset (subtype p)",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : finset α) : finset (subtype p)",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : finset α)",
    "doc_string": " Given a finset `s` and a predicate `p`, `s.subtype p` is the finset of `subtype p` whose elements belong to `s`.",
    "kind": "def",
    "type": "finset (subtype p)"
  },
  {
    "name": "linarith.comp_source",
    "statement": "inductive linarith.comp_source  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "`comp_source` tracks the source of a comparison. The atomic source of a comparison is an assumption, indexed by a natural number. Two comparisons can be added to produce a new comparison, and one comparison can be scaled by a natural number to produce a new comparison.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "macro_def",
    "statement": "constant macro_def  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Macros are basically \"promises\" to build an expr by some C++ code, you can't build them in Lean.   You can unfold a macro and force it to evaluate.   They are used for   - `sorry`.   - Term placeholders (`_`) in `pexpr`s.   - Expression annotations. See `expr.is_annotation`.   - Meta-recursive calls. Eg:     ```lean     meta def Y : (α → α) → α | f := f (Y f)     ```     The `Y` that appears in `f (Y f)` is a macro.   - Builtin projections:     ```lean     structure foo := (mynat : ℕ)     #print foo.mynat     -- @[reducible]     -- def foo.mynat : foo → ℕ :=     -- λ (c : foo), [foo.mynat c]     ```     The thing in square brackets is a macro.   - Ephemeral structures inside certain specialised C++ implemented tactics.",
    "kind": "constant",
    "type": "Type"
  },
  {
    "name": "pi.basis_fun",
    "statement": "def pi.basis_fun (R : Type u_1) (η : Type u_2) [semiring R] [fintype η] : basis η R (η → R)",
    "theorem": "(R : Type u_1) (η : Type u_2) [semiring R] [fintype η] : basis η R (η → R)",
    "args": "(R : Type u_1) (η : Type u_2) [semiring R] [fintype η]",
    "doc_string": "The basis on `η → R` where the `i`th basis vector is `function.update 0 i 1`.",
    "kind": "def",
    "type": "basis η R (η → R)"
  },
  {
    "name": "category_theory.abelian.pseudoelement.pseudo_zero_iff",
    "statement": "theorem category_theory.abelian.pseudoelement.pseudo_zero_iff {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : ↑a = 0 ↔ a.hom = 0",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : ↑a = 0 ↔ a.hom = 0",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P)",
    "doc_string": "The pseudoelement induced by an arrow is zero precisely when that arrow is zero",
    "kind": "theorem",
    "type": "↑a = 0 ↔ a.hom = 0"
  },
  {
    "name": "pseudo_metric_space.to_has_nndist",
    "statement": "def pseudo_metric_space.to_has_nndist {α : Type u} [pseudo_metric_space α] : has_nndist α",
    "theorem": "{α : Type u} [pseudo_metric_space α] : has_nndist α",
    "args": "{α : Type u} [pseudo_metric_space α]",
    "doc_string": "Distance as a nonnegative real number.",
    "kind": "def",
    "type": "has_nndist α"
  },
  {
    "name": "galois_coinsertion.lift_bounded_order",
    "statement": "def galois_coinsertion.lift_bounded_order {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [preorder β] [bounded_order β] (gi : galois_coinsertion l u) : bounded_order α",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [preorder β] [bounded_order β] (gi : galois_coinsertion l u) : bounded_order α",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [preorder β] [bounded_order β] (gi : galois_coinsertion l u)",
    "doc_string": "Lift the top, bottom, suprema, and infima along a Galois coinsertion",
    "kind": "def",
    "type": "bounded_order α"
  },
  {
    "name": "topological_space.complete_lattice",
    "statement": "def topological_space.complete_lattice {α : Type u} : complete_lattice (topological_space α)",
    "theorem": "{α : Type u} : complete_lattice (topological_space α)",
    "args": "{α : Type u}",
    "doc_string": "Topologies on `α` form a complete lattice, with `⊥` the discrete topology  and `⊤` the indiscrete topology. The infimum of a collection of topologies  is the topology generated by all their open sets, while the supremum is the  topology whose open sets are those sets open in every member of the collection.",
    "kind": "def",
    "type": "complete_lattice (topological_space α)"
  },
  {
    "name": "add_torsion",
    "statement": "def add_torsion (G : Type u_1) [add_comm_group G] : add_subgroup G",
    "theorem": "(G : Type u_1) [add_comm_group G] : add_subgroup G",
    "args": "(G : Type u_1) [add_comm_group G]",
    "doc_string": "The torsion subgroup of an additive abelian group.",
    "kind": "def",
    "type": "add_subgroup G"
  },
  {
    "name": "and_or_distrib_left",
    "statement": "theorem and_or_distrib_left {a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c",
    "theorem": "{a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c",
    "args": "{a b c : Prop}",
    "doc_string": "`∧` distributes over `∨` (on the left).",
    "kind": "theorem",
    "type": "a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c"
  },
  {
    "name": "cycle.subsingleton",
    "statement": "def cycle.subsingleton {α : Type u_1} (s : cycle α) : Prop",
    "theorem": "{α : Type u_1} (s : cycle α) : Prop",
    "args": "{α : Type u_1} (s : cycle α)",
    "doc_string": "A `s : cycle α` that is at most one element.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "set.antitone_bforall",
    "statement": "theorem set.antitone_bforall {α : Type u_1} {P : α → Prop} : antitone (λ (s : set α), ∀ (x : α), x ∈ s → P x)",
    "theorem": "{α : Type u_1} {P : α → Prop} : antitone (λ (s : set α), ∀ (x : α), x ∈ s → P x)",
    "args": "{α : Type u_1} {P : α → Prop}",
    "doc_string": "Quantifying over a set is antitone in the set",
    "kind": "theorem",
    "type": "antitone (λ (s : set α), ∀ (x : α), x ∈ s → P x)"
  },
  {
    "name": "has_lt.lt.trans'",
    "statement": "theorem has_lt.lt.trans' {α : Type u} [preorder α] {a b c : α} : b < c → a < b → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b < c → a < b → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_trans'`.",
    "kind": "theorem",
    "type": "b < c → a < b → a < c"
  },
  {
    "name": "is_unit",
    "statement": "def is_unit {M : Type u_1} [monoid M] (a : M) : Prop",
    "theorem": "{M : Type u_1} [monoid M] (a : M) : Prop",
    "args": "{M : Type u_1} [monoid M] (a : M)",
    "doc_string": " An element `a : M` of a monoid is a unit if it has a two-sided inverse. The actual definition says that `a` is equal to some `u : Mˣ`, where `Mˣ` is a bundled version of `is_unit`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bitvec.of_fin",
    "statement": "def bitvec.of_fin {n : ℕ} (i : fin (2 ^ n)) : bitvec n",
    "theorem": "{n : ℕ} (i : fin (2 ^ n)) : bitvec n",
    "args": "{n : ℕ} (i : fin (2 ^ n))",
    "doc_string": "convert `fin` to `bitvec`",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "list.dedupkeys",
    "statement": "def list.dedupkeys {α : Type u} {β : α → Type v} [decidable_eq α] : list (sigma β) → list (sigma β)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] : list (sigma β) → list (sigma β)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α]",
    "doc_string": "Remove entries with duplicate keys from `l : list (sigma β)`.",
    "kind": "def",
    "type": "list (sigma β) → list (sigma β)"
  },
  {
    "name": "or_and_distrib_right",
    "statement": "theorem or_and_distrib_right {a b c : Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c",
    "theorem": "{a b c : Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c",
    "args": "{a b c : Prop}",
    "doc_string": "`∧` distributes over `∨` (on the right).",
    "kind": "theorem",
    "type": "(a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c"
  },
  {
    "name": "is_right_regular",
    "statement": "def is_right_regular {R : Type u_1} [has_mul R] (c : R) : Prop",
    "theorem": "{R : Type u_1} [has_mul R] (c : R) : Prop",
    "args": "{R : Type u_1} [has_mul R] (c : R)",
    "doc_string": " A right-regular element is an element `c` such that multiplication on the right by `c` is injective.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "group.normal_closure.is_normal",
    "statement": "theorem group.normal_closure.is_normal {G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)",
    "theorem": "{G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)",
    "args": "{G : Type u_1} {s : set G} [group G]",
    "doc_string": "The normal closure of s is a normal subgroup.",
    "kind": "theorem",
    "type": "is_normal_subgroup (group.normal_closure s)"
  },
  {
    "name": "sub_right_lt_of_lt_add",
    "statement": "theorem sub_right_lt_of_lt_add {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < b + c → a - c < b",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < b + c → a - c < b",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of sub_lt_iff_lt_add`.",
    "kind": "theorem",
    "type": "a < b + c → a - c < b"
  },
  {
    "name": "is_integrally_closed",
    "statement": "structure is_integrally_closed (R : Type u_1) [comm_ring R] [is_domain R] : Prop",
    "theorem": "(R : Type u_1) [comm_ring R] [is_domain R] : Prop",
    "args": "(R : Type u_1) [comm_ring R] [is_domain R]",
    "doc_string": " `R` is integrally closed if all integral elements of `Frac(R)` are also elements of `R`.  This definition uses `fraction_ring R` to denote `Frac(R)`. See `is_integrally_closed_iff` if you want to choose another field of fractions for `R`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "fintype.of_multiset",
    "statement": "def fintype.of_multiset {α : Type u_1} [decidable_eq α] (s : multiset α) (H : ∀ (x : α), x ∈ s) : fintype α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : multiset α) (H : ∀ (x : α), x ∈ s) : fintype α",
    "args": "{α : Type u_1} [decidable_eq α] (s : multiset α) (H : ∀ (x : α), x ∈ s)",
    "doc_string": "Construct a proof of `fintype α` from a universal multiset",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "le_trans",
    "statement": "theorem le_trans {α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "The relation `≤` on a preorder is transitive.",
    "kind": "theorem",
    "type": "a ≤ b → b ≤ c → a ≤ c"
  },
  {
    "name": "generalized_continued_fraction.convergents'",
    "statement": "def generalized_continued_fraction.convergents' {K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) (n : ℕ) : K",
    "theorem": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) (n : ℕ) : K",
    "args": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) (n : ℕ)",
    "doc_string": "Returns the convergents of `g` by evaluating the fraction described by `g` up to a given position `n`. For example, `convergents' [9; (1, 2), (3, 4), (5, 6)] 2 = 9 + 1 / (2 + 3 / 4)` and `convergents' [9; (1, 2), (3, 4), (5, 6)] 0 = 9`",
    "kind": "def",
    "type": "K"
  },
  {
    "name": "list.foldr_with_index_aux",
    "statement": "def list.foldr_with_index_aux {α : Type u_1} {β : Type u_2} (f : ℕ → α → β → β) : ℕ → β → list α → β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : ℕ → α → β → β) : ℕ → β → list α → β",
    "args": "{α : Type u_1} {β : Type u_2} (f : ℕ → α → β → β)",
    "doc_string": "Auxiliary definition for `foldr_with_index`.",
    "kind": "def",
    "type": "ℕ → β → list α → β"
  },
  {
    "name": "nat.dist",
    "statement": "def nat.dist (n m : ℕ) : ℕ",
    "theorem": "(n m : ℕ) : ℕ",
    "args": "(n m : ℕ)",
    "doc_string": "Distance (absolute value of difference) between natural numbers.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "continuous_map.continuous_curry",
    "statement": "theorem continuous_map.continuous_curry {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)] : continuous continuous_map.curry",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)] : continuous continuous_map.curry",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)]",
    "doc_string": "The currying process is a continuous map between function spaces.",
    "kind": "theorem",
    "type": "continuous continuous_map.curry"
  },
  {
    "name": "ordered_cancel_add_comm_monoid",
    "statement": "structure ordered_cancel_add_comm_monoid (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " An ordered cancellative additive commutative monoid is an additive commutative monoid with a partial order, in which addition is cancellative and monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "finset.add_action_finset",
    "statement": "def finset.add_action_finset {α : Type u_2} {β : Type u_3} [decidable_eq β] [add_monoid α] [add_action α β] : add_action α (finset β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [decidable_eq β] [add_monoid α] [add_action α β] : add_action α (finset β)",
    "args": "{α : Type u_2} {β : Type u_3} [decidable_eq β] [add_monoid α] [add_action α β]",
    "doc_string": "An additive action of an additive monoid on a type `β` gives an additive action on `finset β`.",
    "kind": "def",
    "type": "add_action α (finset β)"
  },
  {
    "name": "fintype.choose",
    "statement": "def fintype.choose {α : Type u_1} [fintype α] (p : α → Prop) [decidable_pred p] (hp : ∃! (a : α), p a) : α",
    "theorem": "{α : Type u_1} [fintype α] (p : α → Prop) [decidable_pred p] (hp : ∃! (a : α), p a) : α",
    "args": "{α : Type u_1} [fintype α] (p : α → Prop) [decidable_pred p] (hp : ∃! (a : α), p a)",
    "doc_string": " Given a fintype `α` and a predicate `p`, associate to a proof that there is a unique element of `α` satisfying `p` this unique element, as an element of `α`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "multiset.to_finset",
    "statement": "def multiset.to_finset {α : Type u_1} [decidable_eq α] (s : multiset α) : finset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : multiset α) : finset α",
    "args": "{α : Type u_1} [decidable_eq α] (s : multiset α)",
    "doc_string": "`to_finset s` removes duplicates from the multiset `s` to produce a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "submonoid.has_top",
    "statement": "def submonoid.has_top {M : Type u_1} [mul_one_class M] : has_top (submonoid M)",
    "theorem": "{M : Type u_1} [mul_one_class M] : has_top (submonoid M)",
    "args": "{M : Type u_1} [mul_one_class M]",
    "doc_string": "The submonoid `M` of the monoid `M`.",
    "kind": "def",
    "type": "has_top (submonoid M)"
  },
  {
    "name": "simple_graph.incidence_set",
    "statement": "def simple_graph.incidence_set {V : Type u} (G : simple_graph V) (v : V) : set (sym2 V)",
    "theorem": "{V : Type u} (G : simple_graph V) (v : V) : set (sym2 V)",
    "args": "{V : Type u} (G : simple_graph V) (v : V)",
    "doc_string": "Set of edges incident to a given vertex, aka incidence set.",
    "kind": "def",
    "type": "set (sym2 V)"
  },
  {
    "name": "submonoid.closure",
    "statement": "def submonoid.closure {M : Type u_1} [mul_one_class M] (s : set M) : submonoid M",
    "theorem": "{M : Type u_1} [mul_one_class M] (s : set M) : submonoid M",
    "args": "{M : Type u_1} [mul_one_class M] (s : set M)",
    "doc_string": "The `submonoid` generated by a set.",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "lie_algebra.f₄",
    "statement": "def lie_algebra.f₄ (R : Type u) [comm_ring R] : Type u",
    "theorem": "(R : Type u) [comm_ring R] : Type u",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "The exceptional split Lie algebra of type f₄.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "zero_lt.right.mul_le_one_of_le_of_le",
    "statement": "theorem zero_lt.right.mul_le_one_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1",
    "theorem": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1",
    "args": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "a * b ≤ 1"
  },
  {
    "name": "multiset.filter_map",
    "statement": "def multiset.filter_map {α : Type u_1} {β : Type u_2} (f : α → option β) (s : multiset α) : multiset β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → option β) (s : multiset α) : multiset β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → option β) (s : multiset α)",
    "doc_string": "`filter_map f s` is a combination filter/map operation on `s`.  The function `f : α → option β` is applied to each element of `s`;  if `f a` is `some b` then `b` is added to the result, otherwise  `a` is removed from the resulting multiset.",
    "kind": "def",
    "type": "multiset β"
  },
  {
    "name": "wseq.all",
    "statement": "def wseq.all {α : Type u} (s : wseq α) (p : α → bool) : computation bool",
    "theorem": "{α : Type u} (s : wseq α) (p : α → bool) : computation bool",
    "args": "{α : Type u} (s : wseq α) (p : α → bool)",
    "doc_string": "Returns `tt` if every element of `s` satisfies `p`",
    "kind": "def",
    "type": "computation bool"
  },
  {
    "name": "list.foldr_with_index_aux_spec",
    "statement": "def list.foldr_with_index_aux_spec {α : Type u} {β : Type v} (f : ℕ → α → β → β) (start : ℕ) (b : β) (as : list α) : β",
    "theorem": "{α : Type u} {β : Type v} (f : ℕ → α → β → β) (start : ℕ) (b : β) (as : list α) : β",
    "args": "{α : Type u} {β : Type v} (f : ℕ → α → β → β) (start : ℕ) (b : β) (as : list α)",
    "doc_string": "Specification of `foldr_with_index_aux`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "lie_subalgebra.has_zero",
    "statement": "def lie_subalgebra.has_zero (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : has_zero (lie_subalgebra R L)",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : has_zero (lie_subalgebra R L)",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": "The zero algebra is a subalgebra of any Lie algebra.",
    "kind": "def",
    "type": "has_zero (lie_subalgebra R L)"
  },
  {
    "name": "bdd_above.inter_of_right",
    "statement": "theorem bdd_above.inter_of_right {α : Type u} [preorder α] {s t : set α} (h : bdd_above t) : bdd_above (s ∩ t)",
    "theorem": "{α : Type u} [preorder α] {s t : set α} (h : bdd_above t) : bdd_above (s ∩ t)",
    "args": "{α : Type u} [preorder α] {s t : set α} (h : bdd_above t)",
    "doc_string": "If `t` is bounded, then so is `s ∩ t`",
    "kind": "theorem",
    "type": "bdd_above (s ∩ t)"
  },
  {
    "name": "ordinal.typein",
    "statement": "def ordinal.typein {α : Type u_1} (r : α → α → Prop) [is_well_order α r] (a : α) : ordinal",
    "theorem": "{α : Type u_1} (r : α → α → Prop) [is_well_order α r] (a : α) : ordinal",
    "args": "{α : Type u_1} (r : α → α → Prop) [is_well_order α r] (a : α)",
    "doc_string": " The order type of an element inside a well order. For the embedding as a principal segment, see `typein.principal_seg`.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "ratfunc.denom",
    "statement": "def ratfunc.denom {K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K",
    "theorem": "{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K",
    "args": "{K : Type u} [hfield : field K] (x : ratfunc K)",
    "doc_string": " `ratfunc.denom` is the denominator of a rational function, normalized such that it is monic.",
    "kind": "def",
    "type": "polynomial K"
  },
  {
    "name": "pos_num.pred'",
    "statement": "def pos_num.pred'  : pos_num → num",
    "theorem": " : pos_num → num",
    "args": "",
    "doc_string": "The predecessor of a `pos_num` as a `num`.",
    "kind": "def",
    "type": "pos_num → num"
  },
  {
    "name": "Twop",
    "statement": "structure Twop  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of two-pointed types.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "is_preconnected.closure",
    "statement": "theorem is_preconnected.closure {α : Type u} [topological_space α] {s : set α} (H : is_preconnected s) : is_preconnected (closure s)",
    "theorem": "{α : Type u} [topological_space α] {s : set α} (H : is_preconnected s) : is_preconnected (closure s)",
    "args": "{α : Type u} [topological_space α] {s : set α} (H : is_preconnected s)",
    "doc_string": "The closure of a (pre)connected set is (pre)connected as well.",
    "kind": "theorem",
    "type": "is_preconnected (closure s)"
  },
  {
    "name": "list.permutations'_aux",
    "statement": "def list.permutations'_aux {α : Type u_1} (t : α) : list α → list (list α)",
    "theorem": "{α : Type u_1} (t : α) : list α → list (list α)",
    "args": "{α : Type u_1} (t : α)",
    "doc_string": " `permutations'_aux t ts` inserts `t` into every position in `ts`, including the last. This function is intended for use in specifications, so it is simpler than `permutations_aux2`, which plays roughly the same role in `permutations`.  Note that `(permutations_aux2 t [] [] ts id).2` is similar to this function, but skips the last position:      permutations'_aux 10 [1, 2, 3] =       [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3], [1, 2, 3, 10]]     (permutations_aux2 10 [] [] [1, 2, 3] id).2 =       [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3]]",
    "kind": "def",
    "type": "list α → list (list α)"
  },
  {
    "name": "quandle.dihedral_act",
    "statement": "def quandle.dihedral_act (n : ℕ) (a : zmod n) : zmod n → zmod n",
    "theorem": "(n : ℕ) (a : zmod n) : zmod n → zmod n",
    "args": "(n : ℕ) (a : zmod n)",
    "doc_string": "The operation for the dihedral quandle.  It does not need to be an equivalence because it is an involution (see `dihedral_act.inv`).",
    "kind": "def",
    "type": "zmod n → zmod n"
  },
  {
    "name": "is_symm_op_of_is_symm",
    "statement": "def is_symm_op_of_is_symm (α : Type u) (r : α → α → Prop) [is_symm α r] : is_symm_op α Prop r",
    "theorem": "(α : Type u) (r : α → α → Prop) [is_symm α r] : is_symm_op α Prop r",
    "args": "(α : Type u) (r : α → α → Prop) [is_symm α r]",
    "doc_string": "The opposite of a symmetric relation is symmetric.",
    "kind": "def",
    "type": "is_symm_op α Prop r"
  },
  {
    "name": "has_le.le.antisymm",
    "statement": "theorem has_le.le.antisymm {α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → a = b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → a = b",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of le_antisymm`.",
    "kind": "theorem",
    "type": "a ≤ b → b ≤ a → a = b"
  },
  {
    "name": "has_lipschitz_add.C",
    "statement": "def has_lipschitz_add.C (β : Type u_2) [pseudo_metric_space β] [add_monoid β] [has_lipschitz_add β] : nnreal",
    "theorem": "(β : Type u_2) [pseudo_metric_space β] [add_monoid β] [has_lipschitz_add β] : nnreal",
    "args": "(β : Type u_2) [pseudo_metric_space β] [add_monoid β] [has_lipschitz_add β]",
    "doc_string": "The Lipschitz constant of an `add_monoid` `β` satisfying `has_lipschitz_add`",
    "kind": "def",
    "type": "nnreal"
  },
  {
    "name": "ring.closure",
    "statement": "def ring.closure {R : Type u} [ring R] (s : set R) : set R",
    "theorem": "{R : Type u} [ring R] (s : set R) : set R",
    "args": "{R : Type u} [ring R] (s : set R)",
    "doc_string": " The smallest subring containing a given subset of a ring, considered as a set. This function is deprecated; use `subring.closure`.",
    "kind": "def",
    "type": "set R"
  },
  {
    "name": "submodule.to_add_submonoid",
    "statement": "def submodule.to_add_submonoid {R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : add_submonoid M",
    "theorem": "{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : add_submonoid M",
    "args": "{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M)",
    "doc_string": "Reinterpret a `submodule` as an `add_submonoid`.",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "matrix.update_row",
    "statement": "def matrix.update_row {m : Type u_2} {n : Type u_3} {α : Type v} [decidable_eq m] (M : matrix m n α) (i : m) (b : n → α) : matrix m n α",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} [decidable_eq m] (M : matrix m n α) (i : m) (b : n → α) : matrix m n α",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} [decidable_eq m] (M : matrix m n α) (i : m) (b : n → α)",
    "doc_string": "Update, i.e. replace the `i`th row of matrix `A` with the values in `b`.",
    "kind": "def",
    "type": "matrix m n α"
  },
  {
    "name": "finite_dimensional.fintype_of_fintype",
    "statement": "def finite_dimensional.fintype_of_fintype (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [fintype K] [finite_dimensional K V] : fintype V",
    "theorem": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [fintype K] [finite_dimensional K V] : fintype V",
    "args": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [fintype K] [finite_dimensional K V]",
    "doc_string": "A finite dimensional vector space over a finite field is finite",
    "kind": "def",
    "type": "fintype V"
  },
  {
    "name": "category_theory.limits.coprod",
    "statement": "def category_theory.limits.coprod {C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : C",
    "theorem": "{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : C",
    "args": "{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y]",
    "doc_string": "If we have a coproduct of `X` and `Y`, we can access it using `coprod X Y ` or    `X ⨿ Y`.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "dense_embedding_pure",
    "statement": "theorem dense_embedding_pure {α : Type u} : dense_embedding has_pure.pure",
    "theorem": "{α : Type u} : dense_embedding has_pure.pure",
    "args": "{α : Type u}",
    "doc_string": "`pure : α → ultrafilter α` defines a dense embedding of `α` in `ultrafilter α`.",
    "kind": "theorem",
    "type": "dense_embedding has_pure.pure"
  },
  {
    "name": "ratfunc.num",
    "statement": "def ratfunc.num {K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K",
    "theorem": "{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K",
    "args": "{K : Type u} [hfield : field K] (x : ratfunc K)",
    "doc_string": " `ratfunc.num` is the numerator of a rational function, normalized such that the denominator is monic.",
    "kind": "def",
    "type": "polynomial K"
  },
  {
    "name": "finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero",
    "statement": "theorem finset.sum_centroid_weights_eq_one_of_cast_card_ne_zero {k : Type u_1} [division_ring k] {ι : Type u_4} (s : finset ι) (h : ↑(s.card) ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "theorem": "{k : Type u_1} [division_ring k] {ι : Type u_4} (s : finset ι) (h : ↑(s.card) ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "args": "{k : Type u_1} [division_ring k] {ι : Type u_4} (s : finset ι) (h : ↑(s.card) ≠ 0)",
    "doc_string": " The weights in the centroid sum to 1, if the number of points, converted to `k`, is not zero.",
    "kind": "theorem",
    "type": "s.sum (λ (i : ι), finset.centroid_weights k s i) = 1"
  },
  {
    "name": "Sup_hom",
    "statement": "structure Sup_hom (α : Type u_8) (β : Type u_9) [has_Sup α] [has_Sup β] : Type (max u_8 u_9)",
    "theorem": "(α : Type u_8) (β : Type u_9) [has_Sup α] [has_Sup β] : Type (max u_8 u_9)",
    "args": "(α : Type u_8) (β : Type u_9) [has_Sup α] [has_Sup β]",
    "doc_string": "The type of `⨆`-preserving functions from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_8 u_9)"
  },
  {
    "name": "lie_subalgebra.complete_lattice",
    "statement": "def lie_subalgebra.complete_lattice {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : complete_lattice (lie_subalgebra R L)",
    "theorem": "{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : complete_lattice (lie_subalgebra R L)",
    "args": "{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": " The set of Lie subalgebras of a Lie algebra form a complete lattice.  We provide explicit values for the fields `bot`, `top`, `inf` to get more convenient definitions than we would otherwise obtain from `complete_lattice_of_Inf`.",
    "kind": "def",
    "type": "complete_lattice (lie_subalgebra R L)"
  },
  {
    "name": "multiset.pi",
    "statement": "def multiset.pi {α : Type u_1} [decidable_eq α] {δ : α → Type u_2} (m : multiset α) (t : Π (a : α), multiset (δ a)) : multiset (Π (a : α), a ∈ m → δ a)",
    "theorem": "{α : Type u_1} [decidable_eq α] {δ : α → Type u_2} (m : multiset α) (t : Π (a : α), multiset (δ a)) : multiset (Π (a : α), a ∈ m → δ a)",
    "args": "{α : Type u_1} [decidable_eq α] {δ : α → Type u_2} (m : multiset α) (t : Π (a : α), multiset (δ a))",
    "doc_string": "`pi m t` constructs the Cartesian product over `t` indexed by `m`.",
    "kind": "def",
    "type": "multiset (Π (a : α), a ∈ m → δ a)"
  },
  {
    "name": "composition.index",
    "statement": "def composition.index {n : ℕ} (c : composition n) (j : fin n) : fin c.length",
    "theorem": "{n : ℕ} (c : composition n) (j : fin n) : fin c.length",
    "args": "{n : ℕ} (c : composition n) (j : fin n)",
    "doc_string": "`c.index j` is the index of the block in the composition `c` containing `j`.",
    "kind": "def",
    "type": "fin c.length"
  },
  {
    "name": "ereal.sub",
    "statement": "def ereal.sub (x y : ereal) : ereal",
    "theorem": "(x y : ereal) : ereal",
    "args": "(x y : ereal)",
    "doc_string": " Subtraction on `ereal`, defined by `x - y = x + (-y)`. Since addition is badly behaved at some points, so is subtraction. There is no standard algebraic typeclass involving subtraction that is registered on `ereal` because of this bad behavior.",
    "kind": "def",
    "type": "ereal"
  },
  {
    "name": "bnot",
    "statement": "def bnot  : bool → bool",
    "theorem": " : bool → bool",
    "args": "",
    "doc_string": "Boolean NOT",
    "kind": "def",
    "type": "bool → bool"
  },
  {
    "name": "open_add_subgroup",
    "statement": "structure open_add_subgroup (G : Type u_1) [add_group G] [topological_space G] : Type u_1",
    "theorem": "(G : Type u_1) [add_group G] [topological_space G] : Type u_1",
    "args": "(G : Type u_1) [add_group G] [topological_space G]",
    "doc_string": "The type of open subgroups of a topological additive group.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "lex",
    "statement": "def lex (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A type synonym to equip a type with its lexicographic order.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "ordnode.insert_with",
    "statement": "def ordnode.insert_with {α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → α) (x : α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → α) (x : α) : ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → α) (x : α)",
    "doc_string": " O(log n). Insert an element into the set, preserving balance and the BST property. If an equivalent element is already in the set, the function `f` is used to generate the element to insert (being passed the current value in the set).      insert_with f 0 {1, 2, 3} = {0, 1, 2, 3}     insert_with f 1 {1, 2, 3} = {f 1, 2, 3}  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      insert_with f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}     insert_with f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)}",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "polynomial.is_splitting_field",
    "statement": "structure polynomial.is_splitting_field (K : Type v) (L : Type w) [field K] [field L] [algebra K L] (f : polynomial K) : Prop",
    "theorem": "(K : Type v) (L : Type w) [field K] [field L] [algebra K L] (f : polynomial K) : Prop",
    "args": "(K : Type v) (L : Type w) [field K] [field L] [algebra K L] (f : polynomial K)",
    "doc_string": "Typeclass characterising splitting fields.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_frobenius_number",
    "statement": "def is_frobenius_number (n : ℕ) (s : set ℕ) : Prop",
    "theorem": "(n : ℕ) (s : set ℕ) : Prop",
    "args": "(n : ℕ) (s : set ℕ)",
    "doc_string": " A natural number `n` is the **Frobenius number** of a set of natural numbers `s` if it is an upper bound on the complement of the additive submonoid generated by `s`. In other words, it is the largest number that can not be expressed as a sum of numbers in `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "option.cases_on'",
    "statement": "def option.cases_on' {α : Type u_1} {β : Type u_2} : option α → β → (α → β) → β",
    "theorem": "{α : Type u_1} {β : Type u_2} : option α → β → (α → β) → β",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": " Given an element of `a : option α`, a default element `b : β` and a function `α → β`, apply this function to `a` if it comes from `α`, and return `b` otherwise.",
    "kind": "def",
    "type": "option α → β → (α → β) → β"
  },
  {
    "name": "cartan_matrix.G₂",
    "statement": "def cartan_matrix.G₂  : matrix (fin 2) (fin 2) ℤ",
    "theorem": " : matrix (fin 2) (fin 2) ℤ",
    "args": "",
    "doc_string": " The Cartan matrix of type g₂. See [bourbaki1968] plate IX, page 290.  The corresponding Dynkin diagram is: ```lean o ≡>≡ o ``` Actually we are using the transpose of Bourbaki's matrix. This is to make this matrix consistent with `cartan_matrix.F₄`, in the sense that all non-zero values below the diagonal are -1.",
    "kind": "def",
    "type": "matrix (fin 2) (fin 2) ℤ"
  },
  {
    "name": "boolean_ring",
    "statement": "structure boolean_ring (α : Type u_4) : Type u_4",
    "theorem": "(α : Type u_4) : Type u_4",
    "args": "(α : Type u_4)",
    "doc_string": "A Boolean ring is a ring where multiplication is idempotent.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "add_group_filter_basis.N",
    "statement": "def add_group_filter_basis.N {G : Type u} [add_group G] (B : add_group_filter_basis G) : G → filter G",
    "theorem": "{G : Type u} [add_group G] (B : add_group_filter_basis G) : G → filter G",
    "args": "{G : Type u} [add_group G] (B : add_group_filter_basis G)",
    "doc_string": "The neighborhood function of a `add_group_filter_basis`",
    "kind": "def",
    "type": "G → filter G"
  },
  {
    "name": "topological_space.positive_compacts.to_nonempty_compacts",
    "statement": "def topological_space.positive_compacts.to_nonempty_compacts {α : Type u_1} [topological_space α] (s : topological_space.positive_compacts α) : topological_space.nonempty_compacts α",
    "theorem": "{α : Type u_1} [topological_space α] (s : topological_space.positive_compacts α) : topological_space.nonempty_compacts α",
    "args": "{α : Type u_1} [topological_space α] (s : topological_space.positive_compacts α)",
    "doc_string": "Reinterpret a positive compact as a nonempty compact.",
    "kind": "def",
    "type": "topological_space.nonempty_compacts α"
  },
  {
    "name": "noncompact_space",
    "statement": "structure noncompact_space (α : Type u_3) [topological_space α] : Prop",
    "theorem": "(α : Type u_3) [topological_space α] : Prop",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": "`α` is a noncompact topological space if it not a compact space.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "normal",
    "statement": "structure normal (F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] : Prop",
    "theorem": "(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] : Prop",
    "args": "(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K]",
    "doc_string": " Typeclass for normal field extension: `K` is a normal extension of `F` iff the minimal polynomial of every element `x` in `K` splits in `K`, i.e. every conjugate of `x` is in `K`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "free_semigroup.lift'",
    "statement": "def free_semigroup.lift' {α : Type u} {β : Type v} [semigroup β] (f : α → β) : α → list α → β",
    "theorem": "{α : Type u} {β : Type v} [semigroup β] (f : α → β) : α → list α → β",
    "args": "{α : Type u} {β : Type v} [semigroup β] (f : α → β)",
    "doc_string": "Auxiliary function for `free_semigroup.lift`.",
    "kind": "def",
    "type": "α → list α → β"
  },
  {
    "name": "encodable.encode_list",
    "statement": "def encodable.encode_list {α : Type u_1} [encodable α] : list α → ℕ",
    "theorem": "{α : Type u_1} [encodable α] : list α → ℕ",
    "args": "{α : Type u_1} [encodable α]",
    "doc_string": "Explicit encoding function for `list α`",
    "kind": "def",
    "type": "list α → ℕ"
  },
  {
    "name": "d_array.read",
    "statement": "def d_array.read {n : ℕ} {α : fin n → Type u} (a : d_array n α) (i : fin n) : α i",
    "theorem": "{n : ℕ} {α : fin n → Type u} (a : d_array n α) (i : fin n) : α i",
    "args": "{n : ℕ} {α : fin n → Type u} (a : d_array n α) (i : fin n)",
    "doc_string": "`read a i` reads the `i`th member of `a`. Has builtin VM implementation.",
    "kind": "def",
    "type": "α i"
  },
  {
    "name": "lists.to_list",
    "statement": "def lists.to_list {α : Type u_1} : lists α → list (lists α)",
    "theorem": "{α : Type u_1} : lists α → list (lists α)",
    "args": "{α : Type u_1}",
    "doc_string": "Converts a ZFA list to a `list` of ZFA lists. Atoms are sent to `[]`.",
    "kind": "def",
    "type": "lists α → list (lists α)"
  },
  {
    "name": "category_theory.limits.has_equalizers",
    "statement": "def category_theory.limits.has_equalizers (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_equalizers` represents a choice of equalizer for every pair of morphisms",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.pmap",
    "statement": "def list.pmap {α : Type u} {β : Type v} {p : α → Prop} (f : Π (a : α), p a → β) (l : list α) : (∀ (a : α), a ∈ l → p a) → list β",
    "theorem": "{α : Type u} {β : Type v} {p : α → Prop} (f : Π (a : α), p a → β) (l : list α) : (∀ (a : α), a ∈ l → p a) → list β",
    "args": "{α : Type u} {β : Type v} {p : α → Prop} (f : Π (a : α), p a → β) (l : list α)",
    "doc_string": "Partial map. If `f : Π a, p a → β` is a partial function defined on  `a : α` satisfying `p`, then `pmap f l h` is essentially the same as `map f l`  but is defined only when all members of `l` satisfy `p`, using the proof  to apply `f`.",
    "kind": "def",
    "type": "(∀ (a : α), a ∈ l → p a) → list β"
  },
  {
    "name": "has_lt.lt.not_le",
    "statement": "theorem has_lt.lt.not_le {α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b ≤ a",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b ≤ a",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of not_le_of_lt`.",
    "kind": "theorem",
    "type": "¬b ≤ a"
  },
  {
    "name": "add_units.is_add_unit_add_units_add",
    "statement": "theorem add_units.is_add_unit_add_units_add {M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (↑u + a) ↔ is_add_unit a",
    "theorem": "{M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (↑u + a) ↔ is_add_unit a",
    "args": "{M : Type u_1} [add_monoid M] (u : add_units M) (a : M)",
    "doc_string": "Addition of a `u : add_units M` on the left doesn't affect `is_add_unit`.",
    "kind": "theorem",
    "type": "is_add_unit (↑u + a) ↔ is_add_unit a"
  },
  {
    "name": "function.involutive.to_perm",
    "statement": "def function.involutive.to_perm {α : Sort u} (f : α → α) (h : function.involutive f) : equiv.perm α",
    "theorem": "{α : Sort u} (f : α → α) (h : function.involutive f) : equiv.perm α",
    "args": "{α : Sort u} (f : α → α) (h : function.involutive f)",
    "doc_string": "Convert an involutive function `f` to a permutation with `to_fun = inv_fun = f`.",
    "kind": "def",
    "type": "equiv.perm α"
  },
  {
    "name": "right.add_neg_of_neg_of_nonpos",
    "statement": "theorem right.add_neg_of_neg_of_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg_of_neg_of_nonpos`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "pgame.inv'",
    "statement": "def pgame.inv'  : pgame → pgame",
    "theorem": " : pgame → pgame",
    "args": "",
    "doc_string": " The inverse of a positive surreal number `x = {L | R}` is given by `x⁻¹ = {0,   (1 + (R - x) * x⁻¹L) * R, (1 + (L - x) * x⁻¹R) * L |   (1 + (L - x) * x⁻¹L) * L, (1 + (R - x) * x⁻¹R) * R}`. Because the two halves `x⁻¹L, x⁻¹R` of `x⁻¹` are used in their own definition, the sets and elements are inductively generated.",
    "kind": "def",
    "type": "pgame → pgame"
  },
  {
    "name": "simplex_category.hom",
    "statement": "def simplex_category.hom (a b : simplex_category) : Type",
    "theorem": "(a b : simplex_category) : Type",
    "args": "(a b : simplex_category)",
    "doc_string": "Morphisms in the simplex_category.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "category_theory.limits.types.binary_product_cone",
    "statement": "def category_theory.limits.types.binary_product_cone (X Y : Type u) : category_theory.limits.binary_fan X Y",
    "theorem": "(X Y : Type u) : category_theory.limits.binary_fan X Y",
    "args": "(X Y : Type u)",
    "doc_string": "The product type `X × Y` forms a cone for the binary product of `X` and `Y`.",
    "kind": "def",
    "type": "category_theory.limits.binary_fan X Y"
  },
  {
    "name": "filter.germ_setoid",
    "statement": "def filter.germ_setoid {α : Type u_1} (l : filter α) (β : Type u_2) : setoid (α → β)",
    "theorem": "{α : Type u_1} (l : filter α) (β : Type u_2) : setoid (α → β)",
    "args": "{α : Type u_1} (l : filter α) (β : Type u_2)",
    "doc_string": "Setoid used to define the space of germs.",
    "kind": "def",
    "type": "setoid (α → β)"
  },
  {
    "name": "with_ideal.topological_space_module",
    "statement": "def with_ideal.topological_space_module (R : Type u_1) [comm_ring R] [with_ideal R] (M : Type u_2) [add_comm_group M] [module R M] : topological_space M",
    "theorem": "(R : Type u_1) [comm_ring R] [with_ideal R] (M : Type u_2) [add_comm_group M] [module R M] : topological_space M",
    "args": "(R : Type u_1) [comm_ring R] [with_ideal R] (M : Type u_2) [add_comm_group M] [module R M]",
    "doc_string": " The adic topology on a `R` module coming from the ideal `with_ideal.I`. This cannot be an instance because `R` cannot be inferred from `M`.",
    "kind": "def",
    "type": "topological_space M"
  },
  {
    "name": "is_regular_mul_iff",
    "statement": "theorem is_regular_mul_iff {R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) ↔ is_regular a ∧ is_regular b",
    "theorem": "{R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) ↔ is_regular a ∧ is_regular b",
    "args": "{R : Type u_1} {a b : R} [comm_semigroup R]",
    "doc_string": "A product is regular if and only if the factors are.",
    "kind": "theorem",
    "type": "is_regular (a * b) ↔ is_regular a ∧ is_regular b"
  },
  {
    "name": "with_top.sub",
    "statement": "def with_top.sub {α : Type u_1} [has_sub α] [has_zero α] (a b : with_top α) : with_top α",
    "theorem": "{α : Type u_1} [has_sub α] [has_zero α] (a b : with_top α) : with_top α",
    "args": "{α : Type u_1} [has_sub α] [has_zero α] (a b : with_top α)",
    "doc_string": "If `α` has subtraction and `0`, we can extend the subtraction to `with_top α`.",
    "kind": "def",
    "type": "with_top α"
  },
  {
    "name": "lazy_list.tail",
    "statement": "def lazy_list.tail {α : Type u} : lazy_list α → lazy_list α",
    "theorem": "{α : Type u} : lazy_list α → lazy_list α",
    "args": "{α : Type u}",
    "doc_string": "Removes the first element of the lazy list.",
    "kind": "def",
    "type": "lazy_list α → lazy_list α"
  },
  {
    "name": "complete_space",
    "statement": "structure complete_space (α : Type u) [uniform_space α] : Prop",
    "theorem": "(α : Type u) [uniform_space α] : Prop",
    "args": "(α : Type u) [uniform_space α]",
    "doc_string": "A complete space is defined here using uniformities. A uniform space  is complete if every Cauchy filter converges.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "imp_forall_iff",
    "statement": "theorem imp_forall_iff {α : Type u_1} {p : Prop} {q : α → Prop} : p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x",
    "theorem": "{α : Type u_1} {p : Prop} {q : α → Prop} : p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x",
    "args": "{α : Type u_1} {p : Prop} {q : α → Prop}",
    "doc_string": " We intentionally restrict the type of `α` in this lemma so that this is a safer to use in simp than `forall_swap`.",
    "kind": "theorem",
    "type": "p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x"
  },
  {
    "name": "matrix.det_invertible_of_left_inverse",
    "statement": "def matrix.det_invertible_of_left_inverse {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : B.mul A = 1) : invertible A.det",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : B.mul A = 1) : invertible A.det",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : B.mul A = 1)",
    "doc_string": "`A.det` is invertible if `A` has a left inverse.",
    "kind": "def",
    "type": "invertible A.det"
  },
  {
    "name": "lattice_ordered_comm_group.lattice_ordered_add_comm_group_to_distrib_lattice",
    "statement": "def lattice_ordered_comm_group.lattice_ordered_add_comm_group_to_distrib_lattice (α : Type u) [s : lattice α] [add_comm_group α] [covariant_class α α has_add.add has_le.le] : distrib_lattice α",
    "theorem": "(α : Type u) [s : lattice α] [add_comm_group α] [covariant_class α α has_add.add has_le.le] : distrib_lattice α",
    "args": "(α : Type u) [s : lattice α] [add_comm_group α] [covariant_class α α has_add.add has_le.le]",
    "doc_string": "Every lattice ordered commutative additive group is a distributive lattice",
    "kind": "def",
    "type": "distrib_lattice α"
  },
  {
    "name": "monoid_algebra",
    "statement": "def monoid_algebra (k : Type u₁) (G : Type u₂) [semiring k] : Type (max u₁ u₂)",
    "theorem": "(k : Type u₁) (G : Type u₂) [semiring k] : Type (max u₁ u₂)",
    "args": "(k : Type u₁) (G : Type u₂) [semiring k]",
    "doc_string": "The monoid algebra over a semiring `k` generated by the monoid `G`. It is the type of finite formal `k`-linear combinations of terms of `G`, endowed with the convolution product.",
    "kind": "def",
    "type": "Type (max u₁ u₂)"
  },
  {
    "name": "is_principal_ideal_ring",
    "statement": "structure is_principal_ideal_ring (R : Type u) [ring R] : Prop",
    "theorem": "(R : Type u) [ring R] : Prop",
    "args": "(R : Type u) [ring R]",
    "doc_string": "A ring is a principal ideal ring if all (left) ideals are principal.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "closure_Ico",
    "statement": "theorem closure_Ico {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ico a b) = set.Icc a b",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ico a b) = set.Icc a b",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b)",
    "doc_string": "The closure of the interval `[a, b)` is the closed interval `[a, b]`.",
    "kind": "theorem",
    "type": "closure (set.Ico a b) = set.Icc a b"
  },
  {
    "name": "num.gcd",
    "statement": "def num.gcd (a b : num) : num",
    "theorem": "(a b : num) : num",
    "args": "(a b : num)",
    "doc_string": "Greatest Common Divisor (GCD) of two `num`s.",
    "kind": "def",
    "type": "num"
  },
  {
    "name": "equiv.perm.prod_extend_right",
    "statement": "def equiv.perm.prod_extend_right {α₁ : Type u_1} {β₁ : Type u_2} [decidable_eq α₁] (a : α₁) (e : equiv.perm β₁) : equiv.perm (α₁ × β₁)",
    "theorem": "{α₁ : Type u_1} {β₁ : Type u_2} [decidable_eq α₁] (a : α₁) (e : equiv.perm β₁) : equiv.perm (α₁ × β₁)",
    "args": "{α₁ : Type u_1} {β₁ : Type u_2} [decidable_eq α₁] (a : α₁) (e : equiv.perm β₁)",
    "doc_string": " `prod_extend_right a e` extends `e : perm β` to `perm (α × β)` by sending `(a, b)` to `(a, e b)` and keeping the other `(a', b)` fixed.",
    "kind": "def",
    "type": "equiv.perm (α₁ × β₁)"
  },
  {
    "name": "add_salem_spencer",
    "statement": "def add_salem_spencer {α : Type u_2} [add_monoid α] (s : set α) : Prop",
    "theorem": "{α : Type u_2} [add_monoid α] (s : set α) : Prop",
    "args": "{α : Type u_2} [add_monoid α] (s : set α)",
    "doc_string": "A Salem-Spencer, aka non averaging, set `s` in an additive monoid is a set such that the average of any two distinct elements is not in the set.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_subgroup.fg",
    "statement": "def add_subgroup.fg {G : Type u_3} [add_group G] (P : add_subgroup G) : Prop",
    "theorem": "{G : Type u_3} [add_group G] (P : add_subgroup G) : Prop",
    "args": "{G : Type u_3} [add_group G] (P : add_subgroup G)",
    "doc_string": " An additive subgroup of `H` is finitely generated if it is the closure of a finite subset of `H`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_closed_frontier",
    "statement": "theorem is_closed_frontier {α : Type u} [topological_space α] {s : set α} : is_closed (frontier s)",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : is_closed (frontier s)",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "The frontier of a set is closed.",
    "kind": "theorem",
    "type": "is_closed (frontier s)"
  },
  {
    "name": "pgame.first_loses",
    "statement": "def pgame.first_loses (G : pgame) : Prop",
    "theorem": "(G : pgame) : Prop",
    "args": "(G : pgame)",
    "doc_string": "The player who goes first loses",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "free_add_semigroup.traverse",
    "statement": "def free_add_semigroup.traverse {m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) (x : free_add_semigroup α) : m (free_add_semigroup β)",
    "theorem": "{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) (x : free_add_semigroup α) : m (free_add_semigroup β)",
    "args": "{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) (x : free_add_semigroup α)",
    "doc_string": "`free_add_semigroup` is traversable.",
    "kind": "def",
    "type": "m (free_add_semigroup β)"
  },
  {
    "name": "resolvent",
    "statement": "def resolvent {R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) (r : R) : A",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) (r : R) : A",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) (r : R)",
    "doc_string": "Given an `a : A` where `A` is an `R`-algebra, the *resolvent* is    a map `R → A` which sends `r : R` to `(algebra_map R A r - a)⁻¹` when    `r ∈ resolvent R A` and `0` when `r ∈ spectrum R A`.",
    "kind": "def",
    "type": "A"
  },
  {
    "name": "dite_eq_ite",
    "statement": "theorem dite_eq_ite {α : Sort u_1} (P : Prop) [decidable P] (a b : α) : dite P (λ (h : P), a) (λ (h : ¬P), b) = ite P a b",
    "theorem": "{α : Sort u_1} (P : Prop) [decidable P] (a b : α) : dite P (λ (h : P), a) (λ (h : ¬P), b) = ite P a b",
    "args": "{α : Sort u_1} (P : Prop) [decidable P] (a b : α)",
    "doc_string": "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`.",
    "kind": "theorem",
    "type": "dite P (λ (h : P), a) (λ (h : ¬P), b) = ite P a b"
  },
  {
    "name": "finset.has_sub",
    "statement": "def finset.has_sub {α : Type u_2} [decidable_eq α] [has_sub α] : has_sub (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [has_sub α] : has_sub (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [has_sub α]",
    "doc_string": "The pointwise subtraction of finsets `s - t` is defined as `{x - y | x ∈ s, y ∈ t}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_sub (finset α)"
  },
  {
    "name": "scope_trace",
    "statement": "def scope_trace {α : Type u} {line col : ℕ} (f : thunk α) : α",
    "theorem": "{α : Type u} {line col : ℕ} (f : thunk α) : α",
    "args": "{α : Type u} {line col : ℕ} (f : thunk α)",
    "doc_string": "This function has a native implementation that displays in the given position all trace messages used in f.   The arguments line and col are filled by the elaborator.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "non_unital_ring_hom",
    "statement": "structure non_unital_ring_hom (α : Type u_5) (β : Type u_6) [non_unital_non_assoc_semiring α] [non_unital_non_assoc_semiring β] : Type (max u_5 u_6)",
    "theorem": "(α : Type u_5) (β : Type u_6) [non_unital_non_assoc_semiring α] [non_unital_non_assoc_semiring β] : Type (max u_5 u_6)",
    "args": "(α : Type u_5) (β : Type u_6) [non_unital_non_assoc_semiring α] [non_unital_non_assoc_semiring β]",
    "doc_string": " Bundled non-unital semiring homomorphisms `α →ₙ+* β`; use this for bundled non-unital ring homomorphisms too.  When possible, instead of parametrizing results over `(f : α →ₙ+* β)`, you should parametrize over `(F : Type*) [non_unital_ring_hom_class F α β] (f : F)`.  When you extend this structure, make sure to extend `non_unital_ring_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "with_one",
    "statement": "def with_one (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Add an extra element `1` to a type",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "category_theory.sum",
    "statement": "def category_theory.sum (C : Type u₁) [category_theory.category C] (D : Type u₁) [category_theory.category D] : category_theory.category (C ⊕ D)",
    "theorem": "(C : Type u₁) [category_theory.category C] (D : Type u₁) [category_theory.category D] : category_theory.category (C ⊕ D)",
    "args": "(C : Type u₁) [category_theory.category C] (D : Type u₁) [category_theory.category D]",
    "doc_string": "`sum C D` gives the direct sum of two categories.",
    "kind": "def",
    "type": "category_theory.category (C ⊕ D)"
  },
  {
    "name": "function.commute.left_bij_on_fixed_pts_comp",
    "statement": "theorem function.commute.left_bij_on_fixed_pts_comp {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "theorem": "{α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "args": "{α : Type u} {f g : α → α} (h : function.commute f g)",
    "doc_string": " If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`.",
    "kind": "theorem",
    "type": "set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))"
  },
  {
    "name": "polynomial.div_X",
    "statement": "def polynomial.div_X {R : Type u} [semiring R] (p : polynomial R) : polynomial R",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : polynomial R",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": "`div_X p` returns a polynomial `q` such that `q * X + C (p.coeff 0) = p`.  It can be used in a semiring where the usual division algorithm is not possible",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "seq.cons",
    "statement": "def seq.cons {α : Type u} (a : α) : seq α → seq α",
    "theorem": "{α : Type u} (a : α) : seq α → seq α",
    "args": "{α : Type u} (a : α)",
    "doc_string": "Prepend an element to a sequence",
    "kind": "def",
    "type": "seq α → seq α"
  },
  {
    "name": "CommRing",
    "statement": "def CommRing  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of commutative rings.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "sequentially_complete.seq",
    "statement": "def sequentially_complete.seq {α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (n : ℕ) : α",
    "theorem": "{α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (n : ℕ) : α",
    "args": "{α : Type u} [uniform_space α] {f : filter α} (hf : cauchy f) {U : ℕ → set (α × α)} (U_mem : ∀ (n : ℕ), U n ∈ uniformity α) (n : ℕ)",
    "doc_string": " A sequence of points such that `seq n ∈ set_seq n`. Here `set_seq` is an antitone sequence of sets `set_seq n ∈ f` with diameters controlled by a given sequence of entourages.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "category_theory.limits.has_kernels",
    "statement": "structure category_theory.limits.has_kernels (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C]",
    "doc_string": "`has_kernels` represents the existence of kernels for every morphism.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "left.mul_lt_one",
    "statement": "theorem left.mul_lt_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "finsupp.single_left_injective",
    "statement": "theorem finsupp.single_left_injective {α : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ≠ 0) : function.injective (λ (a : α), finsupp.single a b)",
    "theorem": "{α : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ≠ 0) : function.injective (λ (a : α), finsupp.single a b)",
    "args": "{α : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ≠ 0)",
    "doc_string": " `finsupp.single a b` is injective in `a`. For the statement that it is injective in `b`, see `finsupp.single_injective`",
    "kind": "theorem",
    "type": "function.injective (λ (a : α), finsupp.single a b)"
  },
  {
    "name": "ordnode.all",
    "statement": "def ordnode.all {α : Type u} (P : α → Prop) : ordnode α → Prop",
    "theorem": "{α : Type u} (P : α → Prop) : ordnode α → Prop",
    "args": "{α : Type u} (P : α → Prop)",
    "doc_string": "O(n). Does every element of the map satisfy property `P`?      all (λ x, x < 5) {1, 2, 3} = true     all (λ x, x < 5) {1, 2, 3, 5} = false",
    "kind": "def",
    "type": "ordnode α → Prop"
  },
  {
    "name": "finset.sup",
    "statement": "def finset.sup {α : Type u_1} {β : Type u_2} [semilattice_sup α] [order_bot α] (s : finset β) (f : β → α) : α",
    "theorem": "{α : Type u_1} {β : Type u_2} [semilattice_sup α] [order_bot α] (s : finset β) (f : β → α) : α",
    "args": "{α : Type u_1} {β : Type u_2} [semilattice_sup α] [order_bot α] (s : finset β) (f : β → α)",
    "doc_string": "Supremum of a finite set: `sup {a, b, c} f = f a ⊔ f b ⊔ f c`",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "encodable.of_left_injection",
    "statement": "def encodable.of_left_injection {α : Type u_1} {β : Type u_2} [encodable α] (f : β → α) (finv : α → option β) (linv : ∀ (b : β), finv (f b) = option.some b) : encodable β",
    "theorem": "{α : Type u_1} {β : Type u_2} [encodable α] (f : β → α) (finv : α → option β) (linv : ∀ (b : β), finv (f b) = option.some b) : encodable β",
    "args": "{α : Type u_1} {β : Type u_2} [encodable α] (f : β → α) (finv : α → option β) (linv : ∀ (b : β), finv (f b) = option.some b)",
    "doc_string": "If `α` is encodable and there is an injection `f : β → α`, then `β` is encodable as well.",
    "kind": "def",
    "type": "encodable β"
  },
  {
    "name": "finset.bipartite_below",
    "statement": "def finset.bipartite_below {α : Type u_1} {β : Type u_2} (r : α → β → Prop) (s : finset α) (b : β) [Π (a : α), decidable (r a b)] : finset α",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop) (s : finset α) (b : β) [Π (a : α), decidable (r a b)] : finset α",
    "args": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop) (s : finset α) (b : β) [Π (a : α), decidable (r a b)]",
    "doc_string": "Elements of `s` which are \"below\" `b` according to relation `r`.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "finset.slice_subset",
    "statement": "theorem finset.slice_subset {α : Type u_1} {𝒜 : finset (finset α)} {r : ℕ} : 𝒜.slice r ⊆ 𝒜",
    "theorem": "{α : Type u_1} {𝒜 : finset (finset α)} {r : ℕ} : 𝒜.slice r ⊆ 𝒜",
    "args": "{α : Type u_1} {𝒜 : finset (finset α)} {r : ℕ}",
    "doc_string": "The `r`-th slice of `𝒜` is a subset of `𝒜`.",
    "kind": "theorem",
    "type": "𝒜.slice r ⊆ 𝒜"
  },
  {
    "name": "is_open",
    "statement": "def is_open {α : Type u} [t : topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [t : topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [t : topological_space α] (s : set α)",
    "doc_string": "`is_open s` means that `s` is open in the ambient topological space on `α`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "concept.swap",
    "statement": "def concept.swap {α : Type u_2} {β : Type u_3} {r : α → β → Prop} (c : concept α β r) : concept β α (function.swap r)",
    "theorem": "{α : Type u_2} {β : Type u_3} {r : α → β → Prop} (c : concept α β r) : concept β α (function.swap r)",
    "args": "{α : Type u_2} {β : Type u_3} {r : α → β → Prop} (c : concept α β r)",
    "doc_string": "Swap the sets of a concept to make it a concept of the dual context.",
    "kind": "def",
    "type": "concept β α (function.swap r)"
  },
  {
    "name": "measure_theory.outer_measure",
    "statement": "structure measure_theory.outer_measure (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "An outer measure is a countably subadditive monotone function that sends `∅` to `0`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "add_nonpos",
    "statement": "theorem add_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0)",
    "doc_string": "**Alias** of `left.add_nonpos`.",
    "kind": "theorem",
    "type": "a + b ≤ 0"
  },
  {
    "name": "semi_normed_group",
    "statement": "structure semi_normed_group (E : Type u_6) : Type u_6",
    "theorem": "(E : Type u_6) : Type u_6",
    "args": "(E : Type u_6)",
    "doc_string": " A seminormed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines a pseudometric space structure.",
    "kind": "structure",
    "type": "Type u_6"
  },
  {
    "name": "exp_char",
    "statement": "inductive exp_char (R : Type u) [semiring R] : ℕ → Prop",
    "theorem": "(R : Type u) [semiring R] : ℕ → Prop",
    "args": "(R : Type u) [semiring R]",
    "doc_string": "The definition of the exponential characteristic of a semiring.",
    "kind": "inductive",
    "type": "ℕ → Prop"
  },
  {
    "name": "subring.to_add_subgroup",
    "statement": "def subring.to_add_subgroup {R : Type u} [ring R] (self : subring R) : add_subgroup R",
    "theorem": "{R : Type u} [ring R] (self : subring R) : add_subgroup R",
    "args": "{R : Type u} [ring R] (self : subring R)",
    "doc_string": "Reinterpret a `subring` as an `add_subgroup`.",
    "kind": "def",
    "type": "add_subgroup R"
  },
  {
    "name": "quiver.weakly_connected_component",
    "statement": "def quiver.weakly_connected_component (V : Type u) [quiver V] : Type u",
    "theorem": "(V : Type u) [quiver V] : Type u",
    "args": "(V : Type u) [quiver V]",
    "doc_string": "The type of weakly connected components of a directed graph. Two vertices are    in the same weakly connected component if there is a zigzag of arrows from one    to the other.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "ordnode.node3_l",
    "statement": "def ordnode.node3_l {α : Type u_1} (l : ordnode α) (x : α) (m : ordnode α) (y : α) (r : ordnode α) : ordnode α",
    "theorem": "{α : Type u_1} (l : ordnode α) (x : α) (m : ordnode α) (y : α) (r : ordnode α) : ordnode α",
    "args": "{α : Type u_1} (l : ordnode α) (x : α) (m : ordnode α) (y : α) (r : ordnode α)",
    "doc_string": "Build a tree from three nodes, left associated (ignores the invariants).",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "same_ray.of_neg",
    "statement": "theorem same_ray.of_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) → same_ray R x y",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) → same_ray R x y",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M}",
    "doc_string": "**Alias** of the forward direction of same_ray_neg_iff`.",
    "kind": "theorem",
    "type": "same_ray R (-x) (-y) → same_ray R x y"
  },
  {
    "name": "generalized_continued_fraction.is_simple_continued_fraction",
    "statement": "def generalized_continued_fraction.is_simple_continued_fraction {α : Type u_1} (g : generalized_continued_fraction α) [has_one α] : Prop",
    "theorem": "{α : Type u_1} (g : generalized_continued_fraction α) [has_one α] : Prop",
    "args": "{α : Type u_1} (g : generalized_continued_fraction α) [has_one α]",
    "doc_string": "A generalized continued fraction is a *simple continued fraction* if all partial numerators are equal to one.                                  1                 h + ---------------------------                                   1                       b₀ + --------------------                                     1                             b₁ + --------------                                         1                                   b₂ + --------                                       b₃ + ...",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "summable_iff_cauchy_seq_finset",
    "statement": "theorem summable_iff_cauchy_seq_finset {α : Type u_1} {β : Type u_2} [add_comm_group α] [uniform_space α] [complete_space α] {f : β → α} : summable f ↔ cauchy_seq (λ (s : finset β), s.sum (λ (b : β), f b))",
    "theorem": "{α : Type u_1} {β : Type u_2} [add_comm_group α] [uniform_space α] [complete_space α] {f : β → α} : summable f ↔ cauchy_seq (λ (s : finset β), s.sum (λ (b : β), f b))",
    "args": "{α : Type u_1} {β : Type u_2} [add_comm_group α] [uniform_space α] [complete_space α] {f : β → α}",
    "doc_string": "The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test**",
    "kind": "theorem",
    "type": "summable f ↔ cauchy_seq (λ (s : finset β), s.sum (λ (b : β), f b))"
  },
  {
    "name": "module.End",
    "statement": "def module.End (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v",
    "theorem": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v",
    "args": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": " Linear endomorphisms of a module, with associated ring structure `module.End.semiring` and algebra structure `module.End.algebra`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "enat",
    "statement": "def enat  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Type of natural numbers with infinity (`⊤`)",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "lt_by_cases",
    "statement": "def lt_by_cases {α : Type u} [linear_order α] (x y : α) {P : Sort u_1} (h₁ : x < y → P) (h₂ : x = y → P) (h₃ : y < x → P) : P",
    "theorem": "{α : Type u} [linear_order α] (x y : α) {P : Sort u_1} (h₁ : x < y → P) (h₂ : x = y → P) (h₃ : y < x → P) : P",
    "args": "{α : Type u} [linear_order α] (x y : α) {P : Sort u_1} (h₁ : x < y → P) (h₂ : x = y → P) (h₃ : y < x → P)",
    "doc_string": "Perform a case-split on the ordering of `x` and `y` in a decidable linear order.",
    "kind": "def",
    "type": "P"
  },
  {
    "name": "or_and_distrib_left",
    "statement": "theorem or_and_distrib_left {a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)",
    "theorem": "{a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)",
    "args": "{a b c : Prop}",
    "doc_string": "`∨` distributes over `∧` (on the left).",
    "kind": "theorem",
    "type": "a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)"
  },
  {
    "name": "primorial",
    "statement": "def primorial (n : ℕ) : ℕ",
    "theorem": "(n : ℕ) : ℕ",
    "args": "(n : ℕ)",
    "doc_string": "The primorial `n#` of `n` is the product of the primes less than or equal to `n`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "is_well_order.linear_order",
    "statement": "def is_well_order.linear_order {α : Type u} (r : α → α → Prop) [is_well_order α r] : linear_order α",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_well_order α r] : linear_order α",
    "args": "{α : Type u} (r : α → α → Prop) [is_well_order α r]",
    "doc_string": "Construct a decidable linear order from a well-founded linear order.",
    "kind": "def",
    "type": "linear_order α"
  },
  {
    "name": "ordset.size",
    "statement": "def ordset.size {α : Type u_1} [preorder α] (s : ordset α) : ℕ",
    "theorem": "{α : Type u_1} [preorder α] (s : ordset α) : ℕ",
    "args": "{α : Type u_1} [preorder α] (s : ordset α)",
    "doc_string": "O(1). Get the size of the set.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "list.all_some",
    "statement": "def list.all_some {α : Type u_1} : list (option α) → option (list α)",
    "theorem": "{α : Type u_1} : list (option α) → option (list α)",
    "args": "{α : Type u_1}",
    "doc_string": "If all elements of `xs` are `some xᵢ`, `all_some xs` returns the `xᵢ`. Otherwise it returns `none`.  ```lean all_some [some 1, some 2] = some [1, 2] all_some [some 1, none  ] = none ```",
    "kind": "def",
    "type": "list (option α) → option (list α)"
  },
  {
    "name": "mul_lt_one'",
    "statement": "theorem mul_lt_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": "**Alias** of left.mul_lt_one'`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "quotient_add_group.subgroup.has_quotient",
    "statement": "def quotient_add_group.subgroup.has_quotient {α : Type u_1} [add_group α] : has_quotient α (add_subgroup α)",
    "theorem": "{α : Type u_1} [add_group α] : has_quotient α (add_subgroup α)",
    "args": "{α : Type u_1} [add_group α]",
    "doc_string": "`α ⧸ s` is the quotient type representing the left cosets of `s`.  If `s` is a normal subgroup, `α ⧸ s` is a group",
    "kind": "def",
    "type": "has_quotient α (add_subgroup α)"
  },
  {
    "name": "nhds_set",
    "statement": "def nhds_set {α : Type u_1} [topological_space α] (s : set α) : filter α",
    "theorem": "{α : Type u_1} [topological_space α] (s : set α) : filter α",
    "args": "{α : Type u_1} [topological_space α] (s : set α)",
    "doc_string": "The filter of neighborhoods of a set in a topological space.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "category_theory.non_preadditive_abelian.preadditive",
    "statement": "def category_theory.non_preadditive_abelian.preadditive {C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.preadditive C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.preadditive C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.non_preadditive_abelian C]",
    "doc_string": "Every `non_preadditive_abelian` category is preadditive.",
    "kind": "def",
    "type": "category_theory.preadditive C"
  },
  {
    "name": "conditionally_complete_linear_order",
    "statement": "structure conditionally_complete_linear_order (α : Type u_4) : Type u_4",
    "theorem": "(α : Type u_4) : Type u_4",
    "args": "(α : Type u_4)",
    "doc_string": " A conditionally complete linear order is a linear order in which every nonempty subset which is bounded above has a supremum, and every nonempty subset which is bounded below has an infimum. Typical examples are real numbers or natural numbers.  To differentiate the statements from the corresponding statements in (unconditional) complete linear orders, we prefix Inf and Sup by a c everywhere. The same statements should hold in both worlds, sometimes with additional assumptions of nonemptiness or boundedness.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "fin_enum.to_list",
    "statement": "def fin_enum.to_list (α : Type u_1) [fin_enum α] : list α",
    "theorem": "(α : Type u_1) [fin_enum α] : list α",
    "args": "(α : Type u_1) [fin_enum α]",
    "doc_string": "create an exhaustive list of the values of a given type",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "has_lt.lt.asymm",
    "statement": "theorem has_lt.lt.asymm {α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of lt_asymm`.",
    "kind": "theorem",
    "type": "¬b < a"
  },
  {
    "name": "add_commute.is_of_fin_order_add",
    "statement": "theorem add_commute.is_of_fin_order_add {G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "theorem": "{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "args": "{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)",
    "doc_string": "Commuting elements of finite additive order are closed under addition.",
    "kind": "theorem",
    "type": "is_of_fin_add_order (x + y)"
  },
  {
    "name": "submodule.has_involutive_pointwise_neg",
    "statement": "def submodule.has_involutive_pointwise_neg {R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_involutive_neg (submodule R M)",
    "theorem": "{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_involutive_neg (submodule R M)",
    "args": "{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M]",
    "doc_string": " `submodule.has_pointwise_neg` is involutive.  This is available as an instance in the `pointwise` locale.",
    "kind": "def",
    "type": "has_involutive_neg (submodule R M)"
  },
  {
    "name": "add_subsemigroup.ext",
    "statement": "theorem add_subsemigroup.ext {M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T",
    "theorem": "{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T",
    "args": "{M : Type u_1} [has_add M] {S T : add_subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T)",
    "doc_string": "Two `add_subsemigroup`s are equal if they have the same elements.",
    "kind": "theorem",
    "type": "S = T"
  },
  {
    "name": "path.homotopic.proj_left",
    "statement": "def path.homotopic.proj_left {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {c₁ c₂ : α × β} (p : path.homotopic.quotient c₁ c₂) : path.homotopic.quotient c₁.fst c₂.fst",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {c₁ c₂ : α × β} (p : path.homotopic.quotient c₁ c₂) : path.homotopic.quotient c₁.fst c₂.fst",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {c₁ c₂ : α × β} (p : path.homotopic.quotient c₁ c₂)",
    "doc_string": "Abbreviation for projection onto the left coordinate of a path class",
    "kind": "def",
    "type": "path.homotopic.quotient c₁.fst c₂.fst"
  },
  {
    "name": "metric.inf_dist_le_inf_dist_add_dist",
    "statement": "theorem metric.inf_dist_le_inf_dist_add_dist {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} : metric.inf_dist x s ≤ metric.inf_dist y s + has_dist.dist x y",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} : metric.inf_dist x s ≤ metric.inf_dist y s + has_dist.dist x y",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α}",
    "doc_string": " The minimal distance from `x` to `s` is bounded by the distance from `y` to `s`, modulo the distance between `x` and `y`",
    "kind": "theorem",
    "type": "metric.inf_dist x s ≤ metric.inf_dist y s + has_dist.dist x y"
  },
  {
    "name": "is_smul_regular.of_mul_eq_one",
    "statement": "theorem is_smul_regular.of_mul_eq_one {R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b",
    "theorem": "{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b",
    "args": "{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1)",
    "doc_string": "An element of `R` admitting a left inverse is `M`-regular.",
    "kind": "theorem",
    "type": "is_smul_regular M b"
  },
  {
    "name": "laurent_polynomial",
    "statement": "def laurent_polynomial (R : Type u_1) [semiring R] : Type u_1",
    "theorem": "(R : Type u_1) [semiring R] : Type u_1",
    "args": "(R : Type u_1) [semiring R]",
    "doc_string": "  The semiring of Laurent polynomials with coefficients in the semiring `R`. We denote it by `R[T;T⁻¹]`. The ring homomorphism `C : R →+* R[T;T⁻¹]` includes `R` as the constant polynomials.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "flow.from_iter",
    "statement": "def flow.from_iter {α : Type u_2} [topological_space α] {g : α → α} (h : continuous g) : flow ℕ α",
    "theorem": "{α : Type u_2} [topological_space α] {g : α → α} (h : continuous g) : flow ℕ α",
    "args": "{α : Type u_2} [topological_space α] {g : α → α} (h : continuous g)",
    "doc_string": "Iterations of a continuous function from a topological space `α`    to itself defines a semiflow by `ℕ` on `α`.",
    "kind": "def",
    "type": "flow ℕ α"
  },
  {
    "name": "is_noetherian.iff_fg",
    "statement": "theorem is_noetherian.iff_fg {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V]",
    "doc_string": "A module over a division ring is noetherian if and only if it is finitely generated.",
    "kind": "theorem",
    "type": "is_noetherian K V ↔ module.finite K V"
  },
  {
    "name": "category_theory.preadditive",
    "statement": "structure category_theory.preadditive (C : Type u) [category_theory.category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category is called preadditive if `P ⟶ Q` is an abelian group such that composition is    linear in both variables.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "is_nilpotent_prod",
    "statement": "def is_nilpotent_prod {G₁ : Type u_2} {G₂ : Type u_3} [group G₁] [group G₂] [group.is_nilpotent G₁] [group.is_nilpotent G₂] : group.is_nilpotent (G₁ × G₂)",
    "theorem": "{G₁ : Type u_2} {G₂ : Type u_3} [group G₁] [group G₂] [group.is_nilpotent G₁] [group.is_nilpotent G₂] : group.is_nilpotent (G₁ × G₂)",
    "args": "{G₁ : Type u_2} {G₂ : Type u_3} [group G₁] [group G₂] [group.is_nilpotent G₁] [group.is_nilpotent G₂]",
    "doc_string": "Products of nilpotent groups are nilpotent",
    "kind": "def",
    "type": "group.is_nilpotent (G₁ × G₂)"
  },
  {
    "name": "has_le.le.lt_of_ne",
    "statement": "theorem has_le.le.lt_of_ne {α : Type u} [partial_order α] {a b : α} : a ≤ b → a ≠ b → a < b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → a ≠ b → a < b",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of lt_of_le_of_ne`.",
    "kind": "theorem",
    "type": "a ≤ b → a ≠ b → a < b"
  },
  {
    "name": "mul_ne_zero_comm",
    "statement": "theorem mul_ne_zero_comm {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ b * a ≠ 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ b * a ≠ 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then for elements `a, b : α`, `a * b` is nonzero iff so is `b * a`.",
    "kind": "theorem",
    "type": "a * b ≠ 0 ↔ b * a ≠ 0"
  },
  {
    "name": "multiset.countp",
    "statement": "def multiset.countp {α : Type u_1} (p : α → Prop) [decidable_pred p] (s : multiset α) : ℕ",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : multiset α) : ℕ",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : multiset α)",
    "doc_string": "`countp p s` counts the number of elements of `s` (with multiplicity) that  satisfy `p`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "category_theory.limits.has_zero_object.zero_is_terminal",
    "statement": "def category_theory.limits.has_zero_object.zero_is_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_terminal 0",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_terminal 0",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C]",
    "doc_string": "A zero object is in particular terminal.",
    "kind": "def",
    "type": "category_theory.limits.is_terminal 0"
  },
  {
    "name": "finset.has_vadd_finset",
    "statement": "def finset.has_vadd_finset {α : Type u_2} {β : Type u_3} [decidable_eq β] [has_vadd α β] : has_vadd α (finset β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [decidable_eq β] [has_vadd α β] : has_vadd α (finset β)",
    "args": "{α : Type u_2} {β : Type u_3} [decidable_eq β] [has_vadd α β]",
    "doc_string": "The translation of a finset `s` by a vector `a`: `a +ᵥ s = {a +ᵥ x | x ∈ s}`.",
    "kind": "def",
    "type": "has_vadd α (finset β)"
  },
  {
    "name": "nnreal.pi",
    "statement": "def nnreal.pi  : nnreal",
    "theorem": " : nnreal",
    "args": "",
    "doc_string": "`π` considered as a nonnegative real.",
    "kind": "def",
    "type": "nnreal"
  },
  {
    "name": "functor.const",
    "statement": "def functor.const (α : Type u_1) (β : Type u_2) : Type u_1",
    "theorem": "(α : Type u_1) (β : Type u_2) : Type u_1",
    "args": "(α : Type u_1) (β : Type u_2)",
    "doc_string": " `const α` is the constant functor, mapping every type to `α`. When `α` has a monoid structure, `const α` has an `applicative` instance. (If `α` has an additive monoid structure, see `functor.add_const`.)",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "list.to_chunks_aux",
    "statement": "def list.to_chunks_aux {α : Type u_1} (n : ℕ) : list α → ℕ → list α × list (list α)",
    "theorem": "{α : Type u_1} (n : ℕ) : list α → ℕ → list α × list (list α)",
    "args": "{α : Type u_1} (n : ℕ)",
    "doc_string": "Auxliary definition used to define `to_chunks`.   `to_chunks_aux n xs i` returns `(xs.take i, (xs.drop i).to_chunks (n+1))`,  that is, the first `i` elements of `xs`, and the remaining elements chunked into  sublists of length `n+1`.",
    "kind": "def",
    "type": "list α → ℕ → list α × list (list α)"
  },
  {
    "name": "con.complete_lattice",
    "statement": "def con.complete_lattice {M : Type u_1} [has_mul M] : complete_lattice (con M)",
    "theorem": "{M : Type u_1} [has_mul M] : complete_lattice (con M)",
    "args": "{M : Type u_1} [has_mul M]",
    "doc_string": "The complete lattice of congruence relations on a given type with a multiplication.",
    "kind": "def",
    "type": "complete_lattice (con M)"
  },
  {
    "name": "category_theory.single_obj.star",
    "statement": "def category_theory.single_obj.star (α : Type u) : category_theory.single_obj α",
    "theorem": "(α : Type u) : category_theory.single_obj α",
    "args": "(α : Type u)",
    "doc_string": "The single object in `single_obj α`.",
    "kind": "def",
    "type": "category_theory.single_obj α"
  },
  {
    "name": "right.add_pos_of_nonneg_of_pos",
    "statement": "theorem right.add_pos_of_nonneg_of_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_nonneg_of_pos`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "paracompact_of_compact",
    "statement": "def paracompact_of_compact {X : Type v} [topological_space X] [compact_space X] : paracompact_space X",
    "theorem": "{X : Type v} [topological_space X] [compact_space X] : paracompact_space X",
    "args": "{X : Type v} [topological_space X] [compact_space X]",
    "doc_string": "A compact space is paracompact.",
    "kind": "def",
    "type": "paracompact_space X"
  },
  {
    "name": "stream.append_stream",
    "statement": "def stream.append_stream {α : Type u} : list α → stream α → stream α",
    "theorem": "{α : Type u} : list α → stream α → stream α",
    "args": "{α : Type u}",
    "doc_string": "Append a stream to a list.",
    "kind": "def",
    "type": "list α → stream α → stream α"
  },
  {
    "name": "add_subgroup.normal",
    "statement": "structure add_subgroup.normal {A : Type u_2} [add_group A] (H : add_subgroup A) : Prop",
    "theorem": "{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop",
    "args": "{A : Type u_2} [add_group A] (H : add_subgroup A)",
    "doc_string": "An add_subgroup is normal if whenever `n ∈ H`, then `g + n - g ∈ H` for every `g : G`",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ennreal.mul_action",
    "statement": "def ennreal.mul_action {M : Type u_1} [mul_action ennreal M] : mul_action nnreal M",
    "theorem": "{M : Type u_1} [mul_action ennreal M] : mul_action nnreal M",
    "args": "{M : Type u_1} [mul_action ennreal M]",
    "doc_string": "A `mul_action` over `ℝ≥0∞` restricts to a `mul_action` over `ℝ≥0`.",
    "kind": "def",
    "type": "mul_action nnreal M"
  },
  {
    "name": "has_groupoid",
    "statement": "structure has_groupoid {H : Type u_5} [topological_space H] (M : Type u_6) [topological_space M] [charted_space H M] (G : structure_groupoid H) : Prop",
    "theorem": "{H : Type u_5} [topological_space H] (M : Type u_6) [topological_space M] [charted_space H M] (G : structure_groupoid H) : Prop",
    "args": "{H : Type u_5} [topological_space H] (M : Type u_6) [topological_space M] [charted_space H M] (G : structure_groupoid H)",
    "doc_string": " A charted space has an atlas in a groupoid `G` if the change of coordinates belong to the groupoid",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "polynomial",
    "statement": "structure polynomial (R : Type u_1) [semiring R] : Type u_1",
    "theorem": "(R : Type u_1) [semiring R] : Type u_1",
    "args": "(R : Type u_1) [semiring R]",
    "doc_string": " `polynomial R` is the type of univariate polynomials over `R`.  Polynomials should be seen as (semi-)rings with the additional constructor `X`. The embedding from `R` is called `C`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "unitization.fst",
    "statement": "def unitization.fst {R : Type u_1} {A : Type u_2} (x : unitization R A) : R",
    "theorem": "{R : Type u_1} {A : Type u_2} (x : unitization R A) : R",
    "args": "{R : Type u_1} {A : Type u_2} (x : unitization R A)",
    "doc_string": "The canonical projection `unitization R A → R`.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "fin.comm_ring",
    "statement": "def fin.comm_ring (n : ℕ) : comm_ring (fin (n + 1))",
    "theorem": "(n : ℕ) : comm_ring (fin (n + 1))",
    "args": "(n : ℕ)",
    "doc_string": "Commutative ring structure on `fin (n+1)`.",
    "kind": "def",
    "type": "comm_ring (fin (n + 1))"
  },
  {
    "name": "le_add_of_sub_left_le",
    "statement": "theorem le_add_of_sub_left_le {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a - b ≤ c → a ≤ b + c",
    "theorem": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a - b ≤ c → a ≤ b + c",
    "args": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of sub_le_iff_le_add'`.",
    "kind": "theorem",
    "type": "a - b ≤ c → a ≤ b + c"
  },
  {
    "name": "metric.Hausdorff_dist_self_zero",
    "statement": "theorem metric.Hausdorff_dist_self_zero {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α}",
    "doc_string": "The Hausdorff distance between a set and itself is zero",
    "kind": "theorem",
    "type": "metric.Hausdorff_dist s s = 0"
  },
  {
    "name": "associated",
    "statement": "def associated {α : Type u_1} [monoid α] (x y : α) : Prop",
    "theorem": "{α : Type u_1} [monoid α] (x y : α) : Prop",
    "args": "{α : Type u_1} [monoid α] (x y : α)",
    "doc_string": " Two elements of a `monoid` are `associated` if one of them is another one multiplied by a unit on the right.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.find_greatest",
    "statement": "def nat.find_greatest (P : ℕ → Prop) [decidable_pred P] : ℕ → ℕ",
    "theorem": "(P : ℕ → Prop) [decidable_pred P] : ℕ → ℕ",
    "args": "(P : ℕ → Prop) [decidable_pred P]",
    "doc_string": " `find_greatest P b` is the largest `i ≤ bound` such that `P i` holds, or `0` if no such `i` exists",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "uniform_convergence.uniform_space",
    "statement": "def uniform_convergence.uniform_space (α : Type u_1) (β : Type u_2) [uniform_space β] : uniform_space (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [uniform_space β] : uniform_space (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [uniform_space β]",
    "doc_string": "Uniform structure of uniform convergence",
    "kind": "def",
    "type": "uniform_space (α → β)"
  },
  {
    "name": "functor.liftp",
    "statement": "def functor.liftp {F : Type u → Type u} [functor F] {α : Type u} (p : α → Prop) (x : F α) : Prop",
    "theorem": "{F : Type u → Type u} [functor F] {α : Type u} (p : α → Prop) (x : F α) : Prop",
    "args": "{F : Type u → Type u} [functor F] {α : Type u} (p : α → Prop) (x : F α)",
    "doc_string": " If we consider `x : F α` to, in some sense, contain values of type `α`, predicate `liftp p x` holds iff every value contained by `x` satisfies `p`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "zero_lt.pos_mul_mono",
    "statement": "def zero_lt.pos_mul_mono (X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop",
    "theorem": "(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop",
    "args": "(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X]",
    "doc_string": "  `zero_lt.pos_mul_mono α` is an abbreviation for `covariant_class α>0 α (λ x y, x * y) (≤)`, expressing that multiplication by positive elements on the left is monotone.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "first_order.language.with_constants",
    "statement": "def first_order.language.with_constants (L : first_order.language) (α : Type w) : first_order.language",
    "theorem": "(L : first_order.language) (α : Type w) : first_order.language",
    "args": "(L : first_order.language) (α : Type w)",
    "doc_string": "Extends a language with a constant for each element of a parameter set in `M`.",
    "kind": "def",
    "type": "first_order.language"
  },
  {
    "name": "not_bdd_above_iff",
    "statement": "theorem not_bdd_above_iff {α : Type u_1} [linear_order α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y",
    "theorem": "{α : Type u_1} [linear_order α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y",
    "args": "{α : Type u_1} [linear_order α] {s : set α}",
    "doc_string": " A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` that is greater than `x`. A version for preorders is called `not_bdd_above_iff'`.",
    "kind": "theorem",
    "type": "¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y"
  },
  {
    "name": "matrix.inv_eq_right_inv",
    "statement": "theorem matrix.inv_eq_right_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : A.mul B = 1) : A⁻¹ = B",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : A.mul B = 1) : A⁻¹ = B",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : A.mul B = 1)",
    "doc_string": "If matrix A is right invertible, then its inverse equals its right inverse.",
    "kind": "theorem",
    "type": "A⁻¹ = B"
  },
  {
    "name": "Inf_convergence_class",
    "statement": "structure Inf_convergence_class (α : Type u_3) [preorder α] [topological_space α] : Prop",
    "theorem": "(α : Type u_3) [preorder α] [topological_space α] : Prop",
    "args": "(α : Type u_3) [preorder α] [topological_space α]",
    "doc_string": " We say that `α` is an `Inf_convergence_class` if the following holds. Let `f : ι → α` be a monotone function, let `a : α` be a greatest lower bound of `set.range f`. Then `f x` tends to `𝓝 a` as `x → -∞` (formally, at the filter `filter.at_bot`). We require this for `ι = (s : set α)`, `f = coe` in the definition, then prove it for any `f` in `tendsto_at_bot_is_glb`.  This property holds for linear orders with order topology as well as their products.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "set.left_inv_on",
    "statement": "def set.left_inv_on {α : Type u} {β : Type v} (f' : β → α) (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u} {β : Type v} (f' : β → α) (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u} {β : Type v} (f' : β → α) (f : α → β) (s : set α)",
    "doc_string": "`g` is a left inverse to `f` on `a` means that `g (f x) = x` for all `x ∈ a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.prime_counting",
    "statement": "def nat.prime_counting (n : ℕ) : ℕ",
    "theorem": "(n : ℕ) : ℕ",
    "args": "(n : ℕ)",
    "doc_string": "The prime counting function: Returns the number of primes less than or equal to the input.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "Compactum_to_CompHaus.ess_surj",
    "statement": "theorem Compactum_to_CompHaus.ess_surj  : category_theory.ess_surj Compactum_to_CompHaus",
    "theorem": " : category_theory.ess_surj Compactum_to_CompHaus",
    "args": "",
    "doc_string": "The functor Compactum_to_CompHaus is essentially surjective.",
    "kind": "theorem",
    "type": "category_theory.ess_surj Compactum_to_CompHaus"
  },
  {
    "name": "nat.min_sq_fac_aux",
    "statement": "def nat.min_sq_fac_aux  : ℕ → ℕ → option ℕ",
    "theorem": " : ℕ → ℕ → option ℕ",
    "args": "",
    "doc_string": "Assuming that `n` has no factors less than `k`, returns the smallest prime `p` such that  `p^2 ∣ n`.",
    "kind": "def",
    "type": "ℕ → ℕ → option ℕ"
  },
  {
    "name": "graded_algebra",
    "statement": "structure graded_algebra {ι : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq ι] [add_monoid ι] [comm_semiring R] [semiring A] [algebra R A] (𝒜 : ι → submodule R A) : Type (max u_1 u_3)",
    "theorem": "{ι : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq ι] [add_monoid ι] [comm_semiring R] [semiring A] [algebra R A] (𝒜 : ι → submodule R A) : Type (max u_1 u_3)",
    "args": "{ι : Type u_1} {R : Type u_2} {A : Type u_3} [decidable_eq ι] [add_monoid ι] [comm_semiring R] [semiring A] [algebra R A] (𝒜 : ι → submodule R A)",
    "doc_string": " An internally-graded `R`-algebra `A` is one that can be decomposed into a collection of `submodule R A`s indexed by `ι` such that the canonical map `A → ⨁ i, 𝒜 i` is bijective and respects multiplication, i.e. the product of an element of degree `i` and an element of degree `j` is an element of degree `i + j`.  Note that the fact that `A` is internally-graded, `graded_algebra 𝒜`, implies an externally-graded algebra structure `direct_sum.galgebra R (λ i, ↥(𝒜 i))`, which in turn makes available an `algebra R (⨁ i, 𝒜 i)` instance.",
    "kind": "structure",
    "type": "Type (max u_1 u_3)"
  },
  {
    "name": "add_subgroup.add_mem",
    "statement": "theorem add_subgroup.add_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x ∈ H → y ∈ H → x + y ∈ H",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} : x ∈ H → y ∈ H → x + y ∈ H",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G}",
    "doc_string": "An `add_subgroup` is closed under addition.",
    "kind": "theorem",
    "type": "x ∈ H → y ∈ H → x + y ∈ H"
  },
  {
    "name": "set.subtraction_monoid",
    "statement": "def set.subtraction_monoid {α : Type u_2} [subtraction_monoid α] : subtraction_monoid (set α)",
    "theorem": "{α : Type u_2} [subtraction_monoid α] : subtraction_monoid (set α)",
    "args": "{α : Type u_2} [subtraction_monoid α]",
    "doc_string": "`set α` is a subtraction monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "subtraction_monoid (set α)"
  },
  {
    "name": "add_cancel_comm_monoid",
    "statement": "structure add_cancel_comm_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": "Commutative version of `add_cancel_monoid`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "con.coe_one",
    "statement": "theorem con.coe_one {M : Type u_1} [mul_one_class M] {c : con M} : ↑1 = 1",
    "theorem": "{M : Type u_1} [mul_one_class M] {c : con M} : ↑1 = 1",
    "args": "{M : Type u_1} [mul_one_class M] {c : con M}",
    "doc_string": "The 1 of the quotient of a monoid by a congruence relation is the equivalence class of the    monoid's 1.",
    "kind": "theorem",
    "type": "↑1 = 1"
  },
  {
    "name": "is_regular.subsingleton",
    "statement": "theorem is_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R] (h : is_regular 0)",
    "doc_string": "The element `0` is regular if and only if `R` is trivial.",
    "kind": "theorem",
    "type": "subsingleton R"
  },
  {
    "name": "topological_space.countable_basis",
    "statement": "def topological_space.countable_basis (α : Type u) [t : topological_space α] [topological_space.second_countable_topology α] : set (set α)",
    "theorem": "(α : Type u) [t : topological_space α] [topological_space.second_countable_topology α] : set (set α)",
    "args": "(α : Type u) [t : topological_space α] [topological_space.second_countable_topology α]",
    "doc_string": "A countable topological basis of `α`.",
    "kind": "def",
    "type": "set (set α)"
  },
  {
    "name": "qpf.liftp_preservation",
    "statement": "def qpf.liftp_preservation {F : Type u → Type u} [functor F] (q : qpf F) : Prop",
    "theorem": "{F : Type u → Type u} [functor F] (q : qpf F) : Prop",
    "args": "{F : Type u → Type u} [functor F] (q : qpf F)",
    "doc_string": "does `abs` preserve `liftp`?",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "inv_lt_one'",
    "statement": "theorem inv_lt_one' {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "kind": "theorem",
    "type": "a⁻¹ < 1 ↔ 1 < a"
  },
  {
    "name": "finset.nat.antidiagonal_tuple",
    "statement": "def finset.nat.antidiagonal_tuple (k n : ℕ) : finset (fin k → ℕ)",
    "theorem": "(k n : ℕ) : finset (fin k → ℕ)",
    "args": "(k n : ℕ)",
    "doc_string": "`finset.antidiagonal_tuple k n` is a finset of `k`-tuples summing to `n`",
    "kind": "def",
    "type": "finset (fin k → ℕ)"
  },
  {
    "name": "AddMagma.of",
    "statement": "def AddMagma.of (M : Type u) [has_add M] : AddMagma",
    "theorem": "(M : Type u) [has_add M] : AddMagma",
    "args": "(M : Type u) [has_add M]",
    "doc_string": "Construct a bundled `AddMagma` from the underlying type and typeclass.",
    "kind": "def",
    "type": "AddMagma"
  },
  {
    "name": "mul_lt_one_of_lt_of_le",
    "statement": "theorem mul_lt_one_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1)",
    "doc_string": "**Alias** of left.mul_lt_one_of_lt_of_le`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "num.div",
    "statement": "def num.div  : num → num → num",
    "theorem": " : num → num → num",
    "args": "",
    "doc_string": "Division of `num`s, where `x / 0 = 0`.",
    "kind": "def",
    "type": "num → num → num"
  },
  {
    "name": "multiset.nat.antidiagonal_zero",
    "statement": "theorem multiset.nat.antidiagonal_zero  : multiset.nat.antidiagonal 0 = {(0, 0)}",
    "theorem": " : multiset.nat.antidiagonal 0 = {(0, 0)}",
    "args": "",
    "doc_string": "The antidiagonal of `0` is the list `[(0, 0)]`",
    "kind": "theorem",
    "type": "multiset.nat.antidiagonal 0 = {(0, 0)}"
  },
  {
    "name": "nonote",
    "statement": "def nonote  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of normal ordinal notations. (It would have been  nicer to define this right in the inductive type, but `NF o`  requires `repr` which requires `onote`, so all these things  would have to be defined at once, which messes up the VM  representation.)",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "zeroth_homotopy",
    "statement": "def zeroth_homotopy (X : Type u_1) [topological_space X] : Type u_1",
    "theorem": "(X : Type u_1) [topological_space X] : Type u_1",
    "args": "(X : Type u_1) [topological_space X]",
    "doc_string": "The quotient type of points of a topological space modulo being joined by a continuous path.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "composition_as_set",
    "statement": "structure composition_as_set (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": " Combinatorial viewpoint on a composition of `n`, by seeing it as non-empty blocks of consecutive integers in `{0, ..., n-1}`. We register every block by its left end-point, yielding a finset containing `0`. As this does not make sense for `n = 0`, we add `n` to this finset, and get a finset of `{0, ..., n}` containing `0` and `n`. This is the data in the structure `composition_as_set n`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "category_theory.is_isomorphic_setoid",
    "statement": "def category_theory.is_isomorphic_setoid (C : Type u) [category_theory.category C] : setoid C",
    "theorem": "(C : Type u) [category_theory.category C] : setoid C",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`is_isomorphic` defines a setoid.",
    "kind": "def",
    "type": "setoid C"
  },
  {
    "name": "SemiNormedGroup₁",
    "statement": "def SemiNormedGroup₁  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "`SemiNormedGroup₁` is a type synonym for `SemiNormedGroup`, which we shall equip with the category structure consisting only of the norm non-increasing maps.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "ordnode.to_list",
    "statement": "def ordnode.to_list {α : Type u} (t : ordnode α) : list α",
    "theorem": "{α : Type u} (t : ordnode α) : list α",
    "args": "{α : Type u} (t : ordnode α)",
    "doc_string": "O(n). Build a list of elements in ascending order from the tree.      to_list {1, 2, 4} = [1, 2, 4]     to_list {2, 1, 1, 4} = [1, 2, 4]",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "local_ring.residue_field",
    "statement": "def local_ring.residue_field (R : Type u) [comm_ring R] [local_ring R] : Type u",
    "theorem": "(R : Type u) [comm_ring R] [local_ring R] : Type u",
    "args": "(R : Type u) [comm_ring R] [local_ring R]",
    "doc_string": "The residue field of a local ring is the quotient of the ring by its maximal ideal.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "norm_num.is_fib_aux",
    "statement": "def norm_num.is_fib_aux (n a b : ℕ) : Prop",
    "theorem": "(n a b : ℕ) : Prop",
    "args": "(n a b : ℕ)",
    "doc_string": "Auxiliary definition for `prove_fib` plugin.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "local_equiv.symm",
    "statement": "def local_equiv.symm {α : Type u_1} {β : Type u_2} (e : local_equiv α β) : local_equiv β α",
    "theorem": "{α : Type u_1} {β : Type u_2} (e : local_equiv α β) : local_equiv β α",
    "args": "{α : Type u_1} {β : Type u_2} (e : local_equiv α β)",
    "doc_string": "The inverse of a local equiv",
    "kind": "def",
    "type": "local_equiv β α"
  },
  {
    "name": "well_founded.cut_expand",
    "statement": "theorem well_founded.cut_expand {α : Type u_1} {r : α → α → Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)",
    "theorem": "{α : Type u_1} {r : α → α → Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)",
    "args": "{α : Type u_1} {r : α → α → Prop} (hr : well_founded r)",
    "doc_string": "`cut_expand r` is well-founded when `r` is.",
    "kind": "theorem",
    "type": "well_founded (relation.cut_expand r)"
  },
  {
    "name": "num.mul",
    "statement": "def num.mul  : num → num → num",
    "theorem": " : num → num → num",
    "args": "",
    "doc_string": "Multiplication of two `num`s.",
    "kind": "def",
    "type": "num → num → num"
  },
  {
    "name": "is_group_hom.injective_iff",
    "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1",
    "theorem": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1",
    "args": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f)",
    "doc_string": "A group homomorphism is injective iff its kernel is trivial.",
    "kind": "theorem",
    "type": "function.injective f ↔ ∀ (a : α), f a = 1 → a = 1"
  },
  {
    "name": "ordnode.partition",
    "statement": "def ordnode.partition {α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α × ordnode α",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α × ordnode α",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p]",
    "doc_string": "O(n). Split the elements of a tree into those satisfying, and not satisfying, a predicate.      partition (λ x, x < 3) {1, 2, 4} = ({1, 2}, {3})",
    "kind": "def",
    "type": "ordnode α → ordnode α × ordnode α"
  },
  {
    "name": "category_theory.free_bicategory.hom",
    "statement": "inductive category_theory.free_bicategory.hom {B : Type u} [quiver B] : B → B → Type (max u v)",
    "theorem": "{B : Type u} [quiver B] : B → B → Type (max u v)",
    "args": "{B : Type u} [quiver B]",
    "doc_string": "1-morphisms in the free bicategory.",
    "kind": "inductive",
    "type": "B → B → Type (max u v)"
  },
  {
    "name": "pos_num.size",
    "statement": "def pos_num.size  : pos_num → pos_num",
    "theorem": " : pos_num → pos_num",
    "args": "",
    "doc_string": "The number of bits of a `pos_num`, as a `pos_num`.",
    "kind": "def",
    "type": "pos_num → pos_num"
  },
  {
    "name": "pSet.powerset",
    "statement": "def pSet.powerset  : pSet → pSet",
    "theorem": " : pSet → pSet",
    "args": "",
    "doc_string": "The pre-set powerset operator",
    "kind": "def",
    "type": "pSet → pSet"
  },
  {
    "name": "discrete_valuation_ring",
    "statement": "structure discrete_valuation_ring (R : Type u) [comm_ring R] [is_domain R] : Prop",
    "theorem": "(R : Type u) [comm_ring R] [is_domain R] : Prop",
    "args": "(R : Type u) [comm_ring R] [is_domain R]",
    "doc_string": "An integral domain is a *discrete valuation ring* (DVR) if it's a local PID which  is not a field.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "metric.Hausdorff_dist_empty",
    "statement": "theorem metric.Hausdorff_dist_empty {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s ∅ = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s ∅ = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α}",
    "doc_string": " The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞)",
    "kind": "theorem",
    "type": "metric.Hausdorff_dist s ∅ = 0"
  },
  {
    "name": "fintype.trunc_encodable",
    "statement": "def fintype.trunc_encodable (α : Type u_1) [decidable_eq α] [fintype α] : trunc (encodable α)",
    "theorem": "(α : Type u_1) [decidable_eq α] [fintype α] : trunc (encodable α)",
    "args": "(α : Type u_1) [decidable_eq α] [fintype α]",
    "doc_string": " A finite type is encodable. Because the encoding is not unique, we wrap it in `trunc` to preserve computability.",
    "kind": "def",
    "type": "trunc (encodable α)"
  },
  {
    "name": "npow_rec",
    "statement": "def npow_rec {M : Type u} [has_one M] [has_mul M] : ℕ → M → M",
    "theorem": "{M : Type u} [has_one M] [has_mul M] : ℕ → M → M",
    "args": "{M : Type u} [has_one M] [has_mul M]",
    "doc_string": " The fundamental power operation in a monoid. `npow_rec n a = a*a*...*a` n times. Use instead `a ^ n`,  which has better definitional behavior.",
    "kind": "def",
    "type": "ℕ → M → M"
  },
  {
    "name": "path.trans",
    "statement": "def path.trans {X : Type u_1} [topological_space X] {x y z : X} (γ : path x y) (γ' : path y z) : path x z",
    "theorem": "{X : Type u_1} [topological_space X] {x y z : X} (γ : path x y) (γ' : path y z) : path x z",
    "args": "{X : Type u_1} [topological_space X] {x y z : X} (γ : path x y) (γ' : path y z)",
    "doc_string": " Concatenation of two paths from `x` to `y` and from `y` to `z`, putting the first path on `[0, 1/2]` and the second one on `[1/2, 1]`.",
    "kind": "def",
    "type": "path x z"
  },
  {
    "name": "matrix.linfty_op_non_unital_semi_normed_ring",
    "statement": "def matrix.linfty_op_non_unital_semi_normed_ring {n : Type u_4} {α : Type u_5} [fintype n] [non_unital_semi_normed_ring α] : non_unital_semi_normed_ring (matrix n n α)",
    "theorem": "{n : Type u_4} {α : Type u_5} [fintype n] [non_unital_semi_normed_ring α] : non_unital_semi_normed_ring (matrix n n α)",
    "args": "{n : Type u_4} {α : Type u_5} [fintype n] [non_unital_semi_normed_ring α]",
    "doc_string": " Seminormed non-unital ring instance (using sup norm of L1 norm) for matrices over a semi normed non-unital ring. Not declared as an instance because there are several natural choices for defining the norm of a matrix.",
    "kind": "def",
    "type": "non_unital_semi_normed_ring (matrix n n α)"
  },
  {
    "name": "composition_series",
    "statement": "structure composition_series (X : Type u) [lattice X] [jordan_holder_lattice X] : Type u",
    "theorem": "(X : Type u) [lattice X] [jordan_holder_lattice X] : Type u",
    "args": "(X : Type u) [lattice X] [jordan_holder_lattice X]",
    "doc_string": "A `composition_series X` is a finite nonempty series of elements of a `jordan_holder_lattice` such that each element is maximal inside the next. The length of a `composition_series X` is one less than the number of elements in the series. Note that there is no stipulation that a series start from the bottom of the lattice and finish at the top. For a composition series `s`, `s.top` is the largest element of the series, and `s.bot` is the least element.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "prime_spectrum",
    "statement": "def prime_spectrum (R : Type u) [comm_ring R] : Type u",
    "theorem": "(R : Type u) [comm_ring R] : Type u",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": " The prime spectrum of a commutative ring `R` is the type of all prime ideals of `R`.  It is naturally endowed with a topology (the Zariski topology), and a sheaf of commutative rings (see `algebraic_geometry.structure_sheaf`). It is a fundamental building block in algebraic geometry.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "bilin_form.is_pair_self_adjoint",
    "statement": "def bilin_form.is_pair_self_adjoint {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B F : bilin_form R M) (f : module.End R M) : Prop",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B F : bilin_form R M) (f : module.End R M) : Prop",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B F : bilin_form R M) (f : module.End R M)",
    "doc_string": " The condition for an endomorphism to be \"self-adjoint\" with respect to a pair of bilinear forms on the underlying module. In the case that these two forms are identical, this is the usual concept of self adjointness. In the case that one of the forms is the negation of the other, this is the usual concept of skew adjointness.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pseudo_metric_space.replace_uniformity",
    "statement": "def pseudo_metric_space.replace_uniformity {α : Type u_1} [U : uniform_space α] (m : pseudo_metric_space α) (H : uniformity α = uniformity α) : pseudo_metric_space α",
    "theorem": "{α : Type u_1} [U : uniform_space α] (m : pseudo_metric_space α) (H : uniformity α = uniformity α) : pseudo_metric_space α",
    "args": "{α : Type u_1} [U : uniform_space α] (m : pseudo_metric_space α) (H : uniformity α = uniformity α)",
    "doc_string": " Build a new pseudometric space from an old one where the bundled uniform structure is provably (but typically non-definitionaly) equal to some given uniform structure. See Note [forgetful inheritance].",
    "kind": "def",
    "type": "pseudo_metric_space α"
  },
  {
    "name": "set.nonempty",
    "statement": "def set.nonempty {α : Type u} (s : set α) : Prop",
    "theorem": "{α : Type u} (s : set α) : Prop",
    "args": "{α : Type u} (s : set α)",
    "doc_string": " The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks to the dot notation.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lists.mem",
    "statement": "def lists.mem {α : Type u_1} (a : lists α) : lists α → Prop",
    "theorem": "{α : Type u_1} (a : lists α) : lists α → Prop",
    "args": "{α : Type u_1} (a : lists α)",
    "doc_string": " Membership of ZFA list. A ZFA list belongs to a proper ZFA list if it belongs to the latter as a proper ZFA prelist. An atom has no members.",
    "kind": "def",
    "type": "lists α → Prop"
  },
  {
    "name": "generalized_continued_fraction.pair.has_coe_to_generalized_continued_fraction_pair",
    "statement": "def generalized_continued_fraction.pair.has_coe_to_generalized_continued_fraction_pair {α : Type u_1} {β : Type u_2} [has_coe α β] : has_coe (generalized_continued_fraction.pair α) (generalized_continued_fraction.pair β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_coe α β] : has_coe (generalized_continued_fraction.pair α) (generalized_continued_fraction.pair β)",
    "args": "{α : Type u_1} {β : Type u_2} [has_coe α β]",
    "doc_string": "Coerce a pair by elementwise coercion.",
    "kind": "def",
    "type": "has_coe (generalized_continued_fraction.pair α) (generalized_continued_fraction.pair β)"
  },
  {
    "name": "one_div_le_one_div",
    "statement": "theorem one_div_le_one_div {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ 1 / b ↔ b ≤ a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ 1 / b ↔ b ≤ a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "For the single implications with fewer assumptions, see `one_div_le_one_div_of_le` and  `le_of_one_div_le_one_div`",
    "kind": "theorem",
    "type": "1 / a ≤ 1 / b ↔ b ≤ a"
  },
  {
    "name": "try_for",
    "statement": "def try_for {α : Type u} (max : ℕ) (f : thunk α) : option α",
    "theorem": "{α : Type u} (max : ℕ) (f : thunk α) : option α",
    "args": "{α : Type u} (max : ℕ) (f : thunk α)",
    "doc_string": "This function has a native implementation where the thunk is interrupted if it takes more than 'max' \"heartbeats\" to compute it. The heartbeat is approx. the maximum number of memory allocations (in thousands) performed by 'f ()'. This is a deterministic way of interrupting long running tasks.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "nonarchimedean_ring.to_nonarchimedean_add_group",
    "statement": "def nonarchimedean_ring.to_nonarchimedean_add_group (R : Type u_1) [ring R] [topological_space R] [t : nonarchimedean_ring R] : nonarchimedean_add_group R",
    "theorem": "(R : Type u_1) [ring R] [topological_space R] [t : nonarchimedean_ring R] : nonarchimedean_add_group R",
    "args": "(R : Type u_1) [ring R] [topological_space R] [t : nonarchimedean_ring R]",
    "doc_string": "Every nonarchimedean ring is naturally a nonarchimedean additive group.",
    "kind": "def",
    "type": "nonarchimedean_add_group R"
  },
  {
    "name": "ultrafilter_is_closed_basic",
    "statement": "theorem ultrafilter_is_closed_basic {α : Type u} (s : set α) : is_closed {u : ultrafilter α | s ∈ u}",
    "theorem": "{α : Type u} (s : set α) : is_closed {u : ultrafilter α | s ∈ u}",
    "args": "{α : Type u} (s : set α)",
    "doc_string": "The basic open sets for the topology on ultrafilters are also closed.",
    "kind": "theorem",
    "type": "is_closed {u : ultrafilter α | s ∈ u}"
  },
  {
    "name": "polish_space.pi_countable",
    "statement": "def polish_space.pi_countable {ι : Type u_1} [encodable ι] {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] [∀ (i : ι), polish_space (E i)] : polish_space (Π (i : ι), E i)",
    "theorem": "{ι : Type u_1} [encodable ι] {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] [∀ (i : ι), polish_space (E i)] : polish_space (Π (i : ι), E i)",
    "args": "{ι : Type u_1} [encodable ι] {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] [∀ (i : ι), polish_space (E i)]",
    "doc_string": "A countable product of Polish spaces is Polish.",
    "kind": "def",
    "type": "polish_space (Π (i : ι), E i)"
  },
  {
    "name": "bitvec.and",
    "statement": "def bitvec.and {n : ℕ} : bitvec n → bitvec n → bitvec n",
    "theorem": "{n : ℕ} : bitvec n → bitvec n → bitvec n",
    "args": "{n : ℕ}",
    "doc_string": "bitwise and",
    "kind": "def",
    "type": "bitvec n → bitvec n → bitvec n"
  },
  {
    "name": "finite_field.is_square_of_char_two",
    "statement": "theorem finite_field.is_square_of_char_two {F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a",
    "theorem": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a",
    "args": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F)",
    "doc_string": "In a finite field of characteristic `2`, all elements are squares.",
    "kind": "theorem",
    "type": "is_square a"
  },
  {
    "name": "lattice_ordered_comm_group.lattice_ordered_comm_group_to_distrib_lattice",
    "statement": "def lattice_ordered_comm_group.lattice_ordered_comm_group_to_distrib_lattice (α : Type u) [s : lattice α] [comm_group α] [covariant_class α α has_mul.mul has_le.le] : distrib_lattice α",
    "theorem": "(α : Type u) [s : lattice α] [comm_group α] [covariant_class α α has_mul.mul has_le.le] : distrib_lattice α",
    "args": "(α : Type u) [s : lattice α] [comm_group α] [covariant_class α α has_mul.mul has_le.le]",
    "doc_string": "Every lattice ordered commutative group is a distributive lattice",
    "kind": "def",
    "type": "distrib_lattice α"
  },
  {
    "name": "padic_seq.valuation",
    "statement": "def padic_seq.valuation {p : ℕ} [fact (nat.prime p)] (f : padic_seq p) : ℤ",
    "theorem": "{p : ℕ} [fact (nat.prime p)] (f : padic_seq p) : ℤ",
    "args": "{p : ℕ} [fact (nat.prime p)] (f : padic_seq p)",
    "doc_string": "The `p`-adic valuation on `ℚ` lifts to `padic_seq p`. `valuation f` is defined to be the valuation of the (`ℚ`-valued) stationary point of `f`.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "monoid.closure_subset",
    "statement": "theorem monoid.closure_subset {M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ⊆ t) : monoid.closure s ⊆ t",
    "theorem": "{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ⊆ t) : monoid.closure s ⊆ t",
    "args": "{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ⊆ t)",
    "doc_string": "The submonoid generated by a set is contained in any submonoid that contains the set.",
    "kind": "theorem",
    "type": "monoid.closure s ⊆ t"
  },
  {
    "name": "guard",
    "statement": "def guard {f : Type → Type v} [alternative f] (p : Prop) [decidable p] : f unit",
    "theorem": "{f : Type → Type v} [alternative f] (p : Prop) [decidable p] : f unit",
    "args": "{f : Type → Type v} [alternative f] (p : Prop) [decidable p]",
    "doc_string": "If the condition `p` is decided to be false, then fail, otherwise, return unit.",
    "kind": "def",
    "type": "f unit"
  },
  {
    "name": "int.abs_le_self_pow_two",
    "statement": "theorem int.abs_le_self_pow_two (a : ℤ) : ↑(a.nat_abs) ≤ a ^ 2",
    "theorem": "(a : ℤ) : ↑(a.nat_abs) ≤ a ^ 2",
    "args": "(a : ℤ)",
    "doc_string": "**Alias** of int.abs_le_self_sq`.",
    "kind": "theorem",
    "type": "↑(a.nat_abs) ≤ a ^ 2"
  },
  {
    "name": "complete_lattice_hom.to_Sup_hom",
    "statement": "def complete_lattice_hom.to_Sup_hom {α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : complete_lattice_hom α β) : Sup_hom α β",
    "theorem": "{α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : complete_lattice_hom α β) : Sup_hom α β",
    "args": "{α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : complete_lattice_hom α β)",
    "doc_string": "Reinterpret a `complete_lattice_hom` as a `Sup_hom`.",
    "kind": "def",
    "type": "Sup_hom α β"
  },
  {
    "name": "rack.is_abelian",
    "statement": "def rack.is_abelian (R : Type u_1) [rack R] : Prop",
    "theorem": "(R : Type u_1) [rack R] : Prop",
    "args": "(R : Type u_1) [rack R]",
    "doc_string": "An abelian rack is one for which the mediality axiom holds.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "multiset.powerset_aux'",
    "statement": "def multiset.powerset_aux' {α : Type u_1} (l : list α) : list (multiset α)",
    "theorem": "{α : Type u_1} (l : list α) : list (multiset α)",
    "args": "{α : Type u_1} (l : list α)",
    "doc_string": " Helper function for the powerset of a multiset. Given a list `l`, returns a list of sublists of `l` (using `sublists'`), as multisets.",
    "kind": "def",
    "type": "list (multiset α)"
  },
  {
    "name": "onote.repr",
    "statement": "def onote.repr  : onote → ordinal",
    "theorem": " : onote → ordinal",
    "args": "",
    "doc_string": "The ordinal denoted by a notation",
    "kind": "def",
    "type": "onote → ordinal"
  },
  {
    "name": "omega_complete_partial_order.chain.zip",
    "statement": "def omega_complete_partial_order.chain.zip {α : Type u} {β : Type v} [preorder α] [preorder β] (c₀ : omega_complete_partial_order.chain α) (c₁ : omega_complete_partial_order.chain β) : omega_complete_partial_order.chain (α × β)",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (c₀ : omega_complete_partial_order.chain α) (c₁ : omega_complete_partial_order.chain β) : omega_complete_partial_order.chain (α × β)",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (c₀ : omega_complete_partial_order.chain α) (c₁ : omega_complete_partial_order.chain β)",
    "doc_string": "`chain.zip` pairs up the elements of two chains that have the same index",
    "kind": "def",
    "type": "omega_complete_partial_order.chain (α × β)"
  },
  {
    "name": "simps_cfg",
    "statement": "structure simps_cfg  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration options for the `@[simps]` attribute. * `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.   The attributes can be either basic attributes, or user attributes without parameters.   There are two attributes which `simps` might add itself:   * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.   * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked     with `@[to_additive]`. This is governed by the `add_additive` configuration option. * if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in   simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.   See note [dsimp, simp]. * `type_md` specifies how aggressively definitions are unfolded in the type of expressions   for the purposes of finding out whether the type is a function type.   Default: `instances`. This will unfold coercion instances (so that a coercion to a function type   is recognized as a function type), but not declarations like `set`. * `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes   of finding out whether it is a constructor.   Default: `none`   Exception: `@[simps]` will automatically add the options   `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with   the given reducibility setting for `rhs_md`. * If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied   terms, i.e. equalities between functions. This does not restrict the recursive behavior of   `@[simps]`, so only the \"final\" projection will be non-fully applied.   However, it can be used in combination with explicit field names, to get a partially applied   intermediate projection. * The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't   recursively apply projections. For example, given an equivalence `α × β ≃ β × α` one usually   wants to only apply the projections for `equiv`, and not also those for `×`. This option is   only relevant if no explicit projection names are given as argument to `@[simps]`. * The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will   print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,   except that it doesn't print information about the found projections. * if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This   option is automatically set to `tt` when the original declaration was tagged with   `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original   declaration.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "onote.NF_below",
    "statement": "inductive onote.NF_below  : onote → ordinal → Prop",
    "theorem": " : onote → ordinal → Prop",
    "args": "",
    "doc_string": "`NF_below o b` says that `o` is a normal form ordinal notation  satisfying `repr o < ω ^ b`.",
    "kind": "inductive",
    "type": "onote → ordinal → Prop"
  },
  {
    "name": "omega.nat.preform",
    "statement": "inductive omega.nat.preform  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Intermediate shadow syntax for LNA formulas that includes non-canonical terms",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "bounded_continuous_function.simps.apply",
    "statement": "def bounded_continuous_function.simps.apply {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] (h : bounded_continuous_function α β) : α → β",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] (h : bounded_continuous_function α β) : α → β",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] (h : bounded_continuous_function α β)",
    "doc_string": "See Note [custom simps projection]. We need to specify this projection explicitly in this case,  because it is a composition of multiple projections.",
    "kind": "def",
    "type": "α → β"
  },
  {
    "name": "galois_coinsertion.lift_semilattice_sup",
    "statement": "def galois_coinsertion.lift_semilattice_sup {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [semilattice_sup β] (gi : galois_coinsertion l u) : semilattice_sup α",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [semilattice_sup β] (gi : galois_coinsertion l u) : semilattice_sup α",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [semilattice_sup β] (gi : galois_coinsertion l u)",
    "doc_string": "Lift the suprema along a Galois coinsertion",
    "kind": "def",
    "type": "semilattice_sup α"
  },
  {
    "name": "pairwise",
    "statement": "def pairwise {α : Type u_1} (r : α → α → Prop) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop)",
    "doc_string": "A relation `r` holds pairwise if `r i j` for all `i ≠ j`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.length_pos_of_one_lt_prod",
    "statement": "theorem list.length_pos_of_one_lt_prod {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length",
    "theorem": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length",
    "args": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod)",
    "doc_string": "A list with product greater than one must have positive length.",
    "kind": "theorem",
    "type": "0 < L.length"
  },
  {
    "name": "turing.to_partrec.code.pred",
    "statement": "def turing.to_partrec.code.pred  : turing.to_partrec.code",
    "theorem": " : turing.to_partrec.code",
    "args": "",
    "doc_string": " `pred` returns the predecessor of the head of the input: `pred [] = [0]`, `pred (0 :: v) = [0]`, `pred (n+1 :: v) = [n]`.",
    "kind": "def",
    "type": "turing.to_partrec.code"
  },
  {
    "name": "strongly_measurable_iff_measurable",
    "statement": "theorem strongly_measurable_iff_measurable {α : Type u_1} {β : Type u_2} {f : α → β} {mα : measurable_space α} [measurable_space β] [topological_space β] [topological_space.metrizable_space β] [borel_space β] [topological_space.second_countable_topology β] : measure_theory.strongly_measurable f ↔ measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} {mα : measurable_space α} [measurable_space β] [topological_space β] [topological_space.metrizable_space β] [borel_space β] [topological_space.second_countable_topology β] : measure_theory.strongly_measurable f ↔ measurable f",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} {mα : measurable_space α} [measurable_space β] [topological_space β] [topological_space.metrizable_space β] [borel_space β] [topological_space.second_countable_topology β]",
    "doc_string": "In a space with second countable topology, strongly measurable and measurable are equivalent.",
    "kind": "theorem",
    "type": "measure_theory.strongly_measurable f ↔ measurable f"
  },
  {
    "name": "linear_ordered_semiring",
    "statement": "structure linear_ordered_semiring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A `linear_ordered_semiring α` is a nontrivial semiring `α` with a linear order such that addition is monotone and multiplication by a positive number is strictly monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "mul_lt_one_of_le_of_lt",
    "statement": "theorem mul_lt_one_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1)",
    "doc_string": "**Alias** of left.mul_lt_one_of_le_of_lt`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "succ_chain",
    "statement": "def succ_chain {α : Type u_1} (r : α → α → Prop) (s : set α) : set α",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s : set α) : set α",
    "args": "{α : Type u_1} (r : α → α → Prop) (s : set α)",
    "doc_string": " Given a set `s`, if there exists a chain `t` strictly including `s`, then `succ_chain s` is one of these chains. Otherwise it is `s`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "cau_seq.lim_zero",
    "statement": "def cau_seq.lim_zero {α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] {abv : β → α} (f : cau_seq β abv) : Prop",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] {abv : β → α} (f : cau_seq β abv) : Prop",
    "args": "{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] {abv : β → α} (f : cau_seq β abv)",
    "doc_string": "`lim_zero f` holds when `f` approaches 0.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_free_groupoid",
    "statement": "structure is_free_groupoid (G : Type u_1) [category_theory.groupoid G] : Type (max u_1 (v+1))",
    "theorem": "(G : Type u_1) [category_theory.groupoid G] : Type (max u_1 (v+1))",
    "args": "(G : Type u_1) [category_theory.groupoid G]",
    "doc_string": "A groupoid `G` is free when we have the following data: - a quiver on `is_free_groupoid.generators G` (a type synonym for `G`) - a function `of` taking a generating arrow to a morphism in `G` - such that a functor from `G` to any group `X` is uniquely determined   by assigning labels in `X` to the generating arrows.    This definition is nonstandard. Normally one would require that functors `G ⥤ X`   to any _groupoid_ `X` are given by graph homomorphisms from `generators`.",
    "kind": "structure",
    "type": "Type (max u_1 (v+1))"
  },
  {
    "name": "has_involutive_star",
    "statement": "structure has_involutive_star (R : Type u) : Type u",
    "theorem": "(R : Type u) : Type u",
    "args": "(R : Type u)",
    "doc_string": "Typeclass for a star operation with is involutive.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "opposite",
    "statement": "def opposite (α : Sort u) : Sort u",
    "theorem": "(α : Sort u) : Sort u",
    "args": "(α : Sort u)",
    "doc_string": "The type of objects of the opposite of `α`; used to define the opposite category.   In order to avoid confusion between `α` and its opposite type, we  set up the type of objects `opposite α` using the following pattern,  which will be repeated later for the morphisms.   1. Define `opposite α := α`.  2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.  3. Make the definition `opposite` irreducible.   This has the following consequences.   * `opposite α` and `α` are distinct types in the elaborator, so you    must use `op` and `unop` explicitly to convert between them.  * Both `unop (op X) = X` and `op (unop X) = X` are definitional    equalities. Notably, every object of the opposite category is    definitionally of the form `op X`, which greatly simplifies the    definition of the structure of the opposite category, for example.   (If Lean supported definitional eta equality for records, we could  achieve the same goals using a structure with one field.)",
    "kind": "def",
    "type": "Sort u"
  },
  {
    "name": "semi_normed_ring",
    "statement": "structure semi_normed_ring (α : Type u_5) : Type u_5",
    "theorem": "(α : Type u_5) : Type u_5",
    "args": "(α : Type u_5)",
    "doc_string": " A seminormed ring is a ring endowed with a seminorm which satisfies the inequality `∥x y∥ ≤ ∥x∥ ∥y∥`.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "dvd_add_right",
    "statement": "theorem dvd_add_right {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c",
    "theorem": "{α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c",
    "args": "{α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b)",
    "doc_string": "If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c.",
    "kind": "theorem",
    "type": "a ∣ b + c ↔ a ∣ c"
  },
  {
    "name": "category_theory.idempotents.karoubi.complement",
    "statement": "def category_theory.idempotents.karoubi.complement {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (P : category_theory.idempotents.karoubi C) : category_theory.idempotents.karoubi C",
    "theorem": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (P : category_theory.idempotents.karoubi C) : category_theory.idempotents.karoubi C",
    "args": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (P : category_theory.idempotents.karoubi C)",
    "doc_string": " `P.complement` is the formal direct factor of `P.X` given by the idempotent endomorphism `𝟙 P.X - P.p`",
    "kind": "def",
    "type": "category_theory.idempotents.karoubi C"
  },
  {
    "name": "category_theory.limits.bicone.of_limit_cone",
    "statement": "def category_theory.limits.bicone.of_limit_cone {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J → C} {t : category_theory.limits.cone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_limit t) : category_theory.limits.bicone f",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J → C} {t : category_theory.limits.cone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_limit t) : category_theory.limits.bicone f",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J → C} {t : category_theory.limits.cone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_limit t)",
    "doc_string": "We can turn any limit cone over a discrete collection of objects into a bicone.",
    "kind": "def",
    "type": "category_theory.limits.bicone f"
  },
  {
    "name": "Sup_convergence_class",
    "statement": "structure Sup_convergence_class (α : Type u_3) [preorder α] [topological_space α] : Prop",
    "theorem": "(α : Type u_3) [preorder α] [topological_space α] : Prop",
    "args": "(α : Type u_3) [preorder α] [topological_space α]",
    "doc_string": " We say that `α` is a `Sup_convergence_class` if the following holds. Let `f : ι → α` be a monotone function, let `a : α` be a least upper bound of `set.range f`. Then `f x` tends to `𝓝 a` as `x → ∞` (formally, at the filter `filter.at_top`). We require this for `ι = (s : set α)`, `f = coe` in the definition, then prove it for any `f` in `tendsto_at_top_is_lub`.  This property holds for linear orders with order topology as well as their products.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "computation.destruct",
    "statement": "def computation.destruct {α : Type u} (c : computation α) : α ⊕ computation α",
    "theorem": "{α : Type u} (c : computation α) : α ⊕ computation α",
    "args": "{α : Type u} (c : computation α)",
    "doc_string": "`destruct c` is the destructor for `computation α` as a coinductive type.  It returns `inl a` if `c = return a` and `inr c'` if `c = think c'`.",
    "kind": "def",
    "type": "α ⊕ computation α"
  },
  {
    "name": "stone_cech_unit",
    "statement": "def stone_cech_unit {α : Type u} [topological_space α] (x : α) : stone_cech α",
    "theorem": "{α : Type u} [topological_space α] (x : α) : stone_cech α",
    "args": "{α : Type u} [topological_space α] (x : α)",
    "doc_string": "The natural map from α to its Stone-Čech compactification.",
    "kind": "def",
    "type": "stone_cech α"
  },
  {
    "name": "omega.nat.preterm.sub_subst",
    "statement": "def omega.nat.preterm.sub_subst (t s : omega.nat.preterm) (k : ℕ) : omega.nat.preterm → omega.nat.preterm",
    "theorem": "(t s : omega.nat.preterm) (k : ℕ) : omega.nat.preterm → omega.nat.preterm",
    "args": "(t s : omega.nat.preterm) (k : ℕ)",
    "doc_string": "Find (t - s) inside a preterm and replace it with variable k",
    "kind": "def",
    "type": "omega.nat.preterm → omega.nat.preterm"
  },
  {
    "name": "Twop.to_Bipointed",
    "statement": "def Twop.to_Bipointed (X : Twop) : Bipointed",
    "theorem": "(X : Twop) : Bipointed",
    "args": "(X : Twop)",
    "doc_string": " Turns a two-pointed type into a bipointed type, by forgetting that the pointed elements are distinct.",
    "kind": "def",
    "type": "Bipointed"
  },
  {
    "name": "subring.multiset_sum_mem",
    "statement": "theorem subring.multiset_sum_mem {R : Type u_1} [ring R] (s : subring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s",
    "theorem": "{R : Type u_1} [ring R] (s : subring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s",
    "args": "{R : Type u_1} [ring R] (s : subring R) (m : multiset R)",
    "doc_string": " Sum of a multiset of elements in an `subring` of a `ring` is in the `subring`.",
    "kind": "theorem",
    "type": "(∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s"
  },
  {
    "name": "mul_action.stabilizer",
    "statement": "def mul_action.stabilizer (α : Type u) {β : Type v} [group α] [mul_action α β] (b : β) : subgroup α",
    "theorem": "(α : Type u) {β : Type v} [group α] [mul_action α β] (b : β) : subgroup α",
    "args": "(α : Type u) {β : Type v} [group α] [mul_action α β] (b : β)",
    "doc_string": " The stabilizer of an element under an action, i.e. what sends the element to itself. A subgroup.",
    "kind": "def",
    "type": "subgroup α"
  },
  {
    "name": "is_lie_abelian",
    "statement": "def is_lie_abelian (L : Type v) [has_bracket L L] [has_zero L] : Prop",
    "theorem": "(L : Type v) [has_bracket L L] [has_zero L] : Prop",
    "args": "(L : Type v) [has_bracket L L] [has_zero L]",
    "doc_string": "A Lie algebra is Abelian iff it is trivial as a Lie module over itself.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "polynomial.prim_part",
    "statement": "def polynomial.prim_part {R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : polynomial R",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : polynomial R",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R)",
    "doc_string": "The primitive part of a polynomial `p` is the primitive polynomial gained by dividing `p` by  `p.content`. If `p = 0`, then `p.prim_part = 1`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "ultrafilter.has_pure",
    "statement": "def ultrafilter.has_pure  : has_pure ultrafilter",
    "theorem": " : has_pure ultrafilter",
    "args": "",
    "doc_string": "The principal ultrafilter associated to a point `x`.",
    "kind": "def",
    "type": "has_pure ultrafilter"
  },
  {
    "name": "is_localization.unique",
    "statement": "def is_localization.unique (R : Type u_1) (Rₘ : Type u_2) [comm_semiring R] [comm_semiring Rₘ] (M : submonoid R) [subsingleton R] [algebra R Rₘ] [is_localization M Rₘ] : unique Rₘ",
    "theorem": "(R : Type u_1) (Rₘ : Type u_2) [comm_semiring R] [comm_semiring Rₘ] (M : submonoid R) [subsingleton R] [algebra R Rₘ] [is_localization M Rₘ] : unique Rₘ",
    "args": "(R : Type u_1) (Rₘ : Type u_2) [comm_semiring R] [comm_semiring Rₘ] (M : submonoid R) [subsingleton R] [algebra R Rₘ] [is_localization M Rₘ]",
    "doc_string": "The localization of a singleton is a singleton. Cannot be an instance due to metavariables.",
    "kind": "def",
    "type": "unique Rₘ"
  },
  {
    "name": "pos_num.div'",
    "statement": "def pos_num.div' (n d : pos_num) : num",
    "theorem": "(n d : pos_num) : num",
    "args": "(n d : pos_num)",
    "doc_string": "Division of `pos_num`,",
    "kind": "def",
    "type": "num"
  },
  {
    "name": "is_mul_hom.to_is_monoid_hom",
    "statement": "theorem is_mul_hom.to_is_monoid_hom {α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f)",
    "doc_string": "A map to a group preserving multiplication is a monoid homomorphism.",
    "kind": "theorem",
    "type": "is_monoid_hom f"
  },
  {
    "name": "has_lipschitz_mul",
    "statement": "structure has_lipschitz_mul (β : Type u_2) [pseudo_metric_space β] [monoid β] : Prop",
    "theorem": "(β : Type u_2) [pseudo_metric_space β] [monoid β] : Prop",
    "args": "(β : Type u_2) [pseudo_metric_space β] [monoid β]",
    "doc_string": " Class `has_lipschitz_mul M` says that the multiplication `(*) : X × X → X` is Lipschitz jointly in the two arguments.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "neg_add_lt_of_lt_add",
    "statement": "theorem neg_add_lt_of_lt_add {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → -b + a < c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → -b + a < c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of inv_mul_lt_iff_lt_mul`.",
    "kind": "theorem",
    "type": "a < b + c → -b + a < c"
  },
  {
    "name": "is_path_connected",
    "statement": "def is_path_connected {X : Type u_1} [topological_space X] (F : set X) : Prop",
    "theorem": "{X : Type u_1} [topological_space X] (F : set X) : Prop",
    "args": "{X : Type u_1} [topological_space X] (F : set X)",
    "doc_string": "A set `F` is path connected if it contains a point that can be joined to all other in `F`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pi_nat.has_dist",
    "statement": "def pi_nat.has_dist {E : ℕ → Type u_1} : has_dist (Π (n : ℕ), E n)",
    "theorem": "{E : ℕ → Type u_1} : has_dist (Π (n : ℕ), E n)",
    "args": "{E : ℕ → Type u_1}",
    "doc_string": " The distance function on a product space `Π n, E n`, given by `dist x y = (1/2)^n` where `n` is the first index at which `x` and `y` differ.",
    "kind": "def",
    "type": "has_dist (Π (n : ℕ), E n)"
  },
  {
    "name": "topological_space.dense_range_dense_seq",
    "statement": "theorem topological_space.dense_range_dense_seq (α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : dense_range (topological_space.dense_seq α)",
    "theorem": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : dense_range (topological_space.dense_seq α)",
    "args": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α]",
    "doc_string": "The sequence `dense_seq α` has dense range.",
    "kind": "theorem",
    "type": "dense_range (topological_space.dense_seq α)"
  },
  {
    "name": "metric.lipschitz_inf_nndist_pt",
    "statement": "theorem metric.lipschitz_inf_nndist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_nndist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_nndist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set (as `ℝ≥0`) is Lipschitz in point with constant 1",
    "kind": "theorem",
    "type": "lipschitz_with 1 (λ (x : α), metric.inf_nndist x s)"
  },
  {
    "name": "bisequence",
    "statement": "def bisequence {t : Type u_1 → Type u_1 → Type u_1} {m : Type u_1 → Type u_1} [bitraversable t] [applicative m] {α β : Type u_1} : t (m α) (m β) → m (t α β)",
    "theorem": "{t : Type u_1 → Type u_1 → Type u_1} {m : Type u_1 → Type u_1} [bitraversable t] [applicative m] {α β : Type u_1} : t (m α) (m β) → m (t α β)",
    "args": "{t : Type u_1 → Type u_1 → Type u_1} {m : Type u_1 → Type u_1} [bitraversable t] [applicative m] {α β : Type u_1}",
    "doc_string": "A bitraversable functor commutes with all applicative functors.",
    "kind": "def",
    "type": "t (m α) (m β) → m (t α β)"
  },
  {
    "name": "sym.repeat",
    "statement": "def sym.repeat {α : Type u_1} (a : α) (n : ℕ) : sym α n",
    "theorem": "{α : Type u_1} (a : α) (n : ℕ) : sym α n",
    "args": "{α : Type u_1} (a : α) (n : ℕ)",
    "doc_string": "`repeat a n` is the sym containing only `a` with multiplicity `n`.",
    "kind": "def",
    "type": "sym α n"
  },
  {
    "name": "multiset.nodup",
    "statement": "def multiset.nodup {α : Type u_1} (s : multiset α) : Prop",
    "theorem": "{α : Type u_1} (s : multiset α) : Prop",
    "args": "{α : Type u_1} (s : multiset α)",
    "doc_string": "`nodup s` means that `s` has no duplicates, i.e. the multiplicity of  any element is at most 1.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.surjective.has_involutive_inv",
    "statement": "def function.surjective.has_involutive_inv {M₁ : Type u_1} {M₂ : Type u_2} [has_inv M₂] [has_involutive_inv M₁] (f : M₁ → M₂) (hf : function.surjective f) (inv : ∀ (x : M₁), f x⁻¹ = (f x)⁻¹) : has_involutive_inv M₂",
    "theorem": "{M₁ : Type u_1} {M₂ : Type u_2} [has_inv M₂] [has_involutive_inv M₁] (f : M₁ → M₂) (hf : function.surjective f) (inv : ∀ (x : M₁), f x⁻¹ = (f x)⁻¹) : has_involutive_inv M₂",
    "args": "{M₁ : Type u_1} {M₂ : Type u_2} [has_inv M₂] [has_involutive_inv M₁] (f : M₁ → M₂) (hf : function.surjective f) (inv : ∀ (x : M₁), f x⁻¹ = (f x)⁻¹)",
    "doc_string": " A type has an involutive inversion if it admits a surjective map that preserves `⁻¹` to a type which has an involutive inversion.",
    "kind": "def",
    "type": "has_involutive_inv M₂"
  },
  {
    "name": "subgroup.set_normalizer",
    "statement": "def subgroup.set_normalizer {G : Type u_1} [group G] (S : set G) : subgroup G",
    "theorem": "{G : Type u_1} [group G] (S : set G) : subgroup G",
    "args": "{G : Type u_1} [group G] (S : set G)",
    "doc_string": "The `set_normalizer` of `S` is the subgroup of `G` whose elements satisfy `g*S*g⁻¹=S`",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "heq",
    "statement": "inductive heq {α : Sort u} (a : α) {β : Sort u} : β → Prop",
    "theorem": "{α : Sort u} (a : α) {β : Sort u} : β → Prop",
    "args": "{α : Sort u} (a : α) {β : Sort u}",
    "doc_string": "Heterogeneous equality.  Its purpose is to write down equalities between terms whose types are not definitionally equal. For example, given `x : vector α n` and `y : vector α (0+n)`, `x = y` doesn't typecheck but `x == y` does.  If you have a goal `⊢ x == y`, your first instinct should be to ask (either yourself, or on [zulip](https://leanprover.zulipchat.com/)) if something has gone wrong already. If you really do need to follow this route, you may find the lemmas `eq_rec_heq` and `eq_mpr_heq` useful.",
    "kind": "inductive",
    "type": "β → Prop"
  },
  {
    "name": "char_zero_of_exp_char_one'",
    "statement": "def char_zero_of_exp_char_one' (R : Type u) [semiring R] [nontrivial R] [hq : exp_char R 1] : char_zero R",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] [hq : exp_char R 1] : char_zero R",
    "args": "(R : Type u) [semiring R] [nontrivial R] [hq : exp_char R 1]",
    "doc_string": "The characteristic is zero if the exponential characteristic is one.",
    "kind": "def",
    "type": "char_zero R"
  },
  {
    "name": "encodable.decode_sum",
    "statement": "def encodable.decode_sum {α : Type u_1} {β : Type u_2} [encodable α] [encodable β] (n : ℕ) : option (α ⊕ β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [encodable α] [encodable β] (n : ℕ) : option (α ⊕ β)",
    "args": "{α : Type u_1} {β : Type u_2} [encodable α] [encodable β] (n : ℕ)",
    "doc_string": "Explicit decoding function for the sum of two encodable types.",
    "kind": "def",
    "type": "option (α ⊕ β)"
  },
  {
    "name": "binder",
    "statement": "structure binder  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of binders containing a name, the binding info and the binding type",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "tactic.ring.horner",
    "statement": "def tactic.ring.horner {α : Type u_1} [comm_semiring α] (a x : α) (n : ℕ) (b : α) : α",
    "theorem": "{α : Type u_1} [comm_semiring α] (a x : α) (n : ℕ) (b : α) : α",
    "args": "{α : Type u_1} [comm_semiring α] (a x : α) (n : ℕ) (b : α)",
    "doc_string": " The normal form that `ring` uses is mediated by the function `horner a x n b := a * x ^ n + b`. The reason we use a definition rather than the (more readable) expression on the right is because this expression contains a number of typeclass arguments in different positions, while `horner` contains only one `comm_semiring` instance at the top level. See also `horner_expr` for a description of normal form.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "BoundedDistribLattice.of",
    "statement": "def BoundedDistribLattice.of (α : Type u_1) [distrib_lattice α] [bounded_order α] : BoundedDistribLattice",
    "theorem": "(α : Type u_1) [distrib_lattice α] [bounded_order α] : BoundedDistribLattice",
    "args": "(α : Type u_1) [distrib_lattice α] [bounded_order α]",
    "doc_string": "Construct a bundled `BoundedDistribLattice` from a `bounded_order` `distrib_lattice`.",
    "kind": "def",
    "type": "BoundedDistribLattice"
  },
  {
    "name": "padic_val_int",
    "statement": "def padic_val_int (p : ℕ) (z : ℤ) : ℕ",
    "theorem": "(p : ℕ) (z : ℤ) : ℕ",
    "args": "(p : ℕ) (z : ℤ)",
    "doc_string": "For `p ≠ 1`, the p-adic valuation of an integer `z ≠ 0` is the largest natural number `k` such that p^k divides z. If `x = 0` or `p = 1`, then `padic_val_int p q` defaults to 0.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "dimH",
    "statement": "def dimH {X : Type u_2} [emetric_space X] (s : set X) : ennreal",
    "theorem": "{X : Type u_2} [emetric_space X] (s : set X) : ennreal",
    "args": "{X : Type u_2} [emetric_space X] (s : set X)",
    "doc_string": "Hausdorff dimension of a set in an (e)metric space.",
    "kind": "def",
    "type": "ennreal"
  },
  {
    "name": "id_delta",
    "statement": "def id_delta {α : Sort u} (a : α) : α",
    "theorem": "{α : Sort u} (a : α) : α",
    "args": "{α : Sort u} (a : α)",
    "doc_string": "The kernel definitional equality test (t =?= s) has special support for id_delta applications. It implements the following rules     1)   (id_delta t) =?= t    2)   t =?= (id_delta t)    3)   (id_delta t) =?= s  IF (unfold_of t) =?= s    4)   t =?= id_delta s    IF t =?= (unfold_of s)  This is mechanism for controlling the delta reduction (aka unfolding) used in the kernel.  We use id_delta applications to address performance problems when type checking lemmas generated by the equation compiler.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "BoolRing.of",
    "statement": "def BoolRing.of (α : Type u_1) [boolean_ring α] : BoolRing",
    "theorem": "(α : Type u_1) [boolean_ring α] : BoolRing",
    "args": "(α : Type u_1) [boolean_ring α]",
    "doc_string": "Construct a bundled `BoolRing` from a `boolean_ring`.",
    "kind": "def",
    "type": "BoolRing"
  },
  {
    "name": "topological_fiber_bundle_core.triv_change",
    "statement": "def topological_fiber_bundle_core.triv_change {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (i j : ι) : local_homeomorph (B × F) (B × F)",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (i j : ι) : local_homeomorph (B × F) (B × F)",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (i j : ι)",
    "doc_string": "Local homeomorphism version of the trivialization change.",
    "kind": "def",
    "type": "local_homeomorph (B × F) (B × F)"
  },
  {
    "name": "list.length_pos_of_prod_ne_one",
    "statement": "theorem list.length_pos_of_prod_ne_one {M : Type u_3} [monoid M] (L : list M) (h : L.prod ≠ 1) : 0 < L.length",
    "theorem": "{M : Type u_3} [monoid M] (L : list M) (h : L.prod ≠ 1) : 0 < L.length",
    "args": "{M : Type u_3} [monoid M] (L : list M) (h : L.prod ≠ 1)",
    "doc_string": "A list with product not one must have positive length.",
    "kind": "theorem",
    "type": "0 < L.length"
  },
  {
    "name": "pell.yn",
    "statement": "def pell.yn {a : ℕ} (a1 : 1 < a) (n : ℕ) : ℕ",
    "theorem": "{a : ℕ} (a1 : 1 < a) (n : ℕ) : ℕ",
    "args": "{a : ℕ} (a1 : 1 < a) (n : ℕ)",
    "doc_string": "The Pell `y` sequence.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "finset.ne_of_mem_slice",
    "statement": "theorem finset.ne_of_mem_slice {α : Type u_1} {𝒜 : finset (finset α)} {A₁ A₂ : finset α} {r₁ r₂ : ℕ} (h₁ : A₁ ∈ 𝒜.slice r₁) (h₂ : A₂ ∈ 𝒜.slice r₂) : r₁ ≠ r₂ → A₁ ≠ A₂",
    "theorem": "{α : Type u_1} {𝒜 : finset (finset α)} {A₁ A₂ : finset α} {r₁ r₂ : ℕ} (h₁ : A₁ ∈ 𝒜.slice r₁) (h₂ : A₂ ∈ 𝒜.slice r₂) : r₁ ≠ r₂ → A₁ ≠ A₂",
    "args": "{α : Type u_1} {𝒜 : finset (finset α)} {A₁ A₂ : finset α} {r₁ r₂ : ℕ} (h₁ : A₁ ∈ 𝒜.slice r₁) (h₂ : A₂ ∈ 𝒜.slice r₂)",
    "doc_string": "Elements in distinct slices must be distinct.",
    "kind": "theorem",
    "type": "r₁ ≠ r₂ → A₁ ≠ A₂"
  },
  {
    "name": "power_series.inv",
    "statement": "def power_series.inv {k : Type u_2} [field k] : power_series k → power_series k",
    "theorem": "{k : Type u_2} [field k] : power_series k → power_series k",
    "args": "{k : Type u_2} [field k]",
    "doc_string": "The inverse 1/f of a power series f defined over a field",
    "kind": "def",
    "type": "power_series k → power_series k"
  },
  {
    "name": "intermediate_field.fg",
    "statement": "def intermediate_field.fg {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (S : intermediate_field F E) : Prop",
    "theorem": "{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (S : intermediate_field F E) : Prop",
    "args": "{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] (S : intermediate_field F E)",
    "doc_string": " An intermediate field `S` is finitely generated if there exists `t : finset E` such that `intermediate_field.adjoin F t = S`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "generalized_continued_fraction.squash_gcf",
    "statement": "def generalized_continued_fraction.squash_gcf {K : Type u_1} [division_ring K] (g : generalized_continued_fraction K) : ℕ → generalized_continued_fraction K",
    "theorem": "{K : Type u_1} [division_ring K] (g : generalized_continued_fraction K) : ℕ → generalized_continued_fraction K",
    "args": "{K : Type u_1} [division_ring K] (g : generalized_continued_fraction K)",
    "doc_string": "Given a gcf `g = [h; (a₀, bₒ), (a₁, b₁), ...]`, we have - `squash_nth.gcf g 0 = [h + a₀ / b₀); (a₀, bₒ), ...]`, - `squash_nth.gcf g (n + 1) = ⟨g.h, squash_seq g.s n⟩`",
    "kind": "def",
    "type": "ℕ → generalized_continued_fraction K"
  },
  {
    "name": "witt_vector.frobenius_poly",
    "statement": "def witt_vector.frobenius_poly (p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : mv_polynomial ℕ ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : mv_polynomial ℕ ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ)",
    "doc_string": " The polynomials that give the coefficients of `frobenius x`, in terms of the coefficients of `x`.",
    "kind": "def",
    "type": "mv_polynomial ℕ ℤ"
  },
  {
    "name": "fixing_add_submonoid",
    "statement": "def fixing_add_submonoid (M : Type u_1) {α : Type u_2} [add_monoid M] [add_action M α] (s : set α) : add_submonoid M",
    "theorem": "(M : Type u_1) {α : Type u_2} [add_monoid M] [add_action M α] (s : set α) : add_submonoid M",
    "args": "(M : Type u_1) {α : Type u_2} [add_monoid M] [add_action M α] (s : set α)",
    "doc_string": "The additive submonoid fixing a set under an `add_action`.",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "localization.add",
    "statement": "def localization.add {R : Type u_1} [comm_semiring R] {M : submonoid R} (z w : localization M) : localization M",
    "theorem": "{R : Type u_1} [comm_semiring R] {M : submonoid R} (z w : localization M) : localization M",
    "args": "{R : Type u_1} [comm_semiring R] {M : submonoid R} (z w : localization M)",
    "doc_string": " Addition in a ring localization is defined as `⟨a, b⟩ + ⟨c, d⟩ = ⟨b * c + d * a, b * d⟩`.  Should not be confused with `add_localization.add`, which is defined as `⟨a, b⟩ + ⟨c, d⟩ = ⟨a + c, b + d⟩`.",
    "kind": "def",
    "type": "localization M"
  },
  {
    "name": "compact_t2_tot_disc_iff_tot_sep",
    "statement": "theorem compact_t2_tot_disc_iff_tot_sep {α : Type u} [topological_space α] [t2_space α] [compact_space α] : totally_disconnected_space α ↔ totally_separated_space α",
    "theorem": "{α : Type u} [topological_space α] [t2_space α] [compact_space α] : totally_disconnected_space α ↔ totally_separated_space α",
    "args": "{α : Type u} [topological_space α] [t2_space α] [compact_space α]",
    "doc_string": "A compact Hausdorff space is totally disconnected if and only if it is totally separated, this  is also true for locally compact spaces.",
    "kind": "theorem",
    "type": "totally_disconnected_space α ↔ totally_separated_space α"
  },
  {
    "name": "measure_theory.strongly_measurable.approx",
    "statement": "def measure_theory.strongly_measurable.approx {α : Type u_1} {β : Type u_2} {f : α → β} [topological_space β] {m : measurable_space α} (hf : measure_theory.strongly_measurable f) : ℕ → measure_theory.simple_func α β",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} [topological_space β] {m : measurable_space α} (hf : measure_theory.strongly_measurable f) : ℕ → measure_theory.simple_func α β",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} [topological_space β] {m : measurable_space α} (hf : measure_theory.strongly_measurable f)",
    "doc_string": " A sequence of simple functions such that `∀ x, tendsto (λ n, hf.approx n x) at_top (𝓝 (f x))`. That property is given by `strongly_measurable.tendsto_approx`.",
    "kind": "def",
    "type": "ℕ → measure_theory.simple_func α β"
  },
  {
    "name": "rack.envel_group",
    "statement": "def rack.envel_group (R : Type u_1) [rack R] : Type u_1",
    "theorem": "(R : Type u_1) [rack R] : Type u_1",
    "args": "(R : Type u_1) [rack R]",
    "doc_string": "The universal enveloping group for the rack R.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "tactic.norm_fin.normalize_fin_lt",
    "statement": "def tactic.norm_fin.normalize_fin_lt (n : ℕ) (a : fin n) (b : ℕ) : Prop",
    "theorem": "(n : ℕ) (a : fin n) (b : ℕ) : Prop",
    "args": "(n : ℕ) (a : fin n) (b : ℕ)",
    "doc_string": " `normalize_fin_lt n a b` means that `a : fin n` is equivalent to `b : ℕ` in the embedding sense - that is, `↑a = b`. This is used for operations that treat `fin n` as the subset `{0, ..., n-1}` of `ℕ`. For example, `fin.succ : fin n → fin (n+1)` is thought of as the successor function, but it does not lift to a map `zmod n → zmod (n+1)`; this addition only makes sense if the input is strictly less than `n`.  `normalize_fin_lt n a b` is equivalent to `normalize_fin n a b ∧ b < n`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bounded_order_hom.to_bot_hom",
    "statement": "def bounded_order_hom.to_bot_hom {α : Type u_2} {β : Type u_3} [preorder α] [preorder β] [bounded_order α] [bounded_order β] (f : bounded_order_hom α β) : bot_hom α β",
    "theorem": "{α : Type u_2} {β : Type u_3} [preorder α] [preorder β] [bounded_order α] [bounded_order β] (f : bounded_order_hom α β) : bot_hom α β",
    "args": "{α : Type u_2} {β : Type u_3} [preorder α] [preorder β] [bounded_order α] [bounded_order β] (f : bounded_order_hom α β)",
    "doc_string": "Reinterpret a `bounded_order_hom` as a `bot_hom`.",
    "kind": "def",
    "type": "bot_hom α β"
  },
  {
    "name": "nnreal.summable_of_le",
    "statement": "theorem nnreal.summable_of_le {β : Type u_2} {f g : β → nnreal} (hgf : ∀ (b : β), g b ≤ f b) : summable f → summable g",
    "theorem": "{β : Type u_2} {f g : β → nnreal} (hgf : ∀ (b : β), g b ≤ f b) : summable f → summable g",
    "args": "{β : Type u_2} {f g : β → nnreal} (hgf : ∀ (b : β), g b ≤ f b)",
    "doc_string": "Comparison test of convergence of `ℝ≥0`-valued series.",
    "kind": "theorem",
    "type": "summable f → summable g"
  },
  {
    "name": "bounded_lattice_hom_class",
    "statement": "structure bounded_lattice_hom_class (F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [lattice α] [lattice β] [bounded_order α] [bounded_order β] : Type (max u_7 u_8 u_9)",
    "theorem": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [lattice α] [lattice β] [bounded_order α] [bounded_order β] : Type (max u_7 u_8 u_9)",
    "args": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [lattice α] [lattice β] [bounded_order α] [bounded_order β]",
    "doc_string": " `bounded_lattice_hom_class F α β` states that `F` is a type of bounded lattice morphisms.  You should extend this class when you extend `bounded_lattice_hom`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8 u_9)"
  },
  {
    "name": "finpartition.has_le",
    "statement": "def finpartition.has_le {α : Type u_1} [lattice α] [order_bot α] {a : α} : has_le (finpartition a)",
    "theorem": "{α : Type u_1} [lattice α] [order_bot α] {a : α} : has_le (finpartition a)",
    "args": "{α : Type u_1} [lattice α] [order_bot α] {a : α}",
    "doc_string": "We say that `P ≤ Q` if `P` refines `Q`: each part of `P` is less than some part of `Q`.",
    "kind": "def",
    "type": "has_le (finpartition a)"
  },
  {
    "name": "function.injective.inj_on",
    "statement": "theorem function.injective.inj_on {α : Type u} {β : Type v} {f : α → β} (h : function.injective f) (s : set α) : set.inj_on f s",
    "theorem": "{α : Type u} {β : Type v} {f : α → β} (h : function.injective f) (s : set α) : set.inj_on f s",
    "args": "{α : Type u} {β : Type v} {f : α → β} (h : function.injective f) (s : set α)",
    "doc_string": "**Alias** of set.inj_on_of_injective`.",
    "kind": "theorem",
    "type": "set.inj_on f s"
  },
  {
    "name": "wseq.index_of",
    "statement": "def wseq.index_of {α : Type u} [decidable_eq α] (a : α) : wseq α → computation ℕ",
    "theorem": "{α : Type u} [decidable_eq α] (a : α) : wseq α → computation ℕ",
    "args": "{α : Type u} [decidable_eq α] (a : α)",
    "doc_string": "Get the index of the first occurrence of `a` in `s`",
    "kind": "def",
    "type": "wseq α → computation ℕ"
  },
  {
    "name": "algebraic_geometry.SheafedSpace.glue_data",
    "statement": "structure algebraic_geometry.SheafedSpace.glue_data (C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : Type (max u (v+1))",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : Type (max u (v+1))",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C]",
    "doc_string": "A family of gluing data consists of 1. An index type `J` 2. A sheafed space `U i` for each `i : J`. 3. A sheafed space `V i j` for each `i j : J`.   (Note that this is `J × J → SheafedSpace C` rather than `J → J → SheafedSpace C` to   connect to the limits library easier.) 4. An open immersion `f i j : V i j ⟶ U i` for each `i j : ι`. 5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`. such that 6. `f i i` is an isomorphism. 7. `t i i` is the identity. 8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some     `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`. 9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.  We can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such that the `U i`'s are open subspaces of the glued space.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "matrix.det_transpose",
    "statement": "theorem matrix.det_transpose {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det",
    "theorem": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det",
    "args": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R)",
    "doc_string": "Transposing a matrix preserves the determinant.",
    "kind": "theorem",
    "type": "M.transpose.det = M.det"
  },
  {
    "name": "truncated_witt_vector.out",
    "statement": "def truncated_witt_vector.out {p n : ℕ} {R : Type u_1} [comm_ring R] (x : truncated_witt_vector p n R) : witt_vector p R",
    "theorem": "{p n : ℕ} {R : Type u_1} [comm_ring R] (x : truncated_witt_vector p n R) : witt_vector p R",
    "args": "{p n : ℕ} {R : Type u_1} [comm_ring R] (x : truncated_witt_vector p n R)",
    "doc_string": "We can turn a truncated Witt vector `x` into a Witt vector by setting all coefficients after `x` to be 0.",
    "kind": "def",
    "type": "witt_vector p R"
  },
  {
    "name": "free_add_semigroup",
    "statement": "def free_add_semigroup (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Free additive semigroup over a given alphabet.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "nat.arithmetic_function.is_multiplicative",
    "statement": "def nat.arithmetic_function.is_multiplicative {R : Type u_1} [monoid_with_zero R] (f : nat.arithmetic_function R) : Prop",
    "theorem": "{R : Type u_1} [monoid_with_zero R] (f : nat.arithmetic_function R) : Prop",
    "args": "{R : Type u_1} [monoid_with_zero R] (f : nat.arithmetic_function R)",
    "doc_string": "Multiplicative functions",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "monoid.is_torsion_free",
    "statement": "def monoid.is_torsion_free (G : Type u_1) [monoid G] : Prop",
    "theorem": "(G : Type u_1) [monoid G] : Prop",
    "args": "(G : Type u_1) [monoid G]",
    "doc_string": "A predicate on a monoid saying that only 1 is of finite order.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_group_topology.coinduced",
    "statement": "def add_group_topology.coinduced {α : Type u_1} {β : Type u_2} [t : topological_space α] [add_group β] (f : α → β) : add_group_topology β",
    "theorem": "{α : Type u_1} {β : Type u_2} [t : topological_space α] [add_group β] (f : α → β) : add_group_topology β",
    "args": "{α : Type u_1} {β : Type u_2} [t : topological_space α] [add_group β] (f : α → β)",
    "doc_string": "Given `f : α → β` and a topology on `α`, the coinduced additive group topology on `β` is the finest topology such that `f` is continuous and `β` is a topological additive group.",
    "kind": "def",
    "type": "add_group_topology β"
  },
  {
    "name": "inv_lt_inv",
    "statement": "theorem inv_lt_inv {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption.",
    "kind": "theorem",
    "type": "a⁻¹ < b⁻¹ ↔ b < a"
  },
  {
    "name": "submodule.torsion",
    "statement": "def submodule.torsion (R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : submodule R M",
    "theorem": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : submodule R M",
    "args": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "The torsion submodule, containing all elements `x` of `M` such that  `a • x = 0` for some  non-zero-divisor `a` in `R`.",
    "kind": "def",
    "type": "submodule R M"
  },
  {
    "name": "setoid.eqv_gen_mono",
    "statement": "theorem setoid.eqv_gen_mono {α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y) : eqv_gen.setoid r ≤ eqv_gen.setoid s",
    "theorem": "{α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y) : eqv_gen.setoid r ≤ eqv_gen.setoid s",
    "args": "{α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y)",
    "doc_string": "Equivalence closure of binary relations is monotone.",
    "kind": "theorem",
    "type": "eqv_gen.setoid r ≤ eqv_gen.setoid s"
  },
  {
    "name": "AddGroup.has_limits_of_size",
    "statement": "def AddGroup.has_limits_of_size  : category_theory.limits.has_limits_of_size AddGroup",
    "theorem": " : category_theory.limits.has_limits_of_size AddGroup",
    "args": "",
    "doc_string": "The category of additive groups has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size AddGroup"
  },
  {
    "name": "right.mul_lt_one_of_lt_of_le",
    "statement": "theorem right.mul_lt_one_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one_of_lt_of_le`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "category_theory.strong_mono_category",
    "statement": "structure category_theory.strong_mono_category (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A strong mono category is a category in which every monomorphism is strong.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "con.prod",
    "statement": "def con.prod {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (d : con N) : con (M × N)",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (d : con N) : con (M × N)",
    "args": "{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (d : con N)",
    "doc_string": "Given types with multiplications `M, N`, the product of two congruence relations `c` on `M` and    `d` on `N`: `(x₁, x₂), (y₁, y₂) ∈ M × N` are related by `c.prod d` iff `x₁` is related to `y₁`    by `c` and `x₂` is related to `y₂` by `d`.",
    "kind": "def",
    "type": "con (M × N)"
  },
  {
    "name": "tactic.rewrite_search.how",
    "statement": "structure tactic.rewrite_search.how  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A `how` contains information needed by the explainer to generate code for a rewrite. `rule_index` denotes which rule in the static list of rules is used. `location` describes which match of that rule was used, to work with `nth_rewrite`. `addr` is a list of \"left\" and \"right\" describing which subexpression is rewritten.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "free_semigroup.of",
    "statement": "def free_semigroup.of {α : Type u} (x : α) : free_semigroup α",
    "theorem": "{α : Type u} (x : α) : free_semigroup α",
    "args": "{α : Type u} (x : α)",
    "doc_string": "The embedding `α → free_semigroup α`.",
    "kind": "def",
    "type": "free_semigroup α"
  },
  {
    "name": "nat.mul_div_mul_left",
    "statement": "theorem nat.mul_div_mul_left (a b : ℕ) {c : ℕ} (hc : 0 < c) : c * a / (c * b) = a / b",
    "theorem": "(a b : ℕ) {c : ℕ} (hc : 0 < c) : c * a / (c * b) = a / b",
    "args": "(a b : ℕ) {c : ℕ} (hc : 0 < c)",
    "doc_string": "Alias of `nat.mul_div_mul`",
    "kind": "theorem",
    "type": "c * a / (c * b) = a / b"
  },
  {
    "name": "ordset.map",
    "statement": "def ordset.map {α : Type u_1} [preorder α] {β : Type u_2} [preorder β] (f : α → β) (f_strict_mono : strict_mono f) (s : ordset α) : ordset β",
    "theorem": "{α : Type u_1} [preorder α] {β : Type u_2} [preorder β] (f : α → β) (f_strict_mono : strict_mono f) (s : ordset α) : ordset β",
    "args": "{α : Type u_1} [preorder α] {β : Type u_2} [preorder β] (f : α → β) (f_strict_mono : strict_mono f) (s : ordset α)",
    "doc_string": "O(n). Map a function across a tree, without changing the structure.",
    "kind": "def",
    "type": "ordset β"
  },
  {
    "name": "ordnode.nth",
    "statement": "def ordnode.nth {α : Type u} : ordnode α → ℕ → option α",
    "theorem": "{α : Type u} : ordnode α → ℕ → option α",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Get the `i`th element of the set, by its index from left to right.      nth {a, b, c, d} 2 = some c     nth {a, b, c, d} 5 = none",
    "kind": "def",
    "type": "ordnode α → ℕ → option α"
  },
  {
    "name": "re_pred",
    "statement": "def re_pred {α : Type u_1} [primcodable α] (p : α → Prop) : Prop",
    "theorem": "{α : Type u_1} [primcodable α] (p : α → Prop) : Prop",
    "args": "{α : Type u_1} [primcodable α] (p : α → Prop)",
    "doc_string": "A recursively enumerable predicate is one which is the domain of a computable partial function.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subtype.emetric_space",
    "statement": "def subtype.emetric_space {α : Type u_1} {p : α → Prop} [emetric_space α] : emetric_space (subtype p)",
    "theorem": "{α : Type u_1} {p : α → Prop} [emetric_space α] : emetric_space (subtype p)",
    "args": "{α : Type u_1} {p : α → Prop} [emetric_space α]",
    "doc_string": "Emetric space instance on subsets of emetric spaces",
    "kind": "def",
    "type": "emetric_space (subtype p)"
  },
  {
    "name": "pos_num.lxor",
    "statement": "def pos_num.lxor  : pos_num → pos_num → num",
    "theorem": " : pos_num → pos_num → num",
    "args": "",
    "doc_string": "Bitwise \"xor\" for `pos_num`.",
    "kind": "def",
    "type": "pos_num → pos_num → num"
  },
  {
    "name": "add_subsemigroup.simps.coe",
    "statement": "def add_subsemigroup.simps.coe {M : Type u_1} [has_add M] (S : add_subsemigroup M) : set M",
    "theorem": "{M : Type u_1} [has_add M] (S : add_subsemigroup M) : set M",
    "args": "{M : Type u_1} [has_add M] (S : add_subsemigroup M)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "add_valuation.to_preorder",
    "statement": "def add_valuation.to_preorder {R : Type u_2} {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [ring R] (v : add_valuation R Γ₀) : preorder R",
    "theorem": "{R : Type u_2} {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [ring R] (v : add_valuation R Γ₀) : preorder R",
    "args": "{R : Type u_2} {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [ring R] (v : add_valuation R Γ₀)",
    "doc_string": "A valuation gives a preorder on the underlying ring.",
    "kind": "def",
    "type": "preorder R"
  },
  {
    "name": "lists'.to_list",
    "statement": "def lists'.to_list {α : Type u_1} {b : bool} : lists' α b → list (lists α)",
    "theorem": "{α : Type u_1} {b : bool} : lists' α b → list (lists α)",
    "args": "{α : Type u_1} {b : bool}",
    "doc_string": "Converts a ZFA prelist to a `list` of ZFA lists. Atoms are sent to `[]`.",
    "kind": "def",
    "type": "lists' α b → list (lists α)"
  },
  {
    "name": "pos_num.test_bit",
    "statement": "def pos_num.test_bit  : pos_num → ℕ → bool",
    "theorem": " : pos_num → ℕ → bool",
    "args": "",
    "doc_string": "`a.test_bit n` is `tt` iff the `n`-th bit (starting from the LSB) in the binary representation      of `a` is active. If the size of `a` is less than `n`, this evaluates to `ff`.",
    "kind": "def",
    "type": "pos_num → ℕ → bool"
  },
  {
    "name": "pell.yz",
    "statement": "def pell.yz {a : ℕ} (a1 : 1 < a) (n : ℕ) : ℤ",
    "theorem": "{a : ℕ} (a1 : 1 < a) (n : ℕ) : ℤ",
    "args": "{a : ℕ} (a1 : 1 < a) (n : ℕ)",
    "doc_string": "The Pell `y` sequence, considered as an integer sequence.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "int.gcd_b",
    "statement": "def int.gcd_b  : ℤ → ℤ → ℤ",
    "theorem": " : ℤ → ℤ → ℤ",
    "args": "",
    "doc_string": "The extended GCD `b` value in the equation `gcd x y = x * a + y * b`.",
    "kind": "def",
    "type": "ℤ → ℤ → ℤ"
  },
  {
    "name": "fintype.to_locally_finite_order",
    "statement": "def fintype.to_locally_finite_order {α : Type u_1} [preorder α] [fintype α] : locally_finite_order α",
    "theorem": "{α : Type u_1} [preorder α] [fintype α] : locally_finite_order α",
    "args": "{α : Type u_1} [preorder α] [fintype α]",
    "doc_string": "A fintype is noncomputably a locally finite order.",
    "kind": "def",
    "type": "locally_finite_order α"
  },
  {
    "name": "is_topological_fiber_bundle_fst",
    "statement": "theorem is_topological_fiber_bundle_fst {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The first projection in a product is a topological fiber bundle.",
    "kind": "theorem",
    "type": "is_topological_fiber_bundle F prod.fst"
  },
  {
    "name": "set.countable",
    "statement": "def set.countable {α : Type u} (s : set α) : Prop",
    "theorem": "{α : Type u} (s : set α) : Prop",
    "args": "{α : Type u} (s : set α)",
    "doc_string": " A set is countable if there exists an encoding of the set into the natural numbers. An encoding is an injection with a partial inverse, which can be viewed as a constructive analogue of countability. (For the most part, theorems about `countable` will be classical and `encodable` will be constructive.)",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.of_list'",
    "statement": "def ordnode.of_list' {α : Type u} [has_le α] [decidable_rel has_le.le] : list α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] : list α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le]",
    "doc_string": "O(n * log n). Adaptively chooses between the linear and log-linear algorithm depending  on whether the input list is already sorted.     of_list' [1, 2, 3] = {1, 2, 3}    of_list' [2, 1, 1, 3] = {1, 2, 3}",
    "kind": "def",
    "type": "list α → ordnode α"
  },
  {
    "name": "bounded_lattice_hom.to_bounded_order_hom",
    "statement": "def bounded_lattice_hom.to_bounded_order_hom {α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β) : bounded_order_hom α β",
    "theorem": "{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β) : bounded_order_hom α β",
    "args": "{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β)",
    "doc_string": "Reinterpret a `bounded_lattice_hom` as a `bounded_order_hom`.",
    "kind": "def",
    "type": "bounded_order_hom α β"
  },
  {
    "name": "category_theory.grothendieck_topology.dense",
    "statement": "def category_theory.grothendieck_topology.dense {C : Type u} [category_theory.category C] : category_theory.grothendieck_topology C",
    "theorem": "{C : Type u} [category_theory.category C] : category_theory.grothendieck_topology C",
    "args": "{C : Type u} [category_theory.category C]",
    "doc_string": "The dense Grothendieck topology.  See https://ncatlab.org/nlab/show/dense+topology, or [MM92] Chapter III, Section 2, example (e).",
    "kind": "def",
    "type": "category_theory.grothendieck_topology C"
  },
  {
    "name": "stream.tail",
    "statement": "def stream.tail {α : Type u} (s : stream α) : stream α",
    "theorem": "{α : Type u} (s : stream α) : stream α",
    "args": "{α : Type u} (s : stream α)",
    "doc_string": "Tail of a stream: `stream.tail (h :: t) = t`.",
    "kind": "def",
    "type": "stream α"
  },
  {
    "name": "finset.image₂",
    "statement": "def finset.image₂ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [decidable_eq γ] (f : α → β → γ) (s : finset α) (t : finset β) : finset γ",
    "theorem": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} [decidable_eq γ] (f : α → β → γ) (s : finset α) (t : finset β) : finset γ",
    "args": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} [decidable_eq γ] (f : α → β → γ) (s : finset α) (t : finset β)",
    "doc_string": " The image of a binary function `f : α → β → γ` as a function `finset α → finset β → finset γ`. Mathematically this should be thought of as the image of the corresponding function `α × β → γ`.",
    "kind": "def",
    "type": "finset γ"
  },
  {
    "name": "composition_series.top",
    "statement": "def composition_series.top {X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X",
    "theorem": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X",
    "args": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X)",
    "doc_string": "The largest element of a `composition_series`",
    "kind": "def",
    "type": "X"
  },
  {
    "name": "zero_at_infty_continuous_map",
    "statement": "structure zero_at_infty_continuous_map (α : Type u) (β : Type v) [topological_space α] [has_zero β] [topological_space β] : Type (max u v)",
    "theorem": "(α : Type u) (β : Type v) [topological_space α] [has_zero β] [topological_space β] : Type (max u v)",
    "args": "(α : Type u) (β : Type v) [topological_space α] [has_zero β] [topological_space β]",
    "doc_string": " `C₀(α, β)` is the type of continuous functions `α → β` which vanish at infinity from a topological space to a metric space with a zero element.  When possible, instead of parametrizing results over `(f : C₀(α, β))`, you should parametrize over `(F : Type*) [zero_at_infty_continuous_map_class F α β] (f : F)`.  When you extend this structure, make sure to extend `zero_at_infty_continuous_map_class`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "tactic.rcases_args",
    "statement": "inductive tactic.rcases_args  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The arguments to `rcases`, which in fact dispatch to several other tactics. * `rcases? expr (: n)?` or `rcases? ⟨expr, ...⟩ (: n)?` calls `rcases_hint` * `rcases? ⟨expr, ...⟩ (: n)?` calls `rcases_hint_many` * `rcases (h :)? expr (with patt)?` calls `rcases` * `rcases ⟨expr, ...⟩ (with patt)?` calls `rcases_many`",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "spectral_map.id",
    "statement": "def spectral_map.id (α : Type u_2) [topological_space α] : spectral_map α α",
    "theorem": "(α : Type u_2) [topological_space α] : spectral_map α α",
    "args": "(α : Type u_2) [topological_space α]",
    "doc_string": "`id` as a `spectral_map`.",
    "kind": "def",
    "type": "spectral_map α α"
  },
  {
    "name": "direct_sum",
    "statement": "def direct_sum (ι : Type v) (β : ι → Type w) [Π (i : ι), add_comm_monoid (β i)] : Type (max v w)",
    "theorem": "(ι : Type v) (β : ι → Type w) [Π (i : ι), add_comm_monoid (β i)] : Type (max v w)",
    "args": "(ι : Type v) (β : ι → Type w) [Π (i : ι), add_comm_monoid (β i)]",
    "doc_string": " `direct_sum β` is the direct sum of a family of additive commutative monoids `β i`.  Note: `open_locale direct_sum` will enable the notation `⨁ i, β i` for `direct_sum β`.",
    "kind": "def",
    "type": "Type (max v w)"
  },
  {
    "name": "monad_reader",
    "statement": "structure monad_reader (ρ : out_param (Type u)) (m : Type u → Type v) : Type v",
    "theorem": "(ρ : out_param (Type u)) (m : Type u → Type v) : Type v",
    "args": "(ρ : out_param (Type u)) (m : Type u → Type v)",
    "doc_string": "An implementation of [MonadReader](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader).    It does not contain `local` because this function cannot be lifted using `monad_lift`.    Instead, the `monad_reader_adapter` class provides the more general `adapt_reader` function.     Note: This class can be seen as a simplification of the more \"principled\" definition    ```lean    class monad_reader (ρ : out_param (Type u)) (n : Type u → Type u) :=    (lift {α : Type u} : (∀ {m : Type u → Type u} [monad m], reader_t ρ m α) → n α)    ```",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "local_ring",
    "statement": "structure local_ring (R : Type u) [semiring R] : Prop",
    "theorem": "(R : Type u) [semiring R] : Prop",
    "args": "(R : Type u) [semiring R]",
    "doc_string": " A semiring is local if it is nontrivial and `a` or `b` is a unit whenever `a + b = 1`. Note that `local_ring` is a predicate.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "doset",
    "statement": "def doset {α : Type u_2} [has_mul α] (a : α) (s t : set α) : set α",
    "theorem": "{α : Type u_2} [has_mul α] (a : α) (s t : set α) : set α",
    "args": "{α : Type u_2} [has_mul α] (a : α) (s t : set α)",
    "doc_string": "The double_coset as an element of `set α` corresponding to `s a t`",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "module.nontrivial",
    "statement": "theorem module.nontrivial (R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M]",
    "doc_string": "A semiring is `nontrivial` provided that there exists a nontrivial module over this semiring.",
    "kind": "theorem",
    "type": "nontrivial R"
  },
  {
    "name": "add_hom_class",
    "statement": "structure add_hom_class (F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_add M] [has_add N] : Type (max u_10 u_11 u_9)",
    "theorem": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_add M] [has_add N] : Type (max u_10 u_11 u_9)",
    "args": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_add M] [has_add N]",
    "doc_string": " `add_hom_class F M N` states that `F` is a type of addition-preserving homomorphisms. You should declare an instance of this typeclass when you extend `add_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_11 u_9)"
  },
  {
    "name": "fixed_by.subfield",
    "statement": "def fixed_by.subfield {M : Type u} [monoid M] (F : Type v) [field F] [mul_semiring_action M F] (m : M) : subfield F",
    "theorem": "{M : Type u} [monoid M] (F : Type v) [field F] [mul_semiring_action M F] (m : M) : subfield F",
    "args": "{M : Type u} [monoid M] (F : Type v) [field F] [mul_semiring_action M F] (m : M)",
    "doc_string": "The subfield of F fixed by the field endomorphism `m`.",
    "kind": "def",
    "type": "subfield F"
  },
  {
    "name": "function.embedding.schroeder_bernstein",
    "statement": "theorem function.embedding.schroeder_bernstein {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h",
    "theorem": "{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h",
    "args": "{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g)",
    "doc_string": " **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`.",
    "kind": "theorem",
    "type": "∃ (h : α → β), function.bijective h"
  },
  {
    "name": "right.mul_le_one",
    "statement": "theorem right.mul_le_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_le_one`.",
    "kind": "theorem",
    "type": "a * b ≤ 1"
  },
  {
    "name": "subgroup.is_commutative",
    "statement": "structure subgroup.is_commutative {G : Type u_1} [group G] (H : subgroup G) : Prop",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : Prop",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": "Commutivity of a subgroup",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "intermediate_field.gi",
    "statement": "def intermediate_field.gi {F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] : galois_insertion (intermediate_field.adjoin F) coe",
    "theorem": "{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E] : galois_insertion (intermediate_field.adjoin F) coe",
    "args": "{F : Type u_1} [field F] {E : Type u_2} [field E] [algebra F E]",
    "doc_string": "Galois insertion between `adjoin` and `coe`.",
    "kind": "def",
    "type": "galois_insertion (intermediate_field.adjoin F) coe"
  },
  {
    "name": "matrix.sub_up_right",
    "statement": "def matrix.sub_up_right {α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α) : matrix (fin u) (fin r) α",
    "theorem": "{α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α) : matrix (fin u) (fin r) α",
    "args": "{α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α)",
    "doc_string": "The top-right `u × r` part of a `(u+d) × (l+r)` matrix.",
    "kind": "def",
    "type": "matrix (fin u) (fin r) α"
  },
  {
    "name": "local_equiv.of_set",
    "statement": "def local_equiv.of_set {α : Type u_1} (s : set α) : local_equiv α α",
    "theorem": "{α : Type u_1} (s : set α) : local_equiv α α",
    "args": "{α : Type u_1} (s : set α)",
    "doc_string": "The identity local equiv on a set `s`",
    "kind": "def",
    "type": "local_equiv α α"
  },
  {
    "name": "add_monoid.in_closure",
    "statement": "inductive add_monoid.in_closure {A : Type u_2} [add_monoid A] (s : set A) : A → Prop",
    "theorem": "{A : Type u_2} [add_monoid A] (s : set A) : A → Prop",
    "args": "{A : Type u_2} [add_monoid A] (s : set A)",
    "doc_string": "The inductively defined membership predicate for the submonoid generated by a subset of a    monoid.",
    "kind": "inductive",
    "type": "A → Prop"
  },
  {
    "name": "free_group.red.step.length",
    "statement": "theorem free_group.red.step.length {α : Type u} {L₁ L₂ : list (α × bool)} : free_group.red.step L₁ L₂ → L₂.length + 2 = L₁.length",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} : free_group.red.step L₁ L₂ → L₂.length + 2 = L₁.length",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)}",
    "doc_string": " Predicate asserting that word `w₁` can be reduced to `w₂` in one step, i.e. there are words `w₃ w₄` and letter `x` such that `w₁ = w₃xx⁻¹w₄` and `w₂ = w₃w₄`",
    "kind": "theorem",
    "type": "free_group.red.step L₁ L₂ → L₂.length + 2 = L₁.length"
  },
  {
    "name": "is_coatomic",
    "statement": "structure is_coatomic (α : Type u_1) [partial_order α] [order_top α] : Prop",
    "theorem": "(α : Type u_1) [partial_order α] [order_top α] : Prop",
    "args": "(α : Type u_1) [partial_order α] [order_top α]",
    "doc_string": "A lattice is coatomic iff every element other than `⊤` has a coatom above it.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "measure_theory.is_stopping_time.measurable_space",
    "statement": "def measure_theory.is_stopping_time.measurable_space {α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] {f : measure_theory.filtration ι m} {τ : α → ι} (hτ : measure_theory.is_stopping_time f τ) : measurable_space α",
    "theorem": "{α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] {f : measure_theory.filtration ι m} {τ : α → ι} (hτ : measure_theory.is_stopping_time f τ) : measurable_space α",
    "args": "{α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] {f : measure_theory.filtration ι m} {τ : α → ι} (hτ : measure_theory.is_stopping_time f τ)",
    "doc_string": "The associated σ-algebra with a stopping time.",
    "kind": "def",
    "type": "measurable_space α"
  },
  {
    "name": "category_theory.noetherian",
    "statement": "structure category_theory.noetherian (C : Type u_1) [category_theory.category C] : Type",
    "theorem": "(C : Type u_1) [category_theory.category C] : Type",
    "args": "(C : Type u_1) [category_theory.category C]",
    "doc_string": "A category is noetherian if it is essentially small and all objects are noetherian.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "d_array.beq",
    "statement": "def d_array.beq {n : ℕ} {α : fin n → Type u} [Π (i : fin n), decidable_eq (α i)] (a b : d_array n α) : bool",
    "theorem": "{n : ℕ} {α : fin n → Type u} [Π (i : fin n), decidable_eq (α i)] (a b : d_array n α) : bool",
    "args": "{n : ℕ} {α : fin n → Type u} [Π (i : fin n), decidable_eq (α i)] (a b : d_array n α)",
    "doc_string": "Boolean element-wise equality check.",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "lazy_list.to_list",
    "statement": "def lazy_list.to_list {α : Type u} : lazy_list α → list α",
    "theorem": "{α : Type u} : lazy_list α → list α",
    "args": "{α : Type u}",
    "doc_string": "Converts a lazy list to a list. If the lazy list is infinite, then this function does not terminate.",
    "kind": "def",
    "type": "lazy_list α → list α"
  },
  {
    "name": "lower_set.Iic_Inf_hom",
    "statement": "def lower_set.Iic_Inf_hom {α : Type u_1} [complete_lattice α] : Inf_hom α (lower_set α)",
    "theorem": "{α : Type u_1} [complete_lattice α] : Inf_hom α (lower_set α)",
    "args": "{α : Type u_1} [complete_lattice α]",
    "doc_string": "`lower_set.Iic` as an `Inf_hom`.",
    "kind": "def",
    "type": "Inf_hom α (lower_set α)"
  },
  {
    "name": "mul_is_left_regular_iff",
    "statement": "theorem mul_is_left_regular_iff {R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) ↔ is_left_regular b",
    "theorem": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) ↔ is_left_regular b",
    "args": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a)",
    "doc_string": "  An element is left-regular if and only if multiplying it on the left by a left-regular element is left-regular.",
    "kind": "theorem",
    "type": "is_left_regular (a * b) ↔ is_left_regular b"
  },
  {
    "name": "pi_nat.cylinder",
    "statement": "def pi_nat.cylinder {E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (n : ℕ) : set (Π (n : ℕ), E n)",
    "theorem": "{E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (n : ℕ) : set (Π (n : ℕ), E n)",
    "args": "{E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (n : ℕ)",
    "doc_string": " In a product space `Π n, E n`, the cylinder set of length `n` around `x`, denoted `cylinder x n`, is the set of sequences `y` that coincide with `x` on the first `n` symbols, i.e., such that `y i = x i` for all `i < n`.",
    "kind": "def",
    "type": "set (Π (n : ℕ), E n)"
  },
  {
    "name": "le_inv_mul_of_mul_le",
    "statement": "theorem le_inv_mul_of_mul_le {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a * b ≤ c → b ≤ a⁻¹ * c",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a * b ≤ c → b ≤ a⁻¹ * c",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of le_inv_mul_iff_mul_le`.",
    "kind": "theorem",
    "type": "a * b ≤ c → b ≤ a⁻¹ * c"
  },
  {
    "name": "nat.gcd_eq_gcd_ab",
    "statement": "theorem nat.gcd_eq_gcd_ab (x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y",
    "theorem": "(x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y",
    "args": "(x y : ℕ)",
    "doc_string": " **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm.",
    "kind": "theorem",
    "type": "↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y"
  },
  {
    "name": "bitvec.one",
    "statement": "def bitvec.one (n : ℕ) : bitvec n",
    "theorem": "(n : ℕ) : bitvec n",
    "args": "(n : ℕ)",
    "doc_string": "Create a bitvector of length `n` whose `n-1`st entry is 1 and other entries are 0.",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "free_add_magma.map",
    "statement": "def free_add_magma.map {α : Type u} {β : Type v} (f : α → β) : free_add_magma α → free_add_magma β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : free_add_magma α → free_add_magma β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": " The unique additive magma homomorphism `free_add_magma α → free_add_magma β` that sends each `of x` to `of (f x)`.",
    "kind": "def",
    "type": "free_add_magma α → free_add_magma β"
  },
  {
    "name": "nat.arithmetic_function.sigma",
    "statement": "def nat.arithmetic_function.sigma (k : ℕ) : nat.arithmetic_function ℕ",
    "theorem": "(k : ℕ) : nat.arithmetic_function ℕ",
    "args": "(k : ℕ)",
    "doc_string": "`σ k n` is the sum of the `k`th powers of the divisors of `n`",
    "kind": "def",
    "type": "nat.arithmetic_function ℕ"
  },
  {
    "name": "discrete_valuation_ring.add_val",
    "statement": "def discrete_valuation_ring.add_val (R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : add_valuation R enat",
    "theorem": "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : add_valuation R enat",
    "args": "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R]",
    "doc_string": "The `enat`-valued additive valuation on a DVR",
    "kind": "def",
    "type": "add_valuation R enat"
  },
  {
    "name": "finset.disj_sum",
    "statement": "def finset.disj_sum {α : Type u_1} {β : Type u_2} (s : finset α) (t : finset β) : finset (α ⊕ β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (s : finset α) (t : finset β) : finset (α ⊕ β)",
    "args": "{α : Type u_1} {β : Type u_2} (s : finset α) (t : finset β)",
    "doc_string": "Disjoint sum of finsets.",
    "kind": "def",
    "type": "finset (α ⊕ β)"
  },
  {
    "name": "category_theory.monoidal_closed",
    "statement": "structure category_theory.monoidal_closed (C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "A monoidal category `C` is (right) monoidal closed if every object is (right) closed.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "non_unital_comm_ring",
    "statement": "structure non_unital_comm_ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "ereal.neg_le_of_neg_le",
    "statement": "theorem ereal.neg_le_of_neg_le {a b : ereal} (h : -a ≤ b) : -b ≤ a",
    "theorem": "{a b : ereal} (h : -a ≤ b) : -b ≤ a",
    "args": "{a b : ereal} (h : -a ≤ b)",
    "doc_string": "if `-a ≤ b` then `-b ≤ a` on `ereal`.",
    "kind": "theorem",
    "type": "-b ≤ a"
  },
  {
    "name": "is_seq_closed_iff_is_closed",
    "statement": "theorem is_seq_closed_iff_is_closed {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s",
    "theorem": "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s",
    "args": "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X}",
    "doc_string": "In a sequential space, a set is closed iff it's sequentially closed.",
    "kind": "theorem",
    "type": "is_seq_closed s ↔ is_closed s"
  },
  {
    "name": "pow_four_add_four_mul_pow_four",
    "statement": "theorem pow_four_add_four_mul_pow_four {R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
    "theorem": "{R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)",
    "args": "{R : Type u_1} [comm_ring R] {a b : R}",
    "doc_string": "Sophie Germain's identity, see <https://www.cut-the-knot.org/blue/SophieGermainIdentity.shtml>.",
    "kind": "theorem",
    "type": "a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)"
  },
  {
    "name": "composition.ones",
    "statement": "def composition.ones (n : ℕ) : composition n",
    "theorem": "(n : ℕ) : composition n",
    "args": "(n : ℕ)",
    "doc_string": "The composition made of blocks all of size `1`.",
    "kind": "def",
    "type": "composition n"
  },
  {
    "name": "zero_lt.left.one_lt_mul_of_le_of_lt",
    "statement": "theorem zero_lt.left.one_lt_mul_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "has_measurable_vadd₂",
    "statement": "structure has_measurable_vadd₂ (M : Type u_1) (α : Type u_2) [has_vadd M α] [measurable_space M] [measurable_space α] : Prop",
    "theorem": "(M : Type u_1) (α : Type u_2) [has_vadd M α] [measurable_space M] [measurable_space α] : Prop",
    "args": "(M : Type u_1) (α : Type u_2) [has_vadd M α] [measurable_space M] [measurable_space α]",
    "doc_string": " We say that the action of `M` on `α` `has_measurable_vadd₂` if the map `(c, x) ↦ c +ᵥ x` is a measurable function.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "tactic.ring_exp.ex_type",
    "statement": "inductive tactic.ring_exp.ex_type  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The values in `ex_type` are used as parameters to `ex` to control the expression's structure.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "d_array.nil",
    "statement": "def d_array.nil {α : fin 0 → Type u_1} : d_array 0 α",
    "theorem": "{α : fin 0 → Type u_1} : d_array 0 α",
    "args": "{α : fin 0 → Type u_1}",
    "doc_string": "The empty array.",
    "kind": "def",
    "type": "d_array 0 α"
  },
  {
    "name": "list.split_on_p_aux",
    "statement": "def list.split_on_p_aux {α : Type u} (P : α → Prop) [decidable_pred P] : list α → (list α → list α) → list (list α)",
    "theorem": "{α : Type u} (P : α → Prop) [decidable_pred P] : list α → (list α → list α) → list (list α)",
    "args": "{α : Type u} (P : α → Prop) [decidable_pred P]",
    "doc_string": "An auxiliary function for `split_on_p`.",
    "kind": "def",
    "type": "list α → (list α → list α) → list (list α)"
  },
  {
    "name": "measurable_of_tendsto_nnreal",
    "statement": "theorem measurable_of_tendsto_nnreal {α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g",
    "theorem": "{α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g",
    "args": "{α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g))",
    "doc_string": "A sequential limit of measurable `ℝ≥0` valued functions is measurable.",
    "kind": "theorem",
    "type": "measurable g"
  },
  {
    "name": "multiplicative",
    "statement": "def multiplicative (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " If `α` carries some additive structure, then `multiplicative α` carries the corresponding multiplicative structure.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "no_zero_divisors.to_cancel_monoid_with_zero",
    "statement": "def no_zero_divisors.to_cancel_monoid_with_zero {α : Type u} [ring α] [no_zero_divisors α] : cancel_monoid_with_zero α",
    "theorem": "{α : Type u} [ring α] [no_zero_divisors α] : cancel_monoid_with_zero α",
    "args": "{α : Type u} [ring α] [no_zero_divisors α]",
    "doc_string": " A ring with no zero divisors is a `cancel_monoid_with_zero`.  Note this is not an instance as it forms a typeclass loop.",
    "kind": "def",
    "type": "cancel_monoid_with_zero α"
  },
  {
    "name": "zero_lt.left.one_lt_mul_of_lt_of_le",
    "statement": "theorem zero_lt.left.one_lt_mul_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "to_nat",
    "statement": "def to_nat {α : Type u} [primcodable α] [inhabited α] (p : set α) : set ℕ",
    "theorem": "{α : Type u} [primcodable α] [inhabited α] (p : set α) : set ℕ",
    "args": "{α : Type u} [primcodable α] [inhabited α] (p : set α)",
    "doc_string": "Computable and injective mapping of predicates to sets of natural numbers.",
    "kind": "def",
    "type": "set ℕ"
  },
  {
    "name": "finset.univ",
    "statement": "def finset.univ {α : Type u_1} [fintype α] : finset α",
    "theorem": "{α : Type u_1} [fintype α] : finset α",
    "args": "{α : Type u_1} [fintype α]",
    "doc_string": "`univ` is the universal finite set of type `finset α` implied from  the assumption `fintype α`.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "topological_space.sum.second_countable_topology",
    "statement": "def topological_space.sum.second_countable_topology {α : Type u} {β : Type u_1} [topological_space α] [topological_space β] [topological_space.second_countable_topology α] [topological_space.second_countable_topology β] : topological_space.second_countable_topology (α ⊕ β)",
    "theorem": "{α : Type u} {β : Type u_1} [topological_space α] [topological_space β] [topological_space.second_countable_topology α] [topological_space.second_countable_topology β] : topological_space.second_countable_topology (α ⊕ β)",
    "args": "{α : Type u} {β : Type u_1} [topological_space α] [topological_space β] [topological_space.second_countable_topology α] [topological_space.second_countable_topology β]",
    "doc_string": "A sum type of two second countable spaces is second countable.",
    "kind": "def",
    "type": "topological_space.second_countable_topology (α ⊕ β)"
  },
  {
    "name": "ordset.erase",
    "statement": "def ordset.erase {α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α) : ordset α",
    "theorem": "{α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α) : ordset α",
    "args": "{α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α)",
    "doc_string": " O(log n). Remove an element from the set equivalent to `x`. Does nothing if there is no such element.",
    "kind": "def",
    "type": "ordset α"
  },
  {
    "name": "monad_reader_adapter",
    "statement": "structure monad_reader_adapter (ρ ρ' : out_param (Type u)) (m m' : Type u → Type v) : Type (max (u+1) v)",
    "theorem": "(ρ ρ' : out_param (Type u)) (m m' : Type u → Type v) : Type (max (u+1) v)",
    "args": "(ρ ρ' : out_param (Type u)) (m m' : Type u → Type v)",
    "doc_string": "Adapt a monad stack, changing the type of its top-most environment.     This class is comparable to [Control.Lens.Magnify](https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Zoom.html#t:Magnify), but does not use lenses (why would it), and is derived automatically for any transformer implementing `monad_functor`.     Note: This class can be seen as a simplification of the more \"principled\" definition    ```lean    class monad_reader_functor (ρ ρ' : out_param (Type u)) (n n' : Type u → Type u) :=    (map {α : Type u} : (∀ {m : Type u → Type u} [monad m], reader_t ρ m α → reader_t ρ' m α) → n α → n' α)    ```",
    "kind": "structure",
    "type": "Type (max (u+1) v)"
  },
  {
    "name": "linarith.linexp",
    "statement": "def linarith.linexp  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A linear expression is a list of pairs of variable indices and coefficients, representing the sum of the products of each coefficient with its corresponding variable.  Some functions on `linexp` assume that `n : ℕ` occurs at most once as the first element of a pair, and that the list is sorted in decreasing order of the first argument. This is not enforced by the type but the operations here preserve it.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "fintype",
    "statement": "structure fintype (α : Type u_4) : Type u_4",
    "theorem": "(α : Type u_4) : Type u_4",
    "args": "(α : Type u_4)",
    "doc_string": "`fintype α` means that `α` is finite, i.e. there are only  finitely many distinct elements of type `α`. The evidence of this  is a finset `elems` (a list up to permutation without duplicates),  together with a proof that everything of type `α` is in the list.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "continuous_groupoid.closed_under_restriction",
    "statement": "def continuous_groupoid.closed_under_restriction {H : Type u} [topological_space H] : closed_under_restriction (continuous_groupoid H)",
    "theorem": "{H : Type u} [topological_space H] : closed_under_restriction (continuous_groupoid H)",
    "args": "{H : Type u} [topological_space H]",
    "doc_string": "The groupoid of all local homeomorphisms on a topological space `H` is closed under restriction.",
    "kind": "def",
    "type": "closed_under_restriction (continuous_groupoid H)"
  },
  {
    "name": "nat.divisors",
    "statement": "def nat.divisors (n : ℕ) : finset ℕ",
    "theorem": "(n : ℕ) : finset ℕ",
    "args": "(n : ℕ)",
    "doc_string": "`divisors n` is the `finset` of divisors of `n`. As a special case, `divisors 0 = ∅`.",
    "kind": "def",
    "type": "finset ℕ"
  },
  {
    "name": "ordset.insert'",
    "statement": "def ordset.insert' {α : Type u_1} [preorder α] [is_total α has_le.le] [decidable_rel has_le.le] (x : α) (s : ordset α) : ordset α",
    "theorem": "{α : Type u_1} [preorder α] [is_total α has_le.le] [decidable_rel has_le.le] (x : α) (s : ordset α) : ordset α",
    "args": "{α : Type u_1} [preorder α] [is_total α has_le.le] [decidable_rel has_le.le] (x : α) (s : ordset α)",
    "doc_string": "O(log n). Insert an element into the set, preserving balance and the BST property.  If an equivalent element is already in the set, the set is returned as is.",
    "kind": "def",
    "type": "ordset α"
  },
  {
    "name": "subring_class",
    "statement": "structure subring_class (S : Type u_1) (R : out_param (Type u)) [ring R] [set_like S R] : Type",
    "theorem": "(S : Type u_1) (R : out_param (Type u)) [ring R] [set_like S R] : Type",
    "args": "(S : Type u_1) (R : out_param (Type u)) [ring R] [set_like S R]",
    "doc_string": " `subring_class S R` states that `S` is a type of subsets `s ⊆ R` that are both a multiplicative submonoid and an additive subgroup.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "function.surjective.comp_left",
    "statement": "theorem function.surjective.comp_left {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g) : function.surjective (function.comp g)",
    "theorem": "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g) : function.surjective (function.comp g)",
    "args": "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g)",
    "doc_string": "Composition by an surjective function on the left is itself surjective.",
    "kind": "theorem",
    "type": "function.surjective (function.comp g)"
  },
  {
    "name": "continuous_subalgebra",
    "statement": "def continuous_subalgebra {α : Type u_1} [topological_space α] {R : Type u_2} [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] : subalgebra R (α → A)",
    "theorem": "{α : Type u_1} [topological_space α] {R : Type u_2} [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] : subalgebra R (α → A)",
    "args": "{α : Type u_1} [topological_space α] {R : Type u_2} [comm_semiring R] {A : Type u_3} [topological_space A] [semiring A] [algebra R A] [topological_semiring A]",
    "doc_string": "The `R`-subalgebra of continuous maps `α → A`.",
    "kind": "def",
    "type": "subalgebra R (α → A)"
  },
  {
    "name": "category_theory.limits.has_reflexive_coequalizers",
    "statement": "structure category_theory.limits.has_reflexive_coequalizers (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`C` has reflexive coequalizers if it has coequalizers for every reflexive pair.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "subgroup.normalizer",
    "statement": "def subgroup.normalizer {G : Type u_1} [group G] (H : subgroup G) : subgroup G",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : subgroup G",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": "The `normalizer` of `H` is the largest subgroup of `G` inside which `H` is normal.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "sym.sym'",
    "statement": "def sym.sym' (α : Type u_1) (n : ℕ) : Type u_1",
    "theorem": "(α : Type u_1) (n : ℕ) : Type u_1",
    "args": "(α : Type u_1) (n : ℕ)",
    "doc_string": "Another definition of the nth symmetric power, using vectors modulo permutations. (See `sym`.)",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "invertible_div",
    "statement": "def invertible_div {α : Type u} [group_with_zero α] (a b : α) [invertible a] [invertible b] : invertible (a / b)",
    "theorem": "{α : Type u} [group_with_zero α] (a b : α) [invertible a] [invertible b] : invertible (a / b)",
    "args": "{α : Type u} [group_with_zero α] (a b : α) [invertible a] [invertible b]",
    "doc_string": "`b / a` is the inverse of `a / b`",
    "kind": "def",
    "type": "invertible (a / b)"
  },
  {
    "name": "disjoint",
    "statement": "def disjoint {α : Type u} [semilattice_inf α] [order_bot α] (a b : α) : Prop",
    "theorem": "{α : Type u} [semilattice_inf α] [order_bot α] (a b : α) : Prop",
    "args": "{α : Type u} [semilattice_inf α] [order_bot α] (a b : α)",
    "doc_string": "Two elements of a lattice are disjoint if their inf is the bottom element.  (This generalizes disjoint sets, viewed as members of the subset lattice.)",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "homological_complex.zero",
    "statement": "def homological_complex.zero {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} [category_theory.limits.has_zero_object V] : homological_complex V c",
    "theorem": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} [category_theory.limits.has_zero_object V] : homological_complex V c",
    "args": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} [category_theory.limits.has_zero_object V]",
    "doc_string": "The zero complex",
    "kind": "def",
    "type": "homological_complex V c"
  },
  {
    "name": "cardinal.categorical",
    "statement": "def cardinal.categorical {L : first_order.language} (κ : cardinal) (T : L.Theory) : Prop",
    "theorem": "{L : first_order.language} (κ : cardinal) (T : L.Theory) : Prop",
    "args": "{L : first_order.language} (κ : cardinal) (T : L.Theory)",
    "doc_string": "A theory is `κ`-categorical if all models of size `κ` are isomorphic.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "fermat_42.minimal",
    "statement": "def fermat_42.minimal (a b c : ℤ) : Prop",
    "theorem": "(a b c : ℤ) : Prop",
    "args": "(a b c : ℤ)",
    "doc_string": " We say a solution to `a ^ 4 + b ^ 4 = c ^ 2` is minimal if there is no other solution with a smaller `c` (in absolute value).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.surjective",
    "statement": "def function.surjective {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "theorem": "{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "args": "{α : Sort u₁} {β : Sort u₂} (f : α → β)",
    "doc_string": " A function `f : α → β` is called surjective if every `b : β` is equal to `f a` for some `a : α`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "dense_range",
    "statement": "def dense_range {β : Type u_2} [topological_space β] {κ : Type u_5} (f : κ → β) : Prop",
    "theorem": "{β : Type u_2} [topological_space β] {κ : Type u_5} (f : κ → β) : Prop",
    "args": "{β : Type u_2} [topological_space β] {κ : Type u_5} (f : κ → β)",
    "doc_string": "`f : ι → β` has dense range if its range (image) is a dense subset of β.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_add_unit.add_submonoid",
    "statement": "def is_add_unit.add_submonoid (M : Type u_1) [add_monoid M] : add_submonoid M",
    "theorem": "(M : Type u_1) [add_monoid M] : add_submonoid M",
    "args": "(M : Type u_1) [add_monoid M]",
    "doc_string": "The additive submonoid consisting of the additive units of an additive monoid",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "with_bot.conditionally_complete_lattice",
    "statement": "def with_bot.conditionally_complete_lattice {α : Type u_1} [conditionally_complete_lattice α] : conditionally_complete_lattice (with_bot α)",
    "theorem": "{α : Type u_1} [conditionally_complete_lattice α] : conditionally_complete_lattice (with_bot α)",
    "args": "{α : Type u_1} [conditionally_complete_lattice α]",
    "doc_string": " Adding a bottom element to a conditionally complete lattice gives a conditionally complete lattice",
    "kind": "def",
    "type": "conditionally_complete_lattice (with_bot α)"
  },
  {
    "name": "wseq.zip",
    "statement": "def wseq.zip {α : Type u} {β : Type v} : wseq α → wseq β → wseq (α × β)",
    "theorem": "{α : Type u} {β : Type v} : wseq α → wseq β → wseq (α × β)",
    "args": "{α : Type u} {β : Type v}",
    "doc_string": "Zip two weak sequences into a single sequence of pairs",
    "kind": "def",
    "type": "wseq α → wseq β → wseq (α × β)"
  },
  {
    "name": "free_product.neword",
    "statement": "inductive free_product.neword {ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : ι → ι → Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : ι → ι → Type (max u_1 u_2)",
    "args": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)]",
    "doc_string": " A `neword M i j` is a representation of a non-empty reduced words where the first letter comes from `M i` and the last letter comes from `M j`. It can be constructed from singletons and via concatentation, and thus provides a useful induction principle.",
    "kind": "inductive",
    "type": "ι → ι → Type (max u_1 u_2)"
  },
  {
    "name": "module.free.matrix",
    "statement": "def module.free.matrix (R : Type u) [semiring R] {m : Type u_1} {n : Type u_2} [fintype m] [fintype n] : module.free R (matrix m n R)",
    "theorem": "(R : Type u) [semiring R] {m : Type u_1} {n : Type u_2} [fintype m] [fintype n] : module.free R (matrix m n R)",
    "args": "(R : Type u) [semiring R] {m : Type u_1} {n : Type u_2} [fintype m] [fintype n]",
    "doc_string": "The module of finite matrices is free.",
    "kind": "def",
    "type": "module.free R (matrix m n R)"
  },
  {
    "name": "free_ring",
    "statement": "def free_ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "The free ring over a type `α`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "ulift.seq",
    "statement": "def ulift.seq {α : Type u} {β : Type v} (f : ulift (α → β)) (x : ulift α) : ulift β",
    "theorem": "{α : Type u} {β : Type v} (f : ulift (α → β)) (x : ulift α) : ulift β",
    "args": "{α : Type u} {β : Type v} (f : ulift (α → β)) (x : ulift α)",
    "doc_string": "Applicative sequencing.",
    "kind": "def",
    "type": "ulift β"
  },
  {
    "name": "has_fix",
    "statement": "structure has_fix (α : Type u_3) : Type u_3",
    "theorem": "(α : Type u_3) : Type u_3",
    "args": "(α : Type u_3)",
    "doc_string": " `has_fix α` gives us a way to calculate the fixed point of function of type `α → α`.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "is_strict_total_order'",
    "statement": "structure is_strict_total_order' (α : Type u) (lt : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (lt : α → α → Prop) : Prop",
    "args": "(α : Type u) (lt : α → α → Prop)",
    "doc_string": " This is basically the same as `is_strict_total_order`, but that definition has a redundant assumption `is_incomp_trans α lt`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.artinian_object",
    "statement": "structure category_theory.artinian_object {C : Type u_1} [category_theory.category C] (X : C) : Prop",
    "theorem": "{C : Type u_1} [category_theory.category C] (X : C) : Prop",
    "args": "{C : Type u_1} [category_theory.category C] (X : C)",
    "doc_string": "An artinian object is an object which does not have infinite decreasing sequences of subobjects.  See https://stacks.math.columbia.edu/tag/0FCF",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "mul_action_with_zero",
    "statement": "structure mul_action_with_zero (R : Type u_1) (M : Type u_3) [monoid_with_zero R] [has_zero M] : Type (max u_1 u_3)",
    "theorem": "(R : Type u_1) (M : Type u_3) [monoid_with_zero R] [has_zero M] : Type (max u_1 u_3)",
    "args": "(R : Type u_1) (M : Type u_3) [monoid_with_zero R] [has_zero M]",
    "doc_string": "  An action of a monoid with zero `R` on a Type `M`, also with `0`, extends `mul_action` and is compatible with `0` (both in `R` and in `M`), with `1 ∈ R`, and with associativity of multiplication on the monoid `M`.",
    "kind": "structure",
    "type": "Type (max u_1 u_3)"
  },
  {
    "name": "BoundedOrder",
    "statement": "structure BoundedOrder  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of bounded orders with monotone functions.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "tree.of_rbnode",
    "statement": "def tree.of_rbnode {α : Type u} : rbnode α → tree α",
    "theorem": "{α : Type u} : rbnode α → tree α",
    "args": "{α : Type u}",
    "doc_string": "Makes a `tree α` out of a red-black tree.",
    "kind": "def",
    "type": "rbnode α → tree α"
  },
  {
    "name": "projectivization_setoid",
    "statement": "def projectivization_setoid (K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : setoid {v // v ≠ 0}",
    "theorem": "(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : setoid {v // v ≠ 0}",
    "args": "(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V]",
    "doc_string": "The setoid whose quotient is the projectivization of `V`.",
    "kind": "def",
    "type": "setoid {v // v ≠ 0}"
  },
  {
    "name": "matrix.invertible_of_diagonal_invertible",
    "statement": "def matrix.invertible_of_diagonal_invertible {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (v : n → α) [invertible (matrix.diagonal v)] : invertible v",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (v : n → α) [invertible (matrix.diagonal v)] : invertible v",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (v : n → α) [invertible (matrix.diagonal v)]",
    "doc_string": "`v` is invertible if `diagonal v` is",
    "kind": "def",
    "type": "invertible v"
  },
  {
    "name": "mk_iff.list_option_merge",
    "statement": "def mk_iff.list_option_merge {α : Type u_1} {β : Type u_2} : list (option α) → list β → list (option β)",
    "theorem": "{α : Type u_1} {β : Type u_2} : list (option α) → list β → list (option β)",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": "Iterate over two lists, if the first element of the first list is `none`, insert `none` into the result and continue with the tail of first list. Otherwise, wrap the first element of the second list with `some` and continue with the tails of both lists. Return when either list is empty.  Example: ```lean list_option_merge [none, some (), none, some ()] [0, 1, 2, 3, 4] = [none, (some 0), none, (some 1)] ```",
    "kind": "def",
    "type": "list (option α) → list β → list (option β)"
  },
  {
    "name": "matrix_equiv_tensor.to_fun",
    "statement": "def matrix_equiv_tensor.to_fun (R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) (a : A) (m : matrix n n R) : matrix n n A",
    "theorem": "(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) (a : A) (m : matrix n n R) : matrix n n A",
    "args": "(R : Type u) [comm_semiring R] (A : Type v) [semiring A] [algebra R A] (n : Type w) (a : A) (m : matrix n n R)",
    "doc_string": "(Implementation detail). The bare function underlying `(A ⊗[R] matrix n n R) →ₐ[R] matrix n n A`, on pure tensors.",
    "kind": "def",
    "type": "matrix n n A"
  },
  {
    "name": "add_subgroup.prod",
    "statement": "def add_subgroup.prod {G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (K : add_subgroup N) : add_subgroup (G × N)",
    "theorem": "{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (K : add_subgroup N) : add_subgroup (G × N)",
    "args": "{G : Type u_1} [add_group G] {N : Type u_3} [add_group N] (H : add_subgroup G) (K : add_subgroup N)",
    "doc_string": "Given `add_subgroup`s `H`, `K` of `add_group`s `A`, `B` respectively, `H × K` as an `add_subgroup` of `A × B`.",
    "kind": "def",
    "type": "add_subgroup (G × N)"
  },
  {
    "name": "AddSemigroup.of",
    "statement": "def AddSemigroup.of (M : Type u) [add_semigroup M] : AddSemigroup",
    "theorem": "(M : Type u) [add_semigroup M] : AddSemigroup",
    "args": "(M : Type u) [add_semigroup M]",
    "doc_string": "Construct a bundled `AddSemigroup` from the underlying type and typeclass.",
    "kind": "def",
    "type": "AddSemigroup"
  },
  {
    "name": "is_lub",
    "statement": "def is_lub {α : Type u} [preorder α] (s : set α) : α → Prop",
    "theorem": "{α : Type u} [preorder α] (s : set α) : α → Prop",
    "args": "{α : Type u} [preorder α] (s : set α)",
    "doc_string": "`a` is a least upper bound of a set `s`; for a partial order, it is unique if exists.",
    "kind": "def",
    "type": "α → Prop"
  },
  {
    "name": "sSet.S1",
    "statement": "def sSet.S1  : sSet",
    "theorem": " : sSet",
    "args": "",
    "doc_string": "The simplicial circle.",
    "kind": "def",
    "type": "sSet"
  },
  {
    "name": "path",
    "statement": "structure path {X : Type u_1} [topological_space X] (x y : X) : Type u_1",
    "theorem": "{X : Type u_1} [topological_space X] (x y : X) : Type u_1",
    "args": "{X : Type u_1} [topological_space X] (x y : X)",
    "doc_string": "Continuous path connecting two points `x` and `y` in a topological space",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "mul_ne_zero_iff",
    "statement": "theorem mul_ne_zero_iff {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then the product of two elements is nonzero iff both of them are nonzero.",
    "kind": "theorem",
    "type": "a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0"
  },
  {
    "name": "Compactum",
    "statement": "def Compactum  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The type `Compactum` of Compacta, defined as algebras for the ultrafilter monad.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "left.mul_lt_one'",
    "statement": "theorem left.mul_lt_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one'`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "filter.has_countable_basis",
    "statement": "structure filter.has_countable_basis {α : Type u_1} {ι : Type u_4} (l : filter α) (p : ι → Prop) (s : ι → set α) : Prop",
    "theorem": "{α : Type u_1} {ι : Type u_4} (l : filter α) (p : ι → Prop) (s : ι → set α) : Prop",
    "args": "{α : Type u_1} {ι : Type u_4} (l : filter α) (p : ι → Prop) (s : ι → set α)",
    "doc_string": " We say that a filter `l` has a countable basis `s : ι → set α` bounded by `p : ι → Prop`, if `t ∈ l` if and only if `t` includes `s i` for some `i` such that `p i`, and the set defined by `p` is countable.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "fin2.add",
    "statement": "def fin2.add {n : ℕ} (i : fin2 n) (k : ℕ) : fin2 (n + k)",
    "theorem": "{n : ℕ} (i : fin2 n) (k : ℕ) : fin2 (n + k)",
    "args": "{n : ℕ} (i : fin2 n) (k : ℕ)",
    "doc_string": "`i + k : fin2 (n + k)` when `i : fin2 n` and `k : ℕ`",
    "kind": "def",
    "type": "fin2 (n + k)"
  },
  {
    "name": "vector3.tail",
    "statement": "def vector3.tail {α : Type u_1} {n : ℕ} (v : vector3 α n.succ) : vector3 α n",
    "theorem": "{α : Type u_1} {n : ℕ} (v : vector3 α n.succ) : vector3 α n",
    "args": "{α : Type u_1} {n : ℕ} (v : vector3 α n.succ)",
    "doc_string": "Get the tail of a nonempty vector.",
    "kind": "def",
    "type": "vector3 α n"
  },
  {
    "name": "algebraic_topology.alternating_face_map_complex.obj",
    "statement": "def algebraic_topology.alternating_face_map_complex.obj {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C) : chain_complex C ℕ",
    "theorem": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C) : chain_complex C ℕ",
    "args": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] (X : category_theory.simplicial_object C)",
    "doc_string": "The alternating face map complex, on objects",
    "kind": "def",
    "type": "chain_complex C ℕ"
  },
  {
    "name": "subalgebra.is_algebraic",
    "statement": "def subalgebra.is_algebraic {R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : Prop",
    "theorem": "{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : Prop",
    "args": "{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A)",
    "doc_string": "A subalgebra is algebraic if all its elements are algebraic.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bitvec.add_lsb",
    "statement": "def bitvec.add_lsb (r : ℕ) (b : bool) : ℕ",
    "theorem": "(r : ℕ) (b : bool) : ℕ",
    "args": "(r : ℕ) (b : bool)",
    "doc_string": "`add_lsb r b` is `r + r + 1` if `b` is `tt` and `r + r` otherwise.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "add_comm_group",
    "statement": "structure add_comm_group (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": "An additive commutative group is an additive group with commutative `(+)`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "finset.powerset_len",
    "statement": "def finset.powerset_len {α : Type u_1} (n : ℕ) (s : finset α) : finset (finset α)",
    "theorem": "{α : Type u_1} (n : ℕ) (s : finset α) : finset (finset α)",
    "args": "{α : Type u_1} (n : ℕ) (s : finset α)",
    "doc_string": " Given an integer `n` and a finset `s`, then `powerset_len n s` is the finset of subsets of `s` of cardinality `n`.",
    "kind": "def",
    "type": "finset (finset α)"
  },
  {
    "name": "is_dedekind_domain.height_one_spectrum.int_valuation",
    "statement": "def is_dedekind_domain.height_one_spectrum.int_valuation {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : valuation R (with_zero (multiplicative ℤ))",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) : valuation R (with_zero (multiplicative ℤ))",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R)",
    "doc_string": "The `v`-adic valuation on `R`.",
    "kind": "def",
    "type": "valuation R (with_zero (multiplicative ℤ))"
  },
  {
    "name": "subgroup.zpowers",
    "statement": "def subgroup.zpowers {G : Type u_1} [group G] (g : G) : subgroup G",
    "theorem": "{G : Type u_1} [group G] (g : G) : subgroup G",
    "args": "{G : Type u_1} [group G] (g : G)",
    "doc_string": "The subgroup generated by an element.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "measure_theory.simple_func.pair",
    "statement": "def measure_theory.simple_func.pair {α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α β) (g : measure_theory.simple_func α γ) : measure_theory.simple_func α (β × γ)",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α β) (g : measure_theory.simple_func α γ) : measure_theory.simple_func α (β × γ)",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α β) (g : measure_theory.simple_func α γ)",
    "doc_string": " Combine two simple functions `f : α →ₛ β` and `g : α →ₛ β` into `λ a, (f a, g a)`.",
    "kind": "def",
    "type": "measure_theory.simple_func α (β × γ)"
  },
  {
    "name": "category_theory.limits.has_coproduct",
    "statement": "def category_theory.limits.has_coproduct {β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Prop",
    "theorem": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Prop",
    "args": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C)",
    "doc_string": "An abbreviation for `has_colimit (discrete.functor f)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.graded_object_with_shift",
    "statement": "def category_theory.graded_object_with_shift {β : Type w} [add_comm_group β] (s : β) (C : Type u) : Type (max w u)",
    "theorem": "{β : Type w} [add_comm_group β] (s : β) (C : Type u) : Type (max w u)",
    "args": "{β : Type w} [add_comm_group β] (s : β) (C : Type u)",
    "doc_string": "A type synonym for `β → C`, used for `β`-graded objects in a category `C` with a shift functor given by translation by `s`.",
    "kind": "def",
    "type": "Type (max w u)"
  },
  {
    "name": "is_left_regular.of_mul",
    "statement": "theorem is_left_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b))",
    "doc_string": "  If an element `b` becomes left-regular after multiplying it on the left by a left-regular element, then `b` is left-regular.",
    "kind": "theorem",
    "type": "is_left_regular b"
  },
  {
    "name": "Ring.has_limits_of_size",
    "statement": "def Ring.has_limits_of_size  : category_theory.limits.has_limits_of_size Ring",
    "theorem": " : category_theory.limits.has_limits_of_size Ring",
    "args": "",
    "doc_string": "The category of rings has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size Ring"
  },
  {
    "name": "polynomial.reflect",
    "statement": "def polynomial.reflect {R : Type u_1} [semiring R] (N : ℕ) : polynomial R → polynomial R",
    "theorem": "{R : Type u_1} [semiring R] (N : ℕ) : polynomial R → polynomial R",
    "args": "{R : Type u_1} [semiring R] (N : ℕ)",
    "doc_string": " `reflect N f` is the polynomial such that `(reflect N f).coeff i = f.coeff (rev_at N i)`. In other words, the terms with exponent `[0, ..., N]` now have exponent `[N, ..., 0]`.  In practice, `reflect` is only used when `N` is at least as large as the degree of `f`.  Eventually, it will be used with `N` exactly equal to the degree of `f`.",
    "kind": "def",
    "type": "polynomial R → polynomial R"
  },
  {
    "name": "zero_lt.right.mul_lt_one_of_lt_of_lt",
    "statement": "theorem zero_lt.right.mul_lt_one_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "topological_fiber_prebundle.total_space_topology",
    "statement": "def topological_fiber_prebundle.total_space_topology {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} (a : topological_fiber_prebundle F proj) : topological_space Z",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} (a : topological_fiber_prebundle F proj) : topological_space Z",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} (a : topological_fiber_prebundle F proj)",
    "doc_string": "Topology on the total space that will make the prebundle into a bundle.",
    "kind": "def",
    "type": "topological_space Z"
  },
  {
    "name": "category_theory.idempotents.to_karoubi_is_equivalence",
    "statement": "def category_theory.idempotents.to_karoubi_is_equivalence (C : Type u_1) [category_theory.category C] [category_theory.is_idempotent_complete C] : category_theory.is_equivalence (category_theory.idempotents.to_karoubi C)",
    "theorem": "(C : Type u_1) [category_theory.category C] [category_theory.is_idempotent_complete C] : category_theory.is_equivalence (category_theory.idempotents.to_karoubi C)",
    "args": "(C : Type u_1) [category_theory.category C] [category_theory.is_idempotent_complete C]",
    "doc_string": "If `C` is idempotent complete, the functor `to_karoubi : C ⥤ karoubi C` is an equivalence.",
    "kind": "def",
    "type": "category_theory.is_equivalence (category_theory.idempotents.to_karoubi C)"
  },
  {
    "name": "polynomial.integral_normalization",
    "statement": "def polynomial.integral_normalization {R : Type u} [semiring R] (f : polynomial R) : polynomial R",
    "theorem": "{R : Type u} [semiring R] (f : polynomial R) : polynomial R",
    "args": "{R : Type u} [semiring R] (f : polynomial R)",
    "doc_string": " If `f : R[X]` is a nonzero polynomial with root `z`, `integral_normalization f` is a monic polynomial with root `leading_coeff f * z`.  Moreover, `integral_normalization 0 = 0`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "measure_theory.measure.count",
    "statement": "def measure_theory.measure.count {α : Type u_1} [measurable_space α] : measure_theory.measure α",
    "theorem": "{α : Type u_1} [measurable_space α] : measure_theory.measure α",
    "args": "{α : Type u_1} [measurable_space α]",
    "doc_string": "Counting measure on any measurable space.",
    "kind": "def",
    "type": "measure_theory.measure α"
  },
  {
    "name": "parser.unfailing",
    "statement": "structure parser.unfailing {α : Type} (p : parser α) : Prop",
    "theorem": "{α : Type} (p : parser α) : Prop",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "A `parser a` is defined to be `unfailing` if it always produces a `done` `parse_result`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "metric.lipschitz_inf_dist_pt",
    "statement": "theorem metric.lipschitz_inf_dist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_dist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_dist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set is Lipschitz in point with constant 1",
    "kind": "theorem",
    "type": "lipschitz_with 1 (λ (x : α), metric.inf_dist x s)"
  },
  {
    "name": "stream.cons",
    "statement": "def stream.cons {α : Type u} (a : α) (s : stream α) : stream α",
    "theorem": "{α : Type u} (a : α) (s : stream α) : stream α",
    "args": "{α : Type u} (a : α) (s : stream α)",
    "doc_string": "Prepend an element to a stream.",
    "kind": "def",
    "type": "stream α"
  },
  {
    "name": "TopCommRing",
    "statement": "structure TopCommRing  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "A bundled topological commutative ring.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "is_torsion_of_fintype",
    "statement": "theorem is_torsion_of_fintype {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G",
    "theorem": "{G : Type u_1} [group G] [fintype G] : monoid.is_torsion G",
    "args": "{G : Type u_1} [group G] [fintype G]",
    "doc_string": "Finite groups are torsion groups.",
    "kind": "theorem",
    "type": "monoid.is_torsion G"
  },
  {
    "name": "category_theory.is_filtered_or_empty",
    "statement": "structure category_theory.is_filtered_or_empty (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category `is_filtered_or_empty` if 1. for every pair of objects there exists another object \"to the right\", and 2. for every pair of parallel morphisms there exists a morphism to the right so the compositions    are equal.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "turing.partrec_to_TM2.stmt'",
    "statement": "def turing.partrec_to_TM2.stmt'  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of TM2 statements used by this machine.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "infinite.nonempty_field",
    "statement": "theorem infinite.nonempty_field {α : Type u} [infinite α] : nonempty (field α)",
    "theorem": "{α : Type u} [infinite α] : nonempty (field α)",
    "args": "{α : Type u} [infinite α]",
    "doc_string": "Any infinite type can be endowed a field structure.",
    "kind": "theorem",
    "type": "nonempty (field α)"
  },
  {
    "name": "multiset.can_lift",
    "statement": "def multiset.can_lift {α : Type u_1} {β : Type u_2} [can_lift α β] : can_lift (multiset α) (multiset β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [can_lift α β] : can_lift (multiset α) (multiset β)",
    "args": "{α : Type u_1} {β : Type u_2} [can_lift α β]",
    "doc_string": " If each element of `s : multiset α` can be lifted to `β`, then `s` can be lifted to `multiset β`.",
    "kind": "def",
    "type": "can_lift (multiset α) (multiset β)"
  },
  {
    "name": "category_theory.is_connected",
    "statement": "structure category_theory.is_connected (J : Type u₁) [category_theory.category J] : Prop",
    "theorem": "(J : Type u₁) [category_theory.category J] : Prop",
    "args": "(J : Type u₁) [category_theory.category J]",
    "doc_string": "We define a connected category as a _nonempty_ category for which every functor to a discrete category is constant.  NB. Some authors include the empty category as connected, we do not. We instead are interested in categories with exactly one 'connected component'.  This allows us to show that the functor X ⨯ - preserves connected limits.  See <https://stacks.math.columbia.edu/tag/002S>",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_alg_closed",
    "statement": "structure is_alg_closed (k : Type u) [field k] : Prop",
    "theorem": "(k : Type u) [field k] : Prop",
    "args": "(k : Type u) [field k]",
    "doc_string": " Typeclass for algebraically closed fields.  To show `polynomial.splits p f` for an arbitrary ring homomorphism `f`, see `is_alg_closed.splits_codomain` and `is_alg_closed.splits_domain`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "matrix.linfty_op_non_unital_normed_ring",
    "statement": "def matrix.linfty_op_non_unital_normed_ring {n : Type u_4} {α : Type u_5} [fintype n] [non_unital_normed_ring α] : non_unital_normed_ring (matrix n n α)",
    "theorem": "{n : Type u_4} {α : Type u_5} [fintype n] [non_unital_normed_ring α] : non_unital_normed_ring (matrix n n α)",
    "args": "{n : Type u_4} {α : Type u_5} [fintype n] [non_unital_normed_ring α]",
    "doc_string": " Normed non-unital ring instance (using sup norm of L1 norm) for matrices over a normed non-unital ring. Not declared as an instance because there are several natural choices for defining the norm of a matrix.",
    "kind": "def",
    "type": "non_unital_normed_ring (matrix n n α)"
  },
  {
    "name": "FinPartialOrder.of",
    "statement": "def FinPartialOrder.of (α : Type u_1) [partial_order α] [fintype α] : FinPartialOrder",
    "theorem": "(α : Type u_1) [partial_order α] [fintype α] : FinPartialOrder",
    "args": "(α : Type u_1) [partial_order α] [fintype α]",
    "doc_string": "Construct a bundled `FinPartialOrder` from `fintype` + `partial_order`.",
    "kind": "def",
    "type": "FinPartialOrder"
  },
  {
    "name": "inv_lt_one_iff_one_lt",
    "statement": "theorem inv_lt_one_iff_one_lt {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "kind": "theorem",
    "type": "a⁻¹ < 1 ↔ 1 < a"
  },
  {
    "name": "opens.pretopology_of_grothendieck",
    "statement": "theorem opens.pretopology_of_grothendieck (T : Type u) [topological_space T] : category_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T",
    "theorem": "(T : Type u) [topological_space T] : category_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T",
    "args": "(T : Type u) [topological_space T]",
    "doc_string": "The pretopology associated to a space is the largest pretopology that    generates the Grothendieck topology associated to the space.",
    "kind": "theorem",
    "type": "category_theory.pretopology.of_grothendieck (topological_space.opens T) (opens.grothendieck_topology T) = opens.pretopology T"
  },
  {
    "name": "division_ring_of_is_unit_or_eq_zero",
    "statement": "def division_ring_of_is_unit_or_eq_zero {R : Type u_1} [nontrivial R] [hR : ring R] (h : ∀ (a : R), is_unit a ∨ a = 0) : division_ring R",
    "theorem": "{R : Type u_1} [nontrivial R] [hR : ring R] (h : ∀ (a : R), is_unit a ∨ a = 0) : division_ring R",
    "args": "{R : Type u_1} [nontrivial R] [hR : ring R] (h : ∀ (a : R), is_unit a ∨ a = 0)",
    "doc_string": "Constructs a `division_ring` structure on a `ring` consisting only of units and 0.",
    "kind": "def",
    "type": "division_ring R"
  },
  {
    "name": "rank_condition_of_strong_rank_condition",
    "statement": "def rank_condition_of_strong_rank_condition (R : Type u) [semiring R] [strong_rank_condition R] : rank_condition R",
    "theorem": "(R : Type u) [semiring R] [strong_rank_condition R] : rank_condition R",
    "args": "(R : Type u) [semiring R] [strong_rank_condition R]",
    "doc_string": "By the universal property for free modules, any surjective map `(fin n → R) →ₗ[R] (fin m → R)` has an injective splitting `(fin m → R) →ₗ[R] (fin n → R)` from which the strong rank condition gives the necessary inequality for the rank condition.",
    "kind": "def",
    "type": "rank_condition R"
  },
  {
    "name": "option.melim",
    "statement": "def option.melim {α β : Type u_1} {m : Type u_1 → Type u_2} [monad m] (y : m β) (z : α → m β) (x : m (option α)) : m β",
    "theorem": "{α β : Type u_1} {m : Type u_1 → Type u_2} [monad m] (y : m β) (z : α → m β) (x : m (option α)) : m β",
    "args": "{α β : Type u_1} {m : Type u_1 → Type u_2} [monad m] (y : m β) (z : α → m β) (x : m (option α))",
    "doc_string": "A monadic analogue of `option.elim`.",
    "kind": "def",
    "type": "m β"
  },
  {
    "name": "right.add_pos_of_pos_of_nonneg",
    "statement": "theorem right.add_pos_of_pos_of_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_pos_of_nonneg`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "category_theory.normal_epi_category.has_coequalizers",
    "statement": "def category_theory.normal_epi_category.has_coequalizers {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] : category_theory.limits.has_coequalizers C",
    "theorem": "{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C] : category_theory.limits.has_coequalizers C",
    "args": "{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_cokernels C] [category_theory.normal_epi_category C]",
    "doc_string": "A `normal_epi_category` category with finite coproducts and cokernels has all coequalizers.",
    "kind": "def",
    "type": "category_theory.limits.has_coequalizers C"
  },
  {
    "name": "holor",
    "statement": "def holor (α : Type u) (ds : list ℕ) : Type u",
    "theorem": "(α : Type u) (ds : list ℕ) : Type u",
    "args": "(α : Type u) (ds : list ℕ)",
    "doc_string": "Holor (indexed collections of tensor coefficients)",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "submodule.has_pointwise_neg",
    "statement": "def submodule.has_pointwise_neg {R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_neg (submodule R M)",
    "theorem": "{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M] : has_neg (submodule R M)",
    "args": "{R : Type u_2} {M : Type u_3} [semiring R] [add_comm_group M] [module R M]",
    "doc_string": " The submodule with every element negated. Note if `R` is a ring and not just a semiring, this is a no-op, as shown by `submodule.neg_eq_self`.  Recall that When `R` is the semiring corresponding to the nonnegative elements of `R'`, `submodule R' M` is the type of cones of `M`. This instance reflects such cones about `0`.  This is available as an instance in the `pointwise` locale.",
    "kind": "def",
    "type": "has_neg (submodule R M)"
  },
  {
    "name": "seq.join",
    "statement": "def seq.join {α : Type u} : seq (seq1 α) → seq α",
    "theorem": "{α : Type u} : seq (seq1 α) → seq α",
    "args": "{α : Type u}",
    "doc_string": "Flatten a sequence of sequences. (It is required that the  sequences be nonempty to ensure productivity; in the case  of an infinite sequence of `nil`, the first element is never  generated.)",
    "kind": "def",
    "type": "seq (seq1 α) → seq α"
  },
  {
    "name": "filter.has_zpow",
    "statement": "def filter.has_zpow {α : Type u_2} [has_one α] [has_mul α] [has_inv α] : has_pow (filter α) ℤ",
    "theorem": "{α : Type u_2} [has_one α] [has_mul α] [has_inv α] : has_pow (filter α) ℤ",
    "args": "{α : Type u_2} [has_one α] [has_mul α] [has_inv α]",
    "doc_string": " Repeated pointwise multiplication/division (not the same as pointwise repeated multiplication/division!) of a `filter`. See Note [pointwise nat action].",
    "kind": "def",
    "type": "has_pow (filter α) ℤ"
  },
  {
    "name": "has_lt.lt.trans_eq'",
    "statement": "theorem has_lt.lt.trans_eq' {α : Type u} [preorder α] {a b c : α} : b < c → a = b → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b < c → a = b → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_lt_of_eq'`.",
    "kind": "theorem",
    "type": "b < c → a = b → a < c"
  },
  {
    "name": "open_embedding.to_local_homeomorph",
    "statement": "def open_embedding.to_local_homeomorph {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (h : open_embedding f) [nonempty α] : local_homeomorph α β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (h : open_embedding f) [nonempty α] : local_homeomorph α β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (h : open_embedding f) [nonempty α]",
    "doc_string": " An open embedding of `α` into `β`, with `α` nonempty, defines a local homeomorphism whose source is all of `α`.  The converse is also true; see `local_homeomorph.to_open_embedding`.",
    "kind": "def",
    "type": "local_homeomorph α β"
  },
  {
    "name": "function.is_fixed_pt.eq",
    "statement": "theorem function.is_fixed_pt.eq {α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) : f x = x",
    "theorem": "{α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) : f x = x",
    "args": "{α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x)",
    "doc_string": "If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`.",
    "kind": "theorem",
    "type": "f x = x"
  },
  {
    "name": "valuation.is_equiv",
    "statement": "def valuation.is_equiv {R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] [linear_ordered_comm_monoid_with_zero Γ'₀] (v₁ : valuation R Γ₀) (v₂ : valuation R Γ'₀) : Prop",
    "theorem": "{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] [linear_ordered_comm_monoid_with_zero Γ'₀] (v₁ : valuation R Γ₀) (v₂ : valuation R Γ'₀) : Prop",
    "args": "{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] [linear_ordered_comm_monoid_with_zero Γ'₀] (v₁ : valuation R Γ₀) (v₂ : valuation R Γ'₀)",
    "doc_string": "Two valuations on `R` are defined to be equivalent if they induce the same preorder on `R`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "has_continuous_sub",
    "statement": "structure has_continuous_sub (G : Type u_1) [topological_space G] [has_sub G] : Prop",
    "theorem": "(G : Type u_1) [topological_space G] [has_sub G] : Prop",
    "args": "(G : Type u_1) [topological_space G] [has_sub G]",
    "doc_string": " A typeclass saying that `λ p : G × G, p.1 - p.2` is a continuous function. This property automatically holds for topological additive groups but it also holds, e.g., for `ℝ≥0`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "hole_command",
    "statement": "structure hole_command  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The front-end (e.g., Emacs, VS Code) can invoke commands for holes `{! ... !}` in a declaration. A command is a tactic that takes zero or more pre-terms in the hole, and returns a list of pair (s, descr) where 's' is a substitution and 'descr' is a short explanation for the substitution. Each string 's' represents a different way to fill the hole. The front-end is responsible for replacing the hole with the string/alternative selected by the user.  This infra-structure can be use to implement auto-fill and/or refine commands.  An action may return an empty list. This is useful for actions that just return information such as: the type of an expression, its normal form, etc.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "upper_semicontinuous_at",
    "statement": "def upper_semicontinuous_at {α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (x : α) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (x : α) : Prop",
    "args": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (x : α)",
    "doc_string": " A real function `f` is upper semicontinuous at `x` if, for any `ε > 0`, for all `x'` close enough to `x`, then `f x'` is at most `f x + ε`. We formulate this in a general preordered space, using an arbitrary `y > f x` instead of `f x + ε`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pseudo_epimorphism.comp",
    "statement": "def pseudo_epimorphism.comp {α : Type u_2} {β : Type u_3} {γ : Type u_4} [preorder α] [preorder β] [preorder γ] (g : pseudo_epimorphism β γ) (f : pseudo_epimorphism α β) : pseudo_epimorphism α γ",
    "theorem": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [preorder α] [preorder β] [preorder γ] (g : pseudo_epimorphism β γ) (f : pseudo_epimorphism α β) : pseudo_epimorphism α γ",
    "args": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [preorder α] [preorder β] [preorder γ] (g : pseudo_epimorphism β γ) (f : pseudo_epimorphism α β)",
    "doc_string": "Composition of `pseudo_epimorphism`s as a `pseudo_epimorphism`.",
    "kind": "def",
    "type": "pseudo_epimorphism α γ"
  },
  {
    "name": "CommRing.prod_fan",
    "statement": "def CommRing.prod_fan (A B : CommRing) : category_theory.limits.binary_fan A B",
    "theorem": "(A B : CommRing) : category_theory.limits.binary_fan A B",
    "args": "(A B : CommRing)",
    "doc_string": "The product in `CommRing` is the cartesian product. This is the binary fan.",
    "kind": "def",
    "type": "category_theory.limits.binary_fan A B"
  },
  {
    "name": "inv_gold",
    "statement": "theorem inv_gold  : golden_ratio⁻¹ = -golden_conj",
    "theorem": " : golden_ratio⁻¹ = -golden_conj",
    "args": "",
    "doc_string": "The inverse of the golden ratio is the opposite of its conjugate.",
    "kind": "theorem",
    "type": "golden_ratio⁻¹ = -golden_conj"
  },
  {
    "name": "matrix.is_adjoint_pair",
    "statement": "def matrix.is_adjoint_pair {R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J J₃ A A' : matrix n n R₃) : Prop",
    "theorem": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J J₃ A A' : matrix n n R₃) : Prop",
    "args": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J J₃ A A' : matrix n n R₃)",
    "doc_string": " The condition for the square matrices `A`, `A'` to be an adjoint pair with respect to the square matrices `J`, `J₃`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordinal.mex",
    "statement": "def ordinal.mex {ι : Type u} (f : ι → ordinal) : ordinal",
    "theorem": "{ι : Type u} (f : ι → ordinal) : ordinal",
    "args": "{ι : Type u} (f : ι → ordinal)",
    "doc_string": "The minimum excluded ordinal in a family of ordinals.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "lie_algebra.orthogonal.type_D",
    "statement": "def lie_algebra.orthogonal.type_D (l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l ⊕ l) (l ⊕ l) R)",
    "theorem": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l ⊕ l) (l ⊕ l) R)",
    "args": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l]",
    "doc_string": " The classical Lie algebra of type D as a Lie subalgebra of matrices associated to the matrix `JD`.",
    "kind": "def",
    "type": "lie_subalgebra R (matrix (l ⊕ l) (l ⊕ l) R)"
  },
  {
    "name": "localization.one",
    "statement": "def localization.one {M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S",
    "theorem": "{M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S",
    "args": "{M : Type u_1} [comm_monoid M] (S : submonoid M)",
    "doc_string": "The identity element of a localization is defined as `⟨1, 1⟩`.",
    "kind": "def",
    "type": "localization S"
  },
  {
    "name": "composition.size_up_to",
    "statement": "def composition.size_up_to {n : ℕ} (c : composition n) (i : ℕ) : ℕ",
    "theorem": "{n : ℕ} (c : composition n) (i : ℕ) : ℕ",
    "args": "{n : ℕ} (c : composition n) (i : ℕ)",
    "doc_string": "The sum of the sizes of the blocks in a composition up to `i`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "seq.take",
    "statement": "def seq.take {α : Type u} : ℕ → seq α → list α",
    "theorem": "{α : Type u} : ℕ → seq α → list α",
    "args": "{α : Type u}",
    "doc_string": "Take the first `n` elements of the sequence (producing a list)",
    "kind": "def",
    "type": "ℕ → seq α → list α"
  },
  {
    "name": "set.has_neg",
    "statement": "def set.has_neg {α : Type u_2} [has_neg α] : has_neg (set α)",
    "theorem": "{α : Type u_2} [has_neg α] : has_neg (set α)",
    "args": "{α : Type u_2} [has_neg α]",
    "doc_string": "The pointwise negation of set `-s` is defined as `{x | -x ∈ s}` in locale `pointwise`. It is equal to `{-x | x ∈ s}`, see `set.image_neg`.",
    "kind": "def",
    "type": "has_neg (set α)"
  },
  {
    "name": "mul_self_div_self",
    "statement": "theorem mul_self_div_self {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a * a / a = a",
    "theorem": "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a * a / a = a",
    "args": "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀)",
    "doc_string": " Multiplying `a` by itself and then dividing by itself results in `a` (whether or not `a` is zero).",
    "kind": "theorem",
    "type": "a * a / a = a"
  },
  {
    "name": "nat.primrec'",
    "statement": "inductive nat.primrec' {n : ℕ} : (vector ℕ n → ℕ) → Prop",
    "theorem": "{n : ℕ} : (vector ℕ n → ℕ) → Prop",
    "args": "{n : ℕ}",
    "doc_string": "An alternative inductive definition of `primrec` which  does not use the pairing function on ℕ, and so has to  work with n-ary functions on ℕ instead of unary functions.  We prove that this is equivalent to the regular notion  in `to_prim` and `of_prim`.",
    "kind": "inductive",
    "type": "(vector ℕ n → ℕ) → Prop"
  },
  {
    "name": "lazy_list.iterates",
    "statement": "def lazy_list.iterates {α : Type u} (f : α → α) : α → lazy_list α",
    "theorem": "{α : Type u} (f : α → α) : α → lazy_list α",
    "args": "{α : Type u} (f : α → α)",
    "doc_string": "The infinite lazy list `[x, f x, f (f x), ...]` of iterates of a function. This definition is meta because it creates an infinite list.",
    "kind": "def",
    "type": "α → lazy_list α"
  },
  {
    "name": "is_square",
    "statement": "def is_square {α : Type u_2} [has_mul α] (a : α) : Prop",
    "theorem": "{α : Type u_2} [has_mul α] (a : α) : Prop",
    "args": "{α : Type u_2} [has_mul α] (a : α)",
    "doc_string": "  An element `a` of a type `α` with multiplication satisfies `square a` if `a = r * r`, for some `r : α`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.xgcd_aux",
    "statement": "def nat.xgcd_aux  : ℕ → ℤ → ℤ → ℕ → ℤ → ℤ → ℕ × ℤ × ℤ",
    "theorem": " : ℕ → ℤ → ℤ → ℕ → ℤ → ℤ → ℕ × ℤ × ℤ",
    "args": "",
    "doc_string": "Helper function for the extended GCD algorithm (`nat.xgcd`).",
    "kind": "def",
    "type": "ℕ → ℤ → ℤ → ℕ → ℤ → ℤ → ℕ × ℤ × ℤ"
  },
  {
    "name": "polynomial.trailing_degree",
    "statement": "def polynomial.trailing_degree {R : Type u} [semiring R] (p : polynomial R) : with_top ℕ",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : with_top ℕ",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": " `trailing_degree p` is the multiplicity of `x` in the polynomial `p`, i.e. the smallest `X`-exponent in `p`. `trailing_degree p = some n` when `p ≠ 0` and `n` is the smallest power of `X` that appears in `p`, otherwise `trailing_degree 0 = ⊤`.",
    "kind": "def",
    "type": "with_top ℕ"
  },
  {
    "name": "ideal",
    "statement": "def ideal (R : Type u) [semiring R] : Type u",
    "theorem": "(R : Type u) [semiring R] : Type u",
    "args": "(R : Type u) [semiring R]",
    "doc_string": " A (left) ideal in a semiring `R` is an additive submonoid `s` such that `a * b ∈ s` whenever `b ∈ s`. If `R` is a ring, then `s` is an additive subgroup.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "con.gi",
    "statement": "def con.gi (M : Type u_1) [has_mul M] : galois_insertion con_gen coe_fn",
    "theorem": "(M : Type u_1) [has_mul M] : galois_insertion con_gen coe_fn",
    "args": "(M : Type u_1) [has_mul M]",
    "doc_string": "There is a Galois insertion of congruence relations on a type with a multiplication `M` into    binary relations on `M`.",
    "kind": "def",
    "type": "galois_insertion con_gen coe_fn"
  },
  {
    "name": "emetric.edist_lt_top_setoid",
    "statement": "def emetric.edist_lt_top_setoid {α : Type u} [pseudo_emetric_space α] : setoid α",
    "theorem": "{α : Type u} [pseudo_emetric_space α] : setoid α",
    "args": "{α : Type u} [pseudo_emetric_space α]",
    "doc_string": "Relation “two points are at a finite edistance” is an equivalence relation.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "category_theory.bicategory.strict",
    "statement": "structure category_theory.bicategory.strict (B : Type u) [category_theory.bicategory B] : Prop",
    "theorem": "(B : Type u) [category_theory.bicategory B] : Prop",
    "args": "(B : Type u) [category_theory.bicategory B]",
    "doc_string": "A bicategory is called `strict` if the left unitors, the right unitors, and the associators are isomorphisms given by equalities.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.subobject.Sup",
    "statement": "def category_theory.subobject.Sup {C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_images C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A",
    "theorem": "{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_images C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A",
    "args": "{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_images C] {A : C} (s : set (category_theory.subobject A))",
    "doc_string": " When `[well_powered C] [has_images C] [has_coproducts C]`, `subobject A` has arbitrary supremums.",
    "kind": "def",
    "type": "category_theory.subobject A"
  },
  {
    "name": "lie_algebra.orthogonal.JD",
    "statement": "def lie_algebra.orthogonal.JD (l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R",
    "theorem": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R",
    "args": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R]",
    "doc_string": " A matrix defining a canonical even-rank symmetric bilinear form.  It looks like this as a `2l x 2l` matrix of `l x l` blocks:     [ 0 1 ]    [ 1 0 ]",
    "kind": "def",
    "type": "matrix (l ⊕ l) (l ⊕ l) R"
  },
  {
    "name": "list.mbfind'",
    "statement": "def list.mbfind' {m : Type u → Type v} [monad m] {α : Type u} (p : α → m (ulift bool)) : list α → m (option α)",
    "theorem": "{m : Type u → Type v} [monad m] {α : Type u} (p : α → m (ulift bool)) : list α → m (option α)",
    "args": "{m : Type u → Type v} [monad m] {α : Type u} (p : α → m (ulift bool))",
    "doc_string": " `mbfind' p l` returns the first element `a` of `l` for which `p a` returns true. `mbfind'` short-circuits, so `p` is not necessarily run on every `a` in `l`. This is a monadic version of `list.find`.",
    "kind": "def",
    "type": "list α → m (option α)"
  },
  {
    "name": "array",
    "statement": "def array (n : ℕ) (α : Type u) : Type u",
    "theorem": "(n : ℕ) (α : Type u) : Type u",
    "args": "(n : ℕ) (α : Type u)",
    "doc_string": "A non-dependent array (see `d_array`). Implemented in the VM as a persistent array.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "intent_closure",
    "statement": "def intent_closure {α : Type u_2} {β : Type u_3} (r : α → β → Prop) (s : set α) : set β",
    "theorem": "{α : Type u_2} {β : Type u_3} (r : α → β → Prop) (s : set α) : set β",
    "args": "{α : Type u_2} {β : Type u_3} (r : α → β → Prop) (s : set α)",
    "doc_string": " The intent closure of `s : set α` along a relation `r : α → β → Prop` is the set of all elements which `r` relates to all elements of `s`.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "irreducible.dvd_symm",
    "statement": "theorem irreducible.dvd_symm {α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q) : p ∣ q → q ∣ p",
    "theorem": "{α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q) : p ∣ q → q ∣ p",
    "args": "{α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q)",
    "doc_string": "If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`.",
    "kind": "theorem",
    "type": "p ∣ q → q ∣ p"
  },
  {
    "name": "subring.sub_mem",
    "statement": "theorem subring.sub_mem {R : Type u} [ring R] (s : subring R) {x y : R} (hx : x ∈ s) (hy : y ∈ s) : x - y ∈ s",
    "theorem": "{R : Type u} [ring R] (s : subring R) {x y : R} (hx : x ∈ s) (hy : y ∈ s) : x - y ∈ s",
    "args": "{R : Type u} [ring R] (s : subring R) {x y : R} (hx : x ∈ s) (hy : y ∈ s)",
    "doc_string": "A subring is closed under subtraction",
    "kind": "theorem",
    "type": "x - y ∈ s"
  },
  {
    "name": "generalized_continued_fraction.continuants",
    "statement": "def generalized_continued_fraction.continuants {K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)",
    "theorem": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)",
    "args": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K)",
    "doc_string": "Returns the continuants `⟨Aₙ, Bₙ⟩` of `g`.",
    "kind": "def",
    "type": "stream (generalized_continued_fraction.pair K)"
  },
  {
    "name": "snum.add",
    "statement": "def snum.add (a b : snum) : snum",
    "theorem": "(a b : snum) : snum",
    "args": "(a b : snum)",
    "doc_string": "Add two `snum`s.",
    "kind": "def",
    "type": "snum"
  },
  {
    "name": "pi.can_lift",
    "statement": "def pi.can_lift (ι : Sort u_1) (α : ι → Sort u_2) (β : ι → Sort u_3) [Π (i : ι), can_lift (α i) (β i)] : can_lift (Π (i : ι), α i) (Π (i : ι), β i)",
    "theorem": "(ι : Sort u_1) (α : ι → Sort u_2) (β : ι → Sort u_3) [Π (i : ι), can_lift (α i) (β i)] : can_lift (Π (i : ι), α i) (Π (i : ι), β i)",
    "args": "(ι : Sort u_1) (α : ι → Sort u_2) (β : ι → Sort u_3) [Π (i : ι), can_lift (α i) (β i)]",
    "doc_string": "Enable automatic handling of pi types in `can_lift`.",
    "kind": "def",
    "type": "can_lift (Π (i : ι), α i) (Π (i : ι), β i)"
  },
  {
    "name": "is_localization.is_integer",
    "statement": "def is_localization.is_integer (R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (a : S) : Prop",
    "theorem": "(R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (a : S) : Prop",
    "args": "(R : Type u_1) [comm_ring R] {S : Type u_2} [comm_ring S] [algebra R S] (a : S)",
    "doc_string": " Given `a : S`, `S` a localization of `R`, `is_integer R a` iff `a` is in the image of the localization map from `R` to `S`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_cyclic_of_prime_card",
    "statement": "theorem is_cyclic_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α",
    "theorem": "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α",
    "args": "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p)",
    "doc_string": "A finite group of prime order is cyclic.",
    "kind": "theorem",
    "type": "is_cyclic α"
  },
  {
    "name": "add_submonoid.ext",
    "statement": "theorem add_submonoid.ext {M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T",
    "theorem": "{M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T",
    "args": "{M : Type u_1} [add_zero_class M] {S T : add_submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T)",
    "doc_string": "Two `add_submonoid`s are equal if they have the same elements.",
    "kind": "theorem",
    "type": "S = T"
  },
  {
    "name": "CpltSepUniformSpace",
    "statement": "structure CpltSepUniformSpace  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "A (bundled) complete separated uniform space.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "eq_zero_of_mul_eq_self_right",
    "statement": "theorem eq_zero_of_mul_eq_self_right {M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a) : a = 0",
    "theorem": "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a) : a = 0",
    "args": "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a)",
    "doc_string": " An element of a `cancel_monoid_with_zero` fixed by right multiplication by an element other than one must be zero.",
    "kind": "theorem",
    "type": "a = 0"
  },
  {
    "name": "add_left_cancel_semigroup",
    "statement": "structure add_left_cancel_semigroup (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": " An `add_left_cancel_semigroup` is an additive semigroup such that `a + b = a + c` implies `b = c`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "turing.list_blank",
    "statement": "def turing.list_blank (Γ : Type u_1) [inhabited Γ] : Type u_1",
    "theorem": "(Γ : Type u_1) [inhabited Γ] : Type u_1",
    "args": "(Γ : Type u_1) [inhabited Γ]",
    "doc_string": " A `list_blank Γ` is a quotient of `list Γ` by extension by blanks at the end. This is used to represent half-tapes of a Turing machine, so that we can pretend that the list continues infinitely with blanks.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "representation.trivial",
    "statement": "def representation.trivial {k : Type u_1} {G : Type u_2} [comm_semiring k] [monoid G] : representation k G k",
    "theorem": "{k : Type u_1} {G : Type u_2} [comm_semiring k] [monoid G] : representation k G k",
    "args": "{k : Type u_1} {G : Type u_2} [comm_semiring k] [monoid G]",
    "doc_string": "The trivial representation of `G` on the one-dimensional module `k`.",
    "kind": "def",
    "type": "representation k G k"
  },
  {
    "name": "affine_subspace.convex",
    "statement": "theorem affine_subspace.convex {𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (Q : affine_subspace 𝕜 E) : convex 𝕜 ↑Q",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (Q : affine_subspace 𝕜 E) : convex 𝕜 ↑Q",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (Q : affine_subspace 𝕜 E)",
    "doc_string": "Affine subspaces are convex.",
    "kind": "theorem",
    "type": "convex 𝕜 ↑Q"
  },
  {
    "name": "nat.sub_mod_eq_zero_of_mod_eq",
    "statement": "theorem nat.sub_mod_eq_zero_of_mod_eq {a b c : ℕ} (h : a % c = b % c) : (a - b) % c = 0",
    "theorem": "{a b c : ℕ} (h : a % c = b % c) : (a - b) % c = 0",
    "args": "{a b c : ℕ} (h : a % c = b % c)",
    "doc_string": "If `a` and `b` are equal mod `c`, `a - b` is zero mod `c`.",
    "kind": "theorem",
    "type": "(a - b) % c = 0"
  },
  {
    "name": "category_theory.zigzag.setoid",
    "statement": "def category_theory.zigzag.setoid (J : Type u₂) [category_theory.category J] : setoid J",
    "theorem": "(J : Type u₂) [category_theory.category J] : setoid J",
    "args": "(J : Type u₂) [category_theory.category J]",
    "doc_string": "The setoid given by the equivalence relation `zigzag`. A quotient for this setoid is a connected component of the category.",
    "kind": "def",
    "type": "setoid J"
  },
  {
    "name": "submodule.is_principal",
    "statement": "structure submodule.is_principal {R : Type u} {M : Type v} [ring R] [add_comm_group M] [module R M] (S : submodule R M) : Prop",
    "theorem": "{R : Type u} {M : Type v} [ring R] [add_comm_group M] [module R M] (S : submodule R M) : Prop",
    "args": "{R : Type u} {M : Type v} [ring R] [add_comm_group M] [module R M] (S : submodule R M)",
    "doc_string": "An `R`-submodule of `M` is principal if it is generated by one element.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "sum.elim",
    "statement": "def sum.elim {α : Type u_1} {β : Type u_2} {γ : Sort u_3} (f : α → γ) (g : β → γ) : α ⊕ β → γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Sort u_3} (f : α → γ) (g : β → γ) : α ⊕ β → γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Sort u_3} (f : α → γ) (g : β → γ)",
    "doc_string": "Define a function on `α ⊕ β` by giving separate definitions on `α` and `β`.",
    "kind": "def",
    "type": "α ⊕ β → γ"
  },
  {
    "name": "array.encodable",
    "statement": "def array.encodable {α : Type u_1} [encodable α] {n : ℕ} : encodable (array n α)",
    "theorem": "{α : Type u_1} [encodable α] {n : ℕ} : encodable (array n α)",
    "args": "{α : Type u_1} [encodable α] {n : ℕ}",
    "doc_string": "If `α` is encodable, then so is `array n α`.",
    "kind": "def",
    "type": "encodable (array n α)"
  },
  {
    "name": "set_like",
    "statement": "structure set_like (A : Type u_1) (B : out_param (Type u_2)) : Type (max u_1 u_2)",
    "theorem": "(A : Type u_1) (B : out_param (Type u_2)) : Type (max u_1 u_2)",
    "args": "(A : Type u_1) (B : out_param (Type u_2))",
    "doc_string": " A class to indicate that there is a canonical injection between `A` and `set B`.  This has the effect of giving terms of `A` elements of type `B` (through a `has_mem` instance) and a compatible coercion to `Type*` as a subtype.  Note: if `set_like.coe` is a projection, implementers should create a simp lemma such as ```lean @[simp] lemma mem_carrier {p : my_subobject X} : x ∈ p.carrier ↔ x ∈ (p : set X) := iff.rfl ``` to normalize terms.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "quandle.conj",
    "statement": "def quandle.conj (G : Type u_1) : Type u_1",
    "theorem": "(G : Type u_1) : Type u_1",
    "args": "(G : Type u_1)",
    "doc_string": "The conjugation quandle of a group.  Each element of the group acts by the corresponding inner automorphism.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "vector.ext",
    "statement": "theorem vector.ext {n : ℕ} {α : Type u_1} {v w : vector α n} (h : ∀ (m : fin n), v.nth m = w.nth m) : v = w",
    "theorem": "{n : ℕ} {α : Type u_1} {v w : vector α n} (h : ∀ (m : fin n), v.nth m = w.nth m) : v = w",
    "args": "{n : ℕ} {α : Type u_1} {v w : vector α n} (h : ∀ (m : fin n), v.nth m = w.nth m)",
    "doc_string": "Two `v w : vector α n` are equal iff they are equal at every single index.",
    "kind": "theorem",
    "type": "v = w"
  },
  {
    "name": "free_magma.length",
    "statement": "def free_magma.length {α : Type u} : free_magma α → ℕ",
    "theorem": "{α : Type u} : free_magma α → ℕ",
    "args": "{α : Type u}",
    "doc_string": "Length of an element of a free magma.",
    "kind": "def",
    "type": "free_magma α → ℕ"
  },
  {
    "name": "star_div'",
    "statement": "theorem star_div' {R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "theorem": "{R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "args": "{R : Type u} [field R] [star_ring R] (x y : R)",
    "doc_string": "When multiplication is commutative, `star` preserves division.",
    "kind": "theorem",
    "type": "has_star.star (x / y) = has_star.star x / has_star.star y"
  },
  {
    "name": "is_preorder",
    "statement": "structure is_preorder (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": " `is_preorder X r` means that the binary relation `r` on `X` is a pre-order, that is, reflexive and transitive.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "hash_map.erase_aux",
    "statement": "def hash_map.erase_aux {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (Σ (a : α), β a) → list (Σ (a : α), β a)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (Σ (a : α), β a) → list (Σ (a : α), β a)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α)",
    "doc_string": "Modify a bucket to remove a key, if it exists.",
    "kind": "def",
    "type": "list (Σ (a : α), β a) → list (Σ (a : α), β a)"
  },
  {
    "name": "finset.centroid_weights_indicator_def",
    "statement": "theorem finset.centroid_weights_indicator_def (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : finset.centroid_weights_indicator k s = ↑s.indicator (finset.centroid_weights k s)",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : finset.centroid_weights_indicator k s = ↑s.indicator (finset.centroid_weights k s)",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι)",
    "doc_string": "The definition of `centroid_weights_indicator`.",
    "kind": "theorem",
    "type": "finset.centroid_weights_indicator k s = ↑s.indicator (finset.centroid_weights k s)"
  },
  {
    "name": "list.nodupkeys",
    "statement": "def list.nodupkeys {α : Type u} {β : α → Type v} (l : list (sigma β)) : Prop",
    "theorem": "{α : Type u} {β : α → Type v} (l : list (sigma β)) : Prop",
    "args": "{α : Type u} {β : α → Type v} (l : list (sigma β))",
    "doc_string": "Determines whether the store uses a key several times.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "simple_graph.coloring",
    "statement": "def simple_graph.coloring {V : Type u} (G : simple_graph V) (α : Type v) : Type (max u v)",
    "theorem": "{V : Type u} (G : simple_graph V) (α : Type v) : Type (max u v)",
    "args": "{V : Type u} (G : simple_graph V) (α : Type v)",
    "doc_string": "An `α`-coloring of a simple graph `G` is a homomorphism of `G` into the complete graph on `α`. This is also known as a proper coloring.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "wseq.productive",
    "statement": "structure wseq.productive {α : Type u} (s : wseq α) : Prop",
    "theorem": "{α : Type u} (s : wseq α) : Prop",
    "args": "{α : Type u} (s : wseq α)",
    "doc_string": "A weak sequence is *productive* if it never stalls forever - there are always a finite number of `think`s between `cons` constructors. The sequence itself is allowed to be infinite though.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "Profinite.of",
    "statement": "def Profinite.of (X : Type u_1) [topological_space X] [compact_space X] [t2_space X] [totally_disconnected_space X] : Profinite",
    "theorem": "(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] [totally_disconnected_space X] : Profinite",
    "args": "(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] [totally_disconnected_space X]",
    "doc_string": "Construct a term of `Profinite` from a type endowed with the structure of a compact, Hausdorff and totally disconnected topological space.",
    "kind": "def",
    "type": "Profinite"
  },
  {
    "name": "function.is_fixed_pt",
    "statement": "def function.is_fixed_pt {α : Type u} (f : α → α) (x : α) : Prop",
    "theorem": "{α : Type u} (f : α → α) (x : α) : Prop",
    "args": "{α : Type u} (f : α → α) (x : α)",
    "doc_string": "A point `x` is a fixed point of `f : α → α` if `f x = x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pythagorean_triple.is_classified",
    "statement": "def pythagorean_triple.is_classified {x y z : ℤ} (h : pythagorean_triple x y z) : Prop",
    "theorem": "{x y z : ℤ} (h : pythagorean_triple x y z) : Prop",
    "args": "{x y z : ℤ} (h : pythagorean_triple x y z)",
    "doc_string": " A Pythagorean triple `x, y, z` is “classified” if there exist integers `k, m, n` such that either  * `x = k * (m ^ 2 - n ^ 2)` and `y = k * (2 * m * n)`, or  * `x = k * (2 * m * n)` and `y = k * (m ^ 2 - n ^ 2)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.divisors_antidiagonal",
    "statement": "def nat.divisors_antidiagonal (n : ℕ) : finset (ℕ × ℕ)",
    "theorem": "(n : ℕ) : finset (ℕ × ℕ)",
    "args": "(n : ℕ)",
    "doc_string": "`divisors_antidiagonal n` is the `finset` of pairs `(x,y)` such that `x * y = n`.  As a special case, `divisors_antidiagonal 0 = ∅`.",
    "kind": "def",
    "type": "finset (ℕ × ℕ)"
  },
  {
    "name": "pos_submonoid",
    "statement": "def pos_submonoid (R : Type u_1) [ordered_semiring R] [nontrivial R] : submonoid R",
    "theorem": "(R : Type u_1) [ordered_semiring R] [nontrivial R] : submonoid R",
    "args": "(R : Type u_1) [ordered_semiring R] [nontrivial R]",
    "doc_string": "Submonoid of positive elements of an ordered semiring.",
    "kind": "def",
    "type": "submonoid R"
  },
  {
    "name": "has_mem.mem.out",
    "statement": "theorem has_mem.mem.out {α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x}) : p a",
    "theorem": "{α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x}) : p a",
    "args": "{α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x})",
    "doc_string": " If `h : a ∈ {x | p x}` then `h.out : p x`. These are definitionally equal, but this can nevertheless be useful for various reasons, e.g. to apply further projection notation or in an argument to `simp`.",
    "kind": "theorem",
    "type": "p a"
  },
  {
    "name": "fin.tail_update_zero",
    "statement": "theorem fin.tail_update_zero {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α 0) : fin.tail (function.update q 0 z) = fin.tail q",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α 0) : fin.tail (function.update q 0 z) = fin.tail q",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α 0)",
    "doc_string": "Updating the first element of a tuple does not change the tail.",
    "kind": "theorem",
    "type": "fin.tail (function.update q 0 z) = fin.tail q"
  },
  {
    "name": "finset.shadow_monotone",
    "statement": "theorem finset.shadow_monotone {α : Type u_1} [decidable_eq α] : monotone finset.shadow",
    "theorem": "{α : Type u_1} [decidable_eq α] : monotone finset.shadow",
    "args": "{α : Type u_1} [decidable_eq α]",
    "doc_string": "The shadow is monotone.",
    "kind": "theorem",
    "type": "monotone finset.shadow"
  },
  {
    "name": "pi.const_ring_hom_eq_algebra_map",
    "statement": "theorem pi.const_ring_hom_eq_algebra_map (R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A → R)",
    "theorem": "(R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A → R)",
    "args": "(R : Type u_1) (A : Type u_2) [comm_semiring R]",
    "doc_string": " When `R` is commutative and permits an `algebra_map`, `pi.const_ring_hom` is equal to that map.",
    "kind": "theorem",
    "type": "pi.const_ring_hom A R = algebra_map R (A → R)"
  },
  {
    "name": "set.centralizer",
    "statement": "def set.centralizer {M : Type u_1} (S : set M) [has_mul M] : set M",
    "theorem": "{M : Type u_1} (S : set M) [has_mul M] : set M",
    "args": "{M : Type u_1} (S : set M) [has_mul M]",
    "doc_string": "The centralizer of a subset of a magma.",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "list.mall",
    "statement": "def list.mall {m : Type → Type v} [monad m] {α : Type u} (p : α → m bool) (as : list α) : m bool",
    "theorem": "{m : Type → Type v} [monad m] {α : Type u} (p : α → m bool) (as : list α) : m bool",
    "args": "{m : Type → Type v} [monad m] {α : Type u} (p : α → m bool) (as : list α)",
    "doc_string": " `mall p as` returns true iff `p` returns true for all elements of `l`. `mall` short-circuits, so if `p` returns false for any element of `l`, later elements are not checked. This is a monadic version of `list.all`.",
    "kind": "def",
    "type": "m bool"
  },
  {
    "name": "ordinal.has_div",
    "statement": "def ordinal.has_div  : has_div ordinal",
    "theorem": " : has_div ordinal",
    "args": "",
    "doc_string": "`a / b` is the unique ordinal `o` satisfying `a = b * o + o'` with `o' < b`.",
    "kind": "def",
    "type": "has_div ordinal"
  },
  {
    "name": "id_groupoid",
    "statement": "def id_groupoid (H : Type u) [topological_space H] : structure_groupoid H",
    "theorem": "(H : Type u) [topological_space H] : structure_groupoid H",
    "args": "(H : Type u) [topological_space H]",
    "doc_string": " The trivial groupoid, containing only the identity (and maps with empty source, as this is necessary from the definition)",
    "kind": "def",
    "type": "structure_groupoid H"
  },
  {
    "name": "order.coframe",
    "statement": "structure order.coframe (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice whose `⊔` distributes over `⨅`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "prod.comm_semiring",
    "statement": "def prod.comm_semiring {R : Type u_1} {S : Type u_3} [comm_semiring R] [comm_semiring S] : comm_semiring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [comm_semiring R] [comm_semiring S] : comm_semiring (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [comm_semiring R] [comm_semiring S]",
    "doc_string": "Product of two commutative semirings is a commutative semiring.",
    "kind": "def",
    "type": "comm_semiring (R × S)"
  },
  {
    "name": "pnat.xgcd_type",
    "statement": "structure pnat.xgcd_type  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A term of xgcd_type is a system of six naturals.  They should be thought of as representing the matrix [[w, x], [y, z]] = [[wp + 1, x], [y, zp + 1]] together with the vector [a, b] = [ap + 1, bp + 1].",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "polynomial.nat_degree",
    "statement": "def polynomial.nat_degree {R : Type u} [semiring R] (p : polynomial R) : ℕ",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : ℕ",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": "`nat_degree p` forces `degree p` to ℕ, by defining nat_degree 0 = 0.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "multiset.choose_x",
    "statement": "def multiset.choose_x {α : Type u_1} (p : α → Prop) [decidable_pred p] (l : multiset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : {a // a ∈ l ∧ p a}",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : multiset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : {a // a ∈ l ∧ p a}",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : multiset α) (hp : ∃! (a : α), a ∈ l ∧ p a)",
    "doc_string": " Given a proof `hp` that there exists a unique `a ∈ l` such that `p a`, `choose_x p l hp` returns that `a` together with proofs of `a ∈ l` and `p a`.",
    "kind": "def",
    "type": "{a // a ∈ l ∧ p a}"
  },
  {
    "name": "add_hom.srange",
    "statement": "def add_hom.srange {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_subsemigroup N",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_subsemigroup N",
    "args": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N)",
    "doc_string": "The range of an `add_hom` is an `add_subsemigroup`.",
    "kind": "def",
    "type": "add_subsemigroup N"
  },
  {
    "name": "has_quotient",
    "statement": "structure has_quotient (A : out_param (Type u)) (B : Type v) : Type (max (u+1) (v+1))",
    "theorem": "(A : out_param (Type u)) (B : Type v) : Type (max (u+1) (v+1))",
    "args": "(A : out_param (Type u)) (B : Type v)",
    "doc_string": " `has_quotient A B` is a notation typeclass that allows us to write `A ⧸ b` for `b : B`. This allows the usual notation for quotients of algebraic structures, such as groups, modules and rings.  `A` is a parameter, despite being unused in the definition below, so it appears in the notation.",
    "kind": "structure",
    "type": "Type (max (u+1) (v+1))"
  },
  {
    "name": "algebraic_geometry.Spec.LocallyRingedSpace_obj",
    "statement": "def algebraic_geometry.Spec.LocallyRingedSpace_obj (R : CommRing) : algebraic_geometry.LocallyRingedSpace",
    "theorem": "(R : CommRing) : algebraic_geometry.LocallyRingedSpace",
    "args": "(R : CommRing)",
    "doc_string": "The spectrum of a commutative ring, as a `LocallyRingedSpace`.",
    "kind": "def",
    "type": "algebraic_geometry.LocallyRingedSpace"
  },
  {
    "name": "upgrade_polish_space",
    "statement": "def upgrade_polish_space (α : Type u_1) [ht : topological_space α] [h : polish_space α] : upgraded_polish_space α",
    "theorem": "(α : Type u_1) [ht : topological_space α] [h : polish_space α] : upgraded_polish_space α",
    "args": "(α : Type u_1) [ht : topological_space α] [h : polish_space α]",
    "doc_string": " This definition endows a Polish space with a complete metric. Use it as: `letI := upgrade_polish_space α`.",
    "kind": "def",
    "type": "upgraded_polish_space α"
  },
  {
    "name": "algebraic_closure.adjoin_monic",
    "statement": "def algebraic_closure.adjoin_monic (k : Type u) [field k] : Type u",
    "theorem": "(k : Type u) [field k] : Type u",
    "args": "(k : Type u) [field k]",
    "doc_string": "The first step of constructing `algebraic_closure`: adjoin a root of all monic polynomials",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "nat.totient_eq_mul_prod_factors",
    "statement": "theorem nat.totient_eq_mul_prod_factors (n : ℕ) : ↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)",
    "theorem": "(n : ℕ) : ↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)",
    "args": "(n : ℕ)",
    "doc_string": "Euler's product formula for the totient function.",
    "kind": "theorem",
    "type": "↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)"
  },
  {
    "name": "associates.factor_set",
    "statement": "def associates.factor_set (α : Type u) [cancel_comm_monoid_with_zero α] : Type u",
    "theorem": "(α : Type u) [cancel_comm_monoid_with_zero α] : Type u",
    "args": "(α : Type u) [cancel_comm_monoid_with_zero α]",
    "doc_string": " `factor_set α` representation elements of unique factorization domain as multisets. `multiset α` produced by `normalized_factors` are only unique up to associated elements, while the multisets in `factor_set α` are unique by equality and restricted to irreducible elements. This gives us a representation of each element as a unique multisets (or the added ⊤ for 0), which has a complete lattice struture. Infimum is the greatest common divisor and supremum is the least common multiple.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "non_assoc_ring",
    "statement": "structure non_assoc_ring (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A unital but not-necessarily-associative ring.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "is_ascending_central_series",
    "statement": "def is_ascending_central_series {G : Type u_1} [group G] (H : ℕ → subgroup G) : Prop",
    "theorem": "{G : Type u_1} [group G] (H : ℕ → subgroup G) : Prop",
    "args": "{G : Type u_1} [group G] (H : ℕ → subgroup G)",
    "doc_string": "A sequence of subgroups of `G` is an ascending central series if `H 0` is trivial and  `⁅H (n + 1), G⁆ ⊆ H n` for all `n`. Note that we do not require that `H n = G` for some `n`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordinal.deriv",
    "statement": "def ordinal.deriv (f : ordinal → ordinal) : ordinal → ordinal",
    "theorem": "(f : ordinal → ordinal) : ordinal → ordinal",
    "args": "(f : ordinal → ordinal)",
    "doc_string": "The derivative of a normal function `f` is the sequence of fixed points of `f`.",
    "kind": "def",
    "type": "ordinal → ordinal"
  },
  {
    "name": "nat.exists_strict_mono'",
    "statement": "theorem nat.exists_strict_mono' {α : Type u} [preorder α] [no_max_order α] (a : α) : ∃ (f : ℕ → α), strict_mono f ∧ f 0 = a",
    "theorem": "{α : Type u} [preorder α] [no_max_order α] (a : α) : ∃ (f : ℕ → α), strict_mono f ∧ f 0 = a",
    "args": "{α : Type u} [preorder α] [no_max_order α] (a : α)",
    "doc_string": " If `α` is a preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α` with any prescribed value of `f 0`.",
    "kind": "theorem",
    "type": "∃ (f : ℕ → α), strict_mono f ∧ f 0 = a"
  },
  {
    "name": "left_ord_continuous",
    "statement": "def left_ord_continuous {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β)",
    "doc_string": " A function `f` between preorders is left order continuous if it preserves all suprema.  We define it using `is_lub` instead of `Sup` so that the proof works both for complete lattices and conditionally complete lattices.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "sym.nil",
    "statement": "def sym.nil {α : Type u_1} : sym α 0",
    "theorem": "{α : Type u_1} : sym α 0",
    "args": "{α : Type u_1}",
    "doc_string": "The unique element in `sym α 0`.",
    "kind": "def",
    "type": "sym α 0"
  },
  {
    "name": "slim_check.small",
    "statement": "def slim_check.small (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Type tag that signals to `slim_check` to use small values for a given type.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "lie_subalgebra",
    "statement": "structure lie_subalgebra (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": " A Lie subalgebra of a Lie algebra is submodule that is closed under the Lie bracket. This is a sufficient condition for the subset itself to form a Lie algebra.",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "two_pointing.pi",
    "statement": "def two_pointing.pi (α : Type u_1) {β : Type u_2} (q : two_pointing β) [nonempty α] : two_pointing (α → β)",
    "theorem": "(α : Type u_1) {β : Type u_2} (q : two_pointing β) [nonempty α] : two_pointing (α → β)",
    "args": "(α : Type u_1) {β : Type u_2} (q : two_pointing β) [nonempty α]",
    "doc_string": "The two-pointing of constant functions.",
    "kind": "def",
    "type": "two_pointing (α → β)"
  },
  {
    "name": "has_continuous_inf",
    "statement": "structure has_continuous_inf (L : Type u_1) [topological_space L] [has_inf L] : Prop",
    "theorem": "(L : Type u_1) [topological_space L] [has_inf L] : Prop",
    "args": "(L : Type u_1) [topological_space L] [has_inf L]",
    "doc_string": "Let `L` be a topological space and let `L×L` be equipped with the product topology and let `⊓:L×L → L` be an infimum. Then `L` is said to have *(jointly) continuous infimum* if the map `⊓:L×L → L` is continuous.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "affine_basis.inhabited",
    "statement": "def affine_basis.inhabited {k : Type u₂} [ring k] : inhabited (affine_basis punit k punit)",
    "theorem": "{k : Type u₂} [ring k] : inhabited (affine_basis punit k punit)",
    "args": "{k : Type u₂} [ring k]",
    "doc_string": "The unique point in a single-point space is the simplest example of an affine basis.",
    "kind": "def",
    "type": "inhabited (affine_basis punit k punit)"
  },
  {
    "name": "matrix.pivot.list_transvec_row",
    "statement": "def matrix.pivot.list_transvec_row {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) : list (matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)",
    "theorem": "{𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) : list (matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)",
    "args": "{𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)",
    "doc_string": " A list of transvections such that multiplying on the right with these transvections will replace the last row with zeroes.",
    "kind": "def",
    "type": "list (matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)"
  },
  {
    "name": "set.mul_indicator",
    "statement": "def set.mul_indicator {α : Type u_1} {M : Type u_4} [has_one M] (s : set α) (f : α → M) : α → M",
    "theorem": "{α : Type u_1} {M : Type u_4} [has_one M] (s : set α) (f : α → M) : α → M",
    "args": "{α : Type u_1} {M : Type u_4} [has_one M] (s : set α) (f : α → M)",
    "doc_string": "`mul_indicator s f a` is `f a` if `a ∈ s`, `1` otherwise.",
    "kind": "def",
    "type": "α → M"
  },
  {
    "name": "flag",
    "statement": "structure flag (α : Type u_3) [has_le α] : Type u_3",
    "theorem": "(α : Type u_3) [has_le α] : Type u_3",
    "args": "(α : Type u_3) [has_le α]",
    "doc_string": "The type of flags, aka maximal chains, of an order.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "has_le.le.eq_of_not_lt",
    "statement": "theorem has_le.le.eq_of_not_lt {α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : a = b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : a = b",
    "args": "{α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b)",
    "doc_string": "**Alias** of eq_of_le_of_not_lt`.",
    "kind": "theorem",
    "type": "a = b"
  },
  {
    "name": "set.inj_on.injective",
    "statement": "theorem set.inj_on.injective {α : Type u} {β : Type v} {s : set α} {f : α → β} : set.inj_on f s → function.injective (s.restrict f)",
    "theorem": "{α : Type u} {β : Type v} {s : set α} {f : α → β} : set.inj_on f s → function.injective (s.restrict f)",
    "args": "{α : Type u} {β : Type v} {s : set α} {f : α → β}",
    "doc_string": "**Alias** of the forward direction of set.inj_on_iff_injective`.",
    "kind": "theorem",
    "type": "set.inj_on f s → function.injective (s.restrict f)"
  },
  {
    "name": "set_like.ext",
    "statement": "theorem set_like.ext {A : Type u_1} {B : Type u_2} [i : set_like A B] {p q : A} (h : ∀ (x : B), x ∈ p ↔ x ∈ q) : p = q",
    "theorem": "{A : Type u_1} {B : Type u_2} [i : set_like A B] {p q : A} (h : ∀ (x : B), x ∈ p ↔ x ∈ q) : p = q",
    "args": "{A : Type u_1} {B : Type u_2} [i : set_like A B] {p q : A} (h : ∀ (x : B), x ∈ p ↔ x ∈ q)",
    "doc_string": "Note: implementers of `set_like` must copy this lemma in order to tag it with `@[ext]`.",
    "kind": "theorem",
    "type": "p = q"
  },
  {
    "name": "Pointed.hom",
    "statement": "structure Pointed.hom (X Y : Pointed) : Type u",
    "theorem": "(X Y : Pointed) : Type u",
    "args": "(X Y : Pointed)",
    "doc_string": "Morphisms in `Pointed`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "lower_set.Iic_inf_hom",
    "statement": "def lower_set.Iic_inf_hom {α : Type u_1} [semilattice_inf α] : inf_hom α (lower_set α)",
    "theorem": "{α : Type u_1} [semilattice_inf α] : inf_hom α (lower_set α)",
    "args": "{α : Type u_1} [semilattice_inf α]",
    "doc_string": "`lower_set.Iic` as an `inf_hom`.",
    "kind": "def",
    "type": "inf_hom α (lower_set α)"
  },
  {
    "name": "Bipointed.of",
    "statement": "def Bipointed.of {X : Type u_1} (to_prod : X × X) : Bipointed",
    "theorem": "{X : Type u_1} (to_prod : X × X) : Bipointed",
    "args": "{X : Type u_1} (to_prod : X × X)",
    "doc_string": "Turns a bipointing into a bipointed type.",
    "kind": "def",
    "type": "Bipointed"
  },
  {
    "name": "universal_enveloping_algebra",
    "statement": "def universal_enveloping_algebra (R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max u₁ u₂)",
    "theorem": "(R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max u₁ u₂)",
    "args": "(R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": "The universal enveloping algebra of a Lie algebra.",
    "kind": "def",
    "type": "Type (max u₁ u₂)"
  },
  {
    "name": "lattice.imp",
    "statement": "def lattice.imp {α : Type u_1} [has_compl α] [has_sup α] (a b : α) : α",
    "theorem": "{α : Type u_1} [has_compl α] [has_sup α] (a b : α) : α",
    "args": "{α : Type u_1} [has_compl α] [has_sup α] (a b : α)",
    "doc_string": "Implication as a binary operation on a boolean algebra.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "nonote.has_sub",
    "statement": "def nonote.has_sub  : has_sub nonote",
    "theorem": " : has_sub nonote",
    "args": "",
    "doc_string": "Subtraction of ordinal notations",
    "kind": "def",
    "type": "has_sub nonote"
  },
  {
    "name": "gaussian_int",
    "statement": "def gaussian_int  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The Gaussian integers, defined as `ℤ√(-1)`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "omega.coeffs.val_except",
    "statement": "def omega.coeffs.val_except (k : ℕ) (v : ℕ → ℤ) (as : list ℤ) : ℤ",
    "theorem": "(k : ℕ) (v : ℕ → ℤ) (as : list ℤ) : ℤ",
    "args": "(k : ℕ) (v : ℕ → ℤ) (as : list ℤ)",
    "doc_string": "`val_except k v as` is the value (under valuation `v`) of the term    obtained taking the term represented by `(0, as)` and dropping the    subterm that includes the `k`th variable.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "denumerable.lower",
    "statement": "def denumerable.lower  : list ℕ → ℕ → list ℕ",
    "theorem": " : list ℕ → ℕ → list ℕ",
    "args": "",
    "doc_string": " Outputs the list of differences of the input list, that is `lower [a₁, a₂, ...] n = [a₁ - n, a₂ - a₁, ...]`",
    "kind": "def",
    "type": "list ℕ → ℕ → list ℕ"
  },
  {
    "name": "affine.simplex.mk_of_point",
    "statement": "def affine.simplex.mk_of_point (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : affine.simplex k P 0",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : affine.simplex k P 0",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P)",
    "doc_string": "Construct a 0-simplex from a point.",
    "kind": "def",
    "type": "affine.simplex k P 0"
  },
  {
    "name": "padic_seq",
    "statement": "def padic_seq (p : ℕ) : Type",
    "theorem": "(p : ℕ) : Type",
    "args": "(p : ℕ)",
    "doc_string": "The type of Cauchy sequences of rationals with respect to the p-adic norm.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "Class.mem",
    "statement": "def Class.mem (A B : Class) : Prop",
    "theorem": "(A B : Class) : Prop",
    "args": "(A B : Class)",
    "doc_string": "`A ∈ B` if `A` is a ZFC set which is a member of `B`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "free_algebra.ι",
    "statement": "def free_algebra.ι (R : Type u_1) [comm_semiring R] {X : Type u_2} : X → free_algebra R X",
    "theorem": "(R : Type u_1) [comm_semiring R] {X : Type u_2} : X → free_algebra R X",
    "args": "(R : Type u_1) [comm_semiring R] {X : Type u_2}",
    "doc_string": "The canonical function `X → free_algebra R X`.",
    "kind": "def",
    "type": "X → free_algebra R X"
  },
  {
    "name": "stream",
    "statement": "def stream (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A stream `stream α` is an infinite sequence of elements of `α`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "W_type.depth",
    "statement": "def W_type.depth {α : Type u_1} {β : α → Type u_2} [Π (a : α), fintype (β a)] : W_type β → ℕ",
    "theorem": "{α : Type u_1} {β : α → Type u_2} [Π (a : α), fintype (β a)] : W_type β → ℕ",
    "args": "{α : Type u_1} {β : α → Type u_2} [Π (a : α), fintype (β a)]",
    "doc_string": "The depth of a finitely branching tree.",
    "kind": "def",
    "type": "W_type β → ℕ"
  },
  {
    "name": "filter.map₂",
    "statement": "def filter.map₂ {α : Type u_1} {β : Type u_3} {γ : Type u_5} (m : α → β → γ) (f : filter α) (g : filter β) : filter γ",
    "theorem": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} (m : α → β → γ) (f : filter α) (g : filter β) : filter γ",
    "args": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} (m : α → β → γ) (f : filter α) (g : filter β)",
    "doc_string": " The image of a binary function `m : α → β → γ` as a function `filter α → filter β → filter γ`. Mathematically this should be thought of as the image of the corresponding function `α × β → γ`.",
    "kind": "def",
    "type": "filter γ"
  },
  {
    "name": "field_of_is_unit_or_eq_zero",
    "statement": "def field_of_is_unit_or_eq_zero {R : Type u_1} [nontrivial R] [hR : comm_ring R] (h : ∀ (a : R), is_unit a ∨ a = 0) : field R",
    "theorem": "{R : Type u_1} [nontrivial R] [hR : comm_ring R] (h : ∀ (a : R), is_unit a ∨ a = 0) : field R",
    "args": "{R : Type u_1} [nontrivial R] [hR : comm_ring R] (h : ∀ (a : R), is_unit a ∨ a = 0)",
    "doc_string": " Constructs a `field` structure on a `comm_ring` consisting only of units and 0. See note [reducible non-instances].",
    "kind": "def",
    "type": "field R"
  },
  {
    "name": "unique",
    "statement": "structure unique (α : Sort u) : Sort (max 1 u)",
    "theorem": "(α : Sort u) : Sort (max 1 u)",
    "args": "(α : Sort u)",
    "doc_string": " `unique α` expresses that `α` is a type with a unique term `default`.  This is implemented as a type, rather than a `Prop`-valued predicate, for good definitional properties of the default term.",
    "kind": "structure",
    "type": "Sort (max 1 u)"
  },
  {
    "name": "monoid_hom",
    "statement": "structure monoid_hom (M : Type u_9) (N : Type u_10) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_9)",
    "theorem": "(M : Type u_9) (N : Type u_10) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_9)",
    "args": "(M : Type u_9) (N : Type u_10) [mul_one_class M] [mul_one_class N]",
    "doc_string": " `M →* N` is the type of functions `M → N` that preserve the `monoid` structure. `monoid_hom` is also used for group homomorphisms.  When possible, instead of parametrizing results over `(f : M →+ N)`, you should parametrize over `(F : Type*) [monoid_hom_class F M N] (f : F)`.  When you extend this structure, make sure to extend `monoid_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_10 u_9)"
  },
  {
    "name": "mvpfunctor.Wp",
    "statement": "def mvpfunctor.Wp {n : ℕ} (P : mvpfunctor (n + 1)) : mvpfunctor n",
    "theorem": "{n : ℕ} (P : mvpfunctor (n + 1)) : mvpfunctor n",
    "args": "{n : ℕ} (P : mvpfunctor (n + 1))",
    "doc_string": " Polynomial functor for the W-type of `P`. `A` is a data-less well-founded tree whereas, for a given `a : A`, `B a` is a valid path in tree `a` so that `Wp.obj α` is made of a tree and a function from its valid paths to the values it contains",
    "kind": "def",
    "type": "mvpfunctor n"
  },
  {
    "name": "Ring",
    "statement": "def Ring  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of rings.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "tactic.eliminate.constructor_argument_naming_info",
    "statement": "structure tactic.eliminate.constructor_argument_naming_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Information used when naming a constructor argument.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "is_locally_constant",
    "statement": "def is_locally_constant {X : Type u_1} {Y : Type u_2} [topological_space X] (f : X → Y) : Prop",
    "theorem": "{X : Type u_1} {Y : Type u_2} [topological_space X] (f : X → Y) : Prop",
    "args": "{X : Type u_1} {Y : Type u_2} [topological_space X] (f : X → Y)",
    "doc_string": "A function between topological spaces is locally constant if the preimage of any set is open.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.add_zero_class",
    "statement": "def finset.add_zero_class {α : Type u_2} [decidable_eq α] [add_zero_class α] : add_zero_class (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [add_zero_class α] : add_zero_class (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [add_zero_class α]",
    "doc_string": "`finset α` is an `add_zero_class` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_zero_class (finset α)"
  },
  {
    "name": "nat.dvd_add_self_left",
    "statement": "theorem nat.dvd_add_self_left {m n : ℕ} : m ∣ m + n ↔ m ∣ n",
    "theorem": "{m n : ℕ} : m ∣ m + n ↔ m ∣ n",
    "args": "{m n : ℕ}",
    "doc_string": "A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.",
    "kind": "theorem",
    "type": "m ∣ m + n ↔ m ∣ n"
  },
  {
    "name": "list.concat",
    "statement": "def list.concat {α : Type u_1} : list α → α → list α",
    "theorem": "{α : Type u_1} : list α → α → list α",
    "args": "{α : Type u_1}",
    "doc_string": "Concatenate an element at the end of a list.      concat [a, b] c = [a, b, c]",
    "kind": "def",
    "type": "list α → α → list α"
  },
  {
    "name": "SemilatticeSup",
    "statement": "structure SemilatticeSup  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of sup-semilattices with a bottom element.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "valuation.valuation_subring",
    "statement": "def valuation.valuation_subring {K : Type u_1} [field K] {Γ : Type u_2} [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) : valuation_subring K",
    "theorem": "{K : Type u_1} [field K] {Γ : Type u_2} [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) : valuation_subring K",
    "args": "{K : Type u_1} [field K] {Γ : Type u_2} [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ)",
    "doc_string": "The valuation subring associated to a valuation.",
    "kind": "def",
    "type": "valuation_subring K"
  },
  {
    "name": "wseq.destruct",
    "statement": "def wseq.destruct {α : Type u} : wseq α → computation (option (α × wseq α))",
    "theorem": "{α : Type u} : wseq α → computation (option (α × wseq α))",
    "args": "{α : Type u}",
    "doc_string": "Destruct a weak sequence, to (eventually possibly) produce either  `none` for `nil` or `some (a, s)` if an element is produced.",
    "kind": "def",
    "type": "wseq α → computation (option (α × wseq α))"
  },
  {
    "name": "quotient_group.right_rel",
    "statement": "def quotient_group.right_rel {α : Type u_1} [group α] (s : subgroup α) : setoid α",
    "theorem": "{α : Type u_1} [group α] (s : subgroup α) : setoid α",
    "args": "{α : Type u_1} [group α] (s : subgroup α)",
    "doc_string": " The equivalence relation corresponding to the partition of a group by right cosets of a subgroup.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "ratfunc.X",
    "statement": "def ratfunc.X {K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K] [hdomain : is_domain K]",
    "doc_string": "`ratfunc.X` is the polynomial variable (aka indeterminate).",
    "kind": "def",
    "type": "ratfunc K"
  },
  {
    "name": "is_left_regular_of_mul_eq_one",
    "statement": "theorem is_left_regular_of_mul_eq_one {R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a",
    "theorem": "{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a",
    "args": "{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1)",
    "doc_string": "An element admitting a left inverse is left-regular.",
    "kind": "theorem",
    "type": "is_left_regular a"
  },
  {
    "name": "tactic.equiv_rw_cfg",
    "statement": "structure tactic.equiv_rw_cfg  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration structure for `equiv_rw`.  * `max_depth` bounds the search depth for equivalences to rewrite along.   The default value is 10.   (e.g., if you're rewriting along `e : α ≃ β`, and `max_depth := 2`,   you can rewrite `option (option α))` but not `option (option (option α))`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "fin_enum",
    "statement": "structure fin_enum (α : Sort u_1) : Sort (max 1 (imax 1 u_1) u_1)",
    "theorem": "(α : Sort u_1) : Sort (max 1 (imax 1 u_1) u_1)",
    "args": "(α : Sort u_1)",
    "doc_string": "`fin_enum α` means that `α` is finite and can be enumerated in some order,  i.e. `α` has an explicit bijection with `fin n` for some n.",
    "kind": "structure",
    "type": "Sort (max 1 (imax 1 u_1) u_1)"
  },
  {
    "name": "module.oriented",
    "statement": "structure module.oriented (R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (ι : Type u_4) [decidable_eq ι] : Type (max u_1 u_2 u_4)",
    "theorem": "(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (ι : Type u_4) [decidable_eq ι] : Type (max u_1 u_2 u_4)",
    "args": "(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (ι : Type u_4) [decidable_eq ι]",
    "doc_string": "A type class fixing an orientation of a module.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_4)"
  },
  {
    "name": "zmod.wilsons_lemma",
    "statement": "theorem zmod.wilsons_lemma (p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1",
    "args": "(p : ℕ) [fact (nat.prime p)]",
    "doc_string": "**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`.",
    "kind": "theorem",
    "type": "↑((p - 1).factorial) = -1"
  },
  {
    "name": "has_lipschitz_add",
    "statement": "structure has_lipschitz_add (β : Type u_2) [pseudo_metric_space β] [add_monoid β] : Prop",
    "theorem": "(β : Type u_2) [pseudo_metric_space β] [add_monoid β] : Prop",
    "args": "(β : Type u_2) [pseudo_metric_space β] [add_monoid β]",
    "doc_string": " Class `has_lipschitz_add M` says that the addition `(+) : X × X → X` is Lipschitz jointly in the two arguments.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "fin.add_comm_group",
    "statement": "def fin.add_comm_group (n : ℕ) : add_comm_group (fin (n + 1))",
    "theorem": "(n : ℕ) : add_comm_group (fin (n + 1))",
    "args": "(n : ℕ)",
    "doc_string": "Abelian group structure on `fin (n+1)`.",
    "kind": "def",
    "type": "add_comm_group (fin (n + 1))"
  },
  {
    "name": "filter.tendsto_mul_right_cobounded",
    "statement": "theorem filter.tendsto_mul_right_cobounded {α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (λ (x : α), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "theorem": "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (λ (x : α), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)",
    "args": "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0)",
    "doc_string": " Multiplication on the right by a nonzero element of a normed division ring tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (x : α), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"
  },
  {
    "name": "is_unit.is_regular",
    "statement": "theorem is_unit.is_regular {R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a",
    "theorem": "{R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a",
    "args": "{R : Type u_1} {a : R} [monoid R] (ua : is_unit a)",
    "doc_string": "A unit in a monoid is regular.",
    "kind": "theorem",
    "type": "is_regular a"
  },
  {
    "name": "int.succ",
    "statement": "def int.succ (a : ℤ) : ℤ",
    "theorem": "(a : ℤ) : ℤ",
    "args": "(a : ℤ)",
    "doc_string": "Immediate successor of an integer: `succ n = n + 1`",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "bitvec.carry",
    "statement": "def bitvec.carry (x y c : bool) : bool",
    "theorem": "(x y c : bool) : bool",
    "args": "(x y c : bool)",
    "doc_string": "`carry x y c` is `x && y || x && c || y && c`.",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "is_absolute_value.to_absolute_value",
    "statement": "def is_absolute_value.to_absolute_value {S : Type u_1} [ordered_semiring S] {R : Type u_2} [semiring R] (abv : R → S) [is_absolute_value abv] : absolute_value R S",
    "theorem": "{S : Type u_1} [ordered_semiring S] {R : Type u_2} [semiring R] (abv : R → S) [is_absolute_value abv] : absolute_value R S",
    "args": "{S : Type u_1} [ordered_semiring S] {R : Type u_2} [semiring R] (abv : R → S) [is_absolute_value abv]",
    "doc_string": "Convert an unbundled `is_absolute_value` to a bundled `absolute_value`.",
    "kind": "def",
    "type": "absolute_value R S"
  },
  {
    "name": "inducing.pseudo_metrizable_space",
    "statement": "theorem inducing.pseudo_metrizable_space {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X",
    "theorem": "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X",
    "args": "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f)",
    "doc_string": " Given an inducing map of a topological space into a pseudo metrizable space, the source space is also pseudo metrizable.",
    "kind": "theorem",
    "type": "topological_space.pseudo_metrizable_space X"
  },
  {
    "name": "normed_linear_ordered_field",
    "statement": "structure normed_linear_ordered_field (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A `normed_linear_ordered_field` is a field that is both a `normed_field` and a    `linear_ordered_field`. This class is necessary to avoid diamonds.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "category_theory.limits.types.terminal_limit_cone",
    "statement": "def category_theory.limits.types.terminal_limit_cone  : category_theory.limits.limit_cone (category_theory.functor.empty (Type u))",
    "theorem": " : category_theory.limits.limit_cone (category_theory.functor.empty (Type u))",
    "args": "",
    "doc_string": "The category of types has `punit` as a terminal object.",
    "kind": "def",
    "type": "category_theory.limits.limit_cone (category_theory.functor.empty (Type u))"
  },
  {
    "name": "emetric.diam",
    "statement": "def emetric.diam {α : Type u} [pseudo_emetric_space α] (s : set α) : ennreal",
    "theorem": "{α : Type u} [pseudo_emetric_space α] (s : set α) : ennreal",
    "args": "{α : Type u} [pseudo_emetric_space α] (s : set α)",
    "doc_string": "The diameter of a set in a pseudoemetric space, named `emetric.diam`",
    "kind": "def",
    "type": "ennreal"
  },
  {
    "name": "equiv.neg",
    "statement": "def equiv.neg (G : Type u_10) [has_involutive_neg G] : equiv.perm G",
    "theorem": "(G : Type u_10) [has_involutive_neg G] : equiv.perm G",
    "args": "(G : Type u_10) [has_involutive_neg G]",
    "doc_string": "Negation on an `add_group` is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm G"
  },
  {
    "name": "rack.pre_envel_group_rel'",
    "statement": "inductive rack.pre_envel_group_rel' (R : Type u) [rack R] : rack.pre_envel_group R → rack.pre_envel_group R → Type u",
    "theorem": "(R : Type u) [rack R] : rack.pre_envel_group R → rack.pre_envel_group R → Type u",
    "args": "(R : Type u) [rack R]",
    "doc_string": "Relations for the enveloping group. This is a type-valued relation because `to_envel_group.map_aux.well_def` inducts on it to show `to_envel_group.map` is well-defined.  The relation `pre_envel_group_rel` is the `Prop`-valued version, which is used to define `envel_group` itself.",
    "kind": "inductive",
    "type": "rack.pre_envel_group R → rack.pre_envel_group R → Type u"
  },
  {
    "name": "algebraic_geometry.LocallyRingedSpace.to_Top",
    "statement": "def algebraic_geometry.LocallyRingedSpace.to_Top (X : algebraic_geometry.LocallyRingedSpace) : Top",
    "theorem": "(X : algebraic_geometry.LocallyRingedSpace) : Top",
    "args": "(X : algebraic_geometry.LocallyRingedSpace)",
    "doc_string": "The underlying topological space of a locally ringed space.",
    "kind": "def",
    "type": "Top"
  },
  {
    "name": "snum.not",
    "statement": "def snum.not  : snum → snum",
    "theorem": " : snum → snum",
    "args": "",
    "doc_string": "Bitwise `not` for `snum`.",
    "kind": "def",
    "type": "snum → snum"
  },
  {
    "name": "fin_enum.of_injective",
    "statement": "def fin_enum.of_injective {α : Type u_1} {β : Type u_2} (f : α → β) [decidable_eq α] [fin_enum β] (h : function.injective f) : fin_enum α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) [decidable_eq α] [fin_enum β] (h : function.injective f) : fin_enum α",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) [decidable_eq α] [fin_enum β] (h : function.injective f)",
    "doc_string": "create a `fin_enum` instance using an injection",
    "kind": "def",
    "type": "fin_enum α"
  },
  {
    "name": "first_order.language",
    "statement": "structure first_order.language  : Type (max (u+1) (v+1))",
    "theorem": " : Type (max (u+1) (v+1))",
    "args": "",
    "doc_string": "A first-order language consists of a type of functions of every natural-number arity and a  type of relations of every natural-number arity.",
    "kind": "structure",
    "type": "Type (max (u+1) (v+1))"
  },
  {
    "name": "order_ring_iso_class",
    "statement": "structure order_ring_iso_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_mul α] [has_add α] [has_le α] [has_mul β] [has_add β] [has_le β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_mul α] [has_add α] [has_le α] [has_mul β] [has_add β] [has_le β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_mul α] [has_add α] [has_le α] [has_mul β] [has_add β] [has_le β]",
    "doc_string": " `order_ring_iso_class F α β` states that `F` is a type of ordered semiring isomorphisms. You should extend this class when you extend `order_ring_iso`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "is_torsion.not_torsion_free",
    "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G",
    "theorem": "{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G",
    "args": "{G : Type u_1} [group G] [hN : nontrivial G]",
    "doc_string": "A nontrivial torsion group is not torsion-free.",
    "kind": "theorem",
    "type": "monoid.is_torsion G → ¬monoid.is_torsion_free G"
  },
  {
    "name": "lie_algebra.orthogonal.indefinite_diagonal",
    "statement": "def lie_algebra.orthogonal.indefinite_diagonal (p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] : matrix (p ⊕ q) (p ⊕ q) R",
    "theorem": "(p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] : matrix (p ⊕ q) (p ⊕ q) R",
    "args": "(p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R]",
    "doc_string": "The indefinite diagonal matrix with `p` 1s and `q` -1s.",
    "kind": "def",
    "type": "matrix (p ⊕ q) (p ⊕ q) R"
  },
  {
    "name": "sym2.map_id'",
    "statement": "theorem sym2.map_id' {α : Type u_1} : sym2.map (λ (x : α), x) = id",
    "theorem": "{α : Type u_1} : sym2.map (λ (x : α), x) = id",
    "args": "{α : Type u_1}",
    "doc_string": "Note: `sym2.map_id` will not simplify `sym2.map id z` due to `sym2.map_congr`.",
    "kind": "theorem",
    "type": "sym2.map (λ (x : α), x) = id"
  },
  {
    "name": "quiver.arborescence",
    "statement": "structure quiver.arborescence (V : Type u) [quiver V] : Type (max u v)",
    "theorem": "(V : Type u) [quiver V] : Type (max u v)",
    "args": "(V : Type u) [quiver V]",
    "doc_string": "A quiver is an arborescence when there is a unique path from the default vertex    to every other vertex.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "nat.partrec.code.encode_code",
    "statement": "def nat.partrec.code.encode_code  : nat.partrec.code → ℕ",
    "theorem": " : nat.partrec.code → ℕ",
    "args": "",
    "doc_string": "An encoding of a `nat.partrec.code` as a ℕ.",
    "kind": "def",
    "type": "nat.partrec.code → ℕ"
  },
  {
    "name": "top_hom_class",
    "statement": "structure top_hom_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_top α] [has_top β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_top α] [has_top β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_top α] [has_top β]",
    "doc_string": " `top_hom_class F α β` states that `F` is a type of `⊤`-preserving morphisms.  You should extend this class when you extend `top_hom`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "coe_to_lift",
    "statement": "def coe_to_lift {a : Sort u} {b : Sort v} [has_coe_t a b] : has_lift_t a b",
    "theorem": "{a : Sort u} {b : Sort v} [has_coe_t a b] : has_lift_t a b",
    "args": "{a : Sort u} {b : Sort v} [has_coe_t a b]",
    "doc_string": "Every coercion is also a lift",
    "kind": "def",
    "type": "has_lift_t a b"
  },
  {
    "name": "measure_theory.analytic_set",
    "statement": "def measure_theory.analytic_set {α : Type u_1} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u_1} [topological_space α] (s : set α)",
    "doc_string": " An analytic set is a set which is the continuous image of some Polish space. There are several equivalent characterizations of this definition. For the definition, we pick one that avoids universe issues: a set is analytic if and only if it is a continuous image of `ℕ → ℕ` (or if it is empty). The above more usual characterization is given in `analytic_set_iff_exists_polish_space_range`.  Warning: these are analytic sets in the context of descriptive set theory (which is why they are registered in the namespace `measure_theory`). They have nothing to do with analytic sets in the context of complex analysis.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_left_regular_zero_iff_subsingleton",
    "statement": "theorem is_left_regular_zero_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_left_regular 0 ↔ subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : is_left_regular 0 ↔ subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "The element `0` is left-regular if and only if `R` is trivial.",
    "kind": "theorem",
    "type": "is_left_regular 0 ↔ subsingleton R"
  },
  {
    "name": "finset.has_npow",
    "statement": "def finset.has_npow {α : Type u_2} [decidable_eq α] [has_one α] [has_mul α] : has_pow (finset α) ℕ",
    "theorem": "{α : Type u_2} [decidable_eq α] [has_one α] [has_mul α] : has_pow (finset α) ℕ",
    "args": "{α : Type u_2} [decidable_eq α] [has_one α] [has_mul α]",
    "doc_string": " Repeated pointwise multiplication (not the same as pointwise repeated multiplication!) of a `finset`. See note [pointwise nat action].",
    "kind": "def",
    "type": "has_pow (finset α) ℕ"
  },
  {
    "name": "colex.singleton_le_iff_le",
    "statement": "theorem colex.singleton_le_iff_le {α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex ≤ {s}.to_colex ↔ r ≤ s",
    "theorem": "{α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex ≤ {s}.to_colex ↔ r ≤ s",
    "args": "{α : Type u_1} [linear_order α] {r s : α}",
    "doc_string": "Colex is an extension of the base ordering on α.",
    "kind": "theorem",
    "type": "{r}.to_colex ≤ {s}.to_colex ↔ r ≤ s"
  },
  {
    "name": "topological_ring",
    "statement": "structure topological_ring (α : Type u_1) [topological_space α] [non_unital_non_assoc_ring α] : Prop",
    "theorem": "(α : Type u_1) [topological_space α] [non_unital_non_assoc_ring α] : Prop",
    "args": "(α : Type u_1) [topological_space α] [non_unital_non_assoc_ring α]",
    "doc_string": " A topological ring is a ring `R` where addition, multiplication and negation are continuous.  If `R` is a (unital) ring, then continuity of negation can be derived from continuity of multiplication as it is multiplication with `-1`. (See `topological_semiring.has_continuous_neg_of_mul` and `topological_semiring.to_topological_add_group`)",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_add_group_hom.map_neg",
    "statement": "theorem is_add_group_hom.map_neg {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α) : f (-a) = -f a",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α) : f (-a) = -f a",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α)",
    "doc_string": "An additive group homomorphism sends negations to negations.",
    "kind": "theorem",
    "type": "f (-a) = -f a"
  },
  {
    "name": "doset.quotient",
    "statement": "def doset.quotient {G : Type u_1} [group G] (H K : set G) : Type u_1",
    "theorem": "{G : Type u_1} [group G] (H K : set G) : Type u_1",
    "args": "{G : Type u_1} [group G] (H K : set G)",
    "doc_string": "Quotient of `G` by the double coset relation, i.e. `H \\ G / K`",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "non_unital_semi_normed_ring",
    "statement": "structure non_unital_semi_normed_ring (α : Type u_5) : Type u_5",
    "theorem": "(α : Type u_5) : Type u_5",
    "args": "(α : Type u_5)",
    "doc_string": " A non-unital seminormed ring is a not-necessarily-unital ring endowed with a seminorm which satisfies the inequality `∥x y∥ ≤ ∥x∥ ∥y∥`.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "part.eta",
    "statement": "theorem part.eta {α : Type u_1} (o : part α) : {dom := o.dom, get := λ (h : o.dom), o.get h} = o",
    "theorem": "{α : Type u_1} (o : part α) : {dom := o.dom, get := λ (h : o.dom), o.get h} = o",
    "args": "{α : Type u_1} (o : part α)",
    "doc_string": "`part` eta expansion",
    "kind": "theorem",
    "type": "{dom := o.dom, get := λ (h : o.dom), o.get h} = o"
  },
  {
    "name": "lower_set",
    "statement": "structure lower_set (α : Type u_4) [has_le α] : Type u_4",
    "theorem": "(α : Type u_4) [has_le α] : Type u_4",
    "args": "(α : Type u_4) [has_le α]",
    "doc_string": "The type of lower sets of an order.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "function.bijective",
    "statement": "def function.bijective {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "theorem": "{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "args": "{α : Sort u₁} {β : Sort u₂} (f : α → β)",
    "doc_string": "A function is called bijective if it is both injective and surjective.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "free_lie_algebra",
    "statement": "def free_lie_algebra (R : Type u) (X : Type v) [comm_ring R] : Type (max u v)",
    "theorem": "(R : Type u) (X : Type v) [comm_ring R] : Type (max u v)",
    "args": "(R : Type u) (X : Type v) [comm_ring R]",
    "doc_string": "The free Lie algebra on the type `X` with coefficients in the commutative ring `R`.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "non_unital_normed_ring",
    "statement": "structure non_unital_normed_ring (α : Type u_5) : Type u_5",
    "theorem": "(α : Type u_5) : Type u_5",
    "args": "(α : Type u_5)",
    "doc_string": " A non-unital normed ring is a not-necessarily-unital ring endowed with a norm which satisfies the inequality `∥x y∥ ≤ ∥x∥ ∥y∥`.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "linarith.ineq",
    "statement": "inductive linarith.ineq  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The three-element type `ineq` is used to represent the strength of a comparison between terms.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "subring",
    "statement": "structure subring (R : Type u) [ring R] : Type u",
    "theorem": "(R : Type u) [ring R] : Type u",
    "args": "(R : Type u) [ring R]",
    "doc_string": "`subring R` is the type of subrings of `R`. A subring of `R` is a subset `s` that is a  multiplicative submonoid and an additive subgroup. Note in particular that it shares the  same 0 and 1 as R.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "ring_topology.coinduced",
    "statement": "def ring_topology.coinduced {α : Type u_1} {β : Type u_2} [t : topological_space α] [ring β] (f : α → β) : ring_topology β",
    "theorem": "{α : Type u_1} {β : Type u_2} [t : topological_space α] [ring β] (f : α → β) : ring_topology β",
    "args": "{α : Type u_1} {β : Type u_2} [t : topological_space α] [ring β] (f : α → β)",
    "doc_string": "  Given `f : α → β` and a topology on `α`, the coinduced ring topology on `β` is the finest topology such that `f` is continuous and `β` is a topological ring.",
    "kind": "def",
    "type": "ring_topology β"
  },
  {
    "name": "add_submonoid.multiples",
    "statement": "def add_submonoid.multiples {A : Type u_2} [add_monoid A] (x : A) : add_submonoid A",
    "theorem": "{A : Type u_2} [add_monoid A] (x : A) : add_submonoid A",
    "args": "{A : Type u_2} [add_monoid A] (x : A)",
    "doc_string": "The additive submonoid generated by an element.",
    "kind": "def",
    "type": "add_submonoid A"
  },
  {
    "name": "order.pfilter.is_prime",
    "statement": "structure order.pfilter.is_prime {P : Type u_1} [preorder P] (F : order.pfilter P) : Prop",
    "theorem": "{P : Type u_1} [preorder P] (F : order.pfilter P) : Prop",
    "args": "{P : Type u_1} [preorder P] (F : order.pfilter P)",
    "doc_string": "A filter `F` is prime if its complement is an ideal.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "AddCommGroup",
    "statement": "def AddCommGroup  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of additive commutative groups and group morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "group.nilpotency_class",
    "statement": "def group.nilpotency_class (G : Type u_1) [group G] [hG : group.is_nilpotent G] : ℕ",
    "theorem": "(G : Type u_1) [group G] [hG : group.is_nilpotent G] : ℕ",
    "args": "(G : Type u_1) [group G] [hG : group.is_nilpotent G]",
    "doc_string": " The nilpotency class of a nilpotent group is the smallest natural `n` such that the `n`'th term of the upper central series is `G`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "add_tsub_le_left",
    "statement": "theorem add_tsub_le_left {α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - a ≤ b",
    "theorem": "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - a ≤ b",
    "args": "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α}",
    "doc_string": "See `add_tsub_cancel_left` for the equality if `contravariant_class α α (+) (≤)`.",
    "kind": "theorem",
    "type": "a + b - a ≤ b"
  },
  {
    "name": "left.one_lt_inv_iff",
    "statement": "theorem left.one_lt_inv_iff {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "kind": "theorem",
    "type": "1 < a⁻¹ ↔ a < 1"
  },
  {
    "name": "bitvec.xor",
    "statement": "def bitvec.xor {n : ℕ} : bitvec n → bitvec n → bitvec n",
    "theorem": "{n : ℕ} : bitvec n → bitvec n → bitvec n",
    "args": "{n : ℕ}",
    "doc_string": "bitwise xor",
    "kind": "def",
    "type": "bitvec n → bitvec n → bitvec n"
  },
  {
    "name": "parser.foldl",
    "statement": "def parser.foldl {α β : Type} (f : α → β → α) (a : α) (p : parser β) : parser α",
    "theorem": "{α β : Type} (f : α → β → α) (a : α) (p : parser β) : parser α",
    "args": "{α β : Type} (f : α → β → α) (a : α) (p : parser β)",
    "doc_string": "Matches zero or more occurrences of `p`, and folds the result.",
    "kind": "def",
    "type": "parser α"
  },
  {
    "name": "multiset.disj_sum",
    "statement": "def multiset.disj_sum {α : Type u_1} {β : Type u_2} (s : multiset α) (t : multiset β) : multiset (α ⊕ β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (s : multiset α) (t : multiset β) : multiset (α ⊕ β)",
    "args": "{α : Type u_1} {β : Type u_2} (s : multiset α) (t : multiset β)",
    "doc_string": "Disjoint sum of multisets.",
    "kind": "def",
    "type": "multiset (α ⊕ β)"
  },
  {
    "name": "homological_complex.X_next",
    "statement": "def homological_complex.X_next {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (i : ι) : V",
    "theorem": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (i : ι) : V",
    "args": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (i : ι)",
    "doc_string": "Either `C.X j`, if there is some `j` with `c.rel i j`, or the zero object.",
    "kind": "def",
    "type": "V"
  },
  {
    "name": "localization_finite",
    "statement": "theorem localization_finite  : ring_hom.localization_preserves ring_hom.finite",
    "theorem": " : ring_hom.localization_preserves ring_hom.finite",
    "args": "",
    "doc_string": "If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra.",
    "kind": "theorem",
    "type": "ring_hom.localization_preserves ring_hom.finite"
  },
  {
    "name": "CpltSepUniformSpace.concrete_category",
    "statement": "def CpltSepUniformSpace.concrete_category  : category_theory.concrete_category CpltSepUniformSpace",
    "theorem": " : category_theory.concrete_category CpltSepUniformSpace",
    "args": "",
    "doc_string": "The concrete category instance on `CpltSepUniformSpace`.",
    "kind": "def",
    "type": "category_theory.concrete_category CpltSepUniformSpace"
  },
  {
    "name": "order.ideal.principal",
    "statement": "def order.ideal.principal {P : Type u_1} [preorder P] (p : P) : order.ideal P",
    "theorem": "{P : Type u_1} [preorder P] (p : P) : order.ideal P",
    "args": "{P : Type u_1} [preorder P] (p : P)",
    "doc_string": "The smallest ideal containing a given element.",
    "kind": "def",
    "type": "order.ideal P"
  },
  {
    "name": "norm_num.match_numeral_result",
    "statement": "inductive norm_num.match_numeral_result  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The result type of `match_numeral`, either `0`, `1`, or a top level decomposition of `bit0 e` or `bit1 e`. The `other` case means it is not a numeral.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "free_group.reduce.rev",
    "statement": "theorem free_group.reduce.rev {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.red L₂ (free_group.reduce L₁)",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.red L₂ (free_group.reduce L₁)",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂)",
    "doc_string": " If words `w₁ w₂` are such that `w₁` reduces to `w₂`, then `w₂` reduces to the maximal reduction of `w₁`.",
    "kind": "theorem",
    "type": "free_group.red L₂ (free_group.reduce L₁)"
  },
  {
    "name": "is_add_subgroup.add_normalizer",
    "statement": "def is_add_subgroup.add_normalizer {G : Type u_1} [add_group G] (s : set G) : set G",
    "theorem": "{G : Type u_1} [add_group G] (s : set G) : set G",
    "args": "{G : Type u_1} [add_group G] (s : set G)",
    "doc_string": "The underlying set of the normalizer of a subset `S : set A` of an   additive group `A`. That is, the elements `a : A` such that `a + S - a = S`.",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "lattice_hom.to_inf_hom",
    "statement": "def lattice_hom.to_inf_hom {α : Type u_3} {β : Type u_4} [lattice α] [lattice β] (f : lattice_hom α β) : inf_hom α β",
    "theorem": "{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] (f : lattice_hom α β) : inf_hom α β",
    "args": "{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] (f : lattice_hom α β)",
    "doc_string": "Reinterpret a `lattice_hom` as an `inf_hom`.",
    "kind": "def",
    "type": "inf_hom α β"
  },
  {
    "name": "ring.total_positive_cone",
    "statement": "structure ring.total_positive_cone (α : Type u_1) [ring α] : Type u_1",
    "theorem": "(α : Type u_1) [ring α] : Type u_1",
    "args": "(α : Type u_1) [ring α]",
    "doc_string": "A positive cone in a ring induces a linear order if `1` is a positive element.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "finmap.sdiff",
    "statement": "def finmap.sdiff {α : Type u} {β : α → Type v} [decidable_eq α] (s s' : finmap β) : finmap β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (s s' : finmap β) : finmap β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (s s' : finmap β)",
    "doc_string": " `sdiff s s'` consists of all key-value pairs from `s` and `s'` where the keys are in `s` or `s'` but not both.",
    "kind": "def",
    "type": "finmap β"
  },
  {
    "name": "galois_insertion.lift_semilattice_sup",
    "statement": "def galois_insertion.lift_semilattice_sup {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [semilattice_sup α] (gi : galois_insertion l u) : semilattice_sup β",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [semilattice_sup α] (gi : galois_insertion l u) : semilattice_sup β",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [semilattice_sup α] (gi : galois_insertion l u)",
    "doc_string": "Lift the suprema along a Galois insertion",
    "kind": "def",
    "type": "semilattice_sup β"
  },
  {
    "name": "fintype.to_bounded_order",
    "statement": "def fintype.to_bounded_order (α : Type u_2) [fintype α] [nonempty α] [lattice α] : bounded_order α",
    "theorem": "(α : Type u_2) [fintype α] [nonempty α] [lattice α] : bounded_order α",
    "args": "(α : Type u_2) [fintype α] [nonempty α] [lattice α]",
    "doc_string": "Constructs the `⊤` and `⊥` of a finite nonempty `lattice`.",
    "kind": "def",
    "type": "bounded_order α"
  },
  {
    "name": "ordered_add_comm_group.add_lt_add_left",
    "statement": "theorem ordered_add_comm_group.add_lt_add_left {α : Type u_1} [has_add α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α) : a + b < a + c",
    "theorem": "{α : Type u_1} [has_add α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α) : a + b < a + c",
    "args": "{α : Type u_1} [has_add α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α)",
    "doc_string": "**Alias** of mul_lt_mul_left'`.",
    "kind": "theorem",
    "type": "a + b < a + c"
  },
  {
    "name": "function.inv_fun",
    "statement": "def function.inv_fun {α : Sort u_1} {β : Sort u_2} [nonempty α] (f : α → β) : β → α",
    "theorem": "{α : Sort u_1} {β : Sort u_2} [nonempty α] (f : α → β) : β → α",
    "args": "{α : Sort u_1} {β : Sort u_2} [nonempty α] (f : α → β)",
    "doc_string": "The inverse of a function (which is a left inverse if `f` is injective  and a right inverse if `f` is surjective).",
    "kind": "def",
    "type": "β → α"
  },
  {
    "name": "lipschitz_with.dimH_range_le",
    "statement": "theorem lipschitz_with.dimH_range_le {X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ",
    "theorem": "{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ",
    "args": "{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f)",
    "doc_string": " If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain.",
    "kind": "theorem",
    "type": "dimH (set.range f) ≤ dimH set.univ"
  },
  {
    "name": "measurable_space.dynkin_system.generate_has",
    "statement": "inductive measurable_space.dynkin_system.generate_has {α : Type u_1} (s : set (set α)) : set α → Prop",
    "theorem": "{α : Type u_1} (s : set (set α)) : set α → Prop",
    "args": "{α : Type u_1} (s : set (set α))",
    "doc_string": "The least Dynkin system containing a collection of basic sets.  This inductive type gives the underlying collection of sets.",
    "kind": "inductive",
    "type": "set α → Prop"
  },
  {
    "name": "joined.some_path",
    "statement": "def joined.some_path {X : Type u_1} [topological_space X] {x y : X} (h : joined x y) : path x y",
    "theorem": "{X : Type u_1} [topological_space X] {x y : X} (h : joined x y) : path x y",
    "args": "{X : Type u_1} [topological_space X] {x y : X} (h : joined x y)",
    "doc_string": "When two points are joined, choose some path from `x` to `y`.",
    "kind": "def",
    "type": "path x y"
  },
  {
    "name": "bounded_continuous_function.has_dist",
    "statement": "def bounded_continuous_function.has_dist {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : has_dist (bounded_continuous_function α β)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : has_dist (bounded_continuous_function α β)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β]",
    "doc_string": "The uniform distance between two bounded continuous functions",
    "kind": "def",
    "type": "has_dist (bounded_continuous_function α β)"
  },
  {
    "name": "comp_add_right",
    "statement": "theorem comp_add_right {α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)",
    "theorem": "{α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)",
    "args": "{α : Type u_1} [add_semigroup α] (x y : α)",
    "doc_string": "Composing two additions on the right by `y` and `x` is equal to a addition on the right by `y + x`.",
    "kind": "theorem",
    "type": "((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)"
  },
  {
    "name": "option.encodable",
    "statement": "def option.encodable {α : Type u_1} [h : encodable α] : encodable (option α)",
    "theorem": "{α : Type u_1} [h : encodable α] : encodable (option α)",
    "args": "{α : Type u_1} [h : encodable α]",
    "doc_string": "If `α` is encodable, then so is `option α`.",
    "kind": "def",
    "type": "encodable (option α)"
  },
  {
    "name": "polynomial.degree_lt",
    "statement": "def polynomial.degree_lt (R : Type u) [semiring R] (n : ℕ) : submodule R (polynomial R)",
    "theorem": "(R : Type u) [semiring R] (n : ℕ) : submodule R (polynomial R)",
    "args": "(R : Type u) [semiring R] (n : ℕ)",
    "doc_string": "The `R`-submodule of `R[X]` consisting of polynomials of degree < `n`.",
    "kind": "def",
    "type": "submodule R (polynomial R)"
  },
  {
    "name": "AddGroup",
    "statement": "def AddGroup  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of additive groups and group morphisms",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "matrix.has_orthogonal_cols",
    "statement": "def matrix.has_orthogonal_cols {α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype m] : Prop",
    "theorem": "{α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype m] : Prop",
    "args": "{α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype m]",
    "doc_string": " `A.has_orthogonal_rows` means matrix `A` has orthogonal columns (with respect to `matrix.dot_product`).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "multiset.Ico",
    "statement": "def multiset.Ico {α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α)",
    "doc_string": " The multiset of elements `x` such that `a ≤ x` and `x < b`. Basically `set.Ico a b` as a multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "antilipschitz_with.K",
    "statement": "def antilipschitz_with.K {α : Type u_1} {β : Type u_2} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : antilipschitz_with K f) : nnreal",
    "theorem": "{α : Type u_1} {β : Type u_2} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : antilipschitz_with K f) : nnreal",
    "args": "{α : Type u_1} {β : Type u_2} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : antilipschitz_with K f)",
    "doc_string": " Extract the constant from `hf : antilipschitz_with K f`. This is useful, e.g., if `K` is given by a long formula, and we want to reuse this value.",
    "kind": "def",
    "type": "nnreal"
  },
  {
    "name": "filter.division_comm_monoid",
    "statement": "def filter.division_comm_monoid {α : Type u_2} [division_comm_monoid α] : division_comm_monoid (filter α)",
    "theorem": "{α : Type u_2} [division_comm_monoid α] : division_comm_monoid (filter α)",
    "args": "{α : Type u_2} [division_comm_monoid α]",
    "doc_string": "`filter α` is a commutative division monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "division_comm_monoid (filter α)"
  },
  {
    "name": "trunc.mk",
    "statement": "def trunc.mk {α : Sort u_1} (a : α) : trunc α",
    "theorem": "{α : Sort u_1} (a : α) : trunc α",
    "args": "{α : Sort u_1} (a : α)",
    "doc_string": "Constructor for `trunc α`",
    "kind": "def",
    "type": "trunc α"
  },
  {
    "name": "list.inits",
    "statement": "def list.inits {α : Type u_1} : list α → list (list α)",
    "theorem": "{α : Type u_1} : list α → list (list α)",
    "args": "{α : Type u_1}",
    "doc_string": "`inits l` is the list of initial segments of `l`.      inits [1, 2, 3] = [[], [1], [1, 2], [1, 2, 3]]",
    "kind": "def",
    "type": "list α → list (list α)"
  },
  {
    "name": "ratfunc.sub",
    "statement": "def ratfunc.sub {K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K → ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K → ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K]",
    "doc_string": "Subtraction of rational functions.",
    "kind": "def",
    "type": "ratfunc K → ratfunc K → ratfunc K"
  },
  {
    "name": "open_subgroup.prod",
    "statement": "def open_subgroup.prod {G : Type u_1} [group G] [topological_space G] {H : Type u_2} [group H] [topological_space H] (U : open_subgroup G) (V : open_subgroup H) : open_subgroup (G × H)",
    "theorem": "{G : Type u_1} [group G] [topological_space G] {H : Type u_2} [group H] [topological_space H] (U : open_subgroup G) (V : open_subgroup H) : open_subgroup (G × H)",
    "args": "{G : Type u_1} [group G] [topological_space G] {H : Type u_2} [group H] [topological_space H] (U : open_subgroup G) (V : open_subgroup H)",
    "doc_string": "The product of two open subgroups as an open subgroup of the product group.",
    "kind": "def",
    "type": "open_subgroup (G × H)"
  },
  {
    "name": "linear_ordered_comm_group",
    "statement": "structure linear_ordered_comm_group (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A linearly ordered commutative group is a commutative group with a linear order in which multiplication is monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "order.pfilter.partial_order",
    "statement": "def order.pfilter.partial_order {P : Type u_1} [preorder P] : partial_order (order.pfilter P)",
    "theorem": "{P : Type u_1} [preorder P] : partial_order (order.pfilter P)",
    "args": "{P : Type u_1} [preorder P]",
    "doc_string": "The partial ordering by subset inclusion, inherited from `set P`.",
    "kind": "def",
    "type": "partial_order (order.pfilter P)"
  },
  {
    "name": "cubic",
    "statement": "structure cubic (R : Type u_1) : Type u_1",
    "theorem": "(R : Type u_1) : Type u_1",
    "args": "(R : Type u_1)",
    "doc_string": "The structure representing a cubic polynomial.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "submodule",
    "statement": "structure submodule (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v",
    "theorem": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Type v",
    "args": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "A submodule of a module is one which is closed under vector operations.  This is a sufficient condition for the subset of vectors in the submodule  to themselves form a module.",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "complete_semilattice_Sup",
    "statement": "structure complete_semilattice_Sup (α : Type u_8) : Type u_8",
    "theorem": "(α : Type u_8) : Type u_8",
    "args": "(α : Type u_8)",
    "doc_string": "Note that we rarely use `complete_semilattice_Sup` (in fact, any such object is always a `complete_lattice`, so it's usually best to start there).  Nevertheless it is sometimes a useful intermediate step in constructions.",
    "kind": "structure",
    "type": "Type u_8"
  },
  {
    "name": "is_trivial_topological_fiber_bundle_fst",
    "statement": "theorem is_trivial_topological_fiber_bundle_fst {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The first projection in a product is a trivial topological fiber bundle.",
    "kind": "theorem",
    "type": "is_trivial_topological_fiber_bundle F prod.fst"
  },
  {
    "name": "subsemiring.closure",
    "statement": "def subsemiring.closure {R : Type u} [non_assoc_semiring R] (s : set R) : subsemiring R",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : set R) : subsemiring R",
    "args": "{R : Type u} [non_assoc_semiring R] (s : set R)",
    "doc_string": "The `subsemiring` generated by a set.",
    "kind": "def",
    "type": "subsemiring R"
  },
  {
    "name": "algebra.is_integral_of_finite",
    "statement": "theorem algebra.is_integral_of_finite (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L",
    "theorem": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L",
    "args": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L]",
    "doc_string": "A field extension is integral if it is finite.",
    "kind": "theorem",
    "type": "algebra.is_integral K L"
  },
  {
    "name": "pnat",
    "statement": "def pnat  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "`ℕ+` is the type of positive natural numbers. It is defined as a subtype,  and the VM representation of `ℕ+` is the same as `ℕ` because the proof  is not stored.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "wseq.union",
    "statement": "def wseq.union {α : Type u} (s1 s2 : wseq α) : wseq α",
    "theorem": "{α : Type u} (s1 s2 : wseq α) : wseq α",
    "args": "{α : Type u} (s1 s2 : wseq α)",
    "doc_string": "`union s1 s2` is a weak sequence which interleaves `s1` and `s2` in  some order (nondeterministically).",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "witt_vector.witt_add",
    "statement": "def witt_vector.witt_add (p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 2 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 2 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "The polynomials used for defining the addition of the ring of Witt vectors.",
    "kind": "def",
    "type": "ℕ → mv_polynomial (fin 2 × ℕ) ℤ"
  },
  {
    "name": "equiv.perm",
    "statement": "def equiv.perm (α : Sort u_1) : Sort (max 1 u_1)",
    "theorem": "(α : Sort u_1) : Sort (max 1 u_1)",
    "args": "(α : Sort u_1)",
    "doc_string": "`perm α` is the type of bijections from `α` to itself.",
    "kind": "def",
    "type": "Sort (max 1 u_1)"
  },
  {
    "name": "multiset.nat.antidiagonal_tuple",
    "statement": "def multiset.nat.antidiagonal_tuple (k n : ℕ) : multiset (fin k → ℕ)",
    "theorem": "(k n : ℕ) : multiset (fin k → ℕ)",
    "args": "(k n : ℕ)",
    "doc_string": "`multiset.antidiagonal_tuple k n` is a multiset of `k`-tuples summing to `n`",
    "kind": "def",
    "type": "multiset (fin k → ℕ)"
  },
  {
    "name": "function.injective2.right'",
    "statement": "theorem function.injective2.right' {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty α] : function.injective (λ (b : β) (a : α), f a b)",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty α] : function.injective (λ (b : β) (a : α), f a b)",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty α]",
    "doc_string": "As a map from the right argument to a unary function, `f` is injective.",
    "kind": "theorem",
    "type": "function.injective (λ (b : β) (a : α), f a b)"
  },
  {
    "name": "tactic.ring_exp.ring_exp_m",
    "statement": "def tactic.ring_exp.ring_exp_m (α : Type) : Type",
    "theorem": "(α : Type) : Type",
    "args": "(α : Type)",
    "doc_string": "The `ring_exp_m` monad is used instead of `tactic` to store the context.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "list.split",
    "statement": "def list.split {α : Type uu} : list α → list α × list α",
    "theorem": "{α : Type uu} : list α → list α × list α",
    "args": "{α : Type uu}",
    "doc_string": "Split `l` into two lists of approximately equal length.      split [1, 2, 3, 4, 5] = ([1, 3, 5], [2, 4])",
    "kind": "def",
    "type": "list α → list α × list α"
  },
  {
    "name": "complex_shape.refl",
    "statement": "def complex_shape.refl (ι : Type u_1) : complex_shape ι",
    "theorem": "(ι : Type u_1) : complex_shape ι",
    "args": "(ι : Type u_1)",
    "doc_string": "The complex shape where only differentials from each `X.i` to itself are allowed.  This is mostly only useful so we can describe the relation of \"related in `k` steps\" below.",
    "kind": "def",
    "type": "complex_shape ι"
  },
  {
    "name": "is_field",
    "statement": "structure is_field (R : Type u) [ring R] : Prop",
    "theorem": "(R : Type u) [ring R] : Prop",
    "args": "(R : Type u) [ring R]",
    "doc_string": " A predicate to express that a ring is a field.  This is mainly useful because such a predicate does not contain data, and can therefore be easily transported along ring isomorphisms. Additionaly, this is useful when trying to prove that a particular ring structure extends to a field.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "measure_theory.outer_measure.sum",
    "statement": "def measure_theory.outer_measure.sum {α : Type u_1} {ι : Type u_2} (f : ι → measure_theory.outer_measure α) : measure_theory.outer_measure α",
    "theorem": "{α : Type u_1} {ι : Type u_2} (f : ι → measure_theory.outer_measure α) : measure_theory.outer_measure α",
    "args": "{α : Type u_1} {ι : Type u_2} (f : ι → measure_theory.outer_measure α)",
    "doc_string": "The sum of an (arbitrary) collection of outer measures.",
    "kind": "def",
    "type": "measure_theory.outer_measure α"
  },
  {
    "name": "stream.head",
    "statement": "def stream.head {α : Type u} (s : stream α) : α",
    "theorem": "{α : Type u} (s : stream α) : α",
    "args": "{α : Type u} (s : stream α)",
    "doc_string": "Head of a stream: `stream.head s = stream.nth 0 s`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "first_order.language.equiv_setoid",
    "statement": "def first_order.language.equiv_setoid {L : first_order.language} : setoid (category_theory.bundled L.Structure)",
    "theorem": "{L : first_order.language} : setoid (category_theory.bundled L.Structure)",
    "args": "{L : first_order.language}",
    "doc_string": "The equivalence relation on bundled `L.Structure`s indicating that they are isomorphic.",
    "kind": "def",
    "type": "setoid (category_theory.bundled L.Structure)"
  },
  {
    "name": "monoid_with_zero_hom_class",
    "statement": "structure monoid_with_zero_hom_class (F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_11 u_9)",
    "theorem": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_11 u_9)",
    "args": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_zero_one_class M] [mul_zero_one_class N]",
    "doc_string": " `monoid_with_zero_hom_class F M N` states that `F` is a type of `monoid_with_zero`-preserving homomorphisms.  You should also extend this typeclass when you extend `monoid_with_zero_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_11 u_9)"
  },
  {
    "name": "compact_covering",
    "statement": "def compact_covering (α : Type u) [topological_space α] [sigma_compact_space α] : ℕ → set α",
    "theorem": "(α : Type u) [topological_space α] [sigma_compact_space α] : ℕ → set α",
    "args": "(α : Type u) [topological_space α] [sigma_compact_space α]",
    "doc_string": "A choice of compact covering for a `σ`-compact space, chosen to be monotone.",
    "kind": "def",
    "type": "ℕ → set α"
  },
  {
    "name": "lipschitz_with.to_locally_bounded_map",
    "statement": "def lipschitz_with.to_locally_bounded_map {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} (f : α → β) (hf : lipschitz_with K f) : locally_bounded_map α β",
    "theorem": "{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} (f : α → β) (hf : lipschitz_with K f) : locally_bounded_map α β",
    "args": "{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {K : nnreal} (f : α → β) (hf : lipschitz_with K f)",
    "doc_string": "A Lipschitz continuous map is a locally bounded map.",
    "kind": "def",
    "type": "locally_bounded_map α β"
  },
  {
    "name": "submonoid.pointwise_mul_action",
    "statement": "def submonoid.pointwise_mul_action {α : Type u_1} {M : Type u_3} [monoid M] [monoid α] [mul_distrib_mul_action α M] : mul_action α (submonoid M)",
    "theorem": "{α : Type u_1} {M : Type u_3} [monoid M] [monoid α] [mul_distrib_mul_action α M] : mul_action α (submonoid M)",
    "args": "{α : Type u_1} {M : Type u_3} [monoid M] [monoid α] [mul_distrib_mul_action α M]",
    "doc_string": " The action on a submonoid corresponding to applying the action to every element.  This is available as an instance in the `pointwise` locale.",
    "kind": "def",
    "type": "mul_action α (submonoid M)"
  },
  {
    "name": "ennreal",
    "statement": "def ennreal  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The extended nonnegative real numbers. This is usually denoted [0, ∞],  and is relevant as the codomain of a measure.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "computation.return",
    "statement": "def computation.return {α : Type u} (a : α) : computation α",
    "theorem": "{α : Type u} (a : α) : computation α",
    "args": "{α : Type u} (a : α)",
    "doc_string": "`return a` is the computation that immediately terminates with result `a`.",
    "kind": "def",
    "type": "computation α"
  },
  {
    "name": "finset.semigroup",
    "statement": "def finset.semigroup {α : Type u_2} [decidable_eq α] [semigroup α] : semigroup (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [semigroup α] : semigroup (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [semigroup α]",
    "doc_string": "`finset α` is a `semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "semigroup (finset α)"
  },
  {
    "name": "topological_add_group",
    "statement": "structure topological_add_group (G : Type u) [topological_space G] [add_group G] : Prop",
    "theorem": "(G : Type u) [topological_space G] [add_group G] : Prop",
    "args": "(G : Type u) [topological_space G] [add_group G]",
    "doc_string": " A topological (additive) group is a group in which the addition and negation operations are continuous.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "add_monoid_hom_class",
    "statement": "structure add_monoid_hom_class (F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_11 u_9)",
    "theorem": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_11 u_9)",
    "args": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [add_zero_class M] [add_zero_class N]",
    "doc_string": " `add_monoid_hom_class F M N` states that `F` is a type of `add_zero_class`-preserving homomorphisms.  You should also extend this typeclass when you extend `add_monoid_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_11 u_9)"
  },
  {
    "name": "multiset.ndinter",
    "statement": "def multiset.ndinter {α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "args": "{α : Type u_1} [decidable_eq α] (s t : multiset α)",
    "doc_string": "`ndinter s t` is the lift of the list `∩` operation. This operation  does not respect multiplicities, unlike `s ∩ t`, but it is suitable as  an intersection operation on `finset`. (`s ∩ t` would also work as a union operation  on finset, but this is more efficient.)",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "antisymm_of'",
    "statement": "theorem antisymm_of' {α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → b = a",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → b = a",
    "args": "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α}",
    "doc_string": " A version of `antisymm'` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there.",
    "kind": "theorem",
    "type": "r a b → r b a → b = a"
  },
  {
    "name": "list.insertion_sort",
    "statement": "def list.insertion_sort {α : Type uu} (r : α → α → Prop) [decidable_rel r] : list α → list α",
    "theorem": "{α : Type uu} (r : α → α → Prop) [decidable_rel r] : list α → list α",
    "args": "{α : Type uu} (r : α → α → Prop) [decidable_rel r]",
    "doc_string": "`insertion_sort l` returns `l` sorted using the insertion sort algorithm.",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "sign_type",
    "statement": "inductive sign_type  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of signs.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "nnreal.has_sum_iff_tendsto_nat",
    "statement": "theorem nnreal.has_sum_iff_tendsto_nat {f : ℕ → nnreal} {r : nnreal} : has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)",
    "theorem": "{f : ℕ → nnreal} {r : nnreal} : has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)",
    "args": "{f : ℕ → nnreal} {r : nnreal}",
    "doc_string": " A series of non-negative real numbers converges to `r` in the sense of `has_sum` if and only if the sequence of partial sum converges to `r`.",
    "kind": "theorem",
    "type": "has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)"
  },
  {
    "name": "erased.out_type",
    "statement": "def erased.out_type (a : erased (Sort u)) : Sort u",
    "theorem": "(a : erased (Sort u)) : Sort u",
    "args": "(a : erased (Sort u))",
    "doc_string": "Extracts the erased value, if it is a type.  Note: `(mk a).out_type` is not definitionally equal to `a`.",
    "kind": "def",
    "type": "Sort u"
  },
  {
    "name": "ulower.up",
    "statement": "def ulower.up {α : Type u_1} [encodable α] (a : ulower α) : α",
    "theorem": "{α : Type u_1} [encodable α] (a : ulower α) : α",
    "args": "{α : Type u_1} [encodable α] (a : ulower α)",
    "doc_string": "Lifts an `a : ulower α` into `α`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "matrix.sub_up_left",
    "statement": "def matrix.sub_up_left {α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α) : matrix (fin u) (fin l) α",
    "theorem": "{α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α) : matrix (fin u) (fin l) α",
    "args": "{α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α)",
    "doc_string": "The top-left `u × l` part of a `(u+d) × (l+r)` matrix.",
    "kind": "def",
    "type": "matrix (fin u) (fin l) α"
  },
  {
    "name": "tactic.ring_exp.exp_congr",
    "statement": "theorem tactic.ring_exp.exp_congr {α : Type u} [comm_semiring α] {p p' : α} {ps ps' : ℕ} : p = p' → ps = ps' → p ^ ps = p' ^ ps'",
    "theorem": "{α : Type u} [comm_semiring α] {p p' : α} {ps ps' : ℕ} : p = p' → ps = ps' → p ^ ps = p' ^ ps'",
    "args": "{α : Type u} [comm_semiring α] {p p' : α} {ps ps' : ℕ}",
    "doc_string": "Congruence lemma for constructing `ex.exp`.",
    "kind": "theorem",
    "type": "p = p' → ps = ps' → p ^ ps = p' ^ ps'"
  },
  {
    "name": "zmod.legendre_sym_card_sqrts",
    "statement": "theorem zmod.legendre_sym_card_sqrts (p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ) : ↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ) : ↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1",
    "args": "(p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ)",
    "doc_string": "The number of square roots of `a` modulo `p` is determined by the Legendre symbol.",
    "kind": "theorem",
    "type": "↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1"
  },
  {
    "name": "factorization_mul",
    "statement": "theorem factorization_mul {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) : factorization (a * b) = factorization a + factorization b",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) : factorization (a * b) = factorization a + factorization b",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0)",
    "doc_string": "For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`",
    "kind": "theorem",
    "type": "factorization (a * b) = factorization a + factorization b"
  },
  {
    "name": "le_rfl",
    "statement": "theorem le_rfl {α : Type u} [preorder α] {a : α} : a ≤ a",
    "theorem": "{α : Type u} [preorder α] {a : α} : a ≤ a",
    "args": "{α : Type u} [preorder α] {a : α}",
    "doc_string": "A version of `le_refl` where the argument is implicit",
    "kind": "theorem",
    "type": "a ≤ a"
  },
  {
    "name": "finset.Icc",
    "statement": "def finset.Icc {α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α)",
    "doc_string": "The finset of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `set.Icc a b` as a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "algebraic_geometry.PresheafedSpace",
    "statement": "structure algebraic_geometry.PresheafedSpace (C : Type u) [category_theory.category C] : Type (max u (v+1))",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u (v+1))",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A `PresheafedSpace C` is a topological space equipped with a presheaf of `C`s.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "has_continuous_sup",
    "statement": "structure has_continuous_sup (L : Type u_1) [topological_space L] [has_sup L] : Prop",
    "theorem": "(L : Type u_1) [topological_space L] [has_sup L] : Prop",
    "args": "(L : Type u_1) [topological_space L] [has_sup L]",
    "doc_string": "Let `L` be a topological space and let `L×L` be equipped with the product topology and let `⊓:L×L → L` be a supremum. Then `L` is said to have *(jointly) continuous supremum* if the map `⊓:L×L → L` is continuous.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.connected_components",
    "statement": "def category_theory.connected_components (J : Type u₁) [category_theory.category J] : Type u₁",
    "theorem": "(J : Type u₁) [category_theory.category J] : Type u₁",
    "args": "(J : Type u₁) [category_theory.category J]",
    "doc_string": "This type indexes the connected components of the category `J`.",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "composition.length",
    "statement": "def composition.length {n : ℕ} (c : composition n) : ℕ",
    "theorem": "{n : ℕ} (c : composition n) : ℕ",
    "args": "{n : ℕ} (c : composition n)",
    "doc_string": "The length of a composition, i.e., the number of blocks in the composition.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "category_theory.monoidal_opposite",
    "statement": "def category_theory.monoidal_opposite (C : Type u₁) : Type u₁",
    "theorem": "(C : Type u₁) : Type u₁",
    "args": "(C : Type u₁)",
    "doc_string": "A type synonym for the monoidal opposite. Use the notation `Cᴹᵒᵖ`.",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "pi.canonically_ordered_monoid",
    "statement": "def pi.canonically_ordered_monoid {ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), canonically_ordered_monoid (Z i)] : canonically_ordered_monoid (Π (i : ι), Z i)",
    "theorem": "{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), canonically_ordered_monoid (Z i)] : canonically_ordered_monoid (Π (i : ι), Z i)",
    "args": "{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), canonically_ordered_monoid (Z i)]",
    "doc_string": "The product of a family of canonically ordered monoids is a canonically ordered monoid.",
    "kind": "def",
    "type": "canonically_ordered_monoid (Π (i : ι), Z i)"
  },
  {
    "name": "applicative_transformation",
    "statement": "structure applicative_transformation (F : Type u → Type v) [applicative F] [is_lawful_applicative F] (G : Type u → Type w) [applicative G] [is_lawful_applicative G] : Type (max (u+1) v w)",
    "theorem": "(F : Type u → Type v) [applicative F] [is_lawful_applicative F] (G : Type u → Type w) [applicative G] [is_lawful_applicative G] : Type (max (u+1) v w)",
    "args": "(F : Type u → Type v) [applicative F] [is_lawful_applicative F] (G : Type u → Type w) [applicative G] [is_lawful_applicative G]",
    "doc_string": " A transformation between applicative functors.  It is a natural transformation such that `app` preserves the `has_pure.pure` and `functor.map` (`<*>`) operations. See `applicative_transformation.preserves_map` for naturality.",
    "kind": "structure",
    "type": "Type (max (u+1) v w)"
  },
  {
    "name": "alist.replace",
    "statement": "def alist.replace {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : alist β) : alist β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : alist β) : alist β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : alist β)",
    "doc_string": "Replace a key with a given value in an association list.  If the key is not present it does nothing.",
    "kind": "def",
    "type": "alist β"
  },
  {
    "name": "antisymm_rel.setoid",
    "statement": "def antisymm_rel.setoid (α : Type u_1) (r : α → α → Prop) [is_preorder α r] : setoid α",
    "theorem": "(α : Type u_1) (r : α → α → Prop) [is_preorder α r] : setoid α",
    "args": "(α : Type u_1) (r : α → α → Prop) [is_preorder α r]",
    "doc_string": "The antisymmetrization relation as an equivalence relation.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "io.mk_generator",
    "statement": "def io.mk_generator  : io std_gen",
    "theorem": " : io std_gen",
    "args": "",
    "doc_string": "create and a seed a random number generator",
    "kind": "def",
    "type": "io std_gen"
  },
  {
    "name": "sub_left_le_of_le_add",
    "statement": "theorem sub_left_le_of_le_add {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a ≤ b + c → a - b ≤ c",
    "theorem": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a ≤ b + c → a - b ≤ c",
    "args": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of sub_le_iff_le_add'`.",
    "kind": "theorem",
    "type": "a ≤ b + c → a - b ≤ c"
  },
  {
    "name": "zmod.is_domain",
    "statement": "def zmod.is_domain (p : ℕ) [hp : fact (nat.prime p)] : is_domain (zmod p)",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : is_domain (zmod p)",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "`zmod p` is an integral domain when `p` is prime.",
    "kind": "def",
    "type": "is_domain (zmod p)"
  },
  {
    "name": "specialization_order",
    "statement": "def specialization_order (α : Type u_1) [topological_space α] [t0_space α] : partial_order α",
    "theorem": "(α : Type u_1) [topological_space α] [t0_space α] : partial_order α",
    "args": "(α : Type u_1) [topological_space α] [t0_space α]",
    "doc_string": "Specialization forms a partial order on a t0 topological space.",
    "kind": "def",
    "type": "partial_order α"
  },
  {
    "name": "category_theory.cartesian_closed",
    "statement": "def category_theory.cartesian_closed (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_products C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_products C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_products C]",
    "doc_string": "A category `C` is cartesian closed if it has finite products and every object is exponentiable. We define this as `monoidal_closed` with respect to the cartesian monoidal structure.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "emetric.inf_edist_lt_iff",
    "statement": "theorem emetric.inf_edist_lt_iff {α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} {r : ennreal} : emetric.inf_edist x s < r ↔ ∃ (y : α) (H : y ∈ s), has_edist.edist x y < r",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} {r : ennreal} : emetric.inf_edist x s < r ↔ ∃ (y : α) (H : y ∈ s), has_edist.edist x y < r",
    "args": "{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} {r : ennreal}",
    "doc_string": "The edist to a set is `< r` iff there exists a point in the set at edistance `< r`",
    "kind": "theorem",
    "type": "emetric.inf_edist x s < r ↔ ∃ (y : α) (H : y ∈ s), has_edist.edist x y < r"
  },
  {
    "name": "generalized_boolean_algebra.to_non_unital_comm_ring",
    "statement": "def generalized_boolean_algebra.to_non_unital_comm_ring {α : Type u_1} [generalized_boolean_algebra α] : non_unital_comm_ring α",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] : non_unital_comm_ring α",
    "args": "{α : Type u_1} [generalized_boolean_algebra α]",
    "doc_string": " Every generalized Boolean algebra has the structure of a non unital commutative ring with the following data:  * `a + b` unfolds to `a ∆ b` (symmetric difference) * `a * b` unfolds to `a ⊓ b` * `-a` unfolds to `a` * `0` unfolds to `⊥`",
    "kind": "def",
    "type": "non_unital_comm_ring α"
  },
  {
    "name": "set.mul_antidiagonal",
    "statement": "def set.mul_antidiagonal {α : Type u_1} [monoid α] (s t : set α) (a : α) : set (α × α)",
    "theorem": "{α : Type u_1} [monoid α] (s t : set α) (a : α) : set (α × α)",
    "args": "{α : Type u_1} [monoid α] (s t : set α) (a : α)",
    "doc_string": "`set.mul_antidiagonal s t a` is the set of all pairs of an element in `s` and an element in `t`  that multiply to `a`.",
    "kind": "def",
    "type": "set (α × α)"
  },
  {
    "name": "valuation_ring",
    "statement": "structure valuation_ring (A : Type u) [comm_ring A] [is_domain A] : Prop",
    "theorem": "(A : Type u) [comm_ring A] [is_domain A] : Prop",
    "args": "(A : Type u) [comm_ring A] [is_domain A]",
    "doc_string": " An integral domain is called a `valuation ring` provided that for any pair of elements `a b : A`, either `a` divides `b` or vice versa.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "vector.insert_nth",
    "statement": "def vector.insert_nth {n : ℕ} {α : Type u_1} (a : α) (i : fin (n + 1)) (v : vector α n) : vector α (n + 1)",
    "theorem": "{n : ℕ} {α : Type u_1} (a : α) (i : fin (n + 1)) (v : vector α n) : vector α (n + 1)",
    "args": "{n : ℕ} {α : Type u_1} (a : α) (i : fin (n + 1)) (v : vector α n)",
    "doc_string": " `v.insert_nth a i` inserts `a` into the vector `v` at position `i` (and shifting later components to the right).",
    "kind": "def",
    "type": "vector α (n + 1)"
  },
  {
    "name": "char.quadratic_char",
    "statement": "def char.quadratic_char (α : Type u_1) [monoid_with_zero α] [decidable_eq α] [decidable_pred is_square] (a : α) : ℤ",
    "theorem": "(α : Type u_1) [monoid_with_zero α] [decidable_eq α] [decidable_pred is_square] (a : α) : ℤ",
    "args": "(α : Type u_1) [monoid_with_zero α] [decidable_eq α] [decidable_pred is_square] (a : α)",
    "doc_string": " Define the quadratic character with values in ℤ on a monoid with zero `α`. It takes the value zero at zero; for non-zero argument `a : α`, it is `1` if `a` is a square, otherwise it is `-1`.  This only deserves the name \"character\" when it is multiplicative, e.g., when `α` is a finite field. See `quadratic_char_mul`.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "equiv.perm.cycle_factors_finset",
    "statement": "def equiv.perm.cycle_factors_finset {α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) : finset (equiv.perm α)",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) : finset (equiv.perm α)",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α)",
    "doc_string": "Factors a permutation `f` into a `finset` of disjoint cyclic permutations that multiply to `f`.",
    "kind": "def",
    "type": "finset (equiv.perm α)"
  },
  {
    "name": "relation.comp",
    "statement": "def relation.comp {α : Type u_1} {β : Type u_2} {γ : Type u_3} (r : α → β → Prop) (p : β → γ → Prop) (a : α) (c : γ) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (r : α → β → Prop) (p : β → γ → Prop) (a : α) (c : γ) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (r : α → β → Prop) (p : β → γ → Prop) (a : α) (c : γ)",
    "doc_string": "The composition of two relations, yielding a new relation.  The result relates a term of `α` and a term of `γ` if there is an intermediate term of `β` related to both.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bornology.relatively_compact",
    "statement": "def bornology.relatively_compact (α : Type u) [topological_space α] [t1_space α] : bornology α",
    "theorem": "(α : Type u) [topological_space α] [t1_space α] : bornology α",
    "args": "(α : Type u) [topological_space α] [t1_space α]",
    "doc_string": " In a `t1_space`, relatively compact sets form a bornology. Its cobounded filter is `filter.coclosed_compact`. See also `bornology.in_compact` the bornology of sets contained in a compact set.",
    "kind": "def",
    "type": "bornology α"
  },
  {
    "name": "parser.many'",
    "statement": "def parser.many' {α : Type} (p : parser α) : parser unit",
    "theorem": "{α : Type} (p : parser α) : parser unit",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "Matches zero or more occurrences of `p`.",
    "kind": "def",
    "type": "parser unit"
  },
  {
    "name": "finset.has_one",
    "statement": "def finset.has_one {α : Type u_2} [has_one α] : has_one (finset α)",
    "theorem": "{α : Type u_2} [has_one α] : has_one (finset α)",
    "args": "{α : Type u_2} [has_one α]",
    "doc_string": "The finset `1 : finset α` is defined as `{1}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_one (finset α)"
  },
  {
    "name": "discrim",
    "statement": "def discrim {R : Type u_1} [ring R] (a b c : R) : R",
    "theorem": "{R : Type u_1} [ring R] (a b c : R) : R",
    "args": "{R : Type u_1} [ring R] (a b c : R)",
    "doc_string": "Discriminant of a quadratic",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "subalgebra.to_subsemiring",
    "statement": "def subalgebra.to_subsemiring {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (self : subalgebra R A) : subsemiring A",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (self : subalgebra R A) : subsemiring A",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (self : subalgebra R A)",
    "doc_string": "Reinterpret a `subalgebra` as a `subsemiring`.",
    "kind": "def",
    "type": "subsemiring A"
  },
  {
    "name": "measure_theory.extend",
    "statement": "def measure_theory.extend {α : Type u_1} {P : α → Prop} (m : Π (s : α), P s → ennreal) (s : α) : ennreal",
    "theorem": "{α : Type u_1} {P : α → Prop} (m : Π (s : α), P s → ennreal) (s : α) : ennreal",
    "args": "{α : Type u_1} {P : α → Prop} (m : Π (s : α), P s → ennreal) (s : α)",
    "doc_string": "We can trivially extend a function defined on a subclass of objects (with codomain `ℝ≥0∞`)  to all objects by defining it to be `∞` on the objects not in the class.",
    "kind": "def",
    "type": "ennreal"
  },
  {
    "name": "category_theory.abelian.pseudo_equal",
    "statement": "def category_theory.abelian.pseudo_equal {C : Type u} [category_theory.category C] (P : C) (f g : category_theory.over P) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (P : C) (f g : category_theory.over P) : Prop",
    "args": "{C : Type u} [category_theory.category C] (P : C) (f g : category_theory.over P)",
    "doc_string": "Two arrows `f : X ⟶ P` and `g : Y ⟶ P` are called pseudo-equal if there is some object    `R` and epimorphisms `p : R ⟶ X` and `q : R ⟶ Y` such that `p ≫ f = q ≫ g`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_hom.mul_left",
    "statement": "def add_hom.mul_left {R : Type u_1} [distrib R] (r : R) : add_hom R R",
    "theorem": "{R : Type u_1} [distrib R] (r : R) : add_hom R R",
    "args": "{R : Type u_1} [distrib R] (r : R)",
    "doc_string": "Left multiplication by an element of a type with distributive multiplication is an `add_hom`.",
    "kind": "def",
    "type": "add_hom R R"
  },
  {
    "name": "is_Sup_finite_compact.well_founded",
    "statement": "theorem is_Sup_finite_compact.well_founded (α : Type u_1) [complete_lattice α] : complete_lattice.is_Sup_finite_compact α → well_founded gt",
    "theorem": "(α : Type u_1) [complete_lattice α] : complete_lattice.is_Sup_finite_compact α → well_founded gt",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": "**Alias** of the reverse direction of complete_lattice.well_founded_iff_is_Sup_finite_compact`.",
    "kind": "theorem",
    "type": "complete_lattice.is_Sup_finite_compact α → well_founded gt"
  },
  {
    "name": "not_is_right_regular_zero",
    "statement": "theorem not_is_right_regular_zero {R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_right_regular 0",
    "theorem": "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_right_regular 0",
    "args": "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R]",
    "doc_string": "In a non-trivial ring, the element `0` is not right-regular -- with typeclasses.",
    "kind": "theorem",
    "type": "¬is_right_regular 0"
  },
  {
    "name": "is_group_hom.map_inv",
    "statement": "theorem is_group_hom.map_inv {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) (a : α) : f a⁻¹ = (f a)⁻¹",
    "theorem": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) (a : α) : f a⁻¹ = (f a)⁻¹",
    "args": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) (a : α)",
    "doc_string": "A group homomorphism sends inverses to inverses.",
    "kind": "theorem",
    "type": "f a⁻¹ = (f a)⁻¹"
  },
  {
    "name": "continuous_submonoid",
    "statement": "def continuous_submonoid (α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [monoid β] [has_continuous_mul β] : submonoid (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [monoid β] [has_continuous_mul β] : submonoid (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [monoid β] [has_continuous_mul β]",
    "doc_string": "The `submonoid` of continuous maps `α → β`.",
    "kind": "def",
    "type": "submonoid (α → β)"
  },
  {
    "name": "pseudo_metric_space.replace_bornology",
    "statement": "def pseudo_metric_space.replace_bornology {α : Type u_1} [B : bornology α] (m : pseudo_metric_space α) (H : ∀ (s : set α), bornology.is_bounded s ↔ bornology.is_bounded s) : pseudo_metric_space α",
    "theorem": "{α : Type u_1} [B : bornology α] (m : pseudo_metric_space α) (H : ∀ (s : set α), bornology.is_bounded s ↔ bornology.is_bounded s) : pseudo_metric_space α",
    "args": "{α : Type u_1} [B : bornology α] (m : pseudo_metric_space α) (H : ∀ (s : set α), bornology.is_bounded s ↔ bornology.is_bounded s)",
    "doc_string": " Build a new pseudometric space from an old one where the bundled bornology structure is provably (but typically non-definitionaly) equal to some given bornology structure. See Note [forgetful inheritance].",
    "kind": "def",
    "type": "pseudo_metric_space α"
  },
  {
    "name": "category_theory.limits.types.binary_product_limit_cone",
    "statement": "def category_theory.limits.types.binary_product_limit_cone (X Y : Type u) : category_theory.limits.limit_cone (category_theory.limits.pair X Y)",
    "theorem": "(X Y : Type u) : category_theory.limits.limit_cone (category_theory.limits.pair X Y)",
    "args": "(X Y : Type u)",
    "doc_string": "The category of types has `X × Y`, the usual cartesian product, as the binary product of `X` and `Y`.",
    "kind": "def",
    "type": "category_theory.limits.limit_cone (category_theory.limits.pair X Y)"
  },
  {
    "name": "pmf",
    "statement": "def pmf (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A probability mass function, or discrete probability measures is a function `α → ℝ≥0` such that  the values have (infinite) sum `1`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "pos_num.divmod",
    "statement": "def pos_num.divmod (d : pos_num) : pos_num → num × num",
    "theorem": "(d : pos_num) : pos_num → num × num",
    "args": "(d : pos_num)",
    "doc_string": "`divmod x y = (y / x, y % x)`.",
    "kind": "def",
    "type": "pos_num → num × num"
  },
  {
    "name": "algebra.is_algebraic",
    "statement": "def algebra.is_algebraic (R : Type u) (A : Type v) [comm_ring R] [ring A] [algebra R A] : Prop",
    "theorem": "(R : Type u) (A : Type v) [comm_ring R] [ring A] [algebra R A] : Prop",
    "args": "(R : Type u) (A : Type v) [comm_ring R] [ring A] [algebra R A]",
    "doc_string": "An algebra is algebraic if all its elements are algebraic.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "order_monoid_hom",
    "statement": "structure order_monoid_hom (α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [mul_one_class α] [mul_one_class β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [mul_one_class α] [mul_one_class β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [mul_one_class α] [mul_one_class β]",
    "doc_string": " `α →*o β` is the type of functions `α → β` that preserve the `ordered_comm_monoid` structure.  `order_monoid_hom` is also used for ordered group homomorphisms.  When possible, instead of parametrizing results over `(f : α →*o β)`, you should parametrize over `(F : Type*) [order_monoid_hom_class F α β] (f : F)`.  When you extend this structure, make sure to extend `order_monoid_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "pmf.of_finset",
    "statement": "def pmf.of_finset {α : Type u_1} (f : α → nnreal) (s : finset α) (h : s.sum (λ (a : α), f a) = 1) (h' : ∀ (a : α), a ∉ s → f a = 0) : pmf α",
    "theorem": "{α : Type u_1} (f : α → nnreal) (s : finset α) (h : s.sum (λ (a : α), f a) = 1) (h' : ∀ (a : α), a ∉ s → f a = 0) : pmf α",
    "args": "{α : Type u_1} (f : α → nnreal) (s : finset α) (h : s.sum (λ (a : α), f a) = 1) (h' : ∀ (a : α), a ∉ s → f a = 0)",
    "doc_string": "Given a finset `s` and a function `f : α → ℝ≥0` with sum `1` on `s`,  such that `f a = 0` for `a ∉ s`, we get a `pmf`",
    "kind": "def",
    "type": "pmf α"
  },
  {
    "name": "computation.parallel",
    "statement": "def computation.parallel {α : Type u} (S : wseq (computation α)) : computation α",
    "theorem": "{α : Type u} (S : wseq (computation α)) : computation α",
    "args": "{α : Type u} (S : wseq (computation α))",
    "doc_string": "Parallel computation of an infinite stream of computations,  taking the first result",
    "kind": "def",
    "type": "computation α"
  },
  {
    "name": "generalized_continued_fraction.next_numerator",
    "statement": "def generalized_continued_fraction.next_numerator {K : Type u_2} [division_ring K] (a b ppredA predA : K) : K",
    "theorem": "{K : Type u_2} [division_ring K] (a b ppredA predA : K) : K",
    "args": "{K : Type u_2} [division_ring K] (a b ppredA predA : K)",
    "doc_string": "Returns the next numerator `Aₙ = bₙ₋₁ * Aₙ₋₁ + aₙ₋₁ * Aₙ₋₂`, where `predA` is `Aₙ₋₁`, `ppredA` is `Aₙ₋₂`, `a` is `aₙ₋₁`, and `b` is `bₙ₋₁`.",
    "kind": "def",
    "type": "K"
  },
  {
    "name": "category_theory.limits.has_biproduct",
    "statement": "structure category_theory.limits.has_biproduct {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) : Prop",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) : Prop",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C)",
    "doc_string": "`has_biproduct F` expresses the mere existence of a bicone which is simultaneously a limit and a colimit of the diagram `F`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "non_unital_comm_semiring",
    "statement": "structure non_unital_comm_semiring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication. In other words, it is a type with the following structures: additive commutative monoid (`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and multiplication by zero law (`mul_zero_class`).",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "mul_add_eq_mul_add_iff_sub_mul_add_eq",
    "statement": "theorem mul_add_eq_mul_add_iff_sub_mul_add_eq {α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α} : a * e + c = b * e + d ↔ (a - b) * e + c = d",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α} : a * e + c = b * e + d ↔ (a - b) * e + c = d",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α}",
    "doc_string": "An iff statement following from right distributivity in rings and the definition  of subtraction.",
    "kind": "theorem",
    "type": "a * e + c = b * e + d ↔ (a - b) * e + c = d"
  },
  {
    "name": "tactic.solve_by_elim.basic_opt",
    "statement": "structure tactic.solve_by_elim.basic_opt  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration options for `solve_by_elim`.  * `accept : list expr → tactic unit` determines whether the current branch should be explored.    At each step, before the lemmas are applied,    `accept` is passed the proof terms for the original goals,    as reported by `get_goals` when `solve_by_elim` started.    These proof terms may be metavariables (if no progress has been made on that goal)    or may contain metavariables at some leaf nodes    (if the goal has been partially solved by previous `apply` steps).    If the `accept` tactic fails `solve_by_elim` aborts searching this branch and backtracks.    By default `accept := λ _, skip` always succeeds.    (There is an example usage in `tests/solve_by_elim.lean`.) * `pre_apply : tactic unit` specifies an additional tactic to run before each round of `apply`. * `discharger : tactic unit` specifies an additional tactic to apply on subgoals   for which no lemma applies.   If that tactic succeeds, `solve_by_elim` will continue applying lemmas on resulting goals.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "setoid.map_of_surjective",
    "statement": "def setoid.map_of_surjective {α : Type u_1} {β : Type u_2} (r : setoid α) (f : α → β) (h : setoid.ker f ≤ r) (hf : function.surjective f) : setoid β",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : setoid α) (f : α → β) (h : setoid.ker f ≤ r) (hf : function.surjective f) : setoid β",
    "args": "{α : Type u_1} {β : Type u_2} (r : setoid α) (f : α → β) (h : setoid.ker f ≤ r) (hf : function.surjective f)",
    "doc_string": "Given a surjective function f whose kernel is contained in an equivalence relation r, the    equivalence relation on f's codomain defined by x ≈ y ↔ the elements of f⁻¹(x) are related to    the elements of f⁻¹(y) by r.",
    "kind": "def",
    "type": "setoid β"
  },
  {
    "name": "ordinal.fp_unbounded",
    "statement": "theorem ordinal.fp_unbounded {f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)",
    "theorem": "{f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)",
    "args": "{f : ordinal → ordinal} (H : ordinal.is_normal f)",
    "doc_string": " The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points.",
    "kind": "theorem",
    "type": "set.unbounded has_lt.lt (function.fixed_points f)"
  },
  {
    "name": "homotopic",
    "statement": "def homotopic {ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape ι) : hom_rel (homological_complex V c)",
    "theorem": "{ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape ι) : hom_rel (homological_complex V c)",
    "args": "{ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape ι)",
    "doc_string": "The congruence on `homological_complex V c` given by the existence of a homotopy.",
    "kind": "def",
    "type": "hom_rel (homological_complex V c)"
  },
  {
    "name": "topological_space.is_topological_basis",
    "statement": "structure topological_space.is_topological_basis {α : Type u} [t : topological_space α] (s : set (set α)) : Prop",
    "theorem": "{α : Type u} [t : topological_space α] (s : set (set α)) : Prop",
    "args": "{α : Type u} [t : topological_space α] (s : set (set α))",
    "doc_string": "A topological basis is one that satisfies the necessary conditions so that  it suffices to take unions of the basis sets to get a topology (without taking  finite intersections as well).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "associates.mk",
    "statement": "def associates.mk {α : Type u_1} [monoid α] (a : α) : associates α",
    "theorem": "{α : Type u_1} [monoid α] (a : α) : associates α",
    "args": "{α : Type u_1} [monoid α] (a : α)",
    "doc_string": "The canonical quotient map from a monoid `α` into the `associates` of `α`",
    "kind": "def",
    "type": "associates α"
  },
  {
    "name": "emetric.inf_edist_le_inf_edist_add_edist",
    "statement": "theorem emetric.inf_edist_le_inf_edist_add_edist {α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} : emetric.inf_edist x s ≤ emetric.inf_edist y s + has_edist.edist x y",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} : emetric.inf_edist x s ≤ emetric.inf_edist y s + has_edist.edist x y",
    "args": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α}",
    "doc_string": " The edist of `x` to `s` is bounded by the sum of the edist of `y` to `s` and the edist from `x` to `y`",
    "kind": "theorem",
    "type": "emetric.inf_edist x s ≤ emetric.inf_edist y s + has_edist.edist x y"
  },
  {
    "name": "list.is_prefix_of",
    "statement": "def list.is_prefix_of {α : Type u} [decidable_eq α] : list α → list α → bool",
    "theorem": "{α : Type u} [decidable_eq α] : list α → list α → bool",
    "args": "{α : Type u} [decidable_eq α]",
    "doc_string": "`is_prefix_of l₁ l₂` returns `tt` iff `l₁` is a prefix of `l₂`.",
    "kind": "def",
    "type": "list α → list α → bool"
  },
  {
    "name": "zero_hom",
    "statement": "structure zero_hom (M : Type u_9) (N : Type u_10) [has_zero M] [has_zero N] : Type (max u_10 u_9)",
    "theorem": "(M : Type u_9) (N : Type u_10) [has_zero M] [has_zero N] : Type (max u_10 u_9)",
    "args": "(M : Type u_9) (N : Type u_10) [has_zero M] [has_zero N]",
    "doc_string": " `zero_hom M N` is the type of functions `M → N` that preserve zero.  When possible, instead of parametrizing results over `(f : zero_hom M N)`, you should parametrize over `(F : Type*) [zero_hom_class F M N] (f : F)`.  When you extend this structure, make sure to also extend `zero_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_10 u_9)"
  },
  {
    "name": "lazy_list.iota",
    "statement": "def lazy_list.iota (i : ℕ) : lazy_list ℕ",
    "theorem": "(i : ℕ) : lazy_list ℕ",
    "args": "(i : ℕ)",
    "doc_string": "The infinite lazy list `[i, i+1, i+2, ...]`",
    "kind": "def",
    "type": "lazy_list ℕ"
  },
  {
    "name": "ring_filter_basis.submodules_basis",
    "statement": "structure ring_filter_basis.submodules_basis {ι : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] (BR : ring_filter_basis R) (B : ι → submodule R M) : Prop",
    "theorem": "{ι : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] (BR : ring_filter_basis R) (B : ι → submodule R M) : Prop",
    "args": "{ι : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] (BR : ring_filter_basis R) (B : ι → submodule R M)",
    "doc_string": " Given a ring filter basis on a commutative ring `R`, define a compatibility condition on a family of submodules of a `R`-module `M`. This compatibility condition allows to get a topological module structure.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "isometry.injective",
    "statement": "theorem isometry.injective {β : Type v} [pseudo_emetric_space β] {α : Type u} [emetric_space α] {f : α → β} (h : isometry f) : function.injective f",
    "theorem": "{β : Type v} [pseudo_emetric_space β] {α : Type u} [emetric_space α] {f : α → β} (h : isometry f) : function.injective f",
    "args": "{β : Type v} [pseudo_emetric_space β] {α : Type u} [emetric_space α] {f : α → β} (h : isometry f)",
    "doc_string": "An isometry from an emetric space is injective",
    "kind": "theorem",
    "type": "function.injective f"
  },
  {
    "name": "filter.has_inv",
    "statement": "def filter.has_inv {α : Type u_2} [has_inv α] : has_inv (filter α)",
    "theorem": "{α : Type u_2} [has_inv α] : has_inv (filter α)",
    "args": "{α : Type u_2} [has_inv α]",
    "doc_string": "The inverse of a filter is the pointwise preimage under `⁻¹` of its sets.",
    "kind": "def",
    "type": "has_inv (filter α)"
  },
  {
    "name": "fin.last",
    "statement": "def fin.last (n : ℕ) : fin (n + 1)",
    "theorem": "(n : ℕ) : fin (n + 1)",
    "args": "(n : ℕ)",
    "doc_string": "The greatest value of `fin (n+1)`",
    "kind": "def",
    "type": "fin (n + 1)"
  },
  {
    "name": "local_ring.closed_point",
    "statement": "def local_ring.closed_point (R : Type u) [comm_ring R] [local_ring R] : prime_spectrum R",
    "theorem": "(R : Type u) [comm_ring R] [local_ring R] : prime_spectrum R",
    "args": "(R : Type u) [comm_ring R] [local_ring R]",
    "doc_string": "The closed point in the prime spectrum of a local ring.",
    "kind": "def",
    "type": "prime_spectrum R"
  },
  {
    "name": "ordnode.span",
    "statement": "def ordnode.span {α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α × ordnode α",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α × ordnode α",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p]",
    "doc_string": " O(log n). Split the set into those satisfying and not satisfying the predicate `p`. `p` is required to be antitone, that is, `x < y → p y → p x`.      span (λ x, x < 4) {1, 2, 3, 4, 5} = ({1, 2, 3}, {4, 5})     span (λ x, x > 4) {1, 2, 3, 4, 5} = precondition violation",
    "kind": "def",
    "type": "ordnode α → ordnode α × ordnode α"
  },
  {
    "name": "normalized_gcd_monoid_of_exists_lcm",
    "statement": "def normalized_gcd_monoid_of_exists_lcm {α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d) : normalized_gcd_monoid α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d) : normalized_gcd_monoid α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d)",
    "doc_string": "Define a `normalized_gcd_monoid` structure on a monoid just from the existence of an `lcm`.",
    "kind": "def",
    "type": "normalized_gcd_monoid α"
  },
  {
    "name": "mem_closure_iff_ultrafilter",
    "statement": "theorem mem_closure_iff_ultrafilter {α : Type u} [topological_space α] {s : set α} {x : α} : x ∈ closure s ↔ ∃ (u : ultrafilter α), s ∈ u ∧ ↑u ≤ nhds x",
    "theorem": "{α : Type u} [topological_space α] {s : set α} {x : α} : x ∈ closure s ↔ ∃ (u : ultrafilter α), s ∈ u ∧ ↑u ≤ nhds x",
    "args": "{α : Type u} [topological_space α] {s : set α} {x : α}",
    "doc_string": "`x` belongs to the closure of `s` if and only if some ultrafilter  supported on `s` converges to `x`.",
    "kind": "theorem",
    "type": "x ∈ closure s ↔ ∃ (u : ultrafilter α), s ∈ u ∧ ↑u ≤ nhds x"
  },
  {
    "name": "normed_ring.to_semi_normed_ring",
    "statement": "def normed_ring.to_semi_normed_ring {α : Type u_1} [β : normed_ring α] : semi_normed_ring α",
    "theorem": "{α : Type u_1} [β : normed_ring α] : semi_normed_ring α",
    "args": "{α : Type u_1} [β : normed_ring α]",
    "doc_string": "A normed ring is a seminormed ring.",
    "kind": "def",
    "type": "semi_normed_ring α"
  },
  {
    "name": "free_algebra.char_p",
    "statement": "def free_algebra.char_p {R : Type u_1} {X : Type u_2} [comm_semiring R] (p : ℕ) [char_p R p] : char_p (free_algebra R X) p",
    "theorem": "{R : Type u_1} {X : Type u_2} [comm_semiring R] (p : ℕ) [char_p R p] : char_p (free_algebra R X) p",
    "args": "{R : Type u_1} {X : Type u_2} [comm_semiring R] (p : ℕ) [char_p R p]",
    "doc_string": "If `R` has characteristic `p`, then so does `free_algebra R X`.",
    "kind": "def",
    "type": "char_p (free_algebra R X) p"
  },
  {
    "name": "chart_at_self_eq",
    "statement": "theorem chart_at_self_eq {H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H",
    "theorem": "{H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H",
    "args": "{H : Type u_1} [topological_space H] {x : H}",
    "doc_string": "In the model space, chart_at is always the identity",
    "kind": "theorem",
    "type": "charted_space.chart_at H x = local_homeomorph.refl H"
  },
  {
    "name": "is_add_left_regular_of_add_eq_zero",
    "statement": "theorem is_add_left_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a",
    "theorem": "{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a",
    "args": "{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0)",
    "doc_string": "An element admitting a left additive opposite is add-left-regular.",
    "kind": "theorem",
    "type": "is_add_left_regular a"
  },
  {
    "name": "monoid_algebra.has_one",
    "statement": "def monoid_algebra.has_one {k : Type u₁} {G : Type u₂} [semiring k] [has_one G] : has_one (monoid_algebra k G)",
    "theorem": "{k : Type u₁} {G : Type u₂} [semiring k] [has_one G] : has_one (monoid_algebra k G)",
    "args": "{k : Type u₁} {G : Type u₂} [semiring k] [has_one G]",
    "doc_string": "The unit of the multiplication is `single 1 1`, i.e. the function  that is `1` at `1` and zero elsewhere.",
    "kind": "def",
    "type": "has_one (monoid_algebra k G)"
  },
  {
    "name": "is_least.bdd_below",
    "statement": "theorem is_least.bdd_below {α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a) : bdd_below s",
    "theorem": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a) : bdd_below s",
    "args": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a)",
    "doc_string": "If `s` has a least element, then it is bounded below.",
    "kind": "theorem",
    "type": "bdd_below s"
  },
  {
    "name": "submonoid.simps.coe",
    "statement": "def submonoid.simps.coe {M : Type u_1} [mul_one_class M] (S : submonoid M) : set M",
    "theorem": "{M : Type u_1} [mul_one_class M] (S : submonoid M) : set M",
    "args": "{M : Type u_1} [mul_one_class M] (S : submonoid M)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "perfection_map.of",
    "statement": "theorem perfection_map.of (p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)",
    "args": "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p]",
    "doc_string": "The canonical perfection map from the perfection of a ring.",
    "kind": "theorem",
    "type": "perfection_map p (perfection.coeff R p 0)"
  },
  {
    "name": "category_theory.subobject_simple_iff_is_atom",
    "statement": "theorem category_theory.subobject_simple_iff_is_atom {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ↑Y ↔ is_atom Y",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ↑Y ↔ is_atom Y",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X)",
    "doc_string": "A subobject is simple iff it is an atom in the subobject lattice.",
    "kind": "theorem",
    "type": "category_theory.simple ↑Y ↔ is_atom Y"
  },
  {
    "name": "upper_bounds",
    "statement": "def upper_bounds {α : Type u} [preorder α] (s : set α) : set α",
    "theorem": "{α : Type u} [preorder α] (s : set α) : set α",
    "args": "{α : Type u} [preorder α] (s : set α)",
    "doc_string": "The set of upper bounds of a set.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "canonically_ordered_comm_semiring.zero_lt_one",
    "statement": "theorem canonically_ordered_comm_semiring.zero_lt_one {α : Type u} [canonically_ordered_comm_semiring α] [nontrivial α] : 0 < 1",
    "theorem": "{α : Type u} [canonically_ordered_comm_semiring α] [nontrivial α] : 0 < 1",
    "args": "{α : Type u} [canonically_ordered_comm_semiring α] [nontrivial α]",
    "doc_string": "A version of `zero_lt_one : 0 < 1` for a `canonically_ordered_comm_semiring`.",
    "kind": "theorem",
    "type": "0 < 1"
  },
  {
    "name": "nat.partrec.code.const",
    "statement": "def nat.partrec.code.const  : ℕ → nat.partrec.code",
    "theorem": " : ℕ → nat.partrec.code",
    "args": "",
    "doc_string": "Returns a code for the constant function outputting a particular natural.",
    "kind": "def",
    "type": "ℕ → nat.partrec.code"
  },
  {
    "name": "regular_expression",
    "statement": "inductive regular_expression (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "This is the definition of regular expressions. The names used here is to mirror the definition of a Kleene algebra (https://en.wikipedia.org/wiki/Kleene_algebra). * `0` (`zero`) matches nothing * `1` (`epsilon`) matches only the empty string * `char a` matches only the string 'a' * `star P` matches any finite concatenation of strings which match `P` * `P + Q` (`plus P Q`) matches anything which match `P` or `Q` * `P * Q` (`comp P Q`) matches `x ++ y` if `x` matches `P` and `y` matches `Q`",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "commensurable.commensurator",
    "statement": "def commensurable.commensurator {G : Type u_1} [group G] (H : subgroup G) : subgroup G",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : subgroup G",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": " For `H` a subgroup of `G`, this is the subgroup of all elements `g : G` such that `commensurable (g H g⁻¹) H`",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "tactic.ring_exp.atom",
    "statement": "structure tactic.ring_exp.atom  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The `atom` structure is used to represent atomic expressions: those which `ring_exp` cannot parse any further.  For instance, `a + (a % b)` has `a` and `(a % b)` as atoms. The `ring_exp_eq` tactic does not normalize the subexpressions in atoms, but `ring_exp` does if `ring_exp_eq` was not sufficient.  Atoms in fact represent equivalence classes of expressions, modulo definitional equality. The field `index : ℕ` should be a unique number for each class, while `value : expr` contains a representative of this class. The function `resolve_atom` determines the appropriate atom for a given expression.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "filter.rcomap",
    "statement": "def filter.rcomap {α : Type u} {β : Type v} (r : rel α β) (f : filter β) : filter α",
    "theorem": "{α : Type u} {β : Type v} (r : rel α β) (f : filter β) : filter α",
    "args": "{α : Type u} {β : Type v} (r : rel α β) (f : filter β)",
    "doc_string": " One way of taking the inverse map of a filter under a relation. One generalization of `filter.comap` to relations. Note that `rel.core` generalizes `set.preimage`.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "category_theory.well_powered",
    "statement": "structure category_theory.well_powered (C : Type u₁) [category_theory.category C] : Prop",
    "theorem": "(C : Type u₁) [category_theory.category C] : Prop",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": "A category (with morphisms in `Type v`) is well-powered if `subobject X` is `v`-small for every `X`.  We show in `well_powered_of_mono_over_essentially_small` and `mono_over_essentially_small` that this is the case if and only if `mono_over X` is `v`-essentially small for every `X`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "cardinal.aleph_0",
    "statement": "def cardinal.aleph_0  : cardinal",
    "theorem": " : cardinal",
    "args": "",
    "doc_string": "`ℵ₀` is the smallest infinite cardinal.",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "Pointed.of",
    "statement": "def Pointed.of {X : Type u_1} (point : X) : Pointed",
    "theorem": "{X : Type u_1} (point : X) : Pointed",
    "args": "{X : Type u_1} (point : X)",
    "doc_string": "Turns a point into a pointed type.",
    "kind": "def",
    "type": "Pointed"
  },
  {
    "name": "normalization_monoid",
    "statement": "structure normalization_monoid (α : Type u_2) [cancel_comm_monoid_with_zero α] : Type u_2",
    "theorem": "(α : Type u_2) [cancel_comm_monoid_with_zero α] : Type u_2",
    "args": "(α : Type u_2) [cancel_comm_monoid_with_zero α]",
    "doc_string": " Normalization monoid: multiplying with `norm_unit` gives a normal form for associated elements.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "grade_bounded_order",
    "statement": "structure grade_bounded_order (𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)",
    "theorem": "(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)",
    "args": "(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α]",
    "doc_string": " A `𝕆`-graded order where minimal elements have minimal grades and maximal elements have maximal grades.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "cardinal.sup",
    "statement": "def cardinal.sup {ι : Type u} (f : ι → cardinal) : cardinal",
    "theorem": "{ι : Type u} (f : ι → cardinal) : cardinal",
    "args": "{ι : Type u} (f : ι → cardinal)",
    "doc_string": "The indexed supremum of cardinals is the smallest cardinal above  everything in the family.",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "equiv.add_left",
    "statement": "def equiv.add_left {G : Type u_10} [add_group G] (a : G) : equiv.perm G",
    "theorem": "{G : Type u_10} [add_group G] (a : G) : equiv.perm G",
    "args": "{G : Type u_10} [add_group G] (a : G)",
    "doc_string": "Left addition in an `add_group` is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm G"
  },
  {
    "name": "finset.Ioc",
    "statement": "def finset.Ioc {α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α)",
    "doc_string": "The finset of elements `x` such that `a < x` and `x ≤ b`. Basically `set.Ioc a b` as a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "is_min_filter",
    "statement": "def is_min_filter {α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α)",
    "doc_string": "`is_min_filter f l a` means that `f a ≤ f x` in some `l`-neighborhood of `a`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "tactic.ring_exp.overlap",
    "statement": "inductive tactic.ring_exp.overlap  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Represents the way in which two products are equal except coefficient.  This type is used in the function `add_overlap`. In order to deal with equations of the form `a * 2 + a = 3 * a`, the `add` function will add up overlapping products, turning `a * 2 + a` into `a * 3`. We need to distinguish `a * 2 + a` from `a * 2 + b` in order to do this, and the `overlap` type carries the information on how it overlaps.  The case `none` corresponds to non-overlapping products, e.g. `a * 2 + b`; the case `nonzero` to overlapping products adding to non-zero, e.g. `a * 2 + a` (the `ex prod` field will then look like `a * 3` with a proof that `a * 2 + a = a * 3`); the case `zero` to overlapping products adding to zero, e.g. `a * 2 + a * -2`. We distinguish those two cases because in the second, the whole product reduces to `0`.  A potential extension to the tactic would also do this for the base of exponents, e.g. to show `2^n * 2^n = 4^n`.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "comm_group",
    "statement": "structure comm_group (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": "A commutative group is a group with commutative `(*)`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "is_extensional",
    "statement": "structure is_extensional (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": "An extensional relation is one in which an element is determined by its set  of predecessors. It is named for the `x ∈ y` relation in set theory, whose  extensionality is one of the first axioms of ZFC.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "semiquot",
    "statement": "structure semiquot (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A member of `semiquot α` is classically a nonempty `set α`,  and in the VM is represented by an element of `α`; the relation  between these is that the VM element is required to be a member  of the set `s`. The specific element of `s` that the VM computes  is hidden by a quotient construction, allowing for the representation  of nondeterministic functions.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "lists",
    "statement": "def lists (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " Hereditarily finite list, aka ZFA list. A ZFA list is either an \"atom\" (`b = ff`), corresponding to an element of `α`, or a \"proper\" ZFA list, inductively defined from the empty ZFA list and from appending a ZFA list to a proper ZFA list.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "rel.image",
    "statement": "def rel.image {α : Type u_1} {β : Type u_2} (r : rel α β) (s : set α) : set β",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set α) : set β",
    "args": "{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set α)",
    "doc_string": "Image of a set under a relation",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "padic_val_int.one",
    "statement": "theorem padic_val_int.one {p : ℕ} : padic_val_int p 1 = 0",
    "theorem": "{p : ℕ} : padic_val_int p 1 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_int p 1` is 0 for any `p`.",
    "kind": "theorem",
    "type": "padic_val_int p 1 = 0"
  },
  {
    "name": "max_chain",
    "statement": "def max_chain {α : Type u_1} (r : α → α → Prop) : set α",
    "theorem": "{α : Type u_1} (r : α → α → Prop) : set α",
    "args": "{α : Type u_1} (r : α → α → Prop)",
    "doc_string": "An explicit maximal chain. `max_chain` is taken to be the union of all sets in `chain_closure`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "separated",
    "statement": "def separated {α : Type u} [topological_space α] : set α → set α → Prop",
    "theorem": "{α : Type u} [topological_space α] : set α → set α → Prop",
    "args": "{α : Type u} [topological_space α]",
    "doc_string": "`separated` is a predicate on pairs of sub`set`s of a topological space.  It holds if the two sub`set`s are contained in disjoint open sets.",
    "kind": "def",
    "type": "set α → set α → Prop"
  },
  {
    "name": "finite_exts",
    "statement": "def finite_exts (K : Type u_1) [field K] (L : Type u_2) [field L] [algebra K L] : set (intermediate_field K L)",
    "theorem": "(K : Type u_1) [field K] (L : Type u_2) [field L] [algebra K L] : set (intermediate_field K L)",
    "args": "(K : Type u_1) [field K] (L : Type u_2) [field L] [algebra K L]",
    "doc_string": " Given a field extension `L/K`, `finite_exts K L` is the set of intermediate field extensions `L/E/K` such that `E/K` is finite",
    "kind": "def",
    "type": "set (intermediate_field K L)"
  },
  {
    "name": "category_theory.non_preadditive_abelian",
    "statement": "structure category_theory.non_preadditive_abelian (C : Type u) [category_theory.category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "We call a category `non_preadditive_abelian` if it has a zero object, kernels, cokernels, binary    products and coproducts, and every monomorphism and every epimorphism is normal.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "list.fin_range",
    "statement": "def list.fin_range (n : ℕ) : list (fin n)",
    "theorem": "(n : ℕ) : list (fin n)",
    "args": "(n : ℕ)",
    "doc_string": "All elements of `fin n`, from `0` to `n-1`.",
    "kind": "def",
    "type": "list (fin n)"
  },
  {
    "name": "continuous_pregroupoid",
    "statement": "def continuous_pregroupoid (H : Type u_1) [topological_space H] : pregroupoid H",
    "theorem": "(H : Type u_1) [topological_space H] : pregroupoid H",
    "args": "(H : Type u_1) [topological_space H]",
    "doc_string": "The pregroupoid of all local maps on a topological space `H`",
    "kind": "def",
    "type": "pregroupoid H"
  },
  {
    "name": "left.mul_lt_one_of_lt_of_le",
    "statement": "theorem left.mul_lt_one_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one_of_lt_of_le`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "pgame.list_short",
    "statement": "inductive pgame.list_short  : list pgame → Type (u+1)",
    "theorem": " : list pgame → Type (u+1)",
    "args": "",
    "doc_string": "Evidence that every `pgame` in a list is `short`.",
    "kind": "inductive",
    "type": "list pgame → Type (u+1)"
  },
  {
    "name": "wseq.collect",
    "statement": "def wseq.collect {α : Type u} (s : wseq α) (n : ℕ) : list α",
    "theorem": "{α : Type u} (s : wseq α) (n : ℕ) : list α",
    "args": "{α : Type u} (s : wseq α) (n : ℕ)",
    "doc_string": "Like take, but does not wait for a result. Calculates `n` steps of  computation and returns the sequence computed so far",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "function.semiconj",
    "statement": "def function.semiconj {α : Type u_1} {β : Type u_2} (f : α → β) (ga : α → α) (gb : β → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (ga : α → α) (gb : β → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (ga : α → α) (gb : β → β)",
    "doc_string": " We say that `f : α → β` semiconjugates `ga : α → α` to `gb : β → β` if `f ∘ ga = gb ∘ f`. We use `∀ x, f (ga x) = gb (f x)` as the definition, so given `h : function.semiconj f ga gb` and `a : α`, we have `h a : f (ga a) = gb (f a)` and `h.comp_eq : f ∘ ga = gb ∘ f`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "self_adjoint_matrices_submodule",
    "statement": "def self_adjoint_matrices_submodule {R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J : matrix n n R₃) [decidable_eq n] : submodule R₃ (matrix n n R₃)",
    "theorem": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J : matrix n n R₃) [decidable_eq n] : submodule R₃ (matrix n n R₃)",
    "args": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J : matrix n n R₃) [decidable_eq n]",
    "doc_string": " The submodule of self-adjoint matrices with respect to the bilinear form corresponding to the matrix `J`.",
    "kind": "def",
    "type": "submodule R₃ (matrix n n R₃)"
  },
  {
    "name": "bdd_above",
    "statement": "def bdd_above {α : Type u} [preorder α] (s : set α) : Prop",
    "theorem": "{α : Type u} [preorder α] (s : set α) : Prop",
    "args": "{α : Type u} [preorder α] (s : set α)",
    "doc_string": "A set is bounded above if there exists an upper bound.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "local_homeomorph.refl",
    "statement": "def local_homeomorph.refl (α : Type u_1) [topological_space α] : local_homeomorph α α",
    "theorem": "(α : Type u_1) [topological_space α] : local_homeomorph α α",
    "args": "(α : Type u_1) [topological_space α]",
    "doc_string": "The identity on the whole space as a local homeomorphism.",
    "kind": "def",
    "type": "local_homeomorph α α"
  },
  {
    "name": "is_min.pred_eq",
    "statement": "theorem is_min.pred_eq {α : Type u_1} [partial_order α] [pred_order α] {a : α} : is_min a → order.pred a = a",
    "theorem": "{α : Type u_1} [partial_order α] [pred_order α] {a : α} : is_min a → order.pred a = a",
    "args": "{α : Type u_1} [partial_order α] [pred_order α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of order.pred_eq_iff_is_min`.",
    "kind": "theorem",
    "type": "is_min a → order.pred a = a"
  },
  {
    "name": "module_filter_basis.inhabited",
    "statement": "def module_filter_basis.inhabited {R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] [discrete_topology R] : inhabited (module_filter_basis R M)",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] [discrete_topology R] : inhabited (module_filter_basis R M)",
    "args": "{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] [discrete_topology R]",
    "doc_string": " If `R` is discrete then the trivial additive group filter basis on any `R`-module is a module filter basis.",
    "kind": "def",
    "type": "inhabited (module_filter_basis R M)"
  },
  {
    "name": "valuation.supp",
    "statement": "def valuation.supp {R : Type u_2} {Γ₀ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Γ₀] (v : valuation R Γ₀) : ideal R",
    "theorem": "{R : Type u_2} {Γ₀ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Γ₀] (v : valuation R Γ₀) : ideal R",
    "args": "{R : Type u_2} {Γ₀ : Type u_3} [comm_ring R] [linear_ordered_comm_monoid_with_zero Γ₀] (v : valuation R Γ₀)",
    "doc_string": "The support of a valuation `v : R → Γ₀` is the ideal of `R` where `v` vanishes.",
    "kind": "def",
    "type": "ideal R"
  },
  {
    "name": "pos_num.sub",
    "statement": "def pos_num.sub (a b : pos_num) : pos_num",
    "theorem": "(a b : pos_num) : pos_num",
    "args": "(a b : pos_num)",
    "doc_string": "Subtraction of `pos_num`s, where if `a < b`, then `a - b = 1`.",
    "kind": "def",
    "type": "pos_num"
  },
  {
    "name": "filter.division_monoid",
    "statement": "def filter.division_monoid {α : Type u_2} [division_monoid α] : division_monoid (filter α)",
    "theorem": "{α : Type u_2} [division_monoid α] : division_monoid (filter α)",
    "args": "{α : Type u_2} [division_monoid α]",
    "doc_string": "`filter α` is a division monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "division_monoid (filter α)"
  },
  {
    "name": "list.is_prefix",
    "statement": "def list.is_prefix {α : Type u_1} (l₁ l₂ : list α) : Prop",
    "theorem": "{α : Type u_1} (l₁ l₂ : list α) : Prop",
    "args": "{α : Type u_1} (l₁ l₂ : list α)",
    "doc_string": "`is_prefix l₁ l₂`, or `l₁ <+: l₂`, means that `l₁` is a prefix of `l₂`,  that is, `l₂` has the form `l₁ ++ t` for some `t`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ratfunc.neg",
    "statement": "def ratfunc.neg {K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K]",
    "doc_string": "Additive inverse of a rational function.",
    "kind": "def",
    "type": "ratfunc K → ratfunc K"
  },
  {
    "name": "free_group.reduce.sound",
    "statement": "theorem free_group.reduce.sound {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂)",
    "doc_string": " If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined.",
    "kind": "theorem",
    "type": "free_group.reduce L₁ = free_group.reduce L₂"
  },
  {
    "name": "subtype.edist_eq",
    "statement": "theorem subtype.edist_eq {α : Type u} [pseudo_emetric_space α] {p : α → Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist ↑x ↑y",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {p : α → Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist ↑x ↑y",
    "args": "{α : Type u} [pseudo_emetric_space α] {p : α → Prop} (x y : subtype p)",
    "doc_string": " The extended psuedodistance on a subset of a pseudoemetric space is the restriction of the original pseudodistance, by definition",
    "kind": "theorem",
    "type": "has_edist.edist x y = has_edist.edist ↑x ↑y"
  },
  {
    "name": "closure_Ioc",
    "statement": "theorem closure_Ioc {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioc a b) = set.Icc a b",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioc a b) = set.Icc a b",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b)",
    "doc_string": "The closure of the interval `(a, b]` is the closed interval `[a, b]`.",
    "kind": "theorem",
    "type": "closure (set.Ioc a b) = set.Icc a b"
  },
  {
    "name": "direct_sum.gsemiring",
    "statement": "structure direct_sum.gsemiring {ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [add_monoid ι] [Π (i : ι), add_comm_monoid (A i)] : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [add_monoid ι] [Π (i : ι), add_comm_monoid (A i)] : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [add_monoid ι] [Π (i : ι), add_comm_monoid (A i)]",
    "doc_string": "A graded version of `semiring`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "zero_lt.right.one_lt_mul_of_le_of_lt",
    "statement": "theorem zero_lt.right.one_lt_mul_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "category_theory.has_forget₂",
    "statement": "structure category_theory.has_forget₂ (C : Type v) (D : Type v') [category_theory.category C] [category_theory.concrete_category C] [category_theory.category D] [category_theory.concrete_category D] : Type (max u_1 u_2 v v')",
    "theorem": "(C : Type v) (D : Type v') [category_theory.category C] [category_theory.concrete_category C] [category_theory.category D] [category_theory.concrete_category D] : Type (max u_1 u_2 v v')",
    "args": "(C : Type v) (D : Type v') [category_theory.category C] [category_theory.concrete_category C] [category_theory.category D] [category_theory.concrete_category D]",
    "doc_string": "`has_forget₂ C D`, where `C` and `D` are both concrete categories, provides a functor `forget₂ C D : C ⥤ D` and a proof that `forget₂ ⋙ (forget D) = forget C`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 v v')"
  },
  {
    "name": "tactic.uncleared_goal",
    "statement": "def tactic.uncleared_goal  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A metavariable representing a subgoal, together with a list of local constants to clear.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "submodule.dual_annihilator_comap",
    "statement": "def submodule.dual_annihilator_comap {R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (Φ : submodule R (module.dual R M)) : submodule R M",
    "theorem": "{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (Φ : submodule R (module.dual R M)) : submodule R M",
    "args": "{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (Φ : submodule R (module.dual R M))",
    "doc_string": "The pullback of a submodule in the dual space along the evaluation map.",
    "kind": "def",
    "type": "submodule R M"
  },
  {
    "name": "lazy_list.mfirst",
    "statement": "def lazy_list.mfirst {m : Type u_1 → Type u_2} [alternative m] {α : Type u_3} {β : Type u_1} (f : α → m β) : lazy_list α → m β",
    "theorem": "{m : Type u_1 → Type u_2} [alternative m] {α : Type u_3} {β : Type u_1} (f : α → m β) : lazy_list α → m β",
    "args": "{m : Type u_1 → Type u_2} [alternative m] {α : Type u_3} {β : Type u_1} (f : α → m β)",
    "doc_string": " Try applying function `f` to every element of a `lazy_list` and return the result of the first attempt that succeeds.",
    "kind": "def",
    "type": "lazy_list α → m β"
  },
  {
    "name": "is_atomistic",
    "statement": "structure is_atomistic (α : Type u_1) [complete_lattice α] : Prop",
    "theorem": "(α : Type u_1) [complete_lattice α] : Prop",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": "A lattice is atomistic iff every element is a `Sup` of a set of atoms.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "DistribLattice",
    "statement": "def DistribLattice  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of distributive lattices.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "is_noetherian.finset_basis_index",
    "statement": "def is_noetherian.finset_basis_index (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : finset V",
    "theorem": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V] : finset V",
    "args": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [is_noetherian K V]",
    "doc_string": " In a noetherian module over a division ring, there exists a finite basis. This is the indexing `finset`.",
    "kind": "def",
    "type": "finset V"
  },
  {
    "name": "algebraic_geometry.Scheme.category_theory.category",
    "statement": "def algebraic_geometry.Scheme.category_theory.category  : category_theory.category algebraic_geometry.Scheme",
    "theorem": " : category_theory.category algebraic_geometry.Scheme",
    "args": "",
    "doc_string": "Schemes are a full subcategory of locally ringed spaces.",
    "kind": "def",
    "type": "category_theory.category algebraic_geometry.Scheme"
  },
  {
    "name": "no_top_order",
    "statement": "structure no_top_order (α : Type u_2) [has_le α] : Prop",
    "theorem": "(α : Type u_2) [has_le α] : Prop",
    "args": "(α : Type u_2) [has_le α]",
    "doc_string": "Order without top elements.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "with_top.map",
    "statement": "def with_top.map {α : Type u} {β : Type v} (f : α → β) : with_top α → with_top β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : with_top α → with_top β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": "Lift a map `f : α → β` to `with_top α → with_top β`. Implemented using `option.map`.",
    "kind": "def",
    "type": "with_top α → with_top β"
  },
  {
    "name": "semigroup_has_dvd",
    "statement": "def semigroup_has_dvd {α : Type u_1} [semigroup α] : has_dvd α",
    "theorem": "{α : Type u_1} [semigroup α] : has_dvd α",
    "args": "{α : Type u_1} [semigroup α]",
    "doc_string": "There are two possible conventions for divisibility, which coincide in a `comm_monoid`.    This matches the convention for ordinals.",
    "kind": "def",
    "type": "has_dvd α"
  },
  {
    "name": "dense",
    "statement": "def dense {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "A set is dense in a topological space if every point belongs to its closure.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "metric.diam_nonneg",
    "statement": "theorem metric.diam_nonneg {α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α}",
    "doc_string": "The diameter of a set is always nonnegative",
    "kind": "theorem",
    "type": "0 ≤ metric.diam s"
  },
  {
    "name": "add_subgroup.is_open_of_zero_mem_interior",
    "statement": "theorem add_subgroup.is_open_of_zero_mem_interior {G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H) : is_open ↑H",
    "theorem": "{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H) : is_open ↑H",
    "args": "{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H)",
    "doc_string": "If a subgroup of an additive topological group has `0` in its interior, then it is open.",
    "kind": "theorem",
    "type": "is_open ↑H"
  },
  {
    "name": "Set.diff",
    "statement": "def Set.diff (x y : Set) : Set",
    "theorem": "(x y : Set) : Set",
    "args": "(x y : Set)",
    "doc_string": "The set difference operation",
    "kind": "def",
    "type": "Set"
  },
  {
    "name": "cmp_le",
    "statement": "def cmp_le {α : Type u_1} [has_le α] [decidable_rel has_le.le] (x y : α) : ordering",
    "theorem": "{α : Type u_1} [has_le α] [decidable_rel has_le.le] (x y : α) : ordering",
    "args": "{α : Type u_1} [has_le α] [decidable_rel has_le.le] (x y : α)",
    "doc_string": " Like `cmp`, but uses a `≤` on the type instead of `<`. Given two elements `x` and `y`, returns a three-way comparison result `ordering`.",
    "kind": "def",
    "type": "ordering"
  },
  {
    "name": "star_div",
    "statement": "theorem star_div {R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "theorem": "{R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y",
    "args": "{R : Type u} [comm_group R] [star_semigroup R] (x y : R)",
    "doc_string": "When multiplication is commutative, `star` preserves division.",
    "kind": "theorem",
    "type": "has_star.star (x / y) = has_star.star x / has_star.star y"
  },
  {
    "name": "localization.mul",
    "statement": "def localization.mul {M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S → localization S → localization S",
    "theorem": "{M : Type u_1} [comm_monoid M] (S : submonoid M) : localization S → localization S → localization S",
    "args": "{M : Type u_1} [comm_monoid M] (S : submonoid M)",
    "doc_string": "Multiplication in a localization is defined as `⟨a, b⟩ * ⟨c, d⟩ = ⟨a * c, b * d⟩`.",
    "kind": "def",
    "type": "localization S → localization S → localization S"
  },
  {
    "name": "is_smul_regular.zero",
    "statement": "theorem is_smul_regular.zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M]",
    "doc_string": "The element `0` is `M`-regular when `M` is trivial.",
    "kind": "theorem",
    "type": "is_smul_regular M 0"
  },
  {
    "name": "simple_graph.clique_free",
    "statement": "def simple_graph.clique_free {α : Type u_1} (G : simple_graph α) (n : ℕ) : Prop",
    "theorem": "{α : Type u_1} (G : simple_graph α) (n : ℕ) : Prop",
    "args": "{α : Type u_1} (G : simple_graph α) (n : ℕ)",
    "doc_string": "`G.clique_free n` means that `G` has no `n`-cliques.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "embedding",
    "statement": "structure embedding {α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β)",
    "doc_string": "A function between topological spaces is an embedding if it is injective,  and for all `s : set α`, `s` is open iff it is the preimage of an open set.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "cancel_comm_monoid_with_zero",
    "statement": "structure cancel_comm_monoid_with_zero (M₀ : Type u_4) : Type u_4",
    "theorem": "(M₀ : Type u_4) : Type u_4",
    "args": "(M₀ : Type u_4)",
    "doc_string": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element, `0` is left and right absorbing,  and left/right multiplication by a non-zero element is injective.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "is_trivial_topological_fiber_bundle_snd",
    "statement": "theorem is_trivial_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The second projection in a product is a trivial topological fiber bundle.",
    "kind": "theorem",
    "type": "is_trivial_topological_fiber_bundle F prod.snd"
  },
  {
    "name": "cast_num",
    "statement": "def cast_num {α : Type u_1} [has_one α] [has_add α] [z : has_zero α] : num → α",
    "theorem": "{α : Type u_1} [has_one α] [has_add α] [z : has_zero α] : num → α",
    "args": "{α : Type u_1} [has_one α] [has_add α] [z : has_zero α]",
    "doc_string": "`cast_num` casts a `num` into any type which has `0`, `1` and `+`.",
    "kind": "def",
    "type": "num → α"
  },
  {
    "name": "is_galois",
    "statement": "structure is_galois (F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : Prop",
    "theorem": "(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E] : Prop",
    "args": "(F : Type u_1) [field F] (E : Type u_2) [field E] [algebra F E]",
    "doc_string": " A field extension E/F is galois if it is both separable and normal. Note that in mathlib a separable extension of fields is by definition algebraic.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "omega.clause",
    "statement": "def omega.clause  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " (([t₁,...tₘ],[s₁,...,sₙ]) : clause) encodes the constraints 0 = ⟦t₁⟧ ∧ ... ∧ 0 = ⟦tₘ⟧ ∧ 0 ≤ ⟦s₁⟧ ∧ ... ∧ 0 ≤ ⟦sₙ⟧, where ⟦t⟧ is the value of (t : term).",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "char_zero_of_exp_char_one",
    "statement": "theorem char_zero_of_exp_char_one (R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1] : p = 0",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1] : p = 0",
    "args": "(R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1]",
    "doc_string": "The exponential characteristic is one if the characteristic is zero.",
    "kind": "theorem",
    "type": "p = 0"
  },
  {
    "name": "powers.one_mem",
    "statement": "theorem powers.one_mem {M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x",
    "theorem": "{M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x",
    "args": "{M : Type u_1} [monoid M] {x : M}",
    "doc_string": "1 is in the set of natural number powers of an element of a monoid.",
    "kind": "theorem",
    "type": "1 ∈ powers x"
  },
  {
    "name": "closed_embedding",
    "statement": "structure closed_embedding {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β)",
    "doc_string": "A closed embedding is an embedding with closed image.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "discrete_topology",
    "statement": "structure discrete_topology (α : Type u_1) [t : topological_space α] : Prop",
    "theorem": "(α : Type u_1) [t : topological_space α] : Prop",
    "args": "(α : Type u_1) [t : topological_space α]",
    "doc_string": "A topological space is discrete if every set is open, that is,  its topology equals the discrete topology `⊥`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "linear_ordered_comm_monoid",
    "statement": "structure linear_ordered_comm_monoid (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A linearly ordered commutative monoid.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "set.division_comm_monoid",
    "statement": "def set.division_comm_monoid {α : Type u_2} [division_comm_monoid α] : division_comm_monoid (set α)",
    "theorem": "{α : Type u_2} [division_comm_monoid α] : division_comm_monoid (set α)",
    "args": "{α : Type u_2} [division_comm_monoid α]",
    "doc_string": "`set α` is a commutative division monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "division_comm_monoid (set α)"
  },
  {
    "name": "discrete_quotient.setoid",
    "statement": "def discrete_quotient.setoid {X : Type u_1} [topological_space X] (S : discrete_quotient X) : setoid X",
    "theorem": "{X : Type u_1} [topological_space X] (S : discrete_quotient X) : setoid X",
    "args": "{X : Type u_1} [topological_space X] (S : discrete_quotient X)",
    "doc_string": "The setoid whose quotient yields the discrete quotient.",
    "kind": "def",
    "type": "setoid X"
  },
  {
    "name": "representation.invariants",
    "statement": "def representation.invariants {k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (ρ : representation k G V) : submodule k V",
    "theorem": "{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (ρ : representation k G V) : submodule k V",
    "args": "{k : Type u_1} {G : Type u_2} {V : Type u_3} [comm_semiring k] [group G] [add_comm_monoid V] [module k V] (ρ : representation k G V)",
    "doc_string": "The subspace of invariants, consisting of the vectors fixed by all elements of `G`.",
    "kind": "def",
    "type": "submodule k V"
  },
  {
    "name": "set.pairwise_disjoint",
    "statement": "def set.pairwise_disjoint {α : Type u_1} {ι : Type u_2} [semilattice_inf α] [order_bot α] (s : set ι) (f : ι → α) : Prop",
    "theorem": "{α : Type u_1} {ι : Type u_2} [semilattice_inf α] [order_bot α] (s : set ι) (f : ι → α) : Prop",
    "args": "{α : Type u_1} {ι : Type u_2} [semilattice_inf α] [order_bot α] (s : set ι) (f : ι → α)",
    "doc_string": " A set is `pairwise_disjoint` under `f`, if the images of any distinct two elements under `f` are disjoint.  `s.pairwise disjoint` is (definitionally) the same as `s.pairwise_disjoint id`. We prefer the latter in order to allow dot notation on `set.pairwise_disjoint`, even though the former unfolds more nicely.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pmf.pure",
    "statement": "def pmf.pure {α : Type u_1} (a : α) : pmf α",
    "theorem": "{α : Type u_1} (a : α) : pmf α",
    "args": "{α : Type u_1} (a : α)",
    "doc_string": "The pure `pmf` is the `pmf` where all the mass lies in one point.  The value of `pure a` is `1` at `a` and `0` elsewhere.",
    "kind": "def",
    "type": "pmf α"
  },
  {
    "name": "has_le.le.trans'",
    "statement": "theorem has_le.le.trans' {α : Type u} [preorder α] {a b c : α} : b ≤ c → a ≤ b → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b ≤ c → a ≤ b → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of le_trans'`.",
    "kind": "theorem",
    "type": "b ≤ c → a ≤ b → a ≤ c"
  },
  {
    "name": "fintype.sum_left",
    "statement": "def fintype.sum_left {α : Type u_1} {β : Type u_2} [fintype (α ⊕ β)] : fintype α",
    "theorem": "{α : Type u_1} {β : Type u_2} [fintype (α ⊕ β)] : fintype α",
    "args": "{α : Type u_1} {β : Type u_2} [fintype (α ⊕ β)]",
    "doc_string": " Given that `α ⊕ β` is a fintype, `α` is also a fintype. This is non-computable as it uses that `sum.inl` is an injection, but there's no clear inverse if `α` is empty.",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "Scott",
    "statement": "def Scott (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A Scott topological space is defined on preorders such that their open sets, seen as a function `α → Prop`, preserves the joins of ω-chains",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "category_theory.limits.has_zero_object_of_has_initial_object",
    "statement": "theorem category_theory.limits.has_zero_object_of_has_initial_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C]",
    "doc_string": "If there are zero morphisms, any initial object is a zero object.",
    "kind": "theorem",
    "type": "category_theory.limits.has_zero_object C"
  },
  {
    "name": "interactive.executor",
    "statement": "structure interactive.executor (m : Type → Type u) [monad m] : Type (max 1 u)",
    "theorem": "(m : Type → Type u) [monad m] : Type (max 1 u)",
    "args": "(m : Type → Type u) [monad m]",
    "doc_string": "Typeclass for custom interaction monads, which provides    the information required to convert an interactive-mode    construction to a `tactic` which can actually be executed.     Given a `[monad m]`, `execute_with` explains how to turn a `begin ... end`    block, or a `by ...` statement into a `tactic α` which can actually be    executed. The `inhabited` first argument facilitates the passing of an    optional configuration parameter `config`, using the syntax:    ```lean    begin [custom_monad] with config,        ...    end    ```",
    "kind": "structure",
    "type": "Type (max 1 u)"
  },
  {
    "name": "multilinear_map.mk_pi_algebra",
    "statement": "def multilinear_map.mk_pi_algebra (R : Type u) (ι : Type u') [decidable_eq ι] [comm_semiring R] (A : Type u_1) [comm_semiring A] [algebra R A] [fintype ι] : multilinear_map R (λ (i : ι), A) A",
    "theorem": "(R : Type u) (ι : Type u') [decidable_eq ι] [comm_semiring R] (A : Type u_1) [comm_semiring A] [algebra R A] [fintype ι] : multilinear_map R (λ (i : ι), A) A",
    "args": "(R : Type u) (ι : Type u') [decidable_eq ι] [comm_semiring R] (A : Type u_1) [comm_semiring A] [algebra R A] [fintype ι]",
    "doc_string": " Given an `R`-algebra `A`, `mk_pi_algebra` is the multilinear map on `A^ι` associating to `m` the product of all the `m i`.  See also `multilinear_map.mk_pi_algebra_fin` for a version that works with a non-commutative algebra `A` but requires `ι = fin n`.",
    "kind": "def",
    "type": "multilinear_map R (λ (i : ι), A) A"
  },
  {
    "name": "add_subgroup.is_complement'",
    "statement": "def add_subgroup.is_complement' {G : Type u_1} [add_group G] (H K : add_subgroup G) : Prop",
    "theorem": "{G : Type u_1} [add_group G] (H K : add_subgroup G) : Prop",
    "args": "{G : Type u_1} [add_group G] (H K : add_subgroup G)",
    "doc_string": "`H` and `K` are complements if `(*) : H × K → G` is a bijection",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "Compactum.of_topological_space",
    "statement": "def Compactum.of_topological_space (X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : Compactum",
    "theorem": "(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : Compactum",
    "args": "(X : Type u_1) [topological_space X] [compact_space X] [t2_space X]",
    "doc_string": "Given any compact Hausdorff space, we construct a Compactum.",
    "kind": "def",
    "type": "Compactum"
  },
  {
    "name": "is_fw_invariant_iff_is_invariant",
    "statement": "theorem is_fw_invariant_iff_is_invariant {τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} : is_fw_invariant ϕ s ↔ is_invariant ϕ s",
    "theorem": "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} : is_fw_invariant ϕ s ↔ is_invariant ϕ s",
    "args": "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α}",
    "doc_string": " If `τ` is a `canonically_ordered_add_monoid` (e.g., `ℕ` or `ℝ≥0`), then the notions `is_fw_invariant` and `is_invariant` are equivalent.",
    "kind": "theorem",
    "type": "is_fw_invariant ϕ s ↔ is_invariant ϕ s"
  },
  {
    "name": "emetric.Hausdorff_edist_self",
    "statement": "theorem emetric.Hausdorff_edist_self {α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s s = 0",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s s = 0",
    "args": "{α : Type u} [pseudo_emetric_space α] {s : set α}",
    "doc_string": "The Hausdorff edistance of a set to itself vanishes",
    "kind": "theorem",
    "type": "emetric.Hausdorff_edist s s = 0"
  },
  {
    "name": "denumerable.finset",
    "statement": "def denumerable.finset {α : Type u_1} [denumerable α] : denumerable (finset α)",
    "theorem": "{α : Type u_1} [denumerable α] : denumerable (finset α)",
    "args": "{α : Type u_1} [denumerable α]",
    "doc_string": " If `α` is denumerable, then so is `finset α`. Warning: this is *not* the same encoding as used in `finset.encodable`.",
    "kind": "def",
    "type": "denumerable (finset α)"
  },
  {
    "name": "sym_alg",
    "statement": "def sym_alg (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "The symmetrized algebra has the same underlying space as the original algebra.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "lie_algebra.e₇",
    "statement": "def lie_algebra.e₇ (R : Type u) [comm_ring R] : Type u",
    "theorem": "(R : Type u) [comm_ring R] : Type u",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "The exceptional split Lie algebra of type e₇.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "sym",
    "statement": "def sym (α : Type u_1) (n : ℕ) : Type u_1",
    "theorem": "(α : Type u_1) (n : ℕ) : Type u_1",
    "args": "(α : Type u_1) (n : ℕ)",
    "doc_string": "The nth symmetric power is n-tuples up to permutation.  We define it as a subtype of `multiset` since these are well developed in the library.  We also give a definition `sym.sym'` in terms of vectors, and we show these are equivalent in `sym.sym_equiv_sym'`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "turing.to_partrec.code.id",
    "statement": "def turing.to_partrec.code.id  : turing.to_partrec.code",
    "theorem": " : turing.to_partrec.code",
    "args": "",
    "doc_string": "`id` is the identity function: `id v = v`.",
    "kind": "def",
    "type": "turing.to_partrec.code"
  },
  {
    "name": "seq.nth",
    "statement": "def seq.nth {α : Type u} : seq α → ℕ → option α",
    "theorem": "{α : Type u} : seq α → ℕ → option α",
    "args": "{α : Type u}",
    "doc_string": "Get the nth element of a sequence (if it exists)",
    "kind": "def",
    "type": "seq α → ℕ → option α"
  },
  {
    "name": "set_like.fintype",
    "statement": "def set_like.fintype {A : Type u_1} {B : Type u_2} [fintype B] [set_like A B] : fintype A",
    "theorem": "{A : Type u_1} {B : Type u_2} [fintype B] [set_like A B] : fintype A",
    "args": "{A : Type u_1} {B : Type u_2} [fintype B] [set_like A B]",
    "doc_string": " TODO: It should be possible to obtain a computable version of this for most set_like objects. If we add those instances, we should remove this one.",
    "kind": "def",
    "type": "fintype A"
  },
  {
    "name": "category_theory.bundled",
    "statement": "structure category_theory.bundled (c : Type u → Type v) : Type (max (u+1) v)",
    "theorem": "(c : Type u → Type v) : Type (max (u+1) v)",
    "args": "(c : Type u → Type v)",
    "doc_string": " `bundled` is a type bundled with a type class instance for that type. Only the type class is exposed as a parameter.",
    "kind": "structure",
    "type": "Type (max (u+1) v)"
  },
  {
    "name": "turing.list_blank.modify_nth",
    "statement": "def turing.list_blank.modify_nth {Γ : Type u_1} [inhabited Γ] (f : Γ → Γ) : ℕ → turing.list_blank Γ → turing.list_blank Γ",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (f : Γ → Γ) : ℕ → turing.list_blank Γ → turing.list_blank Γ",
    "args": "{Γ : Type u_1} [inhabited Γ] (f : Γ → Γ)",
    "doc_string": "Apply a function to a value stored at the nth position of the list.",
    "kind": "def",
    "type": "ℕ → turing.list_blank Γ → turing.list_blank Γ"
  },
  {
    "name": "StoneCech_obj",
    "statement": "def StoneCech_obj (X : Top) : CompHaus",
    "theorem": "(X : Top) : CompHaus",
    "args": "(X : Top)",
    "doc_string": "(Implementation) The object part of the compactification functor from topological spaces to compact Hausdorff spaces.",
    "kind": "def",
    "type": "CompHaus"
  },
  {
    "name": "nat.exists_infinite_primes",
    "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p",
    "theorem": "(n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p",
    "args": "(n : ℕ)",
    "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.",
    "kind": "theorem",
    "type": "∃ (p : ℕ), n ≤ p ∧ nat.prime p"
  },
  {
    "name": "local_homeomorph.restr",
    "statement": "def local_homeomorph.restr {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) : local_homeomorph α β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) : local_homeomorph α β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α)",
    "doc_string": " Restricting a local homeomorphism `e` to `e.source ∩ interior s`. We use the interior to make sure that the restriction is well defined whatever the set s, since local homeomorphisms are by definition defined on open sets. In applications where `s` is open, this coincides with the restriction of local equivalences",
    "kind": "def",
    "type": "local_homeomorph α β"
  },
  {
    "name": "neg_zero'",
    "statement": "theorem neg_zero' {α : Type u} [mul_zero_class α] [has_distrib_neg α] : -0 = 0",
    "theorem": "{α : Type u} [mul_zero_class α] [has_distrib_neg α] : -0 = 0",
    "args": "{α : Type u} [mul_zero_class α] [has_distrib_neg α]",
    "doc_string": "Prefer `neg_zero` if `subtraction_monoid` is available.",
    "kind": "theorem",
    "type": "-0 = 0"
  },
  {
    "name": "submodule.module_set",
    "statement": "def submodule.module_set (R : Type u) [comm_semiring R] (A : Type v) [comm_semiring A] [algebra R A] : module (set_semiring A) (submodule R A)",
    "theorem": "(R : Type u) [comm_semiring R] (A : Type v) [comm_semiring A] [algebra R A] : module (set_semiring A) (submodule R A)",
    "args": "(R : Type u) [comm_semiring R] (A : Type v) [comm_semiring A] [algebra R A]",
    "doc_string": "R-submodules of the R-algebra A are a module over `set A`.",
    "kind": "def",
    "type": "module (set_semiring A) (submodule R A)"
  },
  {
    "name": "nat.fib",
    "statement": "def nat.fib (n : ℕ) : ℕ",
    "theorem": "(n : ℕ) : ℕ",
    "args": "(n : ℕ)",
    "doc_string": "Implementation of the fibonacci sequence satisfying `fib 0 = 0, fib 1 = 1, fib (n + 2) = fib n + fib (n + 1)`.  *Note:* We use a stream iterator for better performance when compared to the naive recursive implementation.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "generic_point",
    "statement": "def generic_point (α : Type u_1) [topological_space α] [quasi_sober α] [irreducible_space α] : α",
    "theorem": "(α : Type u_1) [topological_space α] [quasi_sober α] [irreducible_space α] : α",
    "args": "(α : Type u_1) [topological_space α] [quasi_sober α] [irreducible_space α]",
    "doc_string": "A generic point of a sober irreducible space.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "nat.ceil",
    "statement": "def nat.ceil {α : Type u_1} [ordered_semiring α] [floor_semiring α] : α → ℕ",
    "theorem": "{α : Type u_1} [ordered_semiring α] [floor_semiring α] : α → ℕ",
    "args": "{α : Type u_1} [ordered_semiring α] [floor_semiring α]",
    "doc_string": "`⌈a⌉₊` is the least natural `n` such that `a ≤ n`",
    "kind": "def",
    "type": "α → ℕ"
  },
  {
    "name": "topological_space.first_countable_topology.sequential_space",
    "statement": "def topological_space.first_countable_topology.sequential_space {X : Type u_1} [topological_space X] [topological_space.first_countable_topology X] : sequential_space X",
    "theorem": "{X : Type u_1} [topological_space X] [topological_space.first_countable_topology X] : sequential_space X",
    "args": "{X : Type u_1} [topological_space X] [topological_space.first_countable_topology X]",
    "doc_string": "Every first-countable space is sequential.",
    "kind": "def",
    "type": "sequential_space X"
  },
  {
    "name": "polynomial.has_separable_contraction",
    "statement": "def polynomial.has_separable_contraction {F : Type} [comm_semiring F] (q : ℕ) (f : polynomial F) : Prop",
    "theorem": "{F : Type} [comm_semiring F] (q : ℕ) (f : polynomial F) : Prop",
    "args": "{F : Type} [comm_semiring F] (q : ℕ) (f : polynomial F)",
    "doc_string": "The condition of having a separable contration.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_finite_products",
    "statement": "structure category_theory.limits.has_finite_products (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category has finite products if there is a chosen limit for every diagram with shape `discrete J`, where we have `[fintype J]`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "complete_linear_order",
    "statement": "structure complete_linear_order (α : Type u_8) : Type u_8",
    "theorem": "(α : Type u_8) : Type u_8",
    "args": "(α : Type u_8)",
    "doc_string": "A complete linear order is a linear order whose lattice structure is complete.",
    "kind": "structure",
    "type": "Type u_8"
  },
  {
    "name": "homological_complex",
    "statement": "structure homological_complex {ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape ι) : Type (max u u_1 v)",
    "theorem": "{ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape ι) : Type (max u u_1 v)",
    "args": "{ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (c : complex_shape ι)",
    "doc_string": "A `homological_complex V c` with a \"shape\" controlled by `c : complex_shape ι` has chain groups `X i` (objects in `V`) indexed by `i : ι`, and a differential `d i j` whenever `c.rel i j`.  We in fact ask for differentials `d i j` for all `i j : ι`, but have a field `shape'` requiring that these are zero when not allowed by `c`. This avoids a lot of dependent type theory hell!  The composite of any two differentials `d i j ≫ d j k` must be zero.",
    "kind": "structure",
    "type": "Type (max u u_1 v)"
  },
  {
    "name": "lazy_list.join",
    "statement": "def lazy_list.join {α : Type u} : lazy_list (lazy_list α) → lazy_list α",
    "theorem": "{α : Type u} : lazy_list (lazy_list α) → lazy_list α",
    "args": "{α : Type u}",
    "doc_string": "The monadic join operation for lazy lists.",
    "kind": "def",
    "type": "lazy_list (lazy_list α) → lazy_list α"
  },
  {
    "name": "category_theory.limits.types.has_colimits_of_size",
    "statement": "def category_theory.limits.types.has_colimits_of_size  : category_theory.limits.has_colimits_of_size (Type (max v u))",
    "theorem": " : category_theory.limits.has_colimits_of_size (Type (max v u))",
    "args": "",
    "doc_string": "The category of types has all colimits.  See <https://stacks.math.columbia.edu/tag/002U>.",
    "kind": "def",
    "type": "category_theory.limits.has_colimits_of_size (Type (max v u))"
  },
  {
    "name": "add_commute.refl",
    "statement": "theorem add_commute.refl {S : Type u_1} [has_add S] (a : S) : add_commute a a",
    "theorem": "{S : Type u_1} [has_add S] (a : S) : add_commute a a",
    "args": "{S : Type u_1} [has_add S] (a : S)",
    "doc_string": "Any element commutes with itself.",
    "kind": "theorem",
    "type": "add_commute a a"
  },
  {
    "name": "galois_coinsertion",
    "statement": "structure galois_coinsertion {α : Type u} {β : Type v} [preorder α] [preorder β] (l : α → β) (u : β → α) : Type (max u v)",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (l : α → β) (u : β → α) : Type (max u v)",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (l : α → β) (u : β → α)",
    "doc_string": " A Galois coinsertion is a Galois connection where `u ∘ l = id`. It also contains a constructive choice function, to give better definitional equalities when lifting order structures. Dual to `galois_insertion`",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "function.injective",
    "statement": "def function.injective {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "theorem": "{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "args": "{α : Sort u₁} {β : Sort u₂} (f : α → β)",
    "doc_string": "A function `f : α → β` is called injective if `f x = f y` implies `x = y`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bitvec",
    "statement": "def bitvec (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": "`bitvec n` is a `vector` of `bool` with length `n`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "filter.monad",
    "statement": "def filter.monad  : monad filter",
    "theorem": " : monad filter",
    "args": "",
    "doc_string": "The monad structure on filters.",
    "kind": "def",
    "type": "monad filter"
  },
  {
    "name": "add_subgroup.set_normalizer",
    "statement": "def add_subgroup.set_normalizer {G : Type u_1} [add_group G] (S : set G) : add_subgroup G",
    "theorem": "{G : Type u_1} [add_group G] (S : set G) : add_subgroup G",
    "args": "{G : Type u_1} [add_group G] (S : set G)",
    "doc_string": "The `set_normalizer` of `S` is the subgroup of `G` whose elements satisfy `g+S-g=S`.",
    "kind": "def",
    "type": "add_subgroup G"
  },
  {
    "name": "list.func.neg",
    "statement": "def list.func.neg {α : Type u} [has_neg α] (as : list α) : list α",
    "theorem": "{α : Type u} [has_neg α] (as : list α) : list α",
    "args": "{α : Type u} [has_neg α] (as : list α)",
    "doc_string": "Elementwise negation of a list",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "locally_constant.map",
    "statement": "def locally_constant.map {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] (f : Y → Z) : locally_constant X Y → locally_constant X Z",
    "theorem": "{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] (f : Y → Z) : locally_constant X Y → locally_constant X Z",
    "args": "{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] (f : Y → Z)",
    "doc_string": "Push forward of locally constant maps under any map, by post-composition.",
    "kind": "def",
    "type": "locally_constant X Y → locally_constant X Z"
  },
  {
    "name": "fin2.is_lt",
    "statement": "structure fin2.is_lt (m n : ℕ) : Type",
    "theorem": "(m n : ℕ) : Type",
    "args": "(m n : ℕ)",
    "doc_string": "This is a simple type class inference prover for proof obligations  of the form `m < n` where `m n : ℕ`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "range.is_submonoid",
    "statement": "theorem range.is_submonoid {M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) : is_submonoid (set.range f)",
    "theorem": "{M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) : is_submonoid (set.range f)",
    "args": "{M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f)",
    "doc_string": "The image of a monoid hom is a submonoid of the codomain.",
    "kind": "theorem",
    "type": "is_submonoid (set.range f)"
  },
  {
    "name": "symmetric_rel",
    "statement": "def symmetric_rel {α : Type u_1} (V : set (α × α)) : Prop",
    "theorem": "{α : Type u_1} (V : set (α × α)) : Prop",
    "args": "{α : Type u_1} (V : set (α × α))",
    "doc_string": "The relation is invariant under swapping factors.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "generalized_continued_fraction.of_integer",
    "statement": "def generalized_continued_fraction.of_integer {α : Type u_1} (a : α) : generalized_continued_fraction α",
    "theorem": "{α : Type u_1} (a : α) : generalized_continued_fraction α",
    "args": "{α : Type u_1} (a : α)",
    "doc_string": "Constructs a generalized continued fraction without fractional part.",
    "kind": "def",
    "type": "generalized_continued_fraction α"
  },
  {
    "name": "bitvec.uborrow",
    "statement": "def bitvec.uborrow {n : ℕ} (x y : bitvec n) : bool",
    "theorem": "{n : ℕ} (x y : bitvec n) : bool",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": " `uborrow x y` returns `tt` iff the \"subtract with borrow\" operation on `x`, `y` and `ff` required a borrow.",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "add_le_of_le_neg_add",
    "statement": "theorem add_le_of_le_neg_add {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ -a + c → a + b ≤ c",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ -a + c → a + b ≤ c",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of le_inv_mul_iff_mul_le`.",
    "kind": "theorem",
    "type": "b ≤ -a + c → a + b ≤ c"
  },
  {
    "name": "subsemiring.has_inf",
    "statement": "def subsemiring.has_inf {R : Type u} [non_assoc_semiring R] : has_inf (subsemiring R)",
    "theorem": "{R : Type u} [non_assoc_semiring R] : has_inf (subsemiring R)",
    "args": "{R : Type u} [non_assoc_semiring R]",
    "doc_string": "The inf of two subsemirings is their intersection.",
    "kind": "def",
    "type": "has_inf (subsemiring R)"
  },
  {
    "name": "Born.of",
    "statement": "def Born.of (α : Type u_1) [bornology α] : Born",
    "theorem": "(α : Type u_1) [bornology α] : Born",
    "args": "(α : Type u_1) [bornology α]",
    "doc_string": "Construct a bundled `Born` from a `bornology`.",
    "kind": "def",
    "type": "Born"
  },
  {
    "name": "metric_space.induced",
    "statement": "def metric_space.induced {γ : Type u_1} {β : Type u_2} (f : γ → β) (hf : function.injective f) (m : metric_space β) : metric_space γ",
    "theorem": "{γ : Type u_1} {β : Type u_2} (f : γ → β) (hf : function.injective f) (m : metric_space β) : metric_space γ",
    "args": "{γ : Type u_1} {β : Type u_2} (f : γ → β) (hf : function.injective f) (m : metric_space β)",
    "doc_string": " Metric space structure pulled back by an injective function. Injectivity is necessary to ensure that `dist x y = 0` only if `x = y`.",
    "kind": "def",
    "type": "metric_space γ"
  },
  {
    "name": "tagged_format",
    "statement": "inductive tagged_format (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "An alternative to format that keeps structural information stored as a tag.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "sym2.mem.other'",
    "statement": "def sym2.mem.other' {α : Type u_1} [decidable_eq α] {a : α} {z : sym2 α} (h : a ∈ z) : α",
    "theorem": "{α : Type u_1} [decidable_eq α] {a : α} {z : sym2 α} (h : a ∈ z) : α",
    "args": "{α : Type u_1} [decidable_eq α] {a : α} {z : sym2 α} (h : a ∈ z)",
    "doc_string": "Get the other element of the unordered pair using the decidable equality. This is the computable version of `mem.other`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "is_smul_regular.not_zero",
    "statement": "theorem is_smul_regular.not_zero {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : ¬is_smul_regular M 0",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : ¬is_smul_regular M 0",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M]",
    "doc_string": "The `0` element is not `M`-regular, on a non-trivial module.",
    "kind": "theorem",
    "type": "¬is_smul_regular M 0"
  },
  {
    "name": "tactic.auto_cases.auto_cases_tac",
    "statement": "structure tactic.auto_cases.auto_cases_tac  : Type 1",
    "theorem": " : Type 1",
    "args": "",
    "doc_string": "Structure representing a tactic which can be used by `tactic.auto_cases`.",
    "kind": "structure",
    "type": "Type 1"
  },
  {
    "name": "prod.pseudo_emetric_space_max",
    "statement": "def prod.pseudo_emetric_space_max {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] : pseudo_emetric_space (α × β)",
    "theorem": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] : pseudo_emetric_space (α × β)",
    "args": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β]",
    "doc_string": " The product of two pseudoemetric spaces, with the max distance, is an extended pseudometric spaces. We make sure that the uniform structure thus constructed is the one corresponding to the product of uniform spaces, to avoid diamond problems.",
    "kind": "def",
    "type": "pseudo_emetric_space (α × β)"
  },
  {
    "name": "nzsnum.tail",
    "statement": "def nzsnum.tail  : nzsnum → snum",
    "theorem": " : nzsnum → snum",
    "args": "",
    "doc_string": "The `tail` of a `nzsnum` is the `snum` obtained by removing the LSB.      Edge cases: `tail 1 = 0` and `tail (-2) = -1`.",
    "kind": "def",
    "type": "nzsnum → snum"
  },
  {
    "name": "category_theory.zigzag_is_connected",
    "statement": "theorem category_theory.zigzag_is_connected {J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂) : category_theory.is_connected J",
    "theorem": "{J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂) : category_theory.is_connected J",
    "args": "{J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂)",
    "doc_string": "If any two objects in an nonempty category are related by `zigzag`, the category is connected.",
    "kind": "theorem",
    "type": "category_theory.is_connected J"
  },
  {
    "name": "char_p.char_ne_zero_of_fintype",
    "statement": "theorem char_p.char_ne_zero_of_fintype (R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0",
    "theorem": "(R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0",
    "args": "(R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R]",
    "doc_string": "The characteristic of a finite ring cannot be zero.",
    "kind": "theorem",
    "type": "p ≠ 0"
  },
  {
    "name": "localization",
    "statement": "def localization {M : Type u_1} [comm_monoid M] (S : submonoid M) : Type u_1",
    "theorem": "{M : Type u_1} [comm_monoid M] (S : submonoid M) : Type u_1",
    "args": "{M : Type u_1} [comm_monoid M] (S : submonoid M)",
    "doc_string": "The localization of a `comm_monoid` at one of its submonoids (as a quotient type).",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "SemiRing.of",
    "statement": "def SemiRing.of (R : Type u) [semiring R] : SemiRing",
    "theorem": "(R : Type u) [semiring R] : SemiRing",
    "args": "(R : Type u) [semiring R]",
    "doc_string": "Construct a bundled SemiRing from the underlying type and typeclass.",
    "kind": "def",
    "type": "SemiRing"
  },
  {
    "name": "algebra.semiring_to_ring",
    "statement": "def algebra.semiring_to_ring (R : Type u) {A : Type w} [comm_ring R] [semiring A] [algebra R A] : ring A",
    "theorem": "(R : Type u) {A : Type w} [comm_ring R] [semiring A] [algebra R A] : ring A",
    "args": "(R : Type u) {A : Type w} [comm_ring R] [semiring A] [algebra R A]",
    "doc_string": " A `semiring` that is an `algebra` over a commutative ring carries a natural `ring` structure. See note [reducible non-instances].",
    "kind": "def",
    "type": "ring A"
  },
  {
    "name": "int.le_induction_down",
    "statement": "theorem int.le_induction_down {P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n",
    "theorem": "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n",
    "args": "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ)",
    "doc_string": "See `int.induction_on'` for an induction in both directions.",
    "kind": "theorem",
    "type": "n ≤ m → P n"
  },
  {
    "name": "category_theory.free_bicategory",
    "statement": "def category_theory.free_bicategory (B : Type u) : Type u",
    "theorem": "(B : Type u) : Type u",
    "args": "(B : Type u)",
    "doc_string": "Free bicategory over a quiver. Its objects are the same as those in the underlying quiver.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "fintype.group_with_zero_of_cancel",
    "statement": "def fintype.group_with_zero_of_cancel (M : Type u_1) [cancel_monoid_with_zero M] [decidable_eq M] [fintype M] [nontrivial M] : group_with_zero M",
    "theorem": "(M : Type u_1) [cancel_monoid_with_zero M] [decidable_eq M] [fintype M] [nontrivial M] : group_with_zero M",
    "args": "(M : Type u_1) [cancel_monoid_with_zero M] [decidable_eq M] [fintype M] [nontrivial M]",
    "doc_string": "Every finite nontrivial cancel_monoid_with_zero is a group_with_zero.",
    "kind": "def",
    "type": "group_with_zero M"
  },
  {
    "name": "one_hom.has_one",
    "statement": "def one_hom.has_one {M : Type u_3} {N : Type u_4} [has_one M] [has_one N] : has_one (one_hom M N)",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] : has_one (one_hom M N)",
    "args": "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N]",
    "doc_string": "`1` is the homomorphism sending all elements to `1`.",
    "kind": "def",
    "type": "has_one (one_hom M N)"
  },
  {
    "name": "ordnode.singleton",
    "statement": "def ordnode.singleton {α : Type u} (a : α) : ordnode α",
    "theorem": "{α : Type u} (a : α) : ordnode α",
    "args": "{α : Type u} (a : α)",
    "doc_string": "O(1). Construct a singleton set containing value `a`.      singleton 3 = {3}",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "parser.any_char",
    "statement": "def parser.any_char  : parser char",
    "theorem": " : parser char",
    "args": "",
    "doc_string": "Matches a single character. Fails only if there is no more input.",
    "kind": "def",
    "type": "parser char"
  },
  {
    "name": "hahn_series.add_val",
    "statement": "def hahn_series.add_val (Γ : Type u_1) (R : Type u_2) [linear_ordered_add_comm_group Γ] [ring R] [is_domain R] : add_valuation (hahn_series Γ R) (with_top Γ)",
    "theorem": "(Γ : Type u_1) (R : Type u_2) [linear_ordered_add_comm_group Γ] [ring R] [is_domain R] : add_valuation (hahn_series Γ R) (with_top Γ)",
    "args": "(Γ : Type u_1) (R : Type u_2) [linear_ordered_add_comm_group Γ] [ring R] [is_domain R]",
    "doc_string": "The additive valuation on `hahn_series Γ R`, returning the smallest index at which  a Hahn Series has a nonzero coefficient, or `⊤` for the 0 series.",
    "kind": "def",
    "type": "add_valuation (hahn_series Γ R) (with_top Γ)"
  },
  {
    "name": "pi.ordered_comm_monoid",
    "statement": "def pi.ordered_comm_monoid {ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), ordered_comm_monoid (Z i)] : ordered_comm_monoid (Π (i : ι), Z i)",
    "theorem": "{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), ordered_comm_monoid (Z i)] : ordered_comm_monoid (Π (i : ι), Z i)",
    "args": "{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), ordered_comm_monoid (Z i)]",
    "doc_string": "The product of a family of ordered commutative monoids is an ordered commutative monoid.",
    "kind": "def",
    "type": "ordered_comm_monoid (Π (i : ι), Z i)"
  },
  {
    "name": "is_add_group_hom.mk'",
    "statement": "theorem is_add_group_hom.mk' {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : ∀ (x y : α), f (x + y) = f x + f y) : is_add_group_hom f",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : ∀ (x y : α), f (x + y) = f x + f y) : is_add_group_hom f",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : ∀ (x y : α), f (x + y) = f x + f y)",
    "doc_string": "Construct `is_add_group_hom` from its only hypothesis.",
    "kind": "theorem",
    "type": "is_add_group_hom f"
  },
  {
    "name": "unit_interval.upath01",
    "statement": "def unit_interval.upath01  : path {down := 0} {down := 1}",
    "theorem": " : path {down := 0} {down := 1}",
    "args": "",
    "doc_string": "The path 0 ⟶ 1 in ulift I",
    "kind": "def",
    "type": "path {down := 0} {down := 1}"
  },
  {
    "name": "turing.frespects",
    "statement": "def turing.frespects {σ₁ : Type u_1} {σ₂ : Type u_2} (f₂ : σ₂ → option σ₂) (tr : σ₁ → σ₂) (a₂ : σ₂) : option σ₁ → Prop",
    "theorem": "{σ₁ : Type u_1} {σ₂ : Type u_2} (f₂ : σ₂ → option σ₂) (tr : σ₁ → σ₂) (a₂ : σ₂) : option σ₁ → Prop",
    "args": "{σ₁ : Type u_1} {σ₂ : Type u_2} (f₂ : σ₂ → option σ₂) (tr : σ₁ → σ₂) (a₂ : σ₂)",
    "doc_string": "A simpler version of `respects` when the state transition relation `tr` is a function.",
    "kind": "def",
    "type": "option σ₁ → Prop"
  },
  {
    "name": "order.cofinal",
    "statement": "structure order.cofinal (P : Type u_2) [preorder P] : Type u_2",
    "theorem": "(P : Type u_2) [preorder P] : Type u_2",
    "args": "(P : Type u_2) [preorder P]",
    "doc_string": "For a preorder `P`, `cofinal P` is the type of subsets of `P`  containing arbitrarily large elements. They are the dense sets in  the topology whose open sets are terminal segments.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "linear_ordered_comm_monoid_with_zero",
    "statement": "structure linear_ordered_comm_monoid_with_zero (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A linearly ordered commutative monoid with a zero element.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "has_star",
    "statement": "structure has_star (R : Type u) : Type u",
    "theorem": "(R : Type u) : Type u",
    "args": "(R : Type u)",
    "doc_string": "Notation typeclass (with no default notation!) for an algebraic structure with a star operation.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "measurable_set.is_clopenable",
    "statement": "theorem measurable_set.is_clopenable {α : Type u_1} [topological_space α] [polish_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) : polish_space.is_clopenable s",
    "theorem": "{α : Type u_1} [topological_space α] [polish_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) : polish_space.is_clopenable s",
    "args": "{α : Type u_1} [topological_space α] [polish_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s)",
    "doc_string": " Given a Borel-measurable set in a Polish space, there exists a finer Polish topology making it clopen. This is in fact an equivalence, see `is_clopenable_iff_measurable_set`.",
    "kind": "theorem",
    "type": "polish_space.is_clopenable s"
  },
  {
    "name": "sum.get_left",
    "statement": "def sum.get_left {α : Type u} {β : Type v} : α ⊕ β → option α",
    "theorem": "{α : Type u} {β : Type v} : α ⊕ β → option α",
    "args": "{α : Type u} {β : Type v}",
    "doc_string": "Check if a sum is `inl` and if so, retrieve its contents.",
    "kind": "def",
    "type": "α ⊕ β → option α"
  },
  {
    "name": "fin.cast_lt",
    "statement": "def fin.cast_lt {n m : ℕ} (i : fin m) (h : i.val < n) : fin n",
    "theorem": "{n m : ℕ} (i : fin m) (h : i.val < n) : fin n",
    "args": "{n m : ℕ} (i : fin m) (h : i.val < n)",
    "doc_string": "`cast_lt i h` embeds `i` into a `fin` where `h` proves it belongs into.",
    "kind": "def",
    "type": "fin n"
  },
  {
    "name": "ordnode.rotate_l",
    "statement": "def ordnode.rotate_l {α : Type u_1} : ordnode α → α → ordnode α → ordnode α",
    "theorem": "{α : Type u_1} : ordnode α → α → ordnode α → ordnode α",
    "args": "{α : Type u_1}",
    "doc_string": " Concatenate two nodes, performing a left rotation `x (y z) -> ((x y) z)` if balance is upset.",
    "kind": "def",
    "type": "ordnode α → α → ordnode α → ordnode α"
  },
  {
    "name": "normed_algebra",
    "statement": "structure normed_algebra (𝕜 : Type u_5) (𝕜' : Type u_6) [normed_field 𝕜] [semi_normed_ring 𝕜'] : Type (max u_5 u_6)",
    "theorem": "(𝕜 : Type u_5) (𝕜' : Type u_6) [normed_field 𝕜] [semi_normed_ring 𝕜'] : Type (max u_5 u_6)",
    "args": "(𝕜 : Type u_5) (𝕜' : Type u_6) [normed_field 𝕜] [semi_normed_ring 𝕜']",
    "doc_string": " A normed algebra `𝕜'` over `𝕜` is normed module that is also an algebra.  See the implementation notes for `algebra` for a discussion about non-unital algebras. Following the strategy there, a non-unital *normed* algebra can be written as: ```lean variables [normed_field 𝕜] [non_unital_semi_normed_ring 𝕜'] variables [normed_module 𝕜 𝕜'] [smul_comm_class 𝕜 𝕜' 𝕜'] [is_scalar_tower 𝕜 𝕜' 𝕜'] ```",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "has_pos_part",
    "statement": "structure has_pos_part (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "The positive part of an element admiting a decomposition into positive and negative parts.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "topological_space.compacts.inhabited",
    "statement": "def topological_space.compacts.inhabited {α : Type u_1} [topological_space α] : inhabited (topological_space.compacts α)",
    "theorem": "{α : Type u_1} [topological_space α] : inhabited (topological_space.compacts α)",
    "args": "{α : Type u_1} [topological_space α]",
    "doc_string": "The type of compact sets is inhabited, with default element the empty set.",
    "kind": "def",
    "type": "inhabited (topological_space.compacts α)"
  },
  {
    "name": "lie_subalgebra.normalizer",
    "statement": "def lie_subalgebra.normalizer {R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : lie_subalgebra R L",
    "theorem": "{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : lie_subalgebra R L",
    "args": "{R : Type u_1} {L : Type u_2} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L)",
    "doc_string": " Regarding a Lie subalgebra `H ⊆ L` as a module over itself, its centralizer is in fact a Lie subalgebra. This is called the normalizer of the Lie subalgebra.",
    "kind": "def",
    "type": "lie_subalgebra R L"
  },
  {
    "name": "measure_theory.prog_measurable",
    "statement": "def measure_theory.prog_measurable {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] [measurable_space ι] (f : measure_theory.filtration ι m) (u : ι → α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] [measurable_space ι] (f : measure_theory.filtration ι m) (u : ι → α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] [measurable_space ι] (f : measure_theory.filtration ι m) (u : ι → α → β)",
    "doc_string": " Progressively measurable process. A sequence of functions `u` is said to be progressively measurable with respect to a filtration `f` if at each point in time `i`, `u` restricted to `set.Iic i × α` is measurable with respect to the product `measurable_space` structure where the σ-algebra used for `α` is `f i`. The usual definition uses the interval `[0,i]`, which we replace by `set.Iic i`. We recover the usual definition for index types `ℝ≥0` or `ℕ`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_p_group.is_nilpotent",
    "statement": "theorem is_p_group.is_nilpotent {G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G",
    "theorem": "{G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G",
    "args": "{G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G)",
    "doc_string": "A p-group is nilpotent",
    "kind": "theorem",
    "type": "group.is_nilpotent G"
  },
  {
    "name": "matrix.has_repr",
    "statement": "def matrix.has_repr {α : Type u} {n m : ℕ} [has_repr α] : has_repr (matrix (fin m) (fin n) α)",
    "theorem": "{α : Type u} {n m : ℕ} [has_repr α] : has_repr (matrix (fin m) (fin n) α)",
    "args": "{α : Type u} {n m : ℕ} [has_repr α]",
    "doc_string": " Use `![...]` notation for displaying a `fin`-indexed matrix, for example:  ```lean #eval ![![1, 2], ![3, 4]] + ![![3, 4], ![5, 6]] -- ![![4, 6], ![8, 10]] ```",
    "kind": "def",
    "type": "has_repr (matrix (fin m) (fin n) α)"
  },
  {
    "name": "category_theory.presieve.cocone",
    "statement": "def category_theory.presieve.cocone {C : Type u₁} [category_theory.category C] {X : C} (S : category_theory.presieve X) : category_theory.limits.cocone S.diagram",
    "theorem": "{C : Type u₁} [category_theory.category C] {X : C} (S : category_theory.presieve X) : category_theory.limits.cocone S.diagram",
    "args": "{C : Type u₁} [category_theory.category C] {X : C} (S : category_theory.presieve X)",
    "doc_string": "Given a sieve `S` on `X : C`, its associated cocone `S.cocone` is defined to be    the natural cocone over the diagram defined above with cocone point `X`.",
    "kind": "def",
    "type": "category_theory.limits.cocone S.diagram"
  },
  {
    "name": "add_monoid.closure",
    "statement": "def add_monoid.closure {M : Type u_1} [add_monoid M] (s : set M) : set M",
    "theorem": "{M : Type u_1} [add_monoid M] (s : set M) : set M",
    "args": "{M : Type u_1} [add_monoid M] (s : set M)",
    "doc_string": "The inductively defined `add_submonoid` genrated by a subset of an `add_monoid`.",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "is_unit.is_smul_regular",
    "statement": "theorem is_unit.is_smul_regular {R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a",
    "theorem": "{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a",
    "args": "{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a)",
    "doc_string": "A unit is `M`-regular.",
    "kind": "theorem",
    "type": "is_smul_regular M a"
  },
  {
    "name": "box_integral.integration_params",
    "statement": "structure box_integral.integration_params  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " An `integration_params` is a structure holding 3 boolean values used to define a filter to be used in the definition of a box-integrable function.  * `bRiemann`: the value `tt` means that the filter corresponds to a Riemann-style integral, i.e. in   the definition of integrability we require a constant upper estimate `r` on the size of boxes of a   tagged partition; the value `ff` means that the estimate may depend on the position of the tag.  * `bHenstock`: the value `tt` means that we require that each tag belongs to its own closed box; the   value `ff` means that we only require that tags belong to the ambient box.  * `bDistortion`: the value `tt` means that `r` can depend on the maximal ratio of sides of the same   box of a partition. Presence of this case makes quite a few proofs harder but we can prove the   divergence theorem only for the filter `⊥ = {bRiemann := ff, bHenstock := tt, bDistortion := tt}`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "modular_group.fdo",
    "statement": "def modular_group.fdo  : set upper_half_plane",
    "theorem": " : set upper_half_plane",
    "args": "",
    "doc_string": "The standard open fundamental domain of the action of `SL(2,ℤ)` on `ℍ`.",
    "kind": "def",
    "type": "set upper_half_plane"
  },
  {
    "name": "znum.succ",
    "statement": "def znum.succ  : znum → znum",
    "theorem": " : znum → znum",
    "args": "",
    "doc_string": "The successor of a `znum`.",
    "kind": "def",
    "type": "znum → znum"
  },
  {
    "name": "setoid.classes",
    "statement": "def setoid.classes {α : Type u_1} (r : setoid α) : set (set α)",
    "theorem": "{α : Type u_1} (r : setoid α) : set (set α)",
    "args": "{α : Type u_1} (r : setoid α)",
    "doc_string": "Makes the equivalence classes of an equivalence relation.",
    "kind": "def",
    "type": "set (set α)"
  },
  {
    "name": "well_founded.conditionally_complete_linear_order_with_bot",
    "statement": "def well_founded.conditionally_complete_linear_order_with_bot {α : Type u_1} [i₁ : linear_order α] [i₂ : order_bot α] (h : well_founded has_lt.lt) : conditionally_complete_linear_order_bot α",
    "theorem": "{α : Type u_1} [i₁ : linear_order α] [i₂ : order_bot α] (h : well_founded has_lt.lt) : conditionally_complete_linear_order_bot α",
    "args": "{α : Type u_1} [i₁ : linear_order α] [i₂ : order_bot α] (h : well_founded has_lt.lt)",
    "doc_string": "A well founded linear order with a bottom element is conditionally complete.",
    "kind": "def",
    "type": "conditionally_complete_linear_order_bot α"
  },
  {
    "name": "setoid.ker_lift_injective",
    "statement": "theorem setoid.ker_lift_injective {α : Type u_1} {β : Type u_2} (f : α → β) : function.injective (quotient.lift f _)",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) : function.injective (quotient.lift f _)",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β)",
    "doc_string": "Given a map f from α to β, the natural map from the quotient of α by the kernel of f is    injective.",
    "kind": "theorem",
    "type": "function.injective (quotient.lift f _)"
  },
  {
    "name": "measure_theory.simple_func.neg_part",
    "statement": "def measure_theory.simple_func.neg_part {α : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space α] [has_neg E] (f : measure_theory.simple_func α E) : measure_theory.simple_func α E",
    "theorem": "{α : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space α] [has_neg E] (f : measure_theory.simple_func α E) : measure_theory.simple_func α E",
    "args": "{α : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space α] [has_neg E] (f : measure_theory.simple_func α E)",
    "doc_string": "Negative part of a simple function.",
    "kind": "def",
    "type": "measure_theory.simple_func α E"
  },
  {
    "name": "order_iso",
    "statement": "def order_iso (α : Type u_1) (β : Type u_2) [has_le α] [has_le β] : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (β : Type u_2) [has_le α] [has_le β] : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (β : Type u_2) [has_le α] [has_le β]",
    "doc_string": " An order isomorphism is an equivalence such that `a ≤ b ↔ (f a) ≤ (f b)`. This definition is an abbreviation of `rel_iso (≤) (≤)`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "polynomial.cancel_leads",
    "statement": "def polynomial.cancel_leads {R : Type u_1} [ring R] (p q : polynomial R) : polynomial R",
    "theorem": "{R : Type u_1} [ring R] (p q : polynomial R) : polynomial R",
    "args": "{R : Type u_1} [ring R] (p q : polynomial R)",
    "doc_string": "`cancel_leads p q` is formed by multiplying `p` and `q` by monomials so that they  have the same leading term, and then subtracting.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "tendsto_diag_uniformity",
    "statement": "theorem tendsto_diag_uniformity {α : Type u_1} {β : Type u_2} [uniform_space α] (f : β → α) (l : filter β) : filter.tendsto (λ (x : β), (f x, f x)) l (uniformity α)",
    "theorem": "{α : Type u_1} {β : Type u_2} [uniform_space α] (f : β → α) (l : filter β) : filter.tendsto (λ (x : β), (f x, f x)) l (uniformity α)",
    "args": "{α : Type u_1} {β : Type u_2} [uniform_space α] (f : β → α) (l : filter β)",
    "doc_string": "Relation `λ f g, tendsto (λ x, (f x, g x)) l (𝓤 α)` is reflexive.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (x : β), (f x, f x)) l (uniformity α)"
  },
  {
    "name": "poly.sumsq",
    "statement": "def poly.sumsq {α : Type u_1} : list (poly α) → poly α",
    "theorem": "{α : Type u_1} : list (poly α) → poly α",
    "args": "{α : Type u_1}",
    "doc_string": "The sum of squares of a list of polynomials. This is relevant for  Diophantine equations, because it means that a list of equations  can be encoded as a single equation: `x = 0 ∧ y = 0 ∧ z = 0` is  equivalent to `x^2 + y^2 + z^2 = 0`.",
    "kind": "def",
    "type": "list (poly α) → poly α"
  },
  {
    "name": "category_theory.le_topology_of_closed_sieves_is_sheaf",
    "statement": "theorem category_theory.le_topology_of_closed_sieves_is_sheaf {C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₂)) : J₁ ≤ J₂",
    "theorem": "{C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₂)) : J₁ ≤ J₂",
    "args": "{C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₂))",
    "doc_string": "If presheaf of `J₁`-closed sieves is a `J₂`-sheaf then `J₁ ≤ J₂`. Note the converse is true by `classifier_is_sheaf` and `is_sheaf_of_le`.",
    "kind": "theorem",
    "type": "J₁ ≤ J₂"
  },
  {
    "name": "is_fraction_ring",
    "statement": "def is_fraction_ring (R : Type u_1) [comm_ring R] (K : Type u_5) [comm_ring K] [algebra R K] : Prop",
    "theorem": "(R : Type u_1) [comm_ring R] (K : Type u_5) [comm_ring K] [algebra R K] : Prop",
    "args": "(R : Type u_1) [comm_ring R] (K : Type u_5) [comm_ring K] [algebra R K]",
    "doc_string": "`is_fraction_ring R K` states `K` is the field of fractions of an integral domain `R`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "generalized_continued_fraction.numerators",
    "statement": "def generalized_continued_fraction.numerators {K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K",
    "theorem": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K",
    "args": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K)",
    "doc_string": "Returns the numerators `Aₙ` of `g`.",
    "kind": "def",
    "type": "stream K"
  },
  {
    "name": "int.least_of_bdd",
    "statement": "def int.least_of_bdd {P : ℤ → Prop} [decidable_pred P] (b : ℤ) (Hb : ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : {lb // P lb ∧ ∀ (z : ℤ), P z → lb ≤ z}",
    "theorem": "{P : ℤ → Prop} [decidable_pred P] (b : ℤ) (Hb : ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : {lb // P lb ∧ ∀ (z : ℤ), P z → lb ≤ z}",
    "args": "{P : ℤ → Prop} [decidable_pred P] (b : ℤ) (Hb : ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z)",
    "doc_string": " A computable version of `exists_least_of_bdd`: given a decidable predicate on the integers, with an explicit lower bound and a proof that it is somewhere true, return the least value for which the predicate is true.",
    "kind": "def",
    "type": "{lb // P lb ∧ ∀ (z : ℤ), P z → lb ≤ z}"
  },
  {
    "name": "algebraic_topology.normalized_Moore_complex.obj",
    "statement": "def algebraic_topology.normalized_Moore_complex.obj {C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) : chain_complex C ℕ",
    "theorem": "{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) : chain_complex C ℕ",
    "args": "{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C)",
    "doc_string": "The normalized Moore complex functor, on objects.",
    "kind": "def",
    "type": "chain_complex C ℕ"
  },
  {
    "name": "pseudo_metric_space.induced",
    "statement": "def pseudo_metric_space.induced {α : Type u_1} {β : Type u_2} (f : α → β) (m : pseudo_metric_space β) : pseudo_metric_space α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (m : pseudo_metric_space β) : pseudo_metric_space α",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (m : pseudo_metric_space β)",
    "doc_string": "Pseudometric space structure pulled back by a function.",
    "kind": "def",
    "type": "pseudo_metric_space α"
  },
  {
    "name": "option.maybe",
    "statement": "def option.maybe {m : Type u → Type v} [monad m] {α : Type u} : option (m α) → m (option α)",
    "theorem": "{m : Type u → Type v} [monad m] {α : Type u} : option (m α) → m (option α)",
    "args": "{m : Type u → Type v} [monad m] {α : Type u}",
    "doc_string": " If you maybe have a monadic computation in a `[monad m]` which produces a term of type `α`, then there is a naturally associated way to always perform a computation in `m` which maybe produces a result.",
    "kind": "def",
    "type": "option (m α) → m (option α)"
  },
  {
    "name": "CompHaus.of",
    "statement": "def CompHaus.of (X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : CompHaus",
    "theorem": "(X : Type u_1) [topological_space X] [compact_space X] [t2_space X] : CompHaus",
    "args": "(X : Type u_1) [topological_space X] [compact_space X] [t2_space X]",
    "doc_string": " A constructor for objects of the category `CompHaus`, taking a type, and bundling the compact Hausdorff topology found by typeclass inference.",
    "kind": "def",
    "type": "CompHaus"
  },
  {
    "name": "ray_vector.mul_action",
    "statement": "def ray_vector.mul_action {M : Type u_2} [add_comm_monoid M] {G : Type u_5} [group G] [distrib_mul_action G M] {R : Type u_1} : mul_action G (ray_vector R M)",
    "theorem": "{M : Type u_2} [add_comm_monoid M] {G : Type u_5} [group G] [distrib_mul_action G M] {R : Type u_1} : mul_action G (ray_vector R M)",
    "args": "{M : Type u_2} [add_comm_monoid M] {G : Type u_5} [group G] [distrib_mul_action G M] {R : Type u_1}",
    "doc_string": " Any invertible action preserves the non-zeroness of ray vectors. This is primarily of interest when `G = Rˣ`",
    "kind": "def",
    "type": "mul_action G (ray_vector R M)"
  },
  {
    "name": "representation",
    "statement": "def representation (k : Type u_1) (G : Type u_2) (V : Type u_3) [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V] : Type (max u_3 u_2)",
    "theorem": "(k : Type u_1) (G : Type u_2) (V : Type u_3) [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V] : Type (max u_3 u_2)",
    "args": "(k : Type u_1) (G : Type u_2) (V : Type u_3) [comm_semiring k] [monoid G] [add_comm_monoid V] [module k V]",
    "doc_string": "A representation of `G` on the `k`-module `V` is an homomorphism `G →* (V →ₗ[k] V)`.",
    "kind": "def",
    "type": "Type (max u_3 u_2)"
  },
  {
    "name": "add_submonoid.has_inf",
    "statement": "def add_submonoid.has_inf {M : Type u_1} [add_zero_class M] : has_inf (add_submonoid M)",
    "theorem": "{M : Type u_1} [add_zero_class M] : has_inf (add_submonoid M)",
    "args": "{M : Type u_1} [add_zero_class M]",
    "doc_string": "The inf of two `add_submonoid`s is their intersection.",
    "kind": "def",
    "type": "has_inf (add_submonoid M)"
  },
  {
    "name": "simple_continued_fraction.is_continued_fraction",
    "statement": "def simple_continued_fraction.is_continued_fraction {α : Type u_1} [has_one α] [has_zero α] [has_lt α] (s : simple_continued_fraction α) : Prop",
    "theorem": "{α : Type u_1} [has_one α] [has_zero α] [has_lt α] (s : simple_continued_fraction α) : Prop",
    "args": "{α : Type u_1} [has_one α] [has_zero α] [has_lt α] (s : simple_continued_fraction α)",
    "doc_string": "A simple continued fraction is a *(regular) continued fraction* ((r)cf) if all partial denominators `bᵢ` are positive, i.e. `0 < bᵢ`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lazy_list.traverse",
    "statement": "def lazy_list.traverse {m : Type u → Type u} [applicative m] {α β : Type u} (f : α → m β) : lazy_list α → m (lazy_list β)",
    "theorem": "{m : Type u → Type u} [applicative m] {α β : Type u} (f : α → m β) : lazy_list α → m (lazy_list β)",
    "args": "{m : Type u → Type u} [applicative m] {α β : Type u} (f : α → m β)",
    "doc_string": "Traversal of lazy lists using an applicative effect.",
    "kind": "def",
    "type": "lazy_list α → m (lazy_list β)"
  },
  {
    "name": "nat.proper_divisors",
    "statement": "def nat.proper_divisors (n : ℕ) : finset ℕ",
    "theorem": "(n : ℕ) : finset ℕ",
    "args": "(n : ℕ)",
    "doc_string": "`proper_divisors n` is the `finset` of divisors of `n`, other than `n`.  As a special case, `proper_divisors 0 = ∅`.",
    "kind": "def",
    "type": "finset ℕ"
  },
  {
    "name": "monoid.in_closure",
    "statement": "inductive monoid.in_closure {M : Type u_1} [monoid M] (s : set M) : M → Prop",
    "theorem": "{M : Type u_1} [monoid M] (s : set M) : M → Prop",
    "args": "{M : Type u_1} [monoid M] (s : set M)",
    "doc_string": "The inductively defined membership predicate for the `submonoid` generated by a subset of an    monoid.",
    "kind": "inductive",
    "type": "M → Prop"
  },
  {
    "name": "polynomial.cyclotomic_nonneg",
    "statement": "theorem polynomial.cyclotomic_nonneg (n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ≤ x) : 0 ≤ polynomial.eval x (polynomial.cyclotomic n R)",
    "theorem": "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ≤ x) : 0 ≤ polynomial.eval x (polynomial.cyclotomic n R)",
    "args": "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ≤ x)",
    "doc_string": "Cyclotomic polynomials are always nonnegative on inputs one or more.",
    "kind": "theorem",
    "type": "0 ≤ polynomial.eval x (polynomial.cyclotomic n R)"
  },
  {
    "name": "function.injective.has_involutive_inv",
    "statement": "def function.injective.has_involutive_inv {M₂ : Type u_2} {M₁ : Type u_1} [has_inv M₁] [has_involutive_inv M₂] (f : M₁ → M₂) (hf : function.injective f) (inv : ∀ (x : M₁), f x⁻¹ = (f x)⁻¹) : has_involutive_inv M₁",
    "theorem": "{M₂ : Type u_2} {M₁ : Type u_1} [has_inv M₁] [has_involutive_inv M₂] (f : M₁ → M₂) (hf : function.injective f) (inv : ∀ (x : M₁), f x⁻¹ = (f x)⁻¹) : has_involutive_inv M₁",
    "args": "{M₂ : Type u_2} {M₁ : Type u_1} [has_inv M₁] [has_involutive_inv M₂] (f : M₁ → M₂) (hf : function.injective f) (inv : ∀ (x : M₁), f x⁻¹ = (f x)⁻¹)",
    "doc_string": " A type has an involutive inversion if it admits a surjective map that preserves `⁻¹` to a type which has an involutive inversion.",
    "kind": "def",
    "type": "has_involutive_inv M₁"
  },
  {
    "name": "ultrafilter_basis",
    "statement": "def ultrafilter_basis (α : Type u) : set (set (ultrafilter α))",
    "theorem": "(α : Type u) : set (set (ultrafilter α))",
    "args": "(α : Type u)",
    "doc_string": "Basis for the topology on `ultrafilter α`.",
    "kind": "def",
    "type": "set (set (ultrafilter α))"
  },
  {
    "name": "is_refl",
    "statement": "structure is_refl (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": "`is_refl X r` means the binary relation `r` on `X` is reflexive.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "cycle.length",
    "statement": "def cycle.length {α : Type u_1} (s : cycle α) : ℕ",
    "theorem": "{α : Type u_1} (s : cycle α) : ℕ",
    "args": "{α : Type u_1} (s : cycle α)",
    "doc_string": "The length of the `s : cycle α`, which is the number of elements, counting duplicates.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "ennreal.module",
    "statement": "def ennreal.module {M : Type u_1} [add_comm_monoid M] [module ennreal M] : module nnreal M",
    "theorem": "{M : Type u_1} [add_comm_monoid M] [module ennreal M] : module nnreal M",
    "args": "{M : Type u_1} [add_comm_monoid M] [module ennreal M]",
    "doc_string": "A `module` over `ℝ≥0∞` restricts to a `module` over `ℝ≥0`.",
    "kind": "def",
    "type": "module nnreal M"
  },
  {
    "name": "first_order.language.infinite_theory",
    "statement": "def first_order.language.infinite_theory (L : first_order.language) : L.Theory",
    "theorem": "(L : first_order.language) : L.Theory",
    "args": "(L : first_order.language)",
    "doc_string": "A theory indicating that a structure is infinite.",
    "kind": "def",
    "type": "L.Theory"
  },
  {
    "name": "is_extr_filter",
    "statement": "def is_extr_filter {α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α)",
    "doc_string": "`is_extr_filter f l a` means `is_min_filter f l a` or `is_max_filter f l a`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "continuous_monoid_hom.snd",
    "statement": "def continuous_monoid_hom.snd (A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A × B) B",
    "theorem": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A × B) B",
    "args": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by projection onto the second factor.",
    "kind": "def",
    "type": "continuous_monoid_hom (A × B) B"
  },
  {
    "name": "num.mod",
    "statement": "def num.mod  : num → num → num",
    "theorem": " : num → num → num",
    "args": "",
    "doc_string": "Modulus of `num`s.",
    "kind": "def",
    "type": "num → num → num"
  },
  {
    "name": "lie_algebra.orthogonal.PB",
    "statement": "def lie_algebra.orthogonal.PB (l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R",
    "theorem": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R",
    "args": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R]",
    "doc_string": " A matrix transforming the bilinear form defined by the matrix `JB` into an almost-split-signature diagonal matrix.  It looks like this as a `(2l+1) x (2l+1)` matrix of blocks:     [ 1 0  0 ]    [ 0 1 -1 ]    [ 0 1  1 ]  where sizes of the blocks are:     [`1 x 1` `1 x l` `1 x l`]    [`l x 1` `l x l` `l x l`]    [`l x 1` `l x l` `l x l`]",
    "kind": "def",
    "type": "matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R"
  },
  {
    "name": "ring_subgroups_basis",
    "statement": "structure ring_subgroups_basis {A : Type u_1} {ι : Type u_2} [ring A] (B : ι → add_subgroup A) : Prop",
    "theorem": "{A : Type u_1} {ι : Type u_2} [ring A] (B : ι → add_subgroup A) : Prop",
    "args": "{A : Type u_1} {ι : Type u_2} [ring A] (B : ι → add_subgroup A)",
    "doc_string": " A family of additive subgroups on a ring `A` is a subgroups basis if it satisfies some axioms ensuring there is a topology on `A` which is compatible with the ring structure and admits this family as a basis of neighborhoods of zero.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "prod.non_unital_semi_normed_ring",
    "statement": "def prod.non_unital_semi_normed_ring {α : Type u_1} {β : Type u_2} [non_unital_semi_normed_ring α] [non_unital_semi_normed_ring β] : non_unital_semi_normed_ring (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [non_unital_semi_normed_ring α] [non_unital_semi_normed_ring β] : non_unital_semi_normed_ring (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} [non_unital_semi_normed_ring α] [non_unital_semi_normed_ring β]",
    "doc_string": "Non-unital seminormed ring structure on the product of two non-unital seminormed rings,  using the sup norm.",
    "kind": "def",
    "type": "non_unital_semi_normed_ring (α × β)"
  },
  {
    "name": "linear_recurrence.mk_sol",
    "statement": "def linear_recurrence.mk_sol {α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (init : fin E.order → α) : ℕ → α",
    "theorem": "{α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (init : fin E.order → α) : ℕ → α",
    "args": "{α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (init : fin E.order → α)",
    "doc_string": "A solution of a `linear_recurrence` which satisfies certain initial conditions.  We will prove this is the only such solution.",
    "kind": "def",
    "type": "ℕ → α"
  },
  {
    "name": "witt_vector.tail",
    "statement": "def witt_vector.tail {p : ℕ} {R : Type u_1} [comm_ring R] (n : ℕ) : witt_vector p R → witt_vector p R",
    "theorem": "{p : ℕ} {R : Type u_1} [comm_ring R] (n : ℕ) : witt_vector p R → witt_vector p R",
    "args": "{p : ℕ} {R : Type u_1} [comm_ring R] (n : ℕ)",
    "doc_string": " `witt_vector.tail n x` is the Witt vector of which the first `n` coefficients are `0` and all other coefficients are those from `x`. See `witt_vector.init` for the complementary part.",
    "kind": "def",
    "type": "witt_vector p R → witt_vector p R"
  },
  {
    "name": "semiquot.bind",
    "statement": "def semiquot.bind {α : Type u_1} {β : Type u_2} (q : semiquot α) (f : α → semiquot β) : semiquot β",
    "theorem": "{α : Type u_1} {β : Type u_2} (q : semiquot α) (f : α → semiquot β) : semiquot β",
    "args": "{α : Type u_1} {β : Type u_2} (q : semiquot α) (f : α → semiquot β)",
    "doc_string": "Apply a function returning a `semiquot` to a `semiquot`.",
    "kind": "def",
    "type": "semiquot β"
  },
  {
    "name": "Class.iota",
    "statement": "def Class.iota (p : Set → Prop) : Class",
    "theorem": "(p : Set → Prop) : Class",
    "args": "(p : Set → Prop)",
    "doc_string": "The definite description operator, which is `{x}` if `{a | p a} = {x}` and `∅` otherwise.",
    "kind": "def",
    "type": "Class"
  },
  {
    "name": "is_strong_antichain",
    "statement": "def is_strong_antichain {α : Type u_1} (r : α → α → Prop) (s : set α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s : set α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (s : set α)",
    "doc_string": " An strong (upward) antichain is a set such that no two distinct elements are related to a common element.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ultrafilter",
    "statement": "structure ultrafilter (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "An ultrafilter is a minimal (maximal in the set order) proper filter.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "no_min_order",
    "statement": "structure no_min_order (α : Type u_2) [has_lt α] : Prop",
    "theorem": "(α : Type u_2) [has_lt α] : Prop",
    "args": "(α : Type u_2) [has_lt α]",
    "doc_string": "Order without minimal elements. Sometimes called coinitial or dense.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "list.func.sub",
    "statement": "def list.func.sub {α : Type u} [has_zero α] [has_sub α] : list α → list α → list α",
    "theorem": "{α : Type u} [has_zero α] [has_sub α] : list α → list α → list α",
    "args": "{α : Type u} [has_zero α] [has_sub α]",
    "doc_string": "Pointwise subtraction on lists. If lists are different lengths, use zero.",
    "kind": "def",
    "type": "list α → list α → list α"
  },
  {
    "name": "nat.perfect",
    "statement": "def nat.perfect (n : ℕ) : Prop",
    "theorem": "(n : ℕ) : Prop",
    "args": "(n : ℕ)",
    "doc_string": "`n : ℕ` is perfect if and only the sum of the proper divisors of `n` is `n` and `n`  is positive.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "stream.interleave",
    "statement": "def stream.interleave {α : Type u} (s₁ s₂ : stream α) : stream α",
    "theorem": "{α : Type u} (s₁ s₂ : stream α) : stream α",
    "args": "{α : Type u} (s₁ s₂ : stream α)",
    "doc_string": "Interleave two streams.",
    "kind": "def",
    "type": "stream α"
  },
  {
    "name": "cycle.reverse",
    "statement": "def cycle.reverse {α : Type u_1} (s : cycle α) : cycle α",
    "theorem": "{α : Type u_1} (s : cycle α) : cycle α",
    "args": "{α : Type u_1} (s : cycle α)",
    "doc_string": "Reverse a `s : cycle α` by reversing the underlying `list`.",
    "kind": "def",
    "type": "cycle α"
  },
  {
    "name": "list.of_fn",
    "statement": "def list.of_fn {α : Type u_1} {n : ℕ} (f : fin n → α) : list α",
    "theorem": "{α : Type u_1} {n : ℕ} (f : fin n → α) : list α",
    "args": "{α : Type u_1} {n : ℕ} (f : fin n → α)",
    "doc_string": "`of_fn f` with `f : fin n → α` returns the list whose ith element is `f i`  `of_fun f = [f 0, f 1, ... , f(n - 1)]`",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "category_theory.subobject.Inf",
    "statement": "def category_theory.subobject.Inf {C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A",
    "theorem": "{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : category_theory.subobject A",
    "args": "{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A))",
    "doc_string": "When `[well_powered C]` and `[has_wide_pullbacks C]`, `subobject A` has arbitrary infimums.",
    "kind": "def",
    "type": "category_theory.subobject A"
  },
  {
    "name": "fintype.to_order_top",
    "statement": "def fintype.to_order_top (α : Type u_2) [fintype α] [nonempty α] [semilattice_sup α] : order_top α",
    "theorem": "(α : Type u_2) [fintype α] [nonempty α] [semilattice_sup α] : order_top α",
    "args": "(α : Type u_2) [fintype α] [nonempty α] [semilattice_sup α]",
    "doc_string": "Constructs the `⊤` of a finite nonempty `semilattice_sup`",
    "kind": "def",
    "type": "order_top α"
  },
  {
    "name": "path.symm",
    "statement": "def path.symm {X : Type u_1} [topological_space X] {x y : X} (γ : path x y) : path y x",
    "theorem": "{X : Type u_1} [topological_space X] {x y : X} (γ : path x y) : path y x",
    "args": "{X : Type u_1} [topological_space X] {x y : X} (γ : path x y)",
    "doc_string": "The reverse of a path from `x` to `y`, as a path from `y` to `x`",
    "kind": "def",
    "type": "path y x"
  },
  {
    "name": "emetric.continuous_inf_edist_Hausdorff_edist",
    "statement": "theorem emetric.continuous_inf_edist_Hausdorff_edist {α : Type u} [emetric_space α] : continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd))",
    "theorem": "{α : Type u} [emetric_space α] : continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd))",
    "args": "{α : Type u} [emetric_space α]",
    "doc_string": "The edistance to a closed set depends continuously on the point and the set",
    "kind": "theorem",
    "type": "continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd))"
  },
  {
    "name": "simp_lemmas",
    "statement": "constant simp_lemmas  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Simp lemmas are used by the \"simplifier\" family of tactics. `simp_lemmas` is essentially a pair of tables `rb_map (expr_type × name) (priority_list simp_lemma)`. One of the tables is for congruences and one is for everything else. An individual simp lemma is: - A kind which can be `Refl`, `Simp` or `Congr`. - A pair of `expr`s `l ~> r`. The rb map is indexed by the name of `get_app_fn(l)`. - A proof that `l = r` or `l ↔ r`. - A list of the metavariables that must be filled before the proof can be applied. - A priority number",
    "kind": "constant",
    "type": "Type"
  },
  {
    "name": "nat.choose",
    "statement": "def nat.choose  : ℕ → ℕ → ℕ",
    "theorem": " : ℕ → ℕ → ℕ",
    "args": "",
    "doc_string": " `choose n k` is the number of `k`-element subsets in an `n`-element set. Also known as binomial coefficients.",
    "kind": "def",
    "type": "ℕ → ℕ → ℕ"
  },
  {
    "name": "subring.mk'",
    "statement": "def subring.mk' {R : Type u} [ring R] (s : set R) (sm : submonoid R) (sa : add_subgroup R) (hm : ↑sm = s) (ha : ↑sa = s) : subring R",
    "theorem": "{R : Type u} [ring R] (s : set R) (sm : submonoid R) (sa : add_subgroup R) (hm : ↑sm = s) (ha : ↑sa = s) : subring R",
    "args": "{R : Type u} [ring R] (s : set R) (sm : submonoid R) (sa : add_subgroup R) (hm : ↑sm = s) (ha : ↑sa = s)",
    "doc_string": " Construct a `subring R` from a set `s`, a submonoid `sm`, and an additive subgroup `sa` such that `x ∈ s ↔ x ∈ sm ↔ x ∈ sa`.",
    "kind": "def",
    "type": "subring R"
  },
  {
    "name": "finset.shadow_empty",
    "statement": "theorem finset.shadow_empty {α : Type u_1} [decidable_eq α] : ∅.shadow = ∅",
    "theorem": "{α : Type u_1} [decidable_eq α] : ∅.shadow = ∅",
    "args": "{α : Type u_1} [decidable_eq α]",
    "doc_string": "The shadow of the empty set is empty.",
    "kind": "theorem",
    "type": "∅.shadow = ∅"
  },
  {
    "name": "is_greatest",
    "statement": "def is_greatest {α : Type u} [preorder α] (s : set α) (a : α) : Prop",
    "theorem": "{α : Type u} [preorder α] (s : set α) (a : α) : Prop",
    "args": "{α : Type u} [preorder α] (s : set α) (a : α)",
    "doc_string": "`a` is a greatest element of a set `s`; for a partial order, it is unique if exists",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pmf.map",
    "statement": "def pmf.map {α : Type u_1} {β : Type u_2} (f : α → β) (p : pmf α) : pmf β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (p : pmf α) : pmf β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (p : pmf α)",
    "doc_string": "The functorial action of a function on a `pmf`.",
    "kind": "def",
    "type": "pmf β"
  },
  {
    "name": "linear_ordered_cancel_add_comm_monoid",
    "statement": "structure linear_ordered_cancel_add_comm_monoid (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A linearly ordered cancellative additive commutative monoid is an additive commutative monoid with a decidable linear order in which addition is cancellative and monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "to_additive.value_type",
    "statement": "structure to_additive.value_type  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " `value_type` is the type of the arguments that can be provided to `to_additive`. `to_additive.parser` parses the provided arguments: * `replace_all`: replace all multiplicative declarations, do not use the heuristic. * `trace`: output the generated additive declaration. * `tgt : name`: the name of the target (the additive declaration). * `doc`: an optional doc string. * if `allow_auto_name` is `ff` (default) then `@[to_additive]` will check whether the given name   can be auto-generated.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "continuous_monoid_hom.swap",
    "statement": "def continuous_monoid_hom.swap (A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A × B) (B × A)",
    "theorem": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A × B) (B × A)",
    "args": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by swapping components.",
    "kind": "def",
    "type": "continuous_monoid_hom (A × B) (B × A)"
  },
  {
    "name": "list.length_pos_of_prod_lt_one",
    "statement": "theorem list.length_pos_of_prod_lt_one {M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length",
    "theorem": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length",
    "args": "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1)",
    "doc_string": "A list with product less than one must have positive length.",
    "kind": "theorem",
    "type": "0 < L.length"
  },
  {
    "name": "is_Gδ.union",
    "statement": "theorem is_Gδ.union {α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t)",
    "theorem": "{α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t)",
    "args": "{α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t)",
    "doc_string": "The union of two Gδ sets is a Gδ set.",
    "kind": "theorem",
    "type": "is_Gδ (s ∪ t)"
  },
  {
    "name": "witt_vector.standard_one_dim_isocrystal",
    "statement": "def witt_vector.standard_one_dim_isocrystal (p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] (m : ℤ) : Type u_1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] (m : ℤ) : Type u_1",
    "args": "(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] (m : ℤ)",
    "doc_string": "Type synonym for `K(p, k)` to carry the standard 1-dimensional isocrystal structure of slope `m : ℤ`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "widget_override.local_collection",
    "statement": "structure widget_override.local_collection  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A group of local constants in the context that should be rendered as one line.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "tendsto_locally_uniformly",
    "statement": "def tendsto_locally_uniformly {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] [topological_space α] (F : ι → α → β) (f : α → β) (p : filter ι) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] [topological_space α] (F : ι → α → β) (f : α → β) (p : filter ι) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] [topological_space α] (F : ι → α → β) (f : α → β) (p : filter ι)",
    "doc_string": " A sequence of functions `Fₙ` converges locally uniformly to a limiting function `f` with respect to a filter `p` if, for any entourage of the diagonal `u`, for any `x`, one has `p`-eventually `(f y, Fₙ y) ∈ u` for all `y` in a neighborhood of `x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "Lim",
    "statement": "def Lim {α : Type u} [topological_space α] [nonempty α] (f : filter α) : α",
    "theorem": "{α : Type u} [topological_space α] [nonempty α] (f : filter α) : α",
    "args": "{α : Type u} [topological_space α] [nonempty α] (f : filter α)",
    "doc_string": "If `f` is a filter, then `Lim f` is a limit of the filter, if it exists.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "BoundedLattice.of",
    "statement": "def BoundedLattice.of (α : Type u_1) [lattice α] [bounded_order α] : BoundedLattice",
    "theorem": "(α : Type u_1) [lattice α] [bounded_order α] : BoundedLattice",
    "args": "(α : Type u_1) [lattice α] [bounded_order α]",
    "doc_string": "Construct a bundled `BoundedLattice` from `lattice` + `bounded_order`.",
    "kind": "def",
    "type": "BoundedLattice"
  },
  {
    "name": "mul_action.to_perm",
    "statement": "def mul_action.to_perm {α : Type u} {β : Type v} [group α] [mul_action α β] (a : α) : equiv.perm β",
    "theorem": "{α : Type u} {β : Type v} [group α] [mul_action α β] (a : α) : equiv.perm β",
    "args": "{α : Type u} {β : Type v} [group α] [mul_action α β] (a : α)",
    "doc_string": "Given an action of a group `α` on `β`, each `g : α` defines a permutation of `β`.",
    "kind": "def",
    "type": "equiv.perm β"
  },
  {
    "name": "add_commute",
    "statement": "def add_commute {S : Type u_1} [has_add S] (a b : S) : Prop",
    "theorem": "{S : Type u_1} [has_add S] (a b : S) : Prop",
    "args": "{S : Type u_1} [has_add S] (a b : S)",
    "doc_string": "Two elements additively commute if `a + b = b + a`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.update",
    "statement": "def function.update {α : Sort u} {β : α → Sort v} [decidable_eq α] (f : Π (a : α), β a) (a' : α) (v : β a') (a : α) : β a",
    "theorem": "{α : Sort u} {β : α → Sort v} [decidable_eq α] (f : Π (a : α), β a) (a' : α) (v : β a') (a : α) : β a",
    "args": "{α : Sort u} {β : α → Sort v} [decidable_eq α] (f : Π (a : α), β a) (a' : α) (v : β a') (a : α)",
    "doc_string": "Replacing the value of a function at a given point by a given value.",
    "kind": "def",
    "type": "β a"
  },
  {
    "name": "category_theory.fin_category",
    "statement": "structure category_theory.fin_category (J : Type v) [category_theory.small_category J] : Type v",
    "theorem": "(J : Type v) [category_theory.small_category J] : Type v",
    "args": "(J : Type v) [category_theory.small_category J]",
    "doc_string": "A category with a `fintype` of objects, and a `fintype` for each morphism space.",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "pos_num.land",
    "statement": "def pos_num.land  : pos_num → pos_num → num",
    "theorem": " : pos_num → pos_num → num",
    "args": "",
    "doc_string": "Bitwise \"and\" for `pos_num`.",
    "kind": "def",
    "type": "pos_num → pos_num → num"
  },
  {
    "name": "affine_independent",
    "statement": "def affine_independent (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) : Prop",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P) : Prop",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] {ι : Type u_4} (p : ι → P)",
    "doc_string": " An indexed family is said to be affinely independent if no nontrivial weighted subtractions (where the sum of weights is 0) are 0.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "real.not_summable_one_div_nat_cast",
    "statement": "theorem real.not_summable_one_div_nat_cast  : ¬summable (λ (n : ℕ), 1 / ↑n)",
    "theorem": " : ¬summable (λ (n : ℕ), 1 / ↑n)",
    "args": "",
    "doc_string": "Harmonic series is not unconditionally summable.",
    "kind": "theorem",
    "type": "¬summable (λ (n : ℕ), 1 / ↑n)"
  },
  {
    "name": "measure_theory.signed_measure.total_variation",
    "statement": "def measure_theory.signed_measure.total_variation {α : Type u_1} [measurable_space α] (s : measure_theory.signed_measure α) : measure_theory.measure α",
    "theorem": "{α : Type u_1} [measurable_space α] (s : measure_theory.signed_measure α) : measure_theory.measure α",
    "args": "{α : Type u_1} [measurable_space α] (s : measure_theory.signed_measure α)",
    "doc_string": "The total variation of a signed measure.",
    "kind": "def",
    "type": "measure_theory.measure α"
  },
  {
    "name": "onote.opow",
    "statement": "def onote.opow (o₁ o₂ : onote) : onote",
    "theorem": "(o₁ o₂ : onote) : onote",
    "args": "(o₁ o₂ : onote)",
    "doc_string": "`opow o₁ o₂` calculates the ordinal notation for  the ordinal exponential `o₁ ^ o₂`.",
    "kind": "def",
    "type": "onote"
  },
  {
    "name": "module.free.choose_basis_index",
    "statement": "def module.free.choose_basis_index (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : Type v",
    "theorem": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : Type v",
    "args": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M]",
    "doc_string": "If `module.free R M` then `choose_basis_index R M` is the `ι` which indexes the basis  `ι → M`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "sup_bot_hom",
    "statement": "structure sup_bot_hom (α : Type u_7) (β : Type u_8) [has_sup α] [has_sup β] [has_bot α] [has_bot β] : Type (max u_7 u_8)",
    "theorem": "(α : Type u_7) (β : Type u_8) [has_sup α] [has_sup β] [has_bot α] [has_bot β] : Type (max u_7 u_8)",
    "args": "(α : Type u_7) (β : Type u_8) [has_sup α] [has_sup β] [has_bot α] [has_bot β]",
    "doc_string": "The type of finitary supremum-preserving homomorphisms from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8)"
  },
  {
    "name": "pSet.Union",
    "statement": "def pSet.Union  : pSet → pSet",
    "theorem": " : pSet → pSet",
    "args": "",
    "doc_string": "The pre-set union operator",
    "kind": "def",
    "type": "pSet → pSet"
  },
  {
    "name": "le_neg_of_le_neg",
    "statement": "theorem le_neg_of_le_neg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ -b → b ≤ -a",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ -b → b ≤ -a",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the forward direction of le_inv'`.",
    "kind": "theorem",
    "type": "a ≤ -b → b ≤ -a"
  },
  {
    "name": "has_le.le.eq_or_gt",
    "statement": "theorem has_le.le.eq_or_gt {α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : b = a ∨ a < b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : b = a ∨ a < b",
    "args": "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b)",
    "doc_string": "**Alias** of eq_or_gt_of_le`.",
    "kind": "theorem",
    "type": "b = a ∨ a < b"
  },
  {
    "name": "free_monoid.of",
    "statement": "def free_monoid.of {α : Type u_1} (x : α) : free_monoid α",
    "theorem": "{α : Type u_1} (x : α) : free_monoid α",
    "args": "{α : Type u_1} (x : α)",
    "doc_string": "Embeds an element of `α` into `free_monoid α` as a singleton list.",
    "kind": "def",
    "type": "free_monoid α"
  },
  {
    "name": "nat.set_induction",
    "statement": "theorem nat.set_induction {S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S",
    "theorem": "{S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S",
    "args": "{S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ)",
    "doc_string": "A subset of `ℕ` containing zero and closed under `nat.succ` contains all of `ℕ`.",
    "kind": "theorem",
    "type": "n ∈ S"
  },
  {
    "name": "polynomial.contract",
    "statement": "def polynomial.contract {R : Type u} [comm_semiring R] (p : ℕ) (f : polynomial R) : polynomial R",
    "theorem": "{R : Type u} [comm_semiring R] (p : ℕ) (f : polynomial R) : polynomial R",
    "args": "{R : Type u} [comm_semiring R] (p : ℕ) (f : polynomial R)",
    "doc_string": "The opposite of `expand`: sends `∑ aₙ xⁿᵖ` to `∑ aₙ xⁿ`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "bin_tree",
    "statement": "inductive bin_tree (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Auxiliary datatype for #[ ... ] notation.    #[1, 2, 3, 4] is notation for     bin_tree.node      (bin_tree.node (bin_tree.leaf 1) (bin_tree.leaf 2))      (bin_tree.node (bin_tree.leaf 3) (bin_tree.leaf 4))     We use this notation to input long sequences without exhausting the system stack space.    Later, we define a coercion from `bin_tree` into `list`.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "sub_neg_monoid.has_measurable_smul_int₂",
    "statement": "def sub_neg_monoid.has_measurable_smul_int₂ (M : Type u_1) [sub_neg_monoid M] [measurable_space M] [has_measurable_add₂ M] [has_measurable_neg M] : has_measurable_smul₂ ℤ M",
    "theorem": "(M : Type u_1) [sub_neg_monoid M] [measurable_space M] [has_measurable_add₂ M] [has_measurable_neg M] : has_measurable_smul₂ ℤ M",
    "args": "(M : Type u_1) [sub_neg_monoid M] [measurable_space M] [has_measurable_add₂ M] [has_measurable_neg M]",
    "doc_string": "`sub_neg_monoid.has_scalar_int` is measurable.",
    "kind": "def",
    "type": "has_measurable_smul₂ ℤ M"
  },
  {
    "name": "expr.address",
    "statement": "def expr.address  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " An address is a list of coordinates used to reference subterms of an expression. The first coordinate in the list corresponds to the root of the expression.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "le_of_neg_le_neg",
    "statement": "theorem le_of_neg_le_neg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : -a ≤ -b → b ≤ a",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : -a ≤ -b → b ≤ a",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the forward direction of neg_le_neg_iff`.",
    "kind": "theorem",
    "type": "-a ≤ -b → b ≤ a"
  },
  {
    "name": "order_hom_class.to_lattice_hom",
    "statement": "def order_hom_class.to_lattice_hom {F : Type u_1} (α : Type u_3) (β : Type u_4) [linear_order α] [lattice β] [order_hom_class F α β] (f : F) : lattice_hom α β",
    "theorem": "{F : Type u_1} (α : Type u_3) (β : Type u_4) [linear_order α] [lattice β] [order_hom_class F α β] (f : F) : lattice_hom α β",
    "args": "{F : Type u_1} (α : Type u_3) (β : Type u_4) [linear_order α] [lattice β] [order_hom_class F α β] (f : F)",
    "doc_string": "Reinterpret an order homomorphism to a linear order as a `lattice_hom`.",
    "kind": "def",
    "type": "lattice_hom α β"
  },
  {
    "name": "list.map₂_right'",
    "statement": "def list.map₂_right' {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : option α → β → γ) (as : list α) (bs : list β) : list γ × list α",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : option α → β → γ) (as : list α) (bs : list β) : list γ × list α",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : option α → β → γ) (as : list α) (bs : list β)",
    "doc_string": "Right-biased version of `list.map₂`. `map₂_right' f as bs` applies `f` to each pair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, `f` is applied to `none` for the remaining `bᵢ`. Returns the results of the `f` applications and the remaining `as`.  ```lean map₂_right' prod.mk [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])  map₂_right' prod.mk [1, 2] ['a'] = ([(some 1, 'a')], [2]) ```",
    "kind": "def",
    "type": "list γ × list α"
  },
  {
    "name": "derived_series",
    "statement": "def derived_series (G : Type u_1) [group G] : ℕ → subgroup G",
    "theorem": "(G : Type u_1) [group G] : ℕ → subgroup G",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "The derived series of the group `G`, obtained by starting from the subgroup `⊤` and repeatedly  taking the commutator of the previous subgroup with itself for `n` times.",
    "kind": "def",
    "type": "ℕ → subgroup G"
  },
  {
    "name": "denumerable.prod",
    "statement": "def denumerable.prod {α : Type u_1} {β : Type u_2} [denumerable α] [denumerable β] : denumerable (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [denumerable α] [denumerable β] : denumerable (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} [denumerable α] [denumerable β]",
    "doc_string": "If `α` and `β` are denumerable, then so is their product.",
    "kind": "def",
    "type": "denumerable (α × β)"
  },
  {
    "name": "algebraic_geometry.Proj.to_LocallyRingedSpace",
    "statement": "def algebraic_geometry.Proj.to_LocallyRingedSpace {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : algebraic_geometry.LocallyRingedSpace",
    "theorem": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : algebraic_geometry.LocallyRingedSpace",
    "args": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜]",
    "doc_string": "`Proj` of a graded ring as a `LocallyRingedSpace`",
    "kind": "def",
    "type": "algebraic_geometry.LocallyRingedSpace"
  },
  {
    "name": "quiver.root",
    "statement": "def quiver.root (V : Type u) [quiver V] [quiver.arborescence V] : V",
    "theorem": "(V : Type u) [quiver V] [quiver.arborescence V] : V",
    "args": "(V : Type u) [quiver V] [quiver.arborescence V]",
    "doc_string": "The root of an arborescence.",
    "kind": "def",
    "type": "V"
  },
  {
    "name": "mvqpf.liftp_preservation",
    "statement": "def mvqpf.liftp_preservation {n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F) : Prop",
    "theorem": "{n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F) : Prop",
    "args": "{n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F)",
    "doc_string": "does `abs` preserve `liftp`?",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ultrafilter.Lim",
    "statement": "def ultrafilter.Lim {α : Type u} [topological_space α] : ultrafilter α → α",
    "theorem": "{α : Type u} [topological_space α] : ultrafilter α → α",
    "args": "{α : Type u} [topological_space α]",
    "doc_string": "If `F` is an ultrafilter, then `filter.ultrafilter.Lim F` is a limit of the filter, if it exists. Note that dot notation `F.Lim` can be used for `F : ultrafilter α`.",
    "kind": "def",
    "type": "ultrafilter α → α"
  },
  {
    "name": "slim_check.use_has_to_string",
    "statement": "def slim_check.use_has_to_string (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Type tag that replaces a type's `has_repr` instance with its `has_to_string` instance.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "measure_theory.measure.haar_measure",
    "statement": "def measure_theory.measure.haar_measure {G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] (K₀ : topological_space.positive_compacts G) : measure_theory.measure G",
    "theorem": "{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] (K₀ : topological_space.positive_compacts G) : measure_theory.measure G",
    "args": "{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] (K₀ : topological_space.positive_compacts G)",
    "doc_string": "The Haar measure on the locally compact group `G`, scaled so that `haar_measure K₀ K₀ = 1`.",
    "kind": "def",
    "type": "measure_theory.measure G"
  },
  {
    "name": "inv_mul_le_of_le_mul",
    "statement": "theorem inv_mul_le_of_le_mul {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a ≤ b * c → b⁻¹ * a ≤ c",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a ≤ b * c → b⁻¹ * a ≤ c",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of inv_mul_le_iff_le_mul`.",
    "kind": "theorem",
    "type": "a ≤ b * c → b⁻¹ * a ≤ c"
  },
  {
    "name": "measure_theory.probability_measure",
    "statement": "def measure_theory.probability_measure (α : Type u_1) [measurable_space α] : Type u_1",
    "theorem": "(α : Type u_1) [measurable_space α] : Type u_1",
    "args": "(α : Type u_1) [measurable_space α]",
    "doc_string": " Probability measures are defined as the subtype of measures that have the property of being probability measures (i.e., their total mass is one).",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "semiring",
    "statement": "structure semiring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A semiring is a type with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and multiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero` instead of `monoid` and `mul_zero_class`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "ring.eq_self_iff_eq_zero_of_char_ne_two",
    "statement": "theorem ring.eq_self_iff_eq_zero_of_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ≠ 2) {a : R} : -a = a ↔ a = 0",
    "theorem": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ≠ 2) {a : R} : -a = a ↔ a = 0",
    "args": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ≠ 2) {a : R}",
    "doc_string": "Characteristic `≠ 2` in a domain implies that `-a = a` iff `a = 0`.",
    "kind": "theorem",
    "type": "-a = a ↔ a = 0"
  },
  {
    "name": "tactic.eliminate.constructor_argument_naming_rule",
    "statement": "def tactic.eliminate.constructor_argument_naming_rule  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A constructor argument naming rule takes a `constructor_argument_naming_info` structure and returns a list of suitable names for the argument. If the rule is not applicable to the given constructor argument, the returned list is empty.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "simple_graph.reachable",
    "statement": "def simple_graph.reachable {V : Type u} (G : simple_graph V) (u v : V) : Prop",
    "theorem": "{V : Type u} (G : simple_graph V) (u v : V) : Prop",
    "args": "{V : Type u} (G : simple_graph V) (u v : V)",
    "doc_string": " Two vertices are *reachable* if there is a walk between them. This is equivalent to `relation.refl_trans_gen` of `G.adj`. See `simple_graph.reachable_iff_refl_trans_gen`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_R_or_C.char_zero_R_or_C",
    "statement": "def is_R_or_C.char_zero_R_or_C {K : Type u_1} [is_R_or_C K] : char_zero K",
    "theorem": "{K : Type u_1} [is_R_or_C K] : char_zero K",
    "args": "{K : Type u_1} [is_R_or_C K]",
    "doc_string": "ℝ and ℂ are both of characteristic zero.",
    "kind": "def",
    "type": "char_zero K"
  },
  {
    "name": "equiv.perm.vectors_prod_eq_one",
    "statement": "def equiv.perm.vectors_prod_eq_one (G : Type u_2) [group G] (n : ℕ) : set (vector G n)",
    "theorem": "(G : Type u_2) [group G] (n : ℕ) : set (vector G n)",
    "args": "(G : Type u_2) [group G] (n : ℕ)",
    "doc_string": "The type of vectors with terms from `G`, length `n`, and product equal to `1:G`.",
    "kind": "def",
    "type": "set (vector G n)"
  },
  {
    "name": "add_hom.has_add",
    "statement": "def add_hom.has_add {M : Type u_3} {N : Type u_4} [has_add M] [add_comm_semigroup N] : has_add (add_hom M N)",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_add M] [add_comm_semigroup N] : has_add (add_hom M N)",
    "args": "{M : Type u_3} {N : Type u_4} [has_add M] [add_comm_semigroup N]",
    "doc_string": " Given two additive morphisms `f`, `g` to an additive commutative semigroup, `f + g` is the additive morphism sending `x` to `f x + g x`.",
    "kind": "def",
    "type": "has_add (add_hom M N)"
  },
  {
    "name": "emetric.continuous_inf_edist",
    "statement": "theorem emetric.continuous_inf_edist {α : Type u} [pseudo_emetric_space α] {s : set α} : continuous (λ (x : α), emetric.inf_edist x s)",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s : set α} : continuous (λ (x : α), emetric.inf_edist x s)",
    "args": "{α : Type u} [pseudo_emetric_space α] {s : set α}",
    "doc_string": "The edist to a set depends continuously on the point",
    "kind": "theorem",
    "type": "continuous (λ (x : α), emetric.inf_edist x s)"
  },
  {
    "name": "pgame.is_option",
    "statement": "inductive pgame.is_option  : pgame → pgame → Prop",
    "theorem": " : pgame → pgame → Prop",
    "args": "",
    "doc_string": "`is_option x y` means that `x` is either a left or right option for `y`.",
    "kind": "inductive",
    "type": "pgame → pgame → Prop"
  },
  {
    "name": "algebraic_topology.dold_kan.c",
    "statement": "def algebraic_topology.dold_kan.c  : complex_shape ℕ",
    "theorem": " : complex_shape ℕ",
    "args": "",
    "doc_string": " As we are using chain complexes indexed by `ℕ`, we shall need the relation `c` such `c m n` if and only if `n+1=m`.",
    "kind": "def",
    "type": "complex_shape ℕ"
  },
  {
    "name": "div_le_div_of_mul_sub_mul_div_nonpos",
    "statement": "theorem div_le_div_of_mul_sub_mul_div_nonpos {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0)",
    "doc_string": "**Alias** of the forward direction of mul_sub_mul_div_mul_nonpos_iff`.",
    "kind": "theorem",
    "type": "(a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d"
  },
  {
    "name": "topological_space.opens.coe_mk",
    "statement": "theorem topological_space.opens.coe_mk {α : Type u_1} [topological_space α] {U : set α} {hU : is_open U} : ↑⟨U, hU⟩ = U",
    "theorem": "{α : Type u_1} [topological_space α] {U : set α} {hU : is_open U} : ↑⟨U, hU⟩ = U",
    "args": "{α : Type u_1} [topological_space α] {U : set α} {hU : is_open U}",
    "doc_string": "the coercion `opens α → set α` applied to a pair is the same as taking the first component",
    "kind": "theorem",
    "type": "↑⟨U, hU⟩ = U"
  },
  {
    "name": "measure_theory.strongly_measurable",
    "statement": "def measure_theory.strongly_measurable {α : Type u_1} {β : Type u_2} [topological_space β] [measurable_space α] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space β] [measurable_space α] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space β] [measurable_space α] (f : α → β)",
    "doc_string": "A function is `strongly_measurable` if it is the limit of simple functions.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "triv_sq_zero_ext.fst",
    "statement": "def triv_sq_zero_ext.fst {R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : R",
    "theorem": "{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : R",
    "args": "{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M)",
    "doc_string": "The canonical projection `triv_sq_zero_ext R M → R`.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "native.float.specification.emin",
    "statement": "constant native.float.specification.emin  : ℤ",
    "theorem": " : ℤ",
    "args": "",
    "doc_string": "The minimum exponent. `= 1 - emax`",
    "kind": "constant",
    "type": "ℤ"
  },
  {
    "name": "fin.coe_val_eq_self",
    "statement": "theorem fin.coe_val_eq_self {n : ℕ} (a : fin (n + 1)) : ↑(a.val) = a",
    "theorem": "{n : ℕ} (a : fin (n + 1)) : ↑(a.val) = a",
    "args": "{n : ℕ} (a : fin (n + 1))",
    "doc_string": " Converting the value of a `fin (n + 1)` to `fin (n + 1)` results in the same value.",
    "kind": "theorem",
    "type": "↑(a.val) = a"
  },
  {
    "name": "topological_fiber_bundle_core.is_open_map_proj",
    "statement": "theorem topological_fiber_bundle_core.is_open_map_proj {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_open_map Z.proj",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_open_map Z.proj",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F)",
    "doc_string": "The projection on the base of a topological bundle created from core is an open map",
    "kind": "theorem",
    "type": "is_open_map Z.proj"
  },
  {
    "name": "mvqpf.pi.P",
    "statement": "def mvqpf.pi.P {n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] : mvpfunctor n",
    "theorem": "{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] : mvpfunctor n",
    "args": "{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)]",
    "doc_string": "polynomial functor representation of a dependent product",
    "kind": "def",
    "type": "mvpfunctor n"
  },
  {
    "name": "bounded_lattice_hom.to_inf_top_hom",
    "statement": "def bounded_lattice_hom.to_inf_top_hom {α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β) : inf_top_hom α β",
    "theorem": "{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β) : inf_top_hom α β",
    "args": "{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β)",
    "doc_string": "Reinterpret a `bounded_lattice_hom` as an `inf_top_hom`.",
    "kind": "def",
    "type": "inf_top_hom α β"
  },
  {
    "name": "add_valuation.is_equiv",
    "statement": "def add_valuation.is_equiv {R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [linear_ordered_add_comm_monoid_with_top Γ₀] [linear_ordered_add_comm_monoid_with_top Γ'₀] [ring R] (v₁ : add_valuation R Γ₀) (v₂ : add_valuation R Γ'₀) : Prop",
    "theorem": "{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [linear_ordered_add_comm_monoid_with_top Γ₀] [linear_ordered_add_comm_monoid_with_top Γ'₀] [ring R] (v₁ : add_valuation R Γ₀) (v₂ : add_valuation R Γ'₀) : Prop",
    "args": "{R : Type u_2} {Γ₀ : Type u_3} {Γ'₀ : Type u_4} [linear_ordered_add_comm_monoid_with_top Γ₀] [linear_ordered_add_comm_monoid_with_top Γ'₀] [ring R] (v₁ : add_valuation R Γ₀) (v₂ : add_valuation R Γ'₀)",
    "doc_string": "Two additive valuations on `R` are defined to be equivalent if they induce the same  preorder on `R`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "path.homotopy",
    "statement": "def path.homotopy {X : Type u} [topological_space X] {x₀ x₁ : X} (p₀ p₁ : path x₀ x₁) : Type u",
    "theorem": "{X : Type u} [topological_space X] {x₀ x₁ : X} (p₀ p₁ : path x₀ x₁) : Type u",
    "args": "{X : Type u} [topological_space X] {x₀ x₁ : X} (p₀ p₁ : path x₀ x₁)",
    "doc_string": "The type of homotopies between two paths.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "abstract_completion",
    "statement": "structure abstract_completion (α : Type u) [uniform_space α] : Type (u+1)",
    "theorem": "(α : Type u) [uniform_space α] : Type (u+1)",
    "args": "(α : Type u) [uniform_space α]",
    "doc_string": " A completion of `α` is the data of a complete separated uniform space (from the same universe) and a map from `α` with dense range and inducing the original uniform structure on `α`.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "category_theory.limits.is_zero.is_terminal",
    "statement": "def category_theory.limits.is_zero.is_terminal {C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_terminal X",
    "theorem": "{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_terminal X",
    "args": "{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X)",
    "doc_string": "A zero object is in particular terminal.",
    "kind": "def",
    "type": "category_theory.limits.is_terminal X"
  },
  {
    "name": "derangements",
    "statement": "def derangements (α : Type u_1) : set (equiv.perm α)",
    "theorem": "(α : Type u_1) : set (equiv.perm α)",
    "args": "(α : Type u_1)",
    "doc_string": "A permutation is a derangement if it has no fixed points.",
    "kind": "def",
    "type": "set (equiv.perm α)"
  },
  {
    "name": "archimedean",
    "statement": "structure archimedean (α : Type u_2) [ordered_add_comm_monoid α] : Prop",
    "theorem": "(α : Type u_2) [ordered_add_comm_monoid α] : Prop",
    "args": "(α : Type u_2) [ordered_add_comm_monoid α]",
    "doc_string": " An ordered additive commutative monoid is called `archimedean` if for any two elements `x`, `y` such that `0 < y` there exists a natural number `n` such that `x ≤ n • y`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "basis.of_vector_space_index",
    "statement": "def basis.of_vector_space_index (K : Type u_4) (V : Type u) [division_ring K] [add_comm_group V] [module K V] : set V",
    "theorem": "(K : Type u_4) (V : Type u) [division_ring K] [add_comm_group V] [module K V] : set V",
    "args": "(K : Type u_4) (V : Type u) [division_ring K] [add_comm_group V] [module K V]",
    "doc_string": "A set used to index `basis.of_vector_space`.",
    "kind": "def",
    "type": "set V"
  },
  {
    "name": "language",
    "statement": "def language (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A language is a set of strings over an alphabet.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "list.lookup",
    "statement": "def list.lookup {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → option (β a)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → option (β a)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α)",
    "doc_string": "`lookup a l` is the first value in `l` corresponding to the key `a`,  or `none` if no such element exists.",
    "kind": "def",
    "type": "list (sigma β) → option (β a)"
  },
  {
    "name": "function.mul_support",
    "statement": "def function.mul_support {α : Type u_1} {M : Type u_5} [has_one M] (f : α → M) : set α",
    "theorem": "{α : Type u_1} {M : Type u_5} [has_one M] (f : α → M) : set α",
    "args": "{α : Type u_1} {M : Type u_5} [has_one M] (f : α → M)",
    "doc_string": "`mul_support` of a function is the set of points `x` such that `f x ≠ 1`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "cocompact_map.id",
    "statement": "def cocompact_map.id (α : Type u_1) [topological_space α] : cocompact_map α α",
    "theorem": "(α : Type u_1) [topological_space α] : cocompact_map α α",
    "args": "(α : Type u_1) [topological_space α]",
    "doc_string": "The identity as a cocompact continuous map.",
    "kind": "def",
    "type": "cocompact_map α α"
  },
  {
    "name": "is_of_fin_order.inv",
    "statement": "theorem is_of_fin_order.inv {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹",
    "theorem": "{G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹",
    "args": "{G : Type u} [group G] {x : G} (hx : is_of_fin_order x)",
    "doc_string": "Inverses of elements of finite order have finite order.",
    "kind": "theorem",
    "type": "is_of_fin_order x⁻¹"
  },
  {
    "name": "lt_or_lt_iff_ne",
    "statement": "theorem lt_or_lt_iff_ne {α : Type u} [linear_order α] {x y : α} : x < y ∨ y < x ↔ x ≠ y",
    "theorem": "{α : Type u} [linear_order α] {x y : α} : x < y ∨ y < x ↔ x ≠ y",
    "args": "{α : Type u} [linear_order α] {x y : α}",
    "doc_string": "A version of `ne_iff_lt_or_gt` with LHS and RHS reversed.",
    "kind": "theorem",
    "type": "x < y ∨ y < x ↔ x ≠ y"
  },
  {
    "name": "nat.sum_four_squares",
    "statement": "theorem nat.sum_four_squares (n : ℕ) : ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n",
    "theorem": "(n : ℕ) : ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n",
    "args": "(n : ℕ)",
    "doc_string": "**Four squares theorem**",
    "kind": "theorem",
    "type": "∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"
  },
  {
    "name": "simple_graph.walk",
    "statement": "inductive simple_graph.walk {V : Type u} (G : simple_graph V) : V → V → Type u",
    "theorem": "{V : Type u} (G : simple_graph V) : V → V → Type u",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": " A walk is a sequence of adjacent vertices.  For vertices `u v : V`, the type `walk u v` consists of all walks starting at `u` and ending at `v`.  We say that a walk *visits* the vertices it contains.  The set of vertices a walk visits is `simple_graph.walk.support`.  See `simple_graph.walk.nil'` and `simple_graph.walk.cons'` for patterns that can be useful in definitions since they make the vertices explicit.",
    "kind": "inductive",
    "type": "V → V → Type u"
  },
  {
    "name": "multiset.product",
    "statement": "def multiset.product {α : Type u_1} {β : Type u_2} (s : multiset α) (t : multiset β) : multiset (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (s : multiset α) (t : multiset β) : multiset (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} (s : multiset α) (t : multiset β)",
    "doc_string": "The multiplicity of `(a, b)` in `s.product t` is  the product of the multiplicity of `a` in `s` and `b` in `t`.",
    "kind": "def",
    "type": "multiset (α × β)"
  },
  {
    "name": "tropical.trop",
    "statement": "def tropical.trop {R : Type u} : R → tropical R",
    "theorem": "{R : Type u} : R → tropical R",
    "args": "{R : Type u}",
    "doc_string": " Reinterpret `x : R` as an element of `tropical R`. See `tropical.trop_equiv` for the equivalence.",
    "kind": "def",
    "type": "R → tropical R"
  },
  {
    "name": "compact_exhaustion.find",
    "statement": "def compact_exhaustion.find {α : Type u} [topological_space α] (K : compact_exhaustion α) (x : α) : ℕ",
    "theorem": "{α : Type u} [topological_space α] (K : compact_exhaustion α) (x : α) : ℕ",
    "args": "{α : Type u} [topological_space α] (K : compact_exhaustion α) (x : α)",
    "doc_string": "The minimal `n` such that `x ∈ K n`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "antivary_on",
    "statement": "def antivary_on {ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) (s : set ι) : Prop",
    "theorem": "{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) (s : set ι) : Prop",
    "args": "{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) (s : set ι)",
    "doc_string": "`f` antivaries with `g` on `s` if `g i < g j` implies `f j ≤ f i` for all `i, j ∈ s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.induced_category",
    "statement": "def category_theory.induced_category {C : Type u₁} (D : Type u₂) [category_theory.category D] (F : C → D) : Type u₁",
    "theorem": "{C : Type u₁} (D : Type u₂) [category_theory.category D] (F : C → D) : Type u₁",
    "args": "{C : Type u₁} (D : Type u₂) [category_theory.category D] (F : C → D)",
    "doc_string": "`induced_category D F`, where `F : C → D`, is a typeclass synonym for `C`, which provides a category structure so that the morphisms `X ⟶ Y` are the morphisms in `D` from `F X` to `F Y`.",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "compact_space.uniform_continuous_of_continuous",
    "statement": "theorem compact_space.uniform_continuous_of_continuous {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [compact_space α] [separated_space α] {f : α → β} (h : continuous f) : uniform_continuous f",
    "theorem": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [compact_space α] [separated_space α] {f : α → β} (h : continuous f) : uniform_continuous f",
    "args": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [compact_space α] [separated_space α] {f : α → β} (h : continuous f)",
    "doc_string": " Heine-Cantor: a continuous function on a compact separated uniform space is uniformly continuous.",
    "kind": "theorem",
    "type": "uniform_continuous f"
  },
  {
    "name": "t0_space",
    "statement": "structure t0_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A T₀ space, also known as a Kolmogorov space, is a topological space  where for every pair `x ≠ y`, there is an open set containing one but not the other.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "dvd_add_left",
    "statement": "theorem dvd_add_left {α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ c) : a ∣ b + c ↔ a ∣ b",
    "theorem": "{α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ c) : a ∣ b + c ↔ a ∣ b",
    "args": "{α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ c)",
    "doc_string": "If an element a divides another element c in a commutative ring, a divides the sum of another  element b with c iff a divides b.",
    "kind": "theorem",
    "type": "a ∣ b + c ↔ a ∣ b"
  },
  {
    "name": "set.bij_on",
    "statement": "def set.bij_on {α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β) : Prop",
    "args": "{α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β)",
    "doc_string": "`f` is bijective from `s` to `t` if `f` is injective on `s` and `f '' s = t`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "shrinking_lemma.partial_refinement.chain_Sup_carrier",
    "statement": "def shrinking_lemma.partial_refinement.chain_Sup_carrier {ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} {s : set X} (c : set (shrinking_lemma.partial_refinement u s)) : set ι",
    "theorem": "{ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} {s : set X} (c : set (shrinking_lemma.partial_refinement u s)) : set ι",
    "args": "{ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] {u : ι → set X} {s : set X} (c : set (shrinking_lemma.partial_refinement u s))",
    "doc_string": " The carrier of the least upper bound of a non-empty chain of partial refinements is the union of their carriers.",
    "kind": "def",
    "type": "set ι"
  },
  {
    "name": "bounded_random",
    "statement": "structure bounded_random (α : Type u) [preorder α] : Type (max 1 u)",
    "theorem": "(α : Type u) [preorder α] : Type (max 1 u)",
    "args": "(α : Type u) [preorder α]",
    "doc_string": "`bounded_random α` gives us machinery to generate values of type `α` between certain bounds",
    "kind": "structure",
    "type": "Type (max 1 u)"
  },
  {
    "name": "category_theory.limits.split_mono_coprod_inr",
    "statement": "def category_theory.limits.split_mono_coprod_inr {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inr",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.split_mono category_theory.limits.coprod.inr",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_colimit (category_theory.limits.pair X Y)]",
    "doc_string": "In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms.",
    "kind": "def",
    "type": "category_theory.split_mono category_theory.limits.coprod.inr"
  },
  {
    "name": "denumerable.raise",
    "statement": "def denumerable.raise  : list ℕ → ℕ → list ℕ",
    "theorem": " : list ℕ → ℕ → list ℕ",
    "args": "",
    "doc_string": " Outputs the list of partial sums of the input list, that is `raise [a₁, a₂, ...] n = [n + a₁, n + a₁ + a₂, ...]`",
    "kind": "def",
    "type": "list ℕ → ℕ → list ℕ"
  },
  {
    "name": "denumerable.ulift",
    "statement": "def denumerable.ulift {α : Type u_1} [denumerable α] : denumerable (ulift α)",
    "theorem": "{α : Type u_1} [denumerable α] : denumerable (ulift α)",
    "args": "{α : Type u_1} [denumerable α]",
    "doc_string": "The lift of a denumerable type is denumerable.",
    "kind": "def",
    "type": "denumerable (ulift α)"
  },
  {
    "name": "vector.zero_subsingleton",
    "statement": "def vector.zero_subsingleton {α : Type u_1} : subsingleton (vector α 0)",
    "theorem": "{α : Type u_1} : subsingleton (vector α 0)",
    "args": "{α : Type u_1}",
    "doc_string": "The empty `vector` is a `subsingleton`.",
    "kind": "def",
    "type": "subsingleton (vector α 0)"
  },
  {
    "name": "function.injective.tendsto_cofinite",
    "statement": "theorem function.injective.tendsto_cofinite {α : Type u_2} {β : Type u_3} {f : α → β} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite",
    "theorem": "{α : Type u_2} {β : Type u_3} {f : α → β} (hf : function.injective f) : filter.tendsto f filter.cofinite filter.cofinite",
    "args": "{α : Type u_2} {β : Type u_3} {f : α → β} (hf : function.injective f)",
    "doc_string": " For an injective function `f`, inverse images of finite sets are finite. See also `filter.comap_cofinite_le` and `function.injective.comap_cofinite_eq`.",
    "kind": "theorem",
    "type": "filter.tendsto f filter.cofinite filter.cofinite"
  },
  {
    "name": "bounded_continuous_function.continuous_eval_const",
    "statement": "theorem bounded_continuous_function.continuous_eval_const {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {x : α} : continuous (λ (f : bounded_continuous_function α β), ⇑f x)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {x : α} : continuous (λ (f : bounded_continuous_function α β), ⇑f x)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {x : α}",
    "doc_string": "When `x` is fixed, `(f : α →ᵇ β) ↦ f x` is continuous",
    "kind": "theorem",
    "type": "continuous (λ (f : bounded_continuous_function α β), ⇑f x)"
  },
  {
    "name": "eq_of_nndist_eq_zero",
    "statement": "theorem eq_of_nndist_eq_zero {γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 → x = y",
    "theorem": "{γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 → x = y",
    "args": "{γ : Type w} [metric_space γ] {x y : γ}",
    "doc_string": "Deduce the equality of points with the vanishing of the nonnegative distance",
    "kind": "theorem",
    "type": "has_nndist.nndist x y = 0 → x = y"
  },
  {
    "name": "submodule.orthogonal",
    "statement": "def submodule.orthogonal {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) : submodule 𝕜 E",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E) : submodule 𝕜 E",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (K : submodule 𝕜 E)",
    "doc_string": "The subspace of vectors orthogonal to a given subspace.",
    "kind": "def",
    "type": "submodule 𝕜 E"
  },
  {
    "name": "tsum",
    "statement": "def tsum {α : Type u_1} [add_comm_monoid α] [topological_space α] {β : Type u_2} (f : β → α) : α",
    "theorem": "{α : Type u_1} [add_comm_monoid α] [topological_space α] {β : Type u_2} (f : β → α) : α",
    "args": "{α : Type u_1} [add_comm_monoid α] [topological_space α] {β : Type u_2} (f : β → α)",
    "doc_string": "`∑' i, f i` is the sum of `f` it exists, or 0 otherwise",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "native.float.specification.emax",
    "statement": "constant native.float.specification.emax  : ℕ",
    "theorem": " : ℕ",
    "args": "",
    "doc_string": "The maximum exponent.",
    "kind": "constant",
    "type": "ℕ"
  },
  {
    "name": "category_theory.limits.has_finite_limits",
    "statement": "structure category_theory.limits.has_finite_limits (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category has all finite limits if every functor `J ⥤ C` with a `fin_category J` instance has a limit.  This is often called 'finitely complete'.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "function.commute.inv_on_fixed_pts_comp",
    "statement": "theorem function.commute.inv_on_fixed_pts_comp {α : Type u} {f g : α → α} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "theorem": "{α : Type u} {f g : α → α} (h : function.commute f g) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "args": "{α : Type u} {f g : α → α} (h : function.commute f g)",
    "doc_string": " If self-maps `f` and `g` commute, then they are inverse of each other on the set of fixed points of `f ∘ g`. This is a particular case of `function.inv_on_fixed_pts_comp`.",
    "kind": "theorem",
    "type": "set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))"
  },
  {
    "name": "homotopy_equiv.refl",
    "statement": "def homotopy_equiv.refl {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} (C : homological_complex V c) : homotopy_equiv C C",
    "theorem": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} (C : homological_complex V c) : homotopy_equiv C C",
    "args": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} (C : homological_complex V c)",
    "doc_string": "Any complex is homotopy equivalent to itself.",
    "kind": "def",
    "type": "homotopy_equiv C C"
  },
  {
    "name": "bounded_continuous_function",
    "statement": "structure bounded_continuous_function (α : Type u) (β : Type v) [topological_space α] [pseudo_metric_space β] : Type (max u v)",
    "theorem": "(α : Type u) (β : Type v) [topological_space α] [pseudo_metric_space β] : Type (max u v)",
    "args": "(α : Type u) (β : Type v) [topological_space α] [pseudo_metric_space β]",
    "doc_string": " `α →ᵇ β` is the type of bounded continuous functions `α → β` from a topological space to a metric space.  When possible, instead of parametrizing results over `(f : α →ᵇ β)`, you should parametrize over `(F : Type*) [bounded_continuous_map_class F α β] (f : F)`.  When you extend this structure, make sure to extend `bounded_continuous_map_class`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "cauchy",
    "statement": "def cauchy {α : Type u} [uniform_space α] (f : filter α) : Prop",
    "theorem": "{α : Type u} [uniform_space α] (f : filter α) : Prop",
    "args": "{α : Type u} [uniform_space α] (f : filter α)",
    "doc_string": "A filter `f` is Cauchy if for every entourage `r`, there exists an  `s ∈ f` such that `s × s ⊆ r`. This is a generalization of Cauchy  sequences, because if `a : ℕ → α` then the filter of sets containing  cofinitely many of the `a n` is Cauchy iff `a` is a Cauchy sequence.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "associates",
    "statement": "def associates (α : Type u_1) [monoid α] : Type u_1",
    "theorem": "(α : Type u_1) [monoid α] : Type u_1",
    "args": "(α : Type u_1) [monoid α]",
    "doc_string": "The quotient of a monoid by the `associated` relation. Two elements `x` and `y`  are associated iff there is a unit `u` such that `x * u = y`. There is a natural  monoid structure on `associates α`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "linarith.sum",
    "statement": "def linarith.sum  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Linear combinations of monomials are represented by mapping monomials to coefficients.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "set.Iio_subset_Iic",
    "statement": "theorem set.Iio_subset_Iic {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Iio a ⊆ set.Iic b",
    "theorem": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Iio a ⊆ set.Iic b",
    "args": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b)",
    "doc_string": " If `a ≤ b`, then `(-∞, a) ⊆ (-∞, b]`. In preorders, this is just an implication. If you need the equivalence in dense linear orders, use `Iio_subset_Iic_iff`.",
    "kind": "theorem",
    "type": "set.Iio a ⊆ set.Iic b"
  },
  {
    "name": "left_cancel_monoid",
    "statement": "structure left_cancel_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": "A monoid in which multiplication is left-cancellative.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "finite_dimensional.nontrivial_of_finrank_eq_succ",
    "statement": "theorem finite_dimensional.nontrivial_of_finrank_eq_succ {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {n : ℕ} (hn : finite_dimensional.finrank K V = n.succ) : nontrivial V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {n : ℕ} (hn : finite_dimensional.finrank K V = n.succ) : nontrivial V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {n : ℕ} (hn : finite_dimensional.finrank K V = n.succ)",
    "doc_string": " A finite dimensional space is nontrivial if it has `finrank` equal to the successor of a natural number.",
    "kind": "theorem",
    "type": "nontrivial V"
  },
  {
    "name": "polynomial.is_root",
    "statement": "def polynomial.is_root {R : Type u} [semiring R] (p : polynomial R) (a : R) : Prop",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) (a : R) : Prop",
    "args": "{R : Type u} [semiring R] (p : polynomial R) (a : R)",
    "doc_string": "`is_root p x` implies `x` is a root of `p`. The evaluation of `p` at `x` is zero",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "option.elim",
    "statement": "def option.elim {α : Type u_1} {β : Type u_2} (b : β) (f : α → β) : option α → β",
    "theorem": "{α : Type u_1} {β : Type u_2} (b : β) (f : α → β) : option α → β",
    "args": "{α : Type u_1} {β : Type u_2} (b : β) (f : α → β)",
    "doc_string": "An elimination principle for `option`. It is a nondependent version of `option.rec`.",
    "kind": "def",
    "type": "option α → β"
  },
  {
    "name": "omega_complete_partial_order.continuous'",
    "statement": "def omega_complete_partial_order.continuous' {α : Type u} {β : Type v} [omega_complete_partial_order α] [omega_complete_partial_order β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [omega_complete_partial_order α] [omega_complete_partial_order β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [omega_complete_partial_order α] [omega_complete_partial_order β] (f : α → β)",
    "doc_string": "`continuous' f` asserts that `f` is both monotone and continuous.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "fin2.left",
    "statement": "def fin2.left (k : ℕ) {n : ℕ} : fin2 n → fin2 (k + n)",
    "theorem": "(k : ℕ) {n : ℕ} : fin2 n → fin2 (k + n)",
    "args": "(k : ℕ) {n : ℕ}",
    "doc_string": "`left k` is the embedding `fin2 n → fin2 (k + n)`",
    "kind": "def",
    "type": "fin2 n → fin2 (k + n)"
  },
  {
    "name": "option.filter",
    "statement": "def option.filter {α : Type u_1} (p : α → Prop) [decidable_pred p] (o : option α) : option α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (o : option α) : option α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (o : option α)",
    "doc_string": "`filter p o` returns `some a` if `o` is `some a` and `p a` holds, otherwise `none`.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "bitvec.to_fin",
    "statement": "def bitvec.to_fin {n : ℕ} (i : bitvec n) : fin (2 ^ n)",
    "theorem": "{n : ℕ} (i : bitvec n) : fin (2 ^ n)",
    "args": "{n : ℕ} (i : bitvec n)",
    "doc_string": "convert `bitvec` to `fin`",
    "kind": "def",
    "type": "fin (2 ^ n)"
  },
  {
    "name": "real.tendsto_pow_mul_exp_neg_at_top_nhds_0",
    "statement": "theorem real.tendsto_pow_mul_exp_neg_at_top_nhds_0 (n : ℕ) : filter.tendsto (λ (x : ℝ), x ^ n * real.exp (-x)) filter.at_top (nhds 0)",
    "theorem": "(n : ℕ) : filter.tendsto (λ (x : ℝ), x ^ n * real.exp (-x)) filter.at_top (nhds 0)",
    "args": "(n : ℕ)",
    "doc_string": "The function `x^n * exp(-x)` tends to `0` at `+∞`, for any natural number `n`.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (x : ℝ), x ^ n * real.exp (-x)) filter.at_top (nhds 0)"
  },
  {
    "name": "is_compact.bdd_below",
    "statement": "theorem is_compact.bdd_below {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_below s",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_below s",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s)",
    "doc_string": "A compact set is bounded below",
    "kind": "theorem",
    "type": "bdd_below s"
  },
  {
    "name": "is_topological_fiber_bundle.continuous_proj",
    "statement": "theorem is_topological_fiber_bundle.continuous_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : continuous proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj)",
    "doc_string": "The projection from a topological fiber bundle to its base is continuous.",
    "kind": "theorem",
    "type": "continuous proj"
  },
  {
    "name": "topological_semiring.has_continuous_neg_of_mul",
    "statement": "theorem topological_semiring.has_continuous_neg_of_mul {α : Type u_1} [topological_space α] [non_assoc_ring α] [has_continuous_mul α] : has_continuous_neg α",
    "theorem": "{α : Type u_1} [topological_space α] [non_assoc_ring α] [has_continuous_mul α] : has_continuous_neg α",
    "args": "{α : Type u_1} [topological_space α] [non_assoc_ring α] [has_continuous_mul α]",
    "doc_string": " If `R` is a ring with a continuous multiplication, then negation is continuous as well since it is just multiplication with `-1`.",
    "kind": "theorem",
    "type": "has_continuous_neg α"
  },
  {
    "name": "rel_hom",
    "statement": "structure rel_hom {α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "theorem": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "args": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop)",
    "doc_string": " A relation homomorphism with respect to a given pair of relations `r` and `s` is a function `f : α → β` such that `r a b → s (f a) (f b)`.",
    "kind": "structure",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "part.partial_order",
    "statement": "def part.partial_order {α : Type u_1} : partial_order (part α)",
    "theorem": "{α : Type u_1} : partial_order (part α)",
    "args": "{α : Type u_1}",
    "doc_string": "We give `part α` the order where everything is greater than `none`.",
    "kind": "def",
    "type": "partial_order (part α)"
  },
  {
    "name": "has_binary_coproducts_of_initial_and_pushouts",
    "statement": "theorem has_binary_coproducts_of_initial_and_pushouts (C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C] : category_theory.limits.has_binary_coproducts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_pushouts C]",
    "doc_string": "Any category with pushouts and initial object has binary coproducts.",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_coproducts C"
  },
  {
    "name": "turing.list_blank.append",
    "statement": "def turing.list_blank.append {Γ : Type u_1} [inhabited Γ] : list Γ → turing.list_blank Γ → turing.list_blank Γ",
    "theorem": "{Γ : Type u_1} [inhabited Γ] : list Γ → turing.list_blank Γ → turing.list_blank Γ",
    "args": "{Γ : Type u_1} [inhabited Γ]",
    "doc_string": "Append a list on the left side of a list_blank.",
    "kind": "def",
    "type": "list Γ → turing.list_blank Γ → turing.list_blank Γ"
  },
  {
    "name": "seq.to_list'",
    "statement": "def seq.to_list' {α : Type u_1} (s : seq α) : computation (list α)",
    "theorem": "{α : Type u_1} (s : seq α) : computation (list α)",
    "args": "{α : Type u_1} (s : seq α)",
    "doc_string": "Convert a sequence into a list, embedded in a computation to allow for  the possibility of infinite sequences (in which case the computation  never returns anything).",
    "kind": "def",
    "type": "computation (list α)"
  },
  {
    "name": "setoid.is_partition",
    "statement": "def setoid.is_partition {α : Type u_1} (c : set (set α)) : Prop",
    "theorem": "{α : Type u_1} (c : set (set α)) : Prop",
    "args": "{α : Type u_1} (c : set (set α))",
    "doc_string": " A collection `c : set (set α)` of sets is a partition of `α` into pairwise disjoint sets if `∅ ∉ c` and each element `a : α` belongs to a unique set `b ∈ c`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.is_detecting",
    "statement": "def category_theory.is_detecting {C : Type u} [category_theory.category C] (𝒢 : set C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (𝒢 : set C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (𝒢 : set C)",
    "doc_string": "We say that `𝒢` is a detecting set if the functors `C(G, -)` collectively reflect isomorphisms,    i.e., if any `h` with domain in `𝒢` uniquely factors through `f`, then `f` is an isomorphism.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "submodule.colon",
    "statement": "def submodule.colon {R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (N P : submodule R M) : ideal R",
    "theorem": "{R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (N P : submodule R M) : ideal R",
    "args": "{R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (N P : submodule R M)",
    "doc_string": "`N.colon P` is the ideal of all elements `r : R` such that `r • P ⊆ N`.",
    "kind": "def",
    "type": "ideal R"
  },
  {
    "name": "modular_group.bottom_row_coprime",
    "statement": "theorem modular_group.bottom_row_coprime {R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (↑g 1 0) (↑g 1 1)",
    "theorem": "{R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R) : is_coprime (↑g 1 0) (↑g 1 1)",
    "args": "{R : Type u_1} [comm_ring R] (g : matrix.special_linear_group (fin 2) R)",
    "doc_string": "The two numbers `c`, `d` in the \"bottom_row\" of `g=[[*,*],[c,d]]` in `SL(2, ℤ)` are coprime.",
    "kind": "theorem",
    "type": "is_coprime (↑g 1 0) (↑g 1 1)"
  },
  {
    "name": "int.exists_strict_anti",
    "statement": "theorem int.exists_strict_anti (α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_anti f",
    "theorem": "(α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_anti f",
    "args": "(α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α]",
    "doc_string": " If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly antitone function `f : ℤ → α`.",
    "kind": "theorem",
    "type": "∃ (f : ℤ → α), strict_anti f"
  },
  {
    "name": "AddCommGroup.of",
    "statement": "def AddCommGroup.of (G : Type u) [add_comm_group G] : AddCommGroup",
    "theorem": "(G : Type u) [add_comm_group G] : AddCommGroup",
    "args": "(G : Type u) [add_comm_group G]",
    "doc_string": "Construct a bundled `AddCommGroup` from the underlying type and typeclass.",
    "kind": "def",
    "type": "AddCommGroup"
  },
  {
    "name": "boolean_algebra.core",
    "statement": "structure boolean_algebra.core (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " This class contains the core axioms of a Boolean algebra. The `boolean_algebra` class extends both this class and `generalized_boolean_algebra`, see Note [forgetful inheritance].  Since `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le` to be present at define-time, the `extends` mechanism does not work with them. Instead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the order axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "ordnode.split_min",
    "statement": "def ordnode.split_min {α : Type u} : ordnode α → option (α × ordnode α)",
    "theorem": "{α : Type u} : ordnode α → option (α × ordnode α)",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Extract and remove the minimum element from the tree, if it exists.      split_min {1, 2, 3} = some (1, {2, 3})     split_min ∅ = none",
    "kind": "def",
    "type": "ordnode α → option (α × ordnode α)"
  },
  {
    "name": "category_theory.limits.has_binary_coproduct",
    "statement": "def category_theory.limits.has_binary_coproduct {C : Type u} [category_theory.category C] (X Y : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (X Y : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (X Y : C)",
    "doc_string": "An abbreviation for `has_colimit (pair X Y)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "multiset.fold",
    "statement": "def multiset.fold {α : Type u_1} (op : α → α → α) [hc : is_commutative α op] [ha : is_associative α op] : α → multiset α → α",
    "theorem": "{α : Type u_1} (op : α → α → α) [hc : is_commutative α op] [ha : is_associative α op] : α → multiset α → α",
    "args": "{α : Type u_1} (op : α → α → α) [hc : is_commutative α op] [ha : is_associative α op]",
    "doc_string": "`fold op b s` folds a commutative associative operation `op` over  the multiset `s`.",
    "kind": "def",
    "type": "α → multiset α → α"
  },
  {
    "name": "plift.pure",
    "statement": "def plift.pure {α : Sort u} : α → plift α",
    "theorem": "{α : Sort u} : α → plift α",
    "args": "{α : Sort u}",
    "doc_string": "Embedding of pure values.",
    "kind": "def",
    "type": "α → plift α"
  },
  {
    "name": "category_theory.sheaf_over",
    "statement": "def category_theory.sheaf_over {C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] {J : category_theory.grothendieck_topology C} (ℱ : category_theory.Sheaf J A) (E : A) : category_theory.SheafOfTypes J",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] {J : category_theory.grothendieck_topology C} (ℱ : category_theory.Sheaf J A) (E : A) : category_theory.SheafOfTypes J",
    "args": "{C : Type u₁} [category_theory.category C] {A : Type u₂} [category_theory.category A] {J : category_theory.grothendieck_topology C} (ℱ : category_theory.Sheaf J A) (E : A)",
    "doc_string": "The sheaf of sections guaranteed by the sheaf condition.",
    "kind": "def",
    "type": "category_theory.SheafOfTypes J"
  },
  {
    "name": "mul_zero_class",
    "statement": "structure mul_zero_class (M₀ : Type u_4) : Type u_4",
    "theorem": "(M₀ : Type u_4) : Type u_4",
    "args": "(M₀ : Type u_4)",
    "doc_string": " Typeclass for expressing that a type `M₀` with multiplication and a zero satisfies `0 * a = 0` and `a * 0 = 0` for all `a : M₀`.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "rel.codom",
    "statement": "def rel.codom {α : Type u_1} {β : Type u_2} (r : rel α β) : set β",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : rel α β) : set β",
    "args": "{α : Type u_1} {β : Type u_2} (r : rel α β)",
    "doc_string": "Codomain aka range of a relation",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "pgame.state",
    "statement": "structure pgame.state (S : Type u) : Type u",
    "theorem": "(S : Type u) : Type u",
    "args": "(S : Type u)",
    "doc_string": "`pgame_state S` describes how to interpret `s : S` as a state of a combinatorial game. Use `pgame.of s` or `game.of s` to construct the game.  `pgame_state.L : S → finset S` and `pgame_state.R : S → finset S` describe the states reachable by a move by Left or Right. `pgame_state.turn_bound : S → ℕ` gives an upper bound on the number of possible turns remaining from this state.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "turing.to_partrec.code.nil",
    "statement": "def turing.to_partrec.code.nil  : turing.to_partrec.code",
    "theorem": " : turing.to_partrec.code",
    "args": "",
    "doc_string": "`nil` is the constant nil function: `nil v = []`.",
    "kind": "def",
    "type": "turing.to_partrec.code"
  },
  {
    "name": "subsemiring.coe_closure_eq",
    "statement": "theorem subsemiring.coe_closure_eq {R : Type u} [non_assoc_semiring R] (s : set R) : ↑(subsemiring.closure s) = ↑(add_submonoid.closure ↑(submonoid.closure s))",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : set R) : ↑(subsemiring.closure s) = ↑(add_submonoid.closure ↑(submonoid.closure s))",
    "args": "{R : Type u} [non_assoc_semiring R] (s : set R)",
    "doc_string": " The elements of the subsemiring closure of `M` are exactly the elements of the additive closure of a multiplicative submonoid `M`.",
    "kind": "theorem",
    "type": "↑(subsemiring.closure s) = ↑(add_submonoid.closure ↑(submonoid.closure s))"
  },
  {
    "name": "snum.bit0",
    "statement": "def snum.bit0  : snum → snum",
    "theorem": " : snum → snum",
    "args": "",
    "doc_string": "Add an inactive bit at the end of a `snum`. This mimics `znum.bit0`.",
    "kind": "def",
    "type": "snum → snum"
  },
  {
    "name": "dense_inducing.extend",
    "statement": "def dense_inducing.extend {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] {i : α → β} [topological_space γ] (di : dense_inducing i) (f : α → γ) (b : β) : γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] {i : α → β} [topological_space γ] (di : dense_inducing i) (f : α → γ) (b : β) : γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] {i : α → β} [topological_space γ] (di : dense_inducing i) (f : α → γ) (b : β)",
    "doc_string": "If `i : α → β` is a dense inducing, then any function `f : α → γ` \"extends\"  to a function `g = extend di f : β → γ`. If `γ` is Hausdorff and `f` has a  continuous extension, then `g` is the unique such extension. In general,  `g` might not be continuous or even extend `f`.",
    "kind": "def",
    "type": "γ"
  },
  {
    "name": "measure_theory.simple_func.comp",
    "statement": "def measure_theory.simple_func.comp {α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] (f : measure_theory.simple_func β γ) (g : α → β) (hgm : measurable g) : measure_theory.simple_func α γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] (f : measure_theory.simple_func β γ) (g : α → β) (hgm : measurable g) : measure_theory.simple_func α γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] [measurable_space β] (f : measure_theory.simple_func β γ) (g : α → β) (hgm : measurable g)",
    "doc_string": "Composition of a `simple_fun` and a measurable function is a `simple_func`.",
    "kind": "def",
    "type": "measure_theory.simple_func α γ"
  },
  {
    "name": "linear_pmap",
    "statement": "structure linear_pmap (R : Type u) [ring R] (E : Type v) [add_comm_group E] [module R E] (F : Type w) [add_comm_group F] [module R F] : Type (max v w)",
    "theorem": "(R : Type u) [ring R] (E : Type v) [add_comm_group E] [module R E] (F : Type w) [add_comm_group F] [module R F] : Type (max v w)",
    "args": "(R : Type u) [ring R] (E : Type v) [add_comm_group E] [module R E] (F : Type w) [add_comm_group F] [module R F]",
    "doc_string": "A `linear_pmap R E F` is a linear map from a submodule of `E` to `F`.",
    "kind": "structure",
    "type": "Type (max v w)"
  },
  {
    "name": "subalgebra.topological_closure",
    "statement": "def subalgebra.topological_closure {R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] (s : subalgebra R A) : subalgebra R A",
    "theorem": "{R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] (s : subalgebra R A) : subalgebra R A",
    "args": "{R : Type u_1} [comm_semiring R] {A : Type u} [topological_space A] [semiring A] [algebra R A] [topological_semiring A] (s : subalgebra R A)",
    "doc_string": "The closure of a subalgebra in a topological algebra as a subalgebra.",
    "kind": "def",
    "type": "subalgebra R A"
  },
  {
    "name": "onote.mul",
    "statement": "def onote.mul  : onote → onote → onote",
    "theorem": " : onote → onote → onote",
    "args": "",
    "doc_string": "Multiplication of ordinal notations (correct only for normal input)",
    "kind": "def",
    "type": "onote → onote → onote"
  },
  {
    "name": "Prop.bounded_order",
    "statement": "def Prop.bounded_order  : bounded_order Prop",
    "theorem": " : bounded_order Prop",
    "args": "",
    "doc_string": "Propositions form a bounded order.",
    "kind": "def",
    "type": "bounded_order Prop"
  },
  {
    "name": "nat.digits_lt_base",
    "statement": "theorem nat.digits_lt_base {b m d : ℕ} (hb : 2 ≤ b) (hd : d ∈ b.digits m) : d < b",
    "theorem": "{b m d : ℕ} (hb : 2 ≤ b) (hd : d ∈ b.digits m) : d < b",
    "args": "{b m d : ℕ} (hb : 2 ≤ b) (hd : d ∈ b.digits m)",
    "doc_string": "The digits in the base b expansion of n are all less than b, if b ≥ 2",
    "kind": "theorem",
    "type": "d < b"
  },
  {
    "name": "order_of",
    "statement": "def order_of {G : Type u} [monoid G] (x : G) : ℕ",
    "theorem": "{G : Type u} [monoid G] (x : G) : ℕ",
    "args": "{G : Type u} [monoid G] (x : G)",
    "doc_string": " `order_of x` is the order of the element `x`, i.e. the `n ≥ 1`, s.t. `x ^ n = 1` if it exists. Otherwise, i.e. if `x` is of infinite order, then `order_of x` is `0` by convention.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "list.dprod_index",
    "statement": "def list.dprod_index {ι : Type u_1} {α : Type u_2} [add_monoid ι] (l : list α) (fι : α → ι) : ι",
    "theorem": "{ι : Type u_1} {α : Type u_2} [add_monoid ι] (l : list α) (fι : α → ι) : ι",
    "args": "{ι : Type u_1} {α : Type u_2} [add_monoid ι] (l : list α) (fι : α → ι)",
    "doc_string": " The index used by `list.dprod`. Propositionally this is equal to `(l.map fι).sum`, but definitionally it needs to have a different form to avoid introducing `eq.rec`s in `list.dprod`.",
    "kind": "def",
    "type": "ι"
  },
  {
    "name": "pi.unique_of_is_empty",
    "statement": "def pi.unique_of_is_empty {α : Sort u} [is_empty α] (β : α → Sort v) : unique (Π (a : α), β a)",
    "theorem": "{α : Sort u} [is_empty α] (β : α → Sort v) : unique (Π (a : α), β a)",
    "args": "{α : Sort u} [is_empty α] (β : α → Sort v)",
    "doc_string": "There is a unique function on an empty domain.",
    "kind": "def",
    "type": "unique (Π (a : α), β a)"
  },
  {
    "name": "lie_algebra.is_engelian",
    "statement": "def lie_algebra.is_engelian (R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "theorem": "(R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "args": "(R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": " A Lie algebra `L` is said to be Engelian if a sufficient condition for any `L`-Lie module `M` to be nilpotent is that the image of the map `L → End(M)` consists of nilpotent elements.  Engel's theorem `lie_algebra.is_engelian_of_is_noetherian` states that any Noetherian Lie algebra is Engelian.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_valuation",
    "statement": "def add_valuation (R : Type u_2) [ring R] (Γ₀ : Type u_3) [linear_ordered_add_comm_monoid_with_top Γ₀] : Type (max u_2 u_3)",
    "theorem": "(R : Type u_2) [ring R] (Γ₀ : Type u_3) [linear_ordered_add_comm_monoid_with_top Γ₀] : Type (max u_2 u_3)",
    "args": "(R : Type u_2) [ring R] (Γ₀ : Type u_3) [linear_ordered_add_comm_monoid_with_top Γ₀]",
    "doc_string": "The type of `Γ₀`-valued additive valuations on `R`.",
    "kind": "def",
    "type": "Type (max u_2 u_3)"
  },
  {
    "name": "cast_znum",
    "statement": "def cast_znum {α : Type u_1} [has_zero α] [has_one α] [has_add α] [has_neg α] : znum → α",
    "theorem": "{α : Type u_1} [has_zero α] [has_one α] [has_add α] [has_neg α] : znum → α",
    "args": "{α : Type u_1} [has_zero α] [has_one α] [has_add α] [has_neg α]",
    "doc_string": "`cast_znum` casts a `znum` into any type which has `0`, `1`, `+` and `neg`",
    "kind": "def",
    "type": "znum → α"
  },
  {
    "name": "graded_monoid.grade_zero.mul_action",
    "statement": "def graded_monoid.grade_zero.mul_action {ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] {i : ι} : mul_action (A 0) (A i)",
    "theorem": "{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] {i : ι} : mul_action (A 0) (A i)",
    "args": "{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] {i : ι}",
    "doc_string": "Each grade `A i` derives a `A 0`-action structure from `gmonoid A`.",
    "kind": "def",
    "type": "mul_action (A 0) (A i)"
  },
  {
    "name": "category_theory.cosimplicial_object",
    "statement": "def category_theory.cosimplicial_object (C : Type u) [category_theory.category C] : Type (max v u)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max v u)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "Cosimplicial objects.",
    "kind": "def",
    "type": "Type (max v u)"
  },
  {
    "name": "ring_topology.complete_semilattice_Inf",
    "statement": "def ring_topology.complete_semilattice_Inf {α : Type u_1} [ring α] : complete_semilattice_Inf (ring_topology α)",
    "theorem": "{α : Type u_1} [ring α] : complete_semilattice_Inf (ring_topology α)",
    "args": "{α : Type u_1} [ring α]",
    "doc_string": " Ring topologies on `α` form a complete lattice, with `⊥` the discrete topology and `⊤` the indiscrete topology.  The infimum of a collection of ring topologies is the topology generated by all their open sets (which is a ring topology).  The supremum of two ring topologies `s` and `t` is the infimum of the family of all ring topologies contained in the intersection of `s` and `t`.",
    "kind": "def",
    "type": "complete_semilattice_Inf (ring_topology α)"
  },
  {
    "name": "quiver.empty",
    "statement": "def quiver.empty (V : Type u) : Type u",
    "theorem": "(V : Type u) : Type u",
    "args": "(V : Type u)",
    "doc_string": "A type synonym for a quiver with no arrows.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "witt_vector.frobenius_poly_aux",
    "statement": "def witt_vector.frobenius_poly_aux (p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial ℕ ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial ℕ ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": " An auxiliary polynomial over the integers, that satisfies `p * (frobenius_poly_aux p n) + X n ^ p = frobenius_poly p n`. This makes it easy to show that `frobenius_poly p n` is congruent to `X n ^ p` modulo `p`.",
    "kind": "def",
    "type": "ℕ → mv_polynomial ℕ ℤ"
  },
  {
    "name": "list.mmap'_diag",
    "statement": "def list.mmap'_diag {m : Type → Type u_1} [monad m] {α : Type u_2} (f : α → α → m unit) : list α → m unit",
    "theorem": "{m : Type → Type u_1} [monad m] {α : Type u_2} (f : α → α → m unit) : list α → m unit",
    "args": "{m : Type → Type u_1} [monad m] {α : Type u_2} (f : α → α → m unit)",
    "doc_string": "`mmap'_diag f l` calls `f` on all elements in the upper triangular part of `l × l`. That is, for each `e ∈ l`, it will run `f e e` and then `f e e'` for each `e'` that appears after `e` in `l`.  Example: suppose `l = [1, 2, 3]`. `mmap'_diag f l` will evaluate, in this order, `f 1 1`, `f 1 2`, `f 1 3`, `f 2 2`, `f 2 3`, `f 3 3`.",
    "kind": "def",
    "type": "list α → m unit"
  },
  {
    "name": "matrix.has_orthogonal_rows",
    "statement": "def matrix.has_orthogonal_rows {α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype n] : Prop",
    "theorem": "{α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype n] : Prop",
    "args": "{α : Type u_1} {n : Type u_2} {m : Type u_3} [has_mul α] [add_comm_monoid α] (A : matrix m n α) [fintype n]",
    "doc_string": " `A.has_orthogonal_rows` means matrix `A` has orthogonal rows (with respect to `matrix.dot_product`).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "complete_graph",
    "statement": "def complete_graph (V : Type u) : simple_graph V",
    "theorem": "(V : Type u) : simple_graph V",
    "args": "(V : Type u)",
    "doc_string": " The complete graph on a type `V` is the simple graph with all pairs of distinct vertices adjacent. In `mathlib`, this is usually referred to as `⊤`.",
    "kind": "def",
    "type": "simple_graph V"
  },
  {
    "name": "measure_theory.measure.haar.index",
    "statement": "def measure_theory.measure.haar.index {G : Type u_1} [group G] (K V : set G) : ℕ",
    "theorem": "{G : Type u_1} [group G] (K V : set G) : ℕ",
    "args": "{G : Type u_1} [group G] (K V : set G)",
    "doc_string": "The index or Haar covering number or ratio of `K` w.r.t. `V`, denoted `(K : V)`:  it is the smallest number of (left) translates of `V` that is necessary to cover `K`.  It is defined to be 0 if no finite number of translates cover `K`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "bounded_order_hom_class",
    "statement": "structure bounded_order_hom_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_le α] [has_le β] [bounded_order α] [bounded_order β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_le α] [has_le β] [bounded_order α] [bounded_order β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_le α] [has_le β] [bounded_order α] [bounded_order β]",
    "doc_string": " `bounded_order_hom_class F α β` states that `F` is a type of bounded order morphisms.  You should extend this class when you extend `bounded_order_hom`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "witt_vector.frobenius_fun",
    "statement": "def witt_vector.frobenius_fun {p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : witt_vector p R",
    "theorem": "{p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : witt_vector p R",
    "args": "{p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R)",
    "doc_string": " `frobenius_fun` is the function underlying the ring endomorphism `frobenius : 𝕎 R →+* frobenius 𝕎 R`.",
    "kind": "def",
    "type": "witt_vector p R"
  },
  {
    "name": "graded_monoid.ghas_mul",
    "statement": "structure graded_monoid.ghas_mul {ι : Type u_1} (A : ι → Type u_2) [has_add ι] : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} (A : ι → Type u_2) [has_add ι] : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} (A : ι → Type u_2) [has_add ι]",
    "doc_string": " A graded version of `has_mul`. Multiplication combines grades additively, like `add_monoid_algebra`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "lazy_list.nth",
    "statement": "def lazy_list.nth {α : Type u} : lazy_list α → ℕ → option α",
    "theorem": "{α : Type u} : lazy_list α → ℕ → option α",
    "args": "{α : Type u}",
    "doc_string": "The nth element of a lazy list as an option (like `list.nth`).",
    "kind": "def",
    "type": "lazy_list α → ℕ → option α"
  },
  {
    "name": "category_theory.limits.has_equalizers_of_pullbacks_and_binary_products",
    "statement": "theorem category_theory.limits.has_equalizers_of_pullbacks_and_binary_products {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_equalizers C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_pullbacks C]",
    "doc_string": "Any category with pullbacks and binary products, has equalizers.",
    "kind": "theorem",
    "type": "category_theory.limits.has_equalizers C"
  },
  {
    "name": "order.succ_lt_succ",
    "statement": "theorem order.succ_lt_succ {α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : a < b → order.succ a < order.succ b",
    "theorem": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : a < b → order.succ a < order.succ b",
    "args": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α]",
    "doc_string": "**Alias** of the reverse direction of order.succ_lt_succ_iff`.",
    "kind": "theorem",
    "type": "a < b → order.succ a < order.succ b"
  },
  {
    "name": "ordinal.type",
    "statement": "def ordinal.type {α : Type u_1} (r : α → α → Prop) [wo : is_well_order α r] : ordinal",
    "theorem": "{α : Type u_1} (r : α → α → Prop) [wo : is_well_order α r] : ordinal",
    "args": "{α : Type u_1} (r : α → α → Prop) [wo : is_well_order α r]",
    "doc_string": "The order type of a well order is an ordinal.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "fin.cast_pred",
    "statement": "def fin.cast_pred {n : ℕ} (i : fin (n + 2)) : fin (n + 1)",
    "theorem": "{n : ℕ} (i : fin (n + 2)) : fin (n + 1)",
    "args": "{n : ℕ} (i : fin (n + 2))",
    "doc_string": " `cast_pred` embeds `i : fin (n + 2)` into `fin (n + 1)` by lowering just `last (n + 1)` to `last n`.",
    "kind": "def",
    "type": "fin (n + 1)"
  },
  {
    "name": "has_exists_mul_of_le",
    "statement": "structure has_exists_mul_of_le (α : Type u) [has_mul α] [has_le α] : Prop",
    "theorem": "(α : Type u) [has_mul α] [has_le α] : Prop",
    "args": "(α : Type u) [has_mul α] [has_le α]",
    "doc_string": " An `ordered_comm_monoid` with one-sided 'division' in the sense that if `a ≤ b`, there is some `c` for which `a * c = b`. This is a weaker version of the condition on canonical orderings defined by `canonically_ordered_monoid`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "DFA.to_NFA",
    "statement": "def DFA.to_NFA {α : Type u} {σ' : Type v} (M : DFA α σ') : NFA α σ'",
    "theorem": "{α : Type u} {σ' : Type v} (M : DFA α σ') : NFA α σ'",
    "args": "{α : Type u} {σ' : Type v} (M : DFA α σ')",
    "doc_string": "`M.to_NFA` is an `NFA` constructed from a `DFA` `M` by using the same start and accept  states and a transition function which sends `s` with input `a` to the singleton `M.step s a`.",
    "kind": "def",
    "type": "NFA α σ'"
  },
  {
    "name": "prod.topological_ring",
    "statement": "def prod.topological_ring {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [non_unital_non_assoc_ring α] [non_unital_non_assoc_ring β] [topological_ring α] [topological_ring β] : topological_ring (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [non_unital_non_assoc_ring α] [non_unital_non_assoc_ring β] [topological_ring α] [topological_ring β] : topological_ring (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [non_unital_non_assoc_ring α] [non_unital_non_assoc_ring β] [topological_ring α] [topological_ring β]",
    "doc_string": "The product topology on the cartesian product of two topological rings  makes the product into a topological ring.",
    "kind": "def",
    "type": "topological_ring (α × β)"
  },
  {
    "name": "finset.has_vsub",
    "statement": "def finset.has_vsub {α : Type u_2} {β : Type u_3} [decidable_eq α] [has_vsub α β] : has_vsub (finset α) (finset β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [decidable_eq α] [has_vsub α β] : has_vsub (finset α) (finset β)",
    "args": "{α : Type u_2} {β : Type u_3} [decidable_eq α] [has_vsub α β]",
    "doc_string": "The pointwise product of two finsets `s` and `t`: `s -ᵥ t = {x -ᵥ y | x ∈ s, y ∈ t}`.",
    "kind": "def",
    "type": "has_vsub (finset α) (finset β)"
  },
  {
    "name": "ray_vector.setoid",
    "statement": "def ray_vector.setoid (R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : setoid (ray_vector R M)",
    "theorem": "(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : setoid (ray_vector R M)",
    "args": "(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M]",
    "doc_string": "The setoid of the `same_ray` relation for the subtype of nonzero vectors.",
    "kind": "def",
    "type": "setoid (ray_vector R M)"
  },
  {
    "name": "add_le_cancellable",
    "statement": "def add_le_cancellable {α : Type u_1} [has_add α] [has_le α] (a : α) : Prop",
    "theorem": "{α : Type u_1} [has_add α] [has_le α] (a : α) : Prop",
    "args": "{α : Type u_1} [has_add α] [has_le α] (a : α)",
    "doc_string": " An element `a : α` is `add_le_cancellable` if `x ↦ a + x` is order-reflecting. We will make a separate version of many lemmas that require `[contravariant_class α α (+) (≤)]` with `mul_le_cancellable` assumptions instead. These lemmas can then be instantiated to specific types, like `ennreal`, where we can replace the assumption `add_le_cancellable x` by `x ≠ ∞`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pseudo_epimorphism_class",
    "statement": "structure pseudo_epimorphism_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β]",
    "doc_string": " `pseudo_epimorphism_class F α β` states that `F` is a type of `⊔`-preserving morphisms.  You should extend this class when you extend `pseudo_epimorphism`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "composition_as_set.blocks_fun",
    "statement": "def composition_as_set.blocks_fun {n : ℕ} (c : composition_as_set n) (i : fin c.length) : ℕ",
    "theorem": "{n : ℕ} (c : composition_as_set n) (i : fin c.length) : ℕ",
    "args": "{n : ℕ} (c : composition_as_set n) (i : fin c.length)",
    "doc_string": "Size of the `i`-th block in a `composition_as_set`, seen as a function on `fin c.length`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "semiconj_by.eq",
    "statement": "theorem semiconj_by.eq {S : Type u} [has_mul S] {a x y : S} (h : semiconj_by a x y) : a * x = y * a",
    "theorem": "{S : Type u} [has_mul S] {a x y : S} (h : semiconj_by a x y) : a * x = y * a",
    "args": "{S : Type u} [has_mul S] {a x y : S} (h : semiconj_by a x y)",
    "doc_string": "Equality behind `semiconj_by a x y`; useful for rewriting.",
    "kind": "theorem",
    "type": "a * x = y * a"
  },
  {
    "name": "is_empty_elim",
    "statement": "def is_empty_elim {α : Sort u_1} [is_empty α] {p : α → Sort u_2} (a : α) : p a",
    "theorem": "{α : Sort u_1} [is_empty α] {p : α → Sort u_2} (a : α) : p a",
    "args": "{α : Sort u_1} [is_empty α] {p : α → Sort u_2} (a : α)",
    "doc_string": "Eliminate out of a type that `is_empty` (without using projection notation).",
    "kind": "def",
    "type": "p a"
  },
  {
    "name": "fin.cons_self_tail",
    "statement": "theorem fin.cons_self_tail {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.cons (q 0) (fin.tail q) = q",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.cons (q 0) (fin.tail q) = q",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i)",
    "doc_string": "Concatenating the first element of a tuple with its tail gives back the original tuple",
    "kind": "theorem",
    "type": "fin.cons (q 0) (fin.tail q) = q"
  },
  {
    "name": "slim_check.slim_check_cfg",
    "statement": "structure slim_check.slim_check_cfg  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "configuration for testing a property",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "as_linear_order",
    "statement": "def as_linear_order (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " Type synonym to create an instance of `linear_order` from a `partial_order` and `is_total α (≤)`",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "left.one_lt_mul",
    "statement": "theorem left.one_lt_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "subsemiring.multiset_prod_mem",
    "statement": "theorem subsemiring.multiset_prod_mem {R : Type u_1} [comm_semiring R] (s : subsemiring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s",
    "theorem": "{R : Type u_1} [comm_semiring R] (s : subsemiring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s",
    "args": "{R : Type u_1} [comm_semiring R] (s : subsemiring R) (m : multiset R)",
    "doc_string": "Product of a multiset of elements in a `subsemiring` of a `comm_semiring`    is in the `subsemiring`.",
    "kind": "theorem",
    "type": "(∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s"
  },
  {
    "name": "has_continuous_inv₀",
    "statement": "structure has_continuous_inv₀ (G₀ : Type u_4) [has_zero G₀] [has_inv G₀] [topological_space G₀] : Prop",
    "theorem": "(G₀ : Type u_4) [has_zero G₀] [has_inv G₀] [topological_space G₀] : Prop",
    "args": "(G₀ : Type u_4) [has_zero G₀] [has_inv G₀] [topological_space G₀]",
    "doc_string": " A type with `0` and `has_inv` such that `λ x, x⁻¹` is continuous at all nonzero points. Any normed (semi)field has this property.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_localization",
    "statement": "structure is_localization {R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop",
    "theorem": "{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop",
    "args": "{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S]",
    "doc_string": " The typeclass `is_localization (M : submodule R) S` where `S` is an `R`-algebra expresses that `S` is isomorphic to the localization of `R` at `M`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "znum.pred",
    "statement": "def znum.pred  : znum → znum",
    "theorem": " : znum → znum",
    "args": "",
    "doc_string": "The predecessor of a `znum`.",
    "kind": "def",
    "type": "znum → znum"
  },
  {
    "name": "ordinal",
    "statement": "def ordinal  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "`ordinal.{u}` is the type of well orders in `Type u`, up to order isomorphism.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "is_dedekind_domain",
    "statement": "structure is_dedekind_domain (A : Type u_2) [comm_ring A] [is_domain A] : Prop",
    "theorem": "(A : Type u_2) [comm_ring A] [is_domain A] : Prop",
    "args": "(A : Type u_2) [comm_ring A] [is_domain A]",
    "doc_string": "A Dedekind domain is an integral domain that is Noetherian, integrally closed, and has Krull dimension at most one.  This is definition 3.2 of [Neukirch1992].  The integral closure condition is independent of the choice of field of fractions: use `is_dedekind_domain_iff` to prove `is_dedekind_domain` for a given `fraction_map`.  This is the default implementation, but there are equivalent definitions, `is_dedekind_domain_dvr` and `is_dedekind_domain_inv`. TODO: Prove that these are actually equivalent definitions.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "set.division_monoid",
    "statement": "def set.division_monoid {α : Type u_2} [division_monoid α] : division_monoid (set α)",
    "theorem": "{α : Type u_2} [division_monoid α] : division_monoid (set α)",
    "args": "{α : Type u_2} [division_monoid α]",
    "doc_string": "`set α` is a division monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "division_monoid (set α)"
  },
  {
    "name": "comp_add_left",
    "statement": "theorem comp_add_left {α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y)",
    "theorem": "{α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y)",
    "args": "{α : Type u_1} [add_semigroup α] (x y : α)",
    "doc_string": "Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`.",
    "kind": "theorem",
    "type": "has_add.add x ∘ has_add.add y = has_add.add (x + y)"
  },
  {
    "name": "nat.set_induction_bounded",
    "statement": "theorem nat.set_induction_bounded {b : ℕ} {S : set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n) : n ∈ S",
    "theorem": "{b : ℕ} {S : set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n) : n ∈ S",
    "args": "{b : ℕ} {S : set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n)",
    "doc_string": "A subset of `ℕ` containing `b : ℕ` and closed under `nat.succ` contains every `n ≥ b`.",
    "kind": "theorem",
    "type": "n ∈ S"
  },
  {
    "name": "expr.clean_ids",
    "statement": "def expr.clean_ids  : list name",
    "theorem": " : list name",
    "args": "",
    "doc_string": "List of names removed by `clean`. All these names must resolve to functions defeq `id`.",
    "kind": "def",
    "type": "list name"
  },
  {
    "name": "polish_space.sigma",
    "statement": "def polish_space.sigma {ι : Type u_1} [encodable ι] {E : ι → Type u_2} [Π (n : ι), topological_space (E n)] [∀ (n : ι), polish_space (E n)] : polish_space (Σ (n : ι), E n)",
    "theorem": "{ι : Type u_1} [encodable ι] {E : ι → Type u_2} [Π (n : ι), topological_space (E n)] [∀ (n : ι), polish_space (E n)] : polish_space (Σ (n : ι), E n)",
    "args": "{ι : Type u_1} [encodable ι] {E : ι → Type u_2} [Π (n : ι), topological_space (E n)] [∀ (n : ι), polish_space (E n)]",
    "doc_string": "A countable disjoint union of Polish spaces is Polish.",
    "kind": "def",
    "type": "polish_space (Σ (n : ι), E n)"
  },
  {
    "name": "szemeredi_regularity.step_bound_pos",
    "statement": "theorem szemeredi_regularity.step_bound_pos {n : ℕ} : 0 < n → 0 < szemeredi_regularity.step_bound n",
    "theorem": "{n : ℕ} : 0 < n → 0 < szemeredi_regularity.step_bound n",
    "args": "{n : ℕ}",
    "doc_string": "**Alias** of the reverse direction of szemeredi_regularity.step_bound_pos_iff`.",
    "kind": "theorem",
    "type": "0 < n → 0 < szemeredi_regularity.step_bound n"
  },
  {
    "name": "multiples.self_mem",
    "statement": "theorem multiples.self_mem {M : Type u_1} [add_monoid M] {x : M} : x ∈ multiples x",
    "theorem": "{M : Type u_1} [add_monoid M] {x : M} : x ∈ multiples x",
    "args": "{M : Type u_1} [add_monoid M] {x : M}",
    "doc_string": "An element of an `add_monoid` is in the set of that element's natural number multiples.",
    "kind": "theorem",
    "type": "x ∈ multiples x"
  },
  {
    "name": "complex",
    "statement": "structure complex  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Complex numbers consist of two `real`s: a real part `re` and an imaginary part `im`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "subsemiring.to_add_submonoid",
    "statement": "def subsemiring.to_add_submonoid {R : Type u} [non_assoc_semiring R] (self : subsemiring R) : add_submonoid R",
    "theorem": "{R : Type u} [non_assoc_semiring R] (self : subsemiring R) : add_submonoid R",
    "args": "{R : Type u} [non_assoc_semiring R] (self : subsemiring R)",
    "doc_string": "Reinterpret a `subsemiring` as an `add_submonoid`.",
    "kind": "def",
    "type": "add_submonoid R"
  },
  {
    "name": "complex.tendsto_exp_comap_re_at_top",
    "statement": "theorem complex.tendsto_exp_comap_re_at_top  : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)",
    "theorem": " : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)",
    "args": "",
    "doc_string": "`complex.abs (complex.exp z) → ∞` as `complex.re z → ∞`. TODO: use `bornology.cobounded`.",
    "kind": "theorem",
    "type": "filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)"
  },
  {
    "name": "right_mul",
    "statement": "def right_mul {G : Type u_1} [has_mul G] : G → G → G",
    "theorem": "{G : Type u_1} [has_mul G] : G → G → G",
    "args": "{G : Type u_1} [has_mul G]",
    "doc_string": "`right_mul g` denotes right multiplication by `g`",
    "kind": "def",
    "type": "G → G → G"
  },
  {
    "name": "rel_embedding.coe_fn_injective",
    "statement": "theorem rel_embedding.coe_fn_injective {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}",
    "doc_string": "The map `coe_fn : (r ↪r s) → (α → β)` is injective.",
    "kind": "theorem",
    "type": "function.injective coe_fn"
  },
  {
    "name": "matrix.nondegenerate",
    "statement": "def matrix.nondegenerate {m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] (M : matrix m m R) : Prop",
    "theorem": "{m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] (M : matrix m m R) : Prop",
    "args": "{m : Type u_1} {R : Type u_2} [fintype m] [comm_ring R] (M : matrix m m R)",
    "doc_string": "A matrix `M` is nondegenerate if for all `v ≠ 0`, there is a `w ≠ 0` with `w ⬝ M ⬝ v ≠ 0`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pi.lex.linear_order",
    "statement": "def pi.lex.linear_order {ι : Type u_1} {β : ι → Type u_2} [linear_order ι] [is_well_order ι has_lt.lt] [Π (a : ι), linear_order (β a)] : linear_order (lex (Π (i : ι), β i))",
    "theorem": "{ι : Type u_1} {β : ι → Type u_2} [linear_order ι] [is_well_order ι has_lt.lt] [Π (a : ι), linear_order (β a)] : linear_order (lex (Π (i : ι), β i))",
    "args": "{ι : Type u_1} {β : ι → Type u_2} [linear_order ι] [is_well_order ι has_lt.lt] [Π (a : ι), linear_order (β a)]",
    "doc_string": "`Πₗ i, α i` is a linear order if the original order is well-founded.",
    "kind": "def",
    "type": "linear_order (lex (Π (i : ι), β i))"
  },
  {
    "name": "ordinal.nfp",
    "statement": "def ordinal.nfp (f : ordinal → ordinal) : ordinal → ordinal",
    "theorem": "(f : ordinal → ordinal) : ordinal → ordinal",
    "args": "(f : ordinal → ordinal)",
    "doc_string": "The next fixed point function, the least fixed point of the normal function `f`, at least `a`.",
    "kind": "def",
    "type": "ordinal → ordinal"
  },
  {
    "name": "category_theory.limits.finite_colimits_from_coequalizers_and_finite_coproducts",
    "statement": "theorem category_theory.limits.finite_colimits_from_coequalizers_and_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C]",
    "doc_string": "Any category with finite coproducts and coequalizers has all finite colimits.  See <https://stacks.math.columbia.edu/tag/002Q>.",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_colimits C"
  },
  {
    "name": "polynomial.frange",
    "statement": "def polynomial.frange {R : Type u} [semiring R] (p : polynomial R) : finset R",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : finset R",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": "The finset of nonzero coefficients of a polynomial.",
    "kind": "def",
    "type": "finset R"
  },
  {
    "name": "pnat.xgcd_type.reduce",
    "statement": "def pnat.xgcd_type.reduce  : pnat.xgcd_type → pnat.xgcd_type",
    "theorem": " : pnat.xgcd_type → pnat.xgcd_type",
    "args": "",
    "doc_string": "We can now define the full reduction function, which applies step as long as possible, and then applies finish. Note that the \"have\" statement puts a fact in the local context, and the equation compiler uses this fact to help construct the full definition in terms of well-founded recursion.  The same fact needs to be introduced in all the inductive proofs of properties given below.",
    "kind": "def",
    "type": "pnat.xgcd_type → pnat.xgcd_type"
  },
  {
    "name": "add_order_of_pos_iff",
    "statement": "theorem add_order_of_pos_iff {G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x",
    "theorem": "{G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x",
    "args": "{G : Type u} {x : G} [add_monoid G]",
    "doc_string": "A group element has finite additive order iff its order is positive.",
    "kind": "theorem",
    "type": "0 < add_order_of x ↔ is_of_fin_add_order x"
  },
  {
    "name": "alexandroff.infty",
    "statement": "def alexandroff.infty {X : Type u_1} : alexandroff X",
    "theorem": "{X : Type u_1} : alexandroff X",
    "args": "{X : Type u_1}",
    "doc_string": "The point at infinity",
    "kind": "def",
    "type": "alexandroff X"
  },
  {
    "name": "alexandroff.connected_space",
    "statement": "def alexandroff.connected_space {X : Type u_1} [topological_space X] [preconnected_space X] [noncompact_space X] : connected_space (alexandroff X)",
    "theorem": "{X : Type u_1} [topological_space X] [preconnected_space X] [noncompact_space X] : connected_space (alexandroff X)",
    "args": "{X : Type u_1} [topological_space X] [preconnected_space X] [noncompact_space X]",
    "doc_string": "If `X` is not a compact space, then `alexandroff X` is a connected space.",
    "kind": "def",
    "type": "connected_space (alexandroff X)"
  },
  {
    "name": "ordnode.find_lt",
    "statement": "def ordnode.find_lt {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": "O(log n). Get the largest element in the tree that is `< x`.      find_lt 2 {1, 2, 4} = some 1     find_lt 3 {1, 2, 4} = some 2     find_lt 0 {1, 2, 4} = none",
    "kind": "def",
    "type": "ordnode α → option α"
  },
  {
    "name": "opens.pretopology",
    "statement": "def opens.pretopology (T : Type u) [topological_space T] : category_theory.pretopology (topological_space.opens T)",
    "theorem": "(T : Type u) [topological_space T] : category_theory.pretopology (topological_space.opens T)",
    "args": "(T : Type u) [topological_space T]",
    "doc_string": "The Grothendieck pretopology associated to a topological space.",
    "kind": "def",
    "type": "category_theory.pretopology (topological_space.opens T)"
  },
  {
    "name": "parser.digit",
    "statement": "def parser.digit  : parser ℕ",
    "theorem": " : parser ℕ",
    "args": "",
    "doc_string": "Matches a digit (0-9).",
    "kind": "def",
    "type": "parser ℕ"
  },
  {
    "name": "matrix.star_ring",
    "statement": "def matrix.star_ring {n : Type u_3} {α : Type v} [fintype n] [semiring α] [star_ring α] : star_ring (matrix n n α)",
    "theorem": "{n : Type u_3} {α : Type v} [fintype n] [semiring α] [star_ring α] : star_ring (matrix n n α)",
    "args": "{n : Type u_3} {α : Type v} [fintype n] [semiring α] [star_ring α]",
    "doc_string": "When `α` is a `*`-(semi)ring, `matrix.has_star` is also a `*`-(semi)ring.",
    "kind": "def",
    "type": "star_ring (matrix n n α)"
  },
  {
    "name": "lattice_hom",
    "statement": "structure lattice_hom (α : Type u_7) (β : Type u_8) [lattice α] [lattice β] : Type (max u_7 u_8)",
    "theorem": "(α : Type u_7) (β : Type u_8) [lattice α] [lattice β] : Type (max u_7 u_8)",
    "args": "(α : Type u_7) (β : Type u_8) [lattice α] [lattice β]",
    "doc_string": "The type of lattice homomorphisms from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8)"
  },
  {
    "name": "continuous_monoid_hom.fst",
    "statement": "def continuous_monoid_hom.fst (A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A × B) A",
    "theorem": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom (A × B) A",
    "args": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by projection onto the first factor.",
    "kind": "def",
    "type": "continuous_monoid_hom (A × B) A"
  },
  {
    "name": "topological_group.continuous_conj_prod",
    "statement": "theorem topological_group.continuous_conj_prod {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)",
    "theorem": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)",
    "args": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G]",
    "doc_string": "Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous.",
    "kind": "theorem",
    "type": "continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)"
  },
  {
    "name": "circle_deg1_lift.lattice",
    "statement": "def circle_deg1_lift.lattice  : lattice circle_deg1_lift",
    "theorem": " : lattice circle_deg1_lift",
    "args": "",
    "doc_string": "Monotone circle maps form a lattice with respect to the pointwise order",
    "kind": "def",
    "type": "lattice circle_deg1_lift"
  },
  {
    "name": "subgroup.has_inf",
    "statement": "def subgroup.has_inf {G : Type u_1} [group G] : has_inf (subgroup G)",
    "theorem": "{G : Type u_1} [group G] : has_inf (subgroup G)",
    "args": "{G : Type u_1} [group G]",
    "doc_string": "The inf of two subgroups is their intersection.",
    "kind": "def",
    "type": "has_inf (subgroup G)"
  },
  {
    "name": "has_sum_zero",
    "statement": "theorem has_sum_zero {α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] : has_sum (λ (b : β), 0) 0",
    "theorem": "{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] : has_sum (λ (b : β), 0) 0",
    "args": "{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α]",
    "doc_string": "Constant zero function has sum `0`",
    "kind": "theorem",
    "type": "has_sum (λ (b : β), 0) 0"
  },
  {
    "name": "pexpr",
    "statement": "def pexpr  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Quoted expressions. They can be converted into expressions by using a tactic.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "closed_embedding.polish_space",
    "statement": "theorem closed_embedding.polish_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [polish_space β] {f : α → β} (hf : closed_embedding f) : polish_space α",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [polish_space β] {f : α → β} (hf : closed_embedding f) : polish_space α",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [polish_space β] {f : α → β} (hf : closed_embedding f)",
    "doc_string": "Given a closed embedding into a Polish space, the source space is also Polish.",
    "kind": "theorem",
    "type": "polish_space α"
  },
  {
    "name": "turing.list_blank.exists_cons",
    "statement": "theorem turing.list_blank.exists_cons {Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : ∃ (a : Γ) (l' : turing.list_blank Γ), l = turing.list_blank.cons a l'",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : ∃ (a : Γ) (l' : turing.list_blank Γ), l = turing.list_blank.cons a l'",
    "args": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ)",
    "doc_string": " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists.",
    "kind": "theorem",
    "type": "∃ (a : Γ) (l' : turing.list_blank Γ), l = turing.list_blank.cons a l'"
  },
  {
    "name": "Exists.some_spec",
    "statement": "theorem Exists.some_spec {α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : p P.some",
    "theorem": "{α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : p P.some",
    "args": "{α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a)",
    "doc_string": "Show that an element extracted from `P : ∃ a, p a` using `P.some` satisfies `p`.",
    "kind": "theorem",
    "type": "p P.some"
  },
  {
    "name": "AddGroup.of",
    "statement": "def AddGroup.of (X : Type u) [add_group X] : AddGroup",
    "theorem": "(X : Type u) [add_group X] : AddGroup",
    "args": "(X : Type u) [add_group X]",
    "doc_string": "Construct a bundled `AddGroup` from the underlying type and typeclass.",
    "kind": "def",
    "type": "AddGroup"
  },
  {
    "name": "nat.fast_fib",
    "statement": "def nat.fast_fib (n : ℕ) : ℕ",
    "theorem": "(n : ℕ) : ℕ",
    "args": "(n : ℕ)",
    "doc_string": " Computes `nat.fib n` using the binary representation of `n`. Proved to be equal to `nat.fib` in `nat.fast_fib_eq`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "multiset.add",
    "statement": "def multiset.add {α : Type u_1} (s₁ s₂ : multiset α) : multiset α",
    "theorem": "{α : Type u_1} (s₁ s₂ : multiset α) : multiset α",
    "args": "{α : Type u_1} (s₁ s₂ : multiset α)",
    "doc_string": "The sum of two multisets is the lift of the list append operation.  This adds the multiplicities of each element,  i.e. `count a (s + t) = count a s + count a t`.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "polynomial.div",
    "statement": "def polynomial.div {R : Type u} [field R] (p q : polynomial R) : polynomial R",
    "theorem": "{R : Type u} [field R] (p q : polynomial R) : polynomial R",
    "args": "{R : Type u} [field R] (p q : polynomial R)",
    "doc_string": "Division of polynomials. See `polynomial.div_by_monic` for more details.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "dlist.concat",
    "statement": "def dlist.concat {α : Type u} (x : α) : dlist α → dlist α",
    "theorem": "{α : Type u} (x : α) : dlist α → dlist α",
    "args": "{α : Type u} (x : α)",
    "doc_string": "`O(1)` Append a single element to a dlist",
    "kind": "def",
    "type": "dlist α → dlist α"
  },
  {
    "name": "continued_fraction",
    "statement": "def continued_fraction (α : Type u_1) [has_one α] [has_zero α] [has_lt α] : Type u_1",
    "theorem": "(α : Type u_1) [has_one α] [has_zero α] [has_lt α] : Type u_1",
    "args": "(α : Type u_1) [has_one α] [has_zero α] [has_lt α]",
    "doc_string": "A *(regular) continued fraction* ((r)cf) is a simple continued fraction (scf) whose partial denominators are all positive. It is the subtype of scfs that satisfy `simple_continued_fraction.is_continued_fraction`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "bilin_form.orthogonal",
    "statement": "def bilin_form.orthogonal {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (N : submodule R M) : submodule R M",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (N : submodule R M) : submodule R M",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (N : submodule R M)",
    "doc_string": " The orthogonal complement of a submodule `N` with respect to some bilinear form is the set of elements `x` which are orthogonal to all elements of `N`; i.e., for all `y` in `N`, `B x y = 0`.  Note that for general (neither symmetric nor antisymmetric) bilinear forms this definition has a chirality; in addition to this \"left\" orthogonal complement one could define a \"right\" orthogonal complement for which, for all `y` in `N`, `B y x = 0`.  This variant definition is not currently provided in mathlib.",
    "kind": "def",
    "type": "submodule R M"
  },
  {
    "name": "finset.monoid",
    "statement": "def finset.monoid {α : Type u_2} [decidable_eq α] [monoid α] : monoid (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [monoid α] : monoid (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [monoid α]",
    "doc_string": "`finset α` is a `monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "monoid (finset α)"
  },
  {
    "name": "parsed_projection_data",
    "statement": "structure parsed_projection_data  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Temporary projection data parsed from `initialize_simps_projections` before the expression  matching this projection has been found. Only used internally in `simps_get_raw_projections`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "uv.compress_idem",
    "statement": "theorem uv.compress_idem {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : uv.compress u v (uv.compress u v a) = uv.compress u v a",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : uv.compress u v (uv.compress u v a) = uv.compress u v a",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α)",
    "doc_string": "Compressing an element is idempotent.",
    "kind": "theorem",
    "type": "uv.compress u v (uv.compress u v a) = uv.compress u v a"
  },
  {
    "name": "parser.sep_by1",
    "statement": "def parser.sep_by1 {α : Type} (sep : parser unit) (p : parser α) : parser (list α)",
    "theorem": "{α : Type} (sep : parser unit) (p : parser α) : parser (list α)",
    "args": "{α : Type} (sep : parser unit) (p : parser α)",
    "doc_string": "Matches one or more occurrences of `p`, separated by `sep`.",
    "kind": "def",
    "type": "parser (list α)"
  },
  {
    "name": "reflexive.ne_imp_iff",
    "statement": "theorem reflexive.ne_imp_iff {α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y",
    "theorem": "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y",
    "args": "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α}",
    "doc_string": " If a reflexive relation `r : α → α → Prop` holds over `x y : α`, then it holds whether or not `x ≠ y`.",
    "kind": "theorem",
    "type": "x ≠ y → r x y ↔ r x y"
  },
  {
    "name": "subring.topological_closure",
    "statement": "def subring.topological_closure {α : Type u_1} [topological_space α] [ring α] [topological_ring α] (S : subring α) : subring α",
    "theorem": "{α : Type u_1} [topological_space α] [ring α] [topological_ring α] (S : subring α) : subring α",
    "args": "{α : Type u_1} [topological_space α] [ring α] [topological_ring α] (S : subring α)",
    "doc_string": " The (topological-space) closure of a subring of a topological ring is itself a subring.",
    "kind": "def",
    "type": "subring α"
  },
  {
    "name": "finset.center_mass",
    "statement": "def finset.center_mass {R : Type u_1} {E : Type u_2} {ι : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (t : finset ι) (w : ι → R) (z : ι → E) : E",
    "theorem": "{R : Type u_1} {E : Type u_2} {ι : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (t : finset ι) (w : ι → R) (z : ι → E) : E",
    "args": "{R : Type u_1} {E : Type u_2} {ι : Type u_4} [linear_ordered_field R] [add_comm_group E] [module R E] (t : finset ι) (w : ι → R) (z : ι → E)",
    "doc_string": " Center of mass of a finite collection of points with prescribed weights. Note that we require neither `0 ≤ w i` nor `∑ w = 1`.",
    "kind": "def",
    "type": "E"
  },
  {
    "name": "nat.asc_factorial",
    "statement": "def nat.asc_factorial (n : ℕ) : ℕ → ℕ",
    "theorem": "(n : ℕ) : ℕ → ℕ",
    "args": "(n : ℕ)",
    "doc_string": " `n.asc_factorial k = (n + k)! / n!` (as seen in `nat.asc_factorial_eq_div`), but implemented recursively to allow for \"quick\" computation when using `norm_num`. This is closely related to `pochhammer`, but much less general.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "upper_central_series_is_ascending_central_series",
    "statement": "theorem upper_central_series_is_ascending_central_series (G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)",
    "theorem": "(G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "The upper central series of a group is an ascending central series.",
    "kind": "theorem",
    "type": "is_ascending_central_series (upper_central_series G)"
  },
  {
    "name": "sum.encodable",
    "statement": "def sum.encodable {α : Type u_1} {β : Type u_2} [encodable α] [encodable β] : encodable (α ⊕ β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [encodable α] [encodable β] : encodable (α ⊕ β)",
    "args": "{α : Type u_1} {β : Type u_2} [encodable α] [encodable β]",
    "doc_string": "If `α` and `β` are encodable, then so is their sum.",
    "kind": "def",
    "type": "encodable (α ⊕ β)"
  },
  {
    "name": "nat.prime.mod_two_eq_one_iff_ne_two",
    "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
    "theorem": "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
    "args": "{p : ℕ} [fact (nat.prime p)]",
    "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.",
    "kind": "theorem",
    "type": "p % 2 = 1 ↔ p ≠ 2"
  },
  {
    "name": "zsqrtd.nonnegg",
    "statement": "def zsqrtd.nonnegg (c d : ℕ) : ℤ → ℤ → Prop",
    "theorem": "(c d : ℕ) : ℤ → ℤ → Prop",
    "args": "(c d : ℕ)",
    "doc_string": "\"Generalized\" `nonneg`. `nonnegg c d x y` means `a √c + b √d ≥ 0`;  we are interested in the case `c = 1` but this is more symmetric",
    "kind": "def",
    "type": "ℤ → ℤ → Prop"
  },
  {
    "name": "list.map_comp_map",
    "statement": "theorem list.map_comp_map {α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) : list.map g ∘ list.map f = list.map (g ∘ f)",
    "theorem": "{α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) : list.map g ∘ list.map f = list.map (g ∘ f)",
    "args": "{α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β)",
    "doc_string": "Composing a `list.map` with another `list.map` is equal to a single `list.map` of composed functions.",
    "kind": "theorem",
    "type": "list.map g ∘ list.map f = list.map (g ∘ f)"
  },
  {
    "name": "tsupport",
    "statement": "def tsupport {X : Type u_1} {α : Type u_2} [has_zero α] [topological_space X] (f : X → α) : set X",
    "theorem": "{X : Type u_1} {α : Type u_2} [has_zero α] [topological_space X] (f : X → α) : set X",
    "args": "{X : Type u_1} {α : Type u_2} [has_zero α] [topological_space X] (f : X → α)",
    "doc_string": "The topological support of a function is the closure of its support. i.e. the closure of the  set of all elements where the function is nonzero.",
    "kind": "def",
    "type": "set X"
  },
  {
    "name": "not_is_right_regular_zero_iff",
    "statement": "theorem not_is_right_regular_zero_iff {R : Type u_1} [mul_zero_class R] : ¬is_right_regular 0 ↔ nontrivial R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : ¬is_right_regular 0 ↔ nontrivial R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "In a non-trivial `mul_zero_class`, the `0` element is not right-regular.",
    "kind": "theorem",
    "type": "¬is_right_regular 0 ↔ nontrivial R"
  },
  {
    "name": "binder_info",
    "statement": "inductive binder_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Auxiliary annotation for binders (Lambda and Pi).     This information is only used for elaboration.       The difference between `{}` and `⦃⦄` is how implicit arguments are treated that are *not* followed by explicit arguments.   `{}` arguments are applied eagerly, while `⦃⦄` arguments are left partially applied: ```lean def foo {x : ℕ} : ℕ := x def bar ⦃x : ℕ⦄ : ℕ := x #check foo -- foo : ℕ #check bar -- bar : Π ⦃x : ℕ⦄, ℕ ```",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "field_of_finite_dimensional",
    "statement": "def field_of_finite_dimensional (F : Type u_1) (K : Type u_2) [field F] [comm_ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : field K",
    "theorem": "(F : Type u_1) (K : Type u_2) [field F] [comm_ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : field K",
    "args": "(F : Type u_1) (K : Type u_2) [field F] [comm_ring K] [is_domain K] [algebra F K] [finite_dimensional F K]",
    "doc_string": "An integral domain that is module-finite as an algebra over a field is a field.",
    "kind": "def",
    "type": "field K"
  },
  {
    "name": "subgroup.topological_closure",
    "statement": "def subgroup.topological_closure {G : Type w} [topological_space G] [group G] [topological_group G] (s : subgroup G) : subgroup G",
    "theorem": "{G : Type w} [topological_space G] [group G] [topological_group G] (s : subgroup G) : subgroup G",
    "args": "{G : Type w} [topological_space G] [group G] [topological_group G] (s : subgroup G)",
    "doc_string": " The (topological-space) closure of a subgroup of a space `M` with `has_continuous_mul` is itself a subgroup.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "category_theory.hom_orthogonal",
    "statement": "def category_theory.hom_orthogonal {C : Type u} [category_theory.category C] {ι : Type u_1} (s : ι → C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] {ι : Type u_1} (s : ι → C) : Prop",
    "args": "{C : Type u} [category_theory.category C] {ι : Type u_1} (s : ι → C)",
    "doc_string": " A family of objects is \"hom orthogonal\" if there is at most one morphism between distinct objects.  (In a category with zero morphisms, that must be the zero morphism.)",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.has_right_inverse",
    "statement": "def function.has_right_inverse {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "theorem": "{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "args": "{α : Sort u₁} {β : Sort u₂} (f : α → β)",
    "doc_string": "`has_right_inverse f` means that `f` has an unspecified right inverse.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "metric.inf_dist_le_dist_of_mem",
    "statement": "theorem metric.inf_dist_le_dist_of_mem {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : y ∈ s) : metric.inf_dist x s ≤ has_dist.dist x y",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : y ∈ s) : metric.inf_dist x s ≤ has_dist.dist x y",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : y ∈ s)",
    "doc_string": "The minimal distance to a set is bounded by the distance to any point in this set",
    "kind": "theorem",
    "type": "metric.inf_dist x s ≤ has_dist.dist x y"
  },
  {
    "name": "first_order.language.prestructure",
    "statement": "structure first_order.language.prestructure (L : first_order.language) {M : Type u_3} (s : setoid M) : Type (max u_1 u_2 u_3)",
    "theorem": "(L : first_order.language) {M : Type u_3} (s : setoid M) : Type (max u_1 u_2 u_3)",
    "args": "(L : first_order.language) {M : Type u_3} (s : setoid M)",
    "doc_string": "A prestructure is a first-order structure with a `setoid` equivalence relation on it,  such that quotienting by that equivalence relation is still a structure.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "alist.union",
    "statement": "def alist.union {α : Type u} {β : α → Type v} [decidable_eq α] (s₁ s₂ : alist β) : alist β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (s₁ s₂ : alist β) : alist β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (s₁ s₂ : alist β)",
    "doc_string": " `s₁ ∪ s₂` is the key-based union of two association lists. It is left-biased: if there exists an `a ∈ s₁`, `lookup a (s₁ ∪ s₂) = lookup a s₁`.",
    "kind": "def",
    "type": "alist β"
  },
  {
    "name": "measure_theory.outer_measure.mk_metric",
    "statement": "def measure_theory.outer_measure.mk_metric {X : Type u_2} [emetric_space X] (m : ennreal → ennreal) : measure_theory.outer_measure X",
    "theorem": "{X : Type u_2} [emetric_space X] (m : ennreal → ennreal) : measure_theory.outer_measure X",
    "args": "{X : Type u_2} [emetric_space X] (m : ennreal → ennreal)",
    "doc_string": " Given a function `m : ℝ≥0∞ → ℝ≥0∞` and `r > 0`, let `μ r` be the maximal outer measure such that `μ s ≤ m (emetric.diam s)` whenever `emetric.diam s < r`. Then `mk_metric m = ⨆ r > 0, μ r`.",
    "kind": "def",
    "type": "measure_theory.outer_measure X"
  },
  {
    "name": "matrix.special_linear_group.has_coe",
    "statement": "def matrix.special_linear_group.has_coe {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : has_coe (matrix.special_linear_group n ℤ) (matrix.special_linear_group n R)",
    "theorem": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : has_coe (matrix.special_linear_group n ℤ) (matrix.special_linear_group n R)",
    "args": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R]",
    "doc_string": "Coercion of SL `n` `ℤ` to SL `n` `R` for a commutative ring `R`.",
    "kind": "def",
    "type": "has_coe (matrix.special_linear_group n ℤ) (matrix.special_linear_group n R)"
  },
  {
    "name": "finset.eq_empty_of_is_empty",
    "statement": "theorem finset.eq_empty_of_is_empty {α : Type u_1} [is_empty α] (s : finset α) : s = ∅",
    "theorem": "{α : Type u_1} [is_empty α] (s : finset α) : s = ∅",
    "args": "{α : Type u_1} [is_empty α] (s : finset α)",
    "doc_string": "A `finset` for an empty type is empty.",
    "kind": "theorem",
    "type": "s = ∅"
  },
  {
    "name": "attribute_list",
    "statement": "def attribute_list  : list name",
    "theorem": " : list name",
    "args": "",
    "doc_string": "The attributes we check for",
    "kind": "def",
    "type": "list name"
  },
  {
    "name": "computability.encoding",
    "statement": "structure computability.encoding (α : Type u) : Type (max u (v+1))",
    "theorem": "(α : Type u) : Type (max u (v+1))",
    "args": "(α : Type u)",
    "doc_string": "An encoding of a type in a certain alphabet, together with a decoding.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "ordset",
    "statement": "def ordset (α : Type u_1) [preorder α] : Type u_1",
    "theorem": "(α : Type u_1) [preorder α] : Type u_1",
    "args": "(α : Type u_1) [preorder α]",
    "doc_string": " An `ordset α` is a finite set of values, represented as a tree. The operations on this type maintain that the tree is balanced and correctly stores subtree sizes at each level. The correctness property of the tree is baked into the type, so all operations on this type are correct by construction.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "ideal.closure",
    "statement": "def ideal.closure {α : Type u_1} [topological_space α] [comm_ring α] [topological_ring α] (S : ideal α) : ideal α",
    "theorem": "{α : Type u_1} [topological_space α] [comm_ring α] [topological_ring α] (S : ideal α) : ideal α",
    "args": "{α : Type u_1} [topological_space α] [comm_ring α] [topological_ring α] (S : ideal α)",
    "doc_string": "The closure of an ideal in a topological ring as an ideal.",
    "kind": "def",
    "type": "ideal α"
  },
  {
    "name": "module.free.choose_basis",
    "statement": "def module.free.choose_basis (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : basis (module.free.choose_basis_index R M) R M",
    "theorem": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M] : basis (module.free.choose_basis_index R M) R M",
    "args": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] [module.free R M]",
    "doc_string": " If `module.free R M` then `choose_basis : ι → M` is the basis. Here `ι = choose_basis_index R M`.",
    "kind": "def",
    "type": "basis (module.free.choose_basis_index R M) R M"
  },
  {
    "name": "category_theory.artinian",
    "statement": "structure category_theory.artinian (C : Type u_1) [category_theory.category C] : Type",
    "theorem": "(C : Type u_1) [category_theory.category C] : Type",
    "args": "(C : Type u_1) [category_theory.category C]",
    "doc_string": "A category is artinian if it is essentially small and all objects are artinian.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "computation.head",
    "statement": "def computation.head {α : Type u} (c : computation α) : option α",
    "theorem": "{α : Type u} (c : computation α) : option α",
    "args": "{α : Type u} (c : computation α)",
    "doc_string": "`head c` is the first step of computation, either `some a` if `c = return a`  or `none` if `c = think c'`.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "ring_invo.id",
    "statement": "def ring_invo.id (R : Type u_1) [comm_ring R] : ring_invo R",
    "theorem": "(R : Type u_1) [comm_ring R] : ring_invo R",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": "The identity function of a `comm_ring` is a ring involution.",
    "kind": "def",
    "type": "ring_invo R"
  },
  {
    "name": "generalized_continued_fraction.comp_exact_value",
    "statement": "def generalized_continued_fraction.comp_exact_value {K : Type u_1} [linear_ordered_field K] (pconts conts : generalized_continued_fraction.pair K) (fr : K) : K",
    "theorem": "{K : Type u_1} [linear_ordered_field K] (pconts conts : generalized_continued_fraction.pair K) (fr : K) : K",
    "args": "{K : Type u_1} [linear_ordered_field K] (pconts conts : generalized_continued_fraction.pair K) (fr : K)",
    "doc_string": "Given two continuants `pconts` and `conts` and a value `fr`, this function returns - `conts.a / conts.b` if `fr = 0` - `exact_conts.a / exact_conts.b` where `exact_conts = next_continuants 1 fr⁻¹ pconts conts`   otherwise.  This function can be used to compute the exact value approxmated by a continued fraction `generalized_continued_fraction.of v` as described in lemma `comp_exact_value_correctness_of_stream_eq_some`.",
    "kind": "def",
    "type": "K"
  },
  {
    "name": "ordnode.emem",
    "statement": "def ordnode.emem {α : Type u} (x : α) : ordnode α → Prop",
    "theorem": "{α : Type u} (x : α) : ordnode α → Prop",
    "args": "{α : Type u} (x : α)",
    "doc_string": " O(n). Exact membership in the set. This is useful primarily for stating correctness properties; use `∈` for a version that actually uses the BST property of the tree.      emem 2 {1, 2, 3} = true     emem 4 {1, 2, 3} = false",
    "kind": "def",
    "type": "ordnode α → Prop"
  },
  {
    "name": "nonarchimedean_ring.mul_subset",
    "statement": "theorem nonarchimedean_ring.mul_subset {R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : ∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U",
    "theorem": "{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : ∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U",
    "args": "{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R)",
    "doc_string": "An open subgroup of a nonarchimedean ring contains the square of another one.",
    "kind": "theorem",
    "type": "∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U"
  },
  {
    "name": "nat.factorial",
    "statement": "def nat.factorial  : ℕ → ℕ",
    "theorem": " : ℕ → ℕ",
    "args": "",
    "doc_string": "`nat.factorial n` is the factorial of `n`.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "group.fg",
    "statement": "structure group.fg (G : Type u_3) [group G] : Prop",
    "theorem": "(G : Type u_3) [group G] : Prop",
    "args": "(G : Type u_3) [group G]",
    "doc_string": "A group is finitely generated if it is finitely generated as a submonoid of itself.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_finite_biproducts",
    "statement": "structure category_theory.limits.has_finite_biproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C]",
    "doc_string": " `has_finite_biproducts C` represents a choice of biproduct for every family of objects in `C` indexed by a finite type.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "alist.disjoint",
    "statement": "def alist.disjoint {α : Type u} {β : α → Type v} (s₁ s₂ : alist β) : Prop",
    "theorem": "{α : Type u} {β : α → Type v} (s₁ s₂ : alist β) : Prop",
    "args": "{α : Type u} {β : α → Type v} (s₁ s₂ : alist β)",
    "doc_string": "Two associative lists are disjoint if they have no common keys.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "num.succ",
    "statement": "def num.succ (n : num) : num",
    "theorem": "(n : num) : num",
    "args": "(n : num)",
    "doc_string": "The successor of a `num` as a `num`.",
    "kind": "def",
    "type": "num"
  },
  {
    "name": "continuous_add_monoid_hom.snd",
    "statement": "def continuous_add_monoid_hom.snd (A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A × B) B",
    "theorem": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A × B) B",
    "args": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by projection onto the second factor.",
    "kind": "def",
    "type": "continuous_add_monoid_hom (A × B) B"
  },
  {
    "name": "list.ordered_insert",
    "statement": "def list.ordered_insert {α : Type uu} (r : α → α → Prop) [decidable_rel r] (a : α) : list α → list α",
    "theorem": "{α : Type uu} (r : α → α → Prop) [decidable_rel r] (a : α) : list α → list α",
    "args": "{α : Type uu} (r : α → α → Prop) [decidable_rel r] (a : α)",
    "doc_string": "`ordered_insert a l` inserts `a` into `l` at such that  `ordered_insert a l` is sorted if `l` is.",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "add_freiman_hom",
    "statement": "structure add_freiman_hom {α : Type u_2} (A : set α) (β : Type u_7) [add_comm_monoid α] [add_comm_monoid β] (n : ℕ) : Type (max u_2 u_7)",
    "theorem": "{α : Type u_2} (A : set α) (β : Type u_7) [add_comm_monoid α] [add_comm_monoid β] (n : ℕ) : Type (max u_2 u_7)",
    "args": "{α : Type u_2} (A : set α) (β : Type u_7) [add_comm_monoid α] [add_comm_monoid β] (n : ℕ)",
    "doc_string": "An additive `n`-Freiman homomorphism is a map which preserves sums of `n` elements.",
    "kind": "structure",
    "type": "Type (max u_2 u_7)"
  },
  {
    "name": "is_lub.bdd_above",
    "statement": "theorem is_lub.bdd_above {α : Type u} [preorder α] {s : set α} {a : α} (h : is_lub s a) : bdd_above s",
    "theorem": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_lub s a) : bdd_above s",
    "args": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_lub s a)",
    "doc_string": "If `s` has a least upper bound, then it is bounded above.",
    "kind": "theorem",
    "type": "bdd_above s"
  },
  {
    "name": "seq.force_to_list",
    "statement": "def seq.force_to_list {α : Type u} (s : seq α) : list α",
    "theorem": "{α : Type u} (s : seq α) : list α",
    "args": "{α : Type u} (s : seq α)",
    "doc_string": "Translate a sequence to a list. This function will run forever if  run on an infinite sequence.",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "trunc.lift",
    "statement": "def trunc.lift {α : Sort u_1} {β : Sort u_2} (f : α → β) (c : ∀ (a b : α), f a = f b) : trunc α → β",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (f : α → β) (c : ∀ (a b : α), f a = f b) : trunc α → β",
    "args": "{α : Sort u_1} {β : Sort u_2} (f : α → β) (c : ∀ (a b : α), f a = f b)",
    "doc_string": "Any constant function lifts to a function out of the truncation",
    "kind": "def",
    "type": "trunc α → β"
  },
  {
    "name": "function.injective2.left'",
    "statement": "theorem function.injective2.left' {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty β] : function.injective f",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty β] : function.injective f",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty β]",
    "doc_string": "As a map from the left argument to a unary function, `f` is injective.",
    "kind": "theorem",
    "type": "function.injective f"
  },
  {
    "name": "list.range'",
    "statement": "def list.range'  : ℕ → ℕ → list ℕ",
    "theorem": " : ℕ → ℕ → list ℕ",
    "args": "",
    "doc_string": "`range' s n` is the list of numbers `[s, s+1, ..., s+n-1]`.  It is intended mainly for proving properties of `range` and `iota`.",
    "kind": "def",
    "type": "ℕ → ℕ → list ℕ"
  },
  {
    "name": "is_compact_interval",
    "statement": "theorem is_compact_interval {α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b)",
    "theorem": "{α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b)",
    "args": "{α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α}",
    "doc_string": "An unordered closed interval is compact.",
    "kind": "theorem",
    "type": "is_compact (set.interval a b)"
  },
  {
    "name": "irreducible_component",
    "statement": "def irreducible_component {α : Type u} [topological_space α] (x : α) : set α",
    "theorem": "{α : Type u} [topological_space α] (x : α) : set α",
    "args": "{α : Type u} [topological_space α] (x : α)",
    "doc_string": "A maximal irreducible set that contains a given point.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "bilin_form.skew_adjoint_submodule",
    "statement": "def bilin_form.skew_adjoint_submodule {R₃ : Type u_7} {M₃ : Type u_8} [comm_ring R₃] [add_comm_group M₃] [module R₃ M₃] (B₃ : bilin_form R₃ M₃) : submodule R₃ (module.End R₃ M₃)",
    "theorem": "{R₃ : Type u_7} {M₃ : Type u_8} [comm_ring R₃] [add_comm_group M₃] [module R₃ M₃] (B₃ : bilin_form R₃ M₃) : submodule R₃ (module.End R₃ M₃)",
    "args": "{R₃ : Type u_7} {M₃ : Type u_8} [comm_ring R₃] [add_comm_group M₃] [module R₃ M₃] (B₃ : bilin_form R₃ M₃)",
    "doc_string": " The set of skew-adjoint endomorphisms of a module with bilinear form is a submodule. (In fact it is a Lie subalgebra.)",
    "kind": "def",
    "type": "submodule R₃ (module.End R₃ M₃)"
  },
  {
    "name": "ordset.find",
    "statement": "def ordset.find {α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α) : option α",
    "theorem": "{α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α) : option α",
    "args": "{α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α)",
    "doc_string": "O(log n). Retrieve an element in the set that is equivalent to `x` in the order,  if it exists.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "Class.Cong_to_Class",
    "statement": "def Class.Cong_to_Class (x : set Class) : Class",
    "theorem": "(x : set Class) : Class",
    "args": "(x : set Class)",
    "doc_string": "Convert a conglomerate (a collection of classes) into a class",
    "kind": "def",
    "type": "Class"
  },
  {
    "name": "simple_graph.subgraph",
    "statement": "structure simple_graph.subgraph {V : Type u} (G : simple_graph V) : Type u",
    "theorem": "{V : Type u} (G : simple_graph V) : Type u",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": " A subgraph of a `simple_graph` is a subset of vertices along with a restriction of the adjacency relation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.  Thinking of `V → V → Prop` as `set (V × V)`, a set of darts (i.e., half-edges), then `subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "semiquot.map",
    "statement": "def semiquot.map {α : Type u_1} {β : Type u_2} (f : α → β) (q : semiquot α) : semiquot β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (q : semiquot α) : semiquot β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (q : semiquot α)",
    "doc_string": "Apply a function to the unknown value stored in a `semiquot α`.",
    "kind": "def",
    "type": "semiquot β"
  },
  {
    "name": "omega.clauses.unsat",
    "statement": "def omega.clauses.unsat (cs : list omega.clause) : Prop",
    "theorem": "(cs : list omega.clause) : Prop",
    "args": "(cs : list omega.clause)",
    "doc_string": "There is no satisfiable clause c in argument",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "onote.top_below",
    "statement": "def onote.top_below (b : onote) : onote → Prop",
    "theorem": "(b : onote) : onote → Prop",
    "args": "(b : onote)",
    "doc_string": "`top_below b o` asserts that the largest exponent in `o`, if  it exists, is less than `b`. This is an auxiliary definition  for decidability of `NF`.",
    "kind": "def",
    "type": "onote → Prop"
  },
  {
    "name": "add_units.ordered_add_comm_group",
    "statement": "def add_units.ordered_add_comm_group {α : Type u} [ordered_add_comm_monoid α] : ordered_add_comm_group (add_units α)",
    "theorem": "{α : Type u} [ordered_add_comm_monoid α] : ordered_add_comm_group (add_units α)",
    "args": "{α : Type u} [ordered_add_comm_monoid α]",
    "doc_string": "The units of an ordered commutative additive monoid form an ordered commutative additive group.",
    "kind": "def",
    "type": "ordered_add_comm_group (add_units α)"
  },
  {
    "name": "nat.psub'",
    "statement": "def nat.psub' (m n : ℕ) : option ℕ",
    "theorem": "(m n : ℕ) : option ℕ",
    "args": "(m n : ℕ)",
    "doc_string": "Same as `psub`, but with a more efficient implementation.",
    "kind": "def",
    "type": "option ℕ"
  },
  {
    "name": "Top.presheaf_to_Type",
    "statement": "def Top.presheaf_to_Type (X : Top) (T : Type v) : Top.presheaf (Type v) X",
    "theorem": "(X : Top) (T : Type v) : Top.presheaf (Type v) X",
    "args": "(X : Top) (T : Type v)",
    "doc_string": "The presheaf of functions on `X` with values in a type `T`. There is no requirement that the functions are continuous, here.",
    "kind": "def",
    "type": "Top.presheaf (Type v) X"
  },
  {
    "name": "inf_hom",
    "statement": "structure inf_hom (α : Type u_7) (β : Type u_8) [has_inf α] [has_inf β] : Type (max u_7 u_8)",
    "theorem": "(α : Type u_7) (β : Type u_8) [has_inf α] [has_inf β] : Type (max u_7 u_8)",
    "args": "(α : Type u_7) (β : Type u_8) [has_inf α] [has_inf β]",
    "doc_string": "The type of `⊓`-preserving functions from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8)"
  },
  {
    "name": "valuation_subring",
    "statement": "structure valuation_subring (K : Type u_1) [field K] : Type u_1",
    "theorem": "(K : Type u_1) [field K] : Type u_1",
    "args": "(K : Type u_1) [field K]",
    "doc_string": " A valuation subring of a field `K` is a subring `A` such that for every `x : K`, either `x ∈ A` or `x⁻¹ ∈ K`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "ordinal.principal_add_iff_zero_or_omega_opow",
    "statement": "theorem ordinal.principal_add_iff_zero_or_omega_opow {o : ordinal} : ordinal.principal has_add.add o ↔ o = 0 ∨ ∃ (a : ordinal), o = ordinal.omega ^ a",
    "theorem": "{o : ordinal} : ordinal.principal has_add.add o ↔ o = 0 ∨ ∃ (a : ordinal), o = ordinal.omega ^ a",
    "args": "{o : ordinal}",
    "doc_string": "The main characterization theorem for additive principal ordinals.",
    "kind": "theorem",
    "type": "ordinal.principal has_add.add o ↔ o = 0 ∨ ∃ (a : ordinal), o = ordinal.omega ^ a"
  },
  {
    "name": "mul_aut.apply_mul_distrib_mul_action",
    "statement": "def mul_aut.apply_mul_distrib_mul_action {M : Type u_1} [monoid M] : mul_distrib_mul_action (mul_aut M) M",
    "theorem": "{M : Type u_1} [monoid M] : mul_distrib_mul_action (mul_aut M) M",
    "args": "{M : Type u_1} [monoid M]",
    "doc_string": " The tautological action by `mul_aut M` on `M`.  This generalizes `function.End.apply_mul_action`.",
    "kind": "def",
    "type": "mul_distrib_mul_action (mul_aut M) M"
  },
  {
    "name": "continuous_subgroup",
    "statement": "def continuous_subgroup (α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [group β] [topological_group β] : subgroup (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [group β] [topological_group β] : subgroup (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [group β] [topological_group β]",
    "doc_string": "The subgroup of continuous maps `α → β`.",
    "kind": "def",
    "type": "subgroup (α → β)"
  },
  {
    "name": "inv_lt_of_inv_lt'",
    "statement": "theorem inv_lt_of_inv_lt' {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b → b⁻¹ < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b → b⁻¹ < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the forward direction of inv_lt'`.",
    "kind": "theorem",
    "type": "a⁻¹ < b → b⁻¹ < a"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.nth_stream_fr_lt_one",
    "statement": "theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_lt_one {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1",
    "theorem": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1",
    "args": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n)",
    "doc_string": "Shows that the fractional parts of the stream are smaller than one.",
    "kind": "theorem",
    "type": "ifp_n.fr < 1"
  },
  {
    "name": "first_order.language.amalgamation",
    "statement": "def first_order.language.amalgamation {L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop",
    "theorem": "{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop",
    "args": "{L : first_order.language} (K : set (category_theory.bundled L.Structure))",
    "doc_string": "A class `K` has the amalgamation property when for any pair of embeddings of a structure `M` in  `K` into other structures in `K`, those two structures can be embedded into a fourth structure in  `K` such that the resulting square of embeddings commutes.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.gcd_monoid",
    "statement": "def nat.gcd_monoid  : gcd_monoid ℕ",
    "theorem": " : gcd_monoid ℕ",
    "args": "",
    "doc_string": "`ℕ` is a gcd_monoid.",
    "kind": "def",
    "type": "gcd_monoid ℕ"
  },
  {
    "name": "pow_two",
    "statement": "theorem pow_two {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "theorem": "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "args": "{M : Type u} [monoid M] (a : M)",
    "doc_string": "Note that most of the lemmas about powers of two refer to it as `sq`.",
    "kind": "theorem",
    "type": "a ^ 2 = a * a"
  },
  {
    "name": "pgame.numeric",
    "statement": "def pgame.numeric  : pgame → Prop",
    "theorem": " : pgame → Prop",
    "args": "",
    "doc_string": " A pre-game is numeric if everything in the L set is less than everything in the R set, and all the elements of L and R are also numeric.",
    "kind": "def",
    "type": "pgame → Prop"
  },
  {
    "name": "tactic.abel.add_g",
    "statement": "def tactic.abel.add_g  : name → name",
    "theorem": " : name → name",
    "args": "",
    "doc_string": " Add the letter \"g\" to the end of the name, e.g. turning `term` into `termg`.  This is used to choose between declarations taking `add_comm_monoid` and those taking `add_comm_group` instances.",
    "kind": "def",
    "type": "name → name"
  },
  {
    "name": "tactic.rcases_patt",
    "statement": "inductive tactic.rcases_patt  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "An `rcases` pattern can be one of the following, in a nested combination:  * A name like `foo` * The special keyword `rfl` (for pattern matching on equality using `subst`) * A hyphen `-`, which clears the active hypothesis and any dependents. * A type ascription like `pat : ty` (parentheses are optional) * A tuple constructor like `⟨p1, p2, p3⟩` * An alternation / variant pattern `p1 | p2 | p3`  Parentheses can be used for grouping; alternation is higher precedence than type ascription, so `p1 | p2 | p3 : ty` means `(p1 | p2 | p3) : ty`.  N-ary alternations are treated as a group, so `p1 | p2 | p3` is not the same as `p1 | (p2 | p3)`, and similarly for tuples. However, note that an n-ary alternation or tuple can match an n-ary conjunction or disjunction, because if the number of patterns exceeds the number of constructors in the type being destructed, the extra patterns will match on the last element, meaning that `p1 | p2 | p3` will act like `p1 | (p2 | p3)` when matching `a1 ∨ a2 ∨ a3`. If matching against a type with 3 constructors,  `p1 | (p2 | p3)` will act like `p1 | (p2 | p3) | _` instead.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "list.func.set",
    "statement": "def list.func.set {α : Type u} [inhabited α] (a : α) : list α → ℕ → list α",
    "theorem": "{α : Type u} [inhabited α] (a : α) : list α → ℕ → list α",
    "args": "{α : Type u} [inhabited α] (a : α)",
    "doc_string": "Update element of a list by index. If the index is out of range, extend the list with default elements",
    "kind": "def",
    "type": "list α → ℕ → list α"
  },
  {
    "name": "measurable_space.generate_from",
    "statement": "def measurable_space.generate_from {α : Type u_1} (s : set (set α)) : measurable_space α",
    "theorem": "{α : Type u_1} (s : set (set α)) : measurable_space α",
    "args": "{α : Type u_1} (s : set (set α))",
    "doc_string": "Construct the smallest measure space containing a collection of basic sets",
    "kind": "def",
    "type": "measurable_space α"
  },
  {
    "name": "nat.arithmetic_function.card_factors",
    "statement": "def nat.arithmetic_function.card_factors  : nat.arithmetic_function ℕ",
    "theorem": " : nat.arithmetic_function ℕ",
    "args": "",
    "doc_string": "`Ω n` is the number of prime factors of `n`.",
    "kind": "def",
    "type": "nat.arithmetic_function ℕ"
  },
  {
    "name": "finset.sum_centroid_weights_eq_one_of_card_ne_zero",
    "statement": "theorem finset.sum_centroid_weights_eq_one_of_card_ne_zero (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.card ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.card ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.card ≠ 0)",
    "doc_string": " In the characteristic zero case, the weights in the centroid sum to 1 if the number of points is not zero.",
    "kind": "theorem",
    "type": "s.sum (λ (i : ι), finset.centroid_weights k s i) = 1"
  },
  {
    "name": "add_action.to_perm",
    "statement": "def add_action.to_perm {α : Type u} {β : Type v} [add_group α] [add_action α β] (a : α) : equiv.perm β",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_action α β] (a : α) : equiv.perm β",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_action α β] (a : α)",
    "doc_string": "Given an action of an additive group `α` on `β`, each `g : α` defines a permutation of `β`.",
    "kind": "def",
    "type": "equiv.perm β"
  },
  {
    "name": "nonarchimedean_ring.prod.nonarchimedean_ring",
    "statement": "def nonarchimedean_ring.prod.nonarchimedean_ring {R : Type u_1} {S : Type u_2} [ring R] [topological_space R] [nonarchimedean_ring R] [ring S] [topological_space S] [nonarchimedean_ring S] : nonarchimedean_ring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_2} [ring R] [topological_space R] [nonarchimedean_ring R] [ring S] [topological_space S] [nonarchimedean_ring S] : nonarchimedean_ring (R × S)",
    "args": "{R : Type u_1} {S : Type u_2} [ring R] [topological_space R] [nonarchimedean_ring R] [ring S] [topological_space S] [nonarchimedean_ring S]",
    "doc_string": "The cartesian product of two nonarchimedean rings is nonarchimedean.",
    "kind": "def",
    "type": "nonarchimedean_ring (R × S)"
  },
  {
    "name": "not_is_unit_prime_of_dvd_card",
    "statement": "theorem not_is_unit_prime_of_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p",
    "theorem": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p",
    "args": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R)",
    "doc_string": " A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`.",
    "kind": "theorem",
    "type": "¬is_unit ↑p"
  },
  {
    "name": "is_totally_separated",
    "statement": "def is_totally_separated {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": " A set `s` is called totally separated if any two points of this set can be separated by two disjoint open sets covering `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pos_num.pred",
    "statement": "def pos_num.pred (a : pos_num) : pos_num",
    "theorem": "(a : pos_num) : pos_num",
    "args": "(a : pos_num)",
    "doc_string": "The predecessor of a `pos_num` as a `pos_num`. This means that `pred 1 = 1`.",
    "kind": "def",
    "type": "pos_num"
  },
  {
    "name": "list.scanr_aux",
    "statement": "def list.scanr_aux {α : Type u_1} {β : Type u_2} (f : α → β → β) (b : β) : list α → β × list β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β → β) (b : β) : list α → β × list β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β → β) (b : β)",
    "doc_string": " Auxiliary definition used to define `scanr`. If `scanr_aux f b l = (b', l')` then `scanr f b l = b' :: l'`",
    "kind": "def",
    "type": "list α → β × list β"
  },
  {
    "name": "is_chain",
    "statement": "def is_chain {α : Type u_1} (r : α → α → Prop) (s : set α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s : set α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (s : set α)",
    "doc_string": "A chain is a set `s` satisfying `x ≺ y ∨ x = y ∨ y ≺ x` for all `x y ∈ s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "quaternion_group.fintype",
    "statement": "def quaternion_group.fintype {n : ℕ} [fact (0 < n)] : fintype (quaternion_group n)",
    "theorem": "{n : ℕ} [fact (0 < n)] : fintype (quaternion_group n)",
    "args": "{n : ℕ} [fact (0 < n)]",
    "doc_string": "If `0 < n`, then `quaternion_group n` is a finite group.",
    "kind": "def",
    "type": "fintype (quaternion_group n)"
  },
  {
    "name": "neg_nonpos",
    "statement": "theorem neg_nonpos {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 ↔ 0 ≤ a",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 ↔ 0 ≤ a",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α}",
    "doc_string": "**Alias** of left.inv_le_one_iff`.",
    "kind": "theorem",
    "type": "-a ≤ 0 ↔ 0 ≤ a"
  },
  {
    "name": "category_theory.limits.has_finite_colimits",
    "statement": "structure category_theory.limits.has_finite_colimits (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category has all finite colimits if every functor `J ⥤ C` with a `fin_category J` instance has a colimit.  This is often called 'finitely cocomplete'.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nat.eq_pow_of_factorization_eq_single",
    "statement": "theorem nat.eq_pow_of_factorization_eq_single {n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k",
    "theorem": "{n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k",
    "args": "{n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k)",
    "doc_string": "If the factorization of `n` contains just one number `p` then `n` is a power of `p`",
    "kind": "theorem",
    "type": "n = p ^ k"
  },
  {
    "name": "add_con.map_gen",
    "statement": "def add_con.map_gen {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (f : M → N) : add_con N",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (f : M → N) : add_con N",
    "args": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (f : M → N)",
    "doc_string": "Given a function `f`, the smallest additive congruence relation containing the binary relation on `f`'s image defined by '`x ≈ y` iff the elements of `f⁻¹(x)` are related to the elements of `f⁻¹(y)` by an additive congruence relation `c`.'",
    "kind": "def",
    "type": "add_con N"
  },
  {
    "name": "witt_vector.witt_poly_prod",
    "statement": "def witt_vector.witt_poly_prod (p n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ",
    "theorem": "(p n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ",
    "args": "(p n : ℕ)",
    "doc_string": "```lean (∑ i in range n, (y.coeff i)^(p^(n-i)) * p^i.val) *   (∑ i in range n, (y.coeff i)^(p^(n-i)) * p^i.val) ```",
    "kind": "def",
    "type": "mv_polynomial (fin 2 × ℕ) ℤ"
  },
  {
    "name": "wseq.inits",
    "statement": "def wseq.inits {α : Type u} (s : wseq α) : wseq (list α)",
    "theorem": "{α : Type u} (s : wseq α) : wseq (list α)",
    "args": "{α : Type u} (s : wseq α)",
    "doc_string": "Get the weak sequence of initial segments of the input sequence",
    "kind": "def",
    "type": "wseq (list α)"
  },
  {
    "name": "is_semiring_hom.to_is_add_monoid_hom",
    "statement": "theorem is_semiring_hom.to_is_add_monoid_hom {α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_add_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_add_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f)",
    "doc_string": "A semiring homomorphism is an additive monoid homomorphism.",
    "kind": "theorem",
    "type": "is_add_monoid_hom f"
  },
  {
    "name": "list.find",
    "statement": "def list.find {α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → option α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → option α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p]",
    "doc_string": "`find p l` is the first element of `l` satisfying `p`, or `none` if no such  element exists.",
    "kind": "def",
    "type": "list α → option α"
  },
  {
    "name": "emetric.inf_edist_anti",
    "statement": "theorem emetric.inf_edist_anti {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : s ⊆ t) : emetric.inf_edist x t ≤ emetric.inf_edist x s",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : s ⊆ t) : emetric.inf_edist x t ≤ emetric.inf_edist x s",
    "args": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : s ⊆ t)",
    "doc_string": "The edist is antitone with respect to inclusion.",
    "kind": "theorem",
    "type": "emetric.inf_edist x t ≤ emetric.inf_edist x s"
  },
  {
    "name": "ring_hom",
    "statement": "structure ring_hom (α : Type u_5) (β : Type u_6) [non_assoc_semiring α] [non_assoc_semiring β] : Type (max u_5 u_6)",
    "theorem": "(α : Type u_5) (β : Type u_6) [non_assoc_semiring α] [non_assoc_semiring β] : Type (max u_5 u_6)",
    "args": "(α : Type u_5) (β : Type u_6) [non_assoc_semiring α] [non_assoc_semiring β]",
    "doc_string": " Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.  This extends from both `monoid_hom` and `monoid_with_zero_hom` in order to put the fields in a sensible order, even though `monoid_with_zero_hom` already extends `monoid_hom`.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "clifford_algebra_quaternion.Q",
    "statement": "def clifford_algebra_quaternion.Q {R : Type u_1} [comm_ring R] (c₁ c₂ : R) : quadratic_form R (R × R)",
    "theorem": "{R : Type u_1} [comm_ring R] (c₁ c₂ : R) : quadratic_form R (R × R)",
    "args": "{R : Type u_1} [comm_ring R] (c₁ c₂ : R)",
    "doc_string": " `Q c₁ c₂` is a quadratic form over `R × R` such that `clifford_algebra (Q c₁ c₂)` is isomorphic as an `R`-algebra to `ℍ[R,c₁,c₂]`.",
    "kind": "def",
    "type": "quadratic_form R (R × R)"
  },
  {
    "name": "Top.of",
    "statement": "def Top.of (X : Type u) [topological_space X] : Top",
    "theorem": "(X : Type u) [topological_space X] : Top",
    "args": "(X : Type u) [topological_space X]",
    "doc_string": "Construct a bundled `Top` from the underlying type and the typeclass.",
    "kind": "def",
    "type": "Top"
  },
  {
    "name": "prod.non_unital_comm_semiring",
    "statement": "def prod.non_unital_comm_semiring {R : Type u_1} {S : Type u_3} [non_unital_comm_semiring R] [non_unital_comm_semiring S] : non_unital_comm_semiring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [non_unital_comm_semiring R] [non_unital_comm_semiring S] : non_unital_comm_semiring (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [non_unital_comm_semiring R] [non_unital_comm_semiring S]",
    "doc_string": "Product of two `non_unital_comm_semiring`s is a `non_unital_comm_semiring`.",
    "kind": "def",
    "type": "non_unital_comm_semiring (R × S)"
  },
  {
    "name": "ordered_add_comm_group",
    "statement": "structure ordered_add_comm_group (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " An ordered additive commutative group is an additive commutative group with a partial order in which addition is strictly monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "list.chain'",
    "statement": "def list.chain' {α : Type u_1} (R : α → α → Prop) : list α → Prop",
    "theorem": "{α : Type u_1} (R : α → α → Prop) : list α → Prop",
    "args": "{α : Type u_1} (R : α → α → Prop)",
    "doc_string": "`chain' R l` means that `R` holds between adjacent elements of `l`.      chain' R [a, b, c, d] ↔ R a b ∧ R b c ∧ R c d",
    "kind": "def",
    "type": "list α → Prop"
  },
  {
    "name": "lie_subalgebra.is_cartan_subalgebra",
    "statement": "structure lie_subalgebra.is_cartan_subalgebra {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : Prop",
    "theorem": "{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L) : Prop",
    "args": "{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] (H : lie_subalgebra R L)",
    "doc_string": "A Cartan subalgebra is a nilpotent, self-normalizing subalgebra.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "filter.tendsto",
    "statement": "def filter.tendsto {α : Type u} {β : Type v} (f : α → β) (l₁ : filter α) (l₂ : filter β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (l₁ : filter α) (l₂ : filter β) : Prop",
    "args": "{α : Type u} {β : Type v} (f : α → β) (l₁ : filter α) (l₂ : filter β)",
    "doc_string": "`tendsto` is the generic \"limit of a function\" predicate.  `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,  the `f`-preimage of `a` is an `l₁` neighborhood.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.Icc_eq_empty",
    "statement": "theorem finset.Icc_eq_empty {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → finset.Icc a b = ∅",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → finset.Icc a b = ∅",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of finset.Icc_eq_empty_iff`.",
    "kind": "theorem",
    "type": "¬a ≤ b → finset.Icc a b = ∅"
  },
  {
    "name": "nat.lt_wf",
    "statement": "theorem nat.lt_wf  : well_founded nat.lt",
    "theorem": " : well_founded nat.lt",
    "args": "",
    "doc_string": "less-than is well-founded",
    "kind": "theorem",
    "type": "well_founded nat.lt"
  },
  {
    "name": "fin.mk",
    "statement": "def fin.mk {n : ℕ} (i : ℕ) (h : i < n) : fin n",
    "theorem": "{n : ℕ} (i : ℕ) (h : i < n) : fin n",
    "args": "{n : ℕ} (i : ℕ) (h : i < n)",
    "doc_string": "Backwards-compatible constructor for `fin n`.",
    "kind": "def",
    "type": "fin n"
  },
  {
    "name": "tactic.rewrite_search.vertex",
    "statement": "structure tactic.rewrite_search.vertex  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A vertex represents an expression that is equivalent to either the left or right side of our initial equation. * `id` is a numerical id used to refer to this vertex in the context of a single graph. * `exp` is the expression this vertex represents. * `pp` is the string format of the expression; we store this in the vertex to avoid recalculating it. * `side` is whether this vertex descends from the left or right side of the equation. * `parent` is the edge that originally added this vertex to the graph.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "filter.has_inf",
    "statement": "def filter.has_inf {α : Type u} : has_inf (filter α)",
    "theorem": "{α : Type u} : has_inf (filter α)",
    "args": "{α : Type u}",
    "doc_string": "The infimum of filters is the filter generated by intersections  of elements of the two filters.",
    "kind": "def",
    "type": "has_inf (filter α)"
  },
  {
    "name": "list.length_pos_of_sum_ne_zero",
    "statement": "theorem list.length_pos_of_sum_ne_zero {M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length",
    "theorem": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length",
    "args": "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0)",
    "doc_string": "A list with sum not zero must have positive length.",
    "kind": "theorem",
    "type": "0 < L.length"
  },
  {
    "name": "generalized_continued_fraction.terminated_at",
    "statement": "def generalized_continued_fraction.terminated_at {α : Type u_1} (g : generalized_continued_fraction α) (n : ℕ) : Prop",
    "theorem": "{α : Type u_1} (g : generalized_continued_fraction α) (n : ℕ) : Prop",
    "args": "{α : Type u_1} (g : generalized_continued_fraction α) (n : ℕ)",
    "doc_string": "A gcf terminated at position `n` if its sequence terminates at position `n`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "one_lt_mul'",
    "statement": "theorem one_lt_mul' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": "**Alias** of left.one_lt_mul`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "algebraic_geometry.Scheme",
    "statement": "structure algebraic_geometry.Scheme  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "We define `Scheme` as a `X : LocallyRingedSpace`, along with a proof that every point has an open neighbourhood `U` so that that the restriction of `X` to `U` is isomorphic, as a locally ringed space, to `Spec.to_LocallyRingedSpace.obj (op R)` for some `R : CommRing`.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "category_theory.rigid_category",
    "statement": "structure category_theory.rigid_category (C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "A rigid monoidal category is a monoidal category which is left rigid and right rigid.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "fin_enum.finset.enum",
    "statement": "def fin_enum.finset.enum {α : Type u} [decidable_eq α] : list α → list (finset α)",
    "theorem": "{α : Type u} [decidable_eq α] : list α → list (finset α)",
    "args": "{α : Type u} [decidable_eq α]",
    "doc_string": "enumerate all finite sets of a given type",
    "kind": "def",
    "type": "list α → list (finset α)"
  },
  {
    "name": "pgame.grundy_value",
    "statement": "def pgame.grundy_value (G : pgame) : ordinal",
    "theorem": "(G : pgame) : ordinal",
    "args": "(G : pgame)",
    "doc_string": "The Grundy value of an impartial game, the ordinal which corresponds to the game of nim that the game is equivalent to",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "bounded_continuous_function.pseudo_metric_space",
    "statement": "def bounded_continuous_function.pseudo_metric_space {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : pseudo_metric_space (bounded_continuous_function α β)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : pseudo_metric_space (bounded_continuous_function α β)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β]",
    "doc_string": "The type of bounded continuous functions, with the uniform distance, is a pseudometric space.",
    "kind": "def",
    "type": "pseudo_metric_space (bounded_continuous_function α β)"
  },
  {
    "name": "chain_complex.mk_struct",
    "statement": "structure chain_complex.mk_struct (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)",
    "theorem": "(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)",
    "args": "(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V]",
    "doc_string": "Auxiliary structure for setting up the recursion in `mk`. This is purely an implementation detail: for some reason just using the dependent 6-tuple directly results in `mk_aux` taking much longer (well over the `-T100000` limit) to elaborate.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "add_con.has_Inf",
    "statement": "def add_con.has_Inf {M : Type u_1} [has_add M] : has_Inf (add_con M)",
    "theorem": "{M : Type u_1} [has_add M] : has_Inf (add_con M)",
    "args": "{M : Type u_1} [has_add M]",
    "doc_string": "The infimum of a set of additive congruence relations on a given type with an addition.",
    "kind": "def",
    "type": "has_Inf (add_con M)"
  },
  {
    "name": "modular_group.S",
    "statement": "def modular_group.S  : matrix.special_linear_group (fin 2) ℤ",
    "theorem": " : matrix.special_linear_group (fin 2) ℤ",
    "args": "",
    "doc_string": "The matrix `S = [[0,-1],[1,0]]` as an element of `SL(2,ℤ)`",
    "kind": "def",
    "type": "matrix.special_linear_group (fin 2) ℤ"
  },
  {
    "name": "name.get_nth_prefix",
    "statement": "def name.get_nth_prefix  : name → ℕ → name",
    "theorem": " : name → ℕ → name",
    "args": "",
    "doc_string": "`get_nth_prefix nm n` removes the last `n` components from `nm`",
    "kind": "def",
    "type": "name → ℕ → name"
  },
  {
    "name": "set.inv_Ioo_0_left",
    "statement": "theorem set.inv_Ioo_0_left {k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)⁻¹ = set.Ioi a⁻¹",
    "theorem": "{k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)⁻¹ = set.Ioi a⁻¹",
    "args": "{k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a)",
    "doc_string": "The (pre)image under `inv` of `Ioo 0 a` is `Ioi a⁻¹`.",
    "kind": "theorem",
    "type": "(set.Ioo 0 a)⁻¹ = set.Ioi a⁻¹"
  },
  {
    "name": "valuation_ring.value_group",
    "statement": "def valuation_ring.value_group (A : Type u) [comm_ring A] (K : Type v) [field K] [algebra A K] : Type v",
    "theorem": "(A : Type u) [comm_ring A] (K : Type v) [field K] [algebra A K] : Type v",
    "args": "(A : Type u) [comm_ring A] (K : Type v) [field K] [algebra A K]",
    "doc_string": "The value group of the valuation ring `A`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "polynomial.pow_sub_pow_factor",
    "statement": "def polynomial.pow_sub_pow_factor {R : Type u} [comm_ring R] (x y : R) (i : ℕ) : {z // x ^ i - y ^ i = z * (x - y)}",
    "theorem": "{R : Type u} [comm_ring R] (x y : R) (i : ℕ) : {z // x ^ i - y ^ i = z * (x - y)}",
    "args": "{R : Type u} [comm_ring R] (x y : R) (i : ℕ)",
    "doc_string": "`x^n - y^n` can be expressed as `z * (x - y)` for some `z` in the ring.",
    "kind": "def",
    "type": "{z // x ^ i - y ^ i = z * (x - y)}"
  },
  {
    "name": "eq.subset",
    "statement": "theorem eq.subset {α : Type u_1} {s t : set α} : s = t → s ⊆ t",
    "theorem": "{α : Type u_1} {s t : set α} : s = t → s ⊆ t",
    "args": "{α : Type u_1} {s t : set α}",
    "doc_string": "Duplicate of `eq.subset'`, which currently has elaboration problems.",
    "kind": "theorem",
    "type": "s = t → s ⊆ t"
  },
  {
    "name": "semiquot.to_trunc",
    "statement": "def semiquot.to_trunc {α : Type u_1} (q : semiquot α) : trunc α",
    "theorem": "{α : Type u_1} (q : semiquot α) : trunc α",
    "args": "{α : Type u_1} (q : semiquot α)",
    "doc_string": "Convert a `semiquot α` to a `trunc α`.",
    "kind": "def",
    "type": "trunc α"
  },
  {
    "name": "geometry.simplicial_complex.facets",
    "statement": "def geometry.simplicial_complex.facets {𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E) : set (finset E)",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E) : set (finset E)",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E)",
    "doc_string": "A facet of a simplicial complex is a maximal face.",
    "kind": "def",
    "type": "set (finset E)"
  },
  {
    "name": "list.split_at",
    "statement": "def list.split_at {α : Type u_1} : ℕ → list α → list α × list α",
    "theorem": "{α : Type u_1} : ℕ → list α → list α × list α",
    "args": "{α : Type u_1}",
    "doc_string": "Split a list at an index.      split_at 2 [a, b, c] = ([a, b], [c])",
    "kind": "def",
    "type": "ℕ → list α → list α × list α"
  },
  {
    "name": "edist_eq_zero",
    "statement": "theorem edist_eq_zero {γ : Type w} [emetric_space γ] {x y : γ} : has_edist.edist x y = 0 ↔ x = y",
    "theorem": "{γ : Type w} [emetric_space γ] {x y : γ} : has_edist.edist x y = 0 ↔ x = y",
    "args": "{γ : Type w} [emetric_space γ] {x y : γ}",
    "doc_string": "Characterize the equality of points by the vanishing of their extended distance",
    "kind": "theorem",
    "type": "has_edist.edist x y = 0 ↔ x = y"
  },
  {
    "name": "seq.nats",
    "statement": "def seq.nats  : seq ℕ",
    "theorem": " : seq ℕ",
    "args": "",
    "doc_string": "The sequence of natural numbers some 0, some 1, ...",
    "kind": "def",
    "type": "seq ℕ"
  },
  {
    "name": "W_type.of_sigma",
    "statement": "def W_type.of_sigma {α : Type u_1} {β : α → Type u_2} : (Σ (a : α), β a → W_type β) → W_type β",
    "theorem": "{α : Type u_1} {β : α → Type u_2} : (Σ (a : α), β a → W_type β) → W_type β",
    "args": "{α : Type u_1} {β : α → Type u_2}",
    "doc_string": "The canonical map from the sigma type into a `W_type`. Given a node `a : α`, and  its children as a function `β a → W_type β`, return the corresponding tree.",
    "kind": "def",
    "type": "(Σ (a : α), β a → W_type β) → W_type β"
  },
  {
    "name": "mvpfunctor.M.path",
    "statement": "inductive mvpfunctor.M.path {n : ℕ} (P : mvpfunctor (n + 1)) : P.last.M → fin2 n → Type u",
    "theorem": "{n : ℕ} (P : mvpfunctor (n + 1)) : P.last.M → fin2 n → Type u",
    "args": "{n : ℕ} (P : mvpfunctor (n + 1))",
    "doc_string": "A path from the root of a tree to one of its node",
    "kind": "inductive",
    "type": "P.last.M → fin2 n → Type u"
  },
  {
    "name": "multiset.sub_zero",
    "statement": "theorem multiset.sub_zero {α : Type u_1} [decidable_eq α] (s : multiset α) : s - 0 = s",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : multiset α) : s - 0 = s",
    "args": "{α : Type u_1} [decidable_eq α] (s : multiset α)",
    "doc_string": "This is a special case of `tsub_zero`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset α)`.",
    "kind": "theorem",
    "type": "s - 0 = s"
  },
  {
    "name": "field.to_is_field",
    "statement": "theorem field.to_is_field (R : Type u) [field R] : is_field R",
    "theorem": "(R : Type u) [field R] : is_field R",
    "args": "(R : Type u) [field R]",
    "doc_string": "Transferring from field to is_field",
    "kind": "theorem",
    "type": "is_field R"
  },
  {
    "name": "category_theory.limits.has_coproducts_of_shape",
    "statement": "def category_theory.limits.has_coproducts_of_shape (β : Type v) (C : Type u_1) [category_theory.category C] : Prop",
    "theorem": "(β : Type v) (C : Type u_1) [category_theory.category C] : Prop",
    "args": "(β : Type v) (C : Type u_1) [category_theory.category C]",
    "doc_string": "An abbreviation for `has_colimits_of_shape (discrete f)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "fintype.to_order_bot",
    "statement": "def fintype.to_order_bot (α : Type u_2) [fintype α] [nonempty α] [semilattice_inf α] : order_bot α",
    "theorem": "(α : Type u_2) [fintype α] [nonempty α] [semilattice_inf α] : order_bot α",
    "args": "(α : Type u_2) [fintype α] [nonempty α] [semilattice_inf α]",
    "doc_string": "Constructs the `⊥` of a finite nonempty `semilattice_inf`.",
    "kind": "def",
    "type": "order_bot α"
  },
  {
    "name": "multiset.keys",
    "statement": "def multiset.keys {α : Type u} {β : α → Type v} (s : multiset (sigma β)) : multiset α",
    "theorem": "{α : Type u} {β : α → Type v} (s : multiset (sigma β)) : multiset α",
    "args": "{α : Type u} {β : α → Type v} (s : multiset (sigma β))",
    "doc_string": "Multiset of keys of an association multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "semiquot.lift_on",
    "statement": "def semiquot.lift_on {α : Type u_1} {β : Type u_2} (q : semiquot α) (f : α → β) (h : ∀ (a : α), a ∈ q → ∀ (b : α), b ∈ q → f a = f b) : β",
    "theorem": "{α : Type u_1} {β : Type u_2} (q : semiquot α) (f : α → β) (h : ∀ (a : α), a ∈ q → ∀ (b : α), b ∈ q → f a = f b) : β",
    "args": "{α : Type u_1} {β : Type u_2} (q : semiquot α) (f : α → β) (h : ∀ (a : α), a ∈ q → ∀ (b : α), b ∈ q → f a = f b)",
    "doc_string": " If `f` is a constant on `q.s`, then `q.lift_on f` is the value of `f` at any point of `q`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "Gromov_Hausdorff.aux_gluing_struct",
    "statement": "structure Gromov_Hausdorff.aux_gluing_struct (A : Type) [metric_space A] : Type 1",
    "theorem": "(A : Type) [metric_space A] : Type 1",
    "args": "(A : Type) [metric_space A]",
    "doc_string": " Auxiliary structure used to glue metric spaces below, recording an isometric embedding of a type `A` in another metric space.",
    "kind": "structure",
    "type": "Type 1"
  },
  {
    "name": "matrix.nonsing_inv_eq_ring_inverse",
    "statement": "theorem matrix.nonsing_inv_eq_ring_inverse {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : A⁻¹ = ring.inverse A",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : A⁻¹ = ring.inverse A",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α)",
    "doc_string": "The nonsingular inverse is the same as the general `ring.inverse`.",
    "kind": "theorem",
    "type": "A⁻¹ = ring.inverse A"
  },
  {
    "name": "nhds_within",
    "statement": "def nhds_within {α : Type u} [topological_space α] (a : α) (s : set α) : filter α",
    "theorem": "{α : Type u} [topological_space α] (a : α) (s : set α) : filter α",
    "args": "{α : Type u} [topological_space α] (a : α) (s : set α)",
    "doc_string": " The \"neighborhood within\" filter. Elements of `𝓝[s] a` are sets containing the intersection of `s` and a neighborhood of `a`.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "list.func.equiv",
    "statement": "def list.func.equiv {α : Type u} [inhabited α] (as1 as2 : list α) : Prop",
    "theorem": "{α : Type u} [inhabited α] (as1 as2 : list α) : Prop",
    "args": "{α : Type u} [inhabited α] (as1 as2 : list α)",
    "doc_string": "Pointwise equality of lists. If lists are different lengths, compare with the default element.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "galois_connection.lower_adjoint",
    "statement": "def galois_connection.lower_adjoint {α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u) : lower_adjoint u",
    "theorem": "{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u) : lower_adjoint u",
    "args": "{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u)",
    "doc_string": "Every Galois connection induces a lower adjoint.",
    "kind": "def",
    "type": "lower_adjoint u"
  },
  {
    "name": "stream.tails",
    "statement": "def stream.tails {α : Type u} (s : stream α) : stream (stream α)",
    "theorem": "{α : Type u} (s : stream α) : stream (stream α)",
    "args": "{α : Type u} (s : stream α)",
    "doc_string": "Tails of a stream, starting with `stream.tail s`.",
    "kind": "def",
    "type": "stream (stream α)"
  },
  {
    "name": "ring.inverse_non_unit",
    "statement": "theorem ring.inverse_non_unit {M₀ : Type u_1} [monoid_with_zero M₀] (x : M₀) (h : ¬is_unit x) : ring.inverse x = 0",
    "theorem": "{M₀ : Type u_1} [monoid_with_zero M₀] (x : M₀) (h : ¬is_unit x) : ring.inverse x = 0",
    "args": "{M₀ : Type u_1} [monoid_with_zero M₀] (x : M₀) (h : ¬is_unit x)",
    "doc_string": "By definition, if `x` is not invertible then `inverse x = 0`.",
    "kind": "theorem",
    "type": "ring.inverse x = 0"
  },
  {
    "name": "subsingleton.convex_independent",
    "statement": "theorem subsingleton.convex_independent {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [subsingleton ι] (p : ι → E) : convex_independent 𝕜 p",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [subsingleton ι] (p : ι → E) : convex_independent 𝕜 p",
    "args": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [subsingleton ι] (p : ι → E)",
    "doc_string": "A family with at most one point is convex independent.",
    "kind": "theorem",
    "type": "convex_independent 𝕜 p"
  },
  {
    "name": "seq.head",
    "statement": "def seq.head {α : Type u} (s : seq α) : option α",
    "theorem": "{α : Type u} (s : seq α) : option α",
    "args": "{α : Type u} (s : seq α)",
    "doc_string": "Get the first element of a sequence",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "formal_multilinear_series.comp_partial_sum_source",
    "statement": "def formal_multilinear_series.comp_partial_sum_source (m M N : ℕ) : finset (Σ (n : ℕ), fin n → ℕ)",
    "theorem": "(m M N : ℕ) : finset (Σ (n : ℕ), fin n → ℕ)",
    "args": "(m M N : ℕ)",
    "doc_string": " Source set in the change of variables to compute the composition of partial sums of formal power series. See also `comp_partial_sum`.",
    "kind": "def",
    "type": "finset (Σ (n : ℕ), fin n → ℕ)"
  },
  {
    "name": "ordnode.prod",
    "statement": "def ordnode.prod {α : Type u} {β : Type u_1} (t₁ : ordnode α) (t₂ : ordnode β) : ordnode (α × β)",
    "theorem": "{α : Type u} {β : Type u_1} (t₁ : ordnode α) (t₂ : ordnode β) : ordnode (α × β)",
    "args": "{α : Type u} {β : Type u_1} (t₁ : ordnode α) (t₂ : ordnode β)",
    "doc_string": "O(m*n). The cartesian product of two sets: `(a, b) ∈ s.prod t` iff `a ∈ s` and `b ∈ t`.      prod {1, 2} {2, 3} = {(1, 2), (1, 3), (2, 2), (2, 3)}",
    "kind": "def",
    "type": "ordnode (α × β)"
  },
  {
    "name": "algebra.elemental_algebra",
    "statement": "def algebra.elemental_algebra (R : Type u_1) [comm_ring R] {A : Type u} [topological_space A] [ring A] [algebra R A] [topological_ring A] (x : A) : subalgebra R A",
    "theorem": "(R : Type u_1) [comm_ring R] {A : Type u} [topological_space A] [ring A] [algebra R A] [topological_ring A] (x : A) : subalgebra R A",
    "args": "(R : Type u_1) [comm_ring R] {A : Type u} [topological_space A] [ring A] [algebra R A] [topological_ring A] (x : A)",
    "doc_string": "The topological closure of the subalgebra generated by a single element.",
    "kind": "def",
    "type": "subalgebra R A"
  },
  {
    "name": "set.infinite",
    "statement": "def set.infinite {α : Type u} (s : set α) : Prop",
    "theorem": "{α : Type u} (s : set α) : Prop",
    "args": "{α : Type u} (s : set α)",
    "doc_string": " A set is infinite if it is not finite.  This is protected so that it does not conflict with global `infinite`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.copair",
    "statement": "def ordnode.copair {α : Type u} {β : Type u_1} (t₁ : ordnode α) (t₂ : ordnode β) : ordnode (α ⊕ β)",
    "theorem": "{α : Type u} {β : Type u_1} (t₁ : ordnode α) (t₂ : ordnode β) : ordnode (α ⊕ β)",
    "args": "{α : Type u} {β : Type u_1} (t₁ : ordnode α) (t₂ : ordnode β)",
    "doc_string": " O(m+n). Build a set on the disjoint union by combining sets on the factors. `inl a ∈ s.copair t` iff `a ∈ s`, and `inr b ∈ s.copair t` iff `b ∈ t`.      copair {1, 2} {2, 3} = {inl 1, inl 2, inr 2, inr 3}",
    "kind": "def",
    "type": "ordnode (α ⊕ β)"
  },
  {
    "name": "with_ideal",
    "statement": "structure with_ideal (R : Type u_2) [comm_ring R] : Type u_2",
    "theorem": "(R : Type u_2) [comm_ring R] : Type u_2",
    "args": "(R : Type u_2) [comm_ring R]",
    "doc_string": "The ring `R` is equipped with a preferred ideal.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "list.keys",
    "statement": "def list.keys {α : Type u} {β : α → Type v} : list (sigma β) → list α",
    "theorem": "{α : Type u} {β : α → Type v} : list (sigma β) → list α",
    "args": "{α : Type u} {β : α → Type v}",
    "doc_string": "List of keys from a list of key-value pairs",
    "kind": "def",
    "type": "list (sigma β) → list α"
  },
  {
    "name": "is_square_of_exists_sq",
    "statement": "theorem is_square_of_exists_sq {α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m",
    "theorem": "{α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m",
    "args": "{α : Type u_2} [monoid α] (m : α)",
    "doc_string": "**Alias** of the reverse direction of is_square_iff_exists_sq`.",
    "kind": "theorem",
    "type": "(∃ (c : α), m = c ^ 2) → is_square m"
  },
  {
    "name": "is_separated",
    "statement": "def is_separated {α : Type u} [uniform_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [uniform_space α] (s : set α) : Prop",
    "args": "{α : Type u} [uniform_space α] (s : set α)",
    "doc_string": " A set `s` in a uniform space `α` is separated if the separation relation `𝓢 α` induces the trivial relation on `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "quot.out",
    "statement": "def quot.out {α : Sort u_1} {r : α → α → Prop} (q : quot r) : α",
    "theorem": "{α : Sort u_1} {r : α → α → Prop} (q : quot r) : α",
    "args": "{α : Sort u_1} {r : α → α → Prop} (q : quot r)",
    "doc_string": "Choose an element of the equivalence class using the axiom of choice.  Sound but noncomputable.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "category_theory.limits.has_wide_equalizers",
    "statement": "def category_theory.limits.has_wide_equalizers (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_wide_equalizers` represents a choice of wide equalizer for every family of morphisms",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_trans",
    "statement": "structure is_trans (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": "`is_trans X r` means the binary relation `r` on `X` is transitive.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_biproduct.of_has_coproduct",
    "statement": "theorem category_theory.limits.has_biproduct.of_has_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f]",
    "doc_string": "In a preadditive category, if the coproduct over `f : J → C` exists,    then the biproduct over `f` exists.",
    "kind": "theorem",
    "type": "category_theory.limits.has_biproduct f"
  },
  {
    "name": "vector3.cons",
    "statement": "def vector3.cons {α : Type u_1} {n : ℕ} (a : α) (v : vector3 α n) : vector3 α n.succ",
    "theorem": "{α : Type u_1} {n : ℕ} (a : α) (v : vector3 α n) : vector3 α n.succ",
    "args": "{α : Type u_1} {n : ℕ} (a : α) (v : vector3 α n)",
    "doc_string": "The vector cons operation",
    "kind": "def",
    "type": "vector3 α n.succ"
  },
  {
    "name": "inv_gold_conj",
    "statement": "theorem inv_gold_conj  : golden_conj⁻¹ = -golden_ratio",
    "theorem": " : golden_conj⁻¹ = -golden_ratio",
    "args": "",
    "doc_string": "The opposite of the golden ratio is the inverse of its conjugate.",
    "kind": "theorem",
    "type": "golden_conj⁻¹ = -golden_ratio"
  },
  {
    "name": "prime_multiset",
    "statement": "def prime_multiset  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of multisets of prime numbers.  Unique factorization gives an equivalence between this set and ℕ+, as we will formalize below.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "Sup_hom_class",
    "statement": "structure Sup_hom_class (F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [has_Sup α] [has_Sup β] : Type (max u_10 u_8 u_9)",
    "theorem": "(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [has_Sup α] [has_Sup β] : Type (max u_10 u_8 u_9)",
    "args": "(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [has_Sup α] [has_Sup β]",
    "doc_string": " `Sup_hom_class F α β` states that `F` is a type of `⨆`-preserving morphisms.  You should extend this class when you extend `Sup_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_8 u_9)"
  },
  {
    "name": "Top.prod_binary_fan",
    "statement": "def Top.prod_binary_fan (X Y : Top) : category_theory.limits.binary_fan X Y",
    "theorem": "(X Y : Top) : category_theory.limits.binary_fan X Y",
    "args": "(X Y : Top)",
    "doc_string": "The explicit binary cofan of `X, Y` given by `X × Y`.",
    "kind": "def",
    "type": "category_theory.limits.binary_fan X Y"
  },
  {
    "name": "nhds",
    "statement": "def nhds {α : Type u} [topological_space α] (a : α) : filter α",
    "theorem": "{α : Type u} [topological_space α] (a : α) : filter α",
    "args": "{α : Type u} [topological_space α] (a : α)",
    "doc_string": " A set is called a neighborhood of `a` if it contains an open set around `a`. The set of all neighborhoods of `a` forms a filter, the neighborhood filter at `a`, is here defined as the infimum over the principal filters of all open sets containing `a`.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "category_theory.single_obj.category_struct",
    "statement": "def category_theory.single_obj.category_struct (α : Type u) [has_one α] [has_mul α] : category_theory.category_struct (category_theory.single_obj α)",
    "theorem": "(α : Type u) [has_one α] [has_mul α] : category_theory.category_struct (category_theory.single_obj α)",
    "args": "(α : Type u) [has_one α] [has_mul α]",
    "doc_string": "One and `flip (*)` become `id` and `comp` for morphisms of the single object category.",
    "kind": "def",
    "type": "category_theory.category_struct (category_theory.single_obj α)"
  },
  {
    "name": "ordnode.insert'",
    "statement": "def ordnode.insert' {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": " O(log n). Insert an element into the set, preserving balance and the BST property. If an equivalent element is already in the set, the set is returned as is.      insert' 1 {1, 2, 3} = {1, 2, 3}     insert' 4 {1, 2, 3} = {1, 2, 3, 4}  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      insert' (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}     insert' (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)}",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "num.to_znum_neg",
    "statement": "def num.to_znum_neg  : num → znum",
    "theorem": " : num → znum",
    "args": "",
    "doc_string": "Converts `x : num` to `-x : znum`.",
    "kind": "def",
    "type": "num → znum"
  },
  {
    "name": "nat.exists_strict_anti'",
    "statement": "theorem nat.exists_strict_anti' {α : Type u} [preorder α] [no_min_order α] (a : α) : ∃ (f : ℕ → α), strict_anti f ∧ f 0 = a",
    "theorem": "{α : Type u} [preorder α] [no_min_order α] (a : α) : ∃ (f : ℕ → α), strict_anti f ∧ f 0 = a",
    "args": "{α : Type u} [preorder α] [no_min_order α] (a : α)",
    "doc_string": " If `α` is a preorder with no maximal elements, then there exists a strictly antitone function `ℕ → α` with any prescribed value of `f 0`.",
    "kind": "theorem",
    "type": "∃ (f : ℕ → α), strict_anti f ∧ f 0 = a"
  },
  {
    "name": "neg_pos",
    "statement": "theorem neg_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a ↔ a < 0",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a ↔ a < 0",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.one_lt_inv_iff`.",
    "kind": "theorem",
    "type": "0 < -a ↔ a < 0"
  },
  {
    "name": "two_pointing.swap",
    "statement": "def two_pointing.swap {α : Type u_1} (p : two_pointing α) : two_pointing α",
    "theorem": "{α : Type u_1} (p : two_pointing α) : two_pointing α",
    "args": "{α : Type u_1} (p : two_pointing α)",
    "doc_string": "Swaps the two pointed elements.",
    "kind": "def",
    "type": "two_pointing α"
  },
  {
    "name": "category_theory.is_subterminal.mono_is_terminal_from",
    "statement": "theorem category_theory.is_subterminal.mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T)",
    "doc_string": "If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism. The converse of `is_subterminal_of_mono_is_terminal_from`.",
    "kind": "theorem",
    "type": "category_theory.mono (hT.from A)"
  },
  {
    "name": "mul_action.stabilizer.submonoid",
    "statement": "def mul_action.stabilizer.submonoid (α : Type u) {β : Type v} [monoid α] [mul_action α β] (b : β) : submonoid α",
    "theorem": "(α : Type u) {β : Type v} [monoid α] [mul_action α β] (b : β) : submonoid α",
    "args": "(α : Type u) {β : Type v} [monoid α] [mul_action α β] (b : β)",
    "doc_string": "The stabilizer of a point `b` as a submonoid of `α`.",
    "kind": "def",
    "type": "submonoid α"
  },
  {
    "name": "locally_compact_space",
    "statement": "structure locally_compact_space (α : Type u_3) [topological_space α] : Prop",
    "theorem": "(α : Type u_3) [topological_space α] : Prop",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": " There are various definitions of \"locally compact space\" in the literature, which agree for Hausdorff spaces but not in general. This one is the precise condition on X needed for the evaluation `map C(X, Y) × X → Y` to be continuous for all `Y` when `C(X, Y)` is given the compact-open topology.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "generalized_continued_fraction.denominators",
    "statement": "def generalized_continued_fraction.denominators {K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K",
    "theorem": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K",
    "args": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K)",
    "doc_string": "Returns the denominators `Bₙ` of `g`.",
    "kind": "def",
    "type": "stream K"
  },
  {
    "name": "closure",
    "statement": "def closure {α : Type u} [topological_space α] (s : set α) : set α",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : set α",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "The closure of `s` is the smallest closed set containing `s`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "submonoid.list_prod_mem",
    "statement": "theorem submonoid.list_prod_mem {M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.prod ∈ s",
    "theorem": "{M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.prod ∈ s",
    "args": "{M : Type u_1} [monoid M] (s : submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s)",
    "doc_string": "Product of a list of elements in a submonoid is in the submonoid.",
    "kind": "theorem",
    "type": "l.prod ∈ s"
  },
  {
    "name": "antivary",
    "statement": "def antivary {ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) : Prop",
    "theorem": "{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) : Prop",
    "args": "{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β)",
    "doc_string": "`f` antivaries with `g` if `g i < g j` implies `f j ≤ f i`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.binary_biproduct_data",
    "statement": "structure category_theory.limits.binary_biproduct_data {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C)",
    "doc_string": "A bicone over `P Q : C`, which is both a limit cone and a colimit cocone.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "is_add_right_regular.of_add",
    "statement": "theorem is_add_right_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a))",
    "doc_string": "If an element `b` becomes add-right-regular after adding to it on the right a add-right-regular element, then `b` is add-right-regular.",
    "kind": "theorem",
    "type": "is_add_right_regular b"
  },
  {
    "name": "measure_theory.jordan_decomposition",
    "statement": "structure measure_theory.jordan_decomposition (α : Type u_3) [measurable_space α] : Type u_3",
    "theorem": "(α : Type u_3) [measurable_space α] : Type u_3",
    "args": "(α : Type u_3) [measurable_space α]",
    "doc_string": " A Jordan decomposition of a measurable space is a pair of mutually singular, finite measures.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "ordinal.principal_seg_out",
    "statement": "def ordinal.principal_seg_out {α β : ordinal} (h : α < β) : principal_seg has_lt.lt has_lt.lt",
    "theorem": "{α β : ordinal} (h : α < β) : principal_seg has_lt.lt has_lt.lt",
    "args": "{α β : ordinal} (h : α < β)",
    "doc_string": " Given two ordinals `α < β`, then `principal_seg_out α β` is the principal segment embedding of `α` to `β`, as map from a model type for `α` to a model type for `β`.",
    "kind": "def",
    "type": "principal_seg has_lt.lt has_lt.lt"
  },
  {
    "name": "topological_fiber_bundle_core.continuous_total_space_mk",
    "statement": "theorem topological_fiber_bundle_core.continuous_total_space_mk {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b)",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b)",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B)",
    "doc_string": "The inclusion of a fiber into the total space is a continuous map.",
    "kind": "theorem",
    "type": "continuous (bundle.total_space_mk b)"
  },
  {
    "name": "fraction_ring",
    "statement": "def fraction_ring (R : Type u_1) [comm_ring R] : Type u_1",
    "theorem": "(R : Type u_1) [comm_ring R] : Type u_1",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": " The fraction ring of a commutative ring `R` as a quotient type.  We instantiate this definition as generally as possible, and assume that the commutative ring `R` is an integral domain only when this is needed for proving.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "open_embedding",
    "statement": "structure open_embedding {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β)",
    "doc_string": "An open embedding is an embedding with open image.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "arrow_action",
    "statement": "def arrow_action {G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] : mul_action G (A → B)",
    "theorem": "{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] : mul_action G (A → B)",
    "args": "{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A]",
    "doc_string": "If `G` acts on `A`, then it acts also on `A → B`, by `(g • F) a = F (g⁻¹ • a)`.",
    "kind": "def",
    "type": "mul_action G (A → B)"
  },
  {
    "name": "int.exists_strict_mono",
    "statement": "theorem int.exists_strict_mono (α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_mono f",
    "theorem": "(α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_mono f",
    "args": "(α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α]",
    "doc_string": " If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly monotone function `f : ℤ → α`.",
    "kind": "theorem",
    "type": "∃ (f : ℤ → α), strict_mono f"
  },
  {
    "name": "hash_map.find_aux",
    "statement": "def hash_map.find_aux {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (Σ (a : α), β a) → option (β a)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (Σ (a : α), β a) → option (β a)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α)",
    "doc_string": "Search a bucket for a key `a` and return the value",
    "kind": "def",
    "type": "list (Σ (a : α), β a) → option (β a)"
  },
  {
    "name": "ordnode.inter",
    "statement": "def ordnode.inter {α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le]",
    "doc_string": " O(m * log(|m ∪ n| + 1)), m ≤ n. Intersection of two sets, preferring members of `t₁` over those of `t₂` when equivalent elements are encountered.      inter {1, 2} {2, 3} = {2}     inter {1, 3} {2} = ∅",
    "kind": "def",
    "type": "ordnode α → ordnode α → ordnode α"
  },
  {
    "name": "Mon_.trivial",
    "statement": "def Mon_.trivial (C : Type u₁) [category_theory.category C] [category_theory.monoidal_category C] : Mon_ C",
    "theorem": "(C : Type u₁) [category_theory.category C] [category_theory.monoidal_category C] : Mon_ C",
    "args": "(C : Type u₁) [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "The trivial monoid object. We later show this is initial in `Mon_ C`.",
    "kind": "def",
    "type": "Mon_ C"
  },
  {
    "name": "quotient_map",
    "statement": "def quotient_map {α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β)",
    "doc_string": "A function between topological spaces is a quotient map if it is surjective,  and for all `s : set β`, `s` is open iff its preimage is an open set.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nonempty.map",
    "statement": "theorem nonempty.map {α : Sort u_1} {β : Sort u_2} (f : α → β) : nonempty α → nonempty β",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (f : α → β) : nonempty α → nonempty β",
    "args": "{α : Sort u_1} {β : Sort u_2} (f : α → β)",
    "doc_string": "Given `f : α → β`, if `α` is nonempty then `β` is also nonempty.  `nonempty` cannot be a `functor`, because `functor` is restricted to `Type`.",
    "kind": "theorem",
    "type": "nonempty α → nonempty β"
  },
  {
    "name": "category_theory.is_cofiltered",
    "statement": "structure category_theory.is_cofiltered (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category `is_cofiltered` if 1. for every pair of objects there exists another object \"to the left\", 2. for every pair of parallel morphisms there exists a morphism to the left so the compositions    are equal, and 3. there exists some object.  See <https://stacks.math.columbia.edu/tag/04AZ>.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "closed_under_restriction_id_restr_groupoid",
    "statement": "def closed_under_restriction_id_restr_groupoid {H : Type u} [topological_space H] : closed_under_restriction id_restr_groupoid",
    "theorem": "{H : Type u} [topological_space H] : closed_under_restriction id_restr_groupoid",
    "args": "{H : Type u} [topological_space H]",
    "doc_string": "The trivial restriction-closed groupoid is indeed `closed_under_restriction`.",
    "kind": "def",
    "type": "closed_under_restriction id_restr_groupoid"
  },
  {
    "name": "ordnode.split_at",
    "statement": "def ordnode.split_at {α : Type u} (i : ℕ) (t : ordnode α) : ordnode α × ordnode α",
    "theorem": "{α : Type u} (i : ℕ) (t : ordnode α) : ordnode α × ordnode α",
    "args": "{α : Type u} (i : ℕ) (t : ordnode α)",
    "doc_string": "O(log n). Split a set at the `i`th element, getting the first `i` and everything else.      split_at 2 {a, b, c, d} = ({a, b}, {c, d})     split_at 5 {a, b, c, d} = ({a, b, c, d}, ∅)",
    "kind": "def",
    "type": "ordnode α × ordnode α"
  },
  {
    "name": "contravariant.to_left_cancel_semigroup",
    "statement": "def contravariant.to_left_cancel_semigroup {α : Type u_1} [semigroup α] [partial_order α] [contravariant_class α α has_mul.mul has_le.le] : left_cancel_semigroup α",
    "theorem": "{α : Type u_1} [semigroup α] [partial_order α] [contravariant_class α α has_mul.mul has_le.le] : left_cancel_semigroup α",
    "args": "{α : Type u_1} [semigroup α] [partial_order α] [contravariant_class α α has_mul.mul has_le.le]",
    "doc_string": "  A semigroup with a partial order and satisfying `left_cancel_semigroup` (i.e. `a * c < b * c → a < b`) is a `left_cancel semigroup`.",
    "kind": "def",
    "type": "left_cancel_semigroup α"
  },
  {
    "name": "list.lookup_all",
    "statement": "def list.lookup_all {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → list (β a)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → list (β a)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α)",
    "doc_string": "`lookup_all a l` is the list of all values in `l` corresponding to the key `a`.",
    "kind": "def",
    "type": "list (sigma β) → list (β a)"
  },
  {
    "name": "multiset.nodupkeys",
    "statement": "def multiset.nodupkeys {α : Type u} {β : α → Type v} (s : multiset (sigma β)) : Prop",
    "theorem": "{α : Type u} {β : α → Type v} (s : multiset (sigma β)) : Prop",
    "args": "{α : Type u} {β : α → Type v} (s : multiset (sigma β))",
    "doc_string": "`nodupkeys s` means that `s` has no duplicate keys.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "filter.Liminf",
    "statement": "def filter.Liminf {α : Type u_1} [conditionally_complete_lattice α] (f : filter α) : α",
    "theorem": "{α : Type u_1} [conditionally_complete_lattice α] (f : filter α) : α",
    "args": "{α : Type u_1} [conditionally_complete_lattice α] (f : filter α)",
    "doc_string": " The `Liminf` of a filter `f` is the supremum of the `a` such that, eventually for `f`, holds `x ≥ a`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "nat.of_digits_lt_base_pow_length",
    "statement": "theorem nat.of_digits_lt_base_pow_length {b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b) : nat.of_digits b l < b ^ l.length",
    "theorem": "{b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b) : nat.of_digits b l < b ^ l.length",
    "args": "{b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b)",
    "doc_string": "an n-digit number in base b is less than b^n if b ≥ 2",
    "kind": "theorem",
    "type": "nat.of_digits b l < b ^ l.length"
  },
  {
    "name": "CompHaus",
    "statement": "structure CompHaus  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The type of Compact Hausdorff topological spaces.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "subring.has_inf",
    "statement": "def subring.has_inf {R : Type u} [ring R] : has_inf (subring R)",
    "theorem": "{R : Type u} [ring R] : has_inf (subring R)",
    "args": "{R : Type u} [ring R]",
    "doc_string": "The inf of two subrings is their intersection.",
    "kind": "def",
    "type": "has_inf (subring R)"
  },
  {
    "name": "seq.omap",
    "statement": "def seq.omap {α : Type u} {β : Type v} {γ : Type w} (f : β → γ) : option (α × β) → option (α × γ)",
    "theorem": "{α : Type u} {β : Type v} {γ : Type w} (f : β → γ) : option (α × β) → option (α × γ)",
    "args": "{α : Type u} {β : Type v} {γ : Type w} (f : β → γ)",
    "doc_string": "Functorial action of the functor `option (α × _)`",
    "kind": "def",
    "type": "option (α × β) → option (α × γ)"
  },
  {
    "name": "continuous_monoid_hom.inl",
    "statement": "def continuous_monoid_hom.inl (A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A (A × B)",
    "theorem": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A (A × B)",
    "args": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by inclusion of the first factor.",
    "kind": "def",
    "type": "continuous_monoid_hom A (A × B)"
  },
  {
    "name": "complete_lattice.is_Sup_finite_compact",
    "statement": "def complete_lattice.is_Sup_finite_compact (α : Type u_1) [complete_lattice α] : Prop",
    "theorem": "(α : Type u_1) [complete_lattice α] : Prop",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": " A compactness property for a complete lattice is that any subset has a finite subset with the same `Sup`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.coprod_monad",
    "statement": "def category_theory.coprod_monad {C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproducts C] : category_theory.monad C",
    "theorem": "{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproducts C] : category_theory.monad C",
    "args": "{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_coproducts C]",
    "doc_string": "`X ⨿ -` has a monad structure. This is sometimes called the either monad.",
    "kind": "def",
    "type": "category_theory.monad C"
  },
  {
    "name": "unique.encodable",
    "statement": "def unique.encodable {α : Type u_1} [unique α] : encodable α",
    "theorem": "{α : Type u_1} [unique α] : encodable α",
    "args": "{α : Type u_1} [unique α]",
    "doc_string": "A type with unique element is encodable. This is not an instance to avoid diamonds.",
    "kind": "def",
    "type": "encodable α"
  },
  {
    "name": "ring_aut.group",
    "statement": "def ring_aut.group (R : Type u_1) [has_mul R] [has_add R] : group (ring_aut R)",
    "theorem": "(R : Type u_1) [has_mul R] [has_add R] : group (ring_aut R)",
    "args": "(R : Type u_1) [has_mul R] [has_add R]",
    "doc_string": "The group operation on automorphisms of a ring is defined by `λ g h, ring_equiv.trans h g`. This means that multiplication agrees with composition, `(g*h)(x) = g (h x)`.",
    "kind": "def",
    "type": "group (ring_aut R)"
  },
  {
    "name": "shift_31_left",
    "statement": "def shift_31_left  : ℕ",
    "theorem": " : ℕ",
    "args": "",
    "doc_string": " shift_31_left = 2^31; multiplying by it shifts the binary representation of a number left by 31 bits, dividing by it shifts it right by 31 bits",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "seq.of_list",
    "statement": "def seq.of_list {α : Type u} (l : list α) : seq α",
    "theorem": "{α : Type u} (l : list α) : seq α",
    "args": "{α : Type u} (l : list α)",
    "doc_string": "Embed a list as a sequence",
    "kind": "def",
    "type": "seq α"
  },
  {
    "name": "trunc",
    "statement": "def trunc (α : Sort u) : Sort u",
    "theorem": "(α : Sort u) : Sort u",
    "args": "(α : Sort u)",
    "doc_string": "`trunc α` is the quotient of `α` by the always-true relation. This  is related to the propositional truncation in HoTT, and is similar  in effect to `nonempty α`, but unlike `nonempty α`, `trunc α` is data,  so the VM representation is the same as `α`, and so this can be used to  maintain computability.",
    "kind": "def",
    "type": "Sort u"
  },
  {
    "name": "priestley_space",
    "statement": "structure priestley_space (α : Type u_2) [preorder α] [topological_space α] : Type",
    "theorem": "(α : Type u_2) [preorder α] [topological_space α] : Type",
    "args": "(α : Type u_2) [preorder α] [topological_space α]",
    "doc_string": " A Priestley space is an ordered topological space such that any two distinct points can be separated by a clopen upper set. Compactness is often assumed, but we do not include it here.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "orthonormal_basis",
    "statement": "structure orthonormal_basis (ι : Type u_1) (𝕜 : Type u_3) [is_R_or_C 𝕜] (E : Type u_4) [inner_product_space 𝕜 E] [fintype ι] : Type (max u_1 u_3 u_4)",
    "theorem": "(ι : Type u_1) (𝕜 : Type u_3) [is_R_or_C 𝕜] (E : Type u_4) [inner_product_space 𝕜 E] [fintype ι] : Type (max u_1 u_3 u_4)",
    "args": "(ι : Type u_1) (𝕜 : Type u_3) [is_R_or_C 𝕜] (E : Type u_4) [inner_product_space 𝕜 E] [fintype ι]",
    "doc_string": " An orthonormal basis on E is an identification of `E` with its dimensional-matching `euclidean_space 𝕜 ι`.",
    "kind": "structure",
    "type": "Type (max u_1 u_3 u_4)"
  },
  {
    "name": "linarith.comp",
    "statement": "structure linarith.comp  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The main datatype for FM elimination. Variables are represented by natural numbers, each of which has an integer coefficient. Index 0 is reserved for constants, i.e. `coeffs.find 0` is the coefficient of 1. The represented term is `coeffs.sum (λ ⟨k, v⟩, v * Var[k])`. str determines the strength of the comparison -- is it < 0, ≤ 0, or = 0?",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "parser.many",
    "statement": "def parser.many {α : Type} (p : parser α) : parser (list α)",
    "theorem": "{α : Type} (p : parser α) : parser (list α)",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "Matches zero or more occurrences of `p`.",
    "kind": "def",
    "type": "parser (list α)"
  },
  {
    "name": "group_filter_basis.topology",
    "statement": "def group_filter_basis.topology {G : Type u} [group G] (B : group_filter_basis G) : topological_space G",
    "theorem": "{G : Type u} [group G] (B : group_filter_basis G) : topological_space G",
    "args": "{G : Type u} [group G] (B : group_filter_basis G)",
    "doc_string": "The topological space structure coming from a group filter basis.",
    "kind": "def",
    "type": "topological_space G"
  },
  {
    "name": "add_semiconj_by.conj_mk",
    "statement": "theorem add_semiconj_by.conj_mk {G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)",
    "theorem": "{G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)",
    "args": "{G : Type u} [add_group G] (a x : G)",
    "doc_string": "`a` semiconjugates `x` to `a + x + -a`.",
    "kind": "theorem",
    "type": "add_semiconj_by a x (a + x + -a)"
  },
  {
    "name": "is_subfield",
    "statement": "structure is_subfield {F : Type u_1} [field F] (S : set F) : Prop",
    "theorem": "{F : Type u_1} [field F] (S : set F) : Prop",
    "args": "{F : Type u_1} [field F] (S : set F)",
    "doc_string": " `is_subfield (S : set F)` is the predicate saying that a given subset of a field is the set underlying a subfield. This structure is deprecated; use the bundled variant `subfield F` to model subfields of a field.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "has_measurable_inf₂",
    "statement": "structure has_measurable_inf₂ (M : Type u_1) [measurable_space M] [has_inf M] : Prop",
    "theorem": "(M : Type u_1) [measurable_space M] [has_inf M] : Prop",
    "args": "(M : Type u_1) [measurable_space M] [has_inf M]",
    "doc_string": " We say that a type `has_measurable_inf₂` if `uncurry (⊔)` is a measurable functions. For a typeclass assuming measurability of `((⊔) c)` and `(⊔ c)` see `has_measurable_inf`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "primitive_roots",
    "statement": "def primitive_roots (k : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : finset R",
    "theorem": "(k : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : finset R",
    "args": "(k : ℕ) (R : Type u_1) [comm_ring R] [is_domain R]",
    "doc_string": " `primitive_roots k R` is the finset of primitive `k`-th roots of unity in the integral domain `R`.",
    "kind": "def",
    "type": "finset R"
  },
  {
    "name": "rack.to_envel_group.map_aux",
    "statement": "def rack.to_envel_group.map_aux {R : Type u_1} [rack R] {G : Type u_2} [group G] (f : shelf_hom R (quandle.conj G)) : rack.pre_envel_group R → G",
    "theorem": "{R : Type u_1} [rack R] {G : Type u_2} [group G] (f : shelf_hom R (quandle.conj G)) : rack.pre_envel_group R → G",
    "args": "{R : Type u_1} [rack R] {G : Type u_2} [group G] (f : shelf_hom R (quandle.conj G))",
    "doc_string": "The preliminary definition of the induced map from the enveloping group. See `to_envel_group.map`.",
    "kind": "def",
    "type": "rack.pre_envel_group R → G"
  },
  {
    "name": "filter.is_bounded",
    "statement": "def filter.is_bounded {α : Type u_1} (r : α → α → Prop) (f : filter α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (f : filter α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (f : filter α)",
    "doc_string": " `f.is_bounded (≺)`: the filter `f` is eventually bounded w.r.t. the relation `≺`, i.e. eventually, it is bounded by some uniform bound. `r` will be usually instantiated with `≤` or `≥`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "tactic.ring_exp.ex_info",
    "statement": "structure tactic.ring_exp.ex_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Each `ex` stores information for its normalization proof.  The `orig` expression is the expression that was passed to `eval`.  The `pretty` expression is the normalised form that the `ex` represents. (I didn't call this something like `norm`, because there are already too many things called `norm` in mathematics!)  The field `proof` contains an optional proof term of type `%%orig = %%pretty`. The value `none` for the proof indicates that everything reduces to reflexivity. (Which saves space in quite a lot of cases.)",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "algebraic_geometry.SheafedSpace",
    "statement": "structure algebraic_geometry.SheafedSpace (C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : Type (max u (v+1))",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : Type (max u (v+1))",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C]",
    "doc_string": "A `SheafedSpace C` is a topological space equipped with a sheaf of `C`s.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "has_measurable_inf",
    "statement": "structure has_measurable_inf (M : Type u_1) [measurable_space M] [has_inf M] : Prop",
    "theorem": "(M : Type u_1) [measurable_space M] [has_inf M] : Prop",
    "args": "(M : Type u_1) [measurable_space M] [has_inf M]",
    "doc_string": " We say that a type `has_measurable_inf` if `((⊓) c)` and `(⊓ c)` are measurable functions. For a typeclass assuming measurability of `uncurry (⊓)` see `has_measurable_inf₂`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordnode.balance",
    "statement": "def ordnode.balance {α : Type u} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "theorem": "{α : Type u} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "args": "{α : Type u} (l : ordnode α) (x : α) (r : ordnode α)",
    "doc_string": " **Internal use only**  O(1). Rebalance a tree which was previously balanced but has had one side change by at most 1.",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "rel_iso.coe_fn_injective",
    "statement": "theorem rel_iso.coe_fn_injective {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}",
    "doc_string": " The map `coe_fn : (r ≃r s) → (α → β)` is injective. Lean fails to parse `function.injective (λ e : r ≃r s, (e : α → β))`, so we use a trick to say the same.",
    "kind": "theorem",
    "type": "function.injective coe_fn"
  },
  {
    "name": "bitvec.slt",
    "statement": "def bitvec.slt {n : ℕ} (x y : bitvec n) : Prop",
    "theorem": "{n : ℕ} (x y : bitvec n) : Prop",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "signed less-than proposition",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "multiset.gcd",
    "statement": "def multiset.gcd {α : Type u_1} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : multiset α) : α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : multiset α) : α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : multiset α)",
    "doc_string": "Greatest common divisor of a multiset",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "category_theory.symmetric_category",
    "statement": "structure category_theory.symmetric_category (C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "A symmetric monoidal category is a braided monoidal category for which the braiding is symmetric.  See <https://stacks.math.columbia.edu/tag/0FFW>.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "list.erasep",
    "statement": "def list.erasep {α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → list α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → list α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p]",
    "doc_string": "`erasep p l` removes the first element of `l` satisfying the predicate `p`.",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "ordnode.balance_r",
    "statement": "def ordnode.balance_r {α : Type u} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "theorem": "{α : Type u} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "args": "{α : Type u} (l : ordnode α) (x : α) (r : ordnode α)",
    "doc_string": " **Internal use only**  O(1). Rebalance a tree which was previously balanced but has had its right side grow by 1, or its left side shrink by 1.",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "tactic.explode.thm",
    "statement": "inductive tactic.explode.thm  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A type to distinguish introduction or elimination rules represented as strings from theorems referred to by their names.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "list.is_infix",
    "statement": "def list.is_infix {α : Type u_1} (l₁ l₂ : list α) : Prop",
    "theorem": "{α : Type u_1} (l₁ l₂ : list α) : Prop",
    "args": "{α : Type u_1} (l₁ l₂ : list α)",
    "doc_string": "`is_infix l₁ l₂`, or `l₁ <:+: l₂`, means that `l₁` is a contiguous  substring of `l₂`, that is, `l₂` has the form `s ++ l₁ ++ t` for some `s, t`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "has_edist",
    "statement": "structure has_edist (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "`has_edist α` means that `α` is equipped with an extended distance.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "max_default",
    "statement": "def max_default {α : Type u} [has_le α] [decidable_rel has_le.le] (a b : α) : α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (a b : α) : α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (a b : α)",
    "doc_string": "Default definition of `max`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "add_left_cancel_monoid",
    "statement": "structure add_left_cancel_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": " An additive monoid in which addition is left-cancellative. Main examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero is useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "pSet.mem",
    "statement": "def pSet.mem  : pSet → pSet → Prop",
    "theorem": " : pSet → pSet → Prop",
    "args": "",
    "doc_string": "`x ∈ y` as pre-sets if `x` is extensionally equivalent to a member of the family `y`.",
    "kind": "def",
    "type": "pSet → pSet → Prop"
  },
  {
    "name": "local_context",
    "statement": "constant local_context  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " A local context is a list of local constant declarations. Each metavariable in a metavariable context holds a local_context to declare which locals the metavariable is allowed to depend on.",
    "kind": "constant",
    "type": "Type"
  },
  {
    "name": "set.has_vadd",
    "statement": "def set.has_vadd {α : Type u_2} {β : Type u_3} [has_vadd α β] : has_vadd (set α) (set β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [has_vadd α β] : has_vadd (set α) (set β)",
    "args": "{α : Type u_2} {β : Type u_3} [has_vadd α β]",
    "doc_string": "The pointwise scalar addition of sets `s +ᵥ t` is defined as `{x +ᵥ y | x ∈ s, y ∈ t}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_vadd (set α) (set β)"
  },
  {
    "name": "turing.to_partrec.code.zero",
    "statement": "def turing.to_partrec.code.zero  : turing.to_partrec.code",
    "theorem": " : turing.to_partrec.code",
    "args": "",
    "doc_string": "`zero` is the constant zero function: `zero v = [0]`.",
    "kind": "def",
    "type": "turing.to_partrec.code"
  },
  {
    "name": "finite_dimensional.finrank_zero_of_subsingleton",
    "statement": "theorem finite_dimensional.finrank_zero_of_subsingleton {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V]",
    "doc_string": "A finite dimensional space that is a subsingleton has zero `finrank`.",
    "kind": "theorem",
    "type": "finite_dimensional.finrank K V = 0"
  },
  {
    "name": "subgroup.is_complement",
    "statement": "def subgroup.is_complement {G : Type u_1} [group G] (S T : set G) : Prop",
    "theorem": "{G : Type u_1} [group G] (S T : set G) : Prop",
    "args": "{G : Type u_1} [group G] (S T : set G)",
    "doc_string": "`S` and `T` are complements if `(*) : S × T → G` is a bijection.  This notion generalizes left transversals, right transversals, and complementary subgroups.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nonote.cmp",
    "statement": "def nonote.cmp (a b : nonote) : ordering",
    "theorem": "(a b : nonote) : ordering",
    "args": "(a b : nonote)",
    "doc_string": "Compare ordinal notations",
    "kind": "def",
    "type": "ordering"
  },
  {
    "name": "cardinal.is_inaccessible",
    "statement": "def cardinal.is_inaccessible (c : cardinal) : Prop",
    "theorem": "(c : cardinal) : Prop",
    "args": "(c : cardinal)",
    "doc_string": "A cardinal is inaccessible if it is an uncountable regular strong limit cardinal.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.partrec.code.evaln_prim",
    "statement": "theorem nat.partrec.code.evaln_prim  : primrec (λ (a : (ℕ × nat.partrec.code) × ℕ), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)",
    "theorem": " : primrec (λ (a : (ℕ × nat.partrec.code) × ℕ), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)",
    "args": "",
    "doc_string": "The `nat.partrec.code.evaln` function is primitive recursive.",
    "kind": "theorem",
    "type": "primrec (λ (a : (ℕ × nat.partrec.code) × ℕ), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)"
  },
  {
    "name": "galois_connection.lift_order_bot",
    "statement": "def galois_connection.lift_order_bot {α : Type u_1} {β : Type u_2} [preorder α] [order_bot α] [partial_order β] {l : α → β} {u : β → α} (gc : galois_connection l u) : order_bot β",
    "theorem": "{α : Type u_1} {β : Type u_2} [preorder α] [order_bot α] [partial_order β] {l : α → β} {u : β → α} (gc : galois_connection l u) : order_bot β",
    "args": "{α : Type u_1} {β : Type u_2} [preorder α] [order_bot α] [partial_order β] {l : α → β} {u : β → α} (gc : galois_connection l u)",
    "doc_string": "Lift the bottom along a Galois connection",
    "kind": "def",
    "type": "order_bot β"
  },
  {
    "name": "interactive.types.tac_rbp",
    "statement": "def interactive.types.tac_rbp  : ℕ",
    "theorem": " : ℕ",
    "args": "",
    "doc_string": "The right-binding power 2 will terminate expressions by    '<|>' (rbp 2), ';' (rbp 1), and ',' (rbp 0). It should be used for any (potentially)    trailing expression parameters.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "nim",
    "statement": "def nim  : ordinal → pgame",
    "theorem": " : ordinal → pgame",
    "args": "",
    "doc_string": "The definition of single-heap nim, which can be viewed as a pile of stones where each player can  take a positive number of stones from it on their turn.",
    "kind": "def",
    "type": "ordinal → pgame"
  },
  {
    "name": "comm_group.is_nilpotent",
    "statement": "def comm_group.is_nilpotent {G : Type u_1} [comm_group G] : group.is_nilpotent G",
    "theorem": "{G : Type u_1} [comm_group G] : group.is_nilpotent G",
    "args": "{G : Type u_1} [comm_group G]",
    "doc_string": "Abelian groups are nilpotent",
    "kind": "def",
    "type": "group.is_nilpotent G"
  },
  {
    "name": "matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix",
    "statement": "theorem matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : ↑↑↑g = ↑g",
    "theorem": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : ↑↑↑g = ↑g",
    "args": "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R)",
    "doc_string": " Coercing a `special_linear_group` via `GL_pos` and `GL` is the same as coercing striaght to a matrix.",
    "kind": "theorem",
    "type": "↑↑↑g = ↑g"
  },
  {
    "name": "rand",
    "statement": "def rand (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A monad to generate random objects using the generator type `std_gen`",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "upper_central_series",
    "statement": "def upper_central_series (G : Type u_1) [group G] (n : ℕ) : subgroup G",
    "theorem": "(G : Type u_1) [group G] (n : ℕ) : subgroup G",
    "args": "(G : Type u_1) [group G] (n : ℕ)",
    "doc_string": "`upper_central_series G n` is the `n`th term in the upper central series of `G`.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "is_unit.invertible",
    "statement": "def is_unit.invertible {α : Type u} [monoid α] {a : α} (h : is_unit a) : invertible a",
    "theorem": "{α : Type u} [monoid α] {a : α} (h : is_unit a) : invertible a",
    "args": "{α : Type u} [monoid α] {a : α} (h : is_unit a)",
    "doc_string": " Convert `is_unit` to `invertible` using `classical.choice`.  Prefer `casesI h.nonempty_invertible` over `letI := h.invertible` if you want to avoid choice.",
    "kind": "def",
    "type": "invertible a"
  },
  {
    "name": "equiv.perm.support",
    "statement": "def equiv.perm.support {α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) : finset α",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) : finset α",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α)",
    "doc_string": "The `finset` of nonfixed points of a permutation.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "tree.map",
    "statement": "def tree.map {α : Type u} {β : Type u_1} (f : α → β) : tree α → tree β",
    "theorem": "{α : Type u} {β : Type u_1} (f : α → β) : tree α → tree β",
    "args": "{α : Type u} {β : Type u_1} (f : α → β)",
    "doc_string": " Apply a function to each value in the tree.  This is the `map` function for the `tree` functor. TODO: implement `traversable tree`.",
    "kind": "def",
    "type": "tree α → tree β"
  },
  {
    "name": "right.add_pos'",
    "statement": "theorem right.add_pos' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos'`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "local_homeomorph",
    "statement": "structure local_homeomorph (α : Type u_5) (β : Type u_6) [topological_space α] [topological_space β] : Type (max u_5 u_6)",
    "theorem": "(α : Type u_5) (β : Type u_6) [topological_space α] [topological_space β] : Type (max u_5 u_6)",
    "args": "(α : Type u_5) (β : Type u_6) [topological_space α] [topological_space β]",
    "doc_string": "local homeomorphisms, defined on open subsets of the space",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "subfield.to_add_subgroup",
    "statement": "def subfield.to_add_subgroup {K : Type u} [field K] (s : subfield K) : add_subgroup K",
    "theorem": "{K : Type u} [field K] (s : subfield K) : add_subgroup K",
    "args": "{K : Type u} [field K] (s : subfield K)",
    "doc_string": "The underlying `add_subgroup` of a subfield.",
    "kind": "def",
    "type": "add_subgroup K"
  },
  {
    "name": "lie_algebra.g₂",
    "statement": "def lie_algebra.g₂ (R : Type u) [comm_ring R] : Type u",
    "theorem": "(R : Type u) [comm_ring R] : Type u",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "The exceptional split Lie algebra of type g₂.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "set.definable",
    "statement": "def set.definable {M : Type w} (A : set M) (L : first_order.language) [L.Structure M] {α : Type u_1} (s : set (α → M)) : Prop",
    "theorem": "{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] {α : Type u_1} (s : set (α → M)) : Prop",
    "args": "{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] {α : Type u_1} (s : set (α → M))",
    "doc_string": "A subset of a finite Cartesian product of a structure is definable over a set `A` when  membership in the set is given by a first-order formula with parameters from `A`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.pairwise.pw_filter",
    "statement": "theorem list.pairwise.pw_filter {α : Type u_1} {R : α → α → Prop} [decidable_rel R] {l : list α} : list.pairwise R l → list.pw_filter R l = l",
    "theorem": "{α : Type u_1} {R : α → α → Prop} [decidable_rel R] {l : list α} : list.pairwise R l → list.pw_filter R l = l",
    "args": "{α : Type u_1} {R : α → α → Prop} [decidable_rel R] {l : list α}",
    "doc_string": "**Alias** of the reverse direction of list.pw_filter_eq_self`.",
    "kind": "theorem",
    "type": "list.pairwise R l → list.pw_filter R l = l"
  },
  {
    "name": "list.comp_map",
    "statement": "theorem list.comp_map {α : Type u} {β : Type v} {γ : Type w} (h : β → γ) (g : α → β) (l : list α) : list.map (h ∘ g) l = list.map h (list.map g l)",
    "theorem": "{α : Type u} {β : Type v} {γ : Type w} (h : β → γ) (g : α → β) (l : list α) : list.map (h ∘ g) l = list.map h (list.map g l)",
    "args": "{α : Type u} {β : Type v} {γ : Type w} (h : β → γ) (g : α → β) (l : list α)",
    "doc_string": "A single `list.map` of a composition of functions is equal to composing a `list.map` with another `list.map`, fully applied. This is the reverse direction of `list.map_map`.",
    "kind": "theorem",
    "type": "list.map (h ∘ g) l = list.map h (list.map g l)"
  },
  {
    "name": "orientation",
    "statement": "def orientation (R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (ι : Type u_4) [decidable_eq ι] : Type (max u_2 u_1 u_4)",
    "theorem": "(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (ι : Type u_4) [decidable_eq ι] : Type (max u_2 u_1 u_4)",
    "args": "(R : Type u_1) [ordered_comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] (ι : Type u_4) [decidable_eq ι]",
    "doc_string": " An orientation of a module, intended to be used when `ι` is a `fintype` with the same cardinality as a basis.",
    "kind": "def",
    "type": "Type (max u_2 u_1 u_4)"
  },
  {
    "name": "surreal.equiv",
    "statement": "def surreal.equiv (x y : {x // x.numeric}) : Prop",
    "theorem": "(x y : {x // x.numeric}) : Prop",
    "args": "(x y : {x // x.numeric})",
    "doc_string": "The equivalence on numeric pre-games.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_colimits_of_shape",
    "statement": "structure category_theory.limits.has_colimits_of_shape (J : Type u₁) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(J : Type u₁) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop",
    "args": "(J : Type u₁) [category_theory.category J] (C : Type u) [category_theory.category C]",
    "doc_string": "`C` has colimits of shape `J` if there exists a colimit for every functor `F : J ⥤ C`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "pfunctor.M_intl",
    "statement": "structure pfunctor.M_intl (F : pfunctor) : Type u",
    "theorem": "(F : pfunctor) : Type u",
    "args": "(F : pfunctor)",
    "doc_string": " Internal definition for `M`. It is needed to avoid name clashes between `M.mk` and `M.cases_on` and the declarations generated for the structure",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "continuous_on",
    "statement": "def continuous_on {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (s : set α)",
    "doc_string": " A function between topological spaces is continuous on a subset `s` when it's continuous at every point of `s` within `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ring_invo",
    "statement": "structure ring_invo (R : Type u_1) [semiring R] : Type u_1",
    "theorem": "(R : Type u_1) [semiring R] : Type u_1",
    "args": "(R : Type u_1) [semiring R]",
    "doc_string": "A ring involution",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "dual_number.eps",
    "statement": "def dual_number.eps {R : Type u_1} [has_zero R] [has_one R] : dual_number R",
    "theorem": "{R : Type u_1} [has_zero R] [has_one R] : dual_number R",
    "args": "{R : Type u_1} [has_zero R] [has_one R]",
    "doc_string": "The unit element $ε$ that squares to zero.",
    "kind": "def",
    "type": "dual_number R"
  },
  {
    "name": "monoid_hom_class",
    "statement": "structure monoid_hom_class (F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_11 u_9)",
    "theorem": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_one_class M] [mul_one_class N] : Type (max u_10 u_11 u_9)",
    "args": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [mul_one_class M] [mul_one_class N]",
    "doc_string": " `monoid_hom_class F M N` states that `F` is a type of `monoid`-preserving homomorphisms. You should also extend this typeclass when you extend `monoid_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_11 u_9)"
  },
  {
    "name": "zero_hom.comp",
    "statement": "def zero_hom.comp {M : Type u_3} {N : Type u_4} {P : Type u_5} [has_zero M] [has_zero N] [has_zero P] (hnp : zero_hom N P) (hmn : zero_hom M N) : zero_hom M P",
    "theorem": "{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_zero M] [has_zero N] [has_zero P] (hnp : zero_hom N P) (hmn : zero_hom M N) : zero_hom M P",
    "args": "{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_zero M] [has_zero N] [has_zero P] (hnp : zero_hom N P) (hmn : zero_hom M N)",
    "doc_string": "Composition of `zero_hom`s as a `zero_hom`.",
    "kind": "def",
    "type": "zero_hom M P"
  },
  {
    "name": "lazy_list.mem",
    "statement": "def lazy_list.mem {α : Type u_1} (x : α) : lazy_list α → Prop",
    "theorem": "{α : Type u_1} (x : α) : lazy_list α → Prop",
    "args": "{α : Type u_1} (x : α)",
    "doc_string": "Membership in lazy lists",
    "kind": "def",
    "type": "lazy_list α → Prop"
  },
  {
    "name": "no_zero_divisors",
    "statement": "structure no_zero_divisors (M₀ : Type u_4) [has_mul M₀] [has_zero M₀] : Prop",
    "theorem": "(M₀ : Type u_4) [has_mul M₀] [has_zero M₀] : Prop",
    "args": "(M₀ : Type u_4) [has_mul M₀] [has_zero M₀]",
    "doc_string": " Predicate typeclass for expressing that `a * b = 0` implies `a = 0` or `b = 0` for all `a` and `b` of type `G₀`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "add_monoid.exponent",
    "statement": "def add_monoid.exponent (G : Type u) [add_monoid G] : ℕ",
    "theorem": "(G : Type u) [add_monoid G] : ℕ",
    "args": "(G : Type u) [add_monoid G]",
    "doc_string": "The exponent of an additive group is the smallest positive integer `n` such that   `n • g = 0` for all `g ∈ G` if it exists, otherwise it is zero by convention.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "semiquot.is_pure",
    "statement": "def semiquot.is_pure {α : Type u_1} (q : semiquot α) : Prop",
    "theorem": "{α : Type u_1} (q : semiquot α) : Prop",
    "args": "{α : Type u_1} (q : semiquot α)",
    "doc_string": "Assert that a `semiquot` contains only one possible value.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "conjugates_of",
    "statement": "def conjugates_of {α : Type u} [monoid α] (a : α) : set α",
    "theorem": "{α : Type u} [monoid α] (a : α) : set α",
    "args": "{α : Type u} [monoid α] (a : α)",
    "doc_string": "Given an element `a`, `conjugates a` is the set of conjugates.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "add_action.fixed_points",
    "statement": "def add_action.fixed_points (α : Type u) (β : Type v) [add_monoid α] [add_action α β] : set β",
    "theorem": "(α : Type u) (β : Type v) [add_monoid α] [add_action α β] : set β",
    "args": "(α : Type u) (β : Type v) [add_monoid α] [add_action α β]",
    "doc_string": "The set of elements fixed under the whole action.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "pred_order",
    "statement": "structure pred_order (α : Type u_2) [preorder α] : Type u_2",
    "theorem": "(α : Type u_2) [preorder α] : Type u_2",
    "args": "(α : Type u_2) [preorder α]",
    "doc_string": "Order equipped with a sensible predecessor function.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "is_atom.unique_finpartition",
    "statement": "def is_atom.unique_finpartition {α : Type u_1} [lattice α] [order_bot α] {a : α} (ha : is_atom a) : unique (finpartition a)",
    "theorem": "{α : Type u_1} [lattice α] [order_bot α] {a : α} (ha : is_atom a) : unique (finpartition a)",
    "args": "{α : Type u_1} [lattice α] [order_bot α] {a : α} (ha : is_atom a)",
    "doc_string": "There's a unique partition of an atom.",
    "kind": "def",
    "type": "unique (finpartition a)"
  },
  {
    "name": "borel_space.opens_measurable",
    "statement": "def borel_space.opens_measurable {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] : opens_measurable_space α",
    "theorem": "{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] : opens_measurable_space α",
    "args": "{α : Type u_1} [topological_space α] [measurable_space α] [borel_space α]",
    "doc_string": "In a `borel_space` all open sets are measurable.",
    "kind": "def",
    "type": "opens_measurable_space α"
  },
  {
    "name": "topological_space.compacts",
    "statement": "structure topological_space.compacts (α : Type u_3) [topological_space α] : Type u_3",
    "theorem": "(α : Type u_3) [topological_space α] : Type u_3",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": "The type of compact sets of a topological space.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "multiset.sum",
    "statement": "def multiset.sum {α : Type u_2} [add_comm_monoid α] : multiset α → α",
    "theorem": "{α : Type u_2} [add_comm_monoid α] : multiset α → α",
    "args": "{α : Type u_2} [add_comm_monoid α]",
    "doc_string": "Sum of a multiset given a commutative additive monoid structure on `α`.   `sum {a, b, c} = a + b + c`",
    "kind": "def",
    "type": "multiset α → α"
  },
  {
    "name": "set.Iic",
    "statement": "def set.Iic {α : Type u_1} [preorder α] (b : α) : set α",
    "theorem": "{α : Type u_1} [preorder α] (b : α) : set α",
    "args": "{α : Type u_1} [preorder α] (b : α)",
    "doc_string": "Left-infinite right-closed interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "category_theory.exact_inl_snd",
    "statement": "theorem category_theory.exact_inl_snd {𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd",
    "theorem": "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd",
    "args": "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜)",
    "doc_string": "The sequence `A ⟶ A ⊞ B ⟶ B` is exact.",
    "kind": "theorem",
    "type": "category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd"
  },
  {
    "name": "is_solvable_by_rad",
    "statement": "inductive is_solvable_by_rad (F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] : E → Prop",
    "theorem": "(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] : E → Prop",
    "args": "(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E]",
    "doc_string": "Inductive definition of solvable by radicals",
    "kind": "inductive",
    "type": "E → Prop"
  },
  {
    "name": "finset.up_shadow_monotone",
    "statement": "theorem finset.up_shadow_monotone {α : Type u_1} [decidable_eq α] [fintype α] : monotone finset.up_shadow",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] : monotone finset.up_shadow",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α]",
    "doc_string": "The upper shadow is monotone.",
    "kind": "theorem",
    "type": "monotone finset.up_shadow"
  },
  {
    "name": "neg_one_mul",
    "statement": "theorem neg_one_mul {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a",
    "theorem": "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a",
    "args": "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α)",
    "doc_string": "The additive inverse of one multiplied by an element of a ring is the element's additive  inverse.",
    "kind": "theorem",
    "type": "(-1) * a = -a"
  },
  {
    "name": "buffer.map",
    "statement": "def buffer.map {α : Type u} {β : Type w} : buffer α → (α → β) → buffer β",
    "theorem": "{α : Type u} {β : Type w} : buffer α → (α → β) → buffer β",
    "args": "{α : Type u} {β : Type w}",
    "doc_string": "Map a function over the buffer.",
    "kind": "def",
    "type": "buffer α → (α → β) → buffer β"
  },
  {
    "name": "Top.presheaf.is_sheaf_pairwise_intersections",
    "statement": "def Top.presheaf.is_sheaf_pairwise_intersections {X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop",
    "theorem": "{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop",
    "args": "{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X)",
    "doc_string": "An alternative formulation of the sheaf condition (which we prove equivalent to the usual one below as `is_sheaf_iff_is_sheaf_pairwise_intersections`).  A presheaf is a sheaf if `F` sends the cone `(pairwise.cocone U).op` to a limit cone. (Recall `pairwise.cocone U` has cone point `supr U`, mapping down to the `U i` and the `U i ⊓ U j`.)",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lower_bounds",
    "statement": "def lower_bounds {α : Type u} [preorder α] (s : set α) : set α",
    "theorem": "{α : Type u} [preorder α] (s : set α) : set α",
    "args": "{α : Type u} [preorder α] (s : set α)",
    "doc_string": "The set of lower bounds of a set.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "zero_dvd_iff",
    "statement": "theorem zero_dvd_iff {α : Type u_1} [semigroup_with_zero α] {a : α} : 0 ∣ a ↔ a = 0",
    "theorem": "{α : Type u_1} [semigroup_with_zero α] {a : α} : 0 ∣ a ↔ a = 0",
    "args": "{α : Type u_1} [semigroup_with_zero α] {a : α}",
    "doc_string": "Given an element `a` of a commutative semigroup with zero, there exists another element whose    product with zero equals `a` iff `a` equals zero.",
    "kind": "theorem",
    "type": "0 ∣ a ↔ a = 0"
  },
  {
    "name": "SemiNormedGroup",
    "statement": "def SemiNormedGroup  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of seminormed abelian groups and bounded group homomorphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "ratfunc.num_denom",
    "statement": "def ratfunc.num_denom {K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K × polynomial K",
    "theorem": "{K : Type u} [hfield : field K] (x : ratfunc K) : polynomial K × polynomial K",
    "args": "{K : Type u} [hfield : field K] (x : ratfunc K)",
    "doc_string": " `ratfunc.num_denom` are numerator and denominator of a rational function over a field, normalized such that the denominator is monic.",
    "kind": "def",
    "type": "polynomial K × polynomial K"
  },
  {
    "name": "pgame.impartial",
    "statement": "structure pgame.impartial (G : pgame) : Prop",
    "theorem": "(G : pgame) : Prop",
    "args": "(G : pgame)",
    "doc_string": "A typeclass on impartial games.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "widget_override.interactive_expression.sf",
    "statement": "inductive widget_override.interactive_expression.sf  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "eformat but without any of the formatting stuff like highlighting, groups etc.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "unchecked_cast'",
    "statement": "def unchecked_cast' {α : Sort u} {β : Sort v} (a : α) : β",
    "theorem": "{α : Sort u} {β : Sort v} (a : α) : β",
    "args": "{α : Sort u} {β : Sort v} (a : α)",
    "doc_string": "`unchecked_cast' a : β` performs an unchecked cast of `(a : α)` to `β`.  Unlike `unchecked_cast`, it can cast across universes. The VM implementation is guaranteed to be the identity.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "measure_theory.strongly_measurable.is_separable_range",
    "statement": "theorem measure_theory.strongly_measurable.is_separable_range {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f)",
    "doc_string": "The range of a strongly measurable function is separable.",
    "kind": "theorem",
    "type": "topological_space.is_separable (set.range f)"
  },
  {
    "name": "invertible_inv",
    "statement": "def invertible_inv {α : Type u} [group_with_zero α] {a : α} [invertible a] : invertible a⁻¹",
    "theorem": "{α : Type u} [group_with_zero α] {a : α} [invertible a] : invertible a⁻¹",
    "args": "{α : Type u} [group_with_zero α] {a : α} [invertible a]",
    "doc_string": "`a` is the inverse of `a⁻¹`",
    "kind": "def",
    "type": "invertible a⁻¹"
  },
  {
    "name": "commute",
    "statement": "def commute {S : Type u_1} [has_mul S] (a b : S) : Prop",
    "theorem": "{S : Type u_1} [has_mul S] (a b : S) : Prop",
    "args": "{S : Type u_1} [has_mul S] (a b : S)",
    "doc_string": "Two elements commute if `a * b = b * a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "matrix.dot_product",
    "statement": "def matrix.dot_product {m : Type u_2} {α : Type v} [fintype m] [has_mul α] [add_comm_monoid α] (v w : m → α) : α",
    "theorem": "{m : Type u_2} {α : Type v} [fintype m] [has_mul α] [add_comm_monoid α] (v w : m → α) : α",
    "args": "{m : Type u_2} {α : Type v} [fintype m] [has_mul α] [add_comm_monoid α] (v w : m → α)",
    "doc_string": "`dot_product v w` is the sum of the entrywise products `v i * w i`",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "wseq.join",
    "statement": "def wseq.join {α : Type u} (S : wseq (wseq α)) : wseq α",
    "theorem": "{α : Type u} (S : wseq (wseq α)) : wseq α",
    "args": "{α : Type u} (S : wseq (wseq α))",
    "doc_string": "Flatten a sequence of weak sequences. (Note that this allows  empty sequences, unlike `seq.join`.)",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "affine_subspace.direction",
    "statement": "def affine_subspace.direction {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : affine_subspace k P) : submodule k V",
    "theorem": "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : affine_subspace k P) : submodule k V",
    "args": "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : affine_subspace k P)",
    "doc_string": " The direction of an affine subspace is the submodule spanned by the pairwise differences of points.  (Except in the case of an empty affine subspace, where the direction is the zero submodule, every vector in the direction is the difference of two points in the affine subspace.)",
    "kind": "def",
    "type": "submodule k V"
  },
  {
    "name": "lt_add_of_neg_add_lt_left",
    "statement": "theorem lt_add_of_neg_add_lt_left {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of lt_mul_of_inv_mul_lt`.",
    "kind": "theorem",
    "type": "-b + a < c → a < b + c"
  },
  {
    "name": "zero_lt.right.mul_nonneg",
    "statement": "theorem zero_lt.right.mul_nonneg {α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "0 ≤ a * b"
  },
  {
    "name": "topological_fiber_bundle_core.total_space",
    "statement": "def topological_fiber_bundle_core.total_space {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : Type (max u_2 u_3)",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : Type (max u_2 u_3)",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F)",
    "doc_string": " The total space of the topological fiber bundle, as a convenience function for dot notation. It is by definition equal to `bundle.total_space Z.fiber`, a.k.a. `Σ x, Z.fiber x` but with a different name for typeclass inference.",
    "kind": "def",
    "type": "Type (max u_2 u_3)"
  },
  {
    "name": "prime",
    "statement": "def prime {α : Type u_1} [comm_monoid_with_zero α] (p : α) : Prop",
    "theorem": "{α : Type u_1} [comm_monoid_with_zero α] (p : α) : Prop",
    "args": "{α : Type u_1} [comm_monoid_with_zero α] (p : α)",
    "doc_string": "prime element of a `comm_monoid_with_zero`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "sum.swap",
    "statement": "def sum.swap {α : Type u} {β : Type v} : α ⊕ β → β ⊕ α",
    "theorem": "{α : Type u} {β : Type v} : α ⊕ β → β ⊕ α",
    "args": "{α : Type u} {β : Type v}",
    "doc_string": "Swap the factors of a sum type",
    "kind": "def",
    "type": "α ⊕ β → β ⊕ α"
  },
  {
    "name": "non_zero_divisors",
    "statement": "def non_zero_divisors (R : Type u_1) [monoid_with_zero R] : submonoid R",
    "theorem": "(R : Type u_1) [monoid_with_zero R] : submonoid R",
    "args": "(R : Type u_1) [monoid_with_zero R]",
    "doc_string": "The submonoid of non-zero-divisors of a `monoid_with_zero` `R`.",
    "kind": "def",
    "type": "submonoid R"
  },
  {
    "name": "polish_space",
    "statement": "structure polish_space (α : Type u_3) [h : topological_space α] : Prop",
    "theorem": "(α : Type u_3) [h : topological_space α] : Prop",
    "args": "(α : Type u_3) [h : topological_space α]",
    "doc_string": " A Polish space is a topological space with second countable topology, that can be endowed with a metric for which it is complete. We register an instance from complete second countable metric space to polish space, and not the other way around as this is the most common use case.  To endow a Polish space with a complete metric space structure, do `letI := upgrade_polish_space α`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_monoid_hom",
    "statement": "structure is_monoid_hom {α : Type u} {β : Type v} [mul_one_class α] [mul_one_class β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [mul_one_class α] [mul_one_class β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [mul_one_class α] [mul_one_class β] (f : α → β)",
    "doc_string": "Predicate for monoid homomorphisms (deprecated -- use the bundled `monoid_hom` version).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "sup_bot_hom_class",
    "statement": "structure sup_bot_hom_class (F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_sup α] [has_sup β] [has_bot α] [has_bot β] : Type (max u_7 u_8 u_9)",
    "theorem": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_sup α] [has_sup β] [has_bot α] [has_bot β] : Type (max u_7 u_8 u_9)",
    "args": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_sup α] [has_sup β] [has_bot α] [has_bot β]",
    "doc_string": " `sup_bot_hom_class F α β` states that `F` is a type of finitary supremum-preserving morphisms.  You should extend this class when you extend `sup_bot_hom`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8 u_9)"
  },
  {
    "name": "set.bounded",
    "statement": "def set.bounded {α : Type u} (r : α → α → Prop) (s : set α) : Prop",
    "theorem": "{α : Type u} (r : α → α → Prop) (s : set α) : Prop",
    "args": "{α : Type u} (r : α → α → Prop) (s : set α)",
    "doc_string": "A bounded or final set. Not to be confused with `metric.bounded`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "monoid_algebra.algebra",
    "statement": "def monoid_algebra.algebra {k : Type u₁} {G : Type u₂} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] : algebra k (monoid_algebra A G)",
    "theorem": "{k : Type u₁} {G : Type u₂} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] : algebra k (monoid_algebra A G)",
    "args": "{k : Type u₁} {G : Type u₂} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G]",
    "doc_string": "The instance `algebra k (monoid_algebra A G)` whenever we have `algebra k A`.  In particular this provides the instance `algebra k (monoid_algebra k G)`.",
    "kind": "def",
    "type": "algebra k (monoid_algebra A G)"
  },
  {
    "name": "algebraic_topology.normalized_Moore_complex.obj_X",
    "statement": "def algebraic_topology.normalized_Moore_complex.obj_X {C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) (n : ℕ) : category_theory.subobject (X.obj (opposite.op (simplex_category.mk n)))",
    "theorem": "{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) (n : ℕ) : category_theory.subobject (X.obj (opposite.op (simplex_category.mk n)))",
    "args": "{C : Type u_1} [category_theory.category C] [category_theory.abelian C] (X : category_theory.simplicial_object C) (n : ℕ)",
    "doc_string": "The normalized Moore complex in degree `n`, as a subobject of `X n`.",
    "kind": "def",
    "type": "category_theory.subobject (X.obj (opposite.op (simplex_category.mk n)))"
  },
  {
    "name": "has_sbtw.sbtw.not_btw",
    "statement": "theorem has_sbtw.sbtw.not_btw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_btw.btw c b a",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_btw.btw c b a",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of not_btw_of_sbtw`.",
    "kind": "theorem",
    "type": "¬has_btw.btw c b a"
  },
  {
    "name": "restrict_scalars.module",
    "statement": "def restrict_scalars.module (R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [comm_semiring R] [algebra R S] [module S M] : module R (restrict_scalars R S M)",
    "theorem": "(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [comm_semiring R] [algebra R S] [module S M] : module R (restrict_scalars R S M)",
    "args": "(R : Type u_1) (S : Type u_2) (M : Type u_3) [semiring S] [add_comm_monoid M] [comm_semiring R] [algebra R S] [module S M]",
    "doc_string": "When `M` is a module over a ring `S`, and `S` is an algebra over `R`, then `M` inherits a module structure over `R`.  The preferred way of setting this up is `[module R M] [module S M] [is_scalar_tower R S M]`.",
    "kind": "def",
    "type": "module R (restrict_scalars R S M)"
  },
  {
    "name": "znum.bitm1",
    "statement": "def znum.bitm1  : znum → znum",
    "theorem": " : znum → znum",
    "args": "",
    "doc_string": "`bitm1 x` appends a `1` to the end of `x`, mapping `x` to `2 * x - 1`.",
    "kind": "def",
    "type": "znum → znum"
  },
  {
    "name": "matrix.frobenius_normed_ring",
    "statement": "def matrix.frobenius_normed_ring {m : Type u_3} {α : Type u_5} [fintype m] [is_R_or_C α] [decidable_eq m] : normed_ring (matrix m m α)",
    "theorem": "{m : Type u_3} {α : Type u_5} [fintype m] [is_R_or_C α] [decidable_eq m] : normed_ring (matrix m m α)",
    "args": "{m : Type u_3} {α : Type u_5} [fintype m] [is_R_or_C α] [decidable_eq m]",
    "doc_string": " Normed ring instance (using frobenius norm) for matrices over `ℝ` or `ℂ`.  Not declared as an instance because there are several natural choices for defining the norm of a matrix.",
    "kind": "def",
    "type": "normed_ring (matrix m m α)"
  },
  {
    "name": "module.End.division_ring",
    "statement": "def module.End.division_ring {R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] [decidable_eq (module.End R M)] [is_simple_module R M] : division_ring (module.End R M)",
    "theorem": "{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] [decidable_eq (module.End R M)] [is_simple_module R M] : division_ring (module.End R M)",
    "args": "{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] [decidable_eq (module.End R M)] [is_simple_module R M]",
    "doc_string": "Schur's Lemma makes the endomorphism ring of a simple module a division ring.",
    "kind": "def",
    "type": "division_ring (module.End R M)"
  },
  {
    "name": "ring_equiv_class",
    "statement": "structure ring_equiv_class (F : Type u_7) (R : out_param (Type u_8)) (S : out_param (Type u_9)) [has_mul R] [has_add R] [has_mul S] [has_add S] : Type (max u_7 u_8 u_9)",
    "theorem": "(F : Type u_7) (R : out_param (Type u_8)) (S : out_param (Type u_9)) [has_mul R] [has_add R] [has_mul S] [has_add S] : Type (max u_7 u_8 u_9)",
    "args": "(F : Type u_7) (R : out_param (Type u_8)) (S : out_param (Type u_9)) [has_mul R] [has_add R] [has_mul S] [has_add S]",
    "doc_string": " `ring_equiv_class F R S` states that `F` is a type of ring structure preserving equivalences. You should extend this class when you extend `ring_equiv`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8 u_9)"
  },
  {
    "name": "polynomial.root_multiplicity",
    "statement": "def polynomial.root_multiplicity {R : Type u} [comm_ring R] (a : R) (p : polynomial R) : ℕ",
    "theorem": "{R : Type u} [comm_ring R] (a : R) (p : polynomial R) : ℕ",
    "args": "{R : Type u} [comm_ring R] (a : R) (p : polynomial R)",
    "doc_string": " The largest power of `X - C a` which divides `p`. This is computable via the divisibility algorithm `decidable_dvd_monic`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "baire_space",
    "statement": "structure baire_space (α : Type u_5) [topological_space α] : Prop",
    "theorem": "(α : Type u_5) [topological_space α] : Prop",
    "args": "(α : Type u_5) [topological_space α]",
    "doc_string": " The property `baire_space α` means that the topological space `α` has the Baire property: any countable intersection of open dense subsets is dense. Formulated here when the source space is ℕ (and subsumed below by `dense_Inter_of_open` working with any encodable source space).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "pgame.pow_half",
    "statement": "def pgame.pow_half  : ℕ → pgame",
    "theorem": " : ℕ → pgame",
    "args": "",
    "doc_string": " For a natural number `n`, the pre-game `pow_half (n + 1)` is recursively defined as `{0 | pow_half n}`. These are the explicit expressions of powers of `1 / 2`. By definition, we have `pow_half 0 = 1` and `pow_half 1 ≈ 1 / 2` and we prove later on that `pow_half (n + 1) + pow_half (n + 1) ≈ pow_half n`.",
    "kind": "def",
    "type": "ℕ → pgame"
  },
  {
    "name": "group.conjugates_of_set",
    "statement": "def group.conjugates_of_set {G : Type u_1} [group G] (s : set G) : set G",
    "theorem": "{G : Type u_1} [group G] (s : set G) : set G",
    "args": "{G : Type u_1} [group G] (s : set G)",
    "doc_string": " Given a set `s`, `conjugates_of_set s` is the set of all conjugates of the elements of `s`.",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "expr.coord",
    "statement": "inductive expr.coord  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " An enum representing a recursive argument in an `expr` constructor. Types of local and meta variables are not included because they are not consistently set and depend on context.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "gcd_monoid_of_exists_lcm",
    "statement": "def gcd_monoid_of_exists_lcm {α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d) : gcd_monoid α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d) : gcd_monoid α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), a ∣ d ∧ b ∣ d ↔ c ∣ d)",
    "doc_string": "Define a `gcd_monoid` structure on a monoid just from the existence of an `lcm`.",
    "kind": "def",
    "type": "gcd_monoid α"
  },
  {
    "name": "add_subgroup.is_commutative",
    "statement": "structure add_subgroup.is_commutative {A : Type u_2} [add_group A] (H : add_subgroup A) : Prop",
    "theorem": "{A : Type u_2} [add_group A] (H : add_subgroup A) : Prop",
    "args": "{A : Type u_2} [add_group A] (H : add_subgroup A)",
    "doc_string": "Commutivity of an additive subgroup",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "number_field.ring_of_integers",
    "statement": "def number_field.ring_of_integers (K : Type u_1) [field K] : subalgebra ℤ K",
    "theorem": "(K : Type u_1) [field K] : subalgebra ℤ K",
    "args": "(K : Type u_1) [field K]",
    "doc_string": " The ring of integers (or number ring) corresponding to a number field is the integral closure of ℤ in the number field.",
    "kind": "def",
    "type": "subalgebra ℤ K"
  },
  {
    "name": "ordnode.erase",
    "statement": "def ordnode.erase {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": " O(log n). Remove an element from the set equivalent to `x`. Does nothing if there is no such element.      erase 1 {1, 2, 3} = {2, 3}     erase 4 {1, 2, 3} = {1, 2, 3}  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      erase (1, 1) {(0, 1), (1, 2)} = {(0, 1)}     erase (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "finmap.union",
    "statement": "def finmap.union {α : Type u} {β : α → Type v} [decidable_eq α] (s₁ s₂ : finmap β) : finmap β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (s₁ s₂ : finmap β) : finmap β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (s₁ s₂ : finmap β)",
    "doc_string": " `s₁ ∪ s₂` is the key-based union of two finite maps. It is left-biased: if there exists an `a ∈ s₁`, `lookup a (s₁ ∪ s₂) = lookup a s₁`.",
    "kind": "def",
    "type": "finmap β"
  },
  {
    "name": "snum.bit",
    "statement": "def snum.bit  : bool → snum → snum",
    "theorem": " : bool → snum → snum",
    "args": "",
    "doc_string": "Add a bit at the end of a `snum`. This mimics `nzsnum.bit`.",
    "kind": "def",
    "type": "bool → snum → snum"
  },
  {
    "name": "matrix.vandermonde",
    "statement": "def matrix.vandermonde {R : Type u_1} [comm_ring R] {n : ℕ} (v : fin n → R) : matrix (fin n) (fin n) R",
    "theorem": "{R : Type u_1} [comm_ring R] {n : ℕ} (v : fin n → R) : matrix (fin n) (fin n) R",
    "args": "{R : Type u_1} [comm_ring R] {n : ℕ} (v : fin n → R)",
    "doc_string": "`vandermonde v` is the square matrix with `i`th row equal to `1, v i, v i ^ 2, v i ^ 3, ...`.",
    "kind": "def",
    "type": "matrix (fin n) (fin n) R"
  },
  {
    "name": "unitization.inl",
    "statement": "def unitization.inl {R : Type u_1} {A : Type u_2} [has_zero A] (r : R) : unitization R A",
    "theorem": "{R : Type u_1} {A : Type u_2} [has_zero A] (r : R) : unitization R A",
    "args": "{R : Type u_1} {A : Type u_2} [has_zero A] (r : R)",
    "doc_string": "The canonical inclusion `R → unitization R A`.",
    "kind": "def",
    "type": "unitization R A"
  },
  {
    "name": "bitvec.ult",
    "statement": "def bitvec.ult {n : ℕ} (x y : bitvec n) : Prop",
    "theorem": "{n : ℕ} (x y : bitvec n) : Prop",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "unsigned less-than proposition",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "div_inv_monoid.has_measurable_zpow",
    "statement": "def div_inv_monoid.has_measurable_zpow (G : Type u) [div_inv_monoid G] [measurable_space G] [has_measurable_mul₂ G] [has_measurable_inv G] : has_measurable_pow G ℤ",
    "theorem": "(G : Type u) [div_inv_monoid G] [measurable_space G] [has_measurable_mul₂ G] [has_measurable_inv G] : has_measurable_pow G ℤ",
    "args": "(G : Type u) [div_inv_monoid G] [measurable_space G] [has_measurable_mul₂ G] [has_measurable_inv G]",
    "doc_string": "`div_inv_monoid.has_pow` is measurable.",
    "kind": "def",
    "type": "has_measurable_pow G ℤ"
  },
  {
    "name": "topological_space.pseudo_metrizable_space",
    "statement": "structure topological_space.pseudo_metrizable_space (X : Type u_5) [t : topological_space X] : Prop",
    "theorem": "(X : Type u_5) [t : topological_space X] : Prop",
    "args": "(X : Type u_5) [t : topological_space X]",
    "doc_string": " A topological space is *pseudo metrizable* if there exists a pseudo metric space structure compatible with the topology. To endow such a space with a compatible distance, use `letI : pseudo_metric_space X := topological_space.pseudo_metrizable_space_pseudo_metric X`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordered_add_comm_group.le_of_add_le_add_left",
    "statement": "theorem ordered_add_comm_group.le_of_add_le_add_left {α : Type u_1} [has_add α] [has_le α] [contravariant_class α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c) : b ≤ c",
    "theorem": "{α : Type u_1} [has_add α] [has_le α] [contravariant_class α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c) : b ≤ c",
    "args": "{α : Type u_1} [has_add α] [has_le α] [contravariant_class α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c)",
    "doc_string": "**Alias** of le_of_mul_le_mul_left'`.",
    "kind": "theorem",
    "type": "b ≤ c"
  },
  {
    "name": "free_group.reduce.self",
    "statement": "theorem free_group.reduce.self {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L",
    "theorem": "{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L",
    "args": "{α : Type u} {L : list (α × bool)} [decidable_eq α]",
    "doc_string": " A word and its maximal reduction correspond to the same element of the free group.",
    "kind": "theorem",
    "type": "free_group.mk (free_group.reduce L) = free_group.mk L"
  },
  {
    "name": "add_monoid_algebra.has_mul",
    "statement": "def add_monoid_algebra.has_mul {k : Type u₁} {G : Type u₂} [semiring k] [has_add G] : has_mul (add_monoid_algebra k G)",
    "theorem": "{k : Type u₁} {G : Type u₂} [semiring k] [has_add G] : has_mul (add_monoid_algebra k G)",
    "args": "{k : Type u₁} {G : Type u₂} [semiring k] [has_add G]",
    "doc_string": "The product of `f g : add_monoid_algebra k G` is the finitely supported function  whose value at `a` is the sum of `f x * g y` over all pairs `x, y`  such that `x + y = a`. (Think of the product of multivariate  polynomials where `α` is the additive monoid of monomial exponents.)",
    "kind": "def",
    "type": "has_mul (add_monoid_algebra k G)"
  },
  {
    "name": "first_order.language.Lhom",
    "statement": "structure first_order.language.Lhom (L : first_order.language) (L' : first_order.language) : Type (max u u' v v')",
    "theorem": "(L : first_order.language) (L' : first_order.language) : Type (max u u' v v')",
    "args": "(L : first_order.language) (L' : first_order.language)",
    "doc_string": "A language homomorphism maps the symbols of one language to symbols of another.",
    "kind": "structure",
    "type": "Type (max u u' v v')"
  },
  {
    "name": "inner_product_space",
    "statement": "structure inner_product_space (𝕜 : Type u_4) (E : Type u_5) [is_R_or_C 𝕜] : Type (max u_4 u_5)",
    "theorem": "(𝕜 : Type u_4) (E : Type u_5) [is_R_or_C 𝕜] : Type (max u_4 u_5)",
    "args": "(𝕜 : Type u_4) (E : Type u_5) [is_R_or_C 𝕜]",
    "doc_string": "An inner product space is a vector space with an additional operation called inner product. The norm could be derived from the inner product, instead we require the existence of a norm and the fact that `∥x∥^2 = re ⟪x, x⟫` to be able to put instances on `𝕂` or product spaces.  To construct a norm from an inner product, see `inner_product_space.of_core`.",
    "kind": "structure",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "parser.foldr",
    "statement": "def parser.foldr {α β : Type} (f : α → β → β) (p : parser α) (b : β) : parser β",
    "theorem": "{α β : Type} (f : α → β → β) (p : parser α) (b : β) : parser β",
    "args": "{α β : Type} (f : α → β → β) (p : parser α) (b : β)",
    "doc_string": "Matches zero or more occurrences of `p`, and folds the result.",
    "kind": "def",
    "type": "parser β"
  },
  {
    "name": "expr_lens.dir",
    "statement": "inductive expr_lens.dir  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Inductive type with two constructors `F` and `A`, that represent the function-part `f` and arg-part `a` of an application `f a`. They specify the directions in which an `expr_lens` should zoom into an `expr`.  This type is used in the development of rewriting tactics such as `nth_rewrite` and `rewrite_search`.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "linarith.linarith_config",
    "statement": "structure linarith.linarith_config  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A configuration object for `linarith`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "is_closed.is_seq_closed",
    "statement": "theorem is_closed.is_seq_closed {X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s",
    "theorem": "{X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s",
    "args": "{X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s)",
    "doc_string": "A set is sequentially closed if it is closed.",
    "kind": "theorem",
    "type": "is_seq_closed s"
  },
  {
    "name": "continuous_add_monoid_hom.id",
    "statement": "def continuous_add_monoid_hom.id (A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A A",
    "theorem": "(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A A",
    "args": "(A : Type u_4) [add_monoid A] [topological_space A]",
    "doc_string": "The identity continuous homomorphism.",
    "kind": "def",
    "type": "continuous_add_monoid_hom A A"
  },
  {
    "name": "Set.union",
    "statement": "def Set.union (x y : Set) : Set",
    "theorem": "(x y : Set) : Set",
    "args": "(x y : Set)",
    "doc_string": "The binary union operation",
    "kind": "def",
    "type": "Set"
  },
  {
    "name": "nat.unpair",
    "statement": "def nat.unpair (n : ℕ) : ℕ × ℕ",
    "theorem": "(n : ℕ) : ℕ × ℕ",
    "args": "(n : ℕ)",
    "doc_string": "Unpairing function for the natural numbers.",
    "kind": "def",
    "type": "ℕ × ℕ"
  },
  {
    "name": "euclidean_domain.gcd_monoid",
    "statement": "def euclidean_domain.gcd_monoid (R : Type u_1) [euclidean_domain R] : gcd_monoid R",
    "theorem": "(R : Type u_1) [euclidean_domain R] : gcd_monoid R",
    "args": "(R : Type u_1) [euclidean_domain R]",
    "doc_string": "Create a `gcd_monoid` whose `gcd_monoid.gcd` matches `euclidean_domain.gcd`.",
    "kind": "def",
    "type": "gcd_monoid R"
  },
  {
    "name": "list.mmap_with_index_aux_spec",
    "statement": "def list.mmap_with_index_aux_spec {m : Type u → Type v} [applicative m] {α : Type u_1} {β : Type u} (f : ℕ → α → m β) (start : ℕ) (as : list α) : m (list β)",
    "theorem": "{m : Type u → Type v} [applicative m] {α : Type u_1} {β : Type u} (f : ℕ → α → m β) (start : ℕ) (as : list α) : m (list β)",
    "args": "{m : Type u → Type v} [applicative m] {α : Type u_1} {β : Type u} (f : ℕ → α → m β) (start : ℕ) (as : list α)",
    "doc_string": "Specification of `mmap_with_index_aux`.",
    "kind": "def",
    "type": "m (list β)"
  },
  {
    "name": "seq.zip_with",
    "statement": "def seq.zip_with {α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) : seq α → seq β → seq γ",
    "theorem": "{α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) : seq α → seq β → seq γ",
    "args": "{α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ)",
    "doc_string": "Combine two sequences with a function",
    "kind": "def",
    "type": "seq α → seq β → seq γ"
  },
  {
    "name": "distrib_mul_action",
    "statement": "structure distrib_mul_action (M : Type u_10) (A : Type u_11) [monoid M] [add_monoid A] : Type (max u_10 u_11)",
    "theorem": "(M : Type u_10) (A : Type u_11) [monoid M] [add_monoid A] : Type (max u_10 u_11)",
    "args": "(M : Type u_10) (A : Type u_11) [monoid M] [add_monoid A]",
    "doc_string": "Typeclass for multiplicative actions on additive structures. This generalizes group modules.",
    "kind": "structure",
    "type": "Type (max u_10 u_11)"
  },
  {
    "name": "turing.list_blank.head",
    "statement": "def turing.list_blank.head {Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : Γ",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : Γ",
    "args": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ)",
    "doc_string": "The head of a `list_blank` is well defined.",
    "kind": "def",
    "type": "Γ"
  },
  {
    "name": "is_prime_pow",
    "statement": "def is_prime_pow {R : Type u_1} [comm_monoid_with_zero R] (n : R) : Prop",
    "theorem": "{R : Type u_1} [comm_monoid_with_zero R] (n : R) : Prop",
    "args": "{R : Type u_1} [comm_monoid_with_zero R] (n : R)",
    "doc_string": " `n` is a prime power if there is a prime `p` and a positive natural `k` such that `n` can be written as `p^k`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "module.ray.has_involutive_neg",
    "statement": "def module.ray.has_involutive_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_involutive_neg (module.ray R M)",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_involutive_neg (module.ray R M)",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M]",
    "doc_string": "Negating a ray twice produces the original ray.",
    "kind": "def",
    "type": "has_involutive_neg (module.ray R M)"
  },
  {
    "name": "Class.Class_to_Cong",
    "statement": "def Class.Class_to_Cong (x : Class) : set Class",
    "theorem": "(x : Class) : set Class",
    "args": "(x : Class)",
    "doc_string": "Convert a class into a conglomerate (a collection of classes)",
    "kind": "def",
    "type": "set Class"
  },
  {
    "name": "subring.center",
    "statement": "def subring.center (R : Type u) [ring R] : subring R",
    "theorem": "(R : Type u) [ring R] : subring R",
    "args": "(R : Type u) [ring R]",
    "doc_string": "The center of a ring `R` is the set of elements that commute with everything in `R`",
    "kind": "def",
    "type": "subring R"
  },
  {
    "name": "padic_val_nat.one",
    "statement": "theorem padic_val_nat.one {p : ℕ} : padic_val_nat p 1 = 0",
    "theorem": "{p : ℕ} : padic_val_nat p 1 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_nat p 1` is 0 for any `p`.",
    "kind": "theorem",
    "type": "padic_val_nat p 1 = 0"
  },
  {
    "name": "subtype.prop",
    "statement": "theorem subtype.prop {α : Sort u_1} {p : α → Prop} (x : subtype p) : p ↑x",
    "theorem": "{α : Sort u_1} {p : α → Prop} (x : subtype p) : p ↑x",
    "args": "{α : Sort u_1} {p : α → Prop} (x : subtype p)",
    "doc_string": "A version of `x.property` or `x.2` where `p` is syntactically applied to the coercion of `x`  instead of `x.1`. A similar result is `subtype.mem` in `data.set.basic`.",
    "kind": "theorem",
    "type": "p ↑x"
  },
  {
    "name": "pgame.domineering.board",
    "statement": "def pgame.domineering.board  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A Domineering board is an arbitrary finite subset of `ℤ × ℤ`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "topological_space.sigma.second_countable_topology",
    "statement": "def topological_space.sigma.second_countable_topology {ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] [encodable ι] [∀ (i : ι), topological_space.second_countable_topology (E i)] : topological_space.second_countable_topology (Σ (i : ι), E i)",
    "theorem": "{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] [encodable ι] [∀ (i : ι), topological_space.second_countable_topology (E i)] : topological_space.second_countable_topology (Σ (i : ι), E i)",
    "args": "{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), topological_space (E i)] [encodable ι] [∀ (i : ι), topological_space.second_countable_topology (E i)]",
    "doc_string": "A countable disjoint union of second countable spaces is second countable.",
    "kind": "def",
    "type": "topological_space.second_countable_topology (Σ (i : ι), E i)"
  },
  {
    "name": "generalized_continued_fraction.continuants_aux",
    "statement": "def generalized_continued_fraction.continuants_aux {K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)",
    "theorem": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream (generalized_continued_fraction.pair K)",
    "args": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K)",
    "doc_string": "Returns the continuants `⟨Aₙ₋₁, Bₙ₋₁⟩` of `g`.",
    "kind": "def",
    "type": "stream (generalized_continued_fraction.pair K)"
  },
  {
    "name": "subgroup.complete_lattice",
    "statement": "def subgroup.complete_lattice {G : Type u_1} [group G] : complete_lattice (subgroup G)",
    "theorem": "{G : Type u_1} [group G] : complete_lattice (subgroup G)",
    "args": "{G : Type u_1} [group G]",
    "doc_string": "Subgroups of a group form a complete lattice.",
    "kind": "def",
    "type": "complete_lattice (subgroup G)"
  },
  {
    "name": "category_theory.strong_epi_category",
    "statement": "structure category_theory.strong_epi_category (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A strong epi category is a category in which every epimorphism is strong.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.with_initial",
    "statement": "inductive category_theory.with_initial (C : Type u) [category_theory.category C] : Type u",
    "theorem": "(C : Type u) [category_theory.category C] : Type u",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "Formally adjoin an initial object to a category.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "con.has_le",
    "statement": "def con.has_le {M : Type u_1} [has_mul M] : has_le (con M)",
    "theorem": "{M : Type u_1} [has_mul M] : has_le (con M)",
    "args": "{M : Type u_1} [has_mul M]",
    "doc_string": "For congruence relations `c, d` on a type `M` with a multiplication, `c ≤ d` iff `∀ x y ∈ M`,    `x` is related to `y` by `d` if `x` is related to `y` by `c`.",
    "kind": "def",
    "type": "has_le (con M)"
  },
  {
    "name": "subgroup.normal",
    "statement": "structure subgroup.normal {G : Type u_1} [group G] (H : subgroup G) : Prop",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : Prop",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": "A subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G`",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "Prop.distrib_lattice",
    "statement": "def Prop.distrib_lattice  : distrib_lattice Prop",
    "theorem": " : distrib_lattice Prop",
    "args": "",
    "doc_string": "Propositions form a distributive lattice.",
    "kind": "def",
    "type": "distrib_lattice Prop"
  },
  {
    "name": "free_comm_ring",
    "statement": "def free_comm_ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "`free_comm_ring α` is the free commutative ring on the type `α`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "subalgebra.to_add_submonoid",
    "statement": "def subalgebra.to_add_submonoid {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : add_submonoid A",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : add_submonoid A",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A)",
    "doc_string": "The projection from a subalgebra of `A` to an additive submonoid of `A`.",
    "kind": "def",
    "type": "add_submonoid A"
  },
  {
    "name": "continuous_map.continuous_restrict",
    "statement": "theorem continuous_map.continuous_restrict {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α) : continuous (λ (F : C(α, β)), continuous_map.restrict s F)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α) : continuous (λ (F : C(α, β)), continuous_map.restrict s F)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α)",
    "doc_string": " For any subset `s` of `α`, the restriction of continuous functions to `s` is continuous as a function from `C(α, β)` to `C(s, β)` with their respective compact-open topologies.",
    "kind": "theorem",
    "type": "continuous (λ (F : C(α, β)), continuous_map.restrict s F)"
  },
  {
    "name": "category_theory.free_monoidal_category",
    "statement": "inductive category_theory.free_monoidal_category (C : Type u) : Type u",
    "theorem": "(C : Type u) : Type u",
    "args": "(C : Type u)",
    "doc_string": "Given a type `C`, the free monoidal category over `C` has as objects formal expressions built from (formal) tensor products of terms of `C` and a formal unit. Its morphisms are compositions and tensor products of identities, unitors and associators.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "category_theory.injective_presentation",
    "statement": "structure category_theory.injective_presentation {C : Type u} [category_theory.category C] (X : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] (X : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] (X : C)",
    "doc_string": "An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J` to some injective object `J`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "vector3.head",
    "statement": "def vector3.head {α : Type u_1} {n : ℕ} (v : vector3 α n.succ) : α",
    "theorem": "{α : Type u_1} {n : ℕ} (v : vector3 α n.succ) : α",
    "args": "{α : Type u_1} {n : ℕ} (v : vector3 α n.succ)",
    "doc_string": "Get the head of a nonempty vector.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "computation.results",
    "statement": "def computation.results {α : Type u} (s : computation α) (a : α) (n : ℕ) : Prop",
    "theorem": "{α : Type u} (s : computation α) (a : α) (n : ℕ) : Prop",
    "args": "{α : Type u} (s : computation α) (a : α) (n : ℕ)",
    "doc_string": "`results s a n` completely characterizes a terminating computation:  it asserts that `s` terminates after exactly `n` steps, with result `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "matrix.transpose_apply",
    "statement": "theorem matrix.transpose_apply {m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) (i : m) (j : n) : M.transpose j i = M i j",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) (i : m) (j : n) : M.transpose j i = M i j",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) (i : m) (j : n)",
    "doc_string": "Tell `simp` what the entries are in a transposed matrix.  Compare with `mul_apply`, `diagonal_apply_eq`, etc.",
    "kind": "theorem",
    "type": "M.transpose j i = M i j"
  },
  {
    "name": "comm_group_with_zero",
    "statement": "structure comm_group_with_zero (G₀ : Type u_4) : Type u_4",
    "theorem": "(G₀ : Type u_4) : Type u_4",
    "args": "(G₀ : Type u_4)",
    "doc_string": " A type `G₀` is a commutative “group with zero” if it is a commutative monoid with zero element (distinct from `1`) such that every nonzero element is invertible. The type is required to come with an “inverse” function, and the inverse of `0` must be `0`.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "derive_fintype.finset_in",
    "statement": "def derive_fintype.finset_in {α : Type u_1} (P : α → Prop) : Type u_1",
    "theorem": "{α : Type u_1} (P : α → Prop) : Type u_1",
    "args": "{α : Type u_1} (P : α → Prop)",
    "doc_string": " This is a finset covering a nontrivial variant (with one or more constructor arguments). The property `P` here is `λ a, enum a = n` where `n` is the discriminant for the current variant.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "topological_add_group.continuous_conj",
    "statement": "theorem topological_add_group.continuous_conj {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (λ (h : G), g + h + -g)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (λ (h : G), g + h + -g)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G)",
    "doc_string": "Conjugation by a fixed element is continuous when `add` is continuous.",
    "kind": "theorem",
    "type": "continuous (λ (h : G), g + h + -g)"
  },
  {
    "name": "category_theory.limits.has_limits",
    "statement": "def category_theory.limits.has_limits (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`C` has all (small) limits if it has limits of every shape that is as big as its hom-sets.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "linear_recurrence",
    "statement": "structure linear_recurrence (α : Type u_1) [comm_semiring α] : Type u_1",
    "theorem": "(α : Type u_1) [comm_semiring α] : Type u_1",
    "args": "(α : Type u_1) [comm_semiring α]",
    "doc_string": "A \"linear recurrence relation\" over a commutative semiring is given by its  order `n` and `n` coefficients.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "Fintype.of",
    "statement": "def Fintype.of (X : Type u_1) [fintype X] : Fintype",
    "theorem": "(X : Type u_1) [fintype X] : Fintype",
    "args": "(X : Type u_1) [fintype X]",
    "doc_string": "Construct a bundled `Fintype` from the underlying type and typeclass.",
    "kind": "def",
    "type": "Fintype"
  },
  {
    "name": "encodable.decode_sigma",
    "statement": "def encodable.decode_sigma {α : Type u_1} {γ : α → Type u_3} [encodable α] [Π (a : α), encodable (γ a)] (n : ℕ) : option (sigma γ)",
    "theorem": "{α : Type u_1} {γ : α → Type u_3} [encodable α] [Π (a : α), encodable (γ a)] (n : ℕ) : option (sigma γ)",
    "args": "{α : Type u_1} {γ : α → Type u_3} [encodable α] [Π (a : α), encodable (γ a)] (n : ℕ)",
    "doc_string": "Explicit decoding function for `sigma γ`",
    "kind": "def",
    "type": "option (sigma γ)"
  },
  {
    "name": "finprod_mem_one",
    "statement": "theorem finprod_mem_one {α : Type u_1} {M : Type u_5} [comm_monoid M] (s : set α) : finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1",
    "theorem": "{α : Type u_1} {M : Type u_5} [comm_monoid M] (s : set α) : finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1",
    "args": "{α : Type u_1} {M : Type u_5} [comm_monoid M] (s : set α)",
    "doc_string": "The product of the constant function `1` over any set equals `1`.",
    "kind": "theorem",
    "type": "finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1"
  },
  {
    "name": "multiples.zero_mem",
    "statement": "theorem multiples.zero_mem {M : Type u_1} [add_monoid M] {x : M} : 0 ∈ multiples x",
    "theorem": "{M : Type u_1} [add_monoid M] {x : M} : 0 ∈ multiples x",
    "args": "{M : Type u_1} [add_monoid M] {x : M}",
    "doc_string": "0 is in the set of natural number multiples of an element of an `add_monoid`.",
    "kind": "theorem",
    "type": "0 ∈ multiples x"
  },
  {
    "name": "comp_mul_left",
    "statement": "theorem comp_mul_left {α : Type u_1} [semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)",
    "theorem": "{α : Type u_1} [semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)",
    "args": "{α : Type u_1} [semigroup α] (x y : α)",
    "doc_string": "Composing two multiplications on the left by `y` then `x` is equal to a multiplication on the left by `x * y`.",
    "kind": "theorem",
    "type": "has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)"
  },
  {
    "name": "alexandroff.compact_space",
    "statement": "def alexandroff.compact_space {X : Type u_1} [topological_space X] : compact_space (alexandroff X)",
    "theorem": "{X : Type u_1} [topological_space X] : compact_space (alexandroff X)",
    "args": "{X : Type u_1} [topological_space X]",
    "doc_string": "For any topological space `X`, its one point compactification is a compact space.",
    "kind": "def",
    "type": "compact_space (alexandroff X)"
  },
  {
    "name": "inner_product_space.of_core",
    "statement": "def inner_product_space.of_core {𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] (c : inner_product_space.core 𝕜 F) : inner_product_space 𝕜 F",
    "theorem": "{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] (c : inner_product_space.core 𝕜 F) : inner_product_space 𝕜 F",
    "args": "{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] (c : inner_product_space.core 𝕜 F)",
    "doc_string": " Given a `inner_product_space.core` structure on a space, one can use it to turn the space into an inner product space, constructing the norm out of the inner product",
    "kind": "def",
    "type": "inner_product_space 𝕜 F"
  },
  {
    "name": "div_div_self",
    "statement": "theorem div_div_self {G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a / (a / a) = a",
    "theorem": "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a / (a / a) = a",
    "args": "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀)",
    "doc_string": " Dividing `a` by the result of dividing `a` by itself results in `a` (whether or not `a` is zero).",
    "kind": "theorem",
    "type": "a / (a / a) = a"
  },
  {
    "name": "joined_in.some_path",
    "statement": "def joined_in.some_path {X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : path x y",
    "theorem": "{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : path x y",
    "args": "{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y)",
    "doc_string": "When `x` and `y` are joined in `F`, choose a path from `x` to `y` inside `F`",
    "kind": "def",
    "type": "path x y"
  },
  {
    "name": "AddSemigroup",
    "statement": "def AddSemigroup  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of additive semigroups and semigroup morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "finmap.disjoint",
    "statement": "def finmap.disjoint {α : Type u} {β : α → Type v} (s₁ s₂ : finmap β) : Prop",
    "theorem": "{α : Type u} {β : α → Type v} (s₁ s₂ : finmap β) : Prop",
    "args": "{α : Type u} {β : α → Type v} (s₁ s₂ : finmap β)",
    "doc_string": "`disjoint s₁ s₂` holds if `s₁` and `s₂` have no keys in common.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "urysohns.CU",
    "statement": "structure urysohns.CU (X : Type u_2) [topological_space X] : Type u_2",
    "theorem": "(X : Type u_2) [topological_space X] : Type u_2",
    "args": "(X : Type u_2) [topological_space X]",
    "doc_string": " An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its open neighborhood `U`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "add_group.closure",
    "statement": "def add_group.closure {G : Type u_1} [add_group G] (s : set G) : set G",
    "theorem": "{G : Type u_1} [add_group G] (s : set G) : set G",
    "args": "{G : Type u_1} [add_group G] (s : set G)",
    "doc_string": "`add_group.closure s` is the additive subgroup generated by `s`, i.e., the   smallest additive subgroup containing `s`.",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "ordnode.powerset",
    "statement": "def ordnode.powerset {α : Type u} (t : ordnode α) : ordnode (ordnode α)",
    "theorem": "{α : Type u} (t : ordnode α) : ordnode (ordnode α)",
    "args": "{α : Type u} (t : ordnode α)",
    "doc_string": "O(2^n). Constructs the powerset of a given set, that is, the set of all subsets.      powerset {1, 2, 3} = {∅, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}}",
    "kind": "def",
    "type": "ordnode (ordnode α)"
  },
  {
    "name": "function.sometimes",
    "statement": "def function.sometimes {α : Sort u_1} {β : Sort u_2} [nonempty β] (f : α → β) : β",
    "theorem": "{α : Sort u_1} {β : Sort u_2} [nonempty β] (f : α → β) : β",
    "args": "{α : Sort u_1} {β : Sort u_2} [nonempty β] (f : α → β)",
    "doc_string": " `sometimes f` evaluates to some value of `f`, if it exists. This function is especially interesting in the case where `α` is a proposition, in which case `f` is necessarily a constant function, so that `sometimes f = f a` for all `a`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "has_btw",
    "statement": "structure has_btw (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Syntax typeclass for a betweenness relation.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "add_submonoid.fg",
    "statement": "def add_submonoid.fg {M : Type u_1} [add_monoid M] (P : add_submonoid M) : Prop",
    "theorem": "{M : Type u_1} [add_monoid M] (P : add_submonoid M) : Prop",
    "args": "{M : Type u_1} [add_monoid M] (P : add_submonoid M)",
    "doc_string": " An additive submonoid of `N` is finitely generated if it is the closure of a finite subset of `M`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "closed_embedding.tendsto_cocompact",
    "statement": "theorem closed_embedding.tendsto_cocompact {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact α) (filter.cocompact β)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact α) (filter.cocompact β)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f)",
    "doc_string": " A closed embedding is proper, ie, inverse images of compact sets are contained in compacts. Moreover, the preimage of a compact set is compact, see `closed_embedding.is_compact_preimage`.",
    "kind": "theorem",
    "type": "filter.tendsto f (filter.cocompact α) (filter.cocompact β)"
  },
  {
    "name": "simple_graph.is_n_clique",
    "statement": "structure simple_graph.is_n_clique {α : Type u_1} (G : simple_graph α) (n : ℕ) (s : finset α) : Prop",
    "theorem": "{α : Type u_1} (G : simple_graph α) (n : ℕ) (s : finset α) : Prop",
    "args": "{α : Type u_1} (G : simple_graph α) (n : ℕ) (s : finset α)",
    "doc_string": "A `n`-clique in a graph is a set of `n` vertices which are pairwise connected.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "decl_info",
    "statement": "structure decl_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The information collected from each declaration",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "hash_map.find",
    "statement": "def hash_map.find {α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α) : option (β a)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α) : option (β a)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α)",
    "doc_string": "Return the value corresponding to a key, or `none` if not found",
    "kind": "def",
    "type": "option (β a)"
  },
  {
    "name": "is_connected",
    "statement": "def is_connected {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "A connected set is one that is nonempty and where there is no non-trivial open partition.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "Meas.Giry",
    "statement": "def Meas.Giry  : category_theory.monad Meas",
    "theorem": " : category_theory.monad Meas",
    "args": "",
    "doc_string": "The Giry monad, i.e. the monadic structure associated with `Measure`.",
    "kind": "def",
    "type": "category_theory.monad Meas"
  },
  {
    "name": "bilin_form.is_self_adjoint",
    "statement": "def bilin_form.is_self_adjoint {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (f : module.End R M) : Prop",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (f : module.End R M) : Prop",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) (f : module.End R M)",
    "doc_string": " An endomorphism of a module is self-adjoint with respect to a bilinear form if it serves as an adjoint for itself.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.find_ge",
    "statement": "def ordnode.find_ge {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": "O(log n). Get the smallest element in the tree that is `≥ x`.      find_le 2 {1, 2, 4} = some 2     find_le 3 {1, 2, 4} = some 4     find_le 5 {1, 2, 4} = none",
    "kind": "def",
    "type": "ordnode α → option α"
  },
  {
    "name": "polynomial.eval",
    "statement": "def polynomial.eval {R : Type u} [semiring R] : R → polynomial R → R",
    "theorem": "{R : Type u} [semiring R] : R → polynomial R → R",
    "args": "{R : Type u} [semiring R]",
    "doc_string": "`eval x p` is the evaluation of the polynomial `p` at `x`",
    "kind": "def",
    "type": "R → polynomial R → R"
  },
  {
    "name": "buffer.mmap",
    "statement": "def buffer.mmap {α : Type u} {β : Type w} {m : Type w → Type u_1} [monad m] (b : buffer α) (f : α → m β) : m (buffer β)",
    "theorem": "{α : Type u} {β : Type w} {m : Type w → Type u_1} [monad m] (b : buffer α) (f : α → m β) : m (buffer β)",
    "args": "{α : Type u} {β : Type w} {m : Type w → Type u_1} [monad m] (b : buffer α) (f : α → m β)",
    "doc_string": "Monadically map a function over the buffer.",
    "kind": "def",
    "type": "m (buffer β)"
  },
  {
    "name": "antisymmetrization",
    "statement": "def antisymmetrization (α : Type u_1) (r : α → α → Prop) [is_preorder α r] : Type u_1",
    "theorem": "(α : Type u_1) (r : α → α → Prop) [is_preorder α r] : Type u_1",
    "args": "(α : Type u_1) (r : α → α → Prop) [is_preorder α r]",
    "doc_string": " The partial order derived from a preorder by making pairwise comparable elements equal. This is the quotient by `λ a b, a ≤ b ∧ b ≤ a`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "add_group.in_closure",
    "statement": "inductive add_group.in_closure {A : Type u_3} [add_group A] (s : set A) : A → Prop",
    "theorem": "{A : Type u_3} [add_group A] (s : set A) : A → Prop",
    "args": "{A : Type u_3} [add_group A] (s : set A)",
    "doc_string": " If `A` is an additive group and `s : set A`, then `in_closure s : set A` is the underlying subset of the subgroup generated by `s`.",
    "kind": "inductive",
    "type": "A → Prop"
  },
  {
    "name": "lattice_hom.id",
    "statement": "def lattice_hom.id (α : Type u_3) [lattice α] : lattice_hom α α",
    "theorem": "(α : Type u_3) [lattice α] : lattice_hom α α",
    "args": "(α : Type u_3) [lattice α]",
    "doc_string": "`id` as a `lattice_hom`.",
    "kind": "def",
    "type": "lattice_hom α α"
  },
  {
    "name": "is_cau_seq",
    "statement": "def is_cau_seq {α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] (abv : β → α) (f : ℕ → β) : Prop",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] (abv : β → α) (f : ℕ → β) : Prop",
    "args": "{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] (abv : β → α) (f : ℕ → β)",
    "doc_string": "A sequence is Cauchy if the distance between its entries tends to zero.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finite_field.exists_nonsquare",
    "statement": "theorem finite_field.exists_nonsquare {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a",
    "theorem": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a",
    "args": "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2)",
    "doc_string": "In a finite field of odd characteristic, not every element is a square.",
    "kind": "theorem",
    "type": "∃ (a : F), ¬is_square a"
  },
  {
    "name": "part.ext",
    "statement": "theorem part.ext {α : Type u_1} {o p : part α} (H : ∀ (a : α), a ∈ o ↔ a ∈ p) : o = p",
    "theorem": "{α : Type u_1} {o p : part α} (H : ∀ (a : α), a ∈ o ↔ a ∈ p) : o = p",
    "args": "{α : Type u_1} {o p : part α} (H : ∀ (a : α), a ∈ o ↔ a ∈ p)",
    "doc_string": "`part` extensionality",
    "kind": "theorem",
    "type": "o = p"
  },
  {
    "name": "list.mfoldl_with_index",
    "statement": "def list.mfoldl_with_index {m : Type v → Type w} [monad m] {α : Type u_1} {β : Type v} (f : ℕ → β → α → m β) (b : β) (as : list α) : m β",
    "theorem": "{m : Type v → Type w} [monad m] {α : Type u_1} {β : Type v} (f : ℕ → β → α → m β) (b : β) (as : list α) : m β",
    "args": "{m : Type v → Type w} [monad m] {α : Type u_1} {β : Type v} (f : ℕ → β → α → m β) (b : β) (as : list α)",
    "doc_string": "Monadic variant of `foldl_with_index`.",
    "kind": "def",
    "type": "m β"
  },
  {
    "name": "measurable_div_const'",
    "statement": "theorem measurable_div_const' {G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (λ (h : G), h / g)",
    "theorem": "{G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (λ (h : G), h / g)",
    "args": "{G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G)",
    "doc_string": "A version of `measurable_div_const` that assumes `has_measurable_mul` instead of  `has_measurable_div`. This can be nice to avoid unnecessary type-class assumptions.",
    "kind": "theorem",
    "type": "measurable (λ (h : G), h / g)"
  },
  {
    "name": "int.floor",
    "statement": "def int.floor {α : Type u_1} [linear_ordered_ring α] [floor_ring α] : α → ℤ",
    "theorem": "{α : Type u_1} [linear_ordered_ring α] [floor_ring α] : α → ℤ",
    "args": "{α : Type u_1} [linear_ordered_ring α] [floor_ring α]",
    "doc_string": "`int.floor a` is the greatest integer `z` such that `z ≤ a`. It is denoted with `⌊a⌋`.",
    "kind": "def",
    "type": "α → ℤ"
  },
  {
    "name": "triv_sq_zero_ext",
    "statement": "def triv_sq_zero_ext (R : Type u) (M : Type v) : Type (max u v)",
    "theorem": "(R : Type u) (M : Type v) : Type (max u v)",
    "args": "(R : Type u) (M : Type v)",
    "doc_string": "\"Trivial Square-Zero Extension\".  Given a module `M` over a ring `R`, the trivial square-zero extension of `M` over `R` is defined to be the `R`-algebra `R × M` with multiplication given by `(r₁ + m₁) * (r₂ + m₂) = r₁ r₂ + r₁ m₂ + r₂ m₁`.  It is a square-zero extension because `M^2 = 0`.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "boolean_ring.has_inf",
    "statement": "def boolean_ring.has_inf {α : Type u_1} [boolean_ring α] : has_inf α",
    "theorem": "{α : Type u_1} [boolean_ring α] : has_inf α",
    "args": "{α : Type u_1} [boolean_ring α]",
    "doc_string": "The meet operation in a Boolean ring is `x * y`.",
    "kind": "def",
    "type": "has_inf α"
  },
  {
    "name": "tactic.new_goals",
    "statement": "inductive tactic.new_goals  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " How to order the new goals made from an `apply` tactic. Supposing we were applying `e : ∀ (a:α) (p : P(a)), Q` - `non_dep_first` would produce goals `⊢ P(?m)`, `⊢ α`. It puts the P goal at the front because none of the arguments after `p` in `e` depend on `p`. It doesn't matter what the result `Q` depends on. - `non_dep_only` would produce goal `⊢ P(?m)`. - `all` would produce goals `⊢ α`, `⊢ P(?m)`.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "lie_algebra.symplectic.sp",
    "statement": "def lie_algebra.symplectic.sp (l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l ⊕ l) (l ⊕ l) R)",
    "theorem": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (l ⊕ l) (l ⊕ l) R)",
    "args": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l]",
    "doc_string": " The symplectic Lie algebra: skew-adjoint matrices with respect to the canonical skew-symmetric bilinear form.",
    "kind": "def",
    "type": "lie_subalgebra R (matrix (l ⊕ l) (l ⊕ l) R)"
  },
  {
    "name": "add_con.gi",
    "statement": "def add_con.gi (M : Type u_1) [has_add M] : galois_insertion add_con_gen coe_fn",
    "theorem": "(M : Type u_1) [has_add M] : galois_insertion add_con_gen coe_fn",
    "args": "(M : Type u_1) [has_add M]",
    "doc_string": "There is a Galois insertion of additive congruence relations on a type with an addition `M` into binary relations on `M`.",
    "kind": "def",
    "type": "galois_insertion add_con_gen coe_fn"
  },
  {
    "name": "emetric.diam_empty",
    "statement": "theorem emetric.diam_empty {α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0",
    "theorem": "{α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0",
    "args": "{α : Type u} [pseudo_emetric_space α]",
    "doc_string": "The diameter of the empty set vanishes",
    "kind": "theorem",
    "type": "emetric.diam ∅ = 0"
  },
  {
    "name": "list.encodable",
    "statement": "def list.encodable {α : Type u_1} [encodable α] : encodable (list α)",
    "theorem": "{α : Type u_1} [encodable α] : encodable (list α)",
    "args": "{α : Type u_1} [encodable α]",
    "doc_string": " If `α` is encodable, then so is `list α`. This uses the `mkpair` and `unpair` functions from `data.nat.pairing`.",
    "kind": "def",
    "type": "encodable (list α)"
  },
  {
    "name": "modular_group.T",
    "statement": "def modular_group.T  : matrix.special_linear_group (fin 2) ℤ",
    "theorem": " : matrix.special_linear_group (fin 2) ℤ",
    "args": "",
    "doc_string": "The matrix `T = [[1,1],[0,1]]` as an element of `SL(2,ℤ)`",
    "kind": "def",
    "type": "matrix.special_linear_group (fin 2) ℤ"
  },
  {
    "name": "bot_hom.comp",
    "statement": "def bot_hom.comp {α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_bot α] [has_bot β] [has_bot γ] (f : bot_hom β γ) (g : bot_hom α β) : bot_hom α γ",
    "theorem": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_bot α] [has_bot β] [has_bot γ] (f : bot_hom β γ) (g : bot_hom α β) : bot_hom α γ",
    "args": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_bot α] [has_bot β] [has_bot γ] (f : bot_hom β γ) (g : bot_hom α β)",
    "doc_string": "Composition of `bot_hom`s as a `bot_hom`.",
    "kind": "def",
    "type": "bot_hom α γ"
  },
  {
    "name": "tensor_algebra",
    "statement": "def tensor_algebra (R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type (max u_1 u_2)",
    "theorem": "(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : Type (max u_1 u_2)",
    "args": "(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M]",
    "doc_string": "The tensor algebra of the module `M` over the commutative semiring `R`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "rel_hom.coe_fn_injective",
    "statement": "theorem rel_hom.coe_fn_injective {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop}",
    "doc_string": "The map `coe_fn : (r →r s) → (α → β)` is injective.",
    "kind": "theorem",
    "type": "function.injective coe_fn"
  },
  {
    "name": "resolvent_set",
    "statement": "def resolvent_set (R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R",
    "theorem": "(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R",
    "args": "(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A)",
    "doc_string": " Given a commutative ring `R` and an `R`-algebra `A`, the *resolvent set* of `a : A` is the `set R` consisting of those `r : R` for which `r•1 - a` is a unit of the algebra `A`.",
    "kind": "def",
    "type": "set R"
  },
  {
    "name": "arity.const",
    "statement": "def arity.const {α : Type u} (a : α) (n : ℕ) : arity α n",
    "theorem": "{α : Type u} (a : α) (n : ℕ) : arity α n",
    "args": "{α : Type u} (a : α) (n : ℕ)",
    "doc_string": "Constant `n`-ary function with value `a`.",
    "kind": "def",
    "type": "arity α n"
  },
  {
    "name": "is_add_hom.id",
    "statement": "theorem is_add_hom.id {α : Type u} [has_add α] : is_add_hom id",
    "theorem": "{α : Type u} [has_add α] : is_add_hom id",
    "args": "{α : Type u} [has_add α]",
    "doc_string": "The identity map preserves addition",
    "kind": "theorem",
    "type": "is_add_hom id"
  },
  {
    "name": "nat.count_set.fintype",
    "statement": "def nat.count_set.fintype (p : ℕ → Prop) [decidable_pred p] (n : ℕ) : fintype {i // i < n ∧ p i}",
    "theorem": "(p : ℕ → Prop) [decidable_pred p] (n : ℕ) : fintype {i // i < n ∧ p i}",
    "args": "(p : ℕ → Prop) [decidable_pred p] (n : ℕ)",
    "doc_string": "A fintype instance for the set relevant to `nat.count`. Locally an instance in locale `count`",
    "kind": "def",
    "type": "fintype {i // i < n ∧ p i}"
  },
  {
    "name": "pSet.of_nat",
    "statement": "def pSet.of_nat  : ℕ → pSet",
    "theorem": " : ℕ → pSet",
    "args": "",
    "doc_string": "The n-th von Neumann ordinal",
    "kind": "def",
    "type": "ℕ → pSet"
  },
  {
    "name": "module_info.module_id",
    "statement": "def module_info.module_id  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The absolute path to the `.lean` file containing the module (e.g. `\".../data/dlist.lean\"`).",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "witt_vector.recursion_main.succ_nth_defining_poly",
    "statement": "def witt_vector.recursion_main.succ_nth_defining_poly (p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ℕ) (a₁ a₂ : witt_vector p k) (bs : fin (n + 1) → k) : polynomial k",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ℕ) (a₁ a₂ : witt_vector p k) (bs : fin (n + 1) → k) : polynomial k",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ℕ) (a₁ a₂ : witt_vector p k) (bs : fin (n + 1) → k)",
    "doc_string": "The root of this polynomial determines the `n+1`st coefficient of our solution.",
    "kind": "def",
    "type": "polynomial k"
  },
  {
    "name": "is_separable.of_finite",
    "statement": "def is_separable.of_finite (F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] [finite_dimensional F K] [char_zero F] : is_separable F K",
    "theorem": "(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] [finite_dimensional F K] [char_zero F] : is_separable F K",
    "args": "(F : Type u_1) (K : Type u_2) [field F] [field K] [algebra F K] [finite_dimensional F K] [char_zero F]",
    "doc_string": "A finite field extension in characteristic 0 is separable.",
    "kind": "def",
    "type": "is_separable F K"
  },
  {
    "name": "pfunctor.approx.path",
    "statement": "def pfunctor.approx.path (F : pfunctor) : Type u",
    "theorem": "(F : pfunctor) : Type u",
    "args": "(F : pfunctor)",
    "doc_string": "`path F` provides indices to access internal nodes in `corec F`",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "name.add_prime",
    "statement": "def name.add_prime  : name → name",
    "theorem": " : name → name",
    "args": "",
    "doc_string": "Appends `'` to the end of a name.",
    "kind": "def",
    "type": "name → name"
  },
  {
    "name": "projectivization",
    "statement": "def projectivization (K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : Type u_2",
    "theorem": "(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V] : Type u_2",
    "args": "(K : Type u_1) (V : Type u_2) [field K] [add_comm_group V] [module K V]",
    "doc_string": " The projectivization of the `K`-vector space `V`. The notation `ℙ K V` is preferred.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "Top.sheaf.is_terminal_of_empty",
    "statement": "def Top.sheaf.is_terminal_of_empty {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.sheaf C X) : category_theory.limits.is_terminal (F.val.obj (opposite.op ∅))",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.sheaf C X) : category_theory.limits.is_terminal (F.val.obj (opposite.op ∅))",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.sheaf C X)",
    "doc_string": "The empty component of a sheaf is terminal",
    "kind": "def",
    "type": "category_theory.limits.is_terminal (F.val.obj (opposite.op ∅))"
  },
  {
    "name": "spectral_map_class",
    "statement": "structure spectral_map_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [topological_space β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [topological_space β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [topological_space β]",
    "doc_string": " `spectral_map_class F α β` states that `F` is a type of spectral maps.  You should extend this class when you extend `spectral_map`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "list.zip_right",
    "statement": "def list.zip_right {α : Type u_1} {β : Type u_2} : list α → list β → list (option α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} : list α → list β → list (option α × β)",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": "Right-biased version of `list.zip`. `zip_right as bs` returns the list of pairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, the remaining `bᵢ` are paired with `none`.  ```lean zip_right [1, 2] ['a'] = [(some 1, 'a')]  zip_right [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]  zip_right = map₂_right prod.mk ```",
    "kind": "def",
    "type": "list α → list β → list (option α × β)"
  },
  {
    "name": "char_prime_of_ne_zero",
    "statement": "theorem char_prime_of_ne_zero (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p",
    "args": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0)",
    "doc_string": "A helper lemma: the characteristic is prime if it is non-zero.",
    "kind": "theorem",
    "type": "nat.prime p"
  },
  {
    "name": "fintype_of_fintype_ne",
    "statement": "def fintype_of_fintype_ne {α : Type u_1} (a : α) [decidable_pred (λ (_x : α), _x = a)] (h : fintype {b // b ≠ a}) : fintype α",
    "theorem": "{α : Type u_1} (a : α) [decidable_pred (λ (_x : α), _x = a)] (h : fintype {b // b ≠ a}) : fintype α",
    "args": "{α : Type u_1} (a : α) [decidable_pred (λ (_x : α), _x = a)] (h : fintype {b // b ≠ a})",
    "doc_string": "If the subtype of all-but-one elements is a `fintype` then the type itself is a `fintype`.",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "category_theory.limits.has_wide_pushouts",
    "statement": "def category_theory.limits.has_wide_pushouts (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_wide_pushouts` represents a choice of wide pushout for every collection of morphisms",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subgroup.mul_mem",
    "statement": "theorem subgroup.mul_mem {G : Type u_1} [group G] (H : subgroup G) {x y : G} : x ∈ H → y ∈ H → x * y ∈ H",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) {x y : G} : x ∈ H → y ∈ H → x * y ∈ H",
    "args": "{G : Type u_1} [group G] (H : subgroup G) {x y : G}",
    "doc_string": "A subgroup is closed under multiplication.",
    "kind": "theorem",
    "type": "x ∈ H → y ∈ H → x * y ∈ H"
  },
  {
    "name": "set.finite",
    "statement": "inductive set.finite {α : Type u} (s : set α) : Prop",
    "theorem": "{α : Type u} (s : set α) : Prop",
    "args": "{α : Type u} (s : set α)",
    "doc_string": " A set is finite if there is a `finset` with the same elements. This is represented as there being a `fintype` instance for the set coerced to a type.  Note: this is a custom inductive type rather than `nonempty (fintype s)` so that it won't be frozen as a local instance.",
    "kind": "inductive",
    "type": "Prop"
  },
  {
    "name": "stream.drop",
    "statement": "def stream.drop {α : Type u} (n : ℕ) (s : stream α) : stream α",
    "theorem": "{α : Type u} (n : ℕ) (s : stream α) : stream α",
    "args": "{α : Type u} (n : ℕ) (s : stream α)",
    "doc_string": "Drop first `n` elements of a stream.",
    "kind": "def",
    "type": "stream α"
  },
  {
    "name": "onote.scale",
    "statement": "def onote.scale (x : onote) : onote → onote",
    "theorem": "(x : onote) : onote → onote",
    "args": "(x : onote)",
    "doc_string": "`scale x o` is the ordinal notation for `ω ^ x * o`.",
    "kind": "def",
    "type": "onote → onote"
  },
  {
    "name": "hash_map.erase",
    "statement": "def hash_map.erase {α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α) : hash_map α β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α) : hash_map α β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α)",
    "doc_string": "Remove a key from the map. (Modifies `m` in-place when applicable)",
    "kind": "def",
    "type": "hash_map α β"
  },
  {
    "name": "list.modify_nth",
    "statement": "def list.modify_nth {α : Type u_1} (f : α → α) : ℕ → list α → list α",
    "theorem": "{α : Type u_1} (f : α → α) : ℕ → list α → list α",
    "args": "{α : Type u_1} (f : α → α)",
    "doc_string": "Apply `f` to the nth element of the list, if it exists.",
    "kind": "def",
    "type": "ℕ → list α → list α"
  },
  {
    "name": "with_top.mul_zero_one_class",
    "statement": "def with_top.mul_zero_one_class {α : Type u} [decidable_eq α] [mul_zero_one_class α] [nontrivial α] : mul_zero_one_class (with_top α)",
    "theorem": "{α : Type u} [decidable_eq α] [mul_zero_one_class α] [nontrivial α] : mul_zero_one_class (with_top α)",
    "args": "{α : Type u} [decidable_eq α] [mul_zero_one_class α] [nontrivial α]",
    "doc_string": "`nontrivial α` is needed here as otherwise we have `1 * ⊤ = ⊤` but also `= 0 * ⊤ = 0`.",
    "kind": "def",
    "type": "mul_zero_one_class (with_top α)"
  },
  {
    "name": "submodule.semiring",
    "statement": "def submodule.semiring {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : semiring (submodule R A)",
    "theorem": "{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : semiring (submodule R A)",
    "args": "{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A]",
    "doc_string": "Sub-R-modules of an R-algebra form a semiring.",
    "kind": "def",
    "type": "semiring (submodule R A)"
  },
  {
    "name": "convex_cone.positive_cone",
    "statement": "def convex_cone.positive_cone (𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [ordered_add_comm_group E] [module 𝕜 E] [ordered_smul 𝕜 E] : convex_cone 𝕜 E",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [ordered_add_comm_group E] [module 𝕜 E] [ordered_smul 𝕜 E] : convex_cone 𝕜 E",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [ordered_add_comm_group E] [module 𝕜 E] [ordered_smul 𝕜 E]",
    "doc_string": "The positive cone is the convex cone formed by the set of nonnegative elements in an ordered module.",
    "kind": "def",
    "type": "convex_cone 𝕜 E"
  },
  {
    "name": "ordnode.map",
    "statement": "def ordnode.map {α : Type u} {β : Type u_1} (f : α → β) : ordnode α → ordnode β",
    "theorem": "{α : Type u} {β : Type u_1} (f : α → β) : ordnode α → ordnode β",
    "args": "{α : Type u} {β : Type u_1} (f : α → β)",
    "doc_string": " O(n). Map a function across a tree, without changing the structure. Only valid when the function is strictly monotone, i.e. `x < y → f x < f y`.       partition (λ x, x + 2) {1, 2, 4} = {2, 3, 6}      partition (λ x : ℕ, x - 2) {1, 2, 4} = precondition violation",
    "kind": "def",
    "type": "ordnode α → ordnode β"
  },
  {
    "name": "set_like.has_graded_mul",
    "statement": "structure set_like.has_graded_mul {ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_mul R] [has_add ι] (A : ι → S) : Prop",
    "theorem": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_mul R] [has_add ι] (A : ι → S) : Prop",
    "args": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [has_mul R] [has_add ι] (A : ι → S)",
    "doc_string": "A version of `graded_monoid.ghas_one` for internally graded objects.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "Meas.of",
    "statement": "def Meas.of (α : Type u) [measurable_space α] : Meas",
    "theorem": "(α : Type u) [measurable_space α] : Meas",
    "args": "(α : Type u) [measurable_space α]",
    "doc_string": "Construct a bundled `Meas` from the underlying type and the typeclass.",
    "kind": "def",
    "type": "Meas"
  },
  {
    "name": "has_dvd.dvd.trans",
    "statement": "theorem has_dvd.dvd.trans {α : Type u_1} [semigroup α] {a b c : α} : a ∣ b → b ∣ c → a ∣ c",
    "theorem": "{α : Type u_1} [semigroup α] {a b c : α} : a ∣ b → b ∣ c → a ∣ c",
    "args": "{α : Type u_1} [semigroup α] {a b c : α}",
    "doc_string": "**Alias** of dvd_trans`.",
    "kind": "theorem",
    "type": "a ∣ b → b ∣ c → a ∣ c"
  },
  {
    "name": "subsingleton_fin_one",
    "statement": "def subsingleton_fin_one  : subsingleton (fin 1)",
    "theorem": " : subsingleton (fin 1)",
    "args": "",
    "doc_string": "`fin 1` is a subsingleton.",
    "kind": "def",
    "type": "subsingleton (fin 1)"
  },
  {
    "name": "topological_space.compacts.map",
    "statement": "def topological_space.compacts.map {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (hf : continuous f) (K : topological_space.compacts α) : topological_space.compacts β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (hf : continuous f) (K : topological_space.compacts α) : topological_space.compacts β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (hf : continuous f) (K : topological_space.compacts α)",
    "doc_string": "The image of a compact set under a continuous function.",
    "kind": "def",
    "type": "topological_space.compacts β"
  },
  {
    "name": "CpltSepUniformSpace.to_UniformSpace",
    "statement": "def CpltSepUniformSpace.to_UniformSpace (X : CpltSepUniformSpace) : UniformSpace",
    "theorem": "(X : CpltSepUniformSpace) : UniformSpace",
    "args": "(X : CpltSepUniformSpace)",
    "doc_string": "The function forgetting that a complete separated uniform spaces is complete and separated.",
    "kind": "def",
    "type": "UniformSpace"
  },
  {
    "name": "seq.destruct",
    "statement": "def seq.destruct {α : Type u} (s : seq α) : option (seq1 α)",
    "theorem": "{α : Type u} (s : seq α) : option (seq1 α)",
    "args": "{α : Type u} (s : seq α)",
    "doc_string": "Destructor for a sequence, resulting in either `none` (for `nil`) or  `some (a, s)` (for `cons a s`).",
    "kind": "def",
    "type": "option (seq1 α)"
  },
  {
    "name": "free_product.neword.to_list",
    "statement": "def free_product.neword.to_list {ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : list (Σ (i : ι), M i)",
    "theorem": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : list (Σ (i : ι), M i)",
    "args": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j)",
    "doc_string": "The list represented by a given `neword`",
    "kind": "def",
    "type": "list (Σ (i : ι), M i)"
  },
  {
    "name": "slim_check.large",
    "statement": "def slim_check.large (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Type tag that signals to `slim_check` to use large values for a given type.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "submodule.annihilator",
    "statement": "def submodule.annihilator {R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : ideal R",
    "theorem": "{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : ideal R",
    "args": "{R : Type u} {M : Type v} [comm_semiring R] [add_comm_monoid M] [module R M] (N : submodule R M)",
    "doc_string": "`N.annihilator` is the ideal of all elements `r : R` such that `r • N = 0`.",
    "kind": "def",
    "type": "ideal R"
  },
  {
    "name": "ideal.polynomial_not_is_field",
    "statement": "theorem ideal.polynomial_not_is_field {R : Type u} [ring R] : ¬is_field (polynomial R)",
    "theorem": "{R : Type u} [ring R] : ¬is_field (polynomial R)",
    "args": "{R : Type u} [ring R]",
    "doc_string": "`polynomial R` is never a field for any ring `R`.",
    "kind": "theorem",
    "type": "¬is_field (polynomial R)"
  },
  {
    "name": "submodule.has_one",
    "statement": "def submodule.has_one {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_one (submodule R A)",
    "theorem": "{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_one (submodule R A)",
    "args": "{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A]",
    "doc_string": "`1 : submodule R A` is the submodule R of A.",
    "kind": "def",
    "type": "has_one (submodule R A)"
  },
  {
    "name": "continuous_monoid_hom",
    "statement": "structure continuous_monoid_hom (A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : Type (max u_4 u_5)",
    "theorem": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : Type (max u_4 u_5)",
    "args": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B]",
    "doc_string": " The type of continuous monoid homomorphisms from `α` to `β`.  When possible, instead of parametrizing results over `(f : continuous_monoid_hom α β)`, you should parametrize over `(F : Type*) [continuous_monoid_hom_class F α β] (f : F)`.  When you extend this structure, make sure to extend `continuous_add_monoid_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "add_units.simps.coe",
    "statement": "def add_units.simps.coe {α : Type u} [add_monoid α] (u : add_units α) : α",
    "theorem": "{α : Type u} [add_monoid α] (u : add_units α) : α",
    "args": "{α : Type u} [add_monoid α] (u : add_units α)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "list.sorted_insertion_sort",
    "statement": "theorem list.sorted_insertion_sort {α : Type uu} (r : α → α → Prop) [decidable_rel r] [is_total α r] [is_trans α r] (l : list α) : list.sorted r (list.insertion_sort r l)",
    "theorem": "{α : Type uu} (r : α → α → Prop) [decidable_rel r] [is_total α r] [is_trans α r] (l : list α) : list.sorted r (list.insertion_sort r l)",
    "args": "{α : Type uu} (r : α → α → Prop) [decidable_rel r] [is_total α r] [is_trans α r] (l : list α)",
    "doc_string": "The list `list.insertion_sort r l` is `list.sorted` with respect to `r`.",
    "kind": "theorem",
    "type": "list.sorted r (list.insertion_sort r l)"
  },
  {
    "name": "list.choose_x",
    "statement": "def list.choose_x {α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) (hp : ∃ (a : α), a ∈ l ∧ p a) : {a // a ∈ l ∧ p a}",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) (hp : ∃ (a : α), a ∈ l ∧ p a) : {a // a ∈ l ∧ p a}",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) (hp : ∃ (a : α), a ∈ l ∧ p a)",
    "doc_string": " Given a decidable predicate `p` and a proof of existence of `a ∈ l` such that `p a`, choose the first element with this property. This version returns both `a` and proofs of `a ∈ l` and `p a`.",
    "kind": "def",
    "type": "{a // a ∈ l ∧ p a}"
  },
  {
    "name": "hash_map.inhabited",
    "statement": "def hash_map.inhabited {β : ℕ → Type u_1} : inhabited (hash_map ℕ β)",
    "theorem": "{β : ℕ → Type u_1} : inhabited (hash_map ℕ β)",
    "args": "{β : ℕ → Type u_1}",
    "doc_string": "`hash_map` with key type `nat` and value type that may vary.",
    "kind": "def",
    "type": "inhabited (hash_map ℕ β)"
  },
  {
    "name": "category_theory.functor.const.category_theory.faithful",
    "statement": "def category_theory.functor.const.category_theory.faithful (J : Type u₁) [category_theory.category J] {C : Type u₂} [category_theory.category C] [nonempty J] : category_theory.faithful (category_theory.functor.const J)",
    "theorem": "(J : Type u₁) [category_theory.category J] {C : Type u₂} [category_theory.category C] [nonempty J] : category_theory.faithful (category_theory.functor.const J)",
    "args": "(J : Type u₁) [category_theory.category J] {C : Type u₂} [category_theory.category C] [nonempty J]",
    "doc_string": "If `J` is nonempty, then the constant functor over `J` is faithful.",
    "kind": "def",
    "type": "category_theory.faithful (category_theory.functor.const J)"
  },
  {
    "name": "subgroup.copy",
    "statement": "def subgroup.copy {G : Type u_1} [group G] (K : subgroup G) (s : set G) (hs : s = ↑K) : subgroup G",
    "theorem": "{G : Type u_1} [group G] (K : subgroup G) (s : set G) (hs : s = ↑K) : subgroup G",
    "args": "{G : Type u_1} [group G] (K : subgroup G) (s : set G) (hs : s = ↑K)",
    "doc_string": " Copy of a subgroup with a new `carrier` equal to the old one. Useful to fix definitional equalities.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "gcd_monoid_of_exists_gcd",
    "statement": "def gcd_monoid_of_exists_gcd {α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c) : gcd_monoid α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c) : gcd_monoid α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c)",
    "doc_string": "Define a `gcd_monoid` structure on a monoid just from the existence of a `gcd`.",
    "kind": "def",
    "type": "gcd_monoid α"
  },
  {
    "name": "linear_recurrence.sol_space",
    "statement": "def linear_recurrence.sol_space {α : Type u_1} [comm_semiring α] (E : linear_recurrence α) : submodule α (ℕ → α)",
    "theorem": "{α : Type u_1} [comm_semiring α] (E : linear_recurrence α) : submodule α (ℕ → α)",
    "args": "{α : Type u_1} [comm_semiring α] (E : linear_recurrence α)",
    "doc_string": "The space of solutions of `E`, as a `submodule` over `α` of the module `ℕ → α`.",
    "kind": "def",
    "type": "submodule α (ℕ → α)"
  },
  {
    "name": "set.definable₂",
    "statement": "def set.definable₂ {M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set (M × M)) : Prop",
    "theorem": "{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set (M × M)) : Prop",
    "args": "{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set (M × M))",
    "doc_string": "A 2-dimensional version of `definable`, for `set (M × M)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pnat.xgcd_type.is_reduced",
    "statement": "def pnat.xgcd_type.is_reduced (u : pnat.xgcd_type) : Prop",
    "theorem": "(u : pnat.xgcd_type) : Prop",
    "args": "(u : pnat.xgcd_type)",
    "doc_string": "is_reduced holds if the two entries in the vector are the same.  The reduction algorithm will produce a system with this property, whose product vector is the same as for the original system.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "uniformity",
    "statement": "def uniformity (α : Type u) [uniform_space α] : filter (α × α)",
    "theorem": "(α : Type u) [uniform_space α] : filter (α × α)",
    "args": "(α : Type u) [uniform_space α]",
    "doc_string": "The uniformity is a filter on α × α (inferred from an ambient uniform space  structure on α).",
    "kind": "def",
    "type": "filter (α × α)"
  },
  {
    "name": "function.inv_on_fixed_pts_comp",
    "statement": "theorem function.inv_on_fixed_pts_comp {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))",
    "args": "{α : Type u} {β : Type v} (f : α → β) (g : β → α)",
    "doc_string": " Any two maps `f : α → β` and `g : β → α` are inverse of each other on the sets of fixed points of `f ∘ g` and `g ∘ f`, respectively.",
    "kind": "theorem",
    "type": "set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))"
  },
  {
    "name": "set.equitable_on",
    "statement": "def set.equitable_on {α : Type u_1} {β : Type u_2} [has_le β] [has_add β] [has_one β] (s : set α) (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_le β] [has_add β] [has_one β] (s : set α) (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [has_le β] [has_add β] [has_one β] (s : set α) (f : α → β)",
    "doc_string": "A set is equitable if no element value is more than one bigger than another.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "int.dvd_sub_of_mod_eq",
    "statement": "theorem int.dvd_sub_of_mod_eq {a b c : ℤ} (h : a % b = c) : b ∣ a - c",
    "theorem": "{a b c : ℤ} (h : a % b = c) : b ∣ a - c",
    "args": "{a b c : ℤ} (h : a % b = c)",
    "doc_string": "If `a % b = c` then `b` divides `a - c`.",
    "kind": "theorem",
    "type": "b ∣ a - c"
  },
  {
    "name": "is_localization.card_le",
    "statement": "theorem is_localization.card_le {R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ≤ cardinal.mk R",
    "theorem": "{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ≤ cardinal.mk R",
    "args": "{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L]",
    "doc_string": "A localization always has cardinality less than or equal to the base ring.",
    "kind": "theorem",
    "type": "cardinal.mk L ≤ cardinal.mk R"
  },
  {
    "name": "is_add_monoid_hom",
    "statement": "structure is_add_monoid_hom {α : Type u} {β : Type v} [add_zero_class α] [add_zero_class β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [add_zero_class α] [add_zero_class β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [add_zero_class α] [add_zero_class β] (f : α → β)",
    "doc_string": "Predicate for add_monoid homomorphisms (deprecated -- use the bundled `monoid_hom` version).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "composition.sigma_eq_iff_blocks_eq",
    "statement": "theorem composition.sigma_eq_iff_blocks_eq {c c' : Σ (n : ℕ), composition n} : c = c' ↔ c.snd.blocks = c'.snd.blocks",
    "theorem": "{c c' : Σ (n : ℕ), composition n} : c = c' ↔ c.snd.blocks = c'.snd.blocks",
    "args": "{c c' : Σ (n : ℕ), composition n}",
    "doc_string": " Two compositions (possibly of different integers) coincide if and only if they have the same sequence of blocks.",
    "kind": "theorem",
    "type": "c = c' ↔ c.snd.blocks = c'.snd.blocks"
  },
  {
    "name": "measure_theory.is_stopping_time",
    "statement": "def measure_theory.is_stopping_time {α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] (f : measure_theory.filtration ι m) (τ : α → ι) : Prop",
    "theorem": "{α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] (f : measure_theory.filtration ι m) (τ : α → ι) : Prop",
    "args": "{α : Type u_1} {ι : Type u_3} {m : measurable_space α} [preorder ι] (f : measure_theory.filtration ι m) (τ : α → ι)",
    "doc_string": " A stopping time with respect to some filtration `f` is a function `τ` such that for all `i`, the preimage of `{j | j ≤ i}` along `τ` is measurable with respect to `f i`.  Intuitively, the stopping time `τ` describes some stopping rule such that at time `i`, we may determine it with the information we have at time `i`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "has_dvd.dvd.nat_cast",
    "statement": "theorem has_dvd.dvd.nat_cast {α : Type u_1} [semiring α] {m n : ℕ} (h : m ∣ n) : ↑m ∣ ↑n",
    "theorem": "{α : Type u_1} [semiring α] {m n : ℕ} (h : m ∣ n) : ↑m ∣ ↑n",
    "args": "{α : Type u_1} [semiring α] {m n : ℕ} (h : m ∣ n)",
    "doc_string": "**Alias** of nat.coe_nat_dvd`.",
    "kind": "theorem",
    "type": "↑m ∣ ↑n"
  },
  {
    "name": "uv.is_compressed_self",
    "statement": "theorem uv.is_compressed_self {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u : α) (s : finset α) : uv.is_compressed u u s",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u : α) (s : finset α) : uv.is_compressed u u s",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u : α) (s : finset α)",
    "doc_string": "Any family is compressed along two identical elements.",
    "kind": "theorem",
    "type": "uv.is_compressed u u s"
  },
  {
    "name": "add_submonoid.add_mem",
    "statement": "theorem add_submonoid.add_mem {M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S",
    "theorem": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S",
    "args": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M) {x y : M}",
    "doc_string": "An `add_submonoid` is closed under addition.",
    "kind": "theorem",
    "type": "x ∈ S → y ∈ S → x + y ∈ S"
  },
  {
    "name": "znum.add",
    "statement": "def znum.add  : znum → znum → znum",
    "theorem": " : znum → znum → znum",
    "args": "",
    "doc_string": "Addition of `znum`s.",
    "kind": "def",
    "type": "znum → znum → znum"
  },
  {
    "name": "category_theory.has_lifting_property",
    "statement": "structure category_theory.has_lifting_property {C : Type u} [category_theory.category C] (i p : category_theory.arrow C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (i p : category_theory.arrow C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (i p : category_theory.arrow C)",
    "doc_string": " The lifting property of a morphism `i` with respect to a morphism `p`. This can be interpreted as the right lifting property of `i` with respect to `p`, or the left lifting property of `p` with respect to `i`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "wide_subquiver.to_Type",
    "statement": "def wide_subquiver.to_Type (V : Type u) [quiver V] (H : wide_subquiver V) : Type u",
    "theorem": "(V : Type u) [quiver V] (H : wide_subquiver V) : Type u",
    "args": "(V : Type u) [quiver V] (H : wide_subquiver V)",
    "doc_string": " A type synonym for `V`, when thought of as a quiver having only the arrows from some `wide_subquiver`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "has_sum",
    "statement": "def has_sum {α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] (f : β → α) (a : α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] (f : β → α) (a : α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] (f : β → α) (a : α)",
    "doc_string": " Infinite sum on a topological monoid  The `at_top` filter on `finset β` is the limit of all finite sets towards the entire type. So we sum up bigger and bigger sets. This sum operation is invariant under reordering. In particular, the function `ℕ → ℝ` sending `n` to `(-1)^n / (n+1)` does not have a sum for this definition, but a series which is absolutely convergent will have the correct sum.  This is based on Mario Carneiro's [infinite sum `df-tsms` in Metamath](http://us.metamath.org/mpeuni/df-tsms.html).  For the definition or many statements, `α` does not need to be a topological monoid. We only add this assumption later, for the lemmas where it is relevant.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_aut.apply_distrib_mul_action",
    "statement": "def add_aut.apply_distrib_mul_action {A : Type u_1} [add_monoid A] : distrib_mul_action (add_aut A) A",
    "theorem": "{A : Type u_1} [add_monoid A] : distrib_mul_action (add_aut A) A",
    "args": "{A : Type u_1} [add_monoid A]",
    "doc_string": " The tautological action by `add_aut A` on `A`.  This generalizes `function.End.apply_mul_action`.",
    "kind": "def",
    "type": "distrib_mul_action (add_aut A) A"
  },
  {
    "name": "finite_dimensional",
    "statement": "def finite_dimensional (K : Type u_1) (V : Type u_2) [division_ring K] [add_comm_group V] [module K V] : Prop",
    "theorem": "(K : Type u_1) (V : Type u_2) [division_ring K] [add_comm_group V] [module K V] : Prop",
    "args": "(K : Type u_1) (V : Type u_2) [division_ring K] [add_comm_group V] [module K V]",
    "doc_string": " `finite_dimensional` vector spaces are defined to be finite modules. Use `finite_dimensional.of_fintype_basis` to prove finite dimension from another definition.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "can_lift",
    "statement": "structure can_lift (α : Sort u_1) (β : Sort u_2) : Sort (max 1 (imax u_2 u_1) u_1)",
    "theorem": "(α : Sort u_1) (β : Sort u_2) : Sort (max 1 (imax u_2 u_1) u_1)",
    "args": "(α : Sort u_1) (β : Sort u_2)",
    "doc_string": "A class specifying that you can lift elements from `α` to `β` assuming `cond` is true.  Used by the tactic `lift`.",
    "kind": "structure",
    "type": "Sort (max 1 (imax u_2 u_1) u_1)"
  },
  {
    "name": "matrix.det",
    "statement": "def matrix.det {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : R",
    "theorem": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : R",
    "args": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R)",
    "doc_string": "The determinant of a matrix given by the Leibniz formula.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "metric.bounded.mono",
    "statement": "theorem metric.bounded.mono {α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t)",
    "doc_string": "Subsets of a bounded set are also bounded",
    "kind": "theorem",
    "type": "metric.bounded t → metric.bounded s"
  },
  {
    "name": "asymptotics.is_o",
    "statement": "def asymptotics.is_o {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter α) (f : α → E) (g : α → F) : Prop",
    "theorem": "{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter α) (f : α → E) (g : α → F) : Prop",
    "args": "{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter α) (f : α → E) (g : α → F)",
    "doc_string": " The Landau notation `f =o[l] g` where `f` and `g` are two functions on a type `α` and `l` is a filter on `α`, means that eventually for `l`, `∥f∥` is bounded by an arbitrarily small constant multiple of `∥g∥`. In other words, `∥f∥ / ∥g∥` tends to `0` along `l`, modulo division by zero issues that are avoided by this definition.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "first_order.language.bounded_formula.relabel_aux",
    "statement": "def first_order.language.bounded_formula.relabel_aux {α : Type u'} {β : Type v'} {n : ℕ} (g : α → β ⊕ fin n) (k : ℕ) : α ⊕ fin k → β ⊕ fin (n + k)",
    "theorem": "{α : Type u'} {β : Type v'} {n : ℕ} (g : α → β ⊕ fin n) (k : ℕ) : α ⊕ fin k → β ⊕ fin (n + k)",
    "args": "{α : Type u'} {β : Type v'} {n : ℕ} (g : α → β ⊕ fin n) (k : ℕ)",
    "doc_string": "A function to help relabel the variables in bounded formulas.",
    "kind": "def",
    "type": "α ⊕ fin k → β ⊕ fin (n + k)"
  },
  {
    "name": "is_of_fin_add_order.neg",
    "statement": "theorem is_of_fin_add_order.neg {G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)",
    "theorem": "{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)",
    "args": "{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x)",
    "doc_string": "Inverses of elements of finite additive order have finite additive order.",
    "kind": "theorem",
    "type": "is_of_fin_add_order (-x)"
  },
  {
    "name": "has_inf",
    "statement": "structure has_inf (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Typeclass for the `⊓` (`\\glb`) notation",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "besicovitch.tau_package.color",
    "statement": "def besicovitch.tau_package.color {α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) : ordinal → ℕ",
    "theorem": "{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) : ordinal → ℕ",
    "args": "{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α)",
    "doc_string": " Group the balls into disjoint families, by assigning to a ball the smallest color for which it does not intersect any already chosen ball of this color.",
    "kind": "def",
    "type": "ordinal → ℕ"
  },
  {
    "name": "dlist.lazy_of_list",
    "statement": "def dlist.lazy_of_list {α : Type u} (l : thunk (list α)) : dlist α",
    "theorem": "{α : Type u} (l : thunk (list α)) : dlist α",
    "args": "{α : Type u} (l : thunk (list α))",
    "doc_string": "Convert a lazily-evaluated list to a dlist",
    "kind": "def",
    "type": "dlist α"
  },
  {
    "name": "submonoid.multiset_prod_mem",
    "statement": "theorem submonoid.multiset_prod_mem {M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.prod ∈ S",
    "theorem": "{M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.prod ∈ S",
    "args": "{M : Type u_1} [comm_monoid M] (S : submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S)",
    "doc_string": "Product of a multiset of elements in a submonoid of a `comm_monoid` is in the submonoid.",
    "kind": "theorem",
    "type": "m.prod ∈ S"
  },
  {
    "name": "norm_cast.norm_cast_attr_ty",
    "statement": "def norm_cast.norm_cast_attr_ty  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of the `norm_cast` attribute. The optional label is used to overwrite the classifier.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "category_theory.limits.walking_parallel_family",
    "statement": "inductive category_theory.limits.walking_parallel_family (J : Type v) : Type v",
    "theorem": "(J : Type v) : Type v",
    "args": "(J : Type v)",
    "doc_string": "The type of objects for the diagram indexing a wide (co)equalizer.",
    "kind": "inductive",
    "type": "Type v"
  },
  {
    "name": "polynomial.monic",
    "statement": "def polynomial.monic {R : Type u} [semiring R] (p : polynomial R) : Prop",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : Prop",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": "a polynomial is `monic` if its leading coefficient is 1",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "with_zero.canonically_ordered_add_monoid",
    "statement": "def with_zero.canonically_ordered_add_monoid {α : Type u} [canonically_ordered_add_monoid α] : canonically_ordered_add_monoid (with_zero α)",
    "theorem": "{α : Type u} [canonically_ordered_add_monoid α] : canonically_ordered_add_monoid (with_zero α)",
    "args": "{α : Type u} [canonically_ordered_add_monoid α]",
    "doc_string": "Adding a new zero to a canonically ordered additive monoid produces another one.",
    "kind": "def",
    "type": "canonically_ordered_add_monoid (with_zero α)"
  },
  {
    "name": "bool.to_nat",
    "statement": "def bool.to_nat (b : bool) : ℕ",
    "theorem": "(b : bool) : ℕ",
    "args": "(b : bool)",
    "doc_string": "convert a `bool` to a `ℕ`, `false -> 0`, `true -> 1`",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "turing.to_partrec.cfg",
    "statement": "inductive turing.to_partrec.cfg  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The set of configurations of the machine:  * `halt v`: The machine is about to stop and `v : list ℕ` is the result. * `ret k v`: The machine is about to pass `v : list ℕ` to continuation `k : cont`.  We don't have a state corresponding to normal evaluation because these are evaluated immediately to a `ret` \"in zero steps\" using the `step_normal` function.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "free_abelian_group.basis",
    "statement": "def free_abelian_group.basis (α : Type u_1) : basis α ℤ (free_abelian_group α)",
    "theorem": "(α : Type u_1) : basis α ℤ (free_abelian_group α)",
    "args": "(α : Type u_1)",
    "doc_string": "`A` is a basis of the ℤ-module `free_abelian_group A`.",
    "kind": "def",
    "type": "basis α ℤ (free_abelian_group α)"
  },
  {
    "name": "with_zero.group_with_zero",
    "statement": "def with_zero.group_with_zero {α : Type u} [group α] : group_with_zero (with_zero α)",
    "theorem": "{α : Type u} [group α] : group_with_zero (with_zero α)",
    "args": "{α : Type u} [group α]",
    "doc_string": "if `G` is a group then `with_zero G` is a group with zero.",
    "kind": "def",
    "type": "group_with_zero (with_zero α)"
  },
  {
    "name": "category_theory.left_rigid_category",
    "statement": "structure category_theory.left_rigid_category (C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "A left rigid monoidal category is one in which every object has a right dual.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "sum.is_right",
    "statement": "def sum.is_right {α : Type u} {β : Type v} : α ⊕ β → bool",
    "theorem": "{α : Type u} {β : Type v} : α ⊕ β → bool",
    "args": "{α : Type u} {β : Type v}",
    "doc_string": "Check if a sum is `inr`.",
    "kind": "def",
    "type": "α ⊕ β → bool"
  },
  {
    "name": "left_add_coset",
    "statement": "def left_add_coset {α : Type u_1} [has_add α] (a : α) (s : set α) : set α",
    "theorem": "{α : Type u_1} [has_add α] (a : α) (s : set α) : set α",
    "args": "{α : Type u_1} [has_add α] (a : α) (s : set α)",
    "doc_string": "The left coset `a+s` for an element `a : α` and a subset `s : set α`",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "gaussian_int.prime_iff_mod_four_eq_three_of_nat_prime",
    "statement": "theorem gaussian_int.prime_iff_mod_four_eq_three_of_nat_prime (p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4`",
    "kind": "theorem",
    "type": "prime ↑p ↔ p % 4 = 3"
  },
  {
    "name": "presented_group",
    "statement": "def presented_group {α : Type} (rels : set (free_group α)) : Type",
    "theorem": "{α : Type} (rels : set (free_group α)) : Type",
    "args": "{α : Type} (rels : set (free_group α))",
    "doc_string": " Given a set of relations, rels, over a type `α`, presented_group constructs the group with generators `x : α` and relations `rels` as a quotient of free_group `α`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "is_irrefl",
    "statement": "structure is_irrefl (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": " `is_irrefl X r` means the binary relation `r` on `X` is irreflexive (that is, `r x x` never holds).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.cosimplicial_object.truncated",
    "statement": "def category_theory.cosimplicial_object.truncated (C : Type u) [category_theory.category C] (n : ℕ) : Type (max v u)",
    "theorem": "(C : Type u) [category_theory.category C] (n : ℕ) : Type (max v u)",
    "args": "(C : Type u) [category_theory.category C] (n : ℕ)",
    "doc_string": "Truncated cosimplicial objects.",
    "kind": "def",
    "type": "Type (max v u)"
  },
  {
    "name": "Lattice",
    "statement": "def Lattice  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of lattices.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "is_unit_iff_not_dvd_char",
    "statement": "theorem is_unit_iff_not_dvd_char (R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R",
    "theorem": "(R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R",
    "args": "(R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)]",
    "doc_string": " A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic.",
    "kind": "theorem",
    "type": "is_unit ↑p ↔ ¬p ∣ ring_char R"
  },
  {
    "name": "stone_cech_extend",
    "statement": "def stone_cech_extend {α : Type u} [topological_space α] {γ : Type u} [topological_space γ] [t2_space γ] [compact_space γ] {f : α → γ} (hf : continuous f) : stone_cech α → γ",
    "theorem": "{α : Type u} [topological_space α] {γ : Type u} [topological_space γ] [t2_space γ] [compact_space γ] {f : α → γ} (hf : continuous f) : stone_cech α → γ",
    "args": "{α : Type u} [topological_space α] {γ : Type u} [topological_space γ] [t2_space γ] [compact_space γ] {f : α → γ} (hf : continuous f)",
    "doc_string": "The extension of a continuous function from α to a compact  Hausdorff space γ to the Stone-Čech compactification of α.",
    "kind": "def",
    "type": "stone_cech α → γ"
  },
  {
    "name": "dense.of_closure",
    "statement": "theorem dense.of_closure {α : Type u} [topological_space α] {s : set α} : dense (closure s) → dense s",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : dense (closure s) → dense s",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "**Alias** of the forward direction of dense_closure`.",
    "kind": "theorem",
    "type": "dense (closure s) → dense s"
  },
  {
    "name": "matrix.invertible_of_right_inverse",
    "statement": "def matrix.invertible_of_right_inverse {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : A.mul B = 1) : invertible A",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : A.mul B = 1) : invertible A",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : A.mul B = 1)",
    "doc_string": "We can construct an instance of invertible A if A has a right inverse.",
    "kind": "def",
    "type": "invertible A"
  },
  {
    "name": "has_vadd",
    "statement": "structure has_vadd (G : Type u_1) (P : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(G : Type u_1) (P : Type u_2) : Type (max u_1 u_2)",
    "args": "(G : Type u_1) (P : Type u_2)",
    "doc_string": "Type class for the `+ᵥ` notation.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "tactic.itauto.is_ok",
    "statement": "def tactic.itauto.is_ok {α : Type u_1} : bool × α → option α",
    "theorem": "{α : Type u_1} : bool × α → option α",
    "args": "{α : Type u_1}",
    "doc_string": "Convert a value-with-success to an optional value.",
    "kind": "def",
    "type": "bool × α → option α"
  },
  {
    "name": "category_theory.full_subcategory",
    "statement": "def category_theory.full_subcategory {C : Type u₁} [category_theory.category C] (Z : C → Prop) : category_theory.category {X // Z X}",
    "theorem": "{C : Type u₁} [category_theory.category C] (Z : C → Prop) : category_theory.category {X // Z X}",
    "args": "{C : Type u₁} [category_theory.category C] (Z : C → Prop)",
    "doc_string": "The category structure on a subtype; morphisms just ignore the property.  See <https://stacks.math.columbia.edu/tag/001D>. We do not define 'strictly full' subcategories.",
    "kind": "def",
    "type": "category_theory.category {X // Z X}"
  },
  {
    "name": "list.map₂_left",
    "statement": "def list.map₂_left {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → option β → γ) : list α → list β → list γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → option β → γ) : list α → list β → list γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → option β → γ)",
    "doc_string": "Left-biased version of `list.map₂`. `map₂_left f as bs` applies `f` to each pair `aᵢ ∈ as` and `bᵢ ‌∈ bs`. If `bs` is shorter than `as`, `f` is applied to `none` for the remaining `aᵢ`.  ```lean map₂_left prod.mk [1, 2] ['a'] = [(1, some 'a'), (2, none)]  map₂_left prod.mk [1] ['a', 'b'] = [(1, some 'a')]  map₂_left f as bs = (map₂_left' f as bs).fst ```",
    "kind": "def",
    "type": "list α → list β → list γ"
  },
  {
    "name": "subring.to_submonoid",
    "statement": "def subring.to_submonoid {R : Type u} [ring R] (s : subring R) : submonoid R",
    "theorem": "{R : Type u} [ring R] (s : subring R) : submonoid R",
    "args": "{R : Type u} [ring R] (s : subring R)",
    "doc_string": "The underlying submonoid of a subring.",
    "kind": "def",
    "type": "submonoid R"
  },
  {
    "name": "option.pbind",
    "statement": "def option.pbind {α : Type u_1} {β : Type u_2} (x : option α) : (Π (a : α), a ∈ x → option β) → option β",
    "theorem": "{α : Type u_1} {β : Type u_2} (x : option α) : (Π (a : α), a ∈ x → option β) → option β",
    "args": "{α : Type u_1} {β : Type u_2} (x : option α)",
    "doc_string": "Partial bind. If for some `x : option α`, `f : Π (a : α), a ∈ x → option β` is a  partial function defined on `a : α` giving an `option β`, where `some a = x`,  then `pbind x f h` is essentially the same as `bind x f`  but is defined only when all `x = some a`, using the proof to apply `f`.",
    "kind": "def",
    "type": "(Π (a : α), a ∈ x → option β) → option β"
  },
  {
    "name": "is_locally_constant.desc",
    "statement": "theorem is_locally_constant.desc {X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g) : is_locally_constant f",
    "theorem": "{X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g) : is_locally_constant f",
    "args": "{X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g)",
    "doc_string": " If a composition of a function `f` followed by an injection `g` is locally constant, then the locally constant property descends to `f`.",
    "kind": "theorem",
    "type": "is_locally_constant f"
  },
  {
    "name": "csupr_le",
    "statement": "theorem csupr_le {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c)",
    "doc_string": "The indexed supremum of a function is bounded above by a uniform bound",
    "kind": "theorem",
    "type": "supr f ≤ c"
  },
  {
    "name": "seq.of_stream",
    "statement": "def seq.of_stream {α : Type u} (s : stream α) : seq α",
    "theorem": "{α : Type u} (s : stream α) : seq α",
    "args": "{α : Type u} (s : stream α)",
    "doc_string": "Embed an infinite stream as a sequence",
    "kind": "def",
    "type": "seq α"
  },
  {
    "name": "vector_all",
    "statement": "def vector_all {α : Type u_1} (k : ℕ) : (vector3 α k → Prop) → Prop",
    "theorem": "{α : Type u_1} (k : ℕ) : (vector3 α k → Prop) → Prop",
    "args": "{α : Type u_1} (k : ℕ)",
    "doc_string": "\"Curried\" forall, i.e. `∀ x₁ ... xₙ, f [x₁, ..., xₙ]`.",
    "kind": "def",
    "type": "(vector3 α k → Prop) → Prop"
  },
  {
    "name": "nnreal.geom_mean_le_arith_mean2_weighted",
    "statement": "theorem nnreal.geom_mean_le_arith_mean2_weighted (w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂",
    "theorem": "(w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂",
    "args": "(w₁ w₂ p₁ p₂ : nnreal)",
    "doc_string": " The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers.",
    "kind": "theorem",
    "type": "w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂"
  },
  {
    "name": "prime_multiset.of_prime",
    "statement": "def prime_multiset.of_prime (p : nat.primes) : prime_multiset",
    "theorem": "(p : nat.primes) : prime_multiset",
    "args": "(p : nat.primes)",
    "doc_string": "The multiset consisting of a single prime",
    "kind": "def",
    "type": "prime_multiset"
  },
  {
    "name": "int.dvd_of_dvd_mul_right_of_gcd_one",
    "statement": "theorem int.dvd_of_dvd_mul_right_of_gcd_one {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c",
    "theorem": "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c",
    "args": "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1)",
    "doc_string": " Euclid's lemma: if `a ∣ b * c` and `gcd a b = 1` then `a ∣ c`. Compare with `is_coprime.dvd_of_dvd_mul_right` and `unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors`",
    "kind": "theorem",
    "type": "a ∣ c"
  },
  {
    "name": "real.sq_sin_pi_div_three",
    "statement": "theorem real.sq_sin_pi_div_three  : real.sin (real.pi / 3) ^ 2 = 3 / 4",
    "theorem": " : real.sin (real.pi / 3) ^ 2 = 3 / 4",
    "args": "",
    "doc_string": " The square of the sine of `π / 3` is `3 / 4` (this is sometimes more convenient than the result for cosine itself).",
    "kind": "theorem",
    "type": "real.sin (real.pi / 3) ^ 2 = 3 / 4"
  },
  {
    "name": "simple_graph.has_sup",
    "statement": "def simple_graph.has_sup {V : Type u} : has_sup (simple_graph V)",
    "theorem": "{V : Type u} : has_sup (simple_graph V)",
    "args": "{V : Type u}",
    "doc_string": "The supremum of two graphs `x ⊔ y` has edges where either `x` or `y` have edges.",
    "kind": "def",
    "type": "has_sup (simple_graph V)"
  },
  {
    "name": "int.cast_inj_on_of_ring_char_ne_two",
    "statement": "theorem int.cast_inj_on_of_ring_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : set.inj_on coe {0, 1, -1}",
    "theorem": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : set.inj_on coe {0, 1, -1}",
    "args": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2)",
    "doc_string": " If two integers from `{0, 1, -1}` result in equal elements in a ring `R` that is nontrivial and of characteristic not `2`, then they are equal.",
    "kind": "theorem",
    "type": "set.inj_on coe {0, 1, -1}"
  },
  {
    "name": "set.preimage",
    "statement": "def set.preimage {α : Type u} {β : Type v} (f : α → β) (s : set β) : set α",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (s : set β) : set α",
    "args": "{α : Type u} {β : Type v} (f : α → β) (s : set β)",
    "doc_string": "The preimage of `s : set β` by `f : α → β`, written `f ⁻¹' s`,  is the set of `x : α` such that `f x ∈ s`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "tendsto_inv_at_top_zero'",
    "statement": "theorem tendsto_inv_at_top_zero' {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (r : α), r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0))",
    "theorem": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (r : α), r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0))",
    "args": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α]",
    "doc_string": "The function `r ↦ r⁻¹` tends to `0` on the right as `r → +∞`.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (r : α), r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0))"
  },
  {
    "name": "quaternion_group.quaternion_group_one_is_cyclic",
    "statement": "theorem quaternion_group.quaternion_group_one_is_cyclic  : is_cyclic (quaternion_group 1)",
    "theorem": " : is_cyclic (quaternion_group 1)",
    "args": "",
    "doc_string": "In the special case `n = 1`, `quaternion 1` is a cyclic group (of order `4`).",
    "kind": "theorem",
    "type": "is_cyclic (quaternion_group 1)"
  },
  {
    "name": "set.Ioc",
    "statement": "def set.Ioc {α : Type u_1} [preorder α] (a b : α) : set α",
    "theorem": "{α : Type u_1} [preorder α] (a b : α) : set α",
    "args": "{α : Type u_1} [preorder α] (a b : α)",
    "doc_string": "Left-open right-closed interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "category_theory.abelian.non_preadditive_abelian",
    "statement": "def category_theory.abelian.non_preadditive_abelian {C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.non_preadditive_abelian C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.non_preadditive_abelian C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C]",
    "doc_string": "Every abelian category is, in particular, `non_preadditive_abelian`.",
    "kind": "def",
    "type": "category_theory.non_preadditive_abelian C"
  },
  {
    "name": "mvqpf.comp",
    "statement": "def mvqpf.comp {n m : ℕ} (F : typevec n → Type u_1) (G : fin2 n → typevec m → Type u) (v : typevec m) : Type u_1",
    "theorem": "{n m : ℕ} (F : typevec n → Type u_1) (G : fin2 n → typevec m → Type u) (v : typevec m) : Type u_1",
    "args": "{n m : ℕ} (F : typevec n → Type u_1) (G : fin2 n → typevec m → Type u) (v : typevec m)",
    "doc_string": " Composition of an `n`-ary functor with `n` `m`-ary functors gives us one `m`-ary functor",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "free_product.neword.to_word",
    "statement": "def free_product.neword.to_word {ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : free_product.word M",
    "theorem": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : free_product.word M",
    "args": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j)",
    "doc_string": "The `word M` represented by a `neword M i j`",
    "kind": "def",
    "type": "free_product.word M"
  },
  {
    "name": "category_theory.is_codetector",
    "statement": "def category_theory.is_codetector {C : Type u} [category_theory.category C] (G : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (G : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (G : C)",
    "doc_string": "We say that `G` is a codetector if the functor `C(-, G)` reflects isomorphisms.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "measure_theory.simple_func",
    "statement": "structure measure_theory.simple_func (α : Type u) [measurable_space α] (β : Type v) : Type (max u v)",
    "theorem": "(α : Type u) [measurable_space α] (β : Type v) : Type (max u v)",
    "args": "(α : Type u) [measurable_space α] (β : Type v)",
    "doc_string": " A function `f` from a measurable space to any type is called *simple*, if every preimage `f ⁻¹' {x}` is measurable, and the range is finite. This structure bundles a function with these properties.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "euclidean_domain.lcm",
    "statement": "def euclidean_domain.lcm {R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R",
    "theorem": "{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R",
    "args": "{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R)",
    "doc_string": "`lcm a b` is a (non-unique) element such that `a ∣ lcm a b` `b ∣ lcm a b`, and for  any element `c` such that `a ∣ c` and `b ∣ c`, then `lcm a b ∣ c`",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "category_theory.Cat",
    "statement": "def category_theory.Cat  : Type (max (u+1) u (v+1))",
    "theorem": " : Type (max (u+1) u (v+1))",
    "args": "",
    "doc_string": "Category of categories.",
    "kind": "def",
    "type": "Type (max (u+1) u (v+1))"
  },
  {
    "name": "finmap.any",
    "statement": "def finmap.any {α : Type u} {β : α → Type v} (f : Π (x : α), β x → bool) (s : finmap β) : bool",
    "theorem": "{α : Type u} {β : α → Type v} (f : Π (x : α), β x → bool) (s : finmap β) : bool",
    "args": "{α : Type u} {β : α → Type v} (f : Π (x : α), β x → bool) (s : finmap β)",
    "doc_string": "`any f s` returns `tt` iff there exists a value `v` in `s` such that `f v = tt`.",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "exp_char_is_prime_or_one",
    "statement": "theorem exp_char_is_prime_or_one (R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1",
    "args": "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q]",
    "doc_string": "The exponential characteristic is a prime number or one.",
    "kind": "theorem",
    "type": "nat.prime q ∨ q = 1"
  },
  {
    "name": "commute.mul_left",
    "statement": "theorem commute.mul_left {S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c",
    "theorem": "{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c",
    "args": "{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c)",
    "doc_string": "If both `a` and `b` commute with `c`, then their product commutes with `c`.",
    "kind": "theorem",
    "type": "commute (a * b) c"
  },
  {
    "name": "list.rotate",
    "statement": "def list.rotate {α : Type u_1} (l : list α) (n : ℕ) : list α",
    "theorem": "{α : Type u_1} (l : list α) (n : ℕ) : list α",
    "args": "{α : Type u_1} (l : list α) (n : ℕ)",
    "doc_string": "`rotate l n` rotates the elements of `l` to the left by `n`      rotate [0, 1, 2, 3, 4, 5] 2 = [2, 3, 4, 5, 0, 1]",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "measure_theory.simple_func.range",
    "statement": "def measure_theory.simple_func.range {α : Type u_1} {β : Type u_2} [measurable_space α] (f : measure_theory.simple_func α β) : finset β",
    "theorem": "{α : Type u_1} {β : Type u_2} [measurable_space α] (f : measure_theory.simple_func α β) : finset β",
    "args": "{α : Type u_1} {β : Type u_2} [measurable_space α] (f : measure_theory.simple_func α β)",
    "doc_string": "Range of a simple function `α →ₛ β` as a `finset β`.",
    "kind": "def",
    "type": "finset β"
  },
  {
    "name": "rand.random",
    "statement": "def rand.random (α : Type u) {g : Type} [random_gen g] [random α] : rand_g g α",
    "theorem": "(α : Type u) {g : Type} [random_gen g] [random α] : rand_g g α",
    "args": "(α : Type u) {g : Type} [random_gen g] [random α]",
    "doc_string": "Generate a random value of type `α`.",
    "kind": "def",
    "type": "rand_g g α"
  },
  {
    "name": "polynomial.erase_lead",
    "statement": "def polynomial.erase_lead {R : Type u_1} [semiring R] (f : polynomial R) : polynomial R",
    "theorem": "{R : Type u_1} [semiring R] (f : polynomial R) : polynomial R",
    "args": "{R : Type u_1} [semiring R] (f : polynomial R)",
    "doc_string": " `erase_lead f` for a polynomial `f` is the polynomial obtained by subtracting from `f` the leading term of `f`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "submonoid.copy",
    "statement": "def submonoid.copy {M : Type u_1} [mul_one_class M] (S : submonoid M) (s : set M) (hs : s = ↑S) : submonoid M",
    "theorem": "{M : Type u_1} [mul_one_class M] (S : submonoid M) (s : set M) (hs : s = ↑S) : submonoid M",
    "args": "{M : Type u_1} [mul_one_class M] (S : submonoid M) (s : set M) (hs : s = ↑S)",
    "doc_string": "Copy a submonoid replacing `carrier` with a set that is equal to it.",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "bundle.total_space",
    "statement": "def bundle.total_space {B : Type u_1} (E : B → Type u_2) : Type (max u_1 u_2)",
    "theorem": "{B : Type u_1} (E : B → Type u_2) : Type (max u_1 u_2)",
    "args": "{B : Type u_1} (E : B → Type u_2)",
    "doc_string": "`bundle.total_space E` is the total space of the bundle `Σ x, E x`. This type synonym is used to avoid conflicts with general sigma types.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "Scott.is_ωSup",
    "statement": "def Scott.is_ωSup {α : Type u} [preorder α] (c : omega_complete_partial_order.chain α) (x : α) : Prop",
    "theorem": "{α : Type u} [preorder α] (c : omega_complete_partial_order.chain α) (x : α) : Prop",
    "args": "{α : Type u} [preorder α] (c : omega_complete_partial_order.chain α) (x : α)",
    "doc_string": "`x` is an `ω`-Sup of a chain `c` if it is the least upper bound of the range of `c`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.bicompr",
    "statement": "def function.bicompr {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (f : γ → δ) (g : α → β → γ) (a : α) (b : β) : δ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (f : γ → δ) (g : α → β → γ) (a : α) (b : β) : δ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (f : γ → δ) (g : α → β → γ) (a : α) (b : β)",
    "doc_string": "Compose an unary function `f` with a binary function `g`.",
    "kind": "def",
    "type": "δ"
  },
  {
    "name": "is_seq_compact",
    "statement": "def is_seq_compact {X : Type u_1} [topological_space X] (s : set X) : Prop",
    "theorem": "{X : Type u_1} [topological_space X] (s : set X) : Prop",
    "args": "{X : Type u_1} [topological_space X] (s : set X)",
    "doc_string": " A set `s` is sequentially compact if every sequence taking values in `s` has a converging subsequence.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lucas_lehmer.s_zmod",
    "statement": "def lucas_lehmer.s_zmod (p : ℕ) : ℕ → zmod (2 ^ p - 1)",
    "theorem": "(p : ℕ) : ℕ → zmod (2 ^ p - 1)",
    "args": "(p : ℕ)",
    "doc_string": "The recurrence `s (i+1) = (s i)^2 - 2` in `zmod (2^p - 1)`.",
    "kind": "def",
    "type": "ℕ → zmod (2 ^ p - 1)"
  },
  {
    "name": "language.has_one",
    "statement": "def language.has_one {α : Type u_1} : has_one (language α)",
    "theorem": "{α : Type u_1} : has_one (language α)",
    "args": "{α : Type u_1}",
    "doc_string": "`1 : language α` contains only one element `[]`.",
    "kind": "def",
    "type": "has_one (language α)"
  },
  {
    "name": "function.inv_fun_on",
    "statement": "def function.inv_fun_on {α : Type u} {β : Type v} [nonempty α] (f : α → β) (s : set α) (b : β) : α",
    "theorem": "{α : Type u} {β : Type v} [nonempty α] (f : α → β) (s : set α) (b : β) : α",
    "args": "{α : Type u} {β : Type v} [nonempty α] (f : α → β) (s : set α) (b : β)",
    "doc_string": " Construct the inverse for a function `f` on domain `s`. This function is a right inverse of `f` on `f '' s`. For a computable version, see `function.injective.inv_of_mem_range`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "left.add_pos_of_pos_of_nonneg",
    "statement": "theorem left.add_pos_of_pos_of_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_pos_of_nonneg`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "tsub_tsub_cancel_of_le",
    "statement": "theorem tsub_tsub_cancel_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} [contravariant_class α α has_add.add has_le.le] (h : a ≤ b) : b - (b - a) = a",
    "theorem": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} [contravariant_class α α has_add.add has_le.le] (h : a ≤ b) : b - (b - a) = a",
    "args": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} [contravariant_class α α has_add.add has_le.le] (h : a ≤ b)",
    "doc_string": "See `tsub_tsub_le` for an inequality.",
    "kind": "theorem",
    "type": "b - (b - a) = a"
  },
  {
    "name": "euclidean_geometry.cospherical_subset",
    "statement": "theorem euclidean_geometry.cospherical_subset {P : Type u_2} [metric_space P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : euclidean_geometry.cospherical ps₂) : euclidean_geometry.cospherical ps₁",
    "theorem": "{P : Type u_2} [metric_space P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : euclidean_geometry.cospherical ps₂) : euclidean_geometry.cospherical ps₁",
    "args": "{P : Type u_2} [metric_space P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : euclidean_geometry.cospherical ps₂)",
    "doc_string": "A subset of a cospherical set is cospherical.",
    "kind": "theorem",
    "type": "euclidean_geometry.cospherical ps₁"
  },
  {
    "name": "generalized_continued_fraction.pair.map",
    "statement": "def generalized_continued_fraction.pair.map {α : Type u_1} {β : Type u_2} (f : α → β) (gp : generalized_continued_fraction.pair α) : generalized_continued_fraction.pair β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (gp : generalized_continued_fraction.pair α) : generalized_continued_fraction.pair β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (gp : generalized_continued_fraction.pair α)",
    "doc_string": "Maps a function `f` on both components of a given pair.",
    "kind": "def",
    "type": "generalized_continued_fraction.pair β"
  },
  {
    "name": "cocompact_map",
    "statement": "structure cocompact_map (α : Type u) (β : Type v) [topological_space α] [topological_space β] : Type (max u v)",
    "theorem": "(α : Type u) (β : Type v) [topological_space α] [topological_space β] : Type (max u v)",
    "args": "(α : Type u) (β : Type v) [topological_space α] [topological_space β]",
    "doc_string": " A *cocompact continuous map* is a continuous function between topological spaces which tends to the cocompact filter along the cocompact filter. Functions for which preimages of compact sets are compact always satisfy this property, and the converse holds for cocompact continuous maps when the codomain is Hausdorff (see `cocompact_map.tendsto_of_forall_preimage` and `cocompact_map.compact_preimage`)",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "wseq.filter_map",
    "statement": "def wseq.filter_map {α : Type u} {β : Type v} (f : α → option β) : wseq α → wseq β",
    "theorem": "{α : Type u} {β : Type v} (f : α → option β) : wseq α → wseq β",
    "args": "{α : Type u} {β : Type v} (f : α → option β)",
    "doc_string": "Map the elements of `s` over `f`, removing any values that yield `none`.",
    "kind": "def",
    "type": "wseq α → wseq β"
  },
  {
    "name": "measure_theory.outer_measure.trim",
    "statement": "def measure_theory.outer_measure.trim {α : Type u_1} [measurable_space α] (m : measure_theory.outer_measure α) : measure_theory.outer_measure α",
    "theorem": "{α : Type u_1} [measurable_space α] (m : measure_theory.outer_measure α) : measure_theory.outer_measure α",
    "args": "{α : Type u_1} [measurable_space α] (m : measure_theory.outer_measure α)",
    "doc_string": "Given an outer measure `m` we can forget its value on non-measurable sets, and then consider  `m.trim`, the unique maximal outer measure less than that function.",
    "kind": "def",
    "type": "measure_theory.outer_measure α"
  },
  {
    "name": "ennreal.cancel_of_lt'",
    "statement": "theorem ennreal.cancel_of_lt' {a b : ennreal} (h : a < b) : add_le_cancellable a",
    "theorem": "{a b : ennreal} (h : a < b) : add_le_cancellable a",
    "args": "{a b : ennreal} (h : a < b)",
    "doc_string": "This lemma has an abbreviated name because it is used frequently.",
    "kind": "theorem",
    "type": "add_le_cancellable a"
  },
  {
    "name": "unique_factorization_monoid.factors",
    "statement": "def unique_factorization_monoid.factors {α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] [unique_factorization_monoid α] (a : α) : multiset α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] [unique_factorization_monoid α] (a : α) : multiset α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] [unique_factorization_monoid α] (a : α)",
    "doc_string": "Noncomputably determines the multiset of prime factors.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "surjective_quot_mk",
    "statement": "theorem surjective_quot_mk {α : Sort u_1} (r : α → α → Prop) : function.surjective (quot.mk r)",
    "theorem": "{α : Sort u_1} (r : α → α → Prop) : function.surjective (quot.mk r)",
    "args": "{α : Sort u_1} (r : α → α → Prop)",
    "doc_string": "`quot.mk r` is a surjective function.",
    "kind": "theorem",
    "type": "function.surjective (quot.mk r)"
  },
  {
    "name": "has_lt.to_has_sbtw",
    "statement": "def has_lt.to_has_sbtw (α : Type u_1) [has_lt α] : has_sbtw α",
    "theorem": "(α : Type u_1) [has_lt α] : has_sbtw α",
    "args": "(α : Type u_1) [has_lt α]",
    "doc_string": " The strict betweenness relation obtained from \"looping around\" `<`. See note [reducible non-instances].",
    "kind": "def",
    "type": "has_sbtw α"
  },
  {
    "name": "int.zpow_log_gi",
    "statement": "def int.zpow_log_gi (R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) : galois_coinsertion (λ (z : ℤ), ⟨↑b ^ z, _⟩) (λ (r : ↥(set.Ioi 0)), int.log b ↑r)",
    "theorem": "(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) : galois_coinsertion (λ (z : ℤ), ⟨↑b ^ z, _⟩) (λ (r : ↥(set.Ioi 0)), int.log b ↑r)",
    "args": "(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b)",
    "doc_string": "Over suitable subtypes, `zpow` and `int.log` form a galois coinsertion",
    "kind": "def",
    "type": "galois_coinsertion (λ (z : ℤ), ⟨↑b ^ z, _⟩) (λ (r : ↥(set.Ioi 0)), int.log b ↑r)"
  },
  {
    "name": "invertible_of_group",
    "statement": "def invertible_of_group {α : Type u} [group α] (a : α) : invertible a",
    "theorem": "{α : Type u} [group α] (a : α) : invertible a",
    "args": "{α : Type u} [group α] (a : α)",
    "doc_string": "Each element of a group is invertible.",
    "kind": "def",
    "type": "invertible a"
  },
  {
    "name": "Top.presheaf_to_Top",
    "statement": "def Top.presheaf_to_Top (X T : Top) : Top.presheaf (Type v) X",
    "theorem": "(X T : Top) : Top.presheaf (Type v) X",
    "args": "(X T : Top)",
    "doc_string": " The presheaf of continuous functions on `X` with values in fixed target topological space `T`.",
    "kind": "def",
    "type": "Top.presheaf (Type v) X"
  },
  {
    "name": "tactic.rewrite_search.edge",
    "statement": "structure tactic.rewrite_search.edge  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "An edge represents a proof that can get from one expression to another. It represents the fact that, starting from the vertex `fr`, the expression in `proof` can prove the vertex `to`. `how` contains information that the explainer will use to generate Lean code for the proof.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "add_submonoid.has_neg",
    "statement": "def add_submonoid.has_neg {G : Type u_2} [add_group G] : has_neg (add_submonoid G)",
    "theorem": "{G : Type u_2} [add_group G] : has_neg (add_submonoid G)",
    "args": "{G : Type u_2} [add_group G]",
    "doc_string": "The additive submonoid with every element negated.",
    "kind": "def",
    "type": "has_neg (add_submonoid G)"
  },
  {
    "name": "tensor_product",
    "statement": "def tensor_product (R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : Type (max u_4 u_5)",
    "theorem": "(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : Type (max u_4 u_5)",
    "args": "(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N]",
    "doc_string": " The tensor product of two modules `M` and `N` over the same commutative semiring `R`. The localized notations are `M ⊗ N` and `M ⊗[R] N`, accessed by `open_locale tensor_product`.",
    "kind": "def",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "first_order.sequence₂",
    "statement": "def first_order.sequence₂ (a₀ a₁ a₂ : Type u) : ℕ → Type u",
    "theorem": "(a₀ a₁ a₂ : Type u) : ℕ → Type u",
    "args": "(a₀ a₁ a₂ : Type u)",
    "doc_string": "Used to define `first_order.language₂`.",
    "kind": "def",
    "type": "ℕ → Type u"
  },
  {
    "name": "bitvec.or",
    "statement": "def bitvec.or {n : ℕ} : bitvec n → bitvec n → bitvec n",
    "theorem": "{n : ℕ} : bitvec n → bitvec n → bitvec n",
    "args": "{n : ℕ}",
    "doc_string": "bitwise or",
    "kind": "def",
    "type": "bitvec n → bitvec n → bitvec n"
  },
  {
    "name": "algebraic_geometry.prime_spectrum.Top",
    "statement": "def algebraic_geometry.prime_spectrum.Top (R : Type u) [comm_ring R] : Top",
    "theorem": "(R : Type u) [comm_ring R] : Top",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "The prime spectrum, just as a topological space.",
    "kind": "def",
    "type": "Top"
  },
  {
    "name": "is_add_monoid_hom.is_add_monoid_hom_mul_left",
    "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_left {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)",
    "theorem": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)",
    "args": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ)",
    "doc_string": "Left multiplication in a ring is an additive monoid morphism.",
    "kind": "theorem",
    "type": "is_add_monoid_hom (λ (y : γ), x * y)"
  },
  {
    "name": "closure_Iio",
    "statement": "theorem closure_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_min_order α] : closure (set.Iio a) = set.Iic a",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_min_order α] : closure (set.Iio a) = set.Iic a",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_min_order α]",
    "doc_string": "The closure of the interval `(-∞, a)` is the interval `(-∞, a]`.",
    "kind": "theorem",
    "type": "closure (set.Iio a) = set.Iic a"
  },
  {
    "name": "simple_graph.is_subgraph",
    "statement": "def simple_graph.is_subgraph {V : Type u} (x y : simple_graph V) : Prop",
    "theorem": "{V : Type u} (x y : simple_graph V) : Prop",
    "args": "{V : Type u} (x y : simple_graph V)",
    "doc_string": " The relation that one `simple_graph` is a subgraph of another. Note that this should be spelled `≤`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_neg_of_nonpos_of_neg",
    "statement": "theorem add_neg_of_nonpos_of_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0)",
    "doc_string": "**Alias** of `left.add_neg_of_nonpos_of_neg`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "is_clopen.frontier_eq",
    "statement": "theorem is_clopen.frontier_eq {α : Type u} [topological_space α] {s : set α} : is_clopen s → frontier s = ∅",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : is_clopen s → frontier s = ∅",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "**Alias** of the forward direction of is_clopen_iff_frontier_eq_empty`.",
    "kind": "theorem",
    "type": "is_clopen s → frontier s = ∅"
  },
  {
    "name": "typevec.append1",
    "statement": "def typevec.append1 {n : ℕ} (α : typevec n) (β : Type u_1) : typevec (n + 1)",
    "theorem": "{n : ℕ} (α : typevec n) (β : Type u_1) : typevec (n + 1)",
    "args": "{n : ℕ} (α : typevec n) (β : Type u_1)",
    "doc_string": "Support for extending a typevec by one element.",
    "kind": "def",
    "type": "typevec (n + 1)"
  },
  {
    "name": "ordnode.drop",
    "statement": "def ordnode.drop {α : Type u} (i : ℕ) (t : ordnode α) : ordnode α",
    "theorem": "{α : Type u} (i : ℕ) (t : ordnode α) : ordnode α",
    "args": "{α : Type u} (i : ℕ) (t : ordnode α)",
    "doc_string": "O(log n). Remove the first `i` elements of the set, counted from the left.      drop 2 {a, b, c, d} = {c, d}     drop 5 {a, b, c, d} = ∅",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "is_integrally_closed_iff_is_integral_closure",
    "statement": "theorem is_integrally_closed_iff_is_integral_closure {R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ↔ is_integral_closure R R K",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ↔ is_integral_closure R R K",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K]",
    "doc_string": "`R` is integrally closed iff it is the integral closure of itself in its field of fractions.",
    "kind": "theorem",
    "type": "is_integrally_closed R ↔ is_integral_closure R R K"
  },
  {
    "name": "category_theory.grothendieck_topology",
    "statement": "structure category_theory.grothendieck_topology (C : Type u) [category_theory.category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "The definition of a Grothendieck topology: a set of sieves `J X` on each object `X` satisfying three axioms: 1. For every object `X`, the maximal sieve is in `J X`. 2. If `S ∈ J X` then its pullback along any `h : Y ⟶ X` is in `J Y`. 3. If `S ∈ J X` and `R` is a sieve on `X`, then provided that the pullback of `R` along any arrow    `f : Y ⟶ X` in `S` is in `J Y`, we have that `R` itself is in `J X`.  A sieve `S` on `X` is referred to as `J`-covering, (or just covering), if `S ∈ J X`.  See <https://stacks.math.columbia.edu/tag/00Z4>, or [nlab], or [MM92][] Chapter III, Section 2, Definition 1.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "power_basis.minpoly_gen",
    "statement": "def power_basis.minpoly_gen {S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] (pb : power_basis A S) : polynomial A",
    "theorem": "{S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] (pb : power_basis A S) : polynomial A",
    "args": "{S : Type u_2} [comm_ring S] {A : Type u_4} [comm_ring A] [algebra A S] (pb : power_basis A S)",
    "doc_string": " `pb.minpoly_gen` is a minimal polynomial for `pb.gen`.  If `A` is not a field, it might not necessarily be *the* minimal polynomial, however `nat_degree_minpoly` shows its degree is indeed minimal.",
    "kind": "def",
    "type": "polynomial A"
  },
  {
    "name": "category_theory.paths_hom_rel",
    "statement": "def category_theory.paths_hom_rel (C : Type u₁) [category_theory.category C] : hom_rel (category_theory.paths C)",
    "theorem": "(C : Type u₁) [category_theory.category C] : hom_rel (category_theory.paths C)",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": " The canonical relation on the path category of a category: two paths are related if they compose to the same morphism.",
    "kind": "def",
    "type": "hom_rel (category_theory.paths C)"
  },
  {
    "name": "lie_algebra.is_engelian_of_is_noetherian",
    "statement": "theorem lie_algebra.is_engelian_of_is_noetherian {R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L",
    "theorem": "{R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L",
    "args": "{R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L]",
    "doc_string": " *Engel's theorem*.  Note that this implies all traditional forms of Engel's theorem via `lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`, `lie_algebra.is_nilpotent_iff_forall`.",
    "kind": "theorem",
    "type": "lie_algebra.is_engelian R L"
  },
  {
    "name": "matrix.det_fin_one",
    "statement": "theorem matrix.det_fin_one {R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0",
    "theorem": "{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0",
    "args": "{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R)",
    "doc_string": "Determinant of 1x1 matrix",
    "kind": "theorem",
    "type": "A.det = A 0 0"
  },
  {
    "name": "function.injective2",
    "statement": "def function.injective2 {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) : Prop",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ) : Prop",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β → γ)",
    "doc_string": " The property of a binary function `f : α → β → γ` being injective. Mathematically this should be thought of as the corresponding function `α × β → γ` being injective.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "algebra.finite_presentation.of_finite_type",
    "statement": "theorem algebra.finite_presentation.of_finite_type {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A",
    "theorem": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A",
    "args": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R]",
    "doc_string": " An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented.",
    "kind": "theorem",
    "type": "algebra.finite_type R A ↔ algebra.finite_presentation R A"
  },
  {
    "name": "is_closed.is_clopenable",
    "statement": "theorem is_closed.is_clopenable {α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s) : polish_space.is_clopenable s",
    "theorem": "{α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s) : polish_space.is_clopenable s",
    "args": "{α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s)",
    "doc_string": " Given a closed set `s` in a Polish space, one can construct a finer Polish topology for which `s` is both open and closed.",
    "kind": "theorem",
    "type": "polish_space.is_clopenable s"
  },
  {
    "name": "set.kern_image",
    "statement": "def set.kern_image {α : Type u_1} {β : Type u_2} (f : α → β) (s : set α) : set β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (s : set α) : set β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (s : set α)",
    "doc_string": "`kern_image f s` is the set of `y` such that `f ⁻¹ y ⊆ s`.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "polynomial.dickson",
    "statement": "def polynomial.dickson {R : Type u_1} [comm_ring R] (k : ℕ) (a : R) : ℕ → polynomial R",
    "theorem": "{R : Type u_1} [comm_ring R] (k : ℕ) (a : R) : ℕ → polynomial R",
    "args": "{R : Type u_1} [comm_ring R] (k : ℕ) (a : R)",
    "doc_string": " `dickson` is the `n`the (generalised) Dickson polynomial of the `k`-th kind associated to the element `a ∈ R`.",
    "kind": "def",
    "type": "ℕ → polynomial R"
  },
  {
    "name": "besicovitch.tau_package",
    "statement": "structure besicovitch.tau_package (β : Type u_1) (α : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(β : Type u_1) (α : Type u_2) : Type (max u_1 u_2)",
    "args": "(β : Type u_1) (α : Type u_2)",
    "doc_string": " A Besicovitch tau-package is a family of balls in a metric space with positive bounded radii, together with enough data to proceed with the Besicovitch greedy algorithm. We register this in a single structure to make sure that all our constructions in this algorithm only depend on one variable.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "subgroup.simps.coe",
    "statement": "def subgroup.simps.coe {G : Type u_1} [group G] (S : subgroup G) : set G",
    "theorem": "{G : Type u_1} [group G] (S : subgroup G) : set G",
    "args": "{G : Type u_1} [group G] (S : subgroup G)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "real.sinh_strict_mono",
    "statement": "theorem real.sinh_strict_mono  : strict_mono real.sinh",
    "theorem": " : strict_mono real.sinh",
    "args": "",
    "doc_string": "`sinh` is strictly monotone.",
    "kind": "theorem",
    "type": "strict_mono real.sinh"
  },
  {
    "name": "fin_enum.of_surjective",
    "statement": "def fin_enum.of_surjective {α : Type u} {β : Type u_1} (f : β → α) [decidable_eq α] [fin_enum β] (h : function.surjective f) : fin_enum α",
    "theorem": "{α : Type u} {β : Type u_1} (f : β → α) [decidable_eq α] [fin_enum β] (h : function.surjective f) : fin_enum α",
    "args": "{α : Type u} {β : Type u_1} (f : β → α) [decidable_eq α] [fin_enum β] (h : function.surjective f)",
    "doc_string": "create a `fin_enum` instance using a surjection",
    "kind": "def",
    "type": "fin_enum α"
  },
  {
    "name": "matrix.std_basis_matrix",
    "statement": "def matrix.std_basis_matrix {m : Type u_2} {n : Type u_3} {α : Type u_5} [decidable_eq m] [decidable_eq n] [semiring α] (i : m) (j : n) (a : α) : matrix m n α",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type u_5} [decidable_eq m] [decidable_eq n] [semiring α] (i : m) (j : n) (a : α) : matrix m n α",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type u_5} [decidable_eq m] [decidable_eq n] [semiring α] (i : m) (j : n) (a : α)",
    "doc_string": "`std_basis_matrix i j a` is the matrix with `a` in the `i`-th row, `j`-th column, and zeroes elsewhere.",
    "kind": "def",
    "type": "matrix m n α"
  },
  {
    "name": "ordset.empty",
    "statement": "def ordset.empty {α : Type u_1} [preorder α] (s : ordset α) : Prop",
    "theorem": "{α : Type u_1} [preorder α] (s : ordset α) : Prop",
    "args": "{α : Type u_1} [preorder α] (s : ordset α)",
    "doc_string": "O(1). Is the set empty?",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_subgroup.simps.coe",
    "statement": "def add_subgroup.simps.coe {G : Type u_1} [add_group G] (S : add_subgroup G) : set G",
    "theorem": "{G : Type u_1} [add_group G] (S : add_subgroup G) : set G",
    "args": "{G : Type u_1} [add_group G] (S : add_subgroup G)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "category_theory.simplicial_object",
    "statement": "def category_theory.simplicial_object (C : Type u) [category_theory.category C] : Type (max v u)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max v u)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": " The category of simplicial objects valued in a category `C`. This is the category of contravariant functors from `simplex_category` to `C`.",
    "kind": "def",
    "type": "Type (max v u)"
  },
  {
    "name": "pseudo_metric_space",
    "statement": "structure pseudo_metric_space (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " Metric space  Each metric space induces a canonical `uniform_space` and hence a canonical `topological_space`. This is enforced in the type class definition, by extending the `uniform_space` structure. When instantiating a `metric_space` structure, the uniformity fields are not necessary, they will be filled in by default. In the same way, each metric space induces an emetric space structure. It is included in the structure, but filled in by default.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "is_free_group",
    "statement": "structure is_free_group (G : Type u) [group G] : Type (u+1)",
    "theorem": "(G : Type u) [group G] : Type (u+1)",
    "args": "(G : Type u) [group G]",
    "doc_string": "`is_free_group G` means that `G` isomorphic to a free group.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "smul_with_zero",
    "statement": "structure smul_with_zero (R : Type u_1) (M : Type u_3) [has_zero R] [has_zero M] : Type (max u_1 u_3)",
    "theorem": "(R : Type u_1) (M : Type u_3) [has_zero R] [has_zero M] : Type (max u_1 u_3)",
    "args": "(R : Type u_1) (M : Type u_3) [has_zero R] [has_zero M]",
    "doc_string": "  `smul_with_zero` is a class consisting of a Type `R` with `0 ∈ R` and a scalar multiplication of `R` on a Type `M` with `0`, such that the equality `r • m = 0` holds if at least one among `r` or `m` equals `0`.",
    "kind": "structure",
    "type": "Type (max u_1 u_3)"
  },
  {
    "name": "list.map_with_complement",
    "statement": "def list.map_with_complement {α : Type u_1} {β : Type u_2} (f : α → list α → β) : list α → list β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → list α → β) : list α → list β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → list α → β)",
    "doc_string": "`list.map_with_complement f l` is a variant of `list.map_with_prefix_suffix` that maps `f` across a list `l`. For each `a ∈ l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f a (pref ++ suff)`, i.e., the list input to `f` is `l` with `a` removed.  Example: if `f : ℕ → list ℕ → β`, `list.map_with_complement f [1, 2, 3]` will produce the list `[f 1 [2, 3], f 2 [1, 3], f 3 [1, 2]]`.",
    "kind": "def",
    "type": "list α → list β"
  },
  {
    "name": "normed_ring",
    "statement": "structure normed_ring (α : Type u_5) : Type u_5",
    "theorem": "(α : Type u_5) : Type u_5",
    "args": "(α : Type u_5)",
    "doc_string": "A normed ring is a ring endowed with a norm which satisfies the inequality `∥x y∥ ≤ ∥x∥ ∥y∥`.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "non_unital_ring",
    "statement": "structure non_unital_ring (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "An associative but not-necessarily unital ring.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "set.cIcc",
    "statement": "def set.cIcc {α : Type u_1} [circular_preorder α] (a b : α) : set α",
    "theorem": "{α : Type u_1} [circular_preorder α] (a b : α) : set α",
    "args": "{α : Type u_1} [circular_preorder α] (a b : α)",
    "doc_string": "Closed-closed circular interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "erased.out",
    "statement": "def erased.out {α : Sort u_1} : erased α → α",
    "theorem": "{α : Sort u_1} : erased α → α",
    "args": "{α : Sort u_1}",
    "doc_string": "Extracts the erased value, noncomputably.",
    "kind": "def",
    "type": "erased α → α"
  },
  {
    "name": "snum.pred",
    "statement": "def snum.pred  : snum → snum",
    "theorem": " : snum → snum",
    "args": "",
    "doc_string": "The predecessor of a `snum` (i.e. the operation of removing one).",
    "kind": "def",
    "type": "snum → snum"
  },
  {
    "name": "pos_num.mul",
    "statement": "def pos_num.mul (a : pos_num) : pos_num → pos_num",
    "theorem": "(a : pos_num) : pos_num → pos_num",
    "args": "(a : pos_num)",
    "doc_string": "Multiplication of two `pos_num`s.",
    "kind": "def",
    "type": "pos_num → pos_num"
  },
  {
    "name": "vadd_right_injective",
    "statement": "theorem vadd_right_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p)",
    "theorem": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p)",
    "args": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P)",
    "doc_string": " Adding a group element to the point `p` is an injective function.",
    "kind": "theorem",
    "type": "function.injective (λ (_x : G), _x +ᵥ p)"
  },
  {
    "name": "equiv.swap_mul_involutive",
    "statement": "theorem equiv.swap_mul_involutive {α : Type u} [decidable_eq α] (i j : α) : function.involutive (has_mul.mul (equiv.swap i j))",
    "theorem": "{α : Type u} [decidable_eq α] (i j : α) : function.involutive (has_mul.mul (equiv.swap i j))",
    "args": "{α : Type u} [decidable_eq α] (i j : α)",
    "doc_string": "A stronger version of `mul_right_injective`",
    "kind": "theorem",
    "type": "function.involutive (has_mul.mul (equiv.swap i j))"
  },
  {
    "name": "free_group.reduce.red",
    "statement": "theorem free_group.reduce.red {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.red L (free_group.reduce L)",
    "theorem": "{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.red L (free_group.reduce L)",
    "args": "{α : Type u} {L : list (α × bool)} [decidable_eq α]",
    "doc_string": " The first theorem that characterises the function `reduce`: a word reduces to its maximal reduction.",
    "kind": "theorem",
    "type": "free_group.red L (free_group.reduce L)"
  },
  {
    "name": "bounded_order_hom.to_top_hom",
    "statement": "def bounded_order_hom.to_top_hom {α : Type u_2} {β : Type u_3} [preorder α] [preorder β] [bounded_order α] [bounded_order β] (f : bounded_order_hom α β) : top_hom α β",
    "theorem": "{α : Type u_2} {β : Type u_3} [preorder α] [preorder β] [bounded_order α] [bounded_order β] (f : bounded_order_hom α β) : top_hom α β",
    "args": "{α : Type u_2} {β : Type u_3} [preorder α] [preorder β] [bounded_order α] [bounded_order β] (f : bounded_order_hom α β)",
    "doc_string": "Reinterpret a `bounded_order_hom` as a `top_hom`.",
    "kind": "def",
    "type": "top_hom α β"
  },
  {
    "name": "matrix.orthogonal_group",
    "statement": "def matrix.orthogonal_group {n : Type u} [decidable_eq n] [fintype n] (β : Type v) [comm_ring β] : submonoid (matrix n n β)",
    "theorem": "{n : Type u} [decidable_eq n] [fintype n] (β : Type v) [comm_ring β] : submonoid (matrix n n β)",
    "args": "{n : Type u} [decidable_eq n] [fintype n] (β : Type v) [comm_ring β]",
    "doc_string": "`orthogonal_group n` is the group of `n` by `n` matrices where the transpose is the inverse.",
    "kind": "def",
    "type": "submonoid (matrix n n β)"
  },
  {
    "name": "metric_space.ext",
    "statement": "theorem metric_space.ext {α : Type u_1} {m m' : metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'",
    "theorem": "{α : Type u_1} {m m' : metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'",
    "args": "{α : Type u_1} {m m' : metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist)",
    "doc_string": "Two metric space structures with the same distance coincide.",
    "kind": "theorem",
    "type": "m = m'"
  },
  {
    "name": "free_group.mk",
    "statement": "def free_group.mk {α : Type u} (L : list (α × bool)) : free_group α",
    "theorem": "{α : Type u} (L : list (α × bool)) : free_group α",
    "args": "{α : Type u} (L : list (α × bool))",
    "doc_string": "The canonical map from `list (α × bool)` to the free group on `α`.",
    "kind": "def",
    "type": "free_group α"
  },
  {
    "name": "category_theory.subterminals",
    "statement": "def category_theory.subterminals (C : Type u₁) [category_theory.category C] : Type u₁",
    "theorem": "(C : Type u₁) [category_theory.category C] : Type u₁",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": "The (full sub)category of subterminal objects. TODO: If `C` is the category of sheaves on a topological space `X`, this category is equivalent to the lattice of open subsets of `X`. More generally, if `C` is a topos, this is the lattice of \"external truth values\".",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "order_closed_topology",
    "statement": "structure order_closed_topology (α : Type u_1) [topological_space α] [preorder α] : Prop",
    "theorem": "(α : Type u_1) [topological_space α] [preorder α] : Prop",
    "args": "(α : Type u_1) [topological_space α] [preorder α]",
    "doc_string": " A topology on a set which is both a topological space and a preorder is _order-closed_ if the set of points `(x, y)` with `x ≤ y` is closed in the product space. We introduce this as a mixin. This property is satisfied for the order topology on a linear order, but it can be satisfied more generally, and suffices to derive many interesting properties relating order and topology.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "fin.coe_coe_eq_self",
    "statement": "theorem fin.coe_coe_eq_self {n : ℕ} (a : fin (n + 1)) : ↑↑a = a",
    "theorem": "{n : ℕ} (a : fin (n + 1)) : ↑↑a = a",
    "args": "{n : ℕ} (a : fin (n + 1))",
    "doc_string": " Converting a `fin (n + 1)` to `ℕ` and back results in the same value.",
    "kind": "theorem",
    "type": "↑↑a = a"
  },
  {
    "name": "reflexive.rel_of_ne_imp",
    "statement": "theorem reflexive.rel_of_ne_imp {α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y",
    "theorem": "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y",
    "args": "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} (hr : x ≠ y → r x y)",
    "doc_string": " To show a reflexive relation `r : α → α → Prop` holds over `x y : α`, it suffices to show it holds when `x ≠ y`.",
    "kind": "theorem",
    "type": "r x y"
  },
  {
    "name": "subring.mul_mem",
    "statement": "theorem subring.mul_mem {R : Type u} [ring R] (s : subring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s",
    "theorem": "{R : Type u} [ring R] (s : subring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s",
    "args": "{R : Type u} [ring R] (s : subring R) {x y : R}",
    "doc_string": "A subring is closed under multiplication.",
    "kind": "theorem",
    "type": "x ∈ s → y ∈ s → x * y ∈ s"
  },
  {
    "name": "classical.dec_rel",
    "statement": "def classical.dec_rel {α : Sort u_1} (p : α → α → Prop) : decidable_rel p",
    "theorem": "{α : Sort u_1} (p : α → α → Prop) : decidable_rel p",
    "args": "{α : Sort u_1} (p : α → α → Prop)",
    "doc_string": "Any relation `p` is decidable classically.",
    "kind": "def",
    "type": "decidable_rel p"
  },
  {
    "name": "truncated_witt_vector",
    "statement": "def truncated_witt_vector (p n : ℕ) (R : Type u_1) : Type u_1",
    "theorem": "(p n : ℕ) (R : Type u_1) : Type u_1",
    "args": "(p n : ℕ) (R : Type u_1)",
    "doc_string": "A truncated Witt vector over `R` is a vector of elements of `R`, i.e., the first `n` coefficients of a Witt vector. We will define operations on this type that are compatible with the (untruncated) Witt vector operations.  `truncated_witt_vector p n R` takes a parameter `p : ℕ` that is not used in the definition. In practice, this number `p` is assumed to be a prime number, and under this assumption we construct a ring structure on `truncated_witt_vector p n R`. (`truncated_witt_vector p₁ n R` and `truncated_witt_vector p₂ n R` are definitionally equal as types but will have different ring operations.)",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "continuous_groupoid",
    "statement": "def continuous_groupoid (H : Type u_1) [topological_space H] : structure_groupoid H",
    "theorem": "(H : Type u_1) [topological_space H] : structure_groupoid H",
    "args": "(H : Type u_1) [topological_space H]",
    "doc_string": "The groupoid of all local homeomorphisms on a topological space `H`",
    "kind": "def",
    "type": "structure_groupoid H"
  },
  {
    "name": "pi_nat.first_diff",
    "statement": "def pi_nat.first_diff {E : ℕ → Type u_1} (x y : Π (n : ℕ), E n) : ℕ",
    "theorem": "{E : ℕ → Type u_1} (x y : Π (n : ℕ), E n) : ℕ",
    "args": "{E : ℕ → Type u_1} (x y : Π (n : ℕ), E n)",
    "doc_string": " In a product space `Π n, E n`, then `first_diff x y` is the first index at which `x` and `y` differ. If `x = y`, then by convention we set `first_diff x x = 0`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "seq_compact_space",
    "statement": "structure seq_compact_space (X : Type u_3) [topological_space X] : Prop",
    "theorem": "(X : Type u_3) [topological_space X] : Prop",
    "args": "(X : Type u_3) [topological_space X]",
    "doc_string": " A space `X` is sequentially compact if every sequence in `X` has a converging subsequence.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "Frame.hom",
    "statement": "def Frame.hom (α : Type u_1) (β : Type u_2) [order.frame α] [order.frame β] : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (β : Type u_2) [order.frame α] [order.frame β] : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (β : Type u_2) [order.frame α] [order.frame β]",
    "doc_string": " An abbreviation of `frame_hom` that assumes `frame` instead of the weaker `complete_lattice`. Necessary for the category theory machinery.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "densely_ordered",
    "statement": "structure densely_ordered (α : Type u) [has_lt α] : Prop",
    "theorem": "(α : Type u) [has_lt α] : Prop",
    "args": "(α : Type u) [has_lt α]",
    "doc_string": "An order is dense if there is an element between any pair of distinct elements.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordnode.insert",
    "statement": "def ordnode.insert {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": " O(log n). Insert an element into the set, preserving balance and the BST property. If an equivalent element is already in the set, this replaces it.      insert 1 {1, 2, 3} = {1, 2, 3}     insert 4 {1, 2, 3} = {1, 2, 3, 4}  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      insert (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 1)}     insert (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)}",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "as_boolalg",
    "statement": "def as_boolalg (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Type synonym to view a Boolean ring as a Boolean algebra.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "galois_coinsertion.lift_semilattice_inf",
    "statement": "def galois_coinsertion.lift_semilattice_inf {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [semilattice_inf β] (gi : galois_coinsertion l u) : semilattice_inf α",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [semilattice_inf β] (gi : galois_coinsertion l u) : semilattice_inf α",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [semilattice_inf β] (gi : galois_coinsertion l u)",
    "doc_string": "Lift the infima along a Galois coinsertion",
    "kind": "def",
    "type": "semilattice_inf α"
  },
  {
    "name": "zmod.inv",
    "statement": "def zmod.inv (n : ℕ) : zmod n → zmod n",
    "theorem": "(n : ℕ) : zmod n → zmod n",
    "args": "(n : ℕ)",
    "doc_string": " The inversion on `zmod n`. It is setup in such a way that `a * a⁻¹` is equal to `gcd a.val n`. In particular, if `a` is coprime to `n`, and hence a unit, `a * a⁻¹ = 1`.",
    "kind": "def",
    "type": "zmod n → zmod n"
  },
  {
    "name": "bilin_form.to_quadratic_form",
    "statement": "def bilin_form.to_quadratic_form {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] (B : bilin_form R M) : quadratic_form R M",
    "theorem": "{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] (B : bilin_form R M) : quadratic_form R M",
    "args": "{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] (B : bilin_form R M)",
    "doc_string": "A bilinear form gives a quadratic form by applying the argument twice.",
    "kind": "def",
    "type": "quadratic_form R M"
  },
  {
    "name": "finset.bUnion",
    "statement": "def finset.bUnion {α : Type u_1} {β : Type u_2} [decidable_eq β] (s : finset α) (t : α → finset β) : finset β",
    "theorem": "{α : Type u_1} {β : Type u_2} [decidable_eq β] (s : finset α) (t : α → finset β) : finset β",
    "args": "{α : Type u_1} {β : Type u_2} [decidable_eq β] (s : finset α) (t : α → finset β)",
    "doc_string": " `bUnion s t` is the union of `t x` over `x ∈ s`. (This was formerly `bind` due to the monad structure on types with `decidable_eq`.)",
    "kind": "def",
    "type": "finset β"
  },
  {
    "name": "finset.has_div",
    "statement": "def finset.has_div {α : Type u_2} [decidable_eq α] [has_div α] : has_div (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [has_div α] : has_div (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [has_div α]",
    "doc_string": " The pointwise division of sfinets `s / t` is defined as `{x / y | x ∈ s, y ∈ t}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_div (finset α)"
  },
  {
    "name": "tactic.norm_num.min_fac_helper",
    "statement": "def tactic.norm_num.min_fac_helper (n k : ℕ) : Prop",
    "theorem": "(n k : ℕ) : Prop",
    "args": "(n k : ℕ)",
    "doc_string": "A predicate representing partial progress in a proof of `min_fac`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "CommSemiRing",
    "statement": "def CommSemiRing  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of commutative semirings.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "subgroup.div_mem",
    "statement": "theorem subgroup.div_mem {G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H",
    "args": "{G : Type u_1} [group G] (H : subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H)",
    "doc_string": "A subgroup is closed under division.",
    "kind": "theorem",
    "type": "x / y ∈ H"
  },
  {
    "name": "zsmul_rec",
    "statement": "def zsmul_rec {M : Type u_1} [has_zero M] [has_add M] [has_neg M] : ℤ → M → M",
    "theorem": "{M : Type u_1} [has_zero M] [has_add M] [has_neg M] : ℤ → M → M",
    "args": "{M : Type u_1} [has_zero M] [has_add M] [has_neg M]",
    "doc_string": " The fundamental scalar multiplication in an additive group. `zsmul_rec n a = a+a+...+a` n times, for integer `n`. Use instead `n • a`, which has better definitional behavior.",
    "kind": "def",
    "type": "ℤ → M → M"
  },
  {
    "name": "gold_irrational",
    "statement": "theorem gold_irrational  : irrational golden_ratio",
    "theorem": " : irrational golden_ratio",
    "args": "",
    "doc_string": "The golden ratio is irrational.",
    "kind": "theorem",
    "type": "irrational golden_ratio"
  },
  {
    "name": "linear_order.lift",
    "statement": "def linear_order.lift {α : Type u_1} {β : Type u_2} [linear_order β] (f : α → β) (inj : function.injective f) : linear_order α",
    "theorem": "{α : Type u_1} {β : Type u_2} [linear_order β] (f : α → β) (inj : function.injective f) : linear_order α",
    "args": "{α : Type u_1} {β : Type u_2} [linear_order β] (f : α → β) (inj : function.injective f)",
    "doc_string": " Transfer a `linear_order` on `β` to a `linear_order` on `α` using an injective function `f : α → β`. See note [reducible non-instances].",
    "kind": "def",
    "type": "linear_order α"
  },
  {
    "name": "category_theory.Mat",
    "statement": "def category_theory.Mat (R : Type u) : Type (u+1)",
    "theorem": "(R : Type u) : Type (u+1)",
    "args": "(R : Type u)",
    "doc_string": " A type synonym for `Fintype`, which we will equip with a category structure where the morphisms are matrices with components in `R`.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "powers.mul_mem",
    "statement": "theorem powers.mul_mem {M : Type u_1} [monoid M] {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x",
    "theorem": "{M : Type u_1} [monoid M] {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x",
    "args": "{M : Type u_1} [monoid M] {x y z : M}",
    "doc_string": "The set of natural number powers of an element of a monoid is closed under multiplication.",
    "kind": "theorem",
    "type": "y ∈ powers x → z ∈ powers x → y * z ∈ powers x"
  },
  {
    "name": "pSet.definable",
    "statement": "inductive pSet.definable (n : ℕ) : arity Set n → Type (u+1)",
    "theorem": "(n : ℕ) : arity Set n → Type (u+1)",
    "args": "(n : ℕ)",
    "doc_string": "A set function is \"definable\" if it is the image of some n-ary pre-set  function. This isn't exactly definability, but is useful as a sufficient  condition for functions that have a computable image.",
    "kind": "inductive",
    "type": "arity Set n → Type (u+1)"
  },
  {
    "name": "spectrum.is_unit_resolvent",
    "statement": "theorem spectrum.is_unit_resolvent {R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r ∈ resolvent_set R a ↔ is_unit (resolvent a r)",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r ∈ resolvent_set R a ↔ is_unit (resolvent a r)",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A}",
    "doc_string": "The resolvent is a unit when the argument is in the resolvent set.",
    "kind": "theorem",
    "type": "r ∈ resolvent_set R a ↔ is_unit (resolvent a r)"
  },
  {
    "name": "eq.trans_lt",
    "statement": "theorem eq.trans_lt {α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b < c) : a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b < c) : a < c",
    "args": "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b < c)",
    "doc_string": "**Alias** of lt_of_eq_of_lt`.",
    "kind": "theorem",
    "type": "a < c"
  },
  {
    "name": "nnreal.young_inequality",
    "statement": "theorem nnreal.young_inequality (a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b ≤ a ^ ↑p / p + b ^ ↑q / q",
    "theorem": "(a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b ≤ a ^ ↑p / p + b ^ ↑q / q",
    "args": "(a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1)",
    "doc_string": " Young's inequality, `ℝ≥0` version. We use `{p q : ℝ≥0}` in order to avoid constructing witnesses of `0 ≤ p` and `0 ≤ q` for the denominators.",
    "kind": "theorem",
    "type": "a * b ≤ a ^ ↑p / p + b ^ ↑q / q"
  },
  {
    "name": "category_theory.simplicial_object.augmented",
    "statement": "def category_theory.simplicial_object.augmented (C : Type u) [category_theory.category C] : Type (max (max v u) u v)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max (max v u) u v)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "The category of augmented simplicial objects, defined as a comma category.",
    "kind": "def",
    "type": "Type (max (max v u) u v)"
  },
  {
    "name": "pos_num.nat_size",
    "statement": "def pos_num.nat_size  : pos_num → ℕ",
    "theorem": " : pos_num → ℕ",
    "args": "",
    "doc_string": "The number of bits of a `pos_num`, as a `nat`.",
    "kind": "def",
    "type": "pos_num → ℕ"
  },
  {
    "name": "witt_vector.witt_nsmul",
    "statement": "def witt_vector.witt_nsmul (p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ)",
    "doc_string": "The polynomials used for defining repeated addition of the ring of Witt vectors.",
    "kind": "def",
    "type": "ℕ → mv_polynomial (fin 1 × ℕ) ℤ"
  },
  {
    "name": "with_top",
    "statement": "def with_top (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Attach `⊤` to a type.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "list.length_le_sum_of_one_le",
    "statement": "theorem list.length_le_sum_of_one_le (L : list ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i) : L.length ≤ L.sum",
    "theorem": "(L : list ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i) : L.length ≤ L.sum",
    "args": "(L : list ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i)",
    "doc_string": " If all elements in a list are bounded below by `1`, then the length of the list is bounded by the sum of the elements.",
    "kind": "theorem",
    "type": "L.length ≤ L.sum"
  },
  {
    "name": "subring.list_sum_mem",
    "statement": "theorem subring.list_sum_mem {R : Type u} [ring R] (s : subring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s",
    "theorem": "{R : Type u} [ring R] (s : subring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s",
    "args": "{R : Type u} [ring R] (s : subring R) {l : list R}",
    "doc_string": "Sum of a list of elements in a subring is in the subring.",
    "kind": "theorem",
    "type": "(∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s"
  },
  {
    "name": "multiset.range",
    "statement": "def multiset.range (n : ℕ) : multiset ℕ",
    "theorem": "(n : ℕ) : multiset ℕ",
    "args": "(n : ℕ)",
    "doc_string": "`range n` is the multiset lifted from the list `range n`,  that is, the set `{0, 1, ..., n-1}`.",
    "kind": "def",
    "type": "multiset ℕ"
  },
  {
    "name": "ring",
    "statement": "structure ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A ring is a type with the following structures: additive commutative group (`add_comm_group`), multiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a `semiring` with a negation operation making it an additive group.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "simple_graph.dart",
    "statement": "structure simple_graph.dart {V : Type u} (G : simple_graph V) : Type u",
    "theorem": "{V : Type u} (G : simple_graph V) : Type u",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": " A `dart` is an oriented edge, implemented as an ordered pair of adjacent vertices. This terminology comes from combinatorial maps, and they are also known as \"half-edges\" or \"bonds.\"",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "is_simple_order.lattice",
    "statement": "def is_simple_order.lattice {α : Type u_1} [decidable_eq α] [partial_order α] [bounded_order α] [is_simple_order α] : lattice α",
    "theorem": "{α : Type u_1} [decidable_eq α] [partial_order α] [bounded_order α] [is_simple_order α] : lattice α",
    "args": "{α : Type u_1} [decidable_eq α] [partial_order α] [bounded_order α] [is_simple_order α]",
    "doc_string": " A simple partial ordered `bounded_order` induces a lattice. This is not an instance to prevent loops",
    "kind": "def",
    "type": "lattice α"
  },
  {
    "name": "CpltSepUniformSpace.of",
    "statement": "def CpltSepUniformSpace.of (X : Type u) [uniform_space X] [complete_space X] [separated_space X] : CpltSepUniformSpace",
    "theorem": "(X : Type u) [uniform_space X] [complete_space X] [separated_space X] : CpltSepUniformSpace",
    "args": "(X : Type u) [uniform_space X] [complete_space X] [separated_space X]",
    "doc_string": "Construct a bundled `UniformSpace` from the underlying type and the appropriate typeclasses.",
    "kind": "def",
    "type": "CpltSepUniformSpace"
  },
  {
    "name": "upper_semicontinuous",
    "statement": "def upper_semicontinuous {α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) : Prop",
    "args": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β)",
    "doc_string": " A real function `f` is upper semicontinuous if, for any `ε > 0`, for any `x`, for all `x'` close enough to `x`, then `f x'` is at most `f x + ε`. We formulate this in a general preordered space, using an arbitrary `y > f x` instead of `f x + ε`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "order_monoid_with_zero_hom",
    "statement": "structure order_monoid_with_zero_hom (α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [mul_zero_one_class α] [mul_zero_one_class β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [mul_zero_one_class α] [mul_zero_one_class β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [mul_zero_one_class α] [mul_zero_one_class β]",
    "doc_string": " `order_monoid_with_zero_hom α β` is the type of functions `α → β` that preserve the `monoid_with_zero` structure.  `order_monoid_with_zero_hom` is also used for group homomorphisms.  When possible, instead of parametrizing results over `(f : α →+ β)`, you should parametrize over `(F : Type*) [order_monoid_with_zero_hom_class F α β] (f : F)`.  When you extend this structure, make sure to extend `order_monoid_with_zero_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "multiset.Icc",
    "statement": "def multiset.Icc {α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α)",
    "doc_string": " The multiset of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `set.Icc a b` as a multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "finset.nonempty",
    "statement": "def finset.nonempty {α : Type u_1} (s : finset α) : Prop",
    "theorem": "{α : Type u_1} (s : finset α) : Prop",
    "args": "{α : Type u_1} (s : finset α)",
    "doc_string": " The property `s.nonempty` expresses the fact that the finset `s` is not empty. It should be used in theorem assumptions instead of `∃ x, x ∈ s` or `s ≠ ∅` as it gives access to a nice API thanks to the dot notation.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "encodable.decidable_eq_of_encodable",
    "statement": "def encodable.decidable_eq_of_encodable (α : Type u_1) [encodable α] : decidable_eq α",
    "theorem": "(α : Type u_1) [encodable α] : decidable_eq α",
    "args": "(α : Type u_1) [encodable α]",
    "doc_string": " An encodable type has decidable equality. Not set as an instance because this is usually not the best way to infer decidability.",
    "kind": "def",
    "type": "decidable_eq α"
  },
  {
    "name": "le_inv_of_le_inv",
    "statement": "theorem le_inv_of_le_inv {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} : a ≤ b⁻¹ → b ≤ a⁻¹",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} : a ≤ b⁻¹ → b ≤ a⁻¹",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the forward direction of le_inv'`.",
    "kind": "theorem",
    "type": "a ≤ b⁻¹ → b ≤ a⁻¹"
  },
  {
    "name": "stream.any",
    "statement": "def stream.any {α : Type u} (p : α → Prop) (s : stream α) : Prop",
    "theorem": "{α : Type u} (p : α → Prop) (s : stream α) : Prop",
    "args": "{α : Type u} (p : α → Prop) (s : stream α)",
    "doc_string": "Proposition saying that at least one element of a stream satisfies a predicate.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "submodule.fg",
    "statement": "def submodule.fg {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : Prop",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (N : submodule R M) : Prop",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (N : submodule R M)",
    "doc_string": "A submodule of `M` is finitely generated if it is the span of a finite subset of `M`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.skeleton",
    "statement": "def category_theory.skeleton (C : Type u₁) [category_theory.category C] : Type u₁",
    "theorem": "(C : Type u₁) [category_theory.category C] : Type u₁",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": "Construct the skeleton category as the induced category on the isomorphism classes, and derive its category structure.",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "is_noetherian_pi'",
    "statement": "def is_noetherian_pi' {R : Type u_1} {ι : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype ι] [is_noetherian R M] : is_noetherian R (ι → M)",
    "theorem": "{R : Type u_1} {ι : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype ι] [is_noetherian R M] : is_noetherian R (ι → M)",
    "args": "{R : Type u_1} {ι : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype ι] [is_noetherian R M]",
    "doc_string": " A version of `is_noetherian_pi` for non-dependent functions. We need this instance because sometimes Lean fails to apply the dependent version in non-dependent settings (e.g., it fails to prove that `ι → ℝ` is finite dimensional over `ℝ`).",
    "kind": "def",
    "type": "is_noetherian R (ι → M)"
  },
  {
    "name": "equiv.perm.sign_bij_aux",
    "statement": "def equiv.perm.sign_bij_aux {n : ℕ} (f : equiv.perm (fin n)) (a : Σ (a : fin n), fin n) : Σ (a : fin n), fin n",
    "theorem": "{n : ℕ} (f : equiv.perm (fin n)) (a : Σ (a : fin n), fin n) : Σ (a : fin n), fin n",
    "args": "{n : ℕ} (f : equiv.perm (fin n)) (a : Σ (a : fin n), fin n)",
    "doc_string": "`sign_bij_aux f ⟨a, b⟩` returns the pair consisting of `f a` and `f b` in decreasing order.",
    "kind": "def",
    "type": "Σ (a : fin n), fin n"
  },
  {
    "name": "filter.comm_monoid",
    "statement": "def filter.comm_monoid {α : Type u_2} [comm_monoid α] : comm_monoid (filter α)",
    "theorem": "{α : Type u_2} [comm_monoid α] : comm_monoid (filter α)",
    "args": "{α : Type u_2} [comm_monoid α]",
    "doc_string": "`filter α` is a `comm_monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "comm_monoid (filter α)"
  },
  {
    "name": "vector.zip_with",
    "statement": "def vector.zip_with {α : Type u_1} {β : Type u_2} {γ : Type u_3} {n : ℕ} (f : α → β → γ) : vector α n → vector β n → vector γ n",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {n : ℕ} (f : α → β → γ) : vector α n → vector β n → vector γ n",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {n : ℕ} (f : α → β → γ)",
    "doc_string": "Apply the function `f : α → β → γ` to each corresponding pair of elements from two vectors.",
    "kind": "def",
    "type": "vector α n → vector β n → vector γ n"
  },
  {
    "name": "algebraic_geometry.LocallyRingedSpace",
    "statement": "structure algebraic_geometry.LocallyRingedSpace  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": " A `LocallyRingedSpace` is a topological space equipped with a sheaf of commutative rings such that all the stalks are local rings.  A morphism of locally ringed spaces is a morphism of ringed spaces such that the morphisms induced on stalks are local ring homomorphisms.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "subsemiring.zero_mem",
    "statement": "theorem subsemiring.zero_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 0 ∈ s",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 0 ∈ s",
    "args": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R)",
    "doc_string": "A subsemiring contains the semiring's 0.",
    "kind": "theorem",
    "type": "0 ∈ s"
  },
  {
    "name": "list.mmap_filter",
    "statement": "def list.mmap_filter {m : Type → Type v} [monad m] {α : Type u_1} {β : Type} (f : α → m (option β)) : list α → m (list β)",
    "theorem": "{m : Type → Type v} [monad m] {α : Type u_1} {β : Type} (f : α → m (option β)) : list α → m (list β)",
    "args": "{m : Type → Type v} [monad m] {α : Type u_1} {β : Type} (f : α → m (option β))",
    "doc_string": "Filters and maps elements of a list",
    "kind": "def",
    "type": "list α → m (list β)"
  },
  {
    "name": "stream.is_seq",
    "statement": "def stream.is_seq {α : Type u} (s : stream (option α)) : Prop",
    "theorem": "{α : Type u} (s : stream (option α)) : Prop",
    "args": "{α : Type u} (s : stream (option α))",
    "doc_string": "A stream `s : option α` is a sequence if `s.nth n = none` implies `s.nth (n + 1) = none`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "has_measurable_div",
    "statement": "structure has_measurable_div (G₀ : Type u_1) [measurable_space G₀] [has_div G₀] : Prop",
    "theorem": "(G₀ : Type u_1) [measurable_space G₀] [has_div G₀] : Prop",
    "args": "(G₀ : Type u_1) [measurable_space G₀] [has_div G₀]",
    "doc_string": " We say that a type `has_measurable_div` if `((/) c)` and `(/ c)` are measurable functions. For a typeclass assuming measurability of `uncurry (/)` see `has_measurable_div₂`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "list.extractp",
    "statement": "def list.extractp {α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → option α × list α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → option α × list α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p]",
    "doc_string": "`extractp p l` returns a pair of an element `a` of `l` satisfying the predicate  `p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`.",
    "kind": "def",
    "type": "list α → option α × list α"
  },
  {
    "name": "is_add_group_hom.neg",
    "statement": "theorem is_add_group_hom.neg {α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_group_hom (λ (a : α), -f a)",
    "theorem": "{α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_group_hom (λ (a : α), -f a)",
    "args": "{α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f)",
    "doc_string": "The negation of an additive group homomorphism is an additive group homomorphism if the target is commutative.",
    "kind": "theorem",
    "type": "is_add_group_hom (λ (a : α), -f a)"
  },
  {
    "name": "left.one_le_mul",
    "statement": "theorem left.one_le_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_le_mul`.",
    "kind": "theorem",
    "type": "1 ≤ a * b"
  },
  {
    "name": "is_compactly_generated",
    "statement": "structure is_compactly_generated (α : Type u_2) [complete_lattice α] : Prop",
    "theorem": "(α : Type u_2) [complete_lattice α] : Prop",
    "args": "(α : Type u_2) [complete_lattice α]",
    "doc_string": " A complete lattice is said to be compactly generated if any element is the `Sup` of compact elements.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "zmod.legendre_sym_eq_neg_one_iff",
    "statement": "theorem zmod.legendre_sym_eq_neg_one_iff (p : ℕ) [fact (nat.prime p)] {a : ℤ} : zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a",
    "theorem": "(p : ℕ) [fact (nat.prime p)] {a : ℤ} : zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a",
    "args": "(p : ℕ) [fact (nat.prime p)] {a : ℤ}",
    "doc_string": "`legendre_sym p a = -1` iff`a` is a nonsquare mod `p`.",
    "kind": "theorem",
    "type": "zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a"
  },
  {
    "name": "measure_theory.outer_measure.Inf_gen",
    "statement": "def measure_theory.outer_measure.Inf_gen {α : Type u_1} (m : set (measure_theory.outer_measure α)) (s : set α) : ennreal",
    "theorem": "{α : Type u_1} (m : set (measure_theory.outer_measure α)) (s : set α) : ennreal",
    "args": "{α : Type u_1} (m : set (measure_theory.outer_measure α)) (s : set α)",
    "doc_string": "Given a set of outer measures, we define a new function that on a set `s` is defined to be the  infimum of `μ(s)` for the outer measures `μ` in the collection. We ensure that this  function is defined to be `0` on `∅`, even if the collection of outer measures is empty.  The outer measure generated by this function is the infimum of the given outer measures.",
    "kind": "def",
    "type": "ennreal"
  },
  {
    "name": "ulower.down",
    "statement": "def ulower.down {α : Type u_1} [encodable α] (a : α) : ulower α",
    "theorem": "{α : Type u_1} [encodable α] (a : α) : ulower α",
    "args": "{α : Type u_1} [encodable α] (a : α)",
    "doc_string": "Lowers an `a : α` into `ulower α`.",
    "kind": "def",
    "type": "ulower α"
  },
  {
    "name": "measurable_space.prod",
    "statement": "def measurable_space.prod {α : Type u_1} {β : Type u_2} (m₁ : measurable_space α) (m₂ : measurable_space β) : measurable_space (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (m₁ : measurable_space α) (m₂ : measurable_space β) : measurable_space (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} (m₁ : measurable_space α) (m₂ : measurable_space β)",
    "doc_string": "A `measurable_space` structure on the product of two measurable spaces.",
    "kind": "def",
    "type": "measurable_space (α × β)"
  },
  {
    "name": "path_connected_space",
    "statement": "structure path_connected_space (X : Type u_4) [topological_space X] : Prop",
    "theorem": "(X : Type u_4) [topological_space X] : Prop",
    "args": "(X : Type u_4) [topological_space X]",
    "doc_string": " A topological space is path-connected if it is non-empty and every two points can be joined by a continuous path.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "linear_extension",
    "statement": "def linear_extension (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A type alias for `α`, intended to extend a partial order on `α` to a linear order.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "matrix.det_invertible_of_invertible",
    "statement": "def matrix.det_invertible_of_invertible {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A] : invertible A.det",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A] : invertible A.det",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A]",
    "doc_string": "If `A` has a constructive inverse, produce one for `A.det`.",
    "kind": "def",
    "type": "invertible A.det"
  },
  {
    "name": "has_btw.btw.not_sbtw",
    "statement": "theorem has_btw.btw.not_sbtw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c)",
    "doc_string": "**Alias** of not_sbtw_of_btw`.",
    "kind": "theorem",
    "type": "¬has_sbtw.sbtw c b a"
  },
  {
    "name": "fintype_perm",
    "statement": "def fintype_perm {α : Type u_1} [decidable_eq α] [fintype α] : fintype (equiv.perm α)",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] : fintype (equiv.perm α)",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α]",
    "doc_string": "The collection of permutations of a fintype is a fintype.",
    "kind": "def",
    "type": "fintype (equiv.perm α)"
  },
  {
    "name": "poly.map",
    "statement": "def poly.map {α : Type u_1} {β : Type u_2} (f : α → β) (g : poly α) : poly β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (g : poly α) : poly β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (g : poly α)",
    "doc_string": "Map the index set of variables, replacing `x_i` with `x_(f i)`.",
    "kind": "def",
    "type": "poly β"
  },
  {
    "name": "local_homeomorph.of_set",
    "statement": "def local_homeomorph.of_set {α : Type u_1} [topological_space α] (s : set α) (hs : is_open s) : local_homeomorph α α",
    "theorem": "{α : Type u_1} [topological_space α] (s : set α) (hs : is_open s) : local_homeomorph α α",
    "args": "{α : Type u_1} [topological_space α] (s : set α) (hs : is_open s)",
    "doc_string": "The identity local equiv on a set `s`",
    "kind": "def",
    "type": "local_homeomorph α α"
  },
  {
    "name": "contracting_with",
    "statement": "def contracting_with {α : Type u_1} [emetric_space α] (K : nnreal) (f : α → α) : Prop",
    "theorem": "{α : Type u_1} [emetric_space α] (K : nnreal) (f : α → α) : Prop",
    "args": "{α : Type u_1} [emetric_space α] (K : nnreal) (f : α → α)",
    "doc_string": "A map is said to be `contracting_with K`, if `K < 1` and `f` is `lipschitz_with K`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "witt_vector.witt_mul_n",
    "statement": "def witt_vector.witt_mul_n (p : ℕ) [hp : fact (nat.prime p)] : ℕ → ℕ → mv_polynomial ℕ ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : ℕ → ℕ → mv_polynomial ℕ ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": " `witt_mul_n p n` is the family of polynomials that computes the coefficients of `x * n` in terms of the coefficients of the Witt vector `x`.",
    "kind": "def",
    "type": "ℕ → ℕ → mv_polynomial ℕ ℤ"
  },
  {
    "name": "qpf.is_uniform",
    "statement": "def qpf.is_uniform {F : Type u → Type u} [functor F] (q : qpf F) : Prop",
    "theorem": "{F : Type u → Type u} [functor F] (q : qpf F) : Prop",
    "args": "{F : Type u → Type u} [functor F] (q : qpf F)",
    "doc_string": " A qpf is said to be uniform if every polynomial functor representing a single value all have the same range.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "continuous_map.continuous_coe",
    "statement": "theorem continuous_map.continuous_coe {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β]",
    "doc_string": "See also `continuous_map.continuous_coe'`",
    "kind": "theorem",
    "type": "continuous coe_fn"
  },
  {
    "name": "decidable_of_iff'",
    "statement": "def decidable_of_iff' {a : Prop} (b : Prop) (h : a ↔ b) [D : decidable b] : decidable a",
    "theorem": "{a : Prop} (b : Prop) (h : a ↔ b) [D : decidable b] : decidable a",
    "args": "{a : Prop} (b : Prop) (h : a ↔ b) [D : decidable b]",
    "doc_string": " Transfer decidability of `b` to decidability of `a`, if the propositions are equivalent. This is the same as `decidable_of_iff` but the iff is flipped.",
    "kind": "def",
    "type": "decidable a"
  },
  {
    "name": "is_field.to_field",
    "statement": "def is_field.to_field {R : Type u} [ring R] (h : is_field R) : field R",
    "theorem": "{R : Type u} [ring R] (h : is_field R) : field R",
    "args": "{R : Type u} [ring R] (h : is_field R)",
    "doc_string": "Transferring from is_field to field",
    "kind": "def",
    "type": "field R"
  },
  {
    "name": "left_coset_equivalence",
    "statement": "def left_coset_equivalence {α : Type u_1} [has_mul α] (s : set α) (a b : α) : Prop",
    "theorem": "{α : Type u_1} [has_mul α] (s : set α) (a b : α) : Prop",
    "args": "{α : Type u_1} [has_mul α] (s : set α) (a b : α)",
    "doc_string": "Equality of two left cosets `a * s` and `b * s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "turing.partrec_to_TM2.cont'",
    "statement": "inductive turing.partrec_to_TM2.cont'  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Continuations as in `to_partrec.cont` but with the data removed. This is done because we want the set of all continuations in the program to be finite (so that it can ultimately be encoded into the finite state machine of a Turing machine), but a continuation can handle a potentially infinite number of data values during execution.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "left.add_pos'",
    "statement": "theorem left.add_pos' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos'`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits",
    "statement": "theorem category_theory.limits.has_finite_wide_pushouts_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C]",
    "doc_string": "Finite wide pushouts are finite colimits, so if `C` has all finite colimits, it also has finite wide pushouts",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_wide_pushouts C"
  },
  {
    "name": "fin.find_spec",
    "statement": "theorem fin.find_spec {n : ℕ} (p : fin n → Prop) [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) : p i",
    "theorem": "{n : ℕ} (p : fin n → Prop) [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) : p i",
    "args": "{n : ℕ} (p : fin n → Prop) [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p)",
    "doc_string": "If `find p = some i`, then `p i` holds",
    "kind": "theorem",
    "type": "p i"
  },
  {
    "name": "pgame.le_lf",
    "statement": "def pgame.le_lf (x y : pgame) : Prop × Prop",
    "theorem": "(x y : pgame) : Prop × Prop",
    "args": "(x y : pgame)",
    "doc_string": "Define simultaneously by mutual induction the `≤` relation and its swapped converse `⧏` on  pre-games.   The ZFC definition says that `x = {xL | xR}` is less or equal to `y = {yL | yR}` if  `∀ x₁ ∈ xL, x₁ ⧏ y` and `∀ y₂ ∈ yR, x ⧏ y₂`, where `x ⧏ y` means `¬ y ≤ x`. This is a tricky  induction because it only decreases one side at a time, and it also swaps the arguments in the  definition of `≤`. The solution is to define `x ≤ y` and `x ⧏ y` simultaneously.",
    "kind": "def",
    "type": "Prop × Prop"
  },
  {
    "name": "monoid.gmonoid",
    "statement": "def monoid.gmonoid (ι : Type u_1) {R : Type u_2} [add_monoid ι] [monoid R] : graded_monoid.gmonoid (λ (i : ι), R)",
    "theorem": "(ι : Type u_1) {R : Type u_2} [add_monoid ι] [monoid R] : graded_monoid.gmonoid (λ (i : ι), R)",
    "args": "(ι : Type u_1) {R : Type u_2} [add_monoid ι] [monoid R]",
    "doc_string": " If all grades are the same type and themselves form a monoid, then there is a trivial grading structure.",
    "kind": "def",
    "type": "graded_monoid.gmonoid (λ (i : ι), R)"
  },
  {
    "name": "mvpfunctor.Mp",
    "statement": "def mvpfunctor.Mp {n : ℕ} (P : mvpfunctor (n + 1)) : mvpfunctor n",
    "theorem": "{n : ℕ} (P : mvpfunctor (n + 1)) : mvpfunctor n",
    "args": "{n : ℕ} (P : mvpfunctor (n + 1))",
    "doc_string": " Polynomial functor of the M-type of `P`. `A` is a data-less possibly infinite tree whereas, for a given `a : A`, `B a` is a valid path in tree `a` so that `Wp.obj α` is made of a tree and a function from its valid paths to the values it contains",
    "kind": "def",
    "type": "mvpfunctor n"
  },
  {
    "name": "pos_num.min_fac",
    "statement": "def pos_num.min_fac  : pos_num → pos_num",
    "theorem": " : pos_num → pos_num",
    "args": "",
    "doc_string": "Returns the smallest prime factor of `n ≠ 1`.",
    "kind": "def",
    "type": "pos_num → pos_num"
  },
  {
    "name": "prod.non_unital_non_assoc_semiring",
    "statement": "def prod.non_unital_non_assoc_semiring {R : Type u_1} {S : Type u_3} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] : non_unital_non_assoc_semiring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S] : non_unital_non_assoc_semiring (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [non_unital_non_assoc_semiring R] [non_unital_non_assoc_semiring S]",
    "doc_string": "Product of two `non_unital_non_assoc_semiring`s is a `non_unital_non_assoc_semiring`.",
    "kind": "def",
    "type": "non_unital_non_assoc_semiring (R × S)"
  },
  {
    "name": "with_bot.mul_zero_one_class",
    "statement": "def with_bot.mul_zero_one_class {α : Type u} [decidable_eq α] [mul_zero_one_class α] [nontrivial α] : mul_zero_one_class (with_bot α)",
    "theorem": "{α : Type u} [decidable_eq α] [mul_zero_one_class α] [nontrivial α] : mul_zero_one_class (with_bot α)",
    "args": "{α : Type u} [decidable_eq α] [mul_zero_one_class α] [nontrivial α]",
    "doc_string": "`nontrivial α` is needed here as otherwise we have `1 * ⊥ = ⊥` but also `= 0 * ⊥ = 0`.",
    "kind": "def",
    "type": "mul_zero_one_class (with_bot α)"
  },
  {
    "name": "sup_hom_class",
    "statement": "structure sup_hom_class (F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_sup α] [has_sup β] : Type (max u_7 u_8 u_9)",
    "theorem": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_sup α] [has_sup β] : Type (max u_7 u_8 u_9)",
    "args": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_sup α] [has_sup β]",
    "doc_string": " `sup_hom_class F α β` states that `F` is a type of `⊔`-preserving morphisms.  You should extend this class when you extend `sup_hom`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8 u_9)"
  },
  {
    "name": "list.pairwise",
    "statement": "inductive list.pairwise {α : Type u_1} (R : α → α → Prop) : list α → Prop",
    "theorem": "{α : Type u_1} (R : α → α → Prop) : list α → Prop",
    "args": "{α : Type u_1} (R : α → α → Prop)",
    "doc_string": "`pairwise R l` means that all the elements with earlier indexes are  `R`-related to all the elements with later indexes.      pairwise R [1, 2, 3] ↔ R 1 2 ∧ R 1 3 ∧ R 2 3   For example if `R = (≠)` then it asserts `l` has no duplicates,  and if `R = (<)` then it asserts that `l` is (strictly) sorted.",
    "kind": "inductive",
    "type": "list α → Prop"
  },
  {
    "name": "pfunctor.M.is_bisimulation",
    "statement": "structure pfunctor.M.is_bisimulation {F : pfunctor} (R : F.M → F.M → Prop) : Prop",
    "theorem": "{F : pfunctor} (R : F.M → F.M → Prop) : Prop",
    "args": "{F : pfunctor} (R : F.M → F.M → Prop)",
    "doc_string": " Bisimulation is the standard proof technique for equality between infinite tree-like structures",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "list.unique_of_is_empty",
    "statement": "def list.unique_of_is_empty {α : Type u} [is_empty α] : unique (list α)",
    "theorem": "{α : Type u} [is_empty α] : unique (list α)",
    "args": "{α : Type u} [is_empty α]",
    "doc_string": "There is only one list of an empty type",
    "kind": "def",
    "type": "unique (list α)"
  },
  {
    "name": "extend_from",
    "statement": "def extend_from {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (A : set X) (f : X → Y) : X → Y",
    "theorem": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (A : set X) (f : X → Y) : X → Y",
    "args": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (A : set X) (f : X → Y)",
    "doc_string": " Extend a function from a set `A`. The resulting function `g` is such that at any `x₀`, if `f` converges to some `y` as `x` tends to `x₀` within `A`, then `g x₀` is defined to be one of these `y`. Else, `g x₀` could be anything.",
    "kind": "def",
    "type": "X → Y"
  },
  {
    "name": "trace_call_stack",
    "statement": "def trace_call_stack {α : Type u} (f : thunk α) : α",
    "theorem": "{α : Type u} (f : thunk α) : α",
    "args": "{α : Type u} (f : thunk α)",
    "doc_string": "This function has a native implementation that shows the VM call stack.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "galois_insertion.lift_complete_lattice",
    "statement": "def galois_insertion.lift_complete_lattice {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [complete_lattice α] (gi : galois_insertion l u) : complete_lattice β",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [complete_lattice α] (gi : galois_insertion l u) : complete_lattice β",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [complete_lattice α] (gi : galois_insertion l u)",
    "doc_string": "Lift all suprema and infima along a Galois insertion",
    "kind": "def",
    "type": "complete_lattice β"
  },
  {
    "name": "set.maps_to",
    "statement": "def set.maps_to {α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β) : Prop",
    "args": "{α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β)",
    "doc_string": "`maps_to f a b` means that the image of `a` is contained in `b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "witt_vector.map_fun",
    "statement": "def witt_vector.map_fun {p : ℕ} {α : Type u_4} {β : Type u_5} (f : α → β) : witt_vector p α → witt_vector p β",
    "theorem": "{p : ℕ} {α : Type u_4} {β : Type u_5} (f : α → β) : witt_vector p α → witt_vector p β",
    "args": "{p : ℕ} {α : Type u_4} {β : Type u_5} (f : α → β)",
    "doc_string": " `f : α → β` induces a map from `𝕎 α` to `𝕎 β` by applying `f` componentwise. If `f` is a ring homomorphism, then so is `f`, see `witt_vector.map f`.",
    "kind": "def",
    "type": "witt_vector p α → witt_vector p β"
  },
  {
    "name": "is_ring_hom.id",
    "statement": "theorem is_ring_hom.id {α : Type u} [ring α] : is_ring_hom id",
    "theorem": "{α : Type u} [ring α] : is_ring_hom id",
    "args": "{α : Type u} [ring α]",
    "doc_string": "The identity map is a ring homomorphism.",
    "kind": "theorem",
    "type": "is_ring_hom id"
  },
  {
    "name": "subgroup.connected_component_of_one",
    "statement": "def subgroup.connected_component_of_one (G : Type u_1) [topological_space G] [group G] [topological_group G] : subgroup G",
    "theorem": "(G : Type u_1) [topological_space G] [group G] [topological_group G] : subgroup G",
    "args": "(G : Type u_1) [topological_space G] [group G] [topological_group G]",
    "doc_string": "The connected component of 1 is a subgroup of `G`.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "intermediate_field.one_mem",
    "statement": "theorem intermediate_field.one_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 1 ∈ S",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 1 ∈ S",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L)",
    "doc_string": "An intermediate field contains the ring's 1.",
    "kind": "theorem",
    "type": "1 ∈ S"
  },
  {
    "name": "set.add_antidiagonal",
    "statement": "def set.add_antidiagonal {α : Type u_1} [add_monoid α] (s t : set α) (a : α) : set (α × α)",
    "theorem": "{α : Type u_1} [add_monoid α] (s t : set α) (a : α) : set (α × α)",
    "args": "{α : Type u_1} [add_monoid α] (s t : set α) (a : α)",
    "doc_string": "`set.add_antidiagonal s t a` is the set of all pairs of an element in `s`   and an element in `t` that add to `a`.",
    "kind": "def",
    "type": "set (α × α)"
  },
  {
    "name": "polynomial.div_by_monic",
    "statement": "def polynomial.div_by_monic {R : Type u} [ring R] (p q : polynomial R) : polynomial R",
    "theorem": "{R : Type u} [ring R] (p q : polynomial R) : polynomial R",
    "args": "{R : Type u} [ring R] (p q : polynomial R)",
    "doc_string": "`div_by_monic` gives the quotient of `p` by a monic polynomial `q`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "is_descending_central_series",
    "statement": "def is_descending_central_series {G : Type u_1} [group G] (H : ℕ → subgroup G) : Prop",
    "theorem": "{G : Type u_1} [group G] (H : ℕ → subgroup G) : Prop",
    "args": "{G : Type u_1} [group G] (H : ℕ → subgroup G)",
    "doc_string": "A sequence of subgroups of `G` is a descending central series if `H 0` is `G` and  `⁅H n, G⁆ ⊆ H (n + 1)` for all `n`. Note that we do not requre that `H n = {1}` for some `n`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "encodable.encodable_of_list",
    "statement": "def encodable.encodable_of_list {α : Type u_1} [decidable_eq α] (l : list α) (H : ∀ (x : α), x ∈ l) : encodable α",
    "theorem": "{α : Type u_1} [decidable_eq α] (l : list α) (H : ∀ (x : α), x ∈ l) : encodable α",
    "args": "{α : Type u_1} [decidable_eq α] (l : list α) (H : ∀ (x : α), x ∈ l)",
    "doc_string": "A listable type with decidable equality is encodable.",
    "kind": "def",
    "type": "encodable α"
  },
  {
    "name": "unitary",
    "statement": "def unitary (R : Type u_1) [monoid R] [star_semigroup R] : submonoid R",
    "theorem": "(R : Type u_1) [monoid R] [star_semigroup R] : submonoid R",
    "args": "(R : Type u_1) [monoid R] [star_semigroup R]",
    "doc_string": "In a *-monoid, `unitary R` is the submonoid consisting of all the elements `U` of `R` such that `star U * U = 1` and `U * star U = 1`.",
    "kind": "def",
    "type": "submonoid R"
  },
  {
    "name": "add_subsemigroup.add_mem",
    "statement": "theorem add_subsemigroup.add_mem {M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S",
    "theorem": "{M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M} : x ∈ S → y ∈ S → x + y ∈ S",
    "args": "{M : Type u_1} [has_add M] (S : add_subsemigroup M) {x y : M}",
    "doc_string": "An `add_subsemigroup` is closed under addition.",
    "kind": "theorem",
    "type": "x ∈ S → y ∈ S → x + y ∈ S"
  },
  {
    "name": "skew_adjoint_matrices_lie_subalgebra",
    "statement": "def skew_adjoint_matrices_lie_subalgebra {R : Type u} {n : Type w} [comm_ring R] [decidable_eq n] [fintype n] (J : matrix n n R) : lie_subalgebra R (matrix n n R)",
    "theorem": "{R : Type u} {n : Type w} [comm_ring R] [decidable_eq n] [fintype n] (J : matrix n n R) : lie_subalgebra R (matrix n n R)",
    "args": "{R : Type u} {n : Type w} [comm_ring R] [decidable_eq n] [fintype n] (J : matrix n n R)",
    "doc_string": "The Lie subalgebra of skew-adjoint square matrices corresponding to a square matrix `J`.",
    "kind": "def",
    "type": "lie_subalgebra R (matrix n n R)"
  },
  {
    "name": "pseudo_epimorphism.id",
    "statement": "def pseudo_epimorphism.id (α : Type u_2) [preorder α] : pseudo_epimorphism α α",
    "theorem": "(α : Type u_2) [preorder α] : pseudo_epimorphism α α",
    "args": "(α : Type u_2) [preorder α]",
    "doc_string": "`id` as a `pseudo_epimorphism`.",
    "kind": "def",
    "type": "pseudo_epimorphism α α"
  },
  {
    "name": "fintype.subtype_eq",
    "statement": "def fintype.subtype_eq {α : Type u_1} (y : α) : fintype {x // x = y}",
    "theorem": "{α : Type u_1} (y : α) : fintype {x // x = y}",
    "args": "{α : Type u_1} (y : α)",
    "doc_string": " Short-circuit instance to decrease search for `unique.fintype`, since that relies on a subsingleton elimination for `unique`.",
    "kind": "def",
    "type": "fintype {x // x = y}"
  },
  {
    "name": "tactic.suggest.normalize_synonym",
    "statement": "def tactic.suggest.normalize_synonym  : name → name",
    "theorem": " : name → name",
    "args": "",
    "doc_string": " Map a name (typically a head symbol) to a \"canonical\" definitional synonym. Given a name `n`, we want a name `n'` such that a sufficiently applied expression with head symbol `n` is always definitionally equal to an expression with head symbol `n'`. Thus, we can search through all lemmas with a result type of `n'` to solve a goal with head symbol `n`.  For example, `>` is mapped to `<` because `a > b` is definitionally equal to `b < a`, and `not` is mapped to `false` because `¬ a` is definitionally equal to `p → false` The default is that the original argument is returned, so `<` is just mapped to `<`.  `normalize_synonym` is called for every lemma in the library, so it needs to be fast.",
    "kind": "def",
    "type": "name → name"
  },
  {
    "name": "multiset.zero",
    "statement": "def multiset.zero {α : Type u_1} : multiset α",
    "theorem": "{α : Type u_1} : multiset α",
    "args": "{α : Type u_1}",
    "doc_string": "`0 : multiset α` is the empty set",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "set.center",
    "statement": "def set.center (M : Type u_1) [has_mul M] : set M",
    "theorem": "(M : Type u_1) [has_mul M] : set M",
    "args": "(M : Type u_1) [has_mul M]",
    "doc_string": "The center of a magma.",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "function.bijective.comp_left",
    "statement": "theorem function.bijective.comp_left {α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g) : function.bijective (function.comp g)",
    "theorem": "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g) : function.bijective (function.comp g)",
    "args": "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g)",
    "doc_string": "Composition by an bijective function on the left is itself bijective.",
    "kind": "theorem",
    "type": "function.bijective (function.comp g)"
  },
  {
    "name": "cardinal.sum",
    "statement": "def cardinal.sum {ι : Type u_1} (f : ι → cardinal) : cardinal",
    "theorem": "{ι : Type u_1} (f : ι → cardinal) : cardinal",
    "args": "{ι : Type u_1} (f : ι → cardinal)",
    "doc_string": "The indexed sum of cardinals is the cardinality of the  indexed disjoint union, i.e. sigma type.",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "set.monoid",
    "statement": "def set.monoid {α : Type u_2} [monoid α] : monoid (set α)",
    "theorem": "{α : Type u_2} [monoid α] : monoid (set α)",
    "args": "{α : Type u_2} [monoid α]",
    "doc_string": "`set α` is a `monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "monoid (set α)"
  },
  {
    "name": "cardinal.succ_order",
    "statement": "def cardinal.succ_order  : succ_order cardinal",
    "theorem": " : succ_order cardinal",
    "args": "",
    "doc_string": "Note that the successor of `c` is not the same as `c + 1` except in the case of finite `c`.",
    "kind": "def",
    "type": "succ_order cardinal"
  },
  {
    "name": "CompleteLattice",
    "statement": "def CompleteLattice  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of complete lattices.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "is_max_chain",
    "statement": "def is_max_chain {α : Type u_1} (r : α → α → Prop) (s : set α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s : set α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (s : set α)",
    "doc_string": "A chain `s` is a maximal chain if there does not exists a chain strictly including `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pi.has_continuous_mul'",
    "statement": "def pi.has_continuous_mul' {ι : Type u_1} {M : Type u_4} [topological_space M] [has_mul M] [has_continuous_mul M] : has_continuous_mul (ι → M)",
    "theorem": "{ι : Type u_1} {M : Type u_4} [topological_space M] [has_mul M] [has_continuous_mul M] : has_continuous_mul (ι → M)",
    "args": "{ι : Type u_1} {M : Type u_4} [topological_space M] [has_mul M] [has_continuous_mul M]",
    "doc_string": " A version of `pi.has_continuous_mul` for non-dependent functions. It is needed because sometimes Lean fails to use `pi.has_continuous_mul` for non-dependent functions.",
    "kind": "def",
    "type": "has_continuous_mul (ι → M)"
  },
  {
    "name": "W_type.to_sigma",
    "statement": "def W_type.to_sigma {α : Type u_1} {β : α → Type u_2} : W_type β → (Σ (a : α), β a → W_type β)",
    "theorem": "{α : Type u_1} {β : α → Type u_2} : W_type β → (Σ (a : α), β a → W_type β)",
    "args": "{α : Type u_1} {β : α → Type u_2}",
    "doc_string": "The canonical map to the corresponding sigma type, returning the label of a node as an  element `a` of `α`, and the children of the node as a function `β a → W_type β`.",
    "kind": "def",
    "type": "W_type β → (Σ (a : α), β a → W_type β)"
  },
  {
    "name": "has_besicovitch_covering",
    "statement": "structure has_besicovitch_covering (α : Type u_1) [metric_space α] : Prop",
    "theorem": "(α : Type u_1) [metric_space α] : Prop",
    "args": "(α : Type u_1) [metric_space α]",
    "doc_string": " A metric space has the Besicovitch covering property if there exist `N` and `τ > 1` such that there are no satellite configuration of parameter `τ` with `N+1` points. This is the condition that guarantees that the measurable Besicovitch covering theorem holds. It is satified by finite-dimensional real vector spaces.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "set.Icc",
    "statement": "def set.Icc {α : Type u_1} [preorder α] (a b : α) : set α",
    "theorem": "{α : Type u_1} [preorder α] (a b : α) : set α",
    "args": "{α : Type u_1} [preorder α] (a b : α)",
    "doc_string": "Left-closed right-closed interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "int.le_self_pow_two",
    "statement": "theorem int.le_self_pow_two (b : ℤ) : b ≤ b ^ 2",
    "theorem": "(b : ℤ) : b ≤ b ^ 2",
    "args": "(b : ℤ)",
    "doc_string": "**Alias** of int.le_self_sq`.",
    "kind": "theorem",
    "type": "b ≤ b ^ 2"
  },
  {
    "name": "parser.conditionally_unfailing",
    "statement": "structure parser.conditionally_unfailing {α : Type} (p : parser α) : Prop",
    "theorem": "{α : Type} (p : parser α) : Prop",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "A `parser a` is defined to be `conditionally_unfailing` if it produces a `done` `parse_result` as long as it is parsing within the provided `char_buffer`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.initial_mono_class_of_disjoint_coproducts",
    "statement": "theorem category_theory.limits.initial_mono_class_of_disjoint_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C]",
    "doc_string": " If `C` has disjoint coproducts, any morphism out of initial is mono. Note it isn't true in general that `C` has strict initial objects, for instance consider the category of types and partial functions.",
    "kind": "theorem",
    "type": "category_theory.limits.initial_mono_class C"
  },
  {
    "name": "dlist.cons",
    "statement": "def dlist.cons {α : Type u} (x : α) : dlist α → dlist α",
    "theorem": "{α : Type u} (x : α) : dlist α → dlist α",
    "args": "{α : Type u} (x : α)",
    "doc_string": "`O(1)` Prepend a single element to a dlist",
    "kind": "def",
    "type": "dlist α → dlist α"
  },
  {
    "name": "polynomial.cyclotomic_pos'",
    "statement": "theorem polynomial.cyclotomic_pos' (n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)",
    "theorem": "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)",
    "args": "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x)",
    "doc_string": " Cyclotomic polynomials are always positive on inputs larger than one. Similar to `cyclotomic_pos` but with the condition on the input rather than index of the cyclotomic polynomial.",
    "kind": "theorem",
    "type": "0 < polynomial.eval x (polynomial.cyclotomic n R)"
  },
  {
    "name": "algebraic_geometry.PresheafedSpace.category_of_PresheafedSpaces",
    "statement": "def algebraic_geometry.PresheafedSpace.category_of_PresheafedSpaces (C : Type u) [category_theory.category C] : category_theory.category (algebraic_geometry.PresheafedSpace C)",
    "theorem": "(C : Type u) [category_theory.category C] : category_theory.category (algebraic_geometry.PresheafedSpace C)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "The category of PresheafedSpaces. Morphisms are pairs, a continuous map and a presheaf map    from the presheaf on the target to the pushforward of the presheaf on the source.",
    "kind": "def",
    "type": "category_theory.category (algebraic_geometry.PresheafedSpace C)"
  },
  {
    "name": "has_variable_names",
    "statement": "structure has_variable_names (α : Sort u) : Type",
    "theorem": "(α : Sort u) : Type",
    "args": "(α : Sort u)",
    "doc_string": "Type class for associating a type `α` with typical variable names for elements of `α`. See `tactic.typical_variable_names`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "lt_tsub_of_add_lt_right",
    "statement": "theorem lt_tsub_of_add_lt_right {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] (h : a + c < b) : a < b - c",
    "theorem": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] (h : a + c < b) : a < b - c",
    "args": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} [contravariant_class α α has_add.add has_le.le] (h : a + c < b)",
    "doc_string": "This lemma (and some of its corollaries also holds for `ennreal`,  but this proof doesn't work for it.  Maybe we should add this lemma as field to `has_ordered_sub`?",
    "kind": "theorem",
    "type": "a < b - c"
  },
  {
    "name": "primrec",
    "statement": "def primrec {α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (f : α → β)",
    "doc_string": "`primrec f` means `f` is primitive recursive (after  encoding its input and output as natural numbers).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "con.pi",
    "statement": "def con.pi {ι : Type u_1} {f : ι → Type u_2} [Π (i : ι), has_mul (f i)] (C : Π (i : ι), con (f i)) : con (Π (i : ι), f i)",
    "theorem": "{ι : Type u_1} {f : ι → Type u_2} [Π (i : ι), has_mul (f i)] (C : Π (i : ι), con (f i)) : con (Π (i : ι), f i)",
    "args": "{ι : Type u_1} {f : ι → Type u_2} [Π (i : ι), has_mul (f i)] (C : Π (i : ι), con (f i))",
    "doc_string": "The product of an indexed collection of congruence relations.",
    "kind": "def",
    "type": "con (Π (i : ι), f i)"
  },
  {
    "name": "semilattice_sup",
    "statement": "structure semilattice_sup (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A `semilattice_sup` is a join-semilattice, that is, a partial order  with a join (a.k.a. lub / least upper bound, sup / supremum) operation  `⊔` which is the least element larger than both factors.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "division_ring",
    "statement": "structure division_ring (K : Type u) : Type u",
    "theorem": "(K : Type u) : Type u",
    "args": "(K : Type u)",
    "doc_string": "A `division_ring` is a `ring` with multiplicative inverses for nonzero elements",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "submonoid.center",
    "statement": "def submonoid.center (M : Type u_1) [monoid M] : submonoid M",
    "theorem": "(M : Type u_1) [monoid M] : submonoid M",
    "args": "(M : Type u_1) [monoid M]",
    "doc_string": "The center of a monoid `M` is the set of elements that commute with everything in `M`",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "polynomial.next_coeff_up",
    "statement": "def polynomial.next_coeff_up {R : Type u} [semiring R] (p : polynomial R) : R",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : R",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": "The second-lowest coefficient, or 0 for constants",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "is_submonoid",
    "statement": "structure is_submonoid {M : Type u_1} [monoid M] (s : set M) : Prop",
    "theorem": "{M : Type u_1} [monoid M] (s : set M) : Prop",
    "args": "{M : Type u_1} [monoid M] (s : set M)",
    "doc_string": " `s` is a submonoid: a set containing 1 and closed under multiplication. Note that this structure is deprecated, and the bundled variant `submonoid M` should be preferred.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "list.mmap_upper_triangle",
    "statement": "def list.mmap_upper_triangle {m : Type u → Type u_1} [monad m] {α β : Type u} (f : α → α → m β) : list α → m (list β)",
    "theorem": "{m : Type u → Type u_1} [monad m] {α β : Type u} (f : α → α → m β) : list α → m (list β)",
    "args": "{m : Type u → Type u_1} [monad m] {α β : Type u} (f : α → α → m β)",
    "doc_string": "`mmap_upper_triangle f l` calls `f` on all elements in the upper triangular part of `l × l`. That is, for each `e ∈ l`, it will run `f e e` and then `f e e'` for each `e'` that appears after `e` in `l`.  Example: suppose `l = [1, 2, 3]`. `mmap_upper_triangle f l` will produce the list `[f 1 1, f 1 2, f 1 3, f 2 2, f 2 3, f 3 3]`.",
    "kind": "def",
    "type": "list α → m (list β)"
  },
  {
    "name": "monoid.closure_mono",
    "statement": "theorem monoid.closure_mono {M : Type u_1} [monoid M] {s t : set M} (h : s ⊆ t) : monoid.closure s ⊆ monoid.closure t",
    "theorem": "{M : Type u_1} [monoid M] {s t : set M} (h : s ⊆ t) : monoid.closure s ⊆ monoid.closure t",
    "args": "{M : Type u_1} [monoid M] {s t : set M} (h : s ⊆ t)",
    "doc_string": "Given subsets `t` and `s` of a monoid `M`, if `s ⊆ t`, the submonoid of `M` generated by `s` is    contained in the submonoid generated by `t`.",
    "kind": "theorem",
    "type": "monoid.closure s ⊆ monoid.closure t"
  },
  {
    "name": "category_theory.discrete_category",
    "statement": "def category_theory.discrete_category (α : Type u₁) : category_theory.small_category (category_theory.discrete α)",
    "theorem": "(α : Type u₁) : category_theory.small_category (category_theory.discrete α)",
    "args": "(α : Type u₁)",
    "doc_string": "The \"discrete\" category on a type, whose morphisms are equalities.  Because we do not allow morphisms in `Prop` (only in `Type`), somewhat annoyingly we have to define `X ⟶ Y` as `ulift (plift (X = Y))`.  See <https://stacks.math.columbia.edu/tag/001A>",
    "kind": "def",
    "type": "category_theory.small_category (category_theory.discrete α)"
  },
  {
    "name": "function.End",
    "statement": "def function.End (α : Type u_6) : Type u_6",
    "theorem": "(α : Type u_6) : Type u_6",
    "args": "(α : Type u_6)",
    "doc_string": " The monoid of endomorphisms.  Note that this is generalized by `category_theory.End` to categories other than `Type u`.",
    "kind": "def",
    "type": "Type u_6"
  },
  {
    "name": "list.palindrome",
    "statement": "inductive list.palindrome {α : Type u_1} : list α → Prop",
    "theorem": "{α : Type u_1} : list α → Prop",
    "args": "{α : Type u_1}",
    "doc_string": "`palindrome l` asserts that `l` is a palindrome. This is defined inductively:  * The empty list is a palindrome; * A list with one element is a palindrome; * Adding the same element to both ends of a palindrome results in a bigger palindrome.",
    "kind": "inductive",
    "type": "list α → Prop"
  },
  {
    "name": "joined",
    "statement": "def joined {X : Type u_1} [topological_space X] (x y : X) : Prop",
    "theorem": "{X : Type u_1} [topological_space X] (x y : X) : Prop",
    "args": "{X : Type u_1} [topological_space X] (x y : X)",
    "doc_string": "The relation \"being joined by a path\". This is an equivalence relation.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_monoid_hom",
    "statement": "structure add_monoid_hom (M : Type u_9) (N : Type u_10) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_9)",
    "theorem": "(M : Type u_9) (N : Type u_10) [add_zero_class M] [add_zero_class N] : Type (max u_10 u_9)",
    "args": "(M : Type u_9) (N : Type u_10) [add_zero_class M] [add_zero_class N]",
    "doc_string": " `M →+ N` is the type of functions `M → N` that preserve the `add_zero_class` structure.  `add_monoid_hom` is also used for group homomorphisms.  When possible, instead of parametrizing results over `(f : M →+ N)`, you should parametrize over `(F : Type*) [add_monoid_hom_class F M N] (f : F)`.  When you extend this structure, make sure to extend `add_monoid_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_10 u_9)"
  },
  {
    "name": "set.add_center",
    "statement": "def set.add_center (M : Type u_1) [has_add M] : set M",
    "theorem": "(M : Type u_1) [has_add M] : set M",
    "args": "(M : Type u_1) [has_add M]",
    "doc_string": "The center of an additive magma.",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "measurable_space.comap",
    "statement": "def measurable_space.comap {α : Type u_1} {β : Type u_2} (f : α → β) (m : measurable_space β) : measurable_space α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (m : measurable_space β) : measurable_space α",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (m : measurable_space β)",
    "doc_string": "The reverse image of a measurable space under a function. `comap f m` contains the sets  `s : set α` such that `s` is the `f`-preimage of a measurable set in `β`.",
    "kind": "def",
    "type": "measurable_space α"
  },
  {
    "name": "filter.is_basis",
    "statement": "structure filter.is_basis {α : Type u_1} {ι : Sort u_4} (p : ι → Prop) (s : ι → set α) : Prop",
    "theorem": "{α : Type u_1} {ι : Sort u_4} (p : ι → Prop) (s : ι → set α) : Prop",
    "args": "{α : Type u_1} {ι : Sort u_4} (p : ι → Prop) (s : ι → set α)",
    "doc_string": "`is_basis p s` means the image of `s` bounded by `p` is a filter basis.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.monoidal_category.lift_obj",
    "statement": "structure category_theory.monoidal_category.lift_obj {C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type u",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C) : Type u",
    "args": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (X : C)",
    "doc_string": "A typeclass carrying a choice of lift of an object from `C` to `free_monoidal_category C`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "parser.numeral.from_one.of_fintype",
    "statement": "def parser.numeral.from_one.of_fintype (α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] : parser α",
    "theorem": "(α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] : parser α",
    "args": "(α : Type) [has_zero α] [has_one α] [has_add α] [fintype α]",
    "doc_string": "Parse a string of digits as a numeral while casting it to target type `α`, which has a `[fintype α]` constraint. The parser ensures that the numeral parsed in is within the cardinality of the type `α`. The parsing starts at \"1\", so `\"1\"` is parsed in as `nat.cast 0`. Providing `\"0\"` to the parser causes a failure.",
    "kind": "def",
    "type": "parser α"
  },
  {
    "name": "category_theory.preadditive.has_coequalizers_of_has_cokernels",
    "statement": "theorem category_theory.preadditive.has_coequalizers_of_has_cokernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C]",
    "doc_string": "If a preadditive category has all cokernels, then it also has all coequalizers.",
    "kind": "theorem",
    "type": "category_theory.limits.has_coequalizers C"
  },
  {
    "name": "language.has_zero",
    "statement": "def language.has_zero {α : Type u_1} : has_zero (language α)",
    "theorem": "{α : Type u_1} : has_zero (language α)",
    "args": "{α : Type u_1}",
    "doc_string": "Zero language has no elements.",
    "kind": "def",
    "type": "has_zero (language α)"
  },
  {
    "name": "seq.nil",
    "statement": "def seq.nil {α : Type u} : seq α",
    "theorem": "{α : Type u} : seq α",
    "args": "{α : Type u}",
    "doc_string": "The empty sequence",
    "kind": "def",
    "type": "seq α"
  },
  {
    "name": "category_theory.cosimplicial_object.augmented",
    "statement": "def category_theory.cosimplicial_object.augmented (C : Type u) [category_theory.category C] : Type (max v u)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max v u)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "Augmented cosimplicial objects.",
    "kind": "def",
    "type": "Type (max v u)"
  },
  {
    "name": "tactic.instance_cache",
    "statement": "structure tactic.instance_cache  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Caches unary type classes on a type `α : Type.{univ}`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "path.homotopic",
    "statement": "def path.homotopic {X : Type u} [topological_space X] {x₀ x₁ : X} (p₀ p₁ : path x₀ x₁) : Prop",
    "theorem": "{X : Type u} [topological_space X] {x₀ x₁ : X} (p₀ p₁ : path x₀ x₁) : Prop",
    "args": "{X : Type u} [topological_space X] {x₀ x₁ : X} (p₀ p₁ : path x₀ x₁)",
    "doc_string": "Two paths `p₀` and `p₁` are `path.homotopic` if there exists a `homotopy` between them.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ωCPO.of",
    "statement": "def ωCPO.of (α : Type u_1) [omega_complete_partial_order α] : ωCPO",
    "theorem": "(α : Type u_1) [omega_complete_partial_order α] : ωCPO",
    "args": "(α : Type u_1) [omega_complete_partial_order α]",
    "doc_string": "Construct a bundled ωCPO from the underlying type and typeclass.",
    "kind": "def",
    "type": "ωCPO"
  },
  {
    "name": "list.nat.antidiagonal_tuple",
    "statement": "def list.nat.antidiagonal_tuple (k : ℕ) : ℕ → list (fin k → ℕ)",
    "theorem": "(k : ℕ) : ℕ → list (fin k → ℕ)",
    "args": "(k : ℕ)",
    "doc_string": " `list.antidiagonal_tuple k n` is a list of all `k`-tuples which sum to `n`.  This list contains no duplicates (`list.nat.nodup_antidiagonal_tuple`), and is sorted lexicographically (`list.nat.antidiagonal_tuple_pairwise_pi_lex`), starting with `![0, ..., n]` and ending with `![n, ..., 0]`.  ```lean #eval antidiagonal_tuple 3 2 -- [![0, 0, 2], ![0, 1, 1], ![0, 2, 0], ![1, 0, 1], ![1, 1, 0], ![2, 0, 0]] ```",
    "kind": "def",
    "type": "ℕ → list (fin k → ℕ)"
  },
  {
    "name": "finset.has_inv",
    "statement": "def finset.has_inv {α : Type u_2} [decidable_eq α] [has_inv α] : has_inv (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [has_inv α] : has_inv (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [has_inv α]",
    "doc_string": "The pointwise inversion of finset `s⁻¹` is defined as `{x⁻¹ | x ∈ s}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_inv (finset α)"
  },
  {
    "name": "num.bit",
    "statement": "def num.bit (b : bool) : num → num",
    "theorem": "(b : bool) : num → num",
    "args": "(b : bool)",
    "doc_string": "`bit b n` appends the bit `b` to the end of `n`, where `bit tt x = x1` and `bit ff x = x0`.",
    "kind": "def",
    "type": "num → num"
  },
  {
    "name": "category_theory.skeleton.monoidal_category",
    "statement": "def category_theory.skeleton.monoidal_category {C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_category (category_theory.skeleton C)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.monoidal_category (category_theory.skeleton C)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "The skeleton of a monoidal category has a monoidal structure itself, induced by the equivalence.",
    "kind": "def",
    "type": "category_theory.monoidal_category (category_theory.skeleton C)"
  },
  {
    "name": "laurent_series",
    "statement": "def laurent_series (R : Type u_1) [has_zero R] : Type u_1",
    "theorem": "(R : Type u_1) [has_zero R] : Type u_1",
    "args": "(R : Type u_1) [has_zero R]",
    "doc_string": "A `laurent_series` is implemented as a `hahn_series` with value group `ℤ`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "finpartition.atomise",
    "statement": "def finpartition.atomise {α : Type u_1} [decidable_eq α] (s : finset α) (F : finset (finset α)) : finpartition s",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : finset α) (F : finset (finset α)) : finpartition s",
    "args": "{α : Type u_1} [decidable_eq α] (s : finset α) (F : finset (finset α))",
    "doc_string": " Cuts `s` along the finsets in `F`: Two elements of `s` will be in the same part if they are in the same finsets of `F`.",
    "kind": "def",
    "type": "finpartition s"
  },
  {
    "name": "surreal.dyadic",
    "statement": "def surreal.dyadic  : set surreal",
    "theorem": " : set surreal",
    "args": "",
    "doc_string": "We define dyadic surreals as the range of the map `dyadic_map`.",
    "kind": "def",
    "type": "set surreal"
  },
  {
    "name": "matrix.invertible_of_left_inverse",
    "statement": "def matrix.invertible_of_left_inverse {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : B.mul A = 1) : invertible A",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : B.mul A = 1) : invertible A",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : B.mul A = 1)",
    "doc_string": "We can construct an instance of invertible A if A has a left inverse.",
    "kind": "def",
    "type": "invertible A"
  },
  {
    "name": "mvpfunctor",
    "statement": "structure mvpfunctor (n : ℕ) : Type (u+1)",
    "theorem": "(n : ℕ) : Type (u+1)",
    "args": "(n : ℕ)",
    "doc_string": "multivariate polynomial functors",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "has_involutive_inv",
    "statement": "structure has_involutive_inv (G : Type u_2) : Type u_2",
    "theorem": "(G : Type u_2) : Type u_2",
    "args": "(G : Type u_2)",
    "doc_string": "Auxiliary typeclass for types with an involutive `has_inv`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "fintype.nonempty_field_iff",
    "statement": "theorem fintype.nonempty_field_iff {α : Type u_1} [fintype α] : nonempty (field α) ↔ is_prime_pow (fintype.card α)",
    "theorem": "{α : Type u_1} [fintype α] : nonempty (field α) ↔ is_prime_pow (fintype.card α)",
    "args": "{α : Type u_1} [fintype α]",
    "doc_string": "A `fintype` can be given a field structure iff its cardinality is a prime power.",
    "kind": "theorem",
    "type": "nonempty (field α) ↔ is_prime_pow (fintype.card α)"
  },
  {
    "name": "dihedral_group.fintype",
    "statement": "def dihedral_group.fintype {n : ℕ} [fact (0 < n)] : fintype (dihedral_group n)",
    "theorem": "{n : ℕ} [fact (0 < n)] : fintype (dihedral_group n)",
    "args": "{n : ℕ} [fact (0 < n)]",
    "doc_string": "If `0 < n`, then `dihedral_group n` is a finite group.",
    "kind": "def",
    "type": "fintype (dihedral_group n)"
  },
  {
    "name": "category_theory.Kleisli",
    "statement": "def category_theory.Kleisli (m : Type u → Type v) : Type (u+1)",
    "theorem": "(m : Type u → Type v) : Type (u+1)",
    "args": "(m : Type u → Type v)",
    "doc_string": " The Kleisli category on the (type-)monad `m`. Note that the monad is not assumed to be lawful yet.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "order_top.bdd_above",
    "statement": "theorem order_top.bdd_above {γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s",
    "theorem": "{γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s",
    "args": "{γ : Type w} [preorder γ] [order_top γ] (s : set γ)",
    "doc_string": "When there is a global maximum, every set is bounded above.",
    "kind": "theorem",
    "type": "bdd_above s"
  },
  {
    "name": "submonoid.complete_lattice",
    "statement": "def submonoid.complete_lattice {M : Type u_1} [mul_one_class M] : complete_lattice (submonoid M)",
    "theorem": "{M : Type u_1} [mul_one_class M] : complete_lattice (submonoid M)",
    "args": "{M : Type u_1} [mul_one_class M]",
    "doc_string": "Submonoids of a monoid form a complete lattice.",
    "kind": "def",
    "type": "complete_lattice (submonoid M)"
  },
  {
    "name": "indexed_partition",
    "statement": "structure indexed_partition {ι : Type u_1} {α : Type u_2} (s : ι → set α) : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} {α : Type u_2} (s : ι → set α) : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} {α : Type u_2} (s : ι → set α)",
    "doc_string": " Constructive information associated with a partition of a type `α` indexed by another type `ι`, `s : ι → set α`.  `indexed_partition.index` sends an element to its index, while `indexed_partition.some` sends an index to an element of the corresponding set.  This type is primarily useful for definitional control of `s` - if this is not needed, then `setoid.ker index` by itself may be sufficient.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "emetric.Hausdorff_edist_comm",
    "statement": "theorem emetric.Hausdorff_edist_comm {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s",
    "args": "{α : Type u} [pseudo_emetric_space α] {s t : set α}",
    "doc_string": "The Haudorff edistances of `s` to `t` and of `t` to `s` coincide",
    "kind": "theorem",
    "type": "emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s"
  },
  {
    "name": "ordinal.cof",
    "statement": "def ordinal.cof (o : ordinal) : cardinal",
    "theorem": "(o : ordinal) : cardinal",
    "args": "(o : ordinal)",
    "doc_string": "Cofinality of an ordinal. This is the smallest cardinal of a  subset `S` of the ordinal which is unbounded, in the sense  `∀ a, ∃ b ∈ S, a ≤ b`. It is defined for all ordinals, but  `cof 0 = 0` and `cof (succ o) = 1`, so it is only really  interesting on limit ordinals (when it is an infinite cardinal).",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "filter.rcomap'",
    "statement": "def filter.rcomap' {α : Type u} {β : Type v} (r : rel α β) (f : filter β) : filter α",
    "theorem": "{α : Type u} {β : Type v} (r : rel α β) (f : filter β) : filter α",
    "args": "{α : Type u} {β : Type v} (r : rel α β) (f : filter β)",
    "doc_string": " One way of taking the inverse map of a filter under a relation. Generalization of `filter.comap` to relations.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "adjoin_root.root",
    "statement": "def adjoin_root.root {R : Type u} [comm_ring R] (f : polynomial R) : adjoin_root f",
    "theorem": "{R : Type u} [comm_ring R] (f : polynomial R) : adjoin_root f",
    "args": "{R : Type u} [comm_ring R] (f : polynomial R)",
    "doc_string": "The adjoined root.",
    "kind": "def",
    "type": "adjoin_root f"
  },
  {
    "name": "category_theory.limits.bicone.to_cocone",
    "statement": "def category_theory.limits.bicone.to_cocone {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F) : category_theory.limits.cocone (category_theory.discrete.functor F)",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F) : category_theory.limits.cocone (category_theory.discrete.functor F)",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F)",
    "doc_string": "Extract the cocone from a bicone.",
    "kind": "def",
    "type": "category_theory.limits.cocone (category_theory.discrete.functor F)"
  },
  {
    "name": "star_ring_aut",
    "statement": "def star_ring_aut {R : Type u} [comm_semiring R] [star_ring R] : ring_aut R",
    "theorem": "{R : Type u} [comm_semiring R] [star_ring R] : ring_aut R",
    "args": "{R : Type u} [comm_semiring R] [star_ring R]",
    "doc_string": "`star` as a ring automorphism, for commutative `R`.",
    "kind": "def",
    "type": "ring_aut R"
  },
  {
    "name": "rel.core",
    "statement": "def rel.core {α : Type u_1} {β : Type u_2} (r : rel α β) (s : set β) : set α",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set β) : set α",
    "args": "{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set β)",
    "doc_string": " Core of a set `s : set β` w.r.t `r : rel α β` is the set of `x : α` that are related *only* to elements of `s`. Other generalization of `function.preimage`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "BoolAlg",
    "statement": "def BoolAlg  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of boolean algebras.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "fixing_subgroup",
    "statement": "def fixing_subgroup (M : Type u_1) {α : Type u_2} [group M] [mul_action M α] (s : set α) : subgroup M",
    "theorem": "(M : Type u_1) {α : Type u_2} [group M] [mul_action M α] (s : set α) : subgroup M",
    "args": "(M : Type u_1) {α : Type u_2} [group M] [mul_action M α] (s : set α)",
    "doc_string": "The subgroup fixing a set under a `mul_action`.",
    "kind": "def",
    "type": "subgroup M"
  },
  {
    "name": "zsqrtd.sq_le",
    "statement": "def zsqrtd.sq_le (a c b d : ℕ) : Prop",
    "theorem": "(a c b d : ℕ) : Prop",
    "args": "(a c b d : ℕ)",
    "doc_string": "Read `sq_le a c b d` as `a √c ≤ b √d`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "alist.foldl",
    "statement": "def alist.foldl {α : Type u} {β : α → Type v} {δ : Type w} (f : δ → Π (a : α), β a → δ) (d : δ) (m : alist β) : δ",
    "theorem": "{α : Type u} {β : α → Type v} {δ : Type w} (f : δ → Π (a : α), β a → δ) (d : δ) (m : alist β) : δ",
    "args": "{α : Type u} {β : α → Type v} {δ : Type w} (f : δ → Π (a : α), β a → δ) (d : δ) (m : alist β)",
    "doc_string": "Fold a function over the key-value pairs in the map.",
    "kind": "def",
    "type": "δ"
  },
  {
    "name": "canonically_ordered_comm_semiring",
    "statement": "structure canonically_ordered_comm_semiring (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b` iff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but not the integers or other ordered groups.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "one_le_mul",
    "statement": "theorem one_le_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b)",
    "doc_string": "**Alias** of left.one_le_mul`.",
    "kind": "theorem",
    "type": "1 ≤ a * b"
  },
  {
    "name": "fintype.of_subsingleton'",
    "statement": "def fintype.of_subsingleton' (α : Type u_1) [subsingleton α] : fintype α",
    "theorem": "(α : Type u_1) [subsingleton α] : fintype α",
    "args": "(α : Type u_1) [subsingleton α]",
    "doc_string": "Any subsingleton type is (noncomputably) a fintype (with zero or one term).",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "fin.init_update_last",
    "statement": "theorem fin.init_update_last {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α (fin.last n))",
    "doc_string": "Updating the last element of a tuple does not change the beginning.",
    "kind": "theorem",
    "type": "fin.init (function.update q (fin.last n) z) = fin.init q"
  },
  {
    "name": "list.split_on",
    "statement": "def list.split_on {α : Type u} [decidable_eq α] (a : α) (as : list α) : list (list α)",
    "theorem": "{α : Type u} [decidable_eq α] (a : α) (as : list α) : list (list α)",
    "args": "{α : Type u} [decidable_eq α] (a : α) (as : list α)",
    "doc_string": "Split a list at every occurrence of an element.     [1,1,2,3,2,4,4].split_on 2 = [[1,1],[3],[4,4]]",
    "kind": "def",
    "type": "list (list α)"
  },
  {
    "name": "measure_theory.simple_func.seq",
    "statement": "def measure_theory.simple_func.seq {α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α (β → γ)) (g : measure_theory.simple_func α β) : measure_theory.simple_func α γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α (β → γ)) (g : measure_theory.simple_func α β) : measure_theory.simple_func α γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α (β → γ)) (g : measure_theory.simple_func α β)",
    "doc_string": " If `f` is a simple function taking values in `β → γ` and `g` is another simple function with the same domain and codomain `β`, then `f.seq g = f a (g a)`.",
    "kind": "def",
    "type": "measure_theory.simple_func α γ"
  },
  {
    "name": "subgroup.ext",
    "statement": "theorem subgroup.ext {G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K",
    "theorem": "{G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K",
    "args": "{G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K)",
    "doc_string": "Two subgroups are equal if they have the same elements.",
    "kind": "theorem",
    "type": "H = K"
  },
  {
    "name": "add_torsor",
    "statement": "structure add_torsor (G : out_param (Type u_1)) (P : Type u_2) [out_param (add_group G)] : Type (max u_1 u_2)",
    "theorem": "(G : out_param (Type u_1)) (P : Type u_2) [out_param (add_group G)] : Type (max u_1 u_2)",
    "args": "(G : out_param (Type u_1)) (P : Type u_2) [out_param (add_group G)]",
    "doc_string": " An `add_torsor G P` gives a structure to the nonempty type `P`, acted on by an `add_group G` with a transitive and free action given by the `+ᵥ` operation and a corresponding subtraction given by the `-ᵥ` operation. In the case of a vector space, it is an affine space.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "pgame.domineering.one",
    "statement": "def pgame.domineering.one  : pgame",
    "theorem": " : pgame",
    "args": "",
    "doc_string": "The Domineering board with two squares arranged vertically, in which Left has the only move.",
    "kind": "def",
    "type": "pgame"
  },
  {
    "name": "has_lt.lt.ne",
    "statement": "theorem has_lt.lt.ne {α : Type u} [preorder α] {a b : α} (h : a < b) : a ≠ b",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a < b) : a ≠ b",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of ne_of_lt`.",
    "kind": "theorem",
    "type": "a ≠ b"
  },
  {
    "name": "right.mul_lt_one_of_le_of_lt",
    "statement": "theorem right.mul_lt_one_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one_of_le_of_lt`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "filter.is_cobounded",
    "statement": "def filter.is_cobounded {α : Type u_1} (r : α → α → Prop) (f : filter α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (f : filter α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (f : filter α)",
    "doc_string": " `is_cobounded (≺) f` states that the filter `f` does not tend to infinity w.r.t. `≺`. This is also called frequently bounded. Will be usually instantiated with `≤` or `≥`.  There is a subtlety in this definition: we want `f.is_cobounded` to hold for any `f` in the case of complete lattices. This will be relevant to deduce theorems on complete lattices from their versions on conditionally complete lattices with additional assumptions. We have to be careful in the edge case of the trivial filter containing the empty set: the other natural definition   `¬ ∀ a, ∀ᶠ n in f, a ≤ n` would not work as well in this case.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.merge",
    "statement": "def ordnode.merge {α : Type u} (l : ordnode α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} (l : ordnode α) : ordnode α → ordnode α",
    "args": "{α : Type u} (l : ordnode α)",
    "doc_string": "O(log(m+n)). Concatenate two trees that are ordered with respect to each other.      merge {1, 2} {3, 4} = {1, 2, 3, 4}     merge {3, 4} {1, 2} = precondition violation",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "add_hom",
    "statement": "structure add_hom (M : Type u_9) (N : Type u_10) [has_add M] [has_add N] : Type (max u_10 u_9)",
    "theorem": "(M : Type u_9) (N : Type u_10) [has_add M] [has_add N] : Type (max u_10 u_9)",
    "args": "(M : Type u_9) (N : Type u_10) [has_add M] [has_add N]",
    "doc_string": " `add_hom M N` is the type of functions `M → N` that preserve addition.  When possible, instead of parametrizing results over `(f : add_hom M N)`, you should parametrize over `(F : Type*) [add_hom_class F M N] (f : F)`.  When you extend this structure, make sure to extend `add_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_10 u_9)"
  },
  {
    "name": "category_theory.skeletal",
    "statement": "def category_theory.skeletal (C : Type u₁) [category_theory.category C] : Prop",
    "theorem": "(C : Type u₁) [category_theory.category C] : Prop",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": "A category is skeletal if isomorphic objects are equal.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_con",
    "statement": "structure add_con (M : Type u_1) [has_add M] : Type u_1",
    "theorem": "(M : Type u_1) [has_add M] : Type u_1",
    "args": "(M : Type u_1) [has_add M]",
    "doc_string": "A congruence relation on a type with an addition is an equivalence relation which    preserves addition.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "ωCPO",
    "statement": "def ωCPO  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of types with a omega complete partial order.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "algebraic_geometry.Scheme.glue_data",
    "statement": "structure algebraic_geometry.Scheme.glue_data  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "A family of gluing data consists of 1. An index type `J` 2. An scheme `U i` for each `i : J`. 3. An scheme `V i j` for each `i j : J`.   (Note that this is `J × J → Scheme` rather than `J → J → Scheme` to connect to the   limits library easier.) 4. An open immersion `f i j : V i j ⟶ U i` for each `i j : ι`. 5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`. such that 6. `f i i` is an isomorphism. 7. `t i i` is the identity. 8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some     `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`. 9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.  We can then glue the schemes `U i` together by identifying `V i j` with `V j i`, such that the `U i`'s are open subschemes of the glued space.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "free_algebra.basis_free_monoid",
    "statement": "def free_algebra.basis_free_monoid (R : Type u) (X : Type v) [comm_ring R] : basis (free_monoid X) R (free_algebra R X)",
    "theorem": "(R : Type u) (X : Type v) [comm_ring R] : basis (free_monoid X) R (free_algebra R X)",
    "args": "(R : Type u) (X : Type v) [comm_ring R]",
    "doc_string": " The `free_monoid X` basis on the `free_algebra R X`, mapping `[x₁, x₂, ..., xₙ]` to the \"monomial\" `1 • x₁ * x₂ * ⋯ * xₙ`",
    "kind": "def",
    "type": "basis (free_monoid X) R (free_algebra R X)"
  },
  {
    "name": "normal_space",
    "statement": "structure normal_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A T₄ space, also known as a normal space (although this condition sometimes  omits T₂), is one in which for every pair of disjoint closed sets `C` and `D`,  there exist disjoint open sets containing `C` and `D` respectively.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "rel",
    "statement": "def rel (α : Type u_1) (β : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (β : Type u_2) : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (β : Type u_2)",
    "doc_string": "A relation on `α` and `β`, aka a set-valued function, aka a partial multifunction -",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "uniform_space.completion.extension",
    "statement": "def uniform_space.completion.extension {α : Type u_1} [uniform_space α] {β : Type u_2} [uniform_space β] (f : α → β) : uniform_space.completion α → β",
    "theorem": "{α : Type u_1} [uniform_space α] {β : Type u_2} [uniform_space β] (f : α → β) : uniform_space.completion α → β",
    "args": "{α : Type u_1} [uniform_space α] {β : Type u_2} [uniform_space β] (f : α → β)",
    "doc_string": " \"Extension\" to the completion. It is defined for any map `f` but returns an arbitrary constant value if `f` is not uniformly continuous",
    "kind": "def",
    "type": "uniform_space.completion α → β"
  },
  {
    "name": "tactic.unify_equations.unification_step",
    "statement": "def tactic.unify_equations.unification_step  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A unification step is a tactic that attempts to simplify a given equation and returns a `unification_step_result`. The inputs are:  - `equ`, the equation being processed. Must be a local constant. - `lhs_type` and `rhs_type`, the types of equ's LHS and RHS. For homogeneous   equations, these are defeq. - `lhs` and `rhs`, `equ`'s LHS and RHS. - `lhs_whnf` and `rhs_whnf`, `equ`'s LHS and RHS in WHNF. - `u`, `equ`'s level.  So `equ : @eq.{u} lhs_type lhs rhs` or `equ : @heq.{u} lhs_type lhs rhs_type rhs`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "tactic.ring.cache",
    "statement": "structure tactic.ring.cache  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "This cache contains data required by the `ring` tactic during execution.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "zsqrtd",
    "statement": "structure zsqrtd (d : ℤ) : Type",
    "theorem": "(d : ℤ) : Type",
    "args": "(d : ℤ)",
    "doc_string": "The ring of integers adjoined with a square root of `d`.  These have the form `a + b √d` where `a b : ℤ`. The components  are called `re` and `im` by analogy to the negative `d` case.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "intermediate_field.map_id",
    "statement": "theorem intermediate_field.map_id {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L)",
    "doc_string": "Mapping intermediate fields along the identity does not change them",
    "kind": "theorem",
    "type": "E.map (alg_hom.id K L) = E"
  },
  {
    "name": "cardinal.bdd_above_range",
    "statement": "theorem cardinal.bdd_above_range {ι : Type u} (f : ι → cardinal) : bdd_above (set.range f)",
    "theorem": "{ι : Type u} (f : ι → cardinal) : bdd_above (set.range f)",
    "args": "{ι : Type u} (f : ι → cardinal)",
    "doc_string": "The range of an indexed cardinal function, whose outputs live in a higher universe than the    inputs, is always bounded above.",
    "kind": "theorem",
    "type": "bdd_above (set.range f)"
  },
  {
    "name": "measure_theory.stopped_value",
    "statement": "def measure_theory.stopped_value {α : Type u_1} {β : Type u_2} {ι : Type u_3} (u : ι → α → β) (τ : α → ι) : α → β",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} (u : ι → α → β) (τ : α → ι) : α → β",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} (u : ι → α → β) (τ : α → ι)",
    "doc_string": " Given a map `u : ι → α → E`, its stopped value with respect to the stopping time `τ` is the map `x ↦ u (τ x) x`.",
    "kind": "def",
    "type": "α → β"
  },
  {
    "name": "matrix.hadamard",
    "statement": "def matrix.hadamard {α : Type u_1} {m : Type u_4} {n : Type u_5} [has_mul α] (A B : matrix m n α) : matrix m n α",
    "theorem": "{α : Type u_1} {m : Type u_4} {n : Type u_5} [has_mul α] (A B : matrix m n α) : matrix m n α",
    "args": "{α : Type u_1} {m : Type u_4} {n : Type u_5} [has_mul α] (A B : matrix m n α)",
    "doc_string": "`matrix.hadamard` defines the Hadamard product,    which is the pointwise product of two matrices of the same size.",
    "kind": "def",
    "type": "matrix m n α"
  },
  {
    "name": "function.periodic_pts",
    "statement": "def function.periodic_pts {α : Type u_1} (f : α → α) : set α",
    "theorem": "{α : Type u_1} (f : α → α) : set α",
    "args": "{α : Type u_1} (f : α → α)",
    "doc_string": "The set of periodic points of a map `f : α → α`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "ordnode.find_min",
    "statement": "def ordnode.find_min {α : Type u} : ordnode α → option α",
    "theorem": "{α : Type u} : ordnode α → option α",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Return the minimum element of the tree, if it exists.      find_min {1, 2, 3} = some 1     find_min ∅ = none",
    "kind": "def",
    "type": "ordnode α → option α"
  },
  {
    "name": "EllipticCurve",
    "statement": "structure EllipticCurve (R : Type u_1) [comm_ring R] : Type u_1",
    "theorem": "(R : Type u_1) [comm_ring R] : Type u_1",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": " The category of elliptic curves over `R` (note that this definition is only mathematically correct for certain rings, for example if `R` is a field or a PID).",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "ordnode.foldr",
    "statement": "def ordnode.foldr {α : Type u} {β : Sort u_1} (f : α → β → β) : ordnode α → β → β",
    "theorem": "{α : Type u} {β : Sort u_1} (f : α → β → β) : ordnode α → β → β",
    "args": "{α : Type u} {β : Sort u_1} (f : α → β → β)",
    "doc_string": "O(n). Fold a function from right to left (in decreasing order) across the tree.      foldl f {1, 2, 4} z = f 1 (f 2 (f 4 z))",
    "kind": "def",
    "type": "ordnode α → β → β"
  },
  {
    "name": "matrix.sub_down",
    "statement": "def matrix.sub_down {α : Type v} {d u n : ℕ} (A : matrix (fin (u + d)) (fin n) α) : matrix (fin d) (fin n) α",
    "theorem": "{α : Type v} {d u n : ℕ} (A : matrix (fin (u + d)) (fin n) α) : matrix (fin d) (fin n) α",
    "args": "{α : Type v} {d u n : ℕ} (A : matrix (fin (u + d)) (fin n) α)",
    "doc_string": "The bottom `d × n` part of a `(u+d) × n` matrix.",
    "kind": "def",
    "type": "matrix (fin d) (fin n) α"
  },
  {
    "name": "add_semiconj_by.eq",
    "statement": "theorem add_semiconj_by.eq {S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a",
    "theorem": "{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a",
    "args": "{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y)",
    "doc_string": "Equality behind `add_semiconj_by a x y`; useful for rewriting.",
    "kind": "theorem",
    "type": "a + x = y + a"
  },
  {
    "name": "valuation.integers",
    "statement": "structure valuation.integers {R : Type u} {Γ₀ : Type v} [comm_ring R] [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) (O : Type w) [comm_ring O] [algebra O R] : Prop",
    "theorem": "{R : Type u} {Γ₀ : Type v} [comm_ring R] [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) (O : Type w) [comm_ring O] [algebra O R] : Prop",
    "args": "{R : Type u} {Γ₀ : Type v} [comm_ring R] [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) (O : Type w) [comm_ring O] [algebra O R]",
    "doc_string": " Given a valuation v : R → Γ₀ and a ring homomorphism O →+* R, we say that O is the integers of v if f is injective, and its range is exactly `v.integer`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "first_order.language.joint_embedding",
    "statement": "def first_order.language.joint_embedding {L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop",
    "theorem": "{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop",
    "args": "{L : first_order.language} (K : set (category_theory.bundled L.Structure))",
    "doc_string": "A class `K` has the joint embedding property when for every `M`, `N` in `K`, there is another  structure in `K` into which both `M` and `N` embed.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ultrafilter_converges_iff",
    "statement": "theorem ultrafilter_converges_iff {α : Type u} {u : ultrafilter (ultrafilter α)} {x : ultrafilter α} : ↑u ≤ nhds x ↔ x = mjoin u",
    "theorem": "{α : Type u} {u : ultrafilter (ultrafilter α)} {x : ultrafilter α} : ↑u ≤ nhds x ↔ x = mjoin u",
    "args": "{α : Type u} {u : ultrafilter (ultrafilter α)} {x : ultrafilter α}",
    "doc_string": "Every ultrafilter `u` on `ultrafilter α` converges to a unique  point of `ultrafilter α`, namely `mjoin u`.",
    "kind": "theorem",
    "type": "↑u ≤ nhds x ↔ x = mjoin u"
  },
  {
    "name": "nat.partrec.code.curry",
    "statement": "def nat.partrec.code.curry (c : nat.partrec.code) (n : ℕ) : nat.partrec.code",
    "theorem": "(c : nat.partrec.code) (n : ℕ) : nat.partrec.code",
    "args": "(c : nat.partrec.code) (n : ℕ)",
    "doc_string": "Given a code `c` taking a pair as input, returns a code using `n` as the first argument to `c`.",
    "kind": "def",
    "type": "nat.partrec.code"
  },
  {
    "name": "is_open_map_quotient_mk_mul",
    "statement": "theorem is_open_map_quotient_mk_mul {Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [has_continuous_const_smul Γ T] : is_open_map quotient.mk",
    "theorem": "{Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [has_continuous_const_smul Γ T] : is_open_map quotient.mk",
    "args": "{Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [has_continuous_const_smul Γ T]",
    "doc_string": "The quotient map by a group action is open.",
    "kind": "theorem",
    "type": "is_open_map quotient.mk"
  },
  {
    "name": "ring_filter_basis.topology",
    "statement": "def ring_filter_basis.topology {R : Type u} [ring R] (B : ring_filter_basis R) : topological_space R",
    "theorem": "{R : Type u} [ring R] (B : ring_filter_basis R) : topological_space R",
    "args": "{R : Type u} [ring R] (B : ring_filter_basis R)",
    "doc_string": " The topology associated to a ring filter basis. It has the given basis as a basis of neighborhoods of zero.",
    "kind": "def",
    "type": "topological_space R"
  },
  {
    "name": "encodable.fin_arrow",
    "statement": "def encodable.fin_arrow {α : Type u_1} [encodable α] {n : ℕ} : encodable (fin n → α)",
    "theorem": "{α : Type u_1} [encodable α] {n : ℕ} : encodable (fin n → α)",
    "args": "{α : Type u_1} [encodable α] {n : ℕ}",
    "doc_string": "If `α` is encodable, then so is `fin n → α`.",
    "kind": "def",
    "type": "encodable (fin n → α)"
  },
  {
    "name": "linear_ordered_comm_group_with_zero.nhds_fun",
    "statement": "def linear_ordered_comm_group_with_zero.nhds_fun (Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] (x : Γ₀) : filter Γ₀",
    "theorem": "(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] (x : Γ₀) : filter Γ₀",
    "args": "(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] (x : Γ₀)",
    "doc_string": " The neighbourhoods around γ ∈ Γ₀, used in the definition of the topology on Γ₀. These neighbourhoods are defined as follows: A set s is a neighbourhood of 0 if there is an invertible γ₀ ∈ Γ₀ such that {γ | γ < γ₀} ⊆ s. If γ ≠ 0, then every set that contains γ is a neighbourhood of γ.",
    "kind": "def",
    "type": "filter Γ₀"
  },
  {
    "name": "pythagorean_triple.mul_iff",
    "statement": "theorem pythagorean_triple.mul_iff {x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z",
    "theorem": "{x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z",
    "args": "{x y z : ℤ} (k : ℤ) (hk : k ≠ 0)",
    "doc_string": " `(k*x, k*y, k*z)` is a Pythagorean triple if and only if `(x, y, z)` is also a triple.",
    "kind": "theorem",
    "type": "pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z"
  },
  {
    "name": "CommRing.of",
    "statement": "def CommRing.of (R : Type u) [comm_ring R] : CommRing",
    "theorem": "(R : Type u) [comm_ring R] : CommRing",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "Construct a bundled CommRing from the underlying type and typeclass.",
    "kind": "def",
    "type": "CommRing"
  },
  {
    "name": "discrete_quotient",
    "statement": "structure discrete_quotient (X : Type u_1) [topological_space X] : Type u_1",
    "theorem": "(X : Type u_1) [topological_space X] : Type u_1",
    "args": "(X : Type u_1) [topological_space X]",
    "doc_string": "The type of discrete quotients of a topological space.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "pi.has_continuous_add'",
    "statement": "def pi.has_continuous_add' {ι : Type u_1} {M : Type u_4} [topological_space M] [has_add M] [has_continuous_add M] : has_continuous_add (ι → M)",
    "theorem": "{ι : Type u_1} {M : Type u_4} [topological_space M] [has_add M] [has_continuous_add M] : has_continuous_add (ι → M)",
    "args": "{ι : Type u_1} {M : Type u_4} [topological_space M] [has_add M] [has_continuous_add M]",
    "doc_string": "A version of `pi.has_continuous_add` for non-dependent functions. It is needed because sometimes Lean fails to use `pi.has_continuous_add` for non-dependent functions.",
    "kind": "def",
    "type": "has_continuous_add (ι → M)"
  },
  {
    "name": "local_equiv.simps.symm_apply",
    "statement": "def local_equiv.simps.symm_apply {α : Type u_1} {β : Type u_2} (e : local_equiv α β) : β → α",
    "theorem": "{α : Type u_1} {β : Type u_2} (e : local_equiv α β) : β → α",
    "args": "{α : Type u_1} {β : Type u_2} (e : local_equiv α β)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "β → α"
  },
  {
    "name": "is_top",
    "statement": "def is_top {α : Type u_1} [has_le α] (a : α) : Prop",
    "theorem": "{α : Type u_1} [has_le α] (a : α) : Prop",
    "args": "{α : Type u_1} [has_le α] (a : α)",
    "doc_string": " `a : α` is a top element of `α` if it is greater than or equal to any other element of `α`. This predicate is roughly an unbundled version of `order_bot`, except that a preorder may have several top elements. When `α` is linear, this is useful to make a case disjunction on `no_max_order α` within a proof.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "fin.coe_val_of_lt",
    "statement": "theorem fin.coe_val_of_lt {n a : ℕ} (h : a < n + 1) : ↑a.val = a",
    "theorem": "{n a : ℕ} (h : a < n + 1) : ↑a.val = a",
    "args": "{n a : ℕ} (h : a < n + 1)",
    "doc_string": " Converting an in-range number to `fin (n + 1)` produces a result whose value is the original number.",
    "kind": "theorem",
    "type": "↑a.val = a"
  },
  {
    "name": "order_monoid_hom_class",
    "statement": "structure order_monoid_hom_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [mul_one_class α] [mul_one_class β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [mul_one_class α] [mul_one_class β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [mul_one_class α] [mul_one_class β]",
    "doc_string": " `order_monoid_hom_class F α β` states that `F` is a type of ordered monoid homomorphisms.  You should also extend this typeclass when you extend `order_monoid_hom`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "computability.fin_encoding",
    "statement": "structure computability.fin_encoding (α : Type u) : Type (max 1 u)",
    "theorem": "(α : Type u) : Type (max 1 u)",
    "args": "(α : Type u)",
    "doc_string": "An encoding plus a guarantee of finiteness of the alphabet.",
    "kind": "structure",
    "type": "Type (max 1 u)"
  },
  {
    "name": "emetric.inf_edist_le_Hausdorff_edist_of_mem",
    "statement": "theorem emetric.inf_edist_le_Hausdorff_edist_of_mem {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t",
    "args": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s)",
    "doc_string": "The distance to a set is controlled by the Hausdorff distance",
    "kind": "theorem",
    "type": "emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t"
  },
  {
    "name": "lower_semicontinuous_within_at",
    "statement": "def lower_semicontinuous_within_at {α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) (x : α) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) (x : α) : Prop",
    "args": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) (x : α)",
    "doc_string": " A real function `f` is lower semicontinuous at `x` within a set `s` if, for any `ε > 0`, for all `x'` close enough to `x` in  `s`, then `f x'` is at least `f x - ε`. We formulate this in a general preordered space, using an arbitrary `y < f x` instead of `f x - ε`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "besicovitch.tau_package.last_step",
    "statement": "def besicovitch.tau_package.last_step {α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) : ordinal",
    "theorem": "{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) : ordinal",
    "args": "{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α)",
    "doc_string": " `p.last_step` is the first ordinal where the construction stops making sense, i.e., `f` returns garbage since there is no point left to be chosen. We will only use ordinals before this step.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "vector_ex",
    "statement": "def vector_ex {α : Type u_1} (k : ℕ) : (vector3 α k → Prop) → Prop",
    "theorem": "{α : Type u_1} (k : ℕ) : (vector3 α k → Prop) → Prop",
    "args": "{α : Type u_1} (k : ℕ)",
    "doc_string": "\"Curried\" exists, i.e. `∃ x₁ ... xₙ, f [x₁, ..., xₙ]`.",
    "kind": "def",
    "type": "(vector3 α k → Prop) → Prop"
  },
  {
    "name": "cardinal.ord_aleph_eq_enum_card",
    "statement": "theorem cardinal.ord_aleph_eq_enum_card  : cardinal.ord ∘ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}",
    "theorem": " : cardinal.ord ∘ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}",
    "args": "",
    "doc_string": "`ord ∘ aleph` enumerates the infinite ordinals that are cardinals.",
    "kind": "theorem",
    "type": "cardinal.ord ∘ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}"
  },
  {
    "name": "fintype_of_option",
    "statement": "def fintype_of_option {α : Type u_1} [fintype (option α)] : fintype α",
    "theorem": "{α : Type u_1} [fintype (option α)] : fintype α",
    "args": "{α : Type u_1} [fintype (option α)]",
    "doc_string": "If `option α` is a `fintype` then so is `α`",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "pos_num.cmp",
    "statement": "def pos_num.cmp  : pos_num → pos_num → ordering",
    "theorem": " : pos_num → pos_num → ordering",
    "args": "",
    "doc_string": "Ordering of `pos_num`s.",
    "kind": "def",
    "type": "pos_num → pos_num → ordering"
  },
  {
    "name": "asymptotics.is_O",
    "statement": "def asymptotics.is_O {α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter α) (f : α → E) (g : α → F) : Prop",
    "theorem": "{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter α) (f : α → E) (g : α → F) : Prop",
    "args": "{α : Type u_1} {E : Type u_3} {F : Type u_4} [has_norm E] [has_norm F] (l : filter α) (f : α → E) (g : α → F)",
    "doc_string": " The Landau notation `f =O[l] g` where `f` and `g` are two functions on a type `α` and `l` is a filter on `α`, means that eventually for `l`, `∥f∥` is bounded by a constant multiple of `∥g∥`. In other words, `∥f∥ / ∥g∥` is eventually bounded, modulo division by zero issues that are avoided by this definition.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "continuous_add_submonoid",
    "statement": "def continuous_add_submonoid (α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [add_monoid β] [has_continuous_add β] : add_submonoid (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [add_monoid β] [has_continuous_add β] : add_submonoid (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [add_monoid β] [has_continuous_add β]",
    "doc_string": "The `add_submonoid` of continuous maps `α → β`.",
    "kind": "def",
    "type": "add_submonoid (α → β)"
  },
  {
    "name": "pi_nat.metric_space",
    "statement": "def pi_nat.metric_space {E : ℕ → Type u_1} [Π (n : ℕ), topological_space (E n)] [∀ (n : ℕ), discrete_topology (E n)] : metric_space (Π (n : ℕ), E n)",
    "theorem": "{E : ℕ → Type u_1} [Π (n : ℕ), topological_space (E n)] [∀ (n : ℕ), discrete_topology (E n)] : metric_space (Π (n : ℕ), E n)",
    "args": "{E : ℕ → Type u_1} [Π (n : ℕ), topological_space (E n)] [∀ (n : ℕ), discrete_topology (E n)]",
    "doc_string": " Metric space structure on `Π (n : ℕ), E n` when the spaces `E n` have the discrete topology, where the distance is given by `dist x y = (1/2)^n`, where `n` is the smallest index where `x` and `y` differ. Not registered as a global instance by default. Warning: this definition makes sure that the topology is defeq to the original product topology, but it does not take care of a possible uniformity. If the `E n` have a uniform structure, then there will be two non-defeq uniform structures on `Π n, E n`, the product one and the one coming from the metric structure. In this case, use `metric_space_of_discrete_uniformity` instead.",
    "kind": "def",
    "type": "metric_space (Π (n : ℕ), E n)"
  },
  {
    "name": "category_theory.limits.has_finite_biproducts.of_has_finite_coproducts",
    "statement": "theorem category_theory.limits.has_finite_biproducts.of_has_finite_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C]",
    "doc_string": "A preadditive category with finite coproducts has finite biproducts.",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_biproducts C"
  },
  {
    "name": "polynomial.comp",
    "statement": "def polynomial.comp {R : Type u} [semiring R] (p q : polynomial R) : polynomial R",
    "theorem": "{R : Type u} [semiring R] (p q : polynomial R) : polynomial R",
    "args": "{R : Type u} [semiring R] (p q : polynomial R)",
    "doc_string": "The composition of polynomials as a polynomial.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "sign_type.mul",
    "statement": "def sign_type.mul  : sign_type → sign_type → sign_type",
    "theorem": " : sign_type → sign_type → sign_type",
    "args": "",
    "doc_string": "The multiplication on `sign_type`.",
    "kind": "def",
    "type": "sign_type → sign_type → sign_type"
  },
  {
    "name": "nnreal.tendsto_tsum_compl_at_top_zero",
    "statement": "theorem nnreal.tendsto_tsum_compl_at_top_zero {α : Type u_1} (f : α → nnreal) : filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)",
    "theorem": "{α : Type u_1} (f : α → nnreal) : filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)",
    "args": "{α : Type u_1} (f : α → nnreal)",
    "doc_string": " The sum over the complement of a finset tends to `0` when the finset grows to cover the whole space. This does not need a summability assumption, as otherwise all sums are zero.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)"
  },
  {
    "name": "linear_ordered_comm_ring",
    "statement": "structure linear_ordered_comm_ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A `linear_ordered_comm_ring α` is a commutative ring `α` with a linear order such that addition is monotone and multiplication by a positive number is strictly monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "has_measurable_sub",
    "statement": "structure has_measurable_sub (G : Type u_1) [measurable_space G] [has_sub G] : Prop",
    "theorem": "(G : Type u_1) [measurable_space G] [has_sub G] : Prop",
    "args": "(G : Type u_1) [measurable_space G] [has_sub G]",
    "doc_string": " We say that a type `has_measurable_sub` if `(λ x, c - x)` and `(λ x, x - c)` are measurable functions. For a typeclass assuming measurability of `uncurry (-)` see `has_measurable_sub₂`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "multiset.decidable_exists_multiset",
    "statement": "def multiset.decidable_exists_multiset {α : Type u_1} {m : multiset α} {p : α → Prop} [decidable_pred p] : decidable (∃ (x : α) (H : x ∈ m), p x)",
    "theorem": "{α : Type u_1} {m : multiset α} {p : α → Prop} [decidable_pred p] : decidable (∃ (x : α) (H : x ∈ m), p x)",
    "args": "{α : Type u_1} {m : multiset α} {p : α → Prop} [decidable_pred p]",
    "doc_string": " If `p` is a decidable predicate, so is the existence of an element in a multiset satisfying `p`.",
    "kind": "def",
    "type": "decidable (∃ (x : α) (H : x ∈ m), p x)"
  },
  {
    "name": "pmf.bernoulli",
    "statement": "def pmf.bernoulli (p : nnreal) (h : p ≤ 1) : pmf bool",
    "theorem": "(p : nnreal) (h : p ≤ 1) : pmf bool",
    "args": "(p : nnreal) (h : p ≤ 1)",
    "doc_string": "A `pmf` which assigns probability `p` to `tt` and `1 - p` to `ff`.",
    "kind": "def",
    "type": "pmf bool"
  },
  {
    "name": "quadratic_form",
    "statement": "structure quadratic_form (R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] : Type (max u v)",
    "theorem": "(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] : Type (max u v)",
    "args": "(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M]",
    "doc_string": " A quadratic form over a module.  Note we only need the left lemmas about `quadratic_form.polar` as the right lemmas follow from `quadratic_form.polar_comm`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "right_cancel_monoid.to_has_faithful_smul",
    "statement": "def right_cancel_monoid.to_has_faithful_smul {α : Type u} [right_cancel_monoid α] : has_faithful_smul α α",
    "theorem": "{α : Type u} [right_cancel_monoid α] : has_faithful_smul α α",
    "args": "{α : Type u} [right_cancel_monoid α]",
    "doc_string": "`monoid.to_mul_action` is faithful on cancellative monoids.",
    "kind": "def",
    "type": "has_faithful_smul α α"
  },
  {
    "name": "zmod.int_cast_zmod_cast",
    "statement": "theorem zmod.int_cast_zmod_cast {n : ℕ} (a : zmod n) : ↑↑a = a",
    "theorem": "{n : ℕ} (a : zmod n) : ↑↑a = a",
    "args": "{n : ℕ} (a : zmod n)",
    "doc_string": " So-named because the outer coercion is `int.cast` into `zmod`. For `int.cast` into an arbitrary ring, see `zmod.int_cast_cast`.",
    "kind": "theorem",
    "type": "↑↑a = a"
  },
  {
    "name": "subsemiring.has_top",
    "statement": "def subsemiring.has_top {R : Type u} [non_assoc_semiring R] : has_top (subsemiring R)",
    "theorem": "{R : Type u} [non_assoc_semiring R] : has_top (subsemiring R)",
    "args": "{R : Type u} [non_assoc_semiring R]",
    "doc_string": "The subsemiring `R` of the semiring `R`.",
    "kind": "def",
    "type": "has_top (subsemiring R)"
  },
  {
    "name": "mul_sub_mul_div_mul_neg",
    "statement": "theorem mul_sub_mul_div_mul_neg {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c < b / d → (a * d - b * c) / (c * d) < 0",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c < b / d → (a * d - b * c) / (c * d) < 0",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0)",
    "doc_string": "**Alias** of the reverse direction of mul_sub_mul_div_mul_neg_iff`.",
    "kind": "theorem",
    "type": "a / c < b / d → (a * d - b * c) / (c * d) < 0"
  },
  {
    "name": "group.rank",
    "statement": "def group.rank (G : Type u_3) [group G] [h : group.fg G] [decidable_pred (λ (n : ℕ), ∃ (S : finset G), S.card = n ∧ subgroup.closure ↑S = ⊤)] : ℕ",
    "theorem": "(G : Type u_3) [group G] [h : group.fg G] [decidable_pred (λ (n : ℕ), ∃ (S : finset G), S.card = n ∧ subgroup.closure ↑S = ⊤)] : ℕ",
    "args": "(G : Type u_3) [group G] [h : group.fg G] [decidable_pred (λ (n : ℕ), ∃ (S : finset G), S.card = n ∧ subgroup.closure ↑S = ⊤)]",
    "doc_string": "The minimum number of generators of a group.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "ordinal.has_sub",
    "statement": "def ordinal.has_sub  : has_sub ordinal",
    "theorem": " : has_sub ordinal",
    "args": "",
    "doc_string": "`a - b` is the unique ordinal satisfying `b + (a - b) = a` when `b ≤ a`.",
    "kind": "def",
    "type": "has_sub ordinal"
  },
  {
    "name": "monoid.has_measurable_pow",
    "statement": "def monoid.has_measurable_pow (M : Type u_1) [monoid M] [measurable_space M] [has_measurable_mul₂ M] : has_measurable_pow M ℕ",
    "theorem": "(M : Type u_1) [monoid M] [measurable_space M] [has_measurable_mul₂ M] : has_measurable_pow M ℕ",
    "args": "(M : Type u_1) [monoid M] [measurable_space M] [has_measurable_mul₂ M]",
    "doc_string": "`monoid.has_pow` is measurable.",
    "kind": "def",
    "type": "has_measurable_pow M ℕ"
  },
  {
    "name": "order_hom_class",
    "statement": "def order_hom_class (F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [has_le α] [has_le β] : Type (max u_1 u_2 u_3)",
    "theorem": "(F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [has_le α] [has_le β] : Type (max u_1 u_2 u_3)",
    "args": "(F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [has_le α] [has_le β]",
    "doc_string": "`order_hom_class F α b` asserts that `F` is a type of `≤`-preserving morphisms.",
    "kind": "def",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "module.rank",
    "statement": "def module.rank (K : Type u) (V : Type v) [semiring K] [add_comm_monoid V] [module K V] : cardinal",
    "theorem": "(K : Type u) (V : Type v) [semiring K] [add_comm_monoid V] [module K V] : cardinal",
    "args": "(K : Type u) (V : Type v) [semiring K] [add_comm_monoid V] [module K V]",
    "doc_string": " The rank of a module, defined as a term of type `cardinal`.  We define this as the supremum of the cardinalities of linearly independent subsets.  For a free module over any ring satisfying the strong rank condition (e.g. left-noetherian rings, commutative rings, and in particular division rings and fields), this is the same as the dimension of the space (i.e. the cardinality of any basis).  In particular this agrees with the usual notion of the dimension of a vector space.  The definition is marked as protected to avoid conflicts with `_root_.rank`, the rank of a linear map.",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "is_regular.ne_zero",
    "statement": "theorem is_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a ≠ 0",
    "theorem": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a ≠ 0",
    "args": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a)",
    "doc_string": "A regular element of a `nontrivial` `mul_zero_class` is non-zero.",
    "kind": "theorem",
    "type": "a ≠ 0"
  },
  {
    "name": "bundle.trivial",
    "statement": "def bundle.trivial (B : Type u_1) (F : Type u_2) : B → Type u_2",
    "theorem": "(B : Type u_1) (F : Type u_2) : B → Type u_2",
    "args": "(B : Type u_1) (F : Type u_2)",
    "doc_string": "`bundle.trivial B F` is the trivial bundle over `B` of fiber `F`.",
    "kind": "def",
    "type": "B → Type u_2"
  },
  {
    "name": "initial_seg.refl",
    "statement": "def initial_seg.refl {α : Type u_1} (r : α → α → Prop) : initial_seg r r",
    "theorem": "{α : Type u_1} (r : α → α → Prop) : initial_seg r r",
    "args": "{α : Type u_1} (r : α → α → Prop)",
    "doc_string": "The identity function shows that `≼i` is reflexive",
    "kind": "def",
    "type": "initial_seg r r"
  },
  {
    "name": "Pointed",
    "statement": "structure Pointed  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of pointed types.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "num",
    "statement": "inductive num  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of nonnegative binary numbers, using `pos_num`.      13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "uniq_inv_of_is_field",
    "statement": "theorem uniq_inv_of_is_field (R : Type u) [ring R] (hf : is_field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1)",
    "theorem": "(R : Type u) [ring R] (hf : is_field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1)",
    "args": "(R : Type u) [ring R] (hf : is_field R) (x : R)",
    "doc_string": " For each field, and for each nonzero element of said field, there is a unique inverse. Since `is_field` doesn't remember the data of an `inv` function and as such, a lemma that there is a unique inverse could be useful.",
    "kind": "theorem",
    "type": "x ≠ 0 → (∃! (y : R), x * y = 1)"
  },
  {
    "name": "ordnode.delta",
    "statement": "def ordnode.delta  : ℕ",
    "theorem": " : ℕ",
    "args": "",
    "doc_string": " **Internal use only**  The maximal relative difference between the sizes of two trees, it corresponds with the `w` in Adams' paper.  According to the Haskell comment, only `(delta, ratio)` settings of `(3, 2)` and `(4, 2)` will work, and the proofs in `ordset.lean` assume `delta := 3` and `ratio := 2`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "plift.encodable",
    "statement": "def plift.encodable {α : Type u_1} [encodable α] : encodable (plift α)",
    "theorem": "{α : Type u_1} [encodable α] : encodable (plift α)",
    "args": "{α : Type u_1} [encodable α]",
    "doc_string": "The lift of an encodable type is encodable.",
    "kind": "def",
    "type": "encodable (plift α)"
  },
  {
    "name": "parser.many1",
    "statement": "def parser.many1 {α : Type} (p : parser α) : parser (list α)",
    "theorem": "{α : Type} (p : parser α) : parser (list α)",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "Matches one or more occurrences of `p`.",
    "kind": "def",
    "type": "parser (list α)"
  },
  {
    "name": "topological_add_group.continuous_conj'",
    "statement": "theorem topological_add_group.continuous_conj' {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (λ (g : G), g + h + -g)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (λ (g : G), g + h + -g)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G)",
    "doc_string": "Conjugation acting on fixed element of the additive group is continuous when both   `add` and `neg` are continuous.",
    "kind": "theorem",
    "type": "continuous (λ (g : G), g + h + -g)"
  },
  {
    "name": "measurable_const'",
    "statement": "theorem measurable_const' {α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {f : β → α} (hf : ∀ (x y : β), f x = f y) : measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {f : β → α} (hf : ∀ (x y : β), f x = f y) : measurable f",
    "args": "{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {f : β → α} (hf : ∀ (x y : β), f x = f y)",
    "doc_string": " A version of `measurable_const` that assumes `f x = f y` for all `x, y`. This version works for functions between empty types.",
    "kind": "theorem",
    "type": "measurable f"
  },
  {
    "name": "stream.cycle",
    "statement": "def stream.cycle {α : Type u} (l : list α) : l ≠ list.nil → stream α",
    "theorem": "{α : Type u} (l : list α) : l ≠ list.nil → stream α",
    "args": "{α : Type u} (l : list α)",
    "doc_string": "Interpret a nonempty list as a cyclic stream.",
    "kind": "def",
    "type": "l ≠ list.nil → stream α"
  },
  {
    "name": "equiv.perm.is_cycle",
    "statement": "def equiv.perm.is_cycle {β : Type u_2} (f : equiv.perm β) : Prop",
    "theorem": "{β : Type u_2} (f : equiv.perm β) : Prop",
    "args": "{β : Type u_2} (f : equiv.perm β)",
    "doc_string": "A permutation is a cycle when any two nonfixed points of the permutation are related by repeated  application of the permutation.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "eckmann_hilton.is_unital",
    "statement": "structure eckmann_hilton.is_unital {X : Type u} (m : X → X → X) (e : X) : Prop",
    "theorem": "{X : Type u} (m : X → X → X) (e : X) : Prop",
    "args": "{X : Type u} (m : X → X → X) (e : X)",
    "doc_string": " `is_unital m e` expresses that `e : X` is a left and right unit for the binary operation `m : X → X → X`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "embedding_like",
    "statement": "structure embedding_like (F : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))",
    "theorem": "(F : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))",
    "args": "(F : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (Sort u_3))",
    "doc_string": " The class `embedding_like F α β` expresses that terms of type `F` have an injective coercion to injective functions `α ↪ β`.",
    "kind": "structure",
    "type": "Sort (max 1 (imax u_1 u_2 u_3))"
  },
  {
    "name": "onote.has_zero",
    "statement": "def onote.has_zero  : has_zero onote",
    "theorem": " : has_zero onote",
    "args": "",
    "doc_string": "Notation for 0",
    "kind": "def",
    "type": "has_zero onote"
  },
  {
    "name": "is_open_map_fst",
    "statement": "theorem is_open_map_fst {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β]",
    "doc_string": "The first projection in a product of topological spaces sends open sets to open sets.",
    "kind": "theorem",
    "type": "is_open_map prod.fst"
  },
  {
    "name": "X_in_terms_of_W",
    "statement": "def X_in_terms_of_W (p : ℕ) (R : Type u_1) [comm_ring R] [invertible ↑p] : ℕ → mv_polynomial ℕ R",
    "theorem": "(p : ℕ) (R : Type u_1) [comm_ring R] [invertible ↑p] : ℕ → mv_polynomial ℕ R",
    "args": "(p : ℕ) (R : Type u_1) [comm_ring R] [invertible ↑p]",
    "doc_string": " The `X_in_terms_of_W p R n` is the polynomial on the basis of Witt polynomials that corresponds to the ordinary `X n`.",
    "kind": "def",
    "type": "ℕ → mv_polynomial ℕ R"
  },
  {
    "name": "pSet.lift",
    "statement": "def pSet.lift  : pSet → pSet",
    "theorem": " : pSet → pSet",
    "args": "",
    "doc_string": "Universe lift operation",
    "kind": "def",
    "type": "pSet → pSet"
  },
  {
    "name": "is_seq_closed.is_closed",
    "statement": "theorem is_seq_closed.is_closed {X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s → is_closed s",
    "theorem": "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s → is_closed s",
    "args": "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X}",
    "doc_string": "**Alias** of the forward direction of is_seq_closed_iff_is_closed`.",
    "kind": "theorem",
    "type": "is_seq_closed s → is_closed s"
  },
  {
    "name": "hahn_series.summable_family",
    "statement": "structure hahn_series.summable_family (Γ : Type u_1) (R : Type u_2) [partial_order Γ] [add_comm_monoid R] (α : Type u_3) : Type (max u_1 u_2 u_3)",
    "theorem": "(Γ : Type u_1) (R : Type u_2) [partial_order Γ] [add_comm_monoid R] (α : Type u_3) : Type (max u_1 u_2 u_3)",
    "args": "(Γ : Type u_1) (R : Type u_2) [partial_order Γ] [add_comm_monoid R] (α : Type u_3)",
    "doc_string": "An infinite family of Hahn series which has a formal coefficient-wise sum.  The requirements for this are that the union of the supports of the series is well-founded,  and that only finitely many series are nonzero at any given coefficient.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "has_measurable_div₂",
    "statement": "structure has_measurable_div₂ (G₀ : Type u_1) [measurable_space G₀] [has_div G₀] : Prop",
    "theorem": "(G₀ : Type u_1) [measurable_space G₀] [has_div G₀] : Prop",
    "args": "(G₀ : Type u_1) [measurable_space G₀] [has_div G₀]",
    "doc_string": " We say that a type `has_measurable_div` if `uncurry (/)` is a measurable functions. For a typeclass assuming measurability of `((/) c)` and `(/ c)` see `has_measurable_div`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "subsemiring.prod",
    "statement": "def subsemiring.prod {R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (s : subsemiring R) (t : subsemiring S) : subsemiring (R × S)",
    "theorem": "{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (s : subsemiring R) (t : subsemiring S) : subsemiring (R × S)",
    "args": "{R : Type u} {S : Type v} [non_assoc_semiring R] [non_assoc_semiring S] (s : subsemiring R) (t : subsemiring S)",
    "doc_string": " Given `subsemiring`s `s`, `t` of semirings `R`, `S` respectively, `s.prod t` is `s × t` as a subsemiring of `R × S`.",
    "kind": "def",
    "type": "subsemiring (R × S)"
  },
  {
    "name": "ordinal.card",
    "statement": "def ordinal.card (o : ordinal) : cardinal",
    "theorem": "(o : ordinal) : cardinal",
    "args": "(o : ordinal)",
    "doc_string": "The cardinal of an ordinal is the cardinal of any  set with that order type.",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "pequiv",
    "statement": "structure pequiv (α : Type u) (β : Type v) : Type (max u v)",
    "theorem": "(α : Type u) (β : Type v) : Type (max u v)",
    "args": "(α : Type u) (β : Type v)",
    "doc_string": " A `pequiv` is a partial equivalence, a representation of a bijection between a subset   of `α` and a subset of `β`. See also `local_equiv` for a version that requires `to_fun` and `inv_fun` to be globally defined functions and has `source` and `target` sets as extra fields.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "category_theory.is_subterminal",
    "statement": "def category_theory.is_subterminal {C : Type u₁} [category_theory.category C] (A : C) : Prop",
    "theorem": "{C : Type u₁} [category_theory.category C] (A : C) : Prop",
    "args": "{C : Type u₁} [category_theory.category C] (A : C)",
    "doc_string": "An object `A` is subterminal iff for any `Z`, there is at most one morphism `Z ⟶ A`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.sum_centroid_weights_eq_one_of_card_eq_add_one",
    "statement": "theorem finset.sum_centroid_weights_eq_one_of_card_eq_add_one (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] {n : ℕ} (h : s.card = n + 1) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] {n : ℕ} (h : s.card = n + 1) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] {n : ℕ} (h : s.card = n + 1)",
    "doc_string": " In the characteristic zero case, the weights in the centroid sum to 1 if the number of points is `n + 1`.",
    "kind": "theorem",
    "type": "s.sum (λ (i : ι), finset.centroid_weights k s i) = 1"
  },
  {
    "name": "sym2.rel_bool",
    "statement": "def sym2.rel_bool {α : Type u_1} [decidable_eq α] (x y : α × α) : bool",
    "theorem": "{α : Type u_1} [decidable_eq α] (x y : α × α) : bool",
    "args": "{α : Type u_1} [decidable_eq α] (x y : α × α)",
    "doc_string": "An algorithm for computing `sym2.rel`.",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "filter.tendsto_abs_at_bot_at_top",
    "statement": "theorem filter.tendsto_abs_at_bot_at_top {α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_bot filter.at_top",
    "theorem": "{α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_bot filter.at_top",
    "args": "{α : Type u_3} [linear_ordered_add_comm_group α]",
    "doc_string": "$\\lim_{x\\to-\\infty}|x|=+\\infty$",
    "kind": "theorem",
    "type": "filter.tendsto has_abs.abs filter.at_bot filter.at_top"
  },
  {
    "name": "mul_action.orbit",
    "statement": "def mul_action.orbit (α : Type u) {β : Type v} [monoid α] [mul_action α β] (b : β) : set β",
    "theorem": "(α : Type u) {β : Type v} [monoid α] [mul_action α β] (b : β) : set β",
    "args": "(α : Type u) {β : Type v} [monoid α] [mul_action α β] (b : β)",
    "doc_string": "The orbit of an element under an action.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "setoid.rel",
    "statement": "def setoid.rel {α : Type u_1} (r : setoid α) : α → α → Prop",
    "theorem": "{α : Type u_1} (r : setoid α) : α → α → Prop",
    "args": "{α : Type u_1} (r : setoid α)",
    "doc_string": "A version of `setoid.r` that takes the equivalence relation as an explicit argument.",
    "kind": "def",
    "type": "α → α → Prop"
  },
  {
    "name": "category_theory.preadditive.has_equalizers_of_has_kernels",
    "statement": "theorem category_theory.preadditive.has_equalizers_of_has_kernels {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C]",
    "doc_string": "If a preadditive category has all kernels, then it also has all equalizers.",
    "kind": "theorem",
    "type": "category_theory.limits.has_equalizers C"
  },
  {
    "name": "uniform_convergence.topological_space",
    "statement": "def uniform_convergence.topological_space (α : Type u_1) (β : Type u_2) [uniform_space β] : topological_space (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [uniform_space β] : topological_space (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [uniform_space β]",
    "doc_string": "Topology of uniform convergence",
    "kind": "def",
    "type": "topological_space (α → β)"
  },
  {
    "name": "topological_fiber_bundle_core.index",
    "statement": "def topological_fiber_bundle_core.index {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : Type u_1",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : Type u_1",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F)",
    "doc_string": "The index set of a topological fiber bundle core, as a convenience function for dot notation",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "quiver.has_reverse",
    "statement": "structure quiver.has_reverse (V : Type u) [quiver V] : Type (max u v)",
    "theorem": "(V : Type u) [quiver V] : Type (max u v)",
    "args": "(V : Type u) [quiver V]",
    "doc_string": "A quiver `has_reverse` if we can reverse an arrow `p` from `a` to `b` to get an arrow    `p.reverse` from `b` to `a`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "is_regular_of_cancel_monoid",
    "statement": "theorem is_regular_of_cancel_monoid {R : Type u_1} [cancel_monoid R] (g : R) : is_regular g",
    "theorem": "{R : Type u_1} [cancel_monoid R] (g : R) : is_regular g",
    "args": "{R : Type u_1} [cancel_monoid R] (g : R)",
    "doc_string": "Elements of a cancel monoid are regular.  Cancel semigroups do not appear to exist.",
    "kind": "theorem",
    "type": "is_regular g"
  },
  {
    "name": "uniform_inducing",
    "statement": "structure uniform_inducing {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β)",
    "doc_string": " A map `f : α → β` between uniform spaces is called *uniform inducing* if the uniformity filter on `α` is the pullback of the uniformity filter on `β` under `prod.map f f`. If `α` is a separated space, then this implies that `f` is injective, hence it is a `uniform_embedding`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_add_monoid_hom.neg",
    "statement": "theorem is_add_monoid_hom.neg {α : Type u_1} {β : Type u_2} [add_zero_class α] [add_comm_group β] {f : α → β} (hf : is_add_monoid_hom f) : is_add_monoid_hom (λ (a : α), -f a)",
    "theorem": "{α : Type u_1} {β : Type u_2} [add_zero_class α] [add_comm_group β] {f : α → β} (hf : is_add_monoid_hom f) : is_add_monoid_hom (λ (a : α), -f a)",
    "args": "{α : Type u_1} {β : Type u_2} [add_zero_class α] [add_comm_group β] {f : α → β} (hf : is_add_monoid_hom f)",
    "doc_string": "The negation of a map which preserves addition, preserves addition when the target is commutative.",
    "kind": "theorem",
    "type": "is_add_monoid_hom (λ (a : α), -f a)"
  },
  {
    "name": "rat",
    "statement": "structure rat  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "`rat`, or `ℚ`, is the type of rational numbers. It is defined  as the set of pairs ⟨n, d⟩ of integers such that `d` is positive and `n` and  `d` are coprime. This representation is preferred to the quotient  because without periodic reduction, the numerator and denominator can grow  exponentially (for example, adding 1/2 to itself repeatedly).",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "dense_inducing.separable_space",
    "statement": "theorem dense_inducing.separable_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} (di : dense_inducing i) [topological_space.separable_space α] : topological_space.separable_space β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} (di : dense_inducing i) [topological_space.separable_space α] : topological_space.separable_space β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} (di : dense_inducing i) [topological_space.separable_space α]",
    "doc_string": "If the domain of a `dense_inducing` map is a separable space, then so is the codomain.",
    "kind": "theorem",
    "type": "topological_space.separable_space β"
  },
  {
    "name": "ring.positive_cone",
    "statement": "structure ring.positive_cone (α : Type u_1) [ring α] : Type u_1",
    "theorem": "(α : Type u_1) [ring α] : Type u_1",
    "args": "(α : Type u_1) [ring α]",
    "doc_string": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`, which contains `1` and such that the positive elements are closed under multiplication.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "nonote.repr",
    "statement": "def nonote.repr (o : nonote) : ordinal",
    "theorem": "(o : nonote) : ordinal",
    "args": "(o : nonote)",
    "doc_string": "The ordinal represented by an ordinal notation.  (This function is noncomputable because ordinal  arithmetic is noncomputable. In computational applications  `nonote` can be used exclusively without reference  to `ordinal`, but this function allows for correctness  results to be stated.)",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair",
    "statement": "structure generalized_continued_fraction.int_fract_pair (K : Type u_1) : Type u_1",
    "theorem": "(K : Type u_1) : Type u_1",
    "args": "(K : Type u_1)",
    "doc_string": "We collect an integer part `b = ⌊v⌋` and fractional part `fr = v - ⌊v⌋` of a value `v` in a pair `⟨b, fr⟩`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "topological_division_ring",
    "statement": "structure topological_division_ring (K : Type u_1) [division_ring K] [topological_space K] : Prop",
    "theorem": "(K : Type u_1) [division_ring K] [topological_space K] : Prop",
    "args": "(K : Type u_1) [division_ring K] [topological_space K]",
    "doc_string": "A topological division ring is a division ring with a topology where all operations are    continuous, including inversion.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "finset.product",
    "statement": "def finset.product {α : Type u_1} {β : Type u_2} (s : finset α) (t : finset β) : finset (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (s : finset α) (t : finset β) : finset (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} (s : finset α) (t : finset β)",
    "doc_string": "`product s t` is the set of pairs `(a, b)` such that `a ∈ s` and `b ∈ t`.",
    "kind": "def",
    "type": "finset (α × β)"
  },
  {
    "name": "category_theory.Quiv",
    "statement": "def category_theory.Quiv  : Type (max (u+1) u (v+1))",
    "theorem": " : Type (max (u+1) u (v+1))",
    "args": "",
    "doc_string": "Category of quivers.",
    "kind": "def",
    "type": "Type (max (u+1) u (v+1))"
  },
  {
    "name": "structure_groupoid.is_local_structomorph_within_at",
    "statement": "def structure_groupoid.is_local_structomorph_within_at {H : Type u_1} [topological_space H] (G : structure_groupoid H) (f : H → H) (s : set H) (x : H) : Prop",
    "theorem": "{H : Type u_1} [topological_space H] (G : structure_groupoid H) (f : H → H) (s : set H) (x : H) : Prop",
    "args": "{H : Type u_1} [topological_space H] (G : structure_groupoid H) (f : H → H) (s : set H) (x : H)",
    "doc_string": " A function from a model space `H` to itself is a local structomorphism, with respect to a structure groupoid `G` for `H`, relative to a set `s` in `H`, if for all points `x` in the set, the function agrees with a `G`-structomorphism on `s` in a neighbourhood of `x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "midpoint",
    "statement": "def midpoint (R : Type u_1) {V : Type u_2} {P : Type u_4} [ring R] [invertible 2] [add_comm_group V] [module R V] [add_torsor V P] (x y : P) : P",
    "theorem": "(R : Type u_1) {V : Type u_2} {P : Type u_4} [ring R] [invertible 2] [add_comm_group V] [module R V] [add_torsor V P] (x y : P) : P",
    "args": "(R : Type u_1) {V : Type u_2} {P : Type u_4} [ring R] [invertible 2] [add_comm_group V] [module R V] [add_torsor V P] (x y : P)",
    "doc_string": "`midpoint x y` is the midpoint of the segment `[x, y]`.",
    "kind": "def",
    "type": "P"
  },
  {
    "name": "num.land",
    "statement": "def num.land  : num → num → num",
    "theorem": " : num → num → num",
    "args": "",
    "doc_string": "Bitwise \"and\" for `num`.",
    "kind": "def",
    "type": "num → num → num"
  },
  {
    "name": "two_pointing",
    "statement": "structure two_pointing (α : Type u_3) : Type u_3",
    "theorem": "(α : Type u_3) : Type u_3",
    "args": "(α : Type u_3)",
    "doc_string": "Two-pointing of a type. This is a Type-valued termed `nontrivial`.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "add_group_with_zero_nhd",
    "statement": "structure add_group_with_zero_nhd (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": " additive group with a neighbourhood around 0. Only used to construct a topology and uniform space.  This is currently only available for commutative groups, but it can be extended to non-commutative groups too.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "mul_opposite",
    "statement": "def mul_opposite (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " Multiplicative opposite of a type. This type inherits all additive structures on `α` and reverses left and right in multiplication.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "funext",
    "statement": "theorem funext {α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x) : f₁ = f₂",
    "theorem": "{α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x) : f₁ = f₂",
    "args": "{α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x)",
    "doc_string": "Function extensionality, proven using quotients.",
    "kind": "theorem",
    "type": "f₁ = f₂"
  },
  {
    "name": "bitvec.bits_to_nat",
    "statement": "def bitvec.bits_to_nat (v : list bool) : ℕ",
    "theorem": "(v : list bool) : ℕ",
    "args": "(v : list bool)",
    "doc_string": "Given a `list` of `bool`s, return the `nat` they represent as a list of binary digits.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "ennreal.algebra",
    "statement": "def ennreal.algebra {A : Type u_1} [semiring A] [algebra ennreal A] : algebra nnreal A",
    "theorem": "{A : Type u_1} [semiring A] [algebra ennreal A] : algebra nnreal A",
    "args": "{A : Type u_1} [semiring A] [algebra ennreal A]",
    "doc_string": "An `algebra` over `ℝ≥0∞` restricts to an `algebra` over `ℝ≥0`.",
    "kind": "def",
    "type": "algebra nnreal A"
  },
  {
    "name": "topological_space.compact_opens",
    "statement": "structure topological_space.compact_opens (α : Type u_3) [topological_space α] : Type u_3",
    "theorem": "(α : Type u_3) [topological_space α] : Type u_3",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": " The type of compact open sets of a topological space. This is useful in non Hausdorff contexts, in particular spectral spaces.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "zmod.legendre_sym_eq_pow",
    "statement": "theorem zmod.legendre_sym_eq_pow (p : ℕ) (a : ℤ) [hp : fact (nat.prime p)] : ↑(zmod.legendre_sym p a) = ↑a ^ (p / 2)",
    "theorem": "(p : ℕ) (a : ℤ) [hp : fact (nat.prime p)] : ↑(zmod.legendre_sym p a) = ↑a ^ (p / 2)",
    "args": "(p : ℕ) (a : ℤ) [hp : fact (nat.prime p)]",
    "doc_string": "We have the congruence `legendre_sym p a ≡ a ^ (p / 2) mod p`.",
    "kind": "theorem",
    "type": "↑(zmod.legendre_sym p a) = ↑a ^ (p / 2)"
  },
  {
    "name": "arity",
    "statement": "def arity (α : Type u) : ℕ → Type u",
    "theorem": "(α : Type u) : ℕ → Type u",
    "args": "(α : Type u)",
    "doc_string": "The type of `n`-ary functions `α → α → ... → α`.",
    "kind": "def",
    "type": "ℕ → Type u"
  },
  {
    "name": "multiples",
    "statement": "def multiples {M : Type u_1} [add_monoid M] (x : M) : set M",
    "theorem": "{M : Type u_1} [add_monoid M] (x : M) : set M",
    "args": "{M : Type u_1} [add_monoid M] (x : M)",
    "doc_string": "The set of natural number multiples `0, x, 2x, ...` of an element `x` of an `add_monoid`.",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "multiset.subset",
    "statement": "def multiset.subset {α : Type u_1} (s t : multiset α) : Prop",
    "theorem": "{α : Type u_1} (s t : multiset α) : Prop",
    "args": "{α : Type u_1} (s t : multiset α)",
    "doc_string": "`s ⊆ t` is the lift of the list subset relation. It means that any  element with nonzero multiplicity in `s` has nonzero multiplicity in `t`,  but it does not imply that the multiplicity of `a` in `s` is less or equal than in `t`;  see `s ≤ t` for this relation.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "seminorm_family.basis_sets",
    "statement": "def seminorm_family.basis_sets {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm_family 𝕜 E ι) : set (set E)",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm_family 𝕜 E ι) : set (set E)",
    "args": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm_family 𝕜 E ι)",
    "doc_string": "The sets of a filter basis for the neighborhood filter of 0.",
    "kind": "def",
    "type": "set (set E)"
  },
  {
    "name": "right.one_lt_mul_of_lt_of_le",
    "statement": "theorem right.one_lt_mul_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_lt_of_le`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "neg_le_self",
    "statement": "theorem neg_le_self {α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_le.le] {a : α} (h : 0 ≤ a) : -a ≤ a",
    "theorem": "{α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_le.le] {a : α} (h : 0 ≤ a) : -a ≤ a",
    "args": "{α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_le.le] {a : α} (h : 0 ≤ a)",
    "doc_string": "**Alias** of left.neg_le_self`.",
    "kind": "theorem",
    "type": "-a ≤ a"
  },
  {
    "name": "category_theory.InjectiveResolution.of_cocomplex",
    "statement": "def category_theory.InjectiveResolution.of_cocomplex {C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_injectives C] (Z : C) : cochain_complex C ℕ",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_injectives C] (Z : C) : cochain_complex C ℕ",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_injectives C] (Z : C)",
    "doc_string": "Auxiliary definition for `InjectiveResolution.of`.",
    "kind": "def",
    "type": "cochain_complex C ℕ"
  },
  {
    "name": "measure_theory.pi_premeasure",
    "statement": "def measure_theory.pi_premeasure {ι : Type u_1} {α : ι → Type u_3} [fintype ι] (m : Π (i : ι), measure_theory.outer_measure (α i)) (s : set (Π (i : ι), α i)) : ennreal",
    "theorem": "{ι : Type u_1} {α : ι → Type u_3} [fintype ι] (m : Π (i : ι), measure_theory.outer_measure (α i)) (s : set (Π (i : ι), α i)) : ennreal",
    "args": "{ι : Type u_1} {α : ι → Type u_3} [fintype ι] (m : Π (i : ι), measure_theory.outer_measure (α i)) (s : set (Π (i : ι), α i))",
    "doc_string": "An upper bound for the measure in a finite product space.  It is defined to by taking the image of the set under all projections, and taking the product  of the measures of these images.  For measurable boxes it is equal to the correct measure.",
    "kind": "def",
    "type": "ennreal"
  },
  {
    "name": "padic_val_nat.zero",
    "statement": "theorem padic_val_nat.zero {p : ℕ} : padic_val_nat p 0 = 0",
    "theorem": "{p : ℕ} : padic_val_nat p 0 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_nat p 0` is 0 for any `p`.",
    "kind": "theorem",
    "type": "padic_val_nat p 0 = 0"
  },
  {
    "name": "Top.glue_data",
    "statement": "structure Top.glue_data  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "A family of gluing data consists of 1. An index type `J` 2. An object `U i` for each `i : J`. 3. An object `V i j` for each `i j : J`.   (Note that this is `J × J → Top` rather than `J → J → Top` to connect to the   limits library easier.) 4. An open embedding `f i j : V i j ⟶ U i` for each `i j : ι`. 5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`. such that 6. `f i i` is an isomorphism. 7. `t i i` is the identity. 8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some     `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.     (This merely means that `V i j ∩ V i k ⊆ t i j ⁻¹' (V j i ∩ V j k)`.) 9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.  We can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`, such that the `U i`'s are open subspaces of the glued space.  Most of the times it would be easier to use the constructor `Top.glue_data.mk'` where the conditions are stated in a less categorical way.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "category_theory.exact_inr_fst",
    "statement": "theorem category_theory.exact_inr_fst {𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst",
    "theorem": "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst",
    "args": "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜)",
    "doc_string": "The sequence `B ⟶ A ⊞ B ⟶ A` is exact.",
    "kind": "theorem",
    "type": "category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst"
  },
  {
    "name": "alist.keys",
    "statement": "def alist.keys {α : Type u} {β : α → Type v} (s : alist β) : list α",
    "theorem": "{α : Type u} {β : α → Type v} (s : alist β) : list α",
    "args": "{α : Type u} {β : α → Type v} (s : alist β)",
    "doc_string": "The list of keys of an association list.",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "TopCommRing.of",
    "statement": "def TopCommRing.of (X : Type u) [comm_ring X] [topological_space X] [topological_ring X] : TopCommRing",
    "theorem": "(X : Type u) [comm_ring X] [topological_space X] [topological_ring X] : TopCommRing",
    "args": "(X : Type u) [comm_ring X] [topological_space X] [topological_ring X]",
    "doc_string": "Construct a bundled `TopCommRing` from the underlying type and the appropriate typeclasses.",
    "kind": "def",
    "type": "TopCommRing"
  },
  {
    "name": "equiv.perm.sigma_congr_right",
    "statement": "def equiv.perm.sigma_congr_right {α : Type u_1} {β : α → Type u_2} (F : Π (a : α), equiv.perm (β a)) : equiv.perm (Σ (a : α), β a)",
    "theorem": "{α : Type u_1} {β : α → Type u_2} (F : Π (a : α), equiv.perm (β a)) : equiv.perm (Σ (a : α), β a)",
    "args": "{α : Type u_1} {β : α → Type u_2} (F : Π (a : α), equiv.perm (β a))",
    "doc_string": "A family of permutations `Π a, perm (β a)` generates a permuation `perm (Σ a, β₁ a)`.",
    "kind": "def",
    "type": "equiv.perm (Σ (a : α), β a)"
  },
  {
    "name": "module.subsingleton",
    "statement": "theorem module.subsingleton (R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M]",
    "doc_string": " A module over a `subsingleton` semiring is a `subsingleton`. We cannot register this as an instance because Lean has no way to guess `R`.",
    "kind": "theorem",
    "type": "subsingleton M"
  },
  {
    "name": "encodable.encode_sum",
    "statement": "def encodable.encode_sum {α : Type u_1} {β : Type u_2} [encodable α] [encodable β] : α ⊕ β → ℕ",
    "theorem": "{α : Type u_1} {β : Type u_2} [encodable α] [encodable β] : α ⊕ β → ℕ",
    "args": "{α : Type u_1} {β : Type u_2} [encodable α] [encodable β]",
    "doc_string": "Explicit encoding function for the sum of two encodable types.",
    "kind": "def",
    "type": "α ⊕ β → ℕ"
  },
  {
    "name": "linear_ordered_comm_group_with_zero.nhds_zero_of_ne_zero",
    "statement": "theorem linear_ordered_comm_group_with_zero.nhds_zero_of_ne_zero {Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : {x : Γ₀ | x < γ} ∈ nhds 0",
    "theorem": "{Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀) (h : γ ≠ 0) : {x : Γ₀ | x < γ} ∈ nhds 0",
    "args": "{Γ₀ : Type u_1} [linear_ordered_comm_group_with_zero Γ₀] (γ : Γ₀) (h : γ ≠ 0)",
    "doc_string": " If γ is a nonzero element of a linearly ordered group with zero element adjoined, then {x | x < γ} is a neighbourhood of 0.",
    "kind": "theorem",
    "type": "{x : Γ₀ | x < γ} ∈ nhds 0"
  },
  {
    "name": "infi",
    "statement": "def infi {α : Type u_1} [has_Inf α] {ι : Sort u_2} (s : ι → α) : α",
    "theorem": "{α : Type u_1} [has_Inf α] {ι : Sort u_2} (s : ι → α) : α",
    "args": "{α : Type u_1} [has_Inf α] {ι : Sort u_2} (s : ι → α)",
    "doc_string": "Indexed infimum",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "num.add",
    "statement": "def num.add  : num → num → num",
    "theorem": " : num → num → num",
    "args": "",
    "doc_string": "Addition of two `num`s.",
    "kind": "def",
    "type": "num → num → num"
  },
  {
    "name": "monoid.to_mul_action",
    "statement": "def monoid.to_mul_action (M : Type u_1) [monoid M] : mul_action M M",
    "theorem": "(M : Type u_1) [monoid M] : mul_action M M",
    "args": "(M : Type u_1) [monoid M]",
    "doc_string": " The regular action of a monoid on itself by left multiplication.  This is promoted to a module by `semiring.to_module`.",
    "kind": "def",
    "type": "mul_action M M"
  },
  {
    "name": "alist",
    "statement": "structure alist {α : Type u} (β : α → Type v) : Type (max u v)",
    "theorem": "{α : Type u} (β : α → Type v) : Type (max u v)",
    "args": "{α : Type u} (β : α → Type v)",
    "doc_string": "`alist β` is a key-value map stored as a `list` (i.e. a linked list).  It is a wrapper around certain `list` functions with the added constraint  that the list have unique keys.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "computation.terminates",
    "statement": "structure computation.terminates {α : Type u} (s : computation α) : Prop",
    "theorem": "{α : Type u} (s : computation α) : Prop",
    "args": "{α : Type u} (s : computation α)",
    "doc_string": "`terminates s` asserts that the computation `s` eventually terminates with some value.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "prod.semiring",
    "statement": "def prod.semiring {R : Type u_1} {S : Type u_3} [semiring R] [semiring S] : semiring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [semiring R] [semiring S] : semiring (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [semiring R] [semiring S]",
    "doc_string": "Product of two semirings is a semiring.",
    "kind": "def",
    "type": "semiring (R × S)"
  },
  {
    "name": "omega.clause.sat",
    "statement": "def omega.clause.sat (c : omega.clause) : Prop",
    "theorem": "(c : omega.clause) : Prop",
    "args": "(c : omega.clause)",
    "doc_string": "sat c := there exists a valuation v under which c holds",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "matrix.vec_mul",
    "statement": "def matrix.vec_mul {m : Type u_2} {n : Type u_3} {α : Type v} [non_unital_non_assoc_semiring α] [fintype m] (v : m → α) (M : matrix m n α) : n → α",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} [non_unital_non_assoc_semiring α] [fintype m] (v : m → α) (M : matrix m n α) : n → α",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} [non_unital_non_assoc_semiring α] [fintype m] (v : m → α) (M : matrix m n α)",
    "doc_string": "`vec_mul v M` is the vector-matrix product of `v` and `M`, where `v` is seen as a row matrix.    Put another way, `vec_mul v M` is the vector whose entries    are those of `row v ⬝ M` (see `row_vec_mul`).",
    "kind": "def",
    "type": "n → α"
  },
  {
    "name": "topological_space.positive_compacts.locally_compact_space_of_group",
    "statement": "theorem topological_space.positive_compacts.locally_compact_space_of_group {G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G",
    "theorem": "{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G",
    "args": "{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G)",
    "doc_string": " Every separated topological group in which there exists a compact set with nonempty interior is locally compact.",
    "kind": "theorem",
    "type": "locally_compact_space G"
  },
  {
    "name": "submonoid.powers",
    "statement": "def submonoid.powers {M : Type u_1} [monoid M] (n : M) : submonoid M",
    "theorem": "{M : Type u_1} [monoid M] (n : M) : submonoid M",
    "args": "{M : Type u_1} [monoid M] (n : M)",
    "doc_string": "The submonoid generated by an element.",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "witt_polynomial",
    "statement": "def witt_polynomial (p : ℕ) (R : Type u_1) [comm_ring R] (n : ℕ) : mv_polynomial ℕ R",
    "theorem": "(p : ℕ) (R : Type u_1) [comm_ring R] (n : ℕ) : mv_polynomial ℕ R",
    "args": "(p : ℕ) (R : Type u_1) [comm_ring R] (n : ℕ)",
    "doc_string": " `witt_polynomial p R n` is the `n`-th Witt polynomial with respect to a prime `p` with coefficients in a commutative ring `R`. It is defined as:  `∑_{i ≤ n} p^i X_i^{p^{n-i}} ∈ R[X_0, X_1, X_2, …]`.",
    "kind": "def",
    "type": "mv_polynomial ℕ R"
  },
  {
    "name": "has_lt.lt.not_lt",
    "statement": "theorem has_lt.lt.not_lt {α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of lt_asymm`.",
    "kind": "theorem",
    "type": "¬b < a"
  },
  {
    "name": "submodule.to_sub_mul_action",
    "statement": "def submodule.to_sub_mul_action {R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : sub_mul_action R M",
    "theorem": "{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M) : sub_mul_action R M",
    "args": "{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (self : submodule R M)",
    "doc_string": "Reinterpret a `submodule` as an `sub_mul_action`.",
    "kind": "def",
    "type": "sub_mul_action R M"
  },
  {
    "name": "list.rotate'",
    "statement": "def list.rotate' {α : Type u_1} : list α → ℕ → list α",
    "theorem": "{α : Type u_1} : list α → ℕ → list α",
    "args": "{α : Type u_1}",
    "doc_string": "rotate' is the same as `rotate`, but slower. Used for proofs about `rotate`",
    "kind": "def",
    "type": "list α → ℕ → list α"
  },
  {
    "name": "adjoin_root.power_basis",
    "statement": "def adjoin_root.power_basis {K : Type w} [field K] {f : polynomial K} (hf : f ≠ 0) : power_basis K (adjoin_root f)",
    "theorem": "{K : Type w} [field K] {f : polynomial K} (hf : f ≠ 0) : power_basis K (adjoin_root f)",
    "args": "{K : Type w} [field K] {f : polynomial K} (hf : f ≠ 0)",
    "doc_string": " The power basis `1, root f, ..., root f ^ (d - 1)` for `adjoin_root f`, where `f` is an irreducible polynomial over a field of degree `d`.",
    "kind": "def",
    "type": "power_basis K (adjoin_root f)"
  },
  {
    "name": "multiset.nat.antidiagonal",
    "statement": "def multiset.nat.antidiagonal (n : ℕ) : multiset (ℕ × ℕ)",
    "theorem": "(n : ℕ) : multiset (ℕ × ℕ)",
    "args": "(n : ℕ)",
    "doc_string": "The antidiagonal of a natural number `n` is    the multiset of pairs `(i, j)` such that `i + j = n`.",
    "kind": "def",
    "type": "multiset (ℕ × ℕ)"
  },
  {
    "name": "cluster_pt",
    "statement": "def cluster_pt {α : Type u} [topological_space α] (x : α) (F : filter α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (x : α) (F : filter α) : Prop",
    "args": "{α : Type u} [topological_space α] (x : α) (F : filter α)",
    "doc_string": " A point `x` is a cluster point of a filter `F` if 𝓝 x ⊓ F ≠ ⊥. Also known as an accumulation point or a limit point.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "matrix.has_star",
    "statement": "def matrix.has_star {n : Type u_3} {α : Type v} [has_star α] : has_star (matrix n n α)",
    "theorem": "{n : Type u_3} {α : Type v} [has_star α] : has_star (matrix n n α)",
    "args": "{n : Type u_3} {α : Type v} [has_star α]",
    "doc_string": " When `α` has a star operation, square matrices `matrix n n α` have a star operation equal to `matrix.conj_transpose`.",
    "kind": "def",
    "type": "has_star (matrix n n α)"
  },
  {
    "name": "finset.Iic",
    "statement": "def finset.Iic {α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : finset α",
    "theorem": "{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : finset α",
    "args": "{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α)",
    "doc_string": "The finset of elements `x` such that `x ≤ b`. Basically `set.Iic b` as a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "polynomial.cyclotomic_ne_zero",
    "statement": "theorem polynomial.cyclotomic_ne_zero (n : ℕ) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R ≠ 0",
    "theorem": "(n : ℕ) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R ≠ 0",
    "args": "(n : ℕ) (R : Type u_1) [ring R] [nontrivial R]",
    "doc_string": "`cyclotomic n R` is different from `0`.",
    "kind": "theorem",
    "type": "polynomial.cyclotomic n R ≠ 0"
  },
  {
    "name": "setoid.mk_classes",
    "statement": "def setoid.mk_classes {α : Type u_1} (c : set (set α)) (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) : setoid α",
    "theorem": "{α : Type u_1} (c : set (set α)) (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) : setoid α",
    "args": "{α : Type u_1} (c : set (set α)) (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b)",
    "doc_string": "Makes an equivalence relation from a set of sets partitioning α.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "vector.last",
    "statement": "def vector.last {n : ℕ} {α : Type u_1} (v : vector α (n + 1)) : α",
    "theorem": "{n : ℕ} {α : Type u_1} (v : vector α (n + 1)) : α",
    "args": "{n : ℕ} {α : Type u_1} (v : vector α (n + 1))",
    "doc_string": "The last element of a `vector`, given that the vector is at least one element.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "neg_neg_iff_pos",
    "statement": "theorem neg_neg_iff_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "kind": "theorem",
    "type": "-a < 0 ↔ 0 < a"
  },
  {
    "name": "is_add_left_regular.of_add",
    "statement": "theorem is_add_left_regular.of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b))",
    "doc_string": "If an element `b` becomes add-left-regular after adding to it on the left a add-left-regular element, then `b` is add-left-regular.",
    "kind": "theorem",
    "type": "is_add_left_regular b"
  },
  {
    "name": "category_theory.types_grothendieck_topology",
    "statement": "def category_theory.types_grothendieck_topology  : category_theory.grothendieck_topology (Type u)",
    "theorem": " : category_theory.grothendieck_topology (Type u)",
    "args": "",
    "doc_string": " A Grothendieck topology associated to the category of all types. A sieve is a covering iff it is jointly surjective.",
    "kind": "def",
    "type": "category_theory.grothendieck_topology (Type u)"
  },
  {
    "name": "nat.min_sq_fac_prop",
    "statement": "def nat.min_sq_fac_prop (n : ℕ) : option ℕ → Prop",
    "theorem": "(n : ℕ) : option ℕ → Prop",
    "args": "(n : ℕ)",
    "doc_string": "The correctness property of the return value of `min_sq_fac`.  * If `none`, then `n` is squarefree;  * If `some d`, then `d` is a minimal square factor of `n`",
    "kind": "def",
    "type": "option ℕ → Prop"
  },
  {
    "name": "category_theory.enriched_category",
    "statement": "structure category_theory.enriched_category (V : Type v) [category_theory.category V] [category_theory.monoidal_category V] (C : Type u₁) : Type (max u₁ v w)",
    "theorem": "(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] (C : Type u₁) : Type (max u₁ v w)",
    "args": "(V : Type v) [category_theory.category V] [category_theory.monoidal_category V] (C : Type u₁)",
    "doc_string": "A `V`-category is a category enriched in a monoidal category `V`.  Note that we do not assume that `V` is a concrete category, so there may not be an \"honest\" underlying category at all!",
    "kind": "structure",
    "type": "Type (max u₁ v w)"
  },
  {
    "name": "normalized_gcd_monoid_of_exists_gcd",
    "statement": "def normalized_gcd_monoid_of_exists_gcd {α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c) : normalized_gcd_monoid α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c) : normalized_gcd_monoid α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalization_monoid α] [decidable_eq α] (h : ∀ (a b : α), ∃ (c : α), ∀ (d : α), d ∣ a ∧ d ∣ b ↔ d ∣ c)",
    "doc_string": "Define a `normalized_gcd_monoid` structure on a monoid just from the existence of a `gcd`.",
    "kind": "def",
    "type": "normalized_gcd_monoid α"
  },
  {
    "name": "subring.one_mem",
    "statement": "theorem subring.one_mem {R : Type u} [ring R] (s : subring R) : 1 ∈ s",
    "theorem": "{R : Type u} [ring R] (s : subring R) : 1 ∈ s",
    "args": "{R : Type u} [ring R] (s : subring R)",
    "doc_string": "A subring contains the ring's 1.",
    "kind": "theorem",
    "type": "1 ∈ s"
  },
  {
    "name": "ring_filter_basis",
    "statement": "structure ring_filter_basis (R : Type u) [ring R] : Type u",
    "theorem": "(R : Type u) [ring R] : Type u",
    "args": "(R : Type u) [ring R]",
    "doc_string": "A `ring_filter_basis` on a ring is a `filter_basis` satisfying some additional axioms.  Example : if `R` is a topological ring then the neighbourhoods of the identity are a  `ring_filter_basis`. Conversely given a `ring_filter_basis` on a ring `R`, one can define a  topology on `R` which is compatible with the ring structure.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "ulift.map",
    "statement": "def ulift.map {α : Type u} {β : Type v} (f : α → β) (a : ulift α) : ulift β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (a : ulift α) : ulift β",
    "args": "{α : Type u} {β : Type v} (f : α → β) (a : ulift α)",
    "doc_string": "Functorial action.",
    "kind": "def",
    "type": "ulift β"
  },
  {
    "name": "cardinal.prod",
    "statement": "def cardinal.prod {ι : Type u} (f : ι → cardinal) : cardinal",
    "theorem": "{ι : Type u} (f : ι → cardinal) : cardinal",
    "args": "{ι : Type u} (f : ι → cardinal)",
    "doc_string": "The indexed product of cardinals is the cardinality of the Pi type  (dependent product).",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "left_coset",
    "statement": "def left_coset {α : Type u_1} [has_mul α] (a : α) (s : set α) : set α",
    "theorem": "{α : Type u_1} [has_mul α] (a : α) (s : set α) : set α",
    "args": "{α : Type u_1} [has_mul α] (a : α) (s : set α)",
    "doc_string": "The left coset `a * s` for an element `a : α` and a subset `s : set α`",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "matrix.diag",
    "statement": "def matrix.diag {n : Type u_3} {α : Type v} (A : matrix n n α) (i : n) : α",
    "theorem": "{n : Type u_3} {α : Type v} (A : matrix n n α) (i : n) : α",
    "args": "{n : Type u_3} {α : Type v} (A : matrix n n α) (i : n)",
    "doc_string": "The diagonal of a square matrix.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "seq.append",
    "statement": "def seq.append {α : Type u} (s₁ s₂ : seq α) : seq α",
    "theorem": "{α : Type u} (s₁ s₂ : seq α) : seq α",
    "args": "{α : Type u} (s₁ s₂ : seq α)",
    "doc_string": "Append two sequences. If `s₁` is infinite, then `s₁ ++ s₂ = s₁`,  otherwise it puts `s₂` at the location of the `nil` in `s₁`.",
    "kind": "def",
    "type": "seq α"
  },
  {
    "name": "finset.slice",
    "statement": "def finset.slice {α : Type u_1} (𝒜 : finset (finset α)) (r : ℕ) : finset (finset α)",
    "theorem": "{α : Type u_1} (𝒜 : finset (finset α)) (r : ℕ) : finset (finset α)",
    "args": "{α : Type u_1} (𝒜 : finset (finset α)) (r : ℕ)",
    "doc_string": "The `r`-th slice of a set family is the subset of its elements which have cardinality `r`.",
    "kind": "def",
    "type": "finset (finset α)"
  },
  {
    "name": "category_theory.monoidal_category.monoidal_predicate",
    "statement": "structure category_theory.monoidal_category.monoidal_predicate {C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C → Prop) : Type",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C → Prop) : Type",
    "args": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (P : C → Prop)",
    "doc_string": "A property `C → Prop` is a monoidal predicate if it is closed under `𝟙_` and `⊗`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "typevec",
    "statement": "def typevec (n : ℕ) : Type (u_1+1)",
    "theorem": "(n : ℕ) : Type (u_1+1)",
    "args": "(n : ℕ)",
    "doc_string": "n-tuples of types, as a category",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "FinVect.FinVect_dual",
    "statement": "def FinVect.FinVect_dual (K : Type u) [field K] (V : FinVect K) : FinVect K",
    "theorem": "(K : Type u) [field K] (V : FinVect K) : FinVect K",
    "args": "(K : Type u) [field K] (V : FinVect K)",
    "doc_string": "The dual module is the dual in the rigid monoidal category `FinVect K`.",
    "kind": "def",
    "type": "FinVect K"
  },
  {
    "name": "list.permutations",
    "statement": "def list.permutations {α : Type u_1} (l : list α) : list (list α)",
    "theorem": "{α : Type u_1} (l : list α) : list (list α)",
    "args": "{α : Type u_1} (l : list α)",
    "doc_string": "List of all permutations of `l`.      permutations [1, 2, 3] =       [[1, 2, 3], [2, 1, 3], [3, 2, 1],        [2, 3, 1], [3, 1, 2], [1, 3, 2]]",
    "kind": "def",
    "type": "list (list α)"
  },
  {
    "name": "list.Ico",
    "statement": "def list.Ico (n m : ℕ) : list ℕ",
    "theorem": "(n m : ℕ) : list ℕ",
    "args": "(n m : ℕ)",
    "doc_string": "`Ico n m` is the list of natural numbers `n ≤ x < m`. (Ico stands for \"interval, closed-open\".)  See also `data/set/intervals.lean` for `set.Ico`, modelling intervals in general preorders, and `multiset.Ico` and `finset.Ico` for `n ≤ x < m` as a multiset or as a finset.",
    "kind": "def",
    "type": "list ℕ"
  },
  {
    "name": "pell.az",
    "statement": "def pell.az {a : ℕ} : ℤ",
    "theorem": "{a : ℕ} : ℤ",
    "args": "{a : ℕ}",
    "doc_string": "The element `a` such that `d = a ^ 2 - 1`, considered as an integer.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "first_order.language.sentence",
    "statement": "def first_order.language.sentence (L : first_order.language) : Type (max u v)",
    "theorem": "(L : first_order.language) : Type (max u v)",
    "args": "(L : first_order.language)",
    "doc_string": "A sentence is a formula with no free variables.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "prime_multiset.of_nat_list",
    "statement": "def prime_multiset.of_nat_list (l : list ℕ) (h : ∀ (p : ℕ), p ∈ l → nat.prime p) : prime_multiset",
    "theorem": "(l : list ℕ) (h : ∀ (p : ℕ), p ∈ l → nat.prime p) : prime_multiset",
    "args": "(l : list ℕ) (h : ∀ (p : ℕ), p ∈ l → nat.prime p)",
    "doc_string": " Lists can be coerced to multisets; here we have some results about how this interacts with our constructions on multisets.",
    "kind": "def",
    "type": "prime_multiset"
  },
  {
    "name": "filter.ne_bot",
    "statement": "structure filter.ne_bot {α : Type u} (f : filter α) : Prop",
    "theorem": "{α : Type u} (f : filter α) : Prop",
    "args": "{α : Type u} (f : filter α)",
    "doc_string": " A filter is `ne_bot` if it is not equal to `⊥`, or equivalently the empty set does not belong to the filter. Bourbaki include this assumption in the definition of a filter but we prefer to have a `complete_lattice` structure on filter, so we use a typeclass argument in lemmas instead.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordnode.find_gt",
    "statement": "def ordnode.find_gt {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": "O(log n). Get the smallest element in the tree that is `> x`.      find_lt 2 {1, 2, 4} = some 4     find_lt 3 {1, 2, 4} = some 4     find_lt 4 {1, 2, 4} = none",
    "kind": "def",
    "type": "ordnode α → option α"
  },
  {
    "name": "stream.cycle_f",
    "statement": "def stream.cycle_f {α : Type u} : α × list α × α × list α → α",
    "theorem": "{α : Type u} : α × list α × α × list α → α",
    "args": "{α : Type u}",
    "doc_string": "An auxiliary definition for `stream.cycle` corecursive def",
    "kind": "def",
    "type": "α × list α × α × list α → α"
  },
  {
    "name": "uniform_space.separation_setoid",
    "statement": "def uniform_space.separation_setoid (α : Type u) [uniform_space α] : setoid α",
    "theorem": "(α : Type u) [uniform_space α] : setoid α",
    "args": "(α : Type u) [uniform_space α]",
    "doc_string": "The separation relation of a uniform space seen as a setoid.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "nat.exists_strict_anti",
    "statement": "theorem nat.exists_strict_anti (α : Type u) [preorder α] [nonempty α] [no_min_order α] : ∃ (f : ℕ → α), strict_anti f",
    "theorem": "(α : Type u) [preorder α] [nonempty α] [no_min_order α] : ∃ (f : ℕ → α), strict_anti f",
    "args": "(α : Type u) [preorder α] [nonempty α] [no_min_order α]",
    "doc_string": " If `α` is a nonempty preorder with no minimal elements, then there exists a strictly antitone function `ℕ → α`.",
    "kind": "theorem",
    "type": "∃ (f : ℕ → α), strict_anti f"
  },
  {
    "name": "additive",
    "statement": "def additive (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " If `α` carries some multiplicative structure, then `additive α` carries the corresponding additive structure.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "ultrafilter.extend",
    "statement": "def ultrafilter.extend {α : Type u} {γ : Type u_1} [topological_space γ] (f : α → γ) : ultrafilter α → γ",
    "theorem": "{α : Type u} {γ : Type u_1} [topological_space γ] (f : α → γ) : ultrafilter α → γ",
    "args": "{α : Type u} {γ : Type u_1} [topological_space γ] (f : α → γ)",
    "doc_string": "The extension of a function `α → γ` to a function `ultrafilter α → γ`.  When `γ` is a compact Hausdorff space it will be continuous.",
    "kind": "def",
    "type": "ultrafilter α → γ"
  },
  {
    "name": "num.lxor",
    "statement": "def num.lxor  : num → num → num",
    "theorem": " : num → num → num",
    "args": "",
    "doc_string": "Bitwise \"xor\" for `num`.",
    "kind": "def",
    "type": "num → num → num"
  },
  {
    "name": "interactive.loc",
    "statement": "inductive interactive.loc  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A `loc` is either a 'wildcard', which means \"everywhere\", or a list of `option name`s. `none` means `target` and `some n` means `n` in the local context.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "multiplicity",
    "statement": "def multiplicity {α : Type u_1} [comm_monoid α] [decidable_rel has_dvd.dvd] (a b : α) : enat",
    "theorem": "{α : Type u_1} [comm_monoid α] [decidable_rel has_dvd.dvd] (a b : α) : enat",
    "args": "{α : Type u_1} [comm_monoid α] [decidable_rel has_dvd.dvd] (a b : α)",
    "doc_string": "`multiplicity a b` returns the largest natural number `n` such that  `a ^ n ∣ b`, as an `enat` or natural with infinity. If `∀ n, a ^ n ∣ b`,  then it returns `⊤`",
    "kind": "def",
    "type": "enat"
  },
  {
    "name": "is_ring_hom",
    "statement": "structure is_ring_hom {α : Type u} {β : Type v} [ring α] [ring β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [ring α] [ring β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [ring α] [ring β] (f : α → β)",
    "doc_string": "Predicate for ring homomorphisms (deprecated -- use the bundled `ring_hom` version).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordset.mem",
    "statement": "def ordset.mem {α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α) : bool",
    "theorem": "{α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α) : bool",
    "args": "{α : Type u_1} [preorder α] [decidable_rel has_le.le] (x : α) (s : ordset α)",
    "doc_string": "O(log n). Does the set contain the element `x`? That is,  is there an element that is equivalent to `x` in the order?",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "classical.dec_eq",
    "statement": "def classical.dec_eq (α : Sort u_1) : decidable_eq α",
    "theorem": "(α : Sort u_1) : decidable_eq α",
    "args": "(α : Sort u_1)",
    "doc_string": "Any type `α` has decidable equality classically.",
    "kind": "def",
    "type": "decidable_eq α"
  },
  {
    "name": "category_theory.ProjectiveResolution",
    "statement": "structure category_theory.ProjectiveResolution {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C)",
    "doc_string": "A `ProjectiveResolution Z` consists of a bundled `ℕ`-indexed chain complex of projective objects, along with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.  (We don't actually ask here that the chain map is a quasi-iso, just exactness everywhere: that `π` is a quasi-iso is a lemma when the category is abelian. Should we just ask for it here?)  Except in situations where you want to provide a particular projective resolution (for example to compute a derived functor), you will not typically need to use this bundled object, and will instead use * `projective_resolution Z`: the `ℕ`-indexed chain complex   (equipped with `projective` and `exact` instances) * `projective_resolution.π Z`: the chain map from `projective_resolution Z` to   `(single C _ 0).obj Z` (all the components are equipped with `epi` instances,   and when the category is `abelian` we will show `π` is a quasi-iso).",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "completable_top_field",
    "statement": "structure completable_top_field (K : Type u_1) [field K] [uniform_space K] : Prop",
    "theorem": "(K : Type u_1) [field K] [uniform_space K] : Prop",
    "args": "(K : Type u_1) [field K] [uniform_space K]",
    "doc_string": "A topological field is completable if it is separated and the image under the mapping x ↦ x⁻¹ of every Cauchy filter (with respect to the additive uniform structure) which does not have a cluster point at 0 is a Cauchy filter (with respect to the additive uniform structure). This ensures the completion is a field.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "continuous_add_monoid_hom.fst",
    "statement": "def continuous_add_monoid_hom.fst (A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A × B) A",
    "theorem": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A × B) A",
    "args": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by projection onto the first factor.",
    "kind": "def",
    "type": "continuous_add_monoid_hom (A × B) A"
  },
  {
    "name": "wide_subquiver",
    "statement": "def wide_subquiver (V : Type u_1) [quiver V] : Type (max u_1 v)",
    "theorem": "(V : Type u_1) [quiver V] : Type (max u_1 v)",
    "args": "(V : Type u_1) [quiver V]",
    "doc_string": "A wide subquiver `H` of `G` picks out a set `H a b` of arrows from `a` to `b`    for every pair of vertices `a b`.     NB: this does not work for `Prop`-valued quivers. It requires `G : quiver.{v+1} V`.",
    "kind": "def",
    "type": "Type (max u_1 v)"
  },
  {
    "name": "finmap.all",
    "statement": "def finmap.all {α : Type u} {β : α → Type v} (f : Π (x : α), β x → bool) (s : finmap β) : bool",
    "theorem": "{α : Type u} {β : α → Type v} (f : Π (x : α), β x → bool) (s : finmap β) : bool",
    "args": "{α : Type u} {β : α → Type v} (f : Π (x : α), β x → bool) (s : finmap β)",
    "doc_string": "`all f s` returns `tt` iff `f v = tt` for all values `v` in `s`.",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "finset.max",
    "statement": "def finset.max {α : Type u_1} [linear_order α] : finset α → option α",
    "theorem": "{α : Type u_1} [linear_order α] : finset α → option α",
    "args": "{α : Type u_1} [linear_order α]",
    "doc_string": " Let `s` be a finset in a linear order. Then `s.max` is the maximum of `s` if `s` is not empty, and `none` otherwise. It belongs to `option α`. If you want to get an element of `α`, see `s.max'`.",
    "kind": "def",
    "type": "finset α → option α"
  },
  {
    "name": "bilin_form.is_refl",
    "statement": "def bilin_form.is_refl {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M)",
    "doc_string": "The proposition that a bilinear form is reflexive",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "free_group.red.church_rosser",
    "statement": "theorem free_group.red.church_rosser {α : Type u} {L₁ L₂ L₃ : list (α × bool)} : free_group.red L₁ L₂ → free_group.red L₁ L₃ → relation.join free_group.red L₂ L₃",
    "theorem": "{α : Type u} {L₁ L₂ L₃ : list (α × bool)} : free_group.red L₁ L₂ → free_group.red L₁ L₃ → relation.join free_group.red L₂ L₃",
    "args": "{α : Type u} {L₁ L₂ L₃ : list (α × bool)}",
    "doc_string": " **Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces to `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4` respectively. This is also known as Newman's diamond lemma.",
    "kind": "theorem",
    "type": "free_group.red L₁ L₂ → free_group.red L₁ L₃ → relation.join free_group.red L₂ L₃"
  },
  {
    "name": "matrix.diagonal_invertible",
    "statement": "def matrix.diagonal_invertible {n : Type u'} [fintype n] [decidable_eq n] {α : Type u_1} [non_assoc_semiring α] (v : n → α) [invertible v] : invertible (matrix.diagonal v)",
    "theorem": "{n : Type u'} [fintype n] [decidable_eq n] {α : Type u_1} [non_assoc_semiring α] (v : n → α) [invertible v] : invertible (matrix.diagonal v)",
    "args": "{n : Type u'} [fintype n] [decidable_eq n] {α : Type u_1} [non_assoc_semiring α] (v : n → α) [invertible v]",
    "doc_string": "`diagonal v` is invertible if `v` is",
    "kind": "def",
    "type": "invertible (matrix.diagonal v)"
  },
  {
    "name": "is_left_regular.mul",
    "statement": "theorem is_left_regular.mul {R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b)",
    "doc_string": "In a semigroup, the product of left-regular elements is left-regular.",
    "kind": "theorem",
    "type": "is_left_regular (a * b)"
  },
  {
    "name": "affine_subspace.top_coe",
    "statement": "theorem affine_subspace.top_coe (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊤ = set.univ",
    "theorem": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊤ = set.univ",
    "args": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P]",
    "doc_string": "`⊤`, coerced to a set, is the whole set of points.",
    "kind": "theorem",
    "type": "↑⊤ = set.univ"
  },
  {
    "name": "AddCommGroup.has_limits_of_size",
    "statement": "def AddCommGroup.has_limits_of_size  : category_theory.limits.has_limits_of_size AddCommGroup",
    "theorem": " : category_theory.limits.has_limits_of_size AddCommGroup",
    "args": "",
    "doc_string": "The category of additive commutative groups has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size AddCommGroup"
  },
  {
    "name": "denumerable.raise'",
    "statement": "def denumerable.raise'  : list ℕ → ℕ → list ℕ",
    "theorem": " : list ℕ → ℕ → list ℕ",
    "args": "",
    "doc_string": " Outputs the list of partial sums plus one of the input list, that is `raise [a₁, a₂, a₃, ...] n = [n + a₁, n + a₁ + a₂ + 1, n + a₁ + a₂ + a₃ + 2, ...]`. Adding one each time ensures the elements are distinct.",
    "kind": "def",
    "type": "list ℕ → ℕ → list ℕ"
  },
  {
    "name": "irreducible",
    "statement": "structure irreducible {α : Type u_1} [monoid α] (p : α) : Prop",
    "theorem": "{α : Type u_1} [monoid α] (p : α) : Prop",
    "args": "{α : Type u_1} [monoid α] (p : α)",
    "doc_string": " `irreducible p` states that `p` is non-unit and only factors into units.  We explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a monoid allows us to reuse irreducible for associated elements.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.sheaf.canonical_topology",
    "statement": "def category_theory.sheaf.canonical_topology (C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C",
    "theorem": "(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "The `canonical_topology` on a category is the finest (largest) topology for which every representable presheaf is a sheaf.  See <https://stacks.math.columbia.edu/tag/00ZA>",
    "kind": "def",
    "type": "category_theory.grothendieck_topology C"
  },
  {
    "name": "category_theory.projective.projective",
    "statement": "def category_theory.projective.projective (X : Type u) : category_theory.projective X",
    "theorem": "(X : Type u) : category_theory.projective X",
    "args": "(X : Type u)",
    "doc_string": "The axiom of choice says that every type is a projective object in `Type`.",
    "kind": "def",
    "type": "category_theory.projective X"
  },
  {
    "name": "first_order.language.sum",
    "statement": "def first_order.language.sum (L : first_order.language) (L' : first_order.language) : first_order.language",
    "theorem": "(L : first_order.language) (L' : first_order.language) : first_order.language",
    "args": "(L : first_order.language) (L' : first_order.language)",
    "doc_string": "The sum of two languages consists of the disjoint union of their symbols.",
    "kind": "def",
    "type": "first_order.language"
  },
  {
    "name": "algebraic_geometry.PresheafedSpace.const",
    "statement": "def algebraic_geometry.PresheafedSpace.const {C : Type u} [category_theory.category C] (X : Top) (Z : C) : algebraic_geometry.PresheafedSpace C",
    "theorem": "{C : Type u} [category_theory.category C] (X : Top) (Z : C) : algebraic_geometry.PresheafedSpace C",
    "args": "{C : Type u} [category_theory.category C] (X : Top) (Z : C)",
    "doc_string": "The constant presheaf on `X` with value `Z`.",
    "kind": "def",
    "type": "algebraic_geometry.PresheafedSpace C"
  },
  {
    "name": "category_theory.is_separator",
    "statement": "def category_theory.is_separator {C : Type u} [category_theory.category C] (G : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (G : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (G : C)",
    "doc_string": "We say that `G` is a separator if the functor `C(G, -)` is faithful.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "skew_adjoint",
    "statement": "def skew_adjoint (R : Type u_1) [add_comm_group R] [star_add_monoid R] : add_subgroup R",
    "theorem": "(R : Type u_1) [add_comm_group R] [star_add_monoid R] : add_subgroup R",
    "args": "(R : Type u_1) [add_comm_group R] [star_add_monoid R]",
    "doc_string": "The skew-adjoint elements of a star additive group, as an additive subgroup.",
    "kind": "def",
    "type": "add_subgroup R"
  },
  {
    "name": "function.periodic",
    "statement": "def function.periodic {α : Type u_1} {β : Type u_2} [has_add α] (f : α → β) (c : α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_add α] (f : α → β) (c : α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [has_add α] (f : α → β) (c : α)",
    "doc_string": "A function `f` is said to be `periodic` with period `c` if for all `x`, `f (x + c) = f x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.bipartite_above",
    "statement": "def finset.bipartite_above {α : Type u_1} {β : Type u_2} (r : α → β → Prop) (t : finset β) (a : α) [decidable_pred (r a)] : finset β",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop) (t : finset β) (a : α) [decidable_pred (r a)] : finset β",
    "args": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop) (t : finset β) (a : α) [decidable_pred (r a)]",
    "doc_string": "Elements of `t` which are \"above\" `a` according to relation `r`.",
    "kind": "def",
    "type": "finset β"
  },
  {
    "name": "matrix.block_triangular_matrix",
    "statement": "def matrix.block_triangular_matrix {R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) (b : o → ℕ) : Prop",
    "theorem": "{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) (b : o → ℕ) : Prop",
    "args": "{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) (b : o → ℕ)",
    "doc_string": "Let `b` map rows and columns of a square matrix `M` to blocks indexed by `ℕ`s. Then  `block_triangular_matrix M n b` says the matrix is block triangular.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_left_regular_of_left_cancel_semigroup",
    "statement": "theorem is_left_regular_of_left_cancel_semigroup {R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g",
    "theorem": "{R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g",
    "args": "{R : Type u_1} [left_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of a left cancel semigroup are left regular.",
    "kind": "theorem",
    "type": "is_left_regular g"
  },
  {
    "name": "is_topological_fiber_bundle.is_open_map_proj",
    "statement": "theorem is_topological_fiber_bundle.is_open_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj)",
    "doc_string": "The projection from a topological fiber bundle to its base is an open map.",
    "kind": "theorem",
    "type": "is_open_map proj"
  },
  {
    "name": "nat.partrec.code.evaln",
    "statement": "def nat.partrec.code.evaln (k : ℕ) : nat.partrec.code → ℕ → option ℕ",
    "theorem": "(k : ℕ) : nat.partrec.code → ℕ → option ℕ",
    "args": "(k : ℕ)",
    "doc_string": "A modified evaluation for the code which returns an `option ℕ` instead of a `part ℕ`. To avoid undecidability, `evaln` takes a parameter `k` and fails if it encounters a number ≥ k in the course of its execution. Other than this, the semantics are the same as in `nat.partrec.code.eval`.",
    "kind": "def",
    "type": "nat.partrec.code → ℕ → option ℕ"
  },
  {
    "name": "is_closed_map",
    "statement": "def is_closed_map {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β)",
    "doc_string": " A map `f : α → β` is said to be a *closed map*, if the image of any closed `U : set α` is closed in `β`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts.of_has_binary_products",
    "statement": "theorem category_theory.limits.has_binary_biproducts.of_has_binary_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C]",
    "doc_string": "In a preadditive category, if all binary products exist, then all binary biproducts exist.",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_biproducts C"
  },
  {
    "name": "option.mget_or_else",
    "statement": "def option.mget_or_else {α : Type u_1} {m : Type u_1 → Type u_2} [monad m] (x : m (option α)) (y : m α) : m α",
    "theorem": "{α : Type u_1} {m : Type u_1 → Type u_2} [monad m] (x : m (option α)) (y : m α) : m α",
    "args": "{α : Type u_1} {m : Type u_1 → Type u_2} [monad m] (x : m (option α)) (y : m α)",
    "doc_string": "A monadic analogue of `option.get_or_else`.",
    "kind": "def",
    "type": "m α"
  },
  {
    "name": "list.permutations'",
    "statement": "def list.permutations' {α : Type u_1} : list α → list (list α)",
    "theorem": "{α : Type u_1} : list α → list (list α)",
    "args": "{α : Type u_1}",
    "doc_string": " List of all permutations of `l`. This version of `permutations` is less efficient but has simpler definitional equations. The permutations are in a different order, but are equal up to permutation, as shown by `list.permutations_perm_permutations'`.       permutations [1, 2, 3] =        [[1, 2, 3], [2, 1, 3], [2, 3, 1],         [1, 3, 2], [3, 1, 2], [3, 2, 1]]",
    "kind": "def",
    "type": "list α → list (list α)"
  },
  {
    "name": "add_neg'",
    "statement": "theorem add_neg' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "**Alias** of `left.add_neg'`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "wseq.zip_with",
    "statement": "def wseq.zip_with {α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) (s1 : wseq α) (s2 : wseq β) : wseq γ",
    "theorem": "{α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) (s1 : wseq α) (s2 : wseq β) : wseq γ",
    "args": "{α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) (s1 : wseq α) (s2 : wseq β)",
    "doc_string": "Zip a function over two weak sequences",
    "kind": "def",
    "type": "wseq γ"
  },
  {
    "name": "edist_nndist",
    "statement": "theorem edist_nndist {α : Type u} [pseudo_metric_space α] (x y : α) : has_edist.edist x y = ↑(has_nndist.nndist x y)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (x y : α) : has_edist.edist x y = ↑(has_nndist.nndist x y)",
    "args": "{α : Type u} [pseudo_metric_space α] (x y : α)",
    "doc_string": "Express `edist` in terms of `nndist`",
    "kind": "theorem",
    "type": "has_edist.edist x y = ↑(has_nndist.nndist x y)"
  },
  {
    "name": "multiset.Ioi",
    "statement": "def multiset.Ioi {α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : multiset α",
    "theorem": "{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : multiset α",
    "args": "{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α)",
    "doc_string": "The multiset of elements `x` such that `a < x`. Basically `set.Ioi a` as a multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "option.lift_or_get",
    "statement": "def option.lift_or_get {α : Type u_1} (f : α → α → α) : option α → option α → option α",
    "theorem": "{α : Type u_1} (f : α → α → α) : option α → option α → option α",
    "args": "{α : Type u_1} (f : α → α → α)",
    "doc_string": " Two arguments failsafe function. Returns `f a b` if the inputs are `some a` and `some b`, and \"does nothing\" otherwise.",
    "kind": "def",
    "type": "option α → option α → option α"
  },
  {
    "name": "witt_vector.witt_mul",
    "statement": "def witt_vector.witt_mul (p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 2 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 2 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "The polynomials used for defining the multiplication of the ring of Witt vectors.",
    "kind": "def",
    "type": "ℕ → mv_polynomial (fin 2 × ℕ) ℤ"
  },
  {
    "name": "metric_space.replace_uniformity",
    "statement": "def metric_space.replace_uniformity {γ : Type u_1} [U : uniform_space γ] (m : metric_space γ) (H : uniformity γ = uniformity γ) : metric_space γ",
    "theorem": "{γ : Type u_1} [U : uniform_space γ] (m : metric_space γ) (H : uniformity γ = uniformity γ) : metric_space γ",
    "args": "{γ : Type u_1} [U : uniform_space γ] (m : metric_space γ) (H : uniformity γ = uniformity γ)",
    "doc_string": " Build a new metric space from an old one where the bundled uniform structure is provably (but typically non-definitionaly) equal to some given uniform structure. See Note [forgetful inheritance].",
    "kind": "def",
    "type": "metric_space γ"
  },
  {
    "name": "group_filter_basis.inhabited",
    "statement": "def group_filter_basis.inhabited {G : Type u} [group G] : inhabited (group_filter_basis G)",
    "theorem": "{G : Type u} [group G] : inhabited (group_filter_basis G)",
    "args": "{G : Type u} [group G]",
    "doc_string": " The trivial group filter basis consists of `{1}` only. The associated topology is discrete.",
    "kind": "def",
    "type": "inhabited (group_filter_basis G)"
  },
  {
    "name": "category_theory.grothendieck_topology.partial_order",
    "statement": "def category_theory.grothendieck_topology.partial_order {C : Type u} [category_theory.category C] : partial_order (category_theory.grothendieck_topology C)",
    "theorem": "{C : Type u} [category_theory.category C] : partial_order (category_theory.grothendieck_topology C)",
    "args": "{C : Type u} [category_theory.category C]",
    "doc_string": "See <https://stacks.math.columbia.edu/tag/00Z6>",
    "kind": "def",
    "type": "partial_order (category_theory.grothendieck_topology C)"
  },
  {
    "name": "setoid.has_inf",
    "statement": "def setoid.has_inf {α : Type u_1} : has_inf (setoid α)",
    "theorem": "{α : Type u_1} : has_inf (setoid α)",
    "args": "{α : Type u_1}",
    "doc_string": "The infimum of two equivalence relations.",
    "kind": "def",
    "type": "has_inf (setoid α)"
  },
  {
    "name": "Set.subset",
    "statement": "def Set.subset (x y : Set) : Prop",
    "theorem": "(x y : Set) : Prop",
    "args": "(x y : Set)",
    "doc_string": "`x ⊆ y` as ZFC sets means that all members of `x` are members of `y`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.sublists",
    "statement": "def list.sublists {α : Type u_1} (l : list α) : list (list α)",
    "theorem": "{α : Type u_1} (l : list α) : list (list α)",
    "args": "{α : Type u_1} (l : list α)",
    "doc_string": "`sublists l` is the list of all (non-contiguous) sublists of `l`; cf. `sublists'`  for a different ordering.      sublists [1, 2, 3] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]",
    "kind": "def",
    "type": "list (list α)"
  },
  {
    "name": "is_free_group.of",
    "statement": "def is_free_group.of {G : Type u_1} [group G] [is_free_group G] : is_free_group.generators G → G",
    "theorem": "{G : Type u_1} [group G] [is_free_group G] : is_free_group.generators G → G",
    "args": "{G : Type u_1} [group G] [is_free_group G]",
    "doc_string": "The canonical injection of G's generators into G",
    "kind": "def",
    "type": "is_free_group.generators G → G"
  },
  {
    "name": "free_product.rel",
    "statement": "inductive free_product.rel {ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : free_monoid (Σ (i : ι), M i) → free_monoid (Σ (i : ι), M i) → Prop",
    "theorem": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : free_monoid (Σ (i : ι), M i) → free_monoid (Σ (i : ι), M i) → Prop",
    "args": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)]",
    "doc_string": " A relation on the free monoid on alphabet `Σ i, M i`, relating `⟨i, 1⟩` with `1` and `⟨i, x⟩ * ⟨i, y⟩` with `⟨i, x * y⟩`.",
    "kind": "inductive",
    "type": "free_monoid (Σ (i : ι), M i) → free_monoid (Σ (i : ι), M i) → Prop"
  },
  {
    "name": "regular_expression.deriv",
    "statement": "def regular_expression.deriv {α : Type u_1} [dec : decidable_eq α] : regular_expression α → α → regular_expression α",
    "theorem": "{α : Type u_1} [dec : decidable_eq α] : regular_expression α → α → regular_expression α",
    "args": "{α : Type u_1} [dec : decidable_eq α]",
    "doc_string": "`P.deriv a` matches `x` if `P` matches `a :: x`, the Brzozowski derivative of `P` with respect  to `a`",
    "kind": "def",
    "type": "regular_expression α → α → regular_expression α"
  },
  {
    "name": "alexandroff.opens_of_compl",
    "statement": "def alexandroff.opens_of_compl {X : Type u_1} [topological_space X] (s : set X) (h₁ : is_closed s) (h₂ : is_compact s) : topological_space.opens (alexandroff X)",
    "theorem": "{X : Type u_1} [topological_space X] (s : set X) (h₁ : is_closed s) (h₂ : is_compact s) : topological_space.opens (alexandroff X)",
    "args": "{X : Type u_1} [topological_space X] (s : set X) (h₁ : is_closed s) (h₂ : is_compact s)",
    "doc_string": "An open set in `alexandroff X` constructed from a closed compact set in `X`",
    "kind": "def",
    "type": "topological_space.opens (alexandroff X)"
  },
  {
    "name": "group_algebra.average",
    "statement": "def group_algebra.average (k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible ↑(fintype.card G)] : monoid_algebra k G",
    "theorem": "(k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible ↑(fintype.card G)] : monoid_algebra k G",
    "args": "(k : Type u_1) (G : Type u_2) [comm_semiring k] [group G] [fintype G] [invertible ↑(fintype.card G)]",
    "doc_string": "The average of all elements of the group `G`, considered as an element of `monoid_algebra k G`.",
    "kind": "def",
    "type": "monoid_algebra k G"
  },
  {
    "name": "CommGroup.has_limits_of_size",
    "statement": "def CommGroup.has_limits_of_size  : category_theory.limits.has_limits_of_size CommGroup",
    "theorem": " : category_theory.limits.has_limits_of_size CommGroup",
    "args": "",
    "doc_string": "The category of commutative groups has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size CommGroup"
  },
  {
    "name": "pgame.of_lists",
    "statement": "def pgame.of_lists (L R : list pgame) : pgame",
    "theorem": "(L R : list pgame) : pgame",
    "args": "(L R : list pgame)",
    "doc_string": "Construct a pre-game from list of pre-games describing the available moves for Left and Right.",
    "kind": "def",
    "type": "pgame"
  },
  {
    "name": "category_theory.limits.finite_limits_from_equalizers_and_finite_products",
    "statement": "theorem category_theory.limits.finite_limits_from_equalizers_and_finite_products {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C]",
    "doc_string": "Any category with finite products and equalizers has all finite limits.  See <https://stacks.math.columbia.edu/tag/002O>.",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_limits C"
  },
  {
    "name": "simplex_category.mk",
    "statement": "def simplex_category.mk (n : ℕ) : simplex_category",
    "theorem": "(n : ℕ) : simplex_category",
    "args": "(n : ℕ)",
    "doc_string": "Interpet a natural number as an object of the simplex category.",
    "kind": "def",
    "type": "simplex_category"
  },
  {
    "name": "shrinking_lemma.partial_refinement",
    "statement": "structure shrinking_lemma.partial_refinement {ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] (u : ι → set X) (s : set X) : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] (u : ι → set X) (s : set X) : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} {X : Type u_2} [topological_space X] [normal_space X] (u : ι → set X) (s : set X)",
    "doc_string": " Auxiliary definition for the proof of `shrinking_lemma`. A partial refinement of a covering `⋃ i, u i` of a set `s` is a map `v : ι → set X` and a set `carrier : set ι` such that  * `s ⊆ ⋃ i, v i`; * all `v i` are open; * if `i ∈ carrier v`, then `closure (v i) ⊆ u i`; * if `i ∉ carrier`, then `v i = u i`.  This type is equipped with the folowing partial order: `v ≤ v'` if `v.carrier ⊆ v'.carrier` and `v i = v' i` for `i ∈ v.carrier`. We will use Zorn's lemma to prove that this type has a maximal element, then show that the maximal element must have `carrier = univ`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "measure_theory.analytic_set_iff_exists_polish_space_range",
    "statement": "theorem measure_theory.analytic_set_iff_exists_polish_space_range {α : Type u_1} [topological_space α] {s : set α} : measure_theory.analytic_set s ↔ ∃ (β : Type) (h : topological_space β) (h' : polish_space β) (f : β → α), continuous f ∧ set.range f = s",
    "theorem": "{α : Type u_1} [topological_space α] {s : set α} : measure_theory.analytic_set s ↔ ∃ (β : Type) (h : topological_space β) (h' : polish_space β) (f : β → α), continuous f ∧ set.range f = s",
    "args": "{α : Type u_1} [topological_space α] {s : set α}",
    "doc_string": "A set is analytic if and only if it is the continuous image of some Polish space.",
    "kind": "theorem",
    "type": "measure_theory.analytic_set s ↔ ∃ (β : Type) (h : topological_space β) (h' : polish_space β) (f : β → α), continuous f ∧ set.range f = s"
  },
  {
    "name": "generalized_continued_fraction.partial_denominators",
    "statement": "def generalized_continued_fraction.partial_denominators {α : Type u_1} (g : generalized_continued_fraction α) : seq α",
    "theorem": "{α : Type u_1} (g : generalized_continued_fraction α) : seq α",
    "args": "{α : Type u_1} (g : generalized_continued_fraction α)",
    "doc_string": "Returns the sequence of partial denominators `bᵢ` of `g`.",
    "kind": "def",
    "type": "seq α"
  },
  {
    "name": "is_submonoid.power_subset",
    "statement": "theorem is_submonoid.power_subset {M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) : powers a ⊆ s",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) : powers a ⊆ s",
    "args": "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s)",
    "doc_string": "The set of natural number powers of an element of a submonoid is a subset of the submonoid.",
    "kind": "theorem",
    "type": "powers a ⊆ s"
  },
  {
    "name": "list.tprod",
    "statement": "def list.tprod {ι : Type u_1} (α : ι → Type u_2) (l : list ι) : Type (max u_2 u_3)",
    "theorem": "{ι : Type u_1} (α : ι → Type u_2) (l : list ι) : Type (max u_2 u_3)",
    "args": "{ι : Type u_1} (α : ι → Type u_2) (l : list ι)",
    "doc_string": "The product of a family of types over a list.",
    "kind": "def",
    "type": "Type (max u_2 u_3)"
  },
  {
    "name": "has_lt.lt.trans",
    "statement": "theorem has_lt.lt.trans {α : Type u} [preorder α] {a b c : α} : a < b → b < c → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a < b → b < c → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_trans`.",
    "kind": "theorem",
    "type": "a < b → b < c → a < c"
  },
  {
    "name": "is_complemented",
    "statement": "structure is_complemented (α : Type u_1) [lattice α] [bounded_order α] : Prop",
    "theorem": "(α : Type u_1) [lattice α] [bounded_order α] : Prop",
    "args": "(α : Type u_1) [lattice α] [bounded_order α]",
    "doc_string": " A complemented bounded lattice is one where every element has a (not necessarily unique) complement.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "unique_factorization_monoid.normalized_factors",
    "statement": "def unique_factorization_monoid.normalized_factors {α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] [normalization_monoid α] [unique_factorization_monoid α] (a : α) : multiset α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] [normalization_monoid α] [unique_factorization_monoid α] (a : α) : multiset α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [decidable_eq α] [normalization_monoid α] [unique_factorization_monoid α] (a : α)",
    "doc_string": "Noncomputably determines the multiset of prime factors.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "directed",
    "statement": "def directed {α : Type u} {ι : Sort w} (r : α → α → Prop) (f : ι → α) : Prop",
    "theorem": "{α : Type u} {ι : Sort w} (r : α → α → Prop) (f : ι → α) : Prop",
    "args": "{α : Type u} {ι : Sort w} (r : α → α → Prop) (f : ι → α)",
    "doc_string": "A family of elements of α is directed (with respect to a relation `≼` on α)  if there is a member of the family `≼`-above any pair in the family.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pgame.relabelling",
    "statement": "inductive pgame.relabelling  : pgame → pgame → Type (u+1)",
    "theorem": " : pgame → pgame → Type (u+1)",
    "args": "",
    "doc_string": "`relabelling x y` says that `x` and `y` are really the same game, just dressed up differently. Specifically, there is a bijection between the moves for Left in `x` and in `y`, and similarly for Right, and under these bijections we inductively have `relabelling`s for the consequent games.  In ZFC, relabellings would indeed be the same games.",
    "kind": "inductive",
    "type": "pgame → pgame → Type (u+1)"
  },
  {
    "name": "fin.tail",
    "statement": "def fin.tail {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (i : fin n) : α i.succ",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (i : fin n) : α i.succ",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (i : fin n)",
    "doc_string": "The tail of an `n+1` tuple, i.e., its last `n` entries.",
    "kind": "def",
    "type": "α i.succ"
  },
  {
    "name": "model_pi",
    "statement": "def model_pi {ι : Type u_1} (H : ι → Type u_2) : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} (H : ι → Type u_2) : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} (H : ι → Type u_2)",
    "doc_string": " Same thing as `Π i, H i` We introduce it for technical reasons, see note [Manifold type tags].",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "nat.sqrt_aux",
    "statement": "def nat.sqrt_aux  : ℕ → ℕ → ℕ → ℕ",
    "theorem": " : ℕ → ℕ → ℕ → ℕ",
    "args": "",
    "doc_string": " Auxiliary function for `nat.sqrt`. See e.g. <https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2)>",
    "kind": "def",
    "type": "ℕ → ℕ → ℕ → ℕ"
  },
  {
    "name": "module_filter_basis",
    "statement": "structure module_filter_basis (R : Type u_1) (M : Type u_2) [comm_ring R] [topological_space R] [add_comm_group M] [module R M] : Type u_2",
    "theorem": "(R : Type u_1) (M : Type u_2) [comm_ring R] [topological_space R] [add_comm_group M] [module R M] : Type u_2",
    "args": "(R : Type u_1) (M : Type u_2) [comm_ring R] [topological_space R] [add_comm_group M] [module R M]",
    "doc_string": "A `module_filter_basis` on a module is a `filter_basis` satisfying some additional axioms.  Example : if `M` is a topological module then the neighbourhoods of zero are a  `module_filter_basis`. Conversely given a `module_filter_basis` one can define a topology  compatible with the module structure on `M`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "is_transcendence_basis",
    "statement": "def is_transcendence_basis {ι : Type u_1} (R : Type u_3) {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] (x : ι → A) : Prop",
    "theorem": "{ι : Type u_1} (R : Type u_3) {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] (x : ι → A) : Prop",
    "args": "{ι : Type u_1} (R : Type u_3) {A : Type u_5} [comm_ring R] [comm_ring A] [algebra R A] (x : ι → A)",
    "doc_string": "A family is a transcendence basis if it is a maximal algebraically independent subset.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "tactic.norm_fin.match_fin_result",
    "statement": "inductive tactic.norm_fin.match_fin_result  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The expression constructors recognized by the `eval_fin` evaluator. This is used instead of a direct expr pattern match because expr pattern matches generate very large terms under the hood so going via an intermediate inductive type like this is more efficient.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "even.neg",
    "statement": "theorem even.neg {α : Type u_2} [subtraction_monoid α] {a : α} : even a → even (-a)",
    "theorem": "{α : Type u_2} [subtraction_monoid α] {a : α} : even a → even (-a)",
    "args": "{α : Type u_2} [subtraction_monoid α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_square_inv`.",
    "kind": "theorem",
    "type": "even a → even (-a)"
  },
  {
    "name": "Set.powerset",
    "statement": "def Set.powerset  : Set → Set",
    "theorem": " : Set → Set",
    "args": "",
    "doc_string": "The powerset operation, the collection of subsets of a ZFC set",
    "kind": "def",
    "type": "Set → Set"
  },
  {
    "name": "free_group.reduce.idem",
    "statement": "theorem free_group.reduce.idem {α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.reduce (free_group.reduce L) = free_group.reduce L",
    "theorem": "{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.reduce (free_group.reduce L) = free_group.reduce L",
    "args": "{α : Type u} {L : list (α × bool)} [decidable_eq α]",
    "doc_string": " `reduce` is idempotent, i.e. the maximal reduction of the maximal reduction of a word is the maximal reduction of the word.",
    "kind": "theorem",
    "type": "free_group.reduce (free_group.reduce L) = free_group.reduce L"
  },
  {
    "name": "compact_exhaustion",
    "statement": "structure compact_exhaustion (X : Type u_3) [topological_space X] : Type u_3",
    "theorem": "(X : Type u_3) [topological_space X] : Type u_3",
    "args": "(X : Type u_3) [topological_space X]",
    "doc_string": " An [exhaustion by compact sets](https://en.wikipedia.org/wiki/Exhaustion_by_compact_sets) of a topological space is a sequence of compact sets `K n` such that `K n ⊆ interior (K (n + 1))` and `(⋃ n, K n) = univ`.  If `X` is a locally compact sigma compact space, then `compact_exhaustion.choice X` provides a choice of an exhaustion by compact sets. This choice is also available as `(default : compact_exhaustion X)`.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "tactic.ref",
    "statement": "constant tactic.ref (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A `ref` performs the role of a mutable variable within a tactic.",
    "kind": "constant",
    "type": "Type u"
  },
  {
    "name": "tactic.packaged_goal",
    "statement": "def tactic.packaged_goal  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Representation of a proof goal that lends itself to comparison. The following goal:  ```lean l₀ : T, l₁ : T ⊢ ∀ v : T, foo ```  is represented as  ```lean (2, ∀ l₀ l₁ v : T, foo) ```  The number 2 indicates that first the two bound variables of the `∀` are actually local constant. Comparing two such goals with `=` rather than `=ₐ` or `is_def_eq` tells us that proof script should not see the difference between the two.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "pregroupoid",
    "statement": "structure pregroupoid (H : Type u_5) [topological_space H] : Type u_5",
    "theorem": "(H : Type u_5) [topological_space H] : Type u_5",
    "args": "(H : Type u_5) [topological_space H]",
    "doc_string": " To construct a groupoid, one may consider classes of local homeos such that both the function and its inverse have some property. If this property is stable under composition, one gets a groupoid. `pregroupoid` bundles the properties needed for this construction, with the groupoid of smooth functions with smooth inverses as an application.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "wseq.lift_rel",
    "statement": "def wseq.lift_rel {α : Type u} {β : Type v} (R : α → β → Prop) (s : wseq α) (t : wseq β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (R : α → β → Prop) (s : wseq α) (t : wseq β) : Prop",
    "args": "{α : Type u} {β : Type v} (R : α → β → Prop) (s : wseq α) (t : wseq β)",
    "doc_string": "Two weak sequences are `lift_rel R` related if they are either both empty,  or they are both nonempty and the heads are `R` related and the tails are  `lift_rel R` related. (This is a coinductive definition.)",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "set.comm_monoid",
    "statement": "def set.comm_monoid {α : Type u_2} [comm_monoid α] : comm_monoid (set α)",
    "theorem": "{α : Type u_2} [comm_monoid α] : comm_monoid (set α)",
    "args": "{α : Type u_2} [comm_monoid α]",
    "doc_string": "`set α` is a `comm_monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "comm_monoid (set α)"
  },
  {
    "name": "finset.up_shadow",
    "statement": "def finset.up_shadow {α : Type u_1} [decidable_eq α] [fintype α] (𝒜 : finset (finset α)) : finset (finset α)",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] (𝒜 : finset (finset α)) : finset (finset α)",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α] (𝒜 : finset (finset α))",
    "doc_string": " The upper shadow of a set family `𝒜` is all sets we can get by adding one element to any set in `𝒜`, and the (`k` times) iterated upper shadow (`up_shadow^[k]`) is all sets we can get by adding `k` elements from any set in `𝒜`.",
    "kind": "def",
    "type": "finset (finset α)"
  },
  {
    "name": "ordnode.is_subset",
    "statement": "def ordnode.is_subset {α : Type u} [has_le α] [decidable_rel has_le.le] (t₁ t₂ : ordnode α) : bool",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (t₁ t₂ : ordnode α) : bool",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (t₁ t₂ : ordnode α)",
    "doc_string": "O(m+n). Is every element of `t₁` equivalent to some element of `t₂`?      is_subset {1, 4} {1, 2, 4} = tt     is_subset {1, 3} {1, 2, 4} = ff",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "list.mbfind",
    "statement": "def list.mbfind {m : Type → Type v} [monad m] {α : Type} (p : α → m bool) (xs : list α) : m (option α)",
    "theorem": "{m : Type → Type v} [monad m] {α : Type} (p : α → m bool) (xs : list α) : m (option α)",
    "args": "{m : Type → Type v} [monad m] {α : Type} (p : α → m bool) (xs : list α)",
    "doc_string": "A variant of `mbfind'` with more restrictive universe levels.",
    "kind": "def",
    "type": "m (option α)"
  },
  {
    "name": "cross.lie_ring",
    "statement": "def cross.lie_ring {R : Type u_1} [comm_ring R] : lie_ring (fin 3 → R)",
    "theorem": "{R : Type u_1} [comm_ring R] : lie_ring (fin 3 → R)",
    "args": "{R : Type u_1} [comm_ring R]",
    "doc_string": "The three-dimensional vectors together with the operations + and ×₃ form a Lie ring.    Note we do not make this an instance as a conflicting one already exists    via `lie_ring.of_associative_ring`.",
    "kind": "def",
    "type": "lie_ring (fin 3 → R)"
  },
  {
    "name": "measure_theory.egorov.not_convergent_seq",
    "statement": "def measure_theory.egorov.not_convergent_seq {α : Type u_1} {β : Type u_2} {ι : Type u_3} [metric_space β] [preorder ι] (f : ι → α → β) (g : α → β) (n : ℕ) (j : ι) : set α",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} [metric_space β] [preorder ι] (f : ι → α → β) (g : α → β) (n : ℕ) (j : ι) : set α",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} [metric_space β] [preorder ι] (f : ι → α → β) (g : α → β) (n : ℕ) (j : ι)",
    "doc_string": " Given a sequence of functions `f` and a function `g`, `not_convergent_seq f g n j` is the set of elements such that `f k x` and `g x` are separated by at least `1 / (n + 1)` for some `k ≥ j`.  This definition is useful for Egorov's theorem.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "num.nat_size",
    "statement": "def num.nat_size  : num → ℕ",
    "theorem": " : num → ℕ",
    "args": "",
    "doc_string": "The number of bits required to represent a `num`, as a `nat`. `size 0` is defined to be `0`.",
    "kind": "def",
    "type": "num → ℕ"
  },
  {
    "name": "polynomial.trailing_coeff",
    "statement": "def polynomial.trailing_coeff {R : Type u} [semiring R] (p : polynomial R) : R",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : R",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": "`trailing_coeff p` gives the coefficient of the smallest power of `X` in `p`",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "classical.exists_cases",
    "statement": "def classical.exists_cases {α : Sort u_1} {p : α → Prop} {C : Sort u} (H0 : C) (H : Π (a : α), p a → C) : C",
    "theorem": "{α : Sort u_1} {p : α → Prop} {C : Sort u} (H0 : C) (H : Π (a : α), p a → C) : C",
    "args": "{α : Sort u_1} {p : α → Prop} {C : Sort u} (H0 : C) (H : Π (a : α), p a → C)",
    "doc_string": " Construct a function from a default value `H0`, and a function to use if there exists a value satisfying the predicate.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "add_submonoid.localization_map",
    "statement": "structure add_submonoid.localization_map {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (N : Type u_2) [add_comm_monoid N] : Type (max u_1 u_2)",
    "theorem": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (N : Type u_2) [add_comm_monoid N] : Type (max u_1 u_2)",
    "args": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (N : Type u_2) [add_comm_monoid N]",
    "doc_string": " The type of add_monoid homomorphisms satisfying the characteristic predicate: if `f : M →+ N` satisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "witt_vector.select_poly",
    "statement": "def witt_vector.select_poly (P : ℕ → Prop) (n : ℕ) : mv_polynomial ℕ ℤ",
    "theorem": "(P : ℕ → Prop) (n : ℕ) : mv_polynomial ℕ ℤ",
    "args": "(P : ℕ → Prop) (n : ℕ)",
    "doc_string": " The polynomial that witnesses that `witt_vector.select` is a polynomial function. `select_poly n` is `X n` if `P n` holds, and `0` otherwise.",
    "kind": "def",
    "type": "mv_polynomial ℕ ℤ"
  },
  {
    "name": "complete_lattice_of_complete_semilattice_Inf",
    "statement": "def complete_lattice_of_complete_semilattice_Inf (α : Type u_1) [complete_semilattice_Inf α] : complete_lattice α",
    "theorem": "(α : Type u_1) [complete_semilattice_Inf α] : complete_lattice α",
    "args": "(α : Type u_1) [complete_semilattice_Inf α]",
    "doc_string": "Any `complete_semilattice_Inf` is in fact a `complete_lattice`.  Note that this construction has bad definitional properties: see the doc-string on `complete_lattice_of_Inf`.",
    "kind": "def",
    "type": "complete_lattice α"
  },
  {
    "name": "wseq.is_empty",
    "statement": "def wseq.is_empty {α : Type u} (s : wseq α) : computation bool",
    "theorem": "{α : Type u} (s : wseq α) : computation bool",
    "args": "{α : Type u} (s : wseq α)",
    "doc_string": "Returns `tt` if `s` is `nil` and `ff` if `s` has an element",
    "kind": "def",
    "type": "computation bool"
  },
  {
    "name": "Frame",
    "statement": "def Frame  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of frames.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "is_semiring_hom",
    "statement": "structure is_semiring_hom {α : Type u} {β : Type v} [semiring α] [semiring β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [semiring α] [semiring β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [semiring α] [semiring β] (f : α → β)",
    "doc_string": "Predicate for semiring homomorphisms (deprecated -- use the bundled `ring_hom` version).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "add_action.fixed_by",
    "statement": "def add_action.fixed_by (α : Type u) (β : Type v) [add_monoid α] [add_action α β] (g : α) : set β",
    "theorem": "(α : Type u) (β : Type v) [add_monoid α] [add_action α β] (g : α) : set β",
    "args": "(α : Type u) (β : Type v) [add_monoid α] [add_action α β] (g : α)",
    "doc_string": "`fixed_by g` is the subfield of elements fixed by `g`.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "field.nonempty_iff",
    "statement": "theorem field.nonempty_iff {α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α)",
    "theorem": "{α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α)",
    "args": "{α : Type u}",
    "doc_string": "There is a field structure on type if and only if its cardinality is a prime power.",
    "kind": "theorem",
    "type": "nonempty (field α) ↔ is_prime_pow (cardinal.mk α)"
  },
  {
    "name": "set_like.homogeneous_submonoid",
    "statement": "def set_like.homogeneous_submonoid {ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [add_monoid ι] [monoid R] (A : ι → S) [set_like.graded_monoid A] : submonoid R",
    "theorem": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [add_monoid ι] [monoid R] (A : ι → S) [set_like.graded_monoid A] : submonoid R",
    "args": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [add_monoid ι] [monoid R] (A : ι → S) [set_like.graded_monoid A]",
    "doc_string": "When `A` is a `set_like.graded_monoid A`, then the homogeneous elements forms a submonoid.",
    "kind": "def",
    "type": "submonoid R"
  },
  {
    "name": "BoolRing",
    "statement": "def BoolRing  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of Boolean rings.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "witt_vector.nth_remainder",
    "statement": "def witt_vector.nth_remainder (p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ℕ) : (fin (n + 1) → k) → (fin (n + 1) → k) → k",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ℕ) : (fin (n + 1) → k) → (fin (n + 1) → k) → k",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [comm_ring k] [char_p k p] (n : ℕ)",
    "doc_string": "Produces the \"remainder function\" of the `n+1`st coefficient, which does not depend on the `n+1`st coefficients of the inputs.",
    "kind": "def",
    "type": "(fin (n + 1) → k) → (fin (n + 1) → k) → k"
  },
  {
    "name": "add_commute.add_left",
    "statement": "theorem add_commute.add_left {S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c",
    "theorem": "{S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c",
    "args": "{S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c)",
    "doc_string": "If both `a` and `b` commute with `c`, then their product commutes with `c`.",
    "kind": "theorem",
    "type": "add_commute (a + b) c"
  },
  {
    "name": "pfunctor",
    "statement": "structure pfunctor  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "A polynomial functor `P` is given by a type `A` and a family `B` of types over `A`. `P` maps any type `α` to a new type `P.obj α`, which is defined as the sigma type `Σ x, P.B x → α`.  An element of `P.obj α` is a pair `⟨a, f⟩`, where `a` is an element of a type `A` and `f : B a → α`. Think of `a` as the shape of the object and `f` as an index to the relevant elements of `α`.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "even.exists_bit0",
    "statement": "theorem even.exists_bit0 {α : Type u_2} [has_add α] {a : α} : even a → (∃ (b : α), a = bit0 b)",
    "theorem": "{α : Type u_2} [has_add α] {a : α} : even a → (∃ (b : α), a = bit0 b)",
    "args": "{α : Type u_2} [has_add α] {a : α}",
    "doc_string": "**Alias** of the forward direction of even_iff_exists_bit0`.",
    "kind": "theorem",
    "type": "even a → (∃ (b : α), a = bit0 b)"
  },
  {
    "name": "multiset.filter",
    "statement": "def multiset.filter {α : Type u_1} (p : α → Prop) [decidable_pred p] (s : multiset α) : multiset α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : multiset α) : multiset α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : multiset α)",
    "doc_string": "`filter p s` returns the elements in `s` (with the same multiplicities)  which satisfy `p`, and removes the rest.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "surreal.has_add",
    "statement": "def surreal.has_add  : has_add surreal",
    "theorem": " : has_add surreal",
    "args": "",
    "doc_string": " Addition on surreals is inherited from pre-game addition: the sum of `x = {xL | xR}` and `y = {yL | yR}` is `{xL + y, x + yL | xR + y, x + yR}`.",
    "kind": "def",
    "type": "has_add surreal"
  },
  {
    "name": "emetric.Hausdorff_edist_triangle",
    "statement": "theorem emetric.Hausdorff_edist_triangle {α : Type u} [pseudo_emetric_space α] {s t u : set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s t u : set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u",
    "args": "{α : Type u} [pseudo_emetric_space α] {s t u : set α}",
    "doc_string": "The Hausdorff distance satisfies the triangular inequality",
    "kind": "theorem",
    "type": "emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u"
  },
  {
    "name": "topological_fiber_bundle_core.continuous_proj",
    "statement": "theorem topological_fiber_bundle_core.continuous_proj {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : continuous Z.proj",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : continuous Z.proj",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F)",
    "doc_string": "The projection on the base of a topological bundle created from core is continuous",
    "kind": "theorem",
    "type": "continuous Z.proj"
  },
  {
    "name": "ordset.singleton",
    "statement": "def ordset.singleton {α : Type u_1} [preorder α] (a : α) : ordset α",
    "theorem": "{α : Type u_1} [preorder α] (a : α) : ordset α",
    "args": "{α : Type u_1} [preorder α] (a : α)",
    "doc_string": "O(1). Construct a singleton set containing value `a`.",
    "kind": "def",
    "type": "ordset α"
  },
  {
    "name": "multiset.encodable",
    "statement": "def multiset.encodable {α : Type u_1} [encodable α] : encodable (multiset α)",
    "theorem": "{α : Type u_1} [encodable α] : encodable (multiset α)",
    "args": "{α : Type u_1} [encodable α]",
    "doc_string": "If `α` is encodable, then so is `multiset α`.",
    "kind": "def",
    "type": "encodable (multiset α)"
  },
  {
    "name": "quiver.rooted_connected",
    "statement": "structure quiver.rooted_connected {V : Type u} [quiver V] (r : V) : Prop",
    "theorem": "{V : Type u} [quiver V] (r : V) : Prop",
    "args": "{V : Type u} [quiver V] (r : V)",
    "doc_string": "`rooted_connected r` means that there is a path from `r` to any other vertex.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordnode.real_size",
    "statement": "def ordnode.real_size {α : Type u_1} : ordnode α → ℕ",
    "theorem": "{α : Type u_1} : ordnode α → ℕ",
    "args": "{α : Type u_1}",
    "doc_string": "O(n). Computes the actual number of elements in the set, ignoring the cached `size` field.",
    "kind": "def",
    "type": "ordnode α → ℕ"
  },
  {
    "name": "ennreal.cancel_coe",
    "statement": "theorem ennreal.cancel_coe {a : nnreal} : add_le_cancellable ↑a",
    "theorem": "{a : nnreal} : add_le_cancellable ↑a",
    "args": "{a : nnreal}",
    "doc_string": "This lemma has an abbreviated name because it is used frequently.",
    "kind": "theorem",
    "type": "add_le_cancellable ↑a"
  },
  {
    "name": "lie_algebra.subsingleton_of_semisimple_lie_abelian",
    "statement": "theorem lie_algebra.subsingleton_of_semisimple_lie_abelian (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L]",
    "doc_string": "A semisimple Abelian Lie algebra is trivial.",
    "kind": "theorem",
    "type": "subsingleton L"
  },
  {
    "name": "relation.fibration",
    "statement": "def relation.fibration {α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) (f : α → β)",
    "doc_string": "A function `f : α → β` is a fibration between the relation `rα` and `rβ` if for all  `a : α` and `b : β`, whenever `b : β` and `f a` are related by `rβ`, `b` is the image  of some `a' : α` under `f`, and `a'` and `a` are related by `rα`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "with_zero",
    "statement": "def with_zero (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Add an extra element `0` to a type",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "is_noetherian.fintype_basis_index",
    "statement": "def is_noetherian.fintype_basis_index {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} [is_noetherian K V] (b : basis ι K V) : fintype ι",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} [is_noetherian K V] (b : basis ι K V) : fintype ι",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} [is_noetherian K V] (b : basis ι K V)",
    "doc_string": "In a noetherian module over a division ring, all bases are indexed by a finite type.",
    "kind": "def",
    "type": "fintype ι"
  },
  {
    "name": "metric.metric_space.to_emetric_space",
    "statement": "def metric.metric_space.to_emetric_space {γ : Type w} [metric_space γ] : emetric_space γ",
    "theorem": "{γ : Type w} [metric_space γ] : emetric_space γ",
    "args": "{γ : Type w} [metric_space γ]",
    "doc_string": "A metric space induces an emetric space",
    "kind": "def",
    "type": "emetric_space γ"
  },
  {
    "name": "is_left_regular",
    "statement": "def is_left_regular {R : Type u_1} [has_mul R] (c : R) : Prop",
    "theorem": "{R : Type u_1} [has_mul R] (c : R) : Prop",
    "args": "{R : Type u_1} [has_mul R] (c : R)",
    "doc_string": " A left-regular element is an element `c` such that multiplication on the left by `c` is injective.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.decidable_eq_pi_finset",
    "statement": "def finset.decidable_eq_pi_finset {α : Type u_1} {s : finset α} {β : α → Type u_2} [h : Π (a : α), decidable_eq (β a)] : decidable_eq (Π (a : α), a ∈ s → β a)",
    "theorem": "{α : Type u_1} {s : finset α} {β : α → Type u_2} [h : Π (a : α), decidable_eq (β a)] : decidable_eq (Π (a : α), a ∈ s → β a)",
    "args": "{α : Type u_1} {s : finset α} {β : α → Type u_2} [h : Π (a : α), decidable_eq (β a)]",
    "doc_string": "decidable equality for functions whose domain is bounded by finsets",
    "kind": "def",
    "type": "decidable_eq (Π (a : α), a ∈ s → β a)"
  },
  {
    "name": "padic_val_nat.self",
    "statement": "theorem padic_val_nat.self {p : ℕ} (hp : 1 < p) : padic_val_nat p p = 1",
    "theorem": "{p : ℕ} (hp : 1 < p) : padic_val_nat p p = 1",
    "args": "{p : ℕ} (hp : 1 < p)",
    "doc_string": "For `p ≠ 0, p ≠ 1, `padic_val_rat p p` is 1.",
    "kind": "theorem",
    "type": "padic_val_nat p p = 1"
  },
  {
    "name": "category_theory.is_filtered.max",
    "statement": "def category_theory.is_filtered.max {C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j j' : C) : C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j j' : C) : C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j j' : C)",
    "doc_string": "`max j j'` is an arbitrary choice of object to the right of both `j` and `j'`, whose existence is ensured by `is_filtered`.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "is_right_regular.subsingleton",
    "statement": "theorem is_right_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R] (h : is_right_regular 0)",
    "doc_string": "The element `0` is right-regular if and only if `R` is trivial.",
    "kind": "theorem",
    "type": "subsingleton R"
  },
  {
    "name": "filter.eventually_le",
    "statement": "def filter.eventually_le {α : Type u} {β : Type v} [has_le β] (l : filter α) (f g : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [has_le β] (l : filter α) (f g : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [has_le β] (l : filter α) (f g : α → β)",
    "doc_string": "A function `f` is eventually less than or equal to a function `g` at a filter `l`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "multiset.powerset_len_aux",
    "statement": "def multiset.powerset_len_aux {α : Type u_1} (n : ℕ) (l : list α) : list (multiset α)",
    "theorem": "{α : Type u_1} (n : ℕ) (l : list α) : list (multiset α)",
    "args": "{α : Type u_1} (n : ℕ) (l : list α)",
    "doc_string": " Helper function for `powerset_len`. Given a list `l`, `powerset_len_aux n l` is the list of sublists of length `n`, as multisets.",
    "kind": "def",
    "type": "list (multiset α)"
  },
  {
    "name": "AddMon.of",
    "statement": "def AddMon.of (M : Type u) [add_monoid M] : AddMon",
    "theorem": "(M : Type u) [add_monoid M] : AddMon",
    "args": "(M : Type u) [add_monoid M]",
    "doc_string": "Construct a bundled `Mon` from the underlying type and typeclass.",
    "kind": "def",
    "type": "AddMon"
  },
  {
    "name": "add_submonoid.pointwise_mul_action",
    "statement": "def add_submonoid.pointwise_mul_action {α : Type u_1} {A : Type u_5} [add_monoid A] [monoid α] [distrib_mul_action α A] : mul_action α (add_submonoid A)",
    "theorem": "{α : Type u_1} {A : Type u_5} [add_monoid A] [monoid α] [distrib_mul_action α A] : mul_action α (add_submonoid A)",
    "args": "{α : Type u_1} {A : Type u_5} [add_monoid A] [monoid α] [distrib_mul_action α A]",
    "doc_string": " The action on an additive submonoid corresponding to applying the action to every element.  This is available as an instance in the `pointwise` locale.",
    "kind": "def",
    "type": "mul_action α (add_submonoid A)"
  },
  {
    "name": "turing.partrec_to_TM2.K'",
    "statement": "inductive turing.partrec_to_TM2.K'  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The four stacks used by the program. `main` is used to store the input value in `tr_normal` mode and the output value in `Λ'.ret` mode, while `stack` is used to keep all the data for the continuations. `rev` is used to store reversed lists when transferring values between stacks, and `aux` is only used once in `cons₁`. See the section documentation.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "ordnode.of_asc_list_aux₂",
    "statement": "def ordnode.of_asc_list_aux₂ {α : Type u} : list α → ordnode α → ℕ → ordnode α",
    "theorem": "{α : Type u} : list α → ordnode α → ℕ → ordnode α",
    "args": "{α : Type u}",
    "doc_string": "Auxiliary definition for `of_asc_list`.",
    "kind": "def",
    "type": "list α → ordnode α → ℕ → ordnode α"
  },
  {
    "name": "closure_operator",
    "statement": "structure closure_operator (α : Type u_1) [preorder α] : Type u_1",
    "theorem": "(α : Type u_1) [preorder α] : Type u_1",
    "args": "(α : Type u_1) [preorder α]",
    "doc_string": " A closure operator on the preorder `α` is a monotone function which is extensive (every `x` is less than its closure) and idempotent.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "free_add_magma.lift_aux",
    "statement": "def free_add_magma.lift_aux {α : Type u} {β : Type v} [has_add β] (f : α → β) : free_add_magma α → β",
    "theorem": "{α : Type u} {β : Type v} [has_add β] (f : α → β) : free_add_magma α → β",
    "args": "{α : Type u} {β : Type v} [has_add β] (f : α → β)",
    "doc_string": " Lifts a function `α → β` to an additive magma homomorphism `free_add_magma α → β` given an additive magma `β`.",
    "kind": "def",
    "type": "free_add_magma α → β"
  },
  {
    "name": "uniform_group",
    "statement": "structure uniform_group (α : Type u_3) [uniform_space α] [group α] : Prop",
    "theorem": "(α : Type u_3) [uniform_space α] [group α] : Prop",
    "args": "(α : Type u_3) [uniform_space α] [group α]",
    "doc_string": "A uniform group is a group in which multiplication and inversion are uniformly continuous.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "right_coset",
    "statement": "def right_coset {α : Type u_1} [has_mul α] (s : set α) (a : α) : set α",
    "theorem": "{α : Type u_1} [has_mul α] (s : set α) (a : α) : set α",
    "args": "{α : Type u_1} [has_mul α] (s : set α) (a : α)",
    "doc_string": "The right coset `s * a` for an element `a : α` and a subset `s : set α`",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "zero_hom.id",
    "statement": "def zero_hom.id (M : Type u_1) [has_zero M] : zero_hom M M",
    "theorem": "(M : Type u_1) [has_zero M] : zero_hom M M",
    "args": "(M : Type u_1) [has_zero M]",
    "doc_string": "The identity map from an type with zero to itself.",
    "kind": "def",
    "type": "zero_hom M M"
  },
  {
    "name": "intermediate_field",
    "statement": "structure intermediate_field (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : Type u_2",
    "theorem": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] : Type u_2",
    "args": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L]",
    "doc_string": " `S : intermediate_field K L` is a subset of `L` such that there is a field tower `L / S / K`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "seq.corec",
    "statement": "def seq.corec {α : Type u} {β : Type v} (f : β → option (α × β)) (b : β) : seq α",
    "theorem": "{α : Type u} {β : Type v} (f : β → option (α × β)) (b : β) : seq α",
    "args": "{α : Type u} {β : Type v} (f : β → option (α × β)) (b : β)",
    "doc_string": "Corecursor for `seq α` as a coinductive type. Iterates `f` to produce new elements  of the sequence until `none` is obtained.",
    "kind": "def",
    "type": "seq α"
  },
  {
    "name": "simple_graph.is_clique",
    "statement": "def simple_graph.is_clique {α : Type u_1} (G : simple_graph α) (s : set α) : Prop",
    "theorem": "{α : Type u_1} (G : simple_graph α) (s : set α) : Prop",
    "args": "{α : Type u_1} (G : simple_graph α) (s : set α)",
    "doc_string": "A clique in a graph is a set of vertices that are pairwise adjacent.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_closed",
    "statement": "structure is_closed {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "A set is closed if its complement is open",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "zmod",
    "statement": "def zmod  : ℕ → Type",
    "theorem": " : ℕ → Type",
    "args": "",
    "doc_string": "The integers modulo `n : ℕ`.",
    "kind": "def",
    "type": "ℕ → Type"
  },
  {
    "name": "add_monoid_algebra.has_one",
    "statement": "def add_monoid_algebra.has_one {k : Type u₁} {G : Type u₂} [semiring k] [has_zero G] : has_one (add_monoid_algebra k G)",
    "theorem": "{k : Type u₁} {G : Type u₂} [semiring k] [has_zero G] : has_one (add_monoid_algebra k G)",
    "args": "{k : Type u₁} {G : Type u₂} [semiring k] [has_zero G]",
    "doc_string": "The unit of the multiplication is `single 1 1`, i.e. the function  that is `1` at `0` and zero elsewhere.",
    "kind": "def",
    "type": "has_one (add_monoid_algebra k G)"
  },
  {
    "name": "subsemiring.gi",
    "statement": "def subsemiring.gi (R : Type u) [non_assoc_semiring R] : galois_insertion subsemiring.closure coe",
    "theorem": "(R : Type u) [non_assoc_semiring R] : galois_insertion subsemiring.closure coe",
    "args": "(R : Type u) [non_assoc_semiring R]",
    "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
    "kind": "def",
    "type": "galois_insertion subsemiring.closure coe"
  },
  {
    "name": "charted_space_self_atlas",
    "statement": "theorem charted_space_self_atlas {H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e ∈ charted_space.atlas H H ↔ e = local_homeomorph.refl H",
    "theorem": "{H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e ∈ charted_space.atlas H H ↔ e = local_homeomorph.refl H",
    "args": "{H : Type u_1} [topological_space H] {e : local_homeomorph H H}",
    "doc_string": " In the trivial charted_space structure of a space modelled over itself through the identity, the atlas members are just the identity",
    "kind": "theorem",
    "type": "e ∈ charted_space.atlas H H ↔ e = local_homeomorph.refl H"
  },
  {
    "name": "typevec.last",
    "statement": "def typevec.last {n : ℕ} (α : typevec (n + 1)) : Type u",
    "theorem": "{n : ℕ} (α : typevec (n + 1)) : Type u",
    "args": "{n : ℕ} (α : typevec (n + 1))",
    "doc_string": "take the last value of a `(n+1)-length` vector",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "category_theory.limits.has_finite_wide_pullbacks_of_has_finite_limits",
    "statement": "theorem category_theory.limits.has_finite_wide_pullbacks_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C]",
    "doc_string": "Finite wide pullbacks are finite limits, so if `C` has all finite limits, it also has finite wide pullbacks",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_wide_pullbacks C"
  },
  {
    "name": "encodable.fintype_arrow_of_encodable",
    "statement": "def encodable.fintype_arrow_of_encodable {α : Type u_1} {β : Type u_2} [encodable α] [fintype α] [encodable β] : encodable (α → β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [encodable α] [fintype α] [encodable β] : encodable (α → β)",
    "args": "{α : Type u_1} {β : Type u_2} [encodable α] [fintype α] [encodable β]",
    "doc_string": "If `α` and `β` are encodable and `α` is a fintype, then `α → β` is encodable as well.",
    "kind": "def",
    "type": "encodable (α → β)"
  },
  {
    "name": "finset.nat.mem_antidiagonal",
    "statement": "theorem finset.nat.mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ finset.nat.antidiagonal n ↔ x.fst + x.snd = n",
    "theorem": "{n : ℕ} {x : ℕ × ℕ} : x ∈ finset.nat.antidiagonal n ↔ x.fst + x.snd = n",
    "args": "{n : ℕ} {x : ℕ × ℕ}",
    "doc_string": "A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`.",
    "kind": "theorem",
    "type": "x ∈ finset.nat.antidiagonal n ↔ x.fst + x.snd = n"
  },
  {
    "name": "list.indexes_of",
    "statement": "def list.indexes_of {α : Type u_1} [decidable_eq α] (a : α) : list α → list ℕ",
    "theorem": "{α : Type u_1} [decidable_eq α] (a : α) : list α → list ℕ",
    "args": "{α : Type u_1} [decidable_eq α] (a : α)",
    "doc_string": " `indexes_of a l` is the list of all indexes of `a` in `l`. For example: ```lean indexes_of a [a, b, a, a] = [0, 2, 3] ```",
    "kind": "def",
    "type": "list α → list ℕ"
  },
  {
    "name": "rel.inv",
    "statement": "def rel.inv {α : Type u_1} {β : Type u_2} (r : rel α β) : rel β α",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : rel α β) : rel β α",
    "args": "{α : Type u_1} {β : Type u_2} (r : rel α β)",
    "doc_string": "The inverse relation : `r.inv x y ↔ r y x`. Note that this is *not* a groupoid inverse.",
    "kind": "def",
    "type": "rel β α"
  },
  {
    "name": "partial_order.lift",
    "statement": "def partial_order.lift {α : Type u_1} {β : Type u_2} [partial_order β] (f : α → β) (inj : function.injective f) : partial_order α",
    "theorem": "{α : Type u_1} {β : Type u_2} [partial_order β] (f : α → β) (inj : function.injective f) : partial_order α",
    "args": "{α : Type u_1} {β : Type u_2} [partial_order β] (f : α → β) (inj : function.injective f)",
    "doc_string": " Transfer a `partial_order` on `β` to a `partial_order` on `α` using an injective function `f : α → β`. See note [reducible non-instances].",
    "kind": "def",
    "type": "partial_order α"
  },
  {
    "name": "ordinal.pred",
    "statement": "def ordinal.pred (o : ordinal) : ordinal",
    "theorem": "(o : ordinal) : ordinal",
    "args": "(o : ordinal)",
    "doc_string": "The ordinal predecessor of `o` is `o'` if `o = succ o'`,  and `o` otherwise.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "tendsto_uniformly",
    "statement": "def tendsto_uniformly {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (f : α → β) (p : filter ι) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (f : α → β) (p : filter ι) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (f : α → β) (p : filter ι)",
    "doc_string": " A sequence of functions `Fₙ` converges uniformly to a limiting function `f` with respect to a filter `p` if, for any entourage of the diagonal `u`, one has `p`-eventually `(f x, Fₙ x) ∈ u` for all `x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.embedding",
    "statement": "structure function.embedding (α : Sort u_1) (β : Sort u_2) : Sort (max 1 (imax u_1 u_2))",
    "theorem": "(α : Sort u_1) (β : Sort u_2) : Sort (max 1 (imax u_1 u_2))",
    "args": "(α : Sort u_1) (β : Sort u_2)",
    "doc_string": "`α ↪ β` is a bundled injective function.",
    "kind": "structure",
    "type": "Sort (max 1 (imax u_1 u_2))"
  },
  {
    "name": "cInf_singleton",
    "statement": "theorem cInf_singleton {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Inf.Inf {a} = a",
    "theorem": "{α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Inf.Inf {a} = a",
    "args": "{α : Type u_1} [conditionally_complete_lattice α] (a : α)",
    "doc_string": "The infimum of a singleton is the element of the singleton",
    "kind": "theorem",
    "type": "has_Inf.Inf {a} = a"
  },
  {
    "name": "Top.presheaf.is_sheaf_preserves_limit_pairwise_intersections",
    "statement": "def Top.presheaf.is_sheaf_preserves_limit_pairwise_intersections {X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop",
    "theorem": "{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X) : Prop",
    "args": "{X : Top} {C : Type u} [category_theory.category C] (F : Top.presheaf C X)",
    "doc_string": "An alternative formulation of the sheaf condition (which we prove equivalent to the usual one below as `is_sheaf_iff_is_sheaf_preserves_limit_pairwise_intersections`).  A presheaf is a sheaf if `F` preserves the limit of `pairwise.diagram U`. (Recall `pairwise.diagram U` is the diagram consisting of the pairwise intersections `U i ⊓ U j` mapping into the open sets `U i`. This diagram has limit `supr U`.)",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.non_preadditive_abelian.abelian",
    "statement": "def category_theory.non_preadditive_abelian.abelian (C : Type u) [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.abelian C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.non_preadditive_abelian C] : category_theory.abelian C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.non_preadditive_abelian C]",
    "doc_string": "Every non_preadditive_abelian category can be promoted to an abelian category.",
    "kind": "def",
    "type": "category_theory.abelian C"
  },
  {
    "name": "ordnode.union",
    "statement": "def ordnode.union {α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le]",
    "doc_string": " O(m * log(|m ∪ n| + 1)), m ≤ n. The union of two sets, preferring members of   `t₁` over those of `t₂` when equivalent elements are encountered.      union {1, 2} {2, 3} = {1, 2, 3}     union {1, 3} {2} = {1, 2, 3}  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      union {(1, 1)} {(0, 1), (1, 2)} = {(0, 1), (1, 1)}",
    "kind": "def",
    "type": "ordnode α → ordnode α → ordnode α"
  },
  {
    "name": "polynomial.update",
    "statement": "def polynomial.update {R : Type u} [semiring R] (p : polynomial R) (n : ℕ) (a : R) : polynomial R",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) (n : ℕ) (a : R) : polynomial R",
    "args": "{R : Type u} [semiring R] (p : polynomial R) (n : ℕ) (a : R)",
    "doc_string": " Replace the coefficient of a `p : polynomial p` at a given degree `n : ℕ` by a given value `a : R`. If `a = 0`, this is equal to `p.erase n` If `p.nat_degree < n` and `a ≠ 0`, this increases the degree to `n`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "spectrum.zero_eq",
    "statement": "theorem spectrum.zero_eq {𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [nontrivial A] : spectrum 𝕜 0 = {0}",
    "theorem": "{𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [nontrivial A] : spectrum 𝕜 0 = {0}",
    "args": "{𝕜 : Type u} {A : Type v} [field 𝕜] [ring A] [algebra 𝕜 A] [nontrivial A]",
    "doc_string": "Without the assumption `nontrivial A`, then `0 : A` would be invertible.",
    "kind": "theorem",
    "type": "spectrum 𝕜 0 = {0}"
  },
  {
    "name": "is_regular_iff_subsingleton",
    "statement": "theorem is_regular_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_regular 0 ↔ subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : is_regular 0 ↔ subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "The element `0` is regular if and only if `R` is trivial.",
    "kind": "theorem",
    "type": "is_regular 0 ↔ subsingleton R"
  },
  {
    "name": "is_countably_spanning",
    "statement": "def is_countably_spanning {α : Type u_1} (C : set (set α)) : Prop",
    "theorem": "{α : Type u_1} (C : set (set α)) : Prop",
    "args": "{α : Type u_1} (C : set (set α))",
    "doc_string": "We say that a collection of sets is countably spanning if a countable subset spans the  whole type. This is a useful condition in various parts of measure theory. For example, it is  a needed condition to show that the product of two collections generate the product sigma algebra,  see `generate_from_prod_eq`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "has_measurable_sub₂",
    "statement": "structure has_measurable_sub₂ (G : Type u_1) [measurable_space G] [has_sub G] : Prop",
    "theorem": "(G : Type u_1) [measurable_space G] [has_sub G] : Prop",
    "args": "(G : Type u_1) [measurable_space G] [has_sub G]",
    "doc_string": " We say that a type `has_measurable_sub` if `uncurry (-)` is a measurable functions. For a typeclass assuming measurability of `((-) c)` and `(- c)` see `has_measurable_sub`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "witt_vector.comm_ring",
    "statement": "def witt_vector.comm_ring (p : ℕ) (R : Type u_1) [hp : fact (nat.prime p)] [comm_ring R] : comm_ring (witt_vector p R)",
    "theorem": "(p : ℕ) (R : Type u_1) [hp : fact (nat.prime p)] [comm_ring R] : comm_ring (witt_vector p R)",
    "args": "(p : ℕ) (R : Type u_1) [hp : fact (nat.prime p)] [comm_ring R]",
    "doc_string": "The commutative ring structure on `𝕎 R`.",
    "kind": "def",
    "type": "comm_ring (witt_vector p R)"
  },
  {
    "name": "monovary_on",
    "statement": "def monovary_on {ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) (s : set ι) : Prop",
    "theorem": "{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) (s : set ι) : Prop",
    "args": "{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) (s : set ι)",
    "doc_string": "`f` monovaries with `g` on `s` if `g i < g j` implies `f i ≤ f j` for all `i, j ∈ s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_localization.unique_of_zero_mem",
    "statement": "def is_localization.unique_of_zero_mem {R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (h : 0 ∈ M) : unique S",
    "theorem": "{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (h : 0 ∈ M) : unique S",
    "args": "{R : Type u_1} [comm_semiring R] {M : submonoid R} {S : Type u_2} [comm_semiring S] [algebra R S] [is_localization M S] (h : 0 ∈ M)",
    "doc_string": "Localizing at a submonoid with 0 inside it leads to the trivial ring.",
    "kind": "def",
    "type": "unique S"
  },
  {
    "name": "combinatorics.line.color_focused",
    "statement": "structure combinatorics.line.color_focused {α : Type u_1} {ι : Type u_2} {κ : Type u_3} (C : (ι → option α) → κ) : Type (max u_1 u_2 u_3)",
    "theorem": "{α : Type u_1} {ι : Type u_2} {κ : Type u_3} (C : (ι → option α) → κ) : Type (max u_1 u_2 u_3)",
    "args": "{α : Type u_1} {ι : Type u_2} {κ : Type u_3} (C : (ι → option α) → κ)",
    "doc_string": " The type of collections of lines such that - each line is only one color except possibly at its endpoint - the lines all have the same endpoint - the colors of the lines are distinct. Used in the proof `exists_mono_in_high_dimension`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "list.is_suffix",
    "statement": "def list.is_suffix {α : Type u_1} (l₁ l₂ : list α) : Prop",
    "theorem": "{α : Type u_1} (l₁ l₂ : list α) : Prop",
    "args": "{α : Type u_1} (l₁ l₂ : list α)",
    "doc_string": "`is_suffix l₁ l₂`, or `l₁ <:+ l₂`, means that `l₁` is a suffix of `l₂`,  that is, `l₂` has the form `t ++ l₁` for some `t`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "valued",
    "statement": "structure valued (R : Type u) [ring R] (Γ₀ : out_param (Type v)) [linear_ordered_comm_group_with_zero Γ₀] : Type (max u v)",
    "theorem": "(R : Type u) [ring R] (Γ₀ : out_param (Type v)) [linear_ordered_comm_group_with_zero Γ₀] : Type (max u v)",
    "args": "(R : Type u) [ring R] (Γ₀ : out_param (Type v)) [linear_ordered_comm_group_with_zero Γ₀]",
    "doc_string": " A valued ring is a ring that comes equipped with a distinguished valuation. The class `valued` is designed for the situation that there is a canonical valuation on the ring.  TODO: show that there always exists an equivalent valuation taking values in a type belonging to the same universe as the ring.  See Note [forgetful inheritance] for why we extend `uniform_space`, `uniform_add_group`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "complex_shape.symm",
    "statement": "def complex_shape.symm {ι : Type u_1} (c : complex_shape ι) : complex_shape ι",
    "theorem": "{ι : Type u_1} (c : complex_shape ι) : complex_shape ι",
    "args": "{ι : Type u_1} (c : complex_shape ι)",
    "doc_string": "The reverse of a `complex_shape`.",
    "kind": "def",
    "type": "complex_shape ι"
  },
  {
    "name": "add_comm_group.int_module.unique",
    "statement": "def add_comm_group.int_module.unique {M : Type u_5} [add_comm_group M] : unique (module ℤ M)",
    "theorem": "{M : Type u_5} [add_comm_group M] : unique (module ℤ M)",
    "args": "{M : Type u_5} [add_comm_group M]",
    "doc_string": " All `ℤ`-module structures are equal. Not an instance since in mathlib all `add_comm_group` should normally have exactly one `ℤ`-module structure by design.",
    "kind": "def",
    "type": "unique (module ℤ M)"
  },
  {
    "name": "category_theory.limits.has_finite_products_of_has_products",
    "statement": "theorem category_theory.limits.has_finite_products_of_has_products (C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C]",
    "doc_string": "If a category has all products then in particular it has finite products.",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_products C"
  },
  {
    "name": "probability_theory.cond_count",
    "statement": "def probability_theory.cond_count {α : Type u_1} [measurable_space α] (s : set α) : measure_theory.measure α",
    "theorem": "{α : Type u_1} [measurable_space α] (s : set α) : measure_theory.measure α",
    "args": "{α : Type u_1} [measurable_space α] (s : set α)",
    "doc_string": " Given a set `s`, `cond_count s` is the counting measure conditioned on `s`. In particular, `cond_count s t` is the proportion of `s` that is contained in `t`.  This is a probability measure when `s` is finite and nonempty and is given by `probability_theory.cond_count_is_probability_measure`.",
    "kind": "def",
    "type": "measure_theory.measure α"
  },
  {
    "name": "filter.has_sub",
    "statement": "def filter.has_sub {α : Type u_2} [has_sub α] : has_sub (filter α)",
    "theorem": "{α : Type u_2} [has_sub α] : has_sub (filter α)",
    "args": "{α : Type u_2} [has_sub α]",
    "doc_string": "The filter `f - g` is generated by `{s - t | s ∈ f, t ∈ g}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_sub (filter α)"
  },
  {
    "name": "ordered_comm_group.le_of_mul_le_mul_left",
    "statement": "theorem ordered_comm_group.le_of_mul_le_mul_left {α : Type u_1} [has_mul α] [has_le α] [contravariant_class α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c) : b ≤ c",
    "theorem": "{α : Type u_1} [has_mul α] [has_le α] [contravariant_class α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c) : b ≤ c",
    "args": "{α : Type u_1} [has_mul α] [has_le α] [contravariant_class α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c)",
    "doc_string": "**Alias** of le_of_mul_le_mul_left'`.",
    "kind": "theorem",
    "type": "b ≤ c"
  },
  {
    "name": "fermat_42",
    "statement": "def fermat_42 (a b c : ℤ) : Prop",
    "theorem": "(a b c : ℤ) : Prop",
    "args": "(a b c : ℤ)",
    "doc_string": " Shorthand for three non-zero integers `a`, `b`, and `c` satisfying `a ^ 4 + b ^ 4 = c ^ 2`. We will show that no integers satisfy this equation. Clearly Fermat's Last theorem for n = 4 follows.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "environment.intro_rule",
    "statement": "structure environment.intro_rule  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "One introduction rule in an inductive declaration",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "hyperreal",
    "statement": "def hyperreal  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Hyperreal numbers on the ultrafilter extending the cofinite filter",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "metric.diam_empty",
    "statement": "theorem metric.diam_empty {α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0",
    "args": "{α : Type u} [pseudo_metric_space α]",
    "doc_string": "The empty set has zero diameter",
    "kind": "theorem",
    "type": "metric.diam ∅ = 0"
  },
  {
    "name": "is_add_left_regular",
    "statement": "def is_add_left_regular {R : Type u_1} [has_add R] (c : R) : Prop",
    "theorem": "{R : Type u_1} [has_add R] (c : R) : Prop",
    "args": "{R : Type u_1} [has_add R] (c : R)",
    "doc_string": "An add-left-regular element is an element `c` such that addition on the left by `c` is injective. -/",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "dense_range.separable_space",
    "statement": "theorem dense_range.separable_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space.separable_space α] [topological_space β] {f : α → β} (h : dense_range f) (h' : continuous f) : topological_space.separable_space β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space.separable_space α] [topological_space β] {f : α → β} (h : dense_range f) (h' : continuous f) : topological_space.separable_space β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space.separable_space α] [topological_space β] {f : α → β} (h : dense_range f) (h' : continuous f)",
    "doc_string": " If `α` is a separable space and `f : α → β` is a continuous map with dense range, then `β` is a separable space as well. E.g., the completion of a separable uniform space is separable.",
    "kind": "theorem",
    "type": "topological_space.separable_space β"
  },
  {
    "name": "topological_add_group.continuous_conj_sum",
    "statement": "theorem topological_add_group.continuous_conj_sum {G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (λ (g : G × G), g.fst + g.snd + -g.fst)",
    "theorem": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (λ (g : G × G), g.fst + g.snd + -g.fst)",
    "args": "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G]",
    "doc_string": "Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous.",
    "kind": "theorem",
    "type": "continuous (λ (g : G × G), g.fst + g.snd + -g.fst)"
  },
  {
    "name": "add_monoid.has_measurable_smul_nat₂",
    "statement": "def add_monoid.has_measurable_smul_nat₂ (M : Type u_1) [add_monoid M] [measurable_space M] [has_measurable_add₂ M] : has_measurable_smul₂ ℕ M",
    "theorem": "(M : Type u_1) [add_monoid M] [measurable_space M] [has_measurable_add₂ M] : has_measurable_smul₂ ℕ M",
    "args": "(M : Type u_1) [add_monoid M] [measurable_space M] [has_measurable_add₂ M]",
    "doc_string": "`add_monoid.has_scalar_nat` is measurable.",
    "kind": "def",
    "type": "has_measurable_smul₂ ℕ M"
  },
  {
    "name": "seq.terminated_at",
    "statement": "def seq.terminated_at {α : Type u} (s : seq α) (n : ℕ) : Prop",
    "theorem": "{α : Type u} (s : seq α) (n : ℕ) : Prop",
    "args": "{α : Type u} (s : seq α) (n : ℕ)",
    "doc_string": "A sequence has terminated at position `n` if the value at position `n` equals `none`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "parser.numeral.char",
    "statement": "def parser.numeral.char (α : Type) [has_zero α] [has_one α] [has_add α] (fromc toc : char) : parser α",
    "theorem": "(α : Type) [has_zero α] [has_one α] [has_add α] (fromc toc : char) : parser α",
    "args": "(α : Type) [has_zero α] [has_one α] [has_add α] (fromc toc : char)",
    "doc_string": "Parse a character as a numeral while casting it to target type `α`, The parser ensures that the character parsed in is within the bounds set by `fromc` and `toc`, and subtracts the value of `fromc` from the parsed in character.",
    "kind": "def",
    "type": "parser α"
  },
  {
    "name": "subfield.add_mem",
    "statement": "theorem subfield.add_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x + y ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x + y ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K) {x y : K}",
    "doc_string": "A subfield is closed under addition.",
    "kind": "theorem",
    "type": "x ∈ s → y ∈ s → x + y ∈ s"
  },
  {
    "name": "continuous_add_monoid_hom.inr",
    "statement": "def continuous_add_monoid_hom.inr (A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom B (A × B)",
    "theorem": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom B (A × B)",
    "args": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by inclusion of the second factor.",
    "kind": "def",
    "type": "continuous_add_monoid_hom B (A × B)"
  },
  {
    "name": "zmod.val_min_abs",
    "statement": "def zmod.val_min_abs {n : ℕ} : zmod n → ℤ",
    "theorem": "{n : ℕ} : zmod n → ℤ",
    "args": "{n : ℕ}",
    "doc_string": "`val_min_abs x` returns the integer in the same equivalence class as `x` that is closest to `0`,  The result will be in the interval `(-n/2, n/2]`.",
    "kind": "def",
    "type": "zmod n → ℤ"
  },
  {
    "name": "Class.powerset",
    "statement": "def Class.powerset (x : Class) : Class",
    "theorem": "(x : Class) : Class",
    "args": "(x : Class)",
    "doc_string": "The power class of a class is the class of all subclasses that are ZFC sets",
    "kind": "def",
    "type": "Class"
  },
  {
    "name": "function.support",
    "statement": "def function.support {α : Type u_1} {A : Type u_3} [has_zero A] (f : α → A) : set α",
    "theorem": "{α : Type u_1} {A : Type u_3} [has_zero A] (f : α → A) : set α",
    "args": "{α : Type u_1} {A : Type u_3} [has_zero A] (f : α → A)",
    "doc_string": "`support` of a function is the set of points `x` such that `f x ≠ 0`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "module.projective",
    "statement": "structure module.projective (R : Type u) [semiring R] (P : Type (max u v)) [add_comm_monoid P] [module R P] : Prop",
    "theorem": "(R : Type u) [semiring R] (P : Type (max u v)) [add_comm_monoid P] [module R P] : Prop",
    "args": "(R : Type u) [semiring R] (P : Type (max u v)) [add_comm_monoid P] [module R P]",
    "doc_string": "An R-module is projective if it is a direct summand of a free module, or equivalently  if maps from the module lift along surjections. There are several other equivalent  definitions.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "erased",
    "statement": "def erased (α : Sort u) : Sort (max 1 u)",
    "theorem": "(α : Sort u) : Sort (max 1 u)",
    "args": "(α : Sort u)",
    "doc_string": "`erased α` is the same as `α`, except that the elements  of `erased α` are erased in the VM in the same way as types  and proofs. This can be used to track data without storing it  literally.",
    "kind": "def",
    "type": "Sort (max 1 u)"
  },
  {
    "name": "finset.traverse",
    "statement": "def finset.traverse {α β : Type u} {F : Type u → Type u} [applicative F] [is_comm_applicative F] [decidable_eq β] (f : α → F β) (s : finset α) : F (finset β)",
    "theorem": "{α β : Type u} {F : Type u → Type u} [applicative F] [is_comm_applicative F] [decidable_eq β] (f : α → F β) (s : finset α) : F (finset β)",
    "args": "{α β : Type u} {F : Type u → Type u} [applicative F] [is_comm_applicative F] [decidable_eq β] (f : α → F β) (s : finset α)",
    "doc_string": "Traverse function for `finset`.",
    "kind": "def",
    "type": "F (finset β)"
  },
  {
    "name": "apply_ite",
    "statement": "theorem apply_ite {α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [decidable P] (a b : α) : f (ite P a b) = ite P (f a) (f b)",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [decidable P] (a b : α) : f (ite P a b) = ite P (f a) (f b)",
    "args": "{α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [decidable P] (a b : α)",
    "doc_string": "A function applied to a `ite` is a `ite` of that function applied to each of the branches.",
    "kind": "theorem",
    "type": "f (ite P a b) = ite P (f a) (f b)"
  },
  {
    "name": "category_theory.limits.initial_mono_class",
    "statement": "structure category_theory.limits.initial_mono_class (C : Type u₁) [category_theory.category C] : Prop",
    "theorem": "(C : Type u₁) [category_theory.category C] : Prop",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": " A category is a `initial_mono_class` if the canonical morphism of an initial object is a monomorphism.  In practice, this is most useful when given an arbitrary morphism out of the chosen initial object, see `initial.mono_from`. Given a terminal object, this is equivalent to the assumption that the unique morphism from initial to terminal is a monomorphism, which is the second of Freyd's axioms for an AT category.  TODO: This is a condition satisfied by categories with zero objects and morphisms.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_noetherian",
    "statement": "structure is_noetherian (R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "`is_noetherian R M` is the proposition that `M` is a Noetherian `R`-module, implemented as the predicate that all `R`-submodules of `M` are finitely generated.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "uv.is_compressed",
    "statement": "def uv.is_compressed {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α) : Prop",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α) : Prop",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α)",
    "doc_string": "`is_compressed u v s` expresses that `s` is UV-compressed.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "onote.split",
    "statement": "def onote.split  : onote → onote × ℕ",
    "theorem": " : onote → onote × ℕ",
    "args": "",
    "doc_string": "Calculate division and remainder of `o` mod ω.  `split o = (a, n)` means `o = a + n`, where `ω ∣ a`.",
    "kind": "def",
    "type": "onote → onote × ℕ"
  },
  {
    "name": "add_mem_class",
    "statement": "structure add_mem_class (S : Type u_4) (M : out_param (Type u_5)) [has_add M] [set_like S M] : Type",
    "theorem": "(S : Type u_4) (M : out_param (Type u_5)) [has_add M] [set_like S M] : Type",
    "args": "(S : Type u_4) (M : out_param (Type u_5)) [has_add M] [set_like S M]",
    "doc_string": "`add_mem_class S M` says `S` is a type of subsets `s ≤ M` that are closed under `(+)`",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "with_top.conditionally_complete_lattice",
    "statement": "def with_top.conditionally_complete_lattice {α : Type u_1} [conditionally_complete_lattice α] : conditionally_complete_lattice (with_top α)",
    "theorem": "{α : Type u_1} [conditionally_complete_lattice α] : conditionally_complete_lattice (with_top α)",
    "args": "{α : Type u_1} [conditionally_complete_lattice α]",
    "doc_string": " Adding a top element to a conditionally complete lattice gives a conditionally complete lattice",
    "kind": "def",
    "type": "conditionally_complete_lattice (with_top α)"
  },
  {
    "name": "list.nodup",
    "statement": "def list.nodup {α : Type u_1} : list α → Prop",
    "theorem": "{α : Type u_1} : list α → Prop",
    "args": "{α : Type u_1}",
    "doc_string": "`nodup l` means that `l` has no duplicates, that is, any element appears at most  once in the list. It is defined as `pairwise (≠)`.",
    "kind": "def",
    "type": "list α → Prop"
  },
  {
    "name": "Class.iota_ex",
    "statement": "theorem Class.iota_ex (p : Set → Prop) : Class.iota p ∈ Class.univ",
    "theorem": "(p : Set → Prop) : Class.iota p ∈ Class.univ",
    "args": "(p : Set → Prop)",
    "doc_string": "Unlike the other set constructors, the `iota` definite descriptor  is a set for any set input, but not constructively so, so there is no  associated `(Set → Prop) → Set` function.",
    "kind": "theorem",
    "type": "Class.iota p ∈ Class.univ"
  },
  {
    "name": "witt_vector.shift",
    "statement": "def witt_vector.shift {p : ℕ} {R : Type u_1} (x : witt_vector p R) (n : ℕ) : witt_vector p R",
    "theorem": "{p : ℕ} {R : Type u_1} (x : witt_vector p R) (n : ℕ) : witt_vector p R",
    "args": "{p : ℕ} {R : Type u_1} (x : witt_vector p R) (n : ℕ)",
    "doc_string": "`witt_vector.verschiebung` translates the entries of a Witt vector upward, inserting 0s in the gaps. `witt_vector.shift` does the opposite, removing the first entries. This is mainly useful as an auxiliary construction for `witt_vector.verschiebung_nonzero`.",
    "kind": "def",
    "type": "witt_vector p R"
  },
  {
    "name": "free_add_monoid",
    "statement": "def free_add_monoid (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Free nonabelian additive monoid over a given alphabet",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "geometry.simplicial_complex.vertices",
    "statement": "def geometry.simplicial_complex.vertices {𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E) : set E",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E) : set E",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E)",
    "doc_string": "The vertices of a simplicial complex are its zero dimensional faces.",
    "kind": "def",
    "type": "set E"
  },
  {
    "name": "ordered_semiring",
    "statement": "structure ordered_semiring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " An `ordered_semiring α` is a semiring `α` with a partial order such that addition is monotone and multiplication by a positive number is strictly monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "add_commute.symm",
    "statement": "theorem add_commute.symm {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a",
    "theorem": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a",
    "args": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b)",
    "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
    "kind": "theorem",
    "type": "add_commute b a"
  },
  {
    "name": "dense_range_pure",
    "statement": "theorem dense_range_pure {α : Type u} : dense_range has_pure.pure",
    "theorem": "{α : Type u} : dense_range has_pure.pure",
    "args": "{α : Type u}",
    "doc_string": "The range of `pure : α → ultrafilter α` is dense in `ultrafilter α`.",
    "kind": "theorem",
    "type": "dense_range has_pure.pure"
  },
  {
    "name": "simple_graph.has_inf",
    "statement": "def simple_graph.has_inf {V : Type u} : has_inf (simple_graph V)",
    "theorem": "{V : Type u} : has_inf (simple_graph V)",
    "args": "{V : Type u}",
    "doc_string": "The infimum of two graphs `x ⊓ y` has edges where both `x` and `y` have edges.",
    "kind": "def",
    "type": "has_inf (simple_graph V)"
  },
  {
    "name": "matrix.adjugate",
    "statement": "def matrix.adjugate {n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) : matrix n n α",
    "theorem": "{n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) : matrix n n α",
    "args": "{n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α)",
    "doc_string": "The adjugate matrix is the transpose of the cofactor matrix.   Typically, the cofactor matrix is defined by taking the determinant of minors,  i.e. the matrix with a row and column removed.  However, the proof of `mul_adjugate` becomes a lot easier if we define the  minor as replacing a column with a basis vector, since it allows us to use  facts about the `cramer` map.",
    "kind": "def",
    "type": "matrix n n α"
  },
  {
    "name": "fin.cases",
    "statement": "def fin.cases {n : ℕ} {C : fin n.succ → Sort u_1} (H0 : C 0) (Hs : Π (i : fin n), C i.succ) (i : fin n.succ) : C i",
    "theorem": "{n : ℕ} {C : fin n.succ → Sort u_1} (H0 : C 0) (Hs : Π (i : fin n), C i.succ) (i : fin n.succ) : C i",
    "args": "{n : ℕ} {C : fin n.succ → Sort u_1} (H0 : C 0) (Hs : Π (i : fin n), C i.succ) (i : fin n.succ)",
    "doc_string": " Define `f : Π i : fin n.succ, C i` by separately handling the cases `i = 0` and `i = j.succ`, `j : fin n`.",
    "kind": "def",
    "type": "C i"
  },
  {
    "name": "locally_constant.unflip",
    "statement": "def locally_constant.unflip {X : Type u_1} {α : Type u_2} {β : Type u_3} [fintype α] [topological_space X] (f : α → locally_constant X β) : locally_constant X (α → β)",
    "theorem": "{X : Type u_1} {α : Type u_2} {β : Type u_3} [fintype α] [topological_space X] (f : α → locally_constant X β) : locally_constant X (α → β)",
    "args": "{X : Type u_1} {α : Type u_2} {β : Type u_3} [fintype α] [topological_space X] (f : α → locally_constant X β)",
    "doc_string": " If α is finite, this constructs a locally constant function to `α → β` given a family of locally constant functions with values in β indexed by α.",
    "kind": "def",
    "type": "locally_constant X (α → β)"
  },
  {
    "name": "non_unital_non_assoc_semiring.nat_is_scalar_tower",
    "statement": "def non_unital_non_assoc_semiring.nat_is_scalar_tower {R : Type u₁} [non_unital_non_assoc_semiring R] : is_scalar_tower ℕ R R",
    "theorem": "{R : Type u₁} [non_unital_non_assoc_semiring R] : is_scalar_tower ℕ R R",
    "args": "{R : Type u₁} [non_unital_non_assoc_semiring R]",
    "doc_string": "Note that `add_comm_monoid.nat_is_scalar_tower` requires stronger assumptions on `R`.",
    "kind": "def",
    "type": "is_scalar_tower ℕ R R"
  },
  {
    "name": "antilipschitz_with",
    "statement": "def antilipschitz_with {α : Type u_1} {β : Type u_2} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β)",
    "doc_string": " We say that `f : α → β` is `antilipschitz_with K` if for any two points `x`, `y` we have `K * edist x y ≤ edist (f x) (f y)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_finite_products_of_has_finite_limits",
    "statement": "def category_theory.limits.has_finite_products_of_has_finite_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_products C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_products C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C]",
    "doc_string": "If `C` has finite limits then it has finite products.",
    "kind": "def",
    "type": "category_theory.limits.has_finite_products C"
  },
  {
    "name": "pfunctor.W.head",
    "statement": "def pfunctor.W.head {P : pfunctor} : P.W → P.A",
    "theorem": "{P : pfunctor} : P.W → P.A",
    "args": "{P : pfunctor}",
    "doc_string": "root element  of a W tree",
    "kind": "def",
    "type": "P.W → P.A"
  },
  {
    "name": "ordinal.has_pow",
    "statement": "def ordinal.has_pow  : has_pow ordinal ordinal",
    "theorem": " : has_pow ordinal ordinal",
    "args": "",
    "doc_string": "The ordinal exponential, defined by transfinite recursion.",
    "kind": "def",
    "type": "has_pow ordinal ordinal"
  },
  {
    "name": "is_localization.localization_localization_submodule",
    "statement": "def is_localization.localization_localization_submodule {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) : submonoid R",
    "theorem": "{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S) : submonoid R",
    "args": "{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] (N : submonoid S)",
    "doc_string": "Localizing wrt `M ⊆ R` and then wrt `N ⊆ S = M⁻¹R` is equal to the localization of `R` wrt this module. See `localization_localization_is_localization`.",
    "kind": "def",
    "type": "submonoid R"
  },
  {
    "name": "subgroup.index",
    "statement": "def subgroup.index {G : Type u_1} [group G] (H : subgroup G) : ℕ",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : ℕ",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": "The index of a subgroup as a natural number, and returns 0 if the index is infinite.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "tactic.nth_rewrite.tracked_rewrite",
    "statement": "structure tactic.nth_rewrite.tracked_rewrite  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " A data structure to track rewrites of subexpressions. The field `exp` contains the new expression, while `proof` contains a proof that `exp` is equivalent to the expression that was rewritten.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "equiv.perm.sum_congr",
    "statement": "def equiv.perm.sum_congr {α : Type u_1} {β : Type u_2} (ea : equiv.perm α) (eb : equiv.perm β) : equiv.perm (α ⊕ β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (ea : equiv.perm α) (eb : equiv.perm β) : equiv.perm (α ⊕ β)",
    "args": "{α : Type u_1} {β : Type u_2} (ea : equiv.perm α) (eb : equiv.perm β)",
    "doc_string": "Combine a permutation of `α` and of `β` into a permutation of `α ⊕ β`.",
    "kind": "def",
    "type": "equiv.perm (α ⊕ β)"
  },
  {
    "name": "empty_graph",
    "statement": "def empty_graph (V : Type u) : simple_graph V",
    "theorem": "(V : Type u) : simple_graph V",
    "args": "(V : Type u)",
    "doc_string": "The graph with no edges on a given vertex type `V`. `mathlib` prefers the notation `⊥`.",
    "kind": "def",
    "type": "simple_graph V"
  },
  {
    "name": "trunc.out",
    "statement": "def trunc.out {α : Sort u_1} : trunc α → α",
    "theorem": "{α : Sort u_1} : trunc α → α",
    "args": "{α : Sort u_1}",
    "doc_string": "Noncomputably extract a representative of `trunc α` (using the axiom of choice).",
    "kind": "def",
    "type": "trunc α → α"
  },
  {
    "name": "Compactum_to_CompHaus.is_equivalence",
    "statement": "def Compactum_to_CompHaus.is_equivalence  : category_theory.is_equivalence Compactum_to_CompHaus",
    "theorem": " : category_theory.is_equivalence Compactum_to_CompHaus",
    "args": "",
    "doc_string": "The functor Compactum_to_CompHaus is an equivalence of categories.",
    "kind": "def",
    "type": "category_theory.is_equivalence Compactum_to_CompHaus"
  },
  {
    "name": "add_subsemigroup.has_top",
    "statement": "def add_subsemigroup.has_top {M : Type u_1} [has_add M] : has_top (add_subsemigroup M)",
    "theorem": "{M : Type u_1} [has_add M] : has_top (add_subsemigroup M)",
    "args": "{M : Type u_1} [has_add M]",
    "doc_string": "The additive subsemigroup `M` of the magma `M`.",
    "kind": "def",
    "type": "has_top (add_subsemigroup M)"
  },
  {
    "name": "equiv.swap_core",
    "statement": "def equiv.swap_core {α : Sort u} [decidable_eq α] (a b r : α) : α",
    "theorem": "{α : Sort u} [decidable_eq α] (a b r : α) : α",
    "args": "{α : Sort u} [decidable_eq α] (a b r : α)",
    "doc_string": "A helper function for `equiv.swap`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "collinear",
    "statement": "def collinear (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : Prop",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : Prop",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P)",
    "doc_string": " A set of points is collinear if their `vector_span` has dimension at most `1`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "prod.ring",
    "statement": "def prod.ring {R : Type u_1} {S : Type u_3} [ring R] [ring S] : ring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [ring R] [ring S] : ring (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [ring R] [ring S]",
    "doc_string": "Product of two rings is a ring.",
    "kind": "def",
    "type": "ring (R × S)"
  },
  {
    "name": "list.zip_left'",
    "statement": "def list.zip_left' {α : Type u_1} {β : Type u_2} : list α → list β → list (α × option β) × list β",
    "theorem": "{α : Type u_1} {β : Type u_2} : list α → list β → list (α × option β) × list β",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": "Left-biased version of `list.zip`. `zip_left' as bs` returns the list of pairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, the remaining `aᵢ` are paired with `none`. Also returns the remaining `bs`.  ```lean zip_left' [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])  zip_left' [1] ['a', 'b'] = ([(1, some 'a')], ['b'])  zip_left' = map₂_left' prod.mk  ```",
    "kind": "def",
    "type": "list α → list β → list (α × option β) × list β"
  },
  {
    "name": "euclidean_space.single",
    "statement": "def euclidean_space.single {ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] [fintype ι] [decidable_eq ι] (i : ι) (a : 𝕜) : euclidean_space 𝕜 ι",
    "theorem": "{ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] [fintype ι] [decidable_eq ι] (i : ι) (a : 𝕜) : euclidean_space 𝕜 ι",
    "args": "{ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] [fintype ι] [decidable_eq ι] (i : ι) (a : 𝕜)",
    "doc_string": " The vector given in euclidean space by being `1 : 𝕜` at coordinate `i : ι` and `0 : 𝕜` at all other coordinates.",
    "kind": "def",
    "type": "euclidean_space 𝕜 ι"
  },
  {
    "name": "ordnode.balance'",
    "statement": "def ordnode.balance' {α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "theorem": "{α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "args": "{α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α)",
    "doc_string": " The full balance operation. This is the same as `balance`, but with less manual inlining. It is somewhat easier to work with this version in proofs.",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "list.indexes_values",
    "statement": "def list.indexes_values {α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) : list (ℕ × α)",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) : list (ℕ × α)",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α)",
    "doc_string": " Returns the elements of `l` that satisfy `p` together with their indexes in `l`. The returned list is ordered by index.",
    "kind": "def",
    "type": "list (ℕ × α)"
  },
  {
    "name": "uniform_cauchy_seq_on",
    "statement": "def uniform_cauchy_seq_on {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (p : filter ι) (s : set α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (p : filter ι) (s : set α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (p : filter ι) (s : set α)",
    "doc_string": " A sequence is uniformly Cauchy if eventually all of its pairwise differences are uniformly bounded",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lie_algebra.orthogonal.so'",
    "statement": "def lie_algebra.orthogonal.so' (p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] [fintype p] [fintype q] : lie_subalgebra R (matrix (p ⊕ q) (p ⊕ q) R)",
    "theorem": "(p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] [fintype p] [fintype q] : lie_subalgebra R (matrix (p ⊕ q) (p ⊕ q) R)",
    "args": "(p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] [fintype p] [fintype q]",
    "doc_string": " The indefinite orthogonal Lie subalgebra: skew-adjoint matrices with respect to the symmetric bilinear form defined by the indefinite diagonal matrix.",
    "kind": "def",
    "type": "lie_subalgebra R (matrix (p ⊕ q) (p ⊕ q) R)"
  },
  {
    "name": "contractible_space",
    "statement": "structure contractible_space (X : Type u_1) [topological_space X] : Prop",
    "theorem": "(X : Type u_1) [topological_space X] : Prop",
    "args": "(X : Type u_1) [topological_space X]",
    "doc_string": "A contractible space is one that is homotopy equivalent to `unit`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "mvpfunctor.last",
    "statement": "def mvpfunctor.last {n : ℕ} (P : mvpfunctor (n + 1)) : pfunctor",
    "theorem": "{n : ℕ} (P : mvpfunctor (n + 1)) : pfunctor",
    "args": "{n : ℕ} (P : mvpfunctor (n + 1))",
    "doc_string": " Split polynomial functor, get a univariate functor from a `n+1`-ary functor",
    "kind": "def",
    "type": "pfunctor"
  },
  {
    "name": "Top.presheaf.sheafify",
    "statement": "def Top.presheaf.sheafify {X : Top} (F : Top.presheaf (Type v) X) : Top.sheaf (Type v) X",
    "theorem": "{X : Top} (F : Top.presheaf (Type v) X) : Top.sheaf (Type v) X",
    "args": "{X : Top} (F : Top.presheaf (Type v) X)",
    "doc_string": "The sheafification of a `Type` valued presheaf, defined as the functions into the stalks which are locally equal to germs.",
    "kind": "def",
    "type": "Top.sheaf (Type v) X"
  },
  {
    "name": "bump_covering.is_subordinate",
    "statement": "def bump_covering.is_subordinate {ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) (U : ι → set X) : Prop",
    "theorem": "{ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) (U : ι → set X) : Prop",
    "args": "{ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) (U : ι → set X)",
    "doc_string": " A collection of bump functions `f i` is subordinate to a family of sets `U i` indexed by the same type if for each `i` the closure of the support of `f i` is a subset of `U i`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "metric.continuous_inf_nndist_pt",
    "statement": "theorem metric.continuous_inf_nndist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_nndist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_nndist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set (as `ℝ≥0`) is continuous in point",
    "kind": "theorem",
    "type": "continuous (λ (x : α), metric.inf_nndist x s)"
  },
  {
    "name": "cauchy_seq",
    "statement": "def cauchy_seq {α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] (u : β → α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] (u : β → α) : Prop",
    "args": "{α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] (u : β → α)",
    "doc_string": " Cauchy sequences. Usually defined on ℕ, but often it is also useful to say that a function defined on ℝ is Cauchy at +∞ to deduce convergence. Therefore, we define it in a type class that is general enough to cover both ℕ and ℝ, which are the main motivating examples.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.diag",
    "statement": "def finset.diag {α : Type u_1} (s : finset α) [decidable_eq α] : finset (α × α)",
    "theorem": "{α : Type u_1} (s : finset α) [decidable_eq α] : finset (α × α)",
    "args": "{α : Type u_1} (s : finset α) [decidable_eq α]",
    "doc_string": " Given a finite set `s`, the diagonal, `s.diag` is the set of pairs of the form `(a, a)` for `a ∈ s`.",
    "kind": "def",
    "type": "finset (α × α)"
  },
  {
    "name": "slim_check.total_function",
    "statement": "inductive slim_check.total_function (α : Type u) (β : Type v) : Type (max u v)",
    "theorem": "(α : Type u) (β : Type v) : Type (max u v)",
    "args": "(α : Type u) (β : Type v)",
    "doc_string": " Data structure specifying a total function using a list of pairs and a default value returned when the input is not in the domain of the partial function.  `with_default f y` encodes `x ↦ f x` when `x ∈ f` and `x ↦ y` otherwise.  We use `Σ` to encode mappings instead of `×` because we rely on the association list API defined in `data.list.sigma`.",
    "kind": "inductive",
    "type": "Type (max u v)"
  },
  {
    "name": "nat.sum_two_pow_lt",
    "statement": "theorem nat.sum_two_pow_lt {k : ℕ} {A : finset ℕ} (h₁ : ∀ {x : ℕ}, x ∈ A → x < k) : A.sum (has_pow.pow 2) < 2 ^ k",
    "theorem": "{k : ℕ} {A : finset ℕ} (h₁ : ∀ {x : ℕ}, x ∈ A → x < k) : A.sum (has_pow.pow 2) < 2 ^ k",
    "args": "{k : ℕ} {A : finset ℕ} (h₁ : ∀ {x : ℕ}, x ∈ A → x < k)",
    "doc_string": "If everything in `A` is less than `k`, we can bound the sum of powers.",
    "kind": "theorem",
    "type": "A.sum (has_pow.pow 2) < 2 ^ k"
  },
  {
    "name": "has_sbtw.sbtw.not_sbtw",
    "statement": "theorem has_sbtw.sbtw.not_sbtw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_sbtw.sbtw c b a",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_sbtw.sbtw c b a",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of sbtw_asymm`.",
    "kind": "theorem",
    "type": "¬has_sbtw.sbtw c b a"
  },
  {
    "name": "omega.nat.preterm.sub_terms",
    "statement": "def omega.nat.preterm.sub_terms  : omega.nat.preterm → option (omega.nat.preterm × omega.nat.preterm)",
    "theorem": " : omega.nat.preterm → option (omega.nat.preterm × omega.nat.preterm)",
    "args": "",
    "doc_string": "Find subtraction inside preterm and return its operands",
    "kind": "def",
    "type": "omega.nat.preterm → option (omega.nat.preterm × omega.nat.preterm)"
  },
  {
    "name": "exp_neg_inv_glue.f_aux_limit",
    "statement": "theorem exp_neg_inv_glue.f_aux_limit (n : ℕ) : filter.tendsto (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)",
    "theorem": "(n : ℕ) : filter.tendsto (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)",
    "args": "(n : ℕ)",
    "doc_string": " To get differentiability at `0` of the auxiliary functions, we need to know that their limit is `0`, to be able to apply general differentiability extension theorems. This limit is checked in this lemma.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)"
  },
  {
    "name": "preorder.to_circular_preorder",
    "statement": "def preorder.to_circular_preorder (α : Type u_1) [preorder α] : circular_preorder α",
    "theorem": "(α : Type u_1) [preorder α] : circular_preorder α",
    "args": "(α : Type u_1) [preorder α]",
    "doc_string": " The circular preorder obtained from \"looping around\" a preorder. See note [reducible non-instances].",
    "kind": "def",
    "type": "circular_preorder α"
  },
  {
    "name": "has_groupoid_continuous_groupoid",
    "statement": "def has_groupoid_continuous_groupoid {H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] : has_groupoid M (continuous_groupoid H)",
    "theorem": "{H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M] : has_groupoid M (continuous_groupoid H)",
    "args": "{H : Type u} {M : Type u_2} [topological_space H] [topological_space M] [charted_space H M]",
    "doc_string": "Any charted space structure is compatible with the groupoid of all local homeomorphisms",
    "kind": "def",
    "type": "has_groupoid M (continuous_groupoid H)"
  },
  {
    "name": "nat.factorization_eq_zero_iff",
    "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1",
    "theorem": "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1",
    "args": "(n : ℕ)",
    "doc_string": "The only numbers with empty prime factorization are `0` and `1`",
    "kind": "theorem",
    "type": "n.factorization = 0 ↔ n = 0 ∨ n = 1"
  },
  {
    "name": "lower_semicontinuous_at",
    "statement": "def lower_semicontinuous_at {α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (x : α) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (x : α) : Prop",
    "args": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (x : α)",
    "doc_string": " A real function `f` is lower semicontinuous at `x` if, for any `ε > 0`, for all `x'` close enough to `x`, then `f x'` is at least `f x - ε`. We formulate this in a general preordered space, using an arbitrary `y < f x` instead of `f x - ε`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "order.succ_ne_succ",
    "statement": "theorem order.succ_ne_succ {α : Type u_1} [partial_order α] [succ_order α] {a b : α} [no_max_order α] : a ≠ b → order.succ a ≠ order.succ b",
    "theorem": "{α : Type u_1} [partial_order α] [succ_order α] {a b : α} [no_max_order α] : a ≠ b → order.succ a ≠ order.succ b",
    "args": "{α : Type u_1} [partial_order α] [succ_order α] {a b : α} [no_max_order α]",
    "doc_string": "**Alias** of the reverse direction of order.succ_ne_succ_iff`.",
    "kind": "theorem",
    "type": "a ≠ b → order.succ a ≠ order.succ b"
  },
  {
    "name": "option.to_finset",
    "statement": "def option.to_finset {α : Type u_1} (o : option α) : finset α",
    "theorem": "{α : Type u_1} (o : option α) : finset α",
    "args": "{α : Type u_1} (o : option α)",
    "doc_string": "Construct an empty or singleton finset from an `option`",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "fintype.bij_inv",
    "statement": "def fintype.bij_inv {α : Type u_1} {β : Type u_2} [fintype α] [decidable_eq β] {f : α → β} (f_bij : function.bijective f) (b : β) : α",
    "theorem": "{α : Type u_1} {β : Type u_2} [fintype α] [decidable_eq β] {f : α → β} (f_bij : function.bijective f) (b : β) : α",
    "args": "{α : Type u_1} {β : Type u_2} [fintype α] [decidable_eq β] {f : α → β} (f_bij : function.bijective f) (b : β)",
    "doc_string": "`bij_inv f` is the unique inverse to a bijection `f`. This acts   as a computable alternative to `function.inv_fun`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "sym2.from_rel",
    "statement": "def sym2.from_rel {α : Type u_1} {r : α → α → Prop} (sym : symmetric r) : set (sym2 α)",
    "theorem": "{α : Type u_1} {r : α → α → Prop} (sym : symmetric r) : set (sym2 α)",
    "args": "{α : Type u_1} {r : α → α → Prop} (sym : symmetric r)",
    "doc_string": "Symmetric relations define a set on `sym2 α` by taking all those pairs of elements that are related.",
    "kind": "def",
    "type": "set (sym2 α)"
  },
  {
    "name": "tsub_tsub_le",
    "statement": "theorem tsub_tsub_le {α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : b - (b - a) ≤ a",
    "theorem": "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : b - (b - a) ≤ a",
    "args": "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α}",
    "doc_string": "See `tsub_tsub_cancel_of_le` for the equality.",
    "kind": "theorem",
    "type": "b - (b - a) ≤ a"
  },
  {
    "name": "add_con_gen.rel",
    "statement": "inductive add_con_gen.rel {M : Type u_1} [has_add M] (r : M → M → Prop) : M → M → Prop",
    "theorem": "{M : Type u_1} [has_add M] (r : M → M → Prop) : M → M → Prop",
    "args": "{M : Type u_1} [has_add M] (r : M → M → Prop)",
    "doc_string": "The inductively defined smallest additive congruence relation containing a given binary    relation.",
    "kind": "inductive",
    "type": "M → M → Prop"
  },
  {
    "name": "nonote.below",
    "statement": "def nonote.below (a b : nonote) : Prop",
    "theorem": "(a b : nonote) : Prop",
    "args": "(a b : nonote)",
    "doc_string": "Asserts that `repr a < ω ^ repr b`. Used in `nonote.rec_on`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "order.ideal.partial_order",
    "statement": "def order.ideal.partial_order {P : Type u_1} [has_le P] : partial_order (order.ideal P)",
    "theorem": "{P : Type u_1} [has_le P] : partial_order (order.ideal P)",
    "args": "{P : Type u_1} [has_le P]",
    "doc_string": "The partial ordering by subset inclusion, inherited from `set P`.",
    "kind": "def",
    "type": "partial_order (order.ideal P)"
  },
  {
    "name": "ordering.compares",
    "statement": "def ordering.compares {α : Type u_1} [has_lt α] : ordering → α → α → Prop",
    "theorem": "{α : Type u_1} [has_lt α] : ordering → α → α → Prop",
    "args": "{α : Type u_1} [has_lt α]",
    "doc_string": " `compares o a b` means that `a` and `b` have the ordering relation `o` between them, assuming that the relation `a < b` is defined.",
    "kind": "def",
    "type": "ordering → α → α → Prop"
  },
  {
    "name": "relation.map",
    "statement": "def relation.map {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (r : α → β → Prop) (f : α → γ) (g : β → δ) : γ → δ → Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (r : α → β → Prop) (f : α → γ) (g : β → δ) : γ → δ → Prop",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (r : α → β → Prop) (f : α → γ) (g : β → δ)",
    "doc_string": "The map of a relation `r` through a pair of functions pushes the relation to the codomains of the functions.  The resulting relation is defined by having pairs of terms related if they have preimages related by `r`.",
    "kind": "def",
    "type": "γ → δ → Prop"
  },
  {
    "name": "sigma.subtype_ext",
    "statement": "theorem sigma.subtype_ext {α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁",
    "theorem": "{α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁",
    "args": "{α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), subtype (p a)}",
    "doc_string": "A specialized ext lemma for equality of sigma types over an indexed subtype.",
    "kind": "theorem",
    "type": "x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁"
  },
  {
    "name": "add_submonoid.gi",
    "statement": "def add_submonoid.gi (M : Type u_1) [add_zero_class M] : galois_insertion add_submonoid.closure coe",
    "theorem": "(M : Type u_1) [add_zero_class M] : galois_insertion add_submonoid.closure coe",
    "args": "(M : Type u_1) [add_zero_class M]",
    "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
    "kind": "def",
    "type": "galois_insertion add_submonoid.closure coe"
  },
  {
    "name": "measure_theory.simple_func.approx",
    "statement": "def measure_theory.simple_func.approx {α : Type u_1} {β : Type u_2} [measurable_space α] [semilattice_sup β] [order_bot β] [has_zero β] (i : ℕ → β) (f : α → β) (n : ℕ) : measure_theory.simple_func α β",
    "theorem": "{α : Type u_1} {β : Type u_2} [measurable_space α] [semilattice_sup β] [order_bot β] [has_zero β] (i : ℕ → β) (f : α → β) (n : ℕ) : measure_theory.simple_func α β",
    "args": "{α : Type u_1} {β : Type u_2} [measurable_space α] [semilattice_sup β] [order_bot β] [has_zero β] (i : ℕ → β) (f : α → β) (n : ℕ)",
    "doc_string": " Fix a sequence `i : ℕ → β`. Given a function `α → β`, its `n`-th approximation by simple functions is defined so that in case `β = ℝ≥0∞` it sends each `a` to the supremum of the set `{i k | k ≤ n ∧ i k ≤ f a}`, see `approx_apply` and `supr_approx_apply` for details.",
    "kind": "def",
    "type": "measure_theory.simple_func α β"
  },
  {
    "name": "computability.unary_decode_nat",
    "statement": "def computability.unary_decode_nat  : list bool → ℕ",
    "theorem": " : list bool → ℕ",
    "args": "",
    "doc_string": "A unary decoding function from `list bool` to ℕ.",
    "kind": "def",
    "type": "list bool → ℕ"
  },
  {
    "name": "zsqrtd.nonsquare",
    "statement": "structure zsqrtd.nonsquare (x : ℕ) : Prop",
    "theorem": "(x : ℕ) : Prop",
    "args": "(x : ℕ)",
    "doc_string": "A nonsquare is a natural number that is not equal to the square of an  integer. This is implemented as a typeclass because it's a necessary condition  for much of the Pell equation theory.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "localization.subalgebra",
    "statement": "def localization.subalgebra {A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) [comm_ring K] [algebra A K] [is_fraction_ring A K] (hS : S ≤ non_zero_divisors A) : subalgebra A K",
    "theorem": "{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) [comm_ring K] [algebra A K] [is_fraction_ring A K] (hS : S ≤ non_zero_divisors A) : subalgebra A K",
    "args": "{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) [comm_ring K] [algebra A K] [is_fraction_ring A K] (hS : S ≤ non_zero_divisors A)",
    "doc_string": "Given a commutative ring `A` with fraction ring `K`, and a submonoid `S` of `A` which contains no zero divisor, this is the localization of `A` at `S`, considered as a subalgebra of `K` over `A`.  The carrier of this subalgebra is defined as the set of all `x : K` of the form `is_localization.mk' K a ⟨s, _⟩`, where `s ∈ S`.",
    "kind": "def",
    "type": "subalgebra A K"
  },
  {
    "name": "topological_vector_bundle.prod.topological_space",
    "statement": "def topological_vector_bundle.prod.topological_space {B : Type u_3} (E₁ : B → Type u_6) (E₂ : B → Type u_7) [topological_space (bundle.total_space E₁)] [topological_space (bundle.total_space E₂)] : topological_space (bundle.total_space (λ (x : B), E₁ x × E₂ x))",
    "theorem": "{B : Type u_3} (E₁ : B → Type u_6) (E₂ : B → Type u_7) [topological_space (bundle.total_space E₁)] [topological_space (bundle.total_space E₂)] : topological_space (bundle.total_space (λ (x : B), E₁ x × E₂ x))",
    "args": "{B : Type u_3} (E₁ : B → Type u_6) (E₂ : B → Type u_7) [topological_space (bundle.total_space E₁)] [topological_space (bundle.total_space E₂)]",
    "doc_string": " Equip the total space of the fibrewise product of two topological vector bundles `E₁`, `E₂` with the induced topology from the diagonal embedding into `total_space E₁ × total_space E₂`.",
    "kind": "def",
    "type": "topological_space (bundle.total_space (λ (x : B), E₁ x × E₂ x))"
  },
  {
    "name": "basis",
    "statement": "structure basis (ι : Type u_1) (R : Type u_3) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_3 u_5)",
    "theorem": "(ι : Type u_1) (R : Type u_3) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_3 u_5)",
    "args": "(ι : Type u_1) (R : Type u_3) (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": " A `basis ι R M` for a module `M` is the type of `ι`-indexed `R`-bases of `M`.  The basis vectors are available as `coe_fn (b : basis ι R M) : ι → M`. To turn a linear independent family of vectors spanning `M` into a basis, use `basis.mk`. They are internally represented as linear equivs `M ≃ₗ[R] (ι →₀ R)`, available as `basis.repr`.",
    "kind": "structure",
    "type": "Type (max u_1 u_3 u_5)"
  },
  {
    "name": "disjointed",
    "statement": "def disjointed {α : Type u_1} [generalized_boolean_algebra α] (f : ℕ → α) : ℕ → α",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] (f : ℕ → α) : ℕ → α",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] (f : ℕ → α)",
    "doc_string": " If `f : ℕ → α` is a sequence of elements, then `disjointed f` is the sequence formed by subtracting each element from the nexts. This is the unique disjoint sequence whose partial sups are the same as the original sequence.",
    "kind": "def",
    "type": "ℕ → α"
  },
  {
    "name": "category_theory.has_injective_resolutions",
    "statement": "structure category_theory.has_injective_resolutions (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] : Prop",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C]",
    "doc_string": " You will rarely use this typeclass directly: it is implied by the combination `[enough_injectives C]` and `[abelian C]`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "uniform_convergence_on.uniform_space",
    "statement": "def uniform_convergence_on.uniform_space (α : Type u_1) (β : Type u_2) [uniform_space β] (𝔖 : set (set α)) : uniform_space (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [uniform_space β] (𝔖 : set (set α)) : uniform_space (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [uniform_space β] (𝔖 : set (set α))",
    "doc_string": "Uniform structure of uniform convergence on the sets of `𝔖`.",
    "kind": "def",
    "type": "uniform_space (α → β)"
  },
  {
    "name": "bounded_order_hom.id",
    "statement": "def bounded_order_hom.id (α : Type u_2) [preorder α] [bounded_order α] : bounded_order_hom α α",
    "theorem": "(α : Type u_2) [preorder α] [bounded_order α] : bounded_order_hom α α",
    "args": "(α : Type u_2) [preorder α] [bounded_order α]",
    "doc_string": "`id` as a `bounded_order_hom`.",
    "kind": "def",
    "type": "bounded_order_hom α α"
  },
  {
    "name": "has_measurable_add₂",
    "statement": "structure has_measurable_add₂ (M : Type u_1) [measurable_space M] [has_add M] : Prop",
    "theorem": "(M : Type u_1) [measurable_space M] [has_add M] : Prop",
    "args": "(M : Type u_1) [measurable_space M] [has_add M]",
    "doc_string": " We say that a type `has_measurable_add` if `uncurry (+)` is a measurable functions. For a typeclass assuming measurability of `((+) c)` and `(+ c)` see `has_measurable_add`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "bornology.is_bounded.bounded_space_subtype",
    "statement": "theorem bornology.is_bounded.bounded_space_subtype {α : Type u_1} [bornology α] {p : α → Prop} : bornology.is_bounded {x : α | p x} → bounded_space (subtype p)",
    "theorem": "{α : Type u_1} [bornology α] {p : α → Prop} : bornology.is_bounded {x : α | p x} → bounded_space (subtype p)",
    "args": "{α : Type u_1} [bornology α] {p : α → Prop}",
    "doc_string": "**Alias** of the reverse direction of bounded_space_subtype_iff`.",
    "kind": "theorem",
    "type": "bornology.is_bounded {x : α | p x} → bounded_space (subtype p)"
  },
  {
    "name": "zero_ne_one_or_forall_eq_0",
    "statement": "theorem zero_ne_one_or_forall_eq_0 {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀]",
    "doc_string": "In a monoid with zero, either zero and one are nonequal, or zero is the only element.",
    "kind": "theorem",
    "type": "0 ≠ 1 ∨ ∀ (a : M₀), a = 0"
  },
  {
    "name": "int.to_nat'",
    "statement": "def int.to_nat'  : ℤ → option ℕ",
    "theorem": " : ℤ → option ℕ",
    "args": "",
    "doc_string": "If `n : ℕ`, then `int.to_nat' n = some n`, if `n : ℤ` is negative, then `int.to_nat' n = none`.",
    "kind": "def",
    "type": "ℤ → option ℕ"
  },
  {
    "name": "generalized_continued_fraction.terminates",
    "statement": "def generalized_continued_fraction.terminates {α : Type u_1} (g : generalized_continued_fraction α) : Prop",
    "theorem": "{α : Type u_1} (g : generalized_continued_fraction α) : Prop",
    "args": "{α : Type u_1} (g : generalized_continued_fraction α)",
    "doc_string": "A gcf terminates if its sequence terminates.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "dense_embedding.separable_space",
    "statement": "theorem dense_embedding.separable_space {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : α → β} (de : dense_embedding e) [topological_space.separable_space α] : topological_space.separable_space β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : α → β} (de : dense_embedding e) [topological_space.separable_space α] : topological_space.separable_space β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : α → β} (de : dense_embedding e) [topological_space.separable_space α]",
    "doc_string": "If the domain of a `dense_embedding` is a separable space, then so is its codomain.",
    "kind": "theorem",
    "type": "topological_space.separable_space β"
  },
  {
    "name": "is_compact.is_closed",
    "statement": "theorem is_compact.is_closed {α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s",
    "theorem": "{α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s",
    "args": "{α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s)",
    "doc_string": "In a `t2_space`, every compact set is closed.",
    "kind": "theorem",
    "type": "is_closed s"
  },
  {
    "name": "nat.cast_desc_factorial_two",
    "statement": "theorem nat.cast_desc_factorial_two (S : Type u_1) [ring S] (a : ℕ) : ↑(a.desc_factorial 2) = ↑a * (↑a - 1)",
    "theorem": "(S : Type u_1) [ring S] (a : ℕ) : ↑(a.desc_factorial 2) = ↑a * (↑a - 1)",
    "args": "(S : Type u_1) [ring S] (a : ℕ)",
    "doc_string": " Convenience lemma. The `a - 1` is not using truncated substraction, as opposed to the definition of `nat.desc_factorial` as a natural.",
    "kind": "theorem",
    "type": "↑(a.desc_factorial 2) = ↑a * (↑a - 1)"
  },
  {
    "name": "bounded_continuous_function.semilattice_inf",
    "statement": "def bounded_continuous_function.semilattice_inf {α : Type u} {β : Type v} [topological_space α] [normed_lattice_add_comm_group β] : semilattice_inf (bounded_continuous_function α β)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [normed_lattice_add_comm_group β] : semilattice_inf (bounded_continuous_function α β)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [normed_lattice_add_comm_group β]",
    "doc_string": "Continuous normed lattice group valued functions form a meet-semilattice",
    "kind": "def",
    "type": "semilattice_inf (bounded_continuous_function α β)"
  },
  {
    "name": "bitvec.not",
    "statement": "def bitvec.not {n : ℕ} : bitvec n → bitvec n",
    "theorem": "{n : ℕ} : bitvec n → bitvec n",
    "args": "{n : ℕ}",
    "doc_string": "bitwise not",
    "kind": "def",
    "type": "bitvec n → bitvec n"
  },
  {
    "name": "category_theory.End.monoid",
    "statement": "def category_theory.End.monoid {C : Type u} [category_theory.category C] {X : C} : monoid (category_theory.End X)",
    "theorem": "{C : Type u} [category_theory.category C] {X : C} : monoid (category_theory.End X)",
    "args": "{C : Type u} [category_theory.category C] {X : C}",
    "doc_string": "Endomorphisms of an object form a monoid",
    "kind": "def",
    "type": "monoid (category_theory.End X)"
  },
  {
    "name": "hinst_lemma",
    "statement": "constant hinst_lemma  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Heuristic instantiation lemma",
    "kind": "constant",
    "type": "Type"
  },
  {
    "name": "finite",
    "statement": "inductive finite (α : Sort u_1) : Prop",
    "theorem": "(α : Sort u_1) : Prop",
    "args": "(α : Sort u_1)",
    "doc_string": " A type is `finite` if it is in bijective correspondence to some `fin n`.  While this could be defined as `nonempty (fintype α)`, it is defined in this way to allow there to be `finite` instances for propositions.",
    "kind": "inductive",
    "type": "Prop"
  },
  {
    "name": "has_sbtw.sbtw.trans_right",
    "statement": "theorem has_sbtw.sbtw.trans_right {α : Type u_1} [circular_preorder α] {a b c d : α} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c d : α} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d",
    "args": "{α : Type u_1} [circular_preorder α] {a b c d : α} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d)",
    "doc_string": "**Alias** of sbtw_trans_right`.",
    "kind": "theorem",
    "type": "has_sbtw.sbtw a b d"
  },
  {
    "name": "measure_theory.measure.haar.add_index",
    "statement": "def measure_theory.measure.haar.add_index {G : Type u_1} [add_group G] (K V : set G) : ℕ",
    "theorem": "{G : Type u_1} [add_group G] (K V : set G) : ℕ",
    "args": "{G : Type u_1} [add_group G] (K V : set G)",
    "doc_string": "additive version of `measure_theory.measure.haar.index`",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "function.partial_inv",
    "statement": "def function.partial_inv {α : Type u_1} {β : Sort u_2} (f : α → β) (b : β) : option α",
    "theorem": "{α : Type u_1} {β : Sort u_2} (f : α → β) (b : β) : option α",
    "args": "{α : Type u_1} {β : Sort u_2} (f : α → β) (b : β)",
    "doc_string": "We can use choice to construct explicitly a partial inverse for  a given injective function `f`.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "znum.gcd",
    "statement": "def znum.gcd (a b : znum) : num",
    "theorem": "(a b : znum) : num",
    "args": "(a b : znum)",
    "doc_string": "Greatest Common Divisor (GCD) of two `znum`s.",
    "kind": "def",
    "type": "num"
  },
  {
    "name": "Set.pair_sep",
    "statement": "def Set.pair_sep (p : Set → Set → Prop) (x y : Set) : Set",
    "theorem": "(p : Set → Set → Prop) (x y : Set) : Set",
    "args": "(p : Set → Set → Prop) (x y : Set)",
    "doc_string": "A subset of pairs `{(a, b) ∈ x × y | p a b}`",
    "kind": "def",
    "type": "Set"
  },
  {
    "name": "set.is_wf",
    "statement": "def set.is_wf {α : Type u_1} [has_lt α] (s : set α) : Prop",
    "theorem": "{α : Type u_1} [has_lt α] (s : set α) : Prop",
    "args": "{α : Type u_1} [has_lt α] (s : set α)",
    "doc_string": "`s.is_wf` indicates that `<` is well-founded when restricted to `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "simple_graph.edge_set",
    "statement": "def simple_graph.edge_set {V : Type u} (G : simple_graph V) : set (sym2 V)",
    "theorem": "{V : Type u} (G : simple_graph V) : set (sym2 V)",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": "The edges of G consist of the unordered pairs of vertices related by `G.adj`.  The way `edge_set` is defined is such that `mem_edge_set` is proved by `refl`. (That is, `⟦(v, w)⟧ ∈ G.edge_set` is definitionally equal to `G.adj v w`.)",
    "kind": "def",
    "type": "set (sym2 V)"
  },
  {
    "name": "list.revzip",
    "statement": "def list.revzip {α : Type u_1} (l : list α) : list (α × α)",
    "theorem": "{α : Type u_1} (l : list α) : list (α × α)",
    "args": "{α : Type u_1} (l : list α)",
    "doc_string": " `revzip l` returns a list of pairs of the elements of `l` paired   with the elements of `l` in reverse order.  `revzip [1,2,3,4,5] = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]`",
    "kind": "def",
    "type": "list (α × α)"
  },
  {
    "name": "euclidean_space",
    "statement": "def euclidean_space (𝕜 : Type u_1) [is_R_or_C 𝕜] (n : Type u_2) [fintype n] : Type (max u_2 u_1)",
    "theorem": "(𝕜 : Type u_1) [is_R_or_C 𝕜] (n : Type u_2) [fintype n] : Type (max u_2 u_1)",
    "args": "(𝕜 : Type u_1) [is_R_or_C 𝕜] (n : Type u_2) [fintype n]",
    "doc_string": " The standard real/complex Euclidean space, functions on a finite type. For an `n`-dimensional space use `euclidean_space 𝕜 (fin n)`.",
    "kind": "def",
    "type": "Type (max u_2 u_1)"
  },
  {
    "name": "alist.insert",
    "statement": "def alist.insert {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : alist β) : alist β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : alist β) : alist β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : alist β)",
    "doc_string": "Insert a key-value pair into an association list and erase any existing pair  with the same key.",
    "kind": "def",
    "type": "alist β"
  },
  {
    "name": "has_continuous_neg",
    "statement": "structure has_continuous_neg (G : Type u) [topological_space G] [has_neg G] : Prop",
    "theorem": "(G : Type u) [topological_space G] [has_neg G] : Prop",
    "args": "(G : Type u) [topological_space G] [has_neg G]",
    "doc_string": " Basic hypothesis to talk about a topological additive group. A topological additive group over `M`, for example, is obtained by requiring the instances `add_group M` and `has_continuous_add M` and `has_continuous_neg M`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "filter.lift'",
    "statement": "def filter.lift' {α : Type u_1} {β : Type u_2} (f : filter α) (h : set α → set β) : filter β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : filter α) (h : set α → set β) : filter β",
    "args": "{α : Type u_1} {β : Type u_2} (f : filter α) (h : set α → set β)",
    "doc_string": " Specialize `lift` to functions `set α → set β`. This can be viewed as a generalization of `map`. This is essentially a push-forward along a function mapping each set to a set.",
    "kind": "def",
    "type": "filter β"
  },
  {
    "name": "GroupWithZero",
    "statement": "def GroupWithZero  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of groups with zero.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "continuous_order_hom",
    "statement": "structure continuous_order_hom (α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [topological_space α] [topological_space β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [topological_space α] [topological_space β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [topological_space α] [topological_space β]",
    "doc_string": "The type of continuous monotone maps from `α` to `β`, aka Priestley homomorphisms.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "ordinal.typein.principal_seg",
    "statement": "def ordinal.typein.principal_seg {α : Type u} (r : α → α → Prop) [is_well_order α r] : principal_seg r has_lt.lt",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_well_order α r] : principal_seg r has_lt.lt",
    "args": "{α : Type u} (r : α → α → Prop) [is_well_order α r]",
    "doc_string": "Principal segment version of the `typein` function, embedding a well order into  ordinals as a principal segment.",
    "kind": "def",
    "type": "principal_seg r has_lt.lt"
  },
  {
    "name": "wseq.is_finite",
    "statement": "structure wseq.is_finite {α : Type u} (s : wseq α) : Prop",
    "theorem": "{α : Type u} (s : wseq α) : Prop",
    "args": "{α : Type u} (s : wseq α)",
    "doc_string": "A weak sequence is finite if `to_list s` terminates. Equivalently,  it is a finite number of `think` and `cons` applied to `nil`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nat.arithmetic_function.moebius",
    "statement": "def nat.arithmetic_function.moebius  : nat.arithmetic_function ℤ",
    "theorem": " : nat.arithmetic_function ℤ",
    "args": "",
    "doc_string": "`μ` is the Möbius function. If `n` is squarefree with an even number of distinct prime factors,  `μ n = 1`. If `n` is squarefree with an odd number of distinct prime factors, `μ n = -1`.  If `n` is not squarefree, `μ n = 0`.",
    "kind": "def",
    "type": "nat.arithmetic_function ℤ"
  },
  {
    "name": "non_unital_non_assoc_ring.int_smul_comm_class",
    "statement": "def non_unital_non_assoc_ring.int_smul_comm_class {R : Type u₁} [non_unital_non_assoc_ring R] : smul_comm_class ℤ R R",
    "theorem": "{R : Type u₁} [non_unital_non_assoc_ring R] : smul_comm_class ℤ R R",
    "args": "{R : Type u₁} [non_unital_non_assoc_ring R]",
    "doc_string": "Note that `add_comm_group.int_smul_comm_class` requires stronger assumptions on `R`.",
    "kind": "def",
    "type": "smul_comm_class ℤ R R"
  },
  {
    "name": "lt_inv_mul_of_mul_lt",
    "statement": "theorem lt_inv_mul_of_mul_lt {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a * b < c → b < a⁻¹ * c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a * b < c → b < a⁻¹ * c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of lt_inv_mul_iff_mul_lt`.",
    "kind": "theorem",
    "type": "a * b < c → b < a⁻¹ * c"
  },
  {
    "name": "Well_order",
    "statement": "structure Well_order  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": " Bundled structure registering a well order on a type. Ordinals will be defined as a quotient of this type.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "add_con.quotient",
    "statement": "def add_con.quotient {M : Type u_1} [has_add M] (c : add_con M) : Type u_1",
    "theorem": "{M : Type u_1} [has_add M] (c : add_con M) : Type u_1",
    "args": "{M : Type u_1} [has_add M] (c : add_con M)",
    "doc_string": "Defining the quotient by an additive congruence relation of a type with an addition.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "function.is_periodic_id",
    "statement": "theorem function.is_periodic_id {α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x",
    "theorem": "{α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x",
    "args": "{α : Type u_1} (n : ℕ) (x : α)",
    "doc_string": "For the identity map, all points are periodic.",
    "kind": "theorem",
    "type": "function.is_periodic_pt id n x"
  },
  {
    "name": "SemiRing.has_limits_of_size",
    "statement": "def SemiRing.has_limits_of_size  : category_theory.limits.has_limits_of_size SemiRing",
    "theorem": " : category_theory.limits.has_limits_of_size SemiRing",
    "args": "",
    "doc_string": "The category of rings has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size SemiRing"
  },
  {
    "name": "classical.dec_pred",
    "statement": "def classical.dec_pred {α : Sort u_1} (p : α → Prop) : decidable_pred p",
    "theorem": "{α : Sort u_1} (p : α → Prop) : decidable_pred p",
    "args": "{α : Sort u_1} (p : α → Prop)",
    "doc_string": "Any predicate `p` is decidable classically.",
    "kind": "def",
    "type": "decidable_pred p"
  },
  {
    "name": "witt_vector.standard_one_dim_isocrystal.isocrystal",
    "statement": "def witt_vector.standard_one_dim_isocrystal.isocrystal (p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (m : ℤ) : witt_vector.isocrystal p k (witt_vector.standard_one_dim_isocrystal p k m)",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (m : ℤ) : witt_vector.isocrystal p k (witt_vector.standard_one_dim_isocrystal p k m)",
    "args": "(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (m : ℤ)",
    "doc_string": "The standard one-dimensional isocrystal of slope `m : ℤ` is an isocrystal.",
    "kind": "def",
    "type": "witt_vector.isocrystal p k (witt_vector.standard_one_dim_isocrystal p k m)"
  },
  {
    "name": "right.add_neg",
    "statement": "theorem right.add_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "nzsnum.head",
    "statement": "def nzsnum.head  : nzsnum → bool",
    "theorem": " : nzsnum → bool",
    "args": "",
    "doc_string": "The `head` of a `nzsnum` is the boolean value of its LSB.",
    "kind": "def",
    "type": "nzsnum → bool"
  },
  {
    "name": "set.has_one",
    "statement": "def set.has_one {α : Type u_2} [has_one α] : has_one (set α)",
    "theorem": "{α : Type u_2} [has_one α] : has_one (set α)",
    "args": "{α : Type u_2} [has_one α]",
    "doc_string": "The set `1 : set α` is defined as `{1}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_one (set α)"
  },
  {
    "name": "category_theory.idempotents.karoubi.coe",
    "statement": "def category_theory.idempotents.karoubi.coe {C : Type u_1} [category_theory.category C] : has_coe_t C (category_theory.idempotents.karoubi C)",
    "theorem": "{C : Type u_1} [category_theory.category C] : has_coe_t C (category_theory.idempotents.karoubi C)",
    "args": "{C : Type u_1} [category_theory.category C]",
    "doc_string": " It is possible to coerce an object of `C` into an object of `karoubi C`. See also the functor `to_karoubi`.",
    "kind": "def",
    "type": "has_coe_t C (category_theory.idempotents.karoubi C)"
  },
  {
    "name": "nonneg.order_bot",
    "statement": "def nonneg.order_bot {α : Type u_1} [preorder α] {a : α} : order_bot {x // a ≤ x}",
    "theorem": "{α : Type u_1} [preorder α] {a : α} : order_bot {x // a ≤ x}",
    "args": "{α : Type u_1} [preorder α] {a : α}",
    "doc_string": " This instance uses data fields from `subtype.partial_order` to help type-class inference. The `set.Ici` data fields are definitionally equal, but that requires unfolding semireducible definitions, so type-class inference won't see this.",
    "kind": "def",
    "type": "order_bot {x // a ≤ x}"
  },
  {
    "name": "is_clopen",
    "statement": "def is_clopen {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "A set is clopen if it is both open and closed.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "first_order.language.Theory.is_complete",
    "statement": "def first_order.language.Theory.is_complete {L : first_order.language} (T : L.Theory) : Prop",
    "theorem": "{L : first_order.language} (T : L.Theory) : Prop",
    "args": "{L : first_order.language} (T : L.Theory)",
    "doc_string": "A theory is complete when it is satisfiable and models each sentence or its negation.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "matrix.vec_alt0",
    "statement": "def matrix.vec_alt0 {α : Type u} {m n : ℕ} (hm : m = n + n) (v : fin m → α) (k : fin n) : α",
    "theorem": "{α : Type u} {m n : ℕ} (hm : m = n + n) (v : fin m → α) (k : fin n) : α",
    "args": "{α : Type u} {m n : ℕ} (hm : m = n + n) (v : fin m → α) (k : fin n)",
    "doc_string": " `vec_alt0 v` gives a vector with half the length of `v`, with only alternate elements (even-numbered).",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "category_theory.pretopology.of_grothendieck",
    "statement": "def category_theory.pretopology.of_grothendieck (C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (J : category_theory.grothendieck_topology C) : category_theory.pretopology C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (J : category_theory.grothendieck_topology C) : category_theory.pretopology C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (J : category_theory.grothendieck_topology C)",
    "doc_string": "The largest pretopology generating the given Grothendieck topology.  See [MM92] Chapter III, Section 2, Equations (3,4).",
    "kind": "def",
    "type": "category_theory.pretopology C"
  },
  {
    "name": "uniform_space.completion.uniform_continuous_dist",
    "statement": "theorem uniform_space.completion.uniform_continuous_dist {α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd)",
    "theorem": "{α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd)",
    "args": "{α : Type u} [pseudo_metric_space α]",
    "doc_string": "The new distance is uniformly continuous.",
    "kind": "theorem",
    "type": "uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd)"
  },
  {
    "name": "denumerable.lower'",
    "statement": "def denumerable.lower'  : list ℕ → ℕ → list ℕ",
    "theorem": " : list ℕ → ℕ → list ℕ",
    "args": "",
    "doc_string": " Outputs the list of differences minus one of the input list, that is `lower' [a₁, a₂, a₃, ...] n = [a₁ - n, a₂ - a₁ - 1, a₃ - a₂ - 1, ...]`.",
    "kind": "def",
    "type": "list ℕ → ℕ → list ℕ"
  },
  {
    "name": "nat.modeq",
    "statement": "def nat.modeq (n a b : ℕ) : Prop",
    "theorem": "(n a b : ℕ) : Prop",
    "args": "(n a b : ℕ)",
    "doc_string": "Modular equality. `n.modeq a b`, or `a ≡ b [MOD n]`, means that `a - b` is a multiple of `n`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "turing.TM0.stmt",
    "statement": "inductive turing.TM0.stmt (Γ : Type u_1) [inhabited Γ] : Type u_1",
    "theorem": "(Γ : Type u_1) [inhabited Γ] : Type u_1",
    "args": "(Γ : Type u_1) [inhabited Γ]",
    "doc_string": "A Turing machine \"statement\" is just a command to either move  left or right, or write a symbol on the tape.",
    "kind": "inductive",
    "type": "Type u_1"
  },
  {
    "name": "add_submonoid.multiset_sum_mem",
    "statement": "theorem add_submonoid.multiset_sum_mem {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.sum ∈ S",
    "theorem": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S) : m.sum ∈ S",
    "args": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) (m : multiset M) (hm : ∀ (a : M), a ∈ m → a ∈ S)",
    "doc_string": "Sum of a multiset of elements in an `add_submonoid` of an `add_comm_monoid` is in the `add_submonoid`.",
    "kind": "theorem",
    "type": "m.sum ∈ S"
  },
  {
    "name": "vector_allp",
    "statement": "def vector_allp {α : Type u_1} {n : ℕ} (p : α → Prop) (v : vector3 α n) : Prop",
    "theorem": "{α : Type u_1} {n : ℕ} (p : α → Prop) (v : vector3 α n) : Prop",
    "args": "{α : Type u_1} {n : ℕ} (p : α → Prop) (v : vector3 α n)",
    "doc_string": "`vector_allp p v` is equivalent to `∀ i, p (v i)`, but unfolds directly to a conjunction,  i.e. `vector_allp p [0, 1, 2] = p 0 ∧ p 1 ∧ p 2`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subsemigroup.complete_lattice",
    "statement": "def subsemigroup.complete_lattice {M : Type u_1} [has_mul M] : complete_lattice (subsemigroup M)",
    "theorem": "{M : Type u_1} [has_mul M] : complete_lattice (subsemigroup M)",
    "args": "{M : Type u_1} [has_mul M]",
    "doc_string": "subsemigroups of a monoid form a complete lattice.",
    "kind": "def",
    "type": "complete_lattice (subsemigroup M)"
  },
  {
    "name": "vector.perm.is_setoid",
    "statement": "def vector.perm.is_setoid (α : Type u_1) (n : ℕ) : setoid (vector α n)",
    "theorem": "(α : Type u_1) (n : ℕ) : setoid (vector α n)",
    "args": "(α : Type u_1) (n : ℕ)",
    "doc_string": "This is the `list.perm` setoid lifted to `vector`.  See note [reducible non-instances].",
    "kind": "def",
    "type": "setoid (vector α n)"
  },
  {
    "name": "ordnode.balance_r'",
    "statement": "def ordnode.balance_r' {α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "theorem": "{α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "args": "{α : Type u_1} (l : ordnode α) (x : α) (r : ordnode α)",
    "doc_string": " A right balance operation. This will rebalance a concatenation, assuming the original nodes are not too far from balanced.",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "category_theory.locally_discrete_bicategory",
    "statement": "def category_theory.locally_discrete_bicategory (C : Type u) [category_theory.category C] : category_theory.bicategory (category_theory.locally_discrete C)",
    "theorem": "(C : Type u) [category_theory.category C] : category_theory.bicategory (category_theory.locally_discrete C)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "The locally discrete bicategory on a category is a bicategory in which the objects and the 1-morphisms are the same as those in the underlying category, and the 2-morphisms are the equalities between 1-morphisms.",
    "kind": "def",
    "type": "category_theory.bicategory (category_theory.locally_discrete C)"
  },
  {
    "name": "abstract_completion.prod",
    "statement": "def abstract_completion.prod {α : Type u_1} [uniform_space α] (pkg : abstract_completion α) {β : Type u_2} [uniform_space β] (pkg' : abstract_completion β) : abstract_completion (α × β)",
    "theorem": "{α : Type u_1} [uniform_space α] (pkg : abstract_completion α) {β : Type u_2} [uniform_space β] (pkg' : abstract_completion β) : abstract_completion (α × β)",
    "args": "{α : Type u_1} [uniform_space α] (pkg : abstract_completion α) {β : Type u_2} [uniform_space β] (pkg' : abstract_completion β)",
    "doc_string": "Products of completions",
    "kind": "def",
    "type": "abstract_completion (α × β)"
  },
  {
    "name": "gold_conj_irrational",
    "statement": "theorem gold_conj_irrational  : irrational golden_conj",
    "theorem": " : irrational golden_conj",
    "args": "",
    "doc_string": "The conjugate of the golden ratio is irrational.",
    "kind": "theorem",
    "type": "irrational golden_conj"
  },
  {
    "name": "CommRing.has_limits_of_size",
    "statement": "def CommRing.has_limits_of_size  : category_theory.limits.has_limits_of_size CommRing",
    "theorem": " : category_theory.limits.has_limits_of_size CommRing",
    "args": "",
    "doc_string": "The category of commutative rings has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size CommRing"
  },
  {
    "name": "category_theory.limits.types.initial_colimit_cocone",
    "statement": "def category_theory.limits.types.initial_colimit_cocone  : category_theory.limits.colimit_cocone (category_theory.functor.empty (Type u))",
    "theorem": " : category_theory.limits.colimit_cocone (category_theory.functor.empty (Type u))",
    "args": "",
    "doc_string": "The category of types has `pempty` as an initial object.",
    "kind": "def",
    "type": "category_theory.limits.colimit_cocone (category_theory.functor.empty (Type u))"
  },
  {
    "name": "pseudo_emetric_space",
    "statement": "structure pseudo_emetric_space (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " Extended (pseudo) metric spaces, with an extended distance `edist` possibly taking the value ∞  Each pseudo_emetric space induces a canonical `uniform_space` and hence a canonical `topological_space`. This is enforced in the type class definition, by extending the `uniform_space` structure. When instantiating a `pseudo_emetric_space` structure, the uniformity fields are not necessary, they will be filled in by default. There is a default value for the uniformity, that can be substituted in cases of interest, for instance when instantiating a `pseudo_emetric_space` structure on a product.  Continuity of `edist` is proved in `topology.instances.ennreal`",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "nat.coprime_factors_disjoint",
    "statement": "theorem nat.coprime_factors_disjoint {a b : ℕ} (hab : a.coprime b) : a.factors.disjoint b.factors",
    "theorem": "{a b : ℕ} (hab : a.coprime b) : a.factors.disjoint b.factors",
    "args": "{a b : ℕ} (hab : a.coprime b)",
    "doc_string": "The sets of factors of coprime `a` and `b` are disjoint",
    "kind": "theorem",
    "type": "a.factors.disjoint b.factors"
  },
  {
    "name": "semiquot.pure",
    "statement": "def semiquot.pure {α : Type u_1} (a : α) : semiquot α",
    "theorem": "{α : Type u_1} (a : α) : semiquot α",
    "args": "{α : Type u_1} (a : α)",
    "doc_string": "`pure a` is `a` reinterpreted as an unspecified element of `{a}`.",
    "kind": "def",
    "type": "semiquot α"
  },
  {
    "name": "set.indicator",
    "statement": "def set.indicator {α : Type u_1} {M : Type u_2} [has_zero M] (s : set α) (f : α → M) : α → M",
    "theorem": "{α : Type u_1} {M : Type u_2} [has_zero M] (s : set α) (f : α → M) : α → M",
    "args": "{α : Type u_1} {M : Type u_2} [has_zero M] (s : set α) (f : α → M)",
    "doc_string": "`indicator s f a` is `f a` if `a ∈ s`, `0` otherwise.",
    "kind": "def",
    "type": "α → M"
  },
  {
    "name": "finsupp.lt_wf",
    "statement": "theorem finsupp.lt_wf (ι : Type u_3) : well_founded has_lt.lt",
    "theorem": "(ι : Type u_3) : well_founded has_lt.lt",
    "args": "(ι : Type u_3)",
    "doc_string": "The order on `ι →₀ ℕ` is well-founded.",
    "kind": "theorem",
    "type": "well_founded has_lt.lt"
  },
  {
    "name": "add_aut.group",
    "statement": "def add_aut.group (A : Type u_1) [has_add A] : group (add_aut A)",
    "theorem": "(A : Type u_1) [has_add A] : group (add_aut A)",
    "args": "(A : Type u_1) [has_add A]",
    "doc_string": "The group operation on additive automorphisms is defined by `λ g h, add_equiv.trans h g`. This means that multiplication agrees with composition, `(g*h)(x) = g (h x)`.",
    "kind": "def",
    "type": "group (add_aut A)"
  },
  {
    "name": "is_conj",
    "statement": "def is_conj {α : Type u} [monoid α] (a b : α) : Prop",
    "theorem": "{α : Type u} [monoid α] (a b : α) : Prop",
    "args": "{α : Type u} [monoid α] (a b : α)",
    "doc_string": "We say that `a` is conjugate to `b` if for some unit `c` we have `c * a * c⁻¹ = b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "inv_mem_class",
    "statement": "structure inv_mem_class (S : Type u_3) (G : Type u_4) [has_inv G] [set_like S G] : Type",
    "theorem": "(S : Type u_3) (G : Type u_4) [has_inv G] [set_like S G] : Type",
    "args": "(S : Type u_3) (G : Type u_4) [has_inv G] [set_like S G]",
    "doc_string": "`inv_mem_class S G` states `S` is a type of subsets `s ⊆ G` closed under inverses.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "int.gcd_least_linear",
    "statement": "theorem int.gcd_least_linear {a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)",
    "theorem": "{a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)",
    "args": "{a b : ℤ} (ha : a ≠ 0)",
    "doc_string": " For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`",
    "kind": "theorem",
    "type": "is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)"
  },
  {
    "name": "zero_lt.right.one_lt_mul_of_lt_of_le",
    "statement": "theorem zero_lt.right.one_lt_mul_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "antisymm_rel.eq",
    "statement": "theorem antisymm_rel.eq {α : Type u_1} {r : α → α → Prop} [is_refl α r] [is_antisymm α r] {a b : α} : antisymm_rel r a b → a = b",
    "theorem": "{α : Type u_1} {r : α → α → Prop} [is_refl α r] [is_antisymm α r] {a b : α} : antisymm_rel r a b → a = b",
    "args": "{α : Type u_1} {r : α → α → Prop} [is_refl α r] [is_antisymm α r] {a b : α}",
    "doc_string": "**Alias** of the forward direction of antisymm_rel_iff_eq`.",
    "kind": "theorem",
    "type": "antisymm_rel r a b → a = b"
  },
  {
    "name": "quotient_add_group.left_rel",
    "statement": "def quotient_add_group.left_rel {α : Type u_1} [add_group α] (s : add_subgroup α) : setoid α",
    "theorem": "{α : Type u_1} [add_group α] (s : add_subgroup α) : setoid α",
    "args": "{α : Type u_1} [add_group α] (s : add_subgroup α)",
    "doc_string": "The equivalence relation corresponding to the partition of a group by left cosets of a subgroup.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "fin.coe_fin_le",
    "statement": "theorem fin.coe_fin_le {n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b",
    "theorem": "{n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b",
    "args": "{n : ℕ} {a b : fin n}",
    "doc_string": "`a ≤ b` as natural numbers if and only if `a ≤ b` in `fin n`.",
    "kind": "theorem",
    "type": "↑a ≤ ↑b ↔ a ≤ b"
  },
  {
    "name": "pmf.to_measure",
    "statement": "def pmf.to_measure {α : Type u_1} [measurable_space α] (p : pmf α) : measure_theory.measure α",
    "theorem": "{α : Type u_1} [measurable_space α] (p : pmf α) : measure_theory.measure α",
    "args": "{α : Type u_1} [measurable_space α] (p : pmf α)",
    "doc_string": "Since every set is Carathéodory-measurable under `pmf.to_outer_measure`,  we can further extend this `outer_measure` to a `measure` on `α`",
    "kind": "def",
    "type": "measure_theory.measure α"
  },
  {
    "name": "polynomial.separable",
    "statement": "def polynomial.separable {R : Type u} [comm_semiring R] (f : polynomial R) : Prop",
    "theorem": "{R : Type u} [comm_semiring R] (f : polynomial R) : Prop",
    "args": "{R : Type u} [comm_semiring R] (f : polynomial R)",
    "doc_string": "A polynomial is separable iff it is coprime with its derivative.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "intermediate_field.to_subfield",
    "statement": "def intermediate_field.to_subfield {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : subfield L",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : subfield L",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L)",
    "doc_string": "Reinterpret an `intermediate_field` as a `subfield`.",
    "kind": "def",
    "type": "subfield L"
  },
  {
    "name": "pred_lt_pred",
    "statement": "theorem pred_lt_pred {α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : a < b → order.pred a < order.pred b",
    "theorem": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : a < b → order.pred a < order.pred b",
    "args": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α]",
    "doc_string": "**Alias** of the reverse direction of order.pred_lt_pred_iff`.",
    "kind": "theorem",
    "type": "a < b → order.pred a < order.pred b"
  },
  {
    "name": "list.fill_nones",
    "statement": "def list.fill_nones {α : Type u_1} : list (option α) → list α → list α",
    "theorem": "{α : Type u_1} : list (option α) → list α → list α",
    "args": "{α : Type u_1}",
    "doc_string": "`fill_nones xs ys` replaces the `none`s in `xs` with elements of `ys`. If there are not enough `ys` to replace all the `none`s, the remaining `none`s are dropped from `xs`.  ```lean fill_nones [none, some 1, none, none] [2, 3] = [2, 1, 3] ```",
    "kind": "def",
    "type": "list (option α) → list α → list α"
  },
  {
    "name": "simple_graph.preconnected",
    "statement": "def simple_graph.preconnected {V : Type u} (G : simple_graph V) : Prop",
    "theorem": "{V : Type u} (G : simple_graph V) : Prop",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": "A graph is preconnected if every pair of vertices is reachable from one another.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "krull_topology_totally_disconnected",
    "statement": "theorem krull_topology_totally_disconnected {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L)",
    "doc_string": "If `L/K` is an algebraic field extension, then the Krull topology on `L ≃ₐ[K] L` is  totally disconnected.",
    "kind": "theorem",
    "type": "is_totally_disconnected set.univ"
  },
  {
    "name": "is_of_fin_order_zero",
    "statement": "theorem is_of_fin_order_zero {G : Type u} [add_monoid G] : is_of_fin_add_order 0",
    "theorem": "{G : Type u} [add_monoid G] : is_of_fin_add_order 0",
    "args": "{G : Type u} [add_monoid G]",
    "doc_string": "0 is of finite order in any additive monoid.",
    "kind": "theorem",
    "type": "is_of_fin_add_order 0"
  },
  {
    "name": "zero_lt.mul_pos_reflect_lt",
    "statement": "def zero_lt.mul_pos_reflect_lt (X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop",
    "theorem": "(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop",
    "args": "(X : Type u) [has_mul X] [has_zero X] [has_lt X]",
    "doc_string": "  `zero_lt.mul_pos_reflect_lt α` is an abbreviation for `contravariant_class α>0 α (λ x y, y * x) (<)`, expressing that multiplication by positive elements on the right is strictly reverse monotone.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_add_left_regular.add",
    "statement": "theorem is_add_left_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b)",
    "doc_string": "In an additive semigroup, the sum of add-left-regular elements is add-left.regular.",
    "kind": "theorem",
    "type": "is_add_left_regular (a + b)"
  },
  {
    "name": "denumerable.sigma",
    "statement": "def denumerable.sigma {α : Type u_1} [denumerable α] {γ : α → Type u_3} [Π (a : α), denumerable (γ a)] : denumerable (sigma γ)",
    "theorem": "{α : Type u_1} [denumerable α] {γ : α → Type u_3} [Π (a : α), denumerable (γ a)] : denumerable (sigma γ)",
    "args": "{α : Type u_1} [denumerable α] {γ : α → Type u_3} [Π (a : α), denumerable (γ a)]",
    "doc_string": "A denumerable collection of denumerable types is denumerable.",
    "kind": "def",
    "type": "denumerable (sigma γ)"
  },
  {
    "name": "category_theory.limits.has_zero_object.has_zero",
    "statement": "def category_theory.limits.has_zero_object.has_zero (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] : has_zero C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] : has_zero C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C]",
    "doc_string": "Construct a `has_zero C` for a category with a zero object. This can not be a global instance as it will trigger for every `has_zero C` typeclass search.",
    "kind": "def",
    "type": "has_zero C"
  },
  {
    "name": "tactic.rewrite_cfg",
    "statement": "structure tactic.rewrite_cfg  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration options for the `rewrite` tactic.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "lower_adjoint.closed",
    "statement": "def lower_adjoint.closed {α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) : set α",
    "theorem": "{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) : set α",
    "args": "{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u)",
    "doc_string": "An element `x` is closed for `l : lower_adjoint u` if it is a fixed point: `u (l x) = x`",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "polynomial.nth_roots_finset",
    "statement": "def polynomial.nth_roots_finset (n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : finset R",
    "theorem": "(n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : finset R",
    "args": "(n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R]",
    "doc_string": "The multiset `nth_roots ↑n (1 : R)` as a finset.",
    "kind": "def",
    "type": "finset R"
  },
  {
    "name": "dfinsupp.pre",
    "statement": "structure dfinsupp.pre (ι : Type u) (β : ι → Type v) [Π (i : ι), has_zero (β i)] : Type (max u v)",
    "theorem": "(ι : Type u) (β : ι → Type v) [Π (i : ι), has_zero (β i)] : Type (max u v)",
    "args": "(ι : Type u) (β : ι → Type v) [Π (i : ι), has_zero (β i)]",
    "doc_string": " An auxiliary structure used in the definition of of `dfinsupp`, the type used to make infinite direct sum of modules over a ring.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "mul_hom",
    "statement": "structure mul_hom (M : Type u_9) (N : Type u_10) [has_mul M] [has_mul N] : Type (max u_10 u_9)",
    "theorem": "(M : Type u_9) (N : Type u_10) [has_mul M] [has_mul N] : Type (max u_10 u_9)",
    "args": "(M : Type u_9) (N : Type u_10) [has_mul M] [has_mul N]",
    "doc_string": " `M →ₙ* N` is the type of functions `M → N` that preserve multiplication. The `ₙ` in the notation stands for \"non-unital\" because it is intended to match the notation for `non_unital_alg_hom` and `non_unital_ring_hom`, so a `mul_hom` is a non-unital monoid hom.  When possible, instead of parametrizing results over `(f : M →ₙ* N)`, you should parametrize over `(F : Type*) [mul_hom_class F M N] (f : F)`. When you extend this structure, make sure to extend `mul_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_10 u_9)"
  },
  {
    "name": "ordered_comm_group.lt_of_mul_lt_mul_left",
    "statement": "theorem ordered_comm_group.lt_of_mul_lt_mul_left {α : Type u_1} [has_mul α] [has_lt α] [contravariant_class α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c) : b < c",
    "theorem": "{α : Type u_1} [has_mul α] [has_lt α] [contravariant_class α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c) : b < c",
    "args": "{α : Type u_1} [has_mul α] [has_lt α] [contravariant_class α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c)",
    "doc_string": "**Alias** of lt_of_mul_lt_mul_left'`.",
    "kind": "theorem",
    "type": "b < c"
  },
  {
    "name": "turing.list_blank.tail",
    "statement": "def turing.list_blank.tail {Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank Γ",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank Γ",
    "args": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ)",
    "doc_string": "The tail of a `list_blank` is well defined (up to the tail of blanks).",
    "kind": "def",
    "type": "turing.list_blank Γ"
  },
  {
    "name": "cartan_matrix.F₄",
    "statement": "def cartan_matrix.F₄  : matrix (fin 4) (fin 4) ℤ",
    "theorem": " : matrix (fin 4) (fin 4) ℤ",
    "args": "",
    "doc_string": " The Cartan matrix of type f₄. See [bourbaki1968] plate VIII, page 288.  The corresponding Dynkin diagram is: ```lean o --- o =>= o --- o ```",
    "kind": "def",
    "type": "matrix (fin 4) (fin 4) ℤ"
  },
  {
    "name": "first_order.language.age",
    "statement": "def first_order.language.age (L : first_order.language) (M : Type w) [L.Structure M] : set (category_theory.bundled L.Structure)",
    "theorem": "(L : first_order.language) (M : Type w) [L.Structure M] : set (category_theory.bundled L.Structure)",
    "args": "(L : first_order.language) (M : Type w) [L.Structure M]",
    "doc_string": "The age of a structure `M` is the class of finitely-generated structures that embed into it.",
    "kind": "def",
    "type": "set (category_theory.bundled L.Structure)"
  },
  {
    "name": "ordinal.induction",
    "statement": "theorem ordinal.induction {p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j) : p i",
    "theorem": "{p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j) : p i",
    "args": "{p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j)",
    "doc_string": " Reformulation of well founded induction on ordinals as a lemma that works with the `induction` tactic, as in `induction i using ordinal.induction with i IH`.",
    "kind": "theorem",
    "type": "p i"
  },
  {
    "name": "real.sinh_injective",
    "statement": "theorem real.sinh_injective  : function.injective real.sinh",
    "theorem": " : function.injective real.sinh",
    "args": "",
    "doc_string": "`sinh` is injective, `∀ a b, sinh a = sinh b → a = b`.",
    "kind": "theorem",
    "type": "function.injective real.sinh"
  },
  {
    "name": "omega.clause.unsat",
    "statement": "def omega.clause.unsat (c : omega.clause) : Prop",
    "theorem": "(c : omega.clause) : Prop",
    "args": "(c : omega.clause)",
    "doc_string": "unsat c := there is no valuation v under which c holds",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "right.neg_pos_iff",
    "statement": "theorem right.neg_pos_iff {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : 0 < -a ↔ a < 0",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : 0 < -a ↔ a < 0",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "kind": "theorem",
    "type": "0 < -a ↔ a < 0"
  },
  {
    "name": "homotopy_category",
    "statement": "def homotopy_category {ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape ι) : Type (max u u_1 v)",
    "theorem": "{ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape ι) : Type (max u u_1 v)",
    "args": "{ι : Type u_1} (V : Type u) [category_theory.category V] [category_theory.preadditive V] (c : complex_shape ι)",
    "doc_string": " `homotopy_category V c` is the category of chain complexes of shape `c` in `V`, with chain maps identified when they are homotopic.",
    "kind": "def",
    "type": "Type (max u u_1 v)"
  },
  {
    "name": "name.length",
    "statement": "def name.length  : name → ℕ",
    "theorem": " : name → ℕ",
    "args": "",
    "doc_string": "Returns the number of characters used to print all the string components of a name,  including periods between name segments. Ignores numerical parts of a name.",
    "kind": "def",
    "type": "name → ℕ"
  },
  {
    "name": "is_preirreducible_iff_closed_union_closed",
    "statement": "theorem is_preirreducible_iff_closed_union_closed {α : Type u} [topological_space α] {s : set α} : is_preirreducible s ↔ ∀ (z₁ z₂ : set α), is_closed z₁ → is_closed z₂ → s ⊆ z₁ ∪ z₂ → s ⊆ z₁ ∨ s ⊆ z₂",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : is_preirreducible s ↔ ∀ (z₁ z₂ : set α), is_closed z₁ → is_closed z₂ → s ⊆ z₁ ∪ z₂ → s ⊆ z₁ ∨ s ⊆ z₂",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": " A set is preirreducible if and only if for every cover by two closed sets, it is contained in one of the two covering sets.",
    "kind": "theorem",
    "type": "is_preirreducible s ↔ ∀ (z₁ z₂ : set α), is_closed z₁ → is_closed z₂ → s ⊆ z₁ ∪ z₂ → s ⊆ z₁ ∨ s ⊆ z₂"
  },
  {
    "name": "category_theory.category_struct",
    "statement": "structure category_theory.category_struct (obj : Type u) : Type (max u (v+1))",
    "theorem": "(obj : Type u) : Type (max u (v+1))",
    "args": "(obj : Type u)",
    "doc_string": " A preliminary structure on the way to defining a category, containing the data, but none of the axioms.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "surjective_quotient_mk",
    "statement": "theorem surjective_quotient_mk (α : Sort u_1) [s : setoid α] : function.surjective quotient.mk",
    "theorem": "(α : Sort u_1) [s : setoid α] : function.surjective quotient.mk",
    "args": "(α : Sort u_1) [s : setoid α]",
    "doc_string": "`quotient.mk` is a surjective function.",
    "kind": "theorem",
    "type": "function.surjective quotient.mk"
  },
  {
    "name": "submonoid",
    "statement": "structure submonoid (M : Type u_4) [mul_one_class M] : Type u_4",
    "theorem": "(M : Type u_4) [mul_one_class M] : Type u_4",
    "args": "(M : Type u_4) [mul_one_class M]",
    "doc_string": "A submonoid of a monoid `M` is a subset containing 1 and closed under multiplication.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "prime_spectrum.vanishing_ideal",
    "statement": "def prime_spectrum.vanishing_ideal {R : Type u} [comm_ring R] (t : set (prime_spectrum R)) : ideal R",
    "theorem": "{R : Type u} [comm_ring R] (t : set (prime_spectrum R)) : ideal R",
    "args": "{R : Type u} [comm_ring R] (t : set (prime_spectrum R))",
    "doc_string": " The vanishing ideal of a set `t` of points of the prime spectrum of a commutative ring `R` is the intersection of all the prime ideals in the set `t`.  An element `f` of `R` can be thought of as a dependent function on the prime spectrum of `R`. At a point `x` (a prime ideal) the function (i.e., element) `f` takes values in the quotient ring `R` modulo the prime ideal `x`. In this manner, `vanishing_ideal t` is exactly the ideal of `R` consisting of all \"functions\" that vanish on all of `t`.",
    "kind": "def",
    "type": "ideal R"
  },
  {
    "name": "Profinite.as_limit_cone",
    "statement": "def Profinite.as_limit_cone (X : Profinite) : category_theory.limits.cone X.diagram",
    "theorem": "(X : Profinite) : category_theory.limits.cone X.diagram",
    "args": "(X : Profinite)",
    "doc_string": "A cone over `X.diagram` whose cone point is `X`.",
    "kind": "def",
    "type": "category_theory.limits.cone X.diagram"
  },
  {
    "name": "has_vadd.comp",
    "statement": "def has_vadd.comp {M : Type u_1} {N : Type u_2} (α : Type u_6) [has_vadd M α] (g : N → M) : has_vadd N α",
    "theorem": "{M : Type u_1} {N : Type u_2} (α : Type u_6) [has_vadd M α] (g : N → M) : has_vadd N α",
    "args": "{M : Type u_1} {N : Type u_2} (α : Type u_6) [has_vadd M α] (g : N → M)",
    "doc_string": "An additive action of `M` on `α` and a function `N → M` induces  an additive action of `N` on `α`",
    "kind": "def",
    "type": "has_vadd N α"
  },
  {
    "name": "non_unital_non_assoc_ring.int_is_scalar_tower",
    "statement": "def non_unital_non_assoc_ring.int_is_scalar_tower {R : Type u₁} [non_unital_non_assoc_ring R] : is_scalar_tower ℤ R R",
    "theorem": "{R : Type u₁} [non_unital_non_assoc_ring R] : is_scalar_tower ℤ R R",
    "args": "{R : Type u₁} [non_unital_non_assoc_ring R]",
    "doc_string": "Note that `add_comm_group.int_is_scalar_tower` requires stronger assumptions on `R`.",
    "kind": "def",
    "type": "is_scalar_tower ℤ R R"
  },
  {
    "name": "add_group_filter_basis.topology",
    "statement": "def add_group_filter_basis.topology {G : Type u} [add_group G] (B : add_group_filter_basis G) : topological_space G",
    "theorem": "{G : Type u} [add_group G] (B : add_group_filter_basis G) : topological_space G",
    "args": "{G : Type u} [add_group G] (B : add_group_filter_basis G)",
    "doc_string": "The topological space structure coming from an additive group filter basis.",
    "kind": "def",
    "type": "topological_space G"
  },
  {
    "name": "group.normal_closure_subset",
    "statement": "theorem group.normal_closure_subset {G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t",
    "theorem": "{G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t",
    "args": "{G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t)",
    "doc_string": "The normal closure of s is the smallest normal subgroup containing s.",
    "kind": "theorem",
    "type": "group.normal_closure s ⊆ t"
  },
  {
    "name": "set.Inter",
    "statement": "def set.Inter {β : Type u_2} {ι : Sort u_4} (s : ι → set β) : set β",
    "theorem": "{β : Type u_2} {ι : Sort u_4} (s : ι → set β) : set β",
    "args": "{β : Type u_2} {ι : Sort u_4} (s : ι → set β)",
    "doc_string": "Indexed intersection of a family of sets",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "add_units.simps.coe_neg",
    "statement": "def add_units.simps.coe_neg {α : Type u} [add_monoid α] (u : add_units α) : α",
    "theorem": "{α : Type u} [add_monoid α] (u : add_units α) : α",
    "args": "{α : Type u} [add_monoid α] (u : add_units α)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "set.inj_on.to_local_equiv",
    "statement": "def set.inj_on.to_local_equiv {α : Type u_1} {β : Type u_2} [nonempty α] (f : α → β) (s : set α) (hf : set.inj_on f s) : local_equiv α β",
    "theorem": "{α : Type u_1} {β : Type u_2} [nonempty α] (f : α → β) (s : set α) (hf : set.inj_on f s) : local_equiv α β",
    "args": "{α : Type u_1} {β : Type u_2} [nonempty α] (f : α → β) (s : set α) (hf : set.inj_on f s)",
    "doc_string": "A map injective on a subset of its domain provides a local equivalence.",
    "kind": "def",
    "type": "local_equiv α β"
  },
  {
    "name": "subsingleton_floor_semiring",
    "statement": "theorem subsingleton_floor_semiring {α : Type u_1} [linear_ordered_semiring α] : subsingleton (floor_semiring α)",
    "theorem": "{α : Type u_1} [linear_ordered_semiring α] : subsingleton (floor_semiring α)",
    "args": "{α : Type u_1} [linear_ordered_semiring α]",
    "doc_string": "There exists at most one `floor_semiring` structure on a linear ordered semiring.",
    "kind": "theorem",
    "type": "subsingleton (floor_semiring α)"
  },
  {
    "name": "locally_constant.comap",
    "statement": "def locally_constant.comap {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] [topological_space Y] (f : X → Y) : locally_constant Y Z → locally_constant X Z",
    "theorem": "{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] [topological_space Y] (f : X → Y) : locally_constant Y Z → locally_constant X Z",
    "args": "{X : Type u_1} {Y : Type u_2} {Z : Type u_3} [topological_space X] [topological_space Y] (f : X → Y)",
    "doc_string": " Pull back of locally constant maps under any map, by pre-composition.  This definition only makes sense if `f` is continuous, in which case it sends locally constant functions to their precomposition with `f`. See also `locally_constant.coe_comap`.",
    "kind": "def",
    "type": "locally_constant Y Z → locally_constant X Z"
  },
  {
    "name": "nnreal.has_sum_geometric",
    "statement": "theorem nnreal.has_sum_geometric {r : nnreal} (hr : r < 1) : has_sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹",
    "theorem": "{r : nnreal} (hr : r < 1) : has_sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹",
    "args": "{r : nnreal} (hr : r < 1)",
    "doc_string": "**Sum of a Geometric Series**",
    "kind": "theorem",
    "type": "has_sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹"
  },
  {
    "name": "add_subgroup.gi",
    "statement": "def add_subgroup.gi (G : Type u_1) [add_group G] : galois_insertion add_subgroup.closure coe",
    "theorem": "(G : Type u_1) [add_group G] : galois_insertion add_subgroup.closure coe",
    "args": "(G : Type u_1) [add_group G]",
    "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
    "kind": "def",
    "type": "galois_insertion add_subgroup.closure coe"
  },
  {
    "name": "function.is_partial_inv",
    "statement": "def function.is_partial_inv {α : Type u_1} {β : Sort u_2} (f : α → β) (g : β → option α) : Prop",
    "theorem": "{α : Type u_1} {β : Sort u_2} (f : α → β) (g : β → option α) : Prop",
    "args": "{α : Type u_1} {β : Sort u_2} (f : α → β) (g : β → option α)",
    "doc_string": "`g` is a partial inverse to `f` (an injective but not necessarily  surjective function) if `g y = some x` implies `f x = y`, and `g y = none`  implies that `y` is not in the range of `f`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "algebraic_geometry.structure_presheaf_in_CommRing",
    "statement": "def algebraic_geometry.structure_presheaf_in_CommRing (R : Type u) [comm_ring R] : Top.presheaf CommRing (algebraic_geometry.prime_spectrum.Top R)",
    "theorem": "(R : Type u) [comm_ring R] : Top.presheaf CommRing (algebraic_geometry.prime_spectrum.Top R)",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "The structure presheaf, valued in `CommRing`, constructed by dressing up the `Type` valued structure presheaf.",
    "kind": "def",
    "type": "Top.presheaf CommRing (algebraic_geometry.prime_spectrum.Top R)"
  },
  {
    "name": "finset.falling",
    "statement": "def finset.falling {α : Type u_2} [decidable_eq α] (k : ℕ) (𝒜 : finset (finset α)) : finset (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] (k : ℕ) (𝒜 : finset (finset α)) : finset (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] (k : ℕ) (𝒜 : finset (finset α))",
    "doc_string": "`falling k 𝒜` is all the finsets of cardinality `k` which are a subset of something in `𝒜`.",
    "kind": "def",
    "type": "finset (finset α)"
  },
  {
    "name": "category_theory.decomposed",
    "statement": "def category_theory.decomposed (J : Type u₁) [category_theory.category J] : Type u₁",
    "theorem": "(J : Type u₁) [category_theory.category J] : Type u₁",
    "args": "(J : Type u₁) [category_theory.category J]",
    "doc_string": "The disjoint union of `J`s connected components, written explicitly as a sigma-type with the category structure. This category is equivalent to `J`.",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "order.partial_iso.comm",
    "statement": "def order.partial_iso.comm {α : Type u_1} {β : Type u_2} [linear_order α] [linear_order β] : order.partial_iso α β → order.partial_iso β α",
    "theorem": "{α : Type u_1} {β : Type u_2} [linear_order α] [linear_order β] : order.partial_iso α β → order.partial_iso β α",
    "args": "{α : Type u_1} {β : Type u_2} [linear_order α] [linear_order β]",
    "doc_string": "A partial isomorphism between `α` and `β` is also a partial isomorphism between `β` and `α`.",
    "kind": "def",
    "type": "order.partial_iso α β → order.partial_iso β α"
  },
  {
    "name": "uniform_continuous",
    "statement": "def uniform_continuous {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β)",
    "doc_string": " A function `f : α → β` is *uniformly continuous* if `(f x, f y)` tends to the diagonal as `(x, y)` tends to the diagonal. In other words, if `x` is sufficiently close to `y`, then `f x` is close to `f y` no matter where `x` and `y` are located in `α`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "measure_theory.simple_func.eapprox",
    "statement": "def measure_theory.simple_func.eapprox {α : Type u_1} [measurable_space α] : (α → ennreal) → ℕ → measure_theory.simple_func α ennreal",
    "theorem": "{α : Type u_1} [measurable_space α] : (α → ennreal) → ℕ → measure_theory.simple_func α ennreal",
    "args": "{α : Type u_1} [measurable_space α]",
    "doc_string": "Approximate a function `α → ℝ≥0∞` by a sequence of simple functions.",
    "kind": "def",
    "type": "(α → ennreal) → ℕ → measure_theory.simple_func α ennreal"
  },
  {
    "name": "ordnode.disjoint",
    "statement": "def ordnode.disjoint {α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → bool",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → bool",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le]",
    "doc_string": "O(m+n). Is every element of `t₁` not equivalent to any element of `t₂`?      disjoint {1, 3} {2, 4} = tt     disjoint {1, 2} {2, 4} = ff",
    "kind": "def",
    "type": "ordnode α → ordnode α → bool"
  },
  {
    "name": "con.has_Inf",
    "statement": "def con.has_Inf {M : Type u_1} [has_mul M] : has_Inf (con M)",
    "theorem": "{M : Type u_1} [has_mul M] : has_Inf (con M)",
    "args": "{M : Type u_1} [has_mul M]",
    "doc_string": "The infimum of a set of congruence relations on a given type with a multiplication.",
    "kind": "def",
    "type": "has_Inf (con M)"
  },
  {
    "name": "wseq.remove_nth",
    "statement": "def wseq.remove_nth {α : Type u} (s : wseq α) (n : ℕ) : wseq α",
    "theorem": "{α : Type u} (s : wseq α) (n : ℕ) : wseq α",
    "args": "{α : Type u} (s : wseq α) (n : ℕ)",
    "doc_string": "Remove the `n`th element of `s`.",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "add_hom.mul_right",
    "statement": "def add_hom.mul_right {R : Type u_1} [distrib R] (r : R) : add_hom R R",
    "theorem": "{R : Type u_1} [distrib R] (r : R) : add_hom R R",
    "args": "{R : Type u_1} [distrib R] (r : R)",
    "doc_string": "Left multiplication by an element of a type with distributive multiplication is an `add_hom`.",
    "kind": "def",
    "type": "add_hom R R"
  },
  {
    "name": "filter.limsup",
    "statement": "def filter.limsup {α : Type u_1} {β : Type u_2} [conditionally_complete_lattice α] (f : filter β) (u : β → α) : α",
    "theorem": "{α : Type u_1} {β : Type u_2} [conditionally_complete_lattice α] (f : filter β) (u : β → α) : α",
    "args": "{α : Type u_1} {β : Type u_2} [conditionally_complete_lattice α] (f : filter β) (u : β → α)",
    "doc_string": " The `limsup` of a function `u` along a filter `f` is the infimum of the `a` such that, eventually for `f`, holds `u x ≤ a`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "commute.refl",
    "statement": "theorem commute.refl {S : Type u_1} [has_mul S] (a : S) : commute a a",
    "theorem": "{S : Type u_1} [has_mul S] (a : S) : commute a a",
    "args": "{S : Type u_1} [has_mul S] (a : S)",
    "doc_string": "Any element commutes with itself.",
    "kind": "theorem",
    "type": "commute a a"
  },
  {
    "name": "right.neg_neg_iff",
    "statement": "theorem right.neg_neg_iff {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "kind": "theorem",
    "type": "-a < 0 ↔ 0 < a"
  },
  {
    "name": "power_series.X",
    "statement": "def power_series.X {R : Type u_1} [semiring R] : power_series R",
    "theorem": "{R : Type u_1} [semiring R] : power_series R",
    "args": "{R : Type u_1} [semiring R]",
    "doc_string": "The variable of the formal power series ring.",
    "kind": "def",
    "type": "power_series R"
  },
  {
    "name": "list.map_with_index",
    "statement": "def list.map_with_index {α : Type u} {β : Type v} (f : ℕ → α → β) (as : list α) : list β",
    "theorem": "{α : Type u} {β : Type v} (f : ℕ → α → β) (as : list α) : list β",
    "args": "{α : Type u} {β : Type v} (f : ℕ → α → β) (as : list α)",
    "doc_string": " Given a function `f : ℕ → α → β` and `as : list α`, `as = [a₀, a₁, ...]`, returns the list `[f 0 a₀, f 1 a₁, ...]`.",
    "kind": "def",
    "type": "list β"
  },
  {
    "name": "add_subgroup",
    "statement": "structure add_subgroup (G : Type u_3) [add_group G] : Type u_3",
    "theorem": "(G : Type u_3) [add_group G] : Type u_3",
    "args": "(G : Type u_3) [add_group G]",
    "doc_string": " An additive subgroup of an additive group `G` is a subset containing 0, closed under addition and additive inverse.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "free_non_unital_non_assoc_algebra.of",
    "statement": "def free_non_unital_non_assoc_algebra.of (R : Type u) {X : Type v} [semiring R] : X → free_non_unital_non_assoc_algebra R X",
    "theorem": "(R : Type u) {X : Type v} [semiring R] : X → free_non_unital_non_assoc_algebra R X",
    "args": "(R : Type u) {X : Type v} [semiring R]",
    "doc_string": "The embedding of `X` into the free algebra with coefficients in `R`.",
    "kind": "def",
    "type": "X → free_non_unital_non_assoc_algebra R X"
  },
  {
    "name": "is_topological_fiber_bundle",
    "statement": "def is_topological_fiber_bundle {B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B) : Prop",
    "theorem": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B) : Prop",
    "args": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B)",
    "doc_string": " A topological fiber bundle with fiber `F` over a base `B` is a space projecting on `B` for which the fibers are all homeomorphic to `F`, such that the local situation around each point is a direct product.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "one_hom.with_top_map",
    "statement": "def one_hom.with_top_map {M : Type u_1} {N : Type u_2} [has_one M] [has_one N] (f : one_hom M N) : one_hom (with_top M) (with_top N)",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_one M] [has_one N] (f : one_hom M N) : one_hom (with_top M) (with_top N)",
    "args": "{M : Type u_1} {N : Type u_2} [has_one M] [has_one N] (f : one_hom M N)",
    "doc_string": "A version of `with_top.map` for `one_hom`s.",
    "kind": "def",
    "type": "one_hom (with_top M) (with_top N)"
  },
  {
    "name": "dvd_neg",
    "statement": "theorem dvd_neg {α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : a ∣ -b ↔ a ∣ b",
    "theorem": "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : a ∣ -b ↔ a ∣ b",
    "args": "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α)",
    "doc_string": " An element a of a semigroup with a distributive negation divides the negation of an element b iff a divides b.",
    "kind": "theorem",
    "type": "a ∣ -b ↔ a ∣ b"
  },
  {
    "name": "category_theory.is_codetecting",
    "statement": "def category_theory.is_codetecting {C : Type u} [category_theory.category C] (𝒢 : set C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (𝒢 : set C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (𝒢 : set C)",
    "doc_string": "We say that `𝒢` is a codetecting set if the functors `C(-, G)` collectively reflect    isomorphisms, i.e., if any `h` with codomain in `G` uniquely factors through `f`, then `f` is    an isomorphism.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.End.apply_has_faithful_smul",
    "statement": "def function.End.apply_has_faithful_smul {α : Type u_6} : has_faithful_smul (function.End α) α",
    "theorem": "{α : Type u_6} : has_faithful_smul (function.End α) α",
    "args": "{α : Type u_6}",
    "doc_string": "`function.End.apply_mul_action` is faithful.",
    "kind": "def",
    "type": "has_faithful_smul (function.End α) α"
  },
  {
    "name": "add_neg_of_neg_of_nonpos",
    "statement": "theorem add_neg_of_neg_of_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0)",
    "doc_string": "**Alias** of `left.add_neg_of_neg_of_nonpos`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "measure_theory.filtration",
    "statement": "structure measure_theory.filtration {α : Type u_1} (ι : Type u_2) [preorder ι] (m : measurable_space α) : Type (max u_1 u_2)",
    "theorem": "{α : Type u_1} (ι : Type u_2) [preorder ι] (m : measurable_space α) : Type (max u_1 u_2)",
    "args": "{α : Type u_1} (ι : Type u_2) [preorder ι] (m : measurable_space α)",
    "doc_string": " A `filtration` on measurable space `α` with σ-algebra `m` is a monotone sequence of sub-σ-algebras of `m`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "add_localization.away",
    "statement": "def add_localization.away {M : Type u_1} [add_comm_monoid M] (x : M) : Type u_1",
    "theorem": "{M : Type u_1} [add_comm_monoid M] (x : M) : Type u_1",
    "args": "{M : Type u_1} [add_comm_monoid M] (x : M)",
    "doc_string": "Given `x : M`, the localization of `M` at the submonoid generated by `x`, as a quotient.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "first_order.language.Theory.is_satisfiable",
    "statement": "def first_order.language.Theory.is_satisfiable {L : first_order.language} (T : L.Theory) : Prop",
    "theorem": "{L : first_order.language} (T : L.Theory) : Prop",
    "args": "{L : first_order.language} (T : L.Theory)",
    "doc_string": "A theory is satisfiable if a structure models it.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.End_monoidal",
    "statement": "def category_theory.End_monoidal {C : Type u_1} [category_theory.bicategory C] (X : C) : Type u_3",
    "theorem": "{C : Type u_1} [category_theory.bicategory C] (X : C) : Type u_3",
    "args": "{C : Type u_1} [category_theory.bicategory C] (X : C)",
    "doc_string": "The endomorphisms of an object in a bicategory can be considered as a monoidal category.",
    "kind": "def",
    "type": "Type u_3"
  },
  {
    "name": "multiset.pmap",
    "statement": "def multiset.pmap {α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (s : multiset α) : (∀ (a : α), a ∈ s → p a) → multiset β",
    "theorem": "{α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (s : multiset α) : (∀ (a : α), a ∈ s → p a) → multiset β",
    "args": "{α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (s : multiset α)",
    "doc_string": "Lift of the list `pmap` operation. Map a partial function `f` over a multiset  `s` whose elements are all in the domain of `f`.",
    "kind": "def",
    "type": "(∀ (a : α), a ∈ s → p a) → multiset β"
  },
  {
    "name": "multiset.ndinsert",
    "statement": "def multiset.ndinsert {α : Type u_1} [decidable_eq α] (a : α) (s : multiset α) : multiset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (a : α) (s : multiset α) : multiset α",
    "args": "{α : Type u_1} [decidable_eq α] (a : α) (s : multiset α)",
    "doc_string": "`ndinsert a s` is the lift of the list `insert` operation. This operation  does not respect multiplicities, unlike `cons`, but it is suitable as  an insert operation on `finset`.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "matrix.vec_alt1",
    "statement": "def matrix.vec_alt1 {α : Type u} {m n : ℕ} (hm : m = n + n) (v : fin m → α) (k : fin n) : α",
    "theorem": "{α : Type u} {m n : ℕ} (hm : m = n + n) (v : fin m → α) (k : fin n) : α",
    "args": "{α : Type u} {m n : ℕ} (hm : m = n + n) (v : fin m → α) (k : fin n)",
    "doc_string": " `vec_alt1 v` gives a vector with half the length of `v`, with only alternate elements (odd-numbered).",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "specialization_preorder",
    "statement": "def specialization_preorder (X : Type u_1) [topological_space X] : preorder X",
    "theorem": "(X : Type u_1) [topological_space X] : preorder X",
    "args": "(X : Type u_1) [topological_space X]",
    "doc_string": "Specialization forms a preorder on the topological space.",
    "kind": "def",
    "type": "preorder X"
  },
  {
    "name": "fintype.trunc_fin_bijection",
    "statement": "def fintype.trunc_fin_bijection (α : Type u_1) [fintype α] : trunc {f // function.bijective f}",
    "theorem": "(α : Type u_1) [fintype α] : trunc {f // function.bijective f}",
    "args": "(α : Type u_1) [fintype α]",
    "doc_string": " There is (computably) a bijection between `fin (card α)` and `α`.  Since it is not unique and depends on which permutation of the universe list is used, the bijection is wrapped in `trunc` to preserve computability.  See `fintype.trunc_equiv_fin` for a version that gives an equivalence given `[decidable_eq α]`.",
    "kind": "def",
    "type": "trunc {f // function.bijective f}"
  },
  {
    "name": "is_irreducible.generic_point",
    "statement": "def is_irreducible.generic_point {α : Type u_1} [topological_space α] [quasi_sober α] {S : set α} (hS : is_irreducible S) : α",
    "theorem": "{α : Type u_1} [topological_space α] [quasi_sober α] {S : set α} (hS : is_irreducible S) : α",
    "args": "{α : Type u_1} [topological_space α] [quasi_sober α] {S : set α} (hS : is_irreducible S)",
    "doc_string": "A generic point of the closure of an irreducible space.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "ordnode.split_max'",
    "statement": "def ordnode.split_max' {α : Type u} : ordnode α → α → ordnode α → ordnode α × α",
    "theorem": "{α : Type u} : ordnode α → α → ordnode α → ordnode α × α",
    "args": "{α : Type u}",
    "doc_string": " **Internal use only**, because it requires a balancing constraint on the inputs.  O(log n). Extract and remove the maximum element from a nonempty tree.",
    "kind": "def",
    "type": "ordnode α → α → ordnode α → ordnode α × α"
  },
  {
    "name": "topological_group.continuous_conj'",
    "statement": "theorem topological_group.continuous_conj' {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (λ (g : G), g * h * g⁻¹)",
    "theorem": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (λ (g : G), g * h * g⁻¹)",
    "args": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G)",
    "doc_string": " Conjugation acting on fixed element of the group is continuous when both `mul` and `inv` are continuous.",
    "kind": "theorem",
    "type": "continuous (λ (g : G), g * h * g⁻¹)"
  },
  {
    "name": "finprod",
    "statement": "def finprod {M : Type u_2} {α : Sort u_4} [comm_monoid M] (f : α → M) : M",
    "theorem": "{M : Type u_2} {α : Sort u_4} [comm_monoid M] (f : α → M) : M",
    "args": "{M : Type u_2} {α : Sort u_4} [comm_monoid M] (f : α → M)",
    "doc_string": " Product of `f x` as `x` ranges over the elements of the multiplicative support of `f`, if it's finite. One otherwise.",
    "kind": "def",
    "type": "M"
  },
  {
    "name": "equiv.perm.cycle_of",
    "statement": "def equiv.perm.cycle_of {α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) (x : α) : equiv.perm α",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) (x : α) : equiv.perm α",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α] (f : equiv.perm α) (x : α)",
    "doc_string": "`f.cycle_of x` is the cycle of the permutation `f` to which `x` belongs.",
    "kind": "def",
    "type": "equiv.perm α"
  },
  {
    "name": "lt_of_inv_lt_inv",
    "statement": "theorem lt_of_inv_lt_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b⁻¹ → b < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a⁻¹ < b⁻¹ → b < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the forward direction of inv_lt_inv_iff`.",
    "kind": "theorem",
    "type": "a⁻¹ < b⁻¹ → b < a"
  },
  {
    "name": "has_measurable_sup",
    "statement": "structure has_measurable_sup (M : Type u_1) [measurable_space M] [has_sup M] : Prop",
    "theorem": "(M : Type u_1) [measurable_space M] [has_sup M] : Prop",
    "args": "(M : Type u_1) [measurable_space M] [has_sup M]",
    "doc_string": " We say that a type `has_measurable_sup` if `((⊔) c)` and `(⊔ c)` are measurable functions. For a typeclass assuming measurability of `uncurry (⊔)` see `has_measurable_sup₂`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "bounded_continuous_function.dist_zero_of_empty",
    "statement": "theorem bounded_continuous_function.dist_zero_of_empty {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α]",
    "doc_string": "On an empty space, bounded continuous functions are at distance 0",
    "kind": "theorem",
    "type": "has_dist.dist f g = 0"
  },
  {
    "name": "isometry.right_inv",
    "statement": "theorem isometry.right_inv {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {g : β → α} (h : isometry f) (hg : function.right_inverse g f) : isometry g",
    "theorem": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {g : β → α} (h : isometry f) (hg : function.right_inverse g f) : isometry g",
    "args": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {g : β → α} (h : isometry f) (hg : function.right_inverse g f)",
    "doc_string": "The right inverse of an isometry is an isometry.",
    "kind": "theorem",
    "type": "isometry g"
  },
  {
    "name": "tropical.has_mul",
    "statement": "def tropical.has_mul {R : Type u} [has_add R] : has_mul (tropical R)",
    "theorem": "{R : Type u} [has_add R] : has_mul (tropical R)",
    "args": "{R : Type u} [has_add R]",
    "doc_string": "Tropical multiplication is the addition in the underlying `R`.",
    "kind": "def",
    "type": "has_mul (tropical R)"
  },
  {
    "name": "add_le_of_le_sub_left",
    "statement": "theorem add_le_of_le_sub_left {α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ c - a → a + b ≤ c",
    "theorem": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ c - a → a + b ≤ c",
    "args": "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of le_sub_iff_add_le'`.",
    "kind": "theorem",
    "type": "b ≤ c - a → a + b ≤ c"
  },
  {
    "name": "submonoid.subsemiring_closure",
    "statement": "def submonoid.subsemiring_closure {R : Type u} [non_assoc_semiring R] (M : submonoid R) : subsemiring R",
    "theorem": "{R : Type u} [non_assoc_semiring R] (M : submonoid R) : subsemiring R",
    "args": "{R : Type u} [non_assoc_semiring R] (M : submonoid R)",
    "doc_string": "The additive closure of a submonoid is a subsemiring.",
    "kind": "def",
    "type": "subsemiring R"
  },
  {
    "name": "filter.principal",
    "statement": "def filter.principal {α : Type u} (s : set α) : filter α",
    "theorem": "{α : Type u} (s : set α) : filter α",
    "args": "{α : Type u} (s : set α)",
    "doc_string": "The principal filter of `s` is the collection of all supersets of `s`.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "monoid_algebra.finite_type_iff_fg",
    "statement": "theorem monoid_algebra.finite_type_iff_fg {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) ↔ monoid.fg M",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) ↔ monoid.fg M",
    "args": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R]",
    "doc_string": "A monoid `M` is finitely generated if and only if `monoid_algebra R M` is of finite type.",
    "kind": "theorem",
    "type": "algebra.finite_type R (monoid_algebra R M) ↔ monoid.fg M"
  },
  {
    "name": "lazy_list",
    "statement": "inductive lazy_list (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Lazy list. All elements (except the first) are computed lazily.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "seq.drop",
    "statement": "def seq.drop {α : Type u} (s : seq α) : ℕ → seq α",
    "theorem": "{α : Type u} (s : seq α) : ℕ → seq α",
    "args": "{α : Type u} (s : seq α)",
    "doc_string": "Remove the first `n` elements from the sequence.",
    "kind": "def",
    "type": "ℕ → seq α"
  },
  {
    "name": "turing.list_blank.nth",
    "statement": "def turing.list_blank.nth {Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) (n : ℕ) : Γ",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) (n : ℕ) : Γ",
    "args": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) (n : ℕ)",
    "doc_string": "The n-th element of a `list_blank` is well defined for all `n : ℕ`, unlike in a `list`.",
    "kind": "def",
    "type": "Γ"
  },
  {
    "name": "function_field.infty_valuation",
    "statement": "def function_field.infty_valuation (Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valuation (ratfunc Fq) (with_zero (multiplicative ℤ))",
    "theorem": "(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valuation (ratfunc Fq) (with_zero (multiplicative ℤ))",
    "args": "(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)]",
    "doc_string": "The valuation at infinity on `Fq(t)`.",
    "kind": "def",
    "type": "valuation (ratfunc Fq) (with_zero (multiplicative ℤ))"
  },
  {
    "name": "finset.eq_of_mem_of_not_mem_erase",
    "statement": "theorem finset.eq_of_mem_of_not_mem_erase {α : Type u_1} [decidable_eq α] {s : finset α} {a b : α} (hs : b ∈ s) (hsa : b ∉ s.erase a) : b = a",
    "theorem": "{α : Type u_1} [decidable_eq α] {s : finset α} {a b : α} (hs : b ∈ s) (hsa : b ∉ s.erase a) : b = a",
    "args": "{α : Type u_1} [decidable_eq α] {s : finset α} {a b : α} (hs : b ∈ s) (hsa : b ∉ s.erase a)",
    "doc_string": " An element of `s` that is not an element of `erase s a` must be `a`.",
    "kind": "theorem",
    "type": "b = a"
  },
  {
    "name": "free_group.of",
    "statement": "def free_group.of {α : Type u} (x : α) : free_group α",
    "theorem": "{α : Type u} (x : α) : free_group α",
    "args": "{α : Type u} (x : α)",
    "doc_string": " `of` is the canonical injection from the type to the free group over that type by sending each element to the equivalence class of the letter that is the element.",
    "kind": "def",
    "type": "free_group α"
  },
  {
    "name": "vector3.of_fn",
    "statement": "def vector3.of_fn {α : Type u_1} {n : ℕ} (f : fin2 n → α) : vector3 α n",
    "theorem": "{α : Type u_1} {n : ℕ} (f : fin2 n → α) : vector3 α n",
    "args": "{α : Type u_1} {n : ℕ} (f : fin2 n → α)",
    "doc_string": "Construct a vector from a function on `fin2`.",
    "kind": "def",
    "type": "vector3 α n"
  },
  {
    "name": "tactic.itauto.context",
    "statement": "def tactic.itauto.context  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The context during proof search is a map from propositions to proof values.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "is_integral.is_algebraic",
    "statement": "theorem is_integral.is_algebraic (R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x → is_algebraic R x",
    "theorem": "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x → is_algebraic R x",
    "args": "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A}",
    "doc_string": "An integral element of an algebra is algebraic.",
    "kind": "theorem",
    "type": "is_integral R x → is_algebraic R x"
  },
  {
    "name": "finset.has_add",
    "statement": "def finset.has_add {α : Type u_2} [decidable_eq α] [has_add α] : has_add (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [has_add α] : has_add (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [has_add α]",
    "doc_string": "The pointwise addition of finsets `s + t` is defined as `{x + y | x ∈ s, y ∈ t}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_add (finset α)"
  },
  {
    "name": "lipschitz_with",
    "statement": "def lipschitz_with {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β)",
    "doc_string": " A function `f` is Lipschitz continuous with constant `K ≥ 0` if for all `x, y` we have `dist (f x) (f y) ≤ K * dist x y`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.injective.has_involutive_neg",
    "statement": "def function.injective.has_involutive_neg {M₂ : Type u_2} {M₁ : Type u_1} [has_neg M₁] [has_involutive_neg M₂] (f : M₁ → M₂) (hf : function.injective f) (inv : ∀ (x : M₁), f (-x) = -f x) : has_involutive_neg M₁",
    "theorem": "{M₂ : Type u_2} {M₁ : Type u_1} [has_neg M₁] [has_involutive_neg M₂] (f : M₁ → M₂) (hf : function.injective f) (inv : ∀ (x : M₁), f (-x) = -f x) : has_involutive_neg M₁",
    "args": "{M₂ : Type u_2} {M₁ : Type u_1} [has_neg M₁] [has_involutive_neg M₂] (f : M₁ → M₂) (hf : function.injective f) (inv : ∀ (x : M₁), f (-x) = -f x)",
    "doc_string": "A type has an involutive negation if it admits a surjective map that preserves `⁻¹` to a type which has an involutive inversion.",
    "kind": "def",
    "type": "has_involutive_neg M₁"
  },
  {
    "name": "category_theory.ProjectiveResolution.of_complex",
    "statement": "def category_theory.ProjectiveResolution.of_complex {C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_projectives C] (Z : C) : chain_complex C ℕ",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_projectives C] (Z : C) : chain_complex C ℕ",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] [category_theory.enough_projectives C] (Z : C)",
    "doc_string": "Auxiliary definition for `ProjectiveResolution.of`.",
    "kind": "def",
    "type": "chain_complex C ℕ"
  },
  {
    "name": "first_order.language.is_fraisse",
    "statement": "structure first_order.language.is_fraisse {L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop",
    "theorem": "{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop",
    "args": "{L : first_order.language} (K : set (category_theory.bundled L.Structure))",
    "doc_string": " A Fraïssé class is a nonempty, isomorphism-invariant, essentially countable class of structures satisfying the hereditary, joint embedding, and amalgamation properties.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "or",
    "statement": "inductive or (a b : Prop) : Prop",
    "theorem": "(a b : Prop) : Prop",
    "args": "(a b : Prop)",
    "doc_string": "Logical or.  `or P Q`, with notation `P ∨ Q`, is the proposition which is true if and only if `P` or `Q` is true.  To prove a goal `⊢ P ∨ Q`, if you know which alternative you want to prove, you can use the tactics `left` (which gives the goal `⊢ P`) or `right` (which gives the goal `⊢ Q`).  Given a hypothesis `h : P ∨ Q` and goal `⊢ R`, the tactic `cases h` will give you two copies of the goal `⊢ R`, with the hypothesis `h : P` in the first, and the hypothesis `h : Q` in the second.",
    "kind": "inductive",
    "type": "Prop"
  },
  {
    "name": "category_theory.free_bicategory.hom₂",
    "statement": "inductive category_theory.free_bicategory.hom₂ {B : Type u} [quiver B] {a b : B} : category_theory.free_bicategory.hom a b → category_theory.free_bicategory.hom a b → Type (max u v)",
    "theorem": "{B : Type u} [quiver B] {a b : B} : category_theory.free_bicategory.hom a b → category_theory.free_bicategory.hom a b → Type (max u v)",
    "args": "{B : Type u} [quiver B] {a b : B}",
    "doc_string": "Representatives of 2-morphisms in the free bicategory.",
    "kind": "inductive",
    "type": "category_theory.free_bicategory.hom a b → category_theory.free_bicategory.hom a b → Type (max u v)"
  },
  {
    "name": "ennreal.to_ereal",
    "statement": "def ennreal.to_ereal  : ennreal → ereal",
    "theorem": " : ennreal → ereal",
    "args": "",
    "doc_string": "The canonical map from nonnegative extended reals to extended reals",
    "kind": "def",
    "type": "ennreal → ereal"
  },
  {
    "name": "lower_semicontinuous",
    "statement": "def lower_semicontinuous {α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) : Prop",
    "args": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β)",
    "doc_string": " A real function `f` is lower semicontinuous if, for any `ε > 0`, for any `x`, for all `x'` close enough to `x`, then `f x'` is at least `f x - ε`. We formulate this in a general preordered space, using an arbitrary `y < f x` instead of `f x - ε`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "multiset.to_list",
    "statement": "def multiset.to_list {α : Type u_1} (s : multiset α) : list α",
    "theorem": "{α : Type u_1} (s : multiset α) : list α",
    "args": "{α : Type u_1} (s : multiset α)",
    "doc_string": "Produces a list of the elements in the multiset using choice.",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "add_le_of_le_sub_right",
    "statement": "theorem add_le_of_le_sub_right {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a ≤ c - b → a + b ≤ c",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a ≤ c - b → a + b ≤ c",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of le_sub_iff_add_le`.",
    "kind": "theorem",
    "type": "a ≤ c - b → a + b ≤ c"
  },
  {
    "name": "snum.czadd",
    "statement": "def snum.czadd  : bool → bool → snum → snum",
    "theorem": " : bool → bool → snum → snum",
    "args": "",
    "doc_string": "`snum.czadd a b n` is `n + a - b` (where `a` and `b` should be read as either 0 or 1).      This is useful to implement the carry system in `cadd`.",
    "kind": "def",
    "type": "bool → bool → snum → snum"
  },
  {
    "name": "padic_val_int.self",
    "statement": "theorem padic_val_int.self {p : ℕ} (hp : 1 < p) : padic_val_int p ↑p = 1",
    "theorem": "{p : ℕ} (hp : 1 < p) : padic_val_int p ↑p = 1",
    "args": "{p : ℕ} (hp : 1 < p)",
    "doc_string": "For `p ≠ 0, p ≠ 1, `padic_val_int p p` is 1.",
    "kind": "theorem",
    "type": "padic_val_int p ↑p = 1"
  },
  {
    "name": "submonoid.localization_map.away_map",
    "statement": "def submonoid.localization_map.away_map {M : Type u_1} [comm_monoid M] (x : M) (N' : Type u_2) [comm_monoid N'] : Type (max u_1 u_2)",
    "theorem": "{M : Type u_1} [comm_monoid M] (x : M) (N' : Type u_2) [comm_monoid N'] : Type (max u_1 u_2)",
    "args": "{M : Type u_1} [comm_monoid M] (x : M) (N' : Type u_2) [comm_monoid N']",
    "doc_string": " Given `x : M`, the type of `comm_monoid` homomorphisms `f : M →* N` such that `N` is isomorphic to the localization of `M` at the submonoid generated by `x`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "separated_space",
    "statement": "structure separated_space (α : Type u) [uniform_space α] : Prop",
    "theorem": "(α : Type u) [uniform_space α] : Prop",
    "args": "(α : Type u) [uniform_space α]",
    "doc_string": " A uniform space is separated if its separation relation is trivial (each point is related only to itself).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "algebraic_geometry.LocallyRingedSpace.category_theory.category",
    "statement": "def algebraic_geometry.LocallyRingedSpace.category_theory.category  : category_theory.category algebraic_geometry.LocallyRingedSpace",
    "theorem": " : category_theory.category algebraic_geometry.LocallyRingedSpace",
    "args": "",
    "doc_string": "The category of locally ringed spaces.",
    "kind": "def",
    "type": "category_theory.category algebraic_geometry.LocallyRingedSpace"
  },
  {
    "name": "monoid.not_is_torsion_free_iff",
    "statement": "theorem monoid.not_is_torsion_free_iff (G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g",
    "theorem": "(G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g",
    "args": "(G : Type u_1) [monoid G]",
    "doc_string": "A nontrivial monoid is not torsion-free if any nontrivial element has finite order.",
    "kind": "theorem",
    "type": "¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g"
  },
  {
    "name": "conditionally_complete_linear_order.to_compact_Icc_space",
    "statement": "def conditionally_complete_linear_order.to_compact_Icc_space (α : Type u_1) [conditionally_complete_linear_order α] [topological_space α] [order_topology α] : compact_Icc_space α",
    "theorem": "(α : Type u_1) [conditionally_complete_linear_order α] [topological_space α] [order_topology α] : compact_Icc_space α",
    "args": "(α : Type u_1) [conditionally_complete_linear_order α] [topological_space α] [order_topology α]",
    "doc_string": "A closed interval in a conditionally complete linear order is compact.",
    "kind": "def",
    "type": "compact_Icc_space α"
  },
  {
    "name": "nonote.has_add",
    "statement": "def nonote.has_add  : has_add nonote",
    "theorem": " : has_add nonote",
    "args": "",
    "doc_string": "Addition of ordinal notations",
    "kind": "def",
    "type": "has_add nonote"
  },
  {
    "name": "con_gen",
    "statement": "def con_gen {M : Type u_1} [has_mul M] (r : M → M → Prop) : con M",
    "theorem": "{M : Type u_1} [has_mul M] (r : M → M → Prop) : con M",
    "args": "{M : Type u_1} [has_mul M] (r : M → M → Prop)",
    "doc_string": "The inductively defined smallest multiplicative congruence relation containing a given binary    relation.",
    "kind": "def",
    "type": "con M"
  },
  {
    "name": "mvqpf.const",
    "statement": "def mvqpf.const (n : ℕ) (A : Type u_1) (v : typevec n) : Type u_1",
    "theorem": "(n : ℕ) (A : Type u_1) (v : typevec n) : Type u_1",
    "args": "(n : ℕ) (A : Type u_1) (v : typevec n)",
    "doc_string": "Constant multivariate functor",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "matrix.mul_vec",
    "statement": "def matrix.mul_vec {m : Type u_2} {n : Type u_3} {α : Type v} [non_unital_non_assoc_semiring α] [fintype n] (M : matrix m n α) (v : n → α) : m → α",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} [non_unital_non_assoc_semiring α] [fintype n] (M : matrix m n α) (v : n → α) : m → α",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} [non_unital_non_assoc_semiring α] [fintype n] (M : matrix m n α) (v : n → α)",
    "doc_string": "`mul_vec M v` is the matrix-vector product of `M` and `v`, where `v` is seen as a column matrix.    Put another way, `mul_vec M v` is the vector whose entries    are those of `M ⬝ col v` (see `col_mul_vec`).",
    "kind": "def",
    "type": "m → α"
  },
  {
    "name": "with_zero.ordered_add_comm_monoid",
    "statement": "def with_zero.ordered_add_comm_monoid {α : Type u} [ordered_add_comm_monoid α] (zero_le : ∀ (a : α), 0 ≤ a) : ordered_add_comm_monoid (with_zero α)",
    "theorem": "{α : Type u} [ordered_add_comm_monoid α] (zero_le : ∀ (a : α), 0 ≤ a) : ordered_add_comm_monoid (with_zero α)",
    "args": "{α : Type u} [ordered_add_comm_monoid α] (zero_le : ∀ (a : α), 0 ≤ a)",
    "doc_string": "If `0` is the least element in `α`, then `with_zero α` is an `ordered_add_comm_monoid`. See note [reducible non-instances].",
    "kind": "def",
    "type": "ordered_add_comm_monoid (with_zero α)"
  },
  {
    "name": "ordnode",
    "statement": "inductive ordnode (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "An `ordnode α` is a finite set of values, represented as a tree.  The operations on this type maintain that the tree is balanced  and correctly stores subtree sizes at each level.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "omega.int.exprform",
    "statement": "inductive omega.int.exprform  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Intermediate shadow syntax for LNA formulas that includes unreified exprs",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "Semigroup",
    "statement": "def Semigroup  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of semigroups and semigroup morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "cardinal.univ",
    "statement": "def cardinal.univ  : cardinal",
    "theorem": " : cardinal",
    "args": "",
    "doc_string": "The cardinal `univ` is the cardinality of ordinal `univ`, or  equivalently the cardinal of `ordinal.{u}`, or `cardinal.{u}`,  as an element of `cardinal.{v}` (when `u < v`).",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "frame_hom_class",
    "statement": "structure frame_hom_class (F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [complete_lattice α] [complete_lattice β] : Type (max u_10 u_8 u_9)",
    "theorem": "(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [complete_lattice α] [complete_lattice β] : Type (max u_10 u_8 u_9)",
    "args": "(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [complete_lattice α] [complete_lattice β]",
    "doc_string": " `frame_hom_class F α β` states that `F` is a type of frame morphisms. They preserve `⊓` and `⨆`.  You should extend this class when you extend `frame_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_8 u_9)"
  },
  {
    "name": "AddCommMon.of",
    "statement": "def AddCommMon.of (M : Type u) [add_comm_monoid M] : AddCommMon",
    "theorem": "(M : Type u) [add_comm_monoid M] : AddCommMon",
    "args": "(M : Type u) [add_comm_monoid M]",
    "doc_string": "Construct a bundled `AddCommMon` from the underlying type and typeclass.",
    "kind": "def",
    "type": "AddCommMon"
  },
  {
    "name": "submonoid.prod",
    "statement": "def submonoid.prod {M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (s : submonoid M) (t : submonoid N) : submonoid (M × N)",
    "theorem": "{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (s : submonoid M) (t : submonoid N) : submonoid (M × N)",
    "args": "{M : Type u_1} {N : Type u_2} [mul_one_class M] [mul_one_class N] (s : submonoid M) (t : submonoid N)",
    "doc_string": " Given `submonoid`s `s`, `t` of monoids `M`, `N` respectively, `s × t` as a submonoid of `M × N`.",
    "kind": "def",
    "type": "submonoid (M × N)"
  },
  {
    "name": "no_max_order.infinite",
    "statement": "theorem no_max_order.infinite {α : Type u_1} [preorder α] [nonempty α] [no_max_order α] : infinite α",
    "theorem": "{α : Type u_1} [preorder α] [nonempty α] [no_max_order α] : infinite α",
    "args": "{α : Type u_1} [preorder α] [nonempty α] [no_max_order α]",
    "doc_string": " A nonempty preorder with no maximal element is infinite. This is not an instance to avoid a cycle with `infinite α → nontrivial α → nonempty α`.",
    "kind": "theorem",
    "type": "infinite α"
  },
  {
    "name": "mathlib_linters",
    "statement": "def mathlib_linters  : list name",
    "theorem": " : list name",
    "args": "",
    "doc_string": "The default linters used in mathlib CI.",
    "kind": "def",
    "type": "list name"
  },
  {
    "name": "mul_sub",
    "statement": "theorem mul_sub {α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : a * (b - c) = a * b - a * c",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : a * (b - c) = a * b - a * c",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α)",
    "doc_string": "**Alias** of mul_sub_left_distrib`.",
    "kind": "theorem",
    "type": "a * (b - c) = a * b - a * c"
  },
  {
    "name": "multiset.Ioc_eq_zero",
    "statement": "theorem multiset.Ioc_eq_zero {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ioc a b = 0",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ioc a b = 0",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of multiset.Ioc_eq_zero_iff`.",
    "kind": "theorem",
    "type": "¬a < b → multiset.Ioc a b = 0"
  },
  {
    "name": "char",
    "statement": "structure char  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The `char` type represents an unicode scalar value.    See http://www.unicode.org/glossary/#unicode_scalar_value).",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "turing.pointed_map",
    "statement": "structure turing.pointed_map (Γ : Type u) (Γ' : Type v) [inhabited Γ] [inhabited Γ'] : Type (max u v)",
    "theorem": "(Γ : Type u) (Γ' : Type v) [inhabited Γ] [inhabited Γ'] : Type (max u v)",
    "args": "(Γ : Type u) (Γ' : Type v) [inhabited Γ] [inhabited Γ']",
    "doc_string": "A pointed map of `inhabited` types is a map that sends one default value to the other.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "wseq.find_index",
    "statement": "def wseq.find_index {α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α) : computation ℕ",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α) : computation ℕ",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α)",
    "doc_string": "Get the index of the first element of `s` satisfying `p`",
    "kind": "def",
    "type": "computation ℕ"
  },
  {
    "name": "alexandroff.t1_space",
    "statement": "def alexandroff.t1_space {X : Type u_1} [topological_space X] [t1_space X] : t1_space (alexandroff X)",
    "theorem": "{X : Type u_1} [topological_space X] [t1_space X] : t1_space (alexandroff X)",
    "args": "{X : Type u_1} [topological_space X] [t1_space X]",
    "doc_string": "The one point compactification of a `t1_space` space is a `t1_space`.",
    "kind": "def",
    "type": "t1_space (alexandroff X)"
  },
  {
    "name": "set.subtraction_comm_monoid",
    "statement": "def set.subtraction_comm_monoid {α : Type u_2} [subtraction_comm_monoid α] : subtraction_comm_monoid (set α)",
    "theorem": "{α : Type u_2} [subtraction_comm_monoid α] : subtraction_comm_monoid (set α)",
    "args": "{α : Type u_2} [subtraction_comm_monoid α]",
    "doc_string": "`set α` is a commutative subtraction monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "subtraction_comm_monoid (set α)"
  },
  {
    "name": "univ.is_submonoid",
    "statement": "theorem univ.is_submonoid {M : Type u_1} [monoid M] : is_submonoid set.univ",
    "theorem": "{M : Type u_1} [monoid M] : is_submonoid set.univ",
    "args": "{M : Type u_1} [monoid M]",
    "doc_string": "A monoid is a submonoid of itself.",
    "kind": "theorem",
    "type": "is_submonoid set.univ"
  },
  {
    "name": "AddMagma",
    "statement": "def AddMagma  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of additive magmas and additive magma morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "measure_theory.simple_func.piecewise",
    "statement": "def measure_theory.simple_func.piecewise {α : Type u_1} {β : Type u_2} [measurable_space α] (s : set α) (hs : measurable_set s) (f g : measure_theory.simple_func α β) : measure_theory.simple_func α β",
    "theorem": "{α : Type u_1} {β : Type u_2} [measurable_space α] (s : set α) (hs : measurable_set s) (f g : measure_theory.simple_func α β) : measure_theory.simple_func α β",
    "args": "{α : Type u_1} {β : Type u_2} [measurable_space α] (s : set α) (hs : measurable_set s) (f g : measure_theory.simple_func α β)",
    "doc_string": "If-then-else as a `simple_func`.",
    "kind": "def",
    "type": "measure_theory.simple_func α β"
  },
  {
    "name": "bornology.cofinite",
    "statement": "def bornology.cofinite {α : Type u_2} : bornology α",
    "theorem": "{α : Type u_2} : bornology α",
    "args": "{α : Type u_2}",
    "doc_string": "The cofinite filter as a bornology",
    "kind": "def",
    "type": "bornology α"
  },
  {
    "name": "free_product.neword.head",
    "statement": "def free_product.neword.head {ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : M i",
    "theorem": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : M i",
    "args": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j)",
    "doc_string": "The first letter of a `neword`",
    "kind": "def",
    "type": "M i"
  },
  {
    "name": "omega.coeffs.val_between",
    "statement": "def omega.coeffs.val_between (v : ℕ → ℤ) (as : list ℤ) (l : ℕ) : ℕ → ℤ",
    "theorem": "(v : ℕ → ℤ) (as : list ℤ) (l : ℕ) : ℕ → ℤ",
    "args": "(v : ℕ → ℤ) (as : list ℤ) (l : ℕ)",
    "doc_string": "`val_between v as l o` is the value (under valuation `v`) of the term    obtained taking the term represented by `(0, as)` and dropping all    subterms that include variables outside the range `[l,l+o)`",
    "kind": "def",
    "type": "ℕ → ℤ"
  },
  {
    "name": "pnat.xgcd_type.step",
    "statement": "def pnat.xgcd_type.step (u : pnat.xgcd_type) : pnat.xgcd_type",
    "theorem": "(u : pnat.xgcd_type) : pnat.xgcd_type",
    "args": "(u : pnat.xgcd_type)",
    "doc_string": "This is the main reduction step, which is used when u.r ≠ 0, or equivalently b does not divide a.",
    "kind": "def",
    "type": "pnat.xgcd_type"
  },
  {
    "name": "mul_action.quotient_action",
    "statement": "structure mul_action.quotient_action {α : Type u} (β : Type v) [group α] [monoid β] [mul_action β α] (H : subgroup α) : Prop",
    "theorem": "{α : Type u} (β : Type v) [group α] [monoid β] [mul_action β α] (H : subgroup α) : Prop",
    "args": "{α : Type u} (β : Type v) [group α] [monoid β] [mul_action β α] (H : subgroup α)",
    "doc_string": "A typeclass for when a `mul_action β α` descends to the quotient `α ⧸ H`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "thunk.mk",
    "statement": "def thunk.mk {α : Type u_1} (x : α) : thunk α",
    "theorem": "{α : Type u_1} (x : α) : thunk α",
    "args": "{α : Type u_1} (x : α)",
    "doc_string": "Creates a thunk with a (non-lazy) constant value.",
    "kind": "def",
    "type": "thunk α"
  },
  {
    "name": "lt_tsub_iff_left",
    "statement": "theorem lt_tsub_iff_left {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ c + a < b",
    "theorem": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ c + a < b",
    "args": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α]",
    "doc_string": "See `lt_tsub_iff_left_of_le` for a weaker statement in a partial order.",
    "kind": "theorem",
    "type": "a < b - c ↔ c + a < b"
  },
  {
    "name": "sum3.in₀",
    "statement": "def sum3.in₀ {α : Type u} {β : Type v} {γ : Type u_1} (a : α) : α ⊕ β ⊕ γ",
    "theorem": "{α : Type u} {β : Type v} {γ : Type u_1} (a : α) : α ⊕ β ⊕ γ",
    "args": "{α : Type u} {β : Type v} {γ : Type u_1} (a : α)",
    "doc_string": "The map from the first summand into a ternary sum.",
    "kind": "def",
    "type": "α ⊕ β ⊕ γ"
  },
  {
    "name": "setoid.complete_lattice",
    "statement": "def setoid.complete_lattice {α : Type u_1} : complete_lattice (setoid α)",
    "theorem": "{α : Type u_1} : complete_lattice (setoid α)",
    "args": "{α : Type u_1}",
    "doc_string": "The complete lattice of equivalence relations on a type, with bottom element `=`    and top element the trivial equivalence relation.",
    "kind": "def",
    "type": "complete_lattice (setoid α)"
  },
  {
    "name": "tactic.mk_mem_name",
    "statement": "def tactic.mk_mem_name (sub : name) : name → name",
    "theorem": "(sub : name) : name → name",
    "args": "(sub : name)",
    "doc_string": "makes the substructure axiom name from field name, by postfacing with `_mem`",
    "kind": "def",
    "type": "name → name"
  },
  {
    "name": "category_theory.limits.walking_multispan",
    "statement": "inductive category_theory.limits.walking_multispan {L R : Type v} (fst snd : L → R) : Type v",
    "theorem": "{L R : Type v} (fst snd : L → R) : Type v",
    "args": "{L R : Type v} (fst snd : L → R)",
    "doc_string": "The type underlying the multiecoqualizer diagram.",
    "kind": "inductive",
    "type": "Type v"
  },
  {
    "name": "function.antiperiodic",
    "statement": "def function.antiperiodic {α : Type u_1} {β : Type u_2} [has_add α] [has_neg β] (f : α → β) (c : α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_add α] [has_neg β] (f : α → β) (c : α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [has_add α] [has_neg β] (f : α → β) (c : α)",
    "doc_string": "A function `f` is said to be `antiperiodic` with antiperiod `c` if for all `x`,  `f (x + c) = -f x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "equiv.perm.fin_pairs_lt",
    "statement": "def equiv.perm.fin_pairs_lt (n : ℕ) : finset (Σ (a : fin n), fin n)",
    "theorem": "(n : ℕ) : finset (Σ (a : fin n), fin n)",
    "args": "(n : ℕ)",
    "doc_string": "set of all pairs (⟨a, b⟩ : Σ a : fin n, fin n) such that b < a",
    "kind": "def",
    "type": "finset (Σ (a : fin n), fin n)"
  },
  {
    "name": "dlist.join",
    "statement": "def dlist.join {α : Type u_1} : list (dlist α) → dlist α",
    "theorem": "{α : Type u_1} : list (dlist α) → dlist α",
    "args": "{α : Type u_1}",
    "doc_string": " Concatenates a list of difference lists to form a single difference list. Similar to `list.join`.",
    "kind": "def",
    "type": "list (dlist α) → dlist α"
  },
  {
    "name": "linarith.monom",
    "statement": "def linarith.monom  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Variables (represented by natural numbers) map to their power.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "rank_condition",
    "statement": "structure rank_condition (R : Type u) [semiring R] : Prop",
    "theorem": "(R : Type u) [semiring R] : Prop",
    "args": "(R : Type u) [semiring R]",
    "doc_string": "We say that `R` satisfies the rank condition if `(fin n → R) →ₗ[R] (fin m → R)` surjective    implies `m ≤ n`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "has_lt.lt.trans_le",
    "statement": "theorem has_lt.lt.trans_le {α : Type u} [preorder α] {a b c : α} : a < b → b ≤ c → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a < b → b ≤ c → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_lt_of_le`.",
    "kind": "theorem",
    "type": "a < b → b ≤ c → a < c"
  },
  {
    "name": "encodable.of_left_inverse",
    "statement": "def encodable.of_left_inverse {α : Type u_1} {β : Type u_2} [encodable α] (f : β → α) (finv : α → β) (linv : ∀ (b : β), finv (f b) = b) : encodable β",
    "theorem": "{α : Type u_1} {β : Type u_2} [encodable α] (f : β → α) (finv : α → β) (linv : ∀ (b : β), finv (f b) = b) : encodable β",
    "args": "{α : Type u_1} {β : Type u_2} [encodable α] (f : β → α) (finv : α → β) (linv : ∀ (b : β), finv (f b) = b)",
    "doc_string": "If `α` is encodable and `f : β → α` is invertible, then `β` is encodable as well.",
    "kind": "def",
    "type": "encodable β"
  },
  {
    "name": "Lattice.of",
    "statement": "def Lattice.of (α : Type u_1) [lattice α] : Lattice",
    "theorem": "(α : Type u_1) [lattice α] : Lattice",
    "args": "(α : Type u_1) [lattice α]",
    "doc_string": "Construct a bundled `Lattice` from a `lattice`.",
    "kind": "def",
    "type": "Lattice"
  },
  {
    "name": "projection_rule",
    "statement": "def projection_rule  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of rules that specify how metadata for projections in changes.  See `initialize_simps_projection`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "multiset.sup",
    "statement": "def multiset.sup {α : Type u_1} [semilattice_sup α] [order_bot α] (s : multiset α) : α",
    "theorem": "{α : Type u_1} [semilattice_sup α] [order_bot α] (s : multiset α) : α",
    "args": "{α : Type u_1} [semilattice_sup α] [order_bot α] (s : multiset α)",
    "doc_string": "Supremum of a multiset: `sup {a, b, c} = a ⊔ b ⊔ c`",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "category_theory.limits.has_coequalizers",
    "statement": "def category_theory.limits.has_coequalizers (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_coequalizers` represents a choice of coequalizer for every pair of morphisms",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bdd_below.inter_of_left",
    "statement": "theorem bdd_below.inter_of_left {α : Type u} [preorder α] {s t : set α} (h : bdd_below s) : bdd_below (s ∩ t)",
    "theorem": "{α : Type u} [preorder α] {s t : set α} (h : bdd_below s) : bdd_below (s ∩ t)",
    "args": "{α : Type u} [preorder α] {s t : set α} (h : bdd_below s)",
    "doc_string": "If `s` is bounded, then so is `s ∩ t`",
    "kind": "theorem",
    "type": "bdd_below (s ∩ t)"
  },
  {
    "name": "lucas_lehmer.two_lt_q",
    "statement": "theorem lucas_lehmer.two_lt_q (p' : ℕ) : 2 < lucas_lehmer.q (p' + 2)",
    "theorem": "(p' : ℕ) : 2 < lucas_lehmer.q (p' + 2)",
    "args": "(p' : ℕ)",
    "doc_string": "If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2.",
    "kind": "theorem",
    "type": "2 < lucas_lehmer.q (p' + 2)"
  },
  {
    "name": "cartan_matrix.E₈",
    "statement": "def cartan_matrix.E₈  : matrix (fin 8) (fin 8) ℤ",
    "theorem": " : matrix (fin 8) (fin 8) ℤ",
    "args": "",
    "doc_string": " The Cartan matrix of type e₈. See [bourbaki1968] plate VII, page 285.  The corresponding Dynkin diagram is: ```lean             o             | o --- o --- o --- o --- o --- o --- o ```",
    "kind": "def",
    "type": "matrix (fin 8) (fin 8) ℤ"
  },
  {
    "name": "matrix.linfty_op_semi_normed_ring",
    "statement": "def matrix.linfty_op_semi_normed_ring {n : Type u_4} {α : Type u_5} [fintype n] [semi_normed_ring α] [decidable_eq n] : semi_normed_ring (matrix n n α)",
    "theorem": "{n : Type u_4} {α : Type u_5} [fintype n] [semi_normed_ring α] [decidable_eq n] : semi_normed_ring (matrix n n α)",
    "args": "{n : Type u_4} {α : Type u_5} [fintype n] [semi_normed_ring α] [decidable_eq n]",
    "doc_string": " Seminormed ring instance (using sup norm of L1 norm) for matrices over a semi normed ring.  Not declared as an instance because there are several natural choices for defining the norm of a matrix.",
    "kind": "def",
    "type": "semi_normed_ring (matrix n n α)"
  },
  {
    "name": "first_order.language.Lequiv",
    "statement": "structure first_order.language.Lequiv (L : first_order.language) (L' : first_order.language) : Type (max u_1 u_2 u_3 u_4)",
    "theorem": "(L : first_order.language) (L' : first_order.language) : Type (max u_1 u_2 u_3 u_4)",
    "args": "(L : first_order.language) (L' : first_order.language)",
    "doc_string": "A language equivalence maps the symbols of one language to symbols of another bijectively.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3 u_4)"
  },
  {
    "name": "discrete_quotient.order_bot",
    "statement": "def discrete_quotient.order_bot {X : Type u_1} [topological_space X] [discrete_topology X] : order_bot (discrete_quotient X)",
    "theorem": "{X : Type u_1} [topological_space X] [discrete_topology X] : order_bot (discrete_quotient X)",
    "args": "{X : Type u_1} [topological_space X] [discrete_topology X]",
    "doc_string": "When X is discrete, there is a `order_bot` instance on `discrete_quotient X`",
    "kind": "def",
    "type": "order_bot (discrete_quotient X)"
  },
  {
    "name": "isometry_subsingleton",
    "statement": "theorem isometry_subsingleton {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} [subsingleton α] : isometry f",
    "theorem": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} [subsingleton α] : isometry f",
    "args": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} [subsingleton α]",
    "doc_string": "Any map on a subsingleton is an isometry",
    "kind": "theorem",
    "type": "isometry f"
  },
  {
    "name": "closure_Ioi",
    "statement": "theorem closure_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_max_order α] : closure (set.Ioi a) = set.Ici a",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_max_order α] : closure (set.Ioi a) = set.Ici a",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_max_order α]",
    "doc_string": "The closure of the interval `(a, +∞)` is the closed interval `[a, +∞)`.",
    "kind": "theorem",
    "type": "closure (set.Ioi a) = set.Ici a"
  },
  {
    "name": "cochain_complex.mk_struct",
    "statement": "structure cochain_complex.mk_struct (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)",
    "theorem": "(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] : Type (max u v)",
    "args": "(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V]",
    "doc_string": "Auxiliary structure for setting up the recursion in `mk`. This is purely an implementation detail: for some reason just using the dependent 6-tuple directly results in `mk_aux` taking much longer (well over the `-T100000` limit) to elaborate.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "omega.nat.preterm.sub_free",
    "statement": "def omega.nat.preterm.sub_free  : omega.nat.preterm → Prop",
    "theorem": " : omega.nat.preterm → Prop",
    "args": "",
    "doc_string": "Preterm is free of subtractions",
    "kind": "def",
    "type": "omega.nat.preterm → Prop"
  },
  {
    "name": "polynomial.cyclotomic.irreducible",
    "statement": "theorem polynomial.cyclotomic.irreducible {n : ℕ} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ℤ)",
    "theorem": "{n : ℕ} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ℤ)",
    "args": "{n : ℕ} (hpos : 0 < n)",
    "doc_string": "`cyclotomic n ℤ` is irreducible.",
    "kind": "theorem",
    "type": "irreducible (polynomial.cyclotomic n ℤ)"
  },
  {
    "name": "free_group.reduce",
    "statement": "def free_group.reduce {α : Type u} [decidable_eq α] (L : list (α × bool)) : list (α × bool)",
    "theorem": "{α : Type u} [decidable_eq α] (L : list (α × bool)) : list (α × bool)",
    "args": "{α : Type u} [decidable_eq α] (L : list (α × bool))",
    "doc_string": " The maximal reduction of a word. It is computable iff `α` has decidable equality.",
    "kind": "def",
    "type": "list (α × bool)"
  },
  {
    "name": "ultrafilter.has_mul",
    "statement": "def ultrafilter.has_mul {M : Type u_1} [has_mul M] : has_mul (ultrafilter M)",
    "theorem": "{M : Type u_1} [has_mul M] : has_mul (ultrafilter M)",
    "args": "{M : Type u_1} [has_mul M]",
    "doc_string": "Multiplication of ultrafilters given by `∀ᶠ m in U*V, p m ↔ ∀ᶠ m in U, ∀ᶠ m' in V, p (m*m')`.",
    "kind": "def",
    "type": "has_mul (ultrafilter M)"
  },
  {
    "name": "enorm",
    "statement": "structure enorm (𝕜 : Type u_1) (V : Type u_2) [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] : Type u_2",
    "theorem": "(𝕜 : Type u_1) (V : Type u_2) [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] : Type u_2",
    "args": "(𝕜 : Type u_1) (V : Type u_2) [normed_field 𝕜] [add_comm_group V] [module 𝕜 V]",
    "doc_string": " Extended norm on a vector space. As in the case of normed spaces, we require only `∥c • x∥ ≤ ∥c∥ * ∥x∥` in the definition, then prove an equality in `map_smul`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "tmp_order",
    "statement": "def tmp_order {α : Type u} : partial_order (topological_space α)",
    "theorem": "{α : Type u} : partial_order (topological_space α)",
    "args": "{α : Type u}",
    "doc_string": "The inclusion ordering on topologies on α. We use it to get a complete   lattice instance via the Galois insertion method, but the partial order   that we will eventually impose on `topological_space α` is the reverse one.",
    "kind": "def",
    "type": "partial_order (topological_space α)"
  },
  {
    "name": "local_homeomorph.trans",
    "statement": "def local_homeomorph.trans {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) (e' : local_homeomorph β γ) : local_homeomorph α γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) (e' : local_homeomorph β γ) : local_homeomorph α γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (e : local_homeomorph α β) (e' : local_homeomorph β γ)",
    "doc_string": " Composing two local homeomorphisms, by restricting to the maximal domain where their composition is well defined.",
    "kind": "def",
    "type": "local_homeomorph α γ"
  },
  {
    "name": "div_inv_monoid",
    "statement": "structure div_inv_monoid (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": " A `div_inv_monoid` is a `monoid` with operations `/` and `⁻¹` satisfying `div_eq_mul_inv : ∀ a b, a / b = a * b⁻¹`.  This deduplicates the name `div_eq_mul_inv`. The default for `div` is such that `a / b = a * b⁻¹` holds by definition.  Adding `div` as a field rather than defining `a / b := a * b⁻¹` allows us to avoid certain classes of unification failures, for example: Let `foo X` be a type with a `∀ X, has_div (foo X)` instance but no `∀ X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we also have an instance `∀ X [cromulent X], group_with_zero (foo X)`. Then the `(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to the `(/)` coming from `foo.has_div`.  In the same way, adding a `zpow` field makes it possible to avoid definitional failures in diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more explanations on this.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "rack.pre_envel_group_rel",
    "statement": "inductive rack.pre_envel_group_rel (R : Type u) [rack R] : rack.pre_envel_group R → rack.pre_envel_group R → Prop",
    "theorem": "(R : Type u) [rack R] : rack.pre_envel_group R → rack.pre_envel_group R → Prop",
    "args": "(R : Type u) [rack R]",
    "doc_string": "The `pre_envel_group_rel` relation as a `Prop`.  Used as the relation for `pre_envel_group.setoid`.",
    "kind": "inductive",
    "type": "rack.pre_envel_group R → rack.pre_envel_group R → Prop"
  },
  {
    "name": "measure_theory.measure.dirac",
    "statement": "def measure_theory.measure.dirac {α : Type u_1} [measurable_space α] (a : α) : measure_theory.measure α",
    "theorem": "{α : Type u_1} [measurable_space α] (a : α) : measure_theory.measure α",
    "args": "{α : Type u_1} [measurable_space α] (a : α)",
    "doc_string": "The dirac measure.",
    "kind": "def",
    "type": "measure_theory.measure α"
  },
  {
    "name": "lie_module",
    "statement": "structure lie_module (R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] : Type",
    "theorem": "(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M] : Type",
    "args": "(R : Type u) (L : Type v) (M : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [add_comm_group M] [module R M] [lie_ring_module L M]",
    "doc_string": " A Lie module is a module over a commutative ring, together with a linear action of a Lie algebra on this module, such that the Lie bracket acts as the commutator of endomorphisms.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "pos_num.of_nat_succ",
    "statement": "def pos_num.of_nat_succ  : ℕ → pos_num",
    "theorem": " : ℕ → pos_num",
    "args": "",
    "doc_string": "`of_nat_succ n` is the `pos_num` corresponding to `n + 1`.",
    "kind": "def",
    "type": "ℕ → pos_num"
  },
  {
    "name": "seq.zip",
    "statement": "def seq.zip {α : Type u} {β : Type v} : seq α → seq β → seq (α × β)",
    "theorem": "{α : Type u} {β : Type v} : seq α → seq β → seq (α × β)",
    "args": "{α : Type u} {β : Type v}",
    "doc_string": "Pair two sequences into a sequence of pairs",
    "kind": "def",
    "type": "seq α → seq β → seq (α × β)"
  },
  {
    "name": "module.ray.ne_neg_self",
    "statement": "theorem module.ray.ne_neg_self {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x ≠ -x",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x ≠ -x",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M)",
    "doc_string": "A ray does not equal its own negation.",
    "kind": "theorem",
    "type": "x ≠ -x"
  },
  {
    "name": "module_info",
    "statement": "constant module_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Information about a currently loaded module (such as `data.dlist`).",
    "kind": "constant",
    "type": "Type"
  },
  {
    "name": "finset.range",
    "statement": "def finset.range (n : ℕ) : finset ℕ",
    "theorem": "(n : ℕ) : finset ℕ",
    "args": "(n : ℕ)",
    "doc_string": "`range n` is the set of natural numbers less than `n`.",
    "kind": "def",
    "type": "finset ℕ"
  },
  {
    "name": "first_order.language.graph",
    "statement": "def first_order.language.graph  : first_order.language",
    "theorem": " : first_order.language",
    "args": "",
    "doc_string": "The language consisting of a single relation representing adjacency.",
    "kind": "def",
    "type": "first_order.language"
  },
  {
    "name": "filter.map₃",
    "statement": "def filter.map₃ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} (m : α → β → γ → δ) (f : filter α) (g : filter β) (h : filter γ) : filter δ",
    "theorem": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} (m : α → β → γ → δ) (f : filter α) (g : filter β) (h : filter γ) : filter δ",
    "args": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} (m : α → β → γ → δ) (f : filter α) (g : filter β) (h : filter γ)",
    "doc_string": " The image of a ternary function `m : α → β → γ → δ` as a function `filter α → filter β → filter γ → filter δ`. Mathematically this should be thought of as the image of the corresponding function `α × β × γ → δ`.",
    "kind": "def",
    "type": "filter δ"
  },
  {
    "name": "category_theory.limits.walking_cospan",
    "statement": "def category_theory.limits.walking_cospan  : Type v",
    "theorem": " : Type v",
    "args": "",
    "doc_string": "The type of objects for the diagram indexing a pullback, defined as a special case of `wide_pullback_shape`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "finset.centroid_weights",
    "statement": "def finset.centroid_weights (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : ι → k",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : ι → k",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι)",
    "doc_string": "The weights for the centroid of some points.",
    "kind": "def",
    "type": "ι → k"
  },
  {
    "name": "finset.min'_singleton",
    "statement": "theorem finset.min'_singleton {α : Type u_1} [linear_order α] (a : α) : {a}.min' _ = a",
    "theorem": "{α : Type u_1} [linear_order α] (a : α) : {a}.min' _ = a",
    "args": "{α : Type u_1} [linear_order α] (a : α)",
    "doc_string": "`{a}.min' _` is `a`.",
    "kind": "theorem",
    "type": "{a}.min' _ = a"
  },
  {
    "name": "comm_monoid_with_zero",
    "statement": "structure comm_monoid_with_zero (M₀ : Type u_4) : Type u_4",
    "theorem": "(M₀ : Type u_4) : Type u_4",
    "args": "(M₀ : Type u_4)",
    "doc_string": " A type `M` is a commutative “monoid with zero” if it is a commutative monoid with zero element, and `0` is left and right absorbing.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "has_neg.to_has_abs",
    "statement": "def has_neg.to_has_abs {α : Type u} [has_neg α] [has_sup α] : has_abs α",
    "theorem": "{α : Type u} [has_neg α] [has_sup α] : has_abs α",
    "args": "{α : Type u} [has_neg α] [has_sup α]",
    "doc_string": "`abs a` is the absolute value of `a`",
    "kind": "def",
    "type": "has_abs α"
  },
  {
    "name": "is_coatom",
    "statement": "def is_coatom {α : Type u_1} [preorder α] [order_top α] (a : α) : Prop",
    "theorem": "{α : Type u_1} [preorder α] [order_top α] (a : α) : Prop",
    "args": "{α : Type u_1} [preorder α] [order_top α] (a : α)",
    "doc_string": "A coatom of an `order_top` is an element with no other element between it and `⊤`,  which is not `⊤`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bornology",
    "statement": "structure bornology (α : Type u_4) : Type u_4",
    "theorem": "(α : Type u_4) : Type u_4",
    "args": "(α : Type u_4)",
    "doc_string": " A **bornology** on a type `α` is a filter of cobounded sets which contains the cofinite filter. Such spaces are equivalently specified by their bounded sets, see `bornology.of_bounded` and `bornology.ext_iff_is_bounded`",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "submonoid.ext",
    "statement": "theorem submonoid.ext {M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T",
    "theorem": "{M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T",
    "args": "{M : Type u_1} [mul_one_class M] {S T : submonoid M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T)",
    "doc_string": "Two submonoids are equal if they have the same elements.",
    "kind": "theorem",
    "type": "S = T"
  },
  {
    "name": "lists.atom",
    "statement": "def lists.atom {α : Type u_1} (a : α) : lists α",
    "theorem": "{α : Type u_1} (a : α) : lists α",
    "args": "{α : Type u_1} (a : α)",
    "doc_string": "Sends `a : α` to the corresponding atom in `lists α`.",
    "kind": "def",
    "type": "lists α"
  },
  {
    "name": "submodule.copy",
    "statement": "def submodule.copy {R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) (s : set M) (hs : s = ↑p) : submodule R M",
    "theorem": "{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) (s : set M) (hs : s = ↑p) : submodule R M",
    "args": "{R : Type u} {M : Type v} [semiring R] [add_comm_monoid M] [module R M] (p : submodule R M) (s : set M) (hs : s = ↑p)",
    "doc_string": " Copy of a submodule with a new `carrier` equal to the old one. Useful to fix definitional equalities.",
    "kind": "def",
    "type": "submodule R M"
  },
  {
    "name": "tactic.transparency",
    "statement": "inductive tactic.transparency  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " A parameter representing how aggressively definitions should be unfolded when trying to decide if two terms match, unify or are definitionally equal. By default, theorem declarations are never unfolded. - `all` will unfold everything, including macros and theorems. Except projection macros. - `semireducible` will unfold everything except theorems and definitions tagged as irreducible. - `instances` will unfold all class instance definitions and definitions tagged with reducible. - `reducible` will only unfold definitions tagged with the `reducible` attribute. - `none` will never unfold anything. [NOTE] You are not allowed to tag a definition with more than one of `reducible`, `irreducible`, `semireducible` attributes. [NOTE] there is a config flag `m_unfold_lemmas`that will make it unfold theorems.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "list.length_pos_of_sum_neg",
    "statement": "theorem list.length_pos_of_sum_neg {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length",
    "theorem": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length",
    "args": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0)",
    "doc_string": "A list with negative sum must have positive length.",
    "kind": "theorem",
    "type": "0 < L.length"
  },
  {
    "name": "topological_space.nonempty_compacts",
    "statement": "structure topological_space.nonempty_compacts (α : Type u_3) [topological_space α] : Type u_3",
    "theorem": "(α : Type u_3) [topological_space α] : Type u_3",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": "The type of nonempty compact sets of a topological space.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "galois_coinsertion.lift_lattice",
    "statement": "def galois_coinsertion.lift_lattice {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [lattice β] (gi : galois_coinsertion l u) : lattice α",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [lattice β] (gi : galois_coinsertion l u) : lattice α",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [lattice β] (gi : galois_coinsertion l u)",
    "doc_string": "Lift the suprema and infima along a Galois coinsertion",
    "kind": "def",
    "type": "lattice α"
  },
  {
    "name": "submodule.has_mul",
    "statement": "def submodule.has_mul {R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_mul (submodule R A)",
    "theorem": "{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A] : has_mul (submodule R A)",
    "args": "{R : Type u} [comm_semiring R] {A : Type v} [semiring A] [algebra R A]",
    "doc_string": " Multiplication of sub-R-modules of an R-algebra A. The submodule `M * N` is the smallest R-submodule of `A` containing the elements `m * n` for `m ∈ M` and `n ∈ N`.",
    "kind": "def",
    "type": "has_mul (submodule R A)"
  },
  {
    "name": "has_ordered_sub",
    "statement": "structure has_ordered_sub (α : Type u_3) [has_le α] [has_add α] [has_sub α] : Type",
    "theorem": "(α : Type u_3) [has_le α] [has_add α] [has_sub α] : Type",
    "args": "(α : Type u_3) [has_le α] [has_add α] [has_sub α]",
    "doc_string": " `has_ordered_sub α` means that `α` has a subtraction characterized by `a - b ≤ c ↔ a ≤ c + b`. In other words, `a - b` is the least `c` such that `a ≤ b + c`.  This is satisfied both by the subtraction in additive ordered groups and by truncated subtraction in canonically ordered monoids on many specific types.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "is_greatest.bdd_above",
    "statement": "theorem is_greatest.bdd_above {α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a) : bdd_above s",
    "theorem": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a) : bdd_above s",
    "args": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a)",
    "doc_string": "If `s` has a greatest element, then it is bounded above.",
    "kind": "theorem",
    "type": "bdd_above s"
  },
  {
    "name": "subgroup.closure",
    "statement": "def subgroup.closure {G : Type u_1} [group G] (k : set G) : subgroup G",
    "theorem": "{G : Type u_1} [group G] (k : set G) : subgroup G",
    "args": "{G : Type u_1} [group G] (k : set G)",
    "doc_string": "The `subgroup` generated by a set.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "truncated_witt_vector.coeff",
    "statement": "def truncated_witt_vector.coeff {p n : ℕ} {R : Type u_1} (i : fin n) (x : truncated_witt_vector p n R) : R",
    "theorem": "{p n : ℕ} {R : Type u_1} (i : fin n) (x : truncated_witt_vector p n R) : R",
    "args": "{p n : ℕ} {R : Type u_1} (i : fin n) (x : truncated_witt_vector p n R)",
    "doc_string": "`x.coeff i` is the `i`th entry of `x`.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "left.add_pos",
    "statement": "theorem left.add_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "list.alternating_sum",
    "statement": "def list.alternating_sum {G : Type u_1} [has_zero G] [has_add G] [has_neg G] : list G → G",
    "theorem": "{G : Type u_1} [has_zero G] [has_add G] [has_neg G] : list G → G",
    "args": "{G : Type u_1} [has_zero G] [has_add G] [has_neg G]",
    "doc_string": "The alternating sum of a list.",
    "kind": "def",
    "type": "list G → G"
  },
  {
    "name": "is_max_on",
    "statement": "def is_max_on {α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α)",
    "doc_string": "`is_max_on f s a` means that `f x ≤ f a` for all `x ∈ a`. Note that we do not assume `a ∈ s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "univ.is_add_submonoid",
    "statement": "theorem univ.is_add_submonoid {M : Type u_1} [add_monoid M] : is_add_submonoid set.univ",
    "theorem": "{M : Type u_1} [add_monoid M] : is_add_submonoid set.univ",
    "args": "{M : Type u_1} [add_monoid M]",
    "doc_string": "An `add_monoid` is an `add_submonoid` of itself.",
    "kind": "theorem",
    "type": "is_add_submonoid set.univ"
  },
  {
    "name": "fintype.sum_right",
    "statement": "def fintype.sum_right {α : Type u_1} {β : Type u_2} [fintype (α ⊕ β)] : fintype β",
    "theorem": "{α : Type u_1} {β : Type u_2} [fintype (α ⊕ β)] : fintype β",
    "args": "{α : Type u_1} {β : Type u_2} [fintype (α ⊕ β)]",
    "doc_string": " Given that `α ⊕ β` is a fintype, `β` is also a fintype. This is non-computable as it uses that `sum.inr` is an injection, but there's no clear inverse if `β` is empty.",
    "kind": "def",
    "type": "fintype β"
  },
  {
    "name": "option.map_injective",
    "statement": "theorem option.map_injective {α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f) : function.injective (option.map f)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f) : function.injective (option.map f)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f)",
    "doc_string": "`option.map f` is injective if `f` is injective.",
    "kind": "theorem",
    "type": "function.injective (option.map f)"
  },
  {
    "name": "frame_hom.comp",
    "statement": "def frame_hom.comp {α : Type u_2} {β : Type u_3} {γ : Type u_4} [complete_lattice α] [complete_lattice β] [complete_lattice γ] (f : frame_hom β γ) (g : frame_hom α β) : frame_hom α γ",
    "theorem": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [complete_lattice α] [complete_lattice β] [complete_lattice γ] (f : frame_hom β γ) (g : frame_hom α β) : frame_hom α γ",
    "args": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [complete_lattice α] [complete_lattice β] [complete_lattice γ] (f : frame_hom β γ) (g : frame_hom α β)",
    "doc_string": "Composition of `frame_hom`s as a `frame_hom`.",
    "kind": "def",
    "type": "frame_hom α γ"
  },
  {
    "name": "order_ring_hom_class",
    "statement": "structure order_ring_hom_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [non_assoc_semiring α] [preorder α] [non_assoc_semiring β] [preorder β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [non_assoc_semiring α] [preorder α] [non_assoc_semiring β] [preorder β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [non_assoc_semiring α] [preorder α] [non_assoc_semiring β] [preorder β]",
    "doc_string": " `order_ring_hom_class F α β` states that `F` is a type of ordered semiring homomorphisms. You should extend this typeclass when you extend `order_ring_hom`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "bitvec.to_nat",
    "statement": "def bitvec.to_nat {n : ℕ} (v : bitvec n) : ℕ",
    "theorem": "{n : ℕ} (v : bitvec n) : ℕ",
    "args": "{n : ℕ} (v : bitvec n)",
    "doc_string": "Return the natural number encoded by the input bitvector",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "box_integral.box",
    "statement": "structure box_integral.box (ι : Type u_2) : Type u_2",
    "theorem": "(ι : Type u_2) : Type u_2",
    "args": "(ι : Type u_2)",
    "doc_string": " A nontrivial rectangular box in `ι → ℝ` with corners `lower` and `upper`. Repesents the product of half-open intervals `(lower i, upper i]`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "snum.succ",
    "statement": "def snum.succ  : snum → snum",
    "theorem": " : snum → snum",
    "args": "",
    "doc_string": "The successor of a `snum` (i.e. the operation adding one).",
    "kind": "def",
    "type": "snum → snum"
  },
  {
    "name": "conj_act.fixed_points_eq_center",
    "statement": "theorem conj_act.fixed_points_eq_center {G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = ↑(subgroup.center G)",
    "theorem": "{G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = ↑(subgroup.center G)",
    "args": "{G : Type u_2} [group G]",
    "doc_string": "The set of fixed points of the conjugation action of `G` on itself is the center of `G`.",
    "kind": "theorem",
    "type": "mul_action.fixed_points (conj_act G) G = ↑(subgroup.center G)"
  },
  {
    "name": "group_with_zero_of_is_unit_or_eq_zero",
    "statement": "def group_with_zero_of_is_unit_or_eq_zero {M : Type u_5} [nontrivial M] [hM : monoid_with_zero M] (h : ∀ (a : M), is_unit a ∨ a = 0) : group_with_zero M",
    "theorem": "{M : Type u_5} [nontrivial M] [hM : monoid_with_zero M] (h : ∀ (a : M), is_unit a ∨ a = 0) : group_with_zero M",
    "args": "{M : Type u_5} [nontrivial M] [hM : monoid_with_zero M] (h : ∀ (a : M), is_unit a ∨ a = 0)",
    "doc_string": "Constructs a `group_with_zero` structure on a `monoid_with_zero`  consisting only of units and 0.",
    "kind": "def",
    "type": "group_with_zero M"
  },
  {
    "name": "finset.op_sum",
    "statement": "theorem finset.op_sum {β : Type u} {α : Type v} [add_comm_monoid β] {s : finset α} (f : α → β) : mul_opposite.op (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), mul_opposite.op (f x))",
    "theorem": "{β : Type u} {α : Type v} [add_comm_monoid β] {s : finset α} (f : α → β) : mul_opposite.op (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), mul_opposite.op (f x))",
    "args": "{β : Type u} {α : Type v} [add_comm_monoid β] {s : finset α} (f : α → β)",
    "doc_string": "Moving to the opposite additive commutative monoid commutes with summing.",
    "kind": "theorem",
    "type": "mul_opposite.op (s.sum (λ (x : α), f x)) = s.sum (λ (x : α), mul_opposite.op (f x))"
  },
  {
    "name": "fin2.opt_of_nat",
    "statement": "def fin2.opt_of_nat {n : ℕ} (k : ℕ) : option (fin2 n)",
    "theorem": "{n : ℕ} (k : ℕ) : option (fin2 n)",
    "args": "{n : ℕ} (k : ℕ)",
    "doc_string": "Converts a natural into a `fin2` if it is in range",
    "kind": "def",
    "type": "option (fin2 n)"
  },
  {
    "name": "has_le.le.trans_eq'",
    "statement": "theorem has_le.le.trans_eq' {α : Type u} [preorder α] {a b c : α} : b ≤ c → a = b → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b ≤ c → a = b → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of le_of_le_of_eq'`.",
    "kind": "theorem",
    "type": "b ≤ c → a = b → a ≤ c"
  },
  {
    "name": "is_mul_hom",
    "statement": "structure is_mul_hom {α : Type u_1} {β : Type u_2} [has_mul α] [has_mul β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_mul α] [has_mul β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [has_mul α] [has_mul β] (f : α → β)",
    "doc_string": "Predicate for maps which preserve a multiplication.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "subring.copy",
    "statement": "def subring.copy {R : Type u} [ring R] (S : subring R) (s : set R) (hs : s = ↑S) : subring R",
    "theorem": "{R : Type u} [ring R] (S : subring R) (s : set R) (hs : s = ↑S) : subring R",
    "args": "{R : Type u} [ring R] (S : subring R) (s : set R) (hs : s = ↑S)",
    "doc_string": " Copy of a subring with a new `carrier` equal to the old one. Useful to fix definitional equalities.",
    "kind": "def",
    "type": "subring R"
  },
  {
    "name": "algebra.finite_type",
    "statement": "structure algebra.finite_type (R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop",
    "theorem": "(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop",
    "args": "(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A]",
    "doc_string": " An algebra over a commutative semiring is of `finite_type` if it is finitely generated over the base ring as algebra.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "matrix.invertible_of_det_invertible",
    "statement": "def matrix.invertible_of_det_invertible {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A.det] : invertible A",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A.det] : invertible A",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) [invertible A.det]",
    "doc_string": "If `A.det` has a constructive inverse, produce one for `A`.",
    "kind": "def",
    "type": "invertible A"
  },
  {
    "name": "fintype.to_complete_linear_order_of_nonempty",
    "statement": "def fintype.to_complete_linear_order_of_nonempty (α : Type u_2) [fintype α] [nonempty α] [linear_order α] : complete_linear_order α",
    "theorem": "(α : Type u_2) [fintype α] [nonempty α] [linear_order α] : complete_linear_order α",
    "args": "(α : Type u_2) [fintype α] [nonempty α] [linear_order α]",
    "doc_string": " A nonempty finite linear order is complete. If the linear order is already a `bounded_order`, then use `fintype.to_complete_linear_order` instead, as this gives definitional equality for `⊥` and `⊤`.",
    "kind": "def",
    "type": "complete_linear_order α"
  },
  {
    "name": "flow",
    "statement": "structure flow (τ : Type u_1) [topological_space τ] [add_monoid τ] [has_continuous_add τ] (α : Type u_2) [topological_space α] : Type (max u_1 u_2)",
    "theorem": "(τ : Type u_1) [topological_space τ] [add_monoid τ] [has_continuous_add τ] (α : Type u_2) [topological_space α] : Type (max u_1 u_2)",
    "args": "(τ : Type u_1) [topological_space τ] [add_monoid τ] [has_continuous_add τ] (α : Type u_2) [topological_space α]",
    "doc_string": "A flow on a topological space `α` by an a additive topological    monoid `τ` is a continuous monoid action of `τ` on `α`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "le_one_of_one_le_inv",
    "statement": "theorem le_one_of_one_le_inv {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ → a ≤ 1",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ → a ≤ 1",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.one_le_inv_iff`.",
    "kind": "theorem",
    "type": "1 ≤ a⁻¹ → a ≤ 1"
  },
  {
    "name": "is_noetherian_ring",
    "statement": "structure is_noetherian_ring (R : Type u_1) [semiring R] : Prop",
    "theorem": "(R : Type u_1) [semiring R] : Prop",
    "args": "(R : Type u_1) [semiring R]",
    "doc_string": "A (semi)ring is Noetherian if it is Noetherian as a module over itself, i.e. all its ideals are finitely generated.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "add_right_cancel_semigroup",
    "statement": "structure add_right_cancel_semigroup (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": " An `add_right_cancel_semigroup` is an additive semigroup such that `a + b = c + b` implies `a = c`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "set.mem_of_indicator_ne_zero",
    "statement": "theorem set.mem_of_indicator_ne_zero {α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s",
    "theorem": "{α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s",
    "args": "{α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0)",
    "doc_string": "If an additive indicator function is not equal to `0` at a point, then that point is in the set.",
    "kind": "theorem",
    "type": "a ∈ s"
  },
  {
    "name": "mvqpf.is_uniform",
    "statement": "def mvqpf.is_uniform {n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F) : Prop",
    "theorem": "{n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F) : Prop",
    "args": "{n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F)",
    "doc_string": " A qpf is said to be uniform if every polynomial functor representing a single value all have the same range.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.find_ge_aux",
    "statement": "def ordnode.find_ge_aux {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": "Auxiliary definition for `find_ge`.",
    "kind": "def",
    "type": "ordnode α → α → α"
  },
  {
    "name": "witt_vector.remainder",
    "statement": "def witt_vector.remainder (p n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ",
    "theorem": "(p n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ",
    "args": "(p n : ℕ)",
    "doc_string": "`remainder p n` represents the remainder term from `mul_poly_of_interest_aux3`. `witt_poly_prod p (n+1)` will have variables up to `n+1`, but `remainder` will only have variables up to `n`.",
    "kind": "def",
    "type": "mv_polynomial (fin 2 × ℕ) ℤ"
  },
  {
    "name": "one_lt_mul''",
    "statement": "theorem one_lt_mul'' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": "**Alias** of left.one_lt_mul'`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "znum.mod",
    "statement": "def znum.mod  : znum → znum → znum",
    "theorem": " : znum → znum → znum",
    "args": "",
    "doc_string": "Modulus of `znum`s.",
    "kind": "def",
    "type": "znum → znum → znum"
  },
  {
    "name": "tactic.itauto.prop",
    "statement": "inductive tactic.itauto.prop  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A reified inductive type for propositional logic.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "cc_state",
    "statement": "constant cc_state  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Congruence closure state. This may be considered to be a set of expressions and an equivalence class over this set. The equivalence class is generated by the equational rules that are added to the cc_state and congruence, that is, if `a = b` then `f(a) = f(b)` and so on.",
    "kind": "constant",
    "type": "Type"
  },
  {
    "name": "level",
    "statement": "inductive level  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A type universe term. eg `max u v`. Reflect a C++ level object. The VM replaces it with the C++ implementation.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "normalizer_condition",
    "statement": "def normalizer_condition (G : Type u_1) [group G] : Prop",
    "theorem": "(G : Type u_1) [group G] : Prop",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "Every proper subgroup `H` of `G` is a proper normal subgroup of the normalizer of `H` in `G`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "witt_vector.init",
    "statement": "def witt_vector.init {p : ℕ} {R : Type u_1} [comm_ring R] (n : ℕ) : witt_vector p R → witt_vector p R",
    "theorem": "{p : ℕ} {R : Type u_1} [comm_ring R] (n : ℕ) : witt_vector p R → witt_vector p R",
    "args": "{p : ℕ} {R : Type u_1} [comm_ring R] (n : ℕ)",
    "doc_string": " `witt_vector.init n x` is the Witt vector of which the first `n` coefficients are those from `x` and all other coefficients are `0`. See `witt_vector.tail` for the complementary part.",
    "kind": "def",
    "type": "witt_vector p R → witt_vector p R"
  },
  {
    "name": "ordnode.balance_l",
    "statement": "def ordnode.balance_l {α : Type u} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "theorem": "{α : Type u} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "args": "{α : Type u} (l : ordnode α) (x : α) (r : ordnode α)",
    "doc_string": " **Internal use only**  O(1). Rebalance a tree which was previously balanced but has had its left side grow by 1, or its right side shrink by 1.",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "encodable",
    "statement": "structure encodable (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " Constructively countable type. Made from an explicit injection `encode : α → ℕ` and a partial inverse `decode : ℕ → option α`. Note that finite types *are* countable. See `denumerable` if you wish to enforce infiniteness.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "ordnode.adjust_with",
    "statement": "def ordnode.adjust_with {α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → α) (x : α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → α) (x : α) : ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → α) (x : α)",
    "doc_string": " O(log n). Modify an element in the set with the given function, doing nothing if the key is not found. Note that the element returned by `f` must be equivalent to `x`.      adjust_with f 0 {1, 2, 3} = {1, 2, 3}     adjust_with f 1 {1, 2, 3} = {f 1, 2, 3}  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      adjust_with f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}     adjust_with f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "category_theory.has_projective_resolutions",
    "statement": "structure category_theory.has_projective_resolutions (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] : Prop",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C]",
    "doc_string": "You will rarely use this typeclass directly: it is implied by the combination `[enough_projectives C]` and `[abelian C]`. By itself it's enough to set up the basic theory of derived functors.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "right_cancel_monoid",
    "statement": "structure right_cancel_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": "A monoid in which multiplication is right-cancellative.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "nat.partrec.code.of_nat_code",
    "statement": "def nat.partrec.code.of_nat_code  : ℕ → nat.partrec.code",
    "theorem": " : ℕ → nat.partrec.code",
    "args": "",
    "doc_string": "A decoder for `nat.partrec.code.encode_code`, taking any ℕ to the `nat.partrec.code` it represents.",
    "kind": "def",
    "type": "ℕ → nat.partrec.code"
  },
  {
    "name": "category_theory.noetherian_object",
    "statement": "structure category_theory.noetherian_object {C : Type u_1} [category_theory.category C] (X : C) : Prop",
    "theorem": "{C : Type u_1} [category_theory.category C] (X : C) : Prop",
    "args": "{C : Type u_1} [category_theory.category C] (X : C)",
    "doc_string": "A noetherian object is an object which does not have infinite increasing sequences of subobjects.  See https://stacks.math.columbia.edu/tag/0FCG",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "bot_hom",
    "statement": "structure bot_hom (α : Type u_6) (β : Type u_7) [has_bot α] [has_bot β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [has_bot α] [has_bot β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [has_bot α] [has_bot β]",
    "doc_string": "The type of `⊥`-preserving functions from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "algebra.is_integral",
    "statement": "def algebra.is_integral (R : Type u_1) (A : Type u_3) [comm_ring R] [ring A] [algebra R A] : Prop",
    "theorem": "(R : Type u_1) (A : Type u_3) [comm_ring R] [ring A] [algebra R A] : Prop",
    "args": "(R : Type u_1) (A : Type u_3) [comm_ring R] [ring A] [algebra R A]",
    "doc_string": "An algebra is integral if every element of the extension is integral over the base ring",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "filter.has_add",
    "statement": "def filter.has_add {α : Type u_2} [has_add α] : has_add (filter α)",
    "theorem": "{α : Type u_2} [has_add α] : has_add (filter α)",
    "args": "{α : Type u_2} [has_add α]",
    "doc_string": "The filter `f + g` is generated by `{s + t | s ∈ f, t ∈ g}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_add (filter α)"
  },
  {
    "name": "minimals",
    "statement": "def minimals {α : Type u_1} (r : α → α → Prop) (s : set α) : set α",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s : set α) : set α",
    "args": "{α : Type u_1} (r : α → α → Prop) (s : set α)",
    "doc_string": "Turns a set into an antichain by keeping only the \"minimal\" elements.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "has_dist",
    "statement": "structure has_dist (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "The distance function (given an ambient metric space on `α`), which returns  a nonnegative real number `dist x y` given `x y : α`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "slim_check.printable_prop",
    "statement": "structure slim_check.printable_prop (p : Prop) : Type",
    "theorem": "(p : Prop) : Type",
    "args": "(p : Prop)",
    "doc_string": "`printable_prop p` allows one to print a proposition so that `slim_check` can indicate how values relate to each other.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "finset.Ioc_eq_empty",
    "statement": "theorem finset.Ioc_eq_empty {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ioc a b = ∅",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ioc a b = ∅",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of finset.Ioc_eq_empty_iff`.",
    "kind": "theorem",
    "type": "¬a < b → finset.Ioc a b = ∅"
  },
  {
    "name": "category_theory.groupoid",
    "statement": "structure category_theory.groupoid (obj : Type u) : Type (max u (v+1))",
    "theorem": "(obj : Type u) : Type (max u (v+1))",
    "args": "(obj : Type u)",
    "doc_string": "A `groupoid` is a category such that all morphisms are isomorphisms.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "filter.eventually_eq",
    "statement": "def filter.eventually_eq {α : Type u} {β : Type v} (l : filter α) (f g : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (l : filter α) (f g : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} (l : filter α) (f g : α → β)",
    "doc_string": " Two functions `f` and `g` are *eventually equal* along a filter `l` if the set of `x` such that `f x = g x` belongs to `l`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "mul_lt_of_lt_inv_mul",
    "statement": "theorem mul_lt_of_lt_inv_mul {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b < a⁻¹ * c → a * b < c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b < a⁻¹ * c → a * b < c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of lt_inv_mul_iff_mul_lt`.",
    "kind": "theorem",
    "type": "b < a⁻¹ * c → a * b < c"
  },
  {
    "name": "disjoint.filter_principal",
    "statement": "theorem disjoint.filter_principal {α : Type u_1} {s t : set α} : disjoint s t → disjoint (filter.principal s) (filter.principal t)",
    "theorem": "{α : Type u_1} {s t : set α} : disjoint s t → disjoint (filter.principal s) (filter.principal t)",
    "args": "{α : Type u_1} {s t : set α}",
    "doc_string": "**Alias** of the reverse direction of filter.disjoint_principal_principal`.",
    "kind": "theorem",
    "type": "disjoint s t → disjoint (filter.principal s) (filter.principal t)"
  },
  {
    "name": "order.succ",
    "statement": "def order.succ {α : Type u_1} [preorder α] [succ_order α] : α → α",
    "theorem": "{α : Type u_1} [preorder α] [succ_order α] : α → α",
    "args": "{α : Type u_1} [preorder α] [succ_order α]",
    "doc_string": " The successor of an element. If `a` is not maximal, then `succ a` is the least element greater than `a`. If `a` is maximal, then `succ a = a`.",
    "kind": "def",
    "type": "α → α"
  },
  {
    "name": "lazy_list.append",
    "statement": "def lazy_list.append {α : Type u} : lazy_list α → thunk (lazy_list α) → lazy_list α",
    "theorem": "{α : Type u} : lazy_list α → thunk (lazy_list α) → lazy_list α",
    "args": "{α : Type u}",
    "doc_string": "Appends two lazy lists.",
    "kind": "def",
    "type": "lazy_list α → thunk (lazy_list α) → lazy_list α"
  },
  {
    "name": "uniform_embedding",
    "statement": "structure uniform_embedding {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β)",
    "doc_string": " A map `f : α → β` between uniform spaces is a *uniform embedding* if it is uniform inducing and injective. If `α` is a separated space, then the latter assumption follows from the former.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "borel",
    "statement": "def borel (α : Type u) [topological_space α] : measurable_space α",
    "theorem": "(α : Type u) [topological_space α] : measurable_space α",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "`measurable_space` structure generated by `topological_space`.",
    "kind": "def",
    "type": "measurable_space α"
  },
  {
    "name": "is_regular_one",
    "statement": "theorem is_regular_one {R : Type u_1} [mul_one_class R] : is_regular 1",
    "theorem": "{R : Type u_1} [mul_one_class R] : is_regular 1",
    "args": "{R : Type u_1} [mul_one_class R]",
    "doc_string": "If multiplying by `1` on either side is the identity, `1` is regular.",
    "kind": "theorem",
    "type": "is_regular 1"
  },
  {
    "name": "matrix.is_symm",
    "statement": "def matrix.is_symm {α : Type u_1} {n : Type u_3} (A : matrix n n α) : Prop",
    "theorem": "{α : Type u_1} {n : Type u_3} (A : matrix n n α) : Prop",
    "args": "{α : Type u_1} {n : Type u_3} (A : matrix n n α)",
    "doc_string": "A matrix `A : matrix n n α` is \"symmetric\" if `Aᵀ = A`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "comm_ring",
    "statement": "structure comm_ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A commutative ring is a `ring` with commutative multiplication.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "add_submonoid.closure",
    "statement": "def add_submonoid.closure {M : Type u_1} [add_zero_class M] (s : set M) : add_submonoid M",
    "theorem": "{M : Type u_1} [add_zero_class M] (s : set M) : add_submonoid M",
    "args": "{M : Type u_1} [add_zero_class M] (s : set M)",
    "doc_string": "The `add_submonoid` generated by a set",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "category_theory.is_cofiltered.min",
    "statement": "def category_theory.is_cofiltered.min {C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (j j' : C) : C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (j j' : C) : C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.is_cofiltered C] (j j' : C)",
    "doc_string": "`min j j'` is an arbitrary choice of object to the left of both `j` and `j'`, whose existence is ensured by `is_cofiltered`.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "add_con.add_ker",
    "statement": "def add_con.add_ker {M : Type u_1} {P : Type u_3} [has_add M] [has_add P] (f : M → P) (h : ∀ (x y : M), f (x + y) = f x + f y) : add_con M",
    "theorem": "{M : Type u_1} {P : Type u_3} [has_add M] [has_add P] (f : M → P) (h : ∀ (x y : M), f (x + y) = f x + f y) : add_con M",
    "args": "{M : Type u_1} {P : Type u_3} [has_add M] [has_add P] (f : M → P) (h : ∀ (x y : M), f (x + y) = f x + f y)",
    "doc_string": "The kernel of an addition-preserving function as an additive congruence relation.",
    "kind": "def",
    "type": "add_con M"
  },
  {
    "name": "name.is_private",
    "statement": "def name.is_private (n : name) : bool",
    "theorem": "(n : name) : bool",
    "args": "(n : name)",
    "doc_string": "Tests whether the first component of a name is `\"_private\"`",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "sym2.mem.other",
    "statement": "def sym2.mem.other {α : Type u_1} {a : α} {z : sym2 α} (h : a ∈ z) : α",
    "theorem": "{α : Type u_1} {a : α} {z : sym2 α} (h : a ∈ z) : α",
    "args": "{α : Type u_1} {a : α} {z : sym2 α} (h : a ∈ z)",
    "doc_string": "Given an element of the unordered pair, give the other element using `classical.some`. See also `mem.other'` for the computable version.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "set.inv_on",
    "statement": "def set.inv_on {α : Type u} {β : Type v} (g : β → α) (f : α → β) (s : set α) (t : set β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (g : β → α) (f : α → β) (s : set α) (t : set β) : Prop",
    "args": "{α : Type u} {β : Type v} (g : β → α) (f : α → β) (s : set α) (t : set β)",
    "doc_string": "`g` is an inverse to `f` viewed as a map from `a` to `b`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "one_hom.comp",
    "statement": "def one_hom.comp {M : Type u_3} {N : Type u_4} {P : Type u_5} [has_one M] [has_one N] [has_one P] (hnp : one_hom N P) (hmn : one_hom M N) : one_hom M P",
    "theorem": "{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_one M] [has_one N] [has_one P] (hnp : one_hom N P) (hmn : one_hom M N) : one_hom M P",
    "args": "{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_one M] [has_one N] [has_one P] (hnp : one_hom N P) (hmn : one_hom M N)",
    "doc_string": "Composition of `one_hom`s as a `one_hom`.",
    "kind": "def",
    "type": "one_hom M P"
  },
  {
    "name": "category_theory.limits.has_binary_product.swap",
    "statement": "theorem category_theory.limits.has_binary_product.swap {C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P",
    "theorem": "{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P",
    "args": "{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q]",
    "doc_string": "Construct `has_binary_product Q P` from `has_binary_product P Q`. This can't be an instance, as it would cause a loop in typeclass search.",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_product Q P"
  },
  {
    "name": "bounded_continuous_function.has_add",
    "statement": "def bounded_continuous_function.has_add {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] [add_monoid β] [has_lipschitz_add β] : has_add (bounded_continuous_function α β)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] [add_monoid β] [has_lipschitz_add β] : has_add (bounded_continuous_function α β)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] [add_monoid β] [has_lipschitz_add β]",
    "doc_string": "The pointwise sum of two bounded continuous functions is again bounded continuous.",
    "kind": "def",
    "type": "has_add (bounded_continuous_function α β)"
  },
  {
    "name": "cardinal",
    "statement": "def cardinal  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "`cardinal.{u}` is the type of cardinal numbers in `Type u`,  defined as the quotient of `Type u` by existence of an equivalence  (a bijection with explicit inverse).",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "matrix.vec_empty",
    "statement": "def matrix.vec_empty {α : Type u} : fin 0 → α",
    "theorem": "{α : Type u} : fin 0 → α",
    "args": "{α : Type u}",
    "doc_string": "`![]` is the vector with no entries.",
    "kind": "def",
    "type": "fin 0 → α"
  },
  {
    "name": "set.image3",
    "statement": "def set.image3 {α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} (g : α → β → γ → δ) (s : set α) (t : set β) (u : set γ) : set δ",
    "theorem": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} (g : α → β → γ → δ) (s : set α) (t : set β) (u : set γ) : set δ",
    "args": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} {δ : Type u_7} (g : α → β → γ → δ) (s : set α) (t : set β) (u : set γ)",
    "doc_string": "The image of a ternary function `f : α → β → γ → δ` as a function  `set α → set β → set γ → set δ`. Mathematically this should be thought of as the image of the  corresponding function `α × β × γ → δ`.",
    "kind": "def",
    "type": "set δ"
  },
  {
    "name": "vector3.append",
    "statement": "def vector3.append {α : Type u_1} {m n : ℕ} (v : vector3 α m) (w : vector3 α n) : vector3 α (n + m)",
    "theorem": "{α : Type u_1} {m n : ℕ} (v : vector3 α m) (w : vector3 α n) : vector3 α (n + m)",
    "args": "{α : Type u_1} {m n : ℕ} (v : vector3 α m) (w : vector3 α n)",
    "doc_string": "Append two vectors",
    "kind": "def",
    "type": "vector3 α (n + m)"
  },
  {
    "name": "omega.ee_state",
    "statement": "structure omega.ee_state  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The state of equality elimination proof search. `eqs` is the list of    equality constraints, and each `t ∈ eqs` represents the constraint `0 = t`.    Similarly, `les` is the list of inequality constraints, and each `t ∈ eqs`    represents the constraint `0 < t`. `ees` is the sequence of equality    elimination steps that have been used so far to obtain the current set of    constraints. The list `ees` grows over time until `eqs` becomes empty.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "num.bit0",
    "statement": "def num.bit0  : num → num",
    "theorem": " : num → num",
    "args": "",
    "doc_string": "`bit0 n` appends a `0` to the end of `n`, where `bit0 n = n0`.",
    "kind": "def",
    "type": "num → num"
  },
  {
    "name": "is_closed_proj_of_is_compact",
    "statement": "theorem is_closed_proj_of_is_compact {X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd",
    "theorem": "{X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd",
    "args": "{X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y]",
    "doc_string": "If X is is_compact then pr₂ : X × Y → Y is a closed map",
    "kind": "theorem",
    "type": "is_closed_map prod.snd"
  },
  {
    "name": "list.foldl_with_index_aux_spec",
    "statement": "def list.foldl_with_index_aux_spec {α : Type u} {β : Type v} (f : ℕ → α → β → α) (start : ℕ) (a : α) (bs : list β) : α",
    "theorem": "{α : Type u} {β : Type v} (f : ℕ → α → β → α) (start : ℕ) (a : α) (bs : list β) : α",
    "args": "{α : Type u} {β : Type v} (f : ℕ → α → β → α) (start : ℕ) (a : α) (bs : list β)",
    "doc_string": "Specification of `foldl_with_index_aux`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "is_prime_pow_iff_unique_prime_dvd",
    "statement": "theorem is_prime_pow_iff_unique_prime_dvd {n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n",
    "theorem": "{n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n",
    "args": "{n : ℕ}",
    "doc_string": " An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it.",
    "kind": "theorem",
    "type": "is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n"
  },
  {
    "name": "function.is_fixed_pt_id",
    "statement": "theorem function.is_fixed_pt_id {α : Type u} (x : α) : function.is_fixed_pt id x",
    "theorem": "{α : Type u} (x : α) : function.is_fixed_pt id x",
    "args": "{α : Type u} (x : α)",
    "doc_string": "Every point is a fixed point of `id`.",
    "kind": "theorem",
    "type": "function.is_fixed_pt id x"
  },
  {
    "name": "bounded_lattice_hom.to_sup_bot_hom",
    "statement": "def bounded_lattice_hom.to_sup_bot_hom {α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β) : sup_bot_hom α β",
    "theorem": "{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β) : sup_bot_hom α β",
    "args": "{α : Type u_3} {β : Type u_4} [lattice α] [lattice β] [bounded_order α] [bounded_order β] (f : bounded_lattice_hom α β)",
    "doc_string": "Reinterpret a `bounded_lattice_hom` as a `sup_bot_hom`.",
    "kind": "def",
    "type": "sup_bot_hom α β"
  },
  {
    "name": "snum.test_bit",
    "statement": "def snum.test_bit  : ℕ → snum → bool",
    "theorem": " : ℕ → snum → bool",
    "args": "",
    "doc_string": "`snum.test_bit n a` is `tt` iff the `n`-th bit (starting from the LSB) of `a` is active.      If the size of `a` is less than `n`, this evaluates to `ff`.",
    "kind": "def",
    "type": "ℕ → snum → bool"
  },
  {
    "name": "function.is_periodic_pt",
    "statement": "def function.is_periodic_pt {α : Type u_1} (f : α → α) (n : ℕ) (x : α) : Prop",
    "theorem": "{α : Type u_1} (f : α → α) (n : ℕ) (x : α) : Prop",
    "args": "{α : Type u_1} (f : α → α) (n : ℕ) (x : α)",
    "doc_string": " A point `x` is a periodic point of `f : α → α` of period `n` if `f^[n] x = x`. Note that we do not require `0 < n` in this definition. Many theorems about periodic points need this assumption.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nndist_eq_zero",
    "statement": "theorem nndist_eq_zero {γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 ↔ x = y",
    "theorem": "{γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 ↔ x = y",
    "args": "{γ : Type w} [metric_space γ] {x y : γ}",
    "doc_string": "Characterize the equality of points with the vanishing of the nonnegative distance",
    "kind": "theorem",
    "type": "has_nndist.nndist x y = 0 ↔ x = y"
  },
  {
    "name": "subfield.multiset_prod_mem",
    "statement": "theorem subfield.multiset_prod_mem {K : Type u} [field K] (s : subfield K) (m : multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.prod ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) (m : multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.prod ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K) (m : multiset K)",
    "doc_string": "Product of a multiset of elements in a subfield is in the subfield.",
    "kind": "theorem",
    "type": "(∀ (a : K), a ∈ m → a ∈ s) → m.prod ∈ s"
  },
  {
    "name": "tactic.merge_list",
    "statement": "def tactic.merge_list {α : Type u_1} (m : α → α → α) : list α → list α → list α",
    "theorem": "{α : Type u_1} (m : α → α → α) : list α → list α → list α",
    "args": "{α : Type u_1} (m : α → α → α)",
    "doc_string": " Like `zip_with`, but if the lists don't match in length, the excess elements will be put at the end of the result.",
    "kind": "def",
    "type": "list α → list α → list α"
  },
  {
    "name": "algebra_nat",
    "statement": "def algebra_nat {R : Type u_1} [semiring R] : algebra ℕ R",
    "theorem": "{R : Type u_1} [semiring R] : algebra ℕ R",
    "args": "{R : Type u_1} [semiring R]",
    "doc_string": "Semiring ⥤ ℕ-Alg",
    "kind": "def",
    "type": "algebra ℕ R"
  },
  {
    "name": "lt_of_sub_pos",
    "statement": "theorem lt_of_sub_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : 0 < a - b → b < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : 0 < a - b → b < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the forward direction of sub_pos`.",
    "kind": "theorem",
    "type": "0 < a - b → b < a"
  },
  {
    "name": "zmod.legendre_sym_sq_one'",
    "statement": "theorem zmod.legendre_sym_sq_one' (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p (a ^ 2) = 1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p (a ^ 2) = 1",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0)",
    "doc_string": "The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`.",
    "kind": "theorem",
    "type": "zmod.legendre_sym p (a ^ 2) = 1"
  },
  {
    "name": "unique_factorization_monoid",
    "statement": "structure unique_factorization_monoid (α : Type u_2) [cancel_comm_monoid_with_zero α] : Prop",
    "theorem": "(α : Type u_2) [cancel_comm_monoid_with_zero α] : Prop",
    "args": "(α : Type u_2) [cancel_comm_monoid_with_zero α]",
    "doc_string": " unique factorization monoids.  These are defined as `cancel_comm_monoid_with_zero`s with well-founded strict divisibility relations, but this is equivalent to more familiar definitions:  Each element (except zero) is uniquely represented as a multiset of irreducible factors. Uniqueness is only up to associated elements.  Each element (except zero) is non-uniquely represented as a multiset of prime factors.  To define a UFD using the definition in terms of multisets of irreducible factors, use the definition `of_exists_unique_irreducible_factors`  To define a UFD using the definition in terms of multisets of prime factors, use the definition `of_exists_prime_factors`",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordinal.out'",
    "statement": "def ordinal.out' (o : ordinal) : Well_order",
    "theorem": "(o : ordinal) : Well_order",
    "args": "(o : ordinal)",
    "doc_string": "`ordinal.out'` has the sole purpose of making `nim` computable. It performs the same job as  `quotient.out` but is specific to ordinals.",
    "kind": "def",
    "type": "Well_order"
  },
  {
    "name": "list.sublists'",
    "statement": "def list.sublists' {α : Type u_1} (l : list α) : list (list α)",
    "theorem": "{α : Type u_1} (l : list α) : list (list α)",
    "args": "{α : Type u_1} (l : list α)",
    "doc_string": "`sublists' l` is the list of all (non-contiguous) sublists of `l`.  It differs from `sublists` only in the order of appearance of the sublists;  `sublists'` uses the first element of the list as the MSB,  `sublists` uses the first element of the list as the LSB.      sublists' [1, 2, 3] = [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]",
    "kind": "def",
    "type": "list (list α)"
  },
  {
    "name": "linear_independent_monoid_hom",
    "statement": "theorem linear_independent_monoid_hom (G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (λ (f : G →* L), ⇑f)",
    "theorem": "(G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (λ (f : G →* L), ⇑f)",
    "args": "(G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L]",
    "doc_string": "Dedekind's linear independence of characters",
    "kind": "theorem",
    "type": "linear_independent L (λ (f : G →* L), ⇑f)"
  },
  {
    "name": "multiset.ndunion",
    "statement": "def multiset.ndunion {α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "args": "{α : Type u_1} [decidable_eq α] (s t : multiset α)",
    "doc_string": "`ndunion s t` is the lift of the list `union` operation. This operation  does not respect multiplicities, unlike `s ∪ t`, but it is suitable as  a union operation on `finset`. (`s ∪ t` would also work as a union operation  on finset, but this is more efficient.)",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "witt_vector.teichmuller_fun",
    "statement": "def witt_vector.teichmuller_fun (p : ℕ) {R : Type u_1} [comm_ring R] (r : R) : witt_vector p R",
    "theorem": "(p : ℕ) {R : Type u_1} [comm_ring R] (r : R) : witt_vector p R",
    "args": "(p : ℕ) {R : Type u_1} [comm_ring R] (r : R)",
    "doc_string": "The underlying function of the monoid hom `witt_vector.teichmuller`. The `0`-th coefficient of `teichmuller_fun p r` is `r`, and all others are `0`.",
    "kind": "def",
    "type": "witt_vector p R"
  },
  {
    "name": "category_theory.limits.multispan_index",
    "statement": "structure category_theory.limits.multispan_index (C : Type u) [category_theory.category C] : Type (max u (v+1))",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u (v+1))",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "This is a structure encapsulating the data necessary to define a `multispan`.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "euclidean_domain.gcd",
    "statement": "def euclidean_domain.gcd {R : Type u} [euclidean_domain R] [decidable_eq R] : R → R → R",
    "theorem": "{R : Type u} [euclidean_domain R] [decidable_eq R] : R → R → R",
    "args": "{R : Type u} [euclidean_domain R] [decidable_eq R]",
    "doc_string": "`gcd a b` is a (non-unique) element such that `gcd a b ∣ a` `gcd a b ∣ b`, and for  any element `c` such that `c ∣ a` and `c ∣ b`, then `c ∣ gcd a b`",
    "kind": "def",
    "type": "R → R → R"
  },
  {
    "name": "local_equiv.refl",
    "statement": "def local_equiv.refl (α : Type u_1) : local_equiv α α",
    "theorem": "(α : Type u_1) : local_equiv α α",
    "args": "(α : Type u_1)",
    "doc_string": "The identity local equiv",
    "kind": "def",
    "type": "local_equiv α α"
  },
  {
    "name": "parser.prog",
    "statement": "structure parser.prog {α : Type} (p : parser α) : Prop",
    "theorem": "{α : Type} (p : parser α) : Prop",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "A `parser α` is defined to be `prog` if it always moves forward on success.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nontrivial.to_nonempty",
    "statement": "def nontrivial.to_nonempty {α : Type u_1} [nontrivial α] : nonempty α",
    "theorem": "{α : Type u_1} [nontrivial α] : nonempty α",
    "args": "{α : Type u_1} [nontrivial α]",
    "doc_string": "See Note [lower instance priority]  Note that since this and `nonempty_of_inhabited` are the most \"obvious\" way to find a nonempty instance if no direct instance can be found, we give this a higher priority than the usual `100`.",
    "kind": "def",
    "type": "nonempty α"
  },
  {
    "name": "zero_mem_class",
    "statement": "structure zero_mem_class (S : Type u_4) (M : out_param (Type u_5)) [has_zero M] [set_like S M] : Type",
    "theorem": "(S : Type u_4) (M : out_param (Type u_5)) [has_zero M] [set_like S M] : Type",
    "args": "(S : Type u_4) (M : out_param (Type u_5)) [has_zero M] [set_like S M]",
    "doc_string": "`zero_mem_class S M` says `S` is a type of subsets `s ≤ M`, such that `0 ∈ s` for all `s`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "bitvec.fill_shr",
    "statement": "def bitvec.fill_shr {n : ℕ} (x : bitvec n) (i : ℕ) (fill : bool) : bitvec n",
    "theorem": "{n : ℕ} (x : bitvec n) (i : ℕ) (fill : bool) : bitvec n",
    "args": "{n : ℕ} (x : bitvec n) (i : ℕ) (fill : bool)",
    "doc_string": " `fill_shr x i fill` is the bitvector obtained by right-shifting `x` `i` times and then padding with `fill : bool`. If `x.length < i` then this will return the constant `fill` bitvector.",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "finprod_mem_empty",
    "statement": "theorem finprod_mem_empty {α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} : finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1",
    "theorem": "{α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} : finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1",
    "args": "{α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M}",
    "doc_string": "The product of any function over an empty set is `1`.",
    "kind": "theorem",
    "type": "finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1"
  },
  {
    "name": "free_product.is_free_group",
    "statement": "def free_product.is_free_group {ι : Type u_1} (G : ι → Type u_2) [Π (i : ι), group (G i)] [hG : Π (i : ι), is_free_group (G i)] : is_free_group (free_product G)",
    "theorem": "{ι : Type u_1} (G : ι → Type u_2) [Π (i : ι), group (G i)] [hG : Π (i : ι), is_free_group (G i)] : is_free_group (free_product G)",
    "args": "{ι : Type u_1} (G : ι → Type u_2) [Π (i : ι), group (G i)] [hG : Π (i : ι), is_free_group (G i)]",
    "doc_string": "The free product of free groups is itself a free group",
    "kind": "def",
    "type": "is_free_group (free_product G)"
  },
  {
    "name": "add_submonoid.of",
    "statement": "def add_submonoid.of {M : Type u_1} [add_monoid M] {s : set M} (h : is_add_submonoid s) : add_submonoid M",
    "theorem": "{M : Type u_1} [add_monoid M] {s : set M} (h : is_add_submonoid s) : add_submonoid M",
    "args": "{M : Type u_1} [add_monoid M] {s : set M} (h : is_add_submonoid s)",
    "doc_string": "Create a bundled additive submonoid from a set `s` and `[is_add_submonoid s]`.",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "tendsto_inv_zero_at_top",
    "statement": "theorem tendsto_inv_zero_at_top {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top",
    "theorem": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top",
    "args": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α]",
    "doc_string": "The function `x ↦ x⁻¹` tends to `+∞` on the right of `0`.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top"
  },
  {
    "name": "multilinear_map.mk_pi_algebra_fin",
    "statement": "def multilinear_map.mk_pi_algebra_fin (R : Type u) (n : ℕ) [comm_semiring R] (A : Type u_1) [semiring A] [algebra R A] : multilinear_map R (λ (i : fin n), A) A",
    "theorem": "(R : Type u) (n : ℕ) [comm_semiring R] (A : Type u_1) [semiring A] [algebra R A] : multilinear_map R (λ (i : fin n), A) A",
    "args": "(R : Type u) (n : ℕ) [comm_semiring R] (A : Type u_1) [semiring A] [algebra R A]",
    "doc_string": " Given an `R`-algebra `A`, `mk_pi_algebra_fin` is the multilinear map on `A^n` associating to `m` the product of all the `m i`.  See also `multilinear_map.mk_pi_algebra` for a version that assumes `[comm_semiring A]` but works for `A^ι` with any finite type `ι`.",
    "kind": "def",
    "type": "multilinear_map R (λ (i : fin n), A) A"
  },
  {
    "name": "topological_space",
    "statement": "structure topological_space (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A topology on `α`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "function.injective.comp_left",
    "statement": "theorem function.injective.comp_left {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g) : function.injective (function.comp g)",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g) : function.injective (function.comp g)",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g)",
    "doc_string": "Composition by an injective function on the left is itself injective.",
    "kind": "theorem",
    "type": "function.injective (function.comp g)"
  },
  {
    "name": "option.iget",
    "statement": "def option.iget {α : Type u_1} [inhabited α] : option α → α",
    "theorem": "{α : Type u_1} [inhabited α] : option α → α",
    "args": "{α : Type u_1} [inhabited α]",
    "doc_string": "Inhabited `get` function. Returns `a` if the input is `some a`, otherwise returns `default`.",
    "kind": "def",
    "type": "option α → α"
  },
  {
    "name": "slim_check.int.has_sizeof",
    "statement": "def slim_check.int.has_sizeof  : has_sizeof ℤ",
    "theorem": " : has_sizeof ℤ",
    "args": "",
    "doc_string": "Redefine `sizeof` for `int` to make it easier to use with `nat`",
    "kind": "def",
    "type": "has_sizeof ℤ"
  },
  {
    "name": "function.injective.subsingleton",
    "statement": "theorem function.injective.subsingleton {α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β] : subsingleton α",
    "theorem": "{α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β] : subsingleton α",
    "args": "{α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β]",
    "doc_string": " If the codomain of an injective function is a subsingleton, then the domain is a subsingleton as well.",
    "kind": "theorem",
    "type": "subsingleton α"
  },
  {
    "name": "vsub_left_injective",
    "statement": "theorem vsub_left_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : P), _x -ᵥ p)",
    "theorem": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : P), _x -ᵥ p)",
    "args": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P)",
    "doc_string": "Subtracting the point `p` is an injective function.",
    "kind": "theorem",
    "type": "function.injective (λ (_x : P), _x -ᵥ p)"
  },
  {
    "name": "ulift.bind",
    "statement": "def ulift.bind {α : Type u} {β : Type v} (a : ulift α) (f : α → ulift β) : ulift β",
    "theorem": "{α : Type u} {β : Type v} (a : ulift α) (f : α → ulift β) : ulift β",
    "args": "{α : Type u} {β : Type v} (a : ulift α) (f : α → ulift β)",
    "doc_string": "Monadic bind.",
    "kind": "def",
    "type": "ulift β"
  },
  {
    "name": "has_lt.lt.not_is_max",
    "statement": "theorem has_lt.lt.not_is_max {α : Type u_1} [preorder α] {a b : α} (h : a < b) : ¬is_max a",
    "theorem": "{α : Type u_1} [preorder α] {a b : α} (h : a < b) : ¬is_max a",
    "args": "{α : Type u_1} [preorder α] {a b : α} (h : a < b)",
    "doc_string": "**Alias** of not_is_max_of_lt`.",
    "kind": "theorem",
    "type": "¬is_max a"
  },
  {
    "name": "lazy_list.singleton",
    "statement": "def lazy_list.singleton {α : Type u} : α → lazy_list α",
    "theorem": "{α : Type u} : α → lazy_list α",
    "args": "{α : Type u}",
    "doc_string": "The singleton lazy list.",
    "kind": "def",
    "type": "α → lazy_list α"
  },
  {
    "name": "slim_check.test_result",
    "statement": "inductive slim_check.test_result (p : Prop) : Type",
    "theorem": "(p : Prop) : Type",
    "args": "(p : Prop)",
    "doc_string": " Result of trying to disprove `p`  The constructors are:   *  `success : (psum unit p) → test_result`      succeed when we find another example satisfying `p`      In `success h`, `h` is an optional proof of the proposition.      Without the proof, all we know is that we found one example      where `p` holds. With a proof, the one test was sufficient to      prove that `p` holds and we do not need to keep finding examples.    * `gave_up {} : ℕ → test_result`      give up when a well-formed example cannot be generated.      `gave_up n` tells us that `n` invalid examples were tried.      Above 100, we give up on the proposition and report that we      did not find a way to properly test it.    * `failure : ¬ p → (list string) → ℕ → test_result`      a counter-example to `p`; the strings specify values for the relevant variables.      `failure h vs n` also carries a proof that `p` does not hold. This way, we can      guarantee that there will be no false positive. The last component, `n`,      is the number of times that the counter-example was shrunk.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "dioph",
    "statement": "def dioph {α : Type u} (S : set (α → ℕ)) : Prop",
    "theorem": "{α : Type u} (S : set (α → ℕ)) : Prop",
    "args": "{α : Type u} (S : set (α → ℕ))",
    "doc_string": "A set `S ⊆ ℕ^α` is Diophantine if there exists a polynomial on  `α ⊕ β` such that `v ∈ S` iff there exists `t : ℕ^β` with `p (v, t) = 0`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "localization.subalgebra.of_field",
    "statement": "def localization.subalgebra.of_field {A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) (hS : S ≤ non_zero_divisors A) [field K] [algebra A K] [is_fraction_ring A K] : subalgebra A K",
    "theorem": "{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) (hS : S ≤ non_zero_divisors A) [field K] [algebra A K] [is_fraction_ring A K] : subalgebra A K",
    "args": "{A : Type u_1} (K : Type u_2) [comm_ring A] (S : submonoid A) (hS : S ≤ non_zero_divisors A) [field K] [algebra A K] [is_fraction_ring A K]",
    "doc_string": "Given a domain `A` with fraction field `K`, and a submonoid `S` of `A` which contains no zero divisor, this is the localization of `A` at `S`, considered as a subalgebra of `K` over `A`.  The carrier of this subalgebra is defined as the set of all `x : K` of the form `algebra_map A K a * (algebra_map A K s)⁻¹` where `a s : A` and `s ∈ S`.",
    "kind": "def",
    "type": "subalgebra A K"
  },
  {
    "name": "stream.odd",
    "statement": "def stream.odd {α : Type u} (s : stream α) : stream α",
    "theorem": "{α : Type u} (s : stream α) : stream α",
    "args": "{α : Type u} (s : stream α)",
    "doc_string": "Elements of a stream with odd indices.",
    "kind": "def",
    "type": "stream α"
  },
  {
    "name": "DistribLattice.of",
    "statement": "def DistribLattice.of (α : Type u_1) [distrib_lattice α] : DistribLattice",
    "theorem": "(α : Type u_1) [distrib_lattice α] : DistribLattice",
    "args": "(α : Type u_1) [distrib_lattice α]",
    "doc_string": "Construct a bundled `DistribLattice` from a `distrib_lattice` underlying type and typeclass.",
    "kind": "def",
    "type": "DistribLattice"
  },
  {
    "name": "has_continuous_inv",
    "statement": "structure has_continuous_inv (G : Type u) [topological_space G] [has_inv G] : Prop",
    "theorem": "(G : Type u) [topological_space G] [has_inv G] : Prop",
    "args": "(G : Type u) [topological_space G] [has_inv G]",
    "doc_string": " Basic hypothesis to talk about a topological group. A topological group over `M`, for example, is obtained by requiring the instances `group M` and `has_continuous_mul M` and `has_continuous_inv M`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "with_bot",
    "statement": "def with_bot (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Attach `⊥` to a type.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "quaternion_group.order_of_a_one",
    "statement": "theorem quaternion_group.order_of_a_one {n : ℕ} : order_of (quaternion_group.a 1) = 2 * n",
    "theorem": "{n : ℕ} : order_of (quaternion_group.a 1) = 2 * n",
    "args": "{n : ℕ}",
    "doc_string": "If `0 < n`, then `a 1` has order `2 * n`.",
    "kind": "theorem",
    "type": "order_of (quaternion_group.a 1) = 2 * n"
  },
  {
    "name": "multiset.noncomm_prod",
    "statement": "def multiset.noncomm_prod {α : Type u_1} [monoid α] (s : multiset α) (comm : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → commute x y) : α",
    "theorem": "{α : Type u_1} [monoid α] (s : multiset α) (comm : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → commute x y) : α",
    "args": "{α : Type u_1} [monoid α] (s : multiset α) (comm : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → commute x y)",
    "doc_string": " Product of a `s : multiset α` with `[monoid α]`, given a proof that `*` commutes on all elements `x ∈ s`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "complete_lattice_hom_class",
    "statement": "structure complete_lattice_hom_class (F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [complete_lattice α] [complete_lattice β] : Type (max u_10 u_8 u_9)",
    "theorem": "(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [complete_lattice α] [complete_lattice β] : Type (max u_10 u_8 u_9)",
    "args": "(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [complete_lattice α] [complete_lattice β]",
    "doc_string": " `complete_lattice_hom_class F α β` states that `F` is a type of complete lattice morphisms.  You should extend this class when you extend `complete_lattice_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_8 u_9)"
  },
  {
    "name": "hidden",
    "statement": "def hidden {α : Sort u_1} {a : α} : α",
    "theorem": "{α : Sort u_1} {a : α} : α",
    "args": "{α : Sort u_1} {a : α}",
    "doc_string": " An identity function with its main argument implicit. This will be printed as `hidden` even if it is applied to a large term, so it can be used for elision, as done in the `elide` and `unelide` tactics.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "Set",
    "statement": "def Set  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The ZFC universe of sets consists of the type of pre-sets,  quotiented by extensional equivalence.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "part.map",
    "statement": "def part.map {α : Type u_1} {β : Type u_2} (f : α → β) (o : part α) : part β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (o : part α) : part β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (o : part α)",
    "doc_string": "The map operation for `part` just maps the value and maintains the same domain.",
    "kind": "def",
    "type": "part β"
  },
  {
    "name": "bitvec.ule",
    "statement": "def bitvec.ule {n : ℕ} (x y : bitvec n) : Prop",
    "theorem": "{n : ℕ} (x y : bitvec n) : Prop",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "unsigned less-than-or-equal-to proposition",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.abelian.has_pushouts",
    "statement": "def category_theory.abelian.has_pushouts {C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pushouts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pushouts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C]",
    "doc_string": "Any abelian category has pushouts",
    "kind": "def",
    "type": "category_theory.limits.has_pushouts C"
  },
  {
    "name": "matrix.diagonal",
    "statement": "def matrix.diagonal {n : Type u_3} {α : Type v} [decidable_eq n] [has_zero α] (d : n → α) : matrix n n α",
    "theorem": "{n : Type u_3} {α : Type v} [decidable_eq n] [has_zero α] (d : n → α) : matrix n n α",
    "args": "{n : Type u_3} {α : Type v} [decidable_eq n] [has_zero α] (d : n → α)",
    "doc_string": " `diagonal d` is the square matrix such that `(diagonal d) i i = d i` and `(diagonal d) i j = 0` if `i ≠ j`.  Note that bundled versions exist as: * `matrix.diagonal_add_monoid_hom` * `matrix.diagonal_linear_map` * `matrix.diagonal_ring_hom` * `matrix.diagonal_alg_hom`",
    "kind": "def",
    "type": "matrix n n α"
  },
  {
    "name": "id_rel",
    "statement": "def id_rel {α : Type u_1} : set (α × α)",
    "theorem": "{α : Type u_1} : set (α × α)",
    "args": "{α : Type u_1}",
    "doc_string": "The identity relation, or the graph of the identity function",
    "kind": "def",
    "type": "set (α × α)"
  },
  {
    "name": "tree.get",
    "statement": "def tree.get {α : Type u} : pos_num → tree α → option α",
    "theorem": "{α : Type u} : pos_num → tree α → option α",
    "args": "{α : Type u}",
    "doc_string": " Retrieves an element uniquely determined by a `pos_num` from the tree, taking the following path to get to the element: - `bit0` - go to left child - `bit1` - go to right child - `pos_num.one` - retrieve from here",
    "kind": "def",
    "type": "pos_num → tree α → option α"
  },
  {
    "name": "finset.bdd_above",
    "statement": "theorem finset.bdd_above {α : Type u} [semilattice_sup α] [nonempty α] (s : finset α) : bdd_above ↑s",
    "theorem": "{α : Type u} [semilattice_sup α] [nonempty α] (s : finset α) : bdd_above ↑s",
    "args": "{α : Type u} [semilattice_sup α] [nonempty α] (s : finset α)",
    "doc_string": "A finset is bounded above.",
    "kind": "theorem",
    "type": "bdd_above ↑s"
  },
  {
    "name": "prod.Pointed",
    "statement": "def prod.Pointed {X : Type u_1} (point : X) : Pointed",
    "theorem": "{X : Type u_1} (point : X) : Pointed",
    "args": "{X : Type u_1} (point : X)",
    "doc_string": "**Alias** of Pointed.of`.",
    "kind": "def",
    "type": "Pointed"
  },
  {
    "name": "vector3.nil",
    "statement": "def vector3.nil {α : Type u_1} : vector3 α 0",
    "theorem": "{α : Type u_1} : vector3 α 0",
    "args": "{α : Type u_1}",
    "doc_string": "The empty vector",
    "kind": "def",
    "type": "vector3 α 0"
  },
  {
    "name": "list.take_list",
    "statement": "def list.take_list {α : Type u_1} : list α → list ℕ → list (list α) × list α",
    "theorem": "{α : Type u_1} : list α → list ℕ → list (list α) × list α",
    "args": "{α : Type u_1}",
    "doc_string": "`take_list as ns` extracts successive sublists from `as`. For `ns = n₁ ... nₘ`, it first takes the `n₁` initial elements from `as`, then the next `n₂` ones, etc. It returns the sublists of `as` -- one for each `nᵢ` -- and the remaining elements of `as`. If `as` does not have at least as many elements as the sum of the `nᵢ`, the corresponding sublists will have less than `nᵢ` elements.  ```lean take_list ['a', 'b', 'c', 'd', 'e'] [2, 1, 1] = ([['a', 'b'], ['c'], ['d']], ['e']) take_list ['a', 'b'] [3, 1] = ([['a', 'b'], []], []) ```",
    "kind": "def",
    "type": "list α → list ℕ → list (list α) × list α"
  },
  {
    "name": "subgroup.right_transversals",
    "statement": "def subgroup.right_transversals {G : Type u_1} [group G] (S : set G) : set (set G)",
    "theorem": "{G : Type u_1} [group G] (S : set G) : set (set G)",
    "args": "{G : Type u_1} [group G] (S : set G)",
    "doc_string": "The set of right-complements of `S : set G`",
    "kind": "def",
    "type": "set (set G)"
  },
  {
    "name": "category_theory.limits.limit_bicone",
    "statement": "structure category_theory.limits.limit_bicone {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) : Type (max u v)",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) : Type (max u v)",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C)",
    "doc_string": "A bicone over `F : J → C`, which is both a limit cone and a colimit cocone.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "lattice_hom_class",
    "statement": "structure lattice_hom_class (F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [lattice α] [lattice β] : Type (max u_7 u_8 u_9)",
    "theorem": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [lattice α] [lattice β] : Type (max u_7 u_8 u_9)",
    "args": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [lattice α] [lattice β]",
    "doc_string": " `lattice_hom_class F α β` states that `F` is a type of lattice morphisms.  You should extend this class when you extend `lattice_hom`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8 u_9)"
  },
  {
    "name": "lint_verbosity",
    "statement": "inductive lint_verbosity  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Verbosity for the linter output. * `low`: only print failing checks, print nothing on success. * `medium`: only print failing checks, print confirmation on success. * `high`: print output of every check.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "is_algebraic",
    "statement": "def is_algebraic (R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop",
    "theorem": "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop",
    "args": "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A)",
    "doc_string": " An element of an R-algebra is algebraic over R if it is a root of a nonzero polynomial with coefficients in R.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_subring",
    "statement": "structure is_subring {R : Type u} [ring R] (S : set R) : Prop",
    "theorem": "{R : Type u} [ring R] (S : set R) : Prop",
    "args": "{R : Type u} [ring R] (S : set R)",
    "doc_string": " `S` is a subring: a set containing 1 and closed under multiplication, addition and additive inverse.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "unit_interval.path01",
    "statement": "def unit_interval.path01  : path 0 1",
    "theorem": " : path 0 1",
    "args": "",
    "doc_string": "The path 0 ⟶ 1 in I",
    "kind": "def",
    "type": "path 0 1"
  },
  {
    "name": "subsingleton_of_forall_eq",
    "statement": "theorem subsingleton_of_forall_eq {α : Sort u_1} (x : α) (h : ∀ (y : α), y = x) : subsingleton α",
    "theorem": "{α : Sort u_1} (x : α) (h : ∀ (y : α), y = x) : subsingleton α",
    "args": "{α : Sort u_1} (x : α) (h : ∀ (y : α), y = x)",
    "doc_string": "If all points are equal to a given point `x`, then `α` is a subsingleton.",
    "kind": "theorem",
    "type": "subsingleton α"
  },
  {
    "name": "subgroup.relindex",
    "statement": "def subgroup.relindex {G : Type u_1} [group G] (H K : subgroup G) : ℕ",
    "theorem": "{G : Type u_1} [group G] (H K : subgroup G) : ℕ",
    "args": "{G : Type u_1} [group G] (H K : subgroup G)",
    "doc_string": "The relative index of a subgroup as a natural number,  and returns 0 if the relative index is infinite.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "absolute_value.abs",
    "statement": "def absolute_value.abs {S : Type u_2} [linear_ordered_ring S] : absolute_value S S",
    "theorem": "{S : Type u_2} [linear_ordered_ring S] : absolute_value S S",
    "args": "{S : Type u_2} [linear_ordered_ring S]",
    "doc_string": "`absolute_value.abs` is `abs` as a bundled `absolute_value`.",
    "kind": "def",
    "type": "absolute_value S S"
  },
  {
    "name": "intermediate_field.inv_mem",
    "statement": "theorem intermediate_field.inv_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ∈ S → x⁻¹ ∈ S",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ∈ S → x⁻¹ ∈ S",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L}",
    "doc_string": "An intermediate field is closed under inverses.",
    "kind": "theorem",
    "type": "x ∈ S → x⁻¹ ∈ S"
  },
  {
    "name": "one_lt_mul_of_lt_of_le'",
    "statement": "theorem one_lt_mul_of_lt_of_le' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b)",
    "doc_string": "**Alias** of left.one_lt_mul_of_lt_of_le`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "has_trivial_star",
    "statement": "structure has_trivial_star (R : Type u) [has_star R] : Prop",
    "theorem": "(R : Type u) [has_star R] : Prop",
    "args": "(R : Type u) [has_star R]",
    "doc_string": "Typeclass for a trivial star operation. This is mostly meant for `ℝ`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "polynomial.remove_factor",
    "statement": "def polynomial.remove_factor {K : Type v} [field K] (f : polynomial K) : polynomial (adjoin_root f.factor)",
    "theorem": "{K : Type v} [field K] (f : polynomial K) : polynomial (adjoin_root f.factor)",
    "args": "{K : Type v} [field K] (f : polynomial K)",
    "doc_string": "Divide a polynomial f by X - C r where r is a root of f in a bigger field extension.",
    "kind": "def",
    "type": "polynomial (adjoin_root f.factor)"
  },
  {
    "name": "add_group",
    "statement": "structure add_group (A : Type u) : Type u",
    "theorem": "(A : Type u) : Type u",
    "args": "(A : Type u)",
    "doc_string": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.  There is also a binary operation `-` such that `a - b = a + -b`, with a default so that `a - b = a + -b` holds by definition.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "linear_ordered_ring",
    "statement": "structure linear_ordered_ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A `linear_ordered_ring α` is a ring `α` with a linear order such that addition is monotone and multiplication by a positive number is strictly monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "upper_half_plane",
    "statement": "def upper_half_plane  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The open upper half plane",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "prime_spectrum.as_ideal",
    "statement": "def prime_spectrum.as_ideal {R : Type u} [comm_ring R] (x : prime_spectrum R) : ideal R",
    "theorem": "{R : Type u} [comm_ring R] (x : prime_spectrum R) : ideal R",
    "args": "{R : Type u} [comm_ring R] (x : prime_spectrum R)",
    "doc_string": " A method to view a point in the prime spectrum of a commutative ring as an ideal of that ring.",
    "kind": "def",
    "type": "ideal R"
  },
  {
    "name": "sum.is_left",
    "statement": "def sum.is_left {α : Type u} {β : Type v} : α ⊕ β → bool",
    "theorem": "{α : Type u} {β : Type v} : α ⊕ β → bool",
    "args": "{α : Type u} {β : Type v}",
    "doc_string": "Check if a sum is `inl`.",
    "kind": "def",
    "type": "α ⊕ β → bool"
  },
  {
    "name": "left.add_neg",
    "statement": "theorem left.add_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "num.of_znum",
    "statement": "def num.of_znum  : znum → num",
    "theorem": " : znum → num",
    "args": "",
    "doc_string": "Converts a `znum` to an `option num`, where `of_znum p = 0` if `p < 0`.",
    "kind": "def",
    "type": "znum → num"
  },
  {
    "name": "has_monad_lift",
    "statement": "structure has_monad_lift (m : Type u → Type v) (n : Type u → Type w) : Type (max (u+1) v w)",
    "theorem": "(m : Type u → Type v) (n : Type u → Type w) : Type (max (u+1) v w)",
    "args": "(m : Type u → Type v) (n : Type u → Type w)",
    "doc_string": "A function for lifting a computation from an inner monad to an outer monad.    Like [MonadTrans](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html),    but `n` does not have to be a monad transformer.    Alternatively, an implementation of [MonadLayer](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer) without `layerInvmap` (so far).",
    "kind": "structure",
    "type": "Type (max (u+1) v w)"
  },
  {
    "name": "has_norm",
    "statement": "structure has_norm (E : Type u_6) : Type u_6",
    "theorem": "(E : Type u_6) : Type u_6",
    "args": "(E : Type u_6)",
    "doc_string": " Auxiliary class, endowing a type `E` with a function `norm : E → ℝ` with notation `∥x∥`. This class is designed to be extended in more interesting classes specifying the properties of the norm.",
    "kind": "structure",
    "type": "Type u_6"
  },
  {
    "name": "topological_space.positive_compacts",
    "statement": "structure topological_space.positive_compacts (α : Type u_3) [topological_space α] : Type u_3",
    "theorem": "(α : Type u_3) [topological_space α] : Type u_3",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": " The type of compact sets nonempty interior of a topological space. See also `compacts` and `nonempty_compacts`",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "znum.bit1",
    "statement": "def znum.bit1  : znum → znum",
    "theorem": " : znum → znum",
    "args": "",
    "doc_string": "`bit1 x` appends a `1` to the end of `x`, mapping `x` to `2 * x + 1`.",
    "kind": "def",
    "type": "znum → znum"
  },
  {
    "name": "name.deinternalize_field",
    "statement": "def name.deinternalize_field  : name → name",
    "theorem": " : name → name",
    "args": "",
    "doc_string": " If `nm` is a simple name (having only one string component) starting with `_`, then `deinternalize_field nm` removes the underscore. Otherwise, it does nothing.",
    "kind": "def",
    "type": "name → name"
  },
  {
    "name": "wseq.compute",
    "statement": "def wseq.compute {α : Type u} (s : wseq α) : wseq α",
    "theorem": "{α : Type u} (s : wseq α) : wseq α",
    "args": "{α : Type u} (s : wseq α)",
    "doc_string": "Calculate one step of computation",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "topological_space.closeds",
    "statement": "structure topological_space.closeds (α : Type u_3) [topological_space α] : Type u_3",
    "theorem": "(α : Type u_3) [topological_space α] : Type u_3",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": "The type of closed subsets of a topological space.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "fin",
    "statement": "def fin (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": "`fin n` is the subtype of `ℕ` consisting of natural numbers strictly smaller than `n`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "has_to_string",
    "statement": "structure has_to_string (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " Convert the object into a string for tracing/display purposes. Similar to Haskell's `show`. See also `has_repr`, which is used to output a string which is a valid lean code. See also `has_to_format` and `has_to_tactic_format`, `format` has additional support for colours and pretty printing multilines.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "nnreal.tendsto_sum_nat_add",
    "statement": "theorem nnreal.tendsto_sum_nat_add (f : ℕ → nnreal) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)",
    "theorem": "(f : ℕ → nnreal) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)",
    "args": "(f : ℕ → nnreal)",
    "doc_string": " For `f : ℕ → ℝ≥0`, then `∑' k, f (k + i)` tends to zero. This does not require a summability assumption on `f`, as otherwise all sums are zero.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)"
  },
  {
    "name": "functor.comp",
    "statement": "def functor.comp (F : Type u → Type w) (G : Type v → Type u) (α : Type v) : Type w",
    "theorem": "(F : Type u → Type w) (G : Type v → Type u) (α : Type v) : Type w",
    "args": "(F : Type u → Type w) (G : Type v → Type u) (α : Type v)",
    "doc_string": "`functor.comp` is a wrapper around `function.comp` for types.    It prevents Lean's type class resolution mechanism from trying    a `functor (comp F id)` when `functor F` would do.",
    "kind": "def",
    "type": "Type w"
  },
  {
    "name": "ring_topology",
    "statement": "structure ring_topology (α : Type u) [ring α] : Type u",
    "theorem": "(α : Type u) [ring α] : Type u",
    "args": "(α : Type u) [ring α]",
    "doc_string": " A ring topology on a ring `α` is a topology for which addition, negation and multiplication are continuous.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "well_founded",
    "statement": "structure well_founded {α : Sort u} (r : α → α → Prop) : Prop",
    "theorem": "{α : Sort u} (r : α → α → Prop) : Prop",
    "args": "{α : Sort u} (r : α → α → Prop)",
    "doc_string": " A relation `r : α → α → Prop` is well-founded when `∀ x, (∀ y, r y x → P y → P x) → P x` for all predicates `P`. Once you know that a relation is well_founded, you can use it to define fixpoint functions on `α`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "order_top",
    "statement": "structure order_top (α : Type u) [has_le α] : Type u",
    "theorem": "(α : Type u) [has_le α] : Type u",
    "args": "(α : Type u) [has_le α]",
    "doc_string": " An order is an `order_top` if it has a greatest element. We state this using a data mixin, holding the value of `⊤` and the greatest element constraint.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "rand_g",
    "statement": "def rand_g (g : Type) (α : Type u) : Type u",
    "theorem": "(g : Type) (α : Type u) : Type u",
    "args": "(g : Type) (α : Type u)",
    "doc_string": "A monad to generate random objects using the generator type `g`",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "is_add_left_regular_of_left_cancel_add_semigroup",
    "statement": "theorem is_add_left_regular_of_left_cancel_add_semigroup {R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g",
    "theorem": "{R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g",
    "args": "{R : Type u_1} [add_left_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of an add left cancel semigroup are add-left-regular.",
    "kind": "theorem",
    "type": "is_add_left_regular g"
  },
  {
    "name": "subsemigroup.closure",
    "statement": "def subsemigroup.closure {M : Type u_1} [has_mul M] (s : set M) : subsemigroup M",
    "theorem": "{M : Type u_1} [has_mul M] (s : set M) : subsemigroup M",
    "args": "{M : Type u_1} [has_mul M] (s : set M)",
    "doc_string": "The `subsemigroup` generated by a set.",
    "kind": "def",
    "type": "subsemigroup M"
  },
  {
    "name": "list.map_with_prefix_suffix",
    "statement": "def list.map_with_prefix_suffix {α : Type u_1} {β : Type u_2} (f : list α → α → list α → β) (l : list α) : list β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : list α → α → list α → β) (l : list α) : list β",
    "args": "{α : Type u_1} {β : Type u_2} (f : list α → α → list α → β) (l : list α)",
    "doc_string": "`list.map_with_prefix_suffix f l` maps `f` across a list `l`. For each `a ∈ l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f pref a suff`.  Example: if `f : list ℕ → ℕ → list ℕ → β`, `list.map_with_prefix_suffix f [1, 2, 3]` will produce the list `[f [] 1 [2, 3], f [1] 2 [3], f [1, 2] 3 []]`.",
    "kind": "def",
    "type": "list β"
  },
  {
    "name": "Set.to_set",
    "statement": "def Set.to_set (u : Set) : set Set",
    "theorem": "(u : Set) : set Set",
    "args": "(u : Set)",
    "doc_string": "Convert a ZFC set into a `set` of ZFC sets",
    "kind": "def",
    "type": "set Set"
  },
  {
    "name": "Top.sheaf_to_Top",
    "statement": "def Top.sheaf_to_Top {X : Top} (T : Top) : Top.sheaf (Type v) X",
    "theorem": "{X : Top} (T : Top) : Top.sheaf (Type v) X",
    "args": "{X : Top} (T : Top)",
    "doc_string": "The sheaf of continuous functions on `X` with values in a space `T`.",
    "kind": "def",
    "type": "Top.sheaf (Type v) X"
  },
  {
    "name": "category_theory.right_rigid_category",
    "statement": "structure category_theory.right_rigid_category (C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "A right rigid monoidal category is one in which every object has a right dual.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "znum.cmp",
    "statement": "def znum.cmp  : znum → znum → ordering",
    "theorem": " : znum → znum → ordering",
    "args": "",
    "doc_string": "Ordering on `znum`s.",
    "kind": "def",
    "type": "znum → znum → ordering"
  },
  {
    "name": "stream.const",
    "statement": "def stream.const {α : Type u} (a : α) : stream α",
    "theorem": "{α : Type u} (a : α) : stream α",
    "args": "{α : Type u} (a : α)",
    "doc_string": "The constant stream: `stream.nth n (stream.const a) = a`.",
    "kind": "def",
    "type": "stream α"
  },
  {
    "name": "turing.blank_rel.setoid",
    "statement": "def turing.blank_rel.setoid (Γ : Type u_1) [inhabited Γ] : setoid (list Γ)",
    "theorem": "(Γ : Type u_1) [inhabited Γ] : setoid (list Γ)",
    "args": "(Γ : Type u_1) [inhabited Γ]",
    "doc_string": "Construct a setoid instance for `blank_rel`.",
    "kind": "def",
    "type": "setoid (list Γ)"
  },
  {
    "name": "trunc_of_nonempty_fintype",
    "statement": "def trunc_of_nonempty_fintype (α : Type u_1) [nonempty α] [fintype α] : trunc α",
    "theorem": "(α : Type u_1) [nonempty α] [fintype α] : trunc α",
    "args": "(α : Type u_1) [nonempty α] [fintype α]",
    "doc_string": "A `nonempty` `fintype` constructively contains an element.",
    "kind": "def",
    "type": "trunc α"
  },
  {
    "name": "list.choose",
    "statement": "def list.choose {α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) (hp : ∃ (a : α), a ∈ l ∧ p a) : α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) (hp : ∃ (a : α), a ∈ l ∧ p a) : α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) (hp : ∃ (a : α), a ∈ l ∧ p a)",
    "doc_string": " Given a decidable predicate `p` and a proof of existence of `a ∈ l` such that `p a`, choose the first element with this property. This version returns `a : α`, and properties are given by `choose_mem` and `choose_property`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "category_theory.abelian.pseudoelement.setoid",
    "statement": "def category_theory.abelian.pseudoelement.setoid {C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : setoid (category_theory.over P)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : setoid (category_theory.over P)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C)",
    "doc_string": "The arrows with codomain `P` equipped with the equivalence relation of being pseudo-equal.",
    "kind": "def",
    "type": "setoid (category_theory.over P)"
  },
  {
    "name": "linarith.linarith_monad",
    "statement": "def linarith.linarith_monad  : Type → Type",
    "theorem": " : Type → Type",
    "args": "",
    "doc_string": "The linarith monad extends an exceptional monad with a `linarith_structure` state. An exception produces a contradictory `pcomp`.",
    "kind": "def",
    "type": "Type → Type"
  },
  {
    "name": "hash_map.fold",
    "statement": "def hash_map.fold {α : Type u} {β : α → Type v} [decidable_eq α] {δ : Type w} (m : hash_map α β) (d : δ) (f : δ → Π (a : α), β a → δ) : δ",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] {δ : Type w} (m : hash_map α β) (d : δ) (f : δ → Π (a : α), β a → δ) : δ",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] {δ : Type w} (m : hash_map α β) (d : δ) (f : δ → Π (a : α), β a → δ)",
    "doc_string": "Fold a function over the key-value pairs in the map",
    "kind": "def",
    "type": "δ"
  },
  {
    "name": "set.interval_subset_interval_union_interval",
    "statement": "theorem set.interval_subset_interval_union_interval {α : Type u} [linear_order α] {a b c : α} : set.interval a c ⊆ set.interval a b ∪ set.interval b c",
    "theorem": "{α : Type u} [linear_order α] {a b c : α} : set.interval a c ⊆ set.interval a b ∪ set.interval b c",
    "args": "{α : Type u} [linear_order α] {a b c : α}",
    "doc_string": "A sort of triangle inequality.",
    "kind": "theorem",
    "type": "set.interval a c ⊆ set.interval a b ∪ set.interval b c"
  },
  {
    "name": "add_neg",
    "statement": "theorem add_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "**Alias** of `left.add_neg`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "fintype.is_prime_pow_card_of_field",
    "statement": "theorem fintype.is_prime_pow_card_of_field {α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α)",
    "theorem": "{α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α)",
    "args": "{α : Type u_1} [fintype α] [field α]",
    "doc_string": "A finite field has prime power cardinality.",
    "kind": "theorem",
    "type": "is_prime_pow (fintype.card α)"
  },
  {
    "name": "pSet.empty",
    "statement": "def pSet.empty  : pSet",
    "theorem": " : pSet",
    "args": "",
    "doc_string": "The empty pre-set",
    "kind": "def",
    "type": "pSet"
  },
  {
    "name": "nat.digits_aux_0",
    "statement": "def nat.digits_aux_0  : ℕ → list ℕ",
    "theorem": " : ℕ → list ℕ",
    "args": "",
    "doc_string": "(Impl.) An auxiliary definition for `digits`, to help get the desired definitional unfolding.",
    "kind": "def",
    "type": "ℕ → list ℕ"
  },
  {
    "name": "filter.subtraction_comm_monoid",
    "statement": "def filter.subtraction_comm_monoid {α : Type u_2} [subtraction_comm_monoid α] : subtraction_comm_monoid (filter α)",
    "theorem": "{α : Type u_2} [subtraction_comm_monoid α] : subtraction_comm_monoid (filter α)",
    "args": "{α : Type u_2} [subtraction_comm_monoid α]",
    "doc_string": "`filter α` is a commutative subtraction monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "subtraction_comm_monoid (filter α)"
  },
  {
    "name": "many_one_degree",
    "statement": "def many_one_degree  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A many-one degree is an equivalence class of sets up to many-one equivalence.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "group.fg_iff_monoid.fg",
    "statement": "theorem group.fg_iff_monoid.fg {G : Type u_3} [group G] : group.fg G ↔ monoid.fg G",
    "theorem": "{G : Type u_3} [group G] : group.fg G ↔ monoid.fg G",
    "args": "{G : Type u_3} [group G]",
    "doc_string": "A group is finitely generated if and only if it is finitely generated as a monoid.",
    "kind": "theorem",
    "type": "group.fg G ↔ monoid.fg G"
  },
  {
    "name": "submodule.snd",
    "statement": "def submodule.snd (R : Type u) (M : Type v) (M₂ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] : submodule R (M × M₂)",
    "theorem": "(R : Type u) (M : Type v) (M₂ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] : submodule R (M × M₂)",
    "args": "(R : Type u) (M : Type v) (M₂ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂]",
    "doc_string": "`N` as a submodule of `M × N`.",
    "kind": "def",
    "type": "submodule R (M × M₂)"
  },
  {
    "name": "name",
    "statement": "inductive name  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Reflect a C++ name object. The VM replaces it with the C++ implementation.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "power_basis",
    "statement": "structure power_basis (R : Type u_8) (S : Type u_9) [comm_ring R] [ring S] [algebra R S] : Type (max u_8 u_9)",
    "theorem": "(R : Type u_8) (S : Type u_9) [comm_ring R] [ring S] [algebra R S] : Type (max u_8 u_9)",
    "args": "(R : Type u_8) (S : Type u_9) [comm_ring R] [ring S] [algebra R S]",
    "doc_string": " `pb : power_basis R S` states that `1, pb.gen, ..., pb.gen ^ (pb.dim - 1)` is a basis for the `R`-algebra `S` (viewed as `R`-module).  This is a structure, not a class, since the same algebra can have many power bases. For the common case where `S` is defined by adjoining an integral element to `R`, the canonical power basis is given by `{algebra,intermediate_field}.adjoin.power_basis`.",
    "kind": "structure",
    "type": "Type (max u_8 u_9)"
  },
  {
    "name": "tensor_product.eqv",
    "statement": "inductive tensor_product.eqv (R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : free_add_monoid (M × N) → free_add_monoid (M × N) → Prop",
    "theorem": "(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N] : free_add_monoid (M × N) → free_add_monoid (M × N) → Prop",
    "args": "(R : Type u_1) [comm_semiring R] (M : Type u_4) (N : Type u_5) [add_comm_monoid M] [add_comm_monoid N] [module R M] [module R N]",
    "doc_string": " The relation on `free_add_monoid (M × N)` that generates a congruence whose quotient is the tensor product.",
    "kind": "inductive",
    "type": "free_add_monoid (M × N) → free_add_monoid (M × N) → Prop"
  },
  {
    "name": "is_atom",
    "statement": "def is_atom {α : Type u_1} [preorder α] [order_bot α] (a : α) : Prop",
    "theorem": "{α : Type u_1} [preorder α] [order_bot α] (a : α) : Prop",
    "args": "{α : Type u_1} [preorder α] [order_bot α] (a : α)",
    "doc_string": "An atom of an `order_bot` is an element with no other element between it and `⊥`,  which is not `⊥`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "tactic.rewrite_search.graph",
    "statement": "structure tactic.rewrite_search.graph  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The graph represents two trees, one descending from each of the left and right sides of our initial equation. * `conf` and `rules` determine what rewrites are used to generate new graph vertices.   Here, the format of a rewrite rule is an expression for rewriting, plus a flag for the   direction to apply it in. * `vertices` maps vertex.id to vertex. * `vmap` maps vertex.pp to a list of vertex.id with that pp, so we can quickly find collisions. * `solving_edge` represents a solution that will prove our target equation.   It is an edge that would connect the two trees, so `solving_edge.fr` and `solving_edge.to`   are vertices in different trees. * `lhs` and `rhs` are the left and right expressions we are trying to prove are equal.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "wseq.nil",
    "statement": "def wseq.nil {α : Type u} : wseq α",
    "theorem": "{α : Type u} : wseq α",
    "args": "{α : Type u}",
    "doc_string": "The empty weak sequence",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "simple_continued_fraction",
    "statement": "def simple_continued_fraction (α : Type u_1) [has_one α] : Type u_1",
    "theorem": "(α : Type u_1) [has_one α] : Type u_1",
    "args": "(α : Type u_1) [has_one α]",
    "doc_string": "A *simple continued fraction* (scf) is a generalized continued fraction (gcf) whose partial numerators are equal to one.                                  1                 h + ---------------------------                                   1                       b₀ + --------------------                                     1                             b₁ + --------------                                         1                                   b₂ + --------                                       b₃ + ...  For convenience, one often writes `[h; b₀, b₁, b₂,...]`. It is encoded as the subtype of gcfs that satisfy `generalized_continued_fraction.is_simple_continued_fraction`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "is_alg_closure",
    "statement": "structure is_alg_closure (R : Type u) (K : Type v) [comm_ring R] [field K] [algebra R K] [no_zero_smul_divisors R K] : Prop",
    "theorem": "(R : Type u) (K : Type v) [comm_ring R] [field K] [algebra R K] [no_zero_smul_divisors R K] : Prop",
    "args": "(R : Type u) (K : Type v) [comm_ring R] [field K] [algebra R K] [no_zero_smul_divisors R K]",
    "doc_string": "Typeclass for an extension being an algebraic closure.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "neg_of_neg_pos",
    "statement": "theorem neg_of_neg_pos {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a → a < 0",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a → a < 0",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.one_lt_inv_iff`.",
    "kind": "theorem",
    "type": "0 < -a → a < 0"
  },
  {
    "name": "list.mmap_with_index",
    "statement": "def list.mmap_with_index {m : Type v → Type w} [applicative m] {α : Type u_1} {β : Type v} (f : ℕ → α → m β) (as : list α) : m (list β)",
    "theorem": "{m : Type v → Type w} [applicative m] {α : Type u_1} {β : Type v} (f : ℕ → α → m β) (as : list α) : m (list β)",
    "args": "{m : Type v → Type w} [applicative m] {α : Type u_1} {β : Type v} (f : ℕ → α → m β) (as : list α)",
    "doc_string": "Applicative variant of `map_with_index`.",
    "kind": "def",
    "type": "m (list β)"
  },
  {
    "name": "bitvec.to_int",
    "statement": "def bitvec.to_int {n : ℕ} : bitvec n → ℤ",
    "theorem": "{n : ℕ} : bitvec n → ℤ",
    "args": "{n : ℕ}",
    "doc_string": "Return the integer encoded by the input bitvector",
    "kind": "def",
    "type": "bitvec n → ℤ"
  },
  {
    "name": "omega.update",
    "statement": "def omega.update {α : Type} (m : ℕ) (a : α) (v : ℕ → α) : ℕ → α",
    "theorem": "{α : Type} (m : ℕ) (a : α) (v : ℕ → α) : ℕ → α",
    "args": "{α : Type} (m : ℕ) (a : α) (v : ℕ → α)",
    "doc_string": "Update variable assignment for a specific variable    and leave everything else unchanged",
    "kind": "def",
    "type": "ℕ → α"
  },
  {
    "name": "nat.find",
    "statement": "def nat.find {p : ℕ → Prop} [decidable_pred p] (H : ∃ (n : ℕ), p n) : ℕ",
    "theorem": "{p : ℕ → Prop} [decidable_pred p] (H : ∃ (n : ℕ), p n) : ℕ",
    "args": "{p : ℕ → Prop} [decidable_pred p] (H : ∃ (n : ℕ), p n)",
    "doc_string": "If `p` is a (decidable) predicate on `ℕ` and `hp : ∃ (n : ℕ), p n` is a proof that there exists some natural number satisfying `p`, then `nat.find hp` is the smallest natural number satisfying `p`. Note that `nat.find` is protected, meaning that you can't just write `find`, even if the `nat` namespace is open.  The API for `nat.find` is:  * `nat.find_spec` is the proof that `nat.find hp` satisfies `p`. * `nat.find_min` is the proof that if `m < nat.find hp` then `m` does not satisfy `p`. * `nat.find_min'` is the proof that if `m` does satisfy `p` then `nat.find hp ≤ m`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "is_topological_fiber_bundle_snd",
    "statement": "theorem is_topological_fiber_bundle_snd {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd",
    "theorem": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd",
    "args": "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F]",
    "doc_string": "The second projection in a product is a topological fiber bundle.",
    "kind": "theorem",
    "type": "is_topological_fiber_bundle F prod.snd"
  },
  {
    "name": "std_simplex",
    "statement": "def std_simplex (𝕜 : Type u_1) (ι : Type u_5) [ordered_semiring 𝕜] [fintype ι] : set (ι → 𝕜)",
    "theorem": "(𝕜 : Type u_1) (ι : Type u_5) [ordered_semiring 𝕜] [fintype ι] : set (ι → 𝕜)",
    "args": "(𝕜 : Type u_1) (ι : Type u_5) [ordered_semiring 𝕜] [fintype ι]",
    "doc_string": " The standard simplex in the space of functions `ι → 𝕜` is the set of vectors with non-negative coordinates with total sum `1`. This is the free object in the category of convex spaces.",
    "kind": "def",
    "type": "set (ι → 𝕜)"
  },
  {
    "name": "set.has_zero",
    "statement": "def set.has_zero {α : Type u_2} [has_zero α] : has_zero (set α)",
    "theorem": "{α : Type u_2} [has_zero α] : has_zero (set α)",
    "args": "{α : Type u_2} [has_zero α]",
    "doc_string": "The set `0 : set α` is defined as `{0}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_zero (set α)"
  },
  {
    "name": "tendsto_rpow_div",
    "statement": "theorem tendsto_rpow_div  : filter.tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_top (nhds 1)",
    "theorem": " : filter.tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_top (nhds 1)",
    "args": "",
    "doc_string": "The function `x ^ (1 / x)` tends to `1` at `+∞`.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_top (nhds 1)"
  },
  {
    "name": "turing.partrec_to_TM2.cont_stack",
    "statement": "def turing.partrec_to_TM2.cont_stack  : turing.to_partrec.cont → list (list ℕ)",
    "theorem": " : turing.to_partrec.cont → list (list ℕ)",
    "args": "",
    "doc_string": " The data part of a continuation is a list of lists, which is encoded on the `stack` stack using `tr_llist`.",
    "kind": "def",
    "type": "turing.to_partrec.cont → list (list ℕ)"
  },
  {
    "name": "add_group_filter_basis",
    "statement": "structure add_group_filter_basis (A : Type u) [add_group A] : Type u",
    "theorem": "(A : Type u) [add_group A] : Type u",
    "args": "(A : Type u) [add_group A]",
    "doc_string": "A `add_group_filter_basis` on an additive group is a `filter_basis` satisfying some additional  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are a  `add_group_filter_basis`. Conversely given a `add_group_filter_basis` one can define a topology  compatible with the group structure on `G`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "matrix.charpoly",
    "statement": "def matrix.charpoly {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : polynomial R",
    "theorem": "{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : polynomial R",
    "args": "{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R)",
    "doc_string": "The characteristic polynomial of a matrix `M` is given by $\\det (t I - M)$.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "is_symm",
    "statement": "structure is_symm (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": "`is_symm X r` means the binary relation `r` on `X` is symmetric.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "parser.eps",
    "statement": "def parser.eps  : parser unit",
    "theorem": " : parser unit",
    "args": "",
    "doc_string": "Matches the empty word.",
    "kind": "def",
    "type": "parser unit"
  },
  {
    "name": "strict_convex_iff_convex",
    "statement": "theorem strict_convex_iff_convex {𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜} : strict_convex 𝕜 s ↔ convex 𝕜 s",
    "theorem": "{𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜} : strict_convex 𝕜 s ↔ convex 𝕜 s",
    "args": "{𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜}",
    "doc_string": "A set in a linear ordered field is strictly convex if and only if it is convex.",
    "kind": "theorem",
    "type": "strict_convex 𝕜 s ↔ convex 𝕜 s"
  },
  {
    "name": "free_semigroup",
    "statement": "def free_semigroup (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " Free semigroup over a given alphabet. (Note: In this definition, the free semigroup does not contain the empty word.)",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "category_theory.has_finite_products_of_has_binary_and_terminal",
    "statement": "theorem category_theory.has_finite_products_of_has_binary_and_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C]",
    "doc_string": "If `C` has a terminal object and binary products, then it has finite products.",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_products C"
  },
  {
    "name": "AddCommMon.has_limits_of_size",
    "statement": "def AddCommMon.has_limits_of_size  : category_theory.limits.has_limits_of_size AddCommMon",
    "theorem": " : category_theory.limits.has_limits_of_size AddCommMon",
    "args": "",
    "doc_string": "The category of commutative monoids has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size AddCommMon"
  },
  {
    "name": "localization.neg",
    "statement": "def localization.neg {R : Type u_1} [comm_ring R] {M : submonoid R} (z : localization M) : localization M",
    "theorem": "{R : Type u_1} [comm_ring R] {M : submonoid R} (z : localization M) : localization M",
    "args": "{R : Type u_1} [comm_ring R] {M : submonoid R} (z : localization M)",
    "doc_string": "Negation in a ring localization is defined as `-⟨a, b⟩ = ⟨-a, b⟩`.",
    "kind": "def",
    "type": "localization M"
  },
  {
    "name": "nat.of_digits",
    "statement": "def nat.of_digits {α : Type u_1} [semiring α] (b : α) : list ℕ → α",
    "theorem": "{α : Type u_1} [semiring α] (b : α) : list ℕ → α",
    "args": "{α : Type u_1} [semiring α] (b : α)",
    "doc_string": "`of_digits b L` takes a list `L` of natural numbers, and interprets them as a number in semiring, as the little-endian digits in base `b`.",
    "kind": "def",
    "type": "list ℕ → α"
  },
  {
    "name": "comm_monoid.torsion",
    "statement": "def comm_monoid.torsion (G : Type u_1) [comm_monoid G] : submonoid G",
    "theorem": "(G : Type u_1) [comm_monoid G] : submonoid G",
    "args": "(G : Type u_1) [comm_monoid G]",
    "doc_string": "The torsion submonoid of a commutative monoid.  (Note that by `monoid.is_torsion.group` torsion monoids are truthfully groups.)",
    "kind": "def",
    "type": "submonoid G"
  },
  {
    "name": "linarith.certificate_oracle",
    "statement": "def linarith.certificate_oracle  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A `certificate_oracle` is a function `produce_certificate : list comp → ℕ → tactic (rb_map ℕ ℕ)`. `produce_certificate hyps max_var` tries to derive a contradiction from the comparisons in `hyps` by eliminating all variables ≤ `max_var`. If successful, it returns a map `coeff : ℕ → ℕ` as a certificate. This map represents that we can find a contradiction by taking the sum  `∑ (coeff i) * hyps[i]`.  The default `certificate_oracle` used by `linarith` is `linarith.fourier_motzkin.produce_certificate`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "ordinal.principal",
    "statement": "def ordinal.principal (op : ordinal → ordinal → ordinal) (o : ordinal) : Prop",
    "theorem": "(op : ordinal → ordinal → ordinal) (o : ordinal) : Prop",
    "args": "(op : ordinal → ordinal → ordinal) (o : ordinal)",
    "doc_string": " An ordinal `o` is said to be principal or indecomposable under an operation when the set of ordinals less than it is closed under that operation. In standard mathematical usage, this term is almost exclusively used for additive and multiplicative principal ordinals.  For simplicity, we break usual convention and regard 0 as principal.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "wseq.tail",
    "statement": "def wseq.tail {α : Type u} (s : wseq α) : wseq α",
    "theorem": "{α : Type u} (s : wseq α) : wseq α",
    "args": "{α : Type u} (s : wseq α)",
    "doc_string": "Get the tail of a weak sequence. This doesn't need a `computation`  wrapper, unlike `head`, because `flatten` allows us to hide this  in the construction of the weak sequence itself.",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "has_le.le.lt_of_not_le",
    "statement": "theorem has_le.le.lt_of_not_le {α : Type u} [preorder α] {a b : α} : a ≤ b → ¬b ≤ a → a < b",
    "theorem": "{α : Type u} [preorder α] {a b : α} : a ≤ b → ¬b ≤ a → a < b",
    "args": "{α : Type u} [preorder α] {a b : α}",
    "doc_string": "**Alias** of lt_of_le_not_le`.",
    "kind": "theorem",
    "type": "a ≤ b → ¬b ≤ a → a < b"
  },
  {
    "name": "measure_theory.simple_func.pos_part",
    "statement": "def measure_theory.simple_func.pos_part {α : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space α] (f : measure_theory.simple_func α E) : measure_theory.simple_func α E",
    "theorem": "{α : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space α] (f : measure_theory.simple_func α E) : measure_theory.simple_func α E",
    "args": "{α : Type u_1} {E : Type u_2} [linear_order E] [has_zero E] [measurable_space α] (f : measure_theory.simple_func α E)",
    "doc_string": "Positive part of a simple function.",
    "kind": "def",
    "type": "measure_theory.simple_func α E"
  },
  {
    "name": "matrix.det_invertible_of_right_inverse",
    "statement": "def matrix.det_invertible_of_right_inverse {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : A.mul B = 1) : invertible A.det",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : A.mul B = 1) : invertible A.det",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A B : matrix n n α) (h : A.mul B = 1)",
    "doc_string": "`A.det` is invertible if `A` has a right inverse.",
    "kind": "def",
    "type": "invertible A.det"
  },
  {
    "name": "add_action.is_minimal",
    "statement": "structure add_action.is_minimal (M : Type u_1) (α : Type u_2) [add_monoid M] [topological_space α] [add_action M α] : Prop",
    "theorem": "(M : Type u_1) (α : Type u_2) [add_monoid M] [topological_space α] [add_action M α] : Prop",
    "args": "(M : Type u_1) (α : Type u_2) [add_monoid M] [topological_space α] [add_action M α]",
    "doc_string": " An action of an additive monoid `M` on a topological space is called *minimal* if the `M`-orbit of every point `x : α` is dense.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "cycle.chain",
    "statement": "def cycle.chain {α : Type u_1} (r : α → α → Prop) (c : cycle α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (c : cycle α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (c : cycle α)",
    "doc_string": " `chain R s` means that `R` holds between adjacent elements of `s`.  `chain R ([a, b, c] : cycle α) ↔ R a b ∧ R b c ∧ R c a`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "continuous_monoid_hom.inr",
    "statement": "def continuous_monoid_hom.inr (A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom B (A × B)",
    "theorem": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom B (A × B)",
    "args": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by inclusion of the second factor.",
    "kind": "def",
    "type": "continuous_monoid_hom B (A × B)"
  },
  {
    "name": "prod.emetric_space_max",
    "statement": "def prod.emetric_space_max {β : Type v} {γ : Type w} [emetric_space γ] [emetric_space β] : emetric_space (γ × β)",
    "theorem": "{β : Type v} {γ : Type w} [emetric_space γ] [emetric_space β] : emetric_space (γ × β)",
    "args": "{β : Type v} {γ : Type w} [emetric_space γ] [emetric_space β]",
    "doc_string": " The product of two emetric spaces, with the max distance, is an extended metric spaces. We make sure that the uniform structure thus constructed is the one corresponding to the product of uniform spaces, to avoid diamond problems.",
    "kind": "def",
    "type": "emetric_space (γ × β)"
  },
  {
    "name": "zero_lt.pos_mul_mono_rev",
    "statement": "def zero_lt.pos_mul_mono_rev (X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop",
    "theorem": "(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop",
    "args": "(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X]",
    "doc_string": "  `zero_lt.pos_mul_mono_rev α` is an abbreviation for `contravariant_class α>0 α (λ x y, x * y) (≤)`, expressing that multiplication by positive elements on the left is reverse monotone.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "equiv.mul_swap_involutive",
    "statement": "theorem equiv.mul_swap_involutive {α : Type u} [decidable_eq α] (i j : α) : function.involutive (λ (_x : equiv.perm α), _x * equiv.swap i j)",
    "theorem": "{α : Type u} [decidable_eq α] (i j : α) : function.involutive (λ (_x : equiv.perm α), _x * equiv.swap i j)",
    "args": "{α : Type u} [decidable_eq α] (i j : α)",
    "doc_string": "A stronger version of `mul_left_injective`",
    "kind": "theorem",
    "type": "function.involutive (λ (_x : equiv.perm α), _x * equiv.swap i j)"
  },
  {
    "name": "pos_num",
    "statement": "inductive pos_num  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of positive binary numbers.      13 = 1101(base 2) = bit1 (bit0 (bit1 one))",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "pseudo_metric.dist_setoid",
    "statement": "def pseudo_metric.dist_setoid (α : Type u) [pseudo_metric_space α] : setoid α",
    "theorem": "(α : Type u) [pseudo_metric_space α] : setoid α",
    "args": "(α : Type u) [pseudo_metric_space α]",
    "doc_string": "The canonical equivalence relation on a pseudometric space.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "tactic_doc_entry",
    "statement": "structure tactic_doc_entry  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The information used to generate a tactic doc entry",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "unit",
    "statement": "def unit  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "An abbreviation for `punit.{0}`, its most common instantiation.    This type should be preferred over `punit` where possible to avoid    unnecessary universe parameters.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "list.alternating_prod",
    "statement": "def list.alternating_prod {G : Type u_1} [has_one G] [has_mul G] [has_inv G] : list G → G",
    "theorem": "{G : Type u_1} [has_one G] [has_mul G] [has_inv G] : list G → G",
    "args": "{G : Type u_1} [has_one G] [has_mul G] [has_inv G]",
    "doc_string": "The alternating product of a list.",
    "kind": "def",
    "type": "list G → G"
  },
  {
    "name": "category_theory.limits.has_binary_biproduct",
    "statement": "structure category_theory.limits.has_binary_biproduct {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C)",
    "doc_string": "`has_binary_biproduct P Q` expresses the mere existence of a bicone which is simultaneously a limit and a colimit of the diagram `pair P Q`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_simple_add_group",
    "statement": "structure is_simple_add_group (A : Type u_2) [add_group A] : Prop",
    "theorem": "(A : Type u_2) [add_group A] : Prop",
    "args": "(A : Type u_2) [add_group A]",
    "doc_string": "An `add_group` is simple when it has exactly two normal `add_subgroup`s.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "many_one_degree.has_le",
    "statement": "def many_one_degree.has_le  : has_le many_one_degree",
    "theorem": " : has_le many_one_degree",
    "args": "",
    "doc_string": "For many-one degrees `d₁` and `d₂`, `d₁ ≤ d₂` if the sets in `d₁` are many-one reducible to the sets in `d₂`.",
    "kind": "def",
    "type": "has_le many_one_degree"
  },
  {
    "name": "filter.tendsto_at_bot_at_bot_of_monotone'",
    "statement": "theorem filter.tendsto_at_bot_at_bot_of_monotone' {ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot",
    "theorem": "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot",
    "args": "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u))",
    "doc_string": " If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded below, then `tendsto u at_bot at_bot`.",
    "kind": "theorem",
    "type": "filter.tendsto u filter.at_bot filter.at_bot"
  },
  {
    "name": "stream.pure",
    "statement": "def stream.pure {α : Type u} (a : α) : stream α",
    "theorem": "{α : Type u} (a : α) : stream α",
    "args": "{α : Type u} (a : α)",
    "doc_string": "A constant stream, same as `stream.const`.",
    "kind": "def",
    "type": "stream α"
  },
  {
    "name": "is_coprime",
    "statement": "def is_coprime {R : Type u} [comm_semiring R] (x y : R) : Prop",
    "theorem": "{R : Type u} [comm_semiring R] (x y : R) : Prop",
    "args": "{R : Type u} [comm_semiring R] (x y : R)",
    "doc_string": " The proposition that `x` and `y` are coprime, defined to be the existence of `a` and `b` such that `a * x + b * y = 1`. Note that elements with no common divisors are not necessarily coprime, e.g., the multivariate polynomials `x₁` and `x₂` are not coprime.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "uv.compress",
    "statement": "def uv.compress {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : α",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : α",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α)",
    "doc_string": " To UV-compress `a`, if it doesn't touch `U` and does contain `V`, we remove `V` and put `U` in. We'll only really use this when `|U| = |V|` and `U ∩ V = ∅`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "is_right_regular_of_non_zero_divisor",
    "statement": "theorem is_right_regular_of_non_zero_divisor {α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0) : is_right_regular k",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0) : is_right_regular k",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0)",
    "doc_string": " Right `mul` by a `k : α` over `[ring α]` is injective, if `k` is not a zero divisor. The typeclass that restricts all terms of `α` to have this property is `no_zero_divisors`.",
    "kind": "theorem",
    "type": "is_right_regular k"
  },
  {
    "name": "filter.has_zero",
    "statement": "def filter.has_zero {α : Type u_2} [has_zero α] : has_zero (filter α)",
    "theorem": "{α : Type u_2} [has_zero α] : has_zero (filter α)",
    "args": "{α : Type u_2} [has_zero α]",
    "doc_string": "`0 : filter α` is defined as the filter of sets containing `0 : α` in locale `pointwise`.",
    "kind": "def",
    "type": "has_zero (filter α)"
  },
  {
    "name": "finset.Iio",
    "statement": "def finset.Iio {α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : finset α",
    "theorem": "{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : finset α",
    "args": "{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α)",
    "doc_string": "The finset of elements `x` such that `x < b`. Basically `set.Iio b` as a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "has_btw.btw.cyclic_right",
    "statement": "theorem has_btw.btw.cyclic_right {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : has_btw.btw c a b",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : has_btw.btw c a b",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c)",
    "doc_string": "**Alias** of btw_cyclic_right`.",
    "kind": "theorem",
    "type": "has_btw.btw c a b"
  },
  {
    "name": "CommSemiRing.has_limits_of_size",
    "statement": "def CommSemiRing.has_limits_of_size  : category_theory.limits.has_limits_of_size CommSemiRing",
    "theorem": " : category_theory.limits.has_limits_of_size CommSemiRing",
    "args": "",
    "doc_string": "The category of rings has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size CommSemiRing"
  },
  {
    "name": "lt_of_tsub_lt_tsub_right",
    "statement": "theorem lt_of_tsub_lt_tsub_right {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] (h : a - c < b - c) : a < b",
    "theorem": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] (h : a - c < b - c) : a < b",
    "args": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] (h : a - c < b - c)",
    "doc_string": "See `lt_of_tsub_lt_tsub_right_of_le` for a weaker statement in a partial order.",
    "kind": "theorem",
    "type": "a < b"
  },
  {
    "name": "fin.cycle_range",
    "statement": "def fin.cycle_range {n : ℕ} (i : fin n) : equiv.perm (fin n)",
    "theorem": "{n : ℕ} (i : fin n) : equiv.perm (fin n)",
    "args": "{n : ℕ} (i : fin n)",
    "doc_string": "`fin.cycle_range i` is the cycle `(0 1 2 ... i)` leaving `(i+1 ... (n-1))` unchanged.",
    "kind": "def",
    "type": "equiv.perm (fin n)"
  },
  {
    "name": "pfunctor.M",
    "statement": "def pfunctor.M (F : pfunctor) : Type u",
    "theorem": "(F : pfunctor) : Type u",
    "args": "(F : pfunctor)",
    "doc_string": "For polynomial functor `F`, `M F` is its final coalgebra",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "simple_graph.reachable_setoid",
    "statement": "def simple_graph.reachable_setoid {V : Type u} (G : simple_graph V) : setoid V",
    "theorem": "{V : Type u} (G : simple_graph V) : setoid V",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": "The equivalence relation on vertices given by `simple_graph.reachable`.",
    "kind": "def",
    "type": "setoid V"
  },
  {
    "name": "algebraic_geometry.SheafedSpace.sheaf",
    "statement": "def algebraic_geometry.SheafedSpace.sheaf {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (X : algebraic_geometry.SheafedSpace C) : Top.sheaf C ↑X",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (X : algebraic_geometry.SheafedSpace C) : Top.sheaf C ↑X",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] (X : algebraic_geometry.SheafedSpace C)",
    "doc_string": "Extract the `sheaf C (X : Top)` from a `SheafedSpace C`.",
    "kind": "def",
    "type": "Top.sheaf C ↑X"
  },
  {
    "name": "exists_open_with_compact_closure",
    "statement": "theorem exists_open_with_compact_closure {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U)",
    "theorem": "{α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U)",
    "args": "{α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α)",
    "doc_string": "In a locally compact T₂ space, every point has an open neighborhood with compact closure",
    "kind": "theorem",
    "type": "∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U)"
  },
  {
    "name": "pSet.arity.equiv",
    "statement": "def pSet.arity.equiv {n : ℕ} : arity pSet n → arity pSet n → Prop",
    "theorem": "{n : ℕ} : arity pSet n → arity pSet n → Prop",
    "args": "{n : ℕ}",
    "doc_string": " Function equivalence is defined so that `f ~ g` iff `∀ x y, x ~ y → f x ~ g y`. This extends to equivalence of `n`-ary functions.",
    "kind": "def",
    "type": "arity pSet n → arity pSet n → Prop"
  },
  {
    "name": "category_theory.is_coseparating",
    "statement": "def category_theory.is_coseparating {C : Type u} [category_theory.category C] (𝒢 : set C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (𝒢 : set C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (𝒢 : set C)",
    "doc_string": "We say that `𝒢` is a coseparating set if the functors `C(-, G)` for `G ∈ 𝒢` are collectively    faithful, i.e., if `f ≫ h = g ≫ h` for all `h` with codomain in `𝒢` implies `f = g`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "group_topology",
    "statement": "structure group_topology (α : Type u) [group α] : Type u",
    "theorem": "(α : Type u) [group α] : Type u",
    "args": "(α : Type u) [group α]",
    "doc_string": " A group topology on a group `α` is a topology for which multiplication and inversion are continuous.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "first_order.language.Theory.model",
    "statement": "structure first_order.language.Theory.model {L : first_order.language} (M : Type w) [L.Structure M] (T : L.Theory) : Prop",
    "theorem": "{L : first_order.language} (M : Type w) [L.Structure M] (T : L.Theory) : Prop",
    "args": "{L : first_order.language} (M : Type w) [L.Structure M] (T : L.Theory)",
    "doc_string": "A model of a theory is a structure in which every sentence is realized as true.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "simple_continued_fraction.has_coe_to_generalized_continued_fraction",
    "statement": "def simple_continued_fraction.has_coe_to_generalized_continued_fraction {α : Type u_1} [has_one α] : has_coe (simple_continued_fraction α) (generalized_continued_fraction α)",
    "theorem": "{α : Type u_1} [has_one α] : has_coe (simple_continued_fraction α) (generalized_continued_fraction α)",
    "args": "{α : Type u_1} [has_one α]",
    "doc_string": "Lift a scf to a gcf using the inclusion map.",
    "kind": "def",
    "type": "has_coe (simple_continued_fraction α) (generalized_continued_fraction α)"
  },
  {
    "name": "generalized_continued_fraction.next_denominator",
    "statement": "def generalized_continued_fraction.next_denominator {K : Type u_2} [division_ring K] (aₙ bₙ ppredB predB : K) : K",
    "theorem": "{K : Type u_2} [division_ring K] (aₙ bₙ ppredB predB : K) : K",
    "args": "{K : Type u_2} [division_ring K] (aₙ bₙ ppredB predB : K)",
    "doc_string": "Returns the next denominator `Bₙ = bₙ₋₁ * Bₙ₋₁ + aₙ₋₁ * Bₙ₋₂``, where `predB` is `Bₙ₋₁` and `ppredB` is `Bₙ₋₂`, `a` is `aₙ₋₁`, and `b` is `bₙ₋₁`.",
    "kind": "def",
    "type": "K"
  },
  {
    "name": "equiv.point_reflection",
    "statement": "def equiv.point_reflection {G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] (x : P) : equiv.perm P",
    "theorem": "{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] (x : P) : equiv.perm P",
    "args": "{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] (x : P)",
    "doc_string": "Point reflection in `x` as a permutation.",
    "kind": "def",
    "type": "equiv.perm P"
  },
  {
    "name": "category_theory.limits.multicospan_index",
    "statement": "structure category_theory.limits.multicospan_index (C : Type u) [category_theory.category C] : Type (max u (v+1))",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u (v+1))",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "This is a structure encapsulating the data necessary to define a `multicospan`.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "real.tendsto_log_at_top",
    "statement": "theorem real.tendsto_log_at_top  : filter.tendsto real.log filter.at_top filter.at_top",
    "theorem": " : filter.tendsto real.log filter.at_top filter.at_top",
    "args": "",
    "doc_string": "The real logarithm function tends to `+∞` at `+∞`.",
    "kind": "theorem",
    "type": "filter.tendsto real.log filter.at_top filter.at_top"
  },
  {
    "name": "plift",
    "statement": "structure plift (α : Sort u) : Type u",
    "theorem": "(α : Sort u) : Type u",
    "args": "(α : Sort u)",
    "doc_string": "Universe lifting operation from Sort to Type",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "is_generic_point",
    "statement": "def is_generic_point {α : Type u_1} [topological_space α] (x : α) (S : set α) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] (x : α) (S : set α) : Prop",
    "args": "{α : Type u_1} [topological_space α] (x : α) (S : set α)",
    "doc_string": "`x` is a generic point of `S` if `S` is the closure of `x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization.to_unique_factorization_monoid",
    "statement": "theorem discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization.to_unique_factorization_monoid {R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R",
    "theorem": "{R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R",
    "args": "{R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R]",
    "doc_string": " An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a unique factorization domain. See `discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization`.",
    "kind": "theorem",
    "type": "unique_factorization_monoid R"
  },
  {
    "name": "ereal.neg",
    "statement": "def ereal.neg  : ereal → ereal",
    "theorem": " : ereal → ereal",
    "args": "",
    "doc_string": "negation on `ereal`",
    "kind": "def",
    "type": "ereal → ereal"
  },
  {
    "name": "multiset.bind",
    "statement": "def multiset.bind {α : Type u_1} {β : Type u_2} (s : multiset α) (f : α → multiset β) : multiset β",
    "theorem": "{α : Type u_1} {β : Type u_2} (s : multiset α) (f : α → multiset β) : multiset β",
    "args": "{α : Type u_1} {β : Type u_2} (s : multiset α) (f : α → multiset β)",
    "doc_string": " `s.bind f` is the monad bind operation, defined as `(s.map f).join`. It is the union of `f a` as `a` ranges over `s`.",
    "kind": "def",
    "type": "multiset β"
  },
  {
    "name": "module",
    "statement": "structure module (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] : Type (max u v)",
    "theorem": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] : Type (max u v)",
    "args": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M]",
    "doc_string": "A module is a generalization of vector spaces to a scalar semiring.  It consists of a scalar semiring `R` and an additive monoid of \"vectors\" `M`,  connected by a \"scalar multiplication\" operation `r • x : M`  (where `r : R` and `x : M`) with some natural associativity and  distributivity axioms similar to those on a ring.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "vector.m_of_fn",
    "statement": "def vector.m_of_fn {m : Type u → Type u_1} [monad m] {α : Type u} {n : ℕ} : (fin n → m α) → m (vector α n)",
    "theorem": "{m : Type u → Type u_1} [monad m] {α : Type u} {n : ℕ} : (fin n → m α) → m (vector α n)",
    "args": "{m : Type u → Type u_1} [monad m] {α : Type u} {n : ℕ}",
    "doc_string": " Monadic analog of `vector.of_fn`. Given a monadic function on `fin n`, return a `vector α n` inside the monad.",
    "kind": "def",
    "type": "(fin n → m α) → m (vector α n)"
  },
  {
    "name": "distrib",
    "statement": "structure distrib (R : Type u_1) : Type u_1",
    "theorem": "(R : Type u_1) : Type u_1",
    "args": "(R : Type u_1)",
    "doc_string": " A typeclass stating that multiplication is left and right distributive over addition.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "snum.sub",
    "statement": "def snum.sub (a b : snum) : snum",
    "theorem": "(a b : snum) : snum",
    "args": "(a b : snum)",
    "doc_string": "Substract two `snum`s.",
    "kind": "def",
    "type": "snum"
  },
  {
    "name": "add_hom.has_zero",
    "statement": "def add_hom.has_zero {M : Type u_3} {N : Type u_4} [has_add M] [add_zero_class N] : has_zero (add_hom M N)",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_add M] [add_zero_class N] : has_zero (add_hom M N)",
    "args": "{M : Type u_3} {N : Type u_4} [has_add M] [add_zero_class N]",
    "doc_string": "`0` is the additive homomorphism sending all elements to `0`.",
    "kind": "def",
    "type": "has_zero (add_hom M N)"
  },
  {
    "name": "finset.not_mem_map_subtype_of_not_property",
    "statement": "theorem finset.not_mem_map_subtype_of_not_property {α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : ¬p a) : a ∉ finset.map (function.embedding.subtype (λ (x : α), p x)) s",
    "theorem": "{α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : ¬p a) : a ∉ finset.map (function.embedding.subtype (λ (x : α), p x)) s",
    "args": "{α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : ¬p a)",
    "doc_string": " If a `finset` of a subtype is converted to the main type with `embedding.subtype`, the result does not contain any value that does not satisfy the property of the subtype.",
    "kind": "theorem",
    "type": "a ∉ finset.map (function.embedding.subtype (λ (x : α), p x)) s"
  },
  {
    "name": "padic_val_nat.div",
    "statement": "theorem padic_val_nat.div {p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1",
    "theorem": "{p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1",
    "args": "{p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b)",
    "doc_string": "Dividing out by a prime factor reduces the padic_val_nat by 1.",
    "kind": "theorem",
    "type": "padic_val_nat p (b / p) = padic_val_nat p b - 1"
  },
  {
    "name": "nat.mkpair",
    "statement": "def nat.mkpair (a b : ℕ) : ℕ",
    "theorem": "(a b : ℕ) : ℕ",
    "args": "(a b : ℕ)",
    "doc_string": "Pairing function for the natural numbers.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "function.antiperiodic.periodic",
    "statement": "theorem function.antiperiodic.periodic {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c) : function.periodic f (2 * c)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c) : function.periodic f (2 * c)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c)",
    "doc_string": "If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period  `2 * c`.",
    "kind": "theorem",
    "type": "function.periodic f (2 * c)"
  },
  {
    "name": "native.float.specification.radix",
    "statement": "constant native.float.specification.radix  : ℕ",
    "theorem": " : ℕ",
    "args": "",
    "doc_string": "The base. Either 2 or 10.",
    "kind": "constant",
    "type": "ℕ"
  },
  {
    "name": "sSet.truncated",
    "statement": "def sSet.truncated (n : ℕ) : Type (u+1)",
    "theorem": "(n : ℕ) : Type (u+1)",
    "args": "(n : ℕ)",
    "doc_string": "Truncated simplicial sets.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "is_subgroup.normalizer",
    "statement": "def is_subgroup.normalizer {G : Type u_1} [group G] (s : set G) : set G",
    "theorem": "{G : Type u_1} [group G] (s : set G) : set G",
    "args": "{G : Type u_1} [group G] (s : set G)",
    "doc_string": "The underlying set of the normalizer of a subset `S : set G` of a group `G`. That is,  the elements `g : G` such that `g * S * g⁻¹ = S`.",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "normed_division_ring.to_normed_ring",
    "statement": "def normed_division_ring.to_normed_ring {α : Type u_1} [β : normed_division_ring α] : normed_ring α",
    "theorem": "{α : Type u_1} [β : normed_division_ring α] : normed_ring α",
    "args": "{α : Type u_1} [β : normed_division_ring α]",
    "doc_string": "A normed division ring is a normed ring.",
    "kind": "def",
    "type": "normed_ring α"
  },
  {
    "name": "bitvec.sle",
    "statement": "def bitvec.sle {n : ℕ} (x y : bitvec n) : Prop",
    "theorem": "{n : ℕ} (x y : bitvec n) : Prop",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "signed less-than-or-equal-to proposition",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "one_mem_class",
    "statement": "structure one_mem_class (S : Type u_4) (M : out_param (Type u_5)) [has_one M] [set_like S M] : Type",
    "theorem": "(S : Type u_4) (M : out_param (Type u_5)) [has_one M] [set_like S M] : Type",
    "args": "(S : Type u_4) (M : out_param (Type u_5)) [has_one M] [set_like S M]",
    "doc_string": "`one_mem_class S M` says `S` is a type of subsets `s ≤ M`, such that `1 ∈ s` for all `s`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "is_submonoid.Inter",
    "statement": "theorem is_submonoid.Inter {M : Type u_1} [monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_submonoid (s y)) : is_submonoid (set.Inter s)",
    "theorem": "{M : Type u_1} [monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_submonoid (s y)) : is_submonoid (set.Inter s)",
    "args": "{M : Type u_1} [monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_submonoid (s y))",
    "doc_string": "The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`.",
    "kind": "theorem",
    "type": "is_submonoid (set.Inter s)"
  },
  {
    "name": "finset.gcd",
    "statement": "def finset.gcd {α : Type u_1} {β : Type u_2} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : finset β) (f : β → α) : α",
    "theorem": "{α : Type u_1} {β : Type u_2} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : finset β) (f : β → α) : α",
    "args": "{α : Type u_1} {β : Type u_2} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : finset β) (f : β → α)",
    "doc_string": "Greatest common divisor of a finite set",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "add_subsemigroup.prod",
    "statement": "def add_subsemigroup.prod {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (s : add_subsemigroup M) (t : add_subsemigroup N) : add_subsemigroup (M × N)",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (s : add_subsemigroup M) (t : add_subsemigroup N) : add_subsemigroup (M × N)",
    "args": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (s : add_subsemigroup M) (t : add_subsemigroup N)",
    "doc_string": "Given `add_subsemigroup`s `s`, `t` of `add_semigroup`s `A`, `B` respectively, `s × t` as an `add_subsemigroup` of `A × B`.",
    "kind": "def",
    "type": "add_subsemigroup (M × N)"
  },
  {
    "name": "same_ray.refl",
    "statement": "theorem same_ray.refl {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x",
    "theorem": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x",
    "args": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M)",
    "doc_string": "`same_ray` is reflexive.",
    "kind": "theorem",
    "type": "same_ray R x x"
  },
  {
    "name": "stream.cycle_g",
    "statement": "def stream.cycle_g {α : Type u} : α × list α × α × list α → α × list α × α × list α",
    "theorem": "{α : Type u} : α × list α × α × list α → α × list α × α × list α",
    "args": "{α : Type u}",
    "doc_string": "An auxiliary definition for `stream.cycle` corecursive def",
    "kind": "def",
    "type": "α × list α × α × list α → α × list α × α × list α"
  },
  {
    "name": "option.subsingleton_iff_is_empty",
    "statement": "theorem option.subsingleton_iff_is_empty {α : Type u_1} : subsingleton (option α) ↔ is_empty α",
    "theorem": "{α : Type u_1} : subsingleton (option α) ↔ is_empty α",
    "args": "{α : Type u_1}",
    "doc_string": "`option α` is a `subsingleton` if and only if `α` is empty.",
    "kind": "theorem",
    "type": "subsingleton (option α) ↔ is_empty α"
  },
  {
    "name": "add_subgroup.left_transversals",
    "statement": "def add_subgroup.left_transversals {G : Type u_1} [add_group G] (T : set G) : set (set G)",
    "theorem": "{G : Type u_1} [add_group G] (T : set G) : set (set G)",
    "args": "{G : Type u_1} [add_group G] (T : set G)",
    "doc_string": "The set of left-complements of `T : set G`",
    "kind": "def",
    "type": "set (set G)"
  },
  {
    "name": "cardinal.sum_lt_prod",
    "statement": "theorem cardinal.sum_lt_prod {ι : Type u_1} (f g : ι → cardinal) (H : ∀ (i : ι), f i < g i) : cardinal.sum f < cardinal.prod g",
    "theorem": "{ι : Type u_1} (f g : ι → cardinal) (H : ∀ (i : ι), f i < g i) : cardinal.sum f < cardinal.prod g",
    "args": "{ι : Type u_1} (f g : ι → cardinal) (H : ∀ (i : ι), f i < g i)",
    "doc_string": "**König's theorem**",
    "kind": "theorem",
    "type": "cardinal.sum f < cardinal.prod g"
  },
  {
    "name": "encodable.decode₂",
    "statement": "def encodable.decode₂ (α : Type u_1) [encodable α] (n : ℕ) : option α",
    "theorem": "(α : Type u_1) [encodable α] (n : ℕ) : option α",
    "args": "(α : Type u_1) [encodable α] (n : ℕ)",
    "doc_string": " Failsafe variant of `decode`. `decode₂ α n` returns the preimage of `n` under `encode` if it exists, and returns `none` if it doesn't. This requirement could be imposed directly on `decode` but is not to help make the definition easier to use.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "skew_adjoint.submodule",
    "statement": "def skew_adjoint.submodule (R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A",
    "theorem": "(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A",
    "args": "(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A]",
    "doc_string": "The skew-adjoint elements of a star module, as a submodule.",
    "kind": "def",
    "type": "submodule R A"
  },
  {
    "name": "subsemiring.topological_closure",
    "statement": "def subsemiring.topological_closure {α : Type u_1} [topological_space α] [semiring α] [topological_semiring α] (s : subsemiring α) : subsemiring α",
    "theorem": "{α : Type u_1} [topological_space α] [semiring α] [topological_semiring α] (s : subsemiring α) : subsemiring α",
    "args": "{α : Type u_1} [topological_space α] [semiring α] [topological_semiring α] (s : subsemiring α)",
    "doc_string": " The (topological-space) closure of a subsemiring of a topological semiring is itself a subsemiring.",
    "kind": "def",
    "type": "subsemiring α"
  },
  {
    "name": "add_pos'",
    "statement": "theorem add_pos' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "**Alias** of `left.add_pos'`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "filter.countable_filter_basis",
    "statement": "structure filter.countable_filter_basis (α : Type u_6) : Type u_6",
    "theorem": "(α : Type u_6) : Type u_6",
    "args": "(α : Type u_6)",
    "doc_string": " A countable filter basis `B` on a type `α` is a nonempty countable collection of sets of `α` such that the intersection of two elements of this collection contains some element of the collection.",
    "kind": "structure",
    "type": "Type u_6"
  },
  {
    "name": "add_monoid.to_add_action",
    "statement": "def add_monoid.to_add_action (M : Type u_1) [add_monoid M] : add_action M M",
    "theorem": "(M : Type u_1) [add_monoid M] : add_action M M",
    "args": "(M : Type u_1) [add_monoid M]",
    "doc_string": " The regular action of a monoid on itself by left addition.  This is promoted to an `add_torsor` by `add_group_is_add_torsor`.",
    "kind": "def",
    "type": "add_action M M"
  },
  {
    "name": "snum.bits",
    "statement": "def snum.bits  : snum → Π (n : ℕ), vector bool n",
    "theorem": " : snum → Π (n : ℕ), vector bool n",
    "args": "",
    "doc_string": "`a.bits n` is the vector of the `n` first bits of `a` (starting from the LSB).",
    "kind": "def",
    "type": "snum → Π (n : ℕ), vector bool n"
  },
  {
    "name": "fin.find",
    "statement": "def fin.find {n : ℕ} (p : fin n → Prop) [decidable_pred p] : option (fin n)",
    "theorem": "{n : ℕ} (p : fin n → Prop) [decidable_pred p] : option (fin n)",
    "args": "{n : ℕ} (p : fin n → Prop) [decidable_pred p]",
    "doc_string": " `find p` returns the first index `n` where `p n` is satisfied, and `none` if it is never satisfied.",
    "kind": "def",
    "type": "option (fin n)"
  },
  {
    "name": "ordnode.take",
    "statement": "def ordnode.take {α : Type u} (i : ℕ) (t : ordnode α) : ordnode α",
    "theorem": "{α : Type u} (i : ℕ) (t : ordnode α) : ordnode α",
    "args": "{α : Type u} (i : ℕ) (t : ordnode α)",
    "doc_string": "O(log n). Get the first `i` elements of the set, counted from the left.      take 2 {a, b, c, d} = {a, b}     take 5 {a, b, c, d} = {a, b, c, d}",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "rack.assoc_iff_id",
    "statement": "theorem rack.assoc_iff_id {R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z",
    "theorem": "{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z",
    "args": "{R : Type u_1} [rack R] {x y z : R}",
    "doc_string": "Associative racks are uninteresting.",
    "kind": "theorem",
    "type": "shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z"
  },
  {
    "name": "erased.bind",
    "statement": "def erased.bind {α : Sort u_1} {β : Sort u_2} (a : erased α) (f : α → erased β) : erased β",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (a : erased α) (f : α → erased β) : erased β",
    "args": "{α : Sort u_1} {β : Sort u_2} (a : erased α) (f : α → erased β)",
    "doc_string": "`(>>=)` operation on `erased`.  This is a separate definition because `α` and `β` can live in different universes (the universe is fixed in `monad`).",
    "kind": "def",
    "type": "erased β"
  },
  {
    "name": "fact_one_le_two_ennreal",
    "statement": "def fact_one_le_two_ennreal  : fact (1 ≤ 2)",
    "theorem": " : fact (1 ≤ 2)",
    "args": "",
    "doc_string": "`(1 : ℝ≥0∞) ≤ 2`, recorded as a `fact` for use with `Lp` spaces.",
    "kind": "def",
    "type": "fact (1 ≤ 2)"
  },
  {
    "name": "lie_algebra.e₈",
    "statement": "def lie_algebra.e₈ (R : Type u) [comm_ring R] : Type u",
    "theorem": "(R : Type u) [comm_ring R] : Type u",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "The exceptional split Lie algebra of type e₈.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "is_add_submonoid",
    "statement": "structure is_add_submonoid {A : Type u_2} [add_monoid A] (s : set A) : Prop",
    "theorem": "{A : Type u_2} [add_monoid A] (s : set A) : Prop",
    "args": "{A : Type u_2} [add_monoid A] (s : set A)",
    "doc_string": " `s` is an additive submonoid: a set containing 0 and closed under addition. Note that this structure is deprecated, and the bundled variant `add_submonoid A` should be preferred.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "bitvec.sgt",
    "statement": "def bitvec.sgt {n : ℕ} (x y : bitvec n) : Prop",
    "theorem": "{n : ℕ} (x y : bitvec n) : Prop",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "signed greater-than proposition",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ring_hom_inv_pair.star_ring_end.ring_hom_inv_pair",
    "statement": "def ring_hom_inv_pair.star_ring_end.ring_hom_inv_pair {R : Type u} [comm_semiring R] [star_ring R] : ring_hom_inv_pair (star_ring_end R) (star_ring_end R)",
    "theorem": "{R : Type u} [comm_semiring R] [star_ring R] : ring_hom_inv_pair (star_ring_end R) (star_ring_end R)",
    "args": "{R : Type u} [comm_semiring R] [star_ring R]",
    "doc_string": " Instance needed to define star-linear maps over a commutative star ring (ex: conjugate-linear maps when R = ℂ).",
    "kind": "def",
    "type": "ring_hom_inv_pair (star_ring_end R) (star_ring_end R)"
  },
  {
    "name": "not_not",
    "statement": "theorem not_not {a : Prop} : ¬¬a ↔ a",
    "theorem": "{a : Prop} : ¬¬a ↔ a",
    "args": "{a : Prop}",
    "doc_string": " The Double Negation Theorem: `¬ ¬ P` is equivalent to `P`. The left-to-right direction, double negation elimination (DNE), is classically true but not constructively.",
    "kind": "theorem",
    "type": "¬¬a ↔ a"
  },
  {
    "name": "linear_order",
    "statement": "structure linear_order (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A linear order is reflexive, transitive, antisymmetric and total relation `≤`. We assume that every linear ordered type has decidable `(≤)`, `(<)`, and `(=)`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "boolean_ring.has_sup",
    "statement": "def boolean_ring.has_sup {α : Type u_1} [boolean_ring α] : has_sup α",
    "theorem": "{α : Type u_1} [boolean_ring α] : has_sup α",
    "args": "{α : Type u_1} [boolean_ring α]",
    "doc_string": "The join operation in a Boolean ring is `x + y + x * y`.",
    "kind": "def",
    "type": "has_sup α"
  },
  {
    "name": "topological_space.exists_dense_seq",
    "statement": "theorem topological_space.exists_dense_seq (α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ∃ (u : ℕ → α), dense_range u",
    "theorem": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ∃ (u : ℕ → α), dense_range u",
    "args": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α]",
    "doc_string": " A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the conclusion of this lemma, you might want to use `topological_space.dense_seq` and `topological_space.dense_range_dense_seq`.  If `α` might be empty, then `exists_countable_dense` is the main way to use separability of `α`.",
    "kind": "theorem",
    "type": "∃ (u : ℕ → α), dense_range u"
  },
  {
    "name": "topological_space.opens",
    "statement": "def topological_space.opens (α : Type u_1) [topological_space α] : Type u_1",
    "theorem": "(α : Type u_1) [topological_space α] : Type u_1",
    "args": "(α : Type u_1) [topological_space α]",
    "doc_string": "The type of open subsets of a topological space.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "pseudo_metric_space.to_pseudo_emetric_space",
    "statement": "def pseudo_metric_space.to_pseudo_emetric_space {α : Type u} [pseudo_metric_space α] : pseudo_emetric_space α",
    "theorem": "{α : Type u} [pseudo_metric_space α] : pseudo_emetric_space α",
    "args": "{α : Type u} [pseudo_metric_space α]",
    "doc_string": "A pseudometric space induces a pseudoemetric space",
    "kind": "def",
    "type": "pseudo_emetric_space α"
  },
  {
    "name": "setoid.ker",
    "statement": "def setoid.ker {α : Type u_1} {β : Type u_2} (f : α → β) : setoid α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) : setoid α",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β)",
    "doc_string": "The kernel of a function is an equivalence relation.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "finset.division_monoid",
    "statement": "def finset.division_monoid {α : Type u_2} [decidable_eq α] [division_monoid α] : division_monoid (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [division_monoid α] : division_monoid (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [division_monoid α]",
    "doc_string": "`finset α` is a division monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "division_monoid (finset α)"
  },
  {
    "name": "is_local_min",
    "statement": "def is_local_min {α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α)",
    "doc_string": "`is_local_min f a` means that `f a ≤ f x` for all `x` in some neighborhood of `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "measure_theory.simple_func.eapprox_diff",
    "statement": "def measure_theory.simple_func.eapprox_diff {α : Type u_1} [measurable_space α] (f : α → ennreal) (n : ℕ) : measure_theory.simple_func α nnreal",
    "theorem": "{α : Type u_1} [measurable_space α] (f : α → ennreal) (n : ℕ) : measure_theory.simple_func α nnreal",
    "args": "{α : Type u_1} [measurable_space α] (f : α → ennreal) (n : ℕ)",
    "doc_string": " Approximate a function `α → ℝ≥0∞` by a series of simple functions taking their values in `ℝ≥0`.",
    "kind": "def",
    "type": "measure_theory.simple_func α nnreal"
  },
  {
    "name": "is_of_fin_order_inv_iff",
    "statement": "theorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x",
    "theorem": "{G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x",
    "args": "{G : Type u} [group G] {x : G}",
    "doc_string": "Inverses of elements of finite order have finite order.",
    "kind": "theorem",
    "type": "is_of_fin_order x⁻¹ ↔ is_of_fin_order x"
  },
  {
    "name": "add_action.is_pretransitive",
    "statement": "structure add_action.is_pretransitive (M : Type u_10) (α : Type u_11) [has_vadd M α] : Prop",
    "theorem": "(M : Type u_10) (α : Type u_11) [has_vadd M α] : Prop",
    "args": "(M : Type u_10) (α : Type u_11) [has_vadd M α]",
    "doc_string": "`M` acts pretransitively on `α` if for any `x y` there is `g` such that `g +ᵥ x = y`.  A transitive action should furthermore have `α` nonempty.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "grade_min_order",
    "statement": "structure grade_min_order (𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)",
    "theorem": "(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)",
    "args": "(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α]",
    "doc_string": "A `𝕆`-graded order where minimal elements have minimal grades.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "category_theory.limits.has_zero_object.has_initial",
    "statement": "def category_theory.limits.has_zero_object.has_initial {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_initial C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_initial C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C]",
    "doc_string": "A zero object is in particular initial.",
    "kind": "def",
    "type": "category_theory.limits.has_initial C"
  },
  {
    "name": "finsupp.single_injective",
    "statement": "theorem finsupp.single_injective {α : Type u_1} {M : Type u_5} [has_zero M] (a : α) : function.injective (finsupp.single a)",
    "theorem": "{α : Type u_1} {M : Type u_5} [has_zero M] (a : α) : function.injective (finsupp.single a)",
    "args": "{α : Type u_1} {M : Type u_5} [has_zero M] (a : α)",
    "doc_string": " `finsupp.single a b` is injective in `b`. For the statement that it is injective in `a`, see `finsupp.single_left_injective`",
    "kind": "theorem",
    "type": "function.injective (finsupp.single a)"
  },
  {
    "name": "principal_ideal_ring.to_unique_factorization_monoid",
    "statement": "def principal_ideal_ring.to_unique_factorization_monoid {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] : unique_factorization_monoid R",
    "theorem": "{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] : unique_factorization_monoid R",
    "args": "{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R]",
    "doc_string": "A principal ideal domain has unique factorization",
    "kind": "def",
    "type": "unique_factorization_monoid R"
  },
  {
    "name": "round",
    "statement": "def round {α : Type u_1} [linear_ordered_field α] [floor_ring α] (x : α) : ℤ",
    "theorem": "{α : Type u_1} [linear_ordered_field α] [floor_ring α] (x : α) : ℤ",
    "args": "{α : Type u_1} [linear_ordered_field α] [floor_ring α] (x : α)",
    "doc_string": "`round` rounds a number to the nearest integer. `round (1 / 2) = 1`",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "finset.add_comm_semigroup",
    "statement": "def finset.add_comm_semigroup {α : Type u_2} [decidable_eq α] [add_comm_semigroup α] : add_comm_semigroup (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [add_comm_semigroup α] : add_comm_semigroup (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [add_comm_semigroup α]",
    "doc_string": "`finset α` is an `add_comm_semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_comm_semigroup (finset α)"
  },
  {
    "name": "bot_hom.id",
    "statement": "def bot_hom.id (α : Type u_2) [has_bot α] : bot_hom α α",
    "theorem": "(α : Type u_2) [has_bot α] : bot_hom α α",
    "args": "(α : Type u_2) [has_bot α]",
    "doc_string": "`id` as a `bot_hom`.",
    "kind": "def",
    "type": "bot_hom α α"
  },
  {
    "name": "ratfunc.inv",
    "statement": "def ratfunc.inv {K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K → ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K → ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K] [hdomain : is_domain K]",
    "doc_string": "Multiplicative inverse of a rational function.",
    "kind": "def",
    "type": "ratfunc K → ratfunc K"
  },
  {
    "name": "lie_algebra.e₆",
    "statement": "def lie_algebra.e₆ (R : Type u) [comm_ring R] : Type u",
    "theorem": "(R : Type u) [comm_ring R] : Type u",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "The exceptional split Lie algebra of type e₆.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "submodule.span",
    "statement": "def submodule.span (R : Type u_1) {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (s : set M) : submodule R M",
    "theorem": "(R : Type u_1) {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (s : set M) : submodule R M",
    "args": "(R : Type u_1) {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (s : set M)",
    "doc_string": "The span of a set `s ⊆ M` is the smallest submodule of M that contains `s`.",
    "kind": "def",
    "type": "submodule R M"
  },
  {
    "name": "mvpfunctor.comp",
    "statement": "def mvpfunctor.comp {n m : ℕ} (P : mvpfunctor n) (Q : fin2 n → mvpfunctor m) : mvpfunctor m",
    "theorem": "{n m : ℕ} (P : mvpfunctor n) (Q : fin2 n → mvpfunctor m) : mvpfunctor m",
    "args": "{n m : ℕ} (P : mvpfunctor n) (Q : fin2 n → mvpfunctor m)",
    "doc_string": "Functor composition on polynomial functors",
    "kind": "def",
    "type": "mvpfunctor m"
  },
  {
    "name": "spectral_radius",
    "statement": "def spectral_radius (𝕜 : Type u_1) {A : Type u_2} [normed_field 𝕜] [ring A] [algebra 𝕜 A] (a : A) : ennreal",
    "theorem": "(𝕜 : Type u_1) {A : Type u_2} [normed_field 𝕜] [ring A] [algebra 𝕜 A] (a : A) : ennreal",
    "args": "(𝕜 : Type u_1) {A : Type u_2} [normed_field 𝕜] [ring A] [algebra 𝕜 A] (a : A)",
    "doc_string": "The *spectral radius* is the supremum of the `nnnorm` (`∥⬝∥₊`) of elements in the spectrum,    coerced into an element of `ℝ≥0∞`. Note that it is possible for `spectrum 𝕜 a = ∅`. In this    case, `spectral_radius a = 0`.  It is also possible that `spectrum 𝕜 a` be unbounded (though    not for Banach algebras, see `spectrum.is_bounded`, below).  In this case,    `spectral_radius a = ∞`.",
    "kind": "def",
    "type": "ennreal"
  },
  {
    "name": "hash_map.entries",
    "statement": "def hash_map.entries {α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) : list (Σ (a : α), β a)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) : list (Σ (a : α), β a)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β)",
    "doc_string": "The list of key-value pairs in the map",
    "kind": "def",
    "type": "list (Σ (a : α), β a)"
  },
  {
    "name": "setoid.prod",
    "statement": "def setoid.prod {α : Type u_1} {β : Type u_2} (r : setoid α) (s : setoid β) : setoid (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : setoid α) (s : setoid β) : setoid (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} (r : setoid α) (s : setoid β)",
    "doc_string": "Given types `α`, `β`, the product of two equivalence relations `r` on `α` and `s` on `β`:    `(x₁, x₂), (y₁, y₂) ∈ α × β` are related by `r.prod s` iff `x₁` is related to `y₁`    by `r` and `x₂` is related to `y₂` by `s`.",
    "kind": "def",
    "type": "setoid (α × β)"
  },
  {
    "name": "ideal.is_jacobson",
    "statement": "structure ideal.is_jacobson (R : Type u_3) [comm_ring R] : Prop",
    "theorem": "(R : Type u_3) [comm_ring R] : Prop",
    "args": "(R : Type u_3) [comm_ring R]",
    "doc_string": "A ring is a Jacobson ring if for every radical ideal `I`, the Jacobson radical of `I` is equal to `I`. See `is_jacobson_iff_prime_eq` and `is_jacobson_iff_Inf_maximal` for equivalent definitions.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "has_measurable_pow",
    "statement": "structure has_measurable_pow (β : Type u_1) (γ : Type u_2) [measurable_space β] [measurable_space γ] [has_pow β γ] : Type",
    "theorem": "(β : Type u_1) (γ : Type u_2) [measurable_space β] [measurable_space γ] [has_pow β γ] : Type",
    "args": "(β : Type u_1) (γ : Type u_2) [measurable_space β] [measurable_space γ] [has_pow β γ]",
    "doc_string": "This class assumes that the map `β × γ → β` given by `(x, y) ↦ x ^ y` is measurable.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "turing.to_partrec.code.rfind",
    "statement": "def turing.to_partrec.code.rfind (f : turing.to_partrec.code) : turing.to_partrec.code",
    "theorem": "(f : turing.to_partrec.code) : turing.to_partrec.code",
    "args": "(f : turing.to_partrec.code)",
    "doc_string": " `rfind f` performs the function of the `rfind` primitive of partial recursive functions. `rfind f v` returns the smallest `n` such that `(f (n :: v)).head = 0`.  It is implemented as:      rfind f v = pred (fix (λ (n::v), f (n::v) :: n+1 :: v) (0 :: v))  The idea is that the initial state is `0 :: v`, and the `fix` keeps `n :: v` as its internal state; it calls `f (n :: v)` as the exit test and `n+1 :: v` as the next state. At the end we get `n+1 :: v` where `n` is the desired output, and `pred (n+1 :: v) = [n]` returns the result.",
    "kind": "def",
    "type": "turing.to_partrec.code"
  },
  {
    "name": "nat.sqrt",
    "statement": "def nat.sqrt (n : ℕ) : ℕ",
    "theorem": "(n : ℕ) : ℕ",
    "args": "(n : ℕ)",
    "doc_string": "`sqrt n` is the square root of a natural number `n`. If `n` is not a  perfect square, it returns the largest `k:ℕ` such that `k*k ≤ n`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "mul_one_class",
    "statement": "structure mul_one_class (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": " Typeclass for expressing that a type `M` with multiplication and a one satisfies `1 * a = a` and `a * 1 = a` for all `a : M`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "d_array.write",
    "statement": "def d_array.write {n : ℕ} {α : fin n → Type u} (a : d_array n α) (i : fin n) (v : α i) : d_array n α",
    "theorem": "{n : ℕ} {α : fin n → Type u} (a : d_array n α) (i : fin n) (v : α i) : d_array n α",
    "args": "{n : ℕ} {α : fin n → Type u} (a : d_array n α) (i : fin n) (v : α i)",
    "doc_string": "`write a i v` sets the `i`th member of `a` to be `v`. Has builtin VM implementation.",
    "kind": "def",
    "type": "d_array n α"
  },
  {
    "name": "compare_reals.Q",
    "statement": "def compare_reals.Q  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Type wrapper around ℚ to make sure the absolute value uniform space instance is picked up instead of the metric space one. We proved in rat.uniform_space_eq that they are equal, but they are not definitionaly equal, so it would confuse the type class system (and probably also human readers).",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "free_magma.lift_aux",
    "statement": "def free_magma.lift_aux {α : Type u} {β : Type v} [has_mul β] (f : α → β) : free_magma α → β",
    "theorem": "{α : Type u} {β : Type v} [has_mul β] (f : α → β) : free_magma α → β",
    "args": "{α : Type u} {β : Type v} [has_mul β] (f : α → β)",
    "doc_string": "Lifts a function `α → β` to a magma homomorphism `free_magma α → β` given a magma `β`.",
    "kind": "def",
    "type": "free_magma α → β"
  },
  {
    "name": "continuous_at",
    "statement": "def continuous_at {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (x : α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (x : α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (x : α)",
    "doc_string": " A function between topological spaces is continuous at a point `x₀` if `f x` tends to `f x₀` when `x` tends to `x₀`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "onote.split'",
    "statement": "def onote.split'  : onote → onote × ℕ",
    "theorem": " : onote → onote × ℕ",
    "args": "",
    "doc_string": "Calculate division and remainder of `o` mod ω.  `split' o = (a, n)` means `o = ω * a + n`.",
    "kind": "def",
    "type": "onote → onote × ℕ"
  },
  {
    "name": "fintype.prod_right",
    "statement": "def fintype.prod_right {α : Type u_1} {β : Type u_2} [decidable_eq β] [fintype (α × β)] [nonempty α] : fintype β",
    "theorem": "{α : Type u_1} {β : Type u_2} [decidable_eq β] [fintype (α × β)] [nonempty α] : fintype β",
    "args": "{α : Type u_1} {β : Type u_2} [decidable_eq β] [fintype (α × β)] [nonempty α]",
    "doc_string": "Given that `α × β` is a fintype, `β` is also a fintype.",
    "kind": "def",
    "type": "fintype β"
  },
  {
    "name": "not_bdd_above_iff'",
    "statement": "theorem not_bdd_above_iff' {α : Type u} [preorder α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x",
    "theorem": "{α : Type u} [preorder α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x",
    "args": "{α : Type u} [preorder α] {s : set α}",
    "doc_string": " A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` such that `x` is not greater than or equal to `y`. This version only assumes `preorder` structure and uses `¬(y ≤ x)`. A version for linear orders is called `not_bdd_above_iff`.",
    "kind": "theorem",
    "type": "¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x"
  },
  {
    "name": "category_theory.limits.has_limits_of_shape",
    "statement": "structure category_theory.limits.has_limits_of_shape (J : Type u₁) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(J : Type u₁) [category_theory.category J] (C : Type u) [category_theory.category C] : Prop",
    "args": "(J : Type u₁) [category_theory.category J] (C : Type u) [category_theory.category C]",
    "doc_string": "`C` has limits of shape `J` if there exists a limit for every functor `F : J ⥤ C`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "monoid_with_zero_hom",
    "statement": "structure monoid_with_zero_hom (M : Type u_9) (N : Type u_10) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_9)",
    "theorem": "(M : Type u_9) (N : Type u_10) [mul_zero_one_class M] [mul_zero_one_class N] : Type (max u_10 u_9)",
    "args": "(M : Type u_9) (N : Type u_10) [mul_zero_one_class M] [mul_zero_one_class N]",
    "doc_string": " `M →*₀ N` is the type of functions `M → N` that preserve the `monoid_with_zero` structure.  `monoid_with_zero_hom` is also used for group homomorphisms.  When possible, instead of parametrizing results over `(f : M →*₀ N)`, you should parametrize over `(F : Type*) [monoid_with_zero_hom_class F M N] (f : F)`.  When you extend this structure, make sure to extend `monoid_with_zero_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_10 u_9)"
  },
  {
    "name": "pythagorean_triple_comm",
    "statement": "theorem pythagorean_triple_comm {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z",
    "theorem": "{x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z",
    "args": "{x y z : ℤ}",
    "doc_string": " Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity.",
    "kind": "theorem",
    "type": "pythagorean_triple x y z ↔ pythagorean_triple y x z"
  },
  {
    "name": "polynomial.support",
    "statement": "def polynomial.support {R : Type u} [semiring R] : polynomial R → finset ℕ",
    "theorem": "{R : Type u} [semiring R] : polynomial R → finset ℕ",
    "args": "{R : Type u} [semiring R]",
    "doc_string": "The set of all `n` such that `X^n` has a non-zero coefficient.",
    "kind": "def",
    "type": "polynomial R → finset ℕ"
  },
  {
    "name": "filter_basis",
    "statement": "structure filter_basis (α : Type u_6) : Type u_6",
    "theorem": "(α : Type u_6) : Type u_6",
    "args": "(α : Type u_6)",
    "doc_string": " A filter basis `B` on a type `α` is a nonempty collection of sets of `α` such that the intersection of two elements of this collection contains some element of the collection.",
    "kind": "structure",
    "type": "Type u_6"
  },
  {
    "name": "measure_theory.measure",
    "statement": "structure measure_theory.measure (α : Type u_6) [measurable_space α] : Type u_6",
    "theorem": "(α : Type u_6) [measurable_space α] : Type u_6",
    "args": "(α : Type u_6) [measurable_space α]",
    "doc_string": " A measure is defined to be an outer measure that is countably additive on measurable sets, with the additional assumption that the outer measure is the canonical extension of the restricted measure.",
    "kind": "structure",
    "type": "Type u_6"
  },
  {
    "name": "category_theory.is_idempotent_complete",
    "statement": "structure category_theory.is_idempotent_complete (C : Type u_1) [category_theory.category C] : Prop",
    "theorem": "(C : Type u_1) [category_theory.category C] : Prop",
    "args": "(C : Type u_1) [category_theory.category C]",
    "doc_string": " A category is idempotent complete iff all idempotent endomorphisms `p` split as a composition `p = e ≫ i` with `i ≫ e = 𝟙 _`",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "fintype_of_compact_of_discrete",
    "statement": "def fintype_of_compact_of_discrete {α : Type u} [topological_space α] [compact_space α] [discrete_topology α] : fintype α",
    "theorem": "{α : Type u} [topological_space α] [compact_space α] [discrete_topology α] : fintype α",
    "args": "{α : Type u} [topological_space α] [compact_space α] [discrete_topology α]",
    "doc_string": "A compact discrete space is finite.",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "clifford_algebra_complex.clifford_algebra.comm_ring",
    "statement": "def clifford_algebra_complex.clifford_algebra.comm_ring  : comm_ring (clifford_algebra clifford_algebra_complex.Q)",
    "theorem": " : comm_ring (clifford_algebra clifford_algebra_complex.Q)",
    "args": "",
    "doc_string": " The clifford algebra is commutative since it is isomorphic to the complex numbers.  TODO: prove this is true for all `clifford_algebra`s over a 1-dimensional vector space.",
    "kind": "def",
    "type": "comm_ring (clifford_algebra clifford_algebra_complex.Q)"
  },
  {
    "name": "pseudo_emetric_space.induced",
    "statement": "def pseudo_emetric_space.induced {α : Type u_1} {β : Type u_2} (f : α → β) (m : pseudo_emetric_space β) : pseudo_emetric_space α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (m : pseudo_emetric_space β) : pseudo_emetric_space α",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (m : pseudo_emetric_space β)",
    "doc_string": "The extended pseudometric induced by a function taking values in a pseudoemetric space.",
    "kind": "def",
    "type": "pseudo_emetric_space α"
  },
  {
    "name": "set.ite",
    "statement": "def set.ite {α : Type u} (t s s' : set α) : set α",
    "theorem": "{α : Type u} (t s s' : set α) : set α",
    "args": "{α : Type u} (t s s' : set α)",
    "doc_string": " `ite` for sets: `set.ite t s s' ∩ t = s ∩ t`, `set.ite t s s' ∩ tᶜ = s' ∩ tᶜ`. Defined as `s ∩ t ∪ s' \\ t`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "list.nat.antidiagonal",
    "statement": "def list.nat.antidiagonal (n : ℕ) : list (ℕ × ℕ)",
    "theorem": "(n : ℕ) : list (ℕ × ℕ)",
    "args": "(n : ℕ)",
    "doc_string": "The antidiagonal of a natural number `n` is the list of pairs `(i, j)` such that `i + j = n`.",
    "kind": "def",
    "type": "list (ℕ × ℕ)"
  },
  {
    "name": "filter.realizer",
    "statement": "structure filter.realizer {α : Type u_1} (f : filter α) : Type (max u_1 (u_5+1))",
    "theorem": "{α : Type u_1} (f : filter α) : Type (max u_1 (u_5+1))",
    "args": "{α : Type u_1} (f : filter α)",
    "doc_string": "A realizer for filter `f` is a cfilter which generates `f`.",
    "kind": "structure",
    "type": "Type (max u_1 (u_5+1))"
  },
  {
    "name": "matrix.rank",
    "statement": "def matrix.rank {m : Type u_1} {n : Type u_2} {K : Type u_4} [fintype n] [decidable_eq n] [field K] (A : matrix m n K) : ℕ",
    "theorem": "{m : Type u_1} {n : Type u_2} {K : Type u_4} [fintype n] [decidable_eq n] [field K] (A : matrix m n K) : ℕ",
    "args": "{m : Type u_1} {n : Type u_2} {K : Type u_4} [fintype n] [decidable_eq n] [field K] (A : matrix m n K)",
    "doc_string": "The rank of a matrix is the rank of its image.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "tactic.eliminate.major_premise_info",
    "statement": "structure tactic.eliminate.major_premise_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Information about a major premise (i.e. the hypothesis on which we are performing induction). Contains:  - `mpname`: the major premise's name. - `mpexpr`: the major premise itself. - `type`: the type of `mpexpr`. - `args`: the arguments of the major premise. The major premise has type   `I x₀ ... xₙ`, where `I` is an inductive type. `args` is the map   `[0 → x₀, ..., n → xₙ]`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "nat.le_induction",
    "statement": "theorem nat.le_induction {P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ) : m ≤ n → P n",
    "theorem": "{P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ) : m ≤ n → P n",
    "args": "{P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ)",
    "doc_string": "Induction principle starting at a non-zero number. For maps to a `Sort*` see `le_rec_on`.",
    "kind": "theorem",
    "type": "m ≤ n → P n"
  },
  {
    "name": "complete_lattice.set_independent",
    "statement": "def complete_lattice.set_independent {α : Type u_1} [complete_lattice α] (s : set α) : Prop",
    "theorem": "{α : Type u_1} [complete_lattice α] (s : set α) : Prop",
    "args": "{α : Type u_1} [complete_lattice α] (s : set α)",
    "doc_string": "An independent set of elements in a complete lattice is one in which every element is disjoint  from the `Sup` of the rest.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "quasi_sober",
    "statement": "structure quasi_sober (α : Type u_3) [topological_space α] : Prop",
    "theorem": "(α : Type u_3) [topological_space α] : Prop",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": "A space is sober if every irreducible closed subset has a generic point.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "has_vadd.comp.vadd",
    "statement": "def has_vadd.comp.vadd {M : Type u_1} {N : Type u_2} {α : Type u_6} [has_vadd M α] (g : N → M) (n : N) (a : α) : α",
    "theorem": "{M : Type u_1} {N : Type u_2} {α : Type u_6} [has_vadd M α] (g : N → M) (n : N) (a : α) : α",
    "args": "{M : Type u_1} {N : Type u_2} {α : Type u_6} [has_vadd M α] (g : N → M) (n : N) (a : α)",
    "doc_string": "Auxiliary definition for `has_vadd.comp`, `add_action.comp_hom`, etc.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "category_theory.balanced",
    "statement": "structure category_theory.balanced (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category is called balanced if any morphism that is both monic and epic is an isomorphism.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_of_fin_order_neg_iff",
    "statement": "theorem is_of_fin_order_neg_iff {G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x",
    "theorem": "{G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x",
    "args": "{G : Type u} [add_group G] {x : G}",
    "doc_string": "Inverses of elements of finite additive order have finite additive order.",
    "kind": "theorem",
    "type": "is_of_fin_add_order (-x) ↔ is_of_fin_add_order x"
  },
  {
    "name": "module.free.choose_basis_index.fintype",
    "statement": "def module.free.choose_basis_index.fintype (R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] [module.free R M] [nontrivial R] [module.finite R M] : fintype (module.free.choose_basis_index R M)",
    "theorem": "(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] [module.free R M] [nontrivial R] [module.finite R M] : fintype (module.free.choose_basis_index R M)",
    "args": "(R : Type u) (M : Type v) [ring R] [add_comm_group M] [module R M] [module.free R M] [nontrivial R] [module.finite R M]",
    "doc_string": "If a free module is finite, then any basis is finite.",
    "kind": "def",
    "type": "fintype (module.free.choose_basis_index R M)"
  },
  {
    "name": "metric.continuous_inf_dist_pt",
    "statement": "theorem metric.continuous_inf_dist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set is continuous in point",
    "kind": "theorem",
    "type": "continuous (λ (x : α), metric.inf_dist x s)"
  },
  {
    "name": "measurable.of_comap_le",
    "statement": "theorem measurable.of_comap_le {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable_space.comap f m₂ ≤ m₁ → measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable_space.comap f m₂ ≤ m₁ → measurable f",
    "args": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β}",
    "doc_string": "**Alias** of the reverse direction of measurable_iff_comap_le`.",
    "kind": "theorem",
    "type": "measurable_space.comap f m₂ ≤ m₁ → measurable f"
  },
  {
    "name": "zero_lt.left.mul_nonneg",
    "statement": "theorem zero_lt.left.mul_nonneg {α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "0 ≤ a * b"
  },
  {
    "name": "add_subgroup.right_transversals",
    "statement": "def add_subgroup.right_transversals {G : Type u_1} [add_group G] (S : set G) : set (set G)",
    "theorem": "{G : Type u_1} [add_group G] (S : set G) : set (set G)",
    "args": "{G : Type u_1} [add_group G] (S : set G)",
    "doc_string": "The set of right-complements of `S : set G`",
    "kind": "def",
    "type": "set (set G)"
  },
  {
    "name": "NonemptyFinLinOrd",
    "statement": "def NonemptyFinLinOrd  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of nonempty finite linear orders.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "wseq.any",
    "statement": "def wseq.any {α : Type u} (s : wseq α) (p : α → bool) : computation bool",
    "theorem": "{α : Type u} (s : wseq α) (p : α → bool) : computation bool",
    "args": "{α : Type u} (s : wseq α) (p : α → bool)",
    "doc_string": "Returns `tt` if any element of `s` satisfies `p`",
    "kind": "def",
    "type": "computation bool"
  },
  {
    "name": "conj_classes",
    "statement": "def conj_classes (α : Type u_1) [monoid α] : Type u_1",
    "theorem": "(α : Type u_1) [monoid α] : Type u_1",
    "args": "(α : Type u_1) [monoid α]",
    "doc_string": "The quotient type of conjugacy classes of a group.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "linear_map.apply_module",
    "statement": "def linear_map.apply_module {R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : module (module.End R M) M",
    "theorem": "{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : module (module.End R M) M",
    "args": "{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": " The tautological action by `module.End R M` (aka `M →ₗ[R] M`) on `M`.  This generalizes `function.End.apply_mul_action`.",
    "kind": "def",
    "type": "module (module.End R M) M"
  },
  {
    "name": "formal_multilinear_series.comp_partial_sum_target_tendsto_at_top",
    "statement": "theorem formal_multilinear_series.comp_partial_sum_target_tendsto_at_top  : filter.tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top",
    "theorem": " : filter.tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top",
    "args": "",
    "doc_string": " The auxiliary set corresponding to the composition of partial sums asymptotically contains all possible compositions.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top"
  },
  {
    "name": "algebra.finite_type.of_finite_presentation",
    "statement": "theorem algebra.finite_type.of_finite_presentation {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A → algebra.finite_type R A",
    "theorem": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A → algebra.finite_type R A",
    "args": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A]",
    "doc_string": "A finitely presented algebra is of finite type.",
    "kind": "theorem",
    "type": "algebra.finite_presentation R A → algebra.finite_type R A"
  },
  {
    "name": "finset.inf",
    "statement": "def finset.inf {α : Type u_1} {β : Type u_2} [semilattice_inf α] [order_top α] (s : finset β) (f : β → α) : α",
    "theorem": "{α : Type u_1} {β : Type u_2} [semilattice_inf α] [order_top α] (s : finset β) (f : β → α) : α",
    "args": "{α : Type u_1} {β : Type u_2} [semilattice_inf α] [order_top α] (s : finset β) (f : β → α)",
    "doc_string": "Infimum of a finite set: `inf {a, b, c} f = f a ⊓ f b ⊓ f c`",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "fin.coe_fin_lt",
    "statement": "theorem fin.coe_fin_lt {n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b",
    "theorem": "{n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b",
    "args": "{n : ℕ} {a b : fin n}",
    "doc_string": "`a < b` as natural numbers if and only if `a < b` in `fin n`.",
    "kind": "theorem",
    "type": "↑a < ↑b ↔ a < b"
  },
  {
    "name": "fintype.to_encodable",
    "statement": "def fintype.to_encodable (α : Type u_1) [fintype α] : encodable α",
    "theorem": "(α : Type u_1) [fintype α] : encodable α",
    "args": "(α : Type u_1) [fintype α]",
    "doc_string": " A noncomputable way to arbitrarily choose an ordering on a finite type. It is not made into a global instance, since it involves an arbitrary choice. This can be locally made into an instance with `local attribute [instance] fintype.to_encodable`.",
    "kind": "def",
    "type": "encodable α"
  },
  {
    "name": "fixing_add_subgroup",
    "statement": "def fixing_add_subgroup (M : Type u_1) {α : Type u_2} [add_group M] [add_action M α] (s : set α) : add_subgroup M",
    "theorem": "(M : Type u_1) {α : Type u_2} [add_group M] [add_action M α] (s : set α) : add_subgroup M",
    "args": "(M : Type u_1) {α : Type u_2} [add_group M] [add_action M α] (s : set α)",
    "doc_string": "The additive subgroup fixing a set under an `add_action`.",
    "kind": "def",
    "type": "add_subgroup M"
  },
  {
    "name": "is_add_monoid_hom.is_add_monoid_hom_mul_right",
    "statement": "theorem is_add_monoid_hom.is_add_monoid_hom_mul_right {γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)",
    "theorem": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)",
    "args": "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ)",
    "doc_string": "Right multiplication in a ring is an additive monoid morphism.",
    "kind": "theorem",
    "type": "is_add_monoid_hom (λ (y : γ), y * x)"
  },
  {
    "name": "pSet.insert",
    "statement": "def pSet.insert  : pSet → pSet → pSet",
    "theorem": " : pSet → pSet → pSet",
    "args": "",
    "doc_string": "Insert an element into a pre-set",
    "kind": "def",
    "type": "pSet → pSet → pSet"
  },
  {
    "name": "pair_self_adjoint_matrices_submodule",
    "statement": "def pair_self_adjoint_matrices_submodule {R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J J₃ : matrix n n R₃) [decidable_eq n] : submodule R₃ (matrix n n R₃)",
    "theorem": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J J₃ : matrix n n R₃) [decidable_eq n] : submodule R₃ (matrix n n R₃)",
    "args": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J J₃ : matrix n n R₃) [decidable_eq n]",
    "doc_string": " The submodule of pair-self-adjoint matrices with respect to bilinear forms corresponding to given matrices `J`, `J₂`.",
    "kind": "def",
    "type": "submodule R₃ (matrix n n R₃)"
  },
  {
    "name": "relation.refl_gen",
    "statement": "inductive relation.refl_gen {α : Type u_1} (r : α → α → Prop) (a : α) : α → Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (a : α) : α → Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (a : α)",
    "doc_string": "`refl_gen r`: reflexive closure of `r`",
    "kind": "inductive",
    "type": "α → Prop"
  },
  {
    "name": "category_theory.sieve.complete_lattice",
    "statement": "def category_theory.sieve.complete_lattice {C : Type u₁} [category_theory.category C] {X : C} : complete_lattice (category_theory.sieve X)",
    "theorem": "{C : Type u₁} [category_theory.category C] {X : C} : complete_lattice (category_theory.sieve X)",
    "args": "{C : Type u₁} [category_theory.category C] {X : C}",
    "doc_string": "Sieves on an object `X` form a complete lattice. We generate this directly rather than using the galois insertion for nicer definitional properties.",
    "kind": "def",
    "type": "complete_lattice (category_theory.sieve X)"
  },
  {
    "name": "subring.neg_mem",
    "statement": "theorem subring.neg_mem {R : Type u} [ring R] (s : subring R) {x : R} : x ∈ s → -x ∈ s",
    "theorem": "{R : Type u} [ring R] (s : subring R) {x : R} : x ∈ s → -x ∈ s",
    "args": "{R : Type u} [ring R] (s : subring R) {x : R}",
    "doc_string": "A subring is closed under negation.",
    "kind": "theorem",
    "type": "x ∈ s → -x ∈ s"
  },
  {
    "name": "nonote.of_nat",
    "statement": "def nonote.of_nat (n : ℕ) : nonote",
    "theorem": "(n : ℕ) : nonote",
    "args": "(n : ℕ)",
    "doc_string": "Convert a natural number to an ordinal notation",
    "kind": "def",
    "type": "nonote"
  },
  {
    "name": "sym.map",
    "statement": "def sym.map {α : Type u_1} {β : Type u_2} {n : ℕ} (f : α → β) (x : sym α n) : sym β n",
    "theorem": "{α : Type u_1} {β : Type u_2} {n : ℕ} (f : α → β) (x : sym α n) : sym β n",
    "args": "{α : Type u_1} {β : Type u_2} {n : ℕ} (f : α → β) (x : sym α n)",
    "doc_string": " A function `α → β` induces a function `sym α n → sym β n` by applying it to every element of the underlying `n`-tuple.",
    "kind": "def",
    "type": "sym β n"
  },
  {
    "name": "tactic.abel.context",
    "statement": "structure tactic.abel.context  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The `context` for a call to `abel`.  Stores a few options for this call, and caches some common subexpressions such as typeclass instances and `0 : α`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "category_theory.fin_category.obj_as_type",
    "statement": "def category_theory.fin_category.obj_as_type (α : Type u_1) [fintype α] [category_theory.small_category α] [category_theory.fin_category α] : Type",
    "theorem": "(α : Type u_1) [fintype α] [category_theory.small_category α] [category_theory.fin_category α] : Type",
    "args": "(α : Type u_1) [fintype α] [category_theory.small_category α] [category_theory.fin_category α]",
    "doc_string": "A fin_category `α` is equivalent to a category with objects in `Type`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "pfunctor.M.head",
    "statement": "def pfunctor.M.head {F : pfunctor} (x : F.M) : F.A",
    "theorem": "{F : pfunctor} (x : F.M) : F.A",
    "args": "{F : pfunctor} (x : F.M)",
    "doc_string": " given a tree generated by `F`, `head` gives us the first piece of data it contains",
    "kind": "def",
    "type": "F.A"
  },
  {
    "name": "has_le.le.lt_or_eq",
    "statement": "theorem has_le.le.lt_or_eq {α : Type u} [partial_order α] {a b : α} : a ≤ b → a < b ∨ a = b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → a < b ∨ a = b",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of lt_or_eq_of_le`.",
    "kind": "theorem",
    "type": "a ≤ b → a < b ∨ a = b"
  },
  {
    "name": "structure_groupoid.order_bot",
    "statement": "def structure_groupoid.order_bot {H : Type u} [topological_space H] : order_bot (structure_groupoid H)",
    "theorem": "{H : Type u} [topological_space H] : order_bot (structure_groupoid H)",
    "args": "{H : Type u} [topological_space H]",
    "doc_string": "Every structure groupoid contains the identity groupoid",
    "kind": "def",
    "type": "order_bot (structure_groupoid H)"
  },
  {
    "name": "has_neg_part",
    "statement": "structure has_neg_part (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "The negative part of an element admiting a decomposition into positive and negative parts.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "urysohns.CU.left",
    "statement": "def urysohns.CU.left {X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X",
    "theorem": "{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X",
    "args": "{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X)",
    "doc_string": " Due to `normal_exists_closure_subset`, for each `c : CU X` there exists an open set `u` such chat `c.C ⊆ u` and `closure u ⊆ c.U`. `c.left` is the pair `(c.C, u)`.",
    "kind": "def",
    "type": "urysohns.CU X"
  },
  {
    "name": "continuous_map.continuous_eval_const'",
    "statement": "theorem continuous_map.continuous_eval_const' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] (a : α) : continuous (λ (f : C(α, β)), ⇑f a)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] (a : α) : continuous (λ (f : C(α, β)), ⇑f a)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] (a : α)",
    "doc_string": "See also `continuous_map.continuous_eval_const`",
    "kind": "theorem",
    "type": "continuous (λ (f : C(α, β)), ⇑f a)"
  },
  {
    "name": "mvqpf.sigma",
    "statement": "def mvqpf.sigma {n : ℕ} {A : Type u} (F : A → typevec n → Type u) (v : typevec n) : Type u",
    "theorem": "{n : ℕ} {A : Type u} (F : A → typevec n → Type u) (v : typevec n) : Type u",
    "args": "{n : ℕ} {A : Type u} (F : A → typevec n → Type u) (v : typevec n)",
    "doc_string": " Dependent sum of of an `n`-ary functor. The sum can range over data types like `ℕ` or over `Type.{u-1}`",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "perfect_closure.r",
    "statement": "inductive perfect_closure.r (K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] : ℕ × K → ℕ × K → Prop",
    "theorem": "(K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] : ℕ × K → ℕ × K → Prop",
    "args": "(K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p]",
    "doc_string": "`perfect_closure K p` is the quotient by this relation.",
    "kind": "inductive",
    "type": "ℕ × K → ℕ × K → Prop"
  },
  {
    "name": "bitvec.ugt",
    "statement": "def bitvec.ugt {n : ℕ} (x y : bitvec n) : Prop",
    "theorem": "{n : ℕ} (x y : bitvec n) : Prop",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "unsigned greater-than proposition",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "algebraic_geometry.is_reduced",
    "statement": "structure algebraic_geometry.is_reduced (X : algebraic_geometry.Scheme) : Prop",
    "theorem": "(X : algebraic_geometry.Scheme) : Prop",
    "args": "(X : algebraic_geometry.Scheme)",
    "doc_string": "A scheme `X` is reduced if all `𝒪ₓ(U)` are reduced.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "right_distrib_class",
    "statement": "structure right_distrib_class (R : Type u_1) [has_mul R] [has_add R] : Type",
    "theorem": "(R : Type u_1) [has_mul R] [has_add R] : Type",
    "args": "(R : Type u_1) [has_mul R] [has_add R]",
    "doc_string": "A typeclass stating that multiplication is right distributive over addition.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "valued.mk'",
    "statement": "def valued.mk' {R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : valued R Γ₀",
    "theorem": "{R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : valued R Γ₀",
    "args": "{R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀)",
    "doc_string": " Alternative `valued` constructor for use when there is no preferred `uniform_space` structure.",
    "kind": "def",
    "type": "valued R Γ₀"
  },
  {
    "name": "add_monoid.is_torsion_free",
    "statement": "def add_monoid.is_torsion_free (G : Type u_1) [add_monoid G] : Prop",
    "theorem": "(G : Type u_1) [add_monoid G] : Prop",
    "args": "(G : Type u_1) [add_monoid G]",
    "doc_string": "A predicate on an additive monoid saying that only 0 is of finite order.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "order.lt_of_pred_lt_pred",
    "statement": "theorem order.lt_of_pred_lt_pred {α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a < order.pred b → a < b",
    "theorem": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a < order.pred b → a < b",
    "args": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α]",
    "doc_string": "**Alias** of the forward direction of order.pred_lt_pred_iff`.",
    "kind": "theorem",
    "type": "order.pred a < order.pred b → a < b"
  },
  {
    "name": "mul_dvd_mul_iff_left",
    "statement": "theorem mul_dvd_mul_iff_left {α : Type u_1} [cancel_monoid_with_zero α] {a b c : α} (ha : a ≠ 0) : a * b ∣ a * c ↔ b ∣ c",
    "theorem": "{α : Type u_1} [cancel_monoid_with_zero α] {a b c : α} (ha : a ≠ 0) : a * b ∣ a * c ↔ b ∣ c",
    "args": "{α : Type u_1} [cancel_monoid_with_zero α] {a b c : α} (ha : a ≠ 0)",
    "doc_string": "Given two elements `b`, `c` of a `cancel_monoid_with_zero` and a nonzero element `a`, `a*b` divides `a*c` iff `b` divides `c`.",
    "kind": "theorem",
    "type": "a * b ∣ a * c ↔ b ∣ c"
  },
  {
    "name": "parser.one_of",
    "statement": "def parser.one_of (cs : list char) : parser char",
    "theorem": "(cs : list char) : parser char",
    "args": "(cs : list char)",
    "doc_string": "Matches one out of a list of characters.",
    "kind": "def",
    "type": "parser char"
  },
  {
    "name": "filter.semigroup",
    "statement": "def filter.semigroup {α : Type u_2} [semigroup α] : semigroup (filter α)",
    "theorem": "{α : Type u_2} [semigroup α] : semigroup (filter α)",
    "args": "{α : Type u_2} [semigroup α]",
    "doc_string": "`filter α` is a `semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "semigroup (filter α)"
  },
  {
    "name": "vadd_comm_class.symm",
    "statement": "theorem vadd_comm_class.symm (M : Type u_1) (N : Type u_2) (α : Type u_3) [has_vadd M α] [has_vadd N α] [vadd_comm_class M N α] : vadd_comm_class N M α",
    "theorem": "(M : Type u_1) (N : Type u_2) (α : Type u_3) [has_vadd M α] [has_vadd N α] [vadd_comm_class M N α] : vadd_comm_class N M α",
    "args": "(M : Type u_1) (N : Type u_2) (α : Type u_3) [has_vadd M α] [has_vadd N α] [vadd_comm_class M N α]",
    "doc_string": " Commutativity of additive actions is a symmetric relation. This lemma can't be an instance because this would cause a loop in the instance search graph.",
    "kind": "theorem",
    "type": "vadd_comm_class N M α"
  },
  {
    "name": "category_theory.projective.over",
    "statement": "def category_theory.projective.over {C : Type u} [category_theory.category C] [category_theory.enough_projectives C] (X : C) : C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.enough_projectives C] (X : C) : C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.enough_projectives C] (X : C)",
    "doc_string": "`projective.over X` provides an arbitrarily chosen projective object equipped with an epimorphism `projective.π : projective.over X ⟶ X`.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "ordnode.size",
    "statement": "def ordnode.size {α : Type u} : ordnode α → ℕ",
    "theorem": "{α : Type u} : ordnode α → ℕ",
    "args": "{α : Type u}",
    "doc_string": "O(1). Get the size of the set.      size {2, 1, 1, 4} = 3",
    "kind": "def",
    "type": "ordnode α → ℕ"
  },
  {
    "name": "pgame.has_mul",
    "statement": "def pgame.has_mul  : has_mul pgame",
    "theorem": " : has_mul pgame",
    "args": "",
    "doc_string": " The product of `x = {xL | xR}` and `y = {yL | yR}` is `{xL*y + x*yL - xL*yL, xR*y + x*yR - xR*yR | xL*y + x*yR - xL*yR, x*yL + xR*y - xR*yL }`.",
    "kind": "def",
    "type": "has_mul pgame"
  },
  {
    "name": "concept",
    "statement": "structure concept (α : Type u_2) (β : Type u_3) (r : α → β → Prop) : Type (max u_2 u_3)",
    "theorem": "(α : Type u_2) (β : Type u_3) (r : α → β → Prop) : Type (max u_2 u_3)",
    "args": "(α : Type u_2) (β : Type u_3) (r : α → β → Prop)",
    "doc_string": " The formal concepts of a relation. A concept of `r : α → β → Prop` is a pair of sets `s`, `t` such that `s` is the set of all elements that are `r`-related to all of `t` and `t` is the set of all elements that are `r`-related to all of `s`.",
    "kind": "structure",
    "type": "Type (max u_2 u_3)"
  },
  {
    "name": "cancel_monoid_with_zero.to_has_faithful_smul",
    "statement": "def cancel_monoid_with_zero.to_has_faithful_smul {α : Type u} [cancel_monoid_with_zero α] [nontrivial α] : has_faithful_smul α α",
    "theorem": "{α : Type u} [cancel_monoid_with_zero α] [nontrivial α] : has_faithful_smul α α",
    "args": "{α : Type u} [cancel_monoid_with_zero α] [nontrivial α]",
    "doc_string": "`monoid.to_mul_action` is faithful on nontrivial cancellative monoids with zero.",
    "kind": "def",
    "type": "has_faithful_smul α α"
  },
  {
    "name": "ordnode.amem",
    "statement": "def ordnode.amem {α : Type u} [has_le α] (x : α) : ordnode α → Prop",
    "theorem": "{α : Type u} [has_le α] (x : α) : ordnode α → Prop",
    "args": "{α : Type u} [has_le α] (x : α)",
    "doc_string": " O(n). Approximate membership in the set, that is, whether some element in the set is equivalent to this one in the preorder. This is useful primarily for stating correctness properties; use `∈` for a version that actually uses the BST property of the tree.      amem 2 {1, 2, 3} = true     amem 4 {1, 2, 3} = false  To see the difference with `emem`, we need a preorder that is not a partial order. For example, suppose we compare pairs of numbers using only their first coordinate. Then:      emem (0, 1) {(0, 0), (1, 2)} = false     amem (0, 1) {(0, 0), (1, 2)} = true     (0, 1) ∈ {(0, 0), (1, 2)} = true  The `∈` relation is equivalent to `amem` as long as the `ordnode` is well formed, and should always be used instead of `amem`.",
    "kind": "def",
    "type": "ordnode α → Prop"
  },
  {
    "name": "category_theory.category",
    "statement": "structure category_theory.category (obj : Type u) : Type (max u (v+1))",
    "theorem": "(obj : Type u) : Type (max u (v+1))",
    "args": "(obj : Type u)",
    "doc_string": "The typeclass `category C` describes morphisms associated to objects of type `C`. The universe levels of the objects and morphisms are unconstrained, and will often need to be specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)  See <https://stacks.math.columbia.edu/tag/0014>.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "monoid.foldl",
    "statement": "def monoid.foldl (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "For a list, foldl f x [y₀,y₁] reduces as follows:  ```lean calc  foldl f x [y₀,y₁]     = foldl f (f x y₀) [y₁]      : rfl ... = foldl f (f (f x y₀) y₁) [] : rfl ... = f (f x y₀) y₁              : rfl ``` with ```lean f : α → β → α x : α [y₀,y₁] : list β ```  We can view the above as a composition of functions: ```lean ... = f (f x y₀) y₁              : rfl ... = flip f y₁ (flip f y₀ x)    : rfl ... = (flip f y₁ ∘ flip f y₀) x  : rfl ```  We can use traverse and const to construct this composition: ```lean calc   const.run (traverse (λ y, const.mk' (flip f y)) [y₀,y₁]) x      = const.run ((::) <$> const.mk' (flip f y₀) <*> traverse (λ y, const.mk' (flip f y)) [y₁]) x ...  = const.run ((::) <$> const.mk' (flip f y₀) <*>          ( (::) <$> const.mk' (flip f y₁) <*> traverse (λ y, const.mk' (flip f y)) [] )) x ...  = const.run ((::) <$> const.mk' (flip f y₀) <*>          ( (::) <$> const.mk' (flip f y₁) <*> pure [] )) x ...  = const.run ( ((::) <$> const.mk' (flip f y₁) <*> pure []) ∘          ((::) <$> const.mk' (flip f y₀)) ) x ...  = const.run ( const.mk' (flip f y₁) ∘ const.mk' (flip f y₀) ) x ...  = const.run ( flip f y₁ ∘ flip f y₀ ) x ...  = f (f x y₀) y₁ ```  And this is how `const` turns a monoid into an applicative functor and how the monoid of endofunctions define `foldl`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "add_hom.with_top_map",
    "statement": "def add_hom.with_top_map {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_hom (with_top M) (with_top N)",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) : add_hom (with_top M) (with_top N)",
    "args": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N)",
    "doc_string": "A version of `with_top.map` for `add_hom`s.",
    "kind": "def",
    "type": "add_hom (with_top M) (with_top N)"
  },
  {
    "name": "finset.property_of_mem_map_subtype",
    "statement": "theorem finset.property_of_mem_map_subtype {α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : a ∈ finset.map (function.embedding.subtype (λ (x : α), p x)) s) : p a",
    "theorem": "{α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : a ∈ finset.map (function.embedding.subtype (λ (x : α), p x)) s) : p a",
    "args": "{α : Type u_1} {p : α → Prop} (s : finset {x // p x}) {a : α} (h : a ∈ finset.map (function.embedding.subtype (λ (x : α), p x)) s)",
    "doc_string": " If a `finset` of a subtype is converted to the main type with `embedding.subtype`, all elements of the result have the property of the subtype.",
    "kind": "theorem",
    "type": "p a"
  },
  {
    "name": "finset.comm_semigroup",
    "statement": "def finset.comm_semigroup {α : Type u_2} [decidable_eq α] [comm_semigroup α] : comm_semigroup (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [comm_semigroup α] : comm_semigroup (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [comm_semigroup α]",
    "doc_string": "`finset α` is a `comm_semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "comm_semigroup (finset α)"
  },
  {
    "name": "CompleteLattice.of",
    "statement": "def CompleteLattice.of (α : Type u_1) [complete_lattice α] : CompleteLattice",
    "theorem": "(α : Type u_1) [complete_lattice α] : CompleteLattice",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": "Construct a bundled `CompleteLattice` from a `complete_lattice`.",
    "kind": "def",
    "type": "CompleteLattice"
  },
  {
    "name": "list.foldl_with_index",
    "statement": "def list.foldl_with_index {α : Type u_1} {β : Type u_2} (f : ℕ → α → β → α) (a : α) (l : list β) : α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : ℕ → α → β → α) (a : α) (l : list β) : α",
    "args": "{α : Type u_1} {β : Type u_2} (f : ℕ → α → β → α) (a : α) (l : list β)",
    "doc_string": " Fold a list from left to right as with `foldl`, but the combining function also receives each element's index.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "subring.pointwise_mul_action",
    "statement": "def subring.pointwise_mul_action {M : Type u_1} {R : Type u_2} [monoid M] [ring R] [mul_semiring_action M R] : mul_action M (subring R)",
    "theorem": "{M : Type u_1} {R : Type u_2} [monoid M] [ring R] [mul_semiring_action M R] : mul_action M (subring R)",
    "args": "{M : Type u_1} {R : Type u_2} [monoid M] [ring R] [mul_semiring_action M R]",
    "doc_string": " The action on a subring corresponding to applying the action to every element.  This is available as an instance in the `pointwise` locale.",
    "kind": "def",
    "type": "mul_action M (subring R)"
  },
  {
    "name": "ordnode.fold",
    "statement": "def ordnode.fold {α : Type u} {β : Sort u_1} (z : β) (f : β → α → β → β) : ordnode α → β",
    "theorem": "{α : Type u} {β : Sort u_1} (z : β) (f : β → α → β → β) : ordnode α → β",
    "args": "{α : Type u} {β : Sort u_1} (z : β) (f : β → α → β → β)",
    "doc_string": " O(n). Fold a function across the structure of a tree.       fold z f {1, 2, 4} = f (f z 1 z) 2 (f z 4 z)  The exact structure of function applications depends on the tree and so is unspecified.",
    "kind": "def",
    "type": "ordnode α → β"
  },
  {
    "name": "inf_top_hom.id",
    "statement": "def inf_top_hom.id (α : Type u_3) [has_inf α] [has_top α] : inf_top_hom α α",
    "theorem": "(α : Type u_3) [has_inf α] [has_top α] : inf_top_hom α α",
    "args": "(α : Type u_3) [has_inf α] [has_top α]",
    "doc_string": "`id` as an `inf_top_hom`.",
    "kind": "def",
    "type": "inf_top_hom α α"
  },
  {
    "name": "power_series.mk",
    "statement": "def power_series.mk {R : Type u_1} (f : ℕ → R) : power_series R",
    "theorem": "{R : Type u_1} (f : ℕ → R) : power_series R",
    "args": "{R : Type u_1} (f : ℕ → R)",
    "doc_string": "Constructor for formal power series.",
    "kind": "def",
    "type": "power_series R"
  },
  {
    "name": "seq1.ret",
    "statement": "def seq1.ret {α : Type u} (a : α) : seq1 α",
    "theorem": "{α : Type u} (a : α) : seq1 α",
    "args": "{α : Type u} (a : α)",
    "doc_string": "The `return` operator for the `seq1` monad,  which produces a singleton sequence.",
    "kind": "def",
    "type": "seq1 α"
  },
  {
    "name": "tactic.impl_graph",
    "statement": "def tactic.impl_graph  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "mutable graphs between local propositions that imply each other with the proof of implication",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "ordnode.split3",
    "statement": "def ordnode.split3 {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α × option α × ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α × option α × ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": " O(log n). Split the tree into those smaller than `x` and those greater than it, plus an element equivalent to `x`, if it exists.      split 2 {1, 2, 4} = ({1}, some 2, {4})     split 3 {1, 2, 4} = ({1, 2}, none, {4})     split 4 {1, 2, 4} = ({1, 2}, some 4, ∅)  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      split (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, some (1, 2), ∅)     split (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, none, ∅)",
    "kind": "def",
    "type": "ordnode α → ordnode α × option α × ordnode α"
  },
  {
    "name": "subsemigroup.ext",
    "statement": "theorem subsemigroup.ext {M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T",
    "theorem": "{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T) : S = T",
    "args": "{M : Type u_1} [has_mul M] {S T : subsemigroup M} (h : ∀ (x : M), x ∈ S ↔ x ∈ T)",
    "doc_string": "Two subsemigroups are equal if they have the same elements.",
    "kind": "theorem",
    "type": "S = T"
  },
  {
    "name": "relation.game_add",
    "statement": "inductive relation.game_add {α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) : α × β → α × β → Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop) : α × β → α × β → Prop",
    "args": "{α : Type u_1} {β : Type u_2} (rα : α → α → Prop) (rβ : β → β → Prop)",
    "doc_string": "The \"addition of games\" relation in combinatorial game theory, on the product type: if  `rα a' a` means that `a ⟶ a'` is a valid move in game `α`, and `rβ b' b` means that `b ⟶ b'`  is a valid move in game `β`, then `game_add rα rβ` specifies the valid moves in the juxtaposition  of `α` and `β`: the player is free to choose one of the games and make a move in it,  while leaving the other game unchanged.",
    "kind": "inductive",
    "type": "α × β → α × β → Prop"
  },
  {
    "name": "galois_insertion.lift_bounded_order",
    "statement": "def galois_insertion.lift_bounded_order {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [preorder α] [bounded_order α] (gi : galois_insertion l u) : bounded_order β",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [preorder α] [bounded_order α] (gi : galois_insertion l u) : bounded_order β",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [preorder α] [bounded_order α] (gi : galois_insertion l u)",
    "doc_string": "Lift the top, bottom, suprema, and infima along a Galois insertion",
    "kind": "def",
    "type": "bounded_order β"
  },
  {
    "name": "turing.list_blank.mk",
    "statement": "def turing.list_blank.mk {Γ : Type u_1} [inhabited Γ] : list Γ → turing.list_blank Γ",
    "theorem": "{Γ : Type u_1} [inhabited Γ] : list Γ → turing.list_blank Γ",
    "args": "{Γ : Type u_1} [inhabited Γ]",
    "doc_string": "The quotient map turning a `list` into a `list_blank`.",
    "kind": "def",
    "type": "list Γ → turing.list_blank Γ"
  },
  {
    "name": "primcodable",
    "statement": "structure primcodable (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A `primcodable` type is an `encodable` type for which  the encode/decode functions are primitive recursive.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "is_unit.dvd_mul_left",
    "statement": "theorem is_unit.dvd_mul_left {α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : a ∣ u * b ↔ a ∣ b",
    "theorem": "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : a ∣ u * b ↔ a ∣ b",
    "args": "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u)",
    "doc_string": "In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left    associates of `b`.",
    "kind": "theorem",
    "type": "a ∣ u * b ↔ a ∣ b"
  },
  {
    "name": "nonote.opow",
    "statement": "def nonote.opow (x y : nonote) : nonote",
    "theorem": "(x y : nonote) : nonote",
    "args": "(x y : nonote)",
    "doc_string": "Exponentiation of ordinal notations",
    "kind": "def",
    "type": "nonote"
  },
  {
    "name": "zero_lt.preorder.left.one_le_mul_of_le_of_le",
    "statement": "theorem zero_lt.preorder.left.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "1 ≤ a * b"
  },
  {
    "name": "hash_map.insert_all",
    "statement": "def hash_map.insert_all {α : Type u} {β : α → Type v} [decidable_eq α] (l : list (Σ (a : α), β a)) (m : hash_map α β) : hash_map α β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (l : list (Σ (a : α), β a)) (m : hash_map α β) : hash_map α β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (l : list (Σ (a : α), β a)) (m : hash_map α β)",
    "doc_string": "Insert a list of key-value pairs into the map. (Modifies `m` in-place when applicable)",
    "kind": "def",
    "type": "hash_map α β"
  },
  {
    "name": "pos_num.of_nat",
    "statement": "def pos_num.of_nat (n : ℕ) : pos_num",
    "theorem": "(n : ℕ) : pos_num",
    "args": "(n : ℕ)",
    "doc_string": "`of_nat n` is the `pos_num` corresponding to `n`, except for `of_nat 0 = 1`.",
    "kind": "def",
    "type": "pos_num"
  },
  {
    "name": "matrix.block_triangular_matrix'",
    "statement": "def matrix.block_triangular_matrix' {R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) {n : ℕ} (b : o → fin n) : Prop",
    "theorem": "{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) {n : ℕ} (b : o → fin n) : Prop",
    "args": "{R : Type v} [comm_ring R] {o : Type u_1} (M : matrix o o R) {n : ℕ} (b : o → fin n)",
    "doc_string": "Let `b` map rows and columns of a square matrix `M` to `n` blocks. Then  `block_triangular_matrix' M n b` says the matrix is block triangular.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_nonstrict_strict_order",
    "statement": "structure is_nonstrict_strict_order (α : Type u_1) (r s : α → α → Prop) : Type",
    "theorem": "(α : Type u_1) (r s : α → α → Prop) : Type",
    "args": "(α : Type u_1) (r s : α → α → Prop)",
    "doc_string": " An unbundled relation class stating that `r` is the nonstrict relation corresponding to the strict relation `s`. Compare `preorder.lt_iff_le_not_le`. This is mostly meant to provide dot notation on `(⊆)` and `(⊂)`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "dense.inter_of_open_left",
    "statement": "theorem dense.inter_of_open_left {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t)",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t)",
    "args": "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s)",
    "doc_string": "The intersection of an open dense set with a dense set is a dense set.",
    "kind": "theorem",
    "type": "dense (s ∩ t)"
  },
  {
    "name": "fintype.to_complete_linear_order",
    "statement": "def fintype.to_complete_linear_order (α : Type u_2) [fintype α] [linear_order α] [bounded_order α] : complete_linear_order α",
    "theorem": "(α : Type u_2) [fintype α] [linear_order α] [bounded_order α] : complete_linear_order α",
    "args": "(α : Type u_2) [fintype α] [linear_order α] [bounded_order α]",
    "doc_string": "A finite bounded linear order is complete.",
    "kind": "def",
    "type": "complete_linear_order α"
  },
  {
    "name": "open_embedding.singleton_charted_space",
    "statement": "def open_embedding.singleton_charted_space {H : Type u} [topological_space H] {α : Type u_5} [topological_space α] [nonempty α] {f : α → H} (h : open_embedding f) : charted_space H α",
    "theorem": "{H : Type u} [topological_space H] {α : Type u_5} [topological_space α] [nonempty α] {f : α → H} (h : open_embedding f) : charted_space H α",
    "args": "{H : Type u} [topological_space H] {α : Type u_5} [topological_space α] [nonempty α] {f : α → H} (h : open_embedding f)",
    "doc_string": " An open embedding of `α` into `H` induces an `H`-charted space structure on `α`. See `local_homeomorph.singleton_charted_space`",
    "kind": "def",
    "type": "charted_space H α"
  },
  {
    "name": "fundamental_groupoid",
    "statement": "def fundamental_groupoid (X : Type u) : Type u",
    "theorem": "(X : Type u) : Type u",
    "args": "(X : Type u)",
    "doc_string": "The fundamental groupoid of a space `X` is defined to be a type synonym for `X`, and we subsequently put a `category_theory.groupoid` structure on it.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "two_pointing.Twop",
    "statement": "def two_pointing.Twop {X : Type u_1} (to_two_pointing : two_pointing X) : Twop",
    "theorem": "{X : Type u_1} (to_two_pointing : two_pointing X) : Twop",
    "args": "{X : Type u_1} (to_two_pointing : two_pointing X)",
    "doc_string": "**Alias** of Twop.of`.",
    "kind": "def",
    "type": "Twop"
  },
  {
    "name": "onote.has_one",
    "statement": "def onote.has_one  : has_one onote",
    "theorem": " : has_one onote",
    "args": "",
    "doc_string": "Notation for 1",
    "kind": "def",
    "type": "has_one onote"
  },
  {
    "name": "sym.has_lift",
    "statement": "def sym.has_lift {α : Type u_1} {n : ℕ} : has_lift (vector α n) (sym α n)",
    "theorem": "{α : Type u_1} {n : ℕ} : has_lift (vector α n) (sym α n)",
    "args": "{α : Type u_1} {n : ℕ}",
    "doc_string": "This is the quotient map that takes a list of n elements as an n-tuple and produces an nth symmetric power.",
    "kind": "def",
    "type": "has_lift (vector α n) (sym α n)"
  },
  {
    "name": "quiver.total",
    "statement": "structure quiver.total (V : Type u) [quiver V] : Sort (max (u+1) v)",
    "theorem": "(V : Type u) [quiver V] : Sort (max (u+1) v)",
    "args": "(V : Type u) [quiver V]",
    "doc_string": "`total V` is the type of _all_ arrows of `V`.",
    "kind": "structure",
    "type": "Sort (max (u+1) v)"
  },
  {
    "name": "add_semiconj_by",
    "statement": "def add_semiconj_by {M : Type u} [has_add M] (a x y : M) : Prop",
    "theorem": "{M : Type u} [has_add M] (a x y : M) : Prop",
    "args": "{M : Type u} [has_add M] (a x y : M)",
    "doc_string": "`x` is additive semiconjugate to `y` by `a` if `a + x = y + a`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.discrete_sieve",
    "statement": "def category_theory.discrete_sieve (α : Type u) : category_theory.sieve α",
    "theorem": "(α : Type u) : category_theory.sieve α",
    "args": "(α : Type u)",
    "doc_string": "The discrete sieve on a type, which only includes arrows whose image is a subsingleton.",
    "kind": "def",
    "type": "category_theory.sieve α"
  },
  {
    "name": "composition.blocks_fun",
    "statement": "def composition.blocks_fun {n : ℕ} (c : composition n) : fin c.length → ℕ",
    "theorem": "{n : ℕ} (c : composition n) : fin c.length → ℕ",
    "args": "{n : ℕ} (c : composition n)",
    "doc_string": " The blocks of a composition, seen as a function on `fin c.length`. When composing analytic functions using compositions, this is the main player.",
    "kind": "def",
    "type": "fin c.length → ℕ"
  },
  {
    "name": "list.argmax",
    "statement": "def list.argmax {α : Type u_1} {β : Type u_2} [preorder β] [decidable_rel has_lt.lt] (f : α → β) (l : list α) : option α",
    "theorem": "{α : Type u_1} {β : Type u_2} [preorder β] [decidable_rel has_lt.lt] (f : α → β) (l : list α) : option α",
    "args": "{α : Type u_1} {β : Type u_2} [preorder β] [decidable_rel has_lt.lt] (f : α → β) (l : list α)",
    "doc_string": " `argmax f l` returns `some a`, where `f a` is maximal among the elements of `l`, in the sense that there is no `b ∈ l` with `f a < f b`. If `a`, `b` are such that `f a = f b`, it returns whichever of `a` or `b` comes first in the list. `argmax f []` = none`.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "doset.setoid",
    "statement": "def doset.setoid {G : Type u_1} [group G] (H K : set G) : setoid G",
    "theorem": "{G : Type u_1} [group G] (H K : set G) : setoid G",
    "args": "{G : Type u_1} [group G] (H K : set G)",
    "doc_string": "The setoid defined by the double_coset relation",
    "kind": "def",
    "type": "setoid G"
  },
  {
    "name": "ordinal.is_limit",
    "statement": "def ordinal.is_limit (o : ordinal) : Prop",
    "theorem": "(o : ordinal) : Prop",
    "args": "(o : ordinal)",
    "doc_string": "A limit ordinal is an ordinal which is not zero and not a successor.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_semiconj_by.zero_right",
    "statement": "theorem add_semiconj_by.zero_right {M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0",
    "theorem": "{M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0",
    "args": "{M : Type u} [add_zero_class M] (a : M)",
    "doc_string": "Any element additively semiconjugates `0` to `0`.",
    "kind": "theorem",
    "type": "add_semiconj_by a 0 0"
  },
  {
    "name": "list.split_on_p_aux'",
    "statement": "def list.split_on_p_aux' {α : Type u} (P : α → Prop) [decidable_pred P] : list α → list α → list (list α)",
    "theorem": "{α : Type u} (P : α → Prop) [decidable_pred P] : list α → list α → list (list α)",
    "args": "{α : Type u} (P : α → Prop) [decidable_pred P]",
    "doc_string": " An auxiliary definition for proving a specification lemma for `split_on_p`.  `split_on_p_aux' P xs ys` splits the list `ys ++ xs` at every element satisfying `P`, where `ys` is an accumulating parameter for the initial segment of elements not satisfying `P`.",
    "kind": "def",
    "type": "list α → list α → list (list α)"
  },
  {
    "name": "function.fixed_points",
    "statement": "def function.fixed_points {α : Type u} (f : α → α) : set α",
    "theorem": "{α : Type u} (f : α → α) : set α",
    "args": "{α : Type u} (f : α → α)",
    "doc_string": "The set of fixed points of a map `f : α → α`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "out_param",
    "statement": "def out_param (α : Sort u) : Sort u",
    "theorem": "(α : Sort u) : Sort u",
    "args": "(α : Sort u)",
    "doc_string": "Gadget for marking output parameters in type classes.",
    "kind": "def",
    "type": "Sort u"
  },
  {
    "name": "power_series",
    "statement": "def power_series (R : Type u_1) : Type u_1",
    "theorem": "(R : Type u_1) : Type u_1",
    "args": "(R : Type u_1)",
    "doc_string": "Formal power series over the coefficient ring `R`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "decidable_of_iff",
    "statement": "def decidable_of_iff {b : Prop} (a : Prop) (h : a ↔ b) [D : decidable a] : decidable b",
    "theorem": "{b : Prop} (a : Prop) (h : a ↔ b) [D : decidable a] : decidable b",
    "args": "{b : Prop} (a : Prop) (h : a ↔ b) [D : decidable a]",
    "doc_string": " Transfer decidability of `a` to decidability of `b`, if the propositions are equivalent. **Important**: this function should be used instead of `rw` on `decidable b`, because the kernel will get stuck reducing the usage of `propext` otherwise, and `dec_trivial` will not work.",
    "kind": "def",
    "type": "decidable b"
  },
  {
    "name": "submodule.torsion_by",
    "statement": "def submodule.torsion_by (R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : submodule R M",
    "theorem": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : submodule R M",
    "args": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R)",
    "doc_string": "The `a`-torsion submodule for `a` in `R`, containing all elements `x` of `M` such that  `a • x = 0`.",
    "kind": "def",
    "type": "submodule R M"
  },
  {
    "name": "measure_theory.simple_func.map",
    "statement": "def measure_theory.simple_func.map {α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (g : β → γ) (f : measure_theory.simple_func α β) : measure_theory.simple_func α γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (g : β → γ) (f : measure_theory.simple_func α β) : measure_theory.simple_func α γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (g : β → γ) (f : measure_theory.simple_func α β)",
    "doc_string": "Given a function `g : β → γ` and a simple function `f : α →ₛ β`, `f.map g` return the simple    function `g ∘ f : α →ₛ γ`",
    "kind": "def",
    "type": "measure_theory.simple_func α γ"
  },
  {
    "name": "zero_lt.left.one_le_mul_of_le_of_le",
    "statement": "theorem zero_lt.left.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a) : 1 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a) : 1 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "1 ≤ a * b"
  },
  {
    "name": "strict_mono",
    "statement": "def strict_mono {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β)",
    "doc_string": "A function `f` is strictly monotone if `a < b` implies `f a < f b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.grothendieck_topology.closure_operator",
    "statement": "def category_theory.grothendieck_topology.closure_operator {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) (X : C) : closure_operator (category_theory.sieve X)",
    "theorem": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) (X : C) : closure_operator (category_theory.sieve X)",
    "args": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) (X : C)",
    "doc_string": "A Grothendieck topology induces a natural family of closure operators on sieves.",
    "kind": "def",
    "type": "closure_operator (category_theory.sieve X)"
  },
  {
    "name": "right.add_nonneg",
    "statement": "theorem right.add_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_nonneg`.",
    "kind": "theorem",
    "type": "0 ≤ a + b"
  },
  {
    "name": "free_abelian_group",
    "statement": "def free_abelian_group (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "The free abelian group on a type.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "list.cyclic_permutations",
    "statement": "def list.cyclic_permutations {α : Type u} : list α → list (list α)",
    "theorem": "{α : Type u} : list α → list (list α)",
    "args": "{α : Type u}",
    "doc_string": " List of all cyclic permutations of `l`. The `cyclic_permutations` of a nonempty list `l` will always contain `list.length l` elements. This implies that under certain conditions, there are duplicates in `list.cyclic_permutations l`. The `n`th entry is equal to `l.rotate n`, proven in `list.nth_le_cyclic_permutations`. The proof that every cyclic permutant of `l` is in the list is `list.mem_cyclic_permutations_iff`.       cyclic_permutations [1, 2, 3, 2, 4] =        [[1, 2, 3, 2, 4], [2, 3, 2, 4, 1], [3, 2, 4, 1, 2],         [2, 4, 1, 2, 3], [4, 1, 2, 3, 2]]",
    "kind": "def",
    "type": "list α → list (list α)"
  },
  {
    "name": "mul_distrib_mul_action",
    "statement": "structure mul_distrib_mul_action (M : Type u_10) (A : Type u_11) [monoid M] [monoid A] : Type (max u_10 u_11)",
    "theorem": "(M : Type u_10) (A : Type u_11) [monoid M] [monoid A] : Type (max u_10 u_11)",
    "args": "(M : Type u_10) (A : Type u_11) [monoid M] [monoid A]",
    "doc_string": " Typeclass for multiplicative actions on multiplicative structures. This generalizes conjugation actions.",
    "kind": "structure",
    "type": "Type (max u_10 u_11)"
  },
  {
    "name": "holder_with",
    "statement": "def holder_with {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X → Y) : Prop",
    "theorem": "{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X → Y) : Prop",
    "args": "{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X → Y)",
    "doc_string": " A function `f : X → Y` between two `pseudo_emetric_space`s is Hölder continuous with constant `C : ℝ≥0` and exponent `r : ℝ≥0`, if `edist (f x) (f y) ≤ C * edist x y ^ r` for all `x y : X`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "submonoid.one_mem",
    "statement": "theorem submonoid.one_mem {M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 ∈ S",
    "theorem": "{M : Type u_1} [mul_one_class M] (S : submonoid M) : 1 ∈ S",
    "args": "{M : Type u_1} [mul_one_class M] (S : submonoid M)",
    "doc_string": "A submonoid contains the monoid's 1.",
    "kind": "theorem",
    "type": "1 ∈ S"
  },
  {
    "name": "add_submonoid.copy",
    "statement": "def add_submonoid.copy {M : Type u_1} [add_zero_class M] (S : add_submonoid M) (s : set M) (hs : s = ↑S) : add_submonoid M",
    "theorem": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M) (s : set M) (hs : s = ↑S) : add_submonoid M",
    "args": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M) (s : set M) (hs : s = ↑S)",
    "doc_string": "Copy an additive submonoid replacing `carrier` with a set that is equal to it.",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "tactic.ring2.correctness",
    "statement": "theorem tactic.ring2.correctness {α : Type u_1} [comm_semiring α] (t : tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂) : tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂",
    "theorem": "{α : Type u_1} [comm_semiring α] (t : tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂) : tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂",
    "args": "{α : Type u_1} [comm_semiring α] (t : tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂)",
    "doc_string": " The main proof-by-reflection theorem. Given reflected csring expressions `r₁` and `r₂` plus a storage `t` of atoms, if both expressions go to the same Horner normal form, then the original non-reflected expressions are equal. `H` follows from kernel reduction and is therefore `rfl`.",
    "kind": "theorem",
    "type": "tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂"
  },
  {
    "name": "commensurable.commensurator'",
    "statement": "def commensurable.commensurator' {G : Type u_1} [group G] (H : subgroup G) : subgroup (conj_act G)",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : subgroup (conj_act G)",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": " For `H` a subgroup of `G`, this is the subgroup of all elements `g : conj_aut G` such that `commensurable (g • H) H`",
    "kind": "def",
    "type": "subgroup (conj_act G)"
  },
  {
    "name": "computation.lmap",
    "statement": "def computation.lmap {α : Type u} {β : Type v} {γ : Type w} (f : α → β) : α ⊕ γ → β ⊕ γ",
    "theorem": "{α : Type u} {β : Type v} {γ : Type w} (f : α → β) : α ⊕ γ → β ⊕ γ",
    "args": "{α : Type u} {β : Type v} {γ : Type w} (f : α → β)",
    "doc_string": "left map of `⊕`",
    "kind": "def",
    "type": "α ⊕ γ → β ⊕ γ"
  },
  {
    "name": "is_nilpotent_pi",
    "statement": "def is_nilpotent_pi {η : Type u_2} [fintype η] {Gs : η → Type u_3} [Π (i : η), group (Gs i)] [∀ (i : η), group.is_nilpotent (Gs i)] : group.is_nilpotent (Π (i : η), Gs i)",
    "theorem": "{η : Type u_2} [fintype η] {Gs : η → Type u_3} [Π (i : η), group (Gs i)] [∀ (i : η), group.is_nilpotent (Gs i)] : group.is_nilpotent (Π (i : η), Gs i)",
    "args": "{η : Type u_2} [fintype η] {Gs : η → Type u_3} [Π (i : η), group (Gs i)] [∀ (i : η), group.is_nilpotent (Gs i)]",
    "doc_string": "n-ary products of nilpotent groups are nilpotent",
    "kind": "def",
    "type": "group.is_nilpotent (Π (i : η), Gs i)"
  },
  {
    "name": "comm_monoid",
    "statement": "structure comm_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": "A commutative monoid is a monoid with commutative `(*)`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization",
    "statement": "theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R",
    "theorem": "{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R",
    "args": "{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R)",
    "doc_string": "An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring.",
    "kind": "theorem",
    "type": "discrete_valuation_ring R"
  },
  {
    "name": "monoid.is_torsion",
    "statement": "def monoid.is_torsion (G : Type u_1) [monoid G] : Prop",
    "theorem": "(G : Type u_1) [monoid G] : Prop",
    "args": "(G : Type u_1) [monoid G]",
    "doc_string": "A predicate on a monoid saying that all elements are of finite order.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "Locale.of",
    "statement": "def Locale.of (α : Type u_1) [order.frame α] : Locale",
    "theorem": "(α : Type u_1) [order.frame α] : Locale",
    "args": "(α : Type u_1) [order.frame α]",
    "doc_string": "Construct a bundled `Locale` from a `frame`.",
    "kind": "def",
    "type": "Locale"
  },
  {
    "name": "ring.two_ne_zero",
    "statement": "theorem ring.two_ne_zero {R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0",
    "theorem": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0",
    "args": "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2)",
    "doc_string": "We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`.",
    "kind": "theorem",
    "type": "2 ≠ 0"
  },
  {
    "name": "category_theory.enough_injectives",
    "statement": "structure category_theory.enough_injectives (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": " A category \"has enough injectives\" if every object has an injective presentation, i.e. if for every object `X` there is an injective object `J` and a monomorphism `X ↪ J`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "has_repr",
    "statement": "structure has_repr (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Implement `has_repr` if the output string is valid lean code that evaluates back to the original object. If you just want to view the object as a string for a trace message, use `has_to_string`.  ### Example:  ```lean #eval to_string \"hello world\" -- [Lean] \"hello world\" #eval repr \"hello world\" -- [Lean] \"\\\"hello world\\\"\" ```  Reference: https://github.com/leanprover/lean/issues/1664",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "ne_zero",
    "statement": "structure ne_zero {R : Type u_1} [has_zero R] (n : R) : Prop",
    "theorem": "{R : Type u_1} [has_zero R] (n : R) : Prop",
    "args": "{R : Type u_1} [has_zero R] (n : R)",
    "doc_string": "A type-class version of `n ≠ 0`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "measurable_space.dynkin_system",
    "statement": "structure measurable_space.dynkin_system (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A Dynkin system is a collection of subsets of a type `α` that contains the empty set,  is closed under complementation and under countable union of pairwise disjoint sets.  The disjointness condition is the only difference with `σ`-algebras.   The main purpose of Dynkin systems is to provide a powerful induction rule for σ-algebras  generated by a collection of sets which is stable under intersection.   A Dynkin system is also known as a \"λ-system\" or a \"d-system\".",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "bitvec.sge",
    "statement": "def bitvec.sge {n : ℕ} (x y : bitvec n) : Prop",
    "theorem": "{n : ℕ} (x y : bitvec n) : Prop",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "signed greater-than-or-equal-to proposition",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.of_fn_nth_val",
    "statement": "def list.of_fn_nth_val {α : Type u_1} {n : ℕ} (f : fin n → α) (i : ℕ) : option α",
    "theorem": "{α : Type u_1} {n : ℕ} (f : fin n → α) (i : ℕ) : option α",
    "args": "{α : Type u_1} {n : ℕ} (f : fin n → α) (i : ℕ)",
    "doc_string": "`of_fn_nth_val f i` returns `some (f i)` if `i < n` and `none` otherwise.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "pochhammer",
    "statement": "def pochhammer (S : Type u) [semiring S] : ℕ → polynomial S",
    "theorem": "(S : Type u) [semiring S] : ℕ → polynomial S",
    "args": "(S : Type u) [semiring S]",
    "doc_string": "`pochhammer S n` is the polynomial `X * (X+1) * ... * (X + n - 1)`, with coefficients in the semiring `S`.",
    "kind": "def",
    "type": "ℕ → polynomial S"
  },
  {
    "name": "bitvec.mul",
    "statement": "def bitvec.mul {n : ℕ} (x y : bitvec n) : bitvec n",
    "theorem": "{n : ℕ} (x y : bitvec n) : bitvec n",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "The product of two bitvectors",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "list.ilast'",
    "statement": "def list.ilast' {α : Type u_1} : α → list α → α",
    "theorem": "{α : Type u_1} : α → list α → α",
    "args": "{α : Type u_1}",
    "doc_string": " `ilast' x xs` returns the last element of `xs` if `xs` is non-empty; it returns `x` otherwise",
    "kind": "def",
    "type": "α → list α → α"
  },
  {
    "name": "has_involutive_neg",
    "statement": "structure has_involutive_neg (A : Type u_2) : Type u_2",
    "theorem": "(A : Type u_2) : Type u_2",
    "args": "(A : Type u_2)",
    "doc_string": "Auxiliary typeclass for types with an involutive `has_neg`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "list.of_fn_zero",
    "statement": "theorem list.of_fn_zero {α : Type u} (f : fin 0 → α) : list.of_fn f = list.nil",
    "theorem": "{α : Type u} (f : fin 0 → α) : list.of_fn f = list.nil",
    "args": "{α : Type u} (f : fin 0 → α)",
    "doc_string": "`of_fn` on an empty domain is the empty list.",
    "kind": "theorem",
    "type": "list.of_fn f = list.nil"
  },
  {
    "name": "set.definable₁",
    "statement": "def set.definable₁ {M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set M) : Prop",
    "theorem": "{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set M) : Prop",
    "args": "{M : Type w} (A : set M) (L : first_order.language) [L.Structure M] (s : set M)",
    "doc_string": "A 1-dimensional version of `definable`, for `set M`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "semi_normed_comm_ring",
    "statement": "structure semi_normed_comm_ring (α : Type u_5) : Type u_5",
    "theorem": "(α : Type u_5) : Type u_5",
    "args": "(α : Type u_5)",
    "doc_string": " A seminormed commutative ring is a commutative ring endowed with a seminorm which satisfies the inequality `∥x y∥ ≤ ∥x∥ ∥y∥`.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "is_unit.mul_left_dvd",
    "statement": "theorem is_unit.mul_left_dvd {α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : u * a ∣ b ↔ a ∣ b",
    "theorem": "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : u * a ∣ b ↔ a ∣ b",
    "args": "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u)",
    "doc_string": "In a commutative monoid, an element `a` divides an element `b` iff all  left associates of `a` divide `b`.",
    "kind": "theorem",
    "type": "u * a ∣ b ↔ a ∣ b"
  },
  {
    "name": "has_variable_names.make_inheriting_instance",
    "statement": "def has_variable_names.make_inheriting_instance (α : Sort u) [has_variable_names α] {β : Sort v} : has_variable_names β",
    "theorem": "(α : Sort u) [has_variable_names α] {β : Sort v} : has_variable_names β",
    "args": "(α : Sort u) [has_variable_names α] {β : Sort v}",
    "doc_string": "`@make_inheriting_instance α _ β` creates an instance `has_variable_names β` from an instance `has_variable_names α`. The generated instance contains the same variable names as that of `α`. This can be used to create instances for 'wrapper' types like `option` and `subtype`.",
    "kind": "def",
    "type": "has_variable_names β"
  },
  {
    "name": "io.run_rand_with",
    "statement": "def io.run_rand_with {α : Type} (seed : ℕ) (cmd : rand α) : io α",
    "theorem": "{α : Type} (seed : ℕ) (cmd : rand α) : io α",
    "args": "{α : Type} (seed : ℕ) (cmd : rand α)",
    "doc_string": "Run `cmd` using the provided seed.",
    "kind": "def",
    "type": "io α"
  },
  {
    "name": "widget.local_collection",
    "statement": "structure widget.local_collection  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A group of local constants in the context that should be rendered as one line.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "bxor",
    "statement": "def bxor  : bool → bool → bool",
    "theorem": " : bool → bool → bool",
    "args": "",
    "doc_string": "Boolean XOR",
    "kind": "def",
    "type": "bool → bool → bool"
  },
  {
    "name": "add_subgroup.ext",
    "statement": "theorem add_subgroup.ext {G : Type u_1} [add_group G] {H K : add_subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K",
    "theorem": "{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K",
    "args": "{G : Type u_1} [add_group G] {H K : add_subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K)",
    "doc_string": "Two `add_subgroup`s are equal if they have the same elements.",
    "kind": "theorem",
    "type": "H = K"
  },
  {
    "name": "real.not_summable_nat_cast_inv",
    "statement": "theorem real.not_summable_nat_cast_inv  : ¬summable (λ (n : ℕ), (↑n)⁻¹)",
    "theorem": " : ¬summable (λ (n : ℕ), (↑n)⁻¹)",
    "args": "",
    "doc_string": "Harmonic series is not unconditionally summable.",
    "kind": "theorem",
    "type": "¬summable (λ (n : ℕ), (↑n)⁻¹)"
  },
  {
    "name": "category_theory.limits.terminal_op_of_initial",
    "statement": "def category_theory.limits.terminal_op_of_initial {C : Type u₁} [category_theory.category C] {X : C} (t : category_theory.limits.is_initial X) : category_theory.limits.is_terminal (opposite.op X)",
    "theorem": "{C : Type u₁} [category_theory.category C] {X : C} (t : category_theory.limits.is_initial X) : category_theory.limits.is_terminal (opposite.op X)",
    "args": "{C : Type u₁} [category_theory.category C] {X : C} (t : category_theory.limits.is_initial X)",
    "doc_string": "An initial object is terminal in the opposite category.",
    "kind": "def",
    "type": "category_theory.limits.is_terminal (opposite.op X)"
  },
  {
    "name": "pfunctor.M.agree'",
    "statement": "inductive pfunctor.M.agree' {F : pfunctor} : ℕ → F.M → F.M → Prop",
    "theorem": "{F : pfunctor} : ℕ → F.M → F.M → Prop",
    "args": "{F : pfunctor}",
    "doc_string": " `agree' n` relates two trees of type `M F` that are the same up to dept `n`",
    "kind": "inductive",
    "type": "ℕ → F.M → F.M → Prop"
  },
  {
    "name": "char_eq_exp_char_iff",
    "statement": "theorem char_eq_exp_char_iff (R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q] : p = q ↔ nat.prime p",
    "theorem": "(R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q] : p = q ↔ nat.prime p",
    "args": "(R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q]",
    "doc_string": "The characteristic equals the exponential characteristic iff the former is prime.",
    "kind": "theorem",
    "type": "p = q ↔ nat.prime p"
  },
  {
    "name": "category_theory.simple_of_is_simple_order_subobject",
    "statement": "theorem category_theory.simple_of_is_simple_order_subobject {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)]",
    "doc_string": "If `X` has subobject lattice `{⊥, ⊤}`, then `X` is simple.",
    "kind": "theorem",
    "type": "category_theory.simple X"
  },
  {
    "name": "game.fuzzy",
    "statement": "def game.fuzzy  : game → game → Prop",
    "theorem": " : game → game → Prop",
    "args": "",
    "doc_string": " The fuzzy, confused, or incomparable relation on games.  If `x ∥ 0`, then the first player can always win `x`.",
    "kind": "def",
    "type": "game → game → Prop"
  },
  {
    "name": "linear_map.apply_has_faithful_smul",
    "statement": "def linear_map.apply_has_faithful_smul {R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : has_faithful_smul (module.End R M) M",
    "theorem": "{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M] : has_faithful_smul (module.End R M) M",
    "args": "{R : Type u_1} {M : Type u_9} [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "`linear_map.apply_module` is faithful.",
    "kind": "def",
    "type": "has_faithful_smul (module.End R M) M"
  },
  {
    "name": "set.add_monoid",
    "statement": "def set.add_monoid {α : Type u_2} [add_monoid α] : add_monoid (set α)",
    "theorem": "{α : Type u_2} [add_monoid α] : add_monoid (set α)",
    "args": "{α : Type u_2} [add_monoid α]",
    "doc_string": "`set α` is an `add_monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_monoid (set α)"
  },
  {
    "name": "class_group",
    "statement": "def class_group (R : Type u_1) (K : Type u_2) [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] : Type u_2",
    "theorem": "(R : Type u_1) (K : Type u_2) [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] : Type u_2",
    "args": "(R : Type u_1) (K : Type u_2) [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K]",
    "doc_string": " The ideal class group of `R` in a field of fractions `K` is the group of invertible fractional ideals modulo the principal ideals.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "add_subgroup.zmultiples",
    "statement": "def add_subgroup.zmultiples {A : Type u_2} [add_group A] (a : A) : add_subgroup A",
    "theorem": "{A : Type u_2} [add_group A] (a : A) : add_subgroup A",
    "args": "{A : Type u_2} [add_group A] (a : A)",
    "doc_string": "The subgroup generated by an element.",
    "kind": "def",
    "type": "add_subgroup A"
  },
  {
    "name": "is_fraction_ring.to_field",
    "statement": "def is_fraction_ring.to_field (A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : field K",
    "theorem": "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : field K",
    "args": "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K]",
    "doc_string": " A `comm_ring` `K` which is the localization of an integral domain `R` at `R - {0}` is a field. See note [reducible non-instances].",
    "kind": "def",
    "type": "field K"
  },
  {
    "name": "witt_vector.isocrystal",
    "statement": "structure witt_vector.isocrystal (p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (V : Type u_2) [add_comm_group V] : Type (max u_1 u_2)",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (V : Type u_2) [add_comm_group V] : Type (max u_1 u_2)",
    "args": "(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] [is_domain k] [char_p k p] [perfect_ring k p] (V : Type u_2) [add_comm_group V]",
    "doc_string": "An isocrystal is a vector space over the field `K(p, k)` additionally equipped with a Frobenius-linear automorphism.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "ordnode.node'",
    "statement": "def ordnode.node' {α : Type u} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "theorem": "{α : Type u} (l : ordnode α) (x : α) (r : ordnode α) : ordnode α",
    "args": "{α : Type u} (l : ordnode α) (x : α) (r : ordnode α)",
    "doc_string": " **Internal use only**  O(1). Construct a node with the correct size information, without rebalancing.",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "category_theory.limits.has_pushouts_of_has_binary_coproducts_of_has_coequalizers",
    "statement": "theorem category_theory.limits.has_pushouts_of_has_binary_coproducts_of_has_coequalizers (C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C",
    "theorem": "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C",
    "args": "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C]",
    "doc_string": "If a category has all binary coproducts and all coequalizers, then it also has all pushouts.    As usual, this is not an instance, since there may be a more direct way to construct    pushouts.",
    "kind": "theorem",
    "type": "category_theory.limits.has_pushouts C"
  },
  {
    "name": "is_group_hom.inv",
    "statement": "theorem is_group_hom.inv {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹)",
    "theorem": "{α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹)",
    "args": "{α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f)",
    "doc_string": "The inverse of a group homomorphism is a group homomorphism if the target is commutative.",
    "kind": "theorem",
    "type": "is_group_hom (λ (a : α), (f a)⁻¹)"
  },
  {
    "name": "submodule.closed_complemented",
    "statement": "def submodule.closed_complemented {R : Type u_1} [ring R] {M : Type u_2} [topological_space M] [add_comm_group M] [module R M] (p : submodule R M) : Prop",
    "theorem": "{R : Type u_1} [ring R] {M : Type u_2} [topological_space M] [add_comm_group M] [module R M] (p : submodule R M) : Prop",
    "args": "{R : Type u_1} [ring R] {M : Type u_2} [topological_space M] [add_comm_group M] [module R M] (p : submodule R M)",
    "doc_string": "A submodule `p` is called *complemented* if there exists a continuous projection `M →ₗ[R] p`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.minimal_period",
    "statement": "def function.minimal_period {α : Type u_1} (f : α → α) (x : α) : ℕ",
    "theorem": "{α : Type u_1} (f : α → α) (x : α) : ℕ",
    "args": "{α : Type u_1} (f : α → α) (x : α)",
    "doc_string": " Minimal period of a point `x` under an endomorphism `f`. If `x` is not a periodic point of `f`, then `minimal_period f x = 0`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "metric_space",
    "statement": "structure metric_space (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "We now define `metric_space`, extending `pseudo_metric_space`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "list.prod_pos",
    "statement": "theorem list.prod_pos {R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ∀ (a : R), a ∈ l → 0 < a) : 0 < l.prod",
    "theorem": "{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ∀ (a : R), a ∈ l → 0 < a) : 0 < l.prod",
    "args": "{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ∀ (a : R), a ∈ l → 0 < a)",
    "doc_string": " The product of a list of positive natural numbers is positive, and likewise for any nontrivial ordered semiring.",
    "kind": "theorem",
    "type": "0 < l.prod"
  },
  {
    "name": "lie_ring_module.of_associative_module",
    "statement": "def lie_ring_module.of_associative_module {A : Type v} [ring A] {M : Type w} [add_comm_group M] [module A M] : lie_ring_module A M",
    "theorem": "{A : Type v} [ring A] {M : Type w} [add_comm_group M] [module A M] : lie_ring_module A M",
    "args": "{A : Type v} [ring A] {M : Type w} [add_comm_group M] [module A M]",
    "doc_string": " We can regard a module over an associative ring `A` as a Lie ring module over `A` with Lie bracket equal to its ring commutator.  Note that this cannot be a global instance because it would create a diamond when `M = A`, specifically we can build two mathematically-different `has_bracket A A`s:  1. `@ring.has_bracket A _` which says `⁅a, b⁆ = a * b - b * a`  2. `(@lie_ring_module.of_associative_module A _ A _ _).to_has_bracket` which says `⁅a, b⁆ = a • b`     (and thus `⁅a, b⁆ = a * b`)  See note [reducible non-instances]",
    "kind": "def",
    "type": "lie_ring_module A M"
  },
  {
    "name": "ring_topology.partial_order",
    "statement": "def ring_topology.partial_order {α : Type u_1} [ring α] : partial_order (ring_topology α)",
    "theorem": "{α : Type u_1} [ring α] : partial_order (ring_topology α)",
    "args": "{α : Type u_1} [ring α]",
    "doc_string": "The ordering on ring topologies on the ring `α`.  `t ≤ s` if every set open in `s` is also open in `t` (`t` is finer than `s`).",
    "kind": "def",
    "type": "partial_order (ring_topology α)"
  },
  {
    "name": "is_extr_on",
    "statement": "def is_extr_on {α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α)",
    "doc_string": "`is_extr_on f s a` means `is_min_on f s a` or `is_max_on f s a`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "Inf_hom_class",
    "statement": "structure Inf_hom_class (F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [has_Inf α] [has_Inf β] : Type (max u_10 u_8 u_9)",
    "theorem": "(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [has_Inf α] [has_Inf β] : Type (max u_10 u_8 u_9)",
    "args": "(F : Type u_8) (α : out_param (Type u_9)) (β : out_param (Type u_10)) [has_Inf α] [has_Inf β]",
    "doc_string": " `Inf_hom_class F α β` states that `F` is a type of `⨅`-preserving morphisms.  You should extend this class when you extend `Inf_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_8 u_9)"
  },
  {
    "name": "many_one_degree.of",
    "statement": "def many_one_degree.of {α : Type u} [primcodable α] [inhabited α] (p : α → Prop) : many_one_degree",
    "theorem": "{α : Type u} [primcodable α] [inhabited α] (p : α → Prop) : many_one_degree",
    "args": "{α : Type u} [primcodable α] [inhabited α] (p : α → Prop)",
    "doc_string": "The many-one degree of a set on a primcodable type.",
    "kind": "def",
    "type": "many_one_degree"
  },
  {
    "name": "subgroup.is_open_of_one_mem_interior",
    "statement": "theorem subgroup.is_open_of_one_mem_interior {G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H",
    "theorem": "{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H",
    "args": "{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H)",
    "doc_string": "If a subgroup of a topological group has `1` in its interior, then it is open.",
    "kind": "theorem",
    "type": "is_open ↑H"
  },
  {
    "name": "continuous_monoid_hom.mul",
    "statement": "def continuous_monoid_hom.mul (E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom (E × E) E",
    "theorem": "(E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom (E × E) E",
    "args": "(E : Type u_8) [comm_group E] [topological_space E] [topological_group E]",
    "doc_string": "The continuous homomorphism given by multiplication.",
    "kind": "def",
    "type": "continuous_monoid_hom (E × E) E"
  },
  {
    "name": "snum.neg",
    "statement": "def snum.neg (n : snum) : snum",
    "theorem": "(n : snum) : snum",
    "args": "(n : snum)",
    "doc_string": "The opposite of a `snum`.",
    "kind": "def",
    "type": "snum"
  },
  {
    "name": "continuous_add_monoid_hom.add",
    "statement": "def continuous_add_monoid_hom.add (E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom (E × E) E",
    "theorem": "(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom (E × E) E",
    "args": "(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E]",
    "doc_string": "The continuous homomorphism given by addition.",
    "kind": "def",
    "type": "continuous_add_monoid_hom (E × E) E"
  },
  {
    "name": "mul_tsupport",
    "statement": "def mul_tsupport {X : Type u_1} {α : Type u_2} [has_one α] [topological_space X] (f : X → α) : set X",
    "theorem": "{X : Type u_1} {α : Type u_2} [has_one α] [topological_space X] (f : X → α) : set X",
    "args": "{X : Type u_1} {α : Type u_2} [has_one α] [topological_space X] (f : X → α)",
    "doc_string": "The topological support of a function is the closure of its support, i.e. the closure of the  set of all elements where the function is not equal to 1.",
    "kind": "def",
    "type": "set X"
  },
  {
    "name": "tropical.has_add",
    "statement": "def tropical.has_add {R : Type u} [linear_order R] : has_add (tropical R)",
    "theorem": "{R : Type u} [linear_order R] : has_add (tropical R)",
    "args": "{R : Type u} [linear_order R]",
    "doc_string": "Tropical addition is the minimum of two underlying elements of `R`.",
    "kind": "def",
    "type": "has_add (tropical R)"
  },
  {
    "name": "Class.of_Set",
    "statement": "def Class.of_Set (x : Set) : Class",
    "theorem": "(x : Set) : Class",
    "args": "(x : Set)",
    "doc_string": "Coerce a ZFC set into a class",
    "kind": "def",
    "type": "Class"
  },
  {
    "name": "category_theory.limits.has_finite_limits_of_has_limits",
    "statement": "def category_theory.limits.has_finite_limits_of_has_limits (C : Type u) [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_finite_limits C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits C] : category_theory.limits.has_finite_limits C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits C]",
    "doc_string": "If `C` has all limits, it has finite limits.",
    "kind": "def",
    "type": "category_theory.limits.has_finite_limits C"
  },
  {
    "name": "ordnode.erase_max",
    "statement": "def ordnode.erase_max {α : Type u} : ordnode α → ordnode α",
    "theorem": "{α : Type u} : ordnode α → ordnode α",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Remove the maximum element from the tree, or do nothing if it is already empty.      erase_max {1, 2, 3} = {1, 2}     erase_max ∅ = ∅",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "list.func.pointwise",
    "statement": "def list.func.pointwise {α : Type u} {β : Type v} {γ : Type w} [inhabited α] [inhabited β] (f : α → β → γ) : list α → list β → list γ",
    "theorem": "{α : Type u} {β : Type v} {γ : Type w} [inhabited α] [inhabited β] (f : α → β → γ) : list α → list β → list γ",
    "args": "{α : Type u} {β : Type v} {γ : Type w} [inhabited α] [inhabited β] (f : α → β → γ)",
    "doc_string": "Pointwise operations on lists. If lists are different lengths, use the default element.",
    "kind": "def",
    "type": "list α → list β → list γ"
  },
  {
    "name": "is_compact.ultrafilter_le_nhds",
    "statement": "theorem is_compact.ultrafilter_le_nhds {α : Type u} [topological_space α] {s : set α} : is_compact s → ∀ (f : ultrafilter α), ↑f ≤ filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : is_compact s → ∀ (f : ultrafilter α), ↑f ≤ filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "**Alias** of the forward direction of is_compact_iff_ultrafilter_le_nhds`.",
    "kind": "theorem",
    "type": "is_compact s → ∀ (f : ultrafilter α), ↑f ≤ filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)"
  },
  {
    "name": "dihedral_group",
    "statement": "inductive dihedral_group (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": "For `n ≠ 0`, `dihedral_group n` represents the symmetry group of the regular `n`-gon. `r i` represents the rotations of the `n`-gon by `2πi/n`, and `sr i` represents the reflections of the `n`-gon. `dihedral_group 0` corresponds to the infinite dihedral group.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "fib_rec",
    "statement": "def fib_rec {α : Type u_1} [comm_semiring α] : linear_recurrence α",
    "theorem": "{α : Type u_1} [comm_semiring α] : linear_recurrence α",
    "args": "{α : Type u_1} [comm_semiring α]",
    "doc_string": "The recurrence relation satisfied by the Fibonacci sequence.",
    "kind": "def",
    "type": "linear_recurrence α"
  },
  {
    "name": "function.not_surjective_Type",
    "statement": "theorem function.not_surjective_Type {α : Type u} (f : α → Type (max u v)) : ¬function.surjective f",
    "theorem": "{α : Type u} (f : α → Type (max u v)) : ¬function.surjective f",
    "args": "{α : Type u} (f : α → Type (max u v))",
    "doc_string": "There is no surjection from `α : Type u` into `Type u`. This theorem  demonstrates why `Type : Type` would be inconsistent in Lean.",
    "kind": "theorem",
    "type": "¬function.surjective f"
  },
  {
    "name": "measure_theory.outer_measure.pi",
    "statement": "def measure_theory.outer_measure.pi {ι : Type u_1} {α : ι → Type u_3} [fintype ι] (m : Π (i : ι), measure_theory.outer_measure (α i)) : measure_theory.outer_measure (Π (i : ι), α i)",
    "theorem": "{ι : Type u_1} {α : ι → Type u_3} [fintype ι] (m : Π (i : ι), measure_theory.outer_measure (α i)) : measure_theory.outer_measure (Π (i : ι), α i)",
    "args": "{ι : Type u_1} {α : ι → Type u_3} [fintype ι] (m : Π (i : ι), measure_theory.outer_measure (α i))",
    "doc_string": "`outer_measure.pi m` is the finite product of the outer measures `{m i | i : ι}`.  It is defined to be the maximal outer measure `n` with the property that  `n (pi univ s) ≤ ∏ i, m i (s i)`, where `pi univ s` is the product of the sets  `{s i | i : ι}`.",
    "kind": "def",
    "type": "measure_theory.outer_measure (Π (i : ι), α i)"
  },
  {
    "name": "ordnode.find_le",
    "statement": "def ordnode.find_le {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": "O(log n). Get the largest element in the tree that is `≤ x`.      find_le 2 {1, 2, 4} = some 2     find_le 3 {1, 2, 4} = some 2     find_le 0 {1, 2, 4} = none",
    "kind": "def",
    "type": "ordnode α → option α"
  },
  {
    "name": "prod.comm_ring",
    "statement": "def prod.comm_ring {R : Type u_1} {S : Type u_3} [comm_ring R] [comm_ring S] : comm_ring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [comm_ring R] [comm_ring S] : comm_ring (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [comm_ring R] [comm_ring S]",
    "doc_string": "Product of two commutative rings is a commutative ring.",
    "kind": "def",
    "type": "comm_ring (R × S)"
  },
  {
    "name": "lazy_list.bind",
    "statement": "def lazy_list.bind {α : Type u_1} {β : Type u_2} : lazy_list α → (α → lazy_list β) → lazy_list β",
    "theorem": "{α : Type u_1} {β : Type u_2} : lazy_list α → (α → lazy_list β) → lazy_list β",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": "Monadic bind operation for `lazy_list`.",
    "kind": "def",
    "type": "lazy_list α → (α → lazy_list β) → lazy_list β"
  },
  {
    "name": "topological_space.induced",
    "statement": "def topological_space.induced {α : Type u} {β : Type v} (f : α → β) (t : topological_space β) : topological_space α",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (t : topological_space β) : topological_space α",
    "args": "{α : Type u} {β : Type v} (f : α → β) (t : topological_space β)",
    "doc_string": "Given `f : α → β` and a topology on `β`, the induced topology on `α` is the collection of  sets that are preimages of some open set in `β`. This is the coarsest topology that  makes `f` continuous.",
    "kind": "def",
    "type": "topological_space α"
  },
  {
    "name": "computation.thinkN",
    "statement": "def computation.thinkN {α : Type u} (c : computation α) : ℕ → computation α",
    "theorem": "{α : Type u} (c : computation α) : ℕ → computation α",
    "args": "{α : Type u} (c : computation α)",
    "doc_string": "`thinkN c n` is the computation that delays for `n` ticks and then performs  computation `c`.",
    "kind": "def",
    "type": "ℕ → computation α"
  },
  {
    "name": "succ_order.of_succ_le_iff",
    "statement": "def succ_order.of_succ_le_iff {α : Type u_1} [linear_order α] (succ : α → α) (hsucc_le_iff : ∀ {a b : α}, succ a ≤ b ↔ a < b) : succ_order α",
    "theorem": "{α : Type u_1} [linear_order α] (succ : α → α) (hsucc_le_iff : ∀ {a b : α}, succ a ≤ b ↔ a < b) : succ_order α",
    "args": "{α : Type u_1} [linear_order α] (succ : α → α) (hsucc_le_iff : ∀ {a b : α}, succ a ≤ b ↔ a < b)",
    "doc_string": "A constructor for `succ_order α` usable when `α` is a linear order with no maximal element.",
    "kind": "def",
    "type": "succ_order α"
  },
  {
    "name": "polynomial.sum",
    "statement": "def polynomial.sum {R : Type u} [semiring R] {S : Type u_1} [add_comm_monoid S] (p : polynomial R) (f : ℕ → R → S) : S",
    "theorem": "{R : Type u} [semiring R] {S : Type u_1} [add_comm_monoid S] (p : polynomial R) (f : ℕ → R → S) : S",
    "args": "{R : Type u} [semiring R] {S : Type u_1} [add_comm_monoid S] (p : polynomial R) (f : ℕ → R → S)",
    "doc_string": "Summing the values of a function applied to the coefficients of a polynomial",
    "kind": "def",
    "type": "S"
  },
  {
    "name": "stream.nats",
    "statement": "def stream.nats  : stream ℕ",
    "theorem": " : stream ℕ",
    "args": "",
    "doc_string": "The stream of natural numbers: `stream.nth n stream.nats = n`.",
    "kind": "def",
    "type": "stream ℕ"
  },
  {
    "name": "is_mul_hom.inv",
    "statement": "theorem is_mul_hom.inv {α : Type u_1} {β : Type u_2} [has_mul α] [comm_group β] {f : α → β} (hf : is_mul_hom f) : is_mul_hom (λ (a : α), (f a)⁻¹)",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_mul α] [comm_group β] {f : α → β} (hf : is_mul_hom f) : is_mul_hom (λ (a : α), (f a)⁻¹)",
    "args": "{α : Type u_1} {β : Type u_2} [has_mul α] [comm_group β] {f : α → β} (hf : is_mul_hom f)",
    "doc_string": " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative.",
    "kind": "theorem",
    "type": "is_mul_hom (λ (a : α), (f a)⁻¹)"
  },
  {
    "name": "algebra.finite_presentation",
    "statement": "def algebra.finite_presentation (R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop",
    "theorem": "(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] : Prop",
    "args": "(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A]",
    "doc_string": " An algebra over a commutative semiring is `finite_presentation` if it is the quotient of a polynomial ring in `n` variables by a finitely generated ideal.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "powers.is_submonoid",
    "statement": "theorem powers.is_submonoid {M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)",
    "theorem": "{M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)",
    "args": "{M : Type u_1} [monoid M] (x : M)",
    "doc_string": "The set of natural number powers of an element of a monoid `M` is a submonoid of `M`.",
    "kind": "theorem",
    "type": "is_submonoid (powers x)"
  },
  {
    "name": "add_semiconj_by.zero_left",
    "statement": "theorem add_semiconj_by.zero_left {M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x",
    "theorem": "{M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x",
    "args": "{M : Type u} [add_zero_class M] (x : M)",
    "doc_string": "Zero additively semiconjugates any element to itself.",
    "kind": "theorem",
    "type": "add_semiconj_by 0 x x"
  },
  {
    "name": "measure_theory.measure.add_haar",
    "statement": "def measure_theory.measure.add_haar {G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G",
    "theorem": "{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G",
    "args": "{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] [locally_compact_space G]",
    "doc_string": "`add_haar` is some choice of a Haar measure, on a locally compact additive group.",
    "kind": "def",
    "type": "measure_theory.measure G"
  },
  {
    "name": "one_one_reducible",
    "statement": "def one_one_reducible {α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop)",
    "doc_string": "`p` is one-one reducible to `q` if there is an injective computable function translating questions about `p` to questions about `q`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "order_ring_hom",
    "statement": "structure order_ring_hom (α : Type u_6) (β : Type u_7) [non_assoc_semiring α] [preorder α] [non_assoc_semiring β] [preorder β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [non_assoc_semiring α] [preorder α] [non_assoc_semiring β] [preorder β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [non_assoc_semiring α] [preorder α] [non_assoc_semiring β] [preorder β]",
    "doc_string": " `order_ring_hom α β` is the type of monotone semiring homomorphisms from `α` to `β`.  When possible, instead of parametrizing results over `(f : order_ring_hom α β)`, you should parametrize over `(F : Type*) [order_ring_hom_class F α β] (f : F)`.  When you extend this structure, make sure to extend `order_ring_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "absolute_value.is_admissible",
    "statement": "structure absolute_value.is_admissible {R : Type u_1} [euclidean_domain R] (abv : absolute_value R ℤ) : Type",
    "theorem": "{R : Type u_1} [euclidean_domain R] (abv : absolute_value R ℤ) : Type",
    "args": "{R : Type u_1} [euclidean_domain R] (abv : absolute_value R ℤ)",
    "doc_string": " An absolute value `R → ℤ` is admissible if it respects the Euclidean domain structure and a large enough set of elements in `R^n` will contain a pair of elements whose remainders are pointwise close together.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "lazy_list.attach",
    "statement": "def lazy_list.attach {α : Type u_1} (l : lazy_list α) : lazy_list {x // x ∈ l}",
    "theorem": "{α : Type u_1} (l : lazy_list α) : lazy_list {x // x ∈ l}",
    "args": "{α : Type u_1} (l : lazy_list α)",
    "doc_string": "\"Attach\" the proof that the elements of `l` are in `l` to produce a new `lazy_list`  with the same elements but in the type `{x // x ∈ l}`.",
    "kind": "def",
    "type": "lazy_list {x // x ∈ l}"
  },
  {
    "name": "Inf_hom.comp",
    "statement": "def Inf_hom.comp {α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_Inf α] [has_Inf β] [has_Inf γ] (f : Inf_hom β γ) (g : Inf_hom α β) : Inf_hom α γ",
    "theorem": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_Inf α] [has_Inf β] [has_Inf γ] (f : Inf_hom β γ) (g : Inf_hom α β) : Inf_hom α γ",
    "args": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_Inf α] [has_Inf β] [has_Inf γ] (f : Inf_hom β γ) (g : Inf_hom α β)",
    "doc_string": "Composition of `Inf_hom`s as a `Inf_hom`.",
    "kind": "def",
    "type": "Inf_hom α γ"
  },
  {
    "name": "normed_ring.to_non_unital_normed_ring",
    "statement": "def normed_ring.to_non_unital_normed_ring {α : Type u_1} [β : normed_ring α] : non_unital_normed_ring α",
    "theorem": "{α : Type u_1} [β : normed_ring α] : non_unital_normed_ring α",
    "args": "{α : Type u_1} [β : normed_ring α]",
    "doc_string": "A normed ring is a non-unital normed ring.",
    "kind": "def",
    "type": "non_unital_normed_ring α"
  },
  {
    "name": "pgame.short",
    "statement": "inductive pgame.short  : pgame → Type (u+1)",
    "theorem": " : pgame → Type (u+1)",
    "args": "",
    "doc_string": "A short game is a game with a finite set of moves at every turn.",
    "kind": "inductive",
    "type": "pgame → Type (u+1)"
  },
  {
    "name": "turing.list_blank.cons",
    "statement": "def turing.list_blank.cons {Γ : Type u_1} [inhabited Γ] (a : Γ) (l : turing.list_blank Γ) : turing.list_blank Γ",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (a : Γ) (l : turing.list_blank Γ) : turing.list_blank Γ",
    "args": "{Γ : Type u_1} [inhabited Γ] (a : Γ) (l : turing.list_blank Γ)",
    "doc_string": "We can cons an element onto a `list_blank`.",
    "kind": "def",
    "type": "turing.list_blank Γ"
  },
  {
    "name": "finset.disj_union",
    "statement": "def finset.disj_union {α : Type u_1} (s t : finset α) (h : ∀ (a : α), a ∈ s → a ∉ t) : finset α",
    "theorem": "{α : Type u_1} (s t : finset α) (h : ∀ (a : α), a ∈ s → a ∉ t) : finset α",
    "args": "{α : Type u_1} (s t : finset α) (h : ∀ (a : α), a ∈ s → a ∉ t)",
    "doc_string": " `disj_union s t h` is the set such that `a ∈ disj_union s t h` iff `a ∈ s` or `a ∈ t`. It is the same as `s ∪ t`, but it does not require decidable equality on the type. The hypothesis ensures that the sets are disjoint.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "bdd_below.inter_of_right",
    "statement": "theorem bdd_below.inter_of_right {α : Type u} [preorder α] {s t : set α} (h : bdd_below t) : bdd_below (s ∩ t)",
    "theorem": "{α : Type u} [preorder α] {s t : set α} (h : bdd_below t) : bdd_below (s ∩ t)",
    "args": "{α : Type u} [preorder α] {s t : set α} (h : bdd_below t)",
    "doc_string": "If `t` is bounded, then so is `s ∩ t`",
    "kind": "theorem",
    "type": "bdd_below (s ∩ t)"
  },
  {
    "name": "tactic.interactive.itactic",
    "statement": "def tactic.interactive.itactic  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "itactic: parse a nested \"interactive\" tactic. That is, parse   `{` tactic `}`",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "category_theory.is_subterminal.mono_terminal_from",
    "statement": "theorem category_theory.is_subterminal.mono_terminal_from {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A)",
    "doc_string": "If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism. The converse of `is_subterminal_of_mono_terminal_from`.",
    "kind": "theorem",
    "type": "category_theory.mono (category_theory.limits.terminal.from A)"
  },
  {
    "name": "zero_lt.mul_pos_mono",
    "statement": "def zero_lt.mul_pos_mono (X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop",
    "theorem": "(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop",
    "args": "(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X]",
    "doc_string": "  `zero_lt.mul_pos_mono α` is an abbreviation for `covariant_class α>0 α (λ x y, y * x) (≤)`, expressing that multiplication by positive elements on the right is monotone.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_lawful_bitraversable",
    "statement": "structure is_lawful_bitraversable (t : Type u → Type u → Type u) [bitraversable t] : Type",
    "theorem": "(t : Type u → Type u → Type u) [bitraversable t] : Type",
    "args": "(t : Type u → Type u → Type u) [bitraversable t]",
    "doc_string": "Bifunctor. This typeclass asserts that a lawless bitraversable bifunctor is lawful.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "tactic.mllist",
    "statement": "inductive tactic.mllist (m : Type u → Type u) (α : Type u) : Type u",
    "theorem": "(m : Type u → Type u) (α : Type u) : Type u",
    "args": "(m : Type u → Type u) (α : Type u)",
    "doc_string": "A monadic lazy list, controlled by an arbitrary monad.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "topological_space.metrizable_space_metric",
    "statement": "def topological_space.metrizable_space_metric (X : Type u_1) [topological_space X] [h : topological_space.metrizable_space X] : metric_space X",
    "theorem": "(X : Type u_1) [topological_space X] [h : topological_space.metrizable_space X] : metric_space X",
    "args": "(X : Type u_1) [topological_space X] [h : topological_space.metrizable_space X]",
    "doc_string": "Construct on a metrizable space a metric compatible with the topology.",
    "kind": "def",
    "type": "metric_space X"
  },
  {
    "name": "polynomial.root_set",
    "statement": "def polynomial.root_set {T : Type w} [comm_ring T] (p : polynomial T) (S : Type u_1) [comm_ring S] [is_domain S] [algebra T S] : set S",
    "theorem": "{T : Type w} [comm_ring T] (p : polynomial T) (S : Type u_1) [comm_ring S] [is_domain S] [algebra T S] : set S",
    "args": "{T : Type w} [comm_ring T] (p : polynomial T) (S : Type u_1) [comm_ring S] [is_domain S] [algebra T S]",
    "doc_string": " The set of distinct roots of `p` in `E`.  If you have a non-separable polynomial, use `polynomial.roots` for the multiset where multiple roots have the appropriate multiplicity.",
    "kind": "def",
    "type": "set S"
  },
  {
    "name": "denumerable.denumerable_list",
    "statement": "def denumerable.denumerable_list {α : Type u_1} [denumerable α] : denumerable (list α)",
    "theorem": "{α : Type u_1} [denumerable α] : denumerable (list α)",
    "args": "{α : Type u_1} [denumerable α]",
    "doc_string": "If `α` is denumerable, then so is `list α`.",
    "kind": "def",
    "type": "denumerable (list α)"
  },
  {
    "name": "category_theory.is_coseparator",
    "statement": "def category_theory.is_coseparator {C : Type u} [category_theory.category C] (G : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (G : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (G : C)",
    "doc_string": "We say that `G` is a coseparator if the functor `C(-, G)` is faithful.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "same_ray",
    "statement": "def same_ray (R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v₁ v₂ : M) : Prop",
    "theorem": "(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v₁ v₂ : M) : Prop",
    "args": "(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v₁ v₂ : M)",
    "doc_string": " Two vectors are in the same ray if either one of them is zero or some positive multiples of them are equal (in the typical case over a field, this means one of them is a nonnegative multiple of the other).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "quadratic_form.sq",
    "statement": "def quadratic_form.sq {R₁ : Type u_4} [comm_ring R₁] : quadratic_form R₁ R₁",
    "theorem": "{R₁ : Type u_4} [comm_ring R₁] : quadratic_form R₁ R₁",
    "args": "{R₁ : Type u_4} [comm_ring R₁]",
    "doc_string": "`sq` is the quadratic form mapping the vector `x : R₁` to `x * x`",
    "kind": "def",
    "type": "quadratic_form R₁ R₁"
  },
  {
    "name": "add_comm_monoid.add_torsion",
    "statement": "def add_comm_monoid.add_torsion (G : Type u_1) [add_comm_monoid G] : add_submonoid G",
    "theorem": "(G : Type u_1) [add_comm_monoid G] : add_submonoid G",
    "args": "(G : Type u_1) [add_comm_monoid G]",
    "doc_string": "The torsion submonoid of an additive commutative monoid.",
    "kind": "def",
    "type": "add_submonoid G"
  },
  {
    "name": "function.graph",
    "statement": "def function.graph {α : Type u_1} {β : Type u_2} (f : α → β) : rel α β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) : rel α β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β)",
    "doc_string": "The graph of a function as a relation.",
    "kind": "def",
    "type": "rel α β"
  },
  {
    "name": "filter.has_npow",
    "statement": "def filter.has_npow {α : Type u_2} [has_one α] [has_mul α] : has_pow (filter α) ℕ",
    "theorem": "{α : Type u_2} [has_one α] [has_mul α] : has_pow (filter α) ℕ",
    "args": "{α : Type u_2} [has_one α] [has_mul α]",
    "doc_string": " Repeated pointwise multiplication (not the same as pointwise repeated multiplication!) of a `filter`. See Note [pointwise nat action].",
    "kind": "def",
    "type": "has_pow (filter α) ℕ"
  },
  {
    "name": "relation.trans_gen",
    "statement": "inductive relation.trans_gen {α : Type u_1} (r : α → α → Prop) (a : α) : α → Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (a : α) : α → Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (a : α)",
    "doc_string": "`trans_gen r`: transitive closure of `r`",
    "kind": "inductive",
    "type": "α → Prop"
  },
  {
    "name": "nhds_contain_boxes",
    "statement": "def nhds_contain_boxes {α : Type u} {β : Type v} [topological_space α] [topological_space β] (s : set α) (t : set β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] (s : set α) (t : set β) : Prop",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] (s : set α) (t : set β)",
    "doc_string": " `nhds_contain_boxes s t` means that any open neighborhood of `s × t` in `α × β` includes a product of an open neighborhood of `s` by an open neighborhood of `t`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lim",
    "statement": "def lim {α : Type u} {β : Type v} [topological_space α] [nonempty α] (f : filter β) (g : β → α) : α",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [nonempty α] (f : filter β) (g : β → α) : α",
    "args": "{α : Type u} {β : Type v} [topological_space α] [nonempty α] (f : filter β) (g : β → α)",
    "doc_string": " If `f` is a filter in `β` and `g : β → α` is a function, then `lim f` is a limit of `g` at `f`, if it exists.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "list.find_indexes",
    "statement": "def list.find_indexes {α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) : list ℕ",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α) : list ℕ",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : list α)",
    "doc_string": "`find_indexes p l` is the list of indexes of elements of `l` that satisfy `p`.",
    "kind": "def",
    "type": "list ℕ"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.has_coe_to_int_fract_pair",
    "statement": "def generalized_continued_fraction.int_fract_pair.has_coe_to_int_fract_pair {K : Type u_1} {β : Type u_2} [has_coe K β] : has_coe (generalized_continued_fraction.int_fract_pair K) (generalized_continued_fraction.int_fract_pair β)",
    "theorem": "{K : Type u_1} {β : Type u_2} [has_coe K β] : has_coe (generalized_continued_fraction.int_fract_pair K) (generalized_continued_fraction.int_fract_pair β)",
    "args": "{K : Type u_1} {β : Type u_2} [has_coe K β]",
    "doc_string": "Coerce a pair by coercing the fractional component.",
    "kind": "def",
    "type": "has_coe (generalized_continued_fraction.int_fract_pair K) (generalized_continued_fraction.int_fract_pair β)"
  },
  {
    "name": "finset.sup_indep",
    "statement": "def finset.sup_indep {α : Type u_1} {ι : Type u_3} [lattice α] [order_bot α] (s : finset ι) (f : ι → α) : Prop",
    "theorem": "{α : Type u_1} {ι : Type u_3} [lattice α] [order_bot α] (s : finset ι) (f : ι → α) : Prop",
    "args": "{α : Type u_1} {ι : Type u_3} [lattice α] [order_bot α] (s : finset ι) (f : ι → α)",
    "doc_string": " Supremum independence of finite sets. We avoid the \"obvious\" definition using `s.erase i` because `erase` would require decidable equality on `ι`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subfield.has_inf",
    "statement": "def subfield.has_inf {K : Type u} [field K] : has_inf (subfield K)",
    "theorem": "{K : Type u} [field K] : has_inf (subfield K)",
    "args": "{K : Type u} [field K]",
    "doc_string": "The inf of two subfields is their intersection.",
    "kind": "def",
    "type": "has_inf (subfield K)"
  },
  {
    "name": "topological_space.coinduced",
    "statement": "def topological_space.coinduced {α : Type u} {β : Type v} (f : α → β) (t : topological_space α) : topological_space β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (t : topological_space α) : topological_space β",
    "args": "{α : Type u} {β : Type v} (f : α → β) (t : topological_space α)",
    "doc_string": "Given `f : α → β` and a topology on `α`, the coinduced topology on `β` is defined  such that `s:set β` is open if the preimage of `s` is open. This is the finest topology that  makes `f` continuous.",
    "kind": "def",
    "type": "topological_space β"
  },
  {
    "name": "pSet.to_set",
    "statement": "def pSet.to_set (u : pSet) : set pSet",
    "theorem": "(u : pSet) : set pSet",
    "args": "(u : pSet)",
    "doc_string": "Convert a pre-set to a `set` of pre-sets.",
    "kind": "def",
    "type": "set pSet"
  },
  {
    "name": "uniform_space.ball",
    "statement": "def uniform_space.ball {β : Type u_2} (x : β) (V : set (β × β)) : set β",
    "theorem": "{β : Type u_2} (x : β) (V : set (β × β)) : set β",
    "args": "{β : Type u_2} (x : β) (V : set (β × β))",
    "doc_string": " The ball around `(x : β)` with respect to `(V : set (β × β))`. Intended to be used for `V ∈ 𝓤 β`, but this is not needed for the definition. Recovers the notions of metric space ball when `V = {p | dist p.1 p.2 < r }`.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "category_theory.limits.bicone.of_colimit_cocone",
    "statement": "def category_theory.limits.bicone.of_colimit_cocone {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J → C} {t : category_theory.limits.cocone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.bicone f",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J → C} {t : category_theory.limits.cocone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.bicone f",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {f : J → C} {t : category_theory.limits.cocone (category_theory.discrete.functor f)} (ht : category_theory.limits.is_colimit t)",
    "doc_string": "We can turn any colimit cocone over a discrete collection of objects into a bicone.",
    "kind": "def",
    "type": "category_theory.limits.bicone f"
  },
  {
    "name": "is_well_order.to_has_well_founded",
    "statement": "def is_well_order.to_has_well_founded {α : Type u} [has_lt α] [hwo : is_well_order α has_lt.lt] : has_well_founded α",
    "theorem": "{α : Type u} [has_lt α] [hwo : is_well_order α has_lt.lt] : has_well_founded α",
    "args": "{α : Type u} [has_lt α] [hwo : is_well_order α has_lt.lt]",
    "doc_string": "Derive a `has_well_founded` instance from a `is_well_order` instance.",
    "kind": "def",
    "type": "has_well_founded α"
  },
  {
    "name": "tropical",
    "statement": "def tropical (R : Type u) : Type u",
    "theorem": "(R : Type u) : Type u",
    "args": "(R : Type u)",
    "doc_string": "The tropicalization of a type `R`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "range.is_add_submonoid",
    "statement": "theorem range.is_add_submonoid {M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)",
    "theorem": "{M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)",
    "args": "{M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f)",
    "doc_string": "The image of an `add_monoid` hom is an `add_submonoid` of the codomain.",
    "kind": "theorem",
    "type": "is_add_submonoid (set.range f)"
  },
  {
    "name": "con",
    "statement": "structure con (M : Type u_1) [has_mul M] : Type u_1",
    "theorem": "(M : Type u_1) [has_mul M] : Type u_1",
    "args": "(M : Type u_1) [has_mul M]",
    "doc_string": "A congruence relation on a type with a multiplication is an equivalence relation which    preserves multiplication.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "is_totally_disconnected",
    "statement": "def is_totally_disconnected {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": " A set `s` is called totally disconnected if every subset `t ⊆ s` which is preconnected is a subsingleton, ie either empty or a singleton.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.arithmetic_function.has_mul",
    "statement": "def nat.arithmetic_function.has_mul {R : Type u_1} [semiring R] : has_mul (nat.arithmetic_function R)",
    "theorem": "{R : Type u_1} [semiring R] : has_mul (nat.arithmetic_function R)",
    "args": "{R : Type u_1} [semiring R]",
    "doc_string": "The Dirichlet convolution of two arithmetic functions `f` and `g` is another arithmetic function  such that `(f * g) n` is the sum of `f x * g y` over all `(x,y)` such that `x * y = n`.",
    "kind": "def",
    "type": "has_mul (nat.arithmetic_function R)"
  },
  {
    "name": "commute.eq",
    "statement": "theorem commute.eq {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a",
    "theorem": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a",
    "args": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b)",
    "doc_string": "Equality behind `commute a b`; useful for rewriting.",
    "kind": "theorem",
    "type": "a * b = b * a"
  },
  {
    "name": "omega_limit",
    "statement": "def omega_limit {τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α) : set β",
    "theorem": "{τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α) : set β",
    "args": "{τ : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space β] (f : filter τ) (ϕ : τ → α → β) (s : set α)",
    "doc_string": "The ω-limit of a set `s` under `ϕ` with respect to a filter `f` is    ⋂ u ∈ f, cl (ϕ u s).",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "witt_vector.fraction_ring.module",
    "statement": "def witt_vector.fraction_ring.module (p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] : module (fraction_ring (witt_vector p k)) (fraction_ring (witt_vector p k))",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k] : module (fraction_ring (witt_vector p k)) (fraction_ring (witt_vector p k))",
    "args": "(p : ℕ) [fact (nat.prime p)] (k : Type u_1) [comm_ring k]",
    "doc_string": "A helper instance for type class inference.",
    "kind": "def",
    "type": "module (fraction_ring (witt_vector p k)) (fraction_ring (witt_vector p k))"
  },
  {
    "name": "bounded_order",
    "statement": "structure bounded_order (α : Type u) [has_le α] : Type u",
    "theorem": "(α : Type u) [has_le α] : Type u",
    "args": "(α : Type u) [has_le α]",
    "doc_string": "A bounded order describes an order `(≤)` with a top and bottom element,  denoted `⊤` and `⊥` respectively.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "asymptotics.superpolynomial_decay",
    "statement": "def asymptotics.superpolynomial_decay {α : Type u_1} {β : Type u_2} [topological_space β] [comm_semiring β] (l : filter α) (k f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space β] [comm_semiring β] (l : filter α) (k f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space β] [comm_semiring β] (l : filter α) (k f : α → β)",
    "doc_string": "`f` has superpolynomial decay in parameter `k` along filter `l` if  `k ^ n * f` tends to zero at `l` for all naturals `n`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_comm_monoid.nat_module.unique",
    "statement": "def add_comm_monoid.nat_module.unique {M : Type u_5} [add_comm_monoid M] : unique (module ℕ M)",
    "theorem": "{M : Type u_5} [add_comm_monoid M] : unique (module ℕ M)",
    "args": "{M : Type u_5} [add_comm_monoid M]",
    "doc_string": " All `ℕ`-module structures are equal. Not an instance since in mathlib all `add_comm_monoid` should normally have exactly one `ℕ`-module structure by design.",
    "kind": "def",
    "type": "unique (module ℕ M)"
  },
  {
    "name": "grade_max_order",
    "statement": "structure grade_max_order (𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)",
    "theorem": "(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)",
    "args": "(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α]",
    "doc_string": "A `𝕆`-graded order where maximal elements have maximal grades.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "ordinal.nfp_family",
    "statement": "def ordinal.nfp_family {ι : Type u} (f : ι → ordinal → ordinal) (a : ordinal) : ordinal",
    "theorem": "{ι : Type u} (f : ι → ordinal → ordinal) (a : ordinal) : ordinal",
    "args": "{ι : Type u} (f : ι → ordinal → ordinal) (a : ordinal)",
    "doc_string": " The next common fixed point, at least `a`, for a family of normal functions.  `ordinal.nfp_family_fp` shows this is a fixed point, `ordinal.le_nfp_family` shows it's at least `a`, and `ordinal.nfp_family_le_fp` shows this is the least ordinal with these properties.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "sup_hom.id",
    "statement": "def sup_hom.id (α : Type u_3) [has_sup α] : sup_hom α α",
    "theorem": "(α : Type u_3) [has_sup α] : sup_hom α α",
    "args": "(α : Type u_3) [has_sup α]",
    "doc_string": "`id` as a `sup_hom`.",
    "kind": "def",
    "type": "sup_hom α α"
  },
  {
    "name": "num.cmp",
    "statement": "def num.cmp  : num → num → ordering",
    "theorem": " : num → num → ordering",
    "args": "",
    "doc_string": "Ordering of `num`s.",
    "kind": "def",
    "type": "num → num → ordering"
  },
  {
    "name": "rel_iso",
    "statement": "structure rel_iso {α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "theorem": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "args": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop)",
    "doc_string": "A relation isomorphism is an equivalence that is also a relation embedding.",
    "kind": "structure",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "group",
    "statement": "structure group (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": " A `group` is a `monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.  There is also a division operation `/` such that `a / b = a * b⁻¹`, with a default so that `a / b = a * b⁻¹` holds by definition.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "dihedral_group.group",
    "statement": "def dihedral_group.group {n : ℕ} : group (dihedral_group n)",
    "theorem": "{n : ℕ} : group (dihedral_group n)",
    "args": "{n : ℕ}",
    "doc_string": "The group structure on `dihedral_group n`.",
    "kind": "def",
    "type": "group (dihedral_group n)"
  },
  {
    "name": "nat.dvd_left_injective",
    "statement": "theorem nat.dvd_left_injective  : function.injective has_dvd.dvd",
    "theorem": " : function.injective has_dvd.dvd",
    "args": "",
    "doc_string": "`dvd` is injective in the left argument",
    "kind": "theorem",
    "type": "function.injective has_dvd.dvd"
  },
  {
    "name": "reflected",
    "statement": "def reflected {α : Sort u} : α → Type",
    "theorem": "{α : Sort u} : α → Type",
    "args": "{α : Sort u}",
    "doc_string": "(reflected a) is a special opaque container for a closed `expr` representing `a`.    It can only be obtained via type class inference, which will use the representation    of `a` in the calling context. Local constants in the representation are replaced    by nested inference of `reflected` instances.     The quotation expression `` `(a) `` (outside of patterns) is equivalent to `reflect a`    and thus can be used as an explicit way of inferring an instance of `reflected a`.",
    "kind": "def",
    "type": "α → Type"
  },
  {
    "name": "antisymm_rel",
    "statement": "def antisymm_rel {α : Type u_1} (r : α → α → Prop) (a b : α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (a b : α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (a b : α)",
    "doc_string": "The antisymmetrization relation.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.to_alist",
    "statement": "def list.to_alist {α : Type u} [decidable_eq α] {β : α → Type v} (l : list (sigma β)) : alist β",
    "theorem": "{α : Type u} [decidable_eq α] {β : α → Type v} (l : list (sigma β)) : alist β",
    "args": "{α : Type u} [decidable_eq α] {β : α → Type v} (l : list (sigma β))",
    "doc_string": " Given `l : list (sigma β)`, create a term of type `alist β` by removing entries with duplicate keys.",
    "kind": "def",
    "type": "alist β"
  },
  {
    "name": "category_theory.of_type_monad",
    "statement": "def category_theory.of_type_monad (m : Type u → Type u) [monad m] [is_lawful_monad m] : category_theory.monad (Type u)",
    "theorem": "(m : Type u → Type u) [monad m] [is_lawful_monad m] : category_theory.monad (Type u)",
    "args": "(m : Type u → Type u) [monad m] [is_lawful_monad m]",
    "doc_string": "A lawful `control.monad` gives a category theory `monad` on the category of types.",
    "kind": "def",
    "type": "category_theory.monad (Type u)"
  },
  {
    "name": "seq_closure_subset_closure",
    "statement": "theorem seq_closure_subset_closure {X : Type u_1} [topological_space X] (s : set X) : seq_closure s ⊆ closure s",
    "theorem": "{X : Type u_1} [topological_space X] (s : set X) : seq_closure s ⊆ closure s",
    "args": "{X : Type u_1} [topological_space X] (s : set X)",
    "doc_string": " The sequential closure of a set is contained in the closure of that set. The converse is not true.",
    "kind": "theorem",
    "type": "seq_closure s ⊆ closure s"
  },
  {
    "name": "fintype.properly_discontinuous_smul",
    "statement": "def fintype.properly_discontinuous_smul {Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [fintype Γ] : properly_discontinuous_smul Γ T",
    "theorem": "{Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [fintype Γ] : properly_discontinuous_smul Γ T",
    "args": "{Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [fintype Γ]",
    "doc_string": "A finite group action is always properly discontinuous",
    "kind": "def",
    "type": "properly_discontinuous_smul Γ T"
  },
  {
    "name": "list.forall₂",
    "statement": "inductive list.forall₂ {α : Type u_1} {β : Type u_2} (R : α → β → Prop) : list α → list β → Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (R : α → β → Prop) : list α → list β → Prop",
    "args": "{α : Type u_1} {β : Type u_2} (R : α → β → Prop)",
    "doc_string": "`forall₂ R l₁ l₂` means that `l₁` and `l₂` have the same length,  and whenever `a` is the nth element of `l₁`, and `b` is the nth element of `l₂`,  then `R a b` is satisfied.",
    "kind": "inductive",
    "type": "list α → list β → Prop"
  },
  {
    "name": "shelf",
    "statement": "structure shelf (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A *shelf* is a structure with a self-distributive binary operation. The binary operation is regarded as a left action of the type on itself.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "dense_range.quotient",
    "statement": "theorem dense_range.quotient {α : Type u} {β : Type v} [setoid α] [topological_space α] {f : β → α} (hf : dense_range f) : dense_range (quotient.mk ∘ f)",
    "theorem": "{α : Type u} {β : Type v} [setoid α] [topological_space α] {f : β → α} (hf : dense_range f) : dense_range (quotient.mk ∘ f)",
    "args": "{α : Type u} {β : Type v} [setoid α] [topological_space α] {f : β → α} (hf : dense_range f)",
    "doc_string": "The composition of `quotient.mk` and a function with dense range has dense range.",
    "kind": "theorem",
    "type": "dense_range (quotient.mk ∘ f)"
  },
  {
    "name": "unique_of_subsingleton",
    "statement": "def unique_of_subsingleton {α : Sort u_1} [subsingleton α] (a : α) : unique α",
    "theorem": "{α : Sort u_1} [subsingleton α] (a : α) : unique α",
    "args": "{α : Sort u_1} [subsingleton α] (a : α)",
    "doc_string": " Given an explicit `a : α` with `[subsingleton α]`, we can construct a `[unique α]` instance. This is a def because the typeclass search cannot arbitrarily invent the `a : α` term. Nevertheless, these instances are all equivalent by `unique.subsingleton.unique`.  See note [reducible non-instances].",
    "kind": "def",
    "type": "unique α"
  },
  {
    "name": "add_pos_of_nonneg_of_pos",
    "statement": "theorem add_pos_of_nonneg_of_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b)",
    "doc_string": "**Alias** of `left.add_pos_of_nonneg_of_pos`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "cycle.to_finset",
    "statement": "def cycle.to_finset {α : Type u_1} [decidable_eq α] (s : cycle α) : finset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : cycle α) : finset α",
    "args": "{α : Type u_1} [decidable_eq α] (s : cycle α)",
    "doc_string": "The `s : cycle α` as a `finset α`.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "list.arg_aux",
    "statement": "def list.arg_aux {α : Type u_1} (r : α → α → Prop) [decidable_rel r] (a : option α) (b : α) : option α",
    "theorem": "{α : Type u_1} (r : α → α → Prop) [decidable_rel r] (a : option α) (b : α) : option α",
    "args": "{α : Type u_1} (r : α → α → Prop) [decidable_rel r] (a : option α) (b : α)",
    "doc_string": "Auxiliary definition for `argmax` and `argmin`.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "is_add_unit.add_unit",
    "statement": "def is_add_unit.add_unit {M : Type u_1} [add_monoid M] {a : M} (h : is_add_unit a) : add_units M",
    "theorem": "{M : Type u_1} [add_monoid M] {a : M} (h : is_add_unit a) : add_units M",
    "args": "{M : Type u_1} [add_monoid M] {a : M} (h : is_add_unit a)",
    "doc_string": "The element of the additive group of additive units, corresponding to an element of an additive monoid which is an additive unit. When `α` is a `subtraction_monoid`, use `is_add_unit.add_unit'` instead.",
    "kind": "def",
    "type": "add_units M"
  },
  {
    "name": "max_chain_spec",
    "statement": "theorem max_chain_spec {α : Type u_1} {r : α → α → Prop} : is_max_chain r (max_chain r)",
    "theorem": "{α : Type u_1} {r : α → α → Prop} : is_max_chain r (max_chain r)",
    "args": "{α : Type u_1} {r : α → α → Prop}",
    "doc_string": " **Hausdorff's maximality principle**  There exists a maximal totally ordered set of `α`. Note that we do not require `α` to be partially ordered by `r`.",
    "kind": "theorem",
    "type": "is_max_chain r (max_chain r)"
  },
  {
    "name": "bitvec.ushr",
    "statement": "def bitvec.ushr {n : ℕ} (x : bitvec n) (i : ℕ) : bitvec n",
    "theorem": "{n : ℕ} (x : bitvec n) (i : ℕ) : bitvec n",
    "args": "{n : ℕ} (x : bitvec n) (i : ℕ)",
    "doc_string": "unsigned shift right",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "is_order_right_adjoint",
    "statement": "def is_order_right_adjoint {α : Type u_1} {β : Type u_2} [preorder α] [preorder β] (f : α → β) (g : β → α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [preorder α] [preorder β] (f : α → β) (g : β → α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [preorder α] [preorder β] (f : α → β) (g : β → α)",
    "doc_string": " We say that `g : β → α` is an order right adjoint function for `f : α → β` if it sends each `y` to a least upper bound for `{x | f x ≤ y}`. If `α` is a partial order, and `f : α → β` has a right adjoint, then this right adjoint is unique.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_modular_lattice",
    "statement": "structure is_modular_lattice (α : Type u_2) [lattice α] : Prop",
    "theorem": "(α : Type u_2) [lattice α] : Prop",
    "args": "(α : Type u_2) [lattice α]",
    "doc_string": "A modular lattice is one with a limited associativity between `⊓` and `⊔`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "tactic.pformat",
    "statement": "def tactic.pformat  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A type alias for `tactic format`, standing for \"pretty print format\".",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "metric.dist_le_diam_of_mem",
    "statement": "theorem metric.dist_le_diam_of_mem {α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : metric.bounded s) (hx : x ∈ s) (hy : y ∈ s) : has_dist.dist x y ≤ metric.diam s",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : metric.bounded s) (hx : x ∈ s) (hy : y ∈ s) : has_dist.dist x y ≤ metric.diam s",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : metric.bounded s) (hx : x ∈ s) (hy : y ∈ s)",
    "doc_string": "The distance between two points in a set is controlled by the diameter of the set.",
    "kind": "theorem",
    "type": "has_dist.dist x y ≤ metric.diam s"
  },
  {
    "name": "quiver.path.length",
    "statement": "def quiver.path.length {V : Type u} [quiver V] {a b : V} : quiver.path a b → ℕ",
    "theorem": "{V : Type u} [quiver V] {a b : V} : quiver.path a b → ℕ",
    "args": "{V : Type u} [quiver V] {a b : V}",
    "doc_string": "The length of a path is the number of arrows it uses.",
    "kind": "def",
    "type": "quiver.path a b → ℕ"
  },
  {
    "name": "cardinal.is_strong_limit",
    "statement": "def cardinal.is_strong_limit (c : cardinal) : Prop",
    "theorem": "(c : cardinal) : Prop",
    "args": "(c : cardinal)",
    "doc_string": "A cardinal is a strong limit if it is not zero and it is  closed under powersets. Note that `ℵ₀` is a strong limit by this definition.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.is_separating",
    "statement": "def category_theory.is_separating {C : Type u} [category_theory.category C] (𝒢 : set C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (𝒢 : set C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (𝒢 : set C)",
    "doc_string": "We say that `𝒢` is a separating set if the functors `C(G, -)` for `G ∈ ??` are collectively    faithful, i.e., if `h ≫ f = h ≫ g` for all `h` with domain in `𝒢` implies `f = g`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "semilattice_inf",
    "statement": "structure semilattice_inf (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A `semilattice_inf` is a meet-semilattice, that is, a partial order  with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation  `⊓` which is the greatest element smaller than both factors.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "omega.clause.holds",
    "statement": "def omega.clause.holds (v : ℕ → ℤ) : omega.clause → Prop",
    "theorem": "(v : ℕ → ℤ) : omega.clause → Prop",
    "args": "(v : ℕ → ℤ)",
    "doc_string": "holds v c := clause c holds under valuation v",
    "kind": "def",
    "type": "omega.clause → Prop"
  },
  {
    "name": "num.psub",
    "statement": "def num.psub (a b : num) : option num",
    "theorem": "(a b : num) : option num",
    "args": "(a b : num)",
    "doc_string": "Subtraction of two `num`s, producing an `option num`.",
    "kind": "def",
    "type": "option num"
  },
  {
    "name": "category_theory.subobject.wide_pullback",
    "statement": "def category_theory.subobject.wide_pullback {C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : C",
    "theorem": "{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A)) : C",
    "args": "{C : Type u₁} [category_theory.category C] [category_theory.well_powered C] [category_theory.limits.has_wide_pullbacks C] {A : C} (s : set (category_theory.subobject A))",
    "doc_string": "The limit of `wide_cospan s`. (This will be the supremum of the set of subobjects.)",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "set.has_vadd_set",
    "statement": "def set.has_vadd_set {α : Type u_2} {β : Type u_3} [has_vadd α β] : has_vadd α (set β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [has_vadd α β] : has_vadd α (set β)",
    "args": "{α : Type u_2} {β : Type u_3} [has_vadd α β]",
    "doc_string": "The translation of set `x +ᵥ s` is defined as `{x +ᵥ y | y ∈ s}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_vadd α (set β)"
  },
  {
    "name": "structomorph.refl",
    "statement": "def structomorph.refl {H : Type u} [topological_space H] {G : structure_groupoid H} (M : Type u_1) [topological_space M] [charted_space H M] [has_groupoid M G] : structomorph G M M",
    "theorem": "{H : Type u} [topological_space H] {G : structure_groupoid H} (M : Type u_1) [topological_space M] [charted_space H M] [has_groupoid M G] : structomorph G M M",
    "args": "{H : Type u} [topological_space H] {G : structure_groupoid H} (M : Type u_1) [topological_space M] [charted_space H M] [has_groupoid M G]",
    "doc_string": "The identity is a diffeomorphism of any charted space, for any groupoid.",
    "kind": "def",
    "type": "structomorph G M M"
  },
  {
    "name": "cycle.nontrivial",
    "statement": "def cycle.nontrivial {α : Type u_1} (s : cycle α) : Prop",
    "theorem": "{α : Type u_1} (s : cycle α) : Prop",
    "args": "{α : Type u_1} (s : cycle α)",
    "doc_string": "A `s : cycle α` that is made up of at least two unique elements.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lazy_list.of_list",
    "statement": "def lazy_list.of_list {α : Type u} : list α → lazy_list α",
    "theorem": "{α : Type u} : list α → lazy_list α",
    "args": "{α : Type u}",
    "doc_string": "Constructs a lazy list from a list.",
    "kind": "def",
    "type": "list α → lazy_list α"
  },
  {
    "name": "nat.partrec'.vec",
    "statement": "def nat.partrec'.vec {n m : ℕ} (f : vector ℕ n → vector ℕ m) : Prop",
    "theorem": "{n m : ℕ} (f : vector ℕ n → vector ℕ m) : Prop",
    "args": "{n m : ℕ} (f : vector ℕ n → vector ℕ m)",
    "doc_string": "Analogous to `nat.partrec'` for `ℕ`-valued functions, a predicate for partial recursive  vector-valued functions.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.grothendieck_topology.close",
    "statement": "def category_theory.grothendieck_topology.close {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : category_theory.sieve X",
    "theorem": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : category_theory.sieve X",
    "args": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X)",
    "doc_string": "The `J`-closure of a sieve is the collection of arrows which it covers.",
    "kind": "def",
    "type": "category_theory.sieve X"
  },
  {
    "name": "filter.has_mul",
    "statement": "def filter.has_mul {α : Type u_2} [has_mul α] : has_mul (filter α)",
    "theorem": "{α : Type u_2} [has_mul α] : has_mul (filter α)",
    "args": "{α : Type u_2} [has_mul α]",
    "doc_string": "The filter `f * g` is generated by `{s * t | s ∈ f, t ∈ g}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_mul (filter α)"
  },
  {
    "name": "bornology.is_bounded",
    "statement": "def bornology.is_bounded {α : Type u_2} [bornology α] (s : set α) : Prop",
    "theorem": "{α : Type u_2} [bornology α] (s : set α) : Prop",
    "args": "{α : Type u_2} [bornology α] (s : set α)",
    "doc_string": "`is_bounded` is the predicate that `s` is bounded relative to the ambient bornology on `α`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "zero_lt.left.mul_lt_one_of_lt_of_le",
    "statement": "theorem zero_lt.left.mul_lt_one_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "measure_theory.simple_func.restrict",
    "statement": "def measure_theory.simple_func.restrict {α : Type u_1} {β : Type u_2} [measurable_space α] [has_zero β] (f : measure_theory.simple_func α β) (s : set α) : measure_theory.simple_func α β",
    "theorem": "{α : Type u_1} {β : Type u_2} [measurable_space α] [has_zero β] (f : measure_theory.simple_func α β) (s : set α) : measure_theory.simple_func α β",
    "args": "{α : Type u_1} {β : Type u_2} [measurable_space α] [has_zero β] (f : measure_theory.simple_func α β) (s : set α)",
    "doc_string": " Restrict a simple function `f : α →ₛ β` to a set `s`. If `s` is measurable, then `f.restrict s a = if a ∈ s then f a else 0`, otherwise `f.restrict s = const α 0`.",
    "kind": "def",
    "type": "measure_theory.simple_func α β"
  },
  {
    "name": "matrix.to_lie_algebra",
    "statement": "def matrix.to_lie_algebra (R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ℤ) : Type (max u v)",
    "theorem": "(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ℤ) : Type (max u v)",
    "args": "(R : Type u) {B : Type v} [comm_ring R] [decidable_eq B] [fintype B] (A : matrix B B ℤ)",
    "doc_string": " The Lie algebra corresponding to a Cartan matrix.  Note that it is defined for any matrix of integers. Its value for non-Cartan matrices should be regarded as junk.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "W_type.nat_α",
    "statement": "inductive W_type.nat_α  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The constructors for the naturals",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "topological_space.generate_from",
    "statement": "def topological_space.generate_from {α : Type u} (g : set (set α)) : topological_space α",
    "theorem": "{α : Type u} (g : set (set α)) : topological_space α",
    "args": "{α : Type u} (g : set (set α))",
    "doc_string": "The smallest topological space containing the collection `g` of basic sets",
    "kind": "def",
    "type": "topological_space α"
  },
  {
    "name": "is_Gδ",
    "statement": "def is_Gδ {α : Type u_1} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u_1} [topological_space α] (s : set α)",
    "doc_string": "A Gδ set is a countable intersection of open sets.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "linear_independent",
    "statement": "def linear_independent {ι : Type u_1} (R : Type u_3) {M : Type u_5} (v : ι → M) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "theorem": "{ι : Type u_1} (R : Type u_3) {M : Type u_5} (v : ι → M) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "args": "{ι : Type u_1} (R : Type u_3) {M : Type u_5} (v : ι → M) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "`linear_independent R v` states the family of vectors `v` is linearly independent over `R`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "Top.presheaf_to_TopCommRing",
    "statement": "def Top.presheaf_to_TopCommRing (X : Top) (T : TopCommRing) : Top.presheaf CommRing X",
    "theorem": "(X : Top) (T : TopCommRing) : Top.presheaf CommRing X",
    "args": "(X : Top) (T : TopCommRing)",
    "doc_string": "The presheaf (of commutative rings), consisting of functions on an open set `U ⊆ X` with values in some topological commutative ring `T`.  For example, we could construct the presheaf of continuous complex valued functions of `X` as ```lean presheaf_to_TopCommRing X (TopCommRing.of ℂ) ``` (this requires `import topology.instances.complex`).",
    "kind": "def",
    "type": "Top.presheaf CommRing X"
  },
  {
    "name": "projective_spectrum",
    "statement": "def projective_spectrum {R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : Type u_2",
    "theorem": "{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : Type u_2",
    "args": "{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜]",
    "doc_string": "The projective spectrum of a graded commutative ring is the subtype of all homogenous ideals that are prime and do not contain the irrelevant ideal.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "category_theory.locally_small",
    "statement": "structure category_theory.locally_small (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category is `w`-locally small if every hom set is `w`-small.  See `shrink_homs C` for a category instance where every hom set has been replaced by a small model.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "sup_hom",
    "statement": "structure sup_hom (α : Type u_7) (β : Type u_8) [has_sup α] [has_sup β] : Type (max u_7 u_8)",
    "theorem": "(α : Type u_7) (β : Type u_8) [has_sup α] [has_sup β] : Type (max u_7 u_8)",
    "args": "(α : Type u_7) (β : Type u_8) [has_sup α] [has_sup β]",
    "doc_string": "The type of `⊔`-preserving functions from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8)"
  },
  {
    "name": "measure_theory.outer_measure.of_function",
    "statement": "def measure_theory.outer_measure.of_function {α : Type u_1} (m : set α → ennreal) (m_empty : m ∅ = 0) : measure_theory.outer_measure α",
    "theorem": "{α : Type u_1} (m : set α → ennreal) (m_empty : m ∅ = 0) : measure_theory.outer_measure α",
    "args": "{α : Type u_1} (m : set α → ennreal) (m_empty : m ∅ = 0)",
    "doc_string": "Given any function `m` assigning measures to sets satisying `m ∅ = 0`, there is  a unique maximal outer measure `μ` satisfying `μ s ≤ m s` for all `s : set α`.",
    "kind": "def",
    "type": "measure_theory.outer_measure α"
  },
  {
    "name": "continuous_add_subgroup",
    "statement": "def continuous_add_subgroup (α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [add_group β] [topological_add_group β] : add_subgroup (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [add_group β] [topological_add_group β] : add_subgroup (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] [add_group β] [topological_add_group β]",
    "doc_string": "The `add_subgroup` of continuous maps `α → β`.",
    "kind": "def",
    "type": "add_subgroup (α → β)"
  },
  {
    "name": "exists_lt_of_lt_csupr",
    "statement": "theorem exists_lt_of_lt_csupr {α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {b : α} [nonempty ι] {f : ι → α} (h : b < supr f) : ∃ (i : ι), b < f i",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {b : α} [nonempty ι] {f : ι → α} (h : b < supr f) : ∃ (i : ι), b < f i",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {b : α} [nonempty ι] {f : ι → α} (h : b < supr f)",
    "doc_string": "Indexed version of the above lemma `exists_lt_of_lt_cSup`. When `b < supr f`, there is an element `i` such that `b < f i`.",
    "kind": "theorem",
    "type": "∃ (i : ι), b < f i"
  },
  {
    "name": "category_theory.limits.mono_factorisation_zero",
    "statement": "def category_theory.limits.mono_factorisation_zero {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X Y : C) : category_theory.limits.mono_factorisation 0",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X Y : C) : category_theory.limits.mono_factorisation 0",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X Y : C)",
    "doc_string": "The zero morphism has a `mono_factorisation` through the zero object.",
    "kind": "def",
    "type": "category_theory.limits.mono_factorisation 0"
  },
  {
    "name": "first_order.language.complete_theory",
    "statement": "def first_order.language.complete_theory (L : first_order.language) (M : Type w) [L.Structure M] : L.Theory",
    "theorem": "(L : first_order.language) (M : Type w) [L.Structure M] : L.Theory",
    "args": "(L : first_order.language) (M : Type w) [L.Structure M]",
    "doc_string": "The complete theory of a structure `M` is the set of all sentences `M` satisfies.",
    "kind": "def",
    "type": "L.Theory"
  },
  {
    "name": "is_preconnected_Icc",
    "statement": "theorem is_preconnected_Icc {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α} : is_preconnected (set.Icc a b)",
    "theorem": "{α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α} : is_preconnected (set.Icc a b)",
    "args": "{α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α}",
    "doc_string": "A closed interval in a densely ordered conditionally complete linear order is preconnected.",
    "kind": "theorem",
    "type": "is_preconnected (set.Icc a b)"
  },
  {
    "name": "game.lf",
    "statement": "def game.lf  : game → game → Prop",
    "theorem": " : game → game → Prop",
    "args": "",
    "doc_string": " The less or fuzzy relation on games.  If `0 ⧏ x` (less or fuzzy with), then Left can win `x` as the first player.",
    "kind": "def",
    "type": "game → game → Prop"
  },
  {
    "name": "quot.factor",
    "statement": "def quot.factor {α : Type u_1} (r s : α → α → Prop) (h : ∀ (x y : α), r x y → s x y) : quot r → quot s",
    "theorem": "{α : Type u_1} (r s : α → α → Prop) (h : ∀ (x y : α), r x y → s x y) : quot r → quot s",
    "args": "{α : Type u_1} (r s : α → α → Prop) (h : ∀ (x y : α), r x y → s x y)",
    "doc_string": "Weaken the relation of a quotient. This is the same as `quot.map id`.",
    "kind": "def",
    "type": "quot r → quot s"
  },
  {
    "name": "polynomial.cyclotomic",
    "statement": "def polynomial.cyclotomic (n : ℕ) (R : Type u_1) [ring R] : polynomial R",
    "theorem": "(n : ℕ) (R : Type u_1) [ring R] : polynomial R",
    "args": "(n : ℕ) (R : Type u_1) [ring R]",
    "doc_string": "The `n`-th cyclotomic polynomial with coefficients in `R`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "list.destutter'",
    "statement": "def list.destutter' {α : Type u_1} (R : α → α → Prop) [decidable_rel R] : α → list α → list α",
    "theorem": "{α : Type u_1} (R : α → α → Prop) [decidable_rel R] : α → list α → list α",
    "args": "{α : Type u_1} (R : α → α → Prop) [decidable_rel R]",
    "doc_string": " Greedily create a sublist of `a :: l` such that, for every two adjacent elements `a, b`, `R a b` holds. Mostly used with ≠; for example, `destutter' (≠) 1 [2, 2, 1, 1] = [1, 2, 1]`, `destutter' (≠) 1, [2, 3, 3] = [1, 2, 3]`, `destutter' (<) 1 [2, 5, 2, 3, 4, 9] = [1, 2, 5, 9]`.",
    "kind": "def",
    "type": "α → list α → list α"
  },
  {
    "name": "order.pfilter.ext",
    "statement": "theorem order.pfilter.ext {P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ↑s = ↑t) : s = t",
    "theorem": "{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ↑s = ↑t) : s = t",
    "args": "{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ↑s = ↑t)",
    "doc_string": "Two filters are equal when their underlying sets are equal.",
    "kind": "theorem",
    "type": "s = t"
  },
  {
    "name": "inv_le",
    "statement": "theorem inv_le {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": " In a linear ordered field, for positive `a` and `b` we have `a⁻¹ ≤ b ↔ b⁻¹ ≤ a`. See also `inv_le_of_inv_le` for a one-sided implication with one fewer assumption.",
    "kind": "theorem",
    "type": "a⁻¹ ≤ b ↔ b⁻¹ ≤ a"
  },
  {
    "name": "free_monoid",
    "statement": "def free_monoid (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Free monoid over a given alphabet.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "locally_constant.indicator",
    "statement": "def locally_constant.indicator {X : Type u_1} [topological_space X] {R : Type u_5} [has_zero R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R",
    "theorem": "{X : Type u_1} [topological_space X] {R : Type u_5} [has_zero R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R",
    "args": "{X : Type u_1} [topological_space X] {R : Type u_5} [has_zero R] {U : set X} (f : locally_constant X R) (hU : is_clopen U)",
    "doc_string": "Given a clopen set `U` and a locally constant function `f`,  `locally_constant.indicator` returns the locally constant function that is `f` on `U` and `0`  otherwise.",
    "kind": "def",
    "type": "locally_constant X R"
  },
  {
    "name": "is_integral",
    "statement": "def is_integral (R : Type u_1) {A : Type u_3} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop",
    "theorem": "(R : Type u_1) {A : Type u_3} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop",
    "args": "(R : Type u_1) {A : Type u_3} [comm_ring R] [ring A] [algebra R A] (x : A)",
    "doc_string": " An element `x` of an algebra `A` over a commutative ring `R` is said to be *integral*, if it is a root of some monic polynomial `p : R[X]`. Equivalently, the element is integral over `R` with respect to the induced `algebra_map`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_atomic",
    "statement": "structure is_atomic (α : Type u_1) [partial_order α] [order_bot α] : Prop",
    "theorem": "(α : Type u_1) [partial_order α] [order_bot α] : Prop",
    "args": "(α : Type u_1) [partial_order α] [order_bot α]",
    "doc_string": "A lattice is atomic iff every element other than `⊥` has an atom below it.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "local_equiv.prod",
    "statement": "def local_equiv.prod {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (e : local_equiv α β) (e' : local_equiv γ δ) : local_equiv (α × γ) (β × δ)",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (e : local_equiv α β) (e' : local_equiv γ δ) : local_equiv (α × γ) (β × δ)",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (e : local_equiv α β) (e' : local_equiv γ δ)",
    "doc_string": "The product of two local equivs, as a local equiv on the product.",
    "kind": "def",
    "type": "local_equiv (α × γ) (β × δ)"
  },
  {
    "name": "right_coset_equivalence",
    "statement": "def right_coset_equivalence {α : Type u_1} [has_mul α] (s : set α) (a b : α) : Prop",
    "theorem": "{α : Type u_1} [has_mul α] (s : set α) (a b : α) : Prop",
    "args": "{α : Type u_1} [has_mul α] (s : set α) (a b : α)",
    "doc_string": "Equality of two right cosets `s * a` and `s * b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "unique_of_zero_eq_one",
    "statement": "def unique_of_zero_eq_one {M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) : unique M₀",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) : unique M₀",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1)",
    "doc_string": " In a monoid with zero, if zero equals one, then zero is the unique element.  Somewhat arbitrarily, we define the default element to be `0`. All other elements will be provably equal to it, but not necessarily definitionally equal.",
    "kind": "def",
    "type": "unique M₀"
  },
  {
    "name": "monovary",
    "statement": "def monovary {ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) : Prop",
    "theorem": "{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β) : Prop",
    "args": "{ι : Type u_1} {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (f : ι → α) (g : ι → β)",
    "doc_string": "`f` monovaries with `g` if `g i < g j` implies `f i ≤ f j`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "mul_semiring_action",
    "statement": "structure mul_semiring_action (M : Type u) (R : Type v) [monoid M] [semiring R] : Type (max u v)",
    "theorem": "(M : Type u) (R : Type v) [monoid M] [semiring R] : Type (max u v)",
    "args": "(M : Type u) (R : Type v) [monoid M] [semiring R]",
    "doc_string": " Typeclass for multiplicative actions by monoids on semirings.  This combines `distrib_mul_action` with `mul_distrib_mul_action`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "Sup_hom.id",
    "statement": "def Sup_hom.id (α : Type u_2) [has_Sup α] : Sup_hom α α",
    "theorem": "(α : Type u_2) [has_Sup α] : Sup_hom α α",
    "args": "(α : Type u_2) [has_Sup α]",
    "doc_string": "`id` as a `Sup_hom`.",
    "kind": "def",
    "type": "Sup_hom α α"
  },
  {
    "name": "first_order.language.elementary_embedding",
    "statement": "structure first_order.language.elementary_embedding (L : first_order.language) (M : Type u_3) (N : Type u_4) [L.Structure M] [L.Structure N] : Type (max u_3 u_4)",
    "theorem": "(L : first_order.language) (M : Type u_3) (N : Type u_4) [L.Structure M] [L.Structure N] : Type (max u_3 u_4)",
    "args": "(L : first_order.language) (M : Type u_3) (N : Type u_4) [L.Structure M] [L.Structure N]",
    "doc_string": "An elementary embedding of first-order structures is an embedding that commutes with the  realizations of formulas.",
    "kind": "structure",
    "type": "Type (max u_3 u_4)"
  },
  {
    "name": "multiset.erase",
    "statement": "def multiset.erase {α : Type u_1} [decidable_eq α] (s : multiset α) (a : α) : multiset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : multiset α) (a : α) : multiset α",
    "args": "{α : Type u_1} [decidable_eq α] (s : multiset α) (a : α)",
    "doc_string": "`erase s a` is the multiset that subtracts 1 from the  multiplicity of `a`.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "has_compact_support",
    "statement": "def has_compact_support {α : Type u_2} {β : Type u_4} [topological_space α] [has_zero β] (f : α → β) : Prop",
    "theorem": "{α : Type u_2} {β : Type u_4} [topological_space α] [has_zero β] (f : α → β) : Prop",
    "args": "{α : Type u_2} {β : Type u_4} [topological_space α] [has_zero β] (f : α → β)",
    "doc_string": " A function `f` *has compact support* or is *compactly supported* if the closure of the support of `f` is compact. In a T₂ space this is equivalent to `f` being equal to `0` outside a compact set.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "left.add_nonneg",
    "statement": "theorem left.add_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_nonneg`.",
    "kind": "theorem",
    "type": "0 ≤ a + b"
  },
  {
    "name": "measure_theory.outer_measure.caratheodory",
    "statement": "def measure_theory.outer_measure.caratheodory {α : Type u} (m : measure_theory.outer_measure α) : measurable_space α",
    "theorem": "{α : Type u} (m : measure_theory.outer_measure α) : measurable_space α",
    "args": "{α : Type u} (m : measure_theory.outer_measure α)",
    "doc_string": "Given an outer measure `μ`, the Carathéodory-measurable space is  defined such that `s` is measurable if `∀t, μ t = μ (t ∩ s) + μ (t \\ s)`.",
    "kind": "def",
    "type": "measurable_space α"
  },
  {
    "name": "wseq.of_stream",
    "statement": "def wseq.of_stream {α : Type u} (l : stream α) : wseq α",
    "theorem": "{α : Type u} (l : stream α) : wseq α",
    "args": "{α : Type u} (l : stream α)",
    "doc_string": "Turn a stream into a weak sequence",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "subsemiring.to_subring",
    "statement": "def subsemiring.to_subring {R : Type u} [ring R] (s : subsemiring R) (hneg : -1 ∈ s) : subring R",
    "theorem": "{R : Type u} [ring R] (s : subsemiring R) (hneg : -1 ∈ s) : subring R",
    "args": "{R : Type u} [ring R] (s : subsemiring R) (hneg : -1 ∈ s)",
    "doc_string": "A `subsemiring` containing -1 is a `subring`.",
    "kind": "def",
    "type": "subring R"
  },
  {
    "name": "ulower",
    "statement": "def ulower (α : Type u_1) [encodable α] : Type",
    "theorem": "(α : Type u_1) [encodable α] : Type",
    "args": "(α : Type u_1) [encodable α]",
    "doc_string": "`ulower α : Type` is an equivalent type in the lowest universe, given `encodable α`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "finite_dimensional.finrank_pos_iff",
    "statement": "theorem finite_dimensional.finrank_pos_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": "A finite dimensional space has positive `finrank` iff it is nontrivial.",
    "kind": "theorem",
    "type": "0 < finite_dimensional.finrank K V ↔ nontrivial V"
  },
  {
    "name": "subalgebra_of_subring",
    "statement": "def subalgebra_of_subring {R : Type u_1} [ring R] (S : subring R) : subalgebra ℤ R",
    "theorem": "{R : Type u_1} [ring R] (S : subring R) : subalgebra ℤ R",
    "args": "{R : Type u_1} [ring R] (S : subring R)",
    "doc_string": "A subring is a `ℤ`-subalgebra.",
    "kind": "def",
    "type": "subalgebra ℤ R"
  },
  {
    "name": "has_monad_lift_to_has_coe",
    "statement": "def has_monad_lift_to_has_coe {m : Type u_1 → Type u_2} {n : Type u_1 → Type u_3} [has_monad_lift_t m n] {α : Type u_1} : has_coe (m α) (n α)",
    "theorem": "{m : Type u_1 → Type u_2} {n : Type u_1 → Type u_3} [has_monad_lift_t m n] {α : Type u_1} : has_coe (m α) (n α)",
    "args": "{m : Type u_1 → Type u_2} {n : Type u_1 → Type u_3} [has_monad_lift_t m n] {α : Type u_1}",
    "doc_string": "A coercion that may reduce the need for explicit lifting.    Because of [limitations of the current coercion resolution](https://github.com/leanprover/lean/issues/1402), this definition is not marked as a global instance and should be marked locally instead.",
    "kind": "def",
    "type": "has_coe (m α) (n α)"
  },
  {
    "name": "multiset.nat.mem_antidiagonal",
    "statement": "theorem multiset.nat.mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ multiset.nat.antidiagonal n ↔ x.fst + x.snd = n",
    "theorem": "{n : ℕ} {x : ℕ × ℕ} : x ∈ multiset.nat.antidiagonal n ↔ x.fst + x.snd = n",
    "args": "{n : ℕ} {x : ℕ × ℕ}",
    "doc_string": "A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`.",
    "kind": "theorem",
    "type": "x ∈ multiset.nat.antidiagonal n ↔ x.fst + x.snd = n"
  },
  {
    "name": "hash_map.contains_aux",
    "statement": "def hash_map.contains_aux {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (l : list (Σ (a : α), β a)) : bool",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (l : list (Σ (a : α), β a)) : bool",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (l : list (Σ (a : α), β a))",
    "doc_string": "Returns `tt` if the bucket `l` contains the key `a`",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "fin.has_neg",
    "statement": "def fin.has_neg (n : ℕ) : has_neg (fin n)",
    "theorem": "(n : ℕ) : has_neg (fin n)",
    "args": "(n : ℕ)",
    "doc_string": "Negation on `fin n`",
    "kind": "def",
    "type": "has_neg (fin n)"
  },
  {
    "name": "has_inv.to_has_abs",
    "statement": "def has_inv.to_has_abs {α : Type u} [has_inv α] [has_sup α] : has_abs α",
    "theorem": "{α : Type u} [has_inv α] [has_sup α] : has_abs α",
    "args": "{α : Type u} [has_inv α] [has_sup α]",
    "doc_string": "`abs a` is the absolute value of `a`.",
    "kind": "def",
    "type": "has_abs α"
  },
  {
    "name": "algebraic_geometry.is_affine",
    "statement": "structure algebraic_geometry.is_affine (X : algebraic_geometry.Scheme) : Prop",
    "theorem": "(X : algebraic_geometry.Scheme) : Prop",
    "args": "(X : algebraic_geometry.Scheme)",
    "doc_string": "A Scheme is affine if the canonical map `X ⟶ Spec Γ(X)` is an isomorphism.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordinal.bdd_above_range",
    "statement": "theorem ordinal.bdd_above_range {ι : Type u} (f : ι → ordinal) : bdd_above (set.range f)",
    "theorem": "{ι : Type u} (f : ι → ordinal) : bdd_above (set.range f)",
    "args": "{ι : Type u} (f : ι → ordinal)",
    "doc_string": "The range of any family of ordinals is bounded above. See also `lsub_not_mem_range`.",
    "kind": "theorem",
    "type": "bdd_above (set.range f)"
  },
  {
    "name": "stream.zip",
    "statement": "def stream.zip {α : Type u} {β : Type v} {δ : Type w} (f : α → β → δ) (s₁ : stream α) (s₂ : stream β) : stream δ",
    "theorem": "{α : Type u} {β : Type v} {δ : Type w} (f : α → β → δ) (s₁ : stream α) (s₂ : stream β) : stream δ",
    "args": "{α : Type u} {β : Type v} {δ : Type w} (f : α → β → δ) (s₁ : stream α) (s₂ : stream β)",
    "doc_string": " Zip two streams using a binary operation: `stream.nth n (stream.zip f s₁ s₂) = f (stream.nth s₁) (stream.nth s₂)`.",
    "kind": "def",
    "type": "stream δ"
  },
  {
    "name": "category_theory.limits.has_binary_coproducts",
    "statement": "def category_theory.limits.has_binary_coproducts (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_binary_coproducts` represents a choice of coproduct for every pair of objects.  See <https://stacks.math.columbia.edu/tag/04AP>.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "measure_theory.simple_func.to_larger_space",
    "statement": "def measure_theory.simple_func.to_larger_space {β : Type u_6} {γ : Type u_7} {m m0 : measurable_space β} (hm : m ≤ m0) (f : measure_theory.simple_func β γ) : measure_theory.simple_func β γ",
    "theorem": "{β : Type u_6} {γ : Type u_7} {m m0 : measurable_space β} (hm : m ≤ m0) (f : measure_theory.simple_func β γ) : measure_theory.simple_func β γ",
    "args": "{β : Type u_6} {γ : Type u_7} {m m0 : measurable_space β} (hm : m ≤ m0) (f : measure_theory.simple_func β γ)",
    "doc_string": "Simple function seen as simple function of a larger `measurable_space`.",
    "kind": "def",
    "type": "measure_theory.simple_func β γ"
  },
  {
    "name": "mul_dvd_mul_iff_right",
    "statement": "theorem mul_dvd_mul_iff_right {α : Type u_1} [cancel_comm_monoid_with_zero α] {a b c : α} (hc : c ≠ 0) : a * c ∣ b * c ↔ a ∣ b",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] {a b c : α} (hc : c ≠ 0) : a * c ∣ b * c ↔ a ∣ b",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] {a b c : α} (hc : c ≠ 0)",
    "doc_string": "Given two elements `a`, `b` of a commutative `cancel_monoid_with_zero` and a nonzero  element `c`, `a*c` divides `b*c` iff `a` divides `b`.",
    "kind": "theorem",
    "type": "a * c ∣ b * c ↔ a ∣ b"
  },
  {
    "name": "extend_partial_order",
    "statement": "theorem extend_partial_order {α : Type u} (r : α → α → Prop) [is_partial_order α r] : ∃ (s : α → α → Prop) (_x : is_linear_order α s), r ≤ s",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_partial_order α r] : ∃ (s : α → α → Prop) (_x : is_linear_order α s), r ≤ s",
    "args": "{α : Type u} (r : α → α → Prop) [is_partial_order α r]",
    "doc_string": "Any partial order can be extended to a linear order.",
    "kind": "theorem",
    "type": "∃ (s : α → α → Prop) (_x : is_linear_order α s), r ≤ s"
  },
  {
    "name": "commute.mul_right",
    "statement": "theorem commute.mul_right {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)",
    "theorem": "{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)",
    "args": "{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c)",
    "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their product.",
    "kind": "theorem",
    "type": "commute a (b * c)"
  },
  {
    "name": "ordnode.find_gt_aux",
    "statement": "def ordnode.find_gt_aux {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": "Auxiliary definition for `find_gt`.",
    "kind": "def",
    "type": "ordnode α → α → α"
  },
  {
    "name": "has_finite_inter.finite_inter_closure",
    "statement": "inductive has_finite_inter.finite_inter_closure {α : Type u_1} (S : set (set α)) : set (set α)",
    "theorem": "{α : Type u_1} (S : set (set α)) : set (set α)",
    "args": "{α : Type u_1} (S : set (set α))",
    "doc_string": "The smallest set of sets containing `S` which is closed under finite intersections.",
    "kind": "inductive",
    "type": "set (set α)"
  },
  {
    "name": "sym2",
    "statement": "def sym2 (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "`sym2 α` is the symmetric square of `α`, which, in other words, is the type of unordered pairs.  It is equivalent in a natural way to multisets of cardinality 2 (see `sym2.equiv_multiset`).",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "paracompact_of_locally_compact_sigma_compact",
    "statement": "def paracompact_of_locally_compact_sigma_compact {X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] : paracompact_space X",
    "theorem": "{X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X] : paracompact_space X",
    "args": "{X : Type v} [topological_space X] [locally_compact_space X] [sigma_compact_space X] [t2_space X]",
    "doc_string": " A locally compact sigma compact Hausdorff space is paracompact. See also `refinement_of_locally_compact_sigma_compact_of_nhds_basis` for a more precise statement.",
    "kind": "def",
    "type": "paracompact_space X"
  },
  {
    "name": "ulift.encodable",
    "statement": "def ulift.encodable {α : Type u_1} [encodable α] : encodable (ulift α)",
    "theorem": "{α : Type u_1} [encodable α] : encodable (ulift α)",
    "args": "{α : Type u_1} [encodable α]",
    "doc_string": "The lift of an encodable type is encodable.",
    "kind": "def",
    "type": "encodable (ulift α)"
  },
  {
    "name": "list.modify_last",
    "statement": "def list.modify_last {α : Type u_1} (f : α → α) : list α → list α",
    "theorem": "{α : Type u_1} (f : α → α) : list α → list α",
    "args": "{α : Type u_1} (f : α → α)",
    "doc_string": "Apply `f` to the last element of `l`, if it exists.",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "local_homeomorph.symm",
    "statement": "def local_homeomorph.symm {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : local_homeomorph β α",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : local_homeomorph β α",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β)",
    "doc_string": "The inverse of a local homeomorphism",
    "kind": "def",
    "type": "local_homeomorph β α"
  },
  {
    "name": "finsum_mem_empty",
    "statement": "theorem finsum_mem_empty {α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0",
    "theorem": "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0",
    "args": "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M}",
    "doc_string": "The sum of any function over an empty set is `0`.",
    "kind": "theorem",
    "type": "finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0"
  },
  {
    "name": "finset.subtraction_monoid",
    "statement": "def finset.subtraction_monoid {α : Type u_2} [decidable_eq α] [subtraction_monoid α] : subtraction_monoid (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [subtraction_monoid α] : subtraction_monoid (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [subtraction_monoid α]",
    "doc_string": "`finset α` is a subtraction monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "subtraction_monoid (finset α)"
  },
  {
    "name": "bitvec.sshr",
    "statement": "def bitvec.sshr {m : ℕ} : bitvec m → ℕ → bitvec m",
    "theorem": "{m : ℕ} : bitvec m → ℕ → bitvec m",
    "args": "{m : ℕ}",
    "doc_string": "signed shift right",
    "kind": "def",
    "type": "bitvec m → ℕ → bitvec m"
  },
  {
    "name": "local_equiv.eq_on_source",
    "statement": "def local_equiv.eq_on_source {α : Type u_1} {β : Type u_2} (e e' : local_equiv α β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (e e' : local_equiv α β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} (e e' : local_equiv α β)",
    "doc_string": " `eq_on_source e e'` means that `e` and `e'` have the same source, and coincide there. Then `e` and `e'` should really be considered the same local equiv.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pythagorean_triple.zero",
    "statement": "theorem pythagorean_triple.zero  : pythagorean_triple 0 0 0",
    "theorem": " : pythagorean_triple 0 0 0",
    "args": "",
    "doc_string": "The zeroth Pythagorean triple is all zeros.",
    "kind": "theorem",
    "type": "pythagorean_triple 0 0 0"
  },
  {
    "name": "polynomial.trailing_monic",
    "statement": "def polynomial.trailing_monic {R : Type u} [semiring R] (p : polynomial R) : Prop",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : Prop",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": "a polynomial is `monic_at` if its trailing coefficient is 1",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.shadow",
    "statement": "def finset.shadow {α : Type u_1} [decidable_eq α] (𝒜 : finset (finset α)) : finset (finset α)",
    "theorem": "{α : Type u_1} [decidable_eq α] (𝒜 : finset (finset α)) : finset (finset α)",
    "args": "{α : Type u_1} [decidable_eq α] (𝒜 : finset (finset α))",
    "doc_string": " The shadow of a set family `𝒜` is all sets we can get by removing one element from any set in `𝒜`, and the (`k` times) iterated shadow (`shadow^[k]`) is all sets we can get by removing `k` elements from any set in `𝒜`.",
    "kind": "def",
    "type": "finset (finset α)"
  },
  {
    "name": "graded_monoid.mk",
    "statement": "def graded_monoid.mk {ι : Type u_1} {A : ι → Type u_2} (i : ι) : A i → graded_monoid A",
    "theorem": "{ι : Type u_1} {A : ι → Type u_2} (i : ι) : A i → graded_monoid A",
    "args": "{ι : Type u_1} {A : ι → Type u_2} (i : ι)",
    "doc_string": "Construct an element of a graded monoid.",
    "kind": "def",
    "type": "A i → graded_monoid A"
  },
  {
    "name": "pSet.resp",
    "statement": "def pSet.resp (n : ℕ) : Type (u+1)",
    "theorem": "(n : ℕ) : Type (u+1)",
    "args": "(n : ℕ)",
    "doc_string": "`resp n` is the collection of n-ary functions on `pSet` that respect  equivalence, i.e. when the inputs are equivalent the output is as well.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "is_coprime.ne_zero",
    "statement": "theorem is_coprime.ne_zero {R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0",
    "theorem": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0",
    "args": "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1))",
    "doc_string": "If a 2-vector `p` satisfies `is_coprime (p 0) (p 1)`, then `p ≠ 0`.",
    "kind": "theorem",
    "type": "p ≠ 0"
  },
  {
    "name": "sym2.is_diag",
    "statement": "def sym2.is_diag {α : Type u_1} : sym2 α → Prop",
    "theorem": "{α : Type u_1} : sym2 α → Prop",
    "args": "{α : Type u_1}",
    "doc_string": "A predicate for testing whether an element of `sym2 α` is on the diagonal.",
    "kind": "def",
    "type": "sym2 α → Prop"
  },
  {
    "name": "algebraic_geometry.LocallyRingedSpace.hom",
    "statement": "def algebraic_geometry.LocallyRingedSpace.hom (X Y : algebraic_geometry.LocallyRingedSpace) : Type u_1",
    "theorem": "(X Y : algebraic_geometry.LocallyRingedSpace) : Type u_1",
    "args": "(X Y : algebraic_geometry.LocallyRingedSpace)",
    "doc_string": "A morphism of locally ringed spaces is a morphism of ringed spaces such that the morphims induced on stalks are local ring homomorphisms.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "local_homeomorph.simps.apply",
    "statement": "def local_homeomorph.simps.apply {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : α → β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : α → β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β)",
    "doc_string": "See Note [custom simps projection]. We need to specify this projection explicitly in this case,  because it is a composition of multiple projections.",
    "kind": "def",
    "type": "α → β"
  },
  {
    "name": "matrix.general_linear_group",
    "statement": "def matrix.general_linear_group (n : Type u) (R : Type v) [decidable_eq n] [fintype n] [comm_ring R] : Type (max u v)",
    "theorem": "(n : Type u) (R : Type v) [decidable_eq n] [fintype n] [comm_ring R] : Type (max u v)",
    "args": "(n : Type u) (R : Type v) [decidable_eq n] [fintype n] [comm_ring R]",
    "doc_string": " `GL n R` is the group of `n` by `n` `R`-matrices with unit determinant. Defined as a subtype of matrices",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "top_hom",
    "statement": "structure top_hom (α : Type u_6) (β : Type u_7) [has_top α] [has_top β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [has_top α] [has_top β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [has_top α] [has_top β]",
    "doc_string": "The type of `⊤`-preserving functions from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "has_continuous_vadd",
    "statement": "structure has_continuous_vadd (M : Type u_1) (X : Type u_2) [has_vadd M X] [topological_space M] [topological_space X] : Prop",
    "theorem": "(M : Type u_1) (X : Type u_2) [has_vadd M X] [topological_space M] [topological_space X] : Prop",
    "args": "(M : Type u_1) (X : Type u_2) [has_vadd M X] [topological_space M] [topological_space X]",
    "doc_string": " Class `has_continuous_vadd M X` says that the additive action `(+ᵥ) : M → X → X` is continuous in both arguments. We use the same class for all kinds of additive actions, including (semi)modules and algebras.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "prod.to_sigma",
    "statement": "def prod.to_sigma {α : Type u_1} {β : Type u_2} : α × β → (Σ (_x : α), β)",
    "theorem": "{α : Type u_1} {β : Type u_2} : α × β → (Σ (_x : α), β)",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": "Convert a product type to a Σ-type.",
    "kind": "def",
    "type": "α × β → (Σ (_x : α), β)"
  },
  {
    "name": "is_simple_group_of_prime_card",
    "statement": "theorem is_simple_group_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α",
    "theorem": "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α",
    "args": "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p)",
    "doc_string": "A finite group of prime order is simple.",
    "kind": "theorem",
    "type": "is_simple_group α"
  },
  {
    "name": "free_abelian_group.support",
    "statement": "def free_abelian_group.support {X : Type u_1} (a : free_abelian_group X) : finset X",
    "theorem": "{X : Type u_1} (a : free_abelian_group X) : finset X",
    "args": "{X : Type u_1} (a : free_abelian_group X)",
    "doc_string": " `support a` for `a : free_abelian_group X` is the finite set of `x : X` that occur in the formal sum `a`.",
    "kind": "def",
    "type": "finset X"
  },
  {
    "name": "ordnode.sized",
    "statement": "def ordnode.sized {α : Type u_1} : ordnode α → Prop",
    "theorem": "{α : Type u_1} : ordnode α → Prop",
    "args": "{α : Type u_1}",
    "doc_string": " The `sized` property asserts that all the `size` fields in nodes match the actual size of the respective subtrees.",
    "kind": "def",
    "type": "ordnode α → Prop"
  },
  {
    "name": "continuous_map.homotopy_equiv",
    "statement": "structure continuous_map.homotopy_equiv (X : Type u) (Y : Type v) [topological_space X] [topological_space Y] : Type (max u v)",
    "theorem": "(X : Type u) (Y : Type v) [topological_space X] [topological_space Y] : Type (max u v)",
    "args": "(X : Type u) (Y : Type v) [topological_space X] [topological_space Y]",
    "doc_string": "A homotopy equivalence between topological spaces `X` and `Y` are a pair of functions `to_fun : C(X, Y)` and `inv_fun : C(Y, X)` such that `to_fun.comp inv_fun` and `inv_fun.comp to_fun` are both homotopic to `id`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "bool.apply_apply_apply",
    "statement": "theorem bool.apply_apply_apply (f : bool → bool) (x : bool) : f (f (f x)) = f x",
    "theorem": "(f : bool → bool) (x : bool) : f (f (f x)) = f x",
    "args": "(f : bool → bool) (x : bool)",
    "doc_string": "**Kaminski's Equation**",
    "kind": "theorem",
    "type": "f (f (f x)) = f x"
  },
  {
    "name": "has_le.le.antisymm'",
    "statement": "theorem has_le.le.antisymm' {α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → b = a",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → b = a",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of ge_antisymm`.",
    "kind": "theorem",
    "type": "a ≤ b → b ≤ a → b = a"
  },
  {
    "name": "is_invariant",
    "statement": "def is_invariant {τ : Type u_1} {α : Type u_2} (ϕ : τ → α → α) (s : set α) : Prop",
    "theorem": "{τ : Type u_1} {α : Type u_2} (ϕ : τ → α → α) (s : set α) : Prop",
    "args": "{τ : Type u_1} {α : Type u_2} (ϕ : τ → α → α) (s : set α)",
    "doc_string": "A set `s ⊆ α` is invariant under `ϕ : τ → α → α` if    `ϕ t s ⊆ s` for all `t` in `τ`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pmf.bind",
    "statement": "def pmf.bind {α : Type u_1} {β : Type u_2} (p : pmf α) (f : α → pmf β) : pmf β",
    "theorem": "{α : Type u_1} {β : Type u_2} (p : pmf α) (f : α → pmf β) : pmf β",
    "args": "{α : Type u_1} {β : Type u_2} (p : pmf α) (f : α → pmf β)",
    "doc_string": "The monadic bind operation for `pmf`.",
    "kind": "def",
    "type": "pmf β"
  },
  {
    "name": "zmod.val",
    "statement": "def zmod.val {n : ℕ} : zmod n → ℕ",
    "theorem": "{n : ℕ} : zmod n → ℕ",
    "args": "{n : ℕ}",
    "doc_string": " `val a` is a natural number defined as:   - for `a : zmod 0` it is the absolute value of `a`   - for `a : zmod n` with `0 < n` it is the least natural number in the equivalence class  See `zmod.val_min_abs` for a variant that takes values in the integers.",
    "kind": "def",
    "type": "zmod n → ℕ"
  },
  {
    "name": "pmf.support",
    "statement": "def pmf.support {α : Type u_1} (p : pmf α) : set α",
    "theorem": "{α : Type u_1} (p : pmf α) : set α",
    "args": "{α : Type u_1} (p : pmf α)",
    "doc_string": "The support of a `pmf` is the set where it is nonzero.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "filter.add_comm_monoid",
    "statement": "def filter.add_comm_monoid {α : Type u_2} [add_comm_monoid α] : add_comm_monoid (filter α)",
    "theorem": "{α : Type u_2} [add_comm_monoid α] : add_comm_monoid (filter α)",
    "args": "{α : Type u_2} [add_comm_monoid α]",
    "doc_string": "`filter α` is an `add_comm_monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_comm_monoid (filter α)"
  },
  {
    "name": "subring.gi",
    "statement": "def subring.gi (R : Type u) [ring R] : galois_insertion subring.closure coe",
    "theorem": "(R : Type u) [ring R] : galois_insertion subring.closure coe",
    "args": "(R : Type u) [ring R]",
    "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
    "kind": "def",
    "type": "galois_insertion subring.closure coe"
  },
  {
    "name": "matrix.row",
    "statement": "def matrix.row {n : Type u_3} {α : Type v} (v : n → α) : matrix unit n α",
    "theorem": "{n : Type u_3} {α : Type v} (v : n → α) : matrix unit n α",
    "args": "{n : Type u_3} {α : Type v} (v : n → α)",
    "doc_string": "`matrix.row u` is the row matrix whose entries are given by `u`.",
    "kind": "def",
    "type": "matrix unit n α"
  },
  {
    "name": "is_localization.finset_integer_multiple",
    "statement": "def is_localization.finset_integer_multiple {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] [decidable_eq R] (s : finset S) : finset R",
    "theorem": "{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] [decidable_eq R] (s : finset S) : finset R",
    "args": "{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] [decidable_eq R] (s : finset S)",
    "doc_string": "The finset of numerators after clearing the denominators of a finite set of fractions.",
    "kind": "def",
    "type": "finset R"
  },
  {
    "name": "lie_algebra.is_solvable",
    "statement": "structure lie_algebra.is_solvable (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": "A Lie algebra is solvable if its derived series reaches 0 (in a finite number of steps).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "parser.numeral.char.of_fintype",
    "statement": "def parser.numeral.char.of_fintype (α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] (fromc : char) : parser α",
    "theorem": "(α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] (fromc : char) : parser α",
    "args": "(α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] (fromc : char)",
    "doc_string": "Parse a character as a numeral while casting it to target type `α`, which has a `[fintype α]` constraint. The parser ensures that the character parsed in is greater or equal to `fromc` and and subtracts the value of `fromc` from the parsed in character. There is also a check that the resulting value is within the cardinality of the type `α`.",
    "kind": "def",
    "type": "parser α"
  },
  {
    "name": "cardinal.has_le",
    "statement": "def cardinal.has_le  : has_le cardinal",
    "theorem": " : has_le cardinal",
    "args": "",
    "doc_string": "We define the order on cardinal numbers by `#α ≤ #β` if and only if  there exists an embedding (injective function) from α to β.",
    "kind": "def",
    "type": "has_le cardinal"
  },
  {
    "name": "algebraic_closure.step",
    "statement": "def algebraic_closure.step (k : Type u) [field k] (n : ℕ) : Type u",
    "theorem": "(k : Type u) [field k] (n : ℕ) : Type u",
    "args": "(k : Type u) [field k] (n : ℕ)",
    "doc_string": "The `n`th step of constructing `algebraic_closure`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "is_add_regular",
    "statement": "structure is_add_regular {R : Type u_2} [has_add R] (c : R) : Prop",
    "theorem": "{R : Type u_2} [has_add R] (c : R) : Prop",
    "args": "{R : Type u_2} [has_add R] (c : R)",
    "doc_string": " An add-regular element is an element `c` such that addition by `c` both on the left and on the right is injective.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "continued_fraction.of_integer",
    "statement": "def continued_fraction.of_integer {α : Type u_1} [has_one α] [has_zero α] [has_lt α] (a : α) : continued_fraction α",
    "theorem": "{α : Type u_1} [has_one α] [has_zero α] [has_lt α] (a : α) : continued_fraction α",
    "args": "{α : Type u_1} [has_one α] [has_zero α] [has_lt α] (a : α)",
    "doc_string": "Constructs a continued fraction without fractional part.",
    "kind": "def",
    "type": "continued_fraction α"
  },
  {
    "name": "simple_graph.path",
    "statement": "def simple_graph.path {V : Type u} (G : simple_graph V) (u v : V) : Type u",
    "theorem": "{V : Type u} (G : simple_graph V) (u v : V) : Type u",
    "args": "{V : Type u} (G : simple_graph V) (u v : V)",
    "doc_string": "The type for paths between two vertices.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "simple_graph.common_neighbors",
    "statement": "def simple_graph.common_neighbors {V : Type u} (G : simple_graph V) (v w : V) : set V",
    "theorem": "{V : Type u} (G : simple_graph V) (v w : V) : set V",
    "args": "{V : Type u} (G : simple_graph V) (v w : V)",
    "doc_string": "The set of common neighbors between two vertices `v` and `w` in a graph `G` is the intersection of the neighbor sets of `v` and `w`.",
    "kind": "def",
    "type": "set V"
  },
  {
    "name": "is_smul_regular.subsingleton",
    "statement": "theorem is_smul_regular.subsingleton {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0)",
    "doc_string": "The element `0` is `M`-regular if and only if `M` is trivial.",
    "kind": "theorem",
    "type": "subsingleton M"
  },
  {
    "name": "option.join",
    "statement": "def option.join {α : Type u_1} : option (option α) → option α",
    "theorem": "{α : Type u_1} : option (option α) → option α",
    "args": "{α : Type u_1}",
    "doc_string": "Flatten an `option` of `option`, a specialization of `mjoin`.",
    "kind": "def",
    "type": "option (option α) → option α"
  },
  {
    "name": "free_add_monoid.of",
    "statement": "def free_add_monoid.of {α : Type u_1} (x : α) : free_add_monoid α",
    "theorem": "{α : Type u_1} (x : α) : free_add_monoid α",
    "args": "{α : Type u_1} (x : α)",
    "doc_string": "Embeds an element of `α` into `free_add_monoid α` as a singleton list.",
    "kind": "def",
    "type": "free_add_monoid α"
  },
  {
    "name": "free_semigroup.map",
    "statement": "def free_semigroup.map {α : Type u} {β : Type v} (f : α → β) : free_semigroup α → free_semigroup β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : free_semigroup α → free_semigroup β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": "The unique semigroup homomorphism that sends `of x` to `of (f x)`.",
    "kind": "def",
    "type": "free_semigroup α → free_semigroup β"
  },
  {
    "name": "topological_fiber_bundle_core.base",
    "statement": "def topological_fiber_bundle_core.base {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : Type u_2",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : Type u_2",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F)",
    "doc_string": "The base space of a topological fiber bundle core, as a convenience function for dot notation",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "ring_quot.rel",
    "statement": "inductive ring_quot.rel {R : Type u₁} [semiring R] (r : R → R → Prop) : R → R → Prop",
    "theorem": "{R : Type u₁} [semiring R] (r : R → R → Prop) : R → R → Prop",
    "args": "{R : Type u₁} [semiring R] (r : R → R → Prop)",
    "doc_string": "Given an arbitrary relation `r` on a ring, we strengthen it to a relation `rel r`, such that the equivalence relation generated by `rel r` has `x ~ y` if and only if `x - y` is in the ideal generated by elements `a - b` such that `r a b`.",
    "kind": "inductive",
    "type": "R → R → Prop"
  },
  {
    "name": "nat.min_sq_fac",
    "statement": "def nat.min_sq_fac (n : ℕ) : option ℕ",
    "theorem": "(n : ℕ) : option ℕ",
    "args": "(n : ℕ)",
    "doc_string": "Returns the smallest prime factor `p` of `n` such that `p^2 ∣ n`, or `none` if there is no  such `p` (that is, `n` is squarefree). See also `squarefree_iff_min_sq_fac`.",
    "kind": "def",
    "type": "option ℕ"
  },
  {
    "name": "ordinal.initial_seg_out",
    "statement": "def ordinal.initial_seg_out {α β : ordinal} (h : α ≤ β) : initial_seg has_lt.lt has_lt.lt",
    "theorem": "{α β : ordinal} (h : α ≤ β) : initial_seg has_lt.lt has_lt.lt",
    "args": "{α β : ordinal} (h : α ≤ β)",
    "doc_string": " Given two ordinals `α ≤ β`, then `initial_seg_out α β` is the initial segment embedding of `α` to `β`, as map from a model type for `α` to a model type for `β`.",
    "kind": "def",
    "type": "initial_seg has_lt.lt has_lt.lt"
  },
  {
    "name": "quandle.dihedral",
    "statement": "def quandle.dihedral (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": "The dihedral quandle. This is the conjugation quandle of the dihedral group restrict to flips.  Used for Fox n-colorings of knots.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "set.pairwise",
    "statement": "def set.pairwise {α : Type u_1} (s : set α) (r : α → α → Prop) : Prop",
    "theorem": "{α : Type u_1} (s : set α) (r : α → α → Prop) : Prop",
    "args": "{α : Type u_1} (s : set α) (r : α → α → Prop)",
    "doc_string": "The relation `r` holds pairwise on the set `s` if `r x y` for all *distinct* `x y ∈ s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finrank_eq_one_iff",
    "statement": "theorem finrank_eq_one_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V)",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V)",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι]",
    "doc_string": "A module has dimension 1 iff there is some `v : V` so `{v}` is a basis.",
    "kind": "theorem",
    "type": "finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V)"
  },
  {
    "name": "as_boolring",
    "statement": "def as_boolring (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Type synonym to view a Boolean ring as a Boolean algebra.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "self_adjoint.submodule",
    "statement": "def self_adjoint.submodule (R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A",
    "theorem": "(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A] : submodule R A",
    "args": "(R : Type u_1) (A : Type u_2) [semiring R] [star_semigroup R] [has_trivial_star R] [add_comm_group A] [module R A] [star_add_monoid A] [star_module R A]",
    "doc_string": "The self-adjoint elements of a star module, as a submodule.",
    "kind": "def",
    "type": "submodule R A"
  },
  {
    "name": "matrix.to_quadratic_form'",
    "statement": "def matrix.to_quadratic_form' {R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] (M : matrix n n R₁) : quadratic_form R₁ (n → R₁)",
    "theorem": "{R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] (M : matrix n n R₁) : quadratic_form R₁ (n → R₁)",
    "args": "{R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] (M : matrix n n R₁)",
    "doc_string": "`M.to_quadratic_form` is the map `λ x, col x ⬝ M ⬝ row x` as a quadratic form.",
    "kind": "def",
    "type": "quadratic_form R₁ (n → R₁)"
  },
  {
    "name": "is_of_fin_order.mul",
    "statement": "theorem is_of_fin_order.mul {G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
    "theorem": "{G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
    "args": "{G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y)",
    "doc_string": "Elements of finite order are closed under multiplication.",
    "kind": "theorem",
    "type": "is_of_fin_order (x * y)"
  },
  {
    "name": "ratfunc.zero",
    "statement": "def ratfunc.zero {K : Type u} [hring : comm_ring K] : ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] : ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K]",
    "doc_string": "The zero rational function.",
    "kind": "def",
    "type": "ratfunc K"
  },
  {
    "name": "topological_space.is_separable",
    "statement": "def topological_space.is_separable {α : Type u} [t : topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [t : topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [t : topological_space α] (s : set α)",
    "doc_string": " A set `s` in a topological space is separable if it is contained in the closure of a countable set `c`. Beware that this definition does not require that `c` is contained in `s` (to express the latter, use `separable_space s` or `is_separable (univ : set s))`. In metric spaces, the two definitions are equivalent, see `topological_space.is_separable.separable_space`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.has_neg",
    "statement": "def finset.has_neg {α : Type u_2} [decidable_eq α] [has_neg α] : has_neg (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [has_neg α] : has_neg (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [has_neg α]",
    "doc_string": "The pointwise negation of finset `-s` is defined as `{-x | x ∈ s}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_neg (finset α)"
  },
  {
    "name": "module.ray.has_neg",
    "statement": "def module.ray.has_neg (R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_neg (module.ray R M)",
    "theorem": "(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] : has_neg (module.ray R M)",
    "args": "(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M]",
    "doc_string": "Negating a ray.",
    "kind": "def",
    "type": "has_neg (module.ray R M)"
  },
  {
    "name": "finset.exists_subset_of_mem_shadow",
    "statement": "theorem finset.exists_subset_of_mem_shadow {α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} (hs : s ∈ 𝒜.shadow) : ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t",
    "theorem": "{α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} (hs : s ∈ 𝒜.shadow) : ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t",
    "args": "{α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} (hs : s ∈ 𝒜.shadow)",
    "doc_string": "Being in the shadow of `𝒜` means we have a superset in `𝒜`.",
    "kind": "theorem",
    "type": "∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t"
  },
  {
    "name": "is_antisymm",
    "statement": "structure is_antisymm (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": "`is_antisymm X r` means the binary relation `r` on `X` is antisymmetric.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_simple_order.complete_boolean_algebra",
    "statement": "def is_simple_order.complete_boolean_algebra {α : Type u_1} [lattice α] [bounded_order α] [is_simple_order α] : complete_boolean_algebra α",
    "theorem": "{α : Type u_1} [lattice α] [bounded_order α] [is_simple_order α] : complete_boolean_algebra α",
    "args": "{α : Type u_1} [lattice α] [bounded_order α] [is_simple_order α]",
    "doc_string": "A simple `bounded_order` is also a `complete_boolean_algebra`.",
    "kind": "def",
    "type": "complete_boolean_algebra α"
  },
  {
    "name": "geometry.simplicial_complex",
    "statement": "structure geometry.simplicial_complex (𝕜 : Type u_1) (E : Type u_2) [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] : Type u_2",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] : Type u_2",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E]",
    "doc_string": " A simplicial complex in a `𝕜`-module is a collection of simplices which glue nicely together. Note that the textbook meaning of \"glue nicely\" is given in `geometry.simplicial_complex.disjoint_or_exists_inter_eq_convex_hull`. It is mostly useless, as `geometry.simplicial_complex.convex_hull_inter_convex_hull` is enough for all purposes.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "is_localization.is_domain_localization",
    "statement": "theorem is_localization.is_domain_localization {A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A) : is_domain (localization M)",
    "theorem": "{A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A) : is_domain (localization M)",
    "args": "{A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A)",
    "doc_string": " The localization at of an integral domain to a set of non-zero elements is an integral domain. See note [reducible non-instances].",
    "kind": "theorem",
    "type": "is_domain (localization M)"
  },
  {
    "name": "sub_mul",
    "statement": "theorem sub_mul {α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : (a - b) * c = a * c - b * c",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : (a - b) * c = a * c - b * c",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α)",
    "doc_string": "**Alias** of mul_sub_right_distrib`.",
    "kind": "theorem",
    "type": "(a - b) * c = a * c - b * c"
  },
  {
    "name": "tactic.eliminate.constructor_argument_info",
    "statement": "structure tactic.eliminate.constructor_argument_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Information about a constructor argument. E.g. given the declaration  ```lean induction ℕ : Type | zero : ℕ | suc (n : ℕ) : ℕ ```  the `zero` constructor has no arguments and the `suc` constructor has one argument, `n`.  We record the following information:  - `aname`: the argument's name. If the argument was not explicitly named in the   declaration, the elaborator generates a name for it. - `type` : the argument's type. - `dependent`: whether the argument is dependent, i.e. whether it occurs in the   remainder of the constructor type. - `index_occurrences`: the index arguments of the constructor's return type   in which this argument occurs. If the constructor return type is   `I i₀ ... iₙ` and the argument under consideration is `a`, and `a` occurs in   `i₁` and `i₂`, then the `index_occurrences` are `1, 2`. As an additional   requirement, for `iⱼ` to be considered an index occurrences,   the type of `iⱼ` must match that of `a` according to   `index_occurrence_type_match`. - `recursive_leading_pis`: `none` if this constructor is not recursive.   Otherwise, the argument has type `Π (x₁ : T₁) ... (xₙ : Tₙ), I ...`   where `I` is the inductive type to which this constructor belongs. In this   case, `recursive_leading_pis` is `some n` with `n` the number of leading Π   binders in the argument's type.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "comp_rel",
    "statement": "def comp_rel {α : Type u} (r₁ r₂ : set (α × α)) : set (α × α)",
    "theorem": "{α : Type u} (r₁ r₂ : set (α × α)) : set (α × α)",
    "args": "{α : Type u} (r₁ r₂ : set (α × α))",
    "doc_string": "The composition of relations",
    "kind": "def",
    "type": "set (α × α)"
  },
  {
    "name": "is_ring_hom.of_semiring",
    "statement": "theorem is_ring_hom.of_semiring {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f) : is_ring_hom f",
    "theorem": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f) : is_ring_hom f",
    "args": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f)",
    "doc_string": "A map of rings that is a semiring homomorphism is also a ring homomorphism.",
    "kind": "theorem",
    "type": "is_ring_hom f"
  },
  {
    "name": "tsub_nonpos_of_le",
    "statement": "theorem tsub_nonpos_of_le {α : Type u_1} [preorder α] [add_comm_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} : a ≤ b → a - b ≤ 0",
    "theorem": "{α : Type u_1} [preorder α] [add_comm_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} : a ≤ b → a - b ≤ 0",
    "args": "{α : Type u_1} [preorder α] [add_comm_monoid α] [has_sub α] [has_ordered_sub α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of tsub_nonpos`.",
    "kind": "theorem",
    "type": "a ≤ b → a - b ≤ 0"
  },
  {
    "name": "category_theory.limits.has_binary_biproduct.of_has_binary_product",
    "statement": "theorem category_theory.limits.has_binary_biproduct.of_has_binary_product {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y]",
    "doc_string": "In a preadditive category, if the product of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists.",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_biproduct X Y"
  },
  {
    "name": "cocompact_map_class",
    "statement": "structure cocompact_map_class (F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [topological_space α] [topological_space β] : Type (max u_1 u_2 u_3)",
    "theorem": "(F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [topological_space α] [topological_space β] : Type (max u_1 u_2 u_3)",
    "args": "(F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [topological_space α] [topological_space β]",
    "doc_string": " `cocompact_map_class F α β` states that `F` is a type of cocompact continuous maps.  You should also extend this typeclass when you extend `cocompact_map`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "category_theory.limits.types.coproduct_colimit_cocone",
    "statement": "def category_theory.limits.types.coproduct_colimit_cocone {J : Type u} (F : J → Type u) : category_theory.limits.colimit_cocone (category_theory.discrete.functor F)",
    "theorem": "{J : Type u} (F : J → Type u) : category_theory.limits.colimit_cocone (category_theory.discrete.functor F)",
    "args": "{J : Type u} (F : J → Type u)",
    "doc_string": "The category of types has `Σ j, f j` as the coproduct of a type family `f : J → Type`.",
    "kind": "def",
    "type": "category_theory.limits.colimit_cocone (category_theory.discrete.functor F)"
  },
  {
    "name": "finite_dimensional.finrank_pos",
    "statement": "theorem finite_dimensional.finrank_pos {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V]",
    "doc_string": "A nontrivial finite dimensional space has positive `finrank`.",
    "kind": "theorem",
    "type": "0 < finite_dimensional.finrank K V"
  },
  {
    "name": "name_set",
    "statement": "constant name_set  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "An rb_map of `name`s.",
    "kind": "constant",
    "type": "Type"
  },
  {
    "name": "tactic.ring.horner_expr",
    "statement": "inductive tactic.ring.horner_expr  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Every expression in the language of commutative semirings can be viewed as a sum of monomials, where each monomial is a product of powers of atoms. We fix a global order on atoms (up to definitional equality), and then separate the terms according to their smallest atom. So the top level expression is `a * x^n + b` where `x` is the smallest atom and `n > 0` is a numeral, and `n` is maximal (so `a` contains at least one monomial not containing an `x`), and `b` contains no monomials with an `x` (hence all atoms in `b` are larger than `x`).  If there is no `x` satisfying these constraints, then the expression must be a numeral. Even though we are working over rings, we allow rational constants when these can be interpreted in the ring, so we can solve problems like `x / 3 = 1 / 3 * x` even though these are not technically in the language of rings.  These constraints ensure that there is a unique normal form for each ring expression, and so the algorithm is simply to calculate the normal form of each side and compare for equality.  To allow us to efficiently pattern match on normal forms, we maintain this inductive type that holds a normalized expression together with its structure. All the `expr`s in this type could be removed without loss of information, and conversely the `horner_expr` structure and the `ℕ` and `ℚ` values can be recovered from the top level `expr`, but we keep both in order to keep proof  producing normalization functions efficient.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "list.maximum",
    "statement": "def list.maximum {α : Type u_1} [preorder α] [decidable_rel has_lt.lt] (l : list α) : with_bot α",
    "theorem": "{α : Type u_1} [preorder α] [decidable_rel has_lt.lt] (l : list α) : with_bot α",
    "args": "{α : Type u_1} [preorder α] [decidable_rel has_lt.lt] (l : list α)",
    "doc_string": " `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for `[]`",
    "kind": "def",
    "type": "with_bot α"
  },
  {
    "name": "holor.cprank",
    "statement": "def holor.cprank {α : Type} {ds : list ℕ} [ring α] (x : holor α ds) : ℕ",
    "theorem": "{α : Type} {ds : list ℕ} [ring α] (x : holor α ds) : ℕ",
    "args": "{α : Type} {ds : list ℕ} [ring α] (x : holor α ds)",
    "doc_string": "The CP rank of a holor `x`: the smallest N such that  `x` can be written as the sum of N holors of rank at most 1.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "widget_override.filter_type",
    "statement": "inductive widget_override.filter_type  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Supported tactic state filters.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "is_open_map_snd",
    "statement": "theorem is_open_map_snd {α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.snd",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.snd",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β]",
    "doc_string": "The second projection in a product of topological spaces sends open sets to open sets.",
    "kind": "theorem",
    "type": "is_open_map prod.snd"
  },
  {
    "name": "int.pred",
    "statement": "def int.pred (a : ℤ) : ℤ",
    "theorem": "(a : ℤ) : ℤ",
    "args": "(a : ℤ)",
    "doc_string": "Immediate predecessor of an integer: `pred n = n - 1`",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "ordnode.raised",
    "statement": "def ordnode.raised (n m : ℕ) : Prop",
    "theorem": "(n m : ℕ) : Prop",
    "args": "(n m : ℕ)",
    "doc_string": "`raised n m` means `m` is either equal or one up from `n`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "algebra.discr",
    "statement": "def algebra.discr {ι : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] [fintype ι] (b : ι → B) : A",
    "theorem": "{ι : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] [fintype ι] (b : ι → B) : A",
    "args": "{ι : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] [fintype ι] (b : ι → B)",
    "doc_string": " Given an `A`-algebra `B` and `b`, an `ι`-indexed family of elements of `B`, we define `discr A ι b` as the determinant of `trace_matrix A ι b`.",
    "kind": "def",
    "type": "A"
  },
  {
    "name": "simple_graph.support",
    "statement": "def simple_graph.support {V : Type u} (G : simple_graph V) : set V",
    "theorem": "{V : Type u} (G : simple_graph V) : set V",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": "`G.support` is the set of vertices that form edges in `G`.",
    "kind": "def",
    "type": "set V"
  },
  {
    "name": "grade_order",
    "statement": "structure grade_order (𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)",
    "theorem": "(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α] : Type (max u_5 u_6)",
    "args": "(𝕆 : Type u_5) (α : Type u_6) [preorder 𝕆] [preorder α]",
    "doc_string": " An `𝕆`-graded order is an order `α` equipped with a strictly monotone function `grade 𝕆 : α → 𝕆` which preserves order covering (`covby`).",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "Inf_hom.id",
    "statement": "def Inf_hom.id (α : Type u_2) [has_Inf α] : Inf_hom α α",
    "theorem": "(α : Type u_2) [has_Inf α] : Inf_hom α α",
    "args": "(α : Type u_2) [has_Inf α]",
    "doc_string": "`id` as an `Inf_hom`.",
    "kind": "def",
    "type": "Inf_hom α α"
  },
  {
    "name": "polynomial.mirror",
    "statement": "def polynomial.mirror {R : Type u_1} [semiring R] (p : polynomial R) : polynomial R",
    "theorem": "{R : Type u_1} [semiring R] (p : polynomial R) : polynomial R",
    "args": "{R : Type u_1} [semiring R] (p : polynomial R)",
    "doc_string": "mirror of a polynomial: reverses the coefficients while preserving `polynomial.nat_degree`",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "function.involutive",
    "statement": "def function.involutive {α : Sort u_1} (f : α → α) : Prop",
    "theorem": "{α : Sort u_1} (f : α → α) : Prop",
    "args": "{α : Sort u_1} (f : α → α)",
    "doc_string": "A function is involutive, if `f ∘ f = id`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "tactic.alias.target",
    "statement": "inductive tactic.alias.target  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "An alias can be in one of three forms",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "stream.map",
    "statement": "def stream.map {α : Type u} {β : Type v} (f : α → β) (s : stream α) : stream β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (s : stream α) : stream β",
    "args": "{α : Type u} {β : Type v} (f : α → β) (s : stream α)",
    "doc_string": "Apply a function `f` to all elements of a stream `s`.",
    "kind": "def",
    "type": "stream β"
  },
  {
    "name": "category_theory.skeleton.monoid",
    "statement": "def category_theory.skeleton.monoid {C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : monoid (category_theory.skeleton C)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] : monoid (category_theory.skeleton C)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "The skeleton of a monoidal category can be viewed as a monoid, where the multiplication is given by the tensor product, and satisfies the monoid axioms since it is a skeleton.",
    "kind": "def",
    "type": "monoid (category_theory.skeleton C)"
  },
  {
    "name": "Mon_.forget.category_theory.reflects_isomorphisms",
    "statement": "def Mon_.forget.category_theory.reflects_isomorphisms {C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.reflects_isomorphisms (Mon_.forget C)",
    "theorem": "{C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] : category_theory.reflects_isomorphisms (Mon_.forget C)",
    "args": "{C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "The forgetful functor from monoid objects to the ambient category reflects isomorphisms.",
    "kind": "def",
    "type": "category_theory.reflects_isomorphisms (Mon_.forget C)"
  },
  {
    "name": "fin_enum.pi",
    "statement": "def fin_enum.pi {α : Type u} {β : α → Type (max u v)} [decidable_eq α] (xs : list α) : (Π (a : α), list (β a)) → list (Π (a : α), a ∈ xs → β a)",
    "theorem": "{α : Type u} {β : α → Type (max u v)} [decidable_eq α] (xs : list α) : (Π (a : α), list (β a)) → list (Π (a : α), a ∈ xs → β a)",
    "args": "{α : Type u} {β : α → Type (max u v)} [decidable_eq α] (xs : list α)",
    "doc_string": "`pi xs f` creates the list of functions `g` such that, for `x ∈ xs`, `g x ∈ f x`",
    "kind": "def",
    "type": "(Π (a : α), list (β a)) → list (Π (a : α), a ∈ xs → β a)"
  },
  {
    "name": "connected_component_setoid",
    "statement": "def connected_component_setoid (α : Type u_1) [topological_space α] : setoid α",
    "theorem": "(α : Type u_1) [topological_space α] : setoid α",
    "args": "(α : Type u_1) [topological_space α]",
    "doc_string": "The setoid of connected components of a topological space",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "is_torsion_free.prod",
    "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
    "theorem": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
    "args": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i))",
    "doc_string": "Direct products of torsion free groups are torsion free.",
    "kind": "theorem",
    "type": "monoid.is_torsion_free (Π (i : η), Gs i)"
  },
  {
    "name": "nzsnum.bit0",
    "statement": "def nzsnum.bit0  : nzsnum → nzsnum",
    "theorem": " : nzsnum → nzsnum",
    "args": "",
    "doc_string": "Add an inactive bit at the end of a `nzsnum`. This mimics `pos_num.bit0`.",
    "kind": "def",
    "type": "nzsnum → nzsnum"
  },
  {
    "name": "lie_algebra.orthogonal.Pso",
    "statement": "def lie_algebra.orthogonal.Pso (p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] (i : R) : matrix (p ⊕ q) (p ⊕ q) R",
    "theorem": "(p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] (i : R) : matrix (p ⊕ q) (p ⊕ q) R",
    "args": "(p : Type u_2) (q : Type u_3) (R : Type u₂) [decidable_eq p] [decidable_eq q] [comm_ring R] (i : R)",
    "doc_string": " A matrix for transforming the indefinite diagonal bilinear form into the definite one, provided the parameter `i` is a square root of -1.",
    "kind": "def",
    "type": "matrix (p ⊕ q) (p ⊕ q) R"
  },
  {
    "name": "continued_fraction.convergents_eq_convergents'",
    "statement": "theorem continued_fraction.convergents_eq_convergents' {K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : ↑c.convergents = ↑c.convergents'",
    "theorem": "{K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : ↑c.convergents = ↑c.convergents'",
    "args": "{K : Type u_1} [linear_ordered_field K] {c : continued_fraction K}",
    "doc_string": " Shows that the recurrence relation (`convergents`) and direct evaluation (`convergents'`) of a (regular) continued fraction coincide.",
    "kind": "theorem",
    "type": "↑c.convergents = ↑c.convergents'"
  },
  {
    "name": "one_lt_inv_of_inv",
    "statement": "theorem one_lt_inv_of_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a < 1 → 1 < a⁻¹",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a < 1 → 1 < a⁻¹",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the reverse direction of left.one_lt_inv_iff`.",
    "kind": "theorem",
    "type": "a < 1 → 1 < a⁻¹"
  },
  {
    "name": "fintype.of_bijective",
    "statement": "def fintype.of_bijective {α : Type u_1} {β : Type u_2} [fintype α] (f : α → β) (H : function.bijective f) : fintype β",
    "theorem": "{α : Type u_1} {β : Type u_2} [fintype α] (f : α → β) (H : function.bijective f) : fintype β",
    "args": "{α : Type u_1} {β : Type u_2} [fintype α] (f : α → β) (H : function.bijective f)",
    "doc_string": "If `f : α → β` is a bijection and `α` is a fintype, then `β` is also a fintype.",
    "kind": "def",
    "type": "fintype β"
  },
  {
    "name": "number_field.class_number",
    "statement": "def number_field.class_number (K : Type u_1) [field K] [number_field K] : ℕ",
    "theorem": "(K : Type u_1) [field K] [number_field K] : ℕ",
    "args": "(K : Type u_1) [field K] [number_field K]",
    "doc_string": "The class number of a number field is the (finite) cardinality of the class group.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "multiset.count",
    "statement": "def multiset.count {α : Type u_1} [decidable_eq α] (a : α) : multiset α → ℕ",
    "theorem": "{α : Type u_1} [decidable_eq α] (a : α) : multiset α → ℕ",
    "args": "{α : Type u_1} [decidable_eq α] (a : α)",
    "doc_string": "`count a s` is the multiplicity of `a` in `s`.",
    "kind": "def",
    "type": "multiset α → ℕ"
  },
  {
    "name": "pythagorean_triple.is_primitive_classified",
    "statement": "def pythagorean_triple.is_primitive_classified {x y z : ℤ} (h : pythagorean_triple x y z) : Prop",
    "theorem": "{x y z : ℤ} (h : pythagorean_triple x y z) : Prop",
    "args": "{x y z : ℤ} (h : pythagorean_triple x y z)",
    "doc_string": "A primitive pythogorean triple `x, y, z` is a pythagorean triple with `x` and `y` coprime. Such a triple is “primitively classified” if there exist coprime integers `m, n` such that either * `x = m ^ 2 - n ^ 2` and `y = 2 * m * n`, or * `x = 2 * m * n` and `y = m ^ 2 - n ^ 2`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "topological_space.separable_space",
    "statement": "structure topological_space.separable_space (α : Type u) [t : topological_space α] : Prop",
    "theorem": "(α : Type u) [t : topological_space α] : Prop",
    "args": "(α : Type u) [t : topological_space α]",
    "doc_string": " A separable space is one with a countable dense subset, available through `topological_space.exists_countable_dense`. If `α` is also known to be nonempty, then `topological_space.dense_seq` provides a sequence `ℕ → α` with dense range, see `topological_space.dense_range_dense_seq`.  If `α` is a uniform space with countably generated uniformity filter (e.g., an `emetric_space`), then this condition is equivalent to `topological_space.second_countable_topology α`. In this case the latter should be used as a typeclass argument in theorems because Lean can automatically deduce `separable_space` from `second_countable_topology` but it can't deduce `second_countable_topology` and `emetric_space`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "bump_covering.to_partition_of_unity",
    "statement": "def bump_covering.to_partition_of_unity {ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) : partition_of_unity ι X s",
    "theorem": "{ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) : partition_of_unity ι X s",
    "args": "{ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s)",
    "doc_string": " The partition of unity defined by a `bump_covering`.  The partition of unity is given by the formula `g i x = f i x * ∏ᶠ j < i, (1 - f j x)`. In other words, `g i x = ∏ᶠ j < i, (1 - f j x) - ∏ᶠ j ≤ i, (1 - f j x)`, so `∑ᶠ i, g i x = 1 - ∏ᶠ j, (1 - f j x)`. If `x ∈ s`, then one of `f j x` equals one, hence the product of `1 - f j x` vanishes, and `∑ᶠ i, g i x = 1`.  In order to avoid an assumption `linear_order ι`, we use `well_ordering_rel` instead of `(<)`.",
    "kind": "def",
    "type": "partition_of_unity ι X s"
  },
  {
    "name": "list.scanr",
    "statement": "def list.scanr {α : Type u_1} {β : Type u_2} (f : α → β → β) (b : β) (l : list α) : list β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β → β) (b : β) (l : list α) : list β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β → β) (b : β) (l : list α)",
    "doc_string": "Fold a function `f` over the list from the right, returning the list  of partial results.      scanr (+) 0 [1, 2, 3] = [6, 5, 3, 0]",
    "kind": "def",
    "type": "list β"
  },
  {
    "name": "nzsnum.sign",
    "statement": "def nzsnum.sign  : nzsnum → bool",
    "theorem": " : nzsnum → bool",
    "args": "",
    "doc_string": "Sign of a `nzsnum`.",
    "kind": "def",
    "type": "nzsnum → bool"
  },
  {
    "name": "category_theory.over.has_connected_limits",
    "statement": "def category_theory.over.has_connected_limits {J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] {B : C} [category_theory.is_connected J] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J (category_theory.over B)",
    "theorem": "{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] {B : C} [category_theory.is_connected J] [category_theory.limits.has_limits_of_shape J C] : category_theory.limits.has_limits_of_shape J (category_theory.over B)",
    "args": "{J : Type v} [category_theory.small_category J] {C : Type u} [category_theory.category C] {B : C} [category_theory.is_connected J] [category_theory.limits.has_limits_of_shape J C]",
    "doc_string": "The over category has any connected limit which the original category has.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_shape J (category_theory.over B)"
  },
  {
    "name": "first_order.language.constants",
    "statement": "def first_order.language.constants (L : first_order.language) : Type u",
    "theorem": "(L : first_order.language) : Type u",
    "args": "(L : first_order.language)",
    "doc_string": "The type of constants in a given language.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "d_array.iterate",
    "statement": "def d_array.iterate {n : ℕ} {α : fin n → Type u} {β : Type w} (a : d_array n α) (b : β) (f : Π (i : fin n), α i → β → β) : β",
    "theorem": "{n : ℕ} {α : fin n → Type u} {β : Type w} (a : d_array n α) (b : β) (f : Π (i : fin n), α i → β → β) : β",
    "args": "{n : ℕ} {α : fin n → Type u} {β : Type w} (a : d_array n α) (b : β) (f : Π (i : fin n), α i → β → β)",
    "doc_string": "Fold over the elements of the given array in ascending order. Has builtin VM implementation.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "list.many",
    "statement": "def list.many {m : Type → Type v} [monad m] {α : Type u} (p : α → m bool) : list α → m bool",
    "theorem": "{m : Type → Type v} [monad m] {α : Type u} (p : α → m bool) : list α → m bool",
    "args": "{m : Type → Type v} [monad m] {α : Type u} (p : α → m bool)",
    "doc_string": " `many p as` returns true iff `p` returns true for any element of `l`. `many` short-circuits, so if `p` returns true for any element of `l`, later elements are not checked. This is a monadic version of `list.any`.",
    "kind": "def",
    "type": "list α → m bool"
  },
  {
    "name": "odd",
    "statement": "def odd {α : Type u_2} [semiring α] (a : α) : Prop",
    "theorem": "{α : Type u_2} [semiring α] (a : α) : Prop",
    "args": "{α : Type u_2} [semiring α] (a : α)",
    "doc_string": "An element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.End.has_mul",
    "statement": "def category_theory.End.has_mul {C : Type u} [category_theory.category_struct C] (X : C) : has_mul (category_theory.End X)",
    "theorem": "{C : Type u} [category_theory.category_struct C] (X : C) : has_mul (category_theory.End X)",
    "args": "{C : Type u} [category_theory.category_struct C] (X : C)",
    "doc_string": "Multiplication of endomorphisms agrees with `function.comp`, not `category_struct.comp`.",
    "kind": "def",
    "type": "has_mul (category_theory.End X)"
  },
  {
    "name": "ring_quot.star_ring",
    "statement": "def ring_quot.star_ring {R : Type u₁} [semiring R] [star_ring R] (r : R → R → Prop) (hr : ∀ (a b : R), r a b → r (has_star.star a) (has_star.star b)) : star_ring (ring_quot r)",
    "theorem": "{R : Type u₁} [semiring R] [star_ring R] (r : R → R → Prop) (hr : ∀ (a b : R), r a b → r (has_star.star a) (has_star.star b)) : star_ring (ring_quot r)",
    "args": "{R : Type u₁} [semiring R] [star_ring R] (r : R → R → Prop) (hr : ∀ (a b : R), r a b → r (has_star.star a) (has_star.star b))",
    "doc_string": "Transfer a star_ring instance through a quotient, if the quotient is invariant to `star`",
    "kind": "def",
    "type": "star_ring (ring_quot r)"
  },
  {
    "name": "formal_multilinear_series.comp_partial_sum_target",
    "statement": "def formal_multilinear_series.comp_partial_sum_target (m M N : ℕ) : finset (Σ (n : ℕ), composition n)",
    "theorem": "(m M N : ℕ) : finset (Σ (n : ℕ), composition n)",
    "args": "(m M N : ℕ)",
    "doc_string": " Target set in the change of variables to compute the composition of partial sums of formal power series, here given a a finset. See also `comp_partial_sum`.",
    "kind": "def",
    "type": "finset (Σ (n : ℕ), composition n)"
  },
  {
    "name": "metric.bounded.union",
    "statement": "theorem metric.bounded.union {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ∪ t)",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ∪ t)",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t)",
    "doc_string": "The union of two bounded sets is bounded.",
    "kind": "theorem",
    "type": "metric.bounded (s ∪ t)"
  },
  {
    "name": "set.Ico",
    "statement": "def set.Ico {α : Type u_1} [preorder α] (a b : α) : set α",
    "theorem": "{α : Type u_1} [preorder α] (a b : α) : set α",
    "args": "{α : Type u_1} [preorder α] (a b : α)",
    "doc_string": "Left-closed right-open interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "cancel_comm_monoid",
    "statement": "structure cancel_comm_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": "Commutative version of `cancel_monoid`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "bitvec.sub",
    "statement": "def bitvec.sub {n : ℕ} (x y : bitvec n) : bitvec n",
    "theorem": "{n : ℕ} (x y : bitvec n) : bitvec n",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "The difference of two bitvectors",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "measure_theory.outer_measure.mk_metric'",
    "statement": "def measure_theory.outer_measure.mk_metric' {X : Type u_2} [emetric_space X] (m : set X → ennreal) : measure_theory.outer_measure X",
    "theorem": "{X : Type u_2} [emetric_space X] (m : set X → ennreal) : measure_theory.outer_measure X",
    "args": "{X : Type u_2} [emetric_space X] (m : set X → ennreal)",
    "doc_string": " Given a function `m : set X → ℝ≥0∞`, `mk_metric' m` is the supremum of `mk_metric'.pre m r` over `r > 0`. Equivalently, it is the limit of `mk_metric'.pre m r` as `r` tends to zero from the right.",
    "kind": "def",
    "type": "measure_theory.outer_measure X"
  },
  {
    "name": "nat.not_bdd_above_set_of_prime",
    "statement": "theorem nat.not_bdd_above_set_of_prime  : ¬bdd_above {p : ℕ | nat.prime p}",
    "theorem": " : ¬bdd_above {p : ℕ | nat.prime p}",
    "args": "",
    "doc_string": "A version of `nat.exists_infinite_primes` using the `bdd_above` predicate.",
    "kind": "theorem",
    "type": "¬bdd_above {p : ℕ | nat.prime p}"
  },
  {
    "name": "parser.sep_by",
    "statement": "def parser.sep_by {α : Type} (sep : parser unit) (p : parser α) : parser (list α)",
    "theorem": "{α : Type} (sep : parser unit) (p : parser α) : parser (list α)",
    "args": "{α : Type} (sep : parser unit) (p : parser α)",
    "doc_string": "Matches zero or more occurrences of `p`, separated by `sep`.",
    "kind": "def",
    "type": "parser (list α)"
  },
  {
    "name": "poly.const",
    "statement": "def poly.const {α : Type u_1} (n : ℤ) : poly α",
    "theorem": "{α : Type u_1} (n : ℤ) : poly α",
    "args": "{α : Type u_1} (n : ℤ)",
    "doc_string": "The constant function with value `n : ℤ`.",
    "kind": "def",
    "type": "poly α"
  },
  {
    "name": "tactic.interactive.case_tag.match_result",
    "statement": "inductive tactic.interactive.case_tag.match_result  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Indicates the result of matching a list of names against the names of a case tag. See `match_tag`.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "pos.move_left",
    "statement": "def pos.move_left (p : pos) (n : ℕ) : pos",
    "theorem": "(p : pos) (n : ℕ) : pos",
    "args": "(p : pos) (n : ℕ)",
    "doc_string": "shift `pos` `n` columns to the left",
    "kind": "def",
    "type": "pos"
  },
  {
    "name": "filter.bind",
    "statement": "def filter.bind {α : Type u} {β : Type v} (f : filter α) (m : α → filter β) : filter β",
    "theorem": "{α : Type u} {β : Type v} (f : filter α) (m : α → filter β) : filter β",
    "args": "{α : Type u} {β : Type v} (f : filter α) (m : α → filter β)",
    "doc_string": " The monadic bind operation on filter is defined the usual way in terms of `map` and `join`.  Unfortunately, this `bind` does not result in the expected applicative. See `filter.seq` for the applicative instance.",
    "kind": "def",
    "type": "filter β"
  },
  {
    "name": "one_lt_of_inv_lt_one",
    "statement": "theorem one_lt_of_inv_lt_one {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 → 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 → 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.inv_lt_one_iff`.",
    "kind": "theorem",
    "type": "a⁻¹ < 1 → 1 < a"
  },
  {
    "name": "with_zero.has_inv",
    "statement": "def with_zero.has_inv {α : Type u} [has_inv α] : has_inv (with_zero α)",
    "theorem": "{α : Type u} [has_inv α] : has_inv (with_zero α)",
    "args": "{α : Type u} [has_inv α]",
    "doc_string": "Given an inverse operation on `α` there is an inverse operation  on `with_zero α` sending `0` to `0`",
    "kind": "def",
    "type": "has_inv (with_zero α)"
  },
  {
    "name": "bitvec.adc",
    "statement": "def bitvec.adc {n : ℕ} (x y : bitvec n) (c : bool) : bitvec (n + 1)",
    "theorem": "{n : ℕ} (x y : bitvec n) (c : bool) : bitvec (n + 1)",
    "args": "{n : ℕ} (x y : bitvec n) (c : bool)",
    "doc_string": "Add with carry (no overflow)",
    "kind": "def",
    "type": "bitvec (n + 1)"
  },
  {
    "name": "padic_norm_e.one'",
    "statement": "theorem padic_norm_e.one' {p : ℕ} [fact (nat.prime p)] : padic_norm_e 1 = 1",
    "theorem": "{p : ℕ} [fact (nat.prime p)] : padic_norm_e 1 = 1",
    "args": "{p : ℕ} [fact (nat.prime p)]",
    "doc_string": " Theorems about `padic_norm_e` are named with a `'` so the names do not conflict with the equivalent theorems about `norm` (`∥ ∥`).",
    "kind": "theorem",
    "type": "padic_norm_e 1 = 1"
  },
  {
    "name": "omega.clauses.sat",
    "statement": "def omega.clauses.sat (cs : list omega.clause) : Prop",
    "theorem": "(cs : list omega.clause) : Prop",
    "args": "(cs : list omega.clause)",
    "doc_string": "There exists a satisfiable clause c in argument",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.of_fn_aux",
    "statement": "def list.of_fn_aux {α : Type u_1} {n : ℕ} (f : fin n → α) (m : ℕ) : m ≤ n → list α → list α",
    "theorem": "{α : Type u_1} {n : ℕ} (f : fin n → α) (m : ℕ) : m ≤ n → list α → list α",
    "args": "{α : Type u_1} {n : ℕ} (f : fin n → α) (m : ℕ)",
    "doc_string": "Auxliary definition used to define `of_fn`.   `of_fn_aux f m h l` returns the first `m` elements of `of_fn f`  appended to `l`",
    "kind": "def",
    "type": "m ≤ n → list α → list α"
  },
  {
    "name": "polish_space_metric",
    "statement": "def polish_space_metric (α : Type u_1) [ht : topological_space α] [h : polish_space α] : metric_space α",
    "theorem": "(α : Type u_1) [ht : topological_space α] [h : polish_space α] : metric_space α",
    "args": "(α : Type u_1) [ht : topological_space α] [h : polish_space α]",
    "doc_string": "Construct on a Polish space a metric (compatible with the topology) which is complete.",
    "kind": "def",
    "type": "metric_space α"
  },
  {
    "name": "hahn_series.support",
    "statement": "def hahn_series.support {Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] (x : hahn_series Γ R) : set Γ",
    "theorem": "{Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] (x : hahn_series Γ R) : set Γ",
    "args": "{Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] (x : hahn_series Γ R)",
    "doc_string": "The support of a Hahn series is just the set of indices whose coefficients are nonzero.  Notably, it is well-founded.",
    "kind": "def",
    "type": "set Γ"
  },
  {
    "name": "tactic.unsafe.type_context",
    "statement": "constant tactic.unsafe.type_context  : Type → Type",
    "theorem": " : Type → Type",
    "args": "",
    "doc_string": " A monad that exposes the functionality of the C++ class `type_context_old`. The idea is that the methods to `type_context` are more powerful but _unsafe_ in the sense that you can create terms that do not typecheck or that are infinitely descending. Under the hood, `type_context` is implemented as a reader monad, with a mutable `type_context` object.",
    "kind": "constant",
    "type": "Type → Type"
  },
  {
    "name": "comm_of",
    "statement": "theorem comm_of {α : Type u} (r : α → α → Prop) [is_symm α r] {a b : α} : r a b ↔ r b a",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_symm α r] {a b : α} : r a b ↔ r b a",
    "args": "{α : Type u} (r : α → α → Prop) [is_symm α r] {a b : α}",
    "doc_string": " A version of `comm` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there.",
    "kind": "theorem",
    "type": "r a b ↔ r b a"
  },
  {
    "name": "filter.seq",
    "statement": "def filter.seq {α : Type u} {β : Type v} (f : filter (α → β)) (g : filter α) : filter β",
    "theorem": "{α : Type u} {β : Type v} (f : filter (α → β)) (g : filter α) : filter β",
    "args": "{α : Type u} {β : Type v} (f : filter (α → β)) (g : filter α)",
    "doc_string": "The applicative sequentiation operation. This is not induced by the bind operation.",
    "kind": "def",
    "type": "filter β"
  },
  {
    "name": "monad_functor",
    "statement": "structure monad_functor (m m' : Type u → Type v) (n n' : Type u → Type w) : Type (max (u+1) v w)",
    "theorem": "(m m' : Type u → Type v) (n n' : Type u → Type w) : Type (max (u+1) v w)",
    "args": "(m m' : Type u → Type v) (n n' : Type u → Type w)",
    "doc_string": "A functor in the category of monads. Can be used to lift monad-transforming functions.    Based on pipes' [MFunctor](https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html),    but not restricted to monad transformers.    Alternatively, an implementation of [MonadTransFunctor](http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor).",
    "kind": "structure",
    "type": "Type (max (u+1) v w)"
  },
  {
    "name": "FinVect",
    "statement": "def FinVect (K : Type u) [field K] : Type (u+1)",
    "theorem": "(K : Type u) [field K] : Type (u+1)",
    "args": "(K : Type u) [field K]",
    "doc_string": "Define `FinVect` as the subtype of `Module.{u} K` of finite dimensional vector spaces.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "Top",
    "statement": "def Top  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of topological spaces and continuous maps.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "nat.cofinite_eq_at_top",
    "statement": "theorem nat.cofinite_eq_at_top  : filter.cofinite = filter.at_top",
    "theorem": " : filter.cofinite = filter.at_top",
    "args": "",
    "doc_string": "For natural numbers the filters `cofinite` and `at_top` coincide.",
    "kind": "theorem",
    "type": "filter.cofinite = filter.at_top"
  },
  {
    "name": "topological_space.clopens",
    "statement": "structure topological_space.clopens (α : Type u_3) [topological_space α] : Type u_3",
    "theorem": "(α : Type u_3) [topological_space α] : Type u_3",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": "The type of clopen sets of a topological space.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "subtype.encodable",
    "statement": "def subtype.encodable {α : Type u_1} {P : α → Prop} [encA : encodable α] [decP : decidable_pred P] : encodable {a // P a}",
    "theorem": "{α : Type u_1} {P : α → Prop} [encA : encodable α] [decP : decidable_pred P] : encodable {a // P a}",
    "args": "{α : Type u_1} {P : α → Prop} [encA : encodable α] [decP : decidable_pred P]",
    "doc_string": "A decidable subtype of an encodable type is encodable.",
    "kind": "def",
    "type": "encodable {a // P a}"
  },
  {
    "name": "computability.encode_bool",
    "statement": "def computability.encode_bool  : bool → list bool",
    "theorem": " : bool → list bool",
    "args": "",
    "doc_string": "An encoding function of bool in bool.",
    "kind": "def",
    "type": "bool → list bool"
  },
  {
    "name": "spectral_map",
    "statement": "structure spectral_map (α : Type u_6) (β : Type u_7) [topological_space α] [topological_space β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [topological_space α] [topological_space β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [topological_space α] [topological_space β]",
    "doc_string": "The type of spectral maps from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "star_subalgebra",
    "statement": "structure star_subalgebra (R : Type u) (A : Type v) [comm_semiring R] [star_ring R] [semiring A] [star_ring A] [algebra R A] [star_module R A] : Type v",
    "theorem": "(R : Type u) (A : Type v) [comm_semiring R] [star_ring R] [semiring A] [star_ring A] [algebra R A] [star_module R A] : Type v",
    "args": "(R : Type u) (A : Type v) [comm_semiring R] [star_ring R] [semiring A] [star_ring A] [algebra R A] [star_module R A]",
    "doc_string": "A *-subalgebra is a subalgebra of a *-algebra which is closed under *.",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "scale_roots",
    "statement": "def scale_roots {R : Type u_3} [comm_ring R] (p : polynomial R) (s : R) : polynomial R",
    "theorem": "{R : Type u_3} [comm_ring R] (p : polynomial R) (s : R) : polynomial R",
    "args": "{R : Type u_3} [comm_ring R] (p : polynomial R) (s : R)",
    "doc_string": "`scale_roots p s` is a polynomial with root `r * s` for each root `r` of `p`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "is_square.exists_sq",
    "statement": "theorem is_square.exists_sq {α : Type u_2} [monoid α] (m : α) : is_square m → (∃ (c : α), m = c ^ 2)",
    "theorem": "{α : Type u_2} [monoid α] (m : α) : is_square m → (∃ (c : α), m = c ^ 2)",
    "args": "{α : Type u_2} [monoid α] (m : α)",
    "doc_string": "**Alias** of the forward direction of is_square_iff_exists_sq`.",
    "kind": "theorem",
    "type": "is_square m → (∃ (c : α), m = c ^ 2)"
  },
  {
    "name": "one_lt_mul_of_le_of_lt'",
    "statement": "theorem one_lt_mul_of_le_of_lt' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b)",
    "doc_string": "**Alias** of left.one_lt_mul_of_le_of_lt`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "boolean_algebra.to_boolean_ring",
    "statement": "def boolean_algebra.to_boolean_ring {α : Type u_1} [boolean_algebra α] : boolean_ring α",
    "theorem": "{α : Type u_1} [boolean_algebra α] : boolean_ring α",
    "args": "{α : Type u_1} [boolean_algebra α]",
    "doc_string": " Every Boolean algebra has the structure of a Boolean ring with the following data:  * `a + b` unfolds to `a ∆ b` (symmetric difference) * `a * b` unfolds to `a ⊓ b` * `-a` unfolds to `a` * `0` unfolds to `⊥` * `1` unfolds to `⊤`",
    "kind": "def",
    "type": "boolean_ring α"
  },
  {
    "name": "uniform_space.comap",
    "statement": "def uniform_space.comap {α : Type u_1} {β : Type u_2} (f : α → β) (u : uniform_space β) : uniform_space α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (u : uniform_space β) : uniform_space α",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (u : uniform_space β)",
    "doc_string": "Given `f : α → β` and a uniformity `u` on `β`, the inverse image of `u` under `f`  is the inverse image in the filter sense of the induced function `α × α → β × β`.",
    "kind": "def",
    "type": "uniform_space α"
  },
  {
    "name": "is_max",
    "statement": "def is_max {α : Type u_1} [has_le α] (a : α) : Prop",
    "theorem": "{α : Type u_1} [has_le α] (a : α) : Prop",
    "args": "{α : Type u_1} [has_le α] (a : α)",
    "doc_string": " `a` is a maximal element of `α` if no element is strictly greater than it. We spell it without `<` to avoid having to convert between `≤` and `<`. Instead, `is_max_iff_forall_not_lt` does the conversion.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_hom.coe_fn",
    "statement": "def add_hom.coe_fn (α : Type u_1) (β : Type u_2) [has_add α] [add_comm_semigroup β] : add_hom (add_hom α β) (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [has_add α] [add_comm_semigroup β] : add_hom (add_hom α β) (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [has_add α] [add_comm_semigroup β]",
    "doc_string": "Coercion of an `add_hom` into a function is itself a `add_hom`. See also `add_hom.eval`.",
    "kind": "def",
    "type": "add_hom (add_hom α β) (α → β)"
  },
  {
    "name": "prod.non_unital_semiring",
    "statement": "def prod.non_unital_semiring {R : Type u_1} {S : Type u_3} [non_unital_semiring R] [non_unital_semiring S] : non_unital_semiring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [non_unital_semiring R] [non_unital_semiring S] : non_unital_semiring (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [non_unital_semiring R] [non_unital_semiring S]",
    "doc_string": "Product of two `non_unital_semiring`s is a `non_unital_semiring`.",
    "kind": "def",
    "type": "non_unital_semiring (R × S)"
  },
  {
    "name": "add_subgroup.relindex",
    "statement": "def add_subgroup.relindex {G : Type u_1} [add_group G] (H K : add_subgroup G) : ℕ",
    "theorem": "{G : Type u_1} [add_group G] (H K : add_subgroup G) : ℕ",
    "args": "{G : Type u_1} [add_group G] (H K : add_subgroup G)",
    "doc_string": "The relative index of a subgroup as a natural number,   and returns 0 if the relative index is infinite.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "cardinal.mk_quaternion_algebra",
    "statement": "theorem cardinal.mk_quaternion_algebra {R : Type u_1} (c₁ c₂ : R) : cardinal.mk (quaternion_algebra R c₁ c₂) = cardinal.mk R ^ 4",
    "theorem": "{R : Type u_1} (c₁ c₂ : R) : cardinal.mk (quaternion_algebra R c₁ c₂) = cardinal.mk R ^ 4",
    "args": "{R : Type u_1} (c₁ c₂ : R)",
    "doc_string": "The cardinality of a quaternion algebra, as a type.",
    "kind": "theorem",
    "type": "cardinal.mk (quaternion_algebra R c₁ c₂) = cardinal.mk R ^ 4"
  },
  {
    "name": "znum.zneg",
    "statement": "def znum.zneg  : znum → znum",
    "theorem": " : znum → znum",
    "args": "",
    "doc_string": "The negation of a `znum`.",
    "kind": "def",
    "type": "znum → znum"
  },
  {
    "name": "matrix.unitary_group",
    "statement": "def matrix.unitary_group (n : Type u) [decidable_eq n] [fintype n] (α : Type v) [comm_ring α] [star_ring α] : submonoid (matrix n n α)",
    "theorem": "(n : Type u) [decidable_eq n] [fintype n] (α : Type v) [comm_ring α] [star_ring α] : submonoid (matrix n n α)",
    "args": "(n : Type u) [decidable_eq n] [fintype n] (α : Type v) [comm_ring α] [star_ring α]",
    "doc_string": "`unitary_group n` is the group of `n` by `n` matrices where the star-transpose is the inverse.",
    "kind": "def",
    "type": "submonoid (matrix n n α)"
  },
  {
    "name": "topological_space.second_countable_topology",
    "statement": "structure topological_space.second_countable_topology (α : Type u) [t : topological_space α] : Prop",
    "theorem": "(α : Type u) [t : topological_space α] : Prop",
    "args": "(α : Type u) [t : topological_space α]",
    "doc_string": "A second-countable space is one with a countable basis.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "measure_theory.strongly_measurable.measurable",
    "statement": "theorem measure_theory.strongly_measurable.measurable {α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f)",
    "doc_string": "A strongly measurable function is measurable.",
    "kind": "theorem",
    "type": "measurable f"
  },
  {
    "name": "multiset.mem_antidiagonal",
    "statement": "theorem multiset.mem_antidiagonal {α : Type u_1} {s : multiset α} {x : multiset α × multiset α} : x ∈ s.antidiagonal ↔ x.fst + x.snd = s",
    "theorem": "{α : Type u_1} {s : multiset α} {x : multiset α × multiset α} : x ∈ s.antidiagonal ↔ x.fst + x.snd = s",
    "args": "{α : Type u_1} {s : multiset α} {x : multiset α × multiset α}",
    "doc_string": "A pair `(t₁, t₂)` of multisets is contained in `antidiagonal s`    if and only if `t₁ + t₂ = s`.",
    "kind": "theorem",
    "type": "x ∈ s.antidiagonal ↔ x.fst + x.snd = s"
  },
  {
    "name": "category_theory.discrete",
    "statement": "structure category_theory.discrete (α : Type u₁) : Type u₁",
    "theorem": "(α : Type u₁) : Type u₁",
    "args": "(α : Type u₁)",
    "doc_string": "A wrapper for promoting any type to a category, with the only morphisms being equalities.",
    "kind": "structure",
    "type": "Type u₁"
  },
  {
    "name": "convex_hull",
    "statement": "def convex_hull (𝕜 : Type u_1) {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] : closure_operator (set E)",
    "theorem": "(𝕜 : Type u_1) {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] : closure_operator (set E)",
    "args": "(𝕜 : Type u_1) {E : Type u_2} [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E]",
    "doc_string": "The convex hull of a set `s` is the minimal convex set that includes `s`.",
    "kind": "def",
    "type": "closure_operator (set E)"
  },
  {
    "name": "algebra.algebra_map_submonoid",
    "statement": "def algebra.algebra_map_submonoid {R : Type u} [comm_semiring R] (S : Type u_1) [semiring S] [algebra R S] (M : submonoid R) : submonoid S",
    "theorem": "{R : Type u} [comm_semiring R] (S : Type u_1) [semiring S] [algebra R S] (M : submonoid R) : submonoid S",
    "args": "{R : Type u} [comm_semiring R] (S : Type u_1) [semiring S] [algebra R S] (M : submonoid R)",
    "doc_string": " Explicit characterization of the submonoid map in the case of an algebra. `S` is made explicit to help with type inference",
    "kind": "def",
    "type": "submonoid S"
  },
  {
    "name": "order.pfilter.order_bot",
    "statement": "def order.pfilter.order_bot {P : Type u_1} [preorder P] [order_top P] : order_bot (order.pfilter P)",
    "theorem": "{P : Type u_1} [preorder P] [order_top P] : order_bot (order.pfilter P)",
    "args": "{P : Type u_1} [preorder P] [order_top P]",
    "doc_string": "There is a bottom filter when `P` has a top element.",
    "kind": "def",
    "type": "order_bot (order.pfilter P)"
  },
  {
    "name": "AddCommMon",
    "statement": "def AddCommMon  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of additive commutative monoids and monoid morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "nnreal.summable_condensed_iff",
    "statement": "theorem nnreal.summable_condensed_iff {f : ℕ → nnreal} (hf : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f",
    "theorem": "{f : ℕ → nnreal} (hf : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f",
    "args": "{f : ℕ → nnreal} (hf : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m)",
    "doc_string": "Cauchy condensation test for a series of `nnreal` version.",
    "kind": "theorem",
    "type": "summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f"
  },
  {
    "name": "set.Iio_subset_Iio",
    "statement": "theorem set.Iio_subset_Iio {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Iio a ⊆ set.Iio b",
    "theorem": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Iio a ⊆ set.Iio b",
    "args": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b)",
    "doc_string": " If `a ≤ b`, then `(-∞, a) ⊆ (-∞, b)`. In preorders, this is just an implication. If you need the equivalence in linear orders, use `Iio_subset_Iio_iff`.",
    "kind": "theorem",
    "type": "set.Iio a ⊆ set.Iio b"
  },
  {
    "name": "sup_bot_hom.to_bot_hom",
    "statement": "def sup_bot_hom.to_bot_hom {α : Type u_3} {β : Type u_4} [has_sup α] [has_bot α] [has_sup β] [has_bot β] (f : sup_bot_hom α β) : bot_hom α β",
    "theorem": "{α : Type u_3} {β : Type u_4} [has_sup α] [has_bot α] [has_sup β] [has_bot β] (f : sup_bot_hom α β) : bot_hom α β",
    "args": "{α : Type u_3} {β : Type u_4} [has_sup α] [has_bot α] [has_sup β] [has_bot β] (f : sup_bot_hom α β)",
    "doc_string": "Reinterpret a `sup_bot_hom` as a `bot_hom`.",
    "kind": "def",
    "type": "bot_hom α β"
  },
  {
    "name": "matrix.vec_head",
    "statement": "def matrix.vec_head {α : Type u} {n : ℕ} (v : fin n.succ → α) : α",
    "theorem": "{α : Type u} {n : ℕ} (v : fin n.succ → α) : α",
    "args": "{α : Type u} {n : ℕ} (v : fin n.succ → α)",
    "doc_string": "`vec_head v` gives the first entry of the vector `v`",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "nat.upto",
    "statement": "def nat.upto (p : ℕ → Prop) : Type",
    "theorem": "(p : ℕ → Prop) : Type",
    "args": "(p : ℕ → Prop)",
    "doc_string": " The subtype of natural numbers `i` which have the property that no `j` less than `i` satisfies `p`. This is an initial segment of the natural numbers, up to and including the first value satisfying `p`.  We will be particularly interested in the case where there exists a value satisfying `p`, because in this case the `>` relation is well-founded.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "rack.is_involutory",
    "statement": "def rack.is_involutory (R : Type u_1) [rack R] : Prop",
    "theorem": "(R : Type u_1) [rack R] : Prop",
    "args": "(R : Type u_1) [rack R]",
    "doc_string": "An involutory rack is one for which `rack.op R x` is an involution for every x.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "linear_ordered_add_comm_group_with_top",
    "statement": "structure linear_ordered_add_comm_group_with_top (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A linearly ordered commutative monoid with an additively absorbing `⊤` element.  Instances should include number systems with an infinite element adjoined.`",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "locally_constant.mul_indicator",
    "statement": "def locally_constant.mul_indicator {X : Type u_1} [topological_space X] {R : Type u_5} [has_one R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R",
    "theorem": "{X : Type u_1} [topological_space X] {R : Type u_5} [has_one R] {U : set X} (f : locally_constant X R) (hU : is_clopen U) : locally_constant X R",
    "args": "{X : Type u_1} [topological_space X] {R : Type u_5} [has_one R] {U : set X} (f : locally_constant X R) (hU : is_clopen U)",
    "doc_string": "Given a clopen set `U` and a locally constant function `f`, `locally_constant.mul_indicator`  returns the locally constant function that is `f` on `U` and `1` otherwise.",
    "kind": "def",
    "type": "locally_constant X R"
  },
  {
    "name": "derive_handler",
    "statement": "def derive_handler  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A handler that may or may not be able to implement the typeclass `cls` for `decl`.    It should return `tt` if it was able to derive `cls` and `ff` if it does not know    how to derive `cls`, in which case lower-priority handlers will be tried next.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "seq.map",
    "statement": "def seq.map {α : Type u} {β : Type v} (f : α → β) : seq α → seq β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : seq α → seq β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": "Map a function over a sequence.",
    "kind": "def",
    "type": "seq α → seq β"
  },
  {
    "name": "is_p_group",
    "statement": "def is_p_group (p : ℕ) (G : Type u_1) [group G] : Prop",
    "theorem": "(p : ℕ) (G : Type u_1) [group G] : Prop",
    "args": "(p : ℕ) (G : Type u_1) [group G]",
    "doc_string": "A p-group is a group in which every element has prime power order",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "neg_lt_self",
    "statement": "theorem neg_lt_self {α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a : α} (h : 0 < a) : -a < a",
    "theorem": "{α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a : α} (h : 0 < a) : -a < a",
    "args": "{α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a : α} (h : 0 < a)",
    "doc_string": "**Alias** of left.neg_lt_self`.",
    "kind": "theorem",
    "type": "-a < a"
  },
  {
    "name": "submonoid.mul_mem",
    "statement": "theorem submonoid.mul_mem {M : Type u_1} [mul_one_class M] (S : submonoid M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S",
    "theorem": "{M : Type u_1} [mul_one_class M] (S : submonoid M) {x y : M} : x ∈ S → y ∈ S → x * y ∈ S",
    "args": "{M : Type u_1} [mul_one_class M] (S : submonoid M) {x y : M}",
    "doc_string": "A submonoid is closed under multiplication.",
    "kind": "theorem",
    "type": "x ∈ S → y ∈ S → x * y ∈ S"
  },
  {
    "name": "is_star_normal",
    "statement": "structure is_star_normal {R : Type u_1} [has_mul R] [has_star R] (x : R) : Prop",
    "theorem": "{R : Type u_1} [has_mul R] [has_star R] (x : R) : Prop",
    "args": "{R : Type u_1} [has_mul R] [has_star R] (x : R)",
    "doc_string": "An element of a star monoid is normal if it commutes with its adjoint.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "pSet.equiv",
    "statement": "def pSet.equiv (x : pSet) (y : pSet) : Prop",
    "theorem": "(x : pSet) (y : pSet) : Prop",
    "args": "(x : pSet) (y : pSet)",
    "doc_string": " Two pre-sets are extensionally equivalent if every element of the first family is extensionally equivalent to some element of the second family and vice-versa.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "con.to_submonoid",
    "statement": "def con.to_submonoid {M : Type u_1} [mul_one_class M] : has_coe (con M) (submonoid (M × M))",
    "theorem": "{M : Type u_1} [mul_one_class M] : has_coe (con M) (submonoid (M × M))",
    "args": "{M : Type u_1} [mul_one_class M]",
    "doc_string": "Coercion from a congruence relation `c` on a monoid `M` to the submonoid of `M × M` whose    elements are `(x, y)` such that `x` is related to `y` by `c`.",
    "kind": "def",
    "type": "has_coe (con M) (submonoid (M × M))"
  },
  {
    "name": "finset.Ioi",
    "statement": "def finset.Ioi {α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : finset α",
    "theorem": "{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : finset α",
    "args": "{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α)",
    "doc_string": "The finset of elements `x` such that `a < x`. Basically `set.Ioi a` as a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "nzsnum",
    "statement": "inductive nzsnum  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "This is a nonzero (and \"non minus one\") version of `snum`.    See the documentation of `snum` for more details.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "vsub_right_injective",
    "statement": "theorem vsub_right_injective {G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (has_vsub.vsub p)",
    "theorem": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (has_vsub.vsub p)",
    "args": "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P)",
    "doc_string": " Subtracting a point from the point `p` is an injective function.",
    "kind": "theorem",
    "type": "function.injective (has_vsub.vsub p)"
  },
  {
    "name": "is_lawful_traversable",
    "statement": "structure is_lawful_traversable (t : Type u → Type u) [traversable t] : Type (u+1)",
    "theorem": "(t : Type u → Type u) [traversable t] : Type (u+1)",
    "args": "(t : Type u → Type u) [traversable t]",
    "doc_string": " A traversable functor is lawful if its `traverse` satisfies a number of additional properties.  It must send `id.mk` to `id.mk`, send the composition of applicative functors to the composition of the `traverse` of each, send each function `f` to `λ x, f <$> x`, and satisfy a naturality condition with respect to applicative transformations.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "int.lcm",
    "statement": "def int.lcm (i j : ℤ) : ℕ",
    "theorem": "(i j : ℤ) : ℕ",
    "args": "(i j : ℤ)",
    "doc_string": "ℤ specific version of least common multiple.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "gcd_monoid",
    "statement": "structure gcd_monoid (α : Type u_2) [cancel_comm_monoid_with_zero α] : Type u_2",
    "theorem": "(α : Type u_2) [cancel_comm_monoid_with_zero α] : Type u_2",
    "args": "(α : Type u_2) [cancel_comm_monoid_with_zero α]",
    "doc_string": " GCD monoid: a `cancel_comm_monoid_with_zero` with `gcd` (greatest common divisor) and `lcm` (least common multiple) operations, determined up to a unit. The type class focuses on `gcd` and we derive the corresponding `lcm` facts from `gcd`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "nat.fib_add_two",
    "statement": "theorem nat.fib_add_two {n : ℕ} : nat.fib (n + 2) = nat.fib n + nat.fib (n + 1)",
    "theorem": "{n : ℕ} : nat.fib (n + 2) = nat.fib n + nat.fib (n + 1)",
    "args": "{n : ℕ}",
    "doc_string": "Shows that `fib` indeed satisfies the Fibonacci recurrence `Fₙ₊₂ = Fₙ + Fₙ₊₁.`",
    "kind": "theorem",
    "type": "nat.fib (n + 2) = nat.fib n + nat.fib (n + 1)"
  },
  {
    "name": "is_semiring_hom.to_is_monoid_hom",
    "statement": "theorem is_semiring_hom.to_is_monoid_hom {α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f)",
    "doc_string": "A semiring homomorphism is a monoid homomorphism.",
    "kind": "theorem",
    "type": "is_monoid_hom f"
  },
  {
    "name": "add_submonoid.complete_lattice",
    "statement": "def add_submonoid.complete_lattice {M : Type u_1} [add_zero_class M] : complete_lattice (add_submonoid M)",
    "theorem": "{M : Type u_1} [add_zero_class M] : complete_lattice (add_submonoid M)",
    "args": "{M : Type u_1} [add_zero_class M]",
    "doc_string": "The `add_submonoid`s of an `add_monoid` form a complete lattice.",
    "kind": "def",
    "type": "complete_lattice (add_submonoid M)"
  },
  {
    "name": "filter.small_sets",
    "statement": "def filter.small_sets {α : Type u_1} (l : filter α) : filter (set α)",
    "theorem": "{α : Type u_1} (l : filter α) : filter (set α)",
    "args": "{α : Type u_1} (l : filter α)",
    "doc_string": "The filter `l.small_sets` is the largest filter containing all powersets of members of `l`.",
    "kind": "def",
    "type": "filter (set α)"
  },
  {
    "name": "emetric.inf_edist",
    "statement": "def emetric.inf_edist {α : Type u} [pseudo_emetric_space α] (x : α) (s : set α) : ennreal",
    "theorem": "{α : Type u} [pseudo_emetric_space α] (x : α) (s : set α) : ennreal",
    "args": "{α : Type u} [pseudo_emetric_space α] (x : α) (s : set α)",
    "doc_string": "The minimal edistance of a point to a set",
    "kind": "def",
    "type": "ennreal"
  },
  {
    "name": "subtype.is_empty_of_false",
    "statement": "theorem subtype.is_empty_of_false {α : Sort u_1} {p : α → Prop} (hp : ∀ (a : α), ¬p a) : is_empty (subtype p)",
    "theorem": "{α : Sort u_1} {p : α → Prop} (hp : ∀ (a : α), ¬p a) : is_empty (subtype p)",
    "args": "{α : Sort u_1} {p : α → Prop} (hp : ∀ (a : α), ¬p a)",
    "doc_string": "subtypes by an all-false predicate are false.",
    "kind": "theorem",
    "type": "is_empty (subtype p)"
  },
  {
    "name": "list.mmap_with_index'",
    "statement": "def list.mmap_with_index' {m : Type v → Type w} [applicative m] {α : Type u_1} (f : ℕ → α → m punit) (as : list α) : m punit",
    "theorem": "{m : Type v → Type w} [applicative m] {α : Type u_1} (f : ℕ → α → m punit) (as : list α) : m punit",
    "args": "{m : Type v → Type w} [applicative m] {α : Type u_1} (f : ℕ → α → m punit) (as : list α)",
    "doc_string": " A variant of `mmap_with_index` specialised to applicative actions which return `unit`.",
    "kind": "def",
    "type": "m punit"
  },
  {
    "name": "finset.sym2",
    "statement": "def finset.sym2 {α : Type u_1} [decidable_eq α] (s : finset α) : finset (sym2 α)",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : finset α) : finset (sym2 α)",
    "args": "{α : Type u_1} [decidable_eq α] (s : finset α)",
    "doc_string": "Lifts a finset to `sym2 α`. `s.sym2` is the finset of all pairs with elements in `s`.",
    "kind": "def",
    "type": "finset (sym2 α)"
  },
  {
    "name": "quiver.wide_subquiver_symmetrify",
    "statement": "def quiver.wide_subquiver_symmetrify {V : Type u} [quiver V] (H : wide_subquiver (quiver.symmetrify V)) : wide_subquiver V",
    "theorem": "{V : Type u} [quiver V] (H : wide_subquiver (quiver.symmetrify V)) : wide_subquiver V",
    "args": "{V : Type u} [quiver V] (H : wide_subquiver (quiver.symmetrify V))",
    "doc_string": "A wide subquiver `H` of `G.symmetrify` determines a wide subquiver of `G`, containing an    an arrow `e` if either `e` or its reversal is in `H`.",
    "kind": "def",
    "type": "wide_subquiver V"
  },
  {
    "name": "ideal.span",
    "statement": "def ideal.span {α : Type u} [semiring α] (s : set α) : ideal α",
    "theorem": "{α : Type u} [semiring α] (s : set α) : ideal α",
    "args": "{α : Type u} [semiring α] (s : set α)",
    "doc_string": "The ideal generated by a subset of a ring",
    "kind": "def",
    "type": "ideal α"
  },
  {
    "name": "composition.to_composition_as_set",
    "statement": "def composition.to_composition_as_set {n : ℕ} (c : composition n) : composition_as_set n",
    "theorem": "{n : ℕ} (c : composition n) : composition_as_set n",
    "args": "{n : ℕ} (c : composition n)",
    "doc_string": " To `c : composition n`, one can associate a `composition_as_set n` by registering the leftmost point of each block, and adding a virtual point at the right of the last block.",
    "kind": "def",
    "type": "composition_as_set n"
  },
  {
    "name": "bilin_form.self_adjoint_submodule",
    "statement": "def bilin_form.self_adjoint_submodule {R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] (B₂ : bilin_form R₂ M₂) : submodule R₂ (module.End R₂ M₂)",
    "theorem": "{R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] (B₂ : bilin_form R₂ M₂) : submodule R₂ (module.End R₂ M₂)",
    "args": "{R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] (B₂ : bilin_form R₂ M₂)",
    "doc_string": " The set of self-adjoint endomorphisms of a module with bilinear form is a submodule. (In fact it is a Jordan subalgebra.)",
    "kind": "def",
    "type": "submodule R₂ (module.End R₂ M₂)"
  },
  {
    "name": "iff",
    "statement": "structure iff (a b : Prop) : Prop",
    "theorem": "(a b : Prop) : Prop",
    "args": "(a b : Prop)",
    "doc_string": " `iff P Q`, with notation `P ↔ Q`, is the proposition asserting that `P` and `Q` are equivalent, that is, have the same truth value.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "lower_adjoint.closure_operator",
    "statement": "def lower_adjoint.closure_operator {α : Type u_1} {β : Type u_4} [partial_order α] [preorder β] {u : β → α} (l : lower_adjoint u) : closure_operator α",
    "theorem": "{α : Type u_1} {β : Type u_4} [partial_order α] [preorder β] {u : β → α} (l : lower_adjoint u) : closure_operator α",
    "args": "{α : Type u_1} {β : Type u_4} [partial_order α] [preorder β] {u : β → α} (l : lower_adjoint u)",
    "doc_string": " Every lower adjoint induces a closure operator given by the composition. This is the partial order version of the statement that every adjunction induces a monad.",
    "kind": "def",
    "type": "closure_operator α"
  },
  {
    "name": "finset.centroid_weights_indicator",
    "statement": "def finset.centroid_weights_indicator (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : ι → k",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : ι → k",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι)",
    "doc_string": " `centroid_weights` gives the weights for the centroid as a constant function, which is suitable when summing over the points whose centroid is being taken.  This function gives the weights in a form suitable for summing over a larger set of points, as an indicator function that is zero outside the set whose centroid is being taken. In the case of a `fintype`, the sum may be over `univ`.",
    "kind": "def",
    "type": "ι → k"
  },
  {
    "name": "exponent_exists.is_torsion",
    "statement": "theorem exponent_exists.is_torsion {G : Type u_1} [group G] (h : monoid.exponent_exists G) : monoid.is_torsion G",
    "theorem": "{G : Type u_1} [group G] (h : monoid.exponent_exists G) : monoid.is_torsion G",
    "args": "{G : Type u_1} [group G] (h : monoid.exponent_exists G)",
    "doc_string": "If a group exponent exists, the group is torsion.",
    "kind": "theorem",
    "type": "monoid.is_torsion G"
  },
  {
    "name": "category_theory.InjectiveResolution",
    "statement": "structure category_theory.InjectiveResolution {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C)",
    "doc_string": "An `InjectiveResolution Z` consists of a bundled `ℕ`-indexed cochain complex of injective objects, along with a quasi-isomorphism to the complex consisting of just `Z` supported in degree `0`.  Except in situations where you want to provide a particular injective resolution (for example to compute a derived functor), you will not typically need to use this bundled object, and will instead use * `injective_resolution Z`: the `ℕ`-indexed cochain complex   (equipped with `injective` and `exact` instances) * `injective_resolution.ι Z`: the cochain map from  `(single C _ 0).obj Z` to   `injective_resolution Z` (all the components are equipped with `mono` instances,   and when the category is `abelian` we will show `ι` is a quasi-iso).",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "add_submonoid.zero_mem",
    "statement": "theorem add_submonoid.zero_mem {M : Type u_1} [add_zero_class M] (S : add_submonoid M) : 0 ∈ S",
    "theorem": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M) : 0 ∈ S",
    "args": "{M : Type u_1} [add_zero_class M] (S : add_submonoid M)",
    "doc_string": "An `add_submonoid` contains the monoid's 0.",
    "kind": "theorem",
    "type": "0 ∈ S"
  },
  {
    "name": "laurent_series.power_series_part",
    "statement": "def laurent_series.power_series_part {R : Type u} [semiring R] (x : laurent_series R) : power_series R",
    "theorem": "{R : Type u} [semiring R] (x : laurent_series R) : power_series R",
    "args": "{R : Type u} [semiring R] (x : laurent_series R)",
    "doc_string": "This is a power series that can be multiplied by an integer power of `X` to give our  Laurent series. If the Laurent series is nonzero, `power_series_part` has a nonzero  constant term.",
    "kind": "def",
    "type": "power_series R"
  },
  {
    "name": "category_theory.monad.id",
    "statement": "def category_theory.monad.id (C : Type u₁) [category_theory.category C] : category_theory.monad C",
    "theorem": "(C : Type u₁) [category_theory.category C] : category_theory.monad C",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": "The identity monad.",
    "kind": "def",
    "type": "category_theory.monad C"
  },
  {
    "name": "exceptional",
    "statement": "inductive exceptional (α : Type) : Type",
    "theorem": "(α : Type) : Type",
    "args": "(α : Type)",
    "doc_string": "An exceptional is similar to `Result` in Haskell.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "matrix.circulant",
    "statement": "def matrix.circulant {α : Type u_1} {n : Type u_4} [has_sub n] (v : n → α) : matrix n n α",
    "theorem": "{α : Type u_1} {n : Type u_4} [has_sub n] (v : n → α) : matrix n n α",
    "args": "{α : Type u_1} {n : Type u_4} [has_sub n] (v : n → α)",
    "doc_string": "Given the condition `[has_sub n]` and a vector `v : n → α`,    we define `circulant v` to be the circulant matrix generated by `v` of type `matrix n n α`.    The `(i,j)`th entry is defined to be `v (i - j)`.",
    "kind": "def",
    "type": "matrix n n α"
  },
  {
    "name": "tactic.tauto_cfg",
    "statement": "structure tactic.tauto_cfg  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration options for `tauto`. If `classical` is `tt`, runs `classical` before the rest of `tauto`. `closer` is run on any remaining subgoals left by `tauto_core; basic_tauto_tacs`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "measure_theory.finite_measure",
    "statement": "def measure_theory.finite_measure (α : Type u_1) [measurable_space α] : Type u_1",
    "theorem": "(α : Type u_1) [measurable_space α] : Type u_1",
    "args": "(α : Type u_1) [measurable_space α]",
    "doc_string": " Finite measures are defined as the subtype of measures that have the property of being finite measures (i.e., their total mass is finite).",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "is_free_groupoid.generators",
    "statement": "def is_free_groupoid.generators (G : Type u_1) [category_theory.groupoid G] : Type u_1",
    "theorem": "(G : Type u_1) [category_theory.groupoid G] : Type u_1",
    "args": "(G : Type u_1) [category_theory.groupoid G]",
    "doc_string": " `is_free_groupoid.generators G` is a type synonym for `G`. We think of this as the vertices of the generating quiver of `G` when `G` is free. We can't use `G` directly, since `G` already has a quiver instance from being a groupoid.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "number_field",
    "statement": "structure number_field (K : Type u_1) [field K] : Prop",
    "theorem": "(K : Type u_1) [field K] : Prop",
    "args": "(K : Type u_1) [field K]",
    "doc_string": " A number field is a field which has characteristic zero and is finite dimensional over ℚ.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "inf_top_hom_class",
    "statement": "structure inf_top_hom_class (F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_inf α] [has_inf β] [has_top α] [has_top β] : Type (max u_7 u_8 u_9)",
    "theorem": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_inf α] [has_inf β] [has_top α] [has_top β] : Type (max u_7 u_8 u_9)",
    "args": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_inf α] [has_inf β] [has_top α] [has_top β]",
    "doc_string": " `inf_top_hom_class F α β` states that `F` is a type of finitary infimum-preserving morphisms.  You should extend this class when you extend `sup_bot_hom`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8 u_9)"
  },
  {
    "name": "tactic.ring_exp.sum_congr",
    "statement": "theorem tactic.ring_exp.sum_congr {α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p + ps = p' + ps'",
    "theorem": "{α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p + ps = p' + ps'",
    "args": "{α : Type u} [comm_semiring α] {p p' ps ps' : α}",
    "doc_string": "Congruence lemma for constructing `ex.sum`.",
    "kind": "theorem",
    "type": "p = p' → ps = ps' → p + ps = p' + ps'"
  },
  {
    "name": "Exists.some",
    "statement": "def Exists.some {α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : α",
    "theorem": "{α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : α",
    "args": "{α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a)",
    "doc_string": "Extract an element from a existential statement, using `classical.some`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "nat.eq_one_of_dvd_coprimes",
    "statement": "theorem nat.eq_one_of_dvd_coprimes {a b k : ℕ} (h_ab_coprime : a.coprime b) (hka : k ∣ a) (hkb : k ∣ b) : k = 1",
    "theorem": "{a b k : ℕ} (h_ab_coprime : a.coprime b) (hka : k ∣ a) (hkb : k ∣ b) : k = 1",
    "args": "{a b k : ℕ} (h_ab_coprime : a.coprime b) (hka : k ∣ a) (hkb : k ∣ b)",
    "doc_string": "If `k:ℕ` divides coprime `a` and `b` then `k = 1`",
    "kind": "theorem",
    "type": "k = 1"
  },
  {
    "name": "indexed_partition.inhabited",
    "statement": "def indexed_partition.inhabited {ι : Type u_1} {α : Type u_2} [unique ι] [inhabited α] : inhabited (indexed_partition (λ (i : ι), set.univ))",
    "theorem": "{ι : Type u_1} {α : Type u_2} [unique ι] [inhabited α] : inhabited (indexed_partition (λ (i : ι), set.univ))",
    "args": "{ι : Type u_1} {α : Type u_2} [unique ι] [inhabited α]",
    "doc_string": "On a unique index set there is the obvious trivial partition",
    "kind": "def",
    "type": "inhabited (indexed_partition (λ (i : ι), set.univ))"
  },
  {
    "name": "finset.mem_slice",
    "statement": "theorem finset.mem_slice {α : Type u_1} {𝒜 : finset (finset α)} {A : finset α} {r : ℕ} : A ∈ 𝒜.slice r ↔ A ∈ 𝒜 ∧ A.card = r",
    "theorem": "{α : Type u_1} {𝒜 : finset (finset α)} {A : finset α} {r : ℕ} : A ∈ 𝒜.slice r ↔ A ∈ 𝒜 ∧ A.card = r",
    "args": "{α : Type u_1} {𝒜 : finset (finset α)} {A : finset α} {r : ℕ}",
    "doc_string": "`A` is in the `r`-th slice of `𝒜` iff it's in `𝒜` and has cardinality `r`.",
    "kind": "theorem",
    "type": "A ∈ 𝒜.slice r ↔ A ∈ 𝒜 ∧ A.card = r"
  },
  {
    "name": "submodule.has_div",
    "statement": "def submodule.has_div {R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : has_div (submodule R A)",
    "theorem": "{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A] : has_div (submodule R A)",
    "args": "{R : Type u} [comm_semiring R] {A : Type v} [comm_semiring A] [algebra R A]",
    "doc_string": " The elements of `I / J` are the `x` such that `x • J ⊆ I`.  In fact, we define `x ∈ I / J` to be `∀ y ∈ J, x * y ∈ I` (see `mem_div_iff_forall_mul_mem`), which is equivalent to `x • J ⊆ I` (see `mem_div_iff_smul_subset`), but nicer to use in proofs.  This is the general form of the ideal quotient, traditionally written $I : J$.",
    "kind": "def",
    "type": "has_div (submodule R A)"
  },
  {
    "name": "quotient.choice",
    "statement": "def quotient.choice {ι : Type u_1} {α : ι → Type u_2} [S : Π (i : ι), setoid (α i)] (f : Π (i : ι), quotient (S i)) : quotient pi_setoid",
    "theorem": "{ι : Type u_1} {α : ι → Type u_2} [S : Π (i : ι), setoid (α i)] (f : Π (i : ι), quotient (S i)) : quotient pi_setoid",
    "args": "{ι : Type u_1} {α : ι → Type u_2} [S : Π (i : ι), setoid (α i)] (f : Π (i : ι), quotient (S i))",
    "doc_string": " Given a function `f : Π i, quotient (S i)`, returns the class of functions `Π i, α i` sending each `i` to an element of the class `f i`.",
    "kind": "def",
    "type": "quotient pi_setoid"
  },
  {
    "name": "triv_sq_zero_ext.inr",
    "statement": "def triv_sq_zero_ext.inr {R : Type u} {M : Type v} [has_zero R] (m : M) : triv_sq_zero_ext R M",
    "theorem": "{R : Type u} {M : Type v} [has_zero R] (m : M) : triv_sq_zero_ext R M",
    "args": "{R : Type u} {M : Type v} [has_zero R] (m : M)",
    "doc_string": "The canonical inclusion `M → triv_sq_zero_ext R M`.",
    "kind": "def",
    "type": "triv_sq_zero_ext R M"
  },
  {
    "name": "free_group",
    "statement": "def free_group (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " The free group over a type, i.e. the words formed by the elements of the type and their formal inverses, quotient by one step reduction.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "list.subperm",
    "statement": "def list.subperm {α : Type uu} (l₁ l₂ : list α) : Prop",
    "theorem": "{α : Type uu} (l₁ l₂ : list α) : Prop",
    "args": "{α : Type uu} (l₁ l₂ : list α)",
    "doc_string": "`subperm l₁ l₂`, denoted `l₁ <+~ l₂`, means that `l₁` is a sublist of  a permutation of `l₂`. This is an analogue of `l₁ ⊆ l₂` which respects  multiplicities of elements, and is used for the `≤` relation on multisets.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pnat.xgcd_type.is_special",
    "statement": "def pnat.xgcd_type.is_special (u : pnat.xgcd_type) : Prop",
    "theorem": "(u : pnat.xgcd_type) : Prop",
    "args": "(u : pnat.xgcd_type)",
    "doc_string": "is_special holds if the matrix has determinant one.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.zip_with3",
    "statement": "def list.zip_with3 {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (f : α → β → γ → δ) : list α → list β → list γ → list δ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (f : α → β → γ → δ) : list α → list β → list γ → list δ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (f : α → β → γ → δ)",
    "doc_string": "Ternary version of `list.zip_with`.",
    "kind": "def",
    "type": "list α → list β → list γ → list δ"
  },
  {
    "name": "order_dual",
    "statement": "def order_dual (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " Type synonym to equip a type with the dual order: `≤` means `≥` and `<` means `>`. `αᵒᵈ` is notation for `order_dual α`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "is_smul_regular_of_group",
    "statement": "theorem is_smul_regular_of_group {R : Type u_1} {G : Type u_4} [group G] [mul_action G R] (g : G) : is_smul_regular R g",
    "theorem": "{R : Type u_1} {G : Type u_4} [group G] [mul_action G R] (g : G) : is_smul_regular R g",
    "args": "{R : Type u_1} {G : Type u_4} [group G] [mul_action G R] (g : G)",
    "doc_string": " An element of a group acting on a Type is regular. This relies on the availability of the inverse given by groups, since there is no `left_cancel_smul` typeclass.",
    "kind": "theorem",
    "type": "is_smul_regular R g"
  },
  {
    "name": "esakia_hom.id",
    "statement": "def esakia_hom.id (α : Type u_2) [topological_space α] [preorder α] : esakia_hom α α",
    "theorem": "(α : Type u_2) [topological_space α] [preorder α] : esakia_hom α α",
    "args": "(α : Type u_2) [topological_space α] [preorder α]",
    "doc_string": "`id` as an `esakia_hom`.",
    "kind": "def",
    "type": "esakia_hom α α"
  },
  {
    "name": "lipschitz_with.holder_with",
    "statement": "theorem lipschitz_with.holder_with {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y} : lipschitz_with C f → holder_with C 1 f",
    "theorem": "{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y} : lipschitz_with C f → holder_with C 1 f",
    "args": "{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y}",
    "doc_string": "**Alias** of the reverse direction of holder_with_one`.",
    "kind": "theorem",
    "type": "lipschitz_with C f → holder_with C 1 f"
  },
  {
    "name": "category_theory.iso",
    "statement": "structure category_theory.iso {C : Type u} [category_theory.category C] (X Y : C) : Type v",
    "theorem": "{C : Type u} [category_theory.category C] (X Y : C) : Type v",
    "args": "{C : Type u} [category_theory.category C] (X Y : C)",
    "doc_string": "An isomorphism (a.k.a. an invertible morphism) between two objects of a category. The inverse morphism is bundled.  See also `category_theory.core` for the category with the same objects and isomorphisms playing the role of morphisms.  See <https://stacks.math.columbia.edu/tag/0017>.",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "pos_num.shiftl",
    "statement": "def pos_num.shiftl (p : pos_num) : ℕ → pos_num",
    "theorem": "(p : pos_num) : ℕ → pos_num",
    "args": "(p : pos_num)",
    "doc_string": "Left-shift the binary representation of a `pos_num`.",
    "kind": "def",
    "type": "ℕ → pos_num"
  },
  {
    "name": "formal_multilinear_series.comp_partial_sum_target_set",
    "statement": "def formal_multilinear_series.comp_partial_sum_target_set (m M N : ℕ) : set (Σ (n : ℕ), composition n)",
    "theorem": "(m M N : ℕ) : set (Σ (n : ℕ), composition n)",
    "args": "(m M N : ℕ)",
    "doc_string": " Target set in the change of variables to compute the composition of partial sums of formal power series, here given a a set.",
    "kind": "def",
    "type": "set (Σ (n : ℕ), composition n)"
  },
  {
    "name": "complete_lattice_hom.comp",
    "statement": "def complete_lattice_hom.comp {α : Type u_2} {β : Type u_3} {γ : Type u_4} [complete_lattice α] [complete_lattice β] [complete_lattice γ] (f : complete_lattice_hom β γ) (g : complete_lattice_hom α β) : complete_lattice_hom α γ",
    "theorem": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [complete_lattice α] [complete_lattice β] [complete_lattice γ] (f : complete_lattice_hom β γ) (g : complete_lattice_hom α β) : complete_lattice_hom α γ",
    "args": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [complete_lattice α] [complete_lattice β] [complete_lattice γ] (f : complete_lattice_hom β γ) (g : complete_lattice_hom α β)",
    "doc_string": "Composition of `complete_lattice_hom`s as a `complete_lattice_hom`.",
    "kind": "def",
    "type": "complete_lattice_hom α γ"
  },
  {
    "name": "mul_le_one'",
    "statement": "theorem mul_le_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1)",
    "doc_string": "**Alias** of left.mul_le_one`.",
    "kind": "theorem",
    "type": "a * b ≤ 1"
  },
  {
    "name": "is_fraction_ring.char_p_of_is_fraction_ring",
    "statement": "theorem is_fraction_ring.char_p_of_is_fraction_ring (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] (p : ℕ) [char_p R p] : char_p K p",
    "theorem": "(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] (p : ℕ) [char_p R p] : char_p K p",
    "args": "(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] (p : ℕ) [char_p R p]",
    "doc_string": "If `R` has characteristic `p`, then so does Frac(R).",
    "kind": "theorem",
    "type": "char_p K p"
  },
  {
    "name": "rel.preimage",
    "statement": "def rel.preimage {α : Type u_1} {β : Type u_2} (r : rel α β) (s : set β) : set α",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set β) : set α",
    "args": "{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set β)",
    "doc_string": "Preimage of a set under a relation `r`. Same as the image of `s` under `r.inv`",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "normed_lattice_add_comm_group_to_ordered_add_comm_group",
    "statement": "def normed_lattice_add_comm_group_to_ordered_add_comm_group {α : Type u_1} [h : normed_lattice_add_comm_group α] : ordered_add_comm_group α",
    "theorem": "{α : Type u_1} [h : normed_lattice_add_comm_group α] : ordered_add_comm_group α",
    "args": "{α : Type u_1} [h : normed_lattice_add_comm_group α]",
    "doc_string": "A normed lattice ordered group is an ordered additive commutative group",
    "kind": "def",
    "type": "ordered_add_comm_group α"
  },
  {
    "name": "filter.eventually",
    "statement": "def filter.eventually {α : Type u} (p : α → Prop) (f : filter α) : Prop",
    "theorem": "{α : Type u} (p : α → Prop) (f : filter α) : Prop",
    "args": "{α : Type u} (p : α → Prop) (f : filter α)",
    "doc_string": " `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x` means that `p` holds true for sufficiently large `x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.find_max",
    "statement": "def ordnode.find_max {α : Type u} : ordnode α → option α",
    "theorem": "{α : Type u} : ordnode α → option α",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Return the maximum element of the tree, if it exists.      find_max {1, 2, 3} = some 3     find_max ∅ = none",
    "kind": "def",
    "type": "ordnode α → option α"
  },
  {
    "name": "bounded_order_hom",
    "statement": "structure bounded_order_hom (α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [bounded_order α] [bounded_order β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [bounded_order α] [bounded_order β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [bounded_order α] [bounded_order β]",
    "doc_string": "The type of bounded order homomorphisms from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "ratfunc.div",
    "statement": "def ratfunc.div {K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K → ratfunc K → ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] : ratfunc K → ratfunc K → ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K] [hdomain : is_domain K]",
    "doc_string": "Division of rational functions.",
    "kind": "def",
    "type": "ratfunc K → ratfunc K → ratfunc K"
  },
  {
    "name": "ultrafilter.has_add",
    "statement": "def ultrafilter.has_add {M : Type u_1} [has_add M] : has_add (ultrafilter M)",
    "theorem": "{M : Type u_1} [has_add M] : has_add (ultrafilter M)",
    "args": "{M : Type u_1} [has_add M]",
    "doc_string": "Addition of ultrafilters given by `∀ᶠ m in U+V, p m ↔ ∀ᶠ m in U, ∀ᶠ m' in V, p (m+m')`.",
    "kind": "def",
    "type": "has_add (ultrafilter M)"
  },
  {
    "name": "first_order.language.trivial_unit_structure",
    "statement": "def first_order.language.trivial_unit_structure (L : first_order.language) : L.Structure unit",
    "theorem": "(L : first_order.language) : L.Structure unit",
    "args": "(L : first_order.language)",
    "doc_string": "Used for defining `first_order.language.Theory.Model.inhabited`.",
    "kind": "def",
    "type": "L.Structure unit"
  },
  {
    "name": "category_theory.limits.has_coproducts",
    "statement": "def category_theory.limits.has_coproducts (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "An abbreviation for `Π J, has_colimits_of_shape (discrete J) C`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "tree.index_of",
    "statement": "def tree.index_of {α : Type u} (lt : α → α → Prop) [decidable_rel lt] (x : α) : tree α → option pos_num",
    "theorem": "{α : Type u} (lt : α → α → Prop) [decidable_rel lt] (x : α) : tree α → option pos_num",
    "args": "{α : Type u} (lt : α → α → Prop) [decidable_rel lt] (x : α)",
    "doc_string": " Finds the index of an element in the tree assuming the tree has been constructed according to the provided decidable order on its elements. If it hasn't, the result will be incorrect. If it has, but the element is not in the tree, returns none.",
    "kind": "def",
    "type": "tree α → option pos_num"
  },
  {
    "name": "witt_vector.frobenius_rotation_coeff",
    "statement": "def witt_vector.frobenius_rotation_coeff (p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [is_alg_closed k] {a₁ a₂ : witt_vector p k} (ha₁ : a₁.coeff 0 ≠ 0) (ha₂ : a₂.coeff 0 ≠ 0) : ℕ → k",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [is_alg_closed k] {a₁ a₂ : witt_vector p k} (ha₁ : a₁.coeff 0 ≠ 0) (ha₂ : a₂.coeff 0 ≠ 0) : ℕ → k",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [char_p k p] [is_alg_closed k] {a₁ a₂ : witt_vector p k} (ha₁ : a₁.coeff 0 ≠ 0) (ha₂ : a₂.coeff 0 ≠ 0)",
    "doc_string": "Recursively defines the sequence of coefficients for `witt_vector.frobenius_rotation`.",
    "kind": "def",
    "type": "ℕ → k"
  },
  {
    "name": "complete_lattice.independent",
    "statement": "def complete_lattice.independent {ι : Sort u_1} {α : Type u_2} [complete_lattice α] (t : ι → α) : Prop",
    "theorem": "{ι : Sort u_1} {α : Type u_2} [complete_lattice α] (t : ι → α) : Prop",
    "args": "{ι : Sort u_1} {α : Type u_2} [complete_lattice α] (t : ι → α)",
    "doc_string": "An independent indexed family of elements in a complete lattice is one in which every element  is disjoint from the `supr` of the rest.   Example: an indexed family of non-zero elements in a  vector space is linearly independent iff the indexed family of subspaces they generate is  independent in this sense.   Example: an indexed family of submodules of a module is independent in this sense if  and only the natural map from the direct sum of the submodules to the module is injective.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "part.assert",
    "statement": "def part.assert {α : Type u_1} (p : Prop) (f : p → part α) : part α",
    "theorem": "{α : Type u_1} (p : Prop) (f : p → part α) : part α",
    "args": "{α : Type u_1} (p : Prop) (f : p → part α)",
    "doc_string": "`assert p f` is a bind-like operation which appends an additional condition  `p` to the domain and uses `f` to produce the value.",
    "kind": "def",
    "type": "part α"
  },
  {
    "name": "right_ord_continuous",
    "statement": "def right_ord_continuous {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β)",
    "doc_string": " A function `f` between preorders is right order continuous if it preserves all infima.  We define it using `is_glb` instead of `Inf` so that the proof works both for complete lattices and conditionally complete lattices.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "matrix",
    "statement": "def matrix (m : Type u) (n : Type u') (α : Type v) : Type (max u u' v)",
    "theorem": "(m : Type u) (n : Type u') (α : Type v) : Type (max u u' v)",
    "args": "(m : Type u) (n : Type u') (α : Type v)",
    "doc_string": " `matrix m n R` is the type of matrices with entries in `R`, whose rows are indexed by `m` and whose columns are indexed by `n`.",
    "kind": "def",
    "type": "Type (max u u' v)"
  },
  {
    "name": "inv_le_one'",
    "statement": "theorem inv_le_one' {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "**Alias** of left.inv_le_one_iff`.",
    "kind": "theorem",
    "type": "a⁻¹ ≤ 1 ↔ 1 ≤ a"
  },
  {
    "name": "has_measurable_add",
    "statement": "structure has_measurable_add (M : Type u_1) [measurable_space M] [has_add M] : Prop",
    "theorem": "(M : Type u_1) [measurable_space M] [has_add M] : Prop",
    "args": "(M : Type u_1) [measurable_space M] [has_add M]",
    "doc_string": " We say that a type `has_measurable_add` if `((+) c)` and `(+ c)` are measurable functions. For a typeclass assuming measurability of `uncurry (+)` see `has_measurable_add₂`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "valuation.to_preorder",
    "statement": "def valuation.to_preorder {R : Type u_2} {Γ₀ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] (v : valuation R Γ₀) : preorder R",
    "theorem": "{R : Type u_2} {Γ₀ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] (v : valuation R Γ₀) : preorder R",
    "args": "{R : Type u_2} {Γ₀ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] (v : valuation R Γ₀)",
    "doc_string": "A valuation gives a preorder on the underlying ring.",
    "kind": "def",
    "type": "preorder R"
  },
  {
    "name": "is_fraction_ring.is_domain",
    "statement": "theorem is_fraction_ring.is_domain (A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K",
    "theorem": "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K",
    "args": "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K]",
    "doc_string": " A `comm_ring` `K` which is the localization of an integral domain `R` at `R - {0}` is an integral domain.",
    "kind": "theorem",
    "type": "is_domain K"
  },
  {
    "name": "multiset.Ioc",
    "statement": "def multiset.Ioc {α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : multiset α",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α)",
    "doc_string": " The multiset of elements `x` such that `a < x` and `x ≤ b`. Basically `set.Ioc a b` as a multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "module.finite.of_basis",
    "statement": "theorem module.finite.of_basis {R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M",
    "theorem": "{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M",
    "args": "{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M)",
    "doc_string": "A free module with a basis indexed by a `fintype` is finite.",
    "kind": "theorem",
    "type": "module.finite R M"
  },
  {
    "name": "compact_exhaustion.choice",
    "statement": "def compact_exhaustion.choice (X : Type u_1) [topological_space X] [locally_compact_space X] [sigma_compact_space X] : compact_exhaustion X",
    "theorem": "(X : Type u_1) [topological_space X] [locally_compact_space X] [sigma_compact_space X] : compact_exhaustion X",
    "args": "(X : Type u_1) [topological_space X] [locally_compact_space X] [sigma_compact_space X]",
    "doc_string": " A choice of an [exhaustion by compact sets](https://en.wikipedia.org/wiki/Exhaustion_by_compact_sets) of a locally compact sigma compact space.",
    "kind": "def",
    "type": "compact_exhaustion X"
  },
  {
    "name": "is_right_regular.of_mul",
    "statement": "theorem is_right_regular.of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a))",
    "doc_string": "  If an element `b` becomes right-regular after multiplying it on the right by a right-regular element, then `b` is right-regular.",
    "kind": "theorem",
    "type": "is_right_regular b"
  },
  {
    "name": "nat.pow_le_iff_le_log",
    "statement": "theorem nat.pow_le_iff_le_log {b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y) : b ^ x ≤ y ↔ x ≤ nat.log b y",
    "theorem": "{b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y) : b ^ x ≤ y ↔ x ≤ nat.log b y",
    "args": "{b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y)",
    "doc_string": "`pow b` and `log b` (almost) form a Galois connection.",
    "kind": "theorem",
    "type": "b ^ x ≤ y ↔ x ≤ nat.log b y"
  },
  {
    "name": "add_monoid.End",
    "statement": "def add_monoid.End (A : Type u_9) [add_zero_class A] : Type u_9",
    "theorem": "(A : Type u_9) [add_zero_class A] : Type u_9",
    "args": "(A : Type u_9) [add_zero_class A]",
    "doc_string": "The monoid of endomorphisms.",
    "kind": "def",
    "type": "Type u_9"
  },
  {
    "name": "parser.numeral.of_fintype",
    "statement": "def parser.numeral.of_fintype (α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] : parser α",
    "theorem": "(α : Type) [has_zero α] [has_one α] [has_add α] [fintype α] : parser α",
    "args": "(α : Type) [has_zero α] [has_one α] [has_add α] [fintype α]",
    "doc_string": "Parse a string of digits as a numeral while casting it to target type `α`, which has a `[fintype α]` constraint. The parser ensures that the numeral parsed in is within the cardinality of the type `α`.",
    "kind": "def",
    "type": "parser α"
  },
  {
    "name": "category_theory.shift_functor_full",
    "statement": "def category_theory.shift_functor_full (C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.full (category_theory.shift_functor C i)",
    "theorem": "(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.full (category_theory.shift_functor C i)",
    "args": "(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A)",
    "doc_string": "Shifting by `n` is a full functor.",
    "kind": "def",
    "type": "category_theory.full (category_theory.shift_functor C i)"
  },
  {
    "name": "mul_action",
    "statement": "structure mul_action (α : Type u_10) (β : Type u_11) [monoid α] : Type (max u_10 u_11)",
    "theorem": "(α : Type u_10) (β : Type u_11) [monoid α] : Type (max u_10 u_11)",
    "args": "(α : Type u_10) (β : Type u_11) [monoid α]",
    "doc_string": "Typeclass for multiplicative actions by monoids. This generalizes group actions.",
    "kind": "structure",
    "type": "Type (max u_10 u_11)"
  },
  {
    "name": "sub_neg_monoid",
    "statement": "structure sub_neg_monoid (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations satisfying `sub_eq_add_neg : ∀ a b, a - b = a + -b`.  The default for `sub` is such that `a - b = a + -b` holds by definition.  Adding `sub` as a field rather than defining `a - b := a + -b` allows us to avoid certain classes of unification failures, for example: Let `foo X` be a type with a `∀ X, has_sub (foo X)` instance but no `∀ X, has_neg (foo X)`. Suppose we also have an instance `∀ X [cromulent X], add_group (foo X)`. Then the `(-)` coming from `add_group.has_sub` cannot be definitionally equal to the `(-)` coming from `foo.has_sub`.  In the same way, adding a `zsmul` field makes it possible to avoid definitional failures in diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more explanations on this.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "linarith.global_branching_preprocessor",
    "statement": "structure linarith.global_branching_preprocessor  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Some preprocessors perform branching case splits. A `global_branching_preprocessor` produces a list of branches to run. Each branch is independent, so hypotheses that appear in multiple branches should be duplicated. The preprocessor is responsible for making sure that each branch contains the correct goal metavariable.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "list.transpose",
    "statement": "def list.transpose {α : Type u_1} : list (list α) → list (list α)",
    "theorem": "{α : Type u_1} : list (list α) → list (list α)",
    "args": "{α : Type u_1}",
    "doc_string": "transpose of a list of lists, treated as a matrix.      transpose [[1, 2], [3, 4], [5, 6]] = [[1, 3, 5], [2, 4, 6]]",
    "kind": "def",
    "type": "list (list α) → list (list α)"
  },
  {
    "name": "is_reduced",
    "statement": "structure is_reduced (R : Type u_1) [has_zero R] [has_pow R ℕ] : Prop",
    "theorem": "(R : Type u_1) [has_zero R] [has_pow R ℕ] : Prop",
    "args": "(R : Type u_1) [has_zero R] [has_pow R ℕ]",
    "doc_string": "A structure that has zero and pow is reduced if it has no nonzero nilpotent elements.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "continuous",
    "statement": "structure continuous {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β)",
    "doc_string": "A function between topological spaces is continuous if the preimage  of every open set is open. Registered as a structure to make sure it is not unfolded by Lean.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "filter_basis.filter",
    "statement": "def filter_basis.filter {α : Type u_1} (B : filter_basis α) : filter α",
    "theorem": "{α : Type u_1} (B : filter_basis α) : filter α",
    "args": "{α : Type u_1} (B : filter_basis α)",
    "doc_string": "The filter associated to a filter basis.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "add_subsemigroup.map",
    "statement": "def add_subsemigroup.map {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup M) : add_subsemigroup N",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup M) : add_subsemigroup N",
    "args": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup M)",
    "doc_string": "The image of an `add_subsemigroup` along an `add_semigroup` homomorphism is an `add_subsemigroup`.",
    "kind": "def",
    "type": "add_subsemigroup N"
  },
  {
    "name": "mvpfunctor.M.corec_shape",
    "statement": "def mvpfunctor.M.corec_shape {n : ℕ} (P : mvpfunctor (n + 1)) {β : Type u} (g₀ : β → P.A) (g₂ : Π (b : β), P.last.B (g₀ b) → β) : β → P.last.M",
    "theorem": "{n : ℕ} (P : mvpfunctor (n + 1)) {β : Type u} (g₀ : β → P.A) (g₂ : Π (b : β), P.last.B (g₀ b) → β) : β → P.last.M",
    "args": "{n : ℕ} (P : mvpfunctor (n + 1)) {β : Type u} (g₀ : β → P.A) (g₂ : Π (b : β), P.last.B (g₀ b) → β)",
    "doc_string": " construct through corecursion the shape of an M-type without its contents",
    "kind": "def",
    "type": "β → P.last.M"
  },
  {
    "name": "residual",
    "statement": "def residual (α : Type u_1) [topological_space α] : filter α",
    "theorem": "(α : Type u_1) [topological_space α] : filter α",
    "args": "(α : Type u_1) [topological_space α]",
    "doc_string": " A set `s` is called *residual* if it includes a dense `Gδ` set. If `α` is a Baire space (e.g., a complete metric space), then residual sets form a filter, see `mem_residual`.  For technical reasons we define the filter `residual` in any topological space but in a non-Baire space it is not useful because it may contain some non-residual sets.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "le_implies_le_of_le_of_le",
    "statement": "theorem le_implies_le_of_le_of_le {α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d) : a ≤ b → c ≤ d",
    "theorem": "{α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d) : a ≤ b → c ≤ d",
    "args": "{α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d)",
    "doc_string": "monotonicity of `≤` with respect to `→`",
    "kind": "theorem",
    "type": "a ≤ b → c ≤ d"
  },
  {
    "name": "composition.single",
    "statement": "def composition.single (n : ℕ) (h : 0 < n) : composition n",
    "theorem": "(n : ℕ) (h : 0 < n) : composition n",
    "args": "(n : ℕ) (h : 0 < n)",
    "doc_string": "The composition made of a single block of size `n`.",
    "kind": "def",
    "type": "composition n"
  },
  {
    "name": "category_theory.limits.has_zero_morphisms",
    "statement": "structure category_theory.limits.has_zero_morphisms (C : Type u) [category_theory.category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": " A category \"has zero morphisms\" if there is a designated \"zero morphism\" in each morphism space, and compositions of zero morphisms with anything give the zero morphism.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "regular_expression.rmatch",
    "statement": "def regular_expression.rmatch {α : Type u_1} [dec : decidable_eq α] : regular_expression α → list α → bool",
    "theorem": "{α : Type u_1} [dec : decidable_eq α] : regular_expression α → list α → bool",
    "args": "{α : Type u_1} [dec : decidable_eq α]",
    "doc_string": "`P.rmatch x` is true if and only if `P` matches `x`. This is a computable definition equivalent  to `matches`.",
    "kind": "def",
    "type": "regular_expression α → list α → bool"
  },
  {
    "name": "subsingleton_info",
    "statement": "structure subsingleton_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "specialized is true if the result of fun_info has been specifialized using this argument. For example, consider the function             f : Pi (α : Type), α -> α  Now, suppse we request get_specialize fun_info for the application         f unit a  fun_info_manager returns two param_info objects: 1) specialized = true 2) is_subsingleton = true  Note that, in general, the second argument of f is not a subsingleton, but it is in this particular case/specialization.  \\remark This bit is only set if it is a dependent parameter.   Moreover, we only set is_specialized IF another parameter  becomes a subsingleton",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "complex_shape.trans",
    "statement": "def complex_shape.trans {ι : Type u_1} (c₁ c₂ : complex_shape ι) : complex_shape ι",
    "theorem": "{ι : Type u_1} (c₁ c₂ : complex_shape ι) : complex_shape ι",
    "args": "{ι : Type u_1} (c₁ c₂ : complex_shape ι)",
    "doc_string": "The \"composition\" of two `complex_shape`s.  We need this to define \"related in k steps\" later.",
    "kind": "def",
    "type": "complex_shape ι"
  },
  {
    "name": "dlist.empty",
    "statement": "def dlist.empty {α : Type u} : dlist α",
    "theorem": "{α : Type u} : dlist α",
    "args": "{α : Type u}",
    "doc_string": "Create a dlist containing no elements",
    "kind": "def",
    "type": "dlist α"
  },
  {
    "name": "prod.partial_order",
    "statement": "def prod.partial_order (α : Type u) (β : Type v) [partial_order α] [partial_order β] : partial_order (α × β)",
    "theorem": "(α : Type u) (β : Type v) [partial_order α] [partial_order β] : partial_order (α × β)",
    "args": "(α : Type u) (β : Type v) [partial_order α] [partial_order β]",
    "doc_string": "The pointwise partial order on a product.    (The lexicographic ordering is defined in order/lexicographic.lean, and the instances are    available via the type synonym `α ×ₗ β = α × β`.)",
    "kind": "def",
    "type": "partial_order (α × β)"
  },
  {
    "name": "filter.comap_cocompact_le",
    "statement": "theorem filter.comap_cocompact_le {α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f) : filter.comap f (filter.cocompact β) ≤ filter.cocompact α",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f) : filter.comap f (filter.cocompact β) ≤ filter.cocompact α",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f)",
    "doc_string": " The comap of the cocompact filter on `β` by a continuous function `f : α → β` is less than or equal to the cocompact filter on `α`. This is a reformulation of the fact that images of compact sets are compact.",
    "kind": "theorem",
    "type": "filter.comap f (filter.cocompact β) ≤ filter.cocompact α"
  },
  {
    "name": "matrix.is_adj_matrix",
    "statement": "structure matrix.is_adj_matrix {V : Type u_1} {α : Type u_2} [has_zero α] [has_one α] (A : matrix V V α) : Prop",
    "theorem": "{V : Type u_1} {α : Type u_2} [has_zero α] [has_one α] (A : matrix V V α) : Prop",
    "args": "{V : Type u_1} {α : Type u_2} [has_zero α] [has_one α] (A : matrix V V α)",
    "doc_string": "`A : matrix V V α` is qualified as an \"adjacency matrix\" if    (1) every entry of `A` is `0` or `1`,    (2) `A` is symmetric,    (3) every diagonal entry of `A` is `0`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "generalized_continued_fraction.of",
    "statement": "def generalized_continued_fraction.of {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction K",
    "theorem": "{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : generalized_continued_fraction K",
    "args": "{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K)",
    "doc_string": "Returns the `generalized_continued_fraction` of a value. In fact, the returned gcf is also a `continued_fraction` that terminates if and only if `v` is rational (those proofs will be added in a future commit).  The continued fraction representation of `v` is given by `[⌊v⌋; b₀, b₁, b₂,...]`, where `[b₀; b₁, b₂,...]` recursively is the continued fraction representation of `1 / (v - ⌊v⌋)`. This process stops when the fractional part `v - ⌊v⌋` hits 0 at some step.  The implementation uses `int_fract_pair.stream` to obtain the partial denominators of the continued fraction. Refer to said function for more details about the computation process.",
    "kind": "def",
    "type": "generalized_continued_fraction K"
  },
  {
    "name": "cocompact_map.comp",
    "statement": "def cocompact_map.comp {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (f : cocompact_map β γ) (g : cocompact_map α β) : cocompact_map α γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (f : cocompact_map β γ) (g : cocompact_map α β) : cocompact_map α γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] (f : cocompact_map β γ) (g : cocompact_map α β)",
    "doc_string": "The composition of cocompact continuous maps, as a cocompact continuous map.",
    "kind": "def",
    "type": "cocompact_map α γ"
  },
  {
    "name": "bot_hom_class",
    "statement": "structure bot_hom_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_bot α] [has_bot β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_bot α] [has_bot β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_bot α] [has_bot β]",
    "doc_string": " `bot_hom_class F α β` states that `F` is a type of `⊥`-preserving morphisms.  You should extend this class when you extend `bot_hom`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "seq1.bind",
    "statement": "def seq1.bind {α : Type u} {β : Type v} (s : seq1 α) (f : α → seq1 β) : seq1 β",
    "theorem": "{α : Type u} {β : Type v} (s : seq1 α) (f : α → seq1 β) : seq1 β",
    "args": "{α : Type u} {β : Type v} (s : seq1 α) (f : α → seq1 β)",
    "doc_string": "The `bind` operator for the `seq1` monad,  which maps `f` on each element of `s` and appends the results together.  (Not all of `s` may be evaluated, because the first few elements of `s`  may already produce an infinite result.)",
    "kind": "def",
    "type": "seq1 β"
  },
  {
    "name": "order.ideal.order_top",
    "statement": "def order.ideal.order_top {P : Type u_1} [has_le P] [is_directed P has_le.le] [nonempty P] : order_top (order.ideal P)",
    "theorem": "{P : Type u_1} [has_le P] [is_directed P has_le.le] [nonempty P] : order_top (order.ideal P)",
    "args": "{P : Type u_1} [has_le P] [is_directed P has_le.le] [nonempty P]",
    "doc_string": "In a directed and nonempty order, the top ideal of a is `univ`.",
    "kind": "def",
    "type": "order_top (order.ideal P)"
  },
  {
    "name": "wseq.nth",
    "statement": "def wseq.nth {α : Type u} (s : wseq α) (n : ℕ) : computation (option α)",
    "theorem": "{α : Type u} (s : wseq α) (n : ℕ) : computation (option α)",
    "args": "{α : Type u} (s : wseq α) (n : ℕ)",
    "doc_string": "Get the nth element of `s`.",
    "kind": "def",
    "type": "computation (option α)"
  },
  {
    "name": "conv",
    "statement": "def conv (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " `conv α` is a tactic for discharging goals of the form `lhs ~ rhs` for some relation `~` (usually equality) and fixed lhs, rhs. Known in the literature as a __conversion__ tactic. So for example, if one had the lemma `p : x = y`, then the conversion for `p` would be one that solves `p`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "is_CHSH_tuple",
    "statement": "structure is_CHSH_tuple {R : Type u_1} [monoid R] [star_semigroup R] (A₀ A₁ B₀ B₁ : R) : Type",
    "theorem": "{R : Type u_1} [monoid R] [star_semigroup R] (A₀ A₁ B₀ B₁ : R) : Type",
    "args": "{R : Type u_1} [monoid R] [star_semigroup R] (A₀ A₁ B₀ B₁ : R)",
    "doc_string": "A CHSH tuple in a *-monoid consists of 4 self-adjoint involutions `A₀ A₁ B₀ B₁` such that the `Aᵢ` commute with the `Bⱼ`.  The physical interpretation is that `A₀` and `A₁` are a pair of boolean observables which are spacelike separated from another pair `B₀` and `B₁` of boolean observables.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "upper_set.Ici",
    "statement": "def upper_set.Ici {α : Type u_1} [preorder α] (a : α) : upper_set α",
    "theorem": "{α : Type u_1} [preorder α] (a : α) : upper_set α",
    "args": "{α : Type u_1} [preorder α] (a : α)",
    "doc_string": "The smallest upper set containing a given element.",
    "kind": "def",
    "type": "upper_set α"
  },
  {
    "name": "has_btw.btw.sbtw_of_not_btw",
    "statement": "theorem has_btw.btw.sbtw_of_not_btw {α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a) : has_sbtw.sbtw a b c",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a) : has_sbtw.sbtw a b c",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a)",
    "doc_string": "**Alias** of sbtw_of_btw_not_btw`.",
    "kind": "theorem",
    "type": "has_sbtw.sbtw a b c"
  },
  {
    "name": "znum.div",
    "statement": "def znum.div  : znum → znum → znum",
    "theorem": " : znum → znum → znum",
    "args": "",
    "doc_string": "Division of `znum`, where `x / 0 = 0`.",
    "kind": "def",
    "type": "znum → znum → znum"
  },
  {
    "name": "lazy_list.pmap",
    "statement": "def lazy_list.pmap {α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (l : lazy_list α) : (∀ (a : α), a ∈ l → p a) → lazy_list β",
    "theorem": "{α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (l : lazy_list α) : (∀ (a : α), a ∈ l → p a) → lazy_list β",
    "args": "{α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (l : lazy_list α)",
    "doc_string": "Partial map. If `f : Π a, p a → β` is a partial function defined on  `a : α` satisfying `p`, then `pmap f l h` is essentially the same as `map f l`  but is defined only when all members of `l` satisfy `p`, using the proof  to apply `f`.",
    "kind": "def",
    "type": "(∀ (a : α), a ∈ l → p a) → lazy_list β"
  },
  {
    "name": "category_theory.limits.types.product_limit_cone",
    "statement": "def category_theory.limits.types.product_limit_cone {J : Type u} (F : J → Type u) : category_theory.limits.limit_cone (category_theory.discrete.functor F)",
    "theorem": "{J : Type u} (F : J → Type u) : category_theory.limits.limit_cone (category_theory.discrete.functor F)",
    "args": "{J : Type u} (F : J → Type u)",
    "doc_string": "The category of types has `Π j, f j` as the product of a type family `f : J → Type`.",
    "kind": "def",
    "type": "category_theory.limits.limit_cone (category_theory.discrete.functor F)"
  },
  {
    "name": "category_theory.shift_mk_core",
    "statement": "structure category_theory.shift_mk_core (C : Type u) (A : Type u_1) [category_theory.category C] [add_monoid A] : Type (max u u_1 v)",
    "theorem": "(C : Type u) (A : Type u_1) [category_theory.category C] [add_monoid A] : Type (max u u_1 v)",
    "args": "(C : Type u) (A : Type u_1) [category_theory.category C] [add_monoid A]",
    "doc_string": "A helper structure to construct the shift functor `(discrete A) ⥤ (C ⥤ C)`.",
    "kind": "structure",
    "type": "Type (max u u_1 v)"
  },
  {
    "name": "order.is_pfilter",
    "statement": "def order.is_pfilter {P : Type u_1} [preorder P] (F : set P) : Prop",
    "theorem": "{P : Type u_1} [preorder P] (F : set P) : Prop",
    "args": "{P : Type u_1} [preorder P] (F : set P)",
    "doc_string": "A predicate for when a subset of `P` is a filter.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "locally_constant.const",
    "statement": "def locally_constant.const (X : Type u_1) {Y : Type u_2} [topological_space X] (y : Y) : locally_constant X Y",
    "theorem": "(X : Type u_1) {Y : Type u_2} [topological_space X] (y : Y) : locally_constant X Y",
    "args": "(X : Type u_1) {Y : Type u_2} [topological_space X] (y : Y)",
    "doc_string": "The constant locally constant function on `X` with value `y : Y`.",
    "kind": "def",
    "type": "locally_constant X Y"
  },
  {
    "name": "alg_equiv",
    "statement": "structure alg_equiv (R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)",
    "theorem": "(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)",
    "args": "(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B]",
    "doc_string": "An equivalence of algebras is an equivalence of rings commuting with the actions of scalars.",
    "kind": "structure",
    "type": "Type (max v w)"
  },
  {
    "name": "filter.comm_semigroup",
    "statement": "def filter.comm_semigroup {α : Type u_2} [comm_semigroup α] : comm_semigroup (filter α)",
    "theorem": "{α : Type u_2} [comm_semigroup α] : comm_semigroup (filter α)",
    "args": "{α : Type u_2} [comm_semigroup α]",
    "doc_string": "`filter α` is a `comm_semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "comm_semigroup (filter α)"
  },
  {
    "name": "zero_lt.preorder.right.one_le_mul_of_le_of_le",
    "statement": "theorem zero_lt.preorder.right.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "1 ≤ a * b"
  },
  {
    "name": "omega.gcd",
    "statement": "def omega.gcd  : list ℤ → ℕ",
    "theorem": " : list ℤ → ℕ",
    "args": "",
    "doc_string": "GCD of all elements of the list.",
    "kind": "def",
    "type": "list ℤ → ℕ"
  },
  {
    "name": "fin.pred_above",
    "statement": "def fin.pred_above {n : ℕ} (p : fin n) (i : fin (n + 1)) : fin n",
    "theorem": "{n : ℕ} (p : fin n) (i : fin (n + 1)) : fin n",
    "args": "{n : ℕ} (p : fin n) (i : fin (n + 1))",
    "doc_string": "`pred_above p i` embeds `i : fin (n+1)` into `fin n` by subtracting one if `p < i`.",
    "kind": "def",
    "type": "fin n"
  },
  {
    "name": "free_add_magma.length",
    "statement": "def free_add_magma.length {α : Type u} : free_add_magma α → ℕ",
    "theorem": "{α : Type u} : free_add_magma α → ℕ",
    "args": "{α : Type u}",
    "doc_string": "Length of an element of a free additive magma.",
    "kind": "def",
    "type": "free_add_magma α → ℕ"
  },
  {
    "name": "finset.subtype_map_of_mem",
    "statement": "theorem finset.subtype_map_of_mem {α : Type u_1} {s : finset α} {p : α → Prop} [decidable_pred p] (h : ∀ (x : α), x ∈ s → p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s",
    "theorem": "{α : Type u_1} {s : finset α} {p : α → Prop} [decidable_pred p] (h : ∀ (x : α), x ∈ s → p x) : finset.map (function.embedding.subtype p) (finset.subtype p s) = s",
    "args": "{α : Type u_1} {s : finset α} {p : α → Prop} [decidable_pred p] (h : ∀ (x : α), x ∈ s → p x)",
    "doc_string": " If all elements of a `finset` satisfy the predicate `p`, `s.subtype p` converts back to `s` with `embedding.subtype`.",
    "kind": "theorem",
    "type": "finset.map (function.embedding.subtype p) (finset.subtype p s) = s"
  },
  {
    "name": "Set.funs",
    "statement": "def Set.funs (x y : Set) : Set",
    "theorem": "(x y : Set) : Set",
    "args": "(x y : Set)",
    "doc_string": "`funs x y` is `y ^ x`, the set of all set functions `x → y`",
    "kind": "def",
    "type": "Set"
  },
  {
    "name": "is_fw_invariant",
    "statement": "def is_fw_invariant {τ : Type u_1} {α : Type u_2} [preorder τ] [has_zero τ] (ϕ : τ → α → α) (s : set α) : Prop",
    "theorem": "{τ : Type u_1} {α : Type u_2} [preorder τ] [has_zero τ] (ϕ : τ → α → α) (s : set α) : Prop",
    "args": "{τ : Type u_1} {α : Type u_2} [preorder τ] [has_zero τ] (ϕ : τ → α → α) (s : set α)",
    "doc_string": "A set `s ⊆ α` is forward-invariant under `ϕ : τ → α → α` if    `ϕ t s ⊆ s` for all `t ≥ 0`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_pullbacks",
    "statement": "def category_theory.limits.has_pullbacks (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_pullbacks` represents a choice of pullback for every pair of morphisms  See <https://stacks.math.columbia.edu/tag/001W>",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "locally_finite_order",
    "statement": "structure locally_finite_order (α : Type u_1) [preorder α] : Type u_1",
    "theorem": "(α : Type u_1) [preorder α] : Type u_1",
    "args": "(α : Type u_1) [preorder α]",
    "doc_string": " A locally finite order is an order where bounded intervals are finite. When you don't care too much about definitional equality, you can use `locally_finite_order.of_Icc` or `locally_finite_order.of_finite_Icc` to build a locally finite order from just `finset.Icc`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "uniform_convergence.uniformity_basis",
    "statement": "def uniform_convergence.uniformity_basis (α : Type u_1) (β : Type u_2) [uniform_space β] : filter_basis ((α → β) × (α → β))",
    "theorem": "(α : Type u_1) (β : Type u_2) [uniform_space β] : filter_basis ((α → β) × (α → β))",
    "args": "(α : Type u_1) (β : Type u_2) [uniform_space β]",
    "doc_string": "Filter basis for the uniformity of uniform convergence",
    "kind": "def",
    "type": "filter_basis ((α → β) × (α → β))"
  },
  {
    "name": "filter.add_semigroup",
    "statement": "def filter.add_semigroup {α : Type u_2} [add_semigroup α] : add_semigroup (filter α)",
    "theorem": "{α : Type u_2} [add_semigroup α] : add_semigroup (filter α)",
    "args": "{α : Type u_2} [add_semigroup α]",
    "doc_string": "`filter α` is an `add_semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_semigroup (filter α)"
  },
  {
    "name": "zmod.legendre_sym_eq_one_or_neg_one",
    "statement": "theorem zmod.legendre_sym_eq_one_or_neg_one (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ∨ zmod.legendre_sym p a = -1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ∨ zmod.legendre_sym p a = -1",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0)",
    "doc_string": "If `p ∤ a`, then `legendre_sym p a` is `1` or `-1`.",
    "kind": "theorem",
    "type": "zmod.legendre_sym p a = 1 ∨ zmod.legendre_sym p a = -1"
  },
  {
    "name": "alexandroff.normal_space",
    "statement": "def alexandroff.normal_space {X : Type u_1} [topological_space X] [locally_compact_space X] [t2_space X] : normal_space (alexandroff X)",
    "theorem": "{X : Type u_1} [topological_space X] [locally_compact_space X] [t2_space X] : normal_space (alexandroff X)",
    "args": "{X : Type u_1} [topological_space X] [locally_compact_space X] [t2_space X]",
    "doc_string": " The one point compactification of a locally compact Hausdorff space is a normal (hence, Hausdorff and regular) topological space.",
    "kind": "def",
    "type": "normal_space (alexandroff X)"
  },
  {
    "name": "order_hom",
    "statement": "structure order_hom (α : Type u_6) (β : Type u_7) [preorder α] [preorder β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β]",
    "doc_string": "Bundled monotone (aka, increasing) function",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "relation.join",
    "statement": "def relation.join {α : Type u_1} (r : α → α → Prop) : α → α → Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) : α → α → Prop",
    "args": "{α : Type u_1} (r : α → α → Prop)",
    "doc_string": "The join of a relation on a single type is a new relation for which pairs of terms are related if there is a third term they are both related to.  For example, if `r` is a relation representing rewrites in a term rewriting system, then *confluence* is the property that if `a` rewrites to both `b` and `c`, then `join r` relates `b` and `c` (see `relation.church_rosser`).",
    "kind": "def",
    "type": "α → α → Prop"
  },
  {
    "name": "is_metric_separated",
    "statement": "def is_metric_separated {X : Type u_1} [emetric_space X] (s t : set X) : Prop",
    "theorem": "{X : Type u_1} [emetric_space X] (s t : set X) : Prop",
    "args": "{X : Type u_1} [emetric_space X] (s t : set X)",
    "doc_string": " Two sets in an (extended) metric space are called *metric separated* if the (extended) distance between `x ∈ s` and `y ∈ t` is bounded from below by a positive constant.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ideal.of_rel",
    "statement": "def ideal.of_rel {α : Type u} [semiring α] (r : α → α → Prop) : ideal α",
    "theorem": "{α : Type u} [semiring α] (r : α → α → Prop) : ideal α",
    "args": "{α : Type u} [semiring α] (r : α → α → Prop)",
    "doc_string": "The ideal generated by an arbitrary binary relation.",
    "kind": "def",
    "type": "ideal α"
  },
  {
    "name": "topological_semiring",
    "statement": "structure topological_semiring (α : Type u_1) [topological_space α] [non_unital_non_assoc_semiring α] : Prop",
    "theorem": "(α : Type u_1) [topological_space α] [non_unital_non_assoc_semiring α] : Prop",
    "args": "(α : Type u_1) [topological_space α] [non_unital_non_assoc_semiring α]",
    "doc_string": " a topological semiring is a semiring `R` where addition and multiplication are continuous. We allow for non-unital and non-associative semirings as well.  The `topological_semiring` class should *only* be instantiated in the presence of a `non_unital_non_assoc_semiring` instance; if there is an instance of `non_unital_non_assoc_ring`, then `topological_ring` should be used. Note: in the presence of `non_assoc_ring`, these classes are mathematically equivalent (see `topological_semiring.has_continuous_neg_of_mul` or `topological_semiring.to_topological_ring`).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "pi.fintype",
    "statement": "def pi.fintype {α : Type u_1} {β : α → Type u_2} [decidable_eq α] [fintype α] [Π (a : α), fintype (β a)] : fintype (Π (a : α), β a)",
    "theorem": "{α : Type u_1} {β : α → Type u_2} [decidable_eq α] [fintype α] [Π (a : α), fintype (β a)] : fintype (Π (a : α), β a)",
    "args": "{α : Type u_1} {β : α → Type u_2} [decidable_eq α] [fintype α] [Π (a : α), fintype (β a)]",
    "doc_string": "A dependent product of fintypes, indexed by a fintype, is a fintype.",
    "kind": "def",
    "type": "fintype (Π (a : α), β a)"
  },
  {
    "name": "encodable.encode_subtype",
    "statement": "def encodable.encode_subtype {α : Type u_1} {P : α → Prop} [encA : encodable α] : {a // P a} → ℕ",
    "theorem": "{α : Type u_1} {P : α → Prop} [encA : encodable α] : {a // P a} → ℕ",
    "args": "{α : Type u_1} {P : α → Prop} [encA : encodable α]",
    "doc_string": "Explicit encoding function for a decidable subtype of an encodable type",
    "kind": "def",
    "type": "{a // P a} → ℕ"
  },
  {
    "name": "ratfunc.int_degree",
    "statement": "def ratfunc.int_degree {K : Type u} [field K] (x : ratfunc K) : ℤ",
    "theorem": "{K : Type u} [field K] (x : ratfunc K) : ℤ",
    "args": "{K : Type u} [field K] (x : ratfunc K)",
    "doc_string": " `int_degree x` is the degree of the rational function `x`, defined as the difference between the `nat_degree` of its numerator and the `nat_degree` of its denominator. In particular, `int_degree 0 = 0`.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "list.sublist_forall₂",
    "statement": "inductive list.sublist_forall₂ {α : Type u_1} {β : Type u_2} (r : α → β → Prop) : list α → list β → Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop) : list α → list β → Prop",
    "args": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop)",
    "doc_string": "Given a relation `r`, `sublist_forall₂ r l₁ l₂` indicates that there is a sublist of `l₂` such  that `forall₂ r l₁ l₂`.",
    "kind": "inductive",
    "type": "list α → list β → Prop"
  },
  {
    "name": "environment.projection_info",
    "statement": "structure environment.projection_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Consider a type `ψ` which is an inductive datatype using a single constructor `mk (a : α) (b : β) : ψ`. Lean will automatically make two projection functions `a : ψ → α`, `b : ψ → β`. Lean tags these declarations as __projections__. This helps the simplifier / rewriter not have to expand projectors. Eg `a (mk x y)` will automatically reduce to `x`. If you `extend` a structure, all of the projections on the parent will also be created for the child. Projections are also treated differently in the VM for efficiency.  Note that projections have nothing to do with the dot `mylist.map` syntax.  You can find out if a declaration is a projection using `environment.is_projection` which returns `projection_info`.  Data for a projection declaration: - `cname`    is the name of the constructor associated with the projection. - `nparams`  is the number of constructor parameters. Eg `and.intro` has two type parameters. - `idx`      is the parameter being projected by this projection. - `is_class` is tt iff this is a typeclass projection.  ### Examples:  - `and.right` is a projection with ``{cname := `and.intro, nparams := 2, idx := 1, is_class := ff}`` - `ordered_ring.neg` is a projection with ``{cname := `ordered_ring.mk, nparams := 1, idx := 5, is_class := tt}``.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "simple_graph",
    "statement": "structure simple_graph (V : Type u) : Type u",
    "theorem": "(V : Type u) : Type u",
    "args": "(V : Type u)",
    "doc_string": "A simple graph is an irreflexive symmetric relation `adj` on a vertex type `V`. The relation describes which pairs of vertices are adjacent. There is exactly one edge for every pair of adjacent vertices; see `simple_graph.edge_set` for the corresponding edge set.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "order.pfilter.principal",
    "statement": "def order.pfilter.principal {P : Type u_1} [preorder P] (p : P) : order.pfilter P",
    "theorem": "{P : Type u_1} [preorder P] (p : P) : order.pfilter P",
    "args": "{P : Type u_1} [preorder P] (p : P)",
    "doc_string": "The smallest filter containing a given element.",
    "kind": "def",
    "type": "order.pfilter P"
  },
  {
    "name": "onote",
    "statement": "inductive onote  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Recursive definition of an ordinal notation. `zero` denotes the  ordinal 0, and `oadd e n a` is intended to refer to `ω^e * n + a`.  For this to be valid Cantor normal form, we must have the exponents  decrease to the right, but we can't state this condition until we've  defined `repr`, so it is a separate definition `NF`.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "path_connected_space.some_path",
    "statement": "def path_connected_space.some_path {X : Type u_1} [topological_space X] [path_connected_space X] (x y : X) : path x y",
    "theorem": "{X : Type u_1} [topological_space X] [path_connected_space X] (x y : X) : path x y",
    "args": "{X : Type u_1} [topological_space X] [path_connected_space X] (x y : X)",
    "doc_string": "Use path-connectedness to build a path between two points.",
    "kind": "def",
    "type": "path x y"
  },
  {
    "name": "widget.effect",
    "statement": "inductive widget.effect  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " An effect is some change that the widget makes outside of its own state. Usually, giving instructions to the editor to perform some task. - `insert_text_relative` will insert at a line relative to the position of the widget. - `insert_text_absolute` will insert text at the precise position given. - `reveal_position` will move the editor to view the given position. - `highlight_position` will add a text highlight to the given position. - `clear_highlighting` will remove all highlights created with `highlight_position`. - `copy_text` will copy the given text to the clipboard. - `custom` can be used to pass custom effects to the client without having to recompile Lean.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "submodule.nat_power_graded_monoid",
    "statement": "def submodule.nat_power_graded_monoid {S : Type u_3} {R : Type u_4} [comm_semiring S] [semiring R] [algebra S R] (p : submodule S R) : set_like.graded_monoid (λ (i : ℕ), p ^ i)",
    "theorem": "{S : Type u_3} {R : Type u_4} [comm_semiring S] [semiring R] [algebra S R] (p : submodule S R) : set_like.graded_monoid (λ (i : ℕ), p ^ i)",
    "args": "{S : Type u_3} {R : Type u_4} [comm_semiring S] [semiring R] [algebra S R] (p : submodule S R)",
    "doc_string": "A direct sum of powers of a submodule of an algebra has a multiplicative structure.",
    "kind": "def",
    "type": "set_like.graded_monoid (λ (i : ℕ), p ^ i)"
  },
  {
    "name": "rel_hom_class",
    "statement": "structure rel_hom_class (F : Type u_4) {α : out_param (Type u_5)} {β : out_param (Type u_6)} (r : out_param (α → α → Prop)) (s : out_param (β → β → Prop)) : Type (max u_4 u_5 u_6)",
    "theorem": "(F : Type u_4) {α : out_param (Type u_5)} {β : out_param (Type u_6)} (r : out_param (α → α → Prop)) (s : out_param (β → β → Prop)) : Type (max u_4 u_5 u_6)",
    "args": "(F : Type u_4) {α : out_param (Type u_5)} {β : out_param (Type u_6)} (r : out_param (α → α → Prop)) (s : out_param (β → β → Prop))",
    "doc_string": " `rel_hom_class F r s` asserts that `F` is a type of functions such that all `f : F` satisfy `r a b → s (f a) (f b)`.  The relations `r` and `s` are `out_param`s since figuring them out from a goal is a higher-order matching problem that Lean usually can't do unaided.",
    "kind": "structure",
    "type": "Type (max u_4 u_5 u_6)"
  },
  {
    "name": "odd.exists_bit1",
    "statement": "theorem odd.exists_bit1 {α : Type u_2} [semiring α] {a : α} : odd a → (∃ (b : α), a = bit1 b)",
    "theorem": "{α : Type u_2} [semiring α] {a : α} : odd a → (∃ (b : α), a = bit1 b)",
    "args": "{α : Type u_2} [semiring α] {a : α}",
    "doc_string": "**Alias** of the forward direction of odd_iff_exists_bit1`.",
    "kind": "theorem",
    "type": "odd a → (∃ (b : α), a = bit1 b)"
  },
  {
    "name": "padic_val_nat.mul",
    "statement": "theorem padic_val_nat.mul (p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r",
    "theorem": "(p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r",
    "args": "(p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0)",
    "doc_string": "A rewrite lemma for `padic_val_nat p (q * r)` with conditions `q ≠ 0`, `r ≠ 0`.",
    "kind": "theorem",
    "type": "padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r"
  },
  {
    "name": "category_theory.abelian.has_finite_biproducts",
    "statement": "def category_theory.abelian.has_finite_biproducts {C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_finite_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_finite_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C]",
    "doc_string": "An abelian category has finite biproducts.",
    "kind": "def",
    "type": "category_theory.limits.has_finite_biproducts C"
  },
  {
    "name": "group_topology.coinduced",
    "statement": "def group_topology.coinduced {α : Type u_1} {β : Type u_2} [t : topological_space α] [group β] (f : α → β) : group_topology β",
    "theorem": "{α : Type u_1} {β : Type u_2} [t : topological_space α] [group β] (f : α → β) : group_topology β",
    "args": "{α : Type u_1} {β : Type u_2} [t : topological_space α] [group β] (f : α → β)",
    "doc_string": "  Given `f : α → β` and a topology on `α`, the coinduced group topology on `β` is the finest topology such that `f` is continuous and `β` is a topological group.",
    "kind": "def",
    "type": "group_topology β"
  },
  {
    "name": "Meas",
    "statement": "def Meas  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of measurable spaces and measurable functions.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "is_subgroup",
    "statement": "structure is_subgroup {G : Type u_1} [group G] (s : set G) : Prop",
    "theorem": "{G : Type u_1} [group G] (s : set G) : Prop",
    "args": "{G : Type u_1} [group G] (s : set G)",
    "doc_string": "`s` is a subgroup: a set containing 1 and closed under multiplication and inverse.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nat.strong_rec'",
    "statement": "def nat.strong_rec' {p : ℕ → Sort u} (H : Π (n : ℕ), (Π (m : ℕ), m < n → p m) → p n) (n : ℕ) : p n",
    "theorem": "{p : ℕ → Sort u} (H : Π (n : ℕ), (Π (m : ℕ), m < n → p m) → p n) (n : ℕ) : p n",
    "args": "{p : ℕ → Sort u} (H : Π (n : ℕ), (Π (m : ℕ), m < n → p m) → p n) (n : ℕ)",
    "doc_string": "Recursion principle based on `<`.",
    "kind": "def",
    "type": "p n"
  },
  {
    "name": "stream.even",
    "statement": "def stream.even {α : Type u} (s : stream α) : stream α",
    "theorem": "{α : Type u} (s : stream α) : stream α",
    "args": "{α : Type u} (s : stream α)",
    "doc_string": "Elements of a stream with even indices.",
    "kind": "def",
    "type": "stream α"
  },
  {
    "name": "add_subgroup.neg_mem",
    "statement": "theorem add_subgroup.neg_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x ∈ H → -x ∈ H",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x : G} : x ∈ H → -x ∈ H",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x : G}",
    "doc_string": "An `add_subgroup` is closed under inverse.",
    "kind": "theorem",
    "type": "x ∈ H → -x ∈ H"
  },
  {
    "name": "nondiscrete_normed_field",
    "statement": "structure nondiscrete_normed_field (α : Type u_5) : Type u_5",
    "theorem": "(α : Type u_5) : Type u_5",
    "args": "(α : Type u_5)",
    "doc_string": " A nondiscrete normed field is a normed field in which there is an element of norm different from `0` and `1`. This makes it possible to bring any element arbitrarily close to `0` by multiplication by the powers of any element, and thus to relate algebra and topology.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "path_setoid",
    "statement": "def path_setoid (X : Type u_1) [topological_space X] : setoid X",
    "theorem": "(X : Type u_1) [topological_space X] : setoid X",
    "args": "(X : Type u_1) [topological_space X]",
    "doc_string": "The setoid corresponding the equivalence relation of being joined by a continuous path.",
    "kind": "def",
    "type": "setoid X"
  },
  {
    "name": "category_theory.limits.initial_mono_class.of_initial",
    "statement": "theorem category_theory.limits.initial_mono_class.of_initial {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C",
    "theorem": "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C",
    "args": "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X))",
    "doc_string": " To show a category is a `initial_mono_class` it suffices to show every morphism out of the initial object is a monomorphism.",
    "kind": "theorem",
    "type": "category_theory.limits.initial_mono_class C"
  },
  {
    "name": "list.tfae",
    "statement": "def list.tfae (l : list Prop) : Prop",
    "theorem": "(l : list Prop) : Prop",
    "args": "(l : list Prop)",
    "doc_string": "tfae: The Following (propositions) Are Equivalent.  The `tfae_have` and `tfae_finish` tactics can be useful in proofs with `tfae` goals.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_simple_group",
    "statement": "structure is_simple_group (G : Type u_1) [group G] : Prop",
    "theorem": "(G : Type u_1) [group G] : Prop",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "A `group` is simple when it has exactly two normal `subgroup`s.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "finset.to_list",
    "statement": "def finset.to_list {α : Type u_1} (s : finset α) : list α",
    "theorem": "{α : Type u_1} (s : finset α) : list α",
    "args": "{α : Type u_1} (s : finset α)",
    "doc_string": "Produce a list of the elements in the finite set using choice.",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "is_alg_closed.infinite",
    "statement": "def is_alg_closed.infinite {K : Type u_1} [field K] [is_alg_closed K] : infinite K",
    "theorem": "{K : Type u_1} [field K] [is_alg_closed K] : infinite K",
    "args": "{K : Type u_1} [field K] [is_alg_closed K]",
    "doc_string": "Algebraically closed fields are infinite since `Xⁿ⁺¹ - 1` is separable when `#K = n`",
    "kind": "def",
    "type": "infinite K"
  },
  {
    "name": "structure_groupoid.id_mem_maximal_atlas",
    "statement": "theorem structure_groupoid.id_mem_maximal_atlas {H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H ∈ structure_groupoid.maximal_atlas H G",
    "theorem": "{H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H ∈ structure_groupoid.maximal_atlas H G",
    "args": "{H : Type u} [topological_space H] (G : structure_groupoid H)",
    "doc_string": "In the model space, the identity is in any maximal atlas.",
    "kind": "theorem",
    "type": "local_homeomorph.refl H ∈ structure_groupoid.maximal_atlas H G"
  },
  {
    "name": "maximals",
    "statement": "def maximals {α : Type u_1} (r : α → α → Prop) (s : set α) : set α",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s : set α) : set α",
    "args": "{α : Type u_1} (r : α → α → Prop) (s : set α)",
    "doc_string": "Turns a set into an antichain by keeping only the \"maximal\" elements.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "ordset.insert",
    "statement": "def ordset.insert {α : Type u_1} [preorder α] [is_total α has_le.le] [decidable_rel has_le.le] (x : α) (s : ordset α) : ordset α",
    "theorem": "{α : Type u_1} [preorder α] [is_total α has_le.le] [decidable_rel has_le.le] (x : α) (s : ordset α) : ordset α",
    "args": "{α : Type u_1} [preorder α] [is_total α has_le.le] [decidable_rel has_le.le] (x : α) (s : ordset α)",
    "doc_string": "O(log n). Insert an element into the set, preserving balance and the BST property.  If an equivalent element is already in the set, this replaces it.",
    "kind": "def",
    "type": "ordset α"
  },
  {
    "name": "subsemiring.list_sum_mem",
    "statement": "theorem subsemiring.list_sum_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s",
    "args": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {l : list R}",
    "doc_string": "Sum of a list of elements in a `subsemiring` is in the `subsemiring`.",
    "kind": "theorem",
    "type": "(∀ (x : R), x ∈ l → x ∈ s) → l.sum ∈ s"
  },
  {
    "name": "name.has_prefix",
    "statement": "def name.has_prefix (P : name → bool) : name → bool",
    "theorem": "(P : name → bool) : name → bool",
    "args": "(P : name → bool)",
    "doc_string": "Checks whether `nm` has a prefix (including itself) such that P is true",
    "kind": "def",
    "type": "name → bool"
  },
  {
    "name": "Class.univ",
    "statement": "def Class.univ  : Class",
    "theorem": " : Class",
    "args": "",
    "doc_string": "The universal class",
    "kind": "def",
    "type": "Class"
  },
  {
    "name": "tactic.ring2.csring_expr",
    "statement": "inductive tactic.ring2.csring_expr  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " A reflected/meta representation of an expression in a commutative semiring. This representation is a direct translation of such expressions - see `horner_expr` for a normal form.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "left.inv_lt_one_iff",
    "statement": "theorem left.inv_lt_one_iff {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "kind": "theorem",
    "type": "a⁻¹ < 1 ↔ 1 < a"
  },
  {
    "name": "subgroup.saturated",
    "statement": "def subgroup.saturated {G : Type u_1} [group G] (H : subgroup G) : Prop",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : Prop",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": " A subgroup `H` of `G` is *saturated* if for all `n : ℕ` and `g : G` with `g^n ∈ H` we have `n = 0` or `g ∈ H`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lt_add_of_neg_add_lt",
    "statement": "theorem lt_add_of_neg_add_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of inv_mul_lt_iff_lt_mul`.",
    "kind": "theorem",
    "type": "-b + a < c → a < b + c"
  },
  {
    "name": "Gromov_Hausdorff.GH_space",
    "statement": "def Gromov_Hausdorff.GH_space  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The Gromov-Hausdorff space",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "is_subgroup.trivial",
    "statement": "def is_subgroup.trivial (G : Type u_1) [group G] : set G",
    "theorem": "(G : Type u_1) [group G] : set G",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "The trivial subgroup",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "name.append_after",
    "statement": "constant name.append_after  : name → ℕ → name",
    "theorem": " : name → ℕ → name",
    "args": "",
    "doc_string": "`name.append_after n i` return a name of the form n_i",
    "kind": "constant",
    "type": "name → ℕ → name"
  },
  {
    "name": "num.lor",
    "statement": "def num.lor  : num → num → num",
    "theorem": " : num → num → num",
    "args": "",
    "doc_string": "Bitwise \"or\" for `num`.",
    "kind": "def",
    "type": "num → num → num"
  },
  {
    "name": "pgame.left_moves",
    "statement": "def pgame.left_moves  : pgame → Type u",
    "theorem": " : pgame → Type u",
    "args": "",
    "doc_string": "The indexing type for allowable moves by Left.",
    "kind": "def",
    "type": "pgame → Type u"
  },
  {
    "name": "regular_space",
    "statement": "structure regular_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A T₃ space, also known as a regular space (although this condition sometimes  omits T₂), is one in which for every closed `C` and `x ∉ C`, there exist  disjoint open sets containing `x` and `C` respectively.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "turing.blank_extends",
    "statement": "def turing.blank_extends {Γ : Type u_1} [inhabited Γ] (l₁ l₂ : list Γ) : Prop",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (l₁ l₂ : list Γ) : Prop",
    "args": "{Γ : Type u_1} [inhabited Γ] (l₁ l₂ : list Γ)",
    "doc_string": " The `blank_extends` partial order holds of `l₁` and `l₂` if `l₂` is obtained by adding blanks (`default : Γ`) to the end of `l₁`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "first_order.language.Theory",
    "statement": "def first_order.language.Theory (L : first_order.language) : Type (max u v)",
    "theorem": "(L : first_order.language) : Type (max u v)",
    "args": "(L : first_order.language)",
    "doc_string": "A theory is a set of sentences.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "omega_complete_partial_order",
    "statement": "structure omega_complete_partial_order (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " An omega-complete partial order is a partial order with a supremum operation on increasing sequences indexed by natural numbers (which we call `ωSup`). In this sense, it is strictly weaker than join complete semi-lattices as only ω-sized totally ordered sets have a supremum.  See the definition on page 114 of [gunter1992].",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "tactic.suggest.head_symbol_match",
    "statement": "inductive tactic.suggest.head_symbol_match  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A declaration can match the head symbol of the current goal in four possible ways: * `ex`  : an exact match * `mp`  : the declaration returns an `iff`, and the right hand side matches the goal * `mpr` : the declaration returns an `iff`, and the left hand side matches the goal * `both`: the declaration returns an `iff`, and the both sides match the goal",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "list.mfind",
    "statement": "def list.mfind {α : Type u} {m : Type u → Type v} [monad m] [alternative m] (tac : α → m punit) : list α → m α",
    "theorem": "{α : Type u} {m : Type u → Type v} [monad m] [alternative m] (tac : α → m punit) : list α → m α",
    "args": "{α : Type u} {m : Type u → Type v} [monad m] [alternative m] (tac : α → m punit)",
    "doc_string": " `mfind tac l` returns the first element of `l` on which `tac` succeeds, and fails otherwise.",
    "kind": "def",
    "type": "list α → m α"
  },
  {
    "name": "Cauchy.pure_cauchy",
    "statement": "def Cauchy.pure_cauchy {α : Type u} [uniform_space α] (a : α) : Cauchy α",
    "theorem": "{α : Type u} [uniform_space α] (a : α) : Cauchy α",
    "args": "{α : Type u} [uniform_space α] (a : α)",
    "doc_string": "Embedding of `α` into its completion `Cauchy α`",
    "kind": "def",
    "type": "Cauchy α"
  },
  {
    "name": "subtraction_comm_monoid",
    "statement": "structure subtraction_comm_monoid (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": "Commutative `subtraction_monoid`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "ordnode.find_index",
    "statement": "def ordnode.find_index {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) (t : ordnode α) : option ℕ",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) (t : ordnode α) : option ℕ",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) (t : ordnode α)",
    "doc_string": " O(log n). Get the index, counting from the left, of an element equivalent to `x` if it exists.      find_index 2 {1, 2, 4} = some 1     find_index 4 {1, 2, 4} = some 2     find_index 5 {1, 2, 4} = none",
    "kind": "def",
    "type": "option ℕ"
  },
  {
    "name": "complete_boolean_algebra",
    "statement": "structure complete_boolean_algebra (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A complete Boolean algebra is a completely distributive Boolean algebra.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "submodule.fst",
    "statement": "def submodule.fst (R : Type u) (M : Type v) (M₂ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] : submodule R (M × M₂)",
    "theorem": "(R : Type u) (M : Type v) (M₂ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] : submodule R (M × M₂)",
    "args": "(R : Type u) (M : Type v) (M₂ : Type w) [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂]",
    "doc_string": "`M` as a submodule of `M × N`.",
    "kind": "def",
    "type": "submodule R (M × M₂)"
  },
  {
    "name": "denumerable",
    "statement": "structure denumerable (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A denumerable type is (constructively) bijective with `ℕ`. Typeclass equivalent of `α ≃ ℕ`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "fintype.of_finite",
    "statement": "def fintype.of_finite (α : Type u_1) [finite α] : fintype α",
    "theorem": "(α : Type u_1) [finite α] : fintype α",
    "args": "(α : Type u_1) [finite α]",
    "doc_string": " Noncomputably get a `fintype` instance from a `finite` instance. This is not an instance because we want `fintype` instances to be useful for computations.",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "filter.coclosed_compact",
    "statement": "def filter.coclosed_compact (α : Type u_1) [topological_space α] : filter α",
    "theorem": "(α : Type u_1) [topological_space α] : filter α",
    "args": "(α : Type u_1) [topological_space α]",
    "doc_string": " `filter.coclosed_compact` is the filter generated by complements to closed compact sets. In a Hausdorff space, this is the same as `filter.cocompact`.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "AddMon.assoc_add_monoid_hom",
    "statement": "def AddMon.assoc_add_monoid_hom (M : Type u_1) (N : Type u_2) [add_monoid M] [add_monoid N] : Type (max u_2 u_1)",
    "theorem": "(M : Type u_1) (N : Type u_2) [add_monoid M] [add_monoid N] : Type (max u_2 u_1)",
    "args": "(M : Type u_1) (N : Type u_2) [add_monoid M] [add_monoid N]",
    "doc_string": "`add_monoid_hom` doesn't actually assume associativity. This alias is needed to make the category theory machinery work.",
    "kind": "def",
    "type": "Type (max u_2 u_1)"
  },
  {
    "name": "list.reduce_option",
    "statement": "def list.reduce_option {α : Type u_1} : list (option α) → list α",
    "theorem": "{α : Type u_1} : list (option α) → list α",
    "args": "{α : Type u_1}",
    "doc_string": "Drop `none`s from a list, and replace each remaining `some a` with `a`.",
    "kind": "def",
    "type": "list (option α) → list α"
  },
  {
    "name": "path.homotopic.quotient",
    "statement": "def path.homotopic.quotient {X : Type u} [topological_space X] (x₀ x₁ : X) : Type u",
    "theorem": "{X : Type u} [topological_space X] (x₀ x₁ : X) : Type u",
    "args": "{X : Type u} [topological_space X] (x₀ x₁ : X)",
    "doc_string": "The quotient on `path x₀ x₁` by the equivalence relation `path.homotopic`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "pow_two_nonneg",
    "statement": "theorem pow_two_nonneg {R : Type u_4} [linear_ordered_ring R] (a : R) : 0 ≤ a ^ 2",
    "theorem": "{R : Type u_4} [linear_ordered_ring R] (a : R) : 0 ≤ a ^ 2",
    "args": "{R : Type u_4} [linear_ordered_ring R] (a : R)",
    "doc_string": "**Alias** of sq_nonneg`.",
    "kind": "theorem",
    "type": "0 ≤ a ^ 2"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.one_le_succ_nth_stream_b",
    "statement": "theorem generalized_continued_fraction.int_fract_pair.one_le_succ_nth_stream_b {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 ≤ ifp_succ_n.b",
    "theorem": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 ≤ ifp_succ_n.b",
    "args": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n)",
    "doc_string": "Shows that the integer parts of the stream are at least one.",
    "kind": "theorem",
    "type": "1 ≤ ifp_succ_n.b"
  },
  {
    "name": "set.inj_on",
    "statement": "def set.inj_on {α : Type u} {β : Type v} (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u} {β : Type v} (f : α → β) (s : set α)",
    "doc_string": "`f` is injective on `a` if the restriction of `f` to `a` is injective.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_lawful_mvfunctor",
    "statement": "structure is_lawful_mvfunctor {n : ℕ} (F : typevec n → Type u_2) [mvfunctor F] : Prop",
    "theorem": "{n : ℕ} (F : typevec n → Type u_2) [mvfunctor F] : Prop",
    "args": "{n : ℕ} (F : typevec n → Type u_2) [mvfunctor F]",
    "doc_string": "laws for `mvfunctor`",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "matrix.transvection_struct.inv",
    "statement": "def matrix.transvection_struct.inv {n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct n R",
    "theorem": "{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct n R",
    "args": "{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R)",
    "doc_string": " The inverse of a `transvection_struct`, designed so that `t.inv.to_matrix` is the inverse of `t.to_matrix`.",
    "kind": "def",
    "type": "matrix.transvection_struct n R"
  },
  {
    "name": "list.can_lift",
    "statement": "def list.can_lift {α : Type u} {β : Type v} [h : can_lift α β] : can_lift (list α) (list β)",
    "theorem": "{α : Type u} {β : Type v} [h : can_lift α β] : can_lift (list α) (list β)",
    "args": "{α : Type u} {β : Type v} [h : can_lift α β]",
    "doc_string": " If each element of a list can be lifted to some type, then the whole list can be lifted to this type.",
    "kind": "def",
    "type": "can_lift (list α) (list β)"
  },
  {
    "name": "module.End.eigenvalues",
    "statement": "def module.End.eigenvalues {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) : Type v",
    "theorem": "{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) : Type v",
    "args": "{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M)",
    "doc_string": "The eigenvalues of the endomorphism `f`, as a subtype of `R`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "is_localization.fintype'",
    "statement": "def is_localization.fintype' {R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] [fintype R] : fintype S",
    "theorem": "{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] [fintype R] : fintype S",
    "args": "{R : Type u_1} [comm_semiring R] (M : submonoid R) (S : Type u_2) [comm_semiring S] [algebra R S] [is_localization M S] [fintype R]",
    "doc_string": "The localization of a `fintype` is a `fintype`. Cannot be an instance.",
    "kind": "def",
    "type": "fintype S"
  },
  {
    "name": "sequential_space",
    "statement": "structure sequential_space (X : Type u_3) [topological_space X] : Prop",
    "theorem": "(X : Type u_3) [topological_space X] : Prop",
    "args": "(X : Type u_3) [topological_space X]",
    "doc_string": "A sequential space is a space in which 'sequences are enough to probe the topology'. This can be formalised by demanding that the sequential closure and the closure coincide. The following statements show that other topological properties can be deduced from sequences in sequential spaces.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_binary_products",
    "statement": "def category_theory.limits.has_binary_products (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_binary_products` represents a choice of product for every pair of objects.  See <https://stacks.math.columbia.edu/tag/001T>.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "linear_ordered_comm_group_with_zero.topological_space",
    "statement": "def linear_ordered_comm_group_with_zero.topological_space (Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : topological_space Γ₀",
    "theorem": "(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : topological_space Γ₀",
    "args": "(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀]",
    "doc_string": " The topology on a linearly ordered commutative group with a zero element adjoined. A subset U is open if 0 ∉ U or if there is an invertible element γ₀ such that {γ | γ < γ₀} ⊆ U.",
    "kind": "def",
    "type": "topological_space Γ₀"
  },
  {
    "name": "composition.sigma_composition_eq_iff",
    "statement": "theorem composition.sigma_composition_eq_iff {n : ℕ} (i j : Σ (a : composition n), composition a.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks",
    "theorem": "{n : ℕ} (i j : Σ (a : composition n), composition a.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks",
    "args": "{n : ℕ} (i j : Σ (a : composition n), composition a.length)",
    "doc_string": " Rewriting equality in the dependent type `Σ (a : composition n), composition a.length)` in non-dependent terms with lists, requiring that the blocks coincide.",
    "kind": "theorem",
    "type": "i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks"
  },
  {
    "name": "pgame.subsequent",
    "statement": "def pgame.subsequent  : pgame → pgame → Prop",
    "theorem": " : pgame → pgame → Prop",
    "args": "",
    "doc_string": " `subsequent x y` says that `x` can be obtained by playing some nonempty sequence of moves from `y`. It is the transitive closure of `is_option`.",
    "kind": "def",
    "type": "pgame → pgame → Prop"
  },
  {
    "name": "subsemiring.add_mem",
    "statement": "theorem subsemiring.add_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s",
    "args": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R}",
    "doc_string": "A subsemiring is closed under addition.",
    "kind": "theorem",
    "type": "x ∈ s → y ∈ s → x + y ∈ s"
  },
  {
    "name": "polish_space.nat_fun",
    "statement": "def polish_space.nat_fun {α : Type u_1} [topological_space α] [polish_space α] : polish_space (ℕ → α)",
    "theorem": "{α : Type u_1} [topological_space α] [polish_space α] : polish_space (ℕ → α)",
    "args": "{α : Type u_1} [topological_space α] [polish_space α]",
    "doc_string": "Without this instance, `polish_space (ℕ → ℕ)` is not found by typeclass inference.",
    "kind": "def",
    "type": "polish_space (ℕ → α)"
  },
  {
    "name": "shrink",
    "statement": "def shrink (α : Type v) [small α] : Type w",
    "theorem": "(α : Type v) [small α] : Type w",
    "args": "(α : Type v) [small α]",
    "doc_string": "An arbitrarily chosen model in `Type w` for a `w`-small type.",
    "kind": "def",
    "type": "Type w"
  },
  {
    "name": "matrix.sub_right",
    "statement": "def matrix.sub_right {α : Type v} {m l r : ℕ} (A : matrix (fin m) (fin (l + r)) α) : matrix (fin m) (fin r) α",
    "theorem": "{α : Type v} {m l r : ℕ} (A : matrix (fin m) (fin (l + r)) α) : matrix (fin m) (fin r) α",
    "args": "{α : Type v} {m l r : ℕ} (A : matrix (fin m) (fin (l + r)) α)",
    "doc_string": "The right `n × r` part of a `n × (l+r)` matrix.",
    "kind": "def",
    "type": "matrix (fin m) (fin r) α"
  },
  {
    "name": "pos_num.add",
    "statement": "def pos_num.add  : pos_num → pos_num → pos_num",
    "theorem": " : pos_num → pos_num → pos_num",
    "args": "",
    "doc_string": "Addition of two `pos_num`s.",
    "kind": "def",
    "type": "pos_num → pos_num → pos_num"
  },
  {
    "name": "multiset.repeat",
    "statement": "def multiset.repeat {α : Type u_1} (a : α) (n : ℕ) : multiset α",
    "theorem": "{α : Type u_1} (a : α) (n : ℕ) : multiset α",
    "args": "{α : Type u_1} (a : α) (n : ℕ)",
    "doc_string": "`repeat a n` is the multiset containing only `a` with multiplicity `n`.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "empty.elim",
    "statement": "def empty.elim {C : Sort u_1} : empty → C",
    "theorem": "{C : Sort u_1} : empty → C",
    "args": "{C : Sort u_1}",
    "doc_string": "Ex falso, the nondependent eliminator for the `empty` type.",
    "kind": "def",
    "type": "empty → C"
  },
  {
    "name": "has_bot",
    "statement": "structure has_bot (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Typeclass for the `⊥` (`\\bot`) notation",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "uniform_space_of_compact_t2",
    "statement": "def uniform_space_of_compact_t2 {γ : Type u_3} [topological_space γ] [compact_space γ] [t2_space γ] : uniform_space γ",
    "theorem": "{γ : Type u_3} [topological_space γ] [compact_space γ] [t2_space γ] : uniform_space γ",
    "args": "{γ : Type u_3} [topological_space γ] [compact_space γ] [t2_space γ]",
    "doc_string": "The unique uniform structure inducing a given compact Hausdorff topological structure.",
    "kind": "def",
    "type": "uniform_space γ"
  },
  {
    "name": "finset.pi.empty",
    "statement": "def finset.pi.empty {α : Type u_1} (β : α → Type u_2) (a : α) (h : a ∈ ∅) : β a",
    "theorem": "{α : Type u_1} (β : α → Type u_2) (a : α) (h : a ∈ ∅) : β a",
    "args": "{α : Type u_1} (β : α → Type u_2) (a : α) (h : a ∈ ∅)",
    "doc_string": " The empty dependent product function, defined on the empty set. The assumption `a ∈ ∅` is never satisfied.",
    "kind": "def",
    "type": "β a"
  },
  {
    "name": "finmap.replace",
    "statement": "def finmap.replace {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : finmap β) : finmap β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : finmap β) : finmap β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (s : finmap β)",
    "doc_string": "Replace a key with a given value in a finite map.  If the key is not present it does nothing.",
    "kind": "def",
    "type": "finmap β"
  },
  {
    "name": "set.interval",
    "statement": "def set.interval {α : Type u} [linear_order α] (a b : α) : set α",
    "theorem": "{α : Type u} [linear_order α] (a b : α) : set α",
    "args": "{α : Type u} [linear_order α] (a b : α)",
    "doc_string": "`interval a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "set.sInter",
    "statement": "def set.sInter {α : Type u_1} (S : set (set α)) : set α",
    "theorem": "{α : Type u_1} (S : set (set α)) : set α",
    "args": "{α : Type u_1} (S : set (set α))",
    "doc_string": "Intersection of a set of sets.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "SemiRing.assoc_ring_hom",
    "statement": "def SemiRing.assoc_ring_hom (M : Type u_1) (N : Type u_2) [semiring M] [semiring N] : Type (max u_1 u_2)",
    "theorem": "(M : Type u_1) (N : Type u_2) [semiring M] [semiring N] : Type (max u_1 u_2)",
    "args": "(M : Type u_1) (N : Type u_2) [semiring M] [semiring N]",
    "doc_string": " `ring_hom` doesn't actually assume associativity. This alias is needed to make the category theory machinery work. We use the same trick in `category_theory.Mon.assoc_monoid_hom`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "lower_central_series_is_descending_central_series",
    "statement": "theorem lower_central_series_is_descending_central_series {G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)",
    "theorem": "{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)",
    "args": "{G : Type u_1} [group G]",
    "doc_string": "The lower central series of a group is a descending central series.",
    "kind": "theorem",
    "type": "is_descending_central_series (lower_central_series G)"
  },
  {
    "name": "cofinite_topology",
    "statement": "def cofinite_topology (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " A type synonym equiped with the topology whose open sets are the empty set and the sets with finite complements.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "pgame.left_wins",
    "statement": "def pgame.left_wins (G : pgame) : Prop",
    "theorem": "(G : pgame) : Prop",
    "args": "(G : pgame)",
    "doc_string": "The left player can always win",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pmf.to_outer_measure",
    "statement": "def pmf.to_outer_measure {α : Type u_1} (p : pmf α) : measure_theory.outer_measure α",
    "theorem": "{α : Type u_1} (p : pmf α) : measure_theory.outer_measure α",
    "args": "{α : Type u_1} (p : pmf α)",
    "doc_string": "Construct an `outer_measure` from a `pmf`, by assigning measure to each set `s : set α` equal  to the sum of `p x` for for each `x ∈ α`",
    "kind": "def",
    "type": "measure_theory.outer_measure α"
  },
  {
    "name": "specializes",
    "statement": "def specializes {X : Type u_1} [topological_space X] (x y : X) : Prop",
    "theorem": "{X : Type u_1} [topological_space X] (x y : X) : Prop",
    "args": "{X : Type u_1} [topological_space X] (x y : X)",
    "doc_string": "`x` specializes to `y` if `y` is in the closure of `x`. The notation used is `x ⤳ y`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_group.to_add_monoid",
    "statement": "def add_group.to_add_monoid (G : Type u) [add_group G] : add_monoid G",
    "theorem": "(G : Type u) [add_group G] : add_monoid G",
    "args": "(G : Type u) [add_group G]",
    "doc_string": "Abbreviation for `@sub_neg_monoid.to_add_monoid _ (@add_group.to_sub_neg_monoid _ _)`.  Useful because it corresponds to the fact that `AddGroup` is a subcategory of `AddMon`. Not an instance since it duplicates `@sub_neg_monoid.to_add_monoid _ (@add_group.to_sub_neg_monoid _ _)`.",
    "kind": "def",
    "type": "add_monoid G"
  },
  {
    "name": "continuous_add_monoid_hom_class",
    "statement": "structure continuous_add_monoid_hom_class (F : Type u_9) (α : Type u_10) (β : Type u_11) [add_monoid α] [add_monoid β] [topological_space α] [topological_space β] : Type (max u_10 u_11 u_9)",
    "theorem": "(F : Type u_9) (α : Type u_10) (β : Type u_11) [add_monoid α] [add_monoid β] [topological_space α] [topological_space β] : Type (max u_10 u_11 u_9)",
    "args": "(F : Type u_9) (α : Type u_10) (β : Type u_11) [add_monoid α] [add_monoid β] [topological_space α] [topological_space β]",
    "doc_string": " `continuous_add_monoid_hom_class F α β` states that `F` is a type of continuous additive monoid homomorphisms.  You should also extend this typeclass when you extend `continuous_add_monoid_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_11 u_9)"
  },
  {
    "name": "lattice.biimp",
    "statement": "def lattice.biimp {α : Type u_1} [has_compl α] [has_sup α] [has_inf α] (a b : α) : α",
    "theorem": "{α : Type u_1} [has_compl α] [has_sup α] [has_inf α] (a b : α) : α",
    "args": "{α : Type u_1} [has_compl α] [has_sup α] [has_inf α] (a b : α)",
    "doc_string": "Equivalence as a binary operation on a boolean algebra.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "add_subsemigroup.comap",
    "statement": "def add_subsemigroup.comap {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup N) : add_subsemigroup M",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup N) : add_subsemigroup M",
    "args": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (f : add_hom M N) (S : add_subsemigroup N)",
    "doc_string": "The preimage of an `add_subsemigroup` along an `add_semigroup` homomorphism is an `add_subsemigroup`.",
    "kind": "def",
    "type": "add_subsemigroup M"
  },
  {
    "name": "group.to_monoid",
    "statement": "def group.to_monoid (G : Type u) [group G] : monoid G",
    "theorem": "(G : Type u) [group G] : monoid G",
    "args": "(G : Type u) [group G]",
    "doc_string": " Abbreviation for `@div_inv_monoid.to_monoid _ (@group.to_div_inv_monoid _ _)`.  Useful because it corresponds to the fact that `Grp` is a subcategory of `Mon`. Not an instance since it duplicates `@div_inv_monoid.to_monoid _ (@group.to_div_inv_monoid _ _)`. See note [reducible non-instances].",
    "kind": "def",
    "type": "monoid G"
  },
  {
    "name": "category_theory.shift_functor_ess_surj",
    "statement": "def category_theory.shift_functor_ess_surj (C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.ess_surj (category_theory.shift_functor C i)",
    "theorem": "(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.ess_surj (category_theory.shift_functor C i)",
    "args": "(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A)",
    "doc_string": "Shifting by `n` is an essentially surjective functor.",
    "kind": "def",
    "type": "category_theory.ess_surj (category_theory.shift_functor C i)"
  },
  {
    "name": "sbtw_cyclic",
    "statement": "theorem sbtw_cyclic {α : Type u_1} [circular_preorder α] {a b c : α} : has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} : has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α}",
    "doc_string": " The order of the `↔` has been chosen so that `rw sbtw_cyclic` cycles to the right while `rw ←sbtw_cyclic` cycles to the left (thus following the prepended arrow).",
    "kind": "theorem",
    "type": "has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b"
  },
  {
    "name": "zmod.field",
    "statement": "def zmod.field (p : ℕ) [fact (nat.prime p)] : field (zmod p)",
    "theorem": "(p : ℕ) [fact (nat.prime p)] : field (zmod p)",
    "args": "(p : ℕ) [fact (nat.prime p)]",
    "doc_string": "Field structure on `zmod p` if `p` is prime.",
    "kind": "def",
    "type": "field (zmod p)"
  },
  {
    "name": "is_max_filter",
    "statement": "def is_max_filter {α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (l : filter α) (a : α)",
    "doc_string": "`is_max_filter f l a` means that `f x ≤ f a` in some `l`-neighborhood of `a`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "continuous_multilinear_map.mk_pi_algebra_fin",
    "statement": "def continuous_multilinear_map.mk_pi_algebra_fin (R : Type u) (n : ℕ) (A : Type u_1) [comm_semiring R] [semiring A] [algebra R A] [topological_space A] [has_continuous_mul A] : continuous_multilinear_map R (λ (i : fin n), A) A",
    "theorem": "(R : Type u) (n : ℕ) (A : Type u_1) [comm_semiring R] [semiring A] [algebra R A] [topological_space A] [has_continuous_mul A] : continuous_multilinear_map R (λ (i : fin n), A) A",
    "args": "(R : Type u) (n : ℕ) (A : Type u_1) [comm_semiring R] [semiring A] [algebra R A] [topological_space A] [has_continuous_mul A]",
    "doc_string": " The continuous multilinear map on `A^n`, where `A` is a normed algebra over `𝕜`, associating to `m` the product of all the `m i`.  See also: `continuous_multilinear_map.mk_pi_algebra`.",
    "kind": "def",
    "type": "continuous_multilinear_map R (λ (i : fin n), A) A"
  },
  {
    "name": "class_group.fintype",
    "statement": "def class_group.fintype {R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype (class_group R K)",
    "theorem": "{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype (class_group R K)",
    "args": "{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R]",
    "doc_string": " The class group of principal ideal domain is finite (in fact a singleton). TODO: generalize to Dedekind domains",
    "kind": "def",
    "type": "fintype (class_group R K)"
  },
  {
    "name": "is_cyclic",
    "statement": "structure is_cyclic (α : Type u) [group α] : Prop",
    "theorem": "(α : Type u) [group α] : Prop",
    "args": "(α : Type u) [group α]",
    "doc_string": "A group is called *cyclic* if it is generated by a single element.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "bump_covering.single",
    "statement": "def bump_covering.single {ι : Type u} {X : Type v} [topological_space X] (i : ι) (s : set X) : bump_covering ι X s",
    "theorem": "{ι : Type u} {X : Type v} [topological_space X] (i : ι) (s : set X) : bump_covering ι X s",
    "args": "{ι : Type u} {X : Type v} [topological_space X] (i : ι) (s : set X)",
    "doc_string": " A `bump_covering` that consists of a single function, uniformly equal to one, defined as an example for `inhabited` instance.",
    "kind": "def",
    "type": "bump_covering ι X s"
  },
  {
    "name": "finset.add_monoid",
    "statement": "def finset.add_monoid {α : Type u_2} [decidable_eq α] [add_monoid α] : add_monoid (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [add_monoid α] : add_monoid (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [add_monoid α]",
    "doc_string": "`finset α` is an `add_monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_monoid (finset α)"
  },
  {
    "name": "matrix.update_column",
    "statement": "def matrix.update_column {m : Type u_2} {n : Type u_3} {α : Type v} [decidable_eq n] (M : matrix m n α) (j : n) (b : m → α) : matrix m n α",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} [decidable_eq n] (M : matrix m n α) (j : n) (b : m → α) : matrix m n α",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} [decidable_eq n] (M : matrix m n α) (j : n) (b : m → α)",
    "doc_string": "Update, i.e. replace the `j`th column of matrix `A` with the values in `b`.",
    "kind": "def",
    "type": "matrix m n α"
  },
  {
    "name": "polynomial.cyclotomic_injective",
    "statement": "theorem polynomial.cyclotomic_injective {R : Type u_1} [comm_ring R] [char_zero R] : function.injective (λ (n : ℕ), polynomial.cyclotomic n R)",
    "theorem": "{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (λ (n : ℕ), polynomial.cyclotomic n R)",
    "args": "{R : Type u_1} [comm_ring R] [char_zero R]",
    "doc_string": "Over a ring `R` of characteristic zero, `λ n, cyclotomic n R` is injective.",
    "kind": "theorem",
    "type": "function.injective (λ (n : ℕ), polynomial.cyclotomic n R)"
  },
  {
    "name": "category_theory.limits.binary_bicone.of_limit_cone",
    "statement": "def category_theory.limits.binary_bicone.of_limit_cone {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_limit t) : category_theory.limits.binary_bicone X Y",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_limit t) : category_theory.limits.binary_bicone X Y",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_limit t)",
    "doc_string": "We can turn any limit cone over a pair into a bicone.",
    "kind": "def",
    "type": "category_theory.limits.binary_bicone X Y"
  },
  {
    "name": "finmap.singleton",
    "statement": "def finmap.singleton {α : Type u} {β : α → Type v} (a : α) (b : β a) : finmap β",
    "theorem": "{α : Type u} {β : α → Type v} (a : α) (b : β a) : finmap β",
    "args": "{α : Type u} {β : α → Type v} (a : α) (b : β a)",
    "doc_string": "The singleton map.",
    "kind": "def",
    "type": "finmap β"
  },
  {
    "name": "sign_type.le",
    "statement": "inductive sign_type.le  : sign_type → sign_type → Prop",
    "theorem": " : sign_type → sign_type → Prop",
    "args": "",
    "doc_string": "The less-than relation on signs.",
    "kind": "inductive",
    "type": "sign_type → sign_type → Prop"
  },
  {
    "name": "category_theory.End.division_ring",
    "statement": "def category_theory.End.division_ring {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X : C} [category_theory.simple X] : division_ring (category_theory.End X)",
    "theorem": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X : C} [category_theory.simple X] : division_ring (category_theory.End X)",
    "args": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] {X : C} [category_theory.simple X]",
    "doc_string": "In any preadditive category with kernels, the endomorphisms of a simple object form a division ring.",
    "kind": "def",
    "type": "division_ring (category_theory.End X)"
  },
  {
    "name": "lie_subalgebra.canonically_ordered_add_monoid",
    "statement": "def lie_subalgebra.canonically_ordered_add_monoid {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : canonically_ordered_add_monoid (lie_subalgebra R L)",
    "theorem": "{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : canonically_ordered_add_monoid (lie_subalgebra R L)",
    "args": "{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": "This is not an instance, as it would stop `⊥` being the simp-normal form (via `bot_eq_zero`).",
    "kind": "def",
    "type": "canonically_ordered_add_monoid (lie_subalgebra R L)"
  },
  {
    "name": "tmp_complete_lattice",
    "statement": "def tmp_complete_lattice {α : Type u} : complete_lattice (topological_space α)",
    "theorem": "{α : Type u} : complete_lattice (topological_space α)",
    "args": "{α : Type u}",
    "doc_string": " The \"temporary\" order `tmp_order` on `topological_space α`, i.e. the inclusion order, is a complete lattice.  (Note that later `topological_space α` will equipped with the dual order to `tmp_order`).",
    "kind": "def",
    "type": "complete_lattice (topological_space α)"
  },
  {
    "name": "subsingleton_fin_zero",
    "statement": "def subsingleton_fin_zero  : subsingleton (fin 0)",
    "theorem": " : subsingleton (fin 0)",
    "args": "",
    "doc_string": "`fin 0` is a subsingleton.",
    "kind": "def",
    "type": "subsingleton (fin 0)"
  },
  {
    "name": "category_theory.limits.has_biproducts_of_shape",
    "statement": "structure category_theory.limits.has_biproducts_of_shape (J : Type v) (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "theorem": "(J : Type v) (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "args": "(J : Type v) (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C]",
    "doc_string": "`C` has biproducts of shape `J` if we have a limit and a colimit, with the same cone points, of every function `F : J → C`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "subgroup.normal_core",
    "statement": "def subgroup.normal_core {G : Type u_1} [group G] (H : subgroup G) : subgroup G",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : subgroup G",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": " The normal core of a subgroup `H` is the largest normal subgroup of `G` contained in `H`, as shown by `subgroup.normal_core_eq_supr`.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "add_action.stabilizer",
    "statement": "def add_action.stabilizer (α : Type u) {β : Type v} [add_group α] [add_action α β] (b : β) : add_subgroup α",
    "theorem": "(α : Type u) {β : Type v} [add_group α] [add_action α β] (b : β) : add_subgroup α",
    "args": "(α : Type u) {β : Type v} [add_group α] [add_action α β] (b : β)",
    "doc_string": "The stabilizer of an element under an action, i.e. what sends the element to itself. An additive subgroup.",
    "kind": "def",
    "type": "add_subgroup α"
  },
  {
    "name": "unique_factorization_monoid.normalization_monoid",
    "statement": "def unique_factorization_monoid.normalization_monoid {α : Type u_1} [cancel_comm_monoid_with_zero α] [nontrivial α] [unique_factorization_monoid α] : normalization_monoid α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [nontrivial α] [unique_factorization_monoid α] : normalization_monoid α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [nontrivial α] [unique_factorization_monoid α]",
    "doc_string": "Noncomputably defines a `normalization_monoid` structure on a `unique_factorization_monoid`.",
    "kind": "def",
    "type": "normalization_monoid α"
  },
  {
    "name": "has_lipschitz_mul.C",
    "statement": "def has_lipschitz_mul.C (β : Type u_2) [pseudo_metric_space β] [monoid β] [has_lipschitz_mul β] : nnreal",
    "theorem": "(β : Type u_2) [pseudo_metric_space β] [monoid β] [has_lipschitz_mul β] : nnreal",
    "args": "(β : Type u_2) [pseudo_metric_space β] [monoid β] [has_lipschitz_mul β]",
    "doc_string": "The Lipschitz constant of a monoid `β` satisfying `has_lipschitz_mul`",
    "kind": "def",
    "type": "nnreal"
  },
  {
    "name": "finset.up_shadow_empty",
    "statement": "theorem finset.up_shadow_empty {α : Type u_1} [decidable_eq α] [fintype α] : ∅.up_shadow = ∅",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] : ∅.up_shadow = ∅",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α]",
    "doc_string": "The upper shadow of the empty set is empty.",
    "kind": "theorem",
    "type": "∅.up_shadow = ∅"
  },
  {
    "name": "is_compact.inter_right",
    "statement": "theorem is_compact.inter_right {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)",
    "args": "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t)",
    "doc_string": "The intersection of a compact set and a closed set is a compact set.",
    "kind": "theorem",
    "type": "is_compact (s ∩ t)"
  },
  {
    "name": "nat.decidable_prime",
    "statement": "def nat.decidable_prime (p : ℕ) : decidable (nat.prime p)",
    "theorem": "(p : ℕ) : decidable (nat.prime p)",
    "args": "(p : ℕ)",
    "doc_string": "This instance is faster in the virtual machine than `decidable_prime_1`, but slower in the kernel.  If you need to prove that a particular number is prime, in any case you should not use `dec_trivial`, but rather `by norm_num`, which is much faster.",
    "kind": "def",
    "type": "decidable (nat.prime p)"
  },
  {
    "name": "bounded_lattice_hom",
    "statement": "structure bounded_lattice_hom (α : Type u_7) (β : Type u_8) [lattice α] [lattice β] [bounded_order α] [bounded_order β] : Type (max u_7 u_8)",
    "theorem": "(α : Type u_7) (β : Type u_8) [lattice α] [lattice β] [bounded_order α] [bounded_order β] : Type (max u_7 u_8)",
    "args": "(α : Type u_7) (β : Type u_8) [lattice α] [lattice β] [bounded_order α] [bounded_order β]",
    "doc_string": "The type of bounded lattice homomorphisms from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8)"
  },
  {
    "name": "padic_val_int.zero",
    "statement": "theorem padic_val_int.zero {p : ℕ} : padic_val_int p 0 = 0",
    "theorem": "{p : ℕ} : padic_val_int p 0 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_int p 0` is 0 for any `p`.",
    "kind": "theorem",
    "type": "padic_val_int p 0 = 0"
  },
  {
    "name": "unique.mk'",
    "statement": "def unique.mk' (α : Sort u) [h₁ : inhabited α] [subsingleton α] : unique α",
    "theorem": "(α : Sort u) [h₁ : inhabited α] [subsingleton α] : unique α",
    "args": "(α : Sort u) [h₁ : inhabited α] [subsingleton α]",
    "doc_string": " Construct `unique` from `inhabited` and `subsingleton`. Making this an instance would create a loop in the class inheritance graph.",
    "kind": "def",
    "type": "unique α"
  },
  {
    "name": "non_unital_non_assoc_ring",
    "statement": "structure non_unital_non_assoc_ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A not-necessarily-unital, not-necessarily-associative ring.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "witt_vector.witt_pow",
    "statement": "def witt_vector.witt_pow (p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ)",
    "doc_string": "The polynomials used for defining repeated addition of the ring of Witt vectors.",
    "kind": "def",
    "type": "ℕ → mv_polynomial (fin 1 × ℕ) ℤ"
  },
  {
    "name": "add_con.coe_zero",
    "statement": "theorem add_con.coe_zero {M : Type u_1} [add_zero_class M] {c : add_con M} : ↑0 = 0",
    "theorem": "{M : Type u_1} [add_zero_class M] {c : add_con M} : ↑0 = 0",
    "args": "{M : Type u_1} [add_zero_class M] {c : add_con M}",
    "doc_string": "The 0 of the quotient of an `add_monoid` by an additive congruence relation is the equivalence class of the `add_monoid`'s 0.",
    "kind": "theorem",
    "type": "↑0 = 0"
  },
  {
    "name": "division_monoid",
    "statement": "structure division_monoid (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that `(a * b)⁻¹ = b⁻¹ * a⁻¹` and `a * b = 1 → a⁻¹ = b`.  This is the immediate common ancestor of `group` and `group_with_zero`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "witt_vector.one_poly",
    "statement": "def witt_vector.one_poly (n : ℕ) : mv_polynomial ℕ ℤ",
    "theorem": "(n : ℕ) : mv_polynomial ℕ ℤ",
    "args": "(n : ℕ)",
    "doc_string": "The coefficients of `1 : 𝕎 R` as polynomials.",
    "kind": "def",
    "type": "mv_polynomial ℕ ℤ"
  },
  {
    "name": "lagrange.basis",
    "statement": "def lagrange.basis {F : Type u} [decidable_eq F] [field F] (s : finset F) (x : F) : polynomial F",
    "theorem": "{F : Type u} [decidable_eq F] [field F] (s : finset F) (x : F) : polynomial F",
    "args": "{F : Type u} [decidable_eq F] [field F] (s : finset F) (x : F)",
    "doc_string": "Lagrange basis polynomials that evaluate to 1 at `x` and 0 at other elements of `s`.",
    "kind": "def",
    "type": "polynomial F"
  },
  {
    "name": "set.sized",
    "statement": "def set.sized {α : Type u_1} (r : ℕ) (A : set (finset α)) : Prop",
    "theorem": "{α : Type u_1} (r : ℕ) (A : set (finset α)) : Prop",
    "args": "{α : Type u_1} (r : ℕ) (A : set (finset α))",
    "doc_string": "`sized r A` means that every finset in `A` has size `r`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_submonoid.localization_map.away_map",
    "statement": "def add_submonoid.localization_map.away_map {M : Type u_1} [add_comm_monoid M] (x : M) (N' : Type u_2) [add_comm_monoid N'] : Type (max u_1 u_2)",
    "theorem": "{M : Type u_1} [add_comm_monoid M] (x : M) (N' : Type u_2) [add_comm_monoid N'] : Type (max u_1 u_2)",
    "args": "{M : Type u_1} [add_comm_monoid M] (x : M) (N' : Type u_2) [add_comm_monoid N']",
    "doc_string": "Given `x : M`, the type of `add_comm_monoid` homomorphisms `f : M →+ N` such that `N` is isomorphic to the localization of `M` at the submonoid generated by `x`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "int.dvd_of_dvd_mul_left_of_gcd_one",
    "statement": "theorem int.dvd_of_dvd_mul_left_of_gcd_one {a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b",
    "theorem": "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b",
    "args": "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1)",
    "doc_string": " Euclid's lemma: if `a ∣ b * c` and `gcd a c = 1` then `a ∣ b`. Compare with `is_coprime.dvd_of_dvd_mul_left` and `unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors`",
    "kind": "theorem",
    "type": "a ∣ b"
  },
  {
    "name": "nndist_self",
    "statement": "theorem nndist_self {α : Type u} [pseudo_metric_space α] (a : α) : has_nndist.nndist a a = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] (a : α) : has_nndist.nndist a a = 0",
    "args": "{α : Type u} [pseudo_metric_space α] (a : α)",
    "doc_string": "`nndist x x` vanishes",
    "kind": "theorem",
    "type": "has_nndist.nndist a a = 0"
  },
  {
    "name": "smt_config",
    "statement": "structure smt_config  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration for the smt_state object.  - em_attr: is the attribute name for the hinst_lemmas   that are used for ematching",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "associated.setoid",
    "statement": "def associated.setoid (α : Type u_1) [monoid α] : setoid α",
    "theorem": "(α : Type u_1) [monoid α] : setoid α",
    "args": "(α : Type u_1) [monoid α]",
    "doc_string": "The setoid of the relation `x ~ᵤ y` iff there is a unit `u` such that `x * u = y`",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "nat.arithmetic_function.card_distinct_factors",
    "statement": "def nat.arithmetic_function.card_distinct_factors  : nat.arithmetic_function ℕ",
    "theorem": " : nat.arithmetic_function ℕ",
    "args": "",
    "doc_string": "`ω n` is the number of distinct prime factors of `n`.",
    "kind": "def",
    "type": "nat.arithmetic_function ℕ"
  },
  {
    "name": "topological_add_group.to_uniform_space",
    "statement": "def topological_add_group.to_uniform_space (G : Type u_1) [add_comm_group G] [topological_space G] [topological_add_group G] : uniform_space G",
    "theorem": "(G : Type u_1) [add_comm_group G] [topological_space G] [topological_add_group G] : uniform_space G",
    "args": "(G : Type u_1) [add_comm_group G] [topological_space G] [topological_add_group G]",
    "doc_string": "The right uniformity on a topological group",
    "kind": "def",
    "type": "uniform_space G"
  },
  {
    "name": "Fintype.skeleton",
    "statement": "def Fintype.skeleton  : Type u",
    "theorem": " : Type u",
    "args": "",
    "doc_string": "The \"standard\" skeleton for `Fintype`. This is the full subcategory of `Fintype` spanned by objects of the form `ulift (fin n)` for `n : ℕ`. We parameterize the objects of `Fintype.skeleton` directly as `ulift ℕ`, as the type `ulift (fin m) ≃ ulift (fin n)` is nonempty if and only if `n = m`. Specifying universes, `skeleton : Type u` is a small skeletal category equivalent to `Fintype.{u}`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "linter",
    "statement": "structure linter  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A linting test for the `#lint` command.  `test` defines a test to perform on every declaration. It should never fail. Returning `none` signifies a passing test. Returning `some msg` reports a failing test with error `msg`.  `no_errors_found` is the message printed when all tests are negative, and `errors_found` is printed when at least one test is positive.  If `is_fast` is false, this test will be omitted from `#lint-`.  If `auto_decls` is true, this test will also be executed on automatically generated declarations.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "function.argmin",
    "statement": "def function.argmin {α : Type u_1} {β : Type u_2} (f : α → β) [has_lt β] (h : well_founded has_lt.lt) [nonempty α] : α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) [has_lt β] (h : well_founded has_lt.lt) [nonempty α] : α",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) [has_lt β] (h : well_founded has_lt.lt) [nonempty α]",
    "doc_string": " Given a function `f : α → β` where `β` carries a well-founded `<`, this is an element of `α` whose image under `f` is minimal in the sense of `function.not_lt_argmin`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "pseudo_emetric_space.replace_uniformity",
    "statement": "def pseudo_emetric_space.replace_uniformity {α : Type u_1} [U : uniform_space α] (m : pseudo_emetric_space α) (H : uniformity α = uniformity α) : pseudo_emetric_space α",
    "theorem": "{α : Type u_1} [U : uniform_space α] (m : pseudo_emetric_space α) (H : uniformity α = uniformity α) : pseudo_emetric_space α",
    "args": "{α : Type u_1} [U : uniform_space α] (m : pseudo_emetric_space α) (H : uniformity α = uniformity α)",
    "doc_string": " Auxiliary function to replace the uniformity on a pseudoemetric space with a uniformity which is equal to the original one, but maybe not defeq. This is useful if one wants to construct a pseudoemetric space with a specified uniformity. See Note [forgetful inheritance] explaining why having definitionally the right uniformity is often important.",
    "kind": "def",
    "type": "pseudo_emetric_space α"
  },
  {
    "name": "con_gen.rel",
    "statement": "inductive con_gen.rel {M : Type u_1} [has_mul M] (r : M → M → Prop) : M → M → Prop",
    "theorem": "{M : Type u_1} [has_mul M] (r : M → M → Prop) : M → M → Prop",
    "args": "{M : Type u_1} [has_mul M] (r : M → M → Prop)",
    "doc_string": "The inductively defined smallest multiplicative congruence relation containing a given binary    relation.",
    "kind": "inductive",
    "type": "M → M → Prop"
  },
  {
    "name": "pfunctor.M.ichildren",
    "statement": "def pfunctor.M.ichildren {F : pfunctor} [inhabited F.M] [decidable_eq F.A] (i : F.Idx) (x : F.M) : F.M",
    "theorem": "{F : pfunctor} [inhabited F.M] [decidable_eq F.A] (i : F.Idx) (x : F.M) : F.M",
    "args": "{F : pfunctor} [inhabited F.M] [decidable_eq F.A] (i : F.Idx) (x : F.M)",
    "doc_string": " select a subtree using a `i : F.Idx` or return an arbitrary tree if `i` designates no subtree of `x`",
    "kind": "def",
    "type": "F.M"
  },
  {
    "name": "eq_zero_of_zero_eq_one",
    "statement": "theorem eq_zero_of_zero_eq_one {M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀)",
    "doc_string": "In a monoid with zero, if zero equals one, then zero is the only element.",
    "kind": "theorem",
    "type": "a = 0"
  },
  {
    "name": "tactic.unify_equations.unification_step_result",
    "statement": "inductive tactic.unify_equations.unification_step_result  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The result of a unification step:  - `simplified hs` means that the step succeeded and produced some new (simpler)   equations `hs`. `hs` can be empty. - `goal_solved` means that the step succeeded and solved the goal (by deriving a   contradiction from the given equation). - `not_simplified` means that the step failed to simplify the equation.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "algebraic_geometry.AffineScheme",
    "statement": "def algebraic_geometry.AffineScheme  : set algebraic_geometry.Scheme",
    "theorem": " : set algebraic_geometry.Scheme",
    "args": "",
    "doc_string": "The category of affine schemes",
    "kind": "def",
    "type": "set algebraic_geometry.Scheme"
  },
  {
    "name": "ultrafilter.semigroup",
    "statement": "def ultrafilter.semigroup {M : Type u_1} [semigroup M] : semigroup (ultrafilter M)",
    "theorem": "{M : Type u_1} [semigroup M] : semigroup (ultrafilter M)",
    "args": "{M : Type u_1} [semigroup M]",
    "doc_string": "Semigroup structure on `ultrafilter M` induced by a semigroup structure on `M`.",
    "kind": "def",
    "type": "semigroup (ultrafilter M)"
  },
  {
    "name": "localization.away",
    "statement": "def localization.away {M : Type u_1} [comm_monoid M] (x : M) : Type u_1",
    "theorem": "{M : Type u_1} [comm_monoid M] (x : M) : Type u_1",
    "args": "{M : Type u_1} [comm_monoid M] (x : M)",
    "doc_string": "Given `x : M`, the localization of `M` at the submonoid generated by `x`, as a quotient.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "module.fintype_of_fintype",
    "statement": "def module.fintype_of_fintype {ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype ι] (b : basis ι R M) [fintype R] : fintype M",
    "theorem": "{ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype ι] (b : basis ι R M) [fintype R] : fintype M",
    "args": "{ι : Type u_1} {R : Type u_3} {M : Type u_5} [semiring R] [add_comm_monoid M] [module R M] [fintype ι] (b : basis ι R M) [fintype R]",
    "doc_string": "A module over a finite ring that admits a finite basis is finite.",
    "kind": "def",
    "type": "fintype M"
  },
  {
    "name": "multiset.Iic",
    "statement": "def multiset.Iic {α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : multiset α",
    "theorem": "{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : multiset α",
    "args": "{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α)",
    "doc_string": "The multiset of elements `x` such that `x ≤ b`. Basically `set.Iic b` as a multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "order_ring_iso",
    "statement": "structure order_ring_iso (α : Type u_6) (β : Type u_7) [has_mul α] [has_add α] [has_le α] [has_mul β] [has_add β] [has_le β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [has_mul α] [has_add α] [has_le α] [has_mul β] [has_add β] [has_le β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [has_mul α] [has_add α] [has_le α] [has_mul β] [has_add β] [has_le β]",
    "doc_string": " `order_ring_hom α β` is the type of order-preserving semiring isomorphisms between `α` and `β`.  When possible, instead of parametrizing results over `(f : order_ring_iso α β)`, you should parametrize over `(F : Type*) [order_ring_iso_class F α β] (f : F)`.  When you extend this structure, make sure to extend `order_ring_iso_class`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "computation",
    "statement": "def computation (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "`computation α` is the type of unbounded computations returning `α`.  An element of `computation α` is an infinite sequence of `option α` such  that if `f n = some a` for some `n` then it is constantly `some a` after that.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "subring.to_subsemiring",
    "statement": "def subring.to_subsemiring {R : Type u} [ring R] (self : subring R) : subsemiring R",
    "theorem": "{R : Type u} [ring R] (self : subring R) : subsemiring R",
    "args": "{R : Type u} [ring R] (self : subring R)",
    "doc_string": "Reinterpret a `subring` as a `subsemiring`.",
    "kind": "def",
    "type": "subsemiring R"
  },
  {
    "name": "pgame.has_le",
    "statement": "def pgame.has_le  : has_le pgame",
    "theorem": " : has_le pgame",
    "args": "",
    "doc_string": " The less or equal relation on pre-games.  If `0 ≤ x`, then Left can win `x` as the second player.",
    "kind": "def",
    "type": "has_le pgame"
  },
  {
    "name": "compact_exhaustion.shiftr",
    "statement": "def compact_exhaustion.shiftr {α : Type u} [topological_space α] (K : compact_exhaustion α) : compact_exhaustion α",
    "theorem": "{α : Type u} [topological_space α] (K : compact_exhaustion α) : compact_exhaustion α",
    "args": "{α : Type u} [topological_space α] (K : compact_exhaustion α)",
    "doc_string": "Prepend the empty set to a compact exhaustion `K n`.",
    "kind": "def",
    "type": "compact_exhaustion α"
  },
  {
    "name": "Top.presheaf",
    "statement": "def Top.presheaf (C : Type u) [category_theory.category C] (X : Top) : Type (max v u)",
    "theorem": "(C : Type u) [category_theory.category C] (X : Top) : Type (max v u)",
    "args": "(C : Type u) [category_theory.category C] (X : Top)",
    "doc_string": "The category of `C`-valued presheaves on a (bundled) topological space `X`.",
    "kind": "def",
    "type": "Type (max v u)"
  },
  {
    "name": "lie_algebra.derived_series",
    "statement": "def lie_algebra.derived_series (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ℕ) : lie_ideal R L",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ℕ) : lie_ideal R L",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (k : ℕ)",
    "doc_string": "The derived series of Lie ideals of a Lie algebra.",
    "kind": "def",
    "type": "lie_ideal R L"
  },
  {
    "name": "continuous.snd'",
    "statement": "theorem continuous.snd' {α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : β → γ} (hf : continuous f) : continuous (λ (x : α × β), f x.snd)",
    "theorem": "{α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : β → γ} (hf : continuous f) : continuous (λ (x : α × β), f x.snd)",
    "args": "{α : Type u} {β : Type v} {γ : Type u_1} [topological_space α] [topological_space β] [topological_space γ] {f : β → γ} (hf : continuous f)",
    "doc_string": "Precomposing `f` with `prod.snd` is continuous",
    "kind": "theorem",
    "type": "continuous (λ (x : α × β), f x.snd)"
  },
  {
    "name": "with_top.comm_semiring",
    "statement": "def with_top.comm_semiring {α : Type u} [decidable_eq α] [canonically_ordered_comm_semiring α] [nontrivial α] : comm_semiring (with_top α)",
    "theorem": "{α : Type u} [decidable_eq α] [canonically_ordered_comm_semiring α] [nontrivial α] : comm_semiring (with_top α)",
    "args": "{α : Type u} [decidable_eq α] [canonically_ordered_comm_semiring α] [nontrivial α]",
    "doc_string": " This instance requires `canonically_ordered_comm_semiring` as it is the smallest class that derives from both `non_assoc_non_unital_semiring` and `canonically_ordered_add_monoid`, both of which are required for distributivity.",
    "kind": "def",
    "type": "comm_semiring (with_top α)"
  },
  {
    "name": "Compactum_to_CompHaus.faithful",
    "statement": "theorem Compactum_to_CompHaus.faithful  : category_theory.faithful Compactum_to_CompHaus",
    "theorem": " : category_theory.faithful Compactum_to_CompHaus",
    "args": "",
    "doc_string": "The functor Compactum_to_CompHaus is faithful.",
    "kind": "theorem",
    "type": "category_theory.faithful Compactum_to_CompHaus"
  },
  {
    "name": "group_topology.complete_semilattice_Inf",
    "statement": "def group_topology.complete_semilattice_Inf {α : Type u} [group α] : complete_semilattice_Inf (group_topology α)",
    "theorem": "{α : Type u} [group α] : complete_semilattice_Inf (group_topology α)",
    "args": "{α : Type u} [group α]",
    "doc_string": " Group topologies on `γ` form a complete lattice, with `⊥` the discrete topology and `⊤` the indiscrete topology.  The infimum of a collection of group topologies is the topology generated by all their open sets (which is a group topology).  The supremum of two group topologies `s` and `t` is the infimum of the family of all group topologies contained in the intersection of `s` and `t`.",
    "kind": "def",
    "type": "complete_semilattice_Inf (group_topology α)"
  },
  {
    "name": "continuous.connected_components_lift",
    "statement": "def continuous.connected_components_lift {α : Type u} {β : Type v} [topological_space α] [topological_space β] [totally_disconnected_space β] {f : α → β} (h : continuous f) : connected_components α → β",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] [totally_disconnected_space β] {f : α → β} (h : continuous f) : connected_components α → β",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] [totally_disconnected_space β] {f : α → β} (h : continuous f)",
    "doc_string": "The lift to `connected_components α` of a continuous map from `α` to a totally disconnected space",
    "kind": "def",
    "type": "connected_components α → β"
  },
  {
    "name": "and_or_distrib_right",
    "statement": "theorem and_or_distrib_right {a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
    "theorem": "{a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
    "args": "{a b c : Prop}",
    "doc_string": "`∨` distributes over `∧` (on the right).",
    "kind": "theorem",
    "type": "a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)"
  },
  {
    "name": "continuous_add_monoid_hom.diag",
    "statement": "def continuous_add_monoid_hom.diag (A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A (A × A)",
    "theorem": "(A : Type u_4) [add_monoid A] [topological_space A] : continuous_add_monoid_hom A (A × A)",
    "args": "(A : Type u_4) [add_monoid A] [topological_space A]",
    "doc_string": "The continuous homomorphism given by the diagonal embedding.",
    "kind": "def",
    "type": "continuous_add_monoid_hom A (A × A)"
  },
  {
    "name": "con.map_gen",
    "statement": "def con.map_gen {M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (f : M → N) : con N",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (f : M → N) : con N",
    "args": "{M : Type u_1} {N : Type u_2} [has_mul M] [has_mul N] (c : con M) (f : M → N)",
    "doc_string": "Given a function `f`, the smallest congruence relation containing the binary relation on `f`'s    image defined by '`x ≈ y` iff the elements of `f⁻¹(x)` are related to the elements of `f⁻¹(y)`    by a congruence relation `c`.'",
    "kind": "def",
    "type": "con N"
  },
  {
    "name": "matrix.is_self_adjoint",
    "statement": "def matrix.is_self_adjoint {R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J A : matrix n n R₃) : Prop",
    "theorem": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J A : matrix n n R₃) : Prop",
    "args": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J A : matrix n n R₃)",
    "doc_string": " The condition for a square matrix `A` to be self-adjoint with respect to the square matrix `J`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "mul_le_of_le_inv_mul",
    "statement": "theorem mul_le_of_le_inv_mul {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : b ≤ a⁻¹ * c → a * b ≤ c",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : b ≤ a⁻¹ * c → a * b ≤ c",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of le_inv_mul_iff_mul_le`.",
    "kind": "theorem",
    "type": "b ≤ a⁻¹ * c → a * b ≤ c"
  },
  {
    "name": "parser.err_static",
    "statement": "structure parser.err_static {α : Type} (p : parser α) : Prop",
    "theorem": "{α : Type} (p : parser α) : Prop",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "A `parser α` is defined to be `err_static` if it does not move on error.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "powers.self_mem",
    "statement": "theorem powers.self_mem {M : Type u_1} [monoid M] {x : M} : x ∈ powers x",
    "theorem": "{M : Type u_1} [monoid M] {x : M} : x ∈ powers x",
    "args": "{M : Type u_1} [monoid M] {x : M}",
    "doc_string": "An element of a monoid is in the set of that element's natural number powers.",
    "kind": "theorem",
    "type": "x ∈ powers x"
  },
  {
    "name": "Mon",
    "statement": "def Mon  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of monoids and monoid morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "matrix.det_fin_zero",
    "statement": "theorem matrix.det_fin_zero {R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1",
    "theorem": "{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1",
    "args": "{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R}",
    "doc_string": "Determinant of 0x0 matrix",
    "kind": "theorem",
    "type": "A.det = 1"
  },
  {
    "name": "denumerable.sum",
    "statement": "def denumerable.sum {α : Type u_1} {β : Type u_2} [denumerable α] [denumerable β] : denumerable (α ⊕ β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [denumerable α] [denumerable β] : denumerable (α ⊕ β)",
    "args": "{α : Type u_1} {β : Type u_2} [denumerable α] [denumerable β]",
    "doc_string": "If `α` and `β` are denumerable, then so is their sum.",
    "kind": "def",
    "type": "denumerable (α ⊕ β)"
  },
  {
    "name": "Exists",
    "statement": "inductive Exists {α : Sort u} (p : α → Prop) : Prop",
    "theorem": "{α : Sort u} (p : α → Prop) : Prop",
    "args": "{α : Sort u} (p : α → Prop)",
    "doc_string": "The existential quantifier.  To prove a goal of the form `⊢ ∃ x, p x`, you can provide a witness `y` with the tactic `existsi y`. If you are working in a project that depends on mathlib, then we recommend the `use` tactic instead. You'll then be left with the goal `⊢ p y`.  To extract a witness `x` and proof `hx : p x` from a hypothesis `h : ∃ x, p x`, use the tactic `cases h with x hx`. See also the mathlib tactics `obtain` and `rcases`.",
    "kind": "inductive",
    "type": "Prop"
  },
  {
    "name": "left.mul_lt_one_of_le_of_lt",
    "statement": "theorem left.mul_lt_one_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one_of_le_of_lt`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "finset.cons",
    "statement": "def finset.cons {α : Type u_1} (a : α) (s : finset α) (h : a ∉ s) : finset α",
    "theorem": "{α : Type u_1} (a : α) (s : finset α) (h : a ∉ s) : finset α",
    "args": "{α : Type u_1} (a : α) (s : finset α) (h : a ∉ s)",
    "doc_string": " `cons a s h` is the set `{a} ∪ s` containing `a` and the elements of `s`. It is the same as `insert a s` when it is defined, but unlike `insert a s` it does not require `decidable_eq α`, and the union is guaranteed to be disjoint.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "ereal.neg_le",
    "statement": "theorem ereal.neg_le {a b : ereal} : -a ≤ b ↔ -b ≤ a",
    "theorem": "{a b : ereal} : -a ≤ b ↔ -b ≤ a",
    "args": "{a b : ereal}",
    "doc_string": "`-a ≤ b ↔ -b ≤ a` on `ereal`.",
    "kind": "theorem",
    "type": "-a ≤ b ↔ -b ≤ a"
  },
  {
    "name": "is_square_decidable",
    "statement": "def is_square_decidable {α : Type u_2} [has_mul α] [fintype α] [decidable_eq α] : decidable_pred is_square",
    "theorem": "{α : Type u_2} [has_mul α] [fintype α] [decidable_eq α] : decidable_pred is_square",
    "args": "{α : Type u_2} [has_mul α] [fintype α] [decidable_eq α]",
    "doc_string": "Create a decidability instance for `is_square` on `fintype`s.",
    "kind": "def",
    "type": "decidable_pred is_square"
  },
  {
    "name": "generalized_continued_fraction.convergents'_aux",
    "statement": "def generalized_continued_fraction.convergents'_aux {K : Type u_2} [division_ring K] : seq (generalized_continued_fraction.pair K) → ℕ → K",
    "theorem": "{K : Type u_2} [division_ring K] : seq (generalized_continued_fraction.pair K) → ℕ → K",
    "args": "{K : Type u_2} [division_ring K]",
    "doc_string": "Returns the approximation of the fraction described by the given sequence up to a given position n. For example, `convergents'_aux [(1, 2), (3, 4), (5, 6)] 2 = 1 / (2 + 3 / 4)` and `convergents'_aux [(1, 2), (3, 4), (5, 6)] 0 = 0`.",
    "kind": "def",
    "type": "seq (generalized_continued_fraction.pair K) → ℕ → K"
  },
  {
    "name": "locally_convex_space",
    "statement": "structure locally_convex_space (𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Prop",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Prop",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [ordered_semiring 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E]",
    "doc_string": " A `locally_convex_space` is a topological semimodule over an ordered semiring in which convex neighborhoods of a point form a neighborhood basis at that point.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "zpow_rec",
    "statement": "def zpow_rec {M : Type u_1} [has_one M] [has_mul M] [has_inv M] : ℤ → M → M",
    "theorem": "{M : Type u_1} [has_one M] [has_mul M] [has_inv M] : ℤ → M → M",
    "args": "{M : Type u_1} [has_one M] [has_mul M] [has_inv M]",
    "doc_string": " The fundamental power operation in a group. `zpow_rec n a = a*a*...*a` n times, for integer `n`. Use instead `a ^ n`,  which has better definitional behavior.",
    "kind": "def",
    "type": "ℤ → M → M"
  },
  {
    "name": "add_units.has_continuous_add",
    "statement": "def add_units.has_continuous_add {α : Type u_2} [topological_space α] [add_monoid α] [has_continuous_add α] : has_continuous_add (add_units α)",
    "theorem": "{α : Type u_2} [topological_space α] [add_monoid α] [has_continuous_add α] : has_continuous_add (add_units α)",
    "args": "{α : Type u_2} [topological_space α] [add_monoid α] [has_continuous_add α]",
    "doc_string": "If addition on an additive monoid is continuous, then addition on the additive units of the monoid, with respect to the induced topology, is continuous.  Negation is also continuous, but we register this in a later file, `topology.algebra.group`, because the predicate `has_continuous_neg` has not yet been defined.",
    "kind": "def",
    "type": "has_continuous_add (add_units α)"
  },
  {
    "name": "continuous_add_monoid_hom",
    "statement": "structure continuous_add_monoid_hom (A : Type u_9) (B : Type u_10) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : Type (max u_10 u_9)",
    "theorem": "(A : Type u_9) (B : Type u_10) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : Type (max u_10 u_9)",
    "args": "(A : Type u_9) (B : Type u_10) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B]",
    "doc_string": " The type of continuous additive monoid homomorphisms from `α` to `β`.  When possible, instead of parametrizing results over `(f : continuous_add_monoid_hom α β)`, you should parametrize over `(F : Type*) [continuous_add_monoid_hom_class F α β] (f : F)`.  When you extend this structure, make sure to extend `continuous_add_monoid_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_10 u_9)"
  },
  {
    "name": "category_theory.limits.binary_fan",
    "statement": "def category_theory.limits.binary_fan {C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] (X Y : C)",
    "doc_string": "A binary fan is just a cone on a diagram indexing a product.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "dlist.singleton",
    "statement": "def dlist.singleton {α : Type u} (x : α) : dlist α",
    "theorem": "{α : Type u} (x : α) : dlist α",
    "args": "{α : Type u} (x : α)",
    "doc_string": "Create dlist with a single element",
    "kind": "def",
    "type": "dlist α"
  },
  {
    "name": "add_units.is_add_unit_add_add_units",
    "statement": "theorem add_units.is_add_unit_add_add_units {M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + ↑u) ↔ is_add_unit a",
    "theorem": "{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + ↑u) ↔ is_add_unit a",
    "args": "{M : Type u_1} [add_monoid M] (a : M) (u : add_units M)",
    "doc_string": "Addition of a `u : add_units M` on the right doesn't affect `is_add_unit`.",
    "kind": "theorem",
    "type": "is_add_unit (a + ↑u) ↔ is_add_unit a"
  },
  {
    "name": "upper_set.Ioi",
    "statement": "def upper_set.Ioi {α : Type u_1} [preorder α] (a : α) : upper_set α",
    "theorem": "{α : Type u_1} [preorder α] (a : α) : upper_set α",
    "args": "{α : Type u_1} [preorder α] (a : α)",
    "doc_string": "The smallest upper set containing a given element.",
    "kind": "def",
    "type": "upper_set α"
  },
  {
    "name": "measure_theory.adapted",
    "statement": "def measure_theory.adapted {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] (f : measure_theory.filtration ι m) (u : ι → α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] (f : measure_theory.filtration ι m) (u : ι → α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : measurable_space α} [topological_space β] [preorder ι] (f : measure_theory.filtration ι m) (u : ι → α → β)",
    "doc_string": " A sequence of functions `u` is adapted to a filtration `f` if for all `i`, `u i` is `f i`-measurable.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "linarith.branch",
    "statement": "def linarith.branch  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Some preprocessors perform branching case splits. A `branch` is used to track one of these case splits. The first component, an `expr`, is the goal corresponding to this branch of the split, given as a metavariable. The `list expr` component is the list of hypotheses for `linarith` in this branch. Every `expr` in this list should be type correct in the context of the associated goal.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "category_theory.limits.has_zero_object.zero_morphisms_of_zero_object",
    "statement": "def category_theory.limits.has_zero_object.zero_morphisms_of_zero_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_zero_morphisms C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_zero_morphisms C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C]",
    "doc_string": "A category with a zero object has zero morphisms.     It is rarely a good idea to use this. Many categories that have a zero object have zero    morphisms for some other reason, for example from additivity. Library code that uses    `zero_morphisms_of_zero_object` will then be incompatible with these categories because    the `has_zero_morphisms` instances will not be definitionally equal. For this reason library    code should generally ask for an instance of `has_zero_morphisms` separately, even if it already    asks for an instance of `has_zero_objects`.",
    "kind": "def",
    "type": "category_theory.limits.has_zero_morphisms C"
  },
  {
    "name": "category_theory.additive_category",
    "statement": "structure category_theory.additive_category (C : Type u) [category_theory.category C] : Type (max u u_1)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u u_1)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A preadditive category `C` is called additive if it has all finite biproducts. See <https://stacks.math.columbia.edu/tag/0104>.",
    "kind": "structure",
    "type": "Type (max u u_1)"
  },
  {
    "name": "num.of_nat'",
    "statement": "def num.of_nat'  : ℕ → num",
    "theorem": " : ℕ → num",
    "args": "",
    "doc_string": "Converts a `nat` to a `num`.",
    "kind": "def",
    "type": "ℕ → num"
  },
  {
    "name": "ring.dimension_le_one",
    "statement": "def ring.dimension_le_one (R : Type u_1) [comm_ring R] : Prop",
    "theorem": "(R : Type u_1) [comm_ring R] : Prop",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": "A ring `R` has Krull dimension at most one if all nonzero prime ideals are maximal.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "comm_semigroup",
    "statement": "structure comm_semigroup (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": "A commutative semigroup is a type with an associative commutative `(*)`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "cardinal.cantor",
    "statement": "theorem cardinal.cantor (a : cardinal) : a < 2 ^ a",
    "theorem": "(a : cardinal) : a < 2 ^ a",
    "args": "(a : cardinal)",
    "doc_string": "**Cantor's theorem**",
    "kind": "theorem",
    "type": "a < 2 ^ a"
  },
  {
    "name": "seminorm_family.add_group_filter_basis",
    "statement": "def seminorm_family.add_group_filter_basis {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm_family 𝕜 E ι) [nonempty ι] : add_group_filter_basis E",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm_family 𝕜 E ι) [nonempty ι] : add_group_filter_basis E",
    "args": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] (p : seminorm_family 𝕜 E ι) [nonempty ι]",
    "doc_string": "The `add_group_filter_basis` induced by the filter basis `seminorm_basis_zero`.",
    "kind": "def",
    "type": "add_group_filter_basis E"
  },
  {
    "name": "pi.ordered_add_comm_monoid",
    "statement": "def pi.ordered_add_comm_monoid {ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), ordered_add_comm_monoid (Z i)] : ordered_add_comm_monoid (Π (i : ι), Z i)",
    "theorem": "{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), ordered_add_comm_monoid (Z i)] : ordered_add_comm_monoid (Π (i : ι), Z i)",
    "args": "{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), ordered_add_comm_monoid (Z i)]",
    "doc_string": "The product of a family of ordered additive commutative monoids is   an ordered additive commutative monoid.",
    "kind": "def",
    "type": "ordered_add_comm_monoid (Π (i : ι), Z i)"
  },
  {
    "name": "multiset.disjoint",
    "statement": "def multiset.disjoint {α : Type u_1} (s t : multiset α) : Prop",
    "theorem": "{α : Type u_1} (s t : multiset α) : Prop",
    "args": "{α : Type u_1} (s t : multiset α)",
    "doc_string": "`disjoint s t` means that `s` and `t` have no elements in common.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_of_fin_add_order.apply",
    "statement": "theorem is_of_fin_add_order.apply {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i)",
    "theorem": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i)",
    "args": "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η)",
    "doc_string": "If a direct product has finite additive order then so does each component.",
    "kind": "theorem",
    "type": "is_of_fin_add_order (x i)"
  },
  {
    "name": "measure_theory.content",
    "statement": "structure measure_theory.content (G : Type w) [topological_space G] : Type w",
    "theorem": "(G : Type w) [topological_space G] : Type w",
    "args": "(G : Type w) [topological_space G]",
    "doc_string": " A content is an additive function on compact sets taking values in `ℝ≥0`. It is a device from which one can define a measure.",
    "kind": "structure",
    "type": "Type w"
  },
  {
    "name": "euclidean_domain",
    "statement": "structure euclidean_domain (R : Type u) : Type u",
    "theorem": "(R : Type u) : Type u",
    "args": "(R : Type u)",
    "doc_string": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,  satisfying `b * (a / b) + a % b = a`.  The definition of a euclidean domain usually includes a valuation function `R → ℕ`.  This definition is slightly generalised to include a well founded relation  `r` with the property that `r (a % b) b`, instead of a valuation.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "category_theory.limits.has_finite_coproducts",
    "statement": "structure category_theory.limits.has_finite_coproducts (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category has finite coproducts if there is a chosen colimit for every diagram with shape `discrete J`, where we have `[fintype J]`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "pos_num.lor",
    "statement": "def pos_num.lor  : pos_num → pos_num → pos_num",
    "theorem": " : pos_num → pos_num → pos_num",
    "args": "",
    "doc_string": "Bitwise \"or\" for `pos_num`.",
    "kind": "def",
    "type": "pos_num → pos_num → pos_num"
  },
  {
    "name": "filter.tendsto_at_top_at_top_of_monotone'",
    "statement": "theorem filter.tendsto_at_top_at_top_of_monotone' {ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top",
    "theorem": "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top",
    "args": "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u))",
    "doc_string": " If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded above, then `tendsto u at_top at_top`.",
    "kind": "theorem",
    "type": "filter.tendsto u filter.at_top filter.at_top"
  },
  {
    "name": "sub_left_lt_of_lt_add",
    "statement": "theorem sub_left_lt_of_lt_add {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → a - b < c",
    "theorem": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → a - b < c",
    "args": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of sub_lt_iff_lt_add'`.",
    "kind": "theorem",
    "type": "a < b + c → a - b < c"
  },
  {
    "name": "rack.pre_envel_group",
    "statement": "inductive rack.pre_envel_group (R : Type u) : Type u",
    "theorem": "(R : Type u) : Type u",
    "args": "(R : Type u)",
    "doc_string": "Free generators of the enveloping group.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "topological_space.pseudo_metrizable_space_pseudo_metric",
    "statement": "def topological_space.pseudo_metrizable_space_pseudo_metric (X : Type u_1) [topological_space X] [h : topological_space.pseudo_metrizable_space X] : pseudo_metric_space X",
    "theorem": "(X : Type u_1) [topological_space X] [h : topological_space.pseudo_metrizable_space X] : pseudo_metric_space X",
    "args": "(X : Type u_1) [topological_space X] [h : topological_space.pseudo_metrizable_space X]",
    "doc_string": "Construct on a metrizable space a metric compatible with the topology.",
    "kind": "def",
    "type": "pseudo_metric_space X"
  },
  {
    "name": "padic_val_int.of_nat",
    "statement": "theorem padic_val_int.of_nat {p n : ℕ} : padic_val_int p ↑n = padic_val_nat p n",
    "theorem": "{p n : ℕ} : padic_val_int p ↑n = padic_val_nat p n",
    "args": "{p n : ℕ}",
    "doc_string": "The p-adic value of an natural is its p-adic_value as an integer",
    "kind": "theorem",
    "type": "padic_val_int p ↑n = padic_val_nat p n"
  },
  {
    "name": "finset.colex",
    "statement": "def finset.colex (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "We define this type synonym to refer to the colexicographic ordering on finsets rather than the natural subset ordering.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "structure_groupoid.local_invariant_prop",
    "statement": "structure structure_groupoid.local_invariant_prop {H : Type u_1} [topological_space H] {H' : Type u_3} [topological_space H'] (G : structure_groupoid H) (G' : structure_groupoid H') (P : (H → H') → set H → H → Prop) : Prop",
    "theorem": "{H : Type u_1} [topological_space H] {H' : Type u_3} [topological_space H'] (G : structure_groupoid H) (G' : structure_groupoid H') (P : (H → H') → set H → H → Prop) : Prop",
    "args": "{H : Type u_1} [topological_space H] {H' : Type u_3} [topological_space H'] (G : structure_groupoid H) (G' : structure_groupoid H') (P : (H → H') → set H → H → Prop)",
    "doc_string": " Structure recording good behavior of a property of a triple `(f, s, x)` where `f` is a function, `s` a set and `x` a point. Good behavior here means locality and invariance under given groupoids (both in the source and in the target). Given such a good behavior, the lift of this property to charted spaces admitting these groupoids will inherit the good behavior.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "strong_rank_condition",
    "statement": "structure strong_rank_condition (R : Type u) [semiring R] : Prop",
    "theorem": "(R : Type u) [semiring R] : Prop",
    "args": "(R : Type u) [semiring R]",
    "doc_string": "We say that `R` satisfies the strong rank condition if `(fin n → R) →ₗ[R] (fin m → R)` injective    implies `n ≤ m`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "inv_le_inv",
    "statement": "theorem inv_le_inv {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption.",
    "kind": "theorem",
    "type": "a⁻¹ ≤ b⁻¹ ↔ b ≤ a"
  },
  {
    "name": "category_theory.large_category",
    "statement": "def category_theory.large_category (C : Type (u+1)) : Type (u+1)",
    "theorem": "(C : Type (u+1)) : Type (u+1)",
    "args": "(C : Type (u+1))",
    "doc_string": "A `large_category` has objects in one universe level higher than the universe level of the morphisms. It is useful for examples such as the category of types, or the category of groups, etc.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "measure_theory.measure.haar",
    "statement": "def measure_theory.measure.haar {G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G",
    "theorem": "{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [locally_compact_space G] : measure_theory.measure G",
    "args": "{G : Type u_1} [group G] [topological_space G] [t2_space G] [topological_group G] [measurable_space G] [borel_space G] [locally_compact_space G]",
    "doc_string": "`haar` is some choice of a Haar measure, on a locally compact group.",
    "kind": "def",
    "type": "measure_theory.measure G"
  },
  {
    "name": "lie_hom",
    "statement": "structure lie_hom (R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)",
    "theorem": "(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)",
    "args": "(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L']",
    "doc_string": "A morphism of Lie algebras is a linear map respecting the bracket operations.",
    "kind": "structure",
    "type": "Type (max v w)"
  },
  {
    "name": "inv.is_group_hom",
    "statement": "theorem inv.is_group_hom {α : Type u} [comm_group α] : is_group_hom has_inv.inv",
    "theorem": "{α : Type u} [comm_group α] : is_group_hom has_inv.inv",
    "args": "{α : Type u} [comm_group α]",
    "doc_string": "Inversion is a group homomorphism if the group is commutative.",
    "kind": "theorem",
    "type": "is_group_hom has_inv.inv"
  },
  {
    "name": "num.div2",
    "statement": "def num.div2  : num → num",
    "theorem": " : num → num",
    "args": "",
    "doc_string": "Divides a `num` by `2`",
    "kind": "def",
    "type": "num → num"
  },
  {
    "name": "totally_bounded.closure",
    "statement": "theorem totally_bounded.closure {α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s) : totally_bounded (closure s)",
    "theorem": "{α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s) : totally_bounded (closure s)",
    "args": "{α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s)",
    "doc_string": "The closure of a totally bounded set is totally bounded.",
    "kind": "theorem",
    "type": "totally_bounded (closure s)"
  },
  {
    "name": "tendsto_rpow_neg_div",
    "statement": "theorem tendsto_rpow_neg_div  : filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)",
    "theorem": " : filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)",
    "args": "",
    "doc_string": "The function `x ^ (-1 / x)` tends to `1` at `+∞`.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)"
  },
  {
    "name": "matrix.pivot.list_transvec_col",
    "statement": "def matrix.pivot.list_transvec_col {𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) : list (matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)",
    "theorem": "{𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜) : list (matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)",
    "args": "{𝕜 : Type u_3} [field 𝕜] {r : ℕ} (M : matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)",
    "doc_string": " A list of transvections such that multiplying on the left with these transvections will replace the last column with zeroes.",
    "kind": "def",
    "type": "list (matrix (fin r ⊕ unit) (fin r ⊕ unit) 𝕜)"
  },
  {
    "name": "is_closed_set_of_cluster_pt",
    "statement": "theorem is_closed_set_of_cluster_pt {α : Type u} [topological_space α] {f : filter α} : is_closed {x : α | cluster_pt x f}",
    "theorem": "{α : Type u} [topological_space α] {f : filter α} : is_closed {x : α | cluster_pt x f}",
    "args": "{α : Type u} [topological_space α] {f : filter α}",
    "doc_string": " The set of cluster points of a filter is closed. In particular, the set of limit points of a sequence is closed.",
    "kind": "theorem",
    "type": "is_closed {x : α | cluster_pt x f}"
  },
  {
    "name": "has_le.le.not_lt",
    "statement": "theorem has_le.le.not_lt {α : Type u} [preorder α] {a b : α} (h : a ≤ b) : ¬b < a",
    "theorem": "{α : Type u} [preorder α] {a b : α} (h : a ≤ b) : ¬b < a",
    "args": "{α : Type u} [preorder α] {a b : α} (h : a ≤ b)",
    "doc_string": "**Alias** of not_lt_of_le`.",
    "kind": "theorem",
    "type": "¬b < a"
  },
  {
    "name": "category_theory.limits.biproduct.bicone",
    "statement": "def category_theory.limits.biproduct.bicone {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) [category_theory.limits.has_biproduct F] : category_theory.limits.bicone F",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) [category_theory.limits.has_biproduct F] : category_theory.limits.bicone F",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) [category_theory.limits.has_biproduct F]",
    "doc_string": "A bicone for `F` which is both a limit cone and a colimit cocone.",
    "kind": "def",
    "type": "category_theory.limits.bicone F"
  },
  {
    "name": "slim_check.injective_function",
    "statement": "inductive slim_check.injective_function (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Data structure specifying a total function using a list of pairs and a default value returned when the input is not in the domain of the partial function.  `map_to_self f` encodes `x ↦ f x` when `x ∈ f` and `x ↦ x`, i.e. `x` to itself, otherwise.  We use `Σ` to encode mappings instead of `×` because we rely on the association list API defined in `data.list.sigma`.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "finset.lcm",
    "statement": "def finset.lcm {α : Type u_1} {β : Type u_2} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : finset β) (f : β → α) : α",
    "theorem": "{α : Type u_1} {β : Type u_2} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : finset β) (f : β → α) : α",
    "args": "{α : Type u_1} {β : Type u_2} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : finset β) (f : β → α)",
    "doc_string": "Least common multiple of a finite set",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "encodable.decode_list",
    "statement": "def encodable.decode_list {α : Type u_1} [encodable α] : ℕ → option (list α)",
    "theorem": "{α : Type u_1} [encodable α] : ℕ → option (list α)",
    "args": "{α : Type u_1} [encodable α]",
    "doc_string": "Explicit decoding function for `list α`",
    "kind": "def",
    "type": "ℕ → option (list α)"
  },
  {
    "name": "set.add_comm_semigroup",
    "statement": "def set.add_comm_semigroup {α : Type u_2} [add_comm_semigroup α] : add_comm_semigroup (set α)",
    "theorem": "{α : Type u_2} [add_comm_semigroup α] : add_comm_semigroup (set α)",
    "args": "{α : Type u_2} [add_comm_semigroup α]",
    "doc_string": "`set α` is an `add_comm_semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_comm_semigroup (set α)"
  },
  {
    "name": "filter.at_top",
    "statement": "def filter.at_top {α : Type u_3} [preorder α] : filter α",
    "theorem": "{α : Type u_3} [preorder α] : filter α",
    "args": "{α : Type u_3} [preorder α]",
    "doc_string": "`at_top` is the filter representing the limit `→ ∞` on an ordered set.  It is generated by the collection of up-sets `{b | a ≤ b}`.  (The preorder need not have a top element for this to be well defined,  and indeed is trivial when a top element exists.)",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "function.is_fixed_pt.comp",
    "statement": "theorem function.is_fixed_pt.comp {α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x",
    "theorem": "{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x",
    "args": "{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x)",
    "doc_string": "If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`.",
    "kind": "theorem",
    "type": "function.is_fixed_pt (f ∘ g) x"
  },
  {
    "name": "add_units",
    "statement": "structure add_units (α : Type u) [add_monoid α] : Type u",
    "theorem": "(α : Type u) [add_monoid α] : Type u",
    "args": "(α : Type u) [add_monoid α]",
    "doc_string": " Units of an `add_monoid`, bundled version.  An element of an `add_monoid` is a unit if it has a two-sided additive inverse. This version bundles the inverse element so that it can be computed. For a predicate see `is_add_unit`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "zmod.legendre_sym",
    "statement": "def zmod.legendre_sym (p : ℕ) [fact (nat.prime p)] (a : ℤ) : ℤ",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) : ℤ",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ)",
    "doc_string": " The Legendre symbol of `a : ℤ` and a prime `p`, `legendre_sym p a`, is an integer defined as  * `0` if `a` is `0` modulo `p`; * `1` if `a` is a square modulo `p` * `-1` otherwise.  Note the order of the arguments! The advantage of the order chosen here is that `legendre_sym p` is a multiplicative function `ℤ → ℤ`.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "ordinal.univ",
    "statement": "def ordinal.univ  : ordinal",
    "theorem": " : ordinal",
    "args": "",
    "doc_string": "`univ.{u v}` is the order type of the ordinals of `Type u` as a member  of `ordinal.{v}` (when `u < v`). It is an inaccessible cardinal.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "simple_graph.partitionable",
    "statement": "def simple_graph.partitionable {V : Type u} (G : simple_graph V) (n : ℕ) : Prop",
    "theorem": "{V : Type u} (G : simple_graph V) (n : ℕ) : Prop",
    "args": "{V : Type u} (G : simple_graph V) (n : ℕ)",
    "doc_string": " Whether a graph is `n`-partite, which is whether its vertex set can be partitioned in at most `n` independent sets.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "computability.decode_nat",
    "statement": "def computability.decode_nat  : list bool → ℕ",
    "theorem": " : list bool → ℕ",
    "args": "",
    "doc_string": "A decoding function from `list bool` to ℕ.",
    "kind": "def",
    "type": "list bool → ℕ"
  },
  {
    "name": "nzsnum.not",
    "statement": "def nzsnum.not  : nzsnum → nzsnum",
    "theorem": " : nzsnum → nzsnum",
    "args": "",
    "doc_string": "Bitwise `not` for `nzsnum`.",
    "kind": "def",
    "type": "nzsnum → nzsnum"
  },
  {
    "name": "polynomial.chebyshev.T",
    "statement": "def polynomial.chebyshev.T (R : Type u_1) [comm_ring R] : ℕ → polynomial R",
    "theorem": "(R : Type u_1) [comm_ring R] : ℕ → polynomial R",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": "`T n` is the `n`-th Chebyshev polynomial of the first kind",
    "kind": "def",
    "type": "ℕ → polynomial R"
  },
  {
    "name": "submodules_ring_basis",
    "statement": "structure submodules_ring_basis {ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] (B : ι → submodule R A) : Prop",
    "theorem": "{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] (B : ι → submodule R A) : Prop",
    "args": "{ι : Type u_1} {R : Type u_2} {A : Type u_3} [comm_ring R] [comm_ring A] [algebra R A] (B : ι → submodule R A)",
    "doc_string": " A family of submodules in a commutative `R`-algebra `A` is a submodules basis if it satisfies some axioms ensuring there is a topology on `A` which is compatible with the ring structure and admits this family as a basis of neighborhoods of zero.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_add_submonoid.Inter",
    "statement": "theorem is_add_submonoid.Inter {M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)",
    "theorem": "{M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)",
    "args": "{M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y))",
    "doc_string": "The intersection of an indexed set of `add_submonoid`s of an `add_monoid` `M` is an `add_submonoid` of `M`.",
    "kind": "theorem",
    "type": "is_add_submonoid (set.Inter s)"
  },
  {
    "name": "list.is_suffix_of",
    "statement": "def list.is_suffix_of {α : Type u} [decidable_eq α] (l₁ l₂ : list α) : bool",
    "theorem": "{α : Type u} [decidable_eq α] (l₁ l₂ : list α) : bool",
    "args": "{α : Type u} [decidable_eq α] (l₁ l₂ : list α)",
    "doc_string": "`is_suffix_of l₁ l₂` returns `tt` iff `l₁` is a suffix of `l₂`.",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "pprod",
    "statement": "structure pprod (α : Sort u) (β : Sort v) : Sort (max 1 u v)",
    "theorem": "(α : Sort u) (β : Sort v) : Sort (max 1 u v)",
    "args": "(α : Sort u) (β : Sort v)",
    "doc_string": "Similar to `prod`, but α and β can be propositions.   We use this type internally to automatically generate the brec_on recursor.",
    "kind": "structure",
    "type": "Sort (max 1 u v)"
  },
  {
    "name": "category_theory.limits.has_finite_wide_pushouts",
    "statement": "structure category_theory.limits.has_finite_wide_pushouts (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_finite_wide_pushouts` represents a choice of wide pushout for every finite collection of morphisms",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "has_continuous_const_vadd",
    "statement": "structure has_continuous_const_vadd (Γ : Type u_1) (T : Type u_2) [topological_space T] [has_vadd Γ T] : Prop",
    "theorem": "(Γ : Type u_1) (T : Type u_2) [topological_space T] [has_vadd Γ T] : Prop",
    "args": "(Γ : Type u_1) (T : Type u_2) [topological_space T] [has_vadd Γ T]",
    "doc_string": " Class `has_continuous_const_vadd Γ T` says that the additive action `(+ᵥ) : Γ → T → T` is continuous in the second argument. We use the same class for all kinds of additive actions, including (semi)modules and algebras.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "pSet.image",
    "statement": "def pSet.image (f : pSet → pSet) : pSet → pSet",
    "theorem": "(f : pSet → pSet) : pSet → pSet",
    "args": "(f : pSet → pSet)",
    "doc_string": "The image of a function from pre-sets to pre-sets.",
    "kind": "def",
    "type": "pSet → pSet"
  },
  {
    "name": "complete_lattice.independent.comp",
    "statement": "theorem complete_lattice.independent.comp {ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f) : complete_lattice.independent (s ∘ f)",
    "theorem": "{ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f) : complete_lattice.independent (s ∘ f)",
    "args": "{ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f)",
    "doc_string": " Composing an independent indexed family with an injective function on the index results in another indepedendent indexed family.",
    "kind": "theorem",
    "type": "complete_lattice.independent (s ∘ f)"
  },
  {
    "name": "separation_rel",
    "statement": "def separation_rel (α : Type u) [u : uniform_space α] : set (α × α)",
    "theorem": "(α : Type u) [u : uniform_space α] : set (α × α)",
    "args": "(α : Type u) [u : uniform_space α]",
    "doc_string": "The separation relation is the intersection of all entourages.  Two points which are related by the separation relation are \"indistinguishable\"  according to the uniform structure.",
    "kind": "def",
    "type": "set (α × α)"
  },
  {
    "name": "exp",
    "statement": "def exp (𝕂 : Type u_1) {𝔸 : Type u_2} [field 𝕂] [ring 𝔸] [algebra 𝕂 𝔸] [topological_space 𝔸] [topological_ring 𝔸] (x : 𝔸) : 𝔸",
    "theorem": "(𝕂 : Type u_1) {𝔸 : Type u_2} [field 𝕂] [ring 𝔸] [algebra 𝕂 𝔸] [topological_space 𝔸] [topological_ring 𝔸] (x : 𝔸) : 𝔸",
    "args": "(𝕂 : Type u_1) {𝔸 : Type u_2} [field 𝕂] [ring 𝔸] [algebra 𝕂 𝔸] [topological_space 𝔸] [topological_ring 𝔸] (x : 𝔸)",
    "doc_string": " `exp 𝕂 : 𝔸 → 𝔸` is the exponential map determined by the action of `𝕂` on `𝔸`. It is defined as the sum of the `formal_multilinear_series` `exp_series 𝕂 𝔸`.  Note that when `𝔸 = matrix n n 𝕂`, this is the **Matrix Exponential**; see [`analysis.normed_space.matrix_exponential`](../matrix_exponential) for lemmas specific to that case.",
    "kind": "def",
    "type": "𝔸"
  },
  {
    "name": "category_theory.core",
    "statement": "def category_theory.core (C : Type u₁) : Type u₁",
    "theorem": "(C : Type u₁) : Type u₁",
    "args": "(C : Type u₁)",
    "doc_string": " The core of a category C is the groupoid whose morphisms are all the isomorphisms of C.",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "int.greatest_of_bdd",
    "statement": "def int.greatest_of_bdd {P : ℤ → Prop} [decidable_pred P] (b : ℤ) (Hb : ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : {ub // P ub ∧ ∀ (z : ℤ), P z → z ≤ ub}",
    "theorem": "{P : ℤ → Prop} [decidable_pred P] (b : ℤ) (Hb : ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : {ub // P ub ∧ ∀ (z : ℤ), P z → z ≤ ub}",
    "args": "{P : ℤ → Prop} [decidable_pred P] (b : ℤ) (Hb : ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z)",
    "doc_string": " A computable version of `exists_greatest_of_bdd`: given a decidable predicate on the integers, with an explicit upper bound and a proof that it is somewhere true, return the greatest value for which the predicate is true.",
    "kind": "def",
    "type": "{ub // P ub ∧ ∀ (z : ℤ), P z → z ≤ ub}"
  },
  {
    "name": "subsemiring_class",
    "statement": "structure subsemiring_class (S : Type u_1) (R : out_param (Type u)) [non_assoc_semiring R] [set_like S R] : Type",
    "theorem": "(S : Type u_1) (R : out_param (Type u)) [non_assoc_semiring R] [set_like S R] : Type",
    "args": "(S : Type u_1) (R : out_param (Type u)) [non_assoc_semiring R] [set_like S R]",
    "doc_string": " `subsemiring_class S R` states that `S` is a type of subsets `s ⊆ R` that are both a multiplicative and an additive submonoid.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "cardinal.ord_card_unbounded",
    "statement": "theorem cardinal.ord_card_unbounded  : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}",
    "theorem": " : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}",
    "args": "",
    "doc_string": "Ordinals that are cardinals are unbounded.",
    "kind": "theorem",
    "type": "set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}"
  },
  {
    "name": "ordinal.deriv_family",
    "statement": "def ordinal.deriv_family {ι : Type u} (f : ι → ordinal → ordinal) (o : ordinal) : ordinal",
    "theorem": "{ι : Type u} (f : ι → ordinal → ordinal) (o : ordinal) : ordinal",
    "args": "{ι : Type u} (f : ι → ordinal → ordinal) (o : ordinal)",
    "doc_string": "The derivative of a family of normal functions is the sequence of their common fixed points.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "pos_num.shiftr",
    "statement": "def pos_num.shiftr  : pos_num → ℕ → num",
    "theorem": " : pos_num → ℕ → num",
    "args": "",
    "doc_string": "Right-shift the binary representation of a `pos_num`.",
    "kind": "def",
    "type": "pos_num → ℕ → num"
  },
  {
    "name": "add_monoid_algebra",
    "statement": "def add_monoid_algebra (k : Type u₁) (G : Type u₂) [semiring k] : Type (max u₂ u₁)",
    "theorem": "(k : Type u₁) (G : Type u₂) [semiring k] : Type (max u₂ u₁)",
    "args": "(k : Type u₁) (G : Type u₂) [semiring k]",
    "doc_string": "The monoid algebra over a semiring `k` generated by the additive monoid `G`. It is the type of finite formal `k`-linear combinations of terms of `G`, endowed with the convolution product.",
    "kind": "def",
    "type": "Type (max u₂ u₁)"
  },
  {
    "name": "semiquot.of_trunc",
    "statement": "def semiquot.of_trunc {α : Type u_1} (q : trunc α) : semiquot α",
    "theorem": "{α : Type u_1} (q : trunc α) : semiquot α",
    "args": "{α : Type u_1} (q : trunc α)",
    "doc_string": "Convert a `trunc α` to a `semiquot α`.",
    "kind": "def",
    "type": "semiquot α"
  },
  {
    "name": "pos_num.of_znum",
    "statement": "def pos_num.of_znum  : znum → pos_num",
    "theorem": " : znum → pos_num",
    "args": "",
    "doc_string": "Converts a `znum` to a `pos_num`, mapping all out of range values to `1`.",
    "kind": "def",
    "type": "znum → pos_num"
  },
  {
    "name": "erased.join",
    "statement": "def erased.join {α : Sort u_1} (a : erased (erased α)) : erased α",
    "theorem": "{α : Sort u_1} (a : erased (erased α)) : erased α",
    "args": "{α : Sort u_1} (a : erased (erased α))",
    "doc_string": "Collapses two levels of erasure.",
    "kind": "def",
    "type": "erased α"
  },
  {
    "name": "right.inv_lt_one_iff",
    "statement": "theorem right.inv_lt_one_iff {α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "kind": "theorem",
    "type": "a⁻¹ < 1 ↔ 1 < a"
  },
  {
    "name": "subtype.is_empty",
    "statement": "def subtype.is_empty {α : Sort u_1} [is_empty α] (p : α → Prop) : is_empty (subtype p)",
    "theorem": "{α : Sort u_1} [is_empty α] (p : α → Prop) : is_empty (subtype p)",
    "args": "{α : Sort u_1} [is_empty α] (p : α → Prop)",
    "doc_string": "subtypes of an empty type are empty",
    "kind": "def",
    "type": "is_empty (subtype p)"
  },
  {
    "name": "dense_closure",
    "statement": "theorem dense_closure {α : Type u} [topological_space α] {s : set α} : dense (closure s) ↔ dense s",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : dense (closure s) ↔ dense s",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "The closure of a set `s` is dense if and only if `s` is dense.",
    "kind": "theorem",
    "type": "dense (closure s) ↔ dense s"
  },
  {
    "name": "cancel_monoid_with_zero",
    "statement": "structure cancel_monoid_with_zero (M₀ : Type u_4) : Type u_4",
    "theorem": "(M₀ : Type u_4) : Type u_4",
    "args": "(M₀ : Type u_4)",
    "doc_string": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left and right absorbing, and left/right multiplication by a non-zero element is injective.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "lists.of_list",
    "statement": "def lists.of_list {α : Type u_1} (l : list (lists α)) : lists α",
    "theorem": "{α : Type u_1} (l : list (lists α)) : lists α",
    "args": "{α : Type u_1} (l : list (lists α))",
    "doc_string": "Converts a `list` of ZFA lists to a ZFA list.",
    "kind": "def",
    "type": "lists α"
  },
  {
    "name": "enorm.emetric_space",
    "statement": "def enorm.emetric_space {𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] (e : enorm 𝕜 V) : emetric_space V",
    "theorem": "{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] (e : enorm 𝕜 V) : emetric_space V",
    "args": "{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] (e : enorm 𝕜 V)",
    "doc_string": "Structure of an `emetric_space` defined by an extended norm.",
    "kind": "def",
    "type": "emetric_space V"
  },
  {
    "name": "is_order_connected",
    "statement": "structure is_order_connected (α : Type u) (lt : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (lt : α → α → Prop) : Prop",
    "args": "(α : Type u) (lt : α → α → Prop)",
    "doc_string": "A connected order is one satisfying the condition `a < c → a < b ∨ b < c`.  This is recognizable as an intuitionistic substitute for `a ≤ b ∨ b ≤ a` on  the constructive reals, and is also known as negative transitivity,  since the contrapositive asserts transitivity of the relation `¬ a < b`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "io.random",
    "statement": "def io.random {α : Type} [random α] : io α",
    "theorem": "{α : Type} [random α] : io α",
    "args": "{α : Type} [random α]",
    "doc_string": "randomly generate a value of type α",
    "kind": "def",
    "type": "io α"
  },
  {
    "name": "list.count",
    "statement": "def list.count {α : Type u_1} [decidable_eq α] (a : α) : list α → ℕ",
    "theorem": "{α : Type u_1} [decidable_eq α] (a : α) : list α → ℕ",
    "args": "{α : Type u_1} [decidable_eq α] (a : α)",
    "doc_string": "`count a l` is the number of occurrences of `a` in `l`.",
    "kind": "def",
    "type": "list α → ℕ"
  },
  {
    "name": "division_ring.to_group_with_zero",
    "statement": "def division_ring.to_group_with_zero {K : Type u} [division_ring K] : group_with_zero K",
    "theorem": "{K : Type u} [division_ring K] : group_with_zero K",
    "args": "{K : Type u} [division_ring K]",
    "doc_string": "Every division ring is a `group_with_zero`.",
    "kind": "def",
    "type": "group_with_zero K"
  },
  {
    "name": "is_regular",
    "statement": "structure is_regular {R : Type u_1} [has_mul R] (c : R) : Prop",
    "theorem": "{R : Type u_1} [has_mul R] (c : R) : Prop",
    "args": "{R : Type u_1} [has_mul R] (c : R)",
    "doc_string": " A regular element is an element `c` such that multiplication by `c` both on the left and on the right is injective.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "neg_pos_of_neg",
    "statement": "theorem neg_pos_of_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : a < 0 → 0 < -a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : a < 0 → 0 < -a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the reverse direction of left.one_lt_inv_iff`.",
    "kind": "theorem",
    "type": "a < 0 → 0 < -a"
  },
  {
    "name": "id.mk",
    "statement": "def id.mk {α : Sort u} : α → id α",
    "theorem": "{α : Sort u} : α → id α",
    "args": "{α : Sort u}",
    "doc_string": " Introduce the `id` functor. Incidentally, this is `pure` for `id` as a `monad` and as an `applicative` functor.",
    "kind": "def",
    "type": "α → id α"
  },
  {
    "name": "category_theory.limits.has_zero_object",
    "statement": "structure category_theory.limits.has_zero_object (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category \"has a zero object\" if it has an object which is both initial and terminal.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "zmod.legendre_sym_eq_one_iff",
    "statement": "theorem zmod.legendre_sym_eq_one_iff (p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a",
    "theorem": "(p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a",
    "args": "(p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0)",
    "doc_string": "When `p ∤ a`, then `legendre_sym p a = 1` iff `a` is a square mod `p`.",
    "kind": "theorem",
    "type": "zmod.legendre_sym p a = 1 ↔ is_square ↑a"
  },
  {
    "name": "continuous_iff_seq_continuous",
    "statement": "theorem continuous_iff_seq_continuous {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f",
    "theorem": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f",
    "args": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X]",
    "doc_string": "In a sequential space, continuity and sequential continuity coincide.",
    "kind": "theorem",
    "type": "continuous f ↔ seq_continuous f"
  },
  {
    "name": "eq.trans_le",
    "statement": "theorem eq.trans_le {α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c) : a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c) : a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c)",
    "doc_string": "**Alias** of le_of_eq_of_le`.",
    "kind": "theorem",
    "type": "a ≤ c"
  },
  {
    "name": "weak_dual",
    "statement": "def weak_dual (𝕜 : Type u_1) (E : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Type (max u_2 u_1)",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Type (max u_2 u_1)",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E]",
    "doc_string": " The weak star topology is the topology coarsest topology on `E →L[𝕜] 𝕜` such that all functionals `λ v, top_dual_pairing 𝕜 E v x` are continuous.",
    "kind": "def",
    "type": "Type (max u_2 u_1)"
  },
  {
    "name": "clifford_algebra_ring.clifford_algebra.comm_ring",
    "statement": "def clifford_algebra_ring.clifford_algebra.comm_ring {R : Type u_1} [comm_ring R] : comm_ring (clifford_algebra 0)",
    "theorem": "{R : Type u_1} [comm_ring R] : comm_ring (clifford_algebra 0)",
    "args": "{R : Type u_1} [comm_ring R]",
    "doc_string": "Since the vector space is empty the ring is commutative.",
    "kind": "def",
    "type": "comm_ring (clifford_algebra 0)"
  },
  {
    "name": "measure_theory.measure.join",
    "statement": "def measure_theory.measure.join {α : Type u_1} [measurable_space α] (m : measure_theory.measure (measure_theory.measure α)) : measure_theory.measure α",
    "theorem": "{α : Type u_1} [measurable_space α] (m : measure_theory.measure (measure_theory.measure α)) : measure_theory.measure α",
    "args": "{α : Type u_1} [measurable_space α] (m : measure_theory.measure (measure_theory.measure α))",
    "doc_string": " Monadic join on `measure` in the category of measurable spaces and measurable functions.",
    "kind": "def",
    "type": "measure_theory.measure α"
  },
  {
    "name": "wseq.head",
    "statement": "def wseq.head {α : Type u} (s : wseq α) : computation (option α)",
    "theorem": "{α : Type u} (s : wseq α) : computation (option α)",
    "args": "{α : Type u} (s : wseq α)",
    "doc_string": "Get the head of a weak sequence. This involves a possibly  infinite computation.",
    "kind": "def",
    "type": "computation (option α)"
  },
  {
    "name": "set.seq",
    "statement": "def set.seq {α : Type u_1} {β : Type u_2} (s : set (α → β)) (t : set α) : set β",
    "theorem": "{α : Type u_1} {β : Type u_2} (s : set (α → β)) (t : set α) : set β",
    "args": "{α : Type u_1} {β : Type u_2} (s : set (α → β)) (t : set α)",
    "doc_string": " Given a set `s` of functions `α → β` and `t : set α`, `seq s t` is the union of `f '' t` over all `f ∈ s`.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "bounded_continuous_map_class",
    "statement": "structure bounded_continuous_map_class (F : Type u_2) (α : Type u_3) (β : Type u_4) [topological_space α] [pseudo_metric_space β] : Type (max u_2 u_3 u_4)",
    "theorem": "(F : Type u_2) (α : Type u_3) (β : Type u_4) [topological_space α] [pseudo_metric_space β] : Type (max u_2 u_3 u_4)",
    "args": "(F : Type u_2) (α : Type u_3) (β : Type u_4) [topological_space α] [pseudo_metric_space β]",
    "doc_string": " `bounded_continuous_map_class F α β` states that `F` is a type of bounded continuous maps.  You should also extend this typeclass when you extend `bounded_continuous_function`.",
    "kind": "structure",
    "type": "Type (max u_2 u_3 u_4)"
  },
  {
    "name": "regular_expression.matches",
    "statement": "def regular_expression.matches {α : Type u_1} : regular_expression α → language α",
    "theorem": "{α : Type u_1} : regular_expression α → language α",
    "args": "{α : Type u_1}",
    "doc_string": "`matches P` provides a language which contains all strings that `P` matches",
    "kind": "def",
    "type": "regular_expression α → language α"
  },
  {
    "name": "subsemiring.complete_lattice",
    "statement": "def subsemiring.complete_lattice {R : Type u} [non_assoc_semiring R] : complete_lattice (subsemiring R)",
    "theorem": "{R : Type u} [non_assoc_semiring R] : complete_lattice (subsemiring R)",
    "args": "{R : Type u} [non_assoc_semiring R]",
    "doc_string": "Subsemirings of a semiring form a complete lattice.",
    "kind": "def",
    "type": "complete_lattice (subsemiring R)"
  },
  {
    "name": "lie_algebra.lie_character",
    "statement": "def lie_algebra.lie_character (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max v u)",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type (max v u)",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": "A character of a Lie algebra is a morphism to the scalars.",
    "kind": "def",
    "type": "Type (max v u)"
  },
  {
    "name": "filter.is_measurably_generated",
    "statement": "structure filter.is_measurably_generated {α : Type u_1} [measurable_space α] (f : filter α) : Prop",
    "theorem": "{α : Type u_1} [measurable_space α] (f : filter α) : Prop",
    "args": "{α : Type u_1} [measurable_space α] (f : filter α)",
    "doc_string": "A filter `f` is measurably generates if each `s ∈ f` includes a measurable `t ∈ f`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nonneg.conditionally_complete_linear_order",
    "statement": "def nonneg.conditionally_complete_linear_order {α : Type u_1} [conditionally_complete_linear_order α] {a : α} : conditionally_complete_linear_order {x // a ≤ x}",
    "theorem": "{α : Type u_1} [conditionally_complete_linear_order α] {a : α} : conditionally_complete_linear_order {x // a ≤ x}",
    "args": "{α : Type u_1} [conditionally_complete_linear_order α] {a : α}",
    "doc_string": "If `Sup ∅ ≤ a` then `{x : α // a ≤ x}` is a `conditionally_complete_linear_order`.",
    "kind": "def",
    "type": "conditionally_complete_linear_order {x // a ≤ x}"
  },
  {
    "name": "prod.Bipointed",
    "statement": "def prod.Bipointed {X : Type u_1} (to_prod : X × X) : Bipointed",
    "theorem": "{X : Type u_1} (to_prod : X × X) : Bipointed",
    "args": "{X : Type u_1} (to_prod : X × X)",
    "doc_string": "**Alias** of Bipointed.of`.",
    "kind": "def",
    "type": "Bipointed"
  },
  {
    "name": "nat.partrec.code",
    "statement": "inductive nat.partrec.code  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Code for partial recursive functions from ℕ to ℕ. See `nat.partrec.code.eval` for the interpretation of these constructors.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "structure_groupoid.maximal_atlas",
    "statement": "def structure_groupoid.maximal_atlas {H : Type u} (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) : set (local_homeomorph M H)",
    "theorem": "{H : Type u} (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H) : set (local_homeomorph M H)",
    "args": "{H : Type u} (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] (G : structure_groupoid H)",
    "doc_string": " Given a charted space admitting a structure groupoid, the maximal atlas associated to this structure groupoid is the set of all local charts that are compatible with the atlas, i.e., such that changing coordinates with an atlas member gives an element of the groupoid.",
    "kind": "def",
    "type": "set (local_homeomorph M H)"
  },
  {
    "name": "module.ray.some_vector",
    "statement": "def module.ray.some_vector {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : M",
    "theorem": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : M",
    "args": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M)",
    "doc_string": "An arbitrary nonzero vector giving a ray.",
    "kind": "def",
    "type": "M"
  },
  {
    "name": "order_hom_class.to_lattice_hom_class",
    "statement": "def order_hom_class.to_lattice_hom_class {F : Type u_1} (α : Type u_3) (β : Type u_4) [linear_order α] [lattice β] [order_hom_class F α β] : lattice_hom_class F α β",
    "theorem": "{F : Type u_1} (α : Type u_3) (β : Type u_4) [linear_order α] [lattice β] [order_hom_class F α β] : lattice_hom_class F α β",
    "args": "{F : Type u_1} (α : Type u_3) (β : Type u_4) [linear_order α] [lattice β] [order_hom_class F α β]",
    "doc_string": "An order homomorphism from a linear order is a lattice homomorphism.",
    "kind": "def",
    "type": "lattice_hom_class F α β"
  },
  {
    "name": "continuous_add_monoid_hom.neg",
    "statement": "def continuous_add_monoid_hom.neg (E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom E E",
    "theorem": "(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E] : continuous_add_monoid_hom E E",
    "args": "(E : Type u_8) [add_comm_group E] [topological_space E] [topological_add_group E]",
    "doc_string": "The continuous homomorphism given by negation.",
    "kind": "def",
    "type": "continuous_add_monoid_hom E E"
  },
  {
    "name": "equiv.const_vadd",
    "statement": "def equiv.const_vadd {G : Type u_1} (P : Type u_2) [add_group G] [add_torsor G P] (v : G) : equiv.perm P",
    "theorem": "{G : Type u_1} (P : Type u_2) [add_group G] [add_torsor G P] (v : G) : equiv.perm P",
    "args": "{G : Type u_1} (P : Type u_2) [add_group G] [add_torsor G P] (v : G)",
    "doc_string": "The permutation given by `p ↦ v +ᵥ p`.",
    "kind": "def",
    "type": "equiv.perm P"
  },
  {
    "name": "int.le_induction",
    "statement": "theorem int.le_induction {P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n",
    "theorem": "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n",
    "args": "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ)",
    "doc_string": "See `int.induction_on'` for an induction in both directions.",
    "kind": "theorem",
    "type": "m ≤ n → P n"
  },
  {
    "name": "add_cancel_monoid",
    "statement": "structure add_cancel_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": " An additive monoid in which addition is cancellative on both sides. Main examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero is useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "is_group_hom",
    "statement": "structure is_group_hom {α : Type u} {β : Type v} [group α] [group β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [group α] [group β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [group α] [group β] (f : α → β)",
    "doc_string": "Predicate for group homomorphisms (deprecated -- use bundled `monoid_hom`).",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "composition_series.append",
    "statement": "def composition_series.append {X : Type u} [lattice X] [jordan_holder_lattice X] (s₁ s₂ : composition_series X) (h : s₁.top = s₂.bot) : composition_series X",
    "theorem": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s₁ s₂ : composition_series X) (h : s₁.top = s₂.bot) : composition_series X",
    "args": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s₁ s₂ : composition_series X) (h : s₁.top = s₂.bot)",
    "doc_string": " Append two composition series `s₁` and `s₂` such that the least element of `s₁` is the maximum element of `s₂`.",
    "kind": "def",
    "type": "composition_series X"
  },
  {
    "name": "tactic.nth_rewrite.cfg",
    "statement": "structure tactic.nth_rewrite.cfg  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration options for nth_rewrite.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "add_submonoid.to_add_subsemigroup",
    "statement": "def add_submonoid.to_add_subsemigroup {M : Type u_4} [add_zero_class M] (self : add_submonoid M) : add_subsemigroup M",
    "theorem": "{M : Type u_4} [add_zero_class M] (self : add_submonoid M) : add_subsemigroup M",
    "args": "{M : Type u_4} [add_zero_class M] (self : add_submonoid M)",
    "doc_string": " An additive submonoid of an additive monoid `M` can be considered as an additive subsemigroup of that additive monoid.",
    "kind": "def",
    "type": "add_subsemigroup M"
  },
  {
    "name": "locally_constant.char_fn",
    "statement": "def locally_constant.char_fn {X : Type u_1} (Y : Type u_2) [topological_space X] [mul_zero_one_class Y] {U : set X} (hU : is_clopen U) : locally_constant X Y",
    "theorem": "{X : Type u_1} (Y : Type u_2) [topological_space X] [mul_zero_one_class Y] {U : set X} (hU : is_clopen U) : locally_constant X Y",
    "args": "{X : Type u_1} (Y : Type u_2) [topological_space X] [mul_zero_one_class Y] {U : set X} (hU : is_clopen U)",
    "doc_string": "Characteristic functions are locally constant functions taking `x : X` to `1` if `x ∈ U`,  where `U` is a clopen set, and `0` otherwise.",
    "kind": "def",
    "type": "locally_constant X Y"
  },
  {
    "name": "pgame.right_wins",
    "statement": "def pgame.right_wins (G : pgame) : Prop",
    "theorem": "(G : pgame) : Prop",
    "args": "(G : pgame)",
    "doc_string": "The right player can always win",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_smul_regular.not_zero_iff",
    "statement": "theorem is_smul_regular.not_zero_iff {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : ¬is_smul_regular M 0 ↔ nontrivial M",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : ¬is_smul_regular M 0 ↔ nontrivial M",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M]",
    "doc_string": "The `0` element is not `M`-regular, on a non-trivial module.",
    "kind": "theorem",
    "type": "¬is_smul_regular M 0 ↔ nontrivial M"
  },
  {
    "name": "composition.boundaries",
    "statement": "def composition.boundaries {n : ℕ} (c : composition n) : finset (fin (n + 1))",
    "theorem": "{n : ℕ} (c : composition n) : finset (fin (n + 1))",
    "args": "{n : ℕ} (c : composition n)",
    "doc_string": " The boundaries of a composition, i.e., the leftmost point of all the blocks. We include a virtual point at the right of the last block, to make for a nice equiv with `composition_as_set n`.",
    "kind": "def",
    "type": "finset (fin (n + 1))"
  },
  {
    "name": "category_theory.uniform_prod",
    "statement": "def category_theory.uniform_prod (C : Type u₁) [category_theory.category C] (D : Type u₁) [category_theory.category D] : category_theory.category (C × D)",
    "theorem": "(C : Type u₁) [category_theory.category C] (D : Type u₁) [category_theory.category D] : category_theory.category (C × D)",
    "args": "(C : Type u₁) [category_theory.category C] (D : Type u₁) [category_theory.category D]",
    "doc_string": "`prod.category.uniform C D` is an additional instance specialised so both factors have the same universe levels. This helps typeclass resolution.",
    "kind": "def",
    "type": "category_theory.category (C × D)"
  },
  {
    "name": "esakia_hom_class",
    "statement": "structure esakia_hom_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [preorder α] [topological_space β] [preorder β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [preorder α] [topological_space β] [preorder β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [preorder α] [topological_space β] [preorder β]",
    "doc_string": " `esakia_hom_class F α β` states that `F` is a type of lattice morphisms.  You should extend this class when you extend `esakia_hom`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "multiset.powerset_len",
    "statement": "def multiset.powerset_len {α : Type u_1} (n : ℕ) (s : multiset α) : multiset (multiset α)",
    "theorem": "{α : Type u_1} (n : ℕ) (s : multiset α) : multiset (multiset α)",
    "args": "{α : Type u_1} (n : ℕ) (s : multiset α)",
    "doc_string": "`powerset_len n s` is the multiset of all submultisets of `s` of length `n`.",
    "kind": "def",
    "type": "multiset (multiset α)"
  },
  {
    "name": "totally_disconnected_space_iff_connected_component_singleton",
    "statement": "theorem totally_disconnected_space_iff_connected_component_singleton {α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}",
    "theorem": "{α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}",
    "args": "{α : Type u} [topological_space α]",
    "doc_string": "A space is totally disconnected iff its connected components are singletons.",
    "kind": "theorem",
    "type": "totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}"
  },
  {
    "name": "dlist.to_list",
    "statement": "def dlist.to_list {α : Type u} : dlist α → list α",
    "theorem": "{α : Type u} : dlist α → list α",
    "args": "{α : Type u}",
    "doc_string": "Convert a dlist to a list",
    "kind": "def",
    "type": "dlist α → list α"
  },
  {
    "name": "ordnode.node4_r",
    "statement": "def ordnode.node4_r {α : Type u_1} : ordnode α → α → ordnode α → α → ordnode α → ordnode α",
    "theorem": "{α : Type u_1} : ordnode α → α → ordnode α → α → ordnode α → ordnode α",
    "args": "{α : Type u_1}",
    "doc_string": "Build a tree from three nodes, with `a () b -> a (() b)` and `a (b c) d -> ((a b) (c d))`.",
    "kind": "def",
    "type": "ordnode α → α → ordnode α → α → ordnode α → ordnode α"
  },
  {
    "name": "pregroupoid.groupoid",
    "statement": "def pregroupoid.groupoid {H : Type u} [topological_space H] (PG : pregroupoid H) : structure_groupoid H",
    "theorem": "{H : Type u} [topological_space H] (PG : pregroupoid H) : structure_groupoid H",
    "args": "{H : Type u} [topological_space H] (PG : pregroupoid H)",
    "doc_string": " Construct a groupoid of local homeos for which the map and its inverse have some property, from a pregroupoid asserting that this property is stable under composition.",
    "kind": "def",
    "type": "structure_groupoid H"
  },
  {
    "name": "is_seq_closed",
    "statement": "def is_seq_closed {X : Type u_1} [topological_space X] (s : set X) : Prop",
    "theorem": "{X : Type u_1} [topological_space X] (s : set X) : Prop",
    "args": "{X : Type u_1} [topological_space X] (s : set X)",
    "doc_string": " A set `s` is sequentially closed if for any converging sequence `x n` of elements of `s`, the limit belongs to `s` as well.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "tactic.eliminate.generalization_mode",
    "statement": "inductive tactic.eliminate.generalization_mode  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A value of `generalization_mode` describes the behaviour of the auto-generalisation functionality:  - `generalize_all_except hs` means that the `hs` remain fixed and all other   hypotheses are generalised. However, there are three exceptions:    * Hypotheses depending on any `h` in `hs` also remain fixed. If we were to     generalise them, we would have to generalise `h` as well.   * Hypotheses which do not occur in the target and which do not mention the     major premise or its dependencies are never generalised. Generalising them     would not lead to a more general induction hypothesis.   * Local definitions (hypotheses of the form `h : T := t`) and their     dependencies are not generalised. This is due to limitations of the     implementation; local definitions could in principle be generalised.  - `generalize_only hs` means that only the `hs` are generalised. Exception:   hypotheses which depend on the major premise are generalised even if they do   not appear in `hs`.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "is_add_group_hom.map_zero",
    "statement": "theorem is_add_group_hom.map_zero {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f)",
    "doc_string": "An additive group homomorphism sends 0 to 0.",
    "kind": "theorem",
    "type": "f 0 = 0"
  },
  {
    "name": "seq1.map",
    "statement": "def seq1.map {α : Type u} {β : Type v} (f : α → β) : seq1 α → seq1 β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : seq1 α → seq1 β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": "Map a function on a `seq1`",
    "kind": "def",
    "type": "seq1 α → seq1 β"
  },
  {
    "name": "is_dedekind_domain_inv",
    "statement": "def is_dedekind_domain_inv (A : Type u_2) [comm_ring A] [is_domain A] : Prop",
    "theorem": "(A : Type u_2) [comm_ring A] [is_domain A] : Prop",
    "args": "(A : Type u_2) [comm_ring A] [is_domain A]",
    "doc_string": "A Dedekind domain is an integral domain such that every fractional ideal has an inverse.  This is equivalent to `is_dedekind_domain`. In particular we provide a `fractional_ideal.comm_group_with_zero` instance, assuming `is_dedekind_domain A`, which implies `is_dedekind_domain_inv`. For **integral** ideals, `is_dedekind_domain`(`_inv`) implies only `ideal.cancel_comm_monoid_with_zero`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_locally_homeomorph",
    "statement": "def is_locally_homeomorph {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y) : Prop",
    "theorem": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y) : Prop",
    "args": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y)",
    "doc_string": "A function `f : X → Y` satisfies `is_locally_homeomorph` if each `x : x` is contained in  the source of some `e : local_homeomorph X Y` with `f = e`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nonneg.to_nonneg",
    "statement": "def nonneg.to_nonneg {α : Type u_1} [has_zero α] [linear_order α] (a : α) : {x // 0 ≤ x}",
    "theorem": "{α : Type u_1} [has_zero α] [linear_order α] (a : α) : {x // 0 ≤ x}",
    "args": "{α : Type u_1} [has_zero α] [linear_order α] (a : α)",
    "doc_string": "The function `a ↦ max a 0` of type `α → {x : α // 0 ≤ x}`.",
    "kind": "def",
    "type": "{x // 0 ≤ x}"
  },
  {
    "name": "fintype.of_subsingleton",
    "statement": "def fintype.of_subsingleton {α : Type u_1} (a : α) [subsingleton α] : fintype α",
    "theorem": "{α : Type u_1} (a : α) [subsingleton α] : fintype α",
    "args": "{α : Type u_1} (a : α) [subsingleton α]",
    "doc_string": "Any subsingleton type with a witness is a fintype (with one term).",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "emetric.diam_mono",
    "statement": "theorem emetric.diam_mono {α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t) : emetric.diam s ≤ emetric.diam t",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t) : emetric.diam s ≤ emetric.diam t",
    "args": "{α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t)",
    "doc_string": "The diameter is monotonous with respect to inclusion",
    "kind": "theorem",
    "type": "emetric.diam s ≤ emetric.diam t"
  },
  {
    "name": "frame_hom.id",
    "statement": "def frame_hom.id (α : Type u_2) [complete_lattice α] : frame_hom α α",
    "theorem": "(α : Type u_2) [complete_lattice α] : frame_hom α α",
    "args": "(α : Type u_2) [complete_lattice α]",
    "doc_string": "`id` as a `frame_hom`.",
    "kind": "def",
    "type": "frame_hom α α"
  },
  {
    "name": "algebra.is_algebraic_of_finite",
    "statement": "theorem algebra.is_algebraic_of_finite (K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L",
    "theorem": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L",
    "args": "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L]",
    "doc_string": "A field extension is algebraic if it is finite.",
    "kind": "theorem",
    "type": "algebra.is_algebraic K L"
  },
  {
    "name": "free_group.reduce.exact",
    "statement": "theorem free_group.reduce.exact {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂)",
    "doc_string": " If two words have a common maximal reduction, then they correspond to the same element in the free group.",
    "kind": "theorem",
    "type": "free_group.mk L₁ = free_group.mk L₂"
  },
  {
    "name": "monotone.ne_of_lt_of_lt_nat",
    "statement": "theorem monotone.ne_of_lt_of_lt_nat {α : Type u} [preorder α] {f : ℕ → α} (hf : monotone f) (n : ℕ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℕ) : f a ≠ x",
    "theorem": "{α : Type u} [preorder α] {f : ℕ → α} (hf : monotone f) (n : ℕ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℕ) : f a ≠ x",
    "args": "{α : Type u} [preorder α] {f : ℕ → α} (hf : monotone f) (n : ℕ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℕ)",
    "doc_string": "If `f` is a monotone function from `ℕ` to a preorder such that `x` lies between `f n` and  `f (n + 1)`, then `x` doesn't lie in the range of `f`.",
    "kind": "theorem",
    "type": "f a ≠ x"
  },
  {
    "name": "fintype.of_list",
    "statement": "def fintype.of_list {α : Type u_1} [decidable_eq α] (l : list α) (H : ∀ (x : α), x ∈ l) : fintype α",
    "theorem": "{α : Type u_1} [decidable_eq α] (l : list α) (H : ∀ (x : α), x ∈ l) : fintype α",
    "args": "{α : Type u_1} [decidable_eq α] (l : list α) (H : ∀ (x : α), x ∈ l)",
    "doc_string": "Construct a proof of `fintype α` from a universal list",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "ultrafilter.add_semigroup",
    "statement": "def ultrafilter.add_semigroup {M : Type u_1} [add_semigroup M] : add_semigroup (ultrafilter M)",
    "theorem": "{M : Type u_1} [add_semigroup M] : add_semigroup (ultrafilter M)",
    "args": "{M : Type u_1} [add_semigroup M]",
    "doc_string": "Additive semigroup structure on `ultrafilter M` induced by an additive semigroup structure on `M`.",
    "kind": "def",
    "type": "add_semigroup (ultrafilter M)"
  },
  {
    "name": "omega.nat.exprterm",
    "statement": "inductive omega.nat.exprterm  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The shadow syntax for arithmetic terms. All constants are reified to `cst` (e.g., `5` is reified to `cst 5`) and all other atomic terms are reified to `exp` (e.g., `5 * (list.length l)` is reified to `exp 5 \\`(list.length l)`). `exp` accepts a coefficient of type `nat` as its first argument because multiplication by constant is allowed by the omega test.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "has_strict_deriv_at_exp_zero",
    "statement": "theorem has_strict_deriv_at_exp_zero {𝕂 : Type u_1} [is_R_or_C 𝕂] : has_strict_deriv_at (exp 𝕂) 1 0",
    "theorem": "{𝕂 : Type u_1} [is_R_or_C 𝕂] : has_strict_deriv_at (exp 𝕂) 1 0",
    "args": "{𝕂 : Type u_1} [is_R_or_C 𝕂]",
    "doc_string": "The exponential map in `𝕂 = ℝ` or `𝕂 = ℂ` has strict derivative `1` at zero.",
    "kind": "theorem",
    "type": "has_strict_deriv_at (exp 𝕂) 1 0"
  },
  {
    "name": "inducing",
    "statement": "structure inducing {α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [tα : topological_space α] [tβ : topological_space β] (f : α → β)",
    "doc_string": " A function `f : α → β` between topological spaces is inducing if the topology on `α` is induced by the topology on `β` through `f`, meaning that a set `s : set α` is open iff it is the preimage under `f` of some open set `t : set β`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "simple_graph.dist",
    "statement": "def simple_graph.dist {V : Type u_1} (G : simple_graph V) (u v : V) : ℕ",
    "theorem": "{V : Type u_1} (G : simple_graph V) (u v : V) : ℕ",
    "args": "{V : Type u_1} (G : simple_graph V) (u v : V)",
    "doc_string": " The distance between two vertices is the length of the shortest walk between them. If no such walk exists, this uses the junk value of `0`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "finite_dimensional.finrank_eq_dim",
    "statement": "theorem finite_dimensional.finrank_eq_dim (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V",
    "theorem": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V",
    "args": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": " In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its `finrank`.",
    "kind": "theorem",
    "type": "↑(finite_dimensional.finrank K V) = module.rank K V"
  },
  {
    "name": "add_pos",
    "statement": "theorem add_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "**Alias** of `left.add_pos`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "setoid.comap_eq",
    "statement": "theorem setoid.comap_eq {α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β} : setoid.comap f r = setoid.ker (quotient.mk ∘ f)",
    "theorem": "{α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β} : setoid.comap f r = setoid.ker (quotient.mk ∘ f)",
    "args": "{α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β}",
    "doc_string": "Given a map `f : N → M` and an equivalence relation `r` on `β`, the equivalence relation    induced on `α` by `f` equals the kernel of `r`'s quotient map composed with `f`.",
    "kind": "theorem",
    "type": "setoid.comap f r = setoid.ker (quotient.mk ∘ f)"
  },
  {
    "name": "znum.mul",
    "statement": "def znum.mul  : znum → znum → znum",
    "theorem": " : znum → znum → znum",
    "args": "",
    "doc_string": "Multiplication of `znum`s.",
    "kind": "def",
    "type": "znum → znum → znum"
  },
  {
    "name": "category_theory.small_model",
    "statement": "def category_theory.small_model (C : Type u) [category_theory.category C] [category_theory.essentially_small C] : Type w",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.essentially_small C] : Type w",
    "args": "(C : Type u) [category_theory.category C] [category_theory.essentially_small C]",
    "doc_string": "An arbitrarily chosen small model for an essentially small category.",
    "kind": "def",
    "type": "Type w"
  },
  {
    "name": "holor_index",
    "statement": "def holor_index (ds : list ℕ) : Type",
    "theorem": "(ds : list ℕ) : Type",
    "args": "(ds : list ℕ)",
    "doc_string": " `holor_index ds` is the type of valid index tuples used to identify an entry of a holor of dimensions `ds`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "metric.uniform_continuous_inf_nndist_pt",
    "statement": "theorem metric.uniform_continuous_inf_nndist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point",
    "kind": "theorem",
    "type": "uniform_continuous (λ (x : α), metric.inf_nndist x s)"
  },
  {
    "name": "part.ωSup",
    "statement": "def part.ωSup {α : Type u} (c : omega_complete_partial_order.chain (part α)) : part α",
    "theorem": "{α : Type u} (c : omega_complete_partial_order.chain (part α)) : part α",
    "args": "{α : Type u} (c : omega_complete_partial_order.chain (part α))",
    "doc_string": "The (noncomputable) `ωSup` definition for the `ω`-CPO structure on `part α`.",
    "kind": "def",
    "type": "part α"
  },
  {
    "name": "commute.is_of_fin_order_mul",
    "statement": "theorem commute.is_of_fin_order_mul {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
    "theorem": "{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
    "args": "{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y)",
    "doc_string": "Commuting elements of finite order are closed under multiplication.",
    "kind": "theorem",
    "type": "is_of_fin_order (x * y)"
  },
  {
    "name": "nsmul_rec",
    "statement": "def nsmul_rec {M : Type u} [has_zero M] [has_add M] : ℕ → M → M",
    "theorem": "{M : Type u} [has_zero M] [has_add M] : ℕ → M → M",
    "args": "{M : Type u} [has_zero M] [has_add M]",
    "doc_string": " The fundamental scalar multiplication in an additive monoid. `nsmul_rec n a = a+a+...+a` n times. Use instead `n • a`, which has better definitional behavior.",
    "kind": "def",
    "type": "ℕ → M → M"
  },
  {
    "name": "has_quotient.quotient",
    "statement": "def has_quotient.quotient (A : out_param (Type u)) {B : Type v} [has_quotient A B] (b : B) : Type (max u v)",
    "theorem": "(A : out_param (Type u)) {B : Type v} [has_quotient A B] (b : B) : Type (max u v)",
    "args": "(A : out_param (Type u)) {B : Type v} [has_quotient A B] (b : B)",
    "doc_string": " `has_quotient.quotient A b` (with notation `A ⧸ b`) is the quotient of the type `A` by `b`.  This differs from `has_quotient.quotient'` in that the `A` argument is explicit, which is necessary to make Lean show the notation in the goal state.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "add_aut.apply_has_faithful_smul",
    "statement": "def add_aut.apply_has_faithful_smul {A : Type u_1} [add_monoid A] : has_faithful_smul (add_aut A) A",
    "theorem": "{A : Type u_1} [add_monoid A] : has_faithful_smul (add_aut A) A",
    "args": "{A : Type u_1} [add_monoid A]",
    "doc_string": "`add_aut.apply_distrib_mul_action` is faithful.",
    "kind": "def",
    "type": "has_faithful_smul (add_aut A) A"
  },
  {
    "name": "free_add_magma.traverse",
    "statement": "def free_add_magma.traverse {m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) : free_add_magma α → m (free_add_magma β)",
    "theorem": "{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) : free_add_magma α → m (free_add_magma β)",
    "args": "{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β)",
    "doc_string": "`free_add_magma` is traversable.",
    "kind": "def",
    "type": "free_add_magma α → m (free_add_magma β)"
  },
  {
    "name": "ordered_comm_semiring",
    "statement": "structure ordered_comm_semiring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " An `ordered_comm_semiring α` is a commutative semiring `α` with a partial order such that addition is monotone and multiplication by a positive number is strictly monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "rel.dom",
    "statement": "def rel.dom {α : Type u_1} {β : Type u_2} (r : rel α β) : set α",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : rel α β) : set α",
    "args": "{α : Type u_1} {β : Type u_2} (r : rel α β)",
    "doc_string": "Domain of a relation",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "function.equiv",
    "statement": "def function.equiv {α : Sort u} {β : α → Sort v} (f₁ f₂ : Π (x : α), β x) : Prop",
    "theorem": "{α : Sort u} {β : α → Sort v} (f₁ f₂ : Π (x : α), β x) : Prop",
    "args": "{α : Sort u} {β : α → Sort v} (f₁ f₂ : Π (x : α), β x)",
    "doc_string": "The relation stating that two functions are pointwise equal.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "antisymm_of",
    "statement": "theorem antisymm_of {α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → a = b",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → a = b",
    "args": "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α}",
    "doc_string": " A version of `antisymm` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there.",
    "kind": "theorem",
    "type": "r a b → r b a → a = b"
  },
  {
    "name": "multiset.attach",
    "statement": "def multiset.attach {α : Type u_1} (s : multiset α) : multiset {x // x ∈ s}",
    "theorem": "{α : Type u_1} (s : multiset α) : multiset {x // x ∈ s}",
    "args": "{α : Type u_1} (s : multiset α)",
    "doc_string": "\"Attach\" a proof that `a ∈ s` to each element `a` in `s` to produce  a multiset on `{x // x ∈ s}`.",
    "kind": "def",
    "type": "multiset {x // x ∈ s}"
  },
  {
    "name": "ordnode.ratio",
    "statement": "def ordnode.ratio  : ℕ",
    "theorem": " : ℕ",
    "args": "",
    "doc_string": " **Internal use only**  The ratio between an outer and inner sibling of the heavier subtree in an unbalanced setting. It determines whether a double or single rotation should be performed to restore balance. It is corresponds with the inverse of `α` in Adam's article.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "ordinal.is_fundamental_sequence",
    "statement": "def ordinal.is_fundamental_sequence (a o : ordinal) (f : Π (b : ordinal), b < o → ordinal) : Prop",
    "theorem": "(a o : ordinal) (f : Π (b : ordinal), b < o → ordinal) : Prop",
    "args": "(a o : ordinal) (f : Π (b : ordinal), b < o → ordinal)",
    "doc_string": "A fundamental sequence for `a` is an increasing sequence of length `o = cof a` that converges at    `a`. We provide `o` explicitly in order to avoid type rewrites.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_simple_order.boolean_algebra",
    "statement": "def is_simple_order.boolean_algebra {α : Type u_1} [decidable_eq α] [lattice α] [bounded_order α] [is_simple_order α] : boolean_algebra α",
    "theorem": "{α : Type u_1} [decidable_eq α] [lattice α] [bounded_order α] [is_simple_order α] : boolean_algebra α",
    "args": "{α : Type u_1} [decidable_eq α] [lattice α] [bounded_order α] [is_simple_order α]",
    "doc_string": "A simple `bounded_order` is also a `boolean_algebra`.",
    "kind": "def",
    "type": "boolean_algebra α"
  },
  {
    "name": "local_ring.maximal_ideal",
    "statement": "def local_ring.maximal_ideal (R : Type u) [comm_semiring R] [local_ring R] : ideal R",
    "theorem": "(R : Type u) [comm_semiring R] [local_ring R] : ideal R",
    "args": "(R : Type u) [comm_semiring R] [local_ring R]",
    "doc_string": "The ideal of elements that are not units.",
    "kind": "def",
    "type": "ideal R"
  },
  {
    "name": "monad_functor_t",
    "statement": "structure monad_functor_t (m m' : Type u → Type v) (n n' : Type u → Type w) : Type (max (u+1) v w)",
    "theorem": "(m m' : Type u → Type v) (n n' : Type u → Type w) : Type (max (u+1) v w)",
    "args": "(m m' : Type u → Type v) (n n' : Type u → Type w)",
    "doc_string": "The reflexive-transitive closure of `monad_functor`.    `monad_map` is used to transitively lift monad morphisms such as `state_t.zoom`.    A generalization of [MonadLiftFunctor](http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadLiftFunctor), which can only lift endomorphisms (i.e. m = m', n = n').",
    "kind": "structure",
    "type": "Type (max (u+1) v w)"
  },
  {
    "name": "zmod.legendre_sym_mod",
    "statement": "theorem zmod.legendre_sym_mod (p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ)",
    "doc_string": "The Legendre symbol depends only on `a` mod `p`.",
    "kind": "theorem",
    "type": "zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)"
  },
  {
    "name": "list.sections",
    "statement": "def list.sections {α : Type u_1} : list (list α) → list (list α)",
    "theorem": "{α : Type u_1} : list (list α) → list (list α)",
    "args": "{α : Type u_1}",
    "doc_string": "List of all sections through a list of lists. A section  of `[L₁, L₂, ..., Lₙ]` is a list whose first element comes from  `L₁`, whose second element comes from `L₂`, and so on.",
    "kind": "def",
    "type": "list (list α) → list (list α)"
  },
  {
    "name": "int.gcd_a",
    "statement": "def int.gcd_a  : ℤ → ℤ → ℤ",
    "theorem": " : ℤ → ℤ → ℤ",
    "args": "",
    "doc_string": "The extended GCD `a` value in the equation `gcd x y = x * a + y * b`.",
    "kind": "def",
    "type": "ℤ → ℤ → ℤ"
  },
  {
    "name": "set.piecewise",
    "statement": "def set.piecewise {α : Type u} {β : α → Sort v} (s : set α) (f g : Π (i : α), β i) [Π (j : α), decidable (j ∈ s)] (i : α) : β i",
    "theorem": "{α : Type u} {β : α → Sort v} (s : set α) (f g : Π (i : α), β i) [Π (j : α), decidable (j ∈ s)] (i : α) : β i",
    "args": "{α : Type u} {β : α → Sort v} (s : set α) (f g : Π (i : α), β i) [Π (j : α), decidable (j ∈ s)] (i : α)",
    "doc_string": "`s.piecewise f g` is the function equal to `f` on the set `s`, and to `g` on its complement.",
    "kind": "def",
    "type": "β i"
  },
  {
    "name": "finite_dimensional.finrank_self",
    "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1",
    "theorem": "(K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1",
    "args": "(K : Type u) [division_ring K]",
    "doc_string": "A division_ring is one-dimensional as a vector space over itself.",
    "kind": "theorem",
    "type": "finite_dimensional.finrank K K = 1"
  },
  {
    "name": "has_reflect",
    "statement": "def has_reflect (α : Sort u) : Sort (max u 1)",
    "theorem": "(α : Sort u) : Sort (max u 1)",
    "args": "(α : Sort u)",
    "doc_string": "`has_reflect α` lets you produce an `expr` from an instance of α. That is, it is a function from α to expr such that the expr has type α.",
    "kind": "def",
    "type": "Sort (max u 1)"
  },
  {
    "name": "filter.rtendsto",
    "statement": "def filter.rtendsto {α : Type u} {β : Type v} (r : rel α β) (l₁ : filter α) (l₂ : filter β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (r : rel α β) (l₁ : filter α) (l₂ : filter β) : Prop",
    "args": "{α : Type u} {β : Type v} (r : rel α β) (l₁ : filter α) (l₂ : filter β)",
    "doc_string": " Generic \"limit of a relation\" predicate. `rtendsto r l₁ l₂` asserts that for every `l₂`-neighborhood `a`, the `r`-core of `a` is an `l₁`-neighborhood. One generalization of `filter.tendsto` to relations.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pgame",
    "statement": "inductive pgame  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The type of pre-games, before we have quotiented  by equivalence (`pgame.setoid`). In ZFC, a combinatorial game is constructed from  two sets of combinatorial games that have been constructed at an earlier  stage. To do this in type theory, we say that a pre-game is built  inductively from two families of pre-games indexed over any type  in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,  reflecting that it is a proper class in ZFC.",
    "kind": "inductive",
    "type": "Type (u+1)"
  },
  {
    "name": "pos_num.ldiff",
    "statement": "def pos_num.ldiff  : pos_num → pos_num → num",
    "theorem": " : pos_num → pos_num → num",
    "args": "",
    "doc_string": "Bitwise `λ a b, a && !b` for `pos_num`. For example, `ldiff 5 9 = 4`:      101    1001    ----     100",
    "kind": "def",
    "type": "pos_num → pos_num → num"
  },
  {
    "name": "category_theory.is_detector",
    "statement": "def category_theory.is_detector {C : Type u} [category_theory.category C] (G : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (G : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (G : C)",
    "doc_string": "We say that `G` is a detector if the functor `C(G, -)` reflects isomorphisms.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_conj.setoid",
    "statement": "def is_conj.setoid (α : Type u_1) [monoid α] : setoid α",
    "theorem": "(α : Type u_1) [monoid α] : setoid α",
    "args": "(α : Type u_1) [monoid α]",
    "doc_string": "The setoid of the relation `is_conj` iff there is a unit `u` such that `u * x = y * u`",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "powers",
    "statement": "def powers {M : Type u_1} [monoid M] (x : M) : set M",
    "theorem": "{M : Type u_1} [monoid M] (x : M) : set M",
    "args": "{M : Type u_1} [monoid M] (x : M)",
    "doc_string": "The set of natural number powers `1, x, x², ...` of an element `x` of a monoid.",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "t1_space",
    "statement": "structure t1_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A T₁ space, also known as a Fréchet space, is a topological space  where every singleton set is closed. Equivalently, for every pair  `x ≠ y`, there is an open set containing `x` and not `y`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "add_submonoid.topological_closure",
    "statement": "def add_submonoid.topological_closure {M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] (s : add_submonoid M) : add_submonoid M",
    "theorem": "{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] (s : add_submonoid M) : add_submonoid M",
    "args": "{M : Type u_4} [topological_space M] [add_monoid M] [has_continuous_add M] (s : add_submonoid M)",
    "doc_string": "The (topological-space) closure of an additive submonoid of a space `M` with `has_continuous_add` is itself an additive submonoid.",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "ratfunc",
    "statement": "structure ratfunc (K : Type u) [hring : comm_ring K] : Type u",
    "theorem": "(K : Type u) [hring : comm_ring K] : Type u",
    "args": "(K : Type u) [hring : comm_ring K]",
    "doc_string": " `ratfunc K` is `K(x)`, the field of rational functions over `K`.  The inclusion of polynomials into `ratfunc` is `algebra_map K[X] (ratfunc K)`, the maps between `ratfunc K` and another field of fractions of `polynomial K`, especially `fraction_ring K[X]`, are given by `is_localization.algebra_equiv`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "subfield.to_submonoid",
    "statement": "def subfield.to_submonoid {K : Type u} [field K] (s : subfield K) : submonoid K",
    "theorem": "{K : Type u} [field K] (s : subfield K) : submonoid K",
    "args": "{K : Type u} [field K] (s : subfield K)",
    "doc_string": "The underlying submonoid of a subfield.",
    "kind": "def",
    "type": "submonoid K"
  },
  {
    "name": "Rep",
    "statement": "def Rep (k G : Type u) [ring k] [monoid G] : Type (u+1)",
    "theorem": "(k G : Type u) [ring k] [monoid G] : Type (u+1)",
    "args": "(k G : Type u) [ring k] [monoid G]",
    "doc_string": "The category of `k`-linear representations of a monoid `G`.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "prime_multiset.of_nat_multiset",
    "statement": "def prime_multiset.of_nat_multiset (v : multiset ℕ) (h : ∀ (p : ℕ), p ∈ v → nat.prime p) : prime_multiset",
    "theorem": "(v : multiset ℕ) (h : ∀ (p : ℕ), p ∈ v → nat.prime p) : prime_multiset",
    "args": "(v : multiset ℕ) (h : ∀ (p : ℕ), p ∈ v → nat.prime p)",
    "doc_string": "If a `multiset ℕ` consists only of primes, it can be recast as a `prime_multiset`.",
    "kind": "def",
    "type": "prime_multiset"
  },
  {
    "name": "free_monoid.star_one",
    "statement": "theorem free_monoid.star_one {α : Type u_1} : has_star.star 1 = 1",
    "theorem": "{α : Type u_1} : has_star.star 1 = 1",
    "args": "{α : Type u_1}",
    "doc_string": "Note that `star_one` is already a global simp lemma, but this one works with dsimp too",
    "kind": "theorem",
    "type": "has_star.star 1 = 1"
  },
  {
    "name": "submodule.torsion_by_set",
    "statement": "def submodule.torsion_by_set (R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule R M",
    "theorem": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : submodule R M",
    "args": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R)",
    "doc_string": "The submodule containing all elements `x` of `M` such that `a • x = 0` for all `a` in `s`.",
    "kind": "def",
    "type": "submodule R M"
  },
  {
    "name": "strict_anti_on",
    "statement": "def strict_anti_on {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α)",
    "doc_string": " A function `f` is strictly antitone on `s` if, for all `a, b ∈ s`, `a < b` implies `f b < f a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "floor_ring",
    "statement": "structure floor_ring (α : Type u_2) [linear_ordered_ring α] : Type u_2",
    "theorem": "(α : Type u_2) [linear_ordered_ring α] : Type u_2",
    "args": "(α : Type u_2) [linear_ordered_ring α]",
    "doc_string": "A `floor_ring` is a linear ordered ring over `α` with a function `floor : α → ℤ` satisfying `∀ (z : ℤ) (a : α), z ≤ floor a ↔ (z : α) ≤ a)`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "subsemigroup.has_top",
    "statement": "def subsemigroup.has_top {M : Type u_1} [has_mul M] : has_top (subsemigroup M)",
    "theorem": "{M : Type u_1} [has_mul M] : has_top (subsemigroup M)",
    "args": "{M : Type u_1} [has_mul M]",
    "doc_string": "The subsemigroup `M` of the magma `M`.",
    "kind": "def",
    "type": "has_top (subsemigroup M)"
  },
  {
    "name": "onote.mul_nat",
    "statement": "def onote.mul_nat  : onote → ℕ → onote",
    "theorem": " : onote → ℕ → onote",
    "args": "",
    "doc_string": "`mul_nat o n` is the ordinal notation for `o * n`.",
    "kind": "def",
    "type": "onote → ℕ → onote"
  },
  {
    "name": "Set.Union",
    "statement": "def Set.Union  : Set → Set",
    "theorem": " : Set → Set",
    "args": "",
    "doc_string": "The union operator, the collection of elements of elements of a ZFC set",
    "kind": "def",
    "type": "Set → Set"
  },
  {
    "name": "tactic.norm_num.factors_helper",
    "statement": "def tactic.norm_num.factors_helper (n p : ℕ) (l : list ℕ) : Prop",
    "theorem": "(n p : ℕ) (l : list ℕ) : Prop",
    "args": "(n p : ℕ) (l : list ℕ)",
    "doc_string": " A partial proof of `factors`. Asserts that `l` is a sorted list of primes, lower bounded by a prime `p`, which multiplies to `n`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "mvpfunctor.W",
    "statement": "def mvpfunctor.W {n : ℕ} (P : mvpfunctor (n + 1)) (α : typevec n) : Type u",
    "theorem": "{n : ℕ} (P : mvpfunctor (n + 1)) (α : typevec n) : Type u",
    "args": "{n : ℕ} (P : mvpfunctor (n + 1)) (α : typevec n)",
    "doc_string": "W-type of `P`",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "closure_operator.id",
    "statement": "def closure_operator.id (α : Type u_1) [partial_order α] : closure_operator α",
    "theorem": "(α : Type u_1) [partial_order α] : closure_operator α",
    "args": "(α : Type u_1) [partial_order α]",
    "doc_string": "The identity function as a closure operator.",
    "kind": "def",
    "type": "closure_operator α"
  },
  {
    "name": "has_le.to_has_btw",
    "statement": "def has_le.to_has_btw (α : Type u_1) [has_le α] : has_btw α",
    "theorem": "(α : Type u_1) [has_le α] : has_btw α",
    "args": "(α : Type u_1) [has_le α]",
    "doc_string": " The betweenness relation obtained from \"looping around\" `≤`. See note [reducible non-instances].",
    "kind": "def",
    "type": "has_btw α"
  },
  {
    "name": "real.tendsto_exp_at_top",
    "statement": "theorem real.tendsto_exp_at_top  : filter.tendsto real.exp filter.at_top filter.at_top",
    "theorem": " : filter.tendsto real.exp filter.at_top filter.at_top",
    "args": "",
    "doc_string": "The real exponential function tends to `+∞` at `+∞`.",
    "kind": "theorem",
    "type": "filter.tendsto real.exp filter.at_top filter.at_top"
  },
  {
    "name": "multiset.powerset_aux",
    "statement": "def multiset.powerset_aux {α : Type u_1} (l : list α) : list (multiset α)",
    "theorem": "{α : Type u_1} (l : list α) : list (multiset α)",
    "args": "{α : Type u_1} (l : list α)",
    "doc_string": " A helper function for the powerset of a multiset. Given a list `l`, returns a list of sublists of `l` (using `sublists_aux`), as multisets.",
    "kind": "def",
    "type": "list (multiset α)"
  },
  {
    "name": "intermediate_field.adjoin",
    "statement": "def intermediate_field.adjoin (F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S : set E) : intermediate_field F E",
    "theorem": "(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S : set E) : intermediate_field F E",
    "args": "(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S : set E)",
    "doc_string": "`adjoin F S` extends a field `F` by adjoining a set `S ⊆ E`.",
    "kind": "def",
    "type": "intermediate_field F E"
  },
  {
    "name": "invertible_mul",
    "statement": "def invertible_mul {α : Type u} [monoid α] (a b : α) [invertible a] [invertible b] : invertible (a * b)",
    "theorem": "{α : Type u} [monoid α] (a b : α) [invertible a] [invertible b] : invertible (a * b)",
    "args": "{α : Type u} [monoid α] (a b : α) [invertible a] [invertible b]",
    "doc_string": "`⅟b * ⅟a` is the inverse of `a * b`",
    "kind": "def",
    "type": "invertible (a * b)"
  },
  {
    "name": "order.preimage",
    "statement": "def order.preimage {α : Sort u_1} {β : Sort u_2} (f : α → β) (s : β → β → Prop) (x y : α) : Prop",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (f : α → β) (s : β → β → Prop) (x y : α) : Prop",
    "args": "{α : Sort u_1} {β : Sort u_2} (f : α → β) (s : β → β → Prop) (x y : α)",
    "doc_string": " Given a relation `R` on `β` and a function `f : α → β`, the preimage relation on `α` is defined by `x ≤ y ↔ f x ≤ f y`. It is the unique relation on `α` making `f` a `rel_embedding` (assuming `f` is injective).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "fin.elim0'",
    "statement": "def fin.elim0' {α : Sort u_1} (x : fin 0) : α",
    "theorem": "{α : Sort u_1} (x : fin 0) : α",
    "args": "{α : Sort u_1} (x : fin 0)",
    "doc_string": "A non-dependent variant of `elim0`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "quandle",
    "statement": "structure quandle (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A quandle is a rack such that each automorphism fixes its corresponding element.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "prod.char_p",
    "statement": "def prod.char_p (R : Type u) (S : Type v) [semiring R] [semiring S] (p : ℕ) [char_p R p] [char_p S p] : char_p (R × S) p",
    "theorem": "(R : Type u) (S : Type v) [semiring R] [semiring S] (p : ℕ) [char_p R p] [char_p S p] : char_p (R × S) p",
    "args": "(R : Type u) (S : Type v) [semiring R] [semiring S] (p : ℕ) [char_p R p] [char_p S p]",
    "doc_string": "The characteristic of the product of two rings of the same characteristic  is the same as the characteristic of the rings",
    "kind": "def",
    "type": "char_p (R × S) p"
  },
  {
    "name": "turing.fin_tm2",
    "statement": "structure turing.fin_tm2  : Type 1",
    "theorem": " : Type 1",
    "args": "",
    "doc_string": " A bundled TM2 (an equivalent of the classical Turing machine, defined starting from the namespace `turing.TM2` in `turing_machine.lean`), with an input and output stack,  a main function, an initial state and some finiteness guarantees.",
    "kind": "structure",
    "type": "Type 1"
  },
  {
    "name": "set.add_semigroup",
    "statement": "def set.add_semigroup {α : Type u_2} [add_semigroup α] : add_semigroup (set α)",
    "theorem": "{α : Type u_2} [add_semigroup α] : add_semigroup (set α)",
    "args": "{α : Type u_2} [add_semigroup α]",
    "doc_string": "`set α` is an `add_semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_semigroup (set α)"
  },
  {
    "name": "topological_space.positive_compacts.nonempty'",
    "statement": "def topological_space.positive_compacts.nonempty' {α : Type u_1} [topological_space α] [locally_compact_space α] [nonempty α] : nonempty (topological_space.positive_compacts α)",
    "theorem": "{α : Type u_1} [topological_space α] [locally_compact_space α] [nonempty α] : nonempty (topological_space.positive_compacts α)",
    "args": "{α : Type u_1} [topological_space α] [locally_compact_space α] [nonempty α]",
    "doc_string": "In a nonempty locally compact space, there exists a compact set with nonempty interior.",
    "kind": "def",
    "type": "nonempty (topological_space.positive_compacts α)"
  },
  {
    "name": "pullback_nonzero",
    "statement": "theorem pullback_nonzero {M₀ : Type u_1} {M₀' : Type u_3} [mul_zero_one_class M₀] [nontrivial M₀] [has_zero M₀'] [has_one M₀'] (f : M₀' → M₀) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial M₀'",
    "theorem": "{M₀ : Type u_1} {M₀' : Type u_3} [mul_zero_one_class M₀] [nontrivial M₀] [has_zero M₀'] [has_one M₀'] (f : M₀' → M₀) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial M₀'",
    "args": "{M₀ : Type u_1} {M₀' : Type u_3} [mul_zero_one_class M₀] [nontrivial M₀] [has_zero M₀'] [has_one M₀'] (f : M₀' → M₀) (zero : f 0 = 0) (one : f 1 = 1)",
    "doc_string": "Pullback a `nontrivial` instance along a function sending `0` to `0` and `1` to `1`.",
    "kind": "theorem",
    "type": "nontrivial M₀'"
  },
  {
    "name": "is_closed_map_smul_of_ne_zero",
    "statement": "theorem is_closed_map_smul_of_ne_zero {α : Type u_2} {G₀ : Type u_4} [topological_space α] [group_with_zero G₀] [mul_action G₀ α] [has_continuous_const_smul G₀ α] {c : G₀} (hc : c ≠ 0) : is_closed_map (λ (x : α), c • x)",
    "theorem": "{α : Type u_2} {G₀ : Type u_4} [topological_space α] [group_with_zero G₀] [mul_action G₀ α] [has_continuous_const_smul G₀ α] {c : G₀} (hc : c ≠ 0) : is_closed_map (λ (x : α), c • x)",
    "args": "{α : Type u_2} {G₀ : Type u_4} [topological_space α] [group_with_zero G₀] [mul_action G₀ α] [has_continuous_const_smul G₀ α] {c : G₀} (hc : c ≠ 0)",
    "doc_string": " `smul` is a closed map in the second argument.  The lemma that `smul` is a closed map in the first argument (for a normed space over a complete normed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`.",
    "kind": "theorem",
    "type": "is_closed_map (λ (x : α), c • x)"
  },
  {
    "name": "expr_lens",
    "statement": "inductive expr_lens  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " You're supposed to think of an `expr_lens` as a big set of nested applications with a single hole which needs to be filled, either in a function spot or argument spot. `expr_lens.fill` can fill this hole and turn your lens back into a real `expr`.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "category_theory.limits.is_zero.is_initial",
    "statement": "def category_theory.limits.is_zero.is_initial {C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_initial X",
    "theorem": "{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X) : category_theory.limits.is_initial X",
    "args": "{C : Type u} [category_theory.category C] {X : C} (hX : category_theory.limits.is_zero X)",
    "doc_string": "A zero object is in particular initial.",
    "kind": "def",
    "type": "category_theory.limits.is_initial X"
  },
  {
    "name": "multiset.prod",
    "statement": "def multiset.prod {α : Type u_2} [comm_monoid α] : multiset α → α",
    "theorem": "{α : Type u_2} [comm_monoid α] : multiset α → α",
    "args": "{α : Type u_2} [comm_monoid α]",
    "doc_string": "Product of a multiset given a commutative monoid structure on `α`.  `prod {a, b, c} = a * b * c`",
    "kind": "def",
    "type": "multiset α → α"
  },
  {
    "name": "slim_check.total_function.list.to_finmap'",
    "statement": "def slim_check.total_function.list.to_finmap' {α : Type u} {β : Type v} (xs : list (α × β)) : list (Σ (_x : α), β)",
    "theorem": "{α : Type u} {β : Type v} (xs : list (α × β)) : list (Σ (_x : α), β)",
    "args": "{α : Type u} {β : Type v} (xs : list (α × β))",
    "doc_string": "Create a `finmap` from a list of pairs.",
    "kind": "def",
    "type": "list (Σ (_x : α), β)"
  },
  {
    "name": "int.log",
    "statement": "def int.log {R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ℕ) (r : R) : ℤ",
    "theorem": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ℕ) (r : R) : ℤ",
    "args": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ℕ) (r : R)",
    "doc_string": "The greatest power of `b` such that `b ^ log b r ≤ r`.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "sigma.lt",
    "statement": "inductive sigma.lt {ι : Type u_1} {α : ι → Type u_2} [Π (i : ι), has_lt (α i)] (a b : Σ (i : ι), α i) : Prop",
    "theorem": "{ι : Type u_1} {α : ι → Type u_2} [Π (i : ι), has_lt (α i)] (a b : Σ (i : ι), α i) : Prop",
    "args": "{ι : Type u_1} {α : ι → Type u_2} [Π (i : ι), has_lt (α i)] (a b : Σ (i : ι), α i)",
    "doc_string": "Disjoint sum of orders. `⟨i, a⟩ < ⟨j, b⟩` iff `i = j` and `a < b`.",
    "kind": "inductive",
    "type": "Prop"
  },
  {
    "name": "module.dual",
    "statement": "def module.dual (R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_2 u_1)",
    "theorem": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_2 u_1)",
    "args": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "The dual space of an R-module M is the R-module of linear maps `M → R`.",
    "kind": "def",
    "type": "Type (max u_2 u_1)"
  },
  {
    "name": "uniform_convergence.gen",
    "statement": "def uniform_convergence.gen (α : Type u_1) (β : Type u_2) (V : set (β × β)) : set ((α → β) × (α → β))",
    "theorem": "(α : Type u_1) (β : Type u_2) (V : set (β × β)) : set ((α → β) × (α → β))",
    "args": "(α : Type u_1) (β : Type u_2) (V : set (β × β))",
    "doc_string": "Basis sets for the uniformity of uniform convergence",
    "kind": "def",
    "type": "set ((α → β) × (α → β))"
  },
  {
    "name": "emetric_space.induced",
    "statement": "def emetric_space.induced {γ : Type u_1} {β : Type u_2} (f : γ → β) (hf : function.injective f) (m : emetric_space β) : emetric_space γ",
    "theorem": "{γ : Type u_1} {β : Type u_2} (f : γ → β) (hf : function.injective f) (m : emetric_space β) : emetric_space γ",
    "args": "{γ : Type u_1} {β : Type u_2} (f : γ → β) (hf : function.injective f) (m : emetric_space β)",
    "doc_string": "The extended metric induced by an injective function taking values in a emetric space.",
    "kind": "def",
    "type": "emetric_space γ"
  },
  {
    "name": "has_sbtw.sbtw.btw",
    "statement": "theorem has_sbtw.sbtw.btw {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of btw_of_sbtw`.",
    "kind": "theorem",
    "type": "has_btw.btw a b c"
  },
  {
    "name": "set.Ioi_subset_Ici",
    "statement": "theorem set.Ioi_subset_Ici {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ici a",
    "theorem": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ici a",
    "args": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b)",
    "doc_string": " If `a ≤ b`, then `(b, +∞) ⊆ [a, +∞)`. In preorders, this is just an implication. If you need the equivalence in dense linear orders, use `Ioi_subset_Ici_iff`.",
    "kind": "theorem",
    "type": "set.Ioi b ⊆ set.Ici a"
  },
  {
    "name": "finsum_mem_zero",
    "statement": "theorem finsum_mem_zero {α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0",
    "theorem": "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0",
    "args": "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α)",
    "doc_string": "The product of the constant function `0` over any set equals `0`.",
    "kind": "theorem",
    "type": "finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0"
  },
  {
    "name": "add_comm_semigroup",
    "statement": "structure add_comm_semigroup (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": "A commutative additive semigroup is a type with an associative commutative `(+)`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "euclidean_domain.xgcd_aux",
    "statement": "def euclidean_domain.xgcd_aux {R : Type u} [euclidean_domain R] [decidable_eq R] : R → R → R → R → R → R → R × R × R",
    "theorem": "{R : Type u} [euclidean_domain R] [decidable_eq R] : R → R → R → R → R → R → R × R × R",
    "args": "{R : Type u} [euclidean_domain R] [decidable_eq R]",
    "doc_string": "An implementation of the extended GCD algorithm. At each step we are computing a triple `(r, s, t)`, where `r` is the next value of the GCD algorithm, to compute the greatest common divisor of the input (say `x` and `y`), and `s` and `t` are the coefficients in front of `x` and `y` to obtain `r` (i.e. `r = s * x + t * y`). The function `xgcd_aux` takes in two triples, and from these recursively computes the next triple: ```lean xgcd_aux (r, s, t) (r', s', t') = xgcd_aux (r' % r, s' - (r' / r) * s, t' - (r' / r) * t) (r, s, t) ```",
    "kind": "def",
    "type": "R → R → R → R → R → R → R × R × R"
  },
  {
    "name": "is_add_hom",
    "statement": "structure is_add_hom {α : Type u_1} {β : Type u_2} [has_add α] [has_add β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_add α] [has_add β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [has_add α] [has_add β] (f : α → β)",
    "doc_string": "Predicate for maps which preserve an addition.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "algebraic_geometry.Scheme.empty",
    "statement": "def algebraic_geometry.Scheme.empty  : algebraic_geometry.Scheme",
    "theorem": " : algebraic_geometry.Scheme",
    "args": "",
    "doc_string": "The empty scheme, as `Spec 0`.",
    "kind": "def",
    "type": "algebraic_geometry.Scheme"
  },
  {
    "name": "multiset.sub",
    "statement": "def multiset.sub {α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "args": "{α : Type u_1} [decidable_eq α] (s t : multiset α)",
    "doc_string": "`s - t` is the multiset such that `count a (s - t) = count a s - count a t` for all `a`  (note that it is truncated subtraction, so it is `0` if `count a t ≥ count a s`).",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "image_range_order_of",
    "statement": "theorem image_range_order_of {G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (λ (i : ℕ), x ^ i) (finset.range (order_of x)) = ↑(subgroup.zpowers x).to_finset",
    "theorem": "{G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (λ (i : ℕ), x ^ i) (finset.range (order_of x)) = ↑(subgroup.zpowers x).to_finset",
    "args": "{G : Type u} {x : G} [fintype G] [group G] [decidable_eq G]",
    "doc_string": "TODO: Generalise to `submonoid.powers`.",
    "kind": "theorem",
    "type": "finset.image (λ (i : ℕ), x ^ i) (finset.range (order_of x)) = ↑(subgroup.zpowers x).to_finset"
  },
  {
    "name": "list.perm",
    "statement": "inductive list.perm {α : Type uu} : list α → list α → Prop",
    "theorem": "{α : Type uu} : list α → list α → Prop",
    "args": "{α : Type uu}",
    "doc_string": "`perm l₁ l₂` or `l₁ ~ l₂` asserts that `l₁` and `l₂` are permutations  of each other. This is defined by induction using pairwise swaps.",
    "kind": "inductive",
    "type": "list α → list α → Prop"
  },
  {
    "name": "is_sup_closed_compact.is_Sup_finite_compact",
    "statement": "theorem is_sup_closed_compact.is_Sup_finite_compact (α : Type u_1) [complete_lattice α] : complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α",
    "theorem": "(α : Type u_1) [complete_lattice α] : complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": "**Alias** of the reverse direction of complete_lattice.is_Sup_finite_compact_iff_is_sup_closed_compact`.",
    "kind": "theorem",
    "type": "complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α"
  },
  {
    "name": "list.countp",
    "statement": "def list.countp {α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → ℕ",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → ℕ",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p]",
    "doc_string": "`countp p l` is the number of elements of `l` that satisfy `p`.",
    "kind": "def",
    "type": "list α → ℕ"
  },
  {
    "name": "module.ray.some_ray_vector",
    "statement": "def module.ray.some_ray_vector {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ray_vector R M",
    "theorem": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M) : ray_vector R M",
    "args": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : module.ray R M)",
    "doc_string": "An arbitrary `ray_vector` giving a ray.",
    "kind": "def",
    "type": "ray_vector R M"
  },
  {
    "name": "free_group.reduce.min",
    "statement": "theorem free_group.reduce.min {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red (free_group.reduce L₁) L₂) : free_group.reduce L₁ = L₂",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red (free_group.reduce L₁) L₂) : free_group.reduce L₁ = L₂",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red (free_group.reduce L₁) L₂)",
    "doc_string": " The second theorem that characterises the function `reduce`: the maximal reduction of a word only reduces to itself.",
    "kind": "theorem",
    "type": "free_group.reduce L₁ = L₂"
  },
  {
    "name": "covby",
    "statement": "def covby {α : Type u_1} [has_lt α] (a b : α) : Prop",
    "theorem": "{α : Type u_1} [has_lt α] (a b : α) : Prop",
    "args": "{α : Type u_1} [has_lt α] (a b : α)",
    "doc_string": "`covby a b` means that `b` covers `a`: `a < b` and there is no element in between.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "array.mmap",
    "statement": "def array.mmap {n : ℕ} {α : Type u} {β : Type v} {m : Type v → Type u_1} [monad m] (a : array n α) (f : α → m β) : m (array n β)",
    "theorem": "{n : ℕ} {α : Type u} {β : Type v} {m : Type v → Type u_1} [monad m] (a : array n α) (f : α → m β) : m (array n β)",
    "args": "{n : ℕ} {α : Type u} {β : Type v} {m : Type v → Type u_1} [monad m] (a : array n α) (f : α → m β)",
    "doc_string": "Monadically map a function over the array.",
    "kind": "def",
    "type": "m (array n β)"
  },
  {
    "name": "equiv.mul_right",
    "statement": "def equiv.mul_right {G : Type u_10} [group G] (a : G) : equiv.perm G",
    "theorem": "{G : Type u_10} [group G] (a : G) : equiv.perm G",
    "args": "{G : Type u_10} [group G] (a : G)",
    "doc_string": "Right multiplication in a `group` is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm G"
  },
  {
    "name": "prime_spectrum.basic_open",
    "statement": "def prime_spectrum.basic_open {R : Type u} [comm_ring R] (r : R) : topological_space.opens (prime_spectrum R)",
    "theorem": "{R : Type u} [comm_ring R] (r : R) : topological_space.opens (prime_spectrum R)",
    "args": "{R : Type u} [comm_ring R] (r : R)",
    "doc_string": "`basic_open r` is the open subset containing all prime ideals not containing `r`.",
    "kind": "def",
    "type": "topological_space.opens (prime_spectrum R)"
  },
  {
    "name": "subset_affine_span",
    "statement": "theorem subset_affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ ↑(affine_span k s)",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ ↑(affine_span k s)",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P)",
    "doc_string": "A set is contained in its affine span.",
    "kind": "theorem",
    "type": "s ⊆ ↑(affine_span k s)"
  },
  {
    "name": "measure_theory.measure.sum",
    "statement": "def measure_theory.measure.sum {α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} (f : ι → measure_theory.measure α) : measure_theory.measure α",
    "theorem": "{α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} (f : ι → measure_theory.measure α) : measure_theory.measure α",
    "args": "{α : Type u_1} {ι : Type u_5} {m0 : measurable_space α} (f : ι → measure_theory.measure α)",
    "doc_string": "Sum of an indexed family of measures.",
    "kind": "def",
    "type": "measure_theory.measure α"
  },
  {
    "name": "properly_discontinuous_vadd",
    "statement": "structure properly_discontinuous_vadd (Γ : Type u_4) (T : Type u_5) [topological_space T] [has_vadd Γ T] : Prop",
    "theorem": "(Γ : Type u_4) (T : Type u_5) [topological_space T] [has_vadd Γ T] : Prop",
    "args": "(Γ : Type u_4) (T : Type u_5) [topological_space T] [has_vadd Γ T]",
    "doc_string": " Class `properly_discontinuous_vadd Γ T` says that the additive action `(+ᵥ) : Γ → T → T` is properly discontinuous, that is, for any pair of compact sets `K, L` in `T`, only finitely many `γ:Γ` move `K` to have nontrivial intersection with `L`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "contravariant.to_right_cancel_semigroup",
    "statement": "def contravariant.to_right_cancel_semigroup {α : Type u_1} [semigroup α] [partial_order α] [contravariant_class α α (function.swap has_mul.mul) has_le.le] : right_cancel_semigroup α",
    "theorem": "{α : Type u_1} [semigroup α] [partial_order α] [contravariant_class α α (function.swap has_mul.mul) has_le.le] : right_cancel_semigroup α",
    "args": "{α : Type u_1} [semigroup α] [partial_order α] [contravariant_class α α (function.swap has_mul.mul) has_le.le]",
    "doc_string": "  A semigroup with a partial order and satisfying `right_cancel_semigroup` (i.e. `a * c < b * c → a < b`) is a `right_cancel semigroup`.",
    "kind": "def",
    "type": "right_cancel_semigroup α"
  },
  {
    "name": "category_theory.limits.binary_bicone.is_bilimit",
    "statement": "structure category_theory.limits.binary_bicone.is_bilimit {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (b : category_theory.limits.binary_bicone P Q) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (b : category_theory.limits.binary_bicone P Q) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (b : category_theory.limits.binary_bicone P Q)",
    "doc_string": "Structure witnessing that a binary bicone is a limit cone and a limit cocone.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "add_monoid_algebra.algebra",
    "statement": "def add_monoid_algebra.algebra {k : Type u₁} {G : Type u₂} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : algebra R (add_monoid_algebra k G)",
    "theorem": "{k : Type u₁} {G : Type u₂} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : algebra R (add_monoid_algebra k G)",
    "args": "{k : Type u₁} {G : Type u₂} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G]",
    "doc_string": "The instance `algebra R (add_monoid_algebra k G)` whenever we have `algebra R k`.  In particular this provides the instance `algebra k (add_monoid_algebra k G)`.",
    "kind": "def",
    "type": "algebra R (add_monoid_algebra k G)"
  },
  {
    "name": "emetric.inf_edist_le_edist_of_mem",
    "statement": "theorem emetric.inf_edist_le_edist_of_mem {α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s) : emetric.inf_edist x s ≤ has_edist.edist x y",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s) : emetric.inf_edist x s ≤ has_edist.edist x y",
    "args": "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s)",
    "doc_string": "The edist to a set is bounded above by the edist to any of its points",
    "kind": "theorem",
    "type": "emetric.inf_edist x s ≤ has_edist.edist x y"
  },
  {
    "name": "category_theory.limits.terminal",
    "statement": "def category_theory.limits.terminal (C : Type u₁) [category_theory.category C] [category_theory.limits.has_terminal C] : C",
    "theorem": "(C : Type u₁) [category_theory.category C] [category_theory.limits.has_terminal C] : C",
    "args": "(C : Type u₁) [category_theory.category C] [category_theory.limits.has_terminal C]",
    "doc_string": "An arbitrary choice of terminal object, if one exists. You can use the notation `⊤_ C`. This object is characterized by having a unique morphism from any object.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "module.flat",
    "statement": "structure module.flat (R : Type u) (M : Type v) [comm_ring R] [add_comm_group M] [module R M] : Prop",
    "theorem": "(R : Type u) (M : Type v) [comm_ring R] [add_comm_group M] [module R M] : Prop",
    "args": "(R : Type u) (M : Type v) [comm_ring R] [add_comm_group M] [module R M]",
    "doc_string": " An `R`-module `M` is flat if for all finitely generated ideals `I` of `R`, the canonical map `I ⊗ M →ₗ M` is injective.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "besicovitch.unit_ball_package",
    "statement": "def besicovitch.unit_ball_package (α : Type u_1) : besicovitch.ball_package α α",
    "theorem": "(α : Type u_1) : besicovitch.ball_package α α",
    "args": "(α : Type u_1)",
    "doc_string": "The ball package made of unit balls.",
    "kind": "def",
    "type": "besicovitch.ball_package α α"
  },
  {
    "name": "category_theory.over.over_has_terminal",
    "statement": "theorem category_theory.over.over_has_terminal {C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] (B : C)",
    "doc_string": "Construct terminal object in the over category. This isn't an instance as it's not typically the way we want to define terminal objects. (For instance, this gives a terminal object which is different from the generic one given by `over_product_of_wide_pullback` above.)",
    "kind": "theorem",
    "type": "category_theory.limits.has_terminal (category_theory.over B)"
  },
  {
    "name": "equiv.perm.disjoint",
    "statement": "def equiv.perm.disjoint {α : Type u_1} (f g : equiv.perm α) : Prop",
    "theorem": "{α : Type u_1} (f g : equiv.perm α) : Prop",
    "args": "{α : Type u_1} (f g : equiv.perm α)",
    "doc_string": " Two permutations `f` and `g` are `disjoint` if their supports are disjoint, i.e., every element is fixed either by `f`, or by `g`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "fintype.division_ring_of_is_domain",
    "statement": "def fintype.division_ring_of_is_domain (R : Type u_1) [ring R] [is_domain R] [decidable_eq R] [fintype R] : division_ring R",
    "theorem": "(R : Type u_1) [ring R] [is_domain R] [decidable_eq R] [fintype R] : division_ring R",
    "args": "(R : Type u_1) [ring R] [is_domain R] [decidable_eq R] [fintype R]",
    "doc_string": " Every finite domain is a division ring.  TODO: Prove Wedderburn's little theorem, which shows a finite domain is in fact commutative, hence a field.",
    "kind": "def",
    "type": "division_ring R"
  },
  {
    "name": "filter.germ",
    "statement": "def filter.germ {α : Type u_1} (l : filter α) (β : Type u_2) : Type (max u_1 u_2)",
    "theorem": "{α : Type u_1} (l : filter α) (β : Type u_2) : Type (max u_1 u_2)",
    "args": "{α : Type u_1} (l : filter α) (β : Type u_2)",
    "doc_string": "The space of germs of functions `α → β` at a filter `l`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "submonoid.localization_with_zero_map",
    "statement": "structure submonoid.localization_with_zero_map {M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) (N : Type u_2) [comm_monoid_with_zero N] : Type (max u_1 u_2)",
    "theorem": "{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) (N : Type u_2) [comm_monoid_with_zero N] : Type (max u_1 u_2)",
    "args": "{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) (N : Type u_2) [comm_monoid_with_zero N]",
    "doc_string": " The type of homomorphisms between monoids with zero satisfying the characteristic predicate: if `f : M →*₀ N` satisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "free_group.red",
    "statement": "def free_group.red {α : Type u} : list (α × bool) → list (α × bool) → Prop",
    "theorem": "{α : Type u} : list (α × bool) → list (α × bool) → Prop",
    "args": "{α : Type u}",
    "doc_string": "Reflexive-transitive closure of red.step",
    "kind": "def",
    "type": "list (α × bool) → list (α × bool) → Prop"
  },
  {
    "name": "category_theory.subobject.nontrivial_of_not_is_zero",
    "statement": "theorem category_theory.subobject.nontrivial_of_not_is_zero {C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)",
    "theorem": "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)",
    "args": "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬category_theory.limits.is_zero X)",
    "doc_string": "A nonzero object has nontrivial subobject lattice.",
    "kind": "theorem",
    "type": "nontrivial (category_theory.subobject X)"
  },
  {
    "name": "add_submonoid",
    "statement": "structure add_submonoid (M : Type u_4) [add_zero_class M] : Type u_4",
    "theorem": "(M : Type u_4) [add_zero_class M] : Type u_4",
    "args": "(M : Type u_4) [add_zero_class M]",
    "doc_string": "An additive submonoid of an additive monoid `M` is a subset containing 0 and  closed under addition.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "topological_fiber_bundle_core.local_triv",
    "statement": "def topological_fiber_bundle_core.local_triv {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (i : ι) : topological_fiber_bundle.trivialization F Z.proj",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (i : ι) : topological_fiber_bundle.trivialization F Z.proj",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (i : ι)",
    "doc_string": " Extended version of the local trivialization of a fiber bundle constructed from core, registering additionally in its type that it is a local bundle trivialization.",
    "kind": "def",
    "type": "topological_fiber_bundle.trivialization F Z.proj"
  },
  {
    "name": "subgroup.pointwise_mul_action",
    "statement": "def subgroup.pointwise_mul_action {α : Type u_1} {G : Type u_2} [group G] [monoid α] [mul_distrib_mul_action α G] : mul_action α (subgroup G)",
    "theorem": "{α : Type u_1} {G : Type u_2} [group G] [monoid α] [mul_distrib_mul_action α G] : mul_action α (subgroup G)",
    "args": "{α : Type u_1} {G : Type u_2} [group G] [monoid α] [mul_distrib_mul_action α G]",
    "doc_string": " The action on a subgroup corresponding to applying the action to every element.  This is available as an instance in the `pointwise` locale.",
    "kind": "def",
    "type": "mul_action α (subgroup G)"
  },
  {
    "name": "ordnode.balanced",
    "statement": "def ordnode.balanced {α : Type u_1} : ordnode α → Prop",
    "theorem": "{α : Type u_1} : ordnode α → Prop",
    "args": "{α : Type u_1}",
    "doc_string": " The `balanced t` asserts that the tree `t` satisfies the balance invariants (at every level).",
    "kind": "def",
    "type": "ordnode α → Prop"
  },
  {
    "name": "affine.triangle",
    "statement": "def affine.triangle (k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3",
    "theorem": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3",
    "args": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P]",
    "doc_string": "A `triangle k P` is a collection of three affinely independent points.",
    "kind": "def",
    "type": "Type u_3"
  },
  {
    "name": "int.ceil",
    "statement": "def int.ceil {α : Type u_1} [linear_ordered_ring α] [floor_ring α] : α → ℤ",
    "theorem": "{α : Type u_1} [linear_ordered_ring α] [floor_ring α] : α → ℤ",
    "args": "{α : Type u_1} [linear_ordered_ring α] [floor_ring α]",
    "doc_string": "`int.ceil a` is the smallest integer `z` such that `a ≤ z`. It is denoted with `⌈a⌉`.",
    "kind": "def",
    "type": "α → ℤ"
  },
  {
    "name": "function.eval",
    "statement": "def function.eval {α : Sort u_1} {β : α → Sort u_2} (x : α) (f : Π (x : α), β x) : β x",
    "theorem": "{α : Sort u_1} {β : α → Sort u_2} (x : α) (f : Π (x : α), β x) : β x",
    "args": "{α : Sort u_1} {β : α → Sort u_2} (x : α) (f : Π (x : α), β x)",
    "doc_string": "Evaluate a function at an argument. Useful if you want to talk about the partially applied  `function.eval x : (Π x, β x) → β x`.",
    "kind": "def",
    "type": "β x"
  },
  {
    "name": "wseq.find",
    "statement": "def wseq.find {α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α) : computation (option α)",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α) : computation (option α)",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α)",
    "doc_string": "Get the first element of `s` satisfying `p`.",
    "kind": "def",
    "type": "computation (option α)"
  },
  {
    "name": "int.exists_greatest_of_bdd",
    "statement": "theorem int.exists_greatest_of_bdd {P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub",
    "theorem": "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub",
    "args": "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z)",
    "doc_string": " If `P : ℤ → Prop` is a predicate such that the set `{m : P m}` is bounded above and nonempty, then this set has the greatest element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.greatest_of_bdd` for a constructive counterpart.",
    "kind": "theorem",
    "type": "∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub"
  },
  {
    "name": "polynomial.cyclotomic_zero",
    "statement": "theorem polynomial.cyclotomic_zero (R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1",
    "theorem": "(R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1",
    "args": "(R : Type u_1) [ring R]",
    "doc_string": "The zeroth cyclotomic polyomial is `1`.",
    "kind": "theorem",
    "type": "polynomial.cyclotomic 0 R = 1"
  },
  {
    "name": "list.attach",
    "statement": "def list.attach {α : Type u} (l : list α) : list {x // x ∈ l}",
    "theorem": "{α : Type u} (l : list α) : list {x // x ∈ l}",
    "args": "{α : Type u} (l : list α)",
    "doc_string": "\"Attach\" the proof that the elements of `l` are in `l` to produce a new list  with the same elements but in the type `{x // x ∈ l}`.",
    "kind": "def",
    "type": "list {x // x ∈ l}"
  },
  {
    "name": "subfield.div_mem",
    "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K) {x y : K}",
    "doc_string": "A subfield is closed under division.",
    "kind": "theorem",
    "type": "x ∈ s → y ∈ s → x / y ∈ s"
  },
  {
    "name": "tactic.interactive.instance_tree",
    "statement": "inductive tactic.interactive.instance_tree  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Tree structure representing a `testable` instance.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "is_add_cyclic.add_comm_group",
    "statement": "def is_add_cyclic.add_comm_group {α : Type u} [hg : add_group α] [is_add_cyclic α] : add_comm_group α",
    "theorem": "{α : Type u} [hg : add_group α] [is_add_cyclic α] : add_comm_group α",
    "args": "{α : Type u} [hg : add_group α] [is_add_cyclic α]",
    "doc_string": "A cyclic group is always commutative. This is not an `instance` because often we have   a better proof of `add_comm_group`.",
    "kind": "def",
    "type": "add_comm_group α"
  },
  {
    "name": "div_eq_mul_inv",
    "statement": "theorem div_eq_mul_inv {G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹",
    "theorem": "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹",
    "args": "{G : Type u_1} [div_inv_monoid G] (a b : G)",
    "doc_string": " Dividing by an element is the same as multiplying by its inverse.  This is a duplicate of `div_inv_monoid.div_eq_mul_inv` ensuring that the types unfold better.",
    "kind": "theorem",
    "type": "a / b = a * b⁻¹"
  },
  {
    "name": "multiset.le.subset",
    "statement": "theorem multiset.le.subset {α : Type u_1} {s t : multiset α} : s ≤ t → s ⊆ t",
    "theorem": "{α : Type u_1} {s t : multiset α} : s ≤ t → s ⊆ t",
    "args": "{α : Type u_1} {s t : multiset α}",
    "doc_string": "**Alias** of multiset.subset_of_le`.",
    "kind": "theorem",
    "type": "s ≤ t → s ⊆ t"
  },
  {
    "name": "num.min_fac",
    "statement": "def num.min_fac  : num → pos_num",
    "theorem": " : num → pos_num",
    "args": "",
    "doc_string": "Returns the smallest prime factor of `n ≠ 1`.",
    "kind": "def",
    "type": "num → pos_num"
  },
  {
    "name": "module.is_torsion_by",
    "statement": "def module.is_torsion_by (R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : Prop",
    "theorem": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R) : Prop",
    "args": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (a : R)",
    "doc_string": "A `a`-torsion module is a module where every element is `a`-torsion.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_zero_object_of_has_terminal_object",
    "statement": "theorem category_theory.limits.has_zero_object_of_has_terminal_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C]",
    "doc_string": "If there are zero morphisms, any terminal object is a zero object.",
    "kind": "theorem",
    "type": "category_theory.limits.has_zero_object C"
  },
  {
    "name": "tendsto_pow_neg_at_top",
    "statement": "theorem tendsto_pow_neg_at_top {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ -↑n) filter.at_top (nhds 0)",
    "theorem": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ -↑n) filter.at_top (nhds 0)",
    "args": "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n)",
    "doc_string": " The function `x^(-n)` tends to `0` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_neg_at_top`.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (x : α), x ^ -↑n) filter.at_top (nhds 0)"
  },
  {
    "name": "category_theory.limits.has_initial",
    "statement": "def category_theory.limits.has_initial (C : Type u₁) [category_theory.category C] : Prop",
    "theorem": "(C : Type u₁) [category_theory.category C] : Prop",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": "A category has an initial object if it has a colimit over the empty diagram. Use `has_initial_of_unique` to construct instances.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.as_small",
    "statement": "def category_theory.as_small (C : Type u) [category_theory.category C] : Type (max u w v)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u w v)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`as_small C` is a small category equivalent to `C`.  More specifically, if `C : Type u` is endowed with `category.{v} C`, then  `as_small.{w} C : Type (max w v u)` is endowed with an instance of a small category.   The objects and morphisms of `as_small C` are defined by applying `ulift` to the  objects and morphisms of `C`.   Note: We require a category instance for this definition in order to have direct  access to the universe level `v`.",
    "kind": "def",
    "type": "Type (max u w v)"
  },
  {
    "name": "not_is_left_regular_zero",
    "statement": "theorem not_is_left_regular_zero {R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_left_regular 0",
    "theorem": "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_left_regular 0",
    "args": "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R]",
    "doc_string": "In a non-trivial ring, the element `0` is not left-regular -- with typeclasses.",
    "kind": "theorem",
    "type": "¬is_left_regular 0"
  },
  {
    "name": "list.sublists_len",
    "statement": "def list.sublists_len {α : Type u_1} (n : ℕ) (l : list α) : list (list α)",
    "theorem": "{α : Type u_1} (n : ℕ) (l : list α) : list (list α)",
    "args": "{α : Type u_1} (n : ℕ) (l : list α)",
    "doc_string": " The list of all sublists of a list `l` that are of length `n`. For instance, for `l = [0, 1, 2, 3]` and `n = 2`, one gets `[[2, 3], [1, 3], [1, 2], [0, 3], [0, 2], [0, 1]]`.",
    "kind": "def",
    "type": "list (list α)"
  },
  {
    "name": "ordnode.equiv",
    "statement": "def ordnode.equiv {α : Type u} (t₁ t₂ : ordnode α) : Prop",
    "theorem": "{α : Type u} (t₁ t₂ : ordnode α) : Prop",
    "args": "{α : Type u} (t₁ t₂ : ordnode α)",
    "doc_string": "O(n). True if the trees have the same elements, ignoring structural differences.      equiv {1, 2, 4} {2, 1, 1, 4} = true     equiv {1, 2, 4} {1, 2, 3} = false",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subgroup.is_complement'",
    "statement": "def subgroup.is_complement' {G : Type u_1} [group G] (H K : subgroup G) : Prop",
    "theorem": "{G : Type u_1} [group G] (H K : subgroup G) : Prop",
    "args": "{G : Type u_1} [group G] (H K : subgroup G)",
    "doc_string": "`H` and `K` are complements if `(*) : H × K → G` is a bijection",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.update_with",
    "statement": "def ordnode.update_with {α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → option α) (x : α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → option α) (x : α) : ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (f : α → option α) (x : α)",
    "doc_string": " O(log n). Modify an element in the set with the given function, doing nothing if the key is not found. Note that the element returned by `f` must be equivalent to `x`.      update_with f 0 {1, 2, 3} = {1, 2, 3}     update_with f 1 {1, 2, 3} = {2, 3}     if f 1 = none                               = {a, 2, 3}  if f 1 = some a",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "urysohns.CU.right",
    "statement": "def urysohns.CU.right {X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X",
    "theorem": "{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X) : urysohns.CU X",
    "args": "{X : Type u_1} [topological_space X] [normal_space X] (c : urysohns.CU X)",
    "doc_string": " Due to `normal_exists_closure_subset`, for each `c : CU X` there exists an open set `u` such chat `c.C ⊆ u` and `closure u ⊆ c.U`. `c.right` is the pair `(closure u, c.U)`.",
    "kind": "def",
    "type": "urysohns.CU X"
  },
  {
    "name": "category_theory.Aut",
    "statement": "def category_theory.Aut {C : Type u} [category_theory.category C] (X : C) : Type v",
    "theorem": "{C : Type u} [category_theory.category C] (X : C) : Type v",
    "args": "{C : Type u} [category_theory.category C] (X : C)",
    "doc_string": "Automorphisms of an object in a category.  The order of arguments in multiplication agrees with `function.comp`, not with `category.comp`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "category_theory.sieve.inter",
    "statement": "def category_theory.sieve.inter {C : Type u₁} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X",
    "theorem": "{C : Type u₁} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X",
    "args": "{C : Type u₁} [category_theory.category C] {X : C} (S R : category_theory.sieve X)",
    "doc_string": "The intersection of two sieves is a sieve.",
    "kind": "def",
    "type": "category_theory.sieve X"
  },
  {
    "name": "seq.to_lazy_list",
    "statement": "def seq.to_lazy_list {α : Type u} : seq α → lazy_list α",
    "theorem": "{α : Type u} : seq α → lazy_list α",
    "args": "{α : Type u}",
    "doc_string": "Translate a sequence into a `lazy_list`. Since `lazy_list` and `list`  are isomorphic as non-meta types, this function is necessarily meta.",
    "kind": "def",
    "type": "seq α → lazy_list α"
  },
  {
    "name": "generalized_continued_fraction",
    "statement": "structure generalized_continued_fraction (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A *generalised continued fraction* (gcf) is a potentially infinite expression of the form                                  a₀                 h + ---------------------------                                   a₁                       b₀ + --------------------                                     a₂                             b₁ + --------------                                         a₃                                   b₂ + --------                                       b₃ + ...  where `h` is called the *head term* or *integer part*, the `aᵢ` are called the *partial numerators* and the `bᵢ` the *partial denominators* of the gcf. We store the sequence of partial numerators and denominators in a sequence of generalized_continued_fraction.pairs `s`. For convenience, one often writes `[h; (a₀, b₀), (a₁, b₁), (a₂, b₂),...]`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "subgroup.multiset_prod_mem",
    "statement": "theorem subgroup.multiset_prod_mem {G : Type u_1} [comm_group G] (K : subgroup G) (g : multiset G) : (∀ (a : G), a ∈ g → a ∈ K) → g.prod ∈ K",
    "theorem": "{G : Type u_1} [comm_group G] (K : subgroup G) (g : multiset G) : (∀ (a : G), a ∈ g → a ∈ K) → g.prod ∈ K",
    "args": "{G : Type u_1} [comm_group G] (K : subgroup G) (g : multiset G)",
    "doc_string": "Product of a multiset of elements in a subgroup of a `comm_group` is in the subgroup.",
    "kind": "theorem",
    "type": "(∀ (a : G), a ∈ g → a ∈ K) → g.prod ∈ K"
  },
  {
    "name": "category_theory.limits.coproducts_disjoint",
    "statement": "structure category_theory.limits.coproducts_disjoint (C : Type u) [category_theory.category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`C` has disjoint coproducts if every coproduct is disjoint.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "filter.generate",
    "statement": "def filter.generate {α : Type u} (g : set (set α)) : filter α",
    "theorem": "{α : Type u} (g : set (set α)) : filter α",
    "args": "{α : Type u} (g : set (set α))",
    "doc_string": "`generate g` is the largest filter containing the sets `g`.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "FinVect.of",
    "statement": "def FinVect.of (K : Type u) [field K] (V : Type u) [add_comm_group V] [module K V] [finite_dimensional K V] : FinVect K",
    "theorem": "(K : Type u) [field K] (V : Type u) [add_comm_group V] [module K V] [finite_dimensional K V] : FinVect K",
    "args": "(K : Type u) [field K] (V : Type u) [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": "Lift an unbundled vector space to `FinVect K`.",
    "kind": "def",
    "type": "FinVect K"
  },
  {
    "name": "free_semigroup.lift",
    "statement": "def free_semigroup.lift {α : Type u} {β : Type v} [semigroup β] (f : α → β) (x : free_semigroup α) : β",
    "theorem": "{α : Type u} {β : Type v} [semigroup β] (f : α → β) (x : free_semigroup α) : β",
    "args": "{α : Type u} {β : Type v} [semigroup β] (f : α → β) (x : free_semigroup α)",
    "doc_string": " Lifts a function `α → β` to a semigroup homomorphism `free_semigroup α → β` given a semigroup `β`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "has_vsub",
    "statement": "structure has_vsub (G : out_param (Type u_1)) (P : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(G : out_param (Type u_1)) (P : Type u_2) : Type (max u_1 u_2)",
    "args": "(G : out_param (Type u_1)) (P : Type u_2)",
    "doc_string": "Type class for the `-ᵥ` notation.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "local_equiv.is_image",
    "statement": "def local_equiv.is_image {α : Type u_1} {β : Type u_2} (e : local_equiv α β) (s : set α) (t : set β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (e : local_equiv α β) (s : set α) (t : set β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} (e : local_equiv α β) (s : set α) (t : set β)",
    "doc_string": " We say that `t : set β` is an image of `s : set α` under a local equivalence if any of the following equivalent conditions hold:  * `e '' (e.source ∩ s) = e.target ∩ t`; * `e.source ∩ e ⁻¹ t = e.source ∩ s`; * `∀ x ∈ e.source, e x ∈ t ↔ x ∈ s` (this one is used in the definition).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "padic_val_nat.pow",
    "statement": "theorem padic_val_nat.pow (p q n : ℕ) [fact (nat.prime p)] (hq : q ≠ 0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q",
    "theorem": "(p q n : ℕ) [fact (nat.prime p)] (hq : q ≠ 0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q",
    "args": "(p q n : ℕ) [fact (nat.prime p)] (hq : q ≠ 0)",
    "doc_string": "A version of `padic_val_rat.pow` for `padic_val_nat`",
    "kind": "theorem",
    "type": "padic_val_nat p (q ^ n) = n * padic_val_nat p q"
  },
  {
    "name": "setoid.partition.partial_order",
    "statement": "def setoid.partition.partial_order {α : Type u_1} : partial_order (subtype setoid.is_partition)",
    "theorem": "{α : Type u_1} : partial_order (subtype setoid.is_partition)",
    "args": "{α : Type u_1}",
    "doc_string": "Defining a partial order on partitions as the partial order on their induced    equivalence relations.",
    "kind": "def",
    "type": "partial_order (subtype setoid.is_partition)"
  },
  {
    "name": "add_units.mk_of_add_eq_zero",
    "statement": "def add_units.mk_of_add_eq_zero {α : Type u} [add_comm_monoid α] (a b : α) (hab : a + b = 0) : add_units α",
    "theorem": "{α : Type u} [add_comm_monoid α] (a b : α) (hab : a + b = 0) : add_units α",
    "args": "{α : Type u} [add_comm_monoid α] (a b : α) (hab : a + b = 0)",
    "doc_string": "For `a, b` in an `add_comm_monoid` such that `a + b = 0`, makes an add_unit out of `a`.",
    "kind": "def",
    "type": "add_units α"
  },
  {
    "name": "upper_semicontinuous_within_at",
    "statement": "def upper_semicontinuous_within_at {α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) (x : α) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) (x : α) : Prop",
    "args": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) (x : α)",
    "doc_string": " A real function `f` is upper semicontinuous at `x` within a set `s` if, for any `ε > 0`, for all `x'` close enough to `x` in  `s`, then `f x'` is at most `f x + ε`. We formulate this in a general preordered space, using an arbitrary `y > f x` instead of `f x + ε`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "compare_reals.Bourbakiℝ",
    "statement": "def compare_reals.Bourbakiℝ  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Real numbers constructed as in Bourbaki.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "omega.int.preterm",
    "statement": "inductive omega.int.preterm  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Similar to `exprterm`, except that all exprs are now replaced with de Brujin indices of type `nat`. This is akin to generalizing over the terms represented by the said exprs.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "tendsto_locally_uniformly_on",
    "statement": "def tendsto_locally_uniformly_on {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] [topological_space α] (F : ι → α → β) (f : α → β) (p : filter ι) (s : set α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] [topological_space α] (F : ι → α → β) (f : α → β) (p : filter ι) (s : set α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] [topological_space α] (F : ι → α → β) (f : α → β) (p : filter ι) (s : set α)",
    "doc_string": " A sequence of functions `Fₙ` converges locally uniformly on a set `s` to a limiting function `f` with respect to a filter `p` if, for any entourage of the diagonal `u`, for any `x ∈ s`, one has `p`-eventually `(f y, Fₙ y) ∈ u` for all `y` in a neighborhood of `x` in `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.head'",
    "statement": "def list.head' {α : Type u_1} : list α → option α",
    "theorem": "{α : Type u_1} : list α → option α",
    "args": "{α : Type u_1}",
    "doc_string": " `head' xs` returns the first element of `xs` if `xs` is non-empty; it returns `none` otherwise",
    "kind": "def",
    "type": "list α → option α"
  },
  {
    "name": "spectrum",
    "statement": "def spectrum (R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R",
    "theorem": "(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A) : set R",
    "args": "(R : Type u) {A : Type v} [comm_semiring R] [ring A] [algebra R A] (a : A)",
    "doc_string": " Given a commutative ring `R` and an `R`-algebra `A`, the *spectrum* of `a : A` is the `set R` consisting of those `r : R` for which `r•1 - a` is not a unit of the algebra `A`.  The spectrum is simply the complement of the resolvent set.",
    "kind": "def",
    "type": "set R"
  },
  {
    "name": "borel_space",
    "statement": "structure borel_space (α : Type u_6) [topological_space α] [measurable_space α] : Prop",
    "theorem": "(α : Type u_6) [topological_space α] [measurable_space α] : Prop",
    "args": "(α : Type u_6) [topological_space α] [measurable_space α]",
    "doc_string": " A space with `measurable_space` and `topological_space` structures such that the `σ`-algebra of measurable sets is exactly the `σ`-algebra generated by open sets.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "traversable.to_list",
    "statement": "def traversable.to_list {α : Type u} {t : Type u → Type u} [traversable t] : t α → list α",
    "theorem": "{α : Type u} {t : Type u → Type u} [traversable t] : t α → list α",
    "args": "{α : Type u} {t : Type u → Type u} [traversable t]",
    "doc_string": "Conceptually, `to_list` collects all the elements of a collection in a list. This idea is formalized by    `lemma to_list_spec (x : t α) : to_list x = fold_map free_monoid.mk x`.  The definition of `to_list` is based on `foldl` and `list.cons` for speed. It is faster than using `fold_map free_monoid.mk` because, by using `foldl` and `list.cons`, each insertion is done in constant time. As a consequence, `to_list` performs in linear.  On the other hand, `fold_map free_monoid.mk` creates a singleton list around each element and concatenates all the resulting lists. In `xs ++ ys`, concatenation takes a time proportional to `length xs`. Since the order in which concatenation is evaluated is unspecified, nothing prevents each element of the traversable to be appended at the end `xs ++ [x]` which would yield a `O(n²)` run time.",
    "kind": "def",
    "type": "t α → list α"
  },
  {
    "name": "add_comm_monoid",
    "statement": "structure add_comm_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": "An additive commutative monoid is an additive monoid with commutative `(+)`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "metric.Hausdorff_dist_comm",
    "statement": "theorem metric.Hausdorff_dist_comm {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α}",
    "doc_string": "The Hausdorff distance from `s` to `t` and from `t` to `s` coincide",
    "kind": "theorem",
    "type": "metric.Hausdorff_dist s t = metric.Hausdorff_dist t s"
  },
  {
    "name": "fractional_ideal.submodule.has_coe",
    "statement": "def fractional_ideal.submodule.has_coe {R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe (fractional_ideal S P) (submodule R P)",
    "theorem": "{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe (fractional_ideal S P) (submodule R P)",
    "args": "{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P]",
    "doc_string": " Map a fractional ideal `I` to a submodule by forgetting that `∃ a, a I ⊆ R`.  This coercion is typically called `coe_to_submodule` in lemma names (or `coe` when the coercion is clear from the context), not to be confused with `is_localization.coe_submodule : ideal R → submodule R P` (which we use to define `coe : ideal R → fractional_ideal S P`, referred to as `coe_ideal` in theorem names).",
    "kind": "def",
    "type": "has_coe (fractional_ideal S P) (submodule R P)"
  },
  {
    "name": "algebraic_geometry.is_integral",
    "statement": "structure algebraic_geometry.is_integral (X : algebraic_geometry.Scheme) : Prop",
    "theorem": "(X : algebraic_geometry.Scheme) : Prop",
    "args": "(X : algebraic_geometry.Scheme)",
    "doc_string": " A scheme `X` is integral if its carrier is nonempty, and `𝒪ₓ(U)` is an integral domain for each `U ≠ ∅`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "pi.const_add_hom",
    "statement": "def pi.const_add_hom (α : Type u_1) (β : Type u_2) [has_add β] : add_hom β (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [has_add β] : add_hom β (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [has_add β]",
    "doc_string": "`function.const` as an `add_hom`.",
    "kind": "def",
    "type": "add_hom β (α → β)"
  },
  {
    "name": "add_group_topology.has_Inf",
    "statement": "def add_group_topology.has_Inf {α : Type u} [add_group α] : has_Inf (add_group_topology α)",
    "theorem": "{α : Type u} [add_group α] : has_Inf (add_group_topology α)",
    "args": "{α : Type u} [add_group α]",
    "doc_string": "Infimum of a collection of additive group topologies",
    "kind": "def",
    "type": "has_Inf (add_group_topology α)"
  },
  {
    "name": "mvpfunctor.drop",
    "statement": "def mvpfunctor.drop {n : ℕ} (P : mvpfunctor (n + 1)) : mvpfunctor n",
    "theorem": "{n : ℕ} (P : mvpfunctor (n + 1)) : mvpfunctor n",
    "args": "{n : ℕ} (P : mvpfunctor (n + 1))",
    "doc_string": " Split polynomial functor, get a n-ary functor from a `n+1`-ary functor",
    "kind": "def",
    "type": "mvpfunctor n"
  },
  {
    "name": "linear_recurrence.is_solution",
    "statement": "def linear_recurrence.is_solution {α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (u : ℕ → α) : Prop",
    "theorem": "{α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (u : ℕ → α) : Prop",
    "args": "{α : Type u_1} [comm_semiring α] (E : linear_recurrence α) (u : ℕ → α)",
    "doc_string": "We say that a sequence `u` is solution of `linear_recurrence order coeffs` when we have  `u (n + order) = ∑ i : fin order, coeffs i * u (n + i)` for any `n`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "fdRep",
    "statement": "def fdRep (k G : Type u) [field k] [monoid G] : Type (u+1)",
    "theorem": "(k G : Type u) [field k] [monoid G] : Type (u+1)",
    "args": "(k G : Type u) [field k] [monoid G]",
    "doc_string": "The category of finite dimensional `k`-linear representations of a monoid `G`.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "add_action.orbit",
    "statement": "def add_action.orbit (α : Type u) {β : Type v} [add_monoid α] [add_action α β] (b : β) : set β",
    "theorem": "(α : Type u) {β : Type v} [add_monoid α] [add_action α β] (b : β) : set β",
    "args": "(α : Type u) {β : Type v} [add_monoid α] [add_action α β] (b : β)",
    "doc_string": "The orbit of an element under an action.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "zmod.ring_char_zmod_n",
    "statement": "theorem zmod.ring_char_zmod_n (n : ℕ) : ring_char (zmod n) = n",
    "theorem": "(n : ℕ) : ring_char (zmod n) = n",
    "args": "(n : ℕ)",
    "doc_string": "We have that `ring_char (zmod n) = n`.",
    "kind": "theorem",
    "type": "ring_char (zmod n) = n"
  },
  {
    "name": "quadratic_form.polar",
    "statement": "def quadratic_form.polar {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] (f : M → R) (x y : M) : R",
    "theorem": "{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] (f : M → R) (x y : M) : R",
    "args": "{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] (f : M → R) (x y : M)",
    "doc_string": " Up to a factor 2, `Q.polar` is the associated bilinear form for a quadratic form `Q`.d  Source of this name: https://en.wikipedia.org/wiki/Quadratic_form#Generalization",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "is_noetherian_of_subsingleton",
    "statement": "def is_noetherian_of_subsingleton (R : Type u_1) (M : Type u_2) [subsingleton R] [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M",
    "theorem": "(R : Type u_1) (M : Type u_2) [subsingleton R] [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M",
    "args": "(R : Type u_1) (M : Type u_2) [subsingleton R] [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "Modules over the trivial ring are Noetherian.",
    "kind": "def",
    "type": "is_noetherian R M"
  },
  {
    "name": "measurable_space.map",
    "statement": "def measurable_space.map {α : Type u_1} {β : Type u_2} (f : α → β) (m : measurable_space α) : measurable_space β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (m : measurable_space α) : measurable_space β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (m : measurable_space α)",
    "doc_string": "The forward image of a measurable space under a function. `map f m` contains the sets  `s : set β` whose preimage under `f` is measurable.",
    "kind": "def",
    "type": "measurable_space β"
  },
  {
    "name": "is_fraction_ring.char_p",
    "statement": "def is_fraction_ring.char_p (R : Type u_1) [comm_ring R] (p : ℕ) [is_domain R] [char_p R p] : char_p (fraction_ring R) p",
    "theorem": "(R : Type u_1) [comm_ring R] (p : ℕ) [is_domain R] [char_p R p] : char_p (fraction_ring R) p",
    "args": "(R : Type u_1) [comm_ring R] (p : ℕ) [is_domain R] [char_p R p]",
    "doc_string": "If `R` has characteristic `p`, then so does `fraction_ring R`.",
    "kind": "def",
    "type": "char_p (fraction_ring R) p"
  },
  {
    "name": "nat.fast_fib_aux",
    "statement": "def nat.fast_fib_aux  : ℕ → ℕ × ℕ",
    "theorem": " : ℕ → ℕ × ℕ",
    "args": "",
    "doc_string": " Computes `(nat.fib n, nat.fib (n + 1))` using the binary representation of `n`. Supports `nat.fast_fib`.",
    "kind": "def",
    "type": "ℕ → ℕ × ℕ"
  },
  {
    "name": "relation.refl_trans_gen",
    "statement": "inductive relation.refl_trans_gen {α : Type u_1} (r : α → α → Prop) (a : α) : α → Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (a : α) : α → Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (a : α)",
    "doc_string": "`refl_trans_gen r`: reflexive transitive closure of `r`",
    "kind": "inductive",
    "type": "α → Prop"
  },
  {
    "name": "pfunctor.W.children",
    "statement": "def pfunctor.W.children {P : pfunctor} (x : P.W) : P.B x.head → P.W",
    "theorem": "{P : pfunctor} (x : P.W) : P.B x.head → P.W",
    "args": "{P : pfunctor} (x : P.W)",
    "doc_string": "children of the root of a W tree",
    "kind": "def",
    "type": "P.B x.head → P.W"
  },
  {
    "name": "category_theory.limits.split_epi_prod_snd",
    "statement": "def category_theory.limits.split_epi_prod_snd {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.snd",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.snd",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)]",
    "doc_string": "In the presence of zero morphisms, projections into a product are (split) epimorphisms.",
    "kind": "def",
    "type": "category_theory.split_epi category_theory.limits.prod.snd"
  },
  {
    "name": "ordnode.rotate_r",
    "statement": "def ordnode.rotate_r {α : Type u_1} : ordnode α → α → ordnode α → ordnode α",
    "theorem": "{α : Type u_1} : ordnode α → α → ordnode α → ordnode α",
    "args": "{α : Type u_1}",
    "doc_string": " Concatenate two nodes, performing a right rotation `(x y) z -> (x (y z))` if balance is upset.",
    "kind": "def",
    "type": "ordnode α → α → ordnode α → ordnode α"
  },
  {
    "name": "complex_shape",
    "statement": "structure complex_shape (ι : Type u_1) : Type u_1",
    "theorem": "(ι : Type u_1) : Type u_1",
    "args": "(ι : Type u_1)",
    "doc_string": "A `c : complex_shape ι` describes the shape of a chain complex, with chain groups indexed by `ι`. Typically `ι` will be `ℕ`, `ℤ`, or `fin n`.  There is a relation `rel : ι → ι → Prop`, and we will only allow a non-zero differential from `i` to `j` when `rel i j`.  There are axioms which imply `{ j // c.rel i j }` and `{ i // c.rel i j }` are subsingletons. This means that the shape consists of some union of lines, rays, intervals, and circles.  Below we define `c.next` and `c.prev` which provide, as an `option`, these related elements.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "localization.npow",
    "statement": "def localization.npow {M : Type u_1} [comm_monoid M] (S : submonoid M) : ℕ → localization S → localization S",
    "theorem": "{M : Type u_1} [comm_monoid M] (S : submonoid M) : ℕ → localization S → localization S",
    "args": "{M : Type u_1} [comm_monoid M] (S : submonoid M)",
    "doc_string": " Exponentiation in a localization is defined as `⟨a, b⟩ ^ n = ⟨a ^ n, b ^ n⟩`.  This is a separate `irreducible` def to ensure the elaborator doesn't waste its time trying to unify some huge recursive definition with itself, but unfolded one step less.",
    "kind": "def",
    "type": "ℕ → localization S → localization S"
  },
  {
    "name": "subfield.to_subring",
    "statement": "def subfield.to_subring {K : Type u} [field K] (self : subfield K) : subring K",
    "theorem": "{K : Type u} [field K] (self : subfield K) : subring K",
    "args": "{K : Type u} [field K] (self : subfield K)",
    "doc_string": "Reinterpret a `subfield` as a `subring`.",
    "kind": "def",
    "type": "subring K"
  },
  {
    "name": "hilbert_basis",
    "statement": "structure hilbert_basis (ι : Type u_1) (𝕜 : Type u_2) [is_R_or_C 𝕜] (E : Type u_3) [inner_product_space 𝕜 E] : Type (max u_1 u_2 u_3)",
    "theorem": "(ι : Type u_1) (𝕜 : Type u_2) [is_R_or_C 𝕜] (E : Type u_3) [inner_product_space 𝕜 E] : Type (max u_1 u_2 u_3)",
    "args": "(ι : Type u_1) (𝕜 : Type u_2) [is_R_or_C 𝕜] (E : Type u_3) [inner_product_space 𝕜 E]",
    "doc_string": " A Hilbert basis on `ι` for an inner product space `E` is an identification of `E` with the `lp` space `ℓ²(ι, 𝕜)`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "contravariant.to_left_cancel_add_semigroup",
    "statement": "def contravariant.to_left_cancel_add_semigroup {α : Type u_1} [add_semigroup α] [partial_order α] [contravariant_class α α has_add.add has_le.le] : add_left_cancel_semigroup α",
    "theorem": "{α : Type u_1} [add_semigroup α] [partial_order α] [contravariant_class α α has_add.add has_le.le] : add_left_cancel_semigroup α",
    "args": "{α : Type u_1} [add_semigroup α] [partial_order α] [contravariant_class α α has_add.add has_le.le]",
    "doc_string": "An additive semigroup with a partial order and satisfying `left_cancel_add_semigroup` (i.e. `c + a < c + b → a < b`) is a `left_cancel add_semigroup`.",
    "kind": "def",
    "type": "add_left_cancel_semigroup α"
  },
  {
    "name": "lower_set.Iio",
    "statement": "def lower_set.Iio {α : Type u_1} [preorder α] (a : α) : lower_set α",
    "theorem": "{α : Type u_1} [preorder α] (a : α) : lower_set α",
    "args": "{α : Type u_1} [preorder α] (a : α)",
    "doc_string": "Strict principal lower set. `set.Iio` as a lower set.",
    "kind": "def",
    "type": "lower_set α"
  },
  {
    "name": "has_measurable_sup₂",
    "statement": "structure has_measurable_sup₂ (M : Type u_1) [measurable_space M] [has_sup M] : Prop",
    "theorem": "(M : Type u_1) [measurable_space M] [has_sup M] : Prop",
    "args": "(M : Type u_1) [measurable_space M] [has_sup M]",
    "doc_string": " We say that a type `has_measurable_sup₂` if `uncurry (⊔)` is a measurable functions. For a typeclass assuming measurability of `((⊔) c)` and `(⊔ c)` see `has_measurable_sup`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordnode.alter",
    "statement": "def ordnode.alter {α : Type u} [has_le α] [decidable_rel has_le.le] (f : option α → option α) (x : α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (f : option α → option α) (x : α) : ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (f : option α → option α) (x : α)",
    "doc_string": " O(log n). Modify an element in the set with the given function, doing nothing if the key is not found. Note that the element returned by `f` must be equivalent to `x`.      alter f 0 {1, 2, 3} = {1, 2, 3}     if f none = none                         = {a, 1, 2, 3}  if f none = some a     alter f 1 {1, 2, 3} = {2, 3}     if f 1 = none                         = {a, 2, 3}  if f 1 = some a",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "trunc.bind",
    "statement": "def trunc.bind {α : Sort u_1} {β : Sort u_2} (q : trunc α) (f : α → trunc β) : trunc β",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (q : trunc α) (f : α → trunc β) : trunc β",
    "args": "{α : Sort u_1} {β : Sort u_2} (q : trunc α) (f : α → trunc β)",
    "doc_string": "The `bind` operator for the `trunc` monad.",
    "kind": "def",
    "type": "trunc β"
  },
  {
    "name": "fin_std_orthonormal_basis",
    "statement": "def fin_std_orthonormal_basis {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] {n : ℕ} (hn : finite_dimensional.finrank 𝕜 E = n) : basis (fin n) 𝕜 E",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] {n : ℕ} (hn : finite_dimensional.finrank 𝕜 E = n) : basis (fin n) 𝕜 E",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] {n : ℕ} (hn : finite_dimensional.finrank 𝕜 E = n)",
    "doc_string": "An `n`-dimensional `inner_product_space` has an orthonormal basis indexed by `fin n`.",
    "kind": "def",
    "type": "basis (fin n) 𝕜 E"
  },
  {
    "name": "is_complete",
    "statement": "def is_complete {α : Type u} [uniform_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [uniform_space α] (s : set α) : Prop",
    "args": "{α : Type u} [uniform_space α] (s : set α)",
    "doc_string": " A set `s` is called *complete*, if any Cauchy filter `f` such that `s ∈ f` has a limit in `s` (formally, it satisfies `f ≤ 𝓝 x` for some `x ∈ s`).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "preorder",
    "statement": "structure preorder (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A preorder is a reflexive, transitive relation `≤` with `a < b` defined in the obvious way.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "is_integral_closure",
    "statement": "structure is_integral_closure (A : Type u_1) (R : Type u_2) (B : Type u_3) [comm_ring R] [comm_semiring A] [comm_ring B] [algebra R B] [algebra A B] : Prop",
    "theorem": "(A : Type u_1) (R : Type u_2) (B : Type u_3) [comm_ring R] [comm_semiring A] [comm_ring B] [algebra R B] [algebra A B] : Prop",
    "args": "(A : Type u_1) (R : Type u_2) (B : Type u_3) [comm_ring R] [comm_semiring A] [comm_ring B] [algebra R B] [algebra A B]",
    "doc_string": " `is_integral_closure A R B` is the characteristic predicate stating `A` is the integral closure of `R` in `B`, i.e. that an element of `B` is integral over `R` iff it is an element of (the image of) `A`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nat.div_lt_self'",
    "statement": "theorem nat.div_lt_self' (n b : ℕ) : (n + 1) / (b + 2) < n + 1",
    "theorem": "(n b : ℕ) : (n + 1) / (b + 2) < n + 1",
    "args": "(n b : ℕ)",
    "doc_string": "A version of `nat.div_lt_self` using successors, rather than additional hypotheses.",
    "kind": "theorem",
    "type": "(n + 1) / (b + 2) < n + 1"
  },
  {
    "name": "matrix.vec_cons",
    "statement": "def matrix.vec_cons {α : Type u} {n : ℕ} (h : α) (t : fin n → α) : fin n.succ → α",
    "theorem": "{α : Type u} {n : ℕ} (h : α) (t : fin n → α) : fin n.succ → α",
    "args": "{α : Type u} {n : ℕ} (h : α) (t : fin n → α)",
    "doc_string": " `vec_cons h t` prepends an entry `h` to a vector `t`.  The inverse functions are `vec_head` and `vec_tail`. The notation `![a, b, ...]` expands to `vec_cons a (vec_cons b ...)`.",
    "kind": "def",
    "type": "fin n.succ → α"
  },
  {
    "name": "order.ideal.has_inf",
    "statement": "def order.ideal.has_inf {P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_inf (order.ideal P)",
    "theorem": "{P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_inf (order.ideal P)",
    "args": "{P : Type u_1} [semilattice_sup P] [is_directed P ge]",
    "doc_string": "The infimum of two ideals of a co-directed order is their intersection.",
    "kind": "def",
    "type": "has_inf (order.ideal P)"
  },
  {
    "name": "trunc.rec_on_subsingleton",
    "statement": "def trunc.rec_on_subsingleton {α : Sort u_1} {C : trunc α → Sort u_3} [∀ (a : α), subsingleton (C (trunc.mk a))] (q : trunc α) (f : Π (a : α), C (trunc.mk a)) : C q",
    "theorem": "{α : Sort u_1} {C : trunc α → Sort u_3} [∀ (a : α), subsingleton (C (trunc.mk a))] (q : trunc α) (f : Π (a : α), C (trunc.mk a)) : C q",
    "args": "{α : Sort u_1} {C : trunc α → Sort u_3} [∀ (a : α), subsingleton (C (trunc.mk a))] (q : trunc α) (f : Π (a : α), C (trunc.mk a))",
    "doc_string": "A version of `trunc.rec_on` assuming the codomain is a `subsingleton`.",
    "kind": "def",
    "type": "C q"
  },
  {
    "name": "antilipschitz_with.subsingleton",
    "statement": "theorem antilipschitz_with.subsingleton {α : Type u_1} {β : Type u_2} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (h : antilipschitz_with 0 f) : subsingleton α",
    "theorem": "{α : Type u_1} {β : Type u_2} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (h : antilipschitz_with 0 f) : subsingleton α",
    "args": "{α : Type u_1} {β : Type u_2} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (h : antilipschitz_with 0 f)",
    "doc_string": "If `f : α → β` is `0`-antilipschitz, then `α` is a `subsingleton`.",
    "kind": "theorem",
    "type": "subsingleton α"
  },
  {
    "name": "mul_is_right_regular_iff",
    "statement": "theorem mul_is_right_regular_iff {R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) ↔ is_right_regular b",
    "theorem": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) ↔ is_right_regular b",
    "args": "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a)",
    "doc_string": "  An element is right-regular if and only if multiplying it on the right with a right-regular element is right-regular.",
    "kind": "theorem",
    "type": "is_right_regular (b * a) ↔ is_right_regular b"
  },
  {
    "name": "group_topology.partial_order",
    "statement": "def group_topology.partial_order {α : Type u} [group α] : partial_order (group_topology α)",
    "theorem": "{α : Type u} [group α] : partial_order (group_topology α)",
    "args": "{α : Type u} [group α]",
    "doc_string": "The ordering on group topologies on the group `γ`.  `t ≤ s` if every set open in `s` is also open in `t` (`t` is finer than `s`).",
    "kind": "def",
    "type": "partial_order (group_topology α)"
  },
  {
    "name": "category_theory.monoidal_of_has_finite_coproducts",
    "statement": "def category_theory.monoidal_of_has_finite_coproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_binary_coproducts C] : category_theory.monoidal_category C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_binary_coproducts C] : category_theory.monoidal_category C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_binary_coproducts C]",
    "doc_string": "A category with an initial object and binary coproducts has a natural monoidal structure.",
    "kind": "def",
    "type": "category_theory.monoidal_category C"
  },
  {
    "name": "multiset.lists",
    "statement": "def multiset.lists {α : Type u_1} [decidable_eq α] : multiset α → finset (list α)",
    "theorem": "{α : Type u_1} [decidable_eq α] : multiset α → finset (list α)",
    "args": "{α : Type u_1} [decidable_eq α]",
    "doc_string": "The `finset` of `l : list α` that, given `m : multiset α`, have the property `⟦l⟧ = m`.",
    "kind": "def",
    "type": "multiset α → finset (list α)"
  },
  {
    "name": "subsemigroup.copy",
    "statement": "def subsemigroup.copy {M : Type u_1} [has_mul M] (S : subsemigroup M) (s : set M) (hs : s = ↑S) : subsemigroup M",
    "theorem": "{M : Type u_1} [has_mul M] (S : subsemigroup M) (s : set M) (hs : s = ↑S) : subsemigroup M",
    "args": "{M : Type u_1} [has_mul M] (S : subsemigroup M) (s : set M) (hs : s = ↑S)",
    "doc_string": "Copy a subsemigroup replacing `carrier` with a set that is equal to it.",
    "kind": "def",
    "type": "subsemigroup M"
  },
  {
    "name": "category_theory.limits.has_pushouts",
    "statement": "def category_theory.limits.has_pushouts (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_pushouts` represents a choice of pushout for every pair of morphisms",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "continuous_add_monoid_hom.inl",
    "statement": "def continuous_add_monoid_hom.inl (A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A (A × B)",
    "theorem": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom A (A × B)",
    "args": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by inclusion of the first factor.",
    "kind": "def",
    "type": "continuous_add_monoid_hom A (A × B)"
  },
  {
    "name": "compact_Icc_space",
    "statement": "structure compact_Icc_space (α : Type u_1) [topological_space α] [preorder α] : Prop",
    "theorem": "(α : Type u_1) [topological_space α] [preorder α] : Prop",
    "args": "(α : Type u_1) [topological_space α] [preorder α]",
    "doc_string": " This typeclass says that all closed intervals in `α` are compact. This is true for all conditionally complete linear orders with order topology and products (finite or infinite) of such spaces.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "triv_sq_zero_ext.inl",
    "statement": "def triv_sq_zero_ext.inl {R : Type u} {M : Type v} [has_zero M] (r : R) : triv_sq_zero_ext R M",
    "theorem": "{R : Type u} {M : Type v} [has_zero M] (r : R) : triv_sq_zero_ext R M",
    "args": "{R : Type u} {M : Type v} [has_zero M] (r : R)",
    "doc_string": "The canonical inclusion `R → triv_sq_zero_ext R M`.",
    "kind": "def",
    "type": "triv_sq_zero_ext R M"
  },
  {
    "name": "polynomial.content",
    "statement": "def polynomial.content {R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : R",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R) : R",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R] [normalized_gcd_monoid R] (p : polynomial R)",
    "doc_string": "`p.content` is the `gcd` of the coefficients of `p`.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "order.pred_lt_of_not_is_min",
    "statement": "theorem order.pred_lt_of_not_is_min {α : Type u_1} [preorder α] [pred_order α] {a : α} : ¬is_min a → order.pred a < a",
    "theorem": "{α : Type u_1} [preorder α] [pred_order α] {a : α} : ¬is_min a → order.pred a < a",
    "args": "{α : Type u_1} [preorder α] [pred_order α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of order.pred_lt_iff_not_is_min`.",
    "kind": "theorem",
    "type": "¬is_min a → order.pred a < a"
  },
  {
    "name": "subsemiring.to_submonoid",
    "statement": "def subsemiring.to_submonoid {R : Type u} [non_assoc_semiring R] (self : subsemiring R) : submonoid R",
    "theorem": "{R : Type u} [non_assoc_semiring R] (self : subsemiring R) : submonoid R",
    "args": "{R : Type u} [non_assoc_semiring R] (self : subsemiring R)",
    "doc_string": "Reinterpret a `subsemiring` as a `submonoid`.",
    "kind": "def",
    "type": "submonoid R"
  },
  {
    "name": "first_order.language.countable",
    "statement": "structure first_order.language.countable (L : first_order.language) : Prop",
    "theorem": "(L : first_order.language) : Prop",
    "args": "(L : first_order.language)",
    "doc_string": "A language is countable when it has countably many symbols.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "finset.has_vadd",
    "statement": "def finset.has_vadd {α : Type u_2} {β : Type u_3} [decidable_eq β] [has_vadd α β] : has_vadd (finset α) (finset β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [decidable_eq β] [has_vadd α β] : has_vadd (finset α) (finset β)",
    "args": "{α : Type u_2} {β : Type u_3} [decidable_eq β] [has_vadd α β]",
    "doc_string": "The pointwise sum of two finsets `s` and `t`: `s +ᵥ t = {x +ᵥ y | x ∈ s, y ∈ t}`.",
    "kind": "def",
    "type": "has_vadd (finset α) (finset β)"
  },
  {
    "name": "lie_subalgebra.lie_span",
    "statement": "def lie_subalgebra.lie_span (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (s : set L) : lie_subalgebra R L",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (s : set L) : lie_subalgebra R L",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] (s : set L)",
    "doc_string": "The Lie subalgebra of a Lie algebra `L` generated by a subset `s ⊆ L`.",
    "kind": "def",
    "type": "lie_subalgebra R L"
  },
  {
    "name": "zero_lt.mul_pos_mono_rev",
    "statement": "def zero_lt.mul_pos_mono_rev (X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop",
    "theorem": "(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X] : Prop",
    "args": "(X : Type u_1) [has_mul X] [has_zero X] [has_lt X] [has_le X]",
    "doc_string": "  `zero_lt.mul_pos_mono_rev α` is an abbreviation for `contravariant_class α>0 α (λ x y, y * x) (≤)`, expressing that multiplication by positive elements on the right is reverse monotone.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "emetric.inf_edist_zero_of_mem",
    "statement": "theorem emetric.inf_edist_zero_of_mem {α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : x ∈ s) : emetric.inf_edist x s = 0",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : x ∈ s) : emetric.inf_edist x s = 0",
    "args": "{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : x ∈ s)",
    "doc_string": "If a point `x` belongs to `s`, then its edist to `s` vanishes",
    "kind": "theorem",
    "type": "emetric.inf_edist x s = 0"
  },
  {
    "name": "is_smul_regular.zero_iff_subsingleton",
    "statement": "theorem is_smul_regular.zero_iff_subsingleton {R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 ↔ subsingleton M",
    "theorem": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 ↔ subsingleton M",
    "args": "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M]",
    "doc_string": "The element `0` is `M`-regular if and only if `M` is trivial.",
    "kind": "theorem",
    "type": "is_smul_regular M 0 ↔ subsingleton M"
  },
  {
    "name": "pgame.fuzzy",
    "statement": "def pgame.fuzzy (x y : pgame) : Prop",
    "theorem": "(x y : pgame) : Prop",
    "args": "(x y : pgame)",
    "doc_string": " The fuzzy, confused, or incomparable relation on pre-games.  If `x ∥ 0`, then the first player can always win `x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.subtraction_comm_monoid",
    "statement": "def finset.subtraction_comm_monoid {α : Type u_2} [decidable_eq α] [subtraction_comm_monoid α] : subtraction_comm_monoid (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [subtraction_comm_monoid α] : subtraction_comm_monoid (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [subtraction_comm_monoid α]",
    "doc_string": "`finset α` is a commutative subtraction monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "subtraction_comm_monoid (finset α)"
  },
  {
    "name": "category_theory.sheaf.subcanonical",
    "statement": "def category_theory.sheaf.subcanonical {C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C)",
    "doc_string": "A subcanonical topology is a topology which is smaller than the canonical topology. Equivalently, a topology is subcanonical iff every representable is a sheaf.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.monoidal_single_obj",
    "statement": "def category_theory.monoidal_single_obj (C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] : Sort u_3",
    "theorem": "(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C] : Sort u_3",
    "args": "(C : Type u_1) [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "Promote a monoidal category to a bicategory with a single object. (The objects of the monoidal category become the 1-morphisms, with composition given by tensor product, and the morphisms of the monoidal category become the 2-morphisms.)",
    "kind": "def",
    "type": "Sort u_3"
  },
  {
    "name": "cartan_matrix.E₇",
    "statement": "def cartan_matrix.E₇  : matrix (fin 7) (fin 7) ℤ",
    "theorem": " : matrix (fin 7) (fin 7) ℤ",
    "args": "",
    "doc_string": " The Cartan matrix of type e₇. See [bourbaki1968] plate VI, page 281.  The corresponding Dynkin diagram is: ```lean             o             | o --- o --- o --- o --- o --- o ```",
    "kind": "def",
    "type": "matrix (fin 7) (fin 7) ℤ"
  },
  {
    "name": "order_of_pos_iff",
    "statement": "theorem order_of_pos_iff {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x",
    "theorem": "{G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x",
    "args": "{G : Type u} {x : G} [monoid G]",
    "doc_string": "A group element has finite order iff its order is positive.",
    "kind": "theorem",
    "type": "0 < order_of x ↔ is_of_fin_order x"
  },
  {
    "name": "isometric",
    "statement": "structure isometric (α : Type u_1) (β : Type u_2) [pseudo_emetric_space α] [pseudo_emetric_space β] : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (β : Type u_2) [pseudo_emetric_space α] [pseudo_emetric_space β] : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (β : Type u_2) [pseudo_emetric_space α] [pseudo_emetric_space β]",
    "doc_string": "`α` and `β` are isometric if there is an isometric bijection between them.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "zmod.legendre_sym_sq_one",
    "statement": "theorem zmod.legendre_sym_sq_one (p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a ^ 2 = 1",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a ^ 2 = 1",
    "args": "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0)",
    "doc_string": "The square of the symbol is 1 if `p ∤ a`.",
    "kind": "theorem",
    "type": "zmod.legendre_sym p a ^ 2 = 1"
  },
  {
    "name": "seminorm_family",
    "statement": "def seminorm_family (𝕜 : Type u_1) (E : Type u_2) (ι : Type u_5) [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] : Type (max u_5 u_2)",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) (ι : Type u_5) [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] : Type (max u_5 u_2)",
    "args": "(𝕜 : Type u_1) (E : Type u_2) (ι : Type u_5) [normed_field 𝕜] [add_comm_group E] [module 𝕜 E]",
    "doc_string": "An abbreviation for indexed families of seminorms. This is mainly to allow for dot-notation.",
    "kind": "def",
    "type": "Type (max u_5 u_2)"
  },
  {
    "name": "algebraic_geometry.PresheafedSpace.hom",
    "statement": "structure algebraic_geometry.PresheafedSpace.hom {C : Type u} [category_theory.category C] (X Y : algebraic_geometry.PresheafedSpace C) : Type v",
    "theorem": "{C : Type u} [category_theory.category C] (X Y : algebraic_geometry.PresheafedSpace C) : Type v",
    "args": "{C : Type u} [category_theory.category C] (X Y : algebraic_geometry.PresheafedSpace C)",
    "doc_string": "A morphism between presheafed spaces `X` and `Y` consists of a continuous map    `f` between the underlying topological spaces, and a (notice contravariant!) map    from the presheaf on `Y` to the pushforward of the presheaf on `X` via `f`.",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "widget_override.tactic_view_action",
    "statement": "inductive widget_override.tactic_view_action (γ : Type) : Type",
    "theorem": "(γ : Type) : Type",
    "args": "(γ : Type)",
    "doc_string": "Actions accepted by the `tactic_view_component`.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "cubic.roots",
    "statement": "def cubic.roots {R : Type u_1} [comm_ring R] [is_domain R] (P : cubic R) : multiset R",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] (P : cubic R) : multiset R",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R] (P : cubic R)",
    "doc_string": "The roots of a cubic polynomial.",
    "kind": "def",
    "type": "multiset R"
  },
  {
    "name": "has_lt.lt.trans_le'",
    "statement": "theorem has_lt.lt.trans_le' {α : Type u} [preorder α] {a b c : α} : b < c → a ≤ b → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b < c → a ≤ b → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_lt_of_le'`.",
    "kind": "theorem",
    "type": "b < c → a ≤ b → a < c"
  },
  {
    "name": "is_left_regular.subsingleton",
    "statement": "theorem is_left_regular.subsingleton {R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R] (h : is_left_regular 0)",
    "doc_string": "The element `0` is left-regular if and only if `R` is trivial.",
    "kind": "theorem",
    "type": "subsingleton R"
  },
  {
    "name": "free_product.word.fst_idx",
    "statement": "def free_product.word.fst_idx {ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] (w : free_product.word M) : option ι",
    "theorem": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] (w : free_product.word M) : option ι",
    "args": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] (w : free_product.word M)",
    "doc_string": " `fst_idx w` is `some i` if the first letter of `w` is `⟨i, m⟩` with `m : M i`. If `w` is empty then it's `none`.",
    "kind": "def",
    "type": "option ι"
  },
  {
    "name": "monoid_algebra.finite_type_iff_group_fg",
    "statement": "theorem monoid_algebra.finite_type_iff_group_fg {R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G",
    "theorem": "{R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G",
    "args": "{R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R]",
    "doc_string": "A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type.",
    "kind": "theorem",
    "type": "algebra.finite_type R (monoid_algebra R G) ↔ group.fg G"
  },
  {
    "name": "normalized_gcd_monoid",
    "statement": "structure normalized_gcd_monoid (α : Type u_2) [cancel_comm_monoid_with_zero α] : Type u_2",
    "theorem": "(α : Type u_2) [cancel_comm_monoid_with_zero α] : Type u_2",
    "args": "(α : Type u_2) [cancel_comm_monoid_with_zero α]",
    "doc_string": " Normalized GCD monoid: a `cancel_comm_monoid_with_zero` with normalization and `gcd` (greatest common divisor) and `lcm` (least common multiple) operations. In this setting `gcd` and `lcm` form a bounded lattice on the associated elements where `gcd` is the infimum, `lcm` is the supremum, `1` is bottom, and `0` is top. The type class focuses on `gcd` and we derive the corresponding `lcm` facts from `gcd`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "typevec.prod",
    "statement": "def typevec.prod {n : ℕ} (α β : typevec n) : typevec n",
    "theorem": "{n : ℕ} (α β : typevec n) : typevec n",
    "args": "{n : ℕ} (α β : typevec n)",
    "doc_string": "`prod α β` is the pointwise product of the components of `α` and `β`",
    "kind": "def",
    "type": "typevec n"
  },
  {
    "name": "indexed_partition.quotient",
    "statement": "def indexed_partition.quotient {ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) : Type u_2",
    "theorem": "{ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) : Type u_2",
    "args": "{ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s)",
    "doc_string": "The quotient associated to an indexed partition.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "tsub_eq_zero_of_le",
    "statement": "theorem tsub_eq_zero_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} (h : a ≤ b) : a - b = 0",
    "theorem": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} (h : a ≤ b) : a - b = 0",
    "args": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} (h : a ≤ b)",
    "doc_string": "One direction of `tsub_eq_zero_iff_le`, as a `@[simp]`-lemma.",
    "kind": "theorem",
    "type": "a - b = 0"
  },
  {
    "name": "subgroup.gi",
    "statement": "def subgroup.gi (G : Type u_1) [group G] : galois_insertion subgroup.closure coe",
    "theorem": "(G : Type u_1) [group G] : galois_insertion subgroup.closure coe",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
    "kind": "def",
    "type": "galois_insertion subgroup.closure coe"
  },
  {
    "name": "is_empty",
    "statement": "structure is_empty (α : Sort u_4) : Prop",
    "theorem": "(α : Sort u_4) : Prop",
    "args": "(α : Sort u_4)",
    "doc_string": "`is_empty α` expresses that `α` is empty.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "free_add_semigroup.lift",
    "statement": "def free_add_semigroup.lift {α : Type u} {β : Type v} [add_semigroup β] (f : α → β) (x : free_add_semigroup α) : β",
    "theorem": "{α : Type u} {β : Type v} [add_semigroup β] (f : α → β) (x : free_add_semigroup α) : β",
    "args": "{α : Type u} {β : Type v} [add_semigroup β] (f : α → β) (x : free_add_semigroup α)",
    "doc_string": "Lifts a function `α → β` to an additive semigroup homomorphism `free_add_semigroup α → β` given an additive semigroup `β`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "functor.add_const",
    "statement": "def functor.add_const (α : Type u_1) (β : Type u_2) : Type u_1",
    "theorem": "(α : Type u_1) (β : Type u_2) : Type u_1",
    "args": "(α : Type u_1) (β : Type u_2)",
    "doc_string": " `add_const α` is a synonym for constant functor `const α`, mapping every type to `α`. When `α` has a additive monoid structure, `add_const α` has an `applicative` instance. (If `α` has a multiplicative monoid structure, see `functor.const`.)",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "structomorph",
    "statement": "structure structomorph {H : Type u} [topological_space H] (G : structure_groupoid H) (M : Type u_5) (M' : Type u_6) [topological_space M] [topological_space M'] [charted_space H M] [charted_space H M'] : Type (max u_5 u_6)",
    "theorem": "{H : Type u} [topological_space H] (G : structure_groupoid H) (M : Type u_5) (M' : Type u_6) [topological_space M] [topological_space M'] [charted_space H M] [charted_space H M'] : Type (max u_5 u_6)",
    "args": "{H : Type u} [topological_space H] (G : structure_groupoid H) (M : Type u_5) (M' : Type u_6) [topological_space M] [topological_space M'] [charted_space H M] [charted_space H M']",
    "doc_string": " A `G`-diffeomorphism between two charted spaces is a homeomorphism which, when read in the charts, belongs to `G`. We avoid the word diffeomorph as it is too related to the smooth category, and use structomorph instead.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "category_theory.limits.walking_pair",
    "statement": "inductive category_theory.limits.walking_pair  : Type v",
    "theorem": " : Type v",
    "args": "",
    "doc_string": "The type of objects for the diagram indexing a binary (co)product.",
    "kind": "inductive",
    "type": "Type v"
  },
  {
    "name": "user_attribute_cache_cfg",
    "statement": "structure user_attribute_cache_cfg (cache_ty : Type) : Type",
    "theorem": "(cache_ty : Type) : Type",
    "args": "(cache_ty : Type)",
    "doc_string": " Configuration for a user attribute cache. For example, the `simp` attribute has a cache of type simp_lemmas. - `mk_cache` is a function where you are given all of the declarations tagged with your attribute and you return the new value for the cache.   That is, `mk_cache` makes the object you want to be cached. - `dependencies` is a list of other attributes whose caches need to be computed first.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "is_dedekind_domain_dvr",
    "statement": "structure is_dedekind_domain_dvr (A : Type u_2) [comm_ring A] [is_domain A] : Prop",
    "theorem": "(A : Type u_2) [comm_ring A] [is_domain A] : Prop",
    "args": "(A : Type u_2) [comm_ring A] [is_domain A]",
    "doc_string": "A Dedekind domain is an integral domain that is Noetherian, and the localization at every nonzero prime is a discrete valuation ring.  This is equivalent to `is_dedekind_domain`. TODO: prove the equivalence.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "wseq.append",
    "statement": "def wseq.append {α : Type u} : wseq α → wseq α → wseq α",
    "theorem": "{α : Type u} : wseq α → wseq α → wseq α",
    "args": "{α : Type u}",
    "doc_string": "Append two weak sequences. As with `seq.append`, this may not use  the second sequence if the first one takes forever to compute",
    "kind": "def",
    "type": "wseq α → wseq α → wseq α"
  },
  {
    "name": "infinite",
    "statement": "structure infinite (α : Type u_4) : Prop",
    "theorem": "(α : Type u_4) : Prop",
    "args": "(α : Type u_4)",
    "doc_string": "A type is said to be infinite if it has no fintype instance.  Note that `infinite α` is equivalent to `is_empty (fintype α)`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "vector.update_nth",
    "statement": "def vector.update_nth {n : ℕ} {α : Type u_1} (v : vector α n) (i : fin n) (a : α) : vector α n",
    "theorem": "{n : ℕ} {α : Type u_1} (v : vector α n) (i : fin n) (a : α) : vector α n",
    "args": "{n : ℕ} {α : Type u_1} (v : vector α n) (i : fin n) (a : α)",
    "doc_string": "`update_nth v n a` replaces the `n`th element of `v` with `a`",
    "kind": "def",
    "type": "vector α n"
  },
  {
    "name": "pell.xz",
    "statement": "def pell.xz {a : ℕ} (a1 : 1 < a) (n : ℕ) : ℤ",
    "theorem": "{a : ℕ} (a1 : 1 < a) (n : ℕ) : ℤ",
    "args": "{a : ℕ} (a1 : 1 < a) (n : ℕ)",
    "doc_string": "The Pell `x` sequence, considered as an integer sequence.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "nat.nth",
    "statement": "def nat.nth (p : ℕ → Prop) : ℕ → ℕ",
    "theorem": "(p : ℕ → Prop) : ℕ → ℕ",
    "args": "(p : ℕ → Prop)",
    "doc_string": " Find the `n`-th natural number satisfying `p` (indexed from `0`, so `nth p 0` is the first natural number satisfying `p`), or `0` if there is no such number. See also `subtype.order_iso_of_nat` for the order isomorphism with ℕ when `p` is infinitely often true.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "category_theory.limits.biprod",
    "statement": "def category_theory.limits.biprod {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y] : C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X Y : C) [category_theory.limits.has_binary_biproduct X Y]",
    "doc_string": "An arbitrary choice of biproduct of a pair of objects.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "monoid.not_is_torsion_iff",
    "statement": "theorem monoid.not_is_torsion_iff (G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g",
    "theorem": "(G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g",
    "args": "(G : Type u_1) [monoid G]",
    "doc_string": "A monoid is not a torsion monoid if it has an element of infinite order.",
    "kind": "theorem",
    "type": "¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g"
  },
  {
    "name": "lazy_list.map",
    "statement": "def lazy_list.map {α : Type u} {β : Type v} (f : α → β) : lazy_list α → lazy_list β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : lazy_list α → lazy_list β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": "Maps a function over a lazy list.",
    "kind": "def",
    "type": "lazy_list α → lazy_list β"
  },
  {
    "name": "category_theory.has_finite_coproducts_of_has_binary_and_terminal",
    "statement": "theorem category_theory.has_finite_coproducts_of_has_binary_and_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C]",
    "doc_string": "If `C` has an initial object and binary coproducts, then it has finite coproducts.",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_coproducts C"
  },
  {
    "name": "has_le.le.lt_of_ne'",
    "statement": "theorem has_le.le.lt_of_ne' {α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≠ a → a < b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≠ a → a < b",
    "args": "{α : Type u} [partial_order α] {a b : α}",
    "doc_string": "**Alias** of lt_of_le_of_ne'`.",
    "kind": "theorem",
    "type": "a ≤ b → b ≠ a → a < b"
  },
  {
    "name": "slim_check.tactic.decorations_of",
    "statement": "def slim_check.tactic.decorations_of (p : Prop) : Type",
    "theorem": "(p : Prop) : Type",
    "args": "(p : Prop)",
    "doc_string": " `decorations_of p` is used as a hint to `mk_decorations` to specify that the goal should be satisfied with a proposition equivalent to `p` with added annotations.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "floor_semiring",
    "statement": "structure floor_semiring (α : Type u_2) [ordered_semiring α] : Type u_2",
    "theorem": "(α : Type u_2) [ordered_semiring α] : Type u_2",
    "args": "(α : Type u_2) [ordered_semiring α]",
    "doc_string": " A `floor_semiring` is an ordered semiring over `α` with a function `floor : α → ℕ` satisfying `∀ (n : ℕ) (x : α), n ≤ ⌊x⌋ ↔ (n : α) ≤ x)`. Note that many lemmas require a `linear_order`. Please see the above `TODO`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "fin.coe_coe_of_lt",
    "statement": "theorem fin.coe_coe_of_lt {n a : ℕ} (h : a < n + 1) : ↑↑a = a",
    "theorem": "{n a : ℕ} (h : a < n + 1) : ↑↑a = a",
    "args": "{n a : ℕ} (h : a < n + 1)",
    "doc_string": " Coercing an in-range number to `fin (n + 1)`, and converting back to `ℕ`, results in that number.",
    "kind": "theorem",
    "type": "↑↑a = a"
  },
  {
    "name": "ereal.le_neg_of_le_neg",
    "statement": "theorem ereal.le_neg_of_le_neg {a b : ereal} (h : a ≤ -b) : b ≤ -a",
    "theorem": "{a b : ereal} (h : a ≤ -b) : b ≤ -a",
    "args": "{a b : ereal} (h : a ≤ -b)",
    "doc_string": "`a ≤ -b → b ≤ -a` on ereal",
    "kind": "theorem",
    "type": "b ≤ -a"
  },
  {
    "name": "wseq.split_at",
    "statement": "def wseq.split_at {α : Type u} (s : wseq α) (n : ℕ) : computation (list α × wseq α)",
    "theorem": "{α : Type u} (s : wseq α) (n : ℕ) : computation (list α × wseq α)",
    "args": "{α : Type u} (s : wseq α) (n : ℕ)",
    "doc_string": "Split the sequence at position `n` into a finite initial segment  and the weak sequence tail",
    "kind": "def",
    "type": "computation (list α × wseq α)"
  },
  {
    "name": "derangements.equiv.remove_none.fiber",
    "statement": "def derangements.equiv.remove_none.fiber {α : Type u_1} [decidable_eq α] (a : option α) : set (equiv.perm α)",
    "theorem": "{α : Type u_1} [decidable_eq α] (a : option α) : set (equiv.perm α)",
    "args": "{α : Type u_1} [decidable_eq α] (a : option α)",
    "doc_string": "The set of permutations `f` such that the preimage of `(a, f)` under    `equiv.perm.decompose_option` is a derangement.",
    "kind": "def",
    "type": "set (equiv.perm α)"
  },
  {
    "name": "list.after",
    "statement": "def list.after {α : Type u} (p : α → Prop) [decidable_pred p] : list α → list α",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] : list α → list α",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p]",
    "doc_string": "`after p xs` is the suffix of `xs` after the first element that satisfies  `p`, not including that element.   ```lean  after      (eq 1)       [0, 1, 2, 3] = [2, 3]  drop_while (not ∘ eq 1) [0, 1, 2, 3] = [1, 2, 3]  ```",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "complete_lattice",
    "statement": "structure complete_lattice (α : Type u_8) : Type u_8",
    "theorem": "(α : Type u_8) : Type u_8",
    "args": "(α : Type u_8)",
    "doc_string": "A complete lattice is a bounded lattice which has suprema and infima for every subset.",
    "kind": "structure",
    "type": "Type u_8"
  },
  {
    "name": "Preorder.of",
    "statement": "def Preorder.of (α : Type u_1) [preorder α] : Preorder",
    "theorem": "(α : Type u_1) [preorder α] : Preorder",
    "args": "(α : Type u_1) [preorder α]",
    "doc_string": "Construct a bundled Preorder from the underlying type and typeclass.",
    "kind": "def",
    "type": "Preorder"
  },
  {
    "name": "submodule.gi",
    "statement": "def submodule.gi (R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : galois_insertion (submodule.span R) coe",
    "theorem": "(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : galois_insertion (submodule.span R) coe",
    "args": "(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "`span` forms a Galois insertion with the coercion from submodule to set.",
    "kind": "def",
    "type": "galois_insertion (submodule.span R) coe"
  },
  {
    "name": "orthonormal_basis.to_basis",
    "statement": "def orthonormal_basis.to_basis {ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] {E : Type u_4} [inner_product_space 𝕜 E] [fintype ι] (b : orthonormal_basis ι 𝕜 E) : basis ι 𝕜 E",
    "theorem": "{ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] {E : Type u_4} [inner_product_space 𝕜 E] [fintype ι] (b : orthonormal_basis ι 𝕜 E) : basis ι 𝕜 E",
    "args": "{ι : Type u_1} {𝕜 : Type u_3} [is_R_or_C 𝕜] {E : Type u_4} [inner_product_space 𝕜 E] [fintype ι] (b : orthonormal_basis ι 𝕜 E)",
    "doc_string": "The `basis ι 𝕜 E` underlying the `orthonormal_basis` -",
    "kind": "def",
    "type": "basis ι 𝕜 E"
  },
  {
    "name": "fintype_of_not_infinite",
    "statement": "def fintype_of_not_infinite {α : Type u_1} (h : ¬infinite α) : fintype α",
    "theorem": "{α : Type u_1} (h : ¬infinite α) : fintype α",
    "args": "{α : Type u_1} (h : ¬infinite α)",
    "doc_string": "A non-infinite type is a fintype.",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "ordnode.split_at_aux",
    "statement": "def ordnode.split_at_aux {α : Type u} : ordnode α → ℕ → ordnode α × ordnode α",
    "theorem": "{α : Type u} : ordnode α → ℕ → ordnode α × ordnode α",
    "args": "{α : Type u}",
    "doc_string": " Auxiliary definition for `split_at`. (Can also be used in lieu of `split_at` if you know the index is within the range of the data structure.)      split_at_aux {a, b, c, d} 2 = ({a, b}, {c, d})     split_at_aux {a, b, c, d} 5 = ({a, b, c, d}, ∅)",
    "kind": "def",
    "type": "ordnode α → ℕ → ordnode α × ordnode α"
  },
  {
    "name": "matrix.linfty_op_normed_ring",
    "statement": "def matrix.linfty_op_normed_ring {n : Type u_4} {α : Type u_5} [fintype n] [normed_ring α] [decidable_eq n] : normed_ring (matrix n n α)",
    "theorem": "{n : Type u_4} {α : Type u_5} [fintype n] [normed_ring α] [decidable_eq n] : normed_ring (matrix n n α)",
    "args": "{n : Type u_4} {α : Type u_5} [fintype n] [normed_ring α] [decidable_eq n]",
    "doc_string": " Normed ring instance (using sup norm of L1 norm) for matrices over a normed ring.  Not declared as an instance because there are several natural choices for defining the norm of a matrix.",
    "kind": "def",
    "type": "normed_ring (matrix n n α)"
  },
  {
    "name": "tactic.rewrite_search.proof_unit",
    "statement": "structure tactic.rewrite_search.proof_unit  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "`proof_unit` represents a sequence of steps that can be applied to one side of the equation to prove a particular expression.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "category_theory.limits.walking_parallel_pair",
    "statement": "inductive category_theory.limits.walking_parallel_pair  : Type v",
    "theorem": " : Type v",
    "args": "",
    "doc_string": "The type of objects for the diagram indexing a (co)equalizer.",
    "kind": "inductive",
    "type": "Type v"
  },
  {
    "name": "order.le_of_pred_le_pred",
    "statement": "theorem order.le_of_pred_le_pred {α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a ≤ order.pred b → a ≤ b",
    "theorem": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a ≤ order.pred b → a ≤ b",
    "args": "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α]",
    "doc_string": "**Alias** of the forward direction of order.pred_le_pred_iff`.",
    "kind": "theorem",
    "type": "order.pred a ≤ order.pred b → a ≤ b"
  },
  {
    "name": "presented_group.of",
    "statement": "def presented_group.of {α : Type} {rels : set (free_group α)} (x : α) : presented_group rels",
    "theorem": "{α : Type} {rels : set (free_group α)} (x : α) : presented_group rels",
    "args": "{α : Type} {rels : set (free_group α)} (x : α)",
    "doc_string": " `of` is the canonical map from `α` to a presented group with generators `x : α`. The term `x` is mapped to the equivalence class of the image of `x` in `free_group α`.",
    "kind": "def",
    "type": "presented_group rels"
  },
  {
    "name": "countable_Inter_filter",
    "statement": "structure countable_Inter_filter {α : Type u_2} (l : filter α) : Prop",
    "theorem": "{α : Type u_2} (l : filter α) : Prop",
    "args": "{α : Type u_2} (l : filter α)",
    "doc_string": " A filter `l` has the countable intersection property if for any countable collection of sets `s ∈ l` their intersection belongs to `l` as well.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "free_group.sum",
    "statement": "def free_group.sum {α : Type u} [add_group α] (x : free_group α) : α",
    "theorem": "{α : Type u} [add_group α] (x : free_group α) : α",
    "args": "{α : Type u} [add_group α] (x : free_group α)",
    "doc_string": " If `α` is a group, then any function from `α` to `α` extends uniquely to a homomorphism from the free group over `α` to `α`. This is the additive version of `prod`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "quot.map_right",
    "statement": "def quot.map_right {α : Sort u_1} {ra ra' : α → α → Prop} (h : ∀ (a₁ a₂ : α), ra a₁ a₂ → ra' a₁ a₂) : quot ra → quot ra'",
    "theorem": "{α : Sort u_1} {ra ra' : α → α → Prop} (h : ∀ (a₁ a₂ : α), ra a₁ a₂ → ra' a₁ a₂) : quot ra → quot ra'",
    "args": "{α : Sort u_1} {ra ra' : α → α → Prop} (h : ∀ (a₁ a₂ : α), ra a₁ a₂ → ra' a₁ a₂)",
    "doc_string": "If `ra` is a subrelation of `ra'`, then we have a natural map `quot ra → quot ra'`.",
    "kind": "def",
    "type": "quot ra → quot ra'"
  },
  {
    "name": "has_groupoid_model_space",
    "statement": "def has_groupoid_model_space (H : Type u_1) [topological_space H] (G : structure_groupoid H) : has_groupoid H G",
    "theorem": "(H : Type u_1) [topological_space H] (G : structure_groupoid H) : has_groupoid H G",
    "args": "(H : Type u_1) [topological_space H] (G : structure_groupoid H)",
    "doc_string": "The trivial charted space structure on the model space is compatible with any groupoid",
    "kind": "def",
    "type": "has_groupoid H G"
  },
  {
    "name": "bitvec.sbb",
    "statement": "def bitvec.sbb {n : ℕ} (x y : bitvec n) (b : bool) : bool × bitvec n",
    "theorem": "{n : ℕ} (x y : bitvec n) (b : bool) : bool × bitvec n",
    "args": "{n : ℕ} (x y : bitvec n) (b : bool)",
    "doc_string": "Subtract with borrow",
    "kind": "def",
    "type": "bool × bitvec n"
  },
  {
    "name": "Scott.is_open",
    "statement": "def Scott.is_open (α : Type u) [omega_complete_partial_order α] (s : set α) : Prop",
    "theorem": "(α : Type u) [omega_complete_partial_order α] (s : set α) : Prop",
    "args": "(α : Type u) [omega_complete_partial_order α] (s : set α)",
    "doc_string": " The characteristic function of open sets is monotone and preserves the limits of chains.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "hindman.FS",
    "statement": "inductive hindman.FS {M : Type u_1} [add_semigroup M] : stream M → set M",
    "theorem": "{M : Type u_1} [add_semigroup M] : stream M → set M",
    "args": "{M : Type u_1} [add_semigroup M]",
    "doc_string": " `FS a` is the set of finite sums in `a`, i.e. `m ∈ FS a` if `m` is the sum of a nonempty subsequence of `a`. We give a direct inductive definition instead of talking about subsequences.",
    "kind": "inductive",
    "type": "stream M → set M"
  },
  {
    "name": "subfield.closure",
    "statement": "def subfield.closure {K : Type u} [field K] (s : set K) : subfield K",
    "theorem": "{K : Type u} [field K] (s : set K) : subfield K",
    "args": "{K : Type u} [field K] (s : set K)",
    "doc_string": "The `subfield` generated by a set.",
    "kind": "def",
    "type": "subfield K"
  },
  {
    "name": "free_group.red.enum",
    "statement": "def free_group.red.enum {α : Type u} [decidable_eq α] (L₁ : list (α × bool)) : list (list (α × bool))",
    "theorem": "{α : Type u} [decidable_eq α] (L₁ : list (α × bool)) : list (list (α × bool))",
    "args": "{α : Type u} [decidable_eq α] (L₁ : list (α × bool))",
    "doc_string": "A list containing every word that `w₁` reduces to.",
    "kind": "def",
    "type": "list (list (α × bool))"
  },
  {
    "name": "parser.ch",
    "statement": "def parser.ch (c : char) : parser unit",
    "theorem": "(c : char) : parser unit",
    "args": "(c : char)",
    "doc_string": "Matches the given character.",
    "kind": "def",
    "type": "parser unit"
  },
  {
    "name": "category_theory.grothendieck_topology.le_close",
    "statement": "theorem category_theory.grothendieck_topology.le_close {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S ≤ J₁.close S",
    "theorem": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S ≤ J₁.close S",
    "args": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X)",
    "doc_string": "Any sieve is smaller than its closure.",
    "kind": "theorem",
    "type": "S ≤ J₁.close S"
  },
  {
    "name": "nat.gcd_a",
    "statement": "def nat.gcd_a (x y : ℕ) : ℤ",
    "theorem": "(x y : ℕ) : ℤ",
    "args": "(x y : ℕ)",
    "doc_string": "The extended GCD `a` value in the equation `gcd x y = x * a + y * b`.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "nonempty.some",
    "statement": "def nonempty.some {α : Sort u_1} (h : nonempty α) : α",
    "theorem": "{α : Sort u_1} (h : nonempty α) : α",
    "args": "{α : Sort u_1} (h : nonempty α)",
    "doc_string": "Using `classical.choice`, extracts a term from a `nonempty` type.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "nat.gcd_b",
    "statement": "def nat.gcd_b (x y : ℕ) : ℤ",
    "theorem": "(x y : ℕ) : ℤ",
    "args": "(x y : ℕ)",
    "doc_string": "The extended GCD `b` value in the equation `gcd x y = x * a + y * b`.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "is_artinian_pi'",
    "statement": "def is_artinian_pi' {R : Type u_1} {ι : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype ι] [is_artinian R M] : is_artinian R (ι → M)",
    "theorem": "{R : Type u_1} {ι : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype ι] [is_artinian R M] : is_artinian R (ι → M)",
    "args": "{R : Type u_1} {ι : Type u_2} {M : Type u_3} [ring R] [add_comm_group M] [module R M] [fintype ι] [is_artinian R M]",
    "doc_string": " A version of `is_artinian_pi` for non-dependent functions. We need this instance because sometimes Lean fails to apply the dependent version in non-dependent settings (e.g., it fails to prove that `ι → ℝ` is finite dimensional over `ℝ`).",
    "kind": "def",
    "type": "is_artinian R (ι → M)"
  },
  {
    "name": "lt_neg_of_lt_neg",
    "statement": "theorem lt_neg_of_lt_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < -b → b < -a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < -b → b < -a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the forward direction of lt_inv'`.",
    "kind": "theorem",
    "type": "a < -b → b < -a"
  },
  {
    "name": "equiv.inv",
    "statement": "def equiv.inv (G : Type u_10) [has_involutive_inv G] : equiv.perm G",
    "theorem": "(G : Type u_10) [has_involutive_inv G] : equiv.perm G",
    "args": "(G : Type u_10) [has_involutive_inv G]",
    "doc_string": "Inversion on a `group` or `group_with_zero` is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm G"
  },
  {
    "name": "lie_algebra.orthogonal.so",
    "statement": "def lie_algebra.orthogonal.so (n : Type u_1) (R : Type u₂) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)",
    "theorem": "(n : Type u_1) (R : Type u₂) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)",
    "args": "(n : Type u_1) (R : Type u₂) [decidable_eq n] [comm_ring R] [fintype n]",
    "doc_string": " The definite orthogonal Lie subalgebra: skew-adjoint matrices with respect to the symmetric bilinear form defined by the identity matrix.",
    "kind": "def",
    "type": "lie_subalgebra R (matrix n n R)"
  },
  {
    "name": "category_theory.limits.initial",
    "statement": "def category_theory.limits.initial (C : Type u₁) [category_theory.category C] [category_theory.limits.has_initial C] : C",
    "theorem": "(C : Type u₁) [category_theory.category C] [category_theory.limits.has_initial C] : C",
    "args": "(C : Type u₁) [category_theory.category C] [category_theory.limits.has_initial C]",
    "doc_string": "An arbitrary choice of initial object, if one exists. You can use the notation `⊥_ C`. This object is characterized by having a unique morphism to any object.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "self_adjoint",
    "statement": "def self_adjoint (R : Type u_1) [add_group R] [star_add_monoid R] : add_subgroup R",
    "theorem": "(R : Type u_1) [add_group R] [star_add_monoid R] : add_subgroup R",
    "args": "(R : Type u_1) [add_group R] [star_add_monoid R]",
    "doc_string": "The self-adjoint elements of a star additive group, as an additive subgroup.",
    "kind": "def",
    "type": "add_subgroup R"
  },
  {
    "name": "direct_sum.gcomm_semiring",
    "statement": "structure direct_sum.gcomm_semiring {ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [add_comm_monoid ι] [Π (i : ι), add_comm_monoid (A i)] : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [add_comm_monoid ι] [Π (i : ι), add_comm_monoid (A i)] : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [add_comm_monoid ι] [Π (i : ι), add_comm_monoid (A i)]",
    "doc_string": "A graded version of `comm_semiring`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "topological_semiring.to_topological_ring",
    "statement": "theorem topological_semiring.to_topological_ring {α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α) : topological_ring α",
    "theorem": "{α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α) : topological_ring α",
    "args": "{α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α)",
    "doc_string": " If `R` is a ring which is a topological semiring, then it is automatically a topological ring. This exists so that one can place a topological ring structure on `R` without explicitly proving `continuous_neg`.",
    "kind": "theorem",
    "type": "topological_ring α"
  },
  {
    "name": "has_le.le.eq_or_lt",
    "statement": "theorem has_le.le.eq_or_lt {α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : a = b ∨ a < b",
    "theorem": "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : a = b ∨ a < b",
    "args": "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b)",
    "doc_string": "**Alias** of eq_or_lt_of_le`.",
    "kind": "theorem",
    "type": "a = b ∨ a < b"
  },
  {
    "name": "homological_complex.X_prev",
    "statement": "def homological_complex.X_prev {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (j : ι) : V",
    "theorem": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (j : ι) : V",
    "args": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (C : homological_complex V c) [category_theory.limits.has_zero_object V] (j : ι)",
    "doc_string": "Either `C.X i`, if there is some `i` with `c.rel i j`, or the zero object.",
    "kind": "def",
    "type": "V"
  },
  {
    "name": "matrix.invertible_of_is_unit_det",
    "statement": "def matrix.invertible_of_is_unit_det {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : invertible A",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : invertible A",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det)",
    "doc_string": " A version of `matrix.invertible_of_det_invertible` with the inverse defeq to `A⁻¹` that is therefore noncomputable.",
    "kind": "def",
    "type": "invertible A"
  },
  {
    "name": "qpf.cofix",
    "statement": "def qpf.cofix (F : Type u → Type u) [functor F] [q : qpf F] : Type u",
    "theorem": "(F : Type u → Type u) [functor F] [q : qpf F] : Type u",
    "args": "(F : Type u → Type u) [functor F] [q : qpf F]",
    "doc_string": "coinductive type defined as the final coalgebra of a qpf",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "measure_theory.jordan_decomposition.to_signed_measure_injective",
    "statement": "theorem measure_theory.jordan_decomposition.to_signed_measure_injective {α : Type u_1} [measurable_space α] : function.injective measure_theory.jordan_decomposition.to_signed_measure",
    "theorem": "{α : Type u_1} [measurable_space α] : function.injective measure_theory.jordan_decomposition.to_signed_measure",
    "args": "{α : Type u_1} [measurable_space α]",
    "doc_string": "The Jordan decomposition of a signed measure is unique.",
    "kind": "theorem",
    "type": "function.injective measure_theory.jordan_decomposition.to_signed_measure"
  },
  {
    "name": "polynomial.rev_at_fun",
    "statement": "def polynomial.rev_at_fun (N i : ℕ) : ℕ",
    "theorem": "(N i : ℕ) : ℕ",
    "args": "(N i : ℕ)",
    "doc_string": " If `i ≤ N`, then `rev_at_fun N i` returns `N - i`, otherwise it returns `i`. This is the map used by the embedding `rev_at`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "is_add_submonoid.multiples_subset",
    "statement": "theorem is_add_submonoid.multiples_subset {M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s) : multiples a ⊆ s",
    "theorem": "{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s) : multiples a ⊆ s",
    "args": "{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s)",
    "doc_string": "The set of natural number multiples of an element of an `add_submonoid` is a subset of the `add_submonoid`.",
    "kind": "theorem",
    "type": "multiples a ⊆ s"
  },
  {
    "name": "prime_spectrum.zero_locus",
    "statement": "def prime_spectrum.zero_locus {R : Type u} [comm_ring R] (s : set R) : set (prime_spectrum R)",
    "theorem": "{R : Type u} [comm_ring R] (s : set R) : set (prime_spectrum R)",
    "args": "{R : Type u} [comm_ring R] (s : set R)",
    "doc_string": " The zero locus of a set `s` of elements of a commutative ring `R` is the set of all prime ideals of the ring that contain the set `s`.  An element `f` of `R` can be thought of as a dependent function on the prime spectrum of `R`. At a point `x` (a prime ideal) the function (i.e., element) `f` takes values in the quotient ring `R` modulo the prime ideal `x`. In this manner, `zero_locus s` is exactly the subset of `prime_spectrum R` where all \"functions\" in `s` vanish simultaneously.",
    "kind": "def",
    "type": "set (prime_spectrum R)"
  },
  {
    "name": "first_order.language.bounded_formula",
    "statement": "inductive first_order.language.bounded_formula (L : first_order.language) (α : Type u') : ℕ → Type (max u v u')",
    "theorem": "(L : first_order.language) (α : Type u') : ℕ → Type (max u v u')",
    "args": "(L : first_order.language) (α : Type u')",
    "doc_string": "`bounded_formula α n` is the type of formulas with free variables indexed by `α` and up to `n`  additional free variables.",
    "kind": "inductive",
    "type": "ℕ → Type (max u v u')"
  },
  {
    "name": "witt_vector.witt_zero",
    "statement": "def witt_vector.witt_zero (p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 0 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 0 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "The polynomials used for defining the element `0` of the ring of Witt vectors.",
    "kind": "def",
    "type": "ℕ → mv_polynomial (fin 0 × ℕ) ℤ"
  },
  {
    "name": "finmap",
    "statement": "structure finmap {α : Type u} (β : α → Type v) : Type (max u v)",
    "theorem": "{α : Type u} (β : α → Type v) : Type (max u v)",
    "args": "{α : Type u} (β : α → Type v)",
    "doc_string": "`finmap β` is the type of finite maps over a multiset. It is effectively  a quotient of `alist β` by permutation of the underlying list.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "monoid.exists_list_of_mem_closure",
    "statement": "theorem monoid.exists_list_of_mem_closure {M : Type u_1} [monoid M] {s : set M} {a : M} (h : a ∈ monoid.closure s) : ∃ (l : list M), (∀ (x : M), x ∈ l → x ∈ s) ∧ l.prod = a",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} {a : M} (h : a ∈ monoid.closure s) : ∃ (l : list M), (∀ (x : M), x ∈ l → x ∈ s) ∧ l.prod = a",
    "args": "{M : Type u_1} [monoid M] {s : set M} {a : M} (h : a ∈ monoid.closure s)",
    "doc_string": " Given an element `a` of the submonoid of a monoid `M` generated by a set `s`, there exists a list of elements of `s` whose product is `a`.",
    "kind": "theorem",
    "type": "∃ (l : list M), (∀ (x : M), x ∈ l → x ∈ s) ∧ l.prod = a"
  },
  {
    "name": "has_lt.lt.trans_eq",
    "statement": "theorem has_lt.lt.trans_eq {α : Type u} [preorder α] {a b c : α} (hab : a < b) (hbc : b = c) : a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} (hab : a < b) (hbc : b = c) : a < c",
    "args": "{α : Type u} [preorder α] {a b c : α} (hab : a < b) (hbc : b = c)",
    "doc_string": "**Alias** of lt_of_lt_of_eq`.",
    "kind": "theorem",
    "type": "a < c"
  },
  {
    "name": "omega.nat.preterm.val",
    "statement": "def omega.nat.preterm.val (v : ℕ → ℕ) : omega.nat.preterm → ℕ",
    "theorem": "(v : ℕ → ℕ) : omega.nat.preterm → ℕ",
    "args": "(v : ℕ → ℕ)",
    "doc_string": "Preterm evaluation",
    "kind": "def",
    "type": "omega.nat.preterm → ℕ"
  },
  {
    "name": "well_founded.succ",
    "statement": "def well_founded.succ {α : Type u_1} {r : α → α → Prop} (wf : well_founded r) (x : α) : α",
    "theorem": "{α : Type u_1} {r : α → α → Prop} (wf : well_founded r) (x : α) : α",
    "args": "{α : Type u_1} {r : α → α → Prop} (wf : well_founded r) (x : α)",
    "doc_string": " A successor of an element `x` in a well-founded order is a minimal element `y` such that `x < y` if one exists. Otherwise it is `x` itself.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "computability.encode_nat",
    "statement": "def computability.encode_nat (n : ℕ) : list bool",
    "theorem": "(n : ℕ) : list bool",
    "args": "(n : ℕ)",
    "doc_string": "An encoding function of ℕ in bool.",
    "kind": "def",
    "type": "list bool"
  },
  {
    "name": "BoolAlg.of",
    "statement": "def BoolAlg.of (α : Type u_1) [boolean_algebra α] : BoolAlg",
    "theorem": "(α : Type u_1) [boolean_algebra α] : BoolAlg",
    "args": "(α : Type u_1) [boolean_algebra α]",
    "doc_string": "Construct a bundled `BoolAlg` from a `boolean_algebra`.",
    "kind": "def",
    "type": "BoolAlg"
  },
  {
    "name": "cinfi_le",
    "statement": "theorem cinfi_le {α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι) : infi f ≤ f c",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι) : infi f ≤ f c",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι)",
    "doc_string": "The indexed infimum of a function is bounded above by the value taken at one point",
    "kind": "theorem",
    "type": "infi f ≤ f c"
  },
  {
    "name": "add_localization",
    "statement": "def add_localization {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : Type u_1",
    "theorem": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : Type u_1",
    "args": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M)",
    "doc_string": "The localization of an `add_comm_monoid` at one of its submonoids (as a quotient type).",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "stream.inits_core",
    "statement": "def stream.inits_core {α : Type u} (l : list α) (s : stream α) : stream (list α)",
    "theorem": "{α : Type u} (l : list α) (s : stream α) : stream (list α)",
    "args": "{α : Type u} (l : list α) (s : stream α)",
    "doc_string": "An auxiliary definition for `stream.inits`.",
    "kind": "def",
    "type": "stream (list α)"
  },
  {
    "name": "is_add_subgroup",
    "statement": "structure is_add_subgroup {A : Type u_3} [add_group A] (s : set A) : Prop",
    "theorem": "{A : Type u_3} [add_group A] (s : set A) : Prop",
    "args": "{A : Type u_3} [add_group A] (s : set A)",
    "doc_string": "`s` is an additive subgroup: a set containing 0 and closed under addition and negation.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "parser.remaining",
    "statement": "def parser.remaining  : parser ℕ",
    "theorem": " : parser ℕ",
    "args": "",
    "doc_string": "Number of remaining input characters.",
    "kind": "def",
    "type": "parser ℕ"
  },
  {
    "name": "fin_zero_elim",
    "statement": "def fin_zero_elim {α : fin 0 → Sort u} (x : fin 0) : α x",
    "theorem": "{α : fin 0 → Sort u} (x : fin 0) : α x",
    "args": "{α : fin 0 → Sort u} (x : fin 0)",
    "doc_string": "Elimination principle for the empty set `fin 0`, dependent version.",
    "kind": "def",
    "type": "α x"
  },
  {
    "name": "finset.attach_fin",
    "statement": "def finset.attach_fin (s : finset ℕ) {n : ℕ} (h : ∀ (m : ℕ), m ∈ s → m < n) : finset (fin n)",
    "theorem": "(s : finset ℕ) {n : ℕ} (h : ∀ (m : ℕ), m ∈ s → m < n) : finset (fin n)",
    "args": "(s : finset ℕ) {n : ℕ} (h : ∀ (m : ℕ), m ∈ s → m < n)",
    "doc_string": " Given a finset `s` of `ℕ` contained in `{0,..., n-1}`, the corresponding finset in `fin n` is `s.attach_fin h` where `h` is a proof that all elements of `s` are less than `n`.",
    "kind": "def",
    "type": "finset (fin n)"
  },
  {
    "name": "fin.find_min",
    "statement": "theorem fin.find_min {n : ℕ} {p : fin n → Prop} [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) {j : fin n} (hj : j < i) : ¬p j",
    "theorem": "{n : ℕ} {p : fin n → Prop} [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) {j : fin n} (hj : j < i) : ¬p j",
    "args": "{n : ℕ} {p : fin n → Prop} [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) {j : fin n} (hj : j < i)",
    "doc_string": " If `find p` returns `some i`, then `p j` does not hold for `j < i`, i.e., `i` is minimal among the indices where `p` holds.",
    "kind": "theorem",
    "type": "¬p j"
  },
  {
    "name": "tensor_algebra.rel",
    "statement": "inductive tensor_algebra.rel (R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : free_algebra R M → free_algebra R M → Prop",
    "theorem": "(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M] : free_algebra R M → free_algebra R M → Prop",
    "args": "(R : Type u_1) [comm_semiring R] (M : Type u_2) [add_comm_monoid M] [module R M]",
    "doc_string": "An inductively defined relation on `pre R M` used to force the initial algebra structure on the associated quotient.",
    "kind": "inductive",
    "type": "free_algebra R M → free_algebra R M → Prop"
  },
  {
    "name": "set.separates_points",
    "statement": "def set.separates_points {α : Type u_1} {β : Type u_2} (A : set (α → β)) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (A : set (α → β)) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} (A : set (α → β))",
    "doc_string": " A set of functions \"separates points\" if for each pair of distinct points there is a function taking different values on them.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordinal.has_add",
    "statement": "def ordinal.has_add  : has_add ordinal",
    "theorem": " : has_add ordinal",
    "args": "",
    "doc_string": "`o₁ + o₂` is the order on the disjoint union of `o₁` and `o₂` obtained by declaring that  every element of `o₁` is smaller than every element of `o₂`.",
    "kind": "def",
    "type": "has_add ordinal"
  },
  {
    "name": "padic_int",
    "statement": "def padic_int (p : ℕ) [fact (nat.prime p)] : Type",
    "theorem": "(p : ℕ) [fact (nat.prime p)] : Type",
    "args": "(p : ℕ) [fact (nat.prime p)]",
    "doc_string": "The p-adic integers ℤ_p are the p-adic numbers with norm ≤ 1.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "le_sub_right_of_add_le",
    "statement": "theorem le_sub_right_of_add_le {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a + b ≤ c → a ≤ c - b",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a + b ≤ c → a ≤ c - b",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of le_sub_iff_add_le`.",
    "kind": "theorem",
    "type": "a + b ≤ c → a ≤ c - b"
  },
  {
    "name": "omega.nat.exprform",
    "statement": "inductive omega.nat.exprform  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Intermediate shadow syntax for LNA formulas that includes unreified exprs",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "set_like.is_homogeneous",
    "statement": "def set_like.is_homogeneous {ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] (A : ι → S) (a : R) : Prop",
    "theorem": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] (A : ι → S) (a : R) : Prop",
    "args": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] (A : ι → S) (a : R)",
    "doc_string": "An element `a : R` is said to be homogeneous if there is some `i : ι` such that `a ∈ A i`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "not",
    "statement": "def not (a : Prop) : Prop",
    "theorem": "(a : Prop) : Prop",
    "args": "(a : Prop)",
    "doc_string": "Logical not.  `not P`, with notation `¬ P`, is the `Prop` which is true if and only if `P` is false. It is internally represented as `P → false`, so one way to prove a goal `⊢ ¬ P` is to use `intro h`, which gives you a new hypothesis `h : P` and the goal `⊢ false`.  A hypothesis `h : ¬ P` can be used in term mode as a function, so if `w : P` then `h w : false`.  Related mathlib tactic: `contrapose`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "cubic.disc",
    "statement": "def cubic.disc {R : Type u_1} [ring R] (P : cubic R) : R",
    "theorem": "{R : Type u_1} [ring R] (P : cubic R) : R",
    "args": "{R : Type u_1} [ring R] (P : cubic R)",
    "doc_string": "The discriminant of a cubic polynomial.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "right.mul_lt_one",
    "statement": "theorem right.mul_lt_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "euclidean_quadrant",
    "statement": "def euclidean_quadrant (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": "The quadrant in `ℝ^n`, used to model manifolds with corners, made of all vectors with nonnegative coordinates.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "free_group.red.step",
    "statement": "inductive free_group.red.step {α : Type u} : list (α × bool) → list (α × bool) → Prop",
    "theorem": "{α : Type u} : list (α × bool) → list (α × bool) → Prop",
    "args": "{α : Type u}",
    "doc_string": "Reduction step: `w * x * x⁻¹ * v ~> w * v`",
    "kind": "inductive",
    "type": "list (α × bool) → list (α × bool) → Prop"
  },
  {
    "name": "rand_nat",
    "statement": "def rand_nat {gen : Type u} [random_gen gen] (g : gen) (lo hi : ℕ) : ℕ × gen",
    "theorem": "{gen : Type u} [random_gen gen] (g : gen) (lo hi : ℕ) : ℕ × gen",
    "args": "{gen : Type u} [random_gen gen] (g : gen) (lo hi : ℕ)",
    "doc_string": "Generate a random natural number in the interval [lo, hi].",
    "kind": "def",
    "type": "ℕ × gen"
  },
  {
    "name": "subsemiring.one_mem",
    "statement": "theorem subsemiring.one_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 1 ∈ s",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) : 1 ∈ s",
    "args": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R)",
    "doc_string": "A subsemiring contains the semiring's 1.",
    "kind": "theorem",
    "type": "1 ∈ s"
  },
  {
    "name": "ordnode.split_max",
    "statement": "def ordnode.split_max {α : Type u} : ordnode α → option (ordnode α × α)",
    "theorem": "{α : Type u} : ordnode α → option (ordnode α × α)",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Extract and remove the maximum element from the tree, if it exists.      split_max {1, 2, 3} = some ({1, 2}, 3)     split_max ∅ = none",
    "kind": "def",
    "type": "ordnode α → option (ordnode α × α)"
  },
  {
    "name": "galois_insertion.lift_order_top",
    "statement": "def galois_insertion.lift_order_top {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [preorder α] [order_top α] (gi : galois_insertion l u) : order_top β",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [preorder α] [order_top α] (gi : galois_insertion l u) : order_top β",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [preorder α] [order_top α] (gi : galois_insertion l u)",
    "doc_string": "Lift the top along a Galois insertion",
    "kind": "def",
    "type": "order_top β"
  },
  {
    "name": "filter.has_involutive_neg",
    "statement": "def filter.has_involutive_neg {α : Type u_2} [has_involutive_neg α] : has_involutive_neg (filter α)",
    "theorem": "{α : Type u_2} [has_involutive_neg α] : has_involutive_neg (filter α)",
    "args": "{α : Type u_2} [has_involutive_neg α]",
    "doc_string": "Negation is involutive on `filter α` if it is on `α`.",
    "kind": "def",
    "type": "has_involutive_neg (filter α)"
  },
  {
    "name": "snum.rec'",
    "statement": "def snum.rec' {α : Sort u_1} (z : bool → α) (s : bool → snum → α → α) : snum → α",
    "theorem": "{α : Sort u_1} (z : bool → α) (s : bool → snum → α → α) : snum → α",
    "args": "{α : Sort u_1} (z : bool → α) (s : bool → snum → α → α)",
    "doc_string": "An induction principle for `snum` which avoids relying on `nzsnum`.",
    "kind": "def",
    "type": "snum → α"
  },
  {
    "name": "is_empty.elim",
    "statement": "def is_empty.elim {α : Sort u_1} (h : is_empty α) {p : α → Sort u_2} (a : α) : p a",
    "theorem": "{α : Sort u_1} (h : is_empty α) {p : α → Sort u_2} (a : α) : p a",
    "args": "{α : Sort u_1} (h : is_empty α) {p : α → Sort u_2} (a : α)",
    "doc_string": "Eliminate out of a type that `is_empty` (using projection notation).",
    "kind": "def",
    "type": "p a"
  },
  {
    "name": "ordinal.lift.initial_seg",
    "statement": "def ordinal.lift.initial_seg  : initial_seg has_lt.lt has_lt.lt",
    "theorem": " : initial_seg has_lt.lt has_lt.lt",
    "args": "",
    "doc_string": "Initial segment version of the lift operation on ordinals, embedding `ordinal.{u}` in  `ordinal.{v}` as an initial segment when `u ≤ v`.",
    "kind": "def",
    "type": "initial_seg has_lt.lt has_lt.lt"
  },
  {
    "name": "euclidean_domain.gcd_eq_gcd_ab",
    "statement": "theorem euclidean_domain.gcd_eq_gcd_ab {R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b",
    "theorem": "{R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b",
    "args": "{R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R)",
    "doc_string": "An explicit version of **Bézout's lemma** for Euclidean domains.",
    "kind": "theorem",
    "type": "euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b"
  },
  {
    "name": "try_for_time",
    "statement": "def try_for_time {α : Type u} (max : ℕ) (f : thunk α) : option α",
    "theorem": "{α : Type u} (max : ℕ) (f : thunk α) : option α",
    "args": "{α : Type u} (max : ℕ) (f : thunk α)",
    "doc_string": "This function has a native implementation where the thunk is interrupted if it takes more than `max` milliseconds to compute it. This is useful due to the variance in the number of heartbeats used by tactics.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "is_mul_hom.id",
    "statement": "theorem is_mul_hom.id {α : Type u} [has_mul α] : is_mul_hom id",
    "theorem": "{α : Type u} [has_mul α] : is_mul_hom id",
    "args": "{α : Type u} [has_mul α]",
    "doc_string": "The identity map preserves multiplication.",
    "kind": "theorem",
    "type": "is_mul_hom id"
  },
  {
    "name": "filter.prod",
    "statement": "def filter.prod {α : Type u} {β : Type v} (f : filter α) (g : filter β) : filter (α × β)",
    "theorem": "{α : Type u} {β : Type v} (f : filter α) (g : filter β) : filter (α × β)",
    "args": "{α : Type u} {β : Type v} (f : filter α) (g : filter β)",
    "doc_string": "Product of filters. This is the filter generated by cartesian products  of elements of the component filters.",
    "kind": "def",
    "type": "filter (α × β)"
  },
  {
    "name": "free_product.word.prod",
    "statement": "def free_product.word.prod {ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] (w : free_product.word M) : free_product M",
    "theorem": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] (w : free_product.word M) : free_product M",
    "args": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] (w : free_product.word M)",
    "doc_string": "A reduced word determines an element of the free product, given by multiplication.",
    "kind": "def",
    "type": "free_product M"
  },
  {
    "name": "closed_under_restriction",
    "statement": "structure closed_under_restriction {H : Type u} [topological_space H] (G : structure_groupoid H) : Prop",
    "theorem": "{H : Type u} [topological_space H] (G : structure_groupoid H) : Prop",
    "args": "{H : Type u} [topological_space H] (G : structure_groupoid H)",
    "doc_string": " A groupoid is closed under restriction if it contains all restrictions of its element local homeomorphisms to open subsets of the source.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "inf_hom.const",
    "statement": "def inf_hom.const (α : Type u_3) {β : Type u_4} [has_inf α] [semilattice_inf β] (b : β) : inf_hom α β",
    "theorem": "(α : Type u_3) {β : Type u_4} [has_inf α] [semilattice_inf β] (b : β) : inf_hom α β",
    "args": "(α : Type u_3) {β : Type u_4} [has_inf α] [semilattice_inf β] (b : β)",
    "doc_string": "The constant function as an `inf_hom`.",
    "kind": "def",
    "type": "inf_hom α β"
  },
  {
    "name": "list.split_wrt_composition_aux",
    "statement": "def list.split_wrt_composition_aux {α : Type u_1} : list α → list ℕ → list (list α)",
    "theorem": "{α : Type u_1} : list α → list ℕ → list (list α)",
    "args": "{α : Type u_1}",
    "doc_string": "Auxiliary for `list.split_wrt_composition`.",
    "kind": "def",
    "type": "list α → list ℕ → list (list α)"
  },
  {
    "name": "is_semiring_hom.id",
    "statement": "theorem is_semiring_hom.id {α : Type u} [semiring α] : is_semiring_hom id",
    "theorem": "{α : Type u} [semiring α] : is_semiring_hom id",
    "args": "{α : Type u} [semiring α]",
    "doc_string": "The identity map is a semiring homomorphism.",
    "kind": "theorem",
    "type": "is_semiring_hom id"
  },
  {
    "name": "finite_dimensional.fin_basis",
    "statement": "def finite_dimensional.fin_basis (K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : basis (fin (finite_dimensional.finrank K V)) K V",
    "theorem": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : basis (fin (finite_dimensional.finrank K V)) K V",
    "args": "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": "A finite dimensional vector space has a basis indexed by `fin (finrank K V)`.",
    "kind": "def",
    "type": "basis (fin (finite_dimensional.finrank K V)) K V"
  },
  {
    "name": "locally_constant",
    "statement": "structure locally_constant (X : Type u_5) (Y : Type u_6) [topological_space X] : Type (max u_5 u_6)",
    "theorem": "(X : Type u_5) (Y : Type u_6) [topological_space X] : Type (max u_5 u_6)",
    "args": "(X : Type u_5) (Y : Type u_6) [topological_space X]",
    "doc_string": "A (bundled) locally constant function from a topological space `X` to a type `Y`.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "fintype.of_surjective",
    "statement": "def fintype.of_surjective {α : Type u_1} {β : Type u_2} [decidable_eq β] [fintype α] (f : α → β) (H : function.surjective f) : fintype β",
    "theorem": "{α : Type u_1} {β : Type u_2} [decidable_eq β] [fintype α] (f : α → β) (H : function.surjective f) : fintype β",
    "args": "{α : Type u_1} {β : Type u_2} [decidable_eq β] [fintype α] (f : α → β) (H : function.surjective f)",
    "doc_string": "If `f : α → β` is a surjection and `α` is a fintype, then `β` is also a fintype.",
    "kind": "def",
    "type": "fintype β"
  },
  {
    "name": "minpoly.ne_one",
    "statement": "theorem minpoly.ne_one (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x ≠ 1",
    "theorem": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x ≠ 1",
    "args": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B]",
    "doc_string": "A minimal polynomial is not `1`.",
    "kind": "theorem",
    "type": "minpoly A x ≠ 1"
  },
  {
    "name": "add_hom.prod",
    "statement": "def add_hom.prod {M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [has_add P] (f : add_hom M N) (g : add_hom M P) : add_hom M (N × P)",
    "theorem": "{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [has_add P] (f : add_hom M N) (g : add_hom M P) : add_hom M (N × P)",
    "args": "{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [has_add P] (f : add_hom M N) (g : add_hom M P)",
    "doc_string": "Combine two `add_monoid_hom`s `f : add_hom M N`, `g : add_hom M P` into `f.prod g : add_hom M (N × P)` given by `(f.prod g) x = (f x, g x)`",
    "kind": "def",
    "type": "add_hom M (N × P)"
  },
  {
    "name": "function.surjective.dense_range",
    "statement": "theorem function.surjective.dense_range {β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : function.surjective f) : dense_range f",
    "theorem": "{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : function.surjective f) : dense_range f",
    "args": "{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : function.surjective f)",
    "doc_string": "A surjective map has dense range.",
    "kind": "theorem",
    "type": "dense_range f"
  },
  {
    "name": "basis.card_le_card_of_linear_independent_aux",
    "statement": "theorem basis.card_le_card_of_linear_independent_aux {R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n",
    "theorem": "{R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n",
    "args": "{R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R)",
    "doc_string": "In an `n`-dimensional space, the rank is at most `m`.",
    "kind": "theorem",
    "type": "linear_independent R v → m ≤ n"
  },
  {
    "name": "tactic.ring_exp.context",
    "statement": "structure tactic.ring_exp.context  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The `context` contains the full set of information needed for the `eval` function.  This structure has two copies of `eval_info`: one is for the base (typically some semiring `α`) and another for the exponent (always `ℕ`). When evaluating an exponent, we put `info_e` in `info_b`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "tendsto_sum_nat_add",
    "statement": "theorem tendsto_sum_nat_add {α : Type u_1} [add_comm_group α] [topological_space α] [topological_add_group α] [t2_space α] (f : ℕ → α) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)",
    "theorem": "{α : Type u_1} [add_comm_group α] [topological_space α] [topological_add_group α] [t2_space α] (f : ℕ → α) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)",
    "args": "{α : Type u_1} [add_comm_group α] [topological_space α] [topological_add_group α] [t2_space α] (f : ℕ → α)",
    "doc_string": " For `f : ℕ → α`, then `∑' k, f (k + i)` tends to zero. This does not require a summability assumption on `f`, as otherwise all sums are zero.",
    "kind": "theorem",
    "type": "filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)"
  },
  {
    "name": "num.size",
    "statement": "def num.size  : num → num",
    "theorem": " : num → num",
    "args": "",
    "doc_string": "The number of bits required to represent a `num`, as a `num`. `size 0` is defined to be `0`.",
    "kind": "def",
    "type": "num → num"
  },
  {
    "name": "add_nonneg",
    "statement": "theorem add_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b)",
    "doc_string": "**Alias** of `left.add_nonneg`.",
    "kind": "theorem",
    "type": "0 ≤ a + b"
  },
  {
    "name": "computability.decode_num",
    "statement": "def computability.decode_num  : list bool → num",
    "theorem": " : list bool → num",
    "args": "",
    "doc_string": "A decoding function from `list bool` to the binary numbers.",
    "kind": "def",
    "type": "list bool → num"
  },
  {
    "name": "matrix.map",
    "statement": "def matrix.map {m : Type u_2} {n : Type u_3} {α : Type v} {β : Type w} (M : matrix m n α) (f : α → β) : matrix m n β",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} {β : Type w} (M : matrix m n α) (f : α → β) : matrix m n β",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} {β : Type w} (M : matrix m n α) (f : α → β)",
    "doc_string": " `M.map f` is the matrix obtained by applying `f` to each entry of the matrix `M`.  This is available in bundled forms as: * `add_monoid_hom.map_matrix` * `linear_map.map_matrix` * `ring_hom.map_matrix` * `alg_hom.map_matrix` * `equiv.map_matrix` * `add_equiv.map_matrix` * `linear_equiv.map_matrix` * `ring_equiv.map_matrix` * `alg_equiv.map_matrix`",
    "kind": "def",
    "type": "matrix m n β"
  },
  {
    "name": "W_type.encodable",
    "statement": "def W_type.encodable {α : Type u_1} {β : α → Type u_2} [Π (a : α), fintype (β a)] [Π (a : α), encodable (β a)] [encodable α] : encodable (W_type β)",
    "theorem": "{α : Type u_1} {β : α → Type u_2} [Π (a : α), fintype (β a)] [Π (a : α), encodable (β a)] [encodable α] : encodable (W_type β)",
    "args": "{α : Type u_1} {β : α → Type u_2} [Π (a : α), fintype (β a)] [Π (a : α), encodable (β a)] [encodable α]",
    "doc_string": " `W_type` is encodable when `α` is an encodable fintype and for every `a : α`, `β a` is encodable.",
    "kind": "def",
    "type": "encodable (W_type β)"
  },
  {
    "name": "modular_group.fd",
    "statement": "def modular_group.fd  : set upper_half_plane",
    "theorem": " : set upper_half_plane",
    "args": "",
    "doc_string": "The standard (closed) fundamental domain of the action of `SL(2,ℤ)` on `ℍ`.",
    "kind": "def",
    "type": "set upper_half_plane"
  },
  {
    "name": "pgame.neg",
    "statement": "def pgame.neg  : pgame → pgame",
    "theorem": " : pgame → pgame",
    "args": "",
    "doc_string": "The negation of `{L | R}` is `{-R | -L}`.",
    "kind": "def",
    "type": "pgame → pgame"
  },
  {
    "name": "order_topology",
    "statement": "structure order_topology (α : Type u_1) [t : topological_space α] [preorder α] : Prop",
    "theorem": "(α : Type u_1) [t : topological_space α] [preorder α] : Prop",
    "args": "(α : Type u_1) [t : topological_space α] [preorder α]",
    "doc_string": " The order topology on an ordered type is the topology generated by open intervals. We register it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed. We define it as a mixin. If you want to introduce the order topology on a preorder, use `preorder.topology`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "colex.singleton_lt_iff_lt",
    "statement": "theorem colex.singleton_lt_iff_lt {α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex < {s}.to_colex ↔ r < s",
    "theorem": "{α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex < {s}.to_colex ↔ r < s",
    "args": "{α : Type u_1} [linear_order α] {r s : α}",
    "doc_string": "Colex is an extension of the base ordering on α.",
    "kind": "theorem",
    "type": "{r}.to_colex < {s}.to_colex ↔ r < s"
  },
  {
    "name": "has_distrib_neg",
    "statement": "structure has_distrib_neg (α : Type u_1) [has_mul α] : Type u_1",
    "theorem": "(α : Type u_1) [has_mul α] : Type u_1",
    "args": "(α : Type u_1) [has_mul α]",
    "doc_string": " Typeclass for a negation operator that distributes across multiplication.  This is useful for dealing with submonoids of a ring that contain `-1` without having to duplicate lemmas.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "is_compact.inter_left",
    "statement": "theorem is_compact.inter_left {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)",
    "args": "{α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s)",
    "doc_string": "The intersection of a closed set and a compact set is a compact set.",
    "kind": "theorem",
    "type": "is_compact (s ∩ t)"
  },
  {
    "name": "exists_compact_superset",
    "statement": "theorem exists_compact_superset {α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K'",
    "theorem": "{α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K'",
    "args": "{α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K)",
    "doc_string": "In a locally compact space, every compact set is contained in the interior of a compact set.",
    "kind": "theorem",
    "type": "∃ (K' : set α), is_compact K' ∧ K ⊆ interior K'"
  },
  {
    "name": "znum.of_int'",
    "statement": "def znum.of_int'  : ℤ → znum",
    "theorem": " : ℤ → znum",
    "args": "",
    "doc_string": "Converts an `int` to a `znum`.",
    "kind": "def",
    "type": "ℤ → znum"
  },
  {
    "name": "Mod.regular",
    "statement": "def Mod.regular {C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] (A : Mon_ C) : Mod A",
    "theorem": "{C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] (A : Mon_ C) : Mod A",
    "args": "{C : Type u₁} [category_theory.category C] [category_theory.monoidal_category C] (A : Mon_ C)",
    "doc_string": "A monoid object as a module over itself.",
    "kind": "def",
    "type": "Mod A"
  },
  {
    "name": "list.lookmap",
    "statement": "def list.lookmap {α : Type u_1} (f : α → option α) : list α → list α",
    "theorem": "{α : Type u_1} (f : α → option α) : list α → list α",
    "args": "{α : Type u_1} (f : α → option α)",
    "doc_string": "`lookmap` is a combination of `lookup` and `filter_map`.  `lookmap f l` will apply `f : α → option α` to each element of the list,  replacing `a → b` at the first value `a` in the list such that `f a = some b`.",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "finpartition.is_equipartition",
    "statement": "def finpartition.is_equipartition {α : Type u_1} [decidable_eq α] {s : finset α} (P : finpartition s) : Prop",
    "theorem": "{α : Type u_1} [decidable_eq α] {s : finset α} (P : finpartition s) : Prop",
    "args": "{α : Type u_1} [decidable_eq α] {s : finset α} (P : finpartition s)",
    "doc_string": "An equipartition is a partition whose parts are all the same size, up to a difference of `1`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "mul_nonneg_of_three",
    "statement": "theorem mul_nonneg_of_three {α : Type u} [linear_ordered_ring α] (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a",
    "theorem": "{α : Type u} [linear_ordered_ring α] (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a",
    "args": "{α : Type u} [linear_ordered_ring α] (a b c : α)",
    "doc_string": "Out of three elements of a `linear_ordered_ring`, two must have the same sign.",
    "kind": "theorem",
    "type": "0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a"
  },
  {
    "name": "path.refl",
    "statement": "def path.refl {X : Type u_1} [topological_space X] (x : X) : path x x",
    "theorem": "{X : Type u_1} [topological_space X] (x : X) : path x x",
    "args": "{X : Type u_1} [topological_space X] (x : X)",
    "doc_string": "The constant path from a point to itself",
    "kind": "def",
    "type": "path x x"
  },
  {
    "name": "bdd_above.union",
    "statement": "theorem bdd_above.union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above s → bdd_above t → bdd_above (s ∪ t)",
    "theorem": "{γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above s → bdd_above t → bdd_above (s ∪ t)",
    "args": "{γ : Type w} [semilattice_sup γ] {s t : set γ}",
    "doc_string": "If `s` and `t` are bounded above sets in a `semilattice_sup`, then so is `s ∪ t`.",
    "kind": "theorem",
    "type": "bdd_above s → bdd_above t → bdd_above (s ∪ t)"
  },
  {
    "name": "bdd_below_union",
    "statement": "theorem bdd_below_union {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t",
    "theorem": "{γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t",
    "args": "{γ : Type w} [semilattice_inf γ] {s t : set γ}",
    "doc_string": "The union of two sets is bounded above if and only if each of the sets is.",
    "kind": "theorem",
    "type": "bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t"
  },
  {
    "name": "language.star",
    "statement": "def language.star {α : Type u_1} (l : language α) : language α",
    "theorem": "{α : Type u_1} (l : language α) : language α",
    "args": "{α : Type u_1} (l : language α)",
    "doc_string": "The star of a language `L` is the set of all strings which can be written by concatenating  strings from `L`.",
    "kind": "def",
    "type": "language α"
  },
  {
    "name": "algebraic_geometry.polynomial.image_of_Df",
    "statement": "def algebraic_geometry.polynomial.image_of_Df {R : Type u_1} [comm_ring R] (f : polynomial R) : set (prime_spectrum R)",
    "theorem": "{R : Type u_1} [comm_ring R] (f : polynomial R) : set (prime_spectrum R)",
    "args": "{R : Type u_1} [comm_ring R] (f : polynomial R)",
    "doc_string": " Given a polynomial `f ∈ R[x]`, `image_of_Df` is the subset of `Spec R` where at least one of the coefficients of `f` does not vanish.  Lemma `image_of_Df_eq_comap_C_compl_zero_locus` proves that `image_of_Df` is the image of `(zero_locus {f})ᶜ` under the morphism `comap C : Spec R[x] → Spec R`.",
    "kind": "def",
    "type": "set (prime_spectrum R)"
  },
  {
    "name": "squarefree",
    "statement": "def squarefree {R : Type u_1} [monoid R] (r : R) : Prop",
    "theorem": "{R : Type u_1} [monoid R] (r : R) : Prop",
    "args": "{R : Type u_1} [monoid R] (r : R)",
    "doc_string": "An element of a monoid is squarefree if the only squares that  divide it are the squares of units.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "module.free.finrank_pi",
    "statement": "theorem module.free.finrank_pi (R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] : finite_dimensional.finrank R (ι → R) = fintype.card ι",
    "theorem": "(R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] : finite_dimensional.finrank R (ι → R) = fintype.card ι",
    "args": "(R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι]",
    "doc_string": "The finrank of `(ι → R)` is `fintype.card ι`.",
    "kind": "theorem",
    "type": "finite_dimensional.finrank R (ι → R) = fintype.card ι"
  },
  {
    "name": "category_theory.limits.limits_from_equalizers_and_products",
    "statement": "theorem category_theory.limits.limits_from_equalizers_and_products {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C]",
    "doc_string": "Any category with products and equalizers has all limits.  See <https://stacks.math.columbia.edu/tag/002N>.",
    "kind": "theorem",
    "type": "category_theory.limits.has_limits C"
  },
  {
    "name": "category_theory.limits.has_binary_products_of_has_limit_pair",
    "statement": "theorem category_theory.limits.has_binary_products_of_has_limit_pair (C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C",
    "theorem": "(C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_products C",
    "args": "(C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_limit (category_theory.limits.pair X Y)]",
    "doc_string": "If `C` has all limits of diagrams `pair X Y`, then it has all binary products",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_products C"
  },
  {
    "name": "mul_le_cancellable",
    "statement": "def mul_le_cancellable {α : Type u_1} [has_mul α] [has_le α] (a : α) : Prop",
    "theorem": "{α : Type u_1} [has_mul α] [has_le α] (a : α) : Prop",
    "args": "{α : Type u_1} [has_mul α] [has_le α] (a : α)",
    "doc_string": "An element `a : α` is `mul_le_cancellable` if `x ↦ a * x` is order-reflecting. We will make a separate version of many lemmas that require `[contravariant_class α α (*) (≤)]` with `mul_le_cancellable` assumptions instead. These lemmas can then be instantiated to specific types, like `ennreal`, where we can replace the assumption `add_le_cancellable x` by `x ≠ ∞`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.monad.forget_creates_limits",
    "statement": "def category_theory.monad.forget_creates_limits {C : Type u₁} [category_theory.category C] {T : category_theory.monad C} : category_theory.creates_limits_of_size T.forget",
    "theorem": "{C : Type u₁} [category_theory.category C] {T : category_theory.monad C} : category_theory.creates_limits_of_size T.forget",
    "args": "{C : Type u₁} [category_theory.category C] {T : category_theory.monad C}",
    "doc_string": "The forgetful functor from the Eilenberg-Moore category creates limits.",
    "kind": "def",
    "type": "category_theory.creates_limits_of_size T.forget"
  },
  {
    "name": "Ring.of",
    "statement": "def Ring.of (R : Type u) [ring R] : Ring",
    "theorem": "(R : Type u) [ring R] : Ring",
    "args": "(R : Type u) [ring R]",
    "doc_string": "Construct a bundled Ring from the underlying type and typeclass.",
    "kind": "def",
    "type": "Ring"
  },
  {
    "name": "linarith.linarith_structure",
    "statement": "structure linarith.linarith_structure  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The state for the elimination monad. * `max_var`: the largest variable index that has not been eliminated. * `comps`: a set of comparisons  The elimination procedure proceeds by eliminating variable `v` from `comps` progressively in decreasing order.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "finset.mul_one_class",
    "statement": "def finset.mul_one_class {α : Type u_2} [decidable_eq α] [mul_one_class α] : mul_one_class (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [mul_one_class α] : mul_one_class (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [mul_one_class α]",
    "doc_string": "`finset α` is a `mul_one_class` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "mul_one_class (finset α)"
  },
  {
    "name": "finset.filter_false_of_mem",
    "statement": "theorem finset.filter_false_of_mem {α : Type u_1} {p : α → Prop} [decidable_pred p] {s : finset α} (h : ∀ (x : α), x ∈ s → ¬p x) : finset.filter p s = ∅",
    "theorem": "{α : Type u_1} {p : α → Prop} [decidable_pred p] {s : finset α} (h : ∀ (x : α), x ∈ s → ¬p x) : finset.filter p s = ∅",
    "args": "{α : Type u_1} {p : α → Prop} [decidable_pred p] {s : finset α} (h : ∀ (x : α), x ∈ s → ¬p x)",
    "doc_string": "If all elements of a `finset` fail to satisfy the predicate `p`, `s.filter p` is `∅`.",
    "kind": "theorem",
    "type": "finset.filter p s = ∅"
  },
  {
    "name": "distrib_lattice",
    "statement": "structure distrib_lattice (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " A distributive lattice is a lattice that satisfies any of four equivalent distributive properties (of `sup` over `inf` or `inf` over `sup`, on the left or right).  The definition here chooses `le_sup_inf`: `(x ⊔ y) ⊓ (x ⊔ z) ≤ x ⊔ (y ⊓ z)`.  A classic example of a distributive lattice is the lattice of subsets of a set, and in fact this example is generic in the sense that every distributive lattice is realizable as a sublattice of a powerset lattice.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "is_of_fin_add_order",
    "statement": "def is_of_fin_add_order {A : Type v} [add_monoid A] (a : A) : Prop",
    "theorem": "{A : Type v} [add_monoid A] (a : A) : Prop",
    "args": "{A : Type v} [add_monoid A] (a : A)",
    "doc_string": " `is_of_fin_add_order` is a predicate on an element `a` of an additive monoid to be of finite order, i.e. there exists `n ≥ 1` such that `n • a = 0`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.eq_zero_of_dvd_of_lt",
    "statement": "theorem nat.eq_zero_of_dvd_of_lt {a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0",
    "theorem": "{a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0",
    "args": "{a b : ℕ} (w : a ∣ b) (h : b < a)",
    "doc_string": " If a small natural number is divisible by a larger natural number, the small number is zero.",
    "kind": "theorem",
    "type": "b = 0"
  },
  {
    "name": "add_commute.eq",
    "statement": "theorem add_commute.eq {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a",
    "theorem": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : a + b = b + a",
    "args": "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b)",
    "doc_string": "Equality behind `add_commute a b`; useful for rewriting.",
    "kind": "theorem",
    "type": "a + b = b + a"
  },
  {
    "name": "pseudo_epimorphism",
    "statement": "structure pseudo_epimorphism (α : Type u_6) (β : Type u_7) [preorder α] [preorder β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β]",
    "doc_string": "The type of pseudo-epimorphisms, aka p-morphisms, aka bounded maps, from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "subsemigroup",
    "statement": "structure subsemigroup (M : Type u_4) [has_mul M] : Type u_4",
    "theorem": "(M : Type u_4) [has_mul M] : Type u_4",
    "args": "(M : Type u_4) [has_mul M]",
    "doc_string": "A subsemigroup of a magma `M` is a subset closed under multiplication.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "monotone",
    "statement": "def monotone {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β)",
    "doc_string": "A function `f` is monotone if `a ≤ b` implies `f a ≤ f b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_action",
    "statement": "structure add_action (G : Type u_10) (P : Type u_11) [add_monoid G] : Type (max u_10 u_11)",
    "theorem": "(G : Type u_10) (P : Type u_11) [add_monoid G] : Type (max u_10 u_11)",
    "args": "(G : Type u_10) (P : Type u_11) [add_monoid G]",
    "doc_string": "Type class for additive monoid actions.",
    "kind": "structure",
    "type": "Type (max u_10 u_11)"
  },
  {
    "name": "list.inth",
    "statement": "def list.inth {α : Type u_1} [h : inhabited α] (l : list α) (n : ℕ) : α",
    "theorem": "{α : Type u_1} [h : inhabited α] (l : list α) (n : ℕ) : α",
    "args": "{α : Type u_1} [h : inhabited α] (l : list α) (n : ℕ)",
    "doc_string": "\"inhabited\" `nth` function: returns `default` instead of `none` in the case  that the index is out of bounds.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "list.to_chunks",
    "statement": "def list.to_chunks {α : Type u_1} : ℕ → list α → list (list α)",
    "theorem": "{α : Type u_1} : ℕ → list α → list (list α)",
    "args": "{α : Type u_1}",
    "doc_string": "`xs.to_chunks n` splits the list into sublists of size at most `n`, such that `(xs.to_chunks n).join = xs`.  ```lean [1, 2, 3, 4, 5, 6, 7, 8].to_chunks 10 = [[1, 2, 3, 4, 5, 6, 7, 8]] [1, 2, 3, 4, 5, 6, 7, 8].to_chunks 3 = [[1, 2, 3], [4, 5, 6], [7, 8]] [1, 2, 3, 4, 5, 6, 7, 8].to_chunks 2 = [[1, 2], [3, 4], [5, 6], [7, 8]] [1, 2, 3, 4, 5, 6, 7, 8].to_chunks 0 = [[1, 2, 3, 4, 5, 6, 7, 8]] ```",
    "kind": "def",
    "type": "ℕ → list α → list (list α)"
  },
  {
    "name": "lattice_ordered_comm_group.has_zero_lattice_has_neg_part",
    "statement": "def lattice_ordered_comm_group.has_zero_lattice_has_neg_part {α : Type u} [lattice α] [add_comm_group α] : has_neg_part α",
    "theorem": "{α : Type u} [lattice α] [add_comm_group α] : has_neg_part α",
    "args": "{α : Type u} [lattice α] [add_comm_group α]",
    "doc_string": "Let `α` be a lattice ordered commutative group with identity `0`. For an element `a` of type `α`, the element `(-a) ⊔ 0` is said to be the *negative component* of `a`, denoted `a⁻`.",
    "kind": "def",
    "type": "has_neg_part α"
  },
  {
    "name": "subspace",
    "statement": "def subspace (R : Type u) (M : Type v) [field R] [add_comm_group M] [module R M] : Type v",
    "theorem": "(R : Type u) (M : Type v) [field R] [add_comm_group M] [module R M] : Type v",
    "args": "(R : Type u) (M : Type v) [field R] [add_comm_group M] [module R M]",
    "doc_string": "Subspace of a vector space. Defined to equal `submodule`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "lazy_list.filter",
    "statement": "def lazy_list.filter {α : Type u} (p : α → Prop) [decidable_pred p] : lazy_list α → lazy_list α",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] : lazy_list α → lazy_list α",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p]",
    "doc_string": "The lazy list of all elements satisfying the predicate. If the lazy list is infinite and none of the elements satisfy the predicate, then this function will not terminate.",
    "kind": "def",
    "type": "lazy_list α → lazy_list α"
  },
  {
    "name": "tensor_power",
    "statement": "def tensor_power (R : Type u_1) (n : ℕ) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)",
    "theorem": "(R : Type u_1) (n : ℕ) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)",
    "args": "(R : Type u_1) (n : ℕ) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": " Homogenous tensor powers $M^{\\otimes n}$. `⨂[R]^n M` is a shorthand for `⨂[R] (i : fin n), M`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "category_theory.sieve.Inf",
    "statement": "def category_theory.sieve.Inf {C : Type u₁} [category_theory.category C] {X : C} (𝒮 : set (category_theory.sieve X)) : category_theory.sieve X",
    "theorem": "{C : Type u₁} [category_theory.category C] {X : C} (𝒮 : set (category_theory.sieve X)) : category_theory.sieve X",
    "args": "{C : Type u₁} [category_theory.category C] {X : C} (𝒮 : set (category_theory.sieve X))",
    "doc_string": "The infimum of a collection of sieves: the intersection of them all.",
    "kind": "def",
    "type": "category_theory.sieve X"
  },
  {
    "name": "topological_lattice",
    "statement": "structure topological_lattice (L : Type u_1) [topological_space L] [lattice L] : Type",
    "theorem": "(L : Type u_1) [topological_space L] [lattice L] : Type",
    "args": "(L : Type u_1) [topological_space L] [lattice L]",
    "doc_string": "Let `L` be a lattice equipped with a topology such that `L` has continuous infimum and supremum. Then `L` is said to be a *topological lattice*.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "filter.at_bot",
    "statement": "def filter.at_bot {α : Type u_3} [preorder α] : filter α",
    "theorem": "{α : Type u_3} [preorder α] : filter α",
    "args": "{α : Type u_3} [preorder α]",
    "doc_string": "`at_bot` is the filter representing the limit `→ -∞` on an ordered set.  It is generated by the collection of down-sets `{b | b ≤ a}`.  (The preorder need not have a bottom element for this to be well defined,  and indeed is trivial when a bottom element exists.)",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "Group.of",
    "statement": "def Group.of (X : Type u) [group X] : Group",
    "theorem": "(X : Type u) [group X] : Group",
    "args": "(X : Type u) [group X]",
    "doc_string": "Construct a bundled `Group` from the underlying type and typeclass.",
    "kind": "def",
    "type": "Group"
  },
  {
    "name": "ordnode.find_min'",
    "statement": "def ordnode.find_min' {α : Type u} : ordnode α → α → α",
    "theorem": "{α : Type u} : ordnode α → α → α",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Return the minimum element of the tree, or the provided default value.      find_min' 37 {1, 2, 3} = 1     find_min' 37 ∅ = 37",
    "kind": "def",
    "type": "ordnode α → α → α"
  },
  {
    "name": "tactic.ring_exp.eval_info",
    "statement": "structure tactic.ring_exp.eval_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Stores the information needed in the `eval` function and its dependencies, so they can (re)construct expressions.  The `eval_info` structure stores this information for one type, and the `context` combines the two types, one for bases and one for exponents.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "field.power_basis_of_finite_of_separable",
    "statement": "def field.power_basis_of_finite_of_separable (F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] [is_separable F E] : power_basis F E",
    "theorem": "(F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] [is_separable F E] : power_basis F E",
    "args": "(F : Type u_1) (E : Type u_2) [field F] [field E] [algebra F E] [finite_dimensional F E] [is_separable F E]",
    "doc_string": " Alternative phrasing of primitive element theorem: a finite separable field extension has a basis `1, α, α^2, ..., α^n`.  See also `exists_primitive_element`.",
    "kind": "def",
    "type": "power_basis F E"
  },
  {
    "name": "first_order.language.Theory.is_finitely_satisfiable",
    "statement": "def first_order.language.Theory.is_finitely_satisfiable {L : first_order.language} (T : L.Theory) : Prop",
    "theorem": "{L : first_order.language} (T : L.Theory) : Prop",
    "args": "{L : first_order.language} (T : L.Theory)",
    "doc_string": "A theory is finitely satisfiable if all of its finite subtheories are satisfiable.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "set.Ioi_subset_Ioi",
    "statement": "theorem set.Ioi_subset_Ioi {α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ioi a",
    "theorem": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ioi a",
    "args": "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b)",
    "doc_string": " If `a ≤ b`, then `(b, +∞) ⊆ (a, +∞)`. In preorders, this is just an implication. If you need the equivalence in linear orders, use `Ioi_subset_Ioi_iff`.",
    "kind": "theorem",
    "type": "set.Ioi b ⊆ set.Ioi a"
  },
  {
    "name": "has_sbtw.sbtw.cyclic_left",
    "statement": "theorem has_sbtw.sbtw.cyclic_left {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw b c a",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of sbtw_cyclic_left`.",
    "kind": "theorem",
    "type": "has_sbtw.sbtw b c a"
  },
  {
    "name": "ordinal.nfp_bfamily",
    "statement": "def ordinal.nfp_bfamily (o : ordinal) (f : Π (b : ordinal), b < o → ordinal → ordinal) : ordinal → ordinal",
    "theorem": "(o : ordinal) (f : Π (b : ordinal), b < o → ordinal → ordinal) : ordinal → ordinal",
    "args": "(o : ordinal) (f : Π (b : ordinal), b < o → ordinal → ordinal)",
    "doc_string": "The next common fixed point, at least `a`, for a family of normal functions indexed by ordinals.",
    "kind": "def",
    "type": "ordinal → ordinal"
  },
  {
    "name": "num.to_znum",
    "statement": "def num.to_znum  : num → znum",
    "theorem": " : num → znum",
    "args": "",
    "doc_string": "Converts a `num` to a `znum`.",
    "kind": "def",
    "type": "num → znum"
  },
  {
    "name": "num.one_bits",
    "statement": "def num.one_bits  : num → list ℕ",
    "theorem": " : num → list ℕ",
    "args": "",
    "doc_string": "`n.one_bits` is the list of indices of active bits in the binary representation of `n`.",
    "kind": "def",
    "type": "num → list ℕ"
  },
  {
    "name": "FinBoolAlg",
    "statement": "structure FinBoolAlg  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of finite boolean algebras with bounded lattice morphisms.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "circular_preorder",
    "statement": "structure circular_preorder (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " A circular preorder is the analogue of a preorder where you can loop around. `≤` and `<` are replaced by ternary relations `btw` and `sbtw`. `btw` is reflexive and cyclic. `sbtw` is transitive.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "principal_ideal_ring.factors",
    "statement": "def principal_ideal_ring.factors {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] (a : R) : multiset R",
    "theorem": "{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] (a : R) : multiset R",
    "args": "{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] (a : R)",
    "doc_string": "`factors a` is a multiset of irreducible elements whose product is `a`, up to units",
    "kind": "def",
    "type": "multiset R"
  },
  {
    "name": "minpoly.ne_zero",
    "statement": "theorem minpoly.ne_zero {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} [nontrivial A] (hx : is_integral A x) : minpoly A x ≠ 0",
    "theorem": "{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} [nontrivial A] (hx : is_integral A x) : minpoly A x ≠ 0",
    "args": "{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] {x : B} [nontrivial A] (hx : is_integral A x)",
    "doc_string": "A minimal polynomial is nonzero.",
    "kind": "theorem",
    "type": "minpoly A x ≠ 0"
  },
  {
    "name": "composition_series.bot",
    "statement": "def composition_series.bot {X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X",
    "theorem": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : X",
    "args": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X)",
    "doc_string": "The smallest element of a `composition_series`",
    "kind": "def",
    "type": "X"
  },
  {
    "name": "add_submonoid.center",
    "statement": "def add_submonoid.center (M : Type u_1) [add_monoid M] : add_submonoid M",
    "theorem": "(M : Type u_1) [add_monoid M] : add_submonoid M",
    "args": "(M : Type u_1) [add_monoid M]",
    "doc_string": "The center of a monoid `M` is the set of elements that commute with everything in `M`",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "bounded_lattice_hom.id",
    "statement": "def bounded_lattice_hom.id (α : Type u_3) [lattice α] [bounded_order α] : bounded_lattice_hom α α",
    "theorem": "(α : Type u_3) [lattice α] [bounded_order α] : bounded_lattice_hom α α",
    "args": "(α : Type u_3) [lattice α] [bounded_order α]",
    "doc_string": "`id` as a `bounded_lattice_hom`.",
    "kind": "def",
    "type": "bounded_lattice_hom α α"
  },
  {
    "name": "multiset.pi.empty",
    "statement": "def multiset.pi.empty {α : Type u_1} (δ : α → Type u_2) (a : α) (H : a ∈ 0) : δ a",
    "theorem": "{α : Type u_1} (δ : α → Type u_2) (a : α) (H : a ∈ 0) : δ a",
    "args": "{α : Type u_1} (δ : α → Type u_2) (a : α) (H : a ∈ 0)",
    "doc_string": " Given `δ : α → Type*`, `pi.empty δ` is the trivial dependent function out of the empty multiset.",
    "kind": "def",
    "type": "δ a"
  },
  {
    "name": "Class.Union",
    "statement": "def Class.Union (x : Class) : Class",
    "theorem": "(x : Class) : Class",
    "args": "(x : Class)",
    "doc_string": "The union of a class is the class of all members of ZFC sets in the class",
    "kind": "def",
    "type": "Class"
  },
  {
    "name": "nat.clog",
    "statement": "def nat.clog (b : ℕ) : ℕ → ℕ",
    "theorem": "(b : ℕ) : ℕ → ℕ",
    "args": "(b : ℕ)",
    "doc_string": " `clog b n`, is the upper logarithm of natural number `n` in base `b`. It returns the smallest `k : ℕ` such that `n ≤ b^k`, so if `b^k = n`, it returns exactly `k`.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "filter.rtendsto'",
    "statement": "def filter.rtendsto' {α : Type u} {β : Type v} (r : rel α β) (l₁ : filter α) (l₂ : filter β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (r : rel α β) (l₁ : filter α) (l₂ : filter β) : Prop",
    "args": "{α : Type u} {β : Type v} (r : rel α β) (l₁ : filter α) (l₂ : filter β)",
    "doc_string": " Generic \"limit of a relation\" predicate. `rtendsto' r l₁ l₂` asserts that for every `l₂`-neighborhood `a`, the `r`-preimage of `a` is an `l₁`-neighborhood. One generalization of `filter.tendsto` to relations.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "CompHaus.to_Profinite_obj",
    "statement": "def CompHaus.to_Profinite_obj (X : CompHaus) : Profinite",
    "theorem": "(X : CompHaus) : Profinite",
    "args": "(X : CompHaus)",
    "doc_string": "(Implementation) The object part of the connected_components functor from compact Hausdorff spaces to Profinite spaces, given by quotienting a space by its connected components. See: https://stacks.math.columbia.edu/tag/0900",
    "kind": "def",
    "type": "Profinite"
  },
  {
    "name": "add_subgroup.has_inf",
    "statement": "def add_subgroup.has_inf {G : Type u_1} [add_group G] : has_inf (add_subgroup G)",
    "theorem": "{G : Type u_1} [add_group G] : has_inf (add_subgroup G)",
    "args": "{G : Type u_1} [add_group G]",
    "doc_string": "The inf of two `add_subgroups`s is their intersection.",
    "kind": "def",
    "type": "has_inf (add_subgroup G)"
  },
  {
    "name": "comm_group.nilpotency_class_le_one",
    "statement": "theorem comm_group.nilpotency_class_le_one {G : Type u_1} [comm_group G] : group.nilpotency_class G ≤ 1",
    "theorem": "{G : Type u_1} [comm_group G] : group.nilpotency_class G ≤ 1",
    "args": "{G : Type u_1} [comm_group G]",
    "doc_string": "Abelian groups have nilpotency class at most one",
    "kind": "theorem",
    "type": "group.nilpotency_class G ≤ 1"
  },
  {
    "name": "neg_lt_of_neg_lt",
    "statement": "theorem neg_lt_of_neg_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : -a < b → -b < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : -a < b → -b < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the forward direction of inv_lt'`.",
    "kind": "theorem",
    "type": "-a < b → -b < a"
  },
  {
    "name": "euclidean_domain.gcd_b",
    "statement": "def euclidean_domain.gcd_b {R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R",
    "theorem": "{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R",
    "args": "{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R)",
    "doc_string": "The extended GCD `b` value in the equation `gcd x y = x * a + y * b`.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "subalgebra.to_submonoid",
    "statement": "def subalgebra.to_submonoid {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submonoid A",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submonoid A",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A)",
    "doc_string": "The projection from a subalgebra of `A` to a submonoid of `A`.",
    "kind": "def",
    "type": "submonoid A"
  },
  {
    "name": "BoundedDistribLattice.to_BoundedLattice",
    "statement": "def BoundedDistribLattice.to_BoundedLattice (X : BoundedDistribLattice) : BoundedLattice",
    "theorem": "(X : BoundedDistribLattice) : BoundedLattice",
    "args": "(X : BoundedDistribLattice)",
    "doc_string": "Turn a `BoundedDistribLattice` into a `BoundedLattice` by forgetting it is distributive.",
    "kind": "def",
    "type": "BoundedLattice"
  },
  {
    "name": "category_theory.essentially_small",
    "statement": "structure category_theory.essentially_small (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": " A category is `essentially_small.{w}` if there exists an equivalence to some `S : Type w` with `[small_category S]`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "mul_action.fixed_points",
    "statement": "def mul_action.fixed_points (α : Type u) (β : Type v) [monoid α] [mul_action α β] : set β",
    "theorem": "(α : Type u) (β : Type v) [monoid α] [mul_action α β] : set β",
    "args": "(α : Type u) (β : Type v) [monoid α] [mul_action α β]",
    "doc_string": "The set of elements fixed under the whole action.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "set.cIoo",
    "statement": "def set.cIoo {α : Type u_1} [circular_preorder α] (a b : α) : set α",
    "theorem": "{α : Type u_1} [circular_preorder α] (a b : α) : set α",
    "args": "{α : Type u_1} [circular_preorder α] (a b : α)",
    "doc_string": "Open-open circular interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "composition_series.erase_top",
    "statement": "def composition_series.erase_top {X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : composition_series X",
    "theorem": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : composition_series X",
    "args": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X)",
    "doc_string": " Remove the largest element from a `composition_series`. If the series `s` has length zero, then `s.erase_top = s`",
    "kind": "def",
    "type": "composition_series X"
  },
  {
    "name": "fin.update_cons_zero",
    "statement": "theorem fin.update_cons_zero {n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (z : α 0) : function.update (fin.cons x p) 0 z = fin.cons z p",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (z : α 0) : function.update (fin.cons x p) 0 z = fin.cons z p",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (z : α 0)",
    "doc_string": " Adding an element at the beginning of a tuple and then updating it amounts to adding it directly.",
    "kind": "theorem",
    "type": "function.update (fin.cons x p) 0 z = fin.cons z p"
  },
  {
    "name": "add_subsemigroup.closure",
    "statement": "def add_subsemigroup.closure {M : Type u_1} [has_add M] (s : set M) : add_subsemigroup M",
    "theorem": "{M : Type u_1} [has_add M] (s : set M) : add_subsemigroup M",
    "args": "{M : Type u_1} [has_add M] (s : set M)",
    "doc_string": "The `add_subsemigroup` generated by a set",
    "kind": "def",
    "type": "add_subsemigroup M"
  },
  {
    "name": "filter.has_basis",
    "statement": "structure filter.has_basis {α : Type u_1} {ι : Sort u_4} (l : filter α) (p : ι → Prop) (s : ι → set α) : Prop",
    "theorem": "{α : Type u_1} {ι : Sort u_4} (l : filter α) (p : ι → Prop) (s : ι → set α) : Prop",
    "args": "{α : Type u_1} {ι : Sort u_4} (l : filter α) (p : ι → Prop) (s : ι → set α)",
    "doc_string": " We say that a filter `l` has a basis `s : ι → set α` bounded by `p : ι → Prop`, if `t ∈ l` if and only if `t` includes `s i` for some `i` such that `p i`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordered_comm_group",
    "statement": "structure ordered_comm_group (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " An ordered commutative group is an commutative group with a partial order in which multiplication is strictly monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "name.map_prefix",
    "statement": "def name.map_prefix (f : name → option name) : name → name",
    "theorem": "(f : name → option name) : name → name",
    "args": "(f : name → option name)",
    "doc_string": " Find the largest prefix `n` of a `name` such that `f n ≠ none`, then replace this prefix with the value of `f n`.",
    "kind": "def",
    "type": "name → name"
  },
  {
    "name": "fintype.to_complete_lattice",
    "statement": "def fintype.to_complete_lattice (α : Type u_2) [fintype α] [lattice α] [bounded_order α] : complete_lattice α",
    "theorem": "(α : Type u_2) [fintype α] [lattice α] [bounded_order α] : complete_lattice α",
    "args": "(α : Type u_2) [fintype α] [lattice α] [bounded_order α]",
    "doc_string": "A finite bounded lattice is complete.",
    "kind": "def",
    "type": "complete_lattice α"
  },
  {
    "name": "znum",
    "statement": "inductive znum  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Representation of integers using trichotomy around zero.      13 = 1101(base 2) = pos (bit1 (bit0 (bit1 one)))     -13 = -1101(base 2) = neg (bit1 (bit0 (bit1 one)))",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "galois_connection.lift_order_top",
    "statement": "def galois_connection.lift_order_top {α : Type u_1} {β : Type u_2} [partial_order α] [preorder β] [order_top β] {l : α → β} {u : β → α} (gc : galois_connection l u) : order_top α",
    "theorem": "{α : Type u_1} {β : Type u_2} [partial_order α] [preorder β] [order_top β] {l : α → β} {u : β → α} (gc : galois_connection l u) : order_top α",
    "args": "{α : Type u_1} {β : Type u_2} [partial_order α] [preorder β] [order_top β] {l : α → β} {u : β → α} (gc : galois_connection l u)",
    "doc_string": "Lift the top along a Galois connection",
    "kind": "def",
    "type": "order_top α"
  },
  {
    "name": "is_local_extr_on",
    "statement": "def is_local_extr_on {α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α)",
    "doc_string": "`is_local_extr_on f s a` means `is_local_min_on f s a ∨ is_local_max_on f s a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_con.has_le",
    "statement": "def add_con.has_le {M : Type u_1} [has_add M] : has_le (add_con M)",
    "theorem": "{M : Type u_1} [has_add M] : has_le (add_con M)",
    "args": "{M : Type u_1} [has_add M]",
    "doc_string": "For additive congruence relations `c, d` on a type `M` with an addition, `c ≤ d` iff `∀ x y ∈ M`, `x` is related to `y` by `d` if `x` is related to `y` by `c`.",
    "kind": "def",
    "type": "has_le (add_con M)"
  },
  {
    "name": "category_theory.Free",
    "statement": "def category_theory.Free (R : Type u_1) (C : Type u) : Type u",
    "theorem": "(R : Type u_1) (C : Type u) : Type u",
    "args": "(R : Type u_1) (C : Type u)",
    "doc_string": "`Free R C` is a type synonym for `C`, which, given `[comm_ring R]` and `[category C]`, we will equip with a category structure where the morphisms are formal `R`-linear combinations of the morphisms in `C`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "subsingleton_iff_zero_eq_one",
    "statement": "theorem subsingleton_iff_zero_eq_one {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 ↔ subsingleton M₀",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 ↔ subsingleton M₀",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀]",
    "doc_string": " In a monoid with zero, zero equals one if and only if all elements of that semiring are equal.",
    "kind": "theorem",
    "type": "0 = 1 ↔ subsingleton M₀"
  },
  {
    "name": "ctop.realizer",
    "statement": "structure ctop.realizer (α : Type u_5) [T : topological_space α] : Type (max u_5 (u_6+1))",
    "theorem": "(α : Type u_5) [T : topological_space α] : Type (max u_5 (u_6+1))",
    "args": "(α : Type u_5) [T : topological_space α]",
    "doc_string": "A `ctop` realizer for the topological space `T` is a `ctop`  which generates `T`.",
    "kind": "structure",
    "type": "Type (max u_5 (u_6+1))"
  },
  {
    "name": "computation.map",
    "statement": "def computation.map {α : Type u} {β : Type v} (f : α → β) : computation α → computation β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : computation α → computation β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": "Map a function on the result of a computation.",
    "kind": "def",
    "type": "computation α → computation β"
  },
  {
    "name": "category_theory.grothendieck_topology.right_ore_condition",
    "statement": "def category_theory.grothendieck_topology.right_ore_condition (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category satisfies the right Ore condition if any span can be completed to a commutative square. NB. Any category with pullbacks obviously satisfies the right Ore condition, see `right_ore_of_pullbacks`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "set.finrank",
    "statement": "def set.finrank (K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : set V) : ℕ",
    "theorem": "(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : set V) : ℕ",
    "args": "(K : Type u) {V : Type v} [division_ring K] [add_comm_group V] [module K V] (s : set V)",
    "doc_string": "The rank of a set of vectors as a natural number.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "category_theory.limits.pair_function",
    "statement": "def category_theory.limits.pair_function {C : Type u} (X Y : C) : category_theory.limits.walking_pair → C",
    "theorem": "{C : Type u} (X Y : C) : category_theory.limits.walking_pair → C",
    "args": "{C : Type u} (X Y : C)",
    "doc_string": "The function on the walking pair, sending the two points to `X` and `Y`.",
    "kind": "def",
    "type": "category_theory.limits.walking_pair → C"
  },
  {
    "name": "sym2.map",
    "statement": "def sym2.map {α : Type u_1} {β : Type u_2} (f : α → β) : sym2 α → sym2 β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) : sym2 α → sym2 β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β)",
    "doc_string": "The functor `sym2` is functorial, and this function constructs the induced maps.",
    "kind": "def",
    "type": "sym2 α → sym2 β"
  },
  {
    "name": "non_unital_alg_hom",
    "statement": "structure non_unital_alg_hom (R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : Type (max v w)",
    "theorem": "(R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B] : Type (max v w)",
    "args": "(R : Type u) (A : Type v) (B : Type w) [monoid R] [non_unital_non_assoc_semiring A] [distrib_mul_action R A] [non_unital_non_assoc_semiring B] [distrib_mul_action R B]",
    "doc_string": " A morphism respecting addition, multiplication, and scalar multiplication. When these arise from algebra structures, this is the same as a not-necessarily-unital morphism of algebras.",
    "kind": "structure",
    "type": "Type (max v w)"
  },
  {
    "name": "setoid.comap",
    "statement": "def setoid.comap {α : Type u_1} {β : Type u_2} (f : α → β) (r : setoid β) : setoid α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (r : setoid β) : setoid α",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (r : setoid β)",
    "doc_string": " Given a function `f : α → β`, an equivalence relation `r` on `β` induces an equivalence relation on `α` defined by '`x ≈ y` iff `f(x)` is related to `f(y)` by `r`'.  See note [reducible non-instances].",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "opt_param",
    "statement": "def opt_param (α : Sort u) (default : α) : Sort u",
    "theorem": "(α : Sort u) (default : α) : Sort u",
    "args": "(α : Sort u) (default : α)",
    "doc_string": "Gadget for optional parameter support.",
    "kind": "def",
    "type": "Sort u"
  },
  {
    "name": "bitvec.of_int",
    "statement": "def bitvec.of_int (n : ℕ) : ℤ → bitvec n.succ",
    "theorem": "(n : ℕ) : ℤ → bitvec n.succ",
    "args": "(n : ℕ)",
    "doc_string": "Create a bitvector in the two's complement representation from an `int`",
    "kind": "def",
    "type": "ℤ → bitvec n.succ"
  },
  {
    "name": "is_coatomistic",
    "statement": "structure is_coatomistic (α : Type u_1) [complete_lattice α] : Prop",
    "theorem": "(α : Type u_1) [complete_lattice α] : Prop",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": "A lattice is coatomistic iff every element is an `Inf` of a set of coatoms.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "padic_norm.is_absolute_value",
    "statement": "def padic_norm.is_absolute_value (p : ℕ) [hp : fact (nat.prime p)] : is_absolute_value (padic_norm p)",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : is_absolute_value (padic_norm p)",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "The p-adic norm is an absolute value: positive-definite and multiplicative, satisfying the triangle inequality.",
    "kind": "def",
    "type": "is_absolute_value (padic_norm p)"
  },
  {
    "name": "computation.rmap",
    "statement": "def computation.rmap {α : Type u} {β : Type v} {γ : Type w} (f : β → γ) : α ⊕ β → α ⊕ γ",
    "theorem": "{α : Type u} {β : Type v} {γ : Type w} (f : β → γ) : α ⊕ β → α ⊕ γ",
    "args": "{α : Type u} {β : Type v} {γ : Type w} (f : β → γ)",
    "doc_string": "right map of `⊕`",
    "kind": "def",
    "type": "α ⊕ β → α ⊕ γ"
  },
  {
    "name": "rack.to_envel_group",
    "statement": "def rack.to_envel_group (R : Type u_1) [rack R] : shelf_hom R (quandle.conj (rack.envel_group R))",
    "theorem": "(R : Type u_1) [rack R] : shelf_hom R (quandle.conj (rack.envel_group R))",
    "args": "(R : Type u_1) [rack R]",
    "doc_string": "The canonical homomorphism from a rack to its enveloping group. Satisfies universal properties given by `to_envel_group.map` and `to_envel_group.univ`.",
    "kind": "def",
    "type": "shelf_hom R (quandle.conj (rack.envel_group R))"
  },
  {
    "name": "sigma.lex",
    "statement": "inductive sigma.lex {ι : Type u_1} {α : ι → Type u_2} (r : ι → ι → Prop) (s : Π (i : ι), α i → α i → Prop) (a b : Σ (i : ι), α i) : Prop",
    "theorem": "{ι : Type u_1} {α : ι → Type u_2} (r : ι → ι → Prop) (s : Π (i : ι), α i → α i → Prop) (a b : Σ (i : ι), α i) : Prop",
    "args": "{ι : Type u_1} {α : ι → Type u_2} (r : ι → ι → Prop) (s : Π (i : ι), α i → α i → Prop) (a b : Σ (i : ι), α i)",
    "doc_string": " The lexicographical order on a sigma type. It takes in a relation on the index type and a relation for each summand. `a` is related to `b` iff their summands are related or they are in the same summand and are related through the summand's relation.",
    "kind": "inductive",
    "type": "Prop"
  },
  {
    "name": "is_min",
    "statement": "def is_min {α : Type u_1} [has_le α] (a : α) : Prop",
    "theorem": "{α : Type u_1} [has_le α] (a : α) : Prop",
    "args": "{α : Type u_1} [has_le α] (a : α)",
    "doc_string": " `a` is a minimal element of `α` if no element is strictly less than it. We spell it without `<` to avoid having to convert between `≤` and `<`. Instead, `is_min_iff_forall_not_lt` does the conversion.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "measure_theory.measure.partial_order",
    "statement": "def measure_theory.measure.partial_order {α : Type u_1} [measurable_space α] : partial_order (measure_theory.measure α)",
    "theorem": "{α : Type u_1} [measurable_space α] : partial_order (measure_theory.measure α)",
    "args": "{α : Type u_1} [measurable_space α]",
    "doc_string": " Measures are partially ordered.  The definition of less equal here is equivalent to the definition without the measurable set condition, and this is shown by `measure.le_iff'`. It is defined this way since, to prove `μ ≤ ν`, we may simply `intros s hs` instead of rewriting followed by `intros s hs`.",
    "kind": "def",
    "type": "partial_order (measure_theory.measure α)"
  },
  {
    "name": "lie_equiv",
    "statement": "structure lie_equiv (R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)",
    "theorem": "(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L'] : Type (max v w)",
    "args": "(R : Type u) (L : Type v) (L' : Type w) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_ring L'] [lie_algebra R L']",
    "doc_string": " An equivalence of Lie algebras is a morphism which is also a linear equivalence. We could instead define an equivalence to be a morphism which is also a (plain) equivalence. However it is more convenient to define via linear equivalence to get `.to_linear_equiv` for free.",
    "kind": "structure",
    "type": "Type (max v w)"
  },
  {
    "name": "filter.tendsto_abs_at_top_at_top",
    "statement": "theorem filter.tendsto_abs_at_top_at_top {α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_top filter.at_top",
    "theorem": "{α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_top filter.at_top",
    "args": "{α : Type u_3} [linear_ordered_add_comm_group α]",
    "doc_string": "$\\lim_{x\\to+\\infty}|x|=+\\infty$",
    "kind": "theorem",
    "type": "filter.tendsto has_abs.abs filter.at_top filter.at_top"
  },
  {
    "name": "mvqpf.cofix",
    "statement": "def mvqpf.cofix {n : ℕ} (F : typevec (n + 1) → Type u) [mvfunctor F] [q : mvqpf F] (α : typevec n) : Type u",
    "theorem": "{n : ℕ} (F : typevec (n + 1) → Type u) [mvfunctor F] [q : mvqpf F] (α : typevec n) : Type u",
    "args": "{n : ℕ} (F : typevec (n + 1) → Type u) [mvfunctor F] [q : mvqpf F] (α : typevec n)",
    "doc_string": " Greatest fixed point of functor F. The result is a functor with one fewer parameters than the input. For `F a b c` a ternary functor, fix F is a binary functor such that  ```lean cofix F a b = F a b (cofix F a b) ```",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "upgraded_polish_space",
    "statement": "structure upgraded_polish_space (α : Type u_3) : Type u_3",
    "theorem": "(α : Type u_3) : Type u_3",
    "args": "(α : Type u_3)",
    "doc_string": " A convenience class, for a Polish space endowed with a complete metric. No instance of this class should be registered: It should be used as `letI := upgrade_polish_space α` to endow a Polish space with a complete metric.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "algebraic_geometry.Spec.Top_obj",
    "statement": "def algebraic_geometry.Spec.Top_obj (R : CommRing) : Top",
    "theorem": "(R : CommRing) : Top",
    "args": "(R : CommRing)",
    "doc_string": "The spectrum of a commutative ring, as a topological space.",
    "kind": "def",
    "type": "Top"
  },
  {
    "name": "tactic.solve_by_elim.opt",
    "statement": "structure tactic.solve_by_elim.opt  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Arguments for `solve_by_elim`: * By default `solve_by_elim` operates only on the first goal,   but with `backtrack_all_goals := true`, it operates on all goals at once,   backtracking across goals as needed,   and only succeeds if it discharges all goals. * `lemmas` specifies the list of lemmas to use in the backtracking search.   If `none`, `solve_by_elim` uses the local hypotheses,   along with `rfl`, `trivial`, `congr_arg`, and `congr_fun`. * `lemma_thunks` provides the lemmas as a list of `tactic expr`,   which are used to regenerate the `expr` objects to avoid binding metavariables.   It should not usually be specified by the user.   (If both `lemmas` and `lemma_thunks` are specified, only `lemma_thunks` is used.) * `ctx_thunk` is for internal use only: it returns the local hypotheses which will be used. * `max_depth` bounds the depth of the search.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "discrete_valuation_ring.exists_prime",
    "statement": "theorem discrete_valuation_ring.exists_prime (R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), prime ϖ",
    "theorem": "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), prime ϖ",
    "args": "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R]",
    "doc_string": "Uniformisers exist in a DVR",
    "kind": "theorem",
    "type": "∃ (ϖ : R), prime ϖ"
  },
  {
    "name": "nhds_adjoint",
    "statement": "def nhds_adjoint {α : Type u} (a : α) (f : filter α) : topological_space α",
    "theorem": "{α : Type u} (a : α) (f : filter α) : topological_space α",
    "args": "{α : Type u} (a : α) (f : filter α)",
    "doc_string": "This construction is left adjoint to the operation sending a topology on `α`  to its neighborhood filter at a fixed point `a : α`.",
    "kind": "def",
    "type": "topological_space α"
  },
  {
    "name": "first_order.language.Structure.cg",
    "statement": "structure first_order.language.Structure.cg (L : first_order.language) (M : Type u_3) [L.Structure M] : Prop",
    "theorem": "(L : first_order.language) (M : Type u_3) [L.Structure M] : Prop",
    "args": "(L : first_order.language) (M : Type u_3) [L.Structure M]",
    "doc_string": "A structure is countably generated if it is the closure of a countable subset.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "valuation_class",
    "statement": "structure valuation_class (F : Type u_1) (R : Type u_2) (Γ₀ : Type u_3) [linear_ordered_comm_monoid_with_zero Γ₀] [ring R] : Type (max u_1 u_2 u_3)",
    "theorem": "(F : Type u_1) (R : Type u_2) (Γ₀ : Type u_3) [linear_ordered_comm_monoid_with_zero Γ₀] [ring R] : Type (max u_1 u_2 u_3)",
    "args": "(F : Type u_1) (R : Type u_2) (Γ₀ : Type u_3) [linear_ordered_comm_monoid_with_zero Γ₀] [ring R]",
    "doc_string": " `valuation_class F α β` states that `F` is a type of valuations.  You should also extend this typeclass when you extend `valuation`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "finset.mem_shadow_iff_exists_mem_card_add_one",
    "statement": "theorem finset.mem_shadow_iff_exists_mem_card_add_one {α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} : s ∈ 𝒜.shadow ↔ ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t ∧ t.card = s.card + 1",
    "theorem": "{α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α} : s ∈ 𝒜.shadow ↔ ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t ∧ t.card = s.card + 1",
    "args": "{α : Type u_1} [decidable_eq α] {𝒜 : finset (finset α)} {s : finset α}",
    "doc_string": "`s ∈ ∂ 𝒜` iff `s` is exactly one element less than something from `𝒜`",
    "kind": "theorem",
    "type": "s ∈ 𝒜.shadow ↔ ∃ (t : finset α) (H : t ∈ 𝒜), s ⊆ t ∧ t.card = s.card + 1"
  },
  {
    "name": "mvqpf.prj.P",
    "statement": "def mvqpf.prj.P {n : ℕ} (i : fin2 n) : mvpfunctor n",
    "theorem": "{n : ℕ} (i : fin2 n) : mvpfunctor n",
    "args": "{n : ℕ} (i : fin2 n)",
    "doc_string": "Polynomial representation of the projection functor",
    "kind": "def",
    "type": "mvpfunctor n"
  },
  {
    "name": "subgroup.centralizer",
    "statement": "def subgroup.centralizer {G : Type u_1} [group G] (H : subgroup G) : subgroup G",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : subgroup G",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": "The `centralizer` of `H` is the subgroup of `g : G` commuting with every `h : H`.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "top_hom.id",
    "statement": "def top_hom.id (α : Type u_2) [has_top α] : top_hom α α",
    "theorem": "(α : Type u_2) [has_top α] : top_hom α α",
    "args": "(α : Type u_2) [has_top α]",
    "doc_string": "`id` as a `top_hom`.",
    "kind": "def",
    "type": "top_hom α α"
  },
  {
    "name": "regular_expression.match_epsilon",
    "statement": "def regular_expression.match_epsilon {α : Type u_1} : regular_expression α → bool",
    "theorem": "{α : Type u_1} : regular_expression α → bool",
    "args": "{α : Type u_1}",
    "doc_string": "`match_epsilon P` is true if and only if `P` matches the empty string",
    "kind": "def",
    "type": "regular_expression α → bool"
  },
  {
    "name": "generalized_continued_fraction.has_coe_to_generalized_continued_fraction",
    "statement": "def generalized_continued_fraction.has_coe_to_generalized_continued_fraction {α : Type u_1} {β : Type u_2} [has_coe α β] : has_coe (generalized_continued_fraction α) (generalized_continued_fraction β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_coe α β] : has_coe (generalized_continued_fraction α) (generalized_continued_fraction β)",
    "args": "{α : Type u_1} {β : Type u_2} [has_coe α β]",
    "doc_string": "Coerce a gcf by elementwise coercion.",
    "kind": "def",
    "type": "has_coe (generalized_continued_fraction α) (generalized_continued_fraction β)"
  },
  {
    "name": "mvpfunctor.W_path",
    "statement": "inductive mvpfunctor.W_path {n : ℕ} (P : mvpfunctor (n + 1)) : P.last.W → fin2 n → Type u",
    "theorem": "{n : ℕ} (P : mvpfunctor (n + 1)) : P.last.W → fin2 n → Type u",
    "args": "{n : ℕ} (P : mvpfunctor (n + 1))",
    "doc_string": "A path from the root of a tree to one of its node",
    "kind": "inductive",
    "type": "P.last.W → fin2 n → Type u"
  },
  {
    "name": "tactic.rewrite_search.using_conv.splice_result",
    "statement": "inductive tactic.rewrite_search.using_conv.splice_result  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A data structure for the result of a splice operation. obstructed:  There was more of the addr to be added left, but we hit a rw contained:   The added addr was already contained, and did not terminate at an existing rw new:         The added addr terminated at an existing rw or we could create a new one for it",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "is_fraction_ring.char_zero",
    "statement": "def is_fraction_ring.char_zero (R : Type u_1) [comm_ring R] [is_domain R] [char_zero R] : char_zero (fraction_ring R)",
    "theorem": "(R : Type u_1) [comm_ring R] [is_domain R] [char_zero R] : char_zero (fraction_ring R)",
    "args": "(R : Type u_1) [comm_ring R] [is_domain R] [char_zero R]",
    "doc_string": "If `R` has characteristic `0`, then so does `fraction_ring R`.",
    "kind": "def",
    "type": "char_zero (fraction_ring R)"
  },
  {
    "name": "euclidean_domain.xgcd",
    "statement": "def euclidean_domain.xgcd {R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R × R",
    "theorem": "{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R × R",
    "args": "{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R)",
    "doc_string": "Use the extended GCD algorithm to generate the `a` and `b` values  satisfying `gcd x y = x * a + y * b`.",
    "kind": "def",
    "type": "R × R"
  },
  {
    "name": "finset.dimH_zero",
    "statement": "theorem finset.dimH_zero {X : Type u_2} [emetric_space X] (s : finset X) : dimH ↑s = 0",
    "theorem": "{X : Type u_2} [emetric_space X] (s : finset X) : dimH ↑s = 0",
    "args": "{X : Type u_2} [emetric_space X] (s : finset X)",
    "doc_string": "**Alias** of dimH_coe_finset`.",
    "kind": "theorem",
    "type": "dimH ↑s = 0"
  },
  {
    "name": "quaternion",
    "statement": "def quaternion (R : Type u_1) [has_one R] [has_neg R] : Type u_1",
    "theorem": "(R : Type u_1) [has_one R] [has_neg R] : Type u_1",
    "args": "(R : Type u_1) [has_one R] [has_neg R]",
    "doc_string": " Space of quaternions over a type. Implemented as a structure with four fields: `re`, `im_i`, `im_j`, and `im_k`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "function.is_fixed_pt.to_left_inverse",
    "statement": "theorem function.is_fixed_pt.to_left_inverse {α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x",
    "theorem": "{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f) : function.is_fixed_pt g x",
    "args": "{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (h : function.left_inverse g f)",
    "doc_string": " If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed point of `g`.",
    "kind": "theorem",
    "type": "function.is_fixed_pt g x"
  },
  {
    "name": "exists_gcd_eq_mul_add_mul",
    "statement": "theorem exists_gcd_eq_mul_add_mul {R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [gcd_monoid R] (a b : R) : ∃ (x y : R), gcd_monoid.gcd a b = a * x + b * y",
    "theorem": "{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [gcd_monoid R] (a b : R) : ∃ (x y : R), gcd_monoid.gcd a b = a * x + b * y",
    "args": "{R : Type u} [comm_ring R] [is_domain R] [is_principal_ideal_ring R] [gcd_monoid R] (a b : R)",
    "doc_string": "**Bézout's lemma**",
    "kind": "theorem",
    "type": "∃ (x y : R), gcd_monoid.gcd a b = a * x + b * y"
  },
  {
    "name": "measure_theory.outer_measure.dirac",
    "statement": "def measure_theory.outer_measure.dirac {α : Type u_1} (a : α) : measure_theory.outer_measure α",
    "theorem": "{α : Type u_1} (a : α) : measure_theory.outer_measure α",
    "args": "{α : Type u_1} (a : α)",
    "doc_string": "The dirac outer measure.",
    "kind": "def",
    "type": "measure_theory.outer_measure α"
  },
  {
    "name": "bor",
    "statement": "def bor  : bool → bool → bool",
    "theorem": " : bool → bool → bool",
    "args": "",
    "doc_string": "Boolean OR",
    "kind": "def",
    "type": "bool → bool → bool"
  },
  {
    "name": "is_nilpotent",
    "statement": "def is_nilpotent {R : Type u} [has_zero R] [has_pow R ℕ] (x : R) : Prop",
    "theorem": "{R : Type u} [has_zero R] [has_pow R ℕ] (x : R) : Prop",
    "args": "{R : Type u} [has_zero R] [has_pow R ℕ] (x : R)",
    "doc_string": " An element is said to be nilpotent if some natural-number-power of it equals zero.  Note that we require only the bare minimum assumptions for the definition to make sense. Even `monoid_with_zero` is too strong since nilpotency is important in the study of rings that are only power-associative.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "encodable.decode_multiset",
    "statement": "def encodable.decode_multiset {α : Type u_1} [encodable α] (n : ℕ) : option (multiset α)",
    "theorem": "{α : Type u_1} [encodable α] (n : ℕ) : option (multiset α)",
    "args": "{α : Type u_1} [encodable α] (n : ℕ)",
    "doc_string": "Explicit decoding function for `multiset α`",
    "kind": "def",
    "type": "option (multiset α)"
  },
  {
    "name": "fintype.compact_space",
    "statement": "def fintype.compact_space {α : Type u} [topological_space α] [fintype α] : compact_space α",
    "theorem": "{α : Type u} [topological_space α] [fintype α] : compact_space α",
    "args": "{α : Type u} [topological_space α] [fintype α]",
    "doc_string": "Finite topological spaces are compact.",
    "kind": "def",
    "type": "compact_space α"
  },
  {
    "name": "add_subgroup.copy",
    "statement": "def add_subgroup.copy {G : Type u_1} [add_group G] (K : add_subgroup G) (s : set G) (hs : s = ↑K) : add_subgroup G",
    "theorem": "{G : Type u_1} [add_group G] (K : add_subgroup G) (s : set G) (hs : s = ↑K) : add_subgroup G",
    "args": "{G : Type u_1} [add_group G] (K : add_subgroup G) (s : set G) (hs : s = ↑K)",
    "doc_string": "Copy of an additive subgroup with a new `carrier` equal to the old one. Useful to fix definitional equalities",
    "kind": "def",
    "type": "add_subgroup G"
  },
  {
    "name": "fintype.choose_x",
    "statement": "def fintype.choose_x {α : Type u_1} [fintype α] (p : α → Prop) [decidable_pred p] (hp : ∃! (a : α), p a) : {a // p a}",
    "theorem": "{α : Type u_1} [fintype α] (p : α → Prop) [decidable_pred p] (hp : ∃! (a : α), p a) : {a // p a}",
    "args": "{α : Type u_1} [fintype α] (p : α → Prop) [decidable_pred p] (hp : ∃! (a : α), p a)",
    "doc_string": " Given a fintype `α` and a predicate `p`, associate to a proof that there is a unique element of `α` satisfying `p` this unique element, as an element of the corresponding subtype.",
    "kind": "def",
    "type": "{a // p a}"
  },
  {
    "name": "multiplicity.add_valuation",
    "statement": "def multiplicity.add_valuation {R : Type u_2} [comm_ring R] [is_domain R] {p : R} [decidable_rel has_dvd.dvd] (hp : prime p) : add_valuation R enat",
    "theorem": "{R : Type u_2} [comm_ring R] [is_domain R] {p : R} [decidable_rel has_dvd.dvd] (hp : prime p) : add_valuation R enat",
    "args": "{R : Type u_2} [comm_ring R] [is_domain R] {p : R} [decidable_rel has_dvd.dvd] (hp : prime p)",
    "doc_string": "`multiplicity` of a prime inan integral domain as an additive valuation to `enat`.",
    "kind": "def",
    "type": "add_valuation R enat"
  },
  {
    "name": "fin2.to_nat",
    "statement": "def fin2.to_nat {n : ℕ} : fin2 n → ℕ",
    "theorem": "{n : ℕ} : fin2 n → ℕ",
    "args": "{n : ℕ}",
    "doc_string": "Converts a `fin2` into a natural.",
    "kind": "def",
    "type": "fin2 n → ℕ"
  },
  {
    "name": "division_ring_of_finite_dimensional",
    "statement": "def division_ring_of_finite_dimensional (F : Type u_1) (K : Type u_2) [field F] [ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : division_ring K",
    "theorem": "(F : Type u_1) (K : Type u_2) [field F] [ring K] [is_domain K] [algebra F K] [finite_dimensional F K] : division_ring K",
    "args": "(F : Type u_1) (K : Type u_2) [field F] [ring K] [is_domain K] [algebra F K] [finite_dimensional F K]",
    "doc_string": "A domain that is module-finite as an algebra over a field is a division ring.",
    "kind": "def",
    "type": "division_ring K"
  },
  {
    "name": "stone_cech",
    "statement": "def stone_cech (α : Type u) [topological_space α] : Type u",
    "theorem": "(α : Type u) [topological_space α] : Type u",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "The Stone-Čech compactification of a topological space.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "subalgebra.copy",
    "statement": "def subalgebra.copy {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) (s : set A) (hs : s = ↑S) : subalgebra R A",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) (s : set A) (hs : s = ↑S) : subalgebra R A",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) (s : set A) (hs : s = ↑S)",
    "doc_string": " Copy of a subalgebra with a new `carrier` equal to the old one. Useful to fix definitional equalities.",
    "kind": "def",
    "type": "subalgebra R A"
  },
  {
    "name": "subalgebra.to_subring",
    "statement": "def subalgebra.to_subring {R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : subring A",
    "theorem": "{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A) : subring A",
    "args": "{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] (S : subalgebra R A)",
    "doc_string": "A subalgebra over a ring is also a `subring`.",
    "kind": "def",
    "type": "subring A"
  },
  {
    "name": "prod.encodable",
    "statement": "def prod.encodable {α : Type u_1} {β : Type u_2} [encodable α] [encodable β] : encodable (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [encodable α] [encodable β] : encodable (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} [encodable α] [encodable β]",
    "doc_string": "If `α` and `β` are encodable, then so is their product.",
    "kind": "def",
    "type": "encodable (α × β)"
  },
  {
    "name": "subtype.forall'",
    "statement": "theorem subtype.forall' {α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _",
    "theorem": "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _",
    "args": "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop}",
    "doc_string": "An alternative version of `subtype.forall`. This one is useful if Lean cannot figure out `q`  when using `subtype.forall` from right to left.",
    "kind": "theorem",
    "type": "(∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _"
  },
  {
    "name": "is_of_fin_order_one",
    "statement": "theorem is_of_fin_order_one {G : Type u} [monoid G] : is_of_fin_order 1",
    "theorem": "{G : Type u} [monoid G] : is_of_fin_order 1",
    "args": "{G : Type u} [monoid G]",
    "doc_string": "1 is of finite order in any monoid.",
    "kind": "theorem",
    "type": "is_of_fin_order 1"
  },
  {
    "name": "filter.subtraction_monoid",
    "statement": "def filter.subtraction_monoid {α : Type u_2} [subtraction_monoid α] : subtraction_monoid (filter α)",
    "theorem": "{α : Type u_2} [subtraction_monoid α] : subtraction_monoid (filter α)",
    "args": "{α : Type u_2} [subtraction_monoid α]",
    "doc_string": "`filter α` is a subtraction monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "subtraction_monoid (filter α)"
  },
  {
    "name": "sigma_compact_space",
    "statement": "structure sigma_compact_space (α : Type u_3) [topological_space α] : Prop",
    "theorem": "(α : Type u_3) [topological_space α] : Prop",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": "A σ-compact space is a space that is the union of a countable collection of compact subspaces.  Note that a locally compact separable T₂ space need not be σ-compact.  The sequence can be extracted using `topological_space.compact_covering`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "pos_num.bit",
    "statement": "def pos_num.bit (b : bool) : pos_num → pos_num",
    "theorem": "(b : bool) : pos_num → pos_num",
    "args": "(b : bool)",
    "doc_string": "`bit b n` appends the bit `b` to the end of `n`, where `bit tt x = x1` and `bit ff x = x0`.",
    "kind": "def",
    "type": "pos_num → pos_num"
  },
  {
    "name": "quadratic_form.to_matrix'",
    "statement": "def quadratic_form.to_matrix' {R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R₁ (n → R₁)) : matrix n n R₁",
    "theorem": "{R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R₁ (n → R₁)) : matrix n n R₁",
    "args": "{R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R₁ (n → R₁))",
    "doc_string": "A matrix representation of the quadratic form.",
    "kind": "def",
    "type": "matrix n n R₁"
  },
  {
    "name": "poly.proj",
    "statement": "def poly.proj {α : Type u_1} (i : α) : poly α",
    "theorem": "{α : Type u_1} (i : α) : poly α",
    "args": "{α : Type u_1} (i : α)",
    "doc_string": "The `i`th projection function, `x_i`.",
    "kind": "def",
    "type": "poly α"
  },
  {
    "name": "where.binder_priority",
    "statement": "def where.binder_priority  : binder_info → ℕ",
    "theorem": " : binder_info → ℕ",
    "args": "",
    "doc_string": "Assigns a priority to each binder for determining the order in which variables are traced.",
    "kind": "def",
    "type": "binder_info → ℕ"
  },
  {
    "name": "qpf.supp_preservation",
    "statement": "def qpf.supp_preservation {F : Type u → Type u} [functor F] (q : qpf F) : Prop",
    "theorem": "{F : Type u → Type u} [functor F] (q : qpf F) : Prop",
    "args": "{F : Type u → Type u} [functor F] (q : qpf F)",
    "doc_string": "does `abs` preserve `supp`?",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "submonoid_class",
    "statement": "structure submonoid_class (S : Type u_4) (M : out_param (Type u_5)) [mul_one_class M] [set_like S M] : Type",
    "theorem": "(S : Type u_4) (M : out_param (Type u_5)) [mul_one_class M] [set_like S M] : Type",
    "args": "(S : Type u_4) (M : out_param (Type u_5)) [mul_one_class M] [set_like S M]",
    "doc_string": " `submonoid_class S M` says `S` is a type of subsets `s ≤ M` that contain `1` and are closed under `(*)`",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "option.rel",
    "statement": "inductive option.rel {α : Type u_1} {β : Type u_2} (r : α → β → Prop) : option α → option β → Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop) : option α → option β → Prop",
    "args": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop)",
    "doc_string": " Lifts a relation `α → β → Prop` to a relation `option α → option β → Prop` by just adding `none ~ none`.",
    "kind": "inductive",
    "type": "option α → option β → Prop"
  },
  {
    "name": "matrix.inv_eq_left_inv",
    "statement": "theorem matrix.inv_eq_left_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : B.mul A = 1) : A⁻¹ = B",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : B.mul A = 1) : A⁻¹ = B",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : B.mul A = 1)",
    "doc_string": "If matrix A is left invertible, then its inverse equals its left inverse.",
    "kind": "theorem",
    "type": "A⁻¹ = B"
  },
  {
    "name": "zero_mul_eq_const",
    "statement": "theorem zero_mul_eq_const {M₀ : Type u_1} [mul_zero_class M₀] : has_mul.mul 0 = function.const M₀ 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] : has_mul.mul 0 = function.const M₀ 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀]",
    "doc_string": "To match `one_mul_eq_id`.",
    "kind": "theorem",
    "type": "has_mul.mul 0 = function.const M₀ 0"
  },
  {
    "name": "besicovitch.tau_package.index",
    "statement": "def besicovitch.tau_package.index {α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) : ordinal → β",
    "theorem": "{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) : ordinal → β",
    "args": "{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α)",
    "doc_string": " Choose inductively large balls with centers that are not contained in the union of already chosen balls. This is a transfinite induction.",
    "kind": "def",
    "type": "ordinal → β"
  },
  {
    "name": "fintype.of_injective",
    "statement": "def fintype.of_injective {α : Type u_1} {β : Type u_2} [fintype β] (f : α → β) (H : function.injective f) : fintype α",
    "theorem": "{α : Type u_1} {β : Type u_2} [fintype β] (f : α → β) (H : function.injective f) : fintype α",
    "args": "{α : Type u_1} {β : Type u_2} [fintype β] (f : α → β) (H : function.injective f)",
    "doc_string": " Given an injective function to a fintype, the domain is also a fintype. This is noncomputable because injectivity alone cannot be used to construct preimages.",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "part.mem",
    "statement": "def part.mem {α : Type u_1} (a : α) (o : part α) : Prop",
    "theorem": "{α : Type u_1} (a : α) (o : part α) : Prop",
    "args": "{α : Type u_1} (a : α) (o : part α)",
    "doc_string": "`a ∈ o` means that `o` is defined and equal to `a`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "measure_theory.simple_func.of_is_empty",
    "statement": "def measure_theory.simple_func.of_is_empty {α : Type u_1} {β : Type u_2} [measurable_space α] [is_empty α] : measure_theory.simple_func α β",
    "theorem": "{α : Type u_1} {β : Type u_2} [measurable_space α] [is_empty α] : measure_theory.simple_func α β",
    "args": "{α : Type u_1} {β : Type u_2} [measurable_space α] [is_empty α]",
    "doc_string": "Simple function defined on the empty type.",
    "kind": "def",
    "type": "measure_theory.simple_func α β"
  },
  {
    "name": "local_equiv.eq_on_source_setoid",
    "statement": "def local_equiv.eq_on_source_setoid {α : Type u_1} {β : Type u_2} : setoid (local_equiv α β)",
    "theorem": "{α : Type u_1} {β : Type u_2} : setoid (local_equiv α β)",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": "`eq_on_source` is an equivalence relation",
    "kind": "def",
    "type": "setoid (local_equiv α β)"
  },
  {
    "name": "ultrafilter_is_open_basic",
    "statement": "theorem ultrafilter_is_open_basic {α : Type u} (s : set α) : is_open {u : ultrafilter α | s ∈ u}",
    "theorem": "{α : Type u} (s : set α) : is_open {u : ultrafilter α | s ∈ u}",
    "args": "{α : Type u} (s : set α)",
    "doc_string": "The basic open sets for the topology on ultrafilters are open.",
    "kind": "theorem",
    "type": "is_open {u : ultrafilter α | s ∈ u}"
  },
  {
    "name": "structure_instance_info",
    "statement": "structure structure_instance_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Information about unelaborated structure instance expressions.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "one_pos",
    "statement": "theorem one_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 1",
    "theorem": "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 1",
    "args": "{α : Type u} [ordered_semiring α] [nontrivial α]",
    "doc_string": "**Alias** of zero_lt_one`.",
    "kind": "theorem",
    "type": "0 < 1"
  },
  {
    "name": "num_derangements",
    "statement": "def num_derangements  : ℕ → ℕ",
    "theorem": " : ℕ → ℕ",
    "args": "",
    "doc_string": "The number of derangements of an `n`-element set.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "nat.digits_aux",
    "statement": "def nat.digits_aux (b : ℕ) (h : 2 ≤ b) : ℕ → list ℕ",
    "theorem": "(b : ℕ) (h : 2 ≤ b) : ℕ → list ℕ",
    "args": "(b : ℕ) (h : 2 ≤ b)",
    "doc_string": "(Impl.) An auxiliary definition for `digits`, to help get the desired definitional unfolding.",
    "kind": "def",
    "type": "ℕ → list ℕ"
  },
  {
    "name": "monoid_algebra.has_mul",
    "statement": "def monoid_algebra.has_mul {k : Type u₁} {G : Type u₂} [semiring k] [has_mul G] : has_mul (monoid_algebra k G)",
    "theorem": "{k : Type u₁} {G : Type u₂} [semiring k] [has_mul G] : has_mul (monoid_algebra k G)",
    "args": "{k : Type u₁} {G : Type u₂} [semiring k] [has_mul G]",
    "doc_string": "The product of `f g : monoid_algebra k G` is the finitely supported function  whose value at `a` is the sum of `f x * g y` over all pairs `x, y`  such that `x * y = a`. (Think of the group ring of a group.)",
    "kind": "def",
    "type": "has_mul (monoid_algebra k G)"
  },
  {
    "name": "linear_ordered_add_comm_monoid_with_top",
    "statement": "structure linear_ordered_add_comm_monoid_with_top (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A linearly ordered commutative monoid with an additively absorbing `⊤` element.  Instances should include number systems with an infinite element adjoined.`",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "free_product",
    "statement": "def free_product {ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)]",
    "doc_string": "The free product (categorical coproduct) of an indexed family of monoids.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "vector.scanl",
    "statement": "def vector.scanl {n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : vector α n) : vector β (n + 1)",
    "theorem": "{n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : vector α n) : vector β (n + 1)",
    "args": "{n : ℕ} {α : Type u_1} {β : Type u_2} (f : β → α → β) (b : β) (v : vector α n)",
    "doc_string": "Construct a `vector β (n + 1)` from a `vector α n` by scanning `f : β → α → β` from the \"left\", that is, from 0 to `fin.last n`, using `b : β` as the starting value.",
    "kind": "def",
    "type": "vector β (n + 1)"
  },
  {
    "name": "dmatrix",
    "statement": "def dmatrix (m : Type u) (n : Type u') [fintype m] [fintype n] (α : m → n → Type v) : Type (max u u' v)",
    "theorem": "(m : Type u) (n : Type u') [fintype m] [fintype n] (α : m → n → Type v) : Type (max u u' v)",
    "args": "(m : Type u) (n : Type u') [fintype m] [fintype n] (α : m → n → Type v)",
    "doc_string": " `dmatrix m n` is the type of dependently typed matrices whose rows are indexed by the fintype `m` and whose columns are indexed by the fintype `n`.",
    "kind": "def",
    "type": "Type (max u u' v)"
  },
  {
    "name": "category_theory.monoidal_category",
    "statement": "structure category_theory.monoidal_category (C : Type u) [𝒞 : category_theory.category C] : Type (max u v)",
    "theorem": "(C : Type u) [𝒞 : category_theory.category C] : Type (max u v)",
    "args": "(C : Type u) [𝒞 : category_theory.category C]",
    "doc_string": "In a monoidal category, we can take the tensor product of objects, `X ⊗ Y` and of morphisms `f ⊗ g`. Tensor product does not need to be strictly associative on objects, but there is a specified associator, `α_ X Y Z : (X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)`. There is a tensor unit `𝟙_ C`, with specified left and right unitor isomorphisms `λ_ X : 𝟙_ C ⊗ X ≅ X` and `ρ_ X : X ⊗ 𝟙_ C ≅ X`. These associators and unitors satisfy the pentagon and triangle equations.  See <https://stacks.math.columbia.edu/tag/0FFK>.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "affine_span",
    "statement": "def affine_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : affine_subspace k P",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : affine_subspace k P",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P)",
    "doc_string": " The affine span of a set of points is the smallest affine subspace containing those points. (Actually defined here in terms of spans in modules.)",
    "kind": "def",
    "type": "affine_subspace k P"
  },
  {
    "name": "disjointed_unique",
    "statement": "theorem disjointed_unique {α : Type u_1} [generalized_boolean_algebra α] {f d : ℕ → α} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] {f d : ℕ → α} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] {f d : ℕ → α} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f)",
    "doc_string": " `disjointed f` is the unique sequence that is pairwise disjoint and has the same partial sups as `f`.",
    "kind": "theorem",
    "type": "d = disjointed f"
  },
  {
    "name": "unique_factorization_monoid.to_normalized_gcd_monoid",
    "statement": "def unique_factorization_monoid.to_normalized_gcd_monoid (α : Type u_1) [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq (associates α)] [decidable_eq α] : normalized_gcd_monoid α",
    "theorem": "(α : Type u_1) [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq (associates α)] [decidable_eq α] : normalized_gcd_monoid α",
    "args": "(α : Type u_1) [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq (associates α)] [decidable_eq α]",
    "doc_string": "`to_normalized_gcd_monoid` constructs a GCD monoid out of a normalization on a  unique factorization domain.",
    "kind": "def",
    "type": "normalized_gcd_monoid α"
  },
  {
    "name": "finset.add_semigroup",
    "statement": "def finset.add_semigroup {α : Type u_2} [decidable_eq α] [add_semigroup α] : add_semigroup (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [add_semigroup α] : add_semigroup (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [add_semigroup α]",
    "doc_string": "`finset α` is an `add_semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_semigroup (finset α)"
  },
  {
    "name": "finset.nat.antidiagonal_zero",
    "statement": "theorem finset.nat.antidiagonal_zero  : finset.nat.antidiagonal 0 = {(0, 0)}",
    "theorem": " : finset.nat.antidiagonal 0 = {(0, 0)}",
    "args": "",
    "doc_string": "The antidiagonal of `0` is the list `[(0, 0)]`",
    "kind": "theorem",
    "type": "finset.nat.antidiagonal 0 = {(0, 0)}"
  },
  {
    "name": "eformat",
    "statement": "def eformat  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "tagged_format with information about subexpressions.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "set.right_inv_on",
    "statement": "def set.right_inv_on {α : Type u} {β : Type v} (f' : β → α) (f : α → β) (t : set β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (f' : β → α) (f : α → β) (t : set β) : Prop",
    "args": "{α : Type u} {β : Type v} (f' : β → α) (f : α → β) (t : set β)",
    "doc_string": "`g` is a right inverse to `f` on `b` if `f (g x) = x` for all `x ∈ b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "Magma",
    "statement": "def Magma  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of magmas and magma morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "category_theory.simple",
    "statement": "structure category_theory.simple {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (X : C)",
    "doc_string": "An object is simple if monomorphisms into it are (exclusively) either isomorphisms or zero.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "intermediate_field.zero_mem",
    "statement": "theorem intermediate_field.zero_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 0 ∈ S",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) : 0 ∈ S",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L)",
    "doc_string": "An intermediate field contains the ring's 0.",
    "kind": "theorem",
    "type": "0 ∈ S"
  },
  {
    "name": "is_glb",
    "statement": "def is_glb {α : Type u} [preorder α] (s : set α) : α → Prop",
    "theorem": "{α : Type u} [preorder α] (s : set α) : α → Prop",
    "args": "{α : Type u} [preorder α] (s : set α)",
    "doc_string": "`a` is a greatest lower bound of a set `s`; for a partial order, it is unique if exists.",
    "kind": "def",
    "type": "α → Prop"
  },
  {
    "name": "bernstein_polynomial",
    "statement": "def bernstein_polynomial (R : Type u_1) [comm_ring R] (n ν : ℕ) : polynomial R",
    "theorem": "(R : Type u_1) [comm_ring R] (n ν : ℕ) : polynomial R",
    "args": "(R : Type u_1) [comm_ring R] (n ν : ℕ)",
    "doc_string": "`bernstein_polynomial R n ν` is `(choose n ν) * X^ν * (1 - X)^(n - ν)`.  Although the coefficients are integers, it is convenient to work over an arbitrary commutative ring.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "list.permutations_aux",
    "statement": "def list.permutations_aux {α : Type u_1} : list α → list α → list (list α)",
    "theorem": "{α : Type u_1} : list α → list α → list (list α)",
    "args": "{α : Type u_1}",
    "doc_string": " An auxiliary function for defining `permutations`. `permutations_aux ts is` is the set of all permutations of `is ++ ts` that do not fix `ts`.",
    "kind": "def",
    "type": "list α → list α → list (list α)"
  },
  {
    "name": "one_le_inv'",
    "statement": "theorem one_le_inv' {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "**Alias** of left.one_le_inv_iff`.",
    "kind": "theorem",
    "type": "1 ≤ a⁻¹ ↔ a ≤ 1"
  },
  {
    "name": "tactic.interactive.case_tag",
    "statement": "inductive tactic.interactive.case_tag  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A case tag carries the following information:  1. A list of names identifying the case ('case names'). This is usually a list    of constructor names, one for each case split that was performed. For    example, the sequence of tactics `cases n; cases xs`, where `n` is a natural    number and `xs` is a list, will generate four cases tagged as follows:     ```lean    nat.zero, list.nil    nat.zero, list.cons    nat.succ, list.nil    nat.succ, list.cons    ```     Note: In the case tag, the case names are stored in reverse order. Thus, the    case names of the first case tag would be `list.nil, nat.zero`. This is    because when printing a goal tag (as part of a goal state), Lean prints all    non-internal names in reverse order.  2. Information about the arguments introduced by the cases-like tactic.    Different tactics work slightly different in this regard:     1. The `with_cases` tactic generates goals where the target quantifies over       any added hypotheses. For example, `with_cases { cases xs }`, where `xs`       is a `list α`, will generate a target of the form `α → list α → ...` in       the `cons` case, where the two arguments correspond to the two arguments       of the `cons` constructor. Goals of this form are tagged with a `pi` case       tag (since the target is a pi type). In addition to the case names, it       contains a natural number, `num_arguments`, which specifies how many of       the arguments that the target quantifies over were introduced by       `with_cases`.        For example, given `n : ℕ` and `xs : list α`, the fourth goal generated by       `with_cases { cases n; induction xs }` has this form:        ```lean       ...       ⊢ ℕ → α → ∀ (xs' : list α), P xs' → ...       ```        The corresponding case tag is        ```lean       pi [`list.cons, `nat.succ] 4       ```        since the first four arguments of the target were introduced by       `with_cases {...}`.     2. The `cases` and `induction` tactics do not add arguments to the target,       but rather introduce them as hypotheses in the local context. Goals of       this form are tagged with a `hyps` case tag. In addition to the case       names, it contains a list of *unique* names of the hypotheses that were       introduced.        For example, given `xs : list α`, the second goal generated by       `induction xs` has this form:        ```lean       ...       x : α       xs' : list α       ih_xs' : P xs'       ⊢ ...       ```        The corresponding goal tag is        ```lean       hyps [`list.cons] [`<x>, `<xs'>, `<ih_xs'>]       ```        where ````<h>``` denotes the unique name of a hypothesis `h`.        Note: Many tactics do not preserve the unique names of hypotheses       (particularly those tactics that use `revert`). Therefore, a `hyps` case       tag is only guaranteed to be valid directly after it was generated.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "generalized_continued_fraction.convergents",
    "statement": "def generalized_continued_fraction.convergents {K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K",
    "theorem": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K) : stream K",
    "args": "{K : Type u_2} [division_ring K] (g : generalized_continued_fraction K)",
    "doc_string": "Returns the convergents `Aₙ / Bₙ` of `g`, where `Aₙ, Bₙ` are the nth continuants of `g`.",
    "kind": "def",
    "type": "stream K"
  },
  {
    "name": "list.disjoint",
    "statement": "def list.disjoint {α : Type u_1} (l₁ l₂ : list α) : Prop",
    "theorem": "{α : Type u_1} (l₁ l₂ : list α) : Prop",
    "args": "{α : Type u_1} (l₁ l₂ : list α)",
    "doc_string": "`disjoint l₁ l₂` means that `l₁` and `l₂` have no elements in common.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subgroup.to_submonoid",
    "statement": "def subgroup.to_submonoid {G : Type u_3} [group G] (self : subgroup G) : submonoid G",
    "theorem": "{G : Type u_3} [group G] (self : subgroup G) : submonoid G",
    "args": "{G : Type u_3} [group G] (self : subgroup G)",
    "doc_string": "Reinterpret a `subgroup` as a `submonoid`.",
    "kind": "def",
    "type": "submonoid G"
  },
  {
    "name": "neg_lt_zero",
    "statement": "theorem neg_lt_zero {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.inv_lt_one_iff`.",
    "kind": "theorem",
    "type": "-a < 0 ↔ 0 < a"
  },
  {
    "name": "is_compact",
    "statement": "def is_compact {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "A set `s` is compact if for every nontrivial filter `f` that contains `s`,    there exists `a ∈ s` such that every set of `f` meets every neighborhood of `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "continuous_map.continuous_eval_const",
    "statement": "theorem continuous_map.continuous_eval_const {α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] (x : α) : continuous (λ (f : C(α, β)), ⇑f x)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] (x : α) : continuous (λ (f : C(α, β)), ⇑f x)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] (x : α)",
    "doc_string": "See also `continuous_map.continuous_eval_const`",
    "kind": "theorem",
    "type": "continuous (λ (f : C(α, β)), ⇑f x)"
  },
  {
    "name": "is_left_regular_of_non_zero_divisor",
    "statement": "theorem is_left_regular_of_non_zero_divisor {α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0) : is_left_regular k",
    "theorem": "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0) : is_left_regular k",
    "args": "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0)",
    "doc_string": " Left `mul` by a `k : α` over `[ring α]` is injective, if `k` is not a zero divisor. The typeclass that restricts all terms of `α` to have this property is `no_zero_divisors`.",
    "kind": "theorem",
    "type": "is_left_regular k"
  },
  {
    "name": "bool.decidable_forall_bool",
    "statement": "def bool.decidable_forall_bool {p : bool → Prop} [Π (b : bool), decidable (p b)] : decidable (∀ (b : bool), p b)",
    "theorem": "{p : bool → Prop} [Π (b : bool), decidable (p b)] : decidable (∀ (b : bool), p b)",
    "args": "{p : bool → Prop} [Π (b : bool), decidable (p b)]",
    "doc_string": "If `p b` is decidable for all `b : bool`, then `∀ b, p b` is decidable",
    "kind": "def",
    "type": "decidable (∀ (b : bool), p b)"
  },
  {
    "name": "filter.pi",
    "statement": "def filter.pi {ι : Type u_1} {α : ι → Type u_2} (f : Π (i : ι), filter (α i)) : filter (Π (i : ι), α i)",
    "theorem": "{ι : Type u_1} {α : ι → Type u_2} (f : Π (i : ι), filter (α i)) : filter (Π (i : ι), α i)",
    "args": "{ι : Type u_1} {α : ι → Type u_2} (f : Π (i : ι), filter (α i))",
    "doc_string": "The product of an indexed family of filters.",
    "kind": "def",
    "type": "filter (Π (i : ι), α i)"
  },
  {
    "name": "mul_action.to_perm_injective",
    "statement": "theorem mul_action.to_perm_injective {α : Type u} {β : Type v} [group α] [mul_action α β] [has_faithful_smul α β] : function.injective mul_action.to_perm",
    "theorem": "{α : Type u} {β : Type v} [group α] [mul_action α β] [has_faithful_smul α β] : function.injective mul_action.to_perm",
    "args": "{α : Type u} {β : Type v} [group α] [mul_action α β] [has_faithful_smul α β]",
    "doc_string": "`mul_action.to_perm` is injective on faithful actions.",
    "kind": "theorem",
    "type": "function.injective mul_action.to_perm"
  },
  {
    "name": "filter.tendsto.le_comap",
    "statement": "theorem filter.tendsto.le_comap {α : Type u} {β : Type v} {f : α → β} {l₁ : filter α} {l₂ : filter β} : filter.tendsto f l₁ l₂ → l₁ ≤ filter.comap f l₂",
    "theorem": "{α : Type u} {β : Type v} {f : α → β} {l₁ : filter α} {l₂ : filter β} : filter.tendsto f l₁ l₂ → l₁ ≤ filter.comap f l₂",
    "args": "{α : Type u} {β : Type v} {f : α → β} {l₁ : filter α} {l₂ : filter β}",
    "doc_string": "**Alias** of the forward direction of filter.tendsto_iff_comap`.",
    "kind": "theorem",
    "type": "filter.tendsto f l₁ l₂ → l₁ ≤ filter.comap f l₂"
  },
  {
    "name": "simplex_category.len",
    "statement": "def simplex_category.len (n : simplex_category) : ℕ",
    "theorem": "(n : simplex_category) : ℕ",
    "args": "(n : simplex_category)",
    "doc_string": "The length of an object of `simplex_category`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "category_theory.pretopology.gi",
    "statement": "def category_theory.pretopology.gi (C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : galois_insertion (category_theory.pretopology.to_grothendieck C) (category_theory.pretopology.of_grothendieck C)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : galois_insertion (category_theory.pretopology.to_grothendieck C) (category_theory.pretopology.of_grothendieck C)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C]",
    "doc_string": "We have a galois insertion from pretopologies to Grothendieck topologies.",
    "kind": "def",
    "type": "galois_insertion (category_theory.pretopology.to_grothendieck C) (category_theory.pretopology.of_grothendieck C)"
  },
  {
    "name": "inv_mul_lt_of_lt_mul",
    "statement": "theorem inv_mul_lt_of_lt_mul {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a < b * c → b⁻¹ * a < c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a < b * c → b⁻¹ * a < c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of inv_mul_lt_iff_lt_mul`.",
    "kind": "theorem",
    "type": "a < b * c → b⁻¹ * a < c"
  },
  {
    "name": "finite_dimensional.finrank_fintype_fun_eq_card",
    "statement": "theorem finite_dimensional.finrank_fintype_fun_eq_card (K : Type u) [division_ring K] {ι : Type v} [fintype ι] : finite_dimensional.finrank K (ι → K) = fintype.card ι",
    "theorem": "(K : Type u) [division_ring K] {ι : Type v} [fintype ι] : finite_dimensional.finrank K (ι → K) = fintype.card ι",
    "args": "(K : Type u) [division_ring K] {ι : Type v} [fintype ι]",
    "doc_string": "The vector space of functions on a fintype ι has finrank equal to the cardinality of ι.",
    "kind": "theorem",
    "type": "finite_dimensional.finrank K (ι → K) = fintype.card ι"
  },
  {
    "name": "circle_deg1_lift",
    "statement": "structure circle_deg1_lift  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A lift of a monotone degree one map `S¹ → S¹`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "emetric.inf_edist_le_inf_edist_add_Hausdorff_edist",
    "statement": "theorem emetric.inf_edist_le_inf_edist_add_Hausdorff_edist {α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} : emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t",
    "theorem": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} : emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t",
    "args": "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α}",
    "doc_string": " The distance from `x` to `s` or `t` is controlled in terms of the Hausdorff distance between `s` and `t`",
    "kind": "theorem",
    "type": "emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg",
    "statement": "theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr",
    "theorem": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr",
    "args": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n)",
    "doc_string": "Shows that the fractional parts of the stream are nonnegative.",
    "kind": "theorem",
    "type": "0 ≤ ifp_n.fr"
  },
  {
    "name": "subgroup.list_prod_mem",
    "statement": "theorem subgroup.list_prod_mem {G : Type u_1} [group G] (K : subgroup G) {l : list G} : (∀ (x : G), x ∈ l → x ∈ K) → l.prod ∈ K",
    "theorem": "{G : Type u_1} [group G] (K : subgroup G) {l : list G} : (∀ (x : G), x ∈ l → x ∈ K) → l.prod ∈ K",
    "args": "{G : Type u_1} [group G] (K : subgroup G) {l : list G}",
    "doc_string": "Product of a list of elements in a subgroup is in the subgroup.",
    "kind": "theorem",
    "type": "(∀ (x : G), x ∈ l → x ∈ K) → l.prod ∈ K"
  },
  {
    "name": "arrow_mul_distrib_mul_action",
    "statement": "def arrow_mul_distrib_mul_action {G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] [monoid B] : mul_distrib_mul_action G (A → B)",
    "theorem": "{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] [monoid B] : mul_distrib_mul_action G (A → B)",
    "args": "{G : Type u_1} {A : Type u_2} {B : Type u_3} [group G] [mul_action G A] [monoid B]",
    "doc_string": "When `B` is a monoid, `arrow_action` is additionally a `mul_distrib_mul_action`.",
    "kind": "def",
    "type": "mul_distrib_mul_action G (A → B)"
  },
  {
    "name": "tactic.rewrite_search.dir_pair",
    "statement": "structure tactic.rewrite_search.dir_pair (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A `dir_pair` is a pair of items designed to be accessed according to `dir`, a \"direction\" defined in the `expr_lens` library.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "has_bracket",
    "statement": "structure has_bracket (L : Type u_1) (M : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(L : Type u_1) (M : Type u_2) : Type (max u_1 u_2)",
    "args": "(L : Type u_1) (M : Type u_2)",
    "doc_string": "The has_bracket class has three intended uses:   1. for certain binary operations on structures, like the product `⁅x, y⁆` of two elements    `x`, `y` in a Lie algebra or the commutator of two elements `x` and `y` in a group.   2. for certain actions of one structure on another, like the action `⁅x, m⁆` of an element `x`    of a Lie algebra on an element `m` in one of its modules (analogous to `has_scalar` in the    associative setting).   3. for binary operations on substructures, like the commutator `⁅H, K⁆` of two subgroups `H` and     `K` of a group.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "filter.has_pure",
    "statement": "def filter.has_pure  : has_pure filter",
    "theorem": " : has_pure filter",
    "args": "",
    "doc_string": " `pure x` is the set of sets that contain `x`. It is equal to `𝓟 {x}` but with this definition we have `s ∈ pure a` defeq `a ∈ s`.",
    "kind": "def",
    "type": "has_pure filter"
  },
  {
    "name": "name.sanitize_name",
    "statement": "def name.sanitize_name  : name → name",
    "theorem": " : name → name",
    "args": "",
    "doc_string": "`name`s can contain numeral pieces, which are not legal names  when typed/passed directly to the parser. We turn an arbitrary  name into a legal identifier name by turning the numbers to strings.",
    "kind": "def",
    "type": "name → name"
  },
  {
    "name": "uniform_space.completion.map",
    "statement": "def uniform_space.completion.map {α : Type u_1} [uniform_space α] {β : Type u_2} [uniform_space β] (f : α → β) : uniform_space.completion α → uniform_space.completion β",
    "theorem": "{α : Type u_1} [uniform_space α] {β : Type u_2} [uniform_space β] (f : α → β) : uniform_space.completion α → uniform_space.completion β",
    "args": "{α : Type u_1} [uniform_space α] {β : Type u_2} [uniform_space β] (f : α → β)",
    "doc_string": "Completion functor acting on morphisms",
    "kind": "def",
    "type": "uniform_space.completion α → uniform_space.completion β"
  },
  {
    "name": "has_coe_t",
    "statement": "structure has_coe_t (a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))",
    "theorem": "(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))",
    "args": "(a : Sort u) (b : Sort v)",
    "doc_string": "Auxiliary class that contains the transitive closure of `has_coe`.",
    "kind": "structure",
    "type": "Sort (max 1 (imax u v))"
  },
  {
    "name": "part.of_option",
    "statement": "def part.of_option {α : Type u_1} : option α → part α",
    "theorem": "{α : Type u_1} : option α → part α",
    "args": "{α : Type u_1}",
    "doc_string": "Converts an `option α` into a `part α`.",
    "kind": "def",
    "type": "option α → part α"
  },
  {
    "name": "int.modeq",
    "statement": "def int.modeq (n a b : ℤ) : Prop",
    "theorem": "(n a b : ℤ) : Prop",
    "args": "(n a b : ℤ)",
    "doc_string": "`a ≡ b [ZMOD n]` when `a % n = b % n`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bitvec.of_nat",
    "statement": "def bitvec.of_nat (n : ℕ) : ℕ → bitvec n",
    "theorem": "(n : ℕ) : ℕ → bitvec n",
    "args": "(n : ℕ)",
    "doc_string": "Create a bitvector from a `nat`",
    "kind": "def",
    "type": "ℕ → bitvec n"
  },
  {
    "name": "algebra",
    "statement": "structure algebra (R : Type u) (A : Type v) [comm_semiring R] [semiring A] : Type (max u v)",
    "theorem": "(R : Type u) (A : Type v) [comm_semiring R] [semiring A] : Type (max u v)",
    "args": "(R : Type u) (A : Type v) [comm_semiring R] [semiring A]",
    "doc_string": "An associative unital `R`-algebra is a semiring `A` equipped with a map into its center `R → A`.  See the implementation notes in this file for discussion of the details of this definition.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "category_theory.limits.types.binary_coproduct_colimit_cocone",
    "statement": "def category_theory.limits.types.binary_coproduct_colimit_cocone (X Y : Type u) : category_theory.limits.colimit_cocone (category_theory.limits.pair X Y)",
    "theorem": "(X Y : Type u) : category_theory.limits.colimit_cocone (category_theory.limits.pair X Y)",
    "args": "(X Y : Type u)",
    "doc_string": "The category of types has `X ⊕ Y`, as the binary coproduct of `X` and `Y`.",
    "kind": "def",
    "type": "category_theory.limits.colimit_cocone (category_theory.limits.pair X Y)"
  },
  {
    "name": "traversable",
    "statement": "structure traversable (t : Type u → Type u) : Type (u+1)",
    "theorem": "(t : Type u → Type u) : Type (u+1)",
    "args": "(t : Type u → Type u)",
    "doc_string": " A traversable functor is a functor along with a way to commute with all applicative functors (see `sequence`).  For example, if `t` is the traversable functor `list` and `m` is the applicative functor `io`, then given a function `f : α → io β`, the function `functor.map f` is `list α → list (io β)`, but `traverse f` is `list α → io (list β)`.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "monoid",
    "statement": "structure monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "congr_arg_kind",
    "statement": "inductive congr_arg_kind  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " This is a kind attached to an argument of a congruence lemma that tells the simplifier how to fill it in. - `fixed`: It is a parameter for the congruence lemma, the parameter occurs in the left and right hand sides.   For example the α in the congruence generated from `f: Π {α : Type} α → α`. - `fixed_no_param`: It is not a parameter for the congruence lemma, the lemma was specialized for this parameter.   This only happens if the parameter is a subsingleton/proposition, and other parameters depend on it. - `eq`: The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i = b_i)`.   `a_i` and `b_i` represent the left and right hand sides, and `eq_i` is a proof for their equality.   For example the second argument in `f: Π {α : Type}, α → α`. - `cast`: corresponds to arguments that are subsingletons/propositions.   For example the `p` in the congruence generated from `f : Π (x y : ℕ) (p: x < y), ℕ`. - `heq` The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i == b_i)`.    `a_i` and `b_i` represent the left and right hand sides, and eq_i is a proof for their heterogeneous equality.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "is_regular_of_ne_zero",
    "statement": "theorem is_regular_of_ne_zero {R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ≠ 0) : is_regular a",
    "theorem": "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ≠ 0) : is_regular a",
    "args": "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ≠ 0)",
    "doc_string": "Non-zero elements of an integral domain are regular.",
    "kind": "theorem",
    "type": "is_regular a"
  },
  {
    "name": "set.add_action_set",
    "statement": "def set.add_action_set {α : Type u_2} {β : Type u_3} [add_monoid α] [add_action α β] : add_action α (set β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [add_monoid α] [add_action α β] : add_action α (set β)",
    "args": "{α : Type u_2} {β : Type u_3} [add_monoid α] [add_action α β]",
    "doc_string": "An additive action of an additive monoid on a type `β` gives an additive action on `set β`.",
    "kind": "def",
    "type": "add_action α (set β)"
  },
  {
    "name": "nat.dvd_right_iff_eq",
    "statement": "theorem nat.dvd_right_iff_eq {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n",
    "theorem": "{m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n",
    "args": "{m n : ℕ}",
    "doc_string": "Two natural numbers are equal if and only if the have the same multiples.",
    "kind": "theorem",
    "type": "(∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n"
  },
  {
    "name": "finset.sym",
    "statement": "def finset.sym {α : Type u_1} [decidable_eq α] (s : finset α) (n : ℕ) : finset (sym α n)",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : finset α) (n : ℕ) : finset (sym α n)",
    "args": "{α : Type u_1} [decidable_eq α] (s : finset α) (n : ℕ)",
    "doc_string": " Lifts a finset to `sym α n`. `s.sym n` is the finset of all unordered tuples of cardinality `n` with elements in `s`.",
    "kind": "def",
    "type": "finset (sym α n)"
  },
  {
    "name": "has_set_prod",
    "statement": "structure has_set_prod (α : Type u_1) (β : Type u_2) (γ : out_param (Type u_3)) : Type (max u_1 u_2 u_3)",
    "theorem": "(α : Type u_1) (β : Type u_2) (γ : out_param (Type u_3)) : Type (max u_1 u_2 u_3)",
    "args": "(α : Type u_1) (β : Type u_2) (γ : out_param (Type u_3))",
    "doc_string": "Notation class for product of subobjects (sets, submonoids, subgroups, etc).",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "ordinal.bsup",
    "statement": "def ordinal.bsup (o : ordinal) (f : Π (a : ordinal), a < o → ordinal) : ordinal",
    "theorem": "(o : ordinal) (f : Π (a : ordinal), a < o → ordinal) : ordinal",
    "args": "(o : ordinal) (f : Π (a : ordinal), a < o → ordinal)",
    "doc_string": "The supremum of a family of ordinals indexed by the set of ordinals less than some    `o : ordinal.{u}`. This is a special case of `sup` over the family provided by    `family_of_bfamily`.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "hahn_series",
    "statement": "structure hahn_series (Γ : Type u_1) (R : Type u_2) [partial_order Γ] [has_zero R] : Type (max u_1 u_2)",
    "theorem": "(Γ : Type u_1) (R : Type u_2) [partial_order Γ] [has_zero R] : Type (max u_1 u_2)",
    "args": "(Γ : Type u_1) (R : Type u_2) [partial_order Γ] [has_zero R]",
    "doc_string": "If `Γ` is linearly ordered and `R` has zero, then `hahn_series Γ R` consists of  formal series over `Γ` with coefficients in `R`, whose supports are well-founded.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "polynomial.degree_le",
    "statement": "def polynomial.degree_le (R : Type u) [semiring R] (n : with_bot ℕ) : submodule R (polynomial R)",
    "theorem": "(R : Type u) [semiring R] (n : with_bot ℕ) : submodule R (polynomial R)",
    "args": "(R : Type u) [semiring R] (n : with_bot ℕ)",
    "doc_string": "The `R`-submodule of `R[X]` consisting of polynomials of degree ≤ `n`.",
    "kind": "def",
    "type": "submodule R (polynomial R)"
  },
  {
    "name": "surreal.has_neg",
    "statement": "def surreal.has_neg  : has_neg surreal",
    "theorem": " : has_neg surreal",
    "args": "",
    "doc_string": " Negation for surreal numbers is inherited from pre-game negation: the negation of `{L | R}` is `{-R | -L}`.",
    "kind": "def",
    "type": "has_neg surreal"
  },
  {
    "name": "add_comm_group.total_positive_cone",
    "statement": "structure add_comm_group.total_positive_cone (α : Type u_1) [add_comm_group α] : Type u_1",
    "theorem": "(α : Type u_1) [add_comm_group α] : Type u_1",
    "args": "(α : Type u_1) [add_comm_group α]",
    "doc_string": " A positive cone in an `add_comm_group` induces a linear order if for every `a`, either `a` or `-a` is non-negative.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "division_comm_monoid",
    "statement": "structure division_comm_monoid (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": " Commutative `division_monoid`.  This is the immediate common ancestor of `comm_group` and `comm_group_with_zero`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "nonarchimedean_group.prod.nonarchimedean_group",
    "statement": "def nonarchimedean_group.prod.nonarchimedean_group {G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K] : nonarchimedean_group (G × K)",
    "theorem": "{G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K] : nonarchimedean_group (G × K)",
    "args": "{G : Type u_1} [group G] [topological_space G] [nonarchimedean_group G] {K : Type u_3} [group K] [topological_space K] [nonarchimedean_group K]",
    "doc_string": "The cartesian product of two nonarchimedean groups is nonarchimedean.",
    "kind": "def",
    "type": "nonarchimedean_group (G × K)"
  },
  {
    "name": "is_group_hom.id",
    "statement": "theorem is_group_hom.id {α : Type u} [group α] : is_group_hom id",
    "theorem": "{α : Type u} [group α] : is_group_hom id",
    "args": "{α : Type u} [group α]",
    "doc_string": "The identity is a group homomorphism.",
    "kind": "theorem",
    "type": "is_group_hom id"
  },
  {
    "name": "lazy_list.init",
    "statement": "def lazy_list.init {α : Type u_1} : lazy_list α → lazy_list α",
    "theorem": "{α : Type u_1} : lazy_list α → lazy_list α",
    "args": "{α : Type u_1}",
    "doc_string": " `init xs`, if `xs` non-empty, drops the last element of the list. Otherwise, return the empty list.",
    "kind": "def",
    "type": "lazy_list α → lazy_list α"
  },
  {
    "name": "algebraic_geometry.Scheme.open_cover",
    "statement": "structure algebraic_geometry.Scheme.open_cover (X : algebraic_geometry.Scheme) : Type (max (u+1) (v+1))",
    "theorem": "(X : algebraic_geometry.Scheme) : Type (max (u+1) (v+1))",
    "args": "(X : algebraic_geometry.Scheme)",
    "doc_string": " An open cover of `X` consists of a family of open immersions into `X`, and for each `x : X` an open immersion (indexed by `f x`) that covers `x`.  This is merely a coverage in the Zariski pretopology, and it would be optimal if we could reuse the existing API about pretopologies, However, the definitions of sieves and grothendieck topologies uses `Prop`s, so that the actual open sets and immersions are hard to obtain. Also, since such a coverage in the pretopology usually contains a proper class of immersions, it is quite hard to glue them, reason about finite covers, etc.",
    "kind": "structure",
    "type": "Type (max (u+1) (v+1))"
  },
  {
    "name": "ring_subgroups_basis.topology",
    "statement": "def ring_subgroups_basis.topology {A : Type u_1} {ι : Type u_2} [ring A] [nonempty ι] {B : ι → add_subgroup A} (hB : ring_subgroups_basis B) : topological_space A",
    "theorem": "{A : Type u_1} {ι : Type u_2} [ring A] [nonempty ι] {B : ι → add_subgroup A} (hB : ring_subgroups_basis B) : topological_space A",
    "args": "{A : Type u_1} {ι : Type u_2} [ring A] [nonempty ι] {B : ι → add_subgroup A} (hB : ring_subgroups_basis B)",
    "doc_string": " The topology defined from a subgroups basis, admitting the given subgroups as a basis of neighborhoods of zero.",
    "kind": "def",
    "type": "topological_space A"
  },
  {
    "name": "holder_on_with",
    "statement": "def holder_on_with {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X → Y) (s : set X) : Prop",
    "theorem": "{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X → Y) (s : set X) : Prop",
    "args": "{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] (C r : nnreal) (f : X → Y) (s : set X)",
    "doc_string": " A function `f : X → Y` between two `pseudo_emeteric_space`s is Hölder continuous with constant `C : ℝ≥0` and exponent `r : ℝ≥0` on a set `s : set X`, if `edist (f x) (f y) ≤ C * edist x y ^ r` for all `x y ∈ s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.injective.pairwise_ne",
    "statement": "theorem function.injective.pairwise_ne {α : Type u_1} {ι : Type u_2} {f : ι → α} : function.injective f → pairwise (ne on f)",
    "theorem": "{α : Type u_1} {ι : Type u_2} {f : ι → α} : function.injective f → pairwise (ne on f)",
    "args": "{α : Type u_1} {ι : Type u_2} {f : ι → α}",
    "doc_string": "**Alias** of the forward direction of function.injective_iff_pairwise_ne`.",
    "kind": "theorem",
    "type": "function.injective f → pairwise (ne on f)"
  },
  {
    "name": "derive_fintype.finset_above",
    "statement": "def derive_fintype.finset_above (α : Type u_1) (enum : α → ℕ) (n : ℕ) : Type u_1",
    "theorem": "(α : Type u_1) (enum : α → ℕ) (n : ℕ) : Type u_1",
    "args": "(α : Type u_1) (enum : α → ℕ) (n : ℕ)",
    "doc_string": " A step in the construction of `finset.univ` for a finite inductive type. We will set `enum` to the discriminant of the inductive type, so a `finset_above` represents a finset that enumerates all elements in a tail of the constructor list.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "category_theory.subsingleton_preadditive_of_has_binary_biproducts",
    "statement": "def category_theory.subsingleton_preadditive_of_has_binary_biproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] : subsingleton (category_theory.preadditive C)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C] : subsingleton (category_theory.preadditive C)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_binary_biproducts C]",
    "doc_string": "The existence of binary biproducts implies that there is at most one preadditive structure.",
    "kind": "def",
    "type": "subsingleton (category_theory.preadditive C)"
  },
  {
    "name": "witt_structure_int",
    "statement": "def witt_structure_int (p : ℕ) {idx : Type u_2} [hp : fact (nat.prime p)] (Φ : mv_polynomial idx ℤ) (n : ℕ) : mv_polynomial (idx × ℕ) ℤ",
    "theorem": "(p : ℕ) {idx : Type u_2} [hp : fact (nat.prime p)] (Φ : mv_polynomial idx ℤ) (n : ℕ) : mv_polynomial (idx × ℕ) ℤ",
    "args": "(p : ℕ) {idx : Type u_2} [hp : fact (nat.prime p)] (Φ : mv_polynomial idx ℤ) (n : ℕ)",
    "doc_string": " `witt_structure_int Φ` is a family of polynomials `ℕ → mv_polynomial (idx × ℕ) ℤ` that are uniquely characterised by the property that ```lean bind₁ (witt_structure_int p Φ) (witt_polynomial p ℤ n) = bind₁ (λ i, (rename (prod.mk i) (witt_polynomial p ℤ n))) Φ ``` In other words: evaluating the `n`-th Witt polynomial on the family `witt_structure_int Φ` is the same as evaluating `Φ` on the (appropriately renamed) `n`-th Witt polynomials.  See `witt_structure_int_prop` for this property, and `witt_structure_int_exists_unique` for the fact that `witt_structure_int` gives the unique family of polynomials with this property.",
    "kind": "def",
    "type": "mv_polynomial (idx × ℕ) ℤ"
  },
  {
    "name": "nonarchimedean_ring",
    "statement": "structure nonarchimedean_ring (R : Type u_1) [ring R] [topological_space R] : Prop",
    "theorem": "(R : Type u_1) [ring R] [topological_space R] : Prop",
    "args": "(R : Type u_1) [ring R] [topological_space R]",
    "doc_string": "An topological ring is nonarchimedean if its underlying topological additive  group is nonarchimedean.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "neg_dvd",
    "statement": "theorem neg_dvd {α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : -a ∣ b ↔ a ∣ b",
    "theorem": "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : -a ∣ b ↔ a ∣ b",
    "args": "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α)",
    "doc_string": " The negation of an element a of a semigroup with a distributive negation divides another element b iff a divides b.",
    "kind": "theorem",
    "type": "-a ∣ b ↔ a ∣ b"
  },
  {
    "name": "inner_product_space.of_core.to_has_inner",
    "statement": "def inner_product_space.of_core.to_has_inner {𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] : has_inner 𝕜 F",
    "theorem": "{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] : has_inner 𝕜 F",
    "args": "{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F]",
    "doc_string": "Inner product defined by the `inner_product_space.core` structure.",
    "kind": "def",
    "type": "has_inner 𝕜 F"
  },
  {
    "name": "ordset.nil",
    "statement": "def ordset.nil {α : Type u_1} [preorder α] : ordset α",
    "theorem": "{α : Type u_1} [preorder α] : ordset α",
    "args": "{α : Type u_1} [preorder α]",
    "doc_string": "O(1). The empty set.",
    "kind": "def",
    "type": "ordset α"
  },
  {
    "name": "tactic.apply_cfg",
    "statement": "structure tactic.apply_cfg  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Configuration options for the `apply` tactic. - `md` sets how aggressively definitions are unfolded. - `new_goals` is the strategy for ordering new goals. - `instances` if `tt`, then `apply` tries to synthesize unresolved `[...]` arguments using type class resolution. - `auto_param` if `tt`, then `apply` tries to synthesize unresolved `(h : p . tac_id)` arguments using tactic `tac_id`. - `opt_param` if `tt`, then `apply` tries to synthesize unresolved `(a : t := v)` arguments by setting them to `v`. - `unify` if `tt`, then `apply` is free to assign existing metavariables in the goal when solving unification constraints.    For example, in the goal `|- ?x < succ 0`, the tactic `apply succ_lt_succ` succeeds with the default configuration,    but `apply_with succ_lt_succ {unify := ff}` doesn't since it would require Lean to assign `?x` to `succ ?y` where    `?y` is a fresh metavariable.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "add_units.add_right",
    "statement": "def add_units.add_right {M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M",
    "theorem": "{M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M",
    "args": "{M : Type u_6} [add_monoid M] (u : add_units M)",
    "doc_string": "Right addition of an additive unit is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm M"
  },
  {
    "name": "num.sub",
    "statement": "def num.sub (a b : num) : num",
    "theorem": "(a b : num) : num",
    "args": "(a b : num)",
    "doc_string": "Subtraction of two `num`s, where if `a < b`, `a - b = 0`.",
    "kind": "def",
    "type": "num"
  },
  {
    "name": "witt_vector.poly_of_interest",
    "statement": "def witt_vector.poly_of_interest (p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ)",
    "doc_string": "This is the polynomial whose degree we want to get a handle on.",
    "kind": "def",
    "type": "mv_polynomial (fin 2 × ℕ) ℤ"
  },
  {
    "name": "algebraic_geometry.RingedSpace",
    "statement": "def algebraic_geometry.RingedSpace  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The type of Ringed spaces, as an abbreviation for `SheafedSpace CommRing`.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "is_local_max_on",
    "statement": "def is_local_max_on {α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α)",
    "doc_string": "`is_local_max_on f s a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.dual",
    "statement": "def ordnode.dual {α : Type u} : ordnode α → ordnode α",
    "theorem": "{α : Type u} : ordnode α → ordnode α",
    "args": "{α : Type u}",
    "doc_string": " **Internal use only**, because it violates the BST property on the original order.  O(n). The dual of a tree is a tree with its left and right sides reversed throughout. The dual of a valid BST is valid under the dual order. This is convenient for exploiting symmetries in the algorithms.",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "eq.trans_ge",
    "statement": "theorem eq.trans_ge {α : Type u} [preorder α] {a b c : α} : b = c → a ≤ b → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b = c → a ≤ b → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of le_of_eq_of_le'`.",
    "kind": "theorem",
    "type": "b = c → a ≤ b → a ≤ c"
  },
  {
    "name": "measure_theory.outer_measure.mk_metric'.pre",
    "statement": "def measure_theory.outer_measure.mk_metric'.pre {X : Type u_2} [emetric_space X] (m : set X → ennreal) (r : ennreal) : measure_theory.outer_measure X",
    "theorem": "{X : Type u_2} [emetric_space X] (m : set X → ennreal) (r : ennreal) : measure_theory.outer_measure X",
    "args": "{X : Type u_2} [emetric_space X] (m : set X → ennreal) (r : ennreal)",
    "doc_string": " Auxiliary definition for `outer_measure.mk_metric'`: given a function on sets `m : set X → ℝ≥0∞`, returns the maximal outer measure `μ` such that `μ s ≤ m s` for any set `s` of diameter at most `r`.",
    "kind": "def",
    "type": "measure_theory.outer_measure X"
  },
  {
    "name": "category_theory.fin_category.as_type",
    "statement": "def category_theory.fin_category.as_type (α : Type u_1) [fintype α] [category_theory.small_category α] [category_theory.fin_category α] : Type",
    "theorem": "(α : Type u_1) [fintype α] [category_theory.small_category α] [category_theory.fin_category α] : Type",
    "args": "(α : Type u_1) [fintype α] [category_theory.small_category α] [category_theory.fin_category α]",
    "doc_string": "A fin_category `α` is equivalent to a fin_category with in `Type`.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "cardinal.aleph",
    "statement": "def cardinal.aleph (o : ordinal) : cardinal",
    "theorem": "(o : ordinal) : cardinal",
    "args": "(o : ordinal)",
    "doc_string": "The `aleph` function gives the infinite cardinals listed by their  ordinal index. `aleph 0 = ℵ₀`, `aleph 1 = succ ℵ₀` is the first  uncountable cardinal, and so on.",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "has_Inf",
    "statement": "structure has_Inf (α : Type u_8) : Type u_8",
    "theorem": "(α : Type u_8) : Type u_8",
    "args": "(α : Type u_8)",
    "doc_string": "class for the `Inf` operator",
    "kind": "structure",
    "type": "Type u_8"
  },
  {
    "name": "subfield.zero_mem",
    "statement": "theorem subfield.zero_mem {K : Type u} [field K] (s : subfield K) : 0 ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) : 0 ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K)",
    "doc_string": "A subfield contains the field's 0.",
    "kind": "theorem",
    "type": "0 ∈ s"
  },
  {
    "name": "tactic.ring.ring_m",
    "statement": "def tactic.ring.ring_m (α : Type) : Type",
    "theorem": "(α : Type) : Type",
    "args": "(α : Type)",
    "doc_string": " The monad that `ring` works in. This is a reader monad containing a mutable cache (using `ref` for mutability), as well as the list of atoms-up-to-defeq encountered thus far, used for atom sorting.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "supr",
    "statement": "def supr {α : Type u_1} [has_Sup α] {ι : Sort u_2} (s : ι → α) : α",
    "theorem": "{α : Type u_1} [has_Sup α] {ι : Sort u_2} (s : ι → α) : α",
    "args": "{α : Type u_1} [has_Sup α] {ι : Sort u_2} (s : ι → α)",
    "doc_string": "Indexed supremum",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "continuous_monoid_hom.diag",
    "statement": "def continuous_monoid_hom.diag (A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A (A × A)",
    "theorem": "(A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A (A × A)",
    "args": "(A : Type u_4) [monoid A] [topological_space A]",
    "doc_string": "The continuous homomorphism given by the diagonal embedding.",
    "kind": "def",
    "type": "continuous_monoid_hom A (A × A)"
  },
  {
    "name": "array.pop_back",
    "statement": "def array.pop_back {n : ℕ} {α : Type u} (a : array (n + 1) α) : array n α",
    "theorem": "{n : ℕ} {α : Type u} (a : array (n + 1) α) : array n α",
    "args": "{n : ℕ} {α : Type u} (a : array (n + 1) α)",
    "doc_string": "Discard _last_ element in the array. Has builtin VM implementation.",
    "kind": "def",
    "type": "array n α"
  },
  {
    "name": "bounded_continuous_function.inhabited",
    "statement": "def bounded_continuous_function.inhabited {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] [inhabited β] : inhabited (bounded_continuous_function α β)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] [inhabited β] : inhabited (bounded_continuous_function α β)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] [inhabited β]",
    "doc_string": "If the target space is inhabited, so is the space of bounded continuous functions",
    "kind": "def",
    "type": "inhabited (bounded_continuous_function α β)"
  },
  {
    "name": "tactic.eliminate.with_pattern",
    "statement": "inductive tactic.eliminate.with_pattern  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Representation of a pattern in the `with n ...` syntax supported by `induction'` and `cases'`. A `with_pattern` can be:  - `with_pattern.auto` (`with _` or no `with` clause): use the name generated by the tactic. - `with_pattern.clear` (`with -`): clear this hypothesis and any hypotheses depending on it. - `with_pattern.exact n` (`with n`): use the name `n` for this hypothesis.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "matrix.is_unit_diagonal",
    "statement": "theorem matrix.is_unit_diagonal {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α} : is_unit (matrix.diagonal v) ↔ is_unit v",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α} : is_unit (matrix.diagonal v) ↔ is_unit v",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α}",
    "doc_string": "When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`.",
    "kind": "theorem",
    "type": "is_unit (matrix.diagonal v) ↔ is_unit v"
  },
  {
    "name": "topological_space.partial_order",
    "statement": "def topological_space.partial_order {α : Type u} : partial_order (topological_space α)",
    "theorem": "{α : Type u} : partial_order (topological_space α)",
    "args": "{α : Type u}",
    "doc_string": "The ordering on topologies on the type `α`.  `t ≤ s` if every set open in `s` is also open in `t` (`t` is finer than `s`).",
    "kind": "def",
    "type": "partial_order (topological_space α)"
  },
  {
    "name": "ordered_add_comm_group.lt_of_add_lt_add_left",
    "statement": "theorem ordered_add_comm_group.lt_of_add_lt_add_left {α : Type u_1} [has_add α] [has_lt α] [contravariant_class α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c) : b < c",
    "theorem": "{α : Type u_1} [has_add α] [has_lt α] [contravariant_class α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c) : b < c",
    "args": "{α : Type u_1} [has_add α] [has_lt α] [contravariant_class α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c)",
    "doc_string": "**Alias** of lt_of_mul_lt_mul_left'`.",
    "kind": "theorem",
    "type": "b < c"
  },
  {
    "name": "part.fix",
    "statement": "def part.fix {α : Type u_1} {β : α → Type u_2} (f : (Π (a : α), part (β a)) → Π (a : α), part (β a)) (x : α) : part (β x)",
    "theorem": "{α : Type u_1} {β : α → Type u_2} (f : (Π (a : α), part (β a)) → Π (a : α), part (β a)) (x : α) : part (β x)",
    "args": "{α : Type u_1} {β : α → Type u_2} (f : (Π (a : α), part (β a)) → Π (a : α), part (β a)) (x : α)",
    "doc_string": " The least fixed point of `f`.  If `f` is a continuous function (according to complete partial orders), it satisfies the equations:    1. `fix f = f (fix f)`          (is a fixed point)   2. `∀ X, f X ≤ X → fix f ≤ X`   (least fixed point)",
    "kind": "def",
    "type": "part (β x)"
  },
  {
    "name": "category_theory.free_bicategory.normalize_aux",
    "statement": "def category_theory.free_bicategory.normalize_aux {B : Type u} [quiver B] {a b c : B} : quiver.path a b → category_theory.free_bicategory.hom b c → quiver.path a c",
    "theorem": "{B : Type u} [quiver B] {a b c : B} : quiver.path a b → category_theory.free_bicategory.hom b c → quiver.path a c",
    "args": "{B : Type u} [quiver B] {a b c : B}",
    "doc_string": "The normalization of the composition of `p : path a b` and `f : hom b c`. `p` will eventually be taken to be `nil` and we then get the normalization of `f` alone, but the auxiliary `p` is necessary for Lean to accept the definition of `normalize_iso` and the `whisker_left` case of `normalize_aux_congr` and `normalize_naturality`.",
    "kind": "def",
    "type": "quiver.path a b → category_theory.free_bicategory.hom b c → quiver.path a c"
  },
  {
    "name": "function.extend",
    "statement": "def function.extend {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β) (g : α → γ) (e' : β → γ) : β → γ",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β) (g : α → γ) (e' : β → γ) : β → γ",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} (f : α → β) (g : α → γ) (e' : β → γ)",
    "doc_string": " `extend f g e'` extends a function `g : α → γ` along a function `f : α → β` to a function `β → γ`, by using the values of `g` on the range of `f` and the values of an auxiliary function `e' : β → γ` elsewhere.  Mostly useful when `f` is injective.",
    "kind": "def",
    "type": "β → γ"
  },
  {
    "name": "fun_like",
    "statement": "structure fun_like (F : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (α → Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))",
    "theorem": "(F : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (α → Sort u_3)) : Sort (max 1 (imax u_1 u_2 u_3))",
    "args": "(F : Sort u_1) (α : out_param (Sort u_2)) (β : out_param (α → Sort u_3))",
    "doc_string": " The class `fun_like F α β` expresses that terms of type `F` have an injective coercion to functions from `α` to `β`.  This typeclass is used in the definition of the homomorphism typeclasses, such as `zero_hom_class`, `mul_hom_class`, `monoid_hom_class`, ....",
    "kind": "structure",
    "type": "Sort (max 1 (imax u_1 u_2 u_3))"
  },
  {
    "name": "polynomial.cyclotomic'",
    "statement": "def polynomial.cyclotomic' (n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : polynomial R",
    "theorem": "(n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R] : polynomial R",
    "args": "(n : ℕ) (R : Type u_1) [comm_ring R] [is_domain R]",
    "doc_string": " The modified `n`-th cyclotomic polynomial with coefficients in `R`, it is the usual cyclotomic polynomial if there is a primitive `n`-th root of unity in `R`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "ring.perfection_subring",
    "statement": "def ring.perfection_subring (R : Type u₁) [comm_ring R] (p : ℕ) [hp : fact (nat.prime p)] [char_p R p] : subring (ℕ → R)",
    "theorem": "(R : Type u₁) [comm_ring R] (p : ℕ) [hp : fact (nat.prime p)] [char_p R p] : subring (ℕ → R)",
    "args": "(R : Type u₁) [comm_ring R] (p : ℕ) [hp : fact (nat.prime p)] [char_p R p]",
    "doc_string": " The perfection of a ring `R` with characteristic `p`, as a subring, defined to be the projective limit of `R` using the Frobenius maps `R → R` indexed by the natural numbers, implemented as `{ f : ℕ → R | ∀ n, f (n + 1) ^ p = f n }`.",
    "kind": "def",
    "type": "subring (ℕ → R)"
  },
  {
    "name": "equiv.star",
    "statement": "def equiv.star {R : Type u} [has_involutive_star R] : equiv.perm R",
    "theorem": "{R : Type u} [has_involutive_star R] : equiv.perm R",
    "args": "{R : Type u} [has_involutive_star R]",
    "doc_string": "`star` as an equivalence when it is involutive.",
    "kind": "def",
    "type": "equiv.perm R"
  },
  {
    "name": "topological_fiber_prebundle",
    "statement": "structure topological_fiber_prebundle {B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z → B) : Type (max u_2 u_3 u_4)",
    "theorem": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z → B) : Type (max u_2 u_3 u_4)",
    "args": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z → B)",
    "doc_string": " This structure permits to define a fiber bundle when trivializations are given as local equivalences but there is not yet a topology on the total space. The total space is hence given a topology in such a way that there is a fiber bundle structure for which the local equivalences are also local homeomorphism and hence local trivializations.",
    "kind": "structure",
    "type": "Type (max u_2 u_3 u_4)"
  },
  {
    "name": "filter.has_vadd_filter",
    "statement": "def filter.has_vadd_filter {α : Type u_2} {β : Type u_3} [has_vadd α β] : has_vadd α (filter β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [has_vadd α β] : has_vadd α (filter β)",
    "args": "{α : Type u_2} {β : Type u_3} [has_vadd α β]",
    "doc_string": "`a +ᵥ f` is the map of `f` under `a +ᵥ` in locale `pointwise`.",
    "kind": "def",
    "type": "has_vadd α (filter β)"
  },
  {
    "name": "is_preirreducible",
    "statement": "def is_preirreducible {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "A preirreducible set `s` is one where there is no non-trivial pair of disjoint opens on `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "complete_lattice.independent.pairwise_disjoint",
    "statement": "theorem complete_lattice.independent.pairwise_disjoint {α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) : pairwise (disjoint on t)",
    "theorem": "{α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) : pairwise (disjoint on t)",
    "args": "{α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t)",
    "doc_string": "If the elements of a set are independent, then any pair within that set is disjoint.",
    "kind": "theorem",
    "type": "pairwise (disjoint on t)"
  },
  {
    "name": "lazy_list.approx",
    "statement": "def lazy_list.approx {α : Type u} : ℕ → lazy_list α → list α",
    "theorem": "{α : Type u} : ℕ → lazy_list α → list α",
    "args": "{α : Type u}",
    "doc_string": "The list containing the first `n` elements of a lazy list.",
    "kind": "def",
    "type": "ℕ → lazy_list α → list α"
  },
  {
    "name": "set.Ici",
    "statement": "def set.Ici {α : Type u_1} [preorder α] (a : α) : set α",
    "theorem": "{α : Type u_1} [preorder α] (a : α) : set α",
    "args": "{α : Type u_1} [preorder α] (a : α)",
    "doc_string": "Left-closed right-infinite interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "absolute_value",
    "statement": "structure absolute_value (R : Type u_1) (S : Type u_2) [semiring R] [ordered_semiring S] : Type (max u_1 u_2)",
    "theorem": "(R : Type u_1) (S : Type u_2) [semiring R] [ordered_semiring S] : Type (max u_1 u_2)",
    "args": "(R : Type u_1) (S : Type u_2) [semiring R] [ordered_semiring S]",
    "doc_string": " `absolute_value R S` is the type of absolute values on `R` mapping to `S`: the maps that preserve `*`, are nonnegative, positive definite and satisfy the triangle equality.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "no_bot_order",
    "statement": "structure no_bot_order (α : Type u_2) [has_le α] : Prop",
    "theorem": "(α : Type u_2) [has_le α] : Prop",
    "args": "(α : Type u_2) [has_le α]",
    "doc_string": "Order without bottom elements.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "tensor_product.compatible_smul.int",
    "statement": "def tensor_product.compatible_smul.int {R : Type u_1} [comm_semiring R] {M : Type u_2} {N : Type u_3} [add_comm_group M] [add_comm_group N] [module R M] [module R N] : tensor_product.compatible_smul R ℤ M N",
    "theorem": "{R : Type u_1} [comm_semiring R] {M : Type u_2} {N : Type u_3} [add_comm_group M] [add_comm_group N] [module R M] [module R N] : tensor_product.compatible_smul R ℤ M N",
    "args": "{R : Type u_1} [comm_semiring R] {M : Type u_2} {N : Type u_3} [add_comm_group M] [add_comm_group N] [module R M] [module R N]",
    "doc_string": "While the tensor product will automatically inherit a ℤ-module structure from `add_comm_group.int_module`, that structure won't be compatible with lemmas like `tmul_smul` unless we use a `ℤ-module` instance provided by `tensor_product.left_module`.  When `R` is a `ring` we get the required `tensor_product.compatible_smul` instance through `is_scalar_tower`, but when it is only a `semiring` we need to build it from scratch. The instance diamond in `compatible_smul` doesn't matter because it's in `Prop`.",
    "kind": "def",
    "type": "tensor_product.compatible_smul R ℤ M N"
  },
  {
    "name": "pontryagin_dual",
    "statement": "def pontryagin_dual (G : Type u_1) [monoid G] [topological_space G] : Type u_1",
    "theorem": "(G : Type u_1) [monoid G] [topological_space G] : Type u_1",
    "args": "(G : Type u_1) [monoid G] [topological_space G]",
    "doc_string": "The Pontryagin dual of `G` is the group of continuous homomorphism `G → circle`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "filter.filter_basis.of_sets",
    "statement": "def filter.filter_basis.of_sets {α : Type u_1} (s : set (set α)) : filter_basis α",
    "theorem": "{α : Type u_1} (s : set (set α)) : filter_basis α",
    "args": "{α : Type u_1} (s : set (set α))",
    "doc_string": "The smallest filter basis containing a given collection of sets.",
    "kind": "def",
    "type": "filter_basis α"
  },
  {
    "name": "category_theory.End",
    "statement": "def category_theory.End {C : Type u} [category_theory.category_struct C] (X : C) : Type v",
    "theorem": "{C : Type u} [category_theory.category_struct C] (X : C) : Type v",
    "args": "{C : Type u} [category_theory.category_struct C] (X : C)",
    "doc_string": " Endomorphisms of an object in a category. Arguments order in multiplication agrees with `function.comp`, not with `category.comp`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "topological_fiber_bundle.trivialization",
    "statement": "structure topological_fiber_bundle.trivialization {B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B) : Type (max u_2 u_3 u_4)",
    "theorem": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B) : Type (max u_2 u_3 u_4)",
    "args": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B)",
    "doc_string": "A structure extending local homeomorphisms, defining a local trivialization of a projection `proj : Z → B` with fiber `F`, as a local homeomorphism between `Z` and `B × F` defined between two sets of the form `proj ⁻¹' base_set` and `base_set × F`, acting trivially on the first coordinate.",
    "kind": "structure",
    "type": "Type (max u_2 u_3 u_4)"
  },
  {
    "name": "has_lift",
    "statement": "structure has_lift (a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))",
    "theorem": "(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))",
    "args": "(a : Sort u) (b : Sort v)",
    "doc_string": "Can perform a lifting operation `↑a`.",
    "kind": "structure",
    "type": "Sort (max 1 (imax u v))"
  },
  {
    "name": "znum.abs",
    "statement": "def znum.abs  : znum → num",
    "theorem": " : znum → num",
    "args": "",
    "doc_string": "The absolute value of a `znum` as a `num`.",
    "kind": "def",
    "type": "znum → num"
  },
  {
    "name": "has_top",
    "statement": "structure has_top (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Typeclass for the `⊤` (`\\top`) notation",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "quaternion_group",
    "statement": "inductive quaternion_group (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": "The (generalised) quaternion group `quaternion_group n` of order `4n`. It can be defined by the presentation $\\langle a, x | a^{2n} = 1, x^2 = a^n, x^{-1}ax=a^{-1}\\rangle$. We write `a i` for $a^i$ and `xa i` for $x * a^i$.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "nonempty_measurable_superset",
    "statement": "theorem nonempty_measurable_superset {α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t}",
    "theorem": "{α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t}",
    "args": "{α : Type u_1} {m : measurable_space α} (s : set α)",
    "doc_string": "Every set has a measurable superset. Declare this as local instance as needed.",
    "kind": "theorem",
    "type": "nonempty {t // s ⊆ t ∧ measurable_set t}"
  },
  {
    "name": "dvd_add_self_right",
    "statement": "theorem dvd_add_self_right {α : Type u} [ring α] {a b : α} : a ∣ b + a ↔ a ∣ b",
    "theorem": "{α : Type u} [ring α] {a b : α} : a ∣ b + a ↔ a ∣ b",
    "args": "{α : Type u} [ring α] {a b : α}",
    "doc_string": "An element a divides the sum b + a if and only if a divides b.",
    "kind": "theorem",
    "type": "a ∣ b + a ↔ a ∣ b"
  },
  {
    "name": "cartan_matrix.E₆",
    "statement": "def cartan_matrix.E₆  : matrix (fin 6) (fin 6) ℤ",
    "theorem": " : matrix (fin 6) (fin 6) ℤ",
    "args": "",
    "doc_string": " The Cartan matrix of type e₆. See [bourbaki1968] plate V, page 277.  The corresponding Dynkin diagram is: ```lean             o             | o --- o --- o --- o --- o ```",
    "kind": "def",
    "type": "matrix (fin 6) (fin 6) ℤ"
  },
  {
    "name": "order.frame",
    "statement": "structure order.frame (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A frame, aka complete Heyting algebra, is a complete lattice whose `⊓` distributes over `⨆`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "fin.fin.lt.is_well_order",
    "statement": "def fin.fin.lt.is_well_order (n : ℕ) : is_well_order (fin n) has_lt.lt",
    "theorem": "(n : ℕ) : is_well_order (fin n) has_lt.lt",
    "args": "(n : ℕ)",
    "doc_string": "The ordering on `fin n` is a well order.",
    "kind": "def",
    "type": "is_well_order (fin n) has_lt.lt"
  },
  {
    "name": "dense.inter_of_open_right",
    "statement": "theorem dense.inter_of_open_right {α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t)",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t)",
    "args": "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t)",
    "doc_string": "The intersection of a dense set with an open dense set is a dense set.",
    "kind": "theorem",
    "type": "dense (s ∩ t)"
  },
  {
    "name": "add_group.fg",
    "statement": "structure add_group.fg (H : Type u_4) [add_group H] : Prop",
    "theorem": "(H : Type u_4) [add_group H] : Prop",
    "args": "(H : Type u_4) [add_group H]",
    "doc_string": " An additive group is finitely generated if it is finitely generated as an additive submonoid of itself.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "left.add_nonpos",
    "statement": "theorem left.add_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_nonpos`.",
    "kind": "theorem",
    "type": "a + b ≤ 0"
  },
  {
    "name": "is_fw_invariant.is_invariant",
    "statement": "theorem is_fw_invariant.is_invariant {τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} (h : is_fw_invariant ϕ s) : is_invariant ϕ s",
    "theorem": "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} (h : is_fw_invariant ϕ s) : is_invariant ϕ s",
    "args": "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} (h : is_fw_invariant ϕ s)",
    "doc_string": " If `τ` is a `canonically_ordered_add_monoid` (e.g., `ℕ` or `ℝ≥0`), then the notions `is_fw_invariant` and `is_invariant` are equivalent.",
    "kind": "theorem",
    "type": "is_invariant ϕ s"
  },
  {
    "name": "free_lie_algebra.lie_ring",
    "statement": "def free_lie_algebra.lie_ring (R : Type u) (X : Type v) [comm_ring R] : lie_ring (free_lie_algebra R X)",
    "theorem": "(R : Type u) (X : Type v) [comm_ring R] : lie_ring (free_lie_algebra R X)",
    "args": "(R : Type u) (X : Type v) [comm_ring R]",
    "doc_string": " Note that here we turn the `has_mul` coming from the `non_unital_non_assoc_semiring` structure on `lib R X` into a `has_bracket` on `free_lie_algebra`.",
    "kind": "def",
    "type": "lie_ring (free_lie_algebra R X)"
  },
  {
    "name": "wseq.scanl",
    "statement": "def wseq.scanl {α : Type u} {β : Type v} (f : α → β → α) (a : α) (s : wseq β) : wseq α",
    "theorem": "{α : Type u} {β : Type v} (f : α → β → α) (a : α) (s : wseq β) : wseq α",
    "args": "{α : Type u} {β : Type v} (f : α → β → α) (a : α) (s : wseq β)",
    "doc_string": "Apply a function to the elements of the sequence to produce a sequence  of partial results. (There is no `scanr` because this would require  working from the end of the sequence, which may not exist.)",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "has_to_format",
    "statement": "structure has_to_format (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " Use this instead of `has_to_string` to enable prettier formatting. See docstring for `format` for more on the differences between `format` and `string`. Note that `format` is `meta` while `string` is not.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "sigma.le",
    "statement": "inductive sigma.le {ι : Type u_1} {α : ι → Type u_2} [Π (i : ι), has_le (α i)] (a b : Σ (i : ι), α i) : Prop",
    "theorem": "{ι : Type u_1} {α : ι → Type u_2} [Π (i : ι), has_le (α i)] (a b : Σ (i : ι), α i) : Prop",
    "args": "{ι : Type u_1} {α : ι → Type u_2} [Π (i : ι), has_le (α i)] (a b : Σ (i : ι), α i)",
    "doc_string": "Disjoint sum of orders. `⟨i, a⟩ ≤ ⟨j, b⟩` iff `i = j` and `a ≤ b`.",
    "kind": "inductive",
    "type": "Prop"
  },
  {
    "name": "Set.choice",
    "statement": "def Set.choice (x : Set) : Set",
    "theorem": "(x : Set) : Set",
    "args": "(x : Set)",
    "doc_string": "A choice function on the class of nonempty ZFC sets.",
    "kind": "def",
    "type": "Set"
  },
  {
    "name": "galois_coinsertion.lift_order_bot",
    "statement": "def galois_coinsertion.lift_order_bot {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [preorder β] [order_bot β] (gi : galois_coinsertion l u) : order_bot α",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [preorder β] [order_bot β] (gi : galois_coinsertion l u) : order_bot α",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [preorder β] [order_bot β] (gi : galois_coinsertion l u)",
    "doc_string": "Lift the bot along a Galois coinsertion",
    "kind": "def",
    "type": "order_bot α"
  },
  {
    "name": "function.surjective.unique",
    "statement": "def function.surjective.unique {α : Sort u} {β : Sort v} {f : α → β} (hf : function.surjective f) [unique α] : unique β",
    "theorem": "{α : Sort u} {β : Sort v} {f : α → β} (hf : function.surjective f) [unique α] : unique β",
    "args": "{α : Sort u} {β : Sort v} {f : α → β} (hf : function.surjective f) [unique α]",
    "doc_string": " If the domain of a surjective function is a singleton, then the codomain is a singleton as well.",
    "kind": "def",
    "type": "unique β"
  },
  {
    "name": "algebraic_geometry.Spec.structure_sheaf",
    "statement": "def algebraic_geometry.Spec.structure_sheaf (R : Type u) [comm_ring R] : Top.sheaf CommRing (algebraic_geometry.prime_spectrum.Top R)",
    "theorem": "(R : Type u) [comm_ring R] : Top.sheaf CommRing (algebraic_geometry.prime_spectrum.Top R)",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "The structure sheaf on $Spec R$, valued in `CommRing`.  This is provided as a bundled `SheafedSpace` as `Spec.SheafedSpace R` later.",
    "kind": "def",
    "type": "Top.sheaf CommRing (algebraic_geometry.prime_spectrum.Top R)"
  },
  {
    "name": "turing.tm2_computable_aux",
    "statement": "structure turing.tm2_computable_aux (Γ₀ Γ₁ : Type) : Type 1",
    "theorem": "(Γ₀ Γ₁ : Type) : Type 1",
    "args": "(Γ₀ Γ₁ : Type)",
    "doc_string": "A Turing machine with input alphabet equivalent to Γ₀ and output alphabet equivalent to Γ₁.",
    "kind": "structure",
    "type": "Type 1"
  },
  {
    "name": "function.cantor_surjective",
    "statement": "theorem function.cantor_surjective {α : Type u_1} (f : α → set α) : ¬function.surjective f",
    "theorem": "{α : Type u_1} (f : α → set α) : ¬function.surjective f",
    "args": "{α : Type u_1} (f : α → set α)",
    "doc_string": " **Cantor's diagonal argument** implies that there are no surjective functions from `α` to `set α`.",
    "kind": "theorem",
    "type": "¬function.surjective f"
  },
  {
    "name": "is_nilpotent.to_is_solvable",
    "statement": "def is_nilpotent.to_is_solvable {G : Type u_1} [group G] [h : group.is_nilpotent G] : is_solvable G",
    "theorem": "{G : Type u_1} [group G] [h : group.is_nilpotent G] : is_solvable G",
    "args": "{G : Type u_1} [group G] [h : group.is_nilpotent G]",
    "doc_string": "A nilpotent subgroup is solvable",
    "kind": "def",
    "type": "is_solvable G"
  },
  {
    "name": "Compactum_to_CompHaus.full",
    "statement": "def Compactum_to_CompHaus.full  : category_theory.full Compactum_to_CompHaus",
    "theorem": " : category_theory.full Compactum_to_CompHaus",
    "args": "",
    "doc_string": "The functor Compactum_to_CompHaus is full.",
    "kind": "def",
    "type": "category_theory.full Compactum_to_CompHaus"
  },
  {
    "name": "lattice.to_linear_order",
    "statement": "def lattice.to_linear_order (α : Type u) [lattice α] [decidable_eq α] [decidable_rel has_le.le] [decidable_rel has_lt.lt] [is_total α has_le.le] : linear_order α",
    "theorem": "(α : Type u) [lattice α] [decidable_eq α] [decidable_rel has_le.le] [decidable_rel has_lt.lt] [is_total α has_le.le] : linear_order α",
    "args": "(α : Type u) [lattice α] [decidable_eq α] [decidable_rel has_le.le] [decidable_rel has_lt.lt] [is_total α has_le.le]",
    "doc_string": " A lattice with total order is a linear order.  See note [reducible non-instances].",
    "kind": "def",
    "type": "linear_order α"
  },
  {
    "name": "subring.list_prod_mem",
    "statement": "theorem subring.list_prod_mem {R : Type u} [ring R] (s : subring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s",
    "theorem": "{R : Type u} [ring R] (s : subring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s",
    "args": "{R : Type u} [ring R] (s : subring R) {l : list R}",
    "doc_string": "Product of a list of elements in a subring is in the subring.",
    "kind": "theorem",
    "type": "(∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s"
  },
  {
    "name": "is_localization.integer_normalization",
    "statement": "def is_localization.integer_normalization {R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (p : polynomial S) : polynomial R",
    "theorem": "{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (p : polynomial S) : polynomial R",
    "args": "{R : Type u_1} [comm_ring R] (M : submonoid R) {S : Type u_2} [comm_ring S] [algebra R S] [is_localization M S] (p : polynomial S)",
    "doc_string": " `integer_normalization g` normalizes `g` to have integer coefficients by clearing the denominators",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "summable",
    "statement": "def summable {α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] (f : β → α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] (f : β → α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] (f : β → α)",
    "doc_string": "`summable f` means that `f` has some (infinite) sum. Use `tsum` to get the value.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "measurable_embedding",
    "statement": "structure measurable_embedding {α : Type u_7} {β : Type u_8} [measurable_space α] [measurable_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_7} {β : Type u_8} [measurable_space α] [measurable_space β] (f : α → β) : Prop",
    "args": "{α : Type u_7} {β : Type u_8} [measurable_space α] [measurable_space β] (f : α → β)",
    "doc_string": " A map `f : α → β` is called a *measurable embedding* if it is injective, measurable, and sends measurable sets to measurable sets. The latter assumption can be replaced with “`f` has measurable inverse `g : range f → α`”, see `measurable_embedding.measurable_range_splitting`, `measurable_embedding.of_measurable_inverse_range`, and `measurable_embedding.of_measurable_inverse`.  One more interpretation: `f` is a measurable embedding if it defines a measurable equivalence to its range and the range is a measurable set. One implication is formalized as `measurable_embedding.equiv_range`; the other one follows from `measurable_equiv.measurable_embedding`, `measurable_embedding.subtype_coe`, and `measurable_embedding.comp`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "add_subgroup.to_add_submonoid",
    "statement": "def add_subgroup.to_add_submonoid {G : Type u_3} [add_group G] (self : add_subgroup G) : add_submonoid G",
    "theorem": "{G : Type u_3} [add_group G] (self : add_subgroup G) : add_submonoid G",
    "args": "{G : Type u_3} [add_group G] (self : add_subgroup G)",
    "doc_string": "Reinterpret an `add_subgroup` as an `add_submonoid`.",
    "kind": "def",
    "type": "add_submonoid G"
  },
  {
    "name": "is_open.is_Gδ",
    "statement": "theorem is_open.is_Gδ {α : Type u_1} [topological_space α] {s : set α} (h : is_open s) : is_Gδ s",
    "theorem": "{α : Type u_1} [topological_space α] {s : set α} (h : is_open s) : is_Gδ s",
    "args": "{α : Type u_1} [topological_space α] {s : set α} (h : is_open s)",
    "doc_string": "An open set is a Gδ set.",
    "kind": "theorem",
    "type": "is_Gδ s"
  },
  {
    "name": "submonoid.gi",
    "statement": "def submonoid.gi (M : Type u_1) [mul_one_class M] : galois_insertion submonoid.closure coe",
    "theorem": "(M : Type u_1) [mul_one_class M] : galois_insertion submonoid.closure coe",
    "args": "(M : Type u_1) [mul_one_class M]",
    "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
    "kind": "def",
    "type": "galois_insertion submonoid.closure coe"
  },
  {
    "name": "set.partially_well_ordered_on",
    "statement": "def set.partially_well_ordered_on {α : Type u_1} (s : set α) (r : α → α → Prop) : Prop",
    "theorem": "{α : Type u_1} (s : set α) (r : α → α → Prop) : Prop",
    "args": "{α : Type u_1} (s : set α) (r : α → α → Prop)",
    "doc_string": "A subset is partially well-ordered by a relation `r` when any infinite sequence contains  two elements where the first is related to the second by `r`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subgroup.prod",
    "statement": "def subgroup.prod {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (K : subgroup N) : subgroup (G × N)",
    "theorem": "{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (K : subgroup N) : subgroup (G × N)",
    "args": "{G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (K : subgroup N)",
    "doc_string": "Given `subgroup`s `H`, `K` of groups `G`, `N` respectively, `H × K` as a subgroup of `G × N`.",
    "kind": "def",
    "type": "subgroup (G × N)"
  },
  {
    "name": "category_theory.limits.has_terminal",
    "statement": "def category_theory.limits.has_terminal (C : Type u₁) [category_theory.category C] : Prop",
    "theorem": "(C : Type u₁) [category_theory.category C] : Prop",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": "A category has a terminal object if it has a limit over the empty diagram. Use `has_terminal_of_unique` to construct instances.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "zmod.algebra'",
    "statement": "def zmod.algebra' (R : Type u_1) [ring R] {n : ℕ} (m : ℕ) [char_p R m] (h : m ∣ n) : algebra (zmod n) R",
    "theorem": "(R : Type u_1) [ring R] {n : ℕ} (m : ℕ) [char_p R m] (h : m ∣ n) : algebra (zmod n) R",
    "args": "(R : Type u_1) [ring R] {n : ℕ} (m : ℕ) [char_p R m] (h : m ∣ n)",
    "doc_string": "The `zmod n`-algebra structure on rings whose characteristic `m` divides `n`",
    "kind": "def",
    "type": "algebra (zmod n) R"
  },
  {
    "name": "list.exists_of_mem_map",
    "statement": "theorem list.exists_of_mem_map {α : Type u} {β : Type v} {f : α → β} {b : β} {l : list α} : b ∈ list.map f l → (∃ (a : α), a ∈ l ∧ f a = b)",
    "theorem": "{α : Type u} {β : Type v} {f : α → β} {b : β} {l : list α} : b ∈ list.map f l → (∃ (a : α), a ∈ l ∧ f a = b)",
    "args": "{α : Type u} {β : Type v} {f : α → β} {b : β} {l : list α}",
    "doc_string": "**Alias** of the forward direction of list.mem_map`.",
    "kind": "theorem",
    "type": "b ∈ list.map f l → (∃ (a : α), a ∈ l ∧ f a = b)"
  },
  {
    "name": "add_subsemigroup.complete_lattice",
    "statement": "def add_subsemigroup.complete_lattice {M : Type u_1} [has_add M] : complete_lattice (add_subsemigroup M)",
    "theorem": "{M : Type u_1} [has_add M] : complete_lattice (add_subsemigroup M)",
    "args": "{M : Type u_1} [has_add M]",
    "doc_string": "The `add_subsemigroup`s of an `add_monoid` form a complete lattice.",
    "kind": "def",
    "type": "complete_lattice (add_subsemigroup M)"
  },
  {
    "name": "is_add_right_regular.add",
    "statement": "theorem is_add_right_regular.add {R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b)",
    "doc_string": "In an additive semigroup, the sum of add-right-regular elements is add-right-regular.",
    "kind": "theorem",
    "type": "is_add_right_regular (a + b)"
  },
  {
    "name": "monoid_algebra.comap_distrib_mul_action_self",
    "statement": "def monoid_algebra.comap_distrib_mul_action_self {k : Type u₁} {G : Type u₂} [group G] [semiring k] : distrib_mul_action G (monoid_algebra k G)",
    "theorem": "{k : Type u₁} {G : Type u₂} [group G] [semiring k] : distrib_mul_action G (monoid_algebra k G)",
    "args": "{k : Type u₁} {G : Type u₂} [group G] [semiring k]",
    "doc_string": "This is not an instance as it conflicts with `monoid_algebra.distrib_mul_action` when `G = kˣ`.",
    "kind": "def",
    "type": "distrib_mul_action G (monoid_algebra k G)"
  },
  {
    "name": "category_theory.idempotents.is_idempotent_complete_of_abelian",
    "statement": "def category_theory.idempotents.is_idempotent_complete_of_abelian (D : Type u_1) [category_theory.category D] [category_theory.abelian D] : category_theory.is_idempotent_complete D",
    "theorem": "(D : Type u_1) [category_theory.category D] [category_theory.abelian D] : category_theory.is_idempotent_complete D",
    "args": "(D : Type u_1) [category_theory.category D] [category_theory.abelian D]",
    "doc_string": "An abelian category is idempotent complete.",
    "kind": "def",
    "type": "category_theory.is_idempotent_complete D"
  },
  {
    "name": "generate_pi_system",
    "statement": "inductive generate_pi_system {α : Type u_1} (S : set (set α)) : set (set α)",
    "theorem": "{α : Type u_1} (S : set (set α)) : set (set α)",
    "args": "{α : Type u_1} (S : set (set α))",
    "doc_string": " Given a collection `S` of subsets of `α`, then `generate_pi_system S` is the smallest π-system containing `S`.",
    "kind": "inductive",
    "type": "set (set α)"
  },
  {
    "name": "list.destutter",
    "statement": "def list.destutter {α : Type u_1} (R : α → α → Prop) [decidable_rel R] : list α → list α",
    "theorem": "{α : Type u_1} (R : α → α → Prop) [decidable_rel R] : list α → list α",
    "args": "{α : Type u_1} (R : α → α → Prop) [decidable_rel R]",
    "doc_string": " Greedily create a sublist of `l` such that, for every two adjacent elements `a, b ∈ l`, `R a b` holds. Mostly used with ≠; for example, `destutter (≠) [1, 2, 2, 1, 1] = [1, 2, 1]`, `destutter (≠) [1, 2, 3, 3] = [1, 2, 3]`, `destutter (<) [1, 2, 5, 2, 3, 4, 9] = [1, 2, 5, 9]`.",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "witt_vector.recursion_base.solution",
    "statement": "def witt_vector.recursion_base.solution (p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [is_alg_closed k] (a₁ a₂ : witt_vector p k) : k",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [is_alg_closed k] (a₁ a₂ : witt_vector p k) : k",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] {k : Type u_1} [field k] [is_alg_closed k] (a₁ a₂ : witt_vector p k)",
    "doc_string": "The base case (0th coefficient) of our solution vector.",
    "kind": "def",
    "type": "k"
  },
  {
    "name": "pi_countable.metric_space",
    "statement": "def pi_countable.metric_space {ι : Type u_2} [encodable ι] {F : ι → Type u_3} [Π (i : ι), metric_space (F i)] : metric_space (Π (i : ι), F i)",
    "theorem": "{ι : Type u_2} [encodable ι] {F : ι → Type u_3} [Π (i : ι), metric_space (F i)] : metric_space (Π (i : ι), F i)",
    "args": "{ι : Type u_2} [encodable ι] {F : ι → Type u_3} [Π (i : ι), metric_space (F i)]",
    "doc_string": " Given a countable family of metric spaces, one may put a distance on their product `Π i, E i`, defining the right topology and uniform structure. It is highly non-canonical, though, and therefore not registered as a global instance. The distance we use here is `dist x y = ∑' n, min (1/2)^(encode i) (dist (x n) (y n))`.",
    "kind": "def",
    "type": "metric_space (Π (i : ι), F i)"
  },
  {
    "name": "category_theory.Rel",
    "statement": "def category_theory.Rel  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "A type synonym for `Type`, which carries the category instance for which    morphisms are binary relations.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "language.has_mul",
    "statement": "def language.has_mul {α : Type u_1} : has_mul (language α)",
    "theorem": "{α : Type u_1} : has_mul (language α)",
    "args": "{α : Type u_1}",
    "doc_string": " The product of two languages `l` and `m` is the language made of the strings `x ++ y` where `x ∈ l` and `y ∈ m`.",
    "kind": "def",
    "type": "has_mul (language α)"
  },
  {
    "name": "polynomial.roots",
    "statement": "def polynomial.roots {R : Type u} [comm_ring R] [is_domain R] (p : polynomial R) : multiset R",
    "theorem": "{R : Type u} [comm_ring R] [is_domain R] (p : polynomial R) : multiset R",
    "args": "{R : Type u} [comm_ring R] [is_domain R] (p : polynomial R)",
    "doc_string": " `roots p` noncomputably gives a multiset containing all the roots of `p`, including their multiplicities.",
    "kind": "def",
    "type": "multiset R"
  },
  {
    "name": "bilin_form.is_symm",
    "statement": "def bilin_form.is_symm {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M)",
    "doc_string": "The proposition that a bilinear form is symmetric",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "filter.tendsto.germ_tendsto",
    "statement": "theorem filter.tendsto.germ_tendsto {α : Type u_1} {β : Type u_2} {l : filter α} {f : α → β} {lb : filter β} : filter.tendsto f l lb → ↑f.tendsto lb",
    "theorem": "{α : Type u_1} {β : Type u_2} {l : filter α} {f : α → β} {lb : filter β} : filter.tendsto f l lb → ↑f.tendsto lb",
    "args": "{α : Type u_1} {β : Type u_2} {l : filter α} {f : α → β} {lb : filter β}",
    "doc_string": "**Alias** of the reverse direction of filter.germ.coe_tendsto`.",
    "kind": "theorem",
    "type": "filter.tendsto f l lb → ↑f.tendsto lb"
  },
  {
    "name": "Frame.of",
    "statement": "def Frame.of (α : Type u_1) [order.frame α] : Frame",
    "theorem": "(α : Type u_1) [order.frame α] : Frame",
    "args": "(α : Type u_1) [order.frame α]",
    "doc_string": "Construct a bundled `Frame` from a `frame`.",
    "kind": "def",
    "type": "Frame"
  },
  {
    "name": "add_tsub_le_right",
    "statement": "theorem add_tsub_le_right {α : Type u_1} [preorder α] [has_add α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - b ≤ a",
    "theorem": "{α : Type u_1} [preorder α] [has_add α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - b ≤ a",
    "args": "{α : Type u_1} [preorder α] [has_add α] [has_sub α] [has_ordered_sub α] {a b : α}",
    "doc_string": "See `add_tsub_cancel_right` for the equality if `contravariant_class α α (+) (≤)`.",
    "kind": "theorem",
    "type": "a + b - b ≤ a"
  },
  {
    "name": "localization.zero",
    "statement": "def localization.zero {M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) : localization S",
    "theorem": "{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M) : localization S",
    "args": "{M : Type u_1} [comm_monoid_with_zero M] (S : submonoid M)",
    "doc_string": " The zero element in a localization is defined as `(0, 1)`.  Should not be confused with `add_localization.zero` which is `(0, 0)`.",
    "kind": "def",
    "type": "localization S"
  },
  {
    "name": "function.involutive.ite_not",
    "statement": "theorem function.involutive.ite_not {α : Sort u} {f : α → α} (h : function.involutive f) (P : Prop) [decidable P] (x : α) : f (ite P x (f x)) = ite (¬P) x (f x)",
    "theorem": "{α : Sort u} {f : α → α} (h : function.involutive f) (P : Prop) [decidable P] (x : α) : f (ite P x (f x)) = ite (¬P) x (f x)",
    "args": "{α : Sort u} {f : α → α} (h : function.involutive f) (P : Prop) [decidable P] (x : α)",
    "doc_string": "Involuting an `ite` of an involuted value `x : α` negates the `Prop` condition in the `ite`.",
    "kind": "theorem",
    "type": "f (ite P x (f x)) = ite (¬P) x (f x)"
  },
  {
    "name": "lazy_list.interleave_all",
    "statement": "def lazy_list.interleave_all {α : Type u_1} : list (lazy_list α) → lazy_list α",
    "theorem": "{α : Type u_1} : list (lazy_list α) → lazy_list α",
    "args": "{α : Type u_1}",
    "doc_string": " `interleave_all (xs::ys::zs::xss)` creates a list where elements of `xs`, `ys` and `zs` and the rest alternate. Every other element of the resulting list is taken from `xs`, every fourth is taken from `ys`, every eighth is taken from `zs` and so on.",
    "kind": "def",
    "type": "list (lazy_list α) → lazy_list α"
  },
  {
    "name": "Set.mem",
    "statement": "def Set.mem  : Set → Set → Prop",
    "theorem": " : Set → Set → Prop",
    "args": "",
    "doc_string": "The membership relation for ZFC sets is inherited from the membership relation for pre-sets.",
    "kind": "def",
    "type": "Set → Set → Prop"
  },
  {
    "name": "star_mul_aut",
    "statement": "def star_mul_aut {R : Type u} [comm_semigroup R] [star_semigroup R] : mul_aut R",
    "theorem": "{R : Type u} [comm_semigroup R] [star_semigroup R] : mul_aut R",
    "args": "{R : Type u} [comm_semigroup R] [star_semigroup R]",
    "doc_string": "`star` as a `mul_aut` for commutative `R`.",
    "kind": "def",
    "type": "mul_aut R"
  },
  {
    "name": "finset.Ioo",
    "statement": "def finset.Ioo {α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α)",
    "doc_string": "The finset of elements `x` such that `a < x` and `x < b`. Basically `set.Ioo a b` as a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "typevec.arrow",
    "statement": "def typevec.arrow {n : ℕ} (α : typevec n) (β : typevec n) : Type (max u_1 u_2)",
    "theorem": "{n : ℕ} (α : typevec n) (β : typevec n) : Type (max u_1 u_2)",
    "args": "{n : ℕ} (α : typevec n) (β : typevec n)",
    "doc_string": "arrow in the category of `typevec`",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "simple_graph.delete_edges",
    "statement": "def simple_graph.delete_edges {V : Type u} (G : simple_graph V) (s : set (sym2 V)) : simple_graph V",
    "theorem": "{V : Type u} (G : simple_graph V) (s : set (sym2 V)) : simple_graph V",
    "args": "{V : Type u} (G : simple_graph V) (s : set (sym2 V))",
    "doc_string": " Given a set of vertex pairs, remove all of the corresponding edges from the graph's edge set, if present.  See also: `simple_graph.subgraph.delete_edges`.",
    "kind": "def",
    "type": "simple_graph V"
  },
  {
    "name": "power_series.X_prime",
    "statement": "theorem power_series.X_prime {R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R]",
    "doc_string": "The variable of the power series ring over an integral domain is prime.",
    "kind": "theorem",
    "type": "prime power_series.X"
  },
  {
    "name": "complete_lattice_of_complete_semilattice_Sup",
    "statement": "def complete_lattice_of_complete_semilattice_Sup (α : Type u_1) [complete_semilattice_Sup α] : complete_lattice α",
    "theorem": "(α : Type u_1) [complete_semilattice_Sup α] : complete_lattice α",
    "args": "(α : Type u_1) [complete_semilattice_Sup α]",
    "doc_string": "Any `complete_semilattice_Sup` is in fact a `complete_lattice`.  Note that this construction has bad definitional properties: see the doc-string on `complete_lattice_of_Sup`.",
    "kind": "def",
    "type": "complete_lattice α"
  },
  {
    "name": "has_measurable_mul",
    "statement": "structure has_measurable_mul (M : Type u_1) [measurable_space M] [has_mul M] : Prop",
    "theorem": "(M : Type u_1) [measurable_space M] [has_mul M] : Prop",
    "args": "(M : Type u_1) [measurable_space M] [has_mul M]",
    "doc_string": " We say that a type `has_measurable_mul` if `((*) c)` and `(* c)` are measurable functions. For a typeclass assuming measurability of `uncurry (*)` see `has_measurable_mul₂`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.is_filtered",
    "statement": "structure category_theory.is_filtered (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category `is_filtered` if 1. for every pair of objects there exists another object \"to the right\", 2. for every pair of parallel morphisms there exists a morphism to the right so the compositions    are equal, and 3. there exists some object.  See <https://stacks.math.columbia.edu/tag/002V>. (They also define a diagram being filtered.)",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "subgroup.commutator",
    "statement": "def subgroup.commutator {G : Type u_1} [group G] : has_bracket (subgroup G) (subgroup G)",
    "theorem": "{G : Type u_1} [group G] : has_bracket (subgroup G) (subgroup G)",
    "args": "{G : Type u_1} [group G]",
    "doc_string": "The commutator of two subgroups `H₁` and `H₂`.",
    "kind": "def",
    "type": "has_bracket (subgroup G) (subgroup G)"
  },
  {
    "name": "exists_prime_order_of_dvd_card",
    "statement": "theorem exists_prime_order_of_dvd_card {G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p",
    "theorem": "{G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p",
    "args": "{G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G)",
    "doc_string": " For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem.",
    "kind": "theorem",
    "type": "∃ (x : G), order_of x = p"
  },
  {
    "name": "continuous_map_class",
    "statement": "structure continuous_map_class (F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [topological_space α] [topological_space β] : Type (max u_1 u_2 u_3)",
    "theorem": "(F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [topological_space α] [topological_space β] : Type (max u_1 u_2 u_3)",
    "args": "(F : Type u_1) (α : out_param (Type u_2)) (β : out_param (Type u_3)) [topological_space α] [topological_space β]",
    "doc_string": " `continuous_map_class F α β` states that `F` is a type of continuous maps.  You should extend this class when you extend `continuous_map`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "set.semigroup",
    "statement": "def set.semigroup {α : Type u_2} [semigroup α] : semigroup (set α)",
    "theorem": "{α : Type u_2} [semigroup α] : semigroup (set α)",
    "args": "{α : Type u_2} [semigroup α]",
    "doc_string": "`set α` is a `semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "semigroup (set α)"
  },
  {
    "name": "mul_action.orbit_rel",
    "statement": "def mul_action.orbit_rel (α : Type u) (β : Type v) [group α] [mul_action α β] : setoid β",
    "theorem": "(α : Type u) (β : Type v) [group α] [mul_action α β] : setoid β",
    "args": "(α : Type u) (β : Type v) [group α] [mul_action α β]",
    "doc_string": "The relation 'in the same orbit'.",
    "kind": "def",
    "type": "setoid β"
  },
  {
    "name": "algebraic_geometry.Proj.to_SheafedSpace",
    "statement": "def algebraic_geometry.Proj.to_SheafedSpace {R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : algebraic_geometry.SheafedSpace CommRing",
    "theorem": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : algebraic_geometry.SheafedSpace CommRing",
    "args": "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜]",
    "doc_string": "`Proj` of a graded ring as a `SheafedSpace`",
    "kind": "def",
    "type": "algebraic_geometry.SheafedSpace CommRing"
  },
  {
    "name": "vector3.insert",
    "statement": "def vector3.insert {α : Type u_1} {n : ℕ} (a : α) (v : vector3 α n) (i : fin2 n.succ) : vector3 α n.succ",
    "theorem": "{α : Type u_1} {n : ℕ} (a : α) (v : vector3 α n) (i : fin2 n.succ) : vector3 α n.succ",
    "args": "{α : Type u_1} {n : ℕ} (a : α) (v : vector3 α n) (i : fin2 n.succ)",
    "doc_string": "Insert `a` into `v` at index `i`.",
    "kind": "def",
    "type": "vector3 α n.succ"
  },
  {
    "name": "basis.of_dim_eq_zero",
    "statement": "def basis.of_dim_eq_zero {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} [is_empty ι] (hV : module.rank K V = 0) : basis ι K V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} [is_empty ι] (hV : module.rank K V = 0) : basis ι K V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type u_1} [is_empty ι] (hV : module.rank K V = 0)",
    "doc_string": " The `ι` indexed basis on `V`, where `ι` is an empty type and `V` is zero-dimensional.  See also `finite_dimensional.fin_basis`.",
    "kind": "def",
    "type": "basis ι K V"
  },
  {
    "name": "parser.fix",
    "statement": "def parser.fix {α : Type} (F : parser α → parser α) : parser α",
    "theorem": "{α : Type} (F : parser α → parser α) : parser α",
    "args": "{α : Type} (F : parser α → parser α)",
    "doc_string": "Fixpoint combinator satisfying `fix F = F (fix F)`.",
    "kind": "def",
    "type": "parser α"
  },
  {
    "name": "polynomial.nth_roots",
    "statement": "def polynomial.nth_roots {R : Type u} [comm_ring R] [is_domain R] (n : ℕ) (a : R) : multiset R",
    "theorem": "{R : Type u} [comm_ring R] [is_domain R] (n : ℕ) (a : R) : multiset R",
    "args": "{R : Type u} [comm_ring R] [is_domain R] (n : ℕ) (a : R)",
    "doc_string": "`nth_roots n a` noncomputably returns the solutions to `x ^ n = a`",
    "kind": "def",
    "type": "multiset R"
  },
  {
    "name": "lt_sub_right_of_add_lt",
    "statement": "theorem lt_sub_right_of_add_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a + b < c → a < c - b",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a + b < c → a < c - b",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of lt_sub_iff_add_lt`.",
    "kind": "theorem",
    "type": "a + b < c → a < c - b"
  },
  {
    "name": "nat.totient",
    "statement": "def nat.totient (n : ℕ) : ℕ",
    "theorem": "(n : ℕ) : ℕ",
    "args": "(n : ℕ)",
    "doc_string": " Euler's totient function. This counts the number of naturals strictly less than `n` which are coprime with `n`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "filter.has_one",
    "statement": "def filter.has_one {α : Type u_2} [has_one α] : has_one (filter α)",
    "theorem": "{α : Type u_2} [has_one α] : has_one (filter α)",
    "args": "{α : Type u_2} [has_one α]",
    "doc_string": "`1 : filter α` is defined as the filter of sets containing `1 : α` in locale `pointwise`.",
    "kind": "def",
    "type": "has_one (filter α)"
  },
  {
    "name": "invertible_of_ring_char_not_dvd",
    "statement": "def invertible_of_ring_char_not_dvd {K : Type u_1} [field K] {t : ℕ} (not_dvd : ¬ring_char K ∣ t) : invertible ↑t",
    "theorem": "{K : Type u_1} [field K] {t : ℕ} (not_dvd : ¬ring_char K ∣ t) : invertible ↑t",
    "args": "{K : Type u_1} [field K] {t : ℕ} (not_dvd : ¬ring_char K ∣ t)",
    "doc_string": " A natural number `t` is invertible in a field `K` if the charactistic of `K` does not divide `t`.",
    "kind": "def",
    "type": "invertible ↑t"
  },
  {
    "name": "slim_check.testable",
    "statement": "structure slim_check.testable (p : Prop) : Type",
    "theorem": "(p : Prop) : Type",
    "args": "(p : Prop)",
    "doc_string": "`testable p` uses random examples to try to disprove `p`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "filter.mul_action_filter",
    "statement": "def filter.mul_action_filter {α : Type u_2} {β : Type u_3} [monoid α] [mul_action α β] : mul_action α (filter β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [monoid α] [mul_action α β] : mul_action α (filter β)",
    "args": "{α : Type u_2} {β : Type u_3} [monoid α] [mul_action α β]",
    "doc_string": "A multiplicative action of a monoid on a type `β` gives a multiplicative action on `filter β`.",
    "kind": "def",
    "type": "mul_action α (filter β)"
  },
  {
    "name": "char_p",
    "statement": "structure char_p (R : Type u) [add_monoid R] [has_one R] (p : ℕ) : Prop",
    "theorem": "(R : Type u) [add_monoid R] [has_one R] (p : ℕ) : Prop",
    "args": "(R : Type u) [add_monoid R] [has_one R] (p : ℕ)",
    "doc_string": " The generator of the kernel of the unique homomorphism ℕ → R for a semiring R.  *Warning*: for a semiring `R`, `char_p R 0` and `char_zero R` need not coincide. * `char_p R 0` asks that only `0 : ℕ` maps to `0 : R` under the map `ℕ → R`; * `char_zero R` requires an injection `ℕ ↪ R`.  For instance, endowing `{0, 1}` with addition given by `max` (i.e. `1` is absorbing), shows that `char_zero {0, 1}` does not hold and yet `char_p {0, 1} 0` does. This example is formalized in `counterexamples/char_p_zero_ne_char_zero`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "exists.classical_rec_on",
    "statement": "def exists.classical_rec_on {α : Sort u_1} {p : α → Prop} (h : ∃ (a : α), p a) {C : Sort u} (H : Π (a : α), p a → C) : C",
    "theorem": "{α : Sort u_1} {p : α → Prop} (h : ∃ (a : α), p a) {C : Sort u} (H : Π (a : α), p a → C) : C",
    "args": "{α : Sort u_1} {p : α → Prop} (h : ∃ (a : α), p a) {C : Sort u} (H : Π (a : α), p a → C)",
    "doc_string": " This function has the same type as `exists.rec_on`, and can be used to case on an equality, but `exists.rec_on` can only eliminate into Prop, while this version eliminates into any universe using the axiom of choice.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "band",
    "statement": "def band  : bool → bool → bool",
    "theorem": " : bool → bool → bool",
    "args": "",
    "doc_string": "Boolean AND",
    "kind": "def",
    "type": "bool → bool → bool"
  },
  {
    "name": "Top.presheaf.is_sheaf_unique_gluing",
    "statement": "def Top.presheaf.is_sheaf_unique_gluing {C : Type u} [category_theory.category C] [category_theory.concrete_category C] {X : Top} (F : Top.presheaf C X) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.concrete_category C] {X : Top} (F : Top.presheaf C X) : Prop",
    "args": "{C : Type u} [category_theory.category C] [category_theory.concrete_category C] {X : Top} (F : Top.presheaf C X)",
    "doc_string": "The sheaf condition in terms of unique gluings. A presheaf `F : presheaf C X` satisfies this sheaf condition if and only if, for every compatible family of sections `sf : Π i : ι, F.obj (op (U i))`, there exists a unique gluing `s : F.obj (op (supr U))`.  We prove this to be equivalent to the usual one below in `is_sheaf_iff_is_sheaf_unique_gluing`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "matrix.vec_tail",
    "statement": "def matrix.vec_tail {α : Type u} {n : ℕ} (v : fin n.succ → α) : fin n → α",
    "theorem": "{α : Type u} {n : ℕ} (v : fin n.succ → α) : fin n → α",
    "args": "{α : Type u} {n : ℕ} (v : fin n.succ → α)",
    "doc_string": "`vec_tail v` gives a vector consisting of all entries of `v` except the first",
    "kind": "def",
    "type": "fin n → α"
  },
  {
    "name": "ordinal.eq_enum_ord",
    "statement": "theorem ordinal.eq_enum_ord {S : set ordinal} (f : ordinal → ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f ∧ set.range f = S ↔ f = ordinal.enum_ord S",
    "theorem": "{S : set ordinal} (f : ordinal → ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f ∧ set.range f = S ↔ f = ordinal.enum_ord S",
    "args": "{S : set ordinal} (f : ordinal → ordinal) (hS : set.unbounded has_lt.lt S)",
    "doc_string": "A characterization of `enum_ord`: it is the unique strict monotonic function with range `S`.",
    "kind": "theorem",
    "type": "strict_mono f ∧ set.range f = S ↔ f = ordinal.enum_ord S"
  },
  {
    "name": "conj_classes.carrier",
    "statement": "def conj_classes.carrier {α : Type u} [monoid α] : conj_classes α → set α",
    "theorem": "{α : Type u} [monoid α] : conj_classes α → set α",
    "args": "{α : Type u} [monoid α]",
    "doc_string": "Given a conjugacy class `a`, `carrier a` is the set it represents.",
    "kind": "def",
    "type": "conj_classes α → set α"
  },
  {
    "name": "is_fraction_ring.num",
    "statement": "def is_fraction_ring.num (A : Type u_4) [comm_ring A] [is_domain A] [unique_factorization_monoid A] {K : Type u_5} [field K] [algebra A K] [is_fraction_ring A K] (x : K) : A",
    "theorem": "(A : Type u_4) [comm_ring A] [is_domain A] [unique_factorization_monoid A] {K : Type u_5} [field K] [algebra A K] [is_fraction_ring A K] (x : K) : A",
    "args": "(A : Type u_4) [comm_ring A] [is_domain A] [unique_factorization_monoid A] {K : Type u_5} [field K] [algebra A K] [is_fraction_ring A K] (x : K)",
    "doc_string": "`f.num x` is the numerator of `x : f.codomain` as a reduced fraction.",
    "kind": "def",
    "type": "A"
  },
  {
    "name": "complete_lattice_hom.set_preimage",
    "statement": "def complete_lattice_hom.set_preimage {α : Type u_2} {β : Type u_3} (f : α → β) : complete_lattice_hom (set β) (set α)",
    "theorem": "{α : Type u_2} {β : Type u_3} (f : α → β) : complete_lattice_hom (set β) (set α)",
    "args": "{α : Type u_2} {β : Type u_3} (f : α → β)",
    "doc_string": "`set.preimage` as a complete lattice homomorphism.",
    "kind": "def",
    "type": "complete_lattice_hom (set β) (set α)"
  },
  {
    "name": "is_regular_mul_and_mul_iff",
    "statement": "theorem is_regular_mul_and_mul_iff {R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R]",
    "doc_string": "  Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a` are regular.",
    "kind": "theorem",
    "type": "is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b"
  },
  {
    "name": "min_default",
    "statement": "def min_default {α : Type u} [has_le α] [decidable_rel has_le.le] (a b : α) : α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (a b : α) : α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (a b : α)",
    "doc_string": "Default definition of `min`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "filter.cofinite",
    "statement": "def filter.cofinite {α : Type u_2} : filter α",
    "theorem": "{α : Type u_2} : filter α",
    "args": "{α : Type u_2}",
    "doc_string": "The cofinite filter is the filter of subsets whose complements are finite.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "ordnode.of_asc_list_aux₁",
    "statement": "def ordnode.of_asc_list_aux₁ {α : Type u} (l : list α) : ℕ → ordnode α × {l' // l'.length ≤ l.length}",
    "theorem": "{α : Type u} (l : list α) : ℕ → ordnode α × {l' // l'.length ≤ l.length}",
    "args": "{α : Type u} (l : list α)",
    "doc_string": " Auxiliary definition for `of_asc_list`.  **Note:** This function is defined by well founded recursion, so it will probably not compute in the kernel, meaning that you probably can't prove things like `of_asc_list [1, 2, 3] = {1, 2, 3}` by `rfl`. This implementation is optimized for VM evaluation.",
    "kind": "def",
    "type": "ℕ → ordnode α × {l' // l'.length ≤ l.length}"
  },
  {
    "name": "simple_continued_fraction.of_integer",
    "statement": "def simple_continued_fraction.of_integer {α : Type u_1} [has_one α] (a : α) : simple_continued_fraction α",
    "theorem": "{α : Type u_1} [has_one α] (a : α) : simple_continued_fraction α",
    "args": "{α : Type u_1} [has_one α] (a : α)",
    "doc_string": "Constructs a simple continued fraction without fractional part.",
    "kind": "def",
    "type": "simple_continued_fraction α"
  },
  {
    "name": "option.pmap",
    "statement": "def option.pmap {α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (x : option α) : (∀ (a : α), a ∈ x → p a) → option β",
    "theorem": "{α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (x : option α) : (∀ (a : α), a ∈ x → p a) → option β",
    "args": "{α : Type u_1} {β : Type u_2} {p : α → Prop} (f : Π (a : α), p a → β) (x : option α)",
    "doc_string": " Partial map. If `f : Π a, p a → β` is a partial function defined on `a : α` satisfying `p`, then `pmap f x h` is essentially the same as `map f x` but is defined only when all members of `x` satisfy `p`, using the proof to apply `f`.",
    "kind": "def",
    "type": "(∀ (a : α), a ∈ x → p a) → option β"
  },
  {
    "name": "first_order.language.order",
    "statement": "def first_order.language.order  : first_order.language",
    "theorem": " : first_order.language",
    "args": "",
    "doc_string": "The language consisting of a single relation representing `≤`.",
    "kind": "def",
    "type": "first_order.language"
  },
  {
    "name": "FinBoolAlg.of",
    "statement": "def FinBoolAlg.of (α : Type u_1) [boolean_algebra α] [fintype α] : FinBoolAlg",
    "theorem": "(α : Type u_1) [boolean_algebra α] [fintype α] : FinBoolAlg",
    "args": "(α : Type u_1) [boolean_algebra α] [fintype α]",
    "doc_string": "Construct a bundled `FinBoolAlg` from `boolean_algebra` + `fintype`.",
    "kind": "def",
    "type": "FinBoolAlg"
  },
  {
    "name": "lt_mul_of_inv_mul_lt_left",
    "statement": "theorem lt_mul_of_inv_mul_lt_left {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of lt_mul_of_inv_mul_lt`.",
    "kind": "theorem",
    "type": "b⁻¹ * a < c → a < b * c"
  },
  {
    "name": "PartialFun.of",
    "statement": "def PartialFun.of  : Type u_1 → PartialFun",
    "theorem": " : Type u_1 → PartialFun",
    "args": "",
    "doc_string": "Turns a type into a `PartialFun`.",
    "kind": "def",
    "type": "Type u_1 → PartialFun"
  },
  {
    "name": "measure_theory.outer_measure.to_measure",
    "statement": "def measure_theory.outer_measure.to_measure {α : Type u_1} [ms : measurable_space α] (m : measure_theory.outer_measure α) (h : ms ≤ m.caratheodory) : measure_theory.measure α",
    "theorem": "{α : Type u_1} [ms : measurable_space α] (m : measure_theory.outer_measure α) (h : ms ≤ m.caratheodory) : measure_theory.measure α",
    "args": "{α : Type u_1} [ms : measurable_space α] (m : measure_theory.outer_measure α) (h : ms ≤ m.caratheodory)",
    "doc_string": "Obtain a measure by giving an outer measure where all sets in the σ-algebra are  Carathéodory measurable.",
    "kind": "def",
    "type": "measure_theory.measure α"
  },
  {
    "name": "finset.filter",
    "statement": "def finset.filter {α : Type u_1} (p : α → Prop) [decidable_pred p] (s : finset α) : finset α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : finset α) : finset α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (s : finset α)",
    "doc_string": "`filter p s` is the set of elements of `s` that satisfy `p`.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "is_separable",
    "statement": "structure is_separable (F : Type u_1) (K : Type u_2) [comm_ring F] [ring K] [algebra F K] : Prop",
    "theorem": "(F : Type u_1) (K : Type u_2) [comm_ring F] [ring K] [algebra F K] : Prop",
    "args": "(F : Type u_1) (K : Type u_2) [comm_ring F] [ring K] [algebra F K]",
    "doc_string": " Typeclass for separable field extension: `K` is a separable field extension of `F` iff the minimal polynomial of every `x : K` is separable.  We define this for general (commutative) rings and only assume `F` and `K` are fields if this is needed for a proof.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "tactic.norm_fin.eval_fin_m",
    "statement": "def tactic.norm_fin.eval_fin_m (α : Type) : Type",
    "theorem": "(α : Type) : Type",
    "args": "(α : Type)",
    "doc_string": " The monad for the `norm_fin` internal tactics. The state consists of an instance cache for `ℕ`, and a tuple `(nn, n', p)` where `p` is a proof of `n = n'` and `nn` is `n` evaluated to a natural number. (`n` itself is implicit.)  It is in an `option` because it is lazily initialized - for many `n` we will never need this information, and indeed eagerly computing it would make some reductions fail spuriously if `n` is not a numeral.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "left_add_coset_equivalence",
    "statement": "def left_add_coset_equivalence {α : Type u_1} [has_add α] (s : set α) (a b : α) : Prop",
    "theorem": "{α : Type u_1} [has_add α] (s : set α) (a b : α) : Prop",
    "args": "{α : Type u_1} [has_add α] (s : set α) (a b : α)",
    "doc_string": "Equality of two left cosets `a + s` and `b + s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.is_cofiltered_or_empty",
    "statement": "structure category_theory.is_cofiltered_or_empty (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category `is_cofiltered_or_empty` if 1. for every pair of objects there exists another object \"to the left\", and 2. for every pair of parallel morphisms there exists a morphism to the left so the compositions    are equal.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "witt_vector.witt_sub",
    "statement": "def witt_vector.witt_sub (p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 2 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 2 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "The polynomials used for describing the subtraction of the ring of Witt vectors.",
    "kind": "def",
    "type": "ℕ → mv_polynomial (fin 2 × ℕ) ℤ"
  },
  {
    "name": "ordnode.insert_max",
    "statement": "def ordnode.insert_max {α : Type u} : ordnode α → α → ordnode α",
    "theorem": "{α : Type u} : ordnode α → α → ordnode α",
    "args": "{α : Type u}",
    "doc_string": " O(log n). Insert an element above all the others, without any comparisons. (Assumes that the element is in fact above all the others).      insert_max {1, 2} 4 = {1, 2, 4}     insert_max {1, 2} 0 = precondition violation",
    "kind": "def",
    "type": "ordnode α → α → ordnode α"
  },
  {
    "name": "mk_array",
    "statement": "def mk_array {α : Type u_1} (n : ℕ) (v : α) : array n α",
    "theorem": "{α : Type u_1} (n : ℕ) (v : α) : array n α",
    "args": "{α : Type u_1} (n : ℕ) (v : α)",
    "doc_string": "`mk_array n v` creates a new array of length `n` where each element is `v`. Has builtin VM implementation.",
    "kind": "def",
    "type": "array n α"
  },
  {
    "name": "complete_distrib_lattice",
    "statement": "structure complete_distrib_lattice (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": " A completely distributive lattice is a complete lattice whose `⊔` and `⊓` respectively distribute over `⨅` and `⨆`.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "ordnode.balanced_sz",
    "statement": "def ordnode.balanced_sz (l r : ℕ) : Prop",
    "theorem": "(l r : ℕ) : Prop",
    "args": "(l r : ℕ)",
    "doc_string": " The `balanced_sz l r` asserts that a hypothetical tree with children of sizes `l` and `r` is balanced: either `l ≤ δ * r` and `r ≤ δ * r`, or the tree is trivial with a singleton on one side and nothing on the other.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_right_cancel_monoid.to_has_faithful_vadd",
    "statement": "def add_right_cancel_monoid.to_has_faithful_vadd {α : Type u} [add_right_cancel_monoid α] : has_faithful_vadd α α",
    "theorem": "{α : Type u} [add_right_cancel_monoid α] : has_faithful_vadd α α",
    "args": "{α : Type u} [add_right_cancel_monoid α]",
    "doc_string": "`add_monoid.to_add_action` is faithful on additive cancellative monoids.",
    "kind": "def",
    "type": "has_faithful_vadd α α"
  },
  {
    "name": "finset.powerset",
    "statement": "def finset.powerset {α : Type u_1} (s : finset α) : finset (finset α)",
    "theorem": "{α : Type u_1} (s : finset α) : finset (finset α)",
    "args": "{α : Type u_1} (s : finset α)",
    "doc_string": "When `s` is a finset, `s.powerset` is the finset of all subsets of `s` (seen as finsets).",
    "kind": "def",
    "type": "finset (finset α)"
  },
  {
    "name": "function.pts_of_period",
    "statement": "def function.pts_of_period {α : Type u_1} (f : α → α) (n : ℕ) : set α",
    "theorem": "{α : Type u_1} (f : α → α) (n : ℕ) : set α",
    "args": "{α : Type u_1} (f : α → α) (n : ℕ)",
    "doc_string": "The set of periodic points of a given (possibly non-minimal) period.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "finset.min'_lt_max'_of_card",
    "statement": "theorem finset.min'_lt_max'_of_card {α : Type u_1} [linear_order α] (s : finset α) (h₂ : 1 < s.card) : s.min' _ < s.max' _",
    "theorem": "{α : Type u_1} [linear_order α] (s : finset α) (h₂ : 1 < s.card) : s.min' _ < s.max' _",
    "args": "{α : Type u_1} [linear_order α] (s : finset α) (h₂ : 1 < s.card)",
    "doc_string": "If there's more than 1 element, the min' is less than the max'. An alternate version of `min'_lt_max'` which is sometimes more convenient.",
    "kind": "theorem",
    "type": "s.min' _ < s.max' _"
  },
  {
    "name": "is_totally_disconnected_of_clopen_set",
    "statement": "theorem is_totally_disconnected_of_clopen_set {X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ",
    "theorem": "{X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ",
    "args": "{X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U))",
    "doc_string": "Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected.",
    "kind": "theorem",
    "type": "is_totally_disconnected set.univ"
  },
  {
    "name": "finset",
    "statement": "structure finset (α : Type u_4) : Type u_4",
    "theorem": "(α : Type u_4) : Type u_4",
    "args": "(α : Type u_4)",
    "doc_string": "`finset α` is the type of finite sets of elements of `α`. It is implemented  as a multiset (a list up to permutation) which has no duplicate elements.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "subring.has_top",
    "statement": "def subring.has_top {R : Type u} [ring R] : has_top (subring R)",
    "theorem": "{R : Type u} [ring R] : has_top (subring R)",
    "args": "{R : Type u} [ring R]",
    "doc_string": "The subring `R` of the ring `R`.",
    "kind": "def",
    "type": "has_top (subring R)"
  },
  {
    "name": "prime.dvd_prod_iff",
    "statement": "theorem prime.dvd_prod_iff {M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a",
    "theorem": "{M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a",
    "args": "{M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p)",
    "doc_string": "Prime `p` divides the product of a list `L` iff it divides some `a ∈ L`",
    "kind": "theorem",
    "type": "p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a"
  },
  {
    "name": "right.one_lt_mul_of_le_of_lt",
    "statement": "theorem right.one_lt_mul_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_le_of_lt`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "skew_adjoint_matrices_submodule",
    "statement": "def skew_adjoint_matrices_submodule {R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J : matrix n n R₃) [decidable_eq n] : submodule R₃ (matrix n n R₃)",
    "theorem": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J : matrix n n R₃) [decidable_eq n] : submodule R₃ (matrix n n R₃)",
    "args": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J : matrix n n R₃) [decidable_eq n]",
    "doc_string": " The submodule of skew-adjoint matrices with respect to the bilinear form corresponding to the matrix `J`.",
    "kind": "def",
    "type": "submodule R₃ (matrix n n R₃)"
  },
  {
    "name": "with_bot.map",
    "statement": "def with_bot.map {α : Type u} {β : Type v} (f : α → β) : with_bot α → with_bot β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : with_bot α → with_bot β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": "Lift a map `f : α → β` to `with_bot α → with_bot β`. Implemented using `option.map`.",
    "kind": "def",
    "type": "with_bot α → with_bot β"
  },
  {
    "name": "ordnode.is_subset_aux",
    "statement": "def ordnode.is_subset_aux {α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → bool",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → bool",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le]",
    "doc_string": "Auxiliary definition for `is_subset`.",
    "kind": "def",
    "type": "ordnode α → ordnode α → bool"
  },
  {
    "name": "cycle.to_multiset",
    "statement": "def cycle.to_multiset {α : Type u_1} (s : cycle α) : multiset α",
    "theorem": "{α : Type u_1} (s : cycle α) : multiset α",
    "args": "{α : Type u_1} (s : cycle α)",
    "doc_string": "The `s : cycle α` as a `multiset α`.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "filter.rmap",
    "statement": "def filter.rmap {α : Type u} {β : Type v} (r : rel α β) (l : filter α) : filter β",
    "theorem": "{α : Type u} {β : Type v} (r : rel α β) (l : filter α) : filter β",
    "args": "{α : Type u} {β : Type v} (r : rel α β) (l : filter α)",
    "doc_string": " The forward map of a filter under a relation. Generalization of `filter.map` to relations. Note that `rel.core` generalizes `set.preimage`.",
    "kind": "def",
    "type": "filter β"
  },
  {
    "name": "quaternion_algebra.has_mul",
    "statement": "def quaternion_algebra.has_mul {R : Type u_1} [comm_ring R] {c₁ c₂ : R} : has_mul (quaternion_algebra R c₁ c₂)",
    "theorem": "{R : Type u_1} [comm_ring R] {c₁ c₂ : R} : has_mul (quaternion_algebra R c₁ c₂)",
    "args": "{R : Type u_1} [comm_ring R] {c₁ c₂ : R}",
    "doc_string": " Multiplication is given by  * `1 * x = x * 1 = x`; * `i * i = c₁`; * `j * j = c₂`; * `i * j = k`, `j * i = -k`; * `k * k = -c₁ * c₂`; * `i * k = c₁ * j`, `k * i = `-c₁ * j`; * `j * k = -c₂ * i`, `k * j = c₂ * i`.",
    "kind": "def",
    "type": "has_mul (quaternion_algebra R c₁ c₂)"
  },
  {
    "name": "valuation_subring.of_subring",
    "statement": "def valuation_subring.of_subring {K : Type u_1} [field K] (R : subring K) (hR : ∀ (x : K), x ∈ R ∨ x⁻¹ ∈ R) : valuation_subring K",
    "theorem": "{K : Type u_1} [field K] (R : subring K) (hR : ∀ (x : K), x ∈ R ∨ x⁻¹ ∈ R) : valuation_subring K",
    "args": "{K : Type u_1} [field K] (R : subring K) (hR : ∀ (x : K), x ∈ R ∨ x⁻¹ ∈ R)",
    "doc_string": "A subring `R` of `K` such that for all `x : K` either `x ∈ R` or `x⁻¹ ∈ R` is  a valuation subring of `K`.",
    "kind": "def",
    "type": "valuation_subring K"
  },
  {
    "name": "ordered_add_comm_monoid",
    "statement": "structure ordered_add_comm_monoid (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "An ordered (additive) commutative monoid is a commutative monoid  with a partial order such that `a ≤ b → c + a ≤ c + b` (addition is monotone)",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "is_add_unit.add_unit'",
    "statement": "def is_add_unit.add_unit' {α : Type u_2} [subtraction_monoid α] {a : α} (h : is_add_unit a) : add_units α",
    "theorem": "{α : Type u_2} [subtraction_monoid α] {a : α} (h : is_add_unit a) : add_units α",
    "args": "{α : Type u_2} [subtraction_monoid α] {a : α} (h : is_add_unit a)",
    "doc_string": "The element of the additive group of additive units, corresponding to an element of an additive monoid which is an additive unit. As opposed to `is_add_unit.add_unit`, the negation is computable and comes from the negation on `α`. This is useful to transfer properties of negation in `add_units α` to `α`. See also `to_add_units`.",
    "kind": "def",
    "type": "add_units α"
  },
  {
    "name": "quiver.shortest_path",
    "statement": "def quiver.shortest_path {V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] (b : V) : quiver.path r b",
    "theorem": "{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] (b : V) : quiver.path r b",
    "args": "{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] (b : V)",
    "doc_string": "A path from `r` of minimal length.",
    "kind": "def",
    "type": "quiver.path r b"
  },
  {
    "name": "metric.inf_nndist",
    "statement": "def metric.inf_nndist {α : Type u} [pseudo_metric_space α] (x : α) (s : set α) : nnreal",
    "theorem": "{α : Type u} [pseudo_metric_space α] (x : α) (s : set α) : nnreal",
    "args": "{α : Type u} [pseudo_metric_space α] (x : α) (s : set α)",
    "doc_string": "The minimal distance of a point to a set as a `ℝ≥0`",
    "kind": "def",
    "type": "nnreal"
  },
  {
    "name": "configuration.dual",
    "statement": "def configuration.dual (P : Type u) : Type u",
    "theorem": "(P : Type u) : Type u",
    "args": "(P : Type u)",
    "doc_string": "A type synonym.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "orthonormal",
    "statement": "def orthonormal (𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (v : ι → E) : Prop",
    "theorem": "(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (v : ι → E) : Prop",
    "args": "(𝕜 : Type u_1) {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} (v : ι → E)",
    "doc_string": "An orthonormal set of vectors in an `inner_product_space`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "W_type",
    "statement": "inductive W_type {α : Type u_1} (β : α → Type u_2) : Type (max u_1 u_2)",
    "theorem": "{α : Type u_1} (β : α → Type u_2) : Type (max u_1 u_2)",
    "args": "{α : Type u_1} (β : α → Type u_2)",
    "doc_string": "Given `β : α → Type*`, `W_type β` is the type of finitely branching trees where nodes are labeled by elements of `α` and the children of a node labeled `a` are indexed by elements of `β a`.",
    "kind": "inductive",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "lattice_ordered_comm_group.has_one_lattice_has_pos_part",
    "statement": "def lattice_ordered_comm_group.has_one_lattice_has_pos_part {α : Type u} [lattice α] [comm_group α] : has_pos_part α",
    "theorem": "{α : Type u} [lattice α] [comm_group α] : has_pos_part α",
    "args": "{α : Type u} [lattice α] [comm_group α]",
    "doc_string": "Let `α` be a lattice ordered commutative group with identity `1`. For an element `a` of type `α`, the element `a ⊔ 1` is said to be the *positive component* of `a`, denoted `a⁺`.",
    "kind": "def",
    "type": "has_pos_part α"
  },
  {
    "name": "multiset.foldl",
    "statement": "def multiset.foldl {α : Type u_1} {β : Type u_2} (f : β → α → β) (H : right_commutative f) (b : β) (s : multiset α) : β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : β → α → β) (H : right_commutative f) (b : β) (s : multiset α) : β",
    "args": "{α : Type u_1} {β : Type u_2} (f : β → α → β) (H : right_commutative f) (b : β) (s : multiset α)",
    "doc_string": "`foldl f H b s` is the lift of the list operation `foldl f b l`,  which folds `f` over the multiset. It is well defined when `f` is right-commutative,  that is, `f (f b a₁) a₂ = f (f b a₂) a₁`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "wseq.indexes_of",
    "statement": "def wseq.indexes_of {α : Type u} [decidable_eq α] (a : α) : wseq α → wseq ℕ",
    "theorem": "{α : Type u} [decidable_eq α] (a : α) : wseq α → wseq ℕ",
    "args": "{α : Type u} [decidable_eq α] (a : α)",
    "doc_string": "Get the indexes of occurrences of `a` in `s`",
    "kind": "def",
    "type": "wseq α → wseq ℕ"
  },
  {
    "name": "pgame.right_moves",
    "statement": "def pgame.right_moves  : pgame → Type u",
    "theorem": " : pgame → Type u",
    "args": "",
    "doc_string": "The indexing type for allowable moves by Right.",
    "kind": "def",
    "type": "pgame → Type u"
  },
  {
    "name": "set.has_div",
    "statement": "def set.has_div {α : Type u_2} [has_div α] : has_div (set α)",
    "theorem": "{α : Type u_2} [has_div α] : has_div (set α)",
    "args": "{α : Type u_2} [has_div α]",
    "doc_string": " The pointwise division of sets `s / t` is defined as `{x / y | x ∈ s, y ∈ t}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_div (set α)"
  },
  {
    "name": "filter.add_action_filter",
    "statement": "def filter.add_action_filter {α : Type u_2} {β : Type u_3} [add_monoid α] [add_action α β] : add_action α (filter β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [add_monoid α] [add_action α β] : add_action α (filter β)",
    "args": "{α : Type u_2} {β : Type u_3} [add_monoid α] [add_action α β]",
    "doc_string": "An additive action of an additive monoid on a type `β` gives an additive action on `filter β`.",
    "kind": "def",
    "type": "add_action α (filter β)"
  },
  {
    "name": "category_theory.projective",
    "statement": "structure category_theory.projective {C : Type u} [category_theory.category C] (P : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (P : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (P : C)",
    "doc_string": "An object `P` is called projective if every morphism out of `P` factors through every epimorphism.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "finite_field.even_card_iff_char_two",
    "statement": "theorem finite_field.even_card_iff_char_two {F : Type u_3} [field F] [fintype F] : ring_char F = 2 ↔ fintype.card F % 2 = 0",
    "theorem": "{F : Type u_3} [field F] [fintype F] : ring_char F = 2 ↔ fintype.card F % 2 = 0",
    "args": "{F : Type u_3} [field F] [fintype F]",
    "doc_string": "The finite field `F` has even cardinality iff it has characteristic `2`.",
    "kind": "theorem",
    "type": "ring_char F = 2 ↔ fintype.card F % 2 = 0"
  },
  {
    "name": "category_theory.limits.has_finite_coproducts_of_has_finite_colimits",
    "statement": "def category_theory.limits.has_finite_coproducts_of_has_finite_colimits (C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_coproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_coproducts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C]",
    "doc_string": "If `C` has finite colimits then it has finite coproducts.",
    "kind": "def",
    "type": "category_theory.limits.has_finite_coproducts C"
  },
  {
    "name": "decidable.em",
    "statement": "theorem decidable.em (p : Prop) [decidable p] : p ∨ ¬p",
    "theorem": "(p : Prop) [decidable p] : p ∨ ¬p",
    "args": "(p : Prop) [decidable p]",
    "doc_string": "Law of Excluded Middle.",
    "kind": "theorem",
    "type": "p ∨ ¬p"
  },
  {
    "name": "set.finset.can_lift",
    "statement": "def set.finset.can_lift {α : Type u} : can_lift (set α) (finset α)",
    "theorem": "{α : Type u} : can_lift (set α) (finset α)",
    "args": "{α : Type u}",
    "doc_string": "Finite sets can be lifted to finsets.",
    "kind": "def",
    "type": "can_lift (set α) (finset α)"
  },
  {
    "name": "subtype.map",
    "statement": "def subtype.map {α : Sort u_1} {β : Sort u_2} {p : α → Prop} {q : β → Prop} (f : α → β) (h : ∀ (a : α), p a → q (f a)) : subtype p → subtype q",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {p : α → Prop} {q : β → Prop} (f : α → β) (h : ∀ (a : α), p a → q (f a)) : subtype p → subtype q",
    "args": "{α : Sort u_1} {β : Sort u_2} {p : α → Prop} {q : β → Prop} (f : α → β) (h : ∀ (a : α), p a → q (f a))",
    "doc_string": "Restriction of a function to a function on subtypes.",
    "kind": "def",
    "type": "subtype p → subtype q"
  },
  {
    "name": "add_submonoid.list_sum_mem",
    "statement": "theorem add_submonoid.list_sum_mem {M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.sum ∈ s",
    "theorem": "{M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s) : l.sum ∈ s",
    "args": "{M : Type u_1} [add_monoid M] (s : add_submonoid M) {l : list M} (hl : ∀ (x : M), x ∈ l → x ∈ s)",
    "doc_string": "Sum of a list of elements in an `add_submonoid` is in the `add_submonoid`.",
    "kind": "theorem",
    "type": "l.sum ∈ s"
  },
  {
    "name": "subgroup.one_mem",
    "statement": "theorem subgroup.one_mem {G : Type u_1} [group G] (H : subgroup G) : 1 ∈ H",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : 1 ∈ H",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": "A subgroup contains the group's 1.",
    "kind": "theorem",
    "type": "1 ∈ H"
  },
  {
    "name": "has_abs",
    "statement": "structure has_abs (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Absolute value is a unary operator with properties similar to the absolute value of a real number.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "partial_sups.gi",
    "statement": "def partial_sups.gi {α : Type u_1} [semilattice_sup α] : galois_insertion partial_sups coe_fn",
    "theorem": "{α : Type u_1} [semilattice_sup α] : galois_insertion partial_sups coe_fn",
    "args": "{α : Type u_1} [semilattice_sup α]",
    "doc_string": "`partial_sups` forms a Galois insertion with the coercion from monotone functions to functions.",
    "kind": "def",
    "type": "galois_insertion partial_sups coe_fn"
  },
  {
    "name": "exists_lt_of_cinfi_lt",
    "statement": "theorem exists_lt_of_cinfi_lt {α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {a : α} [nonempty ι] {f : ι → α} (h : infi f < a) : ∃ (i : ι), f i < a",
    "theorem": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {a : α} [nonempty ι] {f : ι → α} (h : infi f < a) : ∃ (i : ι), f i < a",
    "args": "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {a : α} [nonempty ι] {f : ι → α} (h : infi f < a)",
    "doc_string": "Indexed version of the above lemma `exists_lt_of_cInf_lt` When `infi f < a`, there is an element `i` such that `f i < a`.",
    "kind": "theorem",
    "type": "∃ (i : ι), f i < a"
  },
  {
    "name": "category_theory.idempotents.karoubi",
    "statement": "structure category_theory.idempotents.karoubi (C : Type u_1) [category_theory.category C] : Type (max u_1 u_2)",
    "theorem": "(C : Type u_1) [category_theory.category C] : Type (max u_1 u_2)",
    "args": "(C : Type u_1) [category_theory.category C]",
    "doc_string": " In a preadditive category `C`, when an object `X` decomposes as `X ≅ P ⨿ Q`, one may consider `P` as a direct factor of `X` and up to unique isomorphism, it is determined by the obvious idempotent `X ⟶ P ⟶ X` which is the projection onto `P` with kernel `Q`. More generally, one may define a formal direct factor of an object `X : C` : it consists of an idempotent `p : X ⟶ X` which is thought as the \"formal image\" of `p`. The type `karoubi C` shall be the type of the objects of the karoubi enveloppe of `C`. It makes sense for any category `C`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "set.partially_well_ordered_on.is_bad_seq",
    "statement": "def set.partially_well_ordered_on.is_bad_seq {α : Type u_1} (r : α → α → Prop) (s : set α) (f : ℕ → α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s : set α) (f : ℕ → α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (s : set α) (f : ℕ → α)",
    "doc_string": "In the context of partial well-orderings, a bad sequence is a nonincreasing sequence  whose range is contained in a particular set `s`. One exists if and only if `s` is not  partially well-ordered.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "seq.of_lazy_list",
    "statement": "def seq.of_lazy_list {α : Type u} : lazy_list α → seq α",
    "theorem": "{α : Type u} : lazy_list α → seq α",
    "args": "{α : Type u}",
    "doc_string": "Embed a `lazy_list α` as a sequence. Note that even though this  is non-meta, it will produce infinite sequences if used with  cyclic `lazy_list`s created by meta constructions.",
    "kind": "def",
    "type": "lazy_list α → seq α"
  },
  {
    "name": "Born",
    "statement": "def Born  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of bornologies.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "local_equiv.restr",
    "statement": "def local_equiv.restr {α : Type u_1} {β : Type u_2} (e : local_equiv α β) (s : set α) : local_equiv α β",
    "theorem": "{α : Type u_1} {β : Type u_2} (e : local_equiv α β) (s : set α) : local_equiv α β",
    "args": "{α : Type u_1} {β : Type u_2} (e : local_equiv α β) (s : set α)",
    "doc_string": "Restricting a local equivalence to e.source ∩ s",
    "kind": "def",
    "type": "local_equiv α β"
  },
  {
    "name": "nat.primrec",
    "statement": "inductive nat.primrec  : (ℕ → ℕ) → Prop",
    "theorem": " : (ℕ → ℕ) → Prop",
    "args": "",
    "doc_string": "The primitive recursive functions `ℕ → ℕ`.",
    "kind": "inductive",
    "type": "(ℕ → ℕ) → Prop"
  },
  {
    "name": "finset.empty",
    "statement": "def finset.empty {α : Type u_1} : finset α",
    "theorem": "{α : Type u_1} : finset α",
    "args": "{α : Type u_1}",
    "doc_string": "The empty finset",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "field",
    "statement": "structure field (K : Type u) : Type u",
    "theorem": "(K : Type u) : Type u",
    "args": "(K : Type u)",
    "doc_string": "A `field` is a `comm_ring` with multiplicative inverses for nonzero elements",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "category_theory.limits.has_products_of_shape",
    "statement": "def category_theory.limits.has_products_of_shape (β : Type v) (C : Type u_1) [category_theory.category C] : Prop",
    "theorem": "(β : Type v) (C : Type u_1) [category_theory.category C] : Prop",
    "args": "(β : Type v) (C : Type u_1) [category_theory.category C]",
    "doc_string": "An abbreviation for `has_limits_of_shape (discrete f)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "witt_vector.truncate_fun",
    "statement": "def witt_vector.truncate_fun {p : ℕ} (n : ℕ) {R : Type u_1} (x : witt_vector p R) : truncated_witt_vector p n R",
    "theorem": "{p : ℕ} (n : ℕ) {R : Type u_1} (x : witt_vector p R) : truncated_witt_vector p n R",
    "args": "{p : ℕ} (n : ℕ) {R : Type u_1} (x : witt_vector p R)",
    "doc_string": " `truncate_fun n x` uses the first `n` entries of `x` to construct a `truncated_witt_vector`, which has the same base `p` as `x`. This function is bundled into a ring homomorphism in `witt_vector.truncate`",
    "kind": "def",
    "type": "truncated_witt_vector p n R"
  },
  {
    "name": "free_abelian_group.of",
    "statement": "def free_abelian_group.of {α : Type u} (x : α) : free_abelian_group α",
    "theorem": "{α : Type u} (x : α) : free_abelian_group α",
    "args": "{α : Type u} (x : α)",
    "doc_string": "The canonical map from α to `free_abelian_group α`",
    "kind": "def",
    "type": "free_abelian_group α"
  },
  {
    "name": "henselian_local_ring",
    "statement": "structure henselian_local_ring (R : Type u_1) [comm_ring R] : Prop",
    "theorem": "(R : Type u_1) [comm_ring R] : Prop",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": " A local ring `R` is *Henselian* if the following condition holds: for every polynomial `f` over `R`, with a *simple* root `a₀` over the residue field, there exists a lift `a : R` of `a₀` that is a root of `f`. (Recall that a root `b` of a polynomial `g` is *simple* if it is not a double root, so if `g.derivative.eval b ≠ 0`.)  In other words, `R` is local Henselian if it is Henselian at the ideal `I`, in the sense of `henselian_ring`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "edist_triangle_left",
    "statement": "theorem edist_triangle_left {α : Type u} [pseudo_emetric_space α] (x y z : α) : has_edist.edist x y ≤ has_edist.edist z x + has_edist.edist z y",
    "theorem": "{α : Type u} [pseudo_emetric_space α] (x y z : α) : has_edist.edist x y ≤ has_edist.edist z x + has_edist.edist z y",
    "args": "{α : Type u} [pseudo_emetric_space α] (x y z : α)",
    "doc_string": "Triangle inequality for the extended distance",
    "kind": "theorem",
    "type": "has_edist.edist x y ≤ has_edist.edist z x + has_edist.edist z y"
  },
  {
    "name": "filter",
    "statement": "structure filter (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " A filter `F` on a type `α` is a collection of sets of `α` which contains the whole `α`, is upwards-closed, and is stable under intersection. We do not forbid this collection to be all sets of `α`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "shelf_hom.id",
    "statement": "def shelf_hom.id (S : Type u_1) [shelf S] : shelf_hom S S",
    "theorem": "(S : Type u_1) [shelf S] : shelf_hom S S",
    "args": "(S : Type u_1) [shelf S]",
    "doc_string": "The identity homomorphism",
    "kind": "def",
    "type": "shelf_hom S S"
  },
  {
    "name": "matrix.cramer_map",
    "statement": "def matrix.cramer_map {n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) (b : n → α) (i : n) : α",
    "theorem": "{n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) (b : n → α) (i : n) : α",
    "args": "{n : Type u} [decidable_eq n] [fintype n] {α : Type v} [comm_ring α] (A : matrix n n α) (b : n → α) (i : n)",
    "doc_string": "`cramer_map A b i` is the determinant of the matrix `A` with column `i` replaced with `b`, and thus `cramer_map A b` is the vector output by Cramer's rule on `A` and `b`.  If `A ⬝ x = b` has a unique solution in `x`, `cramer_map A` sends the vector `b` to `A.det • x`. Otherwise, the outcome of `cramer_map` is well-defined but not necessarily useful.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "list.slice",
    "statement": "def list.slice {α : Type u_1} : ℕ → ℕ → list α → list α",
    "theorem": "{α : Type u_1} : ℕ → ℕ → list α → list α",
    "args": "{α : Type u_1}",
    "doc_string": "`list.slice n m xs` removes a slice of length `m` at index `n` in list `xs`.",
    "kind": "def",
    "type": "ℕ → ℕ → list α → list α"
  },
  {
    "name": "witt_vector.verschiebung_fun",
    "statement": "def witt_vector.verschiebung_fun {p : ℕ} {R : Type u_1} [comm_ring R] (x : witt_vector p R) : witt_vector p R",
    "theorem": "{p : ℕ} {R : Type u_1} [comm_ring R] (x : witt_vector p R) : witt_vector p R",
    "args": "{p : ℕ} {R : Type u_1} [comm_ring R] (x : witt_vector p R)",
    "doc_string": "`verschiebung_fun x` shifts the coefficients of `x` up by one, by inserting 0 as the 0th coefficient. `x.coeff i` then becomes `(verchiebung_fun x).coeff (i + 1)`.  `verschiebung_fun` is the underlying function of the additive monoid hom `witt_vector.verschiebung`.",
    "kind": "def",
    "type": "witt_vector p R"
  },
  {
    "name": "orthonormal_basis_index",
    "statement": "def orthonormal_basis_index (𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] : set E",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E] : set E",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] [finite_dimensional 𝕜 E]",
    "doc_string": "Index for an arbitrary orthonormal basis on a finite-dimensional `inner_product_space`.",
    "kind": "def",
    "type": "set E"
  },
  {
    "name": "sSet.boundary",
    "statement": "def sSet.boundary (n : ℕ) : sSet",
    "theorem": "(n : ℕ) : sSet",
    "args": "(n : ℕ)",
    "doc_string": " The boundary `∂Δ[n]` of the `n`-th standard simplex consists of all `m`-simplices of `standard_simplex n` that are not surjective (when viewed as monotone function `m → n`).",
    "kind": "def",
    "type": "sSet"
  },
  {
    "name": "set.Ioo",
    "statement": "def set.Ioo {α : Type u_1} [preorder α] (a b : α) : set α",
    "theorem": "{α : Type u_1} [preorder α] (a b : α) : set α",
    "args": "{α : Type u_1} [preorder α] (a b : α)",
    "doc_string": "Left-open right-open interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "first_order.language.is_relational",
    "statement": "structure first_order.language.is_relational (L : first_order.language) : Prop",
    "theorem": "(L : first_order.language) : Prop",
    "args": "(L : first_order.language)",
    "doc_string": "A language is relational when it has no function symbols.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "fin2.elim0",
    "statement": "def fin2.elim0 {C : fin2 0 → Sort u} (i : fin2 0) : C i",
    "theorem": "{C : fin2 0 → Sort u} (i : fin2 0) : C i",
    "args": "{C : fin2 0 → Sort u} (i : fin2 0)",
    "doc_string": "Ex falso. The dependent eliminator for the empty `fin2 0` type.",
    "kind": "def",
    "type": "C i"
  },
  {
    "name": "mul_self_add_mul_self_eq_zero",
    "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
    "theorem": "{α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
    "args": "{α : Type u} [linear_ordered_ring α] {x y : α}",
    "doc_string": "The sum of two squares is zero iff both elements are zero.",
    "kind": "theorem",
    "type": "x * x + y * y = 0 ↔ x = 0 ∧ y = 0"
  },
  {
    "name": "right.add_neg'",
    "statement": "theorem right.add_neg' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg'`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "multiset.antidiagonal",
    "statement": "def multiset.antidiagonal {α : Type u_1} (s : multiset α) : multiset (multiset α × multiset α)",
    "theorem": "{α : Type u_1} (s : multiset α) : multiset (multiset α × multiset α)",
    "args": "{α : Type u_1} (s : multiset α)",
    "doc_string": "The antidiagonal of a multiset `s` consists of all pairs `(t₁, t₂)`    such that `t₁ + t₂ = s`. These pairs are counted with multiplicities.",
    "kind": "def",
    "type": "multiset (multiset α × multiset α)"
  },
  {
    "name": "finset.card_le_one_of_subsingleton",
    "statement": "theorem finset.card_le_one_of_subsingleton {α : Type u_1} [subsingleton α] (s : finset α) : s.card ≤ 1",
    "theorem": "{α : Type u_1} [subsingleton α] (s : finset α) : s.card ≤ 1",
    "args": "{α : Type u_1} [subsingleton α] (s : finset α)",
    "doc_string": "A `finset` of a subsingleton type has cardinality at most one.",
    "kind": "theorem",
    "type": "s.card ≤ 1"
  },
  {
    "name": "filter.is_antitone_basis",
    "statement": "structure filter.is_antitone_basis {α : Type u_1} {ι'' : Type u_6} [preorder ι''] (s'' : ι'' → set α) : Prop",
    "theorem": "{α : Type u_1} {ι'' : Type u_6} [preorder ι''] (s'' : ι'' → set α) : Prop",
    "args": "{α : Type u_1} {ι'' : Type u_6} [preorder ι''] (s'' : ι'' → set α)",
    "doc_string": "`is_antitone_basis s` means the image of `s` is a filter basis such that `s` is decreasing.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "num.ppred",
    "statement": "def num.ppred  : num → option num",
    "theorem": " : num → option num",
    "args": "",
    "doc_string": "The predecessor of a `num` as an `option num`, where `ppred 0 = none`",
    "kind": "def",
    "type": "num → option num"
  },
  {
    "name": "measure_theory.measure.measurable_space",
    "statement": "def measure_theory.measure.measurable_space {α : Type u_1} [measurable_space α] : measurable_space (measure_theory.measure α)",
    "theorem": "{α : Type u_1} [measurable_space α] : measurable_space (measure_theory.measure α)",
    "args": "{α : Type u_1} [measurable_space α]",
    "doc_string": "Measurability structure on `measure`: Measures are measurable w.r.t. all projections",
    "kind": "def",
    "type": "measurable_space (measure_theory.measure α)"
  },
  {
    "name": "is_add_right_regular_of_add_eq_zero",
    "statement": "theorem is_add_right_regular_of_add_eq_zero {R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a",
    "theorem": "{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a",
    "args": "{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0)",
    "doc_string": "An element admitting a right additive opposite is add-right-regular.",
    "kind": "theorem",
    "type": "is_add_right_regular a"
  },
  {
    "name": "galois_connection",
    "statement": "def galois_connection {α : Type u} {β : Type v} [preorder α] [preorder β] (l : α → β) (u : β → α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (l : α → β) (u : β → α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (l : α → β) (u : β → α)",
    "doc_string": "A Galois connection is a pair of functions `l` and `u` satisfying  `l a ≤ b ↔ a ≤ u b`. They are special cases of adjoint functors in category theory,    but do not depend on the category theory library in mathlib.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_torsion_free.not_torsion",
    "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G",
    "theorem": "{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G",
    "args": "{G : Type u_1} [group G] [hN : nontrivial G]",
    "doc_string": "A nontrivial torsion-free group is not torsion.",
    "kind": "theorem",
    "type": "monoid.is_torsion_free G → ¬monoid.is_torsion G"
  },
  {
    "name": "algebraic_closure",
    "statement": "def algebraic_closure (k : Type u) [field k] : Type u",
    "theorem": "(k : Type u) [field k] : Type u",
    "args": "(k : Type u) [field k]",
    "doc_string": " The canonical algebraic closure of a field, the direct limit of adding roots to the field for each polynomial over the field.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "d_array.foreach",
    "statement": "def d_array.foreach {n : ℕ} {α : fin n → Type u} {α' : fin n → Type v} (a : d_array n α) (f : Π (i : fin n), α i → α' i) : d_array n α'",
    "theorem": "{n : ℕ} {α : fin n → Type u} {α' : fin n → Type v} (a : d_array n α) (f : Π (i : fin n), α i → α' i) : d_array n α'",
    "args": "{n : ℕ} {α : fin n → Type u} {α' : fin n → Type v} (a : d_array n α) (f : Π (i : fin n), α i → α' i)",
    "doc_string": "Map the array. Has builtin VM implementation.",
    "kind": "def",
    "type": "d_array n α'"
  },
  {
    "name": "generalized_continued_fraction.ext_iff",
    "statement": "theorem generalized_continued_fraction.ext_iff {α : Type u_1} {g g' : generalized_continued_fraction α} : g = g' ↔ g.h = g'.h ∧ g.s = g'.s",
    "theorem": "{α : Type u_1} {g g' : generalized_continued_fraction α} : g = g' ↔ g.h = g'.h ∧ g.s = g'.s",
    "args": "{α : Type u_1} {g g' : generalized_continued_fraction α}",
    "doc_string": "Two gcfs `g` and `g'` are equal if and only if their components are equal.",
    "kind": "theorem",
    "type": "g = g' ↔ g.h = g'.h ∧ g.s = g'.s"
  },
  {
    "name": "module.is_torsion",
    "statement": "def module.is_torsion (R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Prop",
    "theorem": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] : Prop",
    "args": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "A torsion module is a module where every element is `a`-torsion for some non-zero-divisor `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "multiset.sort",
    "statement": "def multiset.sort {α : Type u_1} (r : α → α → Prop) [decidable_rel r] [is_trans α r] [is_antisymm α r] [is_total α r] (s : multiset α) : list α",
    "theorem": "{α : Type u_1} (r : α → α → Prop) [decidable_rel r] [is_trans α r] [is_antisymm α r] [is_total α r] (s : multiset α) : list α",
    "args": "{α : Type u_1} (r : α → α → Prop) [decidable_rel r] [is_trans α r] [is_antisymm α r] [is_total α r] (s : multiset α)",
    "doc_string": "`sort s` constructs a sorted list from the multiset `s`.  (Uses merge sort algorithm.)",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "category_theory.sieve.Sup",
    "statement": "def category_theory.sieve.Sup {C : Type u₁} [category_theory.category C] {X : C} (𝒮 : set (category_theory.sieve X)) : category_theory.sieve X",
    "theorem": "{C : Type u₁} [category_theory.category C] {X : C} (𝒮 : set (category_theory.sieve X)) : category_theory.sieve X",
    "args": "{C : Type u₁} [category_theory.category C] {X : C} (𝒮 : set (category_theory.sieve X))",
    "doc_string": "The supremum of a collection of sieves: the union of them all.",
    "kind": "def",
    "type": "category_theory.sieve X"
  },
  {
    "name": "star_semigroup.to_star_module",
    "statement": "def star_semigroup.to_star_module {R : Type u} [comm_monoid R] [star_semigroup R] : star_module R R",
    "theorem": "{R : Type u} [comm_monoid R] [star_semigroup R] : star_module R R",
    "args": "{R : Type u} [comm_monoid R] [star_semigroup R]",
    "doc_string": "A commutative star monoid is a star module over itself via `monoid.to_mul_action`.",
    "kind": "def",
    "type": "star_module R R"
  },
  {
    "name": "lemmas_only",
    "statement": "def lemmas_only  : simps_cfg",
    "theorem": " : simps_cfg",
    "args": "",
    "doc_string": "A common configuration for `@[simps]`: don't tag the generated lemmas with `@[simp]`.",
    "kind": "def",
    "type": "simps_cfg"
  },
  {
    "name": "bitvec.uge",
    "statement": "def bitvec.uge {n : ℕ} (x y : bitvec n) : Prop",
    "theorem": "{n : ℕ} (x y : bitvec n) : Prop",
    "args": "{n : ℕ} (x y : bitvec n)",
    "doc_string": "unsigned greater-than-or-equal-to proposition",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "derivation",
    "statement": "structure derivation (R : Type u_1) (A : Type u_2) [comm_semiring R] [comm_semiring A] [algebra R A] (M : Type u_3) [add_comm_monoid M] [module A M] [module R M] : Type (max u_2 u_3)",
    "theorem": "(R : Type u_1) (A : Type u_2) [comm_semiring R] [comm_semiring A] [algebra R A] (M : Type u_3) [add_comm_monoid M] [module A M] [module R M] : Type (max u_2 u_3)",
    "args": "(R : Type u_1) (A : Type u_2) [comm_semiring R] [comm_semiring A] [algebra R A] (M : Type u_3) [add_comm_monoid M] [module A M] [module R M]",
    "doc_string": " `D : derivation R A M` is an `R`-linear map from `A` to `M` that satisfies the `leibniz` equality. We also require that `D 1 = 0`. See `derivation.mk'` for a constructor that deduces this assumption from the Leibniz rule when `M` is cancellative.  TODO: update this when bimodules are defined.",
    "kind": "structure",
    "type": "Type (max u_2 u_3)"
  },
  {
    "name": "omega.int.preform",
    "statement": "inductive omega.int.preform  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Intermediate shadow syntax for LIA formulas that includes non-canonical terms",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "sequence",
    "statement": "def sequence {t : Type u → Type u} {α : Type u} {f : Type u → Type u} [applicative f] [traversable t] : t (f α) → f (t α)",
    "theorem": "{t : Type u → Type u} {α : Type u} {f : Type u → Type u} [applicative f] [traversable t] : t (f α) → f (t α)",
    "args": "{t : Type u → Type u} {α : Type u} {f : Type u → Type u} [applicative f] [traversable t]",
    "doc_string": "A traversable functor commutes with all applicative functors.",
    "kind": "def",
    "type": "t (f α) → f (t α)"
  },
  {
    "name": "set.add_comm_monoid",
    "statement": "def set.add_comm_monoid {α : Type u_2} [add_comm_monoid α] : add_comm_monoid (set α)",
    "theorem": "{α : Type u_2} [add_comm_monoid α] : add_comm_monoid (set α)",
    "args": "{α : Type u_2} [add_comm_monoid α]",
    "doc_string": "`set α` is an `add_comm_monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_comm_monoid (set α)"
  },
  {
    "name": "complete_lattice_hom.id",
    "statement": "def complete_lattice_hom.id (α : Type u_2) [complete_lattice α] : complete_lattice_hom α α",
    "theorem": "(α : Type u_2) [complete_lattice α] : complete_lattice_hom α α",
    "args": "(α : Type u_2) [complete_lattice α]",
    "doc_string": "`id` as a `complete_lattice_hom`.",
    "kind": "def",
    "type": "complete_lattice_hom α α"
  },
  {
    "name": "pgame.has_one",
    "statement": "def pgame.has_one  : has_one pgame",
    "theorem": " : has_one pgame",
    "args": "",
    "doc_string": "The pre-game `one` is defined by `1 = { 0 | }`.",
    "kind": "def",
    "type": "has_one pgame"
  },
  {
    "name": "metric.diam_mono",
    "statement": "theorem metric.diam_mono {α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t) : metric.diam s ≤ metric.diam t",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t) : metric.diam s ≤ metric.diam t",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t)",
    "doc_string": "If `s ⊆ t`, then the diameter of `s` is bounded by that of `t`, provided `t` is bounded.",
    "kind": "theorem",
    "type": "metric.diam s ≤ metric.diam t"
  },
  {
    "name": "finset.attach",
    "statement": "def finset.attach {α : Type u_1} (s : finset α) : finset {x // x ∈ s}",
    "theorem": "{α : Type u_1} (s : finset α) : finset {x // x ∈ s}",
    "args": "{α : Type u_1} (s : finset α)",
    "doc_string": " `attach s` takes the elements of `s` and forms a new set of elements of the subtype `{x // x ∈ s}`.",
    "kind": "def",
    "type": "finset {x // x ∈ s}"
  },
  {
    "name": "category_theory.comonad.id",
    "statement": "def category_theory.comonad.id (C : Type u₁) [category_theory.category C] : category_theory.comonad C",
    "theorem": "(C : Type u₁) [category_theory.category C] : category_theory.comonad C",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": "The identity comonad.",
    "kind": "def",
    "type": "category_theory.comonad C"
  },
  {
    "name": "filter.add_comm_semigroup",
    "statement": "def filter.add_comm_semigroup {α : Type u_2} [add_comm_semigroup α] : add_comm_semigroup (filter α)",
    "theorem": "{α : Type u_2} [add_comm_semigroup α] : add_comm_semigroup (filter α)",
    "args": "{α : Type u_2} [add_comm_semigroup α]",
    "doc_string": "`filter α` is an `add_comm_semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_comm_semigroup (filter α)"
  },
  {
    "name": "list.foldl_with_index_aux",
    "statement": "def list.foldl_with_index_aux {α : Type u_1} {β : Type u_2} (f : ℕ → α → β → α) : ℕ → α → list β → α",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : ℕ → α → β → α) : ℕ → α → list β → α",
    "args": "{α : Type u_1} {β : Type u_2} (f : ℕ → α → β → α)",
    "doc_string": "Auxiliary definition for `foldl_with_index`.",
    "kind": "def",
    "type": "ℕ → α → list β → α"
  },
  {
    "name": "category_theory.simplicial_object.truncated",
    "statement": "def category_theory.simplicial_object.truncated (C : Type u) [category_theory.category C] (n : ℕ) : Type (max v u)",
    "theorem": "(C : Type u) [category_theory.category C] (n : ℕ) : Type (max v u)",
    "args": "(C : Type u) [category_theory.category C] (n : ℕ)",
    "doc_string": "Truncated simplicial objects.",
    "kind": "def",
    "type": "Type (max v u)"
  },
  {
    "name": "quaternion_group.group",
    "statement": "def quaternion_group.group {n : ℕ} : group (quaternion_group n)",
    "theorem": "{n : ℕ} : group (quaternion_group n)",
    "args": "{n : ℕ}",
    "doc_string": "The group structure on `quaternion_group n`.",
    "kind": "def",
    "type": "group (quaternion_group n)"
  },
  {
    "name": "subring.ext",
    "statement": "theorem subring.ext {R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T",
    "theorem": "{R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T",
    "args": "{R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T)",
    "doc_string": "Two subrings are equal if they have the same elements.",
    "kind": "theorem",
    "type": "S = T"
  },
  {
    "name": "pgame.birthday",
    "statement": "def pgame.birthday  : pgame → ordinal",
    "theorem": " : pgame → ordinal",
    "args": "",
    "doc_string": " The birthday of a pre-game is inductively defined as the least strict upper bound of the birthdays of its left and right games. It may be thought as the \"step\" in which a certain game is constructed.",
    "kind": "def",
    "type": "pgame → ordinal"
  },
  {
    "name": "path.homotopic.proj_right",
    "statement": "def path.homotopic.proj_right {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {c₁ c₂ : α × β} (p : path.homotopic.quotient c₁ c₂) : path.homotopic.quotient c₁.snd c₂.snd",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {c₁ c₂ : α × β} (p : path.homotopic.quotient c₁ c₂) : path.homotopic.quotient c₁.snd c₂.snd",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {c₁ c₂ : α × β} (p : path.homotopic.quotient c₁ c₂)",
    "doc_string": "Abbreviation for projection onto the right coordinate of a path class",
    "kind": "def",
    "type": "path.homotopic.quotient c₁.snd c₂.snd"
  },
  {
    "name": "category_theory.grothendieck_topology.cover",
    "statement": "def category_theory.grothendieck_topology.cover {C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (X : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (X : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] (J : category_theory.grothendieck_topology C) (X : C)",
    "doc_string": " `J.cover X` denotes the poset of covers of `X` with respect to the Grothendieck topology `J`.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "empty_wf",
    "statement": "theorem empty_wf {α : Sort u} : well_founded empty_relation",
    "theorem": "{α : Sort u} : well_founded empty_relation",
    "args": "{α : Sort u}",
    "doc_string": "Empty relation is well-founded",
    "kind": "theorem",
    "type": "well_founded empty_relation"
  },
  {
    "name": "vector.traverse",
    "statement": "def vector.traverse {n : ℕ} {F : Type u → Type u} [applicative F] {α β : Type u} (f : α → F β) : vector α n → F (vector β n)",
    "theorem": "{n : ℕ} {F : Type u → Type u} [applicative F] {α β : Type u} (f : α → F β) : vector α n → F (vector β n)",
    "args": "{n : ℕ} {F : Type u → Type u} [applicative F] {α β : Type u} (f : α → F β)",
    "doc_string": "Apply an applicative function to each component of a vector.",
    "kind": "def",
    "type": "vector α n → F (vector β n)"
  },
  {
    "name": "sym.erase",
    "statement": "def sym.erase {α : Type u_1} {n : ℕ} [decidable_eq α] (s : sym α (n + 1)) (a : α) (h : a ∈ s) : sym α n",
    "theorem": "{α : Type u_1} {n : ℕ} [decidable_eq α] (s : sym α (n + 1)) (a : α) (h : a ∈ s) : sym α n",
    "args": "{α : Type u_1} {n : ℕ} [decidable_eq α] (s : sym α (n + 1)) (a : α) (h : a ∈ s)",
    "doc_string": "`erase s a h` is the sym that subtracts 1 from the  multiplicity of `a` if a is present in the sym.",
    "kind": "def",
    "type": "sym α n"
  },
  {
    "name": "GroupWithZero.of",
    "statement": "def GroupWithZero.of (α : Type u_1) [group_with_zero α] : GroupWithZero",
    "theorem": "(α : Type u_1) [group_with_zero α] : GroupWithZero",
    "args": "(α : Type u_1) [group_with_zero α]",
    "doc_string": "Construct a bundled `GroupWithZero` from a `group_with_zero`.",
    "kind": "def",
    "type": "GroupWithZero"
  },
  {
    "name": "complete_lattice_hom.to_bounded_lattice_hom",
    "statement": "def complete_lattice_hom.to_bounded_lattice_hom {α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : complete_lattice_hom α β) : bounded_lattice_hom α β",
    "theorem": "{α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : complete_lattice_hom α β) : bounded_lattice_hom α β",
    "args": "{α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : complete_lattice_hom α β)",
    "doc_string": "Reinterpret a `complete_lattice_hom` as a `bounded_lattice_hom`.",
    "kind": "def",
    "type": "bounded_lattice_hom α β"
  },
  {
    "name": "is_well_order",
    "statement": "structure is_well_order (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": "A well order is a well-founded linear order.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "turing.to_partrec.cont",
    "statement": "inductive turing.to_partrec.cont  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of continuations, built up during evaluation of a `code` expression.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "topological_space.closeds.inhabited",
    "statement": "def topological_space.closeds.inhabited {α : Type u_1} [topological_space α] : inhabited (topological_space.closeds α)",
    "theorem": "{α : Type u_1} [topological_space α] : inhabited (topological_space.closeds α)",
    "args": "{α : Type u_1} [topological_space α]",
    "doc_string": "The type of closed sets is inhabited, with default element the empty set.",
    "kind": "def",
    "type": "inhabited (topological_space.closeds α)"
  },
  {
    "name": "antitone_on",
    "statement": "def antitone_on {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α)",
    "doc_string": "A function `f` is antitone on `s` if, for all `a, b ∈ s`, `a ≤ b` implies `f b ≤ f a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.any",
    "statement": "def ordnode.any {α : Type u} (P : α → Prop) : ordnode α → Prop",
    "theorem": "{α : Type u} (P : α → Prop) : ordnode α → Prop",
    "args": "{α : Type u} (P : α → Prop)",
    "doc_string": "O(n). Does any element of the map satisfy property `P`?      any (λ x, x < 2) {1, 2, 3} = true     any (λ x, x < 2) {2, 3, 5} = false",
    "kind": "def",
    "type": "ordnode α → Prop"
  },
  {
    "name": "finset.comm_monoid",
    "statement": "def finset.comm_monoid {α : Type u_2} [decidable_eq α] [comm_monoid α] : comm_monoid (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [comm_monoid α] : comm_monoid (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [comm_monoid α]",
    "doc_string": "`finset α` is a `comm_monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "comm_monoid (finset α)"
  },
  {
    "name": "cycle.nodup",
    "statement": "def cycle.nodup {α : Type u_1} (s : cycle α) : Prop",
    "theorem": "{α : Type u_1} (s : cycle α) : Prop",
    "args": "{α : Type u_1} (s : cycle α)",
    "doc_string": "The `s : cycle α` contains no duplicates.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "local_homeomorph.simps.symm_apply",
    "statement": "def local_homeomorph.simps.symm_apply {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : β → α",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) : β → α",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "β → α"
  },
  {
    "name": "pnat.xgcd_type.step_v",
    "statement": "theorem pnat.xgcd_type.step_v (u : pnat.xgcd_type) (hr : u.r ≠ 0) : u.step.v = u.v.swap",
    "theorem": "(u : pnat.xgcd_type) (hr : u.r ≠ 0) : u.step.v = u.v.swap",
    "args": "(u : pnat.xgcd_type) (hr : u.r ≠ 0)",
    "doc_string": "The reduction step does not change the product vector.",
    "kind": "theorem",
    "type": "u.step.v = u.v.swap"
  },
  {
    "name": "subset_span_points",
    "statement": "theorem subset_span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ span_points k s",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ span_points k s",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P)",
    "doc_string": "A set is contained in its `span_points`.",
    "kind": "theorem",
    "type": "s ⊆ span_points k s"
  },
  {
    "name": "order.lt_of_succ_lt_succ",
    "statement": "theorem order.lt_of_succ_lt_succ {α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a < order.succ b → a < b",
    "theorem": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a < order.succ b → a < b",
    "args": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α]",
    "doc_string": "**Alias** of the forward direction of order.succ_lt_succ_iff`.",
    "kind": "theorem",
    "type": "order.succ a < order.succ b → a < b"
  },
  {
    "name": "sub_one_div_inv_le_two",
    "statement": "theorem sub_one_div_inv_le_two {α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2",
    "args": "{α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a)",
    "doc_string": "An inequality involving `2`.",
    "kind": "theorem",
    "type": "(1 - 1 / a)⁻¹ ≤ 2"
  },
  {
    "name": "category_theory.bicategory",
    "statement": "structure category_theory.bicategory (B : Type u) : Type (max u (v+1) (w+1))",
    "theorem": "(B : Type u) : Type (max u (v+1) (w+1))",
    "args": "(B : Type u)",
    "doc_string": "In a bicategory, we can compose the 1-morphisms `f : a ⟶ b` and `g : b ⟶ c` to obtain a 1-morphism `f ≫ g : a ⟶ c`. This composition does not need to be strictly associative, but there is a specified associator, `α_ f g h : (f ≫ g) ≫ h ≅ f ≫ (g ≫ h)`. There is an identity 1-morphism `𝟙 a : a ⟶ a`, with specified left and right unitor isomorphisms `λ_ f : 𝟙 a ≫ f ≅ f` and `ρ_ f : f ≫ 𝟙 a ≅ f`. These associators and unitors satisfy the pentagon and triangle equations.  See https://ncatlab.org/nlab/show/bicategory.",
    "kind": "structure",
    "type": "Type (max u (v+1) (w+1))"
  },
  {
    "name": "mvqpf.fix",
    "statement": "def mvqpf.fix {n : ℕ} (F : typevec (n + 1) → Type u_1) [mvfunctor F] [q : mvqpf F] (α : typevec n) : Type u_1",
    "theorem": "{n : ℕ} (F : typevec (n + 1) → Type u_1) [mvfunctor F] [q : mvqpf F] (α : typevec n) : Type u_1",
    "args": "{n : ℕ} (F : typevec (n + 1) → Type u_1) [mvfunctor F] [q : mvqpf F] (α : typevec n)",
    "doc_string": " Least fixed point of functor F. The result is a functor with one fewer parameters than the input. For `F a b c` a ternary functor, fix F is a binary functor such that  ```lean fix F a b = F a b (fix F a b) ```",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "list.modify_nth_tail",
    "statement": "def list.modify_nth_tail {α : Type u_1} (f : list α → list α) : ℕ → list α → list α",
    "theorem": "{α : Type u_1} (f : list α → list α) : ℕ → list α → list α",
    "args": "{α : Type u_1} (f : list α → list α)",
    "doc_string": "Apply a function to the nth tail of `l`. Returns the input without  using `f` if the index is larger than the length of the list.      modify_nth_tail f 2 [a, b, c] = [a, b] ++ f [c]",
    "kind": "def",
    "type": "ℕ → list α → list α"
  },
  {
    "name": "mul_aut.group",
    "statement": "def mul_aut.group (M : Type u_2) [has_mul M] : group (mul_aut M)",
    "theorem": "(M : Type u_2) [has_mul M] : group (mul_aut M)",
    "args": "(M : Type u_2) [has_mul M]",
    "doc_string": "The group operation on multiplicative automorphisms is defined by `λ g h, mul_equiv.trans h g`. This means that multiplication agrees with composition, `(g*h)(x) = g (h x)`.",
    "kind": "def",
    "type": "group (mul_aut M)"
  },
  {
    "name": "paracompact_space",
    "statement": "structure paracompact_space (X : Type v) [topological_space X] : Prop",
    "theorem": "(X : Type v) [topological_space X] : Prop",
    "args": "(X : Type v) [topological_space X]",
    "doc_string": " A topological space is called paracompact, if every open covering of this space admits a locally finite refinement. We use the same universe for all types in the definition to avoid creating a class like `paracompact_space.{u v}`. Due to lemma `precise_refinement` below, every open covering `s : α → set X` indexed on `α : Type v` has a *precise* locally finite refinement, i.e., a locally finite refinement `t : α → set X` indexed on the same type such that each `∀ i, t i ⊆ s i`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_domain",
    "statement": "structure is_domain (α : Type u) [ring α] : Prop",
    "theorem": "(α : Type u) [ring α] : Prop",
    "args": "(α : Type u) [ring α]",
    "doc_string": "A domain is a nontrivial ring with no zero divisors, i.e. satisfying  the condition `a * b = 0 ↔ a = 0 ∨ b = 0`.   This is implemented as a mixin for `ring α`.  To obtain an integral domain use `[comm_ring α] [is_domain α]`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "normed_comm_ring.to_semi_normed_comm_ring",
    "statement": "def normed_comm_ring.to_semi_normed_comm_ring {α : Type u_1} [β : normed_comm_ring α] : semi_normed_comm_ring α",
    "theorem": "{α : Type u_1} [β : normed_comm_ring α] : semi_normed_comm_ring α",
    "args": "{α : Type u_1} [β : normed_comm_ring α]",
    "doc_string": "A normed commutative ring is a seminormed commutative ring.",
    "kind": "def",
    "type": "semi_normed_comm_ring α"
  },
  {
    "name": "nat_ordinal",
    "statement": "def nat_ordinal  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "A type synonym for ordinals with natural addition and multiplication.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "wcovby",
    "statement": "def wcovby {α : Type u_1} [preorder α] (a b : α) : Prop",
    "theorem": "{α : Type u_1} [preorder α] (a b : α) : Prop",
    "args": "{α : Type u_1} [preorder α] (a b : α)",
    "doc_string": " `wcovby a b` means that `a = b` or `b` covers `a`. This means that `a ≤ b` and there is no element in between.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_empty.elim'",
    "statement": "def is_empty.elim' {α : Sort u_1} {β : Sort u_2} (h : is_empty α) (a : α) : β",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (h : is_empty α) (a : α) : β",
    "args": "{α : Sort u_1} {β : Sort u_2} (h : is_empty α) (a : α)",
    "doc_string": "Non-dependent version of `is_empty.elim`. Helpful if the elaborator cannot elaborate `h.elim a`  correctly.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "list.to_finset",
    "statement": "def list.to_finset {α : Type u_1} [decidable_eq α] (l : list α) : finset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (l : list α) : finset α",
    "args": "{α : Type u_1} [decidable_eq α] (l : list α)",
    "doc_string": "`to_finset l` removes duplicates from the list `l` to produce a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "finpartition.copy",
    "statement": "def finpartition.copy {α : Type u_1} [lattice α] [order_bot α] {a b : α} (P : finpartition a) (h : a = b) : finpartition b",
    "theorem": "{α : Type u_1} [lattice α] [order_bot α] {a b : α} (P : finpartition a) (h : a = b) : finpartition b",
    "args": "{α : Type u_1} [lattice α] [order_bot α] {a b : α} (P : finpartition a) (h : a = b)",
    "doc_string": "Changes the type of a finpartition to an equal one.",
    "kind": "def",
    "type": "finpartition b"
  },
  {
    "name": "generalized_continued_fraction.pair",
    "statement": "structure generalized_continued_fraction.pair (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "We collect a partial numerator `aᵢ` and partial denominator `bᵢ` in a pair `⟨aᵢ,bᵢ⟩`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "grade_min_order.fin_to_nat",
    "statement": "def grade_min_order.fin_to_nat {α : Type u_3} [preorder α] (n : ℕ) [grade_min_order (fin n) α] : grade_min_order ℕ α",
    "theorem": "{α : Type u_3} [preorder α] (n : ℕ) [grade_min_order (fin n) α] : grade_min_order ℕ α",
    "args": "{α : Type u_3} [preorder α] (n : ℕ) [grade_min_order (fin n) α]",
    "doc_string": " A `fin n`-graded order is also `ℕ`-graded. We do not mark this an instance because `n` is not inferrable.",
    "kind": "def",
    "type": "grade_min_order ℕ α"
  },
  {
    "name": "wseq.take",
    "statement": "def wseq.take {α : Type u} (s : wseq α) (n : ℕ) : wseq α",
    "theorem": "{α : Type u} (s : wseq α) (n : ℕ) : wseq α",
    "args": "{α : Type u} (s : wseq α) (n : ℕ)",
    "doc_string": "Get the first `n` elements of a weak sequence",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "turing.list_blank.cons_head_tail",
    "statement": "theorem turing.list_blank.cons_head_tail {Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank.cons l.head l.tail = l",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank.cons l.head l.tail = l",
    "args": "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ)",
    "doc_string": " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists.",
    "kind": "theorem",
    "type": "turing.list_blank.cons l.head l.tail = l"
  },
  {
    "name": "uniform_space.separation_quotient",
    "statement": "def uniform_space.separation_quotient (α : Type u_1) [uniform_space α] : Type u_1",
    "theorem": "(α : Type u_1) [uniform_space α] : Type u_1",
    "args": "(α : Type u_1) [uniform_space α]",
    "doc_string": "The maximal separated quotient of a uniform space `α`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "subsemiring",
    "statement": "structure subsemiring (R : Type u) [non_assoc_semiring R] : Type u",
    "theorem": "(R : Type u) [non_assoc_semiring R] : Type u",
    "args": "(R : Type u) [non_assoc_semiring R]",
    "doc_string": " A subsemiring of a semiring `R` is a subset `s` that is both a multiplicative and an additive submonoid.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "polynomial.monomial_fun",
    "statement": "def polynomial.monomial_fun {R : Type u} [semiring R] (n : ℕ) (a : R) : polynomial R",
    "theorem": "{R : Type u} [semiring R] (n : ℕ) (a : R) : polynomial R",
    "args": "{R : Type u} [semiring R] (n : ℕ) (a : R)",
    "doc_string": "The function version of `monomial`. Use `monomial` instead of this one.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "topological_fiber_bundle_core.local_triv_at",
    "statement": "def topological_fiber_bundle_core.local_triv_at {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : topological_fiber_bundle.trivialization F Z.proj",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : topological_fiber_bundle.trivialization F Z.proj",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B)",
    "doc_string": " Preferred local trivialization of a fiber bundle constructed from core, at a given point, as a bundle trivialization",
    "kind": "def",
    "type": "topological_fiber_bundle.trivialization F Z.proj"
  },
  {
    "name": "list.merge_sort",
    "statement": "def list.merge_sort {α : Type uu} (r : α → α → Prop) [decidable_rel r] : list α → list α",
    "theorem": "{α : Type uu} (r : α → α → Prop) [decidable_rel r] : list α → list α",
    "args": "{α : Type uu} (r : α → α → Prop) [decidable_rel r]",
    "doc_string": "Implementation of a merge sort algorithm to sort a list.",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "omega.eq_elim",
    "statement": "def omega.eq_elim  : list omega.ee → omega.clause → omega.clause",
    "theorem": " : list omega.ee → omega.clause → omega.clause",
    "args": "",
    "doc_string": "Apply a given sequence of equality elimination steps to a clause.",
    "kind": "def",
    "type": "list omega.ee → omega.clause → omega.clause"
  },
  {
    "name": "rel.comp",
    "statement": "def rel.comp {α : Type u_1} {β : Type u_2} {γ : Type u_3} (r : rel α β) (s : rel β γ) : rel α γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (r : rel α β) (s : rel β γ) : rel α γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (r : rel α β) (s : rel β γ)",
    "doc_string": "Composition of relation; note that it follows the `category_theory/` order of arguments.",
    "kind": "def",
    "type": "rel α γ"
  },
  {
    "name": "lie_algebra.is_semisimple",
    "statement": "structure lie_algebra.is_semisimple (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": " A semisimple Lie algebra is one with trivial radical.  Note that the label 'semisimple' is apparently not universally agreed [upon](https://mathoverflow.net/questions/149391/on-radicals-of-a-lie-algebra#comment383669_149391) for general coefficients. We are following [Seligman, page 15](seligman1967) and using the label for the weakest of the various properties which are all equivalent over a field of characteristic zero.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "where.binder_less_important",
    "statement": "def where.binder_less_important (u v : binder_info) : bool",
    "theorem": "(u v : binder_info) : bool",
    "args": "(u v : binder_info)",
    "doc_string": "The relation on binder priorities.",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "submonoid.of",
    "statement": "def submonoid.of {M : Type u_1} [monoid M] {s : set M} (h : is_submonoid s) : submonoid M",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} (h : is_submonoid s) : submonoid M",
    "args": "{M : Type u_1} [monoid M] {s : set M} (h : is_submonoid s)",
    "doc_string": "Create a bundled submonoid from a set `s` and `[is_submonoid s]`.",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "ordinal.log",
    "statement": "def ordinal.log (b x : ordinal) : ordinal",
    "theorem": "(b x : ordinal) : ordinal",
    "args": "(b x : ordinal)",
    "doc_string": "The ordinal logarithm is the solution `u` to the equation `x = b ^ u * v + w` where `v < b` and    `w < b ^ u`.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "bdd_below",
    "statement": "def bdd_below {α : Type u} [preorder α] (s : set α) : Prop",
    "theorem": "{α : Type u} [preorder α] (s : set α) : Prop",
    "args": "{α : Type u} [preorder α] (s : set α)",
    "doc_string": "A set is bounded below if there exists a lower bound.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pi_nat.longest_prefix",
    "statement": "def pi_nat.longest_prefix {E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (s : set (Π (n : ℕ), E n)) : ℕ",
    "theorem": "{E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (s : set (Π (n : ℕ), E n)) : ℕ",
    "args": "{E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (s : set (Π (n : ℕ), E n))",
    "doc_string": " Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then `longest_prefix x s` if the largest `n` for which there is an element of `s` having the same prefix of length `n` as `x`. If there is no such `n`, use `0` by convention.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "and",
    "statement": "structure and (a b : Prop) : Prop",
    "theorem": "(a b : Prop) : Prop",
    "args": "(a b : Prop)",
    "doc_string": "Logical and.  `and P Q`, with notation `P ∧ Q`, is the `Prop` which is true precisely when `P` and `Q` are both true.  To prove a goal `⊢ P ∧ Q`, you can use the tactic `split`, which gives two separate goals `⊢ P` and `⊢ Q`.  Given a hypothesis `h : P ∧ Q`, you can use the tactic `cases h with hP hQ` to obtain two new hypotheses `hP : P` and `hQ : Q`. See also the `obtain` or `rcases` tactics in mathlib.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordinal.opow_le_iff_le_log",
    "statement": "theorem ordinal.opow_le_iff_le_log {b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c ≤ x ↔ c ≤ ordinal.log b x",
    "theorem": "{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c ≤ x ↔ c ≤ ordinal.log b x",
    "args": "{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x)",
    "doc_string": "`opow b` and `log b` (almost) form a Galois connection.",
    "kind": "theorem",
    "type": "b ^ c ≤ x ↔ c ≤ ordinal.log b x"
  },
  {
    "name": "is_normal_add_subgroup",
    "statement": "structure is_normal_add_subgroup {A : Type u_3} [add_group A] (s : set A) : Prop",
    "theorem": "{A : Type u_3} [add_group A] (s : set A) : Prop",
    "args": "{A : Type u_3} [add_group A] (s : set A)",
    "doc_string": " `is_normal_add_subgroup (s : set A)` expresses the fact that `s` is a normal additive subgroup of the additive group `A`. Important: the preferred way to say this in Lean is via bundled subgroups `S : add_subgroup A` and `hs : S.normal`, and not via this structure.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "fin_injective",
    "statement": "theorem fin_injective  : function.injective fin",
    "theorem": " : function.injective fin",
    "args": "",
    "doc_string": " `fin` as a map from `ℕ` to `Type` is injective. Note that since this is a statement about equality of types, using it should be avoided if possible.",
    "kind": "theorem",
    "type": "function.injective fin"
  },
  {
    "name": "add_con.prod",
    "statement": "def add_con.prod {M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (d : add_con N) : add_con (M × N)",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (d : add_con N) : add_con (M × N)",
    "args": "{M : Type u_1} {N : Type u_2} [has_add M] [has_add N] (c : add_con M) (d : add_con N)",
    "doc_string": "Given types with additions `M, N`, the product of two congruence relations `c` on `M` and `d` on `N`: `(x₁, x₂), (y₁, y₂) ∈ M × N` are related by `c.prod d` iff `x₁` is related to `y₁` by `c` and `x₂` is related to `y₂` by `d`.",
    "kind": "def",
    "type": "add_con (M × N)"
  },
  {
    "name": "list.take'",
    "statement": "def list.take' {α : Type u_1} [inhabited α] (n : ℕ) : list α → list α",
    "theorem": "{α : Type u_1} [inhabited α] (n : ℕ) : list α → list α",
    "args": "{α : Type u_1} [inhabited α] (n : ℕ)",
    "doc_string": " Take `n` elements from a list `l`. If `l` has less than `n` elements, append `n - length l` elements `default`.",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "con.mk'_ker",
    "statement": "theorem con.mk'_ker {M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c",
    "theorem": "{M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c",
    "args": "{M : Type u_1} [mul_one_class M] (c : con M)",
    "doc_string": "The kernel of the natural homomorphism from a monoid to its quotient by a congruence    relation `c` equals `c`.",
    "kind": "theorem",
    "type": "con.ker c.mk' = c"
  },
  {
    "name": "vector_span",
    "statement": "def vector_span (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : submodule k V",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : submodule k V",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P)",
    "doc_string": " The submodule spanning the differences of a (possibly empty) set of points.",
    "kind": "def",
    "type": "submodule k V"
  },
  {
    "name": "ordered_comm_ring",
    "statement": "structure ordered_comm_ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " An `ordered_comm_ring α` is a commutative ring `α` with a partial order such that addition is monotone and multiplication by a positive number is strictly monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "matrix.trace",
    "statement": "def matrix.trace {n : Type u_3} {R : Type u_6} [fintype n] [add_comm_monoid R] (A : matrix n n R) : R",
    "theorem": "{n : Type u_3} {R : Type u_6} [fintype n] [add_comm_monoid R] (A : matrix n n R) : R",
    "args": "{n : Type u_3} {R : Type u_6} [fintype n] [add_comm_monoid R] (A : matrix n n R)",
    "doc_string": " The trace of a square matrix. For more bundled versions, see: * `matrix.trace_add_monoid_hom` * `matrix.trace_linear_map`",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "map_cluster_pt",
    "statement": "def map_cluster_pt {α : Type u} [topological_space α] {ι : Type u_1} (x : α) (F : filter ι) (u : ι → α) : Prop",
    "theorem": "{α : Type u} [topological_space α] {ι : Type u_1} (x : α) (F : filter ι) (u : ι → α) : Prop",
    "args": "{α : Type u} [topological_space α] {ι : Type u_1} (x : α) (F : filter ι) (u : ι → α)",
    "doc_string": " A point `x` is a cluster point of a sequence `u` along a filter `F` if it is a cluster point of `map u F`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "opens.grothendieck_topology",
    "statement": "def opens.grothendieck_topology (T : Type u) [topological_space T] : category_theory.grothendieck_topology (topological_space.opens T)",
    "theorem": "(T : Type u) [topological_space T] : category_theory.grothendieck_topology (topological_space.opens T)",
    "args": "(T : Type u) [topological_space T]",
    "doc_string": "The Grothendieck topology associated to a topological space.",
    "kind": "def",
    "type": "category_theory.grothendieck_topology (topological_space.opens T)"
  },
  {
    "name": "tactic.decl_reducibility",
    "statement": "inductive tactic.decl_reducibility  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Possible reducibility attributes for a declaration: reducible, semireducible (the default), irreducible.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "submodule.to_add_subgroup",
    "statement": "def submodule.to_add_subgroup {R : Type u} {M : Type v} [ring R] [add_comm_group M] {module_M : module R M} (p : submodule R M) : add_subgroup M",
    "theorem": "{R : Type u} {M : Type v} [ring R] [add_comm_group M] {module_M : module R M} (p : submodule R M) : add_subgroup M",
    "args": "{R : Type u} {M : Type v} [ring R] [add_comm_group M] {module_M : module R M} (p : submodule R M)",
    "doc_string": "Reinterpret a submodule as an additive subgroup.",
    "kind": "def",
    "type": "add_subgroup M"
  },
  {
    "name": "pmf.uniform_of_fintype",
    "statement": "def pmf.uniform_of_fintype (α : Type u_1) [fintype α] [nonempty α] : pmf α",
    "theorem": "(α : Type u_1) [fintype α] [nonempty α] : pmf α",
    "args": "(α : Type u_1) [fintype α] [nonempty α]",
    "doc_string": "The uniform pmf taking the same uniform value on all of the fintype `α`",
    "kind": "def",
    "type": "pmf α"
  },
  {
    "name": "seq_continuous",
    "statement": "def seq_continuous {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y) : Prop",
    "theorem": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y) : Prop",
    "args": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] (f : X → Y)",
    "doc_string": "A function between topological spaces is sequentially continuous if it commutes with limit of convergent sequences.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "measure_theory.stopped_process",
    "statement": "def measure_theory.stopped_process {α : Type u_1} {β : Type u_2} {ι : Type u_3} [linear_order ι] (u : ι → α → β) (τ : α → ι) : ι → α → β",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} [linear_order ι] (u : ι → α → β) (τ : α → ι) : ι → α → β",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_3} [linear_order ι] (u : ι → α → β) (τ : α → ι)",
    "doc_string": " Given a map `u : ι → α → E`, the stopped process with respect to `τ` is `u i x` if `i ≤ τ x`, and `u (τ x) x` otherwise.  Intuitively, the stopped process stops evolving once the stopping time has occured.",
    "kind": "def",
    "type": "ι → α → β"
  },
  {
    "name": "subgroup.center",
    "statement": "def subgroup.center (G : Type u_1) [group G] : subgroup G",
    "theorem": "(G : Type u_1) [group G] : subgroup G",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "The center of a group `G` is the set of elements that commute with everything in `G`",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "pi.has_continuous_inv'",
    "statement": "def pi.has_continuous_inv' {G : Type w} [topological_space G] [has_inv G] [has_continuous_inv G] {ι : Type u_1} : has_continuous_inv (ι → G)",
    "theorem": "{G : Type w} [topological_space G] [has_inv G] [has_continuous_inv G] {ι : Type u_1} : has_continuous_inv (ι → G)",
    "args": "{G : Type w} [topological_space G] [has_inv G] [has_continuous_inv G] {ι : Type u_1}",
    "doc_string": " A version of `pi.has_continuous_inv` for non-dependent functions. It is needed because sometimes Lean fails to use `pi.has_continuous_inv` for non-dependent functions.",
    "kind": "def",
    "type": "has_continuous_inv (ι → G)"
  },
  {
    "name": "parser.nat",
    "statement": "def parser.nat  : parser ℕ",
    "theorem": " : parser ℕ",
    "args": "",
    "doc_string": " Matches a natural number. Large numbers may cause performance issues, so don't run this parser on untrusted input.",
    "kind": "def",
    "type": "parser ℕ"
  },
  {
    "name": "list.nat.mem_antidiagonal",
    "statement": "theorem list.nat.mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n",
    "theorem": "{n : ℕ} {x : ℕ × ℕ} : x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n",
    "args": "{n : ℕ} {x : ℕ × ℕ}",
    "doc_string": "A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`.",
    "kind": "theorem",
    "type": "x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n"
  },
  {
    "name": "complete_lattice.is_compact_element",
    "statement": "def complete_lattice.is_compact_element {α : Type u_1} [complete_lattice α] (k : α) : Prop",
    "theorem": "{α : Type u_1} [complete_lattice α] (k : α) : Prop",
    "args": "{α : Type u_1} [complete_lattice α] (k : α)",
    "doc_string": " An element `k` of a complete lattice is said to be compact if any set with `Sup` above `k` has a finite subset with `Sup` above `k`.  Such an element is also called \"finite\" or \"S-compact\".",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.pairwise",
    "statement": "inductive category_theory.pairwise (ι : Type v) : Type v",
    "theorem": "(ι : Type v) : Type v",
    "args": "(ι : Type v)",
    "doc_string": "An inductive type representing either a single term of a type `ι`, or a pair of terms. We use this as the objects of a category to describe the sheaf condition.",
    "kind": "inductive",
    "type": "Type v"
  },
  {
    "name": "matrix.fin.circulant_ite",
    "statement": "theorem matrix.fin.circulant_ite (α : Type u_1) [has_zero α] [has_one α] (n : ℕ) : matrix.circulant (λ (i : fin n), ite (↑i = 0) 1 0) = 1",
    "theorem": "(α : Type u_1) [has_zero α] [has_one α] (n : ℕ) : matrix.circulant (λ (i : fin n), ite (↑i = 0) 1 0) = 1",
    "args": "(α : Type u_1) [has_zero α] [has_one α] (n : ℕ)",
    "doc_string": " Note we use `↑i = 0` instead of `i = 0` as `fin 0` has no `0`. This means that we cannot state this with `pi.single` as we did with `matrix.circulant_single`.",
    "kind": "theorem",
    "type": "matrix.circulant (λ (i : fin n), ite (↑i = 0) 1 0) = 1"
  },
  {
    "name": "vm_local_info",
    "statement": "structure vm_local_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Information for local variables and arguments on the VM stack.   Remark: type is only available if it is a closed term at compilation time.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "sq",
    "statement": "theorem sq {M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "theorem": "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a",
    "args": "{M : Type u} [monoid M] (a : M)",
    "doc_string": "**Alias** of pow_two`.",
    "kind": "theorem",
    "type": "a ^ 2 = a * a"
  },
  {
    "name": "has_sup",
    "statement": "structure has_sup (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Typeclass for the `⊔` (`\\lub`) notation",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "subsemigroup.centralizer",
    "statement": "def subsemigroup.centralizer {M : Type u_1} (S : set M) [semigroup M] : subsemigroup M",
    "theorem": "{M : Type u_1} (S : set M) [semigroup M] : subsemigroup M",
    "args": "{M : Type u_1} (S : set M) [semigroup M]",
    "doc_string": "The centralizer of a subset of a semigroup `M`.",
    "kind": "def",
    "type": "subsemigroup M"
  },
  {
    "name": "module.End.has_eigenvalue",
    "statement": "def module.End.has_eigenvalue {R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (a : R) : Prop",
    "theorem": "{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (a : R) : Prop",
    "args": "{R : Type v} {M : Type w} [comm_ring R] [add_comm_group M] [module R M] (f : module.End R M) (a : R)",
    "doc_string": "A scalar `μ` is an eigenvalue for a linear map `f` if there are nonzero vectors `x`    such that `f x = μ • x`. (Def 5.5 of [axler2015])",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "order.ideal.order_bot",
    "statement": "def order.ideal.order_bot {P : Type u_1} [preorder P] [order_bot P] : order_bot (order.ideal P)",
    "theorem": "{P : Type u_1} [preorder P] [order_bot P] : order_bot (order.ideal P)",
    "args": "{P : Type u_1} [preorder P] [order_bot P]",
    "doc_string": "There is a bottom ideal when `P` has a bottom element.",
    "kind": "def",
    "type": "order_bot (order.ideal P)"
  },
  {
    "name": "category_theory.normal_mono_category.has_equalizers",
    "statement": "def category_theory.normal_mono_category.has_equalizers {C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] : category_theory.limits.has_equalizers C",
    "theorem": "{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C] : category_theory.limits.has_equalizers C",
    "args": "{C : Type u_1} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_kernels C] [category_theory.normal_mono_category C]",
    "doc_string": "A `normal_mono_category` category with finite products and kernels has all equalizers.",
    "kind": "def",
    "type": "category_theory.limits.has_equalizers C"
  },
  {
    "name": "ordnode.foldl",
    "statement": "def ordnode.foldl {α : Type u} {β : Sort u_1} (f : β → α → β) : β → ordnode α → β",
    "theorem": "{α : Type u} {β : Sort u_1} (f : β → α → β) : β → ordnode α → β",
    "args": "{α : Type u} {β : Sort u_1} (f : β → α → β)",
    "doc_string": "O(n). Fold a function from left to right (in increasing order) across the tree.      foldl f z {1, 2, 4} = f (f (f z 1) 2) 4",
    "kind": "def",
    "type": "β → ordnode α → β"
  },
  {
    "name": "strict_anti",
    "statement": "def strict_anti {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β)",
    "doc_string": "A function `f` is strictly antitone if `a < b` implies `f b < f a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.right_inverse",
    "statement": "def function.right_inverse {α : Sort u₁} {β : Sort u₂} (g : β → α) (f : α → β) : Prop",
    "theorem": "{α : Sort u₁} {β : Sort u₂} (g : β → α) (f : α → β) : Prop",
    "args": "{α : Sort u₁} {β : Sort u₂} (g : β → α) (f : α → β)",
    "doc_string": "`right_inverse g f` means that g is a right inverse to f. That is, `f ∘ g = id`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_colimits_of_size_shrink",
    "statement": "theorem category_theory.limits.has_colimits_of_size_shrink (C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C]",
    "doc_string": "`has_colimits_of_size_shrink.{v u} C` tries to obtain `has_colimits_of_size.{v u} C` from some other `has_colimits_of_size C`.",
    "kind": "theorem",
    "type": "category_theory.limits.has_colimits_of_size C"
  },
  {
    "name": "t2_space",
    "statement": "structure t2_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A T₂ space, also known as a Hausdorff space, is one in which for every  `x ≠ y` there exists disjoint open sets around `x` and `y`. This is  the most widely used of the separation axioms.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "list.merge",
    "statement": "def list.merge {α : Type uu} (r : α → α → Prop) [decidable_rel r] : list α → list α → list α",
    "theorem": "{α : Type uu} (r : α → α → Prop) [decidable_rel r] : list α → list α → list α",
    "args": "{α : Type uu} (r : α → α → Prop) [decidable_rel r]",
    "doc_string": "Merge two sorted lists into one in linear time.      merge [1, 2, 4, 5] [0, 1, 3, 4] = [0, 1, 1, 2, 3, 4, 4, 5]",
    "kind": "def",
    "type": "list α → list α → list α"
  },
  {
    "name": "denumerable.plift",
    "statement": "def denumerable.plift {α : Type u_1} [denumerable α] : denumerable (plift α)",
    "theorem": "{α : Type u_1} [denumerable α] : denumerable (plift α)",
    "args": "{α : Type u_1} [denumerable α]",
    "doc_string": "The lift of a denumerable type is denumerable.",
    "kind": "def",
    "type": "denumerable (plift α)"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts",
    "statement": "structure category_theory.limits.has_binary_biproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C]",
    "doc_string": "`has_binary_biproducts C` represents the existence of a bicone which is simultaneously a limit and a colimit of the diagram `pair P Q`, for every `P Q : C`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "enat.card",
    "statement": "def enat.card (α : Type u_1) : enat",
    "theorem": "(α : Type u_1) : enat",
    "args": "(α : Type u_1)",
    "doc_string": "`enat.card α` is the cardinality of `α` as an extended natural number.  If `α` is infinite, `enat.card α = ⊤`.",
    "kind": "def",
    "type": "enat"
  },
  {
    "name": "prod.normed_algebra",
    "statement": "def prod.normed_algebra (𝕜 : Type u_5) [normed_field 𝕜] {E : Type u_1} {F : Type u_2} [semi_normed_ring E] [semi_normed_ring F] [normed_algebra 𝕜 E] [normed_algebra 𝕜 F] : normed_algebra 𝕜 (E × F)",
    "theorem": "(𝕜 : Type u_5) [normed_field 𝕜] {E : Type u_1} {F : Type u_2} [semi_normed_ring E] [semi_normed_ring F] [normed_algebra 𝕜 E] [normed_algebra 𝕜 F] : normed_algebra 𝕜 (E × F)",
    "args": "(𝕜 : Type u_5) [normed_field 𝕜] {E : Type u_1} {F : Type u_2} [semi_normed_ring E] [semi_normed_ring F] [normed_algebra 𝕜 E] [normed_algebra 𝕜 F]",
    "doc_string": "The product of two normed algebras is a normed algebra, with the sup norm.",
    "kind": "def",
    "type": "normed_algebra 𝕜 (E × F)"
  },
  {
    "name": "onote.NF",
    "statement": "structure onote.NF (o : onote) : Prop",
    "theorem": "(o : onote) : Prop",
    "args": "(o : onote)",
    "doc_string": "A normal form ordinal notation has the form      ω ^ a₁ * n₁ + ω ^ a₂ * n₂ + ... ω ^ aₖ * nₖ  where `a₁ > a₂ > ... > aₖ` and all the `aᵢ` are  also in normal form.   We will essentially only be interested in normal form  ordinal notations, but to avoid complicating the algorithms  we define everything over general ordinal notations and  only prove correctness with normal form as an invariant.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "wseq.of_seq",
    "statement": "def wseq.of_seq {α : Type u} : seq α → wseq α",
    "theorem": "{α : Type u} : seq α → wseq α",
    "args": "{α : Type u}",
    "doc_string": "Turn a sequence into a weak sequence",
    "kind": "def",
    "type": "seq α → wseq α"
  },
  {
    "name": "field.closure",
    "statement": "def field.closure {F : Type u_1} [field F] (S : set F) : set F",
    "theorem": "{F : Type u_1} [field F] (S : set F) : set F",
    "args": "{F : Type u_1} [field F] (S : set F)",
    "doc_string": "`field.closure s` is the minimal subfield that includes `s`.",
    "kind": "def",
    "type": "set F"
  },
  {
    "name": "category_theory.right_lifting_subcat",
    "statement": "def category_theory.right_lifting_subcat (R : Type u) : Type u",
    "theorem": "(R : Type u) : Type u",
    "args": "(R : Type u)",
    "doc_string": " The objects of the subcategory `right_lifting_subcategory` are the ones in the underlying category.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "nonpos_of_neg_nonneg",
    "statement": "theorem nonpos_of_neg_nonneg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a → a ≤ 0",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a → a ≤ 0",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.one_le_inv_iff`.",
    "kind": "theorem",
    "type": "0 ≤ -a → a ≤ 0"
  },
  {
    "name": "polish_space.is_clopenable",
    "statement": "def polish_space.is_clopenable {α : Type u_1} [t : topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u_1} [t : topological_space α] (s : set α) : Prop",
    "args": "{α : Type u_1} [t : topological_space α] (s : set α)",
    "doc_string": " A set in a topological space is clopenable if there exists a finer Polish topology for which this set is open and closed. It turns out that this notion is equivalent to being Borel-measurable, but this is nontrivial (see `is_clopenable_iff_measurable_set`).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "inf_top_hom",
    "statement": "structure inf_top_hom (α : Type u_7) (β : Type u_8) [has_inf α] [has_inf β] [has_top α] [has_top β] : Type (max u_7 u_8)",
    "theorem": "(α : Type u_7) (β : Type u_8) [has_inf α] [has_inf β] [has_top α] [has_top β] : Type (max u_7 u_8)",
    "args": "(α : Type u_7) (β : Type u_8) [has_inf α] [has_inf β] [has_top α] [has_top β]",
    "doc_string": "The type of finitary infimum-preserving homomorphisms from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8)"
  },
  {
    "name": "subring.zero_mem",
    "statement": "theorem subring.zero_mem {R : Type u} [ring R] (s : subring R) : 0 ∈ s",
    "theorem": "{R : Type u} [ring R] (s : subring R) : 0 ∈ s",
    "args": "{R : Type u} [ring R] (s : subring R)",
    "doc_string": "A subring contains the ring's 0.",
    "kind": "theorem",
    "type": "0 ∈ s"
  },
  {
    "name": "ratfunc.one",
    "statement": "def ratfunc.one {K : Type u} [hring : comm_ring K] : ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] : ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K]",
    "doc_string": "The multiplicative unit of rational functions.",
    "kind": "def",
    "type": "ratfunc K"
  },
  {
    "name": "affine_subspace.bot_coe",
    "statement": "theorem affine_subspace.bot_coe (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊥ = ∅",
    "theorem": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊥ = ∅",
    "args": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P]",
    "doc_string": "`⊥`, coerced to a set, is the empty set.",
    "kind": "theorem",
    "type": "↑⊥ = ∅"
  },
  {
    "name": "dvd_of_mul_left_eq",
    "statement": "theorem dvd_of_mul_left_eq {α : Type u_1} [comm_semigroup α] {a b : α} (c : α) (h : c * a = b) : a ∣ b",
    "theorem": "{α : Type u_1} [comm_semigroup α] {a b : α} (c : α) (h : c * a = b) : a ∣ b",
    "args": "{α : Type u_1} [comm_semigroup α] {a b : α} (c : α) (h : c * a = b)",
    "doc_string": "**Alias** of dvd.intro_left`.",
    "kind": "theorem",
    "type": "a ∣ b"
  },
  {
    "name": "turing.TM2to1.Γ'",
    "statement": "def turing.TM2to1.Γ' {K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} : Type (max u_1 u_2)",
    "theorem": "{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2} : Type (max u_1 u_2)",
    "args": "{K : Type u_1} [decidable_eq K] {Γ : K → Type u_2}",
    "doc_string": " The alphabet of the TM2 simulator on TM1 is a marker for the stack bottom, plus a vector of stack elements for each stack, or none if the stack does not extend this far.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "homeomorph",
    "statement": "structure homeomorph (α : Type u_5) (β : Type u_6) [topological_space α] [topological_space β] : Type (max u_5 u_6)",
    "theorem": "(α : Type u_5) (β : Type u_6) [topological_space α] [topological_space β] : Type (max u_5 u_6)",
    "args": "(α : Type u_5) (β : Type u_6) [topological_space α] [topological_space β]",
    "doc_string": "Homeomorphism between `α` and `β`, also called topological isomorphism",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "lazy_list.find",
    "statement": "def lazy_list.find {α : Type u_1} (p : α → Prop) [decidable_pred p] : lazy_list α → option α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] : lazy_list α → option α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p]",
    "doc_string": " Return the first object contained in the list that satisfies predicate `p`",
    "kind": "def",
    "type": "lazy_list α → option α"
  },
  {
    "name": "semiconj_by.one_left",
    "statement": "theorem semiconj_by.one_left {M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x",
    "theorem": "{M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x",
    "args": "{M : Type u} [mul_one_class M] (x : M)",
    "doc_string": "One semiconjugates any element to itself.",
    "kind": "theorem",
    "type": "semiconj_by 1 x x"
  },
  {
    "name": "zero_lt.right.mul_lt_one_of_le_of_lt",
    "statement": "theorem zero_lt.right.mul_lt_one_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "is_spectral_map",
    "statement": "structure is_spectral_map {α : Type u_2} {β : Type u_3} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_2} {β : Type u_3} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "args": "{α : Type u_2} {β : Type u_3} [topological_space α] [topological_space β] (f : α → β)",
    "doc_string": " A function between topological spaces is spectral if it is continuous and the preimage of every compact open set is compact open.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "order_embedding",
    "statement": "def order_embedding (α : Type u_1) (β : Type u_2) [has_le α] [has_le β] : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (β : Type u_2) [has_le α] [has_le β] : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (β : Type u_2) [has_le α] [has_le β]",
    "doc_string": " An order embedding is an embedding `f : α ↪ β` such that `a ≤ b ↔ (f a) ≤ (f b)`. This definition is an abbreviation of `rel_embedding (≤) (≤)`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "valuation.subgroups_basis",
    "statement": "theorem valuation.subgroups_basis {R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : ring_subgroups_basis (λ (γ : Γ₀ˣ), v.lt_add_subgroup γ)",
    "theorem": "{R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : ring_subgroups_basis (λ (γ : Γ₀ˣ), v.lt_add_subgroup γ)",
    "args": "{R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀)",
    "doc_string": "The basis of open subgroups for the topology on a ring determined by a valuation.",
    "kind": "theorem",
    "type": "ring_subgroups_basis (λ (γ : Γ₀ˣ), v.lt_add_subgroup γ)"
  },
  {
    "name": "inseparable.nhds_eq",
    "statement": "theorem inseparable.nhds_eq {X : Type u_1} [topological_space X] {x y : X} : inseparable x y → nhds x = nhds y",
    "theorem": "{X : Type u_1} [topological_space X] {x y : X} : inseparable x y → nhds x = nhds y",
    "args": "{X : Type u_1} [topological_space X] {x y : X}",
    "doc_string": "**Alias** of the forward direction of inseparable_iff_nhds_eq`.",
    "kind": "theorem",
    "type": "inseparable x y → nhds x = nhds y"
  },
  {
    "name": "d_array",
    "statement": "structure d_array (n : ℕ) (α : fin n → Type u) : Type u",
    "theorem": "(n : ℕ) (α : fin n → Type u) : Type u",
    "args": "(n : ℕ) (α : fin n → Type u)",
    "doc_string": "In the VM, d_array is implemented as a persistent array.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "name.pop_nth_prefix",
    "statement": "def name.pop_nth_prefix (nm : name) (n : ℕ) : name",
    "theorem": "(nm : name) (n : ℕ) : name",
    "args": "(nm : name) (n : ℕ)",
    "doc_string": "Pops the top `n` prefixes from the given name.",
    "kind": "def",
    "type": "name"
  },
  {
    "name": "array.foreach",
    "statement": "def array.foreach {n : ℕ} {α : Type u} {β : Type v} (a : array n α) (f : fin n → α → β) : array n β",
    "theorem": "{n : ℕ} {α : Type u} {β : Type v} (a : array n α) (f : fin n → α → β) : array n β",
    "args": "{n : ℕ} {α : Type u} {β : Type v} (a : array n α) (f : fin n → α → β)",
    "doc_string": "Map each element of the given array with an index argument.",
    "kind": "def",
    "type": "array n β"
  },
  {
    "name": "finsum",
    "statement": "def finsum {M : Type u_1} {α : Sort u_2} [add_comm_monoid M] (f : α → M) : M",
    "theorem": "{M : Type u_1} {α : Sort u_2} [add_comm_monoid M] (f : α → M) : M",
    "args": "{M : Type u_1} {α : Sort u_2} [add_comm_monoid M] (f : α → M)",
    "doc_string": " Sum of `f x` as `x` ranges over the elements of the support of `f`, if it's finite. Zero otherwise.",
    "kind": "def",
    "type": "M"
  },
  {
    "name": "computation.lift_rel",
    "statement": "def computation.lift_rel {α : Type u} {β : Type v} (R : α → β → Prop) (ca : computation α) (cb : computation β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (R : α → β → Prop) (ca : computation α) (cb : computation β) : Prop",
    "args": "{α : Type u} {β : Type v} (R : α → β → Prop) (ca : computation α) (cb : computation β)",
    "doc_string": "`lift_rel R ca cb` is a generalization of `equiv` to relations other than  equality. It asserts that if `ca` terminates with `a`, then `cb` terminates with  some `b` such that `R a b`, and if `cb` terminates with `b` then `ca` terminates  with some `a` such that `R a b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lower_central_series",
    "statement": "def lower_central_series (G : Type u_1) [group G] : ℕ → subgroup G",
    "theorem": "(G : Type u_1) [group G] : ℕ → subgroup G",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "The lower central series of a group `G` is a sequence `H n` of subgroups of `G`, defined  by `H 0` is all of `G` and for `n≥1`, `H (n + 1) = ⁅H n, G⁆`",
    "kind": "def",
    "type": "ℕ → subgroup G"
  },
  {
    "name": "has_le.le.eq_or_lt_dec",
    "statement": "theorem has_le.le.eq_or_lt_dec {α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a = b ∨ a < b",
    "theorem": "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a = b ∨ a < b",
    "args": "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b)",
    "doc_string": "**Alias** of decidable.eq_or_lt_of_le`.",
    "kind": "theorem",
    "type": "a = b ∨ a < b"
  },
  {
    "name": "zero_lt.left.mul_pos",
    "statement": "theorem zero_lt.left.mul_pos {α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "0 < a * b"
  },
  {
    "name": "orthonormal.linear_independent",
    "statement": "theorem orthonormal.linear_independent {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) : linear_independent 𝕜 v",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) : linear_independent 𝕜 v",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v)",
    "doc_string": "An orthonormal set is linearly independent.",
    "kind": "theorem",
    "type": "linear_independent 𝕜 v"
  },
  {
    "name": "zero_lt.pos_mul_strict_mono",
    "statement": "def zero_lt.pos_mul_strict_mono (X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop",
    "theorem": "(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop",
    "args": "(X : Type u) [has_mul X] [has_zero X] [has_lt X]",
    "doc_string": "  `zero_lt.pos_mul_strict_mono α` is an abbreviation for `covariant_class α>0 α (λ x y, x * y) (<)`, expressing that multiplication by positive elements on the left is strictly monotone.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "random",
    "statement": "structure random (α : Type u) : Type (max 1 u)",
    "theorem": "(α : Type u) : Type (max 1 u)",
    "args": "(α : Type u)",
    "doc_string": "`random α` gives us machinery to generate values of type `α`",
    "kind": "structure",
    "type": "Type (max 1 u)"
  },
  {
    "name": "transcendental",
    "statement": "def transcendental (R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop",
    "theorem": "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A) : Prop",
    "args": "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] (x : A)",
    "doc_string": "An element of an R-algebra is transcendental over R if it is not algebraic over R.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.differential_object",
    "statement": "structure category_theory.differential_object (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ℤ] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ℤ] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.has_shift C ℤ]",
    "doc_string": "A differential object in a category with zero morphisms and a shift is an object `X` equipped with a morphism `d : X ⟶ X⟦1⟧`, such that `d^2 = 0`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "part.unwrap",
    "statement": "def part.unwrap {α : Type u_1} (o : part α) : α",
    "theorem": "{α : Type u_1} (o : part α) : α",
    "args": "{α : Type u_1} (o : part α)",
    "doc_string": "`unwrap o` gets the value at `o`, ignoring the condition. This function is unsound.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "add_subsemigroup.center",
    "statement": "def add_subsemigroup.center (M : Type u_1) [add_semigroup M] : add_subsemigroup M",
    "theorem": "(M : Type u_1) [add_semigroup M] : add_subsemigroup M",
    "args": "(M : Type u_1) [add_semigroup M]",
    "doc_string": "The center of a semigroup `M` is the set of elements that commute with everything in `M`",
    "kind": "def",
    "type": "add_subsemigroup M"
  },
  {
    "name": "matrix.det_row_alternating",
    "statement": "def matrix.det_row_alternating {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : alternating_map R (n → R) R n",
    "theorem": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] : alternating_map R (n → R) R n",
    "args": "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R]",
    "doc_string": "`det` is an `alternating_map` in the rows of the matrix.",
    "kind": "def",
    "type": "alternating_map R (n → R) R n"
  },
  {
    "name": "Top.presheaf.is_sheaf",
    "statement": "def Top.presheaf.is_sheaf {C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X) : Prop",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] {X : Top} (F : Top.presheaf C X)",
    "doc_string": "The sheaf condition for a `F : presheaf C X` requires that the morphism `F.obj U ⟶ ∏ F.obj (U i)` (where `U` is some open set which is the union of the `U i`) is the equalizer of the two morphisms `∏ F.obj (U i) ⟶ ∏ F.obj (U i) ⊓ (U j)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "equiv.perm.is_swap",
    "statement": "def equiv.perm.is_swap {α : Type u_1} [decidable_eq α] (f : equiv.perm α) : Prop",
    "theorem": "{α : Type u_1} [decidable_eq α] (f : equiv.perm α) : Prop",
    "args": "{α : Type u_1} [decidable_eq α] (f : equiv.perm α)",
    "doc_string": "`f.is_swap` indicates that the permutation `f` is a transposition of two elements.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "norm_cast.label",
    "statement": "inductive norm_cast.label  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "`label` is a type used to classify `norm_cast` lemmas. * elim lemma:   LHS has 0 head coes and ≥ 1 internal coe * move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes * squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "add_opposite",
    "statement": "def add_opposite (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Additive opposite of a type. This type inherits all multiplicative structures on `α` and reverses left and right in addition.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "lie_algebra.orthogonal.type_B",
    "statement": "def lie_algebra.orthogonal.type_B (l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R)",
    "theorem": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l] : lie_subalgebra R (matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R)",
    "args": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] [fintype l]",
    "doc_string": " The classical Lie algebra of type B as a Lie subalgebra of matrices associated to the matrix `JB`.",
    "kind": "def",
    "type": "lie_subalgebra R (matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R)"
  },
  {
    "name": "finset.set.has_coe_t",
    "statement": "def finset.set.has_coe_t {α : Type u_1} : has_coe_t (finset α) (set α)",
    "theorem": "{α : Type u_1} : has_coe_t (finset α) (set α)",
    "args": "{α : Type u_1}",
    "doc_string": "Convert a finset to a set in the natural way.",
    "kind": "def",
    "type": "has_coe_t (finset α) (set α)"
  },
  {
    "name": "dist_nndist",
    "statement": "theorem dist_nndist {α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist x y = ↑(has_nndist.nndist x y)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist x y = ↑(has_nndist.nndist x y)",
    "args": "{α : Type u} [pseudo_metric_space α] (x y : α)",
    "doc_string": "Express `dist` in terms of `nndist`",
    "kind": "theorem",
    "type": "has_dist.dist x y = ↑(has_nndist.nndist x y)"
  },
  {
    "name": "integral_closure",
    "statement": "def integral_closure (R : Type u_1) (A : Type u_2) [comm_ring R] [comm_ring A] [algebra R A] : subalgebra R A",
    "theorem": "(R : Type u_1) (A : Type u_2) [comm_ring R] [comm_ring A] [algebra R A] : subalgebra R A",
    "args": "(R : Type u_1) (A : Type u_2) [comm_ring R] [comm_ring A] [algebra R A]",
    "doc_string": "The integral closure of R in an R-algebra A.",
    "kind": "def",
    "type": "subalgebra R A"
  },
  {
    "name": "set.ord_connected",
    "statement": "structure set.ord_connected {α : Type u_1} [preorder α] (s : set α) : Prop",
    "theorem": "{α : Type u_1} [preorder α] (s : set α) : Prop",
    "args": "{α : Type u_1} [preorder α] (s : set α)",
    "doc_string": "We say that a set `s : set α` is `ord_connected` if for all `x y ∈ s` it includes the interval `[x, y]`. If `α` is a `densely_ordered` `conditionally_complete_linear_order` with the `order_topology`, then this condition is equivalent to `is_preconnected s`. If `α` is a `linear_ordered_field`, then this condition is also equivalent to `convex α s`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "order.succ_order.subsingleton",
    "statement": "def order.succ_order.subsingleton {α : Type u_1} [partial_order α] : subsingleton (succ_order α)",
    "theorem": "{α : Type u_1} [partial_order α] : subsingleton (succ_order α)",
    "args": "{α : Type u_1} [partial_order α]",
    "doc_string": "There is at most one way to define the successors in a `partial_order`.",
    "kind": "def",
    "type": "subsingleton (succ_order α)"
  },
  {
    "name": "subsemigroup.gi",
    "statement": "def subsemigroup.gi (M : Type u_1) [has_mul M] : galois_insertion subsemigroup.closure coe",
    "theorem": "(M : Type u_1) [has_mul M] : galois_insertion subsemigroup.closure coe",
    "args": "(M : Type u_1) [has_mul M]",
    "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
    "kind": "def",
    "type": "galois_insertion subsemigroup.closure coe"
  },
  {
    "name": "encodable.fintype_arrow",
    "statement": "def encodable.fintype_arrow (α : Type u_1) (β : Type u_2) [decidable_eq α] [fintype α] [encodable β] : trunc (encodable (α → β))",
    "theorem": "(α : Type u_1) (β : Type u_2) [decidable_eq α] [fintype α] [encodable β] : trunc (encodable (α → β))",
    "args": "(α : Type u_1) (β : Type u_2) [decidable_eq α] [fintype α] [encodable β]",
    "doc_string": " When `α` is finite and `β` is encodable, `α → β` is encodable too. Because the encoding is not unique, we wrap it in `trunc` to preserve computability.",
    "kind": "def",
    "type": "trunc (encodable (α → β))"
  },
  {
    "name": "subgroup.left_transversals",
    "statement": "def subgroup.left_transversals {G : Type u_1} [group G] (T : set G) : set (set G)",
    "theorem": "{G : Type u_1} [group G] (T : set G) : set (set G)",
    "args": "{G : Type u_1} [group G] (T : set G)",
    "doc_string": "The set of left-complements of `T : set G`",
    "kind": "def",
    "type": "set (set G)"
  },
  {
    "name": "quotient.mk'",
    "statement": "def quotient.mk' {α : Sort u_1} {s₁ : setoid α} (a : α) : quotient s₁",
    "theorem": "{α : Sort u_1} {s₁ : setoid α} (a : α) : quotient s₁",
    "args": "{α : Sort u_1} {s₁ : setoid α} (a : α)",
    "doc_string": " A version of `quotient.mk` taking `{s : setoid α}` as an implicit argument instead of an instance argument.",
    "kind": "def",
    "type": "quotient s₁"
  },
  {
    "name": "interior",
    "statement": "def interior {α : Type u} [topological_space α] (s : set α) : set α",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : set α",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "The interior of a set `s` is the largest open subset of `s`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "valuation_ring.of_discrete_valuation_ring",
    "statement": "def valuation_ring.of_discrete_valuation_ring (A : Type u) [comm_ring A] [is_domain A] [discrete_valuation_ring A] : valuation_ring A",
    "theorem": "(A : Type u) [comm_ring A] [is_domain A] [discrete_valuation_ring A] : valuation_ring A",
    "args": "(A : Type u) [comm_ring A] [is_domain A] [discrete_valuation_ring A]",
    "doc_string": "A DVR is a valuation ring.",
    "kind": "def",
    "type": "valuation_ring A"
  },
  {
    "name": "ordinal.is_equivalent",
    "statement": "def ordinal.is_equivalent  : setoid Well_order",
    "theorem": " : setoid Well_order",
    "args": "",
    "doc_string": " Equivalence relation on well orders on arbitrary types in universe `u`, given by order isomorphism.",
    "kind": "def",
    "type": "setoid Well_order"
  },
  {
    "name": "nat.primes",
    "statement": "def nat.primes  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of prime numbers",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "two_pos",
    "statement": "theorem two_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 2",
    "theorem": "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 2",
    "args": "{α : Type u} [ordered_semiring α] [nontrivial α]",
    "doc_string": "**Alias** of zero_lt_two`.",
    "kind": "theorem",
    "type": "0 < 2"
  },
  {
    "name": "tactic.ring_exp.coeff",
    "statement": "structure tactic.ring_exp.coeff  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Coefficients in the expression are stored in a wrapper structure, allowing for easier modification of the data structures. The modifications might be caching of the result of `expr.of_rat`, or using a different meta representation of numerals.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "polynomial.coe_to_power_series",
    "statement": "def polynomial.coe_to_power_series {R : Type u_2} [comm_semiring R] : has_coe (polynomial R) (power_series R)",
    "theorem": "{R : Type u_2} [comm_semiring R] : has_coe (polynomial R) (power_series R)",
    "args": "{R : Type u_2} [comm_semiring R]",
    "doc_string": "The natural inclusion from polynomials into formal power series.",
    "kind": "def",
    "type": "has_coe (polynomial R) (power_series R)"
  },
  {
    "name": "is_submonoid.inter",
    "statement": "theorem is_submonoid.inter {M : Type u_1} [monoid M] {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂) : is_submonoid (s₁ ∩ s₂)",
    "theorem": "{M : Type u_1} [monoid M] {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂) : is_submonoid (s₁ ∩ s₂)",
    "args": "{M : Type u_1} [monoid M] {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂)",
    "doc_string": "The intersection of two submonoids of a monoid `M` is a submonoid of `M`.",
    "kind": "theorem",
    "type": "is_submonoid (s₁ ∩ s₂)"
  },
  {
    "name": "stream.apply",
    "statement": "def stream.apply {α : Type u} {β : Type v} (f : stream (α → β)) (s : stream α) : stream β",
    "theorem": "{α : Type u} {β : Type v} (f : stream (α → β)) (s : stream α) : stream β",
    "args": "{α : Type u} {β : Type v} (f : stream (α → β)) (s : stream α)",
    "doc_string": "Given a stream of functions and a stream of values, apply `n`-th function to `n`-th value.",
    "kind": "def",
    "type": "stream β"
  },
  {
    "name": "chain_closure",
    "statement": "inductive chain_closure {α : Type u_1} (r : α → α → Prop) : set α → Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) : set α → Prop",
    "args": "{α : Type u_1} (r : α → α → Prop)",
    "doc_string": "Predicate for whether a set is reachable from `∅` using `succ_chain` and `⋃₀`.",
    "kind": "inductive",
    "type": "set α → Prop"
  },
  {
    "name": "vm_monitor",
    "statement": "structure vm_monitor (α : Type) : Type",
    "theorem": "(α : Type) : Type",
    "args": "(α : Type)",
    "doc_string": "A Lean VM monitor. Monitors are registered using the [vm_monitor] attribute.     If option 'debugger' is true, then the VM will initialize the vm_monitor state using the    'init' field, and will invoke the function 'step' before each instruction is invoked.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "eq_zero_of_mul_eq_self_left",
    "statement": "theorem eq_zero_of_mul_eq_self_left {M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a) : a = 0",
    "theorem": "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a) : a = 0",
    "args": "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a)",
    "doc_string": " An element of a `cancel_monoid_with_zero` fixed by left multiplication by an element other than one must be zero.",
    "kind": "theorem",
    "type": "a = 0"
  },
  {
    "name": "is_R_or_C.inner_product_space",
    "statement": "def is_R_or_C.inner_product_space {𝕜 : Type u_1} [is_R_or_C 𝕜] : inner_product_space 𝕜 𝕜",
    "theorem": "{𝕜 : Type u_1} [is_R_or_C 𝕜] : inner_product_space 𝕜 𝕜",
    "args": "{𝕜 : Type u_1} [is_R_or_C 𝕜]",
    "doc_string": "A field `𝕜` satisfying `is_R_or_C` is itself a `𝕜`-inner product space.",
    "kind": "def",
    "type": "inner_product_space 𝕜 𝕜"
  },
  {
    "name": "right.inv_le_one_iff",
    "statement": "theorem right.inv_le_one_iff {α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "kind": "theorem",
    "type": "a⁻¹ ≤ 1 ↔ 1 ≤ a"
  },
  {
    "name": "finite_dimensional.finrank_zero_iff",
    "statement": "theorem finite_dimensional.finrank_zero_iff {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": " A finite dimensional space has zero `finrank` iff it is a subsingleton. This is the `finrank` version of `dim_zero_iff`.",
    "kind": "theorem",
    "type": "finite_dimensional.finrank K V = 0 ↔ subsingleton V"
  },
  {
    "name": "function.commute",
    "statement": "def function.commute {α : Type u_1} (f g : α → α) : Prop",
    "theorem": "{α : Type u_1} (f g : α → α) : Prop",
    "args": "{α : Type u_1} (f g : α → α)",
    "doc_string": " Two maps `f g : α → α` commute if `f (g x) = g (f x)` for all `x : α`. Given `h : function.commute f g` and `a : α`, we have `h a : f (g a) = g (f a)` and `h.comp_eq : f ∘ g = g ∘ f`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "monoid_algebra.fg_of_finite_type",
    "statement": "theorem monoid_algebra.fg_of_finite_type {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M",
    "args": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)]",
    "doc_string": "If `monoid_algebra R M` is of finite type then `M` is finitely generated.",
    "kind": "theorem",
    "type": "monoid.fg M"
  },
  {
    "name": "is_simple_order.linear_order",
    "statement": "def is_simple_order.linear_order {α : Type u_1} [partial_order α] [bounded_order α] [is_simple_order α] [decidable_eq α] : linear_order α",
    "theorem": "{α : Type u_1} [partial_order α] [bounded_order α] [is_simple_order α] [decidable_eq α] : linear_order α",
    "args": "{α : Type u_1} [partial_order α] [bounded_order α] [is_simple_order α] [decidable_eq α]",
    "doc_string": " A simple partial ordered `bounded_order` induces a linear order. This is not an instance to prevent loops.",
    "kind": "def",
    "type": "linear_order α"
  },
  {
    "name": "two_pointing.sum",
    "statement": "def two_pointing.sum {α : Type u_1} {β : Type u_2} (p : two_pointing α) (q : two_pointing β) : two_pointing (α ⊕ β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (p : two_pointing α) (q : two_pointing β) : two_pointing (α ⊕ β)",
    "args": "{α : Type u_1} {β : Type u_2} (p : two_pointing α) (q : two_pointing β)",
    "doc_string": " The sum of two pointings. Keeps the first point from the left and the second point from the right.",
    "kind": "def",
    "type": "two_pointing (α ⊕ β)"
  },
  {
    "name": "ulift.pure",
    "statement": "def ulift.pure {α : Type u} : α → ulift α",
    "theorem": "{α : Type u} : α → ulift α",
    "args": "{α : Type u}",
    "doc_string": "Embedding of pure values.",
    "kind": "def",
    "type": "α → ulift α"
  },
  {
    "name": "ordnode.insert_min",
    "statement": "def ordnode.insert_min {α : Type u} (x : α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} (x : α) : ordnode α → ordnode α",
    "args": "{α : Type u} (x : α)",
    "doc_string": " O(log n). Insert an element below all the others, without any comparisons. (Assumes that the element is in fact below all the others).      insert_min {1, 2} 0 = {0, 1, 2}     insert_min {1, 2} 4 = precondition violation",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "principal_seg",
    "statement": "structure principal_seg {α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "theorem": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "args": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop)",
    "doc_string": " If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≺i s` is an order embedding whose range is an open interval `(-∞, top)` for some element `top` of `β`. Such order embeddings are called principal segments",
    "kind": "structure",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "cardinal.is_limit",
    "statement": "def cardinal.is_limit (c : cardinal) : Prop",
    "theorem": "(c : cardinal) : Prop",
    "args": "(c : cardinal)",
    "doc_string": "A cardinal is a limit if it is not zero or a successor  cardinal. Note that `ℵ₀` is a limit cardinal by this definition.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "has_scalar",
    "statement": "structure has_scalar (M : Type u_1) (α : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(M : Type u_1) (α : Type u_2) : Type (max u_1 u_2)",
    "args": "(M : Type u_1) (α : Type u_2)",
    "doc_string": "Typeclass for types with a scalar multiplication operation, denoted `•` (`\\bu`)",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "many_one_equiv",
    "statement": "def many_one_equiv {α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop)",
    "doc_string": "`p` and `q` are many-one equivalent if each one is many-one reducible to the other.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "right.add_pos",
    "statement": "theorem right.add_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_pos`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "category_theory.bicone",
    "statement": "inductive category_theory.bicone (J : Type u₁) : Type u₁",
    "theorem": "(J : Type u₁) : Type u₁",
    "args": "(J : Type u₁)",
    "doc_string": "Given a category `J`, construct a walking `bicone J` by adjoining two elements.",
    "kind": "inductive",
    "type": "Type u₁"
  },
  {
    "name": "metric.inf_dist_zero_of_mem",
    "statement": "theorem metric.inf_dist_zero_of_mem {α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s)",
    "doc_string": "The minimal distance of a point to a set containing it vanishes",
    "kind": "theorem",
    "type": "metric.inf_dist x s = 0"
  },
  {
    "name": "algebra.trace_matrix",
    "statement": "def algebra.trace_matrix {κ : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] (b : κ → B) : matrix κ κ A",
    "theorem": "{κ : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] (b : κ → B) : matrix κ κ A",
    "args": "{κ : Type w} (A : Type u) {B : Type v} [comm_ring A] [comm_ring B] [algebra A B] (b : κ → B)",
    "doc_string": " Given an `A`-algebra `B` and `b`, an `κ`-indexed family of elements of `B`, we define `trace_matrix A b` as the matrix whose `(i j)`-th element is the trace of `b i * b j`.",
    "kind": "def",
    "type": "matrix κ κ A"
  },
  {
    "name": "BoundedDistribLattice",
    "statement": "structure BoundedDistribLattice  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of bounded distributive lattices with bounded lattice morphisms.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "Ab",
    "statement": "def Ab  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "`Ab` is an abbreviation for `AddCommGroup`, for the sake of mathematicians' sanity.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "is_add_regular.and_of_add_of_add",
    "statement": "theorem is_add_regular.and_of_add_of_add {R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a ∧ is_add_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a ∧ is_add_regular b",
    "args": "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a))",
    "doc_string": "The \"most used\" implication of `add_and_add_iff`, with split hypotheses, instead of `∧`.",
    "kind": "theorem",
    "type": "is_add_regular a ∧ is_add_regular b"
  },
  {
    "name": "totally_separated_space",
    "statement": "structure totally_separated_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": " A space is totally separated if any two points can be separated by two disjoint open sets covering the whole space.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "submodules_basis",
    "statement": "structure submodules_basis {ι : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [topological_space R] (B : ι → submodule R M) : Prop",
    "theorem": "{ι : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [topological_space R] (B : ι → submodule R M) : Prop",
    "args": "{ι : Type u_1} {R : Type u_2} [comm_ring R] {M : Type u_4} [add_comm_group M] [module R M] [topological_space R] (B : ι → submodule R M)",
    "doc_string": " A family of submodules in an `R`-module `M` is a submodules basis if it satisfies some axioms ensuring there is a topology on `M` which is compatible with the module structure and admits this family as a basis of neighborhoods of zero.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.biproduct",
    "statement": "def category_theory.limits.biproduct {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J → C) [category_theory.limits.has_biproduct f] : C",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J → C) [category_theory.limits.has_biproduct f] : C",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (f : J → C) [category_theory.limits.has_biproduct f]",
    "doc_string": "`biproduct f` computes the biproduct of a family of elements `f`. (It is defined as an   abbreviation for `limit (discrete.functor f)`, so for most facts about `biproduct f`, you will   just use general facts about limits and colimits.)",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "polynomial.coeff",
    "statement": "def polynomial.coeff {R : Type u} [semiring R] : polynomial R → ℕ → R",
    "theorem": "{R : Type u} [semiring R] : polynomial R → ℕ → R",
    "args": "{R : Type u} [semiring R]",
    "doc_string": "`coeff p n` (often denoted `p.coeff n`) is the coefficient of `X^n` in `p`.",
    "kind": "def",
    "type": "polynomial R → ℕ → R"
  },
  {
    "name": "pos_num.divmod_aux",
    "statement": "def pos_num.divmod_aux (d : pos_num) (q r : num) : num × num",
    "theorem": "(d : pos_num) (q r : num) : num × num",
    "args": "(d : pos_num) (q r : num)",
    "doc_string": "Auxiliary definition for `pos_num.divmod`.",
    "kind": "def",
    "type": "num × num"
  },
  {
    "name": "is_antichain",
    "statement": "def is_antichain {α : Type u_1} (r : α → α → Prop) (s : set α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s : set α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (s : set α)",
    "doc_string": "An antichain is a set such that no two distinct elements are related.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "has_sbtw",
    "statement": "structure has_sbtw (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Syntax typeclass for a strict betweenness relation.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "euclidean_domain.gcd_a",
    "statement": "def euclidean_domain.gcd_a {R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R",
    "theorem": "{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R) : R",
    "args": "{R : Type u} [euclidean_domain R] [decidable_eq R] (x y : R)",
    "doc_string": "The extended GCD `a` value in the equation `gcd x y = x * a + y * b`.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "polynomial.mod",
    "statement": "def polynomial.mod {R : Type u} [field R] (p q : polynomial R) : polynomial R",
    "theorem": "{R : Type u} [field R] (p q : polynomial R) : polynomial R",
    "args": "{R : Type u} [field R] (p q : polynomial R)",
    "doc_string": "Remainder of polynomial division. See `polynomial.mod_by_monic` for more details.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "as_fn",
    "statement": "def as_fn  : simps_cfg",
    "theorem": " : simps_cfg",
    "args": "",
    "doc_string": "A common configuration for `@[simps]`: generate equalities between functions instead equalities  between fully applied expressions.",
    "kind": "def",
    "type": "simps_cfg"
  },
  {
    "name": "has_nnnorm",
    "statement": "structure has_nnnorm (E : Type u_6) : Type u_6",
    "theorem": "(E : Type u_6) : Type u_6",
    "args": "(E : Type u_6)",
    "doc_string": "Auxiliary class, endowing a type `α` with a function `nnnorm : α → ℝ≥0` with notation `∥x∥₊`.",
    "kind": "structure",
    "type": "Type u_6"
  },
  {
    "name": "filter.liminf",
    "statement": "def filter.liminf {α : Type u_1} {β : Type u_2} [conditionally_complete_lattice α] (f : filter β) (u : β → α) : α",
    "theorem": "{α : Type u_1} {β : Type u_2} [conditionally_complete_lattice α] (f : filter β) (u : β → α) : α",
    "args": "{α : Type u_1} {β : Type u_2} [conditionally_complete_lattice α] (f : filter β) (u : β → α)",
    "doc_string": " The `liminf` of a function `u` along a filter `f` is the supremum of the `a` such that, eventually for `f`, holds `u x ≥ a`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "is_preconnected",
    "statement": "def is_preconnected {α : Type u} [topological_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : Prop",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "A preconnected set is one where there is no non-trivial open partition.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.floor",
    "statement": "def nat.floor {α : Type u_1} [ordered_semiring α] [floor_semiring α] : α → ℕ",
    "theorem": "{α : Type u_1} [ordered_semiring α] [floor_semiring α] : α → ℕ",
    "args": "{α : Type u_1} [ordered_semiring α] [floor_semiring α]",
    "doc_string": "`⌊a⌋₊` is the greatest natural `n` such that `n ≤ a`. If `a` is negative, then `⌊a⌋₊ = 0`.",
    "kind": "def",
    "type": "α → ℕ"
  },
  {
    "name": "parser.bounded",
    "statement": "structure parser.bounded {α : Type} (p : parser α) : Prop",
    "theorem": "{α : Type} (p : parser α) : Prop",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "A `parser a` is defined to be `bounded` if it produces a `fail` `parse_result` when it is parsing outside the provided `char_buffer`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "totally_bounded",
    "statement": "def totally_bounded {α : Type u} [uniform_space α] (s : set α) : Prop",
    "theorem": "{α : Type u} [uniform_space α] (s : set α) : Prop",
    "args": "{α : Type u} [uniform_space α] (s : set α)",
    "doc_string": "A set `s` is totally bounded if for every entourage `d` there is a finite  set of points `t` such that every element of `s` is `d`-near to some element of `t`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "turing.dir",
    "statement": "inductive turing.dir  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A direction for the turing machine `move` command, either  left or right.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "finmap.lookup",
    "statement": "def finmap.lookup {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β) : option (β a)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β) : option (β a)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : finmap β)",
    "doc_string": "Look up the value associated to a key in a map.",
    "kind": "def",
    "type": "option (β a)"
  },
  {
    "name": "fin.mod_nat",
    "statement": "def fin.mod_nat {n m : ℕ} (i : fin (m * n)) : fin n",
    "theorem": "{n m : ℕ} (i : fin (m * n)) : fin n",
    "args": "{n m : ℕ} (i : fin (m * n))",
    "doc_string": "Compute `i % n`, where `n` is a `nat` and inferred the type of `i`.",
    "kind": "def",
    "type": "fin n"
  },
  {
    "name": "geometry.simplicial_complex.space",
    "statement": "def geometry.simplicial_complex.space {𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E) : set E",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E) : set E",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (K : geometry.simplicial_complex 𝕜 E)",
    "doc_string": "The underlying space of a simplicial complex is the union of its faces.",
    "kind": "def",
    "type": "set E"
  },
  {
    "name": "two_pointing.prod",
    "statement": "def two_pointing.prod {α : Type u_1} {β : Type u_2} (p : two_pointing α) (q : two_pointing β) : two_pointing (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (p : two_pointing α) (q : two_pointing β) : two_pointing (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} (p : two_pointing α) (q : two_pointing β)",
    "doc_string": "The product of two two-pointings.",
    "kind": "def",
    "type": "two_pointing (α × β)"
  },
  {
    "name": "ideal.is_jacobson_field",
    "statement": "def ideal.is_jacobson_field {K : Type u_1} [field K] : ideal.is_jacobson K",
    "theorem": "{K : Type u_1} [field K] : ideal.is_jacobson K",
    "args": "{K : Type u_1} [field K]",
    "doc_string": "Fields have only two ideals, and the condition holds for both of them.",
    "kind": "def",
    "type": "ideal.is_jacobson K"
  },
  {
    "name": "category_theory.is_subterminal_of_mono_is_terminal_from",
    "statement": "theorem category_theory.is_subterminal_of_mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A",
    "theorem": "{C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A",
    "args": "{C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)]",
    "doc_string": "If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`.",
    "kind": "theorem",
    "type": "category_theory.is_subterminal A"
  },
  {
    "name": "matrix.transvection_struct.sum_inl",
    "statement": "def matrix.transvection_struct.sum_inl {n : Type u_1} (p : Type u_2) {R : Type u₂} [decidable_eq n] [decidable_eq p] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct (n ⊕ p) R",
    "theorem": "{n : Type u_1} (p : Type u_2) {R : Type u₂} [decidable_eq n] [decidable_eq p] [comm_ring R] (t : matrix.transvection_struct n R) : matrix.transvection_struct (n ⊕ p) R",
    "args": "{n : Type u_1} (p : Type u_2) {R : Type u₂} [decidable_eq n] [decidable_eq p] [comm_ring R] (t : matrix.transvection_struct n R)",
    "doc_string": " Given a `transvection_struct` on `n`, define the corresponding `transvection_struct` on `n ⊕ p` using the identity on `p`.",
    "kind": "def",
    "type": "matrix.transvection_struct (n ⊕ p) R"
  },
  {
    "name": "fin.append",
    "statement": "def fin.append {m n : ℕ} {α : Type u_1} {o : ℕ} (ho : o = m + n) (u : fin m → α) (v : fin n → α) : fin o → α",
    "theorem": "{m n : ℕ} {α : Type u_1} {o : ℕ} (ho : o = m + n) (u : fin m → α) (v : fin n → α) : fin o → α",
    "args": "{m n : ℕ} {α : Type u_1} {o : ℕ} (ho : o = m + n) (u : fin m → α) (v : fin n → α)",
    "doc_string": " `fin.append ho u v` appends two vectors of lengths `m` and `n` to produce one of length `o = m + n`.  `ho` provides control of definitional equality for the vector length.",
    "kind": "def",
    "type": "fin o → α"
  },
  {
    "name": "fact_one_le_one_ennreal",
    "statement": "def fact_one_le_one_ennreal  : fact (1 ≤ 1)",
    "theorem": " : fact (1 ≤ 1)",
    "args": "",
    "doc_string": "`(1 : ℝ≥0∞) ≤ 1`, recorded as a `fact` for use with `Lp` spaces.",
    "kind": "def",
    "type": "fact (1 ≤ 1)"
  },
  {
    "name": "category_theory.limits.has_finite_colimits_of_has_colimits",
    "statement": "def category_theory.limits.has_finite_colimits_of_has_colimits (C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] : category_theory.limits.has_finite_colimits C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C] : category_theory.limits.has_finite_colimits C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits C]",
    "doc_string": "If `C` has all colimits, it has finite colimits.",
    "kind": "def",
    "type": "category_theory.limits.has_finite_colimits C"
  },
  {
    "name": "multiset.join",
    "statement": "def multiset.join {α : Type u_1} : multiset (multiset α) → multiset α",
    "theorem": "{α : Type u_1} : multiset (multiset α) → multiset α",
    "args": "{α : Type u_1}",
    "doc_string": "`join S`, where `S` is a multiset of multisets, is the lift of the list join  operation, that is, the union of all the sets.     join {{1, 2}, {1, 2}, {0, 1}} = {0, 1, 1, 1, 2, 2}",
    "kind": "def",
    "type": "multiset (multiset α) → multiset α"
  },
  {
    "name": "exists_compact_mem_nhds",
    "statement": "theorem exists_compact_mem_nhds {α : Type u} [topological_space α] [locally_compact_space α] (x : α) : ∃ (K : set α), is_compact K ∧ K ∈ nhds x",
    "theorem": "{α : Type u} [topological_space α] [locally_compact_space α] (x : α) : ∃ (K : set α), is_compact K ∧ K ∈ nhds x",
    "args": "{α : Type u} [topological_space α] [locally_compact_space α] (x : α)",
    "doc_string": "In a locally compact space every point has a compact neighborhood.",
    "kind": "theorem",
    "type": "∃ (K : set α), is_compact K ∧ K ∈ nhds x"
  },
  {
    "name": "cardinal.mk",
    "statement": "def cardinal.mk  : Type u → cardinal",
    "theorem": " : Type u → cardinal",
    "args": "",
    "doc_string": "The cardinal number of a type",
    "kind": "def",
    "type": "Type u → cardinal"
  },
  {
    "name": "pgame.inv_ty",
    "statement": "inductive pgame.inv_ty (l r : Type u) : bool → Type u",
    "theorem": "(l r : Type u) : bool → Type u",
    "args": "(l r : Type u)",
    "doc_string": " Because the two halves of the definition of `inv` produce more elements on each side, we have to define the two families inductively. This is the indexing set for the function, and `inv_val` is the function part.",
    "kind": "inductive",
    "type": "bool → Type u"
  },
  {
    "name": "finset.mul_action_finset",
    "statement": "def finset.mul_action_finset {α : Type u_2} {β : Type u_3} [decidable_eq β] [monoid α] [mul_action α β] : mul_action α (finset β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [decidable_eq β] [monoid α] [mul_action α β] : mul_action α (finset β)",
    "args": "{α : Type u_2} {β : Type u_3} [decidable_eq β] [monoid α] [mul_action α β]",
    "doc_string": "A multiplicative action of a monoid on a type `β` gives a multiplicative action on `finset β`.",
    "kind": "def",
    "type": "mul_action α (finset β)"
  },
  {
    "name": "composition_series.ext",
    "statement": "theorem composition_series.ext {X : Type u} [lattice X] [jordan_holder_lattice X] {s₁ s₂ : composition_series X} (h : ∀ (x : X), x ∈ s₁ ↔ x ∈ s₂) : s₁ = s₂",
    "theorem": "{X : Type u} [lattice X] [jordan_holder_lattice X] {s₁ s₂ : composition_series X} (h : ∀ (x : X), x ∈ s₁ ↔ x ∈ s₂) : s₁ = s₂",
    "args": "{X : Type u} [lattice X] [jordan_holder_lattice X] {s₁ s₂ : composition_series X} (h : ∀ (x : X), x ∈ s₁ ↔ x ∈ s₂)",
    "doc_string": "Two `composition_series` are equal if they have the same elements. See also `ext_fun`.",
    "kind": "theorem",
    "type": "s₁ = s₂"
  },
  {
    "name": "finset.erase",
    "statement": "def finset.erase {α : Type u_1} [decidable_eq α] (s : finset α) (a : α) : finset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : finset α) (a : α) : finset α",
    "args": "{α : Type u_1} [decidable_eq α] (s : finset α) (a : α)",
    "doc_string": "`erase s a` is the set `s - {a}`, that is, the elements of `s` which are  not equal to `a`.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "bool.decidable_exists_bool",
    "statement": "def bool.decidable_exists_bool {p : bool → Prop} [Π (b : bool), decidable (p b)] : decidable (∃ (b : bool), p b)",
    "theorem": "{p : bool → Prop} [Π (b : bool), decidable (p b)] : decidable (∃ (b : bool), p b)",
    "args": "{p : bool → Prop} [Π (b : bool), decidable (p b)]",
    "doc_string": "If `p b` is decidable for all `b : bool`, then `∃ b, p b` is decidable",
    "kind": "def",
    "type": "decidable (∃ (b : bool), p b)"
  },
  {
    "name": "finset.piecewise",
    "statement": "def finset.piecewise {α : Type u_1} {δ : α → Sort u_2} (s : finset α) (f g : Π (i : α), δ i) [Π (j : α), decidable (j ∈ s)] (i : α) : δ i",
    "theorem": "{α : Type u_1} {δ : α → Sort u_2} (s : finset α) (f g : Π (i : α), δ i) [Π (j : α), decidable (j ∈ s)] (i : α) : δ i",
    "args": "{α : Type u_1} {δ : α → Sort u_2} (s : finset α) (f g : Π (i : α), δ i) [Π (j : α), decidable (j ∈ s)] (i : α)",
    "doc_string": " `s.piecewise f g` is the function equal to `f` on the finset `s`, and to `g` on its complement.",
    "kind": "def",
    "type": "δ i"
  },
  {
    "name": "equiv.swap",
    "statement": "def equiv.swap {α : Sort u} [decidable_eq α] (a b : α) : equiv.perm α",
    "theorem": "{α : Sort u} [decidable_eq α] (a b : α) : equiv.perm α",
    "args": "{α : Sort u} [decidable_eq α] (a b : α)",
    "doc_string": "`swap a b` is the permutation that swaps `a` and `b` and  leaves other values as is.",
    "kind": "def",
    "type": "equiv.perm α"
  },
  {
    "name": "free_product.word.pair",
    "statement": "structure free_product.word.pair {ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] (i : ι) : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] (i : ι) : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] (i : ι)",
    "doc_string": " Given an index `i : ι`, `pair M i` is the type of pairs `(head, tail)` where `head : M i` and `tail : word M`, subject to the constraint that first letter of `tail` can't be `⟨i, m⟩`. By prepending `head` to `tail`, one obtains a new word. We'll show that any word can be uniquely obtained in this way.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "wseq.update_nth",
    "statement": "def wseq.update_nth {α : Type u} (s : wseq α) (n : ℕ) (a : α) : wseq α",
    "theorem": "{α : Type u} (s : wseq α) (n : ℕ) (a : α) : wseq α",
    "args": "{α : Type u} (s : wseq α) (n : ℕ) (a : α)",
    "doc_string": "Replace the `n`th element of `s` with `a`.",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "mvqpf.supp_preservation",
    "statement": "def mvqpf.supp_preservation {n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F) : Prop",
    "theorem": "{n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F) : Prop",
    "args": "{n : ℕ} {F : typevec n → Type u_1} [mvfunctor F] (q : mvqpf F)",
    "doc_string": "does `abs` preserve `supp`?",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "free_non_unital_non_assoc_algebra",
    "statement": "def free_non_unital_non_assoc_algebra (R : Type u) (X : Type v) [semiring R] : Type (max u v)",
    "theorem": "(R : Type u) (X : Type v) [semiring R] : Type (max u v)",
    "args": "(R : Type u) (X : Type v) [semiring R]",
    "doc_string": "The free non-unital, non-associative algebra on the type `X` with coefficients in `R`.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "rand.random_series",
    "statement": "def rand.random_series (α : Type u) {g : Type} [random_gen g] [random α] : rand_g g (stream α)",
    "theorem": "(α : Type u) {g : Type} [random_gen g] [random α] : rand_g g (stream α)",
    "args": "(α : Type u) {g : Type} [random_gen g] [random α]",
    "doc_string": "generate an infinite series of random values of type `α`",
    "kind": "def",
    "type": "rand_g g (stream α)"
  },
  {
    "name": "list.pw_filter",
    "statement": "def list.pw_filter {α : Type u_1} (R : α → α → Prop) [decidable_rel R] : list α → list α",
    "theorem": "{α : Type u_1} (R : α → α → Prop) [decidable_rel R] : list α → list α",
    "args": "{α : Type u_1} (R : α → α → Prop) [decidable_rel R]",
    "doc_string": "`pw_filter R l` is a maximal sublist of `l` which is `pairwise R`.  `pw_filter (≠)` is the erase duplicates function (cf. `dedup`), and `pw_filter (<)` finds  a maximal increasing subsequence in `l`. For example,      pw_filter (<) [0, 1, 5, 2, 6, 3, 4] = [0, 1, 2, 3, 4]",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "left.one_lt_mul_of_lt_of_le",
    "statement": "theorem left.one_lt_mul_of_lt_of_le {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_lt_of_le`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "turing.blank_rel",
    "statement": "def turing.blank_rel {Γ : Type u_1} [inhabited Γ] (l₁ l₂ : list Γ) : Prop",
    "theorem": "{Γ : Type u_1} [inhabited Γ] (l₁ l₂ : list Γ) : Prop",
    "args": "{Γ : Type u_1} [inhabited Γ] (l₁ l₂ : list Γ)",
    "doc_string": " `blank_rel` is the symmetric closure of `blank_extends`, turning it into an equivalence relation. Two lists are related by `blank_rel` if one extends the other by blanks.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subgroup.fg",
    "statement": "def subgroup.fg {G : Type u_3} [group G] (P : subgroup G) : Prop",
    "theorem": "{G : Type u_3} [group G] (P : subgroup G) : Prop",
    "args": "{G : Type u_3} [group G] (P : subgroup G)",
    "doc_string": "A subgroup of `G` is finitely generated if it is the closure of a finite subset of `G`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "vector.last_def",
    "statement": "theorem vector.last_def {n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.last = v.nth (fin.last n)",
    "theorem": "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.last = v.nth (fin.last n)",
    "args": "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)}",
    "doc_string": "The last element of a `vector`, given that the vector is at least one element.",
    "kind": "theorem",
    "type": "v.last = v.nth (fin.last n)"
  },
  {
    "name": "path.homotopic.quotient.comp",
    "statement": "def path.homotopic.quotient.comp {X : Type u} [topological_space X] {x₀ x₁ x₂ : X} (P₀ : path.homotopic.quotient x₀ x₁) (P₁ : path.homotopic.quotient x₁ x₂) : path.homotopic.quotient x₀ x₂",
    "theorem": "{X : Type u} [topological_space X] {x₀ x₁ x₂ : X} (P₀ : path.homotopic.quotient x₀ x₁) (P₁ : path.homotopic.quotient x₁ x₂) : path.homotopic.quotient x₀ x₂",
    "args": "{X : Type u} [topological_space X] {x₀ x₁ x₂ : X} (P₀ : path.homotopic.quotient x₀ x₁) (P₁ : path.homotopic.quotient x₁ x₂)",
    "doc_string": "The composition of path homotopy classes. This is `path.trans` descended to the quotient.",
    "kind": "def",
    "type": "path.homotopic.quotient x₀ x₂"
  },
  {
    "name": "list.Ico.trichotomy",
    "statement": "theorem list.Ico.trichotomy (n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b",
    "theorem": "(n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b",
    "args": "(n a b : ℕ)",
    "doc_string": "For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b",
    "kind": "theorem",
    "type": "n < a ∨ b ≤ n ∨ n ∈ list.Ico a b"
  },
  {
    "name": "pseudo_metric_space.ext",
    "statement": "theorem pseudo_metric_space.ext {α : Type u_1} {m m' : pseudo_metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'",
    "theorem": "{α : Type u_1} {m m' : pseudo_metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'",
    "args": "{α : Type u_1} {m m' : pseudo_metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist)",
    "doc_string": "Two pseudo metric space structures with the same distance function coincide.",
    "kind": "theorem",
    "type": "m = m'"
  },
  {
    "name": "preconnected_space",
    "statement": "structure preconnected_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A preconnected space is one where there is no non-trivial open partition.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_add_unit",
    "statement": "def is_add_unit {M : Type u_1} [add_monoid M] (a : M) : Prop",
    "theorem": "{M : Type u_1} [add_monoid M] (a : M) : Prop",
    "args": "{M : Type u_1} [add_monoid M] (a : M)",
    "doc_string": "An element `a : M` of an add_monoid is an `add_unit` if it has a two-sided additive inverse. The actual definition says that `a` is equal to some `u : add_units M`, where `add_units M` is a bundled version of `is_add_unit`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bounded_continuous_function.const",
    "statement": "def bounded_continuous_function.const (α : Type u) {β : Type v} [topological_space α] [pseudo_metric_space β] (b : β) : bounded_continuous_function α β",
    "theorem": "(α : Type u) {β : Type v} [topological_space α] [pseudo_metric_space β] (b : β) : bounded_continuous_function α β",
    "args": "(α : Type u) {β : Type v} [topological_space α] [pseudo_metric_space β] (b : β)",
    "doc_string": "Constant as a continuous bounded function.",
    "kind": "def",
    "type": "bounded_continuous_function α β"
  },
  {
    "name": "measurable_space.generate_measurable",
    "statement": "inductive measurable_space.generate_measurable {α : Type u_1} (s : set (set α)) : set α → Prop",
    "theorem": "{α : Type u_1} (s : set (set α)) : set α → Prop",
    "args": "{α : Type u_1} (s : set (set α))",
    "doc_string": "The smallest σ-algebra containing a collection `s` of basic sets",
    "kind": "inductive",
    "type": "set α → Prop"
  },
  {
    "name": "comm_group_of_is_unit",
    "statement": "def comm_group_of_is_unit {M : Type u_1} [hM : comm_monoid M] (h : ∀ (a : M), is_unit a) : comm_group M",
    "theorem": "{M : Type u_1} [hM : comm_monoid M] (h : ∀ (a : M), is_unit a) : comm_group M",
    "args": "{M : Type u_1} [hM : comm_monoid M] (h : ∀ (a : M), is_unit a)",
    "doc_string": "Constructs a `comm_group` structure on a `comm_monoid` consisting only of units.",
    "kind": "def",
    "type": "comm_group M"
  },
  {
    "name": "category_theory.over.construct_products.over_finite_products_of_finite_wide_pullbacks",
    "statement": "theorem category_theory.over.construct_products.over_finite_products_of_finite_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C}",
    "doc_string": "Given all finite wide pullbacks in `C`, construct finite products in `C/B`.",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_products (category_theory.over B)"
  },
  {
    "name": "snum.sign",
    "statement": "def snum.sign  : snum → bool",
    "theorem": " : snum → bool",
    "args": "",
    "doc_string": "Sign of a `snum`.",
    "kind": "def",
    "type": "snum → bool"
  },
  {
    "name": "locally_constant.flip",
    "statement": "def locally_constant.flip {X : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space X] (f : locally_constant X (α → β)) (a : α) : locally_constant X β",
    "theorem": "{X : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space X] (f : locally_constant X (α → β)) (a : α) : locally_constant X β",
    "args": "{X : Type u_1} {α : Type u_2} {β : Type u_3} [topological_space X] (f : locally_constant X (α → β)) (a : α)",
    "doc_string": " Given a locally constant function to `α → β`, construct a family of locally constant functions with values in β indexed by α.",
    "kind": "def",
    "type": "locally_constant X β"
  },
  {
    "name": "subring.complete_lattice",
    "statement": "def subring.complete_lattice {R : Type u} [ring R] : complete_lattice (subring R)",
    "theorem": "{R : Type u} [ring R] : complete_lattice (subring R)",
    "args": "{R : Type u} [ring R]",
    "doc_string": "Subrings of a ring form a complete lattice.",
    "kind": "def",
    "type": "complete_lattice (subring R)"
  },
  {
    "name": "tactic.norm_fin.normalize_fin",
    "statement": "def tactic.norm_fin.normalize_fin (n : ℕ) (a : fin n) (b : ℕ) : Prop",
    "theorem": "(n : ℕ) (a : fin n) (b : ℕ) : Prop",
    "args": "(n : ℕ) (a : fin n) (b : ℕ)",
    "doc_string": " `normalize_fin n a b` means that `a : fin n` is equivalent to `b : ℕ` in the modular sense - that is, `↑a ≡ b (mod n)`. This is used for translating the algebraic operations: addition, multiplication, zero and one, which use modulo for reduction.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "inseparable",
    "statement": "def inseparable {X : Type u_1} [topological_space X] (x y : X) : Prop",
    "theorem": "{X : Type u_1} [topological_space X] (x y : X) : Prop",
    "args": "{X : Type u_1} [topological_space X] (x y : X)",
    "doc_string": "Two points are topologically inseparable if no open set separates them.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pgame.lf",
    "statement": "def pgame.lf (x y : pgame) : Prop",
    "theorem": "(x y : pgame) : Prop",
    "args": "(x y : pgame)",
    "doc_string": " The less or fuzzy relation on pre-games.  If `0 ⧏ x`, then Left can win `x` as the first player.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_units.add_group",
    "statement": "def add_units.add_group {α : Type u} [add_monoid α] : add_group (add_units α)",
    "theorem": "{α : Type u} [add_monoid α] : add_group (add_units α)",
    "args": "{α : Type u} [add_monoid α]",
    "doc_string": "Additive units of an additive monoid form an additive group.",
    "kind": "def",
    "type": "add_group (add_units α)"
  },
  {
    "name": "submonoid.centralizer",
    "statement": "def submonoid.centralizer {M : Type u_1} (S : set M) [monoid M] : submonoid M",
    "theorem": "{M : Type u_1} (S : set M) [monoid M] : submonoid M",
    "args": "{M : Type u_1} (S : set M) [monoid M]",
    "doc_string": "The centralizer of a subset of a monoid `M`.",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "add_subsemigroup.copy",
    "statement": "def add_subsemigroup.copy {M : Type u_1} [has_add M] (S : add_subsemigroup M) (s : set M) (hs : s = ↑S) : add_subsemigroup M",
    "theorem": "{M : Type u_1} [has_add M] (S : add_subsemigroup M) (s : set M) (hs : s = ↑S) : add_subsemigroup M",
    "args": "{M : Type u_1} [has_add M] (S : add_subsemigroup M) (s : set M) (hs : s = ↑S)",
    "doc_string": "Copy an additive subsemigroup replacing `carrier` with a set that is equal to it.",
    "kind": "def",
    "type": "add_subsemigroup M"
  },
  {
    "name": "wf_dvd_monoid",
    "statement": "structure wf_dvd_monoid (α : Type u_2) [comm_monoid_with_zero α] : Prop",
    "theorem": "(α : Type u_2) [comm_monoid_with_zero α] : Prop",
    "args": "(α : Type u_2) [comm_monoid_with_zero α]",
    "doc_string": " Well-foundedness of the strict version of |, which is equivalent to the descending chain condition on divisibility and to the ascending chain condition on principal ideals in an integral domain.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_monoid_hom.id",
    "statement": "theorem is_monoid_hom.id {α : Type u} [mul_one_class α] : is_monoid_hom id",
    "theorem": "{α : Type u} [mul_one_class α] : is_monoid_hom id",
    "args": "{α : Type u} [mul_one_class α]",
    "doc_string": "The identity map is a monoid homomorphism.",
    "kind": "theorem",
    "type": "is_monoid_hom id"
  },
  {
    "name": "algebraic_geometry.LocallyRingedSpace.glue_data",
    "statement": "structure algebraic_geometry.LocallyRingedSpace.glue_data  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "A family of gluing data consists of 1. An index type `J` 2. A locally ringed space `U i` for each `i : J`. 3. A locally ringed space `V i j` for each `i j : J`.   (Note that this is `J × J → LocallyRingedSpace` rather than `J → J → LocallyRingedSpace` to   connect to the limits library easier.) 4. An open immersion `f i j : V i j ⟶ U i` for each `i j : ι`. 5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`. such that 6. `f i i` is an isomorphism. 7. `t i i` is the identity. 8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some     `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`. 9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.  We can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such that the `U i`'s are open subspaces of the glued space.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "ordnode.find_index_aux",
    "statement": "def ordnode.find_index_aux {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ℕ → option ℕ",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ℕ → option ℕ",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": "Auxiliary definition for `find_index`.",
    "kind": "def",
    "type": "ordnode α → ℕ → option ℕ"
  },
  {
    "name": "composition_as_set.blocks",
    "statement": "def composition_as_set.blocks {n : ℕ} (c : composition_as_set n) : list ℕ",
    "theorem": "{n : ℕ} (c : composition_as_set n) : list ℕ",
    "args": "{n : ℕ} (c : composition_as_set n)",
    "doc_string": "List of the sizes of the blocks in a `composition_as_set`.",
    "kind": "def",
    "type": "list ℕ"
  },
  {
    "name": "frame_hom.to_lattice_hom",
    "statement": "def frame_hom.to_lattice_hom {α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : frame_hom α β) : lattice_hom α β",
    "theorem": "{α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : frame_hom α β) : lattice_hom α β",
    "args": "{α : Type u_2} {β : Type u_3} [complete_lattice α] [complete_lattice β] (f : frame_hom α β)",
    "doc_string": "Reinterpret a `frame_hom` as a `lattice_hom`.",
    "kind": "def",
    "type": "lattice_hom α β"
  },
  {
    "name": "mvfunctor.liftp",
    "statement": "def mvfunctor.liftp {n : ℕ} {F : typevec n → Type v} [mvfunctor F] {α : typevec n} (p : Π (i : fin2 n), α i → Prop) (x : F α) : Prop",
    "theorem": "{n : ℕ} {F : typevec n → Type v} [mvfunctor F] {α : typevec n} (p : Π (i : fin2 n), α i → Prop) (x : F α) : Prop",
    "args": "{n : ℕ} {F : typevec n → Type v} [mvfunctor F] {α : typevec n} (p : Π (i : fin2 n), α i → Prop) (x : F α)",
    "doc_string": "predicate lifting over multivariate functors",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "int.clog",
    "statement": "def int.clog {R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ℕ) (r : R) : ℤ",
    "theorem": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ℕ) (r : R) : ℤ",
    "args": "{R : Type u_1} [linear_ordered_field R] [floor_ring R] (b : ℕ) (r : R)",
    "doc_string": "The least power of `b` such that `r ≤ b ^ log b r`.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "fin2",
    "statement": "inductive fin2  : ℕ → Type",
    "theorem": " : ℕ → Type",
    "args": "",
    "doc_string": "An alternate definition of `fin n` defined as an inductive type instead of a subtype of `ℕ`.",
    "kind": "inductive",
    "type": "ℕ → Type"
  },
  {
    "name": "fintype.subtype_eq'",
    "statement": "def fintype.subtype_eq' {α : Type u_1} (y : α) : fintype {x // y = x}",
    "theorem": "{α : Type u_1} (y : α) : fintype {x // y = x}",
    "args": "{α : Type u_1} (y : α)",
    "doc_string": " Short-circuit instance to decrease search for `unique.fintype`, since that relies on a subsingleton elimination for `unique`.",
    "kind": "def",
    "type": "fintype {x // y = x}"
  },
  {
    "name": "is_cyclic.comm_group",
    "statement": "def is_cyclic.comm_group {α : Type u} [hg : group α] [is_cyclic α] : comm_group α",
    "theorem": "{α : Type u} [hg : group α] [is_cyclic α] : comm_group α",
    "args": "{α : Type u} [hg : group α] [is_cyclic α]",
    "doc_string": " A cyclic group is always commutative. This is not an `instance` because often we have a better proof of `comm_group`.",
    "kind": "def",
    "type": "comm_group α"
  },
  {
    "name": "set.diagonal",
    "statement": "def set.diagonal (α : Type u_1) : set (α × α)",
    "theorem": "(α : Type u_1) : set (α × α)",
    "args": "(α : Type u_1)",
    "doc_string": "`diagonal α` is the set of `α × α` consisting of all pairs of the form `(a, a)`.",
    "kind": "def",
    "type": "set (α × α)"
  },
  {
    "name": "polynomial.X",
    "statement": "def polynomial.X {R : Type u} [semiring R] : polynomial R",
    "theorem": "{R : Type u} [semiring R] : polynomial R",
    "args": "{R : Type u} [semiring R]",
    "doc_string": "`X` is the polynomial variable (aka indeterminate).",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "sylow",
    "statement": "structure sylow (p : ℕ) (G : Type u_1) [group G] : Type u_1",
    "theorem": "(p : ℕ) (G : Type u_1) [group G] : Type u_1",
    "args": "(p : ℕ) (G : Type u_1) [group G]",
    "doc_string": "A Sylow `p`-subgroup is a maximal `p`-subgroup.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "category_theory.limits.has_products",
    "statement": "def category_theory.limits.has_products (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "An abbreviation for `Π J, has_limits_of_shape (discrete J) C`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "charmatrix",
    "statement": "def charmatrix {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : matrix n n (polynomial R)",
    "theorem": "{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : matrix n n (polynomial R)",
    "args": "{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R)",
    "doc_string": "The \"characteristic matrix\" of `M : matrix n n R` is the matrix of polynomials $t I - M$. The determinant of this matrix is the characteristic polynomial.",
    "kind": "def",
    "type": "matrix n n (polynomial R)"
  },
  {
    "name": "matrix.transvection_struct.to_matrix",
    "statement": "def matrix.transvection_struct.to_matrix {n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix n n R",
    "theorem": "{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R) : matrix n n R",
    "args": "{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (t : matrix.transvection_struct n R)",
    "doc_string": "Associating to a `transvection_struct` the corresponding transvection matrix.",
    "kind": "def",
    "type": "matrix n n R"
  },
  {
    "name": "Set.omega",
    "statement": "def Set.omega  : Set",
    "theorem": " : Set",
    "args": "",
    "doc_string": "`omega` is the first infinite von Neumann ordinal",
    "kind": "def",
    "type": "Set"
  },
  {
    "name": "category_theory.shift_functor.is_equivalence",
    "statement": "def category_theory.shift_functor.is_equivalence (C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.is_equivalence (category_theory.shift_functor C i)",
    "theorem": "(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.is_equivalence (category_theory.shift_functor C i)",
    "args": "(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A)",
    "doc_string": "Shifting by `i` is an equivalence.",
    "kind": "def",
    "type": "category_theory.is_equivalence (category_theory.shift_functor C i)"
  },
  {
    "name": "pnat.xgcd_type.vp",
    "statement": "def pnat.xgcd_type.vp (u : pnat.xgcd_type) : ℕ × ℕ",
    "theorem": "(u : pnat.xgcd_type) : ℕ × ℕ",
    "args": "(u : pnat.xgcd_type)",
    "doc_string": "The map v gives the product of the matrix [[w, x], [y, z]] = [[wp + 1, x], [y, zp + 1]] and the vector [a, b] = [ap + 1, bp + 1].  The map vp gives [sp, tp] such that v = [sp + 1, tp + 1].",
    "kind": "def",
    "type": "ℕ × ℕ"
  },
  {
    "name": "left.mul_le_one",
    "statement": "theorem left.mul_le_one {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.mul_le_one`.",
    "kind": "theorem",
    "type": "a * b ≤ 1"
  },
  {
    "name": "Locale",
    "statement": "def Locale  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of locales.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "subalgebra.fg",
    "statement": "def subalgebra.fg {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : Prop",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : Prop",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A)",
    "doc_string": " A subalgebra `S` is finitely generated if there exists `t : finset A` such that `algebra.adjoin R t = S`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordinal.omega",
    "statement": "def ordinal.omega  : ordinal",
    "theorem": " : ordinal",
    "args": "",
    "doc_string": "`ω` is the first infinite ordinal, defined as the order type of `ℕ`.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "list.kerase",
    "statement": "def list.kerase {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → list (sigma β)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → list (sigma β)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α)",
    "doc_string": "Remove the first pair with the key `a`.",
    "kind": "def",
    "type": "list (sigma β) → list (sigma β)"
  },
  {
    "name": "nat.prime.sq_add_sq",
    "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
    "theorem": "{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
    "args": "{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1)",
    "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.",
    "kind": "theorem",
    "type": "∃ (a b : ℕ), a ^ 2 + b ^ 2 = p"
  },
  {
    "name": "left_add",
    "statement": "def left_add {G : Type u_1} [has_add G] : G → G → G",
    "theorem": "{G : Type u_1} [has_add G] : G → G → G",
    "args": "{G : Type u_1} [has_add G]",
    "doc_string": "`left_add g` denotes left addition by `g`",
    "kind": "def",
    "type": "G → G → G"
  },
  {
    "name": "lattice",
    "statement": "structure lattice (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A lattice is a join-semilattice which is also a meet-semilattice.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "prod.distrib",
    "statement": "def prod.distrib {R : Type u_1} {S : Type u_3} [distrib R] [distrib S] : distrib (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [distrib R] [distrib S] : distrib (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [distrib R] [distrib S]",
    "doc_string": "Product of two distributive types is distributive.",
    "kind": "def",
    "type": "distrib (R × S)"
  },
  {
    "name": "functor.liftr",
    "statement": "def functor.liftr {F : Type u → Type u} [functor F] {α : Type u} (r : α → α → Prop) (x y : F α) : Prop",
    "theorem": "{F : Type u → Type u} [functor F] {α : Type u} (r : α → α → Prop) (x y : F α) : Prop",
    "args": "{F : Type u → Type u} [functor F] {α : Type u} (r : α → α → Prop) (x y : F α)",
    "doc_string": " If we consider `x : F α` to, in some sense, contain values of type `α`, then `liftr r x y` relates `x` and `y` iff (1) `x` and `y` have the same shape and (2) we can pair values `a` from `x` and `b` from `y` so that `r a b` holds.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "smt_pre_config",
    "statement": "structure smt_pre_config  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration for the smt tactic preprocessor. The preprocessor is applied whenever a new hypothesis is introduced.  - simp_attr: is the attribute name for the simplification lemmas   that are used during the preprocessing step.  - max_steps: it is the maximum number of steps performed by the simplifier.  - zeta: if tt, then zeta reduction (i.e., unfolding let-expressions)   is used during preprocessing.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "uniform_equiv",
    "statement": "structure uniform_equiv (α : Type u_5) (β : Type u_6) [uniform_space α] [uniform_space β] : Type (max u_5 u_6)",
    "theorem": "(α : Type u_5) (β : Type u_6) [uniform_space α] [uniform_space β] : Type (max u_5 u_6)",
    "args": "(α : Type u_5) (β : Type u_6) [uniform_space α] [uniform_space β]",
    "doc_string": "Uniform isomorphism between `α` and `β`",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "commute.symm",
    "statement": "theorem commute.symm {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a",
    "theorem": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a",
    "args": "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b)",
    "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`.",
    "kind": "theorem",
    "type": "commute b a"
  },
  {
    "name": "measurable_set",
    "statement": "def measurable_set {α : Type u_1} [measurable_space α] : set α → Prop",
    "theorem": "{α : Type u_1} [measurable_space α] : set α → Prop",
    "args": "{α : Type u_1} [measurable_space α]",
    "doc_string": "`measurable_set s` means that `s` is measurable (in the ambient measure space on `α`)",
    "kind": "def",
    "type": "set α → Prop"
  },
  {
    "name": "category_theory.limits.colimit_cocone_of_unique",
    "statement": "def category_theory.limits.colimit_cocone_of_unique {β : Type w} {C : Type u} [category_theory.category C] [unique β] (f : β → C) : category_theory.limits.colimit_cocone (category_theory.discrete.functor f)",
    "theorem": "{β : Type w} {C : Type u} [category_theory.category C] [unique β] (f : β → C) : category_theory.limits.colimit_cocone (category_theory.discrete.functor f)",
    "args": "{β : Type w} {C : Type u} [category_theory.category C] [unique β] (f : β → C)",
    "doc_string": "The colimit cocone for the coproduct over an index type with exactly one term.",
    "kind": "def",
    "type": "category_theory.limits.colimit_cocone (category_theory.discrete.functor f)"
  },
  {
    "name": "measure_theory.is_clopenable_iff_measurable_set",
    "statement": "theorem measure_theory.is_clopenable_iff_measurable_set {γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s",
    "theorem": "{γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s",
    "args": "{γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ}",
    "doc_string": "In a Polish space, a set is clopenable if and only if it is Borel-measurable.",
    "kind": "theorem",
    "type": "polish_space.is_clopenable s ↔ measurable_set s"
  },
  {
    "name": "generalized_boolean_algebra",
    "statement": "structure generalized_boolean_algebra (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A generalized Boolean algebra is a distributive lattice with `⊥` and a relative complement operation `\\` (called `sdiff`, after \"set difference\") satisfying `(a ⊓ b) ⊔ (a \\ b) = a` and `(a ⊓ b) ⊓ (a \\ b) = ⊥`, i.e. `a \\ b` is the complement of `b` in `a`.  This is a generalization of Boolean algebras which applies to `finset α` for arbitrary (not-necessarily-`fintype`) `α`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "add_subgroup.has_top",
    "statement": "def add_subgroup.has_top {G : Type u_1} [add_group G] : has_top (add_subgroup G)",
    "theorem": "{G : Type u_1} [add_group G] : has_top (add_subgroup G)",
    "args": "{G : Type u_1} [add_group G]",
    "doc_string": "The `add_subgroup G` of the `add_group G`.",
    "kind": "def",
    "type": "has_top (add_subgroup G)"
  },
  {
    "name": "list.func.get",
    "statement": "def list.func.get {α : Type u} [inhabited α] : ℕ → list α → α",
    "theorem": "{α : Type u} [inhabited α] : ℕ → list α → α",
    "args": "{α : Type u} [inhabited α]",
    "doc_string": "Get element of a list by index. If the index is out of range, return the default element",
    "kind": "def",
    "type": "ℕ → list α → α"
  },
  {
    "name": "pi.canonically_ordered_add_monoid",
    "statement": "def pi.canonically_ordered_add_monoid {ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), canonically_ordered_add_monoid (Z i)] : canonically_ordered_add_monoid (Π (i : ι), Z i)",
    "theorem": "{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), canonically_ordered_add_monoid (Z i)] : canonically_ordered_add_monoid (Π (i : ι), Z i)",
    "args": "{ι : Type u_1} {Z : ι → Type u_2} [Π (i : ι), canonically_ordered_add_monoid (Z i)]",
    "doc_string": "The product of a family of canonically ordered additive monoids is   a canonically ordered additive monoid.",
    "kind": "def",
    "type": "canonically_ordered_add_monoid (Π (i : ι), Z i)"
  },
  {
    "name": "function.const",
    "statement": "def function.const {α : Sort u₁} (β : Sort u₂) (a : α) : β → α",
    "theorem": "{α : Sort u₁} (β : Sort u₂) (a : α) : β → α",
    "args": "{α : Sort u₁} (β : Sort u₂) (a : α)",
    "doc_string": "Constant `λ _, a`.",
    "kind": "def",
    "type": "β → α"
  },
  {
    "name": "subgroup.characteristic",
    "statement": "structure subgroup.characteristic {G : Type u_1} [group G] (H : subgroup G) : Prop",
    "theorem": "{G : Type u_1} [group G] (H : subgroup G) : Prop",
    "args": "{G : Type u_1} [group G] (H : subgroup G)",
    "doc_string": "A subgroup is characteristic if it is fixed by all automorphisms.  Several equivalent conditions are provided by lemmas of the form `characteristic.iff...`",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "pos_of_neg_neg",
    "statement": "theorem pos_of_neg_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 → 0 < a",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 → 0 < a",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.inv_lt_one_iff`.",
    "kind": "theorem",
    "type": "-a < 0 → 0 < a"
  },
  {
    "name": "monoid.subset_closure",
    "statement": "theorem monoid.subset_closure {M : Type u_1} [monoid M] {s : set M} : s ⊆ monoid.closure s",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} : s ⊆ monoid.closure s",
    "args": "{M : Type u_1} [monoid M] {s : set M}",
    "doc_string": "A subset of a monoid is contained in the submonoid it generates.",
    "kind": "theorem",
    "type": "s ⊆ monoid.closure s"
  },
  {
    "name": "category_theory.limits.colimits_from_coequalizers_and_coproducts",
    "statement": "theorem category_theory.limits.colimits_from_coequalizers_and_coproducts {C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C]",
    "doc_string": "Any category with coproducts and coequalizers has all colimits.  See <https://stacks.math.columbia.edu/tag/002P>.",
    "kind": "theorem",
    "type": "category_theory.limits.has_colimits C"
  },
  {
    "name": "is_artinian",
    "statement": "structure is_artinian (R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "`is_artinian R M` is the proposition that `M` is an Artinian `R`-module, implemented as the well-foundedness of submodule inclusion.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "submodule.has_top",
    "statement": "def submodule.has_top {R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_top (submodule R M)",
    "theorem": "{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_top (submodule R M)",
    "args": "{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "The universal set is the top element of the lattice of submodules.",
    "kind": "def",
    "type": "has_top (submodule R M)"
  },
  {
    "name": "continuous_open_map_class",
    "statement": "structure continuous_open_map_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [topological_space β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [topological_space β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [topological_space α] [topological_space β]",
    "doc_string": " `continuous_open_map_class F α β` states that `F` is a type of continuous open maps.  You should extend this class when you extend `continuous_open_map`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "fixing_submonoid",
    "statement": "def fixing_submonoid (M : Type u_1) {α : Type u_2} [monoid M] [mul_action M α] (s : set α) : submonoid M",
    "theorem": "(M : Type u_1) {α : Type u_2} [monoid M] [mul_action M α] (s : set α) : submonoid M",
    "args": "(M : Type u_1) {α : Type u_2} [monoid M] [mul_action M α] (s : set α)",
    "doc_string": "The submonoid fixing a set under a `mul_action`.",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "bitvec.neg",
    "statement": "def bitvec.neg {n : ℕ} (x : bitvec n) : bitvec n",
    "theorem": "{n : ℕ} (x : bitvec n) : bitvec n",
    "args": "{n : ℕ} (x : bitvec n)",
    "doc_string": "`neg x` is the two's complement of `x`.",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "set.add_centralizer",
    "statement": "def set.add_centralizer {M : Type u_1} (S : set M) [has_add M] : set M",
    "theorem": "{M : Type u_1} (S : set M) [has_add M] : set M",
    "args": "{M : Type u_1} (S : set M) [has_add M]",
    "doc_string": "The centralizer of a subset of an additive magma.",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "language.has_add",
    "statement": "def language.has_add {α : Type u_1} : has_add (language α)",
    "theorem": "{α : Type u_1} : has_add (language α)",
    "args": "{α : Type u_1}",
    "doc_string": "The sum of two languages is their union.",
    "kind": "def",
    "type": "has_add (language α)"
  },
  {
    "name": "loc_path_connected_space",
    "statement": "structure loc_path_connected_space (X : Type u_4) [topological_space X] : Prop",
    "theorem": "(X : Type u_4) [topological_space X] : Prop",
    "args": "(X : Type u_4) [topological_space X]",
    "doc_string": " A topological space is locally path connected, at every point, path connected neighborhoods form a neighborhood basis.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "bdd_above_union",
    "statement": "theorem bdd_above_union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t",
    "theorem": "{γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t",
    "args": "{γ : Type w} [semilattice_sup γ] {s t : set γ}",
    "doc_string": "The union of two sets is bounded above if and only if each of the sets is.",
    "kind": "theorem",
    "type": "bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t"
  },
  {
    "name": "ordered_cancel_comm_monoid",
    "statement": "structure ordered_cancel_comm_monoid (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " An ordered cancellative commutative monoid is a commutative monoid with a partial order, in which multiplication is cancellative and monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "one_le_of_inv_le_one",
    "statement": "theorem one_le_of_inv_le_one {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 → 1 ≤ a",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 → 1 ≤ a",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.inv_le_one_iff`.",
    "kind": "theorem",
    "type": "a⁻¹ ≤ 1 → 1 ≤ a"
  },
  {
    "name": "witt_vector.witt_one",
    "statement": "def witt_vector.witt_one (p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 0 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 0 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "The polynomials used for defining the element `1` of the ring of Witt vectors.",
    "kind": "def",
    "type": "ℕ → mv_polynomial (fin 0 × ℕ) ℤ"
  },
  {
    "name": "hahn_series.order",
    "statement": "def hahn_series.order {Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] [has_zero Γ] (x : hahn_series Γ R) : Γ",
    "theorem": "{Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] [has_zero Γ] (x : hahn_series Γ R) : Γ",
    "args": "{Γ : Type u_1} {R : Type u_2} [partial_order Γ] [has_zero R] [has_zero Γ] (x : hahn_series Γ R)",
    "doc_string": "The order of a nonzero Hahn series `x` is a minimal element of `Γ` where `x` has a  nonzero coefficient, the order of 0 is 0.",
    "kind": "def",
    "type": "Γ"
  },
  {
    "name": "pgame.has_zero",
    "statement": "def pgame.has_zero  : has_zero pgame",
    "theorem": " : has_zero pgame",
    "args": "",
    "doc_string": "The pre-game `zero` is defined by `0 = { | }`.",
    "kind": "def",
    "type": "has_zero pgame"
  },
  {
    "name": "seq.tail",
    "statement": "def seq.tail {α : Type u} : seq α → seq α",
    "theorem": "{α : Type u} : seq α → seq α",
    "args": "{α : Type u}",
    "doc_string": "Get the tail of a sequence (or `nil` if the sequence is `nil`)",
    "kind": "def",
    "type": "seq α → seq α"
  },
  {
    "name": "category_theory.braided_category",
    "statement": "structure category_theory.braided_category (C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.monoidal_category C]",
    "doc_string": "A braided monoidal category is a monoidal category equipped with a braiding isomorphism `β_ X Y : X ⊗ Y ≅ Y ⊗ X` which is natural in both arguments, and also satisfies the two hexagon identities.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "pos",
    "statement": "structure pos  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Column and line position in a Lean source file.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "with_zero.coe_add_hom",
    "statement": "def with_zero.coe_add_hom {α : Type u} [has_add α] : add_hom α (with_zero α)",
    "theorem": "{α : Type u} [has_add α] : add_hom α (with_zero α)",
    "args": "{α : Type u} [has_add α]",
    "doc_string": "`coe` as a bundled morphism",
    "kind": "def",
    "type": "add_hom α (with_zero α)"
  },
  {
    "name": "list.eq_iff_join_eq",
    "statement": "theorem list.eq_iff_join_eq {α : Type u_1} (L L' : list (list α)) : L = L' ↔ L.join = L'.join ∧ list.map list.length L = list.map list.length L'",
    "theorem": "{α : Type u_1} (L L' : list (list α)) : L = L' ↔ L.join = L'.join ∧ list.map list.length L = list.map list.length L'",
    "args": "{α : Type u_1} (L L' : list (list α))",
    "doc_string": " Two lists of sublists are equal iff their joins coincide, as well as the lengths of the sublists.",
    "kind": "theorem",
    "type": "L = L' ↔ L.join = L'.join ∧ list.map list.length L = list.map list.length L'"
  },
  {
    "name": "finset.choose_x",
    "statement": "def finset.choose_x {α : Type u_1} (p : α → Prop) [decidable_pred p] (l : finset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : {a // a ∈ l ∧ p a}",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : finset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : {a // a ∈ l ∧ p a}",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : finset α) (hp : ∃! (a : α), a ∈ l ∧ p a)",
    "doc_string": " Given a finset `l` and a predicate `p`, associate to a proof that there is a unique element of `l` satisfying `p` this unique element, as an element of the corresponding subtype.",
    "kind": "def",
    "type": "{a // a ∈ l ∧ p a}"
  },
  {
    "name": "order_monoid_with_zero_hom_class",
    "statement": "structure order_monoid_with_zero_hom_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [mul_zero_one_class α] [mul_zero_one_class β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [mul_zero_one_class α] [mul_zero_one_class β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [mul_zero_one_class α] [mul_zero_one_class β]",
    "doc_string": " `order_monoid_with_zero_hom_class F α β` states that `F` is a type of ordered monoid with zero homomorphisms.  You should also extend this typeclass when you extend `order_monoid_with_zero_hom`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "category_theory.limits.has_coreflexive_equalizers",
    "statement": "structure category_theory.limits.has_coreflexive_equalizers (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`C` has coreflexive equalizers if it has equalizers for every coreflexive pair.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "norm_cast.norm_cast_cache",
    "statement": "structure norm_cast.norm_cast_cache  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The cache for `norm_cast` attribute stores three `simp_lemma` objects.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "auto.auto_config",
    "statement": "structure auto.auto_config  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration information for the auto tactics. * `(use_simp := tt)`: call the simplifier * `(max_ematch_rounds := 20)`: for the \"done\" tactic",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "inner_product_space.of_core.to_has_norm",
    "statement": "def inner_product_space.of_core.to_has_norm {𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] : has_norm F",
    "theorem": "{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F] : has_norm F",
    "args": "{𝕜 : Type u_1} {F : Type u_3} [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] [c : inner_product_space.core 𝕜 F]",
    "doc_string": " Norm constructed from a `inner_product_space.core` structure, defined to be the square root of the scalar product.",
    "kind": "def",
    "type": "has_norm F"
  },
  {
    "name": "Bipointed",
    "statement": "structure Bipointed  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of bipointed types.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "category_theory.abelian.pseudoelement",
    "statement": "def category_theory.abelian.pseudoelement {C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] (P : C)",
    "doc_string": "A `pseudoelement` of `P` is just an equivalence class of arrows ending in `P` by being    pseudo-equal.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "pSet",
    "statement": "inductive pSet  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The type of pre-sets in universe `u`. A pre-set  is a family of pre-sets indexed by a type in `Type u`.  The ZFC universe is defined as a quotient of this  to ensure extensionality.",
    "kind": "inductive",
    "type": "Type (u+1)"
  },
  {
    "name": "semiconj_by",
    "statement": "def semiconj_by {M : Type u} [has_mul M] (a x y : M) : Prop",
    "theorem": "{M : Type u} [has_mul M] (a x y : M) : Prop",
    "args": "{M : Type u} [has_mul M] (a x y : M)",
    "doc_string": "`x` is semiconjugate to `y` by `a`, if `a * x = y * a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "one_hom_class",
    "statement": "structure one_hom_class (F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_one M] [has_one N] : Type (max u_10 u_11 u_9)",
    "theorem": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_one M] [has_one N] : Type (max u_10 u_11 u_9)",
    "args": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_one M] [has_one N]",
    "doc_string": " `one_hom_class F M N` states that `F` is a type of one-preserving homomorphisms. You should extend this typeclass when you extend `one_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_11 u_9)"
  },
  {
    "name": "pfunctor.approx.cofix_a",
    "statement": "inductive pfunctor.approx.cofix_a (F : pfunctor) : ℕ → Type u",
    "theorem": "(F : pfunctor) : ℕ → Type u",
    "args": "(F : pfunctor)",
    "doc_string": "`cofix_a F n` is an `n` level approximation of a M-type",
    "kind": "inductive",
    "type": "ℕ → Type u"
  },
  {
    "name": "linear_recurrence.char_poly",
    "statement": "def linear_recurrence.char_poly {α : Type u_1} [comm_ring α] (E : linear_recurrence α) : polynomial α",
    "theorem": "{α : Type u_1} [comm_ring α] (E : linear_recurrence α) : polynomial α",
    "args": "{α : Type u_1} [comm_ring α] (E : linear_recurrence α)",
    "doc_string": " The characteristic polynomial of `E` is `X ^ E.order - ∑ i : fin E.order, (E.coeffs i) * X ^ i`.",
    "kind": "def",
    "type": "polynomial α"
  },
  {
    "name": "simple_graph.colorable",
    "statement": "def simple_graph.colorable {V : Type u} (G : simple_graph V) (n : ℕ) : Prop",
    "theorem": "{V : Type u} (G : simple_graph V) (n : ℕ) : Prop",
    "args": "{V : Type u} (G : simple_graph V) (n : ℕ)",
    "doc_string": "Whether a graph can be colored by at most `n` colors.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordinal.CNF",
    "statement": "def ordinal.CNF (b o : ordinal) : list (ordinal × ordinal)",
    "theorem": "(b o : ordinal) : list (ordinal × ordinal)",
    "args": "(b o : ordinal)",
    "doc_string": "The Cantor normal form of an ordinal `o` is the list of coefficients and exponents in the    base-`b` expansion of `o`.     `CNF b (b ^ u₁ * v₁ + b ^ u₂ * v₂) = [(u₁, v₁), (u₂, v₂)]`",
    "kind": "def",
    "type": "list (ordinal × ordinal)"
  },
  {
    "name": "add_magma.free_add_semigroup",
    "statement": "def add_magma.free_add_semigroup (α : Type u) [has_add α] : Type u",
    "theorem": "(α : Type u) [has_add α] : Type u",
    "args": "(α : Type u) [has_add α]",
    "doc_string": "Free additive semigroup over an additive magma.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "nzsnum.bit1",
    "statement": "def nzsnum.bit1  : nzsnum → nzsnum",
    "theorem": " : nzsnum → nzsnum",
    "args": "",
    "doc_string": "Add an active bit at the end of a `nzsnum`. This mimics `pos_num.bit1`.",
    "kind": "def",
    "type": "nzsnum → nzsnum"
  },
  {
    "name": "is_adic",
    "statement": "def is_adic {R : Type u_1} [comm_ring R] [H : topological_space R] (J : ideal R) : Prop",
    "theorem": "{R : Type u_1} [comm_ring R] [H : topological_space R] (J : ideal R) : Prop",
    "args": "{R : Type u_1} [comm_ring R] [H : topological_space R] (J : ideal R)",
    "doc_string": " Given a topology on a ring `R` and an ideal `J`, `is_adic J` means the topology is the `J`-adic one.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "cond",
    "statement": "def cond {a : Type u} : bool → a → a → a",
    "theorem": "{a : Type u} : bool → a → a → a",
    "args": "{a : Type u}",
    "doc_string": "`cond b x y` is `x` if `b = tt` and `y` otherwise.",
    "kind": "def",
    "type": "bool → a → a → a"
  },
  {
    "name": "szemeredi_regularity.step_bound",
    "statement": "def szemeredi_regularity.step_bound (n : ℕ) : ℕ",
    "theorem": "(n : ℕ) : ℕ",
    "args": "(n : ℕ)",
    "doc_string": " Auxiliary function for Szemerédi's regularity lemma. Blowing up a partition of size `n` during the induction results in a partition of size at most `step_bound n`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "first_order.language.term",
    "statement": "inductive first_order.language.term (L : first_order.language) (α : Type u') : Type (max u u')",
    "theorem": "(L : first_order.language) (α : Type u') : Type (max u u')",
    "args": "(L : first_order.language) (α : Type u')",
    "doc_string": "A term on `α` is either a variable indexed by an element of `α`  or a function symbol applied to simpler terms.",
    "kind": "inductive",
    "type": "Type (max u u')"
  },
  {
    "name": "normed_lattice_add_comm_group",
    "statement": "structure normed_lattice_add_comm_group (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Let `α` be a normed commutative group equipped with a partial order covariant with addition, with respect which `α` forms a lattice. Suppose that `α` is *solid*, that is to say, for `a` and `b` in `α`, with absolute values `|a|` and `|b|` respectively, `|a| ≤ |b|` implies `∥a∥ ≤ ∥b∥`. Then `α` is said to be a normed lattice ordered group.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "free_comm_ring.is_supported",
    "statement": "def free_comm_ring.is_supported {α : Type u} (x : free_comm_ring α) (s : set α) : Prop",
    "theorem": "{α : Type u} (x : free_comm_ring α) (s : set α) : Prop",
    "args": "{α : Type u} (x : free_comm_ring α) (s : set α)",
    "doc_string": "`is_supported x s` means that all monomials showing up in `x` have variables in `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subalgebra.centralizer",
    "statement": "def subalgebra.centralizer (R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A",
    "theorem": "(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A",
    "args": "(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A)",
    "doc_string": "The centralizer of a set as a subalgebra.",
    "kind": "def",
    "type": "subalgebra R A"
  },
  {
    "name": "part.none",
    "statement": "def part.none {α : Type u_1} : part α",
    "theorem": "{α : Type u_1} : part α",
    "args": "{α : Type u_1}",
    "doc_string": "The `none` value in `part` has a `false` domain and an empty function.",
    "kind": "def",
    "type": "part α"
  },
  {
    "name": "Top.sheaf_to_Type",
    "statement": "def Top.sheaf_to_Type (X : Top) (T : Type u) : Top.sheaf (Type u) X",
    "theorem": "(X : Top) (T : Type u) : Top.sheaf (Type u) X",
    "args": "(X : Top) (T : Type u)",
    "doc_string": "The sheaf of not-necessarily-continuous functions on `X` with values in a type `T`.",
    "kind": "def",
    "type": "Top.sheaf (Type u) X"
  },
  {
    "name": "ring_aut",
    "statement": "def ring_aut (R : Type u_1) [has_mul R] [has_add R] : Type u_1",
    "theorem": "(R : Type u_1) [has_mul R] [has_add R] : Type u_1",
    "args": "(R : Type u_1) [has_mul R] [has_add R]",
    "doc_string": "The group of ring automorphisms.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "AddCommGroup.binary_product_limit_cone",
    "statement": "def AddCommGroup.binary_product_limit_cone (G H : AddCommGroup) : category_theory.limits.limit_cone (category_theory.limits.pair G H)",
    "theorem": "(G H : AddCommGroup) : category_theory.limits.limit_cone (category_theory.limits.pair G H)",
    "args": "(G H : AddCommGroup)",
    "doc_string": "Construct limit data for a binary product in `AddCommGroup`, using `AddCommGroup.of (G × H)`.",
    "kind": "def",
    "type": "category_theory.limits.limit_cone (category_theory.limits.pair G H)"
  },
  {
    "name": "num.pred",
    "statement": "def num.pred  : num → num",
    "theorem": " : num → num",
    "args": "",
    "doc_string": "The predecessor of a `num` as a `num`, where `pred 0 = 0`.",
    "kind": "def",
    "type": "num → num"
  },
  {
    "name": "cochain_complex",
    "statement": "def cochain_complex (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : Type (max u u_1 v)",
    "theorem": "(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : Type (max u u_1 v)",
    "args": "(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (α : Type u_1) [add_right_cancel_semigroup α] [has_one α]",
    "doc_string": "An `α`-indexed cochain complex is a `homological_complex` in which `d i j ≠ 0` only if `i + 1 = j`.",
    "kind": "def",
    "type": "Type (max u u_1 v)"
  },
  {
    "name": "uniform_space.completion.dist_eq",
    "statement": "theorem uniform_space.completion.dist_eq {α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist ↑x ↑y = has_dist.dist x y",
    "theorem": "{α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist ↑x ↑y = has_dist.dist x y",
    "args": "{α : Type u} [pseudo_metric_space α] (x y : α)",
    "doc_string": "The new distance is an extension of the original distance.",
    "kind": "theorem",
    "type": "has_dist.dist ↑x ↑y = has_dist.dist x y"
  },
  {
    "name": "plift.bind",
    "statement": "def plift.bind {α : Sort u} {β : Sort v} (a : plift α) (f : α → plift β) : plift β",
    "theorem": "{α : Sort u} {β : Sort v} (a : plift α) (f : α → plift β) : plift β",
    "args": "{α : Sort u} {β : Sort v} (a : plift α) (f : α → plift β)",
    "doc_string": "Monadic bind.",
    "kind": "def",
    "type": "plift β"
  },
  {
    "name": "fin.tail_init_eq_init_tail",
    "statement": "theorem fin.tail_init_eq_init_tail {n : ℕ} {β : Type u_1} (q : fin (n + 2) → β) : fin.tail (fin.init q) = fin.init (fin.tail q)",
    "theorem": "{n : ℕ} {β : Type u_1} (q : fin (n + 2) → β) : fin.tail (fin.init q) = fin.init (fin.tail q)",
    "args": "{n : ℕ} {β : Type u_1} (q : fin (n + 2) → β)",
    "doc_string": " `tail` and `init` commute. We state this lemma in a non-dependent setting, as otherwise it would involve a cast to convince Lean that the two types are equal, making it harder to use.",
    "kind": "theorem",
    "type": "fin.tail (fin.init q) = fin.init (fin.tail q)"
  },
  {
    "name": "subfield.gi",
    "statement": "def subfield.gi (K : Type u) [field K] : galois_insertion subfield.closure coe",
    "theorem": "(K : Type u) [field K] : galois_insertion subfield.closure coe",
    "args": "(K : Type u) [field K]",
    "doc_string": "`closure` forms a Galois insertion with the coercion to set.",
    "kind": "def",
    "type": "galois_insertion subfield.closure coe"
  },
  {
    "name": "has_deriv_at_exp_zero",
    "statement": "theorem has_deriv_at_exp_zero {𝕂 : Type u_1} [is_R_or_C 𝕂] : has_deriv_at (exp 𝕂) 1 0",
    "theorem": "{𝕂 : Type u_1} [is_R_or_C 𝕂] : has_deriv_at (exp 𝕂) 1 0",
    "args": "{𝕂 : Type u_1} [is_R_or_C 𝕂]",
    "doc_string": "The exponential map in `𝕂 = ℝ` or `𝕂 = ℂ` has derivative `1` at zero.",
    "kind": "theorem",
    "type": "has_deriv_at (exp 𝕂) 1 0"
  },
  {
    "name": "cauchy_seq_tendsto_of_complete",
    "statement": "theorem cauchy_seq_tendsto_of_complete {α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] [complete_space α] {u : β → α} (H : cauchy_seq u) : ∃ (x : α), filter.tendsto u filter.at_top (nhds x)",
    "theorem": "{α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] [complete_space α] {u : β → α} (H : cauchy_seq u) : ∃ (x : α), filter.tendsto u filter.at_top (nhds x)",
    "args": "{α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] [complete_space α] {u : β → α} (H : cauchy_seq u)",
    "doc_string": "A Cauchy sequence in a complete space converges",
    "kind": "theorem",
    "type": "∃ (x : α), filter.tendsto u filter.at_top (nhds x)"
  },
  {
    "name": "clopen_upper_set",
    "statement": "structure clopen_upper_set (α : Type u_3) [topological_space α] [has_le α] : Type u_3",
    "theorem": "(α : Type u_3) [topological_space α] [has_le α] : Type u_3",
    "args": "(α : Type u_3) [topological_space α] [has_le α]",
    "doc_string": "The type of clopen upper sets of a topological space.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "indexed_partition.setoid",
    "statement": "def indexed_partition.setoid {ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) : setoid α",
    "theorem": "{ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) : setoid α",
    "args": "{ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s)",
    "doc_string": " The equivalence relation associated to an indexed partition. Two elements are equivalent if they belong to the same set of the partition.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "plift.seq",
    "statement": "def plift.seq {α : Sort u} {β : Sort v} (f : plift (α → β)) (x : plift α) : plift β",
    "theorem": "{α : Sort u} {β : Sort v} (f : plift (α → β)) (x : plift α) : plift β",
    "args": "{α : Sort u} {β : Sort v} (f : plift (α → β)) (x : plift α)",
    "doc_string": "Applicative sequencing.",
    "kind": "def",
    "type": "plift β"
  },
  {
    "name": "add_commute.add_right",
    "statement": "theorem add_commute.add_right {S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)",
    "theorem": "{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)",
    "args": "{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c)",
    "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their sum.",
    "kind": "theorem",
    "type": "add_commute a (b + c)"
  },
  {
    "name": "has_nndist",
    "statement": "structure has_nndist (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A version of `has_dist` that takes value in `ℝ≥0`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "tactic.pattern",
    "statement": "structure tactic.pattern  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " A pattern is an expression `target` containing temporary metavariables. A pattern also contains a list of `outputs` which also depend on these temporary metavariables. When we run `match p e`, the system will match `p.target` with `e` and assign the temporary metavariables. It then returns the outputs with the assigned variables.  ## Fields  - `target` Term to match. Contains temporary metavariables. - `uoutput` List of universes that are returned on a successful match. - `moutput` List of expressions that are returned on a successful match. - `nuvars` Number of (temporary) universe metavariables in this pattern. - `nmvars` Number of (temporary) metavariables in this pattern.  ## Example  The pattern for `list.cons h t` returning `h` and `t` would be ```lean { target  := `(@list.cons ?x_0 ?x_1 ?x_2),   uoutput := [],   moutput := [?x_1,?x_2],   nuvars  := 0,   nmvars  := 3 } ```",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "turing.tape",
    "statement": "structure turing.tape (Γ : Type u_1) [inhabited Γ] : Type u_1",
    "theorem": "(Γ : Type u_1) [inhabited Γ] : Type u_1",
    "args": "(Γ : Type u_1) [inhabited Γ]",
    "doc_string": " The tape of a Turing machine is composed of a head element (which we imagine to be the current position of the head), together with two `list_blank`s denoting the portions of the tape going off to the left and right. When the Turing machine moves right, an element is pulled from the right side and becomes the new head, while the head element is consed onto the left side.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "real.sinh_surjective",
    "statement": "theorem real.sinh_surjective  : function.surjective real.sinh",
    "theorem": " : function.surjective real.sinh",
    "args": "",
    "doc_string": "`sinh` is surjective, `∀ b, ∃ a, sinh a = b`. In this case, we use `a = arsinh b`.",
    "kind": "theorem",
    "type": "function.surjective real.sinh"
  },
  {
    "name": "bounded_space",
    "statement": "structure bounded_space (α : Type u_4) [bornology α] : Prop",
    "theorem": "(α : Type u_4) [bornology α] : Prop",
    "args": "(α : Type u_4) [bornology α]",
    "doc_string": "A space with a `bornology` is a **bounded space** if `set.univ : set α` is bounded.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "AddMon.has_limits_of_size",
    "statement": "def AddMon.has_limits_of_size  : category_theory.limits.has_limits_of_size AddMon",
    "theorem": " : category_theory.limits.has_limits_of_size AddMon",
    "args": "",
    "doc_string": "The category of additive monoids has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size AddMon"
  },
  {
    "name": "array.push_back",
    "statement": "def array.push_back {n : ℕ} {α : Type u} (a : array n α) (v : α) : array (n + 1) α",
    "theorem": "{n : ℕ} {α : Type u} (a : array n α) (v : α) : array (n + 1) α",
    "args": "{n : ℕ} {α : Type u} (a : array n α) (v : α)",
    "doc_string": "`push_back a v` pushes value `v` to the end of the array. Has builtin VM implementation.",
    "kind": "def",
    "type": "array (n + 1) α"
  },
  {
    "name": "mem_residual",
    "statement": "theorem mem_residual {α : Type u_1} [topological_space α] [baire_space α] {s : set α} : s ∈ residual α ↔ ∃ (t : set α) (H : t ⊆ s), is_Gδ t ∧ dense t",
    "theorem": "{α : Type u_1} [topological_space α] [baire_space α] {s : set α} : s ∈ residual α ↔ ∃ (t : set α) (H : t ⊆ s), is_Gδ t ∧ dense t",
    "args": "{α : Type u_1} [topological_space α] [baire_space α] {s : set α}",
    "doc_string": "A set is residual (comeagre) if and only if it includes a dense `Gδ` set.",
    "kind": "theorem",
    "type": "s ∈ residual α ↔ ∃ (t : set α) (H : t ⊆ s), is_Gδ t ∧ dense t"
  },
  {
    "name": "category_theory.large_groupoid",
    "statement": "def category_theory.large_groupoid (C : Type (u+1)) : Type (u+1)",
    "theorem": "(C : Type (u+1)) : Type (u+1)",
    "args": "(C : Type (u+1))",
    "doc_string": "A `large_groupoid` is a groupoid where the objects live in `Type (u+1)` while the morphisms live in `Type u`.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "le_nhds_iff",
    "statement": "theorem le_nhds_iff {α : Type u} [topological_space α] {f : filter α} {a : α} : f ≤ nhds a ↔ ∀ (s : set α), a ∈ s → is_open s → s ∈ f",
    "theorem": "{α : Type u} [topological_space α] {f : filter α} {a : α} : f ≤ nhds a ↔ ∀ (s : set α), a ∈ s → is_open s → s ∈ f",
    "args": "{α : Type u} [topological_space α] {f : filter α} {a : α}",
    "doc_string": "A filter lies below the neighborhood filter at `a` iff it contains every open set around `a`.",
    "kind": "theorem",
    "type": "f ≤ nhds a ↔ ∀ (s : set α), a ∈ s → is_open s → s ∈ f"
  },
  {
    "name": "measure_theory.complex_measure",
    "statement": "def measure_theory.complex_measure (α : Type u_1) [measurable_space α] : Type u_1",
    "theorem": "(α : Type u_1) [measurable_space α] : Type u_1",
    "args": "(α : Type u_1) [measurable_space α]",
    "doc_string": "A `complex_measure` is a `ℂ`-vector_measure.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "tactic.ring_exp.prod_congr",
    "statement": "theorem tactic.ring_exp.prod_congr {α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p * ps = p' * ps'",
    "theorem": "{α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p * ps = p' * ps'",
    "args": "{α : Type u} [comm_semiring α] {p p' ps ps' : α}",
    "doc_string": "Congruence lemma for constructing `ex.prod`.",
    "kind": "theorem",
    "type": "p = p' → ps = ps' → p * ps = p' * ps'"
  },
  {
    "name": "complete_lattice_hom",
    "statement": "structure complete_lattice_hom (α : Type u_8) (β : Type u_9) [complete_lattice α] [complete_lattice β] : Type (max u_8 u_9)",
    "theorem": "(α : Type u_8) (β : Type u_9) [complete_lattice α] [complete_lattice β] : Type (max u_8 u_9)",
    "args": "(α : Type u_8) (β : Type u_9) [complete_lattice α] [complete_lattice β]",
    "doc_string": "The type of complete lattice homomorphisms from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_8 u_9)"
  },
  {
    "name": "compact_space",
    "statement": "structure compact_space (α : Type u_3) [topological_space α] : Prop",
    "theorem": "(α : Type u_3) [topological_space α] : Prop",
    "args": "(α : Type u_3) [topological_space α]",
    "doc_string": " Type class for compact spaces. Separation is sometimes included in the definition, especially in the French literature, but we do not include it here.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "submodule.has_distrib_pointwise_neg",
    "statement": "def submodule.has_distrib_pointwise_neg {R : Type u} [comm_semiring R] {A : Type u_1} [ring A] [algebra R A] : has_distrib_neg (submodule R A)",
    "theorem": "{R : Type u} [comm_semiring R] {A : Type u_1} [ring A] [algebra R A] : has_distrib_neg (submodule R A)",
    "args": "{R : Type u} [comm_semiring R] {A : Type u_1} [ring A] [algebra R A]",
    "doc_string": " `submodule.has_pointwise_neg` distributes over multiplication.  This is available as an instance in the `pointwise` locale.",
    "kind": "def",
    "type": "has_distrib_neg (submodule R A)"
  },
  {
    "name": "nat.log",
    "statement": "def nat.log (b : ℕ) : ℕ → ℕ",
    "theorem": "(b : ℕ) : ℕ → ℕ",
    "args": "(b : ℕ)",
    "doc_string": " `log b n`, is the logarithm of natural number `n` in base `b`. It returns the largest `k : ℕ` such that `b^k ≤ n`, so if `b^k = n`, it returns exactly `k`.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "vector.mmap",
    "statement": "def vector.mmap {m : Type u → Type u_1} [monad m] {α : Type u_2} {β : Type u} (f : α → m β) {n : ℕ} : vector α n → m (vector β n)",
    "theorem": "{m : Type u → Type u_1} [monad m] {α : Type u_2} {β : Type u} (f : α → m β) {n : ℕ} : vector α n → m (vector β n)",
    "args": "{m : Type u → Type u_1} [monad m] {α : Type u_2} {β : Type u} (f : α → m β) {n : ℕ}",
    "doc_string": " Apply a monadic function to each component of a vector, returning a vector inside the monad.",
    "kind": "def",
    "type": "vector α n → m (vector β n)"
  },
  {
    "name": "sub_nonpos_of_le",
    "statement": "theorem sub_nonpos_of_le {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ b → a - b ≤ 0",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ b → a - b ≤ 0",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of sub_nonpos`.",
    "kind": "theorem",
    "type": "a ≤ b → a - b ≤ 0"
  },
  {
    "name": "category_theory.grothendieck_topology.is_closed",
    "statement": "def category_theory.grothendieck_topology.is_closed {C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : Prop",
    "args": "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X)",
    "doc_string": "A sieve is closed for the Grothendieck topology if it contains every arrow it covers. In the case of the usual topology on a topological space, this means that the open cover contains every open set which it covers.  Note this has no relation to a closed subset of a topological space.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "rel_embedding",
    "statement": "structure rel_embedding {α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "theorem": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "args": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop)",
    "doc_string": " A relation embedding with respect to a given pair of relations `r` and `s` is an embedding `f : α ↪ β` such that `r a b ↔ s (f a) (f b)`.",
    "kind": "structure",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "category_theory.limits.has_zero_object.zero_is_initial",
    "statement": "def category_theory.limits.has_zero_object.zero_is_initial {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_initial 0",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.is_initial 0",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C]",
    "doc_string": "A zero object is in particular initial.",
    "kind": "def",
    "type": "category_theory.limits.is_initial 0"
  },
  {
    "name": "set.accumulate",
    "statement": "def set.accumulate {α : Type u_1} {β : Type u_2} [has_le α] (s : α → set β) (x : α) : set β",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_le α] (s : α → set β) (x : α) : set β",
    "args": "{α : Type u_1} {β : Type u_2} [has_le α] (s : α → set β) (x : α)",
    "doc_string": "`accumulate s` is the union of `s y` for `y ≤ x`.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "category_theory.yoneda.yoneda_full",
    "statement": "def category_theory.yoneda.yoneda_full {C : Type u₁} [category_theory.category C] : category_theory.full category_theory.yoneda",
    "theorem": "{C : Type u₁} [category_theory.category C] : category_theory.full category_theory.yoneda",
    "args": "{C : Type u₁} [category_theory.category C]",
    "doc_string": "The Yoneda embedding is full.  See <https://stacks.math.columbia.edu/tag/001P>.",
    "kind": "def",
    "type": "category_theory.full category_theory.yoneda"
  },
  {
    "name": "mul_action.fixed_by",
    "statement": "def mul_action.fixed_by (α : Type u) (β : Type v) [monoid α] [mul_action α β] (g : α) : set β",
    "theorem": "(α : Type u) (β : Type v) [monoid α] [mul_action α β] (g : α) : set β",
    "args": "(α : Type u) (β : Type v) [monoid α] [mul_action α β] (g : α)",
    "doc_string": "`fixed_by g` is the subfield of elements fixed by `g`.",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "ordnode.find_max'",
    "statement": "def ordnode.find_max' {α : Type u} : α → ordnode α → α",
    "theorem": "{α : Type u} : α → ordnode α → α",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Return the maximum element of the tree, or the provided default value.      find_max' 37 {1, 2, 3} = 3     find_max' 37 ∅ = 37",
    "kind": "def",
    "type": "α → ordnode α → α"
  },
  {
    "name": "tactic.list_Sigma",
    "statement": "def tactic.list_Sigma (T : Type u_1) : Type u_1",
    "theorem": "(T : Type u_1) : Type u_1",
    "args": "(T : Type u_1)",
    "doc_string": "A list, with a disjunctive meaning (like a list of inductive constructors, or subgoals)",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "tactic.norm_num.squarefree_helper",
    "statement": "def tactic.norm_num.squarefree_helper (n k : ℕ) : Prop",
    "theorem": "(n k : ℕ) : Prop",
    "args": "(n k : ℕ)",
    "doc_string": "A predicate representing partial progress in a proof of `squarefree`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "omega_complete_partial_order.chain",
    "statement": "def omega_complete_partial_order.chain (α : Type u) [preorder α] : Type u",
    "theorem": "(α : Type u) [preorder α] : Type u",
    "args": "(α : Type u) [preorder α]",
    "doc_string": " A chain is a monotone sequence.  See the definition on page 114 of [gunter1992].",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "fintype.card_of_is_empty",
    "statement": "theorem fintype.card_of_is_empty {α : Type u_1} [is_empty α] : fintype.card α = 0",
    "theorem": "{α : Type u_1} [is_empty α] : fintype.card α = 0",
    "args": "{α : Type u_1} [is_empty α]",
    "doc_string": " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about arbitrary `fintype` instances, use `fintype.card_eq_zero_iff`.",
    "kind": "theorem",
    "type": "fintype.card α = 0"
  },
  {
    "name": "emetric_space",
    "statement": "structure emetric_space (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "We now define `emetric_space`, extending `pseudo_emetric_space`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "mvqpf.prj",
    "statement": "def mvqpf.prj {n : ℕ} (i : fin2 n) (v : typevec n) : Type u",
    "theorem": "{n : ℕ} (i : fin2 n) (v : typevec n) : Type u",
    "args": "{n : ℕ} (i : fin2 n) (v : typevec n)",
    "doc_string": "The projection `i` functor",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "has_measurable_neg",
    "statement": "structure has_measurable_neg (G : Type u_1) [has_neg G] [measurable_space G] : Prop",
    "theorem": "(G : Type u_1) [has_neg G] [measurable_space G] : Prop",
    "args": "(G : Type u_1) [has_neg G] [measurable_space G]",
    "doc_string": "We say that a type `has_measurable_neg` if `x ↦ -x` is a measurable function.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "restrict_scalars.algebra",
    "statement": "def restrict_scalars.algebra (R : Type u_1) (S : Type u_2) (A : Type u_4) [semiring A] [comm_semiring S] [algebra S A] [comm_semiring R] [algebra R S] : algebra R (restrict_scalars R S A)",
    "theorem": "(R : Type u_1) (S : Type u_2) (A : Type u_4) [semiring A] [comm_semiring S] [algebra S A] [comm_semiring R] [algebra R S] : algebra R (restrict_scalars R S A)",
    "args": "(R : Type u_1) (S : Type u_2) (A : Type u_4) [semiring A] [comm_semiring S] [algebra S A] [comm_semiring R] [algebra R S]",
    "doc_string": "`R ⟶ S` induces `S-Alg ⥤ R-Alg`",
    "kind": "def",
    "type": "algebra R (restrict_scalars R S A)"
  },
  {
    "name": "generalized_continued_fraction.partial_numerators",
    "statement": "def generalized_continued_fraction.partial_numerators {α : Type u_1} (g : generalized_continued_fraction α) : seq α",
    "theorem": "{α : Type u_1} (g : generalized_continued_fraction α) : seq α",
    "args": "{α : Type u_1} (g : generalized_continued_fraction α)",
    "doc_string": "Returns the sequence of partial numerators `aᵢ` of `g`.",
    "kind": "def",
    "type": "seq α"
  },
  {
    "name": "multiset.decidable_forall_multiset",
    "statement": "def multiset.decidable_forall_multiset {α : Type u_1} {m : multiset α} {p : α → Prop} [hp : Π (a : α), decidable (p a)] : decidable (∀ (a : α), a ∈ m → p a)",
    "theorem": "{α : Type u_1} {m : multiset α} {p : α → Prop} [hp : Π (a : α), decidable (p a)] : decidable (∀ (a : α), a ∈ m → p a)",
    "args": "{α : Type u_1} {m : multiset α} {p : α → Prop} [hp : Π (a : α), decidable (p a)]",
    "doc_string": " If `p` is a decidable predicate, so is the predicate that all elements of a multiset satisfy `p`.",
    "kind": "def",
    "type": "decidable (∀ (a : α), a ∈ m → p a)"
  },
  {
    "name": "card_class_group_eq_one",
    "statement": "theorem card_class_group_eq_one {R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1",
    "theorem": "{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1",
    "args": "{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R]",
    "doc_string": "The class number of a principal ideal domain is `1`.",
    "kind": "theorem",
    "type": "fintype.card (class_group R K) = 1"
  },
  {
    "name": "list.sublists_len_aux",
    "statement": "def list.sublists_len_aux {α : Type u_1} {β : Type u_2} : ℕ → list α → (list α → β) → list β → list β",
    "theorem": "{α : Type u_1} {β : Type u_2} : ℕ → list α → (list α → β) → list β → list β",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": " Auxiliary function to construct the list of all sublists of a given length. Given an integer `n`, a list `l`, a function `f` and an auxiliary list `L`, it returns the list made of of `f` applied to all sublists of `l` of length `n`, concatenated with `L`.",
    "kind": "def",
    "type": "ℕ → list α → (list α → β) → list β → list β"
  },
  {
    "name": "finset.sigma",
    "statement": "def finset.sigma {ι : Type u_1} {α : ι → Type u_2} (s : finset ι) (t : Π (i : ι), finset (α i)) : finset (Σ (i : ι), α i)",
    "theorem": "{ι : Type u_1} {α : ι → Type u_2} (s : finset ι) (t : Π (i : ι), finset (α i)) : finset (Σ (i : ι), α i)",
    "args": "{ι : Type u_1} {α : ι → Type u_2} (s : finset ι) (t : Π (i : ι), finset (α i))",
    "doc_string": "`s.sigma t` is the finset of dependent pairs `⟨i, a⟩` such that `i ∈ s` and `a ∈ t i`.",
    "kind": "def",
    "type": "finset (Σ (i : ι), α i)"
  },
  {
    "name": "tactic.eliminate.constructor_info",
    "statement": "structure tactic.eliminate.constructor_info  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Information about a constructor. Contains:  - `cname`: the constructor's name. - `non_param_args`: information about the arguments of the constructor,   excluding the arguments induced by the parameters of the inductive type. - `num_non_param_args`: the length of `non_param_args`. - `rec_args`: the subset of `non_param_args` which are recursive constructor   arguments. - `num_rec_args`: the length of `rec_args`.  For example, take the constructor ```lean list.cons : ∀ {α} (x : α) (xs : list α), list α ``` `α` is a parameter of `list`, so `non_param_args` contains information about `x` and `xs`. `rec_args` contains information about `xs`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "continued_fraction.of",
    "statement": "def continued_fraction.of {K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : continued_fraction K",
    "theorem": "{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : continued_fraction K",
    "args": "{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K]",
    "doc_string": "Creates the continued fraction of a value.",
    "kind": "def",
    "type": "continued_fraction K"
  },
  {
    "name": "int.sqrt",
    "statement": "def int.sqrt (z : ℤ) : ℤ",
    "theorem": "(z : ℤ) : ℤ",
    "args": "(z : ℤ)",
    "doc_string": " `sqrt z` is the square root of an integer `z`. If `z` is positive, it returns the largest integer `r` such that `r * r ≤ n`. If it is negative, it returns `0`. For example, `sqrt (-1) = 0`, `sqrt 1 = 1`, `sqrt 2 = 1`",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "is_semisimple_module",
    "statement": "def is_semisimple_module (R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop",
    "theorem": "(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop",
    "args": "(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M]",
    "doc_string": "A module is semisimple when every submodule has a complement, or equivalently, the module  is a direct sum of simple modules.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bitvec.zero",
    "statement": "def bitvec.zero (n : ℕ) : bitvec n",
    "theorem": "(n : ℕ) : bitvec n",
    "args": "(n : ℕ)",
    "doc_string": "Create a zero bitvector",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "cardinal.powerlt",
    "statement": "def cardinal.powerlt (α β : cardinal) : cardinal",
    "theorem": "(α β : cardinal) : cardinal",
    "args": "(α β : cardinal)",
    "doc_string": "The function α^{<β}, defined to be sup_{γ < β} α^γ.  We index over {s : set β.out // #s < β } instead of {γ // γ < β}, because the latter lives in a  higher universe",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "set.image2",
    "statement": "def set.image2 {α : Type u_1} {β : Type u_3} {γ : Type u_5} (f : α → β → γ) (s : set α) (t : set β) : set γ",
    "theorem": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} (f : α → β → γ) (s : set α) (t : set β) : set γ",
    "args": "{α : Type u_1} {β : Type u_3} {γ : Type u_5} (f : α → β → γ) (s : set α) (t : set β)",
    "doc_string": "The image of a binary function `f : α → β → γ` as a function `set α → set β → set γ`.  Mathematically this should be thought of as the image of the corresponding function `α × β → γ`.",
    "kind": "def",
    "type": "set γ"
  },
  {
    "name": "wseq.ret",
    "statement": "def wseq.ret {α : Type u} (a : α) : wseq α",
    "theorem": "{α : Type u} (a : α) : wseq α",
    "args": "{α : Type u} (a : α)",
    "doc_string": "The monadic `return a` is a singleton list containing `a`.",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "bilin_form.is_Ortho",
    "statement": "def bilin_form.is_Ortho {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} (B : bilin_form R M) (v : n → M) : Prop",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} (B : bilin_form R M) (v : n → M) : Prop",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] {n : Type w} (B : bilin_form R M) (v : n → M)",
    "doc_string": " A set of vectors `v` is orthogonal with respect to some bilinear form `B` if and only if for all `i ≠ j`, `B (v i) (v j) = 0`. For orthogonality between two elements, use `bilin_form.is_ortho`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.as_empty_cone",
    "statement": "def category_theory.limits.as_empty_cone {C : Type u₁} [category_theory.category C] (X : C) : category_theory.limits.cone (category_theory.functor.empty C)",
    "theorem": "{C : Type u₁} [category_theory.category C] (X : C) : category_theory.limits.cone (category_theory.functor.empty C)",
    "args": "{C : Type u₁} [category_theory.category C] (X : C)",
    "doc_string": "Construct a cone for the empty diagram given an object.",
    "kind": "def",
    "type": "category_theory.limits.cone (category_theory.functor.empty C)"
  },
  {
    "name": "sup_hom.const",
    "statement": "def sup_hom.const (α : Type u_3) {β : Type u_4} [has_sup α] [semilattice_sup β] (b : β) : sup_hom α β",
    "theorem": "(α : Type u_3) {β : Type u_4} [has_sup α] [semilattice_sup β] (b : β) : sup_hom α β",
    "args": "(α : Type u_3) {β : Type u_4} [has_sup α] [semilattice_sup β] (b : β)",
    "doc_string": "The constant function as a `sup_hom`.",
    "kind": "def",
    "type": "sup_hom α β"
  },
  {
    "name": "laurent_polynomial.T",
    "statement": "def laurent_polynomial.T {R : Type u_1} [semiring R] (n : ℤ) : laurent_polynomial R",
    "theorem": "{R : Type u_1} [semiring R] (n : ℤ) : laurent_polynomial R",
    "args": "{R : Type u_1} [semiring R] (n : ℤ)",
    "doc_string": "  The function `n ↦ T ^ n`, implemented as a sequence `ℤ → R[T;T⁻¹]`.  Using directly `T ^ n` does not work, since we want the exponents to be of Type `ℤ` and there is no `ℤ`-power defined on `R[T;T⁻¹]`.  Using that `T` is a unit introduces extra coercions. For these reasons, the definition of `T` is as a sequence.",
    "kind": "def",
    "type": "laurent_polynomial R"
  },
  {
    "name": "computability.encode_num",
    "statement": "def computability.encode_num  : num → list bool",
    "theorem": " : num → list bool",
    "args": "",
    "doc_string": "An encoding function of the binary numbers in bool.",
    "kind": "def",
    "type": "num → list bool"
  },
  {
    "name": "SemiRing",
    "statement": "def SemiRing  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of semirings.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "intermediate_field.insert",
    "statement": "structure intermediate_field.insert {α : Type u_3} (s : set α) : Type u_3",
    "theorem": "{α : Type u_3} (s : set α) : Type u_3",
    "args": "{α : Type u_3} (s : set α)",
    "doc_string": "Variation on `set.insert` to enable good notation for adjoining elements to fields. Used to preferentially use `singleton` rather than `insert` when adjoining one element.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "Algebra",
    "statement": "structure Algebra (R : Type u) [comm_ring R] : Type (max u (v+1))",
    "theorem": "(R : Type u) [comm_ring R] : Type (max u (v+1))",
    "args": "(R : Type u) [comm_ring R]",
    "doc_string": "The category of R-algebras and their morphisms.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "neg_ray_of_ne_zero",
    "statement": "theorem neg_ray_of_ne_zero (R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ≠ 0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _",
    "theorem": "(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ≠ 0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _",
    "args": "(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ≠ 0)",
    "doc_string": "The ray given by the negation of a nonzero vector.",
    "kind": "theorem",
    "type": "-ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _"
  },
  {
    "name": "subfield.sub_mem",
    "statement": "theorem subfield.sub_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x - y ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x - y ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K) {x y : K}",
    "doc_string": "A subfield is closed under subtraction.",
    "kind": "theorem",
    "type": "x ∈ s → y ∈ s → x - y ∈ s"
  },
  {
    "name": "add_con.pi",
    "statement": "def add_con.pi {ι : Type u_1} {f : ι → Type u_2} [Π (i : ι), has_add (f i)] (C : Π (i : ι), add_con (f i)) : add_con (Π (i : ι), f i)",
    "theorem": "{ι : Type u_1} {f : ι → Type u_2} [Π (i : ι), has_add (f i)] (C : Π (i : ι), add_con (f i)) : add_con (Π (i : ι), f i)",
    "args": "{ι : Type u_1} {f : ι → Type u_2} [Π (i : ι), has_add (f i)] (C : Π (i : ι), add_con (f i))",
    "doc_string": "The product of an indexed collection of additive congruence relations.",
    "kind": "def",
    "type": "add_con (Π (i : ι), f i)"
  },
  {
    "name": "is_add_unit.is_add_regular",
    "statement": "theorem is_add_unit.is_add_regular {R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a",
    "theorem": "{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a",
    "args": "{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a)",
    "doc_string": "An additive unit in an additive monoid is add-regular.",
    "kind": "theorem",
    "type": "is_add_regular a"
  },
  {
    "name": "list.product",
    "statement": "def list.product {α : Type u_1} {β : Type u_2} (l₁ : list α) (l₂ : list β) : list (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} (l₁ : list α) (l₂ : list β) : list (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} (l₁ : list α) (l₂ : list β)",
    "doc_string": "`product l₁ l₂` is the list of pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂`.      product [1, 2] [5, 6] = [(1, 5), (1, 6), (2, 5), (2, 6)]",
    "kind": "def",
    "type": "list (α × β)"
  },
  {
    "name": "wseq.map",
    "statement": "def wseq.map {α : Type u} {β : Type v} (f : α → β) : wseq α → wseq β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : wseq α → wseq β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": "Map a function over a weak sequence",
    "kind": "def",
    "type": "wseq α → wseq β"
  },
  {
    "name": "continuous_order_hom_class",
    "statement": "structure continuous_order_hom_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [topological_space α] [topological_space β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [topological_space α] [topological_space β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [topological_space α] [topological_space β]",
    "doc_string": " `continuous_order_hom_class F α β` states that `F` is a type of continuous monotone maps.  You should extend this class when you extend `continuous_order_hom`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "cardinal.aleph'",
    "statement": "def cardinal.aleph'  : ordinal → cardinal",
    "theorem": " : ordinal → cardinal",
    "args": "",
    "doc_string": "The `aleph'` function gives the cardinals listed by their ordinal  index, and is the inverse of `aleph_idx`.  `aleph' n = n`, `aleph' ω = ω`, `aleph' (ω + 1) = succ ℵ₀`, etc.",
    "kind": "def",
    "type": "ordinal → cardinal"
  },
  {
    "name": "fin.div_nat",
    "statement": "def fin.div_nat {n m : ℕ} (i : fin (m * n)) : fin m",
    "theorem": "{n m : ℕ} (i : fin (m * n)) : fin m",
    "args": "{n m : ℕ} (i : fin (m * n))",
    "doc_string": "Compute `i / n`, where `n` is a `nat` and inferred the type of `i`.",
    "kind": "def",
    "type": "fin m"
  },
  {
    "name": "quadratic_form.proj",
    "statement": "def quadratic_form.proj {R₁ : Type u_4} [comm_ring R₁] {n : Type u_5} (i j : n) : quadratic_form R₁ (n → R₁)",
    "theorem": "{R₁ : Type u_4} [comm_ring R₁] {n : Type u_5} (i j : n) : quadratic_form R₁ (n → R₁)",
    "args": "{R₁ : Type u_4} [comm_ring R₁] {n : Type u_5} (i j : n)",
    "doc_string": "`proj i j` is the quadratic form mapping the vector `x : n → R₁` to `x i * x j`",
    "kind": "def",
    "type": "quadratic_form R₁ (n → R₁)"
  },
  {
    "name": "ordnode.remove_nth",
    "statement": "def ordnode.remove_nth {α : Type u} : ordnode α → ℕ → ordnode α",
    "theorem": "{α : Type u} : ordnode α → ℕ → ordnode α",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Remove the `i`th element of the set, by its index from left to right.      remove_nth {a, b, c, d} 2 = {a, b, d}     remove_nth {a, b, c, d} 5 = {a, b, c, d}",
    "kind": "def",
    "type": "ordnode α → ℕ → ordnode α"
  },
  {
    "name": "multiset.powerset",
    "statement": "def multiset.powerset {α : Type u_1} (s : multiset α) : multiset (multiset α)",
    "theorem": "{α : Type u_1} (s : multiset α) : multiset (multiset α)",
    "args": "{α : Type u_1} (s : multiset α)",
    "doc_string": "The power set of a multiset.",
    "kind": "def",
    "type": "multiset (multiset α)"
  },
  {
    "name": "sum.lift_rel",
    "statement": "inductive sum.lift_rel {α : Type u} {β : Type v} {γ : Type u_1} {δ : Type u_2} (r : α → γ → Prop) (s : β → δ → Prop) : α ⊕ β → γ ⊕ δ → Prop",
    "theorem": "{α : Type u} {β : Type v} {γ : Type u_1} {δ : Type u_2} (r : α → γ → Prop) (s : β → δ → Prop) : α ⊕ β → γ ⊕ δ → Prop",
    "args": "{α : Type u} {β : Type v} {γ : Type u_1} {δ : Type u_2} (r : α → γ → Prop) (s : β → δ → Prop)",
    "doc_string": " Lifts pointwise two relations between `α` and `γ` and between `β` and `δ` to a relation between `α ⊕ β` and `γ ⊕ δ`.",
    "kind": "inductive",
    "type": "α ⊕ β → γ ⊕ δ → Prop"
  },
  {
    "name": "multiset.inter",
    "statement": "def multiset.inter {α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "args": "{α : Type u_1} [decidable_eq α] (s t : multiset α)",
    "doc_string": "`s ∩ t` is the lattice meet operation with respect to the  multiset `≤`. The multiplicity of `a` in `s ∩ t` is the minimum  of the multiplicities in `s` and `t`.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "is_ring_hom.map_zero",
    "statement": "theorem is_ring_hom.map_zero {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : f 0 = 0",
    "theorem": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : f 0 = 0",
    "args": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f)",
    "doc_string": "Ring homomorphisms map zero to zero.",
    "kind": "theorem",
    "type": "f 0 = 0"
  },
  {
    "name": "quaternion_algebra",
    "statement": "structure quaternion_algebra (R : Type u_1) (a b : R) : Type u_1",
    "theorem": "(R : Type u_1) (a b : R) : Type u_1",
    "args": "(R : Type u_1) (a b : R)",
    "doc_string": " Quaternion algebra over a type with fixed coefficients $a=i^2$ and $b=j^2$. Implemented as a structure with four fields: `re`, `im_i`, `im_j`, and `im_k`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "matrix.cons_val_one",
    "statement": "theorem matrix.cons_val_one {α : Type u} {m : ℕ} (x : α) (u : fin m.succ → α) : matrix.vec_cons x u 1 = matrix.vec_head u",
    "theorem": "{α : Type u} {m : ℕ} (x : α) (u : fin m.succ → α) : matrix.vec_cons x u 1 = matrix.vec_head u",
    "args": "{α : Type u} {m : ℕ} (x : α) (u : fin m.succ → α)",
    "doc_string": "`![a, b, ...] 1` is equal to `b`.   The simplifier needs a special lemma for length `≥ 2`, in addition to  `cons_val_succ`, because `1 : fin 1 = 0 : fin 1`.",
    "kind": "theorem",
    "type": "matrix.vec_cons x u 1 = matrix.vec_head u"
  },
  {
    "name": "function.injective.nontrivial",
    "statement": "theorem function.injective.nontrivial {α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) : nontrivial β",
    "theorem": "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) : nontrivial β",
    "args": "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f)",
    "doc_string": "Pushforward a `nontrivial` instance along an injective function.",
    "kind": "theorem",
    "type": "nontrivial β"
  },
  {
    "name": "locally_bounded_map",
    "statement": "structure locally_bounded_map (α : Type u_6) (β : Type u_7) [bornology α] [bornology β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [bornology α] [bornology β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [bornology α] [bornology β]",
    "doc_string": "The type of bounded maps from `α` to `β`, the maps which send a bounded set to a bounded set.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "slim_check.sampleable_ext",
    "statement": "structure slim_check.sampleable_ext (α : Sort u) : Sort (max (imax (v+1) u) (v+2))",
    "theorem": "(α : Sort u) : Sort (max (imax (v+1) u) (v+2))",
    "args": "(α : Sort u)",
    "doc_string": " `sampleable_ext` generalizes the behavior of `sampleable` and makes it possible to express instances for types that do not lend themselves to introspection, such as `ℕ → ℕ`. If we test a quantification over functions the counter-examples cannot be shrunken or printed meaningfully.  For that purpose, `sampleable_ext` provides a proxy representation `proxy_repr` that can be printed and shrunken as well as interpreted (using `interp`) as an object of the right type.",
    "kind": "structure",
    "type": "Sort (max (imax (v+1) u) (v+2))"
  },
  {
    "name": "simple_graph.hasse",
    "statement": "def simple_graph.hasse (α : Type u_1) [preorder α] : simple_graph α",
    "theorem": "(α : Type u_1) [preorder α] : simple_graph α",
    "args": "(α : Type u_1) [preorder α]",
    "doc_string": "The Hasse diagram of an order as a simple graph. The graph of the covering relation.",
    "kind": "def",
    "type": "simple_graph α"
  },
  {
    "name": "nat.choose_le_middle",
    "statement": "theorem nat.choose_le_middle (r n : ℕ) : n.choose r ≤ n.choose (n / 2)",
    "theorem": "(r n : ℕ) : n.choose r ≤ n.choose (n / 2)",
    "args": "(r n : ℕ)",
    "doc_string": "`choose n r` is maximised when `r` is `n/2`.",
    "kind": "theorem",
    "type": "n.choose r ≤ n.choose (n / 2)"
  },
  {
    "name": "local_ring.of_nonunits_add",
    "statement": "theorem local_ring.of_nonunits_add {R : Type u} [comm_semiring R] [nontrivial R] (h : ∀ (a b : R), a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R) : local_ring R",
    "theorem": "{R : Type u} [comm_semiring R] [nontrivial R] (h : ∀ (a b : R), a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R) : local_ring R",
    "args": "{R : Type u} [comm_semiring R] [nontrivial R] (h : ∀ (a b : R), a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R)",
    "doc_string": "A semiring is local if it is nontrivial and the set of nonunits is closed under the addition.",
    "kind": "theorem",
    "type": "local_ring R"
  },
  {
    "name": "category_theory.idempotents.karoubi.category_theory.category",
    "statement": "def category_theory.idempotents.karoubi.category_theory.category {C : Type u_1} [category_theory.category C] : category_theory.category (category_theory.idempotents.karoubi C)",
    "theorem": "{C : Type u_1} [category_theory.category C] : category_theory.category (category_theory.idempotents.karoubi C)",
    "args": "{C : Type u_1} [category_theory.category C]",
    "doc_string": "The category structure on the karoubi envelope of a category.",
    "kind": "def",
    "type": "category_theory.category (category_theory.idempotents.karoubi C)"
  },
  {
    "name": "is_add_monoid_hom.id",
    "statement": "theorem is_add_monoid_hom.id {α : Type u} [add_zero_class α] : is_add_monoid_hom id",
    "theorem": "{α : Type u} [add_zero_class α] : is_add_monoid_hom id",
    "args": "{α : Type u} [add_zero_class α]",
    "doc_string": "The identity map is an additive monoid homomorphism.",
    "kind": "theorem",
    "type": "is_add_monoid_hom id"
  },
  {
    "name": "function.extfun",
    "statement": "def function.extfun (α : Sort u) (β : α → Sort v) : Sort (imax u v)",
    "theorem": "(α : Sort u) (β : α → Sort v) : Sort (imax u v)",
    "args": "(α : Sort u) (β : α → Sort v)",
    "doc_string": "The quotient of the function type by pointwise equality.",
    "kind": "def",
    "type": "Sort (imax u v)"
  },
  {
    "name": "order.cof",
    "statement": "def order.cof {α : Type u_1} (r : α → α → Prop) : cardinal",
    "theorem": "{α : Type u_1} (r : α → α → Prop) : cardinal",
    "args": "{α : Type u_1} (r : α → α → Prop)",
    "doc_string": "Cofinality of a reflexive order `≼`. This is the smallest cardinality  of a subset `S : set α` such that `∀ a, ∃ b ∈ S, a ≼ b`.",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "function.injective.nat_tendsto_at_top",
    "statement": "theorem function.injective.nat_tendsto_at_top {f : ℕ → ℕ} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top",
    "theorem": "{f : ℕ → ℕ} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top",
    "args": "{f : ℕ → ℕ} (hf : function.injective f)",
    "doc_string": "An injective sequence `f : ℕ → ℕ` tends to infinity at infinity.",
    "kind": "theorem",
    "type": "filter.tendsto f filter.at_top filter.at_top"
  },
  {
    "name": "bump_covering.ind",
    "statement": "def bump_covering.ind {ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) (x : X) (hx : x ∈ s) : ι",
    "theorem": "{ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) (x : X) (hx : x ∈ s) : ι",
    "args": "{ι : Type u} {X : Type v} [topological_space X] {s : set X} (f : bump_covering ι X s) (x : X) (hx : x ∈ s)",
    "doc_string": "Index of a bump function such that `fs i =ᶠ[𝓝 x] 1`.",
    "kind": "def",
    "type": "ι"
  },
  {
    "name": "dual_number",
    "statement": "def dual_number (R : Type u_1) : Type u_1",
    "theorem": "(R : Type u_1) : Type u_1",
    "args": "(R : Type u_1)",
    "doc_string": "The type of dual numbers, numbers of the form $a + bε$ where $ε^2 = 0$.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "module.free.rank_eq_card_choose_basis_index",
    "statement": "theorem module.free.rank_eq_card_choose_basis_index (R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)",
    "theorem": "(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)",
    "args": "(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M]",
    "doc_string": "The rank of a free module `M` over `R` is the cardinality of `choose_basis_index R M`.",
    "kind": "theorem",
    "type": "module.rank R M = cardinal.mk (module.free.choose_basis_index R M)"
  },
  {
    "name": "set.enumerate",
    "statement": "def set.enumerate {α : Type u_1} (sel : set α → option α) : set α → ℕ → option α",
    "theorem": "{α : Type u_1} (sel : set α → option α) : set α → ℕ → option α",
    "args": "{α : Type u_1} (sel : set α → option α)",
    "doc_string": " Given a choice function `sel`, enumerates the elements of a set in the order `a 0 = sel s`, `a 1 = sel (s \\ {a 0})`, `a 2 = sel (s \\ {a 0, a 1})`, ... and stops when `sel (s \\ {a 0, ..., a n}) = none`. Note that we don't require `sel` to be a choice function.",
    "kind": "def",
    "type": "set α → ℕ → option α"
  },
  {
    "name": "relation.cut_expand",
    "statement": "def relation.cut_expand {α : Type u_1} (r : α → α → Prop) (s' s : multiset α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s' s : multiset α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (s' s : multiset α)",
    "doc_string": "The relation that specifies valid moves in our hydra game. `cut_expand r s' s`  means that `s'` is obtained by removing one head `a ∈ s` and adding back an arbitrary  multiset `t` of heads such that all `a' ∈ t` satisfy `r a' a`.   This is most directly translated into `s' = s.erase a + t`, but `multiset.erase` requires  `decidable_eq α`, so we use the equivalent condition `s' + {a} = s + t` instead, which  is also easier to verify for explicit multisets `s'`, `s` and `t`.   We also don't include the condition `a ∈ s` because `s' + {a} = s + t` already  guarantees `a ∈ s + t`, and if `r` is irreflexive then `a ∉ t`, which is the  case when `r` is well-founded, the case we are primarily interested in.   The lemma `relation.cut_expand_iff` below converts between this convenient definition  and the direct translation when `r` is irreflexive.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ideal.mv_polynomial.mv_polynomial.ideal.is_jacobson",
    "statement": "def ideal.mv_polynomial.mv_polynomial.ideal.is_jacobson {R : Type u_1} [comm_ring R] {ι : Type u_2} [fintype ι] [ideal.is_jacobson R] : ideal.is_jacobson (mv_polynomial ι R)",
    "theorem": "{R : Type u_1} [comm_ring R] {ι : Type u_2} [fintype ι] [ideal.is_jacobson R] : ideal.is_jacobson (mv_polynomial ι R)",
    "args": "{R : Type u_1} [comm_ring R] {ι : Type u_2} [fintype ι] [ideal.is_jacobson R]",
    "doc_string": "General form of the nullstellensatz for Jacobson rings, since in a Jacobson ring we have  `Inf {P maximal | P ≥ I} = Inf {P prime | P ≥ I} = I.radical`. Fields are always Jacobson,  and in that special case this is (most of) the classical Nullstellensatz,  since `I(V(I))` is the intersection of maximal ideals containing `I`, which is then `I.radical`",
    "kind": "def",
    "type": "ideal.is_jacobson (mv_polynomial ι R)"
  },
  {
    "name": "prod.swap",
    "statement": "def prod.swap {α : Type u_1} {β : Type u_2} : α × β → β × α",
    "theorem": "{α : Type u_1} {β : Type u_2} : α × β → β × α",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": "Swap the factors of a product. `swap (a, b) = (b, a)`",
    "kind": "def",
    "type": "α × β → β × α"
  },
  {
    "name": "free_add_magma",
    "statement": "inductive free_add_magma (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "Free nonabelian additive magma over a given alphabet.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "stream.take",
    "statement": "def stream.take {α : Type u} : ℕ → stream α → list α",
    "theorem": "{α : Type u} : ℕ → stream α → list α",
    "args": "{α : Type u}",
    "doc_string": "`take n s` returns a list of the `n` first elements of stream `s`",
    "kind": "def",
    "type": "ℕ → stream α → list α"
  },
  {
    "name": "pSet.subset",
    "statement": "def pSet.subset  : pSet → pSet → Prop",
    "theorem": " : pSet → pSet → Prop",
    "args": "",
    "doc_string": " A pre-set is a subset of another pre-set if every element of the first family is extensionally equivalent to some element of the second family.",
    "kind": "def",
    "type": "pSet → pSet → Prop"
  },
  {
    "name": "category_theory.limits.has_zero_object_of_has_finite_biproducts",
    "statement": "def category_theory.limits.has_zero_object_of_has_finite_biproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_zero_object C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_zero_object C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C]",
    "doc_string": "A category with finite biproducts has a zero object.",
    "kind": "def",
    "type": "category_theory.limits.has_zero_object C"
  },
  {
    "name": "nontrivial",
    "statement": "structure nontrivial (α : Type u_3) : Prop",
    "theorem": "(α : Type u_3) : Prop",
    "args": "(α : Type u_3)",
    "doc_string": " Predicate typeclass for expressing that a type is not reduced to a single element. In rings, this is equivalent to `0 ≠ 1`. In vector spaces, this is equivalent to positive dimension.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "encodable.sorted_univ",
    "statement": "def encodable.sorted_univ (α : Type u_1) [fintype α] [encodable α] : list α",
    "theorem": "(α : Type u_1) [fintype α] [encodable α] : list α",
    "args": "(α : Type u_1) [fintype α] [encodable α]",
    "doc_string": "The elements of a `fintype` as a sorted list.",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "finset.exists_intermediate_set",
    "statement": "theorem finset.exists_intermediate_set {α : Type u_1} {A B : finset α} (i : ℕ) (h₁ : i + B.card ≤ A.card) (h₂ : B ⊆ A) : ∃ (C : finset α), B ⊆ C ∧ C ⊆ A ∧ C.card = i + B.card",
    "theorem": "{α : Type u_1} {A B : finset α} (i : ℕ) (h₁ : i + B.card ≤ A.card) (h₂ : B ⊆ A) : ∃ (C : finset α), B ⊆ C ∧ C ⊆ A ∧ C.card = i + B.card",
    "args": "{α : Type u_1} {A B : finset α} (i : ℕ) (h₁ : i + B.card ≤ A.card) (h₂ : B ⊆ A)",
    "doc_string": " Given a set `A` and a set `B` inside it, we can shrink `A` to any appropriate size, and keep `B` inside it.",
    "kind": "theorem",
    "type": "∃ (C : finset α), B ⊆ C ∧ C ⊆ A ∧ C.card = i + B.card"
  },
  {
    "name": "pfunctor.comp",
    "statement": "def pfunctor.comp (P₂ P₁ : pfunctor) : pfunctor",
    "theorem": "(P₂ P₁ : pfunctor) : pfunctor",
    "args": "(P₂ P₁ : pfunctor)",
    "doc_string": "functor composition for polynomial functors",
    "kind": "def",
    "type": "pfunctor"
  },
  {
    "name": "is_unit.submonoid",
    "statement": "def is_unit.submonoid (M : Type u_1) [monoid M] : submonoid M",
    "theorem": "(M : Type u_1) [monoid M] : submonoid M",
    "args": "(M : Type u_1) [monoid M]",
    "doc_string": "The submonoid consisting of the units of a monoid",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "category_theory.is_isomorphic",
    "statement": "def category_theory.is_isomorphic {C : Type u} [category_theory.category C] : C → C → Prop",
    "theorem": "{C : Type u} [category_theory.category C] : C → C → Prop",
    "args": "{C : Type u} [category_theory.category C]",
    "doc_string": "An object `X` is isomorphic to an object `Y`, if `X ≅ Y` is not empty.",
    "kind": "def",
    "type": "C → C → Prop"
  },
  {
    "name": "nat.lattice",
    "statement": "def nat.lattice  : lattice ℕ",
    "theorem": " : lattice ℕ",
    "args": "",
    "doc_string": " This instance is necessary, otherwise the lattice operations would be derived via conditionally_complete_linear_order_bot and marked as noncomputable.",
    "kind": "def",
    "type": "lattice ℕ"
  },
  {
    "name": "add_subsemigroup",
    "statement": "structure add_subsemigroup (M : Type u_4) [has_add M] : Type u_4",
    "theorem": "(M : Type u_4) [has_add M] : Type u_4",
    "args": "(M : Type u_4) [has_add M]",
    "doc_string": "An additive subsemigroup of an additive magma `M` is a subset closed under addition.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "Cauchy",
    "statement": "def Cauchy (α : Type u) [uniform_space α] : Type u",
    "theorem": "(α : Type u) [uniform_space α] : Type u",
    "args": "(α : Type u) [uniform_space α]",
    "doc_string": " Space of Cauchy filters  This is essentially the completion of a uniform space. The embeddings are the neighbourhood filters. This space is not minimal, the separated uniform space (i.e. quotiented on the intersection of all entourages) is necessary for this.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "is_total_preorder",
    "statement": "structure is_total_preorder (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": "`is_total_preorder X r` means that the binary relation `r` on `X` is total and a preorder.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordnode.take_aux",
    "statement": "def ordnode.take_aux {α : Type u} : ordnode α → ℕ → ordnode α",
    "theorem": "{α : Type u} : ordnode α → ℕ → ordnode α",
    "args": "{α : Type u}",
    "doc_string": " Auxiliary definition for `take`. (Can also be used in lieu of `take` if you know the index is within the range of the data structure.)      take_aux {a, b, c, d} 2 = {a, b}     take_aux {a, b, c, d} 5 = {a, b, c, d}",
    "kind": "def",
    "type": "ordnode α → ℕ → ordnode α"
  },
  {
    "name": "tactic.closure",
    "statement": "def tactic.closure  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "`closure` implements a disjoint set data structure using path compression optimization. For the sake of the scc algorithm, it also stores the preorder numbering of the equivalence graph of the local assumptions.  The `expr_map` encodes a directed forest by storing for every non-root node, a reference to its parent and a proof of equivalence between that node's expression and its parent's expression. Given that data structure, checking that two nodes belong to the same tree is easy and fast by repeatedly following the parent references until a root is reached. If both nodes have the same root, they belong to the same tree, i.e. their expressions are equivalent. The proof of equivalence can be formed by composing the proofs along the edges of the paths to the root.  More concretely, if we ignore preorder numbering, the set `{ {e₀,e₁,e₂,e₃}, {e₄,e₅} }` is represented as:  ```lean e₀ → ⊥      -- no parent, i.e. e₀ is a root e₁ → e₀, p₁ -- with p₁ : e₁ ↔ e₀ e₂ → e₁, p₂ -- with p₂ : e₂ ↔ e₁ e₃ → e₀, p₃ -- with p₃ : e₃ ↔ e₀ e₄ → ⊥      -- no parent, i.e. e₄ is a root e₅ → e₄, p₅ -- with p₅ : e₅ ↔ e₄ ```  We can check that `e₂` and `e₃` are equivalent by seeking the root of the tree of each. The parent of `e₂` is `e₁`, the parent of `e₁` is `e₀` and `e₀` does not have a parent, and thus, this is the root of its tree. The parent of `e₃` is `e₀` and it's also the root, the same as for `e₂` and they are therefore equivalent. We can build a proof of that equivalence by using transitivity on `p₂`, `p₁` and `p₃.symm` in that order.  Similarly, we can discover that `e₂` and `e₅` aren't equivalent.  A description of the path compression optimization can be found at: <https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Path_compression>",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "hash_map.keys",
    "statement": "def hash_map.keys {α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) : list α",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) : list α",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β)",
    "doc_string": "The list of keys in the map",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "continuous.connected_components_map",
    "statement": "def continuous.connected_components_map {α : Type u} [topological_space α] {β : Type u_1} [topological_space β] {f : α → β} (h : continuous f) : connected_components α → connected_components β",
    "theorem": "{α : Type u} [topological_space α] {β : Type u_1} [topological_space β] {f : α → β} (h : continuous f) : connected_components α → connected_components β",
    "args": "{α : Type u} [topological_space α] {β : Type u_1} [topological_space β] {f : α → β} (h : continuous f)",
    "doc_string": "Functoriality of `connected_components`",
    "kind": "def",
    "type": "connected_components α → connected_components β"
  },
  {
    "name": "fintype.subtype",
    "statement": "def fintype.subtype {α : Type u_1} {p : α → Prop} (s : finset α) (H : ∀ (x : α), x ∈ s ↔ p x) : fintype {x // p x}",
    "theorem": "{α : Type u_1} {p : α → Prop} (s : finset α) (H : ∀ (x : α), x ∈ s ↔ p x) : fintype {x // p x}",
    "args": "{α : Type u_1} {p : α → Prop} (s : finset α) (H : ∀ (x : α), x ∈ s ↔ p x)",
    "doc_string": " Given a predicate that can be represented by a finset, the subtype associated to the predicate is a fintype.",
    "kind": "def",
    "type": "fintype {x // p x}"
  },
  {
    "name": "add_monoid_algebra.grade_by",
    "statement": "def add_monoid_algebra.grade_by {M : Type u_1} {ι : Type u_2} (R : Type u_3) [decidable_eq M] [comm_semiring R] (f : M → ι) (i : ι) : submodule R (add_monoid_algebra R M)",
    "theorem": "{M : Type u_1} {ι : Type u_2} (R : Type u_3) [decidable_eq M] [comm_semiring R] (f : M → ι) (i : ι) : submodule R (add_monoid_algebra R M)",
    "args": "{M : Type u_1} {ι : Type u_2} (R : Type u_3) [decidable_eq M] [comm_semiring R] (f : M → ι) (i : ι)",
    "doc_string": "The submodule corresponding to each grade given by the degree function `f`.",
    "kind": "def",
    "type": "submodule R (add_monoid_algebra R M)"
  },
  {
    "name": "is_asymm",
    "statement": "structure is_asymm (α : Type u) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u) (r : α → α → Prop) : Prop",
    "args": "(α : Type u) (r : α → α → Prop)",
    "doc_string": " `is_asymm X r` means that the binary relation `r` on `X` is asymmetric, that is, `r a b → ¬ r b a`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "fintype.pi_finset",
    "statement": "def fintype.pi_finset {α : Type u_1} [decidable_eq α] [fintype α] {δ : α → Type u_4} (t : Π (a : α), finset (δ a)) : finset (Π (a : α), δ a)",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] {δ : α → Type u_4} (t : Π (a : α), finset (δ a)) : finset (Π (a : α), δ a)",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α] {δ : α → Type u_4} (t : Π (a : α), finset (δ a))",
    "doc_string": " Given for all `a : α` a finset `t a` of `δ a`, then one can define the finset `fintype.pi_finset t` of all functions taking values in `t a` for all `a`. This is the analogue of `finset.pi` where the base finset is `univ` (but formally they are not the same, as there is an additional condition `i ∈ finset.univ` in the `finset.pi` definition).",
    "kind": "def",
    "type": "finset (Π (a : α), δ a)"
  },
  {
    "name": "order_add_monoid_hom_class",
    "statement": "structure order_add_monoid_hom_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [add_zero_class α] [add_zero_class β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [add_zero_class α] [add_zero_class β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [preorder α] [preorder β] [add_zero_class α] [add_zero_class β]",
    "doc_string": " `order_add_monoid_hom_class F α β` states that `F` is a type of ordered monoid homomorphisms.  You should also extend this typeclass when you extend `order_add_monoid_hom`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "category_theory.limits.has_colimits",
    "statement": "def category_theory.limits.has_colimits (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`C` has all (small) colimits if it has colimits of every shape that is as big as its hom-sets.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_add_regular_zero",
    "statement": "theorem is_add_regular_zero {R : Type u_1} [add_zero_class R] : is_add_regular 0",
    "theorem": "{R : Type u_1} [add_zero_class R] : is_add_regular 0",
    "args": "{R : Type u_1} [add_zero_class R]",
    "doc_string": "If adding `0` on either side is the identity, `0` is regular.",
    "kind": "theorem",
    "type": "is_add_regular 0"
  },
  {
    "name": "finset.card",
    "statement": "def finset.card {α : Type u_1} (s : finset α) : ℕ",
    "theorem": "{α : Type u_1} (s : finset α) : ℕ",
    "args": "{α : Type u_1} (s : finset α)",
    "doc_string": "`s.card` is the number of elements of `s`, aka its cardinality.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "alexandroff.has_repr",
    "statement": "def alexandroff.has_repr {X : Type u_1} [has_repr X] : has_repr (alexandroff X)",
    "theorem": "{X : Type u_1} [has_repr X] : has_repr (alexandroff X)",
    "args": "{X : Type u_1} [has_repr X]",
    "doc_string": "The repr uses the notation from the `alexandroff` locale.",
    "kind": "def",
    "type": "has_repr (alexandroff X)"
  },
  {
    "name": "plift.map",
    "statement": "def plift.map {α : Sort u} {β : Sort v} (f : α → β) (a : plift α) : plift β",
    "theorem": "{α : Sort u} {β : Sort v} (f : α → β) (a : plift α) : plift β",
    "args": "{α : Sort u} {β : Sort v} (f : α → β) (a : plift α)",
    "doc_string": "Functorial action.",
    "kind": "def",
    "type": "plift β"
  },
  {
    "name": "simple_graph.connected_component",
    "statement": "def simple_graph.connected_component {V : Type u} (G : simple_graph V) : Type u",
    "theorem": "{V : Type u} (G : simple_graph V) : Type u",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": " The quotient of `V` by the `simple_graph.reachable` relation gives the connected components of a graph.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "not_is_regular_zero",
    "statement": "theorem not_is_regular_zero {R : Type u_1} [mul_zero_class R] [nontrivial R] : ¬is_regular 0",
    "theorem": "{R : Type u_1} [mul_zero_class R] [nontrivial R] : ¬is_regular 0",
    "args": "{R : Type u_1} [mul_zero_class R] [nontrivial R]",
    "doc_string": "In a non-trivial ring, the element `0` is not regular -- with typeclasses.",
    "kind": "theorem",
    "type": "¬is_regular 0"
  },
  {
    "name": "list.mbor",
    "statement": "def list.mbor {m : Type → Type v} [monad m] : list (m bool) → m bool",
    "theorem": "{m : Type → Type v} [monad m] : list (m bool) → m bool",
    "args": "{m : Type → Type v} [monad m]",
    "doc_string": " `mbor xs` runs the actions in `xs`, returning true if any of them returns true. `mbor` short-circuits, so if an action returns true, later actions are not run. This is a monadic version of `list.bor`.",
    "kind": "def",
    "type": "list (m bool) → m bool"
  },
  {
    "name": "add_group_filter_basis.uniform_space",
    "statement": "def add_group_filter_basis.uniform_space {G : Type u_1} [add_comm_group G] (B : add_group_filter_basis G) : uniform_space G",
    "theorem": "{G : Type u_1} [add_comm_group G] (B : add_group_filter_basis G) : uniform_space G",
    "args": "{G : Type u_1} [add_comm_group G] (B : add_group_filter_basis G)",
    "doc_string": " The uniform space structure associated to an abelian group filter basis via the associated topological abelian group structure.",
    "kind": "def",
    "type": "uniform_space G"
  },
  {
    "name": "exists_open_superset_and_is_compact_closure",
    "statement": "theorem exists_open_superset_and_is_compact_closure {α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] {K : set α} (hK : is_compact K) : ∃ (V : set α), is_open V ∧ K ⊆ V ∧ is_compact (closure V)",
    "theorem": "{α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] {K : set α} (hK : is_compact K) : ∃ (V : set α), is_open V ∧ K ⊆ V ∧ is_compact (closure V)",
    "args": "{α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] {K : set α} (hK : is_compact K)",
    "doc_string": "In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.",
    "kind": "theorem",
    "type": "∃ (V : set α), is_open V ∧ K ⊆ V ∧ is_compact (closure V)"
  },
  {
    "name": "pSet.embed",
    "statement": "def pSet.embed  : pSet",
    "theorem": " : pSet",
    "args": "",
    "doc_string": "Embedding of one universe in another",
    "kind": "def",
    "type": "pSet"
  },
  {
    "name": "finset.off_diag",
    "statement": "def finset.off_diag {α : Type u_1} (s : finset α) [decidable_eq α] : finset (α × α)",
    "theorem": "{α : Type u_1} (s : finset α) [decidable_eq α] : finset (α × α)",
    "args": "{α : Type u_1} (s : finset α) [decidable_eq α]",
    "doc_string": " Given a finite set `s`, the off-diagonal, `s.off_diag` is the set of pairs `(a, b)` with `a ≠ b` for `a, b ∈ s`.",
    "kind": "def",
    "type": "finset (α × α)"
  },
  {
    "name": "left.add_pos_of_nonneg_of_pos",
    "statement": "theorem left.add_pos_of_nonneg_of_pos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_nonneg_of_pos`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "implies.trans",
    "statement": "theorem implies.trans {p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r",
    "theorem": "{p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r",
    "args": "{p q r : Prop} (h₁ : implies p q) (h₂ : implies q r)",
    "doc_string": "Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`.",
    "kind": "theorem",
    "type": "implies p r"
  },
  {
    "name": "filter.has_involutive_inv",
    "statement": "def filter.has_involutive_inv {α : Type u_2} [has_involutive_inv α] : has_involutive_inv (filter α)",
    "theorem": "{α : Type u_2} [has_involutive_inv α] : has_involutive_inv (filter α)",
    "args": "{α : Type u_2} [has_involutive_inv α]",
    "doc_string": "Inversion is involutive on `filter α` if it is on `α`.",
    "kind": "def",
    "type": "has_involutive_inv (filter α)"
  },
  {
    "name": "cau_seq.const",
    "statement": "def cau_seq.const {α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] (abv : β → α) [is_absolute_value abv] (x : β) : cau_seq β abv",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] (abv : β → α) [is_absolute_value abv] (x : β) : cau_seq β abv",
    "args": "{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [ring β] (abv : β → α) [is_absolute_value abv] (x : β)",
    "doc_string": "The constant Cauchy sequence.",
    "kind": "def",
    "type": "cau_seq β abv"
  },
  {
    "name": "has_le.le.lt_or_eq_dec",
    "statement": "theorem has_le.le.lt_or_eq_dec {α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a < b ∨ a = b",
    "theorem": "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a < b ∨ a = b",
    "args": "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b)",
    "doc_string": "**Alias** of decidable.lt_or_eq_of_le`.",
    "kind": "theorem",
    "type": "a < b ∨ a = b"
  },
  {
    "name": "multiset.mem",
    "statement": "def multiset.mem {α : Type u_1} (a : α) (s : multiset α) : Prop",
    "theorem": "{α : Type u_1} (a : α) (s : multiset α) : Prop",
    "args": "{α : Type u_1} (a : α) (s : multiset α)",
    "doc_string": "`a ∈ s` means that `a` has nonzero multiplicity in `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lt_of_sub_neg",
    "statement": "theorem lt_of_sub_neg {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 → a < b",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 → a < b",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the forward direction of sub_neg`.",
    "kind": "theorem",
    "type": "a - b < 0 → a < b"
  },
  {
    "name": "finset.centroid_weights_apply",
    "statement": "theorem finset.centroid_weights_apply (k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) (i : ι) : finset.centroid_weights k s i = (↑(s.card))⁻¹",
    "theorem": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) (i : ι) : finset.centroid_weights k s i = (↑(s.card))⁻¹",
    "args": "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) (i : ι)",
    "doc_string": "`centroid_weights` at any point.",
    "kind": "theorem",
    "type": "finset.centroid_weights k s i = (↑(s.card))⁻¹"
  },
  {
    "name": "has_le.le.trans_eq",
    "statement": "theorem has_le.le.trans_eq {α : Type u} [preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c) : a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c) : a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c)",
    "doc_string": "**Alias** of le_of_le_of_eq`.",
    "kind": "theorem",
    "type": "a ≤ c"
  },
  {
    "name": "bundle.pullback",
    "statement": "def bundle.pullback {B : Type u_1} {B' : Type u_3} (f : B' → B) (E : B → Type u_2) (x : B') : Type u_2",
    "theorem": "{B : Type u_1} {B' : Type u_3} (f : B' → B) (E : B → Type u_2) (x : B') : Type u_2",
    "args": "{B : Type u_1} {B' : Type u_3} (f : B' → B) (E : B → Type u_2) (x : B')",
    "doc_string": " The pullback of a bundle `E` over a base `B` under a map `f : B' → B`, denoted by `pullback f E` or `f *ᵖ E`,  is the bundle over `B'` whose fiber over `b'` is `E (f b')`.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "pSet.type",
    "statement": "def pSet.type  : pSet → Type u",
    "theorem": " : pSet → Type u",
    "args": "",
    "doc_string": "The underlying type of a pre-set",
    "kind": "def",
    "type": "pSet → Type u"
  },
  {
    "name": "int.exists_lt_and_lt_iff_not_dvd",
    "statement": "theorem int.exists_lt_and_lt_iff_not_dvd (m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
    "theorem": "(m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
    "args": "(m : ℤ) {n : ℤ} (hn : 0 < n)",
    "doc_string": "If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`.",
    "kind": "theorem",
    "type": "(∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m"
  },
  {
    "name": "cardinal.has_pow",
    "statement": "def cardinal.has_pow  : has_pow cardinal cardinal",
    "theorem": " : has_pow cardinal cardinal",
    "args": "",
    "doc_string": "The cardinal exponential. `#α ^ #β` is the cardinal of `β → α`.",
    "kind": "def",
    "type": "has_pow cardinal cardinal"
  },
  {
    "name": "lie_algebra_self_module",
    "statement": "def lie_algebra_self_module {R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_module R L L",
    "theorem": "{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_module R L L",
    "args": "{R : Type u} {L : Type v} [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": "Every Lie algebra is a module over itself.",
    "kind": "def",
    "type": "lie_module R L L"
  },
  {
    "name": "environment.implicit_infer_kind",
    "statement": "inductive environment.implicit_infer_kind  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A marking on the binders of structures and inductives indicating   how this constructor should mark its parameters.        inductive foo       | one {} : foo -> foo   -- relaxed_implicit       | two ( ) : foo -> foo  -- explicit       | two [] : foo -> foo   -- implicit       | three : foo -> foo    -- relaxed implicit (default)",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "lie_algebra.orthogonal.S",
    "statement": "def lie_algebra.orthogonal.S (l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R",
    "theorem": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R",
    "args": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R]",
    "doc_string": "The split-signature diagonal matrix.",
    "kind": "def",
    "type": "matrix (l ⊕ l) (l ⊕ l) R"
  },
  {
    "name": "ordinal.deriv_bfamily",
    "statement": "def ordinal.deriv_bfamily (o : ordinal) (f : Π (b : ordinal), b < o → ordinal → ordinal) : ordinal → ordinal",
    "theorem": "(o : ordinal) (f : Π (b : ordinal), b < o → ordinal → ordinal) : ordinal → ordinal",
    "args": "(o : ordinal) (f : Π (b : ordinal), b < o → ordinal → ordinal)",
    "doc_string": "The derivative of a family of normal functions is the sequence of their common fixed points.",
    "kind": "def",
    "type": "ordinal → ordinal"
  },
  {
    "name": "category_theory.limits.has_binary_biproduct.of_has_binary_coproduct",
    "statement": "theorem category_theory.limits.has_binary_biproduct.of_has_binary_coproduct {C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y]",
    "doc_string": "In a preadditive category, if the coproduct of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists.",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_biproduct X Y"
  },
  {
    "name": "is_pred_archimedean",
    "statement": "structure is_pred_archimedean (α : Type u_2) [preorder α] [pred_order α] : Prop",
    "theorem": "(α : Type u_2) [preorder α] [pred_order α] : Prop",
    "args": "(α : Type u_2) [preorder α] [pred_order α]",
    "doc_string": " A `pred_order` is pred-archimedean if one can go from any two comparable elements by iterating `pred`",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "Preorder",
    "statement": "def Preorder  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of preorders.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "matrix.conj_transpose",
    "statement": "def matrix.conj_transpose {m : Type u_2} {n : Type u_3} {α : Type v} [has_star α] (M : matrix m n α) : matrix n m α",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} [has_star α] (M : matrix m n α) : matrix n m α",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} [has_star α] (M : matrix m n α)",
    "doc_string": "The conjugate transpose of a matrix defined in term of `star`.",
    "kind": "def",
    "type": "matrix n m α"
  },
  {
    "name": "Bipointed.hom",
    "statement": "structure Bipointed.hom (X Y : Bipointed) : Type u",
    "theorem": "(X Y : Bipointed) : Type u",
    "args": "(X Y : Bipointed)",
    "doc_string": "Morphisms in `Bipointed`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "category_theory.limits.has_binary_coproducts_of_has_colimit_pair",
    "statement": "theorem category_theory.limits.has_binary_coproducts_of_has_colimit_pair (C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C",
    "args": "(C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)]",
    "doc_string": "If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_coproducts C"
  },
  {
    "name": "finset.nat.antidiagonal_congr",
    "statement": "theorem finset.nat.antidiagonal_congr {n : ℕ} {p q : ℕ × ℕ} (hp : p ∈ finset.nat.antidiagonal n) (hq : q ∈ finset.nat.antidiagonal n) : p = q ↔ p.fst = q.fst",
    "theorem": "{n : ℕ} {p q : ℕ × ℕ} (hp : p ∈ finset.nat.antidiagonal n) (hq : q ∈ finset.nat.antidiagonal n) : p = q ↔ p.fst = q.fst",
    "args": "{n : ℕ} {p q : ℕ × ℕ} (hp : p ∈ finset.nat.antidiagonal n) (hq : q ∈ finset.nat.antidiagonal n)",
    "doc_string": "A point in the antidiagonal is determined by its first co-ordinate.",
    "kind": "theorem",
    "type": "p = q ↔ p.fst = q.fst"
  },
  {
    "name": "quaternion_group.order_of_xa",
    "statement": "theorem quaternion_group.order_of_xa {n : ℕ} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4",
    "theorem": "{n : ℕ} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4",
    "args": "{n : ℕ} [hpos : fact (0 < n)] (i : zmod (2 * n))",
    "doc_string": "If `0 < n`, then `xa i` has order 4.",
    "kind": "theorem",
    "type": "order_of (quaternion_group.xa i) = 4"
  },
  {
    "name": "proper_space",
    "statement": "structure proper_space (α : Type u) [pseudo_metric_space α] : Prop",
    "theorem": "(α : Type u) [pseudo_metric_space α] : Prop",
    "args": "(α : Type u) [pseudo_metric_space α]",
    "doc_string": "A pseudometric space is proper if all closed balls are compact.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "magma.free_semigroup.r",
    "statement": "inductive magma.free_semigroup.r (α : Type u) [has_mul α] : α → α → Prop",
    "theorem": "(α : Type u) [has_mul α] : α → α → Prop",
    "args": "(α : Type u) [has_mul α]",
    "doc_string": "Associativity relations for a magma.",
    "kind": "inductive",
    "type": "α → α → Prop"
  },
  {
    "name": "is_add_regular_add_iff",
    "statement": "theorem is_add_regular_add_iff {R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b",
    "theorem": "{R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b",
    "args": "{R : Type u_1} {a b : R} [add_comm_semigroup R]",
    "doc_string": "A sum is add-regular if and only if the summands are.",
    "kind": "theorem",
    "type": "is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b"
  },
  {
    "name": "has_faithful_vadd",
    "statement": "structure has_faithful_vadd (G : Type u_10) (P : Type u_11) [has_vadd G P] : Prop",
    "theorem": "(G : Type u_10) (P : Type u_11) [has_vadd G P] : Prop",
    "args": "(G : Type u_10) (P : Type u_11) [has_vadd G P]",
    "doc_string": "Typeclass for faithful actions.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "set.has_zpow",
    "statement": "def set.has_zpow {α : Type u_2} [has_one α] [has_mul α] [has_inv α] : has_pow (set α) ℤ",
    "theorem": "{α : Type u_2} [has_one α] [has_mul α] [has_inv α] : has_pow (set α) ℤ",
    "args": "{α : Type u_2} [has_one α] [has_mul α] [has_inv α]",
    "doc_string": " Repeated pointwise multiplication/division (not the same as pointwise repeated multiplication/division!) of a `set`. See note [pointwise nat action].",
    "kind": "def",
    "type": "has_pow (set α) ℤ"
  },
  {
    "name": "list.take_while",
    "statement": "def list.take_while {α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → list α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] : list α → list α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p]",
    "doc_string": "Get the longest initial segment of the list whose members all satisfy `p`.      take_while (λ x, x < 3) [0, 2, 5, 1] = [0, 2]",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "left.one_lt_mul_of_le_of_lt",
    "statement": "theorem left.one_lt_mul_of_le_of_lt {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_le_of_lt`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "function.is_fixed_pt.left_of_comp",
    "statement": "theorem function.is_fixed_pt.left_of_comp {α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x",
    "theorem": "{α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x",
    "args": "{α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x)",
    "doc_string": "If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`.",
    "kind": "theorem",
    "type": "function.is_fixed_pt f x"
  },
  {
    "name": "normed_group",
    "statement": "structure normed_group (E : Type u_6) : Type u_6",
    "theorem": "(E : Type u_6) : Type u_6",
    "args": "(E : Type u_6)",
    "doc_string": " A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines a metric space structure.",
    "kind": "structure",
    "type": "Type u_6"
  },
  {
    "name": "right_cancel_semigroup",
    "statement": "structure right_cancel_semigroup (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": "A `right_cancel_semigroup` is a semigroup such that `a * b = c * b` implies `a = c`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "nonote.has_mul",
    "statement": "def nonote.has_mul  : has_mul nonote",
    "theorem": " : has_mul nonote",
    "args": "",
    "doc_string": "Multiplication of ordinal notations",
    "kind": "def",
    "type": "has_mul nonote"
  },
  {
    "name": "enat.find",
    "statement": "def enat.find (P : ℕ → Prop) [decidable_pred P] : enat",
    "theorem": "(P : ℕ → Prop) [decidable_pred P] : enat",
    "args": "(P : ℕ → Prop) [decidable_pred P]",
    "doc_string": "The smallest `enat` satisfying a (decidable) predicate `P : ℕ → Prop`",
    "kind": "def",
    "type": "enat"
  },
  {
    "name": "set.has_star",
    "statement": "def set.has_star {α : Type u_1} [has_star α] : has_star (set α)",
    "theorem": "{α : Type u_1} [has_star α] : has_star (set α)",
    "args": "{α : Type u_1} [has_star α]",
    "doc_string": " The set `(star s : set α)` is defined as `{x | star x ∈ s}` in locale `pointwise`. In the usual case where `star` is involutive, it is equal to `{star s | x ∈ s}`, see `set.image_star`.",
    "kind": "def",
    "type": "has_star (set α)"
  },
  {
    "name": "graded_monoid.ghas_one",
    "statement": "structure graded_monoid.ghas_one {ι : Type u_1} (A : ι → Type u_2) [has_zero ι] : Type u_2",
    "theorem": "{ι : Type u_1} (A : ι → Type u_2) [has_zero ι] : Type u_2",
    "args": "{ι : Type u_1} (A : ι → Type u_2) [has_zero ι]",
    "doc_string": "A graded version of `has_one`, which must be of grade 0.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "left_distrib_class",
    "statement": "structure left_distrib_class (R : Type u_1) [has_mul R] [has_add R] : Type",
    "theorem": "(R : Type u_1) [has_mul R] [has_add R] : Type",
    "args": "(R : Type u_1) [has_mul R] [has_add R]",
    "doc_string": "A typeclass stating that multiplication is left distributive over addition.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "category_theory.has_injective_resolution",
    "statement": "structure category_theory.has_injective_resolution {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C)",
    "doc_string": "An object admits a injective resolution.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "set.unique_empty",
    "statement": "def set.unique_empty {α : Type u} [is_empty α] : unique (set α)",
    "theorem": "{α : Type u} [is_empty α] : unique (set α)",
    "args": "{α : Type u} [is_empty α]",
    "doc_string": "There is exactly one set of a type that is empty.",
    "kind": "def",
    "type": "unique (set α)"
  },
  {
    "name": "perfect_closure",
    "statement": "def perfect_closure (K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] : Type u",
    "theorem": "(K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] : Type u",
    "args": "(K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p]",
    "doc_string": "The perfect closure is the smallest extension that makes frobenius surjective.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "norm_one_class",
    "statement": "structure norm_one_class (α : Type u_5) [has_norm α] [has_one α] : Prop",
    "theorem": "(α : Type u_5) [has_norm α] [has_one α] : Prop",
    "args": "(α : Type u_5) [has_norm α] [has_one α]",
    "doc_string": " A mixin class with the axiom `∥1∥ = 1`. Many `normed_ring`s and all `normed_field`s satisfy this axiom.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "strict_mono_on",
    "statement": "def strict_mono_on {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) (s : set α)",
    "doc_string": " A function `f` is strictly monotone on `s` if, for all `a, b ∈ s`, `a < b` implies `f a < f b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "sign_type.cast",
    "statement": "def sign_type.cast {α : Type u_1} [has_zero α] [has_one α] [has_neg α] : sign_type → α",
    "theorem": "{α : Type u_1} [has_zero α] [has_one α] [has_neg α] : sign_type → α",
    "args": "{α : Type u_1} [has_zero α] [has_one α] [has_neg α]",
    "doc_string": " Turn a `sign_type` into zero, one, or minus one. This is a coercion instance, but note it is only a `has_coe_t` instance: see note [use has_coe_t].",
    "kind": "def",
    "type": "sign_type → α"
  },
  {
    "name": "parser.char_buf",
    "statement": "def parser.char_buf (s : char_buffer) : parser unit",
    "theorem": "(s : char_buffer) : parser unit",
    "args": "(s : char_buffer)",
    "doc_string": "Matches a whole char_buffer.  Does not consume input in case of failure.",
    "kind": "def",
    "type": "parser unit"
  },
  {
    "name": "zero_hom.has_zero",
    "statement": "def zero_hom.has_zero {M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] : has_zero (zero_hom M N)",
    "theorem": "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] : has_zero (zero_hom M N)",
    "args": "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N]",
    "doc_string": "`0` is the homomorphism sending all elements to `0`.",
    "kind": "def",
    "type": "has_zero (zero_hom M N)"
  },
  {
    "name": "category_theory.grothendieck_topology.complete_lattice",
    "statement": "def category_theory.grothendieck_topology.complete_lattice {C : Type u} [category_theory.category C] : complete_lattice (category_theory.grothendieck_topology C)",
    "theorem": "{C : Type u} [category_theory.category C] : complete_lattice (category_theory.grothendieck_topology C)",
    "args": "{C : Type u} [category_theory.category C]",
    "doc_string": "Construct a complete lattice from the `Inf`, but make the trivial and discrete topologies definitionally equal to the bottom and top respectively.",
    "kind": "def",
    "type": "complete_lattice (category_theory.grothendieck_topology C)"
  },
  {
    "name": "num.gcd_aux",
    "statement": "def num.gcd_aux  : ℕ → num → num → num",
    "theorem": " : ℕ → num → num → num",
    "args": "",
    "doc_string": "Auxiliary definition for `num.gcd`.",
    "kind": "def",
    "type": "ℕ → num → num → num"
  },
  {
    "name": "category_theory.idempotents.karoubi.hom",
    "statement": "structure category_theory.idempotents.karoubi.hom {C : Type u_1} [category_theory.category C] (P Q : category_theory.idempotents.karoubi C) : Type u_2",
    "theorem": "{C : Type u_1} [category_theory.category C] (P Q : category_theory.idempotents.karoubi C) : Type u_2",
    "args": "{C : Type u_1} [category_theory.category C] (P Q : category_theory.idempotents.karoubi C)",
    "doc_string": " A morphism `P ⟶ Q` in the category `karoubi C` is a morphism in the underlying category `C` which satisfies a relation, which in the preadditive case, expresses that it induces a map between the corresponding \"formal direct factors\" and that it vanishes on the complement formal direct factor.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "free_lie_algebra.of",
    "statement": "def free_lie_algebra.of (R : Type u) {X : Type v} [comm_ring R] : X → free_lie_algebra R X",
    "theorem": "(R : Type u) {X : Type v} [comm_ring R] : X → free_lie_algebra R X",
    "args": "(R : Type u) {X : Type v} [comm_ring R]",
    "doc_string": " The embedding of `X` into the free Lie algebra of `X` with coefficients in the commutative ring `R`.",
    "kind": "def",
    "type": "X → free_lie_algebra R X"
  },
  {
    "name": "pgame.restricted",
    "statement": "inductive pgame.restricted  : pgame → pgame → Type (u+1)",
    "theorem": " : pgame → pgame → Type (u+1)",
    "args": "",
    "doc_string": "`restricted x y` says that Left always has no more moves in `x` than in `y`,     and Right always has no more moves in `y` than in `x`",
    "kind": "inductive",
    "type": "pgame → pgame → Type (u+1)"
  },
  {
    "name": "free_group.reduce.eq_of_red",
    "statement": "theorem free_group.reduce.eq_of_red {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.reduce L₁ = free_group.reduce L₂",
    "theorem": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.reduce L₁ = free_group.reduce L₂",
    "args": "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂)",
    "doc_string": " If a word reduces to another word, then they have a common maximal reduction.",
    "kind": "theorem",
    "type": "free_group.reduce L₁ = free_group.reduce L₂"
  },
  {
    "name": "lt_inv_of_lt_inv",
    "statement": "theorem lt_inv_of_lt_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a < b⁻¹ → b < a⁻¹",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} : a < b⁻¹ → b < a⁻¹",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the forward direction of lt_inv'`.",
    "kind": "theorem",
    "type": "a < b⁻¹ → b < a⁻¹"
  },
  {
    "name": "omega.clause.append",
    "statement": "def omega.clause.append (c1 c2 : omega.clause) : omega.clause",
    "theorem": "(c1 c2 : omega.clause) : omega.clause",
    "args": "(c1 c2 : omega.clause)",
    "doc_string": "append two clauses by elementwise appending",
    "kind": "def",
    "type": "omega.clause"
  },
  {
    "name": "nat.dvd_left_iff_eq",
    "statement": "theorem nat.dvd_left_iff_eq {m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n",
    "theorem": "{m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n",
    "args": "{m n : ℕ}",
    "doc_string": "Two natural numbers are equal if and only if the have the same divisors.",
    "kind": "theorem",
    "type": "(∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n"
  },
  {
    "name": "multiset.choose",
    "statement": "def multiset.choose {α : Type u_1} (p : α → Prop) [decidable_pred p] (l : multiset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : multiset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : multiset α) (hp : ∃! (a : α), a ∈ l ∧ p a)",
    "doc_string": " Given a proof `hp` that there exists a unique `a ∈ l` such that `p a`, `choose p l hp` returns that `a`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "num.bit1",
    "statement": "def num.bit1  : num → num",
    "theorem": " : num → num",
    "args": "",
    "doc_string": "`bit1 n` appends a `1` to the end of `n`, where `bit1 n = n1`.",
    "kind": "def",
    "type": "num → num"
  },
  {
    "name": "ordnode.of_asc_list",
    "statement": "def ordnode.of_asc_list {α : Type u} : list α → ordnode α",
    "theorem": "{α : Type u} : list α → ordnode α",
    "args": "{α : Type u}",
    "doc_string": "O(n). Build a set from a list which is already sorted. Performs no comparisons.      of_asc_list [1, 2, 3] = {1, 2, 3}     of_asc_list [3, 2, 1] = precondition violation",
    "kind": "def",
    "type": "list α → ordnode α"
  },
  {
    "name": "multiset.union",
    "statement": "def multiset.union {α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s t : multiset α) : multiset α",
    "args": "{α : Type u_1} [decidable_eq α] (s t : multiset α)",
    "doc_string": "`s ∪ t` is the lattice join operation with respect to the  multiset `≤`. The multiplicity of `a` in `s ∪ t` is the maximum  of the multiplicities in `s` and `t`.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "hom_rel",
    "statement": "def hom_rel (C : Type u_1) [quiver C] : Sort (max (u_1+1) u_2 1)",
    "theorem": "(C : Type u_1) [quiver C] : Sort (max (u_1+1) u_2 1)",
    "args": "(C : Type u_1) [quiver C]",
    "doc_string": "A `hom_rel` on `C` consists of a relation on every hom-set.",
    "kind": "def",
    "type": "Sort (max (u_1+1) u_2 1)"
  },
  {
    "name": "embedding.metrizable_space",
    "statement": "theorem embedding.metrizable_space {X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f) : topological_space.metrizable_space X",
    "theorem": "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f) : topological_space.metrizable_space X",
    "args": "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f)",
    "doc_string": " Given an embedding of a topological space into a metrizable space, the source space is also metrizable.",
    "kind": "theorem",
    "type": "topological_space.metrizable_space X"
  },
  {
    "name": "bounded_continuous_function.metric_space",
    "statement": "def bounded_continuous_function.metric_space {α : Type u_1} {β : Type u_2} [topological_space α] [metric_space β] : metric_space (bounded_continuous_function α β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [metric_space β] : metric_space (bounded_continuous_function α β)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [metric_space β]",
    "doc_string": "The type of bounded continuous functions, with the uniform distance, is a metric space.",
    "kind": "def",
    "type": "metric_space (bounded_continuous_function α β)"
  },
  {
    "name": "is_poly",
    "statement": "inductive is_poly {α : Type u_1} : ((α → ℕ) → ℤ) → Prop",
    "theorem": "{α : Type u_1} : ((α → ℕ) → ℤ) → Prop",
    "args": "{α : Type u_1}",
    "doc_string": "A predicate asserting that a function is a multivariate integer polynomial.  (We are being a bit lazy here by allowing many representations for multiplication,  rather than only allowing monomials and addition, but the definition is equivalent  and this is easier to use.)",
    "kind": "inductive",
    "type": "((α → ℕ) → ℤ) → Prop"
  },
  {
    "name": "set.Ioi",
    "statement": "def set.Ioi {α : Type u_1} [preorder α] (a : α) : set α",
    "theorem": "{α : Type u_1} [preorder α] (a : α) : set α",
    "args": "{α : Type u_1} [preorder α] (a : α)",
    "doc_string": "Left-open right-infinite interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "vector.reverse_nth_zero",
    "statement": "theorem vector.reverse_nth_zero {n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.reverse.head = v.last",
    "theorem": "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.reverse.head = v.last",
    "args": "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)}",
    "doc_string": "The `last` element of a vector is the `head` of the `reverse` vector.",
    "kind": "theorem",
    "type": "v.reverse.head = v.last"
  },
  {
    "name": "vector.reverse",
    "statement": "def vector.reverse {n : ℕ} {α : Type u_1} (v : vector α n) : vector α n",
    "theorem": "{n : ℕ} {α : Type u_1} (v : vector α n) : vector α n",
    "args": "{n : ℕ} {α : Type u_1} (v : vector α n)",
    "doc_string": "Reverse a vector.",
    "kind": "def",
    "type": "vector α n"
  },
  {
    "name": "structure_groupoid.order_top",
    "statement": "def structure_groupoid.order_top {H : Type u} [topological_space H] : order_top (structure_groupoid H)",
    "theorem": "{H : Type u} [topological_space H] : order_top (structure_groupoid H)",
    "args": "{H : Type u} [topological_space H]",
    "doc_string": "Every structure groupoid is contained in the groupoid of all local homeomorphisms",
    "kind": "def",
    "type": "order_top (structure_groupoid H)"
  },
  {
    "name": "polynomial.reverse",
    "statement": "def polynomial.reverse {R : Type u_1} [semiring R] (f : polynomial R) : polynomial R",
    "theorem": "{R : Type u_1} [semiring R] (f : polynomial R) : polynomial R",
    "args": "{R : Type u_1} [semiring R] (f : polynomial R)",
    "doc_string": " The reverse of a polynomial f is the polynomial obtained by \"reading f backwards\". Even though this is not the actual definition, reverse f = f (1/X) * X ^ f.nat_degree.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "has_le.le.trans",
    "statement": "theorem has_le.le.trans {α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of le_trans`.",
    "kind": "theorem",
    "type": "a ≤ b → b ≤ c → a ≤ c"
  },
  {
    "name": "is_add_group_hom.id",
    "statement": "theorem is_add_group_hom.id {α : Type u} [add_group α] : is_add_group_hom id",
    "theorem": "{α : Type u} [add_group α] : is_add_group_hom id",
    "args": "{α : Type u} [add_group α]",
    "doc_string": "The identity is an additive group homomorphism.",
    "kind": "theorem",
    "type": "is_add_group_hom id"
  },
  {
    "name": "is_submonoid.multiset_prod_mem",
    "statement": "theorem is_submonoid.multiset_prod_mem {M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.prod ∈ s",
    "theorem": "{M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.prod ∈ s",
    "args": "{M : Type u_1} [comm_monoid M] {s : set M} (hs : is_submonoid s) (m : multiset M)",
    "doc_string": " The product of a multiset of elements of a submonoid of a `comm_monoid` is an element of the submonoid.",
    "kind": "theorem",
    "type": "(∀ (a : M), a ∈ m → a ∈ s) → m.prod ∈ s"
  },
  {
    "name": "sym2.to_rel",
    "statement": "def sym2.to_rel {α : Type u_1} (s : set (sym2 α)) (x y : α) : Prop",
    "theorem": "{α : Type u_1} (s : set (sym2 α)) (x y : α) : Prop",
    "args": "{α : Type u_1} (s : set (sym2 α)) (x y : α)",
    "doc_string": " The inverse to `sym2.from_rel`. Given a set on `sym2 α`, give a symmetric relation on `α` (see `sym2.to_rel_symmetric`).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "set.Iio",
    "statement": "def set.Iio {α : Type u_1} [preorder α] (a : α) : set α",
    "theorem": "{α : Type u_1} [preorder α] (a : α) : set α",
    "args": "{α : Type u_1} [preorder α] (a : α)",
    "doc_string": "Left-infinite right-open interval",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "lucas_lehmer.lucas_lehmer_residue",
    "statement": "def lucas_lehmer.lucas_lehmer_residue (p : ℕ) : zmod (2 ^ p - 1)",
    "theorem": "(p : ℕ) : zmod (2 ^ p - 1)",
    "args": "(p : ℕ)",
    "doc_string": "The Lucas-Lehmer residue is `s p (p-2)` in `zmod (2^p - 1)`.",
    "kind": "def",
    "type": "zmod (2 ^ p - 1)"
  },
  {
    "name": "open_subgroup",
    "statement": "structure open_subgroup (G : Type u_1) [group G] [topological_space G] : Type u_1",
    "theorem": "(G : Type u_1) [group G] [topological_space G] : Type u_1",
    "args": "(G : Type u_1) [group G] [topological_space G]",
    "doc_string": "The type of open subgroups of a topological group.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "applicative_transformation.id_transformation",
    "statement": "def applicative_transformation.id_transformation {F : Type u → Type v} [applicative F] [is_lawful_applicative F] : applicative_transformation F F",
    "theorem": "{F : Type u → Type v} [applicative F] [is_lawful_applicative F] : applicative_transformation F F",
    "args": "{F : Type u → Type v} [applicative F] [is_lawful_applicative F]",
    "doc_string": "The identity applicative transformation from an applicative functor to itself.",
    "kind": "def",
    "type": "applicative_transformation F F"
  },
  {
    "name": "category_theory.has_shift",
    "statement": "structure category_theory.has_shift (C : Type u) (A : Type u_2) [category_theory.category C] [add_monoid A] : Type (max u u_2 v)",
    "theorem": "(C : Type u) (A : Type u_2) [category_theory.category C] [add_monoid A] : Type (max u u_2 v)",
    "args": "(C : Type u) (A : Type u_2) [category_theory.category C] [add_monoid A]",
    "doc_string": " A category has a shift indexed by an additive monoid `A` if there is a monoidal functor from `A` to `C ⥤ C`.",
    "kind": "structure",
    "type": "Type (max u u_2 v)"
  },
  {
    "name": "ordered_semiring.to_char_zero",
    "statement": "theorem ordered_semiring.to_char_zero {R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R",
    "theorem": "{R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R",
    "args": "{R : Type u_1} [ordered_semiring R] [nontrivial R]",
    "doc_string": " Note this is not an instance as `char_zero` implies `nontrivial`, and this would risk forming a loop.",
    "kind": "theorem",
    "type": "char_zero R"
  },
  {
    "name": "category_theory.prod_comonad",
    "statement": "def category_theory.prod_comonad {C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : category_theory.comonad C",
    "theorem": "{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C] : category_theory.comonad C",
    "args": "{C : Type u} [category_theory.category C] (X : C) [category_theory.limits.has_binary_products C]",
    "doc_string": "`X ⨯ -` has a comonad structure. This is sometimes called the writer comonad.",
    "kind": "def",
    "type": "category_theory.comonad C"
  },
  {
    "name": "quotient_add_group.right_rel",
    "statement": "def quotient_add_group.right_rel {α : Type u_1} [add_group α] (s : add_subgroup α) : setoid α",
    "theorem": "{α : Type u_1} [add_group α] (s : add_subgroup α) : setoid α",
    "args": "{α : Type u_1} [add_group α] (s : add_subgroup α)",
    "doc_string": "The equivalence relation corresponding to the partition of a group by right cosets of a subgroup.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "directed_on",
    "statement": "def directed_on {α : Type u} (r : α → α → Prop) (s : set α) : Prop",
    "theorem": "{α : Type u} (r : α → α → Prop) (s : set α) : Prop",
    "args": "{α : Type u} (r : α → α → Prop) (s : set α)",
    "doc_string": "A subset of α is directed if there is an element of the set `≼`-above any  pair of elements in the set.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.Ici",
    "statement": "def finset.Ici {α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : finset α",
    "theorem": "{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : finset α",
    "args": "{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α)",
    "doc_string": "The finset of elements `x` such that `a ≤ x`. Basically `set.Ici a` as a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "two_pointing.bool",
    "statement": "def two_pointing.bool  : two_pointing bool",
    "theorem": " : two_pointing bool",
    "args": "",
    "doc_string": "The `ff`, `tt` two-pointing of `bool`.",
    "kind": "def",
    "type": "two_pointing bool"
  },
  {
    "name": "ordnode.filter",
    "statement": "def ordnode.filter {α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p]",
    "doc_string": "O(n). Filter the elements of a tree satisfying a predicate.      filter (λ x, x < 3) {1, 2, 4} = {1, 2}     filter (λ x, x > 5) {1, 2, 4} = ∅",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "first_order.language.card",
    "statement": "def first_order.language.card (L : first_order.language) : cardinal",
    "theorem": "(L : first_order.language) : cardinal",
    "args": "(L : first_order.language)",
    "doc_string": "The cardinality of a language is the cardinality of its type of symbols.",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "add_subgroup.centralizer",
    "statement": "def add_subgroup.centralizer {G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) : add_subgroup G",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G)",
    "doc_string": "The `centralizer` of `H` is the additive subgroup of `g : G` commuting with every `h : H`.",
    "kind": "def",
    "type": "add_subgroup G"
  },
  {
    "name": "model_prod",
    "statement": "def model_prod (H : Type u_1) (H' : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(H : Type u_1) (H' : Type u_2) : Type (max u_1 u_2)",
    "args": "(H : Type u_1) (H' : Type u_2)",
    "doc_string": " Same thing as `H × H'` We introduce it for technical reasons, see note [Manifold type tags].",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "set.Union",
    "statement": "def set.Union {β : Type u_2} {ι : Sort u_4} (s : ι → set β) : set β",
    "theorem": "{β : Type u_2} {ι : Sort u_4} (s : ι → set β) : set β",
    "args": "{β : Type u_2} {ι : Sort u_4} (s : ι → set β)",
    "doc_string": "Indexed union of a family of sets",
    "kind": "def",
    "type": "set β"
  },
  {
    "name": "zero_eq_mul",
    "statement": "theorem zero_eq_mul {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then the product of two elements equals zero iff one of them equals zero.",
    "kind": "theorem",
    "type": "0 = a * b ↔ a = 0 ∨ b = 0"
  },
  {
    "name": "invariant_basis_number",
    "statement": "structure invariant_basis_number (R : Type u) [semiring R] : Prop",
    "theorem": "(R : Type u) [semiring R] : Prop",
    "args": "(R : Type u) [semiring R]",
    "doc_string": "We say that `R` has the invariant basis number property if `(fin n → R) ≃ₗ[R] (fin m → R)`    implies `n = m`. This gives rise to a well-defined notion of rank of a finitely generated free    module.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "dense_inducing_pure",
    "statement": "theorem dense_inducing_pure {α : Type u} : dense_inducing has_pure.pure",
    "theorem": "{α : Type u} : dense_inducing has_pure.pure",
    "args": "{α : Type u}",
    "doc_string": "`pure : α → ultrafilter α` defines a dense inducing of `α` in `ultrafilter α`.",
    "kind": "theorem",
    "type": "dense_inducing has_pure.pure"
  },
  {
    "name": "exp_neg_inv_glue.f_aux_zero_eq",
    "statement": "theorem exp_neg_inv_glue.f_aux_zero_eq  : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue",
    "theorem": " : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue",
    "args": "",
    "doc_string": "The `0`-th auxiliary function `f_aux 0` coincides with `exp_neg_inv_glue`, by definition.",
    "kind": "theorem",
    "type": "exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue"
  },
  {
    "name": "affine_subspace",
    "statement": "structure affine_subspace (k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3",
    "theorem": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] : Type u_3",
    "args": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P]",
    "doc_string": " An `affine_subspace k P` is a subset of an `affine_space V P` that, if not empty, has an affine space structure induced by a corresponding subspace of the `module k V`.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "category_theory.limits.binary_bicone.to_cocone",
    "statement": "def category_theory.limits.binary_bicone.to_cocone {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cocone (category_theory.limits.pair P Q)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cocone (category_theory.limits.pair P Q)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q)",
    "doc_string": "Extract the cocone from a binary bicone.",
    "kind": "def",
    "type": "category_theory.limits.cocone (category_theory.limits.pair P Q)"
  },
  {
    "name": "subgroup.has_top",
    "statement": "def subgroup.has_top {G : Type u_1} [group G] : has_top (subgroup G)",
    "theorem": "{G : Type u_1} [group G] : has_top (subgroup G)",
    "args": "{G : Type u_1} [group G]",
    "doc_string": "The subgroup `G` of the group `G`.",
    "kind": "def",
    "type": "has_top (subgroup G)"
  },
  {
    "name": "locally_constant.discrete_quotient",
    "statement": "def locally_constant.discrete_quotient {X : Type u_1} [topological_space X] {α : Type u_2} (f : locally_constant X α) : discrete_quotient X",
    "theorem": "{X : Type u_1} [topological_space X] {α : Type u_2} (f : locally_constant X α) : discrete_quotient X",
    "args": "{X : Type u_1} [topological_space X] {α : Type u_2} (f : locally_constant X α)",
    "doc_string": "Any locally constant function induces a discrete quotient.",
    "kind": "def",
    "type": "discrete_quotient X"
  },
  {
    "name": "is_ring_hom.map_neg",
    "statement": "theorem is_ring_hom.map_neg {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x",
    "theorem": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x",
    "args": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f)",
    "doc_string": "Ring homomorphisms preserve additive inverses.",
    "kind": "theorem",
    "type": "f (-x) = -f x"
  },
  {
    "name": "galois_connection.closure_operator",
    "statement": "def galois_connection.closure_operator {α : Type u_1} {β : Type u_4} [partial_order α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u) : closure_operator α",
    "theorem": "{α : Type u_1} {β : Type u_4} [partial_order α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u) : closure_operator α",
    "args": "{α : Type u_1} {β : Type u_4} [partial_order α] [preorder β] {l : α → β} {u : β → α} (gc : galois_connection l u)",
    "doc_string": " Every Galois connection induces a closure operator given by the composition. This is the partial order version of the statement that every adjunction induces a monad.",
    "kind": "def",
    "type": "closure_operator α"
  },
  {
    "name": "set.sized.union",
    "statement": "theorem set.sized.union {α : Type u_1} {A B : set (finset α)} {r : ℕ} : set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)",
    "theorem": "{α : Type u_1} {A B : set (finset α)} {r : ℕ} : set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)",
    "args": "{α : Type u_1} {A B : set (finset α)} {r : ℕ}",
    "doc_string": "**Alias** of the reverse direction of set.sized_union`.",
    "kind": "theorem",
    "type": "set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)"
  },
  {
    "name": "num.shiftl",
    "statement": "def num.shiftl  : num → ℕ → num",
    "theorem": " : num → ℕ → num",
    "args": "",
    "doc_string": "Left-shift the binary representation of a `num`.",
    "kind": "def",
    "type": "num → ℕ → num"
  },
  {
    "name": "equiv.add_right",
    "statement": "def equiv.add_right {G : Type u_10} [add_group G] (a : G) : equiv.perm G",
    "theorem": "{G : Type u_10} [add_group G] (a : G) : equiv.perm G",
    "args": "{G : Type u_10} [add_group G] (a : G)",
    "doc_string": "Right addition in an `add_group` is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm G"
  },
  {
    "name": "dihedral_group.order_of_sr",
    "statement": "theorem dihedral_group.order_of_sr {n : ℕ} (i : zmod n) : order_of (dihedral_group.sr i) = 2",
    "theorem": "{n : ℕ} (i : zmod n) : order_of (dihedral_group.sr i) = 2",
    "args": "{n : ℕ} (i : zmod n)",
    "doc_string": "If `0 < n`, then `sr i` has order 2.",
    "kind": "theorem",
    "type": "order_of (dihedral_group.sr i) = 2"
  },
  {
    "name": "has_continuous_add",
    "statement": "structure has_continuous_add (M : Type u) [topological_space M] [has_add M] : Prop",
    "theorem": "(M : Type u) [topological_space M] [has_add M] : Prop",
    "args": "(M : Type u) [topological_space M] [has_add M]",
    "doc_string": " Basic hypothesis to talk about a topological additive monoid or a topological additive semigroup. A topological additive monoid over `M`, for example, is obtained by requiring both the instances `add_monoid M` and `has_continuous_add M`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "slim_check.sampleable",
    "statement": "structure slim_check.sampleable (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " `sampleable α` provides ways of creating examples of type `α`, and given such an example `x : α`, gives us a way to shrink it and find simpler examples.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "set.pi",
    "statement": "def set.pi {ι : Type u_1} {α : ι → Type u_2} (s : set ι) (t : Π (i : ι), set (α i)) : set (Π (i : ι), α i)",
    "theorem": "{ι : Type u_1} {α : ι → Type u_2} (s : set ι) (t : Π (i : ι), set (α i)) : set (Π (i : ι), α i)",
    "args": "{ι : Type u_1} {α : ι → Type u_2} (s : set ι) (t : Π (i : ι), set (α i))",
    "doc_string": " Given an index set `ι` and a family of sets `t : Π i, set (α i)`, `pi s t` is the set of dependent functions `f : Πa, π a` such that `f a` belongs to `t a` whenever `a ∈ s`.",
    "kind": "def",
    "type": "set (Π (i : ι), α i)"
  },
  {
    "name": "game",
    "statement": "def game  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The type of combinatorial games. In ZFC, a combinatorial game is constructed from  two sets of combinatorial games that have been constructed at an earlier  stage. To do this in type theory, we say that a combinatorial pre-game is built  inductively from two families of combinatorial games indexed over any type  in Type u. The resulting type `pgame.{u}` lives in `Type (u+1)`,  reflecting that it is a proper class in ZFC.  A combinatorial game is then constructed by quotienting by the equivalence  `x ≈ y ↔ x ≤ y ∧ y ≤ x`.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "primrec_pred",
    "statement": "def primrec_pred {α : Type u_1} [primcodable α] (p : α → Prop) [decidable_pred p] : Prop",
    "theorem": "{α : Type u_1} [primcodable α] (p : α → Prop) [decidable_pred p] : Prop",
    "args": "{α : Type u_1} [primcodable α] (p : α → Prop) [decidable_pred p]",
    "doc_string": "`primrec_pred p` means `p : α → Prop` is a (decidable)  primitive recursive predicate, which is to say that  `to_bool ∘ p : α → bool` is primitive recursive.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.cast",
    "statement": "def nat.cast {α : Type u_1} [has_zero α] [has_one α] [has_add α] : ℕ → α",
    "theorem": "{α : Type u_1} [has_zero α] [has_one α] [has_add α] : ℕ → α",
    "args": "{α : Type u_1} [has_zero α] [has_one α] [has_add α]",
    "doc_string": "Canonical homomorphism from `ℕ` to a type `α` with `0`, `1` and `+`.",
    "kind": "def",
    "type": "ℕ → α"
  },
  {
    "name": "equiv.coe_fn_injective",
    "statement": "theorem equiv.coe_fn_injective {α : Sort u} {β : Sort v} : function.injective coe_fn",
    "theorem": "{α : Sort u} {β : Sort v} : function.injective coe_fn",
    "args": "{α : Sort u} {β : Sort v}",
    "doc_string": "The map `coe_fn : (r ≃ s) → (r → s)` is injective.",
    "kind": "theorem",
    "type": "function.injective coe_fn"
  },
  {
    "name": "order.le_of_succ_le_succ",
    "statement": "theorem order.le_of_succ_le_succ {α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a ≤ order.succ b → a ≤ b",
    "theorem": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a ≤ order.succ b → a ≤ b",
    "args": "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α]",
    "doc_string": "**Alias** of the forward direction of order.succ_le_succ_iff`.",
    "kind": "theorem",
    "type": "order.succ a ≤ order.succ b → a ≤ b"
  },
  {
    "name": "Set.pair",
    "statement": "def Set.pair (x y : Set) : Set",
    "theorem": "(x y : Set) : Set",
    "args": "(x y : Set)",
    "doc_string": "Kuratowski ordered pair",
    "kind": "def",
    "type": "Set"
  },
  {
    "name": "matrix.pi_fin.has_repr",
    "statement": "def matrix.pi_fin.has_repr {α : Type u} {n : ℕ} [has_repr α] : has_repr (fin n → α)",
    "theorem": "{α : Type u} {n : ℕ} [has_repr α] : has_repr (fin n → α)",
    "args": "{α : Type u} {n : ℕ} [has_repr α]",
    "doc_string": " Use `![...]` notation for displaying a vector `fin n → α`, for example:  ```lean #eval ![1, 2] + ![3, 4] -- ![4, 6] ```",
    "kind": "def",
    "type": "has_repr (fin n → α)"
  },
  {
    "name": "encodable.of_inj",
    "statement": "def encodable.of_inj {α : Type u_1} {β : Type u_2} [encodable β] (f : α → β) (hf : function.injective f) : encodable α",
    "theorem": "{α : Type u_1} {β : Type u_2} [encodable β] (f : α → β) (hf : function.injective f) : encodable α",
    "args": "{α : Type u_1} {β : Type u_2} [encodable β] (f : α → β) (hf : function.injective f)",
    "doc_string": "If `β` is encodable and there is an injection `f : α → β`, then `α` is encodable as well.",
    "kind": "def",
    "type": "encodable α"
  },
  {
    "name": "to_antisymmetrization",
    "statement": "def to_antisymmetrization {α : Type u_1} (r : α → α → Prop) [is_preorder α r] : α → antisymmetrization α r",
    "theorem": "{α : Type u_1} (r : α → α → Prop) [is_preorder α r] : α → antisymmetrization α r",
    "args": "{α : Type u_1} (r : α → α → Prop) [is_preorder α r]",
    "doc_string": "Turn an element into its antisymmetrization.",
    "kind": "def",
    "type": "α → antisymmetrization α r"
  },
  {
    "name": "algebra.gi",
    "statement": "def algebra.gi {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] : galois_insertion (algebra.adjoin R) coe",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] : galois_insertion (algebra.adjoin R) coe",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A]",
    "doc_string": "Galois insertion between `adjoin` and `coe`.",
    "kind": "def",
    "type": "galois_insertion (algebra.adjoin R) coe"
  },
  {
    "name": "nat.dvd_add_self_right",
    "statement": "theorem nat.dvd_add_self_right {m n : ℕ} : m ∣ n + m ↔ m ∣ n",
    "theorem": "{m n : ℕ} : m ∣ n + m ↔ m ∣ n",
    "args": "{m n : ℕ}",
    "doc_string": "A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.",
    "kind": "theorem",
    "type": "m ∣ n + m ↔ m ∣ n"
  },
  {
    "name": "quiver",
    "statement": "structure quiver (V : Type u) : Type (max u v)",
    "theorem": "(V : Type u) : Type (max u v)",
    "args": "(V : Type u)",
    "doc_string": "A quiver `G` on a type `V` of vertices assigns to every pair `a b : V` of vertices a type `a ⟶ b` of arrows from `a` to `b`.  For graphs with no repeated edges, one can use `quiver.{0} V`, which ensures `a ⟶ b : Prop`. For multigraphs, one can use `quiver.{v+1} V`, which ensures `a ⟶ b : Type v`.  Because `category` will later extend this class, we call the field `hom`. Except when constructing instances, you should rarely see this, and use the `⟶` notation instead.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "tactic.ring2.csring_expr.eval",
    "statement": "def tactic.ring2.csring_expr.eval {α : Type u_1} [comm_semiring α] (t : tree α) : tactic.ring2.csring_expr → α",
    "theorem": "{α : Type u_1} [comm_semiring α] (t : tree α) : tactic.ring2.csring_expr → α",
    "args": "{α : Type u_1} [comm_semiring α] (t : tree α)",
    "doc_string": " Evaluates a reflected `csring_expr` into an element of the original `comm_semiring` type `α`, retrieving opaque elements (atoms) from the tree `t`.",
    "kind": "def",
    "type": "tactic.ring2.csring_expr → α"
  },
  {
    "name": "stream.iterate",
    "statement": "def stream.iterate {α : Type u} (f : α → α) (a : α) : stream α",
    "theorem": "{α : Type u} (f : α → α) (a : α) : stream α",
    "args": "{α : Type u} (f : α → α) (a : α)",
    "doc_string": "Iterates of a function as a stream.",
    "kind": "def",
    "type": "stream α"
  },
  {
    "name": "parser",
    "statement": "def parser (α : Type) : Type",
    "theorem": "(α : Type) : Type",
    "args": "(α : Type)",
    "doc_string": "The parser monad. If you are familiar with the Parsec library in Haskell, you will understand this.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "continuous_within_at",
    "statement": "def continuous_within_at {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (s : set α) (x : α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (s : set α) (x : α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) (s : set α) (x : α)",
    "doc_string": " A function between topological spaces is continuous at a point `x₀` within a subset `s` if `f x` tends to `f x₀` when `x` tends to `x₀` while staying within `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "add_submonoid.has_bot",
    "statement": "def add_submonoid.has_bot {M : Type u_1} [add_zero_class M] : has_bot (add_submonoid M)",
    "theorem": "{M : Type u_1} [add_zero_class M] : has_bot (add_submonoid M)",
    "args": "{M : Type u_1} [add_zero_class M]",
    "doc_string": "The trivial `add_submonoid` `{0}` of an `add_monoid` `M`.",
    "kind": "def",
    "type": "has_bot (add_submonoid M)"
  },
  {
    "name": "minpoly.prime",
    "statement": "theorem minpoly.prime {A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)",
    "theorem": "{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)",
    "args": "{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x)",
    "doc_string": "A minimal polynomial is prime.",
    "kind": "theorem",
    "type": "prime (minpoly A x)"
  },
  {
    "name": "submonoid.has_inv",
    "statement": "def submonoid.has_inv {G : Type u_2} [group G] : has_inv (submonoid G)",
    "theorem": "{G : Type u_2} [group G] : has_inv (submonoid G)",
    "args": "{G : Type u_2} [group G]",
    "doc_string": "The submonoid with every element inverted.",
    "kind": "def",
    "type": "has_inv (submonoid G)"
  },
  {
    "name": "add_localization.nsmul",
    "statement": "def add_localization.nsmul {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : ℕ → add_localization S → add_localization S",
    "theorem": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : ℕ → add_localization S → add_localization S",
    "args": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M)",
    "doc_string": "Multiplication with a natural in an `add_localization` is defined as `n • ⟨a, b⟩ = ⟨n • a, n • b⟩`.  This is a separate `irreducible` def to ensure the elaborator doesn't waste its time trying to unify some huge recursive definition with itself, but unfolded one step less.",
    "kind": "def",
    "type": "ℕ → add_localization S → add_localization S"
  },
  {
    "name": "set.has_sub",
    "statement": "def set.has_sub {α : Type u_2} [has_sub α] : has_sub (set α)",
    "theorem": "{α : Type u_2} [has_sub α] : has_sub (set α)",
    "args": "{α : Type u_2} [has_sub α]",
    "doc_string": "The pointwise subtraction of sets `s - t` is defined as `{x - y | x ∈ s, y ∈ t}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_sub (set α)"
  },
  {
    "name": "category_theory.limits.bicone.to_cone",
    "statement": "def category_theory.limits.bicone.to_cone {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F) : category_theory.limits.cone (category_theory.discrete.functor F)",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F) : category_theory.limits.cone (category_theory.discrete.functor F)",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {F : J → C} (B : category_theory.limits.bicone F)",
    "doc_string": "Extract the cone from a bicone.",
    "kind": "def",
    "type": "category_theory.limits.cone (category_theory.discrete.functor F)"
  },
  {
    "name": "quiver.geodesic_subtree",
    "statement": "def quiver.geodesic_subtree {V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] : wide_subquiver V",
    "theorem": "{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r] : wide_subquiver V",
    "args": "{V : Type u} [quiver V] (r : V) [quiver.rooted_connected r]",
    "doc_string": "A subquiver which by construction is an arborescence.",
    "kind": "def",
    "type": "wide_subquiver V"
  },
  {
    "name": "filter.Limsup",
    "statement": "def filter.Limsup {α : Type u_1} [conditionally_complete_lattice α] (f : filter α) : α",
    "theorem": "{α : Type u_1} [conditionally_complete_lattice α] (f : filter α) : α",
    "args": "{α : Type u_1} [conditionally_complete_lattice α] (f : filter α)",
    "doc_string": " The `Limsup` of a filter `f` is the infimum of the `a` such that, eventually for `f`, holds `x ≤ a`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "structure_groupoid.partial_order",
    "statement": "def structure_groupoid.partial_order {H : Type u} [topological_space H] : partial_order (structure_groupoid H)",
    "theorem": "{H : Type u} [topological_space H] : partial_order (structure_groupoid H)",
    "args": "{H : Type u} [topological_space H]",
    "doc_string": "Partial order on the set of groupoids, given by inclusion of the members of the groupoid",
    "kind": "def",
    "type": "partial_order (structure_groupoid H)"
  },
  {
    "name": "le_of_sub_nonneg",
    "statement": "theorem le_of_sub_nonneg {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : 0 ≤ a - b → b ≤ a",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : 0 ≤ a - b → b ≤ a",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the forward direction of sub_nonneg`.",
    "kind": "theorem",
    "type": "0 ≤ a - b → b ≤ a"
  },
  {
    "name": "bundle.total_space_mk",
    "statement": "def bundle.total_space_mk {B : Type u_1} {E : B → Type u_2} (b : B) (a : E b) : bundle.total_space E",
    "theorem": "{B : Type u_1} {E : B → Type u_2} (b : B) (a : E b) : bundle.total_space E",
    "args": "{B : Type u_1} {E : B → Type u_2} (b : B) (a : E b)",
    "doc_string": "Constructor for the total space of a bundle.",
    "kind": "def",
    "type": "bundle.total_space E"
  },
  {
    "name": "count_succ_eq_succ_count",
    "statement": "theorem count_succ_eq_succ_count {p : ℕ → Prop} [decidable_pred p] {n : ℕ} : p n → nat.count p (n + 1) = nat.count p n + 1",
    "theorem": "{p : ℕ → Prop} [decidable_pred p] {n : ℕ} : p n → nat.count p (n + 1) = nat.count p n + 1",
    "args": "{p : ℕ → Prop} [decidable_pred p] {n : ℕ}",
    "doc_string": "**Alias** of the reverse direction of nat.count_succ_eq_succ_count_iff`.",
    "kind": "theorem",
    "type": "p n → nat.count p (n + 1) = nat.count p n + 1"
  },
  {
    "name": "doc_category",
    "statement": "inductive doc_category  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The categories of tactic doc entry.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "array.iterate",
    "statement": "def array.iterate {n : ℕ} {α : Type u} {β : Type v} (a : array n α) (b : β) (f : fin n → α → β → β) : β",
    "theorem": "{n : ℕ} {α : Type u} {β : Type v} (a : array n α) (b : β) (f : fin n → α → β → β) : β",
    "args": "{n : ℕ} {α : Type u} {β : Type v} (a : array n α) (b : β) (f : fin n → α → β → β)",
    "doc_string": "Fold array starting from 0, folder function includes an index argument.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "nat.sub_succ'",
    "statement": "theorem nat.sub_succ' (a b : ℕ) : a - b.succ = a - b - 1",
    "theorem": "(a b : ℕ) : a - b.succ = a - b - 1",
    "args": "(a b : ℕ)",
    "doc_string": "A version of `nat.sub_succ` in the form `_ - 1` instead of `nat.pred _`.",
    "kind": "theorem",
    "type": "a - b.succ = a - b - 1"
  },
  {
    "name": "order.pfilter",
    "statement": "structure order.pfilter (P : Type u_2) [preorder P] : Type u_2",
    "theorem": "(P : Type u_2) [preorder P] : Type u_2",
    "args": "(P : Type u_2) [preorder P]",
    "doc_string": "A filter on a preorder `P` is a subset of `P` that is  - nonempty  - downward directed  - upward closed.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "ordnode.link",
    "statement": "def ordnode.link {α : Type u} (l : ordnode α) (x : α) : ordnode α → ordnode α",
    "theorem": "{α : Type u} (l : ordnode α) (x : α) : ordnode α → ordnode α",
    "args": "{α : Type u} (l : ordnode α) (x : α)",
    "doc_string": " O(log(m+n)). Build a tree from an element between two trees, without any assumption on the relative sizes.      link {1, 2} 4 {5, 6} = {1, 2, 4, 5, 6}     link {1, 3} 2 {5} = precondition violation",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "con.quotient",
    "statement": "def con.quotient {M : Type u_1} [has_mul M] (c : con M) : Type u_1",
    "theorem": "{M : Type u_1} [has_mul M] (c : con M) : Type u_1",
    "args": "{M : Type u_1} [has_mul M] (c : con M)",
    "doc_string": "Defining the quotient by a congruence relation of a type with a multiplication.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "fin.of_nat'",
    "statement": "def fin.of_nat' {n : ℕ} [h : fact (0 < n)] (i : ℕ) : fin n",
    "theorem": "{n : ℕ} [h : fact (0 < n)] (i : ℕ) : fin n",
    "args": "{n : ℕ} [h : fact (0 < n)] (i : ℕ)",
    "doc_string": "Given a positive `n`, `fin.of_nat' i` is `i % n` as an element of `fin n`.",
    "kind": "def",
    "type": "fin n"
  },
  {
    "name": "lower_set.Iic",
    "statement": "def lower_set.Iic {α : Type u_1} [preorder α] (a : α) : lower_set α",
    "theorem": "{α : Type u_1} [preorder α] (a : α) : lower_set α",
    "args": "{α : Type u_1} [preorder α] (a : α)",
    "doc_string": " Principal lower set. `set.Iic` as a lower set. The smallest lower set containing a given element.",
    "kind": "def",
    "type": "lower_set α"
  },
  {
    "name": "category_theory.monoid_of_skeletal_monoidal",
    "statement": "def category_theory.monoid_of_skeletal_monoidal {C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (hC : category_theory.skeletal C) : monoid C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (hC : category_theory.skeletal C) : monoid C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.monoidal_category C] (hC : category_theory.skeletal C)",
    "doc_string": " If `C` is monoidal and skeletal, it is a monoid. See note [reducible non-instances].",
    "kind": "def",
    "type": "monoid C"
  },
  {
    "name": "AddMon",
    "statement": "def AddMon  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of additive monoids and monoid morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "one_one_equiv",
    "statement": "def one_one_equiv {α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop)",
    "doc_string": "`p` and `q` are one-one equivalent if each one is one-one reducible to the other.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "equiv.perm.same_cycle",
    "statement": "def equiv.perm.same_cycle {β : Type u_2} (f : equiv.perm β) (x y : β) : Prop",
    "theorem": "{β : Type u_2} (f : equiv.perm β) (x y : β) : Prop",
    "args": "{β : Type u_2} (f : equiv.perm β) (x y : β)",
    "doc_string": "The equivalence relation indicating that two points are in the same cycle of a permutation.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.division_comm_monoid",
    "statement": "def finset.division_comm_monoid {α : Type u_2} [decidable_eq α] [division_comm_monoid α] : division_comm_monoid (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [division_comm_monoid α] : division_comm_monoid (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [division_comm_monoid α]",
    "doc_string": "`finset α` is a commutative division monoid under pointwise operations if `α` is.",
    "kind": "def",
    "type": "division_comm_monoid (finset α)"
  },
  {
    "name": "lower_adjoint.simps.apply",
    "statement": "def lower_adjoint.simps.apply {α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) : α → β",
    "theorem": "{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) : α → β",
    "args": "{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "α → β"
  },
  {
    "name": "category_theory.limits.types.binary_coproduct_cocone",
    "statement": "def category_theory.limits.types.binary_coproduct_cocone (X Y : Type u) : category_theory.limits.cocone (category_theory.limits.pair X Y)",
    "theorem": "(X Y : Type u) : category_theory.limits.cocone (category_theory.limits.pair X Y)",
    "args": "(X Y : Type u)",
    "doc_string": "The sum type `X ⊕ Y` forms a cocone for the binary coproduct of `X` and `Y`.",
    "kind": "def",
    "type": "category_theory.limits.cocone (category_theory.limits.pair X Y)"
  },
  {
    "name": "filter.frequently",
    "statement": "def filter.frequently {α : Type u} (p : α → Prop) (f : filter α) : Prop",
    "theorem": "{α : Type u} (p : α → Prop) (f : filter α) : Prop",
    "args": "{α : Type u} (p : α → Prop) (f : filter α)",
    "doc_string": " `f.frequently p` or `∃ᶠ x in f, p x` mean that `{x | ¬p x} ∉ f`. E.g., `∃ᶠ x in at_top, p x` means that there exist arbitrarily large `x` for which `p` holds true.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "matrix.is_hermitian",
    "statement": "def matrix.is_hermitian {α : Type u_1} {n : Type u_4} [non_unital_semiring α] [star_ring α] (A : matrix n n α) : Prop",
    "theorem": "{α : Type u_1} {n : Type u_4} [non_unital_semiring α] [star_ring α] (A : matrix n n α) : Prop",
    "args": "{α : Type u_1} {n : Type u_4} [non_unital_semiring α] [star_ring α] (A : matrix n n α)",
    "doc_string": " A matrix is hermitian if it is equal to its conjugate transpose. On the reals, this definition captures symmetric matrices.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "CommGroup.of",
    "statement": "def CommGroup.of (G : Type u) [comm_group G] : CommGroup",
    "theorem": "(G : Type u) [comm_group G] : CommGroup",
    "args": "(G : Type u) [comm_group G]",
    "doc_string": "Construct a bundled `CommGroup` from the underlying type and typeclass.",
    "kind": "def",
    "type": "CommGroup"
  },
  {
    "name": "algebraic_geometry.PresheafedSpace.glue_data",
    "statement": "structure algebraic_geometry.PresheafedSpace.glue_data (C : Type u) [category_theory.category C] : Type (max u (v+1))",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u (v+1))",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A family of gluing data consists of 1. An index type `J` 2. A presheafed space `U i` for each `i : J`. 3. A presheafed space `V i j` for each `i j : J`.   (Note that this is `J × J → PresheafedSpace C` rather than `J → J → PresheafedSpace C` to   connect to the limits library easier.) 4. An open immersion `f i j : V i j ⟶ U i` for each `i j : ι`. 5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`. such that 6. `f i i` is an isomorphism. 7. `t i i` is the identity. 8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some     `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`. 9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.  We can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such that the `U i`'s are open subspaces of the glued space.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "filter.tendsto_Ixx_class",
    "statement": "structure filter.tendsto_Ixx_class {α : Type u_1} [preorder α] (Ixx : α → α → set α) (l₁ : filter α) (l₂ : out_param (filter α)) : Prop",
    "theorem": "{α : Type u_1} [preorder α] (Ixx : α → α → set α) (l₁ : filter α) (l₂ : out_param (filter α)) : Prop",
    "args": "{α : Type u_1} [preorder α] (Ixx : α → α → set α) (l₁ : filter α) (l₂ : out_param (filter α))",
    "doc_string": " A pair of filters `l₁`, `l₂` has `tendsto_Ixx_class Ixx` property if `Ixx a b` tends to `l₂.small_sets` as `a` and `b` tend to `l₁`. In all instances `Ixx` is one of `Icc`, `Ico`, `Ioc`, or `Ioo`. The instances provide the best `l₂` for a given `l₁`. In many cases `l₁ = l₂` but sometimes we can drop an endpoint from an interval: e.g., we prove `tendsto_Ixx_class Ico (𝓟 $ Iic a) (𝓟 $ Iio a)`, i.e., if `u₁ n` and `u₂ n` belong eventually to `Iic a`, then the interval `Ico (u₁ n) (u₂ n)` is eventually included in `Iio a`.  We mark `l₂` as an `out_param` so that Lean can automatically find an appropriate `l₂` based on `Ixx` and `l₁`. This way, e.g., `tendsto.Ico h₁ h₂` works without specifying explicitly `l₂`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "parser.mono",
    "statement": "structure parser.mono {α : Type} (p : parser α) : Prop",
    "theorem": "{α : Type} (p : parser α) : Prop",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "A `p : parser α` is defined to be `mono` if the result `p cb n` it gives, for some `cb : char_buffer` and `n : ℕ`, (whether `done` or `fail`), is always at a `parse_result.pos` that is at least `n`. The `mono` property is used mainly for proper `orelse` behavior.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "first_order.language.empty",
    "statement": "def first_order.language.empty  : first_order.language",
    "theorem": " : first_order.language",
    "args": "",
    "doc_string": "The empty language has no symbols.",
    "kind": "def",
    "type": "first_order.language"
  },
  {
    "name": "Class",
    "statement": "def Class  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The collection of all classes. A class is defined as a `set` of ZFC sets.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "lie_algebra.is_simple",
    "statement": "structure lie_algebra.is_simple (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Prop",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": " A Lie algebra is simple if it is irreducible as a Lie module over itself via the adjoint action, and it is non-Abelian.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "function.involutive.eq_iff",
    "statement": "theorem function.involutive.eq_iff {α : Sort u} {f : α → α} (h : function.involutive f) {x y : α} : f x = y ↔ x = f y",
    "theorem": "{α : Sort u} {f : α → α} (h : function.involutive f) {x y : α} : f x = y ↔ x = f y",
    "args": "{α : Sort u} {f : α → α} (h : function.involutive f) {x y : α}",
    "doc_string": "An involution commutes across an equality. Compare to `function.injective.eq_iff`.",
    "kind": "theorem",
    "type": "f x = y ↔ x = f y"
  },
  {
    "name": "zmod.nat_cast_zmod_val",
    "statement": "theorem zmod.nat_cast_zmod_val {n : ℕ} [fact (0 < n)] (a : zmod n) : ↑(a.val) = a",
    "theorem": "{n : ℕ} [fact (0 < n)] (a : zmod n) : ↑(a.val) = a",
    "args": "{n : ℕ} [fact (0 < n)] (a : zmod n)",
    "doc_string": " So-named because the coercion is `nat.cast` into `zmod`. For `nat.cast` into an arbitrary ring, see `zmod.nat_cast_val`.",
    "kind": "theorem",
    "type": "↑(a.val) = a"
  },
  {
    "name": "group_of_is_unit",
    "statement": "def group_of_is_unit {M : Type u_1} [hM : monoid M] (h : ∀ (a : M), is_unit a) : group M",
    "theorem": "{M : Type u_1} [hM : monoid M] (h : ∀ (a : M), is_unit a) : group M",
    "args": "{M : Type u_1} [hM : monoid M] (h : ∀ (a : M), is_unit a)",
    "doc_string": "Constructs a `group` structure on a `monoid` consisting only of units.",
    "kind": "def",
    "type": "group M"
  },
  {
    "name": "besicovitch.tau_package.Union_up_to",
    "statement": "def besicovitch.tau_package.Union_up_to {α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) (i : ordinal) : set α",
    "theorem": "{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) (i : ordinal) : set α",
    "args": "{α : Type u_1} [metric_space α] {β : Type u} [nonempty β] (p : besicovitch.tau_package β α) (i : ordinal)",
    "doc_string": "The set of points that are covered by the union of balls selected at steps `< i`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "lie_algebra.radical",
    "statement": "def lie_algebra.radical (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": "The (solvable) radical of Lie algebra is the `Sup` of all solvable ideals.",
    "kind": "def",
    "type": "lie_ideal R L"
  },
  {
    "name": "ordinal.lift.principal_seg",
    "statement": "def ordinal.lift.principal_seg  : principal_seg has_lt.lt has_lt.lt",
    "theorem": " : principal_seg has_lt.lt has_lt.lt",
    "args": "",
    "doc_string": "Principal segment version of the lift operation on ordinals, embedding `ordinal.{u}` in  `ordinal.{v}` as a principal segment when `u < v`.",
    "kind": "def",
    "type": "principal_seg has_lt.lt has_lt.lt"
  },
  {
    "name": "ordnode.erase_min",
    "statement": "def ordnode.erase_min {α : Type u} : ordnode α → ordnode α",
    "theorem": "{α : Type u} : ordnode α → ordnode α",
    "args": "{α : Type u}",
    "doc_string": "O(log n). Remove the minimum element from the tree, or do nothing if it is already empty.      erase_min {1, 2, 3} = {2, 3}     erase_min ∅ = ∅",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "nat.arithmetic_function.zeta",
    "statement": "def nat.arithmetic_function.zeta  : nat.arithmetic_function ℕ",
    "theorem": " : nat.arithmetic_function ℕ",
    "args": "",
    "doc_string": "`ζ 0 = 0`, otherwise `ζ x = 1`. The Dirichlet Series is the Riemann ζ.",
    "kind": "def",
    "type": "nat.arithmetic_function ℕ"
  },
  {
    "name": "nat.prime",
    "statement": "def nat.prime (p : ℕ) : Prop",
    "theorem": "(p : ℕ) : Prop",
    "args": "(p : ℕ)",
    "doc_string": "`prime p` means that `p` is a prime number, that is, a natural number  at least 2 whose only divisors are `p` and `1`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.prod_eq_zero_iff",
    "statement": "theorem list.prod_eq_zero_iff {M₀ : Type u_6} [monoid_with_zero M₀] [nontrivial M₀] [no_zero_divisors M₀] {L : list M₀} : L.prod = 0 ↔ 0 ∈ L",
    "theorem": "{M₀ : Type u_6} [monoid_with_zero M₀] [nontrivial M₀] [no_zero_divisors M₀] {L : list M₀} : L.prod = 0 ↔ 0 ∈ L",
    "args": "{M₀ : Type u_6} [monoid_with_zero M₀] [nontrivial M₀] [no_zero_divisors M₀] {L : list M₀}",
    "doc_string": " Product of elements of a list `L` equals zero if and only if `0 ∈ L`. See also `list.prod_eq_zero` for an implication that needs weaker typeclass assumptions.",
    "kind": "theorem",
    "type": "L.prod = 0 ↔ 0 ∈ L"
  },
  {
    "name": "ennreal.distrib_mul_action",
    "statement": "def ennreal.distrib_mul_action {M : Type u_1} [add_monoid M] [distrib_mul_action ennreal M] : distrib_mul_action nnreal M",
    "theorem": "{M : Type u_1} [add_monoid M] [distrib_mul_action ennreal M] : distrib_mul_action nnreal M",
    "args": "{M : Type u_1} [add_monoid M] [distrib_mul_action ennreal M]",
    "doc_string": "A `distrib_mul_action` over `ℝ≥0∞` restricts to a `distrib_mul_action` over `ℝ≥0`.",
    "kind": "def",
    "type": "distrib_mul_action nnreal M"
  },
  {
    "name": "right.one_lt_mul'",
    "statement": "theorem right.one_lt_mul' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul'`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "monoid.fg",
    "statement": "structure monoid.fg (M : Type u_1) [monoid M] : Prop",
    "theorem": "(M : Type u_1) [monoid M] : Prop",
    "args": "(M : Type u_1) [monoid M]",
    "doc_string": "A monoid is finitely generated if it is finitely generated as a submonoid of itself.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordnode.diff",
    "statement": "def ordnode.diff {α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] : ordnode α → ordnode α → ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le]",
    "doc_string": "O(m * log(|m ∪ n| + 1)), m ≤ n. Difference of two sets.     diff {1, 2} {2, 3} = {1}    diff {1, 2, 3} {2} = {1, 3}",
    "kind": "def",
    "type": "ordnode α → ordnode α → ordnode α"
  },
  {
    "name": "is_right_regular_of_right_cancel_semigroup",
    "statement": "theorem is_right_regular_of_right_cancel_semigroup {R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g",
    "theorem": "{R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g",
    "args": "{R : Type u_1} [right_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of a right cancel semigroup are right regular.",
    "kind": "theorem",
    "type": "is_right_regular g"
  },
  {
    "name": "category_theory.limits.initial_op_of_terminal",
    "statement": "def category_theory.limits.initial_op_of_terminal {C : Type u₁} [category_theory.category C] {X : C} (t : category_theory.limits.is_terminal X) : category_theory.limits.is_initial (opposite.op X)",
    "theorem": "{C : Type u₁} [category_theory.category C] {X : C} (t : category_theory.limits.is_terminal X) : category_theory.limits.is_initial (opposite.op X)",
    "args": "{C : Type u₁} [category_theory.category C] {X : C} (t : category_theory.limits.is_terminal X)",
    "doc_string": "A terminal object is initial in the opposite category.",
    "kind": "def",
    "type": "category_theory.limits.is_initial (opposite.op X)"
  },
  {
    "name": "has_lift_t",
    "statement": "structure has_lift_t (a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))",
    "theorem": "(a : Sort u) (b : Sort v) : Sort (max 1 (imax u v))",
    "args": "(a : Sort u) (b : Sort v)",
    "doc_string": "Auxiliary class that contains the transitive closure of `has_lift`.",
    "kind": "structure",
    "type": "Sort (max 1 (imax u v))"
  },
  {
    "name": "noetherian_ring_strong_rank_condition",
    "statement": "def noetherian_ring_strong_rank_condition (R : Type u) [ring R] [nontrivial R] [is_noetherian_ring R] : strong_rank_condition R",
    "theorem": "(R : Type u) [ring R] [nontrivial R] [is_noetherian_ring R] : strong_rank_condition R",
    "args": "(R : Type u) [ring R] [nontrivial R] [is_noetherian_ring R]",
    "doc_string": "Any nontrivial noetherian ring satisfies the strong rank condition.  An injective map `((fin n ⊕ fin (1 + m)) → R) →ₗ[R] (fin n → R)` for some left-noetherian `R` would force `fin (1 + m) → R ≃ₗ punit` (via `is_noetherian.equiv_punit_of_prod_injective`), which is not the case!",
    "kind": "def",
    "type": "strong_rank_condition R"
  },
  {
    "name": "setoid.partition.complete_lattice",
    "statement": "def setoid.partition.complete_lattice {α : Type u_1} : complete_lattice (subtype setoid.is_partition)",
    "theorem": "{α : Type u_1} : complete_lattice (subtype setoid.is_partition)",
    "args": "{α : Type u_1}",
    "doc_string": "A complete lattice instance for partitions; there is more infrastructure for the    equivalent complete lattice on equivalence relations.",
    "kind": "def",
    "type": "complete_lattice (subtype setoid.is_partition)"
  },
  {
    "name": "lazy_list.interleave",
    "statement": "def lazy_list.interleave {α : Type u_1} : lazy_list α → lazy_list α → lazy_list α",
    "theorem": "{α : Type u_1} : lazy_list α → lazy_list α → lazy_list α",
    "args": "{α : Type u_1}",
    "doc_string": "`interleave xs ys` creates a list where elements of `xs` and `ys` alternate.",
    "kind": "def",
    "type": "lazy_list α → lazy_list α → lazy_list α"
  },
  {
    "name": "le_nhds_of_cauchy_adhp",
    "statement": "theorem le_nhds_of_cauchy_adhp {α : Type u} [uniform_space α] {f : filter α} {x : α} (hf : cauchy f) (adhs : cluster_pt x f) : f ≤ nhds x",
    "theorem": "{α : Type u} [uniform_space α] {f : filter α} {x : α} (hf : cauchy f) (adhs : cluster_pt x f) : f ≤ nhds x",
    "args": "{α : Type u} [uniform_space α] {f : filter α} {x : α} (hf : cauchy f) (adhs : cluster_pt x f)",
    "doc_string": " If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point for `f`.",
    "kind": "theorem",
    "type": "f ≤ nhds x"
  },
  {
    "name": "ring_hom_class",
    "statement": "structure ring_hom_class (F : Type u_5) (α : out_param (Type u_6)) (β : out_param (Type u_7)) [non_assoc_semiring α] [non_assoc_semiring β] : Type (max u_5 u_6 u_7)",
    "theorem": "(F : Type u_5) (α : out_param (Type u_6)) (β : out_param (Type u_7)) [non_assoc_semiring α] [non_assoc_semiring β] : Type (max u_5 u_6 u_7)",
    "args": "(F : Type u_5) (α : out_param (Type u_6)) (β : out_param (Type u_7)) [non_assoc_semiring α] [non_assoc_semiring β]",
    "doc_string": " `ring_hom_class F α β` states that `F` is a type of (semi)ring homomorphisms. You should extend this class when you extend `ring_hom`.  This extends from both `monoid_hom_class` and `monoid_with_zero_hom_class` in order to put the fields in a sensible order, even though `monoid_with_zero_hom_class` already extends `monoid_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_5 u_6 u_7)"
  },
  {
    "name": "fin_enum.of_list",
    "statement": "def fin_enum.of_list {α : Type u} [decidable_eq α] (xs : list α) (h : ∀ (x : α), x ∈ xs) : fin_enum α",
    "theorem": "{α : Type u} [decidable_eq α] (xs : list α) (h : ∀ (x : α), x ∈ xs) : fin_enum α",
    "args": "{α : Type u} [decidable_eq α] (xs : list α) (h : ∀ (x : α), x ∈ xs)",
    "doc_string": "create a `fin_enum` instance from an exhaustive list; duplicates are removed",
    "kind": "def",
    "type": "fin_enum α"
  },
  {
    "name": "equiv.perm.cycle_factors_finset_injective",
    "statement": "theorem equiv.perm.cycle_factors_finset_injective {α : Type u_1} [decidable_eq α] [fintype α] : function.injective equiv.perm.cycle_factors_finset",
    "theorem": "{α : Type u_1} [decidable_eq α] [fintype α] : function.injective equiv.perm.cycle_factors_finset",
    "args": "{α : Type u_1} [decidable_eq α] [fintype α]",
    "doc_string": "Two permutations `f g : perm α` have the same cycle factors iff they are the same.",
    "kind": "theorem",
    "type": "function.injective equiv.perm.cycle_factors_finset"
  },
  {
    "name": "real.summable_one_div_nat_pow",
    "statement": "theorem real.summable_one_div_nat_pow {p : ℕ} : summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p",
    "theorem": "{p : ℕ} : summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p",
    "args": "{p : ℕ}",
    "doc_string": " Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges if and only if `1 < p`.",
    "kind": "theorem",
    "type": "summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p"
  },
  {
    "name": "declaration",
    "statement": "inductive declaration  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Reflect a C++ declaration object. The VM replaces it with the C++ implementation.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "quadratic_form.discr",
    "statement": "def quadratic_form.discr {R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R₁ (n → R₁)) : R₁",
    "theorem": "{R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R₁ (n → R₁)) : R₁",
    "args": "{R₁ : Type u_4} [comm_ring R₁] {n : Type w} [fintype n] [decidable_eq n] [invertible 2] (Q : quadratic_form R₁ (n → R₁))",
    "doc_string": "The discriminant of a quadratic form generalizes the discriminant of a quadratic polynomial.",
    "kind": "def",
    "type": "R₁"
  },
  {
    "name": "no_min_order.infinite",
    "statement": "theorem no_min_order.infinite {α : Type u_1} [preorder α] [nonempty α] [no_min_order α] : infinite α",
    "theorem": "{α : Type u_1} [preorder α] [nonempty α] [no_min_order α] : infinite α",
    "args": "{α : Type u_1} [preorder α] [nonempty α] [no_min_order α]",
    "doc_string": " A nonempty preorder with no minimal element is infinite. This is not an instance to avoid a cycle with `infinite α → nontrivial α → nonempty α`.",
    "kind": "theorem",
    "type": "infinite α"
  },
  {
    "name": "is_directed",
    "statement": "structure is_directed (α : Type u_1) (r : α → α → Prop) : Prop",
    "theorem": "(α : Type u_1) (r : α → α → Prop) : Prop",
    "args": "(α : Type u_1) (r : α → α → Prop)",
    "doc_string": " `is_directed α r` states that for any elements `a`, `b` there exists an element `c` such that `r a c` and `r b c`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "onote.opow_aux",
    "statement": "def onote.opow_aux (e a0 a : onote) : ℕ → ℕ → onote",
    "theorem": "(e a0 a : onote) : ℕ → ℕ → onote",
    "args": "(e a0 a : onote)",
    "doc_string": " Auxiliary definition to compute the ordinal notation for the ordinal exponentiation in `opow`",
    "kind": "def",
    "type": "ℕ → ℕ → onote"
  },
  {
    "name": "witt_vector.select",
    "statement": "def witt_vector.select {p : ℕ} {R : Type u_1} [comm_ring R] (P : ℕ → Prop) (x : witt_vector p R) : witt_vector p R",
    "theorem": "{p : ℕ} {R : Type u_1} [comm_ring R] (P : ℕ → Prop) (x : witt_vector p R) : witt_vector p R",
    "args": "{p : ℕ} {R : Type u_1} [comm_ring R] (P : ℕ → Prop) (x : witt_vector p R)",
    "doc_string": " `witt_vector.select P x`, for a predicate `P : ℕ → Prop` is the Witt vector whose `n`-th coefficient is `x.coeff n` if `P n` is true, and `0` otherwise.",
    "kind": "def",
    "type": "witt_vector p R"
  },
  {
    "name": "locally_bounded_map.comp",
    "statement": "def locally_bounded_map.comp {α : Type u_2} {β : Type u_3} {γ : Type u_4} [bornology α] [bornology β] [bornology γ] (f : locally_bounded_map β γ) (g : locally_bounded_map α β) : locally_bounded_map α γ",
    "theorem": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [bornology α] [bornology β] [bornology γ] (f : locally_bounded_map β γ) (g : locally_bounded_map α β) : locally_bounded_map α γ",
    "args": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [bornology α] [bornology β] [bornology γ] (f : locally_bounded_map β γ) (g : locally_bounded_map α β)",
    "doc_string": "Composition of `locally_bounded_map`s as a `locally_bounded_map`.",
    "kind": "def",
    "type": "locally_bounded_map α γ"
  },
  {
    "name": "add_submonoid.centralizer",
    "statement": "def add_submonoid.centralizer {M : Type u_1} (S : set M) [add_monoid M] : add_submonoid M",
    "theorem": "{M : Type u_1} (S : set M) [add_monoid M] : add_submonoid M",
    "args": "{M : Type u_1} (S : set M) [add_monoid M]",
    "doc_string": "The centralizer of a subset of an additive monoid.",
    "kind": "def",
    "type": "add_submonoid M"
  },
  {
    "name": "mersenne",
    "statement": "def mersenne (p : ℕ) : ℕ",
    "theorem": "(p : ℕ) : ℕ",
    "args": "(p : ℕ)",
    "doc_string": "The Mersenne numbers, 2^p - 1.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "ordnode.valid'",
    "statement": "structure ordnode.valid' {α : Type u_1} [preorder α] (lo : with_bot α) (t : ordnode α) (hi : with_top α) : Prop",
    "theorem": "{α : Type u_1} [preorder α] (lo : with_bot α) (t : ordnode α) (hi : with_top α) : Prop",
    "args": "{α : Type u_1} [preorder α] (lo : with_bot α) (t : ordnode α) (hi : with_top α)",
    "doc_string": " The validity predicate for an `ordnode` subtree. This asserts that the `size` fields are correct, the tree is balanced, and the elements of the tree are organized according to the ordering. This version of `valid` also puts all elements in the tree in the interval `(lo, hi)`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "same_ray.symm",
    "statement": "theorem same_ray.symm {R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x",
    "theorem": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x",
    "args": "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y)",
    "doc_string": "`same_ray` is symmetric.",
    "kind": "theorem",
    "type": "same_ray R y x"
  },
  {
    "name": "cstar_ring",
    "statement": "structure cstar_ring (E : Type u_4) [non_unital_normed_ring E] [star_ring E] : Prop",
    "theorem": "(E : Type u_4) [non_unital_normed_ring E] [star_ring E] : Prop",
    "args": "(E : Type u_4) [non_unital_normed_ring E] [star_ring E]",
    "doc_string": " A C*-ring is a normed star ring that satifies the stronger condition `∥x⋆ * x∥ = ∥x∥^2` for every `x`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nonarchimedean_add_group",
    "statement": "structure nonarchimedean_add_group (G : Type u_1) [add_group G] [topological_space G] : Prop",
    "theorem": "(G : Type u_1) [add_group G] [topological_space G] : Prop",
    "args": "(G : Type u_1) [add_group G] [topological_space G]",
    "doc_string": "An topological additive group is nonarchimedean if every neighborhood of 0  contains an open subgroup.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "locally_bounded_map.id",
    "statement": "def locally_bounded_map.id (α : Type u_2) [bornology α] : locally_bounded_map α α",
    "theorem": "(α : Type u_2) [bornology α] : locally_bounded_map α α",
    "args": "(α : Type u_2) [bornology α]",
    "doc_string": "`id` as a `locally_bounded_map`.",
    "kind": "def",
    "type": "locally_bounded_map α α"
  },
  {
    "name": "measure_theory.vector_measure",
    "statement": "structure measure_theory.vector_measure (α : Type u_3) [measurable_space α] (M : Type u_4) [add_comm_monoid M] [topological_space M] : Type (max u_3 u_4)",
    "theorem": "(α : Type u_3) [measurable_space α] (M : Type u_4) [add_comm_monoid M] [topological_space M] : Type (max u_3 u_4)",
    "args": "(α : Type u_3) [measurable_space α] (M : Type u_4) [add_comm_monoid M] [topological_space M]",
    "doc_string": " A vector measure on a measurable space `α` is a σ-additive `M`-valued function (for some `M` an add monoid) such that the empty set and non-measurable sets are mapped to zero.",
    "kind": "structure",
    "type": "Type (max u_3 u_4)"
  },
  {
    "name": "seq.split_at",
    "statement": "def seq.split_at {α : Type u} : ℕ → seq α → list α × seq α",
    "theorem": "{α : Type u} : ℕ → seq α → list α × seq α",
    "args": "{α : Type u}",
    "doc_string": "Split a sequence at `n`, producing a finite initial segment  and an infinite tail.",
    "kind": "def",
    "type": "ℕ → seq α → list α × seq α"
  },
  {
    "name": "one_div_lt_one_div",
    "statement": "theorem one_div_lt_one_div {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ↔ b < a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ↔ b < a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and  `lt_of_one_div_lt_one_div`",
    "kind": "theorem",
    "type": "1 / a < 1 / b ↔ b < a"
  },
  {
    "name": "composition_as_set.length",
    "statement": "def composition_as_set.length {n : ℕ} (c : composition_as_set n) : ℕ",
    "theorem": "{n : ℕ} (c : composition_as_set n) : ℕ",
    "args": "{n : ℕ} (c : composition_as_set n)",
    "doc_string": "Number of blocks in a `composition_as_set`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "set.well_founded_on",
    "statement": "def set.well_founded_on {α : Type u_1} (s : set α) (r : α → α → Prop) : Prop",
    "theorem": "{α : Type u_1} (s : set α) (r : α → α → Prop) : Prop",
    "args": "{α : Type u_1} (s : set α) (r : α → α → Prop)",
    "doc_string": "`s.well_founded_on r` indicates that the relation `r` is well-founded when restricted to `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "onote.omega",
    "statement": "def onote.omega  : onote",
    "theorem": " : onote",
    "args": "",
    "doc_string": "Notation for ω",
    "kind": "def",
    "type": "onote"
  },
  {
    "name": "filter.at_top_le_cofinite",
    "statement": "theorem filter.at_top_le_cofinite {α : Type u_2} [preorder α] [no_max_order α] : filter.at_top ≤ filter.cofinite",
    "theorem": "{α : Type u_2} [preorder α] [no_max_order α] : filter.at_top ≤ filter.cofinite",
    "args": "{α : Type u_2} [preorder α] [no_max_order α]",
    "doc_string": "If `α` is a preorder with no maximal element, then `at_top ≤ cofinite`.",
    "kind": "theorem",
    "type": "filter.at_top ≤ filter.cofinite"
  },
  {
    "name": "cau_seq.completion.Cauchy",
    "statement": "def cau_seq.completion.Cauchy {α : Type u_1} [linear_ordered_field α] {β : Type u_2} [comm_ring β] {abv : β → α} [is_absolute_value abv] : Type u_2",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [comm_ring β] {abv : β → α} [is_absolute_value abv] : Type u_2",
    "args": "{α : Type u_1} [linear_ordered_field α] {β : Type u_2} [comm_ring β] {abv : β → α} [is_absolute_value abv]",
    "doc_string": "The Cauchy completion of a commutative ring with absolute value.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "lie_algebra.center",
    "statement": "def lie_algebra.center (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : lie_ideal R L",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": " The center of a Lie algebra is the set of elements that commute with everything. It can be viewed as the maximal trivial submodule of the Lie algebra as a Lie module over itself via the adjoint representation.",
    "kind": "def",
    "type": "lie_ideal R L"
  },
  {
    "name": "invertible_of_nonzero",
    "statement": "def invertible_of_nonzero {α : Type u} [group_with_zero α] {a : α} (h : a ≠ 0) : invertible a",
    "theorem": "{α : Type u} [group_with_zero α] {a : α} (h : a ≠ 0) : invertible a",
    "args": "{α : Type u} [group_with_zero α] {a : α} (h : a ≠ 0)",
    "doc_string": "`a⁻¹` is an inverse of `a` if `a ≠ 0`",
    "kind": "def",
    "type": "invertible a"
  },
  {
    "name": "has_continuous_div",
    "statement": "structure has_continuous_div (G : Type u_1) [topological_space G] [has_div G] : Prop",
    "theorem": "(G : Type u_1) [topological_space G] [has_div G] : Prop",
    "args": "(G : Type u_1) [topological_space G] [has_div G]",
    "doc_string": " A typeclass saying that `λ p : G × G, p.1 / p.2` is a continuous function. This property automatically holds for topological groups. Lemmas using this class have primes. The unprimed version is for `group_with_zero`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordnode.empty",
    "statement": "def ordnode.empty {α : Type u} : ordnode α → bool",
    "theorem": "{α : Type u} : ordnode α → bool",
    "args": "{α : Type u}",
    "doc_string": "O(1). Is the set empty?      empty ∅ = tt     empty {1, 2, 3} = ff",
    "kind": "def",
    "type": "ordnode α → bool"
  },
  {
    "name": "slim_check.injective_function.list.apply_id",
    "statement": "def slim_check.injective_function.list.apply_id {α : Type u} [decidable_eq α] (xs : list (α × α)) (x : α) : α",
    "theorem": "{α : Type u} [decidable_eq α] (xs : list (α × α)) (x : α) : α",
    "args": "{α : Type u} [decidable_eq α] (xs : list (α × α)) (x : α)",
    "doc_string": " Interpret a list of pairs as a total function, defaulting to the identity function when no entries are found for a given function",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "nat.upto.wf",
    "statement": "theorem nat.upto.wf {p : ℕ → Prop} : (∃ (x : ℕ), p x) → well_founded (nat.upto.gt p)",
    "theorem": "{p : ℕ → Prop} : (∃ (x : ℕ), p x) → well_founded (nat.upto.gt p)",
    "args": "{p : ℕ → Prop}",
    "doc_string": " The \"greater than\" relation on `upto p` is well founded if (and only if) there exists a value satisfying `p`.",
    "kind": "theorem",
    "type": "(∃ (x : ℕ), p x) → well_founded (nat.upto.gt p)"
  },
  {
    "name": "is_simple_module",
    "statement": "def is_simple_module (R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop",
    "theorem": "(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M] : Prop",
    "args": "(R : Type u_1) [ring R] (M : Type u_2) [add_comm_group M] [module R M]",
    "doc_string": "A module is simple when it has only two submodules, `⊥` and `⊤`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "cycle.nil",
    "statement": "def cycle.nil {α : Type u_1} : cycle α",
    "theorem": "{α : Type u_1} : cycle α",
    "args": "{α : Type u_1}",
    "doc_string": "The unique empty cycle.",
    "kind": "def",
    "type": "cycle α"
  },
  {
    "name": "path_component_in",
    "statement": "def path_component_in {X : Type u_1} [topological_space X] (x : X) (F : set X) : set X",
    "theorem": "{X : Type u_1} [topological_space X] (x : X) (F : set X) : set X",
    "args": "{X : Type u_1} [topological_space X] (x : X) (F : set X)",
    "doc_string": "The path component of `x` in `F` is the set of points that can be joined to `x` in `F`.",
    "kind": "def",
    "type": "set X"
  },
  {
    "name": "computation.promises",
    "statement": "def computation.promises {α : Type u} (s : computation α) (a : α) : Prop",
    "theorem": "{α : Type u} (s : computation α) (a : α) : Prop",
    "args": "{α : Type u} (s : computation α) (a : α)",
    "doc_string": "`promises s a`, or `s ~> a`, asserts that although the computation `s`  may not terminate, if it does, then the result is `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finite_dimensional.of_fintype_basis",
    "statement": "theorem finite_dimensional.of_fintype_basis {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V)",
    "doc_string": "If a vector space has a finite basis, then it is finite-dimensional.",
    "kind": "theorem",
    "type": "finite_dimensional K V"
  },
  {
    "name": "frontier",
    "statement": "def frontier {α : Type u} [topological_space α] (s : set α) : set α",
    "theorem": "{α : Type u} [topological_space α] (s : set α) : set α",
    "args": "{α : Type u} [topological_space α] (s : set α)",
    "doc_string": "The frontier of a set is the set of points between the closure and interior.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "is_of_fin_order",
    "statement": "def is_of_fin_order {G : Type u} [monoid G] (x : G) : Prop",
    "theorem": "{G : Type u} [monoid G] (x : G) : Prop",
    "args": "{G : Type u} [monoid G] (x : G)",
    "doc_string": " `is_of_fin_order` is a predicate on an element `x` of a monoid to be of finite order, i.e. there exists `n ≥ 1` such that `x ^ n = 1`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "rand_bool",
    "statement": "def rand_bool {gen : Type u} [random_gen gen] (g : gen) : bool × gen",
    "theorem": "{gen : Type u} [random_gen gen] (g : gen) : bool × gen",
    "args": "{gen : Type u} [random_gen gen] (g : gen)",
    "doc_string": "Generate a random Boolean.",
    "kind": "def",
    "type": "bool × gen"
  },
  {
    "name": "classical.subtype_of_exists",
    "statement": "def classical.subtype_of_exists {α : Type u_1} {P : α → Prop} (h : ∃ (x : α), P x) : {x // P x}",
    "theorem": "{α : Type u_1} {P : α → Prop} (h : ∃ (x : α), P x) : {x // P x}",
    "args": "{α : Type u_1} {P : α → Prop} (h : ∃ (x : α), P x)",
    "doc_string": "A version of classical.indefinite_description which is definitionally equal to a pair",
    "kind": "def",
    "type": "{x // P x}"
  },
  {
    "name": "complex_shape.up",
    "statement": "def complex_shape.up (α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : complex_shape α",
    "theorem": "(α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : complex_shape α",
    "args": "(α : Type u_1) [add_right_cancel_semigroup α] [has_one α]",
    "doc_string": "The `complex_shape` appropriate for cohomology, so `d : X i ⟶ X j` only when `j = i + 1`.",
    "kind": "def",
    "type": "complex_shape α"
  },
  {
    "name": "seq.terminates",
    "statement": "def seq.terminates {α : Type u} (s : seq α) : Prop",
    "theorem": "{α : Type u} (s : seq α) : Prop",
    "args": "{α : Type u} (s : seq α)",
    "doc_string": "A sequence terminates if there is some position `n` at which it has terminated.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "filter.Coprod",
    "statement": "def filter.Coprod {ι : Type u_1} {α : ι → Type u_2} (f : Π (i : ι), filter (α i)) : filter (Π (i : ι), α i)",
    "theorem": "{ι : Type u_1} {α : ι → Type u_2} (f : Π (i : ι), filter (α i)) : filter (Π (i : ι), α i)",
    "args": "{ι : Type u_1} {α : ι → Type u_2} (f : Π (i : ι), filter (α i))",
    "doc_string": "Coproduct of filters.",
    "kind": "def",
    "type": "filter (Π (i : ι), α i)"
  },
  {
    "name": "is_dedekind_domain.height_one_spectrum.adic_completion",
    "statement": "def is_dedekind_domain.height_one_spectrum.adic_completion {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : Type u_2",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : Type u_2",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R)",
    "doc_string": "The completion of `K` with respect to its `v`-adic valuation.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "erased.choice",
    "statement": "def erased.choice {α : Sort u_1} (h : nonempty α) : erased α",
    "theorem": "{α : Sort u_1} (h : nonempty α) : erased α",
    "args": "{α : Sort u_1} (h : nonempty α)",
    "doc_string": "Computably produce an erased value from a proof of nonemptiness.",
    "kind": "def",
    "type": "erased α"
  },
  {
    "name": "category_theory.limits.binary_fan.swap",
    "statement": "def category_theory.limits.binary_fan.swap {C : Type u} [category_theory.category C] {P Q : C} (t : category_theory.limits.binary_fan P Q) : category_theory.limits.binary_fan Q P",
    "theorem": "{C : Type u} [category_theory.category C] {P Q : C} (t : category_theory.limits.binary_fan P Q) : category_theory.limits.binary_fan Q P",
    "args": "{C : Type u} [category_theory.category C] {P Q : C} (t : category_theory.limits.binary_fan P Q)",
    "doc_string": "Swap the two sides of a `binary_fan`.",
    "kind": "def",
    "type": "category_theory.limits.binary_fan Q P"
  },
  {
    "name": "stream.all",
    "statement": "def stream.all {α : Type u} (p : α → Prop) (s : stream α) : Prop",
    "theorem": "{α : Type u} (p : α → Prop) (s : stream α) : Prop",
    "args": "{α : Type u} (p : α → Prop) (s : stream α)",
    "doc_string": "Proposition saying that all elements of a stream satisfy a predicate.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "module.core",
    "statement": "structure module.core (R : Type u_2) (M : Type u_5) [semiring R] [add_comm_group M] : Type (max u_2 u_5)",
    "theorem": "(R : Type u_2) (M : Type u_5) [semiring R] [add_comm_group M] : Type (max u_2 u_5)",
    "args": "(R : Type u_2) (M : Type u_5) [semiring R] [add_comm_group M]",
    "doc_string": " A structure containing most informations as in a module, except the fields `zero_smul` and `smul_zero`. As these fields can be deduced from the other ones when `M` is an `add_comm_group`, this provides a way to construct a module structure by checking less properties, in `module.of_core`.",
    "kind": "structure",
    "type": "Type (max u_2 u_5)"
  },
  {
    "name": "sylow.pointwise_mul_action",
    "statement": "def sylow.pointwise_mul_action {p : ℕ} {G : Type u_1} [group G] {α : Type u_2} [group α] [mul_distrib_mul_action α G] : mul_action α (sylow p G)",
    "theorem": "{p : ℕ} {G : Type u_1} [group G] {α : Type u_2} [group α] [mul_distrib_mul_action α G] : mul_action α (sylow p G)",
    "args": "{p : ℕ} {G : Type u_1} [group G] {α : Type u_2} [group α] [mul_distrib_mul_action α G]",
    "doc_string": "`subgroup.pointwise_mul_action` preserves Sylow subgroups.",
    "kind": "def",
    "type": "mul_action α (sylow p G)"
  },
  {
    "name": "stream.nth",
    "statement": "def stream.nth {α : Type u} (s : stream α) (n : ℕ) : α",
    "theorem": "{α : Type u} (s : stream α) (n : ℕ) : α",
    "args": "{α : Type u} (s : stream α) (n : ℕ)",
    "doc_string": "`n`-th element of a stream.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "free_group.lift.aux",
    "statement": "def free_group.lift.aux {α : Type u} {β : Type v} [group β] (f : α → β) : list (α × bool) → β",
    "theorem": "{α : Type u} {β : Type v} [group β] (f : α → β) : list (α × bool) → β",
    "args": "{α : Type u} {β : Type v} [group β] (f : α → β)",
    "doc_string": "Given `f : α → β` with `β` a group, the canonical map `list (α × bool) → β`",
    "kind": "def",
    "type": "list (α × bool) → β"
  },
  {
    "name": "non_unital_normed_ring.to_non_unital_semi_normed_ring",
    "statement": "def non_unital_normed_ring.to_non_unital_semi_normed_ring {α : Type u_1} [β : non_unital_normed_ring α] : non_unital_semi_normed_ring α",
    "theorem": "{α : Type u_1} [β : non_unital_normed_ring α] : non_unital_semi_normed_ring α",
    "args": "{α : Type u_1} [β : non_unital_normed_ring α]",
    "doc_string": "A non-unital normed ring is a non-unital seminormed ring.",
    "kind": "def",
    "type": "non_unital_semi_normed_ring α"
  },
  {
    "name": "add_subgroup.zero_mem",
    "statement": "theorem add_subgroup.zero_mem {G : Type u_1} [add_group G] (H : add_subgroup G) : 0 ∈ H",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) : 0 ∈ H",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G)",
    "doc_string": "An `add_subgroup` contains the group's 0.",
    "kind": "theorem",
    "type": "0 ∈ H"
  },
  {
    "name": "finset.exists_smaller_set",
    "statement": "theorem finset.exists_smaller_set {α : Type u_1} (A : finset α) (i : ℕ) (h₁ : i ≤ A.card) : ∃ (B : finset α), B ⊆ A ∧ B.card = i",
    "theorem": "{α : Type u_1} (A : finset α) (i : ℕ) (h₁ : i ≤ A.card) : ∃ (B : finset α), B ⊆ A ∧ B.card = i",
    "args": "{α : Type u_1} (A : finset α) (i : ℕ) (h₁ : i ≤ A.card)",
    "doc_string": "We can shrink `A` to any smaller size.",
    "kind": "theorem",
    "type": "∃ (B : finset α), B ⊆ A ∧ B.card = i"
  },
  {
    "name": "native.rb_lmap",
    "statement": "def native.rb_lmap (key data : Type) : Type",
    "theorem": "(key data : Type) : Type",
    "args": "(key data : Type)",
    "doc_string": "a variant of rb_maps that stores a list of elements for each key.   `find` returns the list of elements in the opposite order that they were inserted.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "Inf_hom",
    "statement": "structure Inf_hom (α : Type u_8) (β : Type u_9) [has_Inf α] [has_Inf β] : Type (max u_8 u_9)",
    "theorem": "(α : Type u_8) (β : Type u_9) [has_Inf α] [has_Inf β] : Type (max u_8 u_9)",
    "args": "(α : Type u_8) (β : Type u_9) [has_Inf α] [has_Inf β]",
    "doc_string": "The type of `⨅`-preserving functions from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_8 u_9)"
  },
  {
    "name": "first_order.language.mk₂",
    "statement": "def first_order.language.mk₂ (c f₁ f₂ : Type u) (r₁ r₂ : Type v) : first_order.language",
    "theorem": "(c f₁ f₂ : Type u) (r₁ r₂ : Type v) : first_order.language",
    "args": "(c f₁ f₂ : Type u) (r₁ r₂ : Type v)",
    "doc_string": " A constructor for languages with only constants, unary and binary functions, and unary and binary relations.",
    "kind": "def",
    "type": "first_order.language"
  },
  {
    "name": "dense_range_stone_cech_unit",
    "statement": "theorem dense_range_stone_cech_unit {α : Type u} [topological_space α] : dense_range stone_cech_unit",
    "theorem": "{α : Type u} [topological_space α] : dense_range stone_cech_unit",
    "args": "{α : Type u} [topological_space α]",
    "doc_string": "The image of stone_cech_unit is dense. (But stone_cech_unit need  not be an embedding, for example if α is not Hausdorff.)",
    "kind": "theorem",
    "type": "dense_range stone_cech_unit"
  },
  {
    "name": "parse_result.pos",
    "statement": "def parse_result.pos {α : Type} : parse_result α → ℕ",
    "theorem": "{α : Type} : parse_result α → ℕ",
    "args": "{α : Type}",
    "doc_string": "For some `parse_result α`, give the position at which the result was provided, in either the `done` or the `fail` case.",
    "kind": "def",
    "type": "parse_result α → ℕ"
  },
  {
    "name": "matrix.special_linear_group",
    "statement": "def matrix.special_linear_group (n : Type u) [decidable_eq n] [fintype n] (R : Type v) [comm_ring R] : Type (max u v)",
    "theorem": "(n : Type u) [decidable_eq n] [fintype n] (R : Type v) [comm_ring R] : Type (max u v)",
    "args": "(n : Type u) [decidable_eq n] [fintype n] (R : Type v) [comm_ring R]",
    "doc_string": "`special_linear_group n R` is the group of `n` by `n` `R`-matrices with determinant equal to 1.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "list.kinsert",
    "statement": "def list.kinsert {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (l : list (sigma β)) : list (sigma β)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (l : list (sigma β)) : list (sigma β)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) (l : list (sigma β))",
    "doc_string": "Insert the pair `⟨a, b⟩` and erase the first pair with the key `a`.",
    "kind": "def",
    "type": "list (sigma β)"
  },
  {
    "name": "int_bounded_random",
    "statement": "def int_bounded_random  : bounded_random ℤ",
    "theorem": " : bounded_random ℤ",
    "args": "",
    "doc_string": " This `bounded_random` interval generates integers between `x` and `y` by first generating a natural number between `0` and `y - x` and shifting the result appropriately.",
    "kind": "def",
    "type": "bounded_random ℤ"
  },
  {
    "name": "lie_algebra.symplectic.J",
    "statement": "def lie_algebra.symplectic.J (l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R",
    "theorem": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R",
    "args": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R]",
    "doc_string": "The matrix defining the canonical skew-symmetric bilinear form.",
    "kind": "def",
    "type": "matrix (l ⊕ l) (l ⊕ l) R"
  },
  {
    "name": "linarith.preprocessor",
    "statement": "structure linarith.preprocessor  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A preprocessor transforms a proof of a proposition into a proof of a different propositon. The return type is `list expr`, since some preprocessing steps may create multiple new hypotheses, and some may remove a hypothesis from the list. A \"no-op\" preprocessor should return its input as a singleton list.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "is_open_map",
    "statement": "def is_open_map {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (f : α → β)",
    "doc_string": " A map `f : α → β` is said to be an *open map*, if the image of any open `U : set α` is open in `β`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "mv_polynomial.is_domain_fin",
    "statement": "theorem mv_polynomial.is_domain_fin (R : Type u) [comm_ring R] [is_domain R] (n : ℕ) : is_domain (mv_polynomial (fin n) R)",
    "theorem": "(R : Type u) [comm_ring R] [is_domain R] (n : ℕ) : is_domain (mv_polynomial (fin n) R)",
    "args": "(R : Type u) [comm_ring R] [is_domain R] (n : ℕ)",
    "doc_string": " Auxiliary lemma: Multivariate polynomials over an integral domain with variables indexed by `fin n` form an integral domain. This fact is proven inductively, and then used to prove the general case without any finiteness hypotheses. See `mv_polynomial.is_domain` for the general case.",
    "kind": "theorem",
    "type": "is_domain (mv_polynomial (fin n) R)"
  },
  {
    "name": "ordnode.glue",
    "statement": "def ordnode.glue {α : Type u} : ordnode α → ordnode α → ordnode α",
    "theorem": "{α : Type u} : ordnode α → ordnode α → ordnode α",
    "args": "{α : Type u}",
    "doc_string": " **Internal use only**  O(log(m+n)). Concatenate two trees that are balanced and ordered with respect to each other.",
    "kind": "def",
    "type": "ordnode α → ordnode α → ordnode α"
  },
  {
    "name": "list.next",
    "statement": "def list.next {α : Type u_1} [decidable_eq α] (l : list α) (x : α) (h : x ∈ l) : α",
    "theorem": "{α : Type u_1} [decidable_eq α] (l : list α) (x : α) (h : x ∈ l) : α",
    "args": "{α : Type u_1} [decidable_eq α] (l : list α) (x : α) (h : x ∈ l)",
    "doc_string": "Given an element `x : α` of `l : list α` such that `x ∈ l`, get the next element of `l`. This works from head to tail, (including a check for last element) so it will match on first hit, ignoring later duplicates.  For example:  * `next [1, 2, 3] 2 _ = 3`  * `next [1, 2, 3] 3 _ = 1`  * `next [1, 2, 3, 2, 4] 2 _ = 3`  * `next [1, 2, 3, 2] 2 _ = 3`  * `next [1, 1, 2, 3, 2] 1 _ = 1`",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "zero_hom_class",
    "statement": "structure zero_hom_class (F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_zero M] [has_zero N] : Type (max u_10 u_11 u_9)",
    "theorem": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_zero M] [has_zero N] : Type (max u_10 u_11 u_9)",
    "args": "(F : Type u_9) (M : out_param (Type u_10)) (N : out_param (Type u_11)) [has_zero M] [has_zero N]",
    "doc_string": " `zero_hom_class F M N` states that `F` is a type of zero-preserving homomorphisms.  You should extend this typeclass when you extend `zero_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_11 u_9)"
  },
  {
    "name": "complex_shape.down'",
    "statement": "def complex_shape.down' {α : Type u_1} [add_right_cancel_semigroup α] (a : α) : complex_shape α",
    "theorem": "{α : Type u_1} [add_right_cancel_semigroup α] (a : α) : complex_shape α",
    "args": "{α : Type u_1} [add_right_cancel_semigroup α] (a : α)",
    "doc_string": "The `complex_shape` allowing differentials from `X (j+a)` to `X j`. (For example when `a = 1`, a homology theory indexed by `ℕ` or `ℤ`)",
    "kind": "def",
    "type": "complex_shape α"
  },
  {
    "name": "category_theory.is_connected_zigzag",
    "statement": "theorem category_theory.is_connected_zigzag {J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J) : category_theory.zigzag j₁ j₂",
    "theorem": "{J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J) : category_theory.zigzag j₁ j₂",
    "args": "{J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J)",
    "doc_string": "In a connected category, any two objects are related by `zigzag`.",
    "kind": "theorem",
    "type": "category_theory.zigzag j₁ j₂"
  },
  {
    "name": "add_action.stabilizer.add_submonoid",
    "statement": "def add_action.stabilizer.add_submonoid (α : Type u) {β : Type v} [add_monoid α] [add_action α β] (b : β) : add_submonoid α",
    "theorem": "(α : Type u) {β : Type v} [add_monoid α] [add_action α β] (b : β) : add_submonoid α",
    "args": "(α : Type u) {β : Type v} [add_monoid α] [add_action α β] (b : β)",
    "doc_string": "The stabilizer of a point `b` as an additive submonoid of `α`.",
    "kind": "def",
    "type": "add_submonoid α"
  },
  {
    "name": "finite_dimensional.basis_unique",
    "statement": "def finite_dimensional.basis_unique {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] (h : finite_dimensional.finrank K V = 1) : basis ι K V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] (h : finite_dimensional.finrank K V = 1) : basis ι K V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] (h : finite_dimensional.finrank K V = 1)",
    "doc_string": "A module with dimension 1 has a basis with one element.",
    "kind": "def",
    "type": "basis ι K V"
  },
  {
    "name": "right.one_le_inv_iff",
    "statement": "theorem right.one_le_inv_iff {α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α}",
    "doc_string": "Uses `right` co(ntra)variant.",
    "kind": "theorem",
    "type": "1 ≤ a⁻¹ ↔ a ≤ 1"
  },
  {
    "name": "subsingleton_floor_ring",
    "statement": "theorem subsingleton_floor_ring {α : Type u_1} [linear_ordered_ring α] : subsingleton (floor_ring α)",
    "theorem": "{α : Type u_1} [linear_ordered_ring α] : subsingleton (floor_ring α)",
    "args": "{α : Type u_1} [linear_ordered_ring α]",
    "doc_string": "There exists at most one `floor_ring` structure on a given linear ordered ring.",
    "kind": "theorem",
    "type": "subsingleton (floor_ring α)"
  },
  {
    "name": "cancel_monoid",
    "statement": "structure cancel_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": "A monoid in which multiplication is cancellative.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "ring_char",
    "statement": "def ring_char (R : Type u) [non_assoc_semiring R] : ℕ",
    "theorem": "(R : Type u) [non_assoc_semiring R] : ℕ",
    "args": "(R : Type u) [non_assoc_semiring R]",
    "doc_string": "Noncomputable function that outputs the unique characteristic of a semiring.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "boolean_ring.to_boolean_algebra",
    "statement": "def boolean_ring.to_boolean_algebra {α : Type u_1} [boolean_ring α] : boolean_algebra α",
    "theorem": "{α : Type u_1} [boolean_ring α] : boolean_algebra α",
    "args": "{α : Type u_1} [boolean_ring α]",
    "doc_string": "The Boolean algebra structure on a Boolean ring.  The data is defined so that: * `a ⊔ b` unfolds to `a + b + a * b` * `a ⊓ b` unfolds to `a * b` * `a ≤ b` unfolds to `a + b + a * b = b` * `⊥` unfolds to `0` * `⊤` unfolds to `1` * `aᶜ` unfolds to `1 + a` * `a \\ b` unfolds to `a * (1 + b)`",
    "kind": "def",
    "type": "boolean_algebra α"
  },
  {
    "name": "matrix.mul_nonsing_inv",
    "statement": "theorem matrix.mul_nonsing_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : A.mul A⁻¹ = 1",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : A.mul A⁻¹ = 1",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det)",
    "doc_string": "The `nonsing_inv` of `A` is a right inverse.",
    "kind": "theorem",
    "type": "A.mul A⁻¹ = 1"
  },
  {
    "name": "ordnode.find_lt_aux",
    "statement": "def ordnode.find_lt_aux {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": "Auxiliary definition for `find_lt`.",
    "kind": "def",
    "type": "ordnode α → α → α"
  },
  {
    "name": "category_theory.idempotents.karoubi.biproducts.bicone",
    "statement": "def category_theory.idempotents.karoubi.biproducts.bicone {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] {J : Type v} [fintype J] (F : J → category_theory.idempotents.karoubi C) : category_theory.limits.bicone F",
    "theorem": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] {J : Type v} [fintype J] (F : J → category_theory.idempotents.karoubi C) : category_theory.limits.bicone F",
    "args": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_biproducts C] {J : Type v} [fintype J] (F : J → category_theory.idempotents.karoubi C)",
    "doc_string": " The `bicone` used in order to obtain the existence of the biproduct of a functor `J ⥤ karoubi C` when the category `C` is additive.",
    "kind": "def",
    "type": "category_theory.limits.bicone F"
  },
  {
    "name": "top_hom.comp",
    "statement": "def top_hom.comp {α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_top α] [has_top β] [has_top γ] (f : top_hom β γ) (g : top_hom α β) : top_hom α γ",
    "theorem": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_top α] [has_top β] [has_top γ] (f : top_hom β γ) (g : top_hom α β) : top_hom α γ",
    "args": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [has_top α] [has_top β] [has_top γ] (f : top_hom β γ) (g : top_hom α β)",
    "doc_string": "Composition of `top_hom`s as a `top_hom`.",
    "kind": "def",
    "type": "top_hom α γ"
  },
  {
    "name": "charted_space",
    "statement": "structure charted_space (H : Type u_5) [topological_space H] (M : Type u_6) [topological_space M] : Type (max u_5 u_6)",
    "theorem": "(H : Type u_5) [topological_space H] (M : Type u_6) [topological_space M] : Type (max u_5 u_6)",
    "args": "(H : Type u_5) [topological_space H] (M : Type u_6) [topological_space M]",
    "doc_string": " A charted space is a topological space endowed with an atlas, i.e., a set of local homeomorphisms taking value in a model space `H`, called charts, such that the domains of the charts cover the whole space. We express the covering property by chosing for each `x` a member `chart_at H x` of the atlas containing `x` in its source: in the smooth case, this is convenient to construct the tangent bundle in an efficient way. The model space is written as an explicit parameter as there can be several model spaces for a given topological space. For instance, a complex manifold (modelled over `ℂ^n`) will also be seen sometimes as a real manifold over `ℝ^(2n)`.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "submodule.finset_span_is_compact_element",
    "statement": "theorem submodule.finset_span_is_compact_element {R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ↑S)",
    "theorem": "{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ↑S)",
    "args": "{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M)",
    "doc_string": "The span of a finite subset is compact in the lattice of submodules.",
    "kind": "theorem",
    "type": "complete_lattice.is_compact_element (submodule.span R ↑S)"
  },
  {
    "name": "cycle.map",
    "statement": "def cycle.map {α : Type u_1} {β : Type u_2} (f : α → β) : cycle α → cycle β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) : cycle α → cycle β",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β)",
    "doc_string": "The lift of `list.map`.",
    "kind": "def",
    "type": "cycle α → cycle β"
  },
  {
    "name": "zero_lt.left.mul_lt_one_of_lt_of_lt",
    "statement": "theorem zero_lt.left.mul_lt_one_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "is_glb.bdd_below",
    "statement": "theorem is_glb.bdd_below {α : Type u} [preorder α] {s : set α} {a : α} (h : is_glb s a) : bdd_below s",
    "theorem": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_glb s a) : bdd_below s",
    "args": "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_glb s a)",
    "doc_string": "If `s` has a greatest lower bound, then it is bounded below.",
    "kind": "theorem",
    "type": "bdd_below s"
  },
  {
    "name": "tactic.apply_any_opt",
    "statement": "structure tactic.apply_any_opt  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Configuration options for `apply_any`: * `use_symmetry`: if `apply_any` fails to apply any lemma, call `symmetry` and try again. * `use_exfalso`: if `apply_any` fails to apply any lemma, call `exfalso` and try again. * `apply`: specify an alternative to `tactic.apply`; usually `apply := tactic.eapply`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "hash_map.replace_aux",
    "statement": "def hash_map.replace_aux {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) : list (Σ (a : α), β a) → list (Σ (a : α), β a)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) : list (Σ (a : α), β a) → list (Σ (a : α), β a)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a)",
    "doc_string": "Modify a bucket to replace a value in the list. Leaves the list unchanged if the key is not found.",
    "kind": "def",
    "type": "list (Σ (a : α), β a) → list (Σ (a : α), β a)"
  },
  {
    "name": "padic_norm.one",
    "statement": "theorem padic_norm.one (p : ℕ) : padic_norm p 1 = 1",
    "theorem": "(p : ℕ) : padic_norm p 1 = 1",
    "args": "(p : ℕ)",
    "doc_string": "The p-adic norm of 1 is 1.",
    "kind": "theorem",
    "type": "padic_norm p 1 = 1"
  },
  {
    "name": "sub_eq_add_neg",
    "statement": "theorem sub_eq_add_neg {G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b",
    "theorem": "{G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b",
    "args": "{G : Type u_1} [sub_neg_monoid G] (a b : G)",
    "doc_string": "Subtracting an element is the same as adding by its negative.  This is a duplicate of `sub_neg_monoid.sub_eq_mul_neg` ensuring that the types unfold better.",
    "kind": "theorem",
    "type": "a - b = a + -b"
  },
  {
    "name": "perfect_ring",
    "statement": "structure perfect_ring (R : Type u) [comm_semiring R] (p : ℕ) [fact (nat.prime p)] [char_p R p] : Type u",
    "theorem": "(R : Type u) [comm_semiring R] (p : ℕ) [fact (nat.prime p)] [char_p R p] : Type u",
    "args": "(R : Type u) [comm_semiring R] (p : ℕ) [fact (nat.prime p)] [char_p R p]",
    "doc_string": "A perfect ring is a ring of characteristic p that has p-th root.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "order.pred",
    "statement": "def order.pred {α : Type u_1} [preorder α] [pred_order α] : α → α",
    "theorem": "{α : Type u_1} [preorder α] [pred_order α] : α → α",
    "args": "{α : Type u_1} [preorder α] [pred_order α]",
    "doc_string": " The predecessor of an element. If `a` is not minimal, then `pred a` is the greatest element less than `a`. If `a` is minimal, then `pred a = a`.",
    "kind": "def",
    "type": "α → α"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.seq1",
    "statement": "def generalized_continued_fraction.int_fract_pair.seq1 {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : seq1 (generalized_continued_fraction.int_fract_pair K)",
    "theorem": "{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : seq1 (generalized_continued_fraction.int_fract_pair K)",
    "args": "{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K)",
    "doc_string": "Uses `int_fract_pair.stream` to create a sequence with head (i.e. `seq1`) of integer and fractional parts of a value `v`. The first value of `int_fract_pair.stream` is never `none`, so we can safely extract it and put the tail of the stream in the sequence part.  This is just an intermediate representation and users should not (need to) directly interact with it. The setup of rewriting/simplification lemmas that make the definitions easy to use is done in `algebra.continued_fractions.computation.translations`.",
    "kind": "def",
    "type": "seq1 (generalized_continued_fraction.int_fract_pair K)"
  },
  {
    "name": "rel.restrict_domain",
    "statement": "def rel.restrict_domain {α : Type u_1} {β : Type u_2} (r : rel α β) (s : set α) : rel {x // x ∈ s} β",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set α) : rel {x // x ∈ s} β",
    "args": "{α : Type u_1} {β : Type u_2} (r : rel α β) (s : set α)",
    "doc_string": "Restrict the domain of a relation to a subtype.",
    "kind": "def",
    "type": "rel {x // x ∈ s} β"
  },
  {
    "name": "psigma.subtype_ext",
    "statement": "theorem psigma.subtype_ext {α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁",
    "args": "{α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), subtype (p a)}",
    "doc_string": "A specialized ext lemma for equality of psigma types over an indexed subtype.",
    "kind": "theorem",
    "type": "x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁"
  },
  {
    "name": "category_theory.over.construct_products.over_binary_product_of_pullback",
    "statement": "theorem category_theory.over.construct_products.over_binary_product_of_pullback {C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C}",
    "doc_string": "Given a pullback in `C`, construct a binary product in `C/B`.",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_products (category_theory.over B)"
  },
  {
    "name": "subsemiring.mk'",
    "statement": "def subsemiring.mk' {R : Type u} [non_assoc_semiring R] (s : set R) (sm : submonoid R) (hm : ↑sm = s) (sa : add_submonoid R) (ha : ↑sa = s) : subsemiring R",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : set R) (sm : submonoid R) (hm : ↑sm = s) (sa : add_submonoid R) (ha : ↑sa = s) : subsemiring R",
    "args": "{R : Type u} [non_assoc_semiring R] (s : set R) (sm : submonoid R) (hm : ↑sm = s) (sa : add_submonoid R) (ha : ↑sa = s)",
    "doc_string": " Construct a `subsemiring R` from a set `s`, a submonoid `sm`, and an additive submonoid `sa` such that `x ∈ s ↔ x ∈ sm ↔ x ∈ sa`.",
    "kind": "def",
    "type": "subsemiring R"
  },
  {
    "name": "subsemigroup.has_bot",
    "statement": "def subsemigroup.has_bot {M : Type u_1} [has_mul M] : has_bot (subsemigroup M)",
    "theorem": "{M : Type u_1} [has_mul M] : has_bot (subsemigroup M)",
    "args": "{M : Type u_1} [has_mul M]",
    "doc_string": "The trivial subsemigroup `∅` of a magma `M`.",
    "kind": "def",
    "type": "has_bot (subsemigroup M)"
  },
  {
    "name": "turing.partrec_to_TM2.split_at_pred",
    "statement": "def turing.partrec_to_TM2.split_at_pred {α : Type u_1} (p : α → bool) : list α → list α × option α × list α",
    "theorem": "{α : Type u_1} (p : α → bool) : list α → list α × option α × list α",
    "args": "{α : Type u_1} (p : α → bool)",
    "doc_string": " This could be a general list definition, but it is also somewhat specialized to this application. `split_at_pred p L` will search `L` for the first element satisfying `p`. If it is found, say `L = l₁ ++ a :: l₂` where `a` satisfies `p` but `l₁` does not, then it returns `(l₁, some a, l₂)`. Otherwise, if there is no such element, it returns `(L, none, [])`.",
    "kind": "def",
    "type": "list α → list α × option α × list α"
  },
  {
    "name": "left_cancel_semigroup",
    "statement": "structure left_cancel_semigroup (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": "A `left_cancel_semigroup` is a semigroup such that `a * b = a * c` implies `b = c`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "group_topology.continuous_inv'",
    "statement": "theorem group_topology.continuous_inv' {α : Type u} [group α] (g : group_topology α) : continuous has_inv.inv",
    "theorem": "{α : Type u} [group α] (g : group_topology α) : continuous has_inv.inv",
    "args": "{α : Type u} [group α] (g : group_topology α)",
    "doc_string": "A version of the global `continuous_inv` suitable for dot notation.",
    "kind": "theorem",
    "type": "continuous has_inv.inv"
  },
  {
    "name": "add_pos_of_pos_of_nonneg",
    "statement": "theorem add_pos_of_pos_of_nonneg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b)",
    "doc_string": "**Alias** of `left.add_pos_of_pos_of_nonneg`.",
    "kind": "theorem",
    "type": "0 < a + b"
  },
  {
    "name": "surreal",
    "statement": "def surreal  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": " The type of surreal numbers. These are the numeric pre-games quotiented by the equivalence relation `x ≈ y ↔ x ≤ y ∧ y ≤ x`. In the quotient, the order becomes a total order.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "wseq.of_list",
    "statement": "def wseq.of_list {α : Type u} (l : list α) : wseq α",
    "theorem": "{α : Type u} (l : list α) : wseq α",
    "args": "{α : Type u} (l : list α)",
    "doc_string": "Turn a list into a weak sequence",
    "kind": "def",
    "type": "wseq α"
  },
  {
    "name": "measure_theory.simple_func.const",
    "statement": "def measure_theory.simple_func.const (α : Type u_1) {β : Type u_2} [measurable_space α] (b : β) : measure_theory.simple_func α β",
    "theorem": "(α : Type u_1) {β : Type u_2} [measurable_space α] (b : β) : measure_theory.simple_func α β",
    "args": "(α : Type u_1) {β : Type u_2} [measurable_space α] (b : β)",
    "doc_string": "Constant function as a `simple_func`.",
    "kind": "def",
    "type": "measure_theory.simple_func α β"
  },
  {
    "name": "category_theory.limits.pi_obj",
    "statement": "def category_theory.limits.pi_obj {β : Type w} {C : Type u} [category_theory.category C] (f : β → C) [category_theory.limits.has_product f] : C",
    "theorem": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) [category_theory.limits.has_product f] : C",
    "args": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) [category_theory.limits.has_product f]",
    "doc_string": " `pi_obj f` computes the product of a family of elements `f`. (It is defined as an abbreviation for `limit (discrete.functor f)`, so for most facts about `pi_obj f`, you will just use general facts about limits.)",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "is_localization.away",
    "statement": "def is_localization.away {R : Type u_1} [comm_semiring R] (x : R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop",
    "theorem": "{R : Type u_1} [comm_semiring R] (x : R) (S : Type u_2) [comm_semiring S] [algebra R S] : Prop",
    "args": "{R : Type u_1} [comm_semiring R] (x : R) (S : Type u_2) [comm_semiring S] [algebra R S]",
    "doc_string": " Given `x : R`, the typeclass `is_localization.away x S` states that `S` is isomorphic to the localization of `R` at the submonoid generated by `x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "znum.bit0",
    "statement": "def znum.bit0  : znum → znum",
    "theorem": " : znum → znum",
    "args": "",
    "doc_string": "`bit0 n` appends a `0` to the end of `n`, where `bit0 n = n0`.",
    "kind": "def",
    "type": "znum → znum"
  },
  {
    "name": "nat.eq_prime_pow_of_dvd_least_prime_pow",
    "statement": "theorem nat.eq_prime_pow_of_dvd_least_prime_pow {a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1)",
    "theorem": "{a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1)",
    "args": "{a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1))",
    "doc_string": "If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`.",
    "kind": "theorem",
    "type": "a = p ^ (k + 1)"
  },
  {
    "name": "multiset.pairwise",
    "statement": "def multiset.pairwise {α : Type u_1} (r : α → α → Prop) (m : multiset α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (m : multiset α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (m : multiset α)",
    "doc_string": " `pairwise r m` states that there exists a list of the elements s.t. `r` holds pairwise on this list.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "unique_prop",
    "statement": "def unique_prop {p : Prop} (h : p) : unique p",
    "theorem": "{p : Prop} (h : p) : unique p",
    "args": "{p : Prop} (h : p)",
    "doc_string": "Every provable proposition is unique, as all proofs are equal.",
    "kind": "def",
    "type": "unique p"
  },
  {
    "name": "category_theory.grothendieck_topology.trivial",
    "statement": "def category_theory.grothendieck_topology.trivial (C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C",
    "theorem": "(C : Type u) [category_theory.category C] : category_theory.grothendieck_topology C",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "The trivial Grothendieck topology, in which only the maximal sieve is covering. This topology is also known as the indiscrete, coarse, or chaotic topology.  See [MM92] Chapter III, Section 2, example (a), or https://en.wikipedia.org/wiki/Grothendieck_topology#The_discrete_and_indiscrete_topologies",
    "kind": "def",
    "type": "category_theory.grothendieck_topology C"
  },
  {
    "name": "neg_mem_class",
    "statement": "structure neg_mem_class (S : Type u_3) (G : Type u_4) [has_neg G] [set_like S G] : Type",
    "theorem": "(S : Type u_3) (G : Type u_4) [has_neg G] [set_like S G] : Type",
    "args": "(S : Type u_3) (G : Type u_4) [has_neg G] [set_like S G]",
    "doc_string": "`neg_mem_class S G` states `S` is a type of subsets `s ⊆ G` closed under negation.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "subtype.restrict",
    "statement": "def subtype.restrict {α : Sort u_1} {β : α → Type u_2} (p : α → Prop) (f : Π (x : α), β x) (x : subtype p) : β x.val",
    "theorem": "{α : Sort u_1} {β : α → Type u_2} (p : α → Prop) (f : Π (x : α), β x) (x : subtype p) : β x.val",
    "args": "{α : Sort u_1} {β : α → Type u_2} (p : α → Prop) (f : Π (x : α), β x) (x : subtype p)",
    "doc_string": "Restrict a (dependent) function to a subtype",
    "kind": "def",
    "type": "β x.val"
  },
  {
    "name": "category_theory.limits.fan",
    "statement": "def category_theory.limits.fan {β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Type (max w u v)",
    "theorem": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Type (max w u v)",
    "args": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C)",
    "doc_string": "A fan over `f : β → C` consists of a collection of maps from an object `P` to every `f b`.",
    "kind": "def",
    "type": "Type (max w u v)"
  },
  {
    "name": "ordnode.bounded",
    "statement": "def ordnode.bounded {α : Type u_1} [preorder α] : ordnode α → with_bot α → with_top α → Prop",
    "theorem": "{α : Type u_1} [preorder α] : ordnode α → with_bot α → with_top α → Prop",
    "args": "{α : Type u_1} [preorder α]",
    "doc_string": " `bounded t lo hi` says that every element `x ∈ t` is in the range `lo < x < hi`, and also this property holds recursively in subtrees, making the full tree a BST. The bounds can be set to `lo = ⊥` and `hi = ⊤` if we care only about the internal ordering constraints.",
    "kind": "def",
    "type": "ordnode α → with_bot α → with_top α → Prop"
  },
  {
    "name": "add_action.function_End",
    "statement": "def add_action.function_End {α : Type u_6} : add_action (additive (function.End α)) α",
    "theorem": "{α : Type u_6} : add_action (additive (function.End α)) α",
    "args": "{α : Type u_6}",
    "doc_string": "The tautological additive action by `additive (function.End α)` on `α`.",
    "kind": "def",
    "type": "add_action (additive (function.End α)) α"
  },
  {
    "name": "zero_hom.with_top_map",
    "statement": "def zero_hom.with_top_map {M : Type u_1} {N : Type u_2} [has_zero M] [has_zero N] (f : zero_hom M N) : zero_hom (with_top M) (with_top N)",
    "theorem": "{M : Type u_1} {N : Type u_2} [has_zero M] [has_zero N] (f : zero_hom M N) : zero_hom (with_top M) (with_top N)",
    "args": "{M : Type u_1} {N : Type u_2} [has_zero M] [has_zero N] (f : zero_hom M N)",
    "doc_string": "A version of `with_top.map` for `zero_hom`s",
    "kind": "def",
    "type": "zero_hom (with_top M) (with_top N)"
  },
  {
    "name": "list.map₂_left'",
    "statement": "def list.map₂_left' {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → option β → γ) : list α → list β → list γ × list β",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → option β → γ) : list α → list β → list γ × list β",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → option β → γ)",
    "doc_string": "Left-biased version of `list.map₂`. `map₂_left' f as bs` applies `f` to each pair of elements `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, `f` is applied to `none` for the remaining `aᵢ`. Returns the results of the `f` applications and the remaining `bs`.  ```lean map₂_left' prod.mk [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])  map₂_left' prod.mk [1] ['a', 'b'] = ([(1, some 'a')], ['b']) ```",
    "kind": "def",
    "type": "list α → list β → list γ × list β"
  },
  {
    "name": "bilin_form",
    "statement": "structure bilin_form (R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] : Type (max u_1 u_2)",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "`bilin_form R M` is the type of `R`-bilinear functions `M → M → R`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "has_finite_inter",
    "statement": "structure has_finite_inter {α : Type u_1} (S : set (set α)) : Type",
    "theorem": "{α : Type u_1} (S : set (set α)) : Type",
    "args": "{α : Type u_1} (S : set (set α))",
    "doc_string": "A structure encapsulating the fact that a set of sets is closed under finite intersection.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "lie_module.is_trivial",
    "statement": "structure lie_module.is_trivial (L : Type v) (M : Type w) [has_bracket L M] [has_zero M] : Prop",
    "theorem": "(L : Type v) (M : Type w) [has_bracket L M] [has_zero M] : Prop",
    "args": "(L : Type v) (M : Type w) [has_bracket L M] [has_zero M]",
    "doc_string": "A Lie (ring) module is trivial iff all brackets vanish.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nonarchimedean_group",
    "statement": "structure nonarchimedean_group (G : Type u_1) [group G] [topological_space G] : Prop",
    "theorem": "(G : Type u_1) [group G] [topological_space G] : Prop",
    "args": "(G : Type u_1) [group G] [topological_space G]",
    "doc_string": "A topological group is nonarchimedean if every neighborhood of 1 contains an open subgroup.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "zero_ne_one",
    "statement": "theorem zero_ne_one {M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀] : 0 ≠ 1",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀] : 0 ≠ 1",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀]",
    "doc_string": "In a nontrivial monoid with zero, zero and one are different.",
    "kind": "theorem",
    "type": "0 ≠ 1"
  },
  {
    "name": "category_theory.limits.binary_cofan",
    "statement": "def category_theory.limits.binary_cofan {C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] (X Y : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] (X Y : C)",
    "doc_string": "A binary cofan is just a cocone on a diagram indexing a coproduct.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "non_unital_semiring",
    "statement": "structure non_unital_semiring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "An associative but not-necessarily unital semiring.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "mvqpf",
    "statement": "structure mvqpf {n : ℕ} (F : typevec n → Type u_1) [mvfunctor F] : Type (max (u+1) u_1)",
    "theorem": "{n : ℕ} (F : typevec n → Type u_1) [mvfunctor F] : Type (max (u+1) u_1)",
    "args": "{n : ℕ} (F : typevec n → Type u_1) [mvfunctor F]",
    "doc_string": "Multivariate quotients of polynomial functors.",
    "kind": "structure",
    "type": "Type (max (u+1) u_1)"
  },
  {
    "name": "BoundedLattice",
    "statement": "structure BoundedLattice  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of bounded lattices with bounded lattice morphisms.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "is_bot",
    "statement": "def is_bot {α : Type u_1} [has_le α] (a : α) : Prop",
    "theorem": "{α : Type u_1} [has_le α] (a : α) : Prop",
    "args": "{α : Type u_1} [has_le α] (a : α)",
    "doc_string": " `a : α` is a bottom element of `α` if it is less than or equal to any other element of `α`. This predicate is roughly an unbundled version of `order_bot`, except that a preorder may have several bottom elements. When `α` is linear, this is useful to make a case disjunction on `no_min_order α` within a proof.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordinal.bmex",
    "statement": "def ordinal.bmex (o : ordinal) (f : Π (a : ordinal), a < o → ordinal) : ordinal",
    "theorem": "(o : ordinal) (f : Π (a : ordinal), a < o → ordinal) : ordinal",
    "args": "(o : ordinal) (f : Π (a : ordinal), a < o → ordinal)",
    "doc_string": "The minimum excluded ordinal of a family of ordinals indexed by the set of ordinals less than    some `o : ordinal.{u}`. This is a special case of `mex` over the family provided by    `family_of_bfamily`.     This is to `mex` as `bsup` is to `sup`.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "quaternion_algebra.basis",
    "statement": "structure quaternion_algebra.basis {R : Type u_1} (A : Type u_2) [comm_ring R] [ring A] [algebra R A] (c₁ c₂ : R) : Type u_2",
    "theorem": "{R : Type u_1} (A : Type u_2) [comm_ring R] [ring A] [algebra R A] (c₁ c₂ : R) : Type u_2",
    "args": "{R : Type u_1} (A : Type u_2) [comm_ring R] [ring A] [algebra R A] (c₁ c₂ : R)",
    "doc_string": " A quaternion basis contains the information both sufficient and necessary to construct an `R`-algebra homomorphism from `ℍ[R,c₁,c₂]` to `A`; or equivalently, a surjective `R`-algebra homomorphism from `ℍ[R,c₁,c₂]` to an `R`-subalgebra of `A`.  Note that for definitional convenience, `k` is provided as a field even though `i_mul_j` fully determines it.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "add_subgroup.index",
    "statement": "def add_subgroup.index {G : Type u_1} [add_group G] (H : add_subgroup G) : ℕ",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) : ℕ",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G)",
    "doc_string": "The index of a subgroup as a natural number, and returns 0 if the index is infinite.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "turing.respects",
    "statement": "def turing.respects {σ₁ : Type u_1} {σ₂ : Type u_2} (f₁ : σ₁ → option σ₁) (f₂ : σ₂ → option σ₂) (tr : σ₁ → σ₂ → Prop) : Prop",
    "theorem": "{σ₁ : Type u_1} {σ₂ : Type u_2} (f₁ : σ₁ → option σ₁) (f₂ : σ₂ → option σ₂) (tr : σ₁ → σ₂ → Prop) : Prop",
    "args": "{σ₁ : Type u_1} {σ₂ : Type u_2} (f₁ : σ₁ → option σ₁) (f₂ : σ₂ → option σ₂) (tr : σ₁ → σ₂ → Prop)",
    "doc_string": " Given a relation `tr : σ₁ → σ₂ → Prop` between state spaces, and state transition functions `f₁ : σ₁ → option σ₁` and `f₂ : σ₂ → option σ₂`, `respects f₁ f₂ tr` means that if `tr a₁ a₂` holds initially and `f₁` takes a step to `a₂` then `f₂` will take one or more steps before reaching a state `b₂` satisfying `tr a₂ b₂`, and if `f₁ a₁` terminates then `f₂ a₂` also terminates. Such a relation `tr` is also known as a refinement.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "set.is_pwo",
    "statement": "def set.is_pwo {α : Type u_1} [preorder α] (s : set α) : Prop",
    "theorem": "{α : Type u_1} [preorder α] (s : set α) : Prop",
    "args": "{α : Type u_1} [preorder α] (s : set α)",
    "doc_string": "A subset of a preorder is partially well-ordered when any infinite sequence contains  a monotone subsequence of length 2 (or equivalently, an infinite monotone subsequence).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "expr_map",
    "statement": "def expr_map (data : Type) : Type",
    "theorem": "(data : Type) : Type",
    "args": "(data : Type)",
    "doc_string": "An dictionary from `data` to expressions.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "normalize_scale_roots",
    "statement": "def normalize_scale_roots {R : Type u_1} [comm_ring R] (p : polynomial R) : polynomial R",
    "theorem": "{R : Type u_1} [comm_ring R] (p : polynomial R) : polynomial R",
    "args": "{R : Type u_1} [comm_ring R] (p : polynomial R)",
    "doc_string": "The monic polynomial whose roots are `p.leading_coeff * x` for roots `x` of `p`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "finset.subtype_map",
    "statement": "theorem finset.subtype_map {α : Type u_1} {s : finset α} (p : α → Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s",
    "theorem": "{α : Type u_1} {s : finset α} (p : α → Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s",
    "args": "{α : Type u_1} {s : finset α} (p : α → Prop) [decidable_pred p]",
    "doc_string": " `s.subtype p` converts back to `s.filter p` with `embedding.subtype`.",
    "kind": "theorem",
    "type": "finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s"
  },
  {
    "name": "option.mmap",
    "statement": "def option.mmap {m : Type u → Type v} [monad m] {α : Type w} {β : Type u} (f : α → m β) (o : option α) : m (option β)",
    "theorem": "{m : Type u → Type v} [monad m] {α : Type w} {β : Type u} (f : α → m β) (o : option α) : m (option β)",
    "args": "{m : Type u → Type v} [monad m] {α : Type w} {β : Type u} (f : α → m β) (o : option α)",
    "doc_string": "Map a monadic function `f : α → m β` over an `o : option α`, maybe producing a result.",
    "kind": "def",
    "type": "m (option β)"
  },
  {
    "name": "monoid_algebra.finite_type_of_fg",
    "statement": "def monoid_algebra.finite_type_of_fg {R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [monoid.fg M] : algebra.finite_type R (monoid_algebra R M)",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [monoid.fg M] : algebra.finite_type R (monoid_algebra R M)",
    "args": "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [monoid.fg M]",
    "doc_string": "If a monoid `M` is finitely generated then `monoid_algebra R M` is of finite type.",
    "kind": "def",
    "type": "algebra.finite_type R (monoid_algebra R M)"
  },
  {
    "name": "matrix.vec_mul_vec",
    "statement": "def matrix.vec_mul_vec {m : Type u_2} {n : Type u_3} {α : Type v} [has_mul α] (w : m → α) (v : n → α) : matrix m n α",
    "theorem": "{m : Type u_2} {n : Type u_3} {α : Type v} [has_mul α] (w : m → α) (v : n → α) : matrix m n α",
    "args": "{m : Type u_2} {n : Type u_3} {α : Type v} [has_mul α] (w : m → α) (v : n → α)",
    "doc_string": "For two vectors `w` and `v`, `vec_mul_vec w v i j` is defined to be `w i * v j`.    Put another way, `vec_mul_vec w v` is exactly `col w ⬝ row v`.",
    "kind": "def",
    "type": "matrix m n α"
  },
  {
    "name": "ordinal.blsub",
    "statement": "def ordinal.blsub (o : ordinal) (f : Π (a : ordinal), a < o → ordinal) : ordinal",
    "theorem": "(o : ordinal) (f : Π (a : ordinal), a < o → ordinal) : ordinal",
    "args": "(o : ordinal) (f : Π (a : ordinal), a < o → ordinal)",
    "doc_string": "The least strict upper bound of a family of ordinals indexed by the set of ordinals less than    some `o : ordinal.{u}`.     This is to `lsub` as `bsup` is to `sup`.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "multiset.dedup",
    "statement": "def multiset.dedup {α : Type u_1} [decidable_eq α] (s : multiset α) : multiset α",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : multiset α) : multiset α",
    "args": "{α : Type u_1} [decidable_eq α] (s : multiset α)",
    "doc_string": "`dedup s` removes duplicates from `s`, yielding a `nodup` multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "category_theory.limits.has_images",
    "statement": "structure category_theory.limits.has_images (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_images` asserts that every morphism has an image.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nat.le_pow_iff_clog_le",
    "statement": "theorem nat.le_pow_iff_clog_le {b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ nat.clog b x ≤ y",
    "theorem": "{b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ nat.clog b x ≤ y",
    "args": "{b : ℕ} (hb : 1 < b) {x y : ℕ}",
    "doc_string": "`clog b` and `pow b` form a Galois connection.",
    "kind": "theorem",
    "type": "x ≤ b ^ y ↔ nat.clog b x ≤ y"
  },
  {
    "name": "subring.to_subfield",
    "statement": "def subring.to_subfield {K : Type u} [field K] (s : subring K) (hinv : ∀ (x : K), x ∈ s → x⁻¹ ∈ s) : subfield K",
    "theorem": "{K : Type u} [field K] (s : subring K) (hinv : ∀ (x : K), x ∈ s → x⁻¹ ∈ s) : subfield K",
    "args": "{K : Type u} [field K] (s : subring K) (hinv : ∀ (x : K), x ∈ s → x⁻¹ ∈ s)",
    "doc_string": "A `subring` containing inverses is a `subfield`.",
    "kind": "def",
    "type": "subfield K"
  },
  {
    "name": "discrete_topology_iff_nhds",
    "statement": "theorem discrete_topology_iff_nhds {X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure",
    "theorem": "{X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure",
    "args": "{X : Type u_1} [topological_space X]",
    "doc_string": " This lemma characterizes discrete topological spaces as those whose singletons are neighbourhoods.",
    "kind": "theorem",
    "type": "discrete_topology X ↔ nhds = has_pure.pure"
  },
  {
    "name": "multiset.Ici",
    "statement": "def multiset.Ici {α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : multiset α",
    "theorem": "{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α) : multiset α",
    "args": "{α : Type u_1} [preorder α] [order_top α] [locally_finite_order α] (a : α)",
    "doc_string": "The multiset of elements `x` such that `a ≤ x`. Basically `set.Ici a` as a multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "nat.digits_aux_1",
    "statement": "def nat.digits_aux_1 (n : ℕ) : list ℕ",
    "theorem": "(n : ℕ) : list ℕ",
    "args": "(n : ℕ)",
    "doc_string": "(Impl.) An auxiliary definition for `digits`, to help get the desired definitional unfolding.",
    "kind": "def",
    "type": "list ℕ"
  },
  {
    "name": "order_iso_class",
    "statement": "structure order_iso_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_le α] [has_le β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_le α] [has_le β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [has_le α] [has_le β]",
    "doc_string": " `order_iso_class F α β` states that `F` is a type of order isomorphisms.  You should extend this class when you extend `order_iso`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "normed_division_ring",
    "statement": "structure normed_division_ring (α : Type u_5) : Type u_5",
    "theorem": "(α : Type u_5) : Type u_5",
    "args": "(α : Type u_5)",
    "doc_string": " A normed division ring is a division ring endowed with a seminorm which satisfies the equality `∥x y∥ = ∥x∥ ∥y∥`.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "omega_complete_partial_order.continuous_hom",
    "statement": "structure omega_complete_partial_order.continuous_hom (α : Type u) (β : Type v) [omega_complete_partial_order α] [omega_complete_partial_order β] : Type (max u v)",
    "theorem": "(α : Type u) (β : Type v) [omega_complete_partial_order α] [omega_complete_partial_order β] : Type (max u v)",
    "args": "(α : Type u) (β : Type v) [omega_complete_partial_order α] [omega_complete_partial_order β]",
    "doc_string": " A monotone function on `ω`-continuous partial orders is said to be continuous if for every chain `c : chain α`, `f (⊔ i, c i) = ⊔ i, f (c i)`. This is just the bundled version of `order_hom.continuous`.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "commutator",
    "statement": "def commutator (G : Type u) [group G] : subgroup G",
    "theorem": "(G : Type u) [group G] : subgroup G",
    "args": "(G : Type u) [group G]",
    "doc_string": "The commutator subgroup of a group G is the normal subgroup  generated by the commutators [p,q]=`p*q*p⁻¹*q⁻¹`.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "uniform_inducing.uniform_embedding",
    "statement": "theorem uniform_inducing.uniform_embedding {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f) : uniform_embedding f",
    "theorem": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f) : uniform_embedding f",
    "args": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f)",
    "doc_string": " If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective, hence it is a `uniform_embedding`.",
    "kind": "theorem",
    "type": "uniform_embedding f"
  },
  {
    "name": "submodule.quotient_rel",
    "statement": "def submodule.quotient_rel {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) : setoid M",
    "theorem": "{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M) : setoid M",
    "args": "{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] (p : submodule R M)",
    "doc_string": " The equivalence relation associated to a submodule `p`, defined by `x ≈ y` iff `-x + y ∈ p`.  Note this is equivalent to `y - x ∈ p`, but defined this way to be be defeq to the `add_subgroup` version, where commutativity can't be assumed.",
    "kind": "def",
    "type": "setoid M"
  },
  {
    "name": "matrix.has_inv",
    "statement": "def matrix.has_inv {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] : has_inv (matrix n n α)",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] : has_inv (matrix n n α)",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α]",
    "doc_string": "The inverse of a square matrix, when it is invertible (and zero otherwise).",
    "kind": "def",
    "type": "has_inv (matrix n n α)"
  },
  {
    "name": "sym2.mem",
    "statement": "def sym2.mem {α : Type u_1} (x : α) (z : sym2 α) : Prop",
    "theorem": "{α : Type u_1} (x : α) (z : sym2 α) : Prop",
    "args": "{α : Type u_1} (x : α) (z : sym2 α)",
    "doc_string": "This is a predicate that determines whether a given term is a member of a term of the symmetric square.  From this point of view, the symmetric square is the subtype of cardinality-two multisets on `α`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "separable_locally_compact_group.sigma_compact_space",
    "statement": "def separable_locally_compact_group.sigma_compact_space {G : Type w} [topological_space G] [group G] [topological_group G] [topological_space.separable_space G] [locally_compact_space G] : sigma_compact_space G",
    "theorem": "{G : Type w} [topological_space G] [group G] [topological_group G] [topological_space.separable_space G] [locally_compact_space G] : sigma_compact_space G",
    "args": "{G : Type w} [topological_space G] [group G] [topological_group G] [topological_space.separable_space G] [locally_compact_space G]",
    "doc_string": "Every locally compact separable topological group is σ-compact.  Note: this is not true if we drop the topological group hypothesis.",
    "kind": "def",
    "type": "sigma_compact_space G"
  },
  {
    "name": "pgame.equiv",
    "statement": "def pgame.equiv (x y : pgame) : Prop",
    "theorem": "(x y : pgame) : Prop",
    "args": "(x y : pgame)",
    "doc_string": " The equivalence relation on pre-games. Two pre-games `x`, `y` are equivalent if `x ≤ y` and `y ≤ x`.  If `x ≈ 0`, then the second player can always win `x`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "filter.lift",
    "statement": "def filter.lift {α : Type u_1} {β : Type u_2} (f : filter α) (g : set α → filter β) : filter β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : filter α) (g : set α → filter β) : filter β",
    "args": "{α : Type u_1} {β : Type u_2} (f : filter α) (g : set α → filter β)",
    "doc_string": " A variant on `bind` using a function `g` taking a set instead of a member of `α`. This is essentially a push-forward along a function mapping each set to a filter.",
    "kind": "def",
    "type": "filter β"
  },
  {
    "name": "right_add_coset",
    "statement": "def right_add_coset {α : Type u_1} [has_add α] (s : set α) (a : α) : set α",
    "theorem": "{α : Type u_1} [has_add α] (s : set α) (a : α) : set α",
    "args": "{α : Type u_1} [has_add α] (s : set α) (a : α)",
    "doc_string": "The right coset `s+a` for an element `a : α` and a subset `s : set α`",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "algebra.finite_presentation.self",
    "statement": "theorem algebra.finite_presentation.self (R : Type u_1) [comm_ring R] : algebra.finite_presentation R R",
    "theorem": "(R : Type u_1) [comm_ring R] : algebra.finite_presentation R R",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": "`R` is finitely presented as `R`-algebra.",
    "kind": "theorem",
    "type": "algebra.finite_presentation R R"
  },
  {
    "name": "local_equiv",
    "statement": "structure local_equiv (α : Type u_5) (β : Type u_6) : Type (max u_5 u_6)",
    "theorem": "(α : Type u_5) (β : Type u_6) : Type (max u_5 u_6)",
    "args": "(α : Type u_5) (β : Type u_6)",
    "doc_string": " Local equivalence between subsets `source` and `target` of α and β respectively. The (global) maps `to_fun : α → β` and `inv_fun : β → α` map `source` to `target` and conversely, and are inverse to each other there. The values of `to_fun` outside of `source` and of `inv_fun` outside of `target` are irrelevant.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "nat.exists_strict_mono",
    "statement": "theorem nat.exists_strict_mono (α : Type u) [preorder α] [nonempty α] [no_max_order α] : ∃ (f : ℕ → α), strict_mono f",
    "theorem": "(α : Type u) [preorder α] [nonempty α] [no_max_order α] : ∃ (f : ℕ → α), strict_mono f",
    "args": "(α : Type u) [preorder α] [nonempty α] [no_max_order α]",
    "doc_string": " If `α` is a nonempty preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α`.",
    "kind": "theorem",
    "type": "∃ (f : ℕ → α), strict_mono f"
  },
  {
    "name": "category_theory.is_filtered.max₃",
    "statement": "def category_theory.is_filtered.max₃ {C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j₁ j₂ j₃ : C) : C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j₁ j₂ j₃ : C) : C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.is_filtered C] (j₁ j₂ j₃ : C)",
    "doc_string": "`max₃ j₁ j₂ j₃` is an arbitrary choice of object to the right of `j₁`, `j₂` and `j₃`, whose existence is ensured by `is_filtered`.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "subtype.pseudo_emetric_space",
    "statement": "def subtype.pseudo_emetric_space {α : Type u_1} {p : α → Prop} [pseudo_emetric_space α] : pseudo_emetric_space (subtype p)",
    "theorem": "{α : Type u_1} {p : α → Prop} [pseudo_emetric_space α] : pseudo_emetric_space (subtype p)",
    "args": "{α : Type u_1} {p : α → Prop} [pseudo_emetric_space α]",
    "doc_string": "Pseudoemetric space instance on subsets of pseudoemetric spaces",
    "kind": "def",
    "type": "pseudo_emetric_space (subtype p)"
  },
  {
    "name": "Fintype",
    "statement": "def Fintype  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of finite types.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "alternating_map.of_subsingleton",
    "statement": "def alternating_map.of_subsingleton (R : Type u_1) [semiring R] (N : Type u_3) [add_comm_monoid N] [module R N] {ι : Type u_6} [decidable_eq ι] [subsingleton ι] (i : ι) : alternating_map R N N ι",
    "theorem": "(R : Type u_1) [semiring R] (N : Type u_3) [add_comm_monoid N] [module R N] {ι : Type u_6} [decidable_eq ι] [subsingleton ι] (i : ι) : alternating_map R N N ι",
    "args": "(R : Type u_1) [semiring R] (N : Type u_3) [add_comm_monoid N] [module R N] {ι : Type u_6} [decidable_eq ι] [subsingleton ι] (i : ι)",
    "doc_string": "The evaluation map from `ι → N` to `N` at a given `i` is alternating when `ι` is subsingleton.",
    "kind": "def",
    "type": "alternating_map R N N ι"
  },
  {
    "name": "pos_num.sub'",
    "statement": "def pos_num.sub'  : pos_num → pos_num → znum",
    "theorem": " : pos_num → pos_num → znum",
    "args": "",
    "doc_string": "Subtraction of two `pos_num`s, producing a `znum`.",
    "kind": "def",
    "type": "pos_num → pos_num → znum"
  },
  {
    "name": "bilin_form.is_skew_adjoint",
    "statement": "def bilin_form.is_skew_adjoint {R₁ : Type u_3} {M₁ : Type u_4} [ring R₁] [add_comm_group M₁] [module R₁ M₁] (B₁ : bilin_form R₁ M₁) (f : module.End R₁ M₁) : Prop",
    "theorem": "{R₁ : Type u_3} {M₁ : Type u_4} [ring R₁] [add_comm_group M₁] [module R₁ M₁] (B₁ : bilin_form R₁ M₁) (f : module.End R₁ M₁) : Prop",
    "args": "{R₁ : Type u_3} {M₁ : Type u_4} [ring R₁] [add_comm_group M₁] [module R₁ M₁] (B₁ : bilin_form R₁ M₁) (f : module.End R₁ M₁)",
    "doc_string": " An endomorphism of a module is skew-adjoint with respect to a bilinear form if its negation serves as an adjoint.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_square.inv",
    "statement": "theorem is_square.inv {α : Type u_2} [division_monoid α] {a : α} : is_square a → is_square a⁻¹",
    "theorem": "{α : Type u_2} [division_monoid α] {a : α} : is_square a → is_square a⁻¹",
    "args": "{α : Type u_2} [division_monoid α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of is_square_inv`.",
    "kind": "theorem",
    "type": "is_square a → is_square a⁻¹"
  },
  {
    "name": "nat.digits",
    "statement": "def nat.digits  : ℕ → ℕ → list ℕ",
    "theorem": " : ℕ → ℕ → list ℕ",
    "args": "",
    "doc_string": "`digits b n` gives the digits, in little-endian order, of a natural number `n` in a specified base `b`.  In any base, we have `of_digits b L = L.foldr (λ x y, x + b * y) 0`. * For any `2 ≤ b`, we have `l < b` for any `l ∈ digits b n`,   and the last digit is not zero.   This uniquely specifies the behaviour of `digits b`. * For `b = 1`, we define `digits 1 n = list.repeat 1 n`. * For `b = 0`, we define `digits 0 n = [n]`, except `digits 0 0 = []`.  Note this differs from the existing `nat.to_digits` in core, which is used for printing numerals. In particular, `nat.to_digits b 0 = [0]`, while `digits b 0 = []`.",
    "kind": "def",
    "type": "ℕ → ℕ → list ℕ"
  },
  {
    "name": "hash_map.of_list",
    "statement": "def hash_map.of_list {α : Type u} {β : α → Type v} [decidable_eq α] (l : list (Σ (a : α), β a)) (hash_fn : α → ℕ) : hash_map α β",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (l : list (Σ (a : α), β a)) (hash_fn : α → ℕ) : hash_map α β",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (l : list (Σ (a : α), β a)) (hash_fn : α → ℕ)",
    "doc_string": "Construct a hash map from a list of key-value pairs.",
    "kind": "def",
    "type": "hash_map α β"
  },
  {
    "name": "lie_subalgebra_of_subalgebra",
    "statement": "def lie_subalgebra_of_subalgebra (R : Type u) [comm_ring R] (A : Type v) [ring A] [algebra R A] (A' : subalgebra R A) : lie_subalgebra R A",
    "theorem": "(R : Type u) [comm_ring R] (A : Type v) [ring A] [algebra R A] (A' : subalgebra R A) : lie_subalgebra R A",
    "args": "(R : Type u) [comm_ring R] (A : Type v) [ring A] [algebra R A] (A' : subalgebra R A)",
    "doc_string": "A subalgebra of an associative algebra is a Lie subalgebra of the associated Lie algebra.",
    "kind": "def",
    "type": "lie_subalgebra R A"
  },
  {
    "name": "list.last'",
    "statement": "def list.last' {α : Type u_1} : list α → option α",
    "theorem": "{α : Type u_1} : list α → option α",
    "args": "{α : Type u_1}",
    "doc_string": " `last' xs` returns the last element of `xs` if `xs` is non-empty; it returns `none` otherwise",
    "kind": "def",
    "type": "list α → option α"
  },
  {
    "name": "list.form_perm",
    "statement": "def list.form_perm {α : Type u_1} [decidable_eq α] (l : list α) : equiv.perm α",
    "theorem": "{α : Type u_1} [decidable_eq α] (l : list α) : equiv.perm α",
    "args": "{α : Type u_1} [decidable_eq α] (l : list α)",
    "doc_string": "A list `l : list α` can be interpreted as a `equiv.perm α` where each element in the list is permuted to the next one, defined as `form_perm`. When we have that `nodup l`, we prove that `equiv.perm.support (form_perm l) = l.to_finset`, and that `form_perm l` is rotationally invariant, in `form_perm_rotate`.",
    "kind": "def",
    "type": "equiv.perm α"
  },
  {
    "name": "has_compact_mul_support",
    "statement": "def has_compact_mul_support {α : Type u_2} {β : Type u_4} [topological_space α] [has_one β] (f : α → β) : Prop",
    "theorem": "{α : Type u_2} {β : Type u_4} [topological_space α] [has_one β] (f : α → β) : Prop",
    "args": "{α : Type u_2} {β : Type u_4} [topological_space α] [has_one β] (f : α → β)",
    "doc_string": " A function `f` *has compact multiplicative support* or is *compactly supported* if the closure of the multiplicative support of `f` is compact. In a T₂ space this is equivalent to `f` being equal to `1` outside a compact set.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "setoid.has_le",
    "statement": "def setoid.has_le {α : Type u_1} : has_le (setoid α)",
    "theorem": "{α : Type u_1} : has_le (setoid α)",
    "args": "{α : Type u_1}",
    "doc_string": "Defining `≤` for equivalence relations.",
    "kind": "def",
    "type": "has_le (setoid α)"
  },
  {
    "name": "is_add_group_hom.ker",
    "statement": "def is_add_group_hom.ker {G : Type u_1} {H : Type u_2} [add_group H] (f : G → H) : set G",
    "theorem": "{G : Type u_1} {H : Type u_2} [add_group H] (f : G → H) : set G",
    "args": "{G : Type u_1} {H : Type u_2} [add_group H] (f : G → H)",
    "doc_string": "`ker f : set A` is the underlying subset of the kernel of a map `A → B`",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "fin.random",
    "statement": "def fin.random {g : Type} [random_gen g] {n : ℕ} [fact (0 < n)] : rand_g g (fin n)",
    "theorem": "{g : Type} [random_gen g] {n : ℕ} [fact (0 < n)] : rand_g g (fin n)",
    "args": "{g : Type} [random_gen g] {n : ℕ} [fact (0 < n)]",
    "doc_string": "generate a `fin` randomly",
    "kind": "def",
    "type": "rand_g g (fin n)"
  },
  {
    "name": "padic_norm.zero",
    "statement": "theorem padic_norm.zero (p : ℕ) : padic_norm p 0 = 0",
    "theorem": "(p : ℕ) : padic_norm p 0 = 0",
    "args": "(p : ℕ)",
    "doc_string": "The p-adic norm of 0 is 0.",
    "kind": "theorem",
    "type": "padic_norm p 0 = 0"
  },
  {
    "name": "free_add_semigroup.of",
    "statement": "def free_add_semigroup.of {α : Type u} (x : α) : free_add_semigroup α",
    "theorem": "{α : Type u} (x : α) : free_add_semigroup α",
    "args": "{α : Type u} (x : α)",
    "doc_string": "The embedding `α → free_add_semigroup α`.",
    "kind": "def",
    "type": "free_add_semigroup α"
  },
  {
    "name": "principal_seg.has_coe_initial_seg",
    "statement": "def principal_seg.has_coe_initial_seg {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [is_trans β s] : has_coe (principal_seg r s) (initial_seg r s)",
    "theorem": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [is_trans β s] : has_coe (principal_seg r s) (initial_seg r s)",
    "args": "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} [is_trans β s]",
    "doc_string": "A principal segment is in particular an initial segment.",
    "kind": "def",
    "type": "has_coe (principal_seg r s) (initial_seg r s)"
  },
  {
    "name": "mvqpf.pi",
    "statement": "def mvqpf.pi {n : ℕ} {A : Type u} (F : A → typevec n → Type u) (v : typevec n) : Type u",
    "theorem": "{n : ℕ} {A : Type u} (F : A → typevec n → Type u) (v : typevec n) : Type u",
    "args": "{n : ℕ} {A : Type u} (F : A → typevec n → Type u) (v : typevec n)",
    "doc_string": " Dependent product of of an `n`-ary functor. The sum can range over data types like `ℕ` or over `Type.{u-1}`",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "semiquot.blur",
    "statement": "def semiquot.blur {α : Type u_1} (s : set α) (q : semiquot α) : semiquot α",
    "theorem": "{α : Type u_1} (s : set α) (q : semiquot α) : semiquot α",
    "args": "{α : Type u_1} (s : set α) (q : semiquot α)",
    "doc_string": "Replace `s` in a `q : semiquot α` with a union `s ∪ q.s`",
    "kind": "def",
    "type": "semiquot α"
  },
  {
    "name": "tactic.id_tag.assoc_proof",
    "statement": "def tactic.id_tag.assoc_proof  : unit",
    "theorem": " : unit",
    "args": "",
    "doc_string": "Tag for proofs generated by `assoc_rewrite`.",
    "kind": "def",
    "type": "unit"
  },
  {
    "name": "cubic.to_poly",
    "statement": "def cubic.to_poly {R : Type u_1} [semiring R] (P : cubic R) : polynomial R",
    "theorem": "{R : Type u_1} [semiring R] (P : cubic R) : polynomial R",
    "args": "{R : Type u_1} [semiring R] (P : cubic R)",
    "doc_string": "Convert a cubic polynomial to a polynomial.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "strict_order.cof",
    "statement": "def strict_order.cof {α : Type u_1} (r : α → α → Prop) : cardinal",
    "theorem": "{α : Type u_1} (r : α → α → Prop) : cardinal",
    "args": "{α : Type u_1} (r : α → α → Prop)",
    "doc_string": " Cofinality of a strict order `≺`. This is the smallest cardinality of a set `S : set α` such that `∀ a, ∃ b ∈ S, ¬ b ≺ a`.",
    "kind": "def",
    "type": "cardinal"
  },
  {
    "name": "pfunctor.Idx",
    "statement": "def pfunctor.Idx (P : pfunctor) : Type u_1",
    "theorem": "(P : pfunctor) : Type u_1",
    "args": "(P : pfunctor)",
    "doc_string": " `Idx` identifies a location inside the application of a pfunctor. For `F : pfunctor`, `x : F.obj α` and `i : F.Idx`, `i` can designate one part of `x` or is invalid, if `i.1 ≠ x.1`",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "list.partition_map",
    "statement": "def list.partition_map {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β ⊕ γ) : list α → list β × list γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β ⊕ γ) : list α → list β × list γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β ⊕ γ)",
    "doc_string": "Given a function `f : α → β ⊕ γ`, `partition_map f l` maps the list by `f`  whilst partitioning the result it into a pair of lists, `list β × list γ`,  partitioning the `sum.inl _` into the left list, and the `sum.inr _` into the right list.  `partition_map (id : ℕ ⊕ ℕ → ℕ ⊕ ℕ) [inl 0, inr 1, inl 2] = ([0,2], [1])`",
    "kind": "def",
    "type": "list α → list β × list γ"
  },
  {
    "name": "fin.succ_above_left_injective",
    "statement": "theorem fin.succ_above_left_injective {n : ℕ} : function.injective fin.succ_above",
    "theorem": "{n : ℕ} : function.injective fin.succ_above",
    "args": "{n : ℕ}",
    "doc_string": "`succ_above` is injective at the pivot",
    "kind": "theorem",
    "type": "function.injective fin.succ_above"
  },
  {
    "name": "set.has_npow",
    "statement": "def set.has_npow {α : Type u_2} [has_one α] [has_mul α] : has_pow (set α) ℕ",
    "theorem": "{α : Type u_2} [has_one α] [has_mul α] : has_pow (set α) ℕ",
    "args": "{α : Type u_2} [has_one α] [has_mul α]",
    "doc_string": " Repeated pointwise multiplication (not the same as pointwise repeated multiplication!) of a `set`. See note [pointwise nat action].",
    "kind": "def",
    "type": "has_pow (set α) ℕ"
  },
  {
    "name": "has_sbtw.sbtw.cyclic_right",
    "statement": "theorem has_sbtw.sbtw.cyclic_right {α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c)",
    "doc_string": "**Alias** of sbtw_cyclic_right`.",
    "kind": "theorem",
    "type": "has_sbtw.sbtw c a b"
  },
  {
    "name": "auto_param",
    "statement": "def auto_param (α : Sort u) (tac_name : name) : Sort u",
    "theorem": "(α : Sort u) (tac_name : name) : Sort u",
    "args": "(α : Sort u) (tac_name : name)",
    "doc_string": "Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses    the tactic declaration names tac_name to synthesize the argument.    Like opt_param, this gadget only affects elaboration.    For example, the tactic will *not* be invoked during type class resolution.",
    "kind": "def",
    "type": "Sort u"
  },
  {
    "name": "category_theory.limits.limit_cone_of_unique",
    "statement": "def category_theory.limits.limit_cone_of_unique {β : Type w} {C : Type u} [category_theory.category C] [unique β] (f : β → C) : category_theory.limits.limit_cone (category_theory.discrete.functor f)",
    "theorem": "{β : Type w} {C : Type u} [category_theory.category C] [unique β] (f : β → C) : category_theory.limits.limit_cone (category_theory.discrete.functor f)",
    "args": "{β : Type w} {C : Type u} [category_theory.category C] [unique β] (f : β → C)",
    "doc_string": "The limit cone for the product over an index type with exactly one term.",
    "kind": "def",
    "type": "category_theory.limits.limit_cone (category_theory.discrete.functor f)"
  },
  {
    "name": "measure_theory.strongly_measurable_const'",
    "statement": "theorem measure_theory.strongly_measurable_const' {α : Type u_1} {β : Type u_2} {m : measurable_space α} [topological_space β] {f : α → β} (hf : ∀ (x y : α), f x = f y) : measure_theory.strongly_measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} {m : measurable_space α} [topological_space β] {f : α → β} (hf : ∀ (x y : α), f x = f y) : measure_theory.strongly_measurable f",
    "args": "{α : Type u_1} {β : Type u_2} {m : measurable_space α} [topological_space β] {f : α → β} (hf : ∀ (x y : α), f x = f y)",
    "doc_string": " A version of `strongly_measurable_const` that assumes `f x = f y` for all `x, y`. This version works for functions between empty types.",
    "kind": "theorem",
    "type": "measure_theory.strongly_measurable f"
  },
  {
    "name": "setoid.has_Inf",
    "statement": "def setoid.has_Inf {α : Type u_1} : has_Inf (setoid α)",
    "theorem": "{α : Type u_1} : has_Inf (setoid α)",
    "args": "{α : Type u_1}",
    "doc_string": "The infimum of a set of equivalence relations.",
    "kind": "def",
    "type": "has_Inf (setoid α)"
  },
  {
    "name": "category_theory.with_terminal",
    "statement": "inductive category_theory.with_terminal (C : Type u) [category_theory.category C] : Type u",
    "theorem": "(C : Type u) [category_theory.category C] : Type u",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "Formally adjoin a terminal object to a category.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "prod.non_assoc_semiring",
    "statement": "def prod.non_assoc_semiring {R : Type u_1} {S : Type u_3} [non_assoc_semiring R] [non_assoc_semiring S] : non_assoc_semiring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [non_assoc_semiring R] [non_assoc_semiring S] : non_assoc_semiring (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [non_assoc_semiring R] [non_assoc_semiring S]",
    "doc_string": "Product of two `non_assoc_semiring`s is a `non_assoc_semiring`.",
    "kind": "def",
    "type": "non_assoc_semiring (R × S)"
  },
  {
    "name": "wseq.bind",
    "statement": "def wseq.bind {α : Type u} {β : Type v} (s : wseq α) (f : α → wseq β) : wseq β",
    "theorem": "{α : Type u} {β : Type v} (s : wseq α) (f : α → wseq β) : wseq β",
    "args": "{α : Type u} {β : Type v} (s : wseq α) (f : α → wseq β)",
    "doc_string": "Monadic bind operator for weak sequences",
    "kind": "def",
    "type": "wseq β"
  },
  {
    "name": "omega.term",
    "statement": "def omega.term  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Shadow syntax of normalized terms. The first element    represents the constant term and the list represents    the coefficients.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "finset.sum_pow_mul_eq_add_pow",
    "statement": "theorem finset.sum_pow_mul_eq_add_pow {α : Type u_1} {R : Type u_2} [comm_semiring R] (a b : R) (s : finset α) : s.powerset.sum (λ (t : finset α), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card",
    "theorem": "{α : Type u_1} {R : Type u_2} [comm_semiring R] (a b : R) (s : finset α) : s.powerset.sum (λ (t : finset α), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card",
    "args": "{α : Type u_1} {R : Type u_2} [comm_semiring R] (a b : R) (s : finset α)",
    "doc_string": "  Summing `a^s.card * b^(n-s.card)` over all finite subsets `s` of a `finset` gives `(a + b)^s.card`.",
    "kind": "theorem",
    "type": "s.powerset.sum (λ (t : finset α), a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card"
  },
  {
    "name": "subfield.mul_mem",
    "statement": "theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K) {x y : K}",
    "doc_string": "A subfield is closed under multiplication.",
    "kind": "theorem",
    "type": "x ∈ s → y ∈ s → x * y ∈ s"
  },
  {
    "name": "has_measurable_vadd",
    "statement": "structure has_measurable_vadd (M : Type u_1) (α : Type u_2) [has_vadd M α] [measurable_space M] [measurable_space α] : Prop",
    "theorem": "(M : Type u_1) (α : Type u_2) [has_vadd M α] [measurable_space M] [measurable_space α] : Prop",
    "args": "(M : Type u_1) (α : Type u_2) [has_vadd M α] [measurable_space M] [measurable_space α]",
    "doc_string": " We say that the action of `M` on `α` `has_measurable_vadd` if for each `c` the map `x ↦ c +ᵥ x` is a measurable function and for each `x` the map `c ↦ c +ᵥ x` is a measurable function.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_right_regular_of_mul_eq_one",
    "statement": "theorem is_right_regular_of_mul_eq_one {R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a",
    "theorem": "{R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a",
    "args": "{R : Type u_1} {a b : R} [monoid R] (h : a * b = 1)",
    "doc_string": "An element admitting a right inverse is right-regular.",
    "kind": "theorem",
    "type": "is_right_regular a"
  },
  {
    "name": "equiv.mul_left₀",
    "statement": "def equiv.mul_left₀ {G : Type u_10} [group_with_zero G] (a : G) (ha : a ≠ 0) : equiv.perm G",
    "theorem": "{G : Type u_10} [group_with_zero G] (a : G) (ha : a ≠ 0) : equiv.perm G",
    "args": "{G : Type u_10} [group_with_zero G] (a : G) (ha : a ≠ 0)",
    "doc_string": " Left multiplication by a nonzero element in a `group_with_zero` is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm G"
  },
  {
    "name": "measurable.le_map",
    "statement": "theorem measurable.le_map {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → m₂ ≤ measurable_space.map f m₁",
    "theorem": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → m₂ ≤ measurable_space.map f m₁",
    "args": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β}",
    "doc_string": "**Alias** of the forward direction of measurable_iff_le_map`.",
    "kind": "theorem",
    "type": "measurable f → m₂ ≤ measurable_space.map f m₁"
  },
  {
    "name": "measure_theory.measure.bind",
    "statement": "def measure_theory.measure.bind {α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (m : measure_theory.measure α) (f : α → measure_theory.measure β) : measure_theory.measure β",
    "theorem": "{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (m : measure_theory.measure α) (f : α → measure_theory.measure β) : measure_theory.measure β",
    "args": "{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (m : measure_theory.measure α) (f : α → measure_theory.measure β)",
    "doc_string": " Monadic bind on `measure`, only works in the category of measurable spaces and measurable functions. When the function `f` is not measurable the result is not well defined.",
    "kind": "def",
    "type": "measure_theory.measure β"
  },
  {
    "name": "fintype.prod_left",
    "statement": "def fintype.prod_left {α : Type u_1} {β : Type u_2} [decidable_eq α] [fintype (α × β)] [nonempty β] : fintype α",
    "theorem": "{α : Type u_1} {β : Type u_2} [decidable_eq α] [fintype (α × β)] [nonempty β] : fintype α",
    "args": "{α : Type u_1} {β : Type u_2} [decidable_eq α] [fintype (α × β)] [nonempty β]",
    "doc_string": "Given that `α × β` is a fintype, `α` is also a fintype.",
    "kind": "def",
    "type": "fintype α"
  },
  {
    "name": "simple_graph.connected",
    "statement": "structure simple_graph.connected {V : Type u} (G : simple_graph V) : Prop",
    "theorem": "{V : Type u} (G : simple_graph V) : Prop",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": " A graph is connected if it's preconnected and contains at least one vertex. This follows the convention observed by mathlib that something is connected iff it has exactly one connected component.  There is a `has_coe_to_fun` instance so that `h u v` can be used instead of `h.preconnected u v`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_right_regular_iff",
    "statement": "theorem is_right_regular_iff {R : Type u_1} [has_mul R] {a : R} : is_right_regular a ↔ is_smul_regular R (mul_opposite.op a)",
    "theorem": "{R : Type u_1} [has_mul R] {a : R} : is_right_regular a ↔ is_smul_regular R (mul_opposite.op a)",
    "args": "{R : Type u_1} [has_mul R] {a : R}",
    "doc_string": "Right-regular multiplication on `R` is equivalent to `Rᵐᵒᵖ`-regularity of `R` itself.",
    "kind": "theorem",
    "type": "is_right_regular a ↔ is_smul_regular R (mul_opposite.op a)"
  },
  {
    "name": "add_subgroup.of",
    "statement": "def add_subgroup.of {G : Type u_1} [add_group G] {s : set G} (h : is_add_subgroup s) : add_subgroup G",
    "theorem": "{G : Type u_1} [add_group G] {s : set G} (h : is_add_subgroup s) : add_subgroup G",
    "args": "{G : Type u_1} [add_group G] {s : set G} (h : is_add_subgroup s)",
    "doc_string": "Create a bundled additive subgroup from a set `s` and `[is_add_subgroup s]`.",
    "kind": "def",
    "type": "add_subgroup G"
  },
  {
    "name": "witt_vector",
    "statement": "structure witt_vector (p : ℕ) (R : Type u_1) : Type u_1",
    "theorem": "(p : ℕ) (R : Type u_1) : Type u_1",
    "args": "(p : ℕ) (R : Type u_1)",
    "doc_string": " `witt_vector p R` is the ring of `p`-typical Witt vectors over the commutative ring `R`, where `p` is a prime number.  If `p` is invertible in `R`, this ring is isomorphic to `ℕ → R` (the product of `ℕ` copies of `R`). If `R` is a ring of characteristic `p`, then `witt_vector p R` is a ring of characteristic `0`. The canonical example is `witt_vector p (zmod p)`, which is isomorphic to the `p`-adic integers `ℤ_[p]`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "multiset.le",
    "statement": "def multiset.le {α : Type u_1} (s t : multiset α) : Prop",
    "theorem": "{α : Type u_1} (s t : multiset α) : Prop",
    "args": "{α : Type u_1} (s t : multiset α)",
    "doc_string": "`s ≤ t` means that `s` is a sublist of `t` (up to permutation).  Equivalently, `s ≤ t` means that `count a s ≤ count a t` for all `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordinal.sup",
    "statement": "def ordinal.sup {ι : Type u} (f : ι → ordinal) : ordinal",
    "theorem": "{ι : Type u} (f : ι → ordinal) : ordinal",
    "args": "{ι : Type u} (f : ι → ordinal)",
    "doc_string": "The supremum of a family of ordinals",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "order_of_pos",
    "statement": "theorem order_of_pos {G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x",
    "theorem": "{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x",
    "args": "{G : Type u} [fintype G] [left_cancel_monoid G] (x : G)",
    "doc_string": "This is the same as `order_of_pos' but with one fewer explicit assumption since this is  automatic in case of a finite cancellative monoid.",
    "kind": "theorem",
    "type": "0 < order_of x"
  },
  {
    "name": "int.exists_least_of_bdd",
    "statement": "theorem int.exists_least_of_bdd {P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : ∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z",
    "theorem": "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : ∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z",
    "args": "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z)",
    "doc_string": " If `P : ℤ → Prop` is a predicate such that the set `{m : P m}` is bounded below and nonempty, then this set has the least element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.least_of_bdd` for a constructive counterpart.",
    "kind": "theorem",
    "type": "∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z"
  },
  {
    "name": "uniform_convergence_on.topological_space",
    "statement": "def uniform_convergence_on.topological_space (α : Type u_1) (β : Type u_2) [uniform_space β] (𝔖 : set (set α)) : topological_space (α → β)",
    "theorem": "(α : Type u_1) (β : Type u_2) [uniform_space β] (𝔖 : set (set α)) : topological_space (α → β)",
    "args": "(α : Type u_1) (β : Type u_2) [uniform_space β] (𝔖 : set (set α))",
    "doc_string": "Topology of uniform convergence on the sets of `𝔖`.",
    "kind": "def",
    "type": "topological_space (α → β)"
  },
  {
    "name": "computability.decode_pos_num",
    "statement": "def computability.decode_pos_num  : list bool → pos_num",
    "theorem": " : list bool → pos_num",
    "args": "",
    "doc_string": "A decoding function from `list bool` to the positive binary numbers.",
    "kind": "def",
    "type": "list bool → pos_num"
  },
  {
    "name": "computation.think",
    "statement": "def computation.think {α : Type u} (c : computation α) : computation α",
    "theorem": "{α : Type u} (c : computation α) : computation α",
    "args": "{α : Type u} (c : computation α)",
    "doc_string": "`think c` is the computation that delays for one \"tick\" and then performs  computation `c`.",
    "kind": "def",
    "type": "computation α"
  },
  {
    "name": "is_local_extr",
    "statement": "def is_local_extr {α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α)",
    "doc_string": "`is_local_extr_on f s a` means `is_local_min_on f s a ∨ is_local_max_on f s a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "clifford_algebra.rel",
    "statement": "inductive clifford_algebra.rel {R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) : tensor_algebra R M → tensor_algebra R M → Prop",
    "theorem": "{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M) : tensor_algebra R M → tensor_algebra R M → Prop",
    "args": "{R : Type u_1} [comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (Q : quadratic_form R M)",
    "doc_string": " `rel` relates each `ι m * ι m`, for `m : M`, with `Q m`.  The Clifford algebra of `M` is defined as the quotient modulo this relation.",
    "kind": "inductive",
    "type": "tensor_algebra R M → tensor_algebra R M → Prop"
  },
  {
    "name": "complete_lattice.is_sup_closed_compact",
    "statement": "def complete_lattice.is_sup_closed_compact (α : Type u_1) [complete_lattice α] : Prop",
    "theorem": "(α : Type u_1) [complete_lattice α] : Prop",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": " A compactness property for a complete lattice is that any `sup`-closed non-empty subset contains its `Sup`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "span_points",
    "statement": "def span_points (k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : set P",
    "theorem": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : set P",
    "args": "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P)",
    "doc_string": " The points in the affine span of a (possibly empty) set of points. Use `affine_span` instead to get an `affine_subspace k P`.",
    "kind": "def",
    "type": "set P"
  },
  {
    "name": "subgroup",
    "statement": "structure subgroup (G : Type u_3) [group G] : Type u_3",
    "theorem": "(G : Type u_3) [group G] : Type u_3",
    "args": "(G : Type u_3) [group G]",
    "doc_string": " A subgroup of a group `G` is a subset containing 1, closed under multiplication and closed under multiplicative inverse.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "finset.bdd_below",
    "statement": "theorem finset.bdd_below {α : Type u} [semilattice_inf α] [nonempty α] (s : finset α) : bdd_below ↑s",
    "theorem": "{α : Type u} [semilattice_inf α] [nonempty α] (s : finset α) : bdd_below ↑s",
    "args": "{α : Type u} [semilattice_inf α] [nonempty α] (s : finset α)",
    "doc_string": "A finset is bounded below.",
    "kind": "theorem",
    "type": "bdd_below ↑s"
  },
  {
    "name": "erased.map",
    "statement": "def erased.map {α : Sort u_1} {β : Sort u_2} (f : α → β) (a : erased α) : erased β",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (f : α → β) (a : erased α) : erased β",
    "args": "{α : Sort u_1} {β : Sort u_2} (f : α → β) (a : erased α)",
    "doc_string": "`(<$>)` operation on `erased`.  This is a separate definition because `α` and `β` can live in different universes (the universe is fixed in `functor`).",
    "kind": "def",
    "type": "erased β"
  },
  {
    "name": "is_ring_hom.map_sub",
    "statement": "theorem is_ring_hom.map_sub {α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x y : α} (hf : is_ring_hom f) : f (x - y) = f x - f y",
    "theorem": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x y : α} (hf : is_ring_hom f) : f (x - y) = f x - f y",
    "args": "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x y : α} (hf : is_ring_hom f)",
    "doc_string": "Ring homomorphisms preserve subtraction.",
    "kind": "theorem",
    "type": "f (x - y) = f x - f y"
  },
  {
    "name": "continuous_monoid_hom.inv",
    "statement": "def continuous_monoid_hom.inv (E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom E E",
    "theorem": "(E : Type u_8) [comm_group E] [topological_space E] [topological_group E] : continuous_monoid_hom E E",
    "args": "(E : Type u_8) [comm_group E] [topological_space E] [topological_group E]",
    "doc_string": "The continuous homomorphism given by inversion.",
    "kind": "def",
    "type": "continuous_monoid_hom E E"
  },
  {
    "name": "category_theory.limits.wide_pullback_shape.hom",
    "statement": "inductive category_theory.limits.wide_pullback_shape.hom {J : Type v} : category_theory.limits.wide_pullback_shape J → category_theory.limits.wide_pullback_shape J → Type v",
    "theorem": "{J : Type v} : category_theory.limits.wide_pullback_shape J → category_theory.limits.wide_pullback_shape J → Type v",
    "args": "{J : Type v}",
    "doc_string": "The type of arrows for the shape indexing a wide pullback.",
    "kind": "inductive",
    "type": "category_theory.limits.wide_pullback_shape J → category_theory.limits.wide_pullback_shape J → Type v"
  },
  {
    "name": "topological_space.dense_seq",
    "statement": "def topological_space.dense_seq (α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ℕ → α",
    "theorem": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ℕ → α",
    "args": "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α]",
    "doc_string": " A dense sequence in a non-empty separable topological space.  If `α` might be empty, then `exists_countable_dense` is the main way to use separability of `α`.",
    "kind": "def",
    "type": "ℕ → α"
  },
  {
    "name": "option.to_list",
    "statement": "def option.to_list {α : Type u_1} : option α → list α",
    "theorem": "{α : Type u_1} : option α → list α",
    "args": "{α : Type u_1}",
    "doc_string": " Cast of `option` to `list `. Returns `[a]` if the input is `some a`, and `[]` if it is `none`.",
    "kind": "def",
    "type": "option α → list α"
  },
  {
    "name": "seq.unzip",
    "statement": "def seq.unzip {α : Type u} {β : Type v} (s : seq (α × β)) : seq α × seq β",
    "theorem": "{α : Type u} {β : Type v} (s : seq (α × β)) : seq α × seq β",
    "args": "{α : Type u} {β : Type v} (s : seq (α × β))",
    "doc_string": "Separate a sequence of pairs into two sequences",
    "kind": "def",
    "type": "seq α × seq β"
  },
  {
    "name": "no_zero_divisors.to_cancel_comm_monoid_with_zero",
    "statement": "def no_zero_divisors.to_cancel_comm_monoid_with_zero {α : Type u} [comm_ring α] [no_zero_divisors α] : cancel_comm_monoid_with_zero α",
    "theorem": "{α : Type u} [comm_ring α] [no_zero_divisors α] : cancel_comm_monoid_with_zero α",
    "args": "{α : Type u} [comm_ring α] [no_zero_divisors α]",
    "doc_string": " A commutative ring with no zero divisors is a `cancel_comm_monoid_with_zero`.  Note this is not an instance as it forms a typeclass loop.",
    "kind": "def",
    "type": "cancel_comm_monoid_with_zero α"
  },
  {
    "name": "Semigroup.of",
    "statement": "def Semigroup.of (M : Type u) [semigroup M] : Semigroup",
    "theorem": "(M : Type u) [semigroup M] : Semigroup",
    "args": "(M : Type u) [semigroup M]",
    "doc_string": "Construct a bundled `Semigroup` from the underlying type and typeclass.",
    "kind": "def",
    "type": "Semigroup"
  },
  {
    "name": "left.one_lt_mul'",
    "statement": "theorem left.one_lt_mul' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul'`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "fintype.exists_ne_map_eq_of_infinite",
    "statement": "theorem fintype.exists_ne_map_eq_of_infinite {α : Type u_1} {β : Type u_2} [infinite α] [fintype β] (f : α → β) : ∃ (x y : α), x ≠ y ∧ f x = f y",
    "theorem": "{α : Type u_1} {β : Type u_2} [infinite α] [fintype β] (f : α → β) : ∃ (x y : α), x ≠ y ∧ f x = f y",
    "args": "{α : Type u_1} {β : Type u_2} [infinite α] [fintype β] (f : α → β)",
    "doc_string": "The pigeonhole principle for infinitely many pigeons in finitely many pigeonholes. If there are infinitely many pigeons in finitely many pigeonholes, then there are at least two pigeons in the same pigeonhole.  See also: `fintype.exists_ne_map_eq_of_card_lt`, `fintype.exists_infinite_fiber`.",
    "kind": "theorem",
    "type": "∃ (x y : α), x ≠ y ∧ f x = f y"
  },
  {
    "name": "small",
    "statement": "structure small (α : Type v) : Prop",
    "theorem": "(α : Type v) : Prop",
    "args": "(α : Type v)",
    "doc_string": "A type is `small.{w}` if there exists an equivalence to some `S : Type w`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "subsemiring.list_prod_mem",
    "statement": "theorem subsemiring.list_prod_mem {R : Type u_1} [semiring R] (s : subsemiring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s",
    "theorem": "{R : Type u_1} [semiring R] (s : subsemiring R) {l : list R} : (∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s",
    "args": "{R : Type u_1} [semiring R] (s : subsemiring R) {l : list R}",
    "doc_string": "Product of a list of elements in a `subsemiring` is in the `subsemiring`.",
    "kind": "theorem",
    "type": "(∀ (x : R), x ∈ l → x ∈ s) → l.prod ∈ s"
  },
  {
    "name": "witt_vector.witt_zsmul",
    "statement": "def witt_vector.witt_zsmul (p : ℕ) [hp : fact (nat.prime p)] (n : ℤ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℤ) : ℕ → mv_polynomial (fin 1 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℤ)",
    "doc_string": "The polynomials used for defining repeated addition of the ring of Witt vectors.",
    "kind": "def",
    "type": "ℕ → mv_polynomial (fin 1 × ℕ) ℤ"
  },
  {
    "name": "alg_hom",
    "statement": "structure alg_hom (R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)",
    "theorem": "(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B] : Type (max v w)",
    "args": "(R : Type u) (A : Type v) (B : Type w) [comm_semiring R] [semiring A] [semiring B] [algebra R A] [algebra R B]",
    "doc_string": "Defining the homomorphism in the category R-Alg.",
    "kind": "structure",
    "type": "Type (max v w)"
  },
  {
    "name": "set_like.graded_monoid",
    "statement": "structure set_like.graded_monoid {ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [monoid R] [add_monoid ι] (A : ι → S) : Prop",
    "theorem": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [monoid R] [add_monoid ι] (A : ι → S) : Prop",
    "args": "{ι : Type u_1} {R : Type u_2} {S : Type u_3} [set_like S R] [monoid R] [add_monoid ι] (A : ι → S)",
    "doc_string": "A version of `graded_monoid.gmonoid` for internally graded objects.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "inner_product_space.core",
    "statement": "structure inner_product_space.core (𝕜 : Type u_4) (F : Type u_5) [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] : Type (max u_4 u_5)",
    "theorem": "(𝕜 : Type u_4) (F : Type u_5) [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F] : Type (max u_4 u_5)",
    "args": "(𝕜 : Type u_4) (F : Type u_5) [is_R_or_C 𝕜] [add_comm_group F] [module 𝕜 F]",
    "doc_string": " A structure requiring that a scalar product is positive definite and symmetric, from which one can construct an `inner_product_space` instance in `inner_product_space.of_core`.",
    "kind": "structure",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "finsupp.coe_fn_injective",
    "statement": "theorem finsupp.coe_fn_injective {α : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn",
    "theorem": "{α : Type u_1} {M : Type u_5} [has_zero M] : function.injective coe_fn",
    "args": "{α : Type u_1} {M : Type u_5} [has_zero M]",
    "doc_string": "Deprecated. Use `fun_like.coe_injective` instead.",
    "kind": "theorem",
    "type": "function.injective coe_fn"
  },
  {
    "name": "chain_complex",
    "statement": "def chain_complex (V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : Type (max u u_1 v)",
    "theorem": "(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : Type (max u u_1 v)",
    "args": "(V : Type u) [category_theory.category V] [category_theory.limits.has_zero_morphisms V] (α : Type u_1) [add_right_cancel_semigroup α] [has_one α]",
    "doc_string": "An `α`-indexed chain complex is a `homological_complex` in which `d i j ≠ 0` only if `j + 1 = i`.",
    "kind": "def",
    "type": "Type (max u u_1 v)"
  },
  {
    "name": "cardinal.to_nat",
    "statement": "def cardinal.to_nat  : zero_hom cardinal ℕ",
    "theorem": " : zero_hom cardinal ℕ",
    "args": "",
    "doc_string": "This function sends finite cardinals to the corresponding natural, and infinite cardinals  to 0.",
    "kind": "def",
    "type": "zero_hom cardinal ℕ"
  },
  {
    "name": "turing.to_partrec.cont.then",
    "statement": "def turing.to_partrec.cont.then  : turing.to_partrec.cont → turing.to_partrec.cont → turing.to_partrec.cont",
    "theorem": " : turing.to_partrec.cont → turing.to_partrec.cont → turing.to_partrec.cont",
    "args": "",
    "doc_string": " In order to extract a compositional semantics from the sequential execution behavior of configurations, we observe that continuations have a monoid structure, with `cont.halt` as the unit and `cont.then` as the multiplication. `cont.then k₁ k₂` runs `k₁` until it halts, and then takes the result of `k₁` and passes it to `k₂`.  We will not prove it is associative (although it is), but we are instead interested in the associativity law `k₂ (eval c k₁) = eval c (k₁.then k₂)`. This holds at both the sequential and compositional levels, and allows us to express running a machine without the ambient continuation and relate it to the original machine's evaluation steps. In the literature this is usually where one uses Turing machines embedded inside other Turing machines, but this approach allows us to avoid changing the ambient type `cfg` in the middle of the recursion.",
    "kind": "def",
    "type": "turing.to_partrec.cont → turing.to_partrec.cont → turing.to_partrec.cont"
  },
  {
    "name": "finpartition",
    "statement": "structure finpartition {α : Type u_1} [lattice α] [order_bot α] (a : α) : Type u_1",
    "theorem": "{α : Type u_1} [lattice α] [order_bot α] (a : α) : Type u_1",
    "args": "{α : Type u_1} [lattice α] [order_bot α] (a : α)",
    "doc_string": " A finite partition of `a : α` is a pairwise disjoint finite set of elements whose supremum is `a`. We forbid `⊥` as a part.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "invertible_one",
    "statement": "def invertible_one {α : Type u} [monoid α] : invertible 1",
    "theorem": "{α : Type u} [monoid α] : invertible 1",
    "args": "{α : Type u} [monoid α]",
    "doc_string": "`1` is the inverse of itself",
    "kind": "def",
    "type": "invertible 1"
  },
  {
    "name": "EllipticCurve.disc_aux",
    "statement": "def EllipticCurve.disc_aux {R : Type u_1} [comm_ring R] (a1 a2 a3 a4 a6 : R) : R",
    "theorem": "{R : Type u_1} [comm_ring R] (a1 a2 a3 a4 a6 : R) : R",
    "args": "{R : Type u_1} [comm_ring R] (a1 a2 a3 a4 a6 : R)",
    "doc_string": " The discriminant of the plane cubic `Y^2+a1*X*Y+a3*Y=X^3+a2*X^2+a4*X+a6`. If `R` is a field then this polynomial vanishes iff the cubic curve cut out by this equation is singular.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "array.map",
    "statement": "def array.map {n : ℕ} {α : Type u} {β : Type v} (a : array n α) (f : α → β) : array n β",
    "theorem": "{n : ℕ} {α : Type u} {β : Type v} (a : array n α) (f : α → β) : array n β",
    "args": "{n : ℕ} {α : Type u} {β : Type v} (a : array n α) (f : α → β)",
    "doc_string": "Map a function over the array.",
    "kind": "def",
    "type": "array n β"
  },
  {
    "name": "sum3.in₁",
    "statement": "def sum3.in₁ {α : Type u} {β : Type v} {γ : Type u_1} (b : β) : α ⊕ β ⊕ γ",
    "theorem": "{α : Type u} {β : Type v} {γ : Type u_1} (b : β) : α ⊕ β ⊕ γ",
    "args": "{α : Type u} {β : Type v} {γ : Type u_1} (b : β)",
    "doc_string": "The map from the second summand into a ternary sum.",
    "kind": "def",
    "type": "α ⊕ β ⊕ γ"
  },
  {
    "name": "semigroup",
    "statement": "structure semigroup (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": "A semigroup is a type with an associative `(*)`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "fractional_ideal.coe_to_fractional_ideal",
    "statement": "def fractional_ideal.coe_to_fractional_ideal {R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe_t (ideal R) (fractional_ideal S P)",
    "theorem": "{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P] : has_coe_t (ideal R) (fractional_ideal S P)",
    "args": "{R : Type u_1} [comm_ring R] {S : submonoid R} {P : Type u_2} [comm_ring P] [algebra R P]",
    "doc_string": " Map an ideal `I` to a fractional ideal by forgetting `I` is integral.  This is a bundled version of `is_localization.coe_submodule : ideal R → submodule R P`, which is not to be confused with the `coe : fractional_ideal S P → submodule R P`, also called `coe_to_submodule` in theorem names.  This map is available as a ring hom, called `fractional_ideal.coe_ideal_hom`.",
    "kind": "def",
    "type": "has_coe_t (ideal R) (fractional_ideal S P)"
  },
  {
    "name": "simplex_category",
    "statement": "def simplex_category  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The simplex category: * objects are natural numbers `n : ℕ` * morphisms from `n` to `m` are monotone functions `fin (n+1) → fin (m+1)`",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "fin.strict_mono_unique",
    "statement": "theorem fin.strict_mono_unique {n : ℕ} {α : Type u_1} [preorder α] {f g : fin n → α} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g",
    "theorem": "{n : ℕ} {α : Type u_1} [preorder α] {f g : fin n → α} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g) : f = g",
    "args": "{n : ℕ} {α : Type u_1} [preorder α] {f g : fin n → α} (hf : strict_mono f) (hg : strict_mono g) (h : set.range f = set.range g)",
    "doc_string": " Two strictly monotone functions from `fin n` are equal provided that their ranges are equal.",
    "kind": "theorem",
    "type": "f = g"
  },
  {
    "name": "is_square_of_char_two'",
    "statement": "theorem is_square_of_char_two' {R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a",
    "theorem": "{R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R) : is_square a",
    "args": "{R : Type u_1} [fintype R] [comm_ring R] [is_reduced R] [char_p R 2] (a : R)",
    "doc_string": " If `ring_char R = 2`, where `R` is a finite reduced commutative ring, then every `a : R` is a square.",
    "kind": "theorem",
    "type": "is_square a"
  },
  {
    "name": "category_theory.limits.split_epi_prod_fst",
    "statement": "def category_theory.limits.split_epi_prod_fst {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.fst",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)] : category_theory.split_epi category_theory.limits.prod.fst",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {X Y : C} [category_theory.limits.has_limit (category_theory.limits.pair X Y)]",
    "doc_string": "In the presence of zero morphisms, projections into a product are (split) epimorphisms.",
    "kind": "def",
    "type": "category_theory.split_epi category_theory.limits.prod.fst"
  },
  {
    "name": "boolean_algebra",
    "statement": "structure boolean_algebra (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A Boolean algebra is a bounded distributive lattice with a complement operator `ᶜ` such that `x ⊓ xᶜ = ⊥` and `x ⊔ xᶜ = ⊤`. For convenience, it must also provide a set difference operation `\\` satisfying `x \\ y = x ⊓ yᶜ`.  This is a generalization of (classical) logic of propositions, or the powerset lattice.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "alist.to_finmap",
    "statement": "def alist.to_finmap {α : Type u} {β : α → Type v} (s : alist β) : finmap β",
    "theorem": "{α : Type u} {β : α → Type v} (s : alist β) : finmap β",
    "args": "{α : Type u} {β : α → Type v} (s : alist β)",
    "doc_string": "The quotient map from `alist` to `finmap`.",
    "kind": "def",
    "type": "finmap β"
  },
  {
    "name": "quiver.path",
    "statement": "inductive quiver.path {V : Type u} [quiver V] (a : V) : V → Sort (max (u+1) v)",
    "theorem": "{V : Type u} [quiver V] (a : V) : V → Sort (max (u+1) v)",
    "args": "{V : Type u} [quiver V] (a : V)",
    "doc_string": "`G.path a b` is the type of paths from `a` to `b` through the arrows of `G`.",
    "kind": "inductive",
    "type": "V → Sort (max (u+1) v)"
  },
  {
    "name": "measure_theory.measure.has_sub",
    "statement": "def measure_theory.measure.has_sub {α : Type u_1} [measurable_space α] : has_sub (measure_theory.measure α)",
    "theorem": "{α : Type u_1} [measurable_space α] : has_sub (measure_theory.measure α)",
    "args": "{α : Type u_1} [measurable_space α]",
    "doc_string": " The measure `μ - ν` is defined to be the least measure `τ` such that `μ ≤ τ + ν`. It is the equivalent of `(μ - ν) ⊔ 0` if `μ` and `ν` were signed measures. Compare with `ennreal.has_sub`. Specifically, note that if you have `α = {1,2}`, and  `μ {1} = 2`, `μ {2} = 0`, and `ν {2} = 2`, `ν {1} = 0`, then `(μ - ν) {1, 2} = 2`. However, if `μ ≤ ν`, and `ν univ ≠ ∞`, then `(μ - ν) + ν = μ`.",
    "kind": "def",
    "type": "has_sub (measure_theory.measure α)"
  },
  {
    "name": "pSet.omega",
    "statement": "def pSet.omega  : pSet",
    "theorem": " : pSet",
    "args": "",
    "doc_string": "The von Neumann ordinal ω",
    "kind": "def",
    "type": "pSet"
  },
  {
    "name": "category_theory.limits.binary_bicone.of_colimit_cocone",
    "statement": "def category_theory.limits.binary_bicone.of_colimit_cocone {C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cocone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.binary_bicone X Y",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cocone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_colimit t) : category_theory.limits.binary_bicone X Y",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {X Y : C} {t : category_theory.limits.cocone (category_theory.limits.pair X Y)} (ht : category_theory.limits.is_colimit t)",
    "doc_string": "We can turn any colimit cocone over a pair into a bicone.",
    "kind": "def",
    "type": "category_theory.limits.binary_bicone X Y"
  },
  {
    "name": "filter.mul_one_class",
    "statement": "def filter.mul_one_class {α : Type u_2} [mul_one_class α] : mul_one_class (filter α)",
    "theorem": "{α : Type u_2} [mul_one_class α] : mul_one_class (filter α)",
    "args": "{α : Type u_2} [mul_one_class α]",
    "doc_string": "`filter α` is a `mul_one_class` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "mul_one_class (filter α)"
  },
  {
    "name": "matrix.is_skew_adjoint",
    "statement": "def matrix.is_skew_adjoint {R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J A : matrix n n R₃) : Prop",
    "theorem": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J A : matrix n n R₃) : Prop",
    "args": "{R₃ : Type u_7} [comm_ring R₃] {n : Type u_11} [fintype n] (J A : matrix n n R₃)",
    "doc_string": " The condition for a square matrix `A` to be skew-adjoint with respect to the square matrix `J`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordinal.nadd",
    "statement": "def ordinal.nadd  : ordinal → ordinal → ordinal",
    "theorem": " : ordinal → ordinal → ordinal",
    "args": "",
    "doc_string": " Natural addition on ordinals `a ♯ b`, also known as the Hessenberg sum, is recursively defined as the least ordinal greater than `a' ♯ b` and `a ♯ b'` for all `a' < a` and `b' < b`. In contrast to normal ordinal addition, it is commutative.  Natural addition can equivalently be characterized as the ordinal resulting from adding up corresponding coefficients in the Cantor normal forms of `a` and `b`.",
    "kind": "def",
    "type": "ordinal → ordinal → ordinal"
  },
  {
    "name": "order.pfilter.set.has_coe",
    "statement": "def order.pfilter.set.has_coe {P : Type u_1} [preorder P] : has_coe (order.pfilter P) (set P)",
    "theorem": "{P : Type u_1} [preorder P] : has_coe (order.pfilter P) (set P)",
    "args": "{P : Type u_1} [preorder P]",
    "doc_string": "A filter on `P` is a subset of `P`.",
    "kind": "def",
    "type": "has_coe (order.pfilter P) (set P)"
  },
  {
    "name": "add_con.complete_lattice",
    "statement": "def add_con.complete_lattice {M : Type u_1} [has_add M] : complete_lattice (add_con M)",
    "theorem": "{M : Type u_1} [has_add M] : complete_lattice (add_con M)",
    "args": "{M : Type u_1} [has_add M]",
    "doc_string": "The complete lattice of additive congruence relations on a given type with an addition.",
    "kind": "def",
    "type": "complete_lattice (add_con M)"
  },
  {
    "name": "first_order.language.Structure.fg",
    "statement": "structure first_order.language.Structure.fg (L : first_order.language) (M : Type u_3) [L.Structure M] : Prop",
    "theorem": "(L : first_order.language) (M : Type u_3) [L.Structure M] : Prop",
    "args": "(L : first_order.language) (M : Type u_3) [L.Structure M]",
    "doc_string": "A structure is finitely generated if it is the closure of a finite subset.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_closed_fixed_points",
    "statement": "theorem is_closed_fixed_points {α : Type u_1} [topological_space α] [t2_space α] {f : α → α} (hf : continuous f) : is_closed (function.fixed_points f)",
    "theorem": "{α : Type u_1} [topological_space α] [t2_space α] {f : α → α} (hf : continuous f) : is_closed (function.fixed_points f)",
    "args": "{α : Type u_1} [topological_space α] [t2_space α] {f : α → α} (hf : continuous f)",
    "doc_string": "The set of fixed points of a continuous map is a closed set.",
    "kind": "theorem",
    "type": "is_closed (function.fixed_points f)"
  },
  {
    "name": "tree.get_or_else",
    "statement": "def tree.get_or_else {α : Type u} (n : pos_num) (t : tree α) (v : α) : α",
    "theorem": "{α : Type u} (n : pos_num) (t : tree α) (v : α) : α",
    "args": "{α : Type u} (n : pos_num) (t : tree α) (v : α)",
    "doc_string": " Retrieves an element from the tree, or the provided default value if the index is invalid. See `tree.get`.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "add_submonoid.has_top",
    "statement": "def add_submonoid.has_top {M : Type u_1} [add_zero_class M] : has_top (add_submonoid M)",
    "theorem": "{M : Type u_1} [add_zero_class M] : has_top (add_submonoid M)",
    "args": "{M : Type u_1} [add_zero_class M]",
    "doc_string": "The additive submonoid `M` of the `add_monoid M`.",
    "kind": "def",
    "type": "has_top (add_submonoid M)"
  },
  {
    "name": "bool.of_nat",
    "statement": "def bool.of_nat (n : ℕ) : bool",
    "theorem": "(n : ℕ) : bool",
    "args": "(n : ℕ)",
    "doc_string": "convert a `ℕ` to a `bool`, `0 -> false`, everything else -> `true`",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "denumerable.of_encodable_of_infinite",
    "statement": "def denumerable.of_encodable_of_infinite (α : Type u_1) [encodable α] [infinite α] : denumerable α",
    "theorem": "(α : Type u_1) [encodable α] [infinite α] : denumerable α",
    "args": "(α : Type u_1) [encodable α] [infinite α]",
    "doc_string": "An infinite encodable type is denumerable.",
    "kind": "def",
    "type": "denumerable α"
  },
  {
    "name": "pgame.impartial_aux",
    "statement": "def pgame.impartial_aux  : pgame → Prop",
    "theorem": " : pgame → Prop",
    "args": "",
    "doc_string": "The definition for a impartial game, defined using Conway induction",
    "kind": "def",
    "type": "pgame → Prop"
  },
  {
    "name": "distrib_mul_action_hom",
    "statement": "structure distrib_mul_action_hom (M : Type u_5) [monoid M] (A : Type u_6) [add_monoid A] [distrib_mul_action M A] (B : Type u_8) [add_monoid B] [distrib_mul_action M B] : Type (max u_6 u_8)",
    "theorem": "(M : Type u_5) [monoid M] (A : Type u_6) [add_monoid A] [distrib_mul_action M A] (B : Type u_8) [add_monoid B] [distrib_mul_action M B] : Type (max u_6 u_8)",
    "args": "(M : Type u_5) [monoid M] (A : Type u_6) [add_monoid A] [distrib_mul_action M A] (B : Type u_8) [add_monoid B] [distrib_mul_action M B]",
    "doc_string": "Equivariant additive monoid homomorphisms.",
    "kind": "structure",
    "type": "Type (max u_6 u_8)"
  },
  {
    "name": "wseq",
    "statement": "def wseq (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "Weak sequences.   While the `seq` structure allows for lists which may not be finite,  a weak sequence also allows the computation of each element to  involve an indeterminate amount of computation, including possibly  an infinite loop. This is represented as a regular `seq` interspersed  with `none` elements to indicate that computation is ongoing.   This model is appropriate for Haskell style lazy lists, and is closed  under most interesting computation patterns on infinite lists,  but conversely it is difficult to extract elements from it.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "cardinal.aleph_idx.initial_seg",
    "statement": "def cardinal.aleph_idx.initial_seg  : initial_seg has_lt.lt has_lt.lt",
    "theorem": " : initial_seg has_lt.lt has_lt.lt",
    "args": "",
    "doc_string": "The `aleph'` index function, which gives the ordinal index of a cardinal.  (The `aleph'` part is because unlike `aleph` this counts also the  finite stages. So `aleph_idx n = n`, `aleph_idx ω = ω`,  `aleph_idx ℵ₁ = ω + 1` and so on.)  In this definition, we register additionally that this function is an initial segment,  i.e., it is order preserving and its range is an initial segment of the ordinals.  For the basic function version, see `aleph_idx`.  For an upgraded version stating that the range is everything, see `aleph_idx.rel_iso`.",
    "kind": "def",
    "type": "initial_seg has_lt.lt has_lt.lt"
  },
  {
    "name": "pos_num.of_znum'",
    "statement": "def pos_num.of_znum'  : znum → option pos_num",
    "theorem": " : znum → option pos_num",
    "args": "",
    "doc_string": "Converts a `znum` to `option pos_num`, where it is `some` if the `znum` was positive and `none` otherwise.",
    "kind": "def",
    "type": "znum → option pos_num"
  },
  {
    "name": "sSet.horn",
    "statement": "def sSet.horn (n : ℕ) (i : fin (n + 1)) : sSet",
    "theorem": "(n : ℕ) (i : fin (n + 1)) : sSet",
    "args": "(n : ℕ) (i : fin (n + 1))",
    "doc_string": " `horn n i` (or `Λ[n, i]`) is the `i`-th horn of the `n`-th standard simplex, where `i : n`. It consists of all `m`-simplices `α` of `Δ[n]` for which the union of `{i}` and the range of `α` is not all of `n` (when viewing `α` as monotone function `m → n`).",
    "kind": "def",
    "type": "sSet"
  },
  {
    "name": "real.tendsto_sum_range_one_div_nat_succ_at_top",
    "statement": "theorem real.tendsto_sum_range_one_div_nat_succ_at_top  : filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), 1 / (↑i + 1))) filter.at_top filter.at_top",
    "theorem": " : filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), 1 / (↑i + 1))) filter.at_top filter.at_top",
    "args": "",
    "doc_string": "**Divergence of the Harmonic Series**",
    "kind": "theorem",
    "type": "filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), 1 / (↑i + 1))) filter.at_top filter.at_top"
  },
  {
    "name": "besicovitch.ball_package",
    "statement": "structure besicovitch.ball_package (β : Type u_1) (α : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(β : Type u_1) (α : Type u_2) : Type (max u_1 u_2)",
    "args": "(β : Type u_1) (α : Type u_2)",
    "doc_string": "A ball package is a family of balls in a metric space with positive bounded radii.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "matrix.is_diag",
    "statement": "def matrix.is_diag {α : Type u_1} {n : Type u_4} [has_zero α] (A : matrix n n α) : Prop",
    "theorem": "{α : Type u_1} {n : Type u_4} [has_zero α] (A : matrix n n α) : Prop",
    "args": "{α : Type u_1} {n : Type u_4} [has_zero α] (A : matrix n n α)",
    "doc_string": "`A.is_diag` means square matrix `A` is a diagonal matrix.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "polynomial.degree",
    "statement": "def polynomial.degree {R : Type u} [semiring R] (p : polynomial R) : with_bot ℕ",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : with_bot ℕ",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": " `degree p` is the degree of the polynomial `p`, i.e. the largest `X`-exponent in `p`. `degree p = some n` when `p ≠ 0` and `n` is the highest power of `X` that appears in `p`, otherwise `degree 0 = ⊥`.",
    "kind": "def",
    "type": "with_bot ℕ"
  },
  {
    "name": "lazy_list.zip",
    "statement": "def lazy_list.zip {α : Type u} {β : Type v} : lazy_list α → lazy_list β → lazy_list (α × β)",
    "theorem": "{α : Type u} {β : Type v} : lazy_list α → lazy_list β → lazy_list (α × β)",
    "args": "{α : Type u} {β : Type v}",
    "doc_string": "Zips two lazy lists.",
    "kind": "def",
    "type": "lazy_list α → lazy_list β → lazy_list (α × β)"
  },
  {
    "name": "bitvec.shl",
    "statement": "def bitvec.shl {n : ℕ} (x : bitvec n) (i : ℕ) : bitvec n",
    "theorem": "{n : ℕ} (x : bitvec n) (i : ℕ) : bitvec n",
    "args": "{n : ℕ} (x : bitvec n) (i : ℕ)",
    "doc_string": " `shl x i` is the bitvector obtained by left-shifting `x` `i` times and padding with `ff`. If `x.length < i` then this will return the all-`ff`s bitvector.",
    "kind": "def",
    "type": "bitvec n"
  },
  {
    "name": "denumerable.of_nat",
    "statement": "def denumerable.of_nat (α : Type u_1) [f : denumerable α] (n : ℕ) : α",
    "theorem": "(α : Type u_1) [f : denumerable α] (n : ℕ) : α",
    "args": "(α : Type u_1) [f : denumerable α] (n : ℕ)",
    "doc_string": "Returns the `n`-th element of `α` indexed by the decoding.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "subsemiring.ext",
    "statement": "theorem subsemiring.ext {R : Type u} [non_assoc_semiring R] {S T : subsemiring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T",
    "theorem": "{R : Type u} [non_assoc_semiring R] {S T : subsemiring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T",
    "args": "{R : Type u} [non_assoc_semiring R] {S T : subsemiring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T)",
    "doc_string": "Two subsemirings are equal if they have the same elements.",
    "kind": "theorem",
    "type": "S = T"
  },
  {
    "name": "finmap.keys",
    "statement": "def finmap.keys {α : Type u} {β : α → Type v} (s : finmap β) : finset α",
    "theorem": "{α : Type u} {β : α → Type v} (s : finmap β) : finset α",
    "args": "{α : Type u} {β : α → Type v} (s : finmap β)",
    "doc_string": "The set of keys of a finite map.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "subalgebra.to_submodule",
    "statement": "def subalgebra.to_submodule {R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submodule R A",
    "theorem": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : submodule R A",
    "args": "{R : Type u} {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A)",
    "doc_string": "Convert a `subalgebra` to `submodule`",
    "kind": "def",
    "type": "submodule R A"
  },
  {
    "name": "polynomial.has_separable_contraction.contraction",
    "statement": "def polynomial.has_separable_contraction.contraction {F : Type} [comm_semiring F] {q : ℕ} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : polynomial F",
    "theorem": "{F : Type} [comm_semiring F] {q : ℕ} {f : polynomial F} (hf : polynomial.has_separable_contraction q f) : polynomial F",
    "args": "{F : Type} [comm_semiring F] {q : ℕ} {f : polynomial F} (hf : polynomial.has_separable_contraction q f)",
    "doc_string": "A choice of a separable contraction.",
    "kind": "def",
    "type": "polynomial F"
  },
  {
    "name": "alist.lookup",
    "statement": "def alist.lookup {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : alist β) : option (β a)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : alist β) : option (β a)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (s : alist β)",
    "doc_string": "Look up the value associated to a key in an association list.",
    "kind": "def",
    "type": "option (β a)"
  },
  {
    "name": "cycle.mem",
    "statement": "def cycle.mem {α : Type u_1} (a : α) (s : cycle α) : Prop",
    "theorem": "{α : Type u_1} (a : α) (s : cycle α) : Prop",
    "args": "{α : Type u_1} (a : α) (s : cycle α)",
    "doc_string": "For `x : α`, `s : cycle α`, `x ∈ s` indicates that `x` occurs at least once in `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "slim_check.gen",
    "statement": "def slim_check.gen (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " Monad to generate random examples to test properties with. It has a `nat` parameter so that the caller can decide on the size of the examples.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "with_seminorms",
    "statement": "structure with_seminorms {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] [nonempty ι] (p : seminorm_family 𝕜 E ι) [t : topological_space E] : Prop",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] [nonempty ι] (p : seminorm_family 𝕜 E ι) [t : topological_space E] : Prop",
    "args": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_5} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] [nonempty ι] (p : seminorm_family 𝕜 E ι) [t : topological_space E]",
    "doc_string": "The proposition that the topology of `E` is induced by a family of seminorms `p`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "topological_fiber_bundle_core.is_topological_fiber_bundle",
    "statement": "theorem topological_fiber_bundle_core.is_topological_fiber_bundle {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_topological_fiber_bundle F Z.proj",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_topological_fiber_bundle F Z.proj",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F)",
    "doc_string": "A topological fiber bundle constructed from core is indeed a topological fiber bundle.",
    "kind": "theorem",
    "type": "is_topological_fiber_bundle F Z.proj"
  },
  {
    "name": "polynomial.chebyshev.U",
    "statement": "def polynomial.chebyshev.U (R : Type u_1) [comm_ring R] : ℕ → polynomial R",
    "theorem": "(R : Type u_1) [comm_ring R] : ℕ → polynomial R",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": "`U n` is the `n`-th Chebyshev polynomial of the second kind",
    "kind": "def",
    "type": "ℕ → polynomial R"
  },
  {
    "name": "finpartition.bind",
    "statement": "def finpartition.bind {α : Type u_1} [distrib_lattice α] [order_bot α] [decidable_eq α] {a : α} (P : finpartition a) (Q : Π (i : α), i ∈ P.parts → finpartition i) : finpartition a",
    "theorem": "{α : Type u_1} [distrib_lattice α] [order_bot α] [decidable_eq α] {a : α} (P : finpartition a) (Q : Π (i : α), i ∈ P.parts → finpartition i) : finpartition a",
    "args": "{α : Type u_1} [distrib_lattice α] [order_bot α] [decidable_eq α] {a : α} (P : finpartition a) (Q : Π (i : α), i ∈ P.parts → finpartition i)",
    "doc_string": " Given a finpartition `P` of `a` and finpartitions of each part of `P`, this yields the finpartition of `a` obtained by juxtaposing all the subpartitions.",
    "kind": "def",
    "type": "finpartition a"
  },
  {
    "name": "nat.arithmetic_function.ppow",
    "statement": "def nat.arithmetic_function.ppow {R : Type u_1} [semiring R] (f : nat.arithmetic_function R) (k : ℕ) : nat.arithmetic_function R",
    "theorem": "{R : Type u_1} [semiring R] (f : nat.arithmetic_function R) (k : ℕ) : nat.arithmetic_function R",
    "args": "{R : Type u_1} [semiring R] (f : nat.arithmetic_function R) (k : ℕ)",
    "doc_string": "This is the pointwise power of `arithmetic_function`s.",
    "kind": "def",
    "type": "nat.arithmetic_function R"
  },
  {
    "name": "category_theory.thin_skeleton",
    "statement": "def category_theory.thin_skeleton (C : Type u₁) [category_theory.category C] : Type u₁",
    "theorem": "(C : Type u₁) [category_theory.category C] : Type u₁",
    "args": "(C : Type u₁) [category_theory.category C]",
    "doc_string": "Construct the skeleton category by taking the quotient of objects. This construction gives a preorder with nice definitional properties, but is only really appropriate for thin categories. If your original category is not thin, you probably want to be using `skeleton` instead of this.",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "subsemiring.center",
    "statement": "def subsemiring.center (R : Type u_1) [semiring R] : subsemiring R",
    "theorem": "(R : Type u_1) [semiring R] : subsemiring R",
    "args": "(R : Type u_1) [semiring R]",
    "doc_string": "The center of a semiring `R` is the set of elements that commute with everything in `R`",
    "kind": "def",
    "type": "subsemiring R"
  },
  {
    "name": "discrete_quotient.comap",
    "statement": "def discrete_quotient.comap {X : Type u_1} [topological_space X] (S : discrete_quotient X) {Y : Type u_2} [topological_space Y] {f : Y → X} (cont : continuous f) : discrete_quotient Y",
    "theorem": "{X : Type u_1} [topological_space X] (S : discrete_quotient X) {Y : Type u_2} [topological_space Y] {f : Y → X} (cont : continuous f) : discrete_quotient Y",
    "args": "{X : Type u_1} [topological_space X] (S : discrete_quotient X) {Y : Type u_2} [topological_space Y] {f : Y → X} (cont : continuous f)",
    "doc_string": "Comap a discrete quotient along a continuous map.",
    "kind": "def",
    "type": "discrete_quotient Y"
  },
  {
    "name": "charted_space.locally_compact",
    "statement": "theorem charted_space.locally_compact (H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M",
    "theorem": "(H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H] : locally_compact_space M",
    "args": "(H : Type u) (M : Type u_2) [topological_space H] [topological_space M] [charted_space H M] [locally_compact_space H]",
    "doc_string": " If a topological space admits an atlas with locally compact charts, then the space itself is locally compact.",
    "kind": "theorem",
    "type": "locally_compact_space M"
  },
  {
    "name": "lower_semicontinuous_on",
    "statement": "def lower_semicontinuous_on {α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α)",
    "doc_string": " A real function `f` is lower semicontinuous on a set `s` if, for any `ε > 0`, for any `x ∈ s`, for all `x'` close enough to `x` in `s`, then `f x'` is at least `f x - ε`. We formulate this in a general preordered space, using an arbitrary `y < f x` instead of `f x - ε`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "not_or_distrib",
    "statement": "theorem not_or_distrib {a b : Prop} : ¬(a ∨ b) ↔ ¬a ∧ ¬b",
    "theorem": "{a b : Prop} : ¬(a ∨ b) ↔ ¬a ∧ ¬b",
    "args": "{a b : Prop}",
    "doc_string": " One of de Morgan's laws: the negation of a disjunction is logically equivalent to the conjunction of the negations.",
    "kind": "theorem",
    "type": "¬(a ∨ b) ↔ ¬a ∧ ¬b"
  },
  {
    "name": "tactic.suggest.decl_data",
    "statement": "structure tactic.suggest.decl_data  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " A package of `declaration` metadata, including the way in which its type matches the head symbol which we are searching for.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "list.mband",
    "statement": "def list.mband {m : Type → Type v} [monad m] : list (m bool) → m bool",
    "theorem": "{m : Type → Type v} [monad m] : list (m bool) → m bool",
    "args": "{m : Type → Type v} [monad m]",
    "doc_string": " `mband xs` runs the actions in `xs`, returning true if all of them return true. `mband` short-circuits, so if an action returns false, later actions are not run. This is a monadic version of `list.band`.",
    "kind": "def",
    "type": "list (m bool) → m bool"
  },
  {
    "name": "char_zero",
    "statement": "structure char_zero (R : Type u_1) [add_monoid R] [has_one R] : Prop",
    "theorem": "(R : Type u_1) [add_monoid R] [has_one R] : Prop",
    "args": "(R : Type u_1) [add_monoid R] [has_one R]",
    "doc_string": " Typeclass for monoids with characteristic zero.   (This is usually stated on fields but it makes sense for any additive monoid with 1.)  *Warning*: for a semiring `R`, `char_zero R` and `char_p R 0` need not coincide. * `char_zero R` requires an injection `ℕ ↪ R`; * `char_p R 0` asks that only `0 : ℕ` maps to `0 : R` under the map `ℕ → R`.  For instance, endowing `{0, 1}` with addition given by `max` (i.e. `1` is absorbing), shows that `char_zero {0, 1}` does not hold and yet `char_p {0, 1} 0` does. This example is formalized in `counterexamples/char_p_zero_ne_char_zero`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nat.desc_factorial",
    "statement": "def nat.desc_factorial (n : ℕ) : ℕ → ℕ",
    "theorem": "(n : ℕ) : ℕ → ℕ",
    "args": "(n : ℕ)",
    "doc_string": " `n.desc_factorial k = n! / (n - k)!` (as seen in `nat.desc_factorial_eq_div`), but implemented recursively to allow for \"quick\" computation when using `norm_num`. This is closely related to `pochhammer`, but much less general.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "upper_semicontinuous_on",
    "statement": "def upper_semicontinuous_on {α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u_1} [topological_space α] {β : Type u_2} [preorder β] (f : α → β) (s : set α)",
    "doc_string": " A real function `f` is upper semicontinuous on a set `s` if, for any `ε > 0`, for any `x ∈ s`, for all `x'` close enough to `x` in `s`, then `f x'` is at most `f x + ε`. We formulate this in a general preordered space, using an arbitrary `y > f x` instead of `f x + ε`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lie_algebra",
    "statement": "structure lie_algebra (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] : Type (max u v)",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] : Type (max u v)",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L]",
    "doc_string": " A Lie algebra is a module with compatible product, known as the bracket, satisfying the Jacobi identity. Forgetting the scalar multiplication, every Lie algebra is a Lie ring.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "W_type.list_α",
    "statement": "inductive W_type.list_α (γ : Type u) : Type u",
    "theorem": "(γ : Type u) : Type u",
    "args": "(γ : Type u)",
    "doc_string": "The constructors for lists. There is \"one constructor `cons x` for each `x : γ`\", since we view `list γ` as ```lean | nil : list γ | cons x₀ : list γ → list γ | cons x₁ : list γ → list γ |   ⋮      γ many times ```",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "measurable",
    "statement": "def measurable {α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (f : α → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (f : α → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] (f : α → β)",
    "doc_string": "A function `f` between measurable spaces is measurable if the preimage of every  measurable set is measurable.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_add_submonoid.list_sum_mem",
    "statement": "theorem is_add_submonoid.list_sum_mem {M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.sum ∈ s",
    "theorem": "{M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.sum ∈ s",
    "args": "{M : Type u_1} [add_monoid M] {s : set M} (hs : is_add_submonoid s) {l : list M}",
    "doc_string": "The sum of a list of elements of an `add_submonoid` is an element of the `add_submonoid`.",
    "kind": "theorem",
    "type": "(∀ (x : M), x ∈ l → x ∈ s) → l.sum ∈ s"
  },
  {
    "name": "id_restr_groupoid",
    "statement": "def id_restr_groupoid {H : Type u} [topological_space H] : structure_groupoid H",
    "theorem": "{H : Type u} [topological_space H] : structure_groupoid H",
    "args": "{H : Type u} [topological_space H]",
    "doc_string": " The trivial restriction-closed groupoid, containing only local homeomorphisms equivalent to the restriction of the identity to the various open subsets.",
    "kind": "def",
    "type": "structure_groupoid H"
  },
  {
    "name": "absolute_value.is_euclidean",
    "statement": "structure absolute_value.is_euclidean {R : Type u_1} {S : Type u_2} [euclidean_domain R] [ordered_semiring S] (abv : absolute_value R S) : Prop",
    "theorem": "{R : Type u_1} {S : Type u_2} [euclidean_domain R] [ordered_semiring S] (abv : absolute_value R S) : Prop",
    "args": "{R : Type u_1} {S : Type u_2} [euclidean_domain R] [ordered_semiring S] (abv : absolute_value R S)",
    "doc_string": " An absolute value `abv : R → S` is Euclidean if it is compatible with the `euclidean_domain` structure on `R`, namely `abv` is strictly monotone with respect to the well founded relation `≺` on `R`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "set.bij_on.to_local_equiv",
    "statement": "def set.bij_on.to_local_equiv {α : Type u_1} {β : Type u_2} [nonempty α] (f : α → β) (s : set α) (t : set β) (hf : set.bij_on f s t) : local_equiv α β",
    "theorem": "{α : Type u_1} {β : Type u_2} [nonempty α] (f : α → β) (s : set α) (t : set β) (hf : set.bij_on f s t) : local_equiv α β",
    "args": "{α : Type u_1} {β : Type u_2} [nonempty α] (f : α → β) (s : set α) (t : set β) (hf : set.bij_on f s t)",
    "doc_string": " A bijection between two sets `s : set α` and `t : set β` provides a local equivalence between `α` and `β`.",
    "kind": "def",
    "type": "local_equiv α β"
  },
  {
    "name": "list.get_rest",
    "statement": "def list.get_rest {α : Type u_1} [decidable_eq α] : list α → list α → option (list α)",
    "theorem": "{α : Type u_1} [decidable_eq α] : list α → list α → option (list α)",
    "args": "{α : Type u_1} [decidable_eq α]",
    "doc_string": "`get_rest l l₁` returns `some l₂` if `l = l₁ ++ l₂`.  If `l₁` is not a prefix of `l`, returns `none`",
    "kind": "def",
    "type": "list α → list α → option (list α)"
  },
  {
    "name": "unitization",
    "statement": "def unitization (R : Type u_1) (A : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(R : Type u_1) (A : Type u_2) : Type (max u_1 u_2)",
    "args": "(R : Type u_1) (A : Type u_2)",
    "doc_string": " The minimal unitization of a non-unital `R`-algebra `A`. This is just a type synonym for `R × A`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "circular_order",
    "statement": "structure circular_order (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " A circular order is the analogue of a linear order where you can loop around. `≤` and `<` are replaced by ternary relations `btw` and `sbtw`. `btw` is reflexive, cyclic, antisymmetric and total. `sbtw` is transitive.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "bilin_form.is_pair_self_adjoint_submodule",
    "statement": "def bilin_form.is_pair_self_adjoint_submodule {R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] (B₂ F₂ : bilin_form R₂ M₂) : submodule R₂ (module.End R₂ M₂)",
    "theorem": "{R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] (B₂ F₂ : bilin_form R₂ M₂) : submodule R₂ (module.End R₂ M₂)",
    "args": "{R₂ : Type u_5} {M₂ : Type u_6} [comm_semiring R₂] [add_comm_monoid M₂] [module R₂ M₂] (B₂ F₂ : bilin_form R₂ M₂)",
    "doc_string": "The set of pair-self-adjoint endomorphisms are a submodule of the type of all endomorphisms.",
    "kind": "def",
    "type": "submodule R₂ (module.End R₂ M₂)"
  },
  {
    "name": "prod.topological_semiring",
    "statement": "def prod.topological_semiring {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [non_unital_non_assoc_semiring α] [non_unital_non_assoc_semiring β] [topological_semiring α] [topological_semiring β] : topological_semiring (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [non_unital_non_assoc_semiring α] [non_unital_non_assoc_semiring β] [topological_semiring α] [topological_semiring β] : topological_semiring (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [non_unital_non_assoc_semiring α] [non_unital_non_assoc_semiring β] [topological_semiring α] [topological_semiring β]",
    "doc_string": "The product topology on the cartesian product of two topological semirings  makes the product into a topological semiring.",
    "kind": "def",
    "type": "topological_semiring (α × β)"
  },
  {
    "name": "Top.sheaf",
    "statement": "def Top.sheaf (C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top) : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] (X : Top)",
    "doc_string": "A `sheaf C X` is a presheaf of objects from `C` over a (bundled) topological space `X`, satisfying the sheaf condition.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "conditionally_complete_lattice",
    "statement": "structure conditionally_complete_lattice (α : Type u_4) : Type u_4",
    "theorem": "(α : Type u_4) : Type u_4",
    "args": "(α : Type u_4)",
    "doc_string": " A conditionally complete lattice is a lattice in which every nonempty subset which is bounded above has a supremum, and every nonempty subset which is bounded below has an infimum. Typical examples are real numbers or natural numbers.  To differentiate the statements from the corresponding statements in (unconditional) complete lattices, we prefix Inf and Sup by a c everywhere. The same statements should hold in both worlds, sometimes with additional assumptions of nonemptiness or boundedness.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "occurrences",
    "statement": "inductive occurrences  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "We can specify the scope of application of some tactics using  the following type.   - all : all occurrences of a given term are considered.   - pos [1, 3] : only the first and third occurrences of a given    term are consiered.   - neg [2] : all but the second occurrence of a given term    are considered.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "matrix.mv_polynomial_X",
    "statement": "def matrix.mv_polynomial_X (m : Type u_1) (n : Type u_2) (R : Type u_3) [comm_semiring R] : matrix m n (mv_polynomial (m × n) R)",
    "theorem": "(m : Type u_1) (n : Type u_2) (R : Type u_3) [comm_semiring R] : matrix m n (mv_polynomial (m × n) R)",
    "args": "(m : Type u_1) (n : Type u_2) (R : Type u_3) [comm_semiring R]",
    "doc_string": "The matrix with variable `X (i,j)` at location `(i,j)`.",
    "kind": "def",
    "type": "matrix m n (mv_polynomial (m × n) R)"
  },
  {
    "name": "erased.mk",
    "statement": "def erased.mk {α : Sort u_1} (a : α) : erased α",
    "theorem": "{α : Sort u_1} (a : α) : erased α",
    "args": "{α : Sort u_1} (a : α)",
    "doc_string": "Erase a value.",
    "kind": "def",
    "type": "erased α"
  },
  {
    "name": "category_theory.grothendieck_topology.has_Inf",
    "statement": "def category_theory.grothendieck_topology.has_Inf {C : Type u} [category_theory.category C] : has_Inf (category_theory.grothendieck_topology C)",
    "theorem": "{C : Type u} [category_theory.category C] : has_Inf (category_theory.grothendieck_topology C)",
    "args": "{C : Type u} [category_theory.category C]",
    "doc_string": "See <https://stacks.math.columbia.edu/tag/00Z7>",
    "kind": "def",
    "type": "has_Inf (category_theory.grothendieck_topology C)"
  },
  {
    "name": "padic",
    "statement": "def padic (p : ℕ) [fact (nat.prime p)] : Type",
    "theorem": "(p : ℕ) [fact (nat.prime p)] : Type",
    "args": "(p : ℕ) [fact (nat.prime p)]",
    "doc_string": "The p-adic numbers `Q_[p]` are the Cauchy completion of `ℚ` with respect to the p-adic norm.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "category_theory.nerve",
    "statement": "def category_theory.nerve (C : Type u) [category_theory.category C] : sSet",
    "theorem": "(C : Type u) [category_theory.category C] : sSet",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "The nerve of a category",
    "kind": "def",
    "type": "sSet"
  },
  {
    "name": "topological_space.nonempty_compacts.inhabited",
    "statement": "def topological_space.nonempty_compacts.inhabited {α : Type u_1} [topological_space α] [inhabited α] : inhabited (topological_space.nonempty_compacts α)",
    "theorem": "{α : Type u_1} [topological_space α] [inhabited α] : inhabited (topological_space.nonempty_compacts α)",
    "args": "{α : Type u_1} [topological_space α] [inhabited α]",
    "doc_string": " In an inhabited space, the type of nonempty compact subsets is also inhabited, with default element the singleton set containing the default element.",
    "kind": "def",
    "type": "inhabited (topological_space.nonempty_compacts α)"
  },
  {
    "name": "module_info.module_name",
    "statement": "def module_info.module_name  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The name of the module, as used in an import command (e.g. `data.dlist`).",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "charted_space_self",
    "statement": "def charted_space_self (H : Type u_1) [topological_space H] : charted_space H H",
    "theorem": "(H : Type u_1) [topological_space H] : charted_space H H",
    "args": "(H : Type u_1) [topological_space H]",
    "doc_string": "Any space is a charted_space modelled over itself, by just using the identity chart",
    "kind": "def",
    "type": "charted_space H H"
  },
  {
    "name": "is_left_regular.ne_zero",
    "statement": "theorem is_left_regular.ne_zero {R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a ≠ 0",
    "theorem": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a) : a ≠ 0",
    "args": "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_left_regular a)",
    "doc_string": "A left-regular element of a `nontrivial` `mul_zero_class` is non-zero.",
    "kind": "theorem",
    "type": "a ≠ 0"
  },
  {
    "name": "category_theory.quotient",
    "statement": "structure category_theory.quotient {C : Type u_1} [category_theory.category C] (r : hom_rel C) : Type u_1",
    "theorem": "{C : Type u_1} [category_theory.category C] (r : hom_rel C) : Type u_1",
    "args": "{C : Type u_1} [category_theory.category C] (r : hom_rel C)",
    "doc_string": "A type synonym for `C`, thought of as the objects of the quotient category.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "canonically_ordered_monoid",
    "statement": "structure canonically_ordered_monoid (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A canonically ordered monoid is an ordered commutative monoid  in which the ordering coincides with the divisibility relation,  which is to say, `a ≤ b` iff there exists `c` with `b = a * c`.  Examples seem rare; it seems more likely that the `order_dual`  of a naturally-occurring lattice satisfies this than the lattice  itself (for example, dual of the lattice of ideals of a PID or  Dedekind domain satisfy this; collections of all things ≤ 1 seem to  be more natural that collections of all things ≥ 1).",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "torsion",
    "statement": "def torsion (G : Type u_1) [comm_group G] : subgroup G",
    "theorem": "(G : Type u_1) [comm_group G] : subgroup G",
    "args": "(G : Type u_1) [comm_group G]",
    "doc_string": "The torsion subgroup of an abelian group.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "subsingleton_or_nontrivial",
    "statement": "theorem subsingleton_or_nontrivial (α : Type u_1) : subsingleton α ∨ nontrivial α",
    "theorem": "(α : Type u_1) : subsingleton α ∨ nontrivial α",
    "args": "(α : Type u_1)",
    "doc_string": "A type is either a subsingleton or nontrivial.",
    "kind": "theorem",
    "type": "subsingleton α ∨ nontrivial α"
  },
  {
    "name": "CommSemiRing.of",
    "statement": "def CommSemiRing.of (R : Type u) [comm_semiring R] : CommSemiRing",
    "theorem": "(R : Type u) [comm_semiring R] : CommSemiRing",
    "args": "(R : Type u) [comm_semiring R]",
    "doc_string": "Construct a bundled CommSemiRing from the underlying type and typeclass.",
    "kind": "def",
    "type": "CommSemiRing"
  },
  {
    "name": "quiver.symmetrify",
    "statement": "def quiver.symmetrify (V : Type u) : Type u",
    "theorem": "(V : Type u) : Type u",
    "args": "(V : Type u)",
    "doc_string": "A type synonym for the symmetrized quiver (with an arrow both ways for each original arrow).    NB: this does not work for `Prop`-valued quivers. It requires `[quiver.{v+1} V]`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "perfect_closure.mk",
    "statement": "def perfect_closure.mk (K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] (x : ℕ × K) : perfect_closure K p",
    "theorem": "(K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] (x : ℕ × K) : perfect_closure K p",
    "args": "(K : Type u) [comm_ring K] (p : ℕ) [fact (nat.prime p)] [char_p K p] (x : ℕ × K)",
    "doc_string": "Constructor for `perfect_closure`.",
    "kind": "def",
    "type": "perfect_closure K p"
  },
  {
    "name": "grade",
    "statement": "def grade (𝕆 : Type u_1) {α : Type u_3} [preorder 𝕆] [preorder α] [grade_order 𝕆 α] : α → 𝕆",
    "theorem": "(𝕆 : Type u_1) {α : Type u_3} [preorder 𝕆] [preorder α] [grade_order 𝕆 α] : α → 𝕆",
    "args": "(𝕆 : Type u_1) {α : Type u_3} [preorder 𝕆] [preorder α] [grade_order 𝕆 α]",
    "doc_string": " The grade of an element in a graded order. Morally, this is the number of elements you need to go down by to get to `⊥`.",
    "kind": "def",
    "type": "α → 𝕆"
  },
  {
    "name": "Module",
    "statement": "structure Module (R : Type u) [ring R] : Type (max u (v+1))",
    "theorem": "(R : Type u) [ring R] : Type (max u (v+1))",
    "args": "(R : Type u) [ring R]",
    "doc_string": " The category of R-modules and their morphisms.   Note that in the case of `R = ℤ`, we can not impose here that the `ℤ`-multiplication field from the module structure is defeq to the one coming from the `is_add_comm_group` structure (contrary to what we do for all module structures in mathlib), which creates some difficulties down the road.",
    "kind": "structure",
    "type": "Type (max u (v+1))"
  },
  {
    "name": "module.add_comm_monoid_to_add_comm_group",
    "statement": "def module.add_comm_monoid_to_add_comm_group (R : Type u_2) {M : Type u_5} [ring R] [add_comm_monoid M] [module R M] : add_comm_group M",
    "theorem": "(R : Type u_2) {M : Type u_5} [ring R] [add_comm_monoid M] [module R M] : add_comm_group M",
    "args": "(R : Type u_2) {M : Type u_5} [ring R] [add_comm_monoid M] [module R M]",
    "doc_string": " An `add_comm_monoid` that is a `module` over a `ring` carries a natural `add_comm_group` structure. See note [reducible non-instances].",
    "kind": "def",
    "type": "add_comm_group M"
  },
  {
    "name": "nat.arithmetic_function.pmul",
    "statement": "def nat.arithmetic_function.pmul {R : Type u_1} [mul_zero_class R] (f g : nat.arithmetic_function R) : nat.arithmetic_function R",
    "theorem": "{R : Type u_1} [mul_zero_class R] (f g : nat.arithmetic_function R) : nat.arithmetic_function R",
    "args": "{R : Type u_1} [mul_zero_class R] (f g : nat.arithmetic_function R)",
    "doc_string": "This is the pointwise product of `arithmetic_function`s.",
    "kind": "def",
    "type": "nat.arithmetic_function R"
  },
  {
    "name": "many_one_reducible",
    "statement": "def many_one_reducible {α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [primcodable α] [primcodable β] (p : α → Prop) (q : β → Prop)",
    "doc_string": "`p` is many-one reducible to `q` if there is a computable function translating questions about `p` to questions about `q`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "seq1.join",
    "statement": "def seq1.join {α : Type u} : seq1 (seq1 α) → seq1 α",
    "theorem": "{α : Type u} : seq1 (seq1 α) → seq1 α",
    "args": "{α : Type u}",
    "doc_string": "Flatten a nonempty sequence of nonempty sequences",
    "kind": "def",
    "type": "seq1 (seq1 α) → seq1 α"
  },
  {
    "name": "option.choice",
    "statement": "def option.choice (α : Type u_1) : option α",
    "theorem": "(α : Type u_1) : option α",
    "args": "(α : Type u_1)",
    "doc_string": "An arbitrary `some a` with `a : α` if `α` is nonempty, and otherwise `none`.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "linear_ordered_cancel_comm_monoid",
    "statement": "structure linear_ordered_cancel_comm_monoid (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A linearly ordered cancellative commutative monoid is a commutative monoid with a linear order in which multiplication is cancellative and monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "classical.dec",
    "statement": "def classical.dec (p : Prop) : decidable p",
    "theorem": "(p : Prop) : decidable p",
    "args": "(p : Prop)",
    "doc_string": "Any prop `p` is decidable classically. A shorthand for `classical.prop_decidable`.",
    "kind": "def",
    "type": "decidable p"
  },
  {
    "name": "has_inner",
    "statement": "structure has_inner (𝕜 : Type u_4) (E : Type u_5) : Type (max u_4 u_5)",
    "theorem": "(𝕜 : Type u_4) (E : Type u_5) : Type (max u_4 u_5)",
    "args": "(𝕜 : Type u_4) (E : Type u_5)",
    "doc_string": "Syntactic typeclass for types endowed with an inner product",
    "kind": "structure",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "add_units.add_left",
    "statement": "def add_units.add_left {M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M",
    "theorem": "{M : Type u_6} [add_monoid M] (u : add_units M) : equiv.perm M",
    "args": "{M : Type u_6} [add_monoid M] (u : add_units M)",
    "doc_string": "Left addition of an additive unit is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm M"
  },
  {
    "name": "add_zero_class",
    "statement": "structure add_zero_class (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": " Typeclass for expressing that a type `M` with addition and a zero satisfies `0 + a = a` and `a + 0 = a` for all `a : M`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "category_theory.limits.has_finite_wide_pullbacks",
    "statement": "structure category_theory.limits.has_finite_wide_pullbacks (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_finite_wide_pullbacks` represents a choice of wide pullback for every finite collection of morphisms",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "free_product.neword.inv",
    "statement": "def free_product.neword.inv {ι : Type u_1} {G : ι → Type u_4} [Π (i : ι), group (G i)] {i j : ι} (w : free_product.neword G i j) : free_product.neword G j i",
    "theorem": "{ι : Type u_1} {G : ι → Type u_4} [Π (i : ι), group (G i)] {i j : ι} (w : free_product.neword G i j) : free_product.neword G j i",
    "args": "{ι : Type u_1} {G : ι → Type u_4} [Π (i : ι), group (G i)] {i j : ι} (w : free_product.neword G i j)",
    "doc_string": "The inverse of a non-empty reduced word",
    "kind": "def",
    "type": "free_product.neword G j i"
  },
  {
    "name": "metric.diam_eq_zero_of_unbounded",
    "statement": "theorem metric.diam_eq_zero_of_unbounded {α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s) : metric.diam s = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s) : metric.diam s = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s)",
    "doc_string": " An unbounded set has zero diameter. If you would prefer to get the value ∞, use `emetric.diam`. This lemma makes it possible to avoid side conditions in some situations",
    "kind": "theorem",
    "type": "metric.diam s = 0"
  },
  {
    "name": "mul_aut",
    "statement": "def mul_aut (M : Type u_1) [has_mul M] : Type u_1",
    "theorem": "(M : Type u_1) [has_mul M] : Type u_1",
    "args": "(M : Type u_1) [has_mul M]",
    "doc_string": "The group of multiplicative automorphisms.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "freiman_hom",
    "statement": "structure freiman_hom {α : Type u_2} (A : set α) (β : Type u_7) [comm_monoid α] [comm_monoid β] (n : ℕ) : Type (max u_2 u_7)",
    "theorem": "{α : Type u_2} (A : set α) (β : Type u_7) [comm_monoid α] [comm_monoid β] (n : ℕ) : Type (max u_2 u_7)",
    "args": "{α : Type u_2} (A : set α) (β : Type u_7) [comm_monoid α] [comm_monoid β] (n : ℕ)",
    "doc_string": "A `n`-Freiman homomorphism on a set `A` is a map which preserves products of `n` elements.",
    "kind": "structure",
    "type": "Type (max u_2 u_7)"
  },
  {
    "name": "free_product.neword.prod",
    "statement": "def free_product.neword.prod {ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : free_product M",
    "theorem": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j) : free_product M",
    "args": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] {i j : ι} (w : free_product.neword M i j)",
    "doc_string": "A non-empty reduced word determines an element of the free product, given by multiplication.",
    "kind": "def",
    "type": "free_product M"
  },
  {
    "name": "continuous_add_monoid_hom.swap",
    "statement": "def continuous_add_monoid_hom.swap (A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A × B) (B × A)",
    "theorem": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B] : continuous_add_monoid_hom (A × B) (B × A)",
    "args": "(A : Type u_4) (B : Type u_5) [add_monoid A] [add_monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The continuous homomorphism given by swapping components.",
    "kind": "def",
    "type": "continuous_add_monoid_hom (A × B) (B × A)"
  },
  {
    "name": "measure_theory.measurably_separable",
    "statement": "def measure_theory.measurably_separable {α : Type u_1} [measurable_space α] (s t : set α) : Prop",
    "theorem": "{α : Type u_1} [measurable_space α] (s t : set α) : Prop",
    "args": "{α : Type u_1} [measurable_space α] (s t : set α)",
    "doc_string": " Two sets `u` and `v` in a measurable space are measurably separable if there exists a measurable set containing `u` and disjoint from `v`. This is mostly interesting for Borel-separable sets.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.min_fac",
    "statement": "def nat.min_fac  : ℕ → ℕ",
    "theorem": " : ℕ → ℕ",
    "args": "",
    "doc_string": "Returns the smallest prime factor of `n ≠ 1`.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "setoid.map",
    "statement": "def setoid.map {α : Type u_1} {β : Type u_2} (r : setoid α) (f : α → β) : setoid β",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : setoid α) (f : α → β) : setoid β",
    "args": "{α : Type u_1} {β : Type u_2} (r : setoid α) (f : α → β)",
    "doc_string": "Given a function `f : α → β` and equivalence relation `r` on `α`, the equivalence    closure of the relation on `f`'s image defined by '`x ≈ y` iff the elements of `f⁻¹(x)` are    related to the elements of `f⁻¹(y)` by `r`.'",
    "kind": "def",
    "type": "setoid β"
  },
  {
    "name": "uniform_space.completion",
    "statement": "def uniform_space.completion (α : Type u_1) [uniform_space α] : Type u_1",
    "theorem": "(α : Type u_1) [uniform_space α] : Type u_1",
    "args": "(α : Type u_1) [uniform_space α]",
    "doc_string": "Hausdorff completion of `α`",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "omega.coeffs.val",
    "statement": "def omega.coeffs.val (v : ℕ → ℤ) (as : list ℤ) : ℤ",
    "theorem": "(v : ℕ → ℤ) (as : list ℤ) : ℤ",
    "args": "(v : ℕ → ℤ) (as : list ℤ)",
    "doc_string": "Evaluation of the nonconstant component of a normalized linear arithmetic term.",
    "kind": "def",
    "type": "ℤ"
  },
  {
    "name": "fact",
    "statement": "structure fact (p : Prop) : Prop",
    "theorem": "(p : Prop) : Prop",
    "args": "(p : Prop)",
    "doc_string": " Wrapper for adding elementary propositions to the type class systems. Warning: this can easily be abused. See the rest of this docstring for details.  Certain propositions should not be treated as a class globally, but sometimes it is very convenient to be able to use the type class system in specific circumstances.  For example, `zmod p` is a field if and only if `p` is a prime number. In order to be able to find this field instance automatically by type class search, we have to turn `p.prime` into an instance implicit assumption.  On the other hand, making `nat.prime` a class would require a major refactoring of the library, and it is questionable whether making `nat.prime` a class is desirable at all. The compromise is to add the assumption `[fact p.prime]` to `zmod.field`.  In particular, this class is not intended for turning the type class system into an automated theorem prover for first order logic.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "sym.cons",
    "statement": "def sym.cons {α : Type u_1} {n : ℕ} (a : α) (s : sym α n) : sym α n.succ",
    "theorem": "{α : Type u_1} {n : ℕ} (a : α) (s : sym α n) : sym α n.succ",
    "args": "{α : Type u_1} {n : ℕ} (a : α) (s : sym α n)",
    "doc_string": "Inserts an element into the term of `sym α n`, increasing the length by one.",
    "kind": "def",
    "type": "sym α n.succ"
  },
  {
    "name": "group.is_nilpotent",
    "statement": "structure group.is_nilpotent (G : Type u_2) [group G] : Prop",
    "theorem": "(G : Type u_2) [group G] : Prop",
    "args": "(G : Type u_2) [group G]",
    "doc_string": "A group `G` is nilpotent if its upper central series is eventually `G`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "free_add_semigroup.map",
    "statement": "def free_add_semigroup.map {α : Type u} {β : Type v} (f : α → β) : free_add_semigroup α → free_add_semigroup β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : free_add_semigroup α → free_add_semigroup β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": "The unique additive semigroup homomorphism that sends `of x` to `of (f x)`.",
    "kind": "def",
    "type": "free_add_semigroup α → free_add_semigroup β"
  },
  {
    "name": "category_theory.paths",
    "statement": "def category_theory.paths (V : Type u₁) : Type u₁",
    "theorem": "(V : Type u₁) : Type u₁",
    "args": "(V : Type u₁)",
    "doc_string": "A type synonym for the category of paths in a quiver.",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "has_continuous_star",
    "statement": "structure has_continuous_star (R : Type u) [topological_space R] [has_star R] : Prop",
    "theorem": "(R : Type u) [topological_space R] [has_star R] : Prop",
    "args": "(R : Type u) [topological_space R] [has_star R]",
    "doc_string": "Basic hypothesis to talk about a topological space with a continuous `star` operator.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "module_filter_basis.topology",
    "statement": "def module_filter_basis.topology {R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] (B : module_filter_basis R M) : topological_space M",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] (B : module_filter_basis R M) : topological_space M",
    "args": "{R : Type u_1} {M : Type u_2} [comm_ring R] [topological_space R] [add_comm_group M] [module R M] (B : module_filter_basis R M)",
    "doc_string": " The topology associated to a module filter basis on a module over a topological ring. It has the given basis as a basis of neighborhoods of zero.",
    "kind": "def",
    "type": "topological_space M"
  },
  {
    "name": "fintype.to_complete_boolean_algebra",
    "statement": "def fintype.to_complete_boolean_algebra (α : Type u_2) [fintype α] [boolean_algebra α] : complete_boolean_algebra α",
    "theorem": "(α : Type u_2) [fintype α] [boolean_algebra α] : complete_boolean_algebra α",
    "args": "(α : Type u_2) [fintype α] [boolean_algebra α]",
    "doc_string": "A finite boolean algebra is complete.",
    "kind": "def",
    "type": "complete_boolean_algebra α"
  },
  {
    "name": "zero_le_one_class",
    "statement": "structure zero_le_one_class (α : Type u_2) [has_zero α] [has_one α] [has_le α] : Type",
    "theorem": "(α : Type u_2) [has_zero α] [has_one α] [has_le α] : Type",
    "args": "(α : Type u_2) [has_zero α] [has_one α] [has_le α]",
    "doc_string": "Typeclass for expressing that the `0` of a type is less or equal to its `1`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "polynomial.splitting_field",
    "statement": "def polynomial.splitting_field {K : Type v} [field K] (f : polynomial K) : Type v",
    "theorem": "{K : Type v} [field K] (f : polynomial K) : Type v",
    "args": "{K : Type v} [field K] (f : polynomial K)",
    "doc_string": "A splitting field of a polynomial.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "ultrafilter.comap",
    "statement": "def ultrafilter.comap {α : Type u} {β : Type v} {m : α → β} (u : ultrafilter β) (inj : function.injective m) (large : set.range m ∈ u) : ultrafilter α",
    "theorem": "{α : Type u} {β : Type v} {m : α → β} (u : ultrafilter β) (inj : function.injective m) (large : set.range m ∈ u) : ultrafilter α",
    "args": "{α : Type u} {β : Type v} {m : α → β} (u : ultrafilter β) (inj : function.injective m) (large : set.range m ∈ u)",
    "doc_string": " The pullback of an ultrafilter along an injection whose range is large with respect to the given ultrafilter.",
    "kind": "def",
    "type": "ultrafilter α"
  },
  {
    "name": "function.injective.cod_restrict",
    "statement": "theorem function.injective.cod_restrict {α : Type u} {β : Type v} {t : set β} {f : α → β} (h : ∀ (x : α), f x ∈ t) : function.injective f → function.injective (set.cod_restrict f t h)",
    "theorem": "{α : Type u} {β : Type v} {t : set β} {f : α → β} (h : ∀ (x : α), f x ∈ t) : function.injective f → function.injective (set.cod_restrict f t h)",
    "args": "{α : Type u} {β : Type v} {t : set β} {f : α → β} (h : ∀ (x : α), f x ∈ t)",
    "doc_string": "**Alias** of the reverse direction of set.injective_cod_restrict`.",
    "kind": "theorem",
    "type": "function.injective f → function.injective (set.cod_restrict f t h)"
  },
  {
    "name": "pnat.xgcd_type.rq_eq",
    "statement": "theorem pnat.xgcd_type.rq_eq (u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1",
    "theorem": "(u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1",
    "args": "(u : pnat.xgcd_type)",
    "doc_string": "Properties of division with remainder for a / b.",
    "kind": "theorem",
    "type": "u.r + (u.bp + 1) * u.q = u.ap + 1"
  },
  {
    "name": "measure_theory.outer_measure.is_caratheodory",
    "statement": "def measure_theory.outer_measure.is_caratheodory {α : Type u} (m : measure_theory.outer_measure α) (s : set α) : Prop",
    "theorem": "{α : Type u} (m : measure_theory.outer_measure α) (s : set α) : Prop",
    "args": "{α : Type u} (m : measure_theory.outer_measure α) (s : set α)",
    "doc_string": "A set `s` is Carathéodory-measurable for an outer measure `m` if for all sets `t` we have  `m t = m (t ∩ s) + m (t \\ s)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "tactic.tag",
    "statement": "def tactic.tag  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A `tag` is a list of `names`. These are attached to goals to help tactics track them.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "continuous_open_map",
    "statement": "structure continuous_open_map (α : Type u_6) (β : Type u_7) [topological_space α] [topological_space β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [topological_space α] [topological_space β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [topological_space α] [topological_space β]",
    "doc_string": "The type of continuous open maps from `α` to `β`, aka Priestley homomorphisms.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "equiv.perm.to_list",
    "statement": "def equiv.perm.to_list {α : Type u_1} [fintype α] [decidable_eq α] (p : equiv.perm α) (x : α) : list α",
    "theorem": "{α : Type u_1} [fintype α] [decidable_eq α] (p : equiv.perm α) (x : α) : list α",
    "args": "{α : Type u_1} [fintype α] [decidable_eq α] (p : equiv.perm α) (x : α)",
    "doc_string": "`equiv.perm.to_list (f : perm α) (x : α)` generates the list `[x, f x, f (f x), ...]` until looping. That means when `f x = x`, `to_list f x = []`.",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "first_order.language.nonempty_theory",
    "statement": "def first_order.language.nonempty_theory (L : first_order.language) : L.Theory",
    "theorem": "(L : first_order.language) : L.Theory",
    "args": "(L : first_order.language)",
    "doc_string": "A theory that indicates a structure is nonempty.",
    "kind": "def",
    "type": "L.Theory"
  },
  {
    "name": "uchange",
    "statement": "def uchange (α : Type v) : Type u",
    "theorem": "(α : Type v) : Type u",
    "args": "(α : Type v)",
    "doc_string": "`uchange (α : Sort v) : Sort u` is an equivalent type in a different universe.  In the VM, both `α` and `uchange α` have the same representation.  This definition is `meta` because it collapses the universe hierarchy; if pure code could do this then one could derive Girard's paradox.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "is_smul_regular.one",
    "statement": "theorem is_smul_regular.one {R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1",
    "theorem": "{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1",
    "args": "{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M]",
    "doc_string": "One is `M`-regular always.",
    "kind": "theorem",
    "type": "is_smul_regular M 1"
  },
  {
    "name": "category_theory.paths.of",
    "statement": "def category_theory.paths.of {V : Type u₁} [quiver V] : prefunctor V (category_theory.paths V)",
    "theorem": "{V : Type u₁} [quiver V] : prefunctor V (category_theory.paths V)",
    "args": "{V : Type u₁} [quiver V]",
    "doc_string": "The inclusion of a quiver `V` into its path category, as a prefunctor.",
    "kind": "def",
    "type": "prefunctor V (category_theory.paths V)"
  },
  {
    "name": "well_founded_tactics",
    "statement": "structure well_founded_tactics  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Argument for using_well_founded   The tactic `rel_tac` has to synthesize an element of type (has_well_founded A).  The two arguments are: a local representing the function being defined by well  founded recursion, and a list of recursive equations.  The equations can be used to decide which well founded relation should be used.   The tactic `dec_tac` has to synthesize decreasing proofs.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "computability.encode_pos_num",
    "statement": "def computability.encode_pos_num  : pos_num → list bool",
    "theorem": " : pos_num → list bool",
    "args": "",
    "doc_string": "An encoding function of the positive binary numbers in bool.",
    "kind": "def",
    "type": "pos_num → list bool"
  },
  {
    "name": "category_theory.limits.binary_bicone.to_cone",
    "statement": "def category_theory.limits.binary_bicone.to_cone {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cone (category_theory.limits.pair P Q)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q) : category_theory.limits.cone (category_theory.limits.pair P Q)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] {P Q : C} (c : category_theory.limits.binary_bicone P Q)",
    "doc_string": "Extract the cone from a binary bicone.",
    "kind": "def",
    "type": "category_theory.limits.cone (category_theory.limits.pair P Q)"
  },
  {
    "name": "module.finite",
    "statement": "structure module.finite (R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "theorem": "(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "args": "(R : Type u_1) (M : Type u_4) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "A module over a semiring is `finite` if it is finitely generated as a module.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "linear_ordered_field",
    "statement": "structure linear_ordered_field (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A linear ordered field is a field with a linear order respecting the operations.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "reflexive_ne_imp_iff",
    "statement": "theorem reflexive_ne_imp_iff {α : Type u_1} {r : α → α → Prop} [is_refl α r] {x y : α} : x ≠ y → r x y ↔ r x y",
    "theorem": "{α : Type u_1} {r : α → α → Prop} [is_refl α r] {x y : α} : x ≠ y → r x y ↔ r x y",
    "args": "{α : Type u_1} {r : α → α → Prop} [is_refl α r] {x y : α}",
    "doc_string": " If a reflexive relation `r : α → α → Prop` holds over `x y : α`, then it holds whether or not `x ≠ y`. Unlike `reflexive.ne_imp_iff`, this uses `[is_refl α r]`.",
    "kind": "theorem",
    "type": "x ≠ y → r x y ↔ r x y"
  },
  {
    "name": "submodule.has_quotient",
    "statement": "def submodule.has_quotient {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : has_quotient M (submodule R M)",
    "theorem": "{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : has_quotient M (submodule R M)",
    "args": "{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M]",
    "doc_string": "The quotient of a module `M` by a submodule `p ⊆ M`.",
    "kind": "def",
    "type": "has_quotient M (submodule R M)"
  },
  {
    "name": "fin.cons_injective2",
    "statement": "theorem fin.cons_injective2 {n : ℕ} {α : fin (n + 1) → Type u} : function.injective2 fin.cons",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} : function.injective2 fin.cons",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u}",
    "doc_string": "As a binary function, `fin.cons` is injective.",
    "kind": "theorem",
    "type": "function.injective2 fin.cons"
  },
  {
    "name": "zero_at_infty_continuous_map_class",
    "statement": "structure zero_at_infty_continuous_map_class (F : Type u_2) (α : out_param (Type u_3)) (β : out_param (Type u_4)) [topological_space α] [has_zero β] [topological_space β] : Type (max u_2 u_3 u_4)",
    "theorem": "(F : Type u_2) (α : out_param (Type u_3)) (β : out_param (Type u_4)) [topological_space α] [has_zero β] [topological_space β] : Type (max u_2 u_3 u_4)",
    "args": "(F : Type u_2) (α : out_param (Type u_3)) (β : out_param (Type u_4)) [topological_space α] [has_zero β] [topological_space β]",
    "doc_string": " `zero_at_infty_continuous_map_class F α β` states that `F` is a type of continuous maps which vanish at infinity.  You should also extend this typeclass when you extend `zero_at_infty_continuous_map`.",
    "kind": "structure",
    "type": "Type (max u_2 u_3 u_4)"
  },
  {
    "name": "div_eq_one_of_eq",
    "statement": "theorem div_eq_one_of_eq {G : Type u_2} [group G] {a b : G} : a = b → a / b = 1",
    "theorem": "{G : Type u_2} [group G] {a b : G} : a = b → a / b = 1",
    "args": "{G : Type u_2} [group G] {a b : G}",
    "doc_string": "**Alias** of the reverse direction of div_eq_one`.",
    "kind": "theorem",
    "type": "a = b → a / b = 1"
  },
  {
    "name": "has_le.le.trans_lt",
    "statement": "theorem has_le.le.trans_lt {α : Type u} [preorder α] {a b c : α} : a ≤ b → b < c → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : a ≤ b → b < c → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_le_of_lt`.",
    "kind": "theorem",
    "type": "a ≤ b → b < c → a < c"
  },
  {
    "name": "stieltjes_function.id",
    "statement": "def stieltjes_function.id  : stieltjes_function",
    "theorem": " : stieltjes_function",
    "args": "",
    "doc_string": "The identity of `ℝ` as a Stieltjes function, used to construct Lebesgue measure.",
    "kind": "def",
    "type": "stieltjes_function"
  },
  {
    "name": "lt_add_of_sub_left_lt",
    "statement": "theorem lt_add_of_sub_left_lt {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a - b < c → a < b + c",
    "theorem": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a - b < c → a < b + c",
    "args": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of sub_lt_iff_lt_add'`.",
    "kind": "theorem",
    "type": "a - b < c → a < b + c"
  },
  {
    "name": "group_with_zero",
    "statement": "structure group_with_zero (G₀ : Type u) : Type u",
    "theorem": "(G₀ : Type u) : Type u",
    "args": "(G₀ : Type u)",
    "doc_string": " A type `G₀` is a “group with zero” if it is a monoid with zero element (distinct from `1`) such that every nonzero element is invertible. The type is required to come with an “inverse” function, and the inverse of `0` must be `0`.  Examples include division rings and the ordered monoids that are the target of valuations in general valuation theory.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "pgame.domineering.L",
    "statement": "def pgame.domineering.L  : pgame",
    "theorem": " : pgame",
    "args": "",
    "doc_string": "The `L` shaped Domineering board, in which Left is exactly half a move ahead.",
    "kind": "def",
    "type": "pgame"
  },
  {
    "name": "category_theory.pretopology",
    "statement": "structure category_theory.pretopology (C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C]",
    "doc_string": "A (Grothendieck) pretopology on `C` consists of a collection of families of morphisms with a fixed target `X` for every object `X` in `C`, called \"coverings\" of `X`, which satisfies the following three axioms: 1. Every family consisting of a single isomorphism is a covering family. 2. The collection of covering families is stable under pullback. 3. Given a covering family, and a covering family on each domain of the former, the composition    is a covering family.  In some sense, a pretopology can be seen as Grothendieck topology with weaker saturation conditions, in that each covering is not necessarily downward closed.  See: https://ncatlab.org/nlab/show/Grothendieck+pretopology, or https://stacks.math.columbia.edu/tag/00VH, or [MM92] Chapter III, Section 2, Definition 2. Note that Stacks calls a category together with a pretopology a site, and [MM92] calls this a basis for a topology.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "basis.singleton",
    "statement": "def basis.singleton (ι : Type u_1) (R : Type u_2) [unique ι] [semiring R] : basis ι R R",
    "theorem": "(ι : Type u_1) (R : Type u_2) [unique ι] [semiring R] : basis ι R R",
    "args": "(ι : Type u_1) (R : Type u_2) [unique ι] [semiring R]",
    "doc_string": "`basis.singleton ι R` is the basis sending the unique element of `ι` to `1 : R`.",
    "kind": "def",
    "type": "basis ι R R"
  },
  {
    "name": "dfinsupp.coe_fn_injective",
    "statement": "theorem dfinsupp.coe_fn_injective {ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)] : function.injective coe_fn",
    "theorem": "{ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)] : function.injective coe_fn",
    "args": "{ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)]",
    "doc_string": "Deprecated. Use `fun_like.coe_injective` instead.",
    "kind": "theorem",
    "type": "function.injective coe_fn"
  },
  {
    "name": "category_theory.locally_discrete",
    "statement": "def category_theory.locally_discrete (C : Type u) : Type u",
    "theorem": "(C : Type u) : Type u",
    "args": "(C : Type u)",
    "doc_string": "A type synonym for promoting any type to a category, with the only morphisms being equalities.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "list.prod_eq_zero",
    "statement": "theorem list.prod_eq_zero {M₀ : Type u_6} [monoid_with_zero M₀] {L : list M₀} (h : 0 ∈ L) : L.prod = 0",
    "theorem": "{M₀ : Type u_6} [monoid_with_zero M₀] {L : list M₀} (h : 0 ∈ L) : L.prod = 0",
    "args": "{M₀ : Type u_6} [monoid_with_zero M₀] {L : list M₀} (h : 0 ∈ L)",
    "doc_string": " If zero is an element of a list `L`, then `list.prod L = 0`. If the domain is a nontrivial monoid with zero with no divisors, then this implication becomes an `iff`, see `list.prod_eq_zero_iff`.",
    "kind": "theorem",
    "type": "L.prod = 0"
  },
  {
    "name": "normed_linear_ordered_group",
    "statement": "structure normed_linear_ordered_group (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A `normed_linear_ordered_group` is an additive group that is both a `normed_group` and    a `linear_ordered_add_comm_group`. This class is necessary to avoid diamonds.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "function.bij_on_fixed_pts_comp",
    "statement": "theorem function.bij_on_fixed_pts_comp {α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))",
    "args": "{α : Type u} {β : Type v} (f : α → β) (g : β → α)",
    "doc_string": " Given two maps `f : α → β` and `g : β → α`, `g` is a bijective map between the fixed points of `f ∘ g` and the fixed points of `g ∘ f`. The inverse map is `f`, see `inv_on_fixed_pts_comp`.",
    "kind": "theorem",
    "type": "set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))"
  },
  {
    "name": "complete_semilattice_Inf",
    "statement": "structure complete_semilattice_Inf (α : Type u_8) : Type u_8",
    "theorem": "(α : Type u_8) : Type u_8",
    "args": "(α : Type u_8)",
    "doc_string": "Note that we rarely use `complete_semilattice_Inf` (in fact, any such object is always a `complete_lattice`, so it's usually best to start there).  Nevertheless it is sometimes a useful intermediate step in constructions.",
    "kind": "structure",
    "type": "Type u_8"
  },
  {
    "name": "circular_partial_order",
    "statement": "structure circular_partial_order (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " A circular partial order is the analogue of a partial order where you can loop around. `≤` and `<` are replaced by ternary relations `btw` and `sbtw`. `btw` is reflexive, cyclic and antisymmetric. `sbtw` is transitive.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "clopen_upper_set.to_upper_set",
    "statement": "def clopen_upper_set.to_upper_set {α : Type u_1} [topological_space α] [has_le α] (s : clopen_upper_set α) : upper_set α",
    "theorem": "{α : Type u_1} [topological_space α] [has_le α] (s : clopen_upper_set α) : upper_set α",
    "args": "{α : Type u_1} [topological_space α] [has_le α] (s : clopen_upper_set α)",
    "doc_string": "Reinterpret a upper clopen as an upper set.",
    "kind": "def",
    "type": "upper_set α"
  },
  {
    "name": "category_theory.AdditiveFunctor",
    "statement": "def category_theory.AdditiveFunctor (C : Type u_1) (D : Type u_2) [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] : Type (max u_3 u_4 u_1 u_2)",
    "theorem": "(C : Type u_1) (D : Type u_2) [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D] : Type (max u_3 u_4 u_1 u_2)",
    "args": "(C : Type u_1) (D : Type u_2) [category_theory.category C] [category_theory.category D] [category_theory.preadditive C] [category_theory.preadditive D]",
    "doc_string": "Bundled additive functors.",
    "kind": "def",
    "type": "Type (max u_3 u_4 u_1 u_2)"
  },
  {
    "name": "free_magma.map",
    "statement": "def free_magma.map {α : Type u} {β : Type v} (f : α → β) : free_magma α → free_magma β",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) : free_magma α → free_magma β",
    "args": "{α : Type u} {β : Type v} (f : α → β)",
    "doc_string": " The unique magma homomorphism `free_magma α → free_magma β` that sends each `of x` to `of (f x)`.",
    "kind": "def",
    "type": "free_magma α → free_magma β"
  },
  {
    "name": "add_group_filter_basis.inhabited",
    "statement": "def add_group_filter_basis.inhabited {G : Type u} [add_group G] : inhabited (add_group_filter_basis G)",
    "theorem": "{G : Type u} [add_group G] : inhabited (add_group_filter_basis G)",
    "args": "{G : Type u} [add_group G]",
    "doc_string": "The trivial additive group filter basis consists of `{0}` only. The associated topology is discrete.",
    "kind": "def",
    "type": "inhabited (add_group_filter_basis G)"
  },
  {
    "name": "submodule.has_bot",
    "statement": "def submodule.has_bot {R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_bot (submodule R M)",
    "theorem": "{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M] : has_bot (submodule R M)",
    "args": "{R : Type u_1} {M : Type u_3} [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "The set `{0}` is the bottom element of the lattice of submodules.",
    "kind": "def",
    "type": "has_bot (submodule R M)"
  },
  {
    "name": "finset.min",
    "statement": "def finset.min {α : Type u_1} [linear_order α] : finset α → option α",
    "theorem": "{α : Type u_1} [linear_order α] : finset α → option α",
    "args": "{α : Type u_1} [linear_order α]",
    "doc_string": " Let `s` be a finset in a linear order. Then `s.min` is the minimum of `s` if `s` is not empty, and `none` otherwise. It belongs to `option α`. If you want to get an element of `α`, see `s.min'`.",
    "kind": "def",
    "type": "finset α → option α"
  },
  {
    "name": "subfield.list_prod_mem",
    "statement": "theorem subfield.list_prod_mem {K : Type u} [field K] (s : subfield K) {l : list K} : (∀ (x : K), x ∈ l → x ∈ s) → l.prod ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) {l : list K} : (∀ (x : K), x ∈ l → x ∈ s) → l.prod ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K) {l : list K}",
    "doc_string": "Product of a list of elements in a subfield is in the subfield.",
    "kind": "theorem",
    "type": "(∀ (x : K), x ∈ l → x ∈ s) → l.prod ∈ s"
  },
  {
    "name": "polynomial.mod_by_monic",
    "statement": "def polynomial.mod_by_monic {R : Type u} [ring R] (p q : polynomial R) : polynomial R",
    "theorem": "{R : Type u} [ring R] (p q : polynomial R) : polynomial R",
    "args": "{R : Type u} [ring R] (p q : polynomial R)",
    "doc_string": "`mod_by_monic` gives the remainder of `p` by a monic polynomial `q`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "Set.prod",
    "statement": "def Set.prod  : Set → Set → Set",
    "theorem": " : Set → Set → Set",
    "args": "",
    "doc_string": "The cartesian product, `{(a, b) | a ∈ x, b ∈ y}`",
    "kind": "def",
    "type": "Set → Set → Set"
  },
  {
    "name": "Set.empty",
    "statement": "def Set.empty  : Set",
    "theorem": " : Set",
    "args": "",
    "doc_string": "The empty ZFC set",
    "kind": "def",
    "type": "Set"
  },
  {
    "name": "stream.inits",
    "statement": "def stream.inits {α : Type u} (s : stream α) : stream (list α)",
    "theorem": "{α : Type u} (s : stream α) : stream (list α)",
    "args": "{α : Type u} (s : stream α)",
    "doc_string": "Nonempty initial segments of a stream.",
    "kind": "def",
    "type": "stream (list α)"
  },
  {
    "name": "mul_aut.apply_has_faithful_smul",
    "statement": "def mul_aut.apply_has_faithful_smul {M : Type u_1} [monoid M] : has_faithful_smul (mul_aut M) M",
    "theorem": "{M : Type u_1} [monoid M] : has_faithful_smul (mul_aut M) M",
    "args": "{M : Type u_1} [monoid M]",
    "doc_string": "`mul_aut.apply_mul_action` is faithful.",
    "kind": "def",
    "type": "has_faithful_smul (mul_aut M) M"
  },
  {
    "name": "add_subgroup.topological_closure",
    "statement": "def add_subgroup.topological_closure {G : Type w} [topological_space G] [add_group G] [topological_add_group G] (s : add_subgroup G) : add_subgroup G",
    "theorem": "{G : Type w} [topological_space G] [add_group G] [topological_add_group G] (s : add_subgroup G) : add_subgroup G",
    "args": "{G : Type w} [topological_space G] [add_group G] [topological_add_group G] (s : add_subgroup G)",
    "doc_string": "The (topological-space) closure of an additive subgroup of a space `M` with `has_continuous_add` is itself an additive subgroup.",
    "kind": "def",
    "type": "add_subgroup G"
  },
  {
    "name": "cartan_matrix.generators",
    "statement": "inductive cartan_matrix.generators (B : Type v) [decidable_eq B] [fintype B] : Type v",
    "theorem": "(B : Type v) [decidable_eq B] [fintype B] : Type v",
    "args": "(B : Type v) [decidable_eq B] [fintype B]",
    "doc_string": " The generators of the free Lie algebra from which we construct the Lie algebra of a Cartan matrix as a quotient.",
    "kind": "inductive",
    "type": "Type v"
  },
  {
    "name": "free_group.of_injective",
    "statement": "theorem free_group.of_injective {α : Type u} : function.injective free_group.of",
    "theorem": "{α : Type u} : function.injective free_group.of",
    "args": "{α : Type u}",
    "doc_string": "The canonical injection from the type to the free group is an injection.",
    "kind": "theorem",
    "type": "function.injective free_group.of"
  },
  {
    "name": "mul_eq_zero_comm",
    "statement": "theorem mul_eq_zero_comm {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ b * a = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ b * a = 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then for elements `a, b : α`, `a * b` equals zero iff so is `b * a`.",
    "kind": "theorem",
    "type": "a * b = 0 ↔ b * a = 0"
  },
  {
    "name": "is_unit.mul_right_dvd",
    "statement": "theorem is_unit.mul_right_dvd {α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u) : a * u ∣ b ↔ a ∣ b",
    "theorem": "{α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u) : a * u ∣ b ↔ a ∣ b",
    "args": "{α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u)",
    "doc_string": "In a monoid, an element a divides an element b iff all associates of `a` divide `b`.",
    "kind": "theorem",
    "type": "a * u ∣ b ↔ a ∣ b"
  },
  {
    "name": "tactic.suggest.application",
    "statement": "structure tactic.suggest.application  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "An `application` records the result of a successful application of a library lemma.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "cycle",
    "statement": "def cycle (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "`cycle α` is the quotient of `list α` by cyclic permutation. Duplicates are allowed.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "filter.monoid",
    "statement": "def filter.monoid {α : Type u_2} [monoid α] : monoid (filter α)",
    "theorem": "{α : Type u_2} [monoid α] : monoid (filter α)",
    "args": "{α : Type u_2} [monoid α]",
    "doc_string": "`filter α` is a `monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "monoid (filter α)"
  },
  {
    "name": "ray_vector.has_involutive_neg",
    "statement": "def ray_vector.has_involutive_neg {M : Type u_2} [add_comm_group M] {R : Type u_1} : has_involutive_neg (ray_vector R M)",
    "theorem": "{M : Type u_2} [add_comm_group M] {R : Type u_1} : has_involutive_neg (ray_vector R M)",
    "args": "{M : Type u_2} [add_comm_group M] {R : Type u_1}",
    "doc_string": "Negating a nonzero vector twice produces the original vector.",
    "kind": "def",
    "type": "has_involutive_neg (ray_vector R M)"
  },
  {
    "name": "category_theory.single_obj",
    "statement": "def category_theory.single_obj (α : Type u) : Type",
    "theorem": "(α : Type u) : Type",
    "args": "(α : Type u)",
    "doc_string": "Type tag on `unit` used to define single-object categories and groupoids.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "function_field.infty_valued_Fqt",
    "statement": "def function_field.infty_valued_Fqt (Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valued (ratfunc Fq) (with_zero (multiplicative ℤ))",
    "theorem": "(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)] : valued (ratfunc Fq) (with_zero (multiplicative ℤ))",
    "args": "(Fq : Type) [field Fq] [decidable_eq (ratfunc Fq)]",
    "doc_string": "The valued field `Fq(t)` with the valuation at infinity.",
    "kind": "def",
    "type": "valued (ratfunc Fq) (with_zero (multiplicative ℤ))"
  },
  {
    "name": "exp_char_one_iff_char_zero",
    "statement": "theorem exp_char_one_iff_char_zero (R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q] : q = 1 ↔ p = 0",
    "theorem": "(R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q] : q = 1 ↔ p = 0",
    "args": "(R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q]",
    "doc_string": "The exponential characteristic is one iff the characteristic is zero.",
    "kind": "theorem",
    "type": "q = 1 ↔ p = 0"
  },
  {
    "name": "uniform_space.core",
    "statement": "structure uniform_space.core (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "This core description of a uniform space is outside of the type class hierarchy. It is useful  for constructions of uniform spaces, when the topology is derived from the uniform space.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "is_chain.exists_max_chain",
    "statement": "theorem is_chain.exists_max_chain {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M",
    "theorem": "{α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M",
    "args": "{α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c)",
    "doc_string": "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.",
    "kind": "theorem",
    "type": "∃ (M : set α), is_max_chain r M ∧ c ⊆ M"
  },
  {
    "name": "is_R_or_C",
    "statement": "structure is_R_or_C (K : Type u_1) : Type u_1",
    "theorem": "(K : Type u_1) : Type u_1",
    "args": "(K : Type u_1)",
    "doc_string": "This typeclass captures properties shared by ℝ and ℂ, with an API that closely matches that of ℂ.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "bundle.total_space.proj",
    "statement": "def bundle.total_space.proj {B : Type u_1} {E : B → Type u_2} : bundle.total_space E → B",
    "theorem": "{B : Type u_1} {E : B → Type u_2} : bundle.total_space E → B",
    "args": "{B : Type u_1} {E : B → Type u_2}",
    "doc_string": " `bundle.total_space.proj` is the canonical projection `bundle.total_space E → B` from the total space to the base space.",
    "kind": "def",
    "type": "bundle.total_space E → B"
  },
  {
    "name": "interior_frontier",
    "statement": "theorem interior_frontier {α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅",
    "theorem": "{α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅",
    "args": "{α : Type u} [topological_space α] {s : set α} (h : is_closed s)",
    "doc_string": "The frontier of a closed set has no interior point.",
    "kind": "theorem",
    "type": "interior (frontier s) = ∅"
  },
  {
    "name": "subring.multiset_prod_mem",
    "statement": "theorem subring.multiset_prod_mem {R : Type u_1} [comm_ring R] (s : subring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s",
    "theorem": "{R : Type u_1} [comm_ring R] (s : subring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s",
    "args": "{R : Type u_1} [comm_ring R] (s : subring R) (m : multiset R)",
    "doc_string": "Product of a multiset of elements in a subring of a `comm_ring` is in the subring.",
    "kind": "theorem",
    "type": "(∀ (a : R), a ∈ m → a ∈ s) → m.prod ∈ s"
  },
  {
    "name": "wseq.to_list",
    "statement": "def wseq.to_list {α : Type u} (s : wseq α) : computation (list α)",
    "theorem": "{α : Type u} (s : wseq α) : computation (list α)",
    "args": "{α : Type u} (s : wseq α)",
    "doc_string": "Convert `s` to a list (if it is finite and completes in finite time).",
    "kind": "def",
    "type": "computation (list α)"
  },
  {
    "name": "has_Sup",
    "statement": "structure has_Sup (α : Type u_8) : Type u_8",
    "theorem": "(α : Type u_8) : Type u_8",
    "args": "(α : Type u_8)",
    "doc_string": "class for the `Sup` operator",
    "kind": "structure",
    "type": "Type u_8"
  },
  {
    "name": "algebraic_independent",
    "statement": "def algebraic_independent {ι : Type u_1} (R : Type u_3) {A : Type u_5} (x : ι → A) [comm_ring R] [comm_ring A] [algebra R A] : Prop",
    "theorem": "{ι : Type u_1} (R : Type u_3) {A : Type u_5} (x : ι → A) [comm_ring R] [comm_ring A] [algebra R A] : Prop",
    "args": "{ι : Type u_1} (R : Type u_3) {A : Type u_5} (x : ι → A) [comm_ring R] [comm_ring A] [algebra R A]",
    "doc_string": "`algebraic_independent R x` states the family of elements `x`  is algebraically independent over `R`, meaning that the canonical  map out of the multivariable polynomial ring is injective.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "bornology.is_cobounded",
    "statement": "def bornology.is_cobounded {α : Type u_2} [bornology α] (s : set α) : Prop",
    "theorem": "{α : Type u_2} [bornology α] (s : set α) : Prop",
    "args": "{α : Type u_2} [bornology α] (s : set α)",
    "doc_string": " `is_cobounded` is the predicate that `s` is in the filter of cobounded sets in the ambient bornology on `α`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "commutator_element",
    "statement": "def commutator_element {G : Type u_1} [group G] : has_bracket G G",
    "theorem": "{G : Type u_1} [group G] : has_bracket G G",
    "args": "{G : Type u_1} [group G]",
    "doc_string": "The commutator of two elements `g₁` and `g₂`.",
    "kind": "def",
    "type": "has_bracket G G"
  },
  {
    "name": "graded_monoid.gmonoid",
    "statement": "structure graded_monoid.gmonoid {ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι]",
    "doc_string": " A graded version of `monoid`.  Like `monoid.npow`, this has an optional `gmonoid.gnpow` field to allow definitional control of natural powers of a graded monoid.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "galois_insertion.lift_lattice",
    "statement": "def galois_insertion.lift_lattice {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [lattice α] (gi : galois_insertion l u) : lattice β",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [lattice α] (gi : galois_insertion l u) : lattice β",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [lattice α] (gi : galois_insertion l u)",
    "doc_string": "Lift the suprema and infima along a Galois insertion",
    "kind": "def",
    "type": "lattice β"
  },
  {
    "name": "list.func.add",
    "statement": "def list.func.add {α : Type u} [has_zero α] [has_add α] : list α → list α → list α",
    "theorem": "{α : Type u} [has_zero α] [has_add α] : list α → list α → list α",
    "args": "{α : Type u} [has_zero α] [has_add α]",
    "doc_string": "Pointwise addition on lists. If lists are different lengths, use zero.",
    "kind": "def",
    "type": "list α → list α → list α"
  },
  {
    "name": "submonoid.fg",
    "statement": "def submonoid.fg {M : Type u_1} [monoid M] (P : submonoid M) : Prop",
    "theorem": "{M : Type u_1} [monoid M] (P : submonoid M) : Prop",
    "args": "{M : Type u_1} [monoid M] (P : submonoid M)",
    "doc_string": "A submonoid of `M` is finitely generated if it is the closure of a finite subset of `M`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_finite_biproducts.of_has_finite_products",
    "statement": "theorem category_theory.limits.has_finite_biproducts.of_has_finite_products {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C]",
    "doc_string": "A preadditive category with finite products has finite biproducts.",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_biproducts C"
  },
  {
    "name": "homological_complex.hom",
    "statement": "structure homological_complex.hom {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (A B : homological_complex V c) : Type (max u_1 v)",
    "theorem": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (A B : homological_complex V c) : Type (max u_1 v)",
    "args": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.limits.has_zero_morphisms V] {c : complex_shape ι} (A B : homological_complex V c)",
    "doc_string": "A morphism of homological complexes consists of maps between the chain groups, commuting with the differentials.",
    "kind": "structure",
    "type": "Type (max u_1 v)"
  },
  {
    "name": "matrix.transvection",
    "statement": "def matrix.transvection {n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (i j : n) (c : R) : matrix n n R",
    "theorem": "{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (i j : n) (c : R) : matrix n n R",
    "args": "{n : Type u_1} {R : Type u₂} [decidable_eq n] [comm_ring R] (i j : n) (c : R)",
    "doc_string": " The transvection matrix `transvection i j c` is equal to the identity plus `c` at position `(i, j)`. Multiplying by it on the left (as in `transvection i j c ⬝ M`) corresponds to adding `c` times the `j`-th line of `M` to its `i`-th line. Multiplying by it on the right corresponds to adding `c` times the `i`-th column to the `j`-th column.",
    "kind": "def",
    "type": "matrix n n R"
  },
  {
    "name": "hash_map.contains",
    "statement": "def hash_map.contains {α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α) : bool",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α) : bool",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (m : hash_map α β) (a : α)",
    "doc_string": "Return `tt` if the key exists in the map",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "lazy_list.reverse",
    "statement": "def lazy_list.reverse {α : Type u_1} (xs : lazy_list α) : lazy_list α",
    "theorem": "{α : Type u_1} (xs : lazy_list α) : lazy_list α",
    "args": "{α : Type u_1} (xs : lazy_list α)",
    "doc_string": " Reverse the order of a `lazy_list`. It is done by converting to a `list` first because reversal involves evaluating all the list and if the list is all evaluated, `list` is a better representation for it than a series of thunks.",
    "kind": "def",
    "type": "lazy_list α"
  },
  {
    "name": "category_theory.abelian",
    "statement": "structure category_theory.abelian (C : Type u) [category_theory.category C] : Type (max u v)",
    "theorem": "(C : Type u) [category_theory.category C] : Type (max u v)",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A (preadditive) category `C` is called abelian if it has all finite products, all kernels and cokernels, and if every monomorphism is the kernel of some morphism and every epimorphism is the cokernel of some morphism.  (This definition implies the existence of zero objects: finite products give a terminal object, and in a preadditive category any terminal object is a zero object.)",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "graded_monoid.gmonoid.to_monoid",
    "statement": "def graded_monoid.gmonoid.to_monoid {ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] : monoid (graded_monoid A)",
    "theorem": "{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A] : monoid (graded_monoid A)",
    "args": "{ι : Type u_1} (A : ι → Type u_2) [add_monoid ι] [graded_monoid.gmonoid A]",
    "doc_string": "`gmonoid` implies a `monoid (graded_monoid A)`.",
    "kind": "def",
    "type": "monoid (graded_monoid A)"
  },
  {
    "name": "category_theory.small_category",
    "statement": "def category_theory.small_category (C : Type u) : Type (u+1)",
    "theorem": "(C : Type u) : Type (u+1)",
    "args": "(C : Type u)",
    "doc_string": "A `small_category` has objects and morphisms in the same universe level.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "measure_theory.outer_measure.bounded_by",
    "statement": "def measure_theory.outer_measure.bounded_by {α : Type u_1} (m : set α → ennreal) : measure_theory.outer_measure α",
    "theorem": "{α : Type u_1} (m : set α → ennreal) : measure_theory.outer_measure α",
    "args": "{α : Type u_1} (m : set α → ennreal)",
    "doc_string": "Given any function `m` assigning measures to sets, there is a unique maximal outer measure `μ`  satisfying `μ s ≤ m s` for all `s : set α`. This is the same as `outer_measure.of_function`,  except that it doesn't require `m ∅ = 0`.",
    "kind": "def",
    "type": "measure_theory.outer_measure α"
  },
  {
    "name": "local_homeomorph.restr_open",
    "statement": "def local_homeomorph.restr_open {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) (hs : is_open s) : local_homeomorph α β",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) (hs : is_open s) : local_homeomorph α β",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) (hs : is_open s)",
    "doc_string": " Restricting a local homeomorphism `e` to `e.source ∩ s` when `s` is open. This is sometimes hard to use because of the openness assumption, but it has the advantage that when it can be used then its local_equiv is defeq to local_equiv.restr",
    "kind": "def",
    "type": "local_homeomorph α β"
  },
  {
    "name": "finset.image",
    "statement": "def finset.image {α : Type u_1} {β : Type u_2} [decidable_eq β] (f : α → β) (s : finset α) : finset β",
    "theorem": "{α : Type u_1} {β : Type u_2} [decidable_eq β] (f : α → β) (s : finset α) : finset β",
    "args": "{α : Type u_1} {β : Type u_2} [decidable_eq β] (f : α → β) (s : finset α)",
    "doc_string": "`image f s` is the forward image of `s` under `f`.",
    "kind": "def",
    "type": "finset β"
  },
  {
    "name": "order.pfilter.order_top",
    "statement": "def order.pfilter.order_top {P : Type u_1} [preorder P] [order_bot P] : order_top (order.pfilter P)",
    "theorem": "{P : Type u_1} [preorder P] [order_bot P] : order_top (order.pfilter P)",
    "args": "{P : Type u_1} [preorder P] [order_bot P]",
    "doc_string": "There is a top filter when `P` has a bottom element.",
    "kind": "def",
    "type": "order_top (order.pfilter P)"
  },
  {
    "name": "ring.perfection",
    "statement": "def ring.perfection (R : Type u₁) [comm_semiring R] (p : ℕ) : Type u₁",
    "theorem": "(R : Type u₁) [comm_semiring R] (p : ℕ) : Type u₁",
    "args": "(R : Type u₁) [comm_semiring R] (p : ℕ)",
    "doc_string": " The perfection of a ring `R` with characteristic `p`, defined to be the projective limit of `R` using the Frobenius maps `R → R` indexed by the natural numbers, implemented as `{f : ℕ → R // ∀ n, f (n + 1) ^ p = f n}`.",
    "kind": "def",
    "type": "Type u₁"
  },
  {
    "name": "generalized_continued_fraction.pair.has_repr",
    "statement": "def generalized_continued_fraction.pair.has_repr {α : Type u_1} [has_repr α] : has_repr (generalized_continued_fraction.pair α)",
    "theorem": "{α : Type u_1} [has_repr α] : has_repr (generalized_continued_fraction.pair α)",
    "args": "{α : Type u_1} [has_repr α]",
    "doc_string": "Make a `gcf.pair` printable.",
    "kind": "def",
    "type": "has_repr (generalized_continued_fraction.pair α)"
  },
  {
    "name": "is_invariant_subring",
    "statement": "structure is_invariant_subring (M : Type u) [monoid M] {R : Type v} [ring R] [mul_semiring_action M R] (S : subring R) : Prop",
    "theorem": "(M : Type u) [monoid M] {R : Type v} [ring R] [mul_semiring_action M R] (S : subring R) : Prop",
    "args": "(M : Type u) [monoid M] {R : Type v} [ring R] [mul_semiring_action M R] (S : subring R)",
    "doc_string": "A typeclass for subrings invariant under a `mul_semiring_action`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "metric.uniform_continuous_inf_dist_pt",
    "statement": "theorem metric.uniform_continuous_inf_dist_pt {α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s)",
    "theorem": "{α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s)",
    "args": "{α : Type u} [pseudo_metric_space α] (s : set α)",
    "doc_string": "The minimal distance to a set is uniformly continuous in point",
    "kind": "theorem",
    "type": "uniform_continuous (λ (x : α), metric.inf_dist x s)"
  },
  {
    "name": "lazy_list.head",
    "statement": "def lazy_list.head {α : Type u} [inhabited α] : lazy_list α → α",
    "theorem": "{α : Type u} [inhabited α] : lazy_list α → α",
    "args": "{α : Type u} [inhabited α]",
    "doc_string": "Returns the first element of the lazy list, or `default` if the lazy list is empty.",
    "kind": "def",
    "type": "lazy_list α → α"
  },
  {
    "name": "finset.sort",
    "statement": "def finset.sort {α : Type u_1} (r : α → α → Prop) [decidable_rel r] [is_trans α r] [is_antisymm α r] [is_total α r] (s : finset α) : list α",
    "theorem": "{α : Type u_1} (r : α → α → Prop) [decidable_rel r] [is_trans α r] [is_antisymm α r] [is_total α r] (s : finset α) : list α",
    "args": "{α : Type u_1} (r : α → α → Prop) [decidable_rel r] [is_trans α r] [is_antisymm α r] [is_total α r] (s : finset α)",
    "doc_string": "`sort s` constructs a sorted list from the unordered set `s`.  (Uses merge sort algorithm.)",
    "kind": "def",
    "type": "list α"
  },
  {
    "name": "ordinal.principal_mul_iff_le_two_or_omega_opow_opow",
    "statement": "theorem ordinal.principal_mul_iff_le_two_or_omega_opow_opow {o : ordinal} : ordinal.principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a",
    "theorem": "{o : ordinal} : ordinal.principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a",
    "args": "{o : ordinal}",
    "doc_string": "The main characterization theorem for multiplicative principal ordinals.",
    "kind": "theorem",
    "type": "ordinal.principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a"
  },
  {
    "name": "uniform_space.completion.hat_inv",
    "statement": "def uniform_space.completion.hat_inv {K : Type u_1} [field K] [uniform_space K] : uniform_space.completion K → uniform_space.completion K",
    "theorem": "{K : Type u_1} [field K] [uniform_space K] : uniform_space.completion K → uniform_space.completion K",
    "args": "{K : Type u_1} [field K] [uniform_space K]",
    "doc_string": "extension of inversion to the completion of a field.",
    "kind": "def",
    "type": "uniform_space.completion K → uniform_space.completion K"
  },
  {
    "name": "subring.closure",
    "statement": "def subring.closure {R : Type u} [ring R] (s : set R) : subring R",
    "theorem": "{R : Type u} [ring R] (s : set R) : subring R",
    "args": "{R : Type u} [ring R] (s : set R)",
    "doc_string": "The `subring` generated by a set.",
    "kind": "def",
    "type": "subring R"
  },
  {
    "name": "inf_hom_class",
    "statement": "structure inf_hom_class (F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_inf α] [has_inf β] : Type (max u_7 u_8 u_9)",
    "theorem": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_inf α] [has_inf β] : Type (max u_7 u_8 u_9)",
    "args": "(F : Type u_7) (α : out_param (Type u_8)) (β : out_param (Type u_9)) [has_inf α] [has_inf β]",
    "doc_string": " `inf_hom_class F α β` states that `F` is a type of `⊓`-preserving morphisms.  You should extend this class when you extend `inf_hom`.",
    "kind": "structure",
    "type": "Type (max u_7 u_8 u_9)"
  },
  {
    "name": "free_algebra",
    "statement": "def free_algebra (R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(R : Type u_1) [comm_semiring R] (X : Type u_2) : Type (max u_1 u_2)",
    "args": "(R : Type u_1) [comm_semiring R] (X : Type u_2)",
    "doc_string": "The free algebra for the type `X` over the commutative semiring `R`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "function.semiconj.maps_to_fixed_pts",
    "statement": "theorem function.semiconj.maps_to_fixed_pts {α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {g : α → β} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)",
    "theorem": "{α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {g : α → β} (h : function.semiconj g fa fb) : set.maps_to g (function.fixed_points fa) (function.fixed_points fb)",
    "args": "{α : Type u} {β : Type v} {fa : α → α} {fb : β → β} {g : α → β} (h : function.semiconj g fa fb)",
    "doc_string": " If `g` semiconjugates `fa` to `fb`, then it sends fixed points of `fa` to fixed points of `fb`.",
    "kind": "theorem",
    "type": "set.maps_to g (function.fixed_points fa) (function.fixed_points fb)"
  },
  {
    "name": "discrete_valuation_ring.exists_irreducible",
    "statement": "theorem discrete_valuation_ring.exists_irreducible (R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), irreducible ϖ",
    "theorem": "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), irreducible ϖ",
    "args": "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R]",
    "doc_string": "Uniformisers exist in a DVR",
    "kind": "theorem",
    "type": "∃ (ϖ : R), irreducible ϖ"
  },
  {
    "name": "complex_shape.down",
    "statement": "def complex_shape.down (α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : complex_shape α",
    "theorem": "(α : Type u_1) [add_right_cancel_semigroup α] [has_one α] : complex_shape α",
    "args": "(α : Type u_1) [add_right_cancel_semigroup α] [has_one α]",
    "doc_string": "The `complex_shape` appropriate for homology, so `d : X i ⟶ X j` only when `i = j + 1`.",
    "kind": "def",
    "type": "complex_shape α"
  },
  {
    "name": "is_linear_map",
    "statement": "structure is_linear_map (R : Type u) {M : Type v} {M₂ : Type w} [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] (f : M → M₂) : Prop",
    "theorem": "(R : Type u) {M : Type v} {M₂ : Type w} [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] (f : M → M₂) : Prop",
    "args": "(R : Type u) {M : Type v} {M₂ : Type w} [semiring R] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R M₂] (f : M → M₂)",
    "doc_string": " A map `f` between modules over a semiring is linear if it satisfies the two properties `f (x + y) = f x + f y` and `f (c • x) = c • f x`. The predicate `is_linear_map R f` asserts this property. A bundled version is available with `linear_map`, and should be favored over `is_linear_map` most of the time.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nilradical",
    "statement": "def nilradical (R : Type u_1) [comm_semiring R] : ideal R",
    "theorem": "(R : Type u_1) [comm_semiring R] : ideal R",
    "args": "(R : Type u_1) [comm_semiring R]",
    "doc_string": "The nilradical of a commutative semiring is the ideal of nilpotent elements.",
    "kind": "def",
    "type": "ideal R"
  },
  {
    "name": "right.one_le_mul",
    "statement": "theorem right.one_le_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_le_mul`.",
    "kind": "theorem",
    "type": "1 ≤ a * b"
  },
  {
    "name": "inv_le_of_inv_le'",
    "statement": "theorem inv_le_of_inv_le' {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} : a⁻¹ ≤ b → b⁻¹ ≤ a",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} : a⁻¹ ≤ b → b⁻¹ ≤ a",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the forward direction of inv_le'`.",
    "kind": "theorem",
    "type": "a⁻¹ ≤ b → b⁻¹ ≤ a"
  },
  {
    "name": "locally_bounded_map_class",
    "statement": "structure locally_bounded_map_class (F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [bornology α] [bornology β] : Type (max u_6 u_7 u_8)",
    "theorem": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [bornology α] [bornology β] : Type (max u_6 u_7 u_8)",
    "args": "(F : Type u_6) (α : out_param (Type u_7)) (β : out_param (Type u_8)) [bornology α] [bornology β]",
    "doc_string": " `locally_bounded_map_class F α β` states that `F` is a type of bounded maps.  You should extend this class when you extend `locally_bounded_map`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7 u_8)"
  },
  {
    "name": "ray_vector.has_neg",
    "statement": "def ray_vector.has_neg {M : Type u_2} [add_comm_group M] {R : Type u_1} : has_neg (ray_vector R M)",
    "theorem": "{M : Type u_2} [add_comm_group M] {R : Type u_1} : has_neg (ray_vector R M)",
    "args": "{M : Type u_2} [add_comm_group M] {R : Type u_1}",
    "doc_string": "Negating a nonzero vector.",
    "kind": "def",
    "type": "has_neg (ray_vector R M)"
  },
  {
    "name": "computability.unary_encode_nat",
    "statement": "def computability.unary_encode_nat  : ℕ → list bool",
    "theorem": " : ℕ → list bool",
    "args": "",
    "doc_string": "A unary encoding function of ℕ in bool.",
    "kind": "def",
    "type": "ℕ → list bool"
  },
  {
    "name": "zero_lt.left.mul_le_one_of_le_of_le",
    "statement": "theorem zero_lt.left.mul_le_one_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a) : a * b ≤ 1",
    "theorem": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a) : a * b ≤ 1",
    "args": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "a * b ≤ 1"
  },
  {
    "name": "is_dedekind_domain.height_one_spectrum",
    "statement": "structure is_dedekind_domain.height_one_spectrum (R : Type u_1) [comm_ring R] [is_domain R] [is_dedekind_domain R] : Type u_1",
    "theorem": "(R : Type u_1) [comm_ring R] [is_domain R] [is_dedekind_domain R] : Type u_1",
    "args": "(R : Type u_1) [comm_ring R] [is_domain R] [is_dedekind_domain R]",
    "doc_string": " The height one prime spectrum of a Dedekind domain `R` is the type of nonzero prime ideals of `R`. Note that this equals the maximal spectrum if `R` has Krull dimension 1.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "graded_monoid",
    "statement": "def graded_monoid {ι : Type u_1} (A : ι → Type u_2) : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} (A : ι → Type u_2) : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} (A : ι → Type u_2)",
    "doc_string": "A type alias of sigma types for graded monoids.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "list.map_with_prefix_suffix_aux",
    "statement": "def list.map_with_prefix_suffix_aux {α : Type u_1} {β : Type u_2} (f : list α → α → list α → β) : list α → list α → list β",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : list α → α → list α → β) : list α → list α → list β",
    "args": "{α : Type u_1} {β : Type u_2} (f : list α → α → list α → β)",
    "doc_string": "An auxiliary function for `list.map_with_prefix_suffix`.",
    "kind": "def",
    "type": "list α → list α → list β"
  },
  {
    "name": "linear_ordered_add_comm_monoid",
    "statement": "structure linear_ordered_add_comm_monoid (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A linearly ordered additive commutative monoid.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "dfinsupp",
    "statement": "def dfinsupp {ι : Type u} (β : ι → Type v) [Π (i : ι), has_zero (β i)] : Type (max u v)",
    "theorem": "{ι : Type u} (β : ι → Type v) [Π (i : ι), has_zero (β i)] : Type (max u v)",
    "args": "{ι : Type u} (β : ι → Type v) [Π (i : ι), has_zero (β i)]",
    "doc_string": "A dependent function `Π i, β i` with finite support.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "tactic.itauto.fresh_name",
    "statement": "def tactic.itauto.fresh_name  : ℕ → name × ℕ",
    "theorem": " : ℕ → name × ℕ",
    "args": "",
    "doc_string": "Get a new name in the pattern `h0, h1, h2, ...`",
    "kind": "def",
    "type": "ℕ → name × ℕ"
  },
  {
    "name": "category_theory.enough_projectives",
    "statement": "structure category_theory.enough_projectives (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category \"has enough projectives\" if for every object `X` there is a projective object `P` and    an epimorphism `P ↠ X`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "list.is_rotated",
    "statement": "def list.is_rotated {α : Type u} (l l' : list α) : Prop",
    "theorem": "{α : Type u} (l l' : list α) : Prop",
    "args": "{α : Type u} (l l' : list α)",
    "doc_string": "`is_rotated l₁ l₂` or `l₁ ~r l₂` asserts that `l₁` and `l₂` are cyclic permutations  of each other. This is defined by claiming that `∃ n, l.rotate n = l'`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "clifford_algebra.even_odd",
    "statement": "def clifford_algebra.even_odd {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (i : zmod 2) : submodule R (clifford_algebra Q)",
    "theorem": "{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (i : zmod 2) : submodule R (clifford_algebra Q)",
    "args": "{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (i : zmod 2)",
    "doc_string": " The even or odd submodule, defined as the supremum of the even or odd powers of `(ι Q).range`. `even_odd 0` is the even submodule, and `even_odd 1` is the odd submodule.",
    "kind": "def",
    "type": "submodule R (clifford_algebra Q)"
  },
  {
    "name": "free_magma.traverse",
    "statement": "def free_magma.traverse {m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) : free_magma α → m (free_magma β)",
    "theorem": "{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) : free_magma α → m (free_magma β)",
    "args": "{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β)",
    "doc_string": "`free_magma` is traversable.",
    "kind": "def",
    "type": "free_magma α → m (free_magma β)"
  },
  {
    "name": "list.argmin",
    "statement": "def list.argmin {α : Type u_1} {β : Type u_2} [preorder β] [decidable_rel has_lt.lt] (f : α → β) (l : list α) : option α",
    "theorem": "{α : Type u_1} {β : Type u_2} [preorder β] [decidable_rel has_lt.lt] (f : α → β) (l : list α) : option α",
    "args": "{α : Type u_1} {β : Type u_2} [preorder β] [decidable_rel has_lt.lt] (f : α → β) (l : list α)",
    "doc_string": " `argmin f l` returns `some a`, where `f a` is minimal among the elements of `l`, in the sense that there is no `b ∈ l` with `f b < f a`. If `a`, `b` are such that `f a = f b`, it returns whichever of `a` or `b` comes first in the list. `argmin f []` = none`.",
    "kind": "def",
    "type": "option α"
  },
  {
    "name": "rel.interedges",
    "statement": "def rel.interedges {α : Type u_3} {β : Type u_4} (r : α → β → Prop) [Π (a : α), decidable_pred (r a)] (s : finset α) (t : finset β) : finset (α × β)",
    "theorem": "{α : Type u_3} {β : Type u_4} (r : α → β → Prop) [Π (a : α), decidable_pred (r a)] (s : finset α) (t : finset β) : finset (α × β)",
    "args": "{α : Type u_3} {β : Type u_4} (r : α → β → Prop) [Π (a : α), decidable_pred (r a)] (s : finset α) (t : finset β)",
    "doc_string": "Finset of edges of a relation between two finsets of vertices.",
    "kind": "def",
    "type": "finset (α × β)"
  },
  {
    "name": "enorm.finite_subspace",
    "statement": "def enorm.finite_subspace {𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] (e : enorm 𝕜 V) : subspace 𝕜 V",
    "theorem": "{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] (e : enorm 𝕜 V) : subspace 𝕜 V",
    "args": "{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] (e : enorm 𝕜 V)",
    "doc_string": "The subspace of vectors with finite enorm.",
    "kind": "def",
    "type": "subspace 𝕜 V"
  },
  {
    "name": "category_theory.idempotents.karoubi.category_theory.preadditive",
    "statement": "def category_theory.idempotents.karoubi.category_theory.preadditive {C : Type u_1} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive (category_theory.idempotents.karoubi C)",
    "theorem": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C] : category_theory.preadditive (category_theory.idempotents.karoubi C)",
    "args": "{C : Type u_1} [category_theory.category C] [category_theory.preadditive C]",
    "doc_string": "The category `karoubi C` is preadditive if `C` is.",
    "kind": "def",
    "type": "category_theory.preadditive (category_theory.idempotents.karoubi C)"
  },
  {
    "name": "simple_graph.partition",
    "statement": "structure simple_graph.partition {V : Type u} (G : simple_graph V) : Type u",
    "theorem": "{V : Type u} (G : simple_graph V) : Type u",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": "A `partition` of a simple graph `G` is a structure constituted by * `parts`: a set of subsets of the vertices `V` of `G` * `is_partition`: a proof that `parts` is a proper partition of `V` * `independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "mul_salem_spencer",
    "statement": "def mul_salem_spencer {α : Type u_2} [monoid α] (s : set α) : Prop",
    "theorem": "{α : Type u_2} [monoid α] (s : set α) : Prop",
    "args": "{α : Type u_2} [monoid α] (s : set α)",
    "doc_string": " A multiplicative Salem-Spencer, aka non averaging, set `s` in a monoid is a set such that the multiplicative average of any two distinct elements is not in the set.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "UniformSpace.of",
    "statement": "def UniformSpace.of (α : Type u) [uniform_space α] : UniformSpace",
    "theorem": "(α : Type u) [uniform_space α] : UniformSpace",
    "args": "(α : Type u) [uniform_space α]",
    "doc_string": "Construct a bundled `UniformSpace` from the underlying type and the typeclass.",
    "kind": "def",
    "type": "UniformSpace"
  },
  {
    "name": "dlist.append",
    "statement": "def dlist.append {α : Type u} : dlist α → dlist α → dlist α",
    "theorem": "{α : Type u} : dlist α → dlist α → dlist α",
    "args": "{α : Type u}",
    "doc_string": "`O(1)` Append dlists",
    "kind": "def",
    "type": "dlist α → dlist α → dlist α"
  },
  {
    "name": "add_group_is_add_torsor",
    "statement": "def add_group_is_add_torsor (G : Type u_1) [add_group G] : add_torsor G G",
    "theorem": "(G : Type u_1) [add_group G] : add_torsor G G",
    "args": "(G : Type u_1) [add_group G]",
    "doc_string": "An `add_group G` is a torsor for itself.",
    "kind": "def",
    "type": "add_torsor G G"
  },
  {
    "name": "vector.map_id",
    "statement": "theorem vector.map_id {α : Type u_1} {n : ℕ} (v : vector α n) : vector.map id v = v",
    "theorem": "{α : Type u_1} {n : ℕ} (v : vector α n) : vector.map id v = v",
    "args": "{α : Type u_1} {n : ℕ} (v : vector α n)",
    "doc_string": "Mapping under `id` does not change a vector.",
    "kind": "theorem",
    "type": "vector.map id v = v"
  },
  {
    "name": "nat.prod_dvd_and_dvd_of_dvd_prod",
    "statement": "def nat.prod_dvd_and_dvd_of_dvd_prod {m n k : ℕ} (H : k ∣ m * n) : {d // k = ↑(d.fst) * ↑(d.snd)}",
    "theorem": "{m n k : ℕ} (H : k ∣ m * n) : {d // k = ↑(d.fst) * ↑(d.snd)}",
    "args": "{m n k : ℕ} (H : k ∣ m * n)",
    "doc_string": "Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`.",
    "kind": "def",
    "type": "{d // k = ↑(d.fst) * ↑(d.snd)}"
  },
  {
    "name": "finset.functor",
    "statement": "def finset.functor [Π (P : Prop), decidable P] : functor finset",
    "theorem": "[Π (P : Prop), decidable P] : functor finset",
    "args": "[Π (P : Prop), decidable P]",
    "doc_string": " Because `finset.image` requires a `decidable_eq` instance for the target type, we can only construct `functor finset` when working classically.",
    "kind": "def",
    "type": "functor finset"
  },
  {
    "name": "monoid.End",
    "statement": "def monoid.End (M : Type u_3) [mul_one_class M] : Type u_3",
    "theorem": "(M : Type u_3) [mul_one_class M] : Type u_3",
    "args": "(M : Type u_3) [mul_one_class M]",
    "doc_string": "The monoid of endomorphisms.",
    "kind": "def",
    "type": "Type u_3"
  },
  {
    "name": "comm_ring_strong_rank_condition",
    "statement": "def comm_ring_strong_rank_condition (R : Type u_1) [comm_ring R] [nontrivial R] : strong_rank_condition R",
    "theorem": "(R : Type u_1) [comm_ring R] [nontrivial R] : strong_rank_condition R",
    "args": "(R : Type u_1) [comm_ring R] [nontrivial R]",
    "doc_string": "Any commutative ring satisfies the `strong_rank_condition`.",
    "kind": "def",
    "type": "strong_rank_condition R"
  },
  {
    "name": "is_trivial_topological_fiber_bundle",
    "statement": "def is_trivial_topological_fiber_bundle {B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B) : Prop",
    "theorem": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B) : Prop",
    "args": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] [topological_space Z] (proj : Z → B)",
    "doc_string": " A trivial topological fiber bundle with fiber `F` over a base `B` is a space `Z` projecting on `B` for which there exists a homeomorphism to `B × F` that sends `proj` to `prod.fst`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "coe_option",
    "statement": "def coe_option {a : Type u} : has_coe_t a (option a)",
    "theorem": "{a : Type u} : has_coe_t a (option a)",
    "args": "{a : Type u}",
    "doc_string": "We add this instance directly into `has_coe_t` to avoid non-termination.    Suppose coe_option had type `(has_coe a (option a))`.   Then, we can loop when searching a coercion from `α` to `β` `(has_coe_t α β)`   1- `coe_trans at (has_coe_t α β)`          `(has_coe α ?b₁) and (has_coe_t ?b₁ c)`   2- `coe_option at (has_coe α ?b₁)`          `?b₁ := option α`   3- `coe_trans at (has_coe_t (option α) β)`          `(has_coe (option α) ?b₂) and (has_coe_t ?b₂ β)`   4- `coe_option at (has_coe (option α) ?b₂)`          `?b₂ := option (option α))`   ...",
    "kind": "def",
    "type": "has_coe_t a (option a)"
  },
  {
    "name": "category_theory.single_obj.category",
    "statement": "def category_theory.single_obj.category (α : Type u) [monoid α] : category_theory.category (category_theory.single_obj α)",
    "theorem": "(α : Type u) [monoid α] : category_theory.category (category_theory.single_obj α)",
    "args": "(α : Type u) [monoid α]",
    "doc_string": "Monoid laws become category laws for the single object category.",
    "kind": "def",
    "type": "category_theory.category (category_theory.single_obj α)"
  },
  {
    "name": "subfield",
    "statement": "structure subfield (K : Type u) [field K] : Type u",
    "theorem": "(K : Type u) [field K] : Type u",
    "args": "(K : Type u) [field K]",
    "doc_string": "`subfield R` is the type of subfields of `R`. A subfield of `R` is a subset `s` that is a  multiplicative submonoid and an additive subgroup. Note in particular that it shares the  same 0 and 1 as R.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "is_submonoid.list_prod_mem",
    "statement": "theorem is_submonoid.list_prod_mem {M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s",
    "theorem": "{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s",
    "args": "{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M}",
    "doc_string": "The product of a list of elements of a submonoid is an element of the submonoid.",
    "kind": "theorem",
    "type": "(∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s"
  },
  {
    "name": "free_product.word",
    "statement": "structure free_product.word {ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)] : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} (M : ι → Type u_2) [Π (i : ι), monoid (M i)]",
    "doc_string": " The type of reduced words. A reduced word cannot contain a letter `1`, and no two adjacent letters can come from the same summand.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "is_min_on",
    "statement": "def is_min_on {α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder β] (f : α → β) (s : set α) (a : α)",
    "doc_string": "`is_min_on f s a` means that `f a ≤ f x` for all `x ∈ a`. Note that we do not assume `a ∈ s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.prod",
    "statement": "def category_theory.limits.prod {C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_product X Y] : C",
    "theorem": "{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_product X Y] : C",
    "args": "{C : Type u} [category_theory.category C] (X Y : C) [category_theory.limits.has_binary_product X Y]",
    "doc_string": "If we have a product of `X` and `Y`, we can access it using `prod X Y` or    `X ⨯ Y`.",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "is_group_hom.map_one",
    "statement": "theorem is_group_hom.map_one {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1",
    "theorem": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1",
    "args": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f)",
    "doc_string": "A group homomorphism sends 1 to 1.",
    "kind": "theorem",
    "type": "f 1 = 1"
  },
  {
    "name": "one_hom.id",
    "statement": "def one_hom.id (M : Type u_1) [has_one M] : one_hom M M",
    "theorem": "(M : Type u_1) [has_one M] : one_hom M M",
    "args": "(M : Type u_1) [has_one M]",
    "doc_string": "The identity map from a type with 1 to itself.",
    "kind": "def",
    "type": "one_hom M M"
  },
  {
    "name": "reader_t",
    "statement": "structure reader_t (ρ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)",
    "theorem": "(ρ : Type u) (m : Type u → Type v) (α : Type u) : Type (max u v)",
    "args": "(ρ : Type u) (m : Type u → Type v) (α : Type u)",
    "doc_string": "An implementation of [ReaderT](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT)",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "nonneg_of_neg_nonpos",
    "statement": "theorem nonneg_of_neg_nonpos {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 → 0 ≤ a",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 → 0 ≤ a",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.inv_le_one_iff`.",
    "kind": "theorem",
    "type": "-a ≤ 0 → 0 ≤ a"
  },
  {
    "name": "add_subgroup.list_sum_mem",
    "statement": "theorem add_subgroup.list_sum_mem {G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (∀ (x : G), x ∈ l → x ∈ K) → l.sum ∈ K",
    "theorem": "{G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G} : (∀ (x : G), x ∈ l → x ∈ K) → l.sum ∈ K",
    "args": "{G : Type u_1} [add_group G] (K : add_subgroup G) {l : list G}",
    "doc_string": "Sum of a list of elements in an `add_subgroup` is in the `add_subgroup`.",
    "kind": "theorem",
    "type": "(∀ (x : G), x ∈ l → x ∈ K) → l.sum ∈ K"
  },
  {
    "name": "monoid_with_zero",
    "statement": "structure monoid_with_zero (M₀ : Type u_4) : Type u_4",
    "theorem": "(M₀ : Type u_4) : Type u_4",
    "args": "(M₀ : Type u_4)",
    "doc_string": " A type `M₀` is a “monoid with zero” if it is a monoid with zero element, and `0` is left and right absorbing.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "encodable.decidable_range_encode",
    "statement": "def encodable.decidable_range_encode (α : Type u_1) [encodable α] : decidable_pred (λ (_x : ℕ), _x ∈ set.range encodable.encode)",
    "theorem": "(α : Type u_1) [encodable α] : decidable_pred (λ (_x : ℕ), _x ∈ set.range encodable.encode)",
    "args": "(α : Type u_1) [encodable α]",
    "doc_string": "The encoding function has decidable range.",
    "kind": "def",
    "type": "decidable_pred (λ (_x : ℕ), _x ∈ set.range encodable.encode)"
  },
  {
    "name": "ufm_of_gcd_of_wf_dvd_monoid",
    "statement": "theorem ufm_of_gcd_of_wf_dvd_monoid {α : Type u_1} [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [gcd_monoid α] : unique_factorization_monoid α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [gcd_monoid α] : unique_factorization_monoid α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [gcd_monoid α]",
    "doc_string": "Can't be an instance because it would cause a loop `ufm → wf_dvd_monoid → ufm → ...`.",
    "kind": "theorem",
    "type": "unique_factorization_monoid α"
  },
  {
    "name": "category_theory.essentially_small_iff",
    "statement": "theorem category_theory.essentially_small_iff (C : Type u) [category_theory.category C] : category_theory.essentially_small C ↔ small (category_theory.skeleton C) ∧ category_theory.locally_small C",
    "theorem": "(C : Type u) [category_theory.category C] : category_theory.essentially_small C ↔ small (category_theory.skeleton C) ∧ category_theory.locally_small C",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category is essentially small if and only if the underlying type of its skeleton (i.e. the \"set\" of isomorphism classes) is small, and it is locally small.",
    "kind": "theorem",
    "type": "category_theory.essentially_small C ↔ small (category_theory.skeleton C) ∧ category_theory.locally_small C"
  },
  {
    "name": "lattice_hom.comp",
    "statement": "def lattice_hom.comp {α : Type u_3} {β : Type u_4} {γ : Type u_5} [lattice α] [lattice β] [lattice γ] (f : lattice_hom β γ) (g : lattice_hom α β) : lattice_hom α γ",
    "theorem": "{α : Type u_3} {β : Type u_4} {γ : Type u_5} [lattice α] [lattice β] [lattice γ] (f : lattice_hom β γ) (g : lattice_hom α β) : lattice_hom α γ",
    "args": "{α : Type u_3} {β : Type u_4} {γ : Type u_5} [lattice α] [lattice β] [lattice γ] (f : lattice_hom β γ) (g : lattice_hom α β)",
    "doc_string": "Composition of `lattice_hom`s as a `lattice_hom`.",
    "kind": "def",
    "type": "lattice_hom α γ"
  },
  {
    "name": "joined_in",
    "statement": "def joined_in {X : Type u_1} [topological_space X] (F : set X) (x y : X) : Prop",
    "theorem": "{X : Type u_1} [topological_space X] (F : set X) (x y : X) : Prop",
    "args": "{X : Type u_1} [topological_space X] (F : set X) (x y : X)",
    "doc_string": " The relation \"being joined by a path in `F`\". Not quite an equivalence relation since it's not reflexive for points that do not belong to `F`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "lipschitz_on_with",
    "statement": "def lipschitz_on_with {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] (K : nnreal) (f : α → β) (s : set α)",
    "doc_string": " A function `f` is Lipschitz continuous with constant `K ≥ 0` on `s` if for all `x, y` in `s` we have `dist (f x) (f y) ≤ K * dist x y`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "affine.simplex",
    "statement": "structure affine.simplex (k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] (n : ℕ) : Type u_3",
    "theorem": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] (n : ℕ) : Type u_3",
    "args": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [ring k] [add_comm_group V] [module k V] [add_torsor V P] (n : ℕ)",
    "doc_string": " A `simplex k P n` is a collection of `n + 1` affinely independent points.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "list.zip_left",
    "statement": "def list.zip_left {α : Type u_1} {β : Type u_2} : list α → list β → list (α × option β)",
    "theorem": "{α : Type u_1} {β : Type u_2} : list α → list β → list (α × option β)",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": "Left-biased version of `list.zip`. `zip_left as bs` returns the list of pairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `bs` is shorter than `as`, the remaining `aᵢ` are paired with `none`.  ```lean zip_left [1, 2] ['a'] = [(1, some 'a'), (2, none)]  zip_left [1] ['a', 'b'] = [(1, some 'a')]  zip_left = map₂_left prod.mk ```",
    "kind": "def",
    "type": "list α → list β → list (α × option β)"
  },
  {
    "name": "category_theory.limits.is_zero.has_zero_morphisms",
    "statement": "def category_theory.limits.is_zero.has_zero_morphisms {C : Type u} [category_theory.category C] {O : C} (hO : category_theory.limits.is_zero O) : category_theory.limits.has_zero_morphisms C",
    "theorem": "{C : Type u} [category_theory.category C] {O : C} (hO : category_theory.limits.is_zero O) : category_theory.limits.has_zero_morphisms C",
    "args": "{C : Type u} [category_theory.category C] {O : C} (hO : category_theory.limits.is_zero O)",
    "doc_string": "A category with a zero object has zero morphisms.     It is rarely a good idea to use this. Many categories that have a zero object have zero    morphisms for some other reason, for example from additivity. Library code that uses    `zero_morphisms_of_zero_object` will then be incompatible with these categories because    the `has_zero_morphisms` instances will not be definitionally equal. For this reason library    code should generally ask for an instance of `has_zero_morphisms` separately, even if it already    asks for an instance of `has_zero_objects`.",
    "kind": "def",
    "type": "category_theory.limits.has_zero_morphisms C"
  },
  {
    "name": "hash_map",
    "statement": "structure hash_map (α : Type u) [decidable_eq α] (β : α → Type v) : Type (max u v)",
    "theorem": "(α : Type u) [decidable_eq α] (β : α → Type v) : Type (max u v)",
    "args": "(α : Type u) [decidable_eq α] (β : α → Type v)",
    "doc_string": "A hash map data structure, representing a finite key-value map  with key type `α` and value type `β` (which may depend on `α`).",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "lt_neg_add_of_add_lt",
    "statement": "theorem lt_neg_add_of_add_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < -a + c",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < -a + c",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of lt_inv_mul_iff_mul_lt`.",
    "kind": "theorem",
    "type": "a + b < c → b < -a + c"
  },
  {
    "name": "ring.perfection_subsemiring",
    "statement": "def ring.perfection_subsemiring (R : Type u₁) [comm_semiring R] (p : ℕ) [hp : fact (nat.prime p)] [char_p R p] : subsemiring (ℕ → R)",
    "theorem": "(R : Type u₁) [comm_semiring R] (p : ℕ) [hp : fact (nat.prime p)] [char_p R p] : subsemiring (ℕ → R)",
    "args": "(R : Type u₁) [comm_semiring R] (p : ℕ) [hp : fact (nat.prime p)] [char_p R p]",
    "doc_string": " The perfection of a ring `R` with characteristic `p`, as a subsemiring, defined to be the projective limit of `R` using the Frobenius maps `R → R` indexed by the natural numbers, implemented as `{ f : ℕ → R | ∀ n, f (n + 1) ^ p = f n }`.",
    "kind": "def",
    "type": "subsemiring (ℕ → R)"
  },
  {
    "name": "ordnode.find_le_aux",
    "statement": "def ordnode.find_le_aux {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → α → α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": "Auxiliary definition for `find_le`.",
    "kind": "def",
    "type": "ordnode α → α → α"
  },
  {
    "name": "topological_fiber_bundle.pretrivialization",
    "statement": "structure topological_fiber_bundle.pretrivialization {B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z → B) : Type (max u_2 u_3 u_4)",
    "theorem": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z → B) : Type (max u_2 u_3 u_4)",
    "args": "{B : Type u_2} (F : Type u_3) {Z : Type u_4} [topological_space B] [topological_space F] (proj : Z → B)",
    "doc_string": " This structure contains the information left for a local trivialization (which is implemented below as `trivialization F proj`) if the total space has not been given a topology, but we have a topology on both the fiber and the base space. Through the construction `topological_fiber_prebundle F proj` it will be possible to promote a `pretrivialization F proj` to a `trivialization F proj`.",
    "kind": "structure",
    "type": "Type (max u_2 u_3 u_4)"
  },
  {
    "name": "continuous_subsemiring",
    "statement": "def continuous_subsemiring (α : Type u_1) (R : Type u_2) [topological_space α] [topological_space R] [semiring R] [topological_semiring R] : subsemiring (α → R)",
    "theorem": "(α : Type u_1) (R : Type u_2) [topological_space α] [topological_space R] [semiring R] [topological_semiring R] : subsemiring (α → R)",
    "args": "(α : Type u_1) (R : Type u_2) [topological_space α] [topological_space R] [semiring R] [topological_semiring R]",
    "doc_string": "The subsemiring of continuous maps `α → β`.",
    "kind": "def",
    "type": "subsemiring (α → R)"
  },
  {
    "name": "mvqpf.sigma.P",
    "statement": "def mvqpf.sigma.P {n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] : mvpfunctor n",
    "theorem": "{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)] : mvpfunctor n",
    "args": "{n : ℕ} {A : Type u} (F : A → typevec n → Type u) [Π (α : A), mvfunctor (F α)] [Π (α : A), mvqpf (F α)]",
    "doc_string": "polynomial functor representation of a dependent sum",
    "kind": "def",
    "type": "mvpfunctor n"
  },
  {
    "name": "btw_cyclic",
    "statement": "theorem btw_cyclic {α : Type u_1} [circular_preorder α] {a b c : α} : has_btw.btw a b c ↔ has_btw.btw c a b",
    "theorem": "{α : Type u_1} [circular_preorder α] {a b c : α} : has_btw.btw a b c ↔ has_btw.btw c a b",
    "args": "{α : Type u_1} [circular_preorder α] {a b c : α}",
    "doc_string": " The order of the `↔` has been chosen so that `rw btw_cyclic` cycles to the right while `rw ←btw_cyclic` cycles to the left (thus following the prepended arrow).",
    "kind": "theorem",
    "type": "has_btw.btw a b c ↔ has_btw.btw c a b"
  },
  {
    "name": "dihedral_group.order_of_r_one",
    "statement": "theorem dihedral_group.order_of_r_one {n : ℕ} : order_of (dihedral_group.r 1) = n",
    "theorem": "{n : ℕ} : order_of (dihedral_group.r 1) = n",
    "args": "{n : ℕ}",
    "doc_string": "If `0 < n`, then `r 1` has order `n`.",
    "kind": "theorem",
    "type": "order_of (dihedral_group.r 1) = n"
  },
  {
    "name": "function.surjective.nontrivial",
    "statement": "theorem function.surjective.nontrivial {α : Type u_1} {β : Type u_2} [nontrivial β] {f : α → β} (hf : function.surjective f) : nontrivial α",
    "theorem": "{α : Type u_1} {β : Type u_2} [nontrivial β] {f : α → β} (hf : function.surjective f) : nontrivial α",
    "args": "{α : Type u_1} {β : Type u_2} [nontrivial β] {f : α → β} (hf : function.surjective f)",
    "doc_string": "Pullback a `nontrivial` instance along a surjective function.",
    "kind": "theorem",
    "type": "nontrivial α"
  },
  {
    "name": "dense.closure",
    "statement": "theorem dense.closure {α : Type u} [topological_space α] {s : set α} : dense s → dense (closure s)",
    "theorem": "{α : Type u} [topological_space α] {s : set α} : dense s → dense (closure s)",
    "args": "{α : Type u} [topological_space α] {s : set α}",
    "doc_string": "**Alias** of the reverse direction of dense_closure`.",
    "kind": "theorem",
    "type": "dense s → dense (closure s)"
  },
  {
    "name": "category_theory.prod",
    "statement": "def category_theory.prod (C : Type u₁) [category_theory.category C] (D : Type u₂) [category_theory.category D] : category_theory.category (C × D)",
    "theorem": "(C : Type u₁) [category_theory.category C] (D : Type u₂) [category_theory.category D] : category_theory.category (C × D)",
    "args": "(C : Type u₁) [category_theory.category C] (D : Type u₂) [category_theory.category D]",
    "doc_string": "`prod C D` gives the cartesian product of two categories.  See <https://stacks.math.columbia.edu/tag/001K>.",
    "kind": "def",
    "type": "category_theory.category (C × D)"
  },
  {
    "name": "finset.card_powerset",
    "statement": "theorem finset.card_powerset {α : Type u_1} (s : finset α) : s.powerset.card = 2 ^ s.card",
    "theorem": "{α : Type u_1} (s : finset α) : s.powerset.card = 2 ^ s.card",
    "args": "{α : Type u_1} (s : finset α)",
    "doc_string": "**Number of Subsets of a Set**",
    "kind": "theorem",
    "type": "s.powerset.card = 2 ^ s.card"
  },
  {
    "name": "bitvec.xor3",
    "statement": "def bitvec.xor3 (x y c : bool) : bool",
    "theorem": "(x y c : bool) : bool",
    "args": "(x y c : bool)",
    "doc_string": "`xor3 x y c` is `((x XOR y) XOR c)`.",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "is_unit.dvd",
    "statement": "theorem is_unit.dvd {α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a",
    "theorem": "{α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a",
    "args": "{α : Type u_1} [monoid α] {a u : α} (hu : is_unit u)",
    "doc_string": "Units of a monoid divide any element of the monoid.",
    "kind": "theorem",
    "type": "u ∣ a"
  },
  {
    "name": "eq_zero_of_same_ray_self_neg",
    "statement": "theorem eq_zero_of_same_ray_self_neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x))",
    "doc_string": "If a vector is in the same ray as its negation, that vector is zero.",
    "kind": "theorem",
    "type": "x = 0"
  },
  {
    "name": "filter.is_countable_basis",
    "statement": "structure filter.is_countable_basis {α : Type u_1} {ι : Type u_4} (p : ι → Prop) (s : ι → set α) : Prop",
    "theorem": "{α : Type u_1} {ι : Type u_4} (p : ι → Prop) (s : ι → set α) : Prop",
    "args": "{α : Type u_1} {ι : Type u_4} (p : ι → Prop) (s : ι → set α)",
    "doc_string": "`is_countable_basis p s` means the image of `s` bounded by `p` is a countable filter basis.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_product",
    "statement": "def category_theory.limits.has_product {β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Prop",
    "theorem": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Prop",
    "args": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C)",
    "doc_string": "An abbreviation for `has_limit (discrete.functor f)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "Profinite",
    "statement": "structure Profinite  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The type of profinite topological spaces.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "is_square_zero",
    "statement": "theorem is_square_zero (M : Type u_1) [monoid_with_zero M] : is_square 0",
    "theorem": "(M : Type u_1) [monoid_with_zero M] : is_square 0",
    "args": "(M : Type u_1) [monoid_with_zero M]",
    "doc_string": "`0` is always a square (in a monoid with zero).",
    "kind": "theorem",
    "type": "is_square 0"
  },
  {
    "name": "universal_enveloping_algebra.rel",
    "statement": "inductive universal_enveloping_algebra.rel (R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] : tensor_algebra R L → tensor_algebra R L → Prop",
    "theorem": "(R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] : tensor_algebra R L → tensor_algebra R L → Prop",
    "args": "(R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": " The quotient by the ideal generated by this relation is the universal enveloping algebra.  Note that we have avoided using the more natural expression: | lie_compat (x y : L) : rel (ιₜ ⁅x, y⁆) ⁅ιₜ x, ιₜ y⁆ so that our construction needs only the semiring structure of the tensor algebra.",
    "kind": "inductive",
    "type": "tensor_algebra R L → tensor_algebra R L → Prop"
  },
  {
    "name": "category_theory.is_subterminal_of_mono_terminal_from",
    "statement": "theorem category_theory.is_subterminal_of_mono_terminal_from {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)]",
    "doc_string": "If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_terminal_from`.",
    "kind": "theorem",
    "type": "category_theory.is_subterminal A"
  },
  {
    "name": "Set.insert",
    "statement": "def Set.insert  : Set → Set → Set",
    "theorem": " : Set → Set → Set",
    "args": "",
    "doc_string": "`insert x y` is the set `{x} ∪ y`",
    "kind": "def",
    "type": "Set → Set → Set"
  },
  {
    "name": "group.closure",
    "statement": "def group.closure {G : Type u_1} [group G] (s : set G) : set G",
    "theorem": "{G : Type u_1} [group G] (s : set G) : set G",
    "args": "{G : Type u_1} [group G] (s : set G)",
    "doc_string": "`group.closure s` is the subgroup generated by `s`, i.e. the smallest subgroup containg `s`.",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "finite_dimensional.finrank",
    "statement": "def finite_dimensional.finrank (R : Type u_1) (V : Type u_2) [semiring R] [add_comm_group V] [module R V] : ℕ",
    "theorem": "(R : Type u_1) (V : Type u_2) [semiring R] [add_comm_group V] [module R V] : ℕ",
    "args": "(R : Type u_1) (V : Type u_2) [semiring R] [add_comm_group V] [module R V]",
    "doc_string": " The rank of a module as a natural number.  Defined by convention to be `0` if the space has infinite rank.  For a vector space `V` over a field `K`, this is the same as the finite dimension of `V` over `K`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "free_semigroup.traverse",
    "statement": "def free_semigroup.traverse {m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) (x : free_semigroup α) : m (free_semigroup β)",
    "theorem": "{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) (x : free_semigroup α) : m (free_semigroup β)",
    "args": "{m : Type u → Type u} [applicative m] {α β : Type u} (F : α → m β) (x : free_semigroup α)",
    "doc_string": "`free_semigroup` is traversable.",
    "kind": "def",
    "type": "m (free_semigroup β)"
  },
  {
    "name": "metric_space.replace_bornology",
    "statement": "def metric_space.replace_bornology {α : Type u_1} [B : bornology α] (m : metric_space α) (H : ∀ (s : set α), bornology.is_bounded s ↔ bornology.is_bounded s) : metric_space α",
    "theorem": "{α : Type u_1} [B : bornology α] (m : metric_space α) (H : ∀ (s : set α), bornology.is_bounded s ↔ bornology.is_bounded s) : metric_space α",
    "args": "{α : Type u_1} [B : bornology α] (m : metric_space α) (H : ∀ (s : set α), bornology.is_bounded s ↔ bornology.is_bounded s)",
    "doc_string": " Build a new metric space from an old one where the bundled bornology structure is provably (but typically non-definitionaly) equal to some given bornology structure. See Note [forgetful inheritance].",
    "kind": "def",
    "type": "metric_space α"
  },
  {
    "name": "ordnode.split",
    "statement": "def ordnode.split {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α × ordnode α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → ordnode α × ordnode α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": " O(log n). Split the tree into those smaller than `x` and those greater than it. If an element equivalent to `x` is in the set, it is discarded.      split 2 {1, 2, 4} = ({1}, {4})     split 3 {1, 2, 4} = ({1, 2}, {4})     split 4 {1, 2, 4} = ({1, 2}, ∅)  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      split (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, ∅)     split (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, ∅)",
    "kind": "def",
    "type": "ordnode α → ordnode α × ordnode α"
  },
  {
    "name": "group.normal_closure.is_subgroup",
    "statement": "theorem group.normal_closure.is_subgroup {G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)",
    "theorem": "{G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)",
    "args": "{G : Type u_1} [group G] (s : set G)",
    "doc_string": "The normal closure of a set is a subgroup.",
    "kind": "theorem",
    "type": "is_subgroup (group.normal_closure s)"
  },
  {
    "name": "valuation_subring.value_group",
    "statement": "def valuation_subring.value_group {K : Type u_1} [field K] (A : valuation_subring K) : Type u_1",
    "theorem": "{K : Type u_1} [field K] (A : valuation_subring K) : Type u_1",
    "args": "{K : Type u_1} [field K] (A : valuation_subring K)",
    "doc_string": "The value group of the valuation associated to `A`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "slim_check.sampleable_functor",
    "statement": "structure slim_check.sampleable_functor (F : Type u → Type v) [functor F] : Type (max (u+1) v)",
    "theorem": "(F : Type u → Type v) [functor F] : Type (max (u+1) v)",
    "args": "(F : Type u → Type v) [functor F]",
    "doc_string": " `sampleable_functor F` makes it possible to create samples of and shrink `F α` given a sampling function and a shrinking function for arbitrary `α`",
    "kind": "structure",
    "type": "Type (max (u+1) v)"
  },
  {
    "name": "category_theory.limits.has_colimits_of_size",
    "statement": "structure category_theory.limits.has_colimits_of_size (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`C` has all colimits of size `v₁ u₁` (`has_colimits_of_size.{v₁ u₁} C`) if it has colimits of every shape `J : Type u₁` with `[category.{v₁} J]`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "list.to_rbmap",
    "statement": "def list.to_rbmap {α : Type u_1} : list α → rbmap ℕ α has_lt.lt",
    "theorem": "{α : Type u_1} : list α → rbmap ℕ α has_lt.lt",
    "args": "{α : Type u_1}",
    "doc_string": "`to_rbmap as` is the map that associates each index `i` of `as` with the corresponding element of `as`.  ```lean to_rbmap ['a', 'b', 'c'] = rbmap_of [(0, 'a'), (1, 'b'), (2, 'c')] ```",
    "kind": "def",
    "type": "list α → rbmap ℕ α has_lt.lt"
  },
  {
    "name": "linear_map.general_linear_group",
    "statement": "def linear_map.general_linear_group (R : Type u_1) (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] : Type u_9",
    "theorem": "(R : Type u_1) (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M] : Type u_9",
    "args": "(R : Type u_1) (M : Type u_9) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "The group of invertible linear maps from `M` to itself",
    "kind": "def",
    "type": "Type u_9"
  },
  {
    "name": "category_theory.limits.cofan",
    "statement": "def category_theory.limits.cofan {β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Type (max w u v)",
    "theorem": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) : Type (max w u v)",
    "args": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C)",
    "doc_string": "A cofan over `f : β → C` consists of a collection of maps from every `f b` to an object `P`.",
    "kind": "def",
    "type": "Type (max w u v)"
  },
  {
    "name": "list.modify_head",
    "statement": "def list.modify_head {α : Type u_1} (f : α → α) : list α → list α",
    "theorem": "{α : Type u_1} (f : α → α) : list α → list α",
    "args": "{α : Type u_1} (f : α → α)",
    "doc_string": "Apply `f` to the head of the list, if it exists.",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "wseq.find_indexes",
    "statement": "def wseq.find_indexes {α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α) : wseq ℕ",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α) : wseq ℕ",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p] (s : wseq α)",
    "doc_string": "Get the list of indexes of elements of `s` satisfying `p`",
    "kind": "def",
    "type": "wseq ℕ"
  },
  {
    "name": "nat.card",
    "statement": "def nat.card (α : Type u_1) : ℕ",
    "theorem": "(α : Type u_1) : ℕ",
    "args": "(α : Type u_1)",
    "doc_string": "`nat.card α` is the cardinality of `α` as a natural number.  If `α` is infinite, `nat.card α = 0`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "preirreducible_space",
    "statement": "structure preirreducible_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A preirreducible space is one where there is no non-trivial pair of disjoint opens.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "real.cos_pi_div_three",
    "statement": "theorem real.cos_pi_div_three  : real.cos (real.pi / 3) = 1 / 2",
    "theorem": " : real.cos (real.pi / 3) = 1 / 2",
    "args": "",
    "doc_string": "The cosine of `π / 3` is `1 / 2`.",
    "kind": "theorem",
    "type": "real.cos (real.pi / 3) = 1 / 2"
  },
  {
    "name": "list.sorted",
    "statement": "def list.sorted {α : Type u_1} (R : α → α → Prop) : list α → Prop",
    "theorem": "{α : Type u_1} (R : α → α → Prop) : list α → Prop",
    "args": "{α : Type u_1} (R : α → α → Prop)",
    "doc_string": "`sorted r l` is the same as `pairwise r l`, preferred in the case that `r`  is a `<` or `≤`-like relation (transitive and antisymmetric or asymmetric)",
    "kind": "def",
    "type": "list α → Prop"
  },
  {
    "name": "nat.pow_two_sub_pow_two",
    "statement": "theorem nat.pow_two_sub_pow_two (a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "theorem": "(a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b)",
    "args": "(a b : ℕ)",
    "doc_string": "**Alias** of nat.sq_sub_sq`.",
    "kind": "theorem",
    "type": "a ^ 2 - b ^ 2 = (a + b) * (a - b)"
  },
  {
    "name": "absurd",
    "statement": "def absurd {a : Prop} {b : Sort v} (h₁ : a) (h₂ : ¬a) : b",
    "theorem": "{a : Prop} {b : Sort v} (h₁ : a) (h₂ : ¬a) : b",
    "args": "{a : Prop} {b : Sort v} (h₁ : a) (h₂ : ¬a)",
    "doc_string": "We can't have `a` and `¬a`, that would be absurd!",
    "kind": "def",
    "type": "b"
  },
  {
    "name": "is_pi_system",
    "statement": "def is_pi_system {α : Type u_1} (C : set (set α)) : Prop",
    "theorem": "{α : Type u_1} (C : set (set α)) : Prop",
    "args": "{α : Type u_1} (C : set (set α))",
    "doc_string": "A π-system is a collection of subsets of `α` that is closed under binary intersection of  non-disjoint sets. Usually it is also required that the collection is nonempty, but we don't do  that here.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "snum.bit1",
    "statement": "def snum.bit1  : snum → snum",
    "theorem": " : snum → snum",
    "args": "",
    "doc_string": "Add an active bit at the end of a `snum`. This mimics `znum.bit1`.",
    "kind": "def",
    "type": "snum → snum"
  },
  {
    "name": "is_local_min_on",
    "statement": "def is_local_min_on {α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (s : set α) (a : α)",
    "doc_string": "`is_local_min_on f s a` means that `f a ≤ f x` for all `x ∈ s` in some neighborhood of `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "fundamental_group",
    "statement": "def fundamental_group (X : Type u) [topological_space X] (x : X) : Type u",
    "theorem": "(X : Type u) [topological_space X] (x : X) : Type u",
    "args": "(X : Type u) [topological_space X] (x : X)",
    "doc_string": " The fundamental group is the automorphism group (vertex group) of the basepoint in the fundamental groupoid.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "snum.head",
    "statement": "def snum.head  : snum → bool",
    "theorem": " : snum → bool",
    "args": "",
    "doc_string": "The `head` of a `snum` is the boolean value of its LSB.",
    "kind": "def",
    "type": "snum → bool"
  },
  {
    "name": "semiquot.univ",
    "statement": "def semiquot.univ {α : Type u_1} [inhabited α] : semiquot α",
    "theorem": "{α : Type u_1} [inhabited α] : semiquot α",
    "args": "{α : Type u_1} [inhabited α]",
    "doc_string": "`univ : semiquot α` represents an unspecified element of `univ : set α`.",
    "kind": "def",
    "type": "semiquot α"
  },
  {
    "name": "function.surjective.has_involutive_neg",
    "statement": "def function.surjective.has_involutive_neg {M₁ : Type u_1} {M₂ : Type u_2} [has_neg M₂] [has_involutive_neg M₁] (f : M₁ → M₂) (hf : function.surjective f) (inv : ∀ (x : M₁), f (-x) = -f x) : has_involutive_neg M₂",
    "theorem": "{M₁ : Type u_1} {M₂ : Type u_2} [has_neg M₂] [has_involutive_neg M₁] (f : M₁ → M₂) (hf : function.surjective f) (inv : ∀ (x : M₁), f (-x) = -f x) : has_involutive_neg M₂",
    "args": "{M₁ : Type u_1} {M₂ : Type u_2} [has_neg M₂] [has_involutive_neg M₁] (f : M₁ → M₂) (hf : function.surjective f) (inv : ∀ (x : M₁), f (-x) = -f x)",
    "doc_string": "A type has an involutive negation if it admits a surjective map that preserves `⁻¹` to a type which has an involutive inversion.",
    "kind": "def",
    "type": "has_involutive_neg M₂"
  },
  {
    "name": "category_theory.limits.has_pullbacks_of_has_binary_products_of_has_equalizers",
    "statement": "theorem category_theory.limits.has_pullbacks_of_has_binary_products_of_has_equalizers (C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C",
    "theorem": "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C",
    "args": "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C]",
    "doc_string": "If a category has all binary products and all equalizers, then it also has all pullbacks.    As usual, this is not an instance, since there may be a more direct way to construct    pullbacks.",
    "kind": "theorem",
    "type": "category_theory.limits.has_pullbacks C"
  },
  {
    "name": "loc_compact_Haus_tot_disc_of_zero_dim",
    "statement": "theorem loc_compact_Haus_tot_disc_of_zero_dim {H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}",
    "theorem": "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}",
    "args": "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H]",
    "doc_string": "A locally compact Hausdorff totally disconnected space has a basis with clopen elements.",
    "kind": "theorem",
    "type": "topological_space.is_topological_basis {s : set H | is_clopen s}"
  },
  {
    "name": "quiver.path.comp",
    "statement": "def quiver.path.comp {V : Type u} [quiver V] {a b c : V} : quiver.path a b → quiver.path b c → quiver.path a c",
    "theorem": "{V : Type u} [quiver V] {a b c : V} : quiver.path a b → quiver.path b c → quiver.path a c",
    "args": "{V : Type u} [quiver V] {a b c : V}",
    "doc_string": "Composition of paths.",
    "kind": "def",
    "type": "quiver.path a b → quiver.path b c → quiver.path a c"
  },
  {
    "name": "filter.coprod",
    "statement": "def filter.coprod {α : Type u} {β : Type v} (f : filter α) (g : filter β) : filter (α × β)",
    "theorem": "{α : Type u} {β : Type v} (f : filter α) (g : filter β) : filter (α × β)",
    "args": "{α : Type u} {β : Type v} (f : filter α) (g : filter β)",
    "doc_string": "Coproduct of filters.",
    "kind": "def",
    "type": "filter (α × β)"
  },
  {
    "name": "Mon.assoc_monoid_hom",
    "statement": "def Mon.assoc_monoid_hom (M : Type u_1) (N : Type u_2) [monoid M] [monoid N] : Type (max u_2 u_1)",
    "theorem": "(M : Type u_1) (N : Type u_2) [monoid M] [monoid N] : Type (max u_2 u_1)",
    "args": "(M : Type u_1) (N : Type u_2) [monoid M] [monoid N]",
    "doc_string": " `monoid_hom` doesn't actually assume associativity. This alias is needed to make the category theory machinery work.",
    "kind": "def",
    "type": "Type (max u_2 u_1)"
  },
  {
    "name": "category_theory.limits.has_limits_of_size_shrink",
    "statement": "theorem category_theory.limits.has_limits_of_size_shrink (C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C]",
    "doc_string": "`has_limits_of_size_shrink.{v u} C` tries to obtain `has_limits_of_size.{v u} C` from some other `has_limits_of_size C`.",
    "kind": "theorem",
    "type": "category_theory.limits.has_limits_of_size C"
  },
  {
    "name": "group_filter_basis.N",
    "statement": "def group_filter_basis.N {G : Type u} [group G] (B : group_filter_basis G) : G → filter G",
    "theorem": "{G : Type u} [group G] (B : group_filter_basis G) : G → filter G",
    "args": "{G : Type u} [group G] (B : group_filter_basis G)",
    "doc_string": "The neighborhood function of a `group_filter_basis`",
    "kind": "def",
    "type": "G → filter G"
  },
  {
    "name": "int.clog_zpow_gi",
    "statement": "def int.clog_zpow_gi (R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) : galois_insertion (λ (r : ↥(set.Ioi 0)), int.clog b ↑r) (λ (z : ℤ), ⟨↑b ^ z, _⟩)",
    "theorem": "(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) : galois_insertion (λ (r : ↥(set.Ioi 0)), int.clog b ↑r) (λ (z : ℤ), ⟨↑b ^ z, _⟩)",
    "args": "(R : Type u_1) [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b)",
    "doc_string": "Over suitable subtypes, `int.clog` and `zpow` form a galois insertion",
    "kind": "def",
    "type": "galois_insertion (λ (r : ↥(set.Ioi 0)), int.clog b ↑r) (λ (z : ℤ), ⟨↑b ^ z, _⟩)"
  },
  {
    "name": "category_theory.discrete_presieve",
    "statement": "def category_theory.discrete_presieve (α : Type u) : category_theory.presieve α",
    "theorem": "(α : Type u) : category_theory.presieve α",
    "args": "(α : Type u)",
    "doc_string": "The discrete presieve on a type, which only includes arrows whose domain is a singleton.",
    "kind": "def",
    "type": "category_theory.presieve α"
  },
  {
    "name": "spectral_map.comp",
    "statement": "def spectral_map.comp {α : Type u_2} {β : Type u_3} {γ : Type u_4} [topological_space α] [topological_space β] [topological_space γ] (f : spectral_map β γ) (g : spectral_map α β) : spectral_map α γ",
    "theorem": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [topological_space α] [topological_space β] [topological_space γ] (f : spectral_map β γ) (g : spectral_map α β) : spectral_map α γ",
    "args": "{α : Type u_2} {β : Type u_3} {γ : Type u_4} [topological_space α] [topological_space β] [topological_space γ] (f : spectral_map β γ) (g : spectral_map α β)",
    "doc_string": "Composition of `spectral_map`s as a `spectral_map`.",
    "kind": "def",
    "type": "spectral_map α γ"
  },
  {
    "name": "lt_tsub_iff_right",
    "statement": "theorem lt_tsub_iff_right {α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ a + c < b",
    "theorem": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ a + c < b",
    "args": "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α]",
    "doc_string": "See `lt_tsub_iff_right_of_le` for a weaker statement in a partial order.",
    "kind": "theorem",
    "type": "a < b - c ↔ a + c < b"
  },
  {
    "name": "fin_enum.pi.enum",
    "statement": "def fin_enum.pi.enum {α : Type u} (β : α → Type (max u v)) [fin_enum α] [Π (a : α), fin_enum (β a)] : list (Π (a : α), β a)",
    "theorem": "{α : Type u} (β : α → Type (max u v)) [fin_enum α] [Π (a : α), fin_enum (β a)] : list (Π (a : α), β a)",
    "args": "{α : Type u} (β : α → Type (max u v)) [fin_enum α] [Π (a : α), fin_enum (β a)]",
    "doc_string": "enumerate all functions whose domain and range are finitely enumerable",
    "kind": "def",
    "type": "list (Π (a : α), β a)"
  },
  {
    "name": "projection_data",
    "statement": "structure projection_data  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Projection data for a single projection of a structure, consisting of the following fields: - the name used in the generated `simp` lemmas - an expression used by simps for the projection. It must be definitionally equal to an original   projection (or a composition of multiple projections).   These expressions can contain the universe parameters specified in the first argument of   `simps_str_attr`. - a list of natural numbers, which is the projection number(s) that have to be applied to the   expression. For example the list `[0, 1]` corresponds to applying the first projection of the   structure, and then the second projection of the resulting structure (this assumes that the   target of the first projection is a structure with at least two projections).   The composition of these projections is required to be definitionally equal to the provided   expression. - A boolean specifying whether `simp` lemmas are generated for this projection by default. - A boolean specifying whether this projection is written as prefix.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "fixed_points.subfield",
    "statement": "def fixed_points.subfield (M : Type u) [monoid M] (F : Type v) [field F] [mul_semiring_action M F] : subfield F",
    "theorem": "(M : Type u) [monoid M] (F : Type v) [field F] [mul_semiring_action M F] : subfield F",
    "args": "(M : Type u) [monoid M] (F : Type v) [field F] [mul_semiring_action M F]",
    "doc_string": "The subfield of fixed points by a monoid action.",
    "kind": "def",
    "type": "subfield F"
  },
  {
    "name": "first_order.language.substructure",
    "statement": "structure first_order.language.substructure (L : first_order.language) (M : Type w) [L.Structure M] : Type w",
    "theorem": "(L : first_order.language) (M : Type w) [L.Structure M] : Type w",
    "args": "(L : first_order.language) (M : Type w) [L.Structure M]",
    "doc_string": "A substructure of a structure `M` is a set closed under application of function symbols.",
    "kind": "structure",
    "type": "Type w"
  },
  {
    "name": "add_valuation.supp",
    "statement": "def add_valuation.supp {R : Type u_2} {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [comm_ring R] (v : add_valuation R Γ₀) : ideal R",
    "theorem": "{R : Type u_2} {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [comm_ring R] (v : add_valuation R Γ₀) : ideal R",
    "args": "{R : Type u_2} {Γ₀ : Type u_3} [linear_ordered_add_comm_monoid_with_top Γ₀] [comm_ring R] (v : add_valuation R Γ₀)",
    "doc_string": "The support of an additive valuation `v : R → Γ₀` is the ideal of `R` where `v x = ⊤`",
    "kind": "def",
    "type": "ideal R"
  },
  {
    "name": "canonically_linear_ordered_add_monoid",
    "statement": "structure canonically_linear_ordered_add_monoid (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid    whose ordering is a linear order.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "has_monad_lift_t",
    "statement": "structure has_monad_lift_t (m : Type u → Type v) (n : Type u → Type w) : Type (max (u+1) v w)",
    "theorem": "(m : Type u → Type v) (n : Type u → Type w) : Type (max (u+1) v w)",
    "args": "(m : Type u → Type v) (n : Type u → Type w)",
    "doc_string": "The reflexive-transitive closure of `has_monad_lift`.    `monad_lift` is used to transitively lift monadic computations such as `state_t.get` or `state_t.put s`.    Corresponds to [MonadLift](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift).",
    "kind": "structure",
    "type": "Type (max (u+1) v w)"
  },
  {
    "name": "is_subring.subring",
    "statement": "def is_subring.subring {R : Type u} [ring R] {S : set R} (hs : is_subring S) : subring R",
    "theorem": "{R : Type u} [ring R] {S : set R} (hs : is_subring S) : subring R",
    "args": "{R : Type u} [ring R] {S : set R} (hs : is_subring S)",
    "doc_string": "Construct a `subring` from a set satisfying `is_subring`.",
    "kind": "def",
    "type": "subring R"
  },
  {
    "name": "category_theory.limits.is_zero",
    "statement": "structure category_theory.limits.is_zero {C : Type u} [category_theory.category C] (X : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (X : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (X : C)",
    "doc_string": " An object `X` in a category is a *zero object* if for every object `Y` there is a unique morphism `to : X → Y` and a unique morphism `from : Y → X`.  This is a characteristic predicate for `has_zero_object`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "local_equiv.trans",
    "statement": "def local_equiv.trans {α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : local_equiv α β) (e' : local_equiv β γ) : local_equiv α γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : local_equiv α β) (e' : local_equiv β γ) : local_equiv α γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : local_equiv α β) (e' : local_equiv β γ)",
    "doc_string": " Composing two local equivs, by restricting to the maximal domain where their composition is well defined.",
    "kind": "def",
    "type": "local_equiv α γ"
  },
  {
    "name": "opens.pretopology_to_grothendieck",
    "statement": "theorem opens.pretopology_to_grothendieck (T : Type u) [topological_space T] : category_theory.pretopology.to_grothendieck (topological_space.opens T) (opens.pretopology T) = opens.grothendieck_topology T",
    "theorem": "(T : Type u) [topological_space T] : category_theory.pretopology.to_grothendieck (topological_space.opens T) (opens.pretopology T) = opens.grothendieck_topology T",
    "args": "(T : Type u) [topological_space T]",
    "doc_string": "The pretopology associated to a space induces the Grothendieck topology associated to the space.",
    "kind": "theorem",
    "type": "category_theory.pretopology.to_grothendieck (topological_space.opens T) (opens.pretopology T) = opens.grothendieck_topology T"
  },
  {
    "name": "equiv",
    "statement": "structure equiv (α : Sort u_1) (β : Sort u_2) : Sort (max 1 (imax u_1 u_2) (imax u_2 u_1))",
    "theorem": "(α : Sort u_1) (β : Sort u_2) : Sort (max 1 (imax u_1 u_2) (imax u_2 u_1))",
    "args": "(α : Sort u_1) (β : Sort u_2)",
    "doc_string": "`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.",
    "kind": "structure",
    "type": "Sort (max 1 (imax u_1 u_2) (imax u_2 u_1))"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.has_repr",
    "statement": "def generalized_continued_fraction.int_fract_pair.has_repr {K : Type u_1} [has_repr K] : has_repr (generalized_continued_fraction.int_fract_pair K)",
    "theorem": "{K : Type u_1} [has_repr K] : has_repr (generalized_continued_fraction.int_fract_pair K)",
    "args": "{K : Type u_1} [has_repr K]",
    "doc_string": "Make an `int_fract_pair` printable.",
    "kind": "def",
    "type": "has_repr (generalized_continued_fraction.int_fract_pair K)"
  },
  {
    "name": "lie_algebra.special_linear.sl",
    "statement": "def lie_algebra.special_linear.sl (n : Type u_1) (R : Type u₂) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)",
    "theorem": "(n : Type u_1) (R : Type u₂) [decidable_eq n] [comm_ring R] [fintype n] : lie_subalgebra R (matrix n n R)",
    "args": "(n : Type u_1) (R : Type u₂) [decidable_eq n] [comm_ring R] [fintype n]",
    "doc_string": "The special linear Lie algebra: square matrices of trace zero.",
    "kind": "def",
    "type": "lie_subalgebra R (matrix n n R)"
  },
  {
    "name": "category_theory.pretopology.trivial",
    "statement": "def category_theory.pretopology.trivial (C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : category_theory.pretopology C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] : category_theory.pretopology C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C]",
    "doc_string": "The trivial pretopology, in which the coverings are exactly singleton isomorphisms. This topology is also known as the indiscrete, coarse, or chaotic topology.  See <https://stacks.math.columbia.edu/tag/07GE>",
    "kind": "def",
    "type": "category_theory.pretopology C"
  },
  {
    "name": "measure_theory.simple_func.ennreal_rat_embed",
    "statement": "def measure_theory.simple_func.ennreal_rat_embed (n : ℕ) : ennreal",
    "theorem": "(n : ℕ) : ennreal",
    "args": "(n : ℕ)",
    "doc_string": "A sequence of `ℝ≥0∞`s such that its range is the set of non-negative rational numbers.",
    "kind": "def",
    "type": "ennreal"
  },
  {
    "name": "order_add_monoid_hom",
    "statement": "structure order_add_monoid_hom (α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [add_zero_class α] [add_zero_class β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [add_zero_class α] [add_zero_class β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [preorder α] [preorder β] [add_zero_class α] [add_zero_class β]",
    "doc_string": " `α →+o β` is the type of monotone functions `α → β` that preserve the `ordered_add_comm_monoid` structure.  `order_add_monoid_hom` is also used for ordered group homomorphisms.  When possible, instead of parametrizing results over `(f : α →+o β)`, you should parametrize over `(F : Type*) [order_add_monoid_hom_class F α β] (f : F)`.  When you extend this structure, make sure to extend `order_add_monoid_hom_class`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "num.shiftr",
    "statement": "def num.shiftr  : num → ℕ → num",
    "theorem": " : num → ℕ → num",
    "args": "",
    "doc_string": "Right-shift the binary representation of a `pos_num`.",
    "kind": "def",
    "type": "num → ℕ → num"
  },
  {
    "name": "function.surjective.unique_of_surjective_const",
    "statement": "def function.surjective.unique_of_surjective_const (α : Type u_1) {β : Type u_2} (b : β) (h : function.surjective (function.const α b)) : unique β",
    "theorem": "(α : Type u_1) {β : Type u_2} (b : β) (h : function.surjective (function.const α b)) : unique β",
    "args": "(α : Type u_1) {β : Type u_2} (b : β) (h : function.surjective (function.const α b))",
    "doc_string": "If a constant function is surjective, then the codomain is a singleton.",
    "kind": "def",
    "type": "unique β"
  },
  {
    "name": "pfunctor.obj",
    "statement": "def pfunctor.obj (P : pfunctor) (α : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(P : pfunctor) (α : Type u_2) : Type (max u_1 u_2)",
    "args": "(P : pfunctor) (α : Type u_2)",
    "doc_string": "Applying `P` to an object of `Type`",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "finite_dimensional.fact_finite_dimensional_of_finrank_eq_succ",
    "statement": "theorem finite_dimensional.fact_finite_dimensional_of_finrank_eq_succ {K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ℕ) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V",
    "theorem": "{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ℕ) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V",
    "args": "{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ℕ) [fact (finite_dimensional.finrank K V = n + 1)]",
    "doc_string": " We can infer `finite_dimensional K V` in the presence of `[fact (finrank K V = n + 1)]`. Declare this as a local instance where needed.",
    "kind": "theorem",
    "type": "finite_dimensional K V"
  },
  {
    "name": "has_lt.lt.le",
    "statement": "theorem has_lt.lt.le {α : Type u} [preorder α] {a b : α} : a < b → a ≤ b",
    "theorem": "{α : Type u} [preorder α] {a b : α} : a < b → a ≤ b",
    "args": "{α : Type u} [preorder α] {a b : α}",
    "doc_string": "**Alias** of le_of_lt`.",
    "kind": "theorem",
    "type": "a < b → a ≤ b"
  },
  {
    "name": "filter.has_div",
    "statement": "def filter.has_div {α : Type u_2} [has_div α] : has_div (filter α)",
    "theorem": "{α : Type u_2} [has_div α] : has_div (filter α)",
    "args": "{α : Type u_2} [has_div α]",
    "doc_string": "The filter `f / g` is generated by `{s / t | s ∈ f, t ∈ g}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_div (filter α)"
  },
  {
    "name": "complete_lattice.omega_complete_partial_order",
    "statement": "def complete_lattice.omega_complete_partial_order (α : Type u) [complete_lattice α] : omega_complete_partial_order α",
    "theorem": "(α : Type u) [complete_lattice α] : omega_complete_partial_order α",
    "args": "(α : Type u) [complete_lattice α]",
    "doc_string": " Any complete lattice has an `ω`-CPO structure where the countable supremum is a special case of arbitrary suprema.",
    "kind": "def",
    "type": "omega_complete_partial_order α"
  },
  {
    "name": "tactic.suggest.suggest_opt",
    "statement": "structure tactic.suggest.suggest_opt  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " An extension to the option structure for `solve_by_elim`. * `compulsory_hyps` specifies a list of local hypotheses which must appear in any solution.   These are useful for constraining the results from `library_search` and `suggest`. * `try_this` is a flag (default: `tt`) that controls whether a \"Try this:\"-line should be traced.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "connected_space",
    "statement": "structure connected_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A connected space is a nonempty one where there is no non-trivial open partition.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordinal.brange",
    "statement": "def ordinal.brange {α : Type u_1} (o : ordinal) (f : Π (a : ordinal), a < o → α) : set α",
    "theorem": "{α : Type u_1} (o : ordinal) (f : Π (a : ordinal), a < o → α) : set α",
    "args": "{α : Type u_1} (o : ordinal) (f : Π (a : ordinal), a < o → α)",
    "doc_string": "The range of a family indexed by ordinals.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "topological_space.mk_of_nhds",
    "statement": "def topological_space.mk_of_nhds {α : Type u} (n : α → filter α) : topological_space α",
    "theorem": "{α : Type u} (n : α → filter α) : topological_space α",
    "args": "{α : Type u} (n : α → filter α)",
    "doc_string": "Construct a topology on α given the filter of neighborhoods of each point of α.",
    "kind": "def",
    "type": "topological_space α"
  },
  {
    "name": "is_add_regular_of_cancel_add_monoid",
    "statement": "theorem is_add_regular_of_cancel_add_monoid {R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g",
    "theorem": "{R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g",
    "args": "{R : Type u_1} [add_cancel_monoid R] (g : R)",
    "doc_string": "Elements of an add cancel monoid are regular.  Add cancel semigroups do not appear to exist.",
    "kind": "theorem",
    "type": "is_add_regular g"
  },
  {
    "name": "pos_num.prime",
    "statement": "def pos_num.prime (n : pos_num) : Prop",
    "theorem": "(n : pos_num) : Prop",
    "args": "(n : pos_num)",
    "doc_string": "Primality predicate for a `pos_num`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "subsemiring.mul_mem",
    "statement": "theorem subsemiring.mul_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R} : x ∈ s → y ∈ s → x * y ∈ s",
    "args": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) {x y : R}",
    "doc_string": "A subsemiring is closed under multiplication.",
    "kind": "theorem",
    "type": "x ∈ s → y ∈ s → x * y ∈ s"
  },
  {
    "name": "is_local_max",
    "statement": "def is_local_max {α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α) : Prop",
    "args": "{α : Type u} {β : Type v} [topological_space α] [preorder β] (f : α → β) (a : α)",
    "doc_string": "`is_local_max f a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "affine_subspace.gi",
    "statement": "def affine_subspace.gi (k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : galois_insertion (affine_span k) coe",
    "theorem": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : galois_insertion (affine_span k) coe",
    "args": "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P]",
    "doc_string": " The Galois insertion formed by `affine_span` and coercion back to a set.",
    "kind": "def",
    "type": "galois_insertion (affine_span k) coe"
  },
  {
    "name": "zsmul_right_injective",
    "statement": "theorem zsmul_right_injective {α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} (hn : n ≠ 0) : function.injective (λ (_x : α), n • _x)",
    "theorem": "{α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} (hn : n ≠ 0) : function.injective (λ (_x : α), n • _x)",
    "args": "{α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} (hn : n ≠ 0)",
    "doc_string": "See also `smul_right_injective`. TODO: provide a `no_zero_smul_divisors` instance. We can't do that here because importing that definition would create import cycles.",
    "kind": "theorem",
    "type": "function.injective (λ (_x : α), n • _x)"
  },
  {
    "name": "right.add_neg_of_nonpos_of_neg",
    "statement": "theorem right.add_neg_of_nonpos_of_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_neg_of_nonpos_of_neg`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "inv_of_one_lt_inv",
    "statement": "theorem inv_of_one_lt_inv {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ → a < 1",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ → a < 1",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of the forward direction of left.one_lt_inv_iff`.",
    "kind": "theorem",
    "type": "1 < a⁻¹ → a < 1"
  },
  {
    "name": "directed_on.directed_coe",
    "statement": "theorem directed_on.directed_coe {α : Type u} {r : α → α → Prop} {s : set α} : directed_on r s → directed r coe",
    "theorem": "{α : Type u} {r : α → α → Prop} {s : set α} : directed_on r s → directed r coe",
    "args": "{α : Type u} {r : α → α → Prop} {s : set α}",
    "doc_string": "**Alias** of the forward direction of directed_on_iff_directed`.",
    "kind": "theorem",
    "type": "directed_on r s → directed r coe"
  },
  {
    "name": "path.cast",
    "statement": "def path.cast {X : Type u_1} [topological_space X] {x y : X} (γ : path x y) {x' y' : X} (hx : x' = x) (hy : y' = y) : path x' y'",
    "theorem": "{X : Type u_1} [topological_space X] {x y : X} (γ : path x y) {x' y' : X} (hx : x' = x) (hy : y' = y) : path x' y'",
    "args": "{X : Type u_1} [topological_space X] {x y : X} (γ : path x y) {x' y' : X} (hx : x' = x) (hy : y' = y)",
    "doc_string": "Casting a path from `x` to `y` to a path from `x'` to `y'` when `x' = x` and `y' = y`",
    "kind": "def",
    "type": "path x' y'"
  },
  {
    "name": "homotopy_equiv.symm",
    "statement": "def homotopy_equiv.symm {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (f : homotopy_equiv C D) : homotopy_equiv D C",
    "theorem": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (f : homotopy_equiv C D) : homotopy_equiv D C",
    "args": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} {C D : homological_complex V c} (f : homotopy_equiv C D)",
    "doc_string": "Being homotopy equivalent is a symmetric relation.",
    "kind": "def",
    "type": "homotopy_equiv D C"
  },
  {
    "name": "sSet",
    "statement": "def sSet  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": " The category of simplicial sets. This is the category of contravariant functors from `simplex_category` to `Type u`.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "is_right_regular_zero_iff_subsingleton",
    "statement": "theorem is_right_regular_zero_iff_subsingleton {R : Type u_1} [mul_zero_class R] : is_right_regular 0 ↔ subsingleton R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : is_right_regular 0 ↔ subsingleton R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "The element `0` is right-regular if and only if `R` is trivial.",
    "kind": "theorem",
    "type": "is_right_regular 0 ↔ subsingleton R"
  },
  {
    "name": "add_monoid",
    "statement": "structure add_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "semi_normed_group.core",
    "statement": "structure semi_normed_group.core (E : Type u_6) [add_comm_group E] [has_norm E] : Prop",
    "theorem": "(E : Type u_6) [add_comm_group E] [has_norm E] : Prop",
    "args": "(E : Type u_6) [add_comm_group E] [has_norm E]",
    "doc_string": " A seminormed group can be built from a seminorm that satisfies algebraic properties. This is formalised in this structure.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "filter.is_countably_generated",
    "statement": "structure filter.is_countably_generated {α : Type u_1} (f : filter α) : Prop",
    "theorem": "{α : Type u_1} (f : filter α) : Prop",
    "args": "{α : Type u_1} (f : filter α)",
    "doc_string": "`is_countably_generated f` means `f = generate s` for some countable `s`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "subsemiring.multiset_sum_mem",
    "statement": "theorem subsemiring.multiset_sum_mem {R : Type u} [non_assoc_semiring R] (s : subsemiring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s",
    "theorem": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) (m : multiset R) : (∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s",
    "args": "{R : Type u} [non_assoc_semiring R] (s : subsemiring R) (m : multiset R)",
    "doc_string": " Sum of a multiset of elements in a `subsemiring` of a `semiring` is in the `add_subsemiring`.",
    "kind": "theorem",
    "type": "(∀ (a : R), a ∈ m → a ∈ s) → m.sum ∈ s"
  },
  {
    "name": "left.add_neg'",
    "statement": "theorem left.add_neg' {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg'`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "has_measurable_mul₂",
    "statement": "structure has_measurable_mul₂ (M : Type u_1) [measurable_space M] [has_mul M] : Prop",
    "theorem": "(M : Type u_1) [measurable_space M] [has_mul M] : Prop",
    "args": "(M : Type u_1) [measurable_space M] [has_mul M]",
    "doc_string": " We say that a type `has_measurable_mul` if `uncurry (*)` is a measurable functions. For a typeclass assuming measurability of `((*) c)` and `(* c)` see `has_measurable_mul`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "format",
    "statement": "constant format  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Format is a rich string with highlighting and information about how tabs should be put in if linebreaks are needed. A 'pretty string'.",
    "kind": "constant",
    "type": "Type"
  },
  {
    "name": "is_torsion.group",
    "statement": "def is_torsion.group {G : Type u_1} [monoid G] (tG : monoid.is_torsion G) : group G",
    "theorem": "{G : Type u_1} [monoid G] (tG : monoid.is_torsion G) : group G",
    "args": "{G : Type u_1} [monoid G] (tG : monoid.is_torsion G)",
    "doc_string": "Torsion monoids are really groups.",
    "kind": "def",
    "type": "group G"
  },
  {
    "name": "collinear_empty",
    "statement": "theorem collinear_empty (k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k ∅",
    "theorem": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k ∅",
    "args": "(k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P]",
    "doc_string": "The empty set is collinear.",
    "kind": "theorem",
    "type": "collinear k ∅"
  },
  {
    "name": "fin.cons",
    "statement": "def fin.cons {n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (i : fin (n + 1)) : α i",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (i : fin (n + 1)) : α i",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (x : α 0) (p : Π (i : fin n), α i.succ) (i : fin (n + 1))",
    "doc_string": "Adding an element at the beginning of an `n`-tuple, to get an `n+1`-tuple.",
    "kind": "def",
    "type": "α i"
  },
  {
    "name": "pgame.has_inv",
    "statement": "def pgame.has_inv  : has_inv pgame",
    "theorem": " : has_inv pgame",
    "args": "",
    "doc_string": "The inverse of a surreal number in terms of the inverse on positive surreals.",
    "kind": "def",
    "type": "has_inv pgame"
  },
  {
    "name": "multiset.lcm",
    "statement": "def multiset.lcm {α : Type u_1} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : multiset α) : α",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : multiset α) : α",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [normalized_gcd_monoid α] (s : multiset α)",
    "doc_string": "Least common multiple of a multiset",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "right.one_lt_mul",
    "statement": "theorem right.one_lt_mul {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul`.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "vector.encodable",
    "statement": "def vector.encodable {α : Type u_1} [encodable α] {n : ℕ} : encodable (vector α n)",
    "theorem": "{α : Type u_1} [encodable α] {n : ℕ} : encodable (vector α n)",
    "args": "{α : Type u_1} [encodable α] {n : ℕ}",
    "doc_string": "If `α` is encodable, then so is `vector α n`.",
    "kind": "def",
    "type": "encodable (vector α n)"
  },
  {
    "name": "left.add_neg_of_neg_of_nonpos",
    "statement": "theorem left.add_neg_of_neg_of_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_neg_of_nonpos`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "star_ordered_ring",
    "statement": "structure star_ordered_ring (R : Type u) [non_unital_semiring R] [partial_order R] : Type u",
    "theorem": "(R : Type u) [non_unital_semiring R] [partial_order R] : Type u",
    "args": "(R : Type u) [non_unital_semiring R] [partial_order R]",
    "doc_string": "An ordered `*`-ring is a ring which is both an `ordered_add_comm_group` and a `*`-ring, and `0 ≤ r ↔ ∃ s, r = star s * s`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "filter.unique",
    "statement": "def filter.unique {α : Type u} [is_empty α] : unique (filter α)",
    "theorem": "{α : Type u} [is_empty α] : unique (filter α)",
    "args": "{α : Type u} [is_empty α]",
    "doc_string": "There is exactly one filter on an empty type. -",
    "kind": "def",
    "type": "unique (filter α)"
  },
  {
    "name": "category_theory.monoidal_of_has_finite_products",
    "statement": "def category_theory.monoidal_of_has_finite_products (C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_binary_products C] : category_theory.monoidal_category C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_binary_products C] : category_theory.monoidal_category C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_binary_products C]",
    "doc_string": "A category with a terminal object and binary products has a natural monoidal structure.",
    "kind": "def",
    "type": "category_theory.monoidal_category C"
  },
  {
    "name": "connected_component",
    "statement": "def connected_component {α : Type u} [topological_space α] (x : α) : set α",
    "theorem": "{α : Type u} [topological_space α] (x : α) : set α",
    "args": "{α : Type u} [topological_space α] (x : α)",
    "doc_string": " The connected component of a point is the maximal connected set that contains this point.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "category_theory.limits.has_binary_product",
    "statement": "def category_theory.limits.has_binary_product {C : Type u} [category_theory.category C] (X Y : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] (X Y : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] (X Y : C)",
    "doc_string": "An abbreviation for `has_limit (pair X Y)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.is_subterminal_of_is_iso_diag",
    "statement": "theorem category_theory.is_subterminal_of_is_iso_diag {C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)]",
    "doc_string": "If the diagonal morphism of `A` is an isomorphism, then it is subterminal. The converse of `is_subterminal.is_iso_diag`.",
    "kind": "theorem",
    "type": "category_theory.is_subterminal A"
  },
  {
    "name": "CommMon",
    "statement": "def CommMon  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of commutative monoids and monoid morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "category_theory.is_subterminal.is_iso_diag",
    "statement": "theorem category_theory.is_subterminal.is_iso_diag {C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)",
    "theorem": "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)",
    "args": "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A]",
    "doc_string": "If `A` is subterminal, its diagonal morphism is an isomorphism. The converse of `is_subterminal_of_is_iso_diag`.",
    "kind": "theorem",
    "type": "category_theory.is_iso (category_theory.limits.diag A)"
  },
  {
    "name": "perfection_map.id",
    "statement": "theorem perfection_map.id (p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)",
    "theorem": "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)",
    "args": "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p]",
    "doc_string": "For a perfect ring, it itself is the perfection.",
    "kind": "theorem",
    "type": "perfection_map p (ring_hom.id R)"
  },
  {
    "name": "is_fraction_ring.char_zero_of_is_fraction_ring",
    "statement": "theorem is_fraction_ring.char_zero_of_is_fraction_ring (R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K",
    "theorem": "(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K",
    "args": "(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R]",
    "doc_string": "If `R` has characteristic `0`, then so does Frac(R).",
    "kind": "theorem",
    "type": "char_zero K"
  },
  {
    "name": "simple_graph.neighbor_set",
    "statement": "def simple_graph.neighbor_set {V : Type u} (G : simple_graph V) (v : V) : set V",
    "theorem": "{V : Type u} (G : simple_graph V) (v : V) : set V",
    "args": "{V : Type u} (G : simple_graph V) (v : V)",
    "doc_string": "`G.neighbor_set v` is the set of vertices adjacent to `v` in `G`.",
    "kind": "def",
    "type": "set V"
  },
  {
    "name": "one_lt_inv'",
    "statement": "theorem one_lt_inv' {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α}",
    "doc_string": "**Alias** of left.one_lt_inv_iff`.",
    "kind": "theorem",
    "type": "1 < a⁻¹ ↔ a < 1"
  },
  {
    "name": "filter.hyperfilter",
    "statement": "def filter.hyperfilter (α : Type u) [infinite α] : ultrafilter α",
    "theorem": "(α : Type u) [infinite α] : ultrafilter α",
    "args": "(α : Type u) [infinite α]",
    "doc_string": "The ultrafilter extending the cofinite filter.",
    "kind": "def",
    "type": "ultrafilter α"
  },
  {
    "name": "finset.nat.antidiagonal",
    "statement": "def finset.nat.antidiagonal (n : ℕ) : finset (ℕ × ℕ)",
    "theorem": "(n : ℕ) : finset (ℕ × ℕ)",
    "args": "(n : ℕ)",
    "doc_string": "The antidiagonal of a natural number `n` is    the finset of pairs `(i, j)` such that `i + j = n`.",
    "kind": "def",
    "type": "finset (ℕ × ℕ)"
  },
  {
    "name": "matrix.compl",
    "statement": "def matrix.compl {V : Type u_1} {α : Type u_2} [has_zero α] [has_one α] [decidable_eq α] [decidable_eq V] (A : matrix V V α) : matrix V V α",
    "theorem": "{V : Type u_1} {α : Type u_2} [has_zero α] [has_one α] [decidable_eq α] [decidable_eq V] (A : matrix V V α) : matrix V V α",
    "args": "{V : Type u_1} {α : Type u_2} [has_zero α] [has_one α] [decidable_eq α] [decidable_eq V] (A : matrix V V α)",
    "doc_string": "For `A : matrix V V α`, `A.compl` is supposed to be the adjacency matrix of    the complement graph of the graph induced by `A.adj_matrix`.",
    "kind": "def",
    "type": "matrix V V α"
  },
  {
    "name": "num.test_bit",
    "statement": "def num.test_bit  : num → ℕ → bool",
    "theorem": " : num → ℕ → bool",
    "args": "",
    "doc_string": "`a.test_bit n` is `tt` iff the `n`-th bit (starting from the LSB) in the binary representation      of `a` is active. If the size of `a` is less than `n`, this evaluates to `ff`.",
    "kind": "def",
    "type": "num → ℕ → bool"
  },
  {
    "name": "cardinal.ord",
    "statement": "def cardinal.ord (c : cardinal) : ordinal",
    "theorem": "(c : cardinal) : ordinal",
    "args": "(c : cardinal)",
    "doc_string": "The ordinal corresponding to a cardinal `c` is the least ordinal  whose cardinal is `c`. For the order-embedding version, see `ord.order_embedding`.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "onote.add",
    "statement": "def onote.add  : onote → onote → onote",
    "theorem": " : onote → onote → onote",
    "args": "",
    "doc_string": "Addition of ordinal notations (correct only for normal input)",
    "kind": "def",
    "type": "onote → onote → onote"
  },
  {
    "name": "ordnode.take_while",
    "statement": "def ordnode.take_while {α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α",
    "theorem": "{α : Type u} (p : α → Prop) [decidable_pred p] : ordnode α → ordnode α",
    "args": "{α : Type u} (p : α → Prop) [decidable_pred p]",
    "doc_string": " O(log n). Get an initial segment of the set that satisfies the predicate `p`. `p` is required to be antitone, that is, `x < y → p y → p x`.      take_while (λ x, x < 4) {1, 2, 3, 4, 5} = {1, 2, 3}     take_while (λ x, x > 4) {1, 2, 3, 4, 5} = precondition violation",
    "kind": "def",
    "type": "ordnode α → ordnode α"
  },
  {
    "name": "ring.has_bracket",
    "statement": "def ring.has_bracket {A : Type v} [ring A] : has_bracket A A",
    "theorem": "{A : Type v} [ring A] : has_bracket A A",
    "args": "{A : Type v} [ring A]",
    "doc_string": " The bracket operation for rings is the ring commutator, which captures the extent to which a ring is commutative. It is identically zero exactly when the ring is commutative.",
    "kind": "def",
    "type": "has_bracket A A"
  },
  {
    "name": "add_subgroup.pointwise_mul_action",
    "statement": "def add_subgroup.pointwise_mul_action {α : Type u_1} {A : Type u_3} [add_group A] [monoid α] [distrib_mul_action α A] : mul_action α (add_subgroup A)",
    "theorem": "{α : Type u_1} {A : Type u_3} [add_group A] [monoid α] [distrib_mul_action α A] : mul_action α (add_subgroup A)",
    "args": "{α : Type u_1} {A : Type u_3} [add_group A] [monoid α] [distrib_mul_action α A]",
    "doc_string": " The action on an additive subgroup corresponding to applying the action to every element.  This is available as an instance in the `pointwise` locale.",
    "kind": "def",
    "type": "mul_action α (add_subgroup A)"
  },
  {
    "name": "monotone.ne_of_lt_of_lt_int",
    "statement": "theorem monotone.ne_of_lt_of_lt_int {α : Type u} [preorder α] {f : ℤ → α} (hf : monotone f) (n : ℤ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℤ) : f a ≠ x",
    "theorem": "{α : Type u} [preorder α] {f : ℤ → α} (hf : monotone f) (n : ℤ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℤ) : f a ≠ x",
    "args": "{α : Type u} [preorder α] {f : ℤ → α} (hf : monotone f) (n : ℤ) {x : α} (h1 : f n < x) (h2 : x < f (n + 1)) (a : ℤ)",
    "doc_string": "If `f` is a monotone function from `ℤ` to a preorder and `x` lies between `f n` and  `f (n + 1)`, then `x` doesn't lie in the range of `f`.",
    "kind": "theorem",
    "type": "f a ≠ x"
  },
  {
    "name": "slope",
    "statement": "def slope {k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k → PE) (a b : k) : E",
    "theorem": "{k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k → PE) (a b : k) : E",
    "args": "{k : Type u_1} {E : Type u_2} {PE : Type u_3} [field k] [add_comm_group E] [module k E] [add_torsor E PE] (f : k → PE) (a b : k)",
    "doc_string": " `slope f a b = (b - a)⁻¹ • (f b -ᵥ f a)` is the slope of a function `f` on the interval `[a, b]`. Note that `slope f a a = 0`, not the derivative of `f` at `a`.",
    "kind": "def",
    "type": "E"
  },
  {
    "name": "ray_of_ne_zero",
    "statement": "def ray_of_ne_zero (R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) (h : v ≠ 0) : module.ray R M",
    "theorem": "(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) (h : v ≠ 0) : module.ray R M",
    "args": "(R : Type u_1) [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (v : M) (h : v ≠ 0)",
    "doc_string": "The ray given by a nonzero vector.",
    "kind": "def",
    "type": "module.ray R M"
  },
  {
    "name": "turing.to_partrec.code.head",
    "statement": "def turing.to_partrec.code.head  : turing.to_partrec.code",
    "theorem": " : turing.to_partrec.code",
    "args": "",
    "doc_string": "`head` gets the head of the input list: `head [] = [0]`, `head (n :: v) = [n]`.",
    "kind": "def",
    "type": "turing.to_partrec.code"
  },
  {
    "name": "computation.tail",
    "statement": "def computation.tail {α : Type u} (c : computation α) : computation α",
    "theorem": "{α : Type u} (c : computation α) : computation α",
    "args": "{α : Type u} (c : computation α)",
    "doc_string": "`tail c` is the remainder of computation, either `c` if `c = return a`  or `c'` if `c = think c'`.",
    "kind": "def",
    "type": "computation α"
  },
  {
    "name": "subsemigroup.simps.coe",
    "statement": "def subsemigroup.simps.coe {M : Type u_1} [has_mul M] (S : subsemigroup M) : set M",
    "theorem": "{M : Type u_1} [has_mul M] (S : subsemigroup M) : set M",
    "args": "{M : Type u_1} [has_mul M] (S : subsemigroup M)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "nnreal",
    "statement": "def nnreal  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Nonnegative real numbers.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "CommGroup",
    "statement": "def CommGroup  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of commutative groups and group morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "one_div_lt_one_div_of_neg",
    "statement": "theorem one_div_lt_one_div_of_neg {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ↔ b < a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ↔ b < a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0)",
    "doc_string": "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and  `lt_of_one_div_lt_one_div`",
    "kind": "theorem",
    "type": "1 / a < 1 / b ↔ b < a"
  },
  {
    "name": "topological_group.to_uniform_space",
    "statement": "def topological_group.to_uniform_space (G : Type u_1) [comm_group G] [topological_space G] [topological_group G] : uniform_space G",
    "theorem": "(G : Type u_1) [comm_group G] [topological_space G] [topological_group G] : uniform_space G",
    "args": "(G : Type u_1) [comm_group G] [topological_space G] [topological_group G]",
    "doc_string": "The right uniformity on a topological group.",
    "kind": "def",
    "type": "uniform_space G"
  },
  {
    "name": "is_add_subgroup.add_center",
    "statement": "def is_add_subgroup.add_center (G : Type u_1) [add_group G] : set G",
    "theorem": "(G : Type u_1) [add_group G] : set G",
    "args": "(G : Type u_1) [add_group G]",
    "doc_string": "The underlying set of the center of an additive group.",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "linear_ordered_add_comm_group",
    "statement": "structure linear_ordered_add_comm_group (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " A linearly ordered additive commutative group is an additive commutative group with a linear order in which addition is monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "prod.compact_space",
    "statement": "def prod.compact_space {α : Type u} {β : Type v} [topological_space α] [topological_space β] [compact_space α] [compact_space β] : compact_space (α × β)",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] [compact_space α] [compact_space β] : compact_space (α × β)",
    "args": "{α : Type u} {β : Type v} [topological_space α] [topological_space β] [compact_space α] [compact_space β]",
    "doc_string": "The product of two compact spaces is compact.",
    "kind": "def",
    "type": "compact_space (α × β)"
  },
  {
    "name": "invertible_of_char_p_not_dvd",
    "statement": "def invertible_of_char_p_not_dvd {K : Type u_1} [field K] {p : ℕ} [char_p K p] {t : ℕ} (not_dvd : ¬p ∣ t) : invertible ↑t",
    "theorem": "{K : Type u_1} [field K] {p : ℕ} [char_p K p] {t : ℕ} (not_dvd : ¬p ∣ t) : invertible ↑t",
    "args": "{K : Type u_1} [field K] {p : ℕ} [char_p K p] {t : ℕ} (not_dvd : ¬p ∣ t)",
    "doc_string": " A natural number `t` is invertible in a field `K` of charactistic `p` if `p` does not divide `t`.",
    "kind": "def",
    "type": "invertible ↑t"
  },
  {
    "name": "bitvec.sborrow",
    "statement": "def bitvec.sborrow {n : ℕ} : bitvec n → bitvec n → bool",
    "theorem": "{n : ℕ} : bitvec n → bitvec n → bool",
    "args": "{n : ℕ}",
    "doc_string": "`sborrow x y` returns `tt` iff `x < y` as two's complement integers",
    "kind": "def",
    "type": "bitvec n → bitvec n → bool"
  },
  {
    "name": "prod.non_unital_comm_ring",
    "statement": "def prod.non_unital_comm_ring {R : Type u_1} {S : Type u_3} [non_unital_comm_ring R] [non_unital_comm_ring S] : non_unital_comm_ring (R × S)",
    "theorem": "{R : Type u_1} {S : Type u_3} [non_unital_comm_ring R] [non_unital_comm_ring S] : non_unital_comm_ring (R × S)",
    "args": "{R : Type u_1} {S : Type u_3} [non_unital_comm_ring R] [non_unital_comm_ring S]",
    "doc_string": "Product of two `non_unital_comm_ring`s is a `non_unital_comm_ring`.",
    "kind": "def",
    "type": "non_unital_comm_ring (R × S)"
  },
  {
    "name": "first_order.language.is_algebraic",
    "statement": "structure first_order.language.is_algebraic (L : first_order.language) : Prop",
    "theorem": "(L : first_order.language) : Prop",
    "args": "(L : first_order.language)",
    "doc_string": "A language is algebraic when it has no relation symbols.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ordinal.lift",
    "statement": "def ordinal.lift (o : ordinal) : ordinal",
    "theorem": "(o : ordinal) : ordinal",
    "args": "(o : ordinal)",
    "doc_string": "The universe lift operation for ordinals, which embeds `ordinal.{u}` as  a proper initial segment of `ordinal.{v}` for `v > u`. For the initial segment version,  see `lift.initial_seg`.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "convex_independent.injective",
    "statement": "theorem convex_independent.injective {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) : function.injective p",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) : function.injective p",
    "args": "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p)",
    "doc_string": "A convex independent family is injective.",
    "kind": "theorem",
    "type": "function.injective p"
  },
  {
    "name": "bilin_form.nondegenerate",
    "statement": "def bilin_form.nondegenerate {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M)",
    "doc_string": " A nondegenerate bilinear form is a bilinear form such that the only element that is orthogonal to every other element is `0`; i.e., for all nonzero `m` in `M`, there exists `n` in `M` with `B m n ≠ 0`.  Note that for general (neither symmetric nor antisymmetric) bilinear forms this definition has a chirality; in addition to this \"left\" nondegeneracy condition one could define a \"right\" nondegeneracy condition that in the situation described, `B n m ≠ 0`.  This variant definition is not currently provided in mathlib. In finite dimension either definition implies the other.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "list.duplicate",
    "statement": "inductive list.duplicate {α : Type u_1} (x : α) : list α → Prop",
    "theorem": "{α : Type u_1} (x : α) : list α → Prop",
    "args": "{α : Type u_1} (x : α)",
    "doc_string": "Property that an element `x : α` of `l : list α` can be found in the list more than once.",
    "kind": "inductive",
    "type": "list α → Prop"
  },
  {
    "name": "is_compl",
    "statement": "structure is_compl {α : Type u} [lattice α] [bounded_order α] (x y : α) : Prop",
    "theorem": "{α : Type u} [lattice α] [bounded_order α] (x y : α) : Prop",
    "args": "{α : Type u} [lattice α] [bounded_order α] (x y : α)",
    "doc_string": "Two elements `x` and `y` are complements of each other if `x ⊔ y = ⊤` and `x ⊓ y = ⊥`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ring_topology.to_add_group_topology",
    "statement": "def ring_topology.to_add_group_topology {α : Type u_1} [ring α] (t : ring_topology α) : add_group_topology α",
    "theorem": "{α : Type u_1} [ring α] (t : ring_topology α) : add_group_topology α",
    "args": "{α : Type u_1} [ring α] (t : ring_topology α)",
    "doc_string": "The forgetful functor from ring topologies on `a` to additive group topologies on `a`.",
    "kind": "def",
    "type": "add_group_topology α"
  },
  {
    "name": "finite.of_fintype'",
    "statement": "def finite.of_fintype' (α : Type u_1) [fintype α] : finite α",
    "theorem": "(α : Type u_1) [fintype α] : finite α",
    "args": "(α : Type u_1) [fintype α]",
    "doc_string": " For efficiency reasons, we want `finite` instances to have higher priority than ones coming from `fintype` instances.",
    "kind": "def",
    "type": "finite α"
  },
  {
    "name": "zero_lt.left.mul_lt_one_of_le_of_lt",
    "statement": "theorem zero_lt.left.mul_lt_one_of_le_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "add_hom.id",
    "statement": "def add_hom.id (M : Type u_1) [has_add M] : add_hom M M",
    "theorem": "(M : Type u_1) [has_add M] : add_hom M M",
    "args": "(M : Type u_1) [has_add M]",
    "doc_string": "The identity map from an type with addition to itself.",
    "kind": "def",
    "type": "add_hom M M"
  },
  {
    "name": "parser.static",
    "statement": "structure parser.static {α : Type} (p : parser α) : Prop",
    "theorem": "{α : Type} (p : parser α) : Prop",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "A `parser α` is defined to be `static` if it does not move on success.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "is_lower_set",
    "statement": "def is_lower_set {α : Type u_1} [has_le α] (s : set α) : Prop",
    "theorem": "{α : Type u_1} [has_le α] (s : set α) : Prop",
    "args": "{α : Type u_1} [has_le α] (s : set α)",
    "doc_string": " A lower set in an order `α` is a set such that any element less than one of its members is also a member. Also called down-set, downward-closed set.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.partrec.code.id",
    "statement": "def nat.partrec.code.id  : nat.partrec.code",
    "theorem": " : nat.partrec.code",
    "args": "",
    "doc_string": "A code for the identity function.",
    "kind": "def",
    "type": "nat.partrec.code"
  },
  {
    "name": "graded_monoid.gcomm_monoid",
    "statement": "structure graded_monoid.gcomm_monoid {ι : Type u_1} (A : ι → Type u_2) [add_comm_monoid ι] : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} (A : ι → Type u_2) [add_comm_monoid ι] : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} (A : ι → Type u_2) [add_comm_monoid ι]",
    "doc_string": "A graded version of `comm_monoid`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "matrix.std_basis",
    "statement": "def matrix.std_basis (R : Type u_1) (m : Type u_2) (n : Type u_3) [fintype m] [fintype n] [semiring R] : basis (m × n) R (matrix m n R)",
    "theorem": "(R : Type u_1) (m : Type u_2) (n : Type u_3) [fintype m] [fintype n] [semiring R] : basis (m × n) R (matrix m n R)",
    "args": "(R : Type u_1) (m : Type u_2) (n : Type u_3) [fintype m] [fintype n] [semiring R]",
    "doc_string": "The standard basis of `matrix m n R`.",
    "kind": "def",
    "type": "basis (m × n) R (matrix m n R)"
  },
  {
    "name": "conj_classes.mk",
    "statement": "def conj_classes.mk {α : Type u_1} [monoid α] (a : α) : conj_classes α",
    "theorem": "{α : Type u_1} [monoid α] (a : α) : conj_classes α",
    "args": "{α : Type u_1} [monoid α] (a : α)",
    "doc_string": "The canonical quotient map from a monoid `α` into the `conj_classes` of `α`",
    "kind": "def",
    "type": "conj_classes α"
  },
  {
    "name": "is_dedekind_domain.height_one_spectrum.int_valuation_def",
    "statement": "def is_dedekind_domain.height_one_spectrum.int_valuation_def {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : with_zero (multiplicative ℤ)",
    "theorem": "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R) : with_zero (multiplicative ℤ)",
    "args": "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (r : R)",
    "doc_string": " The additive `v`-adic valuation of `r ∈ R` is the exponent of `v` in the factorization of the ideal `(r)`, if `r` is nonzero, or infinity, if `r = 0`. `int_valuation_def` is the corresponding multiplicative valuation.",
    "kind": "def",
    "type": "with_zero (multiplicative ℤ)"
  },
  {
    "name": "vector3.nth",
    "statement": "def vector3.nth {α : Type u_1} {n : ℕ} (i : fin2 n) (v : vector3 α n) : α",
    "theorem": "{α : Type u_1} {n : ℕ} (i : fin2 n) (v : vector3 α n) : α",
    "args": "{α : Type u_1} {n : ℕ} (i : fin2 n) (v : vector3 α n)",
    "doc_string": "Get the `i`th element of a vector",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "subtraction_monoid",
    "statement": "structure subtraction_monoid (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that `-(a + b) = -b + -a` and `a + b = 0 → -a = b`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "trunc_of_card_pos",
    "statement": "def trunc_of_card_pos {α : Type u_1} [fintype α] (h : 0 < fintype.card α) : trunc α",
    "theorem": "{α : Type u_1} [fintype α] (h : 0 < fintype.card α) : trunc α",
    "args": "{α : Type u_1} [fintype α] (h : 0 < fintype.card α)",
    "doc_string": "A `fintype` with positive cardinality constructively contains an element.",
    "kind": "def",
    "type": "trunc α"
  },
  {
    "name": "list.all₂",
    "statement": "def list.all₂ {α : Type u_1} (p : α → Prop) : list α → Prop",
    "theorem": "{α : Type u_1} (p : α → Prop) : list α → Prop",
    "args": "{α : Type u_1} (p : α → Prop)",
    "doc_string": " `l.all₂ p` is equivalent to `∀ a ∈ l, p a`, but unfolds directly to a conjunction, i.e. `list.all₂ p [0, 1, 2] = p 0 ∧ p 1 ∧ p 2`.",
    "kind": "def",
    "type": "list α → Prop"
  },
  {
    "name": "multiset.inf",
    "statement": "def multiset.inf {α : Type u_1} [semilattice_inf α] [order_top α] (s : multiset α) : α",
    "theorem": "{α : Type u_1} [semilattice_inf α] [order_top α] (s : multiset α) : α",
    "args": "{α : Type u_1} [semilattice_inf α] [order_top α] (s : multiset α)",
    "doc_string": "Infimum of a multiset: `inf {a, b, c} = a ⊓ b ⊓ c`",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "multiset.rel",
    "statement": "inductive multiset.rel {α : Type u_1} {β : Type u_2} (r : α → β → Prop) : multiset α → multiset β → Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop) : multiset α → multiset β → Prop",
    "args": "{α : Type u_1} {β : Type u_2} (r : α → β → Prop)",
    "doc_string": " `rel r s t` -- lift the relation `r` between two elements to a relation between `s` and `t`, s.t. there is a one-to-one mapping betweem elements in `s` and `t` following `r`.",
    "kind": "inductive",
    "type": "multiset α → multiset β → Prop"
  },
  {
    "name": "measure_theory.measure.add_haar_measure",
    "statement": "def measure_theory.measure.add_haar_measure {G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] (K₀ : topological_space.positive_compacts G) : measure_theory.measure G",
    "theorem": "{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] (K₀ : topological_space.positive_compacts G) : measure_theory.measure G",
    "args": "{G : Type u_1} [add_group G] [topological_space G] [t2_space G] [topological_add_group G] [measurable_space G] [borel_space G] (K₀ : topological_space.positive_compacts G)",
    "doc_string": "The Haar measure on the locally compact additive group `G`, scaled so that `add_haar_measure K₀ K₀ = 1`.",
    "kind": "def",
    "type": "measure_theory.measure G"
  },
  {
    "name": "tendsto_uniformly_on",
    "statement": "def tendsto_uniformly_on {α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (f : α → β) (p : filter ι) (s : set α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (f : α → β) (p : filter ι) (s : set α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} {ι : Type u_4} [uniform_space β] (F : ι → α → β) (f : α → β) (p : filter ι) (s : set α)",
    "doc_string": " A sequence of functions `Fₙ` converges uniformly on a set `s` to a limiting function `f` with respect to the filter `p` if, for any entourage of the diagonal `u`, one has `p`-eventually `(f x, Fₙ x) ∈ u` for all `x ∈ s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "function.commute.right_bij_on_fixed_pts_comp",
    "statement": "theorem function.commute.right_bij_on_fixed_pts_comp {α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "theorem": "{α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))",
    "args": "{α : Type u} {f g : α → α} (h : function.commute f g)",
    "doc_string": " If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`.",
    "kind": "theorem",
    "type": "set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))"
  },
  {
    "name": "finset.fin_range",
    "statement": "def finset.fin_range (n : ℕ) : finset (fin n)",
    "theorem": "(n : ℕ) : finset (fin n)",
    "args": "(n : ℕ)",
    "doc_string": "`finset.fin_range n` is the finset `{0, 1, ..., n - 1}`, as a `finset (fin n)`.",
    "kind": "def",
    "type": "finset (fin n)"
  },
  {
    "name": "set.has_mul",
    "statement": "def set.has_mul {α : Type u_2} [has_mul α] : has_mul (set α)",
    "theorem": "{α : Type u_2} [has_mul α] : has_mul (set α)",
    "args": "{α : Type u_2} [has_mul α]",
    "doc_string": " The pointwise multiplication of sets `s * t` and `t` is defined as `{x * y | x ∈ s, y ∈ t}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_mul (set α)"
  },
  {
    "name": "add_localization.zero",
    "statement": "def add_localization.zero {M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_localization S",
    "theorem": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M) : add_localization S",
    "args": "{M : Type u_1} [add_comm_monoid M] (S : add_submonoid M)",
    "doc_string": "The identity element of an `add_localization` is defined as `⟨0, 0⟩`.  Should not be confused with the ring localization counterpart `localization.zero`, which is defined as `⟨0, 1⟩`.",
    "kind": "def",
    "type": "add_localization S"
  },
  {
    "name": "nat.arithmetic_function.pow",
    "statement": "def nat.arithmetic_function.pow (k : ℕ) : nat.arithmetic_function ℕ",
    "theorem": "(k : ℕ) : nat.arithmetic_function ℕ",
    "args": "(k : ℕ)",
    "doc_string": "`pow k n = n ^ k`, except `pow 0 0 = 0`.",
    "kind": "def",
    "type": "nat.arithmetic_function ℕ"
  },
  {
    "name": "finset.prod",
    "statement": "def finset.prod {β : Type u} {α : Type v} [comm_monoid β] (s : finset α) (f : α → β) : β",
    "theorem": "{β : Type u} {α : Type v} [comm_monoid β] (s : finset α) (f : α → β) : β",
    "args": "{β : Type u} {α : Type v} [comm_monoid β] (s : finset α) (f : α → β)",
    "doc_string": "`∏ x in s, f x` is the product of `f x` as `x` ranges over the elements of the finite set `s`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "add_hom.coprod",
    "statement": "def add_hom.coprod {M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [add_comm_semigroup P] (f : add_hom M P) (g : add_hom N P) : add_hom (M × N) P",
    "theorem": "{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [add_comm_semigroup P] (f : add_hom M P) (g : add_hom N P) : add_hom (M × N) P",
    "args": "{M : Type u_5} {N : Type u_6} {P : Type u_7} [has_add M] [has_add N] [add_comm_semigroup P] (f : add_hom M P) (g : add_hom N P)",
    "doc_string": "Coproduct of two `add_hom`s with the same codomain: `f.coprod g (p : M × N) = f p.1 + g p.2`.",
    "kind": "def",
    "type": "add_hom (M × N) P"
  },
  {
    "name": "pgame.has_add",
    "statement": "def pgame.has_add  : has_add pgame",
    "theorem": " : has_add pgame",
    "args": "",
    "doc_string": "The sum of `x = {xL | xR}` and `y = {yL | yR}` is `{xL + y, x + yL | xR + y, x + yR}`.",
    "kind": "def",
    "type": "has_add pgame"
  },
  {
    "name": "equiv.perm.mod_sum_congr",
    "statement": "def equiv.perm.mod_sum_congr (α : Type u_1) (β : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (β : Type u_2) : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (β : Type u_2)",
    "doc_string": "Elements which are considered equivalent if they differ only by swaps within α or β",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "mul_neg_one",
    "statement": "theorem mul_neg_one {α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a",
    "theorem": "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a",
    "args": "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α)",
    "doc_string": "An element of a ring multiplied by the additive inverse of one is the element's additive  inverse.",
    "kind": "theorem",
    "type": "a * -1 = -a"
  },
  {
    "name": "is_localization.away.inv_self",
    "statement": "def is_localization.away.inv_self {R : Type u_1} [comm_semiring R] {S : Type u_2} [comm_semiring S] [algebra R S] (x : R) [is_localization.away x S] : S",
    "theorem": "{R : Type u_1} [comm_semiring R] {S : Type u_2} [comm_semiring S] [algebra R S] (x : R) [is_localization.away x S] : S",
    "args": "{R : Type u_1} [comm_semiring R] {S : Type u_2} [comm_semiring S] [algebra R S] (x : R) [is_localization.away x S]",
    "doc_string": "Given `x : R` and a localization map `F : R →+* S` away from `x`, `inv_self` is `(F x)⁻¹`.",
    "kind": "def",
    "type": "S"
  },
  {
    "name": "three_pos",
    "statement": "theorem three_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 3",
    "theorem": "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 3",
    "args": "{α : Type u} [ordered_semiring α] [nontrivial α]",
    "doc_string": "**Alias** of zero_lt_three`.",
    "kind": "theorem",
    "type": "0 < 3"
  },
  {
    "name": "ring_subgroups_basis.to_ring_filter_basis",
    "statement": "def ring_subgroups_basis.to_ring_filter_basis {A : Type u_1} {ι : Type u_2} [ring A] [nonempty ι] {B : ι → add_subgroup A} (hB : ring_subgroups_basis B) : ring_filter_basis A",
    "theorem": "{A : Type u_1} {ι : Type u_2} [ring A] [nonempty ι] {B : ι → add_subgroup A} (hB : ring_subgroups_basis B) : ring_filter_basis A",
    "args": "{A : Type u_1} {ι : Type u_2} [ring A] [nonempty ι] {B : ι → add_subgroup A} (hB : ring_subgroups_basis B)",
    "doc_string": "Every subgroups basis on a ring leads to a ring filter basis.",
    "kind": "def",
    "type": "ring_filter_basis A"
  },
  {
    "name": "finset.max'_singleton",
    "statement": "theorem finset.max'_singleton {α : Type u_1} [linear_order α] (a : α) : {a}.max' _ = a",
    "theorem": "{α : Type u_1} [linear_order α] (a : α) : {a}.max' _ = a",
    "args": "{α : Type u_1} [linear_order α] (a : α)",
    "doc_string": "`{a}.max' _` is `a`.",
    "kind": "theorem",
    "type": "{a}.max' _ = a"
  },
  {
    "name": "wseq.cons",
    "statement": "def wseq.cons {α : Type u} (a : α) : wseq α → wseq α",
    "theorem": "{α : Type u} (a : α) : wseq α → wseq α",
    "args": "{α : Type u} (a : α)",
    "doc_string": "Prepend an element to a weak sequence",
    "kind": "def",
    "type": "wseq α → wseq α"
  },
  {
    "name": "add_is_add_left_regular_iff",
    "statement": "theorem add_is_add_left_regular_iff {R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) ↔ is_add_left_regular b",
    "theorem": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) ↔ is_add_left_regular b",
    "args": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a)",
    "doc_string": "An element is add-left-regular if and only if adding to it on the left a add-left-regular element is add-left-regular.",
    "kind": "theorem",
    "type": "is_add_left_regular (a + b) ↔ is_add_left_regular b"
  },
  {
    "name": "mvpfunctor.M",
    "statement": "def mvpfunctor.M {n : ℕ} (P : mvpfunctor (n + 1)) (α : typevec n) : Type u",
    "theorem": "{n : ℕ} (P : mvpfunctor (n + 1)) (α : typevec n) : Type u",
    "args": "{n : ℕ} (P : mvpfunctor (n + 1)) (α : typevec n)",
    "doc_string": "`n`-ary M-type for `P`",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "quadratic_form.can_lift",
    "statement": "def quadratic_form.can_lift {R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] : can_lift (bilin_form R M) (quadratic_form R M)",
    "theorem": "{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2] : can_lift (bilin_form R M) (quadratic_form R M)",
    "args": "{R : Type u_2} {M : Type u_3} [add_comm_group M] [ring R] [module R M] [invertible 2]",
    "doc_string": "Symmetric bilinear forms can be lifted to quadratic forms",
    "kind": "def",
    "type": "can_lift (bilin_form R M) (quadratic_form R M)"
  },
  {
    "name": "topological_group.continuous_conj",
    "statement": "theorem topological_group.continuous_conj {G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (λ (h : G), g * h * g⁻¹)",
    "theorem": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (λ (h : G), g * h * g⁻¹)",
    "args": "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G)",
    "doc_string": "Conjugation by a fixed element is continuous when `mul` is continuous.",
    "kind": "theorem",
    "type": "continuous (λ (h : G), g * h * g⁻¹)"
  },
  {
    "name": "measure_theory.signed_measure",
    "statement": "def measure_theory.signed_measure (α : Type u_1) [measurable_space α] : Type u_1",
    "theorem": "(α : Type u_1) [measurable_space α] : Type u_1",
    "args": "(α : Type u_1) [measurable_space α]",
    "doc_string": "A `signed_measure` is a `ℝ`-vector measure.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "num.sub'",
    "statement": "def num.sub'  : num → num → znum",
    "theorem": " : num → num → znum",
    "args": "",
    "doc_string": "Subtraction of two `num`s, producing a `znum`.",
    "kind": "def",
    "type": "num → num → znum"
  },
  {
    "name": "has_variable_names.make_listlike_instance",
    "statement": "def has_variable_names.make_listlike_instance (α : Sort u) [has_variable_names α] {β : Sort v} : has_variable_names β",
    "theorem": "(α : Sort u) [has_variable_names α] {β : Sort v} : has_variable_names β",
    "args": "(α : Sort u) [has_variable_names α] {β : Sort v}",
    "doc_string": "`@make_listlike_instance α _ β` creates an instance `has_variable_names β` from an instance `has_variable_names α`. If `α` has associated names `a`, `b`, ..., the generated instance for `β` has names `as`, `bs`, ... This can be used to create instances for 'containers' such as lists or sets.",
    "kind": "def",
    "type": "has_variable_names β"
  },
  {
    "name": "category_theory.limits.has_strict_terminal_objects",
    "statement": "structure category_theory.limits.has_strict_terminal_objects (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "We say `C` has strict terminal objects if every terminal object is strict, ie given any morphism `f : I ⟶ A` where `I` is terminal, then `f` is an isomorphism.  Strictly speaking, this says that *any* terminal object must be strict, rather than that strict terminal objects exist.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "mul_action.is_minimal",
    "statement": "structure mul_action.is_minimal (M : Type u_1) (α : Type u_2) [monoid M] [topological_space α] [mul_action M α] : Prop",
    "theorem": "(M : Type u_1) (α : Type u_2) [monoid M] [topological_space α] [mul_action M α] : Prop",
    "args": "(M : Type u_1) (α : Type u_2) [monoid M] [topological_space α] [mul_action M α]",
    "doc_string": " An action of a monoid `M` on a topological space is called *minimal* if the `M`-orbit of every point `x : α` is dense.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "neg_pow_two",
    "statement": "theorem neg_pow_two {R : Type u₁} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2",
    "theorem": "{R : Type u₁} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2",
    "args": "{R : Type u₁} [monoid R] [has_distrib_neg R] (a : R)",
    "doc_string": "**Alias** of neg_sq`.",
    "kind": "theorem",
    "type": "(-a) ^ 2 = a ^ 2"
  },
  {
    "name": "algebraic_geometry.Scheme.Spec_obj",
    "statement": "def algebraic_geometry.Scheme.Spec_obj (R : CommRing) : algebraic_geometry.Scheme",
    "theorem": "(R : CommRing) : algebraic_geometry.Scheme",
    "args": "(R : CommRing)",
    "doc_string": "The spectrum of a commutative ring, as a scheme.",
    "kind": "def",
    "type": "algebraic_geometry.Scheme"
  },
  {
    "name": "mfld_cfg",
    "statement": "def mfld_cfg  : simps_cfg",
    "theorem": " : simps_cfg",
    "args": "",
    "doc_string": "Common `@[simps]` configuration options used for manifold-related declarations.",
    "kind": "def",
    "type": "simps_cfg"
  },
  {
    "name": "non_assoc_semiring",
    "statement": "structure non_assoc_semiring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A unital but not-necessarily-associative semiring.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "affine.simplex.points_with_circumcenter_index",
    "statement": "inductive affine.simplex.points_with_circumcenter_index (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": " An index type for the vertices of a simplex plus its circumcenter. This is for use in calculations where it is convenient to work with affine combinations of vertices together with the circumcenter.  (An equivalent form sometimes used in the literature is placing the circumcenter at the origin and working with vectors for the vertices.)",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "continuous_map.continuous_uncurry",
    "statement": "theorem continuous_map.continuous_uncurry {α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β] : continuous continuous_map.uncurry",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β] : continuous continuous_map.uncurry",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β]",
    "doc_string": "The uncurrying process is a continuous map between function spaces.",
    "kind": "theorem",
    "type": "continuous continuous_map.uncurry"
  },
  {
    "name": "algebra.adjoin",
    "statement": "def algebra.adjoin (R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A",
    "theorem": "(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A) : subalgebra R A",
    "args": "(R : Type u) {A : Type v} [comm_semiring R] [semiring A] [algebra R A] (s : set A)",
    "doc_string": "The minimal subalgebra that includes `s`.",
    "kind": "def",
    "type": "subalgebra R A"
  },
  {
    "name": "simple_graph.chromatic_number",
    "statement": "def simple_graph.chromatic_number {V : Type u} (G : simple_graph V) : ℕ",
    "theorem": "{V : Type u} (G : simple_graph V) : ℕ",
    "args": "{V : Type u} (G : simple_graph V)",
    "doc_string": " The chromatic number of a graph is the minimal number of colors needed to color it. If `G` isn't colorable with finitely many colors, this will be 0.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "jordan_holder_lattice",
    "statement": "structure jordan_holder_lattice (X : Type u) [lattice X] : Type u",
    "theorem": "(X : Type u) [lattice X] : Type u",
    "args": "(X : Type u) [lattice X]",
    "doc_string": "A `jordan_holder_lattice` is the class for which the Jordan Hölder theorem is proved. A Jordan Hölder lattice is a lattice equipped with a notion of maximality, `is_maximal`, and a notion of isomorphism of pairs `iso`. In the example of subgroups of a group, `is_maximal H K` means that `H` is a maximal normal subgroup of `K`, and `iso (H₁, K₁) (H₂, K₂)` means that the quotient `H₁ / K₁` is isomorphic to the quotient `H₂ / K₂`. `iso` must be symmetric and transitive and must satisfy the second isomorphism theorem `iso (H, H ⊔ K) (H ⊓ K, K)`. Examples include `subgroup G` if `G` is a group, and `submodule R M` if `M` is an `R`-module.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "galois_coinsertion.lift_complete_lattice",
    "statement": "def galois_coinsertion.lift_complete_lattice {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [complete_lattice β] (gi : galois_coinsertion l u) : complete_lattice α",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [complete_lattice β] (gi : galois_coinsertion l u) : complete_lattice α",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order α] [complete_lattice β] (gi : galois_coinsertion l u)",
    "doc_string": "Lift all suprema and infima along a Galois coinsertion",
    "kind": "def",
    "type": "complete_lattice α"
  },
  {
    "name": "add_subgroup.connected_component_of_zero",
    "statement": "def add_subgroup.connected_component_of_zero (G : Type u_1) [topological_space G] [add_group G] [topological_add_group G] : add_subgroup G",
    "theorem": "(G : Type u_1) [topological_space G] [add_group G] [topological_add_group G] : add_subgroup G",
    "args": "(G : Type u_1) [topological_space G] [add_group G] [topological_add_group G]",
    "doc_string": "The connected component of 0 is a subgroup of `G`.",
    "kind": "def",
    "type": "add_subgroup G"
  },
  {
    "name": "convex.to_cone",
    "statement": "def convex.to_cone {𝕜 : Type u_1} {E : Type u_2} [linear_ordered_field 𝕜] [ordered_add_comm_group E] [module 𝕜 E] (s : set E) (hs : convex 𝕜 s) : convex_cone 𝕜 E",
    "theorem": "{𝕜 : Type u_1} {E : Type u_2} [linear_ordered_field 𝕜] [ordered_add_comm_group E] [module 𝕜 E] (s : set E) (hs : convex 𝕜 s) : convex_cone 𝕜 E",
    "args": "{𝕜 : Type u_1} {E : Type u_2} [linear_ordered_field 𝕜] [ordered_add_comm_group E] [module 𝕜 E] (s : set E) (hs : convex 𝕜 s)",
    "doc_string": "The set of vectors proportional to those in a convex set forms a convex cone.",
    "kind": "def",
    "type": "convex_cone 𝕜 E"
  },
  {
    "name": "uniform_continuous_on",
    "statement": "def uniform_continuous_on {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) (s : set α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] (f : α → β) (s : set α)",
    "doc_string": " A function `f : α → β` is *uniformly continuous* on `s : set α` if `(f x, f y)` tends to the diagonal as `(x, y)` tends to the diagonal while remaining in `s ×ˢ s`. In other words, if `x` is sufficiently close to `y`, then `f x` is close to `f y` no matter where `x` and `y` are located in `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finite_dimensional.finrank_fin_fun",
    "statement": "theorem finite_dimensional.finrank_fin_fun (K : Type u) [division_ring K] {n : ℕ} : finite_dimensional.finrank K (fin n → K) = n",
    "theorem": "(K : Type u) [division_ring K] {n : ℕ} : finite_dimensional.finrank K (fin n → K) = n",
    "args": "(K : Type u) [division_ring K] {n : ℕ}",
    "doc_string": "The vector space of functions on `fin n` has finrank equal to `n`.",
    "kind": "theorem",
    "type": "finite_dimensional.finrank K (fin n → K) = n"
  },
  {
    "name": "polynomial.erase",
    "statement": "def polynomial.erase {R : Type u} [semiring R] (n : ℕ) : polynomial R → polynomial R",
    "theorem": "{R : Type u} [semiring R] (n : ℕ) : polynomial R → polynomial R",
    "args": "{R : Type u} [semiring R] (n : ℕ)",
    "doc_string": "`erase p n` is the polynomial `p` in which the `X^n` term has been erased.",
    "kind": "def",
    "type": "polynomial R → polynomial R"
  },
  {
    "name": "computability.Γ'",
    "statement": "inductive computability.Γ'  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A standard Turing machine alphabet, consisting of blank,bit0,bit1,bra,ket,comma.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "topological_space.generate_open",
    "statement": "inductive topological_space.generate_open {α : Type u} (g : set (set α)) : set α → Prop",
    "theorem": "{α : Type u} (g : set (set α)) : set α → Prop",
    "args": "{α : Type u} (g : set (set α))",
    "doc_string": "The open sets of the least topology containing a collection of basic sets.",
    "kind": "inductive",
    "type": "set α → Prop"
  },
  {
    "name": "is_least",
    "statement": "def is_least {α : Type u} [preorder α] (s : set α) (a : α) : Prop",
    "theorem": "{α : Type u} [preorder α] (s : set α) (a : α) : Prop",
    "args": "{α : Type u} [preorder α] (s : set α) (a : α)",
    "doc_string": "`a` is a least element of a set `s`; for a partial order, it is unique if exists.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "measure_theory.induced_outer_measure",
    "statement": "def measure_theory.induced_outer_measure {α : Type u_1} {P : set α → Prop} (m : Π (s : set α), P s → ennreal) (P0 : P ∅) (m0 : m ∅ P0 = 0) : measure_theory.outer_measure α",
    "theorem": "{α : Type u_1} {P : set α → Prop} (m : Π (s : set α), P s → ennreal) (P0 : P ∅) (m0 : m ∅ P0 = 0) : measure_theory.outer_measure α",
    "args": "{α : Type u_1} {P : set α → Prop} (m : Π (s : set α), P s → ennreal) (P0 : P ∅) (m0 : m ∅ P0 = 0)",
    "doc_string": "Given an arbitrary function on a subset of sets, we can define the outer measure corresponding  to it (this is the unique maximal outer measure that is at most `m` on the domain of `m`).",
    "kind": "def",
    "type": "measure_theory.outer_measure α"
  },
  {
    "name": "matrix.sub_left",
    "statement": "def matrix.sub_left {α : Type v} {m l r : ℕ} (A : matrix (fin m) (fin (l + r)) α) : matrix (fin m) (fin l) α",
    "theorem": "{α : Type v} {m l r : ℕ} (A : matrix (fin m) (fin (l + r)) α) : matrix (fin m) (fin l) α",
    "args": "{α : Type v} {m l r : ℕ} (A : matrix (fin m) (fin (l + r)) α)",
    "doc_string": "The left `n × l` part of a `n × (l+r)` matrix.",
    "kind": "def",
    "type": "matrix (fin m) (fin l) α"
  },
  {
    "name": "trunc.lift_on",
    "statement": "def trunc.lift_on {α : Sort u_1} {β : Sort u_2} (q : trunc α) (f : α → β) (c : ∀ (a b : α), f a = f b) : β",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (q : trunc α) (f : α → β) (c : ∀ (a b : α), f a = f b) : β",
    "args": "{α : Sort u_1} {β : Sort u_2} (q : trunc α) (f : α → β) (c : ∀ (a b : α), f a = f b)",
    "doc_string": "Lift a constant function on `q : trunc α`.",
    "kind": "def",
    "type": "β"
  },
  {
    "name": "units",
    "statement": "structure units (α : Type u) [monoid α] : Type u",
    "theorem": "(α : Type u) [monoid α] : Type u",
    "args": "(α : Type u) [monoid α]",
    "doc_string": " Units of a `monoid`, bundled version. Notation: `αˣ`.  An element of a `monoid` is a unit if it has a two-sided inverse. This version bundles the inverse element so that it can be computed. For a predicate see `is_unit`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "snum.tail",
    "statement": "def snum.tail  : snum → snum",
    "theorem": " : snum → snum",
    "args": "",
    "doc_string": "The `tail` of a `snum` is obtained by removing the LSB.      Edge cases: `tail 1 = 0`, `tail (-2) = -1`, `tail 0 = 0` and `tail (-1) = -1`.",
    "kind": "def",
    "type": "snum → snum"
  },
  {
    "name": "multiples.add_mem",
    "statement": "theorem multiples.add_mem {M : Type u_1} [add_monoid M] {x y z : M} : y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x",
    "theorem": "{M : Type u_1} [add_monoid M] {x y z : M} : y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x",
    "args": "{M : Type u_1} [add_monoid M] {x y z : M}",
    "doc_string": "The set of natural number multiples of an element of an `add_monoid` is closed under addition.",
    "kind": "theorem",
    "type": "y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x"
  },
  {
    "name": "Top.presheaf.is_sheaf_opens_le_cover",
    "statement": "def Top.presheaf.is_sheaf_opens_le_cover {C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X) : Prop",
    "args": "{C : Type u} [category_theory.category C] {X : Top} (F : Top.presheaf C X)",
    "doc_string": "An equivalent formulation of the sheaf condition (which we prove equivalent to the usual one below as `is_sheaf_iff_is_sheaf_opens_le_cover`).  A presheaf is a sheaf if `F` sends the cone `(opens_le_cover_cocone U).op` to a limit cone. (Recall `opens_le_cover_cocone U`, has cone point `supr U`, mapping down to any `V` which is contained in some `U i`.)",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "tactic.list_Pi",
    "statement": "def tactic.list_Pi (T : Type u_1) : Type u_1",
    "theorem": "(T : Type u_1) : Type u_1",
    "args": "(T : Type u_1)",
    "doc_string": "A list, with a conjunctive meaning (like a list of constructor arguments, or hypotheses)",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "free_ring.of",
    "statement": "def free_ring.of {α : Type u} (x : α) : free_ring α",
    "theorem": "{α : Type u} (x : α) : free_ring α",
    "args": "{α : Type u} (x : α)",
    "doc_string": "The canonical map from α to `free_ring α`.",
    "kind": "def",
    "type": "free_ring α"
  },
  {
    "name": "subfield.has_top",
    "statement": "def subfield.has_top {K : Type u} [field K] : has_top (subfield K)",
    "theorem": "{K : Type u} [field K] : has_top (subfield K)",
    "args": "{K : Type u} [field K]",
    "doc_string": "The subfield of `K` containing all elements of `K`.",
    "kind": "def",
    "type": "has_top (subfield K)"
  },
  {
    "name": "module.is_torsion_by_set",
    "statement": "def module.is_torsion_by_set (R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : Prop",
    "theorem": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R) : Prop",
    "args": "(R : Type u_1) (M : Type u_2) [comm_semiring R] [add_comm_monoid M] [module R M] (s : set R)",
    "doc_string": "A module where every element is `a`-torsion for all `a` in `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "left.one_le_inv_iff",
    "statement": "theorem left.one_le_inv_iff {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "kind": "theorem",
    "type": "1 ≤ a⁻¹ ↔ a ≤ 1"
  },
  {
    "name": "metric.Hausdorff_dist_empty'",
    "statement": "theorem metric.Hausdorff_dist_empty' {α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist ∅ s = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist ∅ s = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {s : set α}",
    "doc_string": " The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞)",
    "kind": "theorem",
    "type": "metric.Hausdorff_dist ∅ s = 0"
  },
  {
    "name": "module.End.eigenspaces_independent",
    "statement": "theorem module.End.eigenspaces_independent {K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace",
    "theorem": "{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace",
    "args": "{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V)",
    "doc_string": " The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is, any eigenspace has trivial intersection with the span of all the other eigenspaces.",
    "kind": "theorem",
    "type": "complete_lattice.independent f.eigenspace"
  },
  {
    "name": "connected_components.t2",
    "statement": "def connected_components.t2 {α : Type u} [topological_space α] [t2_space α] [compact_space α] : t2_space (connected_components α)",
    "theorem": "{α : Type u} [topological_space α] [t2_space α] [compact_space α] : t2_space (connected_components α)",
    "args": "{α : Type u} [topological_space α] [t2_space α] [compact_space α]",
    "doc_string": "`connected_components α` is Hausdorff when `α` is Hausdorff and compact",
    "kind": "def",
    "type": "t2_space (connected_components α)"
  },
  {
    "name": "zero_lt.left.one_lt_mul_of_lt_of_lt",
    "statement": "theorem zero_lt.left.one_lt_mul_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a)",
    "doc_string": "Assumes left covariance.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "quotient.fin_choice",
    "statement": "def quotient.fin_choice {ι : Type u_1} [decidable_eq ι] [fintype ι] {α : ι → Type u_2} [S : Π (i : ι), setoid (α i)] (f : Π (i : ι), quotient (S i)) : quotient pi_setoid",
    "theorem": "{ι : Type u_1} [decidable_eq ι] [fintype ι] {α : ι → Type u_2} [S : Π (i : ι), setoid (α i)] (f : Π (i : ι), quotient (S i)) : quotient pi_setoid",
    "args": "{ι : Type u_1} [decidable_eq ι] [fintype ι] {α : ι → Type u_2} [S : Π (i : ι), setoid (α i)] (f : Π (i : ι), quotient (S i))",
    "doc_string": " Given a collection of setoids indexed by a fintype `ι` and a function that for each `i : ι` gives a term of the corresponding quotient type, then there is corresponding term in the quotient of the product of the setoids.",
    "kind": "def",
    "type": "quotient pi_setoid"
  },
  {
    "name": "EllipticCurve.disc",
    "statement": "def EllipticCurve.disc {R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R",
    "theorem": "{R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R",
    "args": "{R : Type u_1} [comm_ring R] (E : EllipticCurve R)",
    "doc_string": "The discriminant of an elliptic curve. Sometimes only defined up to sign in the literature;  we choose the sign used by the LMFDB. See  [the LMFDB page on discriminants](https://www.lmfdb.org/knowledge/show/ec.discriminant)  for more discussion.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "has_measurable_inv",
    "statement": "structure has_measurable_inv (G : Type u_1) [has_inv G] [measurable_space G] : Prop",
    "theorem": "(G : Type u_1) [has_inv G] [measurable_space G] : Prop",
    "args": "(G : Type u_1) [has_inv G] [measurable_space G]",
    "doc_string": "We say that a type `has_measurable_inv` if `x ↦ x⁻¹` is a measurable function.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "canonically_ordered_add_monoid",
    "statement": "structure canonically_ordered_add_monoid (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A canonically ordered additive monoid is an ordered commutative additive monoid  in which the ordering coincides with the subtractibility relation,  which is to say, `a ≤ b` iff there exists `c` with `b = a + c`.  This is satisfied by the natural numbers, for example, but not  the integers or other nontrivial `ordered_add_comm_group`s.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "omega.nat.preterm.fresh_index",
    "statement": "def omega.nat.preterm.fresh_index  : omega.nat.preterm → ℕ",
    "theorem": " : omega.nat.preterm → ℕ",
    "args": "",
    "doc_string": "Fresh de Brujin index not used by any variable in argument",
    "kind": "def",
    "type": "omega.nat.preterm → ℕ"
  },
  {
    "name": "upper_set",
    "statement": "structure upper_set (α : Type u_4) [has_le α] : Type u_4",
    "theorem": "(α : Type u_4) [has_le α] : Type u_4",
    "args": "(α : Type u_4) [has_le α]",
    "doc_string": "The type of upper sets of an order.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "pmf.normalize",
    "statement": "def pmf.normalize {α : Type u_1} (f : α → nnreal) (hf0 : tsum f ≠ 0) : pmf α",
    "theorem": "{α : Type u_1} (f : α → nnreal) (hf0 : tsum f ≠ 0) : pmf α",
    "args": "{α : Type u_1} (f : α → nnreal) (hf0 : tsum f ≠ 0)",
    "doc_string": "Given a `f` with non-zero sum, we get a `pmf` by normalizing `f` by it's `tsum`",
    "kind": "def",
    "type": "pmf α"
  },
  {
    "name": "pi_countable.has_dist",
    "statement": "def pi_countable.has_dist {ι : Type u_2} [encodable ι] {F : ι → Type u_3} [Π (i : ι), metric_space (F i)] : has_dist (Π (i : ι), F i)",
    "theorem": "{ι : Type u_2} [encodable ι] {F : ι → Type u_3} [Π (i : ι), metric_space (F i)] : has_dist (Π (i : ι), F i)",
    "args": "{ι : Type u_2} [encodable ι] {F : ι → Type u_3} [Π (i : ι), metric_space (F i)]",
    "doc_string": " Given a countable family of metric spaces, one may put a distance on their product `Π i, E i`. It is highly non-canonical, though, and therefore not registered as a global instance. The distance we use here is `dist x y = ∑' i, min (1/2)^(encode i) (dist (x i) (y i))`.",
    "kind": "def",
    "type": "has_dist (Π (i : ι), F i)"
  },
  {
    "name": "star_semigroup",
    "statement": "structure star_semigroup (R : Type u) [semigroup R] : Type u",
    "theorem": "(R : Type u) [semigroup R] : Type u",
    "args": "(R : Type u) [semigroup R]",
    "doc_string": "A `*`-semigroup is a semigroup `R` with an involutive operations `star` so `star (r * s) = star s * star r`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "category_theory.kleisli",
    "statement": "def category_theory.kleisli {C : Type u} [category_theory.category C] (T : category_theory.monad C) : Type u",
    "theorem": "{C : Type u} [category_theory.category C] (T : category_theory.monad C) : Type u",
    "args": "{C : Type u} [category_theory.category C] (T : category_theory.monad C)",
    "doc_string": "The objects for the Kleisli category of the functor (usually monad) `T : C ⥤ C`, which are the same thing as objects of the base category `C`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "fin.cons_snoc_eq_snoc_cons",
    "statement": "theorem fin.cons_snoc_eq_snoc_cons {n : ℕ} {β : Type u_1} (a : β) (q : fin n → β) (b : β) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b",
    "theorem": "{n : ℕ} {β : Type u_1} (a : β) (q : fin n → β) (b : β) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b",
    "args": "{n : ℕ} {β : Type u_1} (a : β) (q : fin n → β) (b : β)",
    "doc_string": " `cons` and `snoc` commute. We state this lemma in a non-dependent setting, as otherwise it would involve a cast to convince Lean that the two types are equal, making it harder to use.",
    "kind": "theorem",
    "type": "fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b"
  },
  {
    "name": "subalgebra_of_subsemiring",
    "statement": "def subalgebra_of_subsemiring {R : Type u_1} [semiring R] (S : subsemiring R) : subalgebra ℕ R",
    "theorem": "{R : Type u_1} [semiring R] (S : subsemiring R) : subalgebra ℕ R",
    "args": "{R : Type u_1} [semiring R] (S : subsemiring R)",
    "doc_string": "A subsemiring is a `ℕ`-subalgebra.",
    "kind": "def",
    "type": "subalgebra ℕ R"
  },
  {
    "name": "Profinite.to_CompHaus.reflective",
    "statement": "def Profinite.to_CompHaus.reflective  : category_theory.reflective Profinite_to_CompHaus",
    "theorem": " : category_theory.reflective Profinite_to_CompHaus",
    "args": "",
    "doc_string": "The category of profinite sets is reflective in the category of compact hausdroff spaces",
    "kind": "def",
    "type": "category_theory.reflective Profinite_to_CompHaus"
  },
  {
    "name": "category_theory.limits.wide_pullback_shape",
    "statement": "def category_theory.limits.wide_pullback_shape (J : Type v) : Type v",
    "theorem": "(J : Type v) : Type v",
    "args": "(J : Type v)",
    "doc_string": "A wide pullback shape for any type `J` can be written simply as `option J`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "nat.squarefree_mul",
    "statement": "theorem nat.squarefree_mul {m n : ℕ} (hmn : m.coprime n) : squarefree (m * n) ↔ squarefree m ∧ squarefree n",
    "theorem": "{m n : ℕ} (hmn : m.coprime n) : squarefree (m * n) ↔ squarefree m ∧ squarefree n",
    "args": "{m n : ℕ} (hmn : m.coprime n)",
    "doc_string": " `squarefree` is multiplicative. Note that the → direction does not require `hmn` and generalizes to arbitrary commutative monoids. See `squarefree.of_mul_left` and `squarefree.of_mul_right` above for auxiliary lemmas.",
    "kind": "theorem",
    "type": "squarefree (m * n) ↔ squarefree m ∧ squarefree n"
  },
  {
    "name": "preorder.small_category",
    "statement": "def preorder.small_category (α : Type u) [preorder α] : category_theory.small_category α",
    "theorem": "(α : Type u) [preorder α] : category_theory.small_category α",
    "args": "(α : Type u) [preorder α]",
    "doc_string": "The category structure coming from a preorder. There is a morphism `X ⟶ Y` if and only if `X ≤ Y`.  Because we don't allow morphisms to live in `Prop`, we have to define `X ⟶ Y` as `ulift (plift (X ≤ Y))`. See `category_theory.hom_of_le` and `category_theory.le_of_hom`.  See <https://stacks.math.columbia.edu/tag/00D3>.",
    "kind": "def",
    "type": "category_theory.small_category α"
  },
  {
    "name": "right_add_coset_equivalence",
    "statement": "def right_add_coset_equivalence {α : Type u_1} [has_add α] (s : set α) (a b : α) : Prop",
    "theorem": "{α : Type u_1} [has_add α] (s : set α) (a b : α) : Prop",
    "args": "{α : Type u_1} [has_add α] (s : set α) (a b : α)",
    "doc_string": "Equality of two right cosets `s + a` and `s + b`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.limits.has_finite_coproducts_of_has_coproducts",
    "statement": "theorem category_theory.limits.has_finite_coproducts_of_has_coproducts (C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C]",
    "doc_string": "If a category has all coproducts then in particular it has finite coproducts.",
    "kind": "theorem",
    "type": "category_theory.limits.has_finite_coproducts C"
  },
  {
    "name": "antitone",
    "statement": "def antitone {α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "theorem": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β) : Prop",
    "args": "{α : Type u} {β : Type v} [preorder α] [preorder β] (f : α → β)",
    "doc_string": "A function `f` is antitone if `a ≤ b` implies `f b ≤ f a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "seq.ge_stable",
    "statement": "theorem seq.ge_stable {α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ",
    "theorem": "{α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ",
    "args": "{α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ)",
    "doc_string": "If `s.nth n = some aₙ` for some value `aₙ`, then there is also some value `aₘ` such that `s.nth = some aₘ` for `m ≤ n`.",
    "kind": "theorem",
    "type": "∃ (aₘ : α), s.nth m = option.some aₘ"
  },
  {
    "name": "nat.not_exists_sq",
    "statement": "theorem nat.not_exists_sq {n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n",
    "theorem": "{n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n",
    "args": "{n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1))",
    "doc_string": "There are no perfect squares strictly between m² and (m+1)²",
    "kind": "theorem",
    "type": "¬∃ (t : ℕ), t * t = n"
  },
  {
    "name": "list.split_wrt_composition",
    "statement": "def list.split_wrt_composition {n : ℕ} {α : Type u_1} (l : list α) (c : composition n) : list (list α)",
    "theorem": "{n : ℕ} {α : Type u_1} (l : list α) (c : composition n) : list (list α)",
    "args": "{n : ℕ} {α : Type u_1} (l : list α) (c : composition n)",
    "doc_string": " Given a list of length `n` and a composition `[i₁, ..., iₖ]` of `n`, split `l` into a list of `k` lists corresponding to the blocks of the composition, of respective lengths `i₁`, ..., `iₖ`. This makes sense mostly when `n = l.length`, but this is not necessary for the definition.",
    "kind": "def",
    "type": "list (list α)"
  },
  {
    "name": "complete_space_of_is_complete_univ",
    "statement": "theorem complete_space_of_is_complete_univ {α : Type u} [uniform_space α] (h : is_complete set.univ) : complete_space α",
    "theorem": "{α : Type u} [uniform_space α] (h : is_complete set.univ) : complete_space α",
    "args": "{α : Type u} [uniform_space α] (h : is_complete set.univ)",
    "doc_string": "If `univ` is complete, the space is a complete space",
    "kind": "theorem",
    "type": "complete_space α"
  },
  {
    "name": "multiset.Ico_eq_zero",
    "statement": "theorem multiset.Ico_eq_zero {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ico a b = 0",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ico a b = 0",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of multiset.Ico_eq_zero_iff`.",
    "kind": "theorem",
    "type": "¬a < b → multiset.Ico a b = 0"
  },
  {
    "name": "finite_dimensional.finrank_pos_iff_exists_ne_zero",
    "statement": "theorem finite_dimensional.finrank_pos_iff_exists_ne_zero {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V]",
    "doc_string": "A finite dimensional space has positive `finrank` iff it has a nonzero element.",
    "kind": "theorem",
    "type": "0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0"
  },
  {
    "name": "add_hom.comp",
    "statement": "def add_hom.comp {M : Type u_3} {N : Type u_4} {P : Type u_5} [has_add M] [has_add N] [has_add P] (hnp : add_hom N P) (hmn : add_hom M N) : add_hom M P",
    "theorem": "{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_add M] [has_add N] [has_add P] (hnp : add_hom N P) (hmn : add_hom M N) : add_hom M P",
    "args": "{M : Type u_3} {N : Type u_4} {P : Type u_5} [has_add M] [has_add N] [has_add P] (hnp : add_hom N P) (hmn : add_hom M N)",
    "doc_string": "Composition of `add_hom`s as a `add_hom`.",
    "kind": "def",
    "type": "add_hom M P"
  },
  {
    "name": "matrix.col",
    "statement": "def matrix.col {m : Type u_2} {α : Type v} (w : m → α) : matrix m unit α",
    "theorem": "{m : Type u_2} {α : Type v} (w : m → α) : matrix m unit α",
    "args": "{m : Type u_2} {α : Type v} (w : m → α)",
    "doc_string": "`matrix.col u` is the column matrix whose entries are given by `u`.",
    "kind": "def",
    "type": "matrix m unit α"
  },
  {
    "name": "computation.bind",
    "statement": "def computation.bind {α : Type u} {β : Type v} (c : computation α) (f : α → computation β) : computation β",
    "theorem": "{α : Type u} {β : Type v} (c : computation α) (f : α → computation β) : computation β",
    "args": "{α : Type u} {β : Type v} (c : computation α) (f : α → computation β)",
    "doc_string": "Compose two computations into a monadic `bind` operation.",
    "kind": "def",
    "type": "computation β"
  },
  {
    "name": "BoolAlg.to_BoundedDistribLattice",
    "statement": "def BoolAlg.to_BoundedDistribLattice (X : BoolAlg) : BoundedDistribLattice",
    "theorem": "(X : BoolAlg) : BoundedDistribLattice",
    "args": "(X : BoolAlg)",
    "doc_string": "Turn a `BoolAlg` into a `BoundedDistribLattice` by forgetting its complement operation.",
    "kind": "def",
    "type": "BoundedDistribLattice"
  },
  {
    "name": "padic_val_rat.finite_int_prime_iff",
    "statement": "theorem padic_val_rat.finite_int_prime_iff {p : ℕ} [p_prime : fact (nat.prime p)] {a : ℤ} : multiplicity.finite ↑p a ↔ a ≠ 0",
    "theorem": "{p : ℕ} [p_prime : fact (nat.prime p)] {a : ℤ} : multiplicity.finite ↑p a ↔ a ≠ 0",
    "args": "{p : ℕ} [p_prime : fact (nat.prime p)] {a : ℤ}",
    "doc_string": "The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`.",
    "kind": "theorem",
    "type": "multiplicity.finite ↑p a ↔ a ≠ 0"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg_lt_one",
    "statement": "theorem generalized_continued_fraction.int_fract_pair.nth_stream_fr_nonneg_lt_one {K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1",
    "theorem": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1",
    "args": "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n)",
    "doc_string": "Shows that the fractional parts of the stream are in `[0,1)`.",
    "kind": "theorem",
    "type": "0 ≤ ifp_n.fr ∧ ifp_n.fr < 1"
  },
  {
    "name": "matrix.is_unit_iff_is_unit_det",
    "statement": "theorem matrix.is_unit_iff_is_unit_det {n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : is_unit A ↔ is_unit A.det",
    "theorem": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : is_unit A ↔ is_unit A.det",
    "args": "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α)",
    "doc_string": "When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`.",
    "kind": "theorem",
    "type": "is_unit A ↔ is_unit A.det"
  },
  {
    "name": "function.cantor_injective",
    "statement": "theorem function.cantor_injective {α : Type u_1} (f : set α → α) : ¬function.injective f",
    "theorem": "{α : Type u_1} (f : set α → α) : ¬function.injective f",
    "args": "{α : Type u_1} (f : set α → α)",
    "doc_string": " **Cantor's diagonal argument** implies that there are no injective functions from `set α` to `α`.",
    "kind": "theorem",
    "type": "¬function.injective f"
  },
  {
    "name": "list.kextract",
    "statement": "def list.kextract {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → option (β a) × list (sigma β)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) : list (sigma β) → option (β a) × list (sigma β)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α)",
    "doc_string": " Finds the first entry with a given key `a` and returns its value (as an `option` because there might be no entry with key `a`) alongside with the rest of the entries.",
    "kind": "def",
    "type": "list (sigma β) → option (β a) × list (sigma β)"
  },
  {
    "name": "category_theory.limits.has_wide_pullbacks",
    "statement": "def category_theory.limits.has_wide_pullbacks (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "`has_wide_pullbacks` represents a choice of wide pullback for every collection of morphisms",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "linear_ordered_comm_group_with_zero",
    "statement": "structure linear_ordered_comm_group_with_zero (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A linearly ordered commutative group with a zero element.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "order.lt_succ_of_not_is_max",
    "statement": "theorem order.lt_succ_of_not_is_max {α : Type u_1} [preorder α] [succ_order α] {a : α} : ¬is_max a → a < order.succ a",
    "theorem": "{α : Type u_1} [preorder α] [succ_order α] {a : α} : ¬is_max a → a < order.succ a",
    "args": "{α : Type u_1} [preorder α] [succ_order α] {a : α}",
    "doc_string": "**Alias** of the reverse direction of order.lt_succ_iff_not_is_max`.",
    "kind": "theorem",
    "type": "¬is_max a → a < order.succ a"
  },
  {
    "name": "add_aut",
    "statement": "def add_aut (M : Type u_1) [has_add M] : Type u_1",
    "theorem": "(M : Type u_1) [has_add M] : Type u_1",
    "args": "(M : Type u_1) [has_add M]",
    "doc_string": "The group of additive automorphisms.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "seq_continuous.continuous",
    "statement": "theorem seq_continuous.continuous {X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : seq_continuous f → continuous f",
    "theorem": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : seq_continuous f → continuous f",
    "args": "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X]",
    "doc_string": "**Alias** of the reverse direction of continuous_iff_seq_continuous`.",
    "kind": "theorem",
    "type": "seq_continuous f → continuous f"
  },
  {
    "name": "add_order_of_pos",
    "statement": "theorem add_order_of_pos {G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x",
    "theorem": "{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x",
    "args": "{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G)",
    "doc_string": "This is the same as `add_order_of_pos' but with one fewer explicit assumption since this is   automatic in case of a finite cancellative additive monoid.",
    "kind": "theorem",
    "type": "0 < add_order_of x"
  },
  {
    "name": "pi_nat.shortest_prefix_diff",
    "statement": "def pi_nat.shortest_prefix_diff {E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (s : set (Π (n : ℕ), E n)) : ℕ",
    "theorem": "{E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (s : set (Π (n : ℕ), E n)) : ℕ",
    "args": "{E : ℕ → Type u_1} (x : Π (n : ℕ), E n) (s : set (Π (n : ℕ), E n))",
    "doc_string": " Given a point `x` in a product space `Π (n : ℕ), E n`, and `s` a subset of this space, then `shortest_prefix_diff x s` if the smallest `n` for which there is no element of `s` having the same prefix of length `n` as `x`. If there is no such `n`, then use `0` by convention.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "subsemigroup.has_inf",
    "statement": "def subsemigroup.has_inf {M : Type u_1} [has_mul M] : has_inf (subsemigroup M)",
    "theorem": "{M : Type u_1} [has_mul M] : has_inf (subsemigroup M)",
    "args": "{M : Type u_1} [has_mul M]",
    "doc_string": "The inf of two subsemigroups is their intersection.",
    "kind": "def",
    "type": "has_inf (subsemigroup M)"
  },
  {
    "name": "add_submonoid.prod",
    "statement": "def add_submonoid.prod {M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (s : add_submonoid M) (t : add_submonoid N) : add_submonoid (M × N)",
    "theorem": "{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (s : add_submonoid M) (t : add_submonoid N) : add_submonoid (M × N)",
    "args": "{M : Type u_1} {N : Type u_2} [add_zero_class M] [add_zero_class N] (s : add_submonoid M) (t : add_submonoid N)",
    "doc_string": "Given `add_submonoid`s `s`, `t` of `add_monoid`s `A`, `B` respectively, `s × t` as an `add_submonoid` of `A × B`.",
    "kind": "def",
    "type": "add_submonoid (M × N)"
  },
  {
    "name": "list.lex",
    "statement": "inductive list.lex {α : Type u} (r : α → α → Prop) : list α → list α → Prop",
    "theorem": "{α : Type u} (r : α → α → Prop) : list α → list α → Prop",
    "args": "{α : Type u} (r : α → α → Prop)",
    "doc_string": " Given a strict order `<` on `α`, the lexicographic strict order on `list α`, for which `[a0, ..., an] < [b0, ..., b_k]` if `a0 < b0` or `a0 = b0` and `[a1, ..., an] < [b1, ..., bk]`. The definition is given for any relation `r`, not only strict orders.",
    "kind": "inductive",
    "type": "list α → list α → Prop"
  },
  {
    "name": "set.mul_one_class",
    "statement": "def set.mul_one_class {α : Type u_2} [mul_one_class α] : mul_one_class (set α)",
    "theorem": "{α : Type u_2} [mul_one_class α] : mul_one_class (set α)",
    "args": "{α : Type u_2} [mul_one_class α]",
    "doc_string": "`set α` is a `mul_one_class` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "mul_one_class (set α)"
  },
  {
    "name": "right.add_nonpos",
    "statement": "theorem right.add_nonpos {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0)",
    "doc_string": "Assumes right covariance. The lemma assuming left covariance is `left.add_nonpos`.",
    "kind": "theorem",
    "type": "a + b ≤ 0"
  },
  {
    "name": "padic_val_rat.zero",
    "statement": "theorem padic_val_rat.zero (m : ℕ) : padic_val_rat m 0 = 0",
    "theorem": "(m : ℕ) : padic_val_rat m 0 = 0",
    "args": "(m : ℕ)",
    "doc_string": "`padic_val_rat p 0` is 0 for any `p`.",
    "kind": "theorem",
    "type": "padic_val_rat m 0 = 0"
  },
  {
    "name": "add_con.coe_add",
    "statement": "theorem add_con.coe_add {M : Type u_1} [has_add M] {c : add_con M} (x y : M) : ↑(x + y) = ↑x + ↑y",
    "theorem": "{M : Type u_1} [has_add M] {c : add_con M} (x y : M) : ↑(x + y) = ↑x + ↑y",
    "args": "{M : Type u_1} [has_add M] {c : add_con M} (x y : M)",
    "doc_string": "The coercion to the quotient of an additive congruence relation commutes with addition (by definition).",
    "kind": "theorem",
    "type": "↑(x + y) = ↑x + ↑y"
  },
  {
    "name": "function.semiconj₂",
    "statement": "def function.semiconj₂ {α : Type u_1} {β : Type u_2} (f : α → β) (ga : α → α → α) (gb : β → β → β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (f : α → β) (ga : α → α → α) (gb : β → β → β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} (f : α → β) (ga : α → α → α) (gb : β → β → β)",
    "doc_string": " A map `f` semiconjugates a binary operation `ga` to a binary operation `gb` if for all `x`, `y` we have `f (ga x y) = gb (f x) (f y)`. E.g., a `monoid_hom` semiconjugates `(*)` to `(*)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "continuous_monoid_hom.id",
    "statement": "def continuous_monoid_hom.id (A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A A",
    "theorem": "(A : Type u_4) [monoid A] [topological_space A] : continuous_monoid_hom A A",
    "args": "(A : Type u_4) [monoid A] [topological_space A]",
    "doc_string": "The identity continuous homomorphism.",
    "kind": "def",
    "type": "continuous_monoid_hom A A"
  },
  {
    "name": "category_theory.limits.binary_biproduct.bicone",
    "statement": "def category_theory.limits.binary_biproduct.bicone {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q] : category_theory.limits.binary_bicone P Q",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q] : category_theory.limits.binary_bicone P Q",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) [category_theory.limits.has_binary_biproduct P Q]",
    "doc_string": "A bicone for `P Q ` which is both a limit cone and a colimit cocone.",
    "kind": "def",
    "type": "category_theory.limits.binary_bicone P Q"
  },
  {
    "name": "smodeq",
    "statement": "def smodeq {R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] (U : submodule R M) (x y : M) : Prop",
    "theorem": "{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] (U : submodule R M) (x y : M) : Prop",
    "args": "{R : Type u_1} [ring R] {M : Type u_2} [add_comm_group M] [module R M] (U : submodule R M) (x y : M)",
    "doc_string": "A predicate saying two elements of a module are equivalent modulo a submodule.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "set.has_add",
    "statement": "def set.has_add {α : Type u_2} [has_add α] : has_add (set α)",
    "theorem": "{α : Type u_2} [has_add α] : has_add (set α)",
    "args": "{α : Type u_2} [has_add α]",
    "doc_string": "The pointwise addition of sets `s + t` is defined as `{x + y | x ∈ s, y ∈ t}` in locale `pointwise`.",
    "kind": "def",
    "type": "has_add (set α)"
  },
  {
    "name": "intermediate_field.adjoin_adjoin_left",
    "statement": "theorem intermediate_field.adjoin_adjoin_left (F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : ↑(intermediate_field.adjoin ↥(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S ∪ T)",
    "theorem": "(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E) : ↑(intermediate_field.adjoin ↥(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S ∪ T)",
    "args": "(F : Type u_1) [field F] {E : Type u_2} [field E] [algebra F E] (S T : set E)",
    "doc_string": "`F[S][T] = F[S ∪ T]`",
    "kind": "theorem",
    "type": "↑(intermediate_field.adjoin ↥(intermediate_field.adjoin F S) T) = intermediate_field.adjoin F (S ∪ T)"
  },
  {
    "name": "add_monoid_algebra.of'",
    "statement": "def add_monoid_algebra.of' (k : Type u₁) (G : Type u₂) [semiring k] : G → add_monoid_algebra k G",
    "theorem": "(k : Type u₁) (G : Type u₂) [semiring k] : G → add_monoid_algebra k G",
    "args": "(k : Type u₁) (G : Type u₂) [semiring k]",
    "doc_string": "Embedding of a magma with zero `G`, into its magma algebra, having `G` as source.",
    "kind": "def",
    "type": "G → add_monoid_algebra k G"
  },
  {
    "name": "nat.min_fac_aux",
    "statement": "def nat.min_fac_aux (n : ℕ) : ℕ → ℕ",
    "theorem": "(n : ℕ) : ℕ → ℕ",
    "args": "(n : ℕ)",
    "doc_string": "If `n < k * k`, then `min_fac_aux n k = n`, if `k | n`, then `min_fac_aux n k = k`.  Otherwise, `min_fac_aux n k = min_fac_aux n (k+2)` using well-founded recursion.  If `n` is odd and `1 < n`, then then `min_fac_aux n 3` is the smallest prime factor of `n`.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "EllipticCurve.j",
    "statement": "def EllipticCurve.j {R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R",
    "theorem": "{R : Type u_1} [comm_ring R] (E : EllipticCurve R) : R",
    "args": "{R : Type u_1} [comm_ring R] (E : EllipticCurve R)",
    "doc_string": "The j-invariant of an elliptic curve.",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "subtype.exists'",
    "statement": "theorem subtype.exists' {α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _",
    "theorem": "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _",
    "args": "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop}",
    "doc_string": "An alternative version of `subtype.exists`. This one is useful if Lean cannot figure out `q`  when using `subtype.exists` from right to left.",
    "kind": "theorem",
    "type": "(∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _"
  },
  {
    "name": "valuation",
    "statement": "structure valuation (R : Type u_2) (Γ₀ : Type u_3) [linear_ordered_comm_monoid_with_zero Γ₀] [ring R] : Type (max u_2 u_3)",
    "theorem": "(R : Type u_2) (Γ₀ : Type u_3) [linear_ordered_comm_monoid_with_zero Γ₀] [ring R] : Type (max u_2 u_3)",
    "args": "(R : Type u_2) (Γ₀ : Type u_3) [linear_ordered_comm_monoid_with_zero Γ₀] [ring R]",
    "doc_string": " The type of `Γ₀`-valued valuations on `R`.  When you extend this structure, make sure to extend `valuation_class`.",
    "kind": "structure",
    "type": "Type (max u_2 u_3)"
  },
  {
    "name": "pgame.star",
    "statement": "def pgame.star  : pgame",
    "theorem": " : pgame",
    "args": "",
    "doc_string": "The pre-game `star`, which is fuzzy with zero.",
    "kind": "def",
    "type": "pgame"
  },
  {
    "name": "ordered_ring",
    "statement": "structure ordered_ring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": " An `ordered_ring α` is a ring `α` with a partial order such that addition is monotone and multiplication by a positive number is strictly monotone.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "function.periodic_orbit",
    "statement": "def function.periodic_orbit {α : Type u_1} (f : α → α) (x : α) : cycle α",
    "theorem": "{α : Type u_1} (f : α → α) (x : α) : cycle α",
    "args": "{α : Type u_1} (f : α → α) (x : α)",
    "doc_string": " The orbit of a periodic point `x` of `f` is the cycle `[x, f x, f (f x), ...]`. Its length is the minimal period of `x`.  If `x` is not a periodic point, then this is the empty (aka nil) cycle.",
    "kind": "def",
    "type": "cycle α"
  },
  {
    "name": "part.some",
    "statement": "def part.some {α : Type u_1} (a : α) : part α",
    "theorem": "{α : Type u_1} (a : α) : part α",
    "args": "{α : Type u_1} (a : α)",
    "doc_string": "The `some a` value in `part` has a `true` domain and the  function returns `a`.",
    "kind": "def",
    "type": "part α"
  },
  {
    "name": "metric.metric_space_sum",
    "statement": "def metric.metric_space_sum {X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : metric_space (X ⊕ Y)",
    "theorem": "{X : Type u} {Y : Type v} [metric_space X] [metric_space Y] : metric_space (X ⊕ Y)",
    "args": "{X : Type u} {Y : Type v} [metric_space X] [metric_space Y]",
    "doc_string": " The distance on the disjoint union indeed defines a metric space. All the distance properties follow from our choice of the distance. The harder work is to show that the uniform structure defined by the distance coincides with the disjoint union uniform structure.",
    "kind": "def",
    "type": "metric_space (X ⊕ Y)"
  },
  {
    "name": "submonoid.localization_map",
    "statement": "structure submonoid.localization_map {M : Type u_1} [comm_monoid M] (S : submonoid M) (N : Type u_2) [comm_monoid N] : Type (max u_1 u_2)",
    "theorem": "{M : Type u_1} [comm_monoid M] (S : submonoid M) (N : Type u_2) [comm_monoid N] : Type (max u_1 u_2)",
    "args": "{M : Type u_1} [comm_monoid M] (S : submonoid M) (N : Type u_2) [comm_monoid N]",
    "doc_string": " The type of monoid homomorphisms satisfying the characteristic predicate: if `f : M →* N` satisfies this predicate, then `N` is isomorphic to the localization of `M` at `S`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "lt_of_tsub_lt_tsub_right_of_le",
    "statement": "theorem lt_of_tsub_lt_tsub_right_of_le {α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c) : a < b",
    "theorem": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c) : a < b",
    "args": "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c)",
    "doc_string": "See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order.",
    "kind": "theorem",
    "type": "a < b"
  },
  {
    "name": "Set.sep",
    "statement": "def Set.sep (p : Set → Prop) : Set → Set",
    "theorem": "(p : Set → Prop) : Set → Set",
    "args": "(p : Set → Prop)",
    "doc_string": "`{x ∈ a | p x}` is the set of elements in `a` satisfying `p`",
    "kind": "def",
    "type": "Set → Set"
  },
  {
    "name": "is_preconnected.subset_closure",
    "statement": "theorem is_preconnected.subset_closure {α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : is_preconnected t",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : is_preconnected t",
    "args": "{α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s)",
    "doc_string": " Theorem of bark and tree : if a set is within a (pre)connected set and its closure, then it is (pre)connected as well.",
    "kind": "theorem",
    "type": "is_preconnected t"
  },
  {
    "name": "is_add_group_hom.to_is_add_monoid_hom",
    "statement": "theorem is_add_group_hom.to_is_add_monoid_hom {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f)",
    "doc_string": "An additive group homomorphism is an additive monoid homomorphism.",
    "kind": "theorem",
    "type": "is_add_monoid_hom f"
  },
  {
    "name": "add_add_hom",
    "statement": "def add_add_hom {α : Type u_8} [add_comm_semigroup α] : add_hom (α × α) α",
    "theorem": "{α : Type u_8} [add_comm_semigroup α] : add_hom (α × α) α",
    "args": "{α : Type u_8} [add_comm_semigroup α]",
    "doc_string": "Addition as an additive homomorphism.",
    "kind": "def",
    "type": "add_hom (α × α) α"
  },
  {
    "name": "charted_space_core",
    "statement": "structure charted_space_core (H : Type u_5) [topological_space H] (M : Type u_6) : Type (max u_5 u_6)",
    "theorem": "(H : Type u_5) [topological_space H] (M : Type u_6) : Type (max u_5 u_6)",
    "args": "(H : Type u_5) [topological_space H] (M : Type u_6)",
    "doc_string": " Sometimes, one may want to construct a charted space structure on a space which does not yet have a topological structure, where the topology would come from the charts. For this, one needs charts that are only local equivs, and continuity properties for their composition. This is formalised in `charted_space_core`.",
    "kind": "structure",
    "type": "Type (max u_5 u_6)"
  },
  {
    "name": "continuous_monoid_hom.one",
    "statement": "def continuous_monoid_hom.one (A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A B",
    "theorem": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B] : continuous_monoid_hom A B",
    "args": "(A : Type u_4) (B : Type u_5) [monoid A] [monoid B] [topological_space A] [topological_space B]",
    "doc_string": "The trivial continuous homomorphism.",
    "kind": "def",
    "type": "continuous_monoid_hom A B"
  },
  {
    "name": "wseq.length",
    "statement": "def wseq.length {α : Type u} (s : wseq α) : computation ℕ",
    "theorem": "{α : Type u} (s : wseq α) : computation ℕ",
    "args": "{α : Type u} (s : wseq α)",
    "doc_string": "Get the length of `s` (if it is finite and completes in finite time).",
    "kind": "def",
    "type": "computation ℕ"
  },
  {
    "name": "normed_comm_ring",
    "statement": "structure normed_comm_ring (α : Type u_5) : Type u_5",
    "theorem": "(α : Type u_5) : Type u_5",
    "args": "(α : Type u_5)",
    "doc_string": " A normed commutative ring is a commutative ring endowed with a norm which satisfies the inequality `∥x y∥ ≤ ∥x∥ ∥y∥`.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "semiquot.mk",
    "statement": "def semiquot.mk {α : Type u_1} {a : α} {s : set α} (h : a ∈ s) : semiquot α",
    "theorem": "{α : Type u_1} {a : α} {s : set α} (h : a ∈ s) : semiquot α",
    "args": "{α : Type u_1} {a : α} {s : set α} (h : a ∈ s)",
    "doc_string": "Construct a `semiquot α` from `h : a ∈ s` where `s : set α`.",
    "kind": "def",
    "type": "semiquot α"
  },
  {
    "name": "turing.partrec_to_TM2.Λ'",
    "statement": "inductive turing.partrec_to_TM2.Λ'  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The set of program positions. We make extensive use of inductive types here to let us describe \"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where `q` is another label. In order to prevent this from resulting in an infinite number of distinct accessible states, we are careful to be non-recursive (although loops are okay). See the section documentation for a description of all the programs.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "category_theory.over.construct_products.over_product_of_wide_pullback",
    "statement": "theorem category_theory.over.construct_products.over_product_of_wide_pullback {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C}",
    "doc_string": "Given a wide pullback in `C`, construct a product in `C/B`.",
    "kind": "theorem",
    "type": "category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)"
  },
  {
    "name": "list.kreplace",
    "statement": "def list.kreplace {α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) : list (sigma β) → list (sigma β)",
    "theorem": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a) : list (sigma β) → list (sigma β)",
    "args": "{α : Type u} {β : α → Type v} [decidable_eq α] (a : α) (b : β a)",
    "doc_string": "Replaces the first value with key `a` by `b`.",
    "kind": "def",
    "type": "list (sigma β) → list (sigma β)"
  },
  {
    "name": "associates.factors'",
    "statement": "def associates.factors' {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [dec : decidable_eq α] (a : α) : multiset {a // irreducible a}",
    "theorem": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [dec : decidable_eq α] (a : α) : multiset {a // irreducible a}",
    "args": "{α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [dec : decidable_eq α] (a : α)",
    "doc_string": "This returns the multiset of irreducible factors as a `factor_set`,  a multiset of irreducible associates `with_top`.",
    "kind": "def",
    "type": "multiset {a // irreducible a}"
  },
  {
    "name": "tropical.untrop",
    "statement": "def tropical.untrop {R : Type u} : tropical R → R",
    "theorem": "{R : Type u} : tropical R → R",
    "args": "{R : Type u}",
    "doc_string": " Reinterpret `x : tropical R` as an element of `R`. See `tropical.trop_equiv` for the equivalence.",
    "kind": "def",
    "type": "tropical R → R"
  },
  {
    "name": "complete_lattice.to_conditionally_complete_lattice",
    "statement": "def complete_lattice.to_conditionally_complete_lattice {α : Type u_1} [complete_lattice α] : conditionally_complete_lattice α",
    "theorem": "{α : Type u_1} [complete_lattice α] : conditionally_complete_lattice α",
    "args": "{α : Type u_1} [complete_lattice α]",
    "doc_string": " A complete lattice is a conditionally complete lattice, as there are no restrictions on the properties of Inf and Sup in a complete lattice.",
    "kind": "def",
    "type": "conditionally_complete_lattice α"
  },
  {
    "name": "pell.pell",
    "statement": "def pell.pell {a : ℕ} (a1 : 1 < a) : ℕ → ℕ × ℕ",
    "theorem": "{a : ℕ} (a1 : 1 < a) : ℕ → ℕ × ℕ",
    "args": "{a : ℕ} (a1 : 1 < a)",
    "doc_string": " The Pell sequences, i.e. the sequence of integer solutions to `x ^ 2 - d * y ^ 2 = 1`, where `d = a ^ 2 - 1`, defined together in mutual recursion.",
    "kind": "def",
    "type": "ℕ → ℕ × ℕ"
  },
  {
    "name": "rand.split",
    "statement": "def rand.split (g : Type) [random_gen g] : rand_g g g",
    "theorem": "(g : Type) [random_gen g] : rand_g g g",
    "args": "(g : Type) [random_gen g]",
    "doc_string": "create a new random number generator distinct from the one stored in the state",
    "kind": "def",
    "type": "rand_g g g"
  },
  {
    "name": "lie_ring.to_non_unital_non_assoc_semiring",
    "statement": "def lie_ring.to_non_unital_non_assoc_semiring (L : Type v) [lie_ring L] : non_unital_non_assoc_semiring L",
    "theorem": "(L : Type v) [lie_ring L] : non_unital_non_assoc_semiring L",
    "args": "(L : Type v) [lie_ring L]",
    "doc_string": " A `lie_ring` can be regarded as a `non_unital_non_assoc_semiring` by turning its `has_bracket` (denoted `⁅, ⁆`) into a `has_mul` (denoted `*`).",
    "kind": "def",
    "type": "non_unital_non_assoc_semiring L"
  },
  {
    "name": "list.insert_nth",
    "statement": "def list.insert_nth {α : Type u_1} (n : ℕ) (a : α) : list α → list α",
    "theorem": "{α : Type u_1} (n : ℕ) (a : α) : list α → list α",
    "args": "{α : Type u_1} (n : ℕ) (a : α)",
    "doc_string": "`insert_nth n a l` inserts `a` into the list `l` after the first `n` elements of `l` `insert_nth 2 1 [1, 2, 3, 4] = [1, 2, 1, 3, 4]`",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "measurable_equiv",
    "statement": "structure measurable_equiv (α : Type u_7) (β : Type u_8) [measurable_space α] [measurable_space β] : Type (max u_7 u_8)",
    "theorem": "(α : Type u_7) (β : Type u_8) [measurable_space α] [measurable_space β] : Type (max u_7 u_8)",
    "args": "(α : Type u_7) (β : Type u_8) [measurable_space α] [measurable_space β]",
    "doc_string": " Equivalences between measurable spaces. Main application is the simplification of measurability statements along measurable equivalences.",
    "kind": "structure",
    "type": "Type (max u_7 u_8)"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.stream",
    "statement": "def generalized_continued_fraction.int_fract_pair.stream {K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : stream (option (generalized_continued_fraction.int_fract_pair K))",
    "theorem": "{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K) : stream (option (generalized_continued_fraction.int_fract_pair K))",
    "args": "{K : Type u_1} [linear_ordered_field K] [floor_ring K] (v : K)",
    "doc_string": "Creates the stream of integer and fractional parts of a value `v` needed to obtain the continued fraction representation of `v` in `generalized_continued_fraction.of`. More precisely, given a value `v : K`, it recursively computes a stream of option `ℤ × K` pairs as follows: - `stream v 0 = some ⟨⌊v⌋, v - ⌊v⌋⟩` - `stream v (n + 1) = some ⟨⌊frₙ⁻¹⌋, frₙ⁻¹ - ⌊frₙ⁻¹⌋⟩`,     if `stream v n = some ⟨_, frₙ⟩` and `frₙ ≠ 0` - `stream v (n + 1) = none`, otherwise  For example, let `(v : ℚ) := 3.4`. The process goes as follows: - `stream v 0 = some ⟨⌊v⌋, v - ⌊v⌋⟩ = some ⟨3, 0.4⟩` - `stream v 1 = some ⟨⌊0.4⁻¹⌋, 0.4⁻¹ - ⌊0.4⁻¹⌋⟩ = some ⟨⌊2.5⌋, 2.5 - ⌊2.5⌋⟩ = some ⟨2, 0.5⟩` - `stream v 2 = some ⟨⌊0.5⁻¹⌋, 0.5⁻¹ - ⌊0.5⁻¹⌋⟩ = some ⟨⌊2⌋, 2 - ⌊2⌋⟩ = some ⟨2, 0⟩` - `stream v n = none`, for `n ≥ 3`",
    "kind": "def",
    "type": "stream (option (generalized_continued_fraction.int_fract_pair K))"
  },
  {
    "name": "slim_check.sampleable_bifunctor",
    "statement": "structure slim_check.sampleable_bifunctor (F : Type u → Type v → Type w) [bifunctor F] : Type (max (u+1) (v+1) w)",
    "theorem": "(F : Type u → Type v → Type w) [bifunctor F] : Type (max (u+1) (v+1) w)",
    "args": "(F : Type u → Type v → Type w) [bifunctor F]",
    "doc_string": " `sampleable_bifunctor F` makes it possible to create samples of and shrink `F α β` given a sampling function and a shrinking function for arbitrary `α` and `β`",
    "kind": "structure",
    "type": "Type (max (u+1) (v+1) w)"
  },
  {
    "name": "ordnode.mem",
    "statement": "def ordnode.mem {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → bool",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → bool",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": " O(log n). Does the set (approximately) contain the element `x`? That is, is there an element that is equivalent to `x` in the order?      1 ∈ {1, 2, 3} = true     4 ∈ {1, 2, 3} = false  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      (1, 1) ∈ {(0, 1), (1, 2)} = true     (3, 1) ∈ {(0, 1), (1, 2)} = false",
    "kind": "def",
    "type": "ordnode α → bool"
  },
  {
    "name": "composition_as_set.to_composition",
    "statement": "def composition_as_set.to_composition {n : ℕ} (c : composition_as_set n) : composition n",
    "theorem": "{n : ℕ} (c : composition_as_set n) : composition n",
    "args": "{n : ℕ} (c : composition_as_set n)",
    "doc_string": " Associating a `composition n` to a `composition_as_set n`, by registering the sizes of the blocks as a list of positive integers.",
    "kind": "def",
    "type": "composition n"
  },
  {
    "name": "measurable.of_le_map",
    "statement": "theorem measurable.of_le_map {α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : m₂ ≤ measurable_space.map f m₁ → measurable f",
    "theorem": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : m₂ ≤ measurable_space.map f m₁ → measurable f",
    "args": "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β}",
    "doc_string": "**Alias** of the reverse direction of measurable_iff_le_map`.",
    "kind": "theorem",
    "type": "m₂ ≤ measurable_space.map f m₁ → measurable f"
  },
  {
    "name": "category_theory.limits.types.has_limits_of_size",
    "statement": "def category_theory.limits.types.has_limits_of_size  : category_theory.limits.has_limits_of_size (Type (max v u))",
    "theorem": " : category_theory.limits.has_limits_of_size (Type (max v u))",
    "args": "",
    "doc_string": "The category of types has all limits.  See <https://stacks.math.columbia.edu/tag/002U>.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size (Type (max v u))"
  },
  {
    "name": "ordered_comm_monoid",
    "statement": "structure ordered_comm_monoid (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": " An ordered commutative monoid is a commutative monoid with a partial order such that `a ≤ b → c * a ≤ c * b` (multiplication is monotone)",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "id_tag",
    "statement": "def id_tag (tag : unit) {p : Prop} (h : p) : p",
    "theorem": "(tag : unit) {p : Prop} (h : p) : p",
    "args": "(tag : unit) {p : Prop} (h : p)",
    "doc_string": "For tactics to tag the proofs they construct. The tag is `unit` but is intended to be encoded by a constant, e.g. def tagged_proof.ring : unit := ()",
    "kind": "def",
    "type": "p"
  },
  {
    "name": "category_theory.pretopology.to_grothendieck",
    "statement": "def category_theory.pretopology.to_grothendieck (C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.grothendieck_topology C",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C) : category_theory.grothendieck_topology C",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_pullbacks C] (K : category_theory.pretopology C)",
    "doc_string": "A pretopology `K` can be completed to a Grothendieck topology `J` by declaring a sieve to be `J`-covering if it contains a family in `K`.  See <https://stacks.math.columbia.edu/tag/00ZC>, or [MM92] Chapter III, Section 2, Equation (2).",
    "kind": "def",
    "type": "category_theory.grothendieck_topology C"
  },
  {
    "name": "add_order_of",
    "statement": "def add_order_of {G : Type u} [add_monoid G] (x : G) : ℕ",
    "theorem": "{G : Type u} [add_monoid G] (x : G) : ℕ",
    "args": "{G : Type u} [add_monoid G] (x : G)",
    "doc_string": "`add_order_of a` is the order of the element `a`, i.e. the `n ≥ 1`, s.t. `n • a = 0` if it exists. Otherwise, i.e. if `a` is of infinite order, then `add_order_of a` is `0` by convention.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "submodule.to_affine_subspace",
    "statement": "def submodule.to_affine_subspace {k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] (p : submodule k V) : affine_subspace k V",
    "theorem": "{k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] (p : submodule k V) : affine_subspace k V",
    "args": "{k : Type u_1} {V : Type u_2} [ring k] [add_comm_group V] [module k V] (p : submodule k V)",
    "doc_string": "Reinterpret `p : submodule k V` as an `affine_subspace k V`.",
    "kind": "def",
    "type": "affine_subspace k V"
  },
  {
    "name": "lie_algebra.orthogonal.PD",
    "statement": "def lie_algebra.orthogonal.PD (l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R",
    "theorem": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (l ⊕ l) (l ⊕ l) R",
    "args": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R]",
    "doc_string": " A matrix transforming the bilinear form defined by the matrix `JD` into a split-signature diagonal matrix.  It looks like this as a `2l x 2l` matrix of `l x l` blocks:     [ 1 -1 ]    [ 1  1 ]",
    "kind": "def",
    "type": "matrix (l ⊕ l) (l ⊕ l) R"
  },
  {
    "name": "le_of_sub_nonpos",
    "statement": "theorem le_of_sub_nonpos {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a - b ≤ 0 → a ≤ b",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a - b ≤ 0 → a ≤ b",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the forward direction of sub_nonpos`.",
    "kind": "theorem",
    "type": "a - b ≤ 0 → a ≤ b"
  },
  {
    "name": "omega.nat.preterm",
    "statement": "inductive omega.nat.preterm  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Similar to `exprterm`, except that all exprs are now replaced with de Brujin indices of type `nat`. This is akin to generalizing over the terms represented by the said exprs.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "polish_space.sum",
    "statement": "def polish_space.sum {α : Type u_1} {β : Type u_2} [topological_space α] [polish_space α] [topological_space β] [polish_space β] : polish_space (α ⊕ β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [polish_space α] [topological_space β] [polish_space β] : polish_space (α ⊕ β)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [polish_space α] [topological_space β] [polish_space β]",
    "doc_string": "The disjoint union of two Polish spaces is Polish.",
    "kind": "def",
    "type": "polish_space (α ⊕ β)"
  },
  {
    "name": "lie_algebra.orthogonal.JB",
    "statement": "def lie_algebra.orthogonal.JB (l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R",
    "theorem": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R] : matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R",
    "args": "(l : Type u_4) (R : Type u₂) [decidable_eq l] [comm_ring R]",
    "doc_string": " A matrix defining a canonical odd-rank symmetric bilinear form.  It looks like this as a `(2l+1) x (2l+1)` matrix of blocks:     [ 2 0 0 ]    [ 0 0 1 ]    [ 0 1 0 ]  where sizes of the blocks are:     [`1 x 1` `1 x l` `1 x l`]    [`l x 1` `l x l` `l x l`]    [`l x 1` `l x l` `l x l`]",
    "kind": "def",
    "type": "matrix (unit ⊕ l ⊕ l) (unit ⊕ l ⊕ l) R"
  },
  {
    "name": "real.angle",
    "statement": "def real.angle  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of angles",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "linear_order.to_circular_order",
    "statement": "def linear_order.to_circular_order (α : Type u_1) [linear_order α] : circular_order α",
    "theorem": "(α : Type u_1) [linear_order α] : circular_order α",
    "args": "(α : Type u_1) [linear_order α]",
    "doc_string": " The circular order obtained from \"looping around\" a linear order. See note [reducible non-instances].",
    "kind": "def",
    "type": "circular_order α"
  },
  {
    "name": "ordinal.monoid",
    "statement": "def ordinal.monoid  : monoid ordinal",
    "theorem": " : monoid ordinal",
    "args": "",
    "doc_string": " The multiplication of ordinals `o₁` and `o₂` is the (well founded) lexicographic order on `o₂ × o₁`.",
    "kind": "def",
    "type": "monoid ordinal"
  },
  {
    "name": "PartialOrder",
    "statement": "def PartialOrder  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of partially ordered types.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "locally_constant.of_clopen",
    "statement": "def locally_constant.of_clopen {X : Type u_1} [topological_space X] {U : set X} [Π (x : X), decidable (x ∈ U)] (hU : is_clopen U) : locally_constant X (fin 2)",
    "theorem": "{X : Type u_1} [topological_space X] {U : set X} [Π (x : X), decidable (x ∈ U)] (hU : is_clopen U) : locally_constant X (fin 2)",
    "args": "{X : Type u_1} [topological_space X] {U : set X} [Π (x : X), decidable (x ∈ U)] (hU : is_clopen U)",
    "doc_string": "The locally constant function to `fin 2` associated to a clopen set.",
    "kind": "def",
    "type": "locally_constant X (fin 2)"
  },
  {
    "name": "padic_val_rat.one",
    "statement": "theorem padic_val_rat.one {p : ℕ} : padic_val_rat p 1 = 0",
    "theorem": "{p : ℕ} : padic_val_rat p 1 = 0",
    "args": "{p : ℕ}",
    "doc_string": "`padic_val_rat p 1` is 0 for any `p`.",
    "kind": "theorem",
    "type": "padic_val_rat p 1 = 0"
  },
  {
    "name": "snum.mul",
    "statement": "def snum.mul (a : snum) : snum → snum",
    "theorem": "(a : snum) : snum → snum",
    "args": "(a : snum)",
    "doc_string": "Multiply two `snum`s.",
    "kind": "def",
    "type": "snum → snum"
  },
  {
    "name": "ordnode.split_min'",
    "statement": "def ordnode.split_min' {α : Type u} : ordnode α → α → ordnode α → α × ordnode α",
    "theorem": "{α : Type u} : ordnode α → α → ordnode α → α × ordnode α",
    "args": "{α : Type u}",
    "doc_string": " **Internal use only**, because it requires a balancing constraint on the inputs.  O(log n). Extract and remove the minimum element from a nonempty tree.",
    "kind": "def",
    "type": "ordnode α → α → ordnode α → α × ordnode α"
  },
  {
    "name": "padic_val_nat",
    "statement": "def padic_val_nat (p n : ℕ) : ℕ",
    "theorem": "(p n : ℕ) : ℕ",
    "args": "(p n : ℕ)",
    "doc_string": "For `p ≠ 1`, the p-adic valuation of a natural `n ≠ 0` is the largest natural number `k` such that p^k divides z. If `n = 0` or `p = 1`, then `padic_val_nat p q` defaults to 0.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "function.injective2.right",
    "statement": "theorem function.injective2.right {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α) : function.injective (f a)",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α) : function.injective (f a)",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α)",
    "doc_string": "A binary injective function is injective when only the right argument varies.",
    "kind": "theorem",
    "type": "function.injective (f a)"
  },
  {
    "name": "is_group_hom.to_is_monoid_hom",
    "statement": "theorem is_group_hom.to_is_monoid_hom {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f",
    "theorem": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f",
    "args": "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f)",
    "doc_string": "A group homomorphism is a monoid homomorphism.",
    "kind": "theorem",
    "type": "is_monoid_hom f"
  },
  {
    "name": "direct_sum.gnon_unital_non_assoc_semiring",
    "statement": "structure direct_sum.gnon_unital_non_assoc_semiring {ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [has_add ι] [Π (i : ι), add_comm_monoid (A i)] : Type (max u_1 u_2)",
    "theorem": "{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [has_add ι] [Π (i : ι), add_comm_monoid (A i)] : Type (max u_1 u_2)",
    "args": "{ι : Type u_1} [decidable_eq ι] (A : ι → Type u_2) [has_add ι] [Π (i : ι), add_comm_monoid (A i)]",
    "doc_string": "A graded version of `non_unital_non_assoc_semiring`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "extent_closure",
    "statement": "def extent_closure {α : Type u_2} {β : Type u_3} (r : α → β → Prop) (t : set β) : set α",
    "theorem": "{α : Type u_2} {β : Type u_3} (r : α → β → Prop) (t : set β) : set α",
    "args": "{α : Type u_2} {β : Type u_3} (r : α → β → Prop) (t : set β)",
    "doc_string": " The extent closure of `t : set β` along a relation `r : α → β → Prop` is the set of all elements which `r` relates to all elements of `t`.",
    "kind": "def",
    "type": "set α"
  },
  {
    "name": "polynomial.is_noetherian_ring",
    "statement": "theorem polynomial.is_noetherian_ring {R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)",
    "theorem": "{R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)",
    "args": "{R : Type u} [comm_ring R] [is_noetherian_ring R]",
    "doc_string": "Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring.",
    "kind": "theorem",
    "type": "is_noetherian_ring (polynomial R)"
  },
  {
    "name": "Profinite.lim",
    "statement": "def Profinite.lim (X : Profinite) : category_theory.limits.limit_cone X.diagram",
    "theorem": "(X : Profinite) : category_theory.limits.limit_cone X.diagram",
    "args": "(X : Profinite)",
    "doc_string": "A bundled version of `X.as_limit_cone` and `X.as_limit`.",
    "kind": "def",
    "type": "category_theory.limits.limit_cone X.diagram"
  },
  {
    "name": "measurable_space",
    "statement": "structure measurable_space (α : Type u_7) : Type u_7",
    "theorem": "(α : Type u_7) : Type u_7",
    "args": "(α : Type u_7)",
    "doc_string": "A measurable space is a space equipped with a σ-algebra.",
    "kind": "structure",
    "type": "Type u_7"
  },
  {
    "name": "pell.xn",
    "statement": "def pell.xn {a : ℕ} (a1 : 1 < a) (n : ℕ) : ℕ",
    "theorem": "{a : ℕ} (a1 : 1 < a) (n : ℕ) : ℕ",
    "args": "{a : ℕ} (a1 : 1 < a) (n : ℕ)",
    "doc_string": "The Pell `x` sequence.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "set.has_inv",
    "statement": "def set.has_inv {α : Type u_2} [has_inv α] : has_inv (set α)",
    "theorem": "{α : Type u_2} [has_inv α] : has_inv (set α)",
    "args": "{α : Type u_2} [has_inv α]",
    "doc_string": " The pointwise inversion of set `s⁻¹` is defined as `{x | x⁻¹ ∈ s}` in locale `pointwise`. It i equal to `{x⁻¹ | x ∈ s}`, see `set.image_inv`.",
    "kind": "def",
    "type": "has_inv (set α)"
  },
  {
    "name": "locally_finite",
    "statement": "def locally_finite {α : Type u} {β : Type v} [topological_space α] (f : β → set α) : Prop",
    "theorem": "{α : Type u} {β : Type v} [topological_space α] (f : β → set α) : Prop",
    "args": "{α : Type u} {β : Type v} [topological_space α] (f : β → set α)",
    "doc_string": "A family of sets in `set α` is locally finite if at every point `x:α`,  there is a neighborhood of `x` which meets only finitely many sets in the family",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.lcm.char_p",
    "statement": "def nat.lcm.char_p (R : Type u) (S : Type v) [semiring R] [semiring S] (p q : ℕ) [char_p R p] [char_p S q] : char_p (R × S) (p.lcm q)",
    "theorem": "(R : Type u) (S : Type v) [semiring R] [semiring S] (p q : ℕ) [char_p R p] [char_p S q] : char_p (R × S) (p.lcm q)",
    "args": "(R : Type u) (S : Type v) [semiring R] [semiring S] (p q : ℕ) [char_p R p] [char_p S q]",
    "doc_string": " The characteristic of the product of rings is the least common multiple of the characteristics of the two rings.",
    "kind": "def",
    "type": "char_p (R × S) (p.lcm q)"
  },
  {
    "name": "computation.orelse",
    "statement": "def computation.orelse {α : Type u} (c₁ c₂ : computation α) : computation α",
    "theorem": "{α : Type u} (c₁ c₂ : computation α) : computation α",
    "args": "{α : Type u} (c₁ c₂ : computation α)",
    "doc_string": "`c₁ <|> c₂` calculates `c₁` and `c₂` simultaneously, returning  the first one that gives a result.",
    "kind": "def",
    "type": "computation α"
  },
  {
    "name": "galois_insertion",
    "statement": "structure galois_insertion {α : Type u_2} {β : Type u_3} [preorder α] [preorder β] (l : α → β) (u : β → α) : Type (max u_2 u_3)",
    "theorem": "{α : Type u_2} {β : Type u_3} [preorder α] [preorder β] (l : α → β) (u : β → α) : Type (max u_2 u_3)",
    "args": "{α : Type u_2} {β : Type u_3} [preorder α] [preorder β] (l : α → β) (u : β → α)",
    "doc_string": " A Galois insertion is a Galois connection where `l ∘ u = id`. It also contains a constructive choice function, to give better definitional equalities when lifting order structures. Dual to `galois_coinsertion`",
    "kind": "structure",
    "type": "Type (max u_2 u_3)"
  },
  {
    "name": "triv_sq_zero_ext.snd",
    "statement": "def triv_sq_zero_ext.snd {R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : M",
    "theorem": "{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M) : M",
    "args": "{R : Type u} {M : Type v} (x : triv_sq_zero_ext R M)",
    "doc_string": "The canonical projection `triv_sq_zero_ext R M → M`.",
    "kind": "def",
    "type": "M"
  },
  {
    "name": "is_left_regular_iff",
    "statement": "theorem is_left_regular_iff {R : Type u_1} [has_mul R] {a : R} : is_left_regular a ↔ is_smul_regular R a",
    "theorem": "{R : Type u_1} [has_mul R] {a : R} : is_left_regular a ↔ is_smul_regular R a",
    "args": "{R : Type u_1} [has_mul R] {a : R}",
    "doc_string": "Left-regular multiplication on `R` is equivalent to `R`-regularity of `R` itself.",
    "kind": "theorem",
    "type": "is_left_regular a ↔ is_smul_regular R a"
  },
  {
    "name": "is_dedekind_domain_inv.is_dedekind_domain",
    "statement": "theorem is_dedekind_domain_inv.is_dedekind_domain {A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A",
    "theorem": "{A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A",
    "args": "{A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A)",
    "doc_string": " Showing one side of the equivalence between the definitions `is_dedekind_domain_inv` and `is_dedekind_domain` of Dedekind domains.",
    "kind": "theorem",
    "type": "is_dedekind_domain A"
  },
  {
    "name": "four_pos",
    "statement": "theorem four_pos {α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 4",
    "theorem": "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 4",
    "args": "{α : Type u} [ordered_semiring α] [nontrivial α]",
    "doc_string": "**Alias** of zero_lt_four`.",
    "kind": "theorem",
    "type": "0 < 4"
  },
  {
    "name": "nat.choose_two_right",
    "statement": "theorem nat.choose_two_right (n : ℕ) : n.choose 2 = n * (n - 1) / 2",
    "theorem": "(n : ℕ) : n.choose 2 = n * (n - 1) / 2",
    "args": "(n : ℕ)",
    "doc_string": "`choose n 2` is the `n`-th triangle number.",
    "kind": "theorem",
    "type": "n.choose 2 = n * (n - 1) / 2"
  },
  {
    "name": "eq.trans_gt",
    "statement": "theorem eq.trans_gt {α : Type u} [preorder α] {a b c : α} : b = c → a < b → a < c",
    "theorem": "{α : Type u} [preorder α] {a b c : α} : b = c → a < b → a < c",
    "args": "{α : Type u} [preorder α] {a b c : α}",
    "doc_string": "**Alias** of lt_of_eq_of_lt'`.",
    "kind": "theorem",
    "type": "b = c → a < b → a < c"
  },
  {
    "name": "alexandroff",
    "statement": "def alexandroff (X : Type u_1) : Type u_1",
    "theorem": "(X : Type u_1) : Type u_1",
    "args": "(X : Type u_1)",
    "doc_string": "The Alexandroff extension of an arbitrary topological space `X`",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "prod_X_sub_smul",
    "statement": "def prod_X_sub_smul (G : Type u_2) [group G] [fintype G] (R : Type u_3) [comm_ring R] [mul_semiring_action G R] (x : R) : polynomial R",
    "theorem": "(G : Type u_2) [group G] [fintype G] (R : Type u_3) [comm_ring R] [mul_semiring_action G R] (x : R) : polynomial R",
    "args": "(G : Type u_2) [group G] [fintype G] (R : Type u_3) [comm_ring R] [mul_semiring_action G R] (x : R)",
    "doc_string": "the product of `(X - g • x)` over distinct `g • x`.",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "add_comm_group.positive_cone",
    "statement": "structure add_comm_group.positive_cone (α : Type u_1) [add_comm_group α] : Type u_1",
    "theorem": "(α : Type u_1) [add_comm_group α] : Type u_1",
    "args": "(α : Type u_1) [add_comm_group α]",
    "doc_string": " A collection of elements in an `add_comm_group` designated as \"non-negative\". This is useful for constructing an `ordered_add_commm_group` by choosing a positive cone in an exisiting `add_comm_group`.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "fin.snoc_init_self",
    "statement": "theorem fin.snoc_init_self {n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.snoc (fin.init q) (q (fin.last n)) = q",
    "theorem": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.snoc (fin.init q) (q (fin.last n)) = q",
    "args": "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i)",
    "doc_string": "Concatenating the first element of a tuple with its tail gives back the original tuple",
    "kind": "theorem",
    "type": "fin.snoc (fin.init q) (q (fin.last n)) = q"
  },
  {
    "name": "not_small_ordinal",
    "statement": "theorem not_small_ordinal  : ¬small ordinal",
    "theorem": " : ¬small ordinal",
    "args": "",
    "doc_string": " The type of ordinals in universe `u` is not `small.{u}`. This is the type-theoretic analog of the Burali-Forti paradox.",
    "kind": "theorem",
    "type": "¬small ordinal"
  },
  {
    "name": "restrict_scalars",
    "statement": "def restrict_scalars (R : Type u_1) (S : Type u_2) (M : Type u_3) : Type u_3",
    "theorem": "(R : Type u_1) (S : Type u_2) (M : Type u_3) : Type u_3",
    "args": "(R : Type u_1) (S : Type u_2) (M : Type u_3)",
    "doc_string": " If we put an `R`-algebra structure on a semiring `S`, we get a natural equivalence from the category of `S`-modules to the category of representations of the algebra `S` (over `R`). The type synonym `restrict_scalars` is essentially this equivalence.  Warning: use this type synonym judiciously! Consider an example where we want to construct an `R`-linear map from `M` to `S`, given: ```lean variables (R S M : Type*) variables [comm_semiring R] [semiring S] [algebra R S] [add_comm_monoid M] [module S M] ``` With the assumptions above we can't directly state our map as we have no `module R M` structure, but `restrict_scalars` permits it to be written as: ```lean -- an `R`-module structure on `M` is provided by `restrict_scalars` which is compatible example : restrict_scalars R S M →ₗ[R] S := sorry ``` However, it is usually better just to add this extra structure as an argument: ```lean -- an `R`-module structure on `M` and proof of its compatibility is provided by the user example [module R M] [is_scalar_tower R S M] : M →ₗ[R] S := sorry ``` The advantage of the second approach is that it defers the duty of providing the missing typeclasses `[module R M] [is_scalar_tower R S M]`. If some concrete `M` naturally carries these (as is often the case) then we have avoided `restrict_scalars` entirely. If not, we can pass `restrict_scalars R S M` later on instead of `M`.  Note that this means we almost always want to state definitions and lemmas in the language of `is_scalar_tower` rather than `restrict_scalars`.  An example of when one might want to use `restrict_scalars` would be if one has a vector space over a field of characteristic zero and wishes to make use of the `ℚ`-algebra structure.",
    "kind": "def",
    "type": "Type u_3"
  },
  {
    "name": "pi_nat.metric_space_nat_nat",
    "statement": "def pi_nat.metric_space_nat_nat  : metric_space (ℕ → ℕ)",
    "theorem": " : metric_space (ℕ → ℕ)",
    "args": "",
    "doc_string": " Metric space structure on `ℕ → ℕ` where the distance is given by `dist x y = (1/2)^n`, where `n` is the smallest index where `x` and `y` differ. Not registered as a global instance by default.",
    "kind": "def",
    "type": "metric_space (ℕ → ℕ)"
  },
  {
    "name": "pmf.seq",
    "statement": "def pmf.seq {α : Type u_1} {β : Type u_2} (q : pmf (α → β)) (p : pmf α) : pmf β",
    "theorem": "{α : Type u_1} {β : Type u_2} (q : pmf (α → β)) (p : pmf α) : pmf β",
    "args": "{α : Type u_1} {β : Type u_2} (q : pmf (α → β)) (p : pmf α)",
    "doc_string": "The monadic sequencing operation for `pmf`.",
    "kind": "def",
    "type": "pmf β"
  },
  {
    "name": "set.mul_action_set",
    "statement": "def set.mul_action_set {α : Type u_2} {β : Type u_3} [monoid α] [mul_action α β] : mul_action α (set β)",
    "theorem": "{α : Type u_2} {β : Type u_3} [monoid α] [mul_action α β] : mul_action α (set β)",
    "args": "{α : Type u_2} {β : Type u_3} [monoid α] [mul_action α β]",
    "doc_string": "A multiplicative action of a monoid on a type `β` gives a multiplicative action on `set β`.",
    "kind": "def",
    "type": "mul_action α (set β)"
  },
  {
    "name": "grade_order.fin_to_nat",
    "statement": "def grade_order.fin_to_nat {α : Type u_3} [preorder α] (n : ℕ) [grade_order (fin n) α] : grade_order ℕ α",
    "theorem": "{α : Type u_3} [preorder α] (n : ℕ) [grade_order (fin n) α] : grade_order ℕ α",
    "args": "{α : Type u_3} [preorder α] (n : ℕ) [grade_order (fin n) α]",
    "doc_string": " A `fin n`-graded order is also `ℕ`-graded. We do not mark this an instance because `n` is not inferrable.",
    "kind": "def",
    "type": "grade_order ℕ α"
  },
  {
    "name": "perms_of_list",
    "statement": "def perms_of_list {α : Type u_1} [decidable_eq α] : list α → list (equiv.perm α)",
    "theorem": "{α : Type u_1} [decidable_eq α] : list α → list (equiv.perm α)",
    "args": "{α : Type u_1} [decidable_eq α]",
    "doc_string": "Given a list, produce a list of all permutations of its elements.",
    "kind": "def",
    "type": "list α → list (equiv.perm α)"
  },
  {
    "name": "add_is_add_right_regular_iff",
    "statement": "theorem add_is_add_right_regular_iff {R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) ↔ is_add_right_regular b",
    "theorem": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) ↔ is_add_right_regular b",
    "args": "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a)",
    "doc_string": "An element is add-right-regular if and only if adding it on the right to a add-right-regular element is add-right-regular.",
    "kind": "theorem",
    "type": "is_add_right_regular (b + a) ↔ is_add_right_regular b"
  },
  {
    "name": "summable.tendsto_cofinite_zero",
    "statement": "theorem summable.tendsto_cofinite_zero {α : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : α → G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)",
    "theorem": "{α : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : α → G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)",
    "args": "{α : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : α → G} (hf : summable f)",
    "doc_string": " Series divergence test: if `f` is a convergent series, then `f x` tends to zero along `cofinite`.",
    "kind": "theorem",
    "type": "filter.tendsto f filter.cofinite (nhds 0)"
  },
  {
    "name": "is_add_group_hom.injective_iff",
    "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0",
    "theorem": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0",
    "args": "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f)",
    "doc_string": "An additive group homomorphism is injective if its kernel is trivial.",
    "kind": "theorem",
    "type": "function.injective f ↔ ∀ (a : α), f a = 0 → a = 0"
  },
  {
    "name": "set.partially_well_ordered_on.is_min_bad_seq",
    "statement": "def set.partially_well_ordered_on.is_min_bad_seq {α : Type u_1} (r : α → α → Prop) (rk : α → ℕ) (s : set α) (n : ℕ) (f : ℕ → α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (rk : α → ℕ) (s : set α) (n : ℕ) (f : ℕ → α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (rk : α → ℕ) (s : set α) (n : ℕ) (f : ℕ → α)",
    "doc_string": "This indicates that every bad sequence `g` that agrees with `f` on the first `n`  terms has `rk (f n) ≤ rk (g n)`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.exists_lt_and_lt_iff_not_dvd",
    "statement": "theorem nat.exists_lt_and_lt_iff_not_dvd (m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
    "theorem": "(m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m",
    "args": "(m : ℕ) {n : ℕ} (hn : 0 < n)",
    "doc_string": "`m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`.",
    "kind": "theorem",
    "type": "(∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m"
  },
  {
    "name": "Set.inter",
    "statement": "def Set.inter (x y : Set) : Set",
    "theorem": "(x y : Set) : Set",
    "args": "(x y : Set)",
    "doc_string": "The binary intersection operation",
    "kind": "def",
    "type": "Set"
  },
  {
    "name": "Top.glue_data.mk_core",
    "statement": "structure Top.glue_data.mk_core  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "A family of gluing data consists of 1. An index type `J` 2. A bundled topological space `U i` for each `i : J`. 3. An open set `V i j ⊆ U i` for each `i j : J`. 4. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`. such that 6. `V i i = U i`. 7. `t i i` is the identity. 8. For each `x ∈ V i j ∩ V i k`, `t i j x ∈ V j k`. 9. `t j k (t i j x) = t i k x`.  We can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.",
    "kind": "structure",
    "type": "Type (u+1)"
  },
  {
    "name": "measure_theory.measure_space",
    "statement": "structure measure_theory.measure_space (α : Type u_6) : Type u_6",
    "theorem": "(α : Type u_6) : Type u_6",
    "args": "(α : Type u_6)",
    "doc_string": "A measure space is a measurable space equipped with a  measure, referred to as `volume`.",
    "kind": "structure",
    "type": "Type u_6"
  },
  {
    "name": "parser.step",
    "statement": "structure parser.step {α : Type} (p : parser α) : Prop",
    "theorem": "{α : Type} (p : parser α) : Prop",
    "args": "{α : Type} (p : parser α)",
    "doc_string": "A `parser α` is defined to be `step` if it always moves exactly one char forward on success.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "qpf.fix",
    "statement": "def qpf.fix (F : Type u → Type u) [functor F] [q : qpf F] : Type u",
    "theorem": "(F : Type u → Type u) [functor F] [q : qpf F] : Type u",
    "args": "(F : Type u → Type u) [functor F] [q : qpf F]",
    "doc_string": "inductive type defined as initial algebra of a Quotient of Polynomial Functor",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "invertible_neg",
    "statement": "def invertible_neg {α : Type u} [has_mul α] [has_one α] [has_distrib_neg α] (a : α) [invertible a] : invertible (-a)",
    "theorem": "{α : Type u} [has_mul α] [has_one α] [has_distrib_neg α] (a : α) [invertible a] : invertible (-a)",
    "args": "{α : Type u} [has_mul α] [has_one α] [has_distrib_neg α] (a : α) [invertible a]",
    "doc_string": "`-⅟a` is the inverse of `-a`",
    "kind": "def",
    "type": "invertible (-a)"
  },
  {
    "name": "first_order.language.hereditary",
    "statement": "def first_order.language.hereditary {L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop",
    "theorem": "{L : first_order.language} (K : set (category_theory.bundled L.Structure)) : Prop",
    "args": "{L : first_order.language} (K : set (category_theory.bundled L.Structure))",
    "doc_string": "A class `K` has the hereditary property when all finitely-generated structures that embed into  structures in `K` are also in `K`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "projective_spectrum.Top",
    "statement": "def projective_spectrum.Top {R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : Top",
    "theorem": "{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜] : Top",
    "args": "{R : Type u_1} {A : Type u_2} [comm_semiring R] [comm_ring A] [algebra R A] (𝒜 : ℕ → submodule R A) [graded_algebra 𝒜]",
    "doc_string": "The underlying topology of `Proj` is the projective spectrum of graded ring `A`.",
    "kind": "def",
    "type": "Top"
  },
  {
    "name": "mvpfunctor.const",
    "statement": "def mvpfunctor.const (n : ℕ) (A : Type u) : mvpfunctor n",
    "theorem": "(n : ℕ) (A : Type u) : mvpfunctor n",
    "args": "(n : ℕ) (A : Type u)",
    "doc_string": "Constant functor where the input object does not affect the output",
    "kind": "def",
    "type": "mvpfunctor n"
  },
  {
    "name": "add_subsemigroup.has_bot",
    "statement": "def add_subsemigroup.has_bot {M : Type u_1} [has_add M] : has_bot (add_subsemigroup M)",
    "theorem": "{M : Type u_1} [has_add M] : has_bot (add_subsemigroup M)",
    "args": "{M : Type u_1} [has_add M]",
    "doc_string": "The trivial `add_subsemigroup` `∅` of an additive magma `M`.",
    "kind": "def",
    "type": "has_bot (add_subsemigroup M)"
  },
  {
    "name": "real.coe_fib_eq'",
    "statement": "theorem real.coe_fib_eq'  : (λ (n : ℕ), ↑(nat.fib n)) = λ (n : ℕ), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5",
    "theorem": " : (λ (n : ℕ), ↑(nat.fib n)) = λ (n : ℕ), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5",
    "args": "",
    "doc_string": "Binet's formula as a function equality.",
    "kind": "theorem",
    "type": "(λ (n : ℕ), ↑(nat.fib n)) = λ (n : ℕ), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5"
  },
  {
    "name": "comm_group_of_nilpotency_class",
    "statement": "def comm_group_of_nilpotency_class {G : Type u_1} [group G] [group.is_nilpotent G] (h : group.nilpotency_class G ≤ 1) : comm_group G",
    "theorem": "{G : Type u_1} [group G] [group.is_nilpotent G] (h : group.nilpotency_class G ≤ 1) : comm_group G",
    "args": "{G : Type u_1} [group G] [group.is_nilpotent G] (h : group.nilpotency_class G ≤ 1)",
    "doc_string": "Groups with nilpotency class at most one are abelian",
    "kind": "def",
    "type": "comm_group G"
  },
  {
    "name": "inducing.is_open_map",
    "statement": "theorem inducing.is_open_map {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f))",
    "doc_string": "An inducing map with an open range is an open map.",
    "kind": "theorem",
    "type": "is_open_map f"
  },
  {
    "name": "fin.comm_semigroup",
    "statement": "def fin.comm_semigroup (n : ℕ) : comm_semigroup (fin (n + 1))",
    "theorem": "(n : ℕ) : comm_semigroup (fin (n + 1))",
    "args": "(n : ℕ)",
    "doc_string": "Multiplicative commutative semigroup structure on `fin (n+1)`.",
    "kind": "def",
    "type": "comm_semigroup (fin (n + 1))"
  },
  {
    "name": "simplex_category.truncated",
    "statement": "def simplex_category.truncated (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": "The truncated simplex category.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "nat.fib_add_two_strict_mono",
    "statement": "theorem nat.fib_add_two_strict_mono  : strict_mono (λ (n : ℕ), nat.fib (n + 2))",
    "theorem": " : strict_mono (λ (n : ℕ), nat.fib (n + 2))",
    "args": "",
    "doc_string": "`fib (n + 2)` is strictly monotone.",
    "kind": "theorem",
    "type": "strict_mono (λ (n : ℕ), nat.fib (n + 2))"
  },
  {
    "name": "finset.mem_powerset_len",
    "statement": "theorem finset.mem_powerset_len {α : Type u_1} {n : ℕ} {s t : finset α} : s ∈ finset.powerset_len n t ↔ s ⊆ t ∧ s.card = n",
    "theorem": "{α : Type u_1} {n : ℕ} {s t : finset α} : s ∈ finset.powerset_len n t ↔ s ⊆ t ∧ s.card = n",
    "args": "{α : Type u_1} {n : ℕ} {s t : finset α}",
    "doc_string": "**Formula for the Number of Combinations**",
    "kind": "theorem",
    "type": "s ∈ finset.powerset_len n t ↔ s ⊆ t ∧ s.card = n"
  },
  {
    "name": "local_homeomorph.is_image",
    "statement": "def local_homeomorph.is_image {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) (t : set β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) (t : set β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e : local_homeomorph α β) (s : set α) (t : set β)",
    "doc_string": " We say that `t : set β` is an image of `s : set α` under a local homeomorphism `e` if any of the following equivalent conditions hold:  * `e '' (e.source ∩ s) = e.target ∩ t`; * `e.source ∩ e ⁻¹ t = e.source ∩ s`; * `∀ x ∈ e.source, e x ∈ t ↔ x ∈ s` (this one is used in the definition).",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "dvd_not_unit",
    "statement": "def dvd_not_unit {α : Type u_1} [comm_monoid_with_zero α] (a b : α) : Prop",
    "theorem": "{α : Type u_1} [comm_monoid_with_zero α] (a b : α) : Prop",
    "args": "{α : Type u_1} [comm_monoid_with_zero α] (a b : α)",
    "doc_string": " `dvd_not_unit a b` expresses that `a` divides `b` \"strictly\", i.e. that `b` divided by `a` is not a unit.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "nat.factors",
    "statement": "def nat.factors  : ℕ → list ℕ",
    "theorem": " : ℕ → list ℕ",
    "args": "",
    "doc_string": "`factors n` is the prime factorization of `n`, listed in increasing order.",
    "kind": "def",
    "type": "ℕ → list ℕ"
  },
  {
    "name": "continuous_monoid_hom_class",
    "statement": "structure continuous_monoid_hom_class (F : Type u_9) (α : Type u_10) (β : Type u_11) [monoid α] [monoid β] [topological_space α] [topological_space β] : Type (max u_10 u_11 u_9)",
    "theorem": "(F : Type u_9) (α : Type u_10) (β : Type u_11) [monoid α] [monoid β] [topological_space α] [topological_space β] : Type (max u_10 u_11 u_9)",
    "args": "(F : Type u_9) (α : Type u_10) (β : Type u_11) [monoid α] [monoid β] [topological_space α] [topological_space β]",
    "doc_string": " `continuous_monoid_hom_class F α β` states that `F` is a type of continuous additive monoid homomorphisms.  You should also extend this typeclass when you extend `continuous_monoid_hom`.",
    "kind": "structure",
    "type": "Type (max u_10 u_11 u_9)"
  },
  {
    "name": "pempty",
    "statement": "inductive pempty  : Sort u",
    "theorem": " : Sort u",
    "args": "",
    "doc_string": "`pempty` is the universe-polymorphic analogue of `empty`.",
    "kind": "inductive",
    "type": "Sort u"
  },
  {
    "name": "pmf.of_multiset",
    "statement": "def pmf.of_multiset {α : Type u_1} (s : multiset α) (hs : s ≠ 0) : pmf α",
    "theorem": "{α : Type u_1} (s : multiset α) (hs : s ≠ 0) : pmf α",
    "args": "{α : Type u_1} (s : multiset α) (hs : s ≠ 0)",
    "doc_string": "Given a non-empty multiset `s` we construct the `pmf` which sends `a` to the fraction of  elements in `s` that are `a`.",
    "kind": "def",
    "type": "pmf α"
  },
  {
    "name": "category_theory.limits.has_cokernels",
    "statement": "structure category_theory.limits.has_cokernels (C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] : Prop",
    "args": "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C]",
    "doc_string": "`has_cokernels` represents the existence of cokernels for every morphism.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "snum",
    "statement": "inductive snum  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Alternative representation of integers using a sign bit at the end.  The convention on sign here is to have the argument to `msb` denote  the sign of the MSB itself, with all higher bits set to the negation  of this sign. The result is interpreted in two's complement.      13  = ..0001101(base 2) = nz (bit1 (bit0 (bit1 (msb tt))))     -13 = ..1110011(base 2) = nz (bit1 (bit1 (bit0 (msb ff))))   As with `num`, a special case must be added for zero, which has no msb,  but by two's complement symmetry there is a second special case for -1.  Here the `bool` field indicates the sign of the number.      0  = ..0000000(base 2) = zero ff     -1 = ..1111111(base 2) = zero tt",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "set.subsingleton",
    "statement": "def set.subsingleton {α : Type u} (s : set α) : Prop",
    "theorem": "{α : Type u} (s : set α) : Prop",
    "args": "{α : Type u} (s : set α)",
    "doc_string": "A set `s` is a `subsingleton`, if it has at most one element.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "random_fin_of_pos",
    "statement": "def random_fin_of_pos {n : ℕ} (h : 0 < n) : random (fin n)",
    "theorem": "{n : ℕ} (h : 0 < n) : random (fin n)",
    "args": "{n : ℕ} (h : 0 < n)",
    "doc_string": " A shortcut for creating a `random (fin n)` instance from a proof that `0 < n` rather than on matching on `fin (succ n)`",
    "kind": "def",
    "type": "random (fin n)"
  },
  {
    "name": "holor.cprank_max1",
    "statement": "inductive holor.cprank_max1 {α : Type} [has_mul α] {ds : list ℕ} : holor α ds → Prop",
    "theorem": "{α : Type} [has_mul α] {ds : list ℕ} : holor α ds → Prop",
    "args": "{α : Type} [has_mul α] {ds : list ℕ}",
    "doc_string": "`cprank_max1 x` means `x` has CP rank at most 1, that is,  it is the tensor product of 1-dimensional holors.",
    "kind": "inductive",
    "type": "holor α ds → Prop"
  },
  {
    "name": "nat.count",
    "statement": "def nat.count (p : ℕ → Prop) [decidable_pred p] (n : ℕ) : ℕ",
    "theorem": "(p : ℕ → Prop) [decidable_pred p] (n : ℕ) : ℕ",
    "args": "(p : ℕ → Prop) [decidable_pred p] (n : ℕ)",
    "doc_string": "Count the number of naturals `k < n` satisfying `p k`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "set.surj_on",
    "statement": "def set.surj_on {α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β) : Prop",
    "theorem": "{α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β) : Prop",
    "args": "{α : Type u} {β : Type v} (f : α → β) (s : set α) (t : set β)",
    "doc_string": "`f` is surjective from `a` to `b` if `b` is contained in the image of `a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "coe_coe",
    "statement": "theorem coe_coe {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} [has_coe α β] [has_coe_t β γ] (a : α) : ↑a = ↑↑a",
    "theorem": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} [has_coe α β] [has_coe_t β γ] (a : α) : ↑a = ↑↑a",
    "args": "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} [has_coe α β] [has_coe_t β γ] (a : α)",
    "doc_string": "Add an instance to \"undo\" coercion transitivity into a chain of coercions, because   most simp lemmas are stated with respect to simple coercions and will not match when   part of a chain.",
    "kind": "theorem",
    "type": "↑a = ↑↑a"
  },
  {
    "name": "metric.inf_dist_empty",
    "statement": "theorem metric.inf_dist_empty {α : Type u} [pseudo_metric_space α] {x : α} : metric.inf_dist x ∅ = 0",
    "theorem": "{α : Type u} [pseudo_metric_space α] {x : α} : metric.inf_dist x ∅ = 0",
    "args": "{α : Type u} [pseudo_metric_space α] {x : α}",
    "doc_string": " the minimal distance to the empty set is 0 (if you want to have the more reasonable value ∞ instead, use `inf_edist`, which takes values in ℝ≥0∞)",
    "kind": "theorem",
    "type": "metric.inf_dist x ∅ = 0"
  },
  {
    "name": "cau_seq.is_complete",
    "statement": "structure cau_seq.is_complete {α : Type u_1} [linear_ordered_field α] (β : Type u_2) [ring β] (abv : β → α) [is_absolute_value abv] : Prop",
    "theorem": "{α : Type u_1} [linear_ordered_field α] (β : Type u_2) [ring β] (abv : β → α) [is_absolute_value abv] : Prop",
    "args": "{α : Type u_1} [linear_ordered_field α] (β : Type u_2) [ring β] (abv : β → α) [is_absolute_value abv]",
    "doc_string": " A class stating that a ring with an absolute value is complete, i.e. every Cauchy sequence has a limit.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "add_action.orbit_rel",
    "statement": "def add_action.orbit_rel (α : Type u) (β : Type v) [add_group α] [add_action α β] : setoid β",
    "theorem": "(α : Type u) (β : Type v) [add_group α] [add_action α β] : setoid β",
    "args": "(α : Type u) (β : Type v) [add_group α] [add_action α β]",
    "doc_string": "The relation 'in the same orbit'.",
    "kind": "def",
    "type": "setoid β"
  },
  {
    "name": "ennreal.topological_space",
    "statement": "def ennreal.topological_space  : topological_space ennreal",
    "theorem": " : topological_space ennreal",
    "args": "",
    "doc_string": " Topology on `ℝ≥0∞`.  Note: this is different from the `emetric_space` topology. The `emetric_space` topology has `is_open {⊤}`, while this topology doesn't have singleton elements.",
    "kind": "def",
    "type": "topological_space ennreal"
  },
  {
    "name": "pos_num.min_fac_aux",
    "statement": "def pos_num.min_fac_aux (n : pos_num) : ℕ → pos_num → pos_num",
    "theorem": "(n : pos_num) : ℕ → pos_num → pos_num",
    "args": "(n : pos_num)",
    "doc_string": " Auxiliary function for computing the smallest prime factor of a `pos_num`. Unlike `nat.min_fac_aux`, we use a natural number `fuel` variable that is set to an upper bound on the number of iterations. It is initialized to the number `n` we are determining primality for. Even though this is exponential in the input (since it is a `nat`, not a `num`), it will get lazily evaluated during kernel reduction, so we will only require about `sqrt n` unfoldings, for the `sqrt n` iterations of the loop.",
    "kind": "def",
    "type": "ℕ → pos_num → pos_num"
  },
  {
    "name": "continuous_map",
    "statement": "structure continuous_map (α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β]",
    "doc_string": " The type of continuous maps from `α` to `β`.  When possible, instead of parametrizing results over `(f : C(α, β))`, you should parametrize over `{F : Type*} [continuous_map_class F α β] (f : F)`.  When you extend this structure, make sure to extend `continuous_map_class`.",
    "kind": "structure",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "add_hom.fst",
    "statement": "def add_hom.fst (M : Type u_5) (N : Type u_6) [has_add M] [has_add N] : add_hom (M × N) M",
    "theorem": "(M : Type u_5) (N : Type u_6) [has_add M] [has_add N] : add_hom (M × N) M",
    "args": "(M : Type u_5) (N : Type u_6) [has_add M] [has_add N]",
    "doc_string": "Given additive magmas `A`, `B`, the natural projection homomorphism from `A × B` to `A`",
    "kind": "def",
    "type": "add_hom (M × N) M"
  },
  {
    "name": "simple_graph.from_rel",
    "statement": "def simple_graph.from_rel {V : Type u} (r : V → V → Prop) : simple_graph V",
    "theorem": "{V : Type u} (r : V → V → Prop) : simple_graph V",
    "args": "{V : Type u} (r : V → V → Prop)",
    "doc_string": "Construct the simple graph induced by the given relation. It symmetrizes the relation and makes it irreflexive.",
    "kind": "def",
    "type": "simple_graph V"
  },
  {
    "name": "intermediate_field.lifts",
    "statement": "def intermediate_field.lifts (F : Type u_1) (E : Type u_2) (K : Type u_3) [field F] [field E] [field K] [algebra F E] [algebra F K] : Type (max u_2 u_3)",
    "theorem": "(F : Type u_1) (E : Type u_2) (K : Type u_3) [field F] [field E] [field K] [algebra F E] [algebra F K] : Type (max u_2 u_3)",
    "args": "(F : Type u_1) (E : Type u_2) (K : Type u_3) [field F] [field E] [field K] [algebra F E] [algebra F K]",
    "doc_string": "Lifts `L → K` of `F → K`",
    "kind": "def",
    "type": "Type (max u_2 u_3)"
  },
  {
    "name": "add_subgroup.sub_mem",
    "statement": "theorem add_subgroup.sub_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x - y ∈ H",
    "theorem": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x - y ∈ H",
    "args": "{G : Type u_1} [add_group G] (H : add_subgroup G) {x y : G} (hx : x ∈ H) (hy : y ∈ H)",
    "doc_string": "An `add_subgroup` is closed under subtraction.",
    "kind": "theorem",
    "type": "x - y ∈ H"
  },
  {
    "name": "free_algebra.star_ring",
    "statement": "def free_algebra.star_ring {R : Type u_1} [comm_semiring R] {X : Type u_2} : star_ring (free_algebra R X)",
    "theorem": "{R : Type u_1} [comm_semiring R] {X : Type u_2} : star_ring (free_algebra R X)",
    "args": "{R : Type u_1} [comm_semiring R] {X : Type u_2}",
    "doc_string": "The star ring formed by reversing the elements of products",
    "kind": "def",
    "type": "star_ring (free_algebra R X)"
  },
  {
    "name": "star_add_monoid",
    "statement": "structure star_add_monoid (R : Type u) [add_monoid R] : Type u",
    "theorem": "(R : Type u) [add_monoid R] : Type u",
    "args": "(R : Type u) [add_monoid R]",
    "doc_string": "A `*`-additive monoid `R` is an additive monoid with an involutive `star` operation which preserves addition.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "order_bot.bdd_below",
    "statement": "theorem order_bot.bdd_below {γ : Type w} [preorder γ] [order_bot γ] (s : set γ) : bdd_below s",
    "theorem": "{γ : Type w} [preorder γ] [order_bot γ] (s : set γ) : bdd_below s",
    "args": "{γ : Type w} [preorder γ] [order_bot γ] (s : set γ)",
    "doc_string": "When there is a global minimum, every set is bounded below.",
    "kind": "theorem",
    "type": "bdd_below s"
  },
  {
    "name": "ordnode.node3_r",
    "statement": "def ordnode.node3_r {α : Type u_1} (l : ordnode α) (x : α) (m : ordnode α) (y : α) (r : ordnode α) : ordnode α",
    "theorem": "{α : Type u_1} (l : ordnode α) (x : α) (m : ordnode α) (y : α) (r : ordnode α) : ordnode α",
    "args": "{α : Type u_1} (l : ordnode α) (x : α) (m : ordnode α) (y : α) (r : ordnode α)",
    "doc_string": "Build a tree from three nodes, right associated (ignores the invariants).",
    "kind": "def",
    "type": "ordnode α"
  },
  {
    "name": "category_theory.linear",
    "statement": "structure category_theory.linear (R : Type w) [semiring R] (C : Type u) [category_theory.category C] [category_theory.preadditive C] : Type (max u v w)",
    "theorem": "(R : Type w) [semiring R] (C : Type u) [category_theory.category C] [category_theory.preadditive C] : Type (max u v w)",
    "args": "(R : Type w) [semiring R] (C : Type u) [category_theory.category C] [category_theory.preadditive C]",
    "doc_string": "A category is called `R`-linear if `P ⟶ Q` is an `R`-module such that composition is    `R`-linear in both variables.",
    "kind": "structure",
    "type": "Type (max u v w)"
  },
  {
    "name": "native.float.specification.precision",
    "statement": "constant native.float.specification.precision  : ℕ",
    "theorem": " : ℕ",
    "args": "",
    "doc_string": "The length of the mantissa.",
    "kind": "constant",
    "type": "ℕ"
  },
  {
    "name": "name.is_likely_generated_binder_name",
    "statement": "def name.is_likely_generated_binder_name (n : name) : bool",
    "theorem": "(n : name) : bool",
    "args": "(n : name)",
    "doc_string": "Check whether a name was likely generated by Lean to name an anonymous binder. Such names are either `ᾰ` or `ᾰ_n` for some natural `n`. See note [likely generated binder names].",
    "kind": "def",
    "type": "bool"
  },
  {
    "name": "ideal.torsion_of",
    "statement": "def ideal.torsion_of (R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] (x : M) : ideal R",
    "theorem": "(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] (x : M) : ideal R",
    "args": "(R : Type u_1) (M : Type u_2) [semiring R] [add_comm_monoid M] [module R M] (x : M)",
    "doc_string": "The torsion ideal of `x`, containing all `a` such that `a • x = 0`.",
    "kind": "def",
    "type": "ideal R"
  },
  {
    "name": "where.collect_by",
    "statement": "def where.collect_by {α β γ : Type} (l : list α) (p : α → β × γ) [decidable_eq β] : list (β × list γ)",
    "theorem": "{α β γ : Type} (l : list α) (p : α → β × γ) [decidable_eq β] : list (β × list γ)",
    "args": "{α β γ : Type} (l : list α) (p : α → β × γ) [decidable_eq β]",
    "doc_string": " Returns the elements of `l` under the image of `p`, collecting together elements with the same `β` component, deleting duplicates.",
    "kind": "def",
    "type": "list (β × list γ)"
  },
  {
    "name": "add_right_cancel_monoid",
    "statement": "structure add_right_cancel_monoid (M : Type u) : Type u",
    "theorem": "(M : Type u) : Type u",
    "args": "(M : Type u)",
    "doc_string": " An additive monoid in which addition is right-cancellative. Main examples are `ℕ` and groups. This is the right typeclass for many sum lemmas, as having a zero is useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "list.mmap_with_index_aux",
    "statement": "def list.mmap_with_index_aux {m : Type v → Type w} [applicative m] {α : Type u_1} {β : Type v} (f : ℕ → α → m β) : ℕ → list α → m (list β)",
    "theorem": "{m : Type v → Type w} [applicative m] {α : Type u_1} {β : Type v} (f : ℕ → α → m β) : ℕ → list α → m (list β)",
    "args": "{m : Type v → Type w} [applicative m] {α : Type u_1} {β : Type v} (f : ℕ → α → m β)",
    "doc_string": "Auxiliary definition for `mmap_with_index`.",
    "kind": "def",
    "type": "ℕ → list α → m (list β)"
  },
  {
    "name": "ereal",
    "statement": "def ereal  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "ereal : The type `[-∞, ∞]`",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "function.has_uncurry",
    "statement": "structure function.has_uncurry (α : Type u_5) (β : out_param (Type u_6)) (γ : out_param (Type u_7)) : Type (max u_5 u_6 u_7)",
    "theorem": "(α : Type u_5) (β : out_param (Type u_6)) (γ : out_param (Type u_7)) : Type (max u_5 u_6 u_7)",
    "args": "(α : Type u_5) (β : out_param (Type u_6)) (γ : out_param (Type u_7))",
    "doc_string": " Records a way to turn an element of `α` into a function from `β` to `γ`. The most generic use is to recursively uncurry. For instance `f : α → β → γ → δ` will be turned into `↿f : α × β × γ → δ`. One can also add instances for bundled maps.",
    "kind": "structure",
    "type": "Type (max u_5 u_6 u_7)"
  },
  {
    "name": "filter.cocompact",
    "statement": "def filter.cocompact (α : Type u_1) [topological_space α] : filter α",
    "theorem": "(α : Type u_1) [topological_space α] : filter α",
    "args": "(α : Type u_1) [topological_space α]",
    "doc_string": "`filter.cocompact` is the filter generated by complements to compact sets.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "subsingleton_of_zero_eq_one",
    "statement": "theorem subsingleton_of_zero_eq_one {M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 → subsingleton M₀",
    "theorem": "{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 → subsingleton M₀",
    "args": "{M₀ : Type u_1} [mul_zero_one_class M₀]",
    "doc_string": "**Alias** of the forward direction of subsingleton_iff_zero_eq_one`.",
    "kind": "theorem",
    "type": "0 = 1 → subsingleton M₀"
  },
  {
    "name": "wseq.equiv",
    "statement": "def wseq.equiv {α : Type u} : wseq α → wseq α → Prop",
    "theorem": "{α : Type u} : wseq α → wseq α → Prop",
    "args": "{α : Type u}",
    "doc_string": "If two sequences are equivalent, then they have the same values and  the same computational behavior (i.e. if one loops forever then so does  the other), although they may differ in the number of `think`s needed to  arrive at the answer.",
    "kind": "def",
    "type": "wseq α → wseq α → Prop"
  },
  {
    "name": "linear_combo.linear_combination_config",
    "statement": "structure linear_combo.linear_combination_config  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A configuration object for `linear_combination`.  `normalize` describes whether or not the normalization step should be used.  `normalization_tactic` describes the tactic used for normalization when checking if the weighted sum is equivalent to the goal (when `normalize` is `tt`).",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "zero_lt.mul_pos_strict_mono",
    "statement": "def zero_lt.mul_pos_strict_mono (X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop",
    "theorem": "(X : Type u) [has_mul X] [has_zero X] [has_lt X] : Prop",
    "args": "(X : Type u) [has_mul X] [has_zero X] [has_lt X]",
    "doc_string": "  `zero_lt.mul_pos_strict_mono α` is an abbreviation for `covariant_class α>0 α (λ x y, y * x) (<)`, expressing that multiplication by positive elements on the right is strictly monotone.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "topological_fiber_bundle_core.fiber",
    "statement": "def topological_fiber_bundle_core.fiber {ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (x : B) : Type u_3",
    "theorem": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (x : B) : Type u_3",
    "args": "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (x : B)",
    "doc_string": " The fiber of a topological fiber bundle core, as a convenience function for dot notation and typeclass inference",
    "kind": "def",
    "type": "Type u_3"
  },
  {
    "name": "function.left_inverse",
    "statement": "def function.left_inverse {α : Sort u₁} {β : Sort u₂} (g : β → α) (f : α → β) : Prop",
    "theorem": "{α : Sort u₁} {β : Sort u₂} (g : β → α) (f : α → β) : Prop",
    "args": "{α : Sort u₁} {β : Sort u₂} (g : β → α) (f : α → β)",
    "doc_string": "`left_inverse g f` means that g is a left inverse to f. That is, `g ∘ f = id`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_upper_set",
    "statement": "def is_upper_set {α : Type u_1} [has_le α] (s : set α) : Prop",
    "theorem": "{α : Type u_1} [has_le α] (s : set α) : Prop",
    "args": "{α : Type u_1} [has_le α] (s : set α)",
    "doc_string": " An upper set in an order `α` is a set such that any element greater than one of its members is also a member. Also called up-set, upward-closed set.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "generalized_continued_fraction.int_fract_pair.mapFr",
    "statement": "def generalized_continued_fraction.int_fract_pair.mapFr {K : Type u_1} {β : Type u_2} (f : K → β) (gp : generalized_continued_fraction.int_fract_pair K) : generalized_continued_fraction.int_fract_pair β",
    "theorem": "{K : Type u_1} {β : Type u_2} (f : K → β) (gp : generalized_continued_fraction.int_fract_pair K) : generalized_continued_fraction.int_fract_pair β",
    "args": "{K : Type u_1} {β : Type u_2} (f : K → β) (gp : generalized_continued_fraction.int_fract_pair K)",
    "doc_string": "Maps a function `f` on the fractional components of a given pair.",
    "kind": "def",
    "type": "generalized_continued_fraction.int_fract_pair β"
  },
  {
    "name": "nat.even_pow",
    "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0",
    "theorem": "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0",
    "args": "{m n : ℕ}",
    "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.",
    "kind": "theorem",
    "type": "even (m ^ n) ↔ even m ∧ n ≠ 0"
  },
  {
    "name": "trunc_of_multiset_exists_mem",
    "statement": "def trunc_of_multiset_exists_mem {α : Type u_1} (s : multiset α) : (∃ (x : α), x ∈ s) → trunc α",
    "theorem": "{α : Type u_1} (s : multiset α) : (∃ (x : α), x ∈ s) → trunc α",
    "args": "{α : Type u_1} (s : multiset α)",
    "doc_string": "For `s : multiset α`, we can lift the existential statement that `∃ x, x ∈ s` to a `trunc α`.",
    "kind": "def",
    "type": "(∃ (x : α), x ∈ s) → trunc α"
  },
  {
    "name": "ring.neg_one_ne_one_of_char_ne_two",
    "statement": "theorem ring.neg_one_ne_one_of_char_ne_two {R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : -1 ≠ 1",
    "theorem": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : -1 ≠ 1",
    "args": "{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2)",
    "doc_string": "Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`.",
    "kind": "theorem",
    "type": "-1 ≠ 1"
  },
  {
    "name": "left.inv_le_one_iff",
    "statement": "theorem left.inv_le_one_iff {α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "theorem": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a",
    "args": "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α}",
    "doc_string": "Uses `left` co(ntra)variant.",
    "kind": "theorem",
    "type": "a⁻¹ ≤ 1 ↔ 1 ≤ a"
  },
  {
    "name": "even",
    "statement": "def even {α : Type u_2} [has_add α] (a : α) : Prop",
    "theorem": "{α : Type u_2} [has_add α] (a : α) : Prop",
    "args": "{α : Type u_2} [has_add α] (a : α)",
    "doc_string": "An element `a` of a type `α` with addition satisfies `even a` if `a = r + r`, for some `r : α`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "ordnode.valid",
    "statement": "def ordnode.valid {α : Type u_1} [preorder α] (t : ordnode α) : Prop",
    "theorem": "{α : Type u_1} [preorder α] (t : ordnode α) : Prop",
    "args": "{α : Type u_1} [preorder α] (t : ordnode α)",
    "doc_string": " The validity predicate for an `ordnode` subtree. This asserts that the `size` fields are correct, the tree is balanced, and the elements of the tree are organized according to the ordering.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pSet.sep",
    "statement": "def pSet.sep (p : set pSet) : pSet → pSet",
    "theorem": "(p : set pSet) : pSet → pSet",
    "args": "(p : set pSet)",
    "doc_string": "The pre-set separation operation `{x ∈ a | p x}`",
    "kind": "def",
    "type": "pSet → pSet"
  },
  {
    "name": "category_theory.sieve.union",
    "statement": "def category_theory.sieve.union {C : Type u₁} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X",
    "theorem": "{C : Type u₁} [category_theory.category C] {X : C} (S R : category_theory.sieve X) : category_theory.sieve X",
    "args": "{C : Type u₁} [category_theory.category C] {X : C} (S R : category_theory.sieve X)",
    "doc_string": "The union of two sieves is a sieve.",
    "kind": "def",
    "type": "category_theory.sieve X"
  },
  {
    "name": "poly_equiv_tensor.inv_fun",
    "statement": "def poly_equiv_tensor.inv_fun (R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] (p : polynomial A) : tensor_product R A (polynomial R)",
    "theorem": "(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] (p : polynomial A) : tensor_product R A (polynomial R)",
    "args": "(R : Type u_1) (A : Type u_2) [comm_semiring R] [semiring A] [algebra R A] (p : polynomial A)",
    "doc_string": "(Implementation detail.)  The bare function `polynomial A → A ⊗[R] R[X]`. (We don't need to show that it's an algebra map, thankfully --- just that it's an inverse.)",
    "kind": "def",
    "type": "tensor_product R A (polynomial R)"
  },
  {
    "name": "category_theory.small_groupoid",
    "statement": "def category_theory.small_groupoid (C : Type u) : Type (u+1)",
    "theorem": "(C : Type u) : Type (u+1)",
    "args": "(C : Type u)",
    "doc_string": "A `small_groupoid` is a groupoid where the objects and morphisms live in the same universe.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "is_simple_order.preorder",
    "statement": "def is_simple_order.preorder {α : Type u_1} [has_le α] [bounded_order α] [is_simple_order α] : preorder α",
    "theorem": "{α : Type u_1} [has_le α] [bounded_order α] [is_simple_order α] : preorder α",
    "args": "{α : Type u_1} [has_le α] [bounded_order α] [is_simple_order α]",
    "doc_string": "A simple `bounded_order` induces a preorder. This is not an instance to prevent loops.",
    "kind": "def",
    "type": "preorder α"
  },
  {
    "name": "zero_lt.right.mul_pos",
    "statement": "theorem zero_lt.right.mul_pos {α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 0 < a) (hb : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "0 < a * b"
  },
  {
    "name": "left.add_neg_of_nonpos_of_neg",
    "statement": "theorem left.add_neg_of_nonpos_of_neg {α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "theorem": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0",
    "args": "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0)",
    "doc_string": "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_nonpos_of_neg`.",
    "kind": "theorem",
    "type": "a + b < 0"
  },
  {
    "name": "cSup_singleton",
    "statement": "theorem cSup_singleton {α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a",
    "theorem": "{α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a",
    "args": "{α : Type u_1} [conditionally_complete_lattice α] (a : α)",
    "doc_string": "The supremum of a singleton is the element of the singleton",
    "kind": "theorem",
    "type": "has_Sup.Sup {a} = a"
  },
  {
    "name": "turing.to_partrec.code",
    "statement": "inductive turing.to_partrec.code  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The type of codes for primitive recursive functions. Unlike `nat.partrec.code`, this uses a set of operations on `list ℕ`. See `code.eval` for a description of the behavior of the primitives.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "group_filter_basis",
    "statement": "structure group_filter_basis (G : Type u) [group G] : Type u",
    "theorem": "(G : Type u) [group G] : Type u",
    "args": "(G : Type u) [group G]",
    "doc_string": "A `group_filter_basis` on a group is a `filter_basis` satisfying some additional axioms.  Example : if `G` is a topological group then the neighbourhoods of the identity are a  `group_filter_basis`. Conversely given a `group_filter_basis` one can define a topology  compatible with the group structure on `G`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "filter.has_neg",
    "statement": "def filter.has_neg {α : Type u_2} [has_neg α] : has_neg (filter α)",
    "theorem": "{α : Type u_2} [has_neg α] : has_neg (filter α)",
    "args": "{α : Type u_2} [has_neg α]",
    "doc_string": "The negation of a filter is the pointwise preimage under `-` of its sets.",
    "kind": "def",
    "type": "has_neg (filter α)"
  },
  {
    "name": "matrix.det_unique",
    "statement": "theorem matrix.det_unique {R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default",
    "theorem": "{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default",
    "args": "{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R)",
    "doc_string": " If `n` has only one element, the determinant of an `n` by `n` matrix is just that element. Although `unique` implies `decidable_eq` and `fintype`, the instances might not be syntactically equal. Thus, we need to fill in the args explicitly.",
    "kind": "theorem",
    "type": "A.det = A inhabited.default inhabited.default"
  },
  {
    "name": "submonoid.has_bot",
    "statement": "def submonoid.has_bot {M : Type u_1} [mul_one_class M] : has_bot (submonoid M)",
    "theorem": "{M : Type u_1} [mul_one_class M] : has_bot (submonoid M)",
    "args": "{M : Type u_1} [mul_one_class M]",
    "doc_string": "The trivial submonoid `{1}` of an monoid `M`.",
    "kind": "def",
    "type": "has_bot (submonoid M)"
  },
  {
    "name": "topological_space.metrizable_space",
    "statement": "structure topological_space.metrizable_space (X : Type u_5) [t : topological_space X] : Prop",
    "theorem": "(X : Type u_5) [t : topological_space X] : Prop",
    "args": "(X : Type u_5) [t : topological_space X]",
    "doc_string": " A topological space is metrizable if there exists a metric space structure compatible with the topology. To endow such a space with a compatible distance, use `letI : metric_space X := topological_space.metrizable_space_metric X`",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "module.free",
    "statement": "structure module.free (R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "theorem": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M] : Prop",
    "args": "(R : Type u) (M : Type v) [semiring R] [add_comm_monoid M] [module R M]",
    "doc_string": "`module.free R M` is the statement that the `R`-module `M` is free.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "ratfunc.add",
    "statement": "def ratfunc.add {K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K → ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] : ratfunc K → ratfunc K → ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K]",
    "doc_string": "Addition of rational functions.",
    "kind": "def",
    "type": "ratfunc K → ratfunc K → ratfunc K"
  },
  {
    "name": "formal_multilinear_series.comp_change_of_variables",
    "statement": "def formal_multilinear_series.comp_change_of_variables (m M N : ℕ) (i : Σ (n : ℕ), fin n → ℕ) (hi : i ∈ formal_multilinear_series.comp_partial_sum_source m M N) : Σ (n : ℕ), composition n",
    "theorem": "(m M N : ℕ) (i : Σ (n : ℕ), fin n → ℕ) (hi : i ∈ formal_multilinear_series.comp_partial_sum_source m M N) : Σ (n : ℕ), composition n",
    "args": "(m M N : ℕ) (i : Σ (n : ℕ), fin n → ℕ) (hi : i ∈ formal_multilinear_series.comp_partial_sum_source m M N)",
    "doc_string": " Change of variables appearing to compute the composition of partial sums of formal power series",
    "kind": "def",
    "type": "Σ (n : ℕ), composition n"
  },
  {
    "name": "invertible",
    "statement": "structure invertible {α : Type u} [has_mul α] [has_one α] (a : α) : Type u",
    "theorem": "{α : Type u} [has_mul α] [has_one α] (a : α) : Type u",
    "args": "{α : Type u} [has_mul α] [has_one α] (a : α)",
    "doc_string": "`invertible a` gives a two-sided multiplicative inverse of `a`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "ascending_central_series_le_upper",
    "statement": "theorem ascending_central_series_le_upper {G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ) : H n ≤ upper_central_series G n",
    "theorem": "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ) : H n ≤ upper_central_series G n",
    "args": "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ)",
    "doc_string": "Any ascending central series for a group is bounded above by the upper central series.",
    "kind": "theorem",
    "type": "H n ≤ upper_central_series G n"
  },
  {
    "name": "multiset.Iio",
    "statement": "def multiset.Iio {α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : multiset α",
    "theorem": "{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α) : multiset α",
    "args": "{α : Type u_1} [preorder α] [order_bot α] [locally_finite_order α] (b : α)",
    "doc_string": "The multiset of elements `x` such that `x < b`. Basically `set.Iio b` as a multiset.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "tactic",
    "statement": "def tactic (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "`tactic` is the monad for building tactics.    You use this to:    - View and modify the local goals and hypotheses in the prover's state.    - Invoke type checking and elaboration of terms.    - View and modify the environment.    - Build new tactics out of existing ones such as `simp` and `rewrite`.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "list.zip_right'",
    "statement": "def list.zip_right' {α : Type u_1} {β : Type u_2} : list α → list β → list (option α × β) × list α",
    "theorem": "{α : Type u_1} {β : Type u_2} : list α → list β → list (option α × β) × list α",
    "args": "{α : Type u_1} {β : Type u_2}",
    "doc_string": "Right-biased version of `list.zip`. `zip_right' as bs` returns the list of pairs `(aᵢ, bᵢ)` for `aᵢ ∈ as` and `bᵢ ∈ bs`. If `as` is shorter than `bs`, the remaining `bᵢ` are paired with `none`. Also returns the remaining `as`.  ```lean zip_right' [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])  zip_right' [1, 2] ['a'] = ([(some 1, 'a')], [2])  zip_right' = map₂_right' prod.mk ```",
    "kind": "def",
    "type": "list α → list β → list (option α × β) × list α"
  },
  {
    "name": "reducibility_hints",
    "statement": "inductive reducibility_hints  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Reducibility hints are used in the convertibility checker. When trying to solve a constraint such a             (f ...) =?= (g ...)  where f and g are definitions, the checker has to decide which one will be unfolded.   If      f (g) is opaque,     then g (f) is unfolded if it is also not marked as opaque,   Else if f (g) is abbrev,     then f (g) is unfolded if g (f) is also not marked as abbrev,   Else if f and g are regular, then we unfold the one with the biggest definitional height.   Otherwise both are unfolded.  The arguments of the `regular` constructor are: the definitional height and the flag `self_opt`.  The definitional height is by default computed by the kernel. It only takes into account other regular definitions used in a definition. When creating declarations using meta-programming, we can specify the definitional depth manually.  For definitions marked as regular, we also have a hint for constraints such as            (f a) =?= (f b)  if self_opt == true, then checker will first try to solve (a =?= b), only if it fails, it unfolds f.  Remark: the hint only affects performance. None of the hints prevent the kernel from unfolding a declaration during type checking.  Remark: the reducibility_hints are not related to the attributes: reducible/irrelevance/semireducible. These attributes are used by the elaborator. The reducibility_hints are used by the kernel (and elaborator). Moreover, the reducibility_hints cannot be changed after a declaration is added to the kernel.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "set.eq_on",
    "statement": "def set.eq_on {α : Type u} {β : Type v} (f₁ f₂ : α → β) (s : set α) : Prop",
    "theorem": "{α : Type u} {β : Type v} (f₁ f₂ : α → β) (s : set α) : Prop",
    "args": "{α : Type u} {β : Type v} (f₁ f₂ : α → β) (s : set α)",
    "doc_string": "Two functions `f₁ f₂ : α → β` are equal on `s`  if `f₁ x = f₂ x` for all `x ∈ a`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "category_theory.shift_functor_faithful",
    "statement": "def category_theory.shift_functor_faithful (C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.faithful (category_theory.shift_functor C i)",
    "theorem": "(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A) : category_theory.faithful (category_theory.shift_functor C i)",
    "args": "(C : Type u) {A : Type u_1} [category_theory.category C] [add_group A] [category_theory.has_shift C A] (i : A)",
    "doc_string": "Shifting by `n` is a faithful functor.",
    "kind": "def",
    "type": "category_theory.faithful (category_theory.shift_functor C i)"
  },
  {
    "name": "category_theory.abelian.pseudo_equal_trans",
    "statement": "theorem category_theory.abelian.pseudo_equal_trans {C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C}",
    "doc_string": "Pseudoequality is transitive: Just take the pullback. The pullback morphisms will    be epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms.",
    "kind": "theorem",
    "type": "transitive (category_theory.abelian.pseudo_equal P)"
  },
  {
    "name": "function.fun_setoid",
    "statement": "def function.fun_setoid (α : Sort u) (β : α → Sort v) : setoid (Π (x : α), β x)",
    "theorem": "(α : Sort u) (β : α → Sort v) : setoid (Π (x : α), β x)",
    "args": "(α : Sort u) (β : α → Sort v)",
    "doc_string": "The setoid generated by pointwise equality.",
    "kind": "def",
    "type": "setoid (Π (x : α), β x)"
  },
  {
    "name": "category_theory.abelian.has_pullbacks",
    "statement": "def category_theory.abelian.has_pullbacks {C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pullbacks C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.abelian C] : category_theory.limits.has_pullbacks C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.abelian C]",
    "doc_string": "Any abelian category has pullbacks",
    "kind": "def",
    "type": "category_theory.limits.has_pullbacks C"
  },
  {
    "name": "slim_check.no_shrink",
    "statement": "def slim_check.no_shrink (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": " `no_shrink` is a type annotation to signal that a certain type is not to be shrunk. It can be useful in combination with other types: e.g. `xs : list (no_shrink ℤ)` will result in the list being cut down but individual integers being kept as is.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "add_group_topology",
    "statement": "structure add_group_topology (α : Type u) [add_group α] : Type u",
    "theorem": "(α : Type u) [add_group α] : Type u",
    "args": "(α : Type u) [add_group α]",
    "doc_string": "An additive group topology on an additive group `α` is a topology for which addition and  negation are continuous.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "normed_field",
    "statement": "structure normed_field (α : Type u_5) : Type u_5",
    "theorem": "(α : Type u_5) : Type u_5",
    "args": "(α : Type u_5)",
    "doc_string": "A normed field is a field with a norm satisfying ∥x y∥ = ∥x∥ ∥y∥.",
    "kind": "structure",
    "type": "Type u_5"
  },
  {
    "name": "is_dedekind_domain_iff_is_dedekind_domain_inv",
    "statement": "theorem is_dedekind_domain_iff_is_dedekind_domain_inv {A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A ↔ is_dedekind_domain_inv A",
    "theorem": "{A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A ↔ is_dedekind_domain_inv A",
    "args": "{A : Type u_2} [comm_ring A] [is_domain A]",
    "doc_string": " `is_dedekind_domain` and `is_dedekind_domain_inv` are equivalent ways to express that an integral domain is a Dedekind domain.",
    "kind": "theorem",
    "type": "is_dedekind_domain A ↔ is_dedekind_domain_inv A"
  },
  {
    "name": "con.con_gen_mono",
    "statement": "theorem con.con_gen_mono {M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : con_gen r ≤ con_gen s",
    "theorem": "{M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : con_gen r ≤ con_gen s",
    "args": "{M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y)",
    "doc_string": "Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation    containing `s` contains the smallest congruence relation containing `r`.",
    "kind": "theorem",
    "type": "con_gen r ≤ con_gen s"
  },
  {
    "name": "galois_insertion.lift_semilattice_inf",
    "statement": "def galois_insertion.lift_semilattice_inf {α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [semilattice_inf α] (gi : galois_insertion l u) : semilattice_inf β",
    "theorem": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [semilattice_inf α] (gi : galois_insertion l u) : semilattice_inf β",
    "args": "{α : Type u} {β : Type v} {l : α → β} {u : β → α} [partial_order β] [semilattice_inf α] (gi : galois_insertion l u)",
    "doc_string": "Lift the infima along a Galois insertion",
    "kind": "def",
    "type": "semilattice_inf β"
  },
  {
    "name": "zero_lt.right.one_le_mul_of_le_of_le",
    "statement": "theorem zero_lt.right.one_le_mul_of_le_of_le {α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b) : 1 ≤ a * b",
    "theorem": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b) : 1 ≤ a * b",
    "args": "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "1 ≤ a * b"
  },
  {
    "name": "ordnode.find",
    "statement": "def ordnode.find {α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "theorem": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α) : ordnode α → option α",
    "args": "{α : Type u} [has_le α] [decidable_rel has_le.le] (x : α)",
    "doc_string": " O(log n). Retrieve an element in the set that is equivalent to `x` in the order, if it exists.      find 1 {1, 2, 3} = some 1     find 4 {1, 2, 3} = none  Using a preorder on `ℕ × ℕ` that only compares the first coordinate:      find (1, 1) {(0, 1), (1, 2)} = some (1, 2)     find (3, 1) {(0, 1), (1, 2)} = none",
    "kind": "def",
    "type": "ordnode α → option α"
  },
  {
    "name": "multiset.sub_le_iff_le_add",
    "statement": "theorem multiset.sub_le_iff_le_add {α : Type u_1} [decidable_eq α] {s t u : multiset α} : s - t ≤ u ↔ s ≤ u + t",
    "theorem": "{α : Type u_1} [decidable_eq α] {s t u : multiset α} : s - t ≤ u ↔ s ≤ u + t",
    "args": "{α : Type u_1} [decidable_eq α] {s t u : multiset α}",
    "doc_string": "This is a special case of `tsub_le_iff_right`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset α)`.",
    "kind": "theorem",
    "type": "s - t ≤ u ↔ s ≤ u + t"
  },
  {
    "name": "list.chain",
    "statement": "inductive list.chain {α : Type u_1} (R : α → α → Prop) : α → list α → Prop",
    "theorem": "{α : Type u_1} (R : α → α → Prop) : α → list α → Prop",
    "args": "{α : Type u_1} (R : α → α → Prop)",
    "doc_string": "`chain R a l` means that `R` holds between adjacent elements of `a::l`.      chain R a [b, c, d] ↔ R a b ∧ R b c ∧ R c d",
    "kind": "inductive",
    "type": "α → list α → Prop"
  },
  {
    "name": "continuous_map.continuous_coe'",
    "statement": "theorem continuous_map.continuous_coe' {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous coe_fn",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous coe_fn",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α]",
    "doc_string": "See also `continuous_map.continuous_coe`",
    "kind": "theorem",
    "type": "continuous coe_fn"
  },
  {
    "name": "bilin_form.is_alt",
    "statement": "def bilin_form.is_alt {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop",
    "theorem": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M) : Prop",
    "args": "{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] (B : bilin_form R M)",
    "doc_string": "The proposition that a bilinear form is alternating",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "has_dvd.dvd.mul_left",
    "statement": "theorem has_dvd.dvd.mul_left {α : Type u_1} [comm_semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ c * b",
    "theorem": "{α : Type u_1} [comm_semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ c * b",
    "args": "{α : Type u_1} [comm_semigroup α] {a b : α} (h : a ∣ b) (c : α)",
    "doc_string": "**Alias** of dvd_mul_of_dvd_right`.",
    "kind": "theorem",
    "type": "a ∣ c * b"
  },
  {
    "name": "count_succ_eq_count",
    "statement": "theorem count_succ_eq_count {p : ℕ → Prop} [decidable_pred p] {n : ℕ} : ¬p n → nat.count p (n + 1) = nat.count p n",
    "theorem": "{p : ℕ → Prop} [decidable_pred p] {n : ℕ} : ¬p n → nat.count p (n + 1) = nat.count p n",
    "args": "{p : ℕ → Prop} [decidable_pred p] {n : ℕ}",
    "doc_string": "**Alias** of the reverse direction of nat.count_succ_eq_count_iff`.",
    "kind": "theorem",
    "type": "¬p n → nat.count p (n + 1) = nat.count p n"
  },
  {
    "name": "weak_space",
    "statement": "def weak_space (𝕜 : Type u_1) (E : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Type u_2",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E] : Type u_2",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [comm_semiring 𝕜] [topological_space 𝕜] [has_continuous_add 𝕜] [has_continuous_const_smul 𝕜 𝕜] [add_comm_monoid E] [module 𝕜 E] [topological_space E]",
    "doc_string": " The weak topology is the topology coarsest topology on `E` such that all functionals `λ x, top_dual_pairing 𝕜 E v x` are continuous.",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "neg.is_add_group_hom",
    "statement": "theorem neg.is_add_group_hom {α : Type u} [add_comm_group α] : is_add_group_hom has_neg.neg",
    "theorem": "{α : Type u} [add_comm_group α] : is_add_group_hom has_neg.neg",
    "args": "{α : Type u} [add_comm_group α]",
    "doc_string": "Negation is an `add_group` homomorphism if the `add_group` is commutative.",
    "kind": "theorem",
    "type": "is_add_group_hom has_neg.neg"
  },
  {
    "name": "simple_continued_fraction.of",
    "statement": "def simple_continued_fraction.of {K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : simple_continued_fraction K",
    "theorem": "{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K] : simple_continued_fraction K",
    "args": "{K : Type u_1} (v : K) [linear_ordered_field K] [floor_ring K]",
    "doc_string": "Creates the simple continued fraction of a value.",
    "kind": "def",
    "type": "simple_continued_fraction K"
  },
  {
    "name": "esakia_hom.to_pseudo_epimorphism",
    "statement": "def esakia_hom.to_pseudo_epimorphism {α : Type u_2} {β : Type u_3} [topological_space α] [preorder α] [topological_space β] [preorder β] (f : esakia_hom α β) : pseudo_epimorphism α β",
    "theorem": "{α : Type u_2} {β : Type u_3} [topological_space α] [preorder α] [topological_space β] [preorder β] (f : esakia_hom α β) : pseudo_epimorphism α β",
    "args": "{α : Type u_2} {β : Type u_3} [topological_space α] [preorder α] [topological_space β] [preorder β] (f : esakia_hom α β)",
    "doc_string": "Reinterpret an `esakia_hom` as a `pseudo_epimorphism`.",
    "kind": "def",
    "type": "pseudo_epimorphism α β"
  },
  {
    "name": "is_algebraic_iff_is_integral",
    "statement": "theorem is_algebraic_iff_is_integral {K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x",
    "theorem": "{K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x",
    "args": "{K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A}",
    "doc_string": "An element of an algebra over a field is algebraic if and only if it is integral.",
    "kind": "theorem",
    "type": "is_algebraic K x ↔ is_integral K x"
  },
  {
    "name": "onote.cmp",
    "statement": "def onote.cmp  : onote → onote → ordering",
    "theorem": " : onote → onote → ordering",
    "args": "",
    "doc_string": "Compare ordinal notations",
    "kind": "def",
    "type": "onote → onote → ordering"
  },
  {
    "name": "has_dvd.dvd.mul_right",
    "statement": "theorem has_dvd.dvd.mul_right {α : Type u_1} [semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ b * c",
    "theorem": "{α : Type u_1} [semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ b * c",
    "args": "{α : Type u_1} [semigroup α] {a b : α} (h : a ∣ b) (c : α)",
    "doc_string": "**Alias** of dvd_mul_of_dvd_left`.",
    "kind": "theorem",
    "type": "a ∣ b * c"
  },
  {
    "name": "set.interval_oc",
    "statement": "def set.interval_oc {α : Type u} [linear_order α] : α → α → set α",
    "theorem": "{α : Type u} [linear_order α] : α → α → set α",
    "args": "{α : Type u} [linear_order α]",
    "doc_string": "The open-closed interval with unordered bounds.",
    "kind": "def",
    "type": "α → α → set α"
  },
  {
    "name": "metric.sigma.has_dist",
    "statement": "def metric.sigma.has_dist {ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), metric_space (E i)] : has_dist (Σ (i : ι), E i)",
    "theorem": "{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), metric_space (E i)] : has_dist (Σ (i : ι), E i)",
    "args": "{ι : Type u_1} {E : ι → Type u_2} [Π (i : ι), metric_space (E i)]",
    "doc_string": " A `has_dist` instance on the disjoint union `Σ i, E i`. We embed isometrically each factor, set the basepoints at distance 1, arbitrarily, and say that the distance from `a` to `b` is the sum of the distances of `a` and `b` to their respective basepoints, plus the distance 1 between the basepoints. Since there is an arbitrary choice in this construction, it is not an instance by default.",
    "kind": "def",
    "type": "has_dist (Σ (i : ι), E i)"
  },
  {
    "name": "category_theory.congruence",
    "statement": "structure category_theory.congruence {C : Type u_1} [category_theory.category C] (r : hom_rel C) : Prop",
    "theorem": "{C : Type u_1} [category_theory.category C] (r : hom_rel C) : Prop",
    "args": "{C : Type u_1} [category_theory.category C] (r : hom_rel C)",
    "doc_string": " A `hom_rel` is a congruence when it's an equivalence on every hom-set, and it can be composed from left and right.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "polynomial.map_cyclotomic_int",
    "statement": "theorem polynomial.map_cyclotomic_int (n : ℕ) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ℤ) = polynomial.cyclotomic n R",
    "theorem": "(n : ℕ) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ℤ) = polynomial.cyclotomic n R",
    "args": "(n : ℕ) (R : Type u_1) [ring R]",
    "doc_string": "`cyclotomic n R` comes from `cyclotomic n ℤ`.",
    "kind": "theorem",
    "type": "polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ℤ) = polynomial.cyclotomic n R"
  },
  {
    "name": "int.range",
    "statement": "def int.range (m n : ℤ) : list ℤ",
    "theorem": "(m n : ℤ) : list ℤ",
    "args": "(m n : ℤ)",
    "doc_string": "List enumerating `[m, n)`. This is the ℤ variant of `list.Ico`.",
    "kind": "def",
    "type": "list ℤ"
  },
  {
    "name": "task",
    "statement": "constant task  : Type u → Type u",
    "theorem": " : Type u → Type u",
    "args": "",
    "doc_string": "A task is a promise to produce a value later. They perform the same role as promises in JavaScript.",
    "kind": "constant",
    "type": "Type u → Type u"
  },
  {
    "name": "Group.has_limits_of_size",
    "statement": "def Group.has_limits_of_size  : category_theory.limits.has_limits_of_size Group",
    "theorem": " : category_theory.limits.has_limits_of_size Group",
    "args": "",
    "doc_string": "The category of groups has all limits.",
    "kind": "def",
    "type": "category_theory.limits.has_limits_of_size Group"
  },
  {
    "name": "quadratic_form.pos_def",
    "statement": "def quadratic_form.pos_def {M : Type u_3} [add_comm_group M] {R₂ : Type u} [ordered_ring R₂] [module R₂ M] (Q₂ : quadratic_form R₂ M) : Prop",
    "theorem": "{M : Type u_3} [add_comm_group M] {R₂ : Type u} [ordered_ring R₂] [module R₂ M] (Q₂ : quadratic_form R₂ M) : Prop",
    "args": "{M : Type u_3} [add_comm_group M] {R₂ : Type u} [ordered_ring R₂] [module R₂ M] (Q₂ : quadratic_form R₂ M)",
    "doc_string": "A positive definite quadratic form is positive on nonzero vectors.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "sup_bot_hom.id",
    "statement": "def sup_bot_hom.id (α : Type u_3) [has_sup α] [has_bot α] : sup_bot_hom α α",
    "theorem": "(α : Type u_3) [has_sup α] [has_bot α] : sup_bot_hom α α",
    "args": "(α : Type u_3) [has_sup α] [has_bot α]",
    "doc_string": "`id` as a `sup_bot_hom`.",
    "kind": "def",
    "type": "sup_bot_hom α α"
  },
  {
    "name": "int.of_snum",
    "statement": "def int.of_snum  : snum → ℤ",
    "theorem": " : snum → ℤ",
    "args": "",
    "doc_string": "Cast a `snum` to the corresponding integer.",
    "kind": "def",
    "type": "snum → ℤ"
  },
  {
    "name": "onote.sub",
    "statement": "def onote.sub  : onote → onote → onote",
    "theorem": " : onote → onote → onote",
    "args": "",
    "doc_string": "Subtraction of ordinal notations (correct only for normal input)",
    "kind": "def",
    "type": "onote → onote → onote"
  },
  {
    "name": "quotient_group.subgroup.has_quotient",
    "statement": "def quotient_group.subgroup.has_quotient {α : Type u_1} [group α] : has_quotient α (subgroup α)",
    "theorem": "{α : Type u_1} [group α] : has_quotient α (subgroup α)",
    "args": "{α : Type u_1} [group α]",
    "doc_string": "`α ⧸ s` is the quotient type representing the left cosets of `s`.  If `s` is a normal subgroup, `α ⧸ s` is a group",
    "kind": "def",
    "type": "has_quotient α (subgroup α)"
  },
  {
    "name": "LinearOrder",
    "statement": "def LinearOrder  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of linear orders.",
    "kind": "def",
    "type": "Type (u_1+1)"
  },
  {
    "name": "uniform_space",
    "statement": "structure uniform_space (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A uniform space is a generalization of the \"uniform\" topological aspects of a  metric space. It consists of a filter on `α × α` called the \"uniformity\", which  satisfies properties analogous to the reflexivity, symmetry, and triangle properties  of a metric.   A metric space has a natural uniformity, and a uniform space has a natural topology.  A topological group also has a natural uniformity, even when it is not metrizable.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "polynomial.of_finsupp_inj",
    "statement": "theorem polynomial.of_finsupp_inj {R : Type u} [semiring R] {a b : add_monoid_algebra R ℕ} : {to_finsupp := a} = {to_finsupp := b} ↔ a = b",
    "theorem": "{R : Type u} [semiring R] {a b : add_monoid_algebra R ℕ} : {to_finsupp := a} = {to_finsupp := b} ↔ a = b",
    "args": "{R : Type u} [semiring R] {a b : add_monoid_algebra R ℕ}",
    "doc_string": "A more convenient spelling of `polynomial.of_finsupp.inj_eq` in terms of `iff`.",
    "kind": "theorem",
    "type": "{to_finsupp := a} = {to_finsupp := b} ↔ a = b"
  },
  {
    "name": "nat.prime_counting'",
    "statement": "def nat.prime_counting'  : ℕ → ℕ",
    "theorem": " : ℕ → ℕ",
    "args": "",
    "doc_string": "A variant of the traditional prime counting function which gives the number of primes *strictly* less than the input. More convenient for avoiding off-by-one errors.",
    "kind": "def",
    "type": "ℕ → ℕ"
  },
  {
    "name": "category_theory.limits.has_zero_object.has_terminal",
    "statement": "def category_theory.limits.has_zero_object.has_terminal {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_terminal C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] : category_theory.limits.has_terminal C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C]",
    "doc_string": "A zero object is in particular terminal.",
    "kind": "def",
    "type": "category_theory.limits.has_terminal C"
  },
  {
    "name": "matrix.sub_down_right",
    "statement": "def matrix.sub_down_right {α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α) : matrix (fin d) (fin r) α",
    "theorem": "{α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α) : matrix (fin d) (fin r) α",
    "args": "{α : Type v} {d u l r : ℕ} (A : matrix (fin (u + d)) (fin (l + r)) α)",
    "doc_string": "The bottom-right `d × r` part of a `(u+d) × (l+r)` matrix.",
    "kind": "def",
    "type": "matrix (fin d) (fin r) α"
  },
  {
    "name": "is_add_submonoid.multiset_sum_mem",
    "statement": "theorem is_add_submonoid.multiset_sum_mem {M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.sum ∈ s",
    "theorem": "{M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → m.sum ∈ s",
    "args": "{M : Type u_1} [add_comm_monoid M] {s : set M} (hs : is_add_submonoid s) (m : multiset M)",
    "doc_string": "The sum of a multiset of elements of an `add_submonoid` of an `add_comm_monoid` is an element of the `add_submonoid`.",
    "kind": "theorem",
    "type": "(∀ (a : M), a ∈ m → a ∈ s) → m.sum ∈ s"
  },
  {
    "name": "is_subgroup.center",
    "statement": "def is_subgroup.center (G : Type u_1) [group G] : set G",
    "theorem": "(G : Type u_1) [group G] : set G",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "The underlying set of the center of a group.",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "equiv.mul_right₀",
    "statement": "def equiv.mul_right₀ {G : Type u_10} [group_with_zero G] (a : G) (ha : a ≠ 0) : equiv.perm G",
    "theorem": "{G : Type u_10} [group_with_zero G] (a : G) (ha : a ≠ 0) : equiv.perm G",
    "args": "{G : Type u_10} [group_with_zero G] (a : G) (ha : a ≠ 0)",
    "doc_string": " Right multiplication by a nonzero element in a `group_with_zero` is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm G"
  },
  {
    "name": "nat.factorization_inj",
    "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}",
    "theorem": " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}",
    "args": "",
    "doc_string": "Every nonzero natural number has a unique prime factorization",
    "kind": "theorem",
    "type": "set.inj_on nat.factorization {x : ℕ | x ≠ 0}"
  },
  {
    "name": "free_product.word.empty",
    "statement": "def free_product.word.empty {ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] : free_product.word M",
    "theorem": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)] : free_product.word M",
    "args": "{ι : Type u_1} {M : ι → Type u_2} [Π (i : ι), monoid (M i)]",
    "doc_string": "The empty reduced word.",
    "kind": "def",
    "type": "free_product.word M"
  },
  {
    "name": "list.sorted.insertion_sort_eq",
    "statement": "theorem list.sorted.insertion_sort_eq {α : Type uu} {r : α → α → Prop} [decidable_rel r] {l : list α} (h : list.sorted r l) : list.insertion_sort r l = l",
    "theorem": "{α : Type uu} {r : α → α → Prop} [decidable_rel r] {l : list α} (h : list.sorted r l) : list.insertion_sort r l = l",
    "args": "{α : Type uu} {r : α → α → Prop} [decidable_rel r] {l : list α} (h : list.sorted r l)",
    "doc_string": " If `l` is already `list.sorted` with respect to `r`, then `insertion_sort` does not change it.",
    "kind": "theorem",
    "type": "list.insertion_sort r l = l"
  },
  {
    "name": "nat.pow_dvd_pow_iff_le_right",
    "statement": "theorem nat.pow_dvd_pow_iff_le_right {x k l : ℕ} (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l",
    "theorem": "{x k l : ℕ} (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l",
    "args": "{x k l : ℕ} (w : 1 < x)",
    "doc_string": "If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`.",
    "kind": "theorem",
    "type": "x ^ k ∣ x ^ l ↔ k ≤ l"
  },
  {
    "name": "fintype.univ_of_is_empty",
    "statement": "theorem fintype.univ_of_is_empty {α : Type u_1} [is_empty α] : finset.univ = ∅",
    "theorem": "{α : Type u_1} [is_empty α] : finset.univ = ∅",
    "args": "{α : Type u_1} [is_empty α]",
    "doc_string": " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about arbitrary `fintype` instances, use `finset.univ_eq_empty`.",
    "kind": "theorem",
    "type": "finset.univ = ∅"
  },
  {
    "name": "is_topological_fiber_bundle.surjective_proj",
    "statement": "theorem is_topological_fiber_bundle.surjective_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj)",
    "doc_string": " The projection from a topological fiber bundle with a nonempty fiber to its base is a surjective map.",
    "kind": "theorem",
    "type": "function.surjective proj"
  },
  {
    "name": "category_theory.limits.wide_pushout_shape",
    "statement": "def category_theory.limits.wide_pushout_shape (J : Type v) : Type v",
    "theorem": "(J : Type v) : Type v",
    "args": "(J : Type v)",
    "doc_string": "A wide pushout shape for any type `J` can be written simply as `option J`.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "quotient.out",
    "statement": "def quotient.out {α : Sort u_1} [s : setoid α] : quotient s → α",
    "theorem": "{α : Sort u_1} [s : setoid α] : quotient s → α",
    "args": "{α : Sort u_1} [s : setoid α]",
    "doc_string": "Choose an element of the equivalence class using the axiom of choice.  Sound but noncomputable.",
    "kind": "def",
    "type": "quotient s → α"
  },
  {
    "name": "first_order.language.elementary_substructure",
    "statement": "structure first_order.language.elementary_substructure (L : first_order.language) (M : Type u_3) [L.Structure M] : Type u_3",
    "theorem": "(L : first_order.language) (M : Type u_3) [L.Structure M] : Type u_3",
    "args": "(L : first_order.language) (M : Type u_3) [L.Structure M]",
    "doc_string": "An elementary substructure is one in which every formula applied to a tuple in the subtructure  agrees with its value in the overall structure.",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "submonoid.left_inv",
    "statement": "def submonoid.left_inv {M : Type u_1} [monoid M] (S : submonoid M) : submonoid M",
    "theorem": "{M : Type u_1} [monoid M] (S : submonoid M) : submonoid M",
    "args": "{M : Type u_1} [monoid M] (S : submonoid M)",
    "doc_string": "`S.left_inv` is the submonoid containing all the left inverses of `S`.",
    "kind": "def",
    "type": "submonoid M"
  },
  {
    "name": "algebra.trace_form",
    "statement": "def algebra.trace_form (R : Type u_1) (S : Type u_2) [comm_ring R] [comm_ring S] [algebra R S] : bilin_form R S",
    "theorem": "(R : Type u_1) (S : Type u_2) [comm_ring R] [comm_ring S] [algebra R S] : bilin_form R S",
    "args": "(R : Type u_1) (S : Type u_2) [comm_ring R] [comm_ring S] [algebra R S]",
    "doc_string": " The `trace_form` maps `x y : S` to the trace of `x * y`. It is a symmetric bilinear form and is nondegenerate if the extension is separable.",
    "kind": "def",
    "type": "bilin_form R S"
  },
  {
    "name": "subfield.ext",
    "statement": "theorem subfield.ext {K : Type u} [field K] {S T : subfield K} (h : ∀ (x : K), x ∈ S ↔ x ∈ T) : S = T",
    "theorem": "{K : Type u} [field K] {S T : subfield K} (h : ∀ (x : K), x ∈ S ↔ x ∈ T) : S = T",
    "args": "{K : Type u} [field K] {S T : subfield K} (h : ∀ (x : K), x ∈ S ↔ x ∈ T)",
    "doc_string": "Two subfields are equal if they have the same elements.",
    "kind": "theorem",
    "type": "S = T"
  },
  {
    "name": "super_chain",
    "statement": "def super_chain {α : Type u_1} (r : α → α → Prop) (s t : set α) : Prop",
    "theorem": "{α : Type u_1} (r : α → α → Prop) (s t : set α) : Prop",
    "args": "{α : Type u_1} (r : α → α → Prop) (s t : set α)",
    "doc_string": "`super_chain s t` means that `t` is a chain that strictly includes `s`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.has_zpow",
    "statement": "def finset.has_zpow {α : Type u_2} [decidable_eq α] [has_one α] [has_mul α] [has_inv α] : has_pow (finset α) ℤ",
    "theorem": "{α : Type u_2} [decidable_eq α] [has_one α] [has_mul α] [has_inv α] : has_pow (finset α) ℤ",
    "args": "{α : Type u_2} [decidable_eq α] [has_one α] [has_mul α] [has_inv α]",
    "doc_string": " Repeated pointwise multiplication/division (not the same as pointwise repeated multiplication/division!) of a `finset`. See note [pointwise nat action].",
    "kind": "def",
    "type": "has_pow (finset α) ℤ"
  },
  {
    "name": "category_theory.zigzag",
    "statement": "def category_theory.zigzag {J : Type u₁} [category_theory.category J] : J → J → Prop",
    "theorem": "{J : Type u₁} [category_theory.category J] : J → J → Prop",
    "args": "{J : Type u₁} [category_theory.category J]",
    "doc_string": "`j₁` and `j₂` are related by `zigzag` if there is a chain of morphisms from `j₁` to `j₂`, with backward morphisms allowed.",
    "kind": "def",
    "type": "J → J → Prop"
  },
  {
    "name": "add_con.mk'_ker",
    "statement": "theorem add_con.mk'_ker {M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c",
    "theorem": "{M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c",
    "args": "{M : Type u_1} [add_zero_class M] (c : add_con M)",
    "doc_string": "The kernel of the natural homomorphism from an `add_monoid` to its quotient by an additive congruence relation `c` equals `c`.",
    "kind": "theorem",
    "type": "add_con.ker c.mk' = c"
  },
  {
    "name": "homotopy_equiv",
    "statement": "structure homotopy_equiv {ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} (C D : homological_complex V c) : Type (max u_1 v)",
    "theorem": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} (C D : homological_complex V c) : Type (max u_1 v)",
    "args": "{ι : Type u_1} {V : Type u} [category_theory.category V] [category_theory.preadditive V] {c : complex_shape ι} (C D : homological_complex V c)",
    "doc_string": "A homotopy equivalence between two chain complexes consists of a chain map each way, and homotopies from the compositions to the identity chain maps.  Note that this contains data; arguably it might be more useful for many applications if we truncated it to a Prop.",
    "kind": "structure",
    "type": "Type (max u_1 v)"
  },
  {
    "name": "quotient_group.left_rel",
    "statement": "def quotient_group.left_rel {α : Type u_1} [group α] (s : subgroup α) : setoid α",
    "theorem": "{α : Type u_1} [group α] (s : subgroup α) : setoid α",
    "args": "{α : Type u_1} [group α] (s : subgroup α)",
    "doc_string": " The equivalence relation corresponding to the partition of a group by left cosets of a subgroup.",
    "kind": "def",
    "type": "setoid α"
  },
  {
    "name": "is_topological_fiber_bundle.quotient_map_proj",
    "statement": "theorem is_topological_fiber_bundle.quotient_map_proj {B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj",
    "theorem": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj",
    "args": "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj)",
    "doc_string": " The projection from a topological fiber bundle with a nonempty fiber to its base is a quotient map.",
    "kind": "theorem",
    "type": "quotient_map proj"
  },
  {
    "name": "onote.of_nat",
    "statement": "def onote.of_nat  : ℕ → onote",
    "theorem": " : ℕ → onote",
    "args": "",
    "doc_string": "Convert a `nat` into an ordinal",
    "kind": "def",
    "type": "ℕ → onote"
  },
  {
    "name": "local_homeomorph.eq_on_source",
    "statement": "def local_homeomorph.eq_on_source {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e e' : local_homeomorph α β) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e e' : local_homeomorph α β) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (e e' : local_homeomorph α β)",
    "doc_string": " `eq_on_source e e'` means that `e` and `e'` have the same source, and coincide there. They should really be considered the same local equiv.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "polynomial.eval_sub_factor",
    "statement": "def polynomial.eval_sub_factor {R : Type u} [comm_ring R] (f : polynomial R) (x y : R) : {z // polynomial.eval x f - polynomial.eval y f = z * (x - y)}",
    "theorem": "{R : Type u} [comm_ring R] (f : polynomial R) (x y : R) : {z // polynomial.eval x f - polynomial.eval y f = z * (x - y)}",
    "args": "{R : Type u} [comm_ring R] (f : polynomial R) (x y : R)",
    "doc_string": "For any polynomial `f`, `f.eval x - f.eval y` can be expressed as `z * (x - y)` for some `z` in the ring.",
    "kind": "def",
    "type": "{z // polynomial.eval x f - polynomial.eval y f = z * (x - y)}"
  },
  {
    "name": "no_max_order",
    "statement": "structure no_max_order (α : Type u_2) [has_lt α] : Prop",
    "theorem": "(α : Type u_2) [has_lt α] : Prop",
    "args": "(α : Type u_2) [has_lt α]",
    "doc_string": "Order without maximal elements. Sometimes called cofinal.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "seq1",
    "statement": "def seq1 (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "`seq1 α` is the type of nonempty sequences.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "closure_Ioo",
    "statement": "theorem closure_Ioo {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioo a b) = set.Icc a b",
    "theorem": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioo a b) = set.Icc a b",
    "args": "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b)",
    "doc_string": "The closure of the open interval `(a, b)` is the closed interval `[a, b]`.",
    "kind": "theorem",
    "type": "closure (set.Ioo a b) = set.Icc a b"
  },
  {
    "name": "t2_5_space",
    "statement": "structure t2_5_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": "A T₂.₅ space, also known as a Urysohn space, is a topological space  where for every pair `x ≠ y`, there are two open sets, with the intersection of closures  empty, one containing `x` and the other `y` .",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "list.is_rotated.setoid",
    "statement": "def list.is_rotated.setoid (α : Type u_1) : setoid (list α)",
    "theorem": "(α : Type u_1) : setoid (list α)",
    "args": "(α : Type u_1)",
    "doc_string": "The relation `list.is_rotated l l'` forms a `setoid` of cycles.",
    "kind": "def",
    "type": "setoid (list α)"
  },
  {
    "name": "group_topology.continuous_mul'",
    "statement": "theorem group_topology.continuous_mul' {α : Type u} [group α] (g : group_topology α) : continuous (λ (p : α × α), p.fst * p.snd)",
    "theorem": "{α : Type u} [group α] (g : group_topology α) : continuous (λ (p : α × α), p.fst * p.snd)",
    "args": "{α : Type u} [group α] (g : group_topology α)",
    "doc_string": "A version of the global `continuous_mul` suitable for dot notation.",
    "kind": "theorem",
    "type": "continuous (λ (p : α × α), p.fst * p.snd)"
  },
  {
    "name": "metric.bounded_union",
    "statement": "theorem metric.bounded_union {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t",
    "theorem": "{α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t",
    "args": "{α : Type u} [pseudo_metric_space α] {s t : set α}",
    "doc_string": "The union of two sets is bounded iff each of the sets is bounded.",
    "kind": "theorem",
    "type": "metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t"
  },
  {
    "name": "function.injective.unique",
    "statement": "def function.injective.unique {α : Sort u} {β : Sort v} {f : α → β} [inhabited α] [subsingleton β] (hf : function.injective f) : unique α",
    "theorem": "{α : Sort u} {β : Sort v} {f : α → β} [inhabited α] [subsingleton β] (hf : function.injective f) : unique α",
    "args": "{α : Sort u} {β : Sort v} {f : α → β} [inhabited α] [subsingleton β] (hf : function.injective f)",
    "doc_string": "If `α` is inhabited and admits an injective map to a subsingleton type, then `α` is `unique`.",
    "kind": "def",
    "type": "unique α"
  },
  {
    "name": "is_regular.and_of_mul_of_mul",
    "statement": "theorem is_regular.and_of_mul_of_mul {R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a ∧ is_regular b",
    "theorem": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a ∧ is_regular b",
    "args": "{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a))",
    "doc_string": "The \"most used\" implication of `mul_and_mul_iff`, with split hypotheses, instead of `∧`.",
    "kind": "theorem",
    "type": "is_regular a ∧ is_regular b"
  },
  {
    "name": "zero_lt.right.one_lt_mul_of_lt_of_lt",
    "statement": "theorem zero_lt.right.one_lt_mul_of_lt_of_lt {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "1 < a * b"
  },
  {
    "name": "lie_ring",
    "statement": "structure lie_ring (L : Type v) : Type v",
    "theorem": "(L : Type v) : Type v",
    "args": "(L : Type v)",
    "doc_string": " A Lie ring is an additive group with compatible product, known as the bracket, satisfying the Jacobi identity.",
    "kind": "structure",
    "type": "Type v"
  },
  {
    "name": "first_order.language.symbols",
    "statement": "def first_order.language.symbols (L : first_order.language) : Type (max u v)",
    "theorem": "(L : first_order.language) : Type (max u v)",
    "args": "(L : first_order.language)",
    "doc_string": "The type of symbols in a given language.",
    "kind": "def",
    "type": "Type (max u v)"
  },
  {
    "name": "sub_neg_of_lt",
    "statement": "theorem sub_neg_of_lt {α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < b → a - b < 0",
    "theorem": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < b → a - b < 0",
    "args": "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of sub_neg`.",
    "kind": "theorem",
    "type": "a < b → a - b < 0"
  },
  {
    "name": "cardinal.mk_quaternion",
    "statement": "theorem cardinal.mk_quaternion (R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4",
    "theorem": "(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4",
    "args": "(R : Type u_1) [has_one R] [has_neg R]",
    "doc_string": "The cardinality of the quaternions, as a type.",
    "kind": "theorem",
    "type": "cardinal.mk (quaternion R) = cardinal.mk R ^ 4"
  },
  {
    "name": "tactic.itauto.and_kind",
    "statement": "inductive tactic.itauto.and_kind  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " Different propositional constructors that are variants of \"and\" for the purposes of the theorem prover.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "rack",
    "statement": "structure rack (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A *rack* is an automorphic set (a set with an action on itself by bijections) that is self-distributive.  It is a shelf such that each element's action is invertible.  The notations `x ◃ y` and `x ◃⁻¹ y` denote the action and the inverse action, respectively, and they are right associative.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "pfun",
    "statement": "def pfun (α : Type u_1) (β : Type u_2) : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (β : Type u_2) : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (β : Type u_2)",
    "doc_string": "`pfun α β`, or `α →. β`, is the type of partial functions from  `α` to `β`. It is defined as `α → part β`.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "intermediate_field.neg_mem",
    "statement": "theorem intermediate_field.neg_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ∈ S → -x ∈ S",
    "theorem": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L} : x ∈ S → -x ∈ S",
    "args": "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x : L}",
    "doc_string": "An intermediate field is closed under negation.",
    "kind": "theorem",
    "type": "x ∈ S → -x ∈ S"
  },
  {
    "name": "ordnode.image",
    "statement": "def ordnode.image {α : Type u_1} {β : Type u_2} [has_le β] [decidable_rel has_le.le] (f : α → β) (t : ordnode α) : ordnode β",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_le β] [decidable_rel has_le.le] (f : α → β) (t : ordnode α) : ordnode β",
    "args": "{α : Type u_1} {β : Type u_2} [has_le β] [decidable_rel has_le.le] (f : α → β) (t : ordnode α)",
    "doc_string": " O(n * log n). Map a function on a set. Unlike `map` this has no requirements on `f`, and the resulting set may be smaller than the input if `f` is noninjective. Equivalent elements are selected with a preference for smaller source elements.      image (λ x, x + 2) {1, 2, 4} = {3, 4, 6}     image (λ x : ℕ, x - 2) {1, 2, 4} = {0, 2}",
    "kind": "def",
    "type": "ordnode β"
  },
  {
    "name": "mt",
    "statement": "theorem mt {a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a",
    "theorem": "{a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a",
    "args": "{a b : Prop} (h₁ : a → b) (h₂ : ¬b)",
    "doc_string": "Modus tollens. If an implication is true, then so is its contrapositive.",
    "kind": "theorem",
    "type": "¬a"
  },
  {
    "name": "has_exists_add_of_le",
    "statement": "structure has_exists_add_of_le (α : Type u) [has_add α] [has_le α] : Prop",
    "theorem": "(α : Type u) [has_add α] [has_le α] : Prop",
    "args": "(α : Type u) [has_add α] [has_le α]",
    "doc_string": " An `ordered_add_comm_monoid` with one-sided 'subtraction' in the sense that if `a ≤ b`, then there is some `c` for which `a + c = b`. This is a weaker version of the condition on canonical orderings defined by `canonically_ordered_add_monoid`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "turing.partrec_to_TM2.Γ'",
    "statement": "inductive turing.partrec_to_TM2.Γ'  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " The alphabet for the stacks in the program. `bit0` and `bit1` are used to represent `ℕ` values as lists of binary digits, `cons` is used to separate `list ℕ` values, and `Cons` is used to separate `list (list ℕ)` values. See the section documentation.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "AddCommGroup.category_theory.abelian",
    "statement": "def AddCommGroup.category_theory.abelian  : category_theory.abelian AddCommGroup",
    "theorem": " : category_theory.abelian AddCommGroup",
    "args": "",
    "doc_string": "The category of abelian groups is abelian.",
    "kind": "def",
    "type": "category_theory.abelian AddCommGroup"
  },
  {
    "name": "semiconj_by.one_right",
    "statement": "theorem semiconj_by.one_right {M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1",
    "theorem": "{M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1",
    "args": "{M : Type u} [mul_one_class M] (a : M)",
    "doc_string": "Any element semiconjugates `1` to `1`.",
    "kind": "theorem",
    "type": "semiconj_by a 1 1"
  },
  {
    "name": "lazy_list.map₂",
    "statement": "def lazy_list.map₂ {α : Type u} {β : Type v} {δ : Type w} (f : α → β → δ) : lazy_list α → lazy_list β → lazy_list δ",
    "theorem": "{α : Type u} {β : Type v} {δ : Type w} (f : α → β → δ) : lazy_list α → lazy_list β → lazy_list δ",
    "args": "{α : Type u} {β : Type v} {δ : Type w} (f : α → β → δ)",
    "doc_string": "Maps a binary function over two lazy list. Like `lazy_list.zip`, the result is only as long as the smaller input.",
    "kind": "def",
    "type": "lazy_list α → lazy_list β → lazy_list δ"
  },
  {
    "name": "parser.numeral.from_one",
    "statement": "def parser.numeral.from_one (α : Type) [has_zero α] [has_one α] [has_add α] : parser α",
    "theorem": "(α : Type) [has_zero α] [has_one α] [has_add α] : parser α",
    "args": "(α : Type) [has_zero α] [has_one α] [has_add α]",
    "doc_string": "Parse a string of digits as a numeral while casting it to target type `α`. The parsing starts at \"1\", so `\"1\"` is parsed in as `nat.cast 0`. Providing `\"0\"` to the parser causes a failure.",
    "kind": "def",
    "type": "parser α"
  },
  {
    "name": "subfield.one_mem",
    "statement": "theorem subfield.one_mem {K : Type u} [field K] (s : subfield K) : 1 ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) : 1 ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K)",
    "doc_string": "A subfield contains the field's 1.",
    "kind": "theorem",
    "type": "1 ∈ s"
  },
  {
    "name": "finset.add_comm_monoid",
    "statement": "def finset.add_comm_monoid {α : Type u_2} [decidable_eq α] [add_comm_monoid α] : add_comm_monoid (finset α)",
    "theorem": "{α : Type u_2} [decidable_eq α] [add_comm_monoid α] : add_comm_monoid (finset α)",
    "args": "{α : Type u_2} [decidable_eq α] [add_comm_monoid α]",
    "doc_string": "`finset α` is an `add_comm_monoid` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "add_comm_monoid (finset α)"
  },
  {
    "name": "Twop.of",
    "statement": "def Twop.of {X : Type u_1} (to_two_pointing : two_pointing X) : Twop",
    "theorem": "{X : Type u_1} (to_two_pointing : two_pointing X) : Twop",
    "args": "{X : Type u_1} (to_two_pointing : two_pointing X)",
    "doc_string": "Turns a two-pointing into a two-pointed type.",
    "kind": "def",
    "type": "Twop"
  },
  {
    "name": "irreducible_space",
    "statement": "structure irreducible_space (α : Type u) [topological_space α] : Prop",
    "theorem": "(α : Type u) [topological_space α] : Prop",
    "args": "(α : Type u) [topological_space α]",
    "doc_string": " An irreducible space is one that is nonempty and where there is no non-trivial pair of disjoint opens.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "initial_seg",
    "statement": "structure initial_seg {α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "theorem": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop) : Type (max u_4 u_5)",
    "args": "{α : Type u_4} {β : Type u_5} (r : α → α → Prop) (s : β → β → Prop)",
    "doc_string": " If `r` is a relation on `α` and `s` in a relation on `β`, then `f : r ≼i s` is an order embedding whose range is an initial segment. That is, whenever `b < f a` in `β` then `b` is in the range of `f`.",
    "kind": "structure",
    "type": "Type (max u_4 u_5)"
  },
  {
    "name": "category_theory.has_projective_resolution",
    "statement": "structure category_theory.has_projective_resolution {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Prop",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C) : Prop",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_object C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_equalizers C] [category_theory.limits.has_images C] (Z : C)",
    "doc_string": "An object admits a projective resolution.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "lucas_lehmer.lucas_lehmer_test",
    "statement": "def lucas_lehmer.lucas_lehmer_test (p : ℕ) : Prop",
    "theorem": "(p : ℕ) : Prop",
    "args": "(p : ℕ)",
    "doc_string": "A Mersenne number `2^p-1` is prime if and only if the Lucas-Lehmer residue `s p (p-2) % (2^p - 1)` is zero.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "group.normal_closure",
    "statement": "def group.normal_closure {G : Type u_1} [group G] (s : set G) : set G",
    "theorem": "{G : Type u_1} [group G] (s : set G) : set G",
    "args": "{G : Type u_1} [group G] (s : set G)",
    "doc_string": " The normal closure of a set s is the subgroup closure of all the conjugates of elements of s. It is the smallest normal subgroup containing s.",
    "kind": "def",
    "type": "set G"
  },
  {
    "name": "polynomial.leading_coeff",
    "statement": "def polynomial.leading_coeff {R : Type u} [semiring R] (p : polynomial R) : R",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : R",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": "`leading_coeff p` gives the coefficient of the highest power of `X` in `p`",
    "kind": "def",
    "type": "R"
  },
  {
    "name": "filter.is_cobounded_under",
    "statement": "def filter.is_cobounded_under {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (f : filter β) (u : β → α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : α → α → Prop) (f : filter β) (u : β → α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} (r : α → α → Prop) (f : filter β) (u : β → α)",
    "doc_string": " `is_cobounded_under (≺) f u` states that the image of the filter `f` under the map `u` does not tend to infinity w.r.t. `≺`. This is also called frequently bounded. Will be usually instantiated with `≤` or `≥`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "parser.numeral",
    "statement": "def parser.numeral (α : Type) [has_zero α] [has_one α] [has_add α] : parser α",
    "theorem": "(α : Type) [has_zero α] [has_one α] [has_add α] : parser α",
    "args": "(α : Type) [has_zero α] [has_one α] [has_add α]",
    "doc_string": "Parse a string of digits as a numeral while casting it to target type `α`.",
    "kind": "def",
    "type": "parser α"
  },
  {
    "name": "omega.ee",
    "statement": "inductive omega.ee  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of equality elimination rules.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "traversable.pure_transformation",
    "statement": "def traversable.pure_transformation (F : Type u → Type u) [applicative F] [is_lawful_applicative F] : applicative_transformation id F",
    "theorem": "(F : Type u → Type u) [applicative F] [is_lawful_applicative F] : applicative_transformation id F",
    "args": "(F : Type u → Type u) [applicative F] [is_lawful_applicative F]",
    "doc_string": " The natural applicative transformation from the identity functor to `F`, defined by `pure : Π {α}, α → F α`.",
    "kind": "def",
    "type": "applicative_transformation id F"
  },
  {
    "name": "equiv.perm.mod_swap",
    "statement": "def equiv.perm.mod_swap {α : Type u} [decidable_eq α] (i j : α) : setoid (equiv.perm α)",
    "theorem": "{α : Type u} [decidable_eq α] (i j : α) : setoid (equiv.perm α)",
    "args": "{α : Type u} [decidable_eq α] (i j : α)",
    "doc_string": "`mod_swap i j` contains permutations up to swapping `i` and `j`.  We use this to partition permutations in `matrix.det_zero_of_row_eq`, such that each partition sums up to `0`.",
    "kind": "def",
    "type": "setoid (equiv.perm α)"
  },
  {
    "name": "turing.partrec_to_TM2.cfg'",
    "statement": "def turing.partrec_to_TM2.cfg'  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "The type of TM2 configurations used by this machine.",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "lists'",
    "statement": "inductive lists' (α : Type u) : bool → Type u",
    "theorem": "(α : Type u) : bool → Type u",
    "args": "(α : Type u)",
    "doc_string": " Prelists, helper type to define `lists`. `lists' α ff` are the \"atoms\", a copy of `α`. `lists' α tt` are the \"proper\" ZFA prelists, inductively defined from the empty ZFA prelist and from appending a ZFA prelist to a proper ZFA prelist. It is made so that you can't append anything to an atom while having only one appending function for appending both atoms and proper ZFC prelists to a proper ZFA prelist.",
    "kind": "inductive",
    "type": "bool → Type u"
  },
  {
    "name": "mul_eq_zero",
    "statement": "theorem mul_eq_zero {M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ a = 0 ∨ b = 0",
    "theorem": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ a = 0 ∨ b = 0",
    "args": "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀}",
    "doc_string": " If `α` has no zero divisors, then the product of two elements equals zero iff one of them equals zero.",
    "kind": "theorem",
    "type": "a * b = 0 ↔ a = 0 ∨ b = 0"
  },
  {
    "name": "is_normal_subgroup",
    "statement": "structure is_normal_subgroup {G : Type u_1} [group G] (s : set G) : Prop",
    "theorem": "{G : Type u_1} [group G] (s : set G) : Prop",
    "args": "{G : Type u_1} [group G] (s : set G)",
    "doc_string": " `is_normal_subgroup (s : set G)` expresses the fact that `s` is a normal subgroup of the group `G`. Important: the preferred way to say this in Lean is via bundled subgroups `S : subgroup G` and not via this structure.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "composition",
    "statement": "structure composition (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": "A composition of `n` is a list of positive integers summing to `n`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "witt_vector.witt_poly_prod_remainder",
    "statement": "def witt_vector.witt_poly_prod_remainder (p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ) : mv_polynomial (fin 2 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)] (n : ℕ)",
    "doc_string": "The \"remainder term\" of `witt_vector.witt_poly_prod`. See `mul_poly_of_interest_aux2`.",
    "kind": "def",
    "type": "mv_polynomial (fin 2 × ℕ) ℤ"
  },
  {
    "name": "list.length_pos_of_sum_pos",
    "statement": "theorem list.length_pos_of_sum_pos {M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length",
    "theorem": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length",
    "args": "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum)",
    "doc_string": "A list with positive sum must have positive length.",
    "kind": "theorem",
    "type": "0 < L.length"
  },
  {
    "name": "lucas_lehmer.s_mod",
    "statement": "def lucas_lehmer.s_mod (p : ℕ) : ℕ → ℤ",
    "theorem": "(p : ℕ) : ℕ → ℤ",
    "args": "(p : ℕ)",
    "doc_string": "The recurrence `s (i+1) = ((s i)^2 - 2) % (2^p - 1)` in `ℤ`.",
    "kind": "def",
    "type": "ℕ → ℤ"
  },
  {
    "name": "is_solvable",
    "statement": "structure is_solvable (G : Type u_1) [group G] : Prop",
    "theorem": "(G : Type u_1) [group G] : Prop",
    "args": "(G : Type u_1) [group G]",
    "doc_string": "A group `G` is solvable if its derived series is eventually trivial. We use this definition  because it's the most convenient one to work with.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "complex_shape.up'",
    "statement": "def complex_shape.up' {α : Type u_1} [add_right_cancel_semigroup α] (a : α) : complex_shape α",
    "theorem": "{α : Type u_1} [add_right_cancel_semigroup α] (a : α) : complex_shape α",
    "args": "{α : Type u_1} [add_right_cancel_semigroup α] (a : α)",
    "doc_string": "The `complex_shape` allowing differentials from `X i` to `X (i+a)`. (For example when `a = 1`, a cohomology theory indexed by `ℕ` or `ℤ`)",
    "kind": "def",
    "type": "complex_shape α"
  },
  {
    "name": "right.mul_lt_one'",
    "statement": "theorem right.mul_lt_one' {α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "theorem": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1",
    "args": "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1)",
    "doc_string": " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one'`.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "lipschitz_on_with.holder_on_with",
    "statement": "theorem lipschitz_on_with.holder_on_with {X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y} {s : set X} : lipschitz_on_with C f s → holder_on_with C 1 f s",
    "theorem": "{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y} {s : set X} : lipschitz_on_with C f s → holder_on_with C 1 f s",
    "args": "{X : Type u_1} {Y : Type u_2} [pseudo_emetric_space X] [pseudo_emetric_space Y] {C : nnreal} {f : X → Y} {s : set X}",
    "doc_string": "**Alias** of the reverse direction of holder_on_with_one`.",
    "kind": "theorem",
    "type": "lipschitz_on_with C f s → holder_on_with C 1 f s"
  },
  {
    "name": "list.dedup",
    "statement": "def list.dedup {α : Type u_1} [decidable_eq α] : list α → list α",
    "theorem": "{α : Type u_1} [decidable_eq α] : list α → list α",
    "args": "{α : Type u_1} [decidable_eq α]",
    "doc_string": "`dedup l` removes duplicates from `l` (taking only the first occurrence).  Defined as `pw_filter (≠)`.      dedup [1, 0, 2, 2, 1] = [0, 2, 1]",
    "kind": "def",
    "type": "list α → list α"
  },
  {
    "name": "zero_lt.preorder.right.mul_le_one_of_le_of_le",
    "statement": "theorem zero_lt.preorder.right.mul_le_one_of_le_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "a * b ≤ 1"
  },
  {
    "name": "local_homeomorph.setoid",
    "statement": "def local_homeomorph.setoid {α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] : setoid (local_homeomorph α β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] : setoid (local_homeomorph α β)",
    "args": "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β]",
    "doc_string": "`eq_on_source` is an equivalence relation",
    "kind": "def",
    "type": "setoid (local_homeomorph α β)"
  },
  {
    "name": "ordinal.is_normal",
    "statement": "def ordinal.is_normal (f : ordinal → ordinal) : Prop",
    "theorem": "(f : ordinal → ordinal) : Prop",
    "args": "(f : ordinal → ordinal)",
    "doc_string": "A normal ordinal function is a strictly increasing function which is  order-continuous, i.e., the image `f o` of a limit ordinal `o` is the sup of `f a` for  `a < o`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "order.partial_iso",
    "statement": "def order.partial_iso (α : Type u_1) (β : Type u_2) [linear_order α] [linear_order β] : Type (max u_1 u_2)",
    "theorem": "(α : Type u_1) (β : Type u_2) [linear_order α] [linear_order β] : Type (max u_1 u_2)",
    "args": "(α : Type u_1) (β : Type u_2) [linear_order α] [linear_order β]",
    "doc_string": "The type of partial order isomorphisms between `α` and `β` defined on finite subsets.    A partial order isomorphism is encoded as a finite subset of `α × β`, consisting    of pairs which should be identified.",
    "kind": "def",
    "type": "Type (max u_1 u_2)"
  },
  {
    "name": "not_below",
    "statement": "def not_below {α : Type u_1} [omega_complete_partial_order α] (y : Scott α) : set (Scott α)",
    "theorem": "{α : Type u_1} [omega_complete_partial_order α] (y : Scott α) : set (Scott α)",
    "args": "{α : Type u_1} [omega_complete_partial_order α] (y : Scott α)",
    "doc_string": " `not_below` is an open set in `Scott α` used to prove the monotonicity of continuous functions",
    "kind": "def",
    "type": "set (Scott α)"
  },
  {
    "name": "name.pop_prefix",
    "statement": "def name.pop_prefix (n : name) : name",
    "theorem": "(n : name) : name",
    "args": "(n : name)",
    "doc_string": "Pop the prefix of a name",
    "kind": "def",
    "type": "name"
  },
  {
    "name": "non_unital_non_assoc_semiring.nat_smul_comm_class",
    "statement": "def non_unital_non_assoc_semiring.nat_smul_comm_class {R : Type u₁} [non_unital_non_assoc_semiring R] : smul_comm_class ℕ R R",
    "theorem": "{R : Type u₁} [non_unital_non_assoc_semiring R] : smul_comm_class ℕ R R",
    "args": "{R : Type u₁} [non_unital_non_assoc_semiring R]",
    "doc_string": "Note that `add_comm_monoid.nat_smul_comm_class` requires stronger assumptions on `R`.",
    "kind": "def",
    "type": "smul_comm_class ℕ R R"
  },
  {
    "name": "dvd_of_mul_right_eq",
    "statement": "theorem dvd_of_mul_right_eq {α : Type u_1} [semigroup α] {a b : α} (c : α) (h : a * c = b) : a ∣ b",
    "theorem": "{α : Type u_1} [semigroup α] {a b : α} (c : α) (h : a * c = b) : a ∣ b",
    "args": "{α : Type u_1} [semigroup α] {a b : α} (c : α) (h : a * c = b)",
    "doc_string": "**Alias** of dvd.intro`.",
    "kind": "theorem",
    "type": "a ∣ b"
  },
  {
    "name": "compact_of_is_closed_subset",
    "statement": "theorem compact_of_is_closed_subset {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t",
    "theorem": "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t",
    "args": "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s)",
    "doc_string": "A closed subset of a compact set is a compact set.",
    "kind": "theorem",
    "type": "is_compact t"
  },
  {
    "name": "alist.singleton",
    "statement": "def alist.singleton {α : Type u} {β : α → Type v} (a : α) (b : β a) : alist β",
    "theorem": "{α : Type u} {β : α → Type v} (a : α) (b : β a) : alist β",
    "args": "{α : Type u} {β : α → Type v} (a : α) (b : β a)",
    "doc_string": "The singleton association list.",
    "kind": "def",
    "type": "alist β"
  },
  {
    "name": "subsemiring.centralizer",
    "statement": "def subsemiring.centralizer {R : Type u_1} [semiring R] (s : set R) : subsemiring R",
    "theorem": "{R : Type u_1} [semiring R] (s : set R) : subsemiring R",
    "args": "{R : Type u_1} [semiring R] (s : set R)",
    "doc_string": "The centralizer of a set as subsemiring.",
    "kind": "def",
    "type": "subsemiring R"
  },
  {
    "name": "Set.is_func",
    "statement": "def Set.is_func (x y f : Set) : Prop",
    "theorem": "(x y f : Set) : Prop",
    "args": "(x y f : Set)",
    "doc_string": " `is_func x y f` is the assertion that `f` is a subset of `x × y` which relates to each element of `x` a unique element of `y`, so that we can consider `f`as a ZFC function `x → y`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "UniformSpace",
    "statement": "def UniformSpace  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "A (bundled) uniform space.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "FinPartialOrder",
    "statement": "structure FinPartialOrder  : Type (u_1+1)",
    "theorem": " : Type (u_1+1)",
    "args": "",
    "doc_string": "The category of finite partial orders with monotone functions.",
    "kind": "structure",
    "type": "Type (u_1+1)"
  },
  {
    "name": "multiset.cons",
    "statement": "def multiset.cons {α : Type u_1} (a : α) (s : multiset α) : multiset α",
    "theorem": "{α : Type u_1} (a : α) (s : multiset α) : multiset α",
    "args": "{α : Type u_1} (a : α) (s : multiset α)",
    "doc_string": "`cons a s` is the multiset which contains `s` plus one more  instance of `a`.",
    "kind": "def",
    "type": "multiset α"
  },
  {
    "name": "algebraic_closure.monic_irreducible",
    "statement": "def algebraic_closure.monic_irreducible (k : Type u) [field k] : Type u",
    "theorem": "(k : Type u) [field k] : Type u",
    "args": "(k : Type u) [field k]",
    "doc_string": "The subtype of monic irreducible polynomials",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "tactic.ext_state",
    "statement": "structure tactic.ext_state  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "Helper structure for `ext` and `ext1`. `lemmas` keeps track of extensionality lemmas  applied so far.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "composition.gather",
    "statement": "def composition.gather {n : ℕ} (a : composition n) (b : composition a.length) : composition n",
    "theorem": "{n : ℕ} (a : composition n) (b : composition a.length) : composition n",
    "args": "{n : ℕ} (a : composition n) (b : composition a.length)",
    "doc_string": " When `a` is a composition of `n` and `b` is a composition of `a.length`, `a.gather b` is the composition of `n` obtained by gathering all the blocks of `a` corresponding to a block of `b`. For instance, if `a = [6, 5, 3, 5, 2]` and `b = [2, 3]`, one should gather together the first two blocks of `a` and its last three blocks, giving `a.gather b = [11, 10]`.",
    "kind": "def",
    "type": "composition n"
  },
  {
    "name": "add_subsemigroup.centralizer",
    "statement": "def add_subsemigroup.centralizer {M : Type u_1} (S : set M) [add_semigroup M] : add_subsemigroup M",
    "theorem": "{M : Type u_1} (S : set M) [add_semigroup M] : add_subsemigroup M",
    "args": "{M : Type u_1} (S : set M) [add_semigroup M]",
    "doc_string": "The centralizer of a subset of an additive semigroup.",
    "kind": "def",
    "type": "add_subsemigroup M"
  },
  {
    "name": "invariant_basis_number_of_nontrivial_of_comm_ring",
    "statement": "def invariant_basis_number_of_nontrivial_of_comm_ring {R : Type u} [comm_ring R] [nontrivial R] : invariant_basis_number R",
    "theorem": "{R : Type u} [comm_ring R] [nontrivial R] : invariant_basis_number R",
    "args": "{R : Type u} [comm_ring R] [nontrivial R]",
    "doc_string": "Nontrivial commutative rings have the invariant basis number property.",
    "kind": "def",
    "type": "invariant_basis_number R"
  },
  {
    "name": "category_theory.over.construct_products.over_products_of_wide_pullbacks",
    "statement": "theorem category_theory.over.construct_products.over_products_of_wide_pullbacks {C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C}",
    "doc_string": "Given all wide pullbacks in `C`, construct products in `C/B`.",
    "kind": "theorem",
    "type": "category_theory.limits.has_products (category_theory.over B)"
  },
  {
    "name": "congr_lemma",
    "statement": "structure congr_lemma  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A congruence lemma is a proof that two terms are equal using a congruence proof generated by `mk_congr_lemma_simp` and friends. See the docstring for `mk_congr_lemma_simp` and `congr_arg_kind` for more information. The conclusion is prepended by a set of arguments. `arg_kinds` gives a suggestion of how that argument should be filled in using a simplifier.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "dlist.of_list",
    "statement": "def dlist.of_list {α : Type u} (l : list α) : dlist α",
    "theorem": "{α : Type u} (l : list α) : dlist α",
    "args": "{α : Type u} (l : list α)",
    "doc_string": "Convert a list to a dlist",
    "kind": "def",
    "type": "dlist α"
  },
  {
    "name": "zmod.cast",
    "statement": "def zmod.cast {R : Type u_1} [has_zero R] [has_one R] [has_add R] [has_neg R] {n : ℕ} : zmod n → R",
    "theorem": "{R : Type u_1} [has_zero R] [has_one R] [has_add R] [has_neg R] {n : ℕ} : zmod n → R",
    "args": "{R : Type u_1} [has_zero R] [has_one R] [has_add R] [has_neg R] {n : ℕ}",
    "doc_string": " Cast an integer modulo `n` to another semiring. This function is a morphism if the characteristic of `R` divides `n`. See `zmod.cast_hom` for a bundled version.",
    "kind": "def",
    "type": "zmod n → R"
  },
  {
    "name": "is_of_fin_add_order.add",
    "statement": "theorem is_of_fin_add_order.add {G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "theorem": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)",
    "args": "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y)",
    "doc_string": "Elements of finite additive order are closed under addition.",
    "kind": "theorem",
    "type": "is_of_fin_add_order (x + y)"
  },
  {
    "name": "matrix.to_bilin'_aux",
    "statement": "def matrix.to_bilin'_aux {R₂ : Type u_5} [comm_semiring R₂] {n : Type u_11} [fintype n] (M : matrix n n R₂) : bilin_form R₂ (n → R₂)",
    "theorem": "{R₂ : Type u_5} [comm_semiring R₂] {n : Type u_11} [fintype n] (M : matrix n n R₂) : bilin_form R₂ (n → R₂)",
    "args": "{R₂ : Type u_5} [comm_semiring R₂] {n : Type u_11} [fintype n] (M : matrix n n R₂)",
    "doc_string": " The map from `matrix n n R` to bilinear forms on `n → R`.  This is an auxiliary definition for the equivalence `matrix.to_bilin_form'`.",
    "kind": "def",
    "type": "bilin_form R₂ (n → R₂)"
  },
  {
    "name": "subtype.simps.coe",
    "statement": "def subtype.simps.coe {α : Sort u_1} {p : α → Prop} (x : subtype p) : α",
    "theorem": "{α : Sort u_1} {p : α → Prop} (x : subtype p) : α",
    "args": "{α : Sort u_1} {p : α → Prop} (x : subtype p)",
    "doc_string": "See Note [custom simps projection]",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "minpoly.not_is_unit",
    "statement": "theorem minpoly.not_is_unit (A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬is_unit (minpoly A x)",
    "theorem": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬is_unit (minpoly A x)",
    "args": "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B]",
    "doc_string": "A minimal polynomial is not a unit.",
    "kind": "theorem",
    "type": "¬is_unit (minpoly A x)"
  },
  {
    "name": "has_lt.lt.not_is_min",
    "statement": "theorem has_lt.lt.not_is_min {α : Type u_1} [preorder α] {a b : α} (h : b < a) : ¬is_min a",
    "theorem": "{α : Type u_1} [preorder α] {a b : α} (h : b < a) : ¬is_min a",
    "args": "{α : Type u_1} [preorder α] {a b : α} (h : b < a)",
    "doc_string": "**Alias** of not_is_min_of_lt`.",
    "kind": "theorem",
    "type": "¬is_min a"
  },
  {
    "name": "nat.bin_cast",
    "statement": "def nat.bin_cast {α : Type u_1} [has_zero α] [has_one α] [has_add α] (n : ℕ) : α",
    "theorem": "{α : Type u_1} [has_zero α] [has_one α] [has_add α] (n : ℕ) : α",
    "args": "{α : Type u_1} [has_zero α] [has_one α] [has_add α] (n : ℕ)",
    "doc_string": "Computationally friendlier cast than `nat.cast`, using binary representation.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "sub_nonneg_of_le",
    "statement": "theorem sub_nonneg_of_le {α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : b ≤ a → 0 ≤ a - b",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : b ≤ a → 0 ≤ a - b",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of sub_nonneg`.",
    "kind": "theorem",
    "type": "b ≤ a → 0 ≤ a - b"
  },
  {
    "name": "set.comm_semigroup",
    "statement": "def set.comm_semigroup {α : Type u_2} [comm_semigroup α] : comm_semigroup (set α)",
    "theorem": "{α : Type u_2} [comm_semigroup α] : comm_semigroup (set α)",
    "args": "{α : Type u_2} [comm_semigroup α]",
    "doc_string": "`set α` is a `comm_semigroup` under pointwise operations if `α` is.",
    "kind": "def",
    "type": "comm_semigroup (set α)"
  },
  {
    "name": "emetric_space.replace_uniformity",
    "statement": "def emetric_space.replace_uniformity {γ : Type u_1} [U : uniform_space γ] (m : emetric_space γ) (H : uniformity γ = uniformity γ) : emetric_space γ",
    "theorem": "{γ : Type u_1} [U : uniform_space γ] (m : emetric_space γ) (H : uniformity γ = uniformity γ) : emetric_space γ",
    "args": "{γ : Type u_1} [U : uniform_space γ] (m : emetric_space γ) (H : uniformity γ = uniformity γ)",
    "doc_string": " Auxiliary function to replace the uniformity on an emetric space with a uniformity which is equal to the original one, but maybe not defeq. This is useful if one wants to construct an emetric space with a specified uniformity. See Note [forgetful inheritance] explaining why having definitionally the right uniformity is often important.",
    "kind": "def",
    "type": "emetric_space γ"
  },
  {
    "name": "dlist",
    "statement": "structure dlist (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A difference list is a function that, given a list, returns the original contents of the difference list prepended to the given list.  This structure supports `O(1)` `append` and `concat` operations on lists, making it useful for append-heavy uses such as logging and pretty printing.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "monad_run",
    "statement": "structure monad_run (out : out_param (Type u → Type v)) (m : Type u → Type v) : Type (max (u+1) v)",
    "theorem": "(out : out_param (Type u → Type v)) (m : Type u → Type v) : Type (max (u+1) v)",
    "args": "(out : out_param (Type u → Type v)) (m : Type u → Type v)",
    "doc_string": "Run a monad stack to completion.    `run` should be the composition of the transformers' individual `run` functions.    This class mostly saves some typing when using highly nested monad stacks:    ```lean    @[reducible] def my_monad := reader_t my_cfg $ state_t my_state $ except_t my_err id    -- def my_monad.run {α : Type} (x : my_monad α) (cfg : my_cfg) (st : my_state) := ((x.run cfg).run st).run    def my_monad.run {α : Type} (x : my_monad α) := monad_run.run x    ```",
    "kind": "structure",
    "type": "Type (max (u+1) v)"
  },
  {
    "name": "category_theory.SheafOfTypes.hom",
    "statement": "structure category_theory.SheafOfTypes.hom {C : Type u₁} [category_theory.category C] {J : category_theory.grothendieck_topology C} (X Y : category_theory.SheafOfTypes J) : Type (max u_1 u₁)",
    "theorem": "{C : Type u₁} [category_theory.category C] {J : category_theory.grothendieck_topology C} (X Y : category_theory.SheafOfTypes J) : Type (max u_1 u₁)",
    "args": "{C : Type u₁} [category_theory.category C] {J : category_theory.grothendieck_topology C} (X Y : category_theory.SheafOfTypes J)",
    "doc_string": "Morphisms between sheaves of types are just morphisms between the underlying presheaves.",
    "kind": "structure",
    "type": "Type (max u_1 u₁)"
  },
  {
    "name": "prod.ωSup",
    "statement": "def prod.ωSup {α : Type u_1} {β : Type u_2} [omega_complete_partial_order α] [omega_complete_partial_order β] (c : omega_complete_partial_order.chain (α × β)) : α × β",
    "theorem": "{α : Type u_1} {β : Type u_2} [omega_complete_partial_order α] [omega_complete_partial_order β] (c : omega_complete_partial_order.chain (α × β)) : α × β",
    "args": "{α : Type u_1} {β : Type u_2} [omega_complete_partial_order α] [omega_complete_partial_order β] (c : omega_complete_partial_order.chain (α × β))",
    "doc_string": "The supremum of a chain in the product `ω`-CPO.",
    "kind": "def",
    "type": "α × β"
  },
  {
    "name": "multiset.Icc_eq_zero",
    "statement": "theorem multiset.Icc_eq_zero {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → multiset.Icc a b = 0",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → multiset.Icc a b = 0",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of multiset.Icc_eq_zero_iff`.",
    "kind": "theorem",
    "type": "¬a ≤ b → multiset.Icc a b = 0"
  },
  {
    "name": "list.tails",
    "statement": "def list.tails {α : Type u_1} : list α → list (list α)",
    "theorem": "{α : Type u_1} : list α → list (list α)",
    "args": "{α : Type u_1}",
    "doc_string": "`tails l` is the list of terminal segments of `l`.      tails [1, 2, 3] = [[1, 2, 3], [2, 3], [3], []]",
    "kind": "def",
    "type": "list α → list (list α)"
  },
  {
    "name": "ordinal.to_pgame",
    "statement": "def ordinal.to_pgame (o : ordinal) : pgame",
    "theorem": "(o : ordinal) : pgame",
    "args": "(o : ordinal)",
    "doc_string": "Converts an ordinal into the corresponding pre-game.",
    "kind": "def",
    "type": "pgame"
  },
  {
    "name": "Class.fval",
    "statement": "def Class.fval (F A : Class) : Class",
    "theorem": "(F A : Class) : Class",
    "args": "(F A : Class)",
    "doc_string": "Function value",
    "kind": "def",
    "type": "Class"
  },
  {
    "name": "measurable_singleton_class",
    "statement": "structure measurable_singleton_class (α : Type u_7) [measurable_space α] : Prop",
    "theorem": "(α : Type u_7) [measurable_space α] : Prop",
    "args": "(α : Type u_7) [measurable_space α]",
    "doc_string": "A typeclass mixin for `measurable_space`s such that each singleton is measurable.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "add_monoid_algebra.grade",
    "statement": "def add_monoid_algebra.grade {M : Type u_1} (R : Type u_3) [decidable_eq M] [comm_semiring R] (m : M) : submodule R (add_monoid_algebra R M)",
    "theorem": "{M : Type u_1} (R : Type u_3) [decidable_eq M] [comm_semiring R] (m : M) : submodule R (add_monoid_algebra R M)",
    "args": "{M : Type u_1} (R : Type u_3) [decidable_eq M] [comm_semiring R] (m : M)",
    "doc_string": "The submodule corresponding to each grade.",
    "kind": "def",
    "type": "submodule R (add_monoid_algebra R M)"
  },
  {
    "name": "pnat.factor_multiset_of_prime",
    "statement": "theorem pnat.factor_multiset_of_prime (p : nat.primes) : ↑p.factor_multiset = prime_multiset.of_prime p",
    "theorem": "(p : nat.primes) : ↑p.factor_multiset = prime_multiset.of_prime p",
    "args": "(p : nat.primes)",
    "doc_string": "Factoring a prime gives the corresponding one-element multiset.",
    "kind": "theorem",
    "type": "↑p.factor_multiset = prime_multiset.of_prime p"
  },
  {
    "name": "sum3.in₂",
    "statement": "def sum3.in₂ {α : Type u} {β : Type v} {γ : Type u_1} (c : γ) : α ⊕ β ⊕ γ",
    "theorem": "{α : Type u} {β : Type v} {γ : Type u_1} (c : γ) : α ⊕ β ⊕ γ",
    "args": "{α : Type u} {β : Type v} {γ : Type u_1} (c : γ)",
    "doc_string": "The map from the third summand into a ternary sum.",
    "kind": "def",
    "type": "α ⊕ β ⊕ γ"
  },
  {
    "name": "widget.interactive_expression.sf",
    "statement": "inductive widget.interactive_expression.sf  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "eformat but without any of the formatting stuff like highlighting, groups etc.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "widget_override.interactive_expression.action",
    "statement": "inductive widget_override.interactive_expression.action (γ : Type) : Type",
    "theorem": "(γ : Type) : Type",
    "args": "(γ : Type)",
    "doc_string": "The actions accepted by an expression widget.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "wseq.think",
    "statement": "def wseq.think {α : Type u} : wseq α → wseq α",
    "theorem": "{α : Type u} : wseq α → wseq α",
    "args": "{α : Type u}",
    "doc_string": "Compute for one tick, without producing any elements",
    "kind": "def",
    "type": "wseq α → wseq α"
  },
  {
    "name": "power_basis.finite_dimensional",
    "statement": "theorem power_basis.finite_dimensional {S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S",
    "theorem": "{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S",
    "args": "{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S)",
    "doc_string": "Cannot be an instance because `power_basis` cannot be a class.",
    "kind": "theorem",
    "type": "finite_dimensional K S"
  },
  {
    "name": "ordinal.blsub₂",
    "statement": "def ordinal.blsub₂ (op : ordinal → ordinal → ordinal) (o : ordinal) : ordinal",
    "theorem": "(op : ordinal → ordinal → ordinal) (o : ordinal) : ordinal",
    "args": "(op : ordinal → ordinal → ordinal) (o : ordinal)",
    "doc_string": " The least strict upper bound of `op` applied to all pairs of ordinals less than `o`. This is essentially a two-argument version of `ordinal.blsub`.",
    "kind": "def",
    "type": "ordinal"
  },
  {
    "name": "add_lt_of_lt_sub_left",
    "statement": "theorem add_lt_of_lt_sub_left {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < c - a → a + b < c",
    "theorem": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < c - a → a + b < c",
    "args": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of lt_sub_iff_add_lt'`.",
    "kind": "theorem",
    "type": "b < c - a → a + b < c"
  },
  {
    "name": "partial_order_of_SO",
    "statement": "def partial_order_of_SO {α : Type u} (r : α → α → Prop) [is_strict_order α r] : partial_order α",
    "theorem": "{α : Type u} (r : α → α → Prop) [is_strict_order α r] : partial_order α",
    "args": "{α : Type u} (r : α → α → Prop) [is_strict_order α r]",
    "doc_string": " Construct a partial order from a `is_strict_order` relation.  See note [reducible non-instances].",
    "kind": "def",
    "type": "partial_order α"
  },
  {
    "name": "denumerable.option",
    "statement": "def denumerable.option {α : Type u_1} [denumerable α] : denumerable (option α)",
    "theorem": "{α : Type u_1} [denumerable α] : denumerable (option α)",
    "args": "{α : Type u_1} [denumerable α]",
    "doc_string": "If `α` is denumerable, then so is `option α`.",
    "kind": "def",
    "type": "denumerable (option α)"
  },
  {
    "name": "fin.has_well_founded",
    "statement": "def fin.has_well_founded {n : ℕ} : has_well_founded (fin n)",
    "theorem": "{n : ℕ} : has_well_founded (fin n)",
    "args": "{n : ℕ}",
    "doc_string": " Use the ordering on `fin n` for checking recursive definitions.  For example, the following definition is not accepted by the termination checker, unless we declare the `has_well_founded` instance: ```lean def factorial {n : ℕ} : fin n → ℕ | ⟨0, _⟩ := 1 | ⟨i + 1, hi⟩ := (i + 1) * factorial ⟨i, i.lt_succ_self.trans hi⟩ ```",
    "kind": "def",
    "type": "has_well_founded (fin n)"
  },
  {
    "name": "Group",
    "statement": "def Group  : Type (u+1)",
    "theorem": " : Type (u+1)",
    "args": "",
    "doc_string": "The category of groups and group morphisms.",
    "kind": "def",
    "type": "Type (u+1)"
  },
  {
    "name": "category_theory.limits.bicone",
    "statement": "structure category_theory.limits.bicone {J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) : Type (max u v)",
    "theorem": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C) : Type (max u v)",
    "args": "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (F : J → C)",
    "doc_string": "A `c : bicone F` is: * an object `c.X` and * morphisms `π j : X ⟶ F j` and `ι j : F j ⟶ X` for each `j`, * such that `ι j ≫ π j'` is the identity when `j = j'` and zero otherwise.",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "inv_lt",
    "statement": "theorem inv_lt {α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b ↔ b⁻¹ < a",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b ↔ b⁻¹ < a",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b)",
    "doc_string": " In a linear ordered field, for positive `a` and `b` we have `a⁻¹ < b ↔ b⁻¹ < a`. See also `inv_lt_of_inv_lt` for a one-sided implication with one fewer assumption.",
    "kind": "theorem",
    "type": "a⁻¹ < b ↔ b⁻¹ < a"
  },
  {
    "name": "monoid.closure",
    "statement": "def monoid.closure {M : Type u_1} [monoid M] (s : set M) : set M",
    "theorem": "{M : Type u_1} [monoid M] (s : set M) : set M",
    "args": "{M : Type u_1} [monoid M] (s : set M)",
    "doc_string": "The inductively defined submonoid generated by a subset of a monoid.",
    "kind": "def",
    "type": "set M"
  },
  {
    "name": "subgroup.normal_closure",
    "statement": "def subgroup.normal_closure {G : Type u_1} [group G] (s : set G) : subgroup G",
    "theorem": "{G : Type u_1} [group G] (s : set G) : subgroup G",
    "args": "{G : Type u_1} [group G] (s : set G)",
    "doc_string": " The normal closure of a set `s` is the subgroup closure of all the conjugates of elements of `s`. It is the smallest normal subgroup containing `s`.",
    "kind": "def",
    "type": "subgroup G"
  },
  {
    "name": "free_group.to_word",
    "statement": "def free_group.to_word {α : Type u} [decidable_eq α] : free_group α → list (α × bool)",
    "theorem": "{α : Type u} [decidable_eq α] : free_group α → list (α × bool)",
    "args": "{α : Type u} [decidable_eq α]",
    "doc_string": " The function that sends an element of the free group to its maximal reduction.",
    "kind": "def",
    "type": "free_group α → list (α × bool)"
  },
  {
    "name": "lie_algebra.of_associative_algebra",
    "statement": "def lie_algebra.of_associative_algebra {A : Type v} [ring A] {R : Type u} [comm_ring R] [algebra R A] : lie_algebra R A",
    "theorem": "{A : Type v} [ring A] {R : Type u} [comm_ring R] [algebra R A] : lie_algebra R A",
    "args": "{A : Type v} [ring A] {R : Type u} [comm_ring R] [algebra R A]",
    "doc_string": " An associative algebra gives rise to a Lie algebra by taking the bracket to be the ring commutator.",
    "kind": "def",
    "type": "lie_algebra R A"
  },
  {
    "name": "is_fraction_ring.inv",
    "statement": "def is_fraction_ring.inv (A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] (z : K) : K",
    "theorem": "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] (z : K) : K",
    "args": "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] (z : K)",
    "doc_string": "The inverse of an element in the field of fractions of an integral domain.",
    "kind": "def",
    "type": "K"
  },
  {
    "name": "is_simple_order",
    "statement": "structure is_simple_order (α : Type u_2) [has_le α] [bounded_order α] : Prop",
    "theorem": "(α : Type u_2) [has_le α] [bounded_order α] : Prop",
    "args": "(α : Type u_2) [has_le α] [bounded_order α]",
    "doc_string": "An order is simple iff it has exactly two elements, `⊥` and `⊤`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "matrix.sub_up",
    "statement": "def matrix.sub_up {α : Type v} {d u n : ℕ} (A : matrix (fin (u + d)) (fin n) α) : matrix (fin u) (fin n) α",
    "theorem": "{α : Type v} {d u n : ℕ} (A : matrix (fin (u + d)) (fin n) α) : matrix (fin u) (fin n) α",
    "args": "{α : Type v} {d u n : ℕ} (A : matrix (fin (u + d)) (fin n) α)",
    "doc_string": "The top `u × n` part of a `(u+d) × n` matrix.",
    "kind": "def",
    "type": "matrix (fin u) (fin n) α"
  },
  {
    "name": "canonically_linear_ordered_monoid",
    "statement": "structure canonically_linear_ordered_monoid (α : Type u_2) : Type u_2",
    "theorem": "(α : Type u_2) : Type u_2",
    "args": "(α : Type u_2)",
    "doc_string": "A canonically linear-ordered monoid is a canonically ordered monoid    whose ordering is a linear order.",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "not_is_left_regular_zero_iff",
    "statement": "theorem not_is_left_regular_zero_iff {R : Type u_1} [mul_zero_class R] : ¬is_left_regular 0 ↔ nontrivial R",
    "theorem": "{R : Type u_1} [mul_zero_class R] : ¬is_left_regular 0 ↔ nontrivial R",
    "args": "{R : Type u_1} [mul_zero_class R]",
    "doc_string": "In a non-trivial `mul_zero_class`, the `0` element is not left-regular.",
    "kind": "theorem",
    "type": "¬is_left_regular 0 ↔ nontrivial R"
  },
  {
    "name": "tactic.rewrite_search.rewrite",
    "statement": "structure tactic.rewrite_search.rewrite  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "`rewrite` represents a single step of rewriting, that proves `exp` using `proof`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "lagrange.interpolate",
    "statement": "def lagrange.interpolate {F : Type u} [decidable_eq F] [field F] (s : finset F) (f : F → F) : polynomial F",
    "theorem": "{F : Type u} [decidable_eq F] [field F] (s : finset F) (f : F → F) : polynomial F",
    "args": "{F : Type u} [decidable_eq F] [field F] (s : finset F) (f : F → F)",
    "doc_string": " Lagrange interpolation: given a finset `s` and a function `f : F → F`, `interpolate s f` is the unique polynomial of degree `< s.card` that takes value `f x` on all `x` in `s`.",
    "kind": "def",
    "type": "polynomial F"
  },
  {
    "name": "measure_theory.simple_func.bind",
    "statement": "def measure_theory.simple_func.bind {α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α β) (g : β → measure_theory.simple_func α γ) : measure_theory.simple_func α γ",
    "theorem": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α β) (g : β → measure_theory.simple_func α γ) : measure_theory.simple_func α γ",
    "args": "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [measurable_space α] (f : measure_theory.simple_func α β) (g : β → measure_theory.simple_func α γ)",
    "doc_string": " If `f : α →ₛ β` is a simple function and `g : β → α →ₛ γ` is a family of simple functions, then `f.bind g` binds the first argument of `g` to `f`. In other words, `f.bind g a = g (f a) a`.",
    "kind": "def",
    "type": "measure_theory.simple_func α γ"
  },
  {
    "name": "topological_fiber_bundle_core",
    "statement": "structure topological_fiber_bundle_core (ι : Type u_4) (B : Type u_5) [topological_space B] (F : Type u_6) [topological_space F] : Type (max u_4 u_5 u_6)",
    "theorem": "(ι : Type u_4) (B : Type u_5) [topological_space B] (F : Type u_6) [topological_space F] : Type (max u_4 u_5 u_6)",
    "args": "(ι : Type u_4) (B : Type u_5) [topological_space B] (F : Type u_6) [topological_space F]",
    "doc_string": " Core data defining a locally trivial topological bundle with fiber `F` over a topological space `B`. Note that \"bundle\" is used in its mathematical sense. This is the (computer science) bundled version, i.e., all the relevant data is contained in the following structure. A family of local trivializations is indexed by a type `ι`, on open subsets `base_set i` for each `i : ι`. Trivialization changes from `i` to `j` are given by continuous maps `coord_change i j` from `base_set i ∩ base_set j` to the set of homeomorphisms of `F`, but we express them as maps `B → F → F` and require continuity on `(base_set i ∩ base_set j) × F` to avoid the topology on the space of continuous maps on `F`.",
    "kind": "structure",
    "type": "Type (max u_4 u_5 u_6)"
  },
  {
    "name": "equiv.mul_left",
    "statement": "def equiv.mul_left {G : Type u_10} [group G] (a : G) : equiv.perm G",
    "theorem": "{G : Type u_10} [group G] (a : G) : equiv.perm G",
    "args": "{G : Type u_10} [group G] (a : G)",
    "doc_string": "Left multiplication in a `group` is a permutation of the underlying type.",
    "kind": "def",
    "type": "equiv.perm G"
  },
  {
    "name": "ordinal.has_mod",
    "statement": "def ordinal.has_mod  : has_mod ordinal",
    "theorem": " : has_mod ordinal",
    "args": "",
    "doc_string": "`a % b` is the unique ordinal `o'` satisfying  `a = b * o + o'` with `o' < b`.",
    "kind": "def",
    "type": "has_mod ordinal"
  },
  {
    "name": "submonoid.to_subsemigroup",
    "statement": "def submonoid.to_subsemigroup {M : Type u_4} [mul_one_class M] (self : submonoid M) : subsemigroup M",
    "theorem": "{M : Type u_4} [mul_one_class M] (self : submonoid M) : subsemigroup M",
    "args": "{M : Type u_4} [mul_one_class M] (self : submonoid M)",
    "doc_string": "A submonoid of a monoid `M` can be considered as a subsemigroup of that monoid.",
    "kind": "def",
    "type": "subsemigroup M"
  },
  {
    "name": "dite_not",
    "statement": "theorem dite_not {α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x",
    "theorem": "{α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x",
    "args": "{α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α)",
    "doc_string": "Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches.",
    "kind": "theorem",
    "type": "dite (¬P) x y = dite P (λ (h : P), y _) x"
  },
  {
    "name": "prod.normed_ring",
    "statement": "def prod.normed_ring {α : Type u_1} {β : Type u_2} [normed_ring α] [normed_ring β] : normed_ring (α × β)",
    "theorem": "{α : Type u_1} {β : Type u_2} [normed_ring α] [normed_ring β] : normed_ring (α × β)",
    "args": "{α : Type u_1} {β : Type u_2} [normed_ring α] [normed_ring β]",
    "doc_string": "Normed ring structure on the product of two normed rings, using the sup norm.",
    "kind": "def",
    "type": "normed_ring (α × β)"
  },
  {
    "name": "lattice_ordered_comm_group.has_one_lattice_has_neg_part",
    "statement": "def lattice_ordered_comm_group.has_one_lattice_has_neg_part {α : Type u} [lattice α] [comm_group α] : has_neg_part α",
    "theorem": "{α : Type u} [lattice α] [comm_group α] : has_neg_part α",
    "args": "{α : Type u} [lattice α] [comm_group α]",
    "doc_string": "Let `α` be a lattice ordered commutative group with identity `1`. For an element `a` of type `α`, the element `(-a) ⊔ 1` is said to be the *negative component* of `a`, denoted `a⁻`.",
    "kind": "def",
    "type": "has_neg_part α"
  },
  {
    "name": "discrete_quotient.le_comap",
    "statement": "def discrete_quotient.le_comap {X : Type u_1} [topological_space X] {Y : Type u_2} [topological_space Y] {f : Y → X} (cont : continuous f) (A : discrete_quotient Y) (B : discrete_quotient X) : Prop",
    "theorem": "{X : Type u_1} [topological_space X] {Y : Type u_2} [topological_space Y] {f : Y → X} (cont : continuous f) (A : discrete_quotient Y) (B : discrete_quotient X) : Prop",
    "args": "{X : Type u_1} [topological_space X] {Y : Type u_2} [topological_space Y] {f : Y → X} (cont : continuous f) (A : discrete_quotient Y) (B : discrete_quotient X)",
    "doc_string": "Given `cont : continuous f`, `le_comap cont A B` is defined as `A ≤ B.comap f`. Mathematically this means that `f` descends to a morphism `A → B`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "polynomial.algebra_pi",
    "statement": "def polynomial.algebra_pi (R' : Type u) (S' : Type v) (T' : Type w) [comm_semiring R'] [comm_semiring S'] [comm_semiring T'] [algebra R' S'] [algebra S' T'] : algebra (polynomial R') (S' → T')",
    "theorem": "(R' : Type u) (S' : Type v) (T' : Type w) [comm_semiring R'] [comm_semiring S'] [comm_semiring T'] [algebra R' S'] [algebra S' T'] : algebra (polynomial R') (S' → T')",
    "args": "(R' : Type u) (S' : Type v) (T' : Type w) [comm_semiring R'] [comm_semiring S'] [comm_semiring T'] [algebra R' S'] [algebra S' T']",
    "doc_string": "This is not an instance for the same reasons as `polynomial.has_scalar_pi'`.",
    "kind": "def",
    "type": "algebra (polynomial R') (S' → T')"
  },
  {
    "name": "category_theory.grothendieck_topology.has_le",
    "statement": "def category_theory.grothendieck_topology.has_le {C : Type u} [category_theory.category C] : has_le (category_theory.grothendieck_topology C)",
    "theorem": "{C : Type u} [category_theory.category C] : has_le (category_theory.grothendieck_topology C)",
    "args": "{C : Type u} [category_theory.category C]",
    "doc_string": "See <https://stacks.math.columbia.edu/tag/00Z6>",
    "kind": "def",
    "type": "has_le (category_theory.grothendieck_topology C)"
  },
  {
    "name": "category_theory.limits.has_strong_epi_mono_factorisations",
    "statement": "structure category_theory.limits.has_strong_epi_mono_factorisations (C : Type u) [category_theory.category C] : Prop",
    "theorem": "(C : Type u) [category_theory.category C] : Prop",
    "args": "(C : Type u) [category_theory.category C]",
    "doc_string": "A category has strong epi-mono factorisations if every morphism admits a strong epi-mono    factorisation.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "tactic.proof_state",
    "statement": "def tactic.proof_state  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " proof state made of multiple `goal` meant for comparing the result of running different tactics",
    "kind": "def",
    "type": "Type"
  },
  {
    "name": "conditionally_complete_linear_order_bot",
    "statement": "structure conditionally_complete_linear_order_bot (α : Type u_4) : Type u_4",
    "theorem": "(α : Type u_4) : Type u_4",
    "args": "(α : Type u_4)",
    "doc_string": " A conditionally complete linear order with `bot` is a linear order with least element, in which every nonempty subset which is bounded above has a supremum, and every nonempty subset (necessarily bounded below) has an infimum.  A typical example is the natural numbers.  To differentiate the statements from the corresponding statements in (unconditional) complete linear orders, we prefix Inf and Sup by a c everywhere. The same statements should hold in both worlds, sometimes with additional assumptions of nonemptiness or boundedness.",
    "kind": "structure",
    "type": "Type u_4"
  },
  {
    "name": "tactic.ring2.horner_expr",
    "statement": "inductive tactic.ring2.horner_expr  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": " An efficient representation of expressions in a commutative semiring using the sparse Horner normal form. This type admits non-optimal instantiations (e.g. `P` can be represented as `P+0+0`), so to get good performance out of it, care must be taken to maintain an optimal, *canonical* form.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "order.ideal",
    "statement": "structure order.ideal (P : Type u_2) [has_le P] : Type u_2",
    "theorem": "(P : Type u_2) [has_le P] : Type u_2",
    "args": "(P : Type u_2) [has_le P]",
    "doc_string": "An ideal on an order `P` is a subset of `P` that is  - nonempty  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)  - downward closed (any element less than an element of the ideal is in the ideal).",
    "kind": "structure",
    "type": "Type u_2"
  },
  {
    "name": "witt_vector.verschiebung_poly",
    "statement": "def witt_vector.verschiebung_poly (n : ℕ) : mv_polynomial ℕ ℤ",
    "theorem": "(n : ℕ) : mv_polynomial ℕ ℤ",
    "args": "(n : ℕ)",
    "doc_string": "The 0th Verschiebung polynomial is 0. For `n > 0`, the `n`th Verschiebung polynomial is the variable `X (n-1)`.",
    "kind": "def",
    "type": "mv_polynomial ℕ ℤ"
  },
  {
    "name": "list.to_array",
    "statement": "def list.to_array {α : Type u_1} (l : list α) : array l.length α",
    "theorem": "{α : Type u_1} (l : list α) : array l.length α",
    "args": "{α : Type u_1} (l : list α)",
    "doc_string": "Convert a list into an array (whose length is the length of `l`).",
    "kind": "def",
    "type": "array l.length α"
  },
  {
    "name": "lie_ideal",
    "statement": "def lie_ideal (R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v",
    "theorem": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] : Type v",
    "args": "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L]",
    "doc_string": "An ideal of a Lie algebra is a Lie submodule of the Lie algebra as a Lie module over itself.",
    "kind": "def",
    "type": "Type v"
  },
  {
    "name": "mul_salem_spencer.decidable",
    "statement": "def mul_salem_spencer.decidable {α : Type u_1} [decidable_eq α] [monoid α] {s : finset α} : decidable (mul_salem_spencer ↑s)",
    "theorem": "{α : Type u_1} [decidable_eq α] [monoid α] {s : finset α} : decidable (mul_salem_spencer ↑s)",
    "args": "{α : Type u_1} [decidable_eq α] [monoid α] {s : finset α}",
    "doc_string": "Whether a given finset is Salem-Spencer is decidable.",
    "kind": "def",
    "type": "decidable (mul_salem_spencer ↑s)"
  },
  {
    "name": "mul_mem_class",
    "statement": "structure mul_mem_class (S : Type u_4) (M : out_param (Type u_5)) [has_mul M] [set_like S M] : Type",
    "theorem": "(S : Type u_4) (M : out_param (Type u_5)) [has_mul M] [set_like S M] : Type",
    "args": "(S : Type u_4) (M : out_param (Type u_5)) [has_mul M] [set_like S M]",
    "doc_string": "`mul_mem_class S M` says `S` is a type of subsets `s ≤ M` that are closed under `(*)`",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "witt_vector.witt_neg",
    "statement": "def witt_vector.witt_neg (p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 1 × ℕ) ℤ",
    "theorem": "(p : ℕ) [hp : fact (nat.prime p)] : ℕ → mv_polynomial (fin 1 × ℕ) ℤ",
    "args": "(p : ℕ) [hp : fact (nat.prime p)]",
    "doc_string": "The polynomials used for defining the negation of the ring of Witt vectors.",
    "kind": "def",
    "type": "ℕ → mv_polynomial (fin 1 × ℕ) ℤ"
  },
  {
    "name": "well_founded.is_sup_closed_compact",
    "statement": "theorem well_founded.is_sup_closed_compact (α : Type u_1) [complete_lattice α] : well_founded gt → complete_lattice.is_sup_closed_compact α",
    "theorem": "(α : Type u_1) [complete_lattice α] : well_founded gt → complete_lattice.is_sup_closed_compact α",
    "args": "(α : Type u_1) [complete_lattice α]",
    "doc_string": "**Alias** of the reverse direction of complete_lattice.is_sup_closed_compact_iff_well_founded`.",
    "kind": "theorem",
    "type": "well_founded gt → complete_lattice.is_sup_closed_compact α"
  },
  {
    "name": "commensurable",
    "statement": "def commensurable {G : Type u_1} [group G] (H K : subgroup G) : Prop",
    "theorem": "{G : Type u_1} [group G] (H K : subgroup G) : Prop",
    "args": "{G : Type u_1} [group G] (H K : subgroup G)",
    "doc_string": "Two subgroups `H K` of `G` are commensurable if `H ⊓ K` has finite index in both `H` and `K`",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finite_dimensional.nontrivial_of_finrank_pos",
    "statement": "theorem finite_dimensional.nontrivial_of_finrank_pos {K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V",
    "theorem": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V",
    "args": "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V)",
    "doc_string": "A finite dimensional space is nontrivial if it has positive `finrank`.",
    "kind": "theorem",
    "type": "nontrivial V"
  },
  {
    "name": "NonemptyFinLinOrd.of",
    "statement": "def NonemptyFinLinOrd.of (α : Type u_1) [nonempty_fin_lin_ord α] : NonemptyFinLinOrd",
    "theorem": "(α : Type u_1) [nonempty_fin_lin_ord α] : NonemptyFinLinOrd",
    "args": "(α : Type u_1) [nonempty_fin_lin_ord α]",
    "doc_string": "Construct a bundled `NonemptyFinLinOrd` from the underlying type and typeclass.",
    "kind": "def",
    "type": "NonemptyFinLinOrd"
  },
  {
    "name": "is_localization.inv_submonoid",
    "statement": "def is_localization.inv_submonoid {R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] : submonoid S",
    "theorem": "{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S] : submonoid S",
    "args": "{R : Type u_1} [comm_ring R] (M : submonoid R) (S : Type u_2) [comm_ring S] [algebra R S]",
    "doc_string": "The submonoid of `S = M⁻¹R` consisting of `{ 1 / x | x ∈ M }`.",
    "kind": "def",
    "type": "submonoid S"
  },
  {
    "name": "polynomial.nat_trailing_degree",
    "statement": "def polynomial.nat_trailing_degree {R : Type u} [semiring R] (p : polynomial R) : ℕ",
    "theorem": "{R : Type u} [semiring R] (p : polynomial R) : ℕ",
    "args": "{R : Type u} [semiring R] (p : polynomial R)",
    "doc_string": " `nat_trailing_degree p` forces `trailing_degree p` to `ℕ`, by defining `nat_trailing_degree ⊤ = 0`.",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "seq",
    "statement": "def seq (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "`seq α` is the type of possibly infinite lists (referred here as sequences).  It is encoded as an infinite stream of options such that if `f n = none`, then  `f m = none` for all `m ≥ n`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "ite_not",
    "statement": "theorem ite_not {α : Sort u_1} (P : Prop) [decidable P] (a b : α) : ite (¬P) a b = ite P b a",
    "theorem": "{α : Sort u_1} (P : Prop) [decidable P] (a b : α) : ite (¬P) a b = ite P b a",
    "args": "{α : Sort u_1} (P : Prop) [decidable P] (a b : α)",
    "doc_string": "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches.",
    "kind": "theorem",
    "type": "ite (¬P) a b = ite P b a"
  },
  {
    "name": "category_theory.sieve.sieve_inhabited",
    "statement": "def category_theory.sieve.sieve_inhabited {C : Type u₁} [category_theory.category C] {X : C} : inhabited (category_theory.sieve X)",
    "theorem": "{C : Type u₁} [category_theory.category C] {X : C} : inhabited (category_theory.sieve X)",
    "args": "{C : Type u₁} [category_theory.category C] {X : C}",
    "doc_string": "The maximal sieve always exists.",
    "kind": "def",
    "type": "inhabited (category_theory.sieve X)"
  },
  {
    "name": "is_chain.symm",
    "statement": "theorem is_chain.symm {α : Type u_1} {r : α → α → Prop} {s : set α} (h : is_chain r s) : is_chain (flip r) s",
    "theorem": "{α : Type u_1} {r : α → α → Prop} {s : set α} (h : is_chain r s) : is_chain (flip r) s",
    "args": "{α : Type u_1} {r : α → α → Prop} {s : set α} (h : is_chain r s)",
    "doc_string": "This can be used to turn `is_chain (≥)` into `is_chain (≤)` and vice-versa.",
    "kind": "theorem",
    "type": "is_chain (flip r) s"
  },
  {
    "name": "lawful_fix",
    "statement": "structure lawful_fix (α : Type u_3) [omega_complete_partial_order α] : Type u_3",
    "theorem": "(α : Type u_3) [omega_complete_partial_order α] : Type u_3",
    "args": "(α : Type u_3) [omega_complete_partial_order α]",
    "doc_string": " Intuitively, a fixed point operator `fix` is lawful if it satisfies `fix f = f (fix f)` for all `f`, but this is inconsistent / uninteresting in most cases due to the existence of \"exotic\" functions `f`, such as the function that is defined iff its argument is not, familiar from the halting problem. Instead, this requirement is limited to only functions that are `continuous` in the sense of `ω`-complete partial orders, which excludes the example because it is not monotone (making the input argument less defined can make `f` more defined).",
    "kind": "structure",
    "type": "Type u_3"
  },
  {
    "name": "discrete_quotient.of_clopen",
    "statement": "def discrete_quotient.of_clopen {X : Type u_1} [topological_space X] {A : set X} (h : is_clopen A) : discrete_quotient X",
    "theorem": "{X : Type u_1} [topological_space X] {A : set X} (h : is_clopen A) : discrete_quotient X",
    "args": "{X : Type u_1} [topological_space X] {A : set X} (h : is_clopen A)",
    "doc_string": "Construct a discrete quotient from a clopen set.",
    "kind": "def",
    "type": "discrete_quotient X"
  },
  {
    "name": "basis.empty",
    "statement": "def basis.empty {ι : Type u_1} {R : Type u_3} (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [subsingleton M] [is_empty ι] : basis ι R M",
    "theorem": "{ι : Type u_1} {R : Type u_3} (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [subsingleton M] [is_empty ι] : basis ι R M",
    "args": "{ι : Type u_1} {R : Type u_3} (M : Type u_5) [semiring R] [add_comm_monoid M] [module R M] [subsingleton M] [is_empty ι]",
    "doc_string": "If `M` is a subsingleton and `ι` is empty, this is the unique `ι`-indexed basis for `M`.",
    "kind": "def",
    "type": "basis ι R M"
  },
  {
    "name": "archimedean.floor_ring",
    "statement": "def archimedean.floor_ring (α : Type u_1) [linear_ordered_ring α] [archimedean α] : floor_ring α",
    "theorem": "(α : Type u_1) [linear_ordered_ring α] [archimedean α] : floor_ring α",
    "args": "(α : Type u_1) [linear_ordered_ring α] [archimedean α]",
    "doc_string": " A linear ordered archimedean ring is a floor ring. This is not an `instance` because in some cases we have a computable `floor` function.",
    "kind": "def",
    "type": "floor_ring α"
  },
  {
    "name": "subgroup_class",
    "statement": "structure subgroup_class (S : Type u_3) (G : Type u_4) [div_inv_monoid G] [set_like S G] : Type",
    "theorem": "(S : Type u_3) (G : Type u_4) [div_inv_monoid G] [set_like S G] : Type",
    "args": "(S : Type u_3) (G : Type u_4) [div_inv_monoid G] [set_like S G]",
    "doc_string": "`subgroup_class S G` states `S` is a type of subsets `s ⊆ G` that are subgroups of `G`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "subtype.coind",
    "statement": "def subtype.coind {α : Sort u_1} {β : Sort u_2} (f : α → β) {p : β → Prop} (h : ∀ (a : α), p (f a)) : α → subtype p",
    "theorem": "{α : Sort u_1} {β : Sort u_2} (f : α → β) {p : β → Prop} (h : ∀ (a : α), p (f a)) : α → subtype p",
    "args": "{α : Sort u_1} {β : Sort u_2} (f : α → β) {p : β → Prop} (h : ∀ (a : α), p (f a))",
    "doc_string": "Defining a map into a subtype, this can be seen as an \"coinduction principle\" of `subtype`",
    "kind": "def",
    "type": "α → subtype p"
  },
  {
    "name": "normed_algebra.to_normed_space'",
    "statement": "def normed_algebra.to_normed_space' {𝕜 : Type u_5} [normed_field 𝕜] {𝕜' : Type u_1} [normed_ring 𝕜'] [normed_algebra 𝕜 𝕜'] : normed_space 𝕜 𝕜'",
    "theorem": "{𝕜 : Type u_5} [normed_field 𝕜] {𝕜' : Type u_1} [normed_ring 𝕜'] [normed_algebra 𝕜 𝕜'] : normed_space 𝕜 𝕜'",
    "args": "{𝕜 : Type u_5} [normed_field 𝕜] {𝕜' : Type u_1} [normed_ring 𝕜'] [normed_algebra 𝕜 𝕜']",
    "doc_string": " While this may appear identical to `normed_algebra.to_normed_space`, it contains an implicit argument involving `normed_ring.to_semi_normed_ring` that typeclass inference has trouble inferring.  Specifically, the following instance cannot be found without this `normed_space.to_module'`: ```lean example   (𝕜 ι : Type*) (E : ι → Type*)   [normed_field 𝕜] [Π i, normed_ring (E i)] [Π i, normed_algebra 𝕜 (E i)] :   Π i, module 𝕜 (E i) := by apply_instance ```  See `normed_space.to_module'` for a similar situation.",
    "kind": "def",
    "type": "normed_space 𝕜 𝕜'"
  },
  {
    "name": "affine_subspace.coe_injective",
    "statement": "theorem affine_subspace.coe_injective {k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe",
    "theorem": "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe",
    "args": "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P]",
    "doc_string": "Two affine subspaces are equal if they have the same points.",
    "kind": "theorem",
    "type": "function.injective coe"
  },
  {
    "name": "lt_mul_of_inv_mul_lt",
    "statement": "theorem lt_mul_of_inv_mul_lt {α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c",
    "theorem": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c",
    "args": "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the forward direction of inv_mul_lt_iff_lt_mul`.",
    "kind": "theorem",
    "type": "b⁻¹ * a < c → a < b * c"
  },
  {
    "name": "non_unital_non_assoc_semiring",
    "statement": "structure non_unital_non_assoc_semiring (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A not-necessarily-unital, not-necessarily-associative semiring.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "esakia_hom",
    "statement": "structure esakia_hom (α : Type u_6) (β : Type u_7) [topological_space α] [preorder α] [topological_space β] [preorder β] : Type (max u_6 u_7)",
    "theorem": "(α : Type u_6) (β : Type u_7) [topological_space α] [preorder α] [topological_space β] [preorder β] : Type (max u_6 u_7)",
    "args": "(α : Type u_6) (β : Type u_7) [topological_space α] [preorder α] [topological_space β] [preorder β]",
    "doc_string": "The type of Esakia morphisms, aka continuous pseudo-epimorphisms, from `α` to `β`.",
    "kind": "structure",
    "type": "Type (max u_6 u_7)"
  },
  {
    "name": "subfield.multiset_sum_mem",
    "statement": "theorem subfield.multiset_sum_mem {K : Type u} [field K] (s : subfield K) (m : multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.sum ∈ s",
    "theorem": "{K : Type u} [field K] (s : subfield K) (m : multiset K) : (∀ (a : K), a ∈ m → a ∈ s) → m.sum ∈ s",
    "args": "{K : Type u} [field K] (s : subfield K) (m : multiset K)",
    "doc_string": "Sum of a multiset of elements in a `subfield` is in the `subfield`.",
    "kind": "theorem",
    "type": "(∀ (a : K), a ∈ m → a ∈ s) → m.sum ∈ s"
  },
  {
    "name": "adjoin_root",
    "statement": "def adjoin_root {R : Type u} [comm_ring R] (f : polynomial R) : Type u",
    "theorem": "{R : Type u} [comm_ring R] (f : polynomial R) : Type u",
    "args": "{R : Type u} [comm_ring R] (f : polynomial R)",
    "doc_string": " Adjoin a root of a polynomial `f` to a commutative ring `R`. We define the new ring as the quotient of `polynomial R` by the principal ideal generated by `f`.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "filter.as_basis",
    "statement": "def filter.as_basis {α : Type u_1} (f : filter α) : filter_basis α",
    "theorem": "{α : Type u_1} (f : filter α) : filter_basis α",
    "args": "{α : Type u_1} (f : filter α)",
    "doc_string": "View a filter as a filter basis.",
    "kind": "def",
    "type": "filter_basis α"
  },
  {
    "name": "preorder.topology",
    "statement": "def preorder.topology (α : Type u_1) [preorder α] : topological_space α",
    "theorem": "(α : Type u_1) [preorder α] : topological_space α",
    "args": "(α : Type u_1) [preorder α]",
    "doc_string": " (Order) topology on a partial order `α` generated by the subbase of open intervals `(a, ∞) = { x ∣ a < x }, (-∞ , b) = {x ∣ x < b}` for all `a, b` in `α`. We do not register it as an instance as many ordered sets are already endowed with the same topology, most often in a non-defeq way though. Register as a local instance when necessary.",
    "kind": "def",
    "type": "topological_space α"
  },
  {
    "name": "num.prime",
    "statement": "def num.prime (n : num) : Prop",
    "theorem": "(n : num) : Prop",
    "args": "(n : num)",
    "doc_string": "Primality predicate for a `num`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "Set.mk",
    "statement": "def Set.mk  : pSet → Set",
    "theorem": " : pSet → Set",
    "args": "",
    "doc_string": "Turns a pre-set into a ZFC set.",
    "kind": "def",
    "type": "pSet → Set"
  },
  {
    "name": "tree",
    "statement": "inductive tree (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "A binary tree with values stored in non-leaf nodes.",
    "kind": "inductive",
    "type": "Type u"
  },
  {
    "name": "add_con.to_add_submonoid",
    "statement": "def add_con.to_add_submonoid {M : Type u_1} [add_zero_class M] : has_coe (add_con M) (add_submonoid (M × M))",
    "theorem": "{M : Type u_1} [add_zero_class M] : has_coe (add_con M) (add_submonoid (M × M))",
    "args": "{M : Type u_1} [add_zero_class M]",
    "doc_string": "Coercion from a congruence relation `c` on an `add_monoid` `M` to the `add_submonoid` of `M × M` whose elements are `(x, y)` such that `x` is related to `y` by `c`.",
    "kind": "def",
    "type": "has_coe (add_con M) (add_submonoid (M × M))"
  },
  {
    "name": "finset.Ico",
    "statement": "def finset.Ico {α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α) : finset α",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] (a b : α)",
    "doc_string": "The finset of elements `x` such that `a ≤ x` and `x < b`. Basically `set.Ico a b` as a finset.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "num.succ'",
    "statement": "def num.succ'  : num → pos_num",
    "theorem": " : num → pos_num",
    "args": "",
    "doc_string": "The successor of a `num` as a `pos_num`.",
    "kind": "def",
    "type": "num → pos_num"
  },
  {
    "name": "zero_lt.right.mul_lt_one_of_lt_of_le",
    "statement": "theorem zero_lt.right.mul_lt_one_of_lt_of_le {α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b < 1",
    "theorem": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b < 1",
    "args": "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b)",
    "doc_string": "Assumes right covariance.",
    "kind": "theorem",
    "type": "a * b < 1"
  },
  {
    "name": "encodable.decode_subtype",
    "statement": "def encodable.decode_subtype {α : Type u_1} {P : α → Prop} [encA : encodable α] [decP : decidable_pred P] (v : ℕ) : option {a // P a}",
    "theorem": "{α : Type u_1} {P : α → Prop} [encA : encodable α] [decP : decidable_pred P] (v : ℕ) : option {a // P a}",
    "args": "{α : Type u_1} {P : α → Prop} [encA : encodable α] [decP : decidable_pred P] (v : ℕ)",
    "doc_string": "Explicit decoding function for a decidable subtype of an encodable type",
    "kind": "def",
    "type": "option {a // P a}"
  },
  {
    "name": "category_theory.End.group",
    "statement": "def category_theory.End.group {C : Type u} [category_theory.groupoid C] (X : C) : group (category_theory.End X)",
    "theorem": "{C : Type u} [category_theory.groupoid C] (X : C) : group (category_theory.End X)",
    "args": "{C : Type u} [category_theory.groupoid C] (X : C)",
    "doc_string": "In a groupoid, endomorphisms form a group",
    "kind": "def",
    "type": "group (category_theory.End X)"
  },
  {
    "name": "continued_fraction.has_coe_to_simple_continued_fraction",
    "statement": "def continued_fraction.has_coe_to_simple_continued_fraction {α : Type u_1} [has_one α] [has_zero α] [has_lt α] : has_coe (continued_fraction α) (simple_continued_fraction α)",
    "theorem": "{α : Type u_1} [has_one α] [has_zero α] [has_lt α] : has_coe (continued_fraction α) (simple_continued_fraction α)",
    "args": "{α : Type u_1} [has_one α] [has_zero α] [has_lt α]",
    "doc_string": "Lift a cf to a scf using the inclusion map.",
    "kind": "def",
    "type": "has_coe (continued_fraction α) (simple_continued_fraction α)"
  },
  {
    "name": "dihedral_group.order_of_r",
    "statement": "theorem dihedral_group.order_of_r {n : ℕ} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val",
    "theorem": "{n : ℕ} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val",
    "args": "{n : ℕ} [fact (0 < n)] (i : zmod n)",
    "doc_string": "If `0 < n`, then `i : zmod n` has order `n / gcd n i`.",
    "kind": "theorem",
    "type": "order_of (dihedral_group.r i) = n / n.gcd i.val"
  },
  {
    "name": "category_theory.limits.binary_bicone",
    "statement": "structure category_theory.limits.binary_bicone {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C) : Type (max u v)",
    "args": "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] (P Q : C)",
    "doc_string": "A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`, maps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`, so that `inl ≫ fst = 𝟙 P`, `inl ≫ snd = 0`, `inr ≫ fst = 0`, and `inr ≫ snd = 𝟙 Q`",
    "kind": "structure",
    "type": "Type (max u v)"
  },
  {
    "name": "rand_g.next",
    "statement": "def rand_g.next {g : Type} [random_gen g] : rand_g g ℕ",
    "theorem": "{g : Type} [random_gen g] : rand_g g ℕ",
    "args": "{g : Type} [random_gen g]",
    "doc_string": "Generate one more `ℕ`",
    "kind": "def",
    "type": "rand_g g ℕ"
  },
  {
    "name": "div_lt_div_of_mul_sub_mul_div_neg",
    "statement": "theorem div_lt_div_of_mul_sub_mul_div_neg {α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 → a / c < b / d",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 → a / c < b / d",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0)",
    "doc_string": "**Alias** of the forward direction of mul_sub_mul_div_mul_neg_iff`.",
    "kind": "theorem",
    "type": "(a * d - b * c) / (c * d) < 0 → a / c < b / d"
  },
  {
    "name": "nat.arithmetic_function",
    "statement": "def nat.arithmetic_function (R : Type u_1) [has_zero R] : Type u_1",
    "theorem": "(R : Type u_1) [has_zero R] : Type u_1",
    "args": "(R : Type u_1) [has_zero R]",
    "doc_string": "An arithmetic function is a function from `ℕ` that maps 0 to 0. In the literature, they are  often instead defined as functions from `ℕ+`. Multiplication on `arithmetic_functions` is by  Dirichlet convolution.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "category_theory.limits.has_binary_biproducts.of_has_binary_coproducts",
    "statement": "theorem category_theory.limits.has_binary_biproducts.of_has_binary_coproducts {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C]",
    "doc_string": "In a preadditive category, if all binary coproducts exist, then all binary biproducts exist.",
    "kind": "theorem",
    "type": "category_theory.limits.has_binary_biproducts C"
  },
  {
    "name": "nat.decreasing_induction",
    "statement": "def nat.decreasing_induction {P : ℕ → Sort u_1} (h : Π (n : ℕ), P (n + 1) → P n) {m n : ℕ} (mn : m ≤ n) (hP : P n) : P m",
    "theorem": "{P : ℕ → Sort u_1} (h : Π (n : ℕ), P (n + 1) → P n) {m n : ℕ} (mn : m ≤ n) (hP : P n) : P m",
    "args": "{P : ℕ → Sort u_1} (h : Π (n : ℕ), P (n + 1) → P n) {m n : ℕ} (mn : m ≤ n) (hP : P n)",
    "doc_string": " Decreasing induction: if `P (k+1)` implies `P k`, then `P n` implies `P m` for all `m ≤ n`. Also works for functions to `Sort*`. For a version assuming only the assumption for `k < n`, see `decreasing_induction'`.",
    "kind": "def",
    "type": "P m"
  },
  {
    "name": "monoid_with_zero.to_mul_action_with_zero",
    "statement": "def monoid_with_zero.to_mul_action_with_zero (R : Type u_1) [monoid_with_zero R] : mul_action_with_zero R R",
    "theorem": "(R : Type u_1) [monoid_with_zero R] : mul_action_with_zero R R",
    "args": "(R : Type u_1) [monoid_with_zero R]",
    "doc_string": "See also `semiring.to_module`",
    "kind": "def",
    "type": "mul_action_with_zero R R"
  },
  {
    "name": "conj_act",
    "statement": "def conj_act (G : Type u_2) : Type u_2",
    "theorem": "(G : Type u_2) : Type u_2",
    "args": "(G : Type u_2)",
    "doc_string": "A type alias for a group `G`. `conj_act G` acts on `G` by conjugation",
    "kind": "def",
    "type": "Type u_2"
  },
  {
    "name": "part",
    "statement": "structure part (α : Type u) : Type u",
    "theorem": "(α : Type u) : Type u",
    "args": "(α : Type u)",
    "doc_string": "`part α` is the type of \"partial values\" of type `α`. It  is similar to `option α` except the domain condition can be an  arbitrary proposition, not necessarily decidable.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "lower_set.compl",
    "statement": "def lower_set.compl {α : Type u_1} [has_le α] (s : lower_set α) : upper_set α",
    "theorem": "{α : Type u_1} [has_le α] (s : lower_set α) : upper_set α",
    "args": "{α : Type u_1} [has_le α] (s : lower_set α)",
    "doc_string": "The complement of a lower set as an upper set.",
    "kind": "def",
    "type": "upper_set α"
  },
  {
    "name": "prime_dvd_char_iff_dvd_card",
    "statement": "theorem prime_dvd_char_iff_dvd_card {R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R",
    "theorem": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R",
    "args": "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)]",
    "doc_string": " The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality.",
    "kind": "theorem",
    "type": "p ∣ ring_char R ↔ p ∣ fintype.card R"
  },
  {
    "name": "is_absolute_value.uniform_space",
    "statement": "def is_absolute_value.uniform_space {𝕜 : Type u_1} [linear_ordered_field 𝕜] {R : Type u_2} [comm_ring R] (abv : R → 𝕜) [is_absolute_value abv] : uniform_space R",
    "theorem": "{𝕜 : Type u_1} [linear_ordered_field 𝕜] {R : Type u_2} [comm_ring R] (abv : R → 𝕜) [is_absolute_value abv] : uniform_space R",
    "args": "{𝕜 : Type u_1} [linear_ordered_field 𝕜] {R : Type u_2} [comm_ring R] (abv : R → 𝕜) [is_absolute_value abv]",
    "doc_string": "The uniform structure coming from an absolute value.",
    "kind": "def",
    "type": "uniform_space R"
  },
  {
    "name": "second_countable_topology_either",
    "statement": "structure second_countable_topology_either (α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] : Prop",
    "theorem": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β] : Prop",
    "args": "(α : Type u_1) (β : Type u_2) [topological_space α] [topological_space β]",
    "doc_string": " The typeclass `second_countable_topology_either α β` registers the fact that at least one of the two spaces has second countable topology. This is the right assumption to ensure that continuous maps from `α` to `β` are strongly measurable.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "nonempty_fin_lin_ord",
    "statement": "structure nonempty_fin_lin_ord (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "A typeclass for nonempty finite linear orders.",
    "kind": "structure",
    "type": "Type u_1"
  },
  {
    "name": "nat.partition",
    "statement": "structure nat.partition (n : ℕ) : Type",
    "theorem": "(n : ℕ) : Type",
    "args": "(n : ℕ)",
    "doc_string": "A partition of `n` is a multiset of positive integers summing to `n`.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "geometry.simplicial_complex.has_inf",
    "statement": "def geometry.simplicial_complex.has_inf (𝕜 : Type u_1) (E : Type u_2) [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] : has_inf (geometry.simplicial_complex 𝕜 E)",
    "theorem": "(𝕜 : Type u_1) (E : Type u_2) [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] : has_inf (geometry.simplicial_complex 𝕜 E)",
    "args": "(𝕜 : Type u_1) (E : Type u_2) [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E]",
    "doc_string": "The complex consisting of only the faces present in both of its arguments.",
    "kind": "def",
    "type": "has_inf (geometry.simplicial_complex 𝕜 E)"
  },
  {
    "name": "same_ray.neg",
    "statement": "theorem same_ray.neg {R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y → same_ray R (-x) (-y)",
    "theorem": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y → same_ray R (-x) (-y)",
    "args": "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M}",
    "doc_string": "**Alias** of the reverse direction of same_ray_neg_iff`.",
    "kind": "theorem",
    "type": "same_ray R x y → same_ray R (-x) (-y)"
  },
  {
    "name": "is_invariant_subfield",
    "statement": "structure is_invariant_subfield (M : Type u) [monoid M] {F : Type v} [field F] [mul_semiring_action M F] (S : subfield F) : Prop",
    "theorem": "(M : Type u) [monoid M] {F : Type v} [field F] [mul_semiring_action M F] (S : subfield F) : Prop",
    "args": "(M : Type u) [monoid M] {F : Type v} [field F] [mul_semiring_action M F] (S : subfield F)",
    "doc_string": "A typeclass for subrings invariant under a `mul_semiring_action`.",
    "kind": "structure",
    "type": "Prop"
  },
  {
    "name": "encodable.encode_sigma",
    "statement": "def encodable.encode_sigma {α : Type u_1} {γ : α → Type u_3} [encodable α] [Π (a : α), encodable (γ a)] : sigma γ → ℕ",
    "theorem": "{α : Type u_1} {γ : α → Type u_3} [encodable α] [Π (a : α), encodable (γ a)] : sigma γ → ℕ",
    "args": "{α : Type u_1} {γ : α → Type u_3} [encodable α] [Π (a : α), encodable (γ a)]",
    "doc_string": "Explicit encoding function for `sigma γ`",
    "kind": "def",
    "type": "sigma γ → ℕ"
  },
  {
    "name": "finpartition.has_bot",
    "statement": "def finpartition.has_bot {α : Type u_1} [decidable_eq α] (s : finset α) : has_bot (finpartition s)",
    "theorem": "{α : Type u_1} [decidable_eq α] (s : finset α) : has_bot (finpartition s)",
    "args": "{α : Type u_1} [decidable_eq α] (s : finset α)",
    "doc_string": "`⊥` is the partition in singletons, aka discrete partition.",
    "kind": "def",
    "type": "has_bot (finpartition s)"
  },
  {
    "name": "enorm.has_top",
    "statement": "def enorm.has_top {𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] : has_top (enorm 𝕜 V)",
    "theorem": "{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V] : has_top (enorm 𝕜 V)",
    "args": "{𝕜 : Type u_1} {V : Type u_2} [normed_field 𝕜] [add_comm_group V] [module 𝕜 V]",
    "doc_string": "The `enorm` sending each non-zero vector to infinity.",
    "kind": "def",
    "type": "has_top (enorm 𝕜 V)"
  },
  {
    "name": "multiset.sections",
    "statement": "def multiset.sections {α : Type u_1} (s : multiset (multiset α)) : multiset (multiset α)",
    "theorem": "{α : Type u_1} (s : multiset (multiset α)) : multiset (multiset α)",
    "args": "{α : Type u_1} (s : multiset (multiset α))",
    "doc_string": "The sections of a multiset of multisets `s` consists of all those multisets which can be put in bijection with `s`, so each element is an member of the corresponding multiset.",
    "kind": "def",
    "type": "multiset (multiset α)"
  },
  {
    "name": "neg_nonneg",
    "statement": "theorem neg_nonneg {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a ↔ a ≤ 0",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a ↔ a ≤ 0",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α}",
    "doc_string": "**Alias** of left.one_le_inv_iff`.",
    "kind": "theorem",
    "type": "0 ≤ -a ↔ a ≤ 0"
  },
  {
    "name": "filter.comap",
    "statement": "def filter.comap {α : Type u} {β : Type v} (m : α → β) (f : filter β) : filter α",
    "theorem": "{α : Type u} {β : Type v} (m : α → β) (f : filter β) : filter α",
    "args": "{α : Type u} {β : Type v} (m : α → β) (f : filter β)",
    "doc_string": " The inverse map of a filter. A set `s` belongs to `filter.comap f l` if either of the following equivalent conditions hold.  1. There exists a set `t ∈ l` such that `f ⁻¹' t ⊆ s`. This is used as a definition. 2. The set `{y | ∀ x, f x = y → x ∈ s}` belongs to `l`, see `filter.mem_comap'`. 3. The set `(f '' sᶜ)ᶜ` belongs to `l`, see `filter.mem_comap_iff_compl` and `filter.compl_mem_comap`.",
    "kind": "def",
    "type": "filter α"
  },
  {
    "name": "is_add_hom.neg",
    "statement": "theorem is_add_hom.neg {α : Type u_1} {β : Type u_2} [has_add α] [add_comm_group β] {f : α → β} (hf : is_add_hom f) : is_add_hom (λ (a : α), -f a)",
    "theorem": "{α : Type u_1} {β : Type u_2} [has_add α] [add_comm_group β] {f : α → β} (hf : is_add_hom f) : is_add_hom (λ (a : α), -f a)",
    "args": "{α : Type u_1} {β : Type u_2} [has_add α] [add_comm_group β] {f : α → β} (hf : is_add_hom f)",
    "doc_string": "The negation of a map which preserves addition, preserves addition when the target is commutative.",
    "kind": "theorem",
    "type": "is_add_hom (λ (a : α), -f a)"
  },
  {
    "name": "abelianization",
    "statement": "def abelianization (G : Type u) [group G] : Type u",
    "theorem": "(G : Type u) [group G] : Type u",
    "args": "(G : Type u) [group G]",
    "doc_string": "The abelianization of G is the quotient of G by its commutator subgroup.",
    "kind": "def",
    "type": "Type u"
  },
  {
    "name": "encodable.encode_multiset",
    "statement": "def encodable.encode_multiset {α : Type u_1} [encodable α] (s : multiset α) : ℕ",
    "theorem": "{α : Type u_1} [encodable α] (s : multiset α) : ℕ",
    "args": "{α : Type u_1} [encodable α] (s : multiset α)",
    "doc_string": "Explicit encoding function for `multiset α`",
    "kind": "def",
    "type": "ℕ"
  },
  {
    "name": "ratfunc.mk",
    "statement": "def ratfunc.mk {K : Type u} [hring : comm_ring K] [hdomain : is_domain K] (p q : polynomial K) : ratfunc K",
    "theorem": "{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] (p q : polynomial K) : ratfunc K",
    "args": "{K : Type u} [hring : comm_ring K] [hdomain : is_domain K] (p q : polynomial K)",
    "doc_string": " `ratfunc.mk (p q : K[X])` is `p / q` as a rational function.  If `q = 0`, then `mk` returns 0.  This is an auxiliary definition used to define an `algebra` structure on `ratfunc`; the `simp` normal form of `mk p q` is `algebra_map _ _ p / algebra_map _ _ q`.",
    "kind": "def",
    "type": "ratfunc K"
  },
  {
    "name": "order.pred_ne_pred",
    "statement": "theorem order.pred_ne_pred {α : Type u_1} [partial_order α] [pred_order α] {a b : α} [no_min_order α] : a ≠ b → order.pred a ≠ order.pred b",
    "theorem": "{α : Type u_1} [partial_order α] [pred_order α] {a b : α} [no_min_order α] : a ≠ b → order.pred a ≠ order.pred b",
    "args": "{α : Type u_1} [partial_order α] [pred_order α] {a b : α} [no_min_order α]",
    "doc_string": "**Alias** of the reverse direction of order.pred_ne_pred_iff`.",
    "kind": "theorem",
    "type": "a ≠ b → order.pred a ≠ order.pred b"
  },
  {
    "name": "alexandroff.t0_space",
    "statement": "def alexandroff.t0_space {X : Type u_1} [topological_space X] [t0_space X] : t0_space (alexandroff X)",
    "theorem": "{X : Type u_1} [topological_space X] [t0_space X] : t0_space (alexandroff X)",
    "args": "{X : Type u_1} [topological_space X] [t0_space X]",
    "doc_string": "The one point compactification of a `t0_space` space is a `t0_space`.",
    "kind": "def",
    "type": "t0_space (alexandroff X)"
  },
  {
    "name": "category_theory.limits.sigma_obj",
    "statement": "def category_theory.limits.sigma_obj {β : Type w} {C : Type u} [category_theory.category C] (f : β → C) [category_theory.limits.has_coproduct f] : C",
    "theorem": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) [category_theory.limits.has_coproduct f] : C",
    "args": "{β : Type w} {C : Type u} [category_theory.category C] (f : β → C) [category_theory.limits.has_coproduct f]",
    "doc_string": " `sigma_obj f` computes the coproduct of a family of elements `f`. (It is defined as an abbreviation for `colimit (discrete.functor f)`, so for most facts about `sigma_obj f`, you will just use general facts about colimits.)",
    "kind": "def",
    "type": "C"
  },
  {
    "name": "right_iff_left_not_left_of",
    "statement": "theorem right_iff_left_not_left_of {α : Type u} (r s : α → α → Prop) [is_nonstrict_strict_order α r s] {a b : α} : s a b ↔ r a b ∧ ¬r b a",
    "theorem": "{α : Type u} (r s : α → α → Prop) [is_nonstrict_strict_order α r s] {a b : α} : s a b ↔ r a b ∧ ¬r b a",
    "args": "{α : Type u} (r s : α → α → Prop) [is_nonstrict_strict_order α r s] {a b : α}",
    "doc_string": "A version of `right_iff_left_not_left` with explicit `r` and `s`.",
    "kind": "theorem",
    "type": "s a b ↔ r a b ∧ ¬r b a"
  },
  {
    "name": "tactic.itauto.proof",
    "statement": "inductive tactic.itauto.proof  : Type",
    "theorem": " : Type",
    "args": "",
    "doc_string": "A reified inductive proof type for intuitionistic propositional logic.",
    "kind": "inductive",
    "type": "Type"
  },
  {
    "name": "lt_sub_left_of_add_lt",
    "statement": "theorem lt_sub_left_of_add_lt {α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < c - a",
    "theorem": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < c - a",
    "args": "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α}",
    "doc_string": "**Alias** of the reverse direction of lt_sub_iff_add_lt'`.",
    "kind": "theorem",
    "type": "a + b < c → b < c - a"
  },
  {
    "name": "prime_spectrum.compact_space",
    "statement": "def prime_spectrum.compact_space {R : Type u} [comm_ring R] : compact_space (prime_spectrum R)",
    "theorem": "{R : Type u} [comm_ring R] : compact_space (prime_spectrum R)",
    "args": "{R : Type u} [comm_ring R]",
    "doc_string": "The prime spectrum of a commutative ring is a compact topological space.",
    "kind": "def",
    "type": "compact_space (prime_spectrum R)"
  },
  {
    "name": "subring.add_mem",
    "statement": "theorem subring.add_mem {R : Type u} [ring R] (s : subring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s",
    "theorem": "{R : Type u} [ring R] (s : subring R) {x y : R} : x ∈ s → y ∈ s → x + y ∈ s",
    "args": "{R : Type u} [ring R] (s : subring R) {x y : R}",
    "doc_string": "A subring is closed under addition.",
    "kind": "theorem",
    "type": "x ∈ s → y ∈ s → x + y ∈ s"
  },
  {
    "name": "category_theory.limits.walking_multicospan",
    "statement": "inductive category_theory.limits.walking_multicospan {L R : Type v} (fst snd : R → L) : Type v",
    "theorem": "{L R : Type v} (fst snd : R → L) : Type v",
    "args": "{L R : Type v} (fst snd : R → L)",
    "doc_string": "The type underlying the multiequalizer diagram.",
    "kind": "inductive",
    "type": "Type v"
  },
  {
    "name": "add_semigroup",
    "statement": "structure add_semigroup (G : Type u) : Type u",
    "theorem": "(G : Type u) : Type u",
    "args": "(G : Type u)",
    "doc_string": "An additive semigroup is a type with an associative `(+)`.",
    "kind": "structure",
    "type": "Type u"
  },
  {
    "name": "neg_le_of_neg_le",
    "statement": "theorem neg_le_of_neg_le {α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : -a ≤ b → -b ≤ a",
    "theorem": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : -a ≤ b → -b ≤ a",
    "args": "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α}",
    "doc_string": "**Alias** of the forward direction of inv_le'`.",
    "kind": "theorem",
    "type": "-a ≤ b → -b ≤ a"
  },
  {
    "name": "uv.compression",
    "statement": "def uv.compression {α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α) : finset α",
    "theorem": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α) : finset α",
    "args": "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v : α) (s : finset α)",
    "doc_string": " To UV-compress a set family, we compress each of its elements, except that we don't want to reduce the cardinality, so we keep all elements whose compression is already present.",
    "kind": "def",
    "type": "finset α"
  },
  {
    "name": "add_monoid.is_torsion",
    "statement": "def add_monoid.is_torsion (G : Type u_1) [add_monoid G] : Prop",
    "theorem": "(G : Type u_1) [add_monoid G] : Prop",
    "args": "(G : Type u_1) [add_monoid G]",
    "doc_string": "A predicate on an additive monoid saying that all elements are of finite order.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "frame_hom",
    "statement": "structure frame_hom (α : Type u_8) (β : Type u_9) [complete_lattice α] [complete_lattice β] : Type (max u_8 u_9)",
    "theorem": "(α : Type u_8) (β : Type u_9) [complete_lattice α] [complete_lattice β] : Type (max u_8 u_9)",
    "args": "(α : Type u_8) (β : Type u_9) [complete_lattice α] [complete_lattice β]",
    "doc_string": "The type of frame homomorphisms from `α` to `β`. They preserve finite meets and arbitrary joins.",
    "kind": "structure",
    "type": "Type (max u_8 u_9)"
  },
  {
    "name": "category_theory.indecomposable_of_simple",
    "statement": "theorem category_theory.indecomposable_of_simple {C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X",
    "theorem": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X",
    "args": "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X]",
    "doc_string": "Any simple object in a preadditive category is indecomposable.",
    "kind": "theorem",
    "type": "category_theory.indecomposable X"
  },
  {
    "name": "io.run_rand",
    "statement": "def io.run_rand {α : Type} (cmd : rand α) : io α",
    "theorem": "{α : Type} (cmd : rand α) : io α",
    "args": "{α : Type} (cmd : rand α)",
    "doc_string": "Run `cmd` using a randomly seeded random number generator",
    "kind": "def",
    "type": "io α"
  },
  {
    "name": "composition_series.to_list",
    "statement": "def composition_series.to_list {X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : list X",
    "theorem": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X) : list X",
    "args": "{X : Type u} [lattice X] [jordan_holder_lattice X] (s : composition_series X)",
    "doc_string": "The ordered `list X` of elements of a `composition_series X`.",
    "kind": "def",
    "type": "list X"
  },
  {
    "name": "pythagorean_triple",
    "statement": "def pythagorean_triple (x y z : ℤ) : Prop",
    "theorem": "(x y z : ℤ) : Prop",
    "args": "(x y z : ℤ)",
    "doc_string": "Three integers `x`, `y`, and `z` form a Pythagorean triple if `x * x + y * y = z * z`.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "is_add_right_regular_of_right_cancel_add_semigroup",
    "statement": "theorem is_add_right_regular_of_right_cancel_add_semigroup {R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g",
    "theorem": "{R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g",
    "args": "{R : Type u_1} [add_right_cancel_semigroup R] (g : R)",
    "doc_string": "Elements of an add right cancel semigroup are add-right-regular",
    "kind": "theorem",
    "type": "is_add_right_regular g"
  },
  {
    "name": "computation.join",
    "statement": "def computation.join {α : Type u} (c : computation (computation α)) : computation α",
    "theorem": "{α : Type u} (c : computation (computation α)) : computation α",
    "args": "{α : Type u} (c : computation (computation α))",
    "doc_string": "Flatten a computation of computations into a single computation.",
    "kind": "def",
    "type": "computation α"
  },
  {
    "name": "bornology.induced",
    "statement": "def bornology.induced {α : Type u_1} {β : Type u_2} [bornology β] (f : α → β) : bornology α",
    "theorem": "{α : Type u_1} {β : Type u_2} [bornology β] (f : α → β) : bornology α",
    "args": "{α : Type u_1} {β : Type u_2} [bornology β] (f : α → β)",
    "doc_string": "Inverse image of a bornology.",
    "kind": "def",
    "type": "bornology α"
  },
  {
    "name": "lattice_ordered_comm_group.has_zero_lattice_has_pos_part",
    "statement": "def lattice_ordered_comm_group.has_zero_lattice_has_pos_part {α : Type u} [lattice α] [add_comm_group α] : has_pos_part α",
    "theorem": "{α : Type u} [lattice α] [add_comm_group α] : has_pos_part α",
    "args": "{α : Type u} [lattice α] [add_comm_group α]",
    "doc_string": "Let `α` be a lattice ordered commutative group with identity `0`. For an element `a` of type `α`, the element `a ⊔ 0` is said to be the *positive component* of `a`, denoted `a⁺`.",
    "kind": "def",
    "type": "has_pos_part α"
  },
  {
    "name": "dense_range.some",
    "statement": "def dense_range.some {β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : dense_range f) (b : β) : κ",
    "theorem": "{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : dense_range f) (b : β) : κ",
    "args": "{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : dense_range f) (b : β)",
    "doc_string": "Given a function `f : α → β` with dense range and `b : β`, returns some `a : α`.",
    "kind": "def",
    "type": "κ"
  },
  {
    "name": "multiset.decidable_eq_pi_multiset",
    "statement": "def multiset.decidable_eq_pi_multiset {α : Type u_1} {m : multiset α} {β : α → Type u_2} [h : Π (a : α), decidable_eq (β a)] : decidable_eq (Π (a : α), a ∈ m → β a)",
    "theorem": "{α : Type u_1} {m : multiset α} {β : α → Type u_2} [h : Π (a : α), decidable_eq (β a)] : decidable_eq (Π (a : α), a ∈ m → β a)",
    "args": "{α : Type u_1} {m : multiset α} {β : α → Type u_2} [h : Π (a : α), decidable_eq (β a)]",
    "doc_string": "decidable equality for functions whose domain is bounded by multisets",
    "kind": "def",
    "type": "decidable_eq (Π (a : α), a ∈ m → β a)"
  },
  {
    "name": "where.select_for_which",
    "statement": "def where.select_for_which {α β γ : Type} (p : α → β × γ) [decidable_eq β] (b' : β) : list α → list γ × list α",
    "theorem": "{α β γ : Type} (p : α → β × γ) [decidable_eq β] (b' : β) : list α → list γ × list α",
    "args": "{α β γ : Type} (p : α → β × γ) [decidable_eq β] (b' : β)",
    "doc_string": " Selects the elements of the given `list α` which under the image of `p : α → β × γ` have `β` component equal to `b'`. Returns the `γ` components of the selected elements under the image of `p`, and the elements of the original `list α` which were not selected.",
    "kind": "def",
    "type": "list α → list γ × list α"
  },
  {
    "name": "filter.is_bounded_under",
    "statement": "def filter.is_bounded_under {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (f : filter β) (u : β → α) : Prop",
    "theorem": "{α : Type u_1} {β : Type u_2} (r : α → α → Prop) (f : filter β) (u : β → α) : Prop",
    "args": "{α : Type u_1} {β : Type u_2} (r : α → α → Prop) (f : filter β) (u : β → α)",
    "doc_string": " `f.is_bounded_under (≺) u`: the image of the filter `f` under `u` is eventually bounded w.r.t. the relation `≺`, i.e. eventually, it is bounded by some uniform bound.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "div_le_of_nonneg_of_le_mul",
    "statement": "theorem div_le_of_nonneg_of_le_mul {α : Type u_1} [linear_ordered_field α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b) : a / b ≤ c",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b) : a / b ≤ c",
    "args": "{α : Type u_1} [linear_ordered_field α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b)",
    "doc_string": "One direction of `div_le_iff` where `b` is allowed to be `0` (but `c` must be nonnegative)",
    "kind": "theorem",
    "type": "a / b ≤ c"
  },
  {
    "name": "fintype.to_complete_lattice_of_nonempty",
    "statement": "def fintype.to_complete_lattice_of_nonempty (α : Type u_2) [fintype α] [nonempty α] [lattice α] : complete_lattice α",
    "theorem": "(α : Type u_2) [fintype α] [nonempty α] [lattice α] : complete_lattice α",
    "args": "(α : Type u_2) [fintype α] [nonempty α] [lattice α]",
    "doc_string": " A nonempty finite lattice is complete. If the lattice is already a `bounded_order`, then use `fintype.to_complete_lattice` instead, as this gives definitional equality for `⊥` and `⊤`.",
    "kind": "def",
    "type": "complete_lattice α"
  },
  {
    "name": "combinatorics.line.almost_mono",
    "statement": "structure combinatorics.line.almost_mono {α : Type u_1} {ι : Type u_2} {κ : Type u_3} (C : (ι → option α) → κ) : Type (max u_1 u_2 u_3)",
    "theorem": "{α : Type u_1} {ι : Type u_2} {κ : Type u_3} (C : (ι → option α) → κ) : Type (max u_1 u_2 u_3)",
    "args": "{α : Type u_1} {ι : Type u_2} {κ : Type u_3} (C : (ι → option α) → κ)",
    "doc_string": "The type of lines that are only one color except possibly at their endpoints.",
    "kind": "structure",
    "type": "Type (max u_1 u_2 u_3)"
  },
  {
    "name": "fin.sub_nat",
    "statement": "def fin.sub_nat {n : ℕ} (m : ℕ) (i : fin (n + m)) (h : m ≤ ↑i) : fin n",
    "theorem": "{n : ℕ} (m : ℕ) (i : fin (n + m)) (h : m ≤ ↑i) : fin n",
    "args": "{n : ℕ} (m : ℕ) (i : fin (n + m)) (h : m ≤ ↑i)",
    "doc_string": "`sub_nat i h` subtracts `m` from `i`, generalizes `fin.pred`.",
    "kind": "def",
    "type": "fin n"
  },
  {
    "name": "valuation_ring.of_field",
    "statement": "def valuation_ring.of_field (K : Type u) [field K] : valuation_ring K",
    "theorem": "(K : Type u) [field K] : valuation_ring K",
    "args": "(K : Type u) [field K]",
    "doc_string": "A field is a valuation ring.",
    "kind": "def",
    "type": "valuation_ring K"
  },
  {
    "name": "set_semiring",
    "statement": "def set_semiring (α : Type u_1) : Type u_1",
    "theorem": "(α : Type u_1) : Type u_1",
    "args": "(α : Type u_1)",
    "doc_string": "An alias for `set α`, which has a semiring structure given by `∪` as \"addition\" and pointwise  multiplication `*` as \"multiplication\".",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "order.ideal.has_sup",
    "statement": "def order.ideal.has_sup {P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_sup (order.ideal P)",
    "theorem": "{P : Type u_1} [semilattice_sup P] [is_directed P ge] : has_sup (order.ideal P)",
    "args": "{P : Type u_1} [semilattice_sup P] [is_directed P ge]",
    "doc_string": " The supremum of two ideals of a co-directed order is the union of the down sets of the pointwise supremum of `I` and `J`.",
    "kind": "def",
    "type": "has_sup (order.ideal P)"
  },
  {
    "name": "nat.cast_div_le",
    "statement": "theorem nat.cast_div_le {α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n",
    "theorem": "{α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n",
    "args": "{α : Type u_1} [linear_ordered_field α] {m n : ℕ}",
    "doc_string": "Natural division is always less than division in the field.",
    "kind": "theorem",
    "type": "↑(m / n) ≤ ↑m / ↑n"
  },
  {
    "name": "flow.reverse",
    "statement": "def flow.reverse {τ : Type u_1} [add_comm_group τ] [topological_space τ] [topological_add_group τ] {α : Type u_2} [topological_space α] (ϕ : flow τ α) : flow τ α",
    "theorem": "{τ : Type u_1} [add_comm_group τ] [topological_space τ] [topological_add_group τ] {α : Type u_2} [topological_space α] (ϕ : flow τ α) : flow τ α",
    "args": "{τ : Type u_1} [add_comm_group τ] [topological_space τ] [topological_add_group τ] {α : Type u_2} [topological_space α] (ϕ : flow τ α)",
    "doc_string": "The time-reversal of a flow `ϕ` by a (commutative, additive) group    is defined `ϕ.reverse t x = ϕ (-t) x`.",
    "kind": "def",
    "type": "flow τ α"
  },
  {
    "name": "function.has_left_inverse",
    "statement": "def function.has_left_inverse {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "theorem": "{α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop",
    "args": "{α : Sort u₁} {β : Sort u₂} (f : α → β)",
    "doc_string": "`has_left_inverse f` means that `f` has an unspecified left inverse.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "finset.choose",
    "statement": "def finset.choose {α : Type u_1} (p : α → Prop) [decidable_pred p] (l : finset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : α",
    "theorem": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : finset α) (hp : ∃! (a : α), a ∈ l ∧ p a) : α",
    "args": "{α : Type u_1} (p : α → Prop) [decidable_pred p] (l : finset α) (hp : ∃! (a : α), a ∈ l ∧ p a)",
    "doc_string": " Given a finset `l` and a predicate `p`, associate to a proof that there is a unique element of `l` satisfying `p` this unique element, as an element of the ambient type.",
    "kind": "def",
    "type": "α"
  },
  {
    "name": "discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization",
    "statement": "def discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization (R : Type u_1) [comm_ring R] : Prop",
    "theorem": "(R : Type u_1) [comm_ring R] : Prop",
    "args": "(R : Type u_1) [comm_ring R]",
    "doc_string": "Alternative characterisation of discrete valuation rings.",
    "kind": "def",
    "type": "Prop"
  },
  {
    "name": "pfunctor.W",
    "statement": "def pfunctor.W (P : pfunctor) : Type u_1",
    "theorem": "(P : pfunctor) : Type u_1",
    "args": "(P : pfunctor)",
    "doc_string": " re-export existing definition of W-types and adapt it to a packaged definition of polynomial functor",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "subalgebra.center",
    "statement": "def subalgebra.center (R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : subalgebra R A",
    "theorem": "(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A] : subalgebra R A",
    "args": "(R : Type u) (A : Type v) [comm_semiring R] [semiring A] [algebra R A]",
    "doc_string": " The center of an algebra is the set of elements which commute with every element. They form a subalgebra.",
    "kind": "def",
    "type": "subalgebra R A"
  },
  {
    "name": "nat.decidable_prime_1",
    "statement": "def nat.decidable_prime_1 (p : ℕ) : decidable (nat.prime p)",
    "theorem": "(p : ℕ) : decidable (nat.prime p)",
    "args": "(p : ℕ)",
    "doc_string": "This instance is slower than the instance `decidable_prime` defined below, but has the advantage that it works in the kernel for small values.  If you need to prove that a particular number is prime, in any case you should not use `dec_trivial`, but rather `by norm_num`, which is much faster.",
    "kind": "def",
    "type": "decidable (nat.prime p)"
  },
  {
    "name": "polynomial.iterated_deriv",
    "statement": "def polynomial.iterated_deriv {R : Type u} [semiring R] (f : polynomial R) (n : ℕ) : polynomial R",
    "theorem": "{R : Type u} [semiring R] (f : polynomial R) (n : ℕ) : polynomial R",
    "args": "{R : Type u} [semiring R] (f : polynomial R) (n : ℕ)",
    "doc_string": "`iterated_deriv f n` is the `n`-th formal derivative of the polynomial `f`",
    "kind": "def",
    "type": "polynomial R"
  },
  {
    "name": "polynomial.gal",
    "statement": "def polynomial.gal {F : Type u_1} [field F] (p : polynomial F) : Type u_1",
    "theorem": "{F : Type u_1} [field F] (p : polynomial F) : Type u_1",
    "args": "{F : Type u_1} [field F] (p : polynomial F)",
    "doc_string": "The Galois group of a polynomial.",
    "kind": "def",
    "type": "Type u_1"
  },
  {
    "name": "add_subgroup.complete_lattice",
    "statement": "def add_subgroup.complete_lattice {G : Type u_1} [add_group G] : complete_lattice (add_subgroup G)",
    "theorem": "{G : Type u_1} [add_group G] : complete_lattice (add_subgroup G)",
    "args": "{G : Type u_1} [add_group G]",
    "doc_string": "The `add_subgroup`s of an `add_group` form a complete lattice.",
    "kind": "def",
    "type": "complete_lattice (add_subgroup G)"
  },
  {
    "name": "finset.Ico_eq_empty",
    "statement": "theorem finset.Ico_eq_empty {α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ico a b = ∅",
    "theorem": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ico a b = ∅",
    "args": "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α}",
    "doc_string": "**Alias** of the reverse direction of finset.Ico_eq_empty_iff`.",
    "kind": "theorem",
    "type": "¬a < b → finset.Ico a b = ∅"
  },
  {
    "name": "subfield_class",
    "statement": "structure subfield_class (S : Type u_1) (K : out_param (Type u_2)) [field K] [set_like S K] : Type",
    "theorem": "(S : Type u_1) (K : out_param (Type u_2)) [field K] [set_like S K] : Type",
    "args": "(S : Type u_1) (K : out_param (Type u_2)) [field K] [set_like S K]",
    "doc_string": "`subfield_class S K` states `S` is a type of subsets `s ⊆ K` closed under field operations.",
    "kind": "structure",
    "type": "Type"
  },
  {
    "name": "cardinal.continuum",
    "statement": "def cardinal.continuum  : cardinal",
    "theorem": " : cardinal",
    "args": "",
    "doc_string": "Cardinality of continuum.",
    "kind": "def",
    "type": "cardinal"
  }
]