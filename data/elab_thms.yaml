- doc_string: "Triangle inequality for the nonnegative distance"
  theorem: "{α : Type u} [pseudo_metric_space α] (x y z : α) : has_nndist.nndist x z ≤ has_nndist.nndist x y + has_nndist.nndist y z"

- doc_string: "**Alias** of sub_neg`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 ↔ a < b"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b ≤ 1"

- doc_string: "If `R` is an additive monoid, an element in `add_units R` is add-regular."
  theorem: "{R : Type u_1} [add_monoid R] (a : add_units R) : is_add_regular ↑a"

- doc_string: " For every prime `p` dividing the order of a finite additive group `G` there exists an element of order `p` in `G`. This is the additive version of Cauchy's theorem."
  theorem: "{G : Type u_1} [add_group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), add_order_of x = p"

- doc_string: "**Alias** of the forward direction of sub_lt_iff_lt_add`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a - c < b → a < b + c"

- doc_string: "All values of a function `f ∈ std_simplex 𝕜 ι` belong to `[0, 1]`."
  theorem: "{R : Type u_1} {ι : Type u_4} [linear_ordered_field R] [fintype ι] {f : ι → R} (hf : f ∈ std_simplex R ι) (x : ι) : f x ∈ set.Icc 0 1"

- doc_string: " The neighbourhoods {γ | γ < γ₀} of 0 form a directed set indexed by the invertible elements γ₀."
  theorem: "(Γ₀ : Type u_1) [linear_ordered_comm_group_with_zero Γ₀] : directed ge (λ (γ₀ : Γ₀ˣ), filter.principal {γ : Γ₀ | γ < ↑γ₀})"

- doc_string: "The Legendre symbol of `p` and `a` is zero iff `p ∣ a`."
  theorem: "(p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = 0 ↔ ↑a = 0"

- doc_string: "The Hausdorff distance is nonnegative"
  theorem: "{α : Type u} [pseudo_metric_space α] {s t : set α} : 0 ≤ metric.Hausdorff_dist s t"

- doc_string: "In a non-trivial integral domain, an element is regular iff it is non-zero."
  theorem: "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] [nontrivial R] : is_regular a ↔ a ≠ 0"

- doc_string: "This is a special case of `with_top.coe_sub` in the `ennreal` namespace"
  theorem: "{r p : nnreal} : ↑(r - p) = ↑r - ↑p"

- doc_string: "Any descending central series for a group is bounded below by the lower central series."
  theorem: "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_descending_central_series H) (n : ℕ) : lower_central_series G n ≤ H n"

- doc_string: "A sequential limit of measurable `ℝ≥0∞` valued functions is measurable."
  theorem: "{α : Type u_1} [measurable_space α] {f : ℕ → α → ennreal} {g : α → ennreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g"

- doc_string: "In a local ring the characteristics is either zero or a prime power."
  theorem: "(R : Type u_1) [comm_ring R] [local_ring R] (q : ℕ) [char_R_q : char_p R q] : q = 0 ∨ is_prime_pow q"

- doc_string: "Any power of a left-regular element is left-regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] (n : ℕ) (rla : is_left_regular a) : is_left_regular (a ^ n)"

- doc_string: " The square of the cosine of `π / 6` is `3 / 4` (this is sometimes more convenient than the result for cosine itself)."
  theorem: " : real.cos (real.pi / 6) ^ 2 = 3 / 4"

- doc_string: "An element `a` is right-regular if and only if a positive power of `a` is right-regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n) : is_right_regular (a ^ n) ↔ is_right_regular a"

- doc_string: "A binary injective function is injective when only the left argument varies."
  theorem: "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (b : β) : function.injective (λ (a : α), f a b)"

- doc_string: "Any point is a periodic point of period `0`."
  theorem: "{α : Type u_1} (f : α → α) (x : α) : function.is_periodic_pt f 0 x"

- doc_string: "**Alias** of the reverse direction of is_atom_dual_iff_is_coatom`."
  theorem: "{α : Type u_1} [preorder α] [order_top α] {a : α} : is_coatom a → is_atom (⇑order_dual.to_dual a)"

- doc_string: " An injective function from a nontrivial type has an argument at which it does not take a given value."
  theorem: "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) (y : β) : ∃ (x : α), f x ≠ y"

- doc_string: "The set of natural number multiples of an element of an `add_monoid` `M` is an `add_submonoid` of `M`."
  theorem: "{M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x)"

- doc_string: "A continuous surjective open map is a quotient map."
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (open_map : is_open_map f) (cont : continuous f) (surj : function.surjective f) : quotient_map f"

- doc_string: "Infinite ordinals that are cardinals are unbounded."
  theorem: " : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}"

- doc_string: "If `irreducible (cyclotomic (p ^ n) R)` then `irreducible (cyclotomic p R).`"
  theorem: "{p : ℕ} (hp : nat.prime p) {R : Type u_1} [comm_ring R] [is_domain R] {n : ℕ} (hn : n ≠ 0) (h : irreducible (polynomial.cyclotomic (p ^ n) R)) : irreducible (polynomial.cyclotomic p R)"

- doc_string: "Deprecated: use `fun_like.congr_fun` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x"

- doc_string: "an n-digit number in base b + 2 is less than (b + 2)^n"
  theorem: "{b : ℕ} {l : list ℕ} (hl : ∀ (x : ℕ), x ∈ l → x < b + 2) : nat.of_digits (b + 2) l < (b + 2) ^ l.length"

- doc_string: " Embedding `i : fin n` into `fin (n + 1)` using a pivot `p` that is lesser results in a value that is greater than `p`."
  theorem: "{n : ℕ} (p : fin (n + 1)) (i : fin n) : p < ⇑(p.succ_above) i ↔ p ≤ ⇑fin.cast_succ i"

- doc_string: "A special case of `ring_hom.eq_int_cast'` that happens to be true definitionally"
  theorem: "(R : Type u_1) [ring R] : algebra_map ℤ R = int.cast_ring_hom R"

- doc_string: "A natural number is odd iff it has residue `1` or `3` mod `4`"
  theorem: "{n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3"

- doc_string: " `submodule.orthogonal` gives a `galois_connection` between `submodule 𝕜 E` and its `order_dual`."
  theorem: "(𝕜 : Type u_1) (E : Type u_2) [is_R_or_C 𝕜] [inner_product_space 𝕜 E] : galois_connection submodule.orthogonal submodule.orthogonal"

- doc_string: " If `S` is the localization of the Jacobson ring `R` at the submonoid generated by `y : R`, then `S` is Jacobson."
  theorem: "{R : Type u_1} {S : Type u_2} [comm_ring R] [comm_ring S] (y : R) [algebra R S] [is_localization.away y S] [H : ideal.is_jacobson R] : ideal.is_jacobson S"

- doc_string: " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative."
  theorem: "{α : Type u_1} {β : Type u_2} [mul_one_class α] [comm_group β] {f : α → β} (hf : is_monoid_hom f) : is_monoid_hom (λ (a : α), (f a)⁻¹)"

- doc_string: "The exponential characteristic is one if the characteristic is zero."
  theorem: "(R : Type u) [semiring R] (q : ℕ) [hp : char_p R 0] [hq : exp_char R q] : q = 1"

- doc_string: "**Alias** of the reverse direction of mul_sub_mul_div_mul_nonpos_iff`."
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c ≤ b / d → (a * d - b * c) / (c * d) ≤ 0"

- doc_string: "In a preadditive category, if the product over `f : J → C` exists,    then the biproduct over `f` exists."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_product f] : category_theory.limits.has_biproduct f"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1"

- doc_string: "An element a divides the sum a + b if and only if a divides b."
  theorem: "{α : Type u} [ring α] {a b : α} : a ∣ a + b ↔ a ∣ b"

- doc_string: "Extracts the erased value, if it is a proof."
  theorem: "{p : Prop} (a : erased p) : p"

- doc_string: "**Alias** of div_eq_mul_inv`."
  theorem: "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹"

- doc_string: "**Alias** of int.nat_abs_sq`."
  theorem: "(x : ℤ) : ↑(x.nat_abs) ^ 2 = x ^ 2"

- doc_string: "The sine of `π / 6` is `1 / 2`."
  theorem: " : real.sin (real.pi / 6) = 1 / 2"

- doc_string: "Any map `f` sends fixed points of `g ∘ f` to fixed points of `f ∘ g`."
  theorem: "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.maps_to f (function.fixed_points (g ∘ f)) (function.fixed_points (f ∘ g))"

- doc_string: "A category with finite biproducts has binary biproducts.  This is not an instance as typically in concrete categories there will be an alternative construction with nicer definitional properties."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_finite_biproducts C] : category_theory.limits.has_binary_biproducts C"

- doc_string: "**Alias** of the forward direction of lt_inv_mul_iff_mul_lt`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < -a + c → a + b < c"

- doc_string: " Multiplication on the left by a nonzero element of a normed division ring tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`."
  theorem: "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (has_mul.mul a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"

- doc_string: "**Alias** of mul_lt_mul_left'`."
  theorem: "{α : Type u_1} [has_mul α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {b c : α} (bc : b < c) (a : α) : a * b < a * c"

- doc_string: "The relation `≤` on a preorder is reflexive."
  theorem: "{α : Type u} [preorder α] (a : α) : a ≤ a"

- doc_string: "**Alias** of left.mul_lt_one`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "`X` is simple iff it has subobject lattice `{⊥, ⊤}`."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) : category_theory.simple X ↔ is_simple_order (category_theory.subobject X)"

- doc_string: "`set.image` is monotone. See `set.image_image` for the statement in terms of `⊆`."
  theorem: "{α : Type u_1} {β : Type u_2} {f : α → β} : monotone (set.image f)"

- doc_string: " The real exponential function tends to `0` at `-∞` or, equivalently, `exp(-x)` tends to `0` at `+∞`"
  theorem: " : filter.tendsto (λ (x : ℝ), real.exp (-x)) filter.at_top (nhds 0)"

- doc_string: " If `x = y` then `y ≤ x`. Note: this lemma uses `y ≤ x` instead of `x ≥ y`, because `le` is used almost exclusively in mathlib."
  theorem: "{α : Type u} [preorder α] {x y : α} (h : x = y) : y ≤ x"

- doc_string: "A balanced set absorbs itself."
  theorem: "{𝕜 : Type u_1} {E : Type u_3} [normed_field 𝕜] [add_comm_group E] [module 𝕜 E] {A : set E} (hA : balanced 𝕜 A) : absorbs 𝕜 A A"

- doc_string: "Shorthand for using projection notation with `function.bijective_iff_exists_unique`."
  theorem: "{α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : function.bijective f) (b : β) : ∃! (a : α), f a = b"

- doc_string: "**Alias** of le_of_eq`."
  theorem: "{α : Type u} [preorder α] {a b : α} : a = b → a ≤ b"

- doc_string: " A triple is still a triple if you multiply `x`, `y` and `z` by a constant `k`."
  theorem: "{x y z : ℤ} (h : pythagorean_triple x y z) (k : ℤ) : pythagorean_triple (k * x) (k * y) (k * z)"

- doc_string: "The indexed supremum of a function is bounded below by the value taken at one point"
  theorem: "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_above (set.range f)) (c : ι) : f c ≤ supr f"

- doc_string: "**Alias** of the reverse direction of order.succ_eq_iff_is_max`."
  theorem: "{α : Type u_1} [partial_order α] [succ_order α] {a : α} : is_max a → order.succ a = a"

- doc_string: "A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`."
  theorem: "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : is_square a ↔ a ^ (fintype.card F / 2) = 1"

- doc_string: "Over the ring `zmod (p^(n+1))`, we produce the `n+1`st Witt polynomial by expanding the `n`th Witt polynomial by `p`."
  theorem: "(p n : ℕ) : witt_polynomial p (zmod (p ^ (n + 1))) (n + 1) = ⇑(mv_polynomial.expand p) (witt_polynomial p (zmod (p ^ (n + 1))) n)"

- doc_string: "The value of the quadratic character at `-1`"
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) : char.quadratic_char F (-1) = ⇑zmod.χ₄ ↑(fintype.card F)"

- doc_string: "The pseudoelement induced by an arrow is zero precisely when that arrow is zero"
  theorem: "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} (a : category_theory.over P) : ↑a = 0 ↔ a.hom = 0"

- doc_string: "`∧` distributes over `∨` (on the left)."
  theorem: "{a b c : Prop} : a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c"

- doc_string: "Quantifying over a set is antitone in the set"
  theorem: "{α : Type u_1} {P : α → Prop} : antitone (λ (s : set α), ∀ (x : α), x ∈ s → P x)"

- doc_string: "**Alias** of lt_trans'`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : b < c → a < b → a < c"

- doc_string: "`∧` distributes over `∨` (on the right)."
  theorem: "{a b c : Prop} : (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c"

- doc_string: "The normal closure of s is a normal subgroup."
  theorem: "{G : Type u_1} {s : set G} [group G] : is_normal_subgroup (group.normal_closure s)"

- doc_string: "The identity is `C^∞`."
  theorem: "{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {n : with_top ℕ} : cont_diff 𝕜 n id"

- doc_string: "**Alias** of the reverse direction of sub_lt_iff_lt_add`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < b + c → a - c < b"

- doc_string: "The relation `≤` on a preorder is transitive."
  theorem: "{α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c"

- doc_string: "The currying process is a continuous map between function spaces."
  theorem: "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space (α × β)] : continuous continuous_map.curry"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1"

- doc_string: "If `t` is bounded, then so is `s ∩ t`"
  theorem: "{α : Type u} [preorder α] {s t : set α} (h : bdd_above t) : bdd_above (s ∩ t)"

- doc_string: "The closure of a (pre)connected set is (pre)connected as well."
  theorem: "{α : Type u} [topological_space α] {s : set α} (H : is_preconnected s) : is_preconnected (closure s)"

- doc_string: "In a field `F`, `X ^ n - 1` is separable iff `↑n ≠ 0`."
  theorem: "{F : Type u} [field F] {n : ℕ} : (polynomial.X ^ n - 1).separable ↔ ↑n ≠ 0"

- doc_string: "**Alias** of le_antisymm`."
  theorem: "{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → a = b"

- doc_string: "`pure : α → ultrafilter α` defines a dense embedding of `α` in `ultrafilter α`."
  theorem: "{α : Type u} : dense_embedding has_pure.pure"

- doc_string: " The weights in the centroid sum to 1, if the number of points, converted to `k`, is not zero."
  theorem: "{k : Type u_1} [division_ring k] {ι : Type u_4} (s : finset ι) (h : ↑(s.card) ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1"

- doc_string: "**Alias** of not_le_of_lt`."
  theorem: "{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b ≤ a"

- doc_string: "Addition of a `u : add_units M` on the left doesn't affect `is_add_unit`."
  theorem: "{M : Type u_1} [add_monoid M] (u : add_units M) (a : M) : is_add_unit (↑u + a) ↔ is_add_unit a"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_neg_of_neg_of_nonpos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0"

- doc_string: "A product is regular if and only if the factors are."
  theorem: "{R : Type u_1} {a b : R} [comm_semigroup R] : is_regular (a * b) ↔ is_regular a ∧ is_regular b"

- doc_string: " We intentionally restrict the type of `α` in this lemma so that this is a safer to use in simp than `forall_swap`."
  theorem: "{α : Type u_1} {p : Prop} {q : α → Prop} : p → ∀ (x : α), q x ↔ ∀ (x : α), p → q x"

- doc_string: "The closure of the interval `[a, b)` is the closed interval `[a, b]`."
  theorem: "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ico a b) = set.Icc a b"

- doc_string: "The frontier of a set is closed."
  theorem: "{α : Type u} [topological_space α] {s : set α} : is_closed (frontier s)"

- doc_string: "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`."
  theorem: "{α : Sort u_1} (P : Prop) [decidable P] (a b : α) : dite P (λ (h : P), a) (λ (h : ¬P), b) = ite P a b"

- doc_string: " If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`."
  theorem: "{α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on f (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))"

- doc_string: "**Alias** of the forward direction of is_max_filter_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_max_filter (⇑order_dual.to_dual ∘ f) l a → is_min_filter f l a"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "Multiplicative congruence relations preserve natural powers."
  theorem: "{M : Type u_1} [monoid M] (c : con M) (n : ℕ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)"

- doc_string: " `finsupp.single a b` is injective in `a`. For the statement that it is injective in `b`, see `finsupp.single_injective`"
  theorem: "{α : Type u_1} {M : Type u_5} [has_zero M] {b : M} (h : b ≠ 0) : function.injective (λ (a : α), finsupp.single a b)"

- doc_string: "Deprecated. Use `fun_like.ext_iff`."
  theorem: "{R : Type u_2} {Γ₀ : Type u_3} [ring R] [linear_ordered_comm_monoid_with_zero Γ₀] {v₁ v₂ : valuation R Γ₀} : v₁ = v₂ ↔ ∀ (r : R), ⇑v₁ r = ⇑v₂ r"

- doc_string: "**Alias** of `left.add_nonpos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0"

- doc_string: "**Alias** of the forward direction of same_ray_neg_iff`."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) → same_ray R x y"

- doc_string: "`∨` distributes over `∧` (on the left)."
  theorem: "{a b c : Prop} : a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)"

- doc_string: "**Alias** of left.mul_lt_one'`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "**Alias** of lt_asymm`."
  theorem: "{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a"

- doc_string: "Commuting elements of finite additive order are closed under addition."
  theorem: "{G : Type u} {y : G} [add_monoid G] {x : G} (h : add_commute x y) (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)"

- doc_string: "**Alias** of dvd_pow`."
  theorem: "{M : Type u} [monoid M] {x y : M} (hxy : x ∣ y) {n : ℕ} (hn : n ≠ 0) : x ∣ y ^ n"

- doc_string: " The minimal distance from `x` to `s` is bounded by the distance from `y` to `s`, modulo the distance between `x` and `y`"
  theorem: "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} : metric.inf_dist x s ≤ metric.inf_dist y s + has_dist.dist x y"

- doc_string: "An element of `R` admitting a left inverse is `M`-regular."
  theorem: "{R : Type u_1} {M : Type u_3} {a b : R} [monoid R] [mul_action R M] (h : a * b = 1) : is_smul_regular M b"

- doc_string: "A module over a division ring is noetherian if and only if it is finitely generated."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] : is_noetherian K V ↔ module.finite K V"

- doc_string: "**Alias** of lt_of_le_of_ne`."
  theorem: "{α : Type u} [partial_order α] {a b : α} : a ≤ b → a ≠ b → a < b"

- doc_string: " If `α` has no zero divisors, then for elements `a, b : α`, `a * b` is nonzero iff so is `b * a`."
  theorem: "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ b * a ≠ 0"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_nonneg_of_pos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b"

- doc_string: "**Alias** of the forward direction of sub_le_iff_le_add'`."
  theorem: "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a - b ≤ c → a ≤ b + c"

- doc_string: "The Hausdorff distance between a set and itself is zero"
  theorem: "{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s s = 0"

- doc_string: " A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` that is greater than `x`. A version for preorders is called `not_bdd_above_iff'`."
  theorem: "{α : Type u_1} [linear_order α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), x < y"

- doc_string: "If matrix A is right invertible, then its inverse equals its right inverse."
  theorem: "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : A.mul B = 1) : A⁻¹ = B"

- doc_string: "The functor Compactum_to_CompHaus is essentially surjective."
  theorem: " : category_theory.ess_surj Compactum_to_CompHaus"

- doc_string: "The 1 of the quotient of a monoid by a congruence relation is the equivalence class of the    monoid's 1."
  theorem: "{M : Type u_1} [mul_one_class M] {c : con M} : ↑1 = 1"

- doc_string: "The element `0` is regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] (h : is_regular 0) : subsingleton R"

- doc_string: "**Alias** of left.inv_lt_one_iff`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a"

- doc_string: "**Alias** of left.mul_lt_one_of_lt_of_le`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1"

- doc_string: "`cut_expand r` is well-founded when `r` is."
  theorem: "{α : Type u_1} {r : α → α → Prop} (hr : well_founded r) : well_founded (relation.cut_expand r)"

- doc_string: "A group homomorphism is injective iff its kernel is trivial."
  theorem: "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1"

- doc_string: "The multiplicity of `a` as root of `(X - a) ^ n` is `n`."
  theorem: "{R : Type u} [comm_ring R] [is_domain R] (a : R) (n : ℕ) : polynomial.root_multiplicity a ((polynomial.X - ⇑polynomial.C a) ^ n) = n"

- doc_string: " The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞)"
  theorem: "{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist s ∅ = 0"

- doc_string: "For the single implications with fewer assumptions, see `one_div_le_one_div_of_le` and  `le_of_one_div_le_one_div`"
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a ≤ 1 / b ↔ b ≤ a"

- doc_string: "In a finite field of characteristic `2`, all elements are squares."
  theorem: "{F : Type u_3} [field F] [fintype F] (hF : ring_char F = 2) (a : F) : is_square a"

- doc_string: "The set of Liouville numbers has Lebesgue measure zero."
  theorem: " : ⇑measure_theory.measure_space.volume {x : ℝ | liouville x} = 0"

- doc_string: "The submonoid generated by a set is contained in any submonoid that contains the set."
  theorem: "{M : Type u_1} [monoid M] {s t : set M} (ht : is_submonoid t) (h : s ⊆ t) : monoid.closure s ⊆ t"

- doc_string: "**Alias** of int.abs_le_self_sq`."
  theorem: "(a : ℤ) : ↑(a.nat_abs) ≤ a ^ 2"

- doc_string: "A list with product greater than one must have positive length."
  theorem: "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : 1 < L.prod) : 0 < L.length"

- doc_string: "**Alias** of left.mul_lt_one_of_le_of_lt`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1"

- doc_string: "If an element a divides another element b in a commutative ring, a divides the sum of b and  another element c iff a divides c."
  theorem: "{α : Type u} [non_unital_ring α] {a b c : α} (h : a ∣ b) : a ∣ b + c ↔ a ∣ c"

- doc_string: "A map to a group preserving multiplication is a monoid homomorphism."
  theorem: "{α : Type u} {β : Type v} [mul_one_class α] [group β] {f : α → β} (hf : is_mul_hom f) : is_monoid_hom f"

- doc_string: "**Alias** of the reverse direction of inv_mul_lt_iff_lt_mul`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → -b + a < c"

- doc_string: "The sequence `dense_seq α` has dense range."
  theorem: "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : dense_range (topological_space.dense_seq α)"

- doc_string: "The minimal distance to a set (as `ℝ≥0`) is Lipschitz in point with constant 1"
  theorem: "{α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_nndist x s)"

- doc_string: "A list with product not one must have positive length."
  theorem: "{M : Type u_3} [monoid M] (L : list M) (h : L.prod ≠ 1) : 0 < L.length"

- doc_string: "A compact Hausdorff space is totally disconnected if and only if it is totally separated, this  is also true for locally compact spaces."
  theorem: "{α : Type u} [topological_space α] [t2_space α] [compact_space α] : totally_disconnected_space α ↔ totally_separated_space α"

- doc_string: "Comparison test of convergence of `ℝ≥0`-valued series."
  theorem: "{β : Type u_2} {f g : β → nnreal} (hgf : ∀ (b : β), g b ≤ f b) : summable f → summable g"

- doc_string: " Every element is less than its closure. This property is sometimes referred to as extensivity or inflationarity."
  theorem: "{α : Type u_1} [partial_order α] (c : closure_operator α) (x : α) : x ≤ ⇑c x"

- doc_string: "**Alias** of set.inj_on_of_injective`."
  theorem: "{α : Type u} {β : Type v} {f : α → β} (h : function.injective f) (s : set α) : set.inj_on f s"

- doc_string: "Transposing a matrix preserves the determinant."
  theorem: "{n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : M.transpose.det = M.det"

- doc_string: "See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption."
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b⁻¹ ↔ b < a"

- doc_string: "Equivalence closure of binary relations is monotone."
  theorem: "{α : Type u_1} {r s : α → α → Prop} (h : ∀ (x y : α), r x y → s x y) : eqv_gen.setoid r ≤ eqv_gen.setoid s"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one_of_lt_of_le`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1"

- doc_string: "Alias of `nat.mul_div_mul`"
  theorem: "(a b : ℕ) {c : ℕ} (hc : 0 < c) : c * a / (c * b) = a / b"

- doc_string: "The first projection in a product is a topological fiber bundle."
  theorem: "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.fst"

- doc_string: "A semiring is `nontrivial` provided that there exists a nontrivial module over this semiring."
  theorem: "(R : Type u_1) (M : Type u_2) [semiring R] [nontrivial M] [add_comm_monoid M] [module R M] : nontrivial R"

- doc_string: " **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`."
  theorem: "{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_le_one`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1"

- doc_string: " Predicate asserting that word `w₁` can be reduced to `w₂` in one step, i.e. there are words `w₃ w₄` and letter `x` such that `w₁ = w₃xx⁻¹w₄` and `w₂ = w₃w₄`"
  theorem: "{α : Type u} {L₁ L₂ : list (α × bool)} : free_group.red.step L₁ L₂ → L₂.length + 2 = L₁.length"

- doc_string: "The quadratic character is `1` or `-1` on nonzero arguments."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1 ∨ char.quadratic_char F a = -1"

- doc_string: "  An element is left-regular if and only if multiplying it on the left by a left-regular element is left-regular."
  theorem: "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_left_regular a) : is_left_regular (a * b) ↔ is_left_regular b"

- doc_string: "**Alias** of the reverse direction of le_inv_mul_iff_mul_le`."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a * b ≤ c → b ≤ a⁻¹ * c"

- doc_string: " **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm."
  theorem: "(x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y"

- doc_string: "if `-a ≤ b` then `-b ≤ a` on `ereal`."
  theorem: "{a b : ereal} (h : -a ≤ b) : -b ≤ a"

- doc_string: "In a sequential space, a set is closed iff it's sequentially closed."
  theorem: "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s ↔ is_closed s"

- doc_string: "Sophie Germain's identity, see <https://www.cut-the-knot.org/blue/SophieGermainIdentity.shtml>."
  theorem: "{R : Type u_1} [comm_ring R] {a b : R} : a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 ≤ a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b"

- doc_string: "For rewriting in the reverse direction, see `fin.cast_nat_add_right`."
  theorem: "{n n' : ℕ} (m : ℕ) (i : fin n') (h : n' = n) : ⇑(fin.nat_add m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.nat_add m) i)"

- doc_string: "A sequential limit of measurable `ℝ≥0` valued functions is measurable."
  theorem: "{α : Type u_1} [measurable_space α] {f : ℕ → α → nnreal} {g : α → nnreal} (hf : ∀ (i : ℕ), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 < a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 < a * b"

- doc_string: "Composition by an surjective function on the left is itself surjective."
  theorem: "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.surjective g) : function.surjective (function.comp g)"

- doc_string: " If `α` has no zero divisors, then the product of two elements is nonzero iff both of them are nonzero."
  theorem: "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one'`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "  If an element `b` becomes left-regular after multiplying it on the left by a left-regular element, then `b` is left-regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (ab : is_left_regular (a * b)) : is_left_regular b"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1"

- doc_string: "The minimal distance to a set is Lipschitz in point with constant 1"
  theorem: "{α : Type u} [pseudo_metric_space α] (s : set α) : lipschitz_with 1 (λ (x : α), metric.inf_dist x s)"

- doc_string: "Finite groups are torsion groups."
  theorem: "{G : Type u_1} [group G] [fintype G] : monoid.is_torsion G"

- doc_string: "Any infinite type can be endowed a field structure."
  theorem: "{α : Type u} [infinite α] : nonempty (field α)"

- doc_string: "**Alias** of left.inv_lt_one_iff`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_pos_of_pos_of_nonneg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b"

- doc_string: "**Alias** of lt_of_lt_of_eq'`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : b < c → a = b → a < c"

- doc_string: "If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`."
  theorem: "{α : Type u} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) : f x = x"

- doc_string: "The inverse of the golden ratio is the opposite of its conjugate."
  theorem: " : golden_ratio⁻¹ = -golden_conj"

- doc_string: " Multiplying `a` by itself and then dividing by itself results in `a` (whether or not `a` is zero)."
  theorem: "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a * a / a = a"

- doc_string: "If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`."
  theorem: "{α : Type u_1} [monoid α] {p q : α} (hp : irreducible p) (hq : irreducible q) : p ∣ q → q ∣ p"

- doc_string: "A finite group of prime order is cyclic."
  theorem: "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α"

- doc_string: " An element of a `cancel_monoid_with_zero` fixed by right multiplication by an element other than one must be zero."
  theorem: "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : a * b = a) : a = 0"

- doc_string: "Affine subspaces are convex."
  theorem: "{𝕜 : Type u_1} {E : Type u_2} [ordered_ring 𝕜] [add_comm_group E] [module 𝕜 E] (Q : affine_subspace 𝕜 E) : convex 𝕜 ↑Q"

- doc_string: "If `a` and `b` are equal mod `c`, `a - b` is zero mod `c`."
  theorem: "{a b c : ℕ} (h : a % c = b % c) : (a - b) % c = 0"

- doc_string: "Two `v w : vector α n` are equal iff they are equal at every single index."
  theorem: "{n : ℕ} {α : Type u_1} {v w : vector α n} (h : ∀ (m : fin n), v.nth m = w.nth m) : v = w"

- doc_string: "When multiplication is commutative, `star` preserves division."
  theorem: "{R : Type u} [field R] [star_ring R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y"

- doc_string: "The definition of `centroid_weights_indicator`."
  theorem: "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) : finset.centroid_weights_indicator k s = ↑s.indicator (finset.centroid_weights k s)"

- doc_string: " If `h : a ∈ {x | p x}` then `h.out : p x`. These are definitionally equal, but this can nevertheless be useful for various reasons, e.g. to apply further projection notation or in an argument to `simp`."
  theorem: "{α : Type u} {p : α → Prop} {a : α} (h : a ∈ {x : α | p x}) : p a"

- doc_string: "Updating the first element of a tuple does not change the tail."
  theorem: "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α 0) : fin.tail (function.update q 0 z) = fin.tail q"

- doc_string: "The shadow is monotone."
  theorem: "{α : Type u_1} [decidable_eq α] : monotone finset.shadow"

- doc_string: " When `R` is commutative and permits an `algebra_map`, `pi.const_ring_hom` is equal to that map."
  theorem: "(R : Type u_1) (A : Type u_2) [comm_semiring R] : pi.const_ring_hom A R = algebra_map R (A → R)"

- doc_string: "Euler's product formula for the totient function."
  theorem: "(n : ℕ) : ↑(n.totient) = ↑n * n.factors.to_finset.prod (λ (p : ℕ), 1 - (↑p)⁻¹)"

- doc_string: " If `α` is a preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α` with any prescribed value of `f 0`."
  theorem: "{α : Type u} [preorder α] [no_max_order α] (a : α) : ∃ (f : ℕ → α), strict_mono f ∧ f 0 = a"

- doc_string: "The function `(c,d) → |cz+d|^2` is proper, that is, preimages of bounded-above sets are finite."
  theorem: "(z : upper_half_plane) : filter.tendsto (λ (p : fin 2 → ℤ), ⇑complex.norm_sq (↑(p 0) * ↑z + ↑(p 1))) filter.cofinite filter.at_top"

- doc_string: "**Alias** of eq_of_le_of_not_lt`."
  theorem: "{α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : a = b"

- doc_string: "**Alias** of the forward direction of set.inj_on_iff_injective`."
  theorem: "{α : Type u} {β : Type v} {s : set α} {f : α → β} : set.inj_on f s → function.injective (s.restrict f)"

- doc_string: "Extensionality for `poly α`"
  theorem: "{α : Type u_1} {f g : poly α} : (∀ (x : α → ℕ), ⇑f x = ⇑g x) → f = g"

- doc_string: "A natural number `m` divides the sum `m + n` if and only if `m` divides `n`."
  theorem: "{m n : ℕ} : m ∣ m + n ↔ m ∣ n"

- doc_string: "An element admitting a left inverse is left-regular."
  theorem: "{R : Type u_1} {a b : R} [monoid R] (h : b * a = 1) : is_left_regular a"

- doc_string: "**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`."
  theorem: "(p : ℕ) [fact (nat.prime p)] : ↑((p - 1).factorial) = -1"

- doc_string: "**Alias** of the forward direction of is_min_on_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_min_on (⇑order_dual.to_dual ∘ f) s a → is_max_on f s a"

- doc_string: " Multiplication on the right by a nonzero element of a normed division ring tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`."
  theorem: "{α : Type u_1} [normed_division_ring α] {a : α} (ha : a ≠ 0) : filter.tendsto (λ (x : α), x * a) (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"

- doc_string: "A unit in a monoid is regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] (ua : is_unit a) : is_regular a"

- doc_string: " Given an inducing map of a topological space into a pseudo metrizable space, the source space is also pseudo metrizable."
  theorem: "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.pseudo_metrizable_space Y] {f : X → Y} (hf : inducing f) : topological_space.pseudo_metrizable_space X"

- doc_string: "**Alias** of quaternion.commute_conj_conj`."
  theorem: "{R : Type u_1} [comm_ring R] {a b : quaternion R} (h : commute a b) : commute (⇑quaternion.conj a) (⇑quaternion.conj b)"

- doc_string: "A nontrivial torsion group is not torsion-free."
  theorem: "{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G"

- doc_string: "Note: `sym2.map_id` will not simplify `sym2.map id z` due to `sym2.map_congr`."
  theorem: "{α : Type u_1} : sym2.map (λ (x : α), x) = id"

- doc_string: "The element `0` is left-regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] : is_left_regular 0 ↔ subsingleton R"

- doc_string: "Colex is an extension of the base ordering on α."
  theorem: "{α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex ≤ {s}.to_colex ↔ r ≤ s"

- doc_string: "An additive group homomorphism sends negations to negations."
  theorem: "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) (a : α) : f (-a) = -f a"

- doc_string: "`part` eta expansion"
  theorem: "{α : Type u_1} (o : part α) : {dom := o.dom, get := λ (h : o.dom), o.get h} = o"

- doc_string: "See `add_tsub_cancel_left` for the equality if `contravariant_class α α (+) (≤)`."
  theorem: "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - a ≤ b"

- doc_string: "Uses `left` co(ntra)variant."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1"

- doc_string: "If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra."
  theorem: " : ring_hom.localization_preserves ring_hom.finite"

- doc_string: " If words `w₁ w₂` are such that `w₁` reduces to `w₂`, then `w₂` reduces to the maximal reduction of `w₁`."
  theorem: "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.red L₂ (free_group.reduce L₁)"

- doc_string: "**Alias** of mul_lt_mul_left'`."
  theorem: "{α : Type u_1} [has_add α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {b c : α} (bc : b < c) (a : α) : a + b < a + c"

- doc_string: " If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the Hausdorff dimension of its domain."
  theorem: "{X : Type u_2} {Y : Type u_3} [emetric_space X] [emetric_space Y] {K : nnreal} {f : X → Y} (h : lipschitz_with K f) : dimH (set.range f) ≤ dimH set.univ"

- doc_string: "Composing two additions on the right by `y` and `x` is equal to a addition on the right by `y + x`."
  theorem: "{α : Type u_1} [add_semigroup α] (x y : α) : ((λ (_x : α), _x + x) ∘ λ (_x : α), _x + y) = λ (_x : α), _x + (y + x)"

- doc_string: "The first projection in a product is a trivial topological fiber bundle."
  theorem: "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.fst"

- doc_string: "A field extension is integral if it is finite."
  theorem: "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite_dimensional K L] : algebra.is_integral K L"

- doc_string: "The identity affine map acts as the identity."
  theorem: "(k : Type u_1) {V1 : Type u_2} {P1 : Type u_3} [ring k] [add_comm_group V1] [module k V1] [add_torsor V1 P1] (p : P1) : ⇑(affine_map.id k P1) p = p"

- doc_string: "As a map from the right argument to a unary function, `f` is injective."
  theorem: "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty α] : function.injective (λ (b : β) (a : α), f a b)"

- doc_string: "`zero_locus` and `vanishing_ideal` form a galois connection."
  theorem: "(R : Type u) [comm_ring R] : galois_connection (λ (s : set R), prime_spectrum.zero_locus s) (λ (t : (set (prime_spectrum R))ᵒᵈ), ↑(prime_spectrum.vanishing_ideal t))"

- doc_string: " A version of `antisymm'` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there."
  theorem: "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → b = a"

- doc_string: " A series of non-negative real numbers converges to `r` in the sense of `has_sum` if and only if the sequence of partial sum converges to `r`."
  theorem: "{f : ℕ → nnreal} {r : nnreal} : has_sum f r ↔ filter.tendsto (λ (n : ℕ), (finset.range n).sum (λ (i : ℕ), f i)) filter.at_top (nhds r)"

- doc_string: "Congruence lemma for constructing `ex.exp`."
  theorem: "{α : Type u} [comm_semiring α] {p p' : α} {ps ps' : ℕ} : p = p' → ps = ps' → p ^ ps = p' ^ ps'"

- doc_string: "The number of square roots of `a` modulo `p` is determined by the Legendre symbol."
  theorem: "(p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) (a : ℤ) : ↑({x : zmod p | x ^ 2 = ↑a}.to_finset.card) = zmod.legendre_sym p a + 1"

- doc_string: "A version of `le_refl` where the argument is implicit"
  theorem: "{α : Type u} [preorder α] {a : α} : a ≤ a"

- doc_string: "If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`."
  theorem: "(P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L ≤ fintype.card P"

- doc_string: " The fixed point lemma for normal functions: any normal function has an unbounded set of fixed points."
  theorem: "{f : ordinal → ordinal} (H : ordinal.is_normal f) : set.unbounded has_lt.lt (function.fixed_points f)"

- doc_string: " The edist of `x` to `s` is bounded by the sum of the edist of `y` to `s` and the edist from `x` to `y`"
  theorem: "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} : emetric.inf_edist x s ≤ emetric.inf_edist y s + has_edist.edist x y"

- doc_string: "Additive congruence relations preserve negation."
  theorem: "{M : Type u_1} [add_group M] (c : add_con M) {w x : M} : ⇑c w x → ⇑c (-w) (-x)"

- doc_string: "Any power of a right-regular element is right-regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] (n : ℕ) (rra : is_right_regular a) : is_right_regular (a ^ n)"

- doc_string: "An isometry from an emetric space is injective"
  theorem: "{β : Type v} [pseudo_emetric_space β] {α : Type u} [emetric_space α] {f : α → β} (h : isometry f) : function.injective f"

- doc_string: "In the model space, chart_at is always the identity"
  theorem: "{H : Type u_1} [topological_space H] {x : H} : charted_space.chart_at H x = local_homeomorph.refl H"

- doc_string: "An element admitting a left additive opposite is add-left-regular."
  theorem: "{R : Type u_1} {a b : R} [add_monoid R] (h : b + a = 0) : is_add_left_regular a"

- doc_string: "If `s` has a least element, then it is bounded below."
  theorem: "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_least s a) : bdd_below s"

- doc_string: "The canonical perfection map from the perfection of a ring."
  theorem: "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] : perfection_map p (perfection.coeff R p 0)"

- doc_string: "A subobject is simple iff it is an atom in the subobject lattice."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (Y : category_theory.subobject X) : category_theory.simple ↑Y ↔ is_atom Y"

- doc_string: "A version of `zero_lt_one : 0 < 1` for a `canonically_ordered_comm_semiring`."
  theorem: "{α : Type u} [canonically_ordered_comm_semiring α] [nontrivial α] : 0 < 1"

- doc_string: "**Alias** of the reverse direction of sub_eq_zero`."
  theorem: "{G : Type u_2} [add_group G] {a b : G} : a = b → a - b = 0"

- doc_string: "`sinh` is bijective, both injective and surjective."
  theorem: " : function.bijective real.sinh"

- doc_string: "Euler's Criterion: a nonzero `a : zmod p` is a square if and only if `x ^ (p / 2) = 1`."
  theorem: "(p : ℕ) [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : is_square a ↔ a ^ (p / 2) = 1"

- doc_string: "Adding a point to a set preserves its boundedness above."
  theorem: "{γ : Type w} [semilattice_sup γ] (a : γ) {s : set γ} : bdd_above (has_insert.insert a s) ↔ bdd_above s"

- doc_string: "**Alias** of neg_one_sq`."
  theorem: "{R : Type u₁} [monoid R] [has_distrib_neg R] : (-1) ^ 2 = 1"

- doc_string: "**Alias** of lt_of_le_of_lt'`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : b ≤ c → a < b → a < c"

- doc_string: "Any category with pullbacks and terminal object has binary products."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_pullbacks C] : category_theory.limits.has_binary_products C"

- doc_string: "If `s` is bounded, then so is `s ∩ t`"
  theorem: "{α : Type u} [preorder α] {s t : set α} (h : bdd_above s) : bdd_above (s ∩ t)"

- doc_string: "Entourages are neighborhoods of the diagonal."
  theorem: "{α : Type u_1} [uniform_space α] (x : α) : nhds (x, x) ≤ uniformity α"

- doc_string: "`padic_val_int p 1` is 0 for any `p`."
  theorem: "{p : ℕ} : padic_val_int p 1 = 0"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one_of_lt_of_le`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a < 1) (hb : b ≤ 1) : a * b < 1"

- doc_string: "The directed sUnion of a set S of preconnected subsets is preconnected."
  theorem: "{α : Type u} [topological_space α] {S : set (set α)} (K : directed_on has_subset.subset S) (H : ∀ (s : set α), s ∈ S → is_preconnected s) : is_preconnected (⋃₀S)"

- doc_string: "**Alias** of the reverse direction of order.pred_eq_iff_is_min`."
  theorem: "{α : Type u_1} [partial_order α] [pred_order α] {a : α} : is_min a → order.pred a = a"

- doc_string: "Iff version of extensionality rule for additive congruence relations."
  theorem: "{M : Type u_1} [has_add M] {c d : add_con M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d"

- doc_string: " If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined."
  theorem: "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂"

- doc_string: " The extended psuedodistance on a subset of a pseudoemetric space is the restriction of the original pseudodistance, by definition"
  theorem: "{α : Type u} [pseudo_emetric_space α] {p : α → Prop} (x y : subtype p) : has_edist.edist x y = has_edist.edist ↑x ↑y"

- doc_string: "The closure of the interval `(a, b]` is the closed interval `[a, b]`."
  theorem: "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioc a b) = set.Icc a b"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b"

- doc_string: "The diameter of a set is always nonnegative"
  theorem: "{α : Type u} [pseudo_metric_space α] {s : set α} : 0 ≤ metric.diam s"

- doc_string: "If a subgroup of an additive topological group has `0` in its interior, then it is open."
  theorem: "{G : Type u_1} [add_group G] [topological_space G] [topological_add_group G] {H : add_subgroup G} (h_1_int : 0 ∈ interior ↑H) : is_open ↑H"

- doc_string: "When multiplication is commutative, `star` preserves division."
  theorem: "{R : Type u} [comm_group R] [star_semigroup R] (x y : R) : has_star.star (x / y) = has_star.star x / has_star.star y"

- doc_string: "The element `0` is `M`-regular when `M` is trivial."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [sM : subsingleton M] : is_smul_regular M 0"

- doc_string: "The second projection in a product is a trivial topological fiber bundle."
  theorem: "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_trivial_topological_fiber_bundle F prod.snd"

- doc_string: "The exponential characteristic is one if the characteristic is zero."
  theorem: "(R : Type u) [semiring R] [nontrivial R] (p : ℕ) [hp : char_p R p] [hq : exp_char R 1] : p = 0"

- doc_string: "1 is in the set of natural number powers of an element of a monoid."
  theorem: "{M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x"

- doc_string: "**Alias** of le_trans'`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : b ≤ c → a ≤ b → a ≤ c"

- doc_string: "If there are zero morphisms, any initial object is a zero object."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_initial C] : category_theory.limits.has_zero_object C"

- doc_string: " If `τ` is a `canonically_ordered_add_monoid` (e.g., `ℕ` or `ℝ≥0`), then the notions `is_fw_invariant` and `is_invariant` are equivalent."
  theorem: "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} : is_fw_invariant ϕ s ↔ is_invariant ϕ s"

- doc_string: "The Hausdorff edistance of a set to itself vanishes"
  theorem: "{α : Type u} [pseudo_emetric_space α] {s : set α} : emetric.Hausdorff_edist s s = 0"

- doc_string: " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`."
  theorem: "(n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p"

- doc_string: "Prefer `neg_zero` if `subtraction_monoid` is available."
  theorem: "{α : Type u} [mul_zero_class α] [has_distrib_neg α] : -0 = 0"

- doc_string: "Any element commutes with itself."
  theorem: "{S : Type u_1} [has_add S] (a : S) : add_commute a a"

- doc_string: "The image of a monoid hom is a submonoid of the codomain."
  theorem: "{M : Type u_1} [monoid M] {γ : Type u_2} [monoid γ] {f : M → γ} (hf : is_monoid_hom f) : is_submonoid (set.range f)"

- doc_string: "**Alias** of the forward direction of le_inv_mul_iff_mul_le`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ -a + c → a + b ≤ c"

- doc_string: "The `0` element is not `M`-regular, on a non-trivial module."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] [nM : nontrivial M] : ¬is_smul_regular M 0"

- doc_string: "If any two objects in an nonempty category are related by `zigzag`, the category is connected."
  theorem: "{J : Type u₁} [category_theory.category J] [nonempty J] (h : ∀ (j₁ j₂ : J), category_theory.zigzag j₁ j₂) : category_theory.is_connected J"

- doc_string: "The characteristic of a finite ring cannot be zero."
  theorem: "(R : Type u) [non_assoc_ring R] (p : ℕ) [hc : char_p R p] [fintype R] : p ≠ 0"

- doc_string: "See `int.induction_on'` for an induction in both directions."
  theorem: "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), n ≤ m → P n → P (n - 1)) (n : ℤ) : n ≤ m → P n"

- doc_string: "`zpow b` and `int.log b` (almost) form a Galois connection."
  theorem: "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r < ↑b ^ x ↔ int.log b r < x"

- doc_string: " Given a Borel-measurable set in a Polish space, there exists a finer Polish topology making it clopen. This is in fact an equivalence, see `is_clopenable_iff_measurable_set`."
  theorem: "{α : Type u_1} [topological_space α] [polish_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) : polish_space.is_clopenable s"

- doc_string: "Contrapositive form of `nat.factorization_central_binom_eq_zero_of_two_mul_lt`"
  theorem: "{p n : ℕ} (h_pos : 0 < ⇑(n.central_binom.factorization) p) : p ≤ 2 * n"

- doc_string: "A p-group is nilpotent"
  theorem: "{G : Type u_1} [hG : group G] [hf : fintype G] {p : ℕ} [hp : fact (nat.prime p)] (h : is_p_group p G) : group.is_nilpotent G"

- doc_string: "A unit is `M`-regular."
  theorem: "{R : Type u_1} (M : Type u_3) {a : R} [monoid R] [mul_action R M] (ua : is_unit a) : is_smul_regular M a"

- doc_string: "Given a map f from α to β, the natural map from the quotient of α by the kernel of f is    injective."
  theorem: "{α : Type u_1} {β : Type u_2} (f : α → β) : function.injective (quotient.lift f _)"

- doc_string: "Relation `λ f g, tendsto (λ x, (f x, g x)) l (𝓤 α)` is reflexive."
  theorem: "{α : Type u_1} {β : Type u_2} [uniform_space α] (f : β → α) (l : filter β) : filter.tendsto (λ (x : β), (f x, f x)) l (uniformity α)"

- doc_string: "If presheaf of `J₁`-closed sieves is a `J₂`-sheaf then `J₁ ≤ J₂`. Note the converse is true by `classifier_is_sheaf` and `is_sheaf_of_le`."
  theorem: "{C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₂)) : J₁ ≤ J₂"

- doc_string: "Cyclotomic polynomials are always nonnegative on inputs one or more."
  theorem: "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 ≤ x) : 0 ≤ polynomial.eval x (polynomial.cyclotomic n R)"

- doc_string: "The edistance to a closed set depends continuously on the point and the set"
  theorem: "{α : Type u} [emetric_space α] : continuous (λ (p : α × topological_space.closeds α), emetric.inf_edist p.fst ↑(p.snd))"

- doc_string: "A list with product less than one must have positive length."
  theorem: "{M : Type u_3} [monoid M] [preorder M] (L : list M) (h : L.prod < 1) : 0 < L.length"

- doc_string: "The union of two Gδ sets is a Gδ set."
  theorem: "{α : Type u_1} [topological_space α] {s t : set α} (hs : is_Gδ s) (ht : is_Gδ t) : is_Gδ (s ∪ t)"

- doc_string: "Harmonic series is not unconditionally summable."
  theorem: " : ¬summable (λ (n : ℕ), 1 / ↑n)"

- doc_string: "**Alias** of eq_or_gt_of_le`."
  theorem: "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : b = a ∨ a < b"

- doc_string: "A subset of `ℕ` containing zero and closed under `nat.succ` contains all of `ℕ`."
  theorem: "{S : set ℕ} (hb : 0 ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S"

- doc_string: "**Alias** of the reverse direction of inv_mul_le_iff_le_mul`."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : a ≤ b * c → b⁻¹ * a ≤ c"

- doc_string: "Characteristic `≠ 2` in a domain implies that `-a = a` iff `a = 0`."
  theorem: "{R : Type u_1} [non_assoc_ring R] [nontrivial R] [no_zero_divisors R] (hR : ring_char R ≠ 2) {a : R} : -a = a ↔ a = 0"

- doc_string: "The quadratic character takes the value `1` on nonzero squares."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F (a ^ 2) = 1"

- doc_string: "The edist to a set depends continuously on the point"
  theorem: "{α : Type u} [pseudo_emetric_space α] {s : set α} : continuous (λ (x : α), emetric.inf_edist x s)"

- doc_string: "**Alias** of the forward direction of mul_sub_mul_div_mul_nonpos_iff`."
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) ≤ 0 → a / c ≤ b / d"

- doc_string: "the coercion `opens α → set α` applied to a pair is the same as taking the first component"
  theorem: "{α : Type u_1} [topological_space α] {U : set α} {hU : is_open U} : ↑⟨U, hU⟩ = U"

- doc_string: " Converting the value of a `fin (n + 1)` to `fin (n + 1)` results in the same value."
  theorem: "{n : ℕ} (a : fin (n + 1)) : ↑(a.val) = a"

- doc_string: "The projection on the base of a topological bundle created from core is an open map"
  theorem: "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : is_open_map Z.proj"

- doc_string: "An element of `R` is algebraic, when viewed as an element of the `R`-algebra `A`."
  theorem: "{R : Type u} {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] (x : R) : is_algebraic R (⇑(algebra_map R A) x)"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "Composing two additions on the left by `y` then `x` is equal to a addition on the left by `x + y`."
  theorem: "{α : Type u_1} [add_semigroup α] (x y : α) : has_add.add x ∘ has_add.add y = has_add.add (x + y)"

- doc_string: "A subset of `ℕ` containing `b : ℕ` and closed under `nat.succ` contains every `n ≥ b`."
  theorem: "{b : ℕ} {S : set ℕ} (hb : b ∈ S) (h_ind : ∀ (k : ℕ), k ∈ S → k + 1 ∈ S) {n : ℕ} (hbn : b ≤ n) : n ∈ S"

- doc_string: "**Alias** of the reverse direction of szemeredi_regularity.step_bound_pos_iff`."
  theorem: "{n : ℕ} : 0 < n → 0 < szemeredi_regularity.step_bound n"

- doc_string: "An element of an `add_monoid` is in the set of that element's natural number multiples."
  theorem: "{M : Type u_1} [add_monoid M] {x : M} : x ∈ multiples x"

- doc_string: "`complex.abs (complex.exp z) → ∞` as `complex.re z → ∞`. TODO: use `bornology.cobounded`."
  theorem: " : filter.tendsto complex.exp (filter.comap complex.re filter.at_top) (filter.comap complex.abs filter.at_top)"

- doc_string: "The map `coe_fn : (r ↪r s) → (α → β)` is injective."
  theorem: "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn"

- doc_string: "Any category with finite coproducts and coequalizers has all finite colimits.  See <https://stacks.math.columbia.edu/tag/002Q>."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_finite_colimits C"

- doc_string: "A group element has finite additive order iff its order is positive."
  theorem: "{G : Type u} {x : G} [add_monoid G] : 0 < add_order_of x ↔ is_of_fin_add_order x"

- doc_string: "This is not a simp lemma, since we usually want simp to keep `star_ring_end` bundled. For example, for complex conjugation, we don't want simp to turn `conj x` into the bare function `star x` automatically since most lemmas are about `conj x`."
  theorem: "{R : Type u} [comm_semiring R] [star_ring R] {x : R} : ⇑(star_ring_end R) x = has_star.star x"

- doc_string: "Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous."
  theorem: "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] : continuous (λ (g : G × G), g.fst * g.snd * (g.fst)⁻¹)"

- doc_string: "Constant zero function has sum `0`"
  theorem: "{α : Type u_1} {β : Type u_2} [add_comm_monoid α] [topological_space α] : has_sum (λ (b : β), 0) 0"

- doc_string: "Given a closed embedding into a Polish space, the source space is also Polish."
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [polish_space β] {f : α → β} (hf : closed_embedding f) : polish_space α"

- doc_string: " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists."
  theorem: "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : ∃ (a : Γ) (l' : turing.list_blank Γ), l = turing.list_blank.cons a l'"

- doc_string: "Show that an element extracted from `P : ∃ a, p a` using `P.some` satisfies `p`."
  theorem: "{α : Sort u_1} {p : α → Prop} (P : ∃ (a : α), p a) : p P.some"

- doc_string: "Compressing an element is idempotent."
  theorem: "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u v a : α) : uv.compress u v (uv.compress u v a) = uv.compress u v a"

- doc_string: " If a reflexive relation `r : α → α → Prop` holds over `x y : α`, then it holds whether or not `x ≠ y`."
  theorem: "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} : x ≠ y → r x y ↔ r x y"

- doc_string: "The upper central series of a group is an ascending central series."
  theorem: "(G : Type u_1) [group G] : is_ascending_central_series (upper_central_series G)"

- doc_string: "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
  theorem: "{p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2"

- doc_string: " The elements of the Hilbert basis `fourier_series` for `Lp ℂ 2 haar_circle` are the functions `fourier_Lp 2`, the monomials `λ z, z ^ n` on the circle considered as elements of `L2`."
  theorem: " : ⇑fourier_series = fourier_Lp 2"

- doc_string: "Composing a `list.map` with another `list.map` is equal to a single `list.map` of composed functions."
  theorem: "{α : Type u} {β : Type v} {γ : Type w} (g : β → γ) (f : α → β) : list.map g ∘ list.map f = list.map (g ∘ f)"

- doc_string: "In a non-trivial `mul_zero_class`, the `0` element is not right-regular."
  theorem: "{R : Type u_1} [mul_zero_class R] : ¬is_right_regular 0 ↔ nontrivial R"

- doc_string: "The minimal distance to a set is bounded by the distance to any point in this set"
  theorem: "{α : Type u} [pseudo_metric_space α] {s : set α} {x y : α} (h : y ∈ s) : metric.inf_dist x s ≤ has_dist.dist x y"

- doc_string: "A `finset` for an empty type is empty."
  theorem: "{α : Type u_1} [is_empty α] (s : finset α) : s = ∅"

- doc_string: "An open subgroup of a nonarchimedean ring contains the square of another one."
  theorem: "{R : Type u_1} [ring R] [topological_space R] [nonarchimedean_ring R] (U : open_add_subgroup R) : ∃ (V : open_add_subgroup R), ↑V * ↑V ⊆ ↑U"

- doc_string: "**Alias** of the reverse direction of is_top_to_dual_iff`."
  theorem: "{α : Type u_1} [has_le α] {a : α} : is_bot a → is_top (⇑order_dual.to_dual a)"

- doc_string: "If `s` has a least upper bound, then it is bounded above."
  theorem: "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_lub s a) : bdd_above s"

- doc_string: "As a map from the left argument to a unary function, `f` is injective."
  theorem: "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) [nonempty β] : function.injective f"

- doc_string: "An unordered closed interval is compact."
  theorem: "{α : Type u_1} [linear_order α] [topological_space α] [compact_Icc_space α] {a b : α} : is_compact (set.interval a b)"

- doc_string: "Definition of `≤` for congruence relations."
  theorem: "{M : Type u_1} [has_mul M] {c d : con M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y"

- doc_string: "The main characterization theorem for additive principal ordinals."
  theorem: "{o : ordinal} : ordinal.principal has_add.add o ↔ o = 0 ∨ ∃ (a : ordinal), o = ordinal.omega ^ a"

- doc_string: "Embedding `i : fin n` into `fin (n + 1)` is always about some hole `p`."
  theorem: "{n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑fin.cast_succ i < p ∨ p < i.succ"

- doc_string: "Shows that the fractional parts of the stream are smaller than one."
  theorem: "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : ifp_n.fr < 1"

- doc_string: "Note that most of the lemmas about powers of two refer to it as `sq`."
  theorem: "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a"

- doc_string: " In the characteristic zero case, the weights in the centroid sum to 1 if the number of points is not zero."
  theorem: "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] (h : s.card ≠ 0) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1"

- doc_string: " A prime that does not divide the cardinality of a finite commutative ring `R` is a unit in `R`."
  theorem: "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] (hp : p ∣ fintype.card R) : ¬is_unit ↑p"

- doc_string: "**Alias** of left.inv_le_one_iff`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 ↔ 0 ≤ a"

- doc_string: "If the factorization of `n` contains just one number `p` then `n` is a power of `p`"
  theorem: "{n p k : ℕ} (hn : n ≠ 0) (h : n.factorization = finsupp.single p k) : n = p ^ k"

- doc_string: "A semiring homomorphism is an additive monoid homomorphism."
  theorem: "{α : Type u} {β : Type v} [semiring α] [semiring β] {f : α → β} (hf : is_semiring_hom f) : is_add_monoid_hom f"

- doc_string: "The edist is antitone with respect to inclusion."
  theorem: "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : s ⊆ t) : emetric.inf_edist x t ≤ emetric.inf_edist x s"

- doc_string: "**Alias** of the reverse direction of finset.Icc_eq_empty_iff`."
  theorem: "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → finset.Icc a b = ∅"

- doc_string: "less-than is well-founded"
  theorem: " : well_founded nat.lt"

- doc_string: "A list with sum not zero must have positive length."
  theorem: "{M : Type u_3} [add_monoid M] (L : list M) (h : L.sum ≠ 0) : 0 < L.length"

- doc_string: "**Alias** of left.one_lt_mul`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "The (pre)image under `inv` of `Ioo 0 a` is `Ioi a⁻¹`."
  theorem: "{k : Type u} [linear_ordered_field k] {a : k} (ha : 0 < a) : (set.Ioo 0 a)⁻¹ = set.Ioi a⁻¹"

- doc_string: "Duplicate of `eq.subset'`, which currently has elaboration problems."
  theorem: "{α : Type u_1} {s t : set α} : s = t → s ⊆ t"

- doc_string: "Characterize the equality of points by the vanishing of their extended distance"
  theorem: "{γ : Type w} [emetric_space γ] {x y : γ} : has_edist.edist x y = 0 ↔ x = y"

- doc_string: "This is a special case of `tsub_zero`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset α)`."
  theorem: "{α : Type u_1} [decidable_eq α] (s : multiset α) : s - 0 = s"

- doc_string: "Transferring from field to is_field"
  theorem: "(R : Type u) [field R] : is_field R"

- doc_string: "Additive congruence relations are symmetric."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) {x y : M} : ⇑c x y → ⇑c y x"

- doc_string: "The nonsingular inverse is the same as the general `ring.inverse`."
  theorem: "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : A⁻¹ = ring.inverse A"

- doc_string: " Every element is less than its closure. This property is sometimes referred to as extensivity or inflationarity."
  theorem: "{α : Type u_1} {β : Type u_4} [preorder α] [preorder β] {u : β → α} (l : lower_adjoint u) (x : α) : x ≤ u (⇑l x)"

- doc_string: "By definition, if `x` is not invertible then `inverse x = 0`."
  theorem: "{M₀ : Type u_1} [monoid_with_zero M₀] (x : M₀) (h : ¬is_unit x) : ring.inverse x = 0"

- doc_string: "A family with at most one point is convex independent."
  theorem: "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] [subsingleton ι] (p : ι → E) : convex_independent 𝕜 p"

- doc_string: "**Alias** of the reverse direction of is_square_iff_exists_sq`."
  theorem: "{α : Type u_2} [monoid α] (m : α) : (∃ (c : α), m = c ^ 2) → is_square m"

- doc_string: "In a preadditive category, if the coproduct over `f : J → C` exists,    then the biproduct over `f` exists."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] {J : Type v} [fintype J] (f : J → C) [category_theory.limits.has_coproduct f] : category_theory.limits.has_biproduct f"

- doc_string: "The opposite of the golden ratio is the inverse of its conjugate."
  theorem: " : golden_conj⁻¹ = -golden_ratio"

- doc_string: " If `α` is a preorder with no maximal elements, then there exists a strictly antitone function `ℕ → α` with any prescribed value of `f 0`."
  theorem: "{α : Type u} [preorder α] [no_min_order α] (a : α) : ∃ (f : ℕ → α), strict_anti f ∧ f 0 = a"

- doc_string: "**Alias** of left.one_lt_inv_iff`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a ↔ a < 0"

- doc_string: "If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism. The converse of `is_subterminal_of_mono_is_terminal_from`."
  theorem: "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) {T : C} (hT : category_theory.limits.is_terminal T) : category_theory.mono (hT.from A)"

- doc_string: "If an element `b` becomes add-right-regular after adding to it on the right a add-right-regular element, then `b` is add-right-regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_right_regular (b + a)) : is_add_right_regular b"

- doc_string: "The inclusion of a fiber into the total space is a continuous map."
  theorem: "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) (b : B) : continuous (bundle.total_space_mk b)"

- doc_string: " If `α` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly monotone function `f : ℤ → α`."
  theorem: "(α : Type u) [preorder α] [nonempty α] [no_min_order α] [no_max_order α] : ∃ (f : ℤ → α), strict_mono f"

- doc_string: "Given `f : α → β`, if `α` is nonempty then `β` is also nonempty.  `nonempty` cannot be a `functor`, because `functor` is restricted to `Type`."
  theorem: "{α : Sort u_1} {β : Sort u_2} (f : α → β) : nonempty α → nonempty β"

- doc_string: "an n-digit number in base b is less than b^n if b ≥ 2"
  theorem: "{b : ℕ} {l : list ℕ} (hb : 2 ≤ b) (hl : ∀ (x : ℕ), x ∈ l → x < b) : nat.of_digits b l < b ^ l.length"

- doc_string: "`a` semiconjugates `x` to `a + x + -a`."
  theorem: "{G : Type u} [add_group G] (a x : G) : add_semiconj_by a x (a + x + -a)"

- doc_string: " The map `coe_fn : (r ≃r s) → (α → β)` is injective. Lean fails to parse `function.injective (λ e : r ≃r s, (e : α → β))`, so we use a trick to say the same."
  theorem: "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn"

- doc_string: "A locally compact Hausdorff space is totally disconnected  if and only if it is totally separated."
  theorem: "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] : totally_disconnected_space H ↔ totally_separated_space H"

- doc_string: " `x` is the only fixed point of `point_reflection x`. This lemma requires `x + x = y + y ↔ x = y`. There is no typeclass to use here, so we add it as an explicit argument."
  theorem: "{G : Type u_1} {P : Type u_2} [add_group G] [add_torsor G P] {x y : P} (h : function.injective bit0) : ⇑(equiv.point_reflection x) y = y ↔ y = x"

- doc_string: "An extensionality lemma in terms of the coercion to a pi-type. We prove this explicitly rather than deriving it so that it is in terms of the coercion rather than the projection `.sieves`."
  theorem: "{C : Type u} [category_theory.category C] {J₁ J₂ : category_theory.grothendieck_topology C} (h : ⇑J₁ = ⇑J₂) : J₁ = J₂"

- doc_string: "A ring homomorphism is also a semiring homomorphism."
  theorem: "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : is_semiring_hom f"

- doc_string: " The metric space uniform structure on ℚ (which presupposes the existence of real numbers) agrees with the one coming directly from (abs : ℚ → ℚ)."
  theorem: " : is_absolute_value.uniform_space has_abs.abs = pseudo_metric_space.to_uniform_space"

- doc_string: "`ordinal.induction` but for `nat_ordinal`."
  theorem: "{p : nat_ordinal → Prop} (i : nat_ordinal) (h : ∀ (j : nat_ordinal), (∀ (k : nat_ordinal), k < j → p k) → p j) : p i"

- doc_string: "Brahmagupta-Fibonacci identity or Diophantus identity, see <https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity>.  This sign choice here corresponds to the signs obtained by multiplying two complex numbers."
  theorem: "{R : Type u_1} [comm_ring R] {x₁ x₂ y₁ y₂ : R} : (x₁ ^ 2 + x₂ ^ 2) * (y₁ ^ 2 + y₂ ^ 2) = (x₁ * y₁ - x₂ * y₂) ^ 2 + (x₁ * y₂ + x₂ * y₁) ^ 2"

- doc_string: " An interval of length `a` filtered over a periodic predicate of period `a` has cardinality equal to the number naturals below `a` for which `p a` is true."
  theorem: "(n a : ℕ) (p : ℕ → Prop) [decidable_pred p] (pp : function.periodic p a) : ⇑multiset.card (multiset.filter p (multiset.Ico n (n + a))) = nat.count p a"

- doc_string: "Composing two multiplications on the right by `y` and `x` is equal to a multiplication on the right by `y * x`."
  theorem: "{α : Type u_1} [semigroup α] (x y : α) : ((λ (_x : α), _x * x) ∘ λ (_x : α), _x * y) = λ (_x : α), _x * (y * x)"

- doc_string: "A finite dimensional space that is a subsingleton has zero `finrank`."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [h : subsingleton V] : finite_dimensional.finrank K V = 0"

- doc_string: "The `nat.partrec.code.evaln` function is primitive recursive."
  theorem: " : primrec (λ (a : (ℕ × nat.partrec.code) × ℕ), nat.partrec.code.evaln a.fst.fst a.fst.snd a.snd)"

- doc_string: " Coercing a `special_linear_group` via `GL_pos` and `GL` is the same as coercing striaght to a matrix."
  theorem: "{n : Type u} [decidable_eq n] [fintype n] {R : Type v} [linear_ordered_comm_ring R] (g : matrix.special_linear_group n R) : ↑↑↑g = ↑g"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_pos'`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "**Alias** of the reverse direction of list.pw_filter_eq_self`."
  theorem: "{α : Type u_1} {R : α → α → Prop} [decidable_rel R] {l : list α} : list.pairwise R l → list.pw_filter R l = l"

- doc_string: "The sequence `A ⟶ A ⊞ B ⟶ B` is exact."
  theorem: "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inl category_theory.limits.biprod.snd"

- doc_string: "The upper shadow is monotone."
  theorem: "{α : Type u_1} [decidable_eq α] [fintype α] : monotone finset.up_shadow"

- doc_string: "The additive inverse of one multiplied by an element of a ring is the element's additive  inverse."
  theorem: "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : (-1) * a = -a"

- doc_string: "Given an element `a` of a commutative semigroup with zero, there exists another element whose    product with zero equals `a` iff `a` equals zero."
  theorem: "{α : Type u_1} [semigroup_with_zero α] {a : α} : 0 ∣ a ↔ a = 0"

- doc_string: "The range of a strongly measurable function is separable."
  theorem: "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] (hf : measure_theory.strongly_measurable f) : topological_space.is_separable (set.range f)"

- doc_string: "**Alias** of the reverse direction of strict_anti_on_to_dual_comp_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_mono_on f s → strict_anti_on (⇑order_dual.to_dual ∘ f) s"

- doc_string: "**Alias** of lt_mul_of_inv_mul_lt`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b"

- doc_string: "**Alias** of not_btw_of_sbtw`."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_btw.btw c b a"

- doc_string: "**Alias** of le_of_mul_le_mul_left'`."
  theorem: "{α : Type u_1} [has_add α] [has_le α] [contravariant_class α α has_add.add has_le.le] {a b c : α} (bc : a + b ≤ a + c) : b ≤ c"

- doc_string: " A word and its maximal reduction correspond to the same element of the free group."
  theorem: "{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.mk (free_group.reduce L) = free_group.mk L"

- doc_string: "A set is sequentially closed if it is closed."
  theorem: "{X : Type u_1} [topological_space X] {s : set X} (hs : is_closed s) : is_seq_closed s"

- doc_string: "This is `algebra.norm_eq_zero_iff` composed with `algebra.norm_apply`."
  theorem: "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ⇑linear_map.det (⇑(algebra.lmul K L) x) = 0 ↔ x = 0"

- doc_string: "`padic_val_nat p 1` is 0 for any `p`."
  theorem: "{p : ℕ} : padic_val_nat p 1 = 0"

- doc_string: "A version of `x.property` or `x.2` where `p` is syntactically applied to the coercion of `x`  instead of `x.1`. A similar result is `subtype.mem` in `data.set.basic`."
  theorem: "{α : Sort u_1} {p : α → Prop} (x : subtype p) : p ↑x"

- doc_string: " For any subset `s` of `α`, the restriction of continuous functions to `s` is continuous as a function from `C(α, β)` to `C(s, β)` with their respective compact-open topologies."
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] (s : set α) : continuous (λ (F : C(α, β)), continuous_map.restrict s F)"

- doc_string: "Tell `simp` what the entries are in a transposed matrix.  Compare with `mul_apply`, `diagonal_apply_eq`, etc."
  theorem: "{m : Type u_2} {n : Type u_3} {α : Type v} (M : matrix m n α) (i : m) (j : n) : M.transpose j i = M i j"

- doc_string: "Conjugation by a fixed element is continuous when `add` is continuous."
  theorem: "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] (g : G) : continuous (λ (h : G), g + h + -g)"

- doc_string: "The product of the constant function `1` over any set equals `1`."
  theorem: "{α : Type u_1} {M : Type u_5} [comm_monoid M] (s : set α) : finprod (λ (i : α), finprod (λ (H : i ∈ s), 1)) = 1"

- doc_string: "0 is in the set of natural number multiples of an element of an `add_monoid`."
  theorem: "{M : Type u_1} [add_monoid M] {x : M} : 0 ∈ multiples x"

- doc_string: "Composing two multiplications on the left by `y` then `x` is equal to a multiplication on the left by `x * y`."
  theorem: "{α : Type u_1} [semigroup α] (x y : α) : has_mul.mul x ∘ has_mul.mul y = has_mul.mul (x * y)"

- doc_string: " Dividing `a` by the result of dividing `a` by itself results in `a` (whether or not `a` is zero)."
  theorem: "{G₀ : Type u_2} [group_with_zero G₀] (a : G₀) : a / (a / a) = a"

- doc_string: " A closed embedding is proper, ie, inverse images of compact sets are contained in compacts. Moreover, the preimage of a compact set is compact, see `closed_embedding.is_compact_preimage`."
  theorem: "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : closed_embedding f) : filter.tendsto f (filter.cocompact α) (filter.cocompact β)"

- doc_string: "Rectangles of countably spanning sets are countably spanning."
  theorem: "{α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : is_countably_spanning (set.image2 has_set_prod.prod C D)"

- doc_string: "In a finite field of odd characteristic, not every element is a square."
  theorem: "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a"

- doc_string: "**Alias** of the reverse direction of is_extr_on_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_extr_on f s a → is_extr_on (⇑order_dual.to_dual ∘ f) s a"

- doc_string: "A version of `measurable_div_const` that assumes `has_measurable_mul` instead of  `has_measurable_div`. This can be nice to avoid unnecessary type-class assumptions."
  theorem: "{G : Type u_1} [div_inv_monoid G] [measurable_space G] [has_measurable_mul G] (g : G) : measurable (λ (h : G), h / g)"

- doc_string: "The diameter of the empty set vanishes"
  theorem: "{α : Type u} [pseudo_emetric_space α] : emetric.diam ∅ = 0"

- doc_string: "The map `coe_fn : (r →r s) → (α → β)` is injective."
  theorem: "{α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} : function.injective coe_fn"

- doc_string: "The identity map preserves addition"
  theorem: "{α : Type u} [has_add α] : is_add_hom id"

- doc_string: "A helper lemma: the characteristic is prime if it is non-zero."
  theorem: "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] {p : ℕ} [hp : char_p R p] (p_ne_zero : p ≠ 0) : nat.prime p"

- doc_string: "**Alias** of dvd_trans`."
  theorem: "{α : Type u_1} [semigroup α] {a b c : α} : a ∣ b → b ∣ c → a ∣ c"

- doc_string: "`polynomial R` is never a field for any ring `R`."
  theorem: "{R : Type u} [ring R] : ¬is_field (polynomial R)"

- doc_string: "The list `list.insertion_sort r l` is `list.sorted` with respect to `r`."
  theorem: "{α : Type uu} (r : α → α → Prop) [decidable_rel r] [is_total α r] [is_trans α r] (l : list α) : list.sorted r (list.insertion_sort r l)"

- doc_string: " Any two maps `f : α → β` and `g : β → α` are inverse of each other on the sets of fixed points of `f ∘ g` and `g ∘ f`, respectively."
  theorem: "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.inv_on f g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))"

- doc_string: "If `a % b = c` then `b` divides `a - c`."
  theorem: "{a b c : ℤ} (h : a % b = c) : b ∣ a - c"

- doc_string: "A localization always has cardinality less than or equal to the base ring."
  theorem: "{R : Type u} [comm_ring R] (S : submonoid R) {L : Type u} [comm_ring L] [algebra R L] [is_localization S L] : cardinal.mk L ≤ cardinal.mk R"

- doc_string: " Two compositions (possibly of different integers) coincide if and only if they have the same sequence of blocks."
  theorem: "{c c' : Σ (n : ℕ), composition n} : c = c' ↔ c.snd.blocks = c'.snd.blocks"

- doc_string: "**Alias** of nat.coe_nat_dvd`."
  theorem: "{α : Type u_1} [semiring α] {m n : ℕ} (h : m ∣ n) : ↑m ∣ ↑n"

- doc_string: "Any family is compressed along two identical elements."
  theorem: "{α : Type u_1} [generalized_boolean_algebra α] [decidable_rel disjoint] [decidable_rel has_le.le] (u : α) (s : finset α) : uv.is_compressed u u s"

- doc_string: "Subsets of a bounded set are also bounded"
  theorem: "{α : Type u} [pseudo_metric_space α] {s t : set α} (incl : s ⊆ t) : metric.bounded t → metric.bounded s"

- doc_string: "Inverses of elements of finite additive order have finite additive order."
  theorem: "{G : Type u} [add_group G] {x : G} (hx : is_of_fin_add_order x) : is_of_fin_add_order (-x)"

- doc_string: "A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4`"
  theorem: "(p : ℕ) [hp : fact (nat.prime p)] : prime ↑p ↔ p % 4 = 3"

- doc_string: " A prime `p` is a unit in a finite commutative ring `R` iff it does not divide the characteristic."
  theorem: "(R : Type u_1) [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : is_unit ↑p ↔ ¬p ∣ ring_char R"

- doc_string: "**Alias** of the forward direction of dense_closure`."
  theorem: "{α : Type u} [topological_space α] {s : set α} : dense (closure s) → dense s"

- doc_string: " If a composition of a function `f` followed by an injection `g` is locally constant, then the locally constant property descends to `f`."
  theorem: "{X : Type u_1} [topological_space X] {α : Type u_2} {β : Type u_3} (f : X → α) (g : α → β) (h : is_locally_constant (g ∘ f)) (inj : function.injective g) : is_locally_constant f"

- doc_string: "The indexed supremum of a function is bounded above by a uniform bound"
  theorem: "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), f x ≤ c) : supr f ≤ c"

- doc_string: " The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers."
  theorem: "(w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂"

- doc_string: " Euclid's lemma: if `a ∣ b * c` and `gcd a b = 1` then `a ∣ c`. Compare with `is_coprime.dvd_of_dvd_mul_right` and `unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors`"
  theorem: "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd b = 1) : a ∣ c"

- doc_string: " The square of the sine of `π / 3` is `3 / 4` (this is sometimes more convenient than the result for cosine itself)."
  theorem: " : real.sin (real.pi / 3) ^ 2 = 3 / 4"

- doc_string: "The function `r ↦ r⁻¹` tends to `0` on the right as `r → +∞`."
  theorem: "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (r : α), r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0))"

- doc_string: "In the special case `n = 1`, `quaternion 1` is a cyclic group (of order `4`)."
  theorem: " : is_cyclic (quaternion_group 1)"

- doc_string: "The exponential characteristic is a prime number or one."
  theorem: "(R : Type u) [semiring R] [nontrivial R] [no_zero_divisors R] (q : ℕ) [hq : exp_char R q] : nat.prime q ∨ q = 1"

- doc_string: "If both `a` and `b` commute with `c`, then their product commutes with `c`."
  theorem: "{S : Type u_1} [semigroup S] {a b c : S} (hac : commute a c) (hbc : commute b c) : commute (a * b) c"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_pos_of_nonneg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b"

- doc_string: "See `tsub_tsub_le` for an inequality."
  theorem: "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} [contravariant_class α α has_add.add has_le.le] (h : a ≤ b) : b - (b - a) = a"

- doc_string: "A subset of a cospherical set is cospherical."
  theorem: "{P : Type u_2} [metric_space P] {ps₁ ps₂ : set P} (hs : ps₁ ⊆ ps₂) (hc : euclidean_geometry.cospherical ps₂) : euclidean_geometry.cospherical ps₁"

- doc_string: "This lemma has an abbreviated name because it is used frequently."
  theorem: "{a b : ennreal} (h : a < b) : add_le_cancellable a"

- doc_string: "`quot.mk r` is a surjective function."
  theorem: "{α : Sort u_1} (r : α → α → Prop) : function.surjective (quot.mk r)"

- doc_string: "If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)`"
  theorem: "{M : Type u_1} [monoid M] {x : M} (m : ℕ) {n : ℕ} (h : x ^ n = 1) : x ^ m = x ^ (m % n)"

- doc_string: "Left multiplication in a ring is an additive monoid morphism."
  theorem: "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), x * y)"

- doc_string: "The closure of the interval `(-∞, a)` is the interval `(-∞, a]`."
  theorem: "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_min_order α] : closure (set.Iio a) = set.Iic a"

- doc_string: "**Alias** of `left.add_neg_of_nonpos_of_neg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0"

- doc_string: "**Alias** of the forward direction of is_clopen_iff_frontier_eq_empty`."
  theorem: "{α : Type u} [topological_space α] {s : set α} : is_clopen s → frontier s = ∅"

- doc_string: "`R` is integrally closed iff it is the integral closure of itself in its field of fractions."
  theorem: "{R : Type u_1} [comm_ring R] [is_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] : is_integrally_closed R ↔ is_integral_closure R R K"

- doc_string: " *Engel's theorem*.  Note that this implies all traditional forms of Engel's theorem via `lie_module.nontrivial_max_triv_of_is_nilpotent`, `lie_module.is_nilpotent_iff_forall`, `lie_algebra.is_nilpotent_iff_forall`."
  theorem: "{R : Type u₁} {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] [is_noetherian R L] : lie_algebra.is_engelian R L"

- doc_string: "Determinant of 1x1 matrix"
  theorem: "{R : Type v} [comm_ring R] (A : matrix (fin 1) (fin 1) R) : A.det = A 0 0"

- doc_string: " An algebra over a Noetherian ring is finitely generated if and only if it is finitely presented."
  theorem: "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] [is_noetherian_ring R] : algebra.finite_type R A ↔ algebra.finite_presentation R A"

- doc_string: " Given a closed set `s` in a Polish space, one can construct a finer Polish topology for which `s` is both open and closed."
  theorem: "{α : Type u_1} [topological_space α] [polish_space α] {s : set α} (hs : is_closed s) : polish_space.is_clopenable s"

- doc_string: "**Alias** of the reverse direction of is_coatom_dual_iff_is_atom`."
  theorem: "{α : Type u_1} [preorder α] [order_bot α] {a : α} : is_atom a → is_coatom (⇑order_dual.to_dual a)"

- doc_string: "`sinh` is strictly monotone."
  theorem: " : strict_mono real.sinh"

- doc_string: " Adding a group element to the point `p` is an injective function."
  theorem: "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : G), _x +ᵥ p)"

- doc_string: "A stronger version of `mul_right_injective`"
  theorem: "{α : Type u} [decidable_eq α] (i j : α) : function.involutive (has_mul.mul (equiv.swap i j))"

- doc_string: " The first theorem that characterises the function `reduce`: a word reduces to its maximal reduction."
  theorem: "{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.red L (free_group.reduce L)"

- doc_string: "Two metric space structures with the same distance coincide."
  theorem: "{α : Type u_1} {m m' : metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'"

- doc_string: " Converting a `fin (n + 1)` to `ℕ` and back results in the same value."
  theorem: "{n : ℕ} (a : fin (n + 1)) : ↑↑a = a"

- doc_string: " To show a reflexive relation `r : α → α → Prop` holds over `x y : α`, it suffices to show it holds when `x ≠ y`."
  theorem: "{α : Type u_1} {r : α → α → Prop} (h : reflexive r) {x y : α} (hr : x ≠ y → r x y) : r x y"

- doc_string: "The golden ratio is irrational."
  theorem: " : irrational golden_ratio"

- doc_string: "The set of natural number powers of an element of a monoid is closed under multiplication."
  theorem: "{M : Type u_1} [monoid M] {x y z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x"

- doc_string: "Extensionality rule for congruence relations."
  theorem: "{M : Type u_1} [has_mul M] {c d : con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d"

- doc_string: "The resolvent is a unit when the argument is in the resolvent set."
  theorem: "{R : Type u} {A : Type v} [comm_semiring R] [ring A] [algebra R A] {r : R} {a : A} : r ∈ resolvent_set R a ↔ is_unit (resolvent a r)"

- doc_string: "**Alias** of lt_of_eq_of_lt`."
  theorem: "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b < c) : a < c"

- doc_string: " Young's inequality, `ℝ≥0` version. We use `{p q : ℝ≥0}` in order to avoid constructing witnesses of `0 ≤ p` and `0 ≤ q` for the denominators."
  theorem: "(a b : nnreal) {p q : nnreal} (hp : 1 < p) (hpq : 1 / p + 1 / q = 1) : a * b ≤ a ^ ↑p / p + b ^ ↑q / q"

- doc_string: " If all elements in a list are bounded below by `1`, then the length of the list is bounded by the sum of the elements."
  theorem: "(L : list ℕ) (h : ∀ (i : ℕ), i ∈ L → 1 ≤ i) : L.length ≤ L.sum"

- doc_string: "The negation of an additive group homomorphism is an additive group homomorphism if the target is commutative."
  theorem: "{α : Type u_1} {β : Type u_2} [add_group α] [add_comm_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_group_hom (λ (a : α), -f a)"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_le_mul`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b"

- doc_string: "`legendre_sym p a = -1` iff`a` is a nonsquare mod `p`."
  theorem: "(p : ℕ) [fact (nat.prime p)] {a : ℤ} : zmod.legendre_sym p a = -1 ↔ ¬is_square ↑a"

- doc_string: "**Alias** of not_sbtw_of_btw`."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : ¬has_sbtw.sbtw c b a"

- doc_string: "The `star` map in a normed star group is an isometry"
  theorem: "{E : Type u_2} [semi_normed_group E] [star_add_monoid E] [normed_star_group E] : isometry has_star.star"

- doc_string: "See also `continuous_map.continuous_coe'`"
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous coe_fn"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_pos'`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "Finite wide pushouts are finite colimits, so if `C` has all finite colimits, it also has finite wide pushouts"
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_colimits C] : category_theory.limits.has_finite_wide_pushouts C"

- doc_string: "If `find p = some i`, then `p i` holds"
  theorem: "{n : ℕ} (p : fin n → Prop) [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) : p i"

- doc_string: "The identity map is a ring homomorphism."
  theorem: "{α : Type u} [ring α] : is_ring_hom id"

- doc_string: "`clifford_algebra.involute` is analogous to `complex.conj`."
  theorem: "(c : clifford_algebra clifford_algebra_complex.Q) : ⇑clifford_algebra_complex.to_complex (⇑clifford_algebra.involute c) = ⇑(star_ring_end ℂ) (⇑clifford_algebra_complex.to_complex c)"

- doc_string: "Composition by an bijective function on the left is itself bijective."
  theorem: "{α : Sort u} {β : Sort v} {γ : Sort w} {g : β → γ} (hg : function.bijective g) : function.bijective (function.comp g)"

- doc_string: "**Alias** of int.le_self_sq`."
  theorem: "(b : ℤ) : b ≤ b ^ 2"

- doc_string: "If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`."
  theorem: "{z : upper_half_plane} (hz : z ∈ modular_group.fdo) (n : ℤ) : 1 < ⇑complex.norm_sq ↑(modular_group.T ^ n • z)"

- doc_string: " If `C` has disjoint coproducts, any morphism out of initial is mono. Note it isn't true in general that `C` has strict initial objects, for instance consider the category of types and partial functions."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.coproducts_disjoint C] : category_theory.limits.initial_mono_class C"

- doc_string: " Cyclotomic polynomials are always positive on inputs larger than one. Similar to `cyclotomic_pos` but with the condition on the input rather than index of the cyclotomic polynomial."
  theorem: "(n : ℕ) {R : Type u_1} [linear_ordered_comm_ring R] {x : R} (hx : 1 < x) : 0 < polynomial.eval x (polynomial.cyclotomic n R)"

- doc_string: "Given subsets `t` and `s` of a monoid `M`, if `s ⊆ t`, the submonoid of `M` generated by `s` is    contained in the submonoid generated by `t`."
  theorem: "{M : Type u_1} [monoid M] {s t : set M} (h : s ⊆ t) : monoid.closure s ⊆ monoid.closure t"

- doc_string: "If a preadditive category has all cokernels, then it also has all coequalizers."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_cokernels C] : category_theory.limits.has_coequalizers C"

- doc_string: "A `fintype` can be given a field structure iff its cardinality is a prime power."
  theorem: "{α : Type u_1} [fintype α] : nonempty (field α) ↔ is_prime_pow (fintype.card α)"

- doc_string: "When there is a global maximum, every set is bounded above."
  theorem: "{γ : Type w} [preorder γ] [order_top γ] (s : set γ) : bdd_above s"

- doc_string: "The Haudorff edistances of `s` to `t` and of `t` to `s` coincide"
  theorem: "{α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s t = emetric.Hausdorff_edist t s"

- doc_string: "**Alias** of left.one_le_mul`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b"

- doc_string: "Updating the last element of a tuple does not change the beginning."
  theorem: "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) (z : α (fin.last n)) : fin.init (function.update q (fin.last n) z) = fin.init q"

- doc_string: "**Alias** of ne_of_lt`."
  theorem: "{α : Type u} [preorder α] {a b : α} (h : a < b) : a ≠ b"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one_of_le_of_lt`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1"

- doc_string: "Mapping intermediate fields along the identity does not change them"
  theorem: "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (E : intermediate_field K L) : E.map (alg_hom.id K L) = E"

- doc_string: "The range of an indexed cardinal function, whose outputs live in a higher universe than the    inputs, is always bounded above."
  theorem: "{ι : Type u} (f : ι → cardinal) : bdd_above (set.range f)"

- doc_string: "Equality behind `add_semiconj_by a x y`; useful for rewriting."
  theorem: "{S : Type u} [has_add S] {a x y : S} (h : add_semiconj_by a x y) : a + x = y + a"

- doc_string: "Every ultrafilter `u` on `ultrafilter α` converges to a unique  point of `ultrafilter α`, namely `mjoin u`."
  theorem: "{α : Type u} {u : ultrafilter (ultrafilter α)} {x : ultrafilter α} : ↑u ≤ nhds x ↔ x = mjoin u"

- doc_string: "The quotient map by a group action is open."
  theorem: "{Γ : Type u_4} [group Γ] {T : Type u_5} [topological_space T] [mul_action Γ T] [has_continuous_const_smul Γ T] : is_open_map quotient.mk"

- doc_string: " `(k*x, k*y, k*z)` is a Pythagorean triple if and only if `(x, y, z)` is also a triple."
  theorem: "{x y z : ℤ} (k : ℤ) (hk : k ≠ 0) : pythagorean_triple (k * x) (k * y) (k * z) ↔ pythagorean_triple x y z"

- doc_string: " Converting an in-range number to `fin (n + 1)` produces a result whose value is the original number."
  theorem: "{n a : ℕ} (h : a < n + 1) : ↑a.val = a"

- doc_string: "The distance to a set is controlled by the Hausdorff distance"
  theorem: "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} (h : x ∈ s) : emetric.inf_edist x t ≤ emetric.Hausdorff_edist s t"

- doc_string: "`ord ∘ aleph` enumerates the infinite ordinals that are cardinals."
  theorem: " : cardinal.ord ∘ cardinal.aleph = ordinal.enum_ord {b : ordinal | b.card.ord = b ∧ ordinal.omega ≤ b}"

- doc_string: "A preadditive category with finite coproducts has finite biproducts."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_coproducts C] : category_theory.limits.has_finite_biproducts C"

- doc_string: " The sum over the complement of a finset tends to `0` when the finset grows to cover the whole space. This does not need a summability assumption, as otherwise all sums are zero."
  theorem: "{α : Type u_1} (f : α → nnreal) : filter.tendsto (λ (s : finset α), ∑' (b : {x // x ∉ s}), f ↑b) filter.at_top (nhds 0)"

- doc_string: " So-named because the outer coercion is `int.cast` into `zmod`. For `int.cast` into an arbitrary ring, see `zmod.int_cast_cast`."
  theorem: "{n : ℕ} (a : zmod n) : ↑↑a = a"

- doc_string: "**Alias** of the reverse direction of mul_sub_mul_div_mul_neg_iff`."
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : a / c < b / d → (a * d - b * c) / (c * d) < 0"

- doc_string: "A regular element of a `nontrivial` `mul_zero_class` is non-zero."
  theorem: "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (la : is_regular a) : a ≠ 0"

- doc_string: " For each field, and for each nonzero element of said field, there is a unique inverse. Since `is_field` doesn't remember the data of an `inv` function and as such, a lemma that there is a unique inverse could be useful."
  theorem: "(R : Type u) [ring R] (hf : is_field R) (x : R) : x ≠ 0 → (∃! (y : R), x * y = 1)"

- doc_string: "Conjugation acting on fixed element of the additive group is continuous when both   `add` and `neg` are continuous."
  theorem: "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] (h : G) : continuous (λ (g : G), g + h + -g)"

- doc_string: " A version of `measurable_const` that assumes `f x = f y` for all `x, y`. This version works for functions between empty types."
  theorem: "{α : Type u_1} {β : Type u_2} [measurable_space α] [measurable_space β] {f : β → α} (hf : ∀ (x y : β), f x = f y) : measurable f"

- doc_string: "The first projection in a product of topological spaces sends open sets to open sets."
  theorem: "{α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.fst"

- doc_string: "**Alias** of the forward direction of is_seq_closed_iff_is_closed`."
  theorem: "{X : Type u_1} [topological_space X] [sequential_space X] {s : set X} : is_seq_closed s → is_closed s"

- doc_string: " In the characteristic zero case, the weights in the centroid sum to 1 if the number of points is `n + 1`."
  theorem: "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) [char_zero k] {n : ℕ} (h : s.card = n + 1) : s.sum (λ (i : ι), finset.centroid_weights k s i) = 1"

- doc_string: '$\lim_{x\to-\infty}|x|=+\infty$'
  theorem: "{α : Type u_3} [linear_ordered_add_comm_group α] : filter.tendsto has_abs.abs filter.at_bot filter.at_top"

- doc_string: "If a preadditive category has all kernels, then it also has all equalizers."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_kernels C] : category_theory.limits.has_equalizers C"

- doc_string: "**Alias** of the reverse direction of monotone_on_to_dual_comp_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : antitone_on f s → monotone_on (⇑order_dual.to_dual ∘ f) s"

- doc_string: "Elements of a cancel monoid are regular.  Cancel semigroups do not appear to exist."
  theorem: "{R : Type u_1} [cancel_monoid R] (g : R) : is_regular g"

- doc_string: "The negation of a map which preserves addition, preserves addition when the target is commutative."
  theorem: "{α : Type u_1} {β : Type u_2} [add_zero_class α] [add_comm_group β] {f : α → β} (hf : is_add_monoid_hom f) : is_add_monoid_hom (λ (a : α), -f a)"

- doc_string: "If the domain of a `dense_inducing` map is a separable space, then so is the codomain."
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {i : α → β} (di : dense_inducing i) [topological_space.separable_space α] : topological_space.separable_space β"

- doc_string: "Deprecated: use `fun_like.ext_iff` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] {f g : zero_hom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x"

- doc_string: "Function extensionality, proven using quotients."
  theorem: "{α : Sort u} {β : α → Sort v} {f₁ f₂ : Π (x : α), β x} (h : ∀ (x : α), f₁ x = f₂ x) : f₁ = f₂"

- doc_string: "We have the congruence `legendre_sym p a ≡ a ^ (p / 2) mod p`."
  theorem: "(p : ℕ) (a : ℤ) [hp : fact (nat.prime p)] : ↑(zmod.legendre_sym p a) = ↑a ^ (p / 2)"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_lt_of_le`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b"

- doc_string: "**Alias** of left.neg_le_self`."
  theorem: "{α : Type u} [add_group α] [preorder α] [covariant_class α α has_add.add has_le.le] {a : α} (h : 0 ≤ a) : -a ≤ a"

- doc_string: "`padic_val_nat p 0` is 0 for any `p`."
  theorem: "{p : ℕ} : padic_val_nat p 0 = 0"

- doc_string: "The order of the formal power series `X^n` is `n`."
  theorem: "{R : Type u_1} [semiring R] [nontrivial R] (n : ℕ) : (power_series.X ^ n).order = ↑n"

- doc_string: "The sequence `B ⟶ A ⊞ B ⟶ A` is exact."
  theorem: "{𝒜 : Type u_1} [category_theory.category 𝒜] [category_theory.preadditive 𝒜] [category_theory.limits.has_kernels 𝒜] [category_theory.limits.has_images 𝒜] [category_theory.limits.has_binary_biproducts 𝒜] (A B : 𝒜) : category_theory.exact category_theory.limits.biprod.inr category_theory.limits.biprod.fst"

- doc_string: " A module over a `subsingleton` semiring is a `subsingleton`. We cannot register this as an instance because Lean has no way to guess `R`."
  theorem: "(R : Type u_1) (M : Type u_2) [semiring R] [subsingleton R] [add_comm_monoid M] [module R M] : subsingleton M"

- doc_string: "The order of the monomial `a*X^n` is `n` if `a ≠ 0`."
  theorem: "{R : Type u_1} [semiring R] (n : ℕ) (a : R) (h : a ≠ 0) : (⇑(power_series.monomial R n) a).order = ↑n"

- doc_string: " Every separated topological group in which there exists a compact set with nonempty interior is locally compact."
  theorem: "{G : Type w} [topological_space G] [group G] [topological_group G] [t2_space G] (K : topological_space.positive_compacts G) : locally_compact_space G"

- doc_string: "**Alias** of lt_asymm`."
  theorem: "{α : Type u} [preorder α] {a b : α} (h : a < b) : ¬b < a"

- doc_string: "`cyclotomic n R` is different from `0`."
  theorem: "(n : ℕ) (R : Type u_1) [ring R] [nontrivial R] : polynomial.cyclotomic n R ≠ 0"

- doc_string: "**Alias** of left.inv_lt_one_iff`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a"

- doc_string: "If an element `b` becomes add-left-regular after adding to it on the left a add-left-regular element, then `b` is add-left-regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_left_regular (a + b)) : is_add_left_regular b"

- doc_string: "The `n`-th ghost component of `teichmuller p r` is `r ^ p ^ n`."
  theorem: "(p : ℕ) {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (r : R) (n : ℕ) : ⇑(witt_vector.ghost_component n) (⇑(witt_vector.teichmuller p) r) = r ^ p ^ n"

- doc_string: " If `α` is a nonempty preorder with no minimal elements, then there exists a strictly antitone function `ℕ → α`."
  theorem: "(α : Type u) [preorder α] [nonempty α] [no_min_order α] : ∃ (f : ℕ → α), strict_anti f"

- doc_string: " **Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces to `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4` respectively. This is also known as Newman's diamond lemma."
  theorem: "{α : Type u} {L₁ L₂ L₃ : list (α × bool)} : free_group.red L₁ L₂ → free_group.red L₁ L₃ → relation.join free_group.red L₂ L₃"

- doc_string: "In a semigroup, the product of left-regular elements is left-regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (lra : is_left_regular a) (lrb : is_left_regular b) : is_left_regular (a * b)"

- doc_string: "`⊤`, coerced to a set, is the whole set of points."
  theorem: "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊤ = set.univ"

- doc_string: "Elements of a left cancel semigroup are left regular."
  theorem: "{R : Type u_1} [left_cancel_semigroup R] (g : R) : is_left_regular g"

- doc_string: "The projection from a topological fiber bundle to its base is an open map."
  theorem: "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] (h : is_topological_fiber_bundle F proj) : is_open_map proj"

- doc_string: "In a preadditive category, if all binary products exist, then all binary biproducts exist."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_products C] : category_theory.limits.has_binary_biproducts C"

- doc_string: "**Alias** of `left.add_neg'`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "Express `edist` in terms of `nndist`"
  theorem: "{α : Type u} [pseudo_metric_space α] (x y : α) : has_edist.edist x y = ↑(has_nndist.nndist x y)"

- doc_string: "Any category with finite products and equalizers has all finite limits.  See <https://stacks.math.columbia.edu/tag/002O>."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_finite_limits C"

- doc_string: "The set of natural number powers of an element of a submonoid is a subset of the submonoid."
  theorem: "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) : powers a ⊆ s"

- doc_string: "**Alias** of lt_trans`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : a < b → b < c → a < c"

- doc_string: "**Alias** of the reverse direction of is_square_inv`."
  theorem: "{α : Type u_2} [subtraction_monoid α] {a : α} : even a → even (-a)"

- doc_string: " `reduce` is idempotent, i.e. the maximal reduction of the maximal reduction of a word is the maximal reduction of the word."
  theorem: "{α : Type u} {L : list (α × bool)} [decidable_eq α] : free_group.reduce (free_group.reduce L) = free_group.reduce L"

- doc_string: " In a (semi)normed group, negation `x ↦ -x` tends to infinity at infinity. TODO: use `bornology.cobounded` instead of `filter.comap has_norm.norm filter.at_top`."
  theorem: "{E : Type u_3} [semi_normed_group E] : filter.tendsto has_neg.neg (filter.comap has_norm.norm filter.at_top) (filter.comap has_norm.norm filter.at_top)"

- doc_string: "There is a field structure on type if and only if its cardinality is a prime power."
  theorem: "{α : Type u} : nonempty (field α) ↔ is_prime_pow (cardinal.mk α)"

- doc_string: "If both `a` and `b` commute with `c`, then their product commutes with `c`."
  theorem: "{S : Type u_1} [add_semigroup S] {a b c : S} (hac : add_commute a c) (hbc : add_commute b c) : add_commute (a + b) c"

- doc_string: "The `semi_normed_group.core` induced by a `normed_group.core`."
  theorem: "{E : Type u_1} [add_comm_group E] [has_norm E] (C : normed_group.core E) : semi_normed_group.core E"

- doc_string: "**Alias** of the forward direction of even_iff_exists_bit0`."
  theorem: "{α : Type u_2} [has_add α] {a : α} : even a → (∃ (b : α), a = bit0 b)"

- doc_string: "The Hausdorff distance satisfies the triangular inequality"
  theorem: "{α : Type u} [pseudo_emetric_space α] {s t u : set α} : emetric.Hausdorff_edist s u ≤ emetric.Hausdorff_edist s t + emetric.Hausdorff_edist t u"

- doc_string: "The projection on the base of a topological bundle created from core is continuous"
  theorem: "{ι : Type u_1} {B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] (Z : topological_fiber_bundle_core ι B F) : continuous Z.proj"

- doc_string: "This lemma has an abbreviated name because it is used frequently."
  theorem: "{a : nnreal} : add_le_cancellable ↑a"

- doc_string: "A semisimple Abelian Lie algebra is trivial."
  theorem: "(R : Type u) (L : Type v) [comm_ring R] [lie_ring L] [lie_algebra R L] [lie_algebra.is_semisimple R L] [h : is_lie_abelian L] : subsingleton L"

- doc_string: "Cyclic permutations preserve the triple product. See also `triple_product_eq_det`."
  theorem: "{R : Type u_1} [comm_ring R] (u v w : fin 3 → R) : matrix.dot_product u (⇑(⇑cross_product v) w) = matrix.dot_product v (⇑(⇑cross_product w) u)"

- doc_string: "For `p ≠ 0, p ≠ 1, `padic_val_rat p p` is 1."
  theorem: "{p : ℕ} (hp : 1 < p) : padic_val_nat p p = 1"

- doc_string: "The element `0` is right-regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] (h : is_right_regular 0) : subsingleton R"

- doc_string: "**Alias** of the reverse direction of monotone_to_dual_comp_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : antitone f → monotone (⇑order_dual.to_dual ∘ f)"

- doc_string: " In the trivial charted_space structure of a space modelled over itself through the identity, the atlas members are just the identity"
  theorem: "{H : Type u_1} [topological_space H] {e : local_homeomorph H H} : e ∈ charted_space.atlas H H ↔ e = local_homeomorph.refl H"

- doc_string: "Finite wide pullbacks are finite limits, so if `C` has all finite limits, it also has finite wide pullbacks"
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_finite_limits C] : category_theory.limits.has_finite_wide_pullbacks C"

- doc_string: "The infimum of a singleton is the element of the singleton"
  theorem: "{α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Inf.Inf {a} = a"

- doc_string: "The element `0` is regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] : is_regular 0 ↔ subsingleton R"

- doc_string: "If a category has all products then in particular it has finite products."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_products C] : category_theory.limits.has_finite_products C"

- doc_string: "Two holors are equal if all their slices are equal."
  theorem: "{α : Type} {d : ℕ} {ds : list ℕ} (x y : holor α (d :: ds)) (h : x.slice = y.slice) : x = y"

- doc_string: "**Alias** of le_of_mul_le_mul_left'`."
  theorem: "{α : Type u_1} [has_mul α] [has_le α] [contravariant_class α α has_mul.mul has_le.le] {a b c : α} (bc : a * b ≤ a * c) : b ≤ c"

- doc_string: " The characteristic polynomial of the map `λ x, a * x` is the minimal polynomial of `a`.  In combination with `det_eq_sign_charpoly_coeff` or `trace_eq_neg_charpoly_coeff` and a bit of rewriting, this will allow us to conclude the field norm resp. trace of `x` is the product resp. sum of `x`'s conjugates."
  theorem: "{K : Type u_1} {S : Type u_2} [field K] [comm_ring S] [algebra K S] (h : power_basis K S) : (⇑(algebra.left_mul_matrix h.basis) h.gen).charpoly = minpoly K h.gen"

- doc_string: "The empty set has zero diameter"
  theorem: "{α : Type u} [pseudo_metric_space α] : metric.diam ∅ = 0"

- doc_string: " If `α` is a separable space and `f : α → β` is a continuous map with dense range, then `β` is a separable space as well. E.g., the completion of a separable uniform space is separable."
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space.separable_space α] [topological_space β] {f : α → β} (h : dense_range f) (h' : continuous f) : topological_space.separable_space β"

- doc_string: "**Fermat's Little Theorem**: for all nonzero `a : zmod p`, we have `a ^ (p - 1) = 1`."
  theorem: "{p : ℕ} [fact (nat.prime p)] {a : zmod p} (ha : a ≠ 0) : a ^ (p - 1) = 1"

- doc_string: "Conjugation is jointly continuous on `G × G` when both `mul` and `inv` are continuous."
  theorem: "{G : Type w} [topological_space G] [has_neg G] [has_add G] [has_continuous_add G] [has_continuous_neg G] : continuous (λ (g : G × G), g.fst + g.snd + -g.fst)"

- doc_string: " Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and `zsmul_lt_zsmul_iff'`."
  theorem: "{α : Type u_1} [linear_ordered_comm_group α] {n : ℤ} {a b : α} (hn : n ≠ 0) : a ^ n = b ^ n ↔ a = b"

- doc_string: "The cardinality of the antidiagonal of `n` is `n+1`."
  theorem: "(n : ℕ) : ⇑multiset.card (multiset.nat.antidiagonal n) = n + 1"

- doc_string: "If `a` commutes with `b`, then `b` commutes with `a`."
  theorem: "{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a"

- doc_string: "The range of `pure : α → ultrafilter α` is dense in `ultrafilter α`."
  theorem: "{α : Type u} : dense_range has_pure.pure"

- doc_string: "The minimal distance to a set (as `ℝ≥0`) is continuous in point"
  theorem: "{α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_nndist x s)"

- doc_string: "**Alias** of sbtw_asymm`."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : ¬has_sbtw.sbtw c b a"

- doc_string: " To get differentiability at `0` of the auxiliary functions, we need to know that their limit is `0`, to be able to apply general differentiability extension theorems. This limit is checked in this lemma."
  theorem: "(n : ℕ) : filter.tendsto (λ (x : ℝ), polynomial.eval x (exp_neg_inv_glue.P_aux n) * real.exp (-x⁻¹) / x ^ (2 * n)) (nhds_within 0 (set.Ioi 0)) (nhds 0)"

- doc_string: "The only numbers with empty prime factorization are `0` and `1`"
  theorem: "(n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1"

- doc_string: "**Alias** of the reverse direction of order.succ_ne_succ_iff`."
  theorem: "{α : Type u_1} [partial_order α] [succ_order α] {a b : α} [no_max_order α] : a ≠ b → order.succ a ≠ order.succ b"

- doc_string: "See `tsub_tsub_cancel_of_le` for the equality."
  theorem: "{α : Type u_1} [preorder α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] {a b : α} : b - (b - a) ≤ a"

- doc_string: "A specialized ext lemma for equality of sigma types over an indexed subtype."
  theorem: "{α : Type u_1} {β : Type u_2} {p : α → β → Prop} {x₀ x₁ : Σ (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁"

- doc_string: "**Alias** of the reverse direction of bounded_space_subtype_iff`."
  theorem: "{α : Type u_1} [bornology α] {p : α → Prop} : bornology.is_bounded {x : α | p x} → bounded_space (subtype p)"

- doc_string: "In a monoid with zero, either zero and one are nonequal, or zero is the only element."
  theorem: "{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 ≠ 1 ∨ ∀ (a : M₀), a = 0"

- doc_string: "If the domain of a `dense_embedding` is a separable space, then so is its codomain."
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {e : α → β} (de : dense_embedding e) [topological_space.separable_space α] : topological_space.separable_space β"

- doc_string: "In a `t2_space`, every compact set is closed."
  theorem: "{α : Type u} [topological_space α] [t2_space α] {s : set α} (hs : is_compact s) : is_closed s"

- doc_string: " Convenience lemma. The `a - 1` is not using truncated substraction, as opposed to the definition of `nat.desc_factorial` as a natural."
  theorem: "(S : Type u_1) [ring S] (a : ℕ) : ↑(a.desc_factorial 2) = ↑a * (↑a - 1)"

- doc_string: "**Alias** of sbtw_trans_right`."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c d : α} (hbc : has_sbtw.sbtw a b c) (hcd : has_sbtw.sbtw a c d) : has_sbtw.sbtw a b d"

- doc_string: "Deprecated: use `fun_like.congr_arg` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] (f : one_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y"

- doc_string: "The number of solutions to `x^2 = a` is determined by the quadratic character."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) (a : F) : ↑({x : F | x ^ 2 = a}.to_finset.card) = char.quadratic_char F a + 1"

- doc_string: "We prefer to use the bundled `rev_at` over unbundled `rev_at_fun`."
  theorem: "(N i : ℕ) : polynomial.rev_at_fun N i = ⇑(polynomial.rev_at N) i"

- doc_string: "**Alias** of the reverse direction of lt_inv_mul_iff_mul_lt`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a * b < c → b < a⁻¹ * c"

- doc_string: "For the identity map, all points are periodic."
  theorem: "{α : Type u_1} (n : ℕ) (x : α) : function.is_periodic_pt id n x"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_neg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "The new distance is uniformly continuous."
  theorem: "{α : Type u} [pseudo_metric_space α] : uniform_continuous (λ (p : uniform_space.completion α × uniform_space.completion α), has_dist.dist p.fst p.snd)"

- doc_string: "The conjugate of the golden ratio is irrational."
  theorem: " : irrational golden_conj"

- doc_string: "The sets of factors of coprime `a` and `b` are disjoint"
  theorem: "{a b : ℕ} (hab : a.coprime b) : a.factors.disjoint b.factors"

- doc_string: "The order on `ι →₀ ℕ` is well-founded."
  theorem: "(ι : Type u_3) : well_founded has_lt.lt"

- doc_string: " For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`"
  theorem: "{a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 < a * b"

- doc_string: "**Alias** of the forward direction of antisymm_rel_iff_eq`."
  theorem: "{α : Type u_1} {r : α → α → Prop} [is_refl α r] [is_antisymm α r] {a b : α} : antisymm_rel r a b → a = b"

- doc_string: "`a ≤ b` as natural numbers if and only if `a ≤ b` in `fin n`."
  theorem: "{n : ℕ} {a b : fin n} : ↑a ≤ ↑b ↔ a ≤ b"

- doc_string: "**Alias** of the reverse direction of order.pred_lt_pred_iff`."
  theorem: "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : a < b → order.pred a < order.pred b"

- doc_string: "If `L/K` is an algebraic field extension, then the Krull topology on `L ≃ₐ[K] L` is  totally disconnected."
  theorem: "{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (h_int : algebra.is_integral K L) : is_totally_disconnected set.univ"

- doc_string: "0 is of finite order in any additive monoid."
  theorem: "{G : Type u} [add_monoid G] : is_of_fin_add_order 0"

- doc_string: "In an additive semigroup, the sum of add-left-regular elements is add-left.regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (lra : is_add_left_regular a) (lrb : is_add_left_regular b) : is_add_left_regular (a + b)"

- doc_string: "**Alias** of lt_of_mul_lt_mul_left'`."
  theorem: "{α : Type u_1} [has_mul α] [has_lt α] [contravariant_class α α has_mul.mul has_lt.lt] {a b c : α} (bc : a * b < a * c) : b < c"

- doc_string: " Reformulation of well founded induction on ordinals as a lemma that works with the `induction` tactic, as in `induction i using ordinal.induction with i IH`."
  theorem: "{p : ordinal → Prop} (i : ordinal) (h : ∀ (j : ordinal), (∀ (k : ordinal), k < j → p k) → p j) : p i"

- doc_string: "`sinh` is injective, `∀ a b, sinh a = sinh b → a = b`."
  theorem: " : function.injective real.sinh"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : 0 < -a ↔ a < 0"

- doc_string: "Multiplicative congruence relations preserve inversion."
  theorem: "{M : Type u_1} [group M] (c : con M) {w x : M} : ⇑c w x → ⇑c w⁻¹ x⁻¹"

- doc_string: "`quotient.mk` is a surjective function."
  theorem: "(α : Sort u_1) [s : setoid α] : function.surjective quotient.mk"

- doc_string: "The normal closure of s is the smallest normal subgroup containing s."
  theorem: "{G : Type u_1} [group G] {s t : set G} (ht : is_normal_subgroup t) (h : s ⊆ t) : group.normal_closure s ⊆ t"

- doc_string: "There exists at most one `floor_semiring` structure on a linear ordered semiring."
  theorem: "{α : Type u_1} [linear_ordered_semiring α] : subsingleton (floor_semiring α)"

- doc_string: "**Sum of a Geometric Series**"
  theorem: "{r : nnreal} (hr : r < 1) : has_sum (λ (n : ℕ), r ^ n) (1 - r)⁻¹"

- doc_string: "Any element commutes with itself."
  theorem: "{S : Type u_1} [has_mul S] (a : S) : commute a a"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a : α} : -a < 0 ↔ 0 < a"

- doc_string: " An element a of a semigroup with a distributive negation divides the negation of an element b iff a divides b."
  theorem: "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : a ∣ -b ↔ a ∣ b"

- doc_string: "**Alias** of `left.add_neg_of_neg_of_nonpos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0"

- doc_string: "Additive congruence relations preserve subtraction."
  theorem: "{M : Type u_1} [add_group M] (c : add_con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w - y) (x - z)"

- doc_string: " Conjugation acting on fixed element of the group is continuous when both `mul` and `inv` are continuous."
  theorem: "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] [has_continuous_inv G] (h : G) : continuous (λ (g : G), g * h * g⁻¹)"

- doc_string: "On an empty space, bounded continuous functions are at distance 0"
  theorem: "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} [is_empty α] : has_dist.dist f g = 0"

- doc_string: "The right inverse of an isometry is an isometry."
  theorem: "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} {g : β → α} (h : isometry f) (hg : function.right_inverse g f) : isometry g"

- doc_string: "**Alias** of the forward direction of le_sub_iff_add_le'`."
  theorem: "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : b ≤ c - a → a + b ≤ c"

- doc_string: "A monoid `M` is finitely generated if and only if `monoid_algebra R M` is of finite type."
  theorem: "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R M) ↔ monoid.fg M"

- doc_string: "An integral element of an algebra is algebraic."
  theorem: "(R : Type u) {A : Type v} [comm_ring R] [ring A] [algebra R A] [nontrivial R] {x : A} : is_integral R x → is_algebraic R x"

- doc_string: "**Alias** of the forward direction of le_sub_iff_add_le`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a ≤ c - b → a + b ≤ c"

- doc_string: "For `p ≠ 0, p ≠ 1, `padic_val_int p p` is 1."
  theorem: "{p : ℕ} (hp : 1 < p) : padic_val_int p ↑p = 1"

- doc_string: "A nontrivial monoid is not torsion-free if any nontrivial element has finite order."
  theorem: "(G : Type u_1) [monoid G] : ¬monoid.is_torsion_free G ↔ ∃ (g : G), g ≠ 1 ∧ is_of_fin_order g"

- doc_string: " A nonempty preorder with no maximal element is infinite. This is not an instance to avoid a cycle with `infinite α → nontrivial α → nonempty α`."
  theorem: "{α : Type u_1} [preorder α] [nonempty α] [no_max_order α] : infinite α"

- doc_string: "**Alias** of mul_sub_left_distrib`."
  theorem: "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : a * (b - c) = a * b - a * c"

- doc_string: "**Alias** of the reverse direction of multiset.Ioc_eq_zero_iff`."
  theorem: "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ioc a b = 0"

- doc_string: "A monoid is a submonoid of itself."
  theorem: "{M : Type u_1} [monoid M] : is_submonoid set.univ"

- doc_string: "See `lt_tsub_iff_left_of_le` for a weaker statement in a partial order."
  theorem: "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ c + a < b"

- doc_string: "**Alias** of lt_of_lt_of_le`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : a < b → b ≤ c → a < c"

- doc_string: "For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`."
  theorem: "{α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : y < 1) : ∃ (n : ℕ), y ^ n < x"

- doc_string: "If `s` is bounded, then so is `s ∩ t`"
  theorem: "{α : Type u} [preorder α] {s t : set α} (h : bdd_below s) : bdd_below (s ∩ t)"

- doc_string: "If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2."
  theorem: "(p' : ℕ) : 2 < lucas_lehmer.q (p' + 2)"

- doc_string: "Any map on a subsingleton is an isometry"
  theorem: "{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {f : α → β} [subsingleton α] : isometry f"

- doc_string: "The closure of the interval `(a, +∞)` is the closed interval `[a, +∞)`."
  theorem: "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_max_order α] : closure (set.Ioi a) = set.Ici a"

- doc_string: "`cyclotomic n ℤ` is irreducible."
  theorem: "{n : ℕ} (hpos : 0 < n) : irreducible (polynomial.cyclotomic n ℤ)"

- doc_string: "If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`."
  theorem: "{Γ₀ : Type u_3} [linear_ordered_comm_monoid_with_zero Γ₀] [nontrivial Γ₀] {K : Type u_1} [division_ring K] (v : valuation K Γ₀) {x : K} : ⇑v x = 0 ↔ x = 0"

- doc_string: "A ray does not equal its own negation."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] [no_zero_smul_divisors R M] (x : module.ray R M) : x ≠ -x"

- doc_string: "`{a}.min' _` is `a`."
  theorem: "{α : Type u_1} [linear_order α] (a : α) : {a}.min' _ = a"

- doc_string: "A list with negative sum must have positive length."
  theorem: "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : L.sum < 0) : 0 < L.length"

- doc_string: "If `s` has a greatest element, then it is bounded above."
  theorem: "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_greatest s a) : bdd_above s"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_pos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "An `add_monoid` is an `add_submonoid` of itself."
  theorem: "{M : Type u_1} [add_monoid M] : is_add_submonoid set.univ"

- doc_string: "`option.map f` is injective if `f` is injective."
  theorem: "{α : Type u_1} {β : Type u_2} {f : α → β} (Hf : function.injective f) : function.injective (option.map f)"

- doc_string: "The set of fixed points of the conjugation action of `G` on itself is the center of `G`."
  theorem: "{G : Type u_2} [group G] : mul_action.fixed_points (conj_act G) G = ↑(subgroup.center G)"

- doc_string: "**Alias** of the reverse direction of strict_anti_to_dual_comp_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_mono f → strict_anti (⇑order_dual.to_dual ∘ f)"

- doc_string: "**Alias** of le_of_le_of_eq'`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : b ≤ c → a = b → a ≤ c"

- doc_string: "Bernoulli's inequality for `n : ℕ`, `-2 ≤ a`."
  theorem: "{R : Type u₁} [linear_ordered_ring R] {a : R} (H : -2 ≤ a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n"

- doc_string: "**Alias** of the forward direction of left.one_le_inv_iff`."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ → a ≤ 1"

- doc_string: "If an additive indicator function is not equal to `0` at a point, then that point is in the set."
  theorem: "{α : Type u_1} {M : Type u_4} [has_zero M] {s : set α} {f : α → M} {a : α} (h : s.indicator f a ≠ 0) : a ∈ s"

- doc_string: "Composing two associative operations of `f : α → α → α` on the left is equal to an associative operation on the left."
  theorem: "{α : Type u_1} (f : α → α → α) [is_associative α f] (x y : α) : f x ∘ f y = f (f x y)"

- doc_string: "To match `mul_one_eq_id`."
  theorem: "{M₀ : Type u_1} [mul_zero_class M₀] : (λ (_x : M₀), _x * 0) = function.const M₀ 0"

- doc_string: " One of de Morgan's laws: the negation of a conjunction is logically equivalent to the disjunction of the negations."
  theorem: "{a b : Prop} : ¬(a ∧ b) ↔ ¬a ∨ ¬b"

- doc_string: 'Every pair `![c, d]` of coprime integers is the "bottom_row" of some element `g=[[*,*],[c,d]]` of `SL(2,ℤ)`.'
  theorem: "{R : Type u_1} [comm_ring R] : set.surj_on (λ (g : matrix.special_linear_group (fin 2) R), ↑g 1) set.univ {cd : fin 2 → R | is_coprime (cd 0) (cd 1)}"

- doc_string: "**Alias** of left.one_lt_mul'`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "Given binary relations `r, s` with `r` contained in `s`, the smallest additive congruence relation containing `s` contains the smallest additive congruence relation containing `r`."
  theorem: "{M : Type u_1} [has_add M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : add_con_gen r ≤ add_con_gen s"

- doc_string: " A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` that is less than `x`. A version for preorders is called `not_bdd_below_iff'`."
  theorem: "{α : Type u_1} [linear_order α] {s : set α} : ¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), y < x"

- doc_string: " The cardinality of `fin (bit0 k)` is even, `fact` version. This `fact` is needed as an instance by `matrix.special_linear_group.has_neg`."
  theorem: "{k : ℕ} : fact (even (fintype.card (fin (bit0 k))))"

- doc_string: "`raise l n` is an non-decreasing sequence."
  theorem: "(l : list ℕ) (n : ℕ) : list.sorted has_le.le (denumerable.raise l n)"

- doc_string: "A right-regular element of a `nontrivial` `mul_zero_class` is non-zero."
  theorem: "{R : Type u_1} {a : R} [mul_zero_class R] [nontrivial R] (ra : is_right_regular a) : a ≠ 0"

- doc_string: "A Hausdorff space with a clopen basis is totally separated."
  theorem: "{α : Type u} [topological_space α] [t2_space α] (h : topological_space.is_topological_basis {s : set α | is_clopen s}) : totally_separated_space α"

- doc_string: "**Alias** of the reverse direction of finset.Ioc_eq_empty_iff`."
  theorem: "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ioc a b = ∅"

- doc_string: "**Alias** of the forward direction of lt_inv_mul_iff_mul_lt`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b < a⁻¹ * c → a * b < c"

- doc_string: "If multiplying by `1` on either side is the identity, `1` is regular."
  theorem: "{R : Type u_1} [mul_one_class R] : is_regular 1"

- doc_string: "Construct `has_binary_product Q P` from `has_binary_product P Q`. This can't be an instance, as it would cause a loop in typeclass search."
  theorem: "{C : Type u} [category_theory.category C] (P Q : C) [category_theory.limits.has_binary_product P Q] : category_theory.limits.has_binary_product Q P"

- doc_string: "If X is is_compact then pr₂ : X × Y → Y is a closed map"
  theorem: "{X : Type u_1} [topological_space X] [compact_space X] {Y : Type u_2} [topological_space Y] : is_closed_map prod.snd"

- doc_string: " An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it."
  theorem: "{n : ℕ} : is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n"

- doc_string: "Every point is a fixed point of `id`."
  theorem: "{α : Type u} (x : α) : function.is_fixed_pt id x"

- doc_string: "Extensionality rule for additive congruence relations."
  theorem: "{M : Type u_1} [has_add M] {c d : add_con M} (H : ∀ (x y : M), ⇑c x y ↔ ⇑d x y) : c = d"

- doc_string: "See also `algebra.norm_eq_zero_iff'` if you already have rewritten with `algebra.norm_apply`."
  theorem: "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] [finite_dimensional K L] {x : L} : ⇑(algebra.norm K) x = 0 ↔ x = 0"

- doc_string: "Characterize the equality of points with the vanishing of the nonnegative distance"
  theorem: "{γ : Type w} [metric_space γ] {x y : γ} : has_nndist.nndist x y = 0 ↔ x = y"

- doc_string: "**Alias** of the forward direction of sub_pos`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : 0 < a - b → b < a"

- doc_string: "The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`."
  theorem: "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p (a ^ 2) = 1"

- doc_string: "Dedekind's linear independence of characters"
  theorem: "(G : Type u_1) [monoid G] (L : Type u_2) [comm_ring L] [no_zero_divisors L] : linear_independent L (λ (f : G →* L), ⇑f)"

- doc_string: "The product of any function over an empty set is `1`."
  theorem: "{α : Type u_1} {M : Type u_5} [comm_monoid M] {f : α → M} : finprod (λ (i : α), finprod (λ (H : i ∈ ∅), f i)) = 1"

- doc_string: "The function `x ↦ x⁻¹` tends to `+∞` on the right of `0`."
  theorem: "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (λ (x : α), x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top"

- doc_string: "Composition by an injective function on the left is itself injective."
  theorem: "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {g : β → γ} (hg : function.injective g) : function.injective (function.comp g)"

- doc_string: " If the codomain of an injective function is a subsingleton, then the domain is a subsingleton as well."
  theorem: "{α : Sort u} {β : Sort v} {f : α → β} (hf : function.injective f) [subsingleton β] : subsingleton α"

- doc_string: "Subtracting the point `p` is an injective function."
  theorem: "{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p : P) : function.injective (λ (_x : P), _x -ᵥ p)"

- doc_string: "**Alias** of not_is_max_of_lt`."
  theorem: "{α : Type u_1} [preorder α] {a b : α} (h : a < b) : ¬is_max a"

- doc_string: "If `0 < n`, then `a 1` has order `2 * n`."
  theorem: "{n : ℕ} : order_of (quaternion_group.a 1) = 2 * n"

- doc_string: "A finset is bounded above."
  theorem: "{α : Type u} [semilattice_sup α] [nonempty α] (s : finset α) : bdd_above ↑s"

- doc_string: "If all points are equal to a given point `x`, then `α` is a subsingleton."
  theorem: "{α : Sort u_1} (x : α) (h : ∀ (y : α), y = x) : subsingleton α"

- doc_string: "**Alias** of left.one_lt_mul_of_lt_of_le`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b"

- doc_string: "The intersection of two `add_submonoid`s of an `add_monoid` `M` is an `add_submonoid` of M."
  theorem: "{M : Type u_1} [add_monoid M] {s₁ s₂ : set M} (is₁ : is_add_submonoid s₁) (is₂ : is_add_submonoid s₂) : is_add_submonoid (s₁ ∩ s₂)"

- doc_string: "`same_ray.neg` as an `iff`."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R (-x) (-y) ↔ same_ray R x y"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_neg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "If a direct product has finite order then so does each component."
  theorem: "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_order x) (i : η) : is_of_fin_order (x i)"

- doc_string: "If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`."
  theorem: "{X : Type u_1} [topological_space X] {x y : X} {F : set X} (h : joined_in F x y) : joined ⟨x, _⟩ ⟨y, _⟩"

- doc_string: "**Alias** of the forward direction of measurable_iff_comap_le`."
  theorem: "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → measurable_space.comap f m₂ ≤ m₁"

- doc_string: "**Alias** of the reverse direction of le_sub_iff_add_le'`."
  theorem: "{α : Type u} [add_comm_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ c - a"

- doc_string: "In a semigroup, the product of right-regular elements is right-regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (rra : is_right_regular a) (rrb : is_right_regular b) : is_right_regular (a * b)"

- doc_string: "If two points belong to some set, their edistance is bounded by the diameter of the set"
  theorem: "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (hx : x ∈ s) (hy : y ∈ s) : has_edist.edist x y ≤ emetric.diam s"

- doc_string: " For `f : ℕ → ℝ≥0`, then `∑' k, f (k + i)` tends to zero. This does not require a summability assumption on `f`, as otherwise all sums are zero."
  theorem: "(f : ℕ → nnreal) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)"

- doc_string: "Elements of an add left cancel semigroup are add-left-regular."
  theorem: "{R : Type u_1} [add_left_cancel_semigroup R] (g : R) : is_add_left_regular g"

- doc_string: "A sort of triangle inequality."
  theorem: "{α : Type u} [linear_order α] {a b c : α} : set.interval a c ⊆ set.interval a b ∪ set.interval b c"

- doc_string: "**Alias** of `left.add_neg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "A finite field has prime power cardinality."
  theorem: "{α : Type u_1} [fintype α] [field α] : is_prime_pow (fintype.card α)"

- doc_string: "A group is finitely generated if and only if it is finitely generated as a monoid."
  theorem: "{G : Type u_3} [group G] : group.fg G ↔ monoid.fg G"

- doc_string: "**Alias** of the forward direction of left.one_lt_inv_iff`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : 0 < -a → a < 0"

- doc_string: "The second projection in a product is a topological fiber bundle."
  theorem: "{B : Type u_2} {F : Type u_3} [topological_space B] [topological_space F] : is_topological_fiber_bundle F prod.snd"

- doc_string: "The function `x ^ (1 / x)` tends to `1` at `+∞`."
  theorem: " : filter.tendsto (λ (x : ℝ), x ^ (1 / x)) filter.at_top (nhds 1)"

- doc_string: "A set in a linear ordered field is strictly convex if and only if it is convex."
  theorem: "{𝕜 : Type u_1} [linear_ordered_field 𝕜] [topological_space 𝕜] [order_topology 𝕜] {s : set 𝕜} : strict_convex 𝕜 s ↔ convex 𝕜 s"

- doc_string: "If `C` has a terminal object and binary products, then it has finite products."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] : category_theory.limits.has_finite_products C"

- doc_string: "Extra simp lemma that `dsimp` can use. `simp` will never use this."
  theorem: "{G : Type u_10} [add_group G] (a : G) : ⇑(equiv.symm (equiv.add_right a)) = λ (x : G), x + -a"

- doc_string: "**Alias** of lt_of_le_not_le`."
  theorem: "{α : Type u} [preorder α] {a b : α} : a ≤ b → ¬b ≤ a → a < b"

- doc_string: "A stronger version of `mul_left_injective`"
  theorem: "{α : Type u} [decidable_eq α] (i j : α) : function.involutive (λ (_x : equiv.perm α), _x * equiv.swap i j)"

- doc_string: " If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded below, then `tendsto u at_bot at_bot`."
  theorem: "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u)) : filter.tendsto u filter.at_bot filter.at_bot"

- doc_string: " Right `mul` by a `k : α` over `[ring α]` is injective, if `k` is not a zero divisor. The typeclass that restricts all terms of `α` to have this property is `no_zero_divisors`."
  theorem: "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), x * k = 0 → x = 0) : is_right_regular k"

- doc_string: "**Alias** of btw_cyclic_right`."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_btw.btw a b c) : has_btw.btw c a b"

- doc_string: "See `lt_of_tsub_lt_tsub_right_of_le` for a weaker statement in a partial order."
  theorem: "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] (h : a - c < b - c) : a < b"

- doc_string: "In a locally compact T₂ space, every point has an open neighborhood with compact closure"
  theorem: "{α : Type u} [topological_space α] [locally_compact_space α] [t2_space α] (x : α) : ∃ (U : set α), is_open U ∧ x ∈ U ∧ is_compact (closure U)"

- doc_string: "The real logarithm function tends to `+∞` at `+∞`."
  theorem: " : filter.tendsto real.log filter.at_top filter.at_top"

- doc_string: " An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a unique factorization domain. See `discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization`."
  theorem: "{R : Type u_1} [comm_ring R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) [is_domain R] : unique_factorization_monoid R"

- doc_string: "Dividing out by a prime factor reduces the padic_val_nat by 1."
  theorem: "{p : ℕ} [p_prime : fact (nat.prime p)] {b : ℕ} (dvd : p ∣ b) : padic_val_nat p (b / p) = padic_val_nat p b - 1"

- doc_string: "If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period  `2 * c`."
  theorem: "{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [semiring α] [add_group β] (h : function.antiperiodic f c) : function.periodic f (2 * c)"

- doc_string: "The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`."
  theorem: "{M : Type u_1} [monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_submonoid (s y)) : is_submonoid (set.Inter s)"

- doc_string: "`same_ray` is reflexive."
  theorem: "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] (x : M) : same_ray R x x"

- doc_string: "This lemma is analogous to `quotient.mk_out'`."
  theorem: "{ι : Type u_1} {α : Type u_2} {s : ι → set α} (hs : indexed_partition s) (x : α) : ⇑(hs.out) (hs.proj x) = hs.some (hs.index x)"

- doc_string: "`option α` is a `subsingleton` if and only if `α` is empty."
  theorem: "{α : Type u_1} : subsingleton (option α) ↔ is_empty α"

- doc_string: "**König's theorem**"
  theorem: "{ι : Type u_1} (f g : ι → cardinal) (H : ∀ (i : ι), f i < g i) : cardinal.sum f < cardinal.prod g"

- doc_string: "**Alias** of `left.add_pos'`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "Associative racks are uninteresting."
  theorem: "{R : Type u_1} [rack R] {x y z : R} : shelf.act x (shelf.act y z) = shelf.act (shelf.act x y) z ↔ shelf.act x z = z"

- doc_string: " The Double Negation Theorem: `¬ ¬ P` is equivalent to `P`. The left-to-right direction, double negation elimination (DNE), is classically true but not constructively."
  theorem: "{a : Prop} : ¬¬a ↔ a"

- doc_string: " A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the conclusion of this lemma, you might want to use `topological_space.dense_seq` and `topological_space.dense_range_dense_seq`.  If `α` might be empty, then `exists_countable_dense` is the main way to use separability of `α`."
  theorem: "(α : Type u) [t : topological_space α] [topological_space.separable_space α] [nonempty α] : ∃ (u : ℕ → α), dense_range u"

- doc_string: "Inverses of elements of finite order have finite order."
  theorem: "{G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x"

- doc_string: " `finsupp.single a b` is injective in `b`. For the statement that it is injective in `a`, see `finsupp.single_left_injective`"
  theorem: "{α : Type u_1} {M : Type u_5} [has_zero M] (a : α) : function.injective (finsupp.single a)"

- doc_string: "Rectangles formed by π-systems form a π-system."
  theorem: "{α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_pi_system C) (hD : is_pi_system D) : is_pi_system (set.image2 has_set_prod.prod C D)"

- doc_string: " We can write both `n.factorization p` and `n.factors.count p` to represent the power of `p` in the factorization of `n`: we declare the former to be the simp-normal form. However, since `factorization` is a finsupp it's noncomputable.  This theorem can also be used in reverse to compute values of `factorization n p` when required."
  theorem: "{n p : ℕ} : list.count p n.factors = ⇑(n.factorization) p"

- doc_string: " A set `s` is not bounded above if and only if for each `x` there exists `y ∈ s` such that `x` is not greater than or equal to `y`. This version only assumes `preorder` structure and uses `¬(y ≤ x)`. A version for linear orders is called `not_bdd_above_iff`."
  theorem: "{α : Type u} [preorder α] {s : set α} : ¬bdd_above s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬y ≤ x"

- doc_string: " Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity."
  theorem: "{x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z"

- doc_string: "`int.clog b` and `zpow b` (almost) form a Galois connection."
  theorem: "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : r ≤ ↑b ^ x ↔ int.clog b r ≤ x"

- doc_string: "Induction principle starting at a non-zero number. For maps to a `Sort*` see `le_rec_on`."
  theorem: "{P : ℕ → Prop} {m : ℕ} (h0 : P m) (h1 : ∀ (n : ℕ), m ≤ n → P n → P (n + 1)) (n : ℕ) : m ≤ n → P n"

- doc_string: "Inverses of elements of finite additive order have finite additive order."
  theorem: "{G : Type u} [add_group G] {x : G} : is_of_fin_add_order (-x) ↔ is_of_fin_add_order x"

- doc_string: "The minimal distance to a set is continuous in point"
  theorem: "{α : Type u} [pseudo_metric_space α] (s : set α) : continuous (λ (x : α), metric.inf_dist x s)"

- doc_string: "**Alias** of the reverse direction of measurable_iff_comap_le`."
  theorem: "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable_space.comap f m₂ ≤ m₁ → measurable f"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_zero_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a * b"

- doc_string: " The auxiliary set corresponding to the composition of partial sums asymptotically contains all possible compositions."
  theorem: " : filter.tendsto (λ (N : ℕ), formal_multilinear_series.comp_partial_sum_target 0 N N) filter.at_top filter.at_top"

- doc_string: "A finitely presented algebra is of finite type."
  theorem: "{R : Type u_1} {A : Type u_2} [comm_ring R] [comm_ring A] [algebra R A] : algebra.finite_presentation R A → algebra.finite_type R A"

- doc_string: "`a < b` as natural numbers if and only if `a < b` in `fin n`."
  theorem: "{n : ℕ} {a b : fin n} : ↑a < ↑b ↔ a < b"

- doc_string: "Right multiplication in a ring is an additive monoid morphism."
  theorem: "{γ : Type u_1} [non_unital_non_assoc_semiring γ] (x : γ) : is_add_monoid_hom (λ (y : γ), y * x)"

- doc_string: "**Alias** of lt_or_eq_of_le`."
  theorem: "{α : Type u} [partial_order α] {a b : α} : a ≤ b → a < b ∨ a = b"

- doc_string: "See also `continuous_map.continuous_eval_const`"
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] (a : α) : continuous (λ (f : C(α, β)), ⇑f a)"

- doc_string: "**Alias** of the forward direction of order.pred_lt_pred_iff`."
  theorem: "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a < order.pred b → a < b"

- doc_string: "Given two elements `b`, `c` of a `cancel_monoid_with_zero` and a nonzero element `a`, `a*b` divides `a*c` iff `b` divides `c`."
  theorem: "{α : Type u_1} [cancel_monoid_with_zero α] {a b c : α} (ha : a ≠ 0) : a * b ∣ a * c ↔ b ∣ c"

- doc_string: " Commutativity of additive actions is a symmetric relation. This lemma can't be an instance because this would cause a loop in the instance search graph."
  theorem: "(M : Type u_1) (N : Type u_2) (α : Type u_3) [has_vadd M α] [has_vadd N α] [vadd_comm_class M N α] : vadd_comm_class N M α"

- doc_string: "In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left    associates of `b`."
  theorem: "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : a ∣ u * b ↔ a ∣ b"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 < a) : 1 ≤ a * b"

- doc_string: "The intersection of an open dense set with a dense set is a dense set."
  theorem: "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hso : is_open s) : dense (s ∩ t)"

- doc_string: "An element `a` is `M`-regular if and only if a positive power of `a` is `M`-regular."
  theorem: "{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] {n : ℕ} (n0 : 0 < n) : is_smul_regular M (a ^ n) ↔ is_smul_regular M a"

- doc_string: "Taylor's formula."
  theorem: "{R : Type u_1} [comm_ring R] (f : polynomial R) (r : R) : (⇑(polynomial.taylor r) f).sum (λ (i : ℕ) (a : R), ⇑polynomial.C a * (polynomial.X - ⇑polynomial.C r) ^ i) = f"

- doc_string: "Any element additively semiconjugates `0` to `0`."
  theorem: "{M : Type u} [add_zero_class M] (a : M) : add_semiconj_by a 0 0"

- doc_string: " The `n+1`-th iterated derivative can be obtained by taking the `n`-th derivative of the derivative."
  theorem: "{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = iterated_deriv n (deriv f)"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (a0 : 0 ≤ a) : 1 ≤ a * b"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_nonneg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b"

- doc_string: " The main proof-by-reflection theorem. Given reflected csring expressions `r₁` and `r₂` plus a storage `t` of atoms, if both expressions go to the same Horner normal form, then the original non-reflected expressions are equal. `H` follows from kernel reduction and is therefore `rfl`."
  theorem: "{α : Type u_1} [comm_semiring α] (t : tree α) (r₁ r₂ : tactic.ring2.csring_expr) (H : tactic.ring2.horner_expr.of_csexpr r₁ = tactic.ring2.horner_expr.of_csexpr r₂) : tactic.ring2.csring_expr.eval t r₁ = tactic.ring2.csring_expr.eval t r₂"

- doc_string: "An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring."
  theorem: "{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R"

- doc_string: "We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`."
  theorem: "{R : Type u_1} [non_assoc_semiring R] [nontrivial R] (hR : ring_char R ≠ 2) : 2 ≠ 0"

- doc_string: "`of_fn` on an empty domain is the empty list."
  theorem: "{α : Type u} (f : fin 0 → α) : list.of_fn f = list.nil"

- doc_string: "In a commutative monoid, an element `a` divides an element `b` iff all  left associates of `a` divide `b`."
  theorem: "{α : Type u_1} [comm_monoid α] (a b u : α) (hu : is_unit u) : u * a ∣ b ↔ a ∣ b"

- doc_string: "Harmonic series is not unconditionally summable."
  theorem: " : ¬summable (λ (n : ℕ), (↑n)⁻¹)"

- doc_string: "The characteristic equals the exponential characteristic iff the former is prime."
  theorem: "(R : Type u) [semiring R] (p q : ℕ) [hp : char_p R p] [hq : exp_char R q] : p = q ↔ nat.prime p"

- doc_string: "If `X` has subobject lattice `{⊥, ⊤}`, then `X` is simple."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] (X : C) [is_simple_order (category_theory.subobject X)] : category_theory.simple X"

- doc_string: "If a category has all binary coproducts and all coequalizers, then it also has all pushouts.    As usual, this is not an instance, since there may be a more direct way to construct    pushouts."
  theorem: "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_pushouts C"

- doc_string: "The inverse of a group homomorphism is a group homomorphism if the target is commutative."
  theorem: "{α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f : α → β} (hf : is_group_hom f) : is_group_hom (λ (a : α), (f a)⁻¹)"

- doc_string: " The product of a list of positive natural numbers is positive, and likewise for any nontrivial ordered semiring."
  theorem: "{R : Type u_8} [ordered_semiring R] [nontrivial R] (l : list R) (h : ∀ (a : R), a ∈ l → 0 < a) : 0 < l.prod"

- doc_string: "If a subgroup of a topological group has `1` in its interior, then it is open."
  theorem: "{G : Type u_1} [group G] [topological_space G] [topological_group G] {H : subgroup G} (h_1_int : 1 ∈ interior ↑H) : is_open ↑H"

- doc_string: "The cross product of two vectors is perpendicular to the first vector."
  theorem: "{R : Type u_1} [comm_ring R] (v w : fin 3 → R) : matrix.dot_product v (⇑(⇑cross_product v) w) = 0"

- doc_string: "**Alias** of the forward direction of is_compact_iff_ultrafilter_le_nhds`."
  theorem: "{α : Type u} [topological_space α] {s : set α} : is_compact s → ∀ (f : ultrafilter α), ↑f ≤ filter.principal s → (∃ (a : α) (H : a ∈ s), ↑f ≤ nhds a)"

- doc_string: "There is no surjection from `α : Type u` into `Type u`. This theorem  demonstrates why `Type : Type` would be inconsistent in Lean."
  theorem: "{α : Type u} (f : α → Type (max u v)) : ¬function.surjective f"

- doc_string: "See also `continuous_map.continuous_eval'`"
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] : continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)"

- doc_string: " The inverse of a map which preserves multiplication, preserves multiplication when the target is commutative."
  theorem: "{α : Type u_1} {β : Type u_2} [has_mul α] [comm_group β] {f : α → β} (hf : is_mul_hom f) : is_mul_hom (λ (a : α), (f a)⁻¹)"

- doc_string: "The set of natural number powers of an element of a monoid `M` is a submonoid of `M`."
  theorem: "{M : Type u_1} [monoid M] (x : M) : is_submonoid (powers x)"

- doc_string: "Zero additively semiconjugates any element to itself."
  theorem: "{M : Type u} [add_zero_class M] (x : M) : add_semiconj_by 0 x x"

- doc_string: "`int.clog b` and `zpow b` (almost) form a Galois connection."
  theorem: "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x < r ↔ x < int.clog b r"

- doc_string: "If `t` is bounded, then so is `s ∩ t`"
  theorem: "{α : Type u} [preorder α] {s t : set α} (h : bdd_below t) : bdd_below (s ∩ t)"

- doc_string: "If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism. The converse of `is_subterminal_of_mono_terminal_from`."
  theorem: "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] (hA : category_theory.is_subterminal A) : category_theory.mono (category_theory.limits.terminal.from A)"

- doc_string: "The image of an `add_monoid` hom is an `add_submonoid` of the codomain."
  theorem: "{M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] {f : M → γ} (hf : is_add_monoid_hom f) : is_add_submonoid (set.range f)"

- doc_string: "Equality behind `commute a b`; useful for rewriting."
  theorem: "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : a * b = b * a"

- doc_string: "The determinant of `conj_lie`, as a linear map."
  theorem: " : ⇑linear_map.det ↑(complex.conj_lie.to_linear_equiv) = -1"

- doc_string: "`dvd` is injective in the left argument"
  theorem: " : function.injective has_dvd.dvd"

- doc_string: " The sequential closure of a set is contained in the closure of that set. The converse is not true."
  theorem: "{X : Type u_1} [topological_space X] (s : set X) : seq_closure s ⊆ closure s"

- doc_string: "The composition of `quotient.mk` and a function with dense range has dense range."
  theorem: "{α : Type u} {β : Type v} [setoid α] [topological_space α] {f : β → α} (hf : dense_range f) : dense_range (quotient.mk ∘ f)"

- doc_string: "**Alias** of `left.add_pos_of_nonneg_of_pos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b"

- doc_string: " **Hausdorff's maximality principle**  There exists a maximal totally ordered set of `α`. Note that we do not require `α` to be partially ordered by `r`."
  theorem: "{α : Type u_1} {r : α → α → Prop} : is_max_chain r (max_chain r)"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_mono α] (ha : a < 1) (hb : b ≤ 1) (a0 : 0 < a) : a * b < 1"

- doc_string: "**Alias** of the reverse direction of is_min_to_dual_iff`."
  theorem: "{α : Type u_1} [has_le α] {a : α} : is_max a → is_min (⇑order_dual.to_dual a)"

- doc_string: "Indexed version of the above lemma `exists_lt_of_lt_cSup`. When `b < supr f`, there is an element `i` such that `b < f i`."
  theorem: "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {b : α} [nonempty ι] {f : ι → α} (h : b < supr f) : ∃ (i : ι), b < f i"

- doc_string: "A closed interval in a densely ordered conditionally complete linear order is preconnected."
  theorem: "{α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a b : α} : is_preconnected (set.Icc a b)"

- doc_string: "Two filters are equal when their underlying sets are equal."
  theorem: "{P : Type u_1} [preorder P] (s t : order.pfilter P) (h : ↑s = ↑t) : s = t"

- doc_string: " In a linear ordered field, for positive `a` and `b` we have `a⁻¹ ≤ b ↔ b⁻¹ ≤ a`. See also `inv_le_of_inv_le` for a one-sided implication with one fewer assumption."
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b ↔ b⁻¹ ≤ a"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_nonneg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b"

- doc_string: "A finite dimensional space has positive `finrank` iff it is nontrivial."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ nontrivial V"

- doc_string: "The range of any family of ordinals is bounded above. See also `lsub_not_mem_range`."
  theorem: "{ι : Type u} (f : ι → ordinal) : bdd_above (set.range f)"

- doc_string: "**Alias** of the forward direction of is_extr_filter_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_extr_filter (⇑order_dual.to_dual ∘ f) l a → is_extr_filter f l a"

- doc_string: "Given two elements `a`, `b` of a commutative `cancel_monoid_with_zero` and a nonzero  element `c`, `a*c` divides `b*c` iff `a` divides `b`."
  theorem: "{α : Type u_1} [cancel_comm_monoid_with_zero α] {a b c : α} (hc : c ≠ 0) : a * c ∣ b * c ↔ a ∣ b"

- doc_string: "Any partial order can be extended to a linear order."
  theorem: "{α : Type u} (r : α → α → Prop) [is_partial_order α r] : ∃ (s : α → α → Prop) (_x : is_linear_order α s), r ≤ s"

- doc_string: "If `a` commutes with both `b` and `c`, then it commutes with their product."
  theorem: "{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)"

- doc_string: "The sum of any function over an empty set is `0`."
  theorem: "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} : finsum (λ (i : α), finsum (λ (H : i ∈ ∅), f i)) = 0"

- doc_string: "The zeroth Pythagorean triple is all zeros."
  theorem: " : pythagorean_triple 0 0 0"

- doc_string: "If a 2-vector `p` satisfies `is_coprime (p 0) (p 1)`, then `p ≠ 0`."
  theorem: "{R : Type u} [comm_semiring R] [nontrivial R] {p : fin 2 → R} (h : is_coprime (p 0) (p 1)) : p ≠ 0"

- doc_string: "Adding a point to a set preserves its boundedness below."
  theorem: "{γ : Type w} [semilattice_inf γ] (a : γ) {s : set γ} : bdd_below (has_insert.insert a s) ↔ bdd_below s"

- doc_string: "A finite group of prime order is simple."
  theorem: "{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_simple_group α"

- doc_string: "**Kaminski's Equation**"
  theorem: "(f : bool → bool) (x : bool) : f (f (f x)) = f x"

- doc_string: "**Alias** of ge_antisymm`."
  theorem: "{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≤ a → b = a"

- doc_string: "TODO: Generalise to `finite_cancel_monoid`."
  theorem: "{G : Type u} {x : G} {n : ℕ} [fintype G] [group G] : x ^ n = 1 ↔ x ^ n.gcd (fintype.card G) = 1"

- doc_string: " If `p` is a prime such that `p ∣ n`, then `expand R p (cyclotomic n R) = cyclotomic (p * n) R`."
  theorem: "{p n : ℕ} (hp : nat.prime p) (hdiv : p ∣ n) (R : Type u_1) [comm_ring R] : ⇑(polynomial.expand R p) (polynomial.cyclotomic n R) = polynomial.cyclotomic (n * p) R"

- doc_string: "The element `0` is `M`-regular if and only if `M` is trivial."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] (h : is_smul_regular M 0) : subsingleton M"

- doc_string: "A module has dimension 1 iff there is some `v : V` so `{v}` is a basis."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (ι : Type u_1) [unique ι] : finite_dimensional.finrank K V = 1 ↔ nonempty (basis ι K V)"

- doc_string: "Elements of finite order are closed under multiplication."
  theorem: "{G : Type u} {x y : G} [comm_monoid G] (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)"

- doc_string: " The localization at of an integral domain to a set of non-zero elements is an integral domain. See note [reducible non-instances]."
  theorem: "{A : Type u_6} [comm_ring A] [is_domain A] {M : submonoid A} (hM : M ≤ non_zero_divisors A) : is_domain (localization M)"

- doc_string: "**Alias** of mul_sub_right_distrib`."
  theorem: "{α : Type u} [non_unital_non_assoc_ring α] (a b c : α) : (a - b) * c = a * c - b * c"

- doc_string: "A map of rings that is a semiring homomorphism is also a ring homomorphism."
  theorem: "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (H : is_semiring_hom f) : is_ring_hom f"

- doc_string: "**Alias** of the reverse direction of tsub_nonpos`."
  theorem: "{α : Type u_1} [preorder α] [add_comm_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} : a ≤ b → a - b ≤ 0"

- doc_string: "In a preadditive category, if the product of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_product X Y] : category_theory.limits.has_binary_biproduct X Y"

- doc_string: "A nontrivial finite dimensional space has positive `finrank`."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] [h : nontrivial V] : 0 < finite_dimensional.finrank K V"

- doc_string: "The second projection in a product of topological spaces sends open sets to open sets."
  theorem: "{α : Type u} {β : Type v} [topological_space α] [topological_space β] : is_open_map prod.snd"

- doc_string: "Direct products of torsion free groups are torsion free."
  theorem: "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)"

- doc_string: " Shows that the recurrence relation (`convergents`) and direct evaluation (`convergents'`) of a (regular) continued fraction coincide."
  theorem: "{K : Type u_1} [linear_ordered_field K] {c : continued_fraction K} : ↑c.convergents = ↑c.convergents'"

- doc_string: "**Alias** of the reverse direction of left.one_lt_inv_iff`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a < 1 → 1 < a⁻¹"

- doc_string: "The union of two bounded sets is bounded."
  theorem: "{α : Type u} [pseudo_metric_space α] {s t : set α} (hs : metric.bounded s) (ht : metric.bounded t) : metric.bounded (s ∪ t)"

- doc_string: "A version of `nat.exists_infinite_primes` using the `bdd_above` predicate."
  theorem: " : ¬bdd_above {p : ℕ | nat.prime p}"

- doc_string: "**Alias** of the forward direction of left.inv_lt_one_iff`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 → 1 < a"

- doc_string: "**Alias** of the forward direction of is_extr_on_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_extr_on (⇑order_dual.to_dual ∘ f) s a → is_extr_on f s a"

- doc_string: " Theorems about `padic_norm_e` are named with a `'` so the names do not conflict with the equivalent theorems about `norm` (`∥ ∥`)."
  theorem: "{p : ℕ} [fact (nat.prime p)] : padic_norm_e 1 = 1"

- doc_string: " A version of `comm` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there."
  theorem: "{α : Type u} (r : α → α → Prop) [is_symm α r] {a b : α} : r a b ↔ r b a"

- doc_string: "For natural numbers the filters `cofinite` and `at_top` coincide."
  theorem: " : filter.cofinite = filter.at_top"

- doc_string: "A variant"
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = -1 ↔ ¬char.quadratic_char F a = 1"

- doc_string: "**Alias** of the forward direction of is_square_iff_exists_sq`."
  theorem: "{α : Type u_2} [monoid α] (m : α) : is_square m → (∃ (c : α), m = c ^ 2)"

- doc_string: "**Alias** of left.one_lt_mul_of_le_of_lt`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b"

- doc_string: "The cardinality of a quaternion algebra, as a type."
  theorem: "{R : Type u_1} (c₁ c₂ : R) : cardinal.mk (quaternion_algebra R c₁ c₂) = cardinal.mk R ^ 4"

- doc_string: "A strongly measurable function is measurable."
  theorem: "{α : Type u_1} {β : Type u_2} {f : α → β} {m : measurable_space α} [topological_space β] [topological_space.pseudo_metrizable_space β] [measurable_space β] [borel_space β] (hf : measure_theory.strongly_measurable f) : measurable f"

- doc_string: "Cauchy condensation test for a series of `nnreal` version."
  theorem: "{f : ℕ → nnreal} (hf : ∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) : summable (λ (k : ℕ), 2 ^ k * f (2 ^ k)) ↔ summable f"

- doc_string: "**Alias** of left.mul_le_one`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1"

- doc_string: "**Alias** of left.inv_le_one_iff`."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a"

- doc_string: " A `comm_ring` `K` which is the localization of an integral domain `R` at `R - {0}` is an integral domain."
  theorem: "(A : Type u_4) [comm_ring A] [is_domain A] {K : Type u_5} [comm_ring K] [algebra A K] [is_fraction_ring A K] : is_domain K"

- doc_string: "A free module with a basis indexed by a `fintype` is finite."
  theorem: "{R : Type u_1} {M : Type u_2} {ι : Type u_3} [comm_ring R] [add_comm_group M] [module R M] [fintype ι] (b : basis ι R M) : module.finite R M"

- doc_string: "  If an element `b` becomes right-regular after multiplying it on the right by a right-regular element, then `b` is right-regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (ab : is_right_regular (b * a)) : is_right_regular b"

- doc_string: "`pow b` and `log b` (almost) form a Galois connection."
  theorem: "{b : ℕ} (hb : 1 < b) {x y : ℕ} (hy : 0 < y) : b ^ x ≤ y ↔ x ≤ nat.log b y"

- doc_string: "monotonicity of `≤` with respect to `→`"
  theorem: "{α : Type u} {a b c d : α} [preorder α] (hca : c ≤ a) (hbd : b ≤ d) : a ≤ b → c ≤ d"

- doc_string: " The comap of the cocompact filter on `β` by a continuous function `f : α → β` is less than or equal to the cocompact filter on `α`. This is a reformulation of the fact that images of compact sets are compact."
  theorem: "{α : Type u} {β : Type v} [topological_space α] [topological_space β] {f : α → β} (hf : continuous f) : filter.comap f (filter.cocompact β) ≤ filter.cocompact α"

- doc_string: "**Alias** of the forward direction of is_max_on_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_max_on (⇑order_dual.to_dual ∘ f) s a → is_min_on f s a"

- doc_string: "**Alias** of sbtw_of_btw_not_btw`."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c : α} (habc : has_btw.btw a b c) (hcba : ¬has_btw.btw c b a) : has_sbtw.sbtw a b c"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 < b) : 1 ≤ a * b"

- doc_string: "If `p ∤ a`, then `legendre_sym p a` is `1` or `-1`."
  theorem: "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ∨ zmod.legendre_sym p a = -1"

- doc_string: "**Alias** of the reverse direction of is_bot_to_dual_iff`."
  theorem: "{α : Type u_1} [has_le α] {a : α} : is_top a → is_bot (⇑order_dual.to_dual a)"

- doc_string: "**Alias** of the forward direction of odd_iff_exists_bit1`."
  theorem: "{α : Type u_2} [semiring α] {a : α} : odd a → (∃ (b : α), a = bit1 b)"

- doc_string: "A rewrite lemma for `padic_val_nat p (q * r)` with conditions `q ≠ 0`, `r ≠ 0`."
  theorem: "(p : ℕ) [p_prime : fact (nat.prime p)] {q r : ℕ} (hq : q ≠ 0) (hr : r ≠ 0) : padic_val_nat p (q * r) = padic_val_nat p q + padic_val_nat p r"

- doc_string: "Deprecated: use `fun_like.congr_fun` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] {f g : add_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x"

- doc_string: " To show a category is a `initial_mono_class` it suffices to show every morphism out of the initial object is a monomorphism."
  theorem: "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] (h : ∀ (X : C), category_theory.mono (category_theory.limits.initial.to X)) : category_theory.limits.initial_mono_class C"

- doc_string: "Uniformizers are nonzero."
  theorem: "{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (K : Type u_2) [field K] [algebra R K] [is_fraction_ring R K] (v : is_dedekind_domain.height_one_spectrum R) : classical.some _ ≠ 0"

- doc_string: "In the model space, the identity is in any maximal atlas."
  theorem: "{H : Type u} [topological_space H] (G : structure_groupoid H) : local_homeomorph.refl H ∈ structure_groupoid.maximal_atlas H G"

- doc_string: "Two elements are related by a congruence relation `c` iff they are represented by the same    element of the quotient by `c`."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b"

- doc_string: "A fixed point of `f` is a periodic point of `f` of any prescribed period."
  theorem: "{α : Type u_1} {f : α → α} {x : α} (hf : function.is_fixed_pt f x) (n : ℕ) : function.is_periodic_pt f n x"

- doc_string: "Uses `left` co(ntra)variant."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a"

- doc_string: "Two elements `a` and `b` are add-regular if and only if both sums `a + b` and `b + a` are add-regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] : is_add_regular (a + b) ∧ is_add_regular (b + a) ↔ is_add_regular a ∧ is_add_regular b"

- doc_string: "**Alias** of the forward direction of inv_mul_lt_iff_lt_mul`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : -b + a < c → a < b + c"

- doc_string: "**Alias** of sq_sub_sq`."
  theorem: "{R : Type u₁} [comm_ring R] (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)"

- doc_string: "Finset **stars and bars** for the case `n = 2`."
  theorem: "{α : Type u_1} [decidable_eq α] (s : finset α) : s.sym2.card = s.card * (s.card + 1) / 2"

- doc_string: "A compact set is bounded above"
  theorem: "{α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [nonempty α] {s : set α} (hs : is_compact s) : bdd_above s"

- doc_string: "The prime factorizations of coprime `a` and `b` are disjoint"
  theorem: "{a b : ℕ} (hab : a.coprime b) : disjoint a.factorization.support b.factorization.support"

- doc_string: "**Alias** of the forward direction of is_min_filter_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_min_filter (⇑order_dual.to_dual ∘ f) l a → is_max_filter f l a"

- doc_string: "**Alias** of eq_of_ge_of_not_gt`."
  theorem: "{α : Type u} [partial_order α] {a b : α} (hab : a ≤ b) (hba : ¬a < b) : b = a"

- doc_string: "The function `exp(x)/x^n` tends to `+∞` at `+∞`, for any natural number `n`"
  theorem: "(n : ℕ) : filter.tendsto (λ (x : ℝ), real.exp x / x ^ n) filter.at_top filter.at_top"

- doc_string: "A version of `measurable_sub_const` that assumes `has_measurable_add` instead of  `has_measurable_sub`. This can be nice to avoid unnecessary type-class assumptions."
  theorem: "{G : Type u_1} [sub_neg_monoid G] [measurable_space G] [has_measurable_add G] (g : G) : measurable (λ (h : G), h - g)"

- doc_string: "Shows that the integer parts of the stream are at least one."
  theorem: "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_succ_n : generalized_continued_fraction.int_fract_pair K} (succ_nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v (n + 1) = option.some ifp_succ_n) : 1 ≤ ifp_succ_n.b"

- doc_string: " Rewriting equality in the dependent type `Σ (a : composition n), composition a.length)` in non-dependent terms with lists, requiring that the blocks coincide."
  theorem: "{n : ℕ} (i j : Σ (a : composition n), composition a.length) : i = j ↔ i.fst.blocks = j.fst.blocks ∧ i.snd.blocks = j.snd.blocks"

- doc_string: "The lower central series of a group is a descending central series."
  theorem: "{G : Type u_1} [group G] : is_descending_central_series (lower_central_series G)"

- doc_string: " The polar `polar 𝕜 s` of a set `s : E` is a closed subset when the weak star topology is used."
  theorem: "(𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] {E : Type u_2} [semi_normed_group E] [normed_space 𝕜 E] (s : set E) : is_closed (weak_dual.polar 𝕜 s)"

- doc_string: " The order of the `↔` has been chosen so that `rw sbtw_cyclic` cycles to the right while `rw ←sbtw_cyclic` cycles to the left (thus following the prepended arrow)."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c : α} : has_sbtw.sbtw a b c ↔ has_sbtw.sbtw c a b"

- doc_string: "Over a ring `R` of characteristic zero, `λ n, cyclotomic n R` is injective."
  theorem: "{R : Type u_1} [comm_ring R] [char_zero R] : function.injective (λ (n : ℕ), polynomial.cyclotomic n R)"

- doc_string: "The intersection of a compact set and a closed set is a compact set."
  theorem: "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)"

- doc_string: "`padic_val_int p 0` is 0 for any `p`."
  theorem: "{p : ℕ} : padic_val_int p 0 = 0"

- doc_string: "The 0 of the quotient of an `add_monoid` by an additive congruence relation is the equivalence class of the `add_monoid`'s 0."
  theorem: "{M : Type u_1} [add_zero_class M] {c : add_con M} : ↑0 = 0"

- doc_string: " Euclid's lemma: if `a ∣ b * c` and `gcd a c = 1` then `a ∣ b`. Compare with `is_coprime.dvd_of_dvd_mul_left` and `unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors`"
  theorem: "{a b c : ℤ} (habc : a ∣ b * c) (hab : a.gcd c = 1) : a ∣ b"

- doc_string: "`nndist x x` vanishes"
  theorem: "{α : Type u} [pseudo_metric_space α] (a : α) : has_nndist.nndist a a = 0"

- doc_string: "In a monoid with zero, if zero equals one, then zero is the only element."
  theorem: "{M₀ : Type u_1} [mul_zero_one_class M₀] (h : 0 = 1) (a : M₀) : a = 0"

- doc_string: "The functor Compactum_to_CompHaus is faithful."
  theorem: " : category_theory.faithful Compactum_to_CompHaus"

- doc_string: "`∨` distributes over `∧` (on the right)."
  theorem: "{a b c : Prop} : a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)"

- doc_string: "**Alias** of the forward direction of le_inv_mul_iff_mul_le`."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a b c : α} : b ≤ a⁻¹ * c → a * b ≤ c"

- doc_string: "An element of a monoid is in the set of that element's natural number powers."
  theorem: "{M : Type u_1} [monoid M] {x : M} : x ∈ powers x"

- doc_string: "Determinant of 0x0 matrix"
  theorem: "{R : Type v} [comm_ring R] {A : matrix (fin 0) (fin 0) R} : A.det = 1"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_lt_one_of_le_of_lt`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : a ≤ 1) (hb : b < 1) : a * b < 1"

- doc_string: "`-a ≤ b ↔ -b ≤ a` on `ereal`."
  theorem: "{a b : ereal} : -a ≤ b ↔ -b ≤ a"

- doc_string: "Addition of a `u : add_units M` on the right doesn't affect `is_add_unit`."
  theorem: "{M : Type u_1} [add_monoid M] (a : M) (u : add_units M) : is_add_unit (a + ↑u) ↔ is_add_unit a"

- doc_string: "**Cantor's theorem**"
  theorem: "(a : cardinal) : a < 2 ^ a"

- doc_string: "If a direct product has finite additive order then so does each component."
  theorem: "{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_monoid (Gs i)] {x : Π (i : η), Gs i} (h : is_of_fin_add_order x) (i : η) : is_of_fin_add_order (x i)"

- doc_string: "The cross product of two vectors is perpendicular to the second vector."
  theorem: "{R : Type u_1} [comm_ring R] (v w : fin 3 → R) : matrix.dot_product w (⇑(⇑cross_product v) w) = 0"

- doc_string: " If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded above, then `tendsto u at_top at_top`."
  theorem: "{ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u)) : filter.tendsto u filter.at_top filter.at_top"

- doc_string: "Multiplicative congruence relations preserve multiplication."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w * y) (x * z)"

- doc_string: "**Alias** of the reverse direction of sub_lt_iff_lt_add'`."
  theorem: "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a < b + c → a - b < c"

- doc_string: "The determinant of `conj_lie`, as a linear equiv."
  theorem: " : ⇑linear_equiv.det complex.conj_lie.to_linear_equiv = -1"

- doc_string: "The p-adic value of an natural is its p-adic_value as an integer"
  theorem: "{p n : ℕ} : padic_val_int p ↑n = padic_val_nat p n"

- doc_string: "See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption."
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ ≤ b⁻¹ ↔ b ≤ a"

- doc_string: "Inversion is a group homomorphism if the group is commutative."
  theorem: "{α : Type u} [comm_group α] : is_group_hom has_inv.inv"

- doc_string: "The closure of a totally bounded set is totally bounded."
  theorem: "{α : Type u} [uniform_space α] {s : set α} (h : totally_bounded s) : totally_bounded (closure s)"

- doc_string: "The function `x ^ (-1 / x)` tends to `1` at `+∞`."
  theorem: " : filter.tendsto (λ (x : ℝ), x ^ ((-1) / x)) filter.at_top (nhds 1)"

- doc_string: " The set of cluster points of a filter is closed. In particular, the set of limit points of a sequence is closed."
  theorem: "{α : Type u} [topological_space α] {f : filter α} : is_closed {x : α | cluster_pt x f}"

- doc_string: "**Alias** of not_lt_of_le`."
  theorem: "{α : Type u} [preorder α] {a b : α} (h : a ≤ b) : ¬b < a"

- doc_string: "If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`."
  theorem: "{α : Type u} {f g : α → α} {x : α} (hf : function.is_fixed_pt f x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt (f ∘ g) x"

- doc_string: "The intersection of an indexed set of `add_submonoid`s of an `add_monoid` `M` is an `add_submonoid` of `M`."
  theorem: "{M : Type u_1} [add_monoid M] {ι : Sort u_2} {s : ι → set M} (h : ∀ (y : ι), is_add_submonoid (s y)) : is_add_submonoid (set.Inter s)"

- doc_string: "Deprecated: use `fun_like.ext_iff` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} : f = g ↔ ∀ (x : M), ⇑f x = ⇑g x"

- doc_string: " Composing an independent indexed family with an injective function on the index results in another indepedendent indexed family."
  theorem: "{ι : Sort u_1} {ι' : Sort u_2} {α : Type u_3} [complete_lattice α] {s : ι → α} (hs : complete_lattice.independent s) (f : ι' → ι) (hf : function.injective f) : complete_lattice.independent (s ∘ f)"

- doc_string: "Ordinals that are cardinals are unbounded."
  theorem: " : set.unbounded has_lt.lt {b : ordinal | b.card.ord = b}"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a : α} : a⁻¹ < 1 ↔ 1 < a"

- doc_string: "The closure of a set `s` is dense if and only if `s` is dense."
  theorem: "{α : Type u} [topological_space α] {s : set α} : dense (closure s) ↔ dense s"

- doc_string: "**Alias** of the reverse direction of left.one_lt_inv_iff`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : a < 0 → 0 < -a"

- doc_string: "When `p ∤ a`, then `legendre_sym p a = 1` iff `a` is a square mod `p`."
  theorem: "(p : ℕ) [fact (nat.prime p)] {a : ℤ} (ha0 : ↑a ≠ 0) : zmod.legendre_sym p a = 1 ↔ is_square ↑a"

- doc_string: "In a sequential space, continuity and sequential continuity coincide."
  theorem: "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : continuous f ↔ seq_continuous f"

- doc_string: "**Alias** of le_of_eq_of_le`."
  theorem: "{α : Type u} [preorder α] {a b c : α} (hab : a = b) (hbc : b ≤ c) : a ≤ c"

- doc_string: "See `int.induction_on'` for an induction in both directions."
  theorem: "{P : ℤ → Prop} {m : ℤ} (h0 : P m) (h1 : ∀ (n : ℤ), m ≤ n → P n → P (n + 1)) (n : ℤ) : m ≤ n → P n"

- doc_string: "The `0` element is not `M`-regular, on a non-trivial module."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : ¬is_smul_regular M 0 ↔ nontrivial M"

- doc_string: "A space is totally disconnected iff its connected components are singletons."
  theorem: "{α : Type u} [topological_space α] : totally_disconnected_space α ↔ ∀ (x : α), connected_component x = {x}"

- doc_string: "An additive group homomorphism sends 0 to 0."
  theorem: "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0"

- doc_string: " The Roth number is a subadditive function. Note that by Fekete's lemma this shows that the limit `roth_number_nat N / N` exists, but Roth's theorem gives the stronger result that this limit is actually `0`."
  theorem: "(M N : ℕ) : ⇑roth_number_nat (M + N) ≤ ⇑roth_number_nat M + ⇑roth_number_nat N"

- doc_string: "The diameter is monotonous with respect to inclusion"
  theorem: "{α : Type u} [pseudo_emetric_space α] {s t : set α} (h : s ⊆ t) : emetric.diam s ≤ emetric.diam t"

- doc_string: "A field extension is algebraic if it is finite."
  theorem: "(K : Type u_1) (L : Type u_2) [field K] [field L] [algebra K L] [finite : finite_dimensional K L] : algebra.is_algebraic K L"

- doc_string: " If two words have a common maximal reduction, then they correspond to the same element in the free group."
  theorem: "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.reduce L₁ = free_group.reduce L₂) : free_group.mk L₁ = free_group.mk L₂"

- doc_string: "The exponential map in `𝕂 = ℝ` or `𝕂 = ℂ` has strict derivative `1` at zero."
  theorem: "{𝕂 : Type u_1} [is_R_or_C 𝕂] : has_strict_deriv_at (exp 𝕂) 1 0"

- doc_string: " In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its `finrank`."
  theorem: "(K : Type u) (V : Type v) [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : ↑(finite_dimensional.finrank K V) = module.rank K V"

- doc_string: "**Alias** of `left.add_pos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "Given a map `f : N → M` and an equivalence relation `r` on `β`, the equivalence relation    induced on `α` by `f` equals the kernel of `r`'s quotient map composed with `f`."
  theorem: "{α : Type u_1} {β : Type u_2} {f : α → β} {r : setoid β} : setoid.comap f r = setoid.ker (quotient.mk ∘ f)"

- doc_string: "The minimal distance to a set (as `ℝ≥0`) is uniformly continuous in point"
  theorem: "{α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_nndist x s)"

- doc_string: "Commuting elements of finite order are closed under multiplication."
  theorem: "{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)"

- doc_string: "Moving to the opposite group or group_with_zero commutes with taking powers."
  theorem: "{M : Type u} [div_inv_monoid M] (x : M) (z : ℤ) : mul_opposite.op (x ^ z) = mul_opposite.op x ^ z"

- doc_string: "**Alias** of the reverse direction of is_max_on_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_min_on f s a → is_max_on (⇑order_dual.to_dual ∘ f) s a"

- doc_string: " A version of `antisymm` with `r` explicit.  This lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there."
  theorem: "{α : Type u} (r : α → α → Prop) [is_antisymm α r] {a b : α} : r a b → r b a → a = b"

- doc_string: "The Legendre symbol depends only on `a` mod `p`."
  theorem: "(p : ℕ) [fact (nat.prime p)] (a : ℤ) : zmod.legendre_sym p a = zmod.legendre_sym p (a % ↑p)"

- doc_string: "A division_ring is one-dimensional as a vector space over itself."
  theorem: "(K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1"

- doc_string: "Bernoulli's inequality reformulated to estimate `a^n`."
  theorem: "{R : Type u₁} [linear_ordered_ring R] {a : R} (H : -1 ≤ a) (n : ℕ) : 1 + ↑n * (a - 1) ≤ a ^ n"

- doc_string: "A map to an additive group preserving addition is an additive monoid homomorphism."
  theorem: "{α : Type u} {β : Type v} [add_zero_class α] [add_group β] {f : α → β} (hf : is_add_hom f) : is_add_monoid_hom f"

- doc_string: "The presheaf of `J`-closed sieves is a `J`-sheaf. The proof of this is adapted from [MM92], Chatper III, Section 7, Lemma 1."
  theorem: "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) : category_theory.presieve.is_sheaf J₁ (category_theory.functor.closed_sieves J₁)"

- doc_string: "Show that `nat.choose` is increasing for small values of the right argument."
  theorem: "{r n : ℕ} (h : r < n / 2) : n.choose r ≤ n.choose (r + 1)"

- doc_string: "**Alias** of the forward direction of lt_sub_iff_add_lt`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a < c - b → a + b < c"

- doc_string: "The indexed minimum of a function is bounded below by a uniform lower bound"
  theorem: "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] [nonempty ι] {f : ι → α} {c : α} (H : ∀ (x : ι), c ≤ f x) : c ≤ infi f"

- doc_string: "Note that `star_one` is already a global simp lemma, but this one works with dsimp too"
  theorem: "{α : Type u_1} : has_star.star 1 = 1"

- doc_string: "The real exponential function tends to `+∞` at `+∞`."
  theorem: " : filter.tendsto real.exp filter.at_top filter.at_top"

- doc_string: "Pullback a `nontrivial` instance along a function sending `0` to `0` and `1` to `1`."
  theorem: "{M₀ : Type u_1} {M₀' : Type u_3} [mul_zero_one_class M₀] [nontrivial M₀] [has_zero M₀'] [has_one M₀'] (f : M₀' → M₀) (zero : f 0 = 0) (one : f 1 = 1) : nontrivial M₀'"

- doc_string: " `smul` is a closed map in the second argument.  The lemma that `smul` is a closed map in the first argument (for a normed space over a complete normed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`."
  theorem: "{α : Type u_2} {G₀ : Type u_4} [topological_space α] [group_with_zero G₀] [mul_action G₀ α] [has_continuous_const_smul G₀ α] {c : G₀} (hc : c ≠ 0) : is_closed_map (λ (x : α), c • x)"

- doc_string: "**Alias** of btw_of_sbtw`."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_btw.btw a b c"

- doc_string: " If `a ≤ b`, then `(b, +∞) ⊆ [a, +∞)`. In preorders, this is just an implication. If you need the equivalence in dense linear orders, use `Ioi_subset_Ici_iff`."
  theorem: "{α : Type u_1} [preorder α] {a b : α} (h : a ≤ b) : set.Ioi b ⊆ set.Ici a"

- doc_string: "The product of the constant function `0` over any set equals `0`."
  theorem: "{α : Type u_1} {M : Type u_5} [add_comm_monoid M] (s : set α) : finsum (λ (i : α), finsum (λ (H : i ∈ s), 0)) = 0"

- doc_string: "The trace map from a finite field to its prime field is nongedenerate."
  theorem: "(F : Type u_1) [field F] [fintype F] {a : F} (ha : a ≠ 0) : ∃ (b : F), ⇑(algebra.trace (zmod (ring_char F)) F) (a * b) ≠ 0"

- doc_string: "TODO: Generalise to `submonoid.powers`."
  theorem: "{G : Type u} {x : G} [fintype G] [group G] [decidable_eq G] : finset.image (λ (i : ℕ), x ^ i) (finset.range (order_of x)) = ↑(subgroup.zpowers x).to_finset"

- doc_string: "**Alias** of the reverse direction of complete_lattice.is_Sup_finite_compact_iff_is_sup_closed_compact`."
  theorem: "(α : Type u_1) [complete_lattice α] : complete_lattice.is_sup_closed_compact α → complete_lattice.is_Sup_finite_compact α"

- doc_string: " The second theorem that characterises the function `reduce`: the maximal reduction of a word only reduces to itself."
  theorem: "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red (free_group.reduce L₁) L₂) : free_group.reduce L₁ = L₂"

- doc_string: "If `0 < n`, then `quaternion_group n` has `4n` elements."
  theorem: "{n : ℕ} [fact (0 < n)] : fintype.card (quaternion_group n) = 4 * n"

- doc_string: "A set is contained in its affine span."
  theorem: "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ ↑(affine_span k s)"

- doc_string: "The edist to a set is bounded above by the edist to any of its points"
  theorem: "{α : Type u} [pseudo_emetric_space α] {x y : α} {s : set α} (h : y ∈ s) : emetric.inf_edist x s ≤ has_edist.edist x y"

- doc_string: "See Theorem 6.6, Călugăreanu"
  theorem: "{α : Type u_1} [complete_lattice α] [is_modular_lattice α] [is_compactly_generated α] [is_atomistic α] : is_complemented α"

- doc_string: "Construct terminal object in the over category. This isn't an instance as it's not typically the way we want to define terminal objects. (For instance, this gives a terminal object which is different from the generic one given by `over_product_of_wide_pullback` above.)"
  theorem: "{C : Type u} [category_theory.category C] (B : C) : category_theory.limits.has_terminal (category_theory.over B)"

- doc_string: "A nonzero object has nontrivial subobject lattice."
  theorem: "{C : Type u₁} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_zero_object C] {X : C} (h : ¬category_theory.limits.is_zero X) : nontrivial (category_theory.subobject X)"

- doc_string: " If `P : ℤ → Prop` is a predicate such that the set `{m : P m}` is bounded above and nonempty, then this set has the greatest element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.greatest_of_bdd` for a constructive counterpart."
  theorem: "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → z ≤ b) (Hinh : ∃ (z : ℤ), P z) : ∃ (ub : ℤ), P ub ∧ ∀ (z : ℤ), P z → z ≤ ub"

- doc_string: "The zeroth cyclotomic polyomial is `1`."
  theorem: "(R : Type u_1) [ring R] : polynomial.cyclotomic 0 R = 1"

- doc_string: " Dividing by an element is the same as multiplying by its inverse.  This is a duplicate of `div_inv_monoid.div_eq_mul_inv` ensuring that the types unfold better."
  theorem: "{G : Type u_1} [div_inv_monoid G] (a b : G) : a / b = a * b⁻¹"

- doc_string: "If there are zero morphisms, any terminal object is a zero object."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C"

- doc_string: " The function `x^(-n)` tends to `0` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_neg_at_top`."
  theorem: "{α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ -↑n) filter.at_top (nhds 0)"

- doc_string: "If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = ±1`."
  theorem: "{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) {a : F} (ha : a ≠ 0) : a ^ (fintype.card F / 2) = 1 ∨ a ^ (fintype.card F / 2) = -1"

- doc_string: "In a non-trivial ring, the element `0` is not left-regular -- with typeclasses."
  theorem: "{R : Type u_1} [mul_zero_class R] [nR : nontrivial R] : ¬is_left_regular 0"

- doc_string: "Extra simp lemma that `dsimp` can use. `simp` will never use this."
  theorem: "{G : Type u_10} [group G] (a : G) : ⇑(equiv.symm (equiv.mul_right a)) = λ (x : G), x * a⁻¹"

- doc_string: "A function `f` on `fin (n + 1)` is monotone if and only if `f i ≤ f (i + 1)` for all `i`."
  theorem: "{n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : monotone f ↔ ∀ (i : fin n), f (⇑fin.cast_succ i) ≤ f i.succ"

- doc_string: "The determinant of `conj_ae`, as a linear equiv."
  theorem: " : ⇑linear_equiv.det complex.conj_ae.to_linear_equiv = -1"

- doc_string: "A version of `padic_val_rat.pow` for `padic_val_nat`"
  theorem: "(p q n : ℕ) [fact (nat.prime p)] (hq : q ≠ 0) : padic_val_nat p (q ^ n) = n * padic_val_nat p q"

- doc_string: "The Hausdorff distance from `s` to `t` and from `t` to `s` coincide"
  theorem: "{α : Type u} [pseudo_metric_space α] {s t : set α} : metric.Hausdorff_dist s t = metric.Hausdorff_dist t s"

- doc_string: "We have that `ring_char (zmod n) = n`."
  theorem: "(n : ℕ) : ring_char (zmod n) = n"

- doc_string: "**Alias** of the reverse direction of strict_mono_on_to_dual_comp_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : strict_anti_on f s → strict_mono_on (⇑order_dual.to_dual ∘ f) s"

- doc_string: " If `x` is in the base field `K`, then the norm is `x ^ [L : K]`.  (If `L` is not finite-dimensional over `K`, then `norm = 1 = x ^ 0 = x ^ (finrank L K)`.)"
  theorem: "{K : Type u_4} {L : Type u_5} [field K] [field L] [algebra K L] (x : K) : ⇑(algebra.norm K) (⇑(algebra_map K L) x) = x ^ finite_dimensional.finrank K L"

- doc_string: "A reversed version of `fin.cast_eq_cast` that is easier to rewrite with."
  theorem: "{n m : ℕ} (h : fin n = fin m) : cast h = ⇑(fin.cast _)"

- doc_string: "A version of `nat.div_lt_self` using successors, rather than additional hypotheses."
  theorem: "(n b : ℕ) : (n + 1) / (b + 2) < n + 1"

- doc_string: "If `f : α → β` is `0`-antilipschitz, then `α` is a `subsingleton`."
  theorem: "{α : Type u_1} {β : Type u_2} [emetric_space α] [pseudo_emetric_space β] {f : α → β} (h : antilipschitz_with 0 f) : subsingleton α"

- doc_string: "  An element is right-regular if and only if multiplying it on the right with a right-regular element is right-regular."
  theorem: "{R : Type u_1} {a : R} [semigroup R] (b : R) (ha : is_right_regular a) : is_right_regular (b * a) ↔ is_right_regular b"

- doc_string: "UV-compression is injective on the elements it moves. See `uv.compress`."
  theorem: "{α : Type u_1} [generalized_boolean_algebra α] (u v : α) : set.inj_on (λ (x : α), (x ⊔ u)  v) {x : α | disjoint u x ∧ v ≤ x}"

- doc_string: "**Alias** of the reverse direction of order.pred_lt_iff_not_is_min`."
  theorem: "{α : Type u_1} [preorder α] [pred_order α] {a : α} : ¬is_min a → order.pred a < a"

- doc_string: "If a point `x` belongs to `s`, then its edist to `s` vanishes"
  theorem: "{α : Type u} [pseudo_emetric_space α] {x : α} {s : set α} (h : x ∈ s) : emetric.inf_edist x s = 0"

- doc_string: "The element `0` is `M`-regular if and only if `M` is trivial."
  theorem: "{R : Type u_1} {M : Type u_3} [monoid_with_zero R] [has_zero M] [mul_action_with_zero R M] : is_smul_regular M 0 ↔ subsingleton M"

- doc_string: "A group element has finite order iff its order is positive."
  theorem: "{G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x"

- doc_string: "The square of the symbol is 1 if `p ∤ a`."
  theorem: "(p : ℕ) [fact (nat.prime p)] (a : ℤ) (ha : ↑a ≠ 0) : zmod.legendre_sym p a ^ 2 = 1"

- doc_string: "**Alias** of lt_of_lt_of_le'`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : b < c → a ≤ b → a < c"

- doc_string: "The element `0` is left-regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] (h : is_left_regular 0) : subsingleton R"

- doc_string: "A group `G` is finitely generated if and only if `add_monoid_algebra R G` is of finite type."
  theorem: "{R : Type u_1} {G : Type u_2} [comm_group G] [comm_ring R] [nontrivial R] : algebra.finite_type R (monoid_algebra R G) ↔ group.fg G"

- doc_string: "One direction of `tsub_eq_zero_iff_le`, as a `@[simp]`-lemma."
  theorem: "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b : α} (h : a ≤ b) : a - b = 0"

- doc_string: "A monoid is not a torsion monoid if it has an element of infinite order."
  theorem: "(G : Type u_1) [monoid G] : ¬monoid.is_torsion G ↔ ∃ (g : G), ¬is_of_fin_order g"

- doc_string: "If `C` has an initial object and binary coproducts, then it has finite coproducts."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_initial C] : category_theory.limits.has_finite_coproducts C"

- doc_string: "**Alias** of lt_of_le_of_ne'`."
  theorem: "{α : Type u} [partial_order α] {a b : α} : a ≤ b → b ≠ a → a < b"

- doc_string: " Coercing an in-range number to `fin (n + 1)`, and converting back to `ℕ`, results in that number."
  theorem: "{n a : ℕ} (h : a < n + 1) : ↑↑a = a"

- doc_string: "`a ≤ -b → b ≤ -a` on ereal"
  theorem: "{a b : ereal} (h : a ≤ -b) : b ≤ -a"

- doc_string: " Every positive `x` is between two successive integer powers of another `y` greater than one. This is the same as `exists_mem_Ioc_zpow`, but with ≤ and < the other way around."
  theorem: "{α : Type u_1} [linear_ordered_field α] [archimedean α] {x y : α} (hx : 0 < x) (hy : 1 < y) : ∃ (n : ℤ), x ∈ set.Ico (y ^ n) (y ^ (n + 1))"

- doc_string: "**Alias** of the forward direction of order.pred_le_pred_iff`."
  theorem: "{α : Type u_1} [preorder α] [pred_order α] {a b : α} [no_min_order α] : order.pred a ≤ order.pred b → a ≤ b"

- doc_string: "Any sieve is smaller than its closure."
  theorem: "{C : Type u} [category_theory.category C] (J₁ : category_theory.grothendieck_topology C) {X : C} (S : category_theory.sieve X) : S ≤ J₁.close S"

- doc_string: " If `R` is a ring which is a topological semiring, then it is automatically a topological ring. This exists so that one can place a topological ring structure on `R` without explicitly proving `continuous_neg`."
  theorem: "{α : Type u_1} [topological_space α] [non_assoc_ring α] (h : topological_semiring α) : topological_ring α"

- doc_string: "**Alias** of eq_or_lt_of_le`."
  theorem: "{α : Type u} [partial_order α] {a b : α} (h : a ≤ b) : a = b ∨ a < b"

- doc_string: "The Jordan decomposition of a signed measure is unique."
  theorem: "{α : Type u_1} [measurable_space α] : function.injective measure_theory.jordan_decomposition.to_signed_measure"

- doc_string: "The set of natural number multiples of an element of an `add_submonoid` is a subset of the `add_submonoid`."
  theorem: "{M : Type u_1} [add_monoid M] {s : set M} {a : M} (hs : is_add_submonoid s) (h : a ∈ s) : multiples a ⊆ s"

- doc_string: "**Alias** of lt_of_lt_of_eq`."
  theorem: "{α : Type u} [preorder α] {a b c : α} (hab : a < b) (hbc : b = c) : a < c"

- doc_string: "The indexed infimum of a function is bounded above by the value taken at one point"
  theorem: "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_lattice α] {f : ι → α} (H : bdd_below (set.range f)) (c : ι) : infi f ≤ f c"

- doc_string: " If `find p` returns `some i`, then `p j` does not hold for `j < i`, i.e., `i` is minimal among the indices where `p` holds."
  theorem: "{n : ℕ} {p : fin n → Prop} [decidable_pred p] {i : fin n} (hi : i ∈ fin.find p) {j : fin n} (hj : j < i) : ¬p j"

- doc_string: "**Alias** of the reverse direction of le_sub_iff_add_le`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b c : α} : a + b ≤ c → a ≤ c - b"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "An explicit version of **Bézout's lemma** for Euclidean domains."
  theorem: "{R : Type u} [euclidean_domain R] [decidable_eq R] (a b : R) : euclidean_domain.gcd a b = a * euclidean_domain.gcd_a a b + b * euclidean_domain.gcd_b a b"

- doc_string: "The identity map preserves multiplication."
  theorem: "{α : Type u} [has_mul α] : is_mul_hom id"

- doc_string: "The identity map is a semiring homomorphism."
  theorem: "{α : Type u} [semiring α] : is_semiring_hom id"

- doc_string: "A minimal polynomial is not `1`."
  theorem: "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : minpoly A x ≠ 1"

- doc_string: "A surjective map has dense range."
  theorem: "{β : Type u_2} [topological_space β] {κ : Type u_5} {f : κ → β} (hf : function.surjective f) : dense_range f"

- doc_string: "In an `n`-dimensional space, the rank is at most `m`."
  theorem: "{R : Type u_1} [ring R] [strong_rank_condition R] (n : ℕ) {m : ℕ} (v : fin m → fin n → R) : linear_independent R v → m ≤ n"

- doc_string: " For `f : ℕ → α`, then `∑' k, f (k + i)` tends to zero. This does not require a summability assumption on `f`, as otherwise all sums are zero."
  theorem: "{α : Type u_1} [add_comm_group α] [topological_space α] [topological_add_group α] [t2_space α] (f : ℕ → α) : filter.tendsto (λ (i : ℕ), ∑' (k : ℕ), f (k + i)) filter.at_top (nhds 0)"

- doc_string: "**Alias** of `left.add_nonneg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a + b"

- doc_string: "Colex is an extension of the base ordering on α."
  theorem: "{α : Type u_1} [linear_order α] {r s : α} : {r}.to_colex < {s}.to_colex ↔ r < s"

- doc_string: "The intersection of a closed set and a compact set is a compact set."
  theorem: "{α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)"

- doc_string: "If `0 < n`, then `dihedral_group n` has `2n` elements."
  theorem: "{n : ℕ} [fact (0 < n)] : fintype.card (dihedral_group n) = 2 * n"

- doc_string: "In a locally compact space, every compact set is contained in the interior of a compact set."
  theorem: "{α : Type u} [topological_space α] [locally_compact_space α] {K : set α} (hK : is_compact K) : ∃ (K' : set α), is_compact K' ∧ K ⊆ interior K'"

- doc_string: "Out of three elements of a `linear_ordered_ring`, two must have the same sign."
  theorem: "{α : Type u} [linear_ordered_ring α] (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a"

- doc_string: "If `s` and `t` are bounded above sets in a `semilattice_sup`, then so is `s ∪ t`."
  theorem: "{γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above s → bdd_above t → bdd_above (s ∪ t)"

- doc_string: "The union of two sets is bounded above if and only if each of the sets is."
  theorem: "{γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t"

- doc_string: "The finrank of `(ι → R)` is `fintype.card ι`."
  theorem: "(R : Type u) [ring R] [strong_rank_condition R] {ι : Type v} [fintype ι] : finite_dimensional.finrank R (ι → R) = fintype.card ι"

- doc_string: "Any category with products and equalizers has all limits.  See <https://stacks.math.columbia.edu/tag/002N>."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_limits C"

- doc_string: "An alternative version of `subtype.forall`. This one is useful if Lean cannot figure out `q`  when using `subtype.forall` from right to left."
  theorem: "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : {a // p a}), q ↑x _"

- doc_string: "1 is of finite order in any monoid."
  theorem: "{G : Type u} [monoid G] : is_of_fin_order 1"

- doc_string: "If matrix A is left invertible, then its inverse equals its left inverse."
  theorem: "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {A B : matrix n n α} (h : B.mul A = 1) : A⁻¹ = B"

- doc_string: "To match `one_mul_eq_id`."
  theorem: "{M₀ : Type u_1} [mul_zero_class M₀] : has_mul.mul 0 = function.const M₀ 0"

- doc_string: "**Alias** of zero_lt_one`."
  theorem: "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 1"

- doc_string: " `disjointed f` is the unique sequence that is pairwise disjoint and has the same partial sups as `f`."
  theorem: "{α : Type u_1} [generalized_boolean_algebra α] {f d : ℕ → α} (hdisj : pairwise (disjoint on d)) (hsups : partial_sups d = partial_sups f) : d = disjointed f"

- doc_string: "Deprecated: use `fun_like.congr_arg` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_zero M] [has_zero N] (f : zero_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y"

- doc_string: "**Alias** of left.one_le_inv_iff`."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1"

- doc_string: "**Alias** of left.inv_lt_one_iff`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 ↔ 0 < a"

- doc_string: "See also `continuous_map.continuous_eval_const`"
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [compact_space α] [metric_space β] (x : α) : continuous (λ (f : C(α, β)), ⇑f x)"

- doc_string: " Left `mul` by a `k : α` over `[ring α]` is injective, if `k` is not a zero divisor. The typeclass that restricts all terms of `α` to have this property is `no_zero_divisors`."
  theorem: "{α : Type u} [non_unital_non_assoc_ring α] (k : α) (h : ∀ (x : α), k * x = 0 → x = 0) : is_left_regular k"

- doc_string: "`mul_action.to_perm` is injective on faithful actions."
  theorem: "{α : Type u} {β : Type v} [group α] [mul_action α β] [has_faithful_smul α β] : function.injective mul_action.to_perm"

- doc_string: "**Alias** of the forward direction of filter.tendsto_iff_comap`."
  theorem: "{α : Type u} {β : Type v} {f : α → β} {l₁ : filter α} {l₂ : filter β} : filter.tendsto f l₁ l₂ → l₁ ≤ filter.comap f l₂"

- doc_string: "**Alias** of the reverse direction of inv_mul_lt_iff_lt_mul`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : a < b * c → b⁻¹ * a < c"

- doc_string: "The vector space of functions on a fintype ι has finrank equal to the cardinality of ι."
  theorem: "(K : Type u) [division_ring K] {ι : Type v} [fintype ι] : finite_dimensional.finrank K (ι → K) = fintype.card ι"

- doc_string: " The distance from `x` to `s` or `t` is controlled in terms of the Hausdorff distance between `s` and `t`"
  theorem: "{α : Type u} [pseudo_emetric_space α] {x : α} {s t : set α} : emetric.inf_edist x t ≤ emetric.inf_edist x s + emetric.Hausdorff_edist s t"

- doc_string: "The composition of Frobenius and Verschiebung is multiplication by `p`."
  theorem: "{p : ℕ} {R : Type u_1} [hp : fact (nat.prime p)] [comm_ring R] (x : witt_vector p R) : ⇑witt_vector.frobenius (⇑witt_vector.verschiebung x) = x * ↑p"

- doc_string: "Shows that the fractional parts of the stream are nonnegative."
  theorem: "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr"

- doc_string: "Non-zero elements of an integral domain are regular."
  theorem: "{R : Type u_1} {a : R} [cancel_monoid_with_zero R] (a0 : a ≠ 0) : is_regular a"

- doc_string: "Two natural numbers are equal if and only if the have the same multiples."
  theorem: "{m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n"

- doc_string: "The identity is a group homomorphism."
  theorem: "{α : Type u} [group α] : is_group_hom id"

- doc_string: "**Alias** of the forward direction of function.injective_iff_pairwise_ne`."
  theorem: "{α : Type u_1} {ι : Type u_2} {f : ι → α} : function.injective f → pairwise (ne on f)"

- doc_string: " The negation of an element a of a semigroup with a distributive negation divides another element b iff a divides b."
  theorem: "{α : Type u} [semigroup α] [has_distrib_neg α] (a b : α) : -a ∣ b ↔ a ∣ b"

- doc_string: "**Alias** of le_of_eq_of_le'`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : b = c → a ≤ b → a ≤ c"

- doc_string: "When lowered to a prop, `matrix.diagonal_invertible_equiv_invertible` forms an `iff`."
  theorem: "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] {v : n → α} : is_unit (matrix.diagonal v) ↔ is_unit v"

- doc_string: "**Alias** of lt_of_mul_lt_mul_left'`."
  theorem: "{α : Type u_1} [has_add α] [has_lt α] [contravariant_class α α has_add.add has_lt.lt] {a b c : α} (bc : a + b < a + c) : b < c"

- doc_string: "If the elements of a set are independent, then any pair within that set is disjoint."
  theorem: "{α : Type u_1} {ι : Type u_3} [complete_lattice α] {t : ι → α} (ht : complete_lattice.independent t) : pairwise (disjoint on t)"

- doc_string: "Every set has a measurable superset. Declare this as local instance as needed."
  theorem: "{α : Type u_1} {m : measurable_space α} (s : set α) : nonempty {t // s ⊆ t ∧ measurable_set t}"

- doc_string: "An element a divides the sum b + a if and only if a divides b."
  theorem: "{α : Type u} [ring α] {a b : α} : a ∣ b + a ↔ a ∣ b"

- doc_string: "The intersection of a dense set with an open dense set is a dense set."
  theorem: "{α : Type u} [topological_space α] {s t : set α} (hs : dense s) (ht : dense t) (hto : is_open t) : dense (s ∩ t)"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_nonpos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0"

- doc_string: " If `τ` is a `canonically_ordered_add_monoid` (e.g., `ℕ` or `ℝ≥0`), then the notions `is_fw_invariant` and `is_invariant` are equivalent."
  theorem: "{τ : Type u_1} {α : Type u_2} [canonically_ordered_add_monoid τ] {ϕ : τ → α → α} {s : set α} (h : is_fw_invariant ϕ s) : is_invariant ϕ s"

- doc_string: " **Cantor's diagonal argument** implies that there are no surjective functions from `α` to `set α`."
  theorem: "{α : Type u_1} (f : α → set α) : ¬function.surjective f"

- doc_string: " A finite dimensional vector space Over an `is_R_or_C` is a proper metric space.  This is not an instance because it would cause a search for `finite_dimensional ?x E` before `is_R_or_C ?x`."
  theorem: "(K : Type u_1) [is_R_or_C K] (E : Type u_2) [normed_group E] [normed_space K E] [finite_dimensional K E] : proper_space E"

- doc_string: "An open set is a Gδ set."
  theorem: "{α : Type u_1} [topological_space α] {s : set α} (h : is_open s) : is_Gδ s"

- doc_string: "**Alias** of the forward direction of list.mem_map`."
  theorem: "{α : Type u} {β : Type v} {f : α → β} {b : β} {l : list α} : b ∈ list.map f l → (∃ (a : α), a ∈ l ∧ f a = b)"

- doc_string: "In an additive semigroup, the sum of add-right-regular elements is add-right-regular."
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (rra : is_add_right_regular a) (rrb : is_add_right_regular b) : is_add_right_regular (a + b)"

- doc_string: "**Alias** of the reverse direction of filter.germ.coe_tendsto`."
  theorem: "{α : Type u_1} {β : Type u_2} {l : filter α} {f : α → β} {lb : filter β} : filter.tendsto f l lb → ↑f.tendsto lb"

- doc_string: "See `add_tsub_cancel_right` for the equality if `contravariant_class α α (+) (≤)`."
  theorem: "{α : Type u_1} [preorder α] [has_add α] [has_sub α] [has_ordered_sub α] {a b : α} : a + b - b ≤ a"

- doc_string: "The variable of the power series ring over an integral domain is prime."
  theorem: "{R : Type u_1} [comm_ring R] [is_domain R] : prime power_series.X"

- doc_string: "For rewriting in the reverse direction, see `fin.cast_add_nat_left`."
  theorem: "{n n' m : ℕ} (i : fin n') (h : n' = n) : ⇑(fin.add_nat m) (⇑(fin.cast h) i) = ⇑(fin.cast _) (⇑(fin.add_nat m) i)"

- doc_string: " For every prime `p` dividing the order of a finite group `G` there exists an element of order `p` in `G`. This is known as Cauchy's theorem."
  theorem: "{G : Type u_1} [group G] [fintype G] (p : ℕ) [hp : fact (nat.prime p)] (hdvd : p ∣ fintype.card G) : ∃ (x : G), order_of x = p"

- doc_string: "**Alias** of the reverse direction of lt_sub_iff_add_lt`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b c : α} : a + b < c → a < c - b"

- doc_string: "A characterization of `enum_ord`: it is the unique strict monotonic function with range `S`."
  theorem: "{S : set ordinal} (f : ordinal → ordinal) (hS : set.unbounded has_lt.lt S) : strict_mono f ∧ set.range f = S ↔ f = ordinal.enum_ord S"

- doc_string: "  Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a` are regular."
  theorem: "{R : Type u_1} {a b : R} [semigroup R] : is_regular (a * b) ∧ is_regular (b * a) ↔ is_regular a ∧ is_regular b"

- doc_string: "**Alias** of lt_mul_of_inv_mul_lt`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c"

- doc_string: "If there's more than 1 element, the min' is less than the max'. An alternate version of `min'_lt_max'` which is sometimes more convenient."
  theorem: "{α : Type u_1} [linear_order α] (s : finset α) (h₂ : 1 < s.card) : s.min' _ < s.max' _"

- doc_string: "Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there  is some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected."
  theorem: "{X : Type u_1} [topological_space X] (hX : ∀ {x y : X}, x ≠ y → (∃ (U : set X) (h_clopen : is_clopen U), x ∈ U ∧ y ∉ U)) : is_totally_disconnected set.univ"

- doc_string: "Embedding `i : fin n` into `fin (n + 1)` is always about some hole `p`."
  theorem: "{n : ℕ} (p : fin (n + 1)) (i : fin n) : ⇑fin.cast_succ i < p ∨ p ≤ ⇑fin.cast_succ i"

- doc_string: "`cast_succ i` is positive when `i` is positive"
  theorem: "{n : ℕ} {i : fin (n + 1)} (h : 0 < i) : 0 < ⇑fin.cast_succ i"

- doc_string: "Prime `p` divides the product of a list `L` iff it divides some `a ∈ L`"
  theorem: "{M : Type u_1} [comm_monoid_with_zero M] {p : M} {L : list M} (pp : prime p) : p ∣ L.prod ↔ ∃ (a : M) (H : a ∈ L), p ∣ a"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul_of_le_of_lt`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b"

- doc_string: " The cast of the successor is the succesor of the cast. See `fin.succ_cast_eq` for rewriting in the reverse direction."
  theorem: "{n n' : ℕ} (i : fin n) (h : n.succ = n'.succ) : ⇑(fin.cast h) i.succ = (⇑(fin.cast _) i).succ"

- doc_string: "The finite field `F` has even cardinality iff it has characteristic `2`."
  theorem: "{F : Type u_3} [field F] [fintype F] : ring_char F = 2 ↔ fintype.card F % 2 = 0"

- doc_string: "For `a : F`, `quadratic_char F a = -1 ↔ ¬ is_square a`."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} : char.quadratic_char F a = -1 ↔ ¬is_square a"

- doc_string: "Law of Excluded Middle."
  theorem: "(p : Prop) [decidable p] : p ∨ ¬p"

- doc_string: "Indexed version of the above lemma `exists_lt_of_cInf_lt` When `infi f < a`, there is an element `i` such that `f i < a`."
  theorem: "{α : Type u_1} {ι : Sort u_3} [conditionally_complete_linear_order α] {a : α} [nonempty ι] {f : ι → α} (h : infi f < a) : ∃ (i : ι), f i < a"

- doc_string: " An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`."
  theorem: "{R : Type u_1} [comm_monoid_with_zero R] (n : R) : is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n"

- doc_string: "Triangle inequality for the extended distance"
  theorem: "{α : Type u} [pseudo_emetric_space α] (x y z : α) : has_edist.edist x y ≤ has_edist.edist z x + has_edist.edist z y"

- doc_string: "The sum of two squares is zero iff both elements are zero."
  theorem: "{α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_neg'`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "A `finset` of a subsingleton type has cardinality at most one."
  theorem: "{α : Type u_1} [subsingleton α] (s : finset α) : s.card ≤ 1"

- doc_string: "An element admitting a right additive opposite is add-right-regular."
  theorem: "{R : Type u_1} {a b : R} [add_monoid R] (h : a + b = 0) : is_add_right_regular a"

- doc_string: "A nontrivial torsion-free group is not torsion."
  theorem: "{G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G"

- doc_string: "Two gcfs `g` and `g'` are equal if and only if their components are equal."
  theorem: "{α : Type u_1} {g g' : generalized_continued_fraction α} : g = g' ↔ g.h = g'.h ∧ g.s = g'.s"

- doc_string: "The first coefficient of `id 𝕜 E` is the identity."
  theorem: "(𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] (v : fin 1 → E) : ⇑(formal_multilinear_series.id 𝕜 E 1) v = v 0"

- doc_string: "If `s ⊆ t`, then the diameter of `s` is bounded by that of `t`, provided `t` is bounded."
  theorem: "{α : Type u} [pseudo_metric_space α] {s t : set α} (h : s ⊆ t) (ht : metric.bounded t) : metric.diam s ≤ metric.diam t"

- doc_string: "Additive congruence relations preserve addition."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w + y) (x + z)"

- doc_string: "Empty relation is well-founded"
  theorem: "{α : Sort u} : well_founded empty_relation"

- doc_string: "The reduction step does not change the product vector."
  theorem: "(u : pnat.xgcd_type) (hr : u.r ≠ 0) : u.step.v = u.v.swap"

- doc_string: "A set is contained in its `span_points`."
  theorem: "(k : Type u_1) {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] (s : set P) : s ⊆ span_points k s"

- doc_string: "**Alias** of the forward direction of order.succ_lt_succ_iff`."
  theorem: "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a < order.succ b → a < b"

- doc_string: "An inequality involving `2`."
  theorem: "{α : Type u_1} [linear_ordered_field α] {a : α} (a2 : 2 ≤ a) : (1 - 1 / a)⁻¹ ≤ 2"

- doc_string: "For `n ≠ 1`, the `n`-th coefficient of `id 𝕜 E` is zero, by definition."
  theorem: "(𝕜 : Type u_1) (E : Type u_2) [nondiscrete_normed_field 𝕜] [normed_group E] [normed_space 𝕜 E] {n : ℕ} (h : n ≠ 1) : formal_multilinear_series.id 𝕜 E n = 0"

- doc_string: " The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `list` where this only holds for nonempty lists."
  theorem: "{Γ : Type u_1} [inhabited Γ] (l : turing.list_blank Γ) : turing.list_blank.cons l.head l.tail = l"

- doc_string: "Moving to the opposite monoid commutes with taking powers."
  theorem: "{M : Type u} [monoid M] (x : M) (n : ℕ) : mul_opposite.op (x ^ n) = mul_opposite.op x ^ n"

- doc_string: "`opow b` and `log b` (almost) form a Galois connection."
  theorem: "{b x c : ordinal} (b1 : 1 < b) (x0 : 0 < x) : b ^ c ≤ x ↔ c ≤ ordinal.log b x"

- doc_string: " `fin` as a map from `ℕ` to `Type` is injective. Note that since this is a statement about equality of types, using it should be avoided if possible."
  theorem: " : function.injective fin"

- doc_string: "The kernel of the natural homomorphism from a monoid to its quotient by a congruence    relation `c` equals `c`."
  theorem: "{M : Type u_1} [mul_one_class M] (c : con M) : con.ker c.mk' = c"

- doc_string: "A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`."
  theorem: "{n : ℕ} {x : ℕ × ℕ} : x ∈ list.nat.antidiagonal n ↔ x.fst + x.snd = n"

- doc_string: " Note we use `↑i = 0` instead of `i = 0` as `fin 0` has no `0`. This means that we cannot state this with `pi.single` as we did with `matrix.circulant_single`."
  theorem: "(α : Type u_1) [has_zero α] [has_one α] (n : ℕ) : matrix.circulant (λ (i : fin n), ite (↑i = 0) 1 0) = 1"

- doc_string: "**Alias** of pow_two`."
  theorem: "{M : Type u} [monoid M] (a : M) : a ^ 2 = a * a"

- doc_string: "`has_colimits_of_size_shrink.{v u} C` tries to obtain `has_colimits_of_size.{v u} C` from some other `has_colimits_of_size C`."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_colimits_of_size C] : category_theory.limits.has_colimits_of_size C"

- doc_string: "**Alias** of the forward direction of left.one_le_inv_iff`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a → a ≤ 0"

- doc_string: " While `fin.coe_order_iso_apply` is a more general case of this, we mark this `simp` anyway as it is eligible for `dsimp`."
  theorem: "{n m : ℕ} (h : n = m) (i : fin n) : ↑(⇑(fin.cast h) i) = ↑i"

- doc_string: "`⊥`, coerced to a set, is the empty set."
  theorem: "(k : Type u_1) (V : Type u_2) (P : Type u_3) [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] : ↑⊥ = ∅"

- doc_string: "**Alias** of dvd.intro_left`."
  theorem: "{α : Type u_1} [comm_semigroup α] {a b : α} (c : α) (h : c * a = b) : a ∣ b"

- doc_string: "One semiconjugates any element to itself."
  theorem: "{M : Type u} [mul_one_class M] (x : M) : semiconj_by 1 x x"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b < 1) (b0 : 0 < b) : a * b < 1"

- doc_string: "The basis of open subgroups for the topology on a ring determined by a valuation."
  theorem: "{R : Type u} [ring R] {Γ₀ : Type v} [linear_ordered_comm_group_with_zero Γ₀] (v : valuation R Γ₀) : ring_subgroups_basis (λ (γ : Γ₀ˣ), v.lt_add_subgroup γ)"

- doc_string: "**Alias** of the forward direction of inseparable_iff_nhds_eq`."
  theorem: "{X : Type u_1} [topological_space X] {x y : X} : inseparable x y → nhds x = nhds y"

- doc_string: "**Alias** of decidable.eq_or_lt_of_le`."
  theorem: "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a = b ∨ a < b"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b"

- doc_string: "An orthonormal set is linearly independent."
  theorem: "{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {ι : Type u_4} {v : ι → E} (hv : orthonormal 𝕜 v) : linear_independent 𝕜 v"

- doc_string: "Express `dist` in terms of `nndist`"
  theorem: "{α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist x y = ↑(has_nndist.nndist x y)"

- doc_string: "The function `lmul_left_right : 𝕜' × 𝕜' → (𝕜' →L[𝕜] 𝕜')` is a bounded bilinear map."
  theorem: "(𝕜 : Type u_1) [nondiscrete_normed_field 𝕜] (𝕜' : Type u_2) [normed_ring 𝕜'] [normed_algebra 𝕜 𝕜'] : is_bounded_bilinear_map 𝕜 (λ (p : 𝕜' × 𝕜'), ⇑(⇑(continuous_linear_map.lmul_left_right 𝕜 𝕜') p.fst) p.snd)"

- doc_string: "**Alias** of zero_lt_two`."
  theorem: "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 2"

- doc_string: "The intersection of two submonoids of a monoid `M` is a submonoid of `M`."
  theorem: "{M : Type u_1} [monoid M] {s₁ s₂ : set M} (is₁ : is_submonoid s₁) (is₂ : is_submonoid s₂) : is_submonoid (s₁ ∩ s₂)"

- doc_string: "An element is a root of its minimal polynomial."
  theorem: "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) : ⇑(polynomial.aeval x) (minpoly A x) = 0"

- doc_string: " An element of a `cancel_monoid_with_zero` fixed by left multiplication by an element other than one must be zero."
  theorem: "{M₀ : Type u_1} [cancel_monoid_with_zero M₀] {a b : M₀} (h₁ : b ≠ 1) (h₂ : b * a = a) : a = 0"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a"

- doc_string: " A finite dimensional space has zero `finrank` iff it is a subsingleton. This is the `finrank` version of `dim_zero_iff`."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : finite_dimensional.finrank K V = 0 ↔ subsingleton V"

- doc_string: "If `monoid_algebra R M` is of finite type then `M` is finitely generated."
  theorem: "{R : Type u_1} {M : Type u_2} [comm_monoid M] [comm_ring R] [nontrivial R] [h : algebra.finite_type R (monoid_algebra R M)] : monoid.fg M"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_pos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} (ha : 0 < a) (hb : 0 < b) : 0 < a + b"

- doc_string: "The minimal distance of a point to a set containing it vanishes"
  theorem: "{α : Type u} [pseudo_metric_space α] {s : set α} {x : α} (h : x ∈ s) : metric.inf_dist x s = 0"

- doc_string: 'The "most used" implication of `add_and_add_iff`, with split hypotheses, instead of `∧`.'
  theorem: "{R : Type u_1} {a b : R} [add_semigroup R] (ab : is_add_regular (a + b)) (ba : is_add_regular (b + a)) : is_add_regular a ∧ is_add_regular b"

- doc_string: "Another way of expressing `strong_induction_on`: the `(<)` relation is well-founded."
  theorem: "{α : Type u_1} : well_founded has_lt.lt"

- doc_string: "Additive congruence relations are transitive."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z"

- doc_string: "When we have `[comm_semiring R]`, the function `C` is the same as `algebra_map R R[X]`.  (But note that `C` is defined when `R` is not necessarily commutative, in which case `algebra_map` is not available.)"
  theorem: "{R : Type u} [comm_semiring R] (r : R) : ⇑polynomial.C r = ⇑(algebra_map R (polynomial R)) r"

- doc_string: " A set `s` is not bounded below if and only if for each `x` there exists `y ∈ s` such that `x` is not less than or equal to `y`. This version only assumes `preorder` structure and uses `¬(x ≤ y)`. A version for linear orders is called `not_bdd_below_iff`."
  theorem: "{α : Type u} [preorder α] {s : set α} : ¬bdd_below s ↔ ∀ (x : α), ∃ (y : α) (H : y ∈ s), ¬x ≤ y"

- doc_string: "The coercion to the quotient of a congruence relation commutes with multiplication (by    definition)."
  theorem: "{M : Type u_1} [has_mul M] {c : con M} (x y : M) : ↑(x * y) = ↑x * ↑y"

- doc_string: "Odd Bernoulli numbers (greater than 1) are zero."
  theorem: "{n : ℕ} (h_odd : odd n) (hlt : 1 < n) : bernoulli' n = 0"

- doc_string: "**Alias** of the reverse direction of sub_pos`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : b < a → 0 < a - b"

- doc_string: "the minimal distance is always nonnegative"
  theorem: "{α : Type u} [pseudo_metric_space α] {s : set α} {x : α} : 0 ≤ metric.inf_dist x s"

- doc_string: "Any nonempty Polish space is the continuous image of the fundamental space `ℕ → ℕ`."
  theorem: "(α : Type u_1) [topological_space α] [polish_space α] [nonempty α] : ∃ (f : (ℕ → ℕ) → α), continuous f ∧ function.surjective f"

- doc_string: "Expressing the product of two polynomials as a double sum."
  theorem: "{R : Type u} [semiring R] {p q : polynomial R} : p * q = p.support.sum (λ (i : ℕ), q.sum (λ (j : ℕ) (a : R), ⇑(polynomial.monomial (i + j)) (p.coeff i * a)))"

- doc_string: "`ℤ` with its usual ring structure is not a field."
  theorem: " : ¬is_field ℤ"

- doc_string: "If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`."
  theorem: "{C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_lt_of_le`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 ≤ b) : 1 < a * b"

- doc_string: "The last element of a `vector`, given that the vector is at least one element."
  theorem: "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.last = v.nth (fin.last n)"

- doc_string: "For any natural numbers n, a, and b, one of the following holds: 1. n < a 2. n ≥ b 3. n ∈ Ico a b"
  theorem: "(n a b : ℕ) : n < a ∨ b ≤ n ∨ n ∈ list.Ico a b"

- doc_string: "Two pseudo metric space structures with the same distance function coincide."
  theorem: "{α : Type u_1} {m m' : pseudo_metric_space α} (h : pseudo_metric_space.to_has_dist = pseudo_metric_space.to_has_dist) : m = m'"

- doc_string: "Given all finite wide pullbacks in `C`, construct finite products in `C/B`."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_finite_wide_pullbacks C] {B : C} : category_theory.limits.has_finite_products (category_theory.over B)"

- doc_string: "Definition of `≤` for additive congruence relations."
  theorem: "{M : Type u_1} [has_add M] {c d : add_con M} : c ≤ d ↔ ∀ {x y : M}, ⇑c x y → ⇑d x y"

- doc_string: "The identity map is a monoid homomorphism."
  theorem: "{α : Type u} [mul_one_class α] : is_monoid_hom id"

- doc_string: "When we have `[comm_semiring R]`, the function `C` is the same as `algebra_map R R[T;T⁻¹]`. (But note that `C` is defined when `R` is not necessarily commutative, in which case `algebra_map` is not available.)"
  theorem: "{R : Type u_1} [comm_semiring R] (r : R) : ⇑laurent_polynomial.C r = ⇑(algebra_map R (laurent_polynomial R)) r"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.mul_le_one`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) : a * b ≤ 1"

- doc_string: " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**."
  theorem: "{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p"

- doc_string: "`map_alg` is the morphism induced by `R → S`."
  theorem: "{R : Type u} [comm_semiring R] {S : Type v} [semiring S] [algebra R S] (p : polynomial R) : ⇑(polynomial.map_alg R S) p = polynomial.map (algebra_map R S) p"

- doc_string: "If `a` commutes with `b`, then `b` commutes with `a`."
  theorem: "{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a"

- doc_string: "In a Polish space, a set is clopenable if and only if it is Borel-measurable."
  theorem: "{γ : Type u_3} [tγ : topological_space γ] [polish_space γ] [measurable_space γ] [borel_space γ] {s : set γ} : polish_space.is_clopenable s ↔ measurable_set s"

- doc_string: "**Alias** of the forward direction of left.inv_lt_one_iff`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a : α} : -a < 0 → 0 < a"

- doc_string: "A subset of a monoid is contained in the submonoid it generates."
  theorem: "{M : Type u_1} [monoid M] {s : set M} : s ⊆ monoid.closure s"

- doc_string: "Any category with coproducts and coequalizers has all colimits.  See <https://stacks.math.columbia.edu/tag/002P>."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_coproducts C] [category_theory.limits.has_coequalizers C] : category_theory.limits.has_colimits C"

- doc_string: "The union of two sets is bounded above if and only if each of the sets is."
  theorem: "{γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t"

- doc_string: "**Alias** of the forward direction of left.inv_le_one_iff`."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 → 1 ≤ a"

- doc_string: " Two lists of sublists are equal iff their joins coincide, as well as the lengths of the sublists."
  theorem: "{α : Type u_1} (L L' : list (list α)) : L = L' ↔ L.join = L'.join ∧ list.map list.length L = list.map list.length L'"

- doc_string: "**Alias** of the reverse direction of is_min_on_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {s : set α} {a : α} : is_max_on f s a → is_min_on (⇑order_dual.to_dual ∘ f) s a"

- doc_string: "The new distance is an extension of the original distance."
  theorem: "{α : Type u} [pseudo_metric_space α] (x y : α) : has_dist.dist ↑x ↑y = has_dist.dist x y"

- doc_string: "The sum of two well-founded games is well-founded."
  theorem: "{α : Type u_1} {β : Type u_2} {rα : α → α → Prop} {rβ : β → β → Prop} (hα : well_founded rα) (hβ : well_founded rβ) : well_founded (relation.game_add rα rβ)"

- doc_string: "`∏ i in nat.divisors n, cyclotomic i R = X ^ n - 1`."
  theorem: "{n : ℕ} (hpos : 0 < n) (R : Type u_1) [comm_ring R] : n.divisors.prod (λ (i : ℕ), polynomial.cyclotomic i R) = polynomial.X ^ n - 1"

- doc_string: " `tail` and `init` commute. We state this lemma in a non-dependent setting, as otherwise it would involve a cast to convince Lean that the two types are equal, making it harder to use."
  theorem: "{n : ℕ} {β : Type u_1} (q : fin (n + 2) → β) : fin.tail (fin.init q) = fin.init (fin.tail q)"

- doc_string: "The exponential map in `𝕂 = ℝ` or `𝕂 = ℂ` has derivative `1` at zero."
  theorem: "{𝕂 : Type u_1} [is_R_or_C 𝕂] : has_deriv_at (exp 𝕂) 1 0"

- doc_string: "A Cauchy sequence in a complete space converges"
  theorem: "{α : Type u} {β : Type v} [uniform_space α] [semilattice_sup β] [complete_space α] {u : β → α} (H : cauchy_seq u) : ∃ (x : α), filter.tendsto u filter.at_top (nhds x)"

- doc_string: "If `a` commutes with both `b` and `c`, then it commutes with their sum."
  theorem: "{S : Type u_1} [add_semigroup S] {a b c : S} (hab : add_commute a b) (hac : add_commute a c) : add_commute a (b + c)"

- doc_string: "`sinh` is surjective, `∀ b, ∃ a, sinh a = b`. In this case, we use `a = arsinh b`."
  theorem: " : function.surjective real.sinh"

- doc_string: "Congruence lemma for constructing `ex.prod`."
  theorem: "{α : Type u} [comm_semiring α] {p p' ps ps' : α} : p = p' → ps = ps' → p * ps = p' * ps'"

- doc_string: "Bernoulli's inequality reformulated to estimate `(n : K)`."
  theorem: "{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ (a ^ n - 1) / (a - 1)"

- doc_string: "**Alias** of the reverse direction of sub_nonpos`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a ≤ b → a - b ≤ 0"

- doc_string: " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about arbitrary `fintype` instances, use `fintype.card_eq_zero_iff`."
  theorem: "{α : Type u_1} [is_empty α] : fintype.card α = 0"

- doc_string: "The class number of a principal ideal domain is `1`."
  theorem: "{R : Type u_1} {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_principal_ideal_ring R] : fintype.card (class_group R K) = 1"

- doc_string: "Multiplicative congruence relations preserve integer powers."
  theorem: "{M : Type u_1} [group M] (c : con M) (n : ℤ) {w x : M} : ⇑c w x → ⇑c (w ^ n) (x ^ n)"

- doc_string: "The ray given by the negation of a nonzero vector."
  theorem: "(R : Type u_1) [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] (v : M) (h : v ≠ 0) : -ray_of_ne_zero R v h = ray_of_ne_zero R (-v) _"

- doc_string: "For nonzero `a : F`, `quadratic_char F a = 1 ↔ is_square a`."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1 ↔ is_square a"

- doc_string: "An additive unit in an additive monoid is add-regular."
  theorem: "{R : Type u_1} {a : R} [add_monoid R] (ua : is_add_unit a) : is_add_regular a"

- doc_string: "Ring homomorphisms map zero to zero."
  theorem: "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} (hf : is_ring_hom f) : f 0 = 0"

- doc_string: "`![a, b, ...] 1` is equal to `b`.   The simplifier needs a special lemma for length `≥ 2`, in addition to  `cons_val_succ`, because `1 : fin 1 = 0 : fin 1`."
  theorem: "{α : Type u} {m : ℕ} (x : α) (u : fin m.succ → α) : matrix.vec_cons x u 1 = matrix.vec_head u"

- doc_string: "Pushforward a `nontrivial` instance along an injective function."
  theorem: "{α : Type u_1} {β : Type u_2} [nontrivial α] {f : α → β} (hf : function.injective f) : nontrivial β"

- doc_string: "`choose n r` is maximised when `r` is `n/2`."
  theorem: "(r n : ℕ) : n.choose r ≤ n.choose (n / 2)"

- doc_string: "A semiring is local if it is nontrivial and the set of nonunits is closed under the addition."
  theorem: "{R : Type u} [comm_semiring R] [nontrivial R] (h : ∀ (a b : R), a ∈ nonunits R → b ∈ nonunits R → a + b ∈ nonunits R) : local_ring R"

- doc_string: "The identity map is an additive monoid homomorphism."
  theorem: "{α : Type u} [add_zero_class α] : is_add_monoid_hom id"

- doc_string: "An injective sequence `f : ℕ → ℕ` tends to infinity at infinity."
  theorem: "{f : ℕ → ℕ} (hf : function.injective f) : filter.tendsto f filter.at_top filter.at_top"

- doc_string: "The rank of a free module `M` over `R` is the cardinality of `choose_basis_index R M`."
  theorem: "(R : Type u) (M : Type v) [ring R] [strong_rank_condition R] [add_comm_group M] [module R M] [module.free R M] : module.rank R M = cardinal.mk (module.free.choose_basis_index R M)"

- doc_string: " Any finite-dimensional vector space over a proper field is proper. We do not register this as an instance to avoid an instance loop when trying to prove the properness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance explicitly when needed."
  theorem: "(𝕜 : Type u) [nondiscrete_normed_field 𝕜] (E : Type v) [normed_group E] [normed_space 𝕜 E] [proper_space 𝕜] [finite_dimensional 𝕜 E] : proper_space E"

- doc_string: "If adding `0` on either side is the identity, `0` is regular."
  theorem: "{R : Type u_1} [add_zero_class R] : is_add_regular 0"

- doc_string: "In a non-trivial ring, the element `0` is not regular -- with typeclasses."
  theorem: "{R : Type u_1} [mul_zero_class R] [nontrivial R] : ¬is_regular 0"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_pos_of_nonneg_of_pos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : 0 ≤ a) (hb : 0 < b) : 0 < a + b"

- doc_string: "Implication `→` is transitive. If `P → Q` and `Q → R` then `P → R`."
  theorem: "{p q r : Prop} (h₁ : implies p q) (h₂ : implies q r) : implies p r"

- doc_string: "**Alias** of decidable.lt_or_eq_of_le`."
  theorem: "{α : Type u} [partial_order α] [decidable_rel has_le.le] {a b : α} (hab : a ≤ b) : a < b ∨ a = b"

- doc_string: "**Alias** of the forward direction of sub_neg`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a - b < 0 → a < b"

- doc_string: "`centroid_weights` at any point."
  theorem: "(k : Type u_1) [division_ring k] {ι : Type u_4} (s : finset ι) (i : ι) : finset.centroid_weights k s i = (↑(s.card))⁻¹"

- doc_string: "**Alias** of le_of_le_of_eq`."
  theorem: "{α : Type u} [preorder α] {a b c : α} (hab : a ≤ b) (hbc : b = c) : a ≤ c"

- doc_string: "If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`  for some `k`."
  theorem: "(m : ℤ) {n : ℤ} (hn : 0 < n) : (∃ (k : ℤ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m"

- doc_string: "In a preadditive category, if the coproduct of `X` and `Y` exists, then the    binary biproduct of `X` and `Y` exists."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] (X Y : C) [category_theory.limits.has_binary_coproduct X Y] : category_theory.limits.has_binary_biproduct X Y"

- doc_string: "If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts"
  theorem: "(C : Type u) [category_theory.category C] [∀ {X Y : C}, category_theory.limits.has_colimit (category_theory.limits.pair X Y)] : category_theory.limits.has_binary_coproducts C"

- doc_string: "If `0 < n`, then `xa i` has order 4."
  theorem: "{n : ℕ} [hpos : fact (0 < n)] (i : zmod (2 * n)) : order_of (quaternion_group.xa i) = 4"

- doc_string: "A sum is add-regular if and only if the summands are."
  theorem: "{R : Type u_1} {a b : R} [add_comm_semigroup R] : is_add_regular (a + b) ↔ is_add_regular a ∧ is_add_regular b"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul_of_le_of_lt`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_lt.lt] {a b : α} (ha : 1 ≤ a) (hb : 1 < b) : 1 < a * b"

- doc_string: "If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`."
  theorem: "{α : Type u} {f g : α → α} {x : α} (hfg : function.is_fixed_pt (f ∘ g) x) (hg : function.is_fixed_pt g x) : function.is_fixed_pt f x"

- doc_string: " If a word reduces to another word, then they have a common maximal reduction."
  theorem: "{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.red L₁ L₂) : free_group.reduce L₁ = free_group.reduce L₂"

- doc_string: "Two natural numbers are equal if and only if the have the same divisors."
  theorem: "{m n : ℕ} : (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n"

- doc_string: " Given an embedding of a topological space into a metrizable space, the source space is also metrizable."
  theorem: "{X : Type u_2} {Y : Type u_3} [topological_space X] [topological_space Y] [topological_space.metrizable_space Y] {f : X → Y} (hf : embedding f) : topological_space.metrizable_space X"

- doc_string: "The `last` element of a vector is the `head` of the `reverse` vector."
  theorem: "{n : ℕ} {α : Type u_1} {v : vector α (n + 1)} : v.reverse.head = v.last"

- doc_string: "**Alias** of le_trans`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : a ≤ b → b ≤ c → a ≤ c"

- doc_string: "The identity is an additive group homomorphism."
  theorem: "{α : Type u} [add_group α] : is_add_group_hom id"

- doc_string: " Note this is not an instance as `char_zero` implies `nontrivial`, and this would risk forming a loop."
  theorem: "{R : Type u_1} [ordered_semiring R] [nontrivial R] : char_zero R"

- doc_string: " If `α` has no zero divisors, then the product of two elements equals zero iff one of them equals zero."
  theorem: "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : 0 = a * b ↔ a = 0 ∨ b = 0"

- doc_string: "`pure : α → ultrafilter α` defines a dense inducing of `α` in `ultrafilter α`."
  theorem: "{α : Type u} : dense_inducing has_pure.pure"

- doc_string: "The `0`-th auxiliary function `f_aux 0` coincides with `exp_neg_inv_glue`, by definition."
  theorem: " : exp_neg_inv_glue.f_aux 0 = exp_neg_inv_glue"

- doc_string: "Ring homomorphisms preserve additive inverses."
  theorem: "{α : Type u} {β : Type v} [ring α] [ring β] {f : α → β} {x : α} (hf : is_ring_hom f) : f (-x) = -f x"

- doc_string: "**Alias** of the reverse direction of set.sized_union`."
  theorem: "{α : Type u_1} {A B : set (finset α)} {r : ℕ} : set.sized r A ∧ set.sized r B → set.sized r (A ∪ B)"

- doc_string: "If `0 < n`, then `sr i` has order 2."
  theorem: "{n : ℕ} (i : zmod n) : order_of (dihedral_group.sr i) = 2"

- doc_string: "The map `coe_fn : (r ≃ s) → (r → s)` is injective."
  theorem: "{α : Sort u} {β : Sort v} : function.injective coe_fn"

- doc_string: "Any open set is the union of the basis sets contained in it."
  theorem: "{α : Type u} [t : topological_space α] {B : set (set α)} (hB : topological_space.is_topological_basis B) {u : set α} (ou : is_open u) : u = ⋃₀{s ∈ B | s ⊆ u}"

- doc_string: "**Alias** of the forward direction of order.succ_le_succ_iff`."
  theorem: "{α : Type u_1} [preorder α] [succ_order α] {a b : α} [no_max_order α] : order.succ a ≤ order.succ b → a ≤ b"

- doc_string: "A natural number `m` divides the sum `n + m` if and only if `m` divides `n`."
  theorem: "{m n : ℕ} : m ∣ n + m ↔ m ∣ n"

- doc_string: "A minimal polynomial is prime."
  theorem: "{A : Type u_1} {B : Type u_2} [field A] [ring B] [is_domain B] [algebra A B] {x : B} (hx : is_integral A x) : prime (minpoly A x)"

- doc_string: "**Alias** of the forward direction of sub_nonneg`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : 0 ≤ a - b → b ≤ a"

- doc_string: "**Alias** of the reverse direction of nat.count_succ_eq_succ_count_iff`."
  theorem: "{p : ℕ → Prop} [decidable_pred p] {n : ℕ} : p n → nat.count p (n + 1) = nat.count p n + 1"

- doc_string: "A version of `nat.sub_succ` in the form `_ - 1` instead of `nat.pred _`."
  theorem: "(a b : ℕ) : a - b.succ = a - b - 1"

- doc_string: "An involution commutes across an equality. Compare to `function.injective.eq_iff`."
  theorem: "{α : Sort u} {f : α → α} (h : function.involutive f) {x y : α} : f x = y ↔ x = f y"

- doc_string: " So-named because the coercion is `nat.cast` into `zmod`. For `nat.cast` into an arbitrary ring, see `zmod.nat_cast_val`."
  theorem: "{n : ℕ} [fact (0 < n)] (a : zmod n) : ↑(a.val) = a"

- doc_string: " Product of elements of a list `L` equals zero if and only if `0 ∈ L`. See also `list.prod_eq_zero` for an implication that needs weaker typeclass assumptions."
  theorem: "{M₀ : Type u_6} [monoid_with_zero M₀] [nontrivial M₀] [no_zero_divisors M₀] {L : list M₀} : L.prod = 0 ↔ 0 ∈ L"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul'`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "Submonoids are closed under natural powers."
  theorem: "{M : Type u_1} [monoid M] {s : set M} {a : M} (hs : is_submonoid s) (h : a ∈ s) {n : ℕ} : a ^ n ∈ s"

- doc_string: "Elements of a right cancel semigroup are right regular."
  theorem: "{R : Type u_1} [right_cancel_semigroup R] (g : R) : is_right_regular g"

- doc_string: " If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point for `f`."
  theorem: "{α : Type u} [uniform_space α] {f : filter α} {x : α} (hf : cauchy f) (adhs : cluster_pt x f) : f ≤ nhds x"

- doc_string: "Two permutations `f g : perm α` have the same cycle factors iff they are the same."
  theorem: "{α : Type u_1} [decidable_eq α] [fintype α] : function.injective equiv.perm.cycle_factors_finset"

- doc_string: " Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges if and only if `1 < p`."
  theorem: "{p : ℕ} : summable (λ (n : ℕ), 1 / ↑n ^ p) ↔ 1 < p"

- doc_string: " A nonempty preorder with no minimal element is infinite. This is not an instance to avoid a cycle with `infinite α → nontrivial α → nonempty α`."
  theorem: "{α : Type u_1} [preorder α] [nonempty α] [no_min_order α] : infinite α"

- doc_string: "Iff version of extensionality rule for congruence relations."
  theorem: "{M : Type u_1} [has_mul M] {c d : con M} : (∀ (x y : M), ⇑c x y ↔ ⇑d x y) ↔ c = d"

- doc_string: "`same_ray` is symmetric."
  theorem: "{R : Type u_1} [ordered_comm_semiring R] {M : Type u_2} [add_comm_monoid M] [module R M] {x y : M} (h : same_ray R x y) : same_ray R y x"

- doc_string: "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and  `lt_of_one_div_lt_one_div`"
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b ↔ b < a"

- doc_string: "If `α` is a preorder with no maximal element, then `at_top ≤ cofinite`."
  theorem: "{α : Type u_2} [preorder α] [no_max_order α] : filter.at_top ≤ filter.cofinite"

- doc_string: "The `k`th coefficient of `polynomial.taylor r f` is `(polynomial.hasse_deriv k f).eval r`."
  theorem: "{R : Type u_1} [semiring R] (r : R) (f : polynomial R) (n : ℕ) : (⇑(polynomial.taylor r) f).coeff n = polynomial.eval r (⇑(polynomial.hasse_deriv n) f)"

- doc_string: 'The "greater than" relation on `upto p` is well founded if (and only if) there exists a value satisfying `p`.'
  theorem: "{p : ℕ → Prop} : (∃ (x : ℕ), p x) → well_founded (nat.upto.gt p)"

- doc_string: "If a vector space has a finite basis, then it is finite-dimensional."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] {ι : Type w} [fintype ι] (h : basis ι K V) : finite_dimensional K V"

- doc_string: "**Alias** of the reverse direction of is_extr_filter_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_extr_filter f l a → is_extr_filter (⇑order_dual.to_dual ∘ f) l a"

- doc_string: "If `F` has odd characteristic, then `quadratic_char F` takes the value `-1`."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2) : ∃ (a : F), char.quadratic_char F a = -1"

- doc_string: "The image of stone_cech_unit is dense. (But stone_cech_unit need  not be an embedding, for example if α is not Hausdorff.)"
  theorem: "{α : Type u} [topological_space α] : dense_range stone_cech_unit"

- doc_string: " Auxiliary lemma: Multivariate polynomials over an integral domain with variables indexed by `fin n` form an integral domain. This fact is proven inductively, and then used to prove the general case without any finiteness hypotheses. See `mv_polynomial.is_domain` for the general case."
  theorem: "(R : Type u) [comm_ring R] [is_domain R] (n : ℕ) : is_domain (mv_polynomial (fin n) R)"

- doc_string: "In a connected category, any two objects are related by `zigzag`."
  theorem: "{J : Type u₁} [category_theory.category J] [category_theory.is_connected J] (j₁ j₂ : J) : category_theory.zigzag j₁ j₂"

- doc_string: "Uses `right` co(ntra)variant."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1"

- doc_string: "There exists at most one `floor_ring` structure on a given linear ordered ring."
  theorem: "{α : Type u_1} [linear_ordered_ring α] : subsingleton (floor_ring α)"

- doc_string: "The `nonsing_inv` of `A` is a right inverse."
  theorem: "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) (h : is_unit A.det) : A.mul A⁻¹ = 1"

- doc_string: "The span of a finite subset is compact in the lattice of submodules."
  theorem: "{R : Type u_1} {M : Type u_4} [semiring R] [add_comm_monoid M] [module R M] (S : finset M) : complete_lattice.is_compact_element (submodule.span R ↑S)"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a < 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1"

- doc_string: "`order_emb_of_fin {a} h` sends any argument to `a`."
  theorem: "{α : Type u_1} [linear_order α] (a : α) (i : fin 1) : ⇑({a}.order_emb_of_fin _) i = a"

- doc_string: "If `s` has a greatest lower bound, then it is bounded below."
  theorem: "{α : Type u} [preorder α] {s : set α} {a : α} (h : is_glb s a) : bdd_below s"

- doc_string: "The p-adic norm of 1 is 1."
  theorem: "(p : ℕ) : padic_norm p 1 = 1"

- doc_string: "Subtracting an element is the same as adding by its negative.  This is a duplicate of `sub_neg_monoid.sub_eq_mul_neg` ensuring that the types unfold better."
  theorem: "{G : Type u_1} [sub_neg_monoid G] (a b : G) : a - b = a + -b"

- doc_string: "A specialized ext lemma for equality of psigma types over an indexed subtype."
  theorem: "{α : Sort u_1} {β : Sort u_2} {p : α → β → Prop} {x₀ x₁ : Σ' (a : α), subtype (p a)} : x₀.fst = x₁.fst → ↑(x₀.snd) = ↑(x₁.snd) → x₀ = x₁"

- doc_string: "Given a pullback in `C`, construct a binary product in `C/B`."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_pullbacks C] {B : C} : category_theory.limits.has_binary_products (category_theory.over B)"

- doc_string: "A version of the global `continuous_inv` suitable for dot notation."
  theorem: "{α : Type u} [group α] (g : group_topology α) : continuous has_inv.inv"

- doc_string: "**Alias** of `left.add_pos_of_pos_of_nonneg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : 0 < a) (hb : 0 ≤ b) : 0 < a + b"

- doc_string: "If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`."
  theorem: "{a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)) : a = p ^ (k + 1)"

- doc_string: "Deprecated: use `fun_like.congr_fun` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_one M] [has_one N] {f g : one_hom M N} (h : f = g) (x : M) : ⇑f x = ⇑g x"

- doc_string: "In a nontrivial monoid with zero, zero and one are different."
  theorem: "{M₀ : Type u_1} [mul_zero_one_class M₀] [nontrivial M₀] : 0 ≠ 1"

- doc_string: " `s.subtype p` converts back to `s.filter p` with `embedding.subtype`."
  theorem: "{α : Type u_1} {s : finset α} (p : α → Prop) [decidable_pred p] : finset.map (function.embedding.subtype p) (finset.subtype p s) = finset.filter p s"

- doc_string: "Rectangles form a π-system."
  theorem: "{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] : is_pi_system (set.image2 has_set_prod.prod {s : set α | measurable_set s} {t : set β | measurable_set t})"

- doc_string: "Embedding a positive `fin n` results in a positive fin (n + 1)`"
  theorem: "{n : ℕ} (p : fin (n + 2)) (i : fin (n + 1)) (h : 0 < i) : 0 < ⇑(p.succ_above) i"

- doc_string: "`clog b` and `pow b` form a Galois connection."
  theorem: "{b : ℕ} (hb : 1 < b) {x y : ℕ} : x ≤ b ^ y ↔ nat.clog b x ≤ y"

- doc_string: " This lemma characterizes discrete topological spaces as those whose singletons are neighbourhoods."
  theorem: "{X : Type u_1} [topological_space X] : discrete_topology X ↔ nhds = has_pure.pure"

- doc_string: " If the domain of a `uniform_inducing` map `f` is a `separated_space`, then `f` is injective, hence it is a `uniform_embedding`."
  theorem: "{α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [separated_space α] {f : α → β} (hf : uniform_inducing f) : uniform_embedding f"

- doc_string: "**Alias** of the reverse direction of is_min_filter_dual_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder β] {f : α → β} {l : filter α} {a : α} : is_max_filter f l a → is_min_filter (⇑order_dual.to_dual ∘ f) l a"

- doc_string: "`R` is finitely presented as `R`-algebra."
  theorem: "(R : Type u_1) [comm_ring R] : algebra.finite_presentation R R"

- doc_string: " If `α` is a nonempty preorder with no maximal elements, then there exists a strictly monotone function `ℕ → α`."
  theorem: "(α : Type u) [preorder α] [nonempty α] [no_max_order α] : ∃ (f : ℕ → α), strict_mono f"

- doc_string: "**Alias** of the reverse direction of is_square_inv`."
  theorem: "{α : Type u_2} [division_monoid α] {a : α} : is_square a → is_square a⁻¹"

- doc_string: "The p-adic norm of 0 is 0."
  theorem: "(p : ℕ) : padic_norm p 0 = 0"

- doc_string: "`succ_above` is injective at the pivot"
  theorem: "{n : ℕ} : function.injective fin.succ_above"

- doc_string: "**Alias** of sbtw_cyclic_right`."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c : α} (h : has_sbtw.sbtw a b c) : has_sbtw.sbtw c a b"

- doc_string: " A version of `strongly_measurable_const` that assumes `f x = f y` for all `x, y`. This version works for functions between empty types."
  theorem: "{α : Type u_1} {β : Type u_2} {m : measurable_space α} [topological_space β] {f : α → β} (hf : ∀ (x y : α), f x = f y) : measure_theory.strongly_measurable f"

- doc_string: "An element admitting a right inverse is right-regular."
  theorem: "{R : Type u_1} {a b : R} [monoid R] (h : a * b = 1) : is_right_regular a"

- doc_string: "**Alias** of the forward direction of measurable_iff_le_map`."
  theorem: "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : measurable f → m₂ ≤ measurable_space.map f m₁"

- doc_string: "Right-regular multiplication on `R` is equivalent to `Rᵐᵒᵖ`-regularity of `R` itself."
  theorem: "{R : Type u_1} [has_mul R] {a : R} : is_right_regular a ↔ is_smul_regular R (mul_opposite.op a)"

- doc_string: "Two elements are related by an additive congruence relation `c` iff they are represented by the same element of the quotient by `c`."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) {a b : M} : ↑a = ↑b ↔ ⇑c a b"

- doc_string: "This is the same as `order_of_pos' but with one fewer explicit assumption since this is  automatic in case of a finite cancellative monoid."
  theorem: "{G : Type u} [fintype G] [left_cancel_monoid G] (x : G) : 0 < order_of x"

- doc_string: " If `P : ℤ → Prop` is a predicate such that the set `{m : P m}` is bounded below and nonempty, then this set has the least element. This lemma uses classical logic to avoid assumption `[decidable_pred P]`. See `int.least_of_bdd` for a constructive counterpart."
  theorem: "{P : ℤ → Prop} (Hbdd : ∃ (b : ℤ), ∀ (z : ℤ), P z → b ≤ z) (Hinh : ∃ (z : ℤ), P z) : ∃ (lb : ℤ), P lb ∧ ∀ (z : ℤ), P z → lb ≤ z"

- doc_string: "A finset is bounded below."
  theorem: "{α : Type u} [semilattice_inf α] [nonempty α] (s : finset α) : bdd_below ↑s"

- doc_string: " Assumes left covariance. The lemma assuming right covariance is `right.one_lt_mul'`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α has_mul.mul has_le.le] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "**Alias** of the reverse direction of antitone_to_dual_comp_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : monotone f → antitone (⇑order_dual.to_dual ∘ f)"

- doc_string: "If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p` is prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this group must itself have order `p-1`, which only happens when `p` is prime."
  theorem: "(p : ℕ) (a : zmod p) (ha : a ^ (p - 1) = 1) (hd : ∀ (q : ℕ), nat.prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) : nat.prime p"

- doc_string: " An unbounded set has zero diameter. If you would prefer to get the value ∞, use `emetric.diam`. This lemma makes it possible to avoid side conditions in some situations"
  theorem: "{α : Type u} [pseudo_metric_space α] {s : set α} (h : ¬metric.bounded s) : metric.diam s = 0"

- doc_string: "**Alias** of the reverse direction of strict_mono_to_dual_comp_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} : strict_anti f → strict_mono (⇑order_dual.to_dual ∘ f)"

- doc_string: "**Alias** of the reverse direction of set.injective_cod_restrict`."
  theorem: "{α : Type u} {β : Type v} {t : set β} {f : α → β} (h : ∀ (x : α), f x ∈ t) : function.injective f → function.injective (set.cod_restrict f t h)"

- doc_string: "Properties of division with remainder for a / b."
  theorem: "(u : pnat.xgcd_type) : u.r + (u.bp + 1) * u.q = u.ap + 1"

- doc_string: "One is `M`-regular always."
  theorem: "{R : Type u_1} (M : Type u_3) [monoid R] [mul_action R M] : is_smul_regular M 1"

- doc_string: " If a reflexive relation `r : α → α → Prop` holds over `x y : α`, then it holds whether or not `x ≠ y`. Unlike `reflexive.ne_imp_iff`, this uses `[is_refl α r]`."
  theorem: "{α : Type u_1} {r : α → α → Prop} [is_refl α r] {x y : α} : x ≠ y → r x y ↔ r x y"

- doc_string: "As a binary function, `fin.cons` is injective."
  theorem: "{n : ℕ} {α : fin (n + 1) → Type u} : function.injective2 fin.cons"

- doc_string: "**Alias** of the reverse direction of div_eq_one`."
  theorem: "{G : Type u_2} [group G] {a b : G} : a = b → a / b = 1"

- doc_string: "**Alias** of lt_of_le_of_lt`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : a ≤ b → b < c → a < c"

- doc_string: "**Alias** of the forward direction of sub_lt_iff_lt_add'`."
  theorem: "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a - b < c → a < b + c"

- doc_string: "Deprecated. Use `fun_like.coe_injective` instead."
  theorem: "{ι : Type u} {β : ι → Type v} [Π (i : ι), has_zero (β i)] : function.injective coe_fn"

- doc_string: " If zero is an element of a list `L`, then `list.prod L = 0`. If the domain is a nontrivial monoid with zero with no divisors, then this implication becomes an `iff`, see `list.prod_eq_zero_iff`."
  theorem: "{M₀ : Type u_6} [monoid_with_zero M₀] {L : list M₀} (h : 0 ∈ L) : L.prod = 0"

- doc_string: "Congruence relations are symmetric."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) {x y : M} : ⇑c x y → ⇑c y x"

- doc_string: " Given two maps `f : α → β` and `g : β → α`, `g` is a bijective map between the fixed points of `f ∘ g` and the fixed points of `g ∘ f`. The inverse map is `f`, see `inv_on_fixed_pts_comp`."
  theorem: "{α : Type u} {β : Type v} (f : α → β) (g : β → α) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (g ∘ f))"

- doc_string: "**Alias** of star_ring_end_self_apply`."
  theorem: "{R : Type u} [comm_semiring R] [star_ring R] (x : R) : ⇑(star_ring_end R) (⇑(star_ring_end R) x) = x"

- doc_string: "If `S` is a subset of `R`, and `S` is covering, then `R` is covering as well.  See <https://stacks.math.columbia.edu/tag/00Z5> (2), or discussion after [MM92] Chapter III, Section 2, Definition 1."
  theorem: "{C : Type u} [category_theory.category C] {X : C} {S R : category_theory.sieve X} (J : category_theory.grothendieck_topology C) (Hss : S ≤ R) (sjx : S ∈ ⇑J X) : R ∈ ⇑J X"

- doc_string: "The canonical injection from the type to the free group is an injection."
  theorem: "{α : Type u} : function.injective free_group.of"

- doc_string: " If `α` has no zero divisors, then for elements `a, b : α`, `a * b` equals zero iff so is `b * a`."
  theorem: "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ b * a = 0"

- doc_string: "In a monoid, an element a divides an element b iff all associates of `a` divide `b`."
  theorem: "{α : Type u_1} [monoid α] {a b u : α} (hu : is_unit u) : a * u ∣ b ↔ a ∣ b"

- doc_string: "Any power of an `M`-regular element is `M`-regular."
  theorem: "{R : Type u_1} {M : Type u_3} {a : R} [monoid R] [mul_action R M] (n : ℕ) (ra : is_smul_regular M a) : is_smul_regular M (a ^ n)"

- doc_string: "The exponential characteristic is one iff the characteristic is zero."
  theorem: "(R : Type u) [semiring R] [nontrivial R] (p q : ℕ) [char_p R p] [exp_char R q] : q = 1 ↔ p = 0"

- doc_string: "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle."
  theorem: "{α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M"

- doc_string: "The frontier of a closed set has no interior point."
  theorem: "{α : Type u} [topological_space α] {s : set α} (h : is_closed s) : interior (frontier s) = ∅"

- doc_string: "A preadditive category with finite products has finite biproducts."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_finite_products C] : category_theory.limits.has_finite_biproducts C"

- doc_string: "The minimal distance to a set is uniformly continuous in point"
  theorem: "{α : Type u} [pseudo_metric_space α] (s : set α) : uniform_continuous (λ (x : α), metric.inf_dist x s)"

- doc_string: "The main characterization theorem for multiplicative principal ordinals."
  theorem: "{o : ordinal} : ordinal.principal has_mul.mul o ↔ o ≤ 2 ∨ ∃ (a : ordinal), o = ordinal.omega ^ ordinal.omega ^ a"

- doc_string: "Uniformisers exist in a DVR"
  theorem: "(R : Type u) [comm_ring R] [is_domain R] [discrete_valuation_ring R] : ∃ (ϖ : R), irreducible ϖ"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_le_mul`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) : 1 ≤ a * b"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.pos_mul_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (a0 : 0 ≤ a) : a * b ≤ 1"

- doc_string: "The evaluation map is continuous, as a joint function of `u` and `x`"
  theorem: "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] : continuous (λ (p : bounded_continuous_function α β × α), ⇑(p.fst) p.snd)"

- doc_string: "Mapping under `id` does not change a vector."
  theorem: "{α : Type u_1} {n : ℕ} (v : vector α n) : vector.map id v = v"

- doc_string: "The product of a list of elements of a submonoid is an element of the submonoid."
  theorem: "{M : Type u_1} [monoid M] {s : set M} (hs : is_submonoid s) {l : list M} : (∀ (x : M), x ∈ l → x ∈ s) → l.prod ∈ s"

- doc_string: " The `n+1`-th iterated derivative can be obtained by differentiating the `n`-th iterated derivative."
  theorem: "{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {F : Type u_2} [normed_group F] [normed_space 𝕜 F] {n : ℕ} {f : 𝕜 → F} : iterated_deriv (n + 1) f = deriv (iterated_deriv n f)"

- doc_string: "A group homomorphism sends 1 to 1."
  theorem: "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : f 1 = 1"

- doc_string: "**Alias** of the forward direction of left.inv_le_one_iff`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : -a ≤ 0 → 0 ≤ a"

- doc_string: "Can't be an instance because it would cause a loop `ufm → wf_dvd_monoid → ufm → ...`."
  theorem: "{α : Type u_1} [cancel_comm_monoid_with_zero α] [wf_dvd_monoid α] [gcd_monoid α] : unique_factorization_monoid α"

- doc_string: 'A category is essentially small if and only if the underlying type of its skeleton (i.e. the "set" of isomorphism classes) is small, and it is locally small.'
  theorem: "(C : Type u) [category_theory.category C] : category_theory.essentially_small C ↔ small (category_theory.skeleton C) ∧ category_theory.locally_small C"

- doc_string: "**Alias** of the reverse direction of lt_inv_mul_iff_mul_lt`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < -a + c"

- doc_string: " The order of the `↔` has been chosen so that `rw btw_cyclic` cycles to the right while `rw ←btw_cyclic` cycles to the left (thus following the prepended arrow)."
  theorem: "{α : Type u_1} [circular_preorder α] {a b c : α} : has_btw.btw a b c ↔ has_btw.btw c a b"

- doc_string: "If `0 < n`, then `r 1` has order `n`."
  theorem: "{n : ℕ} : order_of (dihedral_group.r 1) = n"

- doc_string: "Pullback a `nontrivial` instance along a surjective function."
  theorem: "{α : Type u_1} {β : Type u_2} [nontrivial β] {f : α → β} (hf : function.surjective f) : nontrivial α"

- doc_string: "**Alias** of the reverse direction of dense_closure`."
  theorem: "{α : Type u} [topological_space α] {s : set α} : dense s → dense (closure s)"

- doc_string: "**Number of Subsets of a Set**"
  theorem: "{α : Type u_1} (s : finset α) : s.powerset.card = 2 ^ s.card"

- doc_string: "Units of a monoid divide any element of the monoid."
  theorem: "{α : Type u_1} [monoid α] {a u : α} (hu : is_unit u) : u ∣ a"

- doc_string: "If a vector is in the same ray as its negation, that vector is zero."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x : M} [no_zero_smul_divisors R M] (h : same_ray R x (-x)) : x = 0"

- doc_string: "A function `f` on `fin (n + 1)` is antitone if and only if `f (i + 1) ≤ f i` for all `i`."
  theorem: "{n : ℕ} {α : Type u_1} [preorder α] {f : fin (n + 1) → α} : antitone f ↔ ∀ (i : fin n), f i.succ ≤ f (⇑fin.cast_succ i)"

- doc_string: "`0` is always a square (in a monoid with zero)."
  theorem: "(M : Type u_1) [monoid_with_zero M] : is_square 0"

- doc_string: "An element `a` is regular if and only if a positive power of `a` is regular."
  theorem: "{R : Type u_1} {a : R} [monoid R] {n : ℕ} (n0 : 0 < n) : is_regular (a ^ n) ↔ is_regular a"

- doc_string: "If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_terminal_from`."
  theorem: "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_terminal C] [category_theory.mono (category_theory.limits.terminal.from A)] : category_theory.is_subterminal A"

- doc_string: " In a finite-dimensional vector space, the zero map has determinant `1` in dimension `0`, and `0` otherwise. We give a formula that also works in infinite dimension, where we define the determinant to be `1`."
  theorem: "{𝕜 : Type u_1} [field 𝕜] {M : Type u_2} [add_comm_group M] [module 𝕜 M] : ⇑linear_map.det 0 = 0 ^ finite_dimensional.finrank 𝕜 M"

- doc_string: "The normal closure of a set is a subgroup."
  theorem: "{G : Type u_1} [group G] (s : set G) : is_subgroup (group.normal_closure s)"

- doc_string: " For any `a > 1` and a natural `n` we have `n ≤ a ^ n / (a - 1)`. See also `nat.cast_le_pow_sub_div_sub` for a stronger inequality with `a ^ n - 1` in the numerator."
  theorem: "{K : Type u_1} [linear_ordered_field K] {a : K} (H : 1 < a) (n : ℕ) : ↑n ≤ a ^ n / (a - 1)"

- doc_string: "The cosine of `π / 3` is `1 / 2`."
  theorem: " : real.cos (real.pi / 3) = 1 / 2"

- doc_string: "**Alias** of nat.sq_sub_sq`."
  theorem: "(a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b)"

- doc_string: "If a category has all binary products and all equalizers, then it also has all pullbacks.    As usual, this is not an instance, since there may be a more direct way to construct    pullbacks."
  theorem: "(C : Type u) [𝒞 : category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_equalizers C] : category_theory.limits.has_pullbacks C"

- doc_string: "A locally compact Hausdorff totally disconnected space has a basis with clopen elements."
  theorem: "{H : Type u_1} [topological_space H] [locally_compact_space H] [t2_space H] [totally_disconnected_space H] : topological_space.is_topological_basis {s : set H | is_clopen s}"

- doc_string: "The pointwise distance is controlled by the distance between functions, by definition."
  theorem: "{α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f g : bounded_continuous_function α β} (x : α) : has_dist.dist (⇑f x) (⇑g x) ≤ has_dist.dist f g"

- doc_string: "`has_limits_of_size_shrink.{v u} C` tries to obtain `has_limits_of_size.{v u} C` from some other `has_limits_of_size C`."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_limits_of_size C] : category_theory.limits.has_limits_of_size C"

- doc_string: "See `lt_tsub_iff_right_of_le` for a weaker statement in a partial order."
  theorem: "{α : Type u_1} {a b c : α} [linear_order α] [add_comm_semigroup α] [has_sub α] [has_ordered_sub α] : a < b - c ↔ a + c < b"

- doc_string: "Congruence relations are reflexive."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) (x : M) : ⇑c x x"

- doc_string: " We can infer `finite_dimensional K V` in the presence of `[fact (finrank K V = n + 1)]`. Declare this as a local instance where needed."
  theorem: "{K : Type u_1} {V : Type u_2} [field K] [add_comm_group V] [module K V] (n : ℕ) [fact (finite_dimensional.finrank K V = n + 1)] : finite_dimensional K V"

- doc_string: "**Alias** of le_of_lt`."
  theorem: "{α : Type u} [preorder α] {a b : α} : a < b → a ≤ b"

- doc_string: "Elements of an add cancel monoid are regular.  Add cancel semigroups do not appear to exist."
  theorem: "{R : Type u_1} [add_cancel_monoid R] (g : R) : is_add_regular g"

- doc_string: "See also `smul_right_injective`. TODO: provide a `no_zero_smul_divisors` instance. We can't do that here because importing that definition would create import cycles."
  theorem: "{α : Type u_1} [linear_ordered_add_comm_group α] {n : ℤ} (hn : n ≠ 0) : function.injective (λ (_x : α), n • _x)"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_neg_of_nonpos_of_neg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0"

- doc_string: "**Alias** of the forward direction of left.one_lt_inv_iff`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ → a < 1"

- doc_string: "**Alias** of the forward direction of directed_on_iff_directed`."
  theorem: "{α : Type u} {r : α → α → Prop} {s : set α} : directed_on r s → directed r coe"

- doc_string: "The element `0` is right-regular if and only if `R` is trivial."
  theorem: "{R : Type u_1} [mul_zero_class R] : is_right_regular 0 ↔ subsingleton R"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_neg'`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b < 0) : a + b < 0"

- doc_string: "A simplification of one side of an equation exploiting right distributivity in rings  and the definition of subtraction."
  theorem: "{α : Type u} [non_unital_non_assoc_ring α] {a b c d e : α} : a * e + c = b * e + d → (a - b) * e + c = d"

- doc_string: "The empty set is collinear."
  theorem: "(k : Type u_1) {V : Type u_2} (P : Type u_3) [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] : collinear k ∅"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.one_lt_mul`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_lt.lt] {a b : α} (ha : 1 < a) (hb : 1 < b) : 1 < a * b"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_neg_of_nonpos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_le.le] {a b : α} (ha : a < 0) (hb : b ≤ 0) : a + b < 0"

- doc_string: "If the diagonal morphism of `A` is an isomorphism, then it is subterminal. The converse of `is_subterminal.is_iso_diag`."
  theorem: "{C : Type u₁} [category_theory.category C] {A : C} [category_theory.limits.has_binary_product A A] [category_theory.is_iso (category_theory.limits.diag A)] : category_theory.is_subterminal A"

- doc_string: "If `A` is subterminal, its diagonal morphism is an isomorphism. The converse of `is_subterminal_of_is_iso_diag`."
  theorem: "{C : Type u₁} [category_theory.category C] {A : C} (hA : category_theory.is_subterminal A) [category_theory.limits.has_binary_product A A] : category_theory.is_iso (category_theory.limits.diag A)"

- doc_string: "For a perfect ring, it itself is the perfection."
  theorem: "(p : ℕ) [fact (nat.prime p)] (R : Type u₁) [comm_semiring R] [char_p R p] [perfect_ring R p] : perfection_map p (ring_hom.id R)"

- doc_string: "If `R` has characteristic `0`, then so does Frac(R)."
  theorem: "(R : Type u_1) {K : Type u_2} [comm_ring R] [field K] [algebra R K] [is_fraction_ring R K] [char_zero R] : char_zero K"

- doc_string: "**Alias** of left.one_lt_inv_iff`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a : α} : 1 < a⁻¹ ↔ a < 1"

- doc_string: "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and  `lt_of_one_div_lt_one_div`"
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b ↔ b < a"

- doc_string: "A convex independent family is injective."
  theorem: "{𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [ordered_semiring 𝕜] [add_comm_group E] [module 𝕜 E] {p : ι → E} (hc : convex_independent 𝕜 p) : function.injective p"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : a ≤ 1) (hb : b < 1) (a0 : 0 < a) : a * b < 1"

- doc_string: "**Alias** of the reverse direction of is_max_to_dual_iff`."
  theorem: "{α : Type u_1} [has_le α] {a : α} : is_min a → is_max (⇑order_dual.to_dual a)"

- doc_string: " If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f ∘ g`. This is a particular case of `function.bij_on_fixed_pts_comp`."
  theorem: "{α : Type u} {f g : α → α} (h : function.commute f g) : set.bij_on g (function.fixed_points (f ∘ g)) (function.fixed_points (f ∘ g))"

- doc_string: "Deprecated: use `fun_like.congr_arg` instead."
  theorem: "{M : Type u_3} {N : Type u_4} [has_add M] [has_add N] (f : add_hom M N) {x y : M} (h : x = y) : ⇑f x = ⇑f y"

- doc_string: "`legendre_sym p (-1)` is given by `χ₄ p`."
  theorem: "(p : ℕ) [fact (nat.prime p)] (hp : p ≠ 2) : zmod.legendre_sym p (-1) = ⇑zmod.χ₄ ↑p"

- doc_string: "An element of a ring multiplied by the additive inverse of one is the element's additive  inverse."
  theorem: "{α : Type u} [mul_one_class α] [has_distrib_neg α] (a : α) : a * -1 = -a"

- doc_string: "**Alias** of zero_lt_three`."
  theorem: "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 3"

- doc_string: "`{a}.max' _` is `a`."
  theorem: "{α : Type u_1} [linear_order α] (a : α) : {a}.max' _ = a"

- doc_string: " The evaluation map `C(α, β) × α → β` is continuous if `α` is locally compact.  See also `continuous_map.continuous_eval`"
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous (λ (p : C(α, β) × α), ⇑(p.fst) p.snd)"

- doc_string: "An element is add-left-regular if and only if adding to it on the left a add-left-regular element is add-left-regular."
  theorem: "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_left_regular a) : is_add_left_regular (a + b) ↔ is_add_left_regular b"

- doc_string: "Conjugation by a fixed element is continuous when `mul` is continuous."
  theorem: "{G : Type w} [topological_space G] [has_inv G] [has_mul G] [has_continuous_mul G] (g : G) : continuous (λ (h : G), g * h * g⁻¹)"

- doc_string: "**Alias** of neg_sq`."
  theorem: "{R : Type u₁} [monoid R] [has_distrib_neg R] (a : R) : (-a) ^ 2 = a ^ 2"

- doc_string: "The uncurrying process is a continuous map between function spaces."
  theorem: "{α : Type u_1} {β : Type u_2} {γ : Type u_3} [topological_space α] [topological_space β] [topological_space γ] [locally_compact_space α] [locally_compact_space β] : continuous continuous_map.uncurry"

- doc_string: "**Alias** of the reverse direction of antitone_on_to_dual_comp_iff`."
  theorem: "{α : Type u} {β : Type v} [preorder α] [preorder β] {f : α → β} {s : set α} : monotone_on f s → antitone_on (⇑order_dual.to_dual ∘ f) s"

- doc_string: "The vector space of functions on `fin n` has finrank equal to `n`."
  theorem: "(K : Type u) [division_ring K] {n : ℕ} : finite_dimensional.finrank K (fin n → K) = n"

- doc_string: "The set of natural number multiples of an element of an `add_monoid` is closed under addition."
  theorem: "{M : Type u_1} [add_monoid M] {x y z : M} : y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x"

- doc_string: "Uses `left` co(ntra)variant."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : 1 ≤ a⁻¹ ↔ a ≤ 1"

- doc_string: " The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable value ∞ instead, use `Hausdorff_edist`, which takes values in ℝ≥0∞)"
  theorem: "{α : Type u} [pseudo_metric_space α] {s : set α} : metric.Hausdorff_dist ∅ s = 0"

- doc_string: " The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is, any eigenspace has trivial intersection with the span of all the other eigenspaces."
  theorem: "{K : Type v} {V : Type w} [field K] [add_comm_group V] [module K V] (f : module.End K V) : complete_lattice.independent f.eigenspace"

- doc_string: "Assumes left covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.pos_mul_strict_mono α] (ha : 1 < a) (hb : 1 < b) (a0 : 0 < a) : 1 < a * b"

- doc_string: " `cons` and `snoc` commute. We state this lemma in a non-dependent setting, as otherwise it would involve a cast to convince Lean that the two types are equal, making it harder to use."
  theorem: "{n : ℕ} {β : Type u_1} (a : β) (q : fin n → β) (b : β) : fin.cons a (fin.snoc q b) = fin.snoc (fin.cons a q) b"

- doc_string: " `squarefree` is multiplicative. Note that the → direction does not require `hmn` and generalizes to arbitrary commutative monoids. See `squarefree.of_mul_left` and `squarefree.of_mul_right` above for auxiliary lemmas."
  theorem: "{m n : ℕ} (hmn : m.coprime n) : squarefree (m * n) ↔ squarefree m ∧ squarefree n"

- doc_string: "If a category has all coproducts then in particular it has finite coproducts."
  theorem: "(C : Type u) [category_theory.category C] [category_theory.limits.has_coproducts C] : category_theory.limits.has_finite_coproducts C"

- doc_string: "If `s.nth n = some aₙ` for some value `aₙ`, then there is also some value `aₘ` such that `s.nth = some aₘ` for `m ≤ n`."
  theorem: "{α : Type u} (s : seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n) (s_nth_eq_some : s.nth n = option.some aₙ) : ∃ (aₘ : α), s.nth m = option.some aₘ"

- doc_string: "There are no perfect squares strictly between m² and (m+1)²"
  theorem: "{n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) : ¬∃ (t : ℕ), t * t = n"

- doc_string: "If `univ` is complete, the space is a complete space"
  theorem: "{α : Type u} [uniform_space α] (h : is_complete set.univ) : complete_space α"

- doc_string: "**Alias** of the reverse direction of multiset.Ico_eq_zero_iff`."
  theorem: "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → multiset.Ico a b = 0"

- doc_string: "A finite dimensional space has positive `finrank` iff it has a nonzero element."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] [finite_dimensional K V] : 0 < finite_dimensional.finrank K V ↔ ∃ (x : V), x ≠ 0"

- doc_string: "The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`."
  theorem: "{p : ℕ} [p_prime : fact (nat.prime p)] {a : ℤ} : multiplicity.finite ↑p a ↔ a ≠ 0"

- doc_string: "The square of the quadratic character on nonzero arguments is `1`."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] {a : F} (ha : a ≠ 0) : char.quadratic_char F a ^ 2 = 1"

- doc_string: "Shows that the fractional parts of the stream are in `[0,1)`."
  theorem: "{K : Type u_1} {v : K} {n : ℕ} [linear_ordered_field K] [floor_ring K] {ifp_n : generalized_continued_fraction.int_fract_pair K} (nth_stream_eq : generalized_continued_fraction.int_fract_pair.stream v n = option.some ifp_n) : 0 ≤ ifp_n.fr ∧ ifp_n.fr < 1"

- doc_string: "When lowered to a prop, `matrix.invertible_equiv_det_invertible` forms an `iff`."
  theorem: "{n : Type u'} {α : Type v} [fintype n] [decidable_eq n] [comm_ring α] (A : matrix n n α) : is_unit A ↔ is_unit A.det"

- doc_string: " **Cantor's diagonal argument** implies that there are no injective functions from `set α` to `α`."
  theorem: "{α : Type u_1} (f : set α → α) : ¬function.injective f"

- doc_string: "**Alias** of the reverse direction of order.lt_succ_iff_not_is_max`."
  theorem: "{α : Type u_1} [preorder α] [succ_order α] {a : α} : ¬is_max a → a < order.succ a"

- doc_string: "**Alias** of the reverse direction of continuous_iff_seq_continuous`."
  theorem: "{X : Type u_1} {Y : Type u_2} [topological_space X] [topological_space Y] {f : X → Y} [sequential_space X] : seq_continuous f → continuous f"

- doc_string: "This is the same as `add_order_of_pos' but with one fewer explicit assumption since this is   automatic in case of a finite cancellative additive monoid."
  theorem: "{G : Type u} [fintype G] [add_left_cancel_monoid G] (x : G) : 0 < add_order_of x"

- doc_string: "Assumes right covariance. The lemma assuming left covariance is `left.add_nonpos`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} (ha : a ≤ 0) (hb : b ≤ 0) : a + b ≤ 0"

- doc_string: "`padic_val_rat p 0` is 0 for any `p`."
  theorem: "(m : ℕ) : padic_val_rat m 0 = 0"

- doc_string: "The coercion to the quotient of an additive congruence relation commutes with addition (by definition)."
  theorem: "{M : Type u_1} [has_add M] {c : add_con M} (x y : M) : ↑(x + y) = ↑x + ↑y"

- doc_string: "An alternative version of `subtype.exists`. This one is useful if Lean cannot figure out `q`  when using `subtype.exists` from right to left."
  theorem: "{α : Sort u_1} {p : α → Prop} {q : Π (x : α), p x → Prop} : (∃ (x : α) (h : p x), q x h) ↔ ∃ (x : {a // p a}), q ↑x _"

- doc_string: "A variation on Fermat's little theorem. See `zmod.pow_card_sub_one_eq_one`"
  theorem: "{p : ℕ} [fact (nat.prime p)] (x : zmod p) : x ^ p = x"

- doc_string: "Additive congruence relations are reflexive."
  theorem: "{M : Type u_1} [has_add M] (c : add_con M) (x : M) : ⇑c x x"

- doc_string: "See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order."
  theorem: "{α : Type u_1} [canonically_ordered_add_monoid α] [has_sub α] [has_ordered_sub α] {a b c : α} (h : c ≤ b) (h2 : a - c < b - c) : a < b"

- doc_string: " Theorem of bark and tree : if a set is within a (pre)connected set and its closure, then it is (pre)connected as well."
  theorem: "{α : Type u} [topological_space α] {s t : set α} (H : is_preconnected s) (Kst : s ⊆ t) (Ktcs : t ⊆ closure s) : is_preconnected t"

- doc_string: "An additive group homomorphism is an additive monoid homomorphism."
  theorem: "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : is_add_monoid_hom f"

- doc_string: "Given a wide pullback in `C`, construct a product in `C/B`."
  theorem: "{J : Type v} {C : Type u} [category_theory.category C] [category_theory.limits.has_limits_of_shape (category_theory.limits.wide_pullback_shape J) C] {B : C} : category_theory.limits.has_limits_of_shape (category_theory.discrete J) (category_theory.over B)"

- doc_string: "**Alias** of the reverse direction of measurable_iff_le_map`."
  theorem: "{α : Type u_1} {β : Type u_2} {m₁ : measurable_space α} {m₂ : measurable_space β} {f : α → β} : m₂ ≤ measurable_space.map f m₁ → measurable f"

- doc_string: "**Alias** of the forward direction of sub_nonpos`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : a - b ≤ 0 → a ≤ b"

- doc_string: "`padic_val_rat p 1` is 0 for any `p`."
  theorem: "{p : ℕ} : padic_val_rat p 1 = 0"

- doc_string: "A binary injective function is injective when only the right argument varies."
  theorem: "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ} (hf : function.injective2 f) (a : α) : function.injective (f a)"

- doc_string: "A group homomorphism is a monoid homomorphism."
  theorem: "{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : is_monoid_hom f"

- doc_string: "Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring."
  theorem: "{R : Type u} [comm_ring R] [is_noetherian_ring R] : is_noetherian_ring (polynomial R)"

- doc_string: "Left-regular multiplication on `R` is equivalent to `R`-regularity of `R` itself."
  theorem: "{R : Type u_1} [has_mul R] {a : R} : is_left_regular a ↔ is_smul_regular R a"

- doc_string: " Showing one side of the equivalence between the definitions `is_dedekind_domain_inv` and `is_dedekind_domain` of Dedekind domains."
  theorem: "{A : Type u_2} [comm_ring A] [is_domain A] (h : is_dedekind_domain_inv A) : is_dedekind_domain A"

- doc_string: "**Alias** of zero_lt_four`."
  theorem: "{α : Type u} [ordered_semiring α] [nontrivial α] : 0 < 4"

- doc_string: "`choose n 2` is the `n`-th triangle number."
  theorem: "(n : ℕ) : n.choose 2 = n * (n - 1) / 2"

- doc_string: "**Alias** of lt_of_eq_of_lt'`."
  theorem: "{α : Type u} [preorder α] {a b c : α} : b = c → a < b → a < c"

- doc_string: "Concatenating the first element of a tuple with its tail gives back the original tuple"
  theorem: "{n : ℕ} {α : fin (n + 1) → Type u} (q : Π (i : fin (n + 1)), α i) : fin.snoc (fin.init q) (q (fin.last n)) = q"

- doc_string: " The type of ordinals in universe `u` is not `small.{u}`. This is the type-theoretic analog of the Burali-Forti paradox."
  theorem: " : ¬small ordinal"

- doc_string: "An element is add-right-regular if and only if adding it on the right to a add-right-regular element is add-right-regular."
  theorem: "{R : Type u_1} {a : R} [add_semigroup R] (b : R) (ha : is_add_right_regular a) : is_add_right_regular (b + a) ↔ is_add_right_regular b"

- doc_string: " Series divergence test: if `f` is a convergent series, then `f x` tends to zero along `cofinite`."
  theorem: "{α : Type u_1} {G : Type u_5} [topological_space G] [add_comm_group G] [topological_add_group G] {f : α → G} (hf : summable f) : filter.tendsto f filter.cofinite (nhds 0)"

- doc_string: "An additive group homomorphism is injective if its kernel is trivial."
  theorem: "{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0"

- doc_string: "`m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)` for some `k`."
  theorem: "(m : ℕ) {n : ℕ} (hn : 0 < n) : (∃ (k : ℕ), n * k < m ∧ m < n * (k + 1)) ↔ ¬n ∣ m"

- doc_string: "`X ^ n - a` is monic."
  theorem: "{R : Type u} [ring R] (a : R) {n : ℕ} (h : n ≠ 0) : (polynomial.X ^ n - ⇑polynomial.C a).monic"

- doc_string: "Binet's formula as a function equality."
  theorem: " : (λ (n : ℕ), ↑(nat.fib n)) = λ (n : ℕ), (golden_ratio ^ n - golden_conj ^ n) / real.sqrt 5"

- doc_string: "An inducing map with an open range is an open map."
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] {f : α → β} (hi : inducing f) (ho : is_open (set.range f)) : is_open_map f"

- doc_string: "`fib (n + 2)` is strictly monotone."
  theorem: " : strict_mono (λ (n : ℕ), nat.fib (n + 2))"

- doc_string: "`zpow b` and `int.log b` (almost) form a Galois connection."
  theorem: "{R : Type u_1} [linear_ordered_field R] [floor_ring R] {b : ℕ} (hb : 1 < b) {x : ℤ} {r : R} (hr : 0 < r) : ↑b ^ x ≤ r ↔ x ≤ int.log b r"

- doc_string: 'Add an instance to "undo" coercion transitivity into a chain of coercions, because   most simp lemmas are stated with respect to simple coercions and will not match when   part of a chain.'
  theorem: "{α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} [has_coe α β] [has_coe_t β γ] (a : α) : ↑a = ↑↑a"

- doc_string: " the minimal distance to the empty set is 0 (if you want to have the more reasonable value ∞ instead, use `inf_edist`, which takes values in ℝ≥0∞)"
  theorem: "{α : Type u} [pseudo_metric_space α] {x : α} : metric.inf_dist x ∅ = 0"

- doc_string: " Every x greater than or equal to 1 is between two successive natural-number powers of every y greater than one."
  theorem: "{α : Type u_1} [linear_ordered_ring α] [archimedean α] {x y : α} (hx : 1 ≤ x) (hy : 1 < y) : ∃ (n : ℕ), y ^ n ≤ x ∧ x < y ^ (n + 1)"

- doc_string: "When there is a global minimum, every set is bounded below."
  theorem: "{γ : Type w} [preorder γ] [order_bot γ] (s : set γ) : bdd_below s"

- doc_string: "**Alias** of the forward direction of subsingleton_iff_zero_eq_one`."
  theorem: "{M₀ : Type u_1} [mul_zero_one_class M₀] : 0 = 1 → subsingleton M₀"

- doc_string: " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive."
  theorem: "{m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0"

- doc_string: "Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`."
  theorem: "{R : Type u_1} [non_assoc_ring R] [nontrivial R] (hR : ring_char R ≠ 2) : -1 ≠ 1"

- doc_string: "Uses `left` co(ntra)variant."
  theorem: "{α : Type u} [group α] [has_le α] [covariant_class α α has_mul.mul has_le.le] {a : α} : a⁻¹ ≤ 1 ↔ 1 ≤ a"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_zero_class α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 0 < a) (hb : 0 < b) : 0 < a * b"

- doc_string: "Assumes left covariance. The lemma assuming right covariance is `right.add_neg_of_nonpos_of_neg`."
  theorem: "{α : Type u_1} [add_zero_class α] [preorder α] [covariant_class α α has_add.add has_lt.lt] {a b : α} (ha : a ≤ 0) (hb : b < 0) : a + b < 0"

- doc_string: "The supremum of a singleton is the element of the singleton"
  theorem: "{α : Type u_1} [conditionally_complete_lattice α] (a : α) : has_Sup.Sup {a} = a"

- doc_string: " If `n` has only one element, the determinant of an `n` by `n` matrix is just that element. Although `unique` implies `decidable_eq` and `fintype`, the instances might not be syntactically equal. Thus, we need to fill in the args explicitly."
  theorem: "{R : Type v} [comm_ring R] {n : Type u_1} [unique n] [decidable_eq n] [fintype n] (A : matrix n n R) : A.det = A inhabited.default inhabited.default"

- doc_string: "Any ascending central series for a group is bounded above by the upper central series."
  theorem: "{G : Type u_1} [group G] (H : ℕ → subgroup G) (hH : is_ascending_central_series H) (n : ℕ) : H n ≤ upper_central_series G n"

- doc_string: "Pseudoequality is transitive: Just take the pullback. The pullback morphisms will    be epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.abelian C] {P : C} : transitive (category_theory.abelian.pseudo_equal P)"

- doc_string: "The substructure generated by a set includes the set."
  theorem: "{L : first_order.language} {M : Type w} [L.Structure M] {s : set M} : s ⊆ ↑(⇑(first_order.language.substructure.closure L) s)"

- doc_string: " `is_dedekind_domain` and `is_dedekind_domain_inv` are equivalent ways to express that an integral domain is a Dedekind domain."
  theorem: "{A : Type u_2} [comm_ring A] [is_domain A] : is_dedekind_domain A ↔ is_dedekind_domain_inv A"

- doc_string: "Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation    containing `s` contains the smallest congruence relation containing `r`."
  theorem: "{M : Type u_1} [has_mul M] {r s : M → M → Prop} (h : ∀ (x y : M), r x y → s x y) : con_gen r ≤ con_gen s"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_zero_one_class α] [partial_order α] [zero_lt.mul_pos_mono α] (ha : 1 ≤ a) (hb : 1 ≤ b) (b0 : 0 ≤ b) : 1 ≤ a * b"

- doc_string: "This is a special case of `tsub_le_iff_right`, which should be used instead of this.  This is needed to prove `has_ordered_sub (multiset α)`."
  theorem: "{α : Type u_1} [decidable_eq α] {s t u : multiset α} : s - t ≤ u ↔ s ≤ u + t"

- doc_string: "See also `continuous_map.continuous_coe`"
  theorem: "{α : Type u_1} {β : Type u_2} [topological_space α] [topological_space β] [locally_compact_space α] : continuous coe_fn"

- doc_string: "**Alias** of dvd_mul_of_dvd_right`."
  theorem: "{α : Type u_1} [comm_semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ c * b"

- doc_string: "**Alias** of the reverse direction of nat.count_succ_eq_count_iff`."
  theorem: "{p : ℕ → Prop} [decidable_pred p] {n : ℕ} : ¬p n → nat.count p (n + 1) = nat.count p n"

- doc_string: "Multiplicative congruence relations preserve division."
  theorem: "{M : Type u_1} [group M] (c : con M) {w x y z : M} : ⇑c w x → ⇑c y z → ⇑c (w / y) (x / z)"

- doc_string: "Negation is an `add_group` homomorphism if the `add_group` is commutative."
  theorem: "{α : Type u} [add_comm_group α] : is_add_group_hom has_neg.neg"

- doc_string: "An element of an algebra over a field is algebraic if and only if it is integral."
  theorem: "{K : Type u} {A : Type v} [field K] [ring A] [algebra K A] {x : A} : is_algebraic K x ↔ is_integral K x"

- doc_string: "**Alias** of dvd_mul_of_dvd_left`."
  theorem: "{α : Type u_1} [semigroup α] {a b : α} (h : a ∣ b) (c : α) : a ∣ b * c"

- doc_string: "`cyclotomic n R` comes from `cyclotomic n ℤ`."
  theorem: "(n : ℕ) (R : Type u_1) [ring R] : polynomial.map (int.cast_ring_hom R) (polynomial.cyclotomic n ℤ) = polynomial.cyclotomic n R"

- doc_string: "If `ring_char F = 2`, then `quadratic_char F` takes the value `1` on nonzero elements."
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F = 2) {a : F} (ha : a ≠ 0) : char.quadratic_char F a = 1"

- doc_string: "The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms."
  theorem: "{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0"

- doc_string: "A more convenient spelling of `polynomial.of_finsupp.inj_eq` in terms of `iff`."
  theorem: "{R : Type u} [semiring R] {a b : add_monoid_algebra R ℕ} : {to_finsupp := a} = {to_finsupp := b} ↔ a = b"

- doc_string: "Every nonzero natural number has a unique prime factorization"
  theorem: " : set.inj_on nat.factorization {x : ℕ | x ≠ 0}"

- doc_string: " If `l` is already `list.sorted` with respect to `r`, then `insertion_sort` does not change it."
  theorem: "{α : Type uu} {r : α → α → Prop} [decidable_rel r] {l : list α} (h : list.sorted r l) : list.insertion_sort r l = l"

- doc_string: "If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`."
  theorem: "{x k l : ℕ} (w : 1 < x) : x ^ k ∣ x ^ l ↔ k ≤ l"

- doc_string: " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about arbitrary `fintype` instances, use `finset.univ_eq_empty`."
  theorem: "{α : Type u_1} [is_empty α] : finset.univ = ∅"

- doc_string: " The projection from a topological fiber bundle with a nonempty fiber to its base is a surjective map."
  theorem: "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : function.surjective proj"

- doc_string: "The kernel of the natural homomorphism from an `add_monoid` to its quotient by an additive congruence relation `c` equals `c`."
  theorem: "{M : Type u_1} [add_zero_class M] (c : add_con M) : add_con.ker c.mk' = c"

- doc_string: " The projection from a topological fiber bundle with a nonempty fiber to its base is a quotient map."
  theorem: "{B : Type u_2} {F : Type u_3} {Z : Type u_4} [topological_space B] [topological_space F] {proj : Z → B} [topological_space Z] [nonempty F] (h : is_topological_fiber_bundle F proj) : quotient_map proj"

- doc_string: "The closure of the open interval `(a, b)` is the closed interval `[a, b]`."
  theorem: "{α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a b : α} (hab : a ≠ b) : closure (set.Ioo a b) = set.Icc a b"

- doc_string: "A version of the global `continuous_mul` suitable for dot notation."
  theorem: "{α : Type u} [group α] (g : group_topology α) : continuous (λ (p : α × α), p.fst * p.snd)"

- doc_string: "The union of two sets is bounded iff each of the sets is bounded."
  theorem: "{α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t"

- doc_string: 'The "most used" implication of `mul_and_mul_iff`, with split hypotheses, instead of `∧`.'
  theorem: "{R : Type u_1} {a b : R} [semigroup R] (ab : is_regular (a * b)) (ba : is_regular (b * a)) : is_regular a ∧ is_regular b"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) : 1 < a * b"

- doc_string: "**Alias** of the reverse direction of order_dual.to_dual_lt_to_dual`."
  theorem: "{α : Type u_1} [has_lt α] {a b : α} : b < a → ⇑order_dual.to_dual a < ⇑order_dual.to_dual b"

- doc_string: "**Alias** of the reverse direction of sub_neg`."
  theorem: "{α : Type u} [add_group α] [has_lt α] [covariant_class α α (function.swap has_add.add) has_lt.lt] {a b : α} : a < b → a - b < 0"

- doc_string: "The cardinality of the quaternions, as a type."
  theorem: "(R : Type u_1) [has_one R] [has_neg R] : cardinal.mk (quaternion R) = cardinal.mk R ^ 4"

- doc_string: "Modus tollens. If an implication is true, then so is its contrapositive."
  theorem: "{a b : Prop} (h₁ : a → b) (h₂ : ¬b) : ¬a"

- doc_string: "Any element semiconjugates `1` to `1`."
  theorem: "{M : Type u} [mul_one_class M] (a : M) : semiconj_by a 1 1"

- doc_string: "The interpretation in terms of whether `-1` is a square in `F`"
  theorem: "{F : Type u_1} [field F] [fintype F] : is_square (-1) ↔ fintype.card F % 4 ≠ 3"

- doc_string: "**Alias** of the reverse direction of le_inv_mul_iff_mul_le`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a b c : α} : a + b ≤ c → b ≤ -a + c"

- doc_string: "**Alias** of is_totally_disconnected_of_is_totally_separated`."
  theorem: "{α : Type u} [topological_space α] {s : set α} (H : is_totally_separated s) : is_totally_disconnected s"

- doc_string: "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_neg_of_lt` and  `lt_of_one_div_lt_one_div`"
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : a < 0) (hb : b < 0) : 1 / a ≤ 1 / b ↔ b ≤ a"

- doc_string: "**Alias** of star_ring_end_self_apply`."
  theorem: "{R : Type u} [comm_semiring R] [star_ring R] (x : R) : ⇑(star_ring_end R) (⇑(star_ring_end R) x) = x"

- doc_string: "`q` is the minimum factor of `mersenne p`, so `M p = 0` in `X q`."
  theorem: "(p : ℕ) : ↑(mersenne p) = 0"

- doc_string: "The identity is an isometry"
  theorem: "{α : Type u} [pseudo_emetric_space α] : isometry id"

- doc_string: "We will apply the above step recursively.  The following result is used to ensure that the process terminates."
  theorem: "(u : pnat.xgcd_type) (hr : u.r ≠ 0) : sizeof u.step < sizeof u"

- doc_string: " The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`."
  theorem: "{α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top"

- doc_string: " If `α` has no zero divisors, then the product of two elements equals zero iff one of them equals zero."
  theorem: "{M₀ : Type u_1} [mul_zero_class M₀] [no_zero_divisors M₀] {a b : M₀} : a * b = 0 ↔ a = 0 ∨ b = 0"

- doc_string: "A list with positive sum must have positive length."
  theorem: "{M : Type u_3} [add_monoid M] [preorder M] (L : list M) (h : 0 < L.sum) : 0 < L.length"

- doc_string: " Assumes right covariance. The lemma assuming left covariance is `left.mul_lt_one'`."
  theorem: "{α : Type u_1} [mul_one_class α] [preorder α] [covariant_class α α (function.swap has_mul.mul) has_le.le] {a b : α} (ha : a < 1) (hb : b < 1) : a * b < 1"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_mono α] (ha : a ≤ 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b ≤ 1"

- doc_string: "Some basic API lemmas"
  theorem: "{F : Type u_1} [field F] [fintype F] [decidable_eq F] (a : F) : char.quadratic_char F a = 0 ↔ a = 0"

- doc_string: "**Alias** of dvd.intro`."
  theorem: "{α : Type u_1} [semigroup α] {a b : α} (c : α) (h : a * c = b) : a ∣ b"

- doc_string: "A closed subset of a compact set is a compact set."
  theorem: "{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t"

- doc_string: "If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`."
  theorem: "(P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P ≤ fintype.card L"

- doc_string: " Note: this lemma is specifically about `fintype.of_subsingleton`. For a statement about arbitrary `fintype` instances, use either `fintype.card_le_one_iff_subsingleton` or `fintype.card_unique`."
  theorem: "{α : Type u_1} (a : α) [subsingleton α] : fintype.card α = 1"

- doc_string: "Given all wide pullbacks in `C`, construct products in `C/B`."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.limits.has_wide_pullbacks C] {B : C} : category_theory.limits.has_products (category_theory.over B)"

- doc_string: "Elements of finite additive order are closed under addition."
  theorem: "{G : Type u} {x y : G} [add_comm_monoid G] (hx : is_of_fin_add_order x) (hy : is_of_fin_add_order y) : is_of_fin_add_order (x + y)"

- doc_string: "A minimal polynomial is not a unit."
  theorem: "(A : Type u_1) {B : Type u_2} [comm_ring A] [ring B] [algebra A B] (x : B) [nontrivial B] : ¬is_unit (minpoly A x)"

- doc_string: "**Alias** of not_is_min_of_lt`."
  theorem: "{α : Type u_1} [preorder α] {a b : α} (h : b < a) : ¬is_min a"

- doc_string: "**Alias** of the reverse direction of sub_nonneg`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α (function.swap has_add.add) has_le.le] {a b : α} : b ≤ a → 0 ≤ a - b"

- doc_string: 'For a path `γ`, `γ.truncate` gives a "continuous family of paths", by which we  mean the uncurried function which maps `(t₀, t₁, s)` to `γ.truncate t₀ t₁ s` is continuous.'
  theorem: "{X : Type u_1} [topological_space X] {a b : X} (γ : path a b) : continuous (λ (x : ℝ × ℝ × ↥unit_interval), ⇑(γ.truncate x.fst x.snd.fst) x.snd.snd)"

- doc_string: "**Alias** of the reverse direction of multiset.Icc_eq_zero_iff`."
  theorem: "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a ≤ b → multiset.Icc a b = 0"

- doc_string: "Factoring a prime gives the corresponding one-element multiset."
  theorem: "(p : nat.primes) : ↑p.factor_multiset = prime_multiset.of_prime p"

- doc_string: "Cannot be an instance because `power_basis` cannot be a class."
  theorem: "{S : Type u_2} [comm_ring S] {K : Type u_6} [field K] [algebra K S] (pb : power_basis K S) : finite_dimensional K S"

- doc_string: "**Alias** of the forward direction of lt_sub_iff_add_lt'`."
  theorem: "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : b < c - a → a + b < c"

- doc_string: " In a linear ordered field, for positive `a` and `b` we have `a⁻¹ < b ↔ b⁻¹ < a`. See also `inv_lt_of_inv_lt` for a one-sided implication with one fewer assumption."
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b : α} (ha : 0 < a) (hb : 0 < b) : a⁻¹ < b ↔ b⁻¹ < a"

- doc_string: "In a non-trivial `mul_zero_class`, the `0` element is not left-regular."
  theorem: "{R : Type u_1} [mul_zero_class R] : ¬is_left_regular 0 ↔ nontrivial R"

- doc_string: "Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches."
  theorem: "{α : Sort u_1} (P : Prop) [decidable P] (x : ¬P → α) (y : ¬¬P → α) : dite (¬P) x y = dite P (λ (h : P), y _) x"

- doc_string: "**Alias** of the reverse direction of complete_lattice.is_sup_closed_compact_iff_well_founded`."
  theorem: "(α : Type u_1) [complete_lattice α] : well_founded gt → complete_lattice.is_sup_closed_compact α"

- doc_string: "A finite dimensional space is nontrivial if it has positive `finrank`."
  theorem: "{K : Type u} {V : Type v} [division_ring K] [add_comm_group V] [module K V] (h : 0 < finite_dimensional.finrank K V) : nontrivial V"

- doc_string: "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches."
  theorem: "{α : Sort u_1} (P : Prop) [decidable P] (a b : α) : ite (¬P) a b = ite P b a"

- doc_string: "This can be used to turn `is_chain (≥)` into `is_chain (≤)` and vice-versa."
  theorem: "{α : Type u_1} {r : α → α → Prop} {s : set α} (h : is_chain r s) : is_chain (flip r) s"

- doc_string: "Two affine subspaces are equal if they have the same points."
  theorem: "{k : Type u_1} {V : Type u_2} {P : Type u_3} [ring k] [add_comm_group V] [module k V] [add_torsor V P] : function.injective coe"

- doc_string: "**Alias** of the forward direction of inv_mul_lt_iff_lt_mul`."
  theorem: "{α : Type u} [group α] [has_lt α] [covariant_class α α has_mul.mul has_lt.lt] {a b c : α} : b⁻¹ * a < c → a < b * c"

- doc_string: "Assumes right covariance."
  theorem: "{α : Type u} {a b : α} [mul_one_class α] [has_zero α] [preorder α] [zero_lt.mul_pos_strict_mono α] (ha : a < 1) (hb : b ≤ 1) (b0 : 0 < b) : a * b < 1"

- doc_string: "If `0 < n`, then `i : zmod n` has order `n / gcd n i`."
  theorem: "{n : ℕ} [fact (0 < n)] (i : zmod n) : order_of (dihedral_group.r i) = n / n.gcd i.val"

- doc_string: "**Alias** of the forward direction of mul_sub_mul_div_mul_neg_iff`."
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b c d : α} (hc : c ≠ 0) (hd : d ≠ 0) : (a * d - b * c) / (c * d) < 0 → a / c < b / d"

- doc_string: "In a preadditive category, if all binary coproducts exist, then all binary biproducts exist."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_coproducts C] : category_theory.limits.has_binary_biproducts C"

- doc_string: " The prime divisors of the characteristic of a finite commutative ring are exactly the prime divisors of its cardinality."
  theorem: "{R : Type u_1} [comm_ring R] [fintype R] (p : ℕ) [fact (nat.prime p)] : p ∣ ring_char R ↔ p ∣ fintype.card R"

- doc_string: "**Alias** of the reverse direction of same_ray_neg_iff`."
  theorem: "{R : Type u_1} [ordered_comm_ring R] {M : Type u_2} [add_comm_group M] [module R M] {x y : M} : same_ray R x y → same_ray R (-x) (-y)"

- doc_string: "**Alias** of left.one_le_inv_iff`."
  theorem: "{α : Type u} [add_group α] [has_le α] [covariant_class α α has_add.add has_le.le] {a : α} : 0 ≤ -a ↔ a ≤ 0"

- doc_string: "The negation of a map which preserves addition, preserves addition when the target is commutative."
  theorem: "{α : Type u_1} {β : Type u_2} [has_add α] [add_comm_group β] {f : α → β} (hf : is_add_hom f) : is_add_hom (λ (a : α), -f a)"

- doc_string: "Congruence relations are transitive."
  theorem: "{M : Type u_1} [has_mul M] (c : con M) {x y z : M} : ⇑c x y → ⇑c y z → ⇑c x z"

- doc_string: "**Alias** of the reverse direction of order.pred_ne_pred_iff`."
  theorem: "{α : Type u_1} [partial_order α] [pred_order α] {a b : α} [no_min_order α] : a ≠ b → order.pred a ≠ order.pred b"

- doc_string: "A version of `right_iff_left_not_left` with explicit `r` and `s`."
  theorem: "{α : Type u} (r s : α → α → Prop) [is_nonstrict_strict_order α r s] {a b : α} : s a b ↔ r a b ∧ ¬r b a"

- doc_string: "**Alias** of the reverse direction of lt_sub_iff_add_lt'`."
  theorem: "{α : Type u} [add_comm_group α] [has_lt α] [covariant_class α α has_add.add has_lt.lt] {a b c : α} : a + b < c → b < c - a"

- doc_string: " Bernoulli's inequality. This version works for semirings but requires additional hypotheses `0 ≤ a * a` and `0 ≤ (1 + a) * (1 + a)`."
  theorem: "{R : Type u₁} [ordered_semiring R] {a : R} (Hsq : 0 ≤ a * a) (Hsq' : 0 ≤ (1 + a) * (1 + a)) (H : 0 ≤ 2 + a) (n : ℕ) : 1 + ↑n * a ≤ (1 + a) ^ n"

- doc_string: " The set of numbers satisfying the Liouville condition with some exponent `p > 2` has Lebesgue measure zero."
  theorem: " : ⇑measure_theory.measure_space.volume (⋃ (p : ℝ) (hp : 2 < p), {x : ℝ | liouville_with p x}) = 0"

- doc_string: "Any simple object in a preadditive category is indecomposable."
  theorem: "{C : Type u} [category_theory.category C] [category_theory.preadditive C] [category_theory.limits.has_binary_biproducts C] (X : C) [category_theory.simple X] : category_theory.indecomposable X"

- doc_string: "Elements of an add right cancel semigroup are add-right-regular"
  theorem: "{R : Type u_1} [add_right_cancel_semigroup R] (g : R) : is_add_right_regular g"

- doc_string: "One direction of `div_le_iff` where `b` is allowed to be `0` (but `c` must be nonnegative)"
  theorem: "{α : Type u_1} [linear_ordered_field α] {a b c : α} (hb : 0 ≤ b) (hc : 0 ≤ c) (h : a ≤ c * b) : a / b ≤ c"

- doc_string: "Natural division is always less than division in the field."
  theorem: "{α : Type u_1} [linear_ordered_field α] {m n : ℕ} : ↑(m / n) ≤ ↑m / ↑n"

- doc_string: "**Alias** of the reverse direction of finset.Ico_eq_empty_iff`."
  theorem: "{α : Type u_1} [preorder α] [locally_finite_order α] {a b : α} : ¬a < b → finset.Ico a b = ∅"

