[{"type":"‚àÄ {Œ± : Type u_1} {c : ‚Ñù} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} {v : (a : Œ±) ‚Üí ‚Ñù}\n  (a : Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ abs (u x)) fun (x : Œ±) ‚Ü¶ abs (v x)), Asymptotics.IsBigOWith c l u v","name":"Asymptotics.IsBigOWith.of_abs_abs","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigOWith_abs_abs`."},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (x : M), AddSemiconjBy 0 x x","name":"AddSemiconjBy.zero_left","isProp":true,"docString":"Zero semiconjugates any element to itself."},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Finite s), Nonempty (Fintype ‚Üës)","name":"Set.Finite.nonempty_fintype","isProp":true,"docString":"**Alias** of the forward direction of `Set.finite_def`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (hf : Monotone f) (hg : StrictMono g), StrictMono fun (x : Œ≤) ‚Ü¶ f x + g x","name":"Monotone.add_strictMono","isProp":true,"docString":"The sum of a monotone function and a strictly monotone function is\nstrictly monotone."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommSemigroup Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ExistsAddOfLE Œ±]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [inst_4 : Sub Œ±]\n  [inst_5 : OrderedSub Œ±] {a : Œ±} {b : Œ±} {c : Œ±}\n  [inst_6 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (h‚ÇÅ : b ‚â§ a)\n  (h‚ÇÇ : c ‚â§ a), (a - b < a - c : Prop) ‚Üî (c < b : Prop)","name":"tsub_lt_tsub_iff_left_of_le_of_le","isProp":true,"docString":"See `tsub_lt_tsub_iff_left_of_le` for a stronger statement in a linear order. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  {W : C} {X : C} {Y : C} {Z : C} {f : W ‚ü∂ X} {g : W ‚ü∂ Y} {h : X ‚ü∂ Z} {i : Y ‚ü∂ Z}\n  [inst_2 : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) F]\n  (s : CategoryTheory.IsPushout f g h i),\n  CategoryTheory.IsPushout (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) g)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) h)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) i)","name":"CategoryTheory.IsPushout.map","isProp":true,"docString":"**Alias** of `CategoryTheory.Functor.map_isPushout`."},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : TopologicalRing ùïú] (a : ùïú)\n  (b : ùïú) (h : 0 < a),\n  ‚Üë(affineHomeomorph a b ((Ne.symm ((LT.lt.ne h=:0 ‚â† a)=:0 ‚â† a)=:a ‚â† 0)=:a ‚â† 0)) '' Set.Icc 0 1 = Set.Icc b (a + b)","name":"affineHomeomorph_image_I","isProp":true,"docString":"The image of `[0,1]` under the homeomorphism `fun x ‚Ü¶ a * x + b` is `[b, a+b]`.\n"},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  [inst_3 : Invertible A], Matrix.mul A ‚ÖüA = 1","name":"Matrix.mul_invOf_self","isProp":true,"docString":"A copy of `mul_invOf_self` using `‚¨ù` not `*`. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} (hf : Set.EqOn f 1 s),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) = 1","name":"finprod_mem_of_eqOn_one","isProp":true,"docString":"If a function `f` equals `1` on a set `s`, then the product of `f i` over `i ‚àà s` equals `1`. "},{"type":"‚àÄ {F : (a : Type u) ‚Üí Type u} [inst : Functor F] [q : Qpf F] {Œ± : Type u} (u : (a : F Œ±) ‚Üí Œ±) (x : PFunctor.W (Qpf.P F))\n  (y : PFunctor.W (Qpf.P F)) (a : Qpf.Wequiv x y), Qpf.recF u x = Qpf.recF u y","name":"Qpf.recF_eq_of_Wequiv","isProp":true,"docString":"`recF` is insensitive to the representation "},{"type":"‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {a : Option Œ±} {b : Option Œ≤} {Œ¥ : Type u_1}\n  {Œ≤' : Type u_2} {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ≤') ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ≤) ‚Üí Œ≤'}\n  (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' (g' b) a),\n  Option.map g (Option.map‚ÇÇ f a b) = Option.map‚ÇÇ f' (Option.map g' b) a","name":"Option.map_map‚ÇÇ_antidistrib_left","isProp":true,"docString":"Symmetric statement to `Option.map‚ÇÇ_map_left_anticomm`. "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] {Œπ : Type v} [inst_2 : Fintype Œπ] (M : (a : Œπ) ‚Üí Type w)\n  [inst_3 : (i : Œπ) ‚Üí AddCommGroup (M i)] [inst_4 : (i : Œπ) ‚Üí Module R (M i)] [inst_5 : ‚àÄ (i : Œπ), Module.Free R (M i)]\n  [inst_6 : ‚àÄ (i : Œπ), Module.Finite R (M i)],\n  FiniteDimensional.finrank R (DirectSum Œπ fun (i : Œπ) ‚Ü¶ M i) =\n    Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ FiniteDimensional.finrank R (M i)","name":"FiniteDimensional.finrank_directSum","isProp":true,"docString":"The finrank of the direct sum is the sum of the finranks. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {p : Filter Œπ} [inst_1 : UniformSpace Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} (hg : UniformContinuous g) (hf : UniformCauchySeqOn F p s),\n  UniformCauchySeqOn (fun (n : Œπ) ‚Ü¶ g ‚àò F n) p s","name":"UniformContinuous.comp_uniformCauchySeqOn","isProp":true,"docString":"Composing on the left by a uniformly continuous function preserves\nuniform Cauchy sequences "},{"type":"‚àÄ {n : ‚Ñï} (self : CompositionAsSet n), Fin.last n ‚àà CompositionAsSet.boundaries self","name":"CompositionAsSet.getLast_mem","isProp":true,"docString":"Last element of the composition"},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroClass M‚ÇÄ], (fun (x : M‚ÇÄ) ‚Ü¶ x * 0) = Function.const M‚ÇÄ 0","name":"mul_zero_eq_const","isProp":true,"docString":"To match `mul_one_eq_id`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : IsPredArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h1 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc m n), r i (Order.pred i))\n  (h2 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc n m), r (Order.pred i) i) (hnm : n ‚â† m), Relation.TransGen r n m","name":"transGen_of_pred_of_ne","isProp":true,"docString":"For `n ‚â† m`, `(n, m)` is in the transitive closure of a relation `~` if `i ~ pred i` and\n`pred i ~ i` for all `i` between `n` and `m`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {f : M ‚Üí+ N} {g : M ‚Üí+ N},\n  (f = g : Prop) ‚Üî (‚àÄ (x : M), ‚Üëf x = ‚Üëg x : Prop)","name":"AddMonoidHom.ext_iff","isProp":true,"docString":"Deprecated: use `FunLike.ext_iff` instead."},{"type":"‚àÄ {X : Type u} {Y : Type u} {Z : Type u} (f : X ‚ü∂ Y) {g : Y ‚ü∂ Z} {h : Y ‚ü∂ Z} (w : f ‚â´ g = f ‚â´ h)\n  (t : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.Fork.ofŒπ f w)) (y : Y) (hy : g y = h y), ‚àÉ! (x : X), f x = y","name":"CategoryTheory.Limits.Types.unique_of_type_equalizer","isProp":true,"docString":"The converse of `type_equalizer_of_unique`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedHeytingAlgebra Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hac : Codisjoint a c) (hba : b ‚â§ a),\n  c ‚á® b ‚â§ a","name":"Codisjoint.himp_le_of_right_le","isProp":true,"docString":"See `himp_le` for a stronger version in Boolean algebras. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {a : Œ±} (h : Set.Nonempty (Set.Ioi a)), closure (Set.Ioi a) = Set.Ici a","name":"closure_Ioi'","isProp":true,"docString":"The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`, unless `a` is a top\nelement. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a ‚â§ 1) (hb : b ‚â§ 1), a * b ‚â§ 1","name":"mul_le_one'","isProp":true,"docString":"**Alias** of `Left.mul_le_one`."},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {s : Set Œ±} (hs : Set.Finite s), BddAbove s","name":"Set.Finite.bddAbove","isProp":true,"docString":"A finite set is bounded above."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ≥}\n  (hf : UpperSemicontinuousAt f x) (hg : UpperSemicontinuousAt g x)\n  (hcont : ContinuousAt (fun (p : Œ≥ √ó Œ≥) ‚Ü¶ Prod.fst p + Prod.snd p) (f x, g x)),\n  UpperSemicontinuousAt (fun (z : Œ±) ‚Ü¶ f z + g z) x","name":"UpperSemicontinuousAt.add'","isProp":true,"docString":"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. "},{"type":"‚àÄ {Œπ : Type u_1} [inst : Finite Œπ] {I : BoxIntegral.Box Œπ} {œÄ : BoxIntegral.Prepartition I}\n  (h : BoxIntegral.Prepartition.IsPartition œÄ), ‚àÉ (s : Finset (Œπ √ó ‚Ñù)), BoxIntegral.Prepartition.splitMany I s ‚â§ œÄ","name":"BoxIntegral.Prepartition.IsPartition.exists_splitMany_le","isProp":true,"docString":"If `œÄ` is a partition of `I`, then there exists a finite set `s` of hyperplanes such that\n`splitMany I s ‚â§ œÄ`. "},{"type":"‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} (s : Set Œ±),\n  Nonempty { t : Set Œ± // (s ‚äÜ t : Prop) ‚àß (MeasurableSet t : Prop) }","name":"nonempty_measurable_superset","isProp":true,"docString":"Every set has a measurable superset. Declare this as local instance as needed. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {e' : LocalEquiv Œ± Œ≤} (he : e ‚âà e') (s : Set Œ≤),\n  LocalEquiv.source e ‚à© LocalEquiv.toFun e ‚Åª¬π' s = LocalEquiv.source e' ‚à© LocalEquiv.toFun e' ‚Åª¬π' s","name":"LocalEquiv.EqOnSource.source_inter_preimage_eq","isProp":true,"docString":"Preimages are respected by equivalence "},{"type":"‚àÄ (Œ± : Type u) [inst : OrderedCommGroup Œ±],\n  ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1","name":"OrderedCommGroup.to_contravariantClass_left_le","isProp":true,"docString":"A choice-free shortcut instance. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : D ‚•§ C} (self : F ‚ä£ G) {X : C} {Y : D} {g : X ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) Y},\n  ‚Üë(Equiv.symm (CategoryTheory.Adjunction.homEquiv self X Y)) g =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) g ‚â´ (CategoryTheory.Adjunction.counit self).app Y","name":"CategoryTheory.Adjunction.homEquiv_counit","isProp":true,"docString":"Naturality of the counit of an adjunction "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : SeminormedAddCommGroup E] [inst_2 : NormedSpace ùïú E]\n  {r : ‚Ñù}, Balanced ùïú (Metric.ball 0 r)","name":"balanced_ball_zero","isProp":true,"docString":"Balls at the origin are balanced. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] (t : Finset Œπ) (f : (a : Œπ) ‚Üí Set Œ±) (g : (a : Œπ) ‚Üí Œ±)\n  (hg : ‚àÄ (i : Œπ) (a : i ‚àà t), g i ‚àà f i), (Finset.prod t fun (i : Œπ) ‚Ü¶ g i) ‚àà Finset.prod t fun (i : Œπ) ‚Ü¶ f i","name":"Set.finset_prod_mem_finset_prod","isProp":true,"docString":"An n-ary version of `Set.mul_mem_mul`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] (X : C) (Y : C)\n  [inst_2 : CategoryTheory.Limits.HasBinaryCoproduct X Y], CategoryTheory.Limits.HasBinaryBiproduct X Y","name":"CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryCoproduct","isProp":true,"docString":"In a preadditive category, if the coproduct of `X` and `Y` exists, then the\nbinary biproduct of `X` and `Y` exists. "},{"type":"‚àÄ {R : Type u} [self : AddCommGroupWithOne R] (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1","name":"AddCommGroupWithOne.natCast_succ","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` is a homomorphism. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (P : C) (Q : C) [inst_1 : CategoryTheory.Limits.HasBinaryProduct P Q]\n  [inst_2 : CategoryTheory.Limits.HasBinaryProduct Q P],\n  CategoryTheory.Iso.hom (CategoryTheory.Limits.prod.braiding P Q) ‚â´\n      CategoryTheory.Iso.hom (CategoryTheory.Limits.prod.braiding Q P) =\n    ùüô (P ‚®Ø Q)","name":"CategoryTheory.Limits.prod.symmetry","isProp":true,"docString":"The braiding isomorphism is symmetric. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (fin : EMetric.hausdorffEdist s t ‚â† ‚ä§),\n  (Metric.hausdorffDist s t = 0 : Prop) ‚Üî (closure s = closure t : Prop)","name":"Metric.hausdorffDist_zero_iff_closure_eq_closure","isProp":true,"docString":"Two sets are at zero Hausdorff distance if and only if they have the same closures "},{"type":"‚àÄ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S)\n  (hI : IsNilpotent I) {P : ‚¶ÉS : Type u_1‚¶Ñ ‚Üí [inst : CommRing S] ‚Üí (_I : Ideal S) ‚Üí Prop}\n  (h‚ÇÅ : ‚àÄ ‚¶ÉS : Type u_1‚¶Ñ [inst : CommRing S] (I : Ideal S) (a : I ^ 2 = ‚ä•), P I)\n  (h‚ÇÇ :\n    ‚àÄ ‚¶ÉS : Type u_1‚¶Ñ [inst : CommRing S] (I : Ideal S) (J : Ideal S) (a : I ‚â§ J) (a : P I)\n      (a : P (Ideal.map (Ideal.Quotient.mk I) J)), P J),\n  P I","name":"Ideal.IsNilpotent.induction_on","isProp":true,"docString":"Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n`P I ‚Üí P (J ‚ß∏ I) ‚Üí P J`, then `P` holds for all nilpotent ideals. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (self : Œ± ‚âÉ‚Çú Œ≤),\n  Continuous (Equiv.invFun (Homeomorph.toEquiv self))","name":"Homeomorph.continuous_invFun","isProp":true,"docString":"The inverse map of a homeomorphism is a continuous function. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±} (a_1 : IsTop a), a = ‚ä§","name":"IsTop.eq_top","isProp":true,"docString":"**Alias** of the forward direction of `isTop_iff_eq_top`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {J‚ÇÅ : CategoryTheory.GrothendieckTopology C}\n  {J‚ÇÇ : CategoryTheory.GrothendieckTopology C}\n  (h : CategoryTheory.GrothendieckTopology.sieves J‚ÇÅ = CategoryTheory.GrothendieckTopology.sieves J‚ÇÇ), J‚ÇÅ = J‚ÇÇ","name":"CategoryTheory.GrothendieckTopology.ext","isProp":true,"docString":"An extensionality lemma in terms of the coercion to a pi-type.\nWe prove this explicitly rather than deriving it so that it is in terms of the coercion rather than\nthe projection `.sieves`.\n"},{"type":"‚àÄ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]\n  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (self : A ‚âÉ‚Çê[R] B) (r : R),\n  Equiv.toFun (AlgEquiv.toEquiv self) (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r","name":"AlgEquiv.commutes'","isProp":true,"docString":"An equivalence of algebras commutes with the action of scalars. "},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (ha : a ‚â† 0) (hb : b ‚â† 0),\n  List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) ‚à™ List.toFinset (Nat.factors b)","name":"Nat.factors_mul_toFinset","isProp":true,"docString":"If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` "},{"type":"‚àÄ {m : ‚Ñï} {P : (n : ‚Ñï) ‚Üí (x : m ‚â§ n) ‚Üí Prop} (base : P m ((le_rfl=:m ‚â§ m)=:m ‚â§ m))\n  (succ :\n    ‚àÄ (n : ‚Ñï) (hn : m ‚â§ n) (a : P n hn),\n      P (n + 1) ((LE.le.trans hn ((Nat.le_succ n=:n ‚â§ Nat.succ n)=:n ‚â§ Nat.succ n)=:m ‚â§ n + 1)=:m ‚â§ n + 1))\n  (n : ‚Ñï) (hn : m ‚â§ n), P n hn","name":"Nat.le_induction","isProp":true,"docString":"Induction principle starting at a non-zero number. For maps to a `Sort*` see `le_rec_on`.\nTo use in an induction proof, the syntax is `induction n, hn using Nat.le_induction` (or the same\nfor `induction'`). "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} (p : (a : M) ‚Üí Prop) (hp‚ÇÄ : p 1)\n  (hp‚ÇÅ : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x * y)) (hp‚ÇÇ : ‚àÄ (x : Œ±) (a : x ‚àà s), p (f x)),\n  p (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i)","name":"finprod_mem_induction","isProp":true,"docString":"To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {W : C} {X : C} {Y : C} {Z : C} (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) (h : W = Y)\n  (h' : X = Z),\n  (f = CategoryTheory.eqToHom h ‚â´ g ‚â´ CategoryTheory.eqToHom ((Eq.symm h'=:Z = X)=:Z = X) : Prop) ‚Üî (HEq f g : Prop)","name":"CategoryTheory.Functor.conj_eqToHom_iff_hEq","isProp":true,"docString":"Two morphisms are conjugate via eqToHom if and only if they are heterogeneously equal. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {Z : C} {X : C} {Y : C} {P : C} {f : Z ‚ü∂ X} {g : Z ‚ü∂ Y} {inl : X ‚ü∂ P}\n  {inr : Y ‚ü∂ P} (self : CategoryTheory.IsPushout f g inl inr),\n  Nonempty\n    (CategoryTheory.Limits.IsColimit\n      (CategoryTheory.Limits.PushoutCocone.mk inl inr\n        ((CategoryTheory.CommSq.w\n              ((CategoryTheory.IsPushout.toCommSq\n                    self=:CategoryTheory.CommSq f g inl\n                    inr)=:CategoryTheory.CommSq f g inl inr)=:f ‚â´ inl = g ‚â´ inr)=:f ‚â´ inl = g ‚â´ inr)))","name":"CategoryTheory.IsPushout.isColimit'","isProp":true,"docString":"the pushout cocone is a colimit "},{"type":"‚àÄ {M : Type u} [self : LeftCancelMonoid M] (a : M), 1 * a = a","name":"LeftCancelMonoid.one_mul","isProp":true,"docString":"One is a left neutral element for multiplication "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] (a : Œ±), inf‚Çõ {a} = a","name":"cinf‚Çõ_singleton","isProp":true,"docString":"The infimum of a singleton is the element of the singleton"},{"type":"‚àÄ {V : Type u_1} {W : Type u_2} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W]\n  (self : NormedAddGroupHom V W) (v‚ÇÅ : V) (v‚ÇÇ : V),\n  NormedAddGroupHom.toFun self (v‚ÇÅ + v‚ÇÇ) = NormedAddGroupHom.toFun self v‚ÇÅ + NormedAddGroupHom.toFun self v‚ÇÇ","name":"NormedAddGroupHom.map_add'","isProp":true,"docString":"A `NormedAddGroupHom` is additive. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) (b : P) {pred : (a : Œπ) ‚Üí Prop}\n  [inst_3 : DecidablePred pred] (h : ‚àÄ (i : Œπ) (a : i ‚àà s) (a : w i ‚â† 0), pred i),\n  ‚Üë(Finset.weightedVSubOfPoint (Finset.filter pred s) p b) w = ‚Üë(Finset.weightedVSubOfPoint s p b) w","name":"Finset.weightedVSubOfPoint_filter_of_ne","isProp":true,"docString":"A weighted sum over `s.filter pred` equals one over `s` if all the weights at indices in `s`\nnot satisfying `pred` are zero. "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : a ‚â§ b) (a_2 : 0 ‚â§ c), a * c ‚â§ b * c","name":"OrderedSemiring.mul_le_mul_of_nonneg_right","isProp":true,"docString":"In an ordered semiring, we can multiply an inequality `a ‚â§ b` on the right\nby a non-negative element `0 ‚â§ c` to obtain `a * c ‚â§ b * c`. "},{"type":"‚àÄ {Œ± : Type u} [inst : BEq Œ±] [self : LawfulBEq Œ±] {a : Œ±} {b : Œ±} (a_1 : (a == b) = true), a = b","name":"LawfulBEq.eq_of_beq","isProp":true,"docString":"If `a == b` evaluates to `true`, then `a` and `b` are equal in the logic. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {f : CategoryTheory.Arrow C} {g : CategoryTheory.Arrow C}\n  [inst_1 : CategoryTheory.Limits.HasImage (CategoryTheory.Comma.hom f)]\n  [inst_2 : CategoryTheory.Limits.HasImage (CategoryTheory.Comma.hom g)] {sq : f ‚ü∂ g}\n  (self : CategoryTheory.Limits.ImageMap sq),\n  CategoryTheory.Limits.ImageMap.map self ‚â´ CategoryTheory.Limits.image.Œπ (CategoryTheory.Comma.hom g) =\n    CategoryTheory.Limits.image.Œπ (CategoryTheory.Comma.hom f) ‚â´ CategoryTheory.CommaMorphism.right sq","name":"CategoryTheory.Limits.ImageMap.map_Œπ","isProp":true,"docString":"An image map is a morphism `image f ‚Üí image g` fitting into a commutative square and satisfying\nthe obvious commutativity conditions. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí. Œ≤ ‚äï Œ±} {b : Œ≤} {a : Œ±} (hb : Sum.inl b ‚àà f a), b ‚àà PFun.fix f a","name":"PFun.fix_stop","isProp":true,"docString":"If advancing one step from `a` leads to `b : Œ≤`, then `f.fix a = b` "},{"type":"‚àÄ {b : Ordinal} {o : Ordinal} (hb : 1 < b) {x : Ordinal √ó Ordinal} (a : x ‚àà Ordinal.CNF b o), Prod.snd x < b","name":"Ordinal.CNF_snd_lt","isProp":true,"docString":"Every coefficient in the Cantor normal form `CNF b o` is less than `b`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G} {N : Subgroup G} [inst_1 : Subgroup.Normal N] (h : s ‚äÜ ‚ÜëN),\n  Subgroup.normalClosure s ‚â§ N","name":"Subgroup.normalClosure_le_normal","isProp":true,"docString":"The normal closure of `s` is the smallest normal subgroup containing `s`. "},{"type":"‚àÄ {n : ‚Ñï} (A : Finset (Fin n)) (B : Finset (Fin n)),\n  (Finset.toColex (Finset.image (fun (i : Fin n) ‚Ü¶ ‚Üëi) A) < Finset.toColex (Finset.image (fun (i : Fin n) ‚Ü¶ ‚Üëi) B) :\n      Prop) ‚Üî\n    (Finset.toColex A < Finset.toColex B : Prop)","name":"Colex.hom_fin_lt_iff","isProp":true,"docString":"A special case of `Colex.hom_lt_iff` which is sometimes useful. "},{"type":"‚àÄ {E : Type u_1} [self : SeminormedAddCommGroup E] (x : E) (y : E), dist x y = ‚Äñx - y‚Äñ","name":"SeminormedAddCommGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousAdd G] (H : AddSubgroup G)\n  (h_1_int : 0 ‚àà interior ‚ÜëH), IsOpen ‚ÜëH","name":"AddSubgroup.isOpen_of_zero_mem_interior","isProp":true,"docString":"If a subgroup of an additive topological group has `0` in its interior, then it is\nopen."},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] (S : AddSubmonoid M) {Œπ : Type u_2} {t : Finset Œπ} {f : (a : Œπ) ‚Üí M}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà S), (Finset.sum t fun (c : Œπ) ‚Ü¶ f c) ‚àà S","name":"AddSubmonoid.sum_mem","isProp":true,"docString":"Sum of elements in an `AddSubmonoid` of an `AddCommMonoid` indexed by a `Finset`\nis in the `AddSubmonoid`."},{"type":"‚àÄ {Œπ : Type u_2} {R : Type u_1} [inst : CanonicallyOrderedCommSemiring R] {f : (a : Œπ) ‚Üí R} {s : Finset Œπ}\n  [inst_1 : Nontrivial R], (0 < Finset.prod s fun (i : Œπ) ‚Ü¶ f i : Prop) ‚Üî (‚àÄ (i : Œπ) (a : i ‚àà s), 0 < f i : Prop)","name":"CanonicallyOrderedCommSemiring.prod_pos","isProp":true,"docString":"Note that the name is to match `CanonicallyOrderedCommSemiring.mul_pos`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {Œ≤ : Type u'} [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  (f : (a : Œ≤) ‚Üí C) [inst_2 : CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor f)] (b : Œ≤),\n  CategoryTheory.IsSplitMono (CategoryTheory.Limits.Sigma.Œπ f b)","name":"CategoryTheory.Limits.isSplitMono_sigma_Œπ","isProp":true,"docString":"In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [self : Module.Finite R M], Submodule.Fg ‚ä§","name":"Module.Finite.out","isProp":true,"docString":"A module over a semiring is `Finite` if it is finitely generated as a module. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_3} [inst_1 : CommMonoid N] {P : Type u_2}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëg ‚Üëy)) (x : M) (y : { x : M // x ‚àà S }),\n  ‚Üë(Submonoid.LocalizationMap.lift f hg) (Submonoid.LocalizationMap.mk' f x y) =\n    ‚Üëg x * ‚Üë(‚Üë(IsUnit.liftRight (MonoidHom.restrict g S) hg) y)‚Åª¬π","name":"Submonoid.LocalizationMap.lift_mk'","isProp":true,"docString":"Given a Localization map `f : M ‚Üí* N` for a Submonoid `S ‚äÜ M` and a map of `CommMonoid`s\n`g : M ‚Üí* P` such that `g y` is invertible for all `y : S`, the homomorphism induced from\n`N` to `P` maps `f x * (f y)‚Åª¬π` to `g x * (g y)‚Åª¬π` for all `x : M, y ‚àà S`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] (a : E) (b : E), ‚Äñb‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä + ‚Äña - b‚Äñ‚Çä","name":"nnnorm_le_insert","isProp":true,"docString":"**Alias** of `nnnorm_le_nnnorm_add_nnnorm_sub`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFiltered C] {D : Type u‚ÇÅ}\n  [inst_2 : CategoryTheory.Category D] {L : D ‚•§ C} {R : C ‚•§ D} (h : L ‚ä£ R), CategoryTheory.IsFiltered D","name":"CategoryTheory.IsFiltered.of_right_adjoint","isProp":true,"docString":"If `C` is filtered, and we have a functor `R : C ‚•§ D` with a left adjoint, then `D` is filtered.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±], Finset.upShadow ‚àÖ = ‚àÖ","name":"Finset.upShadow_empty","isProp":true,"docString":"The upper shadow of the empty set is empty. "},{"type":"¬¨(Small Ordinal : Prop)","name":"not_small_ordinal","isProp":true,"docString":"The type of ordinals in universe `u` is not `Small.{u}`. This is the type-theoretic analog of\nthe Burali-Forti paradox. "},{"type":"‚àÄ {x : ENNReal} (xt : x ‚â† ‚ä§),\n  Filter.HasBasis (nhds x) (fun (x : ENNReal) ‚Ü¶ x ‚â† 0) fun (Œµ : ENNReal) ‚Ü¶ Set.Icc (x - Œµ) (x + Œµ)","name":"ENNReal.hasBasis_nhds_of_ne_top'","isProp":true,"docString":"Closed intervals `Set.Icc (x - Œµ) (x + Œµ)`, `Œµ ‚â† 0`, form a basis of neighborhoods of an\nextended nonnegative real number `x ‚â† ‚àû`. We use `Set.Icc` instead of `Set.Ioo` because this way the\nstatement works for `x = 0`.\n"},{"type":"‚àÄ {a : NNReal}, AddLECancellable ‚Üëa","name":"ENNReal.cancel_coe","isProp":true,"docString":"This lemma has an abbreviated name because it is used frequently. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a < b + c), a - b < c","name":"sub_left_lt_of_lt_add","isProp":true,"docString":"**Alias** of the reverse direction of `sub_lt_iff_lt_add'`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A / C) * Finset.card B ‚â§ Finset.card (A * B) * Finset.card (B * C)","name":"Finset.card_div_mul_le_card_mul_mul_card_mul","isProp":true,"docString":"**Ruzsa's triangle inequality**. Div-mul-mul version. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] [inst_1 : DecidableEq Œ±] (s : Finset Œ±) {f : (a : Œ±) ‚Üí Œ≤} {a : Œ±}\n  (h : f a = 0), (Finset.sum (Finset.erase s a) fun (x : Œ±) ‚Ü¶ f x) = Finset.sum s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.sum_erase","isProp":true,"docString":"If a function applied at a point is 0, a sum is unchanged by\nremoving that point, if present, from a `Finset`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f)\n  (h : ‚àÄ (a : Nat.card Œ≤ = 0), Nat.card Œ± = 0), Nat.card Œ± ‚â§ Nat.card Œ≤","name":"Finite.card_le_of_injective'","isProp":true,"docString":"If `f` is injective, then `Nat.card Œ± ‚â§ Nat.card Œ≤`. We must also assume\n`Nat.card Œ≤ = 0 ‚Üí Nat.card Œ± = 0` since `Nat.card` is defined to be `0` for infinite types. "},{"type":"‚àÄ {Œ± : Type u_4} {M : Type u_1} {R : Type u_2} {S : Type u_3} [inst : Zero M] [inst_1 : Semiring R]\n  [inst_2 : Semiring S] (h : R ‚Üí+* S) (f : Œ± ‚Üí‚ÇÄ M) (g : (a : Œ±) ‚Üí (a : M) ‚Üí R),\n  ‚Üëh (Finsupp.sum f g) = Finsupp.sum f fun (a : Œ±) (b : M) ‚Ü¶ ‚Üëh (g a b)","name":"RingHom.map_finsupp_sum","isProp":true,"docString":"Deprecated, use `_root_.map_finsupp_sum` instead. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : CategoryTheory.SimplicialObject.Augmented C}\n  {Y : CategoryTheory.SimplicialObject.Augmented C} (f : X ‚ü∂ Y),\n  (Prefunctor.map (CategoryTheory.Functor.toPrefunctor CategoryTheory.SimplicialObject.Augmented.drop) f).app\n        (Opposite.op (SimplexCategory.mk 0)) ‚â´\n      (CategoryTheory.Comma.hom Y).app (Opposite.op (SimplexCategory.mk 0)) =\n    (CategoryTheory.Comma.hom X).app (Opposite.op (SimplexCategory.mk 0)) ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor CategoryTheory.SimplicialObject.Augmented.point) f","name":"CategoryTheory.SimplicialObject.Augmented.w‚ÇÄ","isProp":true,"docString":"The compatibility of a morphism with the augmentation, on 0-simplices "},{"type":"‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_4 : AddCommMonoid M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ]\n  [inst_6 : RingHomSurjective œÉ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : Set M) (N : Submodule R‚ÇÇ M‚ÇÇ),\n  (Submodule.map f (Submodule.span R s) ‚â§ N : Prop) ‚Üî (‚àÄ (m : M) (a : m ‚àà s), ‚Üëf m ‚àà N : Prop)","name":"LinearMap.map_span_le","isProp":true,"docString":"**Alias** of `Submodule.map_span_le`."},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_2} {N : Type u_1} [inst : CommMonoid M] [inst_1 : OrderedCommMonoid N] (f : (a : M) ‚Üí N)\n  (p : (a : M) ‚Üí Prop) (h_one : f 1 = 1) (h_mul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), f (x * y) ‚â§ f x * f y)\n  (hp_mul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x * y)) (g : (a : Œπ) ‚Üí M) {s : Finset Œπ}\n  (hs : ‚àÄ (i : Œπ) (a : i ‚àà s), p (g i)), f (Finset.prod s fun (i : Œπ) ‚Ü¶ g i) ‚â§ Finset.prod s fun (i : Œπ) ‚Ü¶ f (g i)","name":"Finset.le_prod_of_submultiplicative_on_pred","isProp":true,"docString":"Let `{x | p x}` be a subsemigroup of a commutative monoid `M`. Let `f : M ‚Üí N` be a map\nsuch that `f 1 = 1` and `f` is submultiplicative on `{x | p x}`, i.e.,\n`p x ‚Üí p y ‚Üí f (x * y) ‚â§ f x * f y`. Let `g i`, `i ‚àà s`, be a finite family of elements of `M` such\nthat `‚àÄ i ‚àà s, p (g i)`. Then `f (‚àè i in s, g i) ‚â§ ‚àè i in s, f (g i)`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (hf : Monotone f) (hg : Monotone g), Monotone fun (x : Œ≤) ‚Ü¶ f x * g x","name":"Monotone.mul'","isProp":true,"docString":"The product of two monotone functions is monotone. "},{"type":"‚àÄ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : DecidableEq m] [inst_2 : CommSemiring R]\n  (A : Matrix m m R),\n  ‚Üë(RingHom.mapMatrix (MvPolynomial.eval fun (p : m √ó m) ‚Ü¶ A (Prod.fst p) (Prod.snd p))) (Matrix.mvPolynomialX m m R) =\n    A","name":"Matrix.mvPolynomialX_mapMatrix_eval","isProp":true,"docString":"A variant of `Matrix.mvPolynomialX_map_eval‚ÇÇ` with a bundled `RingHom` on the LHS. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C], CategoryTheory.Faithful CategoryTheory.yoneda","name":"CategoryTheory.Yoneda.yoneda_faithful","isProp":true,"docString":"The Yoneda embedding is faithful.\n\nSee <https://stacks.math.columbia.edu/tag/001P>.\n"},{"type":"‚àÄ {obj : Type u} [self : CategoryTheory.Groupoid obj] {X : obj} {Y : obj} (f : X ‚ü∂ Y),\n  f ‚â´ CategoryTheory.Groupoid.inv f = ùüô X","name":"CategoryTheory.Groupoid.comp_inv","isProp":true,"docString":"`f` composed with `inv f` is the identity "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ≥}\n  (hf : LowerSemicontinuousAt f x) (hg : LowerSemicontinuousAt g x)\n  (hcont : ContinuousAt (fun (p : Œ≥ √ó Œ≥) ‚Ü¶ Prod.fst p + Prod.snd p) (f x, g x)),\n  LowerSemicontinuousAt (fun (z : Œ±) ‚Ü¶ f z + g z) x","name":"LowerSemicontinuousAt.add'","isProp":true,"docString":"The sum of two lower semicontinuous functions is lower semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. "},{"type":"‚àÄ {s : Set ‚Ñù} (h : Metric.Bounded s), EMetric.diam s = ENNReal.ofReal (sup‚Çõ s - inf‚Çõ s)","name":"Real.ediam_eq","isProp":true,"docString":"For a bounded set `s : Set ‚Ñù`, its `EMetric.diam` is equal to `sup‚Çõ s - inf‚Çõ s` reinterpreted as\n`‚Ñù‚â•0‚àû`. "},{"type":"‚àÄ {R : Type u_3} {E : Type u_2} {Œπ : Type u_1} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E]\n  [inst_2 : Module R E] (s : Finset Œπ) (hs : Finset.Nonempty s) (p : (a : Œπ) ‚Üí E),\n  Finset.centroid R s p = Finset.centerMass s (Finset.centroidWeights R s) p","name":"Finset.centroid_eq_centerMass","isProp":true,"docString":"The centroid can be regarded as a center of mass. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : CategoryTheory.Presieve X}\n  {x : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R))}\n  (t : CategoryTheory.Presieve.FamilyOfElements.Compatible x),\n  CategoryTheory.Presieve.FamilyOfElements.sieveExtend\n      (CategoryTheory.Presieve.FamilyOfElements.restrict\n        ((CategoryTheory.Sieve.le_generate\n              R=:R ‚â§\n              CategoryTheory.Sieve.arrows\n                (CategoryTheory.Sieve.generate R))=:R ‚â§ CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R))\n        x) =\n    x","name":"CategoryTheory.Presieve.extend_restrict","isProp":true,"docString":"Given a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted\nto `R` and then extended back up to `S`, the resulting extension equals `x`.\n"},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (r : k) (p‚ÇÅ : P) (p‚ÇÇ : P), r ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ) +·µ• p‚ÇÇ ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ}","name":"smul_vsub_rev_vadd_mem_affineSpan_pair","isProp":true,"docString":"A multiple of the difference of two points added to the second point lies in their affine\nspan. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} (hbc : sbtw a b c) (hcd : sbtw a c d),\n  sbtw a b d","name":"SBtw.sbtw.trans_right","isProp":true,"docString":"**Alias** of `sbtw_trans_right`."},{"type":"‚àÄ {Œ≤ : Type v} {Œ≥ : Type w} [inst : EMetricSpace Œ≥] [inst_1 : EMetricSpace Œ≤] {f : (a : Œ≥) ‚Üí Œ≤},\n  (UniformEmbedding f : Prop) ‚Üî\n    ((‚àÄ (Œµ : ENNReal) (a : Œµ > 0),\n            ‚àÉ (Œ¥ : ENNReal), (Œ¥ > 0 : Prop) ‚àß (‚àÄ {a : Œ≥} {b : Œ≥} (a_1 : edist a b < Œ¥), edist (f a) (f b) < Œµ : Prop) :\n          Prop) ‚àß\n        (‚àÄ (Œ¥ : ENNReal) (a : Œ¥ > 0),\n            ‚àÉ (Œµ : ENNReal), (Œµ > 0 : Prop) ‚àß (‚àÄ {a : Œ≥} {b : Œ≥} (a_1 : edist (f a) (f b) < Œµ), edist a b < Œ¥ : Prop) :\n          Prop) :\n      Prop)","name":"EMetric.uniformEmbedding_iff'","isProp":true,"docString":"A map between emetric spaces is a uniform embedding if and only if the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. "},{"type":"‚àÄ {n : ‚Ñï} (A : Finset (Fin n)) (B : Finset (Fin n)),\n  (Finset.toColex (Finset.image (fun (i : Fin n) ‚Ü¶ ‚Üëi) A) ‚â§ Finset.toColex (Finset.image (fun (i : Fin n) ‚Ü¶ ‚Üëi) B) :\n      Prop) ‚Üî\n    (Finset.toColex A ‚â§ Finset.toColex B : Prop)","name":"Colex.hom_fin_le_iff","isProp":true,"docString":"A special case of `hom_le_iff` which is sometimes useful. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {F : (a : J) ‚Üí C} (self : CategoryTheory.Limits.Bicone F) (j : J) (j' : J),\n  CategoryTheory.Limits.Bicone.Œπ self j ‚â´ CategoryTheory.Limits.Bicone.œÄ self j' =\n    if h : (j = j' : Prop) then CategoryTheory.eqToHom ((congrArg F h=:F j = F j')=:F j = F j') else 0","name":"CategoryTheory.Limits.Bicone.Œπ_œÄ","isProp":true,"docString":"A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `œÄ j : pt ‚ü∂ F j` and `Œπ j : F j ‚ü∂  pt` for each `j`,\n* such that `Œπ j ‚â´ œÄ j'` is the identity when `j = j'` and zero otherwise.\n"},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCancelCommMonoid Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"LinearOrderedCancelCommMonoid.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±] {x : Œ±} {y : Œ±} (hx : 0 < x) (hy : y < 1),\n  ‚àÉ (n : ‚Ñï), y ^ n < x","name":"exists_pow_lt_of_lt_one","isProp":true,"docString":"For any `y < 1` and any positive `x`, there exists `n : ‚Ñï` with `y ^ n < x`. "},{"type":"‚àÄ {œÑ : Type u_1} {Œ± : Type u_2} [inst : CanonicallyOrderedAddMonoid œÑ] {œï : (a : œÑ) ‚Üí (a : Œ±) ‚Üí Œ±} {s : Set Œ±}\n  (h : IsFwInvariant œï s), IsInvariant œï s","name":"IsFwInvariant.isInvariant","isProp":true,"docString":"If `œÑ` is a `CanonicallyOrderedAddMonoid` (e.g., `‚Ñï` or `‚Ñù‚â•0`), then the notions\n`IsFwInvariant` and `IsInvariant` are equivalent. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsGroupHom f) (a : Œ±),\n  f a‚Åª¬π = (f a)‚Åª¬π","name":"IsGroupHom.map_inv","isProp":true,"docString":"A group homomorphism sends inverses to inverses. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} {x‚ÇÄ : X},\n  (EquicontinuousAt F x‚ÇÄ : Prop) ‚Üî\n    (‚àÄ (U : Set (Œ± √ó Œ±)) (a : U ‚àà uniformity Œ±),\n        ‚àÉ (V : Set X),\n          (V ‚àà nhds x‚ÇÄ : Prop) ‚àß (‚àÄ (x : X) (a : x ‚àà V) (y : X) (a : y ‚àà V) (i : Œπ), (F i x, F i y) ‚àà U : Prop) :\n      Prop)","name":"equicontinuousAt_iff_pair","isProp":true,"docString":"Reformulation of equicontinuity at `x‚ÇÄ` comparing two variables near `x‚ÇÄ` instead of comparing\nonly one with `x‚ÇÄ`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : CompleteLinearOrder R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R]\n  [inst_3 : CompleteLinearOrder S] [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {F : Filter R}\n  [inst_6 : Filter.NeBot F] {f : (a : R) ‚Üí S} (f_incr : Monotone f) (f_cont : ContinuousAt f (Filter.liminf‚Çõ F)),\n  f (Filter.liminf‚Çõ F) = Filter.liminf f F","name":"Monotone.map_liminf‚Çõ_of_continuousAt","isProp":true,"docString":"A monotone function between complete linear ordered spaces sends a `Filter.liminf‚Çõ`\nto the `Filter.liminf` of the image if it is continuous at the `liminf‚Çõ`. "},{"type":"‚àÄ {Œ± : Type u} [inst : LT Œ±] [inst_1 : WellFoundedLT Œ±] {C : (a : Œ±) ‚Üí Sort u_1}\n  (F : (x : Œ±) ‚Üí (a : (y : Œ±) ‚Üí (a : y < x) ‚Üí C y) ‚Üí C x) (x : Œ±),\n  WellFoundedLT.fix F x = F x fun (y : Œ±) (x : y < x) ‚Ü¶ WellFoundedLT.fix F y","name":"WellFoundedLT.fix_eq","isProp":true,"docString":"The value from `WellFoundedLT.fix` is built from the previous ones as specified. "},{"type":"‚àÄ {Œ± : Type u_1} (l : List Œ±) (c : Composition (List.length l)), List.join (List.splitWrtComposition l c) = l","name":"List.join_splitWrtComposition","isProp":true,"docString":"If one splits a list along a composition, and then joins the sublists, one gets back the\noriginal list. "},{"type":"‚àÄ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Mul A] [inst_1 : Mul B]\n  [self : MulEquivClass F A B] (f : F) (a : A) (b : A), ‚Üëf (a * b) = ‚Üëf a * ‚Üëf b","name":"MulEquivClass.map_mul","isProp":true,"docString":"Preserves multiplication. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±], Subsingleton (FloorRing Œ±)","name":"subsingleton_floorRing","isProp":true,"docString":"There exists at most one `FloorRing` structure on a given linear ordered ring. "},{"type":"‚àÄ {Œπ : Type u_1} {M : Type u_2} [inst : TopologicalSpace M] [inst_1 : Add M] [inst_2 : ContinuousAdd M],\n  ContinuousAdd ((a : Œπ) ‚Üí M)","name":"Pi.continuousAdd'","isProp":true,"docString":"A version of `pi.continuousAdd` for non-dependent functions. It is needed\nbecause sometimes Lean fails to use `pi.continuousAdd` for non-dependent functions."},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] {s : Set M} {p : (a : M) ‚Üí Prop} {x : M} (h : x ‚àà AddSubmonoid.closure s)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s), p x) (H1 : p 0) (Hmul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x + y)), p x","name":"AddSubmonoid.closure_induction","isProp":true,"docString":"An induction principle for additive closure membership. If `p` holds for `0` and all\nelements of `s`, and is preserved under addition, then `p` holds for all elements of the\nadditive closure of `s`."},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)] [inst_1 : Finite Œπ]\n  [inst_2 : ‚àÄ (i : Œπ), DiscreteTopology (œÄ i)], DiscreteTopology ((i : Œπ) ‚Üí œÄ i)","name":"Pi.discreteTopology","isProp":true,"docString":"A finite product of discrete spaces is discrete. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] (self : OneHom M N), OneHom.toFun self 1 = 1","name":"OneHom.map_one'","isProp":true,"docString":"The proposition that the function preserves 1 "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T5Space Œ±], T5Space (SeparationQuotient Œ±)","name":"instT5SpaceSeparationQuotientInstTopologicalSpaceSeparationQuotient","isProp":true,"docString":"The `SeparationQuotient` of a completely normal space is a T‚ÇÖ space. We don't have separate\ntypeclasses for completely normal spaces (without T‚ÇÅ assumption) and T‚ÇÖ spaces, so we use the same\nclass for assumption and for conclusion.\n\nOne can prove this using a homeomorphism between `Œ±` and `SeparationQuotient Œ±`. We give an\nalternative proof that works without assuming that `Œ±` is a T‚ÇÅ space. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {i : (a : Œ±) ‚Üí Œ≤}\n  (self : DenseInducing i), DenseRange i","name":"DenseInducing.dense","isProp":true,"docString":"The range of a dense inducing map is a dense set. "},{"type":"‚àÄ {I : Type u} {Œ≤ : Type u_1} [inst : DecidableEq I] [inst_1 : One Œ≤] (i : I) (x : Œ≤) (i' : I),\n  Pi.mulSingle i x i' = if (i' = i : Prop) then x else 1","name":"Pi.mulSingle_apply","isProp":true,"docString":"On non-dependent functions, `Pi.mulSingle` can be expressed as an `ite` "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] {s : Set R} {p : (a : R) ‚Üí Prop} {x : R} (h : x ‚àà Subsemiring.closure s)\n  (Hs : ‚àÄ (x : R) (a : x ‚àà s), p x) (H0 : p 0) (H1 : p 1) (Hadd : ‚àÄ (x : R) (y : R) (a : p x) (a : p y), p (x + y))\n  (Hmul : ‚àÄ (x : R) (y : R) (a : p x) (a : p y), p (x * y)), p x","name":"Subsemiring.closure_induction","isProp":true,"docString":"An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition and multiplication, then `p` holds for all elements\nof the closure of `s`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {k : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±}\n  (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousAt f x),\n  ‚àÉ (t : Set Œ≤), (k ‚äÜ t : Prop) ‚àß ((IsOpen t : Prop) ‚àß (Metric.Bounded (f '' t) : Prop) : Prop)","name":"Metric.exists_isOpen_bounded_image_of_isCompact_of_forall_continuousAt","isProp":true,"docString":"If a function is continuous at every point of a compact set `k`, then it is bounded on\nsome open neighborhood of `k`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i) < Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (¬¨(MonovaryOn (f ‚àò ‚ÜëœÉ) g ‚Üës : Prop) : Prop)","name":"MonovaryOn.sum_comp_perm_mul_lt_sum_mul_iff","isProp":true,"docString":"**Strict inequality case of Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f ‚àò œÉ` and `g` do not monovary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommMonoid M] [inst_1 : CommRing R] [inst_2 : Nontrivial R],\n  (Algebra.FiniteType R (MonoidAlgebra R M) : Prop) ‚Üî (Monoid.Fg M : Prop)","name":"MonoidAlgebra.finiteType_iff_fg","isProp":true,"docString":"A monoid `M` is finitely generated if and only if `MonoidAlgebra R M` is of finite type. "},{"type":"‚àÄ {G : Type u_2} [inst : AddGroup G] {H : AddSubgroup G} {N : Type u_1} [inst_1 : AddGroup N] (f : N ‚Üí+ G),\n  AddSubgroup.comap f (AddSubgroup.normalizer H) ‚â§ AddSubgroup.normalizer (AddSubgroup.comap f H)","name":"AddSubgroup.le_normalizer_comap","isProp":true,"docString":"The preimage of the normalizer is contained in the normalizer of the preimage."},{"type":"‚àÄ {R : Type u_2} {M : Type u_3} [inst : CommRing R] [inst_1 : TopologicalSpace R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} [inst_4 : TopologicalRing R] [inst_5 : TopologicalSpace M]\n  [inst_6 : TopologicalAddGroup M] {p : (a : Œπ) ‚Üí Prop} {b : (a : Œπ) ‚Üí Set M} (h : Filter.HasBasis (nhds 0) p b)\n  (hsmul : ‚àÄ {i : Œπ} (a : p i), ‚àÉ (V : Set R), (V ‚àà nhds 0 : Prop) ‚àß (‚àÉ (j : Œπ), ‚àÉ (x : p j), V ‚Ä¢ b j ‚äÜ b i : Prop))\n  (hsmul_left : ‚àÄ (x‚ÇÄ : R) {i : Œπ} (a : p i), ‚àÉ (j : Œπ), ‚àÉ (x : p j), b j ‚äÜ (fun (x : M) ‚Ü¶ x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' b i)\n  (hsmul_right : ‚àÄ (m‚ÇÄ : M) {i : Œπ} (a : p i), Filter.Eventually (fun (x : R) ‚Ü¶ x ‚Ä¢ m‚ÇÄ ‚àà b i) (nhds 0)),\n  ContinuousSMul R M","name":"ContinuousSMul.of_basis_zero","isProp":true,"docString":"A topological add group with a basis of `ùìù 0` satisfying the axioms of `ModuleFilterBasis`\nis a topological module.\n\nThis lemma is mathematically useless because one could obtain such a result by applying\n`ModuleFilterBasis.continuousSMul` and use the fact that group topologies are characterized\nby their neighborhoods of 0 to obtain the `ContinuousSMul` on the pre-existing topology.\n\nBut it turns out it's just easier to get it as a byproduct of the proof, so this is just a free\nquality-of-life improvement. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedSemiring Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"LinearOrderedSemiring.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : LT Œ±]\n  [inst_2 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (bc : a * b < a * c), b < c","name":"OrderedCommGroup.lt_of_mul_lt_mul_left","isProp":true,"docString":"**Alias** of `lt_of_mul_lt_mul_left'`."},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {x : ùïú} {y : ùïú} {z : ùïú} (h : x < y),\n  (z ‚àà Set.Ioo x y : Prop) ‚Üî\n    (‚àÉ (a : ùïú),\n        ‚àÉ (b : ùïú), (0 < a : Prop) ‚àß ((0 < b : Prop) ‚àß ((a + b = 1 : Prop) ‚àß (a * x + b * y = z : Prop) : Prop) : Prop) :\n      Prop)","name":"Convex.mem_Ioo","isProp":true,"docString":"A point is in an `Ioo` iff it can be expressed as a strict convex combination of the endpoints.\n"},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M‚ÇÇ]\n  [inst_3 : Module R M] [inst_4 : Module R M‚ÇÇ] (f : M ‚âÉ‚Çó[R] M‚ÇÇ) (p : Submodule R M),\n  FiniteDimensional.finrank R { x : M‚ÇÇ // x ‚àà Submodule.map (‚Üëf) p } = FiniteDimensional.finrank R { x : M // x ‚àà p }","name":"LinearEquiv.finrank_map_eq","isProp":true,"docString":"Pushforwards of finite-dimensional submodules along a `LinearEquiv` have the same finrank. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} [inst_3 : IsTrans Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1] (h‚ÇÅ : a ‚äÇ b) (h‚ÇÇ : b ‚äÜ c), a ‚äÇ c","name":"HasSSubset.SSubset.trans_subset","isProp":true,"docString":"**Alias** of `ssubset_of_ssubset_of_subset`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {r : ‚Ñù} (hr : 0 ‚â§ r)\n  (H1 : ‚àÄ (x : Œ±) (a : x ‚àà s), ‚àÉ (y : Œ±), (y ‚àà t : Prop) ‚àß (dist x y ‚â§ r : Prop))\n  (H2 : ‚àÄ (x : Œ±) (a : x ‚àà t), ‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (dist x y ‚â§ r : Prop)), Metric.hausdorffDist s t ‚â§ r","name":"Metric.hausdorffDist_le_of_mem_dist","isProp":true,"docString":"Bounding the Hausdorff distance by exhibiting, for any point in each set,\nanother point in the other set at controlled distance "},{"type":"‚àÄ (x : ‚Ñù), 0 < Real.cosh x","name":"Real.cosh_pos","isProp":true,"docString":"`Real.cosh` is always positive "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : IsPredArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc n m), r (Order.pred i) i)\n  (hmn : n < m), Relation.TransGen r n m","name":"transGen_of_pred_of_lt","isProp":true,"docString":"For `n < m`, `(n, m)` is in the transitive closure of a relation `~` for `n ‚â† m` if `pred i ~ i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] {a : Œ±} {b : Œ±} (c : Œ±) (h : a * c = b), a ‚à£ b","name":"dvd_of_mul_right_eq","isProp":true,"docString":"**Alias** of `Dvd.intro`."},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] {s : Set E} (a : Metric.Bounded s),\n  ‚àÉ (C : ‚Ñù), ‚àÄ (x : E) (a : x ‚àà s), ‚Äñx‚Äñ ‚â§ C","name":"Metric.Bounded.exists_norm_le","isProp":true,"docString":"**Alias** of the forward direction of `bounded_iff_forall_norm_le`."},{"type":"‚àÄ {Œ± : Type u_1} {A : Set Œ±} {Œ≤ : Type u_2} [inst : CommMonoid Œ±] [inst_1 : CommMonoid Œ≤] {n : ‚Ñï} (self : A ‚Üí*[n] Œ≤)\n  {s : Multiset Œ±} {t : Multiset Œ±} (hsA : ‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà s), x ‚àà A) (htA : ‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà t), x ‚àà A)\n  (hs : ‚ÜëMultiset.card s = n) (ht : ‚ÜëMultiset.card t = n) (h : Multiset.prod s = Multiset.prod t),\n  Multiset.prod (Multiset.map (FreimanHom.toFun self) s) = Multiset.prod (Multiset.map (FreimanHom.toFun self) t)","name":"FreimanHom.map_prod_eq_map_prod'","isProp":true,"docString":"A `n`-Freiman homomorphism preserves products of `n` elements. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] {n : ‚Ñ§} {a : Œ±} {b : Œ±} (hn : n ‚â† 0),\n  (n ‚Ä¢ a = n ‚Ä¢ b : Prop) ‚Üî (a = b : Prop)","name":"zsmul_eq_zsmul_iff'","isProp":true,"docString":"Alias of `zsmul_right_inj`, for ease of discovery alongside\n`zsmul_le_zsmul_iff'` and `zsmul_lt_zsmul_iff'`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {P : CategoryTheory.Subobject Y}\n  {f : X ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.Subobject.underlying) P}\n  {g : X ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.Subobject.underlying) P}\n  (h : f ‚â´ CategoryTheory.Subobject.arrow P = g ‚â´ CategoryTheory.Subobject.arrow P), f = g","name":"CategoryTheory.Subobject.eq_of_comp_arrow_eq","isProp":true,"docString":"Two morphisms into a subobject are equal exactly if\nthe morphisms into the ambient object are equal "},{"type":"‚àÄ {R : Type u} [inst : Semigroup R] [self : StarSemigroup R] (r : R) (s : R), star (r * s) = star s * star r","name":"StarSemigroup.star_mul","isProp":true,"docString":"`star` skew-distributes over multiplication. "},{"type":"‚àÄ {Œ± : Type u} {m : ‚Ñï} (x : Œ±) (u : (a : Fin (Nat.succ m)) ‚Üí Œ±), Matrix.vecCons x u 1 = Matrix.vecHead u","name":"Matrix.cons_val_one","isProp":true,"docString":"`![a, b, ...] 1` is equal to `b`.\n\nThe simplifier needs a special lemma for length `‚â• 2`, in addition to\n`cons_val_succ`, because `1 : Fin 1 = 0 : Fin 1`.\n"},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (ha : a ‚â† 0) (hb : b ‚â† 0), Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b","name":"Nat.perm_factors_mul","isProp":true,"docString":"For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : (a : Œ±) ‚Üí Œ±} (hf : Continuous f),\n  IsClosed (Function.fixedPoints f)","name":"isClosed_fixedPoints","isProp":true,"docString":"The set of fixed points of a continuous map is a closed set. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (m : Multiset M)\n  (a : ‚àÄ (a : M) (a_1 : a ‚àà m), a ‚àà s), Multiset.sum m ‚àà s","name":"IsAddSubmonoid.multiset_sum_mem","isProp":true,"docString":"The sum of a multiset of elements of an `AddSubmonoid` of an `AddCommMonoid`\nis an element of the `AddSubmonoid`. "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] (self : AbstractCompletion Œ±), CompleteSpace (AbstractCompletion.space self)","name":"AbstractCompletion.complete","isProp":true,"docString":"The completion is complete. "},{"type":"‚àÄ {n : ‚Ñï} (w : 0 < n) (h : ¬¨(Nat.Prime n : Prop)), Nat.minFac n ^ 2 ‚â§ n","name":"Nat.minFac_sq_le_self","isProp":true,"docString":"The square of the smallest prime factor of a composite number `n` is at most `n`.\n"},{"type":"‚àÄ {R : Type u} [inst : Ring R] {S : Subring R} {T : Subring R} (h : ‚àÄ (x : R), (x ‚àà S : Prop) ‚Üî (x ‚àà T : Prop)), S = T","name":"Subring.ext","isProp":true,"docString":"Two subrings are equal if they have the same elements. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P) (direction : Submodule k V), p ‚àà AffineSubspace.mk' p direction","name":"AffineSubspace.self_mem_mk'","isProp":true,"docString":"An affine subspace constructed from a point and a direction contains that point. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ≤] {f : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f)\n  (hlim : Filter.Tendsto f (Filter.cocompact Œ≤) Filter.atBot), ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f y ‚â§ f x","name":"Continuous.exists_forall_ge","isProp":true,"docString":"The **extreme value theorem**: if a continuous function `f` tends to negative infinity away from\ncompact sets, then it has a global maximum. "},{"type":"‚àÄ (R : Type u_2) {M : Type u_1} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (n : ‚Ñ§) (b : M),\n  n ‚Ä¢ b = ‚Üën ‚Ä¢ b","name":"zsmul_eq_smul_cast","isProp":true,"docString":"`zsmul` is equal to any other module structure via a cast. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type u_1} [inst : TopologicalSpace Œ±] (b : (a : Œπ) ‚Üí Set Œ±)\n  (hb : TopologicalSpace.IsTopologicalBasis (Set.range b)) (hb' : ‚àÄ (i : Œπ), IsCompact (b i)) (U : Set Œ±),\n  ((IsCompact U : Prop) ‚àß (IsOpen U : Prop) : Prop) ‚Üî\n    (‚àÉ (s : Set Œπ), (Set.Finite s : Prop) ‚àß (U = Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà s) ‚Ü¶ b i : Prop) :\n      Prop)","name":"isCompact_open_iff_eq_finite_union·µ¢_of_isTopologicalBasis","isProp":true,"docString":"If `Œ±` has a basis consisting of compact opens, then an open set in `Œ±` is compact open iff\nit is a finite union of some elements in the basis "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : GCDMonoid Œ±] {m : Œ±} {n : Œ±} {k : Œ±} (H : k ‚à£ m * n),\n  ‚àÉ (d‚ÇÅ : Œ±), ‚àÉ (d‚ÇÇ : Œ±), (d‚ÇÅ ‚à£ m : Prop) ‚àß ((d‚ÇÇ ‚à£ n : Prop) ‚àß (k = d‚ÇÅ * d‚ÇÇ : Prop) : Prop)","name":"exists_dvd_and_dvd_of_dvd_mul","isProp":true,"docString":"Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`.\n\nIn other words, the nonzero elements of a `GCDMonoid` form a decomposition monoid\n(more widely known as a pre-Schreier domain in the context of rings).\n\nNote: In general, this representation is highly non-unique.\n\nSee `Nat.prodDvdAndDvdOfDvdProd` for a constructive version on `‚Ñï`.  "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (self : LocalEquiv Œ± Œ≤) ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà LocalEquiv.source self),\n  LocalEquiv.invFun self (LocalEquiv.toFun self x) = x","name":"LocalEquiv.left_inv'","isProp":true,"docString":"The proposition that `invFun` is a local left-inverse of `toFun` on `source`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {n : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {I : R ‚Üí+* R} {I' : R ‚Üí+* R} [inst_3 : Nontrivial R] {B : M ‚Üí‚Çõ‚Çó[I] M ‚Üí‚Çõ‚Çó[I'] R} {v : Basis n R M}\n  (h : LinearMap.IsOrtho·µ¢ B ‚Üëv) (hB : LinearMap.SeparatingLeft B) (i : n), ¬¨(LinearMap.IsOrtho B (‚Üëv i) (‚Üëv i) : Prop)","name":"LinearMap.IsOrtho·µ¢.not_isOrtho_basis_self_of_separatingLeft","isProp":true,"docString":"An orthogonal basis with respect to a left-separating bilinear form has no self-orthogonal\nelements. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Bot Œ±] [inst_1 : Bot Œ≤]\n  [self : BotHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä• = ‚ä•","name":"BotHomClass.map_bot","isProp":true,"docString":"A `BotHomClass` morphism preserves the bottom element. "},{"type":"‚àÄ {A : Type u_1} [inst : AddMonoid A], FaithfulSMul (AddAut A) A","name":"AddAut.apply_faithfulSMul","isProp":true,"docString":"`AddAut.applyDistribMulAction` is faithful. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M),\n  (S = ‚ä• : Prop) ‚à® (‚àÉ (x : M), (x ‚àà S : Prop) ‚àß (x ‚â† 1 : Prop) : Prop)","name":"Submonoid.bot_or_exists_ne_one","isProp":true,"docString":"A submonoid is either the trivial submonoid or contains a nonzero element. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {x‚ÇÅ : R} {x‚ÇÇ : R} {x‚ÇÉ : R} {x‚ÇÑ : R} {x‚ÇÖ : R} {x‚ÇÜ : R} {x‚Çá : R} {x‚Çà : R} {y‚ÇÅ : R}\n  {y‚ÇÇ : R} {y‚ÇÉ : R} {y‚ÇÑ : R} {y‚ÇÖ : R} {y‚ÇÜ : R} {y‚Çá : R} {y‚Çà : R},\n  (x‚ÇÅ ^ 2 + x‚ÇÇ ^ 2 + x‚ÇÉ ^ 2 + x‚ÇÑ ^ 2 + x‚ÇÖ ^ 2 + x‚ÇÜ ^ 2 + x‚Çá ^ 2 + x‚Çà ^ 2) *\n      (y‚ÇÅ ^ 2 + y‚ÇÇ ^ 2 + y‚ÇÉ ^ 2 + y‚ÇÑ ^ 2 + y‚ÇÖ ^ 2 + y‚ÇÜ ^ 2 + y‚Çá ^ 2 + y‚Çà ^ 2) =\n    (x‚ÇÅ * y‚ÇÅ - x‚ÇÇ * y‚ÇÇ - x‚ÇÉ * y‚ÇÉ - x‚ÇÑ * y‚ÇÑ - x‚ÇÖ * y‚ÇÖ - x‚ÇÜ * y‚ÇÜ - x‚Çá * y‚Çá - x‚Çà * y‚Çà) ^ 2 +\n                  (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ + x‚ÇÉ * y‚ÇÑ - x‚ÇÑ * y‚ÇÉ + x‚ÇÖ * y‚ÇÜ - x‚ÇÜ * y‚ÇÖ - x‚Çá * y‚Çà + x‚Çà * y‚Çá) ^ 2 +\n                (x‚ÇÅ * y‚ÇÉ - x‚ÇÇ * y‚ÇÑ + x‚ÇÉ * y‚ÇÅ + x‚ÇÑ * y‚ÇÇ + x‚ÇÖ * y‚Çá + x‚ÇÜ * y‚Çà - x‚Çá * y‚ÇÖ - x‚Çà * y‚ÇÜ) ^ 2 +\n              (x‚ÇÅ * y‚ÇÑ + x‚ÇÇ * y‚ÇÉ - x‚ÇÉ * y‚ÇÇ + x‚ÇÑ * y‚ÇÅ + x‚ÇÖ * y‚Çà - x‚ÇÜ * y‚Çá + x‚Çá * y‚ÇÜ - x‚Çà * y‚ÇÖ) ^ 2 +\n            (x‚ÇÅ * y‚ÇÖ - x‚ÇÇ * y‚ÇÜ - x‚ÇÉ * y‚Çá - x‚ÇÑ * y‚Çà + x‚ÇÖ * y‚ÇÅ + x‚ÇÜ * y‚ÇÇ + x‚Çá * y‚ÇÉ + x‚Çà * y‚ÇÑ) ^ 2 +\n          (x‚ÇÅ * y‚ÇÜ + x‚ÇÇ * y‚ÇÖ - x‚ÇÉ * y‚Çà + x‚ÇÑ * y‚Çá - x‚ÇÖ * y‚ÇÇ + x‚ÇÜ * y‚ÇÅ - x‚Çá * y‚ÇÑ + x‚Çà * y‚ÇÉ) ^ 2 +\n        (x‚ÇÅ * y‚Çá + x‚ÇÇ * y‚Çà + x‚ÇÉ * y‚ÇÖ - x‚ÇÑ * y‚ÇÜ - x‚ÇÖ * y‚ÇÉ + x‚ÇÜ * y‚ÇÑ + x‚Çá * y‚ÇÅ - x‚Çà * y‚ÇÇ) ^ 2 +\n      (x‚ÇÅ * y‚Çà - x‚ÇÇ * y‚Çá + x‚ÇÉ * y‚ÇÜ + x‚ÇÑ * y‚ÇÖ - x‚ÇÖ * y‚ÇÑ - x‚ÇÜ * y‚ÇÉ + x‚Çá * y‚ÇÇ + x‚Çà * y‚ÇÅ) ^ 2","name":"sum_eight_sq_mul_sum_eight_sq","isProp":true,"docString":"Degen's eight squares identity, see <https://en.wikipedia.org/wiki/Degen%27s_eight-square_identity>.\n\nThis sign choice here corresponds to the signs obtained by multiplying two octonions.\n"},{"type":"‚àÄ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R}\n  (hM : Matrix.Nondegenerate M) {v : (a : m) ‚Üí R} (hv : v ‚â† 0),\n  ‚àÉ (w : (a : m) ‚Üí R), Matrix.dotProduct v (Matrix.mulVec M w) ‚â† 0","name":"Matrix.Nondegenerate.exists_not_ortho_of_ne_zero","isProp":true,"docString":"If `M` is nondegenerate and `v ‚â† 0`, then there is some `w` such that `w ‚¨ù M ‚¨ù v ‚â† 0`. "},{"type":"‚àÄ {p : EReal √ó EReal} (h : (Prod.fst p ‚â† ‚ä§ : Prop) ‚à® (Prod.snd p ‚â† ‚ä• : Prop))\n  (h' : (Prod.fst p ‚â† ‚ä• : Prop) ‚à® (Prod.snd p ‚â† ‚ä§ : Prop)),\n  ContinuousAt (fun (p : EReal √ó EReal) ‚Ü¶ Prod.fst p + Prod.snd p) p","name":"EReal.continuousAt_add","isProp":true,"docString":"The addition on `EReal` is continuous except where it doesn't make sense (i.e., at `(‚ä•, ‚ä§)`\nand at `(‚ä§, ‚ä•)`). "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (ha : a < 1) (hb : b ‚â§ 1), a * b < 1","name":"Right.mul_lt_one_of_lt_of_le","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_lt_of_le`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {s : Set Œ±} [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤},\n  ((¬¨(MonotoneOn f s : Prop) : Prop) ‚àß (¬¨(AntitoneOn f s : Prop) : Prop) : Prop) ‚Üî\n    (‚àÉ (a : Œ±),\n        ‚àÉ (x : a ‚àà s),\n          ‚àÉ (b : Œ±),\n            ‚àÉ (x : b ‚àà s),\n              ‚àÉ (c : Œ±),\n                ‚àÉ (x : c ‚àà s),\n                  (a < b : Prop) ‚àß\n                    ((b < c : Prop) ‚àß\n                        (((f a < f b : Prop) ‚àß (f c < f b : Prop) : Prop) ‚à®\n                            ((f b < f a : Prop) ‚àß (f b < f c : Prop) : Prop) :\n                          Prop) :\n                      Prop) :\n      Prop)","name":"Set.not_monotoneOn_not_antitoneOn_iff_exists_lt_lt","isProp":true,"docString":"A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalAddGroup Œ±]\n  [inst_3 : T2Space Œ±] (f : (a : ‚Ñï) ‚Üí Œ±),\n  Filter.Tendsto (fun (i : ‚Ñï) ‚Ü¶ tsum fun (k : ‚Ñï) ‚Ü¶ f (k + i)) Filter.atTop (nhds 0)","name":"tendsto_sum_nat_add","isProp":true,"docString":"For `f : ‚Ñï ‚Üí Œ±`, then `‚àë' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R} (hp : Polynomial.Monic p)\n  (hroots : ‚ÜëMultiset.card (Polynomial.roots p) = Polynomial.natDegree p),\n  Multiset.prod (Multiset.map (fun (a : R) ‚Ü¶ Polynomial.X - ‚ÜëPolynomial.C a) (Polynomial.roots p)) = p","name":"Polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq","isProp":true,"docString":"A monic polynomial `p` that has as many roots as its degree\ncan be written `p = ‚àè(X - a)`, for `a` in `p.roots`. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] [inst_3 : PosMulMono Œ±]\n  (ha : 1 < a) (hb : 1 ‚â§ b) (a0 : 0 ‚â§ a), 1 < a * b","name":"Left.lt_mul_of_lt_of_one_le_of_nonneg","isProp":true,"docString":"Assumes left covariance. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C]\n  [self : CategoryTheory.Pretriangulated C] (X : C) (Y : C) (f : X ‚ü∂ Y),\n  ‚àÉ (Z : C),\n    ‚àÉ (g : Y ‚ü∂ Z),\n      ‚àÉ (h : Z ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C 1)) X),\n        CategoryTheory.Pretriangulated.Triangle.mk f g h ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles","name":"CategoryTheory.Pretriangulated.distinguished_cocone_triangle","isProp":true,"docString":"any morphism `X ‚ü∂ Y` is part of a distinguished triangle `X ‚ü∂ Y ‚ü∂ Z ‚ü∂ X‚ü¶1‚üß` "},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_1} {M : Type u_2} {v : (a : Œπ) ‚Üí M} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] (hv : LinearIndependent R v), CompleteLattice.Independent fun (i : Œπ) ‚Ü¶ Submodule.span R {v i}","name":"LinearIndependent.independent_span_singleton","isProp":true,"docString":"See also `CompleteLattice.independent_iff_linearIndependent_of_ne_zero`. "},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (hab : Nat.coprime a b), List.Disjoint (Nat.factors a) (Nat.factors b)","name":"Nat.coprime_factors_disjoint","isProp":true,"docString":"The sets of factors of coprime `a` and `b` are disjoint "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s1 : AffineSubspace k P} {s2 : AffineSubspace k P} (h1 : Set.Nonempty ‚Üës1)\n  (h2 : Set.Nonempty ‚Üës2) (hd : IsCompl (AffineSubspace.direction s1) (AffineSubspace.direction s2)),\n  ‚àÉ (p : P), ‚Üës1 ‚à© ‚Üës2 = {p}","name":"AffineSubspace.inter_eq_singleton_of_nonempty_of_isCompl","isProp":true,"docString":"If the directions of two nonempty affine subspaces are complements of each other, they intersect\nin exactly one point. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedMonoid Œ±] (a : Œ±) (b : Œ±), a ‚â§ a * b","name":"CanonicallyOrderedMonoid.le_self_mul","isProp":true,"docString":"For any `a` and `b`, `a ‚â§ a * b` "},{"type":"‚àÄ {p : ‚Ñï} (hp : Nat.Prime p), Nat.factorization p = Finsupp.single p 1","name":"Nat.Prime.factorization","isProp":true,"docString":"The only prime factor of prime `p` is `p` itself, with multiplicity `1` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±}\n  {p : Filter Œπ}, (TendstoUniformlyOn F f p {x} : Prop) ‚Üî (Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n x) p (nhds (f x)) : Prop)","name":"tendstoUniformlyOn_singleton_iff_tendsto","isProp":true,"docString":"Uniform convergence on a singleton is equivalent to regular convergence "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (self : M ‚âÉ* N) (x : M) (y : M),\n  Equiv.toFun (MulEquiv.toEquiv self) (x * y) =\n    Equiv.toFun (MulEquiv.toEquiv self) x * Equiv.toFun (MulEquiv.toEquiv self) y","name":"MulEquiv.map_mul'","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {Œ± : Type u_1} (l : List Œ±) (c : Composition (List.length l)),\n  List.map List.length (List.splitWrtComposition l c) = Composition.blocks c","name":"List.map_length_splitWrtComposition","isProp":true,"docString":"When one splits a list along a composition `c`, the lengths of the sublists thus created are\ngiven by the block sizes in `c`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤},\n  (ConvexOn ùïú s (-f) : Prop) ‚Üî (ConcaveOn ùïú s f : Prop)","name":"neg_convexOn_iff","isProp":true,"docString":"A function `-f` is convex iff `f` is concave. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {F : Type u_3}\n  [mc : MonoidHomClass F M N] (f : F) (s : Set M), Submonoid.map f (Submonoid.closure s) = Submonoid.closure (‚Üëf '' s)","name":"MonoidHom.map_mclosure","isProp":true,"docString":"The image under a monoid hom of the submonoid generated by a set equals the submonoid generated\nby the image of the set. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : (a : Œ±) ‚Üí Œ≤} [inst : AddCommMonoid Œ≤] (R : Setoid Œ±)\n  [inst_1 : DecidableRel Setoid.r]\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s), (Finset.sum (Finset.filter (fun (y : Œ±) ‚Ü¶ y ‚âà x) s) fun (a : Œ±) ‚Ü¶ f a) = 0),\n  (Finset.sum s fun (x : Œ±) ‚Ü¶ f x) = 0","name":"Finset.sum_cancels_of_partition_cancels","isProp":true,"docString":"If we can partition a sum into subsets that cancel out, then the whole sum cancels."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} {v : Vector Œ± n}, Vector.toList (Vector.reverse v) = List.reverse (Vector.toList v)","name":"Vector.toList_reverse","isProp":true,"docString":"The `List` of a vector after a `reverse`, retrieved by `toList` is equal\nto the `List.reverse` after retrieving a vector's `toList`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Finset Œ±} {k : ‚Ñï} (h : Finset.card s = k) (hz : 0 < k),\n  ‚Üë(Finset.orderEmbOfFin s h)\n      { val := k - 1,\n        isLt := ((Nat.sub_lt hz ((Nat.succ_pos 0=:0 < Nat.succ 0)=:0 < Nat.succ 0)=:k - 1 < k)=:k - 1 < k) } =\n    Finset.max' s\n      ((Iff.mp\n            ((Finset.card_pos=:(0 < Finset.card s : Prop) ‚Üî\n                  (Finset.Nonempty s : Prop))=:(0 < Finset.card s : Prop) ‚Üî (Finset.Nonempty s : Prop))\n            ((Eq.rec hz\n                  ((Eq.symm\n                        h=:k =\n                        Finset.card\n                          s)=:k =\n                      Finset.card s)=:0 < Finset.card s)=:0 < Finset.card s)=:Finset.Nonempty s)=:Finset.Nonempty s)","name":"Finset.orderEmbOfFin_last","isProp":true,"docString":"The bijection `orderEmbOfFin s h` sends `k-1` to the maximum of `s`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasFiniteCoproducts C] (n : ‚Ñï),\n  CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete (Fin n)) C","name":"CategoryTheory.Limits.HasFiniteCoproducts.out","isProp":true,"docString":"`C` has all finite coproducts "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] (f : R ‚Üí+* S), Polynomial.X ‚àà Polynomial.lifts f","name":"Polynomial.X_mem_lifts","isProp":true,"docString":"The polynomial `X` lifts. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {K : NNReal} {s : Set Œ±}\n  {f : (a : Œ±) ‚Üí Œ≤} (a : LipschitzOnWith K f s) (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s),\n  dist (f x) (f y) ‚â§ ‚ÜëK * dist x y","name":"LipschitzOnWith.dist_le_mul","isProp":true,"docString":"**Alias** of the forward direction of `lipschitzOnWith_iff_dist_le_mul`."},{"type":"‚àÄ {Œ± : Type u} [inst : AddMonoid Œ±] (f : (a : ‚Ñï) ‚Üí Œ±) (n : ‚Ñï),\n  List.sum (List.map f (List.range (Nat.succ n))) =\n    f 0 + List.sum (List.map (fun (i : ‚Ñï) ‚Ü¶ f (Nat.succ i)) (List.range n))","name":"List.sum_range_succ'","isProp":true,"docString":"A variant of `sum_range_succ` which pulls off the first term in the sum rather than the last."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] (a : Œ±),\n  ((abs a = a : Prop) ‚àß (0 ‚â§ a : Prop) : Prop) ‚à® ((abs a = -a : Prop) ‚àß (a < 0 : Prop) : Prop)","name":"abs_cases","isProp":true,"docString":"For an element `a` of a linear ordered ring, either `abs a = a` and `0 ‚â§ a`,\nor `abs a = -a` and `a < 0`.\nUse cases on this lemma to automate linarith in inequalities "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : IsLowerModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : b ‚ãñ a ‚äî b), a ‚äì b ‚ãñ a","name":"Covby.inf_of_sup_right","isProp":true,"docString":"**Alias** of `inf_covby_of_covby_sup_right`."},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (a : Œ±) {b : Œ±}\n  (a_1 : 0 < b), a - b < a","name":"sub_lt_self","isProp":true,"docString":"**Alias** of the reverse direction of `sub_lt_self_iff`."},{"type":"‚àÄ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] (p : ‚Ñï) (q : ‚Ñï) [inst_2 : CharP R p] [inst : ExpChar R q],\n  (q = 1 : Prop) ‚Üî (p = 0 : Prop)","name":"expChar_one_iff_char_zero","isProp":true,"docString":"The exponential characteristic is one iff the characteristic is zero. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (self : NonarchAddGroupSeminorm G) (r : G) (s : G),\n  ZeroHom.toFun (NonarchAddGroupSeminorm.toZeroHom self) (r + s) ‚â§\n    max (ZeroHom.toFun (NonarchAddGroupSeminorm.toZeroHom self) r)\n      (ZeroHom.toFun (NonarchAddGroupSeminorm.toZeroHom self) s)","name":"NonarchAddGroupSeminorm.add_le_max'","isProp":true,"docString":"The seminorm applied to a sum is dominated by the maximum of the function applied to the\naddends. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ≤' : Type u_1} {Œ¥ : Type u_2}\n  {f : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥} {g : (a : Œ≤) ‚Üí Œ≤'} {f' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_right_comm : ‚àÄ (a : Œ±) (b : Œ≤), f a (g b) = g' (f' a b)),\n  Option.map‚ÇÇ f a (Option.map g b) = Option.map g' (Option.map‚ÇÇ f' a b)","name":"Option.map_map‚ÇÇ_right_comm","isProp":true,"docString":"Symmetric statement to `Option.map_map‚ÇÇ_distrib_right`. "},{"type":"‚àÄ {m : ‚Ñï+} {n : ‚Ñï+}, (‚Üëm = ‚Üën : Prop) ‚Üî (m = n : Prop)","name":"PNat.coe_inj","isProp":true,"docString":"We now define a long list of structures on `‚Ñï+` induced by\nsimilar structures on `‚Ñï`. Most of these behave in a completely\nobvious way, but there are a few things to be said about\nsubtraction, division and powers.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set (Œ± √ó Œ±)} {x : Œ±} (hx : s ‚àà nhds (x, x)),\n  ‚àÉ (U : Set Œ±), (IsOpen U : Prop) ‚àß ((x ‚àà U : Prop) ‚àß (U √óÀ¢ U ‚äÜ s : Prop) : Prop)","name":"exists_nhds_square","isProp":true,"docString":"Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood\nthat is a subset of `s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} (self : Filter.IsCountableBasis p s),\n  Set.Countable (setOf p)","name":"Filter.IsCountableBasis.countable","isProp":true,"docString":"The set of `i` that satisfy the predicate `p` is countable. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"LinearOrderedCommGroupWithZero.mul_inv_cancel","isProp":true,"docString":"Every nonzero element of a group with zero is invertible. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : NoZeroSMulDivisors K V] [inst_4 : StrongRankCondition K] (v : V) (n : v ‚â† 0)\n  (h : ‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w), FiniteDimensional.finrank K V = 1","name":"finrank_eq_one","isProp":true,"docString":"If there is a nonzero vector and every other vector is a multiple of it,\nthen the module has dimension one. "},{"type":"‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]\n  {c : ComplexShape Œπ} (C : HomologicalComplex V c) {i : Œπ} {i' : Œπ} {j : Œπ} (rij : ComplexShape.Rel c i j)\n  (rij' : ComplexShape.Rel c i' j),\n  CategoryTheory.eqToHom\n        ((congr_arg (HomologicalComplex.X C)\n              ((ComplexShape.prev_eq c rij\n                    rij'=:i =\n                    i')=:i =\n                  i')=:HomologicalComplex.X C i =\n              HomologicalComplex.X C i')=:HomologicalComplex.X C i = HomologicalComplex.X C i') ‚â´\n      HomologicalComplex.d C i' j =\n    HomologicalComplex.d C i j","name":"HomologicalComplex.eqToHom_comp_d","isProp":true,"docString":"If `C.d i j` and `C.d i' j` are both allowed, then we must have `i = i'`,\nand so the differentials only differ by an `eqToHom`.\n"},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±}\n  (h : (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) ‚â† 0), ‚àÉ (x : Œ±), (x ‚àà s : Prop) ‚àß (f x ‚â† 0 : Prop)","name":"exists_ne_zero_of_finsum_mem_ne_zero","isProp":true,"docString":"If the product of `f i` over `i ‚àà s` is not equal to `0`, then there is some `x ‚àà s`\nsuch that `f x ‚â† 0`."},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : (a : X) ‚Üí Y}\n  (hf : Continuous f), Monotone f","name":"Continuous.specialization_monotone","isProp":true,"docString":"A continuous function is monotone with respect to the specialization preorders on the domain and\nthe codomain. "},{"type":"‚àÄ {n : ‚Ñï} {p : Fin n} {i : Fin (n + 1)} (h : i ‚â† ‚ÜëFin.castSucc p),\n  ‚Üë(Fin.succAbove (‚ÜëFin.castSucc p)) (Fin.predAbove p i) = i","name":"Fin.succAbove_predAbove","isProp":true,"docString":"Sending `Fin (n+1)` to `Fin n` by subtracting one from anything above `p`\nthen back to `Fin (n+1)` with a gap around `p` is the identity away from `p`. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí SeminormedGroup (œÄ i)]\n  (f : (i : Œπ) ‚Üí œÄ i), (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ ‚Äñf i‚Äñ‚Çä) ‚â§ Fintype.card Œπ ‚Ä¢ ‚Äñf‚Äñ‚Çä","name":"Pi.sum_nnnorm_apply_le_nnnorm'","isProp":true,"docString":"The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Semiring Œ±] [inst_1 : Semiring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsSemiringHom f),\n  f 1 = 1","name":"IsSemiringHom.map_one","isProp":true,"docString":"The proposition that `f` preserves the multiplicative identity. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] (S : AddSubmonoid M), addLocalization.add S = Add.add","name":"addLocalization.add_def","isProp":true,"docString":"Addition in an `addLocalization` is defined as `‚ü®a, b‚ü© + ‚ü®c, d‚ü© = ‚ü®a + c, b + d‚ü©`.\nShould not be confused with the ring localization counterpart `Localization.add`, which maps\n`‚ü®a, b‚ü© + ‚ü®c, d‚ü©` to `‚ü®d * a + b * c, b * d‚ü©`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_6} {Œ≥ : Type u_5} {Œ≥' : Type u_7} {Œ¥ : Type u_3} {Œµ : Type u_1}\n  {f : Filter Œ±} {g : Filter Œ≤} {h : Filter Œ≥} {m : (a : Œ±) ‚Üí (a : Œ¥) ‚Üí Œµ} {n : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Œ¥}\n  {m‚ÇÅ : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≤'} {m‚ÇÇ : (a : Œ±) ‚Üí (a : Œ≥) ‚Üí Œ≥'} {n' : (a : Œ≤') ‚Üí (a : Œ≥') ‚Üí Œµ}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), m a (n b c) = n' (m‚ÇÅ a b) (m‚ÇÇ a c)),\n  Filter.map‚ÇÇ m f (Filter.map‚ÇÇ n g h) ‚â§ Filter.map‚ÇÇ n' (Filter.map‚ÇÇ m‚ÇÅ f g) (Filter.map‚ÇÇ m‚ÇÇ f h)","name":"Filter.map‚ÇÇ_distrib_le_left","isProp":true,"docString":"The other direction does not hold because of the `f`-`f` cross terms on the RHS. "},{"type":"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (a : Œ±) (l : List Œ±), List.length (List.leftpad n a l) = max n (List.length l)","name":"List.leftpad_length","isProp":true,"docString":"The length of the List returned by `List.leftpad n a l` is equal\nto the larger of `n` and `l.length` "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ≤] [inst_5 : One Œ±] {f : (a : Œ≤) ‚Üí Œ±}\n  (hf : Continuous f) (h : HasCompactMulSupport f), ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f y ‚â§ f x","name":"Continuous.exists_forall_ge_of_hasCompactMulSupport","isProp":true,"docString":"A continuous function with compact support has a global maximum. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] {s : Set Œ±} [hs : Set.OrdConnected s] ‚¶Ét : Set ‚Üës‚¶Ñ\n  (ht : Set.Nonempty t) (h_bdd : BddAbove t), sup‚Çõ (Subtype.val '' t) ‚àà s","name":"sup‚Çõ_within_of_ordConnected","isProp":true,"docString":"The `sup‚Çõ` function on a nonempty `OrdConnected` set `s` in a conditionally complete linear\norder takes values within `s`, for all nonempty bounded-above subsets of `s`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i)","name":"AntivaryOn.sum_mul_le_sum_mul_comp_perm","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and\n`g` antivary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] {p : (a : M) ‚Üí Prop} (x : M) {s : Set M} (hs : Submonoid.closure s = ‚ä§)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s), p x) (H1 : p 1) (Hmul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x * y)), p x","name":"Submonoid.dense_induction","isProp":true,"docString":"If `s` is a dense set in a monoid `M`, `Submonoid.closure s = ‚ä§`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ‚àà s`, verify `p 1`,\nand verify that `p x` and `p y` imply `p (x * y)`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (s : Set Œ≤)\n  (h : Embedding f), Embedding (Set.restrictPreimage s f)","name":"Embedding.restrictPreimage","isProp":true,"docString":"**Alias** of `Set.restrictPreimage_embedding`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±) (y : Œ±), edist x y = ‚Üë(nndist x y)","name":"edist_nndist","isProp":true,"docString":"Express `edist` in terms of `nndist`"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : AntitoneOn f s), MonotoneOn (f ‚àò ‚ÜëOrderDual.ofDual) s","name":"AntitoneOn.dual_left","isProp":true,"docString":"**Alias** of the reverse direction of `monotoneOn_comp_ofDual_iff`."},{"type":"‚àÄ (Œ± : Type u) {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] (b : Œ≤) [inst_2 : Fintype Œ±]\n  [inst_3 : Fintype ‚Üë(AddAction.orbit Œ± b)] [inst_4 : Fintype { x : Œ± // x ‚àà AddAction.stabilizer Œ± b }],\n  Fintype.card ‚Üë(AddAction.orbit Œ± b) * Fintype.card { x : Œ± // x ‚àà AddAction.stabilizer Œ± b } = Fintype.card Œ±","name":"AddAction.card_orbit_add_card_stabilizer_eq_card_addGroup","isProp":true,"docString":"Orbit-stabilizer theorem."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b),\n  (¬¨(a ‚©ø b : Prop) : Prop) ‚Üî (‚àÉ (c : Œ±), (a < c : Prop) ‚àß (c < b : Prop) : Prop)","name":"not_wcovby_iff","isProp":true,"docString":"If `a ‚â§ b`, then `b` does not cover `a` iff there's an element in between. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : UniqueFactorizationMonoid Œ±] {P : (a : Œ±) ‚Üí Prop}\n  (s : Finset Œ±) (i : (a : Œ±) ‚Üí ‚Ñï) (is_prime : ‚àÄ (p : Œ±) (a : p ‚àà s), Prime p)\n  (is_coprime : ‚àÄ (p : Œ±) (x : p ‚àà s) (q : Œ±) (x : q ‚àà s) (a : p ‚à£ q), p = q) (h1 : ‚àÄ {x : Œ±} (a : IsUnit x), P x)\n  (hpr : ‚àÄ {p : Œ±} (i : ‚Ñï) (a : Prime p), P (p ^ i))\n  (hcp : ‚àÄ {x : Œ±} {y : Œ±} (a : ‚àÄ (p : Œ±) (a : p ‚à£ x) (a : p ‚à£ y), IsUnit p) (a : P x) (a : P y), P (x * y)),\n  P (Finset.prod s fun (p : Œ±) ‚Ü¶ p ^ i p)","name":"UniqueFactorizationMonoid.induction_on_prime_power","isProp":true,"docString":"If `P` holds for units and powers of primes,\nand `P x ‚àß P y` for coprime `x, y` implies `P (x * y)`,\nthen `P` holds on a product of powers of distinct primes. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (q : (i : Fin (n + 1)) ‚Üí Œ± i), Fin.cons (q 0) (Fin.tail q) = q","name":"Fin.cons_self_tail","isProp":true,"docString":"Concatenating the first element of a tuple with its tail gives back the original tuple "},{"type":"‚àÄ {M‚ÇÄ : Type u} [self : MulZeroOneClass M‚ÇÄ] (a : M‚ÇÄ), a * 0 = 0","name":"MulZeroOneClass.mul_zero","isProp":true,"docString":"Zero is a right absorbing element for multiplication "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : ConcaveOn ùïú s f) {x : E} {y : E} {z : E} (hx : x ‚àà s) (hy : y ‚àà s)\n  (hz : z ‚àà segment ùïú x y), min (f x) (f y) ‚â§ f z","name":"ConcaveOn.ge_on_segment","isProp":true,"docString":"A concave function on a segment is lower-bounded by the min of its endpoints. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsPreconnected J],\n  CategoryTheory.IsPreconnected J·µí·µñ","name":"CategoryTheory.isPreconnected_op","isProp":true,"docString":"If `J` is preconnected, then `J·µí·µñ` is preconnected as well. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : LowerTopology Œ±] (a : Œ±),\n  IsClosed (Set.Ici a)","name":"LowerTopology.isClosed_Ici","isProp":true,"docString":"Left-closed right-infinite intervals [a, ‚àû) are closed in the lower topology. "},{"type":"‚àÄ {Œ± : Type u} [inst : NormedField Œ±] {u : (a : ‚Ñï) ‚Üí Œ±}, (IsCauSeq norm u : Prop) ‚Üî (CauchySeq u : Prop)","name":"isCauSeq_iff_cauchySeq","isProp":true,"docString":"In a normed field, `CauSeq` coincides with the usual notion of Cauchy sequences. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero M] [inst_1 : AddCommMonoid N] [inst_2 : DecidableEq Œ±]\n  (f : Œ± ‚Üí‚ÇÄ M) (a : Œ±) (b : (a : Œ±) ‚Üí (a : M) ‚Üí N),\n  (Finsupp.sum f fun (x : Œ±) (v : M) ‚Ü¶ if (x = a : Prop) then b x v else 0) =\n    if (a ‚àà Finsupp.support f : Prop) then b a (‚Üëf a) else 0","name":"Finsupp.sum_ite_eq'","isProp":true,"docString":"A restatement of `sum_ite_eq` with the equality test reversed."},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] {s : AddSubgroup E} (x : { x : E // x ‚àà s }), ‚Äñx‚Äñ = ‚Äñ‚Üëx‚Äñ","name":"AddSubgroup.coe_norm","isProp":true,"docString":"If `x` is an element of a subgroup `s` of a seminormed group `E`, its\nnorm in `s` is equal to its norm in `E`."},{"type":"‚àÄ {n : Type u_1} {Œ± : Type v} [inst : DecidableEq n] [inst_1 : Zero Œ±] [inst_2 : One Œ±] (œÉ : n ‚âÉ n) (i : n) (j : n),\n  PEquiv.toMatrix (Equiv.toPEquiv œÉ) i j = OfNat.ofNat 1 (‚ÜëœÉ i) j","name":"PEquiv.equiv_toPEquiv_toMatrix","isProp":true,"docString":"We can also define permutation matrices by permuting the rows of the identity matrix. "},{"type":"‚àÄ {n : ‚Ñï} (self : Composition n), List.sum (Composition.blocks self) = n","name":"Composition.blocks_sum","isProp":true,"docString":"Proof that `blocks` sums to `n`"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D]\n  (self : CategoryTheory.LaxMonoidalFunctor C D) (X : C) (Y : C) (Z : C),\n  (CategoryTheory.LaxMonoidalFunctor.Œº self X Y ‚äó\n        ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.LaxMonoidalFunctor.toFunctor self)) Z)) ‚â´\n      CategoryTheory.LaxMonoidalFunctor.Œº self (X ‚äó Y) Z ‚â´\n        Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.LaxMonoidalFunctor.toFunctor self))\n          (CategoryTheory.Iso.hom (Œ±_ X Y Z)) =\n    CategoryTheory.Iso.hom\n        (Œ±_ (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.LaxMonoidalFunctor.toFunctor self)) X)\n          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.LaxMonoidalFunctor.toFunctor self)) Y)\n          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.LaxMonoidalFunctor.toFunctor self)) Z)) ‚â´\n      (ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.LaxMonoidalFunctor.toFunctor self)) X) ‚äó\n          CategoryTheory.LaxMonoidalFunctor.Œº self Y Z) ‚â´\n        CategoryTheory.LaxMonoidalFunctor.Œº self X (Y ‚äó Z)","name":"CategoryTheory.LaxMonoidalFunctor.associativity","isProp":true,"docString":"associativity of the tensorator "},{"type":"‚àÄ {a : Prop} {c : Prop} {b : Prop} {d : Prop} (h‚ÇÅ : (a : Prop) ‚Üî (c : Prop)) (h‚ÇÇ : (b : Prop) ‚Üî (d : Prop)),\n  ((a : Prop) ‚à® (b : Prop) : Prop) ‚Üî ((c : Prop) ‚à® (d : Prop) : Prop)","name":"Iff.or","isProp":true,"docString":"**Alias** of `or_congr`."},{"type":"‚àÄ {Œπ : Type u} {f : (a : Œπ) ‚Üí (a : Ordinal) ‚Üí Ordinal} (H : ‚àÄ (i : Œπ), Ordinal.IsNormal (f i)),\n  Ordinal.derivFamily f = Ordinal.enumOrd (Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Function.fixedPoints (f i))","name":"Ordinal.derivFamily_eq_enumOrd","isProp":true,"docString":"For a family of normal functions, `Ordinal.derivFamily` enumerates the common fixed points. "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedSemifield R] [inst_1 : FloorSemiring R] {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñ§} {r : R}\n  (hr : 0 < r), (‚Üëb ^ x ‚â§ r : Prop) ‚Üî (x ‚â§ Int.log b r : Prop)","name":"Int.zpow_le_iff_le_log","isProp":true,"docString":"`zpow b` and `Int.log b` (almost) form a Galois connection. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C), CategoryTheory.IsPullback 0 0 0 (ùüô X)","name":"CategoryTheory.IsPullback.zero_top","isProp":true,"docString":"The square with `0 : 0 ‚ü∂ 0` on the top and `ùüô X` on the bottom is a pullback square. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {m : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} {s : Set Œ≤} (a : MeasurableSet s),\n  MeasurableSet (Sum.inr '' s)","name":"MeasurableSet.inr_image","isProp":true,"docString":"**Alias** of the reverse direction of `measurableSet_inr_image`."},{"type":"‚àÄ (a : Cardinal), a < 2 ^ a","name":"Cardinal.cantor","isProp":true,"docString":"**Cantor's theorem** "},{"type":"‚àÄ {S : Type u_1} [inst : UnitalShelf S] (x : S) (y : S) (z : S),\n  Shelf.act (Shelf.act x y) z = Shelf.act x (Shelf.act y z)","name":"UnitalShelf.assoc","isProp":true,"docString":"The associativity of a unital shelf comes for free.\n"},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (h : M ‚âÉ+ N), IsAddHom ‚Üëh","name":"AddEquiv.isAddHom","isProp":true,"docString":"An additive isomorphism preserves addition (deprecated)."},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} {x : Œ±}, (List.Duplicate x l : Prop) ‚Üî (List.Sublist [x, x] l : Prop)","name":"List.duplicate_iff_sublist","isProp":true,"docString":"The contrapositive of `List.nodup_iff_sublist`. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±] (H : FreeAddGroup.Red L‚ÇÅ L‚ÇÇ),\n  FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ","name":"FreeGroup.freeAddGroup.red.reduce_eq","isProp":true,"docString":"**Alias** of `FreeAddGroup.reduce.eq_of_red`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {mŒ≤ : MeasurableSpace Œ≤} {m : MeasurableSpace Œ±} (t : (a : ‚Ñï) ‚Üí Set Œ≤)\n  (t_meas : ‚àÄ (n : ‚Ñï), MeasurableSet (t n)) (t_disj : Pairwise (Disjoint on t)) (g : (a : ‚Ñï) ‚Üí (a : Œ≤) ‚Üí Œ±)\n  (hg : ‚àÄ (n : ‚Ñï), Measurable (g n)),\n  ‚àÉ (f : (a : Œ≤) ‚Üí Œ±), (Measurable f : Prop) ‚àß (‚àÄ (n : ‚Ñï) (x : Œ≤) (a : x ‚àà t n), f x = g n x : Prop)","name":"exists_measurable_piecewise_nat","isProp":true,"docString":"Given countably many disjoint measurable sets `t n` and countably many measurable\nfunctions `g n`, one can construct a measurable function that coincides with `g n` on `t n`. "},{"type":"‚àÄ {Œ± : Sort u} {a : Œ±}, HEq a a","name":"HEq.rfl","isProp":true,"docString":"A version of `HEq.refl` with an implicit argument. "},{"type":"‚àÄ {G : Type w} [inst : Group G] {g : G} {P : (a : G) ‚Üí Prop} (h_one : P 1) (h_mul : ‚àÄ (a : G) (a_1 : P a), P (g * a))\n  (h_inv : ‚àÄ (a : G) (a_1 : P a), P (g‚Åª¬π * a)) (n : ‚Ñ§), P (g ^ n)","name":"zpow_induction_left","isProp":true,"docString":"To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `g‚Åª¬π` on the left. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_left`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : StrictConvexOn ùïú s f) {x : E} {y : E} {z : E} (hx : x ‚àà s) (hy : y ‚àà s)\n  (hxy : x ‚â† y) (hz : z ‚àà openSegment ùïú x y), f z < max (f x) (f y)","name":"StrictConvexOn.lt_on_openSegment","isProp":true,"docString":"A strictly convex function on an open segment is strictly upper-bounded by the max of its\nendpoints. "},{"type":"‚àÄ (R : Type u_1) [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {C : (a : Module.Ray R M) ‚Üí Prop} (h : ‚àÄ (v : M) (hv : v ‚â† 0), C (rayOfNeZero R v hv)) (x : Module.Ray R M), C x","name":"Module.Ray.ind","isProp":true,"docString":"An induction principle for `Module.Ray`, used as `induction x using Module.Ray.ind`. "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {G' : SimpleGraph V} (h : G ‚â§ G') {u : V} {v : V} {p : SimpleGraph.Walk G u v}\n  (a : SimpleGraph.Walk.IsPath (SimpleGraph.Walk.mapLe h p)), SimpleGraph.Walk.IsPath p","name":"SimpleGraph.Walk.IsPath.of_mapLe","isProp":true,"docString":"**Alias** of the forward direction of `SimpleGraph.Walk.mapLe_isPath`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} (self : CategoryTheory.Sieve X) {Y : C} {Z : C} {f : Y ‚ü∂ X}\n  (x : CategoryTheory.Sieve.arrows self f) (g : Z ‚ü∂ Y), CategoryTheory.Sieve.arrows self (g ‚â´ f)","name":"CategoryTheory.Sieve.downward_closed","isProp":true,"docString":"stability by precomposition "},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel (SimpleGraph.Adj G)] [inst_2 : Nonempty V]\n  (k : ‚Ñï) (h : ‚àÄ (v : V), k ‚â§ SimpleGraph.degree G v), k ‚â§ SimpleGraph.minDegree G","name":"SimpleGraph.le_minDegree_of_forall_le_degree","isProp":true,"docString":"In a nonempty graph, if `k` is at most the degree of every vertex, it is at most the minimum\ndegree. Note the assumption that the graph is nonempty is necessary as long as `G.minDegree` is\ndefined to be a natural. "},{"type":"‚àÄ {Œ± : Type u} (s : Set Œ±), IsOpen (setOf fun (u : Ultrafilter Œ±) ‚Ü¶ s ‚àà u)","name":"ultrafilter_isOpen_basic","isProp":true,"docString":"The basic open sets for the topology on ultrafilters are open. "},{"type":"‚àÄ (Œ± : Type u) [inst : Preorder Œ±] [inst_1 : Nonempty Œ±] [inst_2 : NoMinOrder Œ±] [inst_3 : NoMaxOrder Œ±],\n  ‚àÉ (f : (a : ‚Ñ§) ‚Üí Œ±), StrictAnti f","name":"Int.exists_strictAnti","isProp":true,"docString":"If `Œ±` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nantitone function `f : ‚Ñ§ ‚Üí Œ±`. "},{"type":"‚àÄ {Œπ : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] {f : (a : Œπ) ‚Üí E} (hf : Summable fun (i : Œπ) ‚Ü¶ ‚Äñf i‚Äñ),\n  ‚Äñtsum fun (i : Œπ) ‚Ü¶ f i‚Äñ ‚â§ tsum fun (i : Œπ) ‚Ü¶ ‚Äñf i‚Äñ","name":"norm_tsum_le_tsum_norm","isProp":true,"docString":"If `‚àë' i, ‚Äñf i‚Äñ` is summable, then `‚Äñ‚àë' i, f i‚Äñ ‚â§ (‚àë' i, ‚Äñf i‚Äñ)`. Note that we do not assume\nthat `‚àë' i, f i` is summable, and it might not be the case if `Œ±` is not a complete space. "},{"type":"‚àÄ (Œ± : Type u) [inst : OrderedCommGroup Œ±],\n  ContravariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1","name":"OrderedCommGroup.to_contravariantClass_right_le","isProp":true,"docString":"A choice-free shortcut instance. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {s : (a : Œπ) ‚Üí Set Œ±},\n  Filter.liminf s Filter.cofinite = setOf fun (x : Œ±) ‚Ü¶ Set.Finite (setOf fun (n : Œπ) ‚Ü¶ ¬¨(x ‚àà s n : Prop))","name":"Filter.cofinite.liminf_set_eq","isProp":true,"docString":"In other words, `liminf cofinite s` is the set of elements lying outside the family `s`\nfinitely often. "},{"type":"‚àÄ {Œ± : Type u}, TopologicalSpace.induced pure Ultrafilter.topologicalSpace = ‚ä•","name":"induced_topology_pure","isProp":true,"docString":"The map `pure : Œ± ‚Üí Ultrafilter Œ±` induces on `Œ±` the discrete topology. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} (P : C·µí·µñ ‚•§ Type w) {S : CategoryTheory.Sieve X}\n  {R : CategoryTheory.Presieve X} (h : CategoryTheory.Sieve.arrows S ‚â§ R)\n  (hS : CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.arrows S))\n  (trans :\n    ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (a : R f),\n      CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.pullback f S))),\n  CategoryTheory.Presieve.IsSheafFor P R","name":"CategoryTheory.Presieve.isSheafFor_subsieve_aux","isProp":true,"docString":"If a presieve `R` on `X` has a subsieve `S` such that:\n\n* `P` is a sheaf for `S`.\n* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,\n\nthen `P` is a sheaf for `R`.\n\nThis is closely related to [Elephant] C2.1.6(i).\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommSemigroup Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ExistsAddOfLE Œ±]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [inst_4 : Sub Œ±]\n  [inst : OrderedSub Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : c ‚â§ b) (h2 : a - c < b - c), a < b","name":"lt_of_tsub_lt_tsub_right_of_le","isProp":true,"docString":"See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order. "},{"type":"‚àÄ {V : Type u_1} {W : Type u_2} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W]\n  (self : NormedAddGroupHom V W), ‚àÉ (C : ‚Ñù), ‚àÄ (v : V), ‚ÄñNormedAddGroupHom.toFun self v‚Äñ ‚â§ C * ‚Äñv‚Äñ","name":"NormedAddGroupHom.bound'","isProp":true,"docString":"A `NormedAddGroupHom` is bounded. "},{"type":"‚àÄ {Œπ : Type u_1} {I : BoxIntegral.Box Œπ} {J : BoxIntegral.Box Œπ} {Js : BoxIntegral.Box Œπ} {s : Finset (Œπ √ó ‚Ñù)}\n  (H : ‚àÄ (i : Œπ), {(i, BoxIntegral.Box.lower J i), (i, BoxIntegral.Box.upper J i)} ‚äÜ s)\n  (HJs : Js ‚àà BoxIntegral.Prepartition.splitMany I s) (Hn : ¬¨(Disjoint ‚ÜëJ ‚ÜëJs : Prop)), Js ‚â§ J","name":"BoxIntegral.Prepartition.not_disjoint_imp_le_of_subset_of_mem_splitMany","isProp":true,"docString":"Let `s : Finset (Œπ √ó ‚Ñù)` be a set of hyperplanes `{x : Œπ ‚Üí ‚Ñù | x i = r}` in `Œπ ‚Üí ‚Ñù` encoded as\npairs `(i, r)`. Suppose that this set contains all faces of a box `J`. The hyperplanes of `s` split\na box `I` into subboxes. Let `Js` be one of them. If `J` and `Js` have nonempty intersection, then\n`Js` is a subbox of `J`.  "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {s : Set E},\n  ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) s =\n    Set.union·µ¢ fun (t : Finset E) ‚Ü¶\n      Set.union·µ¢ fun (hss : ‚Üët ‚äÜ s) ‚Ü¶\n        Set.union·µ¢ fun (hai : AffineIndependent ùïú Subtype.val) ‚Ü¶ ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üët","name":"convexHull_eq_union","isProp":true,"docString":"**Carath√©odory's convexity theorem** "},{"type":"‚àÄ {F : Type u_1} {G : Type u_2} {N : Type u_3} [inst : SubtractionMonoid G] [inst_1 : AddMonoid N]\n  [inst_2 : AddMonoidHomClass F G N] {x : G} (hx : IsAddUnit x) (f : F) (g : F) (h : ‚Üëf x = ‚Üëg x), ‚Üëf (-x) = ‚Üëg (-x)","name":"IsAddUnit.eq_on_neg","isProp":true,"docString":"If two homomorphisms from a subtraction monoid to an additive monoid are equal at an\nadditive unit `x`, then they are equal at `-x`."},{"type":"‚àÄ {Œπ : Type u_1} [hnontriv : Nontrivial Œπ] {G : Type u_3} [inst : Group G] {H : (a : Œπ) ‚Üí Type u_2}\n  [inst_1 : (i : Œπ) ‚Üí Group (H i)] (f : (i : Œπ) ‚Üí H i ‚Üí* G)\n  (hcard : (3 ‚â§ Cardinal.mk Œπ : Prop) ‚à® (‚àÉ (i : Œπ), 3 ‚â§ Cardinal.mk (H i) : Prop)) {Œ± : Type u_4}\n  [inst_2 : MulAction G Œ±] (X : (a : Œπ) ‚Üí Set Œ±) (hXnonempty : ‚àÄ (i : Œπ), Set.Nonempty (X i))\n  (hXdisj : Pairwise fun (i : Œπ) (j : Œπ) ‚Ü¶ Disjoint (X i) (X j))\n  (hpp : Pairwise fun (i : Œπ) (j : Œπ) ‚Ü¶ ‚àÄ (h : H i) (a : h ‚â† 1), ‚Üë(f i) h ‚Ä¢ X j ‚äÜ X i),\n  Function.Injective ‚Üë(‚ÜëFreeProduct.lift f)","name":"FreeProduct.lift_injective_of_ping_pong","isProp":true,"docString":"The Ping-Pong-Lemma.\n\nGiven a group action of `G` on `X` so that the `H i` acts in a specific way on disjoint subsets\n`X i` we can prove that `lift f` is injective, and thus the image of `lift f` is isomorphic to the\nfree product of the `H i`.\n\nOften the Ping-Pong-Lemma is stated with regard to subgroups `H i` that generate the whole group;\nwe generalize to arbitrary group homomorphisms `f i : H i ‚Üí* G` and do not require the group to be\ngenerated by the images.\n\nUsually the Ping-Pong-Lemma requires that one group `H i` has at least three elements. This\ncondition is only needed if `# Œπ = 2`, and we accept `3 ‚â§ # Œπ` as an alternative.\n"},{"type":"‚àÄ {R : Type u_2} {A : Type u_1} [inst : Semiring R] [inst_1 : Add A] {f : AddMonoidAlgebra R A}\n  {g : AddMonoidAlgebra R A} {a0 : A} {b0 : A}\n  (h :\n    ‚àÄ {a : A} {b : A} (a_1 : a ‚àà Finsupp.support f) (a_2 : b ‚àà Finsupp.support g)\n      (a_3 : (a ‚â† a0 : Prop) ‚à® (b ‚â† b0 : Prop)), a + b ‚â† a0 + b0),\n  ‚Üë(f * g) (a0 + b0) = ‚Üëf a0 * ‚Üëg b0","name":"AddMonoidAlgebra.mul_apply_add_eq_mul_of_forall_ne","isProp":true,"docString":"The coefficient of a monomial in a product `f * g` that can be reached in at most one way\nas a product of monomials in the supports of `f` and `g` is a product. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {a : Œ±} {b : Œ±} {u : Œ±} (hu : IsUnit u), (a * u ‚à£ b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"IsUnit.mul_right_dvd","isProp":true,"docString":"In a monoid, an element a divides an element b iff all associates of `a` divide `b`."},{"type":"‚àÄ (l : List ‚Ñï) (n : ‚Ñï), List.Sorted (fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x ‚â§ x_1) (Denumerable.raise l n)","name":"Denumerable.raise_sorted","isProp":true,"docString":"`raise l n` is an non-decreasing sequence. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : MulOneClass Œ±] [inst_1 : MulOneClass Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsMonoidHom f),\n  f 1 = 1","name":"IsMonoidHom.map_one","isProp":true,"docString":"The proposition that `f` preserves the multiplicative identity. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Finset Œ±} {k : ‚Ñï} (h : Finset.card s = k) {f : (a : Fin k) ‚Üí Œ±}\n  (hfs : ‚àÄ (x : Fin k), f x ‚àà s) (hmono : StrictMono f), f = ‚Üë(Finset.orderEmbOfFin s h)","name":"Finset.orderEmbOfFin_unique","isProp":true,"docString":"Any increasing map `f` from `Fin k` to a finset of cardinality `k` has to coincide with\nthe increasing bijection `orderEmbOfFin s h`. "},{"type":"‚àÄ (ùïú : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField ùïú] [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace ùïú E], Bornology.vonNBornology ùïú E = PseudoMetricSpace.toBornology","name":"NormedSpace.vonNBornology_eq","isProp":true,"docString":"In a normed space, the von Neumann bornology (`Bornology.vonNBornology`) is equal to the\nmetric bornology. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú) (i : Fin r ‚äï Unit),\n  Matrix.mul (List.prod (Matrix.Pivot.listTransvecCol M)) M (Sum.inr ()) i = M (Sum.inr ()) i","name":"Matrix.Pivot.listTransvecCol_mul_last_row","isProp":true,"docString":"Multiplying by all the matrices in `listTransvecCol M` does not change the last row. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [self : IsLocalization M S] (z : S),\n  ‚àÉ (x : R √ó { x : R // x ‚àà M }), z * ‚Üë(algebraMap R S) ‚Üë(Prod.snd x) = ‚Üë(algebraMap R S) (Prod.fst x)","name":"IsLocalization.surj'","isProp":true,"docString":"the `algebraMap` is surjective "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} (a : 0 < List.length l), l ‚â† []","name":"List.ne_nil_of_length_pos","isProp":true,"docString":"**Alias** of the forward direction of `List.length_pos`."},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : Nonempty J] {t : CategoryTheory.Limits.Cotrident f} {Z : C} {Z' : C} (q : Z ‚ü∂ Z')\n  (ht : CategoryTheory.Limits.IsColimit t) (k : CategoryTheory.Limits.Cocone.pt t ‚ü∂ Z),\n  ‚Üë(‚Üë(CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z') (k ‚â´ q)) =\n    ‚Üë(‚Üë(CategoryTheory.Limits.Cotrident.IsColimit.homIso ht Z) k) ‚â´ q","name":"CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural","isProp":true,"docString":"The bijection of `Cotrident.IsColimit.homIso` is natural in `Z`. "},{"type":"‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : AddCommGroup N] [inst_5 : Module R N] (f : M ‚Üí‚Çó[R] N) (p : Submodule R M)\n  [inst_6 : Module.Finite R { x : M // x ‚àà p }],\n  FiniteDimensional.finrank R { x : N // x ‚àà Submodule.map f p } ‚â§ FiniteDimensional.finrank R { x : M // x ‚àà p }","name":"Submodule.finrank_map_le","isProp":true,"docString":"Pushforwards of finite submodules have a smaller finrank. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : NonAssocRing Œ±] (x : TopologicalSemiring Œ±), TopologicalRing Œ±","name":"TopologicalSemiring.toTopologicalRing","isProp":true,"docString":"If `R` is a ring which is a topological semiring, then it is automatically a topological\nring. This exists so that one can place a topological ring structure on `R` without explicitly\nproving `continuous_neg`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} {t : Set X} (ts : t ‚äÜ s),\n  instTopologicalSpaceSubtype = TopologicalSpace.induced (Set.inclusion ts) instTopologicalSpaceSubtype","name":"TopologicalSpace.subset_trans","isProp":true,"docString":"Let `X` be a topological space and let `s, t ‚äÜ X` be two subsets.  If there is an inclusion\n`t ‚äÜ s`, then the topological space structure on `t` induced by `X` is the same as the one\nobtained by the induced topological space structure on `s`. Use `embedding_inclusion` instead. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C] [hC : CategoryTheory.Pretriangulated C]\n  (T : CategoryTheory.Pretriangulated.Triangle C) (H : T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles),\n  CategoryTheory.Pretriangulated.Triangle.mor‚ÇÅ T ‚â´ CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T = 0","name":"CategoryTheory.Pretriangulated.comp_dist_triangle_mor_zero‚ÇÅ‚ÇÇ","isProp":true,"docString":"Given any distinguished triangle\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\nthe composition `f ‚â´ g = 0`.\nSee <https://stacks.math.columbia.edu/tag/0146>\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : Preorder Œ≤] {a : Œ±} {f : (a : Œ±) ‚Üí Œ≤}\n  (h‚ÇÅ : MonotoneOn f (Set.Iic a)) (h‚ÇÇ : MonotoneOn f (Set.Ici a)), Monotone f","name":"MonotoneOn.Iic_union_Ici","isProp":true,"docString":"If `f` is monotone both on `(-‚àû, a]` and `[a, ‚àû)`, then it is monotone on the whole line. "},{"type":"‚àÄ {Œ± : Sort u_2} [inst : DecidableEq Œ±] {Œ≤ : Sort u_1} {v : (a : Œ±) ‚Üí Œ≤} {i : Œ±} {j : Œ±} (hv : v i = v j) (k : Œ±),\n  v (‚Üë(Equiv.swap i j) k) = v k","name":"Equiv.apply_swap_eq_self","isProp":true,"docString":"A function is invariant to a swap if it is equal at both elements "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {R : C} {X : C} {Y : C} {Z : C} {a : R ‚ü∂ X} {b : R ‚ü∂ X} {f‚ÇÅ : X ‚ü∂ Y}\n  {f‚ÇÇ : Y ‚ü∂ Z} (comm : a ‚â´ f‚ÇÅ = b ‚â´ f‚ÇÅ) (big_k : CategoryTheory.IsKernelPair (f‚ÇÅ ‚â´ f‚ÇÇ) a b),\n  CategoryTheory.IsKernelPair f‚ÇÅ a b","name":"CategoryTheory.IsKernelPair.cancel_right","isProp":true,"docString":"If `(a,b)` is a kernel pair for `f‚ÇÅ ‚â´ f‚ÇÇ` and `a ‚â´ f‚ÇÅ = b ‚â´ f‚ÇÅ`, then `(a,b)` is a kernel pair for\njust `f‚ÇÅ`.\nThat is, to show that `(a,b)` is a kernel pair for `f‚ÇÅ` it suffices to only show the square\ncommutes, rather than to additionally show it's a pullback.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (hf : ContinuousOn f s) (hs : TopologicalSpace.IsSeparable s), TopologicalSpace.IsSeparable (f '' s)","name":"ContinuousOn.isSeparable_image","isProp":true,"docString":"If a map is continuous on a separable set `s`, then the image of `s` is also separable. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] (f : E ‚Üí‚Çó.[R] F) {x : E} {x' : F} (h : (x, x') ‚àà LinearPMap.graph f)\n  (hx : x = 0), x' = 0","name":"LinearPMap.graph_fst_eq_zero_snd","isProp":true,"docString":"The property that `f 0 = 0` in terms of the graph. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {x : M}, AddMonoid.Closure {x} = multiples x","name":"AddMonoid.closure_singleton","isProp":true,"docString":"The `AddSubmonoid` generated by an element of an `AddMonoid` equals the set of\nnatural number multiples of the element."},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [inst : IsIrrefl Œ± r] {a : Œ±} (hacc : Acc r a),\n  Acc (Relation.CutExpand r) {a}","name":"Acc.cutExpand","isProp":true,"docString":"A singleton `{a}` is accessible under `CutExpand r` if `a` is accessible under `r`,\nassuming `r` is irreflexive. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  (‚àÄ (a : Set (Submodule R M)) (a_1 : Set.Nonempty a),\n        ‚àÉ (M' : Submodule R M), (M' ‚àà a : Prop) ‚àß (‚àÄ (I : Submodule R M) (a : I ‚àà a), ¬¨(M' < I : Prop) : Prop) :\n      Prop) ‚Üî\n    (IsNoetherian R M : Prop)","name":"set_has_maximal_iff_noetherian","isProp":true,"docString":"A module is Noetherian iff every nonempty set of submodules has a maximal submodule among them.\n"},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : OrderedRing ùïú] [inst_1 : TopologicalSpace E]\n  [inst_2 : TopologicalSpace F] [inst_3 : AddCommGroup E] [inst_4 : AddCommGroup F] [inst_5 : Module ùïú E]\n  [inst_6 : Module ùïú F] {s : Set E} (hs : StrictConvex ùïú s) {f : E ‚Üí·µÉ[ùïú] F} (hf : IsOpenMap ‚Üëf),\n  StrictConvex ùïú (‚Üëf '' s)","name":"StrictConvex.affine_image","isProp":true,"docString":"The image of a strictly convex set under an affine map is strictly convex. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : CategoryTheory.Presieve X}\n  (a : CategoryTheory.Presieve.IsSheafFor P R), CategoryTheory.Presieve.IsSeparatedFor P R","name":"CategoryTheory.Presieve.IsSheafFor.isSeparatedFor","isProp":true,"docString":"If `P` is a sheaf for `R`, it is separated for `R`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Metric.hausdorffDist s ‚àÖ = 0","name":"Metric.hausdorffDist_empty","isProp":true,"docString":"The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue ‚àû instead, use `EMetric.hausdorffEdist`, which takes values in ‚Ñù‚â•0‚àû) "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {a : Œ±} {s : Set Œ±}\n  (h : ‚àÄ (a_1 : ¬¨(a ‚àà s : Prop)), f a = 0),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà insert a s) ‚Ü¶ f i) = finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i","name":"finsum_mem_insert_of_eq_zero_if_not_mem","isProp":true,"docString":"If `f a = 0` when `a ‚àâ s`, then the sum of `f i` over `i ‚àà insert a s` equals the sum\nof `f i` over `i ‚àà s`."},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f : M ‚Üí‚Çô* N} {g : M ‚Üí‚Çô* N} (h : f = g) (x : M),\n  ‚Üëf x = ‚Üëg x","name":"MulHom.congr_fun","isProp":true,"docString":"Deprecated: use `FunLike.congr_fun` instead. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {l : List K} (a : ‚àÄ (x : K) (a : x ‚àà l), x ‚àà s), List.prod l ‚àà s","name":"Subfield.list_prod_mem","isProp":true,"docString":"Product of a list of elements in a subfield is in the subfield. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : Preorder Œ≤] {a : Œ±} {f : (a : Œ±) ‚Üí Œ≤}\n  (h‚ÇÅ : StrictMonoOn f (Set.Iic a)) (h‚ÇÇ : StrictMonoOn f (Set.Ici a)), StrictMono f","name":"StrictMonoOn.Iic_union_Ici","isProp":true,"docString":"If `f` is strictly monotone both on `(-‚àû, a]` and `[a, ‚àû)`, then it is strictly monotone on the\nwhole line. "},{"type":"‚àÄ {G : Type u_1} [inst : CommGroup G] (K : Subgroup G) (g : Multiset G) (a : ‚àÄ (a : G) (a_1 : a ‚àà g), a ‚àà K),\n  Multiset.prod g ‚àà K","name":"Subgroup.multiset_prod_mem","isProp":true,"docString":"Product of a multiset of elements in a subgroup of a `CommGroup` is in the subgroup. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} {x : Œ±} {U : Set Œ±} (h_acc : AccPt x (Filter.principal C))\n  (hU : U ‚àà nhds x), AccPt x (Filter.principal (U ‚à© C))","name":"AccPt.nhds_inter","isProp":true,"docString":"If `x` is an accumulation point of a set `C` and `U` is a neighborhood of `x`,\nthen `x` is an accumulation point of `U ‚à© C`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : SeminormedAddCommGroup E] [inst_2 : NormedSpace ùïú E]\n  {r : ‚Ñù} {x : E} (hx : ‚Äñx‚Äñ < r), Absorbent ùïú (Metric.ball x r)","name":"absorbent_ball","isProp":true,"docString":"Balls containing the origin are absorbent. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} {y : Œ±} {t : Set Œ±} (xs : x ‚àà s) (yt : y ‚àà t),\n  Metric.diam (s ‚à™ t) ‚â§ Metric.diam s + dist x y + Metric.diam t","name":"Metric.diam_union","isProp":true,"docString":"The diameter of a union is controlled by the sum of the diameters, and the distance between\nany two points in each of the sets. This lemma is true without any side condition, since it is\nobviously true if `s ‚à™ t` is unbounded. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddMonoid M] (f : AddMonoidAlgebra R M),\n  f ‚àà Algebra.adjoin R (AddMonoidAlgebra.of' R M '' ‚Üë(Finsupp.support f))","name":"AddMonoidAlgebra.mem_adjoin_support","isProp":true,"docString":"An element of `AddMonoidAlgebra R M` is in the subalgebra generated by its support. "},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : UniformSpace Œ≤] (f : UniformFun Œ± Œ≤),\n  Filter.HasBasis (nhds f) (fun (V : Set (Œ≤ √ó Œ≤)) ‚Ü¶ V ‚àà uniformity Œ≤) fun (V : Set (Œ≤ √ó Œ≤)) ‚Ü¶\n    setOf fun (g : UniformFun Œ± Œ≤) ‚Ü¶ (f, g) ‚àà UniformFun.gen Œ± Œ≤ V","name":"UniformFun.hasBasis_nhds","isProp":true,"docString":"For `f : Œ± ‚Üí·µ§ Œ≤`, `ùìù f` admits the family `{g | ‚àÄ x, (f x, g x) ‚àà V}` for `V ‚àà ùì§ Œ≤` as a\nfilter basis. "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {Œ¥ : Type u_1} [inst_4 : LinearOrder Œ¥] [inst_5 : TopologicalSpace Œ¥]\n  [inst_6 : OrderClosedTopology Œ¥] {a : Œ±} {b : Œ±} {f : (a : Œ±) ‚Üí Œ¥} (hf : ContinuousOn f (Set.uIcc a b)),\n  Set.uIcc (f a) (f b) ‚äÜ f '' Set.uIcc a b","name":"intermediate_value_uIcc","isProp":true,"docString":"**Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. "},{"type":"‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} (h : Function.Semiconj f g g), Function.Commute f g","name":"Function.Semiconj.commute","isProp":true,"docString":"Reinterpret `Function.Semiconj f g g` as `Function.Commute f g`. These two predicates are\ndefinitionally equal but have different dot-notation lemmas. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {y : Œ±}, Metric.infDist x {y} = dist x y","name":"Metric.infDist_singleton","isProp":true,"docString":"The minimal distance to a singleton is the distance to the unique point in this singleton "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsOpen s : Prop) ‚Üî (‚àÄ (x : Œ±) (a : x ‚àà s), Filter.Eventually (fun (y : Œ±) ‚Ü¶ y ‚àà s) (nhds x) : Prop)","name":"isOpen_iff_eventually","isProp":true,"docString":"A set `s` is open iff for every point `x` in `s` and every `y` close to `x`, `y` is in `s`. "},{"type":"‚àÄ {Œ± : Sort u_2} {œÉ : (a : Œ±) ‚Üí Sort u_1} (P : Prop) [inst : Decidable (P : Prop)] (f : (a : Œ±) ‚Üí œÉ a)\n  (g : (a : Œ±) ‚Üí œÉ a) (a : Œ±), ite (P : Prop) f g a = if (P : Prop) then f a else g a","name":"ite_apply","isProp":true,"docString":"A 'ite' producing a `Pi` type `Œ† a, œÉ a`, applied to a value `a : Œ±` is a `ite` that applies\neither branch to `a`. "},{"type":"‚àÄ {p : ‚Ñï}, padicValInt p 1 = 0","name":"padicValInt.one","isProp":true,"docString":"`padicValInt p 1` is `0` for any `p`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : BiheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a","name":"BiheytingAlgebra.top_sdiff","isProp":true,"docString":"`‚ä§ \\ a` is `Ôø¢a` "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {f : (a : Œ±) ‚Üí Œ≤} [inst : Subsingleton Œ±] (hf : Function.Surjective f), Subsingleton Œ≤","name":"Function.Surjective.subsingleton","isProp":true,"docString":"If the domain of a surjective function is a subsingleton, then the codomain is a subsingleton as\nwell. "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] (self : AbstractCompletion Œ±), DenseRange (AbstractCompletion.coe self)","name":"AbstractCompletion.dense","isProp":true,"docString":"The map into the completion has dense range. "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} (cop : Nat.coprime m n) (hm : 1 < m) (hn : 1 < n), FrobeniusNumber (m * n - m - n) {m, n}","name":"frobeniusNumber_pair","isProp":true,"docString":"The **Chicken Mcnugget theorem** stating that the Frobenius number\nof positive numbers `m` and `n` is `m * n - m - n`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {a : Œ±} {b : Œ±} {u : Œ±À£}, (a ‚à£ b * ‚Üëu : Prop) ‚Üî (a ‚à£ b : Prop)","name":"Units.dvd_mul_right","isProp":true,"docString":"In a monoid, an element `a` divides an element `b` iff `a` divides all\nassociates of `b`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (f : C(Œ±, Œ≤)) {x : Œ±} {y : Œ±}\n  (h : x = y), ‚Üëf x = ‚Üëf y","name":"ContinuousMap.congr_arg","isProp":true,"docString":"Deprecated. Use `FunLike.congr_arg` instead. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ±} {b : Œ≤} (h : ‚àÄ (a : Œ±), f a b = a) (l : Filter Œ±),\n  Filter.map‚ÇÇ f l (pure b) = l","name":"Filter.map‚ÇÇ_right_identity","isProp":true,"docString":"If `b` is a right identity for `f : Œ± ‚Üí Œ≤ ‚Üí Œ±`, then `pure b` is a right identity for\n`Filter.map‚ÇÇ f`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Subsingleton Œ±] (s : Finset Œ±), Finset.card s ‚â§ 1","name":"Finset.card_le_one_of_subsingleton","isProp":true,"docString":"A `Finset` of a subsingleton type has cardinality at most one. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\n  [inst_2 : NonUnitalRingHomClass F R S] (f : F) (s : Set R),\n  NonUnitalSubsemiring.map f (NonUnitalSubsemiring.closure s) = NonUnitalSubsemiring.closure (‚Üëf '' s)","name":"NonUnitalRingHom.map_sclosure","isProp":true,"docString":"The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. "},{"type":"‚àÄ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a","name":"sq","isProp":true,"docString":"**Alias** of `pow_two`."},{"type":"‚àÄ {Œ± : Type u_2} {n : Type u_3} {m : Type u_1} {A : Matrix m m Œ±} {B : Matrix m n Œ±} {C : Matrix n m Œ±}\n  {D : Matrix n n Œ±} (hA : Matrix.IsSymm A) (hBC : Matrix.transpose B = C) (hD : Matrix.IsSymm D),\n  Matrix.IsSymm (Matrix.fromBlocks A B C D)","name":"Matrix.IsSymm.fromBlocks","isProp":true,"docString":"A block matrix `A.fromBlocks B C D` is symmetric,\nif `A` and `D` are symmetric and `B·µÄ = C`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {S : Set (Set Œ±)}\n  (hc : ‚àÄ (s : Set Œ±) (a : s ‚àà S), IsClosed s) (hS : Set.Countable S) (hU : ‚ãÉ‚ÇÄ S = Set.univ),\n  Dense (Set.union·µ¢ fun (s : Set Œ±) ‚Ü¶ Set.union·µ¢ fun (h : s ‚àà S) ‚Ü¶ interior s)","name":"dense_union‚Çõ_interior_of_closed","isProp":true,"docString":"Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `‚ãÉ‚ÇÄ`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {s : (a : Œπ) ‚Üí Set Œ±} (self : IndexedPartition s) {x : Œ±} {i : Œπ} {j : Œπ} (a : x ‚àà s i)\n  (a : x ‚àà s j), i = j","name":"IndexedPartition.eq_of_mem","isProp":true,"docString":"two indexes are equal if they are equal in membership  "},{"type":"‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : CommGroup Œ±] (a : Œ±) (h : 1 ‚â§ a), a‚Å∫ = a","name":"LatticeOrderedCommGroup.pos_of_one_le","isProp":true,"docString":"If `a` is positive, then it is equal to its positive component `a‚Å∫`. "},{"type":"‚àÄ (p : (a : ‚Ñï) ‚Üí Prop) [inst : DecidablePred p] (n : ‚Ñï),\n  Nat.count p n = Fintype.card { k : ‚Ñï // (k < n : Prop) ‚àß (p k : Prop) }","name":"Nat.count_eq_card_fintype","isProp":true,"docString":"`count p n` can be expressed as the cardinality of `{k // k < n ‚àß p k}`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : Setoid Œ±}, ¬¨(‚àÖ ‚àà Setoid.classes r : Prop)","name":"Setoid.empty_not_mem_classes","isProp":true,"docString":"The empty set is not an equivalence class. "},{"type":"‚àÄ {G : Type u_2} [inst : AddGroup G] {Œπ : Sort u_1} (S : (a : Œπ) ‚Üí AddSubgroup G)\n  {C : (x : G) ‚Üí (a : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) ‚Üí Prop}\n  (hp :\n    ‚àÄ (i : Œπ) (x : G) (hx : x ‚àà S i),\n      C x ((AddSubgroup.mem_sup·µ¢_of_mem i hx=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (h1 : C 0 ((zero_mem (sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:0 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:0 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (hmul :\n    ‚àÄ (x : G) (y : G) (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hy : y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (a : C x hx) (a : C y hy),\n      C (x + y) ((add_mem hx hy=:x + y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x + y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  {x : G} (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i), C x hx","name":"AddSubgroup.sup·µ¢_induction'","isProp":true,"docString":"A dependent version of `AddSubgroup.sup·µ¢_induction`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i)) < Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (¬¨(Monovary f (g ‚àò ‚ÜëœÉ) : Prop) : Prop)","name":"Monovary.sum_mul_comp_perm_lt_sum_mul_iff","isProp":true,"docString":"**Strict inequality case of Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : UniformSpace Œ≤] (ùîñ : Set (Set Œ±)) (f : UniformOnFun Œ± Œ≤ ùîñ) (h : Set.Nonempty ùîñ)\n  (h' : DirectedOn (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äÜ x_1) ùîñ),\n  Filter.HasBasis (nhds f)\n    (fun (SV : Set Œ± √ó Set (Œ≤ √ó Œ≤)) ‚Ü¶ (Prod.fst SV ‚àà ùîñ : Prop) ‚àß (Prod.snd SV ‚àà uniformity Œ≤ : Prop))\n    fun (SV : Set Œ± √ó Set (Œ≤ √ó Œ≤)) ‚Ü¶\n    setOf fun (g : UniformOnFun Œ± Œ≤ ùîñ) ‚Ü¶ (g, f) ‚àà UniformOnFun.gen ùîñ (Prod.fst SV) (Prod.snd SV)","name":"UniformOnFun.hasBasis_nhds","isProp":true,"docString":"For `f : Œ± ‚Üí·µ§[ùîñ] Œ≤`, where `ùîñ : Set (Set Œ±)` is nonempty and directed, `ùìù f` admits the\nfamily `{g | ‚àÄ x ‚àà S, (f x, g x) ‚àà V}` for `S ‚àà ùîñ` and `V ‚àà ùì§ Œ≤` as a filter basis. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {s : Set M} {S : Subsemigroup M}, (Subsemigroup.closure s ‚â§ S : Prop) ‚Üî (s ‚äÜ ‚ÜëS : Prop)","name":"Subsemigroup.closure_le","isProp":true,"docString":"A subsemigroup `S` includes `closure s` if and only if it includes `s`. "},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : (a : Œπ) ‚Üí Type u_1} [inst : Finite Œπ] [inst : DecidableEq Œπ]\n  [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ± i)] (r : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí (a : Finset (Œ± i)) ‚Üí Prop)\n  (H_ex :\n    ‚àÄ (i : Œπ) (s : Finset (Œ± i)) (x : Finset.Nonempty s),\n      ‚àÉ (x : Œ± i), (x ‚àà s : Prop) ‚àß (r i x (Finset.erase s x) : Prop))\n  {p : (a : (i : Œπ) ‚Üí Finset (Œ± i)) ‚Üí Prop} (f : (i : Œπ) ‚Üí Finset (Œ± i)) (h0 : p fun (x : Œπ) ‚Ü¶ ‚àÖ)\n  (step :\n    ‚àÄ (g : (i : Œπ) ‚Üí Finset (Œ± i)) (i : Œπ) (x : Œ± i) (a : r i x (g i)) (a : p g),\n      p (Function.update g i (insert x (g i)))),\n  p f","name":"Finset.induction_on_pi_of_choice","isProp":true,"docString":"General theorem for `Finset.induction_on_pi`-style induction principles. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {J : Type w}\n  [inst_2 : CategoryTheory.Category J] (F : C ‚•§ D) [inst_3 : CategoryTheory.Limits.HasColimitsOfShape J D]\n  [inst_4 : CategoryTheory.CreatesColimitsOfShape J F], CategoryTheory.Limits.HasColimitsOfShape J C","name":"CategoryTheory.hasColimitsOfShape_of_hasColimitsOfShape_createsColimitsOfShape","isProp":true,"docString":"If `F` creates colimits of shape `J`, and `D` has colimits of shape `J`, then\n`C` has colimits of shape `J`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] (g : AddGroupTopology Œ±), Continuous fun (p : Œ± √ó Œ±) ‚Ü¶ Prod.fst p + Prod.snd p","name":"AddGroupTopology.continuous_add'","isProp":true,"docString":"A version of the global `continuous_add` suitable for dot notation."},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {œÄ : (a : X) ‚Üí Y}\n  [inst_2 : TopologicalSpace.SecondCountableTopology X] (h' : QuotientMap œÄ) (h : IsOpenMap œÄ),\n  TopologicalSpace.SecondCountableTopology Y","name":"QuotientMap.secondCountableTopology","isProp":true,"docString":"A second countable space is mapped by an open quotient map to a second countable space. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] (x : M), IsSubmonoid (powers x)","name":"powers.isSubmonoid","isProp":true,"docString":"The set of natural number powers of an element of a monoid `M` is a submonoid of `M`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] (a : Œ±) (b : Œ±), Filter.comap Subtype.val (nhdsWithin a (Set.Ioi a)) = Filter.atBot","name":"comap_coe_Ioo_nhdsWithin_Ioi","isProp":true,"docString":"The `atBot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at\nthe left endpoint in the ambient order. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Type u_3} {N : Type u_2} {P : Type u_4} [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid N] [inst_3 : AddCommMonoid P] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : Module R P] {g : TensorProduct R M N ‚Üí‚Çó[R] P} {h : TensorProduct R M N ‚Üí‚Çó[R] P}\n  (H : LinearMap.compr‚ÇÇ (TensorProduct.mk R M N) g = LinearMap.compr‚ÇÇ (TensorProduct.mk R M N) h), g = h","name":"TensorProduct.ext","isProp":true,"docString":"This used to be an `@[ext]` lemma, but it fails very slowly when the `ext` tactic tries to apply\nit in some cases, notably when one wants to show equality of two linear maps. The `@[ext]`\nattribute is now added locally where it is needed. Using this as the `@[ext]` lemma instead of\n`TensorProduct.ext'` allows `ext` to apply lemmas specific to `M ‚Üí‚Çó _` and `N ‚Üí‚Çó _`.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} [inst : DecidableEq Œπ] [inst_1 : (i : Œπ) ‚Üí Zero (Œ± i)] {s : Finset Œπ}\n  {f : Dfinsupp fun (i : Œπ) ‚Ü¶ Œ± i} [inst_2 : (i : Œπ) ‚Üí DecidableEq (Œ± i)] {t : Dfinsupp fun (i : Œπ) ‚Ü¶ Finset (Œ± i)}\n  (ht : Dfinsupp.support t ‚äÜ s), (f ‚àà Finset.dfinsupp s ‚Üët : Prop) ‚Üî (‚àÄ (i : Œπ), ‚Üëf i ‚àà ‚Üët i : Prop)","name":"Finset.mem_dfinsupp_iff_of_support_subset","isProp":true,"docString":"When `t` is supported on `s`, `f ‚àà s.dfinsupp t` precisely means that `f` is pointwise in `t`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (x : Œ±) (C : Set Œ±),\n  (AccPt x (Filter.principal C) : Prop) ‚Üî\n    (‚àÄ (U : Set Œ±) (a : U ‚àà nhds x), ‚àÉ (y : Œ±), (y ‚àà U ‚à© C : Prop) ‚àß (y ‚â† x : Prop) : Prop)","name":"accPt_iff_nhds","isProp":true,"docString":"`x` is an accumulation point of a set `C` iff every neighborhood\nof `x` contains a point of `C` other than `x`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : GeneralizedCoheytingAlgebra Œ±] (a : Œ±) (b : Œ±) (c : Œ±), (a \\ b ‚â§ c : Prop) ‚Üî (a ‚â§ b ‚äî c : Prop)","name":"GeneralizedCoheytingAlgebra.sdiff_le_iff","isProp":true,"docString":"`\\ a` is right adjoint to `‚äî a` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : StrictMonoOn f s), StrictAntiOn (‚ÜëOrderDual.toDual ‚àò f) s","name":"StrictMonoOn.dual_right","isProp":true,"docString":"**Alias** of the reverse direction of `strictAntiOn_toDual_comp_iff`."},{"type":"‚àÄ {k : Type u_2} {A : Type u_1} [inst : AddMonoid A] [inst_1 : Semiring k] {s : Set A} {x : AddMonoidAlgebra k A},\n  (x ‚àà Ideal.span (AddMonoidAlgebra.of' k A '' s) : Prop) ‚Üî\n    (‚àÄ (m : A) (a : m ‚àà Finsupp.support x), ‚àÉ (m' : A), (m' ‚àà s : Prop) ‚àß (‚àÉ (d : A), m = d + m' : Prop) : Prop)","name":"AddMonoidAlgebra.mem_ideal_span_of'_image","isProp":true,"docString":"If `x` belongs to the ideal generated by generators in `s`, then every element of the support of\n`x` factors additively through an element of `s`.\n"},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (hs : Set.Nonempty s),\n  (Set.Countable s : Prop) ‚Üî (‚àÉ (f : (a : ‚Ñï) ‚Üí ‚Üës), Function.Surjective f : Prop)","name":"Set.countable_iff_exists_surjective","isProp":true,"docString":"A non-empty set is countable iff there exists a surjection from the\nnatural numbers onto the subtype induced by the set.\n"},{"type":"‚àÄ {Œ± : Type u_3} {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Monoid Œ±] [inst_4 : DistribMulAction Œ± M] [inst_5 : SMulCommClass Œ± R M] (a : Œ±), a ‚Ä¢ ‚ä• = ‚ä•","name":"Submodule.smul_bot'","isProp":true,"docString":"See also `Submodule.smul_bot`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] [inst_1 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚à£ x_1] {a : Œ±} {b : Œ±}\n  (a_1 : a ‚à£ b), 0 < multiplicity a b","name":"has_dvd.dvd.multiplicity_pos","isProp":true,"docString":"**Alias** of the reverse direction of `multiplicity.dvd_iff_multiplicity_pos`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y}\n  (self : CategoryTheory.Limits.MonoFactorisation f),\n  CategoryTheory.Mono (CategoryTheory.Limits.MonoFactorisation.m self)","name":"CategoryTheory.Limits.MonoFactorisation.m_mono","isProp":true,"docString":"A factorisation of a morphism `f = e ‚â´ m`, with `m` monic. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : (a : Œπ) ‚Üí Type w}\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] {N : Type u‚ÇÅ} [inst_3 : AddCommMonoid N]\n  [inst_4 : Module R N] ‚¶Éœà : (DirectSum Œπ fun (i : Œπ) ‚Ü¶ M i) ‚Üí‚Çó[R] N‚¶Ñ ‚¶Éœà' : (DirectSum Œπ fun (i : Œπ) ‚Ü¶ M i) ‚Üí‚Çó[R] N‚¶Ñ\n  (H : ‚àÄ (i : Œπ), LinearMap.comp œà (DirectSum.lof R Œπ M i) = LinearMap.comp œà' (DirectSum.lof R Œπ M i)), œà = œà'","name":"DirectSum.linearMap_ext","isProp":true,"docString":"Two `LinearMap`s out of a direct sum are equal if they agree on the generators.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)]\n  [inst_1 : ‚àÄ (i : Œπ), LocallyCompactSpace (œÄ i)] [inst_2 : ‚àÄ (i : Œπ), CompactSpace (œÄ i)],\n  LocallyCompactSpace ((i : Œπ) ‚Üí œÄ i)","name":"LocallyCompactSpace.pi","isProp":true,"docString":"For spaces that are not Hausdorff. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : EMetricSpace Œ≥] {x : Œ≥} {y : Œ≥}, (edist x y = 0 : Prop) ‚Üî (x = y : Prop)","name":"edist_eq_zero","isProp":true,"docString":"Characterize the equality of points by the vanishing of their extended distance "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : AddCommMonoid Œ≤] {s : Finset Œ≥} {t : (a : Œ≥) ‚Üí Finset Œ±}\n  {t' : Finset Œ±} {s' : (a : Œ±) ‚Üí Finset Œ≥}\n  (h : ‚àÄ (x : Œ≥) (y : Œ±), ((x ‚àà s : Prop) ‚àß (y ‚àà t x : Prop) : Prop) ‚Üî ((x ‚àà s' y : Prop) ‚àß (y ‚àà t' : Prop) : Prop))\n  {f : (a : Œ≥) ‚Üí (a : Œ±) ‚Üí Œ≤},\n  (Finset.sum s fun (x : Œ≥) ‚Ü¶ Finset.sum (t x) fun (y : Œ±) ‚Ü¶ f x y) =\n    Finset.sum t' fun (y : Œ±) ‚Ü¶ Finset.sum (s' y) fun (x : Œ≥) ‚Ü¶ f x y","name":"Finset.sum_comm'","isProp":true,"docString":"Generalization of `Finset.sum_comm` to the case when the inner `Finset`s depend on\nthe outer variable."},{"type":"‚àÄ {Œ± : Sort u_1} (x : Œ±) (h : ‚àÄ (y : Œ±), y = x), Subsingleton Œ±","name":"subsingleton_of_forall_eq","isProp":true,"docString":"If all points are equal to a given point `x`, then `Œ±` is a subsingleton. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteLinearOrder Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"CompleteLinearOrder.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : Module.rank K V < Cardinal.aleph0), Set.Finite (Basis.ofVectorSpaceIndex K V)","name":"Basis.finite_ofVectorSpaceIndex_of_rank_lt_aleph0","isProp":true,"docString":"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±}\n  {p : Filter Œπ} {p' : Filter Œ≤},\n  (TendstoUniformlyOnFilter F f p p' : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n        Filter.Eventually (fun (n : Œπ √ó Œ≤) ‚Ü¶ dist (f (Prod.snd n)) (F (Prod.fst n) (Prod.snd n)) < Œµ)\n          (Filter.prod p p') :\n      Prop)","name":"Metric.tendstoUniformlyOnFilter_iff","isProp":true,"docString":"Expressing uniform convergence using `dist` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {S : C ‚•§ D}\n  {T : D} {A : CategoryTheory.CostructuredArrow S T} {P : (CategoryTheory.CostructuredArrow S T)·µí·µñ}\n  {Q : (CategoryTheory.CostructuredArrow S T)·µí·µñ} {f : P ‚ü∂ Opposite.op A} {g : Q ‚ü∂ Opposite.op A}\n  [inst_2 : CategoryTheory.Mono (Quiver.Hom.op (CategoryTheory.CommaMorphism.left (Quiver.Hom.unop f)))]\n  [inst_3 : CategoryTheory.Mono (Quiver.Hom.op (CategoryTheory.CommaMorphism.left (Quiver.Hom.unop g)))]\n  (h :\n    CategoryTheory.Subobject.mk (Quiver.Hom.op (CategoryTheory.CommaMorphism.left (Quiver.Hom.unop f))) ‚â§\n      CategoryTheory.Subobject.mk (Quiver.Hom.op (CategoryTheory.CommaMorphism.left (Quiver.Hom.unop g)))),\n  CategoryTheory.CommaMorphism.left (Quiver.Hom.unop g) ‚â´\n      Quiver.Hom.unop\n        (CategoryTheory.Subobject.ofMkLEMk (Quiver.Hom.op (CategoryTheory.CommaMorphism.left (Quiver.Hom.unop f)))\n          (Quiver.Hom.op (CategoryTheory.CommaMorphism.left (Quiver.Hom.unop g))) h) =\n    CategoryTheory.CommaMorphism.left (Quiver.Hom.unop f)","name":"CategoryTheory.CostructuredArrow.unop_left_comp_ofMkLEMk_unop","isProp":true,"docString":"Technical lemma for `quotientEquiv`. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroClass M‚ÇÄ] [inst_1 : NoZeroDivisors M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ},\n  (a * b = 0 : Prop) ‚Üî (b * a = 0 : Prop)","name":"mul_eq_zero_comm","isProp":true,"docString":"If `Œ±` has no zero divisors, then for elements `a, b : Œ±`, `a * b` equals zero iff so is\n`b * a`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}\n  {c : CategoryTheory.Limits.PullbackCone f g} (h : CategoryTheory.Limits.IsLimit c),\n  CategoryTheory.IsPullback (CategoryTheory.Limits.PullbackCone.fst c) (CategoryTheory.Limits.PullbackCone.snd c) f g","name":"CategoryTheory.IsPullback.of_isLimit","isProp":true,"docString":"If `c` is a limiting pullback cone, then we have a `IsPullback c.fst c.snd f g`. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R ‚Üí+* S} {g : R ‚Üí+* S}\n  {s : Set R} (h : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subsemiring.closure s)","name":"RingHom.eqOn_sclosure","isProp":true,"docString":"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ±}\n  (Hf : AntitoneOn f t) (Hst : s ‚äÜ t) (a : Set.Nonempty (lowerBounds s ‚à© t)), BddAbove (f '' s)","name":"AntitoneOn.map_bddBelow","isProp":true,"docString":"The image under an antitone function of a set which is bounded below is bounded above. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} [inst : CompleteLattice Œ±] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±} (a : Finset.SupIndep s f),\n  CompleteLattice.Independent (f ‚àò Subtype.val)","name":"Finset.SupIndep.independent","isProp":true,"docString":"**Alias** of the reverse direction of `CompleteLattice.independent_iff_supIndep`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : CommMonoid M] [inst_1 : DecidableEq Œ±] [inst_2 : DecidableEq Œ≤]\n  (s : Finset (Œ± √ó Œ≤)) (f : (a : Œ± √ó Œ≤) ‚Üí M),\n  (finprod fun (ab : Œ± √ó Œ≤) ‚Ü¶ finprod fun (_h : ab ‚àà s) ‚Ü¶ f ab) =\n    finprod fun (a : Œ±) ‚Ü¶\n      finprod fun (b : Œ≤) ‚Ü¶\n        finprod fun (_h : b ‚àà Finset.image Prod.snd (Finset.filter (fun (ab : Œ± √ó Œ≤) ‚Ü¶ Prod.fst ab = a) s)) ‚Ü¶ f (a, b)","name":"finprod_mem_finset_product'","isProp":true,"docString":"Note that `b ‚àà (s.filter (fun ab => Prod.fst ab = a)).image Prod.snd` iff `(a, b) ‚àà s` so\nwe can simplify the right hand side of this lemma. However the form stated here is more useful for\niterating this lemma, e.g., if we have `f : Œ± √ó Œ≤ √ó Œ≥ ‚Üí M`. "},{"type":"‚àÄ (Œ± : Type u) (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsSymm Œ± r], IsSymmOp Œ± Prop r","name":"isSymmOp_of_isSymm","isProp":true,"docString":"The opposite of a symmetric relation is symmetric. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {s : Set Œ±} {t : Set Œ≤} (a : LocalHomeomorph.IsImage e s t),\n  LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à©\n      ‚Üë(LocalHomeomorph.symm e) ‚Åª¬π' (LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© s) =\n    LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à© t","name":"LocalHomeomorph.IsImage.symm_preimage_eq'","isProp":true,"docString":"**Alias** of the forward direction of `LocalHomeomorph.IsImage.iff_symm_preimage_eq'`."},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : AddMonoid A] [inst_1 : VAdd R A] [inst_2 : VAddCommClass R A A]\n  [inst_3 : TopologicalSpace A] [inst : ContinuousAdd A], ContinuousConstVAdd R A","name":"VAddCommClass.continuousConstVAdd","isProp":true,"docString":"If the action of `R` on `A` commutes with left-addition, then\ncontinuous addition implies continuous affine addition by constants.\n\nNotably, this instances applies when `R = A·µÉ·µí·µñ`."},{"type":"‚àÄ {R : Type u} [inst : Semiring R] (self : IsField R), ‚àÉ (x : R), ‚àÉ (y : R), x ‚â† y","name":"IsField.exists_pair_ne","isProp":true,"docString":"For a semiring to be a field, it must have two distinct elements. "},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {x : Œ±} {y : Œ±}, ((x < y : Prop) ‚à® (y < x : Prop) : Prop) ‚Üî (x ‚â† y : Prop)","name":"lt_or_lt_iff_ne","isProp":true,"docString":"A version of `ne_iff_lt_or_gt` with LHS and RHS reversed. "},{"type":"‚àÄ {Œ± : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformFun Œ± G)","name":"instUniformGroupUniformFunUniformSpaceInstGroupUniformFun","isProp":true,"docString":"If `G` is a uniform group, then `Œ± ‚Üí·µ§ G` is a uniform group as well. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R) (J : Ideal R), RingHom.ker (DoubleQuot.quotQuotMk I J) = I ‚äî J","name":"DoubleQuot.ker_quotQuotMk","isProp":true,"docString":"The kernel of `quotQuotMk` "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±} {b : Œ±} (h : a < b), a ‚â† ‚ä§","name":"LT.lt.ne_top","isProp":true,"docString":"**Alias** of `ne_top_of_lt`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFilteredOrEmpty C] {i : C} {j : C} {j' : C}\n  (f : i ‚ü∂ j) (f' : i ‚ü∂ j'), ‚àÉ (k : C), ‚àÉ (g : j ‚ü∂ k), ‚àÉ (g' : j' ‚ü∂ k), f ‚â´ g = f' ‚â´ g'","name":"CategoryTheory.IsFiltered.span","isProp":true,"docString":"For every span `j ‚üµ i ‚ü∂ j'`, there\nexists a cocone `j ‚ü∂ k ‚üµ j'` such that the square commutes. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±} {U : Set Œ±}\n  (hK : IsCompact K) (hU : IsOpen U) (hKU : K ‚äÜ U),\n  ‚àÉ (V : Set Œ±),\n    (IsOpen V : Prop) ‚àß ((K ‚äÜ V : Prop) ‚àß ((closure V ‚äÜ U : Prop) ‚àß (IsCompact (closure V) : Prop) : Prop) : Prop)","name":"exists_open_between_and_isCompact_closure","isProp":true,"docString":"In a locally compact T‚ÇÇ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K ‚äÜ V` and the closure of `V` is inside `U`.\n"},{"type":"‚àÄ {Œ≤ : Type v} {œÄ : (a : Œ≤) ‚Üí Type u_1} [inst : Fintype Œ≤] [inst_1 : (b : Œ≤) ‚Üí PseudoMetricSpace (œÄ b)]\n  [h : ‚àÄ (b : Œ≤), ProperSpace (œÄ b)], ProperSpace ((b : Œ≤) ‚Üí œÄ b)","name":"pi_properSpace","isProp":true,"docString":"A finite product of proper spaces is proper. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {f : M ‚âÉ+ N} {g : M ‚âÉ+ N} (h : ‚àÄ (x : M), ‚Üëf x = ‚Üëg x),\n  f = g","name":"AddEquiv.ext","isProp":true,"docString":"Two additive isomorphisms agree if they are defined by the same underlying function."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [self : IsModularLattice Œ±] {x : Œ±} (y : Œ±) {z : Œ±} (a : x ‚â§ z),\n  (x ‚äî y) ‚äì z ‚â§ x ‚äî y ‚äì z","name":"IsModularLattice.sup_inf_le_assoc_of_le","isProp":true,"docString":"Whenever `x ‚â§ z`, then for any `y`, `(x ‚äî y) ‚äì z ‚â§ x ‚äî (y ‚äì z)`  "},{"type":"‚àÄ {Œπ : Type u_3} {X : Type u_4} {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  [inst_2 : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} {x‚ÇÄ : X} {u : (a : Œ±) ‚Üí Œ≤} (hu : UniformInducing u),\n  (EquicontinuousAt F x‚ÇÄ : Prop) ‚Üî\n    (EquicontinuousAt ((fun (x : (a : Œ±) ‚Üí Œ≤) (x_1 : (a : X) ‚Üí Œ±) ‚Ü¶ x ‚àò x_1) u ‚àò F) x‚ÇÄ : Prop)","name":"UniformInducing.equicontinuousAt_iff","isProp":true,"docString":"Given `u : Œ± ‚Üí Œ≤` a uniform inducing map, a family `ùìï : Œπ ‚Üí X ‚Üí Œ±` is equicontinuous at a point\n`x‚ÇÄ : X` iff the family `ùìï'`, obtained by precomposing each function of `ùìï` by `u`, is\nequicontinuous at `x‚ÇÄ`. "},{"type":"‚àÄ {Œº : YoungDiagram} (self : Ssyt Œº) {i1 : ‚Ñï} {i2 : ‚Ñï} {j : ‚Ñï} (a : i1 < i2) (a : (i2, j) ‚àà Œº),\n  Ssyt.entry self i1 j < Ssyt.entry self i2 j","name":"Ssyt.col_strict'","isProp":true,"docString":"The entries in each column are strictly increasing (top to bottom). "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), (S = ‚ä• : Prop) ‚à® (Nontrivial { x : M // x ‚àà S } : Prop)","name":"Submonoid.bot_or_nontrivial","isProp":true,"docString":"A submonoid is either the trivial submonoid or nontrivial. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ‚ÜëK = K","name":"Subgroup.closure_eq","isProp":true,"docString":"Closure of a subgroup `K` equals `K`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hf : StrictMono f) (hx : f x < x),\n  StrictAnti fun (n : ‚Ñï) ‚Ü¶ (f^[n]) x","name":"StrictMono.strictAnti_iterate_of_map_lt","isProp":true,"docString":"If `f` is a strictly antitone map and `f x < x` at some point `x`, then the iterates `f^[n] x`\nform a strictly antitone sequence. "},{"type":"‚àÄ {Œ± : Type u} [inst : StrictOrderedRing Œ±] {a : Œ±} {b : Œ±} (hb : b < 0) (h : a < 1), b < a * b","name":"lt_mul_of_lt_one_left","isProp":true,"docString":"Variant of `mul_lt_of_lt_one_left` for `b` negative instead of positive. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type v} [inst : MetricSpace Œ±] [inst_1 : ProperSpace Œ±] {c : (a : Œπ) ‚Üí Œ±} {s : Set Œ±}\n  {r : (a : Œπ) ‚Üí ‚Ñù} (hs : IsClosed s)\n  (uf : ‚àÄ (x : Œ±) (a : x ‚àà s), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ x ‚àà Metric.ball (c i) (r i)))\n  (us : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r i)),\n  ‚àÉ (r' : (a : Œπ) ‚Üí ‚Ñù), (s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r' i) : Prop) ‚àß (‚àÄ (i : Œπ), r' i < r i : Prop)","name":"exists_subset_union·µ¢_ball_radius_lt","isProp":true,"docString":"Shrinking lemma for coverings by open balls in a proper metric space. A point-finite open cover\nof a closed subset of a proper metric space by open balls can be shrunk to a new cover by open balls\nso that each of the new balls has strictly smaller radius than the old one. This version assumes\nthat `Œª x, ball (c i) (r i)` is a locally finite covering and provides a covering indexed by the\nsame type. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} [inst : CommMonoid Œ≤] {f : (a : Œ±) ‚Üí Prop} [inst_1 : DecidablePred f]\n  (hf : Set.PairwiseDisjoint (‚Üës) f) (a : Œ≤),\n  (Finset.prod s fun (i : Œ±) ‚Ü¶ if (f i : Prop) then a else 1) =\n    if (‚àÉ (i : Œ±), (i ‚àà s : Prop) ‚àß (f i : Prop) : Prop) then a else 1","name":"Finset.prod_ite_one","isProp":true,"docString":"See also `Finset.prod_boole`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Setoid Œ±] {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n  {H : ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ±) (a : a‚ÇÅ ‚âà a‚ÇÇ) (a : b‚ÇÅ ‚âà b‚ÇÇ), (r a‚ÇÅ b‚ÇÅ : Prop) = (r a‚ÇÇ b‚ÇÇ : Prop)}\n  (a : WellFounded r), WellFounded (Quotient.lift‚ÇÇ r H)","name":"WellFounded.quotient_lift‚ÇÇ","isProp":true,"docString":"**Alias** of the reverse direction of `wellFounded_lift‚ÇÇ_iff`."},{"type":"‚àÄ {Œ≤ : Type v} {Œ≥ : Type w} [inst : MetricSpace Œ≥] [inst_1 : MetricSpace Œ≤] {f : (a : Œ≥) ‚Üí Œ≤},\n  (UniformEmbedding f : Prop) ‚Üî\n    ((‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n            ‚àÉ (Œ¥ : ‚Ñù), (Œ¥ > 0 : Prop) ‚àß (‚àÄ {a : Œ≥} {b : Œ≥} (a_1 : dist a b < Œ¥), dist (f a) (f b) < Œµ : Prop) :\n          Prop) ‚àß\n        (‚àÄ (Œ¥ : ‚Ñù) (a : Œ¥ > 0),\n            ‚àÉ (Œµ : ‚Ñù), (Œµ > 0 : Prop) ‚àß (‚àÄ {a : Œ≥} {b : Œ≥} (a_1 : dist (f a) (f b) < Œµ), dist a b < Œ¥ : Prop) :\n          Prop) :\n      Prop)","name":"Metric.uniformEmbedding_iff'","isProp":true,"docString":"A map between metric spaces is a uniform embedding if and only if the distance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. "},{"type":"‚àÄ {Œπ : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] {f : (a : Œπ) ‚Üí E}\n  (hf : Summable fun (i : Œπ) ‚Ü¶ ‚Äñf i‚Äñ‚Çä), ‚Äñtsum fun (i : Œπ) ‚Ü¶ f i‚Äñ‚Çä ‚â§ tsum fun (i : Œπ) ‚Ü¶ ‚Äñf i‚Äñ‚Çä","name":"nnnorm_tsum_le","isProp":true,"docString":"If `‚àë' i, ‚Äñf i‚Äñ‚Çä` is summable, then `‚Äñ‚àë' i, f i‚Äñ‚Çä ‚â§ ‚àë' i, ‚Äñf i‚Äñ‚Çä`. Note that\nwe do not assume that `‚àë' i, f i` is summable, and it might not be the case if `Œ±` is not a complete\nspace. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A / C) * Finset.card B ‚â§ Finset.card (A * B) * Finset.card (B / C)","name":"Finset.card_div_mul_le_card_mul_mul_card_div","isProp":true,"docString":"**Ruzsa's triangle inequality**. Sub-add-sub version. "},{"type":"‚àÄ {X : Type u} [inst : PseudoMetricSpace X] {Œ¥ : ‚Ñù} {E : Set X},\n  Metric.thickening Œ¥ E = Set.union·µ¢ fun (x : X) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà E) ‚Ü¶ Metric.ball x Œ¥","name":"Metric.thickening_eq_bunion·µ¢_ball","isProp":true,"docString":"The (open) `Œ¥`-thickening `Metric.thickening Œ¥ E` of a subset `E` in a metric space equals the\nunion of balls of radius `Œ¥` centered at points of `E`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}\n  (h :\n    ‚àÄ {Œπ : Type u} (U : (a : Œπ) ‚Üí Set Œ±) (a : ‚àÄ (i : Œπ), IsOpen (U i)) (a : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ U i),\n      ‚àÉ (t : Finset Œπ), s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà t) ‚Ü¶ U i),\n  IsCompact s","name":"isCompact_of_finite_subcover","isProp":true,"docString":"A set `s` is compact if for every open cover of `s`, there exists a finite subcover. "},{"type":"‚àÄ {a : ENNReal} (h : a ‚â† ‚ä§), AddLECancellable a","name":"ENNReal.cancel_of_ne","isProp":true,"docString":"This lemma has an abbreviated name because it is used frequently. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s : Set P} (h : affineSpan k s = ‚ä§), vectorSpan k s = ‚ä§","name":"AffineSubspace.vectorSpan_eq_top_of_affineSpan_eq_top","isProp":true,"docString":"If the affine span of a set is `‚ä§`, then the vector span of the same set is the `‚ä§`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.IsIso f],\n  CategoryTheory.IsSplitEpi f","name":"CategoryTheory.IsSplitEpi.of_iso","isProp":true,"docString":"Every iso is a split epi. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : 0 < a) (hb : 0 < b), 0 < a + b","name":"Right.add_pos'","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos'`."},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {C : Type u_2} {D : Type u_3} [inst_1 : CategoryTheory.Category C]\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.Preadditive C] [inst_4 : CategoryTheory.Preadditive D]\n  [inst_5 : CategoryTheory.Linear R C] [inst_6 : CategoryTheory.Linear R D] {F : C ‚•§ D}\n  [inst_7 : CategoryTheory.Functor.Additive F] [self : CategoryTheory.Functor.Linear R F] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (r : R),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (r ‚Ä¢ f) =\n    r ‚Ä¢ Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f","name":"CategoryTheory.Functor.Linear.map_smul","isProp":true,"docString":"the functor induces a linear map on morphisms "},{"type":"‚àÄ {R : Type u_1} [inst : Mul R] [inst_1 : Star R] {x : R} [self : IsStarNormal x], Commute (star x) x","name":"IsStarNormal.star_comm_self","isProp":true,"docString":"A normal element of a star monoid commutes with its adjoint. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf' : DenseRange f) (hf : Continuous f) {s : Set Œ±} (hs : Dense s) {t : Set Œ≤} (ht : Set.MapsTo f s t), Dense t","name":"DenseRange.dense_of_mapsTo","isProp":true,"docString":"If a continuous map with dense range maps a dense set to a subset of `t`, then `t` is a dense\nset. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : a ‚â§ 1) (hb : b < 1), a * b < 1","name":"Right.mul_lt_one_of_le_of_lt","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_le_of_lt`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : PartialOrder Œ±] [inst_3 : ZeroLEOneClass Œ±]\n  [inst_4 : NeZero 1], 0 < 1","name":"zero_lt_one'","isProp":true,"docString":"See `zero_lt_one` for a version with the type implicit. "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] {s : Set Œ±} {c : Set (Set Œ±)} (hs : IsCompact s)\n  (hc‚ÇÅ : ‚àÄ (t : Set Œ±) (a : t ‚àà c), IsOpen t) (hc‚ÇÇ : s ‚äÜ ‚ãÉ‚ÇÄ c),\n  ‚àÉ (n : Set (Œ± √ó Œ±)),\n    (n ‚àà uniformity Œ± : Prop) ‚àß\n      (‚àÄ (x : Œ±) (a : x ‚àà s), ‚àÉ (t : Set Œ±), (t ‚àà c : Prop) ‚àß (‚àÄ (y : Œ±) (a : (x, y) ‚àà n), y ‚àà t : Prop) : Prop)","name":"lebesgue_number_lemma_union‚Çõ","isProp":true,"docString":"Let `c : Set (Set Œ±)` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ‚àà s` its `n`-neighborhood is contained in some `t ‚àà c`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [self : TopologicalSpace.SeparableSpace Œ±],\n  ‚àÉ (s : Set Œ±), (Set.Countable s : Prop) ‚àß (Dense s : Prop)","name":"TopologicalSpace.SeparableSpace.exists_countable_dense","isProp":true,"docString":"There exists a countable dense set. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {P : (a : Polynomial R) ‚Üí Prop} (p : Polynomial R) (h0 : 0 < Polynomial.degree p)\n  (hC : ‚àÄ {a : R} (a_1 : a ‚â† 0), P (‚ÜëPolynomial.C a * Polynomial.X))\n  (hX : ‚àÄ {p : Polynomial R} (a : 0 < Polynomial.degree p) (a : P p), P (p * Polynomial.X))\n  (hadd : ‚àÄ {p : Polynomial R} {a : R} (a_1 : 0 < Polynomial.degree p) (a_2 : P p), P (p + ‚ÜëPolynomial.C a)), P p","name":"Polynomial.degree_pos_induction_on","isProp":true,"docString":"A property holds for all polynomials of positive `degree` with coefficients in a semiring `R`\nif it holds for\n* `a * X`, with `a ‚àà R`,\n* `p * X`, with `p ‚àà R[X]`,\n* `p + a`, with `a ‚àà R`, `p ‚àà R[X]`,\nwith appropriate restrictions on each term.\n\nSee `natDegree_ne_zero_induction_on` for a similar statement involving no explicit multiplication.\n "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) (N : Subgroup G) [hN : Subgroup.Normal N], ‚Üë(H ‚äî N) = ‚ÜëH * ‚ÜëN","name":"Subgroup.mul_normal","isProp":true,"docString":"The carrier of `H ‚äî N` is just `‚ÜëH * ‚ÜëN` (pointwise set product) when `N` is normal. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 2)}\n  {j : Fin (n + 1)} (H : ‚ÜëFin.castSucc j < i),\n  CategoryTheory.CosimplicialObject.Œ¥ X (Fin.succ i) ‚â´ CategoryTheory.CosimplicialObject.œÉ X (‚ÜëFin.castSucc j) =\n    CategoryTheory.CosimplicialObject.œÉ X j ‚â´ CategoryTheory.CosimplicialObject.Œ¥ X i","name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_gt","isProp":true,"docString":"The fourth cosimplicial identity "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : ‚àÄ (x : Œ±) (y : Œ±), f (x * y) = f x * f y), IsGroupHom f","name":"IsGroupHom.mk'","isProp":true,"docString":"Construct `IsGroupHom` from its only hypothesis. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : SeminormedAddCommGroup E] [inst_2 : NormedSpace ùïú E]\n  {r : ‚Ñù} (hr : 0 < r), Absorbent ùïú (Metric.ball 0 r)","name":"absorbent_ball_zero","isProp":true,"docString":"Balls at the origin are absorbent. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} (hf : CategoryTheory.SplitMono f)\n  [inst_1 : CategoryTheory.Mono (CategoryTheory.SplitMono.retraction hf)], CategoryTheory.IsIso f","name":"CategoryTheory.IsIso.of_mono_retraction'","isProp":true,"docString":"Every split mono whose retraction is mono is an iso. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r : R} {r' : R}\n  (s : { x : R // x ‚àà S }) (s' : { x : R // x ‚àà S }) (rb : R) (sb : { x : R // x ‚àà S }) (h : ‚Üës * ‚Üësb = ‚Üës' * rb),\n  r /‚Çí s + r' /‚Çí s' = (r * ‚Üësb + r' * rb) /‚Çí (s * sb)","name":"OreLocalization.oreDiv_add_char","isProp":true,"docString":"A characterization of the addition on the Ore localizaion, allowing for arbitrary Ore\nnumerator and Ore denominator. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasBinaryBiproducts C","name":"CategoryTheory.Limits.hasBinaryBiproducts_of_finite_biproducts","isProp":true,"docString":"A category with finite biproducts has binary biproducts.\n\nThis is not an instance as typically in concrete categories there will be\nan alternative construction with nicer definitional properties.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddGroupHom f)\n  {Œ≥ : Type u_1} [inst_2 : AddGroup Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} (hg : IsAddGroupHom g), IsAddGroupHom (g ‚àò f)","name":"IsAddGroupHom.comp","isProp":true,"docString":"The composition of two additive group homomorphisms is an additive\ngroup homomorphism."},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst : ContinuousSMul ‚Ñù E], PathConnectedSpace E","name":"TopologicalAddGroup.pathConnectedSpace","isProp":true,"docString":"Every topological vector space over ‚Ñù is path connected.\n\nNot an instance, because it creates enormous TC subproblems (turn on `pp.all`).\n"},{"type":"‚àÄ {H : Type u} {M : Type u_1} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M],\n  HasGroupoid M (continuousGroupoid H)","name":"hasGroupoid_continuousGroupoid","isProp":true,"docString":"Any charted space structure is compatible with the groupoid of all local homeomorphisms. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ}\n  (x : CategoryTheory.Sieve.functor S ‚ü∂ P)\n  (g : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda) X ‚ü∂ P),\n  (CategoryTheory.Sieve.functorInclusion S ‚â´ g = x : Prop) ‚Üî\n    (CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation\n        (‚Üë(‚ÜëCategoryTheory.Presieve.natTransEquivCompatibleFamily x)) (‚ÜëCategoryTheory.yonedaEquiv g) :\n      Prop)","name":"CategoryTheory.Presieve.extension_iff_amalgamation","isProp":true,"docString":"(Implementation). A lemma useful to prove `isSheafFor_iff_yonedaSheafCondition`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  (h : ‚àÄ (X : C), CategoryTheory.Mono (CategoryTheory.Limits.initial.to X)), CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.InitialMonoClass.of_initial","isProp":true,"docString":"To show a category is a `InitialMonoClass` it suffices to show every morphism out of the\ninitial object is a monomorphism. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) [inst_5 : DecidableEq Œπ] (m : (i : Œπ) ‚Üí M‚ÇÅ i)\n  (m' : (i : Œπ) ‚Üí M‚ÇÅ i) (t : Finset Œπ),\n  ‚Üëf (Finset.piecewise t (m + m') m') = Finset.sum (Finset.powerset t) fun (s : Finset Œπ) ‚Ü¶ ‚Üëf (Finset.piecewise s m m')","name":"MultilinearMap.map_piecewise_add","isProp":true,"docString":"If one adds to a vector `m'` another vector `m`, but only for coordinates in a finset `t`, then\nthe image under a multilinear map `f` is the sum of `f (s.piecewise m m')` along all subsets `s` of\n`t`. This is mainly an auxiliary statement to prove the result when `t = univ`, given in\n`map_add_univ`, although it can be useful in its own right as it does not require the index set `Œπ`\nto be finite."},{"type":"‚àÄ {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {Œ≤ : (a : Œπ) ‚Üí Type w} [inst : (i : Œπ) ‚Üí AddCommMonoid (Œ≤ i)] {Œ≥ : Type u_1}\n  [inst_1 : AddMonoid Œ≥] ‚¶Éf : (DirectSum Œπ fun (i : Œπ) ‚Ü¶ Œ≤ i) ‚Üí+ Œ≥‚¶Ñ ‚¶Ég : (DirectSum Œπ fun (i : Œπ) ‚Ü¶ Œ≤ i) ‚Üí+ Œ≥‚¶Ñ\n  (H : ‚àÄ (i : Œπ) (y : Œ≤ i), ‚Üëf (‚Üë(DirectSum.of Œ≤ i) y) = ‚Üëg (‚Üë(DirectSum.of Œ≤ i) y)), f = g","name":"DirectSum.addHom_ext","isProp":true,"docString":"If two additive homomorphisms from `‚®Å i, Œ≤ i` are equal on each `of Œ≤ i y`,\nthen they are equal. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M} (pp : Prime p),\n  (p ‚à£ List.prod L : Prop) ‚Üî (‚àÉ (a : M), (a ‚àà L : Prop) ‚àß (p ‚à£ a : Prop) : Prop)","name":"Prime.dvd_prod_iff","isProp":true,"docString":"Prime `p` divides the product of a list `L` iff it divides some `a ‚àà L` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocRing Œ±] [inst_1 : NonAssocRing Œ≤] (f : Œ± ‚Üí+* Œ≤) (x : Œ±) (y : Œ±),\n  ‚Üëf (x - y) = ‚Üëf x - ‚Üëf y","name":"RingHom.map_sub","isProp":true,"docString":"Ring homomorphisms preserve subtraction. "},{"type":"‚àÄ {B : Type u_1} (F : Type u_2) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : (a : B) ‚Üí Type u_3)\n  [inst_2 : TopologicalSpace (Bundle.TotalSpace E)] [inst_3 : (b : B) ‚Üí TopologicalSpace (E b)]\n  [inst_4 : ConditionallyCompleteLinearOrder B] [inst_5 : OrderTopology B] [inst_6 : FiberBundle F E] (a : B) (b : B),\n  ‚àÉ (e : Trivialization F Bundle.TotalSpace.proj), Set.Icc a b ‚äÜ Trivialization.baseSet e","name":"FiberBundle.exists_trivialization_Icc_subset","isProp":true,"docString":"If `E` is a fiber bundle over a conditionally complete linear order,\nthen it is trivial over any closed interval. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasStrictTerminalObjects C]\n  {J : Type v} [inst_2 : CategoryTheory.SmallCategory J] (F : J ‚•§ C) [inst_3 : CategoryTheory.Limits.HasLimit F] (i : J)\n  (H :\n    (j : J) ‚Üí (x : j ‚â† i) ‚Üí CategoryTheory.Limits.IsTerminal (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) j))\n  [inst_4 : Subsingleton (i ‚ü∂ i)], CategoryTheory.IsIso (CategoryTheory.Limits.limit.œÄ F i)","name":"CategoryTheory.Limits.limit_œÄ_isIso_of_is_strict_terminal","isProp":true,"docString":"If all but one object in a diagram is strict terminal, the the limit is isomorphic to the\nsaid object via `limit.œÄ`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (a : Œ±),\n  Filter.HasBasis (nhds a) (fun (s : Set Œ±) ‚Ü¶ (s ‚àà nhds a : Prop) ‚àß (IsOpen s : Prop)) fun (x : Set Œ±) ‚Ü¶ x","name":"nhds_basis_opens'","isProp":true,"docString":"The open neighborhoods of `a` are a basis for the neighborhood filter. See `nhds_basis_opens`\nfor a variant using open sets around `a` instead. "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  [inst_2 : CategoryTheory.Faithful F], CategoryTheory.Faithful (CategoryTheory.Functor.toEssImage F)","name":"CategoryTheory.Faithful.toEssImage","isProp":true,"docString":"The induced functor of a faithful functor is faithful "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommSemigroup Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ExistsAddOfLE Œ±]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [inst_4 : Sub Œ±]\n  [inst_5 : OrderedSub Œ±] {a : Œ±} {b : Œ±}\n  [inst : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (h : a ‚â§ b),\n  b - (b - a) = a","name":"tsub_tsub_cancel_of_le","isProp":true,"docString":"See `tsub_tsub_le` for an inequality. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P), p ‚àà ‚ä§","name":"AffineSubspace.mem_top","isProp":true,"docString":"All points are in `‚ä§`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {Œπ : Type u_1}\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} [inst_2 : CompactSpace Œ≤] (h : Equicontinuous F), UniformEquicontinuous F","name":"CompactSpace.uniformEquicontinuous_of_equicontinuous","isProp":true,"docString":"An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} {t : Set Œ±} (a : s = t), s ‚äÜ t","name":"Eq.subset","isProp":true,"docString":"Duplicate of `eq.subset'`, which currently has elaboration problems. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G ‚Üí+ N) {H : AddSubgroup G}\n  {K : AddSubgroup G} (hH : AddMonoidHom.ker f ‚â§ H) (hK : AddMonoidHom.ker f ‚â§ K)\n  (hf : AddSubgroup.map f H = AddSubgroup.map f K), H = K","name":"AddSubgroup.map_injective_of_ker_le","isProp":true,"docString":"Given `f(A) = f(B)`, `ker f ‚â§ A`, and `ker f ‚â§ B`, deduce that `A = B`."},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type v} [inst : MetricSpace Œ±] [inst_1 : ProperSpace Œ±] {c : (a : Œπ) ‚Üí Œ±} {s : Set Œ±}\n  {r : (a : Œπ) ‚Üí ‚Ñù} (hr : ‚àÄ (i : Œπ), 0 < r i) (hs : IsClosed s)\n  (uf : ‚àÄ (x : Œ±) (a : x ‚àà s), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ x ‚àà Metric.ball (c i) (r i)))\n  (us : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r i)),\n  ‚àÉ (r' : (a : Œπ) ‚Üí ‚Ñù),\n    (s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r' i) : Prop) ‚àß (‚àÄ (i : Œπ), r' i ‚àà Set.Ioo 0 (r i) : Prop)","name":"exists_subset_union·µ¢_ball_radius_pos_lt","isProp":true,"docString":"Shrinking lemma for coverings by open balls in a proper metric space. A point-finite open cover\nof a closed subset of a proper metric space by nonempty open balls can be shrunk to a new cover by\nnonempty open balls so that each of the new balls has strictly smaller radius than the old one. "},{"type":"‚àÄ {R : Type u_1} [inst : Add R] [inst_1 : Mul R] (self : RingCon R) {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x)\n  (a : Setoid.r y z), Setoid.r (w * y) (x * z)","name":"RingCon.mul'","isProp":true,"docString":"Ring congruence relations are closed under multiplication "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  (h‚ÇÅ : a ‚äÜ b) (h‚ÇÇ : ¬¨(b ‚äÜ a : Prop)), a ‚äÇ b","name":"HasSubset.Subset.ssubset_of_not_subset","isProp":true,"docString":"**Alias** of `ssubset_of_subset_not_subset`."},{"type":"‚àÄ {Œ± : Type v} {s : Finset Œ±} {M : Type u_1} [inst : CommMonoid M] (f : (a : Œ±) ‚Üí M) (p : (a : M) ‚Üí Prop)\n  (hom : ‚àÄ (a : M) (b : M) (a_1 : p a) (a_2 : p b), p (a * b)) (nonempty : Finset.Nonempty s)\n  (base : ‚àÄ (x : Œ±) (a : x ‚àà s), p (f x)), p (Finset.prod s fun (x : Œ±) ‚Ü¶ f x)","name":"Finset.prod_induction_nonempty","isProp":true,"docString":"To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±}, (Equicontinuous F : Prop) ‚Üî (Continuous (‚ÜëUniformFun.ofFun ‚àò Function.swap F) : Prop)","name":"equicontinuous_iff_continuous","isProp":true,"docString":"A family `ùìï : Œπ ‚Üí X ‚Üí Œ±` is equicontinuous iff the function `swap ùìï : X ‚Üí Œπ ‚Üí Œ±` is\ncontinuous *when `Œπ ‚Üí Œ±` is equipped with the topology of uniform convergence*. This is\nvery useful for developping the equicontinuity API, but it should not be used directly for other\npurposes. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Surjective f) (s : Set Œ≤)\n  (hs : Set.Subsingleton (f ‚Åª¬π' s)), Set.Subsingleton s","name":"Set.subsingleton_of_preimage","isProp":true,"docString":"If the preimage of a set under an surjective map is a subsingleton,\nthe set is a subsingleton. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {C : Set Œ±} (hC : Perfect C) {Œµ : ENNReal} (hnonempty : Set.Nonempty C)\n  (Œµ_pos : 0 < Œµ),\n  ‚àÉ (C‚ÇÄ : Set Œ±),\n    ‚àÉ (C‚ÇÅ : Set Œ±),\n      ((Perfect C‚ÇÄ : Prop) ‚àß\n            ((Set.Nonempty C‚ÇÄ : Prop) ‚àß ((C‚ÇÄ ‚äÜ C : Prop) ‚àß (EMetric.diam C‚ÇÄ ‚â§ Œµ : Prop) : Prop) : Prop) :\n          Prop) ‚àß\n        (((Perfect C‚ÇÅ : Prop) ‚àß\n                ((Set.Nonempty C‚ÇÅ : Prop) ‚àß ((C‚ÇÅ ‚äÜ C : Prop) ‚àß (EMetric.diam C‚ÇÅ ‚â§ Œµ : Prop) : Prop) : Prop) :\n              Prop) ‚àß\n            (Disjoint C‚ÇÄ C‚ÇÅ : Prop) :\n          Prop)","name":"Perfect.small_diam_splitting","isProp":true,"docString":"A refinement of `Perfect.splitting` for metric spaces, where we also control\nthe diameter of the new perfect sets. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú} (hf : StrictConcaveOn ùïú s f) {x : ùïú}\n  {y : ùïú} {z : ùïú} (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z), (f z - f y) / (z - y) < (f y - f x) / (y - x)","name":"StrictConcaveOn.slope_anti_adjacent","isProp":true,"docString":"If `f : ùïú ‚Üí ùïú` is strictly concave, then for any three points `x < y < z` the slope of the\nsecant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {l : Filter Œ±} {a : Œ±}\n  (a_1 : IsMinFilter (‚ÜëOrderDual.toDual ‚àò f) l a), IsMaxFilter f l a","name":"IsMinFilter.undual","isProp":true,"docString":"**Alias** of the forward direction of `isMinFilter_dual_iff`."},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : IsTrans Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1] {a : Œ±} {b : Œ±} {c : Œ±}\n  (a_1 : a ‚äÜ b) (a_2 : b ‚äÜ c), a ‚äÜ c","name":"HasSubset.Subset.trans","isProp":true,"docString":"**Alias** of `subset_trans`."},{"type":"‚àÄ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Sup L] [self : ContinuousSup L],\n  Continuous fun (p : L √ó L) ‚Ü¶ Prod.fst p ‚äî Prod.snd p","name":"ContinuousSup.continuous_sup","isProp":true,"docString":"The supremum is continuous "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (s : Set E),\n  Metric.diam (‚Üë(ClosureOperator.toOrderHom (convexHull ‚Ñù)) s) = Metric.diam s","name":"convexHull_diam","isProp":true,"docString":"Diameter of the convex hull of a set `s` equals the emetric diameter of `s. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SeminormedRing Œ±] [inst_1 : NormOneClass Œ±] (a : Œ±) (n : ‚Ñï), ‚Äña ^ n‚Äñ ‚â§ ‚Äña‚Äñ ^ n","name":"norm_pow_le","isProp":true,"docString":"If `Œ±` is a seminormed ring with `‚Äñ1‚Äñ = 1`, then `‚Äña ^ n‚Äñ ‚â§ ‚Äña‚Äñ ^ n`. See also `norm_pow_le'`."},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π","name":"map_inv","isProp":true,"docString":"Group homomorphisms preserve inverse. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {s : Set Œ±} {t : Set Œ≤}\n  (a :\n    LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© ‚Üëe ‚Åª¬π' t =\n      LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© s),\n  LocalHomeomorph.IsImage e s t","name":"LocalHomeomorph.IsImage.of_preimage_eq","isProp":true,"docString":"**Alias** of the reverse direction of `LocalHomeomorph.IsImage.iff_preimage_eq`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : MonotoneOn f s), AntitoneOn (f ‚àò ‚ÜëOrderDual.ofDual) s","name":"MonotoneOn.dual_left","isProp":true,"docString":"**Alias** of the reverse direction of `antitoneOn_comp_ofDual_iff`."},{"type":"‚àÄ {Œº : YoungDiagram} (self : Ssyt Œº) {i : ‚Ñï} {j : ‚Ñï} (a : ¬¨((i, j) ‚àà Œº : Prop)), Ssyt.entry self i j = 0","name":"Ssyt.zeros'","isProp":true,"docString":"`entry` is required to be zero for all pairs `(i, j) ‚àâ Œº`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : IsCompact s) (ht : IsClosed t) (h : t ‚äÜ s),\n  IsCompact t","name":"isCompact_of_isClosed_subset","isProp":true,"docString":"A closed subset of a compact set is a compact set. "},{"type":"‚àÄ {p : Prop} (h : ‚àÄ (a : ¬¨(p : Prop)), False), p","name":"Classical.by_contradiction","isProp":true,"docString":"**Alias** of `Classical.byContradiction`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (G : CategoryTheory.Comonad C)\n  {A : CategoryTheory.Comonad.Coalgebra G} {B : CategoryTheory.Comonad.Coalgebra G} (f : A ‚ü∂ B)\n  [inst_1 : CategoryTheory.IsIso (CategoryTheory.Comonad.Coalgebra.Hom.f f)], CategoryTheory.IsIso f","name":"CategoryTheory.Comonad.coalgebra_iso_of_iso","isProp":true,"docString":"Given a coalgebra morphism whose carrier part is an isomorphism, we get a coalgebra isomorphism.\n"},{"type":"‚àÄ (k : Type u_1) [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ) [inst_1 : CharZero k] [inst_2 : Fintype Œπ]\n  {n : ‚Ñï} (h : Finset.card s = n + 1), (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ Finset.centroidWeightsIndicator k s i) = 1","name":"Finset.sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one","isProp":true,"docString":"In the characteristic zero case, the weights in the centroid\nindexed by a `Fintype` sum to 1 if the number of points is `n + 1`. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (z : ‚Ñ§), padicNorm p ‚Üëz ‚â§ 1","name":"padicNorm.of_int","isProp":true,"docString":"The `p`-adic norm of an integer is at most `1`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (H : IsTotallySeparated s), IsTotallyDisconnected s","name":"IsTotallySeparated.isTotallyDisconnected","isProp":true,"docString":"**Alias** of `isTotallyDisconnected_of_isTotallySeparated`."},{"type":"‚àÄ {R‚ÇÅ : Type u_1} [inst : Semiring R‚ÇÅ] {M‚ÇÅ : Type u_2} [inst_1 : TopologicalSpace M‚ÇÅ] [inst_2 : AddCommMonoid M‚ÇÅ]\n  [inst_3 : Module R‚ÇÅ M‚ÇÅ] [inst_4 : ContinuousAdd M‚ÇÅ], FaithfulSMul (M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) M‚ÇÅ","name":"ContinuousLinearMap.applyFaithfulSMul","isProp":true,"docString":"`ContinuousLinearMap.applyModule` is faithful. "},{"type":"‚àÄ {Œπ : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] {f : (a : Œπ) ‚Üí E} {g : (a : Œπ) ‚Üí ‚Ñù} {a : ‚Ñù}\n  (hg : HasSum g a) (h : ‚àÄ (i : Œπ), ‚Äñf i‚Äñ ‚â§ g i), ‚Äñtsum fun (i : Œπ) ‚Ü¶ f i‚Äñ ‚â§ a","name":"tsum_of_norm_bounded","isProp":true,"docString":"Quantitative result associated to the direct comparison test for series:  If `‚àë' i, g i` is\nsummable, and for all `i`, `‚Äñf i‚Äñ ‚â§ g i`, then `‚Äñ‚àë' i, f i‚Äñ ‚â§ ‚àë' i, g i`. Note that we do not\nassume that `‚àë' i, f i` is summable, and it might not be the case if `Œ±` is not a complete space. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} (a : l ‚â† []), 0 < List.length l","name":"List.length_pos_of_ne_nil","isProp":true,"docString":"**Alias** of the reverse direction of `List.length_pos`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  [self : CategoryTheory.IsEquivalence F] (X : C),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor F)\n        ((CategoryTheory.Iso.hom CategoryTheory.IsEquivalence.unitIso).app X) ‚â´\n      (CategoryTheory.Iso.hom CategoryTheory.IsEquivalence.counitIso).app\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X) =\n    ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X)","name":"CategoryTheory.IsEquivalence.functor_unitIso_comp","isProp":true,"docString":"We natural isomorphisms are inverse "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {B : C} {X : CategoryTheory.Subobject B}\n  {Y : CategoryTheory.Subobject B}\n  (f :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.Subobject.underlying) X ‚âÖ\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.Subobject.underlying) Y)\n  (w : CategoryTheory.Iso.hom f ‚â´ CategoryTheory.Subobject.arrow Y = CategoryTheory.Subobject.arrow X), X = Y","name":"CategoryTheory.Subobject.eq_of_comm","isProp":true,"docString":"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {r : ‚Ñù}, Metric.Bounded (Metric.ball x r)","name":"Metric.bounded_ball","isProp":true,"docString":"Open balls are bounded "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (p : (a : Œ±) ‚Üí Prop) (x : Œ±)\n  (H : Filter.Frequently (fun (R : ‚Ñù) ‚Ü¶ ‚àÄ (y : Œ±) (a : y ‚àà Metric.ball x R), p y) Filter.atTop) (y : Œ±), p y","name":"Metric.forall_of_forall_mem_ball","isProp":true,"docString":"If a property holds for all points in balls of arbitrarily large radii, then it holds for all\npoints. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Arrow S),\n  CategoryTheory.Sieve.arrows (CategoryTheory.GrothendieckTopology.Cover.sieve S)\n    (CategoryTheory.GrothendieckTopology.Cover.Arrow.f self)","name":"CategoryTheory.GrothendieckTopology.Cover.Arrow.hf","isProp":true,"docString":"The given arrow is contained in the given sieve. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Multiset Œ±} {t : Multiset Œ±} {u : Multiset Œ±},\n  (s - t ‚â§ u : Prop) ‚Üî (s ‚â§ u + t : Prop)","name":"Multiset.sub_le_iff_le_add","isProp":true,"docString":"This is a special case of `tsub_le_iff_right`, which should be used instead of this.\nThis is needed to prove `OrderedSub (Multiset Œ±)`. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], affineSpan k Set.univ = ‚ä§","name":"AffineSubspace.span_univ","isProp":true,"docString":"The span of `univ` is `‚ä§`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ≤) ‚Üí Œ±} (hf : Function.Injective f) (hg : Function.Injective g),\n  ‚àÉ (h : (a : Œ±) ‚Üí Œ≤), Function.Bijective h","name":"Function.Embedding.schroeder_bernstein","isProp":true,"docString":"**The Schr√∂der-Bernstein Theorem**:\nGiven injections `Œ± ‚Üí Œ≤` and `Œ≤ ‚Üí Œ±`, we can get a bijection `Œ± ‚Üí Œ≤`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 < a) (hb : 0 < b), 0 < a + b","name":"add_pos'","isProp":true,"docString":"**Alias** of `Left.add_pos'`."},{"type":"‚àÄ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (x : A) (r : R)\n  (y : A), x * (‚Üë(algebraMap R A) r * y) = ‚Üë(algebraMap R A) r * (x * y)","name":"Algebra.left_comm","isProp":true,"docString":"`mul_left_comm` for `Algebra`s when one element is from the base ring. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)\n  [inst_3 : CategoryTheory.Epi f], CategoryTheory.Epi CategoryTheory.Limits.pullback.snd","name":"CategoryTheory.Abelian.epi_pullback_of_epi_f","isProp":true,"docString":"In an abelian category, the pullback of an epimorphism is an epimorphism.\nProof from [aluffi2016, IX.2.3], cf. [borceux-vol2, 1.7.6] "},{"type":"‚àÄ {I : Type u} {f : (a : I) ‚Üí Type v} [inst : DecidableEq I] [inst_1 : (i : I) ‚Üí MulOneClass (f i)] (x : (i : I) ‚Üí f i)\n  (i : I) (j : I), Commute (Pi.mulSingle i (x i)) (Pi.mulSingle j (x j))","name":"Pi.mulSingle_apply_commute","isProp":true,"docString":"The injection into a pi group with the same values commutes. "},{"type":"‚àÄ {n : ‚Ñï} {a : Cardinal}, (n ‚Ä¢ a < Cardinal.aleph0 : Prop) ‚Üî ((n = 0 : Prop) ‚à® (a < Cardinal.aleph0 : Prop) : Prop)","name":"Cardinal.nsmul_lt_aleph0_iff","isProp":true,"docString":"See also `Cardinal.nsmul_lt_aleph0_iff_of_ne_zero` if you already have `n ‚â† 0`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)","name":"Group.normalClosure.isSubgroup","isProp":true,"docString":"The normal closure of a set is a subgroup. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R] [nR : Nontrivial R], ¬¨(IsLeftRegular 0 : Prop)","name":"not_isLeftRegular_zero","isProp":true,"docString":"In a non-trivial ring, the element `0` is not left-regular -- with typeclasses. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}\n  {y : (i : Œπ) ‚Üí Œ≤ i}, 0 ‚â§ hammingDist x y","name":"hammingDist_nonneg","isProp":true,"docString":"Corresponds to `dist_nonneg`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) (d : AddCon M),\n  c ‚äî d = addConGen fun (x : M) (y : M) ‚Ü¶ (‚Üëc x y : Prop) ‚à® (‚Üëd x y : Prop)","name":"AddCon.sup_eq_addConGen","isProp":true,"docString":"The supremum of additive congruence relations `c, d` equals the\nsmallest additive congruence relation containing the binary relation '`x` is related to `y`\nby `c` or `d`'."},{"type":"‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W]\n  [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W}\n  (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ)\n  (hœÜ : NormedAddGroupHom.NormNoninc œÜ), NormedAddGroupHom.NormNoninc (NormedAddGroupHom.Equalizer.lift œÜ h)","name":"NormedAddGroupHom.Equalizer.lift_normNoninc","isProp":true,"docString":"The lifting of a norm nonincreasing morphism is norm nonincreasing. "},{"type":"‚àÄ {Œ± : Type u_2} {ùïú : Type u_1} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {S : Set Œ±} [inst : TopologicalSpace Œ±]\n  [inst_1 : TopologicalSpace ùïú] [inst_2 : T1Space ùïú] [inst_3 : Field ùïú] [inst_4 : HasContinuousInv‚ÇÄ ùïú]\n  [inst_5 : ContinuousMul ùïú] (hS : IsPreconnected S) (hf : ContinuousOn f S) (hg : ContinuousOn g S)\n  (hsq : Set.EqOn (f ^ 2) (g ^ 2) S) (hg_ne : ‚àÄ {x : Œ±} (a : x ‚àà S), g x ‚â† 0),\n  (Set.EqOn f g S : Prop) ‚à® (Set.EqOn f (-g) S : Prop)","name":"IsPreconnected.eq_or_eq_neg_of_sq_eq","isProp":true,"docString":"If `f, g` are functions `Œ± ‚Üí ùïú`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ‚â† 0` all `z ‚àà S`, then either `f = g` or `f = -g` on\n`S`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {s : (a : Œπ) ‚Üí Set Œ±} (hs : IndexedPartition s) (x : IndexedPartition.Quotient hs),\n  IndexedPartition.index hs (Quotient.out' x) = IndexedPartition.index hs (‚Üë(IndexedPartition.out hs) x)","name":"IndexedPartition.index_out'","isProp":true,"docString":"The indices of `Quotient.out'` and `IndexedPartition.out` are equal. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : sbtw a b c), btw a b c","name":"SBtw.sbtw.btw","isProp":true,"docString":"**Alias** of `btw_of_sbtw`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PartialOrder Œ≤] (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst_1 : IsSymm Œ± r]\n  {f : (a : Œ±) ‚Üí Œ≤} (h : ‚àÄ (a : Œ±) (b : Œ±) (a_1 : r a b), f a ‚â§ f b) {a : Œ±} {b : Œ±} (a_1 : r a b), f a = f b","name":"rel_imp_eq_of_rel_imp_le","isProp":true,"docString":"A symmetric relation implies two values are equal, when it implies they're less-equal.  "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ≤) ‚Üí Œ±}\n  (hg : Function.Injective g),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà Set.range g) ‚Ü¶ f i) = finprod fun (j : Œ≤) ‚Ü¶ f (g j)","name":"finprod_mem_range","isProp":true,"docString":"The product of `f y` over `y ‚àà Set.range g` equals the product of `f (g i)` over all `i`\nprovided that `g` is injective. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : NormalizationMonoid Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â† 0)\n  (a_2 : b ‚â† 0), normUnit (a * b) = normUnit a * normUnit b","name":"NormalizationMonoid.normUnit_mul","isProp":true,"docString":"The proposition that `normUnit` respects multiplication of non-zero elements. "},{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f‚ÇÄ : C(X, Y)} {f‚ÇÅ : C(X, Y)}\n  (F : ContinuousMap.Homotopy f‚ÇÄ f‚ÇÅ), Continuous ‚ÜëF","name":"ContinuousMap.Homotopy.continuous","isProp":true,"docString":"Deprecated. Use `map_continuous` instead. "},{"type":"‚àÄ {Œ± : Type u} (s : Set Œ±) [inst : Countable ‚Üës], Set.Countable s","name":"Set.to_countable","isProp":true,"docString":"Prove `Set.Countable` from a `Countable` instance on the subtype. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {p : (a : Œ±) ‚Üí Prop} {a : Œ±}\n  (h : Filter.Eventually (fun (y : Œ±) ‚Ü¶ p y) (nhds a)),\n  Filter.Eventually (fun (y : Œ±) ‚Ü¶ Filter.Eventually (fun (x : Œ±) ‚Ü¶ p x) (nhds y)) (nhds a)","name":"Filter.Eventually.eventually_nhds","isProp":true,"docString":"If a predicate is true in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` this predicate is true in a neighbourhood of `y`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (hs : TotallyBounded s) (hf : UniformContinuous f), TotallyBounded (f '' s)","name":"TotallyBounded.image","isProp":true,"docString":"The image of a totally bounded set under a uniformly continuous map is totally bounded. "},{"type":"‚àÄ (R : Type u_2) [inst : Semiring R] (M : Type u_1) [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  Function.Surjective ‚Üë(Finsupp.total M M R id)","name":"Finsupp.total_id_surjective","isProp":true,"docString":"Any module is a quotient of a free module. This is stated as surjectivity of\n`Finsupp.total M M R id : (M ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : b < c - a), a + b < c","name":"add_lt_of_lt_sub_left","isProp":true,"docString":"**Alias** of the forward direction of `lt_sub_iff_add_lt'`."},{"type":"‚àÄ {Œπ : Type u_4} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] (b : Basis Œπ R M) (e : Œπ ‚âÉ Œπ'), Set.range ‚Üë(Basis.reindex b e) = Set.range ‚Üëb","name":"Basis.range_reindex","isProp":true,"docString":"`simp` can prove this as `Basis.coe_reindex` + `EquivLike.range_comp` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {b : Œ±} (ha : a < 0) (hb : b < 0),\n  (1 / a < 1 / b : Prop) ‚Üî (b < a : Prop)","name":"one_div_lt_one_div_of_neg","isProp":true,"docString":"For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and\n`lt_of_one_div_lt_one_div` "},{"type":"‚àÄ {Œ± : Type u_1} [self : Order.Frame Œ±] (a : Œ±) (s : Set Œ±),\n  a ‚äì sup‚Çõ s ‚â§ sup·µ¢ fun (b : Œ±) ‚Ü¶ sup·µ¢ fun (h : b ‚àà s) ‚Ü¶ a ‚äì b","name":"Order.Frame.inf_sup‚Çõ_le_sup·µ¢_inf","isProp":true,"docString":"In a frame, `‚äì` distributes over `‚®Ü`. "},{"type":"‚àÄ {r : NNReal}, ‚ä§ - ‚Üër = ‚ä§","name":"ENNReal.top_sub_coe","isProp":true,"docString":"This is a special case of `WithTop.top_sub_coe` in the `ENNReal` namespace "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] [self : NoTopOrder Œ±] (a : Œ±), ‚àÉ (b : Œ±), ¬¨(b ‚â§ a : Prop)","name":"NoTopOrder.exists_not_le","isProp":true,"docString":"For each term `a`, there is some `b` which is either incomparable or strictly larger. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p : Prop)]\n  (hdvd : p ‚à£ Fintype.card G), ‚àÉ (x : G), addOrderOf x = p","name":"exists_prime_addOrderOf_dvd_card","isProp":true,"docString":"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  [self : CategoryTheory.Functor.PreservesMonomorphisms F] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Mono f],\n  CategoryTheory.Mono (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)","name":"CategoryTheory.Functor.PreservesMonomorphisms.preserves","isProp":true,"docString":"A functor preserves monomorphisms if it maps monomorphisms to monomorphisms. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (Hf : Monotone f) {a : Œ±}\n  {s : Set Œ±} (Ha : IsGreatest s a), IsGreatest (f '' s) (f a)","name":"Monotone.map_isGreatest","isProp":true,"docString":"A monotone map sends a greatest element of a set to a greatest element of its image. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Antitone f) {a : Œ±}\n  {s : Set Œ±} (a_1 : IsGreatest s a), IsLeast (f '' s) (f a)","name":"Antitone.map_isGreatest","isProp":true,"docString":"An antitone map sends a greatest element of a set to a least element of its image. "},{"type":"‚àÄ {œÑ : Type u_2} {Œ± : Type u_3} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤] (f : Filter œÑ) (œï : (a : œÑ) ‚Üí (a : Œ±) ‚Üí Œ≤)\n  (s : Set Œ±) {c : Set Œ≤} (hc‚ÇÅ : IsCompact c)\n  (hc‚ÇÇ : ‚àÉ (v : Set œÑ), (v ‚àà f : Prop) ‚àß (closure (Set.image2 œï v s) ‚äÜ c : Prop)) {n : Set Œ≤} (hn‚ÇÅ : IsOpen n)\n  (hn‚ÇÇ : omegaLimit f œï s ‚äÜ n), ‚àÉ (u : Set œÑ), (u ‚àà f : Prop) ‚àß (closure (Set.image2 œï u s) ‚äÜ n : Prop)","name":"eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset'","isProp":true,"docString":"A set is eventually carried into any open neighbourhood of its œâ-limit:\nif `c` is a compact set such that `closure {œï t x | t ‚àà v, x ‚àà s} ‚äÜ c` for some `v ‚àà f`\nand `n` is an open neighbourhood of `œâ f œï s`, then for some `u ‚àà f` we have\n`closure {œï t x | t ‚àà u, x ‚àà s} ‚äÜ n`. "},{"type":"‚àÄ {K : Type u_2} {K‚ÇÅ : Type u_1} {V‚ÇÅ : Type u_3} {n : Type u_4} [inst : Field K] [inst_1 : Field K‚ÇÅ]\n  [inst_2 : AddCommGroup V‚ÇÅ] [inst_3 : Module K‚ÇÅ V‚ÇÅ] {I‚ÇÅ : K‚ÇÅ ‚Üí+* K} {I‚ÇÅ' : K‚ÇÅ ‚Üí+* K} {B : V‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] V‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ'] K}\n  {v : (a : n) ‚Üí V‚ÇÅ} (hv‚ÇÅ : LinearMap.IsOrtho·µ¢ B v) (hv‚ÇÇ : ‚àÄ (i : n), ¬¨(LinearMap.IsOrtho B (v i) (v i) : Prop)),\n  LinearIndependent K‚ÇÅ v","name":"LinearMap.linearIndependent_of_isOrtho·µ¢","isProp":true,"docString":"A set of orthogonal vectors `v` with respect to some sesquilinear form `B` is linearly\nindependent if for all `i`, `B (v i) (v i) ‚â† 0`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {a : Œ±} {b : Œ±} (hab : a ‚â† b), closure (Set.Ioc a b) = Set.Icc a b","name":"closure_Ioc","isProp":true,"docString":"The closure of the interval `(a, b]` is the closed interval `[a, b]`. "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (u : RÀ£) (v : Module.Ray R M), u‚Åª¬π ‚Ä¢ v = u ‚Ä¢ v","name":"units_inv_smul","isProp":true,"docString":"Scaling by an inverse unit is the same as scaling by itself. "},{"type":"‚àÄ (G : Type u) [inst : CommSemigroup G] [inst_1 : IsRightCancelMul G], IsCancelMul G","name":"CommSemigroup.IsRightCancelMul.toIsCancelMul","isProp":true,"docString":"Any `CommSemigroup G` that satisfies `IsRightCancelMul G` also satisfies\n`IsCancelMul G`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : InfSet Œ±] [inst_1 : InfSet Œ≤]\n  [self : Inf‚ÇõHomClass F Œ± Œ≤] (f : F) (s : Set Œ±), ‚Üëf (inf‚Çõ s) = inf‚Çõ (‚Üëf '' s)","name":"Inf‚ÇõHomClass.map_inf‚Çõ","isProp":true,"docString":"The proposition that members of `Inf‚ÇõHomClass`s commute with arbitrary infima/meets. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  (x : G), nhds ‚Üëx = Filter.map QuotientAddGroup.mk (nhds x)","name":"QuotientAddGroup.nhds_eq","isProp":true,"docString":"Neighborhoods in the quotient are precisely the map of neighborhoods in the prequotient."},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {x : M}\n  {y : M}, (SameRay R (-x) (-y) : Prop) ‚Üî (SameRay R x y : Prop)","name":"sameRay_neg_iff","isProp":true,"docString":"`SameRay.neg` as an `iff`. "},{"type":"‚àÄ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1","name":"Field.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedSemifield Œ±] (n : ‚Ñï) (a : Œ±),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a","name":"LinearOrderedSemifield.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Monoid M]\n  [inst_1 : AddMonoid A] [inst_2 : AddMonoid B] [inst_3 : DistribMulAction M A] [inst_4 : DistribMulAction M B]\n  [self : DistribMulActionHomClass F M A B] (f : F) (x : A) (y : A), ‚Üëf (x + y) = ‚Üëf x + ‚Üëf y","name":"DistribMulActionHomClass.map_add","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ (Œ± : Type u_1) [inst : TopologicalSpace Œ±] [inst_1 : PreirreducibleSpace Œ±] [inst_2 : Nontrivial Œ±]\n  [inst : T2Space Œ±], False","name":"not_preirreducible_nontrivial_t2","isProp":true,"docString":"There does not exist a nontrivial preirreducible T‚ÇÇ space. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {f : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f) (x‚ÇÄ : Œ≤)\n  (h : Filter.Eventually (fun (x : Œ≤) ‚Ü¶ f x ‚â§ f x‚ÇÄ) (Filter.cocompact Œ≤)), ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f y ‚â§ f x","name":"Continuous.exists_forall_ge'","isProp":true,"docString":"The **extreme value theorem**: if a continuous function `f` is smaller than a value in its range\naway from compact sets, then it has a global maximum. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFiltered C] {D : Type u‚ÇÅ}\n  [inst_2 : CategoryTheory.Category D] (h : C ‚âå D), CategoryTheory.IsFiltered D","name":"CategoryTheory.IsFiltered.of_equivalence","isProp":true,"docString":"Being filtered is preserved by equivalence of categories. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X]\n  (h :\n    ‚àÄ (f : (a : X) ‚Üí Prop) (a : X)\n      (a_1 :\n        ‚àÄ (u : (a : ‚Ñï) ‚Üí X) (a_1 : Filter.Tendsto u Filter.atTop (nhds a)),\n          Filter.Tendsto (f ‚àò u) Filter.atTop (nhds (f a : Prop))),\n      ContinuousAt f a),\n  FrechetUrysohnSpace X","name":"FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto","isProp":true,"docString":"An alternative construction for `FrechetUrysohnSpace`: if sequential convergence implies\nconvergence, then the space is a Fr√©chet-Urysohn space. "},{"type":"‚àÄ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R","name":"NonarchimedeanRing.to_nonarchimedeanAddGroup","isProp":true,"docString":"Every nonarchimedean ring is naturally a nonarchimedean additive group. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] (l : List M), Option.getD (List.get? l 0) 0 + List.sum (List.tail l) = List.sum l","name":"List.get?_zero_add_tail_sum","isProp":true,"docString":"We'd like to state this as `L.headI + L.tail.sum = L.sum`, but because `L.headI`\nrelies on an inhabited instance to return a garbage value on the empty list, this is not possible.\nInstead, we write the statement in terms of `(L.get? 0).getD 0`."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : NormedAddGroup E] [inst_1 : TopologicalSpace Œ±] {f : (a : Œ±) ‚Üí E}\n  (a : HasCompactSupport f), HasCompactSupport fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ","name":"HasCompactSupport.norm","isProp":true,"docString":"**Alias** of the reverse direction of `hasCompactSupport_norm_iff`."},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : SeminormedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  {t : TopologicalSpace E} {t' : TopologicalSpace E} (h : t ‚â§ t') {s : Set E} (hs : Bornology.IsVonNBounded ùïú s),\n  Bornology.IsVonNBounded ùïú s","name":"Bornology.IsVonNBounded.of_topologicalSpace_le","isProp":true,"docString":"If a topology `t'` is coarser than `t`, then any set `s` that is bounded with respect to\n`t` is bounded with respect to `t'`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {w : (a : Œ±) ‚Üí M} {b : M} [inst_1 : LinearOrderedCancelAddCommMonoid M]\n  (ht : ‚àÄ (y : Œ≤) (x : ¬¨(y ‚àà t : Prop)), (Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x) ‚â§ 0)\n  (hb : Finset.card t ‚Ä¢ b < Finset.sum s fun (x : Œ±) ‚Ü¶ w x),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (b < Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x : Prop)","name":"Finset.exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:\nif the total weight of a finite set of pigeons is greater than `n ‚Ä¢ b`, they are sorted into some\npigeonholes, and for all but `n` pigeonholes the total weight of the pigeons there is nonpositive,\nthen for at least one of these `n` pigeonholes, the total weight of the pigeons in this pigeonhole\nis greater than `b`. "},{"type":"‚àÄ {Œ± : Type u} (S : Set Œ±) (T : Set Œ±), Cardinal.mk ‚Üë(S ‚à™ T) ‚â§ Cardinal.mk ‚ÜëS + Cardinal.mk ‚ÜëT","name":"Cardinal.mk_union_le","isProp":true,"docString":"The cardinality of a union is at most the sum of the cardinalities\nof the two sets. "},{"type":"‚àÄ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : Monoid A] [self : MulDistribMulAction M A] (r : M) (x : A)\n  (y : A), r ‚Ä¢ (x * y) = r ‚Ä¢ x * r ‚Ä¢ y","name":"MulDistribMulAction.smul_mul","isProp":true,"docString":"Distributivity of `‚Ä¢` across `*` "},{"type":"‚àÄ {n : Type u_1} {ùïú : Type u_2} [inst : Field ùïú] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n ùïú),\n  ‚àÉ (L : List (Matrix.TransvectionStruct n ùïú)),\n    ‚àÉ (L' : List (Matrix.TransvectionStruct n ùïú)),\n      ‚àÉ (D : (a : n) ‚Üí ùïú),\n        M =\n          Matrix.mul (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L)) (Matrix.diagonal D))\n            (List.prod (List.map Matrix.TransvectionStruct.toMatrix L'))","name":"Matrix.Pivot.exists_list_transvec_mul_diagonal_mul_list_transvec","isProp":true,"docString":"Any matrix can be written as the product of transvections, a diagonal matrix, and\ntransvections."},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : TopologicalSpace Œ≤] {x‚ÇÄ : Œ≤}\n  (b : (a : Œ≤) ‚Üí ‚Ñù) (b_lim : Filter.Tendsto b (nhds x‚ÇÄ) (nhds 0)) (F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±)\n  (H : Filter.Eventually (fun (x : Œ≤) ‚Ü¶ ‚àÄ (i : Œπ), dist (F i x‚ÇÄ) (F i x) ‚â§ b x) (nhds x‚ÇÄ)), EquicontinuousAt F x‚ÇÄ","name":"Metric.equicontinuousAt_of_continuity_modulus","isProp":true,"docString":"For a family of functions to a (pseudo) metric spaces, a convenient way to prove\nequicontinuity at a point is to show that all of the functions share a common *local* continuity\nmodulus. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} {s : Finset Œπ} {w : (a : Œπ) ‚Üí k} (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 0)\n  (p : (a : Œπ) ‚Üí P), ‚Üë(Finset.weightedVSub s p) w ‚àà vectorSpan k (Set.range p)","name":"weightedVSub_mem_vectorSpan","isProp":true,"docString":"A `weightedVSub` with sum of weights 0 is in the `vectorSpan` of\nan indexed family. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Z : Set Œ±} {a : Set Œ±} {b : Set Œ±} (h : IsClopen Z) (cover : Z ‚äÜ a ‚à™ b)\n  (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b), IsClopen (Z ‚à© a)","name":"isClopen_inter_of_disjoint_cover_clopen","isProp":true,"docString":"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. "},{"type":"‚àÄ {Œ± : Type u} {l : List Œ±} (a : List.Nodup l), List.Nodup (List.sublists l)","name":"List.nodup.sublists","isProp":true,"docString":"**Alias** of the reverse direction of `List.nodup_sublists`."},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú) (i : Fin r ‚äï Unit) {k : ‚Ñï}\n  (hk : k ‚â§ r),\n  Matrix.mul (List.prod (List.drop k (Matrix.Pivot.listTransvecCol M))) M (Sum.inr ()) i = M (Sum.inr ()) i","name":"Matrix.Pivot.listTransvecCol_mul_last_row_drop","isProp":true,"docString":"Multiplying by some of the matrices in `listTransvecCol M` does not change the last row. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {t : Set Œ±} (a : BddBelow s) (a : BddBelow t)\n  (a : Set.Nonempty (s ‚à© t)), inf‚Çõ s ‚äî inf‚Çõ t ‚â§ inf‚Çõ (s ‚à© t)","name":"le_cinf‚Çõ_inter","isProp":true,"docString":"The infimum of an intersection of two sets is bounded below by the maximum of the\ninfima of each set, if all sets are bounded below and nonempty."},{"type":"‚àÄ {G : Type u_1} [inst : AddCommGroup G] (K : AddSubgroup G) (g : Multiset G) (a : ‚àÄ (a : G) (a_1 : a ‚àà g), a ‚àà K),\n  Multiset.sum g ‚àà K","name":"AddSubgroup.multiset_sum_mem","isProp":true,"docString":"Sum of a multiset of elements in an `AddSubgroup` of an `AddCommGroup` is in\nthe `AddSubgroup`."},{"type":"‚àÄ {K : Type u} [inst : Field K] {s : Set K}, s ‚äÜ ‚Üë(Subfield.closure s)","name":"Subfield.subset_closure","isProp":true,"docString":"The subfield generated by a set includes the set. "},{"type":"‚àÄ {K : Type u} [self : DivisionRing K] (a : K) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"DivisionRing.mul_inv_cancel","isProp":true,"docString":"For a nonzero `a`, `a‚Åª¬π` is a right multiplicative inverse. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedField Œ±] (n : ‚Ñï) (a : Œ±),\n  LinearOrderedField.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedField.zpow (Int.ofNat n) a","name":"LinearOrderedField.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ (v : PrimeMultiset), PNat.factorMultiset (PrimeMultiset.prod v) = v","name":"PrimeMultiset.factorMultiset_prod","isProp":true,"docString":"If we start with a multiset of primes, take the product and\nthen factor it, we get back the original multiset. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {s : Set E}\n  {x : E} (hx : x ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) s),\n  ‚àÉ (Œπ : Type u),\n    ‚àÉ (x_1 : Fintype Œπ),\n      ‚àÉ (z : (a : Œπ) ‚Üí E),\n        ‚àÉ (w : (a : Œπ) ‚Üí ùïú),\n          ‚àÉ (x_2 : Set.range z ‚äÜ s),\n            ‚àÉ (x_3 : AffineIndependent ùïú z),\n              ‚àÉ (x_4 : ‚àÄ (i : Œπ), 0 < w i),\n                ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ w i) = 1 : Prop) ‚àß\n                  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ z i) = x : Prop)","name":"eq_pos_convex_span_of_mem_convexHull","isProp":true,"docString":"A more explicit version of `convexHull_eq_union`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : CompleteLattice Œ±] (f : (a : Œπ) ‚Üí Œ±),\n  (sup·µ¢ fun (i : { i : Œπ // f i ‚â† ‚ä• }) ‚Ü¶ f ‚Üëi) = sup·µ¢ fun (i : Œπ) ‚Ü¶ f i","name":"sup·µ¢_ne_bot_subtype","isProp":true,"docString":"When taking the supremum of `f : Œπ ‚Üí Œ±`, the elements of `Œπ` on which `f` gives `‚ä•` can be\ndropped, without changing the result. "},{"type":"‚àÄ {S‚ÇÄ : Type u} [self : SemigroupWithZero S‚ÇÄ] (a : S‚ÇÄ), 0 * a = 0","name":"SemigroupWithZero.zero_mul","isProp":true,"docString":"Zero is a left absorbing element for multiplication "},{"type":"‚àÄ {Œ± : Type u} {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} [inst : Preorder Œ±] (hca : c ‚â§ a) (hbd : b ‚â§ d) (a : a ‚â§ b), c ‚â§ d","name":"le_implies_le_of_le_of_le","isProp":true,"docString":"monotonicity of `‚â§` with respect to `‚Üí` "},{"type":"‚àÄ {R : Type v} [inst : CommRing R] (A : Matrix (Fin 1) (Fin 1) R), Matrix.det A = A 0 0","name":"Matrix.det_fin_one","isProp":true,"docString":"Determinant of 1x1 matrix "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : (a : Œ≤) ‚Üí Œ≥} {s : Set Œ≤}\n  (h : s ‚äÜ LocalEquiv.target (LocalHomeomorph.toLocalEquiv e)),\n  (ContinuousOn f s : Prop) ‚Üî\n    (ContinuousOn (f ‚àò ‚Üëe) (LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© ‚Üëe ‚Åª¬π' s) : Prop)","name":"LocalHomeomorph.continuousOn_iff_continuousOn_comp_right","isProp":true,"docString":"A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. "},{"type":"‚àÄ {E : Type u_1} {Œ≤ : Type u_2} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E] [inst_2 : Module ‚Ñù E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] [inst_5 : OrderedAddCommGroup Œ≤] [inst_6 : Module ‚Ñù Œ≤]\n  [inst_7 : OrderedSMul ‚Ñù Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤} {a : E} (a_in_s : a ‚àà s) (h_localmin : IsLocalMinOn f s a)\n  (h_conv : ConvexOn ‚Ñù s f), IsMinOn f s a","name":"IsMinOn.of_isLocalMinOn_of_convexOn","isProp":true,"docString":"A local minimum of a convex function is a global minimum, restricted to a set `s`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}\n  (H :\n    ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s),\n      ‚àÉ (t : Set Œ±), (t ‚äÜ s : Prop) ‚àß ((x ‚àà t : Prop) ‚àß ((y ‚àà t : Prop) ‚àß (IsPreconnected t : Prop) : Prop) : Prop)),\n  IsPreconnected s","name":"isPreconnected_of_forall_pair","isProp":true,"docString":"If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (h : Function.Injective f) (s : Set Œ±), Set.InjOn f s","name":"Function.Injective.injOn","isProp":true,"docString":"**Alias** of `Set.injOn_of_injective`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CanonicallyLinearOrderedAddMonoid Œ±] [inst_1 : Sub Œ±] [inst_2 : OrderedSub Œ±] {a : Œ±} {b : Œ±}\n  {c : Œ±} [inst_3 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (h : b ‚â§ a), (a - b < a - c : Prop) ‚Üî (c < b : Prop)","name":"tsub_lt_tsub_iff_left_of_le","isProp":true,"docString":"See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order. "},{"type":"‚àÄ {Œ± : Type u_1} [self : StrictOrderedCommRing Œ±] (a : Œ±) (b : Œ±), a * b = b * a","name":"StrictOrderedCommRing.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (h : Set.Finite s), { x : Œ± // x ‚àà Set.Finite.toFinset h } = ‚Üës","name":"Set.Finite.coeSort_toFinset","isProp":true,"docString":"Note that this is an equality of types not holding definitionally. Use wisely. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (r : k) (p‚ÇÅ : P) (p‚ÇÇ : P), ‚Üë(AffineMap.lineMap p‚ÇÇ p‚ÇÅ) r ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ}","name":"AffineMap.lineMap_rev_mem_affineSpan_pair","isProp":true,"docString":"A combination of two points expressed with `lineMap` (with the two points reversed) lies in\ntheir affine span. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (-a < 0 : Prop) ‚Üî (0 < a : Prop)","name":"Left.neg_neg_iff","isProp":true,"docString":"Uses `left` co(ntra)variant."},{"type":"‚àÄ {Œ± : Type u_1} {l : Filter Œ±} [inst : Filter.IsCountablyGenerated l], Filter.IsCountablyGenerated (nhds l)","name":"Filter.instIsCountablyGeneratedFilterNhds","isProp":true,"docString":"Neighborhoods of a countably generated filter is a countably generated filter. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {k : Set G}, k ‚äÜ ‚Üë(AddSubgroup.closure k)","name":"AddSubgroup.subset_closure","isProp":true,"docString":"The `AddSubgroup` generated by a set includes the set."},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] {s : Set M}, s ‚äÜ ‚Üë(Submonoid.closure s)","name":"Submonoid.subset_closure","isProp":true,"docString":"The submonoid generated by a set includes the set. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {d : Con M},\n  (‚àÄ (x : M) (y : M), (‚Üëc x y : Prop) ‚Üî (‚Üëd x y : Prop) : Prop) ‚Üî (c = d : Prop)","name":"Con.ext_iff","isProp":true,"docString":"Iff version of extensionality rule for congruence relations. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NontriviallyNormedField Œ±], ‚àÉ (x : Œ±), 1 < ‚Äñx‚Äñ","name":"NontriviallyNormedField.non_trivial","isProp":true,"docString":"The norm attains a value exceeding 1. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {I : Ideal R}\n  {N : Submodule R M} {x : M} (hx : x ‚àà I ‚Ä¢ N) {p : (x : M) ‚Üí (a : x ‚àà I ‚Ä¢ N) ‚Üí Prop}\n  (Hb :\n    ‚àÄ (r : R) (hr : r ‚àà I) (n : M) (hn : n ‚àà N),\n      p (r ‚Ä¢ n) ((Submodule.smul_mem_smul hr hn=:r ‚Ä¢ n ‚àà I ‚Ä¢ N)=:r ‚Ä¢ n ‚àà I ‚Ä¢ N))\n  (H1 :\n    ‚àÄ (x : M) (hx : x ‚àà I ‚Ä¢ N) (y : M) (hy : y ‚àà I ‚Ä¢ N) (a : p x hx) (a : p y hy),\n      p (x + y) ((Submodule.add_mem (I ‚Ä¢ N) hx hy=:x + y ‚àà I ‚Ä¢ N)=:x + y ‚àà I ‚Ä¢ N)),\n  p x hx","name":"Submodule.smul_induction_on'","isProp":true,"docString":"Dependent version of `Submodule.smul_induction_on`. "},{"type":"‚àÄ {I : Type u} {f : (a : I) ‚Üí Type v‚ÇÅ} [inst : DecidableEq I] [inst_1 : (i : I) ‚Üí One (f i)] {i : I} {i' : I}\n  (h : i ‚â† i') (x : f i), Pi.mulSingle i x i' = 1","name":"Pi.mulSingle_eq_of_ne'","isProp":true,"docString":"Abbreviation for `mulSingle_eq_of_ne h.symm`, for ease of use by `simp`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] [inst_1 : DecidableEq Œ±] (s : Finset Œ±) {f : (a : Œ±) ‚Üí Œ≤} {a : Œ±}\n  (h : f a = 1), (Finset.prod (Finset.erase s a) fun (x : Œ±) ‚Ü¶ f x) = Finset.prod s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.prod_erase","isProp":true,"docString":"If a function applied at a point is 1, a product is unchanged by\nremoving that point, if present, from a `Finset`. "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddCommMonoid N] {f : Œ± ‚Üí‚ÇÄ M}\n  {g : Œ± ‚Üí‚ÇÄ M} {h : (a : Œ±) ‚Üí (a : M) ‚Üí N} (h_zero : ‚àÄ (a : Œ±), h a 0 = 0)\n  (h_add : ‚àÄ (a : Œ±) (b‚ÇÅ : M) (b‚ÇÇ : M), h a (b‚ÇÅ + b‚ÇÇ) = h a b‚ÇÅ + h a b‚ÇÇ),\n  Finsupp.sum (f + g) h = Finsupp.sum f h + Finsupp.sum g h","name":"Finsupp.sum_add_index'","isProp":true,"docString":"Taking the sum under `h` is an additive homomorphism of finsupps,if `h` is an additive\nhomomorphism. This is a more specific version of `finsupp.sum_add_index` with simpler\nhypotheses."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤]\n  (f : (a : Œ±) ‚Üí Œ≤) {w : (a : Œ±) ‚Üí M} {b : M} [inst_3 : LinearOrderedCancelAddCommMonoid M]\n  (hb : Fintype.card Œ≤ ‚Ä¢ b < Finset.sum Finset.univ fun (x : Œ±) ‚Ü¶ w x),\n  ‚àÉ (y : Œ≤), b < Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ) fun (x : Œ±) ‚Ü¶ w x","name":"Fintype.exists_lt_sum_fiber_of_nsmul_lt_sum","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons of different weights, strict inequality\nversion: there is a pigeonhole with the total weight of pigeons in it greater than `b` provided that\nthe total number of pigeonholes times `b` is less than the total weight of all pigeons. "},{"type":"‚àÄ (k : Type u_1) [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ),\n  Finset.centroidWeights k s = Function.const Œπ (‚Üë(Finset.card s))‚Åª¬π","name":"Finset.centroidWeights_eq_const","isProp":true,"docString":"`centroidWeights` equals a constant function. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (Œ¥ : ‚Ñù) {E‚ÇÅ : Set Œ±} {E‚ÇÇ : Set Œ±} (h : E‚ÇÅ ‚äÜ E‚ÇÇ),\n  Metric.thickening Œ¥ E‚ÇÅ ‚äÜ Metric.thickening Œ¥ E‚ÇÇ","name":"Metric.thickening_subset_of_subset","isProp":true,"docString":"The (open) thickening `Metric.thickening Œ¥ E` with a fixed thickening radius `Œ¥` is\nan increasing function of the subset `E`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} (ne : Set.Nonempty s), EMetric.hausdorffEdist s ‚àÖ = ‚ä§","name":"EMetric.hausdorffEdist_empty","isProp":true,"docString":"The Haudorff edistance to the empty set is infinite "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type u_1} {œÉ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÉ i)]\n  [inst_1 : TopologicalSpace Œ±] {f : (a : Sigma œÉ) ‚Üí Œ±}\n  (hf : ‚àÄ (i : Œπ), Continuous fun (a : œÉ i) ‚Ü¶ f { fst := i, snd := a }), Continuous f","name":"continuous_sigma","isProp":true,"docString":"A map out of a sum type is continuous if its restriction to each summand is. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Preorder M] [inst_1 : Add M] [inst_2 : Sub M] [inst_3 : OrderedSub M]\n  [inst_4 : PartialOrder N] [inst_5 : Add N] [inst_6 : Sub N] [inst_7 : OrderedSub N] (e : M ‚âÉo N)\n  (h_add : ‚àÄ (a : M) (b : M), ‚Üëe (a + b) = ‚Üëe a + ‚Üëe b) (a : M) (b : M), ‚Üëe (a - b) = ‚Üëe a - ‚Üëe b","name":"OrderIso.map_tsub","isProp":true,"docString":"An order isomorphism between types with ordered subtraction preserves subtraction provided that\nit preserves addition. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 < a) (hb : 1 < b), 1 < a * b","name":"Left.one_lt_mul'","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul'`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C)\n  [inst_3 : CategoryTheory.Limits.HasBinaryBiproduct X Y],\n  CategoryTheory.IsPushout CategoryTheory.Limits.biprod.inr 0 CategoryTheory.Limits.biprod.fst 0","name":"CategoryTheory.IsPushout.inr_fst","isProp":true,"docString":"The square\n```\n  Y --inr--> X ‚äû Y\n  |            |\n  0           fst\n  |            |\n  v            v\n  0 ---0-----> X\n```\nis a pushout square.\n"},{"type":"‚àÄ {G : Type u_2} {P : Type u_1} [inst : AddGroup G] [T : AddTorsor G P] (p : P), Function.Injective fun (x : P) ‚Ü¶ p -·µ• x","name":"vsub_right_injective","isProp":true,"docString":"Subtracting a point from the point `p` is an injective\nfunction. "},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (h : ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ ‚¶Éz : Œ±‚¶Ñ (a : x < y) (a : y < z), False), Finite Œ±","name":"Finite.of_forall_not_lt_lt","isProp":true,"docString":"If a linear order does not contain any triple of elements `x < y < z`, then this type\nis finite. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} (d : (a : ‚Ñï) ‚Üí ENNReal)\n  (hf : ‚àÄ (n : ‚Ñï), edist (f n) (f (Nat.succ n)) ‚â§ d n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a)),\n  edist (f 0) a ‚â§ tsum fun (m : ‚Ñï) ‚Ü¶ d m","name":"edist_le_tsum_of_edist_le_of_tendsto‚ÇÄ","isProp":true,"docString":"If `edist (f n) (f (n+1))` is bounded above by a function `d : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû`,\nthen the distance from `f 0` to the limit is bounded by `‚àë'_{k=0}^‚àû d k`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : GeneralizedHeytingAlgebra Œ±] (a : Œ±), a ‚â§ ‚ä§","name":"GeneralizedHeytingAlgebra.le_top","isProp":true,"docString":"`‚ä§` is a greatest element "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : Zero G‚ÇÄ] [inst_1 : Inv G‚ÇÄ] [inst_2 : TopologicalSpace G‚ÇÄ] [self : HasContinuousInv‚ÇÄ G‚ÇÄ]\n  ‚¶Éx : G‚ÇÄ‚¶Ñ (a : x ‚â† 0), ContinuousAt Inv.inv x","name":"HasContinuousInv‚ÇÄ.continuousAt_inv‚ÇÄ","isProp":true,"docString":"The map `fun x ‚Ü¶ x‚Åª¬π` is continuous at all nonzero points. "},{"type":"‚àÄ {R : Type u_3} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {Œπ : Type u_1}\n  {f : (a : Œπ) ‚Üí M} (hf : Function.Injective f) (a : LinearIndependent R Subtype.val), LinearIndependent R f","name":"LinearIndependent.of_subtype_range","isProp":true,"docString":"**Alias** of the forward direction of `linearIndependent_subtype_range`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasProducts C] {Œπ : Type v}\n  {B : (a : Œπ) ‚Üí C} (hB : ‚àÄ (A : C), ‚àÉ (i : Œπ), Nonempty (B i ‚ü∂ A)), ‚àÉ (T : C), ‚àÄ (X : C), Nonempty (T ‚ü∂ X)","name":"CategoryTheory.has_weakly_initial_of_weakly_initial_set_and_hasProducts","isProp":true,"docString":"If `C` has (small) products and a small weakly initial set of objects, then it has a weakly initial\nobject.\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (n : ‚Ñï) (a : Œ±),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"LinearOrderedCommGroupWithZero.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u_1} {s : Multiset Œ±} {t : Multiset Œ±} (a : s ‚â§ t), s ‚äÜ t","name":"Multiset.Le.subset","isProp":true,"docString":"**Alias** of `Multiset.subset_of_le`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (ha : a < 0) (hb : b ‚â§ 0), a + b < 0","name":"Right.add_neg_of_neg_of_nonpos","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg_of_neg_of_nonpos`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : PredOrder Œ±] {a : Œ±} (a_1 : a ‚â§ PredOrder.pred a), IsMin a","name":"PredOrder.min_of_le_pred","isProp":true,"docString":"Proof of interaction between `pred` and minimal element"},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œπ : Type u_1} {m : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} [inst : Countable Œπ]\n  (t : (a : Œπ) ‚Üí Set Œ±) (htm : ‚àÄ (i : Œπ), MeasurableSet (t i)) (f : (i : Œπ) ‚Üí (a : ‚Üë(t i)) ‚Üí Œ≤)\n  (hfm : ‚àÄ (i : Œπ), Measurable (f i))\n  (hf :\n    ‚àÄ (i : Œπ) (j : Œπ) (x : Œ±) (hxi : x ‚àà t i) (hxj : x ‚àà t j),\n      f i { val := x, property := hxi } = f j { val := x, property := hxj })\n  (htU : (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ t i) = Set.univ), Measurable (Set.liftCover t f hf htU)","name":"measurable_liftCover","isProp":true,"docString":"Let `t i` be a countable covering of `Œ±` by measurable sets. Let `f i : t i ‚Üí Œ≤` be a family of\nfunctions that agree on the intersections `t i ‚à© t j`. Then the function `Set.liftCover t f _ _`,\ndefined as `f i ‚ü®x, hx‚ü©` for `hx : x ‚àà t i`, is measurable. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : StrictMono f),\n  StrictAnti (‚ÜëOrderDual.toDual ‚àò f)","name":"StrictMono.dual_right","isProp":true,"docString":"**Alias** of the reverse direction of `strictAnti_toDual_comp_iff`."},{"type":"‚àÄ {G : Type u} [inst : Mul G] [self : IsRightCancelMul G] (a : G) (b : G) (c : G) (a_1 : a * b = c * b), a = c","name":"IsRightCancelMul.mul_right_cancel","isProp":true,"docString":"Multiplication is right cancellative. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 : AffineSubspace k P) (s2 : AffineSubspace k P),\n  (¬¨(s1 ‚â§ s2 : Prop) : Prop) ‚Üî (‚àÉ (p : P), (p ‚àà s1 : Prop) ‚àß (¬¨(p ‚àà s2 : Prop) : Prop) : Prop)","name":"AffineSubspace.not_le_iff_exists","isProp":true,"docString":"One subspace is not less than or equal to another if and only if it has a point not in the\nsecond subspace. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {l : Filter Œ±} {a : Œ±}\n  (a_1 : IsMaxFilter (‚ÜëOrderDual.toDual ‚àò f) l a), IsMinFilter f l a","name":"IsMaxFilter.undual","isProp":true,"docString":"**Alias** of the forward direction of `isMaxFilter_dual_iff`."},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {c : AddCon M} {f : M ‚Üí+ P}\n  (H : c ‚â§ AddCon.ker f) (x : M), ‚Üë(AddCon.lift c f H) (‚Üë(AddCon.mk' c) x) = ‚Üëf x","name":"AddCon.lift_mk'","isProp":true,"docString":"The diagram describing the universal property for quotients of `AddMonoid`s\ncommutes."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (h : a < b),\n  Finset.Ioc a b =\n    Finset.cons b (Finset.Ioo a b)\n      ((Finset.right_not_mem_Ioo=:¬¨(b ‚àà Finset.Ioo a b : Prop))=:¬¨(b ‚àà Finset.Ioo a b : Prop))","name":"Finset.Ioc_eq_cons_Ioo","isProp":true,"docString":"`Finset.cons` version of `Finset.Ioo_insert_right`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (Cf : ContinuousAt f (sup‚Çõ s)) (Af : Antitone f) (fbot : f ‚ä• = ‚ä§), f (sup‚Çõ s) = inf‚Çõ (f '' s)","name":"Antitone.map_sup‚Çõ_of_continuousAt","isProp":true,"docString":"An antitone function `f` sending `bot` to `top` and continuous at the supremum of a set sends\nthis supremum to the infimum of the image of this set. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : Norm E] {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} (a : f =o[l] u),\n  f =o[l] fun (x : Œ±) ‚Ü¶ abs (u x)","name":"Asymptotics.IsLittleO.abs_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_abs_right`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Metric.hausdorffDist s s = 0","name":"Metric.hausdorffDist_self_zero","isProp":true,"docString":"The Hausdorff distance between a set and itself is zero "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Bot Œ±] [inst_1 : Bot Œ≤] (self : BotHom Œ± Œ≤), BotHom.toFun self ‚ä• = ‚ä•","name":"BotHom.map_bot'","isProp":true,"docString":"The function preserves the bottom element. The preferred spelling is `map_bot`. "},{"type":"‚àÄ {R : Type u_2} {G : Type u_1} [inst : Group G] [inst_1 : MulAction G R] (g : G), IsSMulRegular R g","name":"isSMulRegular_of_group","isProp":true,"docString":"An element of a group acting on a Type is regular. This relies on the availability\nof the inverse given by groups, since there is no `LeftCancelSMul` typeclass. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [self : IsCompactlyGenerated Œ±] (x : Œ±),\n  ‚àÉ (s : Set Œ±), (‚àÄ (x : Œ±) (a : x ‚àà s), CompleteLattice.IsCompactElement x : Prop) ‚àß (sup‚Çõ s = x : Prop)","name":"IsCompactlyGenerated.exists_sup‚Çõ_eq","isProp":true,"docString":"In a compactly generated complete lattice,\nevery element is the `sup‚Çõ` of some set of compact elements. "},{"type":"‚àÄ {a : Prop} {b : Prop} {c : Prop},\n  (((a : Prop) ‚à® (b : Prop) : Prop) ‚àß (c : Prop) : Prop) ‚Üî\n    (((a : Prop) ‚àß (c : Prop) : Prop) ‚à® ((b : Prop) ‚àß (c : Prop) : Prop) : Prop)","name":"or_and_right","isProp":true,"docString":"`‚àß` distributes over `‚à®` (on the right). "},{"type":"‚àÄ {n : ‚Ñï} {Œ≤ : Type u_1} [inst : CommMonoid Œ≤] (f : (a : ‚Ñï) ‚Üí Œ≤),\n  (Finsupp.prod (Nat.factorization n) fun (p : ‚Ñï) (x : ‚Ñï) ‚Ü¶ f p) =\n    Finset.prod (List.toFinset (Nat.factors n)) fun (p : ‚Ñï) ‚Ü¶ f p","name":"Nat.prod_factorization_eq_prod_factors","isProp":true,"docString":"If a product over `n.factorization` doesn't use the multiplicities of the prime factors\nthen it's equal to the corresponding product over `n.factors.toFinset` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] (a : Œ±), Filter.atTop = Filter.comap Subtype.val Filter.atTop","name":"Filter.atTop_Ioi_eq","isProp":true,"docString":"The `atTop` filter for an open interval `Ioi a` comes from the `atTop` filter in the ambient\norder. "},{"type":"‚àÄ {Œ± : Sort u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (self : Equivalence r) (x : Œ±), r x x","name":"Equivalence.refl","isProp":true,"docString":"An equivalence relation is reflexive: `x ~ x` "},{"type":"‚àÄ {R : Type u_1} {Œπ : Type u_2} {Œπ' : Type u_3} [inst : NormedRing R] [inst_1 : CompleteSpace R] {f : (a : Œπ) ‚Üí R}\n  {g : (a : Œπ') ‚Üí R} (hf : Summable fun (x : Œπ) ‚Ü¶ ‚Äñf x‚Äñ) (hg : Summable fun (x : Œπ') ‚Ü¶ ‚Äñg x‚Äñ),\n  ((tsum fun (x : Œπ) ‚Ü¶ f x) * tsum fun (y : Œπ') ‚Ü¶ g y) = tsum fun (z : Œπ √ó Œπ') ‚Ü¶ f (Prod.fst z) * g (Prod.snd z)","name":"tsum_mul_tsum_of_summable_norm","isProp":true,"docString":"Product of two infinites sums indexed by arbitrary types.\nSee also `tsum_mul_tsum` if `f` and `g` are *not* absolutely summable. "},{"type":"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis (setOf fun (s : Set H) ‚Ü¶ IsClopen s)","name":"loc_compact_Haus_tot_disc_of_zero_dim","isProp":true,"docString":"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. "},{"type":"‚àÄ (b : ‚Ñï) (h : 2 ‚â§ b) (f : ‚Ñï) (n : ‚Ñï) (e : ‚Ñï) (hlt : n < b ^ e) (h_e_pos : 0 < e),\n  List.length (Nat.toDigitsCore b f n []) ‚â§ e","name":"Nat.to_digits_core_length","isProp":true,"docString":"The String representation produced by toDigitsCore has the proper length relative to\nthe number of digits in `n < e` for some base `b`. Since this works with any base greater\nthan one, it can be used for binary, decimal, and hex. "},{"type":"‚àÄ {ùìï : Type u_1} {E : Type u_2} {F : Type u_3} [inst : SeminormedAddGroup E] [inst_1 : SeminormedAddGroup F]\n  [inst_2 : AddMonoidHomClass ùìï E F] (f : ùìï) (C : ‚Ñù) (h : ‚àÄ (x : E), ‚Äñ‚Üëf x‚Äñ ‚â§ C * ‚Äñx‚Äñ), Continuous ‚Üëf","name":"AddMonoidHomClass.continuous_of_bound","isProp":true,"docString":"A homomorphism `f` of seminormed groups is continuous, if there exists a constant `C`\nsuch that for all `x`, one has `‚Äñf x‚Äñ ‚â§ C * ‚Äñx‚Äñ`"},{"type":"‚àÄ (V : Type u_2) {P : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : PseudoMetricSpace P]\n  [inst_2 : NormedAddTorsor V P] (x : P) (y : P), dist x y = ‚Äñx -·µ• y‚Äñ","name":"dist_eq_norm_vsub","isProp":true,"docString":"The distance equals the norm of subtracting two points. In this\nlemma, it is necessary to have `V` as an explicit argument; otherwise\n`rw dist_eq_norm_vsub` sometimes doesn't work. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : Nonempty Œπ] (s : Set Œ±) (f : (a : Œ±) ‚Üí Œπ),\n  (Set.Pairwise s fun (x : Œ±) (y : Œ±) ‚Ü¶ f x = f y : Prop) ‚Üî (‚àÉ (z : Œπ), ‚àÄ (x : Œ±) (a : x ‚àà s), f x = z : Prop)","name":"Set.pairwise_eq_iff_exists_eq","isProp":true,"docString":"A function `f : Œ± ‚Üí Œπ` with nonempty codomain takes pairwise equal values on a set `s` if and\nonly if for some `z` in the codomain, `f` takes value `z` on all `x ‚àà s`. See also\n`Set.Nonempty.pairwise_eq_iff_exists_eq` for a version that assumes `Set.Nonempty s` instead of\n`[Nonempty Œπ]`. "},{"type":"‚àÄ (R : Type u) (M : Type v) [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Finite R M], Module.rank R M < Cardinal.aleph0","name":"FiniteDimensional.rank_lt_aleph0","isProp":true,"docString":"The rank of a finite module is finite. "},{"type":"‚àÄ {Œ± : Type u_3} [inst : Lattice Œ±] [inst_1 : IsModularLattice Œ±] {Œ≤ : Type u_1} {Œ≥ : Type u_2}\n  [inst_2 : PartialOrder Œ≤] [inst_3 : Preorder Œ≥] (h‚ÇÅ : WellFounded fun (x : Œ≤) (x_1 : Œ≤) ‚Ü¶ x < x_1)\n  (h‚ÇÇ : WellFounded fun (x : Œ≥) (x_1 : Œ≥) ‚Ü¶ x < x_1) (K : Œ±) (f‚ÇÅ : (a : Œ≤) ‚Üí Œ±) (f‚ÇÇ : (a : Œ±) ‚Üí Œ≤) (g‚ÇÅ : (a : Œ≥) ‚Üí Œ±)\n  (g‚ÇÇ : (a : Œ±) ‚Üí Œ≥) (gci : GaloisCoinsertion f‚ÇÅ f‚ÇÇ) (gi : GaloisInsertion g‚ÇÇ g‚ÇÅ) (hf : ‚àÄ (a : Œ±), f‚ÇÅ (f‚ÇÇ a) = a ‚äì K)\n  (hg : ‚àÄ (a : Œ±), g‚ÇÅ (g‚ÇÇ a) = a ‚äî K), WellFounded fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1","name":"wellFounded_lt_exact_sequence","isProp":true,"docString":"A generalization of the theorem that if `N` is a submodule of `M` and\n`N` and `M / N` are both Artinian, then `M` is Artinian. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {S : Type w} [inst_1 : CategoryTheory.SmallCategory S] (e : C ‚âå S),\n  CategoryTheory.EssentiallySmall C","name":"CategoryTheory.EssentiallySmall.mk'","isProp":true,"docString":"Constructor for `EssentiallySmall C` from an explicit small category witness. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Œπ : Type u_4} {M‚ÇÇ : Type u_5} [inst_5 : AddCommMonoid M‚ÇÇ]\n  [inst_6 : Module R M‚ÇÇ] {M‚ÇÉ : Type u_6} [inst_7 : AddCommMonoid M‚ÇÉ] [inst_8 : Module R M‚ÇÉ] (f : AlternatingMap R M N Œπ)\n  (g‚ÇÅ : M‚ÇÇ ‚Üí‚Çó[R] M) (g‚ÇÇ : M‚ÇÉ ‚Üí‚Çó[R] M‚ÇÇ),\n  AlternatingMap.compLinearMap (AlternatingMap.compLinearMap f g‚ÇÅ) g‚ÇÇ =\n    AlternatingMap.compLinearMap f (LinearMap.comp g‚ÇÅ g‚ÇÇ)","name":"AlternatingMap.compLinearMap_assoc","isProp":true,"docString":"Composing an alternating map twice with the same linear map in each argument is\nthe same as composing with their composition. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : AddZeroClass Œ±]\n  [inst_3 : AddZeroClass Œ≤] (self : Œ± ‚Üí+o Œ≤), Monotone (ZeroHom.toFun ‚Üë(OrderAddMonoidHom.toAddMonoidHom self))","name":"OrderAddMonoidHom.monotone'","isProp":true,"docString":"An `OrderAddMonoidHom` is a monotone function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a ‚â§ 1) (hb : b ‚â§ 1), a * b ‚â§ 1","name":"Left.mul_le_one","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_le_one`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] {a : Œ±} {f : Multiset Œ±} (ha : Irreducible a)\n  (pfa : (‚àÄ (b : Œ±) (a : b ‚àà f), Prime b : Prop) ‚àß (Associated (Multiset.prod f) a : Prop)),\n  ‚àÉ (p : Œ±), (Associated a p : Prop) ‚àß (f = {p} : Prop)","name":"prime_factors_irreducible","isProp":true,"docString":"If an irreducible has a prime factorization,\nthen it is an associate of one of its prime factors. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} {r : ‚Ñö} (hqr : q + r ‚â† 0),\n  min (padicValRat p q) (padicValRat p r) ‚â§ padicValRat p (q + r)","name":"padicValRat.min_le_padicValRat_add","isProp":true,"docString":"The minimum of the valuations of `q` and `r` is at most the valuation of `q + r`. "},{"type":"‚àÄ (Œ± : Type u) [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SeparableSpace Œ±] [inst : Nonempty Œ±],\n  ‚àÉ (u : (a : ‚Ñï) ‚Üí Œ±), DenseRange u","name":"TopologicalSpace.exists_dense_seq","isProp":true,"docString":"A nonempty separable space admits a sequence with dense range. Instead of running `cases` on the\nconclusion of this lemma, you might want to use `TopologicalSpace.denseSeq` and\n`TopologicalSpace.denseRange_denseSeq`.\n\nIf `Œ±` might be empty, then `TopologicalSpace.exists_countable_dense` is the main way to use\nseparability of `Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Multiset Œ±} (a : Multiset.Nodup (Multiset.powerset s)), Multiset.Nodup s","name":"Multiset.Nodup.ofPowerset","isProp":true,"docString":"**Alias** of the forward direction of `Multiset.nodup_powerset`."},{"type":"‚àÄ {n : ‚Ñï} [inst : NeZero n] {a : ‚Ñï} (h : a < n), ‚Üë‚Üëa = a","name":"Fin.val_cast_of_lt","isProp":true,"docString":"Converting an in-range number to `Fin (n + 1)` produces a result\nwhose value is the original number.  "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} {b : Œ±} (ha : 0 < a) (hb : 0 < b),\n  (a‚Åª¬π < b : Prop) ‚Üî (b‚Åª¬π < a : Prop)","name":"inv_lt","isProp":true,"docString":"In a linear ordered field, for positive `a` and `b` we have `a‚Åª¬π < b ‚Üî b‚Åª¬π < a`.\nSee also `inv_lt_of_inv_lt` for a one-sided implication with one fewer assumption. "},{"type":"‚àÄ {R : Type u_1} [inst : AddMonoid R] {a : R} {b : R} (h : b + a = 0), IsAddLeftRegular a","name":"isAddLeftRegular_of_add_eq_zero","isProp":true,"docString":"An element admitting a left additive opposite is add-left-regular."},{"type":"‚àÄ {K : Type u_2} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ]\n  [inst_2 : Nontrivial Œì‚ÇÄ] (v : Valuation K Œì‚ÇÄ) {x : K}, (‚Üëv x = 0 : Prop) ‚Üî (x = 0 : Prop)","name":"Valuation.zero_iff","isProp":true,"docString":"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. "},{"type":"‚àÄ {Œ± : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) (s : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsNonstrictStrictOrder Œ± r s]\n  {a : Œ±} {b : Œ±}, (s a b : Prop) ‚Üî ((r a b : Prop) ‚àß (¬¨(r b a : Prop) : Prop) : Prop)","name":"right_iff_left_not_left_of","isProp":true,"docString":"A version of `right_iff_left_not_left` with explicit `r` and `s`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMul R M] [self : NoZeroSMulDivisors R M]\n  {c : R} {x : M} (a : c ‚Ä¢ x = 0), (c = 0 : Prop) ‚à® (x = 0 : Prop)","name":"NoZeroSMulDivisors.eq_zero_or_eq_zero_of_smul_eq_zero","isProp":true,"docString":"If scalar multiplication yields zero, either the scalar or the vector was zero. "},{"type":"‚àÄ {K : Type v} [inst : Field K] {p : Polynomial K},\n  (Polynomial.Splits (RingHom.id K) p : Prop) ‚Üî (‚ÜëMultiset.card (Polynomial.roots p) = Polynomial.natDegree p : Prop)","name":"Polynomial.splits_iff_card_roots","isProp":true,"docString":"A polynomial splits if and only if it has as many roots as its degree. "},{"type":"‚àÄ {V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'} {f : G ‚Üíg G'} {u : V} {v : V}\n  {p : SimpleGraph.Walk G u v} (hinj : Function.Injective ‚Üëf) (a : SimpleGraph.Walk.IsTrail p),\n  SimpleGraph.Walk.IsTrail (SimpleGraph.Walk.map f p)","name":"SimpleGraph.Walk.map_isTrail_of_injective","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.Walk.map_isTrail_iff_of_injective`."},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) {x : G} (a : x ‚àà H), -x ‚àà H","name":"AddSubgroup.neg_mem","isProp":true,"docString":"An `AddSubgroup` is closed under inverse."},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤] (X : Set (C(Œ±, Œ≤) √ó C(Œ±, Œ≤))),\n  (X ‚àà ContinuousMap.compactConvergenceUniformity : Prop) ‚Üî\n    (‚àÉ (K : Set Œ±),\n        ‚àÉ (V : Set (Œ≤ √ó Œ≤)),\n          ‚àÉ (_hK : IsCompact K),\n            ‚àÉ (_hV : V ‚àà uniformity Œ≤),\n              (setOf fun (fg : C(Œ±, Œ≤) √ó C(Œ±, Œ≤)) ‚Ü¶ ‚àÄ (x : Œ±) (a : x ‚àà K), (‚Üë(Prod.fst fg) x, ‚Üë(Prod.snd fg) x) ‚àà V) ‚äÜ\n                X :\n      Prop)","name":"ContinuousMap.mem_compactConvergenceUniformity","isProp":true,"docString":"An intermediate lemma. Usually `ContinuousMap.mem_compactConvergence_entourage_iff` is more\nuseful. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±}, Nonempty ‚Üë(Set.Ici a)","name":"Set.nonempty_Ici_subtype","isProp":true,"docString":"An interval `Ici a` is nonempty. "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} {m : ‚Ñï} (v : Vector Œ± n) (w : Vector Œ± m),\n  Vector.toList (Vector.append v w) = Vector.toList v ++ Vector.toList w","name":"Vector.toList_append","isProp":true,"docString":"Appending of vectors corresponds under `toList` to appending of lists. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : (a : Œ±) ‚Üí ‚Ñù} (K : NNReal)\n  (h : ‚àÄ (x : Œ±) (y : Œ±), f x ‚â§ f y + ‚ÜëK * dist x y), LipschitzWith K f","name":"LipschitzWith.of_le_add_mul","isProp":true,"docString":"For functions to `‚Ñù`, it suffices to prove `f x ‚â§ f y + K * dist x y`; this version\nassumes `0‚â§K`. "},{"type":"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f)","name":"RingHom.ker_isPrime","isProp":true,"docString":"The kernel of a homomorphism to a domain is a prime ideal. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.MonoidalCategory C] [self : CategoryTheory.MonoidalPreadditive C] {W : C} {X : C} {Y : C}\n  {Z : C} (f : W ‚ü∂ X) (g : W ‚ü∂ X) (h : Y ‚ü∂ Z), (f + g) ‚äó h = f ‚äó h + g ‚äó h","name":"CategoryTheory.MonoidalPreadditive.add_tensor","isProp":true,"docString":"right tensoring with a morphism is compatible with addition "},{"type":"‚àÄ {M : Type u} [self : AddMonoid M] (x : M), AddMonoid.nsmul 0 x = 0","name":"AddMonoid.nsmul_zero","isProp":true,"docString":"Multiplication by `(0 : ‚Ñï)` gives `0`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±]\n  [inst_2 : OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±}\n  (hf : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l Filter.atTop),\n  Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x + g x) l Filter.atTop","name":"Filter.Tendsto.add_atTop","isProp":true,"docString":"In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`\nand `g` tends to `atTop` then `f + g` tends to `atTop`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : TopologicalSpace R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] (B : ModuleFilterBasis R M) [inst_4 : TopologicalRing R], ContinuousSMul R M","name":"ModuleFilterBasis.continuousSMul","isProp":true,"docString":"If a module is endowed with a topological structure coming from\na module filter basis then it's a topological module. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ±) ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : ContinuousAt f x),\n  ContinuousAt (fun (a : Œ±) ‚Ü¶ Prod.snd (f a)) x","name":"ContinuousAt.snd","isProp":true,"docString":"Postcomposing `f` with `Prod.snd` is continuous at `x` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonUnitalNonAssocSemiring Œ±] [inst_1 : NonUnitalNonAssocSemiring Œ≤]\n  (self : Œ± ‚Üí‚Çô+* Œ≤) (x : Œ±) (y : Œ±),\n  MulHom.toFun (NonUnitalRingHom.toMulHom self) (x + y) =\n    MulHom.toFun (NonUnitalRingHom.toMulHom self) x + MulHom.toFun (NonUnitalRingHom.toMulHom self) y","name":"NonUnitalRingHom.map_add'","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {x : M}\n  [inst_3 : NoZeroSMulDivisors R M] (h : SameRay R x (-x)), x = 0","name":"eq_zero_of_sameRay_self_neg","isProp":true,"docString":"If a vector is in the same ray as its negation, that vector is zero. "},{"type":"‚àÄ {Œπ : Type u_1} {A : (a : Œπ) ‚Üí Type u_2} [inst : AddMonoid Œπ] [self : GradedMonoid.GMonoid A] (a : GradedMonoid A),\n  a * 1 = a","name":"GradedMonoid.GMonoid.mul_one","isProp":true,"docString":"Muliplication by `one` on the right is the identity "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G) (a : Subgroup.Normal H),\n  (H = ‚ä• : Prop) ‚à® (H = ‚ä§ : Prop)","name":"IsSimpleGroup.eq_bot_or_eq_top_of_normal","isProp":true,"docString":"Any normal subgroup is either `‚ä•` or `‚ä§` "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} (self : Subgroup.IsCommutative H),\n  IsCommutative { x : G // x ‚àà H } fun (x : { x : G // x ‚àà H }) (x_1 : { x : G // x ‚àà H }) ‚Ü¶ x * x_1","name":"Subgroup.IsCommutative.is_comm","isProp":true,"docString":"`*` is commutative on `H` "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : (a : Œ±) ‚Üí Œ≤) (P : Prop) [inst : Decidable (P : Prop)] (x : Œ±) (y : Œ±),\n  f (if (P : Prop) then x else y) = if (P : Prop) then f x else f y","name":"apply_ite","isProp":true,"docString":"A function applied to a `ite` is a `ite` of that function applied to each of the branches. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\n  [inst_2 : Quiver.IsThin C] (hC : CategoryTheory.Skeletal C), CategoryTheory.Skeletal (D ‚•§ C)","name":"CategoryTheory.functor_skeletal","isProp":true,"docString":"If `C` is thin and skeletal, `D ‚•§ C` is skeletal.\n`CategoryTheory.functor_thin` shows it is thin also.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {r : Œ±} {s : Œ±},\n  (Finset.toColex {r} < Finset.toColex {s} : Prop) ‚Üî (r < s : Prop)","name":"Colex.singleton_lt_iff_lt","isProp":true,"docString":"Colex is an extension of the base ordering on Œ±. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] [inst_1 : HasDistribNeg Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚à£ b), -a ‚à£ b","name":"Dvd.dvd.neg_left","isProp":true,"docString":"**Alias** of the reverse direction of `neg_dvd`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ≤] [inst_5 : Zero Œ±] {f : (a : Œ≤) ‚Üí Œ±}\n  (hf : Continuous f) (h : HasCompactSupport f), ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f x ‚â§ f y","name":"Continuous.exists_forall_le_of_hasCompactSupport","isProp":true,"docString":"A continuous function with compact support has a global minimum."},{"type":"‚àÄ {Œπa : Type u_1} {Œπb : Type u_2} [inst : Fintype Œπa] [inst_1 : Fintype Œπb] {R' : Type u_3} {M·µ¢ : Type u_4}\n  {N‚ÇÅ : Type u_5} {N‚ÇÇ : Type u_6} [inst_2 : CommSemiring R'] [inst_3 : AddCommGroup N‚ÇÅ] [inst_4 : Module R' N‚ÇÅ]\n  [inst_5 : AddCommGroup N‚ÇÇ] [inst_6 : Module R' N‚ÇÇ] [inst_7 : AddCommMonoid M·µ¢] [inst_8 : Module R' M·µ¢]\n  [inst_9 : DecidableEq Œπa] [inst_10 : DecidableEq Œπb] (a : MultilinearMap R' (fun (x : Œπa) ‚Ü¶ M·µ¢) N‚ÇÅ)\n  (b : MultilinearMap R' (fun (x : Œπb) ‚Ü¶ M·µ¢) N‚ÇÇ),\n  MultilinearMap.domCoprod ‚Üë(‚ÜëMultilinearMap.alternatization a) ‚Üë(‚ÜëMultilinearMap.alternatization b) =\n    Finset.sum Finset.univ fun (œÉa : Equiv.Perm Œπa) ‚Ü¶\n      Finset.sum Finset.univ fun (œÉb : Equiv.Perm Œπb) ‚Ü¶\n        ‚ÜëEquiv.Perm.sign œÉa ‚Ä¢\n          ‚ÜëEquiv.Perm.sign œÉb ‚Ä¢\n            MultilinearMap.domCoprod (MultilinearMap.domDomCongr œÉa a) (MultilinearMap.domDomCongr œÉb b)","name":"MultilinearMap.domCoprod_alternization_coe","isProp":true,"docString":"A helper lemma for `MultilinearMap.domCoprod_alternization`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] [t : OrderClosedTopology Œ±]\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {b : Filter Œ≤} {a‚ÇÅ : Œ±} {a‚ÇÇ : Œ±} [inst_2 : Filter.NeBot b]\n  (hf : Filter.Tendsto f b (nhds a‚ÇÅ)) (hg : Filter.Tendsto g b (nhds a‚ÇÇ)) (h : f ‚â§·∂†[b] g), a‚ÇÅ ‚â§ a‚ÇÇ","name":"tendsto_le_of_eventuallyLE","isProp":true,"docString":"**Alias** of `le_of_tendsto_of_tendsto`."},{"type":"‚àÄ (M‚ÇÄ : Type u_1) [inst : MulZeroOneClass M‚ÇÄ] [inst_1 : Nontrivial M‚ÇÄ], NeZero 1","name":"NeZero.one","isProp":true,"docString":"In a nontrivial monoid with zero, zero and one are different. "},{"type":"‚àÄ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] (f : K ‚Üí+* L) (s : Set K),\n  Subfield.map f (Subfield.closure s) = Subfield.closure (‚Üëf '' s)","name":"RingHom.map_field_closure","isProp":true,"docString":"The image under a ring homomorphism of the subfield generated by a set equals\nthe subfield generated by the image of the set. "},{"type":"‚àÄ {V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ] (f : V‚ÇÅ ‚Üí+ V‚ÇÇ)\n  {K : NNReal} (h : LipschitzWith K ‚Üëf), ‚ÄñNormedAddGroupHom.ofLipschitz f h‚Äñ ‚â§ ‚ÜëK","name":"NormedAddGroupHom.ofLipschitz_norm_le","isProp":true,"docString":"If a bounded group homomorphism map is constructed from a group homomorphism via the constructor\n`NormedAddGroupHom.ofLipschitz`, then its norm is bounded by the bound given to the constructor. "},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±],\n  FreeAddGroup.reduce (FreeAddGroup.reduce L) = FreeAddGroup.reduce L","name":"FreeAddGroup.reduce.idem","isProp":true,"docString":"`reduce` is idempotent, i.e. the maximal reduction of the maximal\nreduction of a word is the maximal reduction of the word."},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {x : M}, 0 ‚àà multiples x","name":"multiples.zero_mem","isProp":true,"docString":"0 is in the set of natural number multiples of an element of an `AddMonoid`."},{"type":"‚àÄ {Œ± : Type u_2} {ùïú : Type u_1} {f : (a : Œ±) ‚Üí ùïú} {S : Set Œ±} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace ùïú]\n  [inst_2 : T1Space ùïú] [inst_3 : Ring ùïú] [inst_4 : NoZeroDivisors ùïú] (hS : IsPreconnected S) (hf : ContinuousOn f S)\n  (hsq : Set.EqOn (f ^ 2) 1 S), (Set.EqOn f 1 S : Prop) ‚à® (Set.EqOn f (-1) S : Prop)","name":"IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq","isProp":true,"docString":"If `f` is a function `Œ± ‚Üí ùïú` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. "},{"type":"‚àÄ {R : Type u} {Œπ : Type v} {M‚ÇÅ : (a : Œπ) ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [inst : CommSemiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] [inst_5 : (i : Œπ) ‚Üí TopologicalSpace (M‚ÇÅ i)] [inst_6 : TopologicalSpace M‚ÇÇ]\n  (f : ContinuousMultilinearMap R M‚ÇÅ M‚ÇÇ) [inst_7 : Fintype Œπ] (c : (a : Œπ) ‚Üí R) (m : (i : Œπ) ‚Üí M‚ÇÅ i),\n  (‚Üëf fun (i : Œπ) ‚Ü¶ c i ‚Ä¢ m i) = (Finset.prod Finset.univ fun (i : Œπ) ‚Ü¶ c i) ‚Ä¢ ‚Üëf m","name":"ContinuousMultilinearMap.map_smul_univ","isProp":true,"docString":"Multiplicativity of a continuous multilinear map along all coordinates at the same time,\nwriting `f (Œª i, c i ‚Ä¢ m i)` as `(‚àè i, c i) ‚Ä¢ f m`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : NormalizationMonoid Œ±] (u : Œ±À£), normUnit ‚Üëu = u‚Åª¬π","name":"NormalizationMonoid.normUnit_coe_units","isProp":true,"docString":"The proposition that `normUnit` maps units to their inverses. "},{"type":"‚àÄ (M : Type u_2) (Œ± : Type u_1) [inst : Group M] [inst_1 : MulAction M Œ±],\n  GaloisConnection (‚ÜëOrderDual.toDual ‚àò fixingSubgroup M)\n    ((fun (P : Subgroup M) ‚Ü¶ MulAction.fixedPoints { x : M // x ‚àà P } Œ±) ‚àò ‚ÜëOrderDual.ofDual)","name":"fixingSubgroup_fixedPoints_gc","isProp":true,"docString":"The Galois connection between fixing subgroups and fixed points of a group action "},{"type":"‚àÄ {K : Type u} [self : DivisionRing K] (a : ‚Ñ§) (b : ‚Ñï) (h1 : b ‚â† 0) (h2 : Nat.coprime (Int.natAbs a) b),\n  ‚Üë(Rat.mk' a b) = ‚Üëa * (‚Üëb)‚Åª¬π","name":"DivisionRing.ratCast_mk","isProp":true,"docString":"However `ratCast` is defined, propositionally it must be equal to `a * b‚Åª¬π`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A / C) * Finset.card B ‚â§ Finset.card (A / B) * Finset.card (B / C)","name":"Finset.card_div_mul_le_card_div_mul_card_div","isProp":true,"docString":"**Ruzsa's triangle inequality**. Division version. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : NoMaxOrder Œ±]\n  [inst_4 : DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±},\n  (s ‚àà nhdsWithin a (Set.Ioi a) : Prop) ‚Üî (‚àÉ (u : Œ±), (u ‚àà Set.Ioi a : Prop) ‚àß (Set.Ioc a u ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Ioi_iff_exists_Ioc_subset","isProp":true,"docString":"A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u]`\nwith `a < u`. "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {G' : SimpleGraph V} (h : G ‚â§ G') {u : V} {p : SimpleGraph.Walk G u u}\n  (a : SimpleGraph.Walk.IsCycle (SimpleGraph.Walk.mapLe h p)), SimpleGraph.Walk.IsCycle p","name":"SimpleGraph.Walk.IsCycle.of_mapLe","isProp":true,"docString":"**Alias** of the forward direction of `SimpleGraph.Walk.mapLe_isCycle`."},{"type":"‚àÄ {M : Type u} [self : LeftCancelMonoid M] (x : M), LeftCancelMonoid.npow 0 x = 1","name":"LeftCancelMonoid.npow_zero","isProp":true,"docString":"Raising to the power `(0 : ‚Ñï)` gives `1`. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] (p : (a : Œπ) ‚Üí P) {i : Œπ} {j : Œπ}\n  (hi : i ‚àà s) (hj : j ‚àà s), ‚Üë(Finset.weightedVSub s p) (Finset.weightedVSubVSubWeights k i j) = p i -·µ• p j","name":"Finset.weightedVSub_weightedVSubVSubWeights","isProp":true,"docString":"A weighted subtraction with `weightedVSubVSubWeights` gives the result of subtracting the\nspecified points. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (x : Œ±) [inst_1 : Filter.NeBot (nhdsWithin x ({x}·∂ú))], Dense ({x}·∂ú)","name":"dense_compl_singleton","isProp":true,"docString":"If `x` is not an isolated point of a topological space, then `{x}·∂ú` is dense in the whole\nspace. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : HeytingAlgebra Œ±]\n  [inst_1 : HeytingAlgebra Œ≤] [self : HeytingHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a ‚á® b) = ‚Üëf a ‚á® ‚Üëf b","name":"HeytingHomClass.map_himp","isProp":true,"docString":"The proposition that a Heyting homomorphism preserves the Heyting implication."},{"type":"‚àÄ {M‚ÇÄ : Type u} [self : MulZeroClass M‚ÇÄ] (a : M‚ÇÄ), 0 * a = 0","name":"MulZeroClass.zero_mul","isProp":true,"docString":"Zero is a left absorbing element for multiplication "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} (a : Nat.coprime m n), IsCoprime ‚Üëm ‚Üën","name":"Nat.coprime.isCoprime","isProp":true,"docString":"**Alias** of the reverse direction of `Nat.isCoprime_iff_coprime`."},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 : ‚àÄ {X : C} {Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)],\n  CategoryTheory.Limits.HasBinaryCoproducts C","name":"CategoryTheory.Limits.hasBinaryCoproducts_of_hasColimit_pair","isProp":true,"docString":"If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts "},{"type":"‚àÄ {R : Type u_1} {M : Type u_3} {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_4} [inst : Ring R] [inst_1 : Ring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  [inst_6 : RingHomSurjective œÑ‚ÇÅ‚ÇÇ] {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ}\n  (h :\n    ‚àÄ (u : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ LinearMap.range f) (v : M‚ÇÇ ‚Üí‚Çó[R‚ÇÇ] M‚ÇÇ ‚ß∏ LinearMap.range f)\n      (a : LinearMap.comp u f = LinearMap.comp v f), u = v),\n  LinearMap.range f = ‚ä§","name":"LinearMap.range_eq_top_of_cancel","isProp":true,"docString":"An epimorphism is surjective. "},{"type":"‚àÄ {Œ± : Type u_1} {m : ‚Ñï} (P : (a : (a : Fin m) ‚Üí Œ±) ‚Üí Prop),\n  (FinVec.Forall P : Prop) ‚Üî (‚àÄ (x : (a : Fin m) ‚Üí Œ±), P x : Prop)","name":"FinVec.forall_iff","isProp":true,"docString":"This can be use to prove\n```lean\nexample (P : (Fin 2 ‚Üí Œ±) ‚Üí Prop) : (‚àÄ f, P f) ‚Üî ‚àÄ a‚ÇÄ a‚ÇÅ, P ![a‚ÇÄ, a‚ÇÅ] :=\n  (forall_iff _).symm\n```\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, 0 ‚â§ Metric.diam s","name":"Metric.diam_nonneg","isProp":true,"docString":"The diameter of a set is always nonnegative "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {Œ≤ : Type u_1} [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f) (hg : Antitone g) (h : f ‚â§ g) (m : Œ±) (n : Œ±), f m ‚â§ g n","name":"Monotone.forall_le_of_antitone","isProp":true,"docString":"If `f` is monotone, `g` is antitone, and `f ‚â§ g`, then for all `a`, `b` we have `f a ‚â§ g b`. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {R : Type u_2} [inst_1 : Semiring R] [inst_2 : MulSemiringAction M R] {S : Type u_3}\n  [inst_3 : Semiring S] [inst_4 : MulSemiringAction M S] (self : R ‚Üí+*[M] S) (x : R) (y : R),\n  MulActionHom.toFun (DistribMulActionHom.toMulActionHom (MulSemiringActionHom.toDistribMulActionHom self)) (x * y) =\n    MulActionHom.toFun (DistribMulActionHom.toMulActionHom (MulSemiringActionHom.toDistribMulActionHom self)) x *\n      MulActionHom.toFun (DistribMulActionHom.toMulActionHom (MulSemiringActionHom.toDistribMulActionHom self)) y","name":"MulSemiringActionHom.map_mul'","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R] (hR : ringChar R ‚â† 2), 2 ‚â† 0","name":"Ring.two_ne_zero","isProp":true,"docString":"We have `2 ‚â† 0` in a nontrivial ring whose characteristic is not `2`. "},{"type":"‚àÄ (n : ‚Ñï),\n  Finset.univ =\n    Finset.cons 0\n      (Finset.map\n        { toFun := Fin.succ,\n          inj' := ((Fin.succ_injective n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n        Finset.univ)\n      ((of_eq_true\n            ((Eq.trans\n                  ((congrArg Not\n                        ((Eq.trans\n                              ((Eq.trans\n                                    ((Eq.trans\n                                          ((congrArg (Membership.mem 0)\n                                                ((Eq.trans\n                                                      ((Finset.map_eq_image\n                                                            { toFun := Fin.succ,\n                                                              inj' :=\n                                                                ((Fin.succ_injective\n                                                                      n=:Function.Injective\n                                                                      Fin.succ)=:Function.Injective Fin.succ) }\n                                                            Finset.univ=:Finset.map\n                                                              { toFun := Fin.succ,\n                                                                inj' :=\n                                                                  ((Fin.succ_injective\n                                                                        n=:Function.Injective\n                                                                        Fin.succ)=:Function.Injective Fin.succ) }\n                                                              Finset.univ =\n                                                            Finset.image\n                                                              (‚Üë{ toFun := Fin.succ,\n                                                                  inj' :=\n                                                                    ((Fin.succ_injective\n                                                                          n=:Function.Injective\n                                                                          Fin.succ)=:Function.Injective Fin.succ) })\n                                                              Finset.univ)=:Finset.map\n                                                            { toFun := Fin.succ,\n                                                              inj' :=\n                                                                ((Fin.succ_injective\n                                                                      n=:Function.Injective\n                                                                      Fin.succ)=:Function.Injective Fin.succ) }\n                                                            Finset.univ =\n                                                          Finset.image\n                                                            (‚Üë{ toFun := Fin.succ,\n                                                                inj' :=\n                                                                  ((Fin.succ_injective\n                                                                        n=:Function.Injective\n                                                                        Fin.succ)=:Function.Injective Fin.succ) })\n                                                            Finset.univ)\n                                                      ((Fin.image_succ_univ\n                                                            n=:Finset.image Fin.succ Finset.univ =\n                                                            {0}·∂ú)=:Finset.image Fin.succ Finset.univ =\n                                                          {0}·∂ú)=:Finset.map\n                                                        { toFun := Fin.succ,\n                                                          inj' :=\n                                                            ((Fin.succ_injective\n                                                                  n=:Function.Injective\n                                                                  Fin.succ)=:Function.Injective Fin.succ) }\n                                                        Finset.univ =\n                                                      {0}·∂ú)=:Finset.map\n                                                      { toFun := Fin.succ,\n                                                        inj' :=\n                                                          ((Fin.succ_injective\n                                                                n=:Function.Injective\n                                                                Fin.succ)=:Function.Injective Fin.succ) }\n                                                      Finset.univ =\n                                                    {0}·∂ú)=:(0 ‚àà\n                                                    Finset.map\n                                                      { toFun := Fin.succ,\n                                                        inj' :=\n                                                          ((Fin.succ_injective\n                                                                n=:Function.Injective\n                                                                Fin.succ)=:Function.Injective Fin.succ) }\n                                                      Finset.univ :\n                                                  Prop) =\n                                                (0 ‚àà {0}·∂ú :\n                                                  Prop))=:(0 ‚àà\n                                                  Finset.map\n                                                    { toFun := Fin.succ,\n                                                      inj' :=\n                                                        ((Fin.succ_injective\n                                                              n=:Function.Injective\n                                                              Fin.succ)=:Function.Injective Fin.succ) }\n                                                    Finset.univ :\n                                                Prop) =\n                                              (0 ‚àà {0}·∂ú : Prop))\n                                          ((Mathlib.Data.Fintype.Basic._auxLemma.8=:(0 ‚àà {0}·∂ú : Prop) =\n                                                (¬¨(0 ‚àà {0} : Prop) :\n                                                  Prop))=:(0 ‚àà {0}·∂ú : Prop) =\n                                              (¬¨(0 ‚àà {0} : Prop) :\n                                                Prop))=:(0 ‚àà\n                                              Finset.map\n                                                { toFun := Fin.succ,\n                                                  inj' :=\n                                                    ((Fin.succ_injective\n                                                          n=:Function.Injective\n                                                          Fin.succ)=:Function.Injective Fin.succ) }\n                                                Finset.univ :\n                                            Prop) =\n                                          (¬¨(0 ‚àà {0} : Prop) :\n                                            Prop))=:(0 ‚àà\n                                            Finset.map\n                                              { toFun := Fin.succ,\n                                                inj' :=\n                                                  ((Fin.succ_injective\n                                                        n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                                              Finset.univ :\n                                          Prop) =\n                                        (¬¨(0 ‚àà {0} : Prop) : Prop))\n                                    ((congrArg Not\n                                          ((Eq.trans\n                                                ((Mathlib.Data.Finset.Basic._auxLemma.26=:(0 ‚àà {0} : Prop) =\n                                                      (0 = 0 : Prop))=:(0 ‚àà {0} : Prop) = (0 = 0 : Prop))\n                                                ((eq_self\n                                                      0=:(0 = 0 : Prop) =\n                                                      (True :\n                                                        Prop))=:(0 = 0 : Prop) =\n                                                    (True :\n                                                      Prop))=:(0 ‚àà {0} : Prop) =\n                                                (True :\n                                                  Prop))=:(0 ‚àà {0} : Prop) =\n                                              (True :\n                                                Prop))=:(¬¨(0 ‚àà {0} : Prop) : Prop) =\n                                          (¬¨(True : Prop) :\n                                            Prop))=:(¬¨(0 ‚àà {0} : Prop) : Prop) =\n                                        (¬¨(True : Prop) :\n                                          Prop))=:(0 ‚àà\n                                        Finset.map\n                                          { toFun := Fin.succ,\n                                            inj' :=\n                                              ((Fin.succ_injective\n                                                    n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                                          Finset.univ :\n                                      Prop) =\n                                    (¬¨(True : Prop) :\n                                      Prop))=:(0 ‚àà\n                                      Finset.map\n                                        { toFun := Fin.succ,\n                                          inj' :=\n                                            ((Fin.succ_injective\n                                                  n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                                        Finset.univ :\n                                    Prop) =\n                                  (¬¨(True : Prop) : Prop))\n                              (Std.Logic._auxLemma.3=:(¬¨(True : Prop) : Prop) =\n                                  (False :\n                                    Prop))=:(0 ‚àà\n                                  Finset.map\n                                    { toFun := Fin.succ,\n                                      inj' :=\n                                        ((Fin.succ_injective\n                                              n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                                    Finset.univ :\n                                Prop) =\n                              (False :\n                                Prop))=:(0 ‚àà\n                                Finset.map\n                                  { toFun := Fin.succ,\n                                    inj' :=\n                                      ((Fin.succ_injective\n                                            n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                                  Finset.univ :\n                              Prop) =\n                            (False :\n                              Prop))=:(¬¨(0 ‚àà\n                                Finset.map\n                                  { toFun := Fin.succ,\n                                    inj' :=\n                                      ((Fin.succ_injective\n                                            n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                                  Finset.univ :\n                              Prop) :\n                          Prop) =\n                        (¬¨(False : Prop) :\n                          Prop))=:(¬¨(0 ‚àà\n                              Finset.map\n                                { toFun := Fin.succ,\n                                  inj' :=\n                                    ((Fin.succ_injective n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                                Finset.univ :\n                            Prop) :\n                        Prop) =\n                      (¬¨(False : Prop) : Prop))\n                  (not_false_eq_true=:(¬¨(False : Prop) : Prop) =\n                      (True :\n                        Prop))=:(¬¨(0 ‚àà\n                          Finset.map\n                            { toFun := Fin.succ,\n                              inj' :=\n                                ((Fin.succ_injective n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                            Finset.univ :\n                        Prop) :\n                    Prop) =\n                  (True :\n                    Prop))=:(¬¨(0 ‚àà\n                        Finset.map\n                          { toFun := Fin.succ,\n                            inj' := ((Fin.succ_injective n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                          Finset.univ :\n                      Prop) :\n                  Prop) =\n                (True :\n                  Prop))=:¬¨(0 ‚àà\n                Finset.map\n                  { toFun := Fin.succ,\n                    inj' := ((Fin.succ_injective n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                  Finset.univ :\n              Prop))=:¬¨(0 ‚àà\n              Finset.map\n                { toFun := Fin.succ,\n                  inj' := ((Fin.succ_injective n=:Function.Injective Fin.succ)=:Function.Injective Fin.succ) }\n                Finset.univ :\n            Prop))","name":"Fin.univ_succ","isProp":true,"docString":"Embed `Fin n` into `Fin (n + 1)` by prepending zero to the `univ` "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s1 : AffineSubspace k P} {s2 : AffineSubspace k P} (h : s1 ‚â§ s2),\n  AffineSubspace.direction s1 ‚â§ AffineSubspace.direction s2","name":"AffineSubspace.direction_le","isProp":true,"docString":"If one affine subspace is less than or equal to another, the same applies to their\ndirections. "},{"type":"‚àÄ (m : (a : Type u) ‚Üí Type v) [inst : Monad m] (id_map : ‚àÄ {Œ± : Type u} (x : m Œ±), id <$> x = x)\n  (pure_bind : ‚àÄ {Œ± : Type u} {Œ≤ : Type u} (x : Œ±) (f : (a : Œ±) ‚Üí m Œ≤), pure x >>= f = f x)\n  (bind_assoc :\n    ‚àÄ {Œ± : Type u} {Œ≤ : Type u} {Œ≥ : Type u} (x : m Œ±) (f : (a : Œ±) ‚Üí m Œ≤) (g : (a : Œ≤) ‚Üí m Œ≥),\n      x >>= f >>= g = x >>= fun (x : Œ±) ‚Ü¶ f x >>= g)\n  (map_const :\n    autoParam (‚àÄ {Œ± : Type u} {Œ≤ : Type u} (x : Œ±) (y : m Œ≤), Functor.mapConst x y = Function.const Œ≤ x <$> y : Prop)\n      _auto‚úù)\n  (seqLeft_eq :\n    autoParam\n      (‚àÄ {Œ± : Type u} {Œ≤ : Type u} (x : m Œ±) (y : m Œ≤),\n          (SeqLeft.seqLeft x fun (x : Unit) ‚Ü¶ y) = do\n            let a ‚Üê x\n            let _ ‚Üê y\n            pure a :\n        Prop)\n      _auto‚úù¬π)\n  (seqRight_eq :\n    autoParam\n      (‚àÄ {Œ± : Type u} {Œ≤ : Type u} (x : m Œ±) (y : m Œ≤),\n          (SeqRight.seqRight x fun (x : Unit) ‚Ü¶ y) = do\n            let _ ‚Üê x\n            y :\n        Prop)\n      _auto‚úù¬≤)\n  (bind_pure_comp :\n    autoParam\n      (‚àÄ {Œ± : Type u} {Œ≤ : Type u} (f : (a : Œ±) ‚Üí Œ≤) (x : m Œ±),\n          (do\n              let y ‚Üê x\n              pure (f y)) =\n            f <$> x :\n        Prop)\n      _auto‚úù¬≥)\n  (bind_map :\n    autoParam\n      (‚àÄ {Œ± : Type u} {Œ≤ : Type u} (f : m ((a : Œ±) ‚Üí Œ≤)) (x : m Œ±),\n          (do\n              let x_1 ‚Üê f\n              x_1 <$> x) =\n            Seq.seq f fun (x_1 : Unit) ‚Ü¶ x :\n        Prop)\n      _auto‚úù‚Å¥),\n  LawfulMonad m","name":"LawfulMonad.mk'","isProp":true,"docString":"An alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n"},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (j‚ÇÅ : J) (j‚ÇÇ : J),\n  CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ","name":"CategoryTheory.isConnected_zigzag","isProp":true,"docString":"In a connected category, any two objects are related by `zigzag`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} {p : (a : Œπ) ‚Üí P} (h : AffineIndependent k p) {w : (a : Œπ) ‚Üí k}\n  {w‚ÇÅ : (a : Œπ) ‚Üí k} {w‚ÇÇ : (a : Œπ) ‚Üí k} {s : Finset Œπ} (hw : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 0)\n  (hw‚ÇÅ : (Finset.sum s fun (i : Œπ) ‚Ü¶ w‚ÇÅ i) = 1) (hw‚ÇÇ : (Finset.sum s fun (i : Œπ) ‚Ü¶ w‚ÇÇ i) = 1),\n  (‚Üë(Finset.weightedVSub s p) w ‚àà\n        vectorSpan k {‚Üë(Finset.affineCombination k s p) w‚ÇÅ, ‚Üë(Finset.affineCombination k s p) w‚ÇÇ} :\n      Prop) ‚Üî\n    (‚àÉ (r : k), ‚àÄ (i : Œπ) (a : i ‚àà s), w i = r * (w‚ÇÅ i - w‚ÇÇ i) : Prop)","name":"weightedVSub_mem_vectorSpan_pair","isProp":true,"docString":"Given an affinely independent family of points, a weighted subtraction lies in the\n`vectorSpan` of two points given as affine combinations if and only if it is a weighted\nsubtraction with weights a multiple of the difference between the weights of the two points. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G} (a : x ‚àà H), x‚Åª¬π ‚àà H","name":"Subgroup.inv_mem","isProp":true,"docString":"A subgroup is closed under inverse. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] (l : Finset Œπ) (S : (a : Œπ) ‚Üí Set Œ±),\n  (fun (f : (a : Œπ) ‚Üí Œ±) ‚Ü¶ Finset.prod l fun (i : Œπ) ‚Ü¶ f i) '' Set.pi (‚Üël) S = Finset.prod l fun (i : Œπ) ‚Ü¶ S i","name":"Set.image_finset_prod_pi","isProp":true,"docString":"The n-ary version of `set.image_mul_prod`. "},{"type":"‚àÄ {Œ± : Type u_1} (f : (a : Œ±) ‚Üí Œ±) (x : Œ±), Function.IsPeriodicPt f 0 x","name":"Function.isPeriodicPt_zero","isProp":true,"docString":"Any point is a periodic point of period `0`. "},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} {m : ‚Ñï} (hc : c ‚â† 0) (a_1 : a * c ‚â° b * c [MOD m * c]), a ‚â° b [MOD m]","name":"Nat.ModEq.mul_right_cancel'","isProp":true,"docString":"Cancel right multiplication on both sides of the `‚â°` and in the modulus.\n\nFor cancelling right multiplication in the modulus, see `Nat.ModEq.of_mul_right`. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {f : Filter Œ±} {g : Filter Œ≤}\n  {m : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {n : (a : Œ±) ‚Üí Œ±'} {m' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {n' : (a : Œ¥) ‚Üí Œ≥}\n  (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), m (n a) b = n' (m' b a)),\n  Filter.map‚ÇÇ m (Filter.map n f) g = Filter.map n' (Filter.map‚ÇÇ m' g f)","name":"Filter.map‚ÇÇ_map_left_anticomm","isProp":true,"docString":"Symmetric statement to `Filter.map_map‚ÇÇ_antidistrib_left`. "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), Vector.toList (a ::·µ• v) = a :: Vector.toList v","name":"Vector.toList_cons","isProp":true,"docString":"`toList` of `cons` of a vector and an element is\nthe `cons` of the list obtained by `toList` and the element "},{"type":"‚àÄ {Œ± : Type u_1} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop),\n  Relation.Fibration (Prod.GameAdd (Relation.CutExpand r) (Relation.CutExpand r)) (Relation.CutExpand r)\n    fun (s : Multiset Œ± √ó Multiset Œ±) ‚Ü¶ Prod.fst s + Prod.snd s","name":"Relation.cutExpand_fibration","isProp":true,"docString":"For any relation `r` on `Œ±`, multiset addition `Multiset Œ± √ó Multiset Œ± ‚Üí Multiset Œ±` is a\nfibration between the game sum of `CutExpand r` with itself and `CutExpand r` itself. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {A : Type u} [inst_1 : TopologicalSpace A] [inst_2 : Semiring A]\n  [inst_3 : Algebra R A] [inst_4 : TopologicalSemiring A] (s : Subalgebra R A) {B : Type u_2}\n  [inst_5 : TopologicalSpace B] [inst_6 : Ring B] [inst_7 : TopologicalRing B] [inst_8 : Algebra R B] (f : B ‚Üí‚Çê[R] A)\n  (f' : B ‚âÉ‚Çú A) (w : ‚Üëf = ‚Üëf'),\n  Subalgebra.comap f (Subalgebra.topologicalClosure s) = Subalgebra.topologicalClosure (Subalgebra.comap f s)","name":"Subalgebra.topologicalClosure_comap_homeomorph","isProp":true,"docString":"This is really a statement about topological algebra isomorphisms,\nbut we don't have those, so we use the clunky approach of talking about\nan algebra homomorphism, and a separate homeomorphism,\nalong with a witness that as functions they are the same.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±}, EMetric.infEdist x (closure s) = EMetric.infEdist x s","name":"EMetric.infEdist_closure","isProp":true,"docString":"The edist to a set and to its closure coincide "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [self : IsClosed s], IsOpen (s·∂ú)","name":"IsClosed.isOpen_compl","isProp":true,"docString":"The complement of a closed set is an open set. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} [inst_4 : Fintype Œπ]\n  (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i) ‚Ä¢ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ g i) ‚â§\n    Fintype.card Œπ ‚Ä¢ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i","name":"Monovary.sum_smul_sum_le_card_smul_sum","isProp":true,"docString":"**Chebyshev's Sum Inequality**: When `f` and `g` monovary together (eg they are both\nmonotone/antitone), the scalar product of their sum is less than the size of the set times their\nscalar product. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {K : NNReal} {f : (a : Œ±) ‚Üí Œ±} (hf : ContractingWith K f) [inst_1 : Nonempty Œ±]\n  [inst_2 : CompleteSpace Œ±] (x : Œ±) (n : ‚Ñï),\n  dist ((f^[n]) x) (ContractingWith.fixedPoint f hf) ‚â§ dist ((f^[n]) x) ((f^[n + 1]) x) / (1 - ‚ÜëK)","name":"ContractingWith.aposteriori_dist_iterate_fixedPoint_le","isProp":true,"docString":"Aposteriori estimates on the convergence of iterates to the fixed point. "},{"type":"‚àÄ {B : Type u_2} {S : B} {M : Type u_1} [inst : AddCommMonoid M] [inst_1 : SetLike B M] [inst_2 : AddSubmonoidClass B M]\n  (m : Multiset M) (hm : ‚àÄ (a : M) (a_1 : a ‚àà m), a ‚àà S), Multiset.sum m ‚àà S","name":"multiset_sum_mem","isProp":true,"docString":"Sum of a multiset of elements in an `AddSubmonoid` of an `AddCommMonoid` is\nin the `AddSubmonoid`."},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Nonempty s), s ‚â† ‚àÖ","name":"Set.Nonempty.ne_empty","isProp":true,"docString":"**Alias** of the forward direction of `Set.nonempty_iff_ne_empty`."},{"type":"‚àÄ (Œ± : Type u_1) [inst : Countable Œ±], Nonempty (Encodable Œ±)","name":"nonempty_encodable","isProp":true,"docString":"See also `nonempty_fintype`, `nonempty_denumerable`. "},{"type":"‚àÄ (k : Type u_1) {V : Type u_4} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_2} [inst_4 : CharZero k] {s : Finset Œπ} (p : (a : Œπ) ‚Üí P)\n  (h : Finset.card s ‚â† 0), Finset.centroid k s p ‚àà affineSpan k (Set.range p)","name":"centroid_mem_affineSpan_of_card_ne_zero","isProp":true,"docString":"In the characteristic zero case, the centroid lies in the affine\nspan if the number of points is not zero. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {l : (a : Œ±) ‚Üí Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (self : GaloisCoinsertion l u) (a : Œ≤) (h : a ‚â§ l (u a)), GaloisCoinsertion.choice self a h = u a","name":"GaloisCoinsertion.choice_eq","isProp":true,"docString":"Property of the choice function. "},{"type":"‚àÄ {G : outParam (Type u_1)} {P : Type u_2} [inst : outParam (AddGroup G)] [self : AddTorsor G P] (p1 : P) (p2 : P),\n  p1 -·µ• p2 +·µ• p2 = p1","name":"AddTorsor.vsub_vadd'","isProp":true,"docString":"Torsor subtraction and addition with the same element cancels out. "},{"type":"‚àÄ {n : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (m : ‚Ñï) (h : a ‚â° b [MOD m * n]), a ‚â° b [MOD n]","name":"Nat.ModEq.of_mul_left","isProp":true,"docString":"Cancel left multiplication in the modulus.\n\nFor cancelling left multiplication on both sides of the `‚â°`, see `nat.modeq.mul_left_cancel'`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (K : AddSubgroup G), AddSubgroup.closure ‚ÜëK = K","name":"AddSubgroup.closure_eq","isProp":true,"docString":"Additive closure of an additive subgroup `K` equals `K`"},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R], (IsRegular 0 : Prop) ‚Üî (Subsingleton R : Prop)","name":"isRegular_iff_subsingleton","isProp":true,"docString":"The element `0` is regular if and only if `R` is trivial. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±]\n  [inst_3 : TotallyDisconnectedSpace Œ±] {x : Œ±} {U : Set Œ±} (is_open : IsOpen U) (memU : x ‚àà U),\n  ‚àÉ (V : Set Œ±), (IsClopen V : Prop) ‚àß ((x ‚àà V : Prop) ‚àß (V ‚äÜ U : Prop) : Prop)","name":"compact_exists_clopen_in_open","isProp":true,"docString":"Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set.  "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteCoproducts C]\n  [inst_2 : CategoryTheory.Limits.HasCoequalizers C], CategoryTheory.Limits.HasFiniteColimits C","name":"CategoryTheory.Limits.hasFiniteColimits_of_hasCoequalizers_and_finite_coproducts","isProp":true,"docString":"Any category with finite coproducts and coequalizers has all finite colimits.\n\nSee <https://stacks.math.columbia.edu/tag/002Q>.\n"},{"type":"‚àÄ {M : Type u_2} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_1} [inst_1 : CommMonoid N]\n  (f : Submonoid.LocalizationMap S N) (z : N),\n  Submonoid.LocalizationMap.mk' f (Prod.fst (Submonoid.LocalizationMap.sec f z))\n      (Prod.snd (Submonoid.LocalizationMap.sec f z)) =\n    z","name":"Submonoid.LocalizationMap.mk'_sec","isProp":true,"docString":"Given a localization map `f : M ‚Üí* N` for a submonoid `S ‚äÜ M`, for all `z : N` we have that if\n`x : M, y ‚àà S` are such that `z * f y = f x`, then `f x * (f y)‚Åª¬π = z`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.InitialMonoClass C] {I : C} (X : C)\n  (hI : CategoryTheory.Limits.IsInitial I), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)","name":"CategoryTheory.Limits.InitialMonoClass.isInitial_mono_from","isProp":true,"docString":"The map from the (any as stated) initial object to any other object is a\nmonomorphism "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] (f : E ‚Üí‚Çó[ùïú] Œ≤) {s : Set E}\n  (hs : Convex ùïú s), ConvexOn ùïú s ‚Üëf","name":"LinearMap.convexOn","isProp":true,"docString":"A linear map is convex. "},{"type":"‚àÄ {G : Type u_2} [inst : Group G] {Œπ : Type u_1} (s : Finset Œπ) (f : (a : Œπ) ‚Üí G)\n  (comm : Set.Pairwise ‚Üës fun (a : Œπ) (b : Œπ) ‚Ü¶ Commute (f a) (f b)) (K : (a : Œπ) ‚Üí Subgroup G)\n  (hind : CompleteLattice.Independent K) (hmem : ‚àÄ (x : Œπ) (a : x ‚àà s), f x ‚àà K x)\n  (heq1 : Finset.noncommProd s f comm = 1) (i : Œπ) (a : i ‚àà s), f i = 1","name":"Subgroup.eq_one_of_noncommProd_eq_one_of_independent","isProp":true,"docString":"`Finset.noncommProd` is ‚Äúinjective‚Äù in `f` if `f` maps into independent subgroups.  This\ngeneralizes (one direction of) `Subgroup.disjoint_iff_mul_eq_one`. "},{"type":"‚àÄ {ùïú : Type u_1} {V : Type u} {G : SimpleGraph V} [inst : OrderedRing ùïú] [inst_1 : Fintype (Sym2 V)]\n  [inst_2 : DecidableEq V] [inst_3 : DecidableRel (SimpleGraph.Adj G)] {p : (a : SimpleGraph V) ‚Üí Prop} {r : ùïú}\n  (a : SimpleGraph.DeleteFar G p r) ‚¶ÉH : SimpleGraph V‚¶Ñ (a : H ‚â§ G) (a : p H),\n  r ‚â§ ‚Üë(Finset.card (SimpleGraph.edgeFinset G)) - ‚Üë(Finset.card (SimpleGraph.edgeFinset H))","name":"SimpleGraph.DeleteFar.le_card_sub_card","isProp":true,"docString":"**Alias** of the forward direction of `SimpleGraph.deleteFar_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : AddMonoid Œ±] [inst_2 : ContinuousAdd Œ±],\n  ContinuousAdd (AddUnits Œ±)","name":"AddUnits.instContinuousAddAddUnitsInstTopologicalSpaceAddUnitsToAddInstAddZeroClassAddUnits","isProp":true,"docString":"If addition on an additive monoid is continuous, then addition on the additive units\nof the monoid, with respect to the induced topology, is continuous.\n\nNegation is also continuous, but we register this in a later file, `Topology.Algebra.Group`, because\nthe predicate `ContinuousNeg` has not yet been defined."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 0) (hb : b < 0), a + b < 0","name":"Left.add_neg'","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg'`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±},\n  (EMetric.hausdorffEdist s t = 0 : Prop) ‚Üî (closure s = closure t : Prop)","name":"EMetric.hausdorffEdist_zero_iff_closure_eq_closure","isProp":true,"docString":"Two sets are at zero Hausdorff edistance if and only if they have the same closure "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : DecidableEq Œπ] (f : (a : Œπ) ‚Üí Œ±)\n  {p : (a : Finset Œπ) ‚Üí Prop} (s : Finset Œπ) (h0 : p ‚àÖ)\n  (step :\n    ‚àÄ (a : Œπ) (s : Finset Œπ) (a_1 : ¬¨(a ‚àà s : Prop)) (a_2 : ‚àÄ (x : Œπ) (a_2 : x ‚àà s), f x ‚â§ f a) (a_3 : p s),\n      p (insert a s)),\n  p s","name":"Finset.induction_on_max_value","isProp":true,"docString":"Induction principle for `Finset`s in any type from which a given function `f` maps to a linearly\nordered type : a predicate is true on all `s : Finset Œ±` provided that:\n\n* it is true on the empty `Finset`,\n* for every `s : Finset Œ±` and an element `a` such that for elements of `s` denoted by `x` we have\n  `f x ‚â§ f a`, `p s` implies `p (insert a s)`. "},{"type":"‚àÄ (f : CircleDeg1Lift) (P : (a : ‚Ñù) ‚Üí Prop) (h : ‚àÄ (x : ‚Ñù) (a : x ‚àà Set.Icc 0 1), P (‚Üëf x - x)) (x : ‚Ñù), P (‚Üëf x - x)","name":"CircleDeg1Lift.forall_map_sub_of_Icc","isProp":true,"docString":"If a predicate depends only on `f x - x` and holds for all `0 ‚â§ x ‚â§ 1`,\nthen it holds for all `x`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"CanonicallyLinearOrderedSemifield.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ {R : Type u_3} [inst : CommSemiring R] (M : Submonoid R) {S : Type u_1} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] {P : Type u_2} [inst_3 : CommSemiring P] [inst_4 : IsLocalization M S] ‚¶Éj : S ‚Üí+* P‚¶Ñ\n  ‚¶Ék : S ‚Üí+* P‚¶Ñ (h : RingHom.comp j (algebraMap R S) = RingHom.comp k (algebraMap R S)), j = k","name":"IsLocalization.ringHom_ext","isProp":true,"docString":"See note [partially-applied ext lemmas] "},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.NonemptyCompacts Œ±)","name":"EMetric.NonemptyCompacts.compactSpace","isProp":true,"docString":"In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets "},{"type":"‚àÄ {Œ± : Type u} [inst : LE Œ±] [self : OrderBot Œ±] (a : Œ±), ‚ä• ‚â§ a","name":"OrderBot.bot_le","isProp":true,"docString":"`‚ä•` is the least element "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category C]\n  [inst_2 : CategoryTheory.IsPreconnected J] {X : C} {Y : C}\n  (Œ± :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Functor.const J)) X ‚ü∂\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Functor.const J)) Y)\n  (j : J) (j' : J), Œ±.app j = Œ±.app j'","name":"CategoryTheory.nat_trans_from_is_connected","isProp":true,"docString":"For objects `X Y : C`, any natural transformation `Œ± : const X ‚ü∂ const Y` from a connected\ncategory must be constant.\nThis is the key property of connected categories which we use to establish properties about limits.\n"},{"type":"‚àÄ {M : Type u_3} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N] {P : Type u_1}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëg ‚Üëy)) (z : N) (v : P),\n  (‚Üë(AddSubmonoid.LocalizationMap.lift f hg) z = v : Prop) ‚Üî\n    (‚Üëg (Prod.fst (AddSubmonoid.LocalizationMap.sec f z)) = ‚Üëg ‚Üë(Prod.snd (AddSubmonoid.LocalizationMap.sec f z)) + v :\n      Prop)","name":"AddSubmonoid.LocalizationMap.lift_spec","isProp":true,"docString":"Given a Localization map `f : M ‚Üí+ N` for a Submonoid `S ‚äÜ M`, if an\n`AddCommMonoid` map `g : M ‚Üí+ P` induces a map `f.lift hg : N ‚Üí+ P` then for all\n`z : N, v : P`, we have `f.lift hg z = v ‚Üî g x = g y + v`, where `x : M, y ‚àà S` are such that\n`z + f y = f x`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), (H = ‚ä• : Prop) ‚à® (‚àÉ (x : G), (x ‚àà H : Prop) ‚àß (x ‚â† 1 : Prop) : Prop)","name":"Subgroup.bot_or_exists_ne_one","isProp":true,"docString":"A subgroup is either the trivial subgroup or contains a non-identity element. "},{"type":"‚àÄ {Œ± : Type u} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} {n : ‚Ñï},\n  List.drop n (l‚ÇÅ ++ l‚ÇÇ) = List.drop n l‚ÇÅ ++ List.drop (n - List.length l‚ÇÅ) l‚ÇÇ","name":"List.drop_append_eq_append_drop","isProp":true,"docString":"Dropping the elements up to `n` in `l‚ÇÅ ++ l‚ÇÇ` is the same as dropping the elements up to `n`\nin `l‚ÇÅ`, dropping the elements up to `n - l‚ÇÅ.length` in `l‚ÇÇ`, and appending them. "},{"type":"‚àÄ {Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2}\n  {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_left_comm : ‚àÄ (a : Œ±) (b : Œ≤), f (g a) b = g' (f' a b)),\n  Option.map‚ÇÇ f (Option.map g a) b = Option.map g' (Option.map‚ÇÇ f' a b)","name":"Option.map‚ÇÇ_map_left_comm","isProp":true,"docString":"Symmetric statement to `Option.map_map‚ÇÇ_distrib_left`. "},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocSemiring Œ±] (a : Œ±), a * 0 = 0","name":"NonUnitalNonAssocSemiring.mul_zero","isProp":true,"docString":"Zero is a right absorbing element for multiplication "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : ProperSpace Œ±] (h : Metric.Bounded s),\n  IsCompact (closure s)","name":"Metric.Bounded.isCompact_closure","isProp":true,"docString":"The **Heine‚ÄìBorel theorem**: In a proper space, the closure of a bounded set is compact. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} (H : 1 < a) (n : ‚Ñï), ‚Üën ‚â§ (a ^ n - 1) / (a - 1)","name":"Nat.cast_le_pow_sub_div_sub","isProp":true,"docString":"Bernoulli's inequality reformulated to estimate `(n : Œ±)`. "},{"type":"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] {G : StructureGroupoid H} [inst_1 : ClosedUnderRestriction G]\n  (f : LocalHomeomorph H H) {s : Set H} {x : H} (hx : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv f) ‚à™ s·∂ú),\n  (StructureGroupoid.IsLocalStructomorphWithinAt G (‚Üëf) s x : Prop) ‚Üî\n    (‚àÄ (a : x ‚àà s),\n        ‚àÉ (e : LocalHomeomorph H H),\n          (e ‚àà G : Prop) ‚àß\n            ((LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚äÜ LocalEquiv.source (LocalHomeomorph.toLocalEquiv f) :\n                  Prop) ‚àß\n                ((Set.EqOn (‚Üëf) (‚Üëe) (s ‚à© LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)) : Prop) ‚àß\n                    (x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) : Prop) :\n                  Prop) :\n              Prop) :\n      Prop)","name":"LocalHomeomorph.isLocalStructomorphWithinAt_iff","isProp":true,"docString":"A slight reformulation of `IsLocalStructomorphWithinAt` when `f` is a local homeomorph.\nThis gives us an `e` that is defined on a subset of `f.source`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F}\n  {l : Filter Œ±},\n  (f =o[l] g : Prop) ‚Üî (‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ (a : 0 < c), Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) l : Prop)","name":"Asymptotics.isLittleO_iff","isProp":true,"docString":"Definition of `IsLittleO` in terms of filters. "},{"type":"‚àÄ {M : Type u_2} {R : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : SetLike M R] [inst_2 : MulMemClass M R]\n  {S : M} {a : R} {b : R} (ha : a ‚àà S) (hb : b ‚àà AddSubmonoid.closure ‚ÜëS), a * b ‚àà AddSubmonoid.closure ‚ÜëS","name":"MulMemClass.mul_left_mem_add_closure","isProp":true,"docString":"The product of an element of `S` and an element of the additive closure of a multiplicative\nsubmonoid `S` is contained in the additive closure of `S`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {F : Type u_3} [inst : NonAssocSemiring Œ±] [inst_1 : NonAssocSemiring Œ≤]\n  [inst_2 : AddHomClass F Œ± Œ≤] (f : F) (a : Œ±), ‚Üëf (bit0 a) = bit0 (‚Üëf a)","name":"map_bit0","isProp":true,"docString":"Additive homomorphisms preserve `bit0`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : Module ùïú E] {x : E}\n  {z : E} {s : Set E} (hs : StarConvex ùïú (z + x) s), StarConvex ùïú x ((fun (x : E) ‚Ü¶ z + x) ‚Åª¬π' s)","name":"StarConvex.preimage_add_right","isProp":true,"docString":"The translation of a star-convex set is also star-convex. "},{"type":"‚àÄ {R : Type u} [self : EuclideanDomain R], WellFounded EuclideanDomain.r","name":"EuclideanDomain.r_wellFounded","isProp":true,"docString":"The relation `r` must be well-founded.\nThis ensures that the GCD algorithm always terminates. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 ‚Ä¢ x = x","name":"Module.Core.one_smul","isProp":true,"docString":"Scalar multiplication by one is the identity. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {A : Type u_2} [inst_1 : AddMonoid A] [inst_2 : DistribMulAction M A] {B : Type u_3}\n  [inst_3 : AddMonoid B] [inst_4 : DistribMulAction M B] (self : A ‚Üí+[M] B) (x : A) (y : A),\n  MulActionHom.toFun (DistribMulActionHom.toMulActionHom self) (x + y) =\n    MulActionHom.toFun (DistribMulActionHom.toMulActionHom self) x +\n      MulActionHom.toFun (DistribMulActionHom.toMulActionHom self) y","name":"DistribMulActionHom.map_add'","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Monotone f) {x : Œ±}\n  [inst_4 : TopologicalSpace Œ±] [inst_5 : OrderTopology Œ±],\n  (ContinuousWithinAt f (Set.Iio x) x : Prop) ‚Üî (Function.leftLim f x = f x : Prop)","name":"Monotone.continuousWithinAt_Iio_iff_leftLim_eq","isProp":true,"docString":"A monotone function is continuous to the left at a point if and only if its left limit\ncoincides with the value of the function. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [inst : SetLike S R] [inst_1 : Mul R] [inst_2 : Add Œπ] {A : (a : Œπ) ‚Üí S}\n  [self : SetLike.GradedMul A] ‚¶Éi : Œπ‚¶Ñ ‚¶Éj : Œπ‚¶Ñ {gi : R} {gj : R} (a : gi ‚àà A i) (a : gj ‚àà A j), gi * gj ‚àà A (i + j)","name":"SetLike.GradedMul.mul_mem","isProp":true,"docString":"Multiplication is homogeneous "},{"type":"‚àÄ {Œ∑ : Type u_1} [inst : Finite Œ∑] {Gs : (a : Œ∑) ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)]\n  (H : (i : Œ∑) ‚Üí Subgroup (Gs i)) (K : (i : Œ∑) ‚Üí Subgroup (Gs i)),\n  ‚ÅÖSubgroup.pi Set.univ H, Subgroup.pi Set.univ K‚ÅÜ = Subgroup.pi Set.univ fun (i : Œ∑) ‚Ü¶ ‚ÅÖH i, K i‚ÅÜ","name":"Subgroup.commutator_pi_pi_of_finite","isProp":true,"docString":"The commutator of a finite direct product is contained in the direct product of the commutators.\n"},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {n : Type u_2} [inst_1 : Fintype n] [inst_2 : DecidableEq n] {M‚ÇÅ : Type u_3}\n  [inst_3 : AddCommMonoid M‚ÇÅ] [inst_4 : Module R M‚ÇÅ] (v‚ÇÅ : Basis n R M‚ÇÅ), ‚Üë(LinearMap.toMatrix v‚ÇÅ v‚ÇÅ) LinearMap.id = 1","name":"LinearMap.toMatrix_id","isProp":true,"docString":"This will be a special case of `LinearMap.toMatrix_id_eq_basis_toMatrix`. "},{"type":"‚àÄ {Œ± : Type u_1} (as : List Œ±), Array.data (List.toArray as) = as","name":"List.toArray_data","isProp":true,"docString":"**Alias** of `Array.data_toArray`."},{"type":"‚àÄ {H : Type u_1} {M : Type u_2} {H' : Type u_3} {M' : Type u_4} [inst : TopologicalSpace H]\n  [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M] [inst_3 : TopologicalSpace H']\n  [inst_4 : TopologicalSpace M'] [inst_5 : ChartedSpace H' M'] {G : StructureGroupoid H} {G' : StructureGroupoid H'}\n  {e : LocalHomeomorph M H} {P : (a : (a : H) ‚Üí H') ‚Üí (a : Set H) ‚Üí (a : H) ‚Üí Prop} {g : (a : M) ‚Üí M'} {s : Set M}\n  {x : M} (hG : StructureGroupoid.LocalInvariantProp G G' P) [inst_6 : HasGroupoid M G]\n  (he : e ‚àà StructureGroupoid.maximalAtlas M G) (xe : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)),\n  (ChartedSpace.LiftPropWithinAt P g s x : Prop) ‚Üî\n    (ChartedSpace.LiftPropWithinAt P (g ‚àò ‚Üë(LocalHomeomorph.symm e)) (‚Üë(LocalHomeomorph.symm e) ‚Åª¬π' s) (‚Üëe x) : Prop)","name":"StructureGroupoid.LocalInvariantProp.liftPropWithinAt_indep_chart_source","isProp":true,"docString":"A version of `liftPropWithinAt_indep_chart`, only for the source. "},{"type":"‚àÄ {Œπ : Type u_4} {Œπ‚ÇÅ : Type u_5} [inst : Finite Œπ] {R' : Type u_1} {N‚ÇÅ : Type u_2} {N‚ÇÇ : Type u_3}\n  [inst : CommSemiring R'] [inst_1 : AddCommMonoid N‚ÇÅ] [inst_2 : AddCommMonoid N‚ÇÇ] [inst_3 : Module R' N‚ÇÅ]\n  [inst_4 : Module R' N‚ÇÇ] {f : AlternatingMap R' N‚ÇÅ N‚ÇÇ Œπ} {g : AlternatingMap R' N‚ÇÅ N‚ÇÇ Œπ} (e : Basis Œπ‚ÇÅ R' N‚ÇÅ)\n  (h : ‚àÄ (v : (a : Œπ) ‚Üí Œπ‚ÇÅ) (a : Function.Injective v), (‚Üëf fun (i : Œπ) ‚Ü¶ ‚Üëe (v i)) = ‚Üëg fun (i : Œπ) ‚Ü¶ ‚Üëe (v i)), f = g","name":"Basis.ext_alternating","isProp":true,"docString":"Two alternating maps indexed by a `Fintype` are equal if they are equal when all arguments\nare distinct basis vectors. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrder Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"LinearOrder.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {C : Type u} [ùíû : CategoryTheory.Category C] [self : CategoryTheory.MonoidalCategory C] (X : C) (Y : C),\n  CategoryTheory.Iso.hom (Œ±_ X CategoryTheory.MonoidalCategory.tensorUnit' Y) ‚â´ (ùüô X ‚äó CategoryTheory.Iso.hom (Œª_ Y)) =\n    CategoryTheory.Iso.hom (œÅ_ X) ‚äó ùüô Y","name":"CategoryTheory.MonoidalCategory.triangle","isProp":true,"docString":"The identity relating the isomorphisms between `X ‚äó (ùüô_C ‚äó Y)`, `(X ‚äó ùüô_C) ‚äó Y` and `X ‚äó Y`\n"},{"type":"‚àÄ {Œ± : Type u_1} {s : Set (Setoid Œ±)}, Setoid.Rel (inf‚Çõ s) = inf‚Çõ (Setoid.Rel '' s)","name":"Setoid.inf‚Çõ_def","isProp":true,"docString":"The underlying binary operation of the infimum of a set of equivalence relations\nis the infimum of the set's image under the map to the underlying binary operation. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] [inst_1 : DecidableEq Œ±] (h5 : 5 ‚â§ Fintype.card Œ±) {f : Equiv.Perm Œ±}\n  (hf : Equiv.Perm.IsThreeCycle f),\n  Subgroup.normalClosure\n      {{ val := f,\n          property :=\n            ((Equiv.Perm.IsThreeCycle.mem_alternatingGroup hf=:f ‚àà alternatingGroup Œ±)=:f ‚àà alternatingGroup Œ±) }} =\n    ‚ä§","name":"Equiv.Perm.IsThreeCycle.alternating_normalClosure","isProp":true,"docString":"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : (a : Œ±) ‚Üí Œ≤} (h : Set.MapsTo f s t),\n  Set.MapsTo.restrict f s t h =\n    Set.codRestrict (Set.restrict s f) t (fun (x : ‚Üës) ‚Ü¶ (_ : f ‚Üëx ‚àà t)=:‚àÄ (x : ‚Üës), f ‚Üëx ‚àà t)","name":"Set.MapsTo.restrict_eq_codRestrict","isProp":true,"docString":"Reverse of `Set.codRestrict_restrict`. "},{"type":"‚àÄ {s : Set Cardinal} (hs : BddAbove s), Cardinal.lift (sup‚Çõ s) = sup‚Çõ (Cardinal.lift '' s)","name":"Cardinal.lift_sup‚Çõ","isProp":true,"docString":"The lift of a supremum is the supremum of the lifts. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ≤) (b : Œ≤) (v : Vector Œ± 1),\n  Vector.scanl f b v = b ::·µ• f b (Vector.head v) ::·µ• Vector.nil","name":"Vector.scanl_singleton","isProp":true,"docString":"The recursive step of `scanl` splits a vector made up of a single element\n`x ::·µ• nil : Vector Œ± 1` into a `Vector` of the provided starting value `b : Œ≤`\nand the mapped `f b x : Œ≤` as the last value.\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±), (a + b) * c = a * c + b * c","name":"CanonicallyOrderedCommSemiring.right_distrib","isProp":true,"docString":"Multiplication is right distributive over addition "},{"type":"‚àÄ {Œ± : Type u_1} [t : TopologicalSpace Œ±] [inst : Preorder Œ±] [self : OrderTopology Œ±],\n  t = TopologicalSpace.generateFrom (setOf fun (s : Set Œ±) ‚Ü¶ ‚àÉ (a : Œ±), (s = Set.Ioi a : Prop) ‚à® (s = Set.Iio a : Prop))","name":"OrderTopology.topology_eq_generate_intervals","isProp":true,"docString":"The topology is generated by open intervals `Set.Ioi _` and `Set.Iio _`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±), a * 1 = a","name":"CanonicallyOrderedCommSemiring.mul_one","isProp":true,"docString":"One is a right neutral element for multiplication "},{"type":"‚àÄ (o : Ordinal),\n  Set.Nonempty\n    (setOf fun (a : Cardinal) ‚Ü¶\n      ‚àÉ (Œπ : Type u), ‚àÉ (f : (a : Œπ) ‚Üí Ordinal), (Ordinal.lsub f = o : Prop) ‚àß (Cardinal.mk Œπ = a : Prop))","name":"Ordinal.cof_lsub_def_nonempty","isProp":true,"docString":"The set in the `lsub` characterization of `cof` is nonempty. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} [inst : AddGroup Œ±] [self : NonarchAddGroupSeminormClass F Œ±] (f : F),\n  ‚Üëf 0 = 0","name":"NonarchAddGroupSeminormClass.map_zero","isProp":true,"docString":"The image of zero is zero. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasEqualizer f g] {W : C} {k : W ‚ü∂ CategoryTheory.Limits.equalizer f g}\n  {l : W ‚ü∂ CategoryTheory.Limits.equalizer f g}\n  (h : k ‚â´ CategoryTheory.Limits.equalizer.Œπ f g = l ‚â´ CategoryTheory.Limits.equalizer.Œπ f g), k = l","name":"CategoryTheory.Limits.equalizer.hom_ext","isProp":true,"docString":"Two maps into an equalizer are equal if they are are equal when composed with the equalizer\nmap. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R ‚Üí+* S),\n  Function.Injective ‚Üë(RingHom.kerLift f)","name":"RingHom.kerLift_injective","isProp":true,"docString":"The induced map from the quotient by the kernel is injective. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2}, Function.Injective Option.map","name":"Option.map_injective'","isProp":true,"docString":"`Option.map` as a function between functions is injective. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type v'}\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'] (f : M ‚âÉ‚Çó[R] M'),\n  Cardinal.lift (Module.rank R M) = Cardinal.lift (Module.rank R M')","name":"LinearEquiv.lift_rank_eq","isProp":true,"docString":"Two linearly equivalent vector spaces have the same dimension, a version with different\nuniverses. "},{"type":"‚àÄ {G : Type u_2} [inst : Group G] {Œπ : Sort u_1} (S : (a : Œπ) ‚Üí Subgroup G)\n  {C : (x : G) ‚Üí (a : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) ‚Üí Prop}\n  (hp :\n    ‚àÄ (i : Œπ) (x : G) (hx : x ‚àà S i),\n      C x ((Subgroup.mem_sup·µ¢_of_mem i hx=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (h1 : C 1 ((one_mem (sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:1 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:1 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (hmul :\n    ‚àÄ (x : G) (y : G) (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hy : y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (a : C x hx) (a : C y hy),\n      C (x * y) ((mul_mem hx hy=:x * y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x * y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  {x : G} (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i), C x hx","name":"Subgroup.sup·µ¢_induction'","isProp":true,"docString":"A dependent version of `Subgroup.sup·µ¢_induction`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : OrderedSemiring Œ±] {t : ‚Üë(Set.Icc 0 1)}, t ‚â§ 1","name":"Set.Icc.le_one","isProp":true,"docString":"like `coe_le_one`, but with the inequality in `Icc (0:Œ±) 1`. "},{"type":"‚àÄ {H : Type u} {M : Type u_1} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  (G : StructureGroupoid H) [inst_3 : HasGroupoid M G], atlas ‚äÜ StructureGroupoid.maximalAtlas M G","name":"StructureGroupoid.subset_maximalAtlas","isProp":true,"docString":"The elements of the atlas belong to the maximal atlas for any structure groupoid. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤], IsOpenMap Prod.fst","name":"isOpenMap_fst","isProp":true,"docString":"The first projection in a product of topological spaces sends open sets to open sets. "},{"type":"‚àÄ {Œ± : Type u} [inst : LT Œ±] [inst_1 : WellFoundedGT Œ±] {C : (a : Œ±) ‚Üí Sort u_1}\n  (F : (x : Œ±) ‚Üí (a : (y : Œ±) ‚Üí (a : x < y) ‚Üí C y) ‚Üí C x) (x : Œ±),\n  WellFoundedGT.fix F x = F x fun (y : Œ±) (x : x < y) ‚Ü¶ WellFoundedGT.fix F y","name":"WellFoundedGT.fix_eq","isProp":true,"docString":"The value from `WellFoundedGT.fix` is built from the successive ones as specified. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] (self : Flag Œ±) ‚¶És : Set Œ±‚¶Ñ (a : IsChain (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) s)\n  (a : Flag.carrier self ‚äÜ s), Flag.carrier self = s","name":"Flag.max_chain'","isProp":true,"docString":"By definition, a flag is a maximal chain "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Lattice Œ±] [inst_1 : Lattice Œ≤] [inst_2 : BoundedOrder Œ±]\n  [inst_3 : BoundedOrder Œ≤] (self : BoundedLatticeHom Œ± Œ≤),\n  SupHom.toFun (LatticeHom.toSupHom (BoundedLatticeHom.toLatticeHom self)) ‚ä• = ‚ä•","name":"BoundedLatticeHom.map_bot'","isProp":true,"docString":"A `BoundedLatticeHom` preserves the bottom element. "},{"type":"‚àÄ (x : ‚Ñù), Real.cosh x = (Real.exp x + Real.exp (-x)) / 2","name":"Real.cosh_eq","isProp":true,"docString":"The definition of `cosh` in terms of `exp`. "},{"type":"‚àÄ (G : Sort u_3) {Œ± : Sort u_1} {Œ≥ : Sort u_2} [inst : FunLike G Œ± fun (x : Œ±) ‚Ü¶ Œ≥] [inst : Finite Œ±] [inst : Finite Œ≥],\n  Finite G","name":"FunLike.finite'","isProp":true,"docString":"All `FunLike`s are finite if their domain and codomain are.\n\nNon-dependent version of `FunLike.finite` that might be easier to infer.\nCan't be an instance because it can cause infinite loops.\n"},{"type":"‚àÄ {M‚ÇÄ : Type u} [inst : Mul M‚ÇÄ] [inst_1 : Zero M‚ÇÄ] [self : IsLeftCancelMulZero M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ} {c : M‚ÇÄ}\n  (a_1 : a ‚â† 0) (a : a * b = a * c), b = c","name":"IsLeftCancelMulZero.mul_left_cancel_of_ne_zero","isProp":true,"docString":"Multiplicatin by a nonzero element is left cancellative. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : NormedSpace ‚Ñù ùïú]\n  [inst_3 : Module ùïú E] [inst_4 : Module ‚Ñù E] [inst_5 : IsScalarTower ‚Ñù ùïú E] (p : Seminorm ùïú E) (x : E) (r : ‚Ñù),\n  Convex ‚Ñù (Seminorm.ball p x r)","name":"Seminorm.convex_ball","isProp":true,"docString":"Seminorm-balls are convex. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±}, a ‚â§ a","name":"le_rfl","isProp":true,"docString":"A version of `le_refl` where the argument is implicit "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  (TotallyDisconnectedSpace Œ± : Prop) ‚Üî (‚àÄ (x : Œ±), connectedComponent x = {x} : Prop)","name":"totallyDisconnectedSpace_iff_connectedComponent_singleton","isProp":true,"docString":"A space is totally disconnected iff its connected components are singletons. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (h : 0 < r * (b - a)),\n  (f (‚Üë(AffineMap.lineMap a b) r) < ‚Üë(AffineMap.lineMap (f a) (f b)) r : Prop) ‚Üî\n    (slope f a (‚Üë(AffineMap.lineMap a b) r) < slope f a b : Prop)","name":"map_lt_lineMap_iff_slope_lt_slope_left","isProp":true,"docString":"Given `c = lineMap a b r`, `a < c`, the point `(c, f c)` is strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a c < slope f a b`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedMonoid Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"CanonicallyLinearOrderedMonoid.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Countable s), Countable ‚Üës","name":"Set.Countable.to_subtype","isProp":true,"docString":"Restate `Set.Countable` as a `Countable` instance. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (hc : Set.Countable s) (hs : Set.Nonempty s), ‚àÉ (f : (a : ‚Ñï) ‚Üí Œ±), s = Set.range f","name":"Set.Countable.exists_eq_range","isProp":true,"docString":"If `s : Set Œ±` is a nonempty countable set, then there exists a map\n`f : ‚Ñï ‚Üí Œ±` such that `s = range f`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Œ±],\n  Set.Countable (setOf fun (x : Œ±) ‚Ü¶ nhdsWithin x (Set.Iio x) = ‚ä•)","name":"countable_setOf_isolated_left","isProp":true,"docString":"The set of points which are isolated on the left is countable when the space is\nsecond-countable. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ±' : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_2} {Œ¥ : Type u_1} [inst : DecidableEq Œ±']\n  [inst_1 : DecidableEq Œ≥] [inst_2 : DecidableEq Œ¥] {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Finset Œ±} {t : Finset Œ≤}\n  {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ¥} {g' : (a : Œ±) ‚Üí Œ±'}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' (g' a) b),\n  Finset.image g (Finset.image‚ÇÇ f s t) = Finset.image‚ÇÇ f' (Finset.image g' s) t","name":"Finset.image_image‚ÇÇ_distrib_left","isProp":true,"docString":"Symmetric statement to `Finset.image‚ÇÇ_image_left_comm`. "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±], nhdsSet (Set.diagonal Œ±) ‚â§ uniformity Œ±","name":"nhdsSet_diagonal_le_uniformity","isProp":true,"docString":"Entourages are neighborhoods of the diagonal. "},{"type":"‚àÄ {Œ± : Type u_1} {ùïú : Type u_2} [inst : NormedField ùïú] {l : Filter Œ±} {u : (a : Œ±) ‚Üí ùïú} {v : (a : Œ±) ‚Üí ùïú}\n  (h : u =o[l] v), u / v * v =·∂†[l] u","name":"Asymptotics.IsLittleO.eventually_mul_div_cancel","isProp":true,"docString":"If `u = o(v)` along `l`, then `(u / v) * v = u` eventually at `l`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Monoid Œ≤] [inst_1 : DecidableEq Œ±] {s : Finset Œ±} {t : Finset Œ±}\n  (h : Disjoint s t) (f : (a : Œ±) ‚Üí Œ≤)\n  (comm : Set.Pairwise (setOf fun (x : Œ±) ‚Ü¶ x ‚àà s ‚à™ t) fun (a : Œ±) (b : Œ±) ‚Ü¶ Commute (f a) (f b)),\n  Finset.noncommProd (s ‚à™ t) f comm =\n    Finset.noncommProd s f\n        ((Set.Pairwise.mono\n              ((Iff.mpr\n                    ((Finset.coe_subset=:(‚Üës ‚äÜ ‚Üë(s ‚à™ t) : Prop) ‚Üî\n                          (s ‚äÜ s ‚à™ t : Prop))=:(‚Üës ‚äÜ ‚Üë(s ‚à™ t) : Prop) ‚Üî (s ‚äÜ s ‚à™ t : Prop))\n                    ((Finset.subset_union_left s t=:s ‚äÜ s ‚à™ t)=:s ‚äÜ s ‚à™ t)=:‚Üës ‚äÜ ‚Üë(s ‚à™ t))=:‚Üës ‚äÜ ‚Üë(s ‚à™ t))\n              comm=:Set.Pairwise ‚Üës fun (a : Œ±) (b : Œ±) ‚Ü¶\n              Commute (f a) (f b))=:Set.Pairwise ‚Üës fun (a : Œ±) (b : Œ±) ‚Ü¶ Commute (f a) (f b)) *\n      Finset.noncommProd t f\n        ((Set.Pairwise.mono\n              ((Iff.mpr\n                    ((Finset.coe_subset=:(‚Üët ‚äÜ ‚Üë(s ‚à™ t) : Prop) ‚Üî\n                          (t ‚äÜ s ‚à™ t : Prop))=:(‚Üët ‚äÜ ‚Üë(s ‚à™ t) : Prop) ‚Üî (t ‚äÜ s ‚à™ t : Prop))\n                    ((Finset.subset_union_right s t=:t ‚äÜ s ‚à™ t)=:t ‚äÜ s ‚à™ t)=:‚Üët ‚äÜ ‚Üë(s ‚à™ t))=:‚Üët ‚äÜ ‚Üë(s ‚à™ t))\n              comm=:Set.Pairwise ‚Üët fun (a : Œ±) (b : Œ±) ‚Ü¶\n              Commute (f a) (f b))=:Set.Pairwise ‚Üët fun (a : Œ±) (b : Œ±) ‚Ü¶ Commute (f a) (f b))","name":"Finset.noncommProd_union_of_disjoint","isProp":true,"docString":"The non-commutative version of `Finset.prod_union` "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), 0 ‚àà H","name":"AddSubgroup.zero_mem","isProp":true,"docString":"An `AddSubgroup` contains the group's 0."},{"type":"‚àÄ {n : ‚Ñï} (c : Composition n) {i‚ÇÅ : Fin (Composition.length c)} {i‚ÇÇ : Fin (Composition.length c)} (h : i‚ÇÅ ‚â† i‚ÇÇ),\n  Disjoint (Set.range ‚Üë(Composition.embedding c i‚ÇÅ)) (Set.range ‚Üë(Composition.embedding c i‚ÇÇ))","name":"Composition.disjoint_range","isProp":true,"docString":"The embeddings of different blocks of a composition are disjoint. "},{"type":"‚àÄ (k : Type u_3) {V1 : Type u_2} (P1 : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\n  [inst_3 : AddTorsor V1 P1], ‚Üë(AffineMap.id k P1) = id","name":"AffineMap.coe_id","isProp":true,"docString":"The identity affine map acts as the identity. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : Set.Nonempty s)\n  (fin : EMetric.hausdorffEdist s t ‚â† ‚ä§), Set.Nonempty t","name":"EMetric.nonempty_of_hausdorffEdist_ne_top","isProp":true,"docString":"If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (q : (i : Fin (n + 1)) ‚Üí Œ± i) (i : Fin n) (y : Œ± (Fin.succ i)),\n  Fin.tail (Function.update q (Fin.succ i) y) = Function.update (Fin.tail q) i y","name":"Fin.tail_update_succ","isProp":true,"docString":"Updating a nonzero element and taking the tail commute. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {U : Finset Œ±} {V : Finset Œ±} (hUV : Finset.card U = Finset.card V)\n  (A : Finset Œ±), Finset.card (UV.compress U V A) = Finset.card A","name":"UV.card_compress","isProp":true,"docString":"Compressing a finset doesn't change its size. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {l : Filter Œ±} {a : Œ±}\n  (a_1 : IsExtrFilter (‚ÜëOrderDual.toDual ‚àò f) l a), IsExtrFilter f l a","name":"IsExtrFilter.undual","isProp":true,"docString":"**Alias** of the forward direction of `isExtrFilter_dual_iff`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst : TopologicalSpace.SecondCountableTopology Œ±],\n  Set.Countable (setOf fun (x : Œ±) ‚Ü¶ ‚àÉ (y : Œ±), (y < x : Prop) ‚àß (Set.Ioo y x = ‚àÖ : Prop))","name":"countable_of_isolated_left'","isProp":true,"docString":"The set of points which are isolated on the left is countable when the space is\nsecond-countable. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} (a_1 : a + b < c), a < c - b","name":"lt_sub_right_of_add_lt","isProp":true,"docString":"**Alias** of the reverse direction of `lt_sub_iff_add_lt`."},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±), a * 0 = 0","name":"CanonicallyOrderedCommSemiring.mul_zero","isProp":true,"docString":"Zero is a right absorbing element for multiplication "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] (F : C ‚•§ D)\n  (X : C) (Y : C) [inst_4 : CategoryTheory.Limits.HasBinaryBiproduct X Y]\n  [inst_5 :\n    CategoryTheory.Limits.HasBinaryBiproduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X)\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y)]\n  [inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms F],\n  CategoryTheory.Functor.biprodComparison' F X Y ‚â´ CategoryTheory.Functor.biprodComparison F X Y =\n    ùüô\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X ‚äû\n        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y)","name":"CategoryTheory.Functor.biprodComparison'_comp_biprodComparison","isProp":true,"docString":"The composition in the opposite direction is equal to the identity if and only if `F` preserves\nthe biproduct, see `preservesBinaryBiproduct_of_monoBiprodComparison`. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] (s : Submodule R M)\n  (hs : IsCoatom s), (IsClosed ‚Üës : Prop) ‚à® (Dense ‚Üës : Prop)","name":"Submodule.isClosed_or_dense_of_isCoatom","isProp":true,"docString":"A maximal proper subspace of a topological module (i.e a `Submodule` satisfying `IsCoatom`)\nis either closed or dense. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroSMulDivisors R M] [inst_4 : Nontrivial R], (Module.rank R M = 0 : Prop) ‚Üî (Subsingleton M : Prop)","name":"rank_zero_iff","isProp":true,"docString":"See `rank_subsingleton` for the reason that `Nontrivial R` is needed. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {I : Ideal R} (h : Ideal.Fg I) (f : R ‚Üí+* S),\n  Ideal.Fg (Ideal.map f I)","name":"Ideal.Fg.map","isProp":true,"docString":"The image of a finitely generated ideal is finitely generated.\n\nThis is the `ideal` version of `Submodule.Fg.map`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : ConditionallyCompleteLattice Œ±] (s : Set Œ±) (a : Œ±) (a_1 : Set.Nonempty s)\n  (a_2 : a ‚àà upperBounds s), sup‚Çõ s ‚â§ a","name":"ConditionallyCompleteLattice.csup‚Çõ_le","isProp":true,"docString":"`sup‚Çõ s ‚â§ a` for all `a ‚àà upperBounds s`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T1Space Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {a : Œ±} {b : Œ≤} (h : Filter.Tendsto f (nhds a) (nhds b)), ContinuousAt f a","name":"continuousAt_of_tendsto_nhds","isProp":true,"docString":"To prove a function to a `T1Space` is continuous at some point `a`, it suffices to prove that\n`f` admits *some* limit at `a`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {K : NNReal}\n  {f : (a : Œ±) ‚Üí Œ≤} (a : AntilipschitzWith K f) (x : Œ±) (y : Œ±), dist x y ‚â§ ‚ÜëK * dist (f x) (f y)","name":"AntilipschitzWith.le_mul_dist","isProp":true,"docString":"**Alias** of the forward direction of `antilipschitzWith_iff_le_mul_dist`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddCommMonoid Œ≤] (s : Finset Œ±) (f : (a : Finset Œ±) ‚Üí Œ≤),\n  (Finset.sum (Finset.powerset s) fun (t : Finset Œ±) ‚Ü¶ f t) =\n    Finset.sum (Finset.range (Finset.card s + 1)) fun (j : ‚Ñï) ‚Ü¶\n      Finset.sum (Finset.powersetLen j s) fun (t : Finset Œ±) ‚Ü¶ f t","name":"Finset.sum_powerset","isProp":true,"docString":"A sum over `powerset s` is equal to the double sum over sets of subsets of `s` with\n`card s = k`, for `k = 1, ..., card s`"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (hs : IsCompact s) {f : Filter Œ±}\n  (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), ‚àÉ (t : Set Œ±), (t ‚àà nhdsWithin a s : Prop) ‚àß (t·∂ú ‚àà f : Prop)), s·∂ú ‚àà f","name":"IsCompact.compl_mem_sets_of_nhdsWithin","isProp":true,"docString":"The complement to a compact set belongs to a filter `f` if each `a ‚àà s` has a neighborhood `t`\nwithin `s` such that `t·∂ú` belongs to `f`. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {u : (a : Œπ) ‚Üí Set X} {s : Set X}\n  (self : ShrinkingLemma.PartialRefinement u s) {i : Œπ} (a : i ‚àà ShrinkingLemma.PartialRefinement.carrier self),\n  closure (ShrinkingLemma.PartialRefinement.toFun self i) ‚äÜ u i","name":"ShrinkingLemma.PartialRefinement.closure_subset","isProp":true,"docString":"For each `i ‚àà carrier`, the original set includes the closure of the refined set. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {s : Set M}, s ‚äÜ AddMonoid.Closure s","name":"AddMonoid.subset_closure","isProp":true,"docString":"A subset of an `AddMonoid` is contained in the `AddSubmonoid` it generates."},{"type":"‚àÄ {X : Type u_1} {Œ± : Type u_2} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {A : Set ((a : X) ‚Üí Œ±)}\n  (hA : Set.Equicontinuous A), Set.Equicontinuous (closure A)","name":"Equicontinuous.closure","isProp":true,"docString":"If a set of functions is equicontinuous, its closure for the product topology is also\nequicontinuous. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R] (h : IsLeftRegular 0), Subsingleton R","name":"IsLeftRegular.subsingleton","isProp":true,"docString":"The element `0` is left-regular if and only if `R` is trivial. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  [inst_3 : IsAntisymm Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1] (h‚ÇÅ : a ‚äÜ b) (h‚ÇÇ : a ‚â† b), a ‚äÇ b","name":"HasSubset.Subset.ssubset_of_ne","isProp":true,"docString":"**Alias** of `ssubset_of_subset_of_ne`."},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {S : AddSubsemigroup M} {T : AddSubsemigroup M}\n  (h : ‚àÄ (x : M), (x ‚àà S : Prop) ‚Üî (x ‚àà T : Prop)), S = T","name":"AddSubsemigroup.ext","isProp":true,"docString":"Two `AddSubsemigroup`s are equal if they have the same elements."},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} {g : (a : Œ≤) ‚Üí Œ≥} (hg : Function.Bijective g),\n  Function.Bijective ((fun (x : (a : Œ≤) ‚Üí Œ≥) (x_1 : (a : Œ±) ‚Üí Œ≤) ‚Ü¶ x ‚àò x_1) g)","name":"Function.Bijective.comp_left","isProp":true,"docString":"Composition by an bijective function on the left is itself bijective. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} {f : M ‚Üí* P}\n  (H : c ‚â§ Con.ker f) (x : M), ‚Üë(Con.lift c f H) ‚Üëx = ‚Üëf x","name":"Con.lift_coe","isProp":true,"docString":"The diagram describing the universal property for quotients of monoids commutes. "},{"type":"‚àÄ {G : Type w} [inst : AddGroup G] {g : G} {P : (a : G) ‚Üí Prop} (h_one : P 0) (h_mul : ‚àÄ (a : G) (a_1 : P a), P (g + a))\n  (h_inv : ‚àÄ (a : G) (a_1 : P a), P (-g + a)) (n : ‚Ñ§), P (n ‚Ä¢ g)","name":"zsmul_induction_left","isProp":true,"docString":"To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the left. For additive subgroups generated by more than one element, see\n`AddSubgroup.closure_induction_left`."},{"type":"‚àÄ {K : Type u_1} [inst : DivisionRing K] [inst_1 : TopologicalSpace K] [inst_2 : ContinuousMul K] {a : K} (ha : a ‚â† 0),\n  Filter.Tendsto (fun (x : K) ‚Ü¶ x * a) (Filter.cocompact K) (Filter.cocompact K)","name":"Filter.tendsto_cocompact_mul_right‚ÇÄ","isProp":true,"docString":"Right-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. "},{"type":"‚àÄ {C : Type u} {A : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : AddMonoid A]\n  (self : CategoryTheory.ShiftMkCore C A) (m‚ÇÅ : A) (m‚ÇÇ : A) (m‚ÇÉ : A) (X : C),\n  (CategoryTheory.Iso.hom (CategoryTheory.ShiftMkCore.add self (m‚ÇÅ + m‚ÇÇ) m‚ÇÉ)).app X ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self m‚ÇÉ))\n        ((CategoryTheory.Iso.hom (CategoryTheory.ShiftMkCore.add self m‚ÇÅ m‚ÇÇ)).app X) =\n    CategoryTheory.eqToHom\n        ((Eq.mpr\n              ((id\n                    ((Eq.ndrec\n                          ((Eq.refl\n                                (Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor\n                                        (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ)))\n                                      X =\n                                    Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor\n                                        (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                                      X :\n                                  Prop)=:(Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor\n                                        (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ)))\n                                      X =\n                                    Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor\n                                        (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                                      X :\n                                  Prop) =\n                                (Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor\n                                        (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ)))\n                                      X =\n                                    Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor\n                                        (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                                      X :\n                                  Prop))=:(Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor\n                                      (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ)))\n                                    X =\n                                  Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor\n                                      (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                                    X :\n                                Prop) =\n                              (Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor\n                                      (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ)))\n                                    X =\n                                  Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor\n                                      (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                                    X :\n                                Prop))\n                          ((add_assoc m‚ÇÅ m‚ÇÇ\n                                m‚ÇÉ=:m‚ÇÅ + m‚ÇÇ + m‚ÇÉ =\n                                m‚ÇÅ +\n                                  (m‚ÇÇ +\n                                    m‚ÇÉ))=:m‚ÇÅ + m‚ÇÇ + m‚ÇÉ =\n                              m‚ÇÅ +\n                                (m‚ÇÇ +\n                                  m‚ÇÉ))=:(Prefunctor.obj\n                                (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ)))\n                                X =\n                              Prefunctor.obj\n                                (CategoryTheory.Functor.toPrefunctor\n                                  (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                                X :\n                            Prop) =\n                          (Prefunctor.obj\n                                (CategoryTheory.Functor.toPrefunctor\n                                  (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                                X =\n                              Prefunctor.obj\n                                (CategoryTheory.Functor.toPrefunctor\n                                  (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                                X :\n                            Prop))=:(Prefunctor.obj\n                              (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ)))\n                              X =\n                            Prefunctor.obj\n                              (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                              X :\n                          Prop) =\n                        (Prefunctor.obj\n                              (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                              X =\n                            Prefunctor.obj\n                              (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                              X :\n                          Prop))=:(Prefunctor.obj\n                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ))) X =\n                        Prefunctor.obj\n                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)))) X :\n                      Prop) =\n                    (Prefunctor.obj\n                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)))) X =\n                        Prefunctor.obj\n                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)))) X :\n                      Prop))=:(Prefunctor.obj\n                        (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ))) X =\n                      Prefunctor.obj\n                        (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)))) X :\n                    Prop) =\n                  (Prefunctor.obj\n                        (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)))) X =\n                      Prefunctor.obj\n                        (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)))) X :\n                    Prop))\n              ((Eq.refl\n                    (Prefunctor.obj\n                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                      X)=:Prefunctor.obj\n                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)))) X =\n                    Prefunctor.obj\n                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                      X)=:Prefunctor.obj\n                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ)))) X =\n                  Prefunctor.obj\n                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                    X)=:Prefunctor.obj\n                (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ))) X =\n              Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n                X)=:Prefunctor.obj\n              (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + m‚ÇÇ + m‚ÇÉ))) X =\n            Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (m‚ÇÅ + (m‚ÇÇ + m‚ÇÉ))))\n              X) ‚â´\n      (CategoryTheory.Iso.hom (CategoryTheory.ShiftMkCore.add self m‚ÇÅ (m‚ÇÇ + m‚ÇÉ))).app X ‚â´\n        (CategoryTheory.Iso.hom (CategoryTheory.ShiftMkCore.add self m‚ÇÇ m‚ÇÉ)).app\n          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self m‚ÇÅ)) X)","name":"CategoryTheory.ShiftMkCore.assoc_hom_app","isProp":true,"docString":"compatibility with the associativity "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : (a : ‚Ñï) ‚Üí Set Œ±} (h0 : IsComplete (s 0))\n  (hs : ‚àÄ (n : ‚Ñï), IsClosed (s n)) (h's : ‚àÄ (n : ‚Ñï), Metric.Bounded (s n))\n  (h : ‚àÄ (N : ‚Ñï), Set.Nonempty (Set.inter·µ¢ fun (n : ‚Ñï) ‚Ü¶ Set.inter·µ¢ fun (h : n ‚â§ N) ‚Ü¶ s n))\n  (h' : Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ Metric.diam (s n)) Filter.atTop (nhds 0)),\n  Set.Nonempty (Set.inter·µ¢ fun (n : ‚Ñï) ‚Ü¶ s n)","name":"IsComplete.nonempty_inter·µ¢_of_nonempty_binter·µ¢","isProp":true,"docString":"If a family of complete sets with diameter tending to `0` is such that each finite intersection\nis nonempty, then the total intersection is also nonempty. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] (f : OneHom M N) {x : M} {y : M} (h : x = y),\n  ‚Üëf x = ‚Üëf y","name":"OneHom.congr_arg","isProp":true,"docString":"Deprecated: use `FunLike.congr_arg` instead. "},{"type":"‚àÄ (Œ± : Type u) (Œ≤ : Type v) [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] [inst_2 : Fintype Œ±] [inst_3 : Fintype Œ≤]\n  [inst_4 : Fintype (Quotient (MulAction.orbitRel Œ± Œ≤))]\n  [inst_5 : (b : Œ≤) ‚Üí Fintype { x : Œ± // x ‚àà MulAction.stabilizer Œ± b }],\n  Fintype.card Œ≤ =\n    Finset.sum Finset.univ fun (œâ : Quotient (MulAction.orbitRel Œ± Œ≤)) ‚Ü¶\n      Fintype.card Œ± / Fintype.card { x : Œ± // x ‚àà MulAction.stabilizer Œ± (Quotient.out' œâ) }","name":"MulAction.card_eq_sum_card_group_div_card_stabilizer","isProp":true,"docString":"**Class formula** for a finite group acting on a finite type. "},{"type":"‚àÄ {ùìï : Type u_1} {E : Type u_2} {F : Type u_3} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F]\n  [inst_2 : MonoidHomClass ùìï E F] (f : ùìï) (a : ‚àÄ (x : E), ‚Äñ‚Üëf x‚Äñ = ‚Äñx‚Äñ), Isometry ‚Üëf","name":"MonoidHomClass.isometry_of_norm","isProp":true,"docString":"**Alias** of the reverse direction of `MonoidHomClass.isometry_iff_norm`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Infinite Œ±], IrreducibleSpace (CofiniteTopology Œ±)","name":"instIrreducibleSpaceCofiniteTopologyInstTopologicalSpaceCofiniteTopology","isProp":true,"docString":"An infinite type with cofinite topology is an irreducible topological space. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type w}\n  [inst_1 : CategoryTheory.Category D] [inst_2 : CategoryTheory.ConcreteCategory D]\n  [inst_3 : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)]\n  [inst_4 : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ D]\n  [inst_5 :\n    ‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\n  [inst_6 :\n    (X : C) ‚Üí\n      CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ\n        (CategoryTheory.forget D)]\n  {X : C} (P : C·µí·µñ ‚•§ D) (S : CategoryTheory.GrothendieckTopology.Cover J X)\n  (x :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.ConcreteCategory.Forget)\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.GrothendieckTopology.plusObj J P))\n        (Opposite.op X)))\n  (y :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.ConcreteCategory.Forget)\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.GrothendieckTopology.plusObj J P))\n        (Opposite.op X)))\n  (h :\n    ‚àÄ (I : CategoryTheory.GrothendieckTopology.Cover.Arrow S),\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget D))\n          (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.GrothendieckTopology.plusObj J P))\n            (Quiver.Hom.op (CategoryTheory.GrothendieckTopology.Cover.Arrow.f I)))\n          x =\n        Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget D))\n          (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.GrothendieckTopology.plusObj J P))\n            (Quiver.Hom.op (CategoryTheory.GrothendieckTopology.Cover.Arrow.f I)))\n          y),\n  x = y","name":"CategoryTheory.GrothendieckTopology.Plus.sep","isProp":true,"docString":"`P‚Å∫` is always separated. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ‚àà s),\n  ‚Üë(AffineSubspace.direction s) = (fun (x : P) ‚Ü¶ x -·µ• p) '' ‚Üës","name":"AffineSubspace.coe_direction_eq_vsub_set_right","isProp":true,"docString":"Given a point in an affine subspace, the set of vectors in its direction equals the set of\nvectors subtracting that point on the right. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] [inst_3 : PosMulMono Œ±]\n  (ha : a ‚â§ 1) (hb : b ‚â§ 1) (a0 : 0 ‚â§ a), a * b ‚â§ 1","name":"Left.mul_le_one_of_le_of_le","isProp":true,"docString":"Assumes left covariance. "},{"type":"‚àÄ {Œ≤ : Type u_1} {f : (a : Œ≤) ‚Üí ‚Ñ§} (s : Finset Œ≤) {x : Œ≤} (hx : x ‚àà s) (hfz : f x ‚â† 0),\n  (Finset.gcd s fun (b : Œ≤) ‚Ü¶ f b / Finset.gcd s f) = 1","name":"Finset.Int.gcd_div_eq_one","isProp":true,"docString":"Given a nonempty Finset `s` and a function `f` from `s` to `‚Ñ§`, if `d = s.gcd`,\nthen the `gcd` of `(f i) / d` is equal to `1`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (e : M ‚âÉ+ N) (x : M), ‚Üë(AddEquiv.symm e) (‚Üëe x) = x","name":"AddEquiv.symm_apply_apply","isProp":true,"docString":"`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : PreirreducibleSpace Œ±] {s : Set Œ±} (ho : IsOpen s)\n  (hne : Set.Nonempty s), Dense s","name":"IsOpen.dense","isProp":true,"docString":"In a (pre)irreducible space, a nonempty open set is dense. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {T : Set (Set Œ±)} {s : Set Œ±} (hs : IsGŒ¥ s)\n  (hd : Dense s) (hc : Set.Countable T) (hc' : ‚àÄ (t : Set Œ±) (a : t ‚àà T), IsClosed t) (hU : s ‚äÜ ‚ãÉ‚ÇÄ T),\n  Dense (Set.union·µ¢ fun (t : Set Œ±) ‚Ü¶ Set.union·µ¢ fun (h : t ‚àà T) ‚Ü¶ interior t)","name":"IsGŒ¥.dense_union‚Çõ_interior_of_closed","isProp":true,"docString":"If a countable family of closed sets cover a dense `GŒ¥` set, then the union of their interiors\nis dense. Formulated here with `‚ãÉ‚ÇÄ`. "},{"type":"‚àÄ {ùïÜ : Type u_1} {Œ± : Type u_2} [inst : Preorder ùïÜ] [inst_1 : Preorder Œ±] [self : GradeBoundedOrder ùïÜ Œ±] ‚¶Éa : Œ±‚¶Ñ\n  (a_1 : IsMax a), IsMax (GradeOrder.grade a)","name":"GradeBoundedOrder.is_max_grade","isProp":true,"docString":"Maximal elements have maximal grades. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : DecidableEq Œ≤] {f : Œ± ‚Üí. Œ≤}\n  [inst_1 : (x : Œ±) ‚Üí Decidable (Part.Dom (f x) : Prop)] {s : Finset Œ±},\n  Finset.pimage f s =\n    Finset.image\n      (fun (x : { x : Œ± // x ‚àà Finset.filter (fun (x : Œ±) ‚Ü¶ Part.Dom (f x)) s }) ‚Ü¶\n        Part.get (f ‚Üëx)\n          ((And.right\n                ((Iff.mp\n                      ((Finset.mem_filter=:(‚Üëx ‚àà Finset.filter (fun (x : Œ±) ‚Ü¶ Part.Dom (f x)) s : Prop) ‚Üî\n                            ((‚Üëx ‚àà s : Prop) ‚àß (Part.Dom (f ‚Üëx) : Prop) :\n                              Prop))=:(‚Üëx ‚àà Finset.filter (fun (x : Œ±) ‚Ü¶ Part.Dom (f x)) s : Prop) ‚Üî\n                          ((‚Üëx ‚àà s : Prop) ‚àß (Part.Dom (f ‚Üëx) : Prop) : Prop))\n                      ((Subtype.coe_prop\n                            x=:‚Üëx ‚àà fun (x : Œ±) ‚Ü¶\n                            x ‚àà\n                              Finset.val\n                                (Finset.filter (fun (x : Œ±) ‚Ü¶ Part.Dom (f x))\n                                  s))=:‚Üëx ‚àà fun (x : Œ±) ‚Ü¶\n                          x ‚àà\n                            Finset.val\n                              (Finset.filter (fun (x : Œ±) ‚Ü¶ Part.Dom (f x))\n                                s))=:(‚Üëx ‚àà s : Prop) ‚àß\n                      (Part.Dom (f ‚Üëx) :\n                        Prop))=:(‚Üëx ‚àà s : Prop) ‚àß (Part.Dom (f ‚Üëx) : Prop))=:Part.Dom (f ‚Üëx))=:Part.Dom (f ‚Üëx)))\n      (Finset.attach (Finset.filter (fun (x : Œ±) ‚Ü¶ Part.Dom (f x)) s))","name":"Finset.pimage_eq_image_filter","isProp":true,"docString":"Rewrite `s.pimage f` in terms of `Finset.filter`, `Finset.attach`, and `Finset.image`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictMonoOn f s) (hg : StrictMonoOn g s), StrictMonoOn (fun (x : Œ≤) ‚Ü¶ f x * g x) s","name":"StrictMonoOn.mul'","isProp":true,"docString":"The product of two strictly monotone functions is strictly monotone. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M ‚Üí* N) {x : M} {y : M}\n  (h : x = y), ‚Üëf x = ‚Üëf y","name":"MonoidHom.congr_arg","isProp":true,"docString":"Deprecated: use `FunLike.congr_arg` instead. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace.SecondCountableTopology Œ±] [inst_3 : TopologicalSpace.SecondCountableTopology Œ≤],\n  TopologicalSpace.SecondCountableTopology (Œ± ‚äï Œ≤)","name":"TopologicalSpace.instSecondCountableTopologySumInstTopologicalSpaceSum","isProp":true,"docString":"A sum type of two second countable spaces is second countable. "},{"type":"‚àÄ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R} (ab : IsRegular (a * b)) (ba : IsRegular (b * a)),\n  (IsRegular a : Prop) ‚àß (IsRegular b : Prop)","name":"IsRegular.and_of_mul_of_mul","isProp":true,"docString":"The \"most used\" implication of `mul_and_mul_iff`, with split hypotheses, instead of `‚àß`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : IsEmpty Œ±] (s : Finset Œ±), s = ‚àÖ","name":"Finset.eq_empty_of_isEmpty","isProp":true,"docString":"A `Finset` for an empty type is empty. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : b < c) (a_2 : a < b), a < c","name":"LT.lt.trans'","isProp":true,"docString":"**Alias** of `lt_trans'`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (a : LipschitzOnWith K f s), LipschitzWith K (Set.restrict s f)","name":"LipschitzOnWith.to_restrict","isProp":true,"docString":"**Alias** of the forward direction of `lipschitzOnWith_iff_restrict`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : Antitone f),\n  Monotone (f ‚àò ‚ÜëOrderDual.ofDual)","name":"Antitone.dual_left","isProp":true,"docString":"**Alias** of the reverse direction of `monotone_comp_ofDual_iff`."},{"type":"‚àÄ {M : Type u_1} [inst : Nonempty M] [inst : Semigroup M] [inst_1 : TopologicalSpace M] [inst_2 : CompactSpace M]\n  [inst_3 : T2Space M] (continuous_mul_left : ‚àÄ (r : M), Continuous fun (x : M) ‚Ü¶ x * r), ‚àÉ (m : M), m * m = m","name":"exists_idempotent_of_compact_t2_of_continuous_mul_left","isProp":true,"docString":"Any nonempty compact Hausdorff semigroup where right-multiplication is continuous contains\nan idempotent, i.e. an `m` such that `m * m = m`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_3} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] {P : Type u_2} [inst_3 : CommSemiring P] [inst_4 : IsLocalization M S] {g : R ‚Üí+* P}\n  (hg : ‚àÄ (y : { x : R // x ‚àà M }), IsUnit (‚Üëg ‚Üëy)) (x : R) (y : { x : R // x ‚àà M }),\n  ‚Üë(IsLocalization.lift hg) (IsLocalization.mk' S x y) =\n    ‚Üëg x * ‚Üë(‚Üë(IsUnit.liftRight (MonoidHom.restrict (‚Üëg) M) hg) y)‚Åª¬π","name":"IsLocalization.lift_mk'","isProp":true,"docString":"Given a localization map `f : R ‚Üí+* S` for a submonoid `M ‚äÜ R` and a map of `CommSemiring`s\n`g : R ‚Üí* P` such that `g y` is invertible for all `y : M`, the homomorphism induced from\n`S` to `P` maps `f x * (f y)‚Åª¬π` to `g x * (g y)‚Åª¬π` for all `x : R, y ‚àà M`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {M : Type u_3}\n  [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M] {M‚ÇÇ : Type u_4} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R M] [inst_7 : Module S M‚ÇÇ] (self : M ‚ÜíSL[œÉ] M‚ÇÇ),\n  Continuous (AddHom.toFun (LinearMap.toAddHom ‚Üëself))","name":"ContinuousLinearMap.cont","isProp":true,"docString":"Continuous linear maps between modules. We only put the type classes that are necessary for the\ndefinition, although in applications `M` and `M‚ÇÇ` will be topological modules over the topological\nring `R`. "},{"type":"‚àÄ {œÜ : Type w‚ÇÅ} {œÉ : Type w‚ÇÇ} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí (a : œÉ) ‚Üí œÉ √ó œÜ) (x : List Œ±)\n  (y : List Œ≤) (c : œÉ), List.length (Prod.snd (List.mapAccumr‚ÇÇ f x y c)) = min (List.length x) (List.length y)","name":"List.length_mapAccumr‚ÇÇ","isProp":true,"docString":"Length of a list obtained using `mapAccumr‚ÇÇ`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C], CategoryTheory.Limits.HasBinaryProducts C","name":"hasBinaryProducts_of_hasTerminal_and_pullbacks","isProp":true,"docString":"Any category with pullbacks and terminal object has binary products. "},{"type":"‚àÄ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsLeftCancelAdd G], IsCancelAdd G","name":"AddCommSemigroup.IsLeftCancelAdd.toIsCancelAdd","isProp":true,"docString":"Any\n`AddCommSemigroup G` that satisfies `IsLeftCancelAdd G` also satisfies\n`IsCancelAdd G`."},{"type":"‚àÄ {X : Type u} {m‚ÇÅ : (a : X) ‚Üí (a : X) ‚Üí X} {m‚ÇÇ : (a : X) ‚Üí (a : X) ‚Üí X} {e‚ÇÅ : X} {e‚ÇÇ : X}\n  (h‚ÇÅ : EckmannHilton.IsUnital m‚ÇÅ e‚ÇÅ) (h‚ÇÇ : EckmannHilton.IsUnital m‚ÇÇ e‚ÇÇ)\n  (distrib : ‚àÄ (a : X) (b : X) (c : X) (d : X), m‚ÇÅ (m‚ÇÇ a b) (m‚ÇÇ c d) = m‚ÇÇ (m‚ÇÅ a c) (m‚ÇÅ b d)), IsCommutative X m‚ÇÇ","name":"EckmannHilton.mul_comm","isProp":true,"docString":"If a type carries two unital binary operations that distribute over each other,\nthen these operations are commutative.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.CommMonoid`. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {x : M}, x ‚àà powers x","name":"powers.self_mem","isProp":true,"docString":"An element of a monoid is in the set of that element's natural number powers. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] [inst_4 : TopologicalSpace Œ≤] [inst_5 : Zero Œ±] {f : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f)\n  (h : HasCompactSupport f), BddBelow (Set.range f)","name":"Continuous.bddBelow_range_of_hasCompactSupport","isProp":true,"docString":"A continuous function with compact support is bounded below. "},{"type":"‚àÄ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (x : A) (r : R)\n  (y : A), x * ‚Üë(algebraMap R A) r * y = x * y * ‚Üë(algebraMap R A) r","name":"Algebra.right_comm","isProp":true,"docString":"`mul_right_comm` for `Algebra`s when one element is from the base ring. "},{"type":"‚àÄ {n : ‚Ñï} (hn : n ‚â† 0), Nat.totient n = Finsupp.prod (Nat.factorization n) fun (p : ‚Ñï) (k : ‚Ñï) ‚Ü¶ p ^ (k - 1) * (p - 1)","name":"Nat.totient_eq_prod_factorization","isProp":true,"docString":"Euler's product formula for the totient function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] [inst_1 : NoMaxOrder Œ±] (a : Œ±),\n  Filter.map Subtype.val Filter.atTop = Filter.atTop","name":"Filter.map_val_Ioi_atTop","isProp":true,"docString":"The image of the filter `atTop` on `Ioi a` under the coercion equals `atTop`. "},{"type":"‚àÄ {S : Type u_1} [inst : Mul S] {a : S} {b : S} (h : Commute a b), a * b = b * a","name":"Commute.eq","isProp":true,"docString":"Equality behind `Commute a b`; useful for rewriting. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {s : Set Œ±} (a : IsUpperSet s) ‚¶Éa : Œ±‚¶Ñ (a_1 : a ‚àà s), Set.Ioi a ‚äÜ s","name":"IsUpperSet.Ioi_subset","isProp":true,"docString":"**Alias** of the forward direction of `isUpperSet_iff_Ioi_subset`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} (hs : IsCompact s)\n  {t : Set Œ≤} (ht : IsCompact t) {n : Set (Œ± √ó Œ≤)} (hn : IsOpen n) (hp : s √óÀ¢ t ‚äÜ n),\n  ‚àÉ (u : Set Œ±),\n    ‚àÉ (v : Set Œ≤),\n      (IsOpen u : Prop) ‚àß\n        ((IsOpen v : Prop) ‚àß ((s ‚äÜ u : Prop) ‚àß ((t ‚äÜ v : Prop) ‚àß (u √óÀ¢ v ‚äÜ n : Prop) : Prop) : Prop) : Prop)","name":"generalized_tube_lemma","isProp":true,"docString":"If `s` and `t` are compact sets and `n` is an open neighborhood of `s √ó t`, then there exist\nopen neighborhoods `u ‚äá s` and `v ‚äá t` such that `u √ó v ‚äÜ n`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {x : Œ±} {s : Set Œ≤} {F : Filter (Œ± √ó Œ≤)},\n  (s ‚àà Filter.comap (Prod.mk x) F : Prop) ‚Üî\n    ((setOf fun (p : Œ± √ó Œ≤) ‚Ü¶ ‚àÄ (a : Prod.fst p = x), Prod.snd p ‚àà s) ‚àà F : Prop)","name":"Filter.mem_comap_prod_mk","isProp":true,"docString":"RHS form is used, e.g., in the definition of `UniformSpace`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictAnti f) (hg : Antitone g), StrictAnti fun (x : Œ≤) ‚Ü¶ f x * g x","name":"StrictAnti.mul_antitone'","isProp":true,"docString":"The product of a strictly antitone function and a antitone function is strictly antitone. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = ‚Üë(Subgroup.center G)","name":"ConjAct.fixedPoints_eq_center","isProp":true,"docString":"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. "},{"type":"‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} {y : Œ±} {m : ‚Ñï} {n : ‚Ñï} (hx : Function.IsPeriodicPt f m x)\n  (hy : Function.IsPeriodicPt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y), x = y","name":"Function.IsPeriodicPt.eq_of_apply_eq","isProp":true,"docString":"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\nthen `x = y`. "},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : FrechetUrysohnSpace X] {f : (a : X) ‚Üí Y} {a : X} {b : Y},\n  (Filter.Tendsto f (nhds a) (nhds b) : Prop) ‚Üî\n    (‚àÄ (u : (a : ‚Ñï) ‚Üí X) (a : Filter.Tendsto u Filter.atTop (nhds a)), Filter.Tendsto (f ‚àò u) Filter.atTop (nhds b) :\n      Prop)","name":"tendsto_nhds_iff_seq_tendsto","isProp":true,"docString":"If the domain of a function `f : Œ± ‚Üí Œ≤` is a Fr√©chet-Urysohn space, then convergence\nis equivalent to sequential convergence. See also `Filter.tendsto_iff_seq_tendsto` for a version\nthat works for any pair of filters assuming that the filter in the domain is countably generated.\n\nThis property is equivalent to the definition of `FrechetUrysohnSpace`, see\n`FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : (a : Œ≤) ‚Üí Œ≥} {s : Set Œ≤} {x : Œ≤}\n  (h : x ‚àà LocalEquiv.target (LocalHomeomorph.toLocalEquiv e)),\n  (ContinuousWithinAt f s x : Prop) ‚Üî (ContinuousWithinAt (f ‚àò ‚Üëe) (‚Üëe ‚Åª¬π' s) (‚Üë(LocalHomeomorph.symm e) x) : Prop)","name":"LocalHomeomorph.continuousWithinAt_iff_continuousWithinAt_comp_right","isProp":true,"docString":"Continuity within a set at a point can be read under right composition with a local\nhomeomorphism, if the point is in its target "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_4} {Œπ : Type u_1} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} {f : Filter Œ±}\n  (hf : Filter.HasBasis f p s) {Œ≤ : (a : Œπ) ‚Üí Type u_3} {pg : (i : Œπ) ‚Üí (a : Œ≤ i) ‚Üí Prop}\n  {sg : (i : Œπ) ‚Üí (a : Œ≤ i) ‚Üí Set Œ≥} {g : (a : Set Œ±) ‚Üí Filter Œ≥}\n  (hg : ‚àÄ (i : Œπ), Filter.HasBasis (g (s i)) (pg i) (sg i)) (gm : Monotone g),\n  Filter.HasBasis (Filter.lift f g)\n    (fun (i : (i : Œπ) √ó Œ≤ i) ‚Ü¶ (p (Sigma.fst i) : Prop) ‚àß (pg (Sigma.fst i) (Sigma.snd i) : Prop))\n    fun (i : (i : Œπ) √ó Œ≤ i) ‚Ü¶ sg (Sigma.fst i) (Sigma.snd i)","name":"Filter.HasBasis.lift","isProp":true,"docString":"If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí Set Œ±)` is a basis of a filter `f`, `g` is a monotone function\n`Set Œ± ‚Üí Filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí Set Œ±)` is a basis\nof the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`\nis a basis of the filter `f.lift g`.\n\nThis basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using\n`has_basis` one has to use `Œ£ i, Œ≤ i` as the index type. See also `Filter.HasBasis.mem_lift_iff`\nfor the corresponding `mem_iff` statement formulated without using a sigma type. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] (p : ‚Ñï) (q : ‚Ñï) [hp : CharP R p] [hq : ExpChar R q],\n  (p = q : Prop) ‚Üî (Nat.Prime p : Prop)","name":"char_eq_expChar_iff","isProp":true,"docString":"The characteristic equals the exponential characteristic iff the former is prime. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} {r : R} (h : SameRay R x y) (hr : 0 ‚â§ r), SameRay R (r ‚Ä¢ x) y","name":"SameRay.nonneg_smul_left","isProp":true,"docString":"A nonnegative multiple of a vector is in the same ray as one it is in the same ray as. "},{"type":"‚àÄ {n : ‚Ñï} {i : Fin (n + 1)}, SimplexCategory.Œ¥ (‚ÜëFin.castSucc i) ‚â´ SimplexCategory.œÉ i = ùüô (SimplexCategory.mk n)","name":"SimplexCategory.Œ¥_comp_œÉ_self","isProp":true,"docString":"The first part of the third simplicial identity "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type w} [inst_4 : Fintype Œπ] (h : Basis Œπ R M), Module.rank R M = ‚Üë(Fintype.card Œπ)","name":"rank_eq_card_basis","isProp":true,"docString":"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. "},{"type":"‚àÄ {ùïú : Type u_1} {M : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : LinearOrderedAddCommMonoid M]\n  [inst_2 : SMulWithZero ùïú M] (h : ‚àÄ ‚¶Éc : ùïú‚¶Ñ (a : 0 < c), StrictMono fun (a : M) ‚Ü¶ c ‚Ä¢ a), OrderedSMul ùïú M","name":"OrderedSMul.mk''","isProp":true,"docString":"To prove that a linear ordered monoid is an ordered module, it suffices to verify only the first\naxiom of `OrderedSMul`. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) (L' : List (List Œ±)),\n  (L = L' : Prop) ‚Üî\n    ((List.join L = List.join L' : Prop) ‚àß (List.map List.length L = List.map List.length L' : Prop) : Prop)","name":"List.eq_iff_join_eq","isProp":true,"docString":"Two lists of sublists are equal iff their joins coincide, as well as the lengths of the\nsublists. "},{"type":"‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a : B} {b : B}\n  (f : a ‚ü∂ b), f ‚â´ ùüô b = f","name":"CategoryTheory.Bicategory.Strict.comp_id","isProp":true,"docString":"Identity morphisms are right identities for composition. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} [self : CategoryTheory.IsIso f],\n  ‚àÉ (inv : Y ‚ü∂ X), (f ‚â´ inv = ùüô X : Prop) ‚àß (inv ‚â´ f = ùüô Y : Prop)","name":"CategoryTheory.IsIso.out","isProp":true,"docString":"The existence of an inverse morphism. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b), Set.Iio a ‚äÜ Set.Iio b","name":"Set.Iio_subset_Iio","isProp":true,"docString":"If `a ‚â§ b`, then `(-‚àû, a) ‚äÜ (-‚àû, b)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Iio_subset_Iio_iff`. "},{"type":"‚àÄ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (Œ± : Type v) (s : (a : Œ±) ‚Üí Set X)\n  (x : ‚àÄ (a : Œ±), IsOpen (s a)) (x : (Set.union·µ¢ fun (a : Œ±) ‚Ü¶ s a) = Set.univ),\n  ‚àÉ (Œ≤ : Type v),\n    ‚àÉ (t : (a : Œ≤) ‚Üí Set X),\n      ‚àÉ (x : ‚àÄ (b : Œ≤), IsOpen (t b)),\n        ‚àÉ (x : (Set.union·µ¢ fun (b : Œ≤) ‚Ü¶ t b) = Set.univ),\n          (LocallyFinite t : Prop) ‚àß (‚àÄ (b : Œ≤), ‚àÉ (a : Œ±), t b ‚äÜ s a : Prop)","name":"ParacompactSpace.locallyFinite_refinement","isProp":true,"docString":"Every open cover of a paracompact space assumes a locally finite refinement. "},{"type":"‚àÄ {Œ± : Type u_1} [self : DivisionSemiring Œ±], 0‚Åª¬π = 0","name":"DivisionSemiring.inv_zero","isProp":true,"docString":"The inverse of `0` in a group with zero is `0`. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {S : Set (Con M)}, sup‚Çõ S = conGen (sup‚Çõ (FunLike.coe '' S))","name":"Con.sup‚Çõ_def","isProp":true,"docString":"The supremum of a set of congruence relations is the same as the smallest congruence relation\ncontaining the supremum of the set's image under the map to the underlying binary relation. "},{"type":"‚àÄ {ùïú : Type u_3} {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField ùïú] (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop)\n  [inst_1 : (a : Œ±) ‚Üí DecidablePred (r a)] {s‚ÇÅ : Finset Œ±} {s‚ÇÇ : Finset Œ±} {t‚ÇÅ : Finset Œ≤} {t‚ÇÇ : Finset Œ≤} {Œ¥ : ùïú}\n  (hs : s‚ÇÇ ‚äÜ s‚ÇÅ) (ht : t‚ÇÇ ‚äÜ t‚ÇÅ) (hŒ¥ : 0 ‚â§ Œ¥) (hscard : (1 - Œ¥) * ‚Üë(Finset.card s‚ÇÅ) ‚â§ ‚Üë(Finset.card s‚ÇÇ))\n  (htcard : (1 - Œ¥) * ‚Üë(Finset.card t‚ÇÅ) ‚â§ ‚Üë(Finset.card t‚ÇÇ)),\n  abs (‚Üë(Rel.edgeDensity r s‚ÇÇ t‚ÇÇ) - ‚Üë(Rel.edgeDensity r s‚ÇÅ t‚ÇÅ)) ‚â§ 2 * Œ¥","name":"Rel.abs_edgeDensity_sub_edgeDensity_le_two_mul","isProp":true,"docString":"If `s‚ÇÇ ‚äÜ s‚ÇÅ`, `t‚ÇÇ ‚äÜ t‚ÇÅ` and they take up all but a `Œ¥`-proportion, then the difference in edge\ndensities is at most `2 * Œ¥`. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú) (i : Fin r ‚äï Unit) {k : ‚Ñï}\n  (hk : k ‚â§ r),\n  Matrix.mul M (List.prod (List.take k (Matrix.Pivot.listTransvecRow M))) i (Sum.inr ()) = M i (Sum.inr ())","name":"Matrix.Pivot.mul_listTransvecRow_last_col_take","isProp":true,"docString":"Multiplying by some of the matrices in `listTransvecRow M` does not change the last column. "},{"type":"‚àÄ {G : Type u_2} {H : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : OrderedAddCommGroup H] {f : (a : G) ‚Üí H}\n  (h‚ÇÅ : ‚àÄ (x : G), f (-x) = -f x) (h‚ÇÇ : AntitoneOn f (Set.Ici 0)), Antitone f","name":"antitone_of_odd_of_monotoneOn_nonneg","isProp":true,"docString":"An odd function on a linear ordered additive commutative group is antitone on the whole group\nprovided that it is monotone on `Set.Ici 0`. "},{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f‚ÇÄ : C(X, Y)} {f‚ÇÅ : C(X, Y)}\n  (self : ContinuousMap.Homotopy f‚ÇÄ f‚ÇÅ) (x : X),\n  ContinuousMap.toFun (ContinuousMap.Homotopy.toContinuousMap self) (1, x) = ‚Üëf‚ÇÅ x","name":"ContinuousMap.Homotopy.map_one_left","isProp":true,"docString":"value of the homotopy at 1 "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {M : Type u_3} {N : Type u_1} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid N]\n  (f : (a : Œ±) ‚Üí Œ≤) (v : Œ± ‚Üí‚ÇÄ M) (g : (a : M) ‚Üí N) (h0 : g 0 = 0) (hadd : ‚àÄ (x : M) (y : M), g (x + y) = g x + g y),\n  Finsupp.mapDomain f (Finsupp.mapRange g h0 v) = Finsupp.mapRange g h0 (Finsupp.mapDomain f v)","name":"Finsupp.mapDomain_mapRange","isProp":true,"docString":"When `g` preserves addition, `mapRange` and `mapDomain` commute. "},{"type":"‚àÄ (k : Type u_4) {V : Type u_5} {P : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) {Œπ‚ÇÇ : Type u_3} (s‚ÇÇ : Finset Œπ‚ÇÇ) {p : (a : Œπ) ‚Üí P}\n  (hi : ‚àÄ (i : Œπ) (x : i ‚àà s) (j : Œπ) (x : j ‚àà s) (a : p i = p j), i = j) {p‚ÇÇ : (a : Œπ‚ÇÇ) ‚Üí P}\n  (hi‚ÇÇ : ‚àÄ (i : Œπ‚ÇÇ) (x : i ‚àà s‚ÇÇ) (j : Œπ‚ÇÇ) (x : j ‚àà s‚ÇÇ) (a : p‚ÇÇ i = p‚ÇÇ j), i = j) (he : p '' ‚Üës = p‚ÇÇ '' ‚Üës‚ÇÇ),\n  Finset.centroid k s p = Finset.centroid k s‚ÇÇ p‚ÇÇ","name":"Finset.centroid_eq_of_inj_on_of_image_eq","isProp":true,"docString":"Two indexed families of points that are injective on the given\n`Finset`s and with the same points in the image of those `Finset`s\nhave the same centroid. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : CompleteLattice Œ±] {f : (a : Œπ) ‚Üí Œ±} {b : Œ±} (a : ‚àÄ (i : Œπ), b ‚â§ f i)\n  (a : ‚àÄ (w : Œ±) (a : b < w), ‚àÉ (i : Œπ), f i < w), (inf·µ¢ fun (i : Œπ) ‚Ü¶ f i) = b","name":"inf·µ¢_eq_of_forall_ge_of_forall_gt_exists_lt","isProp":true,"docString":"Introduction rule to prove that `b` is the infimum of `f`: it suffices to check that `b`\nis smaller than `f i` for all `i`, and that this is not the case of any `w>b`.\nSee `cinf·µ¢_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in conditionally complete\nlattices. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_4} {Œ¥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  {i : (a : Œ±) ‚Üí Œ≤} [inst_2 : TopologicalSpace Œ¥] {f : (a : Œ≥) ‚Üí Œ±} {g : (a : Œ≥) ‚Üí Œ¥} {h : (a : Œ¥) ‚Üí Œ≤} {d : Œ¥} {a : Œ±}\n  (di : DenseInducing i) (H : Filter.Tendsto h (nhds d) (nhds (i a))) (comm : h ‚àò g = i ‚àò f),\n  Filter.Tendsto f (Filter.comap g (nhds d)) (nhds a)","name":"DenseInducing.tendsto_comap_nhds_nhds","isProp":true,"docString":"```\n Œ≥ -f‚Üí Œ±\ng‚Üì     ‚Üìe\n Œ¥ -h‚Üí Œ≤\n```\n"},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {s : CategoryTheory.Limits.Cocone F} {t : CategoryTheory.Limits.Cocone F} (P : CategoryTheory.Limits.IsColimit s)\n  (Q : CategoryTheory.Limits.IsColimit t) (f : s ‚ü∂ t), CategoryTheory.IsIso f","name":"CategoryTheory.Limits.IsColimit.hom_isIso","isProp":true,"docString":"Any cocone morphism between colimit cocones is an isomorphism. "},{"type":"‚àÄ {R : Type u_1} {Œπ‚ÇÅ : Type u_4} {Œπ‚ÇÇ : Type u_6} {Œπ‚ÇÉ : Type u_7} {Œπ‚ÇÑ : Type u_8} [inst : CommSemiring R] {N‚ÇÅ : Type u_3}\n  [inst_1 : AddCommMonoid N‚ÇÅ] [inst_2 : Module R N‚ÇÅ] {N‚ÇÇ : Type u_5} [inst_3 : AddCommMonoid N‚ÇÇ] [inst_4 : Module R N‚ÇÇ]\n  {N : Type u_2} [inst_5 : AddCommMonoid N] [inst_6 : Module R N] (a : MultilinearMap R (fun (x : Œπ‚ÇÅ) ‚Ü¶ N) N‚ÇÅ)\n  (b : MultilinearMap R (fun (x : Œπ‚ÇÇ) ‚Ü¶ N) N‚ÇÇ) (œÉa : Œπ‚ÇÅ ‚âÉ Œπ‚ÇÉ) (œÉb : Œπ‚ÇÇ ‚âÉ Œπ‚ÇÑ),\n  MultilinearMap.domDomCongr (Equiv.sumCongr œÉa œÉb) (MultilinearMap.domCoprod a b) =\n    MultilinearMap.domCoprod (MultilinearMap.domDomCongr œÉa a) (MultilinearMap.domDomCongr œÉb b)","name":"MultilinearMap.domCoprod_domDomCongr_sumCongr","isProp":true,"docString":"When passed an `Equiv.sumCongr`, `MultilinearMap.domDomCongr` distributes over\n`MultilinearMap.domCoprod`. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M) {x : M} {y : M} (a : x ‚àà S) (a : y ‚àà S), x * y ‚àà S","name":"Submonoid.mul_mem","isProp":true,"docString":"A submonoid is closed under multiplication. "},{"type":"‚àÄ {Œ± : Type u_1} (r : Setoid Œ±), EqvGen.Setoid Setoid.r = r","name":"Setoid.eqvGen_of_setoid","isProp":true,"docString":"The equivalence closure of an equivalence relation r is r. "},{"type":"‚àÄ {ùïú : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {C : ùïú} (hC : C < 0) (hf : Filter.Tendsto f l Filter.atTop)\n  (hg : Filter.Tendsto g l (nhds C)), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * g x) l Filter.atBot","name":"Filter.Tendsto.atTop_mul_neg","isProp":true,"docString":"In a linearly ordered field with the order topology, if `f` tends to `Filter.atTop` and `g`\ntends to a negative constant `C` then `f * g` tends to `Filter.atBot`. "},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) {Œπ : Type u_3} [inst : UniformSpace Œ≤] (f : UniformFun Œ± Œ≤) {p : (a : Œπ) ‚Üí Prop}\n  {s : (a : Œπ) ‚Üí Set (Œ≤ √ó Œ≤)} (h : Filter.HasBasis (uniformity Œ≤) p s),\n  Filter.HasBasis (nhds f) p fun (i : Œπ) ‚Ü¶ setOf fun (g : UniformFun Œ± Œ≤) ‚Ü¶ (f, g) ‚àà UniformFun.gen Œ± Œ≤ (s i)","name":"UniformFun.hasBasis_nhds_of_basis","isProp":true,"docString":"For `f : Œ± ‚Üí·µ§ Œ≤`, `ùìù f` admits the family `{g | ‚àÄ x, (f x, g x) ‚àà V}` for `V ‚àà ùìë` as a filter\nbasis, for any basis `ùìë` of `ùì§ Œ≤`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p‚ÇÅ : P) (p‚ÇÇ : P), vectorSpan k {p‚ÇÅ, p‚ÇÇ} = Submodule.span k {p‚ÇÇ -·µ• p‚ÇÅ}","name":"vectorSpan_pair_rev","isProp":true,"docString":"The `vectorSpan` of two points is the span of their difference (reversed). "},{"type":"‚àÄ {k : Type u_2} {V : Type u_4} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} [inst_4 : Nontrivial k] {s : Finset Œπ} {w : (a : Œπ) ‚Üí k}\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.affineCombination k s p) w ‚àà affineSpan k (Set.range p)","name":"affineCombination_mem_affineSpan","isProp":true,"docString":"An `affineCombination` with sum of weights 1 is in the\n`affineSpan` of an indexed family, if the underlying ring is\nnontrivial. "},{"type":"‚àÄ {Œ± : Sort u_1} {a : Œ±} {b : Œ±} (a_1 : a = b), HEq a b","name":"Eq.heq","isProp":true,"docString":"**Alias** of the reverse direction of `heq_iff_eq`."},{"type":"‚àÄ {Œπ : Type u_2} [inst : Nontrivial Œπ] {G : Type u_1} [inst : Group G] (a : (a : Œπ) ‚Üí G) {Œ± : Type u_3}\n  [inst_1 : MulAction G Œ±] (X : (a : Œπ) ‚Üí Set Œ±) (Y : (a : Œπ) ‚Üí Set Œ±) (hXnonempty : ‚àÄ (i : Œπ), Set.Nonempty (X i))\n  (hXdisj : Pairwise fun (i : Œπ) (j : Œπ) ‚Ü¶ Disjoint (X i) (X j))\n  (hYdisj : Pairwise fun (i : Œπ) (j : Œπ) ‚Ü¶ Disjoint (Y i) (Y j)) (hXYdisj : ‚àÄ (i : Œπ) (j : Œπ), Disjoint (X i) (Y j))\n  (hX : ‚àÄ (i : Œπ), a i ‚Ä¢ Y i·∂ú ‚äÜ X i) (hY : ‚àÄ (i : Œπ), a‚Åª¬π i ‚Ä¢ X i·∂ú ‚äÜ Y i), Function.Injective ‚Üë(‚ÜëFreeGroup.lift a)","name":"FreeGroup.injective_lift_of_ping_pong","isProp":true,"docString":"The Ping-Pong-Lemma.\n\nGiven a group action of `G` on `X` so that the generators of the free groups act in specific\nways on disjoint subsets `X i` and `Y i` we can prove that `lift f` is injective, and thus the image\nof `lift f` is isomorphic to the free group.\n\nOften the Ping-Pong-Lemma is stated with regard to group elements that generate the whole group;\nwe generalize to arbitrary group homomorphisms from the free group to `G`  and do not require the\ngroup to be generated by the elements.\n"},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] {p1 : P} {p2 : P},\n  (p1 -·µ• p2 = 0 : Prop) ‚Üî (p1 = p2 : Prop)","name":"vsub_eq_zero_iff_eq","isProp":true,"docString":"Subtracting two points produces 0 if and only if they are\nequal. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ±) ‚Üí Œ≤ √ó Œ≥} (hf : Continuous f), Continuous fun (a : Œ±) ‚Ü¶ Prod.snd (f a)","name":"Continuous.snd","isProp":true,"docString":"Postcomposing `f` with `Prod.snd` is continuous "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V} {g : V ‚Üí‚Çó[K] V}, (f * g = 1 : Prop) ‚Üî (g * f = 1 : Prop)","name":"LinearMap.mul_eq_one_comm","isProp":true,"docString":"In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {b : M}\n  [inst_1 : LinearOrderedCommSemiring M] (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚àà t)\n  (ht : Finset.card t ‚Ä¢ b < ‚Üë(Finset.card s)),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (b < ‚Üë(Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s)) : Prop)","name":"Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with\nat least as many pigeons as the ceiling of the average number of pigeons across all pigeonholes. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ≤} {g : (a : Œ≤) ‚Üí Œ±}\n  (hg : Set.InjOn g s),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà g '' s) ‚Ü¶ f i) = finprod fun (j : Œ≤) ‚Ü¶ finprod fun (h : j ‚àà s) ‚Ü¶ f (g j)","name":"finprod_mem_image","isProp":true,"docString":"The product of `f y` over `y ‚àà g '' s` equals the product of `f (g i)` over `s` provided that\n`g` is injective on `s`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : TopologicalSpace Œ±] [inst_1 : PolishSpace Œ±] [inst_2 : Nonempty Œ±],\n  ‚àÉ (f : (a : (a : ‚Ñï) ‚Üí ‚Ñï) ‚Üí Œ±), (Continuous f : Prop) ‚àß (Function.Surjective f : Prop)","name":"PolishSpace.exists_nat_nat_continuous_surjective","isProp":true,"docString":"Any nonempty Polish space is the continuous image of the fundamental space `‚Ñï ‚Üí ‚Ñï`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±] {a : Œ±} {f : (a : ‚Ñï) ‚Üí Œ±} (h : HasSum f a),\n  Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f i) Filter.atTop (nhds a)","name":"HasSum.tendsto_sum_nat","isProp":true,"docString":"If `f : ‚Ñï ‚Üí Œ±` has sum `a`, then the partial sums `‚àë_{i=0}^{n-1} f i` converge to `a`. "},{"type":"‚àÄ {Œ≤ : Type v} {œÄ : (a : Œ≤) ‚Üí Type u_1} [inst : Fintype Œ≤] [inst_1 : (b : Œ≤) ‚Üí PseudoMetricSpace (œÄ b)]\n  (x : (b : Œ≤) ‚Üí œÄ b) {r : ‚Ñù} (hr : 0 ‚â§ r),\n  Metric.closedBall x r = Set.pi Set.univ fun (b : Œ≤) ‚Ü¶ Metric.closedBall (x b) r","name":"closedBall_pi","isProp":true,"docString":"A closed ball in a product space is a product of closed balls. See also `metric.closed_ball_pi'`\nfor a version assuming `Nonempty Œ≤` instead of `0 ‚â§ r`. "},{"type":"‚àÄ {E : Type u_1} [self : NormedAddGroup E] (x : E) (y : E), dist x y = ‚Äñx - y‚Äñ","name":"NormedAddGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {Œ± : Type} {d : ‚Ñï} {ds : List ‚Ñï} (x : Holor Œ± (d :: ds)) (y : Holor Œ± (d :: ds)) (h : Holor.slice x = Holor.slice y),\n  x = y","name":"Holor.slice_eq","isProp":true,"docString":"Two holors are equal if all their slices are equal. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {A : Finset Œ±} {B : Finset Œ±} (t : Œ±) (h‚ÇÅ : Finset.toColex A < Finset.toColex B)\n  (h‚ÇÇ : ‚àÄ (x : Œ±) (a : x ‚àà B), x < t) (x : Œ±) (a : x ‚àà A), x < t","name":"Colex.forall_lt_of_colex_lt_of_forall_lt","isProp":true,"docString":"If `A` is before `B` in colex, and everything in `B` is small, then everything in `A` is small.\n"},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] [inst_1 : DecidableEq Œ±] (s : Finset Œ±) (f : (a : Œ±) ‚Üí Œ≤) {a : Œ±}\n  (h : a ‚àà s), (Finset.prod (Finset.erase s a) fun (x : Œ±) ‚Ü¶ f x) * f a = Finset.prod s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.prod_erase_mul","isProp":true,"docString":"A variant of `Finset.mul_prod_erase` with the multiplication swapped. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hst : Disjoint s t)\n  (hs : Set.Finite s) (ht : Set.Finite t),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) =\n    (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà t) ‚Ü¶ f i","name":"finsum_mem_union","isProp":true,"docString":"Given two finite disjoint sets `s` and `t`, the sum of `f i` over `i ‚àà s ‚à™ t` equals\nthe sum of `f i` over `i ‚àà s` plus the sum of `f i` over `i ‚àà t`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±) (y : Œ±), dist x y = ENNReal.toReal (edist x y)","name":"dist_edist","isProp":true,"docString":"Express `dist` in terms of `edist`"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {E : Type u_3}\n  [inst_2 : Norm E] {F : Type u_4} [inst_3 : Norm F] (e : LocalHomeomorph Œ± Œ≤) {b : Œ≤}\n  (hb : b ‚àà LocalEquiv.target (LocalHomeomorph.toLocalEquiv e)) {f : (a : Œ≤) ‚Üí E} {g : (a : Œ≤) ‚Üí F},\n  (f =O[nhds b] g : Prop) ‚Üî ((f ‚àò ‚Üëe) =O[nhds (‚Üë(LocalHomeomorph.symm e) b)] (g ‚àò ‚Üëe) : Prop)","name":"LocalHomeomorph.isBigO_congr","isProp":true,"docString":"Transfer `IsBigO` over a `LocalHomeomorph`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hc : c ‚â† 0),\n  (a * c ‚à£ b * c : Prop) ‚Üî (a ‚à£ b : Prop)","name":"mul_dvd_mul_iff_right","isProp":true,"docString":"Given two elements `a`, `b` of a commutative `CancelMonoidWithZero` and a nonzero\nelement `c`, `a*c` divides `b*c` iff `a` divides `b`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Fintype Œ±] {t : Finset Œ≤} (hŒ±t : Fintype.card Œ± = Finset.card t) {s : Set Œ±}\n  {f : (a : Œ±) ‚Üí Œ≤} (hfst : Set.MapsTo f s ‚Üët) (hfs : Set.InjOn f s),\n  ‚àÉ (g : Œ± ‚âÉ { x : Œ≤ // x ‚àà t }), ‚àÄ (i : Œ±) (a : i ‚àà s), ‚Üë(‚Üëg i) = f i","name":"Set.MapsTo.exists_equiv_extend_of_card_eq","isProp":true,"docString":"Any injection from a set `s` in a fintype `Œ±` to a finset `t` of the same cardinality as `Œ±`\ncan be extended to a bijection between `Œ±` and `t`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ‚àà s) (v : V),\n  (v ‚àà AffineSubspace.direction s : Prop) ‚Üî (‚àÉ (p2 : P), (p2 ‚àà s : Prop) ‚àß (v = p2 -·µ• p : Prop) : Prop)","name":"AffineSubspace.mem_direction_iff_eq_vsub_right","isProp":true,"docString":"Given a point in an affine subspace, a vector is in its direction if and only if it results from\nsubtracting that point on the right. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Antivary f g),\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i) ‚â§ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i)","name":"Antivary.sum_mul_le_sum_mul_comp_perm","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and\n`g` antivary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddSemigroup M] (a : Stream' M) (s : Set (Set M)) (sfin : Set.Finite s)\n  (scov : Hindman.FS a ‚äÜ ‚ãÉ‚ÇÄ s), ‚àÉ (c : Set M), (c ‚àà s : Prop) ‚àß (‚àÉ (b : Stream' M), Hindman.FS b ‚äÜ c : Prop)","name":"Hindman.FS_partition_regular","isProp":true,"docString":"The strong form of **Hindman's theorem**: in any finite cover of\nan FS-set, one the parts contains an FS-set."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : (a : Fin n) ‚Üí Œ±} {œÉ : Equiv.Perm (Fin n)},\n  (f ‚àò ‚ÜëœÉ) ‚àò ‚Üë(Tuple.sort (f ‚àò ‚ÜëœÉ)) = f ‚àò ‚Üë(Tuple.sort f)","name":"Tuple.comp_perm_comp_sort_eq_comp_sort","isProp":true,"docString":"The sorted versions of a tuple `f` and of any permutation of `f` agree. "},{"type":"‚àÄ {R : Type u_1} [inst : LeftCancelSemigroup R] (g : R), IsLeftRegular g","name":"isLeftRegular_of_leftCancelSemigroup","isProp":true,"docString":"Elements of a left cancel semigroup are left regular. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {k : Set Œ≤} {s : Set Œ≤}\n  {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hs : IsOpen s) (hks : k ‚äÜ s) (hf : ContinuousOn f s),\n  ‚àÉ (t : Set Œ≤), (k ‚äÜ t : Prop) ‚àß ((IsOpen t : Prop) ‚àß (Metric.Bounded (f '' t) : Prop) : Prop)","name":"Metric.exists_isOpen_bounded_image_of_isCompact_of_continuousOn","isProp":true,"docString":"If a function is continuous on a neighborhood of a compact set `k`, then it is bounded on\nsome open neighborhood of `k`. "},{"type":"‚àÄ {R : Type u_1} [inst : CancelCommMonoidWithZero R] {x : R} {y : R} {a : R} {p : R} {n : ‚Ñï} (hp : Prime p)\n  (hx : x * y = a * p ^ n),\n  ‚àÉ (i : ‚Ñï),\n    ‚àÉ (j : ‚Ñï),\n      ‚àÉ (b : R),\n        ‚àÉ (c : R),\n          (i + j = n : Prop) ‚àß ((a = b * c : Prop) ‚àß ((x = b * p ^ i : Prop) ‚àß (y = c * p ^ j : Prop) : Prop) : Prop)","name":"mul_eq_mul_prime_pow","isProp":true,"docString":"If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written\nas the product of a power of `p` and a divisor of `a`. "},{"type":"‚àÄ {Œπ : Type u} {Œ≥ : Type w} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] {Œ¥ : Type u_1}\n  [inst : (i : Œπ) ‚Üí AddZeroClass (Œ≤ i)] [inst_1 : AddCommMonoid Œ≥] [inst_2 : AddCommMonoid Œ¥] (g : Œ≥ ‚Üí+ Œ¥)\n  (f : (i : Œπ) ‚Üí Œ≤ i ‚Üí+ Œ≥),\n  AddMonoidHom.comp g (‚ÜëDfinsupp.liftAddHom f) = ‚ÜëDfinsupp.liftAddHom fun (a : Œπ) ‚Ü¶ AddMonoidHom.comp g (f a)","name":"Dfinsupp.comp_liftAddHom","isProp":true,"docString":"The `Dfinsupp` version of `Finsupp.comp_liftAddHom`,"},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasLimitsOfSize C],\n  CategoryTheory.Limits.HasLimitsOfSize C","name":"CategoryTheory.Limits.hasLimitsOfSizeShrink","isProp":true,"docString":"`hasLimitsOfSizeShrink.{v u} C` tries to obtain `HasLimitsOfSize.{v u} C`\nfrom some other `HasLimitsOfSize C`.\n"},{"type":"‚àÄ {E : Sort u_1} {Œ± : outParam (Sort u_2)} {Œ≤ : outParam (Sort u_3)} [self : EquivLike E Œ± Œ≤] (e : E),\n  Function.LeftInverse (EquivLike.inv e) (EquivLike.coe e)","name":"EquivLike.left_inv","isProp":true,"docString":"The coercions are left inverses. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsCompact s : Prop) ‚Üî\n    (‚àÄ {Œπ : Type u} (Z : (a : Œπ) ‚Üí Set Œ±) (a : ‚àÄ (i : Œπ), IsClosed (Z i)) (a : (s ‚à© Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Z i) = ‚àÖ),\n        ‚àÉ (t : Finset Œπ), (s ‚à© Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà t) ‚Ü¶ Z i) = ‚àÖ :\n      Prop)","name":"isCompact_iff_finite_subfamily_closed","isProp":true,"docString":"A set `s` is compact if and only if\nfor every family of closed sets whose intersection avoids `s`,\nthere exists a finite subfamily whose intersection avoids `s`. "},{"type":"‚àÄ {S : Set Ordinal} (o : Ordinal),\n  Ordinal.enumOrd S o = inf‚Çõ (S ‚à© setOf fun (b : Ordinal) ‚Ü¶ ‚àÄ (c : Ordinal) (a : c < o), Ordinal.enumOrd S c < b)","name":"Ordinal.enumOrd_def","isProp":true,"docString":"A more workable definition for `enumOrd`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {s : Set G} {p : (a : G) ‚Üí Prop} {x : G} (h : x ‚àà AddSubgroup.closure s)\n  (Hk : ‚àÄ (x : G) (a : x ‚àà s), p x) (Hk_inv : ‚àÄ (x : G) (a : x ‚àà s), p (-x)) (H1 : p 0)\n  (Hmul : ‚àÄ (x : G) (y : G) (a : p x) (a : p y), p (x + y)), p x","name":"AddSubgroup.closure_induction''","isProp":true,"docString":"An induction principle for additive closure membership. If `p` holds for `0` and all\nelements of `k` and their negation, and is preserved under addition, then `p` holds for all\nelements of the additive closure of `k`."},{"type":"‚àÄ {C : Type u} [ùíû : CategoryTheory.Category C] [self : CategoryTheory.MonoidalCategory C] (X‚ÇÅ : C) (X‚ÇÇ : C),\n  ùüô X‚ÇÅ ‚äó ùüô X‚ÇÇ = ùüô (X‚ÇÅ ‚äó X‚ÇÇ)","name":"CategoryTheory.MonoidalCategory.tensor_id","isProp":true,"docString":"Tensor product of identiy maps is the identity: `(ùüô X‚ÇÅ ‚äó ùüô X‚ÇÇ) = ùüô (X‚ÇÅ ‚äó X‚ÇÇ)` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : DecidableEq Œ±] {A : Finset Œ±} (hA : Finset.Nonempty A) (B : Finset Œ±)\n  (m : ‚Ñï) (n : ‚Ñï),\n  ‚Üë(Finset.card (m ‚Ä¢ B - n ‚Ä¢ B)) ‚â§ (‚Üë(Finset.card (A - B)) / ‚Üë(Finset.card A)) ^ (m + n) * ‚Üë(Finset.card A)","name":"Finset.card_nsmul_sub_nsmul_le'","isProp":true,"docString":"The **Pl√ºnnecke-Ruzsa inequality**. Subtraction version."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±], Subsingleton (SuccOrder Œ±)","name":"Order.instSubsingletonSuccOrderToPreorder","isProp":true,"docString":"There is at most one way to define the successors in a `PartialOrder`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {E : Type u_3}\n  [inst_2 : Norm E] {F : Type u_4} [inst_3 : Norm F] (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : (a : Œ≤) ‚Üí E} {g : (a : Œ≤) ‚Üí F},\n  (f =O[nhds b] g : Prop) ‚Üî ((f ‚àò ‚Üëe) =O[nhds (‚Üë(Homeomorph.symm e) b)] (g ‚àò ‚Üëe) : Prop)","name":"Homeomorph.isBigO_congr","isProp":true,"docString":"Transfer `IsBigO` over a `Homeomorph`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T25Space Œ±] ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : x ‚â† y),\n  Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure)","name":"T25Space.t2_5","isProp":true,"docString":"Given two distinct points in a T‚ÇÇ.‚ÇÖ space, their filters of closed neighborhoods are\ndisjoint. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (S : AddSubgroup G)\n  (hS : Filter.Tendsto (‚Üë(AddSubgroup.subtype S)) Filter.cofinite (Filter.cocompact G)),\n  ProperlyDiscontinuousVAdd { x : G // x ‚àà S } G","name":"AddSubgroup.properlyDiscontinuousVAdd_of_tendsto_cofinite","isProp":true,"docString":"A subgroup `S` of an additive topological group `G` acts on `G` properly\ndiscontinuously on the left, if it is discrete in the sense that `S ‚à© K` is finite for all compact\n`K`. (See also `DiscreteTopology`."},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (a : M), AddSemiconjBy a 0 0","name":"AddSemiconjBy.zero_right","isProp":true,"docString":"Any element semiconjugates `0` to `0`."},{"type":"‚àÄ {N : Type u_2} {G : Type u_1} {H : Type u_3} [inst : Group N] [inst_1 : Group G] [inst_2 : Group H]\n  {œÜ : G ‚Üí* MulAut N} {f : N ‚ãä[œÜ] G ‚Üí* H} {g : N ‚ãä[œÜ] G ‚Üí* H}\n  (hl : MonoidHom.comp f SemidirectProduct.inl = MonoidHom.comp g SemidirectProduct.inl)\n  (hr : MonoidHom.comp f SemidirectProduct.inr = MonoidHom.comp g SemidirectProduct.inr), f = g","name":"SemidirectProduct.hom_ext","isProp":true,"docString":"Two maps out of the semidirect product are equal if they're equal after composition\nwith both `inl` and `inr` "},{"type":"‚àÄ {S : Type u_1} [inst : AddSemigroup S], Transitive fun (a : S) (b : S) ‚Ü¶ ‚àÉ (c : S), AddSemiconjBy c a b","name":"AddSemiconjBy.transitive","isProp":true,"docString":"The relation ‚Äúthere exists an element that semiconjugates `a` to `b`‚Äù on an additive\nsemigroup is transitive."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.WellPowered C·µí·µñ]\n  [inst_2 : CategoryTheory.Limits.HasColimits C] {ùí¢ : Set C} [inst_3 : Small ‚Üëùí¢] (hùí¢ : CategoryTheory.IsSeparating ùí¢),\n  CategoryTheory.Limits.HasTerminal C","name":"CategoryTheory.hasTerminal_of_isSeparating","isProp":true,"docString":"An ingredient of the proof of the Special Adjoint Functor Theorem: a cocomplete well-copowered\ncategory with a small separating set has a terminal object.\n\nIn fact, it follows from the Special Adjoint Functor Theorem that `C` is already complete, see\n`hasLimits_of_hasColimits_of_isSeparating`. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasWideEqualizer f] [inst_2 : Nonempty J] {W : C}\n  {k : W ‚ü∂ CategoryTheory.Limits.wideEqualizer f} {l : W ‚ü∂ CategoryTheory.Limits.wideEqualizer f}\n  (h : k ‚â´ CategoryTheory.Limits.wideEqualizer.Œπ f = l ‚â´ CategoryTheory.Limits.wideEqualizer.Œπ f), k = l","name":"CategoryTheory.Limits.wideEqualizer.hom_ext","isProp":true,"docString":"Two maps into a wide equalizer are equal if they are are equal when composed with the wide\nequalizer map. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} [inst_4 : Fintype Œπ] (p : (a : Œπ) ‚Üí P),\n  (AffineIndependent k p : Prop) ‚Üî\n    (‚àÄ (w1 : (a : Œπ) ‚Üí k) (w2 : (a : Œπ) ‚Üí k) (a : (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ w1 i) = 1)\n        (a : (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ w2 i) = 1)\n        (a : ‚Üë(Finset.affineCombination k Finset.univ p) w1 = ‚Üë(Finset.affineCombination k Finset.univ p) w2), w1 = w2 :\n      Prop)","name":"affineIndependent_iff_eq_of_fintype_affineCombination_eq","isProp":true,"docString":"A finite family is affinely independent if and only if any affine\ncombinations (with sum of weights 1) that evaluate to the same point are equal. "},{"type":"‚àÄ {Œ± : Type u_1} (Œ≤ : Type u_2) {s : Set Œ±} [inst : UniformSpace Œ≤] (ùîñ : Set (Set Œ±)) {x : Œ±} (hxs : x ‚àà s)\n  (hs : s ‚àà ùîñ), UniformContinuous (Function.eval x ‚àò ‚Üë(UniformOnFun.toFun ùîñ))","name":"UniformOnFun.uniformContinuous_eval_of_mem","isProp":true,"docString":"If `x : Œ±` is in some `S ‚àà ùîñ`, then evaluation at `x` is uniformly continuous on\n`Œ± ‚Üí·µ§[ùîñ] Œ≤`. "},{"type":"‚àÄ {Œπ : Type u} {Œ≥ : Type w} [dec : DecidableEq Œπ] [inst : AddCommMonoid Œ≥] (S : (a : Œπ) ‚Üí AddSubmonoid Œ≥)\n  [inst_1 : (i : Œπ) ‚Üí (x : { x : Œ≥ // x ‚àà S i }) ‚Üí Decidable (x ‚â† 0 : Prop)] (x : Œ≥),\n  (x ‚àà sup·µ¢ S : Prop) ‚Üî\n    (‚àÉ (f : Dfinsupp fun (i : Œπ) ‚Ü¶ { x : Œ≥ // x ‚àà S i }),\n        (Dfinsupp.sum f fun (i : Œπ) (xi : { x : Œ≥ // x ‚àà S i }) ‚Ü¶ ‚Üëxi) = x :\n      Prop)","name":"AddSubmonoid.mem_sup·µ¢_iff_exists_dfinsupp'","isProp":true,"docString":"A variant of `AddSubmonoid.mem_sup·µ¢_iff_exists_dfinsupp` with the RHS fully unfolded. "},{"type":"‚àÄ {R : Type u_1} [inst : RightCancelSemigroup R] (g : R), IsRightRegular g","name":"isRightRegular_of_rightCancelSemigroup","isProp":true,"docString":"Elements of a right cancel semigroup are right regular. "},{"type":"‚àÄ {m : Type u_1} [inst : DecidableEq m] [inst_1 : Fintype m] {R : Type v} [inst_2 : CommRing R] (M : Matrix m m R)\n  (N : Matrix m m R) (P : Matrix m m R),\n  Matrix.det (Matrix.mul M (Matrix.mul N P)) = Matrix.det (Matrix.mul N (Matrix.mul M P))","name":"Matrix.det_mul_left_comm","isProp":true,"docString":"On square matrices, `mul_left_comm` applies under `det`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±], NatCast.natCast 0 = 0","name":"CanonicallyOrderedCommSemiring.natCast_zero","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` sends `0 : ‚Ñï` to `0 : R`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±} [inst_1 : TopologicalSpace Œ±]\n  (L :\n    ‚àÄ (u : Set (Œ≤ √ó Œ≤)) (a : u ‚àà uniformity Œ≤),\n      ‚àÉ (t : Set Œ±),\n        (t ‚àà nhds x : Prop) ‚àß\n          (‚àÉ (F : (a : Œ±) ‚Üí Œ≤), (ContinuousAt F x : Prop) ‚àß (‚àÄ (y : Œ±) (a : y ‚àà t), (f y, F y) ‚àà u : Prop) : Prop)),\n  ContinuousAt f x","name":"continuousAt_of_locally_uniform_approx_of_continuousAt","isProp":true,"docString":"A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. "},{"type":"‚àÄ {œÑ : Type u_2} {Œ± : Type u_3} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤] (f : Filter œÑ) (œï : (a : œÑ) ‚Üí (a : Œ±) ‚Üí Œ≤)\n  (s : Set Œ±) [inst_1 : T2Space Œ≤] {c : Set Œ≤} (hc‚ÇÅ : IsCompact c)\n  (hc‚ÇÇ : Filter.Eventually (fun (t : œÑ) ‚Ü¶ Set.MapsTo (œï t) s c) f) {n : Set Œ≤} (hn‚ÇÅ : IsOpen n)\n  (hn‚ÇÇ : omegaLimit f œï s ‚äÜ n), ‚àÉ (u : Set œÑ), (u ‚àà f : Prop) ‚àß (closure (Set.image2 œï u s) ‚äÜ n : Prop)","name":"eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset","isProp":true,"docString":"A set is eventually carried into any open neighbourhood of its œâ-limit:\nif `c` is a compact set such that `closure {œï t x | t ‚àà v, x ‚àà s} ‚äÜ c` for some `v ‚àà f`\nand `n` is an open neighbourhood of `œâ f œï s`, then for some `u ‚àà f` we have\n`closure {œï t x | t ‚àà u, x ‚àà s} ‚äÜ n`. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} [inst : Norm F] {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù}\n  (a : (fun (x : Œ±) ‚Ü¶ abs (u x)) =O[l] g), u =O[l] g","name":"Asymptotics.IsBigO.of_abs_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigO_abs_left`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst : OrderTopology Œ±], CompactSpace Œ±","name":"compactSpace_of_completeLinearOrder","isProp":true,"docString":"A complete linear order is a compact space.\n\nWe do not register an instance for a `[CompactIccSpace Œ±]` because this would only add instances\nfor products (indexed or not) of complete linear orders, and we have instances with higher priority\nthat cover these cases. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : CompleteLattice Œ±] {f : Filter Œ≤} {u : (a : Œ≤) ‚Üí Œ±},\n  Filter.liminf u f = sup·µ¢ fun (s : Set Œ≤) ‚Ü¶ sup·µ¢ fun (h : s ‚àà f) ‚Ü¶ inf·µ¢ fun (a : Œ≤) ‚Ü¶ inf·µ¢ fun (h : a ‚àà s) ‚Ü¶ u a","name":"Filter.liminf_eq_sup·µ¢_inf·µ¢","isProp":true,"docString":"In a complete lattice, the liminf of a function is the infimum over sets `s` in the filter\nof the supremum of the function over `s` "},{"type":"‚àÄ {M : Type u_2} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_4} [inst_1 : AddCommMonoid N] {P : Type u_3}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P} {T : AddSubmonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_1} [inst_3 : AddCommMonoid Q]\n  {k : AddSubmonoid.LocalizationMap T Q} (z : N),\n  ‚Üë(AddSubmonoid.LocalizationMap.toMap k) (‚Üëg ‚Üë(Prod.snd (AddSubmonoid.LocalizationMap.sec f z))) +\n      ‚Üë(AddSubmonoid.LocalizationMap.map f hy k) z =\n    ‚Üë(AddSubmonoid.LocalizationMap.toMap k) (‚Üëg (Prod.fst (AddSubmonoid.LocalizationMap.sec f z)))","name":"AddSubmonoid.LocalizationMap.map_add_left","isProp":true,"docString":"Given Localization maps `f : M ‚Üí+ N, k : P ‚Üí+ Q` for Submonoids `S, T` respectively if an\n`AddCommMonoid` homomorphism `g : M ‚Üí+ P` induces a `f.map hy k : N ‚Üí+ Q`, then for all `z : N`,\nwe have `k (g y) + f.map hy k z = k (g x)` where `x : M, y ‚àà S` are such that\n`z + f y = f x`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {x : Œ±} {r : ‚Ñù} (h : x ‚àà s)\n  (H : Metric.hausdorffDist s t < r) (fin : EMetric.hausdorffEdist s t ‚â† ‚ä§),\n  ‚àÉ (y : Œ±), (y ‚àà t : Prop) ‚àß (dist x y < r : Prop)","name":"Metric.exists_dist_lt_of_hausdorffDist_lt","isProp":true,"docString":"If the Hausdorff distance is `< r`, then any point in one of the sets is at distance\n`< r` of a point in the other set "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R} {n : ‚Ñï} (a : Polynomial.natDegree p ‚â§ n), Polynomial.degree p ‚â§ ‚Üën","name":"Polynomial.degree_le_of_natDegree_le","isProp":true,"docString":"**Alias** of the forward direction of `Polynomial.natDegree_le_iff_degree_le`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C), CategoryTheory.IsPushout 0 0 0 (ùüô X)","name":"CategoryTheory.IsPushout.zero_top","isProp":true,"docString":"The square with `0 : 0 ‚ü∂ 0` on the top and `ùüô X` on the bottom is a pushout square. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : IsPredArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h1 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc m n), r i (Order.pred i))\n  (h2 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc n m), r (Order.pred i) i), Relation.ReflTransGen r n m","name":"reflTransGen_of_pred","isProp":true,"docString":"`(n, m)` is in the reflexive-transitive closure of `~` if `i ~ pred i` and `pred i ~ i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteLimits C],\n  CategoryTheory.Limits.HasFiniteProducts C","name":"CategoryTheory.Limits.hasFiniteProducts_of_hasFiniteLimits","isProp":true,"docString":"If `C` has finite limits then it has finite products. "},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : (a : Œ±) ‚Üí Sort v} {f : (x : Œ±) ‚Üí Œ≤ x} {g : (x : Œ±) ‚Üí Œ≤ x} (h : ‚àÄ (x : Œ±), f x = g x), f = g","name":"funext","isProp":true,"docString":"**Function extensionality** is the statement that if two functions take equal values\nevery point, then the functions themselves are equal: `(‚àÄ x, f x = g x) ‚Üí f = g`.\nIt is called \"extensionality\" because it talks about how to prove two objects are equal\nbased on the properties of the object (compare with set extensionality,\nwhich is `(‚àÄ x, x ‚àà s ‚Üî x ‚àà t) ‚Üí s = t`).\n\nThis is often an axiom in dependent type theory systems, because it cannot be proved\nfrom the core logic alone. However in lean's type theory this follows from the existence\nof quotient types (note the `Quot.sound` in the proof, as well as the `show` line\nwhich makes use of the definitional equality `Quot.lift f h (Quot.mk x) = f x`).\n"},{"type":"‚àÄ {Œ≤ : Type u_1} {Œ± : Type u_2} {A : (a : List Œ≤) ‚Üí Set Œ±} (hA : CantorScheme.Disjoint A),\n  Function.Injective (Sigma.snd (CantorScheme.inducedMap A))","name":"CantorScheme.Disjoint.map_injective","isProp":true,"docString":"A scheme where the children of each set are pairwise disjoint induces an injective map. "},{"type":"‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí ‚Ñù} {g : (a : Œ±) ‚Üí ‚Ñù} {t‚ÇÄ : Filter Œ±} (hf : Filter.Eventually (fun (t : Œ±) ‚Ü¶ 0 ‚â§ f t) t‚ÇÄ)\n  (hft : Filter.Eventually (fun (t : Œ±) ‚Ü¶ f t ‚â§ g t) t‚ÇÄ) (g0 : Filter.Tendsto g t‚ÇÄ (nhds 0)),\n  Filter.Tendsto f t‚ÇÄ (nhds 0)","name":"squeeze_zero'","isProp":true,"docString":"Special case of the sandwich theorem; see `tendsto_of_tendsto_of_tendsto_of_le_of_le'` for the\ngeneral case. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} (b : Basis Œπ R M) (h : Module.rank R M < Cardinal.aleph0), Nonempty (Fintype Œπ)","name":"Basis.nonempty_fintype_index_of_rank_lt_aleph0","isProp":true,"docString":"If a module has a finite dimension, all bases are indexed by a finite type. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hab : a = b) (hbc : b ‚äÜ c), a ‚äÜ c","name":"Eq.trans_subset","isProp":true,"docString":"**Alias** of `subset_of_eq_of_subset`."},{"type":"‚àÄ {Œ± : Type u} [inst : AddZeroClass Œ±], IsAddMonoidHom id","name":"IsAddMonoidHom.id","isProp":true,"docString":"The identity map is an additive monoid homomorphism."},{"type":"‚àÄ {Œ± : Type u_1} [inst : HeytingAlgebra Œ±] {a : Œ±} {b : Œ±}, (a ‚â§ b·∂ú : Prop) ‚Üî (b ‚â§ a·∂ú : Prop)","name":"le_compl_iff_le_compl","isProp":true,"docString":"**Alias** of `le_compl_comm`."},{"type":"‚àÄ {S : Type u_1} {R : Type u_2} [inst : Star R] [inst_1 : SetLike S R] [self : StarMemClass S R] {s : S} {r : R}\n  (a : r ‚àà s), star r ‚àà s","name":"StarMemClass.star_mem","isProp":true,"docString":"Closure under star. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 1) (hb : b < 1), a * b < 1","name":"Left.mul_lt_one'","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one'`. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±]\n  [inst_3 : MulPosStrictMono Œ±] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b), 1 < a * b","name":"Right.one_lt_mul_of_lt_of_lt","isProp":true,"docString":"Assumes right covariance. "},{"type":"‚àÄ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V}\n  [inst_2 : DecidableRel (SimpleGraph.Adj G)] {n : ‚Ñï} {k : ‚Ñï} {‚Ñì : ‚Ñï} {Œº : ‚Ñï} {v : V} {w : V}\n  (h : SimpleGraph.IsSRGWith G n k ‚Ñì Œº) (hne : v ‚â† w) (ha : ¬¨(SimpleGraph.Adj G v w : Prop)),\n  Finset.card (SimpleGraph.neighborFinset G v ‚à™ SimpleGraph.neighborFinset G w) = 2 * k - Œº","name":"SimpleGraph.IsSRGWith.card_neighborFinset_union_of_not_adj","isProp":true,"docString":"Assuming `G` is strongly regular, `2*(k + 1) - m` in `G` is the number of vertices that are\nadjacent to either `v` or `w` when `¬¨G.Adj v w`. So it's the cardinality of\n`G.neighborSet v ‚à™ G.neighborSet w`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí Zero (Œ± i)] (r : (a : Œπ) ‚Üí (a : Œπ) ‚Üí Prop)\n  (s : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí (a : Œ± i) ‚Üí Prop) [inst_1 : (i : Œπ) ‚Üí (s : Set Œπ) ‚Üí Decidable (i ‚àà s : Prop)],\n  Relation.Fibration (InvImage (Prod.GameAdd (Dfinsupp.Lex r s) (Dfinsupp.Lex r s)) Prod.snd) (Dfinsupp.Lex r s)\n    fun (x : Set Œπ √ó (Dfinsupp fun (i : Œπ) ‚Ü¶ Œ± i) √ó Dfinsupp fun (i : Œπ) ‚Ü¶ Œ± i) ‚Ü¶\n    Dfinsupp.piecewise (Prod.fst (Prod.snd x)) (Prod.snd (Prod.snd x)) (Prod.fst x)","name":"Dfinsupp.lex_fibration","isProp":true,"docString":"This key lemma says that if a finitely supported dependent function `x‚ÇÄ` is obtained by merging\ntwo such functions `x‚ÇÅ` and `x‚ÇÇ`, and if we evolve `x‚ÇÄ` down the `Dfinsupp.Lex` relation one\nstep and get `x`, we can always evolve one of `x‚ÇÅ` and `x‚ÇÇ` down the `Dfinsupp.Lex` relation\none step while keeping the other unchanged, and merge them back (possibly in a different way)\nto get back `x`. In other words, the two parts evolve essentially independently under\n`Dfinsupp.Lex`. This is used to show that a function `x` is accessible if\n`Dfinsupp.single i (x i)` is accessible for each `i` in the (finite) support of `x`\n(`Dfinsupp.Lex.acc_of_single`). "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} (b : Basis Œπ R M) {Œ∫ : Type u_1} (v : (a : Œ∫) ‚Üí M) (i : LinearIndependent R v),\n  Cardinal.mk Œ∫ ‚â§ Cardinal.mk Œπ","name":"linearIndependent_le_basis","isProp":true,"docString":"Over any ring `R` satisfying the strong rank condition,\nif `b` is a basis for a module `M`,\nand `s` is a linearly independent set,\nthen the cardinality of `s` is bounded by the cardinality of `b`.\n"},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : OrderedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  {K : Geometry.SimplicialComplex ùïú E} {s : Finset E} {t : Finset E} (hs : s ‚àà Geometry.SimplicialComplex.faces K)\n  (ht : t ‚àà Geometry.SimplicialComplex.faces K),\n  (Disjoint (‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üës) (‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üët) :\n      Prop) ‚à®\n    (‚àÉ (u : Finset E),\n        (u ‚àà Geometry.SimplicialComplex.faces K : Prop) ‚àß\n          (‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üës ‚à© ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üët =\n              ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üëu :\n            Prop) :\n      Prop)","name":"Geometry.SimplicialComplex.disjoint_or_exists_inter_eq_convexHull","isProp":true,"docString":"The conclusion is the usual meaning of \"glue nicely\" in textbooks. It turns out to be quite\nunusable, as it's about faces as sets in space rather than simplices. Further, additional structure\non `ùïú` means the only choice of `u` is `s ‚à© t` (but it's hard to prove). "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  (t : CategoryTheory.Limits.Fork f g) [inst_1 : CategoryTheory.Epi (CategoryTheory.Limits.Fork.Œπ t)], f = g","name":"CategoryTheory.Limits.eq_of_epi_fork_Œπ","isProp":true,"docString":"Two morphisms are equal if there is a fork whose inclusion is epi. "},{"type":"‚àÄ {G : Type u} [inst : AddMonoid G] {H : Type v} [inst_1 : AddMonoid H] (f : G ‚Üí+ H) {x : G} (h : IsOfFinAddOrder x),\n  IsOfFinAddOrder (‚Üëf x)","name":"AddMonoidHom.isOfFinAddOrder","isProp":true,"docString":"The image of an element of finite additive order has finite additive order."},{"type":"‚àÄ {m : Type u_1} {n : Type u_2} {Œ± : Type v} [inst : Fintype m] [inst_1 : Fintype n]\n  [inst_2 : NonUnitalNonAssocSemiring Œ±] (u : (a : m) ‚Üí Œ±) (x : (a : n) ‚Üí Œ±) (e : m ‚âÉ n),\n  Matrix.dotProduct (u ‚àò ‚Üë(Equiv.symm e)) x = Matrix.dotProduct u (x ‚àò ‚Üëe)","name":"Matrix.comp_equiv_symm_dotProduct","isProp":true,"docString":"Permuting a vector on the left of a dot product can be transferred to the right. "},{"type":"‚àÄ (n : ‚Ñï),\n  (Finset.prod (Finset.range (2 * n + 1)) fun (p : ‚Ñï) ‚Ü¶ p ^ ‚Üë(Nat.factorization (Nat.centralBinom n)) p) =\n    Nat.centralBinom n","name":"Nat.prod_pow_factorization_centralBinom","isProp":true,"docString":"The `n`th central binomial coefficient is the product of its prime factors, which are\nat most `2n`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 :\n    ‚àÄ {J : Type w} {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y},\n      CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelFamily f)],\n  CategoryTheory.Limits.HasWideEqualizers C","name":"CategoryTheory.Limits.hasWideEqualizers_of_hasLimit_parallelFamily","isProp":true,"docString":"If `C` has all limits of diagrams `parallelFamily f`, then it has all wide equalizers "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddZeroClass Œ±] [inst_1 : AddZeroClass Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddMonoidHom f)\n  {Œ≥ : Type u_1} [inst_2 : AddZeroClass Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} (hg : IsAddMonoidHom g), IsAddMonoidHom (g ‚àò f)","name":"IsAddMonoidHom.comp","isProp":true,"docString":"The composite of two additive monoid homomorphisms is an additive monoid\nhomomorphism."},{"type":"‚àÄ {Œπ : Type u_1} {S : Type u_2} {R : Type u_3} {N : Type u_4} {M : Type u_5} [inst : SetLike S R] [inst_1 : SetLike N M]\n  [inst_2 : SMul R M] [inst_3 : Add Œπ] {A : (a : Œπ) ‚Üí S} {B : (a : Œπ) ‚Üí N} [self : SetLike.GradedSmul A B] ‚¶Éi : Œπ‚¶Ñ\n  ‚¶Éj : Œπ‚¶Ñ {ai : R} {bj : M} (a : ai ‚àà A i) (a : bj ‚àà B j), ai ‚Ä¢ bj ‚àà B (i + j)","name":"SetLike.GradedSmul.smul_mem","isProp":true,"docString":"Multiplication is homogeneous "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {s : Set M} {p : (a : M) ‚Üí Prop} {x : M} (h : x ‚àà AddSubsemigroup.closure s)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s), p x) (Hmul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x + y)), p x","name":"AddSubsemigroup.closure_induction","isProp":true,"docString":"An induction principle for additive closure membership. If `p`\nholds for all elements of `s`, and is preserved under addition, then `p` holds for all\nelements of the additive closure of `s`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±},\n  EMetric.hausdorffEdist s t = EMetric.hausdorffEdist t s","name":"EMetric.hausdorffEdist_comm","isProp":true,"docString":"The Haudorff edistances of `s` to `t` and of `t` to `s` coincide "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), 1 ‚àà S","name":"Submonoid.one_mem","isProp":true,"docString":"A submonoid contains the monoid's 1. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (a : SeparatedNhds s t),\n  Disjoint (nhdsSet s) (nhdsSet t)","name":"SeparatedNhds.disjoint_nhdsSet","isProp":true,"docString":"**Alias** of the forward direction of `separatedNhds_iff_disjoint`."},{"type":"‚àÄ {E : Type u_1} [self : NormedAddCommGroup E] (x : E) (y : E), dist x y = ‚Äñx - y‚Äñ","name":"NormedAddCommGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1], 0 < 3","name":"zero_lt_three'","isProp":true,"docString":"See `zero_lt_three` for a version with the type implicit. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}\n  {y : (i : Œπ) ‚Üí Œ≤ i}, (0 = hammingDist x y : Prop) ‚Üî (x = y : Prop)","name":"hamming_zero_eq_dist","isProp":true,"docString":"Corresponds to `zero_eq_dist`. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} {y : K} (a : x ‚àà s) (a : y ‚àà s), x + y ‚àà s","name":"Subfield.add_mem","isProp":true,"docString":"A subfield is closed under addition. "},{"type":"‚àÄ (H : AddSubgroup ‚Ñ§), ‚àÉ (a : ‚Ñ§), H = AddSubgroup.closure {a}","name":"Int.subgroup_cyclic","isProp":true,"docString":"Every subgroup of `‚Ñ§` is cyclic. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] (a : Œ±) (b : Œ±), gcd a b ‚à£ b","name":"GCDMonoid.gcd_dvd_right","isProp":true,"docString":"The GCD is a divisor of the second element. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [I : IsNoetherian R M]\n  (f : M ‚Üí‚Çó[R] M), ‚àÉ (n : ‚Ñï), (n ‚â† 0 : Prop) ‚àß (LinearMap.ker (f ^ n) ‚äì LinearMap.range (f ^ n) = ‚ä• : Prop)","name":"IsNoetherian.exists_endomorphism_iterate_ker_inf_range_eq_bot","isProp":true,"docString":"For any endomorphism of a Noetherian module, there is some nontrivial iterate\nwith disjoint kernel and range.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (Cf : ContinuousAt f (inf‚Çõ s)) (Af : Antitone f) (hs : Set.Nonempty s), f (inf‚Çõ s) = sup‚Çõ (f '' s)","name":"Antitone.map_inf‚Çõ_of_continuousAt'","isProp":true,"docString":"An antitone function continuous at the infimum of a nonempty set sends this infimum to\nthe supremum of the image of this set. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {a : Œ±} {p : (a : Œ±) ‚Üí Prop},\n  (Filter.Eventually (fun (x : Œ±) ‚Ü¶ p x) (nhds a) : Prop) ‚Üî\n    (‚àÉ (t : Set Œ±), (‚àÄ (x : Œ±) (a : x ‚àà t), p x : Prop) ‚àß ((IsOpen t : Prop) ‚àß (a ‚àà t : Prop) : Prop) : Prop)","name":"eventually_nhds_iff","isProp":true,"docString":"A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set\ncontaining `a`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] (self : ZeroHom M N), ZeroHom.toFun self 0 = 0","name":"ZeroHom.map_zero'","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ (G : Type u) [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalAddGroup G]\n  [inst_3 : TopologicalSpace.FirstCountableTopology G] (N : AddSubgroup G) [inst_4 : AddSubgroup.Normal N]\n  [inst_5 : CompleteSpace G], CompleteSpace (G ‚ß∏ N)","name":"QuotientAddGroup.completeSpace'","isProp":true,"docString":"The quotient `G ‚ß∏ N` of a complete first countable topological additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause an additive topological group is not equipped with a `UniformSpace` instance by default,\nwe must explicitly provide it in order to consider completeness. See\n`QuotientAddGroup.completeSpace` for a version in which `G` is already equipped with a uniform\nstructure."},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 ‚â§ a) (hb : 1 ‚â§ b), 1 ‚â§ a * b","name":"Left.one_le_mul","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_le_mul`. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú] {n : ‚Ñï}\n  (hn : n ‚â† 0), Filter.Tendsto (fun (x : ùïú) ‚Ü¶ x ^ (-‚Üën)) Filter.atTop (nhds 0)","name":"tendsto_pow_neg_atTop","isProp":true,"docString":"The function `x^(-n)` tends to `0` at `+‚àû` for any positive natural `n`.\nA version for positive real powers exists as `tendsto_rpow_neg_atTop`. "},{"type":"‚àÄ {n : ‚Ñï} {a : ‚Ñï} (hn : Even n) (ha : Even a), Even (n % a)","name":"Even.mod_even","isProp":true,"docString":"If `n` is even and `a` is even, then `n % a` is even. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ‚Ñï} {i : Fin (n + 2)}\n  {j : Fin (n + 1)} (H : i ‚â§ ‚ÜëFin.castSucc j),\n  CategoryTheory.SimplicialObject.œÉ X (Fin.succ j) ‚â´ CategoryTheory.SimplicialObject.Œ¥ X (‚ÜëFin.castSucc i) =\n    CategoryTheory.SimplicialObject.Œ¥ X i ‚â´ CategoryTheory.SimplicialObject.œÉ X j","name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_of_le","isProp":true,"docString":"The second simplicial identity "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  [inst_2 : LocallyCompactSpace Œ±] [inst_3 : CompactSpace Œ≤] [inst_4 : UniformSpace Œ≥] (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥)\n  (h : Continuous ‚Üøf) (x : Œ±), TendstoUniformly f (f x) (nhds x)","name":"Continuous.tendstoUniformly","isProp":true,"docString":"A continuous family of functions `Œ± ‚Üí Œ≤ ‚Üí Œ≥` tends uniformly to its value at `x` if `Œ±` is\nlocally compact and `Œ≤` is compact. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.LocallySmall C] (X : C) (Y : C), Small (X ‚ü∂ Y)","name":"CategoryTheory.LocallySmall.hom_small","isProp":true,"docString":"A locally small category has small hom-types. "},{"type":"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (p : Submodule K V) (hp : p < ‚ä§), ‚àÉ (f : V ‚Üí‚Çó[K] K), (f ‚â† 0 : Prop) ‚àß (p ‚â§ LinearMap.ker f : Prop)","name":"Submodule.exists_le_ker_of_lt_top","isProp":true,"docString":"If `p < ‚ä§` is a subspace of a vector space `V`, then there exists a nonzero linear map\n`f : V ‚Üí‚Çó[K] K` such that `p ‚â§ ker f`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (E : Set Œ±) (s : Set ‚Ñù) (hs‚ÇÄ : s ‚äÜ Set.Ioi 0)\n  (hs : ‚àÄ (Œµ : ‚Ñù) (a : 0 < Œµ), Set.Nonempty (s ‚à© Set.Ioc 0 Œµ)),\n  closure E = Set.inter·µ¢ fun (Œ¥ : ‚Ñù) ‚Ü¶ Set.inter·µ¢ fun (h : Œ¥ ‚àà s) ‚Ü¶ Metric.thickening Œ¥ E","name":"Metric.closure_eq_inter·µ¢_thickening'","isProp":true,"docString":"The closure of a set equals the intersection of its open thickenings of positive radii\naccumulating at zero. "},{"type":"‚àÄ {Œ± : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : (a : ‚Ñï) ‚Üí (a : X) ‚Üí Œ±}\n  (hf : LocallyFinite fun (n : ‚Ñï) ‚Ü¶ setOf fun (x : X) ‚Ü¶ f (n + 1) x ‚â† f n x),\n  ‚àÉ (F : (a : X) ‚Üí Œ±), ‚àÄ (x : X), Filter.Eventually (fun (n : ‚Ñï) ‚Ü¶ f n =·∂†[nhds x] F) Filter.atTop","name":"LocallyFinite.exists_forall_eventually_atTop_eventuallyEq","isProp":true,"docString":"Let `f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x ‚â† f n x}` is locally finite. Then there exists a\nfunction `F :  Œ± ‚Üí Œ≤` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =·∂†[ùìù x] F`. "},{"type":"‚àÄ {Œ± : Sort u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (self : Equivalence r) {x : Œ±} {y : Œ±} {z : Œ±} (a : r x y) (a : r y z),\n  r x z","name":"Equivalence.trans","isProp":true,"docString":"An equivalence relation is transitive: `x ~ y` and `y ~ z` implies `x ~ z` "},{"type":"‚àÄ {R : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_1} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R‚ÇÇ] [inst_4 : AddCommMonoid M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  {s : Set M} {f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} {g : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (hv : Submodule.span R s = ‚ä§) (h : Set.EqOn (‚Üëf) (‚Üëg) s), f = g","name":"LinearMap.ext_on","isProp":true,"docString":"If `s` generates the whole module and linear maps `f`, `g` are equal on `s`, then they are\nequal. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D) {A : C}\n  {A' : C} {B : C} {B' : C} [inst_2 : CategoryTheory.Limits.HasBinaryCoproduct A B]\n  [inst_3 : CategoryTheory.Limits.HasBinaryCoproduct A' B']\n  [inst_4 :\n    CategoryTheory.Limits.HasBinaryCoproduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) A)\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) B)]\n  [inst_5 :\n    CategoryTheory.Limits.HasBinaryCoproduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) A')\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) B')]\n  (f : A ‚ü∂ A') (g : B ‚ü∂ B'),\n  CategoryTheory.Limits.coprodComparison F A B ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.Limits.coprod.map f g) =\n    CategoryTheory.Limits.coprod.map (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)\n        (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) g) ‚â´\n      CategoryTheory.Limits.coprodComparison F A' B'","name":"CategoryTheory.Limits.coprodComparison_natural","isProp":true,"docString":"Naturality of the coprod_comparison morphism in both arguments. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} (hc : c ‚â† 0) (hd : d ‚â† 0)\n  (a_1 : (a * d - b * c) / (c * d) < 0), a / c < b / d","name":"div_lt_div_of_mul_sub_mul_div_neg","isProp":true,"docString":"**Alias** of the forward direction of `mul_sub_mul_div_mul_neg_iff`."},{"type":"‚àÄ (m : Type u_1) (R : Type u_2) [inst : DecidableEq m] [inst_1 : Fintype m] [inst_2 : CommRing R]\n  [inst_3 : Nontrivial R], Matrix.det (Matrix.mvPolynomialX m m R) ‚â† 0","name":"Matrix.det_mvPolynomialX_ne_zero","isProp":true,"docString":"In a nontrivial ring, `Matrix.mvPolynomialX m m R` has non-zero determinant. "},{"type":"‚àÄ {ùïú : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {C : ùïú} (hC : C < 0) (hf : Filter.Tendsto f l (nhds C))\n  (hg : Filter.Tendsto g l Filter.atBot), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * g x) l Filter.atTop","name":"Filter.Tendsto.neg_mul_atBot","isProp":true,"docString":"In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and\n`g` tends to `Filter.atBot` then `f * g` tends to `Filter.atTop`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Lattice Œ±] [inst_1 : Lattice Œ≤]\n  [inst_2 : BoundedOrder Œ±] [inst_3 : BoundedOrder Œ≤] [self : BoundedLatticeHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä§ = ‚ä§","name":"BoundedLatticeHomClass.map_top","isProp":true,"docString":"A `BoundedLatticeHomClass` morphism preserves the top element. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] {a : Œ±} {s : Set Œ≤} (a_1 : Set.Infinite s),\n  Set.Infinite (a ‚Ä¢ s)","name":"Set.Infinite.smul_set","isProp":true,"docString":"**Alias** of the reverse direction of `Set.infinite_smul_set`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : UniformSpace Œ±] [inst_1 : CompactSpace Œ±], uniformity Œ± = sup·µ¢ fun (x : Œ±) ‚Ü¶ nhds (x, x)","name":"compactSpace_uniformity","isProp":true,"docString":"On a compact uniform space, the topology determines the uniform structure, entourages are\nexactly the neighborhoods of the diagonal. "},{"type":"‚àÄ {Œ± : Type u_3} {E : Type u_4} {F' : Type u_2} {ùïú : Type u_1} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F']\n  [inst_2 : NormedField ùïú] {f : (a : Œ±) ‚Üí E} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} [inst_3 : NormedSpace ùïú F'] {c : ùïú}\n  (hc : c ‚â† 0) (a : f =Œò[l] g'), f =Œò[l] fun (x : Œ±) ‚Ü¶ c ‚Ä¢ g' x","name":"Asymptotics.IsTheta.const_smul_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isTheta_const_smul_right`."},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_2} {N : Type u_1} [inst : AddCommMonoid M] [inst_1 : OrderedAddCommMonoid N]\n  (f : (a : M) ‚Üí N) (p : (a : M) ‚Üí Prop) (h_mul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), f (x + y) ‚â§ f x + f y)\n  (hp_mul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x + y)) (g : (a : Œπ) ‚Üí M) (s : Finset Œπ)\n  (hs_nonempty : Finset.Nonempty s) (hs : ‚àÄ (i : Œπ) (a : i ‚àà s), p (g i)),\n  f (Finset.sum s fun (i : Œπ) ‚Ü¶ g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f (g i)","name":"Finset.le_sum_nonempty_of_subadditive_on_pred","isProp":true,"docString":"Let `{x | p x}` be an additive subsemigroup of an additive commutative monoid `M`. Let\n`f : M ‚Üí N` be a map subadditive on `{x | p x}`, i.e., `p x ‚Üí p y ‚Üí f (x + y) ‚â§ f x + f y`. Let\n`g i`, `i ‚àà s`, be a nonempty finite family of elements of `M` such that `‚àÄ i ‚àà s, p (g i)`. Then\n`f (‚àë i in s, g i) ‚â§ ‚àë i in s, f (g i)`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Type u_1}\n  [inst_3 : Semiring A] [inst_4 : Module A V] [inst_5 : SMul K A] [inst_6 : IsScalarTower K A V]\n  (h : FiniteDimensional.finrank K V = 1), IsSimpleOrder (Submodule A V)","name":"is_simple_module_of_finrank_eq_one","isProp":true,"docString":"Any `K`-algebra module that is 1-dimensional over `K` is simple. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Lattice Œ±] [inst_1 : Lattice Œ≤]\n  [inst_2 : BoundedOrder Œ±] [inst_3 : BoundedOrder Œ≤] [self : BoundedLatticeHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä• = ‚ä•","name":"BoundedLatticeHomClass.map_bot","isProp":true,"docString":"A `BoundedLatticeHomClass` morphism preserves the bottom element. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (inf‚Çõ s)) (Mf : Monotone f)\n  (ne : Set.Nonempty s) (H : BddBelow s), f (inf‚Çõ s) = inf‚Çõ (f '' s)","name":"Monotone.map_cinf‚Çõ_of_continuousAt","isProp":true,"docString":"If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,\nthen it sends this infimum to the infimum of the image of `s`. "},{"type":"‚àÄ (R : Type u_1) [inst : Rack R] (G : Type u_2) [inst_1 : Group G] (f : ShelfHom R (Quandle.Conj G)),\n  ShelfHom.comp (Quandle.Conj.map (‚ÜëRack.toEnvelGroup.map f)) (Rack.toEnvelGroup R) = f","name":"Rack.toEnvelGroup.univ","isProp":true,"docString":"Given a homomorphism from a rack to a group, it factors through the enveloping group.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Antitone f) {x : Œ±}\n  [inst_4 : TopologicalSpace Œ±] [inst_5 : OrderTopology Œ±],\n  (ContinuousWithinAt f (Set.Iio x) x : Prop) ‚Üî (Function.leftLim f x = f x : Prop)","name":"Antitone.continuousWithinAt_Iio_iff_leftLim_eq","isProp":true,"docString":"An antitone function is continuous to the left at a point if and only if its left limit\ncoincides with the value of the function. "},{"type":"‚àÄ {n : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (h : a ‚â§ b), (a ‚â° b [MOD n] : Prop) ‚Üî (n ‚à£ b - a : Prop)","name":"Nat.modEq_iff_dvd'","isProp":true,"docString":"A variant of `modEq_iff_dvd` with `nat` divisibility "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddCommMonoid Œ±] [inst_1 : AddCommMonoid Œ≤] {n : ‚Ñï},\n  AddFreimanHomClass (Œ± ‚Üí+ Œ≤) Set.univ Œ≤ n","name":"AddMonoidHom.addFreimanHomClass","isProp":true,"docString":"An additive monoid homomorphism is naturally an `AddFreimanHom` on its entire\ndomain.\n\nWe can't leave the domain `A : Set Œ±` of the `AddFreimanHom` a free variable, since it\nwouldn't be inferrable."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (self : Ring.PositiveCone Œ±) (a : Œ±) (b : Œ±)\n  (a_1 : AddCommGroup.PositiveCone.pos (Ring.PositiveCone.toPositiveCone self) a)\n  (a_2 : AddCommGroup.PositiveCone.pos (Ring.PositiveCone.toPositiveCone self) b),\n  AddCommGroup.PositiveCone.pos (Ring.PositiveCone.toPositiveCone self) (a * b)","name":"Ring.PositiveCone.mul_pos","isProp":true,"docString":"In a positive cone, if `a` and `b` are `pos` then so is `a * b` "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Antivary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) < Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i) : Prop) ‚Üî\n    (¬¨(Antivary f (g ‚àò ‚ÜëœÉ) : Prop) : Prop)","name":"Antivary.sum_mul_lt_sum_mul_comp_perm_iff","isProp":true,"docString":"**Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not antivary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} (hc : c ‚â† 0) (hd : d ‚â† 0)\n  (a_1 : a / c ‚â§ b / d), (a * d - b * c) / (c * d) ‚â§ 0","name":"mul_sub_mul_div_mul_nonpos","isProp":true,"docString":"**Alias** of the reverse direction of `mul_sub_mul_div_mul_nonpos_iff`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}\n  (a : x ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup (Subgroup.toSubmonoid self))),\n  x‚Åª¬π ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup (Subgroup.toSubmonoid self))","name":"Subgroup.inv_mem'","isProp":true,"docString":"`G` is closed under inverses "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_1} {Œπ : Type u_3} {ùîñ : Set (Set Œ±)} {u : (a : Œπ) ‚Üí UniformSpace Œ≥},\n  UniformOnFun.uniformSpace Œ± Œ≥ ùîñ = inf·µ¢ fun (i : Œπ) ‚Ü¶ UniformOnFun.uniformSpace Œ± Œ≥ ùîñ","name":"UniformOnFun.inf·µ¢_eq","isProp":true,"docString":"If `u` is a family of uniform structures on `Œ≥`, then\n`ùí±(Œ±, Œ≥, ùîñ, (‚®Ö i, u i)) = ‚®Ö i, ùí±(Œ±, Œ≥, ùîñ, u i)`. "},{"type":"‚àÄ {R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : AddCommMonoid M‚ÇÉ] [inst_4 : Module R M] [inst_5 : Module R M‚ÇÇ]\n  [inst_6 : Module R M‚ÇÉ] {f : M √ó M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ} {g : M √ó M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ}\n  (hl : LinearMap.comp f (LinearMap.inl R M M‚ÇÇ) = LinearMap.comp g (LinearMap.inl R M M‚ÇÇ))\n  (hr : LinearMap.comp f (LinearMap.inr R M M‚ÇÇ) = LinearMap.comp g (LinearMap.inr R M M‚ÇÇ)), f = g","name":"LinearMap.prod_ext","isProp":true,"docString":"Split equality of linear maps from a product into linear maps over each component, to allow `ext`\nto apply lemmas specific to `M ‚Üí‚Çó M‚ÇÉ` and `M‚ÇÇ ‚Üí‚Çó M‚ÇÉ`.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±] (x : Œ±), nhds (x, x) ‚â§ uniformity Œ±","name":"nhds_le_uniformity","isProp":true,"docString":"Entourages are neighborhoods of the diagonal. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsIrreducible s : Prop) ‚Üî\n    (‚àÄ (Z : Finset (Set Œ±)) (a : ‚àÄ (z : Set Œ±) (a : z ‚àà Z), IsClosed z) (a : s ‚äÜ ‚ãÉ‚ÇÄ ‚ÜëZ),\n        ‚àÉ (z : Set Œ±), (z ‚àà Z : Prop) ‚àß (s ‚äÜ z : Prop) :\n      Prop)","name":"isIrreducible_iff_union‚Çõ_closed","isProp":true,"docString":"A set is irreducible if and only if for every cover by a finite collection of closed sets, it is\ncontained in one of the members of the collection. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (a : Function.Bijective f), Set.BijOn f Set.univ Set.univ","name":"Function.Bijective.bijOn_univ","isProp":true,"docString":"**Alias** of the forward direction of `Set.bijective_iff_bijOn_univ`."},{"type":"‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R ‚âÉ+* S), ‚Üëf 0 = 0","name":"RingEquiv.map_zero","isProp":true,"docString":"A ring isomorphism sends zero to zero. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (e : M ‚âÉ* N) (x : M), ‚Üë(MulEquiv.symm e) (‚Üëe x) = x","name":"MulEquiv.symm_apply_apply","isProp":true,"docString":"`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {w : (a : Œ±) ‚Üí M} {b : M} [inst_1 : LinearOrderedCancelAddCommMonoid M] (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚àà t)\n  (hb : Finset.card t ‚Ä¢ b < Finset.sum s fun (x : Œ±) ‚Ü¶ w x),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (b < Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x : Prop)","name":"Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:\nif the total weight of a finite set of pigeons is greater than `n ‚Ä¢ b`, and they are sorted into\n`n` pigeonholes, then for some pigeonhole, the total weight of the pigeons in this pigeonhole is\ngreater than `b`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {l : (a : Œ±) ‚Üí Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (self : GaloisCoinsertion l u) (x : Œ±), u (l x) ‚â§ x","name":"GaloisCoinsertion.u_l_le","isProp":true,"docString":"Main property of a Galois coinsertion. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] {X : C} (h : ¬¨(CategoryTheory.Limits.IsZero X : Prop)),\n  Nontrivial (CategoryTheory.Subobject X)","name":"CategoryTheory.Subobject.nontrivial_of_not_isZero","isProp":true,"docString":"A nonzero object has nontrivial subobject lattice. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [inst : CommSemiring k] [inst_1 : AddMonoid G] {A : Type u‚ÇÉ} [inst_2 : Semiring A]\n  [inst_3 : Algebra k A] ‚¶ÉœÜ‚ÇÅ : AddMonoidAlgebra k G ‚Üí‚Çê[k] A‚¶Ñ ‚¶ÉœÜ‚ÇÇ : AddMonoidAlgebra k G ‚Üí‚Çê[k] A‚¶Ñ\n  (h : MonoidHom.comp (‚ÜëœÜ‚ÇÅ) (AddMonoidAlgebra.of k G) = MonoidHom.comp (‚ÜëœÜ‚ÇÇ) (AddMonoidAlgebra.of k G)), œÜ‚ÇÅ = œÜ‚ÇÇ","name":"AddMonoidAlgebra.algHom_ext'","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} (l : List Œ±) (c : Composition n) {i : ‚Ñï} (hi : i < List.length (List.splitWrtComposition l c)),\n  List.nthLe (List.splitWrtComposition l c) i hi =\n    List.drop (Composition.sizeUpTo c i) (List.take (Composition.sizeUpTo c (i + 1)) l)","name":"List.nthLe_splitWrtComposition","isProp":true,"docString":"The `i`-th sublist in the splitting of a list `l` along a composition `c`, is the slice of `l`\nbetween the indices `c.sizeUpTo i` and `c.sizeUpTo (i+1)`, i.e., the indices in the `i`-th\nblock of the composition. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCommGroup Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"LinearOrderedCommGroup.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R] {M : Type u_3}\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] {Œπ : Type u_1} [inst_5 : Finite Œπ] (b : Basis Œπ R M)\n  (N : Submodule R M), ‚àÉ (n : ‚Ñï), Nonempty (Basis (Fin n) R { x : M // x ‚àà N })","name":"Submodule.nonempty_basis_of_pid","isProp":true,"docString":"A submodule of a free `R`-module of finite rank is also a free `R`-module of finite rank,\nif `R` is a principal ideal domain.\n\nThis is a `lemma` to make the induction a bit easier. To actually access the basis,\nsee `Submodule.basisOfPid`.\n\nSee also the stronger version `Submodule.smithNormalForm`.\n"},{"type":"‚àÄ {k : Type u_1} {V : Type u_4} {P : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_6} {V‚ÇÇ : Type u_5} {P‚ÇÇ : Type u_3} [inst_4 : AddCommGroup V‚ÇÇ]\n  [inst_5 : Module k V‚ÇÇ] [inst_6 : AddTorsor V‚ÇÇ P‚ÇÇ] {p : (a : Œπ) ‚Üí P} (e : P ‚âÉ·µÉ[k] P‚ÇÇ),\n  (AffineIndependent k (‚Üëe ‚àò p) : Prop) ‚Üî (AffineIndependent k p : Prop)","name":"AffineEquiv.affineIndependent_iff","isProp":true,"docString":"Affine equivalences preserve affine independence of families of points. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±]\n  [inst_2 : TopologicalSpace Œ±] [inst_3 : OrderTopology Œ±] [inst_4 : TopologicalSpace Œ≤] [inst_5 : TopologicalSpace Œ≥]\n  {f : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ≥} (h : ContinuousOn (Function.uncurry f) (Set.univ √óÀ¢ Set.Icc 0 1))\n  (hf : ‚àÄ (s : Œ≤), f s 0 = f s 1), Continuous fun (st : Œ≤ √ó Œ±) ‚Ü¶ f (Prod.fst st) (Int.fract (Prod.snd st))","name":"ContinuousOn.comp_fract'","isProp":true,"docString":"Do not use this, use `ContinuousOn.comp_fract` instead. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Embedding f), (IsCompact s : Prop) ‚Üî (IsCompact (f '' s) : Prop)","name":"Embedding.isCompact_iff_isCompact_image","isProp":true,"docString":"If `f : Œ± ‚Üí Œ≤` is an `Embedding` (or more generally, an `Inducing` map, see\n`Inducing.isCompact_iff`), then the image `f '' s` of a set `s` is compact if and only if the set\n`s` is closed. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} (hs : s ‚â† Set.univ) {f : (a : ‚Üës) ‚Üí Œ±} (hf : Function.Surjective f), Infinite Œ±","name":"Infinite.of_surjective_from_set","isProp":true,"docString":"If `s : Set Œ±` is a proper subset of `Œ±` and `f : s ‚Üí Œ±` is surjective, then `Œ±` is infinite. "},{"type":"‚àÄ {E : Type u_1} [self : NormedGroup E] (x : E) (y : E), dist x y = ‚Äñx / y‚Äñ","name":"NormedGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X) (n : ‚Ñï),\n  IsCompact (CompactExhaustion.toFun self n)","name":"CompactExhaustion.is_compact'","isProp":true,"docString":"The sets in the compact exhaustion are in fact compact. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} [inst_1 : NoMinOrder Œ±], Nonempty ‚Üë(Set.Iio a)","name":"Set.nonempty_Iio_subtype","isProp":true,"docString":"In an order without minimal elements, the intervals `Iio` are nonempty. "},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E} (hs : Convex ‚Ñù s) {x : E}\n  (hx : x ‚àà interior s) (t : ‚Ñù) (ht : 1 < t), closure s ‚äÜ interior (‚Üë(AffineMap.homothety x t) '' s)","name":"Convex.closure_subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] (a : Œ±) (b : Œ±) (u : Œ±) (hu : IsUnit u), (a ‚à£ u * b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"IsUnit.dvd_mul_left","isProp":true,"docString":"In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\nassociates of `b`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} {Œπ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} {t : Finset Œπ} {w : (a : Œπ) ‚Üí ùïú} {p : (a : Œπ) ‚Üí E} (h : ConcaveOn ùïú s f)\n  (hw‚ÇÄ : ‚àÄ (i : Œπ) (a : i ‚àà t), 0 ‚â§ w i) (hw‚ÇÅ : 0 < Finset.sum t fun (i : Œπ) ‚Ü¶ w i)\n  (hp : ‚àÄ (i : Œπ) (a : i ‚àà t), p i ‚àà s), ‚àÉ (i : Œπ), (i ‚àà t : Prop) ‚àß (f (p i) ‚â§ f (Finset.centerMass t w p) : Prop)","name":"ConcaveOn.exists_le_of_centerMass","isProp":true,"docString":"If a function `f` is concave on `s`, then the value it takes at some center of mass of points of\n`s` is greater than the value it takes on one of those points. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} {t : Set Œ≤}\n  (hs : Dense s) (ht : Dense t), Dense (s √óÀ¢ t)","name":"Dense.prod","isProp":true,"docString":"The product of two dense sets is a dense set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_4} {Œ≥ : Type u_2} {Œ¥ : Type u_5} {G : Type u_3} [inst : TopologicalSpace Œ±]\n  [inst_1 : AddCommGroup Œ±] [inst_2 : TopologicalAddGroup Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : AddCommGroup Œ≤]\n  [inst_5 : TopologicalSpace Œ≥] [inst_6 : AddCommGroup Œ≥] [inst_7 : TopologicalAddGroup Œ≥] [inst_8 : TopologicalSpace Œ¥]\n  [inst_9 : AddCommGroup Œ¥] [inst_10 : UniformSpace G] [inst_11 : AddCommGroup G] [inst_12 : UniformAddGroup G]\n  [inst_13 : SeparatedSpace G] [inst_14 : CompleteSpace G] {e : Œ≤ ‚Üí+ Œ±} (de : DenseInducing ‚Üëe) {f : Œ¥ ‚Üí+ Œ≥}\n  (df : DenseInducing ‚Üëf) {œÜ : Œ≤ ‚Üí+ Œ¥ ‚Üí+ G} (hœÜ : Continuous fun (p : Œ≤ √ó Œ¥) ‚Ü¶ ‚Üë(‚ÜëœÜ (Prod.fst p)) (Prod.snd p)),\n  Continuous\n    (DenseInducing.extend\n      ((DenseInducing.prod de\n            df=:DenseInducing fun (p : Œ≤ √ó Œ¥) ‚Ü¶\n            (‚Üëe (Prod.fst p), ‚Üëf (Prod.snd p)))=:DenseInducing fun (p : Œ≤ √ó Œ¥) ‚Ü¶ (‚Üëe (Prod.fst p), ‚Üëf (Prod.snd p)))\n      fun (p : Œ≤ √ó Œ¥) ‚Ü¶ ‚Üë(‚ÜëœÜ (Prod.fst p)) (Prod.snd p))","name":"DenseInducing.extend_Z_bilin","isProp":true,"docString":"Bourbaki GT III.6.5 Theorem I:\n‚Ñ§-bilinear continuous maps from dense images into a complete Hausdorff group extend by continuity.\nNote: Bourbaki assumes that Œ± and Œ≤ are also complete Hausdorff, but this is not necessary. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {y : Œ±} {r : ‚Ñù} (h : y ‚àà t)\n  (H : Metric.hausdorffDist s t < r) (fin : EMetric.hausdorffEdist s t ‚â† ‚ä§),\n  ‚àÉ (x : Œ±), (x ‚àà s : Prop) ‚àß (dist x y < r : Prop)","name":"Metric.exists_dist_lt_of_hausdorffDist_lt'","isProp":true,"docString":"If the Hausdorff distance is `< r`, then any point in one of the sets is at distance\n`< r` of a point in the other set "},{"type":"‚àÄ {M : Type u_1} {Œ± : Type u_2} [inst : VAdd M Œ±] [self : AddAction.IsPretransitive M Œ±] (x : Œ±) (y : Œ±),\n  ‚àÉ (g : M), g +·µ• x = y","name":"AddAction.IsPretransitive.exists_vadd_eq","isProp":true,"docString":"There is `g` such that `g +·µ• x = y`. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]\n  {B : (a : Œπ) ‚Üí Submodule R A} (self : SubmodulesRingBasis B) (a : A) (i : Œπ), ‚àÉ (j : Œπ), a ‚Ä¢ B j ‚â§ B i","name":"SubmodulesRingBasis.leftMul","isProp":true,"docString":"For any element `a : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `a ‚Ä¢ B'` is in `B`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : Finite Œ±], Nonempty (Fintype Œ±)","name":"nonempty_fintype","isProp":true,"docString":"See also `nonempty_encodable`, `nonempty_denumerable`. "},{"type":"‚àÄ {G : Type u} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x : G // x ‚àà H }),\n  (IsOfFinAddOrder x : Prop) ‚Üî (IsOfFinAddOrder ‚Üëx : Prop)","name":"isOfFinAddOrder_iff_coe","isProp":true,"docString":"Elements of finite order are of finite order in submonoids."},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {c : AddCon M}\n  (f : AddCon.Quotient c ‚Üí+ P) (g : AddCon.Quotient c ‚Üí+ P) (h : ‚àÄ (a : M), ‚Üëf ‚Üëa = ‚Üëg ‚Üëa), f = g","name":"AddCon.lift_funext","isProp":true,"docString":"Homomorphisms on the quotient of an AddMonoid` by an additive congruence relation\nare equal if they are equal on elements that are coercions from the `AddMonoid`."},{"type":"‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a : B} {b : B} {c : B}\n  {d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d), (f ‚â´ g) ‚â´ h = f ‚â´ g ‚â´ h","name":"CategoryTheory.Bicategory.Strict.assoc","isProp":true,"docString":"Composition in a bicategory is associative. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (Monovary (f ‚àò ‚ÜëœÉ) g : Prop)","name":"Monovary.sum_comp_perm_smul_eq_sum_smul_iff","isProp":true,"docString":"**Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f ‚àò œÉ` and `g` monovary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {n : ‚Ñï} (f : AlternatingMap R M N (Fin (Nat.succ n)))\n  (m : (a : Fin n) ‚Üí M) (c : R) (x : M), ‚Üëf (Matrix.vecCons (c ‚Ä¢ x) m) = c ‚Ä¢ ‚Üëf (Matrix.vecCons x m)","name":"AlternatingMap.map_vecCons_smul","isProp":true,"docString":"A version of `MultilinearMap.cons_smul` for `AlternatingMap`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ‚âÉ+* S),\n  RingHom.toAddMonoidHom ‚Üëf = AddEquiv.toAddMonoidHom ‚Üëf","name":"RingEquiv.toAddMonoidMom_commutes","isProp":true,"docString":"The two paths coercion can take to an `AddMonoidHom` are equivalent "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {C : ‚Ñù} (h‚ÇÄ : 0 ‚â§ C)\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s), dist x y ‚â§ C), Metric.diam s ‚â§ C","name":"Metric.diam_le_of_forall_dist_le","isProp":true,"docString":"If the distance between any two points in a set is bounded by some non-negative constant,\nthis constant bounds the diameter. "},{"type":"‚àÄ {Œ≤ : Type u_2} {Œ± : Type u_1} {A : (a : List Œ≤) ‚Üí Set Œ±} [inst : PseudoMetricSpace Œ±] [inst_1 : CompleteSpace Œ±]\n  (hdiam : CantorScheme.VanishingDiam A) (hanti : CantorScheme.ClosureAntitone A)\n  (hnonempty : ‚àÄ (l : List Œ≤), Set.Nonempty (A l)), Sigma.fst (CantorScheme.inducedMap A) = Set.univ","name":"CantorScheme.ClosureAntitone.map_of_vanishingDiam","isProp":true,"docString":"A scheme on a complete space with vanishing diameter\nsuch that each set contains the closure of its children\ninduces a total map. "},{"type":"‚àÄ {F : Type u_3} {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : BooleanAlgebra Œ±] [inst_1 : BooleanAlgebra Œ≤]\n  [inst_2 : BoundedLatticeHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a ‚àÜ b) = ‚Üëf a ‚àÜ ‚Üëf b","name":"map_symm_diff'","isProp":true,"docString":"Special case of `map_symm_diff` for boolean algebras. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] {a : Œ±} {b : Œ±} [inst_1 : IsAntisymm Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1]\n  (a_1 : a ‚äÜ b) (a_2 : b ‚äÜ a), b = a","name":"HasSubset.Subset.antisymm'","isProp":true,"docString":"**Alias** of `superset_antisymm`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤]\n  (f : (a : Œ±) ‚Üí Œ≤) {w : (a : Œ±) ‚Üí M} {b : M} [inst_3 : LinearOrderedCancelAddCommMonoid M]\n  (hb : (Finset.sum Finset.univ fun (x : Œ±) ‚Ü¶ w x) < Fintype.card Œ≤ ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), (Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ) fun (x : Œ±) ‚Ü¶ w x) < b","name":"Fintype.exists_sum_fiber_lt_of_sum_lt_nsmul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons of different weights, strict inequality\nversion: there is a pigeonhole with the total weight of pigeons in it less than `b` provided that\nthe total number of pigeonholes times `b` is greater than the total weight of all pigeons. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : DenselyOrdered Œ±] {f : Filter Œ≤} {u : (a : Œ≤) ‚Üí Œ±} {s : Set Œ±} (hs : Dense s)\n  (H :\n    ‚àÄ (a : Œ±) (a_1 : a ‚àà s) (b : Œ±) (a_2 : b ‚àà s) (a_3 : a < b),\n      ¬¨((Filter.Frequently (fun (n : Œ≤) ‚Ü¶ u n < a) f : Prop) ‚àß (Filter.Frequently (fun (n : Œ≤) ‚Ü¶ b < u n) f : Prop) :\n          Prop))\n  (h : autoParam (Filter.IsBoundedUnder (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) f u : Prop) _auto‚úù)\n  (h' : autoParam (Filter.IsBoundedUnder (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â• x_1) f u : Prop) _auto‚úù¬π),\n  ‚àÉ (c : Œ±), Filter.Tendsto u f (nhds c)","name":"tendsto_of_no_upcrossings","isProp":true,"docString":"Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\nworks if `a` and `b` are restricted to a dense subset.\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : GeneralizedCoheytingAlgebra Œ±] (a : Œ±), ‚ä• ‚â§ a","name":"GeneralizedCoheytingAlgebra.bot_le","isProp":true,"docString":"`‚ä•` is a least element "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (s : Subring R) (m : Multiset R) (a : ‚àÄ (a : R) (a_1 : a ‚àà m), a ‚àà s),\n  Multiset.prod m ‚àà s","name":"Subring.multiset_prod_mem","isProp":true,"docString":"Product of a multiset of elements in a subring of a `CommRing` is in the subring. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {e : LocalEquiv Œ± Œ≤} {e' : LocalEquiv Œ± Œ≤} {f : LocalEquiv Œ≤ Œ≥}\n  {f' : LocalEquiv Œ≤ Œ≥} (he : e ‚âà e') (hf : f ‚âà f'), LocalEquiv.trans e f ‚âà LocalEquiv.trans e' f'","name":"LocalEquiv.EqOnSource.trans'","isProp":true,"docString":"Composition of local equivs respects equivalence "},{"type":"‚àÄ {C : Type u} [ùíû : CategoryTheory.Category C] [self : CategoryTheory.MonoidalCategory C] {X‚ÇÅ : C} {Y‚ÇÅ : C} {Z‚ÇÅ : C}\n  {X‚ÇÇ : C} {Y‚ÇÇ : C} {Z‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ),\n  f‚ÇÅ ‚â´ g‚ÇÅ ‚äó f‚ÇÇ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚äó f‚ÇÇ) ‚â´ (g‚ÇÅ ‚äó g‚ÇÇ)","name":"CategoryTheory.MonoidalCategory.tensor_comp","isProp":true,"docString":"Composition of tensor products is tensor product of compositions:\n`(f‚ÇÅ ‚äó g‚ÇÅ) ‚àò (f‚ÇÇ ‚äó g‚ÇÇ) = (f‚ÇÅ ‚àò f‚ÇÇ) ‚äó (g‚ÇÅ ‚äó g‚ÇÇ)`\n"},{"type":"‚àÄ {M : Type u_1} {X : Type u_2} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace X] [inst_2 : SMul M X]\n  [inst_3 : ContinuousSMul M X] [inst_4 : SMul M·µê·µí·µñ X] [inst_5 : IsCentralScalar M X], ContinuousSMul M·µê·µí·µñ X","name":"ContinuousSMul.op","isProp":true,"docString":"If a scalar action is central, then its right action is continuous when its left action is. "},{"type":"‚àÄ {ùïú : Type u} {E : Type v} {Œ≤ : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : ConvexOn ùïú (‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) s) f) {x : E}\n  (hx : x ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) s), ‚àÉ (y : E), (y ‚àà s : Prop) ‚àß (f x ‚â§ f y : Prop)","name":"ConvexOn.exists_ge_of_mem_convexHull","isProp":true,"docString":"Maximum principle for convex functions. If a function `f` is convex on the convex hull of `s`,\nthen the eventual maximum of `f` on `convexHull ùïú s` lies in `s`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚âÉ. Œ≤) (a‚ÇÇ : Œ±) (h : ‚àÄ (a‚ÇÅ : Œ±) (a : a‚ÇÅ ‚â† a‚ÇÇ), Option.isSome (‚Üëf a‚ÇÅ) = true),\n  Function.Injective ‚Üëf","name":"PEquiv.injective_of_forall_ne_isSome","isProp":true,"docString":"If the domain of a `PEquiv` is `Œ±` except a point, its forward direction is injective. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} {y : K} (a : x ‚àà s) (a : y ‚àà s), x * y ‚àà s","name":"Subfield.mul_mem","isProp":true,"docString":"A subfield is closed under multiplication. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : TopologicalSpace ùïú] [inst_1 : CommSemiring ùïú]\n  [inst_2 : AddCommMonoid E] [inst_3 : Module ùïú E] [inst_4 : AddCommMonoid F] [inst_5 : Module ùïú F]\n  (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) [inst_6 : ContinuousAdd ùïú], ContinuousAdd (WeakBilin B)","name":"WeakBilin.instContinuousAdd","isProp":true,"docString":"Addition in `WeakBilin B` is continuous. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type u_1}\n  (s : Finset Œπ) (S : (a : Œπ) ‚Üí Submodule K V) [inst_3 : ‚àÄ (i : Œπ), FiniteDimensional K { x : V // x ‚àà S i }],\n  FiniteDimensional K { x : V // x ‚àà Finset.sup s S }","name":"Submodule.finiteDimensional_finset_sup","isProp":true,"docString":"The submodule generated by a finite supremum of finite dimensional submodules is\nfinite-dimensional.\n\nNote that strictly this only needs `‚àÄ i ‚àà s, FiniteDimensional K (S i)`, but that doesn't\nwork well with typeclass search. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {w : (a : Œ±) ‚Üí M} {b : M} [inst_1 : LinearOrderedCancelAddCommMonoid M] (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚àà t)\n  (ht : Finset.Nonempty t) (hb : Finset.card t ‚Ä¢ b ‚â§ Finset.sum s fun (x : Œ±) ‚Ü¶ w x),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (b ‚â§ Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x : Prop)","name":"Finset.exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality\nversion: if the total weight of a finite set of pigeons is greater than or equal to `n ‚Ä¢ b`, and\nthey are sorted into `n > 0` pigeonholes, then for some pigeonhole, the total weight of the pigeons\nin this pigeonhole is greater than or equal to `b`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ±}\n  (Hf : MonotoneOn f t) (Hst : s ‚äÜ t) (a : Set.Nonempty (lowerBounds s ‚à© t)), BddBelow (f '' s)","name":"MonotoneOn.map_bddBelow","isProp":true,"docString":"The image under a monotone function on a set `t` of a subset which has a lower bound in `t`\nis bounded below. "},{"type":"‚àÄ {Œ± : Type u} (self : UniformSpace.Core Œ±),\n  Filter.Tendsto Prod.swap (UniformSpace.Core.uniformity self) (UniformSpace.Core.uniformity self)","name":"UniformSpace.Core.symm","isProp":true,"docString":"If `s ‚àà uniformity`, then `Prod.swap ‚Åª¬π' s ‚àà uniformity`. "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] [self : SeparatedSpace Œ±], separationRel Œ± = idRel","name":"SeparatedSpace.out","isProp":true,"docString":"The separation relation is equal to the diagonal `idRel`. "},{"type":"‚àÄ {obj : Type u} [self : CategoryTheory.Category obj] {X : obj} {Y : obj} (f : X ‚ü∂ Y), ùüô X ‚â´ f = f","name":"CategoryTheory.Category.id_comp","isProp":true,"docString":"Identity morphisms are left identities for composition. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {m : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} {P : Finpartition s}\n  (hs : a * m + b * (m + 1) = Finset.card s),\n  ‚àÉ (Q : Finpartition s),\n    (‚àÄ (x : Finset Œ±) (a : x ‚àà Finpartition.parts Q), (Finset.card x = m : Prop) ‚à® (Finset.card x = m + 1 : Prop) :\n        Prop) ‚àß\n      ((‚àÄ (x : Finset Œ±) (a : x ‚àà Finpartition.parts P),\n              Finset.card (x \\ Finset.bunion·µ¢ (Finset.filter (fun (y : Finset Œ±) ‚Ü¶ y ‚äÜ x) (Finpartition.parts Q)) id) ‚â§\n                m :\n            Prop) ‚àß\n          (Finset.card (Finset.filter (fun (i : Finset Œ±) ‚Ü¶ Finset.card i = m + 1) (Finpartition.parts Q)) = b : Prop) :\n        Prop)","name":"Finpartition.equitabilise_aux","isProp":true,"docString":"Given a partition `P` of `s`, as well as a proof that `a * m + b * (m + 1) = s.card`, we can\nfind a new partition `Q` of `s` where each part has size `m` or `m + 1`, every part of `P` is the\nunion of parts of `Q` plus at most `m` extra elements, there are `b` parts of size `m + 1` and\n(provided `m > 0`, because a partition does not have parts of size `0`) there are `a` parts of size\n`m` and hence `a + b` parts in total. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S‚ÇÅ : Submodule K V}\n  {S‚ÇÇ : Submodule K V} [inst_3 : FiniteDimensional K { x : V // x ‚àà S‚ÇÇ }] (h : S‚ÇÅ ‚â§ S‚ÇÇ),\n  FiniteDimensional K { x : V // x ‚àà S‚ÇÅ }","name":"Submodule.finiteDimensional_of_le","isProp":true,"docString":"A submodule contained in a finite-dimensional submodule is\nfinite-dimensional. "},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} {x : Œ±} {b : Bool},\n  (FreeAddGroup.Red ((x, b) :: L) [] : Prop) ‚Üî (FreeAddGroup.Red L [(x, !b)] : Prop)","name":"FreeAddGroup.Red.cons_nil_iff_singleton","isProp":true,"docString":"If `x` is a letter and `w` is a word such that `x + w` reduces to the empty word, then `w`\nreduces to `-x`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : 1 ‚â§ a) (hb : 1 < b), 1 < a * b","name":"Right.one_lt_mul_of_le_of_lt","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul_of_le_of_lt`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Bornology Œ±] [self : BoundedSpace Œ±], Bornology.IsBounded Set.univ","name":"BoundedSpace.bounded_univ","isProp":true,"docString":"The `Set.univ` is bounded. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {g : Equiv.Perm Œ±} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±]\n  (hf : Equiv.Perm.IsCycle f) (hg : Equiv.Perm.IsCycle g) (h : Equiv.Perm.support f ‚äÜ Equiv.Perm.support g)\n  (h' : ‚àÄ (x : Œ±) (a : x ‚àà Equiv.Perm.support f), ‚Üëf x = ‚Üëg x), f = g","name":"Equiv.Perm.IsCycle.support_congr","isProp":true,"docString":"Unlike `support_congr`, which assumes that `‚àÄ (x ‚àà g.support), f x = g x)`, here\nwe have the weaker assumption that `‚àÄ (x ‚àà f.support), f x = g x`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CommMonoid Œ≤] (s : Finset Œ±) (f : (a : Finset Œ±) ‚Üí Œ≤),\n  (Finset.prod (Finset.powerset s) fun (t : Finset Œ±) ‚Ü¶ f t) =\n    Finset.prod (Finset.range (Finset.card s + 1)) fun (j : ‚Ñï) ‚Ü¶\n      Finset.prod (Finset.powersetLen j s) fun (t : Finset Œ±) ‚Ü¶ f t","name":"Finset.prod_powerset","isProp":true,"docString":"A product over `powerset s` is equal to the double product over sets of subsets of `s` with\n`card s = k`, for `k = 1, ..., card s`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≤} {a : Œ±} (h : ‚àÄ (b : Œ≤), f a b = b) (t : Set Œ≤),\n  Set.image2 f {a} t = t","name":"Set.image2_left_identity","isProp":true,"docString":"If `a` is a left identity for `f : Œ± ‚Üí Œ≤ ‚Üí Œ≤`, then `{a}` is a left identity for\n`Set.image2 f`. "},{"type":"‚àÄ (k : Type u_1) {V : Type u_3} {P : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] [inst_4 : Invertible 2] (p : (a : Fin 2) ‚Üí P),\n  Finset.centroid k Finset.univ p = 2‚Åª¬π ‚Ä¢ (p 1 -·µ• p 0) +·µ• p 0","name":"Finset.centroid_pair_fin","isProp":true,"docString":"The centroid of two points indexed by `Fin 2`, expressed directly\nas adding a vector to the first point. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [inst : CommSemiring k] [inst_1 : AddMonoid G] {A : Type u‚ÇÉ} [inst_2 : Semiring A]\n  [inst_3 : Algebra k A] (F : AddMonoidAlgebra k G ‚Üí‚Çê[k] A) (f : MonoidAlgebra k G),\n  ‚ÜëF f = Finsupp.sum f fun (a : G) (b : k) ‚Ü¶ b ‚Ä¢ ‚ÜëF (AddMonoidAlgebra.single a 1)","name":"AddMonoidAlgebra.lift_unique","isProp":true,"docString":"Decomposition of a `k`-algebra homomorphism from `MonoidAlgebra k G` by\nits values on `F (single a 1)`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {x : Œ±},\n  ConnectedComponents.mk ‚Åª¬π' {ConnectedComponents.mk x} = connectedComponent x","name":"connectedComponents_preimage_singleton","isProp":true,"docString":"The preimage of a singleton in `connectedComponents` is the connected component\nof an element in the equivalence class. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyCompactSpace Œ±] (x : Œ±) (n : Set Œ±) (a : n ‚àà nhds x),\n  ‚àÉ (s : Set Œ±), (s ‚àà nhds x : Prop) ‚àß ((s ‚äÜ n : Prop) ‚àß (IsCompact s : Prop) : Prop)","name":"LocallyCompactSpace.local_compact_nhds","isProp":true,"docString":"In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {a : Œ±} {b : Œ±} (hs : b ‚àà s)\n  (hsa : ¬¨(b ‚àà Finset.erase s a : Prop)), b = a","name":"Finset.eq_of_mem_of_not_mem_erase","isProp":true,"docString":"An element of `s` that is not an element of `erase s a` must be`a`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] {a : Œ±} {b : Œ±} {u : Œ±À£}, (‚Üëu * a ‚à£ b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"Units.mul_left_dvd","isProp":true,"docString":"In a commutative monoid, an element `a` divides an element `b` iff all\nleft associates of `a` divide `b`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  {s : Set E} {t : Set E} (hs : Convex ùïú s) (ht : Convex ùïú t) (hst : Disjoint s t),\n  ‚àÉ (C : Set E), (Convex ùïú C : Prop) ‚àß ((Convex ùïú (C·∂ú) : Prop) ‚àß ((s ‚äÜ C : Prop) ‚àß (t ‚äÜ C·∂ú : Prop) : Prop) : Prop)","name":"exists_convex_convex_compl_subset","isProp":true,"docString":"**Stone's Separation Theorem** "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (e : Œ± ‚âÉ Œ≤), (IsEmpty Œ± : Prop) ‚Üî (IsEmpty Œ≤ : Prop)","name":"Equiv.isEmpty_congr","isProp":true,"docString":"If `Œ±` is equivalent to `Œ≤`, then `IsEmpty Œ±` is equivalent to `IsEmpty Œ≤`. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (q : (i : Fin (n + 1)) ‚Üí Œ± i) (z : Œ± (Fin.last n)),\n  Fin.init (Function.update q (Fin.last n) z) = Fin.init q","name":"Fin.init_update_last","isProp":true,"docString":"Updating the last element of a tuple does not change the beginning. "},{"type":"‚àÄ {A : Type u_1} [inst : AddGroup A] [self : IsSimpleAddGroup A] (H : AddSubgroup A) (a : AddSubgroup.Normal H),\n  (H = ‚ä• : Prop) ‚à® (H = ‚ä§ : Prop)","name":"IsSimpleAddGroup.eq_bot_or_eq_top_of_normal","isProp":true,"docString":"Any normal additive subgroup is either `‚ä•` or `‚ä§` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommSemigroup Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ExistsAddOfLE Œ±]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [inst_4 : Sub Œ±]\n  [inst_5 : OrderedSub Œ±] {b : Œ±} {c : Œ±}\n  [inst_6 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (h : c ‚â§ b)\n  (a : Œ±), a + b - c = a + (b - c)","name":"add_tsub_assoc_of_le","isProp":true,"docString":"See `add_tsub_le_assoc` for an inequality. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] (p : Submodule R M) [inst_5 : Module.Finite R { x : M // x ‚àà p }]\n  (f : M ‚Üí‚Çó[R] N), Module.Finite R { x : N // x ‚àà Submodule.map f p }","name":"Module.Finite.map","isProp":true,"docString":"Pushforwards of finite submodules are finite. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (e : LocalEquiv Œ± Œ≤) (e' : LocalEquiv Œ± Œ≤) (h : e ‚âà e')\n  (s : LocalEquiv.source e = Set.univ) (t : LocalEquiv.target e = Set.univ), e = e'","name":"LocalEquiv.eq_of_eq_on_source_univ","isProp":true,"docString":"Two equivalent local equivs are equal when the source and target are univ "},{"type":"‚àÄ {Œπ : Type u_1} [inst : Fintype Œπ] [inst_1 : DecidableEq Œπ] {R : Type u_2} [inst_2 : Semiring R] (x : (a : Œπ) ‚Üí R),\n  x = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ x i ‚Ä¢ fun (j : Œπ) ‚Ü¶ if (i = j : Prop) then 1 else 0","name":"pi_eq_sum_univ","isProp":true,"docString":"decomposing `x : Œπ ‚Üí R` as a sum along the canonical basis "},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {X : CategoryTheory.SimplicialObject C} (q : ‚Ñï), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HœÉ q) 0 = 0","name":"AlgebraicTopology.DoldKan.HœÉ_eq_zero","isProp":true,"docString":"In degree `0`, the null homotopic map `HœÉ` is zero. "},{"type":"‚àÄ {n : ‚Ñï}, (IsPrimePow n : Prop) ‚Üî (‚àÉ! (p : ‚Ñï), (Nat.Prime p : Prop) ‚àß (p ‚à£ n : Prop) : Prop)","name":"isPrimePow_iff_unique_prime_dvd","isProp":true,"docString":"An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime\ndividing it. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (self : AbsoluteValue R S) (x : R),\n  0 ‚â§ MulHom.toFun (AbsoluteValue.toMulHom self) x","name":"AbsoluteValue.nonneg'","isProp":true,"docString":"The absolute value is nonnegative "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Inf Œ±] [inst_1 : Inf Œ≤] [inst_2 : Top Œ±] [inst_3 : Top Œ≤]\n  (self : InfTopHom Œ± Œ≤), InfHom.toFun (InfTopHom.toInfHom self) ‚ä§ = ‚ä§","name":"InfTopHom.map_top'","isProp":true,"docString":"An `InfTopHom` preserves the top element. "},{"type":"‚àÄ {V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ]\n  (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ),\n  LipschitzWith { val := ‚Äñf‚Äñ, property := ((NormedAddGroupHom.opNorm_nonneg f=:0 ‚â§ ‚Äñf‚Äñ)=:0 ‚â§ ‚Äñf‚Äñ) } ‚Üëf","name":"NormedAddGroupHom.lipschitz","isProp":true,"docString":"continuous linear maps are Lipschitz continuous. "},{"type":"‚àÄ {n : ‚Ñï} {Œ≤ : Type u_1} (q : (a : Fin (n + 2)) ‚Üí Œ≤), Fin.tail (Fin.init q) = Fin.init (Fin.tail q)","name":"Fin.tail_init_eq_init_tail","isProp":true,"docString":"`tail` and `init` commute. We state this lemma in a non-dependent setting, as otherwise it\nwould involve a cast to convince Lean that the two types are equal, making it harder to use. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí Preorder (œÄ i)] {a : (i : Œπ) ‚Üí œÄ i} {b : (i : Œπ) ‚Üí œÄ i}\n  {c : (i : Œπ) ‚Üí œÄ i} (hab : StrongLT a b) (hbc : b ‚â§ c), StrongLT a c","name":"StrongLT.trans_le","isProp":true,"docString":"**Alias** of `strongLT_of_strongLT_of_le`."},{"type":"‚àÄ (F : Sort u_3) {Œ± : Sort u_1} {Œ≤ : (a : Œ±) ‚Üí Sort u_2} [inst : FunLike F Œ± Œ≤] [inst : Finite Œ±]\n  [inst : ‚àÄ (i : Œ±), Finite (Œ≤ i)], Finite F","name":"FunLike.finite","isProp":true,"docString":"All `FunLike`s are finite if their domain and codomain are.\n\nCan't be an instance because it can cause infinite loops.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±],\n  (WellFounded fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x > x_1 : Prop) ‚Üî\n    (‚àÄ (a : ‚Ñï ‚Üío Œ±), ‚àÉ (n : ‚Ñï), ‚àÄ (m : ‚Ñï) (a_1 : n ‚â§ m), ‚Üëa n = ‚Üëa m : Prop)","name":"WellFounded.monotone_chain_condition","isProp":true,"docString":"The \"monotone chain condition\" below is sometimes a convenient form of well foundedness. "},{"type":"‚àÄ {Œ± : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ±' : Type u_1} {Œ¥ : Type u_2}\n  {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), f (g a) b = g' (f' b a)),\n  Option.map‚ÇÇ f (Option.map g a) b = Option.map g' (Option.map‚ÇÇ f' b a)","name":"Option.map‚ÇÇ_map_left_anticomm","isProp":true,"docString":"Symmetric statement to `Option.map_map‚ÇÇ_antidistrib_left`. "},{"type":"‚àÄ {M : Type u_2} [inst : Add M] {N : Type u_1} [inst_1 : Add N] (f : AddHom M N) (hf : Function.Surjective ‚Üëf),\n  AddHom.srange f = ‚ä§","name":"AddHom.srange_top_of_surjective","isProp":true,"docString":"The range of a surjective `add_semigroup` hom is the whole of the codomain."},{"type":"‚àÄ {E : Type u_1} [self : SeminormedGroup E] (x : E) (y : E), dist x y = ‚Äñx / y‚Äñ","name":"SeminormedGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G),\n  (Subgroup.Fg P : Prop) ‚Üî (‚àÉ (S : Set G), (Subgroup.closure S = P : Prop) ‚àß (Set.Finite S : Prop) : Prop)","name":"Subgroup.fg_iff","isProp":true,"docString":"An equivalent expression of `Subgroup.Fg` in terms of `Set.Finite` instead of `Finset`. "},{"type":"‚àÄ {m : Type u} {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±]\n  [inst_3 : Fintype m] [inst_4 : DecidableEq m] {A : Matrix m m Œ±} (e‚ÇÅ : n ‚âÉ m) (e‚ÇÇ : n ‚âÉ m),\n  (IsUnit (Matrix.submatrix A ‚Üëe‚ÇÅ ‚Üëe‚ÇÇ) : Prop) ‚Üî (IsUnit A : Prop)","name":"Matrix.isUnit_submatrix_equiv","isProp":true,"docString":"When lowered to a prop, `Matrix.invertibleOfSubmatrixEquivInvertible` forms an `iff`. "},{"type":"‚àÄ (L : List ‚Ñï), List.headI L ‚â§ List.sum L","name":"List.headI_le_sum","isProp":true,"docString":"This relies on `default ‚Ñï = 0`. "},{"type":"‚àÄ {M : Type u_1} {Œ± : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : VAdd M Œ±] [inst_2 : ContinuousConstVAdd M Œ±]\n  [inst_3 : VAdd M·µÉ·µí·µñ Œ±] [inst_4 : IsCentralVAdd M Œ±], ContinuousConstVAdd M·µÉ·µí·µñ Œ±","name":"ContinuousConstVAdd.op","isProp":true,"docString":"If an additive action is central, then its right action is continuous when its left\naction is."},{"type":"‚àÄ {M‚ÇÄ : Type u} [inst : Mul M‚ÇÄ] [inst_1 : Zero M‚ÇÄ] [self : IsRightCancelMulZero M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ} {c : M‚ÇÄ}\n  (a_1 : b ‚â† 0) (a_2 : a * b = c * b), a = c","name":"IsRightCancelMulZero.mul_right_cancel_of_ne_zero","isProp":true,"docString":"Multiplicatin by a nonzero element is right cancellative. "},{"type":"‚àÄ (p : (a : True) ‚Üí Prop), (‚àÄ (x : True), p x : Prop) ‚Üî (p (True.intro=:True) : Prop)","name":"forall_true_left","isProp":true,"docString":"See `IsEmpty.forall_iff` for the `false` version. "},{"type":"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {r : ‚Ñù} (hr : 0 < r) (x : E),\n  x +·µ• r ‚Ä¢ Metric.ball 0 1 = Metric.ball x r","name":"affinity_unitBall","isProp":true,"docString":"Any ball `Metric.ball x r`, `0 < r` is the image of the unit ball under `Œª y, x + r ‚Ä¢ y`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {Z : C} {X : C} {Y : C} (f : Z ‚ü∂ X) (g : Z ‚ü∂ Y)\n  [inst_1 : CategoryTheory.Limits.HasPushout f g],\n  CategoryTheory.IsPushout f g CategoryTheory.Limits.pushout.inl CategoryTheory.Limits.pushout.inr","name":"CategoryTheory.IsPushout.of_hasPushout","isProp":true,"docString":"The pushout provided by `HasPushout f g` fits into a `IsPushout`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D]\n  {F : CategoryTheory.LaxMonoidalFunctor C D} {G : CategoryTheory.LaxMonoidalFunctor C D}\n  (self : CategoryTheory.MonoidalNatTrans F G),\n  CategoryTheory.LaxMonoidalFunctor.Œµ F ‚â´ (CategoryTheory.MonoidalNatTrans.toNatTrans self).app (ùüô_ C) =\n    CategoryTheory.LaxMonoidalFunctor.Œµ G","name":"CategoryTheory.MonoidalNatTrans.unit","isProp":true,"docString":"The unit condition for a monoidal natural transformation. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasBinaryCoproducts C","name":"hasBinaryCoproducts_of_hasInitial_and_pushouts","isProp":true,"docString":"Any category with pushouts and initial object has binary coproducts. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {J : Type}\n  [inst_2 : Fintype J] {f : (a : J) ‚Üí C} (b : CategoryTheory.Limits.Bicone f)\n  (total :\n    (Finset.sum Finset.univ fun (j : J) ‚Ü¶ CategoryTheory.Limits.Bicone.œÄ b j ‚â´ CategoryTheory.Limits.Bicone.Œπ b j) =\n      ùüô (CategoryTheory.Limits.Bicone.pt b)),\n  CategoryTheory.Limits.HasBiproduct f","name":"CategoryTheory.Limits.hasBiproduct_of_total","isProp":true,"docString":"In a preadditive category, we can construct a biproduct for `f : J ‚Üí C` from\nany bicone `b` for `f` satisfying `total : ‚àë j : J, b.œÄ j ‚â´ b.Œπ j = ùüô b.X`.\n\n(That is, such a bicone is a limit cone and a colimit cocone.)\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {B : Finset (Finset Œ±)} {n : ‚Ñï} [inst_1 : Fintype Œ±]\n  (h : ‚àÄ (a : Œ±), n ‚â§ Finset.card (Finset.filter ((fun (x : Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚àà x_1) a) B)),\n  Fintype.card Œ± * n ‚â§ Finset.sum B fun (s : Finset Œ±) ‚Ü¶ Finset.card s","name":"Finset.le_sum_card","isProp":true,"docString":"If every element belongs to at least `n` Finsets, then the sum of their sizes is at least `n`\ntimes how many they are. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} {z : M} (hxy : SameRay R x y) (hyz : SameRay R y z)\n  (hy : ‚àÄ (a : y = 0), (x = 0 : Prop) ‚à® (z = 0 : Prop)), SameRay R x z","name":"SameRay.trans","isProp":true,"docString":"`SameRay` is transitive unless the vector in the middle is zero and both other vectors are\nnonzero. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (0 ‚â§ -a : Prop) ‚Üî (a ‚â§ 0 : Prop)","name":"Right.nonneg_neg_iff","isProp":true,"docString":"Uses `right` co(ntra)variant."},{"type":"‚àÄ (R : Type u_1) {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] (w : (a : œÉ) ‚Üí M)\n  (m : M), MvPolynomial.IsWeightedHomogeneous w 0 m","name":"MvPolynomial.isWeightedHomogeneous_zero","isProp":true,"docString":"0 is weighted homogeneous of any degree. "},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E} (h : Convex ‚Ñù s) (hne : Set.Nonempty s),\n  IsConnected s","name":"Convex.isConnected","isProp":true,"docString":"A nonempty convex set is connected. "},{"type":"‚àÄ {S : Set Ordinal} (hS : Set.Unbounded (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x < x_1) S) (a : Ordinal),\n  Set.Nonempty (S ‚à© Set.Ici a)","name":"Ordinal.enumOrd_def'_nonempty","isProp":true,"docString":"The set in `enumOrd_def'` is nonempty. "},{"type":"‚àÄ {Œ± : Type u_1} [self : Semifield Œ±] (a : Œ±), Semifield.zpow 0 a = 1","name":"Semifield.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {I : Type u_1} [inst : DecidableEq I] {Z : (a : I) ‚Üí Type u_3} [inst_1 : (i : I) ‚Üí AddCommMonoid (Z i)]\n  [inst_2 : Finite I] (M : Type u_2) [inst_3 : AddCommMonoid M] (g : ((i : I) ‚Üí Z i) ‚Üí+ M) (h : ((i : I) ‚Üí Z i) ‚Üí+ M)\n  (H : ‚àÄ (i : I), AddMonoidHom.comp g (AddMonoidHom.single Z i) = AddMonoidHom.comp h (AddMonoidHom.single Z i)), g = h","name":"AddMonoidHom.functions_ext'","isProp":true,"docString":"This is used as the ext lemma instead of `AddMonoidHom.functions_ext` for reasons explained in\nnote [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : (a : Œ±) ‚Üí Œ≤) (a : Nonempty Œ±), Nonempty Œ≤","name":"Nonempty.map","isProp":true,"docString":"Given `f : Œ± ‚Üí Œ≤`, if `Œ±` is nonempty then `Œ≤` is also nonempty.\n`Nonempty` cannot be a `functor`, because `Functor` is restricted to `Type`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CompleteLattice Œ±] {f : Filter Œ≤} {p : (a : Œ≤) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop}\n  {u : (a : Œ≤) ‚Üí Œ±},\n  (Filter.bliminf u f fun (x : Œ≤) ‚Ü¶ (p x : Prop) ‚à® (q x : Prop)) ‚â§ Filter.bliminf u f p ‚äì Filter.bliminf u f q","name":"Filter.bliminf_or_le_inf","isProp":true,"docString":"See also `Filter.bliminf_or_eq_inf`. "},{"type":"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p : Prop)], padicNorm p ‚Üëp = (‚Üëp)‚Åª¬π","name":"padicNorm.padicNorm_p_of_prime","isProp":true,"docString":"The `p`-adic norm of `p` is `p‚Åª¬π` if `p` is prime.\n\nSee also `padicNorm.padicNorm_p` for a version assuming `1 < p`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Groupoid C] (c : C) (Œ≥ : c ‚ü∂ c), Œ≥‚Åª¬π = CategoryTheory.inv Œ≥","name":"CategoryTheory.Groupoid.vertexGroup.inv_eq_inv","isProp":true,"docString":"The inverse in the group is equal to the inverse given by `CategoryTheory.inv`. "},{"type":"‚àÄ (Œ± : Type u_1), (Subsingleton Œ± : Prop) ‚à® (Nontrivial Œ± : Prop)","name":"subsingleton_or_nontrivial","isProp":true,"docString":"A type is either a subsingleton or nontrivial. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasCokernels C], CategoryTheory.Limits.HasCoequalizers C","name":"CategoryTheory.Preadditive.hasCoequalizers_of_hasCokernels","isProp":true,"docString":"If a preadditive category has all cokernels, then it also has all coequalizers. "},{"type":"‚àÄ {R : Type u_2} [inst : StrictOrderedCommSemiring R] {M : Type u_1} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {v : M} (h : v ‚â† 0) {r : R} (hr : 0 < r) (hrv : r ‚Ä¢ v ‚â† 0), rayOfNeZero R (r ‚Ä¢ v) hrv = rayOfNeZero R v h","name":"ray_pos_smul","isProp":true,"docString":"The ray given by a positive multiple of a nonzero vector. "},{"type":"‚àÄ {Œ± : Type u_1} [self : DivisionSemiring Œ±] (a : Œ±) (b : Œ±), a / b = a * b‚Åª¬π","name":"DivisionSemiring.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LE Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} {a : Œ±}\n  (h : f ‚â§·∂†[nhds a] g), Filter.Eventually (fun (y : Œ±) ‚Ü¶ f ‚â§·∂†[nhds y] g) (nhds a)","name":"Filter.EventuallyLE.eventuallyLE_nhds","isProp":true,"docString":"If `f x ‚â§ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x ‚â§ g x` in a neighbourhood of `y`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =Œò[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ), f =Œò[l] g'","name":"Asymptotics.IsTheta.of_norm_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isTheta_norm_right`."},{"type":"‚àÄ {Œπ : Type u} {X : Type v} [inst : TopologicalSpace X] [inst_1 : ParacompactSpace X] {s : Set X} (hs : IsClosed s)\n  (u : (a : Œπ) ‚Üí Set X) (uo : ‚àÄ (i : Œπ), IsOpen (u i)) (us : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ u i),\n  ‚àÉ (v : (a : Œπ) ‚Üí Set X),\n    (‚àÄ (i : Œπ), IsOpen (v i) : Prop) ‚àß\n      ((s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ v i : Prop) ‚àß ((LocallyFinite v : Prop) ‚àß (‚àÄ (i : Œπ), v i ‚äÜ u i : Prop) : Prop) :\n        Prop)","name":"precise_refinement_set","isProp":true,"docString":"In a paracompact space, every open covering of a closed set admits a locally finite refinement\nindexed by the same type. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} [inst_1 : T1Space Œ±],\n  (Preperfect C : Prop) ‚Üî (Perfect (closure C) : Prop)","name":"preperfect_iff_perfect_closure","isProp":true,"docString":"In a T1 space, being preperfect is equivalent to having perfect closure."},{"type":"‚àÄ {Œ± : Type u} (L : List Œ±) {i : ‚Ñï} {j : ‚Ñï} (hi : i < List.length L) (hj : i < j),\n  List.get L { val := i, isLt := hi } =\n    List.get (List.take j L)\n      { val := i,\n        isLt :=\n          ((Eq.rec ((lt_min hj hi=:i < min j (List.length L))=:i < min j (List.length L))\n                ((Eq.symm\n                      ((List.length_take j\n                            L=:List.length (List.take j L) =\n                            min j\n                              (List.length\n                                L))=:List.length (List.take j L) =\n                          min j\n                            (List.length\n                              L))=:min j (List.length L) =\n                      List.length\n                        (List.take j\n                          L))=:min j (List.length L) =\n                    List.length (List.take j L))=:i < List.length (List.take j L))=:i < List.length (List.take j L)) }","name":"List.get_take","isProp":true,"docString":"The `i`-th element of a list coincides with the `i`-th element of any of its prefixes of\nlength `> i`. Version designed to rewrite from the big list to the small list. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddMonoid Œ±], FaithfulSMul (AddMonoid.End Œ±) Œ±","name":"AddMonoid.End.applyFaithfulSMul","isProp":true,"docString":"`AddMonoid.End.applyDistribMulAction` is faithful. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Ü™ Œ≤} (s‚ÇÅ : Finset Œ±) (s‚ÇÇ : Finset Œ±)\n  (h' : Disjoint (Finset.map f s‚ÇÅ) (Finset.map f s‚ÇÇ))\n  (h :\n    optParam (Disjoint s‚ÇÅ s‚ÇÇ : Prop)\n      ((Iff.mp\n            ((Finset.disjoint_map\n                  f=:(Disjoint (Finset.map f s‚ÇÅ) (Finset.map f s‚ÇÇ) : Prop) ‚Üî\n                  (Disjoint s‚ÇÅ s‚ÇÇ :\n                    Prop))=:(Disjoint (Finset.map f s‚ÇÅ) (Finset.map f s‚ÇÇ) : Prop) ‚Üî (Disjoint s‚ÇÅ s‚ÇÇ : Prop))\n            h'=:Disjoint s‚ÇÅ s‚ÇÇ)=:Disjoint s‚ÇÅ s‚ÇÇ)),\n  Finset.map f (Finset.disjUnion s‚ÇÅ s‚ÇÇ h) = Finset.disjUnion (Finset.map f s‚ÇÅ) (Finset.map f s‚ÇÇ) h'","name":"Finset.map_disjUnion'","isProp":true,"docString":"A version of `Finset.map_disjUnion` for writing in the other direction. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_1} {Œ≥ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (f : C(Œ±, Œ≤)), Continuous fun (g : C(Œ≤, Œ≥)) ‚Ü¶ ContinuousMap.comp g f","name":"ContinuousMap.continuous_comp_left","isProp":true,"docString":"C(-, Œ≥) is a functor. "},{"type":"‚àÄ {v : Sat.Valuation} {l : Sat.Literal} {a : Prop} (h‚ÇÅ : Sat.Literal.reify v l (a : Prop)),\n  Sat.Clause.reify v (Sat.Clause.cons l Sat.Clause.nil) (a : Prop)","name":"Sat.Clause.reify_one","isProp":true,"docString":"The reification of a singleton clause `¬¨‚ü¶l‚üß_v ‚â° ¬¨‚ü¶l‚üß_v`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (x : Œ±) [inst_1 : Filter.NeBot (nhdsWithin x ({x}·∂ú))],\n  closure ({x}·∂ú) = Set.univ","name":"closure_compl_singleton","isProp":true,"docString":"If `x` is not an isolated point of a topological space, then the closure of `{x}·∂ú` is the whole\nspace. "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} [inst : Semiring R‚ÇÅ] {M‚ÇÅ : Type u_2} [inst_1 : TopologicalSpace M‚ÇÅ] [inst_2 : AddCommMonoid M‚ÇÅ]\n  [inst_3 : Module R‚ÇÅ M‚ÇÅ] [inst_4 : TopologicalSpace R‚ÇÅ] {f : R‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÅ} {g : R‚ÇÅ ‚âÉL[R‚ÇÅ] M‚ÇÅ} (h : ‚Üëf 1 = ‚Üëg 1), f = g","name":"ContinuousLinearEquiv.ext‚ÇÅ","isProp":true,"docString":"An extensionality lemma for `R ‚âÉL[R] M`. "},{"type":"‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±], 0 ‚â§ 1","name":"StrictOrderedRing.zero_le_one","isProp":true,"docString":"In a strict ordered ring, `0 ‚â§ 1`. "},{"type":"‚àÄ {w : List ‚Ñï} {hw : List.Sorted (fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x ‚â• x_1) w} (i : Fin (List.length w)),\n  YoungDiagram.rowLen (YoungDiagram.ofRowLens w hw) ‚Üëi = List.get w i","name":"YoungDiagram.rowLen_ofRowLens","isProp":true,"docString":"The length of the `i`th row in `ofRowLens w hw` is the `i`th entry of `w` "},{"type":"‚àÄ {Œπ : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset Œπ} {f : (a : Œπ) ‚Üí WithTop R}\n  (h : ‚àÄ (i : Œπ) (a : i ‚àà s), f i ‚â† ‚ä§), (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) < ‚ä§","name":"WithTop.prod_lt_top","isProp":true,"docString":"A product of finite numbers is still finite "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (u : RÀ£) (hu : 0 < ‚Üëu) (v : Module.Ray R M), u ‚Ä¢ v = v","name":"Module.Ray.units_smul_of_pos","isProp":true,"docString":"Scaling by a positive unit is a no-op. "},{"type":"‚àÄ (k : Type u_3) {V1 : Type u_2} {P1 : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\n  [inst_3 : AddTorsor V1 P1] (p : P1), ‚Üë(AffineMap.id k P1) p = p","name":"AffineMap.id_apply","isProp":true,"docString":"The identity affine map acts as the identity. "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R), 0 ‚àà s","name":"Subsemiring.zero_mem","isProp":true,"docString":"A subsemiring contains the semiring's 0. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (self : Subsemigroup M) {a : M} {b : M} (a_1 : a ‚àà Subsemigroup.carrier self)\n  (a_2 : b ‚àà Subsemigroup.carrier self), a * b ‚àà Subsemigroup.carrier self","name":"Subsemigroup.mul_mem'","isProp":true,"docString":"The product of two elements of a subsemigroup belongs to the subsemigroup. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCommRing Œ±] (a : Œ±) (b : Œ±), a * b = b * a","name":"LinearOrderedCommRing.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x : X} {y : X} (a : x ‚§≥ y), pure x ‚â§ nhds y","name":"Specializes.pure_le_nhds","isProp":true,"docString":"**Alias** of the forward direction of `specializes_iff_pure`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Finset Œ±} {t : Finset Œ±}\n  (h :\n    ‚àÄ (x : Œ±) (x_1 : x ‚àà s) (y : Œ±) (x_2 : y ‚àà s) (a : x < y) (a : ‚àÄ (z : Œ±) (a : z ‚àà s), ¬¨(z ‚àà Set.Ioo x y : Prop)),\n      ‚àÉ (z : Œ±), (z ‚àà t : Prop) ‚àß ((x < z : Prop) ‚àß (z < y : Prop) : Prop)),\n  Finset.card s ‚â§ Finset.card (t \\ s) + 1","name":"Finset.card_le_diff_of_interleaved","isProp":true,"docString":"If finsets `s` and `t` are interleaved, then `Finset.card s ‚â§ Finset.card (t \\ s) + 1`. "},{"type":"‚àÄ {Œ± : Type u_1} {N : Type u_2} [inst : CommMonoid N] {f : (a : Œ±) ‚Üí N} (a : Œ±)\n  (hf : Set.Finite (Function.mulSupport f)), f a ‚à£ finprod f","name":"finprod_mem_dvd","isProp":true,"docString":"If the multiplicative support of `f` is finite, then for every `x` in the domain of `f`, `f x`\ndivides `finprod f`.  "},{"type":"‚àÄ (S : Set ‚Ñù) (hS : ‚àÄ (x : ‚Ñù) (a : x ‚àà S), x ‚â§ 0), inf‚Çõ S ‚â§ 0","name":"Real.inf‚Çõ_nonpos","isProp":true,"docString":"As `0` is the default value for `Real.inf‚Çõ` of the empty set or sets which are not bounded below, it\nsuffices to show that `S` is bounded above by `0` to show that `inf‚Çõ S ‚â§ 0`.\n"},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] (P : Module R M) (Q : Module R M)\n  (w : ‚àÄ (r : R) (m : M), r ‚Ä¢ m = r ‚Ä¢ m), P = Q","name":"Module.ext'","isProp":true,"docString":"A variant of `Module.ext` that's convenient for term-mode. "},{"type":"‚àÄ {p : ‚Ñï} (a : Prime p), Nat.Prime p","name":"Prime.nat_prime","isProp":true,"docString":"**Alias** of the reverse direction of `Nat.prime_iff`."},{"type":"‚àÄ {Œ± : Type u_1} (Œ≤ : Type u_2) [inst : UniformSpace Œ≤] (x : Œ±), UniformContinuous (Function.eval x ‚àò ‚ÜëUniformFun.toFun)","name":"UniformFun.uniformContinuous_eval","isProp":true,"docString":"Evaluation at a fixed point is uniformly continuous on `Œ± ‚Üí·µ§ Œ≤`. "},{"type":"‚àÄ (X : Type u), CategoryTheory.Projective X","name":"CategoryTheory.Projective.instProjectiveTypeTypes","isProp":true,"docString":"The axiom of choice says that every type is a projective object in `Type`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : SeminormedRing ùïú] [inst_1 : SMul ùïú E] [inst_2 : Zero E]\n  [inst_3 : TopologicalSpace E] {s‚ÇÅ : Set E} {s‚ÇÇ : Set E} (h : s‚ÇÅ ‚äÜ s‚ÇÇ) (hs‚ÇÇ : Bornology.IsVonNBounded ùïú s‚ÇÇ),\n  Bornology.IsVonNBounded ùïú s‚ÇÅ","name":"Bornology.IsVonNBounded.subset","isProp":true,"docString":"Subsets of bounded sets are bounded. "},{"type":"‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Preadditive V]\n  {c : ComplexShape Œπ} {C : HomologicalComplex V c} {D : HomologicalComplex V c} {E : HomologicalComplex V c}\n  (f : C ‚ü∂ D)\n  (hom : (i : Œπ) ‚Üí (j : Œπ) ‚Üí (a : ComplexShape.Rel c j i) ‚Üí HomologicalComplex.X D i ‚ü∂ HomologicalComplex.X E j),\n  f ‚â´ Homotopy.nullHomotopicMap' hom =\n    Homotopy.nullHomotopicMap' fun (i : Œπ) (j : Œπ) (hij : ComplexShape.Rel c j i) ‚Ü¶\n      HomologicalComplex.Hom.f f i ‚â´ hom i j hij","name":"Homotopy.comp_nullHomotopicMap'","isProp":true,"docString":"Compatibility of `nullHomotopicMap'` with the precomposition by a morphism\nof complexes. "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {X : outParam (Type u_3)} {Y : outParam (Type u_4)} [inst : SMul M X]\n  [inst_1 : SMul M Y] [self : SMulHomClass F M X Y] (f : F) (c : M) (x : X), ‚Üëf (c ‚Ä¢ x) = c ‚Ä¢ ‚Üëf x","name":"SMulHomClass.map_smul","isProp":true,"docString":"The proposition that the function preserves the action. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] {s : Set Œ±} (hs : IsCompact s), BddAbove s","name":"IsCompact.bddAbove","isProp":true,"docString":"A compact set is bounded above "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 < a) (hb : 1 ‚â§ b), 1 < a * b","name":"one_lt_mul_of_lt_of_le'","isProp":true,"docString":"**Alias** of `Left.one_lt_mul_of_lt_of_le`."},{"type":"‚àÄ {R : Type u} [inst : Ring R], SMulCommClass R { x : R // x ‚àà Subring.center R } R","name":"Subring.center.smulCommClass_right","isProp":true,"docString":"The center of a semiring acts commutatively on that semiring. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\n  (AddSubgroup.index H = 2 : Prop) ‚Üî (‚àÉ (a : G), ‚àÄ (b : G), Xor' (b + a ‚àà H : Prop) (b ‚àà H : Prop) : Prop)","name":"AddSubgroup.index_eq_two_iff","isProp":true,"docString":"An additive subgroup has index two if and only if there exists `a` such that\nfor all `b`, exactly one of `b + a` and `b` belong to `H`."},{"type":"‚àÄ {C : Type v} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) (g : X ‚ü∂ Y)\n  (w :\n    ‚àÄ (x : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.ConcreteCategory.Forget) X),\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget C)) f x =\n        Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget C)) g x),\n  f = g","name":"CategoryTheory.ConcreteCategory.hom_ext","isProp":true,"docString":"In any concrete category, we can test equality of morphisms by pointwise evaluations."},{"type":"‚àÄ {R : Type u} {a : R} [inst : Semiring R] {p : Polynomial R} (h : a * Polynomial.leadingCoeff p ‚â† 0),\n  Polynomial.natDegree (‚ÜëPolynomial.C a * p) = Polynomial.natDegree p","name":"Polynomial.natDegree_C_mul_eq_of_mul_ne_zero","isProp":true,"docString":"Although not explicitly stated, the assumptions of lemma `nat_degree_C_mul_eq_of_mul_ne_zero`\nforce the polynomial `p` to be non-zero, via `p.leading_coeff ‚â† 0`.\n"},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R) {a : R} {b : R}\n  (a_1 : a ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid self)))\n  (a_2 : b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid self))),\n  a + b ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid self))","name":"Subsemiring.add_mem'","isProp":true,"docString":"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} {M : Type u_3} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} [inst_1 : Finite Œπ]\n  {t : (a : Œπ) ‚Üí Set Œ±} (h : Pairwise (Disjoint on t)) (ht : ‚àÄ (i : Œπ), Set.Finite (t i)),\n  (finsum fun (a : Œ±) ‚Ü¶ finsum fun (h : a ‚àà Set.union·µ¢ fun (i : Œπ) ‚Ü¶ t i) ‚Ü¶ f a) =\n    finsum fun (i : Œπ) ‚Ü¶ finsum fun (a : Œ±) ‚Ü¶ finsum fun (h : a ‚àà t i) ‚Ü¶ f a","name":"finsum_mem_union·µ¢","isProp":true,"docString":"Given a family of pairwise disjoint finite sets `t i` indexed by a finite type, the\nsum of `f a` over the union `‚ãÉ i, t i` is equal to the sum over all indexes `i` of the\nsums of `f a` over `a ‚àà t i`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : EMetricSpace Œ±] {K : NNReal} {f : (a : Œ±) ‚Üí Œ±} {s : Set Œ±} (hsc : IsComplete s)\n  (hsf : Set.MapsTo f s s) (hf : ContractingWith K (Set.MapsTo.restrict f s s hsf)) {x : Œ±} (hxs : x ‚àà s)\n  (hx : edist x (f x) ‚â† ‚ä§),\n  ‚àÉ (y : Œ±),\n    (y ‚àà s : Prop) ‚àß\n      ((Function.IsFixedPt f y : Prop) ‚àß\n          ((Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ (f^[n]) x) Filter.atTop (nhds y) : Prop) ‚àß\n              (‚àÄ (n : ‚Ñï), edist ((f^[n]) x) y ‚â§ edist x (f x) * ‚ÜëK ^ n / (1 - ‚ÜëK) : Prop) :\n            Prop) :\n        Prop)","name":"ContractingWith.exists_fixedPoint'","isProp":true,"docString":"Banach fixed-point theorem for maps contracting on a complete subset. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Lattice Œ±] [inst_1 : Lattice Œ≤] (self : LatticeHom Œ± Œ≤) (a : Œ±) (b : Œ±),\n  SupHom.toFun (LatticeHom.toSupHom self) (a ‚äì b) =\n    SupHom.toFun (LatticeHom.toSupHom self) a ‚äì SupHom.toFun (LatticeHom.toSupHom self) b","name":"LatticeHom.map_inf'","isProp":true,"docString":"A `LatticeHom` preserves infima. "},{"type":"‚àÄ {G : Type u} {n : ‚Ñï} [inst : LeftCancelMonoid G] [inst_1 : Finite G] (x : G),\n  orderOf (x ^ n) = orderOf x / Nat.gcd (orderOf x) n","name":"orderOf_pow","isProp":true,"docString":"This is the same as `orderOf_pow'` and `orderOf_pow''` but with one assumption less which is\nautomatic in the case of a finite cancellative monoid."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {l : Filter Œ±} {f : (a : Œ±) ‚Üí E}\n  (h : Filter.Tendsto (fun (y : Œ±) ‚Ü¶ ‚Äñf y‚Äñ) l Filter.atTop) (x : E), Filter.Eventually (fun (y : Œ±) ‚Ü¶ f y ‚â† x) l","name":"eventually_ne_of_tendsto_norm_atTop'","isProp":true,"docString":"If `‚Äñy‚Äñ ‚Üí ‚àû`, then we can assume `y ‚â† x` for any fixed `x`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type u} (f : (a : Œ≤) ‚Üí Œ±) (Œ∏ : Cardinal) (hŒ∏ : Œ∏ ‚â§ Cardinal.mk Œ≤) (h‚ÇÅ : Cardinal.aleph0 ‚â§ Œ∏)\n  (h‚ÇÇ : Cardinal.mk Œ± < Ordinal.cof (Cardinal.ord Œ∏)), ‚àÉ (a : Œ±), Œ∏ ‚â§ Cardinal.mk ‚Üë(f ‚Åª¬π' {a})","name":"Ordinal.infinite_pigeonhole_card","isProp":true,"docString":"Pigeonhole principle for a cardinality below the cardinality of the domain "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] (x : Œ±),\n  ‚àÉ (U : Set Œ±), (IsOpen U : Prop) ‚àß ((x ‚àà U : Prop) ‚àß (IsCompact (closure U) : Prop) : Prop)","name":"exists_open_with_compact_closure","isProp":true,"docString":"In a locally compact T‚ÇÇ space, every point has an open neighborhood with compact closure "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] (f : (a : ‚Ñï) ‚Üí Œ±) (n : ‚Ñï),\n  (Finset.prod Finset.univ fun (i : Fin n) ‚Ü¶ f ‚Üëi) = Finset.prod (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f i","name":"Fin.prod_univ_eq_prod_range","isProp":true,"docString":"It is equivalent to compute the product of a function over `Fin n` or `Finset.range n`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1","name":"CanonicallyOrderedCommSemiring.natCast_succ","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` is a homomorphism. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Nontrivial s), ¬¨(Set.Subsingleton s : Prop)","name":"Set.Nontrivial.not_subsingleton","isProp":true,"docString":"**Alias** of the reverse direction of `Set.not_subsingleton_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {ua1 : UniformSpace Œ±} {ua2 : UniformSpace Œ±}\n  {ub1 : UniformSpace Œ≤} {ub2 : UniformSpace Œ≤} {uc1 : UniformSpace Œ≥}\n  (h : UniformContinuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)),\n  UniformContinuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)","name":"uniformContinuous_inf_dom_left‚ÇÇ","isProp":true,"docString":"A version of `UniformContinuous.inf_dom_left` for binary functions "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (S : Subsemigroup M), Subsemigroup.closure ‚ÜëS = S","name":"Subsemigroup.closure_eq","isProp":true,"docString":"Closure of a subsemigroup `S` equals `S`. "},{"type":"‚àÄ {R : Type u} {A : Type v} [inst : Star R] [inst_1 : Star A] [inst_2 : SMul R A] [self : StarModule R A] (r : R)\n  (a : A), star (r ‚Ä¢ a) = star r ‚Ä¢ star a","name":"StarModule.star_smul","isProp":true,"docString":"`star` commutes with scalar multiplication "},{"type":"‚àÄ {Œ≤ : Type u_1} {Œ± : Type u_1} (f : (a : Œ≤) ‚Üí Œ±) (w : Cardinal.mk Œ± < Cardinal.mk Œ≤) (w' : Infinite Œ±),\n  ‚àÉ (a : Œ±), Infinite ‚Üë(f ‚Åª¬π' {a})","name":"Cardinal.exists_infinite_fiber","isProp":true,"docString":"A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas an infinite fiber.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (self : LocalEquiv Œ± Œ≤) ‚¶Éx : Œ≤‚¶Ñ (a : x ‚àà LocalEquiv.target self),\n  LocalEquiv.invFun self x ‚àà LocalEquiv.source self","name":"LocalEquiv.map_target'","isProp":true,"docString":"The proposition that elements of `target` are mapped to elements of `source`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {s : Set Œ±} {t : Set Œ≤}\n  (a :\n    LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à©\n        ‚Üëe ‚Åª¬π' (LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à© t) =\n      LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© s),\n  LocalHomeomorph.IsImage e s t","name":"LocalHomeomorph.IsImage.of_preimage_eq'","isProp":true,"docString":"**Alias** of the reverse direction of `LocalHomeomorph.IsImage.iff_preimage_eq'`."},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} [inst : DistribLattice Œ±] [inst_1 : OrderBot Œ±] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  (a : Set.PairwiseDisjoint (‚Üës) f), Finset.SupIndep s f","name":"Set.PairwiseDisjoint.supIndep","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.supIndep_iff_pairwiseDisjoint`."},{"type":"‚àÄ {P : (a : EReal) ‚Üí (a : EReal) ‚Üí Prop} (top_top : P ‚ä§ ‚ä§) (top_pos : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚ä§ ‚Üëx) (top_zero : P ‚ä§ 0)\n  (top_neg : ‚àÄ (x : ‚Ñù) (a : x < 0), P ‚ä§ ‚Üëx) (top_bot : P ‚ä§ ‚ä•) (pos_top : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚Üëx ‚ä§)\n  (pos_bot : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚Üëx ‚ä•) (zero_top : P 0 ‚ä§) (coe_coe : ‚àÄ (x : ‚Ñù) (y : ‚Ñù), P ‚Üëx ‚Üëy) (zero_bot : P 0 ‚ä•)\n  (neg_top : ‚àÄ (x : ‚Ñù) (a : x < 0), P ‚Üëx ‚ä§) (neg_bot : ‚àÄ (x : ‚Ñù) (a : x < 0), P ‚Üëx ‚ä•) (bot_top : P ‚ä• ‚ä§)\n  (bot_pos : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚ä• ‚Üëx) (bot_zero : P ‚ä• 0) (bot_neg : ‚àÄ (x : ‚Ñù) (a : x < 0), P ‚ä• ‚Üëx)\n  (bot_bot : P ‚ä• ‚ä•) (x : EReal) (y : EReal), P x y","name":"EReal.induction‚ÇÇ","isProp":true,"docString":"Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero M] [inst_1 : AddCommMonoid N] (f : Œ± ‚Üí‚ÇÄ M) (y : Œ±)\n  (g : (a : Œ±) ‚Üí (a : M) ‚Üí N) (hg : ‚àÄ (i : Œ±), g i 0 = 0),\n  g y (‚Üëf y) + Finsupp.sum (Finsupp.erase y f) g = Finsupp.sum f g","name":"Finsupp.add_sum_erase'","isProp":true,"docString":"Generalization of `Finsupp.add_sum_erase`: if `g` maps a second argument of 0\nto 0, then its sum over `f : Œ± ‚Üí‚ÇÄ M` is the same as adding the value on any element\n`y : Œ±` to the sum over `erase y f`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P} {direction : Submodule k V},\n  (p‚ÇÇ ‚àà AffineSubspace.mk' p‚ÇÅ direction : Prop) ‚Üî (p‚ÇÇ -·µ• p‚ÇÅ ‚àà direction : Prop)","name":"AffineSubspace.mem_mk'_iff_vsub_mem","isProp":true,"docString":"A point lies in an affine subspace constructed from another point and a direction if and only\nif their difference is in that direction. "},{"type":"‚àÄ {M : Type u} [inst : AddMonoid M] (a : M), 2 ‚Ä¢ a = a + a","name":"two_nsmul","isProp":true,"docString":""},{"type":"‚àÄ {M : Type u_2} {R : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : SetLike M R] [inst_2 : MulMemClass M R]\n  {S : M} {a : R} {b : R} (ha : a ‚àà AddSubmonoid.closure ‚ÜëS) (hb : b ‚àà S), a * b ‚àà AddSubmonoid.closure ‚ÜëS","name":"MulMemClass.mul_right_mem_add_closure","isProp":true,"docString":"The product of an element of the additive closure of a multiplicative subsemigroup `M`\nand an element of `M` is contained in the additive closure of `M`. "},{"type":"‚àÄ {X : (a : ‚Ñï) ‚Üí Type u} [inst : (n : ‚Ñï) ‚Üí MetricSpace (X n)] {f : (n : ‚Ñï) ‚Üí (a : X n) ‚Üí X (n + 1)}\n  (I : ‚àÄ (n : ‚Ñï), Isometry (f n)) (x : (n : ‚Ñï) √ó X n) (y : (n : ‚Ñï) √ó X n) (m : ‚Ñï) (hx : Sigma.fst x ‚â§ m)\n  (hy : Sigma.fst y ‚â§ m),\n  Metric.inductiveLimitDist f x y =\n    dist (Nat.leRecOn hx (fun {k : ‚Ñï} ‚Ü¶ f k) (Sigma.snd x)) (Nat.leRecOn hy (fun {k : ‚Ñï} ‚Ü¶ f k) (Sigma.snd y))","name":"Metric.inductiveLimitDist_eq_dist","isProp":true,"docString":"The predistance on the disjoint union `Œ£ n, X n` can be computed in any `X k` for large\nenough `k`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : DecidableEq Œ≥] {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥}\n  {f' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Finset Œ±} {t : Finset Œ≤} (h : ‚àÄ (a : Œ±) (b : Œ≤), f a b = f' a b),\n  Finset.image‚ÇÇ f s t = Finset.image‚ÇÇ f' s t","name":"Finset.image‚ÇÇ_congr'","isProp":true,"docString":"A common special case of `image‚ÇÇ_congr` "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {E' : Type u_3} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : f' =O[l] g), (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =O[l] g","name":"Asymptotics.IsBigO.norm_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigO_norm_left`."},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {Œ± : Type u_3} [inst : SMul M Œ±] [inst_1 : SMul N Œ±] [self : SMulCommClass M N Œ±]\n  (m : M) (n : N) (a : Œ±), m ‚Ä¢ n ‚Ä¢ a = n ‚Ä¢ m ‚Ä¢ a","name":"SMulCommClass.smul_comm","isProp":true,"docString":"`‚Ä¢` is left commutative "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {P : C} {Q : C}\n  (self : CategoryTheory.Limits.BinaryBicone P Q),\n  CategoryTheory.Limits.BinaryBicone.inr self ‚â´ CategoryTheory.Limits.BinaryBicone.snd self = ùüô Q","name":"CategoryTheory.Limits.BinaryBicone.inr_snd","isProp":true,"docString":"A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ‚â´ fst = ùüô P`, `inl ‚â´ snd = 0`, `inr ‚â´ fst = 0`, and `inr ‚â´ snd = ùüô Q`\n"},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [self : IsLocalization M S] {x : R} {y : R},\n  (‚Üë(algebraMap R S) x = ‚Üë(algebraMap R S) y : Prop) ‚Üî (‚àÉ (c : { x : R // x ‚àà M }), ‚Üëc * x = ‚Üëc * y : Prop)","name":"IsLocalization.eq_iff_exists'","isProp":true,"docString":"The kernel of `algebraMap` is the annihilator of `M` "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hab : a ‚äÇ b) (hbc : b = c), a ‚äÇ c","name":"HasSSubset.SSubset.trans_eq","isProp":true,"docString":"**Alias** of `ssubset_of_ssubset_of_eq`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤) [inst : Nontrivial Œ≤],\n  Nontrivial Œ±","name":"RingHom.domain_nontrivial","isProp":true,"docString":"If there is a homomorphism `f : Œ± ‚Üí+* Œ≤` and `Œ≤` is nontrivial, then `Œ±` is nontrivial. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤} [inst_4 : Fintype Œπ]\n  (hfg : Antivary f g),\n  (Fintype.card Œπ ‚Ä¢ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) ‚â§\n    (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i) ‚Ä¢ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ g i","name":"Antivary.card_smul_sum_le_sum_smul_sum","isProp":true,"docString":"**Chebyshev's Sum Inequality**: When `f` and `g` antivary together (eg one is monotone, the\nother is antitone), the scalar product of their sum is less than the size of the set times their\nscalar product. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {U : Set Œ±} {hU : IsOpen U}, ‚Üë{ carrier := U, is_open' := hU } = U","name":"TopologicalSpace.Opens.coe_mk","isProp":true,"docString":"the coercion `Opens Œ± ‚Üí Set Œ±` applied to a pair is the same as taking the first component "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (a‚Åª¬π < 1 : Prop) ‚Üî (1 < a : Prop)","name":"Right.inv_lt_one_iff","isProp":true,"docString":"Uses `right` co(ntra)variant. "},{"type":"‚àÄ {v : Sat.Valuation} {a : Prop} {n : ‚Ñï} (h : (v n : Prop) ‚Üî (a : Prop)),\n  Sat.Literal.reify v (Sat.Literal.pos n) (¬¨(a : Prop) : Prop)","name":"Sat.Literal.reify_pos","isProp":true,"docString":"The reification of a positive literal `¬¨‚ü¶a‚üß_v ‚â° ¬¨a`. "},{"type":"‚àÄ {Œπ : Type u} (f : (a : Œπ) ‚Üí Cardinal), BddAbove (Set.range f)","name":"Cardinal.bddAbove_range","isProp":true,"docString":"The range of an indexed cardinal function, whose outputs live in a higher universe than the\ninputs, is always bounded above. "},{"type":"‚àÄ {R : Type u_1} [inst : Mul R] {c : R} (self : IsRegular c), IsLeftRegular c","name":"IsRegular.left","isProp":true,"docString":"A regular element `c` is left-regular "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {x : Œ±} {p : Filter Œπ} {g : (a : Œπ) ‚Üí Œ±} [inst_1 : TopologicalSpace Œ±]\n  (h : TendstoLocallyUniformlyOn F f p s) (hf : ContinuousWithinAt f s x) (hx : x ‚àà s)\n  (hg : Filter.Tendsto g p (nhdsWithin x s)), Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n (g n)) p (nhds (f x))","name":"TendstoLocallyUniformlyOn.tendsto_comp","isProp":true,"docString":"If `F‚Çô` tends locally uniformly to `f` on a set `s`, and `g‚Çô` tends to `x` within `s`, then\n`F‚Çô g‚Çô` tends to `f x` if `f` is continuous at `x` within `s` and `x ‚àà s`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {a : M} {b : M}, (‚Üëa = ‚Üëb : Prop) ‚Üî (‚Üëc a b : Prop)","name":"AddCon.eq","isProp":true,"docString":"Two elements are related by an additive congruence relation `c` iff\nthey are represented by the same element of the quotient by `c`."},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (a‚Åª¬π < 1 : Prop) ‚Üî (1 < a : Prop)","name":"inv_lt_one_iff_one_lt","isProp":true,"docString":"**Alias** of `Left.inv_lt_one_iff`."},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {s : Set G} {p : (a : G) ‚Üí Prop} {x : G} (h : x ‚àà AddSubgroup.closure s) (H1 : p 0)\n  (Hmul : ‚àÄ (x : G) (a : x ‚àà s) (y : G) (a : p y), p (x + y))\n  (Hinv : ‚àÄ (x : G) (a : x ‚àà s) (y : G) (a : p y), p (-x + y)), p x","name":"AddSubgroup.closure_induction_left","isProp":true,"docString":"For additive subgroups generated by a single element, see the simpler\n`zsmul_induction_left`."},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedAddCommMonoidWithTop Œ±] (x : Œ±), x ‚â§ ‚ä§","name":"LinearOrderedAddCommMonoidWithTop.le_top","isProp":true,"docString":"In a `LinearOrderedAddCommMonoidWithTop`, the `‚ä§` element is larger than any other element."},{"type":"‚àÄ {Œπ : Type u_1} {Œ∫ : Type u_4} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} {x‚ÇÄ : X} (h : EquicontinuousAt F x‚ÇÄ) (u : (a : Œ∫) ‚Üí Œπ), EquicontinuousAt (F ‚àò u) x‚ÇÄ","name":"EquicontinuousAt.comp","isProp":true,"docString":"Taking sub-families preserves equicontinuity at a point. "},{"type":"‚àÄ {n : ‚Ñï} {p : (a : Fin n) ‚Üí Prop} [inst : DecidablePred p] {i : Fin n} (x : i ‚àà Fin.find p) {j : Fin n} (x : j < i),\n  ¬¨(p j : Prop)","name":"Fin.find_min","isProp":true,"docString":"If `find p` returns `some i`, then `p j` does not hold for `j < i`, i.e., `i` is minimal among\nthe indices where `p` holds. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [inst_1 : IsCompactlyGenerated Œ±] {a : Œ±} {s : Set Œ±}\n  (h : DirectedOn (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) s), sup‚Çõ s ‚äì a = sup·µ¢ fun (b : Œ±) ‚Ü¶ sup·µ¢ fun (h : b ‚àà s) ‚Ü¶ b ‚äì a","name":"DirectedOn.sup‚Çõ_inf_eq","isProp":true,"docString":"This property is sometimes referred to as `Œ±` being upper continuous. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ±] {s : Set Œ≤}\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (h : Set.EqOn f g s) (hf : Continuous f) (hg : Continuous g),\n  Set.EqOn f g (closure s)","name":"Set.EqOn.closure","isProp":true,"docString":"If two continuous maps are equal on `s`, then they are equal on the closure of `s`. See also\n`Set.EqOn.of_subset_closure` for a more general version. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type u_1} {œÉ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÉ i)]\n  [inst_1 : TopologicalSpace Œ±] {f : (a : Sigma œÉ) ‚Üí Œ±},\n  (Continuous f : Prop) ‚Üî (‚àÄ (i : Œπ), Continuous fun (a : œÉ i) ‚Ü¶ f { fst := i, snd := a } : Prop)","name":"continuous_sigma_iff","isProp":true,"docString":"A map out of a sum type is continuous iff its restriction to each summand is. "},{"type":"‚àÄ {G : Type u_1} {M : Type u_2} {Œ± : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MulAction G M]\n  [inst_3 : SMul M Œ±] [inst_4 : SMul G Œ±] [inst_5 : SMulCommClass G M M] [inst_6 : IsScalarTower G M M]\n  [inst_7 : IsScalarTower G M Œ±], IsScalarTower G MÀ£ Œ±","name":"Units.isScalarTower'_left","isProp":true,"docString":"Transfer `IsScalarTower G M Œ±` to `IsScalarTower G MÀ£ Œ±` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictAntiOn f s) (hg : StrictAntiOn g s), StrictAntiOn (fun (x : Œ≤) ‚Ü¶ f x + g x) s","name":"StrictAntiOn.add","isProp":true,"docString":"The sum of two strictly antitone functions is strictly antitone."},{"type":"‚àÄ {Œ± : Type u} [self : NonAssocSemiring Œ±], NatCast.natCast 0 = 0","name":"NonAssocSemiring.natCast_zero","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` sends `0 : ‚Ñï` to `0 : R`. "},{"type":"‚àÄ (M : Type u_2) {Œ± : Type u_1} [inst : AddMonoid M] [inst_1 : AddAction M Œ±] (a‚ÇÅ : M) (a‚ÇÇ : M),\n  (fun (x : M) (x_1 : Œ±) ‚Ü¶ x +·µ• x_1) a‚ÇÅ ‚àò (fun (x : M) (x_1 : Œ±) ‚Ü¶ x +·µ• x_1) a‚ÇÇ =\n    (fun (x : M) (x_1 : Œ±) ‚Ü¶ x +·µ• x_1) (a‚ÇÅ + a‚ÇÇ)","name":"comp_vadd_left","isProp":true,"docString":"`VAdd` version of `comp_add_left`"},{"type":"‚àÄ (self : ‚Ñö), Rat.den self ‚â† 0","name":"Rat.den_nz","isProp":true,"docString":"The denominator is nonzero. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_6} {V‚ÇÇ : Type u_4} {P‚ÇÇ : Type u_5} [inst_4 : AddCommGroup V‚ÇÇ]\n  [inst_5 : Module k V‚ÇÇ] [inst_6 : AddTorsor V‚ÇÇ P‚ÇÇ] {p : (a : Œπ) ‚Üí P} (f : P ‚Üí·µÉ[k] P‚ÇÇ)\n  (hai : AffineIndependent k (‚Üëf ‚àò p)), AffineIndependent k p","name":"AffineIndependent.of_comp","isProp":true,"docString":"If the image of a family of points in affine space under an affine transformation is affine-\nindependent, then the original family of points is also affine-independent. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  (Multiset.prod s = ‚ä• : Prop) ‚Üî (‚àÉ (I : Ideal R), (I ‚àà s : Prop) ‚àß (I = ‚ä• : Prop) : Prop)","name":"Ideal.prod_eq_bot","isProp":true,"docString":"A product of ideals in an integral domain is zero if and only if one of the terms is zero. "},{"type":"‚àÄ (Œπ : Type u_1) [inst : Fintype Œπ], IsCompact (stdSimplex ‚Ñù Œπ)","name":"isCompact_stdSimplex","isProp":true,"docString":"`std_simplex ‚Ñù Œπ` is compact. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±} [self : Set.OrdConnected s] ‚¶Éx : Œ±‚¶Ñ (hx : x ‚àà s) ‚¶Éy : Œ±‚¶Ñ (hy : y ‚àà s),\n  Set.Icc x y ‚äÜ s","name":"Set.OrdConnected.out'","isProp":true,"docString":"`s : Set Œ±` is `OrdConnected` if for all `x y ‚àà s` it includes the interval `[[x, y]]`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (x : Œ±) [inst_1 : Filter.NeBot (nhdsWithin x ({x}·∂ú))], interior {x} = ‚àÖ","name":"interior_singleton","isProp":true,"docString":"If `x` is not an isolated point of a topological space, then the interior of `{x}` is empty. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] {W : C} {X : C} {Y : C} {Z : C} (f : W ‚ü∂ Y) (g : X ‚ü∂ Z)\n  [inst_3 : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_left_of_isIso_biprod_map","isProp":true,"docString":"If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `f` is invertible.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f f) F]\n  [inst_3 : CategoryTheory.Mono f], CategoryTheory.Mono (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)","name":"CategoryTheory.preserves_mono_of_preservesLimit","isProp":true,"docString":"If `F` preserves pullbacks, then it preserves monomorphisms. "},{"type":"‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {p : (a : Œ±) ‚Üí Prop}\n  (a : Filter.Eventually (fun (s : Set Œ±) ‚Ü¶ ‚àÄ (x : Œ±) (a : x ‚àà s), p x) (Filter.smallSets l)),\n  Filter.Eventually (fun (x : Œ±) ‚Ü¶ p x) l","name":"Filter.Eventually.of_smallSets","isProp":true,"docString":"**Alias** of the forward direction of `Filter.eventually_smallSets_forall`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïú E] {p : (a : Œπ) ‚Üí E} (hc : ConvexIndependent ùïú p) (s : Set Œπ),\n  ConvexIndependent ùïú fun (i : ‚Üës) ‚Ü¶ p ‚Üëi","name":"ConvexIndependent.subtype","isProp":true,"docString":"If a family is convex independent, so is any subfamily indexed by a subtype of the index type.\n"},{"type":"‚àÄ {a : Prop} {b : Prop} (self : (a : Prop) ‚àß (b : Prop)), a","name":"And.left","isProp":true,"docString":"Extract the left conjunct from a conjunction. `h : a ‚àß b` then\n`h.left`, also notated as `h.1`, is a proof of `a`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : InfSet Œ±] [inst_1 : InfSet Œ≤] (self : Inf‚ÇõHom Œ± Œ≤) (s : Set Œ±),\n  Inf‚ÇõHom.toFun self (inf‚Çõ s) = inf‚Çõ (Inf‚ÇõHom.toFun self '' s)","name":"Inf‚ÇõHom.map_inf‚Çõ'","isProp":true,"docString":"The proposition that a `Inf‚ÇõHom` commutes with arbitrary infima/meets "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {s : Set Œ±} {t : Set Œ±} {p : Set Œ±} (hs : IsGLB s a) (hp : IsGLB p a)\n  (hst : s ‚äÜ t) (htp : t ‚äÜ p), IsGLB t a","name":"IsGLB.of_subset_of_superset","isProp":true,"docString":"If `a` is a greatest lower bound for sets `s` and `p`, then it is a greater lower bound for any\nset `t`, `s ‚äÜ t ‚äÜ p`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {s : Set Œ±} {t : Set Œ±}\n  {Œ¶ : (a : Œ±) ‚Üí Œ≤} (h : Isometry Œ¶), Metric.hausdorffDist (Œ¶ '' s) (Œ¶ '' t) = Metric.hausdorffDist s t","name":"Metric.hausdorffDist_image","isProp":true,"docString":"The Hausdorff distance is invariant under isometries "},{"type":"‚àÄ {Œ± : Sort u} {a : Œ±} {b : Œ±} {c : Œ±} (h‚ÇÅ : a ‚â† b) (h‚ÇÇ : b = c), a ‚â† c","name":"Ne.trans_eq","isProp":true,"docString":"**Alias** of `ne_of_ne_of_eq`."},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {P : Type u_2} [inst_1 : AddCommMonoid P] [inst_2 : Module R P] {M : Type u_3}\n  [inst_3 : AddCommMonoid M] [inst_4 : Module R M] {N : Type u_4} [inst_5 : AddCommMonoid N] [inst_6 : Module R N]\n  [h : Module.Projective R P] (f : M ‚Üí‚Çó[R] N) (g : P ‚Üí‚Çó[R] N) (hf : Function.Surjective ‚Üëf),\n  ‚àÉ (h : P ‚Üí‚Çó[R] M), LinearMap.comp f h = g","name":"Module.projective_lifting_property","isProp":true,"docString":"A projective R-module has the property that maps from it lift along surjections. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : TopologicalSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±} {p : Filter Œπ} {s : Set Œ≤},\n  (TendstoLocallyUniformlyOn F f p s : Prop) ‚Üî\n    (‚àÄ (Œµ : ENNReal) (a : Œµ > 0) (x : Œ≤) (a : x ‚àà s),\n        ‚àÉ (t : Set Œ≤),\n          (t ‚àà nhdsWithin x s : Prop) ‚àß\n            (Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (y : Œ≤) (a : y ‚àà t), edist (f y) (F n y) < Œµ) p : Prop) :\n      Prop)","name":"EMetric.tendstoLocallyUniformlyOn_iff","isProp":true,"docString":"Expressing locally uniform convergence on a set using `edist`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (e : Œ± ‚âÉ Œ≤) [inst : Nontrivial Œ≤], Nontrivial Œ±","name":"Equiv.nontrivial","isProp":true,"docString":"Transfer `Nontrivial` across an `Equiv` "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =o[l] g'), f =o[l] fun (x : Œ±) ‚Ü¶ -g' x","name":"Asymptotics.IsLittleO.neg_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_neg_right`."},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M]\n  [inst_2 : SemilatticeSup M] (w : (a : œÉ) ‚Üí M), MvPolynomial.weightedTotalDegree' w 0 = ‚ä•","name":"MvPolynomial.weightedTotalDegree'_zero","isProp":true,"docString":"The `weightedTotalDegree'` of the zero polynomial is `‚ä•`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.MonoidalCategory C] [self : CategoryTheory.MonoidalPreadditive C] {W : C} {X : C} {Y : C}\n  {Z : C} (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) (h : Y ‚ü∂ Z), f ‚äó (g + h) = f ‚äó g + f ‚äó h","name":"CategoryTheory.MonoidalPreadditive.tensor_add","isProp":true,"docString":"left tensoring with a morphism is compatible with addition "},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocRing Œ±] (a : Œ±) (b : Œ±) (c : Œ±), a * (b + c) = a * b + a * c","name":"NonUnitalNonAssocRing.left_distrib","isProp":true,"docString":"Multiplication is left distributive over addition "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Semiring Œ±] [inst_1 : Semiring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsSemiringHom f)\n  {Œ≥ : Type u_1} [inst_2 : Semiring Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} (hg : IsSemiringHom g), IsSemiringHom (g ‚àò f)","name":"IsSemiringHom.comp","isProp":true,"docString":"The composition of two semiring homomorphisms is a semiring homomorphism. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±} (hs : IsCompact s) {Œπ : Type u_1}\n  (t : Finset Œπ) (U : (a : Œπ) ‚Üí Set Œ±) (hU : ‚àÄ (i : Œπ) (a : i ‚àà t), IsOpen (U i))\n  (hsC : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà t) ‚Ü¶ U i),\n  ‚àÉ (K : (a : Œπ) ‚Üí Set Œ±),\n    (‚àÄ (i : Œπ), IsCompact (K i) : Prop) ‚àß\n      ((‚àÄ (i : Œπ), K i ‚äÜ U i : Prop) ‚àß (s = Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà t) ‚Ü¶ K i : Prop) : Prop)","name":"IsCompact.finite_compact_cover","isProp":true,"docString":"For every finite open cover `U·µ¢` of a compact set, there exists a compact cover `K·µ¢ ‚äÜ U·µ¢`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Group Œ±] [inst_1 : Fintype Œ±] (s : Subgroup Œ±) [inst_2 : Fintype { x : Œ± // x ‚àà s }],\n  Fintype.card { x : Œ± // x ‚àà s } ‚à£ Fintype.card Œ±","name":"Subgroup.card_subgroup_dvd_card","isProp":true,"docString":"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (h : Reflexive r) {x : Œ±} {y : Œ±},\n  (‚àÄ (a : x ‚â† y), r x y : Prop) ‚Üî (r x y : Prop)","name":"Reflexive.ne_imp_iff","isProp":true,"docString":"If a reflexive relation `r : Œ± ‚Üí Œ± ‚Üí Prop` holds over `x y : Œ±`,\nthen it holds whether or not `x ‚â† y`. "},{"type":"‚àÄ {M : Type u_2} {P : Type u_1} [inst : MulOneClass M] [inst_1 : MulOneClass P] {f : M ‚Üí* P} (x : M),\n  ‚Üë(Con.kerLift f) ‚Üëx = ‚Üëf x","name":"Con.kerLift_mk","isProp":true,"docString":"The diagram described by the universal property for quotients of monoids, when the congruence\nrelation is the kernel of the homomorphism, commutes. "},{"type":"‚àÄ {X : Type u_2} {R : Type u_3} {Œπ : Type u_1} {U : (a : Œπ) ‚Üí Set X} [inst : TopologicalSpace X] [inst_1 : Zero R]\n  {f : (a : Œπ) ‚Üí (a : X) ‚Üí R} (hlf : LocallyFinite fun (i : Œπ) ‚Ü¶ Function.support (f i))\n  (hso : ‚àÄ (i : Œπ), tsupport (f i) ‚äÜ U i) (ho : ‚àÄ (i : Œπ), IsOpen (U i)) (x : X),\n  ‚àÉ (is : Finset Œπ),\n    ‚àÉ (n : Set X),\n      (n ‚àà nhds x : Prop) ‚àß\n        ((n ‚äÜ Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà is) ‚Ü¶ U i : Prop) ‚àß\n            (‚àÄ (z : X) (a : z ‚àà n), (Function.support fun (i : Œπ) ‚Ü¶ f i z) ‚äÜ ‚Üëis : Prop) :\n          Prop)","name":"LocallyFinite.exists_finset_nhd_support_subset","isProp":true,"docString":" If a family of functions `f` has locally-finite support, subordinate to a family of\nopen sets, then for any point we can find a neighbourhood on which only finitely-many members of `f`\nare non-zero. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {X : C}\n  (h :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.coyoneda) (Opposite.op X) ‚ãô\n        CategoryTheory.uliftFunctor ‚âÖ\n      CategoryTheory.Functor.cocones F)\n  {Y : C} (f : X ‚ü∂ Y),\n  CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom h f =\n    CategoryTheory.Limits.Cocone.extend (CategoryTheory.Limits.IsColimit.OfNatIso.colimitCocone h) f","name":"CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom_fac","isProp":true,"docString":"If `F.cocones` is corepresented by `X`, the cocone corresponding to a morphism `f : Y ‚ü∂ X` is\nthe colimit cocone extended by `f`. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {f : (a : Œ±) ‚Üí ENNReal} (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚â† ‚ä§),\n  ENNReal.toReal (Finset.sum s fun (a : Œ±) ‚Ü¶ f a) = Finset.sum s fun (a : Œ±) ‚Ü¶ ENNReal.toReal (f a)","name":"ENNReal.toReal_sum","isProp":true,"docString":"seeing `‚Ñù‚â•0‚àû` as `Real` does not change their sum, unless one of the `‚Ñù‚â•0‚àû` is infinity "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (Cf : ContinuousAt f (inf‚Çõ s)) (Mf : Monotone f) (hs : Set.Nonempty s), f (inf‚Çõ s) = inf‚Çõ (f '' s)","name":"Monotone.map_inf‚Çõ_of_continuousAt'","isProp":true,"docString":"A monotone function continuous at the infimum of a nonempty set sends this infimum to\nthe infimum of the image of this set. "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ), a / (a / a) = a","name":"div_div_self","isProp":true,"docString":"Dividing `a` by the result of dividing `a` by itself results in\n`a` (whether or not `a` is zero). "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [inst : CommSemiring k] [inst_1 : AddMonoid G] {A : Type u‚ÇÉ} [inst_2 : Semiring A]\n  [inst_3 : Algebra k A] ‚¶ÉœÜ‚ÇÅ : AddMonoidAlgebra k G ‚Üí‚Çê[k] A‚¶Ñ ‚¶ÉœÜ‚ÇÇ : AddMonoidAlgebra k G ‚Üí‚Çê[k] A‚¶Ñ\n  (h : ‚àÄ (x : G), ‚ÜëœÜ‚ÇÅ (AddMonoidAlgebra.single x 1) = ‚ÜëœÜ‚ÇÇ (AddMonoidAlgebra.single x 1)), œÜ‚ÇÅ = œÜ‚ÇÇ","name":"AddMonoidAlgebra.algHom_ext","isProp":true,"docString":"A `k`-algebra homomorphism from `MonoidAlgebra k G` is uniquely defined by its\nvalues on the functions `single a 1`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D) {A : C}\n  {A' : C} {B : C} {B' : C} [inst_2 : CategoryTheory.Limits.HasBinaryCoproduct A B]\n  [inst_3 : CategoryTheory.Limits.HasBinaryCoproduct A' B']\n  [inst_4 :\n    CategoryTheory.Limits.HasBinaryCoproduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) A)\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) B)]\n  [inst_5 :\n    CategoryTheory.Limits.HasBinaryCoproduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) A')\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) B')]\n  (f : A ‚ü∂ A') (g : B ‚ü∂ B') [inst_6 : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A B)]\n  [inst_7 : CategoryTheory.IsIso (CategoryTheory.Limits.coprodComparison F A' B')],\n  CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A B) ‚â´\n      CategoryTheory.Limits.coprod.map (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)\n        (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) g) =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.Limits.coprod.map f g) ‚â´\n      CategoryTheory.inv (CategoryTheory.Limits.coprodComparison F A' B')","name":"CategoryTheory.Limits.coprodComparison_inv_natural","isProp":true,"docString":"If the coproduct comparison morphism is an iso, its inverse is natural. "},{"type":"‚àÄ {G : Type u} [inst : AddGroup G] (H : AddSubgroup G) (h : Subsingleton (G ‚ß∏ H)), H = ‚ä§","name":"QuotientAddGroup.addSubgroup_eq_top_of_subsingleton","isProp":true,"docString":"If the quotient by an additive subgroup gives a singleton then the additive subgroup\nis the whole additive group."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i","name":"MonovaryOn.sum_comp_perm_smul_le_sum_smul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when\n`f` and `g` monovary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ∑ : Type u_1} {Gs : (a : Œ∑) ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddMonoid (Gs i)] {x : (i : Œ∑) ‚Üí Gs i}\n  (h : IsOfFinAddOrder x) (i : Œ∑), IsOfFinAddOrder (x i)","name":"IsOfFinAddOrder.apply","isProp":true,"docString":"If a direct product has finite additive order then so does each component."},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±), 0 * a = 0","name":"CanonicallyOrderedCommSemiring.zero_mul","isProp":true,"docString":"Zero is a left absorbing element for multiplication "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±} (hs : BddBelow s) (sne : Set.Nonempty s),\n  inf‚Çõ (insert a s) = a ‚äì inf‚Çõ s","name":"cinf‚Çõ_insert","isProp":true,"docString":"The infimum of `insert a s` is the minimum of `a` and the infimum of `s`, if `s` is\nnonempty and bounded below."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] [self : NoMaxOrder Œ±] (a : Œ±), ‚àÉ (b : Œ±), a < b","name":"NoMaxOrder.exists_gt","isProp":true,"docString":"For each term `a`, there is some strictly greater `b`. "},{"type":"‚àÄ {E : Type u_1} [inst : NonUnitalNormedRing E] [inst_1 : StarRing E] [inst_2 : CstarRing E], NormedStarGroup E","name":"CstarRing.to_normedStarGroup","isProp":true,"docString":"In a C*-ring, star preserves the norm. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {d : Con M} (H : Con.toSetoid c = Con.toSetoid d), c = d","name":"Con.toSetoid_inj","isProp":true,"docString":"The map sending a congruence relation to its underlying equivalence relation is injective. "},{"type":"‚àÄ {Œ± : Type u} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} {n : ‚Ñï},\n  List.take n (l‚ÇÅ ++ l‚ÇÇ) = List.take n l‚ÇÅ ++ List.take (n - List.length l‚ÇÅ) l‚ÇÇ","name":"List.take_append_eq_append_take","isProp":true,"docString":"Taking the first `n` elements in `l‚ÇÅ ++ l‚ÇÇ` is the same as appending the first `n` elements\nof `l‚ÇÅ` to the first `n - l‚ÇÅ.length` elements of `l‚ÇÇ`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {i : D ‚•§ C}\n  [inst_2 : CategoryTheory.IsRightAdjoint i] (A : C)\n  [inst_3 : CategoryTheory.IsIso ((CategoryTheory.Adjunction.unit (CategoryTheory.Adjunction.ofRightAdjoint i)).app A)],\n  A ‚àà CategoryTheory.Functor.essImage i","name":"CategoryTheory.mem_essImage_of_unit_isIso","isProp":true,"docString":"If `Œ∑_A` is an isomorphism, then `A` is in the essential image of `i`. "},{"type":"‚àÄ {Œ± : Type u} [self : NonAssocSemiring Œ±] (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1","name":"NonAssocSemiring.natCast_succ","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` is a homomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hst : s ‚äÜ t)\n  (ht : Set.Finite (t ‚à© Function.support f)),\n  ((finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà t \\ s) ‚Ü¶ f i) =\n    finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà t) ‚Ü¶ f i","name":"finsum_mem_add_diff'","isProp":true,"docString":"A more general version of `finsum_mem_add_diff` that requires `t ‚à© support f` rather\nthan `t` to be finite."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : EMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Isometry f),\n  UniformEmbedding f","name":"Isometry.uniformEmbedding","isProp":true,"docString":"An isometry from an emetric space is a uniform embedding "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {x : Œ±} {p : Filter Œπ} {g : (a : Œπ) ‚Üí Œ±} [inst_1 : TopologicalSpace Œ±] (h : TendstoUniformlyOn F f p s)\n  (hf : ContinuousWithinAt f s x) (hg : Filter.Tendsto g p (nhdsWithin x s)),\n  Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n (g n)) p (nhds (f x))","name":"TendstoUniformlyOn.tendsto_comp","isProp":true,"docString":"If `F‚Çô` tends uniformly to `f` on a set `s`, and `g‚Çô` tends to `x` within `s`, then `F‚Çô g‚Çô`\ntends to `f x` if `f` is continuous at `x` within `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] [inst_1 : HasDistribNeg Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚à£ b), a ‚à£ -b","name":"Dvd.dvd.neg_right","isProp":true,"docString":"**Alias** of the reverse direction of `dvd_neg`."},{"type":"‚àÄ {R : Type v} [inst : CommRing R] (A : Matrix (Fin 3) (Fin 3) R),\n  Matrix.det A =\n    A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 +\n        A 0 2 * A 1 0 * A 2 1 -\n      A 0 2 * A 1 1 * A 2 0","name":"Matrix.det_fin_three","isProp":true,"docString":"Determinant of 3x3 matrix "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) {s‚ÇÅ : Finset Œπ} {s‚ÇÇ : Finset Œπ} (h : s‚ÇÅ ‚äÜ s‚ÇÇ),\n  ‚Üë(Finset.weightedVSub s‚ÇÅ p) w = ‚Üë(Finset.weightedVSub s‚ÇÇ p) (Set.indicator (‚Üës‚ÇÅ) w)","name":"Finset.weightedVSub_indicator_subset","isProp":true,"docString":"The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Monotone f)\n  [inst_4 : TopologicalSpace Œ±] [inst_5 : OrderTopology Œ±] [inst_6 : TopologicalSpace.SecondCountableTopology Œ≤],\n  Set.Countable (setOf fun (x : Œ±) ‚Ü¶ ¬¨(ContinuousWithinAt f (Set.Iio x) x : Prop))","name":"Monotone.countable_not_continuousWithinAt_Iio","isProp":true,"docString":"In a second countable space, the set of points where a monotone function is not left-continuous\nis at most countable. Superseded by `countable_not_continuousAt` which gives the two-sided\nversion. "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : Zero M] (a : Œ±), Function.Injective (Finsupp.single a)","name":"Finsupp.single_injective","isProp":true,"docString":"`Finsupp.single a b` is injective in `b`. For the statement that it is injective in `a`, see\n`Finsupp.single_left_injective` "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  (p : Seminorm ùïú E) {r : ‚Ñù} {x : E} (hpr : ‚Üëp x < r), Absorbent ùïú (Seminorm.ball p x r)","name":"Seminorm.absorbent_ball","isProp":true,"docString":"Seminorm-balls containing the origin are absorbent. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {E' : Type u_3} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {c : ‚Ñù}\n  {g : (a : Œ±) ‚Üí F} {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) g),\n  Asymptotics.IsBigOWith c l f' g","name":"Asymptotics.IsBigOWith.of_norm_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigOWith_norm_left`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i)) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i","name":"MonovaryOn.sum_mul_comp_perm_le_sum_mul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and\n`g` monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a : S} {x : S} {y : S} {x' : S} {y' : S} (h : AddSemiconjBy a x y)\n  (h' : AddSemiconjBy a x' y'), AddSemiconjBy a (x + x') (y + y')","name":"AddSemiconjBy.add_right","isProp":true,"docString":"If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x + x'` to `y + y'`."},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Norm R‚ÇÅ] [inst_3 : Norm R‚ÇÇ]\n  {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ} [self : RingHomIsometric œÉ] {x : R‚ÇÅ}, ‚Äñ‚ÜëœÉ x‚Äñ = ‚Äñx‚Äñ","name":"RingHomIsometric.is_iso","isProp":true,"docString":"The ring homomorphism is an isometry. "},{"type":"‚àÄ {Œ± : Type u} [inst : OrderedSemiring Œ±] {a : Œ±} {b : Œ±} (ha : 1 ‚â§ a) (hb : 1 < b), 1 < a * b","name":"one_lt_mul","isProp":true,"docString":"**Alias** of `one_lt_mul_of_le_of_lt`."},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±}\n  (h : (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) ‚â† 1), Set.Nonempty s","name":"nonempty_of_finprod_mem_ne_one","isProp":true,"docString":"A set `s` is nonempty if the product of some function over `s` is not equal to `1`. "},{"type":"‚àÄ {n : ‚Ñï} {a : ‚Ñï} (hn : Odd n) (ha : Even a), Odd (n % a)","name":"Odd.mod_even","isProp":true,"docString":"If `n` is odd and `a` is even, then `n % a` is odd. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  [self : CategoryTheory.Limits.HasLimit F], Nonempty (CategoryTheory.Limits.LimitCone F)","name":"CategoryTheory.Limits.HasLimit.exists_limit","isProp":true,"docString":"There is some limit cone for `F` "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {x : M} {s : Set M}\n  {p : (a : M) ‚Üí Prop} (h : x ‚àà Submodule.span R s) (Hs : ‚àÄ (x : M) (a : x ‚àà s), p x) (H0 : p 0)\n  (H1 : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x + y)) (H2 : ‚àÄ (a : R) (x : M) (a_1 : p x), p (a ‚Ä¢ x)), p x","name":"Submodule.span_induction","isProp":true,"docString":"An induction principle for span membership. If `p` holds for 0 and all elements of `s`, and is\npreserved under addition and scalar multiplication, then `p` holds for all elements of the span of\n`s`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : AddCommGroup F] [inst_3 : OrderedAddCommMonoid Œ≤] [inst_4 : Module ùïú E] [inst_5 : Module ùïú F]\n  [inst_6 : SMul ùïú Œ≤] {f : (a : F) ‚Üí Œ≤} (g : E ‚Üí·µÉ[ùïú] F) {s : Set F} (hf : ConcaveOn ùïú s f),\n  ConcaveOn ùïú (‚Üëg ‚Åª¬π' s) (f ‚àò ‚Üëg)","name":"ConcaveOn.comp_affineMap","isProp":true,"docString":"If a function is concave on `s`, it remains concave when precomposed by an affine map. "},{"type":"‚àÄ {F : Type u_2} {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] [inst_1 : MonoidWithZeroHomClass F ‚Ñö M‚ÇÄ] {f : F} {g : F}\n  (h : ‚àÄ (m : ‚Ñ§), ‚Üëf ‚Üëm = ‚Üëg ‚Üëm), f = g","name":"MonoidWithZeroHom.ext_rat'","isProp":true,"docString":"If `f` and `g` agree on the integers then they are equal `œÜ`. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p1 : P) (p2 : P) (p3 : P),\n  p1 -·µ• p2 + (p2 -·µ• p3) = p1 -·µ• p3","name":"vsub_add_vsub_cancel","isProp":true,"docString":"Cancellation adding the results of two subtractions. "},{"type":"‚àÄ {V : Type u} {G‚ÇÅ : SimpleGraph V} {G‚ÇÇ : SimpleGraph V} (a : G‚ÇÅ ‚â§ G‚ÇÇ), SimpleGraph.edgeSet G‚ÇÅ ‚äÜ SimpleGraph.edgeSet G‚ÇÇ","name":"SimpleGraph.edgeSet_mono","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.edgeSet_subset_edgeSet`."},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedSemifield R] [inst_1 : FloorSemiring R] {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñ§} {r : R}\n  (hr : 0 < r), (‚Üëb ^ x < r : Prop) ‚Üî (x < Int.clog b r : Prop)","name":"Int.zpow_lt_iff_lt_clog","isProp":true,"docString":"`Int.clog b` and `zpow b` (almost) form a Galois connection. "},{"type":"‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]\n  {c : ComplexShape Œπ} [inst_2 : CategoryTheory.Limits.HasKernels V] [inst_3 : CategoryTheory.Limits.HasImages V]\n  (C : HomologicalComplex V c) (i : Œπ) (h : HomologicalComplex.boundaries C i ‚â§ HomologicalComplex.cycles C i),\n  CategoryTheory.Subobject.ofLE (HomologicalComplex.boundaries C i) (HomologicalComplex.cycles C i) h =\n    HomologicalComplex.boundariesToCycles C i","name":"HomologicalComplex.imageToKernel_as_boundariesToCycles","isProp":true,"docString":"Prefer `boundariesToCycles`. "},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : (a : X) ‚Üí Y) (s : Set X)\n  (h :\n    ‚àÄ (x : X) (a : x ‚àà s),\n      ‚àÉ (e : LocalHomeomorph X Y),\n        (x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) : Prop) ‚àß\n          (‚àÄ (y : X) (a : y ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)), f y = ‚Üëe y : Prop)),\n  IsLocallyHomeomorphOn f s","name":"IsLocallyHomeomorphOn.mk","isProp":true,"docString":"Proves that `f` satisfies `IsLocallyHomeomorphOn f s`. The condition `h` is weaker than the\ndefinition of `IsLocallyHomeomorphOn f s`, since it only requires `e : LocalHomeomorph X Y` to\nagree with `f` on its source `e.source`, as opposed to on the whole space `X`. "},{"type":"‚àÄ {n : Type v} {Œ± : Type w} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  (b : (a : n) ‚Üí Œ±), ‚Üë(Matrix.cramer A) b = Matrix.mulVec (Matrix.adjugate A) b","name":"Matrix.cramer_eq_adjugate_mulVec","isProp":true,"docString":"Since the map `b ‚Ü¶ cramer A b` is linear in `b`, it must be multiplication by some matrix. This\nmatrix is `A.adjugate`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.IsIso f],\n  CategoryTheory.IsSplitMono f","name":"CategoryTheory.IsSplitMono.of_iso","isProp":true,"docString":"Every iso is a split mono. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedField Œ±] (a : Œ±) (b : Œ±), a / b = a * b‚Åª¬π","name":"LinearOrderedField.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p1 : P) (p2 : P), -(p1 -·µ• p2) = p2 -·µ• p1","name":"neg_vsub_eq_vsub_rev","isProp":true,"docString":"Subtracting two points in the reverse order produces the negation\nof subtracting them. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} (hs : IsCompact s),\n  ‚àÉ (t : Set Œ±), (t ‚äÜ s : Prop) ‚àß ((Set.Countable t : Prop) ‚àß (s ‚äÜ closure t : Prop) : Prop)","name":"EMetric.subset_countable_closure_of_compact","isProp":true,"docString":"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set.  "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {s : Set Œ≤} (hs : Set.Subsingleton s) {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f),\n  Set.Subsingleton (f ‚Åª¬π' s)","name":"Set.Subsingleton.preimage","isProp":true,"docString":"The preimage of a subsingleton under an injective map is a subsingleton. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_3} {E' : Type u_2} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : f' =o[l] g), (fun (x : Œ±) ‚Ü¶ -f' x) =o[l] g","name":"Asymptotics.IsLittleO.neg_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_neg_left`."},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], (FiniteDimensional.finrank K V = 0 : Prop) ‚Üî (Subsingleton V : Prop)","name":"FiniteDimensional.finrank_zero_iff","isProp":true,"docString":"A finite dimensional space has zero `finrank` iff it is a subsingleton.\nThis is the `finrank` version of `rank_zero_iff`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} {s : Finset Œ±} [inst : CommMonoid Œ≤] [inst_1 : DecidableEq Œ≥] (f : (a : Œ≥) ‚Üí Œ≤)\n  (g : (a : Œ±) ‚Üí Œ≥),\n  (Finset.prod s fun (a : Œ±) ‚Ü¶ f (g a)) =\n    Finset.prod (Finset.image g s) fun (b : Œ≥) ‚Ü¶ f b ^ Finset.card (Finset.filter (fun (a : Œ±) ‚Ü¶ g a = b) s)","name":"Finset.prod_comp","isProp":true,"docString":"The product of the composition of functions `f` and `g`, is the product over `b ‚àà s.image g` of\n`f b` to the power of the cardinality of the fibre of `b`. See also `Finset.prod_image`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] ‚¶Éf : AddHom M N‚¶Ñ ‚¶Ég : AddHom M N‚¶Ñ (h : ‚Üëf = ‚Üëg), f = g","name":"AddHom.coe_inj","isProp":true,"docString":"Deprecated: use `FunLike.coe_injective` instead."},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {a : Œ±} {b : Œ±} {s : Set Œ±} (hs : IsClosed (s ‚à© Set.Icc a b)) (ha : a ‚àà s)\n  (hgt : ‚àÄ (x : Œ±) (a : x ‚àà s ‚à© Set.Ico a b), s ‚àà nhdsWithin x (Set.Ioi x)), Set.Icc a b ‚äÜ s","name":"IsClosed.Icc_subset_of_forall_mem_nhdsWithin","isProp":true,"docString":"A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and for any `x ‚àà s ‚à© [a, b)` the set `s` includes some open\nneighborhood of `x` within `(x, +‚àû)`, then `[a, b] ‚äÜ s`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : SeminormedRing ùïú] [inst_1 : SMul ùïú E] {s : Set E} {t : Set E}\n  (hs : Balanced ùïú s) (h : s ‚äÜ t), s ‚äÜ balancedCore ùïú t","name":"Balanced.subset_balancedCore_of_subset","isProp":true,"docString":"The balanced core of `t` is maximal in the sense that it contains any balanced subset\n`s` of `t`."},{"type":"‚àÄ {R : Type u_1} [inst : NonUnitalNonAssocRing R] (self : RingNorm R) (x : R)\n  (a : AddGroupSeminorm.toFun (RingSeminorm.toAddGroupSeminorm (RingNorm.toRingSeminorm self)) x = 0), x = 0","name":"RingNorm.eq_zero_of_map_eq_zero'","isProp":true,"docString":"If the image under the seminorm is zero, then the argument is zero. "},{"type":"‚àÄ {R : Type u_1} {a : R} [inst : Monoid R] (n : ‚Ñï) (rra : IsRightRegular a), IsRightRegular (a ^ n)","name":"IsRightRegular.pow","isProp":true,"docString":"Any power of a right-regular element is right-regular. "},{"type":"‚àÄ {a : ‚Ñï}, Real.sqrt ‚Üëa ‚â§ ‚Üë(Nat.sqrt a) + 1","name":"Real.real_sqrt_le_nat_sqrt_succ","isProp":true,"docString":"The real square root is at most the natural square root plus one "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalNonAssocSemiring Œ±] (self : CentroidHom Œ±) (a : Œ±) (b : Œ±),\n  ZeroHom.toFun (‚Üë(CentroidHom.toAddMonoidHom self)) (a * b) = ZeroHom.toFun (‚Üë(CentroidHom.toAddMonoidHom self)) a * b","name":"CentroidHom.map_mul_right'","isProp":true,"docString":"Commutativity of centroid homomorphims with right multiplication. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : TopologicalSpace Œ¥] {e‚ÇÅ : (a : Œ±) ‚Üí Œ≤} {e‚ÇÇ : (a : Œ≥) ‚Üí Œ¥}\n  (de‚ÇÅ : DenseEmbedding e‚ÇÅ) (de‚ÇÇ : DenseEmbedding e‚ÇÇ),\n  DenseEmbedding fun (p : Œ± √ó Œ≥) ‚Ü¶ (e‚ÇÅ (Prod.fst p), e‚ÇÇ (Prod.snd p))","name":"DenseEmbedding.prod","isProp":true,"docString":"The product of two dense embeddings is a dense embedding. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (e : LocalHomeomorph Œ± Œ≤)\n  (e' : LocalHomeomorph Œ± Œ≤) (h : ‚àÄ (x : Œ±), ‚Üëe x = ‚Üëe' x)\n  (hinv : ‚àÄ (x : Œ≤), ‚Üë(LocalHomeomorph.symm e) x = ‚Üë(LocalHomeomorph.symm e') x)\n  (hs : LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) = LocalEquiv.source (LocalHomeomorph.toLocalEquiv e')),\n  e = e'","name":"LocalHomeomorph.ext","isProp":true,"docString":"Two local homeomorphisms are equal when they have equal `toFun`, `invFun` and `source`.\nIt is not sufficient to have equal `toFun` and `source`, as this only determines `invFun` on\nthe target. This would only be true for a weaker notion of equality, arguably the right one,\ncalled `eq_on_source`. "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {N : Type u_2} [dec_Œπ : DecidableEq Œπ] [inst : Semiring R] [inst_1 : AddCommMonoid N]\n  [inst_2 : Module R N] (p : (a : Œπ) ‚Üí Submodule R N)\n  [inst_3 : (i : Œπ) ‚Üí (x : { x : N // x ‚àà p i }) ‚Üí Decidable (x ‚â† 0 : Prop)] (x : N),\n  (x ‚àà sup·µ¢ p : Prop) ‚Üî\n    (‚àÉ (f : Dfinsupp fun (i : Œπ) ‚Ü¶ { x : N // x ‚àà p i }),\n        (Dfinsupp.sum f fun (i : Œπ) (xi : { x : N // x ‚àà p i }) ‚Ü¶ ‚Üëxi) = x :\n      Prop)","name":"Submodule.mem_sup·µ¢_iff_exists_dfinsupp'","isProp":true,"docString":"A variant of `Submodule.mem_sup·µ¢_iff_exists_dfinsupp` with the RHS fully unfolded. "},{"type":"‚àÄ {G‚ÇÄ : Type u} [self : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ) (b : G‚ÇÄ), a / b = a * b‚Åª¬π","name":"GroupWithZero.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_3} {E' : Type u_2} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {c : ‚Ñù}\n  {g : (a : Œ±) ‚Üí F} {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ -f' x) g),\n  Asymptotics.IsBigOWith c l f' g","name":"Asymptotics.IsBigOWith.of_neg_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigOWith_neg_left`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤]\n  (f : (a : Œ±) ‚Üí Œ≤) {b : M} [inst_3 : LinearOrderedCommSemiring M] (hb : ‚Üë(Fintype.card Œ±) < Fintype.card Œ≤ ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), ‚Üë(Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ)) < b","name":"Fintype.exists_card_fiber_lt_of_card_lt_nsmul","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes. There is a pigeonhole\nwith at most as many pigeons as the floor of the average number of pigeons across all pigeonholes.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±] {a : Œ±} (ha : a ‚â† 0),\n  Filter.Tendsto ((fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) a) (Filter.comap norm Filter.atTop) (Filter.comap norm Filter.atTop)","name":"Filter.tendsto_mul_left_cobounded","isProp":true,"docString":"Multiplication on the left by a nonzero element of a normed division ring tends to infinity at\ninfinity. TODO: use `Bornology.cobounded` instead of `Filter.comap Norm.norm Filter.atTop`. "},{"type":"‚àÄ {x : ZFSet} (a : ZFSet.IsTransitive x), x ‚äÜ ZFSet.powerset x","name":"ZFSet.IsTransitive.subset_powerset","isProp":true,"docString":"**Alias** of the forward direction of `ZFSet.isTransitive_iff_subset_powerset`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atBot : Prop) ‚Üî (Filter.Tendsto f l Filter.atBot : Prop)","name":"Filter.tendsto_const_mul_atBot_of_pos","isProp":true,"docString":"If `r` is a positive constant, then `Œª x, r * f x` tends to negative infinity along a filter if\nand only if `f` tends to negative infinity along the same filter. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : ¬¨(a < b : Prop)),\n  Multiset.Ioc a b = 0","name":"Multiset.Ioc_eq_zero","isProp":true,"docString":"**Alias** of the reverse direction of `Multiset.Ioc_eq_zero_iff`."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} {p : (a : Œπ) ‚Üí P} (hp : AffineIndependent k p) (j : Œπ) (w : (a : Œπ) ‚Üí kÀ£),\n  AffineIndependent k fun (i : Œπ) ‚Ü¶ ‚Üë(AffineMap.lineMap (p j) (p i)) ‚Üë(w i)","name":"AffineIndependent.units_lineMap","isProp":true,"docString":"If we single out one member of an affine-independent family of points and affinely transport\nall others along the line joining them to this member, the resulting new family of points is affine-\nindependent.\n\nThis is the affine version of `LinearIndependent.units_smul`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} [inst : UniformSpace Œ≤] {ùîñ : Set (Set Œ±)} {f : (a : Œ≥) ‚Üí Œ≤},\n  UniformOnFun.uniformSpace Œ± Œ≥ ùîñ =\n    UniformSpace.comap ((fun (x : (a : Œ≥) ‚Üí Œ≤) (x_1 : (a : Œ±) ‚Üí Œ≥) ‚Ü¶ x ‚àò x_1) f) (UniformOnFun.uniformSpace Œ± Œ≤ ùîñ)","name":"UniformOnFun.comap_eq","isProp":true,"docString":"If `u` is a uniform structure on `Œ≤` and `f : Œ≥ ‚Üí Œ≤`, then\n`ùí±(Œ±, Œ≥, ùîñ, comap f u) = comap (Œª g, f ‚àò g) ùí±(Œ±, Œ≥, ùîñ, u‚ÇÅ)`. "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} {m : ‚Ñï} (v : Vector Œ± m), Vector.toList (Vector.drop n v) = List.drop n (Vector.toList v)","name":"Vector.toList_drop","isProp":true,"docString":"`drop` of vectors corresponds under `toList` to `drop` of lists. "},{"type":"‚àÄ {Œ± : Type v} [inst : LinearOrder Œ±] {x‚ÇÅ : Œ±} {x‚ÇÇ : Œ±} {y‚ÇÅ : Œ±} {y‚ÇÇ : Œ±} (h : Disjoint (Set.Ico x‚ÇÅ x‚ÇÇ) (Set.Ico y‚ÇÅ y‚ÇÇ))\n  (hx : x‚ÇÅ < x‚ÇÇ) (h2 : x‚ÇÇ ‚àà Set.Ico y‚ÇÅ y‚ÇÇ), y‚ÇÅ = x‚ÇÇ","name":"Set.eq_of_Ico_disjoint","isProp":true,"docString":"If two half-open intervals are disjoint and the endpoint of one lies in the other,\nthen it must be equal to the endpoint of the other. "},{"type":"‚àÄ {A : Type u_1} {B : outParam (Type u_2)} [self : SetLike A B], Function.Injective SetLike.coe","name":"SetLike.coe_injective'","isProp":true,"docString":"The coercion from a term of a `SetLike` to its corresponding `Set` is injective. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s‚ÇÅ : AffineSubspace k P} {s‚ÇÇ : AffineSubspace k P} {p : P} (h : p ‚àà s‚ÇÅ ‚äì s‚ÇÇ),\n  AffineSubspace.direction (s‚ÇÅ ‚äì s‚ÇÇ) = AffineSubspace.direction s‚ÇÅ ‚äì AffineSubspace.direction s‚ÇÇ","name":"AffineSubspace.direction_inf_of_mem_inf","isProp":true,"docString":"If two affine subspaces have a point in their inf, the direction of their inf equals the inf of\ntheir directions. "},{"type":"‚àÄ {Œ± : Type uu} {a : Œ±} {l : List Œ±} (a_1 : l ~ [a]), l = [a]","name":"List.Perm.eq_singleton","isProp":true,"docString":"**Alias** of the forward direction of `List.perm_singleton`."},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {F : Type u_3} [inst : MulOneClass M] [inst_1 : MulOneClass N]\n  [inst_2 : MonoidHomClass F M N] (f : F) {x : M} (hx : ‚àÉ (y : M), y * x = 1), ‚àÉ (y : (fun (x : M) ‚Ü¶ N) x), y * ‚Üëf x = 1","name":"MonoidHom.map_exists_left_inv","isProp":true,"docString":"Given a monoid homomorphism `f : M ‚Üí* N` and an element `x : M`, if `x` has a left inverse,\nthen `f x` has a left inverse too. For elements invertible on both sides see `IsUnit.map`. "},{"type":"‚àÄ {Œ± : Type u} [self : GeneralizedBooleanAlgebra Œ±] (a : Œ±) (b : Œ±), a ‚äì b ‚äî a \\ b = a","name":"GeneralizedBooleanAlgebra.sup_inf_sdiff","isProp":true,"docString":"For any `a`, `b`, `(a ‚äì b) ‚äî (a / b) = a` "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : OrderTop Œ±] (s : Set Œ±), BddAbove s","name":"OrderTop.bddAbove","isProp":true,"docString":"When there is a global maximum, every set is bounded above. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a : R) (b : R), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b","name":"RingEquivClass.map_add","isProp":true,"docString":"By definition, a ring isomorphism preserves the additive structure. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {A : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category A] (P : C·µí·µñ ‚•§ A)\n  {X : C} (S : CategoryTheory.Sieve X),\n  (‚àÄ\n        (c :\n          CategoryTheory.Limits.Cone\n            (CategoryTheory.Functor.op (CategoryTheory.Presieve.diagram (CategoryTheory.Sieve.arrows S)) ‚ãô P)),\n        Subsingleton\n          (c ‚ü∂\n            CategoryTheory.Functor.mapCone P\n              (CategoryTheory.Limits.Cocone.op (CategoryTheory.Presieve.cocone (CategoryTheory.Sieve.arrows S)))) :\n      Prop) ‚Üî\n    (‚àÄ (E : A·µí·µñ),\n        CategoryTheory.Presieve.IsSeparatedFor\n          (P ‚ãô Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.coyoneda) E)\n          (CategoryTheory.Sieve.arrows S) :\n      Prop)","name":"CategoryTheory.Presheaf.subsingleton_iff_isSeparatedFor","isProp":true,"docString":"Given sieve `S` and presheaf `P : C·µí·µñ ‚•§ A`, their natural associated cone admits at most one\nmorphism from every cone in the same category (i.e. over the same diagram),\niff `Hom (E, P -)`is separated for the sieve `S` and all `E : A`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddZeroClass Œ±] [inst_1 : AddGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddHom f),\n  IsAddMonoidHom f","name":"IsAddHom.to_isAddMonoidHom","isProp":true,"docString":"A map to an additive group preserving addition is an additive monoid\nhomomorphism."},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\n  MulOpposite.unop (‚Üëf (MulOpposite.unop (‚Üëf x))) = x","name":"RingInvoClass.involution","isProp":true,"docString":"Every ring involution must be its own inverse "},{"type":"‚àÄ {n : ‚Ñï} {a : Fin n} {b : Fin n}, (‚Üëa < ‚Üëb : Prop) ‚Üî (a < b : Prop)","name":"Fin.val_fin_lt","isProp":true,"docString":"`a < b` as natural numbers if and only if `a < b` in `Fin n`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {c : ‚Ñù}\n  {f : (a : Œ±) ‚Üí E} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l f fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ),\n  Asymptotics.IsBigOWith c l f g'","name":"Asymptotics.IsBigOWith.of_norm_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigOWith_norm_right`."},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±],\n  Filter.HasBasis (uniformity Œ±)\n    (fun (V : Set (Œ± √ó Œ±)) ‚Ü¶ (V ‚àà uniformity Œ± : Prop) ‚àß ((IsOpen V : Prop) ‚àß (SymmetricRel V : Prop) : Prop)) id","name":"uniformity_hasBasis_open_symmetric","isProp":true,"docString":"Open elements `s : Set (Œ± √ó Œ±)` of `ùì§ Œ±` such that `(x, y) ‚àà s ‚Üî (y, x) ‚àà s` form a basis\nof `ùì§ Œ±`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : SemilatticeSup Œ≤] [inst_2 : CompleteSpace Œ±]\n  {u : (a : Œ≤) ‚Üí Œ±} (H : CauchySeq u), ‚àÉ (x : Œ±), Filter.Tendsto u Filter.atTop (nhds x)","name":"cauchySeq_tendsto_of_complete","isProp":true,"docString":"A Cauchy sequence in a complete space converges "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.span f f) F]\n  [inst_3 : CategoryTheory.Epi (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)], CategoryTheory.Epi f","name":"CategoryTheory.reflects_epi_of_reflectsColimit","isProp":true,"docString":"If `F` reflects pushouts, then it reflects epimorphisms. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N] {f : M ‚Üí+ N}\n  (h : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëf ‚Üëy)) {y : { x : M // x ‚àà S }} {z : N} (H : ‚Üëf ‚Üëy + z = 0),\n  ‚Üë(-‚Üë(IsAddUnit.liftRight (AddMonoidHom.restrict f S) h) y) = z","name":"AddSubmonoid.LocalizationMap.neg_unique","isProp":true,"docString":"Given an AddMonoidHom `f : M ‚Üí+ N` and Submonoid `S ‚äÜ M` such that\n`f(S) ‚äÜ AddUnits N`, for all `y ‚àà S`, `- (f y)` is unique."},{"type":"‚àÄ {L : outParam FirstOrder.Language} {F : Type u_3} {M : outParam (Type u_4)} {N : outParam (Type u_5)}\n  [inst : FunLike F M fun (x : M) ‚Ü¶ N] [inst_1 : FirstOrder.Language.Structure L M]\n  [inst_2 : FirstOrder.Language.Structure L N] [self : FirstOrder.Language.HomClass L F M N] (œÜ : F) {n : ‚Ñï}\n  (r : FirstOrder.Language.Relations L n) (x : (a : Fin n) ‚Üí M) (a : FirstOrder.Language.Structure.rel_map r x),\n  FirstOrder.Language.Structure.rel_map r (‚ÜëœÜ ‚àò x)","name":"FirstOrder.Language.HomClass.map_rel","isProp":true,"docString":"The homomorphism sends related elements to related elements "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Type u_5} {N : Type u_4} {P : Type u_3} {Q : Type u_2} {S : Type u_6}\n  [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid N] [inst_3 : AddCommMonoid P] [inst_4 : AddCommMonoid Q]\n  [inst_5 : AddCommMonoid S] [inst_6 : Module R M] [inst_7 : Module R N] [inst_8 : Module R P] [inst_9 : Module R Q]\n  [inst_10 : Module R S] {œÜ : TensorProduct R (TensorProduct R M N) (TensorProduct R P Q) ‚Üí‚Çó[R] S}\n  {œà : TensorProduct R (TensorProduct R M N) (TensorProduct R P Q) ‚Üí‚Çó[R] S}\n  (H : ‚àÄ (w : M) (x : N) (y : P) (z : Q), ‚ÜëœÜ ((w ‚äó‚Çú[R] x) ‚äó‚Çú[R] y ‚äó‚Çú[R] z) = ‚Üëœà ((w ‚äó‚Çú[R] x) ‚äó‚Çú[R] y ‚äó‚Çú[R] z)), œÜ = œà","name":"TensorProduct.ext_fourfold'","isProp":true,"docString":"Two linear maps (M ‚äó N) ‚äó (P ‚äó Q) ‚Üí S which agree on all elements of the\nform (m ‚äó‚Çú n) ‚äó‚Çú (p ‚äó‚Çú q) are equal. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasEqualizer f g] (h : f = g),\n  CategoryTheory.IsIso (CategoryTheory.Limits.equalizer.Œπ f g)","name":"CategoryTheory.Limits.equalizer.Œπ_of_eq","isProp":true,"docString":"The equalizer of `(f, g)`, where `f = g`, is an isomorphism. "},{"type":"‚àÄ {n : ‚Ñï+} (x : n ‚â† 1), ‚àÉ (k : ‚Ñï+), n = k + 1","name":"PNat.exists_eq_succ_of_ne_one","isProp":true,"docString":"If `n : ‚Ñï+` is different from `1`, then it is the successor of some `k : ‚Ñï+`. "},{"type":"‚àÄ {Œπ : Type u_1} {I : BoxIntegral.Box Œπ} (œÄ : BoxIntegral.Prepartition I) [inst : Fintype Œπ] (x : (a : Œπ) ‚Üí ‚Ñù),\n  Finset.card\n      (Finset.filter (fun (J : BoxIntegral.Box Œπ) ‚Ü¶ x ‚àà ‚ÜëBoxIntegral.Box.Icc J) (BoxIntegral.Prepartition.boxes œÄ)) ‚â§\n    2 ^ Fintype.card Œπ","name":"BoxIntegral.Prepartition.card_filter_mem_Icc_le","isProp":true,"docString":"The set of boxes of a prepartition that contain `x` in their closures has cardinality\nat most `2 ^ Fintype.card Œπ`. "},{"type":"‚àÄ {Œ± : Sort u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (self : Equivalence r) {x : Œ±} {y : Œ±} (a : r x y), r y x","name":"Equivalence.symm","isProp":true,"docString":"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±) (b : Œ±), a / b = a * b‚Åª¬π","name":"LinearOrderedCommGroupWithZero.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} {N : Type u_2} [inst_1 : Group N] (f : G ‚Üí* N),\n  Subgroup.map f (Subgroup.normalizer H) ‚â§ Subgroup.normalizer (Subgroup.map f H)","name":"Subgroup.le_normalizer_map","isProp":true,"docString":"The image of the normalizer is contained in the normalizer of the image. "},{"type":"‚àÄ {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} [inst : DecidablePred p] {s : Finset Œ±} (h : ‚àÄ (x : Œ±) (a : x ‚àà s), p x),\n  Finset.filter p s = s","name":"Finset.filter_true_of_mem","isProp":true,"docString":"If all elements of a `Finset` satisfy the predicate `p`, `s.filter p` is `s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (hf : AntitoneOn f s) (hg : AntitoneOn g s), AntitoneOn (fun (x : Œ≤) ‚Ü¶ f x * g x) s","name":"AntitoneOn.mul'","isProp":true,"docString":"The product of two antitone functions is antitone. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\n  [inst_1 : CategoryTheory.Category D]\n  [inst_2 :\n    ‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\n  (P : C·µí·µñ ‚•§ D)\n  [inst_3 : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ D],\n  CategoryTheory.GrothendieckTopology.plusMap J (CategoryTheory.GrothendieckTopology.toPlus J P) =\n    CategoryTheory.GrothendieckTopology.toPlus J (CategoryTheory.GrothendieckTopology.plusObj J P)","name":"CategoryTheory.GrothendieckTopology.plusMap_toPlus","isProp":true,"docString":"`(P ‚ü∂ P‚Å∫)‚Å∫ = P‚Å∫ ‚ü∂ P‚Å∫‚Å∫` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {ùîñ : Set (Set Œ±)} (S : Set Œ±) (V : Set (Œ≤ √ó Œ≤)),\n  UniformOnFun.gen ùîñ S V =\n    Prod.map (Set.restrict S ‚àò ‚ÜëUniformFun.toFun) (Set.restrict S ‚àò ‚ÜëUniformFun.toFun) ‚Åª¬π' UniformFun.gen (‚ÜëS) Œ≤ V","name":"UniformOnFun.gen_eq_preimage_restrict","isProp":true,"docString":"For `S : Set Œ±` and `V : Set (Œ≤ √ó Œ≤)`, we have\n`UniformOnFun.gen ùîñ S V = (S.restrict √ó S.restrict) ‚Åª¬π' (UniformFun.gen S Œ≤ V)`.\nThis is the crucial fact for proving that the family `UniformOnFun.gen S V` for `S ‚àà ùîñ` and\n`V ‚àà ùì§ Œ≤` is indeed a basis for the uniformity `Œ± ‚Üí·µ§[ùîñ] Œ≤` endowed with `ùí±(Œ±, Œ≤, ùîñ, uŒ≤)`\nthe uniform structure of `ùîñ`-convergence, as defined in `uniform_on_fun.uniform_space`. "},{"type":"‚àÄ {R : Type u_1} [inst : AddSemigroup R] {a : R} {b : R} (lra : IsAddLeftRegular a) (lrb : IsAddLeftRegular b),\n  IsAddLeftRegular (a + b)","name":"IsAddLeftRegular.add","isProp":true,"docString":"In an additive semigroup, the sum of add-left-regular elements is add-left.regular."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (Dense s : Prop) ‚Üî (‚àÄ (U : Set Œ±) (a : IsOpen U) (a : Set.Nonempty U), Set.Nonempty (U ‚à© s) : Prop)","name":"dense_iff_inter_open","isProp":true,"docString":"A set is dense if and only if it has a nonempty intersection with each nonempty open set. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ≤) ‚Üí Œ≥} {x : Œ± √ó Œ≤} (hf : ContinuousAt f (Prod.snd x)),\n  ContinuousAt (fun (x : Œ± √ó Œ≤) ‚Ü¶ f (Prod.snd x)) x","name":"ContinuousAt.snd''","isProp":true,"docString":"Precomposing `f` with `Prod.snd` is continuous at `x : Œ± √ó Œ≤` "},{"type":"‚àÄ {Œ± : Type u_1} {G‚ÇÄ : Type u_2} [inst : GroupWithZero G‚ÇÄ] [inst_1 : TopologicalSpace G‚ÇÄ]\n  [inst_2 : HasContinuousInv‚ÇÄ G‚ÇÄ] [inst_3 : ContinuousMul G‚ÇÄ] {f : (a : Œ±) ‚Üí G‚ÇÄ} {g : (a : Œ±) ‚Üí G‚ÇÄ}\n  [inst_4 : TopologicalSpace Œ±] {a : Œ±} (hf : ContinuousAt f a) (hg : ContinuousAt g a) (h‚ÇÄ : g a ‚â† 0),\n  ContinuousAt (f / g) a","name":"ContinuousAt.div","isProp":true,"docString":"Continuity at a point of the result of dividing two functions continuous at that point, where\nthe denominator is nonzero. "},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï} (n_big : 2 < n) (p_le_n : p ‚â§ n) (big : 2 * n < 3 * p),\n  ‚Üë(Nat.factorization (Nat.centralBinom n)) p = 0","name":"Nat.factorization_centralBinom_of_two_mul_self_lt_three_mul","isProp":true,"docString":"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. "},{"type":"‚àÄ {n : Type v} {Œ± : Type w} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  (b : (a : n) ‚Üí Œ±), Matrix.mulVec A (‚Üë(Matrix.cramer A) b) = Matrix.det A ‚Ä¢ b","name":"Matrix.mulVec_cramer","isProp":true,"docString":"A stronger form of **Cramer's rule** that allows us to solve some instances of `A ‚¨ù x = b` even\nif the determinant is not a unit. A sufficient (but still not necessary) condition is that `A.det`\ndivides `b`. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (b : Basis Œπ R M) (f : (a : M) ‚Üí (a : Œπ) ‚Üí R) (hadd : ‚àÄ (x : M) (y : M), f (x + y) = f x + f y)\n  (hsmul : ‚àÄ (c : R) (x : M), f (c ‚Ä¢ x) = c ‚Ä¢ f x) (f_eq : ‚àÄ (i : Œπ), f (‚Üëb i) = ‚Üë(Finsupp.single i 1)) (x : M) (i : Œπ),\n  ‚Üë(‚Üë(Basis.repr b) x) i = f x i","name":"Basis.repr_apply_eq","isProp":true,"docString":"An unbundled version of `repr_eq_iff` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : T2Space Œ±] {K : Set Œ±}\n  (hK : IsCompact K), ‚àÉ (V : Set Œ±), (IsOpen V : Prop) ‚àß ((K ‚äÜ V : Prop) ‚àß (IsCompact (closure V) : Prop) : Prop)","name":"exists_open_superset_and_isCompact_closure","isProp":true,"docString":"In a locally compact T‚ÇÇ space, every compact set has an open neighborhood with compact closure.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {u' : Œ±}\n  {s : Set Œ±} (hu' : a < u'),\n  (s ‚àà nhdsWithin a (Set.Ioi a) : Prop) ‚Üî (‚àÉ (u : Œ±), (u ‚àà Set.Ioi a : Prop) ‚àß (Set.Ioo a u ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Ioi_iff_exists_Ioo_subset'","isProp":true,"docString":"A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`\nwith `a < u < u'`, provided `a` is not a top element. "},{"type":"‚àÄ {Œ± : Type u}, Function.Injective FreeAddGroup.of","name":"FreeAddGroup.of_injective","isProp":true,"docString":"The canonical map from the type to the additive free group is an injection."},{"type":"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Mul G] [inst_1 : Mul H] {A : Finset G} {B : Finset G} {a0 : G} {b0 : G}\n  [inst_2 : DecidableEq H] (f : G ‚Üí‚Çô* H) (hf : Function.Injective ‚Üëf),\n  (UniqueMul (Finset.image (‚Üëf) A) (Finset.image (‚Üëf) B) (‚Üëf a0) (‚Üëf b0) : Prop) ‚Üî (UniqueMul A B a0 b0 : Prop)","name":"UniqueMul.mulHom_image_iff","isProp":true,"docString":"`Unique_Mul` is preserved under multiplicative maps that are injective.\n\nSee `UniqueMul.mulHom_map_iff` for a version with swapped bundling. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : DecidableEq Œ±] [inst_1 : AddZeroClass M] [inst_2 : CommMonoid N]\n  {f : Œ± ‚Üí‚ÇÄ M} {g : Œ± ‚Üí‚ÇÄ M} {h : (a : Œ±) ‚Üí (a : M) ‚Üí N}\n  (h_zero : ‚àÄ (a : Œ±) (a_1 : a ‚àà Finsupp.support f ‚à™ Finsupp.support g), h a 0 = 1)\n  (h_add :\n    ‚àÄ (a : Œ±) (a_1 : a ‚àà Finsupp.support f ‚à™ Finsupp.support g) (b‚ÇÅ : M) (b‚ÇÇ : M), h a (b‚ÇÅ + b‚ÇÇ) = h a b‚ÇÅ * h a b‚ÇÇ),\n  Finsupp.prod (f + g) h = Finsupp.prod f h * Finsupp.prod g h","name":"Finsupp.prod_add_index","isProp":true,"docString":"Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism on the support.\nThis is a more general version of `Finsupp.prod_add_index'`; the latter has simpler hypotheses. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] (s : Submonoid M) {l : List M} (hl : ‚àÄ (x : M) (a : x ‚àà l), x ‚àà s), List.prod l ‚àà s","name":"Submonoid.list_prod_mem","isProp":true,"docString":"Product of a list of elements in a submonoid is in the submonoid. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalSeminormedRing Œ±] (x : Œ±) (y : Œ±), ‚Äñ‚Üë(AddMonoidHom.mulLeft x) y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ","name":"mulLeft_bound","isProp":true,"docString":"In a seminormed ring, the left-multiplication `AddMonoidHom` is bounded. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G) (b : G), ‚Üëf (a / b) = ‚Üëf a / ‚Üëf b","name":"map_div","isProp":true,"docString":"Group homomorphisms preserve division. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A * C) * Finset.card B ‚â§ Finset.card (A * B) * Finset.card (B * C)","name":"Finset.card_mul_mul_card_le_card_mul_mul_card_mul","isProp":true,"docString":"**Ruzsa's triangle inequality**. Multiplication version. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.EssentiallySmall C],\n  ‚àÉ (S : Type w), ‚àÉ (x : CategoryTheory.SmallCategory S), Nonempty (C ‚âå S)","name":"CategoryTheory.EssentiallySmall.equiv_smallCategory","isProp":true,"docString":"An essentially small category is equivalent to some small category. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {y : Œ±} {s : Set Œ±},\n  EMetric.infEdist x s ‚â§ EMetric.infEdist y s + edist x y","name":"EMetric.infEdist_le_infEdist_add_edist","isProp":true,"docString":"The edist of `x` to `s` is bounded by the sum of the edist of `y` to `s` and\nthe edist from `x` to `y` "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan f f) F]\n  [inst_3 : CategoryTheory.Mono (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)], CategoryTheory.Mono f","name":"CategoryTheory.reflects_mono_of_reflectsLimit","isProp":true,"docString":"If `F` reflects pullbacks, then it reflects monomorphisms. "},{"type":"‚àÄ {Œ± : Type u} [inst : OrderedRing Œ±] {a : Œ±} {b : Œ±} (ha : a ‚â§ 0) (h : b ‚â§ 1), a ‚â§ a * b","name":"le_mul_of_le_one_right","isProp":true,"docString":"Variant of `mul_le_of_le_one_right` for `a` non-positive instead of non-negative. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : AddMonoid Œ≤] (f : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Œ≤) (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop)\n  [t : IsTotal Œ± r] (hswap : ‚àÄ (a : Œ±) (b : Œ±), f a b + f b a = 0)\n  (hmul : ‚àÄ {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : r a b) (a_2 : r b c), f a c = f a b + f b c) (a : Œ±) (b : Œ±) (c : Œ±),\n  f a c = f a b + f b c","name":"additive_of_isTotal","isProp":true,"docString":"If a binary function from a type equipped with a total relation\n`r` to an additive monoid is anti-symmetric (i.e. satisfies `f a b + f b a = 0`), in order to show\nit is additive (i.e. satisfies `f a c = f a b + f b c`), we may assume `r a b` and `r b c`\nare satisfied."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {E : Type u_3}\n  [inst_2 : Norm E] {F : Type u_4} [inst_3 : Norm F] (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : (a : Œ≤) ‚Üí E} {g : (a : Œ≤) ‚Üí F} {C : ‚Ñù},\n  (Asymptotics.IsBigOWith C (nhds b) f g : Prop) ‚Üî\n    (Asymptotics.IsBigOWith C (nhds (‚Üë(Homeomorph.symm e) b)) (f ‚àò ‚Üëe) (g ‚àò ‚Üëe) : Prop)","name":"Homeomorph.isBigOWith_congr","isProp":true,"docString":"Transfer `IsBigOWith` over a `Homeomorph`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : Fintype Œ±] {R : Type u_2} [inst_1 : CommSemiring R] (a : R) (b : R),\n  (Finset.sum Finset.univ fun (s : Finset Œ±) ‚Ü¶ a ^ Finset.card s * b ^ (Fintype.card Œ± - Finset.card s)) =\n    (a + b) ^ Fintype.card Œ±","name":"Fintype.sum_pow_mul_eq_add_pow","isProp":true,"docString":"Summing `a^s.card * b^(n-s.card)` over all finite subsets `s` of a fintype of cardinality `n`\ngives `(a + b)^n`. The \"good\" proof involves expanding along all coordinates using the fact that\n`x^n` is multilinear, but multilinear maps are only available now over rings, so we give instead\na proof reducing to the usual binomial theorem to have a result over semirings. "},{"type":"‚àÄ (R : Type u) [inst : Ring R] (hf : IsField R) (x : R) (a : x ‚â† 0), ‚àÉ! (y : R), x * y = 1","name":"uniq_inv_of_isField","isProp":true,"docString":"For each field, and for each nonzero element of said field, there is a unique inverse.\nSince `IsField` doesn't remember the data of an `inv` function and as such,\na lemma that there is a unique inverse could be useful.\n"},{"type":"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] {f : Polynomial ‚Ñ§} {a : ‚Ñ§} {b : ‚Ñ§} (b0 : 0 < b)\n  (fab : Polynomial.eval (‚Üëa / ‚Üëb) (Polynomial.map (algebraMap ‚Ñ§ K) f) ‚â† 0),\n  1 ‚â§ ‚Üëb ^ Polynomial.natDegree f * abs (Polynomial.eval (‚Üëa / ‚Üëb) (Polynomial.map (algebraMap ‚Ñ§ K) f))","name":"one_le_pow_mul_abs_eval_div","isProp":true,"docString":"Evaluating a polynomial with integer coefficients at a rational number and clearing\ndenominators, yields a number greater than or equal to one.  The target can be any\n`LinearOrderedField K`.\nThe assumption on `K` could be weakened to `LinearOrderedCommRing` assuming that the\nimage of the denominator is invertible in `K`. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedRing Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"LinearOrderedRing.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {Œ± : Type u_1} {G : Type u_2} [inst : AddGroup G] {ùîñ : Set (Set Œ±)} [inst_1 : UniformSpace G]\n  [inst_2 : UniformAddGroup G], UniformAddGroup (UniformOnFun Œ± G ùîñ)","name":"instUniformAddGroupUniformOnFunUniformSpaceInstAddGroupUniformOnFun","isProp":true,"docString":"Let `ùîñ : Set (Set Œ±)`. If `G` is a uniform additive group,\nthen `Œ± ‚Üí·µ§[ùîñ] G` is a uniform additive group as well."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (a : IsCompact s) (f : Ultrafilter Œ±)\n  (a : ‚Üëf ‚â§ Filter.principal s), ‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (‚Üëf ‚â§ nhds a : Prop)","name":"IsCompact.ultrafilter_le_nhds","isProp":true,"docString":"**Alias** of the forward direction of `isCompact_iff_ultrafilter_le_nhds`."},{"type":"‚àÄ {s : Set Cardinal}, (BddAbove s : Prop) ‚Üî (Small ‚Üës : Prop)","name":"Cardinal.bddAbove_iff_small","isProp":true,"docString":"A set of cardinals is bounded above iff it's small, i.e. it corresponds to an usual ZFC set. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sup‚Çõ s)) (Af : Antitone f)\n  (ne : Set.Nonempty s) (H : BddAbove s), f (sup‚Çõ s) = inf‚Çõ (f '' s)","name":"Antitone.map_csup‚Çõ_of_continuousAt","isProp":true,"docString":"If an antitone function is continuous at the supremum of a nonempty bounded above set `s`,\nthen it sends this supremum to the infimum of the image of `s`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G·µÉ·µí·µñ G","name":"AddAction.OppositeRegular.isPretransitive","isProp":true,"docString":"The right regular action of an additive group on itself is transitive."},{"type":"‚àÄ {n : ‚Ñï}, Nat.fib (n + 2) = Nat.fib n + Nat.fib (n + 1)","name":"Nat.fib_add_two","isProp":true,"docString":"Shows that `fib` indeed satisfies the Fibonacci recurrence `F‚Çô‚Çä‚ÇÇ = F‚Çô + F‚Çô‚Çä‚ÇÅ.` "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  CategoryTheory.IsConnected (CategoryTheory.Component j)","name":"CategoryTheory.instIsConnectedComponentInstCategoryComponent","isProp":true,"docString":"Each connected component of the category is connected. "},{"type":"¬¨(BddAbove (setOf fun (p : ‚Ñï) ‚Ü¶ Nat.Prime p) : Prop)","name":"Nat.not_bddAbove_setOf_prime","isProp":true,"docString":"A version of `Nat.exists_infinite_primes` using the `BddAbove` predicate. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (self : NonarchAddGroupSeminorm G) (r : G),\n  ZeroHom.toFun (NonarchAddGroupSeminorm.toZeroHom self) (-r) = ZeroHom.toFun (NonarchAddGroupSeminorm.toZeroHom self) r","name":"NonarchAddGroupSeminorm.neg'","isProp":true,"docString":"The seminorm is invariant under negation. "},{"type":"‚àÄ {Œ± : Type u_1} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (a : List.Sublist l‚ÇÅ l‚ÇÇ), List.length l‚ÇÅ ‚â§ List.length l‚ÇÇ","name":"List.length_le_of_sublist","isProp":true,"docString":"**Alias** of `List.Sublist.length_le`."},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLinearOrder Œ±] {a : Œ±} [inst_1 : Nonempty Œπ]\n  {f : (a : Œπ) ‚Üí Œ±} (h : inf·µ¢ f < a), ‚àÉ (i : Œπ), f i < a","name":"exists_lt_of_cinf·µ¢_lt","isProp":true,"docString":"Indexed version of the above lemma `exists_lt_of_cinf‚Çõ_lt`\nWhen `inf·µ¢ f < a`, there is an element `i` such that `f i < a`.\n"},{"type":"‚àÄ {n : ‚Ñï} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ‚â§ ‚ÜëFin.castSucc j),\n  SimplexCategory.Œ¥ (‚ÜëFin.castSucc i) ‚â´ SimplexCategory.œÉ (Fin.succ j) = SimplexCategory.œÉ j ‚â´ SimplexCategory.Œ¥ i","name":"SimplexCategory.Œ¥_comp_œÉ_of_le","isProp":true,"docString":"The second simplicial identity "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {Œ± : Type u_1} {Œ≤ : Type u_2} [inst_1 : SMul Œ± Œ≤] [inst_2 : SMul R Œ±] [inst_3 : SMul R Œ≤]\n  [inst_4 : IsScalarTower R Œ± Œ≤] (S : Subring R), IsScalarTower { x : R // x ‚àà S } Œ± Œ≤","name":"Subring.instIsScalarTowerSubtypeMemSubringInstMembershipInstSetLikeSubringInstSMulSubtypeMemSubringInstMembershipInstSetLikeSubringInstSMulSubtypeMemSubringInstMembershipInstSetLikeSubring","isProp":true,"docString":"Note that this provides `IsScalarTower S R R` which is needed by `smul_mul_assoc`. "},{"type":"‚àÄ {G‚ÇÄ : Type u} [self : GroupWithZero G‚ÇÄ], 0‚Åª¬π = 0","name":"GroupWithZero.inv_zero","isProp":true,"docString":"The inverse of `0` in a group with zero is `0`. "},{"type":"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\n  {i : n} {j : n} (i_ne_j : i ‚â† j) (hij : ‚àÄ (k : n), M k i = M k j), Matrix.det M = 0","name":"Matrix.det_zero_of_column_eq","isProp":true,"docString":"If a matrix has a repeated column, the determinant will be zero. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type x} [inst : PseudoMetricSpace Œ±] [inst_1 : Fintype Œπ] {f : (a : Œ±) ‚Üí (a : Œπ) ‚Üí ‚Ñù} {s : Set Œ±}\n  {K : NNReal} (hf : LipschitzOnWith K f s),\n  ‚àÉ (g : (a : Œ±) ‚Üí (a : Œπ) ‚Üí ‚Ñù), (LipschitzWith K g : Prop) ‚àß (Set.EqOn f g s : Prop)","name":"LipschitzOnWith.extend_pi","isProp":true,"docString":"A function `f : Œ± ‚Üí (Œπ ‚Üí ‚Ñù)` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz\nextension to the whole space.\nTODO: state the same result (with the same proof) for the space `‚Ñì^‚àû (Œπ, ‚Ñù)` over a possibly\ninfinite type `Œπ`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {T : CategoryTheory.Monad C} (self : CategoryTheory.Monad.Algebra T),\n  (CategoryTheory.Monad.Œº T).app (CategoryTheory.Monad.Algebra.A self) ‚â´ CategoryTheory.Monad.Algebra.a self =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Monad.toFunctor T))\n        (CategoryTheory.Monad.Algebra.a self) ‚â´\n      CategoryTheory.Monad.Algebra.a self","name":"CategoryTheory.Monad.Algebra.assoc","isProp":true,"docString":"The associativity axiom associated to an algebra. "},{"type":"‚àÄ {M : Type u_1} {A : Type u_2} [inst : CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (f : (a : A) ‚Üí M) (t : Finset A)\n  (a : ‚àÄ (b : A) (a : b ‚àà t), f b ‚àà s), (Finset.prod t fun (b : A) ‚Ü¶ f b) ‚àà s","name":"IsSubmonoid.finset_prod_mem","isProp":true,"docString":"The product of elements of a submonoid of a `CommMonoid` indexed by a `Finset` is an element\nof the submonoid. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} {y : Œ±}\n  (hy : Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ (f^[n]) x) Filter.atTop (nhds y)) (hf : ContinuousAt f y), Function.IsFixedPt f y","name":"isFixedPt_of_tendsto_iterate","isProp":true,"docString":"If the iterates `f^[n] x` converge to `y` and `f` is continuous at `y`,\nthen `y` is a fixed point for `f`. "},{"type":"‚àÄ {Œπa : Type u_1} {Œπb : Type u_2} [inst : Fintype Œπa] [inst_1 : Fintype Œπb] {R' : Type u_3} {M·µ¢ : Type u_4}\n  {N‚ÇÅ : Type u_5} {N‚ÇÇ : Type u_6} [inst_2 : CommSemiring R'] [inst_3 : AddCommGroup N‚ÇÅ] [inst_4 : Module R' N‚ÇÅ]\n  [inst_5 : AddCommGroup N‚ÇÇ] [inst_6 : Module R' N‚ÇÇ] [inst_7 : AddCommMonoid M·µ¢] [inst_8 : Module R' M·µ¢]\n  [inst_9 : DecidableEq Œπa] [inst_10 : DecidableEq Œπb] (a : MultilinearMap R' (fun (x : Œπa) ‚Ü¶ M·µ¢) N‚ÇÅ)\n  (b : MultilinearMap R' (fun (x : Œπb) ‚Ü¶ M·µ¢) N‚ÇÇ),\n  ‚ÜëMultilinearMap.alternatization (MultilinearMap.domCoprod a b) =\n    AlternatingMap.domCoprod (‚ÜëMultilinearMap.alternatization a) (‚ÜëMultilinearMap.alternatization b)","name":"MultilinearMap.domCoprod_alternization","isProp":true,"docString":"Computing the `MultilinearMap.alternatization` of the `MultilinearMap.domCoprod` is the same\nas computing the `AlternatingMap.domCoprod` of the `MultilinearMap.alternatization`s.\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) < Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i : Prop) ‚Üî\n    (¬¨(AntivaryOn (f ‚àò ‚ÜëœÉ) g ‚Üës : Prop) : Prop)","name":"AntivaryOn.sum_smul_lt_sum_comp_perm_smul_iff","isProp":true,"docString":"**Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f ‚àò œÉ` and `g` do not antivary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteLattice Œ±] (x : Œ±), x ‚â§ ‚ä§","name":"CompleteLattice.le_top","isProp":true,"docString":"Any element is less than the top one. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop},\n  Function.Injective fun (f : r ‚âÉr s) ‚Ü¶ ‚Üëf","name":"RelIso.coe_fn_injective","isProp":true,"docString":"The map `coe_fn : (r ‚âÉr s) ‚Üí (Œ± ‚Üí Œ≤)` is injective. Lean fails to parse\n`function.injective (Œª e : r ‚âÉr s, (e : Œ± ‚Üí Œ≤))`, so we use a trick to say the same. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ≤] {f : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f)\n  (hlim : Filter.Tendsto f (Filter.cocompact Œ≤) Filter.atTop), ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f x ‚â§ f y","name":"Continuous.exists_forall_le","isProp":true,"docString":"The **extreme value theorem**: if a continuous function `f` tends to infinity away from compact\nsets, then it has a global minimum. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : b ‚â§ c) (a_2 : a = b), a ‚â§ c","name":"LE.le.trans_eq'","isProp":true,"docString":"**Alias** of `le_of_le_of_eq'`."},{"type":"‚àÄ (Œ± : Type u_1) [inst : MetricSpace Œ±] [inst_1 : CompleteSpace Œ±] [inst_2 : TopologicalSpace.SecondCountableTopology Œ±]\n  [inst_3 : Nonempty Œ±], ‚àÉ (f : (a : (a : ‚Ñï) ‚Üí ‚Ñï) ‚Üí Œ±), (Continuous f : Prop) ‚àß (Function.Surjective f : Prop)","name":"exists_nat_nat_continuous_surjective_of_completeSpace","isProp":true,"docString":"Any nonempty complete second countable metric space is the continuous image of the\nfundamental space `‚Ñï ‚Üí ‚Ñï`. For a version of this theorem in the context of Polish spaces, see\n`exists_nat_nat_continuous_surjective_of_polishSpace`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : CompleteLattice Œ±] {f : Filter Œ≤}, Filter.liminf (fun (x : Œ≤) ‚Ü¶ ‚ä§) f = ‚ä§","name":"Filter.liminf_const_top","isProp":true,"docString":"Same as limsup_const applied to `‚ä§` but without the `NeBot f` assumption "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {p : (a : M) ‚Üí Prop} (x : M) {s : Set M} (hs : AddSubsemigroup.closure s = ‚ä§)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s), p x) (Hmul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x + y)), p x","name":"AddSubsemigroup.dense_induction","isProp":true,"docString":"If `s` is a dense set in an additive monoid `M`,\n`AddSubsemigroup.closure s = ‚ä§`, then in order to prove that some predicate `p` holds\nfor all `x : M` it suffices to verify `p x` for `x ‚àà s`, and verify that `p x` and `p y` imply\n`p (x + y)`."},{"type":"‚àÄ {n : ‚Ñï}, Fact (Even (Fintype.card (Fin (bit0 n))) : Prop)","name":"Fintype.card_fin_even","isProp":true,"docString":"The cardinality of `Fin (bit0 n)` is even, `fact` version.\nThis `fact` is needed as an instance by `Matrix.SpecialLinearGroup.has_neg`. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] (self : RingInvo R) (x : R),\n  MulOpposite.unop\n      (Equiv.toFun (RingEquiv.toEquiv (RingInvo.toRingEquiv self))\n        (MulOpposite.unop (Equiv.toFun (RingEquiv.toEquiv (RingInvo.toRingEquiv self)) x))) =\n    x","name":"RingInvo.involution'","isProp":true,"docString":"The requirement that the ring homomorphism is its own inverse "},{"type":"‚àÄ {n : ‚Ñï} {m : ‚Ñï} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)), ¬¨(‚àÉ (t : ‚Ñï), t * t = n : Prop)","name":"Nat.not_exists_sq","isProp":true,"docString":"There are no perfect squares strictly between m¬≤ and (m+1)¬≤ "},{"type":"‚àÄ {P : (Œ± : Type u) ‚Üí [inst : Fintype Œ±] ‚Üí Prop}\n  (of_equiv : ‚àÄ (Œ± : Type u) (Œ≤ : Type u) [inst : Fintype Œ≤] (e : Œ± ‚âÉ Œ≤) (a : P Œ±), P Œ≤) (h_empty : P PEmpty)\n  (h_option : ‚àÄ (Œ± : Type u) [inst : Fintype Œ±] (a : P Œ±), P (Option Œ±)) (Œ± : Type u) [h_fintype : Fintype Œ±], P Œ±","name":"Fintype.induction_empty_option","isProp":true,"docString":"An induction principle for finite types, analogous to `Nat.rec`. It effectively says\nthat every `Fintype` is either `Empty` or `Option Œ±`, up to an `Equiv`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : Set Œ±} {t : Set Œ±} (ht : IsAntichain r t) (h : maximals r s ‚äÜ t)\n  (hs : ‚àÄ ‚¶Éa : Œ±‚¶Ñ (a_1 : a ‚àà t), ‚àÉ (b : Œ±), (b ‚àà maximals r s : Prop) ‚àß (r b a : Prop)), maximals r s = t","name":"IsAntichain.max_maximals","isProp":true,"docString":"If `maximals r s` is included in but *shadows* the antichain `t`, then it is actually\nequal to `t`. "},{"type":"‚àÄ {Œπ : Type v} {Œπ' : Type v'} {f : (a : Œπ) ‚Üí Cardinal} {f' : (a : Œπ') ‚Üí Cardinal} (hf : BddAbove (Set.range f))\n  (hf' : BddAbove (Set.range f')) (g : (a : Œπ) ‚Üí Œπ') (h : ‚àÄ (i : Œπ), Cardinal.lift (f i) ‚â§ Cardinal.lift (f' (g i))),\n  Cardinal.lift (sup·µ¢ f) ‚â§ Cardinal.lift (sup·µ¢ f')","name":"Cardinal.lift_sup·µ¢_le_lift_sup·µ¢'","isProp":true,"docString":"A variant of `lift_sup·µ¢_le_lift_sup·µ¢` with universes specialized via `w = v` and `w' = v'`.\nThis is sometimes necessary to avoid universe unification issues. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} {Œ≥ : Type u_1} [inst : UniformSpace Œ≤] [inst_1 : UniformSpace Œ≥] {f : (a : Œ≥) ‚Üí Œ≤}\n  (hf : UniformContinuous f),\n  UniformContinuous (‚ÜëUniformFun.ofFun ‚àò (fun (x : (a : Œ±) ‚Üí Œ≥) ‚Ü¶ f ‚àò x) ‚àò ‚ÜëUniformFun.toFun)","name":"UniformFun.postcomp_uniformContinuous","isProp":true,"docString":"Post-composition by a uniformly continuous function is uniformly continuous on `Œ± ‚Üí·µ§ Œ≤`.\n\nMore precisely, if `f : Œ≥ ‚Üí Œ≤` is uniformly continuous, then `(Œª g, f ‚àò g) : (Œ± ‚Üí·µ§ Œ≥) ‚Üí (Œ± ‚Üí·µ§ Œ≤)`\nis uniformly continuous. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  {Œ≥ : Type u_1} (hf : UniformCauchySeqOn F p s) (g : (a : Œ≥) ‚Üí Œ±),\n  UniformCauchySeqOn (fun (n : Œπ) ‚Ü¶ F n ‚àò g) p (g ‚Åª¬π' s)","name":"UniformCauchySeqOn.comp","isProp":true,"docString":"Composing on the right by a function preserves uniform Cauchy sequences "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : IsPredArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc n m), r (Order.pred i) i)\n  (hmn : n ‚â§ m), Relation.ReflTransGen r n m","name":"reflTransGen_of_pred_of_le","isProp":true,"docString":"For `n ‚â§ m`, `(n, m)` is in the reflexive-transitive closure of `~` if `pred i ~ i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R]\n  {S : Type u_3} [inst_3 : CommRing S] [inst_4 : IsDomain S] [inst_5 : Algebra R S] [inst_6 : Finite Œπ]\n  (b : Basis Œπ R S) (I : Ideal S) (hI : I ‚â† ‚ä•) (i : Œπ),\n  ‚Üë(‚Üë(Ideal.selfBasis b I hI) i) = Ideal.smithCoeffs b I hI i ‚Ä¢ ‚Üë(Ideal.ringBasis b I hI) i","name":"Ideal.selfBasis_def","isProp":true,"docString":"If `S` a finite-dimensional ring extension of a PID `R` which is free as an `R`-module,\nthen any nonzero `S`-ideal `I` is free as an `R`-submodule of `S`, and we can\nfind a basis for `S` and `I` such that the inclusion map is a square diagonal\nmatrix.\n"},{"type":"‚àÄ {Œ± : Type u} (L : List Œ±) {i : ‚Ñï} {j : ‚Ñï} (hi : i < List.length (List.take j L)),\n  List.nthLe (List.take j L) i hi =\n    List.nthLe L i\n      ((lt_of_lt_of_le hi\n            ((of_eq_true\n                  ((Eq.trans\n                        ((Eq.trans\n                              ((Eq.trans\n                                    ((congrFun\n                                          ((congrArg LE.le\n                                                ((List.length_take j\n                                                      L=:List.length (List.take j L) =\n                                                      min j\n                                                        (List.length\n                                                          L))=:List.length (List.take j L) =\n                                                    min j\n                                                      (List.length\n                                                        L))=:LE.le (List.length (List.take j L)) =\n                                                LE.le\n                                                  (min j\n                                                    (List.length\n                                                      L)))=:LE.le (List.length (List.take j L)) =\n                                              LE.le (min j (List.length L)))\n                                          (List.length\n                                            L)=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                          (min j (List.length L) ‚â§ List.length L :\n                                            Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                        (min j (List.length L) ‚â§ List.length L : Prop))\n                                    ((Mathlib.Order.MinMax._auxLemma.3=:(min j (List.length L) ‚â§ List.length L : Prop) =\n                                          ((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) :\n                                            Prop))=:(min j (List.length L) ‚â§ List.length L : Prop) =\n                                        ((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) :\n                                          Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                    ((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) :\n                                      Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                  ((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) : Prop))\n                              ((congrArg (Or (j ‚â§ List.length L : Prop))\n                                    ((Mathlib.Init.Algebra.Order._auxLemma.1\n                                          (List.length\n                                            L)=:(List.length L ‚â§ List.length L : Prop) =\n                                          (True :\n                                            Prop))=:(List.length L ‚â§ List.length L : Prop) =\n                                        (True :\n                                          Prop))=:((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) :\n                                      Prop) =\n                                    ((j ‚â§ List.length L : Prop) ‚à® (True : Prop) :\n                                      Prop))=:((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) :\n                                    Prop) =\n                                  ((j ‚â§ List.length L : Prop) ‚à® (True : Prop) :\n                                    Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                              ((j ‚â§ List.length L : Prop) ‚à® (True : Prop) :\n                                Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                            ((j ‚â§ List.length L : Prop) ‚à® (True : Prop) : Prop))\n                        ((or_true\n                              (j ‚â§ List.length L :\n                                Prop)=:((j ‚â§ List.length L : Prop) ‚à® (True : Prop) : Prop) =\n                              (True :\n                                Prop))=:((j ‚â§ List.length L : Prop) ‚à® (True : Prop) : Prop) =\n                            (True :\n                              Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                        (True :\n                          Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                      (True :\n                        Prop))=:List.length (List.take j L) ‚â§\n                  List.length L)=:List.length (List.take j L) ‚â§ List.length L)=:i < List.length L)=:i < List.length L)","name":"List.nthLe_take'","isProp":true,"docString":"The `i`-th element of a list coincides with the `i`-th element of any of its prefixes of\nlength `> i`. Version designed to rewrite from the small list to the big list. "},{"type":"‚àÄ {Œ± : Type u_1} {x : (a : ‚Ñï) ‚Üí Œ±} {y : (a : ‚Ñï) ‚Üí Œ±} {n : ‚Ñï},\n  (PiNat.res x n = PiNat.res y n : Prop) ‚Üî (‚àÄ ‚¶Ém : ‚Ñï‚¶Ñ (a : m < n), x m = y m : Prop)","name":"PiNat.res_eq_res","isProp":true,"docString":"The restrictions of `x` and `y` to `n` are equal if and only if `x m = y m` for all `m < n`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Antivary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) < Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i) : Prop) ‚Üî\n    (¬¨(Antivary f (g ‚àò ‚ÜëœÉ) : Prop) : Prop)","name":"Antivary.sum_smul_lt_sum_smul_comp_perm_iff","isProp":true,"docString":"**Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not antivary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {v : Sat.Valuation} {l : Sat.Literal} (h‚ÇÅ : ‚àÄ (a : Sat.Valuation.neg v (Sat.Literal.negate l)), False)\n  (h‚ÇÇ : ‚àÄ (a : Sat.Valuation.neg v l), False), False","name":"Sat.Valuation.by_cases","isProp":true,"docString":"The core unit-propagation step.\n\nWe have a local context of assumptions `¬¨l'` (sometimes called an assignment)\nand we wish to add `¬¨l` to the context, that is, we want to prove `l` is also falsified.\nThis is because there is a clause `a ‚à® b ‚à® ¬¨l` in the global context\nsuch that all literals in the clause are falsified except for `¬¨l`;\nso in the context `h‚ÇÅ` where we suppose that `¬¨l` is falsified,\nthe clause itself is falsified so we can prove `False`.\nWe continue the proof in `h‚ÇÇ`, with the assumption that `l` is falsified. "},{"type":"‚àÄ {Œπ : Type u_1} {a : (a : Œπ) ‚Üí ENNReal} (tsum_ne_top : (tsum fun (i : Œπ) ‚Ü¶ a i) ‚â† ‚ä§) {Œµ : ENNReal} (Œµ_ne_zero : Œµ ‚â† 0),\n  Set.Finite (setOf fun (i : Œπ) ‚Ü¶ Œµ ‚â§ a i)","name":"ENNReal.finite_const_le_of_tsum_ne_top","isProp":true,"docString":"A sum of extended nonnegative reals which is finite can have only finitely many terms\nabove any positive threshold."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ioc (f (Order.succ n)) (f n))","name":"Antitone.pairwise_disjoint_on_Ioc_succ","isProp":true,"docString":"If `Œ±` is a linear succ order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is an antitone function, then\nthe intervals `Set.Ioc (f (Order.succ n)) (f n)` are pairwise disjoint. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) (s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop)\n  [inst : IsTrichotomous Œ± r] [inst : IsIrrefl Œ≤ s] (f : (a : Œ±) ‚Üí Œ≤)\n  (hf : ‚àÄ {x : Œ±} {y : Œ±} (a : r x y), s (f x) (f y)), Function.Injective f","name":"injective_of_increasing","isProp":true,"docString":"An increasing function is injective "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  (p : Seminorm ùïú E) {r : ‚Ñù} (hr : 0 < r), Absorbent ùïú (Seminorm.closedBall p 0 r)","name":"Seminorm.absorbent_closedBall_zero","isProp":true,"docString":"Closed seminorm-balls at the origin are absorbent. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M], Reflexive fun (a : M) (b : M) ‚Ü¶ ‚àÉ (c : M), SemiconjBy c a b","name":"SemiconjBy.reflexive","isProp":true,"docString":"The relation ‚Äúthere exists an element that semiconjugates `a` to `b`‚Äù on a monoid (or, more\ngenerally, on `MulOneClass` type) is reflexive. "},{"type":"‚àÄ {M : Type u_2} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_3} [inst_1 : AddCommMonoid N] {P : Type u_1}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëg ‚Üëy)) (z : N),\n  ‚Üë(AddSubmonoid.LocalizationMap.lift f hg) z + ‚Üëg ‚Üë(Prod.snd (AddSubmonoid.LocalizationMap.sec f z)) =\n    ‚Üëg (Prod.fst (AddSubmonoid.LocalizationMap.sec f z))","name":"AddSubmonoid.LocalizationMap.lift_add_right","isProp":true,"docString":"Given a Localization map `f : M ‚Üí+ N` for a Submonoid `S ‚äÜ M`, if an `AddCommMonoid`\nmap `g : M ‚Üí+ P` induces a map `f.lift hg : N ‚Üí+ P` then for all `z : N`, we have\n`f.lift hg z + g y = g x`, where `x : M, y ‚àà S` are such that `z + f y = f x`."},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï}, (‚àÄ (a : ‚Ñï), (a ‚à£ m : Prop) ‚Üî (a ‚à£ n : Prop) : Prop) ‚Üî (m = n : Prop)","name":"Nat.dvd_left_iff_eq","isProp":true,"docString":"Two natural numbers are equal if and only if they have the same divisors. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (e : LocalHomeomorph Œ± Œ≤)\n  (h : LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) = Set.univ), OpenEmbedding ‚Üëe","name":"LocalHomeomorph.to_openEmbedding","isProp":true,"docString":"A local homeomorphism whose source is all of `Œ±` defines an open embedding of `Œ±` into `Œ≤`.  The\nconverse is also true; see `OpenEmbedding.toLocalHomeomorph`. "},{"type":"‚àÄ {t : (a : Type u) ‚Üí Type u} [inst : Traversable t] [self : IsLawfulTraversable t] {Œ± : Type u} (x : t Œ±),\n  traverse pure x = x","name":"IsLawfulTraversable.id_traverse","isProp":true,"docString":"`traverse` plays well with `pure` of the identity monad"},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : BiheytingAlgebra Œ±]\n  [inst_1 : BiheytingAlgebra Œ≤] [self : BiheytingHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a \\ b) = ‚Üëf a \\ ‚Üëf b","name":"BiheytingHomClass.map_sdiff","isProp":true,"docString":"The proposition that a bi-Heyting homomorphism preserves the difference operation."},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Finite s), ¬¨(Set.Infinite s : Prop)","name":"Set.Finite.not_infinite","isProp":true,"docString":"**Alias** of the reverse direction of `Set.not_infinite`."},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedField Œ±], 0‚Åª¬π = 0","name":"LinearOrderedField.inv_zero","isProp":true,"docString":"We define the inverse of `0` to be `0`. "},{"type":"‚àÄ {Œπ : Type w} {R : Type u} [inst : Ring R] [inst_1 : RankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {J : Set M} (v : Basis Œπ R M) (hJ : Submodule.span R J = ‚ä§),\n  Cardinal.mk ‚Üë(Set.range ‚Üëv) ‚â§ Cardinal.mk ‚ÜëJ","name":"Basis.le_span","isProp":true,"docString":"If `R` satisfies the rank condition,\nthen the cardinality of any basis is bounded by the cardinality of any spanning set.\n"},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) {pred : (a : Œπ) ‚Üí Prop}\n  [inst_3 : DecidablePred pred] (h : ‚àÄ (i : Œπ) (a : i ‚àà s) (a : w i ‚â† 0), pred i),\n  ‚Üë(Finset.weightedVSub (Finset.filter pred s) p) w = ‚Üë(Finset.weightedVSub s p) w","name":"Finset.weightedVSub_filter_of_ne","isProp":true,"docString":"A weighted sum over `s.filter pred` equals one over `s` if all the weights at indices in `s`\nnot satisfying `pred` are zero. "},{"type":"‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] {x : F} {y : F},\n  (SameRay ‚Ñù x y : Prop) ‚Üî ((x = 0 : Prop) ‚à® ((y = 0 : Prop) ‚à® (‚Äñx‚Äñ‚Åª¬π ‚Ä¢ x = ‚Äñy‚Äñ‚Åª¬π ‚Ä¢ y : Prop) : Prop) : Prop)","name":"sameRay_iff_inv_norm_smul_eq","isProp":true,"docString":"Two vectors `x y` in a real normed space are on the ray if and only if one of them is zero or\nthe unit vectors `‚Äñx‚Äñ‚Åª¬π ‚Ä¢ x` and `‚Äñy‚Äñ‚Åª¬π ‚Ä¢ y` are equal. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ±) ‚Üí Œ≤ √ó Œ≥} (hf : Continuous f), Continuous fun (a : Œ±) ‚Ü¶ Prod.fst (f a)","name":"Continuous.fst","isProp":true,"docString":"Postcomposing `f` with `Prod.fst` is continuous "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {p : Œ±} (self : Irreducible p) (a : Œ±) (b : Œ±) (a_1 : p = a * b),\n  (IsUnit a : Prop) ‚à® (IsUnit b : Prop)","name":"Irreducible.isUnit_or_isUnit'","isProp":true,"docString":"if `p` factors then one factor is a unit "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {A : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category A] (P : C·µí·µñ ‚•§ A)\n  {X : C} (R : CategoryTheory.Presieve X),\n  (Nonempty\n        (CategoryTheory.Limits.IsLimit\n          (CategoryTheory.Functor.mapCone P\n            (CategoryTheory.Limits.Cocone.op\n              (CategoryTheory.Presieve.cocone (CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R)))))) :\n      Prop) ‚Üî\n    (‚àÄ (E : A·µí·µñ),\n        CategoryTheory.Presieve.IsSheafFor\n          (P ‚ãô Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.coyoneda) E) R :\n      Prop)","name":"CategoryTheory.Presheaf.isLimit_iff_isSheafFor_presieve","isProp":true,"docString":"Given presieve `R` and presheaf `P : C·µí·µñ ‚•§ A`, the natural cone associated to `P` and\nthe sieve `Sieve.generate R` generated by `R` is a limit cone iff `Hom (E, P -)` is a\nsheaf of types for the presieve `R` and all `E : A`. "},{"type":"‚àÄ {Œπ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset Œπ} {f : (a : Œπ) ‚Üí WithTop M},\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i) = ‚ä§ : Prop) ‚Üî (‚àÉ (i : Œπ), (i ‚àà s : Prop) ‚àß (f i = ‚ä§ : Prop) : Prop)","name":"WithTop.sum_eq_top_iff","isProp":true,"docString":"A sum of numbers is infinite iff one of them is infinite "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {œÉ : outParam (R ‚Üí+* S)} {œÉ' : outParam (S ‚Üí+* R)} [inst_2 : RingHomInvPair œÉ œÉ'] [inst_3 : RingHomInvPair œÉ' œÉ]\n  {M : outParam (Type u_4)} {M‚ÇÇ : outParam (Type u_5)} [inst_4 : AddCommMonoid M] [inst_5 : AddCommMonoid M‚ÇÇ]\n  [inst_6 : Module R M] [inst_7 : Module S M‚ÇÇ] [self : SemilinearEquivClass F œÉ M M‚ÇÇ] (f : F) (r : R) (x : M),\n  ‚Üëf (r ‚Ä¢ x) = ‚ÜëœÉ r ‚Ä¢ ‚Üëf x","name":"SemilinearEquivClass.map_smul‚Çõ‚Çó","isProp":true,"docString":"Applying a semilinear equivalence `f` over `œÉ` to `r ‚Ä¢ x ` equals `œÉ r ‚Ä¢ f x`. "},{"type":"‚àÄ {Œ± : Type u} [self : TopologicalSpace Œ±] (s : Set Œ±) (t : Set Œ±) (a : TopologicalSpace.IsOpen s)\n  (a : TopologicalSpace.IsOpen t), TopologicalSpace.IsOpen (s ‚à© t)","name":"TopologicalSpace.isOpen_inter","isProp":true,"docString":"The intersection of two open sets is an open set. Use `IsOpen.inter` instead. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeInf Œ±] {r : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (a : a‚ÇÅ ‚â§ a‚ÇÇ), r (f a‚ÇÇ) (f a‚ÇÅ)), Directed r f","name":"directed_of_inf","isProp":true,"docString":"An antitone function on an inf-semilattice is directed. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (FiniteDimensional.finrank K V = 1 : Prop) ‚Üî (‚àÉ (v : V), ‚àÉ (_n : v ‚â† 0), ‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w : Prop)","name":"finrank_eq_one_iff'","isProp":true,"docString":"A module has dimension 1 iff there is some nonzero `v : V` so every vector is a multiple of `v`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (E : Set Œ±) {Œ¥ : ‚Ñù},\n  frontier (Metric.thickening Œ¥ E) ‚äÜ setOf fun (x : Œ±) ‚Ü¶ EMetric.infEdist x E = ENNReal.ofReal Œ¥","name":"Metric.frontier_thickening_subset","isProp":true,"docString":"The frontier of the (open) thickening of a set is contained in an `EMetric.infEdist` level\nset. "},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : UniformSpace Œ±]\n  [inst_2 : UniformAddGroup Œ±] [inst_3 : CompleteSpace Œ±] {f : (a : Œπ) ‚Üí Œ±} (a : Summable fun (x : Œπ) ‚Ü¶ abs (f x)),\n  Summable f","name":"Summable.of_abs","isProp":true,"docString":"**Alias** of the forward direction of `summable_abs_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {e' : LocalEquiv Œ± Œ≤} (h : e ‚âà e'),\n  Set.EqOn (LocalEquiv.toFun (LocalEquiv.symm e)) (LocalEquiv.toFun (LocalEquiv.symm e')) (LocalEquiv.target e)","name":"LocalEquiv.EqOnSource.symm_eqOn","isProp":true,"docString":"Two equivalent local equivs have coinciding inverses on the target "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G ‚Üí* N) {H : Subgroup G} {K : Subgroup G}\n  (hH : MonoidHom.ker f ‚â§ H) (hK : MonoidHom.ker f ‚â§ K) (hf : Subgroup.map f H = Subgroup.map f K), H = K","name":"Subgroup.map_injective_of_ker_le","isProp":true,"docString":"Given `f(A) = f(B)`, `ker f ‚â§ A`, and `ker f ‚â§ B`, deduce that `A = B`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R}\n  (hroots : ‚ÜëMultiset.card (Polynomial.roots p) = Polynomial.natDegree p) {k : ‚Ñï} (h : k ‚â§ Polynomial.natDegree p),\n  Polynomial.coeff p k =\n    Polynomial.leadingCoeff p * (-1) ^ (Polynomial.natDegree p - k) *\n      Multiset.esymm (Polynomial.roots p) (Polynomial.natDegree p - k)","name":"Polynomial.coeff_eq_esymm_roots_of_card","isProp":true,"docString":"Vieta's formula for the coefficients and the roots of a polynomial over an integral domain\nwith as many roots as its degree. "},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : UniformSpace Œ≤] (ùîñ : Set (Set Œ±)) (h : Set.Nonempty ùîñ)\n  (h' : DirectedOn (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äÜ x_1) ùîñ),\n  Filter.HasBasis (uniformity (UniformOnFun Œ± Œ≤ ùîñ))\n    (fun (SV : Set Œ± √ó Set (Œ≤ √ó Œ≤)) ‚Ü¶ (Prod.fst SV ‚àà ùîñ : Prop) ‚àß (Prod.snd SV ‚àà uniformity Œ≤ : Prop))\n    fun (SV : Set Œ± √ó Set (Œ≤ √ó Œ≤)) ‚Ü¶ UniformOnFun.gen ùîñ (Prod.fst SV) (Prod.snd SV)","name":"UniformOnFun.hasBasis_uniformity","isProp":true,"docString":"If `ùîñ : Set (Set Œ±)` is nonempty and directed, then the uniformity of `Œ± ‚Üí·µ§[ùîñ] Œ≤` admits the\nfamily `{(f, g) | ‚àÄ x ‚àà S, (f x, g x) ‚àà V}` for `S ‚àà ùîñ` and `V ‚àà ùì§ Œ≤` as a filter basis. "},{"type":"‚àÄ {n : Type u_1} {ùïú : Type u_2} [inst : Field ùïú] [inst_1 : DecidableEq n] [inst_2 : Fintype n]\n  (P : (a : Matrix n n ùïú) ‚Üí Prop) (M : Matrix n n ùïú) (hMdet : Matrix.det M ‚â† 0)\n  (hdiag : ‚àÄ (D : (a : n) ‚Üí ùïú) (a : Matrix.det (Matrix.diagonal D) ‚â† 0), P (Matrix.diagonal D))\n  (htransvec : ‚àÄ (t : Matrix.TransvectionStruct n ùïú), P (Matrix.TransvectionStruct.toMatrix t))\n  (hmul :\n    ‚àÄ (A : Matrix n n ùïú) (B : Matrix n n ùïú) (a : Matrix.det A ‚â† 0) (a : Matrix.det B ‚â† 0) (a : P A) (a : P B),\n      P (Matrix.mul A B)),\n  P M","name":"Matrix.diagonal_transvection_induction_of_det_ne_zero","isProp":true,"docString":"Induction principle for invertible matrices based on transvections: if a property is true for\nall invertible diagonal matrices, all transvections, and is stable under product of invertible\nmatrices, then it is true for all invertible matrices. This is the useful way to say that\ninvertible matrices are generated by invertible diagonal matrices and transvections. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s) {x : E} {y : E} (hx : x ‚àà closure s) (hy : x + y ‚àà interior s) {t : ùïú} (ht : t ‚àà Set.Ioc 0 1),\n  x + t ‚Ä¢ y ‚àà interior s","name":"Convex.add_smul_mem_interior'","isProp":true,"docString":"If `x ‚àà closure s` and `x + y ‚àà interior s`, then `x + t y ‚àà interior s` for `t ‚àà (0, 1]`. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type u_1} {I : Set Œπ} (hI : Set.Finite I) {l : Filter Œ±} {p : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Prop},\n  (Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚àÄ (i : Œπ) (a : i ‚àà I), p i x) l : Prop) ‚Üî\n    (‚àÄ (i : Œπ) (a : i ‚àà I), Filter.Eventually (fun (x : Œ±) ‚Ü¶ p i x) l : Prop)","name":"Set.Finite.eventually_all","isProp":true,"docString":"**Alias** of `Filter.eventually_all_finite`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : (a : Œ±) ‚Üí Œ≤}\n  (self : DenseEmbedding e), Function.Injective e","name":"DenseEmbedding.inj","isProp":true,"docString":"A dense embedding is injective. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {r : Œ±} {s : Finset Œ±},\n  (Finset.toColex s < Finset.toColex {r} : Prop) ‚Üî (‚àÄ (x : Œ±) (a : x ‚àà s), x < r : Prop)","name":"Colex.lt_singleton_iff_mem_lt","isProp":true,"docString":"`s.toColex < {r}.toColex` iff all elements of `s` are less than `r`. "},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : (a : Œ±) ‚Üí Sort v} {r : (x : Œ±) ‚Üí (a : Œ≤ x) ‚Üí Prop} (h : ‚àÄ (x : Œ±), ‚àÉ (y : Œ≤ x), r x y),\n  ‚àÉ (f : (x : Œ±) ‚Üí Œ≤ x), ‚àÄ (x : Œ±), r x (f x)","name":"Classical.axiom_of_choice","isProp":true,"docString":"**Alias** of `Classical.axiomOfChoice`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {S : Set Œ≤} {f : (a : Œ≤) ‚Üí Set Œ±}\n  (ho : ‚àÄ (s : Œ≤) (a : s ‚àà S), IsOpen (f s)) (hS : Set.Countable S) (hd : ‚àÄ (s : Œ≤) (a : s ‚àà S), Dense (f s)),\n  Dense (Set.inter·µ¢ fun (s : Œ≤) ‚Ü¶ Set.inter·µ¢ fun (h : s ‚àà S) ‚Ü¶ f s)","name":"dense_binter·µ¢_of_open","isProp":true,"docString":"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {e' : LocalEquiv Œ± Œ≤} (h : e ‚âà e'),\n  LocalEquiv.source e = LocalEquiv.source e'","name":"LocalEquiv.EqOnSource.source_eq","isProp":true,"docString":"Two equivalent local equivs have the same source "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : ConditionallyCompleteLattice Œ±] {f : (a : Œπ) ‚Üí Œ±} (H : BddAbove (Set.range f))\n  (c : Œπ), f c ‚â§ sup·µ¢ f","name":"le_csup·µ¢","isProp":true,"docString":"The indexed supremum of a function is bounded below by the value taken at one point"},{"type":"‚àÄ {k : Type u_1} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p‚ÇÅ : (a : Œπ) ‚Üí P) (p‚ÇÇ : P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ)) = ‚Üë(Finset.affineCombination k s p‚ÇÅ) w -·µ• p‚ÇÇ","name":"Finset.sum_smul_vsub_const_eq_affineCombination_vsub","isProp":true,"docString":"A weighted sum of pairwise subtractions, where the point on the right is constant and the\nsum of the weights is 1. "},{"type":"‚àÄ {R : Type u} {œÉ : Type u_2} [inst : CommSemiring R] {A : Type u_1} [inst_1 : Semiring A] {f : MvPolynomial œÉ R ‚Üí+* A}\n  {g : MvPolynomial œÉ R ‚Üí+* A} (hC : RingHom.comp f MvPolynomial.C = RingHom.comp g MvPolynomial.C)\n  (hX : ‚àÄ (i : œÉ), ‚Üëf (MvPolynomial.X i) = ‚Üëg (MvPolynomial.X i)), f = g","name":"MvPolynomial.ringHom_ext'","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : MulOneClass Œ±] [inst_1 : MulOneClass Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsMonoidHom f)\n  {Œ≥ : Type u_1} [inst_2 : MulOneClass Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} (hg : IsMonoidHom g), IsMonoidHom (g ‚àò f)","name":"IsMonoidHom.comp","isProp":true,"docString":"The composite of two monoid homomorphisms is a monoid homomorphism. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsInitial X) (f : Y ‚ü∂ X),\n  CategoryTheory.IsSplitEpi f","name":"CategoryTheory.Limits.IsInitial.isSplitEpi_to","isProp":true,"docString":"Any morphism to an initial object is split epi. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≤' : Type u_5} {Œ≥ : Type u_2} {Œ¥ : Type u_1} {m : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {f : Filter Œ±}\n  {g : Filter Œ≤} {n : (a : Œ≥) ‚Üí Œ¥} {m' : (a : Œ≤') ‚Üí (a : Œ±) ‚Üí Œ¥} {n' : (a : Œ≤) ‚Üí Œ≤'}\n  (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), n (m a b) = m' (n' b) a),\n  Filter.map n (Filter.map‚ÇÇ m f g) = Filter.map‚ÇÇ m' (Filter.map n' g) f","name":"Filter.map_map‚ÇÇ_antidistrib_left","isProp":true,"docString":"Symmetric statement to `Filter.map‚ÇÇ_map_left_anticomm`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] {f : M ‚Üí*‚ÇÄ N} {g : M ‚Üí*‚ÇÄ N},\n  (f = g : Prop) ‚Üî (‚àÄ (x : M), ‚Üëf x = ‚Üëg x : Prop)","name":"MonoidWithZeroHom.ext_iff","isProp":true,"docString":"Deprecated: use `FunLike.ext_iff` instead. "},{"type":"‚àÄ {M : Type u_1} {Œ± : Type u_2} [inst : SMul M Œ±] [self : FaithfulSMul M Œ±] {m‚ÇÅ : M} {m‚ÇÇ : M}\n  (a : ‚àÄ (a : Œ±), m‚ÇÅ ‚Ä¢ a = m‚ÇÇ ‚Ä¢ a), m‚ÇÅ = m‚ÇÇ","name":"FaithfulSMul.eq_of_smul_eq_smul","isProp":true,"docString":"Two elements `m‚ÇÅ` and `m‚ÇÇ` are equal whenever they act in the same way on all points. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A - C) * Finset.card B ‚â§ Finset.card (A + B) * Finset.card (B + C)","name":"Finset.card_sub_mul_le_card_add_mul_card_add","isProp":true,"docString":"**Ruzsa's triangle inequality**. Sub-add-add version."},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_2} {N : Type u_1} [inst : AddCommMonoid M] [inst_1 : OrderedAddCommMonoid N]\n  (f : (a : M) ‚Üí N) (h_mul : ‚àÄ (x : M) (y : M), f (x + y) ‚â§ f x + f y) {s : Finset Œπ} (hs : Finset.Nonempty s)\n  (g : (a : Œπ) ‚Üí M), f (Finset.sum s fun (i : Œπ) ‚Ü¶ g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f (g i)","name":"Finset.le_sum_nonempty_of_subadditive","isProp":true,"docString":"If `f : M ‚Üí N` is a subadditive function, `f (x + y) ‚â§ f x + f y` and `g i`, `i ‚àà s`, is a\nnonempty finite family of elements of `M`, then `f (‚àë i in s, g i) ‚â§ ‚àë i in s, f (g i)`. "},{"type":"‚àÄ {R : Type u} [inst : Semigroup R] [inst_1 : StarSemigroup R] {x : R} {y : R} (a : Commute x y),\n  Commute (star x) (star y)","name":"Commute.star_star","isProp":true,"docString":"**Alias** of the reverse direction of `commute_star_star`."},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : AddCommMonoid Œ≤] [inst_1 : AddCommMonoid Œ≥] (g : Œ≤ ‚Üí+ Œ≥)\n  (f : (a : Œ±) ‚Üí Œ≤) (s : Finset Œ±), ‚Üëg (Finset.sum s fun (x : Œ±) ‚Ü¶ f x) = Finset.sum s fun (x : Œ±) ‚Ü¶ ‚Üëg (f x)","name":"AddMonoidHom.map_sum","isProp":true,"docString":"Deprecated: use `_root_.map_sum` instead."},{"type":"‚àÄ {Œ± : Type u} [self : SemilatticeSup Œ±] (a : Œ±) (b : Œ±), a ‚â§ a ‚äî b","name":"SemilatticeSup.le_sup_left","isProp":true,"docString":"The supremum is an upper bound on the first argument "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±}, Metric.hausdorffDist s t = Metric.hausdorffDist t s","name":"Metric.hausdorffDist_comm","isProp":true,"docString":"The Hausdorff distance from `s` to `t` and from `t` to `s` coincide "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : AddGroup Œ±]\n  [inst_1 : OrderedAddCommMonoid Œ≤] [self : AddGroupSeminormClass F Œ± Œ≤] (f : F) (a : Œ±), ‚Üëf (-a) = ‚Üëf a","name":"AddGroupSeminormClass.map_neg_eq_map","isProp":true,"docString":"The map is invariant under negation of its argument. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} (a : l <+: []), l = []","name":"List.eq_nil_of_prefix_nil","isProp":true,"docString":"**Alias** of the forward direction of `List.prefix_nil_iff`."},{"type":"‚àÄ (R : Type u) (œÉ : Type v) [inst : CommSemiring R] [inst_1 : Finite œÉ] [inst_2 : NoZeroDivisors R],\n  NoZeroDivisors (MvPolynomial œÉ R)","name":"MvPolynomial.noZeroDivisors_of_finite","isProp":true,"docString":"Auxiliary definition:\nMultivariate polynomials in finitely many variables over an integral domain form an integral domain.\nThis fact is proven by transport of structure from the `MvPolynomial.noZeroDivisors_fin`,\nand then used to prove the general case without finiteness hypotheses.\nSee `MvPolynomial.noZeroDivisors` for the general case. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {Œ± : Type u_2} {Œ≤ : Type u_3} [inst_1 : SMul Œ± Œ≤] [inst_2 : MulAction G Œ±]\n  [inst_3 : MulAction G Œ≤] [inst_4 : IsScalarTower G Œ± Œ≤] (S : Subgroup G), IsScalarTower { x : G // x ‚àà S } Œ± Œ≤","name":"Subgroup.instIsScalarTowerSubtypeMemSubgroupInstMembershipInstSetLikeSubgroupSmulToMulOneClassToMonoidToDivInvMonoidToSMulToSubmonoidSmulToSMul","isProp":true,"docString":"Note that this provides `IsScalarTower S G G` which is needed by `smul_mul_assoc`. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : MulPosMono Œ±] (ha : 0 ‚â§ a)\n  (hb : 0 ‚â§ b), 0 ‚â§ a * b","name":"Right.mul_nonneg","isProp":true,"docString":"Assumes right covariance. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (I : Ideal (R √ó S)),\n  (Ideal.IsPrime I : Prop) ‚Üî\n    ((‚àÉ (p : Ideal R), (Ideal.IsPrime p : Prop) ‚àß (I = Ideal.prod p ‚ä§ : Prop) : Prop) ‚à®\n        (‚àÉ (p : Ideal S), (Ideal.IsPrime p : Prop) ‚àß (I = Ideal.prod ‚ä§ p : Prop) : Prop) :\n      Prop)","name":"Ideal.ideal_prod_prime","isProp":true,"docString":"Classification of prime ideals in product rings: the prime ideals of `R √ó S` are precisely the\nideals of the form `p √ó S` or `R √ó p`, where `p` is a prime ideal of `R` or `S`. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {A : CategoryTheory.Limits.Cocone F} {B : CategoryTheory.Limits.Cocone F}\n  (self : CategoryTheory.Limits.CoconeMorphism A B) (j : J),\n  (CategoryTheory.Limits.Cocone.Œπ A).app j ‚â´ CategoryTheory.Limits.CoconeMorphism.Hom self =\n    (CategoryTheory.Limits.Cocone.Œπ B).app j","name":"CategoryTheory.Limits.CoconeMorphism.w","isProp":true,"docString":"The triangle made from the two natural transformations and `Hom` commutes "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : CompleteLattice Œ±] {t : (a : Œπ) ‚Üí Œ±} (ht : CompleteLattice.Independent t),\n  Pairwise (Disjoint on t)","name":"CompleteLattice.Independent.pairwiseDisjoint","isProp":true,"docString":"If the elements of a set are independent, then any pair within that set is disjoint. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f x (‚Üëf y)), Equiv.Perm.SameCycle f x y","name":"Equiv.Perm.SameCycle.of_apply_right","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.sameCycle_apply_right`."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommMonoid M] [inst_2 : Nontrivial R] {m : M}\n  {S : Set M} (h : AddMonoidAlgebra.of' R M m ‚àà Submodule.span R ‚Üë(Submonoid.closure (AddMonoidAlgebra.of' R M '' S))),\n  m ‚àà AddSubmonoid.closure S","name":"AddMonoidAlgebra.mem_closure_of_mem_span_closure","isProp":true,"docString":"If the image of an element `m : M` in `AddMonoidAlgebra R M` belongs the submodule generated by\nthe closure of some `S : Set M` then `m ‚àà closure S`. "},{"type":"‚àÄ {G : Type u} [self : CommSemigroup G] (a : G) (b : G), a * b = b * a","name":"CommSemigroup.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (self : GroupSeminorm G), GroupSeminorm.toFun self 1 = 0","name":"GroupSeminorm.map_one'","isProp":true,"docString":"The image of one is zero. "},{"type":"‚àÄ {Œ± : Type u} [self : SemilatticeSup Œ±] (a : Œ±) (b : Œ±), b ‚â§ a ‚äî b","name":"SemilatticeSup.le_sup_right","isProp":true,"docString":"The supremum is an upper bound on the second argument "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsInitial X) (f : Y ‚ü∂ X),\n  CategoryTheory.Epi f","name":"CategoryTheory.Limits.IsInitial.epi_to","isProp":true,"docString":"Any morphism to an initial object is epi. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M),\n  (S = ‚ä• : Prop) ‚à® (‚àÉ (x : M), (x ‚àà S : Prop) ‚àß (x ‚â† 0 : Prop) : Prop)","name":"AddSubmonoid.bot_or_exists_ne_zero","isProp":true,"docString":"An additive submonoid is either the trivial additive submonoid or contains a nonzero\nelement."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Semiring Œ±] [inst_1 : Semiring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsSemiringHom f),\n  f 0 = 0","name":"IsSemiringHom.map_zero","isProp":true,"docString":"The proposition that `f` preserves the additive identity. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x : X) (y : X), Joined x y","name":"PathConnectedSpace.Joined","isProp":true,"docString":"Any two points in a path-connected space must be joined by a continuous path. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] (u : M‚ÇÄÀ£), Ring.inverse ‚Üëu = ‚Üëu‚Åª¬π","name":"Ring.inverse_unit","isProp":true,"docString":"By definition, if `x` is invertible then `inverse x = x‚Åª¬π`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {s : Set Œ±} (a : MeasurableSet s),\n  Filter.IsMeasurablyGenerated (Filter.principal s)","name":"MeasurableSet.principal_isMeasurablyGenerated","isProp":true,"docString":"**Alias** of the reverse direction of `Filter.principal_isMeasurablyGenerated_iff`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤},\n  (Isometry f : Prop) ‚Üî (‚àÄ (x : Œ±) (y : Œ±), dist (f x) (f y) = dist x y : Prop)","name":"isometry_iff_dist_eq","isProp":true,"docString":"On pseudometric spaces, a map is an isometry if and only if it preserves distances. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú} (hf : ConvexOn ùïú s f) {x : ùïú} {y : ùïú}\n  {z : ùïú} (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z), (f y - f x) / (y - x) ‚â§ (f z - f y) / (z - y)","name":"ConvexOn.slope_mono_adjacent","isProp":true,"docString":"If `f : ùïú ‚Üí ùïú` is convex, then for any three points `x < y < z` the slope of the secant line of\n`f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}, IsMaxChain r (maxChain r)","name":"maxChain_spec","isProp":true,"docString":"**Hausdorff's maximality principle**\n\nThere exists a maximal totally ordered set of `Œ±`.\nNote that we do not require `Œ±` to be partially ordered by `r`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C], CategoryTheory.Limits.HasEqualizers C","name":"CategoryTheory.NormalMonoCategory.hasEqualizers","isProp":true,"docString":"A `NormalMonoCategory` category with finite products and kernels has all equalizers. "},{"type":"‚àÄ {Œ± : Sort u} [self : Subsingleton Œ±] (a : Œ±) (b : Œ±), a = b","name":"Subsingleton.allEq","isProp":true,"docString":"Any two elements of a subsingleton are equal. "},{"type":"‚àÄ {R : Type u_1} [inst : NonAssocRing R] (self : MulRingSeminorm R) (x : R) (y : R),\n  AddGroupSeminorm.toFun (MulRingSeminorm.toAddGroupSeminorm self) (x * y) =\n    AddGroupSeminorm.toFun (MulRingSeminorm.toAddGroupSeminorm self) x *\n      AddGroupSeminorm.toFun (MulRingSeminorm.toAddGroupSeminorm self) y","name":"MulRingSeminorm.map_mul'","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ (M : Type u_1) (Œ± : Type u_2) [inst : Monoid M] [inst_1 : MulAction M Œ±] {P : Submonoid M} {Q : Submonoid M},\n  MulAction.fixedPoints { x : M // x ‚àà P ‚äî Q } Œ± =\n    MulAction.fixedPoints { x : M // x ‚àà P } Œ± ‚à© MulAction.fixedPoints { x : M // x ‚àà Q } Œ±","name":"fixedPoints_submonoid_sup","isProp":true,"docString":"Fixed points of sup of submonoids is intersection "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFilteredOrEmpty C] {j‚ÇÅ : C} {j‚ÇÇ : C}\n  {k‚ÇÅ : C} {k‚ÇÇ : C} (f‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÅ) (g‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÇ) (f‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÅ) (g‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÇ),\n  ‚àÉ (s : C), ‚àÉ (Œ± : k‚ÇÅ ‚ü∂ s), ‚àÉ (Œ≤ : k‚ÇÇ ‚ü∂ s), (f‚ÇÅ ‚â´ Œ± = g‚ÇÅ ‚â´ Œ≤ : Prop) ‚àß (f‚ÇÇ ‚â´ Œ± = g‚ÇÇ ‚â´ Œ≤ : Prop)","name":"CategoryTheory.IsFiltered.bowtie","isProp":true,"docString":"Given a \"bowtie\" of morphisms\n```\n j‚ÇÅ   j‚ÇÇ\n |\\  /|\n | \\/ |\n | /\\ |\n |/  \\‚à£\n vv  vv\n k‚ÇÅ  k‚ÇÇ\n```\nin a filtered category, we can construct an object `s` and two morphisms from `k‚ÇÅ` and `k‚ÇÇ` to `s`,\nmaking the resulting squares commute.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  [inst_2 : LocallyCompactSpace Œ±] [inst_3 : CompactSpace Œ≤] [inst_4 : UniformSpace Œ≥] {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥}\n  {x : Œ±} {U : Set Œ±} (hxU : U ‚àà nhds x) (h : ContinuousOn (‚Üøf) (U √óÀ¢ Set.univ)), TendstoUniformly f (f x) (nhds x)","name":"ContinuousOn.tendstoUniformly","isProp":true,"docString":"A family of functions `Œ± ‚Üí Œ≤ ‚Üí Œ≥` tends uniformly to its value at `x` if `Œ±` is locally compact,\n`Œ≤` is compact and `f` is continuous on `U √ó (univ : Set Œ≤)` for some neighborhood `U` of `x`. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsPreconnected J] (Z : (a : J) ‚Üí Sort u_1)\n  (h‚ÇÅ : {j‚ÇÅ : J} ‚Üí {j‚ÇÇ : J} ‚Üí (x : j‚ÇÅ ‚ü∂ j‚ÇÇ) ‚Üí (a : Z j‚ÇÅ) ‚Üí Z j‚ÇÇ)\n  (h‚ÇÇ : {j‚ÇÅ : J} ‚Üí {j‚ÇÇ : J} ‚Üí (x : j‚ÇÅ ‚ü∂ j‚ÇÇ) ‚Üí (a : Z j‚ÇÇ) ‚Üí Z j‚ÇÅ) {j‚ÇÄ : J} (x : Z j‚ÇÄ) (j : J), Nonempty (Z j)","name":"CategoryTheory.isPreconnected_induction","isProp":true,"docString":"Another induction principle for `IsPreconnected J`:\ngiven a type family `Z : J ‚Üí Sort*` and\na rule for transporting in *both* directions along a morphism in `J`,\nwe can transport an `x : Z j‚ÇÄ` to a point in `Z j` for any `j`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {r‚ÇÅ : Setoid Œ±} {r‚ÇÇ : Setoid Œ±}, (r‚ÇÅ = r‚ÇÇ : Prop) ‚Üî (Setoid.Rel r‚ÇÅ = Setoid.Rel r‚ÇÇ : Prop)","name":"Setoid.eq_iff_rel_eq","isProp":true,"docString":"Two equivalence relations are equal iff their underlying binary operations are equal. "},{"type":"‚àÄ {x : SimplexCategory} {y : SimplexCategory} {f : x ‚ü∂ y} (a : CategoryTheory.Mono f),\n  SimplexCategory.len x ‚â§ SimplexCategory.len y","name":"SimplexCategory.len_le_of_mono","isProp":true,"docString":"A monomorphism in `SimplexCategory` must increase lengths"},{"type":"‚àÄ {X : Type u_1} {Œ± : Type u_2} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {A : Set ((a : X) ‚Üí Œ±)} {x‚ÇÄ : X}\n  (hA : Set.EquicontinuousAt A x‚ÇÄ), Set.EquicontinuousAt (closure A) x‚ÇÄ","name":"EquicontinuousAt.closure","isProp":true,"docString":"If a set of functions is equicontinuous at some `x‚ÇÄ`, its closure for the product topology is\nalso equicontinuous at `x‚ÇÄ`. "},{"type":"‚àÄ {H : Type u} [inst : TopologicalSpace H] (G : StructureGroupoid H) {f : LocalHomeomorph H H} (hf : f ‚àà G),\n  f ‚àà StructureGroupoid.maximalAtlas H G","name":"StructureGroupoid.mem_maximalAtlas_of_mem_groupoid","isProp":true,"docString":"In the model space, any element of the groupoid is in the maximal atlas. "},{"type":"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)} (H : ‚àÄ (a : Œ±), ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà c), a ‚àà b) {s : Set Œ±} {y : Œ±}\n  (hs : s ‚àà c) (hy : y ‚àà s), s = setOf fun (x : Œ±) ‚Ü¶ Setoid.Rel (Setoid.mkClasses c H) x y","name":"Setoid.eq_eqv_class_of_mem","isProp":true,"docString":"The elements of a set of sets partitioning Œ± are the equivalence classes of the\nequivalence relation defined by the set of sets. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (a_1 : b < a), 0 < a - b","name":"sub_pos_of_lt","isProp":true,"docString":"**Alias** of the reverse direction of `sub_pos`."},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {L‚ÇÅ : C ‚•§ D}\n  {L‚ÇÇ : C ‚•§ D} {R‚ÇÅ : D ‚•§ C} {R‚ÇÇ : D ‚•§ C} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (f : R‚ÇÅ ‚ü∂ R‚ÇÇ)\n  [inst_2 : CategoryTheory.IsIso f],\n  CategoryTheory.IsIso (‚Üë(Equiv.symm (CategoryTheory.transferNatTransSelf adj‚ÇÅ adj‚ÇÇ)) f)","name":"CategoryTheory.transferNatTransSelf_symm_iso","isProp":true,"docString":"If `f` is an isomorphism, then the un-transferred natural transformation is an isomorphism.\nThe converse is given in `transferNatTransSelf_symm_of_iso`.\n"},{"type":"‚àÄ (n : ‚Ñï), List.Nodup (List.Nat.antidiagonal n)","name":"List.Nat.nodup_antidiagonal","isProp":true,"docString":"The antidiagonal of `n` does not contain duplicate entries. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {D : Type u‚ÇÑ}\n  [inst_2 : CategoryTheory.Category D] (F : C ‚•§ D) [inst_3 : CategoryTheory.ReflectsIsomorphisms F] (K : J ‚•§ C),\n  CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Limits.Cones.functoriality K F)","name":"CategoryTheory.Limits.Cones.reflects_cone_isomorphism","isProp":true,"docString":"If `F` reflects isomorphisms, then `Cones.functoriality F` reflects isomorphisms\nas well.\n"},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí Preorder (œÄ i)] {a : (i : Œπ) ‚Üí œÄ i} {b : (i : Œπ) ‚Üí œÄ i}\n  (h : StrongLT a b), a ‚â§ b","name":"StrongLT.le","isProp":true,"docString":"**Alias** of `le_of_strongLT`."},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (b : Basis Œπ R M) {x : M} {y : M},\n  (x = y : Prop) ‚Üî (‚àÄ (i : Œπ), ‚Üë(‚Üë(Basis.repr b) x) i = ‚Üë(‚Üë(Basis.repr b) y) i : Prop)","name":"Basis.ext_elem_iff","isProp":true,"docString":"Two elements are equal iff their coordinates are equal. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G} {x : G} {c : G} (a : x ‚àà Group.conjugatesOfSet s),\n  c * x * c‚Åª¬π ‚àà Group.conjugatesOfSet s","name":"Group.conj_mem_conjugatesOfSet","isProp":true,"docString":"The set of conjugates of `s` is closed under conjugation. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : Set P), s ‚äÜ ‚Üë(affineSpan k s)","name":"subset_affineSpan","isProp":true,"docString":"A set is contained in its affine span. "},{"type":"‚àÄ (ùïú : Type u_2) (Œ± : Type u_1) (E : Type u_3) [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : UniformSpace E] [inst_4 : UniformAddGroup E] [inst_5 : ContinuousSMul ùïú E] {ùîñ : Set (Set Œ±)}\n  (hùîñ‚ÇÅ : Set.Nonempty ùîñ) (hùîñ‚ÇÇ : DirectedOn (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äÜ x_1) ùîñ)\n  (H : Submodule ùïú (UniformOnFun Œ± E ùîñ))\n  (h : ‚àÄ (u : UniformOnFun Œ± E ùîñ) (a : u ‚àà H) (s : Set Œ±) (a : s ‚àà ùîñ), Bornology.IsVonNBounded ùïú (u '' s)),\n  ContinuousSMul ùïú { x : UniformOnFun Œ± E ùîñ // x ‚àà H }","name":"UniformOnFun.continuousSMul_submodule_of_image_bounded","isProp":true,"docString":"Let `E` be a TVS, `ùîñ : Set (Set Œ±)` and `H` a submodule of `Œ± ‚Üí·µ§[ùîñ] E`. If the image of any\n`S ‚àà ùîñ` by any `u ‚àà H` is bounded (in the sense of `Bornology.IsVonNBounded`), then `H`,\nequipped with the topology of `ùîñ`-convergence, is a TVS.\n\nIf you have a hard time using this lemma, try the one above instead. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {Œ∫ : Type u_3} {C : (a : (a : Œπ) ‚Üí Option Œ±) ‚Üí Œ∫}\n  (self : Combinatorics.Line.AlmostMono C) (x : Œ±),\n  C\n      ((fun (x : Option Œ±) (i : Œπ) ‚Ü¶\n          Option.getD (Combinatorics.Line.idxFun (Combinatorics.Line.AlmostMono.line self) i) x)\n        (some x)) =\n    Combinatorics.Line.AlmostMono.color self","name":"Combinatorics.Line.AlmostMono.has_color","isProp":true,"docString":"The proposition that the underlying line of an almost monochromatic line assumes its main\ncolor except possibly at the endpoints. "},{"type":"‚àÄ {Œπ : Type u_1} {I : BoxIntegral.Box Œπ} {J : BoxIntegral.Box Œπ} (œÄ : BoxIntegral.Prepartition I)\n  {œÄi : (J : BoxIntegral.Box Œπ) ‚Üí BoxIntegral.Prepartition J} (hJ : J ‚àà œÄ) {J' : BoxIntegral.Box Œπ} (hJ' : J' ‚àà œÄi J),\n  BoxIntegral.Prepartition.bunion·µ¢Index œÄ œÄi J' = J","name":"BoxIntegral.Prepartition.bunion·µ¢Index_of_mem","isProp":true,"docString":"Uniqueness property of `BoxIntegral.Prepartition.bunion·µ¢Index`. "},{"type":"‚àÄ {Œ± : Type u_2} {R : Type u_1} {l : Filter Œ±} {f : (a : Œ±) ‚Üí R} {r : R} [inst : LinearOrderedRing R]\n  [inst_1 : Archimedean R] (hr : 0 < r) (hf : Filter.Tendsto f l Filter.atBot),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * r) l Filter.atBot","name":"Filter.Tendsto.atBot_mul_const'","isProp":true,"docString":"See also `Filter.Tendsto.atBot_mul_const` for a version of this lemma for\n`LinearOrderedField`s which does not require the `Archimedean` assumption. "},{"type":"‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : Semiring A] [inst_3 : StarRing A]\n  [inst_4 : Algebra R A] [inst_5 : StarModule R A] (self : StarSubalgebra R A) {a : A}\n  (a_1 :\n    a ‚àà\n      Subsemigroup.carrier\n        (Submonoid.toSubsemigroup\n          (Subsemiring.toSubmonoid (Subalgebra.toSubsemiring (StarSubalgebra.toSubalgebra self))))),\n  star a ‚àà\n    Subsemigroup.carrier\n      (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid (Subalgebra.toSubsemiring (StarSubalgebra.toSubalgebra self))))","name":"StarSubalgebra.star_mem'","isProp":true,"docString":"The `carrier` is closed under the `star` operation. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : CompleteLattice Œ±] (a : CompleteLattice.IsSupClosedCompact Œ±),\n  CompleteLattice.IsSupFiniteCompact Œ±","name":"CompleteLattice.IsSupClosedCompact.isSupFiniteCompact","isProp":true,"docString":"**Alias** of the reverse direction of `CompleteLattice.isSupFiniteCompact_iff_isSupClosedCompact`."},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Equiv L M N) {n : ‚Ñï}\n  (f : FirstOrder.Language.Functions L n) (x : (a : Fin n) ‚Üí M),\n  Equiv.toFun (FirstOrder.Language.Equiv.toEquiv self) (FirstOrder.Language.Structure.funMap f x) =\n    FirstOrder.Language.Structure.funMap f (Equiv.toFun (FirstOrder.Language.Equiv.toEquiv self) ‚àò x)","name":"FirstOrder.Language.Equiv.map_fun'","isProp":true,"docString":"The homomorphism commutes with the interpretations of the function symbols "},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Equiv L M N) {n : ‚Ñï}\n  (r : FirstOrder.Language.Relations L n) (x : (a : Fin n) ‚Üí M),\n  (FirstOrder.Language.Structure.rel_map r (Equiv.toFun (FirstOrder.Language.Equiv.toEquiv self) ‚àò x) : Prop) ‚Üî\n    (FirstOrder.Language.Structure.rel_map r x : Prop)","name":"FirstOrder.Language.Equiv.map_rel'","isProp":true,"docString":"The homomorphism sends related elements to related elements "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] {p : Polynomial R} (p0 : p ‚â† 0) {a : R} {n : ‚Ñï},\n  (n ‚â§ Polynomial.rootMultiplicity a p : Prop) ‚Üî ((Polynomial.X - ‚ÜëPolynomial.C a) ^ n ‚à£ p : Prop)","name":"Polynomial.le_rootMultiplicity_iff","isProp":true,"docString":"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonUnitalNormedRing Œ±] (a : Œ±) (b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ","name":"NonUnitalNormedRing.norm_mul","isProp":true,"docString":"The norm is submultiplicative. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedSemiring Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"LinearOrderedSemiring.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ (R : Type u) (M : Type v) (N : Type w) [inst : CommRing R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : AddCommGroup N] [inst_6 : Module R N]\n  [inst_7 : Module.Free R N],\n  Module.rank R (TensorProduct R M N) = Cardinal.lift (Module.rank R M) * Cardinal.lift (Module.rank R N)","name":"rank_tensorProduct","isProp":true,"docString":"The rank of `M ‚äó[R] N` is `(Module.rank R M).lift * (Module.rank R N).lift`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf' : DenseRange f) (hf : Continuous f) {s : Set Œ±} (hs : Dense s), Dense (f '' s)","name":"DenseRange.dense_image","isProp":true,"docString":"The image of a dense set under a continuous map with dense range is a dense set. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {f : (a : Œπ) ‚Üí Set X} (hf : LocallyFinite f)\n  (hc : ‚àÄ (i : Œπ), IsClosed (f i)) (x : X),\n  (Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (_hi : ¬¨(x ‚àà f i : Prop)) ‚Ü¶ f i·∂ú) ‚àà nhds x","name":"LocallyFinite.inter·µ¢_compl_mem_nhds","isProp":true,"docString":"If `f : Œ≤ ‚Üí set Œ±` is a locally finite family of closed sets, then for any `x : Œ±`, the\nintersection of the complements to `f i`, `x ‚àâ f i`, is a neighbourhood of `x`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasFiniteWidePushouts C] (J : Type)\n  [inst_1 : Fintype J], CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Limits.WidePushoutShape J) C","name":"CategoryTheory.Limits.HasFiniteWidePushouts.out","isProp":true,"docString":"`C` has all wide pushouts any Fintype `J`"},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} {K : AddSubgroup G}\n  (h : ‚àÄ (x : G), (x ‚àà H : Prop) ‚Üî (x ‚àà K : Prop)), H = K","name":"AddSubgroup.ext","isProp":true,"docString":"Two `AddSubgroup`s are equal if they have the same elements."},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (hab : a ‚â§ b), (a = b : Prop) ‚à® (a < b : Prop)","name":"LE.le.eq_or_lt_dec","isProp":true,"docString":"**Alias** of `Decidable.eq_or_lt_of_le`."},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ), a * a‚Åª¬π * a = a","name":"mul_inv_mul_self","isProp":true,"docString":"Multiplying `a` by its inverse and then by itself results in `a`\n(whether or not `a` is zero). "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] (x : E)\n  (y : E) {z : E} (hz : z ‚àà Set.range ‚Üë(AffineMap.lineMap x y)),\n  openSegment ùïú x y ‚äÜ insert z (openSegment ùïú x z ‚à™ openSegment ùïú z y)","name":"openSegment_subset_union","isProp":true,"docString":"If `z = lineMap x y c` is a point on the line passing through `x` and `y`, then the open\nsegment `openSegment ùïú x y` is included in the union of the open segments `openSegment ùïú x z`,\n`openSegment ùïú z y`, and the point `z`. Informally, `(x, y) ‚äÜ {z} ‚à™ (x, z) ‚à™ (z, y)`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïú E] {p : (a : Œπ) ‚Üí E},\n  (ConvexIndependent ùïú p : Prop) ‚Üî\n    (‚àÄ (i : Œπ) (s : Set Œπ), ¬¨(p i ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) (p '' (s \\ {i})) : Prop) : Prop)","name":"convexIndependent_iff_not_mem_convexHull_diff","isProp":true,"docString":"If a family is convex independent, a point in the family is not in the convex hull of the other\npoints. See `convexIndependent_set_iff_not_mem_convexHull_diff` for the `Set` version. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {s : Set Œ≤} (hs : IsCompact s) (ne_s : Set.Nonempty s)\n  {f : (a : Œ≤) ‚Üí Œ±} (hf : ContinuousOn f s), ‚àÉ (x : Œ≤), (x ‚àà s : Prop) ‚àß (‚àÄ (y : Œ≤) (a : y ‚àà s), f x ‚â§ f y : Prop)","name":"IsCompact.exists_forall_le","isProp":true,"docString":"The **extreme value theorem**: a continuous function realizes its minimum on a compact set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemiring Œ±], Subsingleton (FloorSemiring Œ±)","name":"subsingleton_floorSemiring","isProp":true,"docString":"There exists at most one `FloorSemiring` structure on a linear ordered semiring. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (I : Ideal (R √ó S)),\n  I = Ideal.prod (Ideal.map (RingHom.fst R S) I) (Ideal.map (RingHom.snd R S) I)","name":"Ideal.ideal_prod_eq","isProp":true,"docString":"Every ideal of the product ring is of the form `I √ó J`, where `I` and `J` can be explicitly\ngiven as the image under the projection maps. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {u' : Œ±}\n  {s : Set Œ±} (hu' : a < u'),\n  (s ‚àà nhdsWithin a (Set.Ici a) : Prop) ‚Üî (‚àÉ (u : Œ±), (u ‚àà Set.Ioi a : Prop) ‚àß (Set.Ico a u ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Ici_iff_exists_Ico_subset'","isProp":true,"docString":"A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`\nwith `a < u < u'`, provided `a` is not a top element. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} {c : Œ±} [inst : Mul Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±]\n  [inst_3 : MulPosReflectLT Œ±] (h : b * a < c * a) (a0 : 0 ‚â§ a), b < c","name":"lt_of_mul_lt_mul_of_nonneg_right","isProp":true,"docString":"**Alias** of `lt_of_mul_lt_mul_right`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} [inst : CommMonoid Œ±] {g : (a : Œ≥) ‚Üí Œ≤} (hg : Function.Injective g)\n  {f : (a : Œ≤) ‚Üí Œ±} (hf : ‚àÄ (x : Œ≤) (a : ¬¨(x ‚àà Set.range g : Prop)), f x = 1),\n  Filter.map (fun (s : Finset Œ≥) ‚Ü¶ Finset.prod s fun (i : Œ≥) ‚Ü¶ f (g i)) Filter.atTop =\n    Filter.map (fun (s : Finset Œ≤) ‚Ü¶ Finset.prod s fun (i : Œ≤) ‚Ü¶ f i) Filter.atTop","name":"Function.Injective.map_atTop_finset_prod_eq","isProp":true,"docString":"Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`\nto a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters\n`atTop.map (Œª s, ‚àè i in s, f (g i))` and `atTop.map (Œª s, ‚àè i in s, f i)` coincide.\n\nThe additive version of this lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under\nthe same assumptions."},{"type":"‚àÄ {Œ± : Type u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [self : IsWellFounded Œ± r], WellFounded r","name":"IsWellFounded.wf","isProp":true,"docString":"The relation is `WellFounded`, as a proposition. "},{"type":"‚àÄ {Œ± : Type u_1} (f : (a : Œ±) ‚Üí Œ±) (x : Œ±),\n  Function.periodicOrbit f x = Cycle.map (fun (n : ‚Ñï) ‚Ü¶ (f^[n]) x) ‚Üë(List.range (Function.minimalPeriod f x))","name":"Function.periodicOrbit_eq_cycle_map","isProp":true,"docString":"The definition of a periodic orbit, in terms of `Cycle.map`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±} {t : Set Œ±} (h : BddBelow s), BddBelow (s ‚à© t)","name":"BddBelow.inter_of_left","isProp":true,"docString":"If `s` is bounded, then so is `s ‚à© t` "},{"type":"‚àÄ {b : ‚Ñï} {l : List ‚Ñï} (hb : 1 < b) (hl : ‚àÄ (x : ‚Ñï) (a : x ‚àà l), x < b), Nat.ofDigits b l < b ^ List.length l","name":"Nat.ofDigits_lt_base_pow_length","isProp":true,"docString":"an n-digit number in base b is less than b^n if b > 1 "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x : X} {y : X} (a : x ‚§≥ y), nhds x ‚â§ nhds y","name":"Specializes.nhds_le_nhds","isProp":true,"docString":"**Alias** of the forward direction of `specializes_iff_nhds`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : 1 ‚â§ a) (hb : 1 ‚â§ b), 1 ‚â§ a * b","name":"Right.one_le_mul","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_le_mul`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤}\n  (a : LocalEquiv.source e ‚à© LocalEquiv.toFun e ‚Åª¬π' t = LocalEquiv.source e ‚à© s), LocalEquiv.IsImage e s t","name":"LocalEquiv.IsImage.of_preimage_eq","isProp":true,"docString":"**Alias** of the reverse direction of `LocalEquiv.IsImage.iff_preimage_eq`."},{"type":"‚àÄ {Œ± : Type u_1} [self : Semifield Œ±] (n : ‚Ñï) (a : Œ±),\n  Semifield.zpow (Int.ofNat (Nat.succ n)) a = a * Semifield.zpow (Int.ofNat n) a","name":"Semifield.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ (Œ± : Type u) (Œ≤ : Type v) [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] [inst_2 : Fintype Œ±] [inst_3 : Fintype Œ≤]\n  [inst_4 : Fintype (Quotient (AddAction.orbitRel Œ± Œ≤))]\n  [inst_5 : (b : Œ≤) ‚Üí Fintype { x : Œ± // x ‚àà AddAction.stabilizer Œ± b }]\n  {œÜ : (a : Quotient (AddAction.orbitRel Œ± Œ≤)) ‚Üí Œ≤} (hœÜ : Function.LeftInverse Quotient.mk'' œÜ),\n  Fintype.card Œ≤ =\n    Finset.sum Finset.univ fun (œâ : Quotient (AddAction.orbitRel Œ± Œ≤)) ‚Ü¶\n      Fintype.card Œ± / Fintype.card { x : Œ± // x ‚àà AddAction.stabilizer Œ± (œÜ œâ) }","name":"AddAction.card_eq_sum_card_addGroup_sub_card_stabilizer'","isProp":true,"docString":"**Class formula** for a finite group acting on a finite type. See\n`AddAction.card_eq_sum_card_addGroup_div_card_stabilizer` for a specialized version using\n`Quotient.out'`."},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±]\n  (H : FreeAddGroup.mk L‚ÇÅ = FreeAddGroup.mk L‚ÇÇ), FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ","name":"FreeAddGroup.reduce.sound","isProp":true,"docString":"If two words correspond to the same element in the additive free group, then they\nhave a common maximal reduction. This is the proof that the function that sends an element of the\nfree group to its maximal reduction is well-defined."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f : (a : Œ±) ‚Üí E}\n  {l : Filter Œ±} {c : Œ±} (h : IsMaxFilter (norm ‚àò f) l c), IsMaxFilter (fun (x : Œ±) ‚Ü¶ ‚Äñf x + f c‚Äñ) l c","name":"IsMaxFilter.norm_add_self","isProp":true,"docString":"If `f : Œ± ‚Üí E` is a function such that `norm ‚àò f` has a maximum along a filter `l` at a point\n`c`, then the function `fun x => ‚Äñf x + f c‚Äñ` has a maximum along `l` at `c`. "},{"type":"‚àÄ {K : Type u_1} {V : Type u} {V' : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V]\n  [inst_2 : AddCommGroup V'] [inst_3 : Module K V] [inst_4 : Module K V'] {p : Submodule K V}\n  (f : { x : V // x ‚àà p } ‚Üí‚Çó[K] V'), ‚àÉ (g : V ‚Üí‚Çó[K] V'), LinearMap.comp g (Submodule.subtype p) = f","name":"LinearMap.exists_extend","isProp":true,"docString":"Any linear map `f : p ‚Üí‚Çó[K] V'` defined on a subspace `p` can be extended to the whole\nspace. "},{"type":"‚àÄ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [inst : Ring k]\n  [inst_1 : AddCommGroup V1] [inst_2 : Module k V1] [inst_3 : AddTorsor V1 P1] [inst_4 : AddCommGroup V2]\n  [inst_5 : Module k V2] [inst_6 : AddTorsor V2 P2] (f : P1 ‚Üí·µÉ[k] P2) (p : P1) (v : V1),\n  ‚Üëf (v +·µ• p) = ‚Üë(AffineMap.linear f) v +·µ• ‚Üëf p","name":"AffineMap.map_vadd","isProp":true,"docString":"An affine map on the result of adding a vector to a point produces\nthe same result as the linear map applied to that vector, added to the\naffine map applied to that point. "},{"type":"‚àÄ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : MonoidHomClass F G H]\n  (f : F), (Function.Injective ‚Üëf : Prop) ‚Üî (‚àÄ (a : G), (‚Üëf a = 1 : Prop) ‚Üî (a = 1 : Prop) : Prop)","name":"injective_iff_map_eq_one'","isProp":true,"docString":"A homomorphism from a group to a monoid is injective iff its kernel is trivial,\nstated as an iff on the triviality of the kernel.\nFor the implication, see `injective_iff_map_eq_one`. "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {Œ¥ : Type u_1} [inst_4 : LinearOrder Œ¥] [inst_5 : TopologicalSpace Œ¥]\n  [inst_6 : OrderClosedTopology Œ¥] {f : (a : Œ±) ‚Üí Œ¥} {s : Set Œ±} [inst_7 : Set.OrdConnected s] (hs : Set.Nonempty s)\n  (hf : ContinuousOn f s) (hbot : Filter.Tendsto (fun (x : ‚Üës) ‚Ü¶ f ‚Üëx) Filter.atBot Filter.atTop)\n  (htop : Filter.Tendsto (fun (x : ‚Üës) ‚Ü¶ f ‚Üëx) Filter.atTop Filter.atBot), Set.SurjOn f s Set.univ","name":"ContinuousOn.surjOn_of_tendsto'","isProp":true,"docString":"If a function `f : Œ± ‚Üí Œ≤` is continuous on a nonempty interval `s`, its restriction to `s`\ntends to `Filter.atTop : Filter Œ≤` along `Filter.atBot : Filter ‚Ü•s` and tends to\n`Filter.atBot : Filter Œ≤` along `Filter.atTop : Filter ‚Ü•s`, then the restriction of `f` to `s` is\nsurjective. We formulate the conclusion as `Function.surjOn f s Set.univ`. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r‚ÇÅ : R) (r‚ÇÇ : R)\n  (s‚ÇÅ : { x : R // x ‚àà S }) (s‚ÇÇ : { x : R // x ‚àà S }) (r' : R) (s' : { x : R // x ‚àà S }) (huv : r‚ÇÇ * ‚Üës' = ‚Üës‚ÇÅ * r'),\n  r‚ÇÅ /‚Çí s‚ÇÅ * (r‚ÇÇ /‚Çí s‚ÇÇ) = r‚ÇÅ * r' /‚Çí (s‚ÇÇ * s')","name":"OreLocalization.oreDiv_mul_char","isProp":true,"docString":"A characterization lemma for the multiplication on the Ore localization, allowing for a choice\nof Ore numerator and Ore denominator. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} (R : CategoryTheory.Presieve X),\n  (CategoryTheory.Presieve.IsSheafFor P R : Prop) ‚Üî\n    (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R)) : Prop)","name":"CategoryTheory.Presieve.isSheafFor_iff_generate","isProp":true,"docString":"C2.1.3 in [Elephant] "},{"type":"‚àÄ {Œ± : Type u_1}, FaithfulSMul (Function.End Œ±) Œ±","name":"Function.End.apply_FaithfulSMul","isProp":true,"docString":"`Function.End.applyMulAction` is faithful. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : DecidableEq Œ±] {p : (a : Finset Œ±) ‚Üí Prop} (s : Finset Œ±) (h0 : p ‚àÖ)\n  (step : ‚àÄ (a : Œ±) (s : Finset Œ±) (a_1 : ‚àÄ (x : Œ±) (a_1 : x ‚àà s), x < a) (a_2 : p s), p (insert a s)), p s","name":"Finset.induction_on_max","isProp":true,"docString":"Induction principle for `Finset`s in a linearly ordered type: a predicate is true on all\n`s : Finset Œ±` provided that:\n\n* it is true on the empty `Finset`,\n* for every `s : Finset Œ±` and an element `a` strictly greater than all elements of `s`, `p s`\n  implies `p (insert a s)`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] [inst_4 : ContinuousAdd Œ≥] {f : (a : Œ±) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ≥} (hf : UpperSemicontinuousAt f x) (hg : UpperSemicontinuousAt g x),\n  UpperSemicontinuousAt (fun (z : Œ±) ‚Ü¶ f z + g z) x","name":"UpperSemicontinuousAt.add","isProp":true,"docString":"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {x : M}\n  {y : M} (a : SameRay R x y), SameRay R (-x) (-y)","name":"SameRay.neg","isProp":true,"docString":"**Alias** of the reverse direction of `sameRay_neg_iff`."},{"type":"‚àÄ {m : Type u} {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±]\n  (A : Matrix n n Œ±) (B : Matrix n m Œ±) [inst_3 : Invertible A], Matrix.mul A (Matrix.mul (‚ÖüA) B) = B","name":"Matrix.mul_invOf_self_assoc","isProp":true,"docString":"A copy of `mul_invOf_self_assoc` using `‚¨ù` not `*`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)]\n  [inst_2 : (i : Œπ) ‚Üí Zero (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}, 0 ‚â§ hammingNorm x","name":"hammingNorm_nonneg","isProp":true,"docString":"Corresponds to `norm_nonneg`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : StrictMono f),\n  StrictMono (WithTop.map f)","name":"StrictMono.withTop_map","isProp":true,"docString":"**Alias** of the reverse direction of `WithTop.strictMono_map_iff`."},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_5} {Œ≤' : Type u_6} {Œ≥' : Type u_7} {Œ¥ : Type u_4} {Œµ : Type u_2} [inst : DecidableEq Œ≤']\n  [inst_1 : DecidableEq Œ≥'] [inst_2 : DecidableEq Œ¥] [inst_3 : DecidableEq Œµ] {s : Finset Œ±} {t : Finset Œ≤}\n  {Œ≥ : Type u_1} {u : Finset Œ≥} {f : (a : Œ±) ‚Üí (a : Œ¥) ‚Üí Œµ} {g : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Œ¥} {f‚ÇÅ : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≤'}\n  {f‚ÇÇ : (a : Œ±) ‚Üí (a : Œ≥) ‚Üí Œ≥'} {g' : (a : Œ≤') ‚Üí (a : Œ≥') ‚Üí Œµ}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), f a (g b c) = g' (f‚ÇÅ a b) (f‚ÇÇ a c)),\n  Finset.image‚ÇÇ f s (Finset.image‚ÇÇ g t u) ‚äÜ Finset.image‚ÇÇ g' (Finset.image‚ÇÇ f‚ÇÅ s t) (Finset.image‚ÇÇ f‚ÇÇ s u)","name":"Finset.image‚ÇÇ_distrib_subset_left","isProp":true,"docString":"The other direction does not hold because of the `s`-`s` cross terms on the RHS. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type u_1} [inst : PseudoMetricSpace Œ±] {f : Filter Œπ} {x‚ÇÄ : Œ±} {p : (a : Œπ √ó Œ±) ‚Üí Prop},\n  (Filter.Eventually (fun (x : Œπ √ó Œ±) ‚Ü¶ p x) (Filter.prod f (nhds x‚ÇÄ)) : Prop) ‚Üî\n    (‚àÉ (pa : (a : Œπ) ‚Üí Prop),\n        (Filter.Eventually (fun (i : Œπ) ‚Ü¶ pa i) f : Prop) ‚àß\n          (‚àÉ (Œµ : ‚Ñù), (Œµ > 0 : Prop) ‚àß (‚àÄ {i : Œπ} (a : pa i) {x : Œ±} (a : dist x x‚ÇÄ < Œµ), p (i, x) : Prop) : Prop) :\n      Prop)","name":"Metric.eventually_prod_nhds_iff","isProp":true,"docString":"A version of `Filter.eventually_prod_iff` where the second filter consists of neighborhoods\nin a pseudo-metric space."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {S : C ‚•§ D}\n  {T : D} [inst_2 : CategoryTheory.Limits.HasColimits C] [inst_3 : CategoryTheory.Limits.PreservesColimits S]\n  {A : CategoryTheory.CostructuredArrow S T} (P : CategoryTheory.Subobject (Opposite.op A))\n  {q :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor S)\n        (Opposite.unop\n          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.Subobject.underlying)\n            (CategoryTheory.CostructuredArrow.projectQuotient P))) ‚ü∂\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Functor.fromPUnit T))\n        (CategoryTheory.Comma.right A)}\n  (hq :\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor S)\n          (Quiver.Hom.unop (CategoryTheory.Subobject.arrow (CategoryTheory.CostructuredArrow.projectQuotient P))) ‚â´\n        q =\n      CategoryTheory.Comma.hom A),\n  CategoryTheory.CostructuredArrow.liftQuotient (CategoryTheory.CostructuredArrow.projectQuotient P) hq = P","name":"CategoryTheory.CostructuredArrow.lift_projectQuotient","isProp":true,"docString":"Projecting and then lifting a quotient recovers the original quotient, because there is at most\none morphism making the projected quotient into a costructured arrow. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] {f : M ‚Üí*‚ÇÄ N} {g : M ‚Üí*‚ÇÄ N}\n  (h : f = g) (x : M), ‚Üëf x = ‚Üëg x","name":"MonoidWithZeroHom.congr_fun","isProp":true,"docString":"Deprecated: use `FunLike.congr_fun` instead. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Multiset Œ±} (a : Multiset.Nodup s), Multiset.Nodup (Multiset.powerset s)","name":"Multiset.Nodup.powerset","isProp":true,"docString":"**Alias** of the reverse direction of `Multiset.nodup_powerset`."},{"type":"‚àÄ {p : ‚Ñï} (hp : Nat.Prime p) (n : ‚Ñï) (k : ‚Ñï), multiplicity p n ‚â§ multiplicity p (Nat.choose n k) + multiplicity p k","name":"Nat.Prime.multiplicity_le_multiplicity_choose_add","isProp":true,"docString":"A lower bound on the multiplicity of `p` in `choose n k`. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Filter Œ±} [self : Filter.IsCountablyGenerated f],\n  ‚àÉ (s : Set (Set Œ±)), (Set.Countable s : Prop) ‚àß (f = Filter.generate s : Prop)","name":"Filter.IsCountablyGenerated.out","isProp":true,"docString":"There exists a countable set that generates the filter. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] (r : R) (f : Polynomial R) (n : ‚Ñï),\n  Polynomial.coeff (‚Üë(Polynomial.taylor r) f) n = Polynomial.eval r (‚Üë(Polynomial.hasseDeriv n) f)","name":"Polynomial.taylor_coeff","isProp":true,"docString":"The `k`th coefficient of `Polynomial.taylor r f` is `(Polynomial.hasseDeriv k f).eval r`. "},{"type":"‚àÄ (Œ± : Type u) (Œ≤ : Type v) [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] [inst_2 : Fintype Œ±]\n  [inst_3 : (a : Œ±) ‚Üí Fintype ‚Üë(AddAction.fixedBy Œ± Œ≤ a)] [inst_4 : Fintype (Quotient (AddAction.orbitRel Œ± Œ≤))],\n  (Finset.sum Finset.univ fun (a : Œ±) ‚Ü¶ Fintype.card ‚Üë(AddAction.fixedBy Œ± Œ≤ a)) =\n    Fintype.card (Quotient (AddAction.orbitRel Œ± Œ≤)) * Fintype.card Œ±","name":"AddAction.sum_card_fixedBy_eq_card_orbits_add_card_addGroup","isProp":true,"docString":"**Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\nthe average number of elements fixed by each `g ‚àà G` is the number of orbits. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {F : Type u_3} [inst : MulOneClass M] [inst_1 : MulOneClass N]\n  [inst_2 : MonoidHomClass F M N] (f : F) {x : M} (hx : ‚àÉ (y : M), x * y = 1), ‚àÉ (y : (fun (x : M) ‚Ü¶ N) x), ‚Üëf x * y = 1","name":"MonoidHom.map_exists_right_inv","isProp":true,"docString":"Given a monoid homomorphism `f : M ‚Üí* N` and an element `x : M`, if `x` has a right inverse,\nthen `f x` has a right inverse too. For elements invertible on both sides see `IsUnit.map`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (f : (a : ‚Ñï) ‚Üí Œ±) {m : ‚Ñï} {n : ‚Ñï} (h : m ‚â§ n),\n  edist (f m) (f n) ‚â§ Finset.sum (Finset.Ico m n) fun (i : ‚Ñï) ‚Ü¶ edist (f i) (f (i + 1))","name":"edist_le_Ico_sum_edist","isProp":true,"docString":"The triangle (polygon) inequality for sequences of points; `Finset.Ico` version. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 < a) (hb : 1 ‚â§ b), 1 < a * b","name":"Left.one_lt_mul_of_lt_of_le","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul_of_lt_of_le`. "},{"type":"‚àÄ {M : Type u_6} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_4} [inst_1 : AddCommMonoid N] {P : Type u_3}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P} {T : AddSubmonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_5} [inst_3 : AddCommMonoid Q]\n  {k : AddSubmonoid.LocalizationMap T Q} {A : Type u_1} [inst_4 : AddCommMonoid A] {U : AddSubmonoid A} {R : Type u_2}\n  [inst_5 : AddCommMonoid R] (j : AddSubmonoid.LocalizationMap U R) {l : P ‚Üí+ A}\n  (hl : ‚àÄ (w : { x : P // x ‚àà T }), ‚Üël ‚Üëw ‚àà U),\n  AddMonoidHom.comp (AddSubmonoid.LocalizationMap.map k hl j) (AddSubmonoid.LocalizationMap.map f hy k) =\n    AddSubmonoid.LocalizationMap.map f\n      (fun (x : { x : M // x ‚àà S }) ‚Ü¶\n        (_ : ‚Üë(AddMonoidHom.comp l g) ‚Üëx ‚àà U)=:‚àÄ (x : { x : M // x ‚àà S }), ‚Üë(AddMonoidHom.comp l g) ‚Üëx ‚àà U)\n      j","name":"AddSubmonoid.LocalizationMap.map_comp_map","isProp":true,"docString":"If `AddCommMonoid` homs `g : M ‚Üí+ P, l : P ‚Üí+ A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ‚àò g`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ico (f n) (f (Order.succ n)))","name":"Monotone.pairwise_disjoint_on_Ico_succ","isProp":true,"docString":"If `Œ±` is a linear succ order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is a monotone function, then\nthe intervals `Set.Ico (f n) (f (Order.succ n))` are pairwise disjoint. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y}\n  {F : CategoryTheory.Limits.MonoFactorisation f} {F' : CategoryTheory.Limits.MonoFactorisation f}\n  (hI : CategoryTheory.Limits.MonoFactorisation.I F = CategoryTheory.Limits.MonoFactorisation.I F')\n  (hm :\n    CategoryTheory.Limits.MonoFactorisation.m F =\n      CategoryTheory.eqToHom hI ‚â´ CategoryTheory.Limits.MonoFactorisation.m F'),\n  F = F'","name":"CategoryTheory.Limits.MonoFactorisation.ext","isProp":true,"docString":"The morphism `m` in a factorisation `f = e ‚â´ m` through a monomorphism is uniquely\ndetermined. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : AddCommMonoid Œ≤] {n : ‚Ñï} (f : (a : Fin (n + 1)) ‚Üí Œ≤) (x : Fin (n + 1)),\n  (Finset.sum Finset.univ fun (i : Fin (n + 1)) ‚Ü¶ f i) =\n    f x + Finset.sum Finset.univ fun (i : Fin n) ‚Ü¶ f (‚Üë(Fin.succAbove x) i)","name":"Fin.sum_univ_succAbove","isProp":true,"docString":"A sum of a function `f : Fin (n + 1) ‚Üí Œ≤` over all `Fin (n + 1)` is the sum of\n`f x`, for some `x : Fin (n + 1)` plus the remaining product"},{"type":"‚àÄ {Œπ : Type v} {Œπ' : Type v'} {f : (a : Œπ) ‚Üí Cardinal} {f' : (a : Œπ') ‚Üí Cardinal} (hf : BddAbove (Set.range f))\n  (hf' : BddAbove (Set.range f')) {g : (a : Œπ) ‚Üí Œπ'} (h : ‚àÄ (i : Œπ), Cardinal.lift (f i) ‚â§ Cardinal.lift (f' (g i))),\n  Cardinal.lift (sup·µ¢ f) ‚â§ Cardinal.lift (sup·µ¢ f')","name":"Cardinal.lift_sup·µ¢_le_lift_sup·µ¢","isProp":true,"docString":"To prove an inequality between the lifts to a common universe of two different supremums,\nit suffices to show that the lift of each cardinal from the smaller supremum\nif bounded by the lift of some cardinal from the larger supremum.\n"},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {c : ‚Ñù}\n  {f : (a : Œ±) ‚Üí E} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l f fun (x : Œ±) ‚Ü¶ -g' x),\n  Asymptotics.IsBigOWith c l f g'","name":"Asymptotics.IsBigOWith.of_neg_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigOWith_neg_right`."},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (a_1 : 0 < a - b), b < a","name":"lt_of_sub_pos","isProp":true,"docString":"**Alias** of the forward direction of `sub_pos`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±}, EMetric.hausdorffEdist s (closure s) = 0","name":"EMetric.hausdorffEdist_self_closure","isProp":true,"docString":"The Hausdorff edistance between a set and its closure vanishes "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {t : Set Œ±} (hs : BddAbove s)\n  (sne : Set.Nonempty s) (ht : BddAbove t) (tne : Set.Nonempty t), sup‚Çõ (s ‚à™ t) = sup‚Çõ s ‚äî sup‚Çõ t","name":"csup‚Çõ_union","isProp":true,"docString":"The `sup‚Çõ` of a union of two sets is the max of the suprema of each subset, under the\nassumptions that all sets are bounded above and nonempty."},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {t : Set Œπ} {s : Set Œ±}\n  (hs : IsGŒ¥ s) (hd : Dense s) (ht : Set.Countable t) {f : (a : Œπ) ‚Üí Set Œ±} (hc : ‚àÄ (i : Œπ) (a : i ‚àà t), IsClosed (f i))\n  (hU : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà t) ‚Ü¶ f i),\n  Dense (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà t) ‚Ü¶ interior (f i))","name":"IsGŒ¥.dense_bunion·µ¢_interior_of_closed","isProp":true,"docString":"If a countable family of closed sets cover a dense `GŒ¥` set, then the union of their interiors\nis dense. Formulated here with a union over a countable set in any type. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú} (hf : ConcaveOn ùïú s f) {x : ùïú} {y : ùïú}\n  {z : ùïú} (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z), (f z - f y) / (z - y) ‚â§ (f y - f x) / (y - x)","name":"ConcaveOn.slope_anti_adjacent","isProp":true,"docString":"If `f : ùïú ‚Üí ùïú` is concave, then for any three points `x < y < z` the slope of the secant line of\n`f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. "},{"type":"‚àÄ {n : ‚Ñï} {x : ‚Ñï √ó ‚Ñï}, (x ‚àà Finset.Nat.antidiagonal n : Prop) ‚Üî (Prod.fst x + Prod.snd x = n : Prop)","name":"Finset.Nat.mem_antidiagonal","isProp":true,"docString":"A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`. "},{"type":"‚àÄ {Œ± : Type u_1} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsTrans Œ± r] (f : (a : ‚Ñï) ‚Üí Œ±),\n  ‚àÉ (g : ‚Ñï ‚Ü™o ‚Ñï),\n    (‚àÄ (m : ‚Ñï) (n : ‚Ñï) (a : m < n), r (f (‚Üëg m)) (f (‚Üëg n)) : Prop) ‚à®\n      (‚àÄ (m : ‚Ñï) (n : ‚Ñï) (a : m < n), ¬¨(r (f (‚Üëg m)) (f (‚Üëg n)) : Prop) : Prop)","name":"exists_increasing_or_nonincreasing_subseq","isProp":true,"docString":"This is the infinitary Erd≈ës‚ÄìSzekeres theorem, and an important lemma in the usual proof of\nBolzano-Weierstrass for `‚Ñù`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G} {p : (a : G) ‚Üí Prop} {x : G} (h : x ‚àà Subgroup.closure s)\n  (Hk : ‚àÄ (x : G) (a : x ‚àà s), p x) (Hk_inv : ‚àÄ (x : G) (a : x ‚àà s), p x‚Åª¬π) (H1 : p 1)\n  (Hmul : ‚àÄ (x : G) (y : G) (a : p x) (a : p y), p (x * y)), p x","name":"Subgroup.closure_induction''","isProp":true,"docString":"An induction principle for closure membership. If `p` holds for `1` and all elements of\n`k` and their inverse, and is preserved under multiplication, then `p` holds for all elements of\nthe closure of `k`. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : AddZeroClass R] [inst_1 : AddZeroClass A] {P : (a : Unitization R A) ‚Üí Prop}\n  (h : ‚àÄ (r : R) (a : A), P (Unitization.inl r + ‚Üëa)) (x : Unitization R A), P x","name":"Unitization.ind","isProp":true,"docString":"To show a property hold on all `Unitization R A` it suffices to show it holds\non terms of the form `inl r + a`.\n\nThis can be used as `induction x using Unitization.ind`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s‚ÇÅ : Set P} {s‚ÇÇ : Set P} (h : s‚ÇÅ ‚äÜ s‚ÇÇ), affineSpan k s‚ÇÅ ‚â§ affineSpan k s‚ÇÇ","name":"affineSpan_mono","isProp":true,"docString":"`affineSpan` is monotone. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_1} [inst : UniformSpace Œ±] {f : (a : Œ±) ‚Üí Œ≥} [inst_1 : TopologicalSpace Œ≥] [inst_2 : One Œ≥]\n  (h : HasCompactMulSupport f), Filter.Tendsto f (Filter.cocompact Œ±) (nhds 1)","name":"HasCompactMulSupport.is_one_at_infty","isProp":true,"docString":"If `f` has compact multiplicative support, then `f` tends to 1 at infinity. "},{"type":"‚àÄ {Œπ : Type u} {Œ≥ : Type w} [dec : DecidableEq Œπ] [inst : AddCommMonoid Œ≥] (S : (a : Œπ) ‚Üí AddSubmonoid Œ≥),\n  sup·µ¢ S = AddMonoidHom.mrange (Dfinsupp.sumAddHom fun (i : Œπ) ‚Ü¶ AddSubmonoid.subtype (S i))","name":"AddSubmonoid.sup·µ¢_eq_mrange_dfinsupp_sumAddHom","isProp":true,"docString":"The supremum of a family of commutative additive submonoids is equal to the range of\n`Dfinsupp.sumAddHom`; that is, every element in the `sup·µ¢` can be produced from taking a finite\nnumber of non-zero elements of `S i`, coercing them to `Œ≥`, and summing them. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Antitone f) {s : Set Œ±}\n  (a : BddAbove s), BddBelow (f '' s)","name":"Antitone.map_bddAbove","isProp":true,"docString":"The image under an antitone function of a set which is bounded above is bounded below. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Sort x} {f : (a : Œπ) ‚Üí Filter Œ±} [inst : Nonempty Œπ]\n  (hd : Directed (fun (x : Filter Œ±) (x_1 : Filter Œ±) ‚Ü¶ x ‚â• x_1) f) (a : ‚àÄ (i : Œπ), Filter.NeBot (f i)),\n  Filter.NeBot (inf·µ¢ f)","name":"Filter.inf·µ¢_neBot_of_directed'","isProp":true,"docString":"If `f : Œπ ‚Üí Filter Œ±` is directed, `Œπ` is not empty, and `‚àÄ i, f i ‚â† ‚ä•`, then `inf·µ¢ f ‚â† ‚ä•`.\nSee also `inf·µ¢_neBot_of_directed` for a version assuming `Nonempty Œ±` instead of `Nonempty Œπ`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] [inst_2 : Encodable Œ≤]\n  {f : (a : Œ≤) ‚Üí Set Œ±} (ho : ‚àÄ (s : Œ≤), IsOpen (f s)) (hd : ‚àÄ (s : Œ≤), Dense (f s)),\n  Dense (Set.inter·µ¢ fun (s : Œ≤) ‚Ü¶ f s)","name":"dense_inter·µ¢_of_open","isProp":true,"docString":"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is an encodable type. "},{"type":"‚àÄ {Œ± : Type u} (l : List Œ±) (n : ‚Ñï) (k : Fin (List.length l)),\n  List.get l k =\n    List.get (List.rotate l n)\n      { val := (List.length l - n % List.length l + ‚Üëk) % List.length l,\n        isLt :=\n          ((LT.lt.trans_eq\n                ((Nat.mod_lt (List.length l - n % List.length l + ‚Üëk)\n                      ((LE.le.trans_lt ((Nat.zero_le ‚Üëk=:0 ‚â§ ‚Üëk)=:0 ‚â§ ‚Üëk)\n                            ((Fin.isLt\n                                  k=:‚Üëk <\n                                  List.length\n                                    l)=:‚Üëk <\n                                List.length\n                                  l)=:0 <\n                            List.length\n                              l)=:0 <\n                          List.length\n                            l)=:(List.length l - n % List.length l + ‚Üëk) % List.length l <\n                      List.length l)=:(List.length l - n % List.length l + ‚Üëk) % List.length l < List.length l)\n                ((Eq.symm\n                      ((List.length_rotate l\n                            n=:List.length (List.rotate l n) =\n                            List.length\n                              l)=:List.length (List.rotate l n) =\n                          List.length\n                            l)=:List.length l =\n                      List.length\n                        (List.rotate l\n                          n))=:List.length l =\n                    List.length\n                      (List.rotate l\n                        n))=:(List.length l - n % List.length l + ‚Üëk) % List.length l <\n                List.length\n                  (List.rotate l\n                    n))=:(List.length l - n % List.length l + ‚Üëk) % List.length l < List.length (List.rotate l n)) }","name":"List.get_eq_get_rotate","isProp":true,"docString":"A version of `List.get_rotate` that represents `List.get l` in terms of\n`List.get (List.rotate l n)`, not vice versa. Can be used instead of rewriting `List.get_rotate`\nfrom right to left. "},{"type":"‚àÄ {r : NNReal} {p : NNReal}, ‚Üë(r - p) = ‚Üër - ‚Üëp","name":"ENNReal.coe_sub","isProp":true,"docString":"This is a special case of `WithTop.coe_sub` in the `ENNReal` namespace "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a‚Åª¬π < b‚Åª¬π), b < a","name":"lt_of_inv_lt_inv","isProp":true,"docString":"**Alias** of the forward direction of `inv_lt_inv_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] (C : ‚Ñù) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu‚ÇÇ : ‚àÄ (n : ‚Ñï), dist (f n) (f (n + 1)) ‚â§ C / 2 / 2 ^ n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a)),\n  dist (f 0) a ‚â§ C","name":"dist_le_of_le_geometric_two_of_tendsto‚ÇÄ","isProp":true,"docString":"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCancelCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : SMul ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (hf : StrictConcaveOn ùïú s f) (c : E), StrictConcaveOn ùïú ((fun (z : E) ‚Ü¶ c + z) ‚Åª¬π' s) (f ‚àò fun (z : E) ‚Ü¶ z + c)","name":"StrictConcaveOn.translate_left","isProp":true,"docString":"Left translation preserves strict concavity. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (a : R) (b : R), a ^ 2 - b ^ 2 = (a + b) * (a - b)","name":"pow_two_sub_pow_two","isProp":true,"docString":"**Alias** of `sq_sub_sq`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  {u : (a : Œ≤) ‚Üí Œ±},\n  (CauchySeq u : Prop) ‚Üî\n    (‚àÄ (Œµ : ENNReal) (a : Œµ > 0), ‚àÉ (N : Œ≤), ‚àÄ (m : Œ≤) (a : N ‚â§ m) (n : Œ≤) (a : N ‚â§ n), edist (u m) (u n) < Œµ : Prop)","name":"EMetric.cauchySeq_iff","isProp":true,"docString":"In a pseudoemetric space, Cauchy sequences are characterized by the fact that, eventually,\nthe pseudoedistance between its elements is arbitrarily small "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (q : (i : Fin (n + 1)) ‚Üí Œ± i) (z : Œ± 0),\n  Fin.tail (Function.update q 0 z) = Fin.tail q","name":"Fin.tail_update_zero","isProp":true,"docString":"Updating the first element of a tuple does not change the tail. "},{"type":"‚àÄ {Œ± : Sort u_1}, IsEmpty { _a : Œ± // False }","name":"Subtype.isEmpty_false","isProp":true,"docString":"subtypes by false are false. "},{"type":"‚àÄ {f : (a : Ordinal) ‚Üí Ordinal} (H : Ordinal.IsNormal f),\n  Set.Unbounded (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x < x_1) (Function.fixedPoints f)","name":"Ordinal.fp_unbounded","isProp":true,"docString":"The fixed point lemma for normal functions: any normal function has an unbounded set of\nfixed points. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module R·µê·µí·µñ M] [inst_4 : SMulCommClass R R·µê·µí·µñ M] (l : List (TrivSqZeroExt R M)),\n  TrivSqZeroExt.snd (List.prod l) =\n    List.sum\n      (List.map\n        (fun (x : ‚Ñï √ó TrivSqZeroExt R M) ‚Ü¶\n          List.prod (List.take (Prod.fst x) (List.map TrivSqZeroExt.fst l)) ‚Ä¢\n            { unop := List.prod (List.drop (Nat.succ (Prod.fst x)) (List.map TrivSqZeroExt.fst l)) } ‚Ä¢\n              TrivSqZeroExt.snd (Prod.snd x))\n        (List.enum l))","name":"TrivSqZeroExt.snd_list_prod","isProp":true,"docString":"The second element of a product $\\prod_{i=0}^n (r_i + m_i)$ is a sum of terms of the form\n$r_0\\cdots r_{i-1}m_ir_{i+1}\\cdots r_n$. "},{"type":"‚àÄ {Œπ : Type u} {Œ± : Type v} [inst : DecidableEq Œ±] {t : (a : Œπ) ‚Üí Finset Œ±} [inst_1 : Finite Œπ]\n  (ht : ‚àÄ (s : Finset Œπ), Finset.card s ‚â§ Finset.card (Finset.bunion·µ¢ s t)),\n  ‚àÉ (f : (a : Œπ) ‚Üí Œ±), (Function.Injective f : Prop) ‚àß (‚àÄ (x : Œπ), f x ‚àà t x : Prop)","name":"HallMarriageTheorem.hall_hard_inductive","isProp":true,"docString":"Here we combine the two inductive steps into a full strong induction proof,\ncompleting the proof the harder direction of **Hall's Marriage Theorem**.\n"},{"type":"‚àÄ {M : Type u_1} [inst : Semigroup M] (a : Stream' M) (s : Set (Set M)) (sfin : Set.Finite s)\n  (scov : Hindman.FP a ‚äÜ ‚ãÉ‚ÇÄ s), ‚àÉ (c : Set M), (c ‚àà s : Prop) ‚àß (‚àÉ (b : Stream' M), Hindman.FP b ‚äÜ c : Prop)","name":"Hindman.FP_partition_regular","isProp":true,"docString":"The strong form of **Hindman's theorem**: in any finite cover of an FP-set, one the parts\ncontains an FP-set. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {f : (a : Œ±) ‚Üí ENNReal} (h : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚â† ‚ä§),\n  (Finset.sum s fun (a : Œ±) ‚Ü¶ f a) < ‚ä§","name":"ENNReal.sum_lt_top","isProp":true,"docString":"A sum of finite numbers is still finite "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (E : Set Œ±),\n  closure E = Set.inter·µ¢ fun (Œ¥ : ‚Ñù) ‚Ü¶ Set.inter·µ¢ fun (_h : 0 < Œ¥) ‚Ü¶ Metric.cthickening Œ¥ E","name":"Metric.closure_eq_inter·µ¢_cthickening","isProp":true,"docString":"The closure of a set equals the intersection of its closed thickenings of positive radii. "},{"type":"‚àÄ (Œ± : Type u) [inst : Semiring Œ±] [inst_1 : Nontrivial Œ±], ‚àÉ (M : Ideal Œ±), Ideal.IsMaximal M","name":"Ideal.exists_maximal","isProp":true,"docString":"Krull's theorem: a nontrivial ring has a maximal ideal. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M ‚Üí* P),\n  Function.Injective ‚Üë(Con.kerLift f)","name":"Con.kerLift_injective","isProp":true,"docString":"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] {K : Set G}\n  {V : Set G} (hK : IsCompact K) (hV : Set.Nonempty (interior V)),\n  ‚àÉ (t : Finset G), K ‚äÜ Set.union·µ¢ fun (g : G) ‚Ü¶ Set.union·µ¢ fun (h : g ‚àà t) ‚Ü¶ (fun (h : G) ‚Ü¶ g + h) ‚Åª¬π' V","name":"compact_covered_by_add_left_translates","isProp":true,"docString":"A compact set is covered by finitely many left additive translates of a set\nwith non-empty interior."},{"type":"‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x : Œ±), x ‚äì x·∂ú ‚â§ ‚ä•","name":"BooleanAlgebra.inf_compl_le_bot","isProp":true,"docString":"The infimum of `x` and `x·∂ú` is at most `‚ä•` "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteLimits C],\n  CategoryTheory.Limits.HasFiniteWidePullbacks C","name":"CategoryTheory.Limits.hasFiniteWidePullbacks_of_hasFiniteLimits","isProp":true,"docString":"Finite wide pullbacks are finite limits, so if `C` has all finite limits,\nit also has finite wide pullbacks\n"},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] (l : List (Polynomial R)) (x : R),\n  Polynomial.eval x (List.prod l) = List.prod (List.map (Polynomial.eval x) l)","name":"Polynomial.eval_list_prod","isProp":true,"docString":"Polynomial evaluation commutes with `List.prod`\n"},{"type":"‚àÄ {K : Type u} [self : DivisionRing K] (n : ‚Ñï) (a : K),\n  DivisionRing.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionRing.zpow (Int.ofNat n) a","name":"DivisionRing.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : Group Œ±] [inst_2 : UniformGroup Œ±] {hom : Type u_1}\n  [inst_3 : UniformSpace Œ≤] [inst_4 : Group Œ≤] [inst_5 : UniformGroup Œ≤] [inst_6 : MonoidHomClass hom Œ± Œ≤] (f : hom)\n  (hf : ContinuousAt (‚Üëf) 1), UniformContinuous ‚Üëf","name":"uniformContinuous_of_continuousAt_one","isProp":true,"docString":"A group homomorphism (a bundled morphism of a type that implements `MonoidHomClass`) between\ntwo uniform groups is uniformly continuous provided that it is continuous at one. See also\n`continuous_of_continuousAt_one`. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {u : (a : Œπ) ‚Üí Set X} {s : Set X}\n  (self : ShrinkingLemma.PartialRefinement u s),\n  s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ ShrinkingLemma.PartialRefinement.toFun self i","name":"ShrinkingLemma.PartialRefinement.subset_union·µ¢","isProp":true,"docString":"The partially refined family still covers the set. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {M : Type u_1}\n  {hom : Type u_2} [inst_3 : MulOneClass M] [inst_4 : TopologicalSpace M] [inst_5 : ContinuousMul M]\n  [inst_6 : MonoidHomClass hom G M] (f : hom) (hf : ContinuousAt (‚Üëf) 1), Continuous ‚Üëf","name":"continuous_of_continuousAt_one","isProp":true,"docString":"A monoid homomorphism (a bundled morphism of a type that implements `MonoidHomClass`) from a\ntopological group to a topological monoid is continuous provided that it is continuous at one. See\nalso `uniformContinuous_of_continuousAt_one`. "},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_2} {N : Type u_1} [inst : AddCommMonoid M] [inst_1 : OrderedAddCommMonoid N]\n  (f : (a : M) ‚Üí N) (p : (a : M) ‚Üí Prop) (h_one : f 0 = 0)\n  (h_mul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), f (x + y) ‚â§ f x + f y)\n  (hp_mul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x + y)) (g : (a : Œπ) ‚Üí M) {s : Finset Œπ}\n  (hs : ‚àÄ (i : Œπ) (a : i ‚àà s), p (g i)), f (Finset.sum s fun (i : Œπ) ‚Ü¶ g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f (g i)","name":"Finset.le_sum_of_subadditive_on_pred","isProp":true,"docString":"Let `{x | p x}` be a subsemigroup of a commutative additive monoid `M`. Let `f : M ‚Üí N` be a map\nsuch that `f 0 = 0` and `f` is subadditive on `{x | p x}`, i.e. `p x ‚Üí p y ‚Üí f (x + y) ‚â§ f x + f y`.\nLet `g i`, `i ‚àà s`, be a finite family of elements of `M` such that `‚àÄ i ‚àà s, p (g i)`. Then\n`f (‚àë x in s, g x) ‚â§ ‚àë x in s, f (g x)`. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ±) ‚Üí M} {s : Set Œ±}\n  (hs : Set.Finite s),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i * g i) =\n    (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ g i","name":"finprod_mem_mul_distrib","isProp":true,"docString":"Given a finite set `s`, the product of `f i * g i` over `i ‚àà s` equals the product of `f i`\nover `i ‚àà s` times the product of `g i` over `i ‚àà s`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (E : D ‚•§ C)\n  [inst_2 : CategoryTheory.IsEquivalence E] [inst : CategoryTheory.Limits.HasLimitsOfSize C],\n  CategoryTheory.Limits.HasLimitsOfSize D","name":"CategoryTheory.Adjunction.has_limits_of_equivalence","isProp":true,"docString":"Transport a `HasLimitsOfSize` instance across an equivalence. "},{"type":"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (A : Matrix n n R),\n  Matrix.det (-A) = (-1) ^ Fintype.card n ‚Ä¢ Matrix.det A","name":"Matrix.det_neg_eq_smul","isProp":true,"docString":"A variant of `Matrix.det_neg` with scalar multiplication by `Units ‚Ñ§` instead of multiplication\nby `R`. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] (P : (a : Polynomial R) ‚Üí Prop) (N : ‚Ñï) (P_0 : P 0)\n  (P_C_mul_pow : ‚àÄ (n : ‚Ñï) (r : R) (a : r ‚â† 0) (a : n ‚â§ N), P (‚ÜëPolynomial.C r * Polynomial.X ^ n))\n  (P_C_add :\n    ‚àÄ (f : Polynomial R) (g : Polynomial R) (a : Polynomial.natDegree f < Polynomial.natDegree g)\n      (a : Polynomial.natDegree g ‚â§ N) (a : P f) (a : P g), P (f + g))\n  (f : Polynomial R) (a : Polynomial.natDegree f ‚â§ N), P f","name":"Polynomial.induction_with_natDegree_le","isProp":true,"docString":"An induction lemma for polynomials. It takes a natural number `N` as a parameter, that is\nrequired to be at least as big as the `nat_degree` of the polynomial.  This is useful to prove\nresults where you want to change each term in a polynomial to something else depending on the\n`nat_degree` of the polynomial itself and not on the specific `nat_degree` of each term. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CanonicallyOrderedCommSemiring R] {f : (a : Œπ) ‚Üí R} {g : (a : Œπ) ‚Üí R}\n  {h : (a : Œπ) ‚Üí R} {s : Finset Œπ} {i : Œπ} (hi : i ‚àà s) (h2i : g i + h i ‚â§ f i)\n  (hgf : ‚àÄ (j : Œπ) (a : j ‚àà s) (a : j ‚â† i), g j ‚â§ f j) (hhf : ‚àÄ (j : Œπ) (a : j ‚àà s) (a : j ‚â† i), h j ‚â§ f j),\n  ((Finset.prod s fun (i : Œπ) ‚Ü¶ g i) + Finset.prod s fun (i : Œπ) ‚Ü¶ h i) ‚â§ Finset.prod s fun (i : Œπ) ‚Ü¶ f i","name":"Finset.prod_add_prod_le'","isProp":true,"docString":"If `g, h ‚â§ f` and `g i + h i ‚â§ f i`, then the product of `f` over `s` is at least the\nsum of the products of `g` and `h`. This is the version for `CanonicallyOrderedCommSemiring`.\n"},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V} (hinj : Function.Injective ‚Üëf), Function.Surjective ‚Üëf","name":"LinearMap.surjective_of_injective","isProp":true,"docString":"On a finite-dimensional space, an injective linear map is surjective. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {x : ùïú} {y : ùïú} {z : ùïú} (h : x ‚â§ y),\n  (z ‚àà Set.Icc x y : Prop) ‚Üî\n    (‚àÉ (a : ùïú),\n        ‚àÉ (b : ùïú), (0 ‚â§ a : Prop) ‚àß ((0 ‚â§ b : Prop) ‚àß ((a + b = 1 : Prop) ‚àß (a * x + b * y = z : Prop) : Prop) : Prop) :\n      Prop)","name":"Convex.mem_Icc","isProp":true,"docString":"A point is in an `Icc` iff it can be expressed as a convex combination of the endpoints. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} [inst : CommMonoid Œ±] {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≥) ‚Üí Œ±}\n  (h_eq :\n    ‚àÄ (u : Finset Œ≥),\n      ‚àÉ (v : Finset Œ≤),\n        ‚àÄ (v' : Finset Œ≤) (a : v ‚äÜ v'),\n          ‚àÉ (u' : Finset Œ≥),\n            (u ‚äÜ u' : Prop) ‚àß ((Finset.prod u' fun (x : Œ≥) ‚Ü¶ g x) = Finset.prod v' fun (b : Œ≤) ‚Ü¶ f b : Prop)),\n  Filter.map (fun (s : Finset Œ≤) ‚Ü¶ Finset.prod s fun (b : Œ≤) ‚Ü¶ f b) Filter.atTop ‚â§\n    Filter.map (fun (s : Finset Œ≥) ‚Ü¶ Finset.prod s fun (x : Œ≥) ‚Ü¶ g x) Filter.atTop","name":"Filter.map_atTop_finset_prod_le_of_prod_eq","isProp":true,"docString":"Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient\ncondition for comparison of the filter `atTop.map (Œª s, ‚àè b in s, f b)` with\n`atTop.map (Œª s, ‚àè b in s, g b)`. This is useful to compare the set of limit points of\n`Œ† b in s, f b` as `s ‚Üí atTop` with the similar set for `g`. "},{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Type u} [inst : CommMonoid Œ≤] {Œπ' : Type u_1} [inst_1 : DecidableEq Œπ] (e : Œπ ‚âÉ Œπ')\n  (f : (a : Œπ') ‚Üí Œ≤) {s' : Finset Œπ'} {s : Finset Œπ} (h : s = Finset.image (‚Üë(Equiv.symm e)) s'),\n  (Finset.prod s' fun (i' : Œπ') ‚Ü¶ f i') = Finset.prod s fun (i : Œπ) ‚Ü¶ f (‚Üëe i)","name":"Finset.Equiv.prod_comp_finset","isProp":true,"docString":"Reindexing a product over a finset along an equivalence.\nSee `Equiv.prod_comp` for the version where `s` and `s'` are `univ`. "},{"type":"‚àÄ {B : Type u_1} (F : Type u_4) {X : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace B]\n  [inst_2 : TopologicalSpace F] {E : (a : B) ‚Üí Type u_2} [inst_3 : TopologicalSpace (Bundle.TotalSpace E)]\n  [inst_4 : (b : B) ‚Üí TopologicalSpace (E b)] [inst_5 : FiberBundle F E] (f : (a : X) ‚Üí Bundle.TotalSpace E) {x‚ÇÄ : X},\n  (ContinuousAt f x‚ÇÄ : Prop) ‚Üî\n    ((ContinuousAt (fun (x : X) ‚Ü¶ Bundle.TotalSpace.proj (f x)) x‚ÇÄ : Prop) ‚àß\n        (ContinuousAt (fun (x : X) ‚Ü¶ Prod.snd (‚Üë(trivializationAt F E (Bundle.TotalSpace.proj (f x‚ÇÄ))) (f x))) x‚ÇÄ :\n          Prop) :\n      Prop)","name":"FiberBundle.continuousAt_totalSpace","isProp":true,"docString":"Characterization of continuous functions (at a point) into a fiber bundle. "},{"type":"‚àÄ {R : Type u_1} {Œì‚ÇÄ : Type u_2} [inst : CommRing R] [inst_1 : LinearOrderedAddCommMonoidWithTop Œì‚ÇÄ]\n  (v : AddValuation R Œì‚ÇÄ) {J : Ideal R} (hJ : J ‚â§ AddValuation.supp v),\n  AddValuation.supp (AddValuation.onQuot v hJ) = Ideal.map (Ideal.Quotient.mk J) (AddValuation.supp v)","name":"AddValuation.supp_quot","isProp":true,"docString":"The quotient valuation on `R / J` has support `(supp v) / J` if `J ‚äÜ supp v`. "},{"type":"‚àÄ {Œ± : Type u_1} {m : Type u_2} {R : Type v} [inst : CommRing R] {M : Matrix m m R} {b : (a : m) ‚Üí Œ±}\n  [inst_1 : DecidableEq m] [inst_2 : Fintype m] [inst_3 : LinearOrder Œ±] [inst_4 : Invertible M]\n  (hM : Matrix.BlockTriangular M b) (k : Œ±), (Matrix.toBlock M‚Åª¬π (fun (i : m) ‚Ü¶ k ‚â§ b i) fun (i : m) ‚Ü¶ b i < k) = 0","name":"Matrix.toBlock_inverse_eq_zero","isProp":true,"docString":"A lower-left subblock of the inverse of a block-triangular matrix is zero. This is a first step\ntowards `BlockTriangular.inv_toBlock` below. "},{"type":"‚àÄ {Œ± : Sort u_1} {s‚ÇÅ : Setoid Œ±}, Function.Surjective Quotient.mk''","name":"Quotient.surjective_Quotient_mk''","isProp":true,"docString":"`Quotient.mk''` is a surjective function. "},{"type":"‚àÄ {L : FirstOrder.Language} [self : FirstOrder.Language.IsRelational L] (n : ‚Ñï),\n  IsEmpty (FirstOrder.Language.Functions L n)","name":"FirstOrder.Language.IsRelational.empty_functions","isProp":true,"docString":"There are no function symbols in the language. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {s : CategoryTheory.Limits.Cone F} {t : CategoryTheory.Limits.Cone F} (P : CategoryTheory.Limits.IsLimit s)\n  (Q : CategoryTheory.Limits.IsLimit t) (f : s ‚ü∂ t), CategoryTheory.IsIso f","name":"CategoryTheory.Limits.IsLimit.hom_isIso","isProp":true,"docString":"Any cone morphism between limit cones is an isomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommMonoid Œ±] (f : (a : ‚Ñï) ‚Üí Œ±) (n : ‚Ñï),\n  (Finset.sum Finset.univ fun (i : Fin n) ‚Ü¶ f ‚Üëi) = Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f i","name":"Fin.sum_univ_eq_sum_range","isProp":true,"docString":"It is equivalent to sum a function over `fin n` or `finset.range n`."},{"type":"‚àÄ {Œ± : Type u_1}, Vector.tail Vector.nil = Vector.nil","name":"Vector.tail_nil","isProp":true,"docString":"The `tail` of a `nil` vector is `nil`. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {n‚ÇÅ : ‚Ñ§} {n‚ÇÇ : ‚Ñ§} {d‚ÇÅ : ‚Ñ§} {d‚ÇÇ : ‚Ñ§} (hn‚ÇÅ : n‚ÇÅ ‚â† 0) (hn‚ÇÇ : n‚ÇÇ ‚â† 0)\n  (hd‚ÇÅ : d‚ÇÅ ‚â† 0) (hd‚ÇÇ : d‚ÇÇ ‚â† 0),\n  (padicValRat p (Rat.divInt n‚ÇÅ d‚ÇÅ) ‚â§ padicValRat p (Rat.divInt n‚ÇÇ d‚ÇÇ) : Prop) ‚Üî\n    (‚àÄ (n : ‚Ñï) (a : ‚Üëp ^ n ‚à£ n‚ÇÅ * d‚ÇÇ), ‚Üëp ^ n ‚à£ n‚ÇÇ * d‚ÇÅ : Prop)","name":"padicValRat.padicValRat_le_padicValRat_iff","isProp":true,"docString":"A condition for `padicValRat p (n‚ÇÅ / d‚ÇÅ) ‚â§ padicValRat p (n‚ÇÇ / d‚ÇÇ)`, in terms of\ndivisibility by `p^n`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofiltered C] {J : Type w}\n  [inst_2 : CategoryTheory.SmallCategory J] [inst_3 : CategoryTheory.FinCategory J] (F : J ‚•§ C),\n  Nonempty (CategoryTheory.Limits.Cone F)","name":"CategoryTheory.IsCofiltered.cone_nonempty","isProp":true,"docString":"If we have `IsCofiltered C`, then for any functor `F : J ‚•§ C` with `FinCategory J`,\nthere exists a cone over `F`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F}\n  {l : Filter Œ±} (a : f =o[l] g) ‚¶Éc : ‚Ñù‚¶Ñ (a : 0 < c), Asymptotics.IsBigOWith c l f g","name":"Asymptotics.IsLittleO.forall_isBigOWith","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_iff_forall_isBigOWith`."},{"type":"‚àÄ {R : Type u} {Œπ : Type w} (s : Finset Œπ) [inst : CommSemiring R] [inst_1 : NoZeroDivisors R]\n  (f : (a : Œπ) ‚Üí Polynomial R),\n  Polynomial.leadingCoeff (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) = Finset.prod s fun (i : Œπ) ‚Ü¶ Polynomial.leadingCoeff (f i)","name":"Polynomial.leadingCoeff_prod","isProp":true,"docString":"The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients.\n\nSee `Polynomial.leadingCoeff_prod'` (with a `'`) for a version for commutative semirings,\nwhere additionally, the product of the leading coefficients must be nonzero.\n"},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {œÉ : Equiv.Perm Œ±} (hs : (setOf fun (a : Œ±) ‚Ü¶ ‚ÜëœÉ a ‚â† a) ‚äÜ ‚Üës),\n  Finset.map (Equiv.toEmbedding œÉ) s = s","name":"Finset.map_perm","isProp":true,"docString":"If the only elements outside `s` are those left fixed by `œÉ`, then mapping by `œÉ` has no effect.\n"},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {S : Type v} [inst_1 : Semiring S] [inst_2 : Algebra R S] (p : Polynomial R),\n  ‚Üë(Polynomial.mapAlg R S) p = Polynomial.map (algebraMap R S) p","name":"Polynomial.mapAlg_eq_map","isProp":true,"docString":"`mapAlg` is the morphism induced by `R ‚Üí S`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (a_1 : IsMinOn f s a),\n  IsMaxOn (‚ÜëOrderDual.toDual ‚àò f) s a","name":"IsMinOn.dual","isProp":true,"docString":"**Alias** of the reverse direction of `isMaxOn_dual_iff`."},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï}, (‚àÄ (a : ‚Ñï), (m ‚à£ a : Prop) ‚Üî (n ‚à£ a : Prop) : Prop) ‚Üî (m = n : Prop)","name":"Nat.dvd_right_iff_eq","isProp":true,"docString":"Two natural numbers are equal if and only if they have the same multiples. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] (S : Submonoid M) (m : Multiset M) (hm : ‚àÄ (a : M) (a_1 : a ‚àà m), a ‚àà S),\n  Multiset.prod m ‚àà S","name":"Submonoid.multiset_prod_mem","isProp":true,"docString":"Product of a multiset of elements in a submonoid of a `CommMonoid` is in the submonoid. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {f : Filter Œ±},\n  (Filter.IsBounded r f : Prop) ‚Üî\n    (‚àÉ (s : Set Œ±), (s ‚àà Filter.sets f : Prop) ‚àß (‚àÉ (b : Œ±), s ‚äÜ setOf fun (x : Œ±) ‚Ü¶ r x b : Prop) : Prop)","name":"Filter.isBounded_iff","isProp":true,"docString":"`f` is eventually bounded if and only if, there exists an admissible set on which it is\nbounded. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} {Œ±_1 : Type u_1} {q : (a : Œ±_1) ‚Üí Prop}\n  {f : (a : Œ±) ‚Üí Œ±_1} [inst : Functor m] [inst_1 : LawfulFunctor m] {x : m Œ±} (hx : SatisfiesM p x)\n  (hf : ‚àÄ {a : Œ±} (a_1 : p a), q (f a)), SatisfiesM q (f <$> x)","name":"SatisfiesM.map","isProp":true,"docString":"`SatisfiesM` distributes over `<$>`, general version. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x : R // x ‚àà s }","name":"Subring.instNoZeroDivisorsSubtypeMemSubringInstMembershipInstSetLikeSubringMulToMulOneClassToMulZeroOneClassToNonAssocSemiringToNonAssocRingToSubmonoidToSubsemiringZeroToZeroToMonoidWithZeroToSemiringToZeroMemClassToAddZeroClassToAddMonoidToAddMonoidWithOneToAddGroupWithOneToAddSubmonoidClassToSubsemiringClassInstSubringClassSubringInstSetLikeSubring","isProp":true,"docString":"A subring of a ring with no zero divisors has no zero divisors. "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (h : Fermat42 a b c),\n  ‚àÉ (a0 : ‚Ñ§), ‚àÉ (b0 : ‚Ñ§), ‚àÉ (c0 : ‚Ñ§), (Fermat42.Minimal a0 b0 c0 : Prop) ‚àß (a0 % 2 = 1 : Prop)","name":"Fermat42.exists_odd_minimal","isProp":true,"docString":"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddMonoid G] [self : AddAction G P] (g‚ÇÅ : G) (g‚ÇÇ : G) (p : P),\n  g‚ÇÅ + g‚ÇÇ +·µ• p = g‚ÇÅ +·µ• (g‚ÇÇ +·µ• p)","name":"AddAction.add_vadd","isProp":true,"docString":"Associativity of `+` and `+·µ•` "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Infinite s), Infinite ‚Üës","name":"Set.Infinite.to_subtype","isProp":true,"docString":"**Alias** of the reverse direction of `Set.infinite_coe_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {u : (a : Œ±) ‚Üí Set Œ≤} {x : Œ±} (xs : x ‚àà s),\n  u x ‚äÜ Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà s) ‚Ü¶ u x","name":"Set.subset_bunion·µ¢_of_mem","isProp":true,"docString":"A specialization of `subset_union·µ¢‚ÇÇ`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Fintype Œ±] [inst_1 : CompleteLattice Œ≤] (f : (a : Œ±) ‚Üí Œ≤),\n  Finset.sup Finset.univ f = sup·µ¢ f","name":"Finset.sup_univ_eq_sup·µ¢","isProp":true,"docString":"A special case of `Finset.sup_eq_sup·µ¢` that omits the useless `x ‚àà univ` binder. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CompleteLattice Œ±] {f : Filter Œ≤} {p : (a : Œ≤) ‚Üí Prop} {q : (a : Œ≤) ‚Üí Prop}\n  {u : (a : Œ≤) ‚Üí Œ±},\n  Filter.blimsup u f p ‚äî Filter.blimsup u f q ‚â§ Filter.blimsup u f fun (x : Œ≤) ‚Ü¶ (p x : Prop) ‚à® (q x : Prop)","name":"Filter.blimsup_sup_le_or","isProp":true,"docString":"See also `Filter.blimsup_or_eq_sup`. "},{"type":"‚àÄ {Œ± : Type v} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±] {s : Set Œ±}\n  (hs : IsPreconnected s) {a : Œ±} {b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s), Set.Icc a b ‚äÜ s","name":"IsPreconnected.Icc_subset","isProp":true,"docString":"If a preconnected set contains endpoints of an interval, then it includes the whole interval. "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {N : Type u_2} [dec_Œπ : DecidableEq Œπ] [inst : Ring R] [inst_1 : AddCommGroup N]\n  [inst_2 : Module R N] [inst_3 : NoZeroSMulDivisors R N] (p : (a : Œπ) ‚Üí Submodule R N)\n  (hp : CompleteLattice.Independent p) {v : (a : Œπ) ‚Üí N} (hv : ‚àÄ (i : Œπ), v i ‚àà p i) (hv' : ‚àÄ (i : Œπ), v i ‚â† 0),\n  LinearIndependent R v","name":"CompleteLattice.Independent.linearIndependent","isProp":true,"docString":"If a family of submodules is `Independent`, then a choice of nonzero vector from each submodule\nforms a linearly independent family.\n\nSee also `CompleteLattice.Independent.linearIndependent'`. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, (Ideal.radical I = I : Prop) ‚Üî (Ideal.IsRadical I : Prop)","name":"Ideal.radical_eq_iff","isProp":true,"docString":"An ideal is radical iff it is equal to its radical. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ±} {b : Œ≤} (h : ‚àÄ (a : Œ±), f a b = a) (o : Option Œ±),\n  Option.map‚ÇÇ f o (some b) = o","name":"Option.map‚ÇÇ_right_identity","isProp":true,"docString":"If `b` is a right identity for a binary operation `f`, then `some b` is a right identity for\n`Option.map‚ÇÇ f`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {R : D ‚•§ C} (h : L ‚ä£ R) {X : C} [inst_2 : CategoryTheory.IsIso ((CategoryTheory.Adjunction.unit h).app X)],\n  CategoryTheory.inv\n      (Prefunctor.map (CategoryTheory.Functor.toPrefunctor L) ((CategoryTheory.Adjunction.unit h).app X)) =\n    (CategoryTheory.Adjunction.counit h).app (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor L) X)","name":"CategoryTheory.inv_map_unit","isProp":true,"docString":"If the unit of an adjunction is an isomorphism, then its inverse on the image of L is given\nby L whiskered with the counit. "},{"type":"‚àÄ {Œ± : Type u_1} {p : Set Œ±} (s : Finset Œ±) (H : ‚àÄ (x : Œ±), (x ‚àà s : Prop) ‚Üî (x ‚àà p : Prop)), Set.toFinset p = s","name":"Set.toFinset_ofFinset","isProp":true,"docString":"Many `Fintype` instances for sets are defined using an extensionally equal `Finset`.\nRewriting `s.toFinset` with `Set.toFinset_ofFinset` replaces the term with such a `Finset`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {s : Set Œ±·µí·µà} (a : IsUpperSet s), IsLowerSet (‚ÜëOrderDual.toDual ‚Åª¬π' s)","name":"IsUpperSet.toDual","isProp":true,"docString":"**Alias** of the reverse direction of `isLowerSet_preimage_toDual_iff`."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C] {K : Type u‚ÇÅ}\n  [inst_2 : CategoryTheory.Category K] (F : J ‚•§ C) (G : K ‚•§ C)\n  (h : CategoryTheory.Functor.cocones F ‚âÖ CategoryTheory.Functor.cocones G) [inst : CategoryTheory.Limits.HasColimit F],\n  CategoryTheory.Limits.HasColimit G","name":"CategoryTheory.Limits.HasColimit.ofCoconesIso","isProp":true,"docString":"If a functor `G` has the same collection of cocones as a functor `F`\nwhich has a colimit, then `G` also has a colimit. "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] (e : R‚ÇÅ ‚âÉ+* R‚ÇÇ),\n  RingHomInvPair ‚Üëe ‚Üë(RingEquiv.symm e)","name":"RingHomInvPair.of_ringEquiv","isProp":true,"docString":"Construct a `RingHomInvPair` from both directions of a ring equiv.\n\nThis is not an instance, as for equivalences that are involutions, a better instance\nwould be `RingHomInvPair e e`. Indeed, this declaration is not currently used in mathlib.\n\nSee note [reducible non-instances].\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] (self : Œ± ‚âÉ·µê Œ≤),\n  Measurable ‚Üë(Equiv.symm (MeasurableEquiv.toEquiv self))","name":"MeasurableEquiv.measurable_invFun","isProp":true,"docString":"The inverse function of a measurable equivalence is measurable. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)]\n  [inst_2 : (i : Œπ) ‚Üí Zero (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}, (hammingNorm x = 0 : Prop) ‚Üî (x = 0 : Prop)","name":"hammingNorm_eq_zero","isProp":true,"docString":"Corresponds to `norm_eq_zero`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G], (AddGroup.Fg G : Prop) ‚Üî (AddMonoid.Fg G : Prop)","name":"AddGroup.fg_iff_addMonoid_fg","isProp":true,"docString":"An additive group is finitely generated if and only\nif it is finitely generated as an additive monoid."},{"type":"‚àÄ (C : Type (u + 1)) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] (D : Type (u + 1))\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.ConcreteCategory D]\n  [inst_4 : CategoryTheory.HasForget‚ÇÇ C D] [inst_5 : CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget C)],\n  CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget‚ÇÇ C D)","name":"CategoryTheory.reflectsIsomorphisms_forget‚ÇÇ","isProp":true,"docString":"A `forget‚ÇÇ C D` forgetful functor between concrete categories `C` and `D`\nwhere `forget C` reflects isomorphisms, itself reflects isomorphisms.\n"},{"type":"‚àÄ {F : Sort u_2} {Œ≤ : Sort u_1} {Œ≥ : Sort u_3} [iF : EquivLike F Œ≤ Œ≥] [inst : Subsingleton Œ≤], Subsingleton F","name":"EquivLike.subsingleton_dom","isProp":true,"docString":"This is not an instance to avoid slowing down every single `Subsingleton` typeclass search."},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (ha : a ‚â† 0) (hb : b ‚â† 0), Nat.factorization (a * b) = Nat.factorization a + Nat.factorization b","name":"Nat.factorization_mul","isProp":true,"docString":"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : DenselyOrdered Œ±] [inst_2 : NoMinOrder Œ±] [inst_3 : NoMaxOrder Œ±]\n  [nonem : Nonempty Œ±] (lo : Finset Œ±) (hi : Finset Œ±) (lo_lt_hi : ‚àÄ (x : Œ±) (a : x ‚àà lo) (y : Œ±) (a : y ‚àà hi), x < y),\n  ‚àÉ (m : Œ±), (‚àÄ (x : Œ±) (a : x ‚àà lo), x < m : Prop) ‚àß (‚àÄ (y : Œ±) (a : y ‚àà hi), m < y : Prop)","name":"Order.exists_between_finsets","isProp":true,"docString":"Suppose `Œ±` is a nonempty dense linear order without endpoints, and\nsuppose `lo`, `hi`, are finite subssets with all of `lo` strictly\nbefore `hi`. Then there is an element of `Œ±` strictly between `lo`\nand `hi`. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Mul G] [inst_1 : Mul H] (f : G ‚Üí‚Çô* H) (hf : Function.Injective ‚Üëf) (a0 : G)\n  (b0 : G) {A : Finset H} {B : Finset H} (u : UniqueMul A B (‚Üëf a0) (‚Üëf b0)),\n  UniqueMul\n    (Finset.preimage A ‚Üëf\n      ((Set.injOn_of_injective hf (‚Üëf ‚Åª¬π' ‚ÜëA)=:Set.InjOn (‚Üëf) (‚Üëf ‚Åª¬π' ‚ÜëA))=:Set.InjOn (‚Üëf) (‚Üëf ‚Åª¬π' ‚ÜëA)))\n    (Finset.preimage B ‚Üëf\n      ((Set.injOn_of_injective hf (‚Üëf ‚Åª¬π' ‚ÜëB)=:Set.InjOn (‚Üëf) (‚Üëf ‚Åª¬π' ‚ÜëB))=:Set.InjOn (‚Üëf) (‚Üëf ‚Åª¬π' ‚ÜëB)))\n    a0 b0","name":"UniqueMul.mulHom_preimage","isProp":true,"docString":"`UniqueMul` is preserved by inverse images under injective, multiplicative maps. "},{"type":"‚àÄ {M : Type v} {X : Type x} [inst : UniformSpace X] [inst_1 : VAdd M X] [inst_2 : VAdd M·µÉ·µí·µñ X]\n  [inst_3 : IsCentralVAdd M X] [inst_4 : UniformContinuousConstVAdd M X], UniformContinuousConstVAdd M·µÉ·µí·µñ X","name":"UniformContinuousConstVAdd.op","isProp":true,"docString":"If an additive action is central, then its right action is uniform\ncontinuous when its left action is."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : NoMaxOrder Œ±]\n  [inst_4 : NoMinOrder Œ±] {a : Œ±} {s : Set Œ±},\n  (s ‚àà nhds a : Prop) ‚Üî (‚àÉ (l : Œ±), ‚àÉ (u : Œ±), (a ‚àà Set.Ioo l u : Prop) ‚àß (Set.Ioo l u ‚äÜ s : Prop) : Prop)","name":"mem_nhds_iff_exists_Ioo_subset","isProp":true,"docString":"A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.\n"},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] {X : C} {Y : C} (f : X ‚ü∂ Y) (Z : C)\n  (l :\n    CategoryTheory.Limits.IsColimit\n      (CategoryTheory.Limits.CokernelCofork.ofœÄ 0\n        (let_fun this : f ‚â´ 0 = 0 :=\n            ((of_eq_true\n                  ((Eq.trans\n                        ((congrFun\n                              ((congrArg Eq\n                                    ((CategoryTheory.Limits.comp_zero=:f ‚â´ 0 =\n                                          0)=:f ‚â´ 0 = 0)=:Eq (f ‚â´ 0) = Eq 0)=:Eq (f ‚â´ 0) = Eq 0)\n                              0=:(f ‚â´ 0 = 0 : Prop) = (0 = 0 : Prop))=:(f ‚â´ 0 = 0 : Prop) = (0 = 0 : Prop))\n                        ((eq_self\n                              0=:(0 = 0 : Prop) =\n                              (True :\n                                Prop))=:(0 = 0 : Prop) =\n                            (True :\n                              Prop))=:(f ‚â´ 0 = 0 : Prop) =\n                        (True : Prop))=:(f ‚â´ 0 = 0 : Prop) = (True : Prop))=:f ‚â´ 0 = 0)=:f ‚â´ 0 = 0);\n          this=:f ‚â´ 0 = 0))),\n  CategoryTheory.Epi f","name":"CategoryTheory.NormalMonoCategory.epi_of_zero_cokernel","isProp":true,"docString":"If a zero morphism is a cokernel of `f`, then `f` is an epimorphism. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : CompactIccSpace Œ±] {a : Œ±} {b : Œ±},\n  IsCompact (Set.uIcc a b)","name":"isCompact_uIcc","isProp":true,"docString":"An unordered closed interval is compact. "},{"type":"‚àÄ (x : ‚Ñ§) (y : ‚Ñ§), ‚Üë(Int.gcd x y) = x * Int.gcdA x y + y * Int.gcdB x y","name":"Int.gcd_eq_gcd_ab","isProp":true,"docString":"**B√©zout's lemma** "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {Œ≤ : Type u'} [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  (f : (a : Œ≤) ‚Üí C) [inst_2 : CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor f)] (b : Œ≤),\n  CategoryTheory.IsSplitEpi (CategoryTheory.Limits.Pi.œÄ f b)","name":"CategoryTheory.Limits.isSplitEpi_pi_œÄ","isProp":true,"docString":"In the presence of zero morphisms, projections into a product are (split) epimorphisms. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (q : ‚Ñö) (r : ‚Ñö), padicNorm p (q * r) = padicNorm p q * padicNorm p r","name":"padicNorm.mul","isProp":true,"docString":"The `p`-adic norm is multiplicative. "},{"type":"‚àÄ {K : Type u} [inst : DivisionSemiring K], IsSimpleOrder (Ideal K)","name":"Ideal.isSimpleOrder","isProp":true,"docString":"Ideals of a `DivisionSemiring` are a simple order. Thanks to the way abbreviations work,\nthis automatically gives a `IsSimpleModule K` instance. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonUnitalNonAssocRing Œ±]\n  [inst_1 : OrderedSemiring Œ≤] [self : RingSeminormClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a * b) ‚â§ ‚Üëf a * ‚Üëf b","name":"RingSeminormClass.map_mul_le_mul","isProp":true,"docString":"the image of a product is less or equal than the product of the images. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (a : R) (n : ‚Ñï),\n  Polynomial.rootMultiplicity a ((Polynomial.X - ‚ÜëPolynomial.C a) ^ n) = n","name":"Polynomial.rootMultiplicity_X_sub_C_pow","isProp":true,"docString":"The multiplicity of `a` as root of `(X - a) ^ n` is `n`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} [inst : AddCommMonoid Œ≤] (f : (a : Œ±) ‚Üí Œ≤) {p : (a : Œ±) ‚Üí Prop}\n  [inst_1 : DecidablePred p] (h : ‚àÄ (x : Œ±) (a : x ‚àà s), p x),\n  (Finset.sum (Finset.subtype p s) fun (x : Subtype p) ‚Ü¶ f ‚Üëx) = Finset.sum s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.sum_subtype_of_mem","isProp":true,"docString":"If all elements of a `Finset` satisfy the predicate `p`, a sum\nover `s.subtype p` equals that sum over `s`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : MeasurableEmbedding f), Function.Injective f","name":"MeasurableEmbedding.injective","isProp":true,"docString":"A measurable embedding is injective. "},{"type":"‚àÄ {M : Type u_1} {Œ± : Type u_2} [inst : SMul M Œ±] [inst_1 : SMul M·µê·µí·µñ Œ±] [self : IsCentralScalar M Œ±] (m : M) (a : Œ±),\n  { unop := m } ‚Ä¢ a = m ‚Ä¢ a","name":"IsCentralScalar.op_smul_eq_smul","isProp":true,"docString":"The right and left actions of `M` on `Œ±` are equal. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i) < Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i : Prop) ‚Üî\n    (¬¨(AntivaryOn (f ‚àò ‚ÜëœÉ) g ‚Üës : Prop) : Prop)","name":"AntivaryOn.sum_mul_lt_sum_comp_perm_mul_iff","isProp":true,"docString":"**Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f ‚àò œÉ` and `g` do not antivary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atBot),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atTop : Prop) ‚Üî (r < 0 : Prop)","name":"Filter.tendsto_mul_const_atTop_iff_neg","isProp":true,"docString":"If `f` tends to negative infinity along a nontrivial filter `l`, then `Œª x, f x * r` tends to\ninfinity if and only if `r < 0. `"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ±‚ÇÇ : Type u_3} [inst : Semiring Œ≤] [inst_1 : Zero Œ±] [inst_2 : Zero Œ±‚ÇÇ] {F : Type u_4}\n  [inst_3 : ZeroHomClass F Œ± Œ±‚ÇÇ] (f : F), AddMonoidAlgebra.mapDomain (‚Üëf) 1 = 1","name":"AddMonoidAlgebra.mapDomain_one","isProp":true,"docString":"Like `Finsupp.mapDomain_zero`, but for the `1` we define in this file "},{"type":"‚àÄ {m : Type u_1} {A : Type u_2} [inst : Fintype m] [inst_1 : CommRing A] [inst_2 : IsDomain A] [inst_3 : DecidableEq m]\n  {M : Matrix m m A} (hM : Matrix.det M ‚â† 0), Matrix.Nondegenerate M","name":"Matrix.nondegenerate_of_det_ne_zero","isProp":true,"docString":"If `M` has a nonzero determinant, then `M` as a bilinear form on `n ‚Üí A` is nondegenerate.\n\nSee also `BilinForm.nondegenerateOfDetNeZero'` and `BilinForm.nondegenerateOfDetNeZero`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (a : IsClopen s), frontier s = ‚àÖ","name":"IsClopen.frontier_eq","isProp":true,"docString":"**Alias** of the forward direction of `isClopen_iff_frontier_eq_empty`."},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú) (i : Fin r ‚äï Unit),\n  Matrix.mul M (List.prod (Matrix.Pivot.listTransvecRow M)) i (Sum.inr ()) = M i (Sum.inr ())","name":"Matrix.Pivot.mul_listTransvecRow_last_col","isProp":true,"docString":"Multiplying by all the matrices in `listTransvecRow M` does not change the last column. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} (a : Disjoint s t), s ‚äÜ t·∂ú","name":"Disjoint.subset_compl_right","isProp":true,"docString":"**Alias** of the reverse direction of `Set.subset_compl_iff_disjoint_right`."},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {f : M ‚Üí* N} {g : M ‚Üí* N},\n  (f = g : Prop) ‚Üî (‚àÄ (x : M), ‚Üëf x = ‚Üëg x : Prop)","name":"MonoidHom.ext_iff","isProp":true,"docString":"Deprecated: use `FunLike.ext_iff` instead. "},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L","name":"FreeGroup.reduce.self","isProp":true,"docString":"A word and its maximal reduction correspond to the same element of the free group. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hf : Monotone f) (hx : x ‚â§ f x),\n  Monotone fun (n : ‚Ñï) ‚Ü¶ (f^[n]) x","name":"Monotone.monotone_iterate_of_le_map","isProp":true,"docString":"If `f` is a monotone map and `x ‚â§ f x` at some point `x`, then the iterates `f^[n] x` form\na monotone sequence. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {r : ‚Ñï} (hùíú : Set.Sized r ‚Üëùíú),\n  Set.Sized (r - 1) ‚Üë(Finset.shadow ùíú)","name":"Finset.Set.Sized.shadow","isProp":true,"docString":"The shadow of a family of `r`-sets is a family of `r - 1`-sets. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : CompleteLattice Œ±] {f : Filter Œ≤} {u : (a : Œ≤) ‚Üí Œ±},\n  Filter.limsup u f = inf·µ¢ fun (s : Set Œ≤) ‚Ü¶ inf·µ¢ fun (h : s ‚àà f) ‚Ü¶ sup·µ¢ fun (a : Œ≤) ‚Ü¶ sup·µ¢ fun (h : a ‚àà s) ‚Ü¶ u a","name":"Filter.limsup_eq_inf·µ¢_sup·µ¢","isProp":true,"docString":"In a complete lattice, the limsup of a function is the infimum over sets `s` in the filter\nof the supremum of the function over `s` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : ClosedEmbedding f), IsClosed (Set.range f)","name":"ClosedEmbedding.closed_range","isProp":true,"docString":"The range of a closed embedding is a closed set. "},{"type":"‚àÄ {m : (a : Type u) ‚Üí Type v} [inst : Applicative m] [self : CommApplicative m] {Œ± : Type u} {Œ≤ : Type u} (a : m Œ±)\n  (b : m Œ≤),\n  (Seq.seq (Prod.mk <$> a) fun (x : Unit) ‚Ü¶ b) = Seq.seq ((fun (b : Œ≤) (a : Œ±) ‚Ü¶ (a, b)) <$> b) fun (x : Unit) ‚Ü¶ a","name":"CommApplicative.commutative_prod","isProp":true,"docString":"Computations performed first on `a : Œ±` and then on `b : Œ≤` are equal to those performed in\nthe reverse order. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : sbtw a b c), ¬¨(sbtw c b a : Prop)","name":"SBtw.sbtw.not_sbtw","isProp":true,"docString":"**Alias** of `sbtw_asymm`."},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {J : Ideal R} {I : Ideal S} {f : R ‚Üí+* S}\n  {H : J ‚â§ Ideal.comap f I} (h : Ideal.comap f I ‚â§ J), Function.Injective ‚Üë(Ideal.quotientMap I f H)","name":"Ideal.quotientMap_injective'","isProp":true,"docString":"`H` and `h` are kept as separate hypothesis since H is used in constructing the quotient map. "},{"type":"‚àÄ {Œ± : Type u_1} {E' : Type u_2} {F' : Type u_3} [inst : SeminormedAddCommGroup E'] [inst_1 : SeminormedAddCommGroup F']\n  {f' : (a : Œ±) ‚Üí E'} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =O[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ),\n  f' =O[l] g'","name":"Asymptotics.IsBigO.of_norm_norm","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigO_norm_norm`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] [inst_4 : TopologicalSpace Œ≤] [inst_5 : Zero Œ±] {f : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f)\n  (h : HasCompactSupport f), BddAbove (Set.range f)","name":"Continuous.bddAbove_range_of_hasCompactSupport","isProp":true,"docString":"A continuous function with compact support is bounded above. "},{"type":"‚àÄ (n : ‚Ñï) (z : ‚ÑÇ),\n  (Complex.cos z + Complex.sin z * Complex.I) ^ n = Complex.cos (‚Üën * z) + Complex.sin (‚Üën * z) * Complex.I","name":"Complex.cos_add_sin_mul_I_pow","isProp":true,"docString":"**De Moivre's formula** "},{"type":"‚àÄ {M : Type u_1} [inst : AddSemigroup M] [inst_1 : Nonempty M] (s : Set (Set M)) (sfin : Set.Finite s)\n  (scov : ‚ä§ ‚äÜ ‚ãÉ‚ÇÄ s), ‚àÉ (c : Set M), (c ‚àà s : Prop) ‚àß (‚àÉ (a : Stream' M), Hindman.FS a ‚äÜ c : Prop)","name":"Hindman.exists_FS_of_finite_cover","isProp":true,"docString":"The weak form of **Hindman's theorem**: in any finite cover\nof a nonempty additive semigroup, one of the parts contains an FS-set."},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [self : CommGroupWithZero G‚ÇÄ] (n : ‚Ñï) (a : G‚ÇÄ),\n  CommGroupWithZero.zpow (Int.ofNat (Nat.succ n)) a = a * CommGroupWithZero.zpow (Int.ofNat n) a","name":"CommGroupWithZero.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} (hf : Monotone f) (n : ‚Ñï) {x : Œ±} (h1 : f n < x)\n  (h2 : x < f (n + 1)) (a : ‚Ñï), f a ‚â† x","name":"Monotone.ne_of_lt_of_lt_nat","isProp":true,"docString":"If `f` is a monotone function from `‚Ñï` to a preorder such that `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ≤] [inst_5 : One Œ±] {f : (a : Œ≤) ‚Üí Œ±}\n  (hf : Continuous f) (h : HasCompactMulSupport f), ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f x ‚â§ f y","name":"Continuous.exists_forall_le_of_hasCompactMulSupport","isProp":true,"docString":"A continuous function with compact support has a global minimum. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±], 0‚Åª¬π = 0","name":"CanonicallyLinearOrderedSemifield.inv_zero","isProp":true,"docString":"The inverse of `0` in a group with zero is `0`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} (f : P ‚ü∂ Q) [inst_1 : CategoryTheory.IsIso f],\n  CategoryTheory.StrongEpi f","name":"CategoryTheory.strongEpi_of_isIso","isProp":true,"docString":"An isomorphism is in particular a strong epimorphism. "},{"type":"‚àÄ {Œ± : Type u} {f : Filter Œ±} {Œ≤ : Type v} {s : (a : Œ≤) ‚Üí Set Œ±} (is : Finset Œ≤),\n  ((Set.inter·µ¢ fun (i : Œ≤) ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà is) ‚Ü¶ s i) ‚àà f : Prop) ‚Üî (‚àÄ (i : Œ≤) (a : i ‚àà is), s i ‚àà f : Prop)","name":"Finset.inter·µ¢_mem_sets","isProp":true,"docString":"**Alias** of `Filter.binter·µ¢_finset_mem`."},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] {œÜ : MvPolynomial œÉ R}\n  {n : M} [inst_2 : SemilatticeSup M] {w : (a : œÉ) ‚Üí M} (hœÜ : MvPolynomial.IsWeightedHomogeneous w œÜ n) (h : œÜ ‚â† 0),\n  MvPolynomial.weightedTotalDegree' w œÜ = ‚Üën","name":"MvPolynomial.IsWeightedHomogeneous.weighted_total_degree","isProp":true,"docString":"A non zero weighted homogeneous polynomial of weighted degree `n` has weighted total degree\n`n`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommMonoid Œ±] {m : Multiset Œ±} (h : ‚àÄ (x : Œ±) (a : x ‚àà m), x = 0), Multiset.sum m = 0","name":"Multiset.sum_eq_zero","isProp":true,"docString":"Slightly more general version of `Multiset.sum_eq_zero_iff` for a non-ordered `AddMonoid`"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (Z : (a : ‚Ñï) ‚Üí Set Œ±) (hZd : ‚àÄ (i : ‚Ñï), Z (i + 1) ‚äÜ Z i)\n  (hZn : ‚àÄ (i : ‚Ñï), Set.Nonempty (Z i)) (hZ0 : IsCompact (Z 0)) (hZcl : ‚àÄ (i : ‚Ñï), IsClosed (Z i)),\n  Set.Nonempty (Set.inter·µ¢ fun (i : ‚Ñï) ‚Ü¶ Z i)","name":"IsCompact.nonempty_inter·µ¢_of_sequence_nonempty_compact_closed","isProp":true,"docString":"Cantor's intersection theorem for sequences indexed by `‚Ñï`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. "},{"type":"¬¨(Class.univ ‚àà Class.univ : Prop)","name":"Class.univ_not_mem_univ","isProp":true,"docString":"**There is no universal set.**\nThis is stated as `univ ‚àâ univ`, meaning that `univ` (the class of all sets) is proper (does not\nbelong to the class of all sets). "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P) (direction : Submodule k V),\n  AffineSubspace.direction (AffineSubspace.mk' p direction) = direction","name":"AffineSubspace.direction_mk'","isProp":true,"docString":"The direction of an affine subspace constructed from a point and a direction. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : DecidableEq Œ±] {A : Finset Œ±} (hA : Finset.Nonempty A) (B : Finset Œ±)\n  (n : ‚Ñï), ‚Üë(Finset.card (n ‚Ä¢ B)) ‚â§ (‚Üë(Finset.card (A + B)) / ‚Üë(Finset.card A)) ^ n * ‚Üë(Finset.card A)","name":"Finset.card_nsmul_le","isProp":true,"docString":"Special case of the **Pl√ºnnecke-Ruzsa inequality**. Addition version."},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {Œπ : Type u_3} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E]\n  [inst_2 : Module R E] {s : Set E} {t : Finset Œπ} {w : (a : Œπ) ‚Üí R} {z : (a : Œπ) ‚Üí E} (hs : Convex R s)\n  (a : ‚àÄ (i : Œπ) (a : i ‚àà t), 0 ‚â§ w i) (a : 0 < Finset.sum t fun (i : Œπ) ‚Ü¶ w i) (a : ‚àÄ (i : Œπ) (a : i ‚àà t), z i ‚àà s),\n  Finset.centerMass t w z ‚àà s","name":"Convex.centerMass_mem","isProp":true,"docString":"The center of mass of a finite subset of a convex set belongs to the set\nprovided that all weights are non-negative, and the total weight is positive. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±} {t : Set Œ±} {r : ENNReal} (h : x ‚àà s)\n  (H : EMetric.hausdorffEdist s t < r), ‚àÉ (y : Œ±), (y ‚àà t : Prop) ‚àß (edist x y < r : Prop)","name":"EMetric.exists_edist_lt_of_hausdorffEdist_lt","isProp":true,"docString":"If the Hausdorff distance is `< r`, then any point in one of the sets has\na corresponding point at distance `< r` in the other set "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : r < 0)\n  (hf : Filter.Tendsto f l Filter.atBot), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atTop","name":"Filter.Tendsto.neg_const_mul_atBot","isProp":true,"docString":"If a function tends to negative infinity along a filter, then this function multiplied by\na negative constant (on the left) tends to positive infinity. "},{"type":"‚àÄ (R : Type u) (M : Type v) [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Finite R M], ‚Üë(FiniteDimensional.finrank R M) = Module.rank R M","name":"FiniteDimensional.finrank_eq_rank","isProp":true,"docString":"If `M` is finite, `finrank M = rank M`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i","name":"AntivaryOn.sum_smul_le_sum_comp_perm_smul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when\n`f` and `g` antivary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X], T1Space (Alexandroff X)","name":"Alexandroff.instT1SpaceAlexandroffInstTopologicalSpaceAlexandroff","isProp":true,"docString":"The one point compactification of a `T1Space` space is a `T1Space`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : LE Œ±] [inst_1 : LE Œ≤]\n  [inst_2 : BoundedOrder Œ±] [inst_3 : BoundedOrder Œ≤] [self : BoundedOrderHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä§ = ‚ä§","name":"BoundedOrderHomClass.map_top","isProp":true,"docString":"Morphisms preserve the top element. The preferred spelling is `_root_.map_top`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : Set Œ±), E ‚äÜ Metric.thickening Œ¥ E","name":"Metric.self_subset_thickening","isProp":true,"docString":"A set is contained in its own (open) thickening. "},{"type":"‚àÄ {R : Type u_1} [inst : AddRightCancelSemigroup R] (g : R), IsAddRightRegular g","name":"isAddRightRegular_of_addRightCancelSemigroup","isProp":true,"docString":"Elements of an add right cancel semigroup are add-right-regular"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : NoMaxOrder Œ±]\n  {a : Œ±} {s : Set Œ±},\n  (s ‚àà nhdsWithin a (Set.Ici a) : Prop) ‚Üî (‚àÉ (u : Œ±), (u ‚àà Set.Ioi a : Prop) ‚àß (Set.Ico a u ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Ici_iff_exists_Ico_subset","isProp":true,"docString":"A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`\nwith `a < u`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : DistribLattice Œ±] (x : Œ±) (y : Œ±) (z : Œ±), (x ‚äî y) ‚äì (x ‚äî z) ‚â§ x ‚äî y ‚äì z","name":"DistribLattice.le_sup_inf","isProp":true,"docString":"The infimum distributes over the supremum "},{"type":"Multiset.Nat.antidiagonal 0 = {(0, 0)}","name":"Multiset.Nat.antidiagonal_zero","isProp":true,"docString":"The antidiagonal of `0` is the list `[(0, 0)]` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type u_1} {t : Set Œπ} {s : (a : Œπ) ‚Üí Set Œ±} (ht : Set.Nonempty t)\n  (H : ‚àÄ (i : Œπ) (a : i ‚àà t), IsConnected (s i))\n  (K :\n    ‚àÄ (i : Œπ) (a : i ‚àà t) (j : Œπ) (a : j ‚àà t),\n      Relation.ReflTransGen (fun (i : Œπ) (j : Œπ) ‚Ü¶ (Set.Nonempty (s i ‚à© s j) : Prop) ‚àß (i ‚àà t : Prop)) i j),\n  IsConnected (Set.union·µ¢ fun (n : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : n ‚àà t) ‚Ü¶ s n)","name":"IsConnected.bunion·µ¢_of_reflTransGen","isProp":true,"docString":"The bunion·µ¢ of a family of preconnected sets is preconnected if the graph determined by\nwhether two sets intersect is preconnected. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {M : (a : Polynomial R) ‚Üí Prop} (p : Polynomial R)\n  (h_add : ‚àÄ (p : Polynomial R) (q : Polynomial R) (a : M p) (a : M q), M (p + q))\n  (h_monomial : ‚àÄ (n : ‚Ñï) (a : R), M (‚Üë(Polynomial.monomial n) a)), M p","name":"Polynomial.induction_on'","isProp":true,"docString":"To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±} (a_1 : IsCoatom a), a ‚ãñ ‚ä§","name":"IsCoatom.covby_top","isProp":true,"docString":"**Alias** of the reverse direction of `covby_top_iff`."},{"type":"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R) {x : R} {y : R} (a : x ‚àà s) (a : y ‚àà s), x * y ‚àà s","name":"Subring.mul_mem","isProp":true,"docString":"A subring is closed under multiplication. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {a : R} {b : R}, a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)","name":"pow_four_add_four_mul_pow_four","isProp":true,"docString":"Sophie Germain's identity, see <https://www.cut-the-knot.org/blue/SophieGermainIdentity.shtml>.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C} {X : C} {Y : C} {Z : C} {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y}\n  (h : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.BinaryFan.mk fst snd))\n  (t : CategoryTheory.Limits.IsTerminal Z),\n  CategoryTheory.IsPullback fst snd (CategoryTheory.Limits.IsTerminal.from t X)\n    (CategoryTheory.Limits.IsTerminal.from t Y)","name":"CategoryTheory.IsPullback.of_is_product'","isProp":true,"docString":"A variant of `of_is_product` that is more useful with `apply`. "},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module R E] [inst_4 : Module R F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : ContinuousAdd E] [inst_8 : ContinuousAdd F] [inst_9 : TopologicalSpace R] [inst_10 : ContinuousSMul R E]\n  [inst_11 : ContinuousSMul R F] {f : E ‚Üí‚Çó.[R] F} (hf : LinearPMap.IsClosable f),\n  Submodule.topologicalClosure (LinearPMap.graph f) = LinearPMap.graph (LinearPMap.closure f)","name":"LinearPMap.IsClosable.graph_closure_eq_closure_graph","isProp":true,"docString":"The closure (as a submodule) of the graph is equal to the graph of the closure\n(as a `LinearPMap`). "},{"type":"‚àÄ {Œ≤ : Type v} {Œ± : Type u_1} [inst : DecidableEq Œ±] (œÉ : (a : Œ±) ‚Üí Equiv.Perm Œ≤) {l : List Œ±} (hl : List.Nodup l)\n  (mem_l : ‚àÄ (a : Œ±), a ‚àà l),\n  List.prod (List.map (fun (a : Œ±) ‚Ü¶ Equiv.Perm.prodExtendRight a (œÉ a)) l) = Equiv.prodCongrRight œÉ","name":"Equiv.Perm.prod_prodExtendRight","isProp":true,"docString":"If we apply `prod_extendRight a (œÉ a)` for all `a : Œ±` in turn,\nwe get `prod_congrRight œÉ`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C), CategoryTheory.IsPullback 0 (ùüô X) 0 0","name":"CategoryTheory.IsPullback.zero_right","isProp":true,"docString":"The square with `0 : 0 ‚ü∂ 0` on the right and `ùüô X` on the left is a pullback square. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  (R‚Çò : Type u_3) (S‚Çò : Type u_4) [inst_3 : CommRing R‚Çò] [inst_4 : CommRing S‚Çò] [inst_5 : Algebra R R‚Çò]\n  [inst_6 : IsLocalization M R‚Çò] [inst_7 : Algebra S S‚Çò] [i : IsLocalization (Algebra.algebraMapSubmonoid S M) S‚Çò]\n  (hRS : Function.Injective ‚Üë(algebraMap R S)), Function.Injective ‚Üë(algebraMap R‚Çò S‚Çò)","name":"localizationAlgebra_injective","isProp":true,"docString":"Injectivity of the underlying `algebraMap` descends to the algebra induced by localization. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (p : X ‚ü∂ Y) (q : Z = Y),\n  cast ((congrArg (fun (W : C) ‚Ü¶ X ‚ü∂ W) ((Eq.symm q=:Y = Z)=:Y = Z)=:(X ‚ü∂ Y) = (X ‚ü∂ Z))=:(X ‚ü∂ Y) = (X ‚ü∂ Z)) p =\n    p ‚â´ CategoryTheory.eqToHom ((Eq.symm q=:Y = Z)=:Y = Z)","name":"CategoryTheory.congrArg_cast_hom_right","isProp":true,"docString":"Reducible form of `congrArg_mpr_hom_right` "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a < b), a - b < 0","name":"sub_neg_of_lt","isProp":true,"docString":"**Alias** of the reverse direction of `sub_neg`."},{"type":"‚àÄ (r : ‚Ñù) (h : r ‚â† 0), (Real.sign r = -1 : Prop) ‚à® (Real.sign r = 1 : Prop)","name":"Real.sign_apply_eq_of_ne_zero","isProp":true,"docString":"This lemma is useful for working with `‚ÑùÀ£` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {s : Set Œ±}\n  (ha : IsLUB s a) (hs : Set.Nonempty s) (sc : IsClosed s), a ‚àà s","name":"IsClosed.isLUB_mem","isProp":true,"docString":"**Alias** of `IsLUB.mem_of_isClosed`."},{"type":"‚àÄ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G} (h‚ÇÄ : 0 < a)\n  (hd : Disjoint (‚ÜëH) (Set.Ioo 0 a)), ‚àÉ (b : G), H = AddSubgroup.closure {b}","name":"AddSubgroup.cyclic_of_isolated_zero","isProp":true,"docString":"If an additive subgroup of a linear ordered additive commutative group is disjoint with the\ninterval `Set.Ioo 0 a` for some positive `a`, then this is a cyclic subgroup. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] {s : Set Œ±} (hs : Dense s) (x : Œ±)\n  [inst_2 : Filter.NeBot (nhdsWithin x ({x}·∂ú))], Dense (s \\ {x})","name":"Dense.diff_singleton","isProp":true,"docString":"Removing a non-isolated point from a dense set, one still obtains a dense set. "},{"type":"‚àÄ {R : Type u} [self : AddCommGroupWithOne R] (n : ‚Ñï), IntCast.intCast (Int.negSucc n) = -‚Üë(n + 1)","name":"AddCommGroupWithOne.intCast_negSucc","isProp":true,"docString":"The canonical homorphism `‚Ñ§ ‚Üí R` for negative values is just the negation of the values\nof the canonical homomorphism `‚Ñï ‚Üí R`. "},{"type":"‚àÄ {a : Prop} {b : Prop} (self : (a : Prop) ‚àß (b : Prop)), b","name":"And.right","isProp":true,"docString":"Extract the right conjunct from a conjunction. `h : a ‚àß b` then\n`h.right`, also notated as `h.2`, is a proof of `b`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : r < 0),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atBot : Prop) ‚Üî (Filter.Tendsto f l Filter.atTop : Prop)","name":"Filter.tendsto_mul_const_atBot_of_neg","isProp":true,"docString":"If `r` is a negative constant, then `Œª x, f x * r` tends to negative infinity along a filter if\nand only if `f` tends to infinity along the same filter. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] [inst_1 : DecidableRel Disjoint]\n  [inst_2 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {s : Finset Œ±} {u : Œ±} {v : Œ±} {a : Œ±},\n  (a ‚àà UV.compression u v s : Prop) ‚Üî\n    (((a ‚àà s : Prop) ‚àß (UV.compress u v a ‚àà s : Prop) : Prop) ‚à®\n        ((¬¨(a ‚àà s : Prop) : Prop) ‚àß (‚àÉ (b : Œ±), (b ‚àà s : Prop) ‚àß (UV.compress u v b = a : Prop) : Prop) : Prop) :\n      Prop)","name":"UV.mem_compression","isProp":true,"docString":"`a` is in the UV-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. "},{"type":"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] {e : LocalHomeomorph H H},\n  (e ‚àà atlas : Prop) ‚Üî (e = LocalHomeomorph.refl H : Prop)","name":"chartedSpaceSelf_atlas","isProp":true,"docString":"In the trivial `ChartedSpace` structure of a space modelled over itself through the identity,\nthe atlas members are just the identity. "},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±), a * b * c = a * (b * c)","name":"NonUnitalSemiring.mul_assoc","isProp":true,"docString":"Multiplication is associative "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 ‚â§ a) (hb : 0 ‚â§ b), 0 ‚â§ a + b","name":"Left.add_nonneg","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonneg`."},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, ‚Üë1 = 1","name":"Con.coe_one","isProp":true,"docString":"The 1 of the quotient of a monoid by a congruence relation is the equivalence class of the\nmonoid's 1. "},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E} (hs : Set.Finite s),\n  IsCompact (‚Üë(ClosureOperator.toOrderHom (convexHull ‚Ñù)) s)","name":"Set.Finite.isCompact_convexHull","isProp":true,"docString":"Convex hull of a finite set is compact. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\n  FiniteDimensional K { x : V‚ÇÇ // x ‚àà LinearMap.range f }","name":"LinearMap.finiteDimensional_range","isProp":true,"docString":"The range of a linear map defined on a finite-dimensional space is also finite-dimensional. "},{"type":"‚àÄ {n : ‚Ñï} {x : Fin (n + 1)} {y : Fin (n + 1)}, (Fin.succAbove x = Fin.succAbove y : Prop) ‚Üî (x = y : Prop)","name":"Fin.succAbove_left_inj","isProp":true,"docString":"`succAbove` is injective at the pivot "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {A : Set E}\n  [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul ùïú E] (hA : A ‚àà nhds 0), Absorbent ùïú A","name":"absorbent_nhds_zero","isProp":true,"docString":"Every neighbourhood of the origin is absorbent. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (G : C ‚•§ D)\n  [inst_2 : CategoryTheory.Limits.HasInitial C]\n  [inst : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G], CategoryTheory.Limits.HasInitial D","name":"CategoryTheory.Limits.hasInitial_of_hasInitial_of_preservesColimit","isProp":true,"docString":"If `C` has a initial object and `G` preserves initial objects, then `D` has a initial object\nalso.\nNote this property is somewhat unique to colimits of the empty diagram: for general `J`, if `C`\nhas colimits of shape `J` and `G` preserves them, then `D` does not necessarily have colimits of\nshape `J`.\n"},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) (hf : ‚àÄ (Z : C) (g : Y ‚ü∂ Z) (x : f ‚â´ g = 0), g = 0), CategoryTheory.Epi f","name":"CategoryTheory.NormalMonoCategory.epi_of_zero_cancel","isProp":true,"docString":"If `f ‚â´ g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. "},{"type":"‚àÄ {Œπ : Type u_1} {p : (a : BoxIntegral.Box Œπ) ‚Üí Prop} (I : BoxIntegral.Box Œπ)\n  (H_ind : ‚àÄ (J : BoxIntegral.Box Œπ) (a : J ‚â§ I) (a : ‚àÄ (s : Set Œπ), p (BoxIntegral.Box.splitCenterBox J s)), p J)\n  (H_nhds :\n    ‚àÄ (z : (a : Œπ) ‚Üí ‚Ñù) (a : z ‚àà ‚ÜëBoxIntegral.Box.Icc I),\n      ‚àÉ (U : Set ((a : Œπ) ‚Üí ‚Ñù)),\n        (U ‚àà nhdsWithin z (‚ÜëBoxIntegral.Box.Icc I) : Prop) ‚àß\n          (‚àÄ (J : BoxIntegral.Box Œπ) (a : J ‚â§ I) (m : ‚Ñï) (a : z ‚àà ‚ÜëBoxIntegral.Box.Icc J)\n              (a : ‚ÜëBoxIntegral.Box.Icc J ‚äÜ U)\n              (a :\n                ‚àÄ (i : Œπ),\n                  BoxIntegral.Box.upper J i - BoxIntegral.Box.lower J i =\n                    (BoxIntegral.Box.upper I i - BoxIntegral.Box.lower I i) / 2 ^ m),\n              p J :\n            Prop)),\n  p I","name":"BoxIntegral.Box.subbox_induction_on'","isProp":true,"docString":"Let `p` be a predicate on `Box Œπ`, let `I` be a box. Suppose that the following two properties\nhold true.\n\n* `H_ind` : Consider a smaller box `J ‚â§ I`. The hyperplanes passing through the center of `J` split\n  it into `2 ^ n` boxes. If `p` holds true on each of these boxes, then it true on `J`.\n\n* `H_nhds` : For each `z` in the closed box `I.Icc` there exists a neighborhood `U` of `z` within\n  `I.Icc` such that for every box `J ‚â§ I` such that `z ‚àà J.Icc ‚äÜ U`, if `J` is homothetic to `I`\n  with a coefficient of the form `1 / 2 ^ m`, then `p` is true on `J`.\n\nThen `p I` is true. See also `BoxIntegral.Box.subbox_induction_on` for a version using\n`BoxIntegral.Prepartition.splitCenter` instead of `BoxIntegral.Box.splitCenterBox`.\n\nThe proof still works if we assume `H_ind` only for subboxes `J ‚â§ I` that are homothetic to `I` with\na coefficient of the form `2‚Åª·µê` but we do not need this generalization yet. "},{"type":"‚àÄ {Œπ : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (b : Basis Œπ R M) {R‚ÇÅ : Type u_2} [inst_3 : Semiring R‚ÇÅ] {œÉ : R ‚Üí+* R‚ÇÅ} {œÉ' : R‚ÇÅ ‚Üí+* R} [inst_4 : RingHomInvPair œÉ œÉ']\n  [inst_5 : RingHomInvPair œÉ' œÉ] {M‚ÇÅ : Type u_4} [inst_6 : AddCommMonoid M‚ÇÅ] [inst_7 : Module R‚ÇÅ M‚ÇÅ] {f‚ÇÅ : M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÅ}\n  {f‚ÇÇ : M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÅ} (h : ‚àÄ (i : Œπ), ‚Üëf‚ÇÅ (‚Üëb i) = ‚Üëf‚ÇÇ (‚Üëb i)), f‚ÇÅ = f‚ÇÇ","name":"Basis.ext'","isProp":true,"docString":"Two linear equivs are equal if they are equal on basis vectors. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] (U : Set Œ≤),\n  Quotient.mk' ‚Åª¬π' (Quotient.mk' '' U) = Set.union·µ¢ fun (a : Œ±) ‚Ü¶ (fun (x : Œ±) (x_1 : Œ≤) ‚Ü¶ x ‚Ä¢ x_1) a '' U","name":"MulAction.quotient_preimage_image_eq_union_mul","isProp":true,"docString":"When you take a set `U` in `Œ≤`, push it down to the quotient, and pull back, you get the union\nof the orbit of `U` under `Œ±`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (incl : s ‚äÜ t) (a : Metric.Bounded t),\n  Metric.Bounded s","name":"Metric.Bounded.mono","isProp":true,"docString":"Subsets of a bounded set are also bounded "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g] [inst_2 : CategoryTheory.Mono g],\n  CategoryTheory.Mono CategoryTheory.Limits.pullback.fst","name":"CategoryTheory.Limits.pullback.fst_of_mono","isProp":true,"docString":"The pullback of a monomorphism is a monomorphism "},{"type":"‚àÄ {Œ± : Type u} (s : Set Œ±) [inst : Finite ‚Üës], Set.Finite s","name":"Set.toFinite","isProp":true,"docString":"Constructor for `Set.Finite` using a `Finite` instance. "},{"type":"‚àÄ {A : Type u_2} {B : Type u_1} [i : SetLike A B] {p : A} {q : A} (h : ‚àÄ (x : B), (x ‚àà p : Prop) ‚Üî (x ‚àà q : Prop)),\n  p = q","name":"SetLike.ext","isProp":true,"docString":"Note: implementers of `SetLike` must copy this lemma in order to tag it with `@[ext]`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (s : Set Œ±), Continuous fun (x : Œ±) ‚Ü¶ Metric.infNndist x s","name":"Metric.continuous_infNndist_pt","isProp":true,"docString":"The minimal distance to a set (as `‚Ñù‚â•0`) is continuous in point "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasLimits C],\n  CategoryTheory.Limits.HasFiniteLimits C","name":"CategoryTheory.Limits.hasFiniteLimits_of_hasLimits","isProp":true,"docString":"If `C` has all limits, it has finite limits. "},{"type":"‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  {f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ}\n  (h :\n    ‚àÄ (u : { x : M // x ‚àà LinearMap.ker f } ‚Üí‚Çó[R] M) (v : { x : M // x ‚àà LinearMap.ker f } ‚Üí‚Çó[R] M)\n      (a : LinearMap.comp f u = LinearMap.comp f v), u = v),\n  LinearMap.ker f = ‚ä•","name":"LinearMap.ker_eq_bot_of_cancel","isProp":true,"docString":"A monomorphism is injective. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C),\n  CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Œπ 0)","name":"CategoryTheory.Limits.kernel.Œπ_of_zero","isProp":true,"docString":"The kernel morphism of a zero morphism is an isomorphism "},{"type":"‚àÄ {G : Type u_2} {H : Type u_1} [inst : Add G] [inst_1 : Add H] {A : Finset G} {B : Finset G} {a0 : G} {b0 : G}\n  [inst_2 : DecidableEq H] (f : AddHom G H) (hf : Function.Injective ‚Üëf),\n  (UniqueAdd (Finset.image (‚Üëf) A) (Finset.image (‚Üëf) B) (‚Üëf a0) (‚Üëf b0) : Prop) ‚Üî (UniqueAdd A B a0 b0 : Prop)","name":"UniqueAdd.addHom_image_iff","isProp":true,"docString":"`UniqueAdd` is preserved under additive maps that are injective.\n\nSee `UniqueAdd.addHom_map_iff` for a version with swapped bundling."},{"type":"‚àÄ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M","name":"ChartedSpace.locallyConnectedSpace","isProp":true,"docString":"If a topological space admits an atlas with locally connected charts, then the space itself is\nlocally connected. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (R : D ‚•§ C)\n  [inst_2 : CategoryTheory.Limits.HasLimitsOfSize C] [inst : CategoryTheory.Reflective R],\n  CategoryTheory.Limits.HasLimitsOfSize D","name":"CategoryTheory.has_limits_of_reflective","isProp":true,"docString":"If `C` has limits then any reflective subcategory has limits. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : AddGroup Œ±] (e : Œ±) (x : Finset Œ± √ó Finset Œ±),\n  Finset.card (Prod.fst (Finset.addEtransformLeft e x)) + Finset.card (Prod.snd (Finset.addEtransformLeft e x)) +\n      (Finset.card (Prod.fst (Finset.addEtransformRight e x)) +\n        Finset.card (Prod.snd (Finset.addEtransformRight e x))) =\n    Finset.card (Prod.fst x) + Finset.card (Prod.snd x) + (Finset.card (Prod.fst x) + Finset.card (Prod.snd x))","name":"Finset.AddEtransform.card","isProp":true,"docString":"This statement is meant to be combined with\n`le_or_lt_of_add_le_add` and similar lemmas."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b) (a_1 : ¬¨(a ‚ãñ b : Prop)),\n  ‚àÉ (c : Œ±), (a < c : Prop) ‚àß (c < b : Prop)","name":"LT.lt.exists_lt_lt","isProp":true,"docString":"**Alias** of `exists_lt_lt_of_not_covby`."},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (S : Set M)\n  (h : Set.Finite S), CompleteLattice.IsCompactElement (Submodule.span R S)","name":"Submodule.finite_span_isCompactElement","isProp":true,"docString":"The span of a finite subset is compact in the lattice of submodules. "},{"type":"‚àÄ {Œ± : Type u_1} {p : (s : Finset Œ±) ‚Üí (a : Finset.Nonempty s) ‚Üí Prop}\n  (h‚ÇÄ : ‚àÄ (a : Œ±), p {a} ((Finset.singleton_nonempty a=:Finset.Nonempty {a})=:Finset.Nonempty {a}))\n  (h‚ÇÅ :\n    ‚àÄ ‚¶Éa : Œ±‚¶Ñ (s : Finset Œ±) (h : ¬¨(a ‚àà s : Prop)) (hs : Finset.Nonempty s) (a_1 : p s hs),\n      p (Finset.cons a s h)\n        ((Finset.nonempty_cons h=:Finset.Nonempty (Finset.cons a s h))=:Finset.Nonempty (Finset.cons a s h)))\n  {s : Finset Œ±} (hs : Finset.Nonempty s), p s hs","name":"Finset.Nonempty.cons_induction","isProp":true,"docString":"To prove a proposition about a nonempty `s : Finset Œ±`, it suffices to show it holds for all\nsingletons and that if it holds for nonempty `t : Finset Œ±`, then it also holds for the `Finset`\nobtained by inserting an element in `t`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : CompleteLattice Œ±]\n  [inst_1 : CompleteLattice Œ≤] [self : CompleteLatticeHomClass F Œ± Œ≤] (f : F) (s : Set Œ±), ‚Üëf (sup‚Çõ s) = sup‚Çõ (‚Üëf '' s)","name":"CompleteLatticeHomClass.map_sup‚Çõ","isProp":true,"docString":"The proposition that members of `CompleteLatticeHomClass` commute with arbitrary\nsuprema/joins. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±], (DiscreteTopology Œ± : Prop) ‚Üî (‚àÄ (x : Œ±), nhds x = pure x : Prop)","name":"discreteTopology_iff_nhds","isProp":true,"docString":"This lemma characterizes discrete topological spaces as those whose singletons are\nneighbourhoods. "},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (hab : Nat.coprime a b), Nat.factors (a * b) ~ Nat.factors a ++ Nat.factors b","name":"Nat.perm_factors_mul_of_coprime","isProp":true,"docString":"For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P} (h : p‚ÇÅ ‚â† p‚ÇÇ), AffineIndependent k ![p‚ÇÅ, p‚ÇÇ]","name":"affineIndependent_of_ne","isProp":true,"docString":"Two different points are affinely independent. "},{"type":"‚àÄ {n : ‚Ñï} {Œ≤ : Type u_1} (a : Œ≤) (q : (a : Fin n) ‚Üí Œ≤) (b : Œ≤), Fin.cons a (Fin.snoc q b) = Fin.snoc (Fin.cons a q) b","name":"Fin.cons_snoc_eq_snoc_cons","isProp":true,"docString":"`cons` and `snoc` commute. We state this lemma in a non-dependent setting, as otherwise it\nwould involve a cast to convince Lean that the two types are equal, making it harder to use. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Encodable Œπ] {s : (a : Œπ) ‚Üí Set Œ±}\n  (hs : ‚àÄ (i : Œπ), IsGŒ¥ (s i)), IsGŒ¥ (Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ s i)","name":"isGŒ¥_inter·µ¢","isProp":true,"docString":"The intersection of an encodable family of GŒ¥ sets is a GŒ¥ set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] {n : ‚Ñ§} (hn : n ‚â† 0), Function.Injective fun (x : Œ±) ‚Ü¶ n ‚Ä¢ x","name":"zsmul_right_injective","isProp":true,"docString":"See also `smul_right_injective`. TODO: provide a `NoZeroSMulDivisors` instance. We can't do\nthat here because importing that definition would create import cycles."},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : AddCommMonoid Œ≤] {n : ‚Ñï} (f : (a : Fin (n + 1)) ‚Üí Œ≤),\n  (Finset.sum Finset.univ fun (i : Fin (n + 1)) ‚Ü¶ f i) =\n    (Finset.sum Finset.univ fun (i : Fin n) ‚Ü¶ f (‚ÜëFin.castSucc i)) + f (Fin.last n)","name":"Fin.sum_univ_castSucc","isProp":true,"docString":"A sum of a function `f : Fin (n + 1) ‚Üí Œ≤` over all `Fin (n + 1)` is the sum of\n`f (Fin.last n)` plus the remaining sum"},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (H : AddSubgroup G) {f : G ‚Üí+ N}\n  (hf : Function.Bijective ‚Üëf),\n  AddSubgroup.map f (AddSubgroup.normalizer H) = AddSubgroup.normalizer (AddSubgroup.map f H)","name":"AddSubgroup.map_normalizer_eq_of_bijective","isProp":true,"docString":"The image of the normalizer is equal to the normalizer of the image of a bijective\nfunction."},{"type":"‚àÄ {Œ± : Type u_1} [self : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} (a_1 : sbtw a b c) (a_2 : sbtw b d c),\n  sbtw a d c","name":"CircularPreorder.sbtw_trans_left","isProp":true,"docString":"For any fixed `c`, `fun a b ‚Ü¶ sbtw a b c` is a transitive relation.\n\nI.e., given `a` `b` `d` `c` in that \"order\", if we have `b` strictly between `a` and `c`, and `d`\nstrictly between `b` and `c`, then `d` is strictly between `a` and `c`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p‚ÇÅ : P) (p‚ÇÇ : P), p‚ÇÅ -·µ• p‚ÇÇ ‚àà vectorSpan k {p‚ÇÅ, p‚ÇÇ}","name":"vsub_mem_vectorSpan_pair","isProp":true,"docString":"The difference between two points lies in their `vectorSpan`. "},{"type":"‚àÄ {Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hf : Function.IsFixedPt f x), f x = x","name":"Function.IsFixedPt.eq","isProp":true,"docString":"If `x` is a fixed point of `f`, then `f x = x`. This is useful, e.g., for `rw` or `simp`."},{"type":"‚àÄ (R : Type u) [inst : Semiring R] [inst_1 : StrongRankCondition R], RankCondition R","name":"rankCondition_of_strongRankCondition","isProp":true,"docString":"By the universal property for free modules, any surjective map `(Fin n ‚Üí R) ‚Üí‚Çó[R] (Fin m ‚Üí R)`\nhas an injective splitting `(Fin m ‚Üí R) ‚Üí‚Çó[R] (Fin n ‚Üí R)`\nfrom which the strong rank condition gives the necessary inequality for the rank condition.\n"},{"type":"‚àÄ {Œ≤ : Type u} {f : (a : Œ≤) ‚Üí Type u} {g : (a : Œ≤) ‚Üí Type u} (Œ± : (j : Œ≤) ‚Üí f j ‚ü∂ g j) (b : Œ≤)\n  (x : ‚àè fun (b : Œ≤) ‚Ü¶ f b),\n  CategoryTheory.Limits.Pi.œÄ g b (CategoryTheory.Limits.Pi.map Œ± x) = Œ± b (CategoryTheory.Limits.Pi.œÄ f b x)","name":"CategoryTheory.Limits.Types.pi_map_œÄ_apply","isProp":true,"docString":"A restatement of `Types.Limit.map_œÄ_apply` that uses `Pi.œÄ` and `Pi.map`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {d : ENNReal}\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s), edist x y ‚â§ d), EMetric.diam s ‚â§ d","name":"EMetric.diam_le","isProp":true,"docString":"If the distance between any two points in a set is bounded by some constant, this constant\nbounds the diameter. "},{"type":"‚àÄ {R : Type u_2} [inst : CommSemiring R] (M : Submonoid R) (S : Type u_1) [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] {x : R} {y : R},\n  (‚Üë(algebraMap R S) x = ‚Üë(algebraMap R S) y : Prop) ‚Üî (‚àÉ (c : { x : R // x ‚àà M }), ‚Üëc * x = ‚Üëc * y : Prop)","name":"IsLocalization.eq_iff_exists","isProp":true,"docString":"The kernel of `algebraMap` is the annihilator of `M` "},{"type":"‚àÄ (T : Type u) [inst : TopologicalSpace T],\n  CategoryTheory.Pretopology.ofGrothendieck (TopologicalSpace.Opens T) (Opens.grothendieckTopology T) =\n    Opens.pretopology T","name":"Opens.pretopology_ofGrothendieck","isProp":true,"docString":"The pretopology associated to a space is the largest pretopology that\ngenerates the Grothendieck topology associated to the space. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {n : ‚Ñï}\n  (ht : Finset.Nonempty t) (hn : Finset.card s ‚â§ Finset.card t * n),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) ‚â§ n : Prop)","name":"Finset.exists_card_fiber_le_of_card_le_mul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by heads: given a function `f`, a\nfinite sets `s` in its domain, a finite set `t` in its codomain, and a natural number `n` such that\n`card s ‚â§ card t * n`, there exists `y ‚àà t` such that its preimage in `s` has no more than `n`\nelements. See also `Finset.exists_card_fiber_lt_of_card_lt_mul` for a stronger statement. "},{"type":"‚àÄ {Œπ : Type u_3} {Œ± : Type u_1} {Œ≤ : Type u_4} {Œ≥ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  [inst_2 : UniformSpace Œ≥] {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {u : (a : Œ±) ‚Üí Œ≥} (hu : UniformInducing u),\n  (UniformEquicontinuous F : Prop) ‚Üî\n    (UniformEquicontinuous ((fun (x : (a : Œ±) ‚Üí Œ≥) (x_1 : (a : Œ≤) ‚Üí Œ±) ‚Ü¶ x ‚àò x_1) u ‚àò F) : Prop)","name":"UniformInducing.uniformEquicontinuous_iff","isProp":true,"docString":"Given `u : Œ± ‚Üí Œ≥` a uniform inducing map, a family `ùìï : Œπ ‚Üí Œ≤ ‚Üí Œ±` is uniformly equicontinuous\niff the family `ùìï'`, obtained by precomposing each function of `ùìï` by `u`, is uniformly\nequicontinuous. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Zero Œ≤] [inst_1 : LE Œ≤]\n  [self : NonnegHomClass F Œ± Œ≤] (f : F) (a : Œ±), 0 ‚â§ ‚Üëf a","name":"NonnegHomClass.map_nonneg","isProp":true,"docString":"the image of any element is non negative. "},{"type":"‚àÄ {R : Type u} {œÉ : Type u_1} [inst : CommSemiring R] {M : (a : MvPolynomial œÉ R) ‚Üí Prop} (p : MvPolynomial œÉ R)\n  (h_C : ‚àÄ (a : R), M (‚ÜëMvPolynomial.C a))\n  (h_add_weak :\n    ‚àÄ (a : œÉ ‚Üí‚ÇÄ ‚Ñï) (b : R) (f : (œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Üí‚ÇÄ R) (a_1 : ¬¨(a ‚àà Finsupp.support f : Prop)) (a_2 : b ‚â† 0) (a_3 : M f),\n      M\n        ((let_fun this : (œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Üí‚ÇÄ R := ‚Üë(MvPolynomial.monomial a) b;\n          this) +\n          f)),\n  M p","name":"MvPolynomial.induction_on'''","isProp":true,"docString":"Similar to `MvPolynomial.induction_on` but only a weak form of `h_add` is required."},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {R' : Type u_2} [inst_1 : Monoid R'] {M : Type u_3} {N : Type u_4}\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : DistribMulAction R' M] [inst_7 : SMulCommClass R R' M] [inst_8 : SMul R' R] [inst_9 : IsScalarTower R' R M],\n  IsScalarTower R' R (TensorProduct R M N)","name":"TensorProduct.isScalarTower","isProp":true,"docString":"A short-cut instance for the common case, where the requirements for the `compatible_smul`\ninstances are sufficient. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {Œπ : Type u_1} {t : Finset Œπ} {f : (a : Œπ) ‚Üí K}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà s), (Finset.sum t fun (i : Œπ) ‚Ü¶ f i) ‚àà s","name":"Subfield.sum_mem","isProp":true,"docString":"Sum of elements in a `Subfield` indexed by a `Finset` is in the `Subfield`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Bornology Œ±] {p : (a : Œ±) ‚Üí Prop} (a : Bornology.IsBounded (setOf fun (x : Œ±) ‚Ü¶ p x)),\n  BoundedSpace (Subtype p)","name":"Bornology.IsBounded.boundedSpace_subtype","isProp":true,"docString":"**Alias** of the reverse direction of `boundedSpace_subtype_iff`."},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X]\n  (hX :\n    Pairwise fun (x : X) (y : X) ‚Ü¶\n      ‚àÉ (U : Set X), (IsClopen U : Prop) ‚àß ((x ‚àà U : Prop) ‚àß (¬¨(y ‚àà U : Prop) : Prop) : Prop)),\n  IsTotallyDisconnected Set.univ","name":"isTotallyDisconnected_of_clopen_set","isProp":true,"docString":"Let `X` be a topological space, and suppose that for all distinct `x,y ‚àà X`, there\nis some clopen set `U` such that `x ‚àà U` and `y ‚àâ U`. Then `X` is totally disconnected. "},{"type":"‚àÄ {M : Type u_2} [inst : Monoid M] {Œπ : Type u_1} [hŒπ : Nonempty Œπ] {s : (a : Œπ) ‚Üí Set M}\n  (hs : ‚àÄ (i : Œπ), IsSubmonoid (s i))\n  (Directed : ‚àÄ (i : Œπ) (j : Œπ), ‚àÉ (k : Œπ), (s i ‚äÜ s k : Prop) ‚àß (s j ‚äÜ s k : Prop)),\n  IsSubmonoid (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ s i)","name":"isSubmonoid_union·µ¢_of_directed","isProp":true,"docString":"The union of an indexed, directed, nonempty set of submonoids of a monoid `M` is a submonoid\nof `M`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] [t : TopologicalSpace Œ≤]\n  [inst_2 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : StrictMono f) (hc : Set.OrdConnected (Set.range f)),\n  TopologicalSpace.induced f t = Preorder.topology Œ±","name":"StrictMono.induced_topology_eq_preorder","isProp":true,"docString":"The topology induced by a strictly monotone function with order-connected range is the preorder\ntopology. "},{"type":"‚àÄ {S : Type u_1} [inst : Mul S] {a : S} {x : S} {y : S} (h : SemiconjBy a x y), a * x = y * a","name":"SemiconjBy.eq","isProp":true,"docString":"Equality behind `SemiconjBy a x y`; useful for rewriting. "},{"type":"‚àÄ {T : Type u} [inst : CategoryTheory.Category T] (i : CategoryTheory.Arrow T) {X : T} {Y : T} (p : X ‚âÖ Y)\n  (sq : i ‚ü∂ CategoryTheory.Arrow.mk (CategoryTheory.Iso.hom p)),\n  CategoryTheory.Comma.hom i ‚â´ CategoryTheory.CommaMorphism.right sq ‚â´ CategoryTheory.Iso.inv p =\n    CategoryTheory.CommaMorphism.left sq","name":"CategoryTheory.Arrow.square_to_iso_invert","isProp":true,"docString":"Given a square from an arrow `i` to an isomorphism `p`, express the source part of `sq`\nin terms of the inverse of `p`. "},{"type":"‚àÄ (k : Type u_1) [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ) (i : Œπ),\n  Finset.centroidWeights k s i = (‚Üë(Finset.card s))‚Åª¬π","name":"Finset.centroidWeights_apply","isProp":true,"docString":"`centroidWeights` at any point. "},{"type":"‚àÄ {n : Type u_1} {Œ± : Type v} {Œ≤ : Type w} [inst : Mul Œ±] [inst_1 : Mul Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (r : Œ±) (A : Matrix n n Œ±)\n  (hf : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±), f (a‚ÇÅ * a‚ÇÇ) = f a‚ÇÅ * f a‚ÇÇ), Matrix.map (r ‚Ä¢ A) f = f r ‚Ä¢ Matrix.map A f","name":"Matrix.map_smul'","isProp":true,"docString":"The scalar action via `Mul.toSMul` is transformed by the same map as the elements\nof the matrix, when `f` preserves multiplication. "},{"type":"‚àÄ {Œì : Type u_2} [inst : AddGroup Œì] {T : Type u_1} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Œì T]\n  [inst_3 : TopologicalSpace.SecondCountableTopology T] [inst_4 : ContinuousConstVAdd Œì T],\n  TopologicalSpace.SecondCountableTopology (Quotient (AddAction.orbitRel Œì T))","name":"ContinuousConstVAdd.secondCountableTopology","isProp":true,"docString":"The quotient of a second countable space by an additive group action is second\ncountable."},{"type":"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, (r ‚àà RingHom.ker f : Prop) ‚Üî (‚Üëf r = 0 : Prop)","name":"RingHom.mem_ker","isProp":true,"docString":"An element is in the kernel if and only if it maps to zero."},{"type":"‚àÄ (a : ‚Ñù), Cardinal.mk ‚Üë(Set.Ioi a) = Cardinal.continuum","name":"Cardinal.mk_Ioi_real","isProp":true,"docString":"The cardinality of the interval (a, ‚àû). "},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] {s : Set Œ±}\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s) (z : Œ±) (a : z ‚àà s) (a : x < y) (a : y < z), False), Set.Finite s","name":"Set.finite_of_forall_not_lt_lt","isProp":true,"docString":"If a set `s` does not contain any triple of elements `x < y < z`, then `s` is finite. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {R : CategoryTheory.Presieve X} (f : Y ‚ü∂ X)\n  [inst_1 : CategoryTheory.IsSplitEpi f] (hf : R f), CategoryTheory.Sieve.generate R = ‚ä§","name":"CategoryTheory.Sieve.generate_of_contains_isSplitEpi","isProp":true,"docString":"If an arrow set contains a split epi, it generates the maximal sieve. "},{"type":"‚àÄ (M : Type u_2) {Œ± : Type u_1} [inst : AddMonoid M] [inst_1 : AddAction M Œ±], (fun (x : M) (x_1 : Œ±) ‚Ü¶ x +·µ• x_1) 0 = id","name":"zero_vadd_eq_id","isProp":true,"docString":"`VAdd` version of `zero_add_eq_id`"},{"type":"‚àÄ {H : Type u} [inst : TopologicalSpace H], ClosedUnderRestriction (continuousGroupoid H)","name":"instClosedUnderRestrictionContinuousGroupoid","isProp":true,"docString":"The groupoid of all local homeomorphisms on a topological space `H` is closed under restriction.\n"},{"type":"‚àÄ {R : Type u_1} {Œπ : Type u_2} [inst : LinearOrderedField R] [inst_1 : Fintype Œπ] {f : (a : Œπ) ‚Üí R}\n  (hf : f ‚àà stdSimplex R Œπ) (x : Œπ), f x ‚àà Set.Icc 0 1","name":"mem_Icc_of_mem_stdSimplex","isProp":true,"docString":"All values of a function `f ‚àà stdSimplex ùïú Œπ` belong to `[0, 1]`. "},{"type":"‚àÄ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)]\n  (hs : IsSeqCompact s), IsComplete s","name":"IsSeqCompact.isComplete","isProp":true,"docString":"A sequentially compact set in a uniform set with countably generated uniformity filter\nis complete. "},{"type":"‚àÄ {R : Type u} [self : CommSemiring R] (a : R) (b : R), a * b = b * a","name":"CommSemiring.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {x : Œ±},\n  (x ‚àà closure s : Prop) ‚Üî (‚àÉ (u : Ultrafilter Œ±), (s ‚àà u : Prop) ‚àß (‚Üëu ‚â§ nhds x : Prop) : Prop)","name":"mem_closure_iff_ultrafilter","isProp":true,"docString":"`x` belongs to the closure of `s` if and only if some ultrafilter\nsupported on `s` converges to `x`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (hf : Antitone f) (hg : Antitone g), Antitone fun (x : Œ≤) ‚Ü¶ f x * g x","name":"Antitone.mul'","isProp":true,"docString":"The product of two antitone functions is antitone. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±}, Metric.diam {x} = 0","name":"Metric.diam_singleton","isProp":true,"docString":"A singleton has zero diameter "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedSemifield Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atTop),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atTop : Prop) ‚Üî (0 < r : Prop)","name":"Filter.tendsto_mul_const_atTop_iff_pos","isProp":true,"docString":"If `f` tends to infinity along a nontrivial filter `l`, then `Œª x, f x * r` tends to infinity\nif and only if `0 < r. `"},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {a : Œ±} {s : Set Œ±} (h : f a = 1),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà insert a s) ‚Ü¶ f i) = finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i","name":"finprod_mem_insert_one","isProp":true,"docString":"If `f a = 1`, then the product of `f i` over `i ‚àà insert a s` equals the product of `f i` over\n`i ‚àà s`. "},{"type":"‚àÄ {Œ± : Type u} [inst : OrderedRing Œ±] {a : Œ±} {b : Œ±} (ha : a ‚â§ 0) (h : 1 ‚â§ b), a * b ‚â§ a","name":"mul_le_of_one_le_right","isProp":true,"docString":"Variant of `le_mul_of_one_le_right` for `a` non-positive instead of non-negative. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ‚Ñï} [hp : CharP R p]\n  (p_ne_zero : p ‚â† 0), Nat.Prime p","name":"char_prime_of_ne_zero","isProp":true,"docString":"A helper lemma: the characteristic is prime if it is non-zero. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : NoMinOrder Œ±]\n  {a : Œ±} {s : Set Œ±},\n  (s ‚àà nhdsWithin a (Set.Iio a) : Prop) ‚Üî (‚àÉ (l : Œ±), (l ‚àà Set.Iio a : Prop) ‚àß (Set.Ioo l a ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Iio_iff_exists_Ioo_subset","isProp":true,"docString":"A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`\nwith `l < a`. "},{"type":"‚àÄ {M : Type u_2} [inst : AddMonoid M] {Œ≥ : Type u_1} [inst_1 : AddMonoid Œ≥] {f : (a : M) ‚Üí Œ≥} (hf : IsAddMonoidHom f),\n  IsAddSubmonoid (Set.range f)","name":"Range.isAddSubmonoid","isProp":true,"docString":"The image of an `AddMonoid` hom is an `AddSubmonoid` of the codomain."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : PseudoEMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : PseudoEMetricSpace Œ≥] (f : (a : Œ± √ó Œ≤) ‚Üí Œ≥) {s : Set Œ±} {t : Set Œ≤} (K : NNReal)\n  (ha : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), ContinuousOn (fun (y : Œ≤) ‚Ü¶ f (a, y)) t)\n  (hb : ‚àÄ (b : Œ≤) (a : b ‚àà t), LipschitzOnWith K (fun (x : Œ±) ‚Ü¶ f (x, b)) s), ContinuousOn f (s √óÀ¢ t)","name":"continuousOn_prod_of_continuousOn_lipschitz_on","isProp":true,"docString":"Consider a function `f : Œ± √ó Œ≤ ‚Üí Œ≥`. Suppose that it is continuous on each ‚Äúvertical fiber‚Äù\n`{a} √ó t`, `a ‚àà s`, and is Lipschitz continuous on each ‚Äúhorizontal fiber‚Äù `s √ó {b}`, `b ‚àà t`\nwith the same Lipschitz constant `K`. Then it is continuous on `s √ó t`.\n\nThe actual statement uses (Lipschitz) continuity of `Œª y, f (a, y)` and `Œª x, f (x, b)` instead\nof continuity of `f` on subsets of the product space. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : LE Œ±]\n  [inst_2 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (bc : a * b ‚â§ a * c), b ‚â§ c","name":"OrderedCommGroup.le_of_mul_le_mul_left","isProp":true,"docString":"**Alias** of `le_of_mul_le_mul_left'`."},{"type":"‚àÄ {S : Type u_1} {M : Type u_2} [inst : One M] [inst_1 : SetLike S M] [self : OneMemClass S M] (s : S), 1 ‚àà s","name":"OneMemClass.one_mem","isProp":true,"docString":"By definition, if we have `OneMemClass S M`, we have `1 ‚àà s` for all `s : S`. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} {PE : Type u_3} [inst : Field k] [inst_1 : AddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : AddTorsor E PE] (f : (a : k) ‚Üí PE) (a : k) (b : k) (c : k) (h : a ‚â† c),\n  ‚Üë(AffineMap.lineMap (slope f a b) (slope f b c)) ((c - b) / (c - a)) = slope f a c","name":"lineMap_slope_slope_sub_div_sub","isProp":true,"docString":"`slope f a c` is an affine combination of `slope f a b` and `slope f b c`. This version uses\n`lineMap` to express this property. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±},\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t","name":"Metric.hausdorffDist_closure","isProp":true,"docString":"The Hausdorff distance between two sets and their closures coincide "},{"type":"‚àÄ {G : Type u} [inst : Monoid G] (H : Submonoid G) (x : { x : G // x ‚àà H }),\n  (IsOfFinOrder x : Prop) ‚Üî (IsOfFinOrder ‚Üëx : Prop)","name":"isOfFinOrder_iff_coe","isProp":true,"docString":"Elements of finite order are of finite order in submonoids."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  (IsNoetherian R M : Prop) ‚Üî (‚àÄ (s : Submodule R M), Submodule.Fg s : Prop)","name":"isNoetherian_def","isProp":true,"docString":"An R-module is Noetherian iff all its submodules are finitely-generated. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ‚âÉ+* S),\n  AddEquiv.toEquiv ‚Üëf = MulEquiv.toEquiv ‚Üëf","name":"RingEquiv.toEquiv_commutes","isProp":true,"docString":"The two paths coercion can take to an `Equiv` are equivalent "},{"type":"‚àÄ {Œ± : Type u} [inst : CancelMonoidWithZero Œ±] [inst_1 : Nontrivial Œ±], FaithfulSMul Œ± Œ±","name":"CancelMonoidWithZero.faithfulSMul","isProp":true,"docString":"`Monoid.toMulAction` is faithful on nontrivial cancellative monoids with zero. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasCoequalizer f g]\n  [inst_2 : CategoryTheory.Mono (CategoryTheory.Limits.coequalizer.œÄ f g)], f = g","name":"CategoryTheory.Limits.eq_of_mono_coequalizer","isProp":true,"docString":"If the coequalizer of two morphisms is a monomorphism, then the two morphisms are equal. "},{"type":"‚àÄ {V : Type u} {G‚ÇÅ : SimpleGraph V} {G‚ÇÇ : SimpleGraph V} [inst : Fintype ‚Üë(SimpleGraph.edgeSet G‚ÇÅ)]\n  [inst_1 : Fintype ‚Üë(SimpleGraph.edgeSet G‚ÇÇ)] (a : G‚ÇÅ ‚â§ G‚ÇÇ), SimpleGraph.edgeFinset G‚ÇÅ ‚äÜ SimpleGraph.edgeFinset G‚ÇÇ","name":"SimpleGraph.edgeFinset_mono","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.edgeFinset_subset_edgeFinset`."},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M) (r : R)\n  (hr : IsUnit r), Submodule.span R (r ‚Ä¢ s) = Submodule.span R s","name":"Submodule.span_smul_eq_of_isUnit","isProp":true,"docString":"See `submodule.span_smul_eq` (in `ring_theory.ideal.operations`) for\n`span R (r ‚Ä¢ s) = r ‚Ä¢ span R s` that holds for arbitrary `r` in a `comm_semiring`. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú)\n  (hM : M (Sum.inr ()) (Sum.inr ()) ‚â† 0),\n  ‚àÉ (L : List (Matrix.TransvectionStruct (Fin r ‚äï Unit) ùïú)),\n    ‚àÉ (L' : List (Matrix.TransvectionStruct (Fin r ‚äï Unit) ùïú)),\n      Matrix.IsTwoBlockDiagonal\n        (Matrix.mul (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L)) M)\n          (List.prod (List.map Matrix.TransvectionStruct.toMatrix L')))","name":"Matrix.Pivot.exists_isTwoBlockDiagonal_of_ne_zero","isProp":true,"docString":"There exist two lists of `TransvectionStruct` such that multiplying by them on the left and\non the right makes a matrix block-diagonal, when the last coefficient is nonzero. "},{"type":"‚àÄ {R : Type u_1} [inst : AddZeroClass R], IsAddRegular 0","name":"isAddRegular_zero","isProp":true,"docString":"If adding `0` on either side is the identity, `0` is regular."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±} (a : IsUpperSet s) ‚¶Éa : Œ±‚¶Ñ (a_1 : a ‚àà s), Set.Ici a ‚äÜ s","name":"IsUpperSet.Ici_subset","isProp":true,"docString":"**Alias** of the forward direction of `isUpperSet_iff_Ici_subset`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : (a : C) ‚Üí D}\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] (X : C),\n  CategoryTheory.Iso.hom (œÅ_ (F X)) =\n    (ùüô (F X) ‚äó CategoryTheory.LaxMonoidal.Œµ) ‚â´\n      CategoryTheory.LaxMonoidal.Œº X (ùüô_ C) ‚â´ CategoryTheory.map F (CategoryTheory.Iso.hom (œÅ_ X))","name":"CategoryTheory.LaxMonoidal.right_unitality","isProp":true,"docString":"right unitality "},{"type":"Ordinal.lift = Ordinal.lift","name":"Ordinal.lift_umax","isProp":true,"docString":"`lift.{(max u v) u}` equals `lift.{v u}`. Using `set_option pp.universes true` will make it much\neasier to understand what's happening when using this lemma. "},{"type":"‚àÄ {Œì : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : SMul Œì T] [self : ContinuousConstSMul Œì T]\n  (Œ≥ : Œì), Continuous fun (x : T) ‚Ü¶ Œ≥ ‚Ä¢ x","name":"ContinuousConstSMul.continuous_const_smul","isProp":true,"docString":"The scalar multiplication `(‚Ä¢) : Œì ‚Üí T ‚Üí T` is continuous in the second argument. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G √ó K)","name":"NonarchimedeanGroup.instNonarchimedeanGroupProdInstGroupProdInstTopologicalSpaceProd","isProp":true,"docString":"The cartesian product of two nonarchimedean groups is nonarchimedean. "},{"type":"‚àÄ {R : Type u_1} {Œ± : Type u_2} (G : SimpleGraph Œ±) [inst : Zero R] [inst_1 : One R] [inst_2 : DecidableEq Œ±]\n  [inst_3 : DecidableRel (SimpleGraph.Adj G)] {a : Œ±} {e : Sym2 Œ±},\n  SimpleGraph.incMatrix R G a e = if (e ‚àà SimpleGraph.incidenceSet G a : Prop) then 1 else 0","name":"SimpleGraph.incMatrix_apply'","isProp":true,"docString":"Entries of the incidence matrix can be computed given additional decidable instances. "},{"type":"‚àÄ {R : Type u_1} {A : Type u} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\n  (Algebra.FiniteType R A : Prop) ‚Üî\n    (‚àÉ (Œπ : Type u), ‚àÉ (x : Fintype Œπ), ‚àÉ (f : MvPolynomial Œπ R ‚Üí‚Çê[R] A), Function.Surjective ‚Üëf : Prop)","name":"Algebra.FiniteType.iff_quotient_mvPolynomial'","isProp":true,"docString":"An algebra is finitely generated if and only if it is a quotient\nof a polynomial ring whose variables are indexed by a fintype. "},{"type":"‚àÄ {a : Prop} {b : Prop} {c : Prop},\n  ((a : Prop) ‚àß ((b : Prop) ‚à® (c : Prop) : Prop) : Prop) ‚Üî\n    (((a : Prop) ‚àß (b : Prop) : Prop) ‚à® ((a : Prop) ‚àß (c : Prop) : Prop) : Prop)","name":"and_or_left","isProp":true,"docString":"`‚àß` distributes over `‚à®` (on the left). "},{"type":"‚àÄ {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {Œπ : Sort u_1}\n  (p : (a : Œπ) ‚Üí Submodule R M) {C : (x : M) ‚Üí (a : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i) ‚Üí Prop}\n  (hp :\n    ‚àÄ (i : Œπ) (x : M) (hx : x ‚àà p i),\n      C x ((Submodule.mem_sup·µ¢_of_mem i hx=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i)=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i))\n  (h0 : C 0 ((zero_mem (sup·µ¢ fun (i : Œπ) ‚Ü¶ p i)=:0 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i)=:0 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i))\n  (hadd :\n    ‚àÄ (x : M) (y : M) (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i) (hy : y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i) (a : C x hx) (a : C y hy),\n      C (x + y) ((add_mem hx hy=:x + y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i)=:x + y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i))\n  {x : M} (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i), C x hx","name":"Submodule.sup·µ¢_induction'","isProp":true,"docString":"A dependent version of `submodule.sup·µ¢_induction`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {a : Œ±} (h : Set.Nonempty (Set.Iio a)), closure (Set.Iio a) = Set.Iic a","name":"closure_Iio'","isProp":true,"docString":"The closure of the interval `(-‚àû, a)` is the closed interval `(-‚àû, a]`, unless `a` is a bottom\nelement. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)}\n  (hV : TopologicalSpace.IsTopologicalBasis V) (h : IsOpenMap Quotient.mk'),\n  TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)","name":"TopologicalSpace.IsTopologicalBasis.quotient","isProp":true,"docString":"The image of a topological basis \"downstairs\" in an open quotient is a topological basis. "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {N : outParam (Type u_3)} [inst : MulOneClass M] [inst_1 : MulOneClass N]\n  [self : MonoidHomClass F M N] (f : F), ‚Üëf 1 = 1","name":"MonoidHomClass.map_one","isProp":true,"docString":"The proposition that the function preserves 1 "},{"type":"‚àÄ {Œ± : Sort u} {a : Œ±} {b : Œ±} {c : Œ±} (h‚ÇÅ : a = b) (h‚ÇÇ : b = c), a = c","name":"Eq.trans","isProp":true,"docString":"Equality is transitive: if `a = b` and `b = c` then `a = c`.\n\nBecause this is in the `Eq` namespace, if you have variables or expressions\n`h‚ÇÅ : a = b` and `h‚ÇÇ : b = c`, you can use `h‚ÇÅ.trans h‚ÇÇ : a = c` as shorthand\nfor `Eq.trans h‚ÇÅ h‚ÇÇ`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [inst_1 : IsCompactlyGenerated Œ±] {a : Œ±} {s : Set Œ±},\n  a ‚äì sup‚Çõ s = sup·µ¢ fun (t : Finset Œ±) ‚Ü¶ sup·µ¢ fun (_H : ‚Üët ‚äÜ s) ‚Ü¶ a ‚äì Finset.sup t id","name":"inf_sup‚Çõ_eq_sup·µ¢_inf_sup_finset","isProp":true,"docString":"This property is equivalent to `Œ±` being upper continuous. "},{"type":"‚àÄ (p : ‚Ñï), ‚Üë(mersenne p) = 0","name":"LucasLehmer.mersenne_coe_X","isProp":true,"docString":"`q` is the minimum factor of `mersenne p`, so `M p = 0` in `X q`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] {s : Finset Œ±} {f : (a : Œ±) ‚Üí Œ≤} {a : Œ±}\n  (hp : (Finset.prod s fun (x : Œ±) ‚Ü¶ f x) = 1) (h1 : ‚àÄ (x : Œ±) (a_1 : x ‚àà s) (a : x ‚â† a), f x = 1) (x : Œ±) (a : x ‚àà s),\n  f x = 1","name":"Finset.eq_one_of_prod_eq_one","isProp":true,"docString":"If a product is 1 and the function is 1 except possibly at one\npoint, it is 1 everywhere on the `Finset`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b),\n  Finset.Icc a b =\n    Finset.cons b (Finset.Ico a b)\n      ((Finset.right_not_mem_Ico=:¬¨(b ‚àà Finset.Ico a b : Prop))=:¬¨(b ‚àà Finset.Ico a b : Prop))","name":"Finset.Icc_eq_cons_Ico","isProp":true,"docString":"`Finset.cons` version of `Finset.Ico_insert_right`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhds a) (hfs : f '' s ‚àà nhds (f a)),\n  ContinuousAt f a","name":"StrictMonoOn.continuousAt_of_image_mem_nhds","isProp":true,"docString":"If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\nand the image of this set under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} {t : Set Œ±} (a : Disjoint s t), Disjoint (Filter.principal s) (Filter.principal t)","name":"Disjoint.filter_principal","isProp":true,"docString":"**Alias** of the reverse direction of `Filter.disjoint_principal_principal`."},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Embedding L M N) {n : ‚Ñï}\n  (r : FirstOrder.Language.Relations L n) (x : (a : Fin n) ‚Üí M),\n  (FirstOrder.Language.Structure.rel_map r\n        (Function.Embedding.toFun (FirstOrder.Language.Embedding.toEmbedding self) ‚àò x) :\n      Prop) ‚Üî\n    (FirstOrder.Language.Structure.rel_map r x : Prop)","name":"FirstOrder.Language.Embedding.map_rel'","isProp":true,"docString":"The homomorphism sends related elements to related elements "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : UniformSpace R] [inst_2 : UniformAddGroup R] [inst_3 : ContinuousMul R],\n  UniformContinuousConstSMul R R","name":"Ring.uniformContinuousConstSMul","isProp":true,"docString":"The action of `Semiring.toModule` is uniformly continuous. "},{"type":"‚àÄ {R : Type u_3} {M : Type u_4} [inst : CommSemiring R] {œÉ : Type u_2} [inst_1 : AddCommMonoid M] {Œπ : Type u_1}\n  (s : Finset Œπ) (œÜ : (a : Œπ) ‚Üí MvPolynomial œÉ R) (n : M) {w : (a : œÉ) ‚Üí M}\n  (h : ‚àÄ (i : Œπ) (a : i ‚àà s), MvPolynomial.IsWeightedHomogeneous w (œÜ i) n),\n  MvPolynomial.IsWeightedHomogeneous w (Finset.sum s fun (i : Œπ) ‚Ü¶ œÜ i) n","name":"MvPolynomial.IsWeightedHomogeneous.sum","isProp":true,"docString":"The sum of weighted homogeneous polynomials of degree `n` is weighted homogeneous of\nweighted degree `n`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {Œπ : Type w} (h : Basis Œπ K V), ‚Üë(FiniteDimensional.finrank K V) = Cardinal.mk Œπ","name":"FiniteDimensional.finrank_eq_card_basis'","isProp":true,"docString":"If a vector space is finite-dimensional, then the cardinality of any basis is equal to its\n`finrank`. "},{"type":"‚àÄ {G : Type u} {x : G} {y : G} [inst : Monoid G] (h : Commute x y) (hx : IsOfFinOrder x) (hy : IsOfFinOrder y),\n  IsOfFinOrder (x * y)","name":"Commute.isOfFinOrder_mul","isProp":true,"docString":"Commuting elements of finite order are closed under multiplication. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (x : Œ± √ó Œ≤),\n  Filter.map Prod.fst (nhdsWithin x (Prod.snd ‚Åª¬π' {Prod.snd x})) = nhds (Prod.fst x)","name":"map_fst_nhdsWithin","isProp":true,"docString":"`Prod.fst` maps neighborhood of `x : Œ± √ó Œ≤` within the section `Prod.snd ‚Åª¬π' {x.2}`\nto `ùìù x.1`. "},{"type":"‚àÄ {Œπ : Type u} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] [inst : (i : Œπ) ‚Üí Zero (Œ≤ i)] {i : Œπ} {j : Œπ} {xi : Œ≤ i}\n  {xj : Œ≤ j} (h : { fst := i, snd := xi } = { fst := j, snd := xj }), Dfinsupp.single i xi = Dfinsupp.single j xj","name":"Dfinsupp.single_eq_of_sigma_eq","isProp":true,"docString":"Equality of sigma types is sufficient (but not necessary) to show equality of `Dfinsupp`s. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type u} (f : (a : Œ≤) ‚Üí Œ±) (h‚ÇÅ : Cardinal.aleph0 ‚â§ Cardinal.mk Œ≤)\n  (h‚ÇÇ : Cardinal.mk Œ± < Ordinal.cof (Cardinal.ord (Cardinal.mk Œ≤))), ‚àÉ (a : Œ±), Cardinal.mk ‚Üë(f ‚Åª¬π' {a}) = Cardinal.mk Œ≤","name":"Ordinal.infinite_pigeonhole","isProp":true,"docString":"The infinite pigeonhole principle "},{"type":"‚àÄ {R : Type u} [inst : CommSemigroup R] [inst_1 : StarSemigroup R] (x : R) (y : R), star (x * y) = star x * star y","name":"star_mul'","isProp":true,"docString":"In a commutative ring, make `simp` prefer leaving the order unchanged. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f (‚Üëf x) y), Equiv.Perm.SameCycle f x y","name":"Equiv.Perm.SameCycle.of_apply_left","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.sameCycle_apply_left`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±}\n  {p : Filter Œπ} {s : Set Œ≤},\n  (TendstoUniformlyOn F f p s : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0), Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (x : Œ≤) (a : x ‚àà s), dist (f x) (F n x) < Œµ) p : Prop)","name":"Metric.tendstoUniformlyOn_iff","isProp":true,"docString":"Expressing uniform convergence on a set using `dist`. "},{"type":"‚àÄ {R : Type u_1} {Œì‚ÇÄ : Type u_2} [inst : CommRing R] [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ] (v : Valuation R Œì‚ÇÄ)\n  {J : Ideal R} (hJ : J ‚â§ Valuation.supp v),\n  Valuation.supp (Valuation.onQuot v hJ) = Ideal.map (Ideal.Quotient.mk J) (Valuation.supp v)","name":"Valuation.supp_quot","isProp":true,"docString":"The quotient valuation on `R / J` has support `(supp v) / J` if `J ‚äÜ supp v`. "},{"type":"‚àÄ {m : Type u_2} {n : Type u_1} {R : Type u_3} [inst : Fintype n] [inst_1 : Fintype m] [inst_2 : NonUnitalSemiring R]\n  (v : (a : m) ‚Üí R) (A : Matrix m n R) (w : (a : n) ‚Üí R),\n  Matrix.dotProduct v (Matrix.mulVec A w) = Matrix.dotProduct (Matrix.vecMul v A) w","name":"Matrix.dotProduct_mulVec","isProp":true,"docString":"Associate the dot product of `mulVec` to the left. "},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] (self : NonUnitalSubsemiring R) {a : R} {b : R}\n  (a_1 : a ‚àà AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup (NonUnitalSubsemiring.toAddSubmonoid self)))\n  (a_2 : b ‚àà AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup (NonUnitalSubsemiring.toAddSubmonoid self))),\n  a * b ‚àà AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup (NonUnitalSubsemiring.toAddSubmonoid self))","name":"NonUnitalSubsemiring.mul_mem'","isProp":true,"docString":"The product of two elements of a subsemigroup belongs to the subsemigroup. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {d : AddCon M},\n  (c ‚â§ d : Prop) ‚Üî (‚àÄ {x : M} {y : M} (a : ‚Üëc x y), ‚Üëd x y : Prop)","name":"AddCon.le_def","isProp":true,"docString":"Definition of `‚â§` for additive congruence relations."},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] [inst_1 : Inhabited M] (l : List M) (h : l ‚â† []),\n  List.headI l + List.sum (List.tail l) = List.sum l","name":"List.headI_add_tail_sum_of_ne_nil","isProp":true,"docString":"Same as `get?_zero_add_tail_sum`, but avoiding the `List.headI` garbage complication\nby requiring the list to be nonempty."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (s : Set Œ±),\n  Continuous fun (F : C(Œ±, Œ≤)) ‚Ü¶ ContinuousMap.restrict s F","name":"ContinuousMap.continuous_restrict","isProp":true,"docString":"For any subset `s` of `Œ±`, the restriction of continuous functions to `s` is continuous as a\nfunction from `C(Œ±, Œ≤)` to `C(s, Œ≤)` with their respective compact-open topologies. "},{"type":"‚àÄ {Œ± : Type u_1} {ùíú : Finset (Finset Œ±)} {r : ‚Ñï}, Set.Sized r ‚Üë(Finset.slice ùíú r)","name":"Finset.sized_slice","isProp":true,"docString":"Everything in the `r`-th slice of `ùíú` has size `r`. "},{"type":"‚àÄ {R' : Type u_1} [inst : Semiring R'], SMulCommClass { x : R' // x ‚àà Subsemiring.center R' } R' R'","name":"Subsemiring.center.smulCommClass_left","isProp":true,"docString":"The center of a semiring acts commutatively on that semiring. "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedCommRing R] (a : R) (b : R), 2 * a * b ‚â§ a ^ 2 + b ^ 2","name":"two_mul_le_add_pow_two","isProp":true,"docString":"**Alias** of `two_mul_le_add_sq`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 < a) (hb : 0 < b), 0 < a + b","name":"Left.add_pos'","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos'`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : List Œ±) (ys : List Œ±) (f : (a : List Œ±) ‚Üí Œ≤),\n  List.map f (Prod.snd (List.permutationsAux2 t ts [] ys id)) = Prod.snd (List.permutationsAux2 t ts [] ys f)","name":"List.map_permutationsAux2","isProp":true,"docString":"The `f` argument to `permutationsAux2` when `r = []` can be eliminated. "},{"type":"‚àÄ {p : (a : ‚Ñï) ‚Üí Prop} [inst : DecidablePred p] {n : ‚Ñï} (a : p n), Nat.count p (n + 1) = Nat.count p n + 1","name":"Nat.count_succ_eq_succ_count","isProp":true,"docString":"**Alias** of the reverse direction of `Nat.count_succ_eq_succ_count_iff`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : Antitone f),\n  Monotone (‚ÜëOrderDual.toDual ‚àò f)","name":"Antitone.dual_right","isProp":true,"docString":"**Alias** of the reverse direction of `monotone_toDual_comp_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 < a) (hb : 1 < b), 1 < a * b","name":"one_lt_mul'","isProp":true,"docString":"**Alias** of `Left.one_lt_mul`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] [self : IsSolvable G], ‚àÉ (n : ‚Ñï), derivedSeries G n = ‚ä•","name":"IsSolvable.solvable","isProp":true,"docString":"A group `G` is solvable if its derived series is eventually trivial. "},{"type":"‚àÄ {X : Type u} [inst : Preorder X] {x : X} {y : X} (h : x ‚ü∂ y), x ‚â§ y","name":"CategoryTheory.leOfHom","isProp":true,"docString":"Extract the underlying inequality from a morphism in a preorder category.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {f' : (a : Œ≤) ‚Üí Œ±} (h : Set.InvOn f' f s t)\n  (hf : Set.MapsTo f s t) (hf' : Set.MapsTo f' t s), Set.BijOn f s t","name":"Set.InvOn.bijOn","isProp":true,"docString":"If functions `f'` and `f` are inverse on `s` and `t`, `f` maps `s` into `t`, and `f'` maps `t`\ninto `s`, then `f` is a bijection between `s` and `t`. The `mapsTo` arguments can be deduced from\n`surjOn` statements using `LeftInvOn.mapsTo` and `RightInvOn.mapsTo`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X‚ÇÅ‚ÇÅ : C} {X‚ÇÅ‚ÇÇ : C} {X‚ÇÅ‚ÇÉ : C} {X‚ÇÇ‚ÇÅ : C} {X‚ÇÇ‚ÇÇ : C} {X‚ÇÇ‚ÇÉ : C}\n  {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÉ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÉ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ}\n  {v‚ÇÅ‚ÇÉ : X‚ÇÅ‚ÇÉ ‚ü∂ X‚ÇÇ‚ÇÉ} (s : CategoryTheory.IsPushout h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) (t : CategoryTheory.IsPushout h‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÇ),\n  CategoryTheory.IsPushout (h‚ÇÅ‚ÇÅ ‚â´ h‚ÇÅ‚ÇÇ) v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÉ (h‚ÇÇ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÇ)","name":"CategoryTheory.IsPushout.paste_horiz","isProp":true,"docString":"Paste two pushout squares \"horizontally\" to obtain another pushout square. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalAddGroup Œ±]\n  {f : (a : Œ≤) ‚Üí Œ±} [inst_3 : T2Space Œ±] [inst_4 : DecidableEq Œ≤] (hf : Summable f) (b : Œ≤),\n  (tsum fun (n : Œ≤) ‚Ü¶ f n) = f b + tsum fun (n : Œ≤) ‚Ü¶ if (n = b : Prop) then 0 else f n","name":"tsum_eq_add_tsum_ite","isProp":true,"docString":"Let `f : Œ≤ ‚Üí Œ±` be a sequence with summable series and let `b ‚àà Œ≤` be an index.\nLemma `tsum_eq_add_tsum_ite` writes `Œ£ f n` as the sum of `f b` plus the series of the\nremaining terms. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {s : Set Œ±} [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤},\n  ((¬¨(MonotoneOn f s : Prop) : Prop) ‚àß (¬¨(AntitoneOn f s : Prop) : Prop) : Prop) ‚Üî\n    (‚àÉ (a : Œ±),\n        ‚àÉ (x : a ‚àà s),\n          ‚àÉ (b : Œ±),\n            ‚àÉ (x : b ‚àà s),\n              ‚àÉ (c : Œ±),\n                ‚àÉ (x : c ‚àà s),\n                  (a ‚â§ b : Prop) ‚àß\n                    ((b ‚â§ c : Prop) ‚àß\n                        (((f a < f b : Prop) ‚àß (f c < f b : Prop) : Prop) ‚à®\n                            ((f b < f a : Prop) ‚àß (f b < f c : Prop) : Prop) :\n                          Prop) :\n                      Prop) :\n      Prop)","name":"Set.not_monotoneOn_not_antitoneOn_iff_exists_le_le","isProp":true,"docString":"A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œπ : Sort u_1} {f : (a : Œπ) ‚Üí Œ±} {g‚ÇÅ : (a : Œ±) ‚Üí Œ≤} {g‚ÇÇ : (a : Œ±) ‚Üí Œ≤}\n  (a : Set.EqOn g‚ÇÅ g‚ÇÇ (Set.range f)), g‚ÇÅ ‚àò f = g‚ÇÇ ‚àò f","name":"Set.EqOn.comp_eq","isProp":true,"docString":"**Alias** of the forward direction of `Set.eqOn_range`."},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} (a : ‚Üëm ‚â§ ‚Üën), m ‚â§ n","name":"Int.le_of_ofNat_le_ofNat","isProp":true,"docString":"**Alias** of the forward direction of `Int.ofNat_le`."},{"type":"‚àÄ {n : ‚Ñï} (self : Composition n) {i : ‚Ñï} (a : i ‚àà Composition.blocks self), 0 < i","name":"Composition.blocks_pos","isProp":true,"docString":"Proof of positivity for `blocks`"},{"type":"‚àÄ {C : Type u‚ÇÅ} {Z : (a : C) ‚Üí Prop} (self : CategoryTheory.FullSubcategory Z),\n  Z (CategoryTheory.FullSubcategory.obj self)","name":"CategoryTheory.FullSubcategory.property","isProp":true,"docString":"The predicate satisfied by all objects in this subcategory"},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} {V‚ÇÇ : Type u_5} {P‚ÇÇ : Type u_6} [inst_4 : AddCommGroup V‚ÇÇ]\n  [inst_5 : Module k V‚ÇÇ] [inst_6 : AddTorsor V‚ÇÇ P‚ÇÇ] {p : (a : Œπ) ‚Üí P} (hai : AffineIndependent k p) (f : P ‚Üí·µÉ[k] P‚ÇÇ)\n  (hf : Function.Injective ‚Üëf), AffineIndependent k (‚Üëf ‚àò p)","name":"AffineIndependent.map'","isProp":true,"docString":"The image of a family of points in affine space, under an injective affine transformation, is\naffine-independent. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p‚ÇÅ : (a : Œπ) ‚Üí P) (p‚ÇÇ : (a : Œπ) ‚Üí P),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ i)) = ‚Üë(Finset.weightedVSub s p‚ÇÅ) w - ‚Üë(Finset.weightedVSub s p‚ÇÇ) w","name":"Finset.sum_smul_vsub_eq_weightedVSub_sub","isProp":true,"docString":"A weighted sum of pairwise subtractions, expressed as a subtraction of two `weightedVSub`\nexpressions. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i) < Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (¬¨(MonovaryOn (f ‚àò ‚ÜëœÉ) g ‚Üës : Prop) : Prop)","name":"MonovaryOn.sum_comp_perm_smul_lt_sum_smul_iff","isProp":true,"docString":"**Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f ‚àò œÉ` and `g` do not monovary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : Module ùïú E] {s : Set E}\n  (hs : Convex ùïú s) (z : E), Convex ùïú ((fun (x : E) ‚Ü¶ z + x) ‚Åª¬π' s)","name":"Convex.translate_preimage_right","isProp":true,"docString":"The translation of a convex set is also convex. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T1Space Œ±] (x : Œ±), IsClosed {x}","name":"T1Space.t1","isProp":true,"docString":"A singleton in a T‚ÇÅ space is a closed set. "},{"type":"‚àÄ {X : Type u} {Y : Type u} (f : X ‚ü∂ Y), (CategoryTheory.Mono f : Prop) ‚Üî (Function.Injective f : Prop)","name":"CategoryTheory.mono_iff_injective","isProp":true,"docString":"A morphism in `Type` is a monomorphism if and only if it is injective.\n\nSee <https://stacks.math.columbia.edu/tag/003C>.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (a_1 : 0 ‚â§ a - b), b ‚â§ a","name":"le_of_sub_nonneg","isProp":true,"docString":"**Alias** of the forward direction of `sub_nonneg`."},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} {t : Set Œ±} [inst : Fintype ‚Üës] [inst_1 : Fintype ‚Üët] (a : s ‚äÇ t),\n  Set.toFinset s ‚äÇ Set.toFinset t","name":"Set.toFinset_strict_mono","isProp":true,"docString":"**Alias** of the reverse direction of `Set.toFinset_ssubset_toFinset`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommSemiring Œ±] (E : LinearRecurrence Œ±) {u : (a : ‚Ñï) ‚Üí Œ±}\n  {init : (a : Fin (LinearRecurrence.order E)) ‚Üí Œ±} (h : LinearRecurrence.IsSolution E u)\n  (heq : ‚àÄ (n : Fin (LinearRecurrence.order E)), u ‚Üën = init n) (n : ‚Ñï), u n = LinearRecurrence.mkSol E init n","name":"LinearRecurrence.eq_mk_of_is_sol_of_eq_init","isProp":true,"docString":"If `u` is a solution to `E` and `init` designates its first `E.order` values,\nthen `‚àÄ n, u n = E.mkSol init n`. "},{"type":"‚àÄ {a : EReal} {b : EReal} (h : a ‚â§ -b), b ‚â§ -a","name":"EReal.le_neg_of_le_neg","isProp":true,"docString":"`a ‚â§ -b ‚Üí b ‚â§ -a` on ereal "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : MulOneClass Œ±] [inst_1 : Group Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsMulHom f), IsMonoidHom f","name":"IsMulHom.to_isMonoidHom","isProp":true,"docString":"A map to a group preserving multiplication is a monoid homomorphism. "},{"type":"‚àÄ {N : Type u_1} {Œ± : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder N] {f : (a : N) ‚Üí Œ±} {Œº : (a : N) ‚Üí (a : N) ‚Üí N}\n  [inst_2 : CovariantClass N N (Function.swap Œº) fun (x : N) (x_1 : N) ‚Ü¶ x ‚â§ x_1] (hf : Monotone f) (m : N),\n  Monotone fun (n : N) ‚Ü¶ f (Œº n m)","name":"Monotone.covariant_of_const'","isProp":true,"docString":"Same as `Monotone.covariant_of_const`, but with the constant on the other side of\nthe operator.  E.g., `‚àÄ (m : ‚Ñï), monotone f ‚Üí monotone (Œª n, f (n + m))`. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] [inst_1 : StarRing R], RingHomInvPair (starRingEnd R) (starRingEnd R)","name":"RingHomInvPair.instRingHomInvPairToSemiringStarRingEnd","isProp":true,"docString":"Instance needed to define star-linear maps over a commutative star ring\n(ex: conjugate-linear maps when R = ‚ÑÇ).  "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] {s : Set Œ±}\n  (hs : IsClosed s),\n  ‚àÉ (S : Set (Set Œ±)),\n    (Set.Finite S : Prop) ‚àß\n      ((‚àÄ (t : Set Œ±) (a : t ‚àà S), IsClosed t : Prop) ‚àß\n          ((‚àÄ (t : Set Œ±) (a : t ‚àà S), IsIrreducible t : Prop) ‚àß (s = ‚ãÉ‚ÇÄ S : Prop) : Prop) :\n        Prop)","name":"TopologicalSpace.NoetherianSpace.exists_finite_set_isClosed_irreducible","isProp":true,"docString":"In a Noetherian space, every closed set is a finite union of irreducible closed sets. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : IsPreconnected s) (ht : IsClopen t),\n  (Disjoint s t : Prop) ‚à® (s ‚äÜ t : Prop)","name":"disjoint_or_subset_of_clopen","isProp":true,"docString":"Preconnected sets are either contained in or disjoint to any given clopen set. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïú E] {p : (a : Œπ) ‚Üí E} (hc : ConvexIndependent ùïú p), Function.Injective p","name":"ConvexIndependent.injective","isProp":true,"docString":"A convex independent family is injective. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} (R : Type u_3) [inst : AddCommMonoid E] [inst_1 : DivisionSemiring R]\n  [inst_2 : Monoid Œ±] [inst_3 : Module R E] [inst_4 : DistribMulAction Œ± E] (n : ‚Ñï) (s : Œ±) (x : E),\n  (‚Üën)‚Åª¬π ‚Ä¢ s ‚Ä¢ x = s ‚Ä¢ (‚Üën)‚Åª¬π ‚Ä¢ x","name":"inv_nat_cast_smul_comm","isProp":true,"docString":"If `E` is a vector space over a division semiring `R` and has a monoid action by `Œ±`, then that\naction commutes by scalar multiplication of inverses of natural numbers in `R`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (a : StrictConvexOn ùïú s f), StrictConcaveOn ùïú s (-f)","name":"StrictConvexOn.neg","isProp":true,"docString":"**Alias** of the reverse direction of `neg_strictConcaveOn_iff`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (I : CategoryTheory.Limits.HasZeroMorphisms C)\n  (J : CategoryTheory.Limits.HasZeroMorphisms C), I = J","name":"CategoryTheory.Limits.HasZeroMorphisms.ext","isProp":true,"docString":"If you're tempted to use this lemma \"in the wild\", you should probably\ncarefully consider whether you've made a mistake in allowing two\ninstances of `HasZeroMorphisms` to exist at all.\n\nSee, particularly, the note on `zeroMorphismsOfZeroObject` below.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : CategoryTheory.Presieve X}\n  {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') (a : CategoryTheory.Presieve.IsSheafFor P R), CategoryTheory.Presieve.IsSheafFor P' R","name":"CategoryTheory.Presieve.isSheafFor_iso","isProp":true,"docString":"If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that\n\"being a sheaf for a presieve\" is a mathematical or hygenic property.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (ùîñ : Set (Set Œ±)) (h : Set.Nonempty ùîñ)\n  (h' : DirectedOn (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äÜ x_1) ùîñ) (ùìë : FilterBasis (Œ≤ √ó Œ≤)),\n  Filter.IsBasis (fun (SV : Set Œ± √ó Set (Œ≤ √ó Œ≤)) ‚Ü¶ (Prod.fst SV ‚àà ùîñ : Prop) ‚àß (Prod.snd SV ‚àà ùìë : Prop))\n    fun (SV : Set Œ± √ó Set (Œ≤ √ó Œ≤)) ‚Ü¶ UniformOnFun.gen ùîñ (Prod.fst SV) (Prod.snd SV)","name":"UniformOnFun.isBasis_gen","isProp":true,"docString":"If `ùîñ : Set (Set Œ±)` is nonempty and directed and `ùìë` is a filter basis on `Œ≤ √ó Œ≤`, then the\nfamily `UniformOnFun.gen ùîñ S V` for `S ‚àà ùîñ` and `V ‚àà ùìë` is a filter basis on\n`(Œ± ‚Üí·µ§[ùîñ] Œ≤) √ó (Œ± ‚Üí·µ§[ùîñ] Œ≤)`.\nWe will show in `has_basis_uniformity_of_basis` that, if `ùìë` is a basis for `ùì§ Œ≤`, then the\ncorresponding filter is the uniformity of `Œ± ‚Üí·µ§[ùîñ] Œ≤`. "},{"type":"‚àÄ {G : Type u} [inst : Monoid G] {x : G} (h : Function.Injective fun (n : ‚Ñï) ‚Ü¶ x ^ n), ¬¨(IsOfFinOrder x : Prop)","name":"not_isOfFinOrder_of_injective_pow","isProp":true,"docString":"See also `injective_pow_iff_not_isOfFinOrder`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {c : AddCon M} {f : (a : M) ‚Üí N}\n  (H : ‚àÄ (x : M) (y : M), f (x + y) = f x + f y) (h : AddCon.addKer f H ‚â§ c) (hf : Function.Surjective f),\n  AddCon.mapGen c f = AddCon.mapOfSurjective c f H h hf","name":"AddCon.mapOfSurjective_eq_mapGen","isProp":true,"docString":"A specialization of 'the smallest additive congruence relation containing\nan additive congruence relation `c` equals `c`'."},{"type":"‚àÄ {Œ± : Type u_1} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (a : l‚ÇÅ <:+ l‚ÇÇ), List.reverse l‚ÇÅ <+: List.reverse l‚ÇÇ","name":"List.isSuffix.reverse","isProp":true,"docString":"**Alias** of the reverse direction of `List.reverse_prefix`."},{"type":"‚àÄ {ùïú : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {C : ùïú} (hC : C < 0) (hf : Filter.Tendsto f l (nhds C))\n  (hg : Filter.Tendsto g l Filter.atTop), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * g x) l Filter.atBot","name":"Filter.Tendsto.neg_mul_atTop","isProp":true,"docString":"In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and\n`g` tends to `Filter.atTop` then `f * g` tends to `Filter.atBot`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : LinearOrderedField Œ±] [inst_1 : FloorRing Œ±], Archimedean Œ±","name":"FloorRing.archimedean","isProp":true,"docString":"A linear ordered field that is a floor ring is archimedean. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ‚âÉ* H) (x : G) (y : G),\n  ‚Üëh (x / y) = ‚Üëh x / ‚Üëh y","name":"MulEquiv.map_div","isProp":true,"docString":"A multiplicative equivalence of groups preserves division. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {N : Type u_3} [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {x : M} {y : M} (f : M ‚Üí‚Çó[R] N) (h : SameRay R x y),\n  SameRay R (‚Üëf x) (‚Üëf y)","name":"SameRay.map","isProp":true,"docString":"If two vectors are on the same ray then they remain so after applying a linear map. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : (a : Œ±) ‚Üí Œ≤) {l : List Œ±} {n : ‚Ñï} (H : n < List.length l),\n  f (List.nthLe l n H) =\n    List.nthLe (List.map f l) n\n      ((Eq.rec H\n            ((Eq.symm\n                  ((List.length_map l\n                        f=:List.length (List.map f l) =\n                        List.length\n                          l)=:List.length (List.map f l) =\n                      List.length\n                        l)=:List.length l =\n                  List.length\n                    (List.map f\n                      l))=:List.length l =\n                List.length (List.map f l))=:n < List.length (List.map f l))=:n < List.length (List.map f l))","name":"List.nthLe_map_rev","isProp":true,"docString":"A version of `nthLe_map` that can be used for rewriting. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : Monotone f),\n  Antitone (f ‚àò ‚ÜëOrderDual.ofDual)","name":"Monotone.dual_left","isProp":true,"docString":"**Alias** of the reverse direction of `antitone_comp_ofDual_iff`."},{"type":"‚àÄ {X : Type u_2} [inst : EMetricSpace X] {Œπ : Type u_1} {I : Set Œπ} (hI : Set.Finite I) {s : (a : Œπ) ‚Üí Set X}\n  {t : Set X} (a : ‚àÄ (i : Œπ) (a : i ‚àà I), IsMetricSeparated (s i) t),\n  IsMetricSeparated (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà I) ‚Ü¶ s i) t","name":"IsMetricSeparated.finite_union·µ¢_left","isProp":true,"docString":"**Alias** of the reverse direction of `IsMetricSeparated.finite_union·µ¢_left_iff`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {T : CategoryTheory.Monad C} {J : Type u}\n  [inst_1 : CategoryTheory.Category J]\n  [inst_2 : CategoryTheory.Limits.PreservesColimitsOfShape J (CategoryTheory.Monad.toFunctor T)]\n  (D : J ‚•§ CategoryTheory.Monad.Algebra T)\n  [inst_3 : CategoryTheory.Limits.HasColimit (D ‚ãô CategoryTheory.Monad.forget T)], CategoryTheory.Limits.HasColimit D","name":"CategoryTheory.Monad.forget_creates_colimits_of_monad_preserves","isProp":true,"docString":"For `D : J ‚•§ algebra T`, `D ‚ãô forget T` has a colimit, then `D` has a colimit provided colimits\nof shape `J` are preserved by `T`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : NoMaxOrder Œ±] {a : Œ±} (ha : 0 < a),\n  Filter.HasBasis (nhds a) (fun (Œµ : Œ±) ‚Ü¶ (0 < Œµ : Prop) ‚àß (Œµ ‚â§ a : Prop)) fun (Œµ : Œ±) ‚Ü¶ Set.Ioo (a - Œµ) (a + Œµ)","name":"nhds_basis_Ioo_pos_of_pos","isProp":true,"docString":"If `a` is positive we can form a basis from only nonnegative `Set.Ioo` intervals "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (D : CategoryTheory.GlueData C)\n  [inst_1 : CategoryTheory.Limits.HasMulticoequalizer (CategoryTheory.GlueData.diagram D)] (F : C ‚•§ Type v)\n  [inst_2 :\n    CategoryTheory.Limits.PreservesColimit\n      (CategoryTheory.Limits.MultispanIndex.multispan (CategoryTheory.GlueData.diagram D)) F]\n  [inst_3 :\n    (i : CategoryTheory.GlueData.J D) ‚Üí\n      (j : CategoryTheory.GlueData.J D) ‚Üí\n        (k : CategoryTheory.GlueData.J D) ‚Üí\n          CategoryTheory.Limits.PreservesLimit\n            (CategoryTheory.Limits.cospan (CategoryTheory.GlueData.f D i j) (CategoryTheory.GlueData.f D i k)) F]\n  (x : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.GlueData.glued D)),\n  ‚àÉ (i : CategoryTheory.GlueData.J D),\n    ‚àÉ (y : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.GlueData.U D i)),\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.GlueData.Œπ D i) y = x","name":"CategoryTheory.GlueData.Œπ_jointly_surjective","isProp":true,"docString":"If there is a forgetful functor into `Type` that preserves enough (co)limits, then `D.Œπ` will\nbe jointly surjective. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ‚Ñï}\n  (h : Finset.card fs = m + 1),\n  Set.range (Affine.Simplex.points (Affine.Simplex.face s h)) = Affine.Simplex.points s '' ‚Üëfs","name":"Affine.Simplex.range_face_points","isProp":true,"docString":"The set of points of a face. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : CommMonoid M] [inst_2 : Nontrivial R] {m : M} {S : Set M}\n  (h : ‚Üë(MonoidAlgebra.of R M) m ‚àà Submodule.span R ‚Üë(Submonoid.closure (‚Üë(MonoidAlgebra.of R M) '' S))),\n  m ‚àà Submonoid.closure S","name":"MonoidAlgebra.mem_closure_of_mem_span_closure","isProp":true,"docString":"If the image of an element `m : M` in `MonoidAlgebra R M` belongs the submodule generated by the\nclosure of some `S : Set M` then `m ‚àà closure S`. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  [inst_3 : Invertible A], Matrix.mul (‚ÖüA) A = 1","name":"Matrix.invOf_mul_self","isProp":true,"docString":"A copy of `invOf_mul_self` using `‚¨ù` not `*`. "},{"type":"‚àÄ {n : ‚Ñï} (P : MvPFunctor (n + 1)) {Œ± : TypeVec n} {C : Type u_1}\n  (g :\n    (a : MvPFunctor.A P) ‚Üí\n      (a_1 : TypeVec.Arrow (MvPFunctor.B (MvPFunctor.drop P) a) Œ±) ‚Üí\n        (a_2 : (a : PFunctor.B (MvPFunctor.last P) a) ‚Üí MvPFunctor.W P Œ±) ‚Üí\n          (a : (a : PFunctor.B (MvPFunctor.last P) a) ‚Üí C) ‚Üí C)\n  (a : MvPFunctor.A P) (f' : TypeVec.Arrow (MvPFunctor.B (MvPFunctor.drop P) a) Œ±)\n  (f : (a : PFunctor.B (MvPFunctor.last P) a) ‚Üí MvPFunctor.W P Œ±),\n  MvPFunctor.wRec P g (MvPFunctor.wMk P a f' f) =\n    g a f' f fun (i : PFunctor.B (MvPFunctor.last P) a) ‚Ü¶ MvPFunctor.wRec P g (f i)","name":"MvPFunctor.wRec_eq","isProp":true,"docString":"Defining equation for the recursor of `W` "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (s : Set (CategoryTheory.GrothendieckTopology C)), IsGLB s (inf‚Çõ s)","name":"CategoryTheory.GrothendieckTopology.isGLB_inf‚Çõ","isProp":true,"docString":"See <https://stacks.math.columbia.edu/tag/00Z7> "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {p : Filter Œπ} [inst_1 : TopologicalSpace Œ±] (h : TendstoLocallyUniformlyOn F f p s)\n  (hc : Filter.Eventually (fun (n : Œπ) ‚Ü¶ ContinuousOn (F n) s) p) [inst_2 : Filter.NeBot p], ContinuousOn f s","name":"TendstoLocallyUniformlyOn.continuousOn","isProp":true,"docString":"A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {a : G} {b : G} (a_1 : a = b), a / b = 1","name":"div_eq_one_of_eq","isProp":true,"docString":"**Alias** of the reverse direction of `div_eq_one`."},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {c : AddCon M} {f : M ‚Üí+ P}\n  (h : c ‚â§ AddCon.ker f) (hf : Function.Surjective ‚Üëf), Function.Surjective ‚Üë(AddCon.lift c f h)","name":"AddCon.lift_surjective_of_surjective","isProp":true,"docString":"Surjective `AddMonoid` homomorphisms constant on an additive congruence\nrelation `c`'s equivalence classes induce a surjective homomorphism on `c`'s quotient."},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {x : M}, x ‚àà multiples x","name":"multiples.self_mem","isProp":true,"docString":"An element of an `AddMonoid` is in the set of that element's natural number multiples."},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {a : ‚Ñ§}, (multiplicity.Finite (‚Üëp) a : Prop) ‚Üî (a ‚â† 0 : Prop)","name":"padicValRat.finite_int_prime_iff","isProp":true,"docString":"The multiplicity of `p : ‚Ñï` in `a : ‚Ñ§` is finite exactly when `a ‚â† 0`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} {Z : C} {œÄ : Y ‚ü∂ Z}\n  (self : CategoryTheory.IsSplitCoequalizer f g œÄ), CategoryTheory.IsSplitCoequalizer.rightSection self ‚â´ œÄ = ùüô Z","name":"CategoryTheory.IsSplitCoequalizer.rightSection_œÄ","isProp":true,"docString":"`rightSection` splits `œÄ` "},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel (SimpleGraph.Adj G)],\n  Even (Finset.card (Finset.filter (fun (v : V) ‚Ü¶ Odd (SimpleGraph.degree G v)) Finset.univ))","name":"SimpleGraph.even_card_odd_degree_vertices","isProp":true,"docString":"The handshaking lemma.  See also `SimpleGraph.sum_degrees_eq_twice_card_edges`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ‚âÉ+* S), ‚Üë‚Üëf = ‚Üëf","name":"RingEquiv.toNonUnitalRingHom_commutes","isProp":true,"docString":"The two paths coercion can take to a `NonUnitalRingEquiv` are equivalent "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ±}\n  {c : Œ±} (h‚ÇÅ : StrictMonoOn f s) (h‚ÇÇ : StrictMonoOn f t) (hs : IsGreatest s c) (ht : IsLeast t c),\n  StrictMonoOn f (s ‚à™ t)","name":"StrictMonoOn.union","isProp":true,"docString":"If `f` is strictly monotone both on `s` and `t`, with `s` to the left of `t` and the center\npoint belonging to both `s` and `t`, then `f` is strictly monotone on `s ‚à™ t` "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonAssocRing Œ±] (a : Œ±), a * 1 = a","name":"NonAssocRing.mul_one","isProp":true,"docString":"One is a right neutral element for multiplication "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {n : ‚Ñï}\n  (hn : Finset.card s < Finset.card t * n),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) < n : Prop)","name":"Finset.exists_card_fiber_lt_of_card_lt_mul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with\nat most as many pigeons as the floor of the average number of pigeons across all pigeonholes.  (\"The\nminimum is at most the mean\" specialized to integers.)\n\nMore formally, given a function `f`, a finite sets `s` in its domain, a finite set `t` in its\ncodomain, and a natural number `n` such that `card s < card t * n`, there exists `y ‚àà t` such that\nits preimage in `s` has less than `n` elements. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] [inst_1 : NoZeroDivisors R] (t : Multiset (Polynomial R))\n  [inst_2 : Nontrivial R],\n  Polynomial.degree (Multiset.prod t) = Multiset.sum (Multiset.map (fun (f : Polynomial R) ‚Ü¶ Polynomial.degree f) t)","name":"Polynomial.degree_multiset_prod","isProp":true,"docString":"The degree of a product of polynomials is equal to\nthe sum of the degrees, where the degree of the zero polynomial is ‚ä•.\n"},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R),\n  0 ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid self))","name":"Subsemiring.zero_mem'","isProp":true,"docString":"An additive submonoid contains `0`. "},{"type":"‚àÄ {m : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} (hm : 0 < m) (h : a * c ‚â° b * c [MOD m]), a ‚â° b [MOD m / Nat.gcd m c]","name":"Nat.ModEq.cancel_right_div_gcd","isProp":true,"docString":"To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c` "},{"type":"‚àÄ {M : Type u_1} (R : Type u_2) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  Submodule.span R s = LinearMap.range (Finsupp.total (‚Üës) M R Subtype.val)","name":"Finsupp.span_eq_range_total","isProp":true,"docString":"A version of `Finsupp.range_total` which is useful for going in the other direction "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedRing Œ±] (a : Œ±) (b : Œ±) (a_1 : 0 ‚â§ a) (a_2 : 0 ‚â§ b), 0 ‚â§ a * b","name":"OrderedRing.mul_nonneg","isProp":true,"docString":"The product of non-negative elements is non-negative. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {m‚ÇÅ : MeasurableSpace Œ±} {m‚ÇÇ : MeasurableSpace Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  (a : MeasurableSpace.comap f m‚ÇÇ ‚â§ m‚ÇÅ), Measurable f","name":"Measurable.of_comap_le","isProp":true,"docString":"**Alias** of the reverse direction of `measurable_iff_comap_le`."},{"type":"‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] (f : V ‚Üí‚Çó[K] V‚ÇÇ) (p : Submodule K V)\n  [inst_5 : FiniteDimensional K { x : V // x ‚àà p }], FiniteDimensional K { x : V‚ÇÇ // x ‚àà Submodule.map f p }","name":"FiniteDimensional.instFiniteDimensionalSubtypeMemSubmoduleToSemiringToDivisionSemiringToAddCommMonoidInstMembershipSetLikeMapToAddCommMonoidIdToNonAssocSemiringToNonAssocRingToRingIdsLinearMapInstSemilinearMapClassLinearMapAddCommGroupModule","isProp":true,"docString":"Pushforwards of finite-dimensional submodules are finite-dimensional. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤}\n  {x_2 : NonAssocSemiring Œ≥} {Œ¥ : Type u_1} {x_3 : NonAssocSemiring Œ¥} (f : Œ± ‚Üí+* Œ≤) (g : Œ≤ ‚Üí+* Œ≥) (h : Œ≥ ‚Üí+* Œ¥),\n  RingHom.comp (RingHom.comp h g) f = RingHom.comp h (RingHom.comp g f)","name":"RingHom.comp_assoc","isProp":true,"docString":"Composition of semiring homomorphisms is associative. "},{"type":"‚àÄ {Œ± : Type u} [inst : CommSemiring Œ±] (x : Œ±) (y : Œ±) (n : ‚Ñï),\n  (Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n","name":"geom_sum‚ÇÇ_mul_add","isProp":true,"docString":"$x^n-y^n = (x-y) \\sum x^ky^{n-1-k}$ reformulated without `-` signs. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (S : AddSubsemigroup M) {x : M} {y : M} (a : x ‚àà S) (a : y ‚àà S), x + y ‚àà S","name":"AddSubsemigroup.add_mem","isProp":true,"docString":"An `AddSubsemigroup` is closed under addition."},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {r : HomRel C} [self : CategoryTheory.Congruence r] {X : C} {Y : C}\n  {Z : C} (f : X ‚ü∂ Y) {g : Y ‚ü∂ Z} {g' : Y ‚ü∂ Z} (a : r g g'), r (f ‚â´ g) (f ‚â´ g')","name":"CategoryTheory.Congruence.compLeft","isProp":true,"docString":"Precomposition with an arrow respects `r`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] (g : AddGroupTopology Œ±), Continuous Neg.neg","name":"AddGroupTopology.continuous_neg'","isProp":true,"docString":"A version of the global `continuous_neg` suitable for dot notation."},{"type":"‚àÄ {Œ± : Type u_4} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} [inst : DecidableEq Œ±']\n  [inst_1 : DecidableEq Œ≥] [inst_2 : DecidableEq Œ¥] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_left_comm : ‚àÄ (a : Œ±) (b : Œ≤), f (g a) b = g' (f' a b)),\n  Finset.image‚ÇÇ f (Finset.image g s) t = Finset.image g' (Finset.image‚ÇÇ f' s t)","name":"Finset.image‚ÇÇ_image_left_comm","isProp":true,"docString":"Symmetric statement to `Finset.image_image‚ÇÇ_distrib_left`. "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R), 1 ‚àà s","name":"Subsemiring.one_mem","isProp":true,"docString":"A subsemiring contains the semiring's 1. "},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {x : X} {y : X}\n  {Œ≥ : (a : Y) ‚Üí Path x y} {f : (a : Y) ‚Üí ‚Ñù} (hŒ≥ : Continuous ‚ÜøŒ≥) (hf : Continuous f),\n  Continuous fun (t : Y) ‚Ü¶ Path.extend (Œ≥ t) (f t)","name":"Continuous.path_extend","isProp":true,"docString":"See Note [continuity lemma statement]. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {r : R} {r' : R} {r‚ÇÅ : R}\n  {r‚ÇÇ : R} {s : { x : R // x ‚àà S }} {t : { x : R // x ‚àà S }} (h : r * ‚Üët = r' * ‚Üët),\n  r‚ÇÅ * r * r‚ÇÇ /‚Çí s = r‚ÇÅ * r' * r‚ÇÇ /‚Çí s","name":"OreLocalization.eq_of_num_factor_eq","isProp":true,"docString":"Fractions which differ by a factor of the numerator can be proven equal if\nthose factors expand to equal elements of `R`. "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) (m : Multiset R) (a : ‚àÄ (a : R) (a_1 : a ‚àà m), a ‚àà s),\n  Multiset.sum m ‚àà s","name":"Subsemiring.multiset_sum_mem","isProp":true,"docString":"Sum of a multiset of elements in a `Subsemiring` of a `Semiring` is\nin the `add_subsemiring`. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)] [inst_1 : DecidableEq Œπ] (i : Œπ),\n  Continuous fun (f : ((j : Œπ) ‚Üí œÄ j) √ó œÄ i) ‚Ü¶ Function.update (Prod.fst f) i (Prod.snd f)","name":"continuous_update","isProp":true,"docString":"`Function.update f i x` is continuous in `(f, x)`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p1 : P} (hp1 : p1 ‚àà s) (p2 : P) (p : P),\n  (p ‚àà affineSpan k (insert p2 ‚Üës) : Prop) ‚Üî (‚àÉ (r : k), ‚àÉ (p0 : P), ‚àÉ (_hp0 : p0 ‚àà s), p = r ‚Ä¢ (p2 -·µ• p1) +·µ• p0 : Prop)","name":"AffineSubspace.mem_affineSpan_insert_iff","isProp":true,"docString":"Given a point `p1` in an affine subspace `s`, and a point `p2`, a point `p` is in the span of\n`s` with `p2` added if and only if it is a multiple of `p2 -·µ• p1` added to a point in `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedField Œ±] (a : Œ±), LinearOrderedField.zpow 0 a = 1","name":"LinearOrderedField.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {X : Type u_1} [inst : UniformSpace X] {s : Set X} (h : IsSeqCompact s), TotallyBounded s","name":"IsSeqCompact.totallyBounded","isProp":true,"docString":"A sequentially compact set in a uniform space is totally bounded. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [inst : Semiring k] [inst_1 : MulOneClass G] [inst_2 : Semiring R]\n  {f : MonoidAlgebra k G ‚Üí+* R} {g : MonoidAlgebra k G ‚Üí+* R}\n  (h‚ÇÅ : ‚àÄ (b : k), ‚Üëf (MonoidAlgebra.single 1 b) = ‚Üëg (MonoidAlgebra.single 1 b))\n  (h_of : ‚àÄ (a : G), ‚Üëf (MonoidAlgebra.single a 1) = ‚Üëg (MonoidAlgebra.single a 1)), f = g","name":"MonoidAlgebra.ringHom_ext","isProp":true,"docString":"If two ring homomorphisms from `MonoidAlgebra k G` are equal on all `single a 1`\nand `single 1 b`, then they are equal. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : ConcaveOn ùïú (‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) s) f) {x : E}\n  (hx : x ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) s), ‚àÉ (y : E), (y ‚àà s : Prop) ‚àß (f y ‚â§ f x : Prop)","name":"ConcaveOn.exists_le_of_mem_convexHull","isProp":true,"docString":"Minimum principle for concave functions. If a function `f` is concave on the convex hull of `s`,\nthen the eventual minimum of `f` on `convexHull ùïú s` lies in `s`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (N : Subgroup G) (H : Subgroup G) [inst_1 : Subgroup.Normal N], ‚Üë(N ‚äî H) = ‚ÜëN * ‚ÜëH","name":"Subgroup.normal_mul","isProp":true,"docString":"The carrier of `N ‚äî H` is just `‚ÜëN * ‚ÜëH` (pointwise set product) when `N` is normal. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (Y ‚ü∂ X)],\n  CategoryTheory.Limits.HasTerminal C","name":"CategoryTheory.Limits.hasTerminal_of_unique","isProp":true,"docString":"We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonAssocRing Œ±] (n : ‚Ñï), IntCast.intCast ‚Üën = ‚Üën","name":"NonAssocRing.intCast_ofNat","isProp":true,"docString":"The canonical homorphism `‚Ñ§ ‚Üí R` agrees with the one from `‚Ñï ‚Üí R` on `‚Ñï`. "},{"type":"‚àÄ {n : ‚Ñï} (self : Nat.Partition n) {i : ‚Ñï} (a : i ‚àà Nat.Partition.parts self), 0 < i","name":"Nat.Partition.parts_pos","isProp":true,"docString":"proof that the `parts` are positive"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±}\n  (a_1 : IsMaxOn (‚ÜëOrderDual.toDual ‚àò f) s a), IsMinOn f s a","name":"IsMaxOn.undual","isProp":true,"docString":"**Alias** of the forward direction of `isMaxOn_dual_iff`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 2)}\n  {j : Fin (n + 1)} (H : i ‚â§ ‚ÜëFin.castSucc j),\n  CategoryTheory.CosimplicialObject.Œ¥ X (‚ÜëFin.castSucc i) ‚â´ CategoryTheory.CosimplicialObject.œÉ X (Fin.succ j) =\n    CategoryTheory.CosimplicialObject.œÉ X j ‚â´ CategoryTheory.CosimplicialObject.Œ¥ X i","name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_le","isProp":true,"docString":"The second cosimplicial identity "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  [inst_2 : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)],\n  CategoryTheory.IsSplitMono CategoryTheory.Limits.coprod.inl","name":"CategoryTheory.Limits.isSplitMono_coprod_inl","isProp":true,"docString":"In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : (a : Œ≥) ‚Üí Œ±}\n  (h : f ‚Åª¬π' LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) = Set.univ),\n  (Continuous f : Prop) ‚Üî (Continuous (‚Üëe ‚àò f) : Prop)","name":"LocalHomeomorph.continuous_iff_continuous_comp_left","isProp":true,"docString":"A function is continuous if and only if its composition with a local homeomorphism\non the left is continuous and its image is contained in the source. "},{"type":"‚àÄ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : (a : R) ‚Üí S}\n  [self : IsAbsoluteValue f] (x : R), 0 ‚â§ f x","name":"IsAbsoluteValue.abv_nonneg'","isProp":true,"docString":"The absolute value is nonnegative "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {p : Filter Œπ} (hF : TendstoUniformlyOn F f p s), UniformCauchySeqOn F p s","name":"TendstoUniformlyOn.uniformCauchySeqOn","isProp":true,"docString":"A sequence that converges uniformly is also uniformly Cauchy "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} (p : (a : M) ‚Üí Prop) (hp‚ÇÄ : p 0)\n  (hp‚ÇÅ : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x + y)) (hp‚ÇÇ : ‚àÄ (x : Œ±) (a : x ‚àà s), p (f x)),\n  p (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i)","name":"finsum_mem_induction","isProp":true,"docString":"To prove a property of a finite sum, it suffices to prove that the property is\nadditive and holds on summands."},{"type":"‚àÄ {Œ± : Type u_2} {n : Type u_1} {A : Matrix n n Œ±}, (Matrix.IsSymm A : Prop) ‚Üî (‚àÄ (i : n) (j : n), A j i = A i j : Prop)","name":"Matrix.IsSymm.ext_iff","isProp":true,"docString":"A version of `Matrix.ext_iff` that unfolds the `Matrix.transpose`. "},{"type":"‚àÄ {M : Type u_2} [inst : AddMonoid M] {Œ≥ : Type u_1} [inst_1 : AddMonoid Œ≥] {f : (a : M) ‚Üí Œ≥} (hf : IsAddMonoidHom f)\n  {s : Set M} (hs : IsAddSubmonoid s), IsAddSubmonoid (f '' s)","name":"IsAddSubmonoid.image","isProp":true,"docString":"The image of an `AddSubmonoid` under an `AddMonoid` hom is an `AddSubmonoid` of the\ncodomain."},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : DecidableEq J] (f : (a : J) ‚Üí C) [inst_3 : CategoryTheory.Limits.HasBiproduct f] (j : J) (j' : J),\n  CategoryTheory.Limits.biproduct.Œπ f j ‚â´ CategoryTheory.Limits.biproduct.œÄ f j' =\n    if h : (j = j' : Prop) then CategoryTheory.eqToHom ((congr_arg f h=:f j = f j')=:f j = f j') else 0","name":"CategoryTheory.Limits.biproduct.Œπ_œÄ","isProp":true,"docString":"Note that as this lemma has a `if` in the statement, we include a `DecidableEq` argument.\nThis means you may not be able to `simp` using this lemma unless you `open_locale Classical`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R √ó S)","name":"NonarchimedeanRing.instNonarchimedeanRingProdInstRingProdInstTopologicalSpaceProd","isProp":true,"docString":"The cartesian product of two nonarchimedean rings is nonarchimedean. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤},\n  (UniformContinuous f : Prop) ‚Üî\n    (‚àÄ (Œµ : ENNReal) (a : Œµ > 0),\n        ‚àÉ (Œ¥ : ENNReal), (Œ¥ > 0 : Prop) ‚àß (‚àÄ {a : Œ±} {b : Œ±} (a_1 : edist a b < Œ¥), edist (f a) (f b) < Œµ : Prop) :\n      Prop)","name":"EMetric.uniformContinuous_iff","isProp":true,"docString":"Œµ-Œ¥ characterization of uniform continuity on pseudoemetric spaces "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±),\n  (Finset.toColex (A \\ B) < Finset.toColex (B \\ A) : Prop) ‚Üî (Finset.toColex A < Finset.toColex B : Prop)","name":"Colex.sdiff_lt_sdiff_iff_lt","isProp":true,"docString":"Colex doesn't care if you remove the other set "},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  (X : CategoryTheory.SimplicialObject C) (n : ‚Ñï),\n  AlgebraicTopology.AlternatingFaceMapComplex.objD X (n + 1) ‚â´ AlgebraicTopology.AlternatingFaceMapComplex.objD X n = 0","name":"AlgebraicTopology.AlternatingFaceMapComplex.d_squared","isProp":true,"docString":"## The chain complex relation `d ‚â´ d`\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] (self : Œ± ‚âÉ·µê Œ≤),\n  Measurable ‚Üë(MeasurableEquiv.toEquiv self)","name":"MeasurableEquiv.measurable_toFun","isProp":true,"docString":"The forward function of a measurable equivalence is measurable. "},{"type":"‚àÄ {Œ± : Type u} (s : Set (Set Œ±)),\n  Cardinal.mk ‚Üë(setOf fun (t : Set Œ±) ‚Ü¶ MeasurableSpace.GenerateMeasurable s t) ‚â§\n    max (Cardinal.mk ‚Üës) 2 ^ Cardinal.aleph0","name":"MeasurableSpace.cardinal_generateMeasurable_le","isProp":true,"docString":"If a sigma-algebra is generated by a set of sets `s`, then the sigma-algebra has cardinality at\nmost `(max (#s) 2) ^ ‚Ñµ‚ÇÄ`. "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {N : outParam (Type u_3)} [inst : Mul M] [inst_1 : Mul N]\n  [self : MulHomClass F M N] (f : F) (x : M) (y : M), ‚Üëf (x * y) = ‚Üëf x * ‚Üëf y","name":"MulHomClass.map_mul","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {n : ‚Ñï}, Fin.succ 1 = 2","name":"Fin.succ_one_eq_two'","isProp":true,"docString":"Version of `succ_one_eq_two` to be used by `dsimp` "},{"type":"‚àÄ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F)\n  (hf : Function.Surjective ‚Üëf), Ideal.IsMaximal (RingHom.ker f)","name":"RingHom.ker_isMaximal_of_surjective","isProp":true,"docString":"The kernel of a homomorphism to a field is a maximal ideal. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [hf : CategoryTheory.IsSplitMono f]\n  [hf' : CategoryTheory.Mono (CategoryTheory.retraction f)], CategoryTheory.IsIso f","name":"CategoryTheory.IsIso.of_mono_retraction","isProp":true,"docString":"Every split mono whose retraction is mono is an iso. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (I : Ideal R)\n  {Œπ : Type u_1} (f : (a : Œπ) ‚Üí M) (x : M),\n  (x ‚àà I ‚Ä¢ Submodule.span R (Set.range f) : Prop) ‚Üî\n    (‚àÉ (a : Œπ ‚Üí‚ÇÄ R), ‚àÉ (x_1 : ‚àÄ (i : Œπ), ‚Üëa i ‚àà I), (Finsupp.sum a fun (i : Œπ) (c : R) ‚Ü¶ c ‚Ä¢ f i) = x : Prop)","name":"Submodule.mem_ideal_smul_span_iff_exists_sum","isProp":true,"docString":"If `x` is an `I`-multiple of the submodule spanned by `f '' s`,\nthen we can write `x` as an `I`-linear combination of the elements of `f '' s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : IsSuccArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h1 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico n m), r i (Order.succ i))\n  (h2 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico m n), r (Order.succ i) i) (hnm : n ‚â† m), Relation.TransGen r n m","name":"transGen_of_succ_of_ne","isProp":true,"docString":"For `n ‚â† m`,`(n, m)` is in the transitive closure of a relation `~` if `i ~ succ i` and\n`succ i ~ i` for all `i` between `n` and `m`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±], EMetric.diam ‚àÖ = 0","name":"EMetric.diam_empty","isProp":true,"docString":"The diameter of the empty set vanishes "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type v} [inst : MetricSpace Œ±] [inst_1 : ProperSpace Œ±] {c : (a : Œπ) ‚Üí Œ±} {r : (a : Œπ) ‚Üí ‚Ñù}\n  (uf : ‚àÄ (x : Œ±), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ x ‚àà Metric.ball (c i) (r i)))\n  (uU : (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r i)) = Set.univ),\n  ‚àÉ (r' : (a : Œπ) ‚Üí ‚Ñù),\n    ((Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r' i)) = Set.univ : Prop) ‚àß (‚àÄ (i : Œπ), r' i < r i : Prop)","name":"exists_union·µ¢_ball_eq_radius_lt","isProp":true,"docString":"Shrinking lemma for coverings by open balls in a proper metric space. A point-finite open cover\nof a proper metric space by open balls can be shrunk to a new cover by open balls so that each of\nthe new balls has strictly smaller radius than the old one. "},{"type":"‚àÄ {R : Type v} [inst : CommRing R] {n : ‚Ñï} (A : Matrix (Fin (Nat.succ n)) (Fin (Nat.succ n)) R) (i : Fin (Nat.succ n)),\n  Matrix.det A =\n    Finset.sum Finset.univ fun (j : Fin (Nat.succ n)) ‚Ü¶\n      (-1) ^ (‚Üëi + ‚Üëj) * A i j * Matrix.det (Matrix.submatrix A ‚Üë(Fin.succAbove i) ‚Üë(Fin.succAbove j))","name":"Matrix.det_succ_row","isProp":true,"docString":"Laplacian expansion of the determinant of an `n+1 √ó n+1` matrix along row `i`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : PredOrder Œ±] [self : IsPredArchimedean Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b),\n  ‚àÉ (n : ‚Ñï), (Order.pred^[n]) b = a","name":"IsPredArchimedean.exists_pred_iterate_of_le","isProp":true,"docString":"If `a ‚â§ b` then one can get to `b` from `a` by iterating `pred` "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (g1 : G) (g2 : G), g1 -·µ• g2 = g1 - g2","name":"vsub_eq_sub","isProp":true,"docString":"Simplify subtraction for a torsor for an `AddGroup G` over\nitself. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1], 0 < 2","name":"zero_lt_two'","isProp":true,"docString":"See `zero_lt_two` for a version with the type implicit. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : SuccOrder Œ±] {a : Œ±} {b : Œ±} [inst_2 : NoMaxOrder Œ±] (a_1 : a < b),\n  Order.succ a < Order.succ b","name":"Order.succ_lt_succ","isProp":true,"docString":"**Alias** of the reverse direction of `Order.succ_lt_succ_iff`."},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M} {t : Set M} (h : s ‚äÜ t), Monoid.Closure s ‚äÜ Monoid.Closure t","name":"Monoid.closure_mono","isProp":true,"docString":"Given subsets `t` and `s` of a monoid `M`, if `s ‚äÜ t`, the submonoid of `M` generated by `s` is\ncontained in the submonoid generated by `t`. "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] {f : Filter Œ±} {x : Œ±}\n  (adhs :\n    ‚àÄ (s : Set (Œ± √ó Œ±)) (a : s ‚àà uniformity Œ±),\n      ‚àÉ (t : Set Œ±),\n        (t ‚àà f : Prop) ‚àß ((t √óÀ¢ t ‚äÜ s : Prop) ‚àß (‚àÉ (y : Œ±), ((x, y) ‚àà s : Prop) ‚àß (y ‚àà t : Prop) : Prop) : Prop)),\n  f ‚â§ nhds x","name":"le_nhds_of_cauchy_adhp_aux","isProp":true,"docString":"The common part of the proofs of `le_nhds_of_cauchy_adhp` and\n`SequentiallyComplete.le_nhds_of_seq_tendsto_nhds`: if for any entourage `s`\none can choose a set `t ‚àà f` of diameter `s` such that it contains a point `y`\nwith `(x, y) ‚àà s`, then `f` converges to `x`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : LocallyFiniteOrderTop Œ±] (a : Œ±) (x : Œ±),\n  (x ‚àà LocallyFiniteOrderTop.finsetIoi a : Prop) ‚Üî (a < x : Prop)","name":"LocallyFiniteOrderTop.finset_mem_Ioi","isProp":true,"docString":"`x ‚àà finsetIoi a ‚Üî a < x` "},{"type":"‚àÄ (V : Type u_1) [inst : SeminormedAddCommGroup V] (h : ‚àÉ (x : V), ‚Äñx‚Äñ ‚â† 0), ‚ÄñNormedAddGroupHom.id V‚Äñ = 1","name":"NormedAddGroupHom.norm_id_of_nontrivial_seminorm","isProp":true,"docString":"If there is an element with norm different from `0`, then the norm of the identity equals `1`.\n(Since we are working with seminorms supposing that the space is non-trivial is not enough.) "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (hs : IsClosed s),\n  (IsPreconnected s : Prop) ‚Üî\n    (‚àÄ (u : Set Œ±) (v : Set Œ±) (a : IsClosed u) (a : IsClosed v) (a : s ‚äÜ u ‚à™ v) (a : Disjoint u v),\n        (s ‚äÜ u : Prop) ‚à® (s ‚äÜ v : Prop) :\n      Prop)","name":"isPreconnected_iff_subset_of_fully_disjoint_closed","isProp":true,"docString":"A closed set `s` is preconnected if and only if for every cover by two closed sets that are\ndisjoint, it is contained in one of the two covering sets. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {P : CategoryTheory.Idempotents.Karoubi C}\n  {Q : CategoryTheory.Idempotents.Karoubi C} (self : CategoryTheory.Idempotents.Karoubi.Hom P Q),\n  CategoryTheory.Idempotents.Karoubi.Hom.f self =\n    CategoryTheory.Idempotents.Karoubi.p P ‚â´\n      CategoryTheory.Idempotents.Karoubi.Hom.f self ‚â´ CategoryTheory.Idempotents.Karoubi.p Q","name":"CategoryTheory.Idempotents.Karoubi.Hom.comm","isProp":true,"docString":"compatibility of the given morphism with the given idempotents "},{"type":"‚àÄ {Œ± : Type u} (L : List Œ±) {i : ‚Ñï} {j : ‚Ñï} (h : i + j < List.length L),\n  List.nthLe L (i + j) h =\n    List.nthLe (List.drop i L) j\n      (let_fun A : i < List.length L :=\n          ((lt_of_le_of_lt ((Nat.le.intro ((rfl=:i + j = i + j)=:i + j = i + j)=:i ‚â§ i + j)=:i ‚â§ i + j)\n                h=:i < List.length L)=:i < List.length L);\n        ((Eq.mp\n              ((Eq.trans\n                    ((congrArg (LT.lt (i + j))\n                          ((Eq.trans\n                                ((List.length_append (List.take i L)\n                                      (List.drop i\n                                        L)=:List.length (List.take i L ++ List.drop i L) =\n                                      List.length (List.take i L) +\n                                        List.length\n                                          (List.drop i\n                                            L))=:List.length (List.take i L ++ List.drop i L) =\n                                    List.length (List.take i L) + List.length (List.drop i L))\n                                ((congrFun\n                                      ((congrArg HAdd.hAdd\n                                            ((Eq.trans\n                                                  ((List.length_take i\n                                                        L=:List.length (List.take i L) =\n                                                        min i\n                                                          (List.length\n                                                            L))=:List.length (List.take i L) = min i (List.length L))\n                                                  ((min_eq_left\n                                                        ((of_eq_true\n                                                              ((eq_true\n                                                                    ((le_of_lt\n                                                                          A=:i ‚â§\n                                                                          List.length\n                                                                            L)=:i ‚â§\n                                                                        List.length\n                                                                          L)=:(i ‚â§ List.length L : Prop) =\n                                                                    (True :\n                                                                      Prop))=:(i ‚â§ List.length L : Prop) =\n                                                                  (True :\n                                                                    Prop))=:i ‚â§\n                                                              List.length\n                                                                L)=:i ‚â§\n                                                            List.length\n                                                              L)=:min i (List.length L) =\n                                                        i)=:min i (List.length L) =\n                                                      i)=:List.length (List.take i L) =\n                                                  i)=:List.length (List.take i L) =\n                                                i)=:HAdd.hAdd (List.length (List.take i L)) =\n                                            HAdd.hAdd i)=:HAdd.hAdd (List.length (List.take i L)) = HAdd.hAdd i)\n                                      (List.length\n                                        (List.drop i\n                                          L))=:List.length (List.take i L) + List.length (List.drop i L) =\n                                      i +\n                                        List.length\n                                          (List.drop i\n                                            L))=:List.length (List.take i L) + List.length (List.drop i L) =\n                                    i +\n                                      List.length\n                                        (List.drop i\n                                          L))=:List.length (List.take i L ++ List.drop i L) =\n                                i +\n                                  List.length\n                                    (List.drop i\n                                      L))=:List.length (List.take i L ++ List.drop i L) =\n                              i +\n                                List.length\n                                  (List.drop i\n                                    L))=:(i + j < List.length (List.take i L ++ List.drop i L) : Prop) =\n                          (i + j < i + List.length (List.drop i L) :\n                            Prop))=:(i + j < List.length (List.take i L ++ List.drop i L) : Prop) =\n                        (i + j < i + List.length (List.drop i L) : Prop))\n                    ((Mathlib.Data.List.Basic._auxLemma.45\n                          i=:(i + j < i + List.length (List.drop i L) : Prop) =\n                          (j < List.length (List.drop i L) :\n                            Prop))=:(i + j < i + List.length (List.drop i L) : Prop) =\n                        (j < List.length (List.drop i L) :\n                          Prop))=:(i + j < List.length (List.take i L ++ List.drop i L) : Prop) =\n                    (j < List.length (List.drop i L) :\n                      Prop))=:(i + j < List.length (List.take i L ++ List.drop i L) : Prop) =\n                  (j < List.length (List.drop i L) : Prop))\n              ((Eq.mp\n                    ((Eq.ndrec\n                          ((Eq.refl\n                                (i + j < List.length L :\n                                  Prop)=:(i + j < List.length L : Prop) =\n                                (i + j < List.length L :\n                                  Prop))=:(i + j < List.length L : Prop) = (i + j < List.length L : Prop))\n                          ((Eq.symm\n                                ((List.take_append_drop i\n                                      L=:List.take i L ++ List.drop i L =\n                                      L)=:List.take i L ++ List.drop i L =\n                                    L)=:L =\n                                List.take i L ++\n                                  List.drop i\n                                    L)=:L =\n                              List.take i L ++\n                                List.drop i\n                                  L)=:(i + j < List.length L : Prop) =\n                          (i + j < List.length (List.take i L ++ List.drop i L) :\n                            Prop))=:(i + j < List.length L : Prop) =\n                        (i + j < List.length (List.take i L ++ List.drop i L) : Prop))\n                    h=:i + j <\n                    List.length\n                      (List.take i L ++\n                        List.drop i\n                          L))=:i + j <\n                  List.length\n                    (List.take i L ++\n                      List.drop i\n                        L))=:j <\n              List.length (List.drop i L))=:j < List.length (List.drop i L))=:j < List.length (List.drop i L))","name":"List.nthLe_drop","isProp":true,"docString":"The `i + j`-th element of a list coincides with the `j`-th element of the list obtained by\ndropping the first `i` elements. Version designed to rewrite from the big list to the small list. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {f : (a : Œ±) ‚Üí E} {a : (a : Œ±) ‚Üí ‚Ñù} {t‚ÇÄ : Filter Œ±}\n  (h : Filter.Eventually (fun (n : Œ±) ‚Ü¶ ‚Äñf n‚Äñ ‚â§ a n) t‚ÇÄ) (h' : Filter.Tendsto a t‚ÇÄ (nhds 0)),\n  Filter.Tendsto f t‚ÇÄ (nhds 1)","name":"squeeze_one_norm'","isProp":true,"docString":"Special case of the sandwich theorem: if the norm of `f` is eventually bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `1`. In this pair of lemmas (`squeeze_one_norm'`\nand `squeeze_one_norm`), following a convention of similar lemmas in `Topology.MetricSpace.Basic`\nand `Topology.Algebra.Order`, the `'` version is phrased using \"eventually\" and the non-`'` version\nis phrased absolutely. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (x : Œ±),\n  (x ‚àà LocallyFiniteOrder.finsetIoo a b : Prop) ‚Üî ((a < x : Prop) ‚àß (x < b : Prop) : Prop)","name":"LocallyFiniteOrder.finset_mem_Ioo","isProp":true,"docString":"`x ‚àà finsetIoo a b ‚Üî a < x ‚àß x < b` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {A : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category A] (P : C·µí·µñ ‚•§ A)\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C] (K : CategoryTheory.Pretopology C),\n  (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Pretopology.toGrothendieck C K) P : Prop) ‚Üî\n    (‚àÄ ‚¶ÉX : C‚¶Ñ (R : CategoryTheory.Presieve X) (a : R ‚àà CategoryTheory.Pretopology.coverings K X),\n        Nonempty\n          (CategoryTheory.Limits.IsLimit\n            (CategoryTheory.Functor.mapCone P\n              (CategoryTheory.Limits.Cocone.op\n                (CategoryTheory.Presieve.cocone (CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R)))))) :\n      Prop)","name":"CategoryTheory.Presheaf.isSheaf_iff_isLimit_pretopology","isProp":true,"docString":"A presheaf `P` is a sheaf for the Grothendieck topology generated by a pretopology `K`\niff for every covering presieve `R` of `K`, the natural cone associated to `P` and\n`Sieve.generate R` is a limit cone. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {l : (a : Œ±) ‚Üí Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (self : GaloisInsertion l u), GaloisConnection l u","name":"GaloisInsertion.gc","isProp":true,"docString":"The Galois connection associated to a Galois insertion. "},{"type":"‚àÄ {G : Type u_1} [inst : Mul G] [self : UniqueProds G] {A : Finset G} {B : Finset G} (x : Finset.Nonempty A)\n  (x : Finset.Nonempty B),\n  ‚àÉ (a0 : G), (a0 ‚àà A : Prop) ‚àß (‚àÉ (b0 : G), (b0 ‚àà B : Prop) ‚àß (UniqueMul A B a0 b0 : Prop) : Prop)","name":"UniqueProds.uniqueMul_of_nonempty","isProp":true,"docString":"For `A B` two nonempty finite sets, there always exist `a0 ‚àà A, b0 ‚àà B` such that\n`UniqueMul A B a0 b0` "},{"type":"‚àÄ {Œπ : Type u_1} {I : BoxIntegral.Box Œπ} {J : BoxIntegral.Box Œπ} (œÄ : BoxIntegral.Prepartition I) (h : I ‚â§ J),\n  BoxIntegral.Prepartition.boxes (BoxIntegral.Prepartition.restrict œÄ J) = BoxIntegral.Prepartition.boxes œÄ","name":"BoxIntegral.Prepartition.restrict_boxes_of_le","isProp":true,"docString":"Restricting to a larger box does not change the set of boxes. We cannot claim equality\nof prepartitions because they have different types. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (m : ‚Ñ§), (padicNorm p ‚Üëm = 1 : Prop) ‚Üî (¬¨(‚Üëp ‚à£ m : Prop) : Prop)","name":"padicNorm.int_eq_one_iff","isProp":true,"docString":"The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. "},{"type":"‚àÄ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A} (self : AddSubgroup.Normal H) (n : A) (a : n ‚àà H) (g : A),\n  g + n + -g ‚àà H","name":"AddSubgroup.Normal.conj_mem","isProp":true,"docString":"`N` is closed under additive conjugation "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {J : Type w}\n  [inst_2 : CategoryTheory.Category J] (K : J ‚•§ C) (F : C ‚•§ D) [inst_3 : CategoryTheory.Limits.HasLimit (K ‚ãô F)]\n  [inst_4 : CategoryTheory.CreatesLimit K F], CategoryTheory.Limits.HasLimit K","name":"CategoryTheory.hasLimit_of_created","isProp":true,"docString":"If `F` creates the limit of `K` and `K ‚ãô F` has a limit, then `K` has a limit. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocRing Œ±] [inst_1 : NonAssocRing Œ≤] (f : Œ± ‚Üí+* Œ≤) (x : Œ±), ‚Üëf (-x) = -‚Üëf x","name":"RingHom.map_neg","isProp":true,"docString":"Ring homomorphisms preserve additive inverse. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {b : Œ±} (hs : Set.Nonempty s)\n  (H : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), a ‚â§ b) (H' : ‚àÄ (w : Œ±) (a : w < b), ‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (w < a : Prop)),\n  sup‚Çõ s = b","name":"csup‚Çõ_eq_of_forall_le_of_forall_lt_exists_gt","isProp":true,"docString":"Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that `b`\nis larger than all elements of `s`, and that this is not the case of any `w<b`.\nSee `sup‚Çõ_eq_of_forall_le_of_forall_lt_exists_gt` for a version in complete lattices. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {m : ‚Ñï} {n : ‚Ñï}, ‚Üë(m / n) ‚â§ ‚Üëm / ‚Üën","name":"Nat.cast_div_le","isProp":true,"docString":"Natural division is always less than division in the field. "},{"type":"‚àÄ (A : Class), Class.iota A ‚àà Class.univ","name":"Class.iota_ex","isProp":true,"docString":"Unlike the other set constructors, the `iota` definite descriptor\nis a set for any set input, but not constructively so, so there is no\nassociated `Class ‚Üí Set` function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SeminormedRing Œ±] (a : Œ±) {n : ‚Ñï} (h : 0 < n), ‚Äña ^ n‚Äñ ‚â§ ‚Äña‚Äñ ^ n","name":"norm_pow_le'","isProp":true,"docString":"If `Œ±` is a seminormed ring, then `‚Äña ^ n‚Äñ ‚â§ ‚Äña‚Äñ ^ n` for `n > 0`. See also `norm_pow_le`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] ‚¶Éf : M ‚Üí+ N‚¶Ñ ‚¶Ég : M ‚Üí+ N‚¶Ñ\n  (h : ‚Üëf = ‚Üëg), f = g","name":"AddMonoidHom.coe_inj","isProp":true,"docString":"Deprecated: use `FunLike.coe_injective` instead."},{"type":"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_3} (s : Finset Œπ) (p : (a : Œπ) ‚Üí P),\n  AffineMap.linear (Finset.affineCombination k s p) = Finset.weightedVSub s p","name":"Finset.affineCombination_linear","isProp":true,"docString":"The linear map corresponding to `affineCombination` is\n`weightedVSub`. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : Monoid R] [inst_1 : NonUnitalNonAssocSemiring A]\n  [inst_2 : DistribMulAction R A] [inst_3 : Star A] [inst_4 : NonUnitalNonAssocSemiring B]\n  [inst_5 : DistribMulAction R B] [inst_6 : Star B] (self : A ‚Üí‚ãÜ‚Çô‚Çê[R] B) (a : A),\n  MulActionHom.toFun\n      (DistribMulActionHom.toMulActionHom\n        (NonUnitalAlgHom.toDistribMulActionHom (NonUnitalStarAlgHom.toNonUnitalAlgHom self)))\n      (star a) =\n    star\n      (MulActionHom.toFun\n        (DistribMulActionHom.toMulActionHom\n          (NonUnitalAlgHom.toDistribMulActionHom (NonUnitalStarAlgHom.toNonUnitalAlgHom self)))\n        a)","name":"NonUnitalStarAlgHom.map_star'","isProp":true,"docString":"By definition, a non-unital ‚ãÜ-algebra homomorphism preserves the `star` operation. "},{"type":"‚àÄ {L : outParam FirstOrder.Language} {F : Type u_3} {M : outParam (Type u_4)} {N : outParam (Type u_5)}\n  [inst : FunLike F M fun (x : M) ‚Ü¶ N] [inst_1 : FirstOrder.Language.Structure L M]\n  [inst_2 : FirstOrder.Language.Structure L N] [self : FirstOrder.Language.StrongHomClass L F M N] (œÜ : F) {n : ‚Ñï}\n  (f : FirstOrder.Language.Functions L n) (x : (a : Fin n) ‚Üí M),\n  ‚ÜëœÜ (FirstOrder.Language.Structure.funMap f x) = FirstOrder.Language.Structure.funMap f (‚ÜëœÜ ‚àò x)","name":"FirstOrder.Language.StrongHomClass.map_fun","isProp":true,"docString":"The homomorphism commutes with the interpretations of the function symbols "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Countable ‚Üës), Set.Countable s","name":"Countable.to_set","isProp":true,"docString":"Restate `Set.Countable` as a `Countable` instance. "},{"type":"‚àÄ {G : Type u_1} [inst : CommGroup G] (L : List G), (List.prod L)‚Åª¬π = List.prod (List.map (fun (x : G) ‚Ü¶ x‚Åª¬π) L)","name":"List.prod_inv","isProp":true,"docString":"This is the `List.prod` version of `mul_inv` "},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p‚ÇÅ : P) (p‚ÇÇ : P), vectorSpan k {p‚ÇÅ, p‚ÇÇ} = Submodule.span k {p‚ÇÅ -·µ• p‚ÇÇ}","name":"vectorSpan_pair","isProp":true,"docString":"The `vectorSpan` of two points is the span of their difference. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DivisionMonoid Œ±] {a : Œ±} (a_1 : IsSquare a), IsSquare a‚Åª¬π","name":"IsSquare.inv","isProp":true,"docString":"**Alias** of the reverse direction of `isSquare_inv`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Finite Œ±] (p : (a : Œ±) ‚Üí Prop) (q : (a : Œ±) ‚Üí Prop) [inst : Fintype { x : Œ± // p x }]\n  [inst_1 : Fintype { x : Œ± // ¬¨(p x : Prop) }] [inst_2 : Fintype { x : Œ± // q x }]\n  [inst_3 : Fintype { x : Œ± // ¬¨(q x : Prop) }] (h : Fintype.card { x : Œ± // p x } = Fintype.card { x : Œ± // q x }),\n  Fintype.card { x : Œ± // ¬¨(p x : Prop) } = Fintype.card { x : Œ± // ¬¨(q x : Prop) }","name":"Fintype.card_compl_eq_card_compl","isProp":true,"docString":"If two subtypes of a fintype have equal cardinality, so do their complements. "},{"type":"‚àÄ {R : Type u_5} [inst : CommSemiring R] {k : Type u_3} {l : Type u_2} {m : Type u_4} {n : Type u_1}\n  [inst_1 : Fintype n] [inst_2 : Fintype l] (e‚ÇÅ : k ‚âÉ m) (e‚ÇÇ : l ‚âÉ n) (M : Matrix k l R),\n  Matrix.mulVecLin (‚Üë(Matrix.reindex e‚ÇÅ e‚ÇÇ) M) =\n    LinearMap.comp (‚Üë(LinearEquiv.funCongrLeft R R (Equiv.symm e‚ÇÅ)))\n      (LinearMap.comp (Matrix.mulVecLin M) ‚Üë(LinearEquiv.funCongrLeft R R e‚ÇÇ))","name":"Matrix.mulVecLin_reindex","isProp":true,"docString":"A variant of `Matrix.mulVecLin_submatrix` that keeps around `LinearEquiv`s. "},{"type":"‚àÄ {n : Type u_1} {R : Type u_2} {Œ± : Type v} [inst : NonUnitalNonAssocSemiring Œ±] [inst_1 : Fintype n]\n  [inst_2 : Monoid R] [inst_3 : DistribMulAction R Œ±] [inst_4 : SMulCommClass R Œ± Œ±],\n  SMulCommClass R (Matrix n n Œ±) (Matrix n n Œ±)","name":"Matrix.Semiring.smulCommClass","isProp":true,"docString":"This instance enables use with `mul_smul_comm`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofilteredOrEmpty C] {j : C} {j' : C}\n  (f : j ‚ü∂ j') (f' : j ‚ü∂ j'), CategoryTheory.IsCofiltered.eqHom f f' ‚â´ f = CategoryTheory.IsCofiltered.eqHom f f' ‚â´ f'","name":"CategoryTheory.IsCofiltered.eq_condition","isProp":true,"docString":"`eq_condition f f'`, for morphisms `f f' : j ‚ü∂ j'`, is the proof that\n`eqHom f f' ‚â´ f = eqHom f f' ‚â´ f'`.\n"},{"type":"‚àÄ {Œπ : Type u} {Œ≥ : Type w} [dec : DecidableEq Œπ] (p : (a : Œπ) ‚Üí Prop) [inst : DecidablePred p]\n  [inst_1 : AddCommMonoid Œ≥] (S : (a : Œπ) ‚Üí AddSubmonoid Œ≥),\n  (sup·µ¢ fun (i : Œπ) ‚Ü¶ sup·µ¢ fun (_h : p i) ‚Ü¶ S i) =\n    AddMonoidHom.mrange\n      (AddMonoidHom.comp (Dfinsupp.sumAddHom fun (i : Œπ) ‚Ü¶ AddSubmonoid.subtype (S i))\n        (Dfinsupp.filterAddMonoidHom (fun (i : Œπ) ‚Ü¶ { x : Œ≥ // x ‚àà S i }) p))","name":"AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom","isProp":true,"docString":"The bounded supremum of a family of commutative additive submonoids is equal to the range of\n`Dfinsupp.sumAddHom` composed with `Dfinsupp.filterAddMonoidHom`; that is, every element in the\nbounded `sup·µ¢` can be produced from taking a finite number of non-zero elements from the `S i` that\nsatisfy `p i`, coercing them to `Œ≥`, and summing them. "},{"type":"‚àÄ {n : ‚Ñï} {m : ‚Ñï} (h : Fin n = Fin m), cast h = ‚Üë(Fin.cast ((fin_injective h=:n = m)=:n = m))","name":"Fin.cast_eq_cast'","isProp":true,"docString":"A reversed version of `Fin.cast_eq_cast` that is easier to rewrite with. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {J : Type} [inst_2 : Finite J]\n  (f : (a : J) ‚Üí C) [inst_3 : CategoryTheory.Limits.HasProduct f], CategoryTheory.Limits.HasBiproduct f","name":"CategoryTheory.Limits.HasBiproduct.of_hasProduct","isProp":true,"docString":"In a preadditive category, if the product over `f : J ‚Üí C` exists,\nthen the biproduct over `f` exists. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] (f : M ‚Üí*‚ÇÄ N) {x : M} {y : M}\n  (h : x = y), ‚Üëf x = ‚Üëf y","name":"MonoidWithZeroHom.congr_arg","isProp":true,"docString":"Deprecated: use `FunLike.congr_arg` instead. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)]\n  [inst_2 : (i : Œπ) ‚Üí Zero (Œ≤ i)] (x : (i : Œπ) ‚Üí Œ≤ i), hammingDist x 0 = hammingNorm x","name":"hammingDist_zero_right","isProp":true,"docString":"Corresponds to `dist_zero_right`. "},{"type":"‚àÄ {R : Type u_1} [inst : NonAssocRing R] (self : MulRingNorm R) (x : R)\n  (a : AddGroupSeminorm.toFun (MulRingSeminorm.toAddGroupSeminorm (MulRingNorm.toMulRingSeminorm self)) x = 0), x = 0","name":"MulRingNorm.eq_zero_of_map_eq_zero'","isProp":true,"docString":"If the image under the seminorm is zero, then the argument is zero. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, seqClosure s ‚äÜ closure s","name":"seqClosure_subset_closure","isProp":true,"docString":"The sequential closure of a set is contained in the closure of that set.\nThe converse is not true. "},{"type":"‚àÄ {b : ‚Ñï} {m : ‚Ñï} (hb : 1 < b), m < b ^ List.length (Nat.digits b m)","name":"Nat.lt_base_pow_length_digits","isProp":true,"docString":"Any number m is less than b^(number of digits in the base b representation of m) "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  [inst_2 : DecidableEq Œπ],\n  (Finset.SupIndep s f : Prop) ‚Üî (‚àÄ (i : Œπ) (a : i ‚àà s), Disjoint (f i) (Finset.sup (Finset.erase s i) f) : Prop)","name":"Finset.supIndep_iff_disjoint_erase","isProp":true,"docString":"The RHS looks like the definition of `CompleteLattice.Independent`. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} {x : Œ±},\n  (List.Duplicate x l : Prop) ‚Üî\n    (‚àÉ (n : ‚Ñï),\n        ‚àÉ (hn : n < List.length l),\n          ‚àÉ (m : ‚Ñï),\n            ‚àÉ (hm : m < List.length l),\n              ‚àÉ (x_1 : n < m), (x = List.nthLe l n hn : Prop) ‚àß (x = List.nthLe l m hm : Prop) :\n      Prop)","name":"List.duplicate_iff_exists_distinct_nthLe","isProp":true,"docString":"An element `x : Œ±` of `l : List Œ±` is a duplicate iff it can be found\nat two distinct indices `n m : ‚Ñï` inside the list `l`.\n"},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  {p : Seminorm ùïú E} {q : Seminorm ùïú E} {x : E}, BddBelow (Set.range fun (u : E) ‚Ü¶ ‚Üëp u + ‚Üëq (x - u))","name":"Seminorm.bddBelow_range_add","isProp":true,"docString":"Auxiliary lemma to show that the infimum of seminorms is well-defined. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {e' : LocalEquiv Œ± Œ≤} (he : e ‚âà e') (s : Set Œ±),\n  LocalEquiv.restr e s ‚âà LocalEquiv.restr e' s","name":"LocalEquiv.EqOnSource.restr","isProp":true,"docString":"Restriction of local equivs respects equivalence "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] {S : Subsemiring R} {T : Subsemiring R}\n  (h : ‚àÄ (x : R), (x ‚àà S : Prop) ‚Üî (x ‚àà T : Prop)), S = T","name":"Subsemiring.ext","isProp":true,"docString":"Two subsemirings are equal if they have the same elements. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {p : (a : Œ±) ‚Üí Prop} {s : Finset { x : Œ± // p x }}\n  {f : (a : { x : Œ± // p x }) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} (h : ‚àÄ (x : { x : Œ± // p x }) (a : x ‚àà s), g ‚Üëx = f x),\n  (Finset.sum (Finset.map (Function.Embedding.subtype fun (x : Œ±) ‚Ü¶ p x) s) fun (x : Œ±) ‚Ü¶ g x) =\n    Finset.sum s fun (x : { x : Œ± // p x }) ‚Ü¶ f x","name":"Finset.sum_subtype_map_embedding","isProp":true,"docString":"A sum of a function over a `Finset` in a subtype equals a\nsum in the main type of a function that agrees with the first\nfunction on that `Finset`."},{"type":"‚àÄ (n : ‚Ñï), (Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ i) * 2 = n * (n - 1)","name":"Finset.sum_range_id_mul_two","isProp":true,"docString":"Gauss' summation formula "},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeAddGroup.Red L (FreeAddGroup.reduce L)","name":"FreeAddGroup.reduce.red","isProp":true,"docString":"The first theorem that characterises the function `reduce`: a word reduces to its\nmaximal reduction."},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {s‚ÇÅ : Setoid Œ±} {s‚ÇÇ : Setoid Œ≤} {p : (a : Quotient s‚ÇÅ) ‚Üí (a : Quotient s‚ÇÇ) ‚Üí Prop}\n  (q‚ÇÅ : Quotient s‚ÇÅ) (q‚ÇÇ : Quotient s‚ÇÇ) (h : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ≤), p (Quotient.mk'' a‚ÇÅ) (Quotient.mk'' a‚ÇÇ)), p q‚ÇÅ q‚ÇÇ","name":"Quotient.inductionOn‚ÇÇ'","isProp":true,"docString":"A version of `Quotient.inductionOn‚ÇÇ` taking `{s‚ÇÅ : Setoid Œ±} {s‚ÇÇ : Setoid Œ≤}` as implicit\narguments instead of instance arguments. "},{"type":"‚àÄ {M : Type u} [self : LeftCancelMonoid M] (n : ‚Ñï) (x : M),\n  LeftCancelMonoid.npow (n + 1) x = x * LeftCancelMonoid.npow n x","name":"LeftCancelMonoid.npow_succ","isProp":true,"docString":"Raising to the power `(n + 1 : ‚Ñï)` behaves as expected. "},{"type":"‚àÄ {Œ± : Type u} [self : SemilatticeSup Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : a ‚â§ c) (a_2 : b ‚â§ c), a ‚äî b ‚â§ c","name":"SemilatticeSup.sup_le","isProp":true,"docString":"The supremum is the *least* upper bound "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {W : C·µí·µñ} {X : C·µí·µñ} {Y : C·µí·µñ} {Z : C·µí·µñ} {f : W ‚ü∂ X} {g : W ‚ü∂ Y}\n  {h : X ‚ü∂ Z} {i : Y ‚ü∂ Z} (p : CategoryTheory.CommSq f g h i),\n  CategoryTheory.CommSq (Quiver.Hom.unop i) (Quiver.Hom.unop h) (Quiver.Hom.unop g) (Quiver.Hom.unop f)","name":"CategoryTheory.CommSq.unop","isProp":true,"docString":"The commutative square associated to a commutative square in the opposite category. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) {i : ‚Ñï} {j : ‚Ñï} (hi : i < List.length L)\n  (hj : j < List.length (List.nthLe L i hi)),\n  List.nthLe (List.join L) (List.sum (List.take i (List.map List.length L)) + j)\n      ((List.sum_take_map_length_lt2 L hi\n            hj=:List.sum (List.take i (List.map List.length L)) + j <\n            List.length\n              (List.join L))=:List.sum (List.take i (List.map List.length L)) + j < List.length (List.join L)) =\n    List.nthLe (List.nthLe L i hi) j hj","name":"List.nthLe_join","isProp":true,"docString":"The `n`-th element in a join of sublists is the `j`-th element of the `i`th sublist,\nwhere `n` can be obtained in terms of `i` and `j` by adding the lengths of all the sublists\nof index `< i`, and adding `j`. "},{"type":"‚àÄ {G : outParam (Type u_1)} {P : Type u_2} [inst : outParam (AddGroup G)] [self : AddTorsor G P] (g : G) (p : P),\n  g +·µ• p -·µ• p = g","name":"AddTorsor.vadd_vsub'","isProp":true,"docString":"Torsor addition and subtraction with the same element cancels out. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} (hs : Set.Subsingleton s), EMetric.diam s = 0","name":"EMetric.diam_subsingleton","isProp":true,"docString":"The diameter of a subsingleton vanishes. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {n : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroDivisors R] {B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R} (v : Basis n R M) (hO : LinearMap.IsOrtho·µ¢ B ‚Üëv)\n  (h : ‚àÄ (i : n), ¬¨(LinearMap.IsOrtho B (‚Üëv i) (‚Üëv i) : Prop)), LinearMap.SeparatingLeft B","name":"LinearMap.IsOrtho·µ¢.separatingLeft_of_not_isOrtho_basis_self","isProp":true,"docString":"Given an orthogonal basis with respect to a bilinear form, the bilinear form is left-separating\nif the basis has no elements which are self-orthogonal. "},{"type":"‚àÄ {Œ± : Type u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {a : Œ±} {b : Œ±} (p : (a : Œ±) ‚Üí Prop) (l : List Œ±) (h : List.Chain r a l)\n  (hb : List.getLast (a :: l) ((List.cons_ne_nil a l=:a :: l ‚â† [])=:a :: l ‚â† []) = b)\n  (carries : ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : r x y) (a : p y), p x) (final : p b), p a","name":"List.Chain.induction_head","isProp":true,"docString":"Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y ‚Üí p y ‚Üí p x` then\nthe predicate is true at `a`.\nThat is, we can propagate the predicate all the way up the chain.\n"},{"type":"‚àÄ {n : ‚Ñï}, Finset.univ = Finset.map (Equiv.toEmbedding (Equiv.symm Equiv.Perm.decomposeFin)) Finset.univ","name":"Finset.univ_perm_fin_succ","isProp":true,"docString":"The set of all permutations of `Fin (n + 1)` can be constructed by augmenting the set of\npermutations of `Fin n` by each element of `Fin (n + 1)` in turn. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] (f : E ‚Üí‚Çó.[R] F) (g : E ‚Üí‚Çó.[R] F)\n  (h : Disjoint (LinearPMap.domain f) (LinearPMap.domain g)) (x : { x : E // x ‚àà LinearPMap.domain f })\n  (y : { x : E // x ‚àà LinearPMap.domain g }) (hxy : ‚Üëx = ‚Üëy), ‚Üëf x = ‚Üëg y","name":"LinearPMap.sup_h_of_disjoint","isProp":true,"docString":"Hypothesis for `LinearPMap.sup` holds, if `f.domain` is disjoint with `g.domain`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±},\n  (Set.OrdConnected s : Prop) ‚Üî (‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s) (a : x ‚â§ y), Set.Icc x y ‚äÜ s : Prop)","name":"Set.ordConnected_iff","isProp":true,"docString":"It suffices to prove `[[x, y]] ‚äÜ s` for `x y ‚àà s`, `x ‚â§ y`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ±' : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_2} {Œ¥ : Type u_1} {m : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {f : Filter Œ±}\n  {g : Filter Œ≤} {n : (a : Œ≥) ‚Üí Œ¥} {m' : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ¥} {n' : (a : Œ±) ‚Üí Œ±'}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), n (m a b) = m' (n' a) b),\n  Filter.map n (Filter.map‚ÇÇ m f g) = Filter.map‚ÇÇ m' (Filter.map n' f) g","name":"Filter.map_map‚ÇÇ_distrib_left","isProp":true,"docString":"Symmetric statement to `Filter.map‚ÇÇ_map_left_comm`. "},{"type":"‚àÄ {Œπ : Type u_5} {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R]\n  [inst_1 : Semiring R‚ÇÇ] [inst_2 : AddCommMonoid M] [inst_3 : Module R M] [inst_4 : AddCommMonoid M‚ÇÇ]\n  [inst_5 : Module R‚ÇÇ M‚ÇÇ] [inst_6 : TopologicalSpace M] [inst_7 : TopologicalSpace M‚ÇÇ] {œÉ : R ‚Üí+* R‚ÇÇ} {f : (a : Œπ) ‚Üí M}\n  (œÜ : M ‚ÜíSL[œÉ] M‚ÇÇ) {x : M} (hf : HasSum f x), HasSum (fun (b : Œπ) ‚Ü¶ ‚ÜëœÜ (f b)) (‚ÜëœÜ x)","name":"HasSum.mapL","isProp":true,"docString":"**Alias** of `ContinuousLinearMap.hasSum`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : TopologicalSpace E]\n  [inst_2 : AddCancelCommMonoid E] [inst_3 : ContinuousAdd E] [inst_4 : Module ùïú E] {s : Set E} (hs : StrictConvex ùïú s)\n  (z : E), StrictConvex ùïú ((fun (x : E) ‚Ü¶ x + z) ‚Åª¬π' s)","name":"StrictConvex.preimage_add_left","isProp":true,"docString":"The translation of a strictly convex set is also strictly convex. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} (s : (a : Œπ) ‚Üí Set Œ±),\n  (Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ s i) =\n    Set.inter·µ¢ fun (t : Finset Œπ) ‚Ü¶ Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà t) ‚Ü¶ s i","name":"Set.inter·µ¢_eq_inter·µ¢_finset","isProp":true,"docString":"Intersection of an indexed family of sets `s : Œπ ‚Üí Set Œ±` is equal to the intersection of the\nintersections of finite subfamilies. This version assumes `Œπ : Type _`. See also\n`inter·µ¢_eq_inter·µ¢_finset'` for a version that works for `Œπ : Sort*`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.RegularMono f]\n  [inst_2 : CategoryTheory.Epi f], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_regularMono_of_epi","isProp":true,"docString":"A regular monomorphism is an isomorphism if it is an epimorphism. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (J : CategoryTheory.GrothendieckTopology C)\n  (f : Y ‚ü∂ X) (S : CategoryTheory.Sieve X) (h : CategoryTheory.GrothendieckTopology.Covers J S f) {Z : C} (g : Z ‚ü∂ Y),\n  CategoryTheory.GrothendieckTopology.Covers J S (g ‚â´ f)","name":"CategoryTheory.GrothendieckTopology.arrow_stable","isProp":true,"docString":"The stability axiom in 'arrow' form: If `S` covers `f` then `S` covers `g ‚â´ f` for any `g`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 2)}\n  {j : Fin (n + 2)} (H : i ‚â§ j),\n  CategoryTheory.CosimplicialObject.Œ¥ X i ‚â´ CategoryTheory.CosimplicialObject.Œ¥ X (Fin.succ j) =\n    CategoryTheory.CosimplicialObject.Œ¥ X j ‚â´ CategoryTheory.CosimplicialObject.Œ¥ X (‚ÜëFin.castSucc i)","name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥","isProp":true,"docString":"The generic case of the first cosimplicial identity "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C), CategoryTheory.IsPullback 0 0 (ùüô X) 0","name":"CategoryTheory.IsPullback.zero_left","isProp":true,"docString":"The square with `0 : 0 ‚ü∂ 0` on the left and `ùüô X` on the right is a pullback square. "},{"type":"‚àÄ {c : (n : ‚Ñï) √ó Composition n} {c' : (n : ‚Ñï) √ó Composition n},\n  (c = c' : Prop) ‚Üî (Composition.blocks (Sigma.snd c) = Composition.blocks (Sigma.snd c') : Prop)","name":"Composition.sigma_eq_iff_blocks_eq","isProp":true,"docString":"Two compositions (possibly of different integers) coincide if and only if they have the\nsame sequence of blocks. "},{"type":"failed to pretty print expression (use 'set_option pp.rawOnError true' for raw representation)","name":"padicValRat.defn","isProp":true,"docString":"A rewrite lemma for `padicValRat p q` when `q` is expressed in terms of `Rat.mk`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {d : AddCon M}, (Setoid.r = Setoid.r : Prop) ‚Üî (c = d : Prop)","name":"AddCon.ext'_iff","isProp":true,"docString":"Two additive congruence relations are equal iff their underlying binary relations\nare equal."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  {f : (a : Œ±) ‚Üí Œ≤} (h : Continuous f), UniformContinuous f","name":"CompactSpace.uniformContinuous_of_continuous","isProp":true,"docString":"Heine-Cantor: a continuous function on a compact uniform space is uniformly\ncontinuous. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] {s : Set Œ±} [hs : Set.OrdConnected s] ‚¶Ét : Set ‚Üës‚¶Ñ\n  (ht : Set.Nonempty t) (h_bdd : BddBelow t), inf‚Çõ (Subtype.val '' t) ‚àà s","name":"inf‚Çõ_within_of_ordConnected","isProp":true,"docString":"The `inf‚Çõ` function on a nonempty `OrdConnected` set `s` in a conditionally complete linear\norder takes values within `s`, for all nonempty bounded-below subsets of `s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) (rŒ≤ : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop),\n  Prod.RProd rŒ± rŒ≤ ‚â§ Relation.TransGen (Prod.GameAdd rŒ± rŒ≤)","name":"Prod.rprod_le_transGen_gameAdd","isProp":true,"docString":"`Prod.RProd` is a subrelation of the transitive closure of `Prod.GameAdd`. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (r : R) (a : A), ‚Üëf (r ‚Ä¢ a) = r ‚Ä¢ ‚Üëf a","name":"StarAlgEquivClass.map_smul","isProp":true,"docString":"By definition, a ‚ãÜ-algebra equivalence commutes with the action of scalars. "},{"type":"‚àÄ {G : Type u_1} [inst : CommGroup G] (K : Subgroup G) {Œπ : Type u_2} {t : Finset Œπ} {f : (a : Œπ) ‚Üí G}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà K), (Finset.prod t fun (c : Œπ) ‚Ü¶ f c) ‚àà K","name":"Subgroup.prod_mem","isProp":true,"docString":"Product of elements of a subgroup of a `CommGroup` indexed by a `Finset` is in the\nsubgroup. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : Set P), affineSpan k s = inf‚Çõ (setOf fun (s' : AffineSubspace k P) ‚Ü¶ s ‚äÜ ‚Üës')","name":"AffineSubspace.affineSpan_eq_inf‚Çõ","isProp":true,"docString":"The affine span is the `inf‚Çõ` of subspaces containing the given points. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {l : (a : Œ±) ‚Üí Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (self : GaloisCoinsertion l u), GaloisConnection l u","name":"GaloisCoinsertion.gc","isProp":true,"docString":"The Galois connection associated to a Galois coinsertion. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} [inst_4 : Nontrivial k] {p : (a : Œπ) ‚Üí P} (ha : AffineIndependent k p) (i : Œπ)\n  (s : Set Œπ), (p i ‚àà affineSpan k (p '' s) : Prop) ‚Üî (i ‚àà s : Prop)","name":"AffineIndependent.mem_affineSpan_iff","isProp":true,"docString":"If a family is affinely independent, a point in the family is in\nthe span of some of the points given by a subset of the index type if\nand only if that point's index is in the subset, if the underlying\nring is nontrivial. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : (a : Œ±) ‚Üí Set Œ≤} {x : Œ±} {y : Œ≤} (xs : x ‚àà s) (ytx : y ‚àà t x),\n  y ‚àà Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà s) ‚Ü¶ t x","name":"Set.mem_bunion·µ¢","isProp":true,"docString":"A specialization of `mem_union·µ¢‚ÇÇ`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (f : (a : ‚Ñï) ‚Üí Œ±) (n : ‚Ñï),\n  List.prod (List.map f (List.range (Nat.succ n))) =\n    f 0 * List.prod (List.map (fun (i : ‚Ñï) ‚Ü¶ f (Nat.succ i)) (List.range n))","name":"List.prod_range_succ'","isProp":true,"docString":"A variant of `prod_range_succ` which pulls off the first\nterm in the product rather than the last."},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {s : Set G} {p : (a : G) ‚Üí Prop} {x : G} (h : x ‚àà AddSubgroup.closure s) (H1 : p 0)\n  (Hmul : ‚àÄ (x : G) (y : G) (a : y ‚àà s) (a : p x), p (x + y))\n  (Hinv : ‚àÄ (x : G) (y : G) (a : y ‚àà s) (a : p x), p (x + -y)), p x","name":"AddSubgroup.closure_induction_right","isProp":true,"docString":"For additive subgroups generated by a single element, see the simpler\n`zsmul_induction_right`."},{"type":"‚àÄ {B : Type u_1} (F : Type u_3) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : (a : B) ‚Üí Type u_2)\n  [inst_2 : TopologicalSpace (Bundle.TotalSpace E)] [inst_3 : (b : B) ‚Üí TopologicalSpace (E b)]\n  [inst_4 : FiberBundle F E], IsOpenMap Bundle.TotalSpace.proj","name":"FiberBundle.isOpenMap_proj","isProp":true,"docString":"The projection from a fiber bundle to its base is an open map. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] (C : ‚Ñù) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu‚ÇÇ : ‚àÄ (n : ‚Ñï), dist (f n) (f (n + 1)) ‚â§ C / 2 / 2 ^ n), CauchySeq f","name":"cauchySeq_of_le_geometric_two","isProp":true,"docString":"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. "},{"type":"‚àÄ {Œ± : Type u_1}, Subsingleton (Vector Œ± 0)","name":"Vector.zero_subsingleton","isProp":true,"docString":"The empty `Vector` is a `Subsingleton`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {N : Type u_3} {P : Type u_4} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : AddCommGroup P] [inst_6 : Module R P]\n  (f : M ‚Üí‚Çó[R] N) (g : N ‚Üí‚Çó[R] P) (hf1 : Submodule.Fg (LinearMap.ker f)) (hf2 : Submodule.Fg (LinearMap.ker g))\n  (hsur : Function.Surjective (Submodule.asFun f)), Submodule.Fg (LinearMap.ker (LinearMap.comp g f))","name":"Submodule.fg_ker_comp","isProp":true,"docString":"The kernel of the composition of two linear maps is finitely generated if both kernels are and\nthe first morphism is surjective. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {R : D ‚•§ C} (h : L ‚ä£ R) [inst_2 : CategoryTheory.IsIso (CategoryTheory.Adjunction.counit h)],\n  CategoryTheory.Faithful R","name":"CategoryTheory.R_faithful_of_counit_isIso","isProp":true,"docString":"If the counit is an isomorphism, then the right adjoint is faithful"},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤],\n  ContinuousMap.compactOpen = ContinuousMap.compactConvergenceTopology","name":"ContinuousMap.compactOpen_eq_compactConvergence","isProp":true,"docString":"The compact-open topology is equal to the compact-convergence topology. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {A : C} {B : C} {f : A ‚ü∂ B} {g : A ‚ü∂ B}\n  [inst_1 : CategoryTheory.IsReflexivePair f g], CategoryTheory.IsReflexivePair g f","name":"CategoryTheory.IsReflexivePair.swap","isProp":true,"docString":"If `f,g` is reflexive, then `g,f` is reflexive. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {y : Œ±} {s : Set Œ±} (hx : x ‚àà s) (hy : y ‚àà s),\n  edist x y ‚â§ EMetric.diam s","name":"EMetric.edist_le_diam_of_mem","isProp":true,"docString":"If two points belong to some set, their edistance is bounded by the diameter of the set "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ≤] [inst_2 : SuccOrder Œ≤]\n  [inst_3 : IsSuccArchimedean Œ≤] [inst_4 : Nonempty Œ≤] {s : (a : Œ≤) ‚Üí Set Œ±} (H : ‚àÄ (n : Œ≤), IsConnected (s n))\n  (K : ‚àÄ (n : Œ≤), Set.Nonempty (s n ‚à© s (Order.succ n))), IsConnected (Set.union·µ¢ fun (n : Œ≤) ‚Ü¶ s n)","name":"IsConnected.union·µ¢_of_chain","isProp":true,"docString":"The union·µ¢ of connected sets indexed by a type with an archimedean successor (like `‚Ñï` or `‚Ñ§`)\nsuch that any two neighboring sets meet is connected. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : DivisionMonoid Œ≤] (f : Œ± ‚Üí* Œ≤) (g : Œ±) (h : Œ±),\n  ‚Üëf (g * h‚Åª¬π) = ‚Üëf g * (‚Üëf h)‚Åª¬π","name":"MonoidHom.map_mul_inv","isProp":true,"docString":"Group homomorphisms preserve division. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  [inst_3 : Archimedean ùïú], DenseRange Rat.cast","name":"Rat.denseRange_cast","isProp":true,"docString":"Rational numbers are dense in a linear ordered archimedean field. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œπ : Type u_1} {m : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} [inst : Countable Œπ]\n  {t : (a : Œπ) ‚Üí Set Œ±} {f : (i : Œπ) ‚Üí (a : ‚Üë(t i)) ‚Üí Œ≤}\n  (htf :\n    ‚àÄ (i : Œπ) (j : Œπ) (x : Œ±) (hxi : x ‚àà t i) (hxj : x ‚àà t j),\n      f i { val := x, property := hxi } = f j { val := x, property := hxj })\n  {T : Set Œ±} (hT : T ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ t i) (htm : ‚àÄ (i : Œπ), MeasurableSet (t i))\n  (hfm : ‚àÄ (i : Œπ), Measurable (f i)), Measurable (Set.union·µ¢Lift t f htf T hT)","name":"measurable_union·µ¢Lift","isProp":true,"docString":"Let `t i` be a countable covering of a set `T` by measurable sets. Let `f i : t i ‚Üí Œ≤` be a\nfamily of functions that agree on the intersections `t i ‚à© t j`. Then the function\n`Set.union·µ¢Lift t f _ _ : T ‚Üí Œ≤`, defined as `f i ‚ü®x, hx‚ü©` for `hx : x ‚àà t i`, is measurable. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} {r : ‚Ñö}, padicNorm p (q + r) ‚â§ max (padicNorm p q) (padicNorm p r)","name":"padicNorm.nonarchimedean","isProp":true,"docString":"The `p`-adic norm is nonarchimedean: the norm of `p + q` is at most the max of the norm of `p`\nand the norm of `q`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : LinearOrder E] {s : Set E}\n  {f : (a : E) ‚Üí Œ≤} (hs : Convex ùïú s)\n  (hf :\n    ‚àÄ ‚¶Éx : E‚¶Ñ (a : x ‚àà s) ‚¶Éy : E‚¶Ñ (a : y ‚àà s) (a : x < y) ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 < a) (a_2 : 0 < b) (a_3 : a + b = 1),\n      f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ f x + b ‚Ä¢ f y),\n  ConvexOn ùïú s f","name":"LinearOrder.convexOn_of_lt","isProp":true,"docString":"For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is convex, it suffices to\nverify the inequality `f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ a ‚Ä¢ f x + b ‚Ä¢ f y` only for `x < y` and positive `a`,\n`b`. The main use case is `E = ùïú` however one can apply it, e.g., to `ùïú^n` with lexicographic order.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {s : Set Œ±} {b : Œ±} (h‚ÇÅ : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), a ‚â§ b)\n  (h‚ÇÇ : ‚àÄ (w : Œ±) (a : w < b), ‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (w < a : Prop)), sup‚Çõ s = b","name":"sup‚Çõ_eq_of_forall_le_of_forall_lt_exists_gt","isProp":true,"docString":"Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that `b`\nis larger than all elements of `s`, and that this is not the case of any `w < b`.\nSee `csup‚Çõ_eq_of_forall_le_of_forall_lt_exists_gt` for a version in conditionally complete\nlattices. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {E : Type u_3}\n  [inst_2 : Norm E] {F : Type u_4} [inst_3 : Norm F] (e : LocalHomeomorph Œ± Œ≤) {b : Œ≤}\n  (hb : b ‚àà LocalEquiv.target (LocalHomeomorph.toLocalEquiv e)) {f : (a : Œ≤) ‚Üí E} {g : (a : Œ≤) ‚Üí F},\n  (f =o[nhds b] g : Prop) ‚Üî ((f ‚àò ‚Üëe) =o[nhds (‚Üë(LocalHomeomorph.symm e) b)] (g ‚àò ‚Üëe) : Prop)","name":"LocalHomeomorph.isLittleO_congr","isProp":true,"docString":"Transfer `IsLittleO` over a `LocalHomeomorph`. "},{"type":"‚àÄ {Œ± : Type u} (p : (a : Œ±) ‚Üí Bool) (xs : List Œ±) (h : ‚àÄ (x : Œ±) (a : x ‚àà xs), ¬¨(p x = true : Prop)) (sep : Œ±)\n  (hsep : p sep = true) (as : List Œ±), List.splitOnP p (xs ++ sep :: as) = xs :: List.splitOnP p as","name":"List.splitOnP_first","isProp":true,"docString":"When a list of the form `[...xs, sep, ...as]` is split on `p`, the first element is `xs`,\nassuming no element in `xs` satisfies `p` but `sep` does satisfy `p` "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {f : M ‚Üí* N}\n  (h : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëf ‚Üëy)) (y : { x : M // x ‚àà S }) (w : N) (z : N),\n  (z = w * ‚Üë(‚Üë(IsUnit.liftRight (MonoidHom.restrict f S) h) y)‚Åª¬π : Prop) ‚Üî (z * ‚Üëf ‚Üëy = w : Prop)","name":"Submonoid.LocalizationMap.mul_inv_right","isProp":true,"docString":"Given a MonoidHom `f : M ‚Üí* N` and Submonoid `S ‚äÜ M` such that `f(S) ‚äÜ NÀ£`, for all\n`w, z : N` and `y ‚àà S`, we have `z = w * (f y)‚Åª¬π ‚Üî z * f y = w`. "},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï} {k : ‚Ñï} (p_large : n < p ^ 2), ‚Üë(Nat.factorization (Nat.choose n k)) p ‚â§ 1","name":"Nat.factorization_choose_le_one","isProp":true,"docString":"Primes greater than about `sqrt n` appear only to multiplicity 0 or 1\nin the binomial coefficient. "},{"type":"‚àÄ {P : Type u_1} [inst : LE P] (self : Order.Ideal P),\n  DirectedOn (fun (x : P) (x_1 : P) ‚Ü¶ x ‚â§ x_1) (LowerSet.carrier (Order.Ideal.toLowerSet self))","name":"Order.Ideal.directed'","isProp":true,"docString":"The ideal is upward directed. "},{"type":"‚àÄ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : MonoidHomClass F G H]\n  (f : F), (Function.Injective ‚Üëf : Prop) ‚Üî (‚àÄ (a : G) (a_1 : ‚Üëf a = 1), a = 1 : Prop)","name":"injective_iff_map_eq_one","isProp":true,"docString":"A homomorphism from a group to a monoid is injective iff its kernel is trivial.\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`.  "},{"type":"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (M : Matrix n n R),\n  Matrix.det (Matrix.transpose M) = Matrix.det M","name":"Matrix.det_transpose","isProp":true,"docString":"Transposing a matrix preserves the determinant. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G],\n  (Group.Fg G : Prop) ‚Üî (‚àÉ (S : Set G), (Subgroup.closure S = ‚ä§ : Prop) ‚àß (Set.Finite S : Prop) : Prop)","name":"Group.fg_iff","isProp":true,"docString":"An equivalent expression of `Group.Fg` in terms of `Set.Finite` instead of `Finset`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : C ‚•§ D}\n  (h_obj :\n    ‚àÄ (X : C),\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X =\n        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) X)\n  (h_map :\n    ‚àÄ (X : C) (Y : C) (f : X ‚ü∂ Y),\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f =\n        CategoryTheory.eqToHom\n            ((h_obj\n                  X=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X =\n                  Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G)\n                    X)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X =\n                Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) X) ‚â´\n          Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) f ‚â´\n            CategoryTheory.eqToHom\n              ((Eq.symm\n                    ((h_obj\n                          Y=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y =\n                          Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G)\n                            Y)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y =\n                        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G)\n                          Y)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) Y =\n                    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F)\n                      Y)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) Y =\n                  Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y)),\n  F = G","name":"CategoryTheory.Functor.ext","isProp":true,"docString":"Proving equality between functors. This isn't an extensionality lemma,\nbecause usually you don't really want to do this. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± √ó Œ≤)","name":"instCompactSpaceProdInstTopologicalSpaceProd","isProp":true,"docString":"The product of two compact spaces is compact. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {w : (a : Œ±) ‚Üí M} {b : M} [inst_1 : LinearOrderedCancelAddCommMonoid M]\n  (ht : ‚àÄ (y : Œ≤) (x : ¬¨(y ‚àà t : Prop)), 0 ‚â§ Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x)\n  (hb : (Finset.sum s fun (x : Œ±) ‚Ü¶ w x) < Finset.card t ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß ((Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x) < b : Prop)","name":"Finset.exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:\nif the total weight of a finite set of pigeons is less than `n ‚Ä¢ b`, they are sorted into some\npigeonholes, and for all but `n` pigeonholes the total weight of the pigeons there is nonnegative,\nthen for at least one of these `n` pigeonholes, the total weight of the pigeons in this pigeonhole\nis less than `b`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F}\n  {l : Filter Œ±} (a : ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ (a : 0 < c), Asymptotics.IsBigOWith c l f g), f =o[l] g","name":"Asymptotics.IsLittleO.of_isBigOWith","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_iff_forall_isBigOWith`."},{"type":"‚àÄ {Œπ : Sort u_1} [inst : Nonempty Œπ] {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h : x ‚â† ‚ä§),\n  x * inf·µ¢ f = inf·µ¢ fun (i : Œπ) ‚Ü¶ x * f i","name":"ENNReal.mul_inf·µ¢","isProp":true,"docString":"If `x ‚â† ‚àû`, then left multiplication by `x` maps infimum over a nonempty type to infimum. See\nalso `ENNReal.mul_inf·µ¢_of_ne` that assumes `x ‚â† 0` but does not require `[Nonempty Œπ]`. "},{"type":"‚àÄ {G : Type u} [inst : Monoid G], IsOfFinOrder 1","name":"isOfFinOrder_one","isProp":true,"docString":"1 is of finite order in any monoid. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G} {p : (a : G) ‚Üí Prop} {x : G} (h : x ‚àà Subgroup.closure s) (H1 : p 1)\n  (Hmul : ‚àÄ (x : G) (y : G) (a : y ‚àà s) (a : p x), p (x * y))\n  (Hinv : ‚àÄ (x : G) (y : G) (a : y ‚àà s) (a : p x), p (x * y‚Åª¬π)), p x","name":"Subgroup.closure_induction_right","isProp":true,"docString":"For subgroups generated by a single element, see the simpler `zpow_induction_right`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : CommMonoid Œ≤] {s : Finset Œ±} {t : Finset Œ≥} {f : (a : Œ±) ‚Üí Œ≤}\n  {g : (a : Œ≥) ‚Üí Œ≤} (i : (a : Œ±) ‚Üí (a : a ‚àà s) ‚Üí Œ≥) (hi : ‚àÄ (a : Œ±) (ha : a ‚àà s), i a ha ‚àà t)\n  (h : ‚àÄ (a : Œ±) (ha : a ‚àà s), f a = g (i a ha))\n  (i_inj : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (ha‚ÇÅ : a‚ÇÅ ‚àà s) (ha‚ÇÇ : a‚ÇÇ ‚àà s) (a : i a‚ÇÅ ha‚ÇÅ = i a‚ÇÇ ha‚ÇÇ), a‚ÇÅ = a‚ÇÇ)\n  (i_surj : ‚àÄ (b : Œ≥) (a : b ‚àà t), ‚àÉ (a : Œ±), ‚àÉ (ha : a ‚àà s), b = i a ha),\n  (Finset.prod s fun (x : Œ±) ‚Ü¶ f x) = Finset.prod t fun (x : Œ≥) ‚Ü¶ g x","name":"Finset.prod_bij","isProp":true,"docString":"Reorder a product.\n\nThe difference with `prod_bij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function.\n"},{"type":"‚àÄ {Œ± : Type u} (a : Set.Finite Set.univ), Finite Œ±","name":"Finite.of_finite_univ","isProp":true,"docString":"**Alias** of the forward direction of `Set.finite_univ_iff`."},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [self : CommGroupWithZero G‚ÇÄ] (a : G‚ÇÄ), CommGroupWithZero.zpow 0 a = 1","name":"CommGroupWithZero.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {K : Type u} {V : Type v} {V‚ÇÅ : Type v} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V‚ÇÅ] [inst_6 : Module K V‚ÇÅ]\n  [inst_7 : Module.Free K V‚ÇÅ] (cond : Module.rank K V = Module.rank K V‚ÇÅ), Nonempty (V ‚âÉ‚Çó[K] V‚ÇÅ)","name":"nonempty_linearEquiv_of_rank_eq","isProp":true,"docString":"Two vector spaces are isomorphic if they have the same dimension. "},{"type":"‚àÄ {R : Type x} [inst : Ring R] [inst_1 : NoZeroDivisors R] (u : RÀ£),\n  (u‚Åª¬π = u : Prop) ‚Üî ((u = 1 : Prop) ‚à® (u = -1 : Prop) : Prop)","name":"Units.inv_eq_self_iff","isProp":true,"docString":"In the unit group of an integral domain, a unit is its own inverse iff the unit is one or\none's additive inverse. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedRing Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx - y‚Äñ","name":"NormedRing.dist_eq","isProp":true,"docString":"The distance is induced by the norm. "},{"type":"‚àÄ {n : ‚Ñï}, ‚Üë(Fin.succAbove 0) = Fin.succ","name":"Fin.succAbove_zero","isProp":true,"docString":"Embedding `Fin n` into `Fin (n + 1)` with a hole around zero embeds by `succ`. "},{"type":"‚àÄ {n : ‚Ñï} {x : ‚Ñï √ó ‚Ñï}, (x ‚àà List.Nat.antidiagonal n : Prop) ‚Üî (Prod.fst x + Prod.snd x = n : Prop)","name":"List.Nat.mem_antidiagonal","isProp":true,"docString":"A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`. "},{"type":"‚àÄ {I : Type u_2} {f : (a : I) ‚Üí Type u_1} (i' : I) [inst : ‚àÄ (i : I), Nonempty (f i)] [inst : Nontrivial (f i')],\n  Nontrivial ((i : I) ‚Üí f i)","name":"Pi.nontrivial_at","isProp":true,"docString":"A pi type is nontrivial if it's nonempty everywhere and nontrivial somewhere. "},{"type":"‚àÄ {T : Type u‚ÇÅ} [inst : CategoryTheory.Category T] {X : T} {f : CategoryTheory.Under X} {g : CategoryTheory.Under X}\n  (k : f ‚ü∂ g) [inst_1 : CategoryTheory.Epi k], CategoryTheory.Epi (CategoryTheory.CommaMorphism.right k)","name":"CategoryTheory.Under.epi_right_of_epi","isProp":true,"docString":"If `k` is a epimorphism, then `k.right` is a epimorphism. In other words, `Under.forget X` preserves\nepimorphisms.\nThe converse of `CategoryTheory.under.epi_of_epi_right`.\n"},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCancelAddCommMonoid Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"LinearOrderedCancelAddCommMonoid.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {n : ‚Ñï} (h : n ‚â† 0) (d : ‚Ñï), Filter.Frequently (fun (m : ‚Ñï) ‚Ü¶ m ‚â° d [MOD n]) Filter.atTop","name":"Nat.frequently_modEq","isProp":true,"docString":"Infinitely many natural numbers are equal to `d` mod `n`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {f : Filter Œ±} [inst : IsTrans Œ± r] [inst : Filter.NeBot f]\n  (a : Filter.IsBounded r f), Filter.IsCobounded (flip r) f","name":"Filter.IsBounded.isCobounded_flip","isProp":true,"docString":"A filter which is eventually bounded is in particular frequently bounded (in the opposite\ndirection). At least if the filter is not trivial. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {r : ENNReal}\n  (H1 : ‚àÄ (x : Œ±) (a : x ‚àà s), EMetric.infEdist x t ‚â§ r) (H2 : ‚àÄ (x : Œ±) (a : x ‚àà t), EMetric.infEdist x s ‚â§ r),\n  EMetric.hausdorffEdist s t ‚â§ r","name":"EMetric.hausdorffEdist_le_of_infEdist","isProp":true,"docString":"Bounding the Hausdorff edistance by bounding the edistance of any point\nin each set to the other set "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLattice Œ±] {b : Œ±} [inst_1 : Nonempty Œπ] {f : (a : Œπ) ‚Üí Œ±}\n  (h‚ÇÅ : ‚àÄ (i : Œπ), f i ‚â§ b) (h‚ÇÇ : ‚àÄ (w : Œ±) (a : w < b), ‚àÉ (i : Œπ), w < f i), (sup·µ¢ fun (i : Œπ) ‚Ü¶ f i) = b","name":"csup·µ¢_eq_of_forall_le_of_forall_lt_exists_gt","isProp":true,"docString":"Introduction rule to prove that `b` is the supremum of `f`: it suffices to check that `b`\nis larger than `f i` for all `i`, and that this is not the case of any `w<b`.\nSee `sup·µ¢_eq_of_forall_le_of_forall_lt_exists_gt` for a version in complete lattices. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {S : Set Œ±} {U : Set Œ±} {Z : Set Œ±} (hZ : IsPreirreducible Z)\n  (hU : Set.Nonempty U) (hU' : IsOpen U) (h‚ÇÅ : U ‚äÜ S) (h‚ÇÇ : S ‚äÜ Z), IsIrreducible S","name":"IsPreirreducible.subset_irreducible","isProp":true,"docString":"If `‚àÖ ‚â† U ‚äÜ S ‚äÜ Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : (a : Œ±) ‚Üí Œ≤} [inst : AddCommMonoid Œ≤] (R : Setoid Œ±)\n  [inst_1 : DecidableRel Setoid.r],\n  (Finset.sum s fun (x : Œ±) ‚Ü¶ f x) =\n    Finset.sum (Finset.image Quotient.mk'' s) fun (xbar : Quotient R) ‚Ü¶\n      Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ Quotient.mk R x = xbar) s) fun (y : Œ±) ‚Ü¶ f y","name":"Finset.sum_partition","isProp":true,"docString":"A sum can be partitioned into a sum of sums, each equivalent under a setoid."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {l : (a : Œ±) ‚Üí Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (self : GaloisInsertion l u) (a : Œ±) (h : u (l a) ‚â§ a), GaloisInsertion.choice self a h = l a","name":"GaloisInsertion.choice_eq","isProp":true,"docString":"Property of the choice function. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ±' : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_2} {Œ¥ : Type u_1} {m : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {f : Filter Œ±}\n  {g : Filter Œ≤} {n : (a : Œ≥) ‚Üí Œ¥} {m' : (a : Œ≤) ‚Üí (a : Œ±') ‚Üí Œ¥} {n' : (a : Œ±) ‚Üí Œ±'}\n  (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), n (m a b) = m' b (n' a)),\n  Filter.map n (Filter.map‚ÇÇ m f g) = Filter.map‚ÇÇ m' g (Filter.map n' f)","name":"Filter.map_map‚ÇÇ_antidistrib_right","isProp":true,"docString":"Symmetric statement to `Filter.map_map‚ÇÇ_right_anticomm`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : MulOneClass Œ±]\n  [inst_3 : MulOneClass Œ≤] (self : Œ± ‚Üí*o Œ≤), Monotone (OneHom.toFun ‚Üë(OrderMonoidHom.toMonoidHom self))","name":"OrderMonoidHom.monotone'","isProp":true,"docString":"An `OrderMonoidHom` is a monotone function. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : Ring ùïú] [inst_1 : SeminormedAddCommGroup E] [inst_2 : Module ùïú E]\n  {s : Submodule ùïú E} (x : { x : E // x ‚àà s }), ‚Äñx‚Äñ = ‚Äñ‚Üëx‚Äñ","name":"Submodule.coe_norm","isProp":true,"docString":"If `x` is an element of a submodule `s` of a normed group `E`, its norm in `s` is equal to its\nnorm in `E`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {J : Type u‚ÇÅ} {K : Type u‚ÇÅ} [inst_1 : CategoryTheory.Category J]\n  [inst_2 : CategoryTheory.Category K] (F : J ‚•§ C) (G : K ‚•§ C)\n  (h : CategoryTheory.Functor.cones F ‚âÖ CategoryTheory.Functor.cones G) [inst_3 : CategoryTheory.Limits.HasLimit F],\n  CategoryTheory.Limits.HasLimit G","name":"CategoryTheory.Limits.HasLimit.ofConesIso","isProp":true,"docString":"If a functor `G` has the same collection of cones as a functor `F`\nwhich has a limit, then `G` also has a limit. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {l : Filter Œ±} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} {t : Set Œ±}\n  (hl : Filter.HasBasis l p s), (t ‚àà l : Prop) ‚Üî (‚àÉ (i : Œπ), (p i : Prop) ‚àß (s i ‚äÜ t : Prop) : Prop)","name":"Filter.HasBasis.mem_iff","isProp":true,"docString":"Definition of `HasBasis` unfolded with implicit set argument. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : LinearOrder Œπ] (s : Finset Œπ) (f : (a : Œπ) ‚Üí R),\n  (Finset.prod s fun (i : Œπ) ‚Ü¶ 1 - f i) =\n    1 - Finset.sum s fun (i : Œπ) ‚Ü¶ f i * Finset.prod (Finset.filter (fun (x : Œπ) ‚Ü¶ x < i) s) fun (j : Œπ) ‚Ü¶ 1 - f j","name":"Finset.prod_one_sub_ordered","isProp":true,"docString":"`‚àè i, (1 - f i) = 1 - ‚àë i, f i * (‚àè j < i, 1 - f j)`. This formula is useful in construction of\na partition of unity from a collection of ‚Äúbump‚Äù functions.  "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (S : Set (AddCon M)),\n  sup‚Çõ S = addConGen fun (x : M) (y : M) ‚Ü¶ ‚àÉ (c : AddCon M), (c ‚àà S : Prop) ‚àß (‚Üëc x y : Prop)","name":"AddCon.sup‚Çõ_eq_addConGen","isProp":true,"docString":"The supremum of a set of additive congruence relations `S` equals\nthe smallest additive congruence relation containing the binary relation 'there exists `c ‚àà S`\nsuch that `x` is related to `y` by `c`'."},{"type":"‚àÄ {Œ± : Type u_1} [inst : HeytingAlgebra Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b·∂ú), b ‚â§ a·∂ú","name":"le_compl_of_le_compl","isProp":true,"docString":"**Alias** of the forward direction of `le_compl_comm`."},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, (affineSpan k s = ‚ä• : Prop) ‚Üî (s = ‚àÖ : Prop)","name":"affineSpan_eq_bot","isProp":true,"docString":"The affine span of a set is `‚ä•` if and only if that set is empty. "},{"type":"‚àÄ {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñï} {y : ‚Ñï} (hy : y ‚â† 0), (b ^ x ‚â§ y : Prop) ‚Üî (x ‚â§ Nat.log b y : Prop)","name":"Nat.pow_le_iff_le_log","isProp":true,"docString":"`pow b` and `log b` (almost) form a Galois connection. See also `Nat.pow_le_of_le_log` and\n`Nat.le_log_of_pow_le` for individual implications under weaker assumptions. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} (hf : Function.Injective2 f) (b : Œ≤),\n  Function.Injective fun (a : Œ±) ‚Ü¶ f a b","name":"Function.Injective2.left","isProp":true,"docString":"A binary injective function is injective when only the left argument varies. "},{"type":"‚àÄ (k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [inst : Semiring k] [inst_1 : Add G] {A : Type u‚ÇÉ} [inst_2 : NonUnitalNonAssocSemiring A]\n  [inst_3 : DistribMulAction k A] {œÜ‚ÇÅ : AddMonoidAlgebra k G ‚Üí‚Çô‚Çê[k] A} {œÜ‚ÇÇ : AddMonoidAlgebra k G ‚Üí‚Çô‚Çê[k] A}\n  (h :\n    MulHom.comp (NonUnitalAlgHom.toMulHom œÜ‚ÇÅ) (AddMonoidAlgebra.ofMagma k G) =\n      MulHom.comp (NonUnitalAlgHom.toMulHom œÜ‚ÇÇ) (AddMonoidAlgebra.ofMagma k G)),\n  œÜ‚ÇÅ = œÜ‚ÇÇ","name":"AddMonoidAlgebra.nonUnitalAlgHom_ext'","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {F : (a : Type u) ‚Üí Type v} [inst : Applicative F] {G : (a : Type u) ‚Üí Type w} [inst_1 : Applicative G]\n  (self : ApplicativeTransformation F G) {Œ± : Type u} (x : Œ±), ApplicativeTransformation.app self Œ± (pure x) = pure x","name":"ApplicativeTransformation.preserves_pure'","isProp":true,"docString":"An `ApplicativeTransformation` preserves `pure`. "},{"type":"‚àÄ {n : ‚Ñï} {d : ‚Ñï} (hnd : d ‚à£ n),\n  Nat.totient (n / d) = Finset.card (Finset.filter (fun (k : ‚Ñï) ‚Ü¶ Nat.gcd n k = d) (Finset.range n))","name":"Nat.totient_div_of_dvd","isProp":true,"docString":"For `d ‚à£ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` "},{"type":"‚àÄ (C : Type u‚ÇÅ) [inst : CategoryTheory.Category C] (D : Type u‚ÇÇ) [inst_1 : CategoryTheory.Category D] (X : C) (Y : D),\n  ùüô (X, Y) = (ùüô X, ùüô Y)","name":"CategoryTheory.prod_id","isProp":true,"docString":"Two rfl lemmas that cannot be generated by `@[simps]`. "},{"type":"‚àÄ {Œπ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : (a : Œπ) ‚Üí Set X} {s : Set X}\n  (hs : IsClosed s) (uo : ‚àÄ (i : Œπ), IsOpen (u i))\n  (uf : ‚àÄ (x : X) (a : x ‚àà s), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ x ‚àà u i)) (us : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ u i),\n  ‚àÉ (v : (a : Œπ) ‚Üí Set X),\n    (s ‚äÜ Set.union·µ¢ v : Prop) ‚àß ((‚àÄ (i : Œπ), IsClosed (v i) : Prop) ‚àß (‚àÄ (i : Œπ), v i ‚äÜ u i : Prop) : Prop)","name":"exists_subset_union·µ¢_closed_subset","isProp":true,"docString":"**Shrinking lemma**. A point-finite open cover of a closed subset of a normal space can be\n\"shrunk\" to a new closed cover so that each new closed set is contained in the corresponding\noriginal open set. See also `exists_subset_union·µ¢_closure_subset` for a stronger statement. "},{"type":"‚àÄ {S : Type u_2} {R : Type u} {M : Type v} {N : Type u_1} [inst : Semiring S] [inst_1 : AddCommMonoid R]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : Module S R] [inst_5 : Module S M]\n  [inst_6 : Module S N] ‚¶Éf : TrivSqZeroExt R M ‚Üí‚Çó[S] N‚¶Ñ ‚¶Ég : TrivSqZeroExt R M ‚Üí‚Çó[S] N‚¶Ñ\n  (hl : ‚àÄ (r : R), ‚Üëf (TrivSqZeroExt.inl r) = ‚Üëg (TrivSqZeroExt.inl r))\n  (hr : ‚àÄ (m : M), ‚Üëf (TrivSqZeroExt.inr m) = ‚Üëg (TrivSqZeroExt.inr m)), f = g","name":"TrivSqZeroExt.linearMap_ext","isProp":true,"docString":"This cannot be marked `@[ext]` as it ends up being used instead of `LinearMap.prod_ext` when\nworking with `R √ó M`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommGroup M] (h : Module ‚Ñ§ M) (n : ‚Ñ§) (x : M), SMul.smul n x = n ‚Ä¢ x","name":"int_smul_eq_zsmul","isProp":true,"docString":"Convert back any exotic `‚Ñ§`-smul to the canonical instance. This should not be needed since in\nmathlib all `AddCommGroup`s should normally have exactly one `‚Ñ§`-module structure by design. "},{"type":"‚àÄ {V : Type u} [inst : Fintype V] {‚Ñì : ‚Ñï}, SimpleGraph.IsSRGWith ‚ä• (Fintype.card V) 0 ‚Ñì 0","name":"SimpleGraph.bot_strongly_regular","isProp":true,"docString":"Empty graphs are strongly regular. Note that `‚Ñì` can take any value\nfor empty graphs, since there are no pairs of adjacent vertices. "},{"type":"‚àÄ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsLeftCancelAdd G], IsRightCancelAdd G","name":"AddCommSemigroup.IsLeftCancelAdd.toIsRightCancelAdd","isProp":true,"docString":"Any\n`AddCommSemigroup G` that satisfies `IsLeftCancelAdd G` also satisfies\n`IsRightCancelAdd G`."},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí Preorder (œÄ i)] {a : (i : Œπ) ‚Üí œÄ i} {b : (i : Œπ) ‚Üí œÄ i}\n  {c : (i : Œπ) ‚Üí œÄ i} (hab : a ‚â§ b) (hbc : StrongLT b c), StrongLT a c","name":"LE.le.trans_strongLT","isProp":true,"docString":"**Alias** of `strongLT_of_le_of_strongLT`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : MeasurableEmbedding f) ‚¶És : Set Œ±‚¶Ñ (a : MeasurableSet s), MeasurableSet (f '' s)","name":"MeasurableEmbedding.measurableSet_image'","isProp":true,"docString":"The image of a measurable set under a measurable embedding is a measurable set. "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} (f : (a : Fin n) ‚Üí Œ±), List.length (List.ofFn f) = n","name":"List.length_ofFn","isProp":true,"docString":"The length of a list converted from a function is the size of the domain. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : LocallyCompactSpace Œ±], Continuous FunLike.coe","name":"ContinuousMap.continuous_coe'","isProp":true,"docString":"See also `ContinuousMap.continuous_coe` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ≤], UniformContinuous ‚ÜëUniformFun.toFun","name":"UniformFun.uniformContinuous_toFun","isProp":true,"docString":"The natural map `UniformFun.toFun` from `Œ± ‚Üí·µ§ Œ≤` to `Œ± ‚Üí Œ≤` is uniformly continuous.\n\nIn other words, the uniform structure of uniform convergence is finer than that of pointwise\nconvergence, aka the product uniform structure. "},{"type":"‚àÄ {R : Type u_2} [inst : CancelCommMonoidWithZero R] {Œ± : Type u_1} [inst_1 : DecidableEq Œ±] {x : R} {y : R} {a : R}\n  {s : Finset Œ±} {p : (a : Œ±) ‚Üí R} (hp : ‚àÄ (i : Œ±) (a : i ‚àà s), Prime (p i))\n  (hx : x * y = a * Finset.prod s fun (i : Œ±) ‚Ü¶ p i),\n  ‚àÉ (t : Finset Œ±),\n    ‚àÉ (u : Finset Œ±),\n      ‚àÉ (b : R),\n        ‚àÉ (c : R),\n          (t ‚à™ u = s : Prop) ‚àß\n            ((Disjoint t u : Prop) ‚àß\n                ((a = b * c : Prop) ‚àß\n                    ((x = b * Finset.prod t fun (i : Œ±) ‚Ü¶ p i : Prop) ‚àß\n                        (y = c * Finset.prod u fun (i : Œ±) ‚Ü¶ p i : Prop) :\n                      Prop) :\n                  Prop) :\n              Prop)","name":"mul_eq_mul_prime_prod","isProp":true,"docString":"If `x * y = a * ‚àè i in s, p i` where `p i` is always prime, then\n`x` and `y` can both be written as a divisor of `a` multiplied by\na product over a subset of `s`  "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Semiring R‚ÇÉ]\n  {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : outParam (R‚ÇÅ ‚Üí+* R‚ÇÉ)} [self : RingHomCompTriple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ],\n  RingHom.comp œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÇ = œÉ‚ÇÅ‚ÇÉ","name":"RingHomCompTriple.comp_eq","isProp":true,"docString":"The morphisms form a commutative triangle "},{"type":"‚àÄ {R : Type u_3} {M : Type u_1} [inst : CommSemiring R] {œÉ : Type u_2} [inst_1 : AddCommMonoid M]\n  [inst_2 : SemilatticeSup M] [inst_3 : OrderBot M] (w : (a : œÉ) ‚Üí M) {p : MvPolynomial œÉ R}\n  (hp : MvPolynomial.weightedTotalDegree w p = ‚ä•), MvPolynomial.IsWeightedHomogeneous w p ‚ä•","name":"MvPolynomial.isWeightedHomogeneous_of_total_degree_zero","isProp":true,"docString":"A polynomial of weightedTotalDegree `‚ä•` is weighted_homogeneous of degree `‚ä•`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤) (a : Œ±) (b : Œ±),\n  ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b","name":"RingHom.map_add","isProp":true,"docString":"Ring homomorphisms preserve addition. "},{"type":"‚àÄ {E : (a : ‚Ñï) ‚Üí Type u_1} [inst : (n : ‚Ñï) ‚Üí TopologicalSpace (E n)] [inst_1 : ‚àÄ (n : ‚Ñï), DiscreteTopology (E n)]\n  {x : (n : ‚Ñï) ‚Üí E n} {y : (n : ‚Ñï) ‚Üí E n} {s : Set ((n : ‚Ñï) ‚Üí E n)} (hs : IsClosed s) (hne : Set.Nonempty s)\n  (H : PiNat.longestPrefix x s < PiNat.firstDiff x y) (xs : ¬¨(x ‚àà s : Prop)) (ys : ¬¨(y ‚àà s : Prop)),\n  PiNat.cylinder x (PiNat.longestPrefix x s) = PiNat.cylinder y (PiNat.longestPrefix y s)","name":"PiNat.cylinder_longestPrefix_eq_of_longestPrefix_lt_firstDiff","isProp":true,"docString":"If two points `x, y` coincide up to length `n`, and the longest common prefix of `x` with `s`\nis strictly shorter than `n`, then the longest common prefix of `y` with `s` is the same, and both\ncylinders of this length based at `x` and `y` coincide. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 : AffineSubspace k P) (s2 : AffineSubspace k P),\n  AffineSubspace.direction s1 ‚äî AffineSubspace.direction s2 ‚â§ AffineSubspace.direction (s1 ‚äî s2)","name":"AffineSubspace.sup_direction_le","isProp":true,"docString":"The sup of the directions of two affine subspaces is less than or equal to the direction of\ntheir sup. "},{"type":"‚àÄ {Œ± : Type u} {G : Type w} [inst : TopologicalSpace G] [inst_1 : Inv G] [inst_2 : ContinuousInv G] {f : (a : Œ±) ‚Üí G}\n  {l : Filter Œ±} {y : G} (h : Filter.Tendsto f l (nhds y)), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ (f x)‚Åª¬π) l (nhds y‚Åª¬π)","name":"Filter.Tendsto.inv","isProp":true,"docString":"If a function converges to a value in a multiplicative topological group, then its inverse\nconverges to the inverse of this value. For the version in normed fields assuming additionally\nthat the limit is nonzero, use `Tendsto.inv'`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {A : Finset Œ±} {B : Finset Œ±} (h : A ‚äÜ B), Finset.toColex A ‚â§ Finset.toColex B","name":"Colex.colex_le_of_subset","isProp":true,"docString":"If `A ‚äÜ B`, then `A ‚â§ B` in the colex order. Note the converse does not hold, as `‚äÜ` is not a\nlinear order. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : b < c) (a_2 : a = b), a < c","name":"LT.lt.trans_eq'","isProp":true,"docString":"**Alias** of `lt_of_lt_of_eq'`."},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : NormedSpace ‚Ñù ùïú]\n  [inst_3 : Module ùïú E] [inst_4 : Module ‚Ñù E] [inst_5 : IsScalarTower ‚Ñù ùïú E] (p : Seminorm ùïú E) (x : E) (r : ‚Ñù),\n  Convex ‚Ñù (Seminorm.closedBall p x r)","name":"Seminorm.convex_closedBall","isProp":true,"docString":"Closed seminorm-balls are convex. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s1 : AffineSubspace k P} {s2 : AffineSubspace k P} (h : s1 < s2) (hn : Set.Nonempty ‚Üës1),\n  AffineSubspace.direction s1 < AffineSubspace.direction s2","name":"AffineSubspace.direction_lt_of_nonempty","isProp":true,"docString":"If one nonempty affine subspace is less than another, the same applies to their directions "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : AddGroup Œ±] [inst_2 : UniformAddGroup Œ±]\n  {hom : Type u_1} [inst_3 : UniformSpace Œ≤] [inst_4 : DiscreteTopology Œ≤] [inst_5 : AddGroup Œ≤]\n  [inst_6 : UniformAddGroup Œ≤] [inst_7 : AddMonoidHomClass hom Œ± Œ≤] {f : hom},\n  (UniformContinuous ‚Üëf : Prop) ‚Üî (IsOpen ‚Üë(AddMonoidHom.ker ‚Üëf) : Prop)","name":"UniformAddGroup.uniformContinuous_iff_open_ker","isProp":true,"docString":"A homomorphism from a uniform additive group to a discrete uniform additive group is\ncontinuous if and only if its kernel is open."},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {Œ±_1 : Type u_1} {p : (a : Œ±_1) ‚Üí Prop} {f : (a : Œ±) ‚Üí Œ±_1}\n  [inst : Functor m] [inst_1 : LawfulFunctor m] {x : m Œ±} (hx : SatisfiesM (fun (a : Œ±) ‚Ü¶ p (f a)) x),\n  SatisfiesM p (f <$> x)","name":"SatisfiesM.map_pre","isProp":true,"docString":"`SatisfiesM` distributes over `<$>`, weakest precondition version.\n(Use this for reasoning backward from the goal.)\n"},{"type":"‚àÄ {X : Type u} {Œ± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Œ±] [inst_2 : TopologicalSpace Œ±]\n  [inst_3 : OrderClosedTopology Œ±] [inst_4 : PreconnectedSpace X] {c : Œ±} {f : (a : X) ‚Üí Œ±} (hf : Continuous f)\n  (h‚ÇÅ : ‚àÉ (a : X), f a ‚â§ c) (h‚ÇÇ : ‚àÉ (b : X), c ‚â§ f b), c ‚àà Set.range f","name":"mem_range_of_exists_le_of_exists_ge","isProp":true,"docString":"**Intermediate Value Theorem** for continuous functions on connected spaces. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : Preorder Œπ] [inst_1 : Preorder Œ±] {l : Filter Œπ} {u : (a : Œπ) ‚Üí Œ±}\n  (h : Monotone u) [inst_2 : Filter.NeBot l] (hu : Filter.Tendsto u l Filter.atBot),\n  Filter.Tendsto u Filter.atBot Filter.atBot","name":"Filter.tendsto_atBot_of_monotone_of_filter","isProp":true,"docString":"If a monotone function `u : Œπ ‚Üí Œ±` tends to `atBot` along *some* non-trivial filter `l`, then\nit tends to `atBot` along `atBot`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C],\n  CategoryTheory.ReflectsIsomorphisms AlgebraicTopology.DoldKan.N‚ÇÇ","name":"AlgebraicTopology.DoldKan.instReflectsIsomorphismsKaroubiSimplicialObjectInstCategorySimplicialObjectInstCategoryKaroubiChainComplexPreadditiveHasZeroMorphismsNatToAddRightCancelSemigroupToAddRightCancelMonoidToAddCancelMonoidToCancelAddCommMonoidToOrderedCancelAddCommMonoidStrictOrderedSemiringToOneCanonicallyOrderedCommSemiringInstCategoryHomologicalComplexDownN‚ÇÇ","isProp":true,"docString":"We deduce that `N‚ÇÇ : Karoubi (SimplicialObject C) ‚•§ Karoubi (ChainComplex C ‚Ñï))`\nreflects isomorphisms from the fact that\n`N‚ÇÅ : SimplicialObject (Karoubi C) ‚•§ Karoubi (ChainComplex (Karoubi C) ‚Ñï)` does. "},{"type":"‚àÄ {X : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E]\n  [inst_2 : TopologicalSpace X] {f : (a : X) ‚Üí E} {s : Set X} {c : X} {y : E} (h : IsLocalMaxOn (norm ‚àò f) s c)\n  (hy : SameRay ‚Ñù (f c) y), IsLocalMaxOn (fun (x : X) ‚Ü¶ ‚Äñf x + y‚Äñ) s c","name":"IsLocalMaxOn.norm_add_sameRay","isProp":true,"docString":"If `f : Œ± ‚Üí E` is a function such that `norm ‚àò f` has a local maximum on a set `s` at a point\n`c` and `y` is a vector on the same ray as `f c`, then the function `fun x => ‚Äñf x + y‚Äñ` has a local\nmaximum on `s` at `c`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.NonPreadditiveAbelian C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y),\n  CategoryTheory.NonPreadditiveAbelian.œÉ ‚â´ f =\n    CategoryTheory.Limits.prod.map f f ‚â´ CategoryTheory.NonPreadditiveAbelian.œÉ","name":"CategoryTheory.NonPreadditiveAbelian.œÉ_comp","isProp":true,"docString":"This is the key identity satisfied by `œÉ`. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] {M‚ÇÅ' : (a : Œπ) ‚Üí Type u_1} [inst_5 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ' i)]\n  [inst_6 : (i : Œπ) ‚Üí Module R (M‚ÇÅ' i)] (f : (i : Œπ) ‚Üí M‚ÇÅ i ‚Üí‚Çó[R] M‚ÇÅ' i), MultilinearMap.compLinearMap 0 f = 0","name":"MultilinearMap.zero_compLinearMap","isProp":true,"docString":"Composing the zero multilinear map with a linear map in each argument. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] {S : Set Œ±} (H : ‚àÄ ‚¶Éi : Œ±‚¶Ñ ‚¶Éj : Œ±‚¶Ñ (a : i ‚àà S) (a : j ‚àà S), i ‚äì j ‚àà S),\n  DirectedOn (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â• x_1) S","name":"directedOn_of_inf_mem","isProp":true,"docString":"A set stable by infimum is `‚â•`-directed. "},{"type":"‚àÄ {M : Type u} [self : RightCancelMonoid M] (n : ‚Ñï) (x : M),\n  RightCancelMonoid.npow (n + 1) x = x * RightCancelMonoid.npow n x","name":"RightCancelMonoid.npow_succ","isProp":true,"docString":"Raising to the power `(n + 1 : ‚Ñï)` behaves as expected. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] {a : Œ±} {b : Œ±} {u : Œ±À£}, (a ‚à£ ‚Üëu * b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"Units.dvd_mul_left","isProp":true,"docString":"In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\nassociates of `b`. "},{"type":"‚àÄ {R : Type u_2} [inst : Ring R] {P : Type u_3} [inst_1 : AddCommGroup P] [inst_2 : Module R P] {Œπ : Type u_1}\n  (b : Basis Œπ R P), Module.Projective R P","name":"Module.Projective.of_basis","isProp":true,"docString":"Free modules are projective. "},{"type":"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] (I : Ideal Œ±) (hI : I ‚â† ‚ä§),\n  ‚àÉ (M : Ideal Œ±), (Ideal.IsMaximal M : Prop) ‚àß (I ‚â§ M : Prop)","name":"Ideal.exists_le_maximal","isProp":true,"docString":"**Krull's theorem**: if `I` is an ideal that is not the whole ring, then it is included in some\nmaximal ideal. "},{"type":"‚àÄ {R : Type v} [inst : CommRing R] (A : Matrix (Fin 2) (Fin 2) R), Matrix.det A = A 0 0 * A 1 1 - A 0 1 * A 1 0","name":"Matrix.det_fin_two","isProp":true,"docString":"Determinant of 2x2 matrix "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [hf : CategoryTheory.IsSplitEpi f],\n  CategoryTheory.Epi f","name":"CategoryTheory.IsSplitEpi.epi","isProp":true,"docString":"Every split epi is an epi. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D]\n  (F : CategoryTheory.MonoidalFunctor C D)\n  [inst_4 :\n    CategoryTheory.IsEquivalence\n      (CategoryTheory.LaxMonoidalFunctor.toFunctor (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F))]\n  [inst_5 : CategoryTheory.MonoidalClosed D] {X : C} {Y : C} {Z : C} (f : X ‚äó Y ‚ü∂ Z),\n  CategoryTheory.MonoidalClosed.curry f =\n    ‚Üë(CategoryTheory.Adjunction.homEquiv\n          (CategoryTheory.Functor.adjunction\n            (CategoryTheory.LaxMonoidalFunctor.toFunctor (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))\n          Y\n          (Prefunctor.obj\n            (CategoryTheory.Functor.toPrefunctor\n              (CategoryTheory.ihom\n                (Prefunctor.obj\n                  (CategoryTheory.Functor.toPrefunctor\n                    (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                      (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))\n                  X)))\n            (Prefunctor.obj\n              (CategoryTheory.Functor.toPrefunctor\n                (CategoryTheory.Functor.inv\n                  (CategoryTheory.Functor.inv\n                    (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                      (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))))\n              Z)))\n      (CategoryTheory.MonoidalClosed.curry\n        (‚Üë(CategoryTheory.Adjunction.homEquiv\n              (CategoryTheory.Functor.adjunction\n                (CategoryTheory.Functor.inv\n                  (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                    (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F))))\n              (Prefunctor.obj\n                  (CategoryTheory.Functor.toPrefunctor\n                    (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                      (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))\n                  X ‚äó\n                Prefunctor.obj\n                  (CategoryTheory.Functor.toPrefunctor\n                    (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                      (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))\n                  Y)\n              Z)\n          ((CategoryTheory.Iso.hom (CategoryTheory.compInvIso (CategoryTheory.MonoidalFunctor.commTensorLeft F X))).app\n              Y ‚â´\n            f)))","name":"CategoryTheory.MonoidalClosed.ofEquiv_curry_def","isProp":true,"docString":"Suppose we have a monoidal equivalence `F : C ‚âå D`, with `D` monoidal closed. We can pull the\nmonoidal closed instance back along the equivalence. For `X, Y, Z : C`, this lemma describes the\nresulting currying map `Hom(X ‚äó Y, Z) ‚Üí Hom(Y, (X ‚ü∂[C] Z))`. (`X ‚ü∂[C] Z` is defined to be\n`F‚Åª¬π(F(X) ‚ü∂[D] F(Z))`, so currying in `C` is given by essentially conjugating currying in\n`D` by `F.`) "},{"type":"‚àÄ {l : Type u_2} {m : Type u_1} {Œ± : Type v} [inst : Zero Œ±] [inst_1 : DecidableEq m] [inst_2 : DecidableEq l]\n  (d : (a : m) ‚Üí Œ±) (e : (a : l) ‚Üí m) (he : Function.Injective e),\n  Matrix.submatrix (Matrix.diagonal d) e e = Matrix.diagonal (d ‚àò e)","name":"Matrix.submatrix_diagonal","isProp":true,"docString":"Given a `(m √ó m)` diagonal matrix defined by a map `d : m ‚Üí Œ±`, if the reindexing map `e` is\ninjective, then the resulting matrix is again diagonal. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±], Monotone Finset.upShadow","name":"Finset.upShadow_monotone","isProp":true,"docString":"The upper shadow is monotone. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) (Z : C), f ‚â´ 0 = 0","name":"CategoryTheory.Limits.HasZeroMorphisms.comp_zero","isProp":true,"docString":"`f` composed with `0` is `0` "},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤] {K : Set Œ±} {V : Set (Œ≤ √ó Œ≤)}\n  (f : C(Œ±, Œ≤)) (hV : V ‚àà uniformity Œ≤),\n  ‚àÉ (V' : Set (Œ≤ √ó Œ≤)),\n    (V' ‚àà uniformity Œ≤ : Prop) ‚àß\n      ((V' ‚äÜ V : Prop) ‚àß\n          (‚àÄ (g : C(Œ±, Œ≤)) (a : g ‚àà ContinuousMap.compactConvNhd K V' f),\n              ContinuousMap.compactConvNhd K V' g ‚äÜ ContinuousMap.compactConvNhd K V f :\n            Prop) :\n        Prop)","name":"ContinuousMap.compactConvNhd_nhd_basis","isProp":true,"docString":"A key property of `ContinuousMap.compactConvNhd`. It allows us to apply\n`TopologicalSpace.nhds_mkOfNhds_filterBasis` below. "},{"type":"‚àÄ {a : Cardinal} {b : Cardinal},\n  (Cardinal.aleph0 ‚â§ a * b : Prop) ‚Üî\n    (((a ‚â† 0 : Prop) ‚àß (Cardinal.aleph0 ‚â§ b : Prop) : Prop) ‚à® ((Cardinal.aleph0 ‚â§ a : Prop) ‚àß (b ‚â† 0 : Prop) : Prop) :\n      Prop)","name":"Cardinal.aleph0_le_mul_iff'","isProp":true,"docString":"See also `Cardinal.aleph0_le_mul_iff'`. "},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocRing Œ±] (a : Œ±) (b : Œ±) (c : Œ±), (a + b) * c = a * c + b * c","name":"NonUnitalNonAssocRing.right_distrib","isProp":true,"docString":"Multiplication is right distributive over addition "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : Fintype Œ±] [inst_1 : Fintype Œ≤] [inst_2 : CommMonoid M]\n  (e : Œ± ‚âÉ Œ≤) (f : (a : Œ±) ‚Üí M) (g : (a : Œ≤) ‚Üí M) (h : ‚àÄ (x : Œ±), f x = g (‚Üëe x)),\n  (Finset.prod Finset.univ fun (x : Œ±) ‚Ü¶ f x) = Finset.prod Finset.univ fun (x : Œ≤) ‚Ü¶ g x","name":"Fintype.prod_equiv","isProp":true,"docString":"`Fintype.prod_equiv` is a specialization of `Finset.prod_bij` that\nautomatically fills in most arguments.\n\nSee `Equiv.prod_comp` for a version without `h`.\n"},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí SeminormedAddGroup (œÄ i)]\n  (f : (i : Œπ) ‚Üí œÄ i), (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ ‚Äñf i‚Äñ) ‚â§ Fintype.card Œπ ‚Ä¢ ‚Äñf‚Äñ","name":"Pi.sum_norm_apply_le_norm","isProp":true,"docString":"The $L^1$ norm is less than the $L^\\infty$ norm scaled by\nthe cardinality."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : NonUnitalNonAssocSemiring Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} {g : (a : ‚Ñï) ‚Üí Œ±}\n  [inst_2 : T3Space Œ±] [inst_3 : TopologicalSemiring Œ±] (hf : Summable f) (hg : Summable g)\n  (hfg : Summable fun (x : ‚Ñï √ó ‚Ñï) ‚Ü¶ f (Prod.fst x) * g (Prod.snd x)),\n  ((tsum fun (n : ‚Ñï) ‚Ü¶ f n) * tsum fun (n : ‚Ñï) ‚Ü¶ g n) =\n    tsum fun (n : ‚Ñï) ‚Ü¶ Finset.sum (Finset.range (n + 1)) fun (k : ‚Ñï) ‚Ü¶ f k * g (n - k)","name":"tsum_mul_tsum_eq_tsum_sum_range","isProp":true,"docString":"The **Cauchy product formula** for the product of two infinites sums indexed by `‚Ñï`, expressed\nby summing on `Finset.range`.\n\nSee also `tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm` if `f` and `g` are absolutely summable.\n"},{"type":"‚àÄ {G : Type u} [inst : AddGroup G] (N : AddSubgroup G) [nN : AddSubgroup.Normal N] {H : Type v} [inst_1 : AddGroup H]\n  ‚¶Éf : G ‚ß∏ N ‚Üí+ H‚¶Ñ ‚¶Ég : G ‚ß∏ N ‚Üí+ H‚¶Ñ\n  (h : AddMonoidHom.comp f (QuotientAddGroup.mk' N) = AddMonoidHom.comp g (QuotientAddGroup.mk' N)), f = g","name":"QuotientAddGroup.addMonoidHom_ext","isProp":true,"docString":"Two `AddMonoidHoms`s from an additive quotient group are equal if\ntheir compositions with `AddQuotientGroup.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {F : Type u_2} {Œ± : Type u_1} {Œ≤ : Type u_3} [inst : FunLike F Œ± fun (x : Œ±) ‚Ü¶ Œ≤] [inst_1 : CommMonoid Œ±]\n  [inst_2 : CancelCommMonoid Œ≤] {A : Set Œ±} {m : ‚Ñï} {n : ‚Ñï} [inst_3 : FreimanHomClass F A Œ≤ n] (h : m ‚â§ n),\n  FreimanHomClass F A Œ≤ m","name":"FreimanHom.FreimanHomClass_of_le","isProp":true,"docString":"A `n`-Freiman homomorphism is also a `m`-Freiman homomorphism for any `m ‚â§ n`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} {Œπ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤] {s : Set E}\n  {f : (a : E) ‚Üí Œ≤} {t : Finset Œπ} {w : (a : Œπ) ‚Üí ùïú} {p : (a : Œπ) ‚Üí E} (hf : ConvexOn ùïú s f)\n  (h‚ÇÄ : ‚àÄ (i : Œπ) (a : i ‚àà t), 0 ‚â§ w i) (h‚ÇÅ : 0 < Finset.sum t fun (i : Œπ) ‚Ü¶ w i)\n  (hmem : ‚àÄ (i : Œπ) (a : i ‚àà t), p i ‚àà s), f (Finset.centerMass t w p) ‚â§ Finset.centerMass t w (f ‚àò p)","name":"ConvexOn.map_centerMass_le","isProp":true,"docString":"Convex **Jensen's inequality**, `Finset.centerMass` version. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} {v : Vector Œ± (n + 1)}, Vector.last v = Vector.get v (Fin.last n)","name":"Vector.last_def","isProp":true,"docString":"The last element of a `Vector`, given that the vector is at least one element. "},{"type":"‚àÄ {G‚ÇÄ : Type u} [self : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"GroupWithZero.mul_inv_cancel","isProp":true,"docString":"Every nonzero element of a group with zero is invertible. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PartialOrder Œ±] [inst_1 : Preorder Œ≤] {l : (a : Œ±) ‚Üí Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (gc : GaloisConnection l u) (a : Œ±), (‚àÉ (b : Œ≤), a = u b : Prop) ‚Üî (a = u (l a) : Prop)","name":"GaloisConnection.exists_eq_u","isProp":true,"docString":"If there exists a `b` such that `a = u a`, then `b = l a` is one such element. "},{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y], Isometry Sum.inl","name":"Metric.isometry_inl","isProp":true,"docString":"The left injection of a space in a disjoint union is an isometry "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s) {a : ùïú} {b : ùïú} (ha : 0 ‚â§ a) (hb : 0 < b) (hab : a + b = 1), a ‚Ä¢ s + b ‚Ä¢ interior s ‚äÜ interior s","name":"Convex.combo_self_interior_subset_interior","isProp":true,"docString":"If `s` is a convex set, then `a ‚Ä¢ s + b ‚Ä¢ interior s ‚äÜ interior s` for all `0 ‚â§ a`, `0 < b`,\n`a + b = 1`. See also `Convex.combo_closure_interior_subset_interior` for a stronger version. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Group R] [inst_1 : MulAction R M] {p : SubMulAction R M} (m : { x : M // x ‚àà p }),\n  MulAction.stabilizer R m = MulAction.stabilizer R ‚Üëm","name":"SubMulAction.stabilizer_of_subMul","isProp":true,"docString":"Stabilizers in group SubMulAction coincide with stabilizers in the ambient space "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Mul Œ±] [inst_1 : Add Œ≤] [inst_2 : LE Œ≤]\n  [self : MulLEAddHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a * b) ‚â§ ‚Üëf a + ‚Üëf b","name":"MulLEAddHomClass.map_mul_le_add","isProp":true,"docString":"the image of a product is less or equal than the sum of the images. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : DivisionMonoid Œ≤] (f : Œ± ‚Üí* Œ≤) (g : Œ±) (n : ‚Ñ§),\n  ‚Üëf (g ^ n) = ‚Üëf g ^ n","name":"MonoidHom.map_zpow","isProp":true,"docString":"Group homomorphisms preserve integer power. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±]\n  (L :\n    ‚àÄ (x : Œ±) (u : Set (Œ≤ √ó Œ≤)) (a : u ‚àà uniformity Œ≤),\n      ‚àÉ (t : Set Œ±),\n        (t ‚àà nhds x : Prop) ‚àß\n          (‚àÉ (F : (a : Œ±) ‚Üí Œ≤), (ContinuousAt F x : Prop) ‚àß (‚àÄ (y : Œ±) (a : y ‚àà t), (f y, F y) ‚àà u : Prop) : Prop)),\n  Continuous f","name":"continuous_of_locally_uniform_approx_of_continuousAt","isProp":true,"docString":"A function which can be locally uniformly approximated by continuous functions is continuous. "},{"type":"‚àÄ {n : ‚Ñï} [inst : NeZero n] (a : ZMod n), ‚Üë(ZMod.val a) = a","name":"ZMod.nat_cast_zmod_val","isProp":true,"docString":"So-named because the coercion is `Nat.cast` into `ZMod`. For `Nat.cast` into an arbitrary ring,\nsee `ZMmod.nat_cast_val`. "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), Vector.tail (a ::·µ• v) = v","name":"Vector.tail_cons","isProp":true,"docString":"The tail of a vector obtained by prepending is the vector prepended. to "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] {A : Matrix n n Œ±}\n  {B : Matrix n n Œ±} (h : Matrix.mul A B = 1), A‚Åª¬π = B","name":"Matrix.inv_eq_right_inv","isProp":true,"docString":"If matrix A is right invertible, then its inverse equals its right inverse. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : MetricSpace Œ≥] {x : Œ≥} {y : Œ≥}, (nndist x y = 0 : Prop) ‚Üî (x = y : Prop)","name":"nndist_eq_zero","isProp":true,"docString":"Characterize the equality of points with the vanishing of the nonnegative distance"},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : LinearOrder E] {s : Set E}\n  {f : (a : E) ‚Üí Œ≤} (hs : Convex ùïú s)\n  (hf :\n    ‚àÄ ‚¶Éx : E‚¶Ñ (a : x ‚àà s) ‚¶Éy : E‚¶Ñ (a : y ‚àà s) (a : x < y) ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 < a) (a_2 : 0 < b) (a_3 : a + b = 1),\n      f (a ‚Ä¢ x + b ‚Ä¢ y) < a ‚Ä¢ f x + b ‚Ä¢ f y),\n  StrictConvexOn ùïú s f","name":"LinearOrder.strictConvexOn_of_lt","isProp":true,"docString":"For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is strictly convex, it suffices\nto verify the inequality `f (a ‚Ä¢ x + b ‚Ä¢ y) < a ‚Ä¢ f x + b ‚Ä¢ f y` for `x < y` and positive `a`, `b`.\nThe main use case is `E = ùïú` however one can apply it, e.g., to `ùïú^n` with lexicographic order. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l],\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atTop : Prop) ‚Üî\n    (((0 < r : Prop) ‚àß (Filter.Tendsto f l Filter.atTop : Prop) : Prop) ‚à®\n        ((r < 0 : Prop) ‚àß (Filter.Tendsto f l Filter.atBot : Prop) : Prop) :\n      Prop)","name":"Filter.tendsto_const_mul_atTop_iff","isProp":true,"docString":"The function `Œª x, r * f x` tends to infinity along a nontrivial filter if and only if `r > 0`\nand `f` tends to infinity or `r < 0` and `f` tends to negative infinity. "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  {a : Œ±} {b : Œ±} {s : Set Œ±} (hs : IsClosed (s ‚à© Set.Icc a b)) (ha : a ‚àà s) (hab : a ‚â§ b)\n  (hgt : ‚àÄ (x : Œ±) (a : x ‚àà s ‚à© Set.Ico a b), Set.Nonempty (s ‚à© Set.Ioc x b)), b ‚àà s","name":"IsClosed.mem_of_ge_of_forall_exists_gt","isProp":true,"docString":"A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and the set `s ‚à© [a, b)` has no maximal point, then `b ‚àà s`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddGroupHom f), f 0 = 0","name":"IsAddGroupHom.map_zero","isProp":true,"docString":"An additive group homomorphism sends 0 to 0."},{"type":"‚àÄ (Œ± : Type u_1) [inst : CompleteLattice Œ±] (a : CompleteLattice.IsSupFiniteCompact Œ±),\n  WellFounded fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x > x_1","name":"CompleteLattice.IsSupFiniteCompact.wellFounded","isProp":true,"docString":"**Alias** of the reverse direction of `CompleteLattice.wellFounded_iff_isSupFiniteCompact`."},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (q : ‚Ñö), padicValRat p q‚Åª¬π = -padicValRat p q","name":"padicValRat.inv","isProp":true,"docString":"A rewrite lemma for `padicValRat p (q‚Åª¬π)` with condition `q ‚â† 0`. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {A : Type v} [inst_1 : Semiring A] [inst_2 : Algebra R A] (M : Submodule R A)\n  {C : (n : ‚Ñï) ‚Üí (x : A) ‚Üí (a : x ‚àà M ^ n) ‚Üí Prop}\n  (hr :\n    ‚àÄ (r : R),\n      C 0 (‚Üë(algebraMap R A) r) ((Submodule.algebraMap_mem r=:‚Üë(algebraMap R A) r ‚àà 1)=:‚Üë(algebraMap R A) r ‚àà 1))\n  (hadd :\n    ‚àÄ (x : A) (y : A) (i : ‚Ñï) (hx : x ‚àà M ^ i) (hy : y ‚àà M ^ i) (a : C i x hx) (a : C i y hy),\n      C i (x + y) ((add_mem hx hy=:x + y ‚àà M ^ i)=:x + y ‚àà M ^ i))\n  (hmul :\n    ‚àÄ (i : ‚Ñï) (x : A) (hx : x ‚àà M ^ i) (a : C i x hx) (m : A) (hm : m ‚àà M),\n      C (Nat.succ i) (x * m)\n        ((Eq.rec ((Submodule.mul_mem_mul hx hm=:x * m ‚àà M ^ i * M)=:x * m ‚àà M ^ i * M)\n              ((Eq.symm\n                    ((pow_succ' M\n                          i=:M ^ (i + 1) =\n                          M ^ i *\n                            M)=:M ^ (i + 1) =\n                        M ^ i *\n                          M)=:M ^ i * M =\n                    M ^ (i + 1))=:M ^ i * M = M ^ (i + 1))=:x * m ‚àà M ^ (i + 1))=:x * m ‚àà M ^ (i + 1)))\n  {x : A} {n : ‚Ñï} (hx : x ‚àà M ^ n), C n x hx","name":"Submodule.pow_induction_on_right'","isProp":true,"docString":"Dependent version of `Submodule.pow_induction_on_right`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {U : Set Œ±} (h : ‚àÄ (x : Œ±) (a : x ‚àà s), U ‚àà nhds x),\n  ‚àÉ (V : Set Œ±), (s ‚äÜ V : Prop) ‚àß ((IsOpen V : Prop) ‚àß (V ‚äÜ U : Prop) : Prop)","name":"exists_open_set_nhds","isProp":true,"docString":"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. "},{"type":"‚àÄ {Œ± : Type v} [self : Small Œ±], ‚àÉ (S : Type w), Nonempty (Œ± ‚âÉ S)","name":"Small.equiv_small","isProp":true,"docString":"If a type is `Small.{w}`, then there exists an equivalence with some `S : Type w` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : (a : Œ±) ‚Üí Œ≤) (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤),\n  (Filter.Tendsto f l‚ÇÅ l‚ÇÇ : Prop) ‚Üî (‚àÄ (g : Ultrafilter Œ±) (a : ‚Üëg ‚â§ l‚ÇÅ), Filter.Tendsto f (‚Üëg) l‚ÇÇ : Prop)","name":"Filter.tendsto_iff_ultrafilter","isProp":true,"docString":"The `tendsto` relation can be checked on ultrafilters. "},{"type":"‚àÄ {b : ‚Ñï} {m : ‚Ñï} {d : ‚Ñï} (hb : 1 < b) (hd : d ‚àà Nat.digits b m), d < b","name":"Nat.digits_lt_base","isProp":true,"docString":"The digits in the base b expansion of n are all less than b, if b ‚â• 2 "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C], Subsingleton (CategoryTheory.Preadditive C)","name":"CategoryTheory.subsingleton_preadditive_of_hasBinaryBiproducts","isProp":true,"docString":"The existence of binary biproducts implies that there is at most one preadditive structure. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} (e : LocalEquiv Œ± Œ≤),\n  LocalEquiv.trans (LocalEquiv.symm e) e ‚âà LocalEquiv.ofSet (LocalEquiv.target e)","name":"LocalEquiv.trans_symm_self","isProp":true,"docString":"Composition of the inverse of a local equiv and this local equiv is equivalent to the\nrestriction of the identity to the target "},{"type":"‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (x‚ÇÄ : (a : Fin 1) ‚Üí Œ±) (x : (a : Fin n) ‚Üí Œ±),\n  Fin.append x‚ÇÄ x = Fin.cons (x‚ÇÄ 0) x ‚àò ‚Üë(Fin.cast ((add_comm 1 n=:1 + n = n + 1)=:1 + n = n + 1))","name":"Fin.append_left_eq_cons","isProp":true,"docString":"Appending a one-tuple to the left is the same as `Fin.cons`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Monotone f)\n  (h : ‚àÄ (b : Œ≤), ‚àÉ (a : Œ±), b ‚â§ f a), Filter.Tendsto f Filter.atTop Filter.atTop","name":"Monotone.tendsto_atTop_atTop","isProp":true,"docString":"**Alias** of `Filter.tendsto_atTop_atTop_of_monotone`."},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M], FaithfulSMul (MulAut M) M","name":"MulAut.apply_faithfulSMul","isProp":true,"docString":"`MulAut.applyDistribMulAction` is faithful. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {F : (a : J) ‚Üí C} [self : CategoryTheory.Limits.HasBiproduct F], Nonempty (CategoryTheory.Limits.LimitBicone F)","name":"CategoryTheory.Limits.HasBiproduct.exists_biproduct","isProp":true,"docString":"`HasBiproduct F` expresses the mere existence of a bicone which is\nsimultaneously a limit and a colimit of the diagram `F`.\n"},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] [inst_2 : Encodable Œ±]\n  [inst_3 : DenselyOrdered Œ≤] [inst_4 : Nontrivial Œ≤], Nonempty (Œ± ‚Ü™o Œ≤)","name":"Order.embedding_from_countable_to_dense","isProp":true,"docString":"Any countable linear order embeds in any nontrivial dense linear order. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Countable Œ±] {n : ‚Ñï}, Countable (Vector Œ± n)","name":"Vector.countable","isProp":true,"docString":"If `Œ±` is countable, then so is `Vector Œ± n`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±),\n  ‚àÉ (K : Set Œ±), (IsCompact K : Prop) ‚àß (K ‚àà nhds x : Prop)","name":"exists_compact_mem_nhds","isProp":true,"docString":"In a locally compact space every point has a compact neighborhood. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  (a_1 : a‚Åª¬π < 1), 1 < a","name":"one_lt_of_inv_lt_one","isProp":true,"docString":"**Alias** of the forward direction of `Left.inv_lt_one_iff`."},{"type":"‚àÄ {R : Type u_2} {E : Type u_1} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E] [inst_2 : Module R E]\n  (t : Finset E) {w : (a : E) ‚Üí R} (hw‚ÇÄ : ‚àÄ (i : E) (a : i ‚àà t), 0 ‚â§ w i) (hws : 0 < Finset.sum t fun (i : E) ‚Ü¶ w i),\n  Finset.centerMass t w id ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull R)) ‚Üët","name":"Finset.centerMass_id_mem_convexHull","isProp":true,"docString":"A refinement of `Finset.centerMass_mem_convexHull` when the indexed family is a `Finset` of\nthe space. "},{"type":"‚àÄ {E : Type u_1} {Œ≤ : Type u_2} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E] [inst_2 : Module ‚Ñù E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] [inst_5 : OrderedAddCommGroup Œ≤] [inst_6 : Module ‚Ñù Œ≤]\n  [inst_7 : OrderedSMul ‚Ñù Œ≤] {f : (a : E) ‚Üí Œ≤} {a : E} (h_local_min : IsLocalMin f a) (h_conv : ConvexOn ‚Ñù Set.univ f)\n  (x : E), f a ‚â§ f x","name":"IsMinOn.of_isLocalMin_of_convex_univ","isProp":true,"docString":"A local minimum of a convex function is a global minimum. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : OrderedSemiring Œ±] [inst_1 : Nontrivial Œ±] {t : ‚Üë(Set.Ico 0 1)}, 0 ‚â§ t","name":"Set.Ico.nonneg","isProp":true,"docString":"like `coe_nonneg`, but with the inequality in `Ico (0:Œ±) 1`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [inst : SeminormedAddGroup E]\n  [inst_1 : SeminormedAddGroup F] [inst_2 : SeminormedAddGroup G] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F} {l : Filter Œ±}\n  (hf : Filter.Tendsto f l (nhds 0)) (hg : Filter.IsBoundedUnder (fun (x : ‚Ñù) (x_1 : ‚Ñù) ‚Ü¶ x ‚â§ x_1) l (norm ‚àò g))\n  (op : (a : E) ‚Üí (a : F) ‚Üí G) (h_op : ‚àÄ (x : E) (y : F), ‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ op (f x) (g x)) l (nhds 0)","name":"Filter.Tendsto.op_zero_isBoundedUnder_le","isProp":true,"docString":"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ` instead of multiplication so\nthat it can be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`."},{"type":"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {a : Œ≥} {b : Œ≥} {s : Set Œ≥} {t : Set Œ≥} (hs : IsLUB s a) (ht : IsLUB t b),\n  IsLUB (s ‚à™ t) (a ‚äî b)","name":"IsLUB.union","isProp":true,"docString":"If `a` is the least upper bound of `s` and `b` is the least upper bound of `t`,\nthen `a ‚äî b` is the least upper bound of `s ‚à™ t`. "},{"type":"‚àÄ {Œ± : Sort u_1} {p : (a : Œ±) ‚Üí Prop} {b : Prop} (a : ‚àÄ (x : Œ±) (a : p x), b) (a : ‚àÉ (x : Œ±), p x), b","name":"not_exists_of_forall_not","isProp":true,"docString":"**Alias** of the reverse direction of `exists_imp`."},{"type":"‚àÄ {Œ± : Type u_1} {C : (a : Cycle Œ±) ‚Üí Prop} (s : Cycle Œ±) (H0 : C Cycle.nil)\n  (HI : ‚àÄ (a : Œ±) (l : List Œ±) (a_1 : C ‚Üël), C ‚Üë(a :: l)), C s","name":"Cycle.induction_on","isProp":true,"docString":"An induction principle for `Cycle`. Use as `induction s using Cycle.induction_on`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : TopologicalSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {x‚ÇÄ : Œ≤},\n  (EquicontinuousAt F x‚ÇÄ : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0), Filter.Eventually (fun (x : Œ≤) ‚Ü¶ ‚àÄ (i : Œπ), dist (F i x‚ÇÄ) (F i x) < Œµ) (nhds x‚ÇÄ) : Prop)","name":"Metric.equicontinuousAt_iff_right","isProp":true,"docString":"Characterization of equicontinuity for families of functions taking values in a (pseudo) metric\nspace. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Infinite Œ±] [inst : Finite Œ≤] (f : (a : Œ±) ‚Üí Œ≤),\n  ‚àÉ (y : Œ≤), Infinite ‚Üë(f ‚Åª¬π' {y})","name":"Finite.exists_infinite_fiber","isProp":true,"docString":"The strong pigeonhole principle for infinitely many pigeons in\nfinitely many pigeonholes.  If there are infinitely many pigeons in\nfinitely many pigeonholes, then there is a pigeonhole with infinitely\nmany pigeons.\n\nSee also: `Finite.exists_ne_map_eq_of_infinite`\n"},{"type":"‚àÄ (R : Type u_2) {A : Type u_1} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : Semiring A]\n  [inst_3 : Algebra R A] [inst_4 : StarRing A] [inst_5 : StarModule R A] (s : Set A),\n  star (Algebra.adjoin R s) = Algebra.adjoin R (star s)","name":"Subalgebra.star_adjoin_comm","isProp":true,"docString":"The star operation on `Subalgebra` commutes with `Algebra.adjoin`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Ring ùïú] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module ùïú E] [inst_4 : Module ùïú F] {x : E} {y : E} {a : ùïú} {b : ùïú} {f : E ‚Üí·µÉ[ùïú] F} (h : a + b = 1),\n  ‚Üëf (a ‚Ä¢ x + b ‚Ä¢ y) = a ‚Ä¢ ‚Üëf x + b ‚Ä¢ ‚Üëf y","name":"Convex.combo_affine_apply","isProp":true,"docString":"Applying an affine map to an affine combination of two points yields an affine combination of\nthe images. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : IsSimpleModule R M] [inst_6 : IsSimpleModule R N]\n  (f : M ‚Üí‚Çó[R] N), (Function.Bijective ‚Üëf : Prop) ‚à® (f = 0 : Prop)","name":"LinearMap.bijective_or_eq_zero","isProp":true,"docString":"**Schur's Lemma** for linear maps between (possibly distinct) simple modules "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  [self : CategoryTheory.HasSplitCoequalizer f g],\n  ‚àÉ (Z : C), ‚àÉ (h : Y ‚ü∂ Z), Nonempty (CategoryTheory.IsSplitCoequalizer f g h)","name":"CategoryTheory.HasSplitCoequalizer.splittable","isProp":true,"docString":"There is some split coequalizer "},{"type":"‚àÄ {Œ± : Type u_1} (c : Set (Set Œ±)) (hc : Setoid.IsPartition c),\n  Setoid.classes\n      (Setoid.mkClasses c\n        ((And.right\n              hc=:‚àÄ (a : Œ±),\n              ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà c), a ‚àà b)=:‚àÄ (a : Œ±), ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà c), a ‚àà b)) =\n    c","name":"Setoid.classes_mkClasses","isProp":true,"docString":"The equivalence classes of the equivalence relation defined by a partition of Œ± equal\nthe original partition. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : StrictConcaveOn ùïú s f) {x : E} {y : E} {z : E} (hx : x ‚àà s) (hy : y ‚àà s)\n  (hxy : x ‚â† y) (hz : z ‚àà openSegment ùïú x y), min (f x) (f y) < f z","name":"StrictConcaveOn.lt_on_openSegment","isProp":true,"docString":"A strictly concave function on an open segment is strictly lower-bounded by the min of its\nendpoints. "},{"type":"‚àÄ {G : Type u_1} [inst : AddCommGroup G] (L : List G), -List.sum L = List.sum (List.map (fun (x : G) ‚Ü¶ -x) L)","name":"List.sum_neg","isProp":true,"docString":"This is the `List.sum` version of `add_neg`"},{"type":"‚àÄ {Œ± : Type u_4} {M : Type u_1} {N : Type u_2} {R : Type u_3} [inst : AddMonoid M] [inst_1 : AddCommMonoid N]\n  [inst_2 : DistribSMul R M] {g : Œ± ‚Üí‚ÇÄ M} {b : R} {h : (a : Œ±) ‚Üí M ‚Üí+ N},\n  (Finsupp.sum (b ‚Ä¢ g) fun (a : Œ±) ‚Ü¶ ‚Üë(h a)) = Finsupp.sum g fun (i : Œ±) (c : M) ‚Ü¶ ‚Üë(h i) (b ‚Ä¢ c)","name":"Finsupp.sum_smul_index_addMonoidHom","isProp":true,"docString":"A version of `Finsupp.sum_smul_index'` for bundled additive maps. "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x : R} {y : R} (a : x ‚àà s) (a : y ‚àà s), x * y ‚àà s","name":"Subsemiring.mul_mem","isProp":true,"docString":"A subsemiring is closed under multiplication. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤},\n  (UniformEmbedding f : Prop) ‚Üî\n    ((Function.Injective f : Prop) ‚àß\n        ((UniformContinuous f : Prop) ‚àß\n            (‚àÄ (Œ¥ : ENNReal) (a : Œ¥ > 0),\n                ‚àÉ (Œµ : ENNReal),\n                  (Œµ > 0 : Prop) ‚àß (‚àÄ {a : Œ±} {b : Œ±} (a_1 : edist (f a) (f b) < Œµ), edist a b < Œ¥ : Prop) :\n              Prop) :\n          Prop) :\n      Prop)","name":"EMetric.uniformEmbedding_iff","isProp":true,"docString":"Œµ-Œ¥ characterization of uniform embeddings on pseudoemetric spaces "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a : a + b ‚â§ a + c), b ‚â§ c","name":"CanonicallyLinearOrderedSemifield.le_of_add_le_add_left","isProp":true,"docString":"Additive cancellation is compatible with the order in an ordered cancellative additive\ncommutative monoid. "},{"type":"‚àÄ {t : ‚ÜëunitInterval}, 0 ‚â§ t","name":"unitInterval.nonneg'","isProp":true,"docString":"like `unitInterval.nonneg`, but with the inequality in `I`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±} (H : IsLeast s a), inf‚Çõ s = a","name":"IsLeast.cinf‚Çõ_eq","isProp":true,"docString":"A least element of a set is the infimum of this set. "},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±), (a + b) * c = a * c + b * c","name":"NonUnitalNonAssocSemiring.right_distrib","isProp":true,"docString":"Multiplication is right distributive over addition "},{"type":"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] (a : Œ≥) {s : Set Œ≥}, (BddAbove (insert a s) : Prop) ‚Üî (BddAbove s : Prop)","name":"bddAbove_insert","isProp":true,"docString":"Adding a point to a set preserves its boundedness above. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] (r : R) (n : ‚Ñï),\n  Polynomial.X ^ n * ‚ÜëPolynomial.C r = ‚ÜëPolynomial.C r * Polynomial.X ^ n","name":"Polynomial.X_pow_mul_C","isProp":true,"docString":"Prefer putting constants to the left of `X ^ n`.\n\nThis lemma is the loop-avoiding `simp` version of `X_pow_mul`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsIrreducible s : Prop) ‚Üî\n    (‚àÄ (U : Finset (Set Œ±)) (a : ‚àÄ (u : Set Œ±) (a : u ‚àà U), IsOpen u)\n        (a : ‚àÄ (u : Set Œ±) (a : u ‚àà U), Set.Nonempty (s ‚à© u)), Set.Nonempty (s ‚à© ‚ãÇ‚ÇÄ ‚ÜëU) :\n      Prop)","name":"isIrreducible_iff_inter‚Çõ","isProp":true,"docString":"A set `s` is irreducible if and only if\nfor every finite collection of open sets all of whose members intersect `s`,\n`s` also intersects the intersection of the entire collection\n(i.e., there is an element of `s` contained in every member of the collection). "},{"type":"‚àÄ {Œ± : Type u_2} {R : Type u_1} {l : Filter Œ±} {f : (a : Œ±) ‚Üí R} {r : R} [inst : LinearOrderedSemiring R]\n  [inst_1 : Archimedean R] (hr : 0 < r) (hf : Filter.Tendsto f l Filter.atTop),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * r) l Filter.atTop","name":"Filter.Tendsto.atTop_mul_const'","isProp":true,"docString":"If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the right) also tends to infinity. The archimedean assumption is convenient to get a\nstatement that works on `‚Ñï`, `‚Ñ§` and `‚Ñù`, although not necessary (a version in ordered fields is\ngiven in `Filter.Tendsto.atTop_mul_const`). "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±} {a : Œ±} (h : IsGreatest s a), BddAbove s","name":"IsGreatest.bddAbove","isProp":true,"docString":"If `s` has a greatest element, then it is bounded above. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : SeminormedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : SMul ùïú E] {x : E} {y : E}\n  {r : ‚Ñù} (p : Seminorm ùïú E), x +·µ• Seminorm.closedBall p y r = Seminorm.closedBall p (x +·µ• y) r","name":"Seminorm.vadd_closedBall","isProp":true,"docString":"The image of a closed ball under addition with a singleton is another closed ball. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : (a : Œ±) ‚Üí ‚Ñù} {s : Set Œ±} {K : NNReal} (hf : LipschitzOnWith K f s),\n  ‚àÉ (g : (a : Œ±) ‚Üí ‚Ñù), (LipschitzWith K g : Prop) ‚àß (Set.EqOn f g s : Prop)","name":"LipschitzOnWith.extend_real","isProp":true,"docString":"A function `f : Œ± ‚Üí ‚Ñù` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz extension\nto the whole space. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {a : Œ±} {s : Set Œ±},\n  (sup·µ¢ fun (b : Œ±) ‚Ü¶ sup·µ¢ fun (h : b ‚àà s) ‚Ü¶ a ‚äì b) ‚â§ a ‚äì sup‚Çõ s","name":"sup·µ¢_inf_le_inf_sup‚Çõ","isProp":true,"docString":"This is a weaker version of `inf_sup‚Çõ_eq` "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {a : X} {b : X} (Œ≥ : Path a b),\n  Continuous fun (x : ‚Ñù √ó ‚Ñù √ó ‚ÜëunitInterval) ‚Ü¶\n    ‚Üë(Path.truncate Œ≥ (Prod.fst x) (Prod.fst (Prod.snd x))) (Prod.snd (Prod.snd x))","name":"Path.truncate_continuous_family","isProp":true,"docString":"For a path `Œ≥`, `Œ≥.truncate` gives a \"continuous family of paths\", by which we\nmean the uncurried function which maps `(t‚ÇÄ, t‚ÇÅ, s)` to `Œ≥.truncate t‚ÇÄ t‚ÇÅ s` is continuous. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {n : ‚Ñï}\n  (H : ‚àÄ (s : Finset M) (a : LinearIndependent R fun (i : { x : M // x ‚àà s }) ‚Ü¶ ‚Üëi), Finset.card s ‚â§ n) (s : Set M)\n  (a : LinearIndependent R Subtype.val), Cardinal.mk ‚Üës ‚â§ ‚Üën","name":"linearIndependent_bounded_of_finset_linearIndependent_bounded","isProp":true,"docString":"If every finite set of linearly independent vectors has cardinality at most `n`,\nthen the same is true for arbitrary sets of linearly independent vectors.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : btw a b c), btw c a b","name":"Btw.btw.cyclic_right","isProp":true,"docString":"**Alias** of `btw_cyclic_right`."},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±},\n  (¬¨(BddBelow s : Prop) : Prop) ‚Üî (‚àÄ (x : Œ±), ‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (¬¨(x ‚â§ y : Prop) : Prop) : Prop)","name":"not_bddBelow_iff'","isProp":true,"docString":"A set `s` is not bounded below if and only if for each `x` there exists `y ‚àà s` such that `x`\nis not less than or equal to `y`. This version only assumes `Preorder` structure and uses\n`¬¨(x ‚â§ y)`. A version for linear orders is called `not_bddBelow_iff`. "},{"type":"‚àÄ {R : Type u_2} {R‚ÇÅ : Type u_3} {R‚ÇÇ : Type u_4} (M‚ÇÅ : Type u_1) (M‚ÇÇ : Type u_5) [inst : CommSemiring R]\n  [inst_1 : CommSemiring R‚ÇÅ] [inst_2 : AddCommMonoid M‚ÇÅ] [inst_3 : Module R‚ÇÅ M‚ÇÅ] [inst_4 : CommSemiring R‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÇ M‚ÇÇ] (I‚ÇÅ : R‚ÇÅ ‚Üí+* R) (I‚ÇÇ : R‚ÇÇ ‚Üí+* R) [inst_7 : Nontrivial M‚ÇÅ],\n  ¬¨(LinearMap.SeparatingLeft 0 : Prop)","name":"LinearMap.not_separatingLeft_zero","isProp":true,"docString":"In a non-trivial module, zero is not non-degenerate. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofiltered C] (O : Finset C)\n  (H : Finset ((X : C) √ó' (Y : C) √ó' (_ : X ‚àà O) √ó' (_ : Y ‚àà O) √ó' (X ‚ü∂ Y))) {X : C} {Y : C} (mX : X ‚àà O) (mY : Y ‚àà O)\n  {f : X ‚ü∂ Y} (mf : { fst := X, snd := { fst := Y, snd := { fst := mX, snd := { fst := mY, snd := f } } } } ‚àà H),\n  CategoryTheory.IsCofiltered.infTo O H mX ‚â´ f = CategoryTheory.IsCofiltered.infTo O H mY","name":"CategoryTheory.IsCofiltered.infTo_commutes","isProp":true,"docString":"The triangles consisting of a morphism in `H` and the maps from `inf O H` commute.\n"},{"type":"‚àÄ {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop}, Set.range Subtype.val = setOf fun (x : Œ±) ‚Ü¶ p x","name":"Subtype.range_coe_subtype","isProp":true,"docString":"We make this the simp lemma instead of `range_coe`. The reason is that if we write\nfor `s : Set Œ±` the function `(‚Üë) : s ‚Üí Œ±`, then the inferred implicit arguments of `(‚Üë)` are\n`‚ÜëŒ± (Œª x, x ‚àà s)`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {M : Type u_2} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {N : Submodule R M} {Œπ : Type u_3} {n : ‚Ñï} (self : Basis.SmithNormalForm N Œπ n) (i : Fin n),\n  ‚Üë(‚Üë(Basis.SmithNormalForm.bN self) i) =\n    Basis.SmithNormalForm.a self i ‚Ä¢ ‚Üë(Basis.SmithNormalForm.bM self) (‚Üë(Basis.SmithNormalForm.f self) i)","name":"Basis.SmithNormalForm.snf","isProp":true,"docString":"The SNF relation between the vectors of the bases. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] (s : Set Œ±), IsCompact s","name":"TopologicalSpace.NoetherianSpace.isCompact","isProp":true,"docString":"In a Noetherian space, all sets are compact. "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedField R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {v‚ÇÅ : M}\n  {v‚ÇÇ : M} (h : SameRay R v‚ÇÅ v‚ÇÇ),\n  ‚àÉ (a : R),\n    ‚àÉ (b : R),\n      (0 ‚â§ a : Prop) ‚àß\n        ((0 ‚â§ b : Prop) ‚àß\n            ((a + b = 1 : Prop) ‚àß ((v‚ÇÅ = a ‚Ä¢ (v‚ÇÅ + v‚ÇÇ) : Prop) ‚àß (v‚ÇÇ = b ‚Ä¢ (v‚ÇÅ + v‚ÇÇ) : Prop) : Prop) : Prop) :\n          Prop)","name":"SameRay.exists_eq_smul_add","isProp":true,"docString":"If vectors `v‚ÇÅ` and `v‚ÇÇ` are on the same ray, then for some nonnegative `a b`, `a + b = 1`, we\nhave `v‚ÇÅ = a ‚Ä¢ (v‚ÇÅ + v‚ÇÇ)` and `v‚ÇÇ = b ‚Ä¢ (v‚ÇÅ + v‚ÇÇ)`. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {a : Œ±} {s : Set Œ±} (f : (a : Œ±) ‚Üí M) (h : ¬¨(a ‚àà s : Prop))\n  (hs : Set.Finite (s ‚à© Function.support f)),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà insert a s) ‚Ü¶ f i) = f a + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i","name":"finsum_mem_insert'","isProp":true,"docString":"A more general version of `finsum_mem_insert` that requires `s ‚à© support f` rather\nthan `s` to be finite."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] (r : ENNReal) (C : ENNReal) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu : ‚àÄ (n : ‚Ñï), edist (f n) (f (n + 1)) ‚â§ C * r ^ n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) (n : ‚Ñï),\n  edist (f n) a ‚â§ C * r ^ n / (1 - r)","name":"edist_le_of_edist_le_geometric_of_tendsto","isProp":true,"docString":"If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from\n`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤] (f : (a : Œ±) ‚Üí Œ≤) {n : ‚Ñï}\n  [inst_3 : Nonempty Œ≤] (hn : Fintype.card Œ± ‚â§ Fintype.card Œ≤ * n),\n  ‚àÉ (y : Œ≤), Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ) ‚â§ n","name":"Fintype.exists_card_fiber_le_of_card_le_mul","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function `f`\nbetween finite types `Œ±` and `Œ≤` and a number `n` such that `card Œ± ‚â§ card Œ≤ * n`, there exists an\nelement `y : Œ≤` such that its preimage has at most `n` elements. See also\n`Fintype.exists_card_fiber_lt_of_card_lt_mul` for a stronger statement. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±} (hs : IsCompact s), IsClosed s","name":"IsCompact.isClosed","isProp":true,"docString":"In a `T2Space`, every compact set is closed. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P)\n  (i : Œπ), ‚Üë(Finset.weightedVSubOfPoint (insert i s) p (p i)) w = ‚Üë(Finset.weightedVSubOfPoint s p (p i)) w","name":"Finset.weightedVSubOfPoint_insert","isProp":true,"docString":"The weighted sum is unaffected by adding the base point, whether\nor not present, to the set of points. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C],\n  (Nonempty (C ‚âå CategoryTheory.Discrete PUnit) : Prop) ‚Üî\n    ((Nonempty C : Prop) ‚àß (‚àÄ (x : C) (y : C), Nonempty (Unique (x ‚ü∂ y)) : Prop) : Prop)","name":"CategoryTheory.equiv_pUnit_iff_unique","isProp":true,"docString":"A category being equivalent to `PUnit` is equivalent to it having a unique morphism between\nany two objects. (In fact, such a category is also a groupoid;\nsee `CategoryTheory.Groupoid.ofHomUnique`) "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} {Q : C} (f : P ‚ü∂ Q),\n  CategoryTheory.Mono (CategoryTheory.Abelian.factorThruCoimage f)","name":"CategoryTheory.Abelian.instMonoCoimageToHasZeroMorphismsNonPreadditiveAbelianHas_kernelsHas_cokernelsFactorThruCoimage","isProp":true,"docString":"The canonical morphism `i : coimage f ‚ü∂ Q` is a monomorphism "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  (h : a ‚äÇ b), ¬¨(b ‚äÜ a : Prop)","name":"HasSSubset.SSubset.not_subset","isProp":true,"docString":"**Alias** of `not_subset_of_ssubset`."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n : ‚Ñï} (s1 : Affine.Simplex k P n) (s2 : Affine.Simplex k P n),\n  (s1 = s2 : Prop) ‚Üî (‚àÄ (i : Fin (n + 1)), Affine.Simplex.points s1 i = Affine.Simplex.points s2 i : Prop)","name":"Affine.Simplex.ext_iff","isProp":true,"docString":"Two simplices are equal if and only if they have the same points. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedDivisionRing Œ±] (a : Œ±) (b : Œ±), ‚Äña * b‚Äñ = ‚Äña‚Äñ * ‚Äñb‚Äñ","name":"NormedDivisionRing.norm_mul'","isProp":true,"docString":"The norm is multiplicative. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] (f : (a : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí M) (n : ‚Ñï),\n  (Finset.prod (Finset.Nat.antidiagonal n) fun (ij : ‚Ñï √ó ‚Ñï) ‚Ü¶ f (Prod.fst ij) (Prod.snd ij)) =\n    Finset.prod (Finset.range (Nat.succ n)) fun (k : ‚Ñï) ‚Ü¶ f k (n - k)","name":"Finset.Nat.prod_antidiagonal_eq_prod_range_succ","isProp":true,"docString":"This lemma matches more generally than `Finset.Nat.prod_antidiagonal_eq_prod_range_succ_mk` when\nusing `rw ‚Üê`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Z : Set Œ±} (h : IsClopen Z),\n  (Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà Z) ‚Ü¶ connectedComponent x) = Z","name":"IsClopen.bunion·µ¢_connectedComponent_eq","isProp":true,"docString":"A clopen set is the union of its connected components. "},{"type":"‚àÄ {R : Type u_2} {E : Type u_1} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E] [inst_2 : Module R E]\n  (s : Set E),\n  ‚Üë(ClosureOperator.toOrderHom (convexHull R)) s =\n    Set.union·µ¢ fun (t : Finset E) ‚Ü¶ Set.union·µ¢ fun (w : ‚Üët ‚äÜ s) ‚Ü¶ ‚Üë(ClosureOperator.toOrderHom (convexHull R)) ‚Üët","name":"convexHull_eq_union_convexHull_finite_subsets","isProp":true,"docString":"A weak version of Carath√©odory's theorem. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±] (H : FreeGroup.Red L‚ÇÅ L‚ÇÇ),\n  FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ","name":"FreeGroup.reduce.eq_of_red","isProp":true,"docString":"If a word reduces to another word, then they have a common maximal reduction. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ±}\n  {c : Œ±} (h‚ÇÅ : MonotoneOn f s) (h‚ÇÇ : MonotoneOn f t) (hs : IsGreatest s c) (ht : IsLeast t c), MonotoneOn f (s ‚à™ t)","name":"MonotoneOn.union_right","isProp":true,"docString":"If `f` is monotone both on `s` and `t`, with `s` to the left of `t` and the center\npoint belonging to both `s` and `t`, then `f` is monotone on `s ‚à™ t` "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroSMulDivisors R M] (x : Module.Ray R M), x ‚â† -x","name":"Module.Ray.ne_neg_self","isProp":true,"docString":"A ray does not equal its own negation. "},{"type":"‚àÄ {Œπ : Type u_3} {B : Type u_1} {F : Type u_2} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (Z : FiberBundleCore Œπ B F), Continuous (FiberBundleCore.proj Z)","name":"FiberBundleCore.continuous_proj","isProp":true,"docString":"The projection on the base of a fiber bundle created from core is continuous "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] {Œπ : Type v} [inst_2 : Fintype Œπ],\n  FiniteDimensional.finrank R (Œπ ‚Üí‚ÇÄ R) = Fintype.card Œπ","name":"FiniteDimensional.finrank_finsupp","isProp":true,"docString":"The finrank of `(Œπ ‚Üí‚ÇÄ R)` is `Fintype.card Œπ`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCancelCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : SMul ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (hf : StrictConcaveOn ùïú s f) (c : E), StrictConcaveOn ùïú ((fun (z : E) ‚Ü¶ c + z) ‚Åª¬π' s) (f ‚àò fun (z : E) ‚Ü¶ c + z)","name":"StrictConcaveOn.translate_right","isProp":true,"docString":"Right translation preserves strict concavity. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K), Subfield.closure ‚Üës = s","name":"Subfield.closure_eq","isProp":true,"docString":"Closure of a subfield `S` equals `S`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ±}\n  {c : Œ±} (h‚ÇÅ : StrictAntiOn f s) (h‚ÇÇ : StrictAntiOn f t) (hs : IsGreatest s c) (ht : IsLeast t c),\n  StrictAntiOn f (s ‚à™ t)","name":"StrictAntiOn.union","isProp":true,"docString":"If `f` is strictly antitone both on `s` and `t`, with `s` to the left of `t` and the center\npoint belonging to both `s` and `t`, then `f` is strictly antitone on `s ‚à™ t` "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.HasShift C ‚Ñ§]\n  {T‚ÇÅ : CategoryTheory.Pretriangulated.Triangle C} {T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle C}\n  (self : CategoryTheory.Pretriangulated.TriangleMorphism T‚ÇÅ T‚ÇÇ),\n  CategoryTheory.Pretriangulated.Triangle.mor‚ÇÉ T‚ÇÅ ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C 1))\n        (CategoryTheory.Pretriangulated.TriangleMorphism.hom‚ÇÅ self) =\n    CategoryTheory.Pretriangulated.TriangleMorphism.hom‚ÇÉ self ‚â´ CategoryTheory.Pretriangulated.Triangle.mor‚ÇÉ T‚ÇÇ","name":"CategoryTheory.Pretriangulated.TriangleMorphism.comm‚ÇÉ","isProp":true,"docString":"the third commutative square of a triangle morphism "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s‚ÇÅ : Set P} {s‚ÇÇ : Set P} (h : s‚ÇÅ ‚äÜ s‚ÇÇ), vectorSpan k s‚ÇÅ ‚â§ vectorSpan k s‚ÇÇ","name":"vectorSpan_mono","isProp":true,"docString":"`vectorSpan` is monotone. "},{"type":"‚àÄ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R ‚Üí+* S)\n  (hf : Function.Surjective ‚Üëf), IsPrincipalIdealRing S","name":"IsPrincipalIdealRing.of_surjective","isProp":true,"docString":"The surjective image of a principal ideal ring is again a principal ideal ring. "},{"type":"‚àÄ {n : Type u_1} {R : Type u_2} {Œ± : Type v} [inst : NonUnitalNonAssocSemiring Œ±] [inst_1 : Fintype n]\n  [inst_2 : Monoid R] [inst_3 : DistribMulAction R Œ±] [inst_4 : IsScalarTower R Œ± Œ±],\n  IsScalarTower R (Matrix n n Œ±) (Matrix n n Œ±)","name":"Matrix.Semiring.isScalarTower","isProp":true,"docString":"This instance enables use with `smul_mul_assoc`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X},\n  (CategoryTheory.Sieve.arrows S (ùüô X) : Prop) ‚Üî (S = ‚ä§ : Prop)","name":"CategoryTheory.Sieve.id_mem_iff_eq_top","isProp":true,"docString":"If the identity arrow is in a sieve, the sieve is maximal. "},{"type":"‚àÄ (n : ‚Ñï), Nat.pred (1 + n) = n","name":"Nat.pred_one_add","isProp":true,"docString":"This ensures that `simp` succeeds on `pred (n + 1) = n`. "},{"type":"‚àÄ {K : Type u} [self : DivisionRing K] (a : K), DivisionRing.zpow 0 a = 1","name":"DivisionRing.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} {p : (a : Œπ) ‚Üí P} (ha : AffineIndependent k p),\n  AffineIndependent k fun (x : ‚Üë(Set.range p)) ‚Ü¶ ‚Üëx","name":"AffineIndependent.range","isProp":true,"docString":"If an indexed family of points is affinely independent, so is the\ncorresponding set of points. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : b ‚â§ c - a), a + b ‚â§ c","name":"add_le_of_le_sub_left","isProp":true,"docString":"**Alias** of the forward direction of `le_sub_iff_add_le'`."},{"type":"‚àÄ {p : ‚Ñï} {q : ‚Ñö} (hq : q ‚â† 0), ‚àÉ (z : ‚Ñ§), padicNorm p q = ‚Üëp ^ (-z)","name":"padicNorm.values_discrete","isProp":true,"docString":"`padicNorm p q` takes discrete values `p ^ -z` for `z : ‚Ñ§`. "},{"type":"‚àÄ {X : Type u} [inst : Lattice X] [inst_1 : JordanHolderLattice X] {s‚ÇÅ : CompositionSeries X} {s‚ÇÇ : CompositionSeries X}\n  (h : ‚àÄ (x : X), (x ‚àà s‚ÇÅ : Prop) ‚Üî (x ‚àà s‚ÇÇ : Prop)), s‚ÇÅ = s‚ÇÇ","name":"CompositionSeries.ext","isProp":true,"docString":"Two `CompositionSeries` are equal if they have the same elements. See also `ext_fun`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_3} [inst : CommSemiring R] {œÉ : Type u_2} [inst_1 : AddCommMonoid M] {œÜ : MvPolynomial œÉ R}\n  {m : M} {n : M} {w : (a : œÉ) ‚Üí M} (hœÜ : œÜ ‚â† 0) (hm : MvPolynomial.IsWeightedHomogeneous w œÜ m)\n  (hn : MvPolynomial.IsWeightedHomogeneous w œÜ n), m = n","name":"MvPolynomial.IsWeightedHomogeneous.inj_right","isProp":true,"docString":"The weighted degree of a nonzero weighted homogeneous polynomial is well-defined. "},{"type":"‚àÄ {T : Type u} [inst : CategoryTheory.Category T] {X : T} {Y : T} (i : X ‚âÖ Y) (p : CategoryTheory.Arrow T)\n  (sq : CategoryTheory.Arrow.mk (CategoryTheory.Iso.hom i) ‚ü∂ p),\n  CategoryTheory.Iso.inv i ‚â´ CategoryTheory.CommaMorphism.left sq ‚â´ CategoryTheory.Comma.hom p =\n    CategoryTheory.CommaMorphism.right sq","name":"CategoryTheory.Arrow.square_from_iso_invert","isProp":true,"docString":"Given a square from an isomorphism `i` to an arrow `p`, express the target part of `sq`\nin terms of the inverse of `i`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (self : LocalEquiv Œ± Œ≤) ‚¶Éx : Œ≤‚¶Ñ (a : x ‚àà LocalEquiv.target self),\n  LocalEquiv.toFun self (LocalEquiv.invFun self x) = x","name":"LocalEquiv.right_inv'","isProp":true,"docString":"The proposition that `invFun` is a local right-inverse of `toFun` on `target`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {i : (a : Œ±) ‚Üí Œ≤}\n  [inst_2 : T2Space Œ≤] (di : DenseInducing i) (hd : Dense (Set.range i·∂ú)) {s : Set Œ±} (hs : IsCompact s), interior s = ‚àÖ","name":"DenseInducing.interior_compact_eq_empty","isProp":true,"docString":"If `i : Œ± ‚Üí Œ≤` is a dense embedding with dense complement of the range, then any compact set in\n`Œ±` has empty interior. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] [inst_1 : IsAsymm Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±} (a_1 : a ‚äÇ b),\n  ¬¨(b ‚äÇ a : Prop)","name":"HasSSubset.SSubset.asymm","isProp":true,"docString":"**Alias** of `ssubset_asymm`."},{"type":"‚àÄ {X : Type u} {m‚ÇÅ : (a : X) ‚Üí (a : X) ‚Üí X} {m‚ÇÇ : (a : X) ‚Üí (a : X) ‚Üí X} {e‚ÇÅ : X} {e‚ÇÇ : X}\n  (h‚ÇÅ : EckmannHilton.IsUnital m‚ÇÅ e‚ÇÅ) (h‚ÇÇ : EckmannHilton.IsUnital m‚ÇÇ e‚ÇÇ)\n  (distrib : ‚àÄ (a : X) (b : X) (c : X) (d : X), m‚ÇÅ (m‚ÇÇ a b) (m‚ÇÇ c d) = m‚ÇÇ (m‚ÇÅ a c) (m‚ÇÅ b d)), IsAssociative X m‚ÇÇ","name":"EckmannHilton.mul_assoc","isProp":true,"docString":"If a type carries two unital binary operations that distribute over each other,\nthen these operations are associative.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.CommMonoid`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {a : Œ±},\n  List.TFAE\n    [(Acc r a : Prop), (Set.WellFoundedOn (setOf fun (b : Œ±) ‚Ü¶ Relation.ReflTransGen r b a) r : Prop),\n      (Set.WellFoundedOn (setOf fun (b : Œ±) ‚Ü¶ Relation.TransGen r b a) r : Prop)]","name":"Set.WellFoundedOn.acc_iff_wellFoundedOn","isProp":true,"docString":"`a` is accessible under the relation `r` iff `r` is well-founded on the downward transitive\nclosure of `a` under `r` (including `a` or not). "},{"type":"‚àÄ {n : Type v} {Œ± : Type w} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  (h : Fintype.card n ‚â† 1), Matrix.adjugate (Matrix.adjugate A) = Matrix.det A ^ (Fintype.card n - 2) ‚Ä¢ A","name":"Matrix.adjugate_adjugate","isProp":true,"docString":"Note that this is not true for `Fintype.card n = 1` since `1 - 2 = 0` and not `-1`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b) (a_2 : ¬¨(b ‚â§ a : Prop)), a < b","name":"LE.le.lt_of_not_le","isProp":true,"docString":"**Alias** of `lt_of_le_not_le`."},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module R E] [inst_4 : Module R F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : ContinuousAdd E] [inst_8 : ContinuousAdd F] [inst_9 : TopologicalSpace R] [inst_10 : ContinuousSMul R E]\n  [inst_11 : ContinuousSMul R F] {f : E ‚Üí‚Çó.[R] F} (hf : LinearPMap.IsClosed f), LinearPMap.IsClosable f","name":"LinearPMap.IsClosed.isClosable","isProp":true,"docString":"A closed operator is trivially closable. "},{"type":"‚àÄ {R : Type u} {L : Type v} {L' : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : LieRing L'] [inst_4 : LieAlgebra R L'] (self : L ‚âÉ‚Çó‚ÅÖR‚ÅÜ L'),\n  Function.LeftInverse (LieEquiv.invFun self) (AddHom.toFun (LinearMap.toAddHom ‚Üë(LieEquiv.toLieHom self)))","name":"LieEquiv.left_inv","isProp":true,"docString":"The inverse function of an equivalence of Lie algebras is a left inverse of the underlying\nfunction. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {f' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±}\n  {t : Set Œ≤} (h : ‚àÄ (a : Œ±) (b : Œ≤), f a b = f' a b), Set.image2 f s t = Set.image2 f' s t","name":"Set.image2_congr'","isProp":true,"docString":"A common special case of `image2_congr` "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {f : Polynomial R} {I : Ideal (Polynomial R)}\n  (cf : ‚àÄ (i : ‚Ñï), ‚ÜëPolynomial.C (Polynomial.coeff f i) ‚àà I),\n  Ideal.span (setOf fun (g : Polynomial R) ‚Ü¶ ‚àÉ (i : ‚Ñï), g = ‚ÜëPolynomial.C (Polynomial.coeff f i)) ‚â§ I","name":"Polynomial.span_le_of_C_coeff_mem","isProp":true,"docString":"If the coefficients of a polynomial belong to an ideal, then that ideal contains\nthe ideal spanned by the coefficients of the polynomial. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ}\n  {c : Œ≤},\n  (Filter.Tendsto (‚ÜøF) (Filter.prod p (Filter.principal s)) (nhds c) : Prop) ‚Üî\n    (TendstoUniformlyOn F (fun (x : Œ±) ‚Ü¶ c) p s : Prop)","name":"tendsto_prod_principal_iff","isProp":true,"docString":"Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p √ó·∂† ùìü s`. "},{"type":"‚àÄ {M : Type u_6} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_4} [inst_1 : AddCommMonoid N] {P : Type u_3}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P} {T : AddSubmonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_5} [inst_3 : AddCommMonoid Q]\n  {k : AddSubmonoid.LocalizationMap T Q} {A : Type u_1} [inst_4 : AddCommMonoid A] {U : AddSubmonoid A} {R : Type u_2}\n  [inst_5 : AddCommMonoid R] (j : AddSubmonoid.LocalizationMap U R) {l : P ‚Üí+ A}\n  (hl : ‚àÄ (w : { x : P // x ‚àà T }), ‚Üël ‚Üëw ‚àà U) (x : N),\n  ‚Üë(AddSubmonoid.LocalizationMap.map k hl j) (‚Üë(AddSubmonoid.LocalizationMap.map f hy k) x) =\n    ‚Üë(AddSubmonoid.LocalizationMap.map f\n          (fun (x : { x : M // x ‚àà S }) ‚Ü¶\n            (_ : ‚Üë(AddMonoidHom.comp l g) ‚Üëx ‚àà U)=:‚àÄ (x : { x : M // x ‚àà S }), ‚Üë(AddMonoidHom.comp l g) ‚Üëx ‚àà U)\n          j)\n      x","name":"AddSubmonoid.LocalizationMap.map_map","isProp":true,"docString":"If `AddCommMonoid` homs `g : M ‚Üí+ P, l : P ‚Üí+ A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ‚àò g`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {s : Set Œ±} (hs : CompleteLattice.SetIndependent s) {x : Œ±} {y : Set Œ±}\n  (hx : x ‚àà s) (hy : y ‚äÜ s) (hxy : ¬¨(x ‚àà y : Prop)), Disjoint x (sup‚Çõ y)","name":"CompleteLattice.SetIndependent.disjoint_sup‚Çõ","isProp":true,"docString":"If the elements of a set are independent, then any element is disjoint from the `sup‚Çõ` of some\nsubset of the rest. "},{"type":"‚àÄ {R : Type u_2} {S : Type u_1} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ‚âÉ+* S), ‚Üëf 1 = 1","name":"RingEquiv.map_one","isProp":true,"docString":"A ring isomorphism sends one to one. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) (N : AddSubgroup G) [hN : AddSubgroup.Normal N],\n  ‚Üë(H ‚äî N) = ‚ÜëH + ‚ÜëN","name":"AddSubgroup.add_normal","isProp":true,"docString":"The carrier of `H ‚äî N` is just `‚ÜëH + ‚ÜëN` (pointwise set addition)\nwhen `N` is normal."},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M), Submonoid.closure ‚ÜëS = S","name":"Submonoid.closure_eq","isProp":true,"docString":"Closure of a submonoid `S` equals `S`. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type uu} [inst : Preorder Œ±] {f : (a : Fin n) ‚Üí Œ±},\n  (List.Sorted (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) (List.ofFn f) : Prop) ‚Üî (Monotone f : Prop)","name":"List.sorted_le_ofFn_iff","isProp":true,"docString":"The list `List.ofFn f` is sorted with respect to `(¬∑ ‚â§ ¬∑)` if and only if `f` is monotone. "},{"type":"‚àÄ {K : Type u} [inst : Field K] {s : Set K} {t : Subfield K}, (Subfield.closure s ‚â§ t : Prop) ‚Üî (s ‚äÜ ‚Üët : Prop)","name":"Subfield.closure_le","isProp":true,"docString":"A subfield `t` includes `closure s` if and only if it includes `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] [inst_1 : NoMinOrder Œ±] (a : Œ±),\n  Filter.map Subtype.val Filter.atBot = Filter.atBot","name":"Filter.map_val_Iio_atBot","isProp":true,"docString":"The `atBot` filter for an open interval `Iio a` comes from the `atBot` filter in the ambient\norder. "},{"type":"‚àÄ {R : Type u} {S‚ÇÅ : Type v} {œÉ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S‚ÇÅ] {f : R ‚Üí+* S‚ÇÅ}\n  {g : S‚ÇÅ ‚Üí+* R} (hf : Function.LeftInverse ‚Üëf ‚Üëg), Function.LeftInverse ‚Üë(MvPolynomial.map f) ‚Üë(MvPolynomial.map g)","name":"MvPolynomial.map_leftInverse","isProp":true,"docString":"If `f` is a left-inverse of `g` then `map f` is a left-inverse of `map g`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : AddZeroClass M] {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f)\n  (v‚ÇÅ : Œ≤ ‚Üí‚ÇÄ M) (v‚ÇÇ : Œ≤ ‚Üí‚ÇÄ M),\n  Finsupp.comapDomain f (v‚ÇÅ + v‚ÇÇ)\n      ((Function.Injective.injOn hf\n            (f ‚Åª¬π'\n              ‚Üë(Finsupp.support\n                  (v‚ÇÅ +\n                    v‚ÇÇ)))=:Set.InjOn f\n            (f ‚Åª¬π' ‚Üë(Finsupp.support (v‚ÇÅ + v‚ÇÇ))))=:Set.InjOn f (f ‚Åª¬π' ‚Üë(Finsupp.support (v‚ÇÅ + v‚ÇÇ)))) =\n    Finsupp.comapDomain f v‚ÇÅ\n        ((Function.Injective.injOn hf\n              (f ‚Åª¬π'\n                ‚Üë(Finsupp.support\n                    v‚ÇÅ))=:Set.InjOn f (f ‚Åª¬π' ‚Üë(Finsupp.support v‚ÇÅ)))=:Set.InjOn f (f ‚Åª¬π' ‚Üë(Finsupp.support v‚ÇÅ))) +\n      Finsupp.comapDomain f v‚ÇÇ\n        ((Function.Injective.injOn hf\n              (f ‚Åª¬π'\n                ‚Üë(Finsupp.support\n                    v‚ÇÇ))=:Set.InjOn f (f ‚Åª¬π' ‚Üë(Finsupp.support v‚ÇÇ)))=:Set.InjOn f (f ‚Åª¬π' ‚Üë(Finsupp.support v‚ÇÇ)))","name":"Finsupp.comapDomain_add_of_injective","isProp":true,"docString":"A version of `Finsupp.comapDomain_add` that's easier to use. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] (t : Multiset Œπ) (f : (a : Œπ) ‚Üí Set Œ±) (g : (a : Œπ) ‚Üí Œ±)\n  (hg : ‚àÄ (i : Œπ) (a : i ‚àà t), g i ‚àà f i), Multiset.sum (Multiset.map g t) ‚àà Multiset.sum (Multiset.map f t)","name":"Set.multiset_sum_mem_multiset_sum","isProp":true,"docString":"An n-ary version of `Set.add_mem_add`. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (S : Set (Con M)),\n  sup‚Çõ S = conGen fun (x : M) (y : M) ‚Ü¶ ‚àÉ (c : Con M), (c ‚àà S : Prop) ‚àß (‚Üëc x y : Prop)","name":"Con.sup‚Çõ_eq_conGen","isProp":true,"docString":"The supremum of a set of congruence relations `S` equals the smallest congruence relation\ncontaining the binary relation 'there exists `c ‚àà S` such that `x` is related to `y` by\n`c`'. "},{"type":"‚àÄ {M : Type u_1} [inst : DivisionMonoid M] [inst_1 : TopologicalSpace M]\n  (h : ContinuousOn Inv.inv (setOf fun (x : M) ‚Ü¶ IsUnit x)), Embedding Units.val","name":"Units.embedding_val_mk","isProp":true,"docString":"An auxiliary lemma that can be used to prove that coercion `MÀ£ ‚Üí M` is a topological embedding.\nUse `Units.embedding_val‚ÇÄ`, `Units.embedding_val`, or `toUnits_homeomorph` instead. "},{"type":"‚àÄ {Œ± : Type u_1} {ix : Fin 1} (x : Œ±), Vector.get (x ::·µ• Vector.nil) ix = x","name":"Vector.get_cons_nil","isProp":true,"docString":"Accessing the nth element of a vector made up\nof one element `x : Œ±` is `x` itself. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] (u : Œ±) (v : Œ±),\n  Set.InjOn (fun (x : Œ±) ‚Ü¶ (x ‚äî u) \\ v) (setOf fun (x : Œ±) ‚Ü¶ (Disjoint u x : Prop) ‚àß (v ‚â§ x : Prop))","name":"sup_sdiff_injOn","isProp":true,"docString":"UV-compression is injective on the elements it moves. See `UV.compress`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} {b : Œ±} (h : a < b), b ‚â† ‚ä•","name":"LT.lt.ne_bot","isProp":true,"docString":"**Alias** of `ne_bot_of_gt`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} {o : Ordering} (a_1 : Ordering.Compares (Ordering.swap o) a b),\n  Ordering.Compares o b a","name":"Ordering.Compares.of_swap","isProp":true,"docString":"**Alias** of the forward direction of `Ordering.compares_swap`."},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommSemiring Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"LinearOrderedCommSemiring.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddGroupHom f),\n  IsAddMonoidHom f","name":"IsAddGroupHom.to_isAddMonoidHom","isProp":true,"docString":"An additive group homomorphism is an additive monoid homomorphism."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {r : ‚Ñù} (h : 0 ‚â§ r), Metric.diam (Metric.ball x r) ‚â§ 2 * r","name":"Metric.diam_ball","isProp":true,"docString":"The diameter of a ball of radius `r` is at most `2 r`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] ‚¶Éh : Set G‚¶Ñ ‚¶Ék : Set G‚¶Ñ (h' : h ‚äÜ k), AddSubgroup.closure h ‚â§ AddSubgroup.closure k","name":"AddSubgroup.closure_mono","isProp":true,"docString":"Additive subgroup closure of a set is monotone in its argument: if `h ‚äÜ k`,\nthen `closure h ‚â§ closure k`"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [self : HasDistribNeg Œ±] (x : Œ±) (y : Œ±), x * -y = -(x * y)","name":"HasDistribNeg.mul_neg","isProp":true,"docString":"Negation is right distributive over multiplication "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : IsClosed s) (ht : IsClosed t),\n  (EMetric.hausdorffEdist s t = 0 : Prop) ‚Üî (s = t : Prop)","name":"EMetric.hausdorffEdist_zero_iff_eq_of_closed","isProp":true,"docString":"Two closed sets are at zero Hausdorff edistance if and only if they coincide "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : AddCommMonoid Œ±] [inst_2 : T2Space Œ±]\n  [inst_3 : ContinuousAdd Œ±] {f : (a : Œ≤) ‚Üí Œ±} {a : Œ±} {a' : Œ±} (hf : HasSum f a) (b : Œ≤) (x : Œ±)\n  (hf' : HasSum (Function.update f b x) a'), a + x = a' + f b","name":"HasSum.update'","isProp":true,"docString":"Version of `HasSum.update` for `AddCommMonoid` rather than `AddCommGroup`.\nRather than showing that `f.update` has a specific sum in terms of `HasSum`,\nit gives a relationship between the sums of `f` and `f.update` given that both exist. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NormedField Œ±] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace Œ± E]\n  {c : Œ±} (hc : 1 < ‚Äñc‚Äñ) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) {x : E} (hx : x ‚â† 0),\n  ‚àÉ (d : Œ±),\n    (d ‚â† 0 : Prop) ‚àß\n      ((‚Äñd ‚Ä¢ x‚Äñ < Œµ : Prop) ‚àß ((Œµ / ‚Äñc‚Äñ ‚â§ ‚Äñd ‚Ä¢ x‚Äñ : Prop) ‚àß (‚Äñd‚Äñ‚Åª¬π ‚â§ Œµ‚Åª¬π * ‚Äñc‚Äñ * ‚Äñx‚Äñ : Prop) : Prop) : Prop)","name":"rescale_to_shell","isProp":true,"docString":"If there is a scalar `c` with `‚Äñc‚Äñ>1`, then any element can be moved by scalar multiplication to\nany shell of width `‚Äñc‚Äñ`. Also recap information on the norm of the rescaling element that shows\nup in applications. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±}\n  (hs : Set.Finite (s ‚à© Function.mulSupport f)) (ht : Set.Finite (t ‚à© Function.mulSupport f)),\n  ((finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) *\n      finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s ‚à© t) ‚Ü¶ f i) =\n    (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà t) ‚Ü¶ f i","name":"finprod_mem_union_inter'","isProp":true,"docString":"A more general version of `finprod_mem_union_inter` that requires `s ‚à© mulSupport f` and\n`t ‚à© mulSupport f` rather than `s` and `t` to be finite. "},{"type":"‚àÄ {n : ‚Ñï} (c : Composition n) {j : ‚Ñï} (h : j < n),\n  ‚àÉ (i : ‚Ñï), (j < Composition.sizeUpTo c (Nat.succ i) : Prop) ‚àß (i < Composition.length c : Prop)","name":"Composition.index_exists","isProp":true,"docString":"`index_exists` asserts there is some `i` with `j < c.size_up_to (i+1)`.\nIn the next definition `index` we use `nat.find` to produce the minimal such index.\n"},{"type":"‚àÄ (Œ± : Type u_1) [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1], 0 < 4","name":"zero_lt_four'","isProp":true,"docString":"See `zero_lt_four` for a version with the type implicit. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), p -·µ• p = 0","name":"vsub_self","isProp":true,"docString":"Subtracting a point from itself produces 0. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (N : AddSubgroup G) (H : AddSubgroup G) [inst_1 : AddSubgroup.Normal N],\n  ‚Üë(N ‚äî H) = ‚ÜëN + ‚ÜëH","name":"AddSubgroup.normal_add","isProp":true,"docString":"The carrier of `N ‚äî H` is just `‚ÜëN + ‚ÜëH` (pointwise set addition)\nwhen `N` is normal."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (x : Œ±),\n  (x ‚àà LocallyFiniteOrder.finsetIco a b : Prop) ‚Üî ((a ‚â§ x : Prop) ‚àß (x < b : Prop) : Prop)","name":"LocallyFiniteOrder.finset_mem_Ico","isProp":true,"docString":"`x ‚àà finsetIco a b ‚Üî a ‚â§ x ‚àß x < b` "},{"type":"‚àÄ {C : Type u} {A : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : AddCommMonoid A]\n  [inst_2 : CategoryTheory.HasShift C A] {X : C} {Y : C} (f : X ‚ü∂ Y) (i : A) (j : A),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C j))\n      (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C i)) f) =\n    CategoryTheory.Iso.hom (CategoryTheory.shiftComm X i j) ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C i))\n          (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C j)) f) ‚â´\n        CategoryTheory.Iso.hom (CategoryTheory.shiftComm Y j i)","name":"CategoryTheory.shiftComm'","isProp":true,"docString":"When shifts are indexed by an additive commutative monoid, then shifts commute. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : ¬¨(a ‚â§ b : Prop)),\n  Multiset.Icc a b = 0","name":"Multiset.Icc_eq_zero","isProp":true,"docString":"**Alias** of the reverse direction of `Multiset.Icc_eq_zero_iff`."},{"type":"‚àÄ {R : Type u_1} {M : Type u_3} [inst : CommSemiring R] {œÉ : Type u_2} [inst_1 : AddCommMonoid M] (w : (a : œÉ) ‚Üí M)\n  (œÜ : MvPolynomial œÉ R), (finsum fun (m : M) ‚Ü¶ ‚Üë(MvPolynomial.weightedHomogeneousComponent w m) œÜ) = œÜ","name":"MvPolynomial.sum_weightedHomogeneousComponent","isProp":true,"docString":"Every polynomial is the sum of its weighted homogeneous components. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Filter Œ±} {u : (a : Œ±) ‚Üí ENNReal} {a : ENNReal} (ha : a ‚â† ‚ä§),\n  (Filter.Tendsto u f (nhds a) : Prop) ‚Üî\n    (‚àÄ (Œµ : ENNReal) (a_1 : Œµ > 0), Filter.Eventually (fun (x : Œ±) ‚Ü¶ u x ‚àà Set.Icc (a - Œµ) (a + Œµ)) f : Prop)","name":"ENNReal.tendsto_nhds","isProp":true,"docString":"Characterization of neighborhoods for `‚Ñù‚â•0‚àû` numbers. See also `tendsto_order`\nfor a version with strict inequalities. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Finite Œ±] {f : (a : Œ±) ‚Üí Œ±} (a : Function.Injective f), Function.Bijective f","name":"Function.Injective.bijective_of_finite","isProp":true,"docString":"**Alias** of the forward direction of `Finite.injective_iff_bijective`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : SMul ùïú E] {s : Set E}\n  (a : Convex ùïú s) ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 ‚â§ a) (a_2 : 0 ‚â§ b) (a_3 : a + b = 1), a ‚Ä¢ s + b ‚Ä¢ s ‚äÜ s","name":"Convex.set_combo_subset","isProp":true,"docString":"**Alias** of the forward direction of `convex_iff_pointwise_add_subset`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {p : (a : Œ±) ‚Üí Prop} {a : Œ±}\n  (h : Filter.Eventually (fun (y : Œ±) ‚Ü¶ p y) (nhds a)), p a","name":"Filter.Eventually.self_of_nhds","isProp":true,"docString":"If a predicate is true in a neighborhood of `a`, then it is true for `a`. "},{"type":"‚àÄ {Œ≤ : Type u_1} {f : (a : Œ≤) ‚Üí ‚Ñù} {g : (a : Œ≤) ‚Üí ‚Ñù} (hg : ‚àÄ (b : Œ≤), 0 ‚â§ g b) (hgf : ‚àÄ (b : Œ≤), g b ‚â§ f b)\n  (hf : Summable f), Summable g","name":"summable_of_nonneg_of_le","isProp":true,"docString":"Comparison test of convergence of series of non-negative real numbers. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Finite Œ±], CompactSpace Œ±","name":"Finite.compactSpace","isProp":true,"docString":"Finite topological spaces are compact. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], (0 < FiniteDimensional.finrank K V : Prop) ‚Üî (‚àÉ (x : V), x ‚â† 0 : Prop)","name":"FiniteDimensional.finrank_pos_iff_exists_ne_zero","isProp":true,"docString":"A finite dimensional space has positive `finrank` iff it has a nonzero element. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : NormalizedGCDMonoid Œ±] (a : Œ±) (b : Œ±),\n  ‚Üënormalize (gcd a b) = gcd a b","name":"NormalizedGCDMonoid.normalize_gcd","isProp":true,"docString":"The GCD is normalized to itself. "},{"type":"‚àÄ {Œ± : Type u_1} [self : HeytingAlgebra Œ±] (a : Œ±), ‚ä• ‚â§ a","name":"HeytingAlgebra.bot_le","isProp":true,"docString":"`‚ä•` is a least element "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f1 : Œ± ‚Üí‚ÇÄ M} {f2 : Œ± ‚Üí‚ÇÄ M}\n  (hd : Disjoint (Finsupp.support f1) (Finsupp.support f2)) {Œ≤ : Type u_3} [inst_1 : CommMonoid Œ≤]\n  (g : (a : Œ±) ‚Üí (a : M) ‚Üí Œ≤), Finsupp.prod (f1 + f2) g = Finsupp.prod f1 g * Finsupp.prod f2 g","name":"Finsupp.prod_add_index_of_disjoint","isProp":true,"docString":"For disjoint `f1` and `f2`, and function `g`, the product of the products of `g`\nover `f1` and `f2` equals the product of `g` over `f1 + f2` "},{"type":"‚àÄ {Œ± : Type u_1} (self : MeasurableSpace.DynkinSystem Œ±) {a : Set Œ±} (a_1 : MeasurableSpace.DynkinSystem.Has self a),\n  MeasurableSpace.DynkinSystem.Has self (a·∂ú)","name":"MeasurableSpace.DynkinSystem.has_compl","isProp":true,"docString":"A Dynkin system is closed under complementation. "},{"type":"‚àÄ {Œ± : Type u_1} {E' : Type u_2} {F' : Type u_3} [inst : SeminormedAddCommGroup E'] [inst_1 : SeminormedAddCommGroup F']\n  {f' : (a : Œ±) ‚Üí E'} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f' =O[l] g'),\n  (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =O[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ","name":"Asymptotics.IsBigO.norm_norm","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigO_norm_norm`."},{"type":"‚àÄ (p : Nat.Primes), PNat.factorMultiset ‚Üëp = PrimeMultiset.ofPrime p","name":"PNat.factorMultiset_ofPrime","isProp":true,"docString":"Factoring a prime gives the corresponding one-element multiset. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {F : Type u_3}\n  [mc : MonoidHomClass F M N] (f : F) (hf : Function.Surjective ‚Üëf), MonoidHom.mrange f = ‚ä§","name":"MonoidHom.mrange_top_of_surjective","isProp":true,"docString":"The range of a surjective monoid hom is the whole of the codomain. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x : X} {y : X} (self : Path x y),\n  ContinuousMap.toFun (Path.toContinuousMap self) 0 = x","name":"Path.source'","isProp":true,"docString":"The start point of a `Path`. "},{"type":"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Submodule K V), (IsAtom W : Prop) ‚Üî (‚àÉ (v : V), ‚àÉ (x : v ‚â† 0), W = Submodule.span K {v} : Prop)","name":"atom_iff_nonzero_span","isProp":true,"docString":"The atoms of the lattice of submodules of a module over a division ring are the\nsubmodules equal to the span of a nonzero element of the module. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] (L : List M) (h : List.prod L ‚â† 1), 0 < List.length L","name":"List.length_pos_of_prod_ne_one","isProp":true,"docString":"A list with product not one must have positive length. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±],\n  Finset.univ = Finset.map (Equiv.toEmbedding (Equiv.symm Equiv.Perm.decomposeOption)) Finset.univ","name":"Finset.univ_perm_option","isProp":true,"docString":"The set of all permutations of `Option Œ±` can be constructed by augmenting the set of\npermutations of `Œ±` by each element of `Option Œ±` in turn. "},{"type":"‚àÄ (A : Finset ‚Ñï) (B : Finset ‚Ñï),\n  ((Finset.sum A fun (i : ‚Ñï) ‚Ü¶ 2 ^ i) < Finset.sum B fun (i : ‚Ñï) ‚Ü¶ 2 ^ i : Prop) ‚Üî\n    (Finset.toColex A < Finset.toColex B : Prop)","name":"Colex.sum_two_pow_lt_iff_lt","isProp":true,"docString":"For subsets of ‚Ñï, we can show that colex is equivalent to binary. "},{"type":"‚àÄ {œÑ : Type u_2} {Œ± : Type u_3} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤] (f : Filter œÑ) (œï : (a : œÑ) ‚Üí (a : Œ±) ‚Üí Œ≤)\n  (s : Set Œ±) (y : Œ≤),\n  (y ‚àà omegaLimit f œï s : Prop) ‚Üî\n    (‚àÄ (n : Set Œ≤) (a : n ‚àà nhds y), Filter.Frequently (fun (t : œÑ) ‚Ü¶ Set.Nonempty (œï t '' s ‚à© n)) f : Prop)","name":"mem_omegaLimit_iff_frequently‚ÇÇ","isProp":true,"docString":"An element `y` is in the œâ-limit set of `s` w.r.t. `f` if the\nforward images of `s` frequently (w.r.t. `f`) intersect arbitrary\nneighbourhoods of `y`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasCoequalizers C],\n  CategoryTheory.Limits.HasReflexiveCoequalizers C","name":"CategoryTheory.Limits.hasReflexiveCoequalizers_of_hasCoequalizers","isProp":true,"docString":"If `C` has coequalizers, then it has reflexive coequalizers. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (hf : Antitone f) (hg : Antitone g), Antitone fun (x : Œ≤) ‚Ü¶ f x + g x","name":"Antitone.add","isProp":true,"docString":"The sum of two antitone functions is antitone."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : UniformInducing f),\n  Filter.comap (fun (x : Œ± √ó Œ±) ‚Ü¶ (f (Prod.fst x), f (Prod.snd x))) (uniformity Œ≤) = uniformity Œ±","name":"UniformInducing.comap_uniformity","isProp":true,"docString":"The uniformity filter on the domain is the pullback of the uniformity filter on the codomain\nunder `Prod.map f f`. "},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] [inst_2 : Encodable Œ±]\n  [inst_3 : DenselyOrdered Œ±] [inst_4 : NoMinOrder Œ±] [inst_5 : NoMaxOrder Œ±] [inst_6 : Nonempty Œ±]\n  [inst_7 : Encodable Œ≤] [inst_8 : DenselyOrdered Œ≤] [inst_9 : NoMinOrder Œ≤] [inst_10 : NoMaxOrder Œ≤]\n  [inst_11 : Nonempty Œ≤], Nonempty (Œ± ‚âÉo Œ≤)","name":"Order.iso_of_countable_dense","isProp":true,"docString":"Any two countable dense, nonempty linear orders without endpoints are order isomorphic. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : EuclideanDomain R] [inst_1 : OrderedSemiring S] {abv : AbsoluteValue R S}\n  (self : AbsoluteValue.IsEuclidean abv) {x : R} {y : R}, (‚Üëabv x < ‚Üëabv y : Prop) ‚Üî (EuclideanDomain.r x y : Prop)","name":"AbsoluteValue.IsEuclidean.map_lt_map_iff'","isProp":true,"docString":"The requirement of a Euclidean absolute value\nthat `abv` is monotone with respect to `‚â∫` "},{"type":"‚àÄ {R : Type u} [inst : Semigroup R] [inst_1 : StarSemigroup R] {x : R} {y : R} {z : R} (a : SemiconjBy x y z),\n  SemiconjBy (star x) (star z) (star y)","name":"SemiconjBy.star_star_star","isProp":true,"docString":"**Alias** of the reverse direction of `semiconjBy_star_star_star`."},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≤' : Type u_5} {Œ≥ : Type u_2} {Œ¥ : Type u_1} [inst : DecidableEq Œ≤']\n  [inst_1 : DecidableEq Œ≥] [inst_2 : DecidableEq Œ¥] {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Finset Œ±} {t : Finset Œ≤}\n  {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ≤') ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ≤) ‚Üí Œ≤'}\n  (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' (g' b) a),\n  Finset.image g (Finset.image‚ÇÇ f s t) = Finset.image‚ÇÇ f' (Finset.image g' t) s","name":"Finset.image_image‚ÇÇ_antidistrib_left","isProp":true,"docString":"Symmetric statement to `Finset.image‚ÇÇ_image_left_anticomm`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a - b ‚â§ 0), a ‚â§ b","name":"le_of_sub_nonpos","isProp":true,"docString":"**Alias** of the forward direction of `sub_nonpos`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : OrderedRing ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : AddCommGroup F] [inst_3 : Module ùïú E] [inst_4 : Module ùïú F] {s : Set E} (f : E ‚Üí·µÉ[ùïú] F) (hs : Convex ùïú s),\n  Convex ùïú (‚Üëf '' s)","name":"Convex.affine_image","isProp":true,"docString":"The image of a convex set under an affine map is convex. "},{"type":"‚àÄ {Œ± : Type u_1} {G : Type u_2} [inst : Group G] {ùîñ : Set (Set Œ±)} [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformOnFun Œ± G ùîñ)","name":"instUniformGroupUniformOnFunUniformSpaceInstGroupUniformOnFun","isProp":true,"docString":"Let `ùîñ : Set (Set Œ±)`. If `G` is a uniform group, then `Œ± ‚Üí·µ§[ùîñ] G` is a uniform group as\nwell. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [self : FloorRing Œ±], GaloisConnection FloorRing.ceil Int.cast","name":"FloorRing.gc_ceil_coe","isProp":true,"docString":"`FloorRing.ceil` is the lower adjoint of the coercion `‚Üë : ‚Ñ§ ‚Üí Œ±`."},{"type":"‚àÄ {M : Type u_2} {R : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : SetLike M R] [inst_2 : MulMemClass M R]\n  {S : M} {a : R} {b : R} (ha : a ‚àà AddSubmonoid.closure ‚ÜëS) (hb : b ‚àà AddSubmonoid.closure ‚ÜëS),\n  a * b ‚àà AddSubmonoid.closure ‚ÜëS","name":"MulMemClass.mul_mem_add_closure","isProp":true,"docString":"The product of two elements of the additive closure of a submonoid `M` is an element of the\nadditive closure of `M`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : TopologicalSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {x‚ÇÄ : Œ≤},\n  (EquicontinuousAt F x‚ÇÄ : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n        ‚àÉ (U : Set Œ≤),\n          (U ‚àà nhds x‚ÇÄ : Prop) ‚àß\n            (‚àÄ (x : Œ≤) (a : x ‚àà U) (x' : Œ≤) (a : x' ‚àà U) (i : Œπ), dist (F i x) (F i x') < Œµ : Prop) :\n      Prop)","name":"Metric.equicontinuousAt_iff_pair","isProp":true,"docString":"Reformulation of `equicontinuousAt_iff_pair` for families of functions taking values in a\n(pseudo) metric space. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : (a : Œ≤) ‚Üí Œ≥} {x : Œ≤}\n  (h : x ‚àà LocalEquiv.target (LocalHomeomorph.toLocalEquiv e)),\n  (ContinuousAt f x : Prop) ‚Üî (ContinuousAt (f ‚àò ‚Üëe) (‚Üë(LocalHomeomorph.symm e) x) : Prop)","name":"LocalHomeomorph.continuousAt_iff_continuousAt_comp_right","isProp":true,"docString":"Continuity at a point can be read under right composition with a local homeomorphism, if the\npoint is in its target "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedRing Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"LinearOrderedRing.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {a : Set (Œ± √ó Œ±)}\n  (ha : a ‚àà uniformity Œ±) {b : Set (Œ≤ √ó Œ≤)} (hb : b ‚àà uniformity Œ≤),\n  (fun (p : Œ± √ó Œ±) ‚Ü¶ (Sum.inl (Prod.fst p), Sum.inl (Prod.snd p))) '' a ‚à™\n      (fun (p : Œ≤ √ó Œ≤) ‚Ü¶ (Sum.inr (Prod.fst p), Sum.inr (Prod.snd p))) '' b ‚àà\n    UniformSpace.Core.uniformity UniformSpace.Core.sum","name":"union_mem_uniformity_sum","isProp":true,"docString":"The union of an entourage of the diagonal in each set of a disjoint union is again an entourage\nof the diagonal. "},{"type":"PythagoreanTriple 0 0 0","name":"PythagoreanTriple.zero","isProp":true,"docString":"The zeroth Pythagorean triple is all zeros. "},{"type":"‚àÄ {R : Type u_1} [inst : AddSemigroup R] {a : R} {b : R} (ab : IsAddLeftRegular (a + b)), IsAddLeftRegular b","name":"IsAddLeftRegular.of_add","isProp":true,"docString":"If an element `b` becomes add-left-regular after adding to it on the left\na add-left-regular element, then `b` is add-left-regular."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] {a : Œ±} (a_1 : Odd a), ‚àÉ (b : Œ±), a = bit1 b","name":"Odd.exists_bit1","isProp":true,"docString":"**Alias** of the forward direction of `odd_iff_exists_bit1`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddGroup Œ±] [inst_1 : SubtractionMonoid Œ≤] (f : Œ± ‚Üí+ Œ≤) (a : Œ±), ‚Üëf (-a) = -‚Üëf a","name":"AddMonoidHom.map_neg","isProp":true,"docString":"Additive group homomorphisms preserve negation."},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú},\n  (ConvexOn ùïú s f : Prop) ‚Üî\n    ((Convex ùïú s : Prop) ‚àß\n        (‚àÄ ‚¶Éx : ùïú‚¶Ñ ‚¶Éy : ùïú‚¶Ñ ‚¶Éz : ùïú‚¶Ñ (a : x ‚àà s) (a : z ‚àà s) (a : x < y) (a : y < z),\n            (f y - f x) / (y - x) ‚â§ (f z - f y) / (z - y) :\n          Prop) :\n      Prop)","name":"convexOn_iff_slope_mono_adjacent","isProp":true,"docString":"A function `f : ùïú ‚Üí ùïú` is convex iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. "},{"type":"‚àÄ {a : ENNReal} {b : ENNReal} (h : a < b), AddLECancellable a","name":"ENNReal.cancel_of_lt'","isProp":true,"docString":"This lemma has an abbreviated name because it is used frequently. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (S : Subgroup G)\n  (hS : Filter.Tendsto (‚Üë(Subgroup.subtype S)) Filter.cofinite (Filter.cocompact G)),\n  ProperlyDiscontinuousSMul { x : G·µê·µí·µñ // x ‚àà ‚ÜëSubgroup.opposite S } G","name":"Subgroup.properlyDiscontinuousSMul_opposite_of_tendsto_cofinite","isProp":true,"docString":"A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the right, if\nit is discrete in the sense that `S ‚à© K` is finite for all compact `K`. (See also\n`DiscreteTopology`.)\n\nIf `G` is Hausdorff, this can be combined with `t2Space_of_properlyDiscontinuousSMul_of_t2Space`\nto show that the quotient group `G ‚ß∏ S` is Hausdorff. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n  [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (inf·µ¢ g)) (Mf : Monotone f),\n  f (inf·µ¢ fun (i : Œπ) ‚Ü¶ g i) = inf·µ¢ fun (i : Œπ) ‚Ü¶ f (g i)","name":"Monotone.map_inf·µ¢_of_continuousAt'","isProp":true,"docString":"A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed\ninfimum to the indexed infimum of the composition. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R ‚Üí+* S} {f' : R' ‚Üí+* S'} {g : R ‚Üí+* R'} {g' : S ‚Üí+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq : Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I) :=\n    ((le_of_eq\n          ((_root_.trans\n                ((Ideal.comap_comap f\n                      g'=:Ideal.comap f (Ideal.comap g' I) =\n                      Ideal.comap (RingHom.comp g' f)\n                        I)=:Ideal.comap f (Ideal.comap g' I) = Ideal.comap (RingHom.comp g' f) I)\n                ((Eq.rec\n                      ((Ideal.comap_comap g\n                            f'=:Ideal.comap g (Ideal.comap f' I) =\n                            Ideal.comap (RingHom.comp f' g)\n                              I)=:Ideal.comap g (Ideal.comap f' I) = Ideal.comap (RingHom.comp f' g) I)\n                      hfg=:Ideal.comap (RingHom.comp g' f) I =\n                      Ideal.comap g\n                        (Ideal.comap f'\n                          I))=:Ideal.comap (RingHom.comp g' f) I =\n                    Ideal.comap g\n                      (Ideal.comap f'\n                        I))=:Ideal.comap f (Ideal.comap g' I) =\n                Ideal.comap g\n                  (Ideal.comap f'\n                    I))=:Ideal.comap f (Ideal.comap g' I) =\n              Ideal.comap g\n                (Ideal.comap f'\n                  I))=:Ideal.comap f (Ideal.comap g' I) ‚â§\n          Ideal.comap g (Ideal.comap f' I))=:Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap g (Ideal.comap f' I));\n  (RingHom.comp\n        (Ideal.quotientMap I g' ((le_rfl=:Ideal.comap g' I ‚â§ Ideal.comap g' I)=:Ideal.comap g' I ‚â§ Ideal.comap g' I))\n        (Ideal.quotientMap (Ideal.comap g' I) f\n          ((le_rfl=:Ideal.comap f (Ideal.comap g' I) ‚â§\n                Ideal.comap f\n                  (Ideal.comap g' I))=:Ideal.comap f (Ideal.comap g' I) ‚â§ Ideal.comap f (Ideal.comap g' I))) =\n      RingHom.comp\n        (Ideal.quotientMap I f' ((le_rfl=:Ideal.comap f' I ‚â§ Ideal.comap f' I)=:Ideal.comap f' I ‚â§ Ideal.comap f' I))\n        (Ideal.quotientMap (Ideal.comap f' I) g leq) :\n    Prop)","name":"Ideal.comp_quotientMap_eq_of_comp_eq","isProp":true,"docString":"Commutativity of a square is preserved when taking quotients by an ideal. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] (t : Multiset Œπ) (f‚ÇÅ : (a : Œπ) ‚Üí Set Œ±) (f‚ÇÇ : (a : Œπ) ‚Üí Set Œ±)\n  (hf : ‚àÄ (i : Œπ) (a : i ‚àà t), f‚ÇÅ i ‚äÜ f‚ÇÇ i), Multiset.prod (Multiset.map f‚ÇÅ t) ‚äÜ Multiset.prod (Multiset.map f‚ÇÇ t)","name":"Set.multiset_prod_subset_multiset_prod","isProp":true,"docString":"An n-ary version of `Set.mul_subset_mul`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (F : D ‚•§ C)\n  (Y : D), Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y ‚àà CategoryTheory.Functor.essImage F","name":"CategoryTheory.Functor.obj_mem_essImage","isProp":true,"docString":"An object in the image is in the essential image. "},{"type":"‚àÄ {Œ≥ : Type u_1} [inst : NonUnitalNonAssocSemiring Œ≥] (x : Œ≥), IsAddMonoidHom fun (y : Œ≥) ‚Ü¶ y * x","name":"IsAddMonoidHom.isAddMonoidHom_mul_right","isProp":true,"docString":"Right multiplication in a ring is an additive monoid morphism. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (n : ‚Ñï) (a : Œ±),\n  CanonicallyLinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a =\n    a * CanonicallyLinearOrderedSemifield.zpow (Int.ofNat n) a","name":"CanonicallyLinearOrderedSemifield.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ (G : Type u) [inst : CommSemigroup G] [inst_1 : IsRightCancelMul G], IsLeftCancelMul G","name":"CommSemigroup.IsRightCancelMul.toIsLeftCancelMul","isProp":true,"docString":"Any `CommSemigroup G` that satisfies `IsRightCancelMul G` also satisfies\n`IsLeftCancelMul G`. "},{"type":"‚àÄ {Œ± : Type u} [inst : StrictOrderedSemiring Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} [inst_1 : ExistsAddOfLE Œ±] (hab : a ‚â§ b)\n  (hcd : c ‚â§ d), a * d + b * c ‚â§ a * c + b * d","name":"mul_add_mul_le_mul_add_mul","isProp":true,"docString":"Binary **rearrangement inequality**. "},{"type":"‚àÄ {R : Type u} {œÉ : Type u_1} [inst : CommSemiring R] {M : (a : MvPolynomial œÉ R) ‚Üí Prop} (p : MvPolynomial œÉ R)\n  (h_C : ‚àÄ (a : R), M (‚ÜëMvPolynomial.C a))\n  (h_add_weak :\n    ‚àÄ (a : œÉ ‚Üí‚ÇÄ ‚Ñï) (b : R) (f : (œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Üí‚ÇÄ R) (a_1 : ¬¨(a ‚àà Finsupp.support f : Prop)) (a_2 : b ‚â† 0) (a_3 : M f)\n      (a_4 : M (‚Üë(MvPolynomial.monomial a) b)),\n      M\n        ((let_fun this : (œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Üí‚ÇÄ R := ‚Üë(MvPolynomial.monomial a) b;\n          this) +\n          f))\n  (h_X : ‚àÄ (p : MvPolynomial œÉ R) (n : œÉ) (a : M p), M (p * MvPolynomial.X n)), M p","name":"MvPolynomial.induction_on''","isProp":true,"docString":"Similar to `MvPolynomial.induction_on` but only a yet weaker form of `h_add` is required."},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\n  {s : Set Œπ} (h : Basis (‚Üës) K V) (hs : Set.Finite s), FiniteDimensional K V","name":"FiniteDimensional.of_finite_basis","isProp":true,"docString":"If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] ‚¶Éf : ZeroHom M N‚¶Ñ ‚¶Ég : ZeroHom M N‚¶Ñ (h : ‚Üëf = ‚Üëg),\n  f = g","name":"ZeroHom.coe_inj","isProp":true,"docString":"Deprecated: use `FunLike.coe_injective` instead."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (s : Set Œ≤)\n  (hs : Set.Nontrivial (f ‚Åª¬π' s)), Set.Nontrivial s","name":"Set.nontrivial_of_preimage","isProp":true,"docString":"If the preimage of a set under an injective map is nontrivial, the set is nontrivial. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (v : M) {r : R} (h : 0 < r), SameRay R (r ‚Ä¢ v) v","name":"SameRay.sameRay_pos_smul_left","isProp":true,"docString":"A positive multiple of a vector is in the same ray as that vector. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] [inst_1 : SubtractionMonoid H] (h : G ‚âÉ+ H) (x : G) (y : G),\n  ‚Üëh (x - y) = ‚Üëh x - ‚Üëh y","name":"AddEquiv.map_sub","isProp":true,"docString":"An additive equivalence of additive groups preserves subtractions."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±} {b : Œ±} (a_1 : b ‚â§ a), ‚ÜëOrderDual.toDual a ‚â§ ‚ÜëOrderDual.toDual b","name":"LE.le.dual","isProp":true,"docString":"**Alias** of the reverse direction of `OrderDual.toDual_le_toDual`."},{"type":"‚àÄ {R‚ÇÅ : Type u_3} {R‚ÇÇ : Type u_4} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_2}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_1} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ] [inst_8 : T2Space M‚ÇÇ] {s : Set M‚ÇÅ}\n  (hs : Dense ‚Üë(Submodule.span R‚ÇÅ s)) {f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} {g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : Set.EqOn (‚Üëf) (‚Üëg) s), f = g","name":"ContinuousLinearMap.ext_on","isProp":true,"docString":"If the submodule generated by a set `s` is dense in the ambient module, then two continuous\nlinear maps equal on `s` are equal. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {a : Œ±} {s : Set Œ±} {b : Set (Set Œ±)}\n  (hb : TopologicalSpace.IsTopologicalBasis b),\n  (s ‚àà nhds a : Prop) ‚Üî (‚àÉ (t : Set Œ±), (t ‚àà b : Prop) ‚àß ((a ‚àà t : Prop) ‚àß (t ‚äÜ s : Prop) : Prop) : Prop)","name":"TopologicalSpace.IsTopologicalBasis.mem_nhds_iff","isProp":true,"docString":"A set `s` is in the neighbourhood of `a` iff there is some basis set `t`, which\ncontains `a` and is itself contained in `s`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {P : Type v} [inst_1 : AddCommMonoid P] [inst_2 : Module R P]\n  (huniv :\n    ‚àÄ (f : (P ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] P) (a : Function.Surjective ‚Üëf), ‚àÉ (h : P ‚Üí‚Çó[R] P ‚Üí‚ÇÄ R), LinearMap.comp f h = LinearMap.id),\n  Module.Projective R P","name":"Module.Projective.of_lifting_property''","isProp":true,"docString":"A module which satisfies the universal property is projective: If all surjections of\n`R`-modules `(P ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] P` have `R`-linear left inverse maps, then `P` is\nprojective. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {A : C} {B : C}\n  (f : A ‚ü∂ B) (F : C ‚•§ D) [inst_2 : CategoryTheory.IsIso (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)]\n  [inst_3 : CategoryTheory.ReflectsIsomorphisms F], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_reflects_iso","isProp":true,"docString":"If `F` reflects isos and `F.map f` is an iso, then `f` is an iso. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : TopologicalSpace ùïú] [inst_1 : CommRing ùïú]\n  [inst_2 : AddCommGroup E] [inst_3 : Module ùïú E] [inst_4 : AddCommGroup F] [inst_5 : Module ùïú F]\n  (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) [inst_6 : ContinuousAdd ùïú], TopologicalAddGroup (WeakBilin B)","name":"WeakBilin.instTopologicalAddGroup","isProp":true,"docString":"`WeakBilin B` is a `TopologicalAddGroup`, meaning that addition and negation are\ncontinuous. "},{"type":"‚àÄ {Œ± : Type u} [inst : MonoidWithZero Œ±] (x : Œ±) [inst_1 : Invertible x], Ring.inverse x = ‚Öüx","name":"Ring.inverse_invertible","isProp":true,"docString":"A variant of `Ring.inverse_unit`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasWidePullbacks C],\n  CategoryTheory.Limits.HasWidePullbacks C","name":"CategoryTheory.Limits.hasWidePullbacks_shrink","isProp":true,"docString":"If a category has wide pullbacks on a higher universe level it also has wide pullbacks\non a lower universe level. "},{"type":"failed to pretty print expression (use 'set_option pp.rawOnError true' for raw representation)","name":"padicValNat_def","isProp":true,"docString":"A simplification of `padicValNat` when one input is prime, by analogy with\n`padicValRat_def`. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R) {x : R} (a : x ‚àà s), -x ‚àà s","name":"Subring.neg_mem","isProp":true,"docString":"A subring is closed under negation. "},{"type":"‚àÄ {k : Type u_4} {V : Type u_5} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} {Œπ‚ÇÇ : Type u_1} (s‚ÇÇ : Finset Œπ‚ÇÇ) (e : Œπ‚ÇÇ ‚Ü™ Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.affineCombination k (Finset.map e s‚ÇÇ) p) w = ‚Üë(Finset.affineCombination k s‚ÇÇ (p ‚àò ‚Üëe)) (w ‚àò ‚Üëe)","name":"Finset.affineCombination_map","isProp":true,"docString":"An affine combination, over the image of an embedding, equals an\naffine combination with the same points and weights over the original\n`Finset`. "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {N : outParam (Type u_3)} [inst : AddZeroClass M] [inst_1 : AddZeroClass N]\n  [self : AddMonoidHomClass F M N] (f : F), ‚Üëf 0 = 0","name":"AddMonoidHomClass.map_zero","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ±) ‚Üí M} {s : Set Œ±}\n  (hf : Set.Finite (s ‚à© Function.support f)) (hg : Set.Finite (s ‚à© Function.support g)),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i + g i) =\n    (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ g i","name":"finsum_mem_add_distrib'","isProp":true,"docString":"A more general version of `finsum_mem_add_distrib` that only requires `s ‚à© support f`\nand `s ‚à© support g` rather than `s` to be finite."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop} (self : Concept Œ± Œ≤ r),\n  intentClosure r (Prod.fst (Concept.toProd self)) = Prod.snd (Concept.toProd self)","name":"Concept.closure_fst","isProp":true,"docString":"The axiom of a `Concept` stating that the closure of the first set is the second set. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] (f : (a : Œ±) ‚Üí M) {s : Finset Œ±} {t : Finset Œ±} (h : s ‚äÜ t),\n  (Finset.sum s fun (i : Œ±) ‚Ü¶ f i) = Finset.sum t fun (i : Œ±) ‚Ü¶ Set.indicator (‚Üës) f i","name":"Set.sum_indicator_subset","isProp":true,"docString":"Summing an indicator function over a possibly larger `Finset` is the same as summing\nthe original function over the original `finset`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type w}\n  [inst_1 : CategoryTheory.Category D] {K : Type z} [inst_2 : CategoryTheory.SmallCategory K]\n  [inst_3 : CategoryTheory.Limits.HasLimitsOfShape K D] (F : K ‚•§ CategoryTheory.Sheaf J D)\n  (E : CategoryTheory.Limits.Cone (F ‚ãô CategoryTheory.sheafToPresheaf J D)) (hE : CategoryTheory.Limits.IsLimit E),\n  CategoryTheory.Presheaf.IsSheaf J (CategoryTheory.Limits.Cone.pt E)","name":"CategoryTheory.Sheaf.isSheaf_of_isLimit","isProp":true,"docString":"If `E` is a cone which is a limit on the level of presheaves,\nthen the limit presheaf is again a sheaf.\n\nThis is used to show that the forgetful functor from sheaves to presheaves creates limits.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (p : (a : Œ±) ‚Üí Prop) (x : Œ±)\n  (H : Filter.Frequently (fun (R : ‚Ñù) ‚Ü¶ ‚àÄ (y : Œ±) (a : y ‚àà Metric.closedBall x R), p y) Filter.atTop) (y : Œ±), p y","name":"Metric.forall_of_forall_mem_closedBall","isProp":true,"docString":"If a property holds for all points in closed balls of arbitrarily large radii, then it holds for\nall points. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} (hq : q ‚â† 0), padicNorm p q ‚â† 0","name":"padicNorm.nonzero","isProp":true,"docString":"If `q ‚â† 0`, then `padicNorm p q ‚â† 0`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddMonoid Œ≤] [inst_1 : DecidableEq Œ±] {s : Finset Œ±} {t : Finset Œ±}\n  (h : Disjoint s t) (f : (a : Œ±) ‚Üí Œ≤)\n  (comm : Set.Pairwise (setOf fun (x : Œ±) ‚Ü¶ x ‚àà s ‚à™ t) fun (a : Œ±) (b : Œ±) ‚Ü¶ AddCommute (f a) (f b)),\n  Finset.noncommSum (s ‚à™ t) f comm =\n    Finset.noncommSum s f\n        ((Set.Pairwise.mono\n              ((Iff.mpr\n                    ((Finset.coe_subset=:(‚Üës ‚äÜ ‚Üë(s ‚à™ t) : Prop) ‚Üî\n                          (s ‚äÜ s ‚à™ t : Prop))=:(‚Üës ‚äÜ ‚Üë(s ‚à™ t) : Prop) ‚Üî (s ‚äÜ s ‚à™ t : Prop))\n                    ((Finset.subset_union_left s t=:s ‚äÜ s ‚à™ t)=:s ‚äÜ s ‚à™ t)=:‚Üës ‚äÜ ‚Üë(s ‚à™ t))=:‚Üës ‚äÜ ‚Üë(s ‚à™ t))\n              comm=:Set.Pairwise ‚Üës fun (a : Œ±) (b : Œ±) ‚Ü¶\n              AddCommute (f a) (f b))=:Set.Pairwise ‚Üës fun (a : Œ±) (b : Œ±) ‚Ü¶ AddCommute (f a) (f b)) +\n      Finset.noncommSum t f\n        ((Set.Pairwise.mono\n              ((Iff.mpr\n                    ((Finset.coe_subset=:(‚Üët ‚äÜ ‚Üë(s ‚à™ t) : Prop) ‚Üî\n                          (t ‚äÜ s ‚à™ t : Prop))=:(‚Üët ‚äÜ ‚Üë(s ‚à™ t) : Prop) ‚Üî (t ‚äÜ s ‚à™ t : Prop))\n                    ((Finset.subset_union_right s t=:t ‚äÜ s ‚à™ t)=:t ‚äÜ s ‚à™ t)=:‚Üët ‚äÜ ‚Üë(s ‚à™ t))=:‚Üët ‚äÜ ‚Üë(s ‚à™ t))\n              comm=:Set.Pairwise ‚Üët fun (a : Œ±) (b : Œ±) ‚Ü¶\n              AddCommute (f a) (f b))=:Set.Pairwise ‚Üët fun (a : Œ±) (b : Œ±) ‚Ü¶ AddCommute (f a) (f b))","name":"Finset.noncommSum_union_of_disjoint","isProp":true,"docString":"The non-commutative version of `finset.sum_union`"},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M}\n  (hs : IsClosed ‚Üës), Submodule.topologicalClosure s = s","name":"IsClosed.submodule_topologicalClosure_eq","isProp":true,"docString":"The topological closure of a closed submodule `s` is equal to `s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : StrictMonoOn f s), StrictMono (Set.restrict s f)","name":"StrictMonoOn.restrict","isProp":true,"docString":"**Alias** of the reverse direction of `strictMono_restrict`."},{"type":"‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : CommGroup Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (a : Œ±),\n  abs (abs a) = abs a","name":"LatticeOrderedCommGroup.mabs_mabs","isProp":true,"docString":"The unary operation of taking the absolute value is idempotent. "},{"type":"‚àÄ {Œπ : Type u_1} (R : Type u) [inst : Semiring R] (M : (a : Œπ) ‚Üí Type u_2) [inst_1 : Finite Œπ]\n  [inst_2 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_3 : (i : Œπ) ‚Üí Module R (M i)]\n  [inst_4 : ‚àÄ (i : Œπ), Module.Free R (M i)], Module.Free R ((i : Œπ) ‚Üí M i)","name":"Module.Free.pi","isProp":true,"docString":"The product of finitely many free modules is free. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasWideCoequalizer f] [inst_2 : Nonempty J] {W : C}\n  {k : CategoryTheory.Limits.wideCoequalizer f ‚ü∂ W} {l : CategoryTheory.Limits.wideCoequalizer f ‚ü∂ W}\n  (h : CategoryTheory.Limits.wideCoequalizer.œÄ f ‚â´ k = CategoryTheory.Limits.wideCoequalizer.œÄ f ‚â´ l), k = l","name":"CategoryTheory.Limits.wideCoequalizer.hom_ext","isProp":true,"docString":"Two maps from a wide coequalizer are equal if they are equal when composed with the wide\ncoequalizer map "},{"type":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±] [inst_1 : Finite Œ±] {P : (a : Equiv.Perm Œ±) ‚Üí Prop} (f : Equiv.Perm Œ±) (a : P 1)\n  (a : ‚àÄ (f : Equiv.Perm Œ±) (x : Œ±) (y : Œ±) (a : x ‚â† y) (a : P f), P (f * Equiv.swap x y)), P f","name":"Equiv.Perm.swap_induction_on'","isProp":true,"docString":"Like `swap_induction_on`, but with the composition on the right of `f`.\n\nAn induction principle for permutations. If `P` holds for the identity permutation, and\nis preserved under composition with a non-trivial swap, then `P` holds for all permutations. "},{"type":"‚àÄ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X} (hs : Metric.Bounded s)\n  {x : (a : ‚Ñï) ‚Üí X} (hx : Filter.Frequently (fun (n : ‚Ñï) ‚Ü¶ x n ‚àà s) Filter.atTop),\n  ‚àÉ (a : X),\n    (a ‚àà closure s : Prop) ‚àß\n      (‚àÉ (œÜ : (a : ‚Ñï) ‚Üí ‚Ñï), (StrictMono œÜ : Prop) ‚àß (Filter.Tendsto (x ‚àò œÜ) Filter.atTop (nhds a) : Prop) : Prop)","name":"tendsto_subseq_of_frequently_bounded","isProp":true,"docString":"A version of **Bolzano-Weistrass**: in a proper metric space (eg. $‚Ñù^n$),\nevery bounded sequence has a converging subsequence. This version assumes only\nthat the sequence is frequently in some bounded set. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] [inst_1 : OrderTop Œ±] {x : Œ±} {y : Œ±} {z : Œ±} (f : x ‚ü∂ z) (g : y ‚ü∂ z),\n  CategoryTheory.Limits.pullback f g = x ‚äì y","name":"CategoryTheory.Limits.CompleteLattice.pullback_eq_inf","isProp":true,"docString":"The pullback in the category of a `SemilatticeInf` with `OrderTop` is the same as the infimum\nover the objects.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : ‚àÄ (x : Œ±) (y : Œ±), f (x + y) = f x + f y), IsAddGroupHom f","name":"IsAddGroupHom.mk'","isProp":true,"docString":"Construct `IsAddGroupHom` from its only hypothesis."},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] [inst_3 : MulPosMono Œ±]\n  (ha : a ‚â§ 1) (hb : b < 1) (b0 : 0 ‚â§ b), a * b < 1","name":"Right.mul_lt_one_of_le_of_lt_of_nonneg","isProp":true,"docString":"Assumes right covariance. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (s : Set E),\n  EMetric.diam (‚Üë(ClosureOperator.toOrderHom (convexHull ‚Ñù)) s) = EMetric.diam s","name":"convexHull_ediam","isProp":true,"docString":"Emetric diameter of the convex hull of a set `s` equals the emetric diameter of `s. "},{"type":"‚àÄ {Œ± : Type u_1} {m : ‚Ñï} {n : ‚Ñï} (P : (a : Matrix (Fin m) (Fin n) Œ±) ‚Üí Prop),\n  (Matrix.Exists P : Prop) ‚Üî (‚àÉ (x : Matrix (Fin m) (Fin n) Œ±), P x : Prop)","name":"Matrix.exists_iff","isProp":true,"docString":"This can be use to prove\n```lean\nexample (P : Matrix (Fin 2) (Fin 3) Œ± ‚Üí Prop) :\n  (‚àÉ x, P x) ‚Üî ‚àÉ a b c d e f, P !![a, b, c; d, e, f] :=\n(exists_iff _).symm\n```\n"},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} (a_1 : a < 1),\n  1 < a‚Åª¬π","name":"one_lt_inv_of_inv","isProp":true,"docString":"**Alias** of the reverse direction of `Left.one_lt_inv_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] (a : Œ±), lcm 0 a = 0","name":"GCDMonoid.lcm_zero_left","isProp":true,"docString":"`0` is left-absorbing. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictAnti f) (hg : StrictAnti g), StrictAnti fun (x : Œ≤) ‚Ü¶ f x + g x","name":"StrictAnti.add","isProp":true,"docString":"The sum of two strictly antitone functions is strictly antitone."},{"type":"‚àÄ {Œ± : Type u} {C : (a : Set Œ±) ‚Üí Prop} {S : Set Œ±} (h : Set.Finite S) (H0 : C ‚àÖ)\n  (H1 : ‚àÄ {a : Œ±} {s : Set Œ±} (a_1 : a ‚àà S) (a_2 : s ‚äÜ S) (a_3 : ¬¨(a ‚àà s : Prop)) (a_4 : C s), C (insert a s)), C S","name":"Set.Finite.induction_on'","isProp":true,"docString":"Analogous to `Finset.induction_on'`. "},{"type":"‚àÄ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty (LowerSet.carrier (Order.Ideal.toLowerSet self))","name":"Order.Ideal.nonempty'","isProp":true,"docString":"The ideal is nonempty. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {a : Œ±} {b : Œ±} (hab : a ‚â† b), closure (Set.Ico a b) = Set.Icc a b","name":"closure_Ico","isProp":true,"docString":"The closure of the interval `[a, b)` is the closed interval `[a, b]`. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : CommMonoid Œ≤] {n : ‚Ñï} (f : (a : Fin (n + 1)) ‚Üí Œ≤),\n  (Finset.prod Finset.univ fun (i : Fin (n + 1)) ‚Ü¶ f i) = f 0 * Finset.prod Finset.univ fun (i : Fin n) ‚Ü¶ f (Fin.succ i)","name":"Fin.prod_univ_succ","isProp":true,"docString":"A product of a function `f : Fin (n + 1) ‚Üí Œ≤` over all `Fin (n + 1)`\nis the product of `f 0` plus the remaining product "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace E] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ùïú E] {s : Set E},\n  (StrictConvex ùïú s : Prop) ‚Üî\n    (Set.Pairwise s fun (x : E) (y : E) ‚Ü¶\n        ‚àÄ ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 < a) (a_2 : 0 < b), (a / (a + b)) ‚Ä¢ x + (b / (a + b)) ‚Ä¢ y ‚àà interior s :\n      Prop)","name":"strictConvex_iff_div","isProp":true,"docString":"Alternative definition of set strict convexity, using division. "},{"type":"‚àÄ {Œ± : Type u_3} {F : Type u_4} {E' : Type u_2} {ùïú : Type u_1} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E']\n  [inst_2 : NormedField ùïú] {g : (a : Œ±) ‚Üí F} {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} [inst_3 : NormedSpace ùïú E'] {c : ùïú}\n  (hc : c ‚â† 0) (a : f' =Œò[l] g), (fun (x : Œ±) ‚Ü¶ c ‚Ä¢ f' x) =Œò[l] g","name":"Asymptotics.IsTheta.const_smul_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isTheta_const_smul_left`."},{"type":"‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a : B} {b : B}\n  (f : a ‚ü∂ b),\n  CategoryTheory.Bicategory.rightUnitor f =\n    CategoryTheory.eqToIso ((CategoryTheory.Bicategory.Strict.comp_id f=:f ‚â´ ùüô b = f)=:f ‚â´ ùüô b = f)","name":"CategoryTheory.Bicategory.Strict.rightUnitor_eqToIso","isProp":true,"docString":"The right unitors are given by equalities "},{"type":"‚àÄ {p : ‚Ñï} (q : ‚Ñö), padicNorm p (-q) = padicNorm p q","name":"padicNorm.neg","isProp":true,"docString":"`padicNorm p` is symmetric. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} {m : ‚Ñï} {n : ‚Ñï} (hmn : m ‚â§ n) {d : (a : ‚Ñï) ‚Üí ‚Ñù}\n  (hd : ‚àÄ {k : ‚Ñï} (a : m ‚â§ k) (a : k < n), dist (f k) (f (k + 1)) ‚â§ d k),\n  dist (f m) (f n) ‚â§ Finset.sum (Finset.Ico m n) fun (i : ‚Ñï) ‚Ü¶ d i","name":"dist_le_Ico_sum_of_dist_le","isProp":true,"docString":"A version of `dist_le_Ico_sum_dist` with each intermediate distance replaced\nwith an upper estimate. "},{"type":"‚àÄ {M : Type u} [self : Monoid M] (a : M), 1 * a = a","name":"Monoid.one_mul","isProp":true,"docString":"One is a left neutral element for multiplication "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_2} {N : Type u_4} {R : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : AddCommMonoid N] [inst_4 : Module R N] ‚¶ÉœÜ : (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] N‚¶Ñ ‚¶Éœà : (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] N‚¶Ñ\n  (h : ‚àÄ (a : Œ±) (b : M), ‚ÜëœÜ (Finsupp.single a b) = ‚Üëœà (Finsupp.single a b)), œÜ = œà","name":"Finsupp.lhom_ext","isProp":true,"docString":"Two `R`-linear maps from `Finsupp X M` which agree on each `single x y` agree everywhere. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : NNReal}, EMetric.ball x ‚ÜëŒµ = Metric.ball x ‚ÜëŒµ","name":"Metric.emetric_ball_nnreal","isProp":true,"docString":"Balls defined using the distance or the edistance coincide "},{"type":"‚àÄ (R : Type u_1) (M : Type u_2) [inst : Semiring R] [inst_1 : Nontrivial M] [inst_2 : AddCommMonoid M]\n  [inst : Module R M], Nontrivial R","name":"Module.nontrivial","isProp":true,"docString":"A semiring is `Nontrivial` provided that there exists a nontrivial module over this semiring. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b) (a_2 : a ‚â† b), a < b","name":"LE.le.lt_of_ne","isProp":true,"docString":"**Alias** of `lt_of_le_of_ne`."},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  {I : Ideal S} (b : Basis Œπ R { x : S // x ‚àà I }) {x : S},\n  (x ‚àà I : Prop) ‚Üî (‚àÉ (c : Œπ ‚Üí‚ÇÄ R), x = Finsupp.sum c fun (i : Œπ) (x : R) ‚Ü¶ x ‚Ä¢ ‚Üë(‚Üëb i) : Prop)","name":"Basis.mem_ideal_iff","isProp":true,"docString":"If `I : Ideal S` has a basis over `R`,\n`x ‚àà I` iff it is a linear combination of basis vectors. "},{"type":"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {r : ‚Ñù} (hr : 0 ‚â§ r),\n  r ‚Ä¢ Metric.closedBall 0 1 = Metric.closedBall 0 r","name":"smul_closedUnitBall_of_nonneg","isProp":true,"docString":"In a real normed space, the image of the unit closed ball under multiplication by a nonnegative\nnumber `r` is the closed ball of radius `r` with center at the origin. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hf : ContinuousOn f s)\n  (hsc : IsClosed s) {x‚ÇÄ : Œ≤} (h‚ÇÄ : x‚ÇÄ ‚àà s)\n  (hc : Filter.Eventually (fun (x : Œ≤) ‚Ü¶ f x‚ÇÄ ‚â§ f x) (Filter.cocompact Œ≤ ‚äì Filter.principal s)),\n  ‚àÉ (x : Œ≤), (x ‚àà s : Prop) ‚àß (‚àÄ (y : Œ≤) (a : y ‚àà s), f x ‚â§ f y : Prop)","name":"ContinuousOn.exists_forall_le'","isProp":true,"docString":"The **extreme value theorem**: if a function `f` is continuous on a closed set `s` and it is\nlarger than a value in its image away from compact sets, then it has a minimum on this set. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {x : Œ±} [inst_1 : TopologicalSpace Œ±]\n  (hx : x ‚àà s)\n  (L :\n    ‚àÄ (u : Set (Œ≤ √ó Œ≤)) (a : u ‚àà uniformity Œ≤),\n      ‚àÉ (t : Set Œ±),\n        (t ‚àà nhdsWithin x s : Prop) ‚àß\n          (‚àÉ (F : (a : Œ±) ‚Üí Œ≤), (ContinuousWithinAt F s x : Prop) ‚àß (‚àÄ (y : Œ±) (a : y ‚àà t), (f y, F y) ‚àà u : Prop) :\n            Prop)),\n  ContinuousWithinAt f s x","name":"continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt","isProp":true,"docString":"A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. "},{"type":"‚àÄ (R : Type u_1) (S : Type u_2) (M : Type u_3) [inst : Semiring S] [inst_1 : AddCommMonoid M] [inst_2 : CommSemiring R]\n  [inst_3 : Algebra R S] [inst_4 : Module S M], IsScalarTower R S (RestrictScalars R S M)","name":"RestrictScalars.isScalarTower","isProp":true,"docString":"This instance is only relevant when `RestrictScalars.moduleOrig` is available as an instance.\n"},{"type":"‚àÄ {Œì : Type u_1} [inst : Inhabited Œì] (l : Turing.ListBlank Œì),\n  Turing.ListBlank.cons (Turing.ListBlank.head l) (Turing.ListBlank.tail l) = l","name":"Turing.ListBlank.cons_head_tail","isProp":true,"docString":"The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `List` where\nthis only holds for nonempty lists. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] [inst_1 : ProperSpace Œ±] (x : Œ±) (r : ‚Ñù), IsCompact (Metric.sphere x r)","name":"isCompact_sphere","isProp":true,"docString":"In a proper pseudometric space, all spheres are compact. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  (t : CategoryTheory.Limits.Cofork f g) [inst_1 : CategoryTheory.Mono (CategoryTheory.Limits.Cofork.œÄ t)], f = g","name":"CategoryTheory.Limits.eq_of_mono_cofork_œÄ","isProp":true,"docString":"Two morphisms are equal if there is a cofork whose projection is mono. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a ‚â§ b‚Åª¬π), b ‚â§ a‚Åª¬π","name":"le_inv_of_le_inv","isProp":true,"docString":"**Alias** of the forward direction of `le_inv'`."},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] [inst_1 : Preorder M] (L : List M) (h : 1 < List.prod L), 0 < List.length L","name":"List.length_pos_of_one_lt_prod","isProp":true,"docString":"A list with product greater than one must have positive length. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {M : Type u_2} [inst_1 : AddMonoid M] {f : G ‚Üí+ M} {g : G ‚Üí+ M} {s : Set G}\n  (h : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(AddSubgroup.closure s)","name":"AddMonoidHom.eqOn_closure","isProp":true,"docString":"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup\nclosure."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {t : Œ±} {ts : List Œ±} {ys : List Œ±} {r : List Œ≤} (f : (a : List Œ±) ‚Üí Œ≤),\n  Prod.snd (List.permutationsAux2 t [] r ys fun (x : List Œ±) ‚Ü¶ f (x ++ ts)) =\n    Prod.snd (List.permutationsAux2 t ts r ys f)","name":"List.permutationsAux2_comp_append","isProp":true,"docString":"The `ts` argument to `permutationsAux2` can be folded into the `f` argument. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {Œº : (a : M) ‚Üí (a : N) ‚Üí N} {Œ± : Type u_3} [inst : Preorder Œ±] [inst_1 : Preorder N]\n  {f : (a : N) ‚Üí Œ±} [inst_2 : CovariantClass M N Œº fun (x : N) (x_1 : N) ‚Ü¶ x ‚â§ x_1] (hf : Antitone f) (m : M),\n  Antitone fun (n : N) ‚Ü¶ f (Œº m n)","name":"Antitone.covariant_of_const","isProp":true,"docString":"Dual of `Monotone.covariant_of_const` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {t : Set Œ±} {x : Œ±}\n  {Œ¶ : (a : Œ±) ‚Üí Œ≤} (hŒ¶ : Isometry Œ¶), Metric.infDist (Œ¶ x) (Œ¶ '' t) = Metric.infDist x t","name":"Metric.infDist_image","isProp":true,"docString":"The infimum distance is invariant under isometries "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} (F : Type u_3) [inst : Norm E] [inst_1 : Norm F] {f : (a : Œ±) ‚Üí E} {l : Filter Œ±}\n  [inst_2 : One F] [inst_3 : NormOneClass F]\n  (a : Filter.IsBoundedUnder (fun (x : ‚Ñù) (x_1 : ‚Ñù) ‚Ü¶ x ‚â§ x_1) l fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ), f =O[l] fun (_x : Œ±) ‚Ü¶ 1","name":"Filter.IsBoundedUnder.isBigO_one","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigO_one_iff`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (s : Set Œ±), UniformContinuous fun (x : Œ±) ‚Ü¶ Metric.infDist x s","name":"Metric.uniformContinuous_infDist_pt","isProp":true,"docString":"The minimal distance to a set is uniformly continuous in point "},{"type":"‚àÄ {n : ‚Ñï} {a : Fin (n + 2)} {b : Fin (n + 1)} (ha : a ‚â† 0) (hb : b ‚â† 0)\n  (hk :\n    optParam (‚Üë(Fin.succAbove a) b ‚â† 0 : Prop)\n      ((Fin.succAbove_ne_zero ha hb=:‚Üë(Fin.succAbove a) b ‚â† 0)=:‚Üë(Fin.succAbove a) b ‚â† 0)),\n  ‚Üë(Fin.succAbove (Fin.pred a ha)) (Fin.pred b hb) = Fin.pred (‚Üë(Fin.succAbove a) b) hk","name":"Fin.pred_succAbove_pred","isProp":true,"docString":"`pred` commutes with `succAbove`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±} {r : ENNReal},\n  (EMetric.infEdist x s < r : Prop) ‚Üî (‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (edist x y < r : Prop) : Prop)","name":"EMetric.infEdist_lt_iff","isProp":true,"docString":"The edist to a set is `< r` iff there exists a point in the set at edistance `< r` "},{"type":"IsSimpleGroup { x : Equiv.Perm (Fin 5) // x ‚àà alternatingGroup (Fin 5) }","name":"alternatingGroup.isSimpleGroup_five","isProp":true,"docString":"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] {ùíú : Finset (Finset Œ±)}\n  (hùíú : IsAntichain (fun (x : Finset Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚äÜ x_1) ‚Üëùíú),\n  Finset.card ùíú ‚â§ Nat.choose (Fintype.card Œ±) (Fintype.card Œ± / 2)","name":"Finset.IsAntichain.sperner","isProp":true,"docString":"**Sperner's theorem**. The size of an antichain in `Finset Œ±` is bounded by the size of the\nmaximal layer in `Finset Œ±`. This precisely means that `Finset Œ±` is a Sperner order. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : LipschitzWith K f), UniformContinuous f","name":"LipschitzWith.uniformContinuous","isProp":true,"docString":"A Lipschitz function is uniformly continuous "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Antivary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (Antivary (f ‚àò ‚ÜëœÉ) g : Prop)","name":"Antivary.sum_mul_eq_sum_comp_perm_mul_iff","isProp":true,"docString":"**Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together, is unchanged by a permutation if and only if `f ‚àò œÉ` and `g` antivary\ntogether. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {s : Set Œ≤} (a : IsCompact s) (a : Set.Nonempty s)\n  {f : (a : Œ≤) ‚Üí Œ±} (a : ContinuousOn f s), ‚àÉ (x : Œ≤), (x ‚àà s : Prop) ‚àß (‚àÄ (y : Œ≤) (a : y ‚àà s), f y ‚â§ f x : Prop)","name":"IsCompact.exists_forall_ge","isProp":true,"docString":"The **extreme value theorem**: a continuous function realizes its maximum on a compact set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalRing Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚à£ c), (a ‚à£ b + c : Prop) ‚Üî (a ‚à£ b : Prop)","name":"dvd_add_left","isProp":true,"docString":"If an element `a` divides another element `c` in a ring, `a` divides the sum of another element\n`b` with `c` iff `a` divides `b`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Type u_1} [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] {A : (a : Œπ) ‚Üí Submodule R M} {i : Œπ} {j : Œπ} (hij : i ‚â† j) (h : Set.univ = {i, j})\n  (hi : DirectSum.IsInternal A), IsCompl (A i) (A j)","name":"DirectSum.IsInternal.isCompl","isProp":true,"docString":"When indexed by only two distinct elements, `DirectSum.IsInternal` implies\nthe two submodules are complementary. Over a `Ring R`, this is true as an iff, as\n`DirectSum.isInternal_submodule_iff_isCompl`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : AddGroup Œ±] [inst_2 : UniformAddGroup Œ±]\n  {hom : Type u_1} [inst_3 : UniformSpace Œ≤] [inst_4 : AddGroup Œ≤] [inst_5 : UniformAddGroup Œ≤]\n  [inst_6 : AddMonoidHomClass hom Œ± Œ≤] (f : hom) (hf : ContinuousAt (‚Üëf) 0), UniformContinuous ‚Üëf","name":"uniformContinuous_of_continuousAt_zero","isProp":true,"docString":"An additive group homomorphism (a bundled morphism of a type that implements\n`AddMonoidHomClass`) between two uniform additive groups is uniformly continuous provided that it\nis continuous at zero. See also `continuous_of_continuousAt_zero`."},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E} (h : Convex ‚Ñù s), IsPreconnected s","name":"Convex.isPreconnected","isProp":true,"docString":"A convex set is preconnected. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {K : Type u‚ÇÅ} [inst_1 : CategoryTheory.Category K]\n  [inst_2 : CategoryTheory.IsPreconnected J] (e : J ‚âå K), CategoryTheory.IsPreconnected K","name":"CategoryTheory.isPreconnected_of_equivalent","isProp":true,"docString":"If `J` and `K` are equivalent, then if `J` is preconnected then `K` is as well. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {n : ‚Ñï}\n  (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚àà t) (ht : Finset.Nonempty t) (hn : Finset.card t * n ‚â§ Finset.card s),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (n ‚â§ Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) : Prop)","name":"Finset.exists_le_card_fiber_of_mul_le_card_of_maps_to","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by heads: given a function between\nfinite sets `s` and `t` and a natural number `b` such that `card t * n ‚â§ card s`, there exists\n`y ‚àà t` such that its preimage in `s` has at least `n` elements. See also\n`Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to` for a stronger statement. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {C : Set Œ±} (hC : Perfect C) (hnonempty : Set.Nonempty C)\n  [inst_1 : CompleteSpace Œ±],\n  ‚àÉ (f : (a : (a : ‚Ñï) ‚Üí Bool) ‚Üí Œ±),\n    (Set.range f ‚äÜ C : Prop) ‚àß ((Continuous f : Prop) ‚àß (Function.Injective f : Prop) : Prop)","name":"Perfect.exists_nat_bool_injection","isProp":true,"docString":"Any nonempty perfect set in a complete metric space admits a continuous injection\nfrom the Cantor space, `‚Ñï ‚Üí Bool`. "},{"type":"‚àÄ {R : Type u_2} {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_5} {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [inst : CommSemiring R]\n  [inst_1 : CommSemiring R‚ÇÅ] [inst_2 : AddCommMonoid M‚ÇÅ] [inst_3 : Module R‚ÇÅ M‚ÇÅ] [inst_4 : CommSemiring R‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÇ M‚ÇÇ] {I‚ÇÅ : R‚ÇÅ ‚Üí+* R} {I‚ÇÇ : R‚ÇÇ ‚Üí+* R} {B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÇ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R},\n  (LinearMap.SeparatingLeft B : Prop) ‚Üî (LinearMap.ker B = ‚ä• : Prop)","name":"LinearMap.separatingLeft_iff_ker_eq_bot","isProp":true,"docString":"A bilinear form is left-separating if and only if it has a trivial kernel. "},{"type":"‚àÄ {S : Type u_1} [inst : Add S] {a : S} {b : S} (h : AddCommute a b), AddCommute b a","name":"AddCommute.symm","isProp":true,"docString":"If `a` commutes with `b`, then `b` commutes with `a`."},{"type":"‚àÄ {Œπ : Type u_1} {M : Type u_2} [inst : TopologicalSpace M] [inst_1 : Mul M] [inst_2 : ContinuousMul M],\n  ContinuousMul ((a : Œπ) ‚Üí M)","name":"Pi.continuousMul'","isProp":true,"docString":"A version of `pi.continuousMul` for non-dependent functions. It is needed because sometimes\nLean 3 fails to use `pi.continuousMul` for non-dependent functions. "},{"type":"‚àÄ {m : ‚Ñï+} {n : ‚Ñï+}, (PNat.factorMultiset m ‚â§ PNat.factorMultiset n : Prop) ‚Üî (m ‚à£ n : Prop)","name":"PNat.factorMultiset_le_iff","isProp":true,"docString":"We now have four different results that all encode the\nidea that inequality of multisets corresponds to divisibility\nof positive integers. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : ClosedEmbedding f) {K : Set Œ≤} (hK : IsCompact K), IsCompact (f ‚Åª¬π' K)","name":"ClosedEmbedding.isCompact_preimage","isProp":true,"docString":"The preimage of a compact set under a closed embedding is a compact set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {a : Œ±} {b : Œ±} {u : Œ±À£}, (a * ‚Üëu ‚à£ b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"Units.mul_right_dvd","isProp":true,"docString":"In a monoid, an element `a` divides an element `b` iff all associates of `a` divide `b`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±) (y : Œ±) (z : Œ±), nndist x z ‚â§ nndist x y + nndist y z","name":"nndist_triangle","isProp":true,"docString":"Triangle inequality for the nonnegative distance"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] {b : CategoryTheory.Limits.BinaryBicone X Y}\n  (h : CategoryTheory.Limits.BinaryBicone.IsBilimit b),\n  CategoryTheory.BicartesianSq 0 0 (CategoryTheory.Limits.BinaryBicone.inl b) (CategoryTheory.Limits.BinaryBicone.inr b)","name":"CategoryTheory.BicartesianSq.of_is_biproduct‚ÇÇ","isProp":true,"docString":"```\n   0 -----0---> X\n   |            |\n   0           inl\n   |            |\n   v            v\n   Y --inr--> X ‚äû Y\n```\nis a bicartesian square.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} (h : 0 ‚â§ a),\n  -a ‚â§ a","name":"neg_le_self","isProp":true,"docString":"**Alias** of `Left.neg_le_self`."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} (v : V) {p : P} (hp : p ‚àà s),\n  (v +·µ• p ‚àà s : Prop) ‚Üî (v ‚àà AffineSubspace.direction s : Prop)","name":"AffineSubspace.vadd_mem_iff_mem_direction","isProp":true,"docString":"Adding a vector to a point in a subspace produces a point in the subspace if and only if the\nvector is in the direction. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_2} {Œ≤ : Type u_1} (f : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ≤) (b : Œ≤) (v : Vector Œ± n),\n  Vector.head (Vector.scanl f b v) = b","name":"Vector.scanl_head","isProp":true,"docString":"The first element of `scanl` of a vector `v : Vector Œ± n`,\nretrieved via `head`, is the starting value `b : Œ≤`.\n"},{"type":"‚àÄ {P : (a : EReal) ‚Üí (a : EReal) ‚Üí Prop} (neg_left : ‚àÄ {x : EReal} {y : EReal} (a : P x y), P (-x) y) (top_top : P ‚ä§ ‚ä§)\n  (top_pos : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚ä§ ‚Üëx) (top_zero : P ‚ä§ 0) (top_neg : ‚àÄ (x : ‚Ñù) (a : x < 0), P ‚ä§ ‚Üëx)\n  (top_bot : P ‚ä§ ‚ä•) (zero_top : P 0 ‚ä§) (zero_bot : P 0 ‚ä•) (pos_top : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚Üëx ‚ä§)\n  (pos_bot : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚Üëx ‚ä•) (coe_coe : ‚àÄ (x : ‚Ñù) (y : ‚Ñù), P ‚Üëx ‚Üëy) (x : EReal) (y : EReal), P x y","name":"EReal.induction‚ÇÇ_neg_left","isProp":true,"docString":"Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that `P x y` implies `P (-x) y` for all\n`x`, `y`. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {v‚ÇÅ : RayVector R M} {v‚ÇÇ : RayVector R M}, (v‚ÇÅ ‚âà v‚ÇÇ : Prop) ‚Üî (SameRay R ‚Üëv‚ÇÅ ‚Üëv‚ÇÇ : Prop)","name":"equiv_iff_sameRay","isProp":true,"docString":"Equivalence of nonzero vectors, in terms of `SameRay`. "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\n  [self : RingHomSurjective œÉ], Function.Surjective ‚ÜëœÉ","name":"RingHomSurjective.is_surjective","isProp":true,"docString":"The ring homomorphism is surjective "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {Œ≤ : Type u_1} {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {f : (a : Œ≤) ‚Üí Œ±}\n  (hf : Pairwise fun (x : Œ≤) (y : Œ≤) ‚Ü¶ Œµ ‚â§ dist (f x) (f y)), UniformEmbedding f","name":"Metric.uniformEmbedding_bot_of_pairwise_le_dist","isProp":true,"docString":"If `f : Œ≤ ‚Üí Œ±` sends any two distinct points to points at distance at least `Œµ > 0`, then\n`f` is a uniform embedding with respect to the discrete uniformity on `Œ≤`. "},{"type":"‚àÄ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R} (ab : IsRightRegular (b * a)), IsRightRegular b","name":"IsRightRegular.of_mul","isProp":true,"docString":"If an element `b` becomes right-regular after multiplying it on the right by a right-regular\nelement, then `b` is right-regular. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±]\n  (h : Function.Periodic f c) (hc : 0 < c) (x : Œ±), ‚àÉ (y : Œ±), (y ‚àà Set.Ico 0 c : Prop) ‚àß (f x = f y : Prop)","name":"Function.Periodic.exists_mem_Ico‚ÇÄ","isProp":true,"docString":"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ‚àà Ico 0 c` such that `f x = f y`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {R' : Type u_2} [inst_1 : Monoid R'] {M : Type u_3} {N : Type u_4}\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : DistribMulAction R' M] [inst_7 : SMulCommClass R R' M] {R'‚ÇÇ : Type u_5} [inst_8 : Monoid R'‚ÇÇ]\n  [inst_9 : DistribMulAction R'‚ÇÇ M] [inst_10 : SMulCommClass R R'‚ÇÇ M] [inst_11 : SMul R'‚ÇÇ R']\n  [inst_12 : DistribMulAction R'‚ÇÇ N] [inst_13 : DistribMulAction R' N]\n  [inst_14 : TensorProduct.CompatibleSMul R R'‚ÇÇ M N] [inst_15 : TensorProduct.CompatibleSMul R R' M N]\n  [inst_16 : IsScalarTower R'‚ÇÇ R' N], IsScalarTower R'‚ÇÇ R' (TensorProduct R M N)","name":"TensorProduct.isScalarTower_right","isProp":true,"docString":"`IsScalarTower R'‚ÇÇ R' N` implies `IsScalarTower R'‚ÇÇ R' (M ‚äó[R] N)` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}\n  (h :\n    ‚àÄ {Œπ : Type u} (Z : (a : Œπ) ‚Üí Set Œ±) (a : ‚àÄ (i : Œπ), IsClosed (Z i)) (a : (s ‚à© Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Z i) = ‚àÖ),\n      ‚àÉ (t : Finset Œπ), (s ‚à© Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà t) ‚Ü¶ Z i) = ‚àÖ),\n  IsCompact s","name":"isCompact_of_finite_subfamily_closed","isProp":true,"docString":"A set `s` is compact if for every family of closed sets whose intersection avoids `s`,\nthere exists a finite subfamily whose intersection avoids `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±}\n  {b : Œ±}, a + b - a ‚â§ b","name":"add_tsub_le_left","isProp":true,"docString":"See `add_tsub_cancel_left` for the equality if `ContravariantClass Œ± Œ± (+) (‚â§)`. "},{"type":"‚àÄ {n : ‚Ñï} [inst : NeZero n] {i : Fin n} (h : 0 < i), 0 < ‚ÜëFin.castSucc i","name":"Fin.castSucc_pos","isProp":true,"docString":"`castSucc i` is positive when `i` is positive "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type uu} [inst : Preorder Œ±] {f : (a : Fin n) ‚Üí Œ±},\n  (List.Sorted (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1) (List.ofFn f) : Prop) ‚Üî (StrictMono f : Prop)","name":"List.sorted_lt_ofFn_iff","isProp":true,"docString":"The list `List.ofFn f` is strictly sorted with respect to `(¬∑ ‚â§ ¬∑)` if and only if `f` is\nstrictly monotone. "},{"type":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±] (p : (a : Œ±) ‚Üí Bool) (l : List Œ±),\n  List.sum (List.map (fun (x : Œ±) ‚Ü¶ List.count x l) (List.filter p (List.dedup l))) = List.countp p l","name":"List.sum_map_count_dedup_filter_eq_countp","isProp":true,"docString":"Summing the count of `x` over a list filtered by some `p` is just `countp` applied to `p` "},{"type":"‚àÄ {K : Type u_1} {K‚Çò : Type u_2} [inst : Field K] [inst_1 : CommRing K‚Çò] {M : Submonoid K} (hM : ¬¨(0 ‚àà M : Prop))\n  [inst_2 : Algebra K K‚Çò] [inst_3 : IsLocalization M K‚Çò], Function.Bijective ‚Üë(algebraMap K K‚Çò)","name":"Field.localization_map_bijective","isProp":true,"docString":"If `R` is a field, then localizing at a submonoid not containing `0` adds no new elements. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : DiscreteTopology ‚Üës] {x : Œ±} (hx : x ‚àà s),\n  ‚àÉ (Œµ : ‚Ñù), (Œµ > 0 : Prop) ‚àß (Metric.closedBall x Œµ ‚à© s = {x} : Prop)","name":"Metric.exists_closedBall_inter_eq_singleton_of_discrete","isProp":true,"docString":"Given a point `x` in a discrete subset `s` of a pseudometric space, there is a closed ball\nof positive radius centered at `x` and intersecting `s` only at `x`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {B : Finset (Finset Œ±)} {n : ‚Ñï} [inst_1 : Fintype Œ±]\n  (h : ‚àÄ (a : Œ±), Finset.card (Finset.filter ((fun (x : Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚àà x_1) a) B) ‚â§ n),\n  (Finset.sum B fun (s : Finset Œ±) ‚Ü¶ Finset.card s) ‚â§ Fintype.card Œ± * n","name":"Finset.sum_card_le","isProp":true,"docString":"If every element belongs to at most `n` Finsets, then the sum of their sizes is at most `n`\ntimes how many they are. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLinearOrder Œ±] {b : Œ±} [inst_1 : Nonempty Œπ]\n  {f : (a : Œπ) ‚Üí Œ±} (h : b < sup·µ¢ f), ‚àÉ (i : Œπ), b < f i","name":"exists_lt_of_lt_csup·µ¢","isProp":true,"docString":"Indexed version of the above lemma `exists_lt_of_lt_csup‚Çõ`.\nWhen `b < sup·µ¢ f`, there is an element `i` such that `b < f i`.\n"},{"type":"‚àÄ {Œ± : Type u} [self : NonAssocSemiring Œ±] (a : Œ±), a * 1 = a","name":"NonAssocSemiring.mul_one","isProp":true,"docString":"One is a right neutral element for multiplication "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} (hf : CategoryTheory.SplitEpi f)\n  [inst_1 : CategoryTheory.Epi (CategoryTheory.SplitEpi.section_ hf)], CategoryTheory.IsIso f","name":"CategoryTheory.IsIso.of_epi_section'","isProp":true,"docString":"Every split epi whose section is epi is an iso. "},{"type":"‚àÄ (Œ± : Type u) (Œ≤ : Type v) [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] [inst_2 : Fintype Œ±]\n  [inst_3 : (a : Œ±) ‚Üí Fintype ‚Üë(MulAction.fixedBy Œ± Œ≤ a)] [inst_4 : Fintype (Quotient (MulAction.orbitRel Œ± Œ≤))],\n  (Finset.sum Finset.univ fun (a : Œ±) ‚Ü¶ Fintype.card ‚Üë(MulAction.fixedBy Œ± Œ≤ a)) =\n    Fintype.card (Quotient (MulAction.orbitRel Œ± Œ≤)) * Fintype.card Œ±","name":"MulAction.sum_card_fixedBy_eq_card_orbits_mul_card_group","isProp":true,"docString":"**Burnside's lemma** : given a finite group `G` acting on a set `X`, the average number of\nelements fixed by each `g ‚àà G` is the number of orbits. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] (s : Multiset R) {k : ‚Ñï} (h : k ‚â§ ‚ÜëMultiset.card s),\n  Polynomial.coeff (Multiset.prod (Multiset.map (fun (r : R) ‚Ü¶ Polynomial.X + ‚ÜëPolynomial.C r) s)) k =\n    Multiset.esymm s (‚ÜëMultiset.card s - k)","name":"Multiset.prod_X_add_C_coeff","isProp":true,"docString":"Vieta's formula for the coefficients of the product of linear terms `X + Œª` where `Œª` runs\nthrough a multiset `s` : the `k`th coefficient is the symmetric function `esymm (card s - k) s`. "},{"type":"‚àÄ {S : Type u_1} {R : outParam (Type u_2)} {M : Type u_3} [inst : VAdd R M] [inst_1 : SetLike S M]\n  [self : VAddMemClass S R M] {s : S} (r : R) {m : M} (a : m ‚àà s), r +·µ• m ‚àà s","name":"VAddMemClass.vadd_mem","isProp":true,"docString":"Addition by a scalar with an element of the set remains in the set. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul ùïú E] (x : E), Bornology.IsVonNBounded ùïú {x}","name":"Bornology.isVonNBounded_singleton","isProp":true,"docString":"Singletons are bounded. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : LocallyFiniteOrderBot Œ±] (b : Œ±),\n  Finset.Iic b =\n    Finset.cons b (Finset.Iio b) ((Finset.not_mem_Iio_self=:¬¨(b ‚àà Finset.Iio b : Prop))=:¬¨(b ‚àà Finset.Iio b : Prop))","name":"Finset.Iic_eq_cons_Iio","isProp":true,"docString":"`Finset.cons` version of `Finset.Iio_insert`. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œ±} {b : Set Œπ} {c : (a : Œπ) ‚Üí Set Œ±}\n  (hs : IsCompact s) (hc‚ÇÅ : ‚àÄ (i : Œπ) (a : i ‚àà b), IsOpen (c i))\n  (hc‚ÇÇ : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà b) ‚Ü¶ c i),\n  ‚àÉ (b' : Set Œπ),\n    (b' ‚äÜ b : Prop) ‚àß\n      ((Set.Finite b' : Prop) ‚àß (s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà b') ‚Ü¶ c i : Prop) : Prop)","name":"IsCompact.elim_finite_subcover_image","isProp":true,"docString":"For every open cover of a compact set, there exists a finite subcover. "},{"type":"‚àÄ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : NormedField K] {B : ‚Ñù} {d : ‚Ñï} (f : F ‚Üí+* K)\n  {p : Polynomial F} (h1 : Polynomial.Monic p) (h2 : Polynomial.Splits f p) (h3 : Polynomial.natDegree p ‚â§ d)\n  (h4 : ‚àÄ (z : K) (a : z ‚àà Polynomial.roots (Polynomial.map f p)), ‚Äñz‚Äñ ‚â§ B) (i : ‚Ñï),\n  ‚ÄñPolynomial.coeff (Polynomial.map f p) i‚Äñ ‚â§ max B 1 ^ d * ‚Üë(Nat.choose d (d / 2))","name":"Polynomial.coeff_bdd_of_roots_le","isProp":true,"docString":"The coefficients of the monic polynomials of bounded degree with bounded roots are\nuniformely bounded. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : Zero Œ±] [inst_1 : One Œ±] (n : ‚Ñï),\n  (Matrix.circulant fun (i : Fin n) ‚Ü¶ if (‚Üëi = 0 : Prop) then 1 else 0) = 1","name":"Matrix.Fin.circulant_ite","isProp":true,"docString":"Note we use `‚Üëi = 0` instead of `i = 0` as `Fin 0` has no `0`.\nThis means that we cannot state this with `Pi.single` as we did with `Matrix.circulant_single`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P : C} {Q : C} (f : P ‚ü∂ Q),\n  CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f)","name":"CategoryTheory.Abelian.instEpiImageToHasZeroMorphismsNonPreadditiveAbelianHas_kernelsHas_cokernelsFactorThruImage","isProp":true,"docString":"The map `p : P ‚ü∂ image f` is an epimorphism "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b), (a < b : Prop) ‚à® (b = a : Prop)","name":"LE.le.gt_or_eq","isProp":true,"docString":"**Alias** of `gt_or_eq_of_le`."},{"type":"Function.RightInverse Nat.cast ‚ÜëCardinal.toNat","name":"Cardinal.toNat_rightInverse","isProp":true,"docString":"`toNat` has a right-inverse: coercion. "},{"type":"‚àÄ {K : Type u} {V : Type v} {V' : Type v'} {V'‚ÇÅ : Type v'} [inst : Ring K] [inst_1 : AddCommGroup V]\n  [inst_2 : Module K V] [inst_3 : AddCommGroup V'] [inst_4 : Module K V'] [inst_5 : AddCommGroup V'‚ÇÅ]\n  [inst_6 : Module K V'‚ÇÅ] (g : V ‚Üí‚Çó[K] V') (f : V' ‚Üí‚Çó[K] V'‚ÇÅ),\n  LinearMap.rank (LinearMap.comp f g) ‚â§ min (LinearMap.rank f) (LinearMap.rank g)","name":"LinearMap.rank_comp_le","isProp":true,"docString":"The rank of the composition of two maps is less than the minimum of their ranks.\n\nSee `lift_rank_comp_le` for the universe-polymorphic version. "},{"type":"‚àÄ {R : Type u} {Œπ : Type v} {M‚ÇÅ : (a : Œπ) ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] [inst_5 : (i : Œπ) ‚Üí TopologicalSpace (M‚ÇÅ i)] [inst_6 : TopologicalSpace M‚ÇÇ]\n  (f : ContinuousMultilinearMap R M‚ÇÅ M‚ÇÇ) [inst_7 : DecidableEq Œπ] [inst_8 : Fintype Œπ] (m : (i : Œπ) ‚Üí M‚ÇÅ i)\n  (m' : (i : Œπ) ‚Üí M‚ÇÅ i), ‚Üëf (m + m') = Finset.sum Finset.univ fun (s : Finset Œπ) ‚Ü¶ ‚Üëf (Finset.piecewise s m m')","name":"ContinuousMultilinearMap.map_add_univ","isProp":true,"docString":"Additivity of a continuous multilinear map along all coordinates at the same time,\nwriting `f (m + m')` as the sum  of `f (s.piecewise m m')` over all sets `s`. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {n : ‚Ñï} (f : AlternatingMap R M N (Fin (Nat.succ n)))\n  (m : (a : Fin n) ‚Üí M) (x : M) (y : M),\n  ‚Üëf (Matrix.vecCons (x + y) m) = ‚Üëf (Matrix.vecCons x m) + ‚Üëf (Matrix.vecCons y m)","name":"AlternatingMap.map_vecCons_add","isProp":true,"docString":"A version of `MultilinearMap.cons_add` for `AlternatingMap`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {s : (a : Œπ) ‚Üí Set Œ±} {t : Set Œ±} (i : Œπ) (h : s i ‚äÜ t),\n  (Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ s i) ‚äÜ t","name":"Set.inter·µ¢_subset_of_subset","isProp":true,"docString":"This rather trivial consequence of `inter·µ¢_subset`is convenient with `apply`, and has `i`\nexplicit for this purpose. "},{"type":"‚àÄ {A : Type u_1} {Œπ : Type u_2} [inst : Ring A] {B : (a : Œπ) ‚Üí AddSubgroup A} (self : RingSubgroupsBasis B) (i : Œπ),\n  ‚àÉ (j : Œπ), ‚Üë(B j) * ‚Üë(B j) ‚äÜ ‚Üë(B i)","name":"RingSubgroupsBasis.mul","isProp":true,"docString":"For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\nthat the set-theoretic product `B' * B'` is in `B`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (hs : Set.Nonempty s) (a : Set.Countable s), ‚àÉ (f : (a : ‚Ñï) ‚Üí ‚Üës), Function.Surjective f","name":"Set.Countable.exists_surjective","isProp":true,"docString":"**Alias** of the forward direction of `Set.countable_iff_exists_surjective`."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : Norm E] {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù}\n  (a : f =o[l] fun (x : Œ±) ‚Ü¶ abs (u x)), f =o[l] u","name":"Asymptotics.IsLittleO.of_abs_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_abs_right`."},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {d : AddCon M} (H : AddCon.toSetoid c = AddCon.toSetoid d), c = d","name":"AddCon.toSetoid_inj","isProp":true,"docString":"The map sending an additive congruence relation to its underlying equivalence\nrelation is injective."},{"type":"‚àÄ (H : Type u_1) [inst : TopologicalSpace H] (G : StructureGroupoid H), HasGroupoid H G","name":"hasGroupoid_model_space","isProp":true,"docString":"The trivial charted space structure on the model space is compatible with any groupoid. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 : AffineSubspace k P} {s2 : AffineSubspace k P}\n  (hd : AffineSubspace.direction s1 = AffineSubspace.direction s2) (hn : Set.Nonempty (‚Üës1 ‚à© ‚Üës2)), s1 = s2","name":"AffineSubspace.ext_of_direction_eq","isProp":true,"docString":"Two affine subspaces with the same direction and nonempty intersection are equal. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  (h : IsUnit (Matrix.det A)), Matrix.mul A A‚Åª¬π = 1","name":"Matrix.mul_nonsing_inv","isProp":true,"docString":"The `nonsing_inv` of `A` is a right inverse. "},{"type":"‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] {x : F} {y : F} (hx : x ‚â† 0) (hy : y ‚â† 0)\n  (a : SameRay ‚Ñù x y), ‚Äñx‚Äñ‚Åª¬π ‚Ä¢ x = ‚Äñy‚Äñ‚Åª¬π ‚Ä¢ y","name":"SameRay.inv_norm_smul_eq","isProp":true,"docString":"**Alias** of the forward direction of `sameRay_iff_inv_norm_smul_eq_of_ne`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Preadditive C] (P : C) (Q : C) (R : C)\n  (f : P ‚ü∂ Q) (f' : P ‚ü∂ Q) (g : Q ‚ü∂ R), (f + f') ‚â´ g = f ‚â´ g + f' ‚â´ g","name":"CategoryTheory.Preadditive.add_comp","isProp":true,"docString":"A category is called preadditive if `P ‚ü∂ Q` is an abelian group such that composition is\nlinear in both variables. "},{"type":"‚àÄ {a : Prop} (a_1 : ¬¨(¬¨(¬¨(a : Prop) : Prop) : Prop)), ¬¨(a : Prop)","name":"not_of_not_not_not","isProp":true,"docString":"**Alias** of the forward direction of `not_not_not`."},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} (x : M) (y : M), ‚Üë(x + y) = ‚Üëx + ‚Üëy","name":"AddCon.coe_add","isProp":true,"docString":"The coercion to the quotient of an additive congruence relation\ncommutes with addition (by definition)."},{"type":"‚àÄ {c : Cardinal} (h : Cardinal.aleph0 ‚â§ c), c + c = c","name":"Cardinal.add_eq_self","isProp":true,"docString":"If `Œ±` is an infinite type, then `Œ± ‚äï Œ±` and `Œ±` have the same cardinality. "},{"type":"‚àÄ {Œπ : Type u} {X : Type v} [inst : TopologicalSpace X] [inst_1 : ParacompactSpace X] (u : (a : Œπ) ‚Üí Set X)\n  (uo : ‚àÄ (a : Œπ), IsOpen (u a)) (uc : (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ u i) = Set.univ),\n  ‚àÉ (v : (a : Œπ) ‚Üí Set X),\n    (‚àÄ (a : Œπ), IsOpen (v a) : Prop) ‚àß\n      (((Set.union·µ¢ fun (i : Œπ) ‚Ü¶ v i) = Set.univ : Prop) ‚àß\n          ((LocallyFinite v : Prop) ‚àß (‚àÄ (a : Œπ), v a ‚äÜ u a : Prop) : Prop) :\n        Prop)","name":"precise_refinement","isProp":true,"docString":"Any open cover of a paracompact space has a locally finite *precise* refinement, that is,\none indexed on the same type with each open set contained in the corresponding original one. "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {Œ¥ : Type u_1} [inst_4 : LinearOrder Œ¥] [inst_5 : TopologicalSpace Œ¥]\n  [inst_6 : OrderClosedTopology Œ¥] {s : Set Œ±} [hs : Set.OrdConnected s] {f : (a : Œ±) ‚Üí Œ¥} (hf : ContinuousOn f s)\n  {a : Œ±} {b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s), Set.SurjOn f s (Set.Icc (f a) (f b))","name":"ContinuousOn.surjOn_Icc","isProp":true,"docString":"**Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `Icc (f x) (f y)`. "},{"type":"‚àÄ (R : Type u_2) {M : Type u_3} (S : Type u_1) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (s : Set M) [inst_3 : Semiring S] [inst_4 : SMul R S] [inst_5 : Module S M] [inst_6 : IsScalarTower R S M],\n  Submodule.span R s ‚â§ Submodule.restrictScalars R (Submodule.span S s)","name":"Submodule.span_le_restrictScalars","isProp":true,"docString":"If `R` is \"smaller\" ring than `S` then the span by `R` is smaller than the span by `S`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y}\n  (self : CategoryTheory.Limits.MonoFactorisation f),\n  CategoryTheory.Limits.MonoFactorisation.e self ‚â´ CategoryTheory.Limits.MonoFactorisation.m self = f","name":"CategoryTheory.Limits.MonoFactorisation.fac","isProp":true,"docString":"A factorisation of a morphism `f = e ‚â´ m`, with `m` monic. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} {y : Œ±} (h : y ‚àà s), Metric.infDist x s ‚â§ dist x y","name":"Metric.infDist_le_dist_of_mem","isProp":true,"docString":"The minimal distance to a set is bounded by the distance to any point in this set "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±} (hs : BddAbove s) (sne : Set.Nonempty s),\n  sup‚Çõ (insert a s) = a ‚äî sup‚Çõ s","name":"csup‚Çõ_insert","isProp":true,"docString":"The supremum of `insert a s` is the maximum of `a` and the supremum of `s`, if `s` is\nnonempty and bounded above."},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedField R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {x : M}\n  {y : M} (h : SameRay R x y) (hy : y ‚â† 0), ‚àÉ (r : R), (0 ‚â§ r : Prop) ‚àß (x = r ‚Ä¢ y : Prop)","name":"SameRay.exists_nonneg_right","isProp":true,"docString":"If a vector `v‚ÇÅ` is on the same ray as a nonzero vector `v‚ÇÇ`, then it is equal to `c ‚Ä¢ v‚ÇÇ` for\nsome nonnegative `c`. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  OmegaCompletePartialOrder.Continuous' SetLike.coe","name":"Submodule.coe_scott_continuous","isProp":true,"docString":"We can regard `coe_sup·µ¢_of_chain` as the statement that `(‚Üë) : (Submodule R M) ‚Üí Set M` is\nScott continuous for the œâ-complete partial order induced by the complete lattice structures. "},{"type":"‚àÄ {Œ± : Type u} [inst : Monoid Œ±] [inst_1 : HasDistribNeg Œ±] (u : Œ±À£), ‚Üë(-u) = -‚Üëu","name":"Units.val_neg","isProp":true,"docString":"Representing an element of a ring's unit group as an element of the ring commutes with\nmapping this element to its additive inverse. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ} {p' : Filter Œ±} (hF : TendstoUniformlyOnFilter F f p p'), UniformCauchySeqOnFilter F p p'","name":"TendstoUniformlyOnFilter.uniformCauchySeqOnFilter","isProp":true,"docString":"A sequence that converges uniformly is also uniformly Cauchy "},{"type":"‚àÄ {C : Type u_4} {D : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {G : C ‚•§ D}\n  {F : D ‚•§ C} {A : C} {B : C} {X : D} {Y : D} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\n  {u : A ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X}\n  {v : B ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y}\n  (sq : CategoryTheory.CommSq u i (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) p) v) (adj : G ‚ä£ F),\n  CategoryTheory.CommSq (‚Üë(Equiv.symm (CategoryTheory.Adjunction.homEquiv adj A X)) u)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) i) p\n    (‚Üë(Equiv.symm (CategoryTheory.Adjunction.homEquiv adj B Y)) v)","name":"CategoryTheory.CommSq.left_adjoint","isProp":true,"docString":"When we have an adjunction `G ‚ä£ F`, any commutative square where the left\nmap is of the form `i` and the right map is `F.map p` has an \"adjoint\" commutative\nsquare whose left map is `G.map i` and whose right map is `p`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] (s : Multiset R),\n  Multiset.prod (Multiset.map (fun (r : R) ‚Ü¶ Polynomial.X + ‚ÜëPolynomial.C r) s) =\n    Finset.sum (Finset.range (‚ÜëMultiset.card s + 1)) fun (j : ‚Ñï) ‚Ü¶\n      ‚ÜëPolynomial.C (Multiset.esymm s j) * Polynomial.X ^ (‚ÜëMultiset.card s - j)","name":"Multiset.prod_X_add_C_eq_sum_esymm","isProp":true,"docString":"A sum version of Vieta's formula for `Multiset`: the product of the linear terms `X + Œª` where\n`Œª` runs through a multiset `s` is equal to a linear combination of the symmetric functions\n`esymm s` of the `Œª`'s ."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : UniqueFactorizationMonoid Œ±] {Œ≤ : Type u_2}\n  [inst_2 : CancelCommMonoidWithZero Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (s : Finset Œ±) (i : (a : Œ±) ‚Üí ‚Ñï) (j : (a : Œ±) ‚Üí ‚Ñï)\n  (is_prime : ‚àÄ (p : Œ±) (a : p ‚àà s), Prime p)\n  (is_coprime : ‚àÄ (p : Œ±) (x : p ‚àà s) (q : Œ±) (x : q ‚àà s) (a : p ‚à£ q), p = q)\n  (h1 : ‚àÄ {x : Œ±} {y : Œ±} (a : IsUnit y), f (x * y) = f x * f y)\n  (hpr : ‚àÄ {p : Œ±} (i : ‚Ñï) (a : Prime p), f (p ^ i) = f p ^ i)\n  (hcp : ‚àÄ {x : Œ±} {y : Œ±} (a : ‚àÄ (p : Œ±) (a : p ‚à£ x) (a : p ‚à£ y), IsUnit p), f (x * y) = f x * f y),\n  f (Finset.prod s fun (p : Œ±) ‚Ü¶ p ^ (i p + j p)) =\n    f (Finset.prod s fun (p : Œ±) ‚Ü¶ p ^ i p) * f (Finset.prod s fun (p : Œ±) ‚Ü¶ p ^ j p)","name":"UniqueFactorizationMonoid.multiplicative_prime_power","isProp":true,"docString":"If `f` maps `p ^ i` to `(f p) ^ i` for primes `p`, and `f`\nis multiplicative on coprime elements, then `f` is multiplicative on all products of primes. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±], IsAddGroupHom id","name":"IsAddGroupHom.id","isProp":true,"docString":"The identity is an additive group homomorphism."},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedHeytingAlgebra Œ±] {a : Œ±} {b : Œ±}, (a ‚á® b = ‚ä§ : Prop) ‚Üî (a ‚â§ b : Prop)","name":"himp_eq_top_iff","isProp":true,"docString":"The **deduction theorem** in the Heyting algebra model of intuitionistic logic:\nan implication holds iff the conclusion follows from the hypothesis. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] (a : Œ±), Filter.atBot = Filter.comap Subtype.val Filter.atBot","name":"Filter.atBot_Iic_eq","isProp":true,"docString":"The `atBot` filter for an open interval `Iic a` comes from the `atBot` filter in the ambient\norder. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : a ‚â§ 1) (hb : b < 1), a * b < 1","name":"Left.mul_lt_one_of_le_of_lt","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one_of_le_of_lt`. "},{"type":"‚àÄ {A : Type u_1} {Œπ : Type u_2} [inst : Ring A] {B : (a : Œπ) ‚Üí AddSubgroup A} (self : RingSubgroupsBasis B) (x : A)\n  (i : Œπ), ‚àÉ (j : Œπ), ‚Üë(B j) ‚äÜ (fun (x_1 : A) ‚Ü¶ x_1 * x) ‚Åª¬π' ‚Üë(B i)","name":"RingSubgroupsBasis.rightMul","isProp":true,"docString":"For any element `x : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `x * B'` is in `B`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex k P n) (i : Fin (n + 1)),\n  Affine.Simplex.face s ((Finset.card_singleton i=:Finset.card {i} = 1)=:Finset.card {i} = 1) =\n    Affine.Simplex.mkOfPoint k (Affine.Simplex.points s i)","name":"Affine.Simplex.face_eq_mkOfPoint","isProp":true,"docString":"A single-point face equals the 0-simplex constructed with\n`mkOfPoint`. "},{"type":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±] (i : Œ±) (j : Œ±) (œÉ : Equiv.Perm Œ±), œÉ * Equiv.swap i j * Equiv.swap i j = œÉ","name":"Equiv.mul_swap_mul_self","isProp":true,"docString":"Right-multiplying a permutation with `swap i j` twice gives the original permutation.\n\nThis specialization of `swap_mul_self` is useful when using cosets of permutations.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedCoheytingAlgebra Œ±] (a : Œ±) (b : Œ±), a ‚äî b \\ a = a ‚äî b","name":"sup_sdiff_self_right","isProp":true,"docString":"**Alias** of `sup_sdiff_self`."},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocSemiring Œ±] (a : Œ±), 0 * a = 0","name":"NonUnitalNonAssocSemiring.zero_mul","isProp":true,"docString":"Zero is a left absorbing element for multiplication "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} {p : (a : Œπ) ‚Üí P} (ha : AffineIndependent k fun (x : ‚Üë(Set.range p)) ‚Ü¶ ‚Üëx)\n  (hi : Function.Injective p), AffineIndependent k p","name":"AffineIndependent.of_set_of_injective","isProp":true,"docString":"If the range of an injective indexed family of points is affinely\nindependent, so is that family. "},{"type":"‚àÄ {L : outParam FirstOrder.Language} {F : Type u_3} {M : outParam (Type u_4)} {N : outParam (Type u_5)}\n  [inst : FunLike F M fun (x : M) ‚Ü¶ N] [inst_1 : FirstOrder.Language.Structure L M]\n  [inst_2 : FirstOrder.Language.Structure L N] [self : FirstOrder.Language.StrongHomClass L F M N] (œÜ : F) {n : ‚Ñï}\n  (r : FirstOrder.Language.Relations L n) (x : (a : Fin n) ‚Üí M),\n  (FirstOrder.Language.Structure.rel_map r (‚ÜëœÜ ‚àò x) : Prop) ‚Üî (FirstOrder.Language.Structure.rel_map r x : Prop)","name":"FirstOrder.Language.StrongHomClass.map_rel","isProp":true,"docString":"The homomorphism sends related elements to related elements "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±},\n  Metric.hausdorffDist s (closure t) = Metric.hausdorffDist s t","name":"Metric.hausdorffDist_closure‚ÇÇ","isProp":true,"docString":"Replacing a set by its closure does not change the Hausdorff distance. "},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel (SimpleGraph.Adj G)] (k : ‚Ñï)\n  (h : ‚àÄ (v : V), SimpleGraph.degree G v ‚â§ k), SimpleGraph.maxDegree G ‚â§ k","name":"SimpleGraph.maxDegree_le_of_forall_degree_le","isProp":true,"docString":"In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum\ndegree. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] (H : Subgroup G)\n  (h_1_int : 1 ‚àà interior ‚ÜëH), IsOpen ‚ÜëH","name":"Subgroup.isOpen_of_one_mem_interior","isProp":true,"docString":"If a subgroup of a topological group has `1` in its interior, then it is open. "},{"type":"‚àÄ {Œ± : Type u_1} {t : Set Œ±} (s : Finset ‚Üët), ‚Üë(Finset.map (Function.Embedding.subtype fun (x : Œ±) ‚Ü¶ x ‚àà t) s) ‚äÜ t","name":"Finset.map_subtype_subset","isProp":true,"docString":"If a `Finset` of a subtype is converted to the main type with\n`Embedding.subtype`, the result is a subset of the set giving the\nsubtype. "},{"type":"‚àÄ {R : Type u_1} [inst : DivisionRing R] (n : ‚Ñï), ‚Üë(-‚Üën) = -‚Üën","name":"Int.cast_neg_natCast","isProp":true,"docString":"Auxiliary lemma for norm_cast to move the cast `-‚Üën` upwards to `‚Üë-‚Üën`.\n\n(The restriction to `DivisionRing` is necessary, otherwise this would also apply in the case where\n`R = ‚Ñ§` and cause nontermination.)\n"},{"type":"‚àÄ {f : (a : Bool) ‚Üí (a : Bool) ‚Üí Bool} (hf : ‚àÄ (b : Bool) (b' : Bool), f b b' = f b' b) (hf' : f false false = false)\n  (n : ‚Ñï) (m : ‚Ñï), Nat.bitwise' f n m = Nat.bitwise' f m n","name":"Nat.bitwise'_comm","isProp":true,"docString":"If `f` is a commutative operation on bools such that `f false false = false`, then `bitwise f`\nis also commutative. "},{"type":"‚àÄ {R : Type u} [inst : Rack R] {a : Rack.PreEnvelGroup R} {b : Rack.PreEnvelGroup R}\n  (a_1 : Rack.PreEnvelGroupRel' R a b), Rack.PreEnvelGroupRel R a b","name":"Rack.PreEnvelGroupRel'.rel","isProp":true,"docString":"A quick way to convert a `PreEnvelGroupRel'` to a `PreEnvelGroupRel`.\n"},{"type":"‚àÄ {R : Type v} [inst : CommRing R] {A : Matrix (Fin 0) (Fin 0) R}, Matrix.det A = 1","name":"Matrix.det_fin_zero","isProp":true,"docString":"Determinant of 0x0 matrix "},{"type":"‚àÄ {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {Œπ : Type u_1}\n  {p : (a : Œπ) ‚Üí Submodule R M} {m : M},\n  (m ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i : Prop) ‚Üî (‚àÉ (s : Finset Œπ), m ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ sup·µ¢ fun (h : i ‚àà s) ‚Ü¶ p i : Prop)","name":"Submodule.mem_sup·µ¢_iff_exists_finset","isProp":true,"docString":"`Submodule.exists_finset_of_mem_sup·µ¢` as an `iff` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (inf‚Çõ s)) (Af : Antitone f)\n  (ne : Set.Nonempty s) (H : BddBelow s), f (inf‚Çõ s) = sup‚Çõ (f '' s)","name":"Antitone.map_cinf‚Çõ_of_continuousAt","isProp":true,"docString":"If an antitone function is continuous at the infimum of a nonempty bounded below set `s`,\nthen it sends this infimum to the supremum of the image of `s`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C] {W : C} {X : C}\n  {Y : C} {Z : C} (f : X ‚ü∂ Y) (g : Z ‚ü∂ W),\n  CategoryTheory.Limits.prod.map f g ‚â´ CategoryTheory.Iso.hom (CategoryTheory.Limits.prod.braiding Y W) =\n    CategoryTheory.Iso.hom (CategoryTheory.Limits.prod.braiding X Z) ‚â´ CategoryTheory.Limits.prod.map g f","name":"CategoryTheory.Limits.braid_natural","isProp":true,"docString":"The braiding isomorphism can be passed through a map by swapping the order. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] {m : Multiset Œ±} (h : ‚àÄ (x : Œ±) (a : x ‚àà m), x = 1), Multiset.prod m = 1","name":"Multiset.prod_eq_one","isProp":true,"docString":"Slightly more general version of `Multiset.prod_eq_one_iff` for a non-ordered `Monoid` "},{"type":"‚àÄ (R‚ÇÅ : Type u_2) {A : Type u_1} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : Algebra R‚ÇÅ A] (I : Ideal A),\n  RingHom.ker ‚Üë(Ideal.Quotient.mk‚Çê R‚ÇÅ I) = I","name":"Ideal.Quotient.mk‚Çê_ker","isProp":true,"docString":"The kernel of `A ‚Üí‚Çê[R‚ÇÅ] I.quotient` is `I`. "},{"type":"‚àÄ {Œπ : Type u_5} {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R]\n  [inst_1 : Semiring R‚ÇÇ] [inst_2 : AddCommMonoid M] [inst_3 : Module R M] [inst_4 : AddCommMonoid M‚ÇÇ]\n  [inst_5 : Module R‚ÇÇ M‚ÇÇ] [inst_6 : TopologicalSpace M] [inst_7 : TopologicalSpace M‚ÇÇ] {œÉ : R ‚Üí+* R‚ÇÇ} {f : (a : Œπ) ‚Üí M}\n  (œÜ : M ‚ÜíSL[œÉ] M‚ÇÇ) (hf : Summable f), Summable fun (b : Œπ) ‚Ü¶ ‚ÜëœÜ (f b)","name":"Summable.mapL","isProp":true,"docString":"**Alias** of `ContinuousLinearMap.summable`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] {x : Œ±} (f : Equiv.Perm Œ±),\n  (Equiv.Perm.IsCycle (Equiv.Perm.cycleOf f x) : Prop) ‚Üî (‚Üëf x ‚â† x : Prop)","name":"Equiv.Perm.isCycle_cycleOf_iff","isProp":true,"docString":"`x` is in the support of `f` iff `Equiv.Perm.cycle_of f x` is a cycle. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {a : Œ±} {s : Set Œ±} (f : (a : Œ±) ‚Üí M) (h : ¬¨(a ‚àà s : Prop))\n  (hs : Set.Finite s),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà insert a s) ‚Ü¶ f i) =\n    f a * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i","name":"finprod_mem_insert","isProp":true,"docString":"Given a finite set `s` and an element `a ‚àâ s`, the product of `f i` over `i ‚àà insert a s` equals\n`f a` times the product of `f i` over `i ‚àà s`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] {b : CategoryTheory.Limits.BinaryBicone X Y}\n  (h : CategoryTheory.Limits.BinaryBicone.IsBilimit b),\n  CategoryTheory.BicartesianSq (CategoryTheory.Limits.BinaryBicone.fst b) (CategoryTheory.Limits.BinaryBicone.snd b) 0 0","name":"CategoryTheory.BicartesianSq.of_is_biproduct‚ÇÅ","isProp":true,"docString":"```\n X ‚äû Y --fst--> X\n   |            |\n  snd           0\n   |            |\n   v            v\n   Y -----0---> 0\n```\nis a bicartesian square.\n"},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {x : P} {s : Set P} {p : (a : P) ‚Üí Prop} (h : x ‚àà affineSpan k s)\n  (Hs : ‚àÄ (x : P) (a : x ‚àà s), p x)\n  (Hc : ‚àÄ (c : k) (u : P) (v : P) (w : P) (a : p u) (a : p v) (a : p w), p (c ‚Ä¢ (u -·µ• v) +·µ• w)), p x","name":"affineSpan_induction","isProp":true,"docString":"An induction principle for span membership. If `p` holds for all elements of `s` and is\npreserved under certain affine combinations, then `p` holds for all elements of the span of `s`. "},{"type":"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  (TotallyDisconnectedSpace H : Prop) ‚Üî (TotallySeparatedSpace H : Prop)","name":"loc_compact_t2_tot_disc_iff_tot_sep","isProp":true,"docString":"A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {a : R} (ua : IsUnit a), IsRegular a","name":"IsUnit.isRegular","isProp":true,"docString":"A unit in a monoid is regular. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {Œ∫ : (a : Œπ) ‚Üí Sort u_3} {s : (i : Œπ) ‚Üí (a : Œ∫ i) ‚Üí Set Œ±} {t : Set Œ±} (i : Œπ) (j : Œ∫ i)\n  (h : s i j ‚äÜ t), (Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (j : Œ∫ i) ‚Ü¶ s i j) ‚äÜ t","name":"Set.inter·µ¢‚ÇÇ_subset_of_subset","isProp":true,"docString":"This rather trivial consequence of `inter·µ¢‚ÇÇ_subset` is convenient with `apply`, and has `i` and\n`j` explicit for this purpose. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedGroup E] {s : Subgroup E} (x : { x : E // x ‚àà s }), ‚Äñx‚Äñ = ‚Äñ‚Üëx‚Äñ","name":"Subgroup.coe_norm","isProp":true,"docString":"If `x` is an element of a subgroup `s` of a seminormed group `E`, its norm in `s` is equal to\nits norm in `E`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] (s : Finset Œ±) (h‚ÇÇ : 1 < Finset.card s),\n  Finset.min' s\n      ((Iff.mp\n            ((Finset.card_pos=:(0 < Finset.card s : Prop) ‚Üî\n                  (Finset.Nonempty s : Prop))=:(0 < Finset.card s : Prop) ‚Üî (Finset.Nonempty s : Prop))\n            ((lt_trans ((zero_lt_one=:0 < 1)=:0 < 1)\n                  h‚ÇÇ=:0 < Finset.card s)=:0 < Finset.card s)=:Finset.Nonempty s)=:Finset.Nonempty s) <\n    Finset.max' s\n      ((Iff.mp\n            ((Finset.card_pos=:(0 < Finset.card s : Prop) ‚Üî\n                  (Finset.Nonempty s : Prop))=:(0 < Finset.card s : Prop) ‚Üî (Finset.Nonempty s : Prop))\n            ((lt_trans ((zero_lt_one=:0 < 1)=:0 < 1)\n                  h‚ÇÇ=:0 < Finset.card s)=:0 < Finset.card s)=:Finset.Nonempty s)=:Finset.Nonempty s)","name":"Finset.min'_lt_max'_of_card","isProp":true,"docString":"If there's more than 1 element, the min' is less than the max'. An alternate version of\n`min'_lt_max'` which is sometimes more convenient.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] (r : ENNReal) (C : ENNReal) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu : ‚àÄ (n : ‚Ñï), edist (f n) (f (n + 1)) ‚â§ C * r ^ n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a)),\n  edist (f 0) a ‚â§ C / (1 - r)","name":"edist_le_of_edist_le_geometric_of_tendsto‚ÇÄ","isProp":true,"docString":"If `edist (f n) (f (n+1))` is bounded by `C * r^n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] [self : OrderClosedTopology Œ±],\n  IsClosed (setOf fun (p : Œ± √ó Œ±) ‚Ü¶ Prod.fst p ‚â§ Prod.snd p)","name":"OrderClosedTopology.isClosed_le'","isProp":true,"docString":"The set `{ (x, y) | x ‚â§ y }` is a closed set. "},{"type":"‚àÄ {Œ≤ : Type u_1} {f : (a : Œ≤) ‚Üí ‚Ñï} (s : Finset Œ≤) {x : Œ≤} (hx : x ‚àà s) (hfz : f x ‚â† 0),\n  (Finset.gcd s fun (b : Œ≤) ‚Ü¶ f b / Finset.gcd s f) = 1","name":"Finset.Nat.gcd_div_eq_one","isProp":true,"docString":"Given a nonempty Finset `s` and a function `f` from `s` to `‚Ñï`, if `d = s.gcd`,\nthen the `gcd` of `(f i) / d` is equal to `1`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤) (a : Œ±) (b : Œ±),\n  ‚Üëf (a * b) = ‚Üëf a * ‚Üëf b","name":"RingHom.map_mul","isProp":true,"docString":"Ring homomorphisms preserve multiplication. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {x : WithBot Œ±}, (‚ä• < x : Prop) ‚Üî (x ‚â† ‚ä• : Prop)","name":"WithBot.bot_lt_iff_ne_bot","isProp":true,"docString":"A version of `bot_lt_iff_ne_bot` for `WithBot` that only requires `LT Œ±`, not\n`PartialOrder Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Setoid Œ±} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n  {H :\n    ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÅ : Œ±) (b‚ÇÇ : Œ±) (a : Setoid.r a‚ÇÅ b‚ÇÅ) (a : Setoid.r a‚ÇÇ b‚ÇÇ),\n      (r a‚ÇÅ a‚ÇÇ : Prop) = (r b‚ÇÅ b‚ÇÇ : Prop)}\n  (a : WellFounded r), WellFounded fun (x : Quotient s) (y : Quotient s) ‚Ü¶ Quotient.liftOn‚ÇÇ' x y r H","name":"WellFounded.quotient_liftOn‚ÇÇ'","isProp":true,"docString":"**Alias** of the reverse direction of `wellFounded_liftOn‚ÇÇ'_iff`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : StrictAnti f),\n  StrictMono (f ‚àò ‚ÜëOrderDual.ofDual)","name":"StrictAnti.dual_left","isProp":true,"docString":"**Alias** of the reverse direction of `strictMono_comp_ofDual_iff`."},{"type":"‚àÄ (R : Type u_2) {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (n : ‚Ñï) (b : M),\n  n ‚Ä¢ b = ‚Üën ‚Ä¢ b","name":"nsmul_eq_smul_cast","isProp":true,"docString":"`nsmul` is equal to any other module structure via a cast. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} (h : ¬¨(Metric.Bounded s : Prop)), Metric.diam s = 0","name":"Metric.diam_eq_zero_of_unbounded","isProp":true,"docString":"An unbounded set has zero diameter. If you would prefer to get the value ‚àû, use `EMetric.diam`.\nThis lemma makes it possible to avoid side conditions in some situations "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {f : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Œ±} (comm : Commutative f)\n  (assoc : ‚àÄ (a : Œ±) (b : Œ±) (c : Œ±), f (f a b) c ‚â§ f a (f b c)), Associative f","name":"associative_of_commutative_of_le","isProp":true,"docString":"To prove associativity of a commutative binary operation `‚óã`, we only to check\n`(a ‚óã b) ‚óã c ‚â§ a ‚óã (b ‚óã c)` for all `a`, `b`, `c`. "},{"type":"‚àÄ {R : Type u_3} [inst : CommSemiring R] (M : Submonoid R) {S : Type u_1} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] {P : Type u_2} [inst_3 : CommSemiring P] [inst_4 : IsLocalization M S] ‚¶Éj : S ‚Üí* P‚¶Ñ\n  ‚¶Ék : S ‚Üí* P‚¶Ñ (h : MonoidHom.comp j ‚Üë(algebraMap R S) = MonoidHom.comp k ‚Üë(algebraMap R S)), j = k","name":"IsLocalization.monoidHom_ext","isProp":true,"docString":"See note [partially-applied ext lemmas] "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero M] [inst_1 : CommMonoid N] (f : Œ± ‚Üí‚ÇÄ M) (y : Œ±)\n  (g : (a : Œ±) ‚Üí (a : M) ‚Üí N) (hyf : y ‚àà Finsupp.support f),\n  g y (‚Üëf y) * Finsupp.prod (Finsupp.erase y f) g = Finsupp.prod f g","name":"Finsupp.mul_prod_erase","isProp":true,"docString":"Taking a product over `f : Œ± ‚Üí‚ÇÄ M` is the same as multiplying the value on a single element\n`y ‚àà f.support` by the product over `erase y f`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ'' : Type u_2} [inst : Preorder Œπ''] {s'' : (a : Œπ'') ‚Üí Set Œ±} (self : Filter.IsAntitoneBasis s''),\n  Antitone s''","name":"Filter.IsAntitoneBasis.antitone","isProp":true,"docString":"The sequence of sets is antitone. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [inst : Semiring k] [inst_1 : AddMonoid G] [inst_2 : Semiring R]\n  {f : AddMonoidAlgebra k G ‚Üí+* R} {g : AddMonoidAlgebra k G ‚Üí+* R}\n  (h‚ÇÅ : RingHom.comp f AddMonoidAlgebra.singleZeroRingHom = RingHom.comp g AddMonoidAlgebra.singleZeroRingHom)\n  (h_of : MonoidHom.comp (‚Üëf) (AddMonoidAlgebra.of k G) = MonoidHom.comp (‚Üëg) (AddMonoidAlgebra.of k G)), f = g","name":"AddMonoidAlgebra.ringHom_ext'","isProp":true,"docString":"If two ring homomorphisms from `AddMonoidAlgebra k G` are equal on all `single a 1`\nand `single 0 b`, then they are equal.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {M : Type u_3} {v : (a : Œπ) ‚Üí M} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] {hli : LinearIndependent R v} {hsp : ‚ä§ ‚â§ Submodule.span R (Set.range v)}\n  [inst_3 : DecidableEq Œπ] {i : Œπ} {j : Œπ}, ‚Üë(Basis.coord (Basis.mk hli hsp) i) (v j) = if (j = i : Prop) then 1 else 0","name":"Basis.mk_coord_apply","isProp":true,"docString":"Given a basis, the `i`th element of the dual basis evaluates to the Kronecker delta on the\n`j`th element of the basis. "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±] {s : Set (Œ± √ó Œ±)} (hs : s ‚àà uniformity Œ±),\n  ‚àÉ (t : Set (Œ± √ó Œ±)), (t ‚àà uniformity Œ± : Prop) ‚àß ((SymmetricRel t : Prop) ‚àß (compRel t t ‚äÜ s : Prop) : Prop)","name":"comp_symm_mem_uniformity_sets","isProp":true,"docString":"See also `comp_open_symm_mem_uniformity_sets`. "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} (f : (a : Fin n) ‚Üí Œ±) (i : ‚Ñï), List.get? (List.ofFn f) i = List.ofFnNthVal f i","name":"List.get?_ofFn","isProp":true,"docString":"The `n`th element of a list "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : a ‚â§ 1) (hb : b < 1), a * b < 1","name":"mul_lt_one_of_le_of_lt","isProp":true,"docString":"**Alias** of `Left.mul_lt_one_of_le_of_lt`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass G { x : G // x ‚àà Subgroup.center G } G","name":"Subgroup.center.smulCommClass_right","isProp":true,"docString":"The center of a group acts commutatively on that group. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} {f‚ÇÅ : (a : Œπ) ‚Üí Œ±} {f‚ÇÇ : (a : Œπ) ‚Üí Œ±} {p : Filter Œπ} {a : Œ±}\n  (h‚ÇÅ : Filter.Tendsto f‚ÇÅ p (nhds a)) (h : Filter.Tendsto (fun (x : Œπ) ‚Ü¶ dist (f‚ÇÅ x) (f‚ÇÇ x)) p (nhds 0)),\n  Filter.Tendsto f‚ÇÇ p (nhds a)","name":"tendsto_of_tendsto_of_dist","isProp":true,"docString":"**Alias** of `Filter.Tendsto.congr_dist`."},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_1} (R : Type u_2) [inst : Fintype Œ±] [inst_1 : Semiring R] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] {v : (a : Œ±) ‚Üí M} {x : M},\n  (x ‚àà Submodule.span R (Set.range v) : Prop) ‚Üî\n    (‚àÉ (c : (a : Œ±) ‚Üí R), (Finset.sum Finset.univ fun (i : Œ±) ‚Ü¶ c i ‚Ä¢ v i) = x : Prop)","name":"mem_span_range_iff_exists_fun","isProp":true,"docString":"An element `x` lies in the span of `v` iff it can be written as sum `‚àë c·µ¢ ‚Ä¢ v·µ¢ = x`.\n"},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : CommMonoid M]\n  [h : Algebra.FiniteType R (MonoidAlgebra R M)], ‚àÉ (G : Finset M), Algebra.adjoin R (‚Üë(MonoidAlgebra.of R M) '' ‚ÜëG) = ‚ä§","name":"MonoidAlgebra.exists_finset_adjoin_eq_top","isProp":true,"docString":"If `MonoidAlgebra R M` is of finite type, there there is a `G : Finset M` such that its image\ngenerates, as algera, `MonoidAlgebra R M`. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : StrongRankCondition R] (n : ‚Ñï) {m : ‚Ñï} (v : (a : Fin m) ‚Üí (a : Fin n) ‚Üí R)\n  (a : LinearIndependent R v), m ‚â§ n","name":"Basis.card_le_card_of_linearIndependent_aux","isProp":true,"docString":"Let `R` satisfy the strong rank condition. If `m` elements of a free rank `n` `R`-module are\nlinearly independent, then `m ‚â§ n`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ‚Ñï}\n  (h : Finset.card fs = m + 1),\n  Finset.centroid k Finset.univ (Affine.Simplex.points (Affine.Simplex.face s h)) =\n    Finset.centroid k fs (Affine.Simplex.points s)","name":"Affine.Simplex.face_centroid_eq_centroid","isProp":true,"docString":"The centroid of a face of a simplex as the centroid of a subset of\nthe points. "},{"type":"‚àÄ {R : Type u_2} {E : Type u_1} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E] [inst_2 : Module R E]\n  {s : Set E} (hs : Set.Finite s),\n  ‚Üë(ClosureOperator.toOrderHom (convexHull R)) s =\n    ‚Üë(Finset.sum Finset.univ fun (x : ‚Üës) ‚Ü¶ LinearMap.smulRight (LinearMap.proj x) ‚Üëx) '' stdSimplex R ‚Üës","name":"Set.Finite.convexHull_eq_image","isProp":true,"docString":"The convex hull of a finite set is the image of the standard simplex in `s ‚Üí ‚Ñù`\nunder the linear map sending each function `w` to `‚àë x in s, w x ‚Ä¢ x`.\n\nSince we have no sums over finite sets, we use sum over `@Finset.univ _ hs.fintype`.\nThe map is defined in terms of operations on `(s ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù` so that later we will not need\nto prove that this map is linear. "},{"type":"‚àÄ {R : Type u} {M : Type v} {Œπ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] {module_M : Module R M}\n  (p : Submodule R M) (x : (a : Œπ) ‚Üí { x : M // x ‚àà p }) (s : Finset Œπ),\n  ‚Üë(Finset.sum s fun (i : Œπ) ‚Ü¶ x i) = Finset.sum s fun (i : Œπ) ‚Ü¶ ‚Üë(x i)","name":"Submodule.coe_sum","isProp":true,"docString":"Note the `AddSubmonoid` version of this lemma is called `AddSubmonoid.coe_finset_sum`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {M : (a : Polynomial R) ‚Üí Prop} {f : Polynomial R} (f0 : Polynomial.natDegree f ‚â† 0)\n  (h_C_add : ‚àÄ {a : R} {p : Polynomial R} (a_1 : M p), M (‚ÜëPolynomial.C a + p))\n  (h_add : ‚àÄ {p : Polynomial R} {q : Polynomial R} (a : M p) (a : M q), M (p + q))\n  (h_monomial : ‚àÄ {n : ‚Ñï} {a : R} (a_1 : a ‚â† 0) (a_2 : n ‚â† 0), M (‚Üë(Polynomial.monomial n) a)), M f","name":"Polynomial.natDegree_ne_zero_induction_on","isProp":true,"docString":"A property holds for all polynomials of non-zero `natDegree` with coefficients in a\nsemiring `R` if it holds for\n* `p + a`, with `a ‚àà R`, `p ‚àà R[X]`,\n* `p + q`, with `p, q ‚àà R[X]`,\n* monomials with nonzero coefficient and non-zero exponent,\nwith appropriate restrictions on each term.\nNote that multiplication is \"hidden\" in the assumption on monomials, so there is no explicit\nmultiplication in the statement.\nSee `degree_pos_induction_on` for a similar statement involving more explicit multiplications.\n "},{"type":"‚àÄ {Œ± : Type u_1} {r : Setoid Œ±} {x : Œ±} {b : Set Œ±} (hc : b ‚àà Setoid.classes r) (hb : x ‚àà b) {b' : Set Œ±}\n  (hc' : b' ‚àà Setoid.classes r) (hb' : x ‚àà b'), b = b'","name":"Setoid.eq_of_mem_classes","isProp":true,"docString":"If x ‚àà Œ± is in 2 equivalence classes, the equivalence classes are equal. "},{"type":"‚àÄ {M : Type u_2} {P : Type u_1} [inst : MulOneClass M] [inst_1 : MulOneClass P] {f : M ‚Üí* P},\n  MonoidHom.mrange (Con.kerLift f) = MonoidHom.mrange f","name":"Con.kerLift_range_eq","isProp":true,"docString":"Given a monoid homomorphism `f`, the induced homomorphism on the quotient by `f`'s kernel has\nthe same image as `f`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : Zero M] (f : (a : Œ±) ‚Üí Œ≤)\n  (hif :\n    optParam (Set.InjOn f (f ‚Åª¬π' ‚Üë(Finsupp.support 0)) : Prop)\n      ((Eq.rec ((Set.injOn_empty f=:Set.InjOn f ‚àÖ)=:Set.InjOn f ‚àÖ)\n            ((Eq.symm\n                  ((Finset.coe_empty=:‚Üë‚àÖ =\n                        ‚àÖ)=:‚Üë‚àÖ = ‚àÖ)=:‚àÖ = ‚Üë‚àÖ)=:‚àÖ = ‚Üë‚àÖ)=:Set.InjOn f (f ‚Åª¬π' ‚Üë‚àÖ))=:Set.InjOn f (f ‚Åª¬π' ‚Üë‚àÖ))),\n  Finsupp.comapDomain f 0 hif = 0","name":"Finsupp.comapDomain_zero","isProp":true,"docString":"Note the `hif` argument is needed for this to work in `rw`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] (x : Œ±) [hx : Filter.NeBot (nhdsWithin x ({x}·∂ú))]\n  {s : Set Œ±} (hs : s ‚àà nhds x), Set.Infinite s","name":"infinite_of_mem_nhds","isProp":true,"docString":"If the punctured neighborhoods of a point form a nontrivial filter, then any neighborhood is\ninfinite. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : b‚Åª¬π * a < c), a < b * c","name":"lt_mul_of_inv_mul_lt","isProp":true,"docString":"**Alias** of the forward direction of `inv_mul_lt_iff_lt_mul`."},{"type":"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 0 ‚àà s","name":"Subring.zero_mem","isProp":true,"docString":"A subring contains the ring's 0. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (hs : Nontrivial ‚Üës), Nontrivial Œ±","name":"Set.nontrivial_of_nontrivial_coe","isProp":true,"docString":"A type with a set `s` whose `coe_sort` is a nontrivial type is nontrivial.\nFor the corresponding result for `Subtype`, see `Subtype.nontrivial_iff_exists_ne`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±}\n  {p : Filter Œπ},\n  (TendstoUniformly F f p : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0), Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (x : Œ≤), dist (f x) (F n x) < Œµ) p : Prop)","name":"Metric.tendstoUniformly_iff","isProp":true,"docString":"Expressing uniform convergence using `dist`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] (a : E) (b : E), dist a b = ‚Äña - b‚Äñ","name":"dist_eq_norm","isProp":true,"docString":"**Alias** of `dist_eq_norm_sub`."},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] [inst_1 : Nonempty Œ±] {s : Set Œ±} (hs : Set.Finite s), BddBelow s","name":"Set.Finite.bddBelow","isProp":true,"docString":"A finite set is bounded below."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : IsWeakLowerModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚ãñ a ‚äî b)\n  (a_2 : b ‚ãñ a ‚äî b), a ‚äì b ‚ãñ a","name":"Covby.inf_of_sup_of_sup_left","isProp":true,"docString":"**Alias** of `inf_covby_of_covby_sup_of_covby_sup_left`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : AntivaryOn f g ‚Üës),\n  (Finset.card s ‚Ä¢ Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) ‚â§\n    (Finset.sum s fun (i : Œπ) ‚Ü¶ f i) ‚Ä¢ Finset.sum s fun (i : Œπ) ‚Ü¶ g i","name":"AntivaryOn.card_smul_sum_le_sum_smul_sum","isProp":true,"docString":"**Chebyshev's Sum Inequality**: When `f` and `g` antivary together (eg one is monotone, the\nother is antitone), the scalar product of their sum is less than the size of the set times their\nscalar product. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : Monoid M] (f : MonoidAlgebra R M),\n  f ‚àà Algebra.adjoin R (‚Üë(MonoidAlgebra.of R M) '' ‚Üë(Finsupp.support f))","name":"MonoidAlgebra.mem_adjoin_support","isProp":true,"docString":"An element of `MonoidAlgebra R M` is in the subalgebra generated by its support. "},{"type":"‚àÄ {S : Type v} (s : S) {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] [inst_2 : SetLike S R]\n  [inst_3 : SubringClass S R], IsDomain { x : R // x ‚àà s }","name":"SubringClass.instIsDomainSubtypeMemInstMembershipToSemiringToRing","isProp":true,"docString":"A subring of a domain is a domain. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M} {a : M} (hs : IsSubmonoid s) (h : a ‚àà s) {n : ‚Ñï}, a ^ n ‚àà s","name":"IsSubmonoid.pow_mem","isProp":true,"docString":"Submonoids are closed under natural powers. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} (x : M) (y : M), ‚Üë(x * y) = ‚Üëx * ‚Üëy","name":"Con.coe_mul","isProp":true,"docString":"The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). "},{"type":"‚àÄ {Œ± : Type u_1} [self : Semifield Œ±] (a : Œ±) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"Semifield.mul_inv_cancel","isProp":true,"docString":"Every nonzero element of a group with zero is invertible. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C}\n  (b : CategoryTheory.Limits.BinaryBicone X Y)\n  (total :\n    CategoryTheory.Limits.BinaryBicone.fst b ‚â´ CategoryTheory.Limits.BinaryBicone.inl b +\n        CategoryTheory.Limits.BinaryBicone.snd b ‚â´ CategoryTheory.Limits.BinaryBicone.inr b =\n      ùüô (CategoryTheory.Limits.BinaryBicone.pt b)),\n  CategoryTheory.Limits.HasBinaryBiproduct X Y","name":"CategoryTheory.Limits.hasBinaryBiproduct_of_total","isProp":true,"docString":"In a preadditive category, we can construct a binary biproduct for `X Y : C` from\nany binary bicone `b` satisfying `total : b.fst ‚â´ b.inl + b.snd ‚â´ b.inr = ùüô b.X`.\n\n(That is, such a bicone is a limit cone and a colimit cocone.)\n"},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±],\n  (setOf fun (s : Set Œ±) ‚Ü¶ IsPreconnected s) =\n    Set.range (Function.uncurry Set.Icc) ‚à™ Set.range (Function.uncurry Set.Ico) ‚à™ Set.range (Function.uncurry Set.Ioc) ‚à™\n        Set.range (Function.uncurry Set.Ioo) ‚à™\n      (Set.range Set.Ici ‚à™ Set.range Set.Ioi ‚à™ Set.range Set.Iic ‚à™ Set.range Set.Iio ‚à™ {Set.univ, ‚àÖ})","name":"setOf_isPreconnected_eq_of_ordered","isProp":true,"docString":"In a dense conditionally complete linear order, the set of preconnected sets is exactly\nthe set of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`, `Iic`, `Iio`, `(-‚àû, +‚àû)`,\nor `‚àÖ`. Though one can represent `‚àÖ` as `(inf‚Çõ s, inf‚Çõ s)`, we include it into the list of\npossible cases to improve readability. "},{"type":"‚àÄ {Œ± : Type u} [inst : LT Œ±] [inst_1 : WellFoundedGT Œ±] {C : (a : Œ±) ‚Üí Prop} (a : Œ±)\n  (a_1 : ‚àÄ (x : Œ±) (a : ‚àÄ (y : Œ±) (a : x < y), C y), C x), C a","name":"WellFoundedGT.induction","isProp":true,"docString":"Inducts on a well-founded `>` relation. "},{"type":"‚àÄ {Œ± : Type u_1} (a : Œ±) [inst : Subsingleton Œ±], Fintype.card Œ± = 1","name":"Fintype.card_ofSubsingleton","isProp":true,"docString":"Note: this lemma is specifically about `Fintype.ofSubsingleton`. For a statement about\narbitrary `Fintype` instances, use either `Fintype.card_le_one_iff_subsingleton` or\n`Fintype.card_unique`. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] {A : Matrix n n Œ±}\n  {B : Matrix n n Œ±} {C : Matrix n n Œ±} (h : Matrix.mul A B = 1) (g : Matrix.mul A C = 1), B = C","name":"Matrix.right_inv_eq_right_inv","isProp":true,"docString":"The right inverse of matrix A is unique when existing. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±],\n  Filter.HasBasis (uniformity Œ±) (fun (Œµ : ENNReal) ‚Ü¶ 0 < Œµ) fun (Œµ : ENNReal) ‚Ü¶\n    setOf fun (p : Œ± √ó Œ±) ‚Ü¶ edist (Prod.fst p) (Prod.snd p) < Œµ","name":"Metric.uniformity_basis_edist","isProp":true,"docString":"Expressing the uniformity in terms of `edist` "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s : Set P} [inst_3 : Nontrivial P], (affineSpan k s = ‚ä§ : Prop) ‚Üî (vectorSpan k s = ‚ä§ : Prop)","name":"AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial","isProp":true,"docString":"For a non-trivial space, the affine span of a set is `‚ä§` iff its vector span is `‚ä§`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {l : Filter Œ±} (hs : IsCompact s),\n  (Disjoint (nhdsSet s) l : Prop) ‚Üî (‚àÄ (x : Œ±) (a : x ‚àà s), Disjoint (nhds x) l : Prop)","name":"IsCompact.disjoint_nhdsSet_left","isProp":true,"docString":"The neighborhood filter of a compact set is disjoint with a filter `l` if and only if the\nneighborhood filter of each point of this set is disjoint with `l`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} (h : x ‚àà s), Metric.infDist x s = 0","name":"Metric.infDist_zero_of_mem","isProp":true,"docString":"The minimal distance of a point to a set containing it vanishes "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : NoMaxOrder Œ±], Filter.atTop ‚â§ Filter.cofinite","name":"Filter.atTop_le_cofinite","isProp":true,"docString":"If `Œ±` is a preorder with no maximal element, then `atTop ‚â§ cofinite`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ∫ : Type u_4} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} (h : Equicontinuous F) (u : (a : Œ∫) ‚Üí Œπ), Equicontinuous (F ‚àò u)","name":"Equicontinuous.comp","isProp":true,"docString":"Taking sub-families preserves equicontinuity. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (self : R ‚âÉ+* S)\n  (x : R) (y : R),\n  Equiv.toFun (RingEquiv.toEquiv self) (x * y) =\n    Equiv.toFun (RingEquiv.toEquiv self) x * Equiv.toFun (RingEquiv.toEquiv self) y","name":"RingEquiv.map_mul'","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {d : AddCon M}, Setoid.r = Setoid.r ‚äì Setoid.r","name":"AddCon.inf_def","isProp":true,"docString":"The infimum of two additive congruence relations equals the infimum of the\nunderlying binary operations."},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x : X} {y : X} (self : Path x y),\n  ContinuousMap.toFun (Path.toContinuousMap self) 1 = y","name":"Path.target'","isProp":true,"docString":"The end point of a `Path`. "},{"type":"‚àÄ (n : ‚Ñï), IsWellOrder (Fin n) fun (x : Fin n) (x_1 : Fin n) ‚Ü¶ x < x_1","name":"Fin.Lt.isWellOrder","isProp":true,"docString":"The ordering on `Fin n` is a well order. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {Œπ : Sort u_1} [hŒπ : Nonempty Œπ] {S : (a : Œπ) ‚Üí Subring R}\n  (hS : Directed (fun (x : Subring R) (x_1 : Subring R) ‚Ü¶ x ‚â§ x_1) S) {x : R},\n  (x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i : Prop) ‚Üî (‚àÉ (i : Œπ), x ‚àà S i : Prop)","name":"Subring.mem_sup·µ¢_of_directed","isProp":true,"docString":"The underlying set of a non-empty directed sup‚Çõ of subrings is just a union of the subrings.\nNote that this fails without the directedness assumption (the union of two subrings is\ntypically not a subring) "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : CommMonoid Œ≤] {s : Finset Œ≥} {t : Finset Œ±}\n  {f : (a : Œ≥) ‚Üí (a : Œ±) ‚Üí Œ≤},\n  (Finset.prod (s √ó·∂† t) fun (x : Œ≥ √ó Œ±) ‚Ü¶ f (Prod.fst x) (Prod.snd x)) =\n    Finset.prod t fun (y : Œ±) ‚Ü¶ Finset.prod s fun (x : Œ≥) ‚Ü¶ f x y","name":"Finset.prod_product_right'","isProp":true,"docString":"An uncurried version of `Finset.prod_product_right`. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} {r : ‚Ñö} (hne : padicNorm p q ‚â† padicNorm p r),\n  padicNorm p (q + r) = max (padicNorm p q) (padicNorm p r)","name":"padicNorm.add_eq_max_of_ne","isProp":true,"docString":"If the `p`-adic norms of `q` and `r` are different, then the norm of `q + r` is equal to the max\nof the norms of `q` and `r`. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a : Œ±} {b : Œ±} (a_1 : b ‚â§ a), a ‚äî b = a","name":"sup_of_le_left","isProp":true,"docString":"**Alias** of the reverse direction of `sup_eq_left`."},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {s : Set M} {p : (a : M) ‚Üí (a : M) ‚Üí Prop} {x : M} {y : M}\n  (hx : x ‚àà Subsemigroup.closure s) (hy : y ‚àà Subsemigroup.closure s)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s) (y : M) (a : y ‚àà s), p x y)\n  (Hmul_left : ‚àÄ (x : M) (y : M) (z : M) (a : p x z) (a : p y z), p (x * y) z)\n  (Hmul_right : ‚àÄ (x : M) (y : M) (z : M) (a : p z x) (a : p z y), p z (x * y)), p x y","name":"Subsemigroup.closure_induction‚ÇÇ","isProp":true,"docString":"An induction principle for closure membership for predicates with two arguments.  "},{"type":"‚àÄ {R : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_4} {M‚ÇÇ : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R‚ÇÇ] [inst_4 : AddCommMonoid M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  {Œπ : Type u_1} {v : (a : Œπ) ‚Üí M} {f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} {g : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (hv : Submodule.span R (Set.range v) = ‚ä§)\n  (h : ‚àÄ (i : Œπ), ‚Üëf (v i) = ‚Üëg (v i)), f = g","name":"LinearMap.ext_on_range","isProp":true,"docString":"If the range of `v : Œπ ‚Üí M` generates the whole module and linear maps `f`, `g` are equal at\neach `v i`, then they are equal. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type v} (self : Finmap Œ≤), Multiset.NodupKeys (Finmap.entries self)","name":"Finmap.nodupKeys","isProp":true,"docString":"There are no duplicate keys in `entries` "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} (a_1 : a + b ‚â§ c), a ‚â§ c - b","name":"le_sub_right_of_add_le","isProp":true,"docString":"**Alias** of the reverse direction of `le_sub_iff_add_le`."},{"type":"‚àÄ (n : ‚Ñï) (k : ‚Ñï) (hkn : k ‚â§ n),\n  (Finset.prod (Finset.range (n + 1)) fun (p : ‚Ñï) ‚Ü¶ p ^ ‚Üë(Nat.factorization (Nat.choose n k)) p) = Nat.choose n k","name":"Nat.prod_pow_factorization_choose","isProp":true,"docString":"A binomial coefficient is the product of its prime factors, which are at most `n`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : TopologicalSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±} {p : Filter Œπ},\n  (TendstoLocallyUniformly F f p : Prop) ‚Üî\n    (‚àÄ (Œµ : ENNReal) (a : Œµ > 0) (x : Œ≤),\n        ‚àÉ (t : Set Œ≤),\n          (t ‚àà nhds x : Prop) ‚àß\n            (Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (y : Œ≤) (a : y ‚àà t), edist (f y) (F n y) < Œµ) p : Prop) :\n      Prop)","name":"EMetric.tendstoLocallyUniformly_iff","isProp":true,"docString":"Expressing locally uniform convergence using `edist`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] (u : E) (v : E), ‚Äñv‚Äñ ‚â§ ‚Äñu‚Äñ + ‚Äñu - v‚Äñ","name":"norm_le_insert","isProp":true,"docString":"**Alias** of `norm_le_norm_add_norm_sub`."},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K), 1 ‚àà s","name":"Subfield.one_mem","isProp":true,"docString":"A subfield contains the field's 1. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (Œπ : Type u_1)\n  [inst_3 : Unique Œπ], (FiniteDimensional.finrank K V = 1 : Prop) ‚Üî (Nonempty (Basis Œπ K V) : Prop)","name":"finrank_eq_one_iff","isProp":true,"docString":"A module has dimension 1 iff there is some `v : V` so `{v}` is a basis.\n"},{"type":"‚àÄ {R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [inst : CommRing R] [inst_1 : LieRing L]\n  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : LieRingModule L M] [inst_7 : LieRingModule L N] (self : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N),\n  Function.RightInverse (LieModuleEquiv.invFun self)\n    (AddHom.toFun (LinearMap.toAddHom ‚Üë(LieModuleEquiv.toLieModuleHom self)))","name":"LieModuleEquiv.right_inv","isProp":true,"docString":"The inverse function of an equivalence of Lie modules is a right inverse of the underlying\nfunction. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  (h : a ‚äÇ b), a ‚äÜ b","name":"HasSSubset.SSubset.subset","isProp":true,"docString":"**Alias** of `subset_of_ssubset`."},{"type":"‚àÄ {M : Type u_2} {N : Type u_1} [inst : MulOneClass M] [inst_1 : MulOneClass N] {c : Con M} {f : N ‚Üí* M},\n  Con.comap ‚Üëf\n      ((MonoidHom.map_mul f=:‚àÄ (a : N) (b : N), ‚Üëf (a * b) = ‚Üëf a * ‚Üëf b)=:‚àÄ (a : N) (b : N), ‚Üëf (a * b) = ‚Üëf a * ‚Üëf b)\n      c =\n    Con.ker (MonoidHom.comp (Con.mk' c) f)","name":"Con.comap_eq","isProp":true,"docString":"Given a monoid homomorphism `f : N ‚Üí M` and a congruence relation `c` on `M`, the congruence\nrelation induced on `N` by `f` equals the kernel of `c`'s quotient homomorphism composed with\n`f`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {t : Finset Œ±} (h : s ‚äÜ t),\n  Finset.card (Finset.Ioo s t) = 2 ^ (Finset.card t - Finset.card s) - 2","name":"Finset.card_Ioo_finset","isProp":true,"docString":"Cardinality of an `Ioo` of finsets. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} {Œ¥ : Type u_2} [inst : TopologicalSpace Œ≤] [inst_1 : TopologicalSpace Œ¥]\n  (f : (a : Œ±) ‚Üí Œ≤) (g : (a : Œ≥) ‚Üí Œ¥),\n  instTopologicalSpaceProd =\n    TopologicalSpace.induced (fun (p : Œ± √ó Œ≥) ‚Ü¶ (f (Prod.fst p), g (Prod.snd p))) instTopologicalSpaceProd","name":"prod_induced_induced","isProp":true,"docString":"A product of induced topologies is induced by the product map "},{"type":"‚àÄ {a : Cardinal} {b : Cardinal} (ha : Cardinal.aleph0 ‚â§ a), a + b = max a b","name":"Cardinal.add_eq_max","isProp":true,"docString":"If `Œ±` is an infinite type, then the cardinality of `Œ± ‚äï Œ≤` is the maximum\nof the cardinalities of `Œ±` and `Œ≤`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (a : G), ‚Üë(Equiv.symm (Equiv.mulRight a)) = fun (x : G) ‚Ü¶ x * a‚Åª¬π","name":"Equiv.mulRight_symm_apply","isProp":true,"docString":"Extra simp lemma that `dsimp` can use. `simp` will never use this. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n  [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (sup·µ¢ g)) (Mf : Monotone f),\n  f (sup·µ¢ fun (i : Œπ) ‚Ü¶ g i) = sup·µ¢ fun (i : Œπ) ‚Ü¶ f (g i)","name":"Monotone.map_sup·µ¢_of_continuousAt'","isProp":true,"docString":"A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed\nsupremum to the indexed supremum of the composition. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (q : (i : Fin (n + 1)) ‚Üí Œ± i) (i : Fin n) (y : Œ± (‚ÜëFin.castSucc i)),\n  Fin.init (Function.update q (‚ÜëFin.castSucc i) y) = Function.update (Fin.init q) i y","name":"Fin.init_update_castSucc","isProp":true,"docString":"Updating an element and taking the beginning commute. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\n  UniformContinuous (Equiv.toFun (UniformEquiv.toEquiv self))","name":"UniformEquiv.uniformContinuous_toFun","isProp":true,"docString":"Uniform continuity of the function "},{"type":"‚àÄ {Œ± : Type u_1} [inst : EMetricSpace Œ±] {K : NNReal} {f : (a : Œ±) ‚Üí Œ±} (hf : ContractingWith K f) {s : Set Œ±}\n  (hsc : IsComplete s) (hsf : Set.MapsTo f s s) (hfs : ContractingWith K (Set.MapsTo.restrict f s s hsf)) {x : Œ±}\n  (hxs : x ‚àà s) (hx : edist x (f x) ‚â† ‚ä§) {t : Set Œ±} (htc : IsComplete t) (htf : Set.MapsTo f t t)\n  (hft : ContractingWith K (Set.MapsTo.restrict f t t htf)) {y : Œ±} (hyt : y ‚àà t) (hy : edist y (f y) ‚â† ‚ä§)\n  (hxy : edist x y ‚â† ‚ä§),\n  ContractingWith.efixedPoint' f hsc hsf hfs x hxs hx = ContractingWith.efixedPoint' f htc htf hft y hyt hy","name":"ContractingWith.efixedPoint_eq_of_edist_lt_top'","isProp":true,"docString":"If a globally contracting map `f` has two complete forward-invariant sets `s`, `t`,\nand `x ‚àà s` is at a finite distance from `y ‚àà t`, then the `efixedPoint'` constructed by `x`\nis the same as the `efixedPoint'` constructed by `y`.\n\nThis lemma takes additional arguments stating that `f` contracts on `s` and `t` because this way\nit can be used to prove the desired equality with non-trivial proofs of these facts. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} {l : Filter Œ±}\n  (a : Filter.Eventually (fun (x : Œ±) ‚Ü¶ (x ‚àà s : Prop) ‚Üî (x ‚àà t : Prop)) l), s =·∂†[l] t","name":"Filter.Eventually.set_eq","isProp":true,"docString":"**Alias** of the reverse direction of `Filter.eventuallyEq_set`."},{"type":"‚àÄ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G}\n  (ha : IsLeast (setOf fun (g : G) ‚Ü¶ (g ‚àà H : Prop) ‚àß (0 < g : Prop)) a), H = AddSubgroup.closure {a}","name":"AddSubgroup.cyclic_of_min","isProp":true,"docString":"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ‚à© G_{>0}` then `H` is generated by `a`. "},{"type":"‚àÄ {X : Type u} [inst : Lattice X] [inst_1 : JordanHolderLattice X] (s‚ÇÅ : CompositionSeries X) (s‚ÇÇ : CompositionSeries X)\n  (hb : CompositionSeries.bot s‚ÇÅ = CompositionSeries.bot s‚ÇÇ) (ht : CompositionSeries.top s‚ÇÅ = CompositionSeries.top s‚ÇÇ),\n  CompositionSeries.Equivalent s‚ÇÅ s‚ÇÇ","name":"CompositionSeries.jordan_holder","isProp":true,"docString":"The **Jordan-H√∂lder** theorem, stated for any `JordanHolderLattice`.\nIf two composition series start and finish at the same place, they are equivalent. "},{"type":"Set.InjOn Nat.factorization (setOf fun (x : ‚Ñï) ‚Ü¶ x ‚â† 0)","name":"Nat.factorization_inj","isProp":true,"docString":"Every nonzero natural number has a unique prime factorization "},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_1} {M : Type u_2} {M' : Type u_3} {v : (a : Œπ) ‚Üí M} [inst : Semiring R]\n  [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M'] [inst_3 : Module R M] [inst_4 : Module R M']\n  (hv : LinearIndependent R v) (f : M ‚Üí‚Çó[R] M') (hf_inj : LinearMap.ker f = ‚ä•), LinearIndependent R (‚Üëf ‚àò v)","name":"LinearIndependent.map'","isProp":true,"docString":"An injective linear map sends linearly independent families of vectors to linearly independent\nfamilies of vectors. See also `LinearIndependent.map` for a more general statement. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.HasShift C ‚Ñ§]\n  [inst_4 : CategoryTheory.Pretriangulated C] [self : CategoryTheory.IsTriangulated C] {X‚ÇÅ : C} {X‚ÇÇ : C} {X‚ÇÉ : C}\n  {Z‚ÇÅ‚ÇÇ : C} {Z‚ÇÇ‚ÇÉ : C} {Z‚ÇÅ‚ÇÉ : C} {u‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ X‚ÇÇ} {u‚ÇÇ‚ÇÉ : X‚ÇÇ ‚ü∂ X‚ÇÉ} {u‚ÇÅ‚ÇÉ : X‚ÇÅ ‚ü∂ X‚ÇÉ} (comm : u‚ÇÅ‚ÇÇ ‚â´ u‚ÇÇ‚ÇÉ = u‚ÇÅ‚ÇÉ)\n  {v‚ÇÅ‚ÇÇ : X‚ÇÇ ‚ü∂ Z‚ÇÅ‚ÇÇ}\n  {w‚ÇÅ‚ÇÇ : Z‚ÇÅ‚ÇÇ ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C 1)) X‚ÇÅ}\n  (h‚ÇÅ‚ÇÇ : CategoryTheory.Pretriangulated.Triangle.mk u‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ w‚ÇÅ‚ÇÇ ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles)\n  {v‚ÇÇ‚ÇÉ : X‚ÇÉ ‚ü∂ Z‚ÇÇ‚ÇÉ}\n  {w‚ÇÇ‚ÇÉ : Z‚ÇÇ‚ÇÉ ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C 1)) X‚ÇÇ}\n  (h‚ÇÇ‚ÇÉ : CategoryTheory.Pretriangulated.Triangle.mk u‚ÇÇ‚ÇÉ v‚ÇÇ‚ÇÉ w‚ÇÇ‚ÇÉ ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles)\n  {v‚ÇÅ‚ÇÉ : X‚ÇÉ ‚ü∂ Z‚ÇÅ‚ÇÉ}\n  {w‚ÇÅ‚ÇÉ : Z‚ÇÅ‚ÇÉ ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C 1)) X‚ÇÅ}\n  (h‚ÇÅ‚ÇÉ :\n    CategoryTheory.Pretriangulated.Triangle.mk u‚ÇÅ‚ÇÉ v‚ÇÅ‚ÇÉ w‚ÇÅ‚ÇÉ ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles),\n  Nonempty (CategoryTheory.Triangulated.Octahedron comm h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÉ)","name":"CategoryTheory.IsTriangulated.octahedron_axiom","isProp":true,"docString":"the octahedron axiom (TR 4) "},{"type":"‚àÄ {R : Type u_1} {Œì‚ÇÄ : Type u_2} [inst : Ring R] [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ] {v‚ÇÅ : Valuation R Œì‚ÇÄ}\n  {v‚ÇÇ : Valuation R Œì‚ÇÄ}, (v‚ÇÅ = v‚ÇÇ : Prop) ‚Üî (‚àÄ (r : R), ‚Üëv‚ÇÅ r = ‚Üëv‚ÇÇ r : Prop)","name":"Valuation.ext_iff","isProp":true,"docString":"Deprecated. Use `FunLike.ext_iff`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type v} (self : AList Œ≤), List.NodupKeys (AList.entries self)","name":"AList.nodupKeys","isProp":true,"docString":"There are no duplicate keys in `entries` "},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)}, (FreeGroup.Red [] L : Prop) ‚Üî (L = [] : Prop)","name":"FreeGroup.Red.nil_iff","isProp":true,"docString":"The empty word `[]` only reduces to itself. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : NonAssocRing Œ±] [inst_2 : ContinuousMul Œ±], ContinuousNeg Œ±","name":"TopologicalSemiring.continuousNeg_of_mul","isProp":true,"docString":"If `R` is a ring with a continuous multiplication, then negation is continuous as well since it\nis just multiplication with `-1`. "},{"type":"‚àÄ {z : ZFSet} (a : ZFSet.IsTransitive z) {x : ZFSet} {y : ZFSet} (a : x ‚àà y) (a : y ‚àà z), x ‚àà z","name":"ZFSet.IsTransitive.mem_trans","isProp":true,"docString":"**Alias** of the forward direction of `ZFSet.isTransitive_iff_mem_trans`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±]\n  (h : Function.Periodic f c) (hc : 0 < c) (x : Œ±) (a : Œ±),\n  ‚àÉ (y : Œ±), (y ‚àà Set.Ioc a (a + c) : Prop) ‚àß (f x = f y : Prop)","name":"Function.Periodic.exists_mem_Ioc","isProp":true,"docString":"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ‚àà Ioc a (a + c)` such that `f x = f y`. "},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±], IsIdempotent Œ± max","name":"max_idem","isProp":true,"docString":"An instance asserting that `max a a = a` "},{"type":"‚àÄ {Œ± : Type u_1} {N : Type u_2} [inst : Zero N] {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : N) ‚Üí (a : N) ‚Üí Prop}\n  (hbot : ‚àÄ ‚¶Én : N‚¶Ñ, ¬¨(s n 0 : Prop)) (hs : WellFounded s) (x : Œ± ‚Üí‚ÇÄ N)\n  (h : ‚àÄ (a : Œ±) (a_1 : a ‚àà Finsupp.support x), Acc (r·∂ú ‚äì fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â† x_1) a), Acc (Finsupp.Lex r s) x","name":"Finsupp.Lex.acc","isProp":true,"docString":"Transferred from `Dfinsupp.Lex.acc`. See the top of that file for an explanation for the\nappearance of the relation `r·∂ú ‚äì (‚â†)`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X) (n : ‚Ñï),\n  CompactExhaustion.toFun self n ‚äÜ interior (CompactExhaustion.toFun self (n + 1))","name":"CompactExhaustion.subset_interior_succ'","isProp":true,"docString":"The sets in the compact exhaustion form a sequence:\neach set is contained in the interior of the next. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedDivisionRing Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx - y‚Äñ","name":"NormedDivisionRing.dist_eq","isProp":true,"docString":"The distance is induced by the norm. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {a : Option Œ±} {b : Option Œ≤} {Œ¥ : Type u_1}\n  {Œ≤' : Type u_2} {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ¥} {g' : (a : Œ≤) ‚Üí Œ≤'}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' a (g' b)),\n  Option.map g (Option.map‚ÇÇ f a b) = Option.map‚ÇÇ f' a (Option.map g' b)","name":"Option.map_map‚ÇÇ_distrib_right","isProp":true,"docString":"Symmetric statement to `Option.map_map‚ÇÇ_right_comm`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±} (a : BddAbove s), BddAbove ‚Üë(lowerClosure s)","name":"BddAbove.lowerClosure","isProp":true,"docString":"**Alias** of the reverse direction of `bddAbove_lowerClosure`."},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {a : AddMonoidAlgebra R ‚Ñï} {b : AddMonoidAlgebra R ‚Ñï},\n  ({ toFinsupp := a } = { toFinsupp := b } : Prop) ‚Üî (a = b : Prop)","name":"Polynomial.ofFinsupp_inj","isProp":true,"docString":"A more convenient spelling of `Polynomial.ofFinsupp.injEq` in terms of `Iff`. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] (t : Multiset (Polynomial R))\n  (h : Multiset.prod (Multiset.map (fun (f : Polynomial R) ‚Ü¶ Polynomial.leadingCoeff f) t) ‚â† 0),\n  Polynomial.natDegree (Multiset.prod t) =\n    Multiset.sum (Multiset.map (fun (f : Polynomial R) ‚Ü¶ Polynomial.natDegree f) t)","name":"Polynomial.natDegree_multiset_prod'","isProp":true,"docString":"The degree of a product of polynomials is equal to\nthe sum of the degrees, provided that the product of leading coefficients is nonzero.\n\nSee `Polynomial.natDegree_multiset_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n"},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {a : R} {b : R} {c : R} (h : ‚àÄ (s : R), discrim a b c ‚â† s ^ 2) (x : R),\n  a * x * x + b * x + c ‚â† 0","name":"quadratic_ne_zero_of_discrim_ne_sq","isProp":true,"docString":"A quadratic has no root if its discriminant has no square root. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±·µí·µà} {b : Œ±·µí·µà} (a_1 : b ‚©ø a), ‚ÜëOrderDual.ofDual a ‚©ø ‚ÜëOrderDual.ofDual b","name":"Wcovby.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `ofDual_wcovby_ofDual_iff`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (h : UniformEmbedding f),\n  (‚àÄ (Œµ : ENNReal) (a : Œµ > 0),\n        ‚àÉ (Œ¥ : ENNReal), (Œ¥ > 0 : Prop) ‚àß (‚àÄ {a : Œ±} {b : Œ±} (a_1 : edist a b < Œ¥), edist (f a) (f b) < Œµ : Prop) :\n      Prop) ‚àß\n    (‚àÄ (Œ¥ : ENNReal) (a : Œ¥ > 0),\n        ‚àÉ (Œµ : ENNReal), (Œµ > 0 : Prop) ‚àß (‚àÄ {a : Œ±} {b : Œ±} (a_1 : edist (f a) (f b) < Œµ), edist a b < Œ¥ : Prop) :\n      Prop)","name":"EMetric.controlled_of_uniformEmbedding","isProp":true,"docString":"If a map between pseudoemetric spaces is a uniform embedding then the edistance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`.\n\nIn fact, this lemma holds for a `UniformInducing` map.\nTODO: generalize? "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (Monovary (f ‚àò ‚ÜëœÉ) g : Prop)","name":"Monovary.sum_comp_perm_mul_eq_sum_mul_iff","isProp":true,"docString":"**Equality case of Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f ‚àò œÉ` and `g` monovary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_3} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)]\n  [inst_2 : (i : Œπ) ‚Üí SMul Œ± (Œ≤ i)] {k : Œ±} {x : (i : Œπ) ‚Üí Œ≤ i} {y : (i : Œπ) ‚Üí Œ≤ i}\n  (hk : ‚àÄ (i : Œπ), IsSMulRegular (Œ≤ i) k), hammingDist (k ‚Ä¢ x) (k ‚Ä¢ y) = hammingDist x y","name":"hammingDist_smul","isProp":true,"docString":"Corresponds to `dist_smul` with the discrete norm on `Œ±`. "},{"type":"‚àÄ {ùïÜ : Type u_1} {Œ± : Type u_2} [inst : Preorder ùïÜ] [inst_1 : Preorder Œ±] [self : GradeOrder ùïÜ Œ±],\n  StrictMono GradeOrder.grade","name":"GradeOrder.grade_strictMono","isProp":true,"docString":"`grade` is strictly monotonic. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_3} [inst : CommSemiring R] {œÉ : Type u_1} [inst_1 : AddCommMonoid M]\n  [inst_2 : SemilatticeSup M] (w : (a : œÉ) ‚Üí M) (p : MvPolynomial œÉ R),\n  (MvPolynomial.weightedTotalDegree' w p = ‚ä• : Prop) ‚Üî (p = 0 : Prop)","name":"MvPolynomial.weightedTotalDegree'_eq_bot_iff","isProp":true,"docString":"The `weightedTotalDegree'` of a polynomial `p` is `‚ä•` if and only if `p = 0`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] {Y : Type u_2} [inst_2 : TopologicalSpace Y],\n  IsClosedMap Prod.snd","name":"isClosedMap_snd_of_compactSpace","isProp":true,"docString":"If `X` is a compact topological space, then `Prod.snd : X √ó Y ‚Üí Y` is a closed map. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero M] [inst_1 : CommMonoid N] [inst_2 : DecidableEq Œ±]\n  (f : Œ± ‚Üí‚ÇÄ M) (a : Œ±) (b : (a : Œ±) ‚Üí (a : M) ‚Üí N),\n  (Finsupp.prod f fun (x : Œ±) (v : M) ‚Ü¶ if (x = a : Prop) then b x v else 1) =\n    if (a ‚àà Finsupp.support f : Prop) then b a (‚Üëf a) else 1","name":"Finsupp.prod_ite_eq'","isProp":true,"docString":"A restatement of `prod_ite_eq` with the equality test reversed. "},{"type":"‚àÄ {M : Type u_2} [inst : MulOneClass M] {Œπ : Sort u_1} (S : (a : Œπ) ‚Üí Submonoid M) {C : (a : M) ‚Üí Prop} {x : M}\n  (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hp : ‚àÄ (i : Œπ) (x : M) (a : x ‚àà S i), C x) (h1 : C 1)\n  (hmul : ‚àÄ (x : M) (y : M) (a : C x) (a : C y), C (x * y)), C x","name":"Submonoid.sup·µ¢_induction","isProp":true,"docString":"An induction principle for elements of `‚®Ü i, S i`.\nIf `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : NoMinOrder Œ±]\n  [inst_4 : DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±},\n  (s ‚àà nhdsWithin a (Set.Iio a) : Prop) ‚Üî (‚àÉ (l : Œ±), (l ‚àà Set.Iio a : Prop) ‚àß (Set.Ico l a ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Iio_iff_exists_Ico_subset","isProp":true,"docString":"A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `[l, a)`\nwith `l < a`. "},{"type":"‚àÄ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  (n : AddSubgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 0)","name":"QuotientAddGroup.nhds_zero_isCountablyGenerated","isProp":true,"docString":"In a first countable topological additive group `G` with normal additive subgroup\n`N`, `0 : G ‚ß∏ N` has a countable neighborhood basis."},{"type":"‚àÄ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  ‚Üë(algebraMap R A) r * x = x * ‚Üë(algebraMap R A) r","name":"Algebra.commutes","isProp":true,"docString":"`mul_comm` for `Algebra`s when one element is from the base ring. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±},\n  EMetric.hausdorffEdist s (closure t) = EMetric.hausdorffEdist s t","name":"EMetric.hausdorffEdist_closure‚ÇÇ","isProp":true,"docString":"Replacing a set by its closure does not change the Hausdorff edistance. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] (X : C) (Y : C)\n  [inst_2 : CategoryTheory.Limits.HasBinaryProduct X Y], CategoryTheory.Limits.HasBinaryBiproduct X Y","name":"CategoryTheory.Limits.HasBinaryBiproduct.of_hasBinaryProduct","isProp":true,"docString":"In a preadditive category, if the product of `X` and `Y` exists, then the\nbinary biproduct of `X` and `Y` exists. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedAddCommGroup Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"LinearOrderedAddCommGroup.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P) (i : Fin 1), Affine.Simplex.points (Affine.Simplex.mkOfPoint k p) i = p","name":"Affine.Simplex.mkOfPoint_points","isProp":true,"docString":"The point in a simplex constructed with `mkOfPoint`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Nonempty s), Nonempty ‚Üës","name":"Set.Nonempty.coe_sort","isProp":true,"docString":"**Alias** of the reverse direction of `Set.nonempty_coe_sort`."},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [inst : IsRefl Œ± r] {x : Œ±} {y : Œ±},\n  (‚àÄ (a : x ‚â† y), r x y : Prop) ‚Üî (r x y : Prop)","name":"reflexive_ne_imp_iff","isProp":true,"docString":"If a reflexive relation `r : Œ± ‚Üí Œ± ‚Üí Prop` holds over `x y : Œ±`,\nthen it holds whether or not `x ‚â† y`. Unlike `Reflexive.ne_imp_iff`, this uses `[IsRefl Œ± r]`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l],\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atTop : Prop) ‚Üî\n    (((0 < r : Prop) ‚àß (Filter.Tendsto f l Filter.atTop : Prop) : Prop) ‚à®\n        ((r < 0 : Prop) ‚àß (Filter.Tendsto f l Filter.atBot : Prop) : Prop) :\n      Prop)","name":"Filter.tendsto_mul_const_atTop_iff","isProp":true,"docString":"The function `Œª x, f x * r` tends to infinity along a nontrivial filter if and only if `r > 0`\nand `f` tends to infinity or `r < 0` and `f` tends to negative infinity. "},{"type":"‚àÄ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), 0 + a = a","name":"AddLeftCancelMonoid.zero_add","isProp":true,"docString":"Zero is a left neutral element for addition "},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] (M : Subsemigroup R),\n  Subsemigroup.nonUnitalSubsemiringClosure M = NonUnitalSubsemiring.closure ‚ÜëM","name":"Subsemigroup.nonUnitalSubsemiringClosure_eq_closure","isProp":true,"docString":"The `NonUnitalSubsemiring` generated by a multiplicative subsemigroup coincides with the\n`NonUnitalSubsemiring.closure` of the subsemigroup itself . "},{"type":"‚àÄ {p : (a : ZFSet) ‚Üí Prop} (x : ZFSet) (h : ‚àÄ (x : ZFSet) (a : ‚àÄ (y : ZFSet) (a : y ‚àà x), p y), p x), p x","name":"ZFSet.inductionOn","isProp":true,"docString":"Induction on the `‚àà` relation. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {u : (a : Œ≤) ‚Üí Œ±} (self : LowerAdjoint u),\n  GaloisConnection (LowerAdjoint.toFun self) u","name":"LowerAdjoint.gc'","isProp":true,"docString":"The underlying function is a lower adjoint. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤} (a : LocalEquiv.IsImage e s t),\n  LocalEquiv.target e ‚à© LocalEquiv.toFun (LocalEquiv.symm e) ‚Åª¬π' s = LocalEquiv.target e ‚à© t","name":"LocalEquiv.IsImage.symm_preimage_eq","isProp":true,"docString":"**Alias** of the forward direction of `LocalEquiv.IsImage.iff_symm_preimage_eq`."},{"type":"‚àÄ {l : ‚Ñï} {m : ‚Ñï} {Œ± : Type u_1} [inst : NonUnitalNonAssocSemiring Œ±] (v : (a : Fin l) ‚Üí Œ±)\n  (A : Matrix (Fin l) (Fin m) Œ±), Matrix.vecMul·µ£ v A = Matrix.vecMul v A","name":"Matrix.vecMul·µ£_eq","isProp":true,"docString":"This can be used to prove\n```lean\nexample [NonUnitalNonAssocSemiring Œ±] (a‚ÇÅ‚ÇÅ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÅ a‚ÇÇ‚ÇÇ b‚ÇÅ b‚ÇÇ : Œ±) :\n  vecMul ![b‚ÇÅ, b‚ÇÇ] !![a‚ÇÅ‚ÇÅ, a‚ÇÅ‚ÇÇ;\n                       a‚ÇÇ‚ÇÅ, a‚ÇÇ‚ÇÇ] = ![b‚ÇÅ*a‚ÇÅ‚ÇÅ + b‚ÇÇ*a‚ÇÇ‚ÇÅ, b‚ÇÅ*a‚ÇÅ‚ÇÇ + b‚ÇÇ*a‚ÇÇ‚ÇÇ] :=\n(vecMul·µ£_eq _ _).symm\n```\n"},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {R : Type u_2} [inst_1 : Semiring R] [inst_2 : MulSemiringAction M R] {S : Type u_3}\n  [inst_3 : Semiring S] [inst_4 : MulSemiringAction M S] (self : R ‚Üí+*[M] S),\n  MulActionHom.toFun (DistribMulActionHom.toMulActionHom (MulSemiringActionHom.toDistribMulActionHom self)) 1 = 1","name":"MulSemiringActionHom.map_one'","isProp":true,"docString":"The proposition that the function preserves 1 "},{"type":"‚àÄ {R : Type v} [inst : CommRing R] {n : ‚Ñï} (A : Matrix (Fin (Nat.succ n)) (Fin (Nat.succ n)) R) (j : Fin (Nat.succ n)),\n  Matrix.det A =\n    Finset.sum Finset.univ fun (i : Fin (Nat.succ n)) ‚Ü¶\n      (-1) ^ (‚Üëi + ‚Üëj) * A i j * Matrix.det (Matrix.submatrix A ‚Üë(Fin.succAbove i) ‚Üë(Fin.succAbove j))","name":"Matrix.det_succ_column","isProp":true,"docString":"Laplacian expansion of the determinant of an `n+1 √ó n+1` matrix along column `j`. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} {z : M} (hy : SameRay R x y) (hz : SameRay R x z), SameRay R x (y + z)","name":"SameRay.add_right","isProp":true,"docString":"If `y` and `z` are on the same ray as `x`, then so is `y + z`. "},{"type":"‚àÄ (G : Type u) [inst : AddGroup G] [us : UniformSpace G] [inst_1 : UniformAddGroup G]\n  [inst_2 : TopologicalSpace.FirstCountableTopology G] (N : AddSubgroup G) [inst_3 : AddSubgroup.Normal N]\n  [hG : CompleteSpace G], CompleteSpace (G ‚ß∏ N)","name":"QuotientAddGroup.completeSpace","isProp":true,"docString":"The quotient `G ‚ß∏ N` of a complete first countable uniform additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. In constrast to `QuotientAddGroup.completeSpace'`, in this version\n`G` is already equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G ‚ß∏ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalAddGroup.to_uniformSpace`.\nIn the most common use case ‚îÄ quotients of normed additive commutative groups by subgroups ‚îÄ\nsignificant care was taken so that the uniform structure inherent in that setting coincides\n(definitionally) with the uniform structure provided here."},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} {v : V} {s : Set Œπ} {p : (a : Œπ) ‚Üí P},\n  (‚àÉ (fs : Finset Œπ),\n        ‚àÉ (x : ‚Üëfs ‚äÜ s),\n          ‚àÉ (w : (a : Œπ) ‚Üí k), ‚àÉ (x : (Finset.sum fs fun (i : Œπ) ‚Ü¶ w i) = 0), v = ‚Üë(Finset.weightedVSub fs p) w :\n      Prop) ‚Üî\n    (‚àÉ (fs : Finset ‚Üës),\n        ‚àÉ (w : (a : ‚Üës) ‚Üí k),\n          ‚àÉ (x : (Finset.sum fs fun (i : ‚Üës) ‚Ü¶ w i) = 0), v = ‚Üë(Finset.weightedVSub fs fun (i : ‚Üës) ‚Ü¶ p ‚Üëi) w :\n      Prop)","name":"Finset.eq_weightedVSub_subset_iff_eq_weightedVSub_subtype","isProp":true,"docString":"Suppose an indexed family of points is given, along with a subset\nof the index type.  A vector can be expressed as `weightedVSub` using\na `Finset` lying within that subset and with sum of weights 0 if and\nonly if it can be expressed as `weightedVSub` with sum of weights 0\nfor the corresponding indexed family whose index type is the subtype\ncorresponding to that subset. "},{"type":"‚àÄ {Œ± : Type u_1} {ùïú : Type u_2} [inst : NormedField ùïú] {l : Filter Œ±} {u : (a : Œ±) ‚Üí ùïú} {v : (a : Œ±) ‚Üí ùïú}\n  (a : u =o[l] v), ‚àÉ (œÜ : (a : Œ±) ‚Üí ùïú), ‚àÉ (_hœÜ : Filter.Tendsto œÜ l (nhds 0)), u =·∂†[l] œÜ * v","name":"Asymptotics.IsLittleO.exists_eq_mul","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_iff_exists_eq_mul`."},{"type":"‚àÄ {Œ± : Type u_1} {s : Multiset Œ±} {x : Multiset Œ± √ó Multiset Œ±},\n  (x ‚àà Multiset.antidiagonal s : Prop) ‚Üî (Prod.fst x + Prod.snd x = s : Prop)","name":"Multiset.mem_antidiagonal","isProp":true,"docString":"A pair `(t‚ÇÅ, t‚ÇÇ)` of multisets is contained in `antidiagonal s`\nif and only if `t‚ÇÅ + t‚ÇÇ = s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h1 : a ‚â§ b) (h2 : b ‚â§ a), a ‚©ø b","name":"LE.le.wcovby_of_le","isProp":true,"docString":"**Alias** of `wcovby_of_le_of_le`."},{"type":"‚àÄ {R : Type u_1} [inst : MulOneClass R], IsRegular 1","name":"isRegular_one","isProp":true,"docString":"If multiplying by `1` on either side is the identity, `1` is regular. "},{"type":"‚àÄ (p : Prop) [inst : Decidable (p : Prop)], (p : Prop) ‚à® (¬¨(p : Prop) : Prop)","name":"dec_em","isProp":true,"docString":"**Alias** of `Decidable.em`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ≤) ‚Üí Œ≥} (hf : Continuous f), Continuous fun (x : Œ± √ó Œ≤) ‚Ü¶ f (Prod.snd x)","name":"Continuous.snd'","isProp":true,"docString":"Precomposing `f` with `Prod.snd` is continuous "},{"type":"‚àÄ {M : Type u} [self : AddCancelCommMonoid M] (a : M) (b : M), a + b = b + a","name":"AddCancelCommMonoid.add_comm","isProp":true,"docString":"Addition is commutative in an additive commutative semigroup. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] [inst_1 : HasDistribNeg R], (-1) ^ 2 = 1","name":"neg_one_pow_two","isProp":true,"docString":"**Alias** of `neg_one_sq`."},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} (a1 : Vector Œ± n) (a2 : Vector Œ± n) (a : Vector.toList a1 = Vector.toList a2), a1 = a2","name":"Vector.eq","isProp":true,"docString":"Vector is determined by the underlying list. "},{"type":"‚àÄ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R} (a_1 : b ‚â† 0), ¬¨(EuclideanDomain.r (a * b) a : Prop)","name":"EuclideanDomain.mul_left_not_lt","isProp":true,"docString":"An additional constraint on `r`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] {f : ZeroHom M N} {g : ZeroHom M N},\n  (f = g : Prop) ‚Üî (‚àÄ (x : M), ‚Üëf x = ‚Üëg x : Prop)","name":"ZeroHom.ext_iff","isProp":true,"docString":"Deprecated: use `FunLike.ext_iff` instead."},{"type":"‚àÄ {Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hf : Function.IsFixedPt f x) (h : Function.LeftInverse g f),\n  Function.IsFixedPt g x","name":"Function.IsFixedPt.to_leftInverse","isProp":true,"docString":"If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\npoint of `g`. "},{"type":"‚àÄ {R : Type u_1} (Œπ : Type u_2) [inst : LinearOrderedField R] [inst_1 : Fintype Œπ],\n  ‚Üë(ClosureOperator.toOrderHom (convexHull R)) (Set.range fun (i : Œπ) (j : Œπ) ‚Ü¶ if (i = j : Prop) then 1 else 0) =\n    stdSimplex R Œπ","name":"convexHull_basis_eq_stdSimplex","isProp":true,"docString":"`stdSimplex ùïú Œπ` is the convex hull of the canonical basis in `Œπ ‚Üí ùïú`. "},{"type":"‚àÄ {Œπ : Type u_1} {A : (a : Œπ) ‚Üí Type u_2} [inst : AddMonoid Œπ] [self : GradedMonoid.GMonoid A] (n : ‚Ñï)\n  (a : GradedMonoid A),\n  GradedMonoid.mk (Nat.succ n ‚Ä¢ Sigma.fst a) (GradedMonoid.GMonoid.gnpow (Nat.succ n) (Sigma.snd a)) =\n    a * { fst := n ‚Ä¢ Sigma.fst a, snd := GradedMonoid.GMonoid.gnpow n (Sigma.snd a) }","name":"GradedMonoid.GMonoid.gnpow_succ'","isProp":true,"docString":"Successor powers behave as expected "},{"type":"‚àÄ {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} [inst : DecidablePred p] {s : Finset Œ±}\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s), ¬¨(p x : Prop)), Finset.filter p s = ‚àÖ","name":"Finset.filter_false_of_mem","isProp":true,"docString":"If all elements of a `Finset` fail to satisfy the predicate `p`, `s.filter p` is `‚àÖ`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±}, (¬¨(Set.Nonempty s : Prop) : Prop) ‚Üî (s = ‚àÖ : Prop)","name":"Set.not_nonempty_iff_eq_empty","isProp":true,"docString":"See also `Set.nonempty_iff_ne_empty`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] [inst_1 : Preorder M]\n  [inst_2 : CovariantClass M M (Function.swap fun (x : M) (x_1 : M) ‚Ü¶ x + x_1) fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1]\n  [inst_3 : CovariantClass M M (fun (x : M) (x_1 : M) ‚Ü¶ x + x_1) fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {l‚ÇÅ : List M}\n  {l‚ÇÇ : List M} (h : List.Sublist l‚ÇÅ l‚ÇÇ) (h‚ÇÅ : ‚àÄ (a : M) (a_1 : a ‚àà l‚ÇÇ), 0 ‚â§ a), List.sum l‚ÇÅ ‚â§ List.sum l‚ÇÇ","name":"List.Sublist.sum_le_sum","isProp":true,"docString":"If `l‚ÇÅ` is a sublist of `l‚ÇÇ` and all elements of `l‚ÇÇ` are nonnegative,\nthen `l‚ÇÅ.sum ‚â§ l‚ÇÇ.sum`.\nOne can prove a stronger version assuming `‚àÄ a ‚àà l‚ÇÇ.diff l‚ÇÅ, 0 ‚â§ a` instead of `‚àÄ a ‚àà l‚ÇÇ, 0 ‚â§ a`\nbut this lemma is not yet in `mathlib`."},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] (a : E) (b : E), ‚Äña‚Äñ‚Çä ‚â§ ‚Äñb‚Äñ‚Çä + ‚Äña - b‚Äñ‚Çä","name":"nnnorm_le_insert'","isProp":true,"docString":"**Alias** of `nnnorm_le_nnnorm_add_nnnorm_sub'`."},{"type":"‚àÄ {Œπ : Type u_2} {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : CompleteSpace E] {f : (a : Œπ) ‚Üí E}\n  (g : (a : Œπ) ‚Üí ‚Ñù) (hg : Summable g) (h : ‚àÄ (i : Œπ), ‚Äñf i‚Äñ ‚â§ g i), Summable f","name":"summable_of_norm_bounded","isProp":true,"docString":"The direct comparison test for series:  if the norm of `f` is bounded by a real function `g`\nwhich is summable, then `f` is summable. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] {Œπ : Type u_1} {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±}\n  {p : Filter Œπ},\n  (TendstoUniformly F f p : Prop) ‚Üî\n    (‚àÄ (Œµ : ENNReal) (a : Œµ > 0), Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (x : Œ≤), edist (f x) (F n x) < Œµ) p : Prop)","name":"EMetric.tendstoUniformly_iff","isProp":true,"docString":"Expressing uniform convergence using `edist`. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {x : Œ± √ó Bool}, (FreeGroup.Red [x] L‚ÇÅ : Prop) ‚Üî (L‚ÇÅ = [x] : Prop)","name":"FreeGroup.Red.singleton_iff","isProp":true,"docString":"A letter only reduces to itself. "},{"type":"‚àÄ {A : Type u_1} [inst : Add A] [inst_1 : LinearOrder A]\n  [inst_2 : CovariantClass A A (fun (x : A) (x_1 : A) ‚Ü¶ x + x_1) fun (x : A) (x_1 : A) ‚Ü¶ x ‚â§ x_1]\n  [inst_3 : CovariantClass A A (Function.swap fun (x : A) (x_1 : A) ‚Ü¶ x + x_1) fun (x : A) (x_1 : A) ‚Ü¶ x < x_1]\n  [inst_4 : ContravariantClass A A (fun (x : A) (x_1 : A) ‚Ü¶ x + x_1) fun (x : A) (x_1 : A) ‚Ü¶ x ‚â§ x_1], UniqueSums A","name":"Covariants.to_uniqueSums","isProp":true,"docString":"This instance asserts that if `A` has an addition, a linear order, and addition\nis 'very monotone', then `A` also has `UniqueSums`."},{"type":"‚àÄ {ùïú : Type u_2} {M : Type u_1} [inst : LinearOrderedSemifield ùïú] [inst_1 : OrderedAddCommMonoid M]\n  [inst_2 : MulActionWithZero ùïú M] (h : ‚àÄ ‚¶Éa : M‚¶Ñ ‚¶Éb : M‚¶Ñ ‚¶Éc : ùïú‚¶Ñ (a_1 : a < b) (a_2 : 0 < c), c ‚Ä¢ a ‚â§ c ‚Ä¢ b),\n  OrderedSMul ùïú M","name":"OrderedSMul.mk'","isProp":true,"docString":"To prove that a vector space over a linear ordered field is ordered, it suffices to verify only\nthe first axiom of `OrderedSMul`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.ConcreteCategory C],\n  CategoryTheory.Faithful CategoryTheory.ConcreteCategory.Forget","name":"CategoryTheory.ConcreteCategory.forget_faithful","isProp":true,"docString":"That functor is faithful "},{"type":"‚àÄ {K : Type u} [inst : Field K] (self : Subfield K) (x : K)\n  (a :\n    x ‚àà\n      Subsemigroup.carrier\n        (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid (Subring.toSubsemiring (Subfield.toSubring self))))),\n  x‚Åª¬π ‚àà\n    Subsemigroup.carrier\n      (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid (Subring.toSubsemiring (Subfield.toSubring self))))","name":"Subfield.inv_mem'","isProp":true,"docString":"A subfield is closed under multiplicative inverses. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (a : Œ±) (ùíú : Finset (Finset Œ±)),\n  Down.compression a (Down.compression a ùíú) = Down.compression a ùíú","name":"Down.compression_idem","isProp":true,"docString":"Down-compressing a family is idempotent. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CircularPartialOrder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : btw a b c) (a_2 : btw c b a),\n  (a = b : Prop) ‚à® ((b = c : Prop) ‚à® (c = a : Prop) : Prop)","name":"CircularPartialOrder.btw_antisymm","isProp":true,"docString":"If `b` is between `a` and `c` and also between `c` and `a`, then at least one pair of points\namong `a`, `b`, `c` are identical. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : Nonempty J]\n  (h : ‚àÄ (j‚ÇÅ : J) (j‚ÇÇ : J), CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ), CategoryTheory.IsConnected J","name":"CategoryTheory.zigzag_isConnected","isProp":true,"docString":"If any two objects in an nonempty category are related by `zigzag`, the category is connected.\n"},{"type":"‚àÄ {r : ‚Ñï} {n : ‚Ñï} (h : r < n / 2), Nat.choose n r ‚â§ Nat.choose n (r + 1)","name":"Nat.choose_le_succ_of_lt_half_left","isProp":true,"docString":"Show that `Nat.choose` is increasing for small values of the right argument. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ‚âÉ+* S),\n  ‚Üë‚Üëf = MulEquiv.toMonoidHom ‚Üëf","name":"RingEquiv.toMonoidHom_commutes","isProp":true,"docString":"The two paths coercion can take to an `MonoidHom` are equivalent "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {x : R}, star x = x","name":"star_id_of_comm","isProp":true,"docString":"Note that since `starSemigroupOfComm` is reducible, `simp` can already prove this. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (a : Set.Nonempty (closure s)), Set.Nonempty s","name":"Set.Nonempty.of_closure","isProp":true,"docString":"**Alias** of the forward direction of `closure_nonempty_iff`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} {Z : C} {œÄ : Y ‚ü∂ Z}\n  (self : CategoryTheory.IsSplitCoequalizer f g œÄ), f ‚â´ œÄ = g ‚â´ œÄ","name":"CategoryTheory.IsSplitCoequalizer.condition","isProp":true,"docString":"Composition of `œÄ` with `f` and with `g` agree "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±], Filter.Tendsto abs Filter.atBot Filter.atTop","name":"Filter.tendsto_abs_atBot_atTop","isProp":true,"docString":"$\\lim_{x\\to-\\infty}|x|=+\\infty$ "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : (a : C) ‚Üí D}\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] (X : C),\n  CategoryTheory.Iso.hom (Œª_ (F X)) =\n    (CategoryTheory.LaxMonoidal.Œµ ‚äó ùüô (F X)) ‚â´\n      CategoryTheory.LaxMonoidal.Œº (ùüô_ C) X ‚â´ CategoryTheory.map F (CategoryTheory.Iso.hom (Œª_ X))","name":"CategoryTheory.LaxMonoidal.left_unitality","isProp":true,"docString":"left unitality "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (a : Dense (closure s)), Dense s","name":"Dense.of_closure","isProp":true,"docString":"**Alias** of the forward direction of `dense_closure`."},{"type":"‚àÄ (a : Cardinal), Cardinal.lift a = a","name":"Cardinal.lift_uzero","isProp":true,"docString":"A cardinal lifted to the zero universe equals itself. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] [inst_2 : Nonempty Œ±]\n  [inst_3 : Encodable Œ≤] {f : (a : Œ≤) ‚Üí Set Œ±} (hc : ‚àÄ (s : Œ≤), IsClosed (f s))\n  (hU : (Set.union·µ¢ fun (s : Œ≤) ‚Ü¶ f s) = Set.univ), ‚àÉ (s : Œ≤), Set.Nonempty (interior (f s))","name":"nonempty_interior_of_union·µ¢_of_closed","isProp":true,"docString":"One of the most useful consequences of Baire theorem: if a countable union of closed sets\ncovers the space, then one of the sets has nonempty interior. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  [inst_2 : Subsingleton Œ±], Isometry f","name":"isometry_subsingleton","isProp":true,"docString":"Any map on a subsingleton is an isometry "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤}\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ} (h : TendstoUniformlyOn F f p s) (g : (a : Œ≥) ‚Üí Œ±),\n  TendstoUniformlyOn (fun (n : Œπ) ‚Ü¶ F n ‚àò g) (f ‚àò g) p (g ‚Åª¬π' s)","name":"TendstoUniformlyOn.comp","isProp":true,"docString":"Composing on the right by a function preserves uniform convergence on a set "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 :\n    ‚àÄ {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)],\n  CategoryTheory.Limits.HasEqualizers C","name":"CategoryTheory.Limits.hasEqualizers_of_hasLimit_parallelPair","isProp":true,"docString":"If `C` has all limits of diagrams `parallelPair f g`, then it has all equalizers "},{"type":"‚àÄ {S : Type u_2} {R : Type u_3} {A : Type u_4} {N : Type u_1} [inst : Semiring S] [inst_1 : AddCommMonoid R]\n  [inst_2 : AddCommMonoid A] [inst_3 : AddCommMonoid N] [inst_4 : Module S R] [inst_5 : Module S A]\n  [inst_6 : Module S N] ‚¶Éf : Unitization R A ‚Üí‚Çó[S] N‚¶Ñ ‚¶Ég : Unitization R A ‚Üí‚Çó[S] N‚¶Ñ\n  (hl : ‚àÄ (r : R), ‚Üëf (Unitization.inl r) = ‚Üëg (Unitization.inl r)) (hr : ‚àÄ (a : A), ‚Üëf ‚Üëa = ‚Üëg ‚Üëa), f = g","name":"Unitization.linearMap_ext","isProp":true,"docString":"This cannot be marked `@[ext]` as it ends up being used instead of `LinearMap.prod_ext` when\nworking with `R √ó A`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] [self : MeasurableSingletonClass Œ±] (x : Œ±), MeasurableSet {x}","name":"MeasurableSingletonClass.measurableSet_singleton","isProp":true,"docString":"A singleton is a measurable set. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {F‚ÇÅ : C·µí·µñ ‚•§ Type v} {F‚ÇÇ : C·µí·µñ ‚•§ Type v} (Œ± : F‚ÇÅ ‚ü∂ F‚ÇÇ),\n  CategoryTheory.Functor.op (CategoryTheory.CategoryOfElements.map Œ±) ‚ãô\n      CategoryTheory.CategoryOfElements.toCostructuredArrow F‚ÇÇ =\n    CategoryTheory.CategoryOfElements.toCostructuredArrow F‚ÇÅ ‚ãô CategoryTheory.CostructuredArrow.map Œ±","name":"CategoryTheory.CategoryOfElements.costructuredArrow_yoneda_equivalence_naturality","isProp":true,"docString":"The equivalence `(-.Elements)·µí·µñ ‚âÖ (yoneda, -)` of is actually a natural isomorphism of functors.\n"},{"type":"Fact (1 ‚â§ 2 : Prop)","name":"fact_one_le_two_ennreal","isProp":true,"docString":"`(1 : ‚Ñù‚â•0‚àû) ‚â§ 2`, recorded as a `Fact` for use with `Lp` spaces. "},{"type":"‚àÄ {S : Set ‚Ñï} (hb : 0 ‚àà S) (h_ind : ‚àÄ (k : ‚Ñï) (a : k ‚àà S), k + 1 ‚àà S) (n : ‚Ñï), n ‚àà S","name":"Nat.set_induction","isProp":true,"docString":"A subset of `‚Ñï` containing zero and closed under `Nat.succ` contains all of `‚Ñï`. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (f : (a : ‚Ñï) ‚Üí R)\n  (g : (a : ‚Ñï) ‚Üí M) {m : ‚Ñï} {n : ‚Ñï} (hmn : m < n),\n  (Finset.sum (Finset.Ico m n) fun (i : ‚Ñï) ‚Ü¶ f i ‚Ä¢ g i) =\n    ((f (n - 1) ‚Ä¢ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ g i) -\n        f m ‚Ä¢ Finset.sum (Finset.range m) fun (i : ‚Ñï) ‚Ü¶ g i) -\n      Finset.sum (Finset.Ico m (n - 1)) fun (i : ‚Ñï) ‚Ü¶\n        (f (i + 1) - f i) ‚Ä¢ Finset.sum (Finset.range (i + 1)) fun (i : ‚Ñï) ‚Ü¶ g i","name":"Finset.sum_Ico_by_parts","isProp":true,"docString":"**Summation by parts**, also known as **Abel's lemma** or an **Abel transformation** "},{"type":"‚àÄ {Œì : Type u_1} [inst : Group Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Œì T]\n  [inst_3 : Finite Œì], ProperlyDiscontinuousSMul Œì T","name":"Finite.to_properlyDiscontinuousSMul","isProp":true,"docString":"A finite group action is always properly discontinuous. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±·µí·µà} {b : Œ±·µí·µà} (a_1 : b ‚â§ a), ‚ÜëOrderDual.ofDual a ‚â§ ‚ÜëOrderDual.ofDual b","name":"LE.le.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `OrderDual.ofDual_le_ofDual`."},{"type":"‚àÄ {a : ‚Ñù} {b : ‚Ñù} (h : a < b), Cardinal.mk ‚Üë(Set.Ioc a b) = Cardinal.continuum","name":"Cardinal.mk_Ioc_real","isProp":true,"docString":"The cardinality of the interval (a, b]. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasLimits C],\n  CategoryTheory.Limits.HasColimits C·µí·µñ","name":"CategoryTheory.Limits.hasColimits_op_of_hasLimits","isProp":true,"docString":"If `C` has limits, we can construct colimits for `C·µí·µñ`.\n"},{"type":"‚àÄ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a","name":"pow_two","isProp":true,"docString":"Note that most of the lemmas about powers of two refer to it as `sq`. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ‚Üí+* S) (s : Set R),\n  Subsemiring.map f (Subsemiring.closure s) = Subsemiring.closure (‚Üëf '' s)","name":"RingHom.map_closureS","isProp":true,"docString":"The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. "},{"type":"‚àÄ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_5} {V2 : Type u_3} {P2 : Type u_4} [inst : Ring k]\n  [inst_1 : AddCommGroup V1] [inst_2 : Module k V1] [inst_3 : AddTorsor V1 P1] [inst_4 : AddCommGroup V2]\n  [inst_5 : Module k V2] [inst_6 : AddTorsor V2 P2] (f : (a : P1) ‚Üí P2) (linear : V1 ‚Üí‚Çó[k] V2)\n  (add : ‚àÄ (p : P1) (v : V1), f (v +·µ• p) = ‚Üëlinear v +·µ• f p), ‚Üë{ toFun := f, linear := linear, map_vadd' := add } = f","name":"AffineMap.coe_mk","isProp":true,"docString":"Constructing an affine map and coercing back to a function\nproduces the same map. "},{"type":"‚àÄ {k : Type u_1} {V1 : Type u_2} {V2 : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\n  [inst_3 : AddCommGroup V2] [inst_4 : Module k V2] (f : V1 ‚Üí·µÉ[k] V2), ‚Üëf = ‚Üë(AffineMap.linear f) + fun (x : V1) ‚Ü¶ ‚Üëf 0","name":"AffineMap.decomp","isProp":true,"docString":"Decomposition of an affine map in the special case when the point space and vector space\nare the same. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {Y : C} [inst_1 : CategoryTheory.Limits.HasInitial C] (f : Y ‚ü∂ ‚ä•_ C),\n  CategoryTheory.IsSplitEpi f","name":"CategoryTheory.Limits.initial.isSplitEpi_to","isProp":true,"docString":"Any morphism to an initial object is split epi. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : CategoryTheory.Presieve X)\n  [inst_1 : CategoryTheory.Limits.HasPullbacks C] (x : CategoryTheory.Equalizer.FirstObj P R),\n  (CategoryTheory.Presieve.FamilyOfElements.Compatible\n        (CategoryTheory.Iso.hom (CategoryTheory.Equalizer.firstObjEqFamily P R) x) :\n      Prop) ‚Üî\n    (CategoryTheory.Equalizer.Presieve.firstMap P R x = CategoryTheory.Equalizer.Presieve.secondMap P R x : Prop)","name":"CategoryTheory.Equalizer.Presieve.compatible_iff","isProp":true,"docString":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : CanonicallyOrderedCommSemiring Œ±] [inst_1 : Nontrivial Œ±] {l : List Œ±},\n  (0 < List.prod l : Prop) ‚Üî (‚àÄ (x : Œ±) (a : x ‚àà l), 0 < x : Prop)","name":"CanonicallyOrderedCommSemiring.list_prod_pos","isProp":true,"docString":"A variant of `List.prod_pos` for `CanonicallyOrderedCommSemiring`. "},{"type":"‚àÄ {R : Type u_3} [inst : CommSemiring R] {l : Type u_2} {m : Type u_1} {n : Type u_4} [inst_1 : Fintype n]\n  [inst_2 : DecidableEq n] [inst_3 : Fintype m] [inst_4 : DecidableEq m] (M : Matrix l m R) (N : Matrix m n R)\n  (x : (a : n) ‚Üí R), ‚Üë(‚ÜëMatrix.toLin' (Matrix.mul M N)) x = ‚Üë(‚ÜëMatrix.toLin' M) (‚Üë(‚ÜëMatrix.toLin' N) x)","name":"Matrix.toLin'_mul_apply","isProp":true,"docString":"Shortcut lemma for `Matrix.toLin'_mul` and `LinearMap.comp_apply` "},{"type":"‚àÄ {Œπ : Type u_1} {M : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí Monoid (M i)] (self : FreeProduct.Word M),\n  List.Chain' (fun (l : (i : Œπ) √ó M i) (l' : (i : Œπ) √ó M i) ‚Ü¶ Sigma.fst l ‚â† Sigma.fst l') (FreeProduct.Word.toList self)","name":"FreeProduct.Word.chain_ne","isProp":true,"docString":"Adjacent letters are not from the same summand. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] {f : R ‚Üí+* S} {s : S} (h : s ‚àà Set.range ‚Üëf),\n  ‚ÜëPolynomial.C s ‚àà Polynomial.lifts f","name":"Polynomial.C'_mem_lifts","isProp":true,"docString":"If `(s : S)` is in the image of `f`, then `C s` lifts. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalNonAssocRing Œ±] (k : Œ±) (h : ‚àÄ (x : Œ±) (a : k * x = 0), x = 0), IsLeftRegular k","name":"isLeftRegular_of_non_zero_divisor","isProp":true,"docString":"Left `Mul` by a `k : Œ±` over `[Ring Œ±]` is injective, if `k` is not a zero divisor.\nThe typeclass that restricts all terms of `Œ±` to have this property is `NoZeroDivisors`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_3} {F : Type u_1} [inst : OrderedRing ùïú] [inst_1 : TopologicalSpace E]\n  [inst_2 : TopologicalSpace F] [inst_3 : AddCommGroup E] [inst_4 : AddCommGroup F] [inst_5 : Module ùïú E]\n  [inst_6 : Module ùïú F] {s : Set F} (hs : StrictConvex ùïú s) {f : E ‚Üí·µÉ[ùïú] F} (hf : Continuous ‚Üëf)\n  (hfinj : Function.Injective ‚Üëf), StrictConvex ùïú (‚Üëf ‚Åª¬π' s)","name":"StrictConvex.affine_preimage","isProp":true,"docString":"The preimage of a strictly convex set under an affine map is strictly convex. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} {v : V} {x : k} {s : Set Œπ} {p : (a : Œπ) ‚Üí P} {b : P},\n  (‚àÉ (fs : Finset Œπ),\n        ‚àÉ (x_1 : ‚Üëfs ‚äÜ s),\n          ‚àÉ (w : (a : Œπ) ‚Üí k),\n            ‚àÉ (x : (Finset.sum fs fun (i : Œπ) ‚Ü¶ w i) = x), v = ‚Üë(Finset.weightedVSubOfPoint fs p b) w :\n      Prop) ‚Üî\n    (‚àÉ (fs : Finset ‚Üës),\n        ‚àÉ (w : (a : ‚Üës) ‚Üí k),\n          ‚àÉ (x : (Finset.sum fs fun (i : ‚Üës) ‚Ü¶ w i) = x),\n            v = ‚Üë(Finset.weightedVSubOfPoint fs (fun (i : ‚Üës) ‚Ü¶ p ‚Üëi) b) w :\n      Prop)","name":"Finset.eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype","isProp":true,"docString":"Suppose an indexed family of points is given, along with a subset\nof the index type.  A vector can be expressed as\n`weightedVSubOfPoint` using a `Finset` lying within that subset and\nwith a given sum of weights if and only if it can be expressed as\n`weightedVSubOfPoint` with that sum of weights for the\ncorresponding indexed family whose index type is the subtype\ncorresponding to that subset. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) (x : M), ‚Üëc x x","name":"Con.refl","isProp":true,"docString":"Congruence relations are reflexive. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : StrictOrderedSemiring Œ±] [inst_1 : Nontrivial Œ±] {t : ‚Üë(Set.Ioc 0 1)}, t ‚â§ 1","name":"Set.Ioc.le_one","isProp":true,"docString":"like `coe_le_one`, but with the inequality in `Ioc (0:Œ±) 1`. "},{"type":"‚àÄ {Œ± : Type u_1} {Ixx : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Set Œ±} {l‚ÇÅ : Filter Œ±} {l‚ÇÇ : outParam (Filter Œ±)}\n  [self : Filter.TendstoIxxClass Ixx l‚ÇÅ l‚ÇÇ],\n  Filter.Tendsto (fun (p : Œ± √ó Œ±) ‚Ü¶ Ixx (Prod.fst p) (Prod.snd p)) (Filter.prod l‚ÇÅ l‚ÇÅ) (Filter.smallSets l‚ÇÇ)","name":"Filter.TendstoIxxClass.tendsto_Ixx","isProp":true,"docString":"`Function.uncurry Ixx` tends to `l‚ÇÇ.smallSets` along `l‚ÇÅ √ó·∂† l‚ÇÅ`. In other words, for any\n`s ‚àà l‚ÇÇ` there exists `t ‚àà l‚ÇÅ` such that `Ixx x y ‚äÜ s` whenever `x ‚àà t` and `y ‚àà t`.\n\nUse lemmas like `Filter.Tendsto.Icc` instead. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommMonoid Œ±] {Œ≤ : Type u_2} [inst_1 : Fintype Œ≤] (s : Set Œ≤)\n  [inst_2 : DecidablePred fun (x : Œ≤) ‚Ü¶ x ‚àà s] (f : (a : Œ≤) ‚Üí Œ±) (g : (a : ‚Üës) ‚Üí Œ±)\n  (w : ‚àÄ (x : Œ≤) (h : x ‚àà s), f x = g { val := x, property := h }) (w' : ‚àÄ (x : Œ≤) (a : ¬¨(x ‚àà s : Prop)), f x = 0),\n  Finset.sum Finset.univ f = Finset.sum Finset.univ g","name":"Finset.sum_congr_set","isProp":true,"docString":"The sum of a function `g` defined only on a set `s` is equal to\nthe sum of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 0` off `s`."},{"type":"‚àÄ {Œº : YoungDiagram} (self : Ssyt Œº) {i : ‚Ñï} {j1 : ‚Ñï} {j2 : ‚Ñï} (a : j1 < j2) (a : (i, j2) ‚àà Œº),\n  Ssyt.entry self i j1 ‚â§ Ssyt.entry self i j2","name":"Ssyt.row_weak'","isProp":true,"docString":"The entries in each row are weakly increasing (left to right). "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {u : Set Œ±} (hu : u ‚àà nhds x),\n  Filter.Eventually (fun (r : ‚Ñù) ‚Ü¶ Metric.closedBall x r ‚äÜ u) (nhds 0)","name":"eventually_closedBall_subset","isProp":true,"docString":"If `u` is a neighborhood of `x`, then for small enough `r`, the closed ball\n`Metric.closedBall x r` is contained in `u`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : LE Œ±] [inst_1 : LE Œ≤]\n  [self : OrderIsoClass F Œ± Œ≤] (f : F) {a : Œ±} {b : Œ±}, (‚Üëf a ‚â§ ‚Üëf b : Prop) ‚Üî (a ‚â§ b : Prop)","name":"OrderIsoClass.map_le_map_iff","isProp":true,"docString":"An order isomorphism respects `‚â§`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedAddMonoid Œ±] (a : Œ±) (b : Œ±), a ‚â§ a + b","name":"CanonicallyOrderedAddMonoid.le_self_add","isProp":true,"docString":"For any `a` and `b`, `a ‚â§ a + b` "},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±],\n  Continuous fun (p : Œ± √ó TopologicalSpace.Closeds Œ±) ‚Ü¶ EMetric.infEdist (Prod.fst p) ‚Üë(Prod.snd p)","name":"EMetric.continuous_infEdist_hausdorffEdist","isProp":true,"docString":"The edistance to a closed set depends continuously on the point and the set "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : RankCondition R] {M : Type v} [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  {Œπ : Type u_1} [inst_4 : Fintype Œπ] (b : Basis Œπ R M) {w : Set M} [inst_5 : Fintype ‚Üëw] (s : Submodule.span R w = ‚ä§),\n  Fintype.card Œπ ‚â§ Fintype.card ‚Üëw","name":"Basis.le_span''","isProp":true,"docString":"An auxiliary lemma for `Basis.le_span`.\n\nIf `R` satisfies the rank condition,\nthen for any finite basis `b : Basis Œπ R M`,\nand any finite spanning set `w : Set M`,\nthe cardinality of `Œπ` is bounded by the cardinality of `w`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (self : Ring.TotalPositiveCone Œ±) (a : Œ±),\n  (AddCommGroup.PositiveCone.nonneg (Ring.PositiveCone.toPositiveCone (Ring.TotalPositiveCone.toPositiveCone_1 self))\n        a :\n      Prop) ‚à®\n    (AddCommGroup.PositiveCone.nonneg (Ring.PositiveCone.toPositiveCone (Ring.TotalPositiveCone.toPositiveCone_1 self))\n        (-a) :\n      Prop)","name":"Ring.TotalPositiveCone.nonneg_total","isProp":true,"docString":"Either `a` or `-a` is `nonneg` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T1Space Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {a : Œ±} {b : Œ≤} (h : Filter.Tendsto f (nhds a) (nhds b)), f a = b","name":"eq_of_tendsto_nhds","isProp":true,"docString":"If a function to a `T1Space` tends to some limit `b` at some point `a`, then necessarily\n`b = f a`. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M} {d : Con M} (h : c ‚â§ d) (x : Con.Quotient c),\n  ‚Üë(Con.map c d h) x =\n    ‚Üë(Con.lift c (Con.mk' d)\n          (fun (x : M) ‚Ü¶ (_ : ‚àÄ (x_1 : M) (hc : ‚Üëc x x_1), ‚Üëx = ‚Üëx_1)=:‚àÄ (x : M) (x_1 : M) (hc : ‚Üëc x x_1), ‚Üëx = ‚Üëx_1))\n      x","name":"Con.map_apply","isProp":true,"docString":"Given congruence relations `c, d` on a monoid such that `d` contains `c`, the definition of\nthe homomorphism from the quotient by `c` to the quotient by `d` induced by `d`'s quotient\nmap. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±}, Metric.infDist x ‚àÖ = 0","name":"Metric.infDist_empty","isProp":true,"docString":"The minimal distance to the empty set is 0 (if you want to have the more reasonable\nvalue `‚àû` instead, use `EMetric.infEdist`, which takes values in `‚Ñù‚â•0‚àû`) "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasPushouts C","name":"CategoryTheory.Abelian.hasPushouts","isProp":true,"docString":"Any abelian category has pushouts "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid S] (p : Polynomial R)\n  {f : (a : ‚Ñï) ‚Üí (a : R) ‚Üí S} (h : ‚àÄ (n : ‚Ñï), f n 0 = 0),\n  Polynomial.sum p f = Finset.sum (Finset.range (Polynomial.natDegree p + 1)) fun (a : ‚Ñï) ‚Ü¶ f a (Polynomial.coeff p a)","name":"Polynomial.sum_over_range","isProp":true,"docString":"We can reexpress a sum over `p.support` as a sum over `range (p.natDegree + 1)`.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasKernel f] {Z : C} (h : Y ‚ü∂ Z) [inst_3 : CategoryTheory.Mono h],\n  CategoryTheory.Limits.kernelSubobject (f ‚â´ h) = CategoryTheory.Limits.kernelSubobject f","name":"CategoryTheory.Limits.kernelSubobject_comp_mono","isProp":true,"docString":"Postcomposing by an monomorphism does not change the kernel subobject. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] [inst_1 : OrderBot Œ±] {s : Finset Œ±} (hs : Set.Intersecting ‚Üës)\n  (h : ‚àÄ (t : Finset Œ±) (a : Set.Intersecting ‚Üët) (a : s ‚äÜ t), s = t), IsUpperSet ‚Üës","name":"Set.Intersecting.isUpperSet'","isProp":true,"docString":"Maximal intersecting families are upper sets. Finset version. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] [inst_1 : Preorder M] (L : List M) (h : List.prod L < 1), 0 < List.length L","name":"List.length_pos_of_prod_lt_one","isProp":true,"docString":"A list with product less than one must have positive length. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {R : C} {X : C} {Y : C} {Z : C} {a : R ‚ü∂ X} {b : R ‚ü∂ X} {f‚ÇÅ : X ‚ü∂ Y}\n  {f‚ÇÇ : Y ‚ü∂ Z} [inst_1 : CategoryTheory.Mono f‚ÇÇ] (big_k : CategoryTheory.IsKernelPair (f‚ÇÅ ‚â´ f‚ÇÇ) a b),\n  CategoryTheory.IsKernelPair f‚ÇÅ a b","name":"CategoryTheory.IsKernelPair.cancel_right_of_mono","isProp":true,"docString":"If `(a,b)` is a kernel pair for `f‚ÇÅ ‚â´ f‚ÇÇ` and `f‚ÇÇ` is mono, then `(a,b)` is a kernel pair for\njust `f‚ÇÅ`.\nThe converse of `comp_of_mono`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ±) ‚Üí M} {s : Set Œ±}\n  (hf : Set.Finite (s ‚à© Function.mulSupport f)) (hg : Set.Finite (s ‚à© Function.mulSupport g)),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i * g i) =\n    (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ g i","name":"finprod_mem_mul_distrib'","isProp":true,"docString":"A more general version of `finprod_mem_mul_distrib` that only requires `s ‚à© mulSupport f` and\n`s ‚à© mulSupport g` rather than `s` to be finite. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : SMul ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (hf : ConcaveOn ùïú s f) (c : E), ConcaveOn ùïú ((fun (z : E) ‚Ü¶ c + z) ‚Åª¬π' s) (f ‚àò fun (z : E) ‚Ü¶ c + z)","name":"ConcaveOn.translate_right","isProp":true,"docString":"Right translation preserves concavity. "},{"type":"‚àÄ {K : Type u} {V : Type v} {V‚ÇÅ : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : AddCommGroup V‚ÇÅ] [inst_4 : Module K V‚ÇÅ] (f : V ‚Üí‚Çó[K] V‚ÇÅ),\n  Module.rank K { x : V‚ÇÅ // x ‚àà LinearMap.range f } + Module.rank K { x : V // x ‚àà LinearMap.ker f } = Module.rank K V","name":"rank_range_add_rank_ker","isProp":true,"docString":"rank-nullity theorem "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  {i : (a : Œ±) ‚Üí Œ≤} [inst_2 : TopologicalSpace Œ≥] [inst_3 : T2Space Œ≥] {f : (a : Œ±) ‚Üí Œ≥} (di : DenseInducing i)\n  (hf : ‚àÄ (b : Œ≤), ‚àÉ (c : Œ≥), Filter.Tendsto f (Filter.comap i (nhds b)) (nhds c)) (a : Œ±),\n  DenseInducing.extend di f (i a) = f a","name":"DenseInducing.extend_eq'","isProp":true,"docString":"Variation of `extend_eq` where we ask that `f` has a limit along `comap i (ùìù b)` for each\n`b : Œ≤`. This is a strictly stronger assumption than continuity of `f`, but in a lot of cases\nyou'd have to prove it anyway to use `continuous_extend`, so this avoids doing the work twice. "},{"type":"‚àÄ (R : Type u_2) {M : Type u_3} (S : Type u_1) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (s : Set M) [inst_3 : Semiring S] [inst_4 : SMul R S] [inst_5 : Module S M] [inst_6 : IsScalarTower R S M],\n  ‚Üë(Submodule.span R s) ‚äÜ ‚Üë(Submodule.span S s)","name":"Submodule.span_subset_span","isProp":true,"docString":"A version of `submodule.span_le_restrict_scalars` with coercions. "},{"type":"‚àÄ {M : Type u_1} {B : Type u_2} [inst : AddMonoid M] [inst_1 : SetLike B M] [inst_2 : AddSubmonoidClass B M] {S : B}\n  {l : List M} (hl : ‚àÄ (x : M) (a : x ‚àà l), x ‚àà S), List.sum l ‚àà S","name":"list_sum_mem","isProp":true,"docString":"Sum of a list of elements in an `AddSubmonoid` is in the `AddSubmonoid`."},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {C : (a : Con.Quotient c) ‚Üí Prop} (q : Con.Quotient c)\n  (H : ‚àÄ (x : M), C ‚Üëx), C q","name":"Con.induction_on","isProp":true,"docString":"The inductive principle used to prove propositions about the elements of a quotient by a\ncongruence relation. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}\n  {y : (i : Œπ) ‚Üí Œ≤ i}, (hammingDist x y ‚â† 0 : Prop) ‚Üî (x ‚â† y : Prop)","name":"hammingDist_ne_zero","isProp":true,"docString":"Corresponds to `dist_ne_zero`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)\n  [inst_1 : CategoryTheory.Limits.HasPullback f g] [inst_2 : CategoryTheory.Limits.HasBinaryProduct X Y],\n  CategoryTheory.Mono\n    (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.pullback.fst CategoryTheory.Limits.pullback.snd)","name":"CategoryTheory.Limits.mono_pullback_to_prod","isProp":true,"docString":"The map `X √ó[Z] Y ‚ü∂ X √ó Y` is mono. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {D : Type u} [inst_1 : CategoryTheory.Category D] (G : D ‚•§ C)\n  [inst_2 : CategoryTheory.IsRightAdjoint G], CategoryTheory.SolutionSetCondition G","name":"CategoryTheory.solutionSetCondition_of_isRightAdjoint","isProp":true,"docString":"If `G : D ‚•§ C` is a right adjoint it satisfies the solution set condition.  "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] (a : Œ±) (b : Œ±), Filter.comap Subtype.val (nhdsWithin b (Set.Iio b)) = Filter.atTop","name":"comap_coe_Ioo_nhdsWithin_Iio","isProp":true,"docString":"The `atTop` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at\nthe right endpoint in the ambient order. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedSemifield Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atTop : Prop) ‚Üî (Filter.Tendsto f l Filter.atTop : Prop)","name":"Filter.tendsto_mul_const_atTop_of_pos","isProp":true,"docString":"If `r` is a positive constant, then `Œª x, f x * r` tends to infinity along a filter if and only\nif `f` tends to infinity along the same filter. "},{"type":"‚àÄ {R : Type u} {L : Type v} {M : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : LieRingModule L M] [self : LieModule R L M] (t : R) (x : L)\n  (m : M), ‚ÅÖx, t ‚Ä¢ m‚ÅÜ = t ‚Ä¢ ‚ÅÖx, m‚ÅÜ","name":"LieModule.lie_smul","isProp":true,"docString":"A Lie module bracket is compatible with scalar multiplication in its second argument. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ}, TendstoUniformlyOn F f p ‚àÖ","name":"tendstoUniformlyOn_empty","isProp":true,"docString":"Uniform convergence on the empty set is vacuously true "},{"type":"‚àÄ {a : Prop} {b : Prop} (self : (a : Prop) ‚Üî (b : Prop)) (a_1 : b), a","name":"Iff.mpr","isProp":true,"docString":"Modus ponens for if and only if, reversed. If `a ‚Üî b` and `b`, then `a`. "},{"type":"‚àÄ {Œ± : Type u_1} {m : Type u_2} {R : Type v} [inst : CommRing R] {M : Matrix m m R} {b : (a : m) ‚Üí Œ±}\n  [inst_1 : DecidableEq m] [inst_2 : Fintype m] [inst_3 : LinearOrder Œ±] [inst_4 : Invertible M]\n  (hM : Matrix.BlockTriangular M b), Matrix.BlockTriangular M‚Åª¬π b","name":"Matrix.blockTriangular_inv_of_blockTriangular","isProp":true,"docString":"The inverse of a block-triangular matrix is block-triangular. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Finite Œ±] {f : (a : Œ±) ‚Üí Œ≤} (e : Œ± ‚âÉ Œ≤) (a : Function.Injective f),\n  Function.Surjective f","name":"Function.Injective.surjective_of_fintype","isProp":true,"docString":"**Alias** of the forward direction of `Finite.injective_iff_surjective_of_equiv`."},{"type":"‚àÄ {Œ± : Type u_1} [self : CircularOrder Œ±] (a : Œ±) (b : Œ±) (c : Œ±), (btw a b c : Prop) ‚à® (btw c b a : Prop)","name":"CircularOrder.btw_total","isProp":true,"docString":"For any triple of points, the second is between the other two one way or another. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : LocallyFiniteOrderTop Œ±] (a : Œ±) (x : Œ±),\n  (x ‚àà LocallyFiniteOrderTop.finsetIci a : Prop) ‚Üî (a ‚â§ x : Prop)","name":"LocallyFiniteOrderTop.finset_mem_Ici","isProp":true,"docString":"`x ‚àà finsetIci a ‚Üî a ‚â§ x` "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  [inst_3 : Invertible A], ‚ÖüA = A‚Åª¬π","name":"Matrix.invOf_eq_nonsing_inv","isProp":true,"docString":"The nonsingular inverse is the same as `invOf` when `A` is invertible. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : ‚àÄ (i : Œπ), Infinite (œÄ i)] [inst : Nonempty Œπ],\n  Infinite ((i : Œπ) ‚Üí œÄ i)","name":"Pi.infinite_of_right","isProp":true,"docString":"See `Pi.infinite_of_exists_right` for the case that only one `œÄ i` is infinite. "},{"type":"‚àÄ {G : Type u_1} [inst : Add G] [self : UniqueSums G] {A : Finset G} {B : Finset G} (x : Finset.Nonempty A)\n  (x : Finset.Nonempty B),\n  ‚àÉ (a0 : G), (a0 ‚àà A : Prop) ‚àß (‚àÉ (b0 : G), (b0 ‚àà B : Prop) ‚àß (UniqueAdd A B a0 b0 : Prop) : Prop)","name":"UniqueSums.uniqueAdd_of_nonempty","isProp":true,"docString":"For `A B` two nonempty finite sets, there always exist `a0 ‚àà A, b0 ‚àà B` such that\n`UniqueAdd A B a0 b0` "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {N : outParam (Type u_3)} [inst : Add M] [inst_1 : Add N]\n  [self : AddHomClass F M N] (f : F) (x : M) (y : M), ‚Üëf (x + y) = ‚Üëf x + ‚Üëf y","name":"AddHomClass.map_add","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {P : (a : EReal) ‚Üí (a : EReal) ‚Üí Prop} (symm : Symmetric P)\n  (neg_left : ‚àÄ {x : EReal} {y : EReal} (a : P x y), P (-x) y) (top_top : P ‚ä§ ‚ä§)\n  (top_pos : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚ä§ ‚Üëx) (top_zero : P ‚ä§ 0) (coe_coe : ‚àÄ (x : ‚Ñù) (y : ‚Ñù), P ‚Üëx ‚Üëy) (x : EReal)\n  (y : EReal), P x y","name":"EReal.induction‚ÇÇ_symm_neg","isProp":true,"docString":"Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that `P` is symmetric and `P x y` implies\n`P (-x) y` for all `x`, `y`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (x : Œ±) (C : Set Œ±),\n  (AccPt x (Filter.principal C) : Prop) ‚Üî\n    (Filter.Frequently (fun (y : Œ±) ‚Ü¶ (y ‚â† x : Prop) ‚àß (y ‚àà C : Prop)) (nhds x) : Prop)","name":"accPt_iff_frequently","isProp":true,"docString":"`x` is an accumulation point of a set `C` iff\nthere are points near `x` in `C` and different from `x`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Add Œ±] [inst_1 : Add Œ≤] {Œ≥ : Type u_1} [inst_2 : Add Œ≥] {f : (a : Œ±) ‚Üí Œ≤}\n  {g : (a : Œ≤) ‚Üí Œ≥} (hf : IsAddHom f) (hg : IsAddHom g), IsAddHom (g ‚àò f)","name":"IsAddHom.comp","isProp":true,"docString":"The composition of addition preserving maps also preserves addition"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Nontrivial Œ±], Nonempty Œ±","name":"Nontrivial.to_nonempty","isProp":true,"docString":"See Note [lower instance priority]\n\nNote that since this and `nonempty_of_inhabited` are the most \"obvious\" way to find a nonempty\ninstance if no direct instance can be found, we give this a higher priority than the usual `100`.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] [t : OrderClosedTopology Œ±]\n  [inst_2 : TopologicalSpace Œ≤] {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤} (hs : IsClosed s)\n  (hf : ContinuousOn f s) (hg : ContinuousOn g s), IsClosed (setOf fun (x : Œ≤) ‚Ü¶ (x ‚àà s : Prop) ‚àß (f x ‚â§ g x : Prop))","name":"IsClosed.isClosed_le","isProp":true,"docString":"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ‚àà s | f x ‚â§ g x}` is a closed set. "},{"type":"‚àÄ (Œ± : Sort u_1) [s : Setoid Œ±], Function.Surjective (Quotient.mk s)","name":"surjective_quotient_mk","isProp":true,"docString":"`Quotient.mk` is a surjective function. "},{"type":"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)} (hu : ‚ãÉ‚ÇÄ c = Set.univ) (H : Set.PairwiseDisjoint c id) (a : Œ±),\n  ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà c), a ‚àà b","name":"Setoid.eqv_classes_of_disjoint_union","isProp":true,"docString":"A set of disjoint sets covering Œ± partition Œ± (classical). "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (L : List G), -List.sum L = List.sum (List.reverse (List.map (fun (x : G) ‚Ü¶ -x) L))","name":"List.sum_neg_reverse","isProp":true,"docString":"This is the `List.sum` version of `add_neg_rev`"},{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : Preorder X] [inst_1 : Preorder Y] {L : X ‚•§ Y} {R : Y ‚•§ X} (adj : L ‚ä£ R),\n  GaloisConnection (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor L))\n    (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor R))","name":"CategoryTheory.Adjunction.gc","isProp":true,"docString":"An adjunction between preorder categories induces a galois connection.\n"},{"type":"‚àÄ {Œ± : Type u_1} {ùïú : Type u_2} [inst : Fintype Œ±] [inst_1 : LinearOrderedField ùïú] {G : SimpleGraph Œ±} {Œµ : ùïú}\n  (a : SimpleGraph.FarFromTriangleFree G Œµ) ‚¶ÉH : SimpleGraph Œ±‚¶Ñ (a : H ‚â§ G) (a : SimpleGraph.CliqueFree H 3),\n  Œµ * ‚Üë(Fintype.card Œ± ^ 2) ‚â§ ‚Üë(Finset.card (SimpleGraph.edgeFinset G)) - ‚Üë(Finset.card (SimpleGraph.edgeFinset H))","name":"SimpleGraph.farFromTriangleFree.le_card_sub_card","isProp":true,"docString":"**Alias** of the forward direction of `SimpleGraph.farFromTriangleFree_iff`."},{"type":"‚àÄ {R : Type u_3} {S : Type u_4} {M : Type u_1} {M‚ÇÇ : Type u_2} [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] {module_M : Module R M} {module_S_M‚ÇÇ : Module S M‚ÇÇ}\n  {œÉ : R ‚Üí+* S} {œÉ' : S ‚Üí+* R} {re‚ÇÅ : RingHomInvPair œÉ œÉ'} {re‚ÇÇ : RingHomInvPair œÉ' œÉ} (e : M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ),\n  LinearMap.toAddMonoidHom ‚Üëe = AddEquiv.toAddMonoidHom (LinearEquiv.toAddEquiv e)","name":"LinearEquiv.toAddMonoidHom_commutes","isProp":true,"docString":"The two paths coercion can take to an `AddMonoidHom` are equivalent "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {R : outParam (Type u_3)} {S : outParam (Type u_4)} [inst : Monoid M]\n  [inst_1 : Semiring R] [inst_2 : Semiring S] [inst_3 : DistribMulAction M R] [inst_4 : DistribMulAction M S]\n  [self : MulSemiringActionHomClass F M R S] (f : F), ‚Üëf 1 = 1","name":"MulSemiringActionHomClass.map_one","isProp":true,"docString":"The proposition that the function preserves 1 "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type u} [inst : ‚àÄ (a : Œ±), Finite (Œ≤ a)],\n  Cardinal.mk (WType Œ≤) ‚â§ max (Cardinal.mk Œ±) Cardinal.aleph0","name":"WType.cardinal_mk_le_max_aleph0_of_finite","isProp":true,"docString":"If, for any `a : Œ±`, `Œ≤ a` is finite, then the cardinality of `WType Œ≤`\nis at most the maximum of the cardinality of `Œ±` and `‚Ñµ‚ÇÄ`  "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} (v : (a : Œπ) ‚Üí M) (i : LinearIndependent R v) (w : Set M) [inst_4 : Fintype ‚Üëw]\n  (s : Submodule.span R w = ‚ä§), Cardinal.mk Œπ ‚â§ ‚Üë(Fintype.card ‚Üëw)","name":"linearIndependent_le_span","isProp":true,"docString":"If `R` satisfies the strong rank condition,\nthen for any linearly independent family `v : Œπ ‚Üí M`\nand any finite spanning set `w : Set M`,\nthe cardinality of `Œπ` is bounded by the cardinality of `w`.\n"},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {C : (a : AddCon.Quotient c) ‚Üí Prop} (q : AddCon.Quotient c)\n  (H : ‚àÄ (x : M), C ‚Üëx), C q","name":"AddCon.induction_on","isProp":true,"docString":"The inductive principle used to prove propositions about\nthe elements of a quotient by an additive congruence relation."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : LocallyCompactSpace Œ±] [inst_4 : LocallyCompactSpace Œ≤],\n  Continuous ContinuousMap.uncurry","name":"ContinuousMap.continuous_uncurry","isProp":true,"docString":"The uncurrying process is a continuous map between function spaces. "},{"type":"‚àÄ {Œ± : Type u_1} [self : DivisionSemiring Œ±] (a : Œ±), DivisionSemiring.zpow 0 a = 1","name":"DivisionSemiring.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {Œ± : Type u} [inst : NonUnitalNonAssocRing Œ±] (a : Œ±) (b : Œ±) (c : Œ±), (a - b) * c = a * c - b * c","name":"sub_mul","isProp":true,"docString":"**Alias** of `mul_sub_right_distrib`."},{"type":"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {r : ‚Ñù} (hr : 0 ‚â§ r) (x : E),\n  x +·µ• r ‚Ä¢ Metric.closedBall 0 1 = Metric.closedBall x r","name":"affinity_unitClosedBall","isProp":true,"docString":"Any closed ball `Metric.closedBall x r`, `0 ‚â§ r` is the image of the unit closed ball under\n`Œª y, x + r ‚Ä¢ y`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.SeparableSpace Œ±]\n  [inst_2 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (h : DenseRange f) (h' : Continuous f),\n  TopologicalSpace.SeparableSpace Œ≤","name":"DenseRange.separableSpace","isProp":true,"docString":"If `Œ±` is a separable space and `f : Œ± ‚Üí Œ≤` is a continuous map with dense range, then `Œ≤` is\na separable space as well. E.g., the completion of a separable uniform space is separable. "},{"type":"‚àÄ {Œ± : Type u_1} {m : Type u_2} {n : Type u_3} {R : Type u_4} [inst : TopologicalSpace R] [inst_1 : TopologicalSpace Œ±]\n  {f : (a : Œ±) ‚Üí Matrix m n R} (h : ‚àÄ (i : m) (j : n), Continuous fun (a : Œ±) ‚Ü¶ f a i j), Continuous f","name":"continuous_matrix","isProp":true,"docString":"To show a function into matrices is continuous it suffices to show the coefficients of the\nresulting matrix are continuous "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} (P : C·µí·µñ ‚•§ Type w),\n  CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.arrows ‚ä§)","name":"CategoryTheory.Presieve.isSheafFor_top_sieve","isProp":true,"docString":"Every presheaf is a sheaf for the maximal sieve.\n\n[Elephant] C2.1.5(ii)\n"},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m Œ±},\n  SatisfiesM (fun (x : Œ±) ‚Ü¶ True) x","name":"SatisfiesM.trivial","isProp":true,"docString":"If `p` is always true, then every `x` satisfies it.\n(This is the strongest postcondition version of `of_true`.)\n"},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R], InvariantBasisNumber R","name":"invariantBasisNumber_of_nontrivial_of_commRing","isProp":true,"docString":"Nontrivial commutative rings have the invariant basis number property.\n\nIn fact, any nontrivial commutative ring satisfies the strong rank condition, see\n`commRing_strongRankCondition`. We prove this instance separately to avoid dependency on\n`LinearAlgebra.Charpoly.Basic`. "},{"type":"‚àÄ {m : ‚Ñù} {f : (a : ‚Ñï) ‚Üí ‚Ñï} (hm : 1 < m) (fi : ‚àÄ (i : ‚Ñï), i ‚â§ f i), Summable fun (i : ‚Ñï) ‚Ü¶ 1 / m ^ f i","name":"summable_one_div_pow_of_le","isProp":true,"docString":"A series whose terms are bounded by the terms of a converging geometric series converges. "},{"type":"‚àÄ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  (self : LieSubalgebra R L) {x : L} {y : L}\n  (a :\n    x ‚àà\n      AddSubsemigroup.carrier\n        (AddSubmonoid.toAddSubsemigroup (Submodule.toAddSubmonoid (LieSubalgebra.toSubmodule self))))\n  (a :\n    y ‚àà\n      AddSubsemigroup.carrier\n        (AddSubmonoid.toAddSubsemigroup (Submodule.toAddSubmonoid (LieSubalgebra.toSubmodule self)))),\n  ‚ÅÖx, y‚ÅÜ ‚àà\n    AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup (Submodule.toAddSubmonoid (LieSubalgebra.toSubmodule self)))","name":"LieSubalgebra.lie_mem'","isProp":true,"docString":"An Lie subalgebra is closed under Lie bracket. "},{"type":"‚àÄ {k : Type u_2} {l : Type u_4} {m : Type u_3} {n : Type u_1} {Œ± : Type v} [inst : Fintype n] [inst_1 : Fintype k]\n  [inst_2 : DecidableEq n] [inst_3 : DecidableEq k] [inst_4 : DecidableEq m] [inst_5 : Semiring Œ±] (a : m) (b : n)\n  (c : k) (M : Matrix k l Œ±),\n  Matrix.mul (PEquiv.toMatrix (PEquiv.single a b)) (Matrix.mul (PEquiv.toMatrix (PEquiv.single b c)) M) =\n    Matrix.mul (PEquiv.toMatrix (PEquiv.single a c)) M","name":"PEquiv.single_mul_single_right","isProp":true,"docString":"Restatement of `single_mul_single`, which will simplify expressions in `simp` normal form,\nwhen associativity may otherwise need to be carefully applied. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : DivisionMonoid Œ≤] (f : Œ± ‚Üí* Œ≤) (a : Œ±), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π","name":"MonoidHom.map_inv","isProp":true,"docString":"Group homomorphisms preserve inverse. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {f : Filter Œ±} {g : Filter Œ≤}\n  {m : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {n : (a : Œ±) ‚Üí Œ±'} {m' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {n' : (a : Œ¥) ‚Üí Œ≥}\n  (h_left_comm : ‚àÄ (a : Œ±) (b : Œ≤), m (n a) b = n' (m' a b)),\n  Filter.map‚ÇÇ m (Filter.map n f) g = Filter.map n' (Filter.map‚ÇÇ m' f g)","name":"Filter.map‚ÇÇ_map_left_comm","isProp":true,"docString":"Symmetric statement to `Filter.map_map‚ÇÇ_distrib_left`. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : (a : Œπ) ‚Üí Type w}\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] {N : Type u‚ÇÅ} [inst_3 : AddCommMonoid N]\n  [inst_4 : Module R N] {œÜ : (i : Œπ) ‚Üí M i ‚Üí‚Çó[R] N} (i : Œπ) (x : M i),\n  ‚Üë(DirectSum.toModule R Œπ N œÜ) (‚Üë(DirectSum.lof R Œπ M i) x) = ‚Üë(œÜ i) x","name":"DirectSum.toModule_lof","isProp":true,"docString":"The map constructed using the universal property gives back the original maps when\nrestricted to each component. "},{"type":"‚àÄ {Œπ : Type u_3} {B : Type u_1} {F : Type u_2} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (Z : FiberBundleCore Œπ B F), IsOpenMap (FiberBundleCore.proj Z)","name":"FiberBundleCore.isOpenMap_proj","isProp":true,"docString":"The projection on the base of a fiber bundle created from core is an open map "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {A : C} {B : C} {R : C} {f : R ‚ü∂ A} {g : R ‚ü∂ A} {q : A ‚ü∂ B}\n  (h : CategoryTheory.IsKernelPair q f g), CategoryTheory.IsReflexivePair f g","name":"CategoryTheory.IsKernelPair.isReflexivePair","isProp":true,"docString":"If `f,g` is a kernel pair for some morphism `q`, then it is reflexive. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±} {t : Set Œ≤}\n  (hf : ‚àÄ (b : Œ≤) (a : b ‚àà t), Function.Injective fun (a : Œ±) ‚Ü¶ f a b),\n  (Set.PairwiseDisjoint t fun (b : Œ≤) ‚Ü¶ (fun (a : Œ±) ‚Ü¶ f a b) '' s : Prop) ‚Üî\n    (Set.InjOn (fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)) (s √óÀ¢ t) : Prop)","name":"Set.pairwiseDisjoint_image_left_iff","isProp":true,"docString":"The partial images of a binary function `f` whose partial evaluations are injective are pairwise\ndisjoint iff `f` is injective . "},{"type":"‚àÄ {Œ± : Type u} {p : (a : Œ±) ‚Üí Prop} (f : Equiv.Perm Œ±) (hf : ‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf‚Åª¬π x) : Prop)),\n  Equiv.Perm.subtypePerm f‚Åª¬π hf =\n    (Equiv.Perm.subtypePerm f\n        ((Iff.mpr\n              ((Equiv.Perm.inv_aux=:(‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf x) : Prop) : Prop) ‚Üî\n                    (‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf‚Åª¬π x) : Prop) :\n                      Prop))=:(‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf x) : Prop) : Prop) ‚Üî\n                  (‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf‚Åª¬π x) : Prop) : Prop))\n              hf=:‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf x) : Prop))=:‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf x) : Prop)))‚Åª¬π","name":"Equiv.Perm.subtypePerm_inv","isProp":true,"docString":"See `Equiv.Perm.inv_subtypePerm`"},{"type":"‚àÄ {Œ± : Type u_1} {n : ‚Ñï} {s : Finset Œ±} {t : Finset Œ±},\n  (s ‚àà Finset.powersetLen n t : Prop) ‚Üî ((s ‚äÜ t : Prop) ‚àß (Finset.card s = n : Prop) : Prop)","name":"Finset.mem_powersetLen","isProp":true,"docString":"**Formula for the Number of Combinations** "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasImages C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y), CategoryTheory.Limits.HasImage f","name":"CategoryTheory.Limits.HasImages.has_image","isProp":true,"docString":"`HasImages` asserts that every morphism has an image. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [self : MulActionWithZero R M] (m : M),\n  0 ‚Ä¢ m = 0","name":"MulActionWithZero.zero_smul","isProp":true,"docString":"Scalar multiplication by the scalar `0` is `0`. "},{"type":"‚àÄ {Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} (h : Function.Commute f g),\n  Set.InvOn f g (Function.fixedPoints (f ‚àò g)) (Function.fixedPoints (f ‚àò g))","name":"Function.Commute.invOn_fixedPoints_comp","isProp":true,"docString":"If self-maps `f` and `g` commute, then they are inverse of each other on the set of fixed points\nof `f ‚àò g`. This is a particular case of `Function.invOn_fixedPoints_comp`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteLattice Œ±] (s : Set Œ±) (a : Œ±) (a_1 : a ‚àà s), a ‚â§ sup‚Çõ s","name":"CompleteLattice.le_sup‚Çõ","isProp":true,"docString":"Any element of a set is less than the set supremum. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasProducts C]\n  [inst_2 : CategoryTheory.Limits.HasEqualizers C], CategoryTheory.Limits.HasLimitsOfSize C","name":"CategoryTheory.Limits.has_limits_of_hasEqualizers_and_products","isProp":true,"docString":"Any category with products and equalizers has all limits.\n\nSee <https://stacks.math.columbia.edu/tag/002N>.\n"},{"type":"‚àÄ {Œ± : Type u} {s : Set (Set Œ±)} (a : Cardinal.mk ‚Üës ‚â§ Cardinal.continuum),\n  Cardinal.mk ‚Üë(setOf fun (t : Set Œ±) ‚Ü¶ MeasurableSet t) ‚â§ Cardinal.continuum","name":"MeasurableSpace.cardinal_measurableSet_le_continuum","isProp":true,"docString":"If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,\nthen the sigma algebra has the same cardinality bound. "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±}\n  (h : (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) ‚â† 0), Set.Nonempty s","name":"nonempty_of_finsum_mem_ne_zero","isProp":true,"docString":"A set `s` is nonempty if the sum of some function over `s` is not equal to `0`."},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R)\n  (hp : ‚àÄ (n : ‚Ñï), Polynomial.coeff p n ‚àà Ideal.comap Polynomial.C I), p ‚àà I","name":"Ideal.polynomial_mem_ideal_of_coeff_mem_ideal","isProp":true,"docString":"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : LocallyCompactSpace Œ±], BaireSpace Œ±","name":"baire_category_theorem_locally_compact","isProp":true,"docString":"The second theorem states that locally compact spaces are Baire. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i","name":"AntivaryOn.sum_mul_le_sum_comp_perm_mul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and\n`g` antivary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (self : LocalEquiv Œ± Œ≤) ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà LocalEquiv.source self),\n  LocalEquiv.toFun self x ‚àà LocalEquiv.target self","name":"LocalEquiv.map_source'","isProp":true,"docString":"The proposition that elements of `source` are mapped to elements of `target`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} {Z : C} {œÄ : Y ‚ü∂ Z}\n  (self : CategoryTheory.IsSplitCoequalizer f g œÄ),\n  CategoryTheory.IsSplitCoequalizer.leftSection self ‚â´ f = œÄ ‚â´ CategoryTheory.IsSplitCoequalizer.rightSection self","name":"CategoryTheory.IsSplitCoequalizer.leftSection_top","isProp":true,"docString":"`leftSection` composed with `f` is `pi` composed with `rightSection` "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Œπ : Type u_4} (f : AlternatingMap R M N Œπ),\n  AlternatingMap.compLinearMap f LinearMap.id = f","name":"AlternatingMap.compLinearMap_id","isProp":true,"docString":"Composing an alternating map with the identity linear map in each argument. "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} {k : ‚Ñï} (h1 : n * k < m) (h2 : m < n * (k + 1)), ¬¨(n ‚à£ m : Prop)","name":"Nat.not_dvd_of_between_consec_multiples","isProp":true,"docString":"`m` is not divisible by `n` if it is between `n * k` and `n * (k + 1)` for some `k`. "},{"type":"‚àÄ {R : Type u} [self : AddGroupWithOne R] (n : ‚Ñï), IntCast.intCast (Int.negSucc n) = -‚Üë(n + 1)","name":"AddGroupWithOne.intCast_negSucc","isProp":true,"docString":"The canonical homorphism `‚Ñ§ ‚Üí R` for negative values is just the negation of the values\nof the canonical homomorphism `‚Ñï ‚Üí R`. "},{"type":"‚àÄ {L : Type v} {M : Type w} [inst : LieRing L] [inst_1 : AddCommGroup M] [self : LieRingModule L M] (x : L) (y : L)\n  (m : M), ‚ÅÖx + y, m‚ÅÜ = ‚ÅÖx, m‚ÅÜ + ‚ÅÖy, m‚ÅÜ","name":"LieRingModule.add_lie","isProp":true,"docString":"A Lie ring module bracket is additive in its first component. "},{"type":"‚àÄ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X} (hs : Metric.Bounded s)\n  {x : (a : ‚Ñï) ‚Üí X} (hx : ‚àÄ (n : ‚Ñï), x n ‚àà s),\n  ‚àÉ (a : X),\n    (a ‚àà closure s : Prop) ‚àß\n      (‚àÉ (œÜ : (a : ‚Ñï) ‚Üí ‚Ñï), (StrictMono œÜ : Prop) ‚àß (Filter.Tendsto (x ‚àò œÜ) Filter.atTop (nhds a) : Prop) : Prop)","name":"tendsto_subseq_of_bounded","isProp":true,"docString":"A version of Bolzano-Weistrass: in a proper metric space (eg. $‚Ñù^n$),\nevery bounded sequence has a converging subsequence. "},{"type":"‚àÄ {X : Type u_5} {m : Type u_3} {n : Type u_1} {p : Type u_4} {R : Type u_2} [inst : TopologicalSpace X]\n  [inst_1 : TopologicalSpace R] [inst_2 : Fintype n] [inst_3 : Mul R] [inst_4 : AddCommMonoid R]\n  [inst_5 : ContinuousAdd R] [inst_6 : ContinuousMul R] {A : (a : X) ‚Üí Matrix m n R} {B : (a : X) ‚Üí Matrix n p R}\n  (hA : Continuous A) (hB : Continuous B), Continuous fun (x : X) ‚Ü¶ Matrix.mul (A x) (B x)","name":"Continuous.matrix_mul","isProp":true,"docString":"For square matrices the usual `continuous_mul` can be used. "},{"type":"‚àÄ {M : Type u_1} [inst : SubtractionMonoid M] [inst_1 : TopologicalSpace M]\n  (h : ContinuousOn Neg.neg (setOf fun (x : M) ‚Ü¶ IsAddUnit x)), Embedding AddUnits.val","name":"AddUnits.embedding_val_mk","isProp":true,"docString":"An auxiliary lemma that can be used to prove that coercion `AddUnits M ‚Üí M` is a\ntopological embedding. Use `AddUnits.embedding_val` or `toAddUnits_homeomorph` instead."},{"type":"‚àÄ {Œ± : Type u_2} {ùïú : Type u_1} [inst : NormedField ùïú] {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú}\n  (hgf : ‚àÄ (x : Œ±) (a : g x = 0), f x = 0) (a : Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x / g x) l (nhds 0)), f =o[l] g","name":"Asymptotics.isLittleO_of_tendsto","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_iff_tendsto`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFiltered C] {D : Type u‚ÇÅ}\n  [inst_2 : CategoryTheory.Category D] (R : C ‚•§ D) [inst : CategoryTheory.IsRightAdjoint R], CategoryTheory.IsFiltered D","name":"CategoryTheory.IsFiltered.of_isRightAdjoint","isProp":true,"docString":"If `C` is filtered, and we have a right adjoint functor `R : C ‚•§ D`, then `D` is filtered. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±},\n  EMetric.hausdorffEdist (closure s) (closure t) = EMetric.hausdorffEdist s t","name":"EMetric.hausdorffEdist_closure","isProp":true,"docString":"The Hausdorff edistance between sets or their closures is the same "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} {t : Set Œ±} (a : s ‚äÜ t), s ‚â§ t","name":"HasSubset.Subset.le","isProp":true,"docString":"**Alias** of the reverse direction of `Set.le_iff_subset`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] (c : ClosureOperator Œ±),\n  c =\n    ClosureOperator.mk‚ÇÉ (‚Üë(ClosureOperator.toOrderHom c)) (ClosureOperator.closed c)\n      ((ClosureOperator.le_closure\n            c=:‚àÄ (x : Œ±), x ‚â§ ‚Üë(ClosureOperator.toOrderHom c) x)=:‚àÄ (x : Œ±), x ‚â§ ‚Üë(ClosureOperator.toOrderHom c) x)\n      ((ClosureOperator.closure_is_closed\n            c=:‚àÄ (x : Œ±),\n            ‚Üë(ClosureOperator.toOrderHom c) x ‚àà\n              ClosureOperator.closed c)=:‚àÄ (x : Œ±), ‚Üë(ClosureOperator.toOrderHom c) x ‚àà ClosureOperator.closed c)\n      (fun (x : Œ±) ‚Ü¶\n        (_ :\n          ‚àÄ (y : Œ±) (hxy : x ‚â§ y) (hy : ClosureOperator.closed c y),\n            ‚Üë(ClosureOperator.toOrderHom c) x ‚â§\n              y)=:‚àÄ (x : Œ±) (y : Œ±) (hxy : x ‚â§ y) (hy : ClosureOperator.closed c y),\n          ‚Üë(ClosureOperator.toOrderHom c) x ‚â§ y)","name":"ClosureOperator.eq_mk‚ÇÉ_closed","isProp":true,"docString":"A closure operator is equal to the closure operator obtained by feeding `c.closed` into the\n`mk‚ÇÉ` constructor. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] (self : IsField R) (x : R) (y : R), x * y = y * x","name":"IsField.mul_comm","isProp":true,"docString":"Fields are commutative. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_4} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1) (b‚ÇÅ : P) (b‚ÇÇ : P),\n  ‚Üë(Finset.weightedVSubOfPoint s p b‚ÇÅ) w +·µ• b‚ÇÅ = ‚Üë(Finset.weightedVSubOfPoint s p b‚ÇÇ) w +·µ• b‚ÇÇ","name":"Finset.weightedVSubOfPoint_vadd_eq_of_sum_eq_one","isProp":true,"docString":"The weighted sum, added to the base point, is independent of the\nbase point when the sum of the weights is 1. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] (self : LowerSet Œ±), IsLowerSet (LowerSet.carrier self)","name":"LowerSet.lower'","isProp":true,"docString":"The carrier of a `LowerSet` is a lower set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommSemiring Œ±] (E : LinearRecurrence Œ±) (init : (a : Fin (LinearRecurrence.order E)) ‚Üí Œ±),\n  LinearRecurrence.IsSolution E (LinearRecurrence.mkSol E init)","name":"LinearRecurrence.is_sol_mkSol","isProp":true,"docString":"`E.mkSol` indeed gives solutions to `E`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} (self : Filter.IsBasis p s) {i : Œπ} {j : Œπ}\n  (a : p i) (a : p j), ‚àÉ (k : Œπ), (p k : Prop) ‚àß (s k ‚äÜ s i ‚à© s j : Prop)","name":"Filter.IsBasis.inter","isProp":true,"docString":"`s` is directed downwards on `i` such that `p i`. "},{"type":"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial œÉ R),\n  ‚àÉ (n : ‚Ñï),\n    ‚àÉ (f : (a : Fin n) ‚Üí œÉ),\n      ‚àÉ (_hf : Function.Injective f), ‚àÉ (q : MvPolynomial (Fin n) R), p = ‚Üë(MvPolynomial.rename f) q","name":"MvPolynomial.exists_fin_rename","isProp":true,"docString":"Every polynomial is a polynomial in finitely many variables. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] [inst_4 : Nontrivial Œ±] {s : Set Œ±} [inst_5 : TopologicalSpace.SeparableSpace ‚Üës]\n  (hs : Dense s),\n  ‚àÉ (t : Set Œ±),\n    (t ‚äÜ s : Prop) ‚àß\n      ((Set.Countable t : Prop) ‚àß\n          ((Dense t : Prop) ‚àß\n              ((‚àÄ (x : Œ±) (a : IsBot x), ¬¨(x ‚àà t : Prop) : Prop) ‚àß (‚àÄ (x : Œ±) (a : IsTop x), ¬¨(x ‚àà t : Prop) : Prop) :\n                Prop) :\n            Prop) :\n        Prop)","name":"Dense.exists_countable_dense_subset_no_bot_top","isProp":true,"docString":"Let `s` be a dense set in a nontrivial dense linear order `Œ±`. If `s` is a\nseparable space (e.g., if `Œ±` has a second countable topology), then there exists a countable\ndense subset `t ‚äÜ s` such that `t` does not contain bottom/top elements of `Œ±`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {X : Type u_2} {A : Type u_3} [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  {f : FreeAlgebra R X ‚Üí‚Çê[R] A} {g : FreeAlgebra R X ‚Üí‚Çê[R] A} (w : ‚Üëf ‚àò FreeAlgebra.Œπ R = ‚Üëg ‚àò FreeAlgebra.Œπ R), f = g","name":"FreeAlgebra.hom_ext","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {f : ‚Ñï ‚Üí‚ÇÄ ‚Ñï} (hf : ‚àÄ (p : ‚Ñï) (a : p ‚àà Finsupp.support f), Nat.Prime p),\n  Nat.factorization (Finsupp.prod f fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x ^ x_1) = f","name":"Nat.prod_pow_factorization_eq_self","isProp":true,"docString":"Any Finsupp `f : ‚Ñï ‚Üí‚ÇÄ ‚Ñï` whose support is in the primes is equal to the factorization of\nthe product `‚àè (a : ‚Ñï) in f.support, a ^ f a`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V] {Œπ : Type u_1}\n  (s : Finset Œπ) {w : (a : Œπ) ‚Üí k} {p : (a : Œπ) ‚Üí V} (hw : Finset.sum s w = 0),\n  ‚Üë(Finset.weightedVSub s p) w = Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ p i","name":"Finset.weightedVSub_eq_linear_combination","isProp":true,"docString":"Viewing a module as an affine space modelled on itself, a `weightedVSub` is just a linear\ncombination. "},{"type":"‚àÄ (n : ‚Ñï) {a : ‚Ñï} (ha : 0 < a),\n  (‚àÉ (k : ‚Ñï), (a * k < n : Prop) ‚àß (n < a * (k + 1) : Prop) : Prop) ‚Üî (¬¨(a ‚à£ n : Prop) : Prop)","name":"Nat.not_dvd_iff_between_consec_multiples","isProp":true,"docString":"`n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. "},{"type":"‚àÄ {G : Type u_1} [inst : SubNegMonoid G] (a : G) (b : G), a - b = a + -b","name":"sub_eq_add_neg","isProp":true,"docString":"Subtracting an element is the same as adding by its negative.\nThis is a duplicate of `SubNegMonoid.sub_eq_mul_neg` ensuring that the types unfold better."},{"type":"‚àÄ {Œπ : Type u_2} {R : Type u_3} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Fintype Œπ] (b : Basis Œπ R M) (x : (a : Œπ) ‚Üí R),\n  ‚Üë(LinearEquiv.symm (Basis.equivFun b)) x = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ x i ‚Ä¢ ‚Üëb i","name":"Basis.equivFun_symm_apply","isProp":true,"docString":"Given a basis `v` indexed by `Œπ`, the canonical linear equivalence between `Œπ ‚Üí R` and `M` maps\na function `x : Œπ ‚Üí R` to the linear combination `‚àë_i x i ‚Ä¢ v i`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {Œπ : Type v} (hs : IsCompact s) (U : (a : Œπ) ‚Üí Set Œ±)\n  (hUo : ‚àÄ (i : Œπ), IsOpen (U i)) (hsU : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ U i),\n  ‚àÉ (t : Finset Œπ), s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà t) ‚Ü¶ U i","name":"IsCompact.elim_finite_subcover","isProp":true,"docString":"For every open cover of a compact set, there exists a finite subcover. "},{"type":"‚àÄ {V : Type u} {G‚ÇÅ : SimpleGraph V} {G‚ÇÇ : SimpleGraph V} (a : G‚ÇÅ < G‚ÇÇ), SimpleGraph.edgeSet G‚ÇÅ ‚äÇ SimpleGraph.edgeSet G‚ÇÇ","name":"SimpleGraph.edgeSet_strict_mono","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.edgeSet_ssubset_edgeSet`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NormedField Œ±] [inst_1 : SeminormedAddCommGroup Œ≤] [self : NormedSpace Œ± Œ≤]\n  (a : Œ±) (b : Œ≤), ‚Äña ‚Ä¢ b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ","name":"NormedSpace.norm_smul_le","isProp":true,"docString":"A normed space over a normed field is a vector space endowed with a norm which satisfies the\nequality `‚Äñc ‚Ä¢ x‚Äñ = ‚Äñc‚Äñ ‚Äñx‚Äñ`. We require only `‚Äñc ‚Ä¢ x‚Äñ ‚â§ ‚Äñc‚Äñ ‚Äñx‚Äñ` in the definition, then prove\n`‚Äñc ‚Ä¢ x‚Äñ = ‚Äñc‚Äñ ‚Äñx‚Äñ` in `norm_smul`.\n\nNote that since this requires `SeminormedAddCommGroup` and not `NormedAddCommGroup`, this\ntypeclass can be used for \"semi normed spaces\" too, just as `Module` can be used for\n\"semi modules\". "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set (Œ± √ó Œ±)},\n  (s ‚àà uniformity Œ± : Prop) ‚Üî\n    (‚àÉ (Œµ : ENNReal), (Œµ > 0 : Prop) ‚àß (‚àÄ {a : Œ±} {b : Œ±} (a_1 : edist a b < Œµ), (a, b) ‚àà s : Prop) : Prop)","name":"mem_uniformity_edist","isProp":true,"docString":"Characterization of the elements of the uniformity in terms of the extended distance "},{"type":"‚àÄ {G : Type u_2} [inst : Group G] {Œπ : Sort u_1} (S : (a : Œπ) ‚Üí Subgroup G) {C : (a : G) ‚Üí Prop} {x : G}\n  (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hp : ‚àÄ (i : Œπ) (x : G) (a : x ‚àà S i), C x) (h1 : C 1)\n  (hmul : ‚àÄ (x : G) (y : G) (a : C x) (a : C y), C (x * y)), C x","name":"Subgroup.sup·µ¢_induction","isProp":true,"docString":"An induction principle for elements of `‚®Ü i, S i`.\nIf `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. "},{"type":"‚àÄ {Œ± : Type u} [self : TopologicalSpace Œ±], TopologicalSpace.IsOpen Set.univ","name":"TopologicalSpace.isOpen_univ","isProp":true,"docString":"The set representing the whole space is an open set. Use `isOpen_univ` in the root namespace\ninstead. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±},\n  (s ‚àà Finset.shadow ùíú : Prop) ‚Üî\n    (‚àÉ (t : Finset Œ±), (t ‚àà ùíú : Prop) ‚àß ((s ‚äÜ t : Prop) ‚àß (Finset.card t = Finset.card s + 1 : Prop) : Prop) : Prop)","name":"Finset.mem_shadow_iff_exists_mem_card_add_one","isProp":true,"docString":"`s ‚àà ‚àÇ ùíú` iff `s` is exactly one element less than something from `ùíú` "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : b < c) (a_2 : a ‚â§ b), a < c","name":"LT.lt.trans_le'","isProp":true,"docString":"**Alias** of `lt_of_lt_of_le'`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : SuccOrder Œ±] {a : Œ±} (a_1 : ¬¨(IsMax a : Prop)), a < Order.succ a","name":"Order.lt_succ_of_not_isMax","isProp":true,"docString":"**Alias** of the reverse direction of `Order.lt_succ_iff_not_isMax`."},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLattice Œ±] {b : Œ±} [inst_1 : Nonempty Œπ] {f : (a : Œπ) ‚Üí Œ±}\n  (h‚ÇÅ : ‚àÄ (i : Œπ), b ‚â§ f i) (h‚ÇÇ : ‚àÄ (w : Œ±) (a : b < w), ‚àÉ (i : Œπ), f i < w), (inf·µ¢ fun (i : Œπ) ‚Ü¶ f i) = b","name":"cinf·µ¢_eq_of_forall_ge_of_forall_gt_exists_lt","isProp":true,"docString":"Introduction rule to prove that `b` is the infimum of `f`: it suffices to check that `b`\nis smaller than `f i` for all `i`, and that this is not the case of any `w>b`.\nSee `inf·µ¢_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in complete lattices. "},{"type":"‚àÄ {L : Type v} {M : Type w} [inst : LieRing L] [inst_1 : AddCommGroup M] [self : LieRingModule L M] (x : L) (y : L)\n  (m : M), ‚ÅÖx, ‚ÅÖy, m‚ÅÜ‚ÅÜ = ‚ÅÖ‚ÅÖx, y‚ÅÜ, m‚ÅÜ + ‚ÅÖy, ‚ÅÖx, m‚ÅÜ‚ÅÜ","name":"LieRingModule.leibniz_lie","isProp":true,"docString":"A Lie ring module bracket satisfies a Leibniz / Jacobi identity. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : CommSemiring ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : ContinuousAdd ùïú]\n  [inst_3 : ContinuousConstSMul ùïú ùïú] [inst_4 : AddCommMonoid E] [inst_5 : Module ùïú E] [inst_6 : TopologicalSpace E]\n  (M : Type u_3) [inst_7 : Monoid M] [inst_8 : DistribMulAction M ùïú] [inst_9 : SMulCommClass ùïú M ùïú]\n  [inst_10 : TopologicalSpace M] [inst_11 : ContinuousSMul M ùïú], ContinuousSMul M (WeakDual ùïú E)","name":"WeakDual.instContinuousSMul","isProp":true,"docString":"If a monoid `M` distributively continuously acts on `ùïú` and this action commutes with\nmultiplication on `ùïú`, then it continuously acts on `WeakDual ùïú E`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : SuccOrder Œ±] (a : Œ±), a ‚â§ SuccOrder.succ a","name":"SuccOrder.le_succ","isProp":true,"docString":"Proof of basic ordering with respect to `succ`"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofiltered C] (O : Finset C)\n  (H : Finset ((X : C) √ó' (Y : C) √ó' (_ : X ‚àà O) √ó' (_ : Y ‚àà O) √ó' (X ‚ü∂ Y))),\n  ‚àÉ (S : C),\n    ‚àÉ (T : {X : C} ‚Üí (a : X ‚àà O) ‚Üí S ‚ü∂ X),\n      ‚àÄ {X : C} {Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y}\n        (a : { fst := X, snd := { fst := Y, snd := { fst := mX, snd := { fst := mY, snd := f } } } } ‚àà H),\n        T mX ‚â´ f = T mY","name":"CategoryTheory.IsCofiltered.inf_exists","isProp":true,"docString":"Given any `Finset` of objects `{X, ...}` and\nindexed collection of `Finset`s of morphisms `{f, ...}` in `C`,\nthere exists an object `S`, with a morphism `T X : S ‚ü∂ X` from each `X`,\nsuch that the triangles commute: `T X ‚â´ f = T Y`, for `f : X ‚ü∂ Y` in the `Finset`.\n"},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} (a : x ‚àà s), -x ‚àà s","name":"Subfield.neg_mem","isProp":true,"docString":"A subfield is closed under negation. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : Set.Nonempty s) (ht : Set.Nonempty t)\n  (bs : Metric.Bounded s) (bt : Metric.Bounded t), EMetric.hausdorffEdist s t ‚â† ‚ä§","name":"Metric.hausdorffEdist_ne_top_of_nonempty_of_bounded","isProp":true,"docString":"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. "},{"type":"‚àÄ {Œ≤ : Type u} [inst : AddCommMonoid Œ≤] (f : (a : ‚Ñï) ‚Üí Œ≤) (s : (a : ‚Ñï) ‚Üí Œ≤) (base : s 0 = 0)\n  (step : ‚àÄ (n : ‚Ñï), s (n + 1) = s n + f n) (n : ‚Ñï), (Finset.sum (Finset.range n) fun (k : ‚Ñï) ‚Ü¶ f k) = s n","name":"Finset.sum_range_induction","isProp":true,"docString":"For any sum along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can\nverify that it's equal to a different function just by checking differences of adjacent terms.\n\nThis is a discrete analogue of the fundamental theorem of calculus."},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} [inst : CompleteLattice Œ±] [inst_1 : Fintype Œπ] {f : (a : Œπ) ‚Üí Œ±}\n  (a : CompleteLattice.Independent f), Finset.SupIndep Finset.univ f","name":"CompleteLattice.Independent.sup_indep_univ","isProp":true,"docString":"**Alias** of the forward direction of `CompleteLattice.independent_iff_supIndep_univ`."},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R], FaithfulSMul (R ‚Üí+* R) R","name":"RingHom.applyFaithfulSMul","isProp":true,"docString":"`RingHom.applyDistribMulAction` is faithful. "},{"type":"‚àÄ {Œπ : Type w} {R : Type u} [inst : Ring R] [inst_1 : Nontrivial R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {v : (a : Œπ) ‚Üí M} (i : LinearIndependent R v),\n  (LinearIndependent.Maximal i : Prop) ‚Üî\n    (‚àÄ (Œ∫ : Type v) (w : (a : Œ∫) ‚Üí M) (_i' : LinearIndependent R w) (j : (a : Œπ) ‚Üí Œ∫) (_h : w ‚àò j = v),\n        Function.Surjective j :\n      Prop)","name":"LinearIndependent.maximal_iff","isProp":true,"docString":"An alternative characterization of a maximal linearly independent family,\nquantifying over types (in the same universe as `M`) into which the indexing family injects.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {mŒ≤ : MeasurableSpace Œ≤} {x : MeasurableSpace Œ±} {f : (a : ‚Ñï) ‚Üí (a : Œ±) ‚Üí Œ≤}\n  {p : (a : ‚Ñï) ‚Üí (a : Œ±) ‚Üí Prop} [inst : (n : ‚Ñï) ‚Üí DecidablePred (p n)] (hf : ‚àÄ (n : ‚Ñï), Measurable (f n))\n  (hp : ‚àÄ (n : ‚Ñï), MeasurableSet (setOf fun (x : Œ±) ‚Ü¶ p n x)) (h : ‚àÄ (x : Œ±), ‚àÉ (n : ‚Ñï), p n x),\n  Measurable fun (x : Œ±) ‚Ü¶ f (Nat.find ((h x=:‚àÉ (n : ‚Ñï), p n x)=:‚àÉ (n : ‚Ñï), p n x)) x","name":"Measurable.find","isProp":true,"docString":"A piecewise function on countably many pieces is measurable if all the data is measurable. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : SeminormedRing ùïú] [inst_1 : SMul ùïú E] {s : Set E} (a : Balanced ùïú s) ‚¶Éa : ùïú‚¶Ñ\n  (a_1 : ‚Äña‚Äñ ‚â§ 1) ‚¶Éx : E‚¶Ñ (a_2 : x ‚àà s), a ‚Ä¢ x ‚àà s","name":"Balanced.smul_mem","isProp":true,"docString":"**Alias** of the forward direction of `balanced_iff_smul_mem`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 < a) (hb : 1 < b), 1 < a * b","name":"Left.one_lt_mul","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : SigmaCompactSpace Œ±] {f : (a : Œ±) ‚Üí Set Œ±} {s : Set Œ±}\n  (hs : IsClosed s) (hf : ‚àÄ (x : Œ±) (a : x ‚àà s), f x ‚àà nhdsWithin x s),\n  ‚àÉ (t : Set Œ±),\n    ‚àÉ (x : t ‚äÜ s), (Set.Countable t : Prop) ‚àß (s ‚äÜ Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà t) ‚Ü¶ f x : Prop)","name":"countable_cover_nhdsWithin_of_sigma_compact","isProp":true,"docString":"In a topological space with sigma compact topology, if `f` is a function that sends each point\n`x` of a closed set `s` to a neighborhood of `x` within `s`, then for some countable set `t ‚äÜ s`,\nthe neighborhoods `f x`, `x ‚àà t`, cover the whole set `s`. "},{"type":"‚àÄ {n : ‚Ñï} (p : Fin (n + 1)) (i : Fin n), (p < ‚Üë(Fin.succAbove p) i : Prop) ‚Üî (p ‚â§ ‚ÜëFin.castSucc i : Prop)","name":"Fin.lt_succAbove_iff","isProp":true,"docString":"Embedding `i : Fin n` into `Fin (n + 1)` using a pivot `p` that is lesser\nresults in a value that is greater than `p`. "},{"type":"‚àÄ {Œ± : Type u_2} {n : Type u_1} {A : Matrix n n Œ±} (a : ‚àÄ (i : n) (j : n), A j i = A i j), Matrix.IsSymm A","name":"Matrix.IsSymm.ext","isProp":true,"docString":"A version of `Matrix.ext` that unfolds the `Matrix.transpose`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {s1 : AffineSubspace k P} (h : s ‚äÜ ‚Üës1), spanPoints k s ‚äÜ ‚Üës1","name":"AffineSubspace.spanPoints_subset_coe_of_subset_coe","isProp":true,"docString":"If an affine subspace contains a set of points, it contains the `spanPoints` of that set. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {t : CategoryTheory.Limits.Cocone F} (self : CategoryTheory.Limits.IsColimit t) (s : CategoryTheory.Limits.Cocone F)\n  (m : CategoryTheory.Limits.Cocone.pt t ‚ü∂ CategoryTheory.Limits.Cocone.pt s)\n  (x : ‚àÄ (j : J), (CategoryTheory.Limits.Cocone.Œπ t).app j ‚â´ m = (CategoryTheory.Limits.Cocone.Œπ s).app j),\n  m = CategoryTheory.Limits.IsColimit.desc self s","name":"CategoryTheory.Limits.IsColimit.uniq","isProp":true,"docString":"`desc` is the unique such map "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ±‚ÇÇ : Type u_3} [inst : Semiring Œ≤] [inst_1 : Mul Œ±] [inst_2 : Mul Œ±‚ÇÇ] {F : Type u_4}\n  [inst_3 : MulHomClass F Œ± Œ±‚ÇÇ] (f : F) (x : MonoidAlgebra Œ≤ Œ±) (y : MonoidAlgebra Œ≤ Œ±),\n  MonoidAlgebra.mapDomain (‚Üëf) (x * y) = MonoidAlgebra.mapDomain (‚Üëf) x * MonoidAlgebra.mapDomain (‚Üëf) y","name":"MonoidAlgebra.mapDomain_mul","isProp":true,"docString":"Like `Finsupp.mapDomain_add`, but for the convolutive multiplication we define in this file "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} {b : Œ±} (ha : 0 < a) (hb : 0 < b),\n  (a‚Åª¬π < b‚Åª¬π : Prop) ‚Üî (b < a : Prop)","name":"inv_lt_inv","isProp":true,"docString":"See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] {w : (a : œÉ) ‚Üí M}\n  (n : M) (œÜ : MvPolynomial œÉ R),\n  MvPolynomial.IsWeightedHomogeneous w (‚Üë(MvPolynomial.weightedHomogeneousComponent w n) œÜ) n","name":"MvPolynomial.weightedHomogeneousComponent_isWeightedHomogeneous","isProp":true,"docString":"The `n` weighted homogeneous component of a polynomial is weighted homogeneous of\nweighted degree `n`. "},{"type":"‚àÄ {p : ‚Ñï} {q : ‚Ñï} (hp : Nat.Prime p) (h : ‚Üë(Nat.factorization p) q ‚â† 0), p = q","name":"Nat.Prime.eq_of_factorization_pos","isProp":true,"docString":"The only prime factor of prime `p` is `p` itself. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsConnected s : Prop) ‚Üî\n    (‚àÄ (U : Finset (Set Œ±))\n        (a : ‚àÄ (u : Set Œ±) (v : Set Œ±) (a : u ‚àà U) (a : v ‚àà U) (a : Set.Nonempty (s ‚à© (u ‚à© v))), u = v)\n        (a : ‚àÄ (u : Set Œ±) (a : u ‚àà U), IsOpen u) (a : s ‚äÜ ‚ãÉ‚ÇÄ ‚ÜëU), ‚àÉ (u : Set Œ±), (u ‚àà U : Prop) ‚àß (s ‚äÜ u : Prop) :\n      Prop)","name":"isConnected_iff_union‚Çõ_disjoint_open","isProp":true,"docString":"A set `s` is connected if and only if\nfor every cover by a finite collection of open sets that are pairwise disjoint on `s`,\nit is contained in one of the members of the collection. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (S : Finset M),\n  CompleteLattice.IsCompactElement (Submodule.span R ‚ÜëS)","name":"Submodule.finset_span_isCompactElement","isProp":true,"docString":"The span of a finite subset is compact in the lattice of submodules. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (F : C ‚•§ CategoryTheory.Discrete PUnit)\n  (G : C ‚•§ CategoryTheory.Discrete PUnit), F = G","name":"CategoryTheory.Functor.pUnit_ext'","isProp":true,"docString":"Any two functors to `Discrete PUnit` are *equal*.\nYou probably want to use `pUnitExt` instead of this. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], ‚Üë‚ä§ = Set.univ","name":"AffineSubspace.top_coe","isProp":true,"docString":"`‚ä§`, coerced to a set, is the whole set of points. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} {p : (a : Œπ) ‚Üí P} {i : Œπ}\n  (ha : AffineIndependent k fun (x : { y : Œπ // y ‚â† i }) ‚Ü¶ p ‚Üëx)\n  (hi : ¬¨(p i ‚àà affineSpan k (p '' setOf fun (x : Œπ) ‚Ü¶ x ‚â† i) : Prop)), AffineIndependent k p","name":"AffineIndependent.affineIndependent_of_not_mem_span","isProp":true,"docString":"If all but one point of a family are affinely independent, and that point does not lie in\nthe affine span of that family, the family is affinely independent. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  (h : IsUnit (Matrix.det A)), Matrix.mul A‚Åª¬π A = 1","name":"Matrix.nonsing_inv_mul","isProp":true,"docString":"The `nonsing_inv` of `A` is a left inverse. "},{"type":"‚àÄ {Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hfg : Function.IsFixedPt (f ‚àò g) x)\n  (hg : Function.IsFixedPt g x), Function.IsFixedPt f x","name":"Function.IsFixedPt.left_of_comp","isProp":true,"docString":"If `x` is a fixed point of `f ‚àò g` and `g`, then it is a fixed point of `f`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Mul Œ±] [inst_1 : One Œ±] {a : Œ±} [self : Invertible a], a * ‚Öüa = 1","name":"Invertible.mul_invOf_self","isProp":true,"docString":"`invOf a` is a right inverse of `a` "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)]\n  [inst_2 : (i : Œπ) ‚Üí Zero (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}, (hammingNorm x ‚â† 0 : Prop) ‚Üî (x ‚â† 0 : Prop)","name":"hammingNorm_ne_zero_iff","isProp":true,"docString":"Corresponds to `norm_ne_zero_iff`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] (a : E) (b : E), nndist a b = ‚Äña - b‚Äñ‚Çä","name":"nndist_eq_nnnorm","isProp":true,"docString":"**Alias** of `nndist_eq_nnnorm_sub`."},{"type":"‚àÄ {n : ‚Ñï} {m : ‚Ñï} (a : ‚Üën < ‚Üëm), n < m","name":"Int.lt_of_ofNat_lt_ofNat","isProp":true,"docString":"**Alias** of the forward direction of `Int.ofNat_lt`."},{"type":"‚àÄ {V : Type u_2} [inst : Quiver V] {V' : Type u_1} [inst_1 : Quiver V'] [inst_2 : Quiver.HasReverse V'] (œÜ : V ‚•§q V')\n  (Œ¶ : Quiver.Symmetrify V ‚•§q V') (hŒ¶ : Quiver.Symmetrify.of ‚ãôq Œ¶ = œÜ)\n  (hŒ¶inv :\n    ‚àÄ {X : Quiver.Symmetrify V} {Y : Quiver.Symmetrify V} (f : X ‚ü∂ Y),\n      Prefunctor.map Œ¶ (Quiver.reverse f) = Quiver.reverse (Prefunctor.map Œ¶ f)),\n  Œ¶ = Quiver.Symmetrify.lift œÜ","name":"Quiver.Symmetrify.lift_unique","isProp":true,"docString":"`lift œÜ` is the only prefunctor extending `œÜ` and preserving reverses. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] (a : M) (u : MÀ£), (IsUnit (a * ‚Üëu) : Prop) ‚Üî (IsUnit a : Prop)","name":"Units.isUnit_mul_units","isProp":true,"docString":"Multiplication by a `u : MÀ£` on the right doesn't affect `IsUnit`. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : CancelMonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ} (h‚ÇÅ : b ‚â† 1) (h‚ÇÇ : b * a = a), a = 0","name":"eq_zero_of_mul_eq_self_left","isProp":true,"docString":"An element of a `CancelMonoidWithZero` fixed by left multiplication by an element other\nthan one must be zero. "},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel (SimpleGraph.Adj G)] [inst_2 : Nonempty V],\n  ‚àÉ (v : V), SimpleGraph.maxDegree G = SimpleGraph.degree G v","name":"SimpleGraph.exists_maximal_degree_vertex","isProp":true,"docString":"There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. "},{"type":"‚àÄ {R : Type u_1} [self : Distrib R] (a : R) (b : R) (c : R), a * (b + c) = a * b + a * c","name":"Distrib.left_distrib","isProp":true,"docString":"Multiplication is left distributive over addition "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {t : Set (Set Œ±)}\n  (h : Set.PairwiseDisjoint t id) (ht‚ÇÄ : Set.Finite t) (ht‚ÇÅ : ‚àÄ (x : Set Œ±) (a : x ‚àà t), Set.Finite x),\n  (finsum fun (a : Œ±) ‚Ü¶ finsum fun (h : a ‚àà ‚ãÉ‚ÇÄ t) ‚Ü¶ f a) =\n    finsum fun (s : Set Œ±) ‚Ü¶ finsum fun (h : s ‚àà t) ‚Ü¶ finsum fun (a : Œ±) ‚Ü¶ finsum fun (h : a ‚àà s) ‚Ü¶ f a","name":"finsum_mem_union‚Çõ","isProp":true,"docString":"If `t` is a finite set of pairwise disjoint finite sets, then the sum of `f a` over\n`a ‚àà ‚ãÉ‚ÇÄ t` is the sum over `s ‚àà t` of the sums of `f a` over `a ‚àà s`."},{"type":"‚àÄ {p : ‚Ñï} (hp : Nat.Prime p) (n : ‚Ñï), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)","name":"Nat.totient_prime_pow_succ","isProp":true,"docString":"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : OrderedCommSemiring R] {s : Finset Œπ} {i : Œπ} {f : (a : Œπ) ‚Üí R}\n  {g : (a : Œπ) ‚Üí R} {h : (a : Œπ) ‚Üí R} (hi : i ‚àà s) (h2i : g i + h i ‚â§ f i)\n  (hgf : ‚àÄ (j : Œπ) (a : j ‚àà s) (a : j ‚â† i), g j ‚â§ f j) (hhf : ‚àÄ (j : Œπ) (a : j ‚àà s) (a : j ‚â† i), h j ‚â§ f j)\n  (hg : ‚àÄ (i : Œπ) (a : i ‚àà s), 0 ‚â§ g i) (hh : ‚àÄ (i : Œπ) (a : i ‚àà s), 0 ‚â§ h i),\n  ((Finset.prod s fun (i : Œπ) ‚Ü¶ g i) + Finset.prod s fun (i : Œπ) ‚Ü¶ h i) ‚â§ Finset.prod s fun (i : Œπ) ‚Ü¶ f i","name":"Finset.prod_add_prod_le","isProp":true,"docString":"If `g, h ‚â§ f` and `g i + h i ‚â§ f i`, then the product of `f` over `s` is at least the\nsum of the products of `g` and `h`. This is the version for `OrderedCommSemiring`. "},{"type":"‚àÄ {R : Type u_1} {a : R} [inst : Monoid R] {n : ‚Ñï} (n0 : 0 < n), (IsRegular (a ^ n) : Prop) ‚Üî (IsRegular a : Prop)","name":"IsRegular.pow_iff","isProp":true,"docString":"An element `a` is regular if and only if a positive power of `a` is regular. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atBot),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atBot : Prop) ‚Üî (0 < r : Prop)","name":"Filter.tendsto_mul_const_atBot_iff_pos","isProp":true,"docString":"If `f` tends to negative infinity along a nontrivial filter `l`, then `Œª x, f x * r` tends to\nnegative infinity if and only if `0 < r. `"},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±} {t : Set Œ±} (h : BddAbove t), BddAbove (s ‚à© t)","name":"BddAbove.inter_of_right","isProp":true,"docString":"If `t` is bounded, then so is `s ‚à© t` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : NormalSpace Œ±] (s : Set Œ±) (t : Set Œ±) (a : IsClosed s)\n  (a : IsClosed t) (a : Disjoint s t), SeparatedNhds s t","name":"NormalSpace.normal","isProp":true,"docString":"Two disjoint sets in a normal space admit disjoint neighbourhoods. "},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (a_1 : a ‚ãñ b), ‚Üëa ‚ãñ ‚Üëb","name":"Covby.cast_int","isProp":true,"docString":"**Alias** of the reverse direction of `Nat.cast_int_covby_iff`."},{"type":"‚àÄ {Œ± : Type u_1} (self : Finset Œ±), Multiset.Nodup (Finset.val self)","name":"Finset.nodup","isProp":true,"docString":"`val` contains no duplicates "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst : TopologicalSpace.SecondCountableTopology Œ±] {y : (a : Œ±) ‚Üí Œ±} {s : Set Œ±}\n  (h : Set.PairwiseDisjoint s fun (x : Œ±) ‚Ü¶ Set.Ioo x (y x)) (h' : ‚àÄ (x : Œ±) (a : x ‚àà s), x < y x), Set.Countable s","name":"Set.PairwiseDisjoint.countable_of_Ioo","isProp":true,"docString":"Consider a disjoint family of intervals `(x, y)` with `x < y` in a second-countable space.\nThen the family is countable.\nThis is not a straightforward consequence of second-countability as some of these intervals might be\nempty (but in fact this can happen only for countably many of them). "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MulOneClass Œ±] [inst_1 : CommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsMonoidHom f),\n  IsMonoidHom fun (a : Œ±) ‚Ü¶ (f a)‚Åª¬π","name":"IsMonoidHom.inv","isProp":true,"docString":"The inverse of a map which preserves multiplication,\npreserves multiplication when the target is commutative. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : CompleteLattice Œ±] {f : Filter Œ≤}, Filter.limsup (fun (x : Œ≤) ‚Ü¶ ‚ä•) f = ‚ä•","name":"Filter.limsup_const_bot","isProp":true,"docString":"Same as limsup_const applied to `‚ä•` but without the `NeBot f` assumption "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} (a_1 : 0 ‚â§ a), 0 ‚â§ a‚Åª¬π","name":"inv_nonneg_of_nonneg","isProp":true,"docString":"**Alias** of the reverse direction of `inv_nonneg`."},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : Mul M‚ÇÄ] [inst_1 : Zero M‚ÇÄ] [self : NoZeroDivisors M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ} (a_1 : a * b = 0),\n  (a = 0 : Prop) ‚à® (b = 0 : Prop)","name":"NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero","isProp":true,"docString":"For all `a` and `b` of `G‚ÇÄ`, `a * b = 0` implies `a = 0` or `b = 0`. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] {s‚ÇÇ : Finset Œπ} (h : s‚ÇÇ ‚äÜ s)\n  (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) (b : P),\n  ‚Üë(Finset.weightedVSubOfPoint (s \\ s‚ÇÇ) p b) w - ‚Üë(Finset.weightedVSubOfPoint s‚ÇÇ p b) (-w) =\n    ‚Üë(Finset.weightedVSubOfPoint s p b) w","name":"Finset.weightedVSubOfPoint_sdiff_sub","isProp":true,"docString":"A weighted sum may be split into a subtraction of such sums over two subsets. "},{"type":"‚àÄ (R : Type u_1) {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] (w : (a : œÉ) ‚Üí M)\n  (i : œÉ), MvPolynomial.IsWeightedHomogeneous w (MvPolynomial.X i) (w i)","name":"MvPolynomial.isWeightedHomogeneous_X","isProp":true,"docString":"An indeterminate `i : œÉ` is weighted homogeneous of degree `w i`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {uas : Set (UniformSpace Œ±)}\n  {ubs : Set (UniformSpace Œ≤)} {ua : UniformSpace Œ±} {ub : UniformSpace Œ≤} {uc : UniformSpace Œ≥} (ha : ua ‚àà uas)\n  (hb : ub ‚àà ubs) (hf : UniformContinuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)),\n  UniformContinuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)","name":"uniformContinuous_inf‚Çõ_dom‚ÇÇ","isProp":true,"docString":"A version of `uniformContinuous_inf‚Çõ_dom` for binary functions "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] (f : (a : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí M) (n : ‚Ñï),\n  (Finset.sum (Finset.Nat.antidiagonal n) fun (ij : ‚Ñï √ó ‚Ñï) ‚Ü¶ f (Prod.fst ij) (Prod.snd ij)) =\n    Finset.sum (Finset.range (Nat.succ n)) fun (k : ‚Ñï) ‚Ü¶ f k (n - k)","name":"Finset.Nat.sum_antidiagonal_eq_sum_range_succ","isProp":true,"docString":"This lemma matches more generally than\n`Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk` when using `rw ‚Üê`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  [inst_1 : CategoryTheory.Limits.HasImage f],\n  CategoryTheory.Limits.MonoFactorisation.e (CategoryTheory.Limits.Image.monoFactorisation f) =\n    CategoryTheory.Limits.factorThruImage f","name":"CategoryTheory.Limits.as_factorThruImage","isProp":true,"docString":"Rewrite in terms of the `factorThruImage` interface. "},{"type":"‚àÄ (M : Type u_1) (Œ± : Type u_2) [inst : Group M] [inst_1 : MulAction M Œ±] {P : Subgroup M} {Q : Subgroup M},\n  MulAction.fixedPoints { x : M // x ‚àà P ‚äî Q } Œ± =\n    MulAction.fixedPoints { x : M // x ‚àà P } Œ± ‚à© MulAction.fixedPoints { x : M // x ‚àà Q } Œ±","name":"fixedPoints_subgroup_sup","isProp":true,"docString":"Fixed points of sup of subgroups is intersection "},{"type":"‚àÄ (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] {m : Type u_1} {n : Type u_2} [inst_4 : Finite m] [inst_5 : Finite n],\n  Module.Free R (Matrix m n M)","name":"Module.Free.matrix","isProp":true,"docString":"The module of finite matrices is free. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [inst_1 : IsModularLattice Œ±] [inst_2 : IsCompactlyGenerated Œ±]\n  (h : sup‚Çõ (setOf fun (a : Œ±) ‚Ü¶ IsAtom a) = ‚ä§) (b : Œ±),\n  ‚àÉ (s : Set Œ±),\n    (CompleteLattice.SetIndependent s : Prop) ‚àß\n      ((IsCompl b (sup‚Çõ s) : Prop) ‚àß (‚àÄ ‚¶Éa : Œ±‚¶Ñ (a_1 : a ‚àà s), IsAtom a : Prop) : Prop)","name":"exists_setIndependent_isCompl_sup‚Çõ_atoms","isProp":true,"docString":"In an atomic lattice, every element `b` has a complement of the form `Sup s`, where each element\nof `s` is an atom. See also `complemented_lattice_of_Sup_atoms_eq_top`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ} {p' : Filter Œ±} [inst_1 : Filter.NeBot p] (hF : UniformCauchySeqOnFilter F p p')\n  (hF' : Filter.Eventually (fun (x : Œ±) ‚Ü¶ Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n x) p (nhds (f x))) p'),\n  TendstoUniformlyOnFilter F f p p'","name":"UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto","isProp":true,"docString":"A uniformly Cauchy sequence converges uniformly to its limit "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryCoproducts C], CategoryTheory.Limits.HasBinaryBiproducts C","name":"CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryCoproducts","isProp":true,"docString":"In a preadditive category, if all binary coproducts exist, then all binary biproducts exist. "},{"type":"‚àÄ {K : Type u_2} [inst : DivisionRing K] {Œì‚ÇÄ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Œì‚ÇÄ]\n  [inst_2 : Nontrivial Œì‚ÇÄ] (v : AddValuation K Œì‚ÇÄ) {x : K}, (AddValuation.asFun v x = ‚ä§ : Prop) ‚Üî (x = 0 : Prop)","name":"AddValuation.top_iff","isProp":true,"docString":"If `v` is an additive valuation on a division ring then `v(x) = ‚ä§` iff `x = 0`. "},{"type":"‚àÄ {R : Type u_2} {Œπ : Type u_1} {M‚ÇÇ : Type u_3} {M‚ÇÉ : Type u_4} [inst : CommSemiring R] [inst_1 : AddCommMonoid M‚ÇÇ]\n  [inst_2 : AddCommMonoid M‚ÇÉ] [inst_3 : Module R M‚ÇÇ] [inst_4 : Module R M‚ÇÉ] [inst_5 : Finite Œπ]\n  {f : MultilinearMap R (fun (x : Œπ) ‚Ü¶ M‚ÇÇ) M‚ÇÉ} {g : MultilinearMap R (fun (x : Œπ) ‚Ü¶ M‚ÇÇ) M‚ÇÉ} {Œπ‚ÇÅ : Type u_5}\n  (e : Basis Œπ‚ÇÅ R M‚ÇÇ) (h : ‚àÄ (v : (a : Œπ) ‚Üí Œπ‚ÇÅ), (‚Üëf fun (i : Œπ) ‚Ü¶ ‚Üëe (v i)) = ‚Üëg fun (i : Œπ) ‚Ü¶ ‚Üëe (v i)), f = g","name":"Basis.ext_multilinear","isProp":true,"docString":"Two multilinear maps indexed by a `Fintype` are equal if they are equal when all arguments\nare basis vectors. Unlike `Basis.ext_multilinear_fin`, this only uses a single basis; a\ndependently-typed version would still be true, but the proof would need a dependently-typed\nversion of `dom_dom_congr`. "},{"type":"‚àÄ {Œ± : Type u_1} {p : (a : Finset Œ±) ‚Üí Prop} [inst : DecidableEq Œ±] (S : Finset Œ±) (h‚ÇÅ : p ‚àÖ)\n  (h‚ÇÇ : ‚àÄ {a : Œ±} {s : Finset Œ±} (a_1 : a ‚àà S) (a_2 : s ‚äÜ S) (a_3 : ¬¨(a ‚àà s : Prop)) (a_4 : p s), p (insert a s)), p S","name":"Finset.induction_on'","isProp":true,"docString":"To prove a proposition about `S : Finset Œ±`,\nit suffices to prove it for the empty `Finset`,\nand to show that if it holds for some `Finset Œ± ‚äÜ S`,\nthen it holds for the `Finset` obtained by inserting a new element of `S`.\n"},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type u_1} {s : Set Œπ} (hs : Set.Finite s) {t : (i : Œπ) ‚Üí (a : i ‚àà s) ‚Üí Set Œ±}\n  (ht : ‚àÄ (i : Œπ) (hi : i ‚àà s), Set.Finite (t i hi)),\n  Set.Finite (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà s) ‚Ü¶ t i h)","name":"Set.Finite.bunion·µ¢'","isProp":true,"docString":"Dependent version of `Finite.bunion·µ¢`. "},{"type":"‚àÄ {b : Ordinal} {o : Ordinal} (ho : o ‚â† 0),\n  Ordinal.CNF b o = (Ordinal.log b o, o / b ^ Ordinal.log b o) :: Ordinal.CNF b (o % b ^ Ordinal.log b o)","name":"Ordinal.CNF_ne_zero","isProp":true,"docString":"Recursive definition for the Cantor normal form. "},{"type":"‚àÄ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a","name":"isSquare_of_charTwo'","isProp":true,"docString":"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. "},{"type":"‚àÄ {Œ± : Type v} {S : Type w} (e : Œ± ‚âÉ S), Small Œ±","name":"Small.mk'","isProp":true,"docString":"Constructor for `Small Œ±` from an explicit witness type and equivalence.\n"},{"type":"‚àÄ {Œπ : Type u_1} {A : (a : Œπ) ‚Üí Type u_2} [inst : AddCommMonoid Œπ] [self : GradedMonoid.GCommMonoid A]\n  (a : GradedMonoid A) (b : GradedMonoid A), a * b = b * a","name":"GradedMonoid.GCommMonoid.mul_comm","isProp":true,"docString":"Multiplication is commutative "},{"type":"‚àÄ {E : Type u_3} {F : Type u_4} {ùïú‚ÇÅ : Type u_1} {ùïú‚ÇÇ : Type u_2} [inst : NormedDivisionRing ùïú‚ÇÅ]\n  [inst_1 : NormedDivisionRing ùïú‚ÇÇ] [inst_2 : AddCommGroup E] [inst_3 : Module ùïú‚ÇÅ E] [inst_4 : AddCommGroup F]\n  [inst_5 : Module ùïú‚ÇÇ F] [inst_6 : TopologicalSpace E] [inst_7 : TopologicalSpace F] {œÉ : ùïú‚ÇÅ ‚Üí+* ùïú‚ÇÇ}\n  [inst_8 : RingHomSurjective œÉ] [inst_9 : RingHomIsometric œÉ] {s : Set E} (hs : Bornology.IsVonNBounded ùïú‚ÇÅ s)\n  (f : E ‚ÜíSL[œÉ] F), Bornology.IsVonNBounded ùïú‚ÇÇ (‚Üëf '' s)","name":"Bornology.IsVonNBounded.image","isProp":true,"docString":"A continuous linear image of a bounded set is bounded. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] (u : E) (v : E), ‚Äñu‚Äñ ‚â§ ‚Äñv‚Äñ + ‚Äñu - v‚Äñ","name":"norm_le_insert'","isProp":true,"docString":"**Alias** of `norm_le_norm_add_norm_sub'`."},{"type":"‚àÄ (Œ± : Type u) [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.SecondCountableTopology Œ±] [inst_2 : T3Space Œ±],\n  NormalSpace Œ±","name":"normalSpaceOfT3SecondCountable","isProp":true,"docString":"A T‚ÇÉ topological space with second countable topology is a normal space.\nThis lemma is not an instance to avoid a loop. "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x : R} {y : R} (a : x ‚àà s) (a : y ‚àà s), x + y ‚àà s","name":"Subsemiring.add_mem","isProp":true,"docString":"A subsemiring is closed under addition. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictMonoOn f s) (hg : MonotoneOn g s), StrictMonoOn (fun (x : Œ≤) ‚Ü¶ f x * g x) s","name":"StrictMonoOn.mul_monotone'","isProp":true,"docString":"The product of a strictly monotone function and a monotone function is strictly monotone. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Top Œ±] [inst_1 : Top Œ≤]\n  [self : TopHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä§ = ‚ä§","name":"TopHomClass.map_top","isProp":true,"docString":"A `TopHomClass` morphism preserves the top element. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] {J : Type w‚ÇÅ}\n  (F : C ‚•§ D) (f : (a : J) ‚Üí C) [inst_4 : CategoryTheory.Limits.HasBiproduct f]\n  [inst_5 : CategoryTheory.Limits.HasBiproduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) ‚àò f)]\n  [inst_6 : CategoryTheory.Functor.PreservesZeroMorphisms F],\n  CategoryTheory.Functor.biproductComparison' F f ‚â´ CategoryTheory.Functor.biproductComparison F f =\n    ùüô (‚®Å Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) ‚àò f)","name":"CategoryTheory.Functor.biproductComparison'_comp_biproductComparison","isProp":true,"docString":"The composition in the opposite direction is equal to the identity if and only if `F` preserves\nthe biproduct, see `preservesBiproduct_of_monoBiproductComparison`.  "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommSemiring Œ±] (E : LinearRecurrence Œ±) (u : (a : ‚Ñï) ‚Üí Œ±) (v : (a : ‚Ñï) ‚Üí Œ±)\n  (hu : LinearRecurrence.IsSolution E u) (hv : LinearRecurrence.IsSolution E v),\n  (u = v : Prop) ‚Üî (Set.EqOn u v ‚Üë(Finset.range (LinearRecurrence.order E)) : Prop)","name":"LinearRecurrence.sol_eq_of_eq_init","isProp":true,"docString":"Two solutions are equal iff they are equal on `range E.order`. "},{"type":"‚àÄ {a : ENNReal} {b : ENNReal} {c : ENNReal} (hle : a ‚â§ b + c) (hb : b ‚â† ‚ä§) (hc : c ‚â† ‚ä§),\n  ENNReal.toReal a ‚â§ ENNReal.toReal b + ENNReal.toReal c","name":"ENNReal.toReal_le_add","isProp":true,"docString":"If `a ‚â§ b + c`, `b ‚â† ‚àû`, and `c ‚â† ‚àû`, then\n`ENNReal.toReal a ‚â§ ENNReal.toReal b + ENNReal.toReal c`. This lemma is useful to transfer\ntriangle-like inequalities from `ENNReal`s to `Real`s. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasImages C]\n  (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Mono f], CategoryTheory.Subobject.exists_ f = CategoryTheory.Subobject.map f","name":"CategoryTheory.Subobject.exists_iso_map","isProp":true,"docString":"When `f : X ‚ü∂ Y` is a monomorphism, `exists_ f` agrees with `map f`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : ¬¨(a < b : Prop)),\n  Finset.Ioc a b = ‚àÖ","name":"Finset.Ioc_eq_empty","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.Ioc_eq_empty_iff`."},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : Semiring R] [inst_1 : NoZeroDivisors R] [inst_2 : AddLeftCancelSemigroup A]\n  [inst_3 : LinearOrder A]\n  [inst_4 : CovariantClass A A (Function.swap fun (x : A) (x_1 : A) ‚Ü¶ x + x_1) fun (x : A) (x_1 : A) ‚Ü¶ x < x_1],\n  NoZeroDivisors (AddMonoidAlgebra R A)","name":"AddMonoidAlgebra.NoZeroDivisors.of_right_ordered","isProp":true,"docString":"If `R` is a semiring with no non-trivial zero-divisors and `A` is a right-ordered add left\ncancel semigroup, then `AddMonoidAlgebra R A` also contains no non-zero zero-divisors. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} (a : FreeGroup.Red L‚ÇÅ L‚ÇÇ), List.Sublist L‚ÇÇ L‚ÇÅ","name":"FreeGroup.Red.sublist","isProp":true,"docString":"If `w‚ÇÅ w‚ÇÇ` are words such that `w‚ÇÅ` reduces to `w‚ÇÇ`, then `w‚ÇÇ` is a sublist of `w‚ÇÅ`. "},{"type":"‚àÄ {P : Type u_1} [inst : Preorder P] (self : Order.Cofinal P) (x : P),\n  ‚àÉ (y : P), (y ‚àà Order.Cofinal.carrier self : Prop) ‚àß (x ‚â§ y : Prop)","name":"Order.Cofinal.mem_gt","isProp":true,"docString":"The `Cofinal` contains arbitrarily large elements. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (1 < a‚Åª¬π : Prop) ‚Üî (a < 1 : Prop)","name":"Left.one_lt_inv_iff","isProp":true,"docString":"Uses `left` co(ntra)variant. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {Œ≤ : Type u_3} {S : (a : Œπ) ‚Üí Set Œ±} {f : (i : Œπ) ‚Üí (x : ‚Üë(S i)) ‚Üí Œ≤}\n  {hf :\n    ‚àÄ (i : Œπ) (j : Œπ) (x : Œ±) (hxi : x ‚àà S i) (hxj : x ‚àà S j),\n      f i { val := x, property := hxi } = f j { val := x, property := hxj }}\n  {T : Set Œ±} {hT : T ‚äÜ Set.union·µ¢ S} (hT' : T = Set.union·µ¢ S)\n  (dir : Directed (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚â§ x_1) S) (op : (a : ‚ÜëT) ‚Üí (a : ‚ÜëT) ‚Üí ‚ÜëT)\n  (opi : (i : Œπ) ‚Üí (a : ‚Üë(S i)) ‚Üí (a : ‚Üë(S i)) ‚Üí ‚Üë(S i))\n  (hopi :\n    ‚àÄ (i : Œπ) (x : ‚Üë(S i)) (y : ‚Üë(S i)),\n      Set.inclusion\n          (let_fun this : S i ‚äÜ T :=\n              ((Eq.rec ((Set.subset_union·µ¢ S i=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)\n                    ((Eq.symm hT'=:Set.union·µ¢ S = T)=:Set.union·µ¢ S = T)=:S i ‚äÜ T)=:S i ‚äÜ T);\n            this=:S i ‚äÜ T)\n          (opi i x y) =\n        op\n          (Set.inclusion\n            (let_fun this : S i ‚äÜ T :=\n                ((Eq.rec\n                      ((Set.subset_union·µ¢ S i=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)\n                      ((Eq.symm hT'=:Set.union·µ¢ S = T)=:Set.union·µ¢ S = T)=:S i ‚äÜ T)=:S i ‚äÜ T);\n              this=:S i ‚äÜ T)\n            x)\n          (Set.inclusion\n            (let_fun this : S i ‚äÜ T :=\n                ((Eq.rec\n                      ((Set.subset_union·µ¢ S i=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)\n                      ((Eq.symm hT'=:Set.union·µ¢ S = T)=:Set.union·µ¢ S = T)=:S i ‚äÜ T)=:S i ‚äÜ T);\n              this=:S i ‚äÜ T)\n            y))\n  (opŒ≤ : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Œ≤) (h : ‚àÄ (i : Œπ) (x : ‚Üë(S i)) (y : ‚Üë(S i)), f i (opi i x y) = opŒ≤ (f i x) (f i y))\n  (x : ‚ÜëT) (y : ‚ÜëT),\n  Set.union·µ¢Lift S f hf T ((le_of_eq hT'=:T ‚â§ Set.union·µ¢ S)=:T ‚â§ Set.union·µ¢ S) (op x y) =\n    opŒ≤ (Set.union·µ¢Lift S f hf T ((le_of_eq hT'=:T ‚â§ Set.union·µ¢ S)=:T ‚â§ Set.union·µ¢ S) x)\n      (Set.union·µ¢Lift S f hf T ((le_of_eq hT'=:T ‚â§ Set.union·µ¢ S)=:T ‚â§ Set.union·µ¢ S) y)","name":"Set.union·µ¢Lift_binary","isProp":true,"docString":"`union·µ¢Lift_binary` is useful for proving that `union·µ¢Lift` is a homomorphism\nof algebraic structures when defined on the Union of algebraic subobjects.\nFor example, it could be used to prove that the lift of a collection\nof group homomorphisms on a union of subgroups preserves `*`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥‚ÇÅ : ‚Ñù} {Œ¥‚ÇÇ : ‚Ñù} (hle : Œ¥‚ÇÅ ‚â§ Œ¥‚ÇÇ) (E : Set Œ±),\n  Metric.thickening Œ¥‚ÇÅ E ‚äÜ Metric.thickening Œ¥‚ÇÇ E","name":"Metric.thickening_mono","isProp":true,"docString":"The (open) thickening `Metric.thickening Œ¥ E` of a fixed subset `E` is an increasing function of\nthe thickening radius `Œ¥`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_4} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) {pred : (a : Œπ) ‚Üí Prop}\n  [inst_3 : DecidablePred pred] (h : ‚àÄ (i : Œπ) (a : i ‚àà s) (a : w i ‚â† 0), pred i),\n  ‚Üë(Finset.affineCombination k (Finset.filter pred s) p) w = ‚Üë(Finset.affineCombination k s p) w","name":"Finset.affineCombination_filter_of_ne","isProp":true,"docString":"An affine combination over `s.filter pred` equals one over `s` if all the weights at indices\nin `s` not satisfying `pred` are zero. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] [self : NoMinOrder Œ±] (a : Œ±), ‚àÉ (b : Œ±), b < a","name":"NoMinOrder.exists_lt","isProp":true,"docString":"For each term `a`, there is some strictly smaller `b`. "},{"type":"‚àÄ {Œ± : Type u_2} {F : Type u_3} {ùïú : Type u_1} [inst : Norm F] [inst_1 : NormedField ùïú] {g : (a : Œ±) ‚Üí F} {l : Filter Œ±}\n  {c : ùïú} {f : (a : Œ±) ‚Üí ùïú} (hc : c ‚â† 0) (a : (fun (x : Œ±) ‚Ü¶ c * f x) =Œò[l] g), f =Œò[l] g","name":"Asymptotics.IsTheta.of_const_mul_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isTheta_const_mul_left`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤}\n  {t : Set Œ≤} (hf : Continuous f) (hst : Set.MapsTo f s t), Filter.Tendsto f (nhdsSet s) (nhdsSet t)","name":"Continuous.tendsto_nhdsSet","isProp":true,"docString":"Preimage of a set neighborhood of `t` under a continuous map `f` is a set neighborhood of `s`\nprovided that `f` maps `s` to `t`.  "},{"type":"‚àÄ {X : Type u} {m‚ÇÅ : (a : X) ‚Üí (a : X) ‚Üí X} {m‚ÇÇ : (a : X) ‚Üí (a : X) ‚Üí X} {e‚ÇÅ : X} {e‚ÇÇ : X}\n  (h‚ÇÅ : EckmannHilton.IsUnital m‚ÇÅ e‚ÇÅ) (h‚ÇÇ : EckmannHilton.IsUnital m‚ÇÇ e‚ÇÇ)\n  (distrib : ‚àÄ (a : X) (b : X) (c : X) (d : X), m‚ÇÅ (m‚ÇÇ a b) (m‚ÇÇ c d) = m‚ÇÇ (m‚ÇÅ a c) (m‚ÇÅ b d)), m‚ÇÅ = m‚ÇÇ","name":"EckmannHilton.mul","isProp":true,"docString":"If a type carries two unital binary operations that distribute over each other,\nthen these operations are equal.\n\nIn fact, they give a commutative monoid structure, see `eckmann_hilton.CommMonoid`. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R)\n  (s : { x : R // x ‚àà S }) (t : R) (hst : ‚Üës * t ‚àà S), r /‚Çí s = r * t /‚Çí { val := ‚Üës * t, property := hst }","name":"OreLocalization.expand","isProp":true,"docString":"A fraction `r /‚Çí s` is equal to its expansion by an arbitrary factor `t` if `s * t ‚àà S`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type u} (f : (a : Œ≤) ‚Üí Œ±) (w : Cardinal.mk Œ± < Cardinal.mk Œ≤)\n  (w' : Cardinal.aleph0 ‚â§ Cardinal.mk Œ±), ‚àÉ (a : Œ±), Cardinal.mk Œ± < Cardinal.mk ‚Üë(f ‚Åª¬π' {a})","name":"Cardinal.infinite_pigeonhole_card_lt","isProp":true,"docString":"A function whose codomain's cardinality is infinite but strictly smaller than its domain's\nhas a fiber with cardinality strictly great than the codomain.\n"},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] {p1 : P} {p2 : P} (h : p1 -·µ• p2 = 0), p1 = p2","name":"eq_of_vsub_eq_zero","isProp":true,"docString":"If subtracting two points produces 0, they are equal. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E], ConvexOn ‚Ñù Set.univ norm","name":"convexOn_univ_norm","isProp":true,"docString":"The norm on a real normed space is convex on the whole space. See also `Seminorm.convexOn`\nand `convexOn_norm`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {t : Set Œ±}\n  [ht : Set.OrdConnected t], OrderTopology ‚Üët","name":"orderTopology_of_ordConnected","isProp":true,"docString":"On an `Set.OrdConnected` subset of a linear order, the order topology for the restriction of the\norder is the same as the restriction to the subset of the order topology. "},{"type":"‚àÄ {Œ± : Type u_4} {M : Type u_1} {N : Type u_2} {P : Type u_3} [inst : Zero M] [inst_1 : AddCommMonoid N]\n  [inst_2 : AddCommMonoid P] (h : N ‚âÉ+ P) (f : Œ± ‚Üí‚ÇÄ M) (g : (a : Œ±) ‚Üí (a : M) ‚Üí N),\n  ‚Üëh (Finsupp.sum f g) = Finsupp.sum f fun (a : Œ±) (b : M) ‚Ü¶ ‚Üëh (g a b)","name":"AddEquiv.map_finsupp_sum","isProp":true,"docString":"Deprecated, use `_root_.map_finsupp_sum` instead."},{"type":"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L],\n  SMulCommClass R (CommutatorRing L) (CommutatorRing L)","name":"LieAlgebra.smulCommClass","isProp":true,"docString":"Regarding the `LieRing` of a `LieAlgebra` as a `NonUnitalNonAssocSemiring`, we can\nreinterpret the `lie_smul` law as an `SMulCommClass`. "},{"type":"‚àÄ {R : Type u_1} [inst : AddSemigroup R] {a : R} (b : R) (ha : IsAddLeftRegular a),\n  (IsAddLeftRegular (a + b) : Prop) ‚Üî (IsAddLeftRegular b : Prop)","name":"add_isAddLeftRegular_iff","isProp":true,"docString":"An element is add-left-regular if and only if adding to it on the left\na add-left-regular element is add-left-regular."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {rŒ≤ : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} (f : (a : Œ±) ‚Üí Œ≤)\n  (fib : Relation.Fibration rŒ± rŒ≤ f) {a : Œ±} (ha : Acc rŒ± a), Acc rŒ≤ (f a)","name":"Acc.of_fibration","isProp":true,"docString":"If `f : Œ± ‚Üí Œ≤` is a fibration between relations `rŒ±` and `rŒ≤`, and `a : Œ±` is\naccessible under `rŒ±`, then `f a` is accessible under `rŒ≤`. "},{"type":"‚àÄ {C : Type u} [ùíû : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)\n  [inst : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair Y Z)]\n  [inst :\n    CategoryTheory.Limits.HasColimit\n      (CategoryTheory.Limits.parallelPair (f ‚â´ CategoryTheory.Limits.coprod.inl)\n        (g ‚â´ CategoryTheory.Limits.coprod.inr))],\n  CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)","name":"CategoryTheory.Limits.hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair","isProp":true,"docString":"If the coproduct `Y ‚®ø Z` and the coequalizer of `f ‚â´ Œπ‚ÇÅ` and `g ‚â´ Œπ‚ÇÇ` exist, then the\npushout of `f` and `g` exists: It is given by composing the inclusions with the coequalizer. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} {m : ‚Ñï} {n : ‚Ñï} (hmn : m ‚â§ n) {d : (a : ‚Ñï) ‚Üí ENNReal}\n  (hd : ‚àÄ {k : ‚Ñï} (a : m ‚â§ k) (a : k < n), edist (f k) (f (k + 1)) ‚â§ d k),\n  edist (f m) (f n) ‚â§ Finset.sum (Finset.Ico m n) fun (i : ‚Ñï) ‚Ü¶ d i","name":"edist_le_Ico_sum_of_edist_le","isProp":true,"docString":"A version of `edist_le_Ico_sum_edist` with each intermediate distance replaced\nwith an upper estimate. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {S : Type v} [inst_1 : Ring S] (f : R ‚Üí+* S) (p : Polynomial S),\n  (p ‚àà Polynomial.lifts f : Prop) ‚Üî (p ‚àà Polynomial.liftsRing f : Prop)","name":"Polynomial.lifts_iff_liftsRing","isProp":true,"docString":"If `R` and `S` are rings, `p` is in the subring of polynomials that lift if and only if it is in\nthe subsemiring of polynomials that lift. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : IdemSemiring Œ±] {a : Œ±} {b : Œ±} (a_1 : b ‚â§ a), a + b = a","name":"LE.le.add_eq_left","isProp":true,"docString":"**Alias** of the reverse direction of `add_eq_left_iff_le`."},{"type":"‚àÄ (n : ‚Ñï), ‚ÜëMultiset.card (Multiset.Nat.antidiagonal n) = n + 1","name":"Multiset.Nat.card_antidiagonal","isProp":true,"docString":"The cardinality of the antidiagonal of `n` is `n+1`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : Infinite Œ±] (n : ‚Ñï), ‚àÉ (s : Finset Œ±), Finset.card s = n","name":"Infinite.exists_subset_card_eq","isProp":true,"docString":"See `Infinite.exists_superset_card_eq` for a version that, for a `s : Finset Œ±`,\nprovides a superset `t : finset Œ±`, `s ‚äÜ t` such that `t.card` is fixed. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚©ø b), (a = b : Prop) ‚à® (a ‚ãñ b : Prop)","name":"Wcovby.eq_or_covby","isProp":true,"docString":"**Alias** of the forward direction of `wcovby_iff_eq_or_covby`."},{"type":"‚àÄ {R : Type u} [inst : Ring R] (hR : IsField R) (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R)\n  (hx : ‚ÜëPolynomial.C x ‚àà I), x = 0","name":"Ideal.eq_zero_of_constant_mem_of_maximal","isProp":true,"docString":"The only constant in a maximal ideal over a field is `0`. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : Nonempty J] {c : CategoryTheory.Limits.Cone (CategoryTheory.Limits.parallelFamily f)}\n  (i : CategoryTheory.Limits.IsLimit c), CategoryTheory.Mono (CategoryTheory.Limits.Trident.Œπ c)","name":"CategoryTheory.Limits.mono_of_isLimit_parallelFamily","isProp":true,"docString":"The wide equalizer morphism in any limit cone is a monomorphism. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedGroup E] (a : E) (b : E), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ + ‚Äñb‚Äñ","name":"norm_mul_le'","isProp":true,"docString":"**Triangle inequality** for the norm. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1], 0 < 2","name":"two_pos","isProp":true,"docString":"**Alias** of `zero_lt_two`."},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] (M : Submonoid R) (S : Type u_2) [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] (I : Ideal R) (hp : Ideal.IsPrime I) (hd : Disjoint ‚ÜëM ‚ÜëI),\n  Ideal.IsPrime (Ideal.map (algebraMap R S) I)","name":"IsLocalization.isPrime_of_isPrime_disjoint","isProp":true,"docString":"If `R` is a ring, then prime ideals in the localization at `M`\ncorrespond to prime ideals in the original ring `R` that are disjoint from `M`.\nThis lemma gives the particular case for an ideal and its map,\nsee `le_rel_iso_of_prime` for the more general relation isomorphism, and the reverse implication "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí. Œ≤} {g : Œ± ‚Üí. Œ≤}\n  (H1 : ‚àÄ (a : Œ±), (a ‚àà PFun.Dom f : Prop) ‚Üî (a ‚àà PFun.Dom g : Prop))\n  (H2 : ‚àÄ (a : Œ±) (p : PFun.Dom f a) (q : PFun.Dom g a), PFun.fn f a p = PFun.fn g a q), f = g","name":"PFun.ext'","isProp":true,"docString":"Partial function extensionality "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X‚ÇÅ‚ÇÅ : C} {X‚ÇÅ‚ÇÇ : C} {X‚ÇÅ‚ÇÉ : C} {X‚ÇÇ‚ÇÅ : C} {X‚ÇÇ‚ÇÇ : C} {X‚ÇÇ‚ÇÉ : C}\n  {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÉ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÉ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ}\n  {v‚ÇÅ‚ÇÉ : X‚ÇÅ‚ÇÉ ‚ü∂ X‚ÇÇ‚ÇÉ} (s : CategoryTheory.IsPullback (h‚ÇÅ‚ÇÅ ‚â´ h‚ÇÅ‚ÇÇ) v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÉ (h‚ÇÇ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÇ)) (p : h‚ÇÅ‚ÇÅ ‚â´ v‚ÇÅ‚ÇÇ = v‚ÇÅ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÅ)\n  (t : CategoryTheory.IsPullback h‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÇ), CategoryTheory.IsPullback h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ","name":"CategoryTheory.IsPullback.of_right","isProp":true,"docString":"Given a pullback square assembled from a commuting square on the left and\na pullback square on the right, the left square is a pullback square. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 < a) (hb : 0 ‚â§ b), 0 < a + b","name":"add_pos_of_pos_of_nonneg","isProp":true,"docString":"**Alias** of `Left.add_pos_of_pos_of_nonneg`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ≤] {ùîñ : Set (Set Œ±)} (h : ‚ãÉ‚ÇÄ ùîñ = Set.univ),\n  UniformContinuous ‚Üë(UniformOnFun.toFun ùîñ)","name":"UniformOnFun.uniformContinuous_toFun","isProp":true,"docString":"If `ùîñ` covers `Œ±`, the natural map `UniformOnFun.toFun` from `Œ± ‚Üí·µ§[ùîñ] Œ≤` to `Œ± ‚Üí Œ≤` is\nuniformly continuous.\n\nIn other words, if `ùîñ` covers `Œ±`, then the uniform structure of `ùîñ`-convergence is finer than\nthat of pointwise convergence. "},{"type":"‚àÄ {Œ± : Type u_1} {ùíú : Finset (Finset Œ±)} {A‚ÇÅ : Finset Œ±} {A‚ÇÇ : Finset Œ±} {r‚ÇÅ : ‚Ñï} {r‚ÇÇ : ‚Ñï} (h‚ÇÅ : A‚ÇÅ ‚àà Finset.slice ùíú r‚ÇÅ)\n  (h‚ÇÇ : A‚ÇÇ ‚àà Finset.slice ùíú r‚ÇÇ) (a : r‚ÇÅ ‚â† r‚ÇÇ), A‚ÇÅ ‚â† A‚ÇÇ","name":"Finset.ne_of_mem_slice","isProp":true,"docString":"Elements in distinct slices must be distinct. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ±) ‚Üí M} {s : Set Œ±}\n  (hs : Set.Finite s),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i + g i) =\n    (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ g i","name":"finsum_mem_add_distrib","isProp":true,"docString":"Given a finite set `s`, the sum of `f i + g i` over `i ‚àà s` equals the sum of `f i`\nover `i ‚àà s` plus the sum of `g i` over `i ‚àà s`."},{"type":"‚àÄ {a : ‚Ñ§} {p : ‚Ñï} (pp : Nat.Prime p) (h : Int.gcd a ‚Üëp ‚â† 1), ‚Üëa = 0","name":"ZMod.eq_zero_of_gcd_ne_one","isProp":true,"docString":"If an integer `a` and a prime `p` satisfy `gcd a p ‚â† 1`, then `a : ZMod p` is zero. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : SemilatticeSup Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} (h : Antitone fun (n : Œ≤) ‚Ü¶ Set.Icc (f n) (g n)) (h' : ‚àÄ (n : Œ≤), f n ‚â§ g n),\n  (sup·µ¢ fun (n : Œ≤) ‚Ü¶ f n) ‚àà Set.inter·µ¢ fun (n : Œ≤) ‚Ü¶ Set.Icc (f n) (g n)","name":"csup·µ¢_mem_Inter_Icc_of_antitone_Icc","isProp":true,"docString":"Nested intervals lemma: if `[f n, g n]` is an antitone sequence of nonempty\nclosed intervals, then `‚®Ü n, f n` belongs to all the intervals `[f n, g n]`. "},{"type":"‚àÄ {M : Type u_1} [inst : MonoidWithZero M] {f : ‚Ñ§ ‚Üí*‚ÇÄ M} {g : ‚Ñ§ ‚Üí*‚ÇÄ M} (h_neg_one : ‚Üëf (-1) = ‚Üëg (-1))\n  (h_nat :\n    MonoidWithZeroHom.comp f (RingHom.toMonoidWithZeroHom Int.ofNatHom) =\n      MonoidWithZeroHom.comp g (RingHom.toMonoidWithZeroHom Int.ofNatHom)),\n  f = g","name":"MonoidWithZeroHom.ext_int","isProp":true,"docString":"If two `MonoidWithZeroHom`s agree on `-1` and the naturals then they are equal. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} {s : Set Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] [inst_4 : ContinuousAdd Œ≥] {f : (a : Œ±) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ≥} (hf : UpperSemicontinuousWithinAt f s x) (hg : UpperSemicontinuousWithinAt g s x),\n  UpperSemicontinuousWithinAt (fun (z : Œ±) ‚Ü¶ f z + g z) s x","name":"UpperSemicontinuousWithinAt.add","isProp":true,"docString":"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. "},{"type":"‚àÄ (n : ‚Ñï) (k : ‚Ñï), Nat.factorization (n ^ k) = k ‚Ä¢ Nat.factorization n","name":"Nat.factorization_pow","isProp":true,"docString":"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {l : (a : Œ±) ‚Üí Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (gc : GaloisConnection l u) {x : Œ±} {y : Œ±} {z : Œ±} (hxy : x ‚â§ u (l y)) (hyz : y ‚â§ u (l z)), x ‚â§ u (l z)","name":"GaloisConnection.le_u_l_trans","isProp":true,"docString":"If `(l, u)` is a Galois connection, then the relation `x ‚â§ u (l y)` is a transitive relation.\nIf `l` is a closure operator (`Submodule.span`, `Subgroup.closure`, ...) and `u` is the coercion to\n`Set`, this reads as \"if `U` is in the closure of `V` and `V` is in the closure of `W` then `U` is\nin the closure of `W`\". "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] {f : Filter Œ≤} {u : (a : Œ≤) ‚Üí Œ±} {a : Œ±} [inst_3 : Filter.NeBot f]\n  (h : Filter.Tendsto u f (nhds a)), Filter.limsup u f = a","name":"Filter.Tendsto.limsup_eq","isProp":true,"docString":"If a function has a limit, then its limsup coincides with its limit. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {s : Set M} {t : Set M} (ht : IsAddSubmonoid t) (h : s ‚äÜ t),\n  AddMonoid.Closure s ‚äÜ t","name":"AddMonoid.closure_subset","isProp":true,"docString":"The `AddSubmonoid` generated by a set is contained in any `AddSubmonoid` that\ncontains the set."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤},\n  (StrictConcaveOn ùïú s (-f) : Prop) ‚Üî (StrictConvexOn ùïú s f : Prop)","name":"neg_strictConcaveOn_iff","isProp":true,"docString":"A function `-f` is strictly concave iff `f` is strictly convex. "},{"type":"‚àÄ {R : Type u_1} [inst : NonUnitalNonAssocRing R] (self : RingSeminorm R) (x : R) (y : R),\n  AddGroupSeminorm.toFun (RingSeminorm.toAddGroupSeminorm self) (x * y) ‚â§\n    AddGroupSeminorm.toFun (RingSeminorm.toAddGroupSeminorm self) x *\n      AddGroupSeminorm.toFun (RingSeminorm.toAddGroupSeminorm self) y","name":"RingSeminorm.mul_le'","isProp":true,"docString":"The property of a `RingSeminorm` that for all `x` and `y` in the ring, the norm of `x * y` is\nless than the norm of `x` times the norm of `y`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : OrderedSemiring Œ±] [self : FloorSemiring Œ±] {a : Œ±} (ha : a < 0), FloorSemiring.floor a = 0","name":"FloorSemiring.floor_of_neg","isProp":true,"docString":"`FloorSemiring.floor` of a negative element is zero."},{"type":"‚àÄ {Œ∑ : Type u_1} {f : (a : Œ∑) ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí AddGroup (f i)] [inst_1 : DecidableEq Œ∑] [inst_2 : Finite Œ∑]\n  {H : (i : Œ∑) ‚Üí AddSubgroup (f i)} {J : AddSubgroup ((i : Œ∑) ‚Üí f i)},\n  (AddSubgroup.pi Set.univ H ‚â§ J : Prop) ‚Üî (‚àÄ (i : Œ∑), AddSubgroup.map (AddMonoidHom.single f i) (H i) ‚â§ J : Prop)","name":"AddSubgroup.pi_le_iff","isProp":true,"docString":"For finite index types, the `Subgroup.pi` is generated by the embeddings of the\nadditive groups."},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s) {x : E} {y : E} (hx : x ‚àà s) (hy : x + y ‚àà interior s) {t : ùïú} (ht : t ‚àà Set.Ioc 0 1),\n  x + t ‚Ä¢ y ‚àà interior s","name":"Convex.add_smul_mem_interior","isProp":true,"docString":"If `x ‚àà s` and `x + y ‚àà interior s`, then `x + t y ‚àà interior s` for `t ‚àà (0, 1]`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {x : E} (hx : x ‚â† 0),\n  IsConnected (setOf fun (y : E) ‚Ü¶ (SameRay ‚Ñù x y : Prop) ‚àß (y ‚â† 0 : Prop))","name":"isConnected_setOf_sameRay_and_ne_zero","isProp":true,"docString":"The set of nonzero vectors in the same ray as the nonzero vector `x` is connected. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ) (Œ¥ : ‚Ñù) (s : Set Œ±),\n  Metric.cthickening Œµ (Metric.thickening Œ¥ s) ‚äÜ Metric.cthickening (Œµ + Œ¥) s","name":"Metric.cthickening_thickening_subset","isProp":true,"docString":"For the equality, see `cthickening_thickening`. "},{"type":"‚àÄ {Œ± : Type u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {a : Œ±} {b : Œ±} (hb : Acc r b) (h : r a b),\n  Acc.rank ((Acc.inv hb h=:Acc r a)=:Acc r a) < Acc.rank hb","name":"Acc.rank_lt_of_rel","isProp":true,"docString":"if `r a b` then the rank of `a` is less than the rank of `b`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] [inst_4 : CharZero k] {n : ‚Ñï} (s : Affine.Simplex k P n) {fs‚ÇÅ : Finset (Fin (n + 1))}\n  {fs‚ÇÇ : Finset (Fin (n + 1))} {m‚ÇÅ : ‚Ñï} {m‚ÇÇ : ‚Ñï} (h‚ÇÅ : Finset.card fs‚ÇÅ = m‚ÇÅ + 1) (h‚ÇÇ : Finset.card fs‚ÇÇ = m‚ÇÇ + 1),\n  (Finset.centroid k fs‚ÇÅ (Affine.Simplex.points s) = Finset.centroid k fs‚ÇÇ (Affine.Simplex.points s) : Prop) ‚Üî\n    (fs‚ÇÅ = fs‚ÇÇ : Prop)","name":"Affine.Simplex.centroid_eq_iff","isProp":true,"docString":"Over a characteristic-zero division ring, the centroids given by\ntwo subsets of the points of a simplex are equal if and only if those\nfaces are given by the same subset of points. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hf : ContinuousOn f s)\n  (hsc : IsClosed s) {x‚ÇÄ : Œ≤} (h‚ÇÄ : x‚ÇÄ ‚àà s)\n  (hc : Filter.Eventually (fun (x : Œ≤) ‚Ü¶ f x‚ÇÄ ‚â§ f x) (Filter.cocompact Œ≤ ‚äì Filter.principal s)),\n  ‚àÉ (x : Œ≤), (x ‚àà s : Prop) ‚àß (IsMinOn f s x : Prop)","name":"ContinuousOn.exists_isMinOn'","isProp":true,"docString":"The **extreme value theorem**: if a function `f` is continuous on a closed set `s` and it is\nlarger than a value in its image away from compact sets, then it has a minimum on this set. "},{"type":"‚àÄ {n : ‚Ñï} (self : Nat.Partition n), Multiset.sum (Nat.Partition.parts self) = n","name":"Nat.Partition.parts_sum","isProp":true,"docString":"proof that the `parts` sum to `n`"},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {f : M ‚Üí* N} {g : M ‚Üí* N} {s : Set M}\n  (h : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(Submonoid.closure s)","name":"MonoidHom.eqOn_closureM","isProp":true,"docString":"If two monoid homomorphisms are equal on a set, then they are equal on its submonoid closure. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 < a) (hb : 0 ‚â§ b), 0 < a + b","name":"Left.add_pos_of_pos_of_nonneg","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos_of_pos_of_nonneg`."},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [h : Nontrivial V], 0 < FiniteDimensional.finrank K V","name":"FiniteDimensional.finrank_pos","isProp":true,"docString":"A nontrivial finite dimensional space has positive `finrank`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : BoundedOrder Œ±] {x : Œ±} {y : Œ±} (self : IsCompl x y), Disjoint x y","name":"IsCompl.disjoint","isProp":true,"docString":"If `x` and `y` are to be complementary in an order, they should be disjoint. "},{"type":"‚àÄ {X : Type v} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : SigmaCompactSpace X]\n  [inst_3 : T2Space X] {Œπ : (a : X) ‚Üí Type u} {p : (x : X) ‚Üí (a : Œπ x) ‚Üí Prop} {B : (x : X) ‚Üí (a : Œπ x) ‚Üí Set X}\n  (hB : ‚àÄ (x : X), Filter.HasBasis (nhds x) (p x) (B x)),\n  ‚àÉ (Œ± : Type v),\n    ‚àÉ (c : (a : Œ±) ‚Üí X),\n      ‚àÉ (r : (a : Œ±) ‚Üí Œπ (c a)),\n        (‚àÄ (a : Œ±), p (c a) (r a) : Prop) ‚àß\n          (((Set.union·µ¢ fun (a : Œ±) ‚Ü¶ B (c a) (r a)) = Set.univ : Prop) ‚àß\n              (LocallyFinite fun (a : Œ±) ‚Ü¶ B (c a) (r a) : Prop) :\n            Prop)","name":"refinement_of_locallyCompact_sigmaCompact_of_nhds_basis","isProp":true,"docString":"Let `X` be a locally compact sigma compact Hausdorff topological space. Suppose that for each\n`x` the sets `B x : Œπ x ‚Üí Set X` with the predicate `p x : Œπ x ‚Üí Prop` form a basis of the filter\n`ùìù x`. Then there exists a locally finite covering `fun i ‚Ü¶ B (c i) (r i)` of `X` such that each\n`r i` satisfies `p (c i)`.\n\nThe notation is inspired by the case `B x r = Metric.ball x r` but the theorem applies to\n`nhds_basis_opens` as well. If the covering must be subordinate to some open covering of `s`, then\nthe user should use a basis obtained by `Filter.HasBasis.restrict_subset` or a similar lemma, see\nthe proof of `paracompact_of_locallyCompact_sigmaCompact` for an example.\n\nThe formalization is based on two [ncatlab](https://ncatlab.org/) proofs:\n* [locally compact and sigma compact spaces are paracompact](https://ncatlab.org/nlab/show/locally+compact+and+sigma-compact+spaces+are+paracompact);\n* [open cover of smooth manifold admits locally finite refinement by closed balls](https://ncatlab.org/nlab/show/partition+of+unity#ExistenceOnSmoothManifolds).\n\nSee also `refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set` for a version of this lemma\ndealing with a covering of a closed set.\n\nIn most cases (namely, if `B c r ‚à™ B c r'` is again a set of the form `B c r''`) it is possible\nto choose `Œ± = X`. This fact is not yet formalized in `mathlib`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhdsWithin a (Set.Ici a))\n  (hfs : closure (f '' s) ‚àà nhdsWithin (f a) (Set.Ici (f a))), ContinuousWithinAt f (Set.Ici a) a","name":"StrictMonoOn.continuousWithinAt_right_of_closure_image_mem_nhdsWithin","isProp":true,"docString":"If a function `f` with a densely ordered codomain is strictly monotone on a right neighborhood\nof `a` and the closure of the image of this neighborhood under `f` is a right neighborhood of `f a`,\nthen `f` is continuous at `a` from the right. "},{"type":"‚àÄ (M : Type u_2) (Œ± : Type u_3) [inst : Group M] [inst_1 : MulAction M Œ±] {Œπ : Sort u_1} {P : (a : Œπ) ‚Üí Subgroup M},\n  MulAction.fixedPoints { x : M // x ‚àà sup·µ¢ P } Œ± =\n    Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ MulAction.fixedPoints { x : M // x ‚àà P i } Œ±","name":"fixedPoints_subgroup_sup·µ¢","isProp":true,"docString":"Fixed points of sup·µ¢ of subgroups is intersection "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] (C : ENNReal) (hC : C ‚â† ‚ä§) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu : ‚àÄ (n : ‚Ñï), edist (f n) (f (n + 1)) ‚â§ C / 2 ^ n), CauchySeq f","name":"cauchySeq_of_edist_le_geometric_two","isProp":true,"docString":"If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then `f` is a Cauchy sequence."},{"type":"‚àÄ (R : Type u_1) [inst : CommRing R] (p : ‚Ñï) [inst_1 : Fact (Nat.Prime p : Prop)] [inst_2 : Finite R],\n  (IsUnit ‚Üëp : Prop) ‚Üî (¬¨(p ‚à£ ringChar R : Prop) : Prop)","name":"isUnit_iff_not_dvd_char","isProp":true,"docString":"A prime `p` is a unit in a finite commutative ring `R`\niff it does not divide the characteristic. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : IsSpectralMap f) ‚¶És : Set Œ≤‚¶Ñ (a : IsOpen s) (a : IsCompact s), IsCompact (f ‚Åª¬π' s)","name":"IsSpectralMap.isCompact_preimage_of_isOpen","isProp":true,"docString":"A function between topological spaces is spectral if it is continuous and the preimage of\nevery compact open set is compact open. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {w : (a : Œ±) ‚Üí M} {b : M} [inst_1 : LinearOrderedCancelAddCommMonoid M] (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚àà t)\n  (ht : Finset.Nonempty t) (hb : (Finset.sum s fun (x : Œ±) ‚Ü¶ w x) ‚â§ Finset.card t ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß ((Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x) ‚â§ b : Prop)","name":"Finset.exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality\nversion: if the total weight of a finite set of pigeons is less than or equal to `n ‚Ä¢ b`, and they\nare sorted into `n > 0` pigeonholes, then for some pigeonhole, the total weight of the pigeons in\nthis pigeonhole is less than or equal to `b`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p‚ÇÇ : (a : Œπ) ‚Üí P) (p‚ÇÅ : P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ i)) = p‚ÇÅ -·µ• ‚Üë(Finset.affineCombination k s p‚ÇÇ) w","name":"Finset.sum_smul_const_vsub_eq_vsub_affineCombination","isProp":true,"docString":"A weighted sum of pairwise subtractions, where the point on the left is constant and the\nsum of the weights is 1. "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {P : Submodule R M} (b : Basis Œπ R { x : M // x ‚àà P }) {x : M},\n  (x ‚àà P : Prop) ‚Üî (‚àÉ (c : Œπ ‚Üí‚ÇÄ R), x = Finsupp.sum c fun (i : Œπ) (x : R) ‚Ü¶ x ‚Ä¢ ‚Üë(‚Üëb i) : Prop)","name":"Basis.mem_submodule_iff","isProp":true,"docString":"If the submodule `P` has a basis, `x ‚àà P` iff it is a linear combination of basis vectors. "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {L‚ÇÅ : C ‚•§ D}\n  {L‚ÇÇ : C ‚•§ D} {R‚ÇÅ : D ‚•§ C} {R‚ÇÇ : D ‚•§ C} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (f : R‚ÇÅ ‚ü∂ R‚ÇÇ)\n  [inst_2 : CategoryTheory.IsIso (‚Üë(Equiv.symm (CategoryTheory.transferNatTransSelf adj‚ÇÅ adj‚ÇÇ)) f)],\n  CategoryTheory.IsIso f","name":"CategoryTheory.transferNatTransSelf_symm_of_iso","isProp":true,"docString":"If `f` is a natural transformation whose un-transferred natural transformation is an isomorphism,\nthen `f` is an isomorphism.\nThe converse is given in `transferNatTransSelf_symm_iso`.\n"},{"type":"‚àÄ (f : (a : Type u‚ÇÄ) ‚Üí Type u‚ÇÅ) [inst : EquivFunctor f] {Œ± : Type u‚ÇÄ} {Œ≤ : Type u‚ÇÄ} {Œ≥ : Type u‚ÇÄ} (ab : Œ± ‚âÉ Œ≤)\n  (bc : Œ≤ ‚âÉ Œ≥),\n  Equiv.trans (EquivFunctor.mapEquiv f ab) (EquivFunctor.mapEquiv f bc) = EquivFunctor.mapEquiv f (Equiv.trans ab bc)","name":"EquivFunctor.mapEquiv_trans","isProp":true,"docString":"The composition of `mapEquiv`s is carried over the `EquivFunctor`.\nFor plain `Functor`s, this lemma is named `map_map` when applied\nor `map_comp_map` when not applied.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [inst_1 : DiscreteTopology ‚Üës] {x : Œ±} (hx : x ‚àà s),\n  ‚àÉ (U : Set Œ±), (U ‚àà nhdsWithin x ({x}·∂ú) : Prop) ‚àß (Disjoint U s : Prop)","name":"disjoint_nhdsWithin_of_mem_discrete","isProp":true,"docString":"For point `x` in a discrete subset `s` of a topological space, there is a set `U`\nsuch that\n1. `U` is a punctured neighborhood of `x` (ie. `U ‚à™ {x}` is a neighbourhood of `x`),\n2. `U` is disjoint from `s`.\n"},{"type":"‚àÄ {x : ‚Ñù} (hx : 0 ‚â§ x), x + 1 ‚â§ Real.exp x","name":"Real.add_one_le_exp_of_nonneg","isProp":true,"docString":"This is an intermediate result that is later replaced by `Real.add_one_le_exp`; use that lemma\ninstead. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±} {t : Set Œ±} (h : BddAbove s), BddAbove (s ‚à© t)","name":"BddAbove.inter_of_left","isProp":true,"docString":"If `s` is bounded, then so is `s ‚à© t` "},{"type":"‚àÄ {E : Type u_1} {Œ≤ : Type u_2} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E] [inst_2 : Module ‚Ñù E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] [inst_5 : OrderedAddCommGroup Œ≤] [inst_6 : Module ‚Ñù Œ≤]\n  [inst_7 : OrderedSMul ‚Ñù Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤} {a : E} (a_in_s : a ‚àà s) (h_localmax : IsLocalMaxOn f s a)\n  (h_conc : ConcaveOn ‚Ñù s f), IsMaxOn f s a","name":"IsMaxOn.of_isLocalMaxOn_of_concaveOn","isProp":true,"docString":"A local maximum of a concave function is a global maximum, restricted to a set `s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {x : Œ±} (h : ContinuousWithinAt f s x), Filter.Tendsto f (nhdsWithin x s) (nhds (f x))","name":"ContinuousWithinAt.tendsto","isProp":true,"docString":"If a function is continuous within `s` at `x`, then it tends to `f x` within `s` by definition.\nWe register this fact for use with the dot notation, especially to use `Filter.Tendsto.comp` as\n`ContinuousWithinAt.comp` will have a different meaning. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Semigroup Œ±] [inst_1 : CommSemigroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : IsMulHom f) (hg : IsMulHom g), IsMulHom fun (a : Œ±) ‚Ü¶ f a * g a","name":"IsMulHom.mul","isProp":true,"docString":"A product of maps which preserve multiplication,\npreserves multiplication when the target is commutative. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ±} {b : Œ≤} (h : ‚àÄ (a : Œ±), f a b = a) (s : Set Œ±),\n  Set.image2 f s {b} = s","name":"Set.image2_right_identity","isProp":true,"docString":"If `b` is a right identity for `f : Œ± ‚Üí Œ≤ ‚Üí Œ±`, then `{b}` is a right identity for\n`Set.image2 f`. "},{"type":"‚àÄ {R : Type u_2} [inst : LinearOrderedCommRing R] {M : Type u_1} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroSMulDivisors R M] {v : M} (hv : v ‚â† 0) {r : R} (hr : r ‚â† 0),\n  (SameRay R v (r ‚Ä¢ v) : Prop) ‚Üî (0 < r : Prop)","name":"sameRay_smul_right_iff_of_ne","isProp":true,"docString":"A nonzero vector is in the same ray as a multiple of itself if and only if that multiple\nis positive. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {P : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : AddCommGroup P] [inst_4 : Module R P] (f : M ‚Üí‚Çó[R] P) {s : Submodule R M}\n  (hs1 : Submodule.Fg (Submodule.map f s)) (hs2 : Submodule.Fg (s ‚äì LinearMap.ker f)), Submodule.Fg s","name":"Submodule.fg_of_fg_map_of_fg_inf_ker","isProp":true,"docString":"If 0 ‚Üí M' ‚Üí M ‚Üí M'' ‚Üí 0 is exact and M' and M'' are\nfinitely generated then so is M. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {s : Set Œ±} (a : IsLowerSet s) ‚¶Éa : Œ±‚¶Ñ (a_1 : a ‚àà s), Set.Iio a ‚äÜ s","name":"IsLowerSet.Iio_subset","isProp":true,"docString":"**Alias** of the forward direction of `isLowerSet_iff_Iio_subset`."},{"type":"‚àÄ {G : Type u_1} {M : Type u_2} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MulAction G M]\n  [inst_3 : SMulCommClass G M M] [inst_4 : IsScalarTower G M M] (g : G) (m : MÀ£), (g ‚Ä¢ m)‚Åª¬π = g‚Åª¬π ‚Ä¢ m‚Åª¬π","name":"Units.smul_inv","isProp":true,"docString":"Note that this lemma exists more generally as the global `smul_inv` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Antitone f) {a : Œ±}\n  {s : Set Œ±} (a_1 : IsLeast s a), IsGreatest (f '' s) (f a)","name":"Antitone.map_isLeast","isProp":true,"docString":"An antitone map sends a least element of a set to a greatest element of its image. "},{"type":"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P),\n  (AffineIndependent k p : Prop) ‚Üî\n    (‚àÄ (s1 : Finset Œπ) (s2 : Finset Œπ) (w1 : (a : Œπ) ‚Üí k) (w2 : (a : Œπ) ‚Üí k)\n        (a : (Finset.sum s1 fun (i : Œπ) ‚Ü¶ w1 i) = 1) (a : (Finset.sum s2 fun (i : Œπ) ‚Ü¶ w2 i) = 1)\n        (a : ‚Üë(Finset.affineCombination k s1 p) w1 = ‚Üë(Finset.affineCombination k s2 p) w2),\n        Set.indicator (‚Üës1) w1 = Set.indicator (‚Üës2) w2 :\n      Prop)","name":"affineIndependent_iff_indicator_eq_of_affineCombination_eq","isProp":true,"docString":"A family is affinely independent if and only if any affine\ncombinations (with sum of weights 1) that evaluate to the same point\nhave equal `Set.indicator`. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedSemiring Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"LinearOrderedSemiring.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] [inst_1 : IsIrrefl Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  (a_1 : a ‚äÇ b), a ‚â† b","name":"HasSSubset.SSubset.ne","isProp":true,"docString":"**Alias** of `ne_of_ssubset`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {x : Œ±} {y : Œ≤} (hf : ContinuousAt f x),\n  ContinuousAt (fun (x : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst x)) (x, y)","name":"ContinuousAt.fst'","isProp":true,"docString":"Precomposing `f` with `Prod.fst` is continuous at `(x, y)` "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} (i : Œπ) [inst : Infinite (œÄ i)] [inst : ‚àÄ (i : Œπ), Nonempty (œÄ i)],\n  Infinite ((i : Œπ) ‚Üí œÄ i)","name":"Pi.infinite_of_exists_right","isProp":true,"docString":"If at least one `œÄ i` is infinite and the rest nonempty, the pi type of all `œÄ` is infinite. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {P : Type (max u v)} [inst_1 : AddCommGroup P] [inst_2 : Module R P]\n  (huniv :\n    ‚àÄ {M : Type (max v u)} {N : Type (max u v)} [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N]\n      [inst_5 : Module R M] [inst_6 : Module R N] (f : M ‚Üí‚Çó[R] N) (g : P ‚Üí‚Çó[R] N) (a : Function.Surjective ‚Üëf),\n      ‚àÉ (h : P ‚Üí‚Çó[R] M), LinearMap.comp f h = g),\n  Module.Projective R P","name":"Module.Projective.of_lifting_property","isProp":true,"docString":"A variant of `of_lifting_property'` when we're working over a `[Ring R]`,\nwhich only requires quantifying over modules with an `AddCommGroup` instance. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hb : 0 ‚â§ b) (hc : 0 ‚â§ c) (h : a ‚â§ c * b),\n  a / b ‚â§ c","name":"div_le_of_nonneg_of_le_mul","isProp":true,"docString":"One direction of `div_le_iff` where `b` is allowed to be `0` (but `c` must be nonnegative) "},{"type":"‚àÄ {R : Type u_2} [inst : CommSemiring R] (M : Submonoid R) {S : Type u_1} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] (z : S),\n  z * ‚Üë(algebraMap R S) ‚Üë(Prod.snd (IsLocalization.sec M z)) = ‚Üë(algebraMap R S) (Prod.fst (IsLocalization.sec M z))","name":"IsLocalization.sec_spec","isProp":true,"docString":"Given `z : S`, `IsLocalization.sec M z` is defined to be a pair `(x, y) : R √ó M` such\nthat `z * f y = f x` (so this lemma is true by definition). "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (B : (a : ‚Ñï) ‚Üí ‚Ñù) (hB : ‚àÄ (n : ‚Ñï), 0 < B n)\n  (H :\n    ‚àÄ (u : (a : ‚Ñï) ‚Üí Œ±) (a : ‚àÄ (N : ‚Ñï) (n : ‚Ñï) (m : ‚Ñï) (a : N ‚â§ n) (a : N ‚â§ m), dist (u n) (u m) < B N),\n      ‚àÉ (x : Œ±), Filter.Tendsto u Filter.atTop (nhds x)),\n  CompleteSpace Œ±","name":"Metric.complete_of_convergent_controlled_sequences","isProp":true,"docString":"A very useful criterion to show that a space is complete is to show that all sequences\nwhich satisfy a bound of the form `dist (u n) (u m) < B N` for all `n m ‚â• N` are\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\n`0`, which makes it possible to use arguments of converging series, while this is impossible\nto do in general for arbitrary Cauchy sequences. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {S : Set (Set Œ±)}\n  (K : DirectedOn (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äÜ x_1) S) (H : ‚àÄ (s : Set Œ±) (a : s ‚àà S), IsPreconnected s),\n  IsPreconnected (‚ãÉ‚ÇÄ S)","name":"IsPreconnected.union‚Çõ_directed","isProp":true,"docString":"The directed union‚Çõ of a set S of preconnected subsets is preconnected. "},{"type":"‚àÄ {k : Type u_2} {M : Type u_1} [inst : OrderedRing k] [inst_1 : OrderedAddCommGroup M] [inst_2 : Module k M]\n  [inst_3 : OrderedSMul k M]\n  [inst_4 : CovariantClass M M (fun (x : M) (x_1 : M) ‚Ü¶ x + x_1) fun (x : M) (x_1 : M) ‚Ü¶ x < x_1]\n  [inst_5 : ContravariantClass M M (fun (x : M) (x_1 : M) ‚Ü¶ x + x_1) fun (x : M) (x_1 : M) ‚Ü¶ x < x_1] {a : k} {b : k}\n  {c : M} {d : M} (hab : a < b) (hcd : c < d), a ‚Ä¢ d + b ‚Ä¢ c < a ‚Ä¢ c + b ‚Ä¢ d","name":"smul_add_smul_lt_smul_add_smul","isProp":true,"docString":"Binary strict **rearrangement inequality**. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"CanonicallyLinearOrderedSemifield.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±]\n  (a : ‚àÄ (u : (a : ‚Ñï) ‚Üí Œ±) (a : CauchySeq u), ‚àÉ (a : Œ±), Filter.Tendsto u Filter.atTop (nhds a)), CompleteSpace Œ±","name":"EMetric.complete_of_cauchySeq_tendsto","isProp":true,"docString":"A sequentially complete pseudoemetric space is complete. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : AddCommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddHom f),\n  IsAddHom fun (a : Œ±) ‚Ü¶ -f a","name":"IsAddHom.neg","isProp":true,"docString":"The negation of a map which preserves addition, preserves addition when\nthe target is commutative."},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï}, padicValRat p ‚Üën = ‚Üë(padicValNat p n)","name":"padicValRat.of_nat","isProp":true,"docString":"The `p`-adic value of an integer `z ‚â† 0` is its `p`-adic value as a rational. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {R : C} {X : C} {Y : C} {Z : C} {a : R ‚ü∂ X} {b : R ‚ü∂ X} {f‚ÇÅ : X ‚ü∂ Y}\n  {f‚ÇÇ : Y ‚ü∂ Z} [inst_1 : CategoryTheory.Mono f‚ÇÇ] (small_k : CategoryTheory.IsKernelPair f‚ÇÅ a b),\n  CategoryTheory.IsKernelPair (f‚ÇÅ ‚â´ f‚ÇÇ) a b","name":"CategoryTheory.IsKernelPair.comp_of_mono","isProp":true,"docString":"If `(a,b)` is a kernel pair for `f‚ÇÅ` and `f‚ÇÇ` is mono, then `(a,b)` is a kernel pair for `f‚ÇÅ ‚â´ f‚ÇÇ`.\nThe converse of `cancel_right_of_mono`.\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Monovary f g),\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i)) ‚â§ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i","name":"Monovary.sum_mul_comp_perm_le_sum_mul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and\n`g` monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.SmallCategory C] {‚Ñ∞ : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category ‚Ñ∞] (A : C ‚•§ ‚Ñ∞)\n  (P : C·µí·µñ ‚•§ Type u‚ÇÅ) (E‚ÇÅ : ‚Ñ∞) (E‚ÇÇ : ‚Ñ∞) (g : E‚ÇÅ ‚ü∂ E‚ÇÇ)\n  {c : CategoryTheory.Limits.Cocone (CategoryTheory.Functor.leftOp (CategoryTheory.CategoryOfElements.œÄ P) ‚ãô A)}\n  (t : CategoryTheory.Limits.IsColimit c) (k : CategoryTheory.Limits.Cocone.pt c ‚ü∂ E‚ÇÅ),\n  ‚Üë(CategoryTheory.ColimitAdj.restrictYonedaHomEquiv A P E‚ÇÇ t) (k ‚â´ g) =\n    ‚Üë(CategoryTheory.ColimitAdj.restrictYonedaHomEquiv A P E‚ÇÅ t) k ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ColimitAdj.restrictedYoneda A)) g","name":"CategoryTheory.ColimitAdj.restrictYonedaHomEquiv_natural","isProp":true,"docString":"(Implementation). Show that the bijection in `restrictYonedaHomEquiv` is natural (on the right).\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} (h : IsCompact s), Metric.Bounded s","name":"IsCompact.bounded","isProp":true,"docString":"A compact set is bounded "},{"type":"‚àÄ {o : Ordinal},\n  (Ordinal.Principal (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x * x_1) o : Prop) ‚Üî\n    ((o ‚â§ 2 : Prop) ‚à® (‚àÉ (a : Ordinal), o = Ordinal.omega ^ Ordinal.omega ^ a : Prop) : Prop)","name":"Ordinal.principal_mul_iff_le_two_or_omega_opow_opow","isProp":true,"docString":"The main characterization theorem for multiplicative principal ordinals. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonUnitalNonAssocRing Œ±]\n  [inst_1 : OrderedSemiring Œ≤] [self : RingNormClass F Œ± Œ≤] (f : F) {a : Œ±} (a_1 : ‚Üëf a = 0), a = 0","name":"RingNormClass.eq_zero_of_map_eq_zero","isProp":true,"docString":"The argument is zero if its image under the map is zero. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±} {k : ‚Ñï},\n  (s ‚àà (Finset.shadow^[k]) ùíú : Prop) ‚Üî\n    (‚àÉ (t : Finset Œ±), (t ‚àà ùíú : Prop) ‚àß ((s ‚äÜ t : Prop) ‚àß (Finset.card t = Finset.card s + k : Prop) : Prop) : Prop)","name":"Finset.mem_shadow_iff_exists_mem_card_add","isProp":true,"docString":"`t ‚àà ‚àÇ^k ùíú` iff `t` is exactly `k` elements less than something in `ùíú`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {d : AddCon M},\n  (‚àÄ (x : M) (y : M), (‚Üëc x y : Prop) ‚Üî (‚Üëd x y : Prop) : Prop) ‚Üî (c = d : Prop)","name":"AddCon.ext_iff","isProp":true,"docString":"Iff version of extensionality rule for additive congruence relations."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsPreconnected J] (p : Set J) {j‚ÇÄ : J}\n  (h0 : j‚ÇÄ ‚àà p) (h1 : ‚àÄ {j‚ÇÅ : J} {j‚ÇÇ : J} (x : j‚ÇÅ ‚ü∂ j‚ÇÇ), (j‚ÇÅ ‚àà p : Prop) ‚Üî (j‚ÇÇ ‚àà p : Prop)) (j : J), j ‚àà p","name":"CategoryTheory.induct_on_objects","isProp":true,"docString":"An inductive-like property for the objects of a connected category.\nIf the set `p` is nonempty, and `p` is closed under morphisms of `J`,\nthen `p` contains all of `J`.\n\nThe converse is given in `IsConnected.of_induct`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {Œ¥ : Type u_1} [inst_4 : LinearOrder Œ¥] [inst_5 : TopologicalSpace Œ¥]\n  [inst_6 : OrderClosedTopology Œ¥] {a : Œ±} {b : Œ±} (hab : a ‚â§ b) {f : (a : Œ±) ‚Üí Œ¥} (hf : ContinuousOn f (Set.Icc a b)),\n  Set.Icc (f a) (f b) ‚äÜ f '' Set.Icc a b","name":"intermediate_value_Icc","isProp":true,"docString":"**Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a ‚â§ t ‚â§ f b`."},{"type":"‚àÄ {R : Type u} [inst : CommRing R] (H : ‚àÄ (P : Ideal R) (a : Ideal.IsPrime P), Submodule.IsPrincipal P),\n  IsPrincipalIdealRing R","name":"IsPrincipalIdealRing.of_prime","isProp":true,"docString":"If all prime ideals in a commutative ring are principal, so are all other ideals. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±], IsTrans Œ± Dvd.dvd","name":"instIsTransDvdSemigroupDvd","isProp":true,"docString":"Transitivity of `|` for use in `calc` blocks. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p1 : P) (p2 : P) (g : G),\n  p1 -·µ• (g +·µ• p2) = p1 -·µ• p2 - g","name":"vsub_vadd_eq_vsub_sub","isProp":true,"docString":"Subtracting the result of adding a group element produces the same result\nas subtracting the points and subtracting that group element. "},{"type":"‚àÄ (ùïú : Type u_5) (Œ± : Type u_1) (E : Type u_3) (H : Type u_2) {hom : Type u_4} [inst : NormedField ùïú]\n  [inst_1 : AddCommGroup H] [inst_2 : Module ùïú H] [inst_3 : AddCommGroup E] [inst_4 : Module ùïú E]\n  [inst_5 : TopologicalSpace H] [inst_6 : UniformSpace E] [inst_7 : UniformAddGroup E] [inst_8 : ContinuousSMul ùïú E]\n  {ùîñ : Set (Set Œ±)} [inst_9 : LinearMapClass hom ùïú H (UniformOnFun Œ± E ùîñ)] (hùîñ‚ÇÅ : Set.Nonempty ùîñ)\n  (hùîñ‚ÇÇ : DirectedOn (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äÜ x_1) ùîñ) (œÜ : hom) (hœÜ : Inducing ‚ÜëœÜ)\n  (h : ‚àÄ (u : H) (s : Set Œ±) (a : s ‚àà ùîñ), Bornology.IsVonNBounded ùïú (‚ÜëœÜ u '' s)), ContinuousSMul ùïú H","name":"UniformOnFun.continuousSMul_induced_of_image_bounded","isProp":true,"docString":"Let `E` be a TVS, `ùîñ : Set (Set Œ±)` and `H` a submodule of `Œ± ‚Üí·µ§[ùîñ] E`. If the image of any\n`S ‚àà ùîñ` by any `u ‚àà H` is bounded (in the sense of `Bornology.IsVonNBounded`), then `H`,\nequipped with the topology of `ùîñ`-convergence, is a TVS.\n\nFor convenience, we don't literally ask for `H : Submodule (Œ± ‚Üí·µ§[ùîñ] E)`. Instead, we prove the\nresult for any vector space `H` equipped with a linear inducing to `Œ± ‚Üí·µ§[ùîñ] E`, which is often\neasier to use. We also state the `Submodule` version as\n`UniformOnFun.continuousSMul_submodule_of_image_bounded`. "},{"type":"‚àÄ {R : Type x} [inst : CommRing R] (a : R) (b : R), a * a - b * b = (a + b) * (a - b)","name":"mul_self_sub_mul_self","isProp":true,"docString":"Representation of a difference of two squares in a commutative ring as a product. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {x : M} {y : M} {z : M} (a : y ‚àà multiples x) (a : z ‚àà multiples x),\n  y + z ‚àà multiples x","name":"multiples.add_mem","isProp":true,"docString":"The set of natural number multiples of an element of an `AddMonoid` is closed under\naddition."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] {x : Œ±} {y : Œ±} {s : Set Œ±} {t : Set Œ±}\n  (hu : t ‚äÜ insert y s), insert x s ‚àà nhdsWithin x t","name":"insert_mem_nhdsWithin_of_subset_insert","isProp":true,"docString":"If `t` is a subset of `s`, except for one point,\nthen `insert x s` is a neighborhood of `x` within `t`. "},{"type":"‚àÄ {C : Type v} {D : Type v'} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C]\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.ConcreteCategory D]\n  [self : CategoryTheory.HasForget‚ÇÇ C D],\n  CategoryTheory.HasForget‚ÇÇ.forget‚ÇÇ ‚ãô CategoryTheory.forget D = CategoryTheory.forget C","name":"CategoryTheory.HasForget‚ÇÇ.forget_comp","isProp":true,"docString":"It covers the `ConcreteCategory.Forget` for `C` and `D` "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} (h : UniformEquicontinuous F), Equicontinuous F","name":"UniformEquicontinuous.equicontinuous","isProp":true,"docString":"Uniform equicontinuity implies equicontinuity. "},{"type":"CategoryTheory.Limits.HasLimits CategoryTheory.Cat","name":"CategoryTheory.Cat.instHasLimitsCatCategory","isProp":true,"docString":"The category of small categories has all small limits. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_3} [inst_1 : AddCommMonoid N] {P : Type u_2}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {k : AddSubmonoid.LocalizationMap S P} (z : N),\n  ‚Üë(AddSubmonoid.LocalizationMap.lift k\n          ((AddSubmonoid.LocalizationMap.map_addUnits\n                f=:‚àÄ (y : { x : M // x ‚àà S }),\n                IsAddUnit\n                  (‚Üë(AddSubmonoid.LocalizationMap.toMap f)\n                    ‚Üëy))=:‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üë(AddSubmonoid.LocalizationMap.toMap f) ‚Üëy)))\n      (‚Üë(AddSubmonoid.LocalizationMap.lift f\n            ((AddSubmonoid.LocalizationMap.map_addUnits\n                  k=:‚àÄ (y : { x : M // x ‚àà S }),\n                  IsAddUnit\n                    (‚Üë(AddSubmonoid.LocalizationMap.toMap k)\n                      ‚Üëy))=:‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üë(AddSubmonoid.LocalizationMap.toMap k) ‚Üëy)))\n        z) =\n    z","name":"AddSubmonoid.LocalizationMap.lift_left_inverse","isProp":true,"docString":"Given two Localization maps `f : M ‚Üí+ N, k : M ‚Üí+ P` for a Submonoid `S ‚äÜ M`, the hom\nfrom `P` to `N` induced by `f` is left inverse to the hom from `N` to `P` induced by `k`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} (f : P ‚ü∂ Q) [inst_1 : CategoryTheory.Epi f]\n  [inst_2 : CategoryTheory.StrongMono f], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_epi_of_strongMono","isProp":true,"docString":"A strong monomorphism that is an epimorphism is an isomorphism. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] {œÜ : MvPolynomial œÉ R}\n  {œà : MvPolynomial œÉ R} {m : M} {n : M} {w : (a : œÉ) ‚Üí M} (hœÜ : MvPolynomial.IsWeightedHomogeneous w œÜ m)\n  (hœà : MvPolynomial.IsWeightedHomogeneous w œà n), MvPolynomial.IsWeightedHomogeneous w (œÜ * œà) (m + n)","name":"MvPolynomial.IsWeightedHomogeneous.mul","isProp":true,"docString":"The product of weighted homogeneous polynomials of weighted degrees `m` and `n` is weighted\nhomogeneous of weighted degree `m + n`. "},{"type":"‚àÄ {Œ± : Type u} (s : Set Œ±), (Set.Finite s : Prop) ‚à® (Set.Infinite s : Prop)","name":"Set.finite_or_infinite","isProp":true,"docString":"See also `finite_or_infinite`, `fintype_or_infinite`. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] [inst_4 : DecidableEq P] [inst_5 : DecidableEq V] {s : Finset P} {p : P} (hp : p ‚àà s),\n  vectorSpan k ‚Üës = Submodule.span k ‚Üë(Finset.image (fun (x : P) ‚Ü¶ x -·µ• p) (Finset.erase s p))","name":"vectorSpan_eq_span_vsub_finset_right_ne","isProp":true,"docString":"The `vectorSpan` is the span of the pairwise subtractions with a given point on the right,\nexcluding the subtraction of that point from itself. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b), ¬¨(b < a : Prop)","name":"LE.le.not_lt","isProp":true,"docString":"**Alias** of `not_lt_of_le`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Nonempty Œ±] [inst : SemilatticeInf Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f), (Filter.Tendsto f Filter.atBot Filter.atBot : Prop) ‚Üî (‚àÄ (b : Œ≤), ‚àÉ (a : Œ±), f a ‚â§ b : Prop)","name":"Monotone.tendsto_atBot_atBot_iff","isProp":true,"docString":"**Alias** of `Filter.tendsto_atBot_atBot_iff_of_monotone`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_1} {ùîñ : Set (Set Œ±)} {u‚ÇÅ : UniformSpace Œ≥} {u‚ÇÇ : UniformSpace Œ≥},\n  UniformOnFun.uniformSpace Œ± Œ≥ ùîñ = UniformOnFun.uniformSpace Œ± Œ≥ ùîñ ‚äì UniformOnFun.uniformSpace Œ± Œ≥ ùîñ","name":"UniformOnFun.inf_eq","isProp":true,"docString":"If `u‚ÇÅ` and `u‚ÇÇ` are two uniform structures on `Œ≥`, then\n`ùí±(Œ±, Œ≥, ùîñ, u‚ÇÅ ‚äì u‚ÇÇ) = ùí±(Œ±, Œ≥, ùîñ, u‚ÇÅ) ‚äì ùí±(Œ±, Œ≥, ùîñ, u‚ÇÇ)`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : PredOrder Œ±] (a : Œ±), PredOrder.pred a ‚â§ a","name":"PredOrder.pred_le","isProp":true,"docString":"Proof of basic ordering with respect to `pred`"},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : b ‚â§ c) (a_2 : a < b), a < c","name":"LE.le.trans_lt'","isProp":true,"docString":"**Alias** of `lt_of_le_of_lt'`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C·µí·µñ ‚•§ D}\n  [inst_2 : CategoryTheory.Faithful F], CategoryTheory.Faithful (CategoryTheory.Functor.rightOp F)","name":"CategoryTheory.Functor.rightOp_faithful","isProp":true,"docString":"If F is faithful then the right_op of F is also faithful. "},{"type":"‚àÄ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M], IsSMulRegular M 1","name":"IsSMulRegular.one","isProp":true,"docString":"One is always `M`-regular. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f),\n  Filter.Tendsto f Filter.cofinite Filter.cofinite","name":"Function.Injective.tendsto_cofinite","isProp":true,"docString":"For an injective function `f`, inverse images of finite sets are finite. See also\n`Filter.comap_cofinite_le` and `Function.Injective.comap_cofinite_eq`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≥ : Type w} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±] [inst_2 : EMetricSpace Œ≥]\n  {f : (a : Œ±) ‚Üí Œ≥} (hf : Isometry f), ClosedEmbedding f","name":"Isometry.closedEmbedding","isProp":true,"docString":"An isometry from a complete emetric space is a closed embedding "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (self : Finpartition a),\n  ¬¨(‚ä• ‚àà Finpartition.parts self : Prop)","name":"Finpartition.not_bot_mem","isProp":true,"docString":"No element of the partition is bottom"},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {d : AddCon M} (H : Setoid.r = Setoid.r), c = d","name":"AddCon.ext'","isProp":true,"docString":"The map sending an additive congruence relation to its underlying binary relation\nis injective."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : UniqueFactorizationMonoid Œ±] {P : (a : Œ±) ‚Üí Prop} (a : Œ±)\n  (h0 : P 0) (h1 : ‚àÄ {x : Œ±} (a : IsUnit x), P x) (hpr : ‚àÄ {p : Œ±} (i : ‚Ñï) (a : Prime p), P (p ^ i))\n  (hcp : ‚àÄ {x : Œ±} {y : Œ±} (a : ‚àÄ (p : Œ±) (a : p ‚à£ x) (a : p ‚à£ y), IsUnit p) (a : P x) (a : P y), P (x * y)), P a","name":"UniqueFactorizationMonoid.induction_on_coprime","isProp":true,"docString":"If `P` holds for `0`, units and powers of primes,\nand `P x ‚àß P y` for coprime `x, y` implies `P (x * y)`,\nthen `P` holds on all `a : Œ±`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedGroup E] {s : Subgroup E} (x : { x : E // x ‚àà s }), ‚Äñ‚Üëx‚Äñ = ‚Äñx‚Äñ","name":"Subgroup.norm_coe","isProp":true,"docString":"If `x` is an element of a subgroup `s` of a seminormed group `E`, its norm in `s` is equal to\nits norm in `E`.\n\nThis is a reversed version of the `simp` lemma `Subgroup.coe_norm` for use by `norm_cast`. "},{"type":"‚àÄ {A : Type u_1} [inst : Mul A] [inst_1 : LinearOrder A]\n  [inst_2 : CovariantClass A A (fun (x : A) (x_1 : A) ‚Ü¶ x * x_1) fun (x : A) (x_1 : A) ‚Ü¶ x ‚â§ x_1]\n  [inst_3 : CovariantClass A A (Function.swap fun (x : A) (x_1 : A) ‚Ü¶ x * x_1) fun (x : A) (x_1 : A) ‚Ü¶ x < x_1]\n  [inst_4 : ContravariantClass A A (fun (x : A) (x_1 : A) ‚Ü¶ x * x_1) fun (x : A) (x_1 : A) ‚Ü¶ x ‚â§ x_1], UniqueProds A","name":"Covariants.to_uniqueProds","isProp":true,"docString":"This instance asserts that if `A` has a multiplication, a linear order, and multiplication\nis 'very monotone', then `A` also has `UniqueProds`. "},{"type":"‚àÄ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {W : CategoryTheory.MorphismProperty C} {E : Type u_5} [inst_2 : CategoryTheory.Category E]\n  (self : CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L W E) (F : C ‚•§ E)\n  (hF : CategoryTheory.MorphismProperty.IsInvertedBy W F),\n  L ‚ãô CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.lift self F hF = F","name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.fac","isProp":true,"docString":"there is a factorisation involving the lifted functor  "},{"type":"‚àÄ (n : ‚Ñï),\n  Nat.totient n =\n    (n / Finset.prod (List.toFinset (Nat.factors n)) fun (p : ‚Ñï) ‚Ü¶ p) *\n      Finset.prod (List.toFinset (Nat.factors n)) fun (p : ‚Ñï) ‚Ü¶ p - 1","name":"Nat.totient_eq_div_factors_mul","isProp":true,"docString":"Euler's product formula for the totient function. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {F : Type u_3} [inst : AddZeroClass M] [inst_1 : AddZeroClass N]\n  [inst_2 : AddMonoidHomClass F M N] (f : F) {x : M} (hx : ‚àÉ (y : M), y + x = 0), ‚àÉ (y : N), y + ‚Üëf x = 0","name":"AddMonoidHom.map_exists_left_neg","isProp":true,"docString":"Given an AddMonoid homomorphism `f : M ‚Üí+ N` and an element `x : M`, if `x` has\na left inverse, then `f x` has a left inverse too. For elements invertible on both sides see\n`IsAddUnit.map`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] (C : ‚Ñù) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu‚ÇÇ : ‚àÄ (n : ‚Ñï), dist (f n) (f (n + 1)) ‚â§ C / 2 / 2 ^ n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a))\n  (n : ‚Ñï), dist (f n) a ‚â§ C / 2 ^ n","name":"dist_le_of_le_geometric_two_of_tendsto","isProp":true,"docString":"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\n`f n` to the limit of `f` is bounded above by `C / 2^n`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : CompactExhaustion X),\n  (Set.union·µ¢ fun (n : ‚Ñï) ‚Ü¶ CompactExhaustion.toFun self n) = Set.univ","name":"CompactExhaustion.union·µ¢_eq'","isProp":true,"docString":"The union of all sets in a compact exhaustion equals the entire space. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N]\n  (f : Submonoid.LocalizationMap S N),\n  Submonoid.LocalizationMap.ofMulEquivOfDom f\n      (let_fun this : Submonoid.map (MulEquiv.toMonoidHom (MulEquiv.refl M)) S = S :=\n          ((Submonoid.ext\n                (fun (x : M) ‚Ü¶\n                  (_ :\n                    (x ‚àà Submonoid.map (MulEquiv.toMonoidHom (MulEquiv.refl M)) S : Prop) ‚Üî\n                      (x ‚àà S :\n                        Prop))=:‚àÄ (x : M),\n                    (x ‚àà Submonoid.map (MulEquiv.toMonoidHom (MulEquiv.refl M)) S : Prop) ‚Üî\n                      (x ‚àà S :\n                        Prop))=:Submonoid.map (MulEquiv.toMonoidHom (MulEquiv.refl M)) S =\n                S)=:Submonoid.map (MulEquiv.toMonoidHom (MulEquiv.refl M)) S = S);\n        this=:Submonoid.map (MulEquiv.toMonoidHom (MulEquiv.refl M)) S = S) =\n    f","name":"Submonoid.LocalizationMap.ofMulEquivOfDom_id","isProp":true,"docString":"A special case of `f ‚àò id = f`, `f` a Localization map. "},{"type":"‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {s : Set A}\n  {p : (a : { x : A // x ‚àà Algebra.adjoin R s }) ‚Üí Prop}\n  (Hs :\n    ‚àÄ (x : A) (h : x ‚àà s),\n      p { val := x, property := ((Algebra.subset_adjoin h=:x ‚àà ‚Üë(Algebra.adjoin R s))=:x ‚àà ‚Üë(Algebra.adjoin R s)) })\n  (Halg : ‚àÄ (r : R), p (‚Üë(algebraMap R { x : A // x ‚àà Algebra.adjoin R s }) r))\n  (Hadd :\n    ‚àÄ (x : { x : A // x ‚àà Algebra.adjoin R s }) (y : { x : A // x ‚àà Algebra.adjoin R s }) (a : p x) (a : p y),\n      p (x + y))\n  (Hmul :\n    ‚àÄ (x : { x : A // x ‚àà Algebra.adjoin R s }) (y : { x : A // x ‚àà Algebra.adjoin R s }) (a : p x) (a : p y),\n      p (x * y))\n  (x : { x : A // x ‚àà Algebra.adjoin R s }), p x","name":"Algebra.adjoin_induction'","isProp":true,"docString":"The difference with `Algebra.adjoin_induction` is that this acts on the subtype. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±] (x : Œ±),\n  connectedComponent x = Set.inter·µ¢ fun (Z : { Z : Set Œ± // (IsClopen Z : Prop) ‚àß (x ‚àà Z : Prop) }) ‚Ü¶ ‚ÜëZ","name":"connectedComponent_eq_inter·µ¢_clopen","isProp":true,"docString":"In a compact t2 space, the connected component of a point equals the intersection of all\nits clopen neighbourhoods. "},{"type":"‚àÄ {Œ± : Type u_1} (P : (a : Œ±) ‚Üí Prop) (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsSymm Œ± r]\n  (h :\n    ‚àÄ (s : Finset Œ±) (a : ‚àÄ (x : Œ±) (a : x ‚àà s), P x), ‚àÉ (y : Œ±), (P y : Prop) ‚àß (‚àÄ (x : Œ±) (a : x ‚àà s), r x y : Prop)),\n  ‚àÉ (f : (a : ‚Ñï) ‚Üí Œ±), (‚àÄ (n : ‚Ñï), P (f n) : Prop) ‚àß (‚àÄ (m : ‚Ñï) (n : ‚Ñï) (a : m ‚â† n), r (f m) (f n) : Prop)","name":"exists_seq_of_forall_finset_exists'","isProp":true,"docString":"Induction principle to build a sequence, by adding one point at a time satisfying a given\nsymmetric relation with respect to all the previously chosen points.\n\nMore precisely, Assume that, for any finite set `s`, one can find another point satisfying\nsome relation `r` with respect to all the points in `s`. Then one may construct a\nfunction `f : ‚Ñï ‚Üí Œ±` such that `r (f m) (f n)` holds whenever `m ‚â† n`.\nWe also ensure that all constructed points satisfy a given predicate `P`. "},{"type":"‚àÄ {R : Type u_1} [self : AddCommMonoidWithOne R] (a : R) (b : R), a + b = b + a","name":"AddCommMonoidWithOne.add_comm","isProp":true,"docString":"Addition is commutative in an additive commutative semigroup. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], ‚Üë‚ä• = ‚àÖ","name":"AffineSubspace.bot_coe","isProp":true,"docString":"`‚ä•`, coerced to a set, is the empty set. "},{"type":"‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±], 0 ‚â§ 1","name":"StrictOrderedSemiring.zero_le_one","isProp":true,"docString":"In a strict ordered semiring, `0 ‚â§ 1`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] [inst_2 : TopologicalSpace Œ±]\n  [h : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : StrictMono f)\n  (hc : Set.OrdConnected (Set.range f)), Embedding f","name":"StrictMono.embedding_of_ordConnected","isProp":true,"docString":"A strictly monotone function between linear orders with order topology is a topological\nembedding provided that the range of `f` is  order-connected. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} (a : Finset.Nonempty s), Nonempty { x : Œ± // x ‚àà s }","name":"Finset.Nonempty.coe_sort","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.nonempty_coe_sort`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (x : Œ±),\n  (x ‚àà LocallyFiniteOrder.finsetIoc a b : Prop) ‚Üî ((a < x : Prop) ‚àß (x ‚â§ b : Prop) : Prop)","name":"LocallyFiniteOrder.finset_mem_Ioc","isProp":true,"docString":"`x ‚àà finsetIoc a b ‚Üî a < x ‚àß x ‚â§ b` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±} (a : BddAbove ‚Üë(lowerClosure s)), BddAbove s","name":"BddAbove.of_lowerClosure","isProp":true,"docString":"**Alias** of the forward direction of `bddAbove_lowerClosure`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} {f : P ‚ü∂ Q} [self : CategoryTheory.StrongEpi f]\n  ‚¶ÉX : C‚¶Ñ ‚¶ÉY : C‚¶Ñ (z : X ‚ü∂ Y) [inst_1 : CategoryTheory.Mono z], CategoryTheory.HasLiftingProperty f z","name":"CategoryTheory.StrongEpi.llp","isProp":true,"docString":"The left lifting property with respect to all monomorphism "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (hs : Set.Countable s),\n  Set.Countable (setOf fun (t : Set Œ±) ‚Ü¶ (Set.Finite t : Prop) ‚àß (t ‚äÜ s : Prop))","name":"Set.countable_setOf_finite_subset","isProp":true,"docString":"The set of finite subsets of a countable set is countable. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : P} (hp : p ‚àà s),\n  vectorSpan k s = Submodule.span k ((fun (x : P) ‚Ü¶ x -·µ• p) '' s)","name":"vectorSpan_eq_span_vsub_set_right","isProp":true,"docString":"The `vectorSpan` is the span of the pairwise subtractions with a given point on the right. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasKernel f]\n  [inst_4 : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.Œπ f)] [inst_5 : CategoryTheory.Mono f],\n  CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.œÄ (CategoryTheory.Limits.kernel.Œπ f))","name":"CategoryTheory.Limits.cokernel.of_kernel_of_mono","isProp":true,"docString":"The cokernel of the kernel of a monomorphism is an isomorphism "},{"type":"‚àÄ {f : (a : Type u‚ÇÄ) ‚Üí Type u‚ÇÅ} [self : EquivFunctor f] {Œ± : Type u‚ÇÄ} {Œ≤ : Type u‚ÇÄ} {Œ≥ : Type u‚ÇÄ} (k : Œ± ‚âÉ Œ≤)\n  (h : Œ≤ ‚âÉ Œ≥), EquivFunctor.map (Equiv.trans k h) = EquivFunctor.map h ‚àò EquivFunctor.map k","name":"EquivFunctor.map_trans'","isProp":true,"docString":"`map` is functorial on equivalences. "},{"type":"‚àÄ {n : ‚Ñï} {p : ‚Ñï} {b : ‚Ñï} (hb : n ‚â§ p ^ b), ‚Üë(Nat.factorization n) p ‚â§ b","name":"Nat.factorization_le_of_le_pow","isProp":true,"docString":"An upper bound on `n.factorization p` "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {t : CategoryTheory.Limits.Cocone F} (self : CategoryTheory.Limits.IsColimit t) (s : CategoryTheory.Limits.Cocone F)\n  (j : J),\n  (CategoryTheory.Limits.Cocone.Œπ t).app j ‚â´ CategoryTheory.Limits.IsColimit.desc self s =\n    (CategoryTheory.Limits.Cocone.Œπ s).app j","name":"CategoryTheory.Limits.IsColimit.fac","isProp":true,"docString":"The map `desc` makes the diagram with the natural transformations commute "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} (h_mono : Monotone f) (h_dense : DenseRange f), Continuous f","name":"Monotone.continuous_of_denseRange","isProp":true,"docString":"A monotone function with densely ordered codomain and a dense range is continuous. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : r < 0),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atTop : Prop) ‚Üî (Filter.Tendsto f l Filter.atBot : Prop)","name":"Filter.tendsto_const_mul_atTop_of_neg","isProp":true,"docString":"If `r` is a negative constant, then `Œª x, r * f x` tends to infinity along a filter if and only\nif `f` tends to negative infinity along the same filter. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_4} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N' : Type u_2}\n  [inst_3 : AddCommGroup N'] [inst_4 : Module R N'] {Œπ : Type u_5} {N'‚ÇÇ : Type u_3} [inst_5 : AddCommGroup N'‚ÇÇ]\n  [inst_6 : Module R N'‚ÇÇ] [inst_7 : DecidableEq Œπ] [inst_8 : Fintype Œπ] (g : N' ‚Üí‚Çó[R] N'‚ÇÇ)\n  (f : MultilinearMap R (fun (x : Œπ) ‚Ü¶ M) N'),\n  ‚ÜëMultilinearMap.alternatization (LinearMap.compMultilinearMap g f) =\n    ‚Üë(LinearMap.compAlternatingMap g) (‚ÜëMultilinearMap.alternatization f)","name":"LinearMap.compMultilinearMap_alternatization","isProp":true,"docString":"Composition with a linear map before and after alternatization are equivalent. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (self : AbsoluteValue R S) (x : R)\n  (y : R),\n  MulHom.toFun (AbsoluteValue.toMulHom self) (x + y) ‚â§\n    MulHom.toFun (AbsoluteValue.toMulHom self) x + MulHom.toFun (AbsoluteValue.toMulHom self) y","name":"AbsoluteValue.add_le'","isProp":true,"docString":"The absolute value satisfies the triangle inequality "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] {I : Ideal R} {J : Ideal R} (hIJ : I ‚â§ J) {x : R},\n  (‚Üë(Ideal.Quotient.mk I) x ‚àà Ideal.map (Ideal.Quotient.mk I) J : Prop) ‚Üî (x ‚àà J : Prop)","name":"Ideal.mem_quotient_iff_mem","isProp":true,"docString":"See also `Ideal.mem_quotient_iff_mem_sup` if the assumption `I ‚â§ J` is not available. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {s : Set Œ±} (a : Equiv.Perm.IsCycleOn f s), Equiv.Perm.IsCycleOn f‚Åª¬π s","name":"Equiv.Perm.IsCycleOn.inv","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.isCycleOn_inv`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} (hs : Set.Nontrivial s) {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f),\n  Set.Nontrivial (f '' s)","name":"Set.Nontrivial.image","isProp":true,"docString":"The image of a nontrivial set under an injective map is nontrivial. "},{"type":"‚àÄ {R : Type u_1} {A : Type u} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\n  (Algebra.FiniteType R A : Prop) ‚Üî\n    (‚àÉ (s : Finset A), ‚àÉ (f : MvPolynomial { x : A // x ‚àà s } R ‚Üí‚Çê[R] A), Function.Surjective ‚Üëf : Prop)","name":"Algebra.FiniteType.iff_quotient_mvPolynomial","isProp":true,"docString":"An algebra is finitely generated if and only if it is a quotient\nof a polynomial ring whose variables are indexed by a finset. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ),\n  FiniteDimensional.finrank K { x : V‚ÇÇ // x ‚àà LinearMap.range f } +\n      FiniteDimensional.finrank K { x : V // x ‚àà LinearMap.ker f } =\n    FiniteDimensional.finrank K V","name":"LinearMap.finrank_range_add_finrank_ker","isProp":true,"docString":"rank-nullity theorem : the dimensions of the kernel and the range of a linear map add up to\nthe dimension of the source space. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : Filter Œ±} {a : Œ±} {s : Set Œ±} (h : a ‚àà s) (o : IsOpen s)\n  (sf : Filter.principal s ‚â§ f), nhds a ‚â§ f","name":"nhds_le_of_le","isProp":true,"docString":"To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\nthe principal filter of some open set `s` containing `a`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {r : ‚Ñù}, Metric.Bounded (Metric.closedBall x r)","name":"Metric.bounded_closedBall","isProp":true,"docString":"Closed balls are bounded "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {ùìü : Ideal R} {f : Polynomial R}\n  (hf : Polynomial.IsEisensteinAt f ùìü) (hprime : Ideal.IsPrime ùìü) (hu : Polynomial.IsPrimitive f)\n  (hfd0 : 0 < Polynomial.natDegree f), Irreducible f","name":"Polynomial.IsEisensteinAt.irreducible","isProp":true,"docString":"If a primitive `f` satisfies `f.IsEisensteinAt ùìü`, where `ùìü.IsPrime`,\nthen `f` is irreducible. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (self : ClosureOperator Œ±) (x : Œ±),\n  ‚Üë(ClosureOperator.toOrderHom self) (‚Üë(ClosureOperator.toOrderHom self) x) = ‚Üë(ClosureOperator.toOrderHom self) x","name":"ClosureOperator.idempotent'","isProp":true,"docString":"Closures are idempotent "},{"type":"‚àÄ {v : (a : ‚Ñï) ‚Üí ‚Ñù} {c : ‚Ñù} (h‚ÇÄ : 0 < v 0) (hc : 1 < c) (hu : ‚àÄ (n : ‚Ñï), c * v n ‚â§ v (n + 1)),\n  Filter.Tendsto v Filter.atTop Filter.atTop","name":"tendsto_atTop_of_geom_le","isProp":true,"docString":"If a sequence `v` of real numbers satisfies `k * v n ‚â§ v (n+1)` with `1 < k`,\nthen it goes to +‚àû. "},{"type":"‚àÄ {R : Type u_1} [inst : Add R] [inst_1 : Mul R] (self : RingCon R) {w : R} {x : R} {y : R} {z : R} (a : Setoid.r w x)\n  (a : Setoid.r y z), Setoid.r (w + y) (x + z)","name":"RingCon.add'","isProp":true,"docString":"Ring congruence relations are closed under addition "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} [inst_4 : Subsingleton Œπ] (p : (a : Œπ) ‚Üí P), AffineIndependent k p","name":"affineIndependent_of_subsingleton","isProp":true,"docString":"A family with at most one point is affinely independent. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {t : Finset Œ±} (h : s ‚äÜ t),\n  Finset.card (Finset.Ioc s t) = 2 ^ (Finset.card t - Finset.card s) - 1","name":"Finset.card_Ioc_finset","isProp":true,"docString":"Cardinality of an `Ioc` of finsets. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =o[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ), f =o[l] g'","name":"Asymptotics.IsLittleO.of_norm_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_norm_right`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {p : Filter Œπ} (h : TendstoUniformlyOn F f p s) {x : Œ±} (hx : x ‚àà s),\n  Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n x) p (nhds (f x))","name":"TendstoUniformlyOn.tendsto_at","isProp":true,"docString":"Uniform converence implies pointwise convergence. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : NonAssocSemiring Œ≤] (self : Œ± ‚Üí+* Œ≤) (x : Œ±)\n  (y : Œ±), OneHom.toFun (‚Üë‚Üëself) (x + y) = OneHom.toFun (‚Üë‚Üëself) x + OneHom.toFun (‚Üë‚Üëself) y","name":"RingHom.map_add'","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Nontrivial R]\n  {Œπ : Type w} (b : Basis Œπ R M) {Œ∫ : Type w'} (v : (a : Œ∫) ‚Üí M) (i : LinearIndependent R v)\n  (m : LinearIndependent.Maximal i), (Set.union·µ¢ fun (k : Œ∫) ‚Ü¶ ‚Üë(Finsupp.support (‚Üë(Basis.repr b) (v k)))) = Set.univ","name":"union_support_maximal_linearIndependent_eq_range_basis","isProp":true,"docString":"Over any ring `R`, if `b` is a basis for a module `M`,\nand `s` is a maximal linearly independent set,\nthen the union of the supports of `x ‚àà s` (when written out in the basis `b`) is all of `b`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] (s : Set Œ±),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ 1) = 1","name":"finprod_mem_one","isProp":true,"docString":"The product of the constant function `1` over any set equals `1`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : PartialOrder Œ±] [inst_3 : ZeroLEOneClass Œ±]\n  [inst_4 : NeZero 1], 0 < 1","name":"zero_lt_one","isProp":true,"docString":"See `zero_lt_one'` for a version with the type explicit. "},{"type":"‚àÄ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)]\n  (hs : IsSeqCompact s), IsCompact s","name":"IsSeqCompact.isCompact","isProp":true,"docString":"If `ùì§ Œ≤` is countably generated, then any sequentially compact set is compact. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G),\n  (H = ‚ä• : Prop) ‚à® (‚àÉ (x : G), (x ‚àà H : Prop) ‚àß (x ‚â† 0 : Prop) : Prop)","name":"AddSubgroup.bot_or_exists_ne_zero","isProp":true,"docString":"A subgroup is either the trivial subgroup or contains a nonzero element."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] (oi : Œ± ‚âÉo Œ≤),\n  GaloisConnection ‚Üëoi ‚Üë(OrderIso.symm oi)","name":"OrderIso.to_galoisConnection","isProp":true,"docString":"Makes a Galois connection from an order-preserving bijection. "},{"type":"‚àÄ {G : Type u} [inst : Group G] (N : Subgroup G) [nN : Subgroup.Normal N] {H : Type v} [inst_1 : Group H]\n  ‚¶Éf : G ‚ß∏ N ‚Üí* H‚¶Ñ ‚¶Ég : G ‚ß∏ N ‚Üí* H‚¶Ñ\n  (h : MonoidHom.comp f (QuotientGroup.mk' N) = MonoidHom.comp g (QuotientGroup.mk' N)), f = g","name":"QuotientGroup.monoidHom_ext","isProp":true,"docString":"Two `MonoidHom`s from a quotient group are equal if their compositions with\n`QuotientGroup.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {a : R} {b : R} (h : b * a = 1), IsLeftRegular a","name":"isLeftRegular_of_mul_eq_one","isProp":true,"docString":"An element admitting a left inverse is left-regular. "},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] {P : Type u_1} [inst_2 : FirstOrder.Language.Structure L P]\n  {Q : Type u_2} [inst_3 : FirstOrder.Language.Structure L Q] (f : FirstOrder.Language.Embedding L M N)\n  (g : FirstOrder.Language.Embedding L N P) (h : FirstOrder.Language.Embedding L P Q),\n  FirstOrder.Language.Embedding.comp (FirstOrder.Language.Embedding.comp h g) f =\n    FirstOrder.Language.Embedding.comp h (FirstOrder.Language.Embedding.comp g f)","name":"FirstOrder.Language.Embedding.comp_assoc","isProp":true,"docString":"Composition of first-order embeddings is associative. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] [inst_1 : HasDistribNeg Œ±] {a : Œ±} {b : Œ±}, (a ‚à£ -b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"dvd_neg","isProp":true,"docString":"An element `a` of a semigroup with a distributive negation divides the negation of an element\n`b` iff `a` divides `b`. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] (t : Multiset (Polynomial R))\n  (h : Multiset.prod (Multiset.map Polynomial.leadingCoeff t) ‚â† 0),\n  Polynomial.leadingCoeff (Multiset.prod t) = Multiset.prod (Multiset.map Polynomial.leadingCoeff t)","name":"Polynomial.leadingCoeff_multiset_prod'","isProp":true,"docString":"The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients, provided that this product is nonzero.\n\nSee `Polynomial.leadingCoeff_multiset_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n"},{"type":"‚àÄ {G : Type u_1} [inst : Group G] ‚¶Éh : Set G‚¶Ñ ‚¶Ék : Set G‚¶Ñ (h' : h ‚äÜ k), Subgroup.closure h ‚â§ Subgroup.closure k","name":"Subgroup.closure_mono","isProp":true,"docString":"Subgroup closure of a set is monotone in its argument: if `h ‚äÜ k`,\nthen `closure h ‚â§ closure k`. "},{"type":"‚àÄ {M : Type u_2} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_4} [inst_1 : CommMonoid N] {P : Type u_3}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P} {T : Submonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_1} [inst_3 : CommMonoid Q]\n  {k : Submonoid.LocalizationMap T Q} (z : N),\n  ‚Üë(Submonoid.LocalizationMap.map f hy k) z *\n      ‚Üë(Submonoid.LocalizationMap.toMap k) (‚Üëg ‚Üë(Prod.snd (Submonoid.LocalizationMap.sec f z))) =\n    ‚Üë(Submonoid.LocalizationMap.toMap k) (‚Üëg (Prod.fst (Submonoid.LocalizationMap.sec f z)))","name":"Submonoid.LocalizationMap.map_mul_right","isProp":true,"docString":"Given Localization maps `f : M ‚Üí* N, k : P ‚Üí* Q` for Submonoids `S, T` respectively, if a\n`CommMonoid` homomorphism `g : M ‚Üí* P` induces a `f.map hy k : N ‚Üí* Q`, then for all `z : N`,\nwe have `f.map hy k z * k (g y) = k (g x)` where `x : M, y ‚àà S` are such that\n`z * f y = f x`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (H : IsSemiringHom f), IsRingHom f","name":"IsRingHom.of_semiring","isProp":true,"docString":"A map of rings that is a semiring homomorphism is also a ring homomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚©ø b), ‚ÜëOrderDual.toDual b ‚©ø ‚ÜëOrderDual.toDual a","name":"Wcovby.toDual","isProp":true,"docString":"**Alias** of the reverse direction of `toDual_wcovby_toDual_iff`."},{"type":"‚àÄ {G : Type u} [inst : AddGroup G] {x : G}, (IsOfFinAddOrder (-x) : Prop) ‚Üî (IsOfFinAddOrder x : Prop)","name":"isOfFinAddOrder_neg_iff","isProp":true,"docString":"Inverses of elements of finite additive order\nhave finite additive order."},{"type":"‚àÄ {C : Type v} [inst : CategoryTheory.Category C] {D : Type v} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  (I :\n    (d : D) ‚Üí\n      CategoryTheory.Limits.colimit\n          (F ‚ãô Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.coyoneda) (Opposite.op d)) ‚âÖ\n        PUnit),\n  CategoryTheory.Functor.Final F","name":"CategoryTheory.Functor.Final.cofinal_of_colimit_comp_coyoneda_iso_pUnit","isProp":true,"docString":"If `colimit (F ‚ãô coyoneda.obj (op d)) ‚âÖ PUnit` for all `d : D`, then `F` is cofinal.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (h : IsClosed s), interior (frontier s) = ‚àÖ","name":"interior_frontier","isProp":true,"docString":"The frontier of a closed set has no interior point. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] (c : Urysohns.CU X),\n  Continuous (Urysohns.CU.lim c)","name":"Urysohns.CU.continuous_lim","isProp":true,"docString":"Continuity of `Urysohns.CU.lim`. See module docstring for a sketch of the proofs. "},{"type":"‚àÄ {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} (s : Finset { x : Œ± // p x }) {a : Œ±} (h : ¬¨(p a : Prop)),\n  ¬¨(a ‚àà Finset.map (Function.Embedding.subtype fun (x : Œ±) ‚Ü¶ p x) s : Prop)","name":"Finset.not_mem_map_subtype_of_not_property","isProp":true,"docString":"If a `Finset` of a subtype is converted to the main type with\n`Embedding.subtype`, the result does not contain any value that does\nnot satisfy the property of the subtype. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] [inst_1 : SubtractionMonoid H] (h : G ‚âÉ+ H) (x : G), ‚Üëh (-x) = -‚Üëh x","name":"AddEquiv.map_neg","isProp":true,"docString":"An additive equivalence of additive groups preserves negation."},{"type":"‚àÄ {n : ‚Ñï} {k : ‚Ñï} (h : k ‚â§ n), Nat.descFactorial n k = Nat.factorial n / Nat.factorial (n - k)","name":"Nat.descFactorial_eq_div","isProp":true,"docString":"Avoid in favor of `Nat.factorial_mul_descFactorial` if you can. ‚Ñï-division isn't worth it. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {S : Set (Set Œ±)} (h : ‚àÄ (s : Set Œ±) (a : s ‚àà S), IsGŒ¥ s)\n  (hS : Set.Countable S), IsGŒ¥ (‚ãÇ‚ÇÄ S)","name":"isGŒ¥_inter‚Çõ","isProp":true,"docString":"A countable intersection of GŒ¥ sets is a GŒ¥ set. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C]\n  [self : CategoryTheory.Pretriangulated C] (T : CategoryTheory.Pretriangulated.Triangle C),\n  (T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles : Prop) ‚Üî\n    (CategoryTheory.Pretriangulated.Triangle.rotate T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles : Prop)","name":"CategoryTheory.Pretriangulated.rotate_distinguished_triangle","isProp":true,"docString":"a triangle is distinguished iff it is so after rotating it "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} {E : Set Œ±}, IsClosed (Metric.cthickening Œ¥ E)","name":"Metric.isClosed_cthickening","isProp":true,"docString":"The closed thickening is a closed set. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasCoequalizer f g] {W : C} {k : CategoryTheory.Limits.coequalizer f g ‚ü∂ W}\n  {l : CategoryTheory.Limits.coequalizer f g ‚ü∂ W}\n  (h : CategoryTheory.Limits.coequalizer.œÄ f g ‚â´ k = CategoryTheory.Limits.coequalizer.œÄ f g ‚â´ l), k = l","name":"CategoryTheory.Limits.coequalizer.hom_ext","isProp":true,"docString":"Two maps from a coequalizer are equal if they are equal when composed with the coequalizer\nmap "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedCommRing Œ±] (a : Œ±) (b : Œ±), a * b = b * a","name":"OrderedCommRing.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {X : outParam (Type u_1)} {Y : outParam (Type u_2)} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  {F : Type u_3} {f‚ÇÄ : outParam C(X, Y)} {f‚ÇÅ : outParam C(X, Y)} [self : ContinuousMap.HomotopyLike F f‚ÇÄ f‚ÇÅ] (f : F)\n  (x : X), ‚Üëf (0, x) = ‚Üëf‚ÇÄ x","name":"ContinuousMap.HomotopyLike.map_zero_left","isProp":true,"docString":"value of the homotopy at 0 "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {ua1 : UniformSpace Œ±} {ua2 : UniformSpace Œ±}\n  {ub1 : UniformSpace Œ≤} {ub2 : UniformSpace Œ≤} {uc1 : UniformSpace Œ≥}\n  (h : UniformContinuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)),\n  UniformContinuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)","name":"uniformContinuous_inf_dom_right‚ÇÇ","isProp":true,"docString":"A version of `UniformContinuous.inf_dom_right` for binary functions "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] [self : CompleteSpace Œ±] {f : Filter Œ±} (a : Cauchy f), ‚àÉ (x : Œ±), f ‚â§ nhds x","name":"CompleteSpace.complete","isProp":true,"docString":"In a complete uniform space, every Cauchy filter converges. "},{"type":"‚àÄ {Œπ : Type u_2} {B : Type u_1} {F : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (Z : FiberBundleCore Œπ B F) (v : F)\n  (h :\n    ‚àÄ (i : Œπ) (j : Œπ) (x : B) (a : x ‚àà FiberBundleCore.baseSet Z i ‚à© FiberBundleCore.baseSet Z j),\n      FiberBundleCore.coordChange Z i j x v = v),\n  Continuous\n    (let_fun this : (a : B) ‚Üí FiberBundleCore.TotalSpace Z := fun (x : B) ‚Ü¶ { fst := x, snd := v };\n    this)","name":"FiberBundleCore.continuous_const_section","isProp":true,"docString":"If an element of `F` is invariant under all coordinate changes, then one can define a\ncorresponding section of the fiber bundle, which is continuous. This applies in particular to the\nzero section of a vector bundle. Another example (not yet defined) would be the identity\nsection of the endomorphism bundle of a vector bundle. "},{"type":"‚àÄ {K : Type u} [self : Field K] (a : K) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"Field.mul_inv_cancel","isProp":true,"docString":"For a nonzero `a`, `a‚Åª¬π` is a right multiplicative inverse. "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_3} {N : Type u_1} [inst : AddCommMonoid M] [inst_1 : Zero N] (f : (a : Œ±) ‚Üí N)\n  (g : (a : Œ±) ‚Üí (a : N) ‚Üí M) {s : Finset Œ±} {t : Finset Œ±} (h : s ‚äÜ t) (hg : ‚àÄ (a : Œ±), g a 0 = 0),\n  (Finset.sum s fun (i : Œ±) ‚Ü¶ g i (f i)) = Finset.sum t fun (i : Œ±) ‚Ü¶ g i (Set.indicator (‚Üës) f i)","name":"Set.sum_indicator_subset_of_eq_zero","isProp":true,"docString":"Consider a sum of `g i (f i)` over a `Finset`. Suppose `g` is a\nfunction such as multiplication, which maps a second argument of 0 to\n0.  (A typical use case would be a weighted sum of `f i * h i` or `f i ‚Ä¢ h i`,\nwhere `f` gives the weights that are multiplied by some other\nfunction `h`.)  Then if `f` is replaced by the corresponding indicator\nfunction, the `Finset` may be replaced by a possibly larger `Finset`\nwithout changing the value of the sum. "},{"type":"‚àÄ {Œ± : Type u} {l : List Œ±} (a : List.Nodup l), List.Nodup (List.attach l)","name":"List.Nodup.attach","isProp":true,"docString":"**Alias** of the reverse direction of `List.nodup_attach`."},{"type":"‚àÄ {Œ± : Sort u_1} {s‚ÇÅ : Setoid Œ±} {p : (a : Quotient s‚ÇÅ) ‚Üí Prop} (h : ‚àÄ (a : Œ±), p (Quotient.mk'' a)) (q : Quotient s‚ÇÅ),\n  p q","name":"Quotient.ind'","isProp":true,"docString":"A version of `Quotient.ind` taking `{s : Setoid Œ±}` as an implicit argument instead of an\ninstance argument. "},{"type":"‚àÄ {Œ± : Type u_1} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsRefl Œ± r] [inst : IsTrans Œ± r] {s : Set Œ±}\n  (h : Set.PartiallyWellOrderedOn s r),\n  Set.PartiallyWellOrderedOn (setOf fun (l : List Œ±) ‚Ü¶ ‚àÄ (x : Œ±) (a : x ‚àà l), x ‚àà s) (List.SublistForall‚ÇÇ r)","name":"Set.PartiallyWellOrderedOn.partiallyWellOrderedOn_sublistForall‚ÇÇ","isProp":true,"docString":"Higman's Lemma, which states that for any reflexive, transitive relation `r` which is\npartially well-ordered on a set `s`, the relation `List.SublistForall‚ÇÇ r` is partially\nwell-ordered on the set of lists of elements of `s`. That relation is defined so that\n`List.SublistForall‚ÇÇ r l‚ÇÅ l‚ÇÇ` whenever `l‚ÇÅ` related pointwise by `r` to a sublist of `l‚ÇÇ`.  "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] (s : Subring R) (m : Multiset R) (a : ‚àÄ (a : R) (a_1 : a ‚àà m), a ‚àà s),\n  Multiset.sum m ‚àà s","name":"Subring.multiset_sum_mem","isProp":true,"docString":"Sum of a multiset of elements in an `Subring` of a `Ring` is\nin the `Subring`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : Preorder Œ±] [inst_2 : NonAssocSemiring Œ≤]\n  [inst_3 : Preorder Œ≤] (self : Œ± ‚Üí+*o Œ≤), Monotone (OneHom.toFun ‚Üë‚Üë(OrderRingHom.toRingHom self))","name":"OrderRingHom.monotone'","isProp":true,"docString":"The proposition that the function preserves the order. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Metric.hausdorffDist s (closure s) = 0","name":"Metric.hausdorffDist_self_closure","isProp":true,"docString":"The Hausdorff distance between a set and its closure vanish "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ‚àà s),\n  AffineSubspace.mk' p (AffineSubspace.direction s) = s","name":"AffineSubspace.mk'_eq","isProp":true,"docString":"Constructing an affine subspace from a point in a subspace and that subspace's direction\nyields the original subspace. "},{"type":"‚àÄ {a : EReal} {b : EReal} (h : -a ‚â§ b), -b ‚â§ a","name":"EReal.neg_le_of_neg_le","isProp":true,"docString":"if `-a ‚â§ b` then `-b ‚â§ a` on `EReal`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : Filter Œ±} {a : Œ±},\n  (f ‚â§ nhds a : Prop) ‚Üî (‚àÄ (s : Set Œ±) (a : a ‚àà s) (a : IsOpen s), s ‚àà f : Prop)","name":"le_nhds_iff","isProp":true,"docString":"A filter lies below the neighborhood filter at `a` iff it contains every open set around `a`. "},{"type":"‚àÄ {Œ± : Type u_1} {R : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [inst : DecidableRel R] {l : List Œ±} (a : List.Pairwise R l),\n  List.pwFilter R l = l","name":"List.Pairwise.pwFilter","isProp":true,"docString":"**Alias** of the reverse direction of `List.pwFilter_eq_self`."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {t : CategoryTheory.Limits.Cone F} (h : CategoryTheory.Limits.IsLimit t) (s : CategoryTheory.Limits.Cone F),\n  ‚àÉ! (l : CategoryTheory.Limits.Cone.pt s ‚ü∂ CategoryTheory.Limits.Cone.pt t),\n    ‚àÄ (j : J), l ‚â´ (CategoryTheory.Limits.Cone.œÄ t).app j = (CategoryTheory.Limits.Cone.œÄ s).app j","name":"CategoryTheory.Limits.IsLimit.existsUnique","isProp":true,"docString":"Restating the definition of a limit cone in terms of the ‚àÉ! operator. "},{"type":"‚àÄ {o : Ordinal} {f : (b : Ordinal) ‚Üí (a : b < o) ‚Üí (a : Ordinal) ‚Üí Ordinal}\n  (H : ‚àÄ (i : Ordinal) (hi : i < o), Ordinal.IsNormal (f i hi)),\n  Set.Unbounded (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x < x_1)\n    (Set.inter·µ¢ fun (i : Ordinal) ‚Ü¶ Set.inter·µ¢ fun (hi : i < o) ‚Ü¶ Function.fixedPoints (f i hi))","name":"Ordinal.fp_bfamily_unbounded","isProp":true,"docString":"A generalization of the fixed point lemma for normal functions: any family of normal functions\nhas an unbounded set of common fixed points. "},{"type":"‚àÄ {Œ± : Type u} [inst : MulOneClass Œ±] [inst_1 : HasDistribNeg Œ±] (a : Œ±), -1 * a = -a","name":"neg_one_mul","isProp":true,"docString":"The additive inverse of one multiplied by an element of a ring is the element's additive\ninverse. "},{"type":"‚àÄ {Œπ : Sort u_2} {M : Type u_1} [inst : Mul M] (S : (a : Œπ) ‚Üí Subsemigroup M) {C : (a : M) ‚Üí Prop} {x‚ÇÅ : M}\n  (hx‚ÇÅ : x‚ÇÅ ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hp : ‚àÄ (i : Œπ) (x‚ÇÇ : M) (_hxS : x‚ÇÇ ‚àà S i), C x‚ÇÇ)\n  (hmul : ‚àÄ (x : M) (y : M) (a : C x) (a : C y), C (x * y)), C x‚ÇÅ","name":"Subsemigroup.sup·µ¢_induction","isProp":true,"docString":"An induction principle for elements of `‚®Ü i, S i`.\nIf `C` holds all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (h : Fermat42 a b c),\n  ‚àÉ (a0 : ‚Ñ§),\n    ‚àÉ (b0 : ‚Ñ§), ‚àÉ (c0 : ‚Ñ§), (Fermat42.Minimal a0 b0 c0 : Prop) ‚àß ((a0 % 2 = 1 : Prop) ‚àß (0 < c0 : Prop) : Prop)","name":"Fermat42.exists_pos_odd_minimal","isProp":true,"docString":"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) (x : List Œ±),\n  x ++ List.join (List.map (fun (l : List Œ±) ‚Ü¶ l ++ x) L) = List.join (List.map (fun (l : List Œ±) ‚Ü¶ x ++ l) L) ++ x","name":"List.append_join_map_append","isProp":true,"docString":"We can rebracket `x ++ (l‚ÇÅ ++ x) ++ (l‚ÇÇ ++ x) ++ ... ++ (l‚Çô ++ x)` to\n`(x ++ l‚ÇÅ) ++ (x ++ l‚ÇÇ) ++ ... ++ (x ++ l‚Çô) ++ x` where `L = [l‚ÇÅ, l‚ÇÇ, ..., l‚Çô]`. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {Œ±_1 : Type u_1} {p‚ÇÅ : (a : (a : Œ±) ‚Üí Œ±_1) ‚Üí Prop}\n  {f : m ((a : Œ±) ‚Üí Œ±_1)} {q : (a : Œ±_1) ‚Üí Prop} [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m Œ±}\n  (hf : SatisfiesM p‚ÇÅ f) (hx : SatisfiesM (fun (a : Œ±) ‚Ü¶ ‚àÄ {f : (a : Œ±) ‚Üí Œ±_1} (a_1 : p‚ÇÅ f), q (f a)) x),\n  SatisfiesM q (Seq.seq f fun (x_1 : Unit) ‚Ü¶ x)","name":"SatisfiesM.seq_pre'","isProp":true,"docString":"`SatisfiesM` distributes over `<*>`, weakest precondition version 2.\n(Use this when `f` and the goal are known and `x` is a subgoal.)\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Semiring Œ±] [inst_1 : Semiring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsSemiringHom f),\n  IsAddMonoidHom f","name":"IsSemiringHom.to_isAddMonoidHom","isProp":true,"docString":"A semiring homomorphism is an additive monoid homomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (x : (a : Fin n) ‚Üí Œ±) (x‚ÇÄ : (a : Fin 1) ‚Üí Œ±), Fin.append x x‚ÇÄ = Fin.snoc x (x‚ÇÄ 0)","name":"Fin.append_right_eq_snoc","isProp":true,"docString":"Appending a one-tuple to the right is the same as `fin.snoc`. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú),\n  ‚àÉ (L : List (Matrix.TransvectionStruct (Fin r ‚äï Unit) ùïú)),\n    ‚àÉ (L' : List (Matrix.TransvectionStruct (Fin r ‚äï Unit) ùïú)),\n      Matrix.IsTwoBlockDiagonal\n        (Matrix.mul (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L)) M)\n          (List.prod (List.map Matrix.TransvectionStruct.toMatrix L')))","name":"Matrix.Pivot.exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec","isProp":true,"docString":"There exist two lists of `TransvectionStruct` such that multiplying by them on the left and\non the right makes a matrix block-diagonal. "},{"type":"‚àÄ (k : Type u_1) {V : Type u_4} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_2} [inst_4 : CharZero k] {s : Finset Œπ} (p : (a : Œπ) ‚Üí P)\n  (h : Finset.Nonempty s), Finset.centroid k s p ‚àà affineSpan k (Set.range p)","name":"centroid_mem_affineSpan_of_nonempty","isProp":true,"docString":"In the characteristic zero case, the centroid lies in the affine\nspan if the set is nonempty. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [inst_1 : IsModularLattice Œ±] [inst_2 : IsCompactlyGenerated Œ±]\n  [inst_3 : IsAtomistic Œ±], ComplementedLattice Œ±","name":"complementedLattice_of_isAtomistic","isProp":true,"docString":"See [Theorem 6.6][calugareanu]. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} {s : Finset Œ±} [inst : AddCommMonoid Œ≤] [inst_1 : DecidableEq Œ≥]\n  (f : (a : Œ≥) ‚Üí Œ≤) (g : (a : Œ±) ‚Üí Œ≥),\n  (Finset.sum s fun (a : Œ±) ‚Ü¶ f (g a)) =\n    Finset.sum (Finset.image g s) fun (b : Œ≥) ‚Ü¶ Finset.card (Finset.filter (fun (a : Œ±) ‚Ü¶ g a = b) s) ‚Ä¢ f b","name":"Finset.sum_comp","isProp":true,"docString":"The sum of the composition of functions `f` and `g`, is the sum over `b ‚àà s.image g`\nof `f b` times of the cardinality of the fibre of `b`. See also `Finset.sum_image`."},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommSemiring Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (h : M ‚âÉ* N), ‚Üëh 1 = 1","name":"MulEquiv.map_one","isProp":true,"docString":"A multiplicative isomorphism of monoids sends `1` to `1` (and is hence a monoid isomorphism). "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {p : Filter Œπ} [inst_1 : Filter.NeBot p] (hF : UniformCauchySeqOn F p s)\n  (hF' : ‚àÄ (x : Œ±) (a : x ‚àà s), Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n x) p (nhds (f x))), TendstoUniformlyOn F f p s","name":"UniformCauchySeqOn.tendstoUniformlyOn_of_tendsto","isProp":true,"docString":"A uniformly Cauchy sequence converges uniformly to its limit "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : IsCompact s) (ht : IsOpen t), IsCompact (s \\ t)","name":"IsCompact.diff","isProp":true,"docString":"The set difference of a compact set and an open set is a compact set. "},{"type":"‚àÄ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsRightCancelAdd G], IsLeftCancelAdd G","name":"AddCommSemigroup.IsRightCancelAdd.toIsLeftCancelAdd","isProp":true,"docString":"Any\n`AddCommSemigroup G` that satisfies `IsRightCancelAdd G` also satisfies\n`IsLeftCancelAdd G`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±) (y : Œ±), nndist x y = Real.toNNReal (dist x y)","name":"nndist_dist","isProp":true,"docString":"Express `nndist` in terms of `dist`"},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalCommRing Œ±] (a : Œ±) (b : Œ±), a * b = b * a","name":"NonUnitalCommRing.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (v : M) {r : R} (h : 0 ‚â§ r), SameRay R (r ‚Ä¢ v) v","name":"SameRay.sameRay_nonneg_smul_left","isProp":true,"docString":"A nonnegative multiple of a vector is in the same ray as that vector. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≤} {a : Œ±} (h : ‚àÄ (b : Œ≤), f a b = b) (l : Filter Œ≤),\n  Filter.map‚ÇÇ f (pure a) l = l","name":"Filter.map‚ÇÇ_left_identity","isProp":true,"docString":"If `a` is a left identity for `f : Œ± ‚Üí Œ≤ ‚Üí Œ≤`, then `pure a` is a left identity for\n`Filter.map‚ÇÇ f`. "},{"type":"‚àÄ {Œì : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : SMul Œì T] [self : ProperlyDiscontinuousSMul Œì T]\n  {K : Set T} {L : Set T} (a : IsCompact K) (a : IsCompact L),\n  Set.Finite (setOf fun (Œ≥ : Œì) ‚Ü¶ (fun (x : T) ‚Ü¶ Œ≥ ‚Ä¢ x) '' K ‚à© L ‚â† ‚àÖ)","name":"ProperlyDiscontinuousSMul.finite_disjoint_inter_image","isProp":true,"docString":"Given two compact sets `K` and `L`, `Œ≥ ‚Ä¢ K ‚à© L` is nonempty for finitely many `Œ≥`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} {y : Œ±} (h : Metric.Bounded s) (hx : x ‚àà s)\n  (hy : y ‚àà s), dist x y ‚â§ Metric.diam s","name":"Metric.dist_le_diam_of_mem","isProp":true,"docString":"The distance between two points in a set is controlled by the diameter of the set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {rŒ≤ : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop}\n  {C : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop} (a : WellFounded rŒ±) (a : WellFounded rŒ≤)\n  (a : ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ≤) (a : ‚àÄ (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ≤) (a : Prod.GameAdd rŒ± rŒ≤ (a‚ÇÇ, b‚ÇÇ) (a‚ÇÅ, b‚ÇÅ)), C a‚ÇÇ b‚ÇÇ), C a‚ÇÅ b‚ÇÅ)\n  (a : Œ±) (b : Œ≤), C a b","name":"Prod.GameAdd.induction","isProp":true,"docString":"Induction on the well-founded `Prod.GameAdd` relation.\nNote that it's strictly more general to induct on the lexicographic order instead. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ≤) ‚Üí M}\n  (e : (a : Œ±) ‚Üí Œ≤) (he‚ÇÄ : Function.Bijective e) (he‚ÇÅ : ‚àÄ (x : Œ±), f x = g (e x)),\n  (finprod fun (i : Œ±) ‚Ü¶ f i) = finprod fun (j : Œ≤) ‚Ü¶ g j","name":"finprod_eq_of_bijective","isProp":true,"docString":"See `finprod_comp`, `Fintype.prod_bijective` and `Finset.prod_bij`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {A : Set E}\n  [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul ùïú E] (hA : Balanced ùïú A), Balanced ùïú (0 ‚à™ interior A)","name":"balanced_zero_union_interior","isProp":true,"docString":"The union of `{0}` with the interior of a balanced set is balanced. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) (b : P) {s‚ÇÅ : Finset Œπ} {s‚ÇÇ : Finset Œπ}\n  (h : s‚ÇÅ ‚äÜ s‚ÇÇ), ‚Üë(Finset.weightedVSubOfPoint s‚ÇÅ p b) w = ‚Üë(Finset.weightedVSubOfPoint s‚ÇÇ p b) (Set.indicator (‚Üës‚ÇÅ) w)","name":"Finset.weightedVSubOfPoint_indicator_subset","isProp":true,"docString":"The weighted sum is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Mul Œ±] [inst_1 : Mul Œ≤] [inst_2 : LE Œ≤]\n  [self : SubmultiplicativeHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a * b) ‚â§ ‚Üëf a * ‚Üëf b","name":"SubmultiplicativeHomClass.map_mul_le_mul","isProp":true,"docString":"the image of a product is less or equal than the product of the images. "},{"type":"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {A : Matrix n n R}\n  {B : Matrix n n R} (c : (a : n) ‚Üí R) (k : n) (hk : c k = 0) (A_eq : ‚àÄ (i : n) (j : n), A i j = B i j + c i * B k j),\n  Matrix.det A = Matrix.det B","name":"Matrix.det_eq_of_forall_row_eq_smul_add_const","isProp":true,"docString":"If you add multiples of row `B k` to other rows, the determinant doesn't change. "},{"type":"‚àÄ {P : Type u_1} [inst : Preorder P] (p : P) {Œπ : Type u_2} [inst_1 : Encodable Œπ] (ùíü : (a : Œπ) ‚Üí Order.Cofinal P)\n  (i : Œπ), ‚àÉ (x : P), (x ‚àà ùíü i : Prop) ‚àß (x ‚àà Order.idealOfCofinals p ùíü : Prop)","name":"Order.cofinal_meets_idealOfCofinals","isProp":true,"docString":"`idealOfCofinals p ùíü` is `ùíü`-generic. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M], Reflexive fun (a : M) (b : M) ‚Ü¶ ‚àÉ (c : M), AddSemiconjBy c a b","name":"AddSemiconjBy.reflexive","isProp":true,"docString":"The relation ‚Äúthere exists an element that semiconjugates `a` to `b`‚Äù on an additive\nmonoid (or, more generally, on a `AddZeroClass` type) is reflexive."},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x : M // x ‚àà Submonoid.center M } M","name":"Submonoid.center.smulCommClass_right","isProp":true,"docString":"The center of a monoid acts commutatively on that monoid. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hs : Set.Finite s)\n  (ht : Set.Finite t),\n  ((finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) *\n      finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s ‚à© t) ‚Ü¶ f i) =\n    (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà t) ‚Ü¶ f i","name":"finprod_mem_union_inter","isProp":true,"docString":"Given finite sets `s` and `t`, the product of `f i` over `i ‚àà s ‚à™ t` times the product of\n`f i` over `i ‚àà s ‚à© t` equals the product of `f i` over `i ‚àà s` times the product of `f i`\nover `i ‚àà t`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} [inst : DecidableEq Œπ] [inst_1 : (i : Œπ) ‚Üí LinearOrder (Œ± i)]\n  (x : (i : Œπ) ‚Üí Œ± i) (y : (i : Œπ) ‚Üí Œ± i) (x' : (i : Œπ) ‚Üí Œ± i) (y' : (i : Œπ) ‚Üí Œ± i),\n  (Set.Icc x y \\ Set.pi Set.univ fun (i : Œπ) ‚Ü¶ Set.Ioo (x' i) (y' i)) ‚äÜ\n    (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.Icc x (Function.update y i (x' i))) ‚à™\n      Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.Icc (Function.update x i (y' i)) y","name":"Set.Icc_diff_pi_univ_Ioo_subset","isProp":true,"docString":"If `x`, `y`, `x'`, and `y'` are functions `Œ† i : Œπ, Œ± i`, then\nthe set difference between the box `[x, y]` and the product of the open intervals `(x' i, y' i)`\nis covered by the union of the following boxes: for each `i : Œπ`, we take\n`[x, update y i (x' i)]` and `[update x i (y' i), y]`.\n\nE.g., if `x' = x` and `y' = y`, then this lemma states that the difference between a closed box\n`[x, y]` and the corresponding open box `{z | ‚àÄ i, x i < z i < y i}` is covered by the union\nof the faces of `[x, y]`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Mul Œ±] [inst_1 : LE Œ±] [self : ExistsMulOfLE Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b),\n  ‚àÉ (c : Œ±), b = a * c","name":"ExistsMulOfLE.exists_mul_of_le","isProp":true,"docString":"For `a ‚â§ b`, `a` left divides `b` "},{"type":"Cardinal.lift = Cardinal.lift","name":"Cardinal.lift_umax","isProp":true,"docString":"`lift.{(max u v) u}` equals `lift.{v u}`. Using `set_option pp.universes true` will make it much\neasier to understand what's happening when using this lemma. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {E : Type u‚ÇÉ}\n  [inst_2 : CategoryTheory.Category E] {F : C ‚•§ D} {G : D ‚•§ E} {H : C ‚•§ E} [‚Ñã : CategoryTheory.Faithful H]\n  (h : F ‚ãô G = H), CategoryTheory.Faithful F","name":"Eq.faithful_of_comp","isProp":true,"docString":"**Alias** of `CategoryTheory.Faithful.of_comp_eq`."},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} {hs : Set.Finite s} {ht : Set.Finite t} (a : s ‚äÇ t),\n  Set.Finite.toFinset hs ‚äÇ Set.Finite.toFinset ht","name":"Set.Finite.toFinset_strictMono","isProp":true,"docString":"**Alias** of the reverse direction of `Set.Finite.toFinset_ssubset_toFinset`."},{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : (a : Œπ) ‚Üí Type u_1} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)]\n  [inst_2 : (i : Œπ) ‚Üí AddGroup (Œ≤ i)] (x : (i : Œπ) ‚Üí Œ≤ i) (y : (i : Œπ) ‚Üí Œ≤ i), hammingDist x y = hammingNorm (x - y)","name":"hammingDist_eq_hammingNorm","isProp":true,"docString":"Corresponds to `dist_eq_norm`. "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedCommSemiring Œ±] (a : Œ±) (b : Œ±), a * b = b * a","name":"OrderedCommSemiring.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b), a ‚äì b = a","name":"inf_of_le_left","isProp":true,"docString":"**Alias** of the reverse direction of `inf_eq_left`."},{"type":"‚àÄ {Œ± : Type u} (f : (a : Œ±) ‚Üí Type (max u v)), ¬¨(Function.Surjective f : Prop)","name":"Function.not_surjective_Type","isProp":true,"docString":"There is no surjection from `Œ± : Type u` into `Type u`. This theorem\ndemonstrates why `Type : Type` would be inconsistent in Lean. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (h : M ‚âÉ* N), IsMonoidHom ‚Üëh","name":"MulEquiv.isMonoidHom","isProp":true,"docString":"A multiplicative bijection between two monoids is a monoid hom\n(deprecated -- use `MulEquiv.toMonoidHom`). "},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeAddGroup.mk (FreeAddGroup.reduce L) = FreeAddGroup.mk L","name":"FreeAddGroup.reduce.self","isProp":true,"docString":"A word and its maximal reduction correspond to the same element of the additive free\ngroup."},{"type":"‚àÄ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : AddMonoid A] [self : DistribMulAction M A] (a : M) (x : A)\n  (y : A), a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y","name":"DistribMulAction.smul_add","isProp":true,"docString":"Scalar multiplication distributes across addition "},{"type":"‚àÄ {Œ± : Type u_1} [self : Bornology Œ±], Bornology.cobounded' ‚â§ Filter.cofinite","name":"Bornology.le_cofinite'","isProp":true,"docString":"The cobounded filter in a bornology is smaller than the cofinite filter. This is a field of\nthe structure, but one should always prefer `Bornology.le_cofinite` because it makes the `Œ±`\nargument explciit. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (S : Set Œ±) (f : Œ≤ ‚âÉ Œ±), ‚Üëf ‚Åª¬π' S = ‚Üë(Equiv.symm f) '' S","name":"Set.preimage_equiv_eq_image_symm","isProp":true,"docString":"Alias for `Equiv.image_eq_preimage` "},{"type":"‚àÄ (f : CircleDeg1Lift) {x : ‚Ñù} {n : ‚Ñï} {m : ‚Ñ§} (h : ‚Üë(f ^ n) x = x + ‚Üëm) (hn : 0 < n),\n  CircleDeg1Lift.translationNumber f = ‚Üëm / ‚Üën","name":"CircleDeg1Lift.translationNumber_of_map_pow_eq_add_int","isProp":true,"docString":"If `f^n x - x`, `n > 0`, is an integer number `m` for some point `x`, then\n`œÑ f = m / n`. On the circle this means that a map with a periodic orbit has\na rational rotation number. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P} {s : AffineSubspace k P} (hp‚ÇÅ : p‚ÇÅ ‚àà s) (hp‚ÇÇ : p‚ÇÇ ‚àà s),\n  affineSpan k {p‚ÇÅ, p‚ÇÇ} ‚â§ s","name":"affineSpan_pair_le_of_mem_of_mem","isProp":true,"docString":"The span of two points that lie in an affine subspace is contained in that subspace. "},{"type":"‚àÄ {Œ± : Type u_1} {ùíú : Finset (Finset Œ±)} {A : Finset Œ±} {r : ‚Ñï},\n  (A ‚àà Finset.slice ùíú r : Prop) ‚Üî ((A ‚àà ùíú : Prop) ‚àß (Finset.card A = r : Prop) : Prop)","name":"Finset.mem_slice","isProp":true,"docString":"`A` is in the `r`-th slice of `ùíú` iff it's in `ùíú` and has cardinality `r`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (T : CategoryTheory.Monad C) {A : CategoryTheory.Monad.Algebra T}\n  {B : CategoryTheory.Monad.Algebra T} (f : A ‚ü∂ B)\n  [inst_1 : CategoryTheory.IsIso (CategoryTheory.Monad.Algebra.Hom.f f)], CategoryTheory.IsIso f","name":"CategoryTheory.Monad.algebra_iso_of_iso","isProp":true,"docString":"Given an algebra morphism whose carrier part is an isomorphism, we get an algebra isomorphism.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {s : Set Œ±} {t : Set Œ≤} (a : LocalHomeomorph.IsImage e s t),\n  LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à© ‚Üë(LocalHomeomorph.symm e) ‚Åª¬π' s =\n    LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à© t","name":"LocalHomeomorph.IsImage.symm_preimage_eq","isProp":true,"docString":"**Alias** of the forward direction of `LocalHomeomorph.IsImage.iff_symm_preimage_eq`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] (a : Œ±), Filter.map Subtype.val Filter.atBot = Filter.atBot","name":"Filter.map_val_Iic_atBot","isProp":true,"docString":"The `atBot` filter for an open interval `Iic a` comes from the `atBot` filter in the ambient\norder. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : PosMulStrictMono Œ±]\n  (ha : 0 < a) (hb : 0 < b), 0 < a * b","name":"mul_pos","isProp":true,"docString":"**Alias** of `Left.mul_pos`."},{"type":"‚àÄ {Œπ : Type u_2} {N : Type u_1} [dec_Œπ : DecidableEq Œπ] [inst : AddCommGroup N] (p : (a : Œπ) ‚Üí AddSubgroup N),\n  (CompleteLattice.Independent p : Prop) ‚Üî\n    (Function.Injective ‚Üë(Dfinsupp.sumAddHom fun (i : Œπ) ‚Ü¶ AddSubgroup.subtype (p i)) : Prop)","name":"CompleteLattice.independent_iff_dfinsupp_sumAddHom_injective","isProp":true,"docString":"A family of additive subgroups over an additive group are independent if and only if\n`Dfinsupp.sumAddHom` applied with `AddSubgroup.subtype` is injective. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {x : Œ±}\n  {p : Filter Œπ} [hp : Filter.NeBot p] (hf : UniformCauchySeqOn F p s) (hx : x ‚àà s),\n  Cauchy (Filter.map (fun (i : Œπ) ‚Ü¶ F i x) p)","name":"UniformCauchySeqOn.cauchy_map","isProp":true,"docString":"If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\na Cauchy sequence. "},{"type":"‚àÄ {K : Type u} [self : Field K] (a : ‚Ñö) (x : K), Field.qsmul a x = ‚Üëa * x","name":"Field.qsmul_eq_mul'","isProp":true,"docString":"However `qsmul` is defined,\npropositionally it must be equal to multiplication by `ratCast`. "},{"type":"‚àÄ {F : Type u_1} {E : Type u_2} [inst : Field F] [inst_1 : Ring E] [inst_2 : Algebra F E] {S : Subalgebra F E}\n  (a : FiniteDimensional F { x : E // x ‚àà S }), FiniteDimensional F { x : E // x ‚àà ‚ÜëSubalgebra.toSubmodule S }","name":"FiniteDimensional.subalgebra_toSubmodule","isProp":true,"docString":"**Alias** of the reverse direction of `Subalgebra.finiteDimensional_toSubmodule`."},{"type":"‚àÄ {M : Type u_1} [inst : Semigroup M] [inst_1 : TopologicalSpace M] [inst_2 : T2Space M]\n  (continuous_mul_left : ‚àÄ (r : M), Continuous fun (x : M) ‚Ü¶ x * r) (s : Set M) (snemp : Set.Nonempty s)\n  (s_compact : IsCompact s) (s_add : ‚àÄ (x : M) (x_1 : x ‚àà s) (y : M) (x_2 : y ‚àà s), x * y ‚àà s),\n  ‚àÉ (m : M), (m ‚àà s : Prop) ‚àß (m * m = m : Prop)","name":"exists_idempotent_in_compact_subsemigroup","isProp":true,"docString":"A version of `exists_idempotent_of_compact_t2_of_continuous_mul_left` where the idempotent lies\nin some specified nonempty compact subsemigroup. "},{"type":"‚àÄ (K : Type u) (V : Type v) [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V], Module.rank K V = Cardinal.mk (Module.Free.ChooseBasisIndex K V)","name":"Module.Free.rank_eq_card_chooseBasisIndex","isProp":true,"docString":"The rank of a free module `M` over `R` is the cardinality of `ChooseBasisIndex R M`. "},{"type":"‚àÄ {F : Type u_1} {E : Type u_2} [inst : Field F] [inst_1 : Ring E] [inst_2 : Algebra F E] {S : Subalgebra F E}\n  (a : FiniteDimensional F { x : E // x ‚àà ‚ÜëSubalgebra.toSubmodule S }), FiniteDimensional F { x : E // x ‚àà S }","name":"FiniteDimensional.of_subalgebra_toSubmodule","isProp":true,"docString":"**Alias** of the forward direction of `Subalgebra.finiteDimensional_toSubmodule`."},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {S : Set Œ±} (H : ‚àÄ ‚¶Éi : Œ±‚¶Ñ ‚¶Éj : Œ±‚¶Ñ (a : i ‚àà S) (a : j ‚àà S), i ‚äî j ‚àà S),\n  DirectedOn (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) S","name":"directedOn_of_sup_mem","isProp":true,"docString":"A set stable by supremum is `‚â§`-directed. "},{"type":"‚àÄ {Œ± : Type u} [inst : StrictOrderedRing Œ±] {a : Œ±} {b : Œ±} (ha : a < 0) (h : 1 < b), a * b < a","name":"mul_lt_of_one_lt_right","isProp":true,"docString":"Variant of `lt_mul_of_lt_one_right` for `a` negative instead of positive. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {x : Œ±} {t : Set Œ±}\n  {Œ¶ : (a : Œ±) ‚Üí Œ≤} (hŒ¶ : Isometry Œ¶), EMetric.infEdist (Œ¶ x) (Œ¶ '' t) = EMetric.infEdist x t","name":"EMetric.infEdist_image","isProp":true,"docString":"The infimum edistance is invariant under isometries "},{"type":"‚àÄ {Œ± : Type u_1} [self : SeminormedCommRing Œ±] (x : Œ±) (y : Œ±), x * y = y * x","name":"SeminormedCommRing.mul_comm","isProp":true,"docString":"Multiplication is commutative. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonUnitalNonAssocSemiring Œ±]\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [self : NonUnitalRingHomClass F Œ± Œ≤] (f : F) (x : Œ±) (y : Œ±),\n  ‚Üëf (x + y) = ‚Üëf x + ‚Üëf y","name":"NonUnitalRingHomClass.map_add","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"CanonicallyLinearOrderedSemifield.mul_inv_cancel","isProp":true,"docString":"Every nonzero element of a group with zero is invertible. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] (self : Subring R) {x : R}\n  (a : x ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid (Subring.toSubsemiring self)))),\n  -x ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid (Subring.toSubsemiring self)))","name":"Subring.neg_mem'","isProp":true,"docString":"`G` is closed under negation "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {Œ± : Type u_4} {S : Type u_3} [inst : SetLike S R] [inst_1 : Monoid R]\n  [inst_2 : AddMonoid Œπ] (A : (a : Œπ) ‚Üí S) [inst_3 : SetLike.GradedMonoid A] (fŒπ : (a : Œ±) ‚Üí Œπ)\n  (fA : (a : Œ±) ‚Üí { x : R // x ‚àà A (fŒπ a) }) (l : List Œ±),\n  List.dProd l fŒπ fA =\n    { val := List.prod (List.map (fun (a : Œ±) ‚Ü¶ ‚Üë(fA a)) l),\n      property :=\n        ((Eq.rec\n              ((SetLike.list_prod_map_mem_graded l fŒπ (fun (a : Œ±) ‚Ü¶ ‚Üë(fA a))\n                    (fun (i : Œ±) ‚Ü¶\n                      (_ :\n                        ‚àÄ (x : i ‚àà l),\n                          ‚Üë(fA i) ‚àà\n                            A\n                              (fŒπ\n                                i))=:‚àÄ (i : Œ±) (x : i ‚àà l),\n                        ‚Üë(fA i) ‚àà\n                          A\n                            (fŒπ\n                              i))=:List.prod (List.map (fun (a : Œ±) ‚Ü¶ ‚Üë(fA a)) l) ‚àà\n                    A\n                      (List.sum\n                        (List.map fŒπ\n                          l)))=:List.prod (List.map (fun (a : Œ±) ‚Ü¶ ‚Üë(fA a)) l) ‚àà A (List.sum (List.map fŒπ l)))\n              ((Eq.symm\n                    ((List.dProdIndex_eq_map_sum l\n                          fŒπ=:List.dProdIndex l fŒπ =\n                          List.sum\n                            (List.map fŒπ\n                              l))=:List.dProdIndex l fŒπ =\n                        List.sum\n                          (List.map fŒπ\n                            l))=:List.sum (List.map fŒπ l) =\n                    List.dProdIndex l\n                      fŒπ)=:List.sum (List.map fŒπ l) =\n                  List.dProdIndex l\n                    fŒπ)=:List.prod (List.map (fun (a : Œ±) ‚Ü¶ ‚Üë(fA a)) l) ‚àà\n              A (List.dProdIndex l fŒπ))=:List.prod (List.map (fun (a : Œ±) ‚Ü¶ ‚Üë(fA a)) l) ‚àà A (List.dProdIndex l fŒπ)) }","name":"SetLike.list_dProd_eq","isProp":true,"docString":"A version of `List.coe_dProd_set_like` with `Subtype.mk`. "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {a : Œ±},\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà {a}) ‚Ü¶ f i) = f a","name":"finprod_mem_singleton","isProp":true,"docString":"The product of `f i` over `i ‚àà {a}` equals `f a`. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]\n  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (f : A ‚Üí‚Çó[R] B) (a : A) (r : R),\n  ‚Üëf (‚Üë(algebraMap R A) r * a) = ‚Üë(algebraMap R B) r * ‚Üëf a","name":"LinearMap.map_algebraMap_mul","isProp":true,"docString":"An alternate statement of `LinearMap.map_smul` for when `algebraMap` is more convenient to\nwork with than `‚Ä¢`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PartialOrder Œ±] [inst_1 : Preorder Œ≤] {fa : Œ± ‚âÉo Œ±} {fb : Œ≤ ‚Ü™o Œ≤}\n  {g : (a : Œ±) ‚Üí Œ≤} (h : Function.Semiconj g ‚Üëfa ‚Üëfb) {g' : (a : Œ≤) ‚Üí Œ±} (hg' : IsOrderRightAdjoint g g'),\n  Function.Semiconj g' ‚Üëfb ‚Üëfa","name":"Function.Semiconj.symm_adjoint","isProp":true,"docString":"If an order automorphism `fa` is semiconjugate to an order embedding `fb` by a function `g`\nand `g'` is an order right adjoint of `g` (i.e. `g' y = sup‚Çõ {x | f x ‚â§ y}`), then `fb` is\nsemiconjugate to `fa` by `g'`.\n\nThis is a version of Proposition 2.1 from [√âtienne Ghys, Groupes d'hom√©omorphismes du cercle et\ncohomologie born√©e][ghys87:groupes]. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_3} {Œπ : Type u_1} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïú E] [inst_3 : Subsingleton Œπ] (p : (a : Œπ) ‚Üí E), ConvexIndependent ùïú p","name":"Subsingleton.convexIndependent","isProp":true,"docString":"A family with at most one point is convex independent. "},{"type":"‚àÄ {M : Type u_3} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {P : Type u_1}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëg ‚Üëy)) (z : N) (w : (fun (x : N) ‚Ü¶ P) z) (v : (fun (x : N) ‚Ü¶ P) z),\n  (‚Üë(Submonoid.LocalizationMap.lift f hg) z * w = v : Prop) ‚Üî\n    (‚Üëg (Prod.fst (Submonoid.LocalizationMap.sec f z)) * w = ‚Üëg ‚Üë(Prod.snd (Submonoid.LocalizationMap.sec f z)) * v :\n      Prop)","name":"Submonoid.LocalizationMap.lift_spec_mul","isProp":true,"docString":"Given a Localization map `f : M ‚Üí* N` for a Submonoid `S ‚äÜ M`, if a `CommMonoid` map\n`g : M ‚Üí* P` induces a map `f.lift hg : N ‚Üí* P` then for all `z : N, v w : P`, we have\n`f.lift hg z * w = v ‚Üî g x * w = g y * v`, where `x : M, y ‚àà S` are such that\n`z * f y = f x`. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] {A : Matrix n n Œ±}\n  {B : Matrix n n Œ±} {C : Matrix n n Œ±} (h : Matrix.mul A B = 1) (g : Matrix.mul C A = 1), B = C","name":"Matrix.right_inv_eq_left_inv","isProp":true,"docString":"The right inverse of matrix A equals the left inverse of A when they exist. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G], (Group.Fg G : Prop) ‚Üî (Monoid.Fg G : Prop)","name":"Group.fg_iff_monoid_fg","isProp":true,"docString":"A group is finitely generated if and only if it is finitely generated as a monoid. "},{"type":"‚àÄ (R : Type u_1) {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] (w : (a : œÉ) ‚Üí M),\n  MvPolynomial.IsWeightedHomogeneous w 1 0","name":"MvPolynomial.isWeightedHomogeneous_one","isProp":true,"docString":"1 is weighted homogeneous of degree 0. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hst : s ‚äÜ t)\n  (ht : Set.Finite t),\n  ((finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà t \\ s) ‚Ü¶ f i) =\n    finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà t) ‚Ü¶ f i","name":"finsum_mem_add_diff","isProp":true,"docString":"Given a finite set `t` and a subset `s` of `t`, the sum of `f i` over `i ‚àà s` plus\nthe sum of `f i` over `t \\ s` equals the sum of `f i` over `i ‚àà t`."},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {i : D ‚•§ C}\n  [inst_2 : CategoryTheory.Reflective i] {A : C} (h : A ‚àà CategoryTheory.Functor.essImage i),\n  CategoryTheory.IsIso ((CategoryTheory.Adjunction.unit (CategoryTheory.Adjunction.ofRightAdjoint i)).app A)","name":"CategoryTheory.Functor.essImage.unit_isIso","isProp":true,"docString":"If `A` is essentially in the image of a reflective functor `i`, then `Œ∑_A` is an isomorphism.\nThis gives that the \"witness\" for `A` being in the essential image can instead be given as the\nreflection of `A`, with the isomorphism as `Œ∑_A`.\n\n(For any `B` in the reflective subcategory, we automatically have that `Œµ_B` is an iso.)\n"},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : (a : Œπ) ‚Üí Type u_1} [inst : Finite Œπ] [inst : DecidableEq Œπ]\n  [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ± i)] {p : (a : (i : Œπ) ‚Üí Finset (Œ± i)) ‚Üí Prop} (f : (i : Œπ) ‚Üí Finset (Œ± i))\n  (h0 : p fun (x : Œπ) ‚Ü¶ ‚àÖ)\n  (step :\n    ‚àÄ (g : (i : Œπ) ‚Üí Finset (Œ± i)) (i : Œπ) (x : Œ± i) (x_1 : ¬¨(x ‚àà g i : Prop)) (a : p g),\n      p (Function.update g i (insert x (g i)))),\n  p f","name":"Finset.induction_on_pi","isProp":true,"docString":"Given a predicate on functions `‚àÄ i, Finset (Œ± i)` defined on a finite type, it is true on all\nmaps provided that it is true on `fun _ ‚Ü¶ ‚àÖ` and for any function `g : ‚àÄ i, Finset (Œ± i)`, an index\n`i : Œπ`, and `x ‚àâ g i`, `p g` implies `p (update g i (insert x (g i)))`.\n\nSee also `Finset.induction_on_pi_max` and `Finset.induction_on_pi_min` for specialized versions\nthat require `‚àÄ i, LinearOrder (Œ± i)`.  "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedRing Œ±] (a : Œ±) (b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ","name":"NormedRing.norm_mul","isProp":true,"docString":"The norm is submultiplicative. "},{"type":"‚àÄ {p : ‚Ñï}, padicValRat p 0 = 0","name":"padicValRat.zero","isProp":true,"docString":"`padicValRat p 0` is `0` for any `p`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤}\n  (a : ‚àÄ (x : Œ±) (y : Œ±), dist (f x) (f y) ‚â§ ‚ÜëK * dist x y), LipschitzWith K f","name":"LipschitzWith.of_dist_le_mul","isProp":true,"docString":"**Alias** of the reverse direction of `lipschitzWith_iff_dist_le_mul`."},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {a : AddUnits M} {x : M} {y : M} (h : AddSemiconjBy (‚Üëa) x y),\n  AddSemiconjBy (‚Üë(-a)) y x","name":"AddSemiconjBy.addUnits_neg_symm_left","isProp":true,"docString":"If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\n`x`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atBot : Prop) ‚Üî (Filter.Tendsto f l Filter.atBot : Prop)","name":"Filter.tendsto_mul_const_atBot_of_pos","isProp":true,"docString":"If `r` is a positive constant, then `Œª x, f x * r` tends to negative infinity along a filter if\nand only if `f` tends to negative infinity along the same filter. "},{"type":"‚àÄ {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {c : AddCon M} {f : N ‚Üí+ M},\n  AddCon.comap ‚Üëf\n      ((AddMonoidHom.map_add\n            f=:‚àÄ (a : N) (b : N), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b)=:‚àÄ (a : N) (b : N), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b)\n      c =\n    AddCon.ker (AddMonoidHom.comp (AddCon.mk' c) f)","name":"AddCon.comap_eq","isProp":true,"docString":"Given an `AddMonoid` homomorphism `f : N ‚Üí M` and an additive congruence relation\n`c` on `M`, the additive congruence relation induced on `N` by `f` equals the kernel of `c`'s\nquotient homomorphism composed with `f`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±], QuasiSober Œ±","name":"T2Space.quasiSober","isProp":true,"docString":"Any Hausdorff space is a quasi-sober space because any irreducible set is a singleton. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} (hs : seqClosure s = s), IsSeqClosed s","name":"isSeqClosed_of_seqClosure_eq","isProp":true,"docString":"If a set is equal to its sequential closure, then it is sequentially closed. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : SuccOrder Œ±] {a : Œ±} (a_1 : SuccOrder.succ a ‚â§ a), IsMax a","name":"SuccOrder.max_of_succ_le","isProp":true,"docString":"Proof of interaction between `succ` and maximal element"},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  (‚àÄ (f : ‚Ñï ‚Üío Submodule R M), ‚àÉ (n : ‚Ñï), ‚àÄ (m : ‚Ñï) (a : n ‚â§ m), ‚Üëf n = ‚Üëf m : Prop) ‚Üî (IsNoetherian R M : Prop)","name":"monotone_stabilizes_iff_noetherian","isProp":true,"docString":"A module is Noetherian iff every increasing chain of submodules stabilizes. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A + C) * Finset.card B ‚â§ Finset.card (A - B) * Finset.card (B + C)","name":"Finset.card_add_mul_le_card_sub_mul_card_add","isProp":true,"docString":"**Ruzsa's triangle inequality**. Add-sub-sub version."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±} (a_1 : IsCoatom a), IsAtom (‚ÜëOrderDual.toDual a)","name":"IsCoatom.dual","isProp":true,"docString":"**Alias** of the reverse direction of `isAtom_dual_iff_isCoatom`."},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} (ha : a ‚â† 0),\n  IsLeast (setOf fun (n : ‚Ñï) ‚Ü¶ (0 < n : Prop) ‚àß (‚àÉ (x : ‚Ñ§), ‚àÉ (y : ‚Ñ§), ‚Üën = a * x + b * y : Prop)) (Int.gcd a b)","name":"Int.gcd_least_linear","isProp":true,"docString":"For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` "},{"type":"‚àÄ {Œπ : Sort u_2} {M : Type u_1} [inst : Add M] (S : (a : Œπ) ‚Üí AddSubsemigroup M) {C : (a : M) ‚Üí Prop} {x‚ÇÅ : M}\n  (hx‚ÇÅ : x‚ÇÅ ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hp : ‚àÄ (i : Œπ) (x‚ÇÇ : M) (_hxS : x‚ÇÇ ‚àà S i), C x‚ÇÇ)\n  (hmul : ‚àÄ (x : M) (y : M) (a : C x) (a : C y), C (x + y)), C x‚ÇÅ","name":"AddSubsemigroup.sup·µ¢_induction","isProp":true,"docString":"An induction principle for elements of `‚®Ü i, S i`. If `C` holds all\nelements of `S i` for all `i`, and is preserved under addition, then it holds for all elements of\nthe supremum of `S`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : (a : Œ±) ‚Üí Œ≤}\n  (de : DenseEmbedding e) [inst : TopologicalSpace.SeparableSpace Œ±], TopologicalSpace.SeparableSpace Œ≤","name":"DenseEmbedding.separableSpace","isProp":true,"docString":"If the domain of a `DenseEmbedding` is a separable space, then so is its codomain. "},{"type":"‚àÄ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [inst : Ring k]\n  [inst_1 : AddCommGroup V1] [inst_2 : Module k V1] [inst_3 : AddTorsor V1 P1] [inst_4 : AddCommGroup V2]\n  [inst_5 : Module k V2] [inst_6 : AddTorsor V2 P2] (f : P1 ‚Üí·µÉ[k] P2), AffineMap.toFun f = ‚Üëf","name":"AffineMap.toFun_eq_coe","isProp":true,"docString":"`toFun` is the same as the result of coercing to a function. "},{"type":"‚àÄ {ùïú : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {C : ùïú} (hC : C < 0) (hf : Filter.Tendsto f l Filter.atBot)\n  (hg : Filter.Tendsto g l (nhds C)), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * g x) l Filter.atTop","name":"Filter.Tendsto.atBot_mul_neg","isProp":true,"docString":"In a linearly ordered field with the order topology, if `f` tends to `Filter.atBot` and `g`\ntends to a negative constant `C` then `f * g` tends to `Filter.atTop`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] [t : OrderTopology Œ±] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {h : (a : Œ≤) ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±} (hg : Filter.Tendsto g b (nhds a))\n  (hh : Filter.Tendsto h b (nhds a)) (hgf : Filter.Eventually (fun (b : Œ≤) ‚Ü¶ g b ‚â§ f b) b)\n  (hfh : Filter.Eventually (fun (b : Œ≤) ‚Ü¶ f b ‚â§ h b) b), Filter.Tendsto f b (nhds a)","name":"tendsto_of_tendsto_of_tendsto_of_le_of_le'","isProp":true,"docString":"**Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities\nhold eventually for the filter. "},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ] (Œ≥ : Œì‚ÇÄÀ£), {‚ÜëŒ≥} ‚àà nhds ‚ÜëŒ≥","name":"WithZeroTopology.singleton_mem_nhds_of_units","isProp":true,"docString":"If `Œ≥` is an invertible element of a linearly ordered group with zero element adjoined, then\n`{Œ≥}` is a neighbourhood of `Œ≥`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (n : ‚Ñï) (x : Œ±),\n  CanonicallyOrderedCommSemiring.npow (n + 1) x = x * CanonicallyOrderedCommSemiring.npow n x","name":"CanonicallyOrderedCommSemiring.npow_succ","isProp":true,"docString":"Raising to the power `(n + 1 : ‚Ñï)` behaves as expected. "},{"type":"‚àÄ {n : ‚Ñï} {k : ‚Ñï} {S : Set ‚Ñï} (hk : k ‚àà S) (h_ind : ‚àÄ (k : ‚Ñï) (a : k ‚àà S), k + 1 ‚àà S) (hnk : k ‚â§ n), n ‚àà S","name":"Nat.set_induction_bounded","isProp":true,"docString":"A subset of `‚Ñï` containing `k : ‚Ñï` and closed under `Nat.succ` contains every `n ‚â• k`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {A : C} {B : C} {X : C} {Y : C} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\n  [self : CategoryTheory.HasLiftingProperty i p] {f : A ‚ü∂ X} {g : B ‚ü∂ Y} (sq : CategoryTheory.CommSq f i p g),\n  CategoryTheory.CommSq.HasLift sq","name":"CategoryTheory.HasLiftingProperty.sq_hasLift","isProp":true,"docString":"Unique field expressing the any commutative square built from `f` and `g` has a lift "},{"type":"‚àÄ {M‚ÇÄ : Type u_2} {M‚ÇÄ' : Type u_1} [inst : MulZeroOneClass M‚ÇÄ] [inst_1 : Nontrivial M‚ÇÄ] [inst_2 : Zero M‚ÇÄ']\n  [inst_3 : One M‚ÇÄ'] (f : (a : M‚ÇÄ') ‚Üí M‚ÇÄ) (zero : f 0 = 0) (one : f 1 = 1), Nontrivial M‚ÇÄ'","name":"pullback_nonzero","isProp":true,"docString":"Pullback a `nontrivial` instance along a function sending `0` to `0` and `1` to `1`. "},{"type":"‚àÄ (S : Set ‚Ñù) (hS : ‚àÄ (x : ‚Ñù) (a : x ‚àà S), x ‚â§ 0), sup‚Çõ S ‚â§ 0","name":"Real.sup‚Çõ_nonpos","isProp":true,"docString":"As `0` is the default value for `Real.sup‚Çõ` of the empty set, it suffices to show that `S` is\nbounded above by `0` to show that `sup‚Çõ S ‚â§ 0`.\n"},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} {g : (a : E) ‚Üí Œ≤} (hf : ConcaveOn ùïú s f) (hg : ConcaveOn ùïú s g), ConcaveOn ùïú s (f ‚äì g)","name":"ConcaveOn.inf","isProp":true,"docString":"The pointwise minimum of concave functions is concave. "},{"type":"‚àÄ (a : ‚Ñù), Cardinal.mk ‚Üë(Set.Iio a) = Cardinal.continuum","name":"Cardinal.mk_Iio_real","isProp":true,"docString":"The cardinality of the interval (-‚àû, a). "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} [inst : Norm F] {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù}\n  (a : (fun (x : Œ±) ‚Ü¶ abs (u x)) =o[l] g), u =o[l] g","name":"Asymptotics.IsLittleO.of_abs_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_abs_left`."},{"type":"‚àÄ {A : Type u_1} {B : Type u_2} [inst : Add A] [inst_1 : Add B] (self : A ‚âÉ+ B) (x : A) (y : A),\n  Equiv.toFun (AddEquiv.toEquiv self) (x + y) =\n    Equiv.toFun (AddEquiv.toEquiv self) x + Equiv.toFun (AddEquiv.toEquiv self) y","name":"AddEquiv.map_add'","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (open_map : IsOpenMap f) (cont : Continuous f) (surj : Function.Surjective f), QuotientMap f","name":"IsOpenMap.to_quotientMap","isProp":true,"docString":"A continuous surjective open map is a quotient map. "},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : C(Œ±, Œ≤)} {Œπ : Type u‚ÇÉ}\n  {p : Filter Œπ} {F : (a : Œπ) ‚Üí C(Œ±, Œ≤)} [inst_2 : LocallyCompactSpace Œ±],\n  (Filter.Tendsto F p (nhds f) : Prop) ‚Üî (TendstoLocallyUniformly (fun (i : Œπ) (a : Œ±) ‚Ü¶ ‚Üë(F i) a) (‚Üëf) p : Prop)","name":"ContinuousMap.tendsto_iff_tendstoLocallyUniformly","isProp":true,"docString":"Convergence in the compact-open topology is the same as locally uniform convergence on a locally\ncompact space.\n\nFor non-T2 spaces, the assumption `LocallyCompactSpace Œ±` is stronger than we need and in fact\nthe `‚Üê` direction is true unconditionally. See `ContinuousMap.tendstoLocallyUniformly_of_tendsto`\nand `ContinuousMap.tendsto_of_tendstoLocallyUniformly` for versions requiring weaker hypotheses. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] [inst_1 : Monoid M] {S : Set (MonoidAlgebra R M)}\n  (hS : Algebra.adjoin R S = ‚ä§),\n  Algebra.adjoin R\n      (Set.union·µ¢ fun (f : MonoidAlgebra R M) ‚Ü¶\n        Set.union·µ¢ fun (h : f ‚àà S) ‚Ü¶ ‚Üë(MonoidAlgebra.of R M) '' ‚Üë(Finsupp.support f)) =\n    ‚ä§","name":"MonoidAlgebra.support_gen_of_gen","isProp":true,"docString":"If a set `S` generates, as algebra, `MonoidAlgebra R M`, then the set of supports of elements\nof `S` generates `MonoidAlgebra R M`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : SMul ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (hf : ConvexOn ùïú s f) (c : E), ConvexOn ùïú ((fun (z : E) ‚Ü¶ c + z) ‚Åª¬π' s) (f ‚àò fun (z : E) ‚Ü¶ z + c)","name":"ConvexOn.translate_left","isProp":true,"docString":"Left translation preserves convexity. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Inf Œ±] [inst_1 : Inf Œ≤]\n  [self : InfHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a ‚äì b) = ‚Üëf a ‚äì ‚Üëf b","name":"InfHomClass.map_inf","isProp":true,"docString":"An `InfHomClass` morphism preserves infima. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)) = Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (MonovaryOn f (g ‚àò ‚ÜëœÉ) ‚Üës : Prop)","name":"MonovaryOn.sum_smul_comp_perm_eq_sum_smul_iff","isProp":true,"docString":"**Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f` and `g ‚àò œÉ` monovary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : HeytingAlgebra Œ±] {a : Œ±} {b : Œ±} (a_1 : Disjoint a b), a ‚â§ b·∂ú","name":"Disjoint.le_compl_right","isProp":true,"docString":"**Alias** of the reverse direction of `le_compl_iff_disjoint_right`."},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] (a : Œ±) (b : Œ±) (c : Œ±),\n  (0 ‚â§ a * b : Prop) ‚à® ((0 ‚â§ b * c : Prop) ‚à® (0 ‚â§ c * a : Prop) : Prop)","name":"mul_nonneg_of_three","isProp":true,"docString":"Out of three elements of a `LinearOrderedRing`, two must have the same sign. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú] {s : Set ùïú},\n  (StrictConvex ùïú s : Prop) ‚Üî (Convex ùïú s : Prop)","name":"strictConvex_iff_convex","isProp":true,"docString":"A set in a linear ordered field is strictly convex if and only if it is convex. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {A : Finset Œ±} {B : Finset Œ±} (h : A ‚äÇ B), Finset.toColex A < Finset.toColex B","name":"Colex.colex_lt_of_ssubset","isProp":true,"docString":"If `A ‚äÇ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\n`‚äÜ` is not a linear order. "},{"type":"‚àÄ {Œ± : Type u_1} {G : SimpleGraph Œ±} {n : ‚Ñï} [inst : Fintype Œ±] (hc : Fintype.card Œ± < n), SimpleGraph.CliqueFree G n","name":"SimpleGraph.cliqueFree_of_card_lt","isProp":true,"docString":"See `simple_graph.clique_free_chromatic_number_succ` for a tighter bound. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (ha : a < 1) (hb : b < 1), a * b < 1","name":"Right.mul_lt_one","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Finset Œ±} {k : ‚Ñï} (h : Finset.card s = k) {f : Fin k ‚Ü™o Œ±}\n  (hfs : ‚àÄ (x : Fin k), ‚Üëf x ‚àà s), f = Finset.orderEmbOfFin s h","name":"Finset.orderEmbOfFin_unique'","isProp":true,"docString":"An order embedding `f` from `Fin k` to a finset of cardinality `k` has to coincide with\nthe increasing bijection `orderEmbOfFin s h`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤}\n  (a : LipschitzWith K f) (x : Œ±) (y : Œ±), dist (f x) (f y) ‚â§ ‚ÜëK * dist x y","name":"LipschitzWith.dist_le_mul","isProp":true,"docString":"**Alias** of the forward direction of `lipschitzWith_iff_dist_le_mul`."},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (a_1 : a = b), a ‚â§ b","name":"Eq.le","isProp":true,"docString":"**Alias** of `le_of_eq`."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {m : ‚Ñï} (x : M)\n  (v : (a : Fin m) ‚Üí M) (hli : LinearIndependent R v)\n  (x_ortho : ‚àÄ (c : R) (y : { x : M // x ‚àà Submodule.span R (Set.range v) }) (a : c ‚Ä¢ x + ‚Üëy = 0), c = 0),\n  LinearIndependent R (Fin.cons x v)","name":"LinearIndependent.fin_cons'","isProp":true,"docString":"See `LinearIndependent.fin_cons` for a family of elements in a vector space. "},{"type":"‚àÄ {R : Type u_2} {E : Type u_1} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E] [inst_2 : Module R E]\n  (s : Set E),\n  ‚Üë(ClosureOperator.toOrderHom (convexHull R)) s =\n    setOf fun (x : E) ‚Ü¶\n      ‚àÉ (Œπ : Type u'),\n        ‚àÉ (t : Finset Œπ),\n          ‚àÉ (w : (a : Œπ) ‚Üí R),\n            ‚àÉ (z : (a : Œπ) ‚Üí E),\n              ‚àÉ (x_1 : ‚àÄ (i : Œπ) (a : i ‚àà t), 0 ‚â§ w i),\n                ‚àÉ (x_2 : (Finset.sum t fun (i : Œπ) ‚Ü¶ w i) = 1),\n                  ‚àÉ (x_3 : ‚àÄ (i : Œπ) (a : i ‚àà t), z i ‚àà s), Finset.centerMass t w z = x","name":"convexHull_eq","isProp":true,"docString":"Convex hull of `s` is equal to the set of all centers of masses of `Finset`s `t`, `z '' t ‚äÜ s`.\nThis version allows finsets in any type in any universe. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} (ha : 0 < a), (Set.Ioo 0 a)‚Åª¬π = Set.Ioi a‚Åª¬π","name":"Set.inv_Ioo_0_left","isProp":true,"docString":"The (pre)image under `inv` of `Ioo 0 a` is `Ioi a‚Åª¬π`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedSemifield Œ±], 0‚Åª¬π = 0","name":"LinearOrderedSemifield.inv_zero","isProp":true,"docString":"The inverse of `0` in a group with zero is `0`. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {p‚ÇÇ : (a : Œ±) ‚Üí Prop} {Œ±_1 : Type u_1} {q : (a : Œ±_1) ‚Üí Prop}\n  {f : m ((a : Œ±) ‚Üí Œ±_1)} [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m Œ±}\n  (hf : SatisfiesM (fun (f : (a : Œ±) ‚Üí Œ±_1) ‚Ü¶ ‚àÄ {a : Œ±} (a_1 : p‚ÇÇ a), q (f a)) f) (hx : SatisfiesM p‚ÇÇ x),\n  SatisfiesM q (Seq.seq f fun (x_1 : Unit) ‚Ü¶ x)","name":"SatisfiesM.seq_pre","isProp":true,"docString":"`SatisfiesM` distributes over `<*>`, weakest precondition version 1.\n(Use this when `x` and the goal are known and `f` is a subgoal.)\n"},{"type":"‚àÄ {k : Type u_2} {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set V} (p : P) (h : Submodule.span k (Set.range Subtype.val) = ‚ä§),\n  affineSpan k ({p} ‚à™ (fun (v : V) ‚Ü¶ v +·µ• p) '' s) = ‚ä§","name":"affineSpan_singleton_union_vadd_eq_top_of_span_eq_top","isProp":true,"docString":"Suppose a set of vectors spans `V`.  Then a point `p`, together with those vectors added to `p`,\nspans `P`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] {I : Set Œ≤} {S : (a : Œ≤) ‚Üí Set Œ±}\n  (H : Set.Finite I),\n  (BddAbove (Set.union·µ¢ fun (i : Œ≤) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà I) ‚Ü¶ S i) : Prop) ‚Üî\n    (‚àÄ (i : Œ≤) (a : i ‚àà I), BddAbove (S i) : Prop)","name":"Set.Finite.bddAbove_bunion·µ¢","isProp":true,"docString":"A finite union of sets which are all bounded above is still bounded above."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} (n : ‚Ñï) {d : (a : ‚Ñï) ‚Üí ENNReal}\n  (hd : ‚àÄ {k : ‚Ñï} (a : k < n), edist (f k) (f (k + 1)) ‚â§ d k),\n  edist (f 0) (f n) ‚â§ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ d i","name":"edist_le_range_sum_of_edist_le","isProp":true,"docString":"A version of `edist_le_range_sum_edist` with each intermediate distance replaced\nwith an upper estimate. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : MeasurableSpace Œ±] [h : MeasurableSpace.CountablyGenerated Œ±]\n  [inst_1 : MeasurableSingletonClass Œ±],\n  ‚àÉ (f : (a : Œ±) ‚Üí (a : ‚Ñï) ‚Üí Bool), (Measurable f : Prop) ‚àß (Function.Injective f : Prop)","name":"MeasurableSpace.measurable_injection_cantor_of_countablyGenerated","isProp":true,"docString":"If a measurable space is countably generated, it admits a measurable injection\ninto the Cantor space `‚Ñï ‚Üí Bool` (equipped with the product sigma algebra). "},{"type":"‚àÄ {R : Type u_3} [inst : CommSemiring R] (M : Submonoid R) {S : Type u_2} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] {P : Type u_1} [inst_3 : CommSemiring P] [inst_4 : IsLocalization M S] (j : (a : S) ‚Üí P)\n  (k : (a : S) ‚Üí P) (hj1 : j 1 = 1) (hk1 : k 1 = 1) (hjm : ‚àÄ (a : S) (b : S), j (a * b) = j a * j b)\n  (hkm : ‚àÄ (a : S) (b : S), k (a * b) = k a * k b) (h : ‚àÄ (a : R), j (‚Üë(algebraMap R S) a) = k (‚Üë(algebraMap R S) a)),\n  j = k","name":"IsLocalization.ext","isProp":true,"docString":"To show `j` and `k` agree on the whole localization, it suffices to show they agree\non the image of the base ring, if they preserve `1` and `*`. "},{"type":"‚àÄ {P : (a : EReal) ‚Üí (a : EReal) ‚Üí Prop} (symm : Symmetric P) (top_top : P ‚ä§ ‚ä§)\n  (top_pos : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚ä§ ‚Üëx) (top_zero : P ‚ä§ 0) (top_neg : ‚àÄ (x : ‚Ñù) (a : x < 0), P ‚ä§ ‚Üëx)\n  (top_bot : P ‚ä§ ‚ä•) (pos_bot : ‚àÄ (x : ‚Ñù) (a : 0 < x), P ‚Üëx ‚ä•) (coe_coe : ‚àÄ (x : ‚Ñù) (y : ‚Ñù), P ‚Üëx ‚Üëy) (zero_bot : P 0 ‚ä•)\n  (neg_bot : ‚àÄ (x : ‚Ñù) (a : x < 0), P ‚Üëx ‚ä•) (bot_bot : P ‚ä• ‚ä•) (x : EReal) (y : EReal), P x y","name":"EReal.induction‚ÇÇ_symm","isProp":true,"docString":"Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that the relation is symmetric. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst : CategoryTheory.Simple 0], False","name":"CategoryTheory.zero_not_simple","isProp":true,"docString":"We don't want the definition of 'simple' to include the zero object, so we check that here. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {n : ‚Ñï} (m : Fin n ‚Üí‚ÇÄ ‚Ñï) (f : MvPolynomial (Fin (n + 1)) R) (i : ‚Ñï),\n  MvPolynomial.coeff m (Polynomial.coeff (‚Üë(MvPolynomial.finSuccEquiv R n) f) i) =\n    MvPolynomial.coeff (Finsupp.cons i m) f","name":"MvPolynomial.finSuccEquiv_coeff_coeff","isProp":true,"docString":"The coefficient of `m` in the `i`-th coefficient of `finSuccEquiv R n f` equals the\ncoefficient of `Finsupp.cons i m` in `f`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±], DenseRange stoneCechUnit","name":"denseRange_stoneCechUnit","isProp":true,"docString":"The image of stone_cech_unit is dense. (But stone_cech_unit need\nnot be an embedding, for example if Œ± is not Hausdorff.) "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : StrictConcaveOn ùïú s f) {x : E} {y : E} (hx : x ‚àà s) (hy : y ‚àà s) (hxy : x ‚â† y)\n  {a : ùïú} {b : ùïú} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1), min (f x) (f y) < f (a ‚Ä¢ x + b ‚Ä¢ y)","name":"StrictConcaveOn.lt_on_open_segment'","isProp":true,"docString":"A strictly concave function on an open segment is strictly lower-bounded by the min of its\nendpoints. "},{"type":"‚àÄ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [inst : Ring k]\n  [inst_1 : AddCommGroup V1] [inst_2 : Module k V1] [inst_3 : AddTorsor V1 P1] [inst_4 : AddCommGroup V2]\n  [inst_5 : Module k V2] [inst_6 : AddTorsor V2 P2] (f : P1 ‚Üí·µÉ[k] P2) (p1 : P1) (p2 : P1),\n  ‚Üë(AffineMap.linear f) (p1 -·µ• p2) = ‚Üëf p1 -·µ• ‚Üëf p2","name":"AffineMap.linearMap_vsub","isProp":true,"docString":"The linear map on the result of subtracting two points is the\nresult of subtracting the result of the affine map on those two\npoints. "},{"type":"‚àÄ {a : Prop} {b : Prop} {c : Prop} (a_1 : (a : Prop) ‚àß ((b : Prop) ‚àß (c : Prop) : Prop)),\n  (b : Prop) ‚àß ((c : Prop) ‚àß (a : Prop) : Prop)","name":"And.rotate","isProp":true,"docString":"**Alias** of the forward direction of `and_rotate`."},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Setoid X}, SequentialSpace (Quotient s)","name":"instSequentialSpaceQuotientInstTopologicalSpaceQuotient","isProp":true,"docString":"The quotient of a sequential space is a sequential space. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a ‚â§ 0) (hb : b ‚â§ 0), a + b ‚â§ 0","name":"Left.add_nonpos","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonpos`."},{"type":"‚àÄ {M : Type u} [self : MulOneClass M] (a : M), 1 * a = a","name":"MulOneClass.one_mul","isProp":true,"docString":"One is a left neutral element for multiplication "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {A : Type u‚ÇÇ}\n  [inst_1 : CategoryTheory.Category A] (self : CategoryTheory.Sheaf J A),\n  CategoryTheory.Presheaf.IsSheaf J (CategoryTheory.Sheaf.val self)","name":"CategoryTheory.Sheaf.cond","isProp":true,"docString":"the condition that the presheaf is a sheaf "},{"type":"‚àÄ {Œπ : Type u_2} {œÄ : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)] {s : (i : Œπ) ‚Üí Set (œÄ i)}\n  (a : ‚àÄ (i : Œπ), IsCompact (s i)), IsCompact (setOf fun (x : (i : Œπ) ‚Üí œÄ i) ‚Ü¶ ‚àÄ (i : Œπ), x i ‚àà s i)","name":"isCompact_pi_infinite","isProp":true,"docString":"**Tychonoff's theorem**: product of compact sets is compact. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : 0 ‚â§ a) (hb : 0 < b), 0 < a + b","name":"Right.add_pos_of_nonneg_of_pos","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_nonneg_of_pos`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] [inst_1 : FloorSemiring Œ±] (m : ‚Ñï) (n : ‚Ñï), ‚åä‚Üëm / ‚Üën‚åã‚Çä = m / n","name":"Nat.floor_div_eq_div","isProp":true,"docString":"Natural division is the floor of field division. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±], Isometry ‚ÜëŒ±","name":"UniformSpace.Completion.coe_isometry","isProp":true,"docString":"The embedding of a metric space in its completion is an isometry. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} (b : Basis Œπ R M) [inst_4 : Infinite Œπ] {Œ∫ : Type u_1} (v : (a : Œ∫) ‚Üí M)\n  (i : LinearIndependent R v), Cardinal.mk Œ∫ ‚â§ Cardinal.mk Œπ","name":"linearIndependent_le_infinite_basis","isProp":true,"docString":"An auxiliary lemma for `linearIndependent_le_basis`:\nwe handle the case where the basis `b` is infinite.\n"},{"type":"‚àÄ {G : Type u} {x : G} [inst : Monoid G], (0 < orderOf x : Prop) ‚Üî (IsOfFinOrder x : Prop)","name":"orderOf_pos_iff","isProp":true,"docString":"A group element has finite order iff its order is positive. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T3Space Œ±] {x : Œ±} {y : Œ±} (h : x ‚â† y),\n  ‚àÉ (U‚ÇÅ : Set Œ±),\n    (U‚ÇÅ ‚àà nhds x : Prop) ‚àß\n      (‚àÉ (V‚ÇÅ : Set Œ±),\n          (V‚ÇÅ ‚àà nhds x : Prop) ‚àß\n            (‚àÉ (U‚ÇÇ : Set Œ±),\n                (U‚ÇÇ ‚àà nhds y : Prop) ‚àß\n                  (‚àÉ (V‚ÇÇ : Set Œ±),\n                      (V‚ÇÇ ‚àà nhds y : Prop) ‚àß\n                        ((IsClosed V‚ÇÅ : Prop) ‚àß\n                            ((IsClosed V‚ÇÇ : Prop) ‚àß\n                                ((IsOpen U‚ÇÅ : Prop) ‚àß\n                                    ((IsOpen U‚ÇÇ : Prop) ‚àß\n                                        ((V‚ÇÅ ‚äÜ U‚ÇÅ : Prop) ‚àß ((V‚ÇÇ ‚äÜ U‚ÇÇ : Prop) ‚àß (Disjoint U‚ÇÅ U‚ÇÇ : Prop) : Prop) :\n                                          Prop) :\n                                      Prop) :\n                                  Prop) :\n                              Prop) :\n                          Prop) :\n                    Prop) :\n              Prop) :\n        Prop)","name":"disjoint_nested_nhds","isProp":true,"docString":"Given two points `x ‚â† y`, we can find neighbourhoods `x ‚àà V‚ÇÅ ‚äÜ U‚ÇÅ` and `y ‚àà V‚ÇÇ ‚äÜ U‚ÇÇ`,\nwith the `V‚Çñ` closed and the `U‚Çñ` open, such that the `U‚Çñ` are disjoint. "},{"type":"‚àÄ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f)","name":"ZeroHom.comp_assoc","isProp":true,"docString":"Composition of additive monoid homomorphisms is associative."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A + C) * Finset.card B ‚â§ Finset.card (A + B) * Finset.card (B + C)","name":"Finset.card_add_mul_card_le_card_add_mul_card_add","isProp":true,"docString":"**Ruzsa's triangle inequality**. Addition version."},{"type":"‚àÄ {F : PFunctor} {R : (a : PFunctor.M F) ‚Üí (a : PFunctor.M F) ‚Üí Prop} (self : PFunctor.M.IsBisimulation R)\n  {a : PFunctor.A F} {f : (a : PFunctor.B F a) ‚Üí PFunctor.M F} {f' : (a : PFunctor.B F a) ‚Üí PFunctor.M F}\n  (a_1 : R (PFunctor.M.mk { fst := a, snd := f }) (PFunctor.M.mk { fst := a, snd := f' })) (i : PFunctor.B F a),\n  R (f i) (f' i)","name":"PFunctor.M.IsBisimulation.tail","isProp":true,"docString":"The tails are equal "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] (n : ‚Ñï), ‚Üë(-1) = ‚Üën - 1","name":"ZMod.cast_neg_one","isProp":true,"docString":"`-1 : ZMod n` lifts to `n - 1 : R`. This avoids the characteristic assumption in `cast_neg`. "},{"type":"‚àÄ {I : Type u_1} {f : (a : I) ‚Üí Type u_2} [inst : Inhabited I] [inst_1 : ‚àÄ (i : I), Nonempty (f i)]\n  [inst : Nontrivial (f default)], Nontrivial ((i : I) ‚Üí f i)","name":"Pi.nontrivial","isProp":true,"docString":"As a convenience, provide an instance automatically if `(f default)` is nontrivial.\n\nIf a different index has the non-trivial type, then use `haveI := nontrivial_at that_index`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {e' : LocalEquiv Œ± Œ≤} (h : e ‚âà e'),\n  LocalEquiv.symm e ‚âà LocalEquiv.symm e'","name":"LocalEquiv.EqOnSource.symm'","isProp":true,"docString":"If two local equivs are equivalent, so are their inverses. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (IsNoetherian K V : Prop) ‚Üî (Module.rank K V < Cardinal.aleph0 : Prop)","name":"IsNoetherian.iff_rank_lt_aleph0","isProp":true,"docString":"A module over a division ring is noetherian if and only if\nits dimension (as a cardinal) is strictly less than the first infinite cardinal `‚Ñµ‚ÇÄ`.\n"},{"type":"‚àÄ (u : ‚Ñ§À£), u ^ 2 = 1","name":"Int.units_pow_two","isProp":true,"docString":"**Alias** of `Int.units_sq`."},{"type":"‚àÄ {R' : Type u_1} [inst : Semiring R'], SMulCommClass R' { x : R' // x ‚àà Subsemiring.center R' } R'","name":"Subsemiring.center.smulCommClass_right","isProp":true,"docString":"The center of a semiring acts commutatively on that semiring. "},{"type":"‚àÄ {G : Type u} [self : DivInvMonoid G] (a : G) (b : G), a / b = a * b‚Åª¬π","name":"DivInvMonoid.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {A : V} {B : V}\n  {C : V} {f : A ‚ü∂ B} [inst_2 : CategoryTheory.Limits.HasImage f] {g : B ‚ü∂ C}\n  [inst_3 : CategoryTheory.Limits.HasKernel g] (w : f ‚â´ g = 0) {A' : V} {B' : V} {C' : V} {f' : A' ‚ü∂ B'}\n  [inst_4 : CategoryTheory.Limits.HasImage f'] {g' : B' ‚ü∂ C'} [inst_5 : CategoryTheory.Limits.HasKernel g']\n  (w' : f' ‚â´ g' = 0) (Œ± : CategoryTheory.Arrow.mk f ‚ü∂ CategoryTheory.Arrow.mk f')\n  [inst_6 : CategoryTheory.Limits.HasImageMap Œ±] (Œ≤ : CategoryTheory.Arrow.mk g ‚ü∂ CategoryTheory.Arrow.mk g')\n  (p : CategoryTheory.CommaMorphism.right Œ± = CategoryTheory.CommaMorphism.left Œ≤),\n  imageToKernel f g w ‚â´ CategoryTheory.Limits.kernelSubobjectMap Œ≤ =\n    CategoryTheory.Limits.imageSubobjectMap Œ± ‚â´ imageToKernel f' g' w'","name":"imageSubobjectMap_comp_imageToKernel","isProp":true,"docString":"Given compatible commutative squares between\na pair `f g` and a pair `f' g'` satisfying `f ‚â´ g = 0` and `f' ‚â´ g' = 0`,\nthe `imageToKernel` morphisms intertwine the induced map on kernels and the induced map on images.\n"},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] (P : CategoryTheory.Idempotents.Karoubi C),\n  ùüô P = CategoryTheory.Idempotents.Karoubi.decompId_i P ‚â´ CategoryTheory.Idempotents.Karoubi.decompId_p P","name":"CategoryTheory.Idempotents.Karoubi.decompId","isProp":true,"docString":"The formal direct factor of `P.X` given by the idempotent `P.p` in the category `C`\nis actually a direct factor in the category `Karoubi C`. "},{"type":"‚àÄ {R : Type u} {Œπ : Type v} {M‚ÇÅ : (a : Œπ) ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] [inst_5 : (i : Œπ) ‚Üí TopologicalSpace (M‚ÇÅ i)] [inst_6 : TopologicalSpace M‚ÇÇ]\n  (self : ContinuousMultilinearMap R M‚ÇÅ M‚ÇÇ),\n  Continuous (MultilinearMap.toFun (ContinuousMultilinearMap.toMultilinearMap self))","name":"ContinuousMultilinearMap.cont","isProp":true,"docString":"Continuous multilinear maps over the ring `R`, from `‚àÄ i, M‚ÇÅ i` to `M‚ÇÇ` where `M‚ÇÅ i` and `M‚ÇÇ`\nare modules over `R` with a topological structure. In applications, there will be compatibility\nconditions between the algebraic and the topological structures, but this is not needed for the\ndefinition. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C)\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] {b : CategoryTheory.Limits.BinaryBicone X Y}\n  (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b),\n  CategoryTheory.Iso.inv\n      (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBicone.IsBilimit.isLimit hb)\n        (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)) =\n    CategoryTheory.Limits.biprod.desc (CategoryTheory.Limits.BinaryBicone.inl b)\n      (CategoryTheory.Limits.BinaryBicone.inr b)","name":"CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv","isProp":true,"docString":"Auxiliary lemma for `biprod.uniqueUpToIso`. "},{"type":"‚àÄ {k : Type u_2} {M : Type u_1} [inst : OrderedRing k] [inst_1 : OrderedAddCommGroup M] [inst_2 : Module k M]\n  [inst_3 : OrderedSMul k M]\n  [inst_4 : ContravariantClass M M (fun (x : M) (x_1 : M) ‚Ü¶ x + x_1) fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {a : k} {b : k}\n  {c : M} {d : M} (hab : a ‚â§ b) (hcd : c ‚â§ d), a ‚Ä¢ d + b ‚Ä¢ c ‚â§ a ‚Ä¢ c + b ‚Ä¢ d","name":"smul_add_smul_le_smul_add_smul","isProp":true,"docString":"Binary **rearrangement inequality**. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] [inst_1 : Preorder M] (L : List M) (h : List.sum L < 0), 0 < List.length L","name":"List.length_pos_of_sum_neg","isProp":true,"docString":"A list with negative sum must have positive length."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] [inst_2 : ‚àÄ (x : Œ±), Filter.NeBot (nhdsWithin x ({x}·∂ú))]\n  {s : Set Œ±} (hs : Dense s) (t : Finset Œ±), Dense (s \\ ‚Üët)","name":"Dense.diff_finset","isProp":true,"docString":"Removing a finset from a dense set in a space without isolated points, one still\nobtains a dense set. "},{"type":"‚àÄ (b : ‚Ñï) (m : ‚Ñï) (hb : 1 < b) (a : m ‚â† 0), b ^ List.length (Nat.digits b m) ‚â§ b * m","name":"Nat.base_pow_length_digits_le","isProp":true,"docString":"Any non-zero natural number `m` is greater than\nb^((number of digits in the base b representation of m) - 1)\n"},{"type":"‚àÄ {Œ± : Type u_1} {P : (a : Œ±) ‚Üí Prop}, Antitone fun (s : Set Œ±) ‚Ü¶ ‚àÄ (x : Œ±) (a : x ‚àà s), P x","name":"Set.antitone_bforall","isProp":true,"docString":"Quantifying over a set is antitone in the set "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsRingHom f) (x : Œ±) (y : Œ±),\n  f (x * y) = f x * f y","name":"IsRingHom.map_mul","isProp":true,"docString":"The proposition that `f` preserves multiplication. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  {u : (a : Œ≤) ‚Üí Œ±},\n  (CauchySeq u : Prop) ‚Üî (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0), ‚àÉ (N : Œ≤), ‚àÄ (n : Œ≤) (a : n ‚â• N), dist (u n) (u N) < Œµ : Prop)","name":"Metric.cauchySeq_iff'","isProp":true,"docString":"A variation around the pseudometric characterization of Cauchy sequences "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] (f : E ‚Üí‚Çó[ùïú] Œ≤) {s : Set E}\n  (hs : Convex ùïú s), ConcaveOn ùïú s ‚Üëf","name":"LinearMap.concaveOn","isProp":true,"docString":"A linear map is concave. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ¥ : Type u_3} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : T2Space Œ±] [inst_3 : CompleteLattice Œ≤] (m : (a : Œ≤) ‚Üí Œ±) (m0 : m ‚ä• = 0) (R : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop)\n  (m_sup·µ¢ : ‚àÄ (s : (a : ‚Ñï) ‚Üí Œ≤), R (m (sup·µ¢ fun (i : ‚Ñï) ‚Ü¶ s i)) (tsum fun (i : ‚Ñï) ‚Ü¶ m (s i))) (s : (a : Œ¥) ‚Üí Œ≤)\n  (t : Finset Œ¥), R (m (sup·µ¢ fun (d : Œ¥) ‚Ü¶ sup·µ¢ fun (h : d ‚àà t) ‚Ü¶ s d)) (Finset.sum t fun (d : Œ¥) ‚Ü¶ m (s d))","name":"rel_sup·µ¢_sum","isProp":true,"docString":"If a function is countably sub-additive then it is sub-additive on finite sets "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : NonUnitalNonAssocRing Œ±] [inst_2 : TopologicalRing Œ±] (x : Œ±),\n  Continuous ‚Üë(AddMonoidHom.mulRight x)","name":"mulRight_continuous","isProp":true,"docString":"In a topological semiring, the right-multiplication `AddMonoidHom` is continuous. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {B : Finset (Finset Œ±)} {n : ‚Ñï}\n  (h : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), n ‚â§ Finset.card (Finset.filter ((fun (x : Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚àà x_1) a) B)),\n  Finset.card s * n ‚â§ Finset.sum B fun (t : Finset Œ±) ‚Ü¶ Finset.card (s ‚à© t)","name":"Finset.le_sum_card_inter","isProp":true,"docString":"If every element belongs to at least `n` Finsets, then the sum of their sizes is at least `n`\ntimes how many they are. "},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel (SimpleGraph.Adj G)] (v : V),\n  SimpleGraph.degree G v ‚â§ SimpleGraph.maxDegree G","name":"SimpleGraph.degree_le_maxDegree","isProp":true,"docString":"The maximum degree in the graph is at least the degree of any particular vertex. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, IsClosed (frontier s)","name":"isClosed_frontier","isProp":true,"docString":"The frontier of a set is closed. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G], MulAction.IsPretransitive G G","name":"MulAction.Regular.isPretransitive","isProp":true,"docString":"The regular action of a group on itself is transitive. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsGroupHom f), IsMonoidHom f","name":"IsGroupHom.to_isMonoidHom","isProp":true,"docString":"A group homomorphism is a monoid homomorphism. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {x‚ÇÅ : R} {x‚ÇÇ : R} {y‚ÇÅ : R} {y‚ÇÇ : R} {n : R},\n  (x‚ÇÅ ^ 2 + n * x‚ÇÇ ^ 2) * (y‚ÇÅ ^ 2 + n * y‚ÇÇ ^ 2) = (x‚ÇÅ * y‚ÇÅ - n * x‚ÇÇ * y‚ÇÇ) ^ 2 + n * (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ) ^ 2","name":"sq_add_mul_sq_mul_sq_add_mul_sq","isProp":true,"docString":"Brahmagupta's identity, see <https://en.wikipedia.org/wiki/Brahmagupta%27s_identity>\n"},{"type":"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R) (J : Ideal R),\n  RingHom.ker (DoubleQuot.quotLeftToQuotSup I J) = Ideal.map (Ideal.Quotient.mk I) J","name":"DoubleQuot.ker_quotLeftToQuotSup","isProp":true,"docString":"The kernel of `quotLeftToQuotSup` "},{"type":"‚àÄ {c : ‚Ñù} (h1 : 0 < c) (h2 : c < 1 / 2), Function.Injective (Cardinal.cantorFunction c)","name":"Cardinal.cantorFunction_injective","isProp":true,"docString":"`cantorFunction c` is injective if `0 < c < 1/2`. "},{"type":"‚àÄ {R : Type u} {L : Type v} {M : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : LieRingModule L M] [self : LieModule R L M] (t : R) (x : L)\n  (m : M), ‚ÅÖt ‚Ä¢ x, m‚ÅÜ = t ‚Ä¢ ‚ÅÖx, m‚ÅÜ","name":"LieModule.smul_lie","isProp":true,"docString":"A Lie module bracket is compatible with scalar multiplication in its first argument. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R) {l : List R} (a : ‚àÄ (x : R) (a : x ‚àà l), x ‚àà s), List.prod l ‚àà s","name":"Subring.list_prod_mem","isProp":true,"docString":"Product of a list of elements in a subring is in the subring. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} {n : ‚Ñï} (a : Equiv.Perm.SameCycle f (‚Üë(f ^ n) x) y),\n  Equiv.Perm.SameCycle f x y","name":"Equiv.Perm.SameCycle.of_pow_left","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.sameCycle_pow_left`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T5Space Œ±], NormalSpace Œ±","name":"T5Space.toNormalSpace","isProp":true,"docString":"A `T‚ÇÖ` space is a `T‚ÇÑ` space. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : TopologicalSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±} {p : Filter Œπ},\n  (TendstoLocallyUniformly F f p : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0) (x : Œ≤),\n        ‚àÉ (t : Set Œ≤),\n          (t ‚àà nhds x : Prop) ‚àß\n            (Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (y : Œ≤) (a : y ‚àà t), dist (f y) (F n y) < Œµ) p : Prop) :\n      Prop)","name":"Metric.tendstoLocallyUniformly_iff","isProp":true,"docString":"Expressing locally uniform convergence using `dist`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {tas : Set (TopologicalSpace Œ±)}\n  {tbs : Set (TopologicalSpace Œ≤)} {ta : TopologicalSpace Œ±} {tb : TopologicalSpace Œ≤} {tc : TopologicalSpace Œ≥}\n  (ha : ta ‚àà tas) (hb : tb ‚àà tbs) (hf : Continuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)),\n  Continuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)","name":"continuous_inf‚Çõ_dom‚ÇÇ","isProp":true,"docString":"A version of `continuous_inf‚Çõ_dom` for binary functions "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_6} {V‚ÇÇ : Type u_4} {P‚ÇÇ : Type u_5} [inst_4 : AddCommGroup V‚ÇÇ]\n  [inst_5 : Module k V‚ÇÇ] [inst_6 : AddTorsor V‚ÇÇ P‚ÇÇ] {p : (a : Œπ) ‚Üí P} (f : P ‚Üí·µÉ[k] P‚ÇÇ) (hf : Function.Injective ‚Üëf),\n  (AffineIndependent k (‚Üëf ‚àò p) : Prop) ‚Üî (AffineIndependent k p : Prop)","name":"AffineMap.affineIndependent_iff","isProp":true,"docString":"Injective affine maps preserve affine independence. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (a : Œ±) (ùíú : Finset (Finset Œ±)),\n  Finset.card (Down.compression a ùíú) = Finset.card ùíú","name":"Down.card_compression","isProp":true,"docString":"Down-compressing a family doesn't change its size. "},{"type":"‚àÄ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a : K} {b : K} {c : K} (ha : a ‚â† 0) {s : K}\n  (h : discrim a b c = s * s) (x : K),\n  (a * x * x + b * x + c = 0 : Prop) ‚Üî ((x = (-b + s) / (2 * a) : Prop) ‚à® (x = (-b - s) / (2 * a) : Prop) : Prop)","name":"quadratic_eq_zero_iff","isProp":true,"docString":"Roots of a quadratic equation. "},{"type":"‚àÄ {V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ]\n  (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ) (g : NormedAddGroupHom V‚ÇÅ V‚ÇÇ), ‚Äñf + g‚Äñ ‚â§ ‚Äñf‚Äñ + ‚Äñg‚Äñ","name":"NormedAddGroupHom.opNorm_add_le","isProp":true,"docString":"The operator norm satisfies the triangle inequality. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {g : G} {H : Subgroup G} (a : g ‚àà H), Subgroup.zpowers g ‚â§ H","name":"Subgroup.zpowers_le_of_mem","isProp":true,"docString":"**Alias** of the reverse direction of `Subgroup.zpowers_le`."},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_2} {K : Type u_1} {M : Type u_3} {v : (a : Œπ) ‚Üí M} [inst : Semiring R]\n  [inst_1 : AddCommMonoid M] [inst_2 : Module R M] [inst_3 : Semiring K] [inst_4 : SMulWithZero R K]\n  [inst_5 : Module K M] [inst_6 : IsScalarTower R K M] (hinj : Function.Injective fun (r : R) ‚Ü¶ r ‚Ä¢ 1)\n  (li : LinearIndependent K v), LinearIndependent R v","name":"LinearIndependent.restrict_scalars","isProp":true,"docString":"A set of linearly independent vectors in a module `M` over a semiring `K` is also linearly\nindependent over a subring `R` of `K`.\nThe implementation uses minimal assumptions about the relationship between `R`, `K` and `M`.\nThe version where `K` is an `R`-algebra is `LinearIndependent.restrict_scalars_algebras`.\n "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {f : (a : Œ±) ‚Üí ‚Ñù} (K : NNReal)\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s), f x ‚â§ f y + ‚ÜëK * dist x y), LipschitzOnWith K f s","name":"LipschitzOnWith.of_le_add_mul","isProp":true,"docString":"For functions to `‚Ñù`, it suffices to prove `f x ‚â§ f y + K * dist x y`; this version\nassumes `0‚â§K`. "},{"type":"‚àÄ {n : ‚Ñï} {k : ‚Ñï} (a : n < k), Nat.descFactorial n k = 0","name":"Nat.descFactorial_of_lt","isProp":true,"docString":"**Alias** of the reverse direction of `Nat.descFactorial_eq_zero_iff_lt`."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsPreconnected J] {Œ± : Type u‚ÇÅ}\n  (F : J ‚•§ CategoryTheory.Discrete Œ±) (j : J) (j' : J),\n  Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) j = Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) j'","name":"CategoryTheory.any_functor_const_on_obj","isProp":true,"docString":"If J is connected, any functor to a discrete category is constant on objects.\nThe converse is given in `IsConnected.of_any_functor_const_on_obj`.\n"},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} {r : R} (h : SameRay R x y) (hr : 0 < r), SameRay R (r ‚Ä¢ x) y","name":"SameRay.pos_smul_left","isProp":true,"docString":"A positive multiple of a vector is in the same ray as one it is in the same ray as. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : AntitoneOn f s), MonotoneOn (‚ÜëOrderDual.toDual ‚àò f) s","name":"AntitoneOn.dual_right","isProp":true,"docString":"**Alias** of the reverse direction of `monotoneOn_toDual_comp_iff`."},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (L : List G) (i : ‚Ñï) (p : i < List.length L),\n  List.sum (List.drop (i + 1) L) = -List.nthLe L i p + List.sum (List.drop i L)","name":"List.sum_drop_succ","isProp":true,"docString":"Counterpart to `List.sum_take_succ` when we have an negation operation"},{"type":"‚àÄ {Œπ : Type u_1} {A : (a : Œπ) ‚Üí Type u_2} [inst : AddMonoid Œπ] [self : GradedMonoid.GMonoid A] (a : GradedMonoid A),\n  GradedMonoid.mk (0 ‚Ä¢ Sigma.fst a) (GradedMonoid.GMonoid.gnpow 0 (Sigma.snd a)) = 1","name":"GradedMonoid.GMonoid.gnpow_zero'","isProp":true,"docString":"The zeroth power will yield 1 "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {l : Filter Œ±} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} (self : Filter.HasBasis l p s)\n  (t : Set Œ±), (t ‚àà l : Prop) ‚Üî (‚àÉ (i : Œπ), (p i : Prop) ‚àß (s i ‚äÜ t : Prop) : Prop)","name":"Filter.HasBasis.mem_iff'","isProp":true,"docString":"A set `t` belongs to a filter `l` iff it includes an element of the basis. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (x : Œ± 0) (p : (i : Fin n) ‚Üí Œ± (Fin.succ i)) (z : Œ± 0),\n  Function.update (Fin.cons x p) 0 z = Fin.cons z p","name":"Fin.update_cons_zero","isProp":true,"docString":"Adding an element at the beginning of a tuple and then updating it amounts to adding it\ndirectly. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {n : ‚Ñ§} (hn : Even n) (h : n ‚â† 0) (a_1 : a ‚â† 0), 0 < a ^ n","name":"Even.zpow_pos","isProp":true,"docString":"**Alias** of the reverse direction of `Even.zpow_pos_iff`."},{"type":"‚àÄ {R : Type u} {M : Type v} {M‚ÇÇ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : Module R M] [inst_4 : Module R M‚ÇÇ] {f : (a : M) ‚Üí M‚ÇÇ} (self : IsLinearMap R f) (x : M) (y : M),\n  f (x + y) = f x + f y","name":"IsLinearMap.map_add","isProp":true,"docString":"A linear map preserves addition. "},{"type":"‚àÄ {Œπ : Type u} {Œ≥ : Type w} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] [inst : (i : Œπ) ‚Üí AddZeroClass (Œ≤ i)]\n  [inst_1 : AddCommMonoid Œ≥] (f : (i : Œπ) ‚Üí Œ≤ i ‚Üí+ Œ≥) (i : Œπ),\n  AddMonoidHom.comp (‚ÜëDfinsupp.liftAddHom f) (Dfinsupp.singleAddHom Œ≤ i) = f i","name":"Dfinsupp.liftAddHom_comp_single","isProp":true,"docString":"The `Dfinsupp` version of `Finsupp.liftAddHom_comp_single`,"},{"type":"‚àÄ (A : Type u_2) [inst : CommRing A] [inst_1 : IsDomain A] {K : Type u_1} [inst_2 : CommRing K] [inst_3 : Algebra A K]\n  [inst : IsFractionRing A K], IsDomain K","name":"IsFractionRing.isDomain","isProp":true,"docString":"A `CommRing` `K` which is the localization of an integral domain `R` at `R - {0}` is an\nintegral domain. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {x : (a : Œπ) ‚Üí Œ±} {f : Filter Œ±} {l : Filter Œπ} [inst : Filter.IsCountablyGenerated l]\n  (hxy :\n    ‚àÄ (ns : (a : ‚Ñï) ‚Üí Œπ) (a : Filter.Tendsto ns Filter.atTop l),\n      ‚àÉ (ms : (a : ‚Ñï) ‚Üí ‚Ñï), Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ x (ns (ms n))) Filter.atTop f),\n  Filter.Tendsto x l f","name":"Filter.tendsto_of_subseq_tendsto","isProp":true,"docString":"A sequence converges if every subsequence has a convergent subsequence. "},{"type":"‚àÄ {q : ‚Ñï+}, Fintype.card (LucasLehmer.X q) = ‚Üëq ^ 2","name":"LucasLehmer.X.card_eq","isProp":true,"docString":"The cardinality of `X` is `q^2`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Monoid Œ±] [self : MulAction Œ± Œ≤] (x : Œ±) (y : Œ±) (b : Œ≤),\n  (x * y) ‚Ä¢ b = x ‚Ä¢ y ‚Ä¢ b","name":"MulAction.mul_smul","isProp":true,"docString":"Associativity of `‚Ä¢` and `*` "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} [self : CategoryTheory.Epi f] {Z : C}\n  (g : Y ‚ü∂ Z) (h : Y ‚ü∂ Z) (a : f ‚â´ g = f ‚â´ h), g = h","name":"CategoryTheory.Epi.left_cancellation","isProp":true,"docString":"A morphism `f` is an epimorphism if it can be cancelled when precomposed. "},{"type":"‚àÄ {Œ± : Type u} [self : TopologicalSpace Œ±] (s : Set (Set Œ±)) (a : ‚àÄ (t : Set Œ±) (a : t ‚àà s), TopologicalSpace.IsOpen t),\n  TopologicalSpace.IsOpen (‚ãÉ‚ÇÄ s)","name":"TopologicalSpace.isOpen_union‚Çõ","isProp":true,"docString":"The union of a family of open sets is an open set. Use `isOpen_union‚Çõ` in the root namespace\ninstead. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_3} {E' : Type u_2} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : (fun (x : Œ±) ‚Ü¶ -f' x) =O[l] g), f' =O[l] g","name":"Asymptotics.IsBigO.of_neg_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigO_neg_left`."},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {Œπ : Type u_1} {t : Finset Œπ} {f : (a : Œπ) ‚Üí R}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà s), (Finset.sum t fun (i : Œπ) ‚Ü¶ f i) ‚àà s","name":"Subsemiring.sum_mem","isProp":true,"docString":"Sum of elements in an `Subsemiring` of an `Semiring` indexed by a `Finset`\nis in the `add_subsemiring`. "},{"type":"‚àÄ {M : Type u_2} [inst : Monoid M] {Œ≥ : Type u_1} [inst_1 : Monoid Œ≥] {f : (a : M) ‚Üí Œ≥} (hf : IsMonoidHom f) {s : Set M}\n  (hs : IsSubmonoid s), IsSubmonoid (f '' s)","name":"IsSubmonoid.image","isProp":true,"docString":"The image of a submonoid under a monoid hom is a submonoid of the codomain. "},{"type":"‚àÄ {X : Type u} {Y : Type u} (f : X ‚ü∂ Y), (CategoryTheory.IsIso f : Prop) ‚Üî (Function.Bijective f : Prop)","name":"CategoryTheory.isIso_iff_bijective","isProp":true,"docString":"A morphism in `Type u` is an isomorphism if and only if it is bijective. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (f : C(Œ±, Œ≤)) (x : Œ±),\n  ContinuousAt (‚Üëf) x","name":"ContinuousMap.continuousAt","isProp":true,"docString":"Deprecated. Use `map_continuousAt` instead. "},{"type":"‚àÄ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a : R) (b : R) (c : R),\n  a * (b + c) = a * b + a * c","name":"mul_add","isProp":true,"docString":"**Alias** of `left_distrib`."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : TypeVec n} {Œ≤ : TypeVec n} (f : TypeVec.Arrow Œ± Œ≤) (g : TypeVec.Arrow Œ± Œ≤)\n  (a : ‚àÄ (i : Fin2 n), f i = g i), f = g","name":"TypeVec.Arrow.ext","isProp":true,"docString":"Extensionality for arrows "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} (b : Basis Œπ R M) [inst_4 : Infinite Œπ] {Œ∫ : Type u_1} (v : (a : Œ∫) ‚Üí M)\n  (i : LinearIndependent R v) (m : LinearIndependent.Maximal i), Cardinal.mk Œ∫ = Cardinal.mk Œπ","name":"maximal_linearIndependent_eq_infinite_basis","isProp":true,"docString":"Over any ring `R` satisfying the strong rank condition,\nif `b` is an infinite basis for a module `M`,\nthen every maximal linearly independent set has the same cardinality as `b`.\n\nThis proof (along with some of the lemmas above) comes from\n[Les familles libres maximales d'un module ont-elles le meme cardinal?][lazarus1973]\n"},{"type":"‚àÄ {K : Type u} [inst : Field K] {S : Subfield K} {T : Subfield K} (h : ‚àÄ (x : K), (x ‚àà S : Prop) ‚Üî (x ‚àà T : Prop)),\n  S = T","name":"Subfield.ext","isProp":true,"docString":"Two subfields are equal if they have the same elements. "},{"type":"‚àÄ {M : Type u_2} [inst : AddZeroClass M] {Œπ : Sort u_1} (S : (a : Œπ) ‚Üí AddSubmonoid M) {C : (a : M) ‚Üí Prop} {x : M}\n  (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hp : ‚àÄ (i : Œπ) (x : M) (a : x ‚àà S i), C x) (h1 : C 0)\n  (hmul : ‚àÄ (x : M) (y : M) (a : C x) (a : C y), C (x + y)), C x","name":"AddSubmonoid.sup·µ¢_induction","isProp":true,"docString":"An induction principle for elements of `‚®Ü i, S i`.\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `S`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p1 : P} {p2 : P} (hp1 : p1 ‚àà s) (hp2 : p2 ‚àà s),\n  p1 -·µ• p2 ‚àà AffineSubspace.direction s","name":"AffineSubspace.vsub_mem_direction","isProp":true,"docString":"Subtracting two points in the subspace produces a vector in the direction. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : TopologicalAddGroup Œ±] {a : Œ±} {b : Œ±}\n  {f : (a : ‚Ñï) ‚Üí Œ±} {g : (a : ‚Ñï) ‚Üí Œ±} (hf : HasSum f a) (hg : HasSum g b), HasSum (Int.rec f g) (a + b)","name":"HasSum.int_rec","isProp":true,"docString":"If `f‚ÇÄ, f‚ÇÅ, f‚ÇÇ, ...` and `g‚ÇÄ, g‚ÇÅ, g‚ÇÇ, ...` are both convergent then so is the `‚Ñ§`-indexed\nsequence: `..., g‚ÇÇ, g‚ÇÅ, g‚ÇÄ, f‚ÇÄ, f‚ÇÅ, f‚ÇÇ, ...`. "},{"type":"‚àÄ {R : Type u_1} [inst : AddMonoidWithOne R] [self : CharZero R], Function.Injective Nat.cast","name":"CharZero.cast_injective","isProp":true,"docString":"An additive monoid with one has characteristic zero if the canonical map `‚Ñï ‚Üí R` is\ninjective. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {r : HomRel C} [self : CategoryTheory.Congruence r] {X : C} {Y : C}\n  {Z : C} {f : X ‚ü∂ Y} {f' : X ‚ü∂ Y} (g : Y ‚ü∂ Z) (a : r f f'), r (f ‚â´ g) (f' ‚â´ g)","name":"CategoryTheory.Congruence.compRight","isProp":true,"docString":"Postcomposition with an arrow respects `r`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {f' : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasImage f] [inst_2 : CategoryTheory.Limits.HasImage f']\n  [inst_3 : CategoryTheory.Limits.HasEqualizers C] (h : f = f'),\n  CategoryTheory.Limits.image.Œπ f =\n    CategoryTheory.Iso.hom (CategoryTheory.Limits.image.eqToIso h) ‚â´ CategoryTheory.Limits.image.Œπ f'","name":"CategoryTheory.Limits.image.eq_fac","isProp":true,"docString":"As long as the category has equalizers,\nthe image inclusion maps commute with `image.eqToIso`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Monoid Œ≤] {s : Finset Œ±} (f : (a : Œ±) ‚Üí Œ≤) (g : (a : Œ±) ‚Üí Œ≤)\n  (comm_ff : Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶ Commute (f x) (f y))\n  (comm_gg : Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶ Commute (g x) (g y))\n  (comm_gf : Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶ Commute (g x) (f y)),\n  Finset.noncommProd s (f * g)\n      ((Finset.noncommProd_mul_distrib_aux comm_ff comm_gg\n            comm_gf=:Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶\n            Commute ((f * g) x) ((f * g) y))=:Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶ Commute ((f * g) x) ((f * g) y)) =\n    Finset.noncommProd s f comm_ff * Finset.noncommProd s g comm_gg","name":"Finset.noncommProd_mul_distrib","isProp":true,"docString":"The non-commutative version of `Finset.prod_mul_distrib` "},{"type":"‚àÄ {u : (a : ‚Ñï) ‚Üí ‚Ñù} {l : ‚Ñù} (h : Filter.Tendsto u Filter.atTop (nhds l)),\n  Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ (‚Üën)‚Åª¬π * Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ u i) Filter.atTop (nhds l)","name":"Filter.Tendsto.cesaro","isProp":true,"docString":"The Cesaro average of a converging sequence converges to the same limit. "},{"type":"‚àÄ {R : Type u} {n : ‚Ñï} {M : (a : Fin (Nat.succ n)) ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Fin (Nat.succ n)) ‚Üí AddCommMonoid (M i)] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : (i : Fin (Nat.succ n)) ‚Üí Module R (M i)] [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M M‚ÇÇ)\n  (m : (i : Fin n) ‚Üí M (‚ÜëFin.castSucc i)) (c : R) (x : M (Fin.last n)), ‚Üëf (Fin.snoc m (c ‚Ä¢ x)) = c ‚Ä¢ ‚Üëf (Fin.snoc m x)","name":"MultilinearMap.snoc_smul","isProp":true,"docString":"In the specific case of multilinear maps on spaces indexed by `Fin (n+1)`, where one can build\nan element of `‚àÄ (i : Fin (n+1)), M i` using `cons`, one can express directly the multiplicativity\nof a multilinear map along the first variable. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddGroup Œ±] [inst_1 : AddCommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : IsAddGroupHom f) (hg : IsAddGroupHom g), IsAddGroupHom fun (a : Œ±) ‚Ü¶ f a - g a","name":"IsAddGroupHom.sub","isProp":true,"docString":"The difference of two additive group homomorphisms is an additive group\nhomomorphism if the target is commutative. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Add Œ±] {a : Œ±} (a_1 : Even a), ‚àÉ (b : Œ±), a = bit0 b","name":"Even.exists_bit0","isProp":true,"docString":"**Alias** of the forward direction of `even_iff_exists_bit0`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±} (h : IsClosed s),\n  (x ‚àà s : Prop) ‚Üî (EMetric.infEdist x s = 0 : Prop)","name":"EMetric.mem_iff_infEdist_zero_of_closed","isProp":true,"docString":"Given a closed set `s`, a point belongs to `s` iff its infimum edistance to this set vanishes "},{"type":"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {f : (a : ‚Ñï) ‚Üí R} {g : (a : ‚Ñï) ‚Üí R}\n  (hf : Summable fun (x : ‚Ñï) ‚Ü¶ ‚Äñf x‚Äñ) (hg : Summable fun (x : ‚Ñï) ‚Ü¶ ‚Äñg x‚Äñ),\n  ((tsum fun (n : ‚Ñï) ‚Ü¶ f n) * tsum fun (n : ‚Ñï) ‚Ü¶ g n) =\n    tsum fun (n : ‚Ñï) ‚Ü¶ Finset.sum (Finset.range (n + 1)) fun (k : ‚Ñï) ‚Ü¶ f k * g (n - k)","name":"tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm","isProp":true,"docString":"The Cauchy product formula for the product of two infinite sums indexed by `‚Ñï`,\nexpressed by summing on `Finset.range`.\nSee also `tsum_mul_tsum_eq_tsum_sum_range` if `f` and `g` are\n*not* absolutely summable. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : SeminormedAddCommGroup E] [inst_2 : NormedSpace ùïú E]\n  {x : E} {s : Set E} (hs : Metric.Bounded s) {u : Set E} (hu : u ‚àà nhds x),\n  Filter.Eventually (fun (r : ùïú) ‚Ü¶ {x} + r ‚Ä¢ s ‚äÜ u) (nhds 0)","name":"eventually_singleton_add_smul_subset","isProp":true,"docString":"If `s` is a bounded set, then for small enough `r`, the set `{x} + r ‚Ä¢ s` is contained in any\nfixed neighborhood of `x`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] {s : Set M} {S : AddSubmonoid M},\n  (AddSubmonoid.closure s ‚â§ S : Prop) ‚Üî (s ‚äÜ ‚ÜëS : Prop)","name":"AddSubmonoid.closure_le","isProp":true,"docString":"An additive submonoid `S` includes `closure s` if and only if it includes `s`"},{"type":"‚àÄ {M : Type u_1} {A : Type u_2} [inst : Zero A] [self : SMulZeroClass M A] (a : M), a ‚Ä¢ 0 = 0","name":"SMulZeroClass.smul_zero","isProp":true,"docString":"Multiplying `0` by a scalar gives `0` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : LocallyCompactSpace Œ±] [inst_3 : T2Space Œ±] [inst_4 : T2Space Œ≤] {Œπ : Type u_3} {l : Filter Œπ}\n  [inst_5 : Filter.NeBot l] (F : (a : Œπ) ‚Üí C(Œ±, Œ≤)),\n  (‚àÉ (f : C(Œ±, Œ≤)), Filter.Tendsto F l (nhds f) : Prop) ‚Üî\n    (‚àÄ (s : Set Œ±) (hs : IsCompact s),\n        ‚àÉ (f : C(‚Üës, Œ≤)), Filter.Tendsto (fun (i : Œπ) ‚Ü¶ ContinuousMap.restrict s (F i)) l (nhds f) :\n      Prop)","name":"ContinuousMap.exists_tendsto_compactOpen_iff_forall","isProp":true,"docString":"A family `F` of functions in `C(Œ±, Œ≤)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `Œ±`. "},{"type":"‚àÄ {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasImages V]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject V] [inst_3 : CategoryTheory.Preadditive V]\n  [inst_4 : CategoryTheory.Limits.HasKernels V] [inst_5 : CategoryTheory.Limits.HasCokernels V] {A : V} {B : V} {C : V}\n  (f : A ‚ü∂ B) (g : B ‚ü∂ C), (CategoryTheory.Exact f g : Prop) ‚Üî (‚àÉ (w : f ‚â´ g = 0), Nonempty (homology f g w ‚âÖ 0) : Prop)","name":"CategoryTheory.Preadditive.exact_iff_homology_zero","isProp":true,"docString":"In any preadditive category,\ncomposable morphisms `f g` are exact iff they compose to zero and the homology vanishes.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : PredOrder Œ±] {a : Œ±} (a_1 : ¬¨(IsMin a : Prop)), Order.pred a < a","name":"Order.pred_lt_of_not_isMin","isProp":true,"docString":"**Alias** of the reverse direction of `Order.pred_lt_iff_not_isMin`."},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {Œ± : Type u_3} [inst : VAdd M Œ±] [inst_1 : VAdd N Œ±] [self : VAddCommClass M N Œ±]\n  (m : M) (n : N) (a : Œ±), m +·µ• (n +·µ• a) = n +·µ• (m +·µ• a)","name":"VAddCommClass.vadd_comm","isProp":true,"docString":"`+·µ•` is left commutative "},{"type":"‚àÄ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D","name":"CategoryTheory.Idempotents.isIdempotentComplete_of_abelian","isProp":true,"docString":"An abelian category is idempotent complete. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (s : Set M) {p : (x : M) ‚Üí (a : x ‚àà AddSubsemigroup.closure s) ‚Üí Prop}\n  (Hs :\n    ‚àÄ (x : M) (h : x ‚àà s),\n      p x ((AddSubsemigroup.subset_closure h=:x ‚àà ‚Üë(AddSubsemigroup.closure s))=:x ‚àà ‚Üë(AddSubsemigroup.closure s)))\n  (Hmul :\n    ‚àÄ (x : M) (hx : x ‚àà AddSubsemigroup.closure s) (y : M) (hy : y ‚àà AddSubsemigroup.closure s) (a : p x hx)\n      (a : p y hy), p (x + y) ((add_mem hx hy=:x + y ‚àà AddSubsemigroup.closure s)=:x + y ‚àà AddSubsemigroup.closure s))\n  {x : M} (hx : x ‚àà AddSubsemigroup.closure s), p x hx","name":"AddSubsemigroup.closure_induction'","isProp":true,"docString":"A dependent version of `AddSubsemigroup.closure_induction`. "},{"type":"‚àÄ (Œ± : Type u) (Œ≤ : Type v) [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] [inst_2 : Fintype Œ±] [inst_3 : Fintype Œ≤]\n  [inst_4 : Fintype (Quotient (MulAction.orbitRel Œ± Œ≤))]\n  [inst_5 : (b : Œ≤) ‚Üí Fintype { x : Œ± // x ‚àà MulAction.stabilizer Œ± b }]\n  {œÜ : (a : Quotient (MulAction.orbitRel Œ± Œ≤)) ‚Üí Œ≤} (hœÜ : Function.LeftInverse Quotient.mk'' œÜ),\n  Fintype.card Œ≤ =\n    Finset.sum Finset.univ fun (œâ : Quotient (MulAction.orbitRel Œ± Œ≤)) ‚Ü¶\n      Fintype.card Œ± / Fintype.card { x : Œ± // x ‚àà MulAction.stabilizer Œ± (œÜ œâ) }","name":"MulAction.card_eq_sum_card_group_div_card_stabilizer'","isProp":true,"docString":"**Class formula** for a finite group acting on a finite type. See\n`MulAction.card_eq_sum_card_group_div_card_stabilizer` for a specialized version using\n`Quotient.out'`. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) {Œ± : (a : Œπ) ‚Üí Type u_1} (g : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí M‚ÇÅ i)\n  (A : (i : Œπ) ‚Üí Finset (Œ± i)) [inst_5 : DecidableEq Œπ] [inst_6 : Fintype Œπ] {n : ‚Ñï}\n  (h : (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ Finset.card (A i)) = n),\n  (‚Üëf fun (i : Œπ) ‚Ü¶ Finset.sum (A i) fun (j : Œ± i) ‚Ü¶ g i j) =\n    Finset.sum (Fintype.piFinset A) fun (r : (a : Œπ) ‚Üí Œ± a) ‚Ü¶ ‚Üëf fun (i : Œπ) ‚Ü¶ g i (r i)","name":"MultilinearMap.map_sum_finset_aux","isProp":true,"docString":"If `f` is multilinear, then `f (Œ£_{j‚ÇÅ ‚àà A‚ÇÅ} g‚ÇÅ j‚ÇÅ, ..., Œ£_{j‚Çô ‚àà A‚Çô} g‚Çô j‚Çô)` is the sum of\n`f (g‚ÇÅ (r 1), ..., g‚Çô (r n))` where `r` ranges over all functions with `r 1 ‚àà A‚ÇÅ`, ...,\n`r n ‚àà A‚Çô`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. Here, we give an auxiliary statement tailored for an inductive proof. Use instead\n`map_sum_finset`. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (self : Œ± ‚Ü™ Œ≤), Function.Injective (Function.Embedding.toFun self)","name":"Function.Embedding.inj'","isProp":true,"docString":"An embedding is an injective function. Use `Function.Embedding.injective` instead. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {H : Type u_2}\n  [inst_3 : Group H] [inst_4 : TopologicalSpace H] [inst_5 : TopologicalGroup H] (f : G ‚Üí* H) (emb : OpenEmbedding ‚Üëf),\n  NonarchimedeanGroup H","name":"NonarchimedeanGroup.nonarchimedean_of_emb","isProp":true,"docString":"If a topological group embeds into a nonarchimedean group, then it is nonarchimedean. "},{"type":"‚àÄ {G : Type u_2} {P : Type u_1} [inst : AddGroup G] [T : AddTorsor G P] (p : P), Function.Injective fun (x : P) ‚Ü¶ x -·µ• p","name":"vsub_left_injective","isProp":true,"docString":"Subtracting the point `p` is an injective function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A * C) * Finset.card B ‚â§ Finset.card (A / B) * Finset.card (B * C)","name":"Finset.card_mul_mul_le_card_div_mul_card_mul","isProp":true,"docString":"**Ruzsa's triangle inequality**. Mul-div-div version. "},{"type":"‚àÄ (œÉ : Type u_1) (R : Type u_2) [inst : CommSemiring R] [inst_1 : Fintype œÉ] (n : ‚Ñï),\n  MvPolynomial.esymm œÉ R n =\n    Finset.sum Finset.univ fun (t : { s : Finset œÉ // Finset.card s = n }) ‚Ü¶\n      Finset.prod ‚Üët fun (i : œÉ) ‚Ü¶ MvPolynomial.X i","name":"MvPolynomial.esymm_eq_sum_subtype","isProp":true,"docString":"We can define `esymm œÉ R n` by summing over a subtype instead of over `powerset_len`. "},{"type":"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (x : Œ±), Function.IsPeriodicPt id n x","name":"Function.is_periodic_id","isProp":true,"docString":"For the identity map, all points are periodic. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (S : Set Œ±) (f : Œ± ‚âÉ Œ≤), ‚Üëf '' S = ‚Üë(Equiv.symm f) ‚Åª¬π' S","name":"Set.image_equiv_eq_preimage_symm","isProp":true,"docString":"Alias for `Equiv.image_eq_preimage` "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (c : AddCon M), AddCon.ker (AddCon.mk' c) = c","name":"AddCon.mk'_ker","isProp":true,"docString":"The kernel of the natural homomorphism from an `AddMonoid` to its\nquotient by an additive congruence relation `c` equals `c`."},{"type":"‚àÄ {K : Type u} [self : Field K] (a : K) (b : K), a / b = a * b‚Åª¬π","name":"Field.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : NoMaxOrder Œ±]\n  [inst_4 : DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±},\n  (s ‚àà nhdsWithin a (Set.Ici a) : Prop) ‚Üî (‚àÉ (u : Œ±), (a < u : Prop) ‚àß (Set.Icc a u ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Ici_iff_exists_Icc_subset","isProp":true,"docString":"A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`\nwith `a < u`. "},{"type":"‚àÄ {Œπ : Type u} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] [inst : (i : Œπ) ‚Üí AddZeroClass (Œ≤ i)] {Œ≥ : Type w}\n  [inst_1 : AddZeroClass Œ≥] ‚¶Éf : (Dfinsupp fun (i : Œπ) ‚Ü¶ Œ≤ i) ‚Üí+ Œ≥‚¶Ñ ‚¶Ég : (Dfinsupp fun (i : Œπ) ‚Ü¶ Œ≤ i) ‚Üí+ Œ≥‚¶Ñ\n  (H : ‚àÄ (i : Œπ) (y : Œ≤ i), ‚Üëf (Dfinsupp.single i y) = ‚Üëg (Dfinsupp.single i y)), f = g","name":"Dfinsupp.addHom_ext","isProp":true,"docString":"If two additive homomorphisms from `Œ†‚ÇÄ i, Œ≤ i` are equal on each `single a b`, then\nthey are equal. "},{"type":"‚àÄ {a : Prop} {b : Prop} {c : Prop},\n  ((a : Prop) ‚à® ((b : Prop) ‚àß (c : Prop) : Prop) : Prop) ‚Üî\n    (((a : Prop) ‚à® (b : Prop) : Prop) ‚àß ((a : Prop) ‚à® (c : Prop) : Prop) : Prop)","name":"or_and_left","isProp":true,"docString":"`‚à®` distributes over `‚àß` (on the left). "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {s : Set E},\n  (Metric.Bounded (‚Üë(ClosureOperator.toOrderHom (convexHull ‚Ñù)) s) : Prop) ‚Üî (Metric.Bounded s : Prop)","name":"bounded_convexHull","isProp":true,"docString":"Convex hull of `s` is bounded if and only if `s` is bounded. "},{"type":"‚àÄ (m : ‚Ñï+) (p : Nat.Primes) (k : ‚Ñï), (Pow.pow (‚Üëp) k ‚à£ m : Prop) ‚Üî (k ‚â§ Multiset.count p (PNat.factorMultiset m) : Prop)","name":"PNat.count_factorMultiset","isProp":true,"docString":"The number of occurrences of p in the factor multiset of m\nis the same as the p-adic valuation of m. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±} {y : Œ±},\n  (Setoid.Rel (Setoid.ker f) x y : Prop) ‚Üî (x ‚àà f ‚Åª¬π' {f y} : Prop)","name":"Setoid.ker_iff_mem_preimage","isProp":true,"docString":"The elements related to x ‚àà Œ± by the kernel of f are those in the preimage of f(x) under f. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} [inst : CommMonoid Œ≤] (f : (a : Œ±) ‚Üí Œ≤) {p : (a : Œ±) ‚Üí Prop}\n  [inst_1 : DecidablePred p],\n  (Finset.prod (Finset.subtype p s) fun (x : Subtype p) ‚Ü¶ f ‚Üëx) = Finset.prod (Finset.filter p s) fun (x : Œ±) ‚Ü¶ f x","name":"Finset.prod_subtype_eq_prod_filter","isProp":true,"docString":"A product over `s.subtype p` equals one over `s.filter p`. "},{"type":"‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_3} {Œ≥ : Sort u_1} (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥) (P : Prop) [inst : Decidable (P : Prop)]\n  (a : (a : P) ‚Üí Œ±) (b : (a : ¬¨(P : Prop)) ‚Üí Œ±) (c : (a : P) ‚Üí Œ≤) (d : (a : ¬¨(P : Prop)) ‚Üí Œ≤),\n  f (dite (P : Prop) a b) (dite (P : Prop) c d) = if h : (P : Prop) then f (a h) (c h) else f (b h) (d h)","name":"apply_dite‚ÇÇ","isProp":true,"docString":"A two-argument function applied to two `dite`s is a `dite` of that two-argument function\napplied to each of the branches. "},{"type":"‚àÄ {Œ± : Type u} (s : Set (Set Œ±)),\n  (setOf fun (t : Set Œ±) ‚Ü¶ MeasurableSpace.GenerateMeasurable s t) =\n    Set.union·µ¢ fun (i : WellOrder.Œ± (Quotient.out (Cardinal.ord (Cardinal.aleph 1)))) ‚Ü¶\n      MeasurableSpace.generateMeasurableRec s i","name":"MeasurableSpace.generateMeasurable_eq_rec","isProp":true,"docString":"`generateMeasurableRec s` generates precisely the smallest sigma-algebra containing `s`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (a : Dense s), closure s = Set.univ","name":"Dense.closure_eq","isProp":true,"docString":"**Alias** of the forward direction of `dense_iff_closure_eq`."},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X], T0Space (Alexandroff X)","name":"Alexandroff.instT0SpaceAlexandroffInstTopologicalSpaceAlexandroff","isProp":true,"docString":"The one point compactification of a `T0Space` space is a `T0Space`. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : PosMulStrictMono Œ±]\n  (ha : 0 < a) (hb : 0 < b), 0 < a * b","name":"Left.mul_pos","isProp":true,"docString":"Assumes left covariance. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {J : Type u}\n  [inst_2 : CategoryTheory.Category J] (E : D ‚•§ C) [inst_3 : CategoryTheory.IsEquivalence E]\n  [inst : CategoryTheory.Limits.HasLimitsOfShape J C], CategoryTheory.Limits.HasLimitsOfShape J D","name":"CategoryTheory.Adjunction.hasLimitsOfShape_of_equivalence","isProp":true,"docString":"Transport a `HasLimitsOfShape` instance across an equivalence. "},{"type":"‚àÄ {p : ‚Ñï} {k : ‚Ñï} (hp : Nat.Prime p), Nat.factorization (p ^ k) = Finsupp.single p k","name":"Nat.Prime.factorization_pow","isProp":true,"docString":"For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` "},{"type":"‚àÄ {M : Type u_3} {N : Type u_4} {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : VAdd M Œ±] [inst_1 : VAdd Œ≤ Œ±]\n  [inst_2 : VAddCommClass Œ≤ M Œ±] (g : (a : N) ‚Üí M), VAddCommClass Œ≤ N Œ±","name":"VAdd.comp.vaddCommClass'","isProp":true,"docString":"This cannot be an instance because it can cause infinite loops wheneverthe `VAdd` arguments\nare still metavariables."},{"type":"‚àÄ {Œπ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {u : (a : Œπ) ‚Üí Set X} {s : Set X}\n  {c : Set (ShrinkingLemma.PartialRefinement u s)}\n  (hc :\n    IsChain (fun (x : ShrinkingLemma.PartialRefinement u s) (x_1 : ShrinkingLemma.PartialRefinement u s) ‚Ü¶ x ‚â§ x_1) c)\n  (ne : Set.Nonempty c) (hfin : ‚àÄ (x : X) (a : x ‚àà s), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ x ‚àà u i))\n  (hU : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ u i) {v : ShrinkingLemma.PartialRefinement u s} (hv : v ‚àà c),\n  v ‚â§ ShrinkingLemma.PartialRefinement.chainSup c hc ne hfin hU","name":"ShrinkingLemma.PartialRefinement.le_chainSup","isProp":true,"docString":"`chainSup hu c hc ne hfin hU` is an upper bound of the chain `c`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] {p : (a : M) ‚Üí Prop} (x : M) {s : Set M} (hs : AddSubmonoid.closure s = ‚ä§)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s), p x) (H1 : p 0) (Hmul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x + y)), p x","name":"AddSubmonoid.dense_induction","isProp":true,"docString":"If `s` is a dense set in an additive monoid `M`, `AddSubmonoid.closure s = ‚ä§`, then in\norder to prove that some predicate `p` holds for all `x : M` it suffices to verify `p x` for\n`x ‚àà s`, verify `p 0`, and verify that `p x` and `p y` imply `p (x + y)`."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {a : R} {b : R} [inst : SMul R M] [inst_1 : Mul R] [inst_2 : IsScalarTower R R M],\n  ((IsSMulRegular M (a * b) : Prop) ‚àß (IsSMulRegular M (b * a) : Prop) : Prop) ‚Üî\n    ((IsSMulRegular M a : Prop) ‚àß (IsSMulRegular M b : Prop) : Prop)","name":"IsSMulRegular.mul_and_mul_iff","isProp":true,"docString":"Two elements `a` and `b` are `M`-regular if and only if both products `a * b` and `b * a`\nare `M`-regular. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {a : Option Œ±} {b : Option Œ≤} {Œ¥ : Type u_1}\n  {Œ±' : Type u_2} {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ≤) ‚Üí (a : Œ±') ‚Üí Œ¥} {g' : (a : Œ±) ‚Üí Œ±'}\n  (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' b (g' a)),\n  Option.map g (Option.map‚ÇÇ f a b) = Option.map‚ÇÇ f' b (Option.map g' a)","name":"Option.map_map‚ÇÇ_antidistrib_right","isProp":true,"docString":"Symmetric statement to `Option.map_map‚ÇÇ_right_anticomm`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_4} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} {s : Finset Œπ} (p : (a : Œπ) ‚Üí P) (h : ‚Üë(Finset.card s) ‚â† 0),\n  Finset.centroid k s p ‚àà affineSpan k (Set.range p)","name":"centroid_mem_affineSpan_of_cast_card_ne_zero","isProp":true,"docString":"The centroid lies in the affine span if the number of points,\nconverted to `k`, is not zero. "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±}\n  (h : (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) ‚â† 1), ‚àÉ (x : Œ±), (x ‚àà s : Prop) ‚àß (f x ‚â† 1 : Prop)","name":"exists_ne_one_of_finprod_mem_ne_one","isProp":true,"docString":"If the product of `f i` over `i ‚àà s` is not equal to `1`, then there is some `x ‚àà s` such that\n`f x ‚â† 1`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (u : Œ±À£), ‚Üëu‚Åª¬π = 1 /‚Çö u","name":"inv_eq_one_divp","isProp":true,"docString":"Used for `field_simp` to deal with inverses of units. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] [self : CompactIccSpace Œ±] {a : Œ±} {b : Œ±},\n  IsCompact (Set.Icc a b)","name":"CompactIccSpace.isCompact_Icc","isProp":true,"docString":"A closed interval `Set.Icc a b` is a compact set for all `a` and `b`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : c ‚àà Set.uIcc a b),\n  abs (b - c) ‚â§ abs (b - a)","name":"Set.abs_sub_right_of_mem_uIcc","isProp":true,"docString":"If `x ‚àà [a, b]`, then the distance between `c` and `b` is less than or equal to\nthat of `a` and `b`  "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±},\n  (s ‚àà Finset.upShadow ùíú : Prop) ‚Üî\n    (‚àÉ (t : Finset Œ±), (t ‚àà ùíú : Prop) ‚àß ((t ‚äÜ s : Prop) ‚àß (Finset.card t + 1 = Finset.card s : Prop) : Prop) : Prop)","name":"Finset.mem_upShadow_iff_exists_mem_card_add_one","isProp":true,"docString":"`s ‚àà ‚àÇ‚Å∫ ùíú` iff `s` is exactly one element less than something from `ùíú`. "},{"type":"‚àÄ {Œ± : Type u_1} {l : Filter Œ±} [self : CountableInterFilter l] (S : Set (Set Œ±)) (a : Set.Countable S)\n  (a : ‚àÄ (s : Set Œ±) (a : s ‚àà S), s ‚àà l), ‚ãÇ‚ÇÄ S ‚àà l","name":"CountableInterFilter.countable_inter‚Çõ_mem","isProp":true,"docString":"For a countable collection of sets `s ‚àà l`, their intersection belongs to `l` as well. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {P : C} {Q : C}\n  (self : CategoryTheory.Limits.BinaryBicone P Q),\n  CategoryTheory.Limits.BinaryBicone.inr self ‚â´ CategoryTheory.Limits.BinaryBicone.fst self = 0","name":"CategoryTheory.Limits.BinaryBicone.inr_fst","isProp":true,"docString":"A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ‚â´ fst = ùüô P`, `inl ‚â´ snd = 0`, `inr ‚â´ fst = 0`, and `inr ‚â´ snd = ùüô Q`\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b) (a_2 : b ‚â§ a), a = b","name":"LE.le.antisymm","isProp":true,"docString":"**Alias** of `le_antisymm`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) {Z : C} (g : Y ‚ü∂ Z)\n  [inst_1 : CategoryTheory.Limits.HasEqualizers C] [inst_2 : CategoryTheory.Limits.HasImage g]\n  [inst_3 : CategoryTheory.Limits.HasImage (f ‚â´ g)] [inst_4 : CategoryTheory.Epi f],\n  CategoryTheory.Epi (CategoryTheory.Limits.image.preComp f g)","name":"CategoryTheory.Limits.image.preComp_epi_of_epi","isProp":true,"docString":"`image.preComp f g` is an epimorphism when `f` is an epimorphism\n(we need `C` to have equalizers to prove this).\n"},{"type":"‚àÄ {n : ‚Ñï} {a : Fin n} {b : Fin n}, (‚Üëa ‚â§ ‚Üëb : Prop) ‚Üî (a ‚â§ b : Prop)","name":"Fin.val_fin_le","isProp":true,"docString":"`a ‚â§ b` as natural numbers if and only if `a ‚â§ b` in `Fin n`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} (f : P ‚ü∂ Q) [inst_1 : CategoryTheory.IsIso f],\n  CategoryTheory.StrongMono f","name":"CategoryTheory.strongMono_of_isIso","isProp":true,"docString":"An isomorphism is in particular a strong monomorphism. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {a : Œ±} {f : (a : Œ±) ‚Üí Œ≤} [inst : CommMonoid Œ≤] [inst_1 : DecidableEq Œ±]\n  (h : f a = 1), (Finset.prod (insert a s) fun (x : Œ±) ‚Ü¶ f x) = Finset.prod s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.prod_insert_one","isProp":true,"docString":"The product of `f` over `insert a s` is the same as\nthe product over `s`, as long as `f a = 1`. "},{"type":"‚àÄ (k : Type u_1) [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ) [inst_1 : CharZero k] [inst_2 : Fintype Œπ]\n  (h : Finset.Nonempty s), (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ Finset.centroidWeightsIndicator k s i) = 1","name":"Finset.sum_centroidWeightsIndicator_eq_one_of_nonempty","isProp":true,"docString":"In the characteristic zero case, the weights in the centroid\nindexed by a `Fintype` sum to 1 if the set is nonempty. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  Nonempty (CategoryTheory.Component j)","name":"CategoryTheory.instNonemptyComponent","isProp":true,"docString":"Each connected component of the category is nonempty. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : UniformSpace Œ≤] {ùîñ : Set (Set Œ±)} [inst_1 : T2Space Œ≤] (h : ‚ãÉ‚ÇÄ ùîñ = Set.univ),\n  T2Space (UniformOnFun Œ± Œ≤ ùîñ)","name":"UniformOnFun.t2Space_of_covering","isProp":true,"docString":"If `ùîñ` covers `Œ±`, then the topology of `ùîñ`-convergence is T‚ÇÇ. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : sbtw a b c), ¬¨(btw c b a : Prop)","name":"SBtw.sbtw.not_btw","isProp":true,"docString":"**Alias** of `not_btw_of_sbtw`."},{"type":"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] {a : K} {b : K} {c : K} (h : ‚àÄ (x : K), 0 ‚â§ a * x * x + b * x + c),\n  discrim a b c ‚â§ 0","name":"discrim_le_zero","isProp":true,"docString":"If a polynomial of degree 2 is always nonnegative, then its discriminant is nonpositive "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddMonoid Œ≤] {s : Finset Œ±} (f : (a : Œ±) ‚Üí Œ≤) (g : (a : Œ±) ‚Üí Œ≤)\n  (comm_ff : Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶ AddCommute (f x) (f y))\n  (comm_gg : Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶ AddCommute (g x) (g y))\n  (comm_gf : Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶ AddCommute (g x) (f y)),\n  Finset.noncommSum s (f + g)\n      ((Finset.noncommSum_add_distrib_aux comm_ff comm_gg\n            comm_gf=:Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶\n            AddCommute ((f + g) x)\n              ((f + g) y))=:Set.Pairwise ‚Üës fun (x : Œ±) (y : Œ±) ‚Ü¶ AddCommute ((f + g) x) ((f + g) y)) =\n    Finset.noncommSum s f comm_ff + Finset.noncommSum s g comm_gg","name":"Finset.noncommSum_add_distrib","isProp":true,"docString":"The non-commutative version of `Finset.sum_add_distrib`"},{"type":"‚àÄ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : AddGroup G] [inst_1 : AddMonoid M]\n  [inst_2 : AddMonoidHomClass F G M] (f : F) (g : F) {x : G} (h : ‚Üëf x = ‚Üëg x), ‚Üëf (-x) = ‚Üëg (-x)","name":"eq_on_neg","isProp":true,"docString":"If two homomorphism from an additive group to an additive monoid are equal at `x`,\nthen they are equal at `-x`."},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_5} {Œ≥ : Type u_4} {Œ¥ : Type u_6} {Œµ : Type u_1} {Œ∂ : Type u_2} (f : (a : Œ±) ‚Üí Œ≤)\n  (f' : (a : Œ≥) ‚Üí Œ¥) (g : (a : Œ≤) ‚Üí Œµ) (g' : (a : Œ¥) ‚Üí Œ∂) (x : Œ± √ó Œ≥),\n  Prod.map g g' (Prod.map f f' x) = Prod.map (g ‚àò f) (g' ‚àò f') x","name":"Prod.map_map","isProp":true,"docString":"Composing a `Prod.map` with another `Prod.map` is equal to\na single `Prod.map` of composed functions, fully applied.\n"},{"type":"‚àÄ {ùïú : Type u_2} {Œ± : Type u_1} [inst : LinearOrderedField ùïú] {ùíú : Finset (Finset Œ±)} [inst_1 : Fintype Œ±]\n  (hùíú : IsAntichain (fun (x : Finset Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚äÜ x_1) ‚Üëùíú),\n  (Finset.sum (Finset.range (Fintype.card Œ± + 1)) fun (r : ‚Ñï) ‚Ü¶\n      ‚Üë(Finset.card (Finset.slice ùíú r)) / ‚Üë(Nat.choose (Fintype.card Œ±) r)) ‚â§\n    1","name":"Finset.sum_card_slice_div_choose_le_one","isProp":true,"docString":"The **Lubell-Yamamoto-Meshalkin inequality**. If `ùíú` is an antichain, then the sum of the\nproportion of elements it takes from each layer is less than `1`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} {Œ≥ : Type u_1} [inst : UniformSpace Œ≤] {ùîñ : Set (Set Œ±)} [inst_1 : UniformSpace Œ≥]\n  {f : (a : Œ≥) ‚Üí Œ≤} (hf : UniformContinuous f),\n  UniformContinuous\n    (‚Üë(UniformOnFun.ofFun ùîñ) ‚àò (fun (x : (a : Œ≥) ‚Üí Œ≤) (x_1 : (a : Œ±) ‚Üí Œ≥) ‚Ü¶ x ‚àò x_1) f ‚àò ‚Üë(UniformOnFun.toFun ùîñ))","name":"UniformOnFun.postcomp_uniformContinuous","isProp":true,"docString":"Post-composition by a uniformly continuous function is uniformly continuous for the\nuniform structures of `ùîñ`-convergence.\n\nMore precisely, if `f : Œ≥ ‚Üí Œ≤` is uniformly continuous, then\n`(Œª g, f ‚àò g) : (Œ± ‚Üí·µ§[ùîñ] Œ≥) ‚Üí (Œ± ‚Üí·µ§[ùîñ] Œ≤)` is uniformly continuous. "},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï} (h : 2 * n < p), ‚Üë(Nat.factorization (Nat.centralBinom n)) p = 0","name":"Nat.factorization_centralBinom_eq_zero_of_two_mul_lt","isProp":true,"docString":"If a prime `p` has positive multiplicity in the `n`th central binomial coefficient,\n`p` is no more than `2 * n` "},{"type":"‚àÄ {Œ± : Type u} {R : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} {l‚ÇÉ : List Œ±} (h‚ÇÅ : List.Chain' R (l‚ÇÅ ++ l‚ÇÇ))\n  (h‚ÇÇ : List.Chain' R (l‚ÇÇ ++ l‚ÇÉ)) (hn : l‚ÇÇ ‚â† []), List.Chain' R (l‚ÇÅ ++ l‚ÇÇ ++ l‚ÇÉ)","name":"List.Chain'.append_overlap","isProp":true,"docString":"If `l‚ÇÅ l‚ÇÇ` and `l‚ÇÉ` are lists and `l‚ÇÅ ++ l‚ÇÇ` and `l‚ÇÇ ++ l‚ÇÉ` both satisfy\n`Chain' R`, then so does `l‚ÇÅ ++ l‚ÇÇ ++ l‚ÇÉ` provided `l‚ÇÇ ‚â† []` "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\n  NonarchimedeanAddGroup (G √ó K)","name":"NonarchimedeanAddGroup.instNonarchimedeanAddGroupSumInstAddGroupSumInstTopologicalSpaceSum","isProp":true,"docString":"The cartesian product of two nonarchimedean groups is nonarchimedean."},{"type":"‚àÄ (R : Type u) [inst : CommSemiring R] {S : Type v} [inst_1 : Semiring S] [inst_2 : Algebra R S] (p : Polynomial S),\n  (p ‚àà Polynomial.lifts (algebraMap R S) : Prop) ‚Üî (p ‚àà AlgHom.range (Polynomial.mapAlg R S) : Prop)","name":"Polynomial.mem_lifts_iff_mem_alg","isProp":true,"docString":"A polynomial `p` lifts if and only if it is in the image of `mapAlg`. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R] [inst_1 : Nontrivial R], ¬¨(IsRegular 0 : Prop)","name":"not_isRegular_zero","isProp":true,"docString":"In a non-trivial ring, the element `0` is not regular -- with typeclasses. "},{"type":"‚àÄ {Œ± : Type u} (f : Filter Œ±) [h : Filter.NeBot f], ‚àÉ (u : Ultrafilter Œ±), ‚Üëu ‚â§ f","name":"Filter.exists_ultrafilter_le","isProp":true,"docString":"**Alias** of `Ultrafilter.exists_le`."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} (l : List Œ±) (c : Composition n),\n  List.length (List.splitWrtComposition l c) = Composition.length c","name":"List.length_splitWrtComposition","isProp":true,"docString":"When one splits a list along a composition `c`, the number of sublists thus created is\n`c.length`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : Semiring Œ±] [inst_1 : AddCommMonoid Œ≤] [inst_2 : Module Œ± Œ≤]\n  [inst_3 : NoZeroSMulDivisors Œ± Œ≤], NoZeroSMulDivisors Œ± ((a : Œπ) ‚Üí Œ≤)","name":"Function.noZeroSMulDivisors","isProp":true,"docString":"A special case of `Pi.noZeroSMulDivisors` for non-dependent types. Lean struggles to\nsynthesize this instance by itself elsewhere in the library. "},{"type":"‚àÄ {a : ‚Ñ§} {p : ‚Ñï} (pp : Nat.Prime p) (h : Int.gcd a ‚Üëp = 1), ‚Üëa ‚â† 0","name":"ZMod.ne_zero_of_gcd_eq_one","isProp":true,"docString":"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. "},{"type":"‚àÄ {P : Type u_1} [inst : SemilatticeInf P] {x : P} {y : P} {F : Order.PFilter P} (hx : x ‚àà F) (hy : y ‚àà F), x ‚äì y ‚àà F","name":"Order.PFilter.inf_mem","isProp":true,"docString":"A specific witness of `pfilter.directed` when `P` has meets. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) (pred : (a : Œπ) ‚Üí Prop)\n  [inst_3 : DecidablePred pred],\n  (‚Üë(Finset.weightedVSub (Finset.subtype pred s) fun (i : Subtype pred) ‚Ü¶ p ‚Üëi) fun (i : Subtype pred) ‚Ü¶ w ‚Üëi) =\n    ‚Üë(Finset.weightedVSub (Finset.filter pred s) p) w","name":"Finset.weightedVSub_subtype_eq_filter","isProp":true,"docString":"A weighted sum over `s.subtype pred` equals one over `s.filter pred`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n‚ÇÅ : ‚Ñï} {n‚ÇÇ : ‚Ñï} {n‚ÇÉ : ‚Ñï} (e‚ÇÅ‚ÇÇ : Fin (n‚ÇÅ + 1) ‚âÉ Fin (n‚ÇÇ + 1))\n  (e‚ÇÇ‚ÇÉ : Fin (n‚ÇÇ + 1) ‚âÉ Fin (n‚ÇÉ + 1)) (s : Affine.Simplex k P n‚ÇÅ),\n  Affine.Simplex.reindex s (Equiv.trans e‚ÇÅ‚ÇÇ e‚ÇÇ‚ÇÉ) = Affine.Simplex.reindex (Affine.Simplex.reindex s e‚ÇÅ‚ÇÇ) e‚ÇÇ‚ÇÉ","name":"Affine.Simplex.reindex_trans","isProp":true,"docString":"Reindexing by the composition of two equivalences is the same as reindexing twice. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : PolishSpace Œ±] {C : Set Œ±} (hC : IsClosed C)\n  (hunc : ¬¨(Set.Countable C : Prop)),\n  ‚àÉ (f : (a : (a : ‚Ñï) ‚Üí Bool) ‚Üí Œ±),\n    (Set.range f ‚äÜ C : Prop) ‚àß ((Continuous f : Prop) ‚àß (Function.Injective f : Prop) : Prop)","name":"IsClosed.exists_nat_bool_injection_of_not_countable","isProp":true,"docString":"Any closed uncountable subset of a Polish space admits a continuous injection\nfrom the Cantor space `‚Ñï ‚Üí Bool`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : LocallyFiniteOrderBot Œ±] (a : Œ±) (x : Œ±),\n  (x ‚àà LocallyFiniteOrderBot.finsetIic a : Prop) ‚Üî (x ‚â§ a : Prop)","name":"LocallyFiniteOrderBot.finset_mem_Iic","isProp":true,"docString":"`x ‚àà finsetIic a ‚Üî x ‚â§ a` "},{"type":"‚àÄ {n : ‚Ñï} (p : Fin (n + 1)) (i : Fin n) (h : p ‚â§ ‚ÜëFin.castSucc i), ‚Üë(Fin.succAbove p) i = Fin.succ i","name":"Fin.succAbove_above","isProp":true,"docString":"Embedding `i : Fin n` into `Fin (n + 1)` with a hole around `p : Fin (n + 1)`\nembeds `i` by `succ` when the resulting `p < i.succ`. "},{"type":"‚àÄ {R : Type u_3} [inst : Semiring R] {S : Type u_1} {F : Type u_2} [inst_1 : Semiring S]\n  [inst_2 : AddMonoidHomClass F (Polynomial R) (Polynomial S)] {œÜ : F} {p : Polynomial R} (k : ‚Ñï) (fu : (a : ‚Ñï) ‚Üí ‚Ñï)\n  (fu0 : ‚àÄ {n : ‚Ñï} (a : n ‚â§ k), fu n = 0) (fc : ‚àÄ {n : ‚Ñï} {m : ‚Ñï} (a : k ‚â§ n) (a : n < m), fu n < fu m)\n  (œÜ_k : ‚àÄ {f : Polynomial R} (a : Polynomial.natDegree f < k), ‚ÜëœÜ f = 0)\n  (œÜ_mon_nat : ‚àÄ (n : ‚Ñï) (c : R) (a : c ‚â† 0), Polynomial.natDegree (‚ÜëœÜ (‚Üë(Polynomial.monomial n) c)) = fu n),\n  Polynomial.natDegree (‚ÜëœÜ p) = fu (Polynomial.natDegree p)","name":"Polynomial.mono_map_natDegree_eq","isProp":true,"docString":"Let `œÜ : R[x] ‚Üí S[x]` be an additive map, `k : ‚Ñï` a bound, and `fu : ‚Ñï ‚Üí ‚Ñï` a\n\"sufficiently monotone\" map.  Assume also that\n* `œÜ` maps to `0` all monomials of degree less than `k`,\n* `œÜ` maps each monomial `m` in `R[x]` to a polynomial `œÜ m` of degree `fu (deg m)`.\nThen, `œÜ` maps each polynomial `p` in `R[x]` to a polynomial of degree `fu (deg p)`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [inst : Nonempty Œ±]\n  (h : ‚àÄ (c : Set Œ±) (a : IsChain r c) (a : Set.Nonempty c), ‚àÉ (ub : Œ±), ‚àÄ (a : Œ±) (a_1 : a ‚àà c), r a ub)\n  (trans : ‚àÄ {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : r a b) (a_2 : r b c), r a c), ‚àÉ (m : Œ±), ‚àÄ (a : Œ±) (a_1 : r m a), r a m","name":"exists_maximal_of_nonempty_chains_bounded","isProp":true,"docString":"A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\nthere is a maximal element.\n"},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} {x‚ÇÄ : X} (h : EquicontinuousAt F x‚ÇÄ) (i : Œπ), ContinuousAt (F i) x‚ÇÄ","name":"EquicontinuousAt.continuousAt","isProp":true,"docString":"Each function of a family equicontinuous at `x‚ÇÄ` is continuous at `x‚ÇÄ`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a < b), a ‚â† b","name":"LT.lt.ne","isProp":true,"docString":"**Alias** of `ne_of_lt`."},{"type":"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i1 : Œπ),\n  (AffineIndependent k p : Prop) ‚Üî (LinearIndependent k fun (i : { x : Œπ // x ‚â† i1 }) ‚Ü¶ p ‚Üëi -·µ• p i1 : Prop)","name":"affineIndependent_iff_linearIndependent_vsub","isProp":true,"docString":"A family is affinely independent if and only if the differences\nfrom a base point in that family are linearly independent. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\n  [inst_4 : NoZeroSMulDivisors K V] [h : Subsingleton V], FiniteDimensional.finrank K V = 0","name":"FiniteDimensional.finrank_zero_of_subsingleton","isProp":true,"docString":"A (finite dimensional) space that is a subsingleton has zero `finrank`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] {s : AddSubgroup E} (x : { x : E // x ‚àà s }), ‚Äñ‚Üëx‚Äñ = ‚Äñx‚Äñ","name":"AddSubgroup.norm_coe","isProp":true,"docString":"If `x` is an element of a subgroup `s` of a seminormed group `E`,\nits norm in `s` is equal to its norm in `E`.\n\nThis is a reversed version of the `simp` lemma `AddSubgroup.coe_norm` for use by `norm_cast`."},{"type":"‚àÄ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : (a : R) ‚Üí S}\n  [self : IsAbsoluteValue f] {x : R}, (f x = 0 : Prop) ‚Üî (x = 0 : Prop)","name":"IsAbsoluteValue.abv_eq_zero'","isProp":true,"docString":"The absolute value is positive definitive "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (I : Ideal R) (f : R ‚âÉ+* S),\n  Ideal.map (‚Üë(RingEquiv.symm f)) (Ideal.map (‚Üëf) I) = I","name":"Ideal.map_of_equiv","isProp":true,"docString":"If `f : R ‚âÉ+* S` is a ring isomorphism and `I : Ideal R`, then `map f (map f.symm) = I`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : NormedSpace ‚Ñù ùïú]\n  [inst_3 : Module ùïú E] [inst_4 : SMul ‚Ñù E] [inst_5 : IsScalarTower ‚Ñù ùïú E] (p : Seminorm ùïú E), ConvexOn ‚Ñù Set.univ ‚Üëp","name":"Seminorm.convexOn","isProp":true,"docString":"A seminorm is convex. Also see `convexOn_norm`. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} {l' : List Œ±} (f : ‚Ñï ‚Ü™o ‚Ñï) (hf : ‚àÄ (ix : ‚Ñï), List.get? l ix = List.get? l' (‚Üëf ix)),\n  List.Sublist l l'","name":"List.sublist_of_orderEmbedding_get?_eq","isProp":true,"docString":"If there is `f`, an order-preserving embedding of `‚Ñï` into `‚Ñï` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`,\nthen `Sublist l l'`.\n"},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R)\n  (s : { x : R // x ‚àà S }), r * ‚Üë(OreLocalization.oreDenom r s) = ‚Üës * OreLocalization.oreNum r s","name":"OreLocalization.ore_eq","isProp":true,"docString":"The Ore condition of a fraction, expressed in terms of `oreNum` and `oreDenom`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : AddCommMonoid M] [inst_1 : DecidableEq Œ±]\n  [inst_2 : DecidableEq Œ≤] (s : Finset (Œ± √ó Œ≤)) (f : (a : Œ± √ó Œ≤) ‚Üí M),\n  (finsum fun (ab : Œ± √ó Œ≤) ‚Ü¶ finsum fun (_h : ab ‚àà s) ‚Ü¶ f ab) =\n    finsum fun (a : Œ±) ‚Ü¶\n      finsum fun (b : Œ≤) ‚Ü¶\n        finsum fun (_h : b ‚àà Finset.image Prod.snd (Finset.filter (fun (ab : Œ± √ó Œ≤) ‚Ü¶ Prod.fst ab = a) s)) ‚Ü¶ f (a, b)","name":"finsum_mem_finset_product'","isProp":true,"docString":"Note that `b ‚àà (s.filter (fun ab => Prod.fst ab = a)).image Prod.snd` iff `(a, b) ‚àà s` so\nwe can simplify the right hand side of this lemma. However the form stated here is more\nuseful for iterating this lemma, e.g., if we have `f : Œ± √ó Œ≤ √ó Œ≥ ‚Üí M`."},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) (hf : ‚àÄ (Z : C) (g : Z ‚ü∂ X) (x : g ‚â´ f = 0), g = 0), CategoryTheory.Mono f","name":"CategoryTheory.NormalEpiCategory.mono_of_cancel_zero","isProp":true,"docString":"If `g ‚â´ f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. "},{"type":"‚àÄ {b : ‚Ñï} {m : ‚Ñï}, m < (b + 2) ^ List.length (Nat.digits (b + 2) m)","name":"Nat.lt_base_pow_length_digits'","isProp":true,"docString":"Any number m is less than (b+2)^(number of digits in the base b + 2 representation of m) "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ≤] [inst_1 : TopologicalSpace Œ≥]\n  [inst_2 : T2Space Œ≥] {f : (a : Œ±) ‚Üí Œ≤} (hfd : DenseRange f) {g : (a : Œ≤) ‚Üí Œ≥} {h : (a : Œ≤) ‚Üí Œ≥} (hg : Continuous g)\n  (hh : Continuous h) (H : g ‚àò f = h ‚àò f), g = h","name":"DenseRange.equalizer","isProp":true,"docString":"Two continuous functions to a t2-space that agree on the dense range of a function are equal. "},{"type":"‚àÄ {B : Type u_1} (F : Type u_3) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : (a : B) ‚Üí Type u_2)\n  [inst_2 : TopologicalSpace (Bundle.TotalSpace E)] [inst_3 : (b : B) ‚Üí TopologicalSpace (E b)]\n  [inst_4 : FiberBundle F E], Continuous Bundle.TotalSpace.proj","name":"FiberBundle.continuous_proj","isProp":true,"docString":"The projection from a fiber bundle to its base is continuous. "},{"type":"‚àÄ {k : Type u_2} {M : Type u_1} [inst : OrderedRing k] [inst_1 : OrderedAddCommGroup M] [inst_2 : Module k M]\n  [inst_3 : OrderedSMul k M]\n  [inst_4 : CovariantClass M M (fun (x : M) (x_1 : M) ‚Ü¶ x + x_1) fun (x : M) (x_1 : M) ‚Ü¶ x < x_1]\n  [inst_5 : ContravariantClass M M (fun (x : M) (x_1 : M) ‚Ü¶ x + x_1) fun (x : M) (x_1 : M) ‚Ü¶ x < x_1] {a : k} {b : k}\n  {c : M} {d : M} (hba : b < a) (hdc : d < c), a ‚Ä¢ d + b ‚Ä¢ c < a ‚Ä¢ c + b ‚Ä¢ d","name":"smul_add_smul_lt_smul_add_smul'","isProp":true,"docString":"Binary strict **rearrangement inequality**. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} {l : Filter Œ±} (a : s =·∂†[l] t),\n  Filter.Eventually (fun (x : Œ±) ‚Ü¶ (x ‚àà s : Prop) ‚Üî (x ‚àà t : Prop)) l","name":"Filter.EventuallyEq.mem_iff","isProp":true,"docString":"**Alias** of the forward direction of `Filter.eventuallyEq_set`."},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (v : M) {r : R} (h : 0 < r), SameRay R v (r ‚Ä¢ v)","name":"SameRay.sameRay_pos_smul_right","isProp":true,"docString":"A vector is in the same ray as a positive multiple of itself. "},{"type":"Cardinal.lift = Cardinal.lift","name":"Cardinal.lift_umax'","isProp":true,"docString":"`lift.{(max v u) u}` equals `lift.{v u}`. Using `set_option pp.universes true` will make it much\neasier to understand what's happening when using this lemma. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Countable Œ±], Countable (Multiset Œ±)","name":"Multiset.countable","isProp":true,"docString":"If `Œ±` is countable, then so is `Multiset Œ±`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {R : D ‚•§ C} (h : L ‚ä£ R) [inst_2 : CategoryTheory.IsIso (CategoryTheory.Adjunction.unit h)], CategoryTheory.Faithful L","name":"CategoryTheory.L_faithful_of_unit_isIso","isProp":true,"docString":"If the unit is an isomorphism, then the left adjoint is faithful"},{"type":"‚àÄ {k : Type u_4} {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_3} (s : Finset Œπ) (w‚ÇÅ : (a : Œπ) ‚Üí k) (w‚ÇÇ : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.weightedVSub s p) w‚ÇÅ +·µ• ‚Üë(Finset.affineCombination k s p) w‚ÇÇ = ‚Üë(Finset.affineCombination k s p) (w‚ÇÅ + w‚ÇÇ)","name":"Finset.weightedVSub_vadd_affineCombination","isProp":true,"docString":"Adding a `weightedVSub` to an `affineCombination`. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} {z : M} (hx : SameRay R x z) (hy : SameRay R y z), SameRay R (x + y) z","name":"SameRay.add_left","isProp":true,"docString":"If `x` and `y` are on the same ray as `z`, then so is `x + y`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T0Space Œ±] {s : Set Œ±} (hfin : Set.Finite s) (hne : Set.Nonempty s)\n  (ho : IsOpen s), ‚àÉ (x : Œ±), (x ‚àà s : Prop) ‚àß (IsOpen {x} : Prop)","name":"exists_open_singleton_of_open_finite","isProp":true,"docString":"Given an open finite set `S` in a T‚ÇÄ space, there is some `x ‚àà S` such that `{x}` is open. "},{"type":"‚àÄ {C : Type u} {A : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : AddMonoid A]\n  (self : CategoryTheory.ShiftMkCore C A) (n : A) (X : C),\n  (CategoryTheory.Iso.hom (CategoryTheory.ShiftMkCore.add self 0 n)).app X =\n    CategoryTheory.eqToHom\n        ((id\n              ((Eq.mpr\n                    ((id\n                          ((Eq.ndrec\n                                ((Eq.refl\n                                      (Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor\n                                              (CategoryTheory.ShiftMkCore.F self (0 + n)))\n                                            X =\n                                          Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                            X :\n                                        Prop)=:(Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor\n                                              (CategoryTheory.ShiftMkCore.F self (0 + n)))\n                                            X =\n                                          Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                            X :\n                                        Prop) =\n                                      (Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor\n                                              (CategoryTheory.ShiftMkCore.F self (0 + n)))\n                                            X =\n                                          Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                            X :\n                                        Prop))=:(Prefunctor.obj\n                                          (CategoryTheory.Functor.toPrefunctor\n                                            (CategoryTheory.ShiftMkCore.F self (0 + n)))\n                                          X =\n                                        Prefunctor.obj\n                                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                          X :\n                                      Prop) =\n                                    (Prefunctor.obj\n                                          (CategoryTheory.Functor.toPrefunctor\n                                            (CategoryTheory.ShiftMkCore.F self (0 + n)))\n                                          X =\n                                        Prefunctor.obj\n                                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                          X :\n                                      Prop))\n                                ((zero_add\n                                      n=:0 + n =\n                                      n)=:0 + n =\n                                    n)=:(Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (0 + n)))\n                                      X =\n                                    Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X :\n                                  Prop) =\n                                (Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                                    Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X :\n                                  Prop))=:(Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (0 + n)))\n                                    X =\n                                  Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X :\n                                Prop) =\n                              (Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                                  Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X :\n                                Prop))=:(Prefunctor.obj\n                                (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (0 + n))) X =\n                              Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                X :\n                            Prop) =\n                          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                X =\n                              Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                X :\n                            Prop))=:(Prefunctor.obj\n                              (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (0 + n))) X =\n                            Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                              X :\n                          Prop) =\n                        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                            Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                              X :\n                          Prop))\n                    ((Eq.refl\n                          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                            X)=:Prefunctor.obj\n                            (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                          Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                            X)=:Prefunctor.obj\n                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                          X)=:Prefunctor.obj\n                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (0 + n))) X =\n                    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                      X)=:Prefunctor.obj\n                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (0 + n))) X =\n                  Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                    X)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (0 + n)))\n                X =\n              Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (ùü≠ C))\n                  X))=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (0 + n)))\n              X =\n            Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n              (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (ùü≠ C)) X)) ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n        ((CategoryTheory.Iso.inv (CategoryTheory.ShiftMkCore.zero self)).app X)","name":"CategoryTheory.ShiftMkCore.zero_add_hom_app","isProp":true,"docString":"compatibility with the left addition with 0 "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {S : Type u_2} {F : Filter Œπ} [inst : Filter.NeBot F] [inst : CompleteLinearOrder R]\n  [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R] [inst_3 : CompleteLinearOrder S]\n  [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {f : (a : R) ‚Üí S} (f_decr : Antitone f) (a : (a : Œπ) ‚Üí R)\n  (f_cont : ContinuousAt f (Filter.limsup a F)), f (Filter.limsup a F) = Filter.liminf (f ‚àò a) F","name":"Antitone.map_limsup_of_continuousAt","isProp":true,"docString":"A continuous antitone function between complete linear ordered spaces sends a `Filter.limsup`\nto the `Filter.liminf` of the images. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelMonoidWithZero Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (ha : a ‚â† 0),\n  (a * b ‚à£ a * c : Prop) ‚Üî (b ‚à£ c : Prop)","name":"mul_dvd_mul_iff_left","isProp":true,"docString":"Given two elements `b`, `c` of a `CancelMonoidWithZero` and a nonzero element `a`,\n`a*b` divides `a*c` iff `b` divides `c`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C]\n  [inst_2 : CategoryTheory.WellPowered C], CategoryTheory.WellPowered C·µí·µñ","name":"CategoryTheory.Abelian.wellPowered_opposite","isProp":true,"docString":"A well-powered abelian category is also well-copowered. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)\n  [inst_1 : CategoryTheory.Limits.HasPullback f g], CategoryTheory.Limits.HasPullback g f","name":"CategoryTheory.Limits.hasPullback_symmetry","isProp":true,"docString":"Making this a global instance would make the typeclass seach go in an infinite loop. "},{"type":"‚àÄ {G : Type u} [self : DivisionCommMonoid G] (a : G) (b : G), a * b = b * a","name":"DivisionCommMonoid.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ (C : Type u_2) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C],\n  (CategoryTheory.IsIdempotentComplete C : Prop) ‚Üî\n    (‚àÄ (X : C) (p : X ‚ü∂ X) (a : p ‚â´ p = p), CategoryTheory.Limits.HasKernel p : Prop)","name":"CategoryTheory.Idempotents.isIdempotentComplete_iff_idempotents_have_kernels","isProp":true,"docString":"A preadditive category is pseudoabelian iff all idempotent endomorphisms have a kernel. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} {M : Type u_3} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} [inst_1 : Finite Œπ]\n  {t : (a : Œπ) ‚Üí Set Œ±} (h : Pairwise (Disjoint on t)) (ht : ‚àÄ (i : Œπ), Set.Finite (t i)),\n  (finprod fun (a : Œ±) ‚Ü¶ finprod fun (h : a ‚àà Set.union·µ¢ fun (i : Œπ) ‚Ü¶ t i) ‚Ü¶ f a) =\n    finprod fun (i : Œπ) ‚Ü¶ finprod fun (a : Œ±) ‚Ü¶ finprod fun (h : a ‚àà t i) ‚Ü¶ f a","name":"finprod_mem_union·µ¢","isProp":true,"docString":"Given a family of pairwise disjoint finite sets `t i` indexed by a finite type, the product of\n`f a` over the union `‚ãÉ i, t i` is equal to the product over all indexes `i` of the products of\n`f a` over `a ‚àà t i`. "},{"type":"‚àÄ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {Œπ : Type u_1} {g : (a : Œπ) ‚Üí Polynomial R}\n  {s : Finset Œπ} (hg : ‚àÄ (i : Œπ) (a : i ‚àà s), Polynomial.Monic (g i))\n  (hcop : Set.Pairwise ‚Üës fun (i : Œπ) (j : Œπ) ‚Ü¶ IsCoprime (g i) (g j)),\n  ‚àÉ (q : Polynomial R),\n    ‚àÉ (r : (a : Œπ) ‚Üí Polynomial R),\n      (‚àÄ (i : Œπ) (a : i ‚àà s), Polynomial.degree (r i) < Polynomial.degree (g i) : Prop) ‚àß\n        ((‚Üëf / Finset.prod s fun (i : Œπ) ‚Ü¶ ‚Üë(g i)) = ‚Üëq + Finset.sum s fun (i : Œπ) ‚Ü¶ ‚Üë(r i) / ‚Üë(g i) : Prop)","name":"div_eq_quo_add_sum_rem_div","isProp":true,"docString":"Let R be an integral domain and f ‚àà R[X]. Let s be a finite index set.\nThen, a fraction of the form f / ‚àè (g i) can be rewritten as q + ‚àë (r i) / (g i), where\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : SuccOrder Œ±] {a : Œ±} {b : Œ±} [inst_2 : NoMaxOrder Œ±]\n  (a_1 : Order.succ a < Order.succ b), a < b","name":"Order.lt_of_succ_lt_succ","isProp":true,"docString":"**Alias** of the forward direction of `Order.succ_lt_succ_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {Œ≤ : Type u_3} {S : (a : Œπ) ‚Üí Set Œ±} {f : (i : Œπ) ‚Üí (x : ‚Üë(S i)) ‚Üí Œ≤}\n  {hf :\n    ‚àÄ (i : Œπ) (j : Œπ) (x : Œ±) (hxi : x ‚àà S i) (hxj : x ‚àà S j),\n      f i { val := x, property := hxi } = f j { val := x, property := hxj }}\n  {T : Set Œ±} {hT : T ‚äÜ Set.union·µ¢ S} (hT' : T = Set.union·µ¢ S) (u : (a : ‚ÜëT) ‚Üí ‚ÜëT)\n  (ui : (i : Œπ) ‚Üí (a : ‚Üë(S i)) ‚Üí ‚Üë(S i))\n  (hui :\n    ‚àÄ (i : Œπ) (x : ‚Üë(S i)),\n      u\n          (Set.inclusion\n            (let_fun this : S i ‚äÜ T :=\n                ((Eq.rec\n                      ((Set.subset_union·µ¢ S i=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)\n                      ((Eq.symm hT'=:Set.union·µ¢ S = T)=:Set.union·µ¢ S = T)=:S i ‚äÜ T)=:S i ‚äÜ T);\n              this=:S i ‚äÜ T)\n            x) =\n        Set.inclusion\n          (let_fun this : S i ‚äÜ T :=\n              ((Eq.rec ((Set.subset_union·µ¢ S i=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:S i ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ S i)\n                    ((Eq.symm hT'=:Set.union·µ¢ S = T)=:Set.union·µ¢ S = T)=:S i ‚äÜ T)=:S i ‚äÜ T);\n            this=:S i ‚äÜ T)\n          (ui i x))\n  (uŒ≤ : (a : Œ≤) ‚Üí Œ≤) (h : ‚àÄ (i : Œπ) (x : ‚Üë(S i)), f i (ui i x) = uŒ≤ (f i x)) (x : ‚ÜëT),\n  Set.union·µ¢Lift S f hf T ((le_of_eq hT'=:T ‚â§ Set.union·µ¢ S)=:T ‚â§ Set.union·µ¢ S) (u x) =\n    uŒ≤ (Set.union·µ¢Lift S f hf T ((le_of_eq hT'=:T ‚â§ Set.union·µ¢ S)=:T ‚â§ Set.union·µ¢ S) x)","name":"Set.union·µ¢Lift_unary","isProp":true,"docString":"`union·µ¢Lift_unary` is useful for proving that `union·µ¢Lift` is a homomorphism\nof algebraic structures when defined on the Union of algebraic subobjects.\nFor example, it could be used to prove that the lift of a collection\nof linear_maps on a union of submodules preserves scalar multiplication. "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {F' : C ‚•§ D} (h : F ‚âÖ F') {Y : D} (hY : Y ‚àà CategoryTheory.Functor.essImage F), Y ‚àà CategoryTheory.Functor.essImage F'","name":"CategoryTheory.Functor.essImage.ofNatIso","isProp":true,"docString":"If `Y` is in the essential image of `F` then it is in the essential image of `F'` as long as\n`F ‚âÖ F'`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : Fintype Œ±] [inst_1 : Fintype Œ≤] [inst_2 : CommMonoid M]\n  (e : (a : Œ±) ‚Üí Œ≤) (he : Function.Bijective e) (f : (a : Œ±) ‚Üí M) (g : (a : Œ≤) ‚Üí M) (h : ‚àÄ (x : Œ±), f x = g (e x)),\n  (Finset.prod Finset.univ fun (x : Œ±) ‚Ü¶ f x) = Finset.prod Finset.univ fun (x : Œ≤) ‚Ü¶ g x","name":"Fintype.prod_bijective","isProp":true,"docString":"`Fintype.prod_bijective` is a variant of `Finset.prod_bij` that accepts `Function.bijective`.\n\nSee `Function.bijective.prod_comp` for a version without `h`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {T : D}\n  {S : C ‚•§ D} (f : CategoryTheory.CostructuredArrow S T),\n  f = CategoryTheory.CostructuredArrow.mk (CategoryTheory.Comma.hom f)","name":"CategoryTheory.CostructuredArrow.eq_mk","isProp":true,"docString":"Eta rule for costructured arrows. Prefer `CostructuredArrow.eta`, as equality of objects tends\nto cause problems. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P) (s1 : AffineSubspace k P) (s2 : AffineSubspace k P),\n  (p ‚àà s1 ‚äì s2 : Prop) ‚Üî ((p ‚àà s1 : Prop) ‚àß (p ‚àà s2 : Prop) : Prop)","name":"AffineSubspace.mem_inf_iff","isProp":true,"docString":"A point is in the inf of two affine subspaces if and only if it is in both of them. "},{"type":"‚àÄ {X : Type u_2} {Y : Type u_1} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : UniformSpace Œ±] {A : Set Y} {u : (a : Y) ‚Üí (a : X) ‚Üí Œ±} {x‚ÇÄ : X}\n  (hA : EquicontinuousAt (u ‚àò Subtype.val) x‚ÇÄ) (hu : Continuous u), EquicontinuousAt (u ‚àò Subtype.val) x‚ÇÄ","name":"EquicontinuousAt.closure'","isProp":true,"docString":"A version of `EquicontinuousAt.closure` applicable to subsets of types which embed continuously\ninto `X ‚Üí Œ±` with the product topology. It turns out we don't need any other condition on the\nembedding than continuity, but in practice this will mostly be applied to `fun_like` types where\nthe coercion is injective. "},{"type":"‚àÄ {K : Type u} {V : Type v} {V‚ÇÅ : Type v} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V‚ÇÅ] [inst_6 : Module K V‚ÇÅ]\n  [inst_7 : Module.Free K V‚ÇÅ], Module.rank K (V √ó V‚ÇÅ) = Module.rank K V + Module.rank K V‚ÇÅ","name":"rank_prod'","isProp":true,"docString":"If `M` and `N` are free (and lie in the same universe), the rank of `M √ó N` is\n`(Module.rank R M) + (Module.rank R N)`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M], IsAddSubmonoid Set.univ","name":"Univ.isAddSubmonoid","isProp":true,"docString":"An `AddMonoid` is an `AddSubmonoid` of itself."},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Inv Œ±] {s : Finset Œ±} (a : Finset.Nonempty s), Finset.Nonempty s‚Åª¬π","name":"Finset.Nonempty.inv","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.inv_nonempty_iff`."},{"type":"‚àÄ {Œì : Type u_1} [inst : Inhabited Œì] (l : Turing.ListBlank Œì),\n  ‚àÉ (a : Œì), ‚àÉ (l' : Turing.ListBlank Œì), l = Turing.ListBlank.cons a l'","name":"Turing.ListBlank.exists_cons","isProp":true,"docString":"The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `List` where\nthis only holds for nonempty lists. "},{"type":"‚àÄ {Œ± : Type u} [inst : OrderedRing Œ±] {a : Œ±} {b : Œ±} (hb : b ‚â§ 0) (h : 1 ‚â§ a), a * b ‚â§ b","name":"mul_le_of_one_le_left","isProp":true,"docString":"Variant of `le_mul_of_one_le_left` for `b` non-positive instead of non-negative. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (n : ‚Ñï) (a : Œ±),\n  LinearOrderedCommGroupWithZero.zpow (Int.ofNat (Nat.succ n)) a =\n    a * LinearOrderedCommGroupWithZero.zpow (Int.ofNat n) a","name":"LinearOrderedCommGroupWithZero.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type w}\n  [inst_3 : Finite Œπ] (h : Basis Œπ K V), FiniteDimensional K V","name":"FiniteDimensional.of_fintype_basis","isProp":true,"docString":"If a vector space has a finite basis, then it is finite-dimensional. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : CommMonoid Œ≤] {s : Finset Œ±} {t : Finset Œ≥} {f : (a : Œ±) ‚Üí Œ≤}\n  {g : (a : Œ≥) ‚Üí Œ≤} (i : (a : Œ±) ‚Üí (a : a ‚àà s) ‚Üí Œ≥) (hi : ‚àÄ (a : Œ±) (ha : a ‚àà s), i a ha ‚àà t)\n  (h : ‚àÄ (a : Œ±) (ha : a ‚àà s), f a = g (i a ha)) (j : (a : Œ≥) ‚Üí (a : a ‚àà t) ‚Üí Œ±)\n  (hj : ‚àÄ (a : Œ≥) (ha : a ‚àà t), j a ha ‚àà s)\n  (left_inv : ‚àÄ (a : Œ±) (ha : a ‚àà s), j (i a ha) ((hi a ha=:i a ha ‚àà t)=:i a ha ‚àà t) = a)\n  (right_inv : ‚àÄ (a : Œ≥) (ha : a ‚àà t), i (j a ha) ((hj a ha=:j a ha ‚àà s)=:j a ha ‚àà s) = a),\n  (Finset.prod s fun (x : Œ±) ‚Ü¶ f x) = Finset.prod t fun (x : Œ≥) ‚Ü¶ g x","name":"Finset.prod_bij'","isProp":true,"docString":"Reorder a product.\n\nThe difference with `prod_bij` is that the bijection is specified with an inverse, rather than\nas a surjective injection.\n"},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (p : ‚Ñï) [inst_1 : CharP R p] (I : Ideal R) (h : ‚àÄ (x : ‚Ñï) (a : ‚Üëx ‚àà I), ‚Üëx = 0),\n  CharP (R ‚ß∏ I) p","name":"CharP.quotient'","isProp":true,"docString":"If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\ninherits the characteristic of the underlying ring. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) {i : ‚Ñï} (hi : i < List.length L),\n  List.drop (List.sum (List.take i (List.map List.length L)))\n      (List.take (List.sum (List.take (i + 1) (List.map List.length L))) (List.join L)) =\n    List.nthLe L i hi","name":"List.drop_take_succ_join_eq_nthLe","isProp":true,"docString":"In a join of sublists, taking the slice between the indices `A` and `B - 1` gives back the\noriginal sublist of index `i` if `A` is the sum of the lenghts of sublists of index `< i`, and\n`B` is the sum of the lengths of sublists of index `‚â§ i`. "},{"type":"‚àÄ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A)\n  (y : A), r ‚Ä¢ x * y = r ‚Ä¢ (x * y)","name":"Algebra.smul_mul_assoc","isProp":true,"docString":"This is just a special case of the global `smul_mul_assoc` lemma that requires less typeclass\nsearch (and was here first). "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f x (‚Üëf‚Åª¬π y)), Equiv.Perm.SameCycle f x y","name":"Equiv.Perm.SameCycle.of_inv_apply_right","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.sameCycle_inv_apply_right`."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F}\n  {l : Filter Œ±} (a : f =o[l] g) ‚¶Éc : ‚Ñù‚¶Ñ (a : 0 < c), Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) l","name":"Asymptotics.IsLittleO.bound","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_iff`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  (p : Seminorm ùïú E) {r : ‚Ñù} (hr : 0 < r), Absorbent ùïú (Seminorm.ball p 0 r)","name":"Seminorm.absorbent_ball_zero","isProp":true,"docString":"Seminorm-balls at the origin are absorbent. "},{"type":"‚àÄ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {Œº : ‚Ñï},\n  SimpleGraph.IsSRGWith ‚ä§ (Fintype.card V) (Fintype.card V - 1) (Fintype.card V - 2) Œº","name":"SimpleGraph.IsSRGWith.top","isProp":true,"docString":"Complete graphs are strongly regular. Note that `Œº` can take any value\nfor complete graphs, since there are no distinct pairs of non-adjacent vertices. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {b : Set (Set Œ±)} (hb : TopologicalSpace.IsTopologicalBasis b) {s : Set Œ±},\n  (Dense s : Prop) ‚Üî (‚àÄ (o : Set Œ±) (a : o ‚àà b) (a : Set.Nonempty o), Set.Nonempty (o ‚à© s) : Prop)","name":"TopologicalSpace.IsTopologicalBasis.dense_iff","isProp":true,"docString":"A set is dense iff it has non-trivial intersection with all basis sets. "},{"type":"‚àÄ (R : Type u) (M : Type v) [inst : Monoid R] [inst_1 : AddCommGroup M] [inst_2 : DistribMulAction R M]\n  [inst_3 : UniformSpace M] [inst_4 : UniformAddGroup M] [inst_5 : ContinuousConstSMul R M],\n  UniformContinuousConstSMul R M","name":"uniformContinuousConstSMul_of_continuousConstSMul","isProp":true,"docString":"A `DistribMulAction` that is continuous on a uniform group is uniformly continuous.\nThis can't be an instance due to it forming a loop with\n`UniformContinuousConstSMul.to_continuousConstSMul` "},{"type":"‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} (h : Function.Commute f g), Function.Semiconj f g g","name":"Function.Commute.semiconj","isProp":true,"docString":"Reinterpret `Function.Commute f g` as `Function.Semiconj f g g`. These two predicates are\ndefinitionally equal but have different dot-notation lemmas. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonAssocRing Œ±], NatCast.natCast 0 = 0","name":"NonAssocRing.natCast_zero","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` sends `0 : ‚Ñï` to `0 : R`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {R : CategoryTheory.Sieve X}\n  (J : CategoryTheory.GrothendieckTopology C) (Hss : S ‚â§ R) (sjx : S ‚àà CategoryTheory.GrothendieckTopology.sieves J X),\n  R ‚àà CategoryTheory.GrothendieckTopology.sieves J X","name":"CategoryTheory.GrothendieckTopology.superset_covering","isProp":true,"docString":"If `S` is a subset of `R`, and `S` is covering, then `R` is covering as well.\n\nSee <https://stacks.math.columbia.edu/tag/00Z5> (2), or discussion after [MM92] Chapter III,\nSection 2, Definition 1.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Monotone f)\n  (h : ‚àÄ (b : Œ≤), ‚àÉ (a : Œ±), f a ‚â§ b), Filter.Tendsto f Filter.atBot Filter.atBot","name":"Monotone.tendsto_atBot_atBot","isProp":true,"docString":"**Alias** of `Filter.tendsto_atBot_atBot_of_monotone`."},{"type":"‚àÄ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B] (e : A ‚âÉ+* B),\n  NoZeroDivisors A","name":"RingEquiv.noZeroDivisors","isProp":true,"docString":"If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : OrderedRing ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : AddCommGroup F] [inst_3 : Module ùïú E] [inst_4 : Module ùïú F] (f : E ‚Üí·µÉ[ùïú] F) {s : Set F} (hs : Convex ùïú s),\n  Convex ùïú (‚Üëf ‚Åª¬π' s)","name":"Convex.affine_preimage","isProp":true,"docString":"The preimage of a convex set under an affine map is convex. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±}, (Equicontinuous F : Prop) ‚Üî (Equicontinuous Subtype.val : Prop)","name":"equicontinuous_iff_range","isProp":true,"docString":"A family `ùìï : Œπ ‚Üí X ‚Üí Œ±` is equicontinuous iff `range ùìï` is equicontinuous,\ni.e the family `(‚Üë) : range F ‚Üí X ‚Üí Œ±` is equicontinuous. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_4} {P : Type u_5} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_2} {Œπ2 : Type u_1} (f : Œπ2 ‚Ü™ Œπ) {p : (a : Œπ) ‚Üí P} (ha : AffineIndependent k p),\n  AffineIndependent k (p ‚àò ‚Üëf)","name":"AffineIndependent.comp_embedding","isProp":true,"docString":"If a family is affinely independent, so is any subfamily given by\ncomposition of an embedding into index type with the original\nfamily. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R] (h : IsRegular 0), Subsingleton R","name":"IsRegular.subsingleton","isProp":true,"docString":"The element `0` is regular if and only if `R` is trivial. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {s : Set Œ±} {t : Set Œ≤}\n  (a :\n    LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à© ‚Üë(LocalHomeomorph.symm e) ‚Åª¬π' s =\n      LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à© t),\n  LocalHomeomorph.IsImage e s t","name":"LocalHomeomorph.IsImage.of_symm_preimage_eq","isProp":true,"docString":"**Alias** of the reverse direction of `LocalHomeomorph.IsImage.iff_symm_preimage_eq`."},{"type":"‚àÄ {R : Type u_1} {ùïú : Type u_2} [inst : NonUnitalNonAssocRing R] [inst_1 : LinearOrderedField ùïú]\n  [inst_2 : TopologicalSpace R] [inst_3 : TopologicalAddGroup R] (norm : (a : R) ‚Üí ùïú)\n  (norm_nonneg : ‚àÄ (x : R), 0 ‚â§ norm x) (norm_mul_le : ‚àÄ (x : R) (y : R), norm (x * y) ‚â§ norm x * norm y)\n  (nhds_basis : Filter.HasBasis (nhds 0) (fun (x : ùïú) ‚Ü¶ 0 < x) fun (Œµ : ùïú) ‚Ü¶ setOf fun (x : R) ‚Ü¶ norm x < Œµ),\n  TopologicalRing R","name":"TopologicalRing.of_norm","isProp":true,"docString":"If a (possibly non-unital and/or non-associative) ring `R` admits a submultiplicative\nnonnegative norm `norm : R ‚Üí ùïú`, where `ùïú` is a linear ordered field, and the open balls\n`{ x | norm x < Œµ }`, `Œµ > 0`, form a basis of neighborhoods of zero, then `R` is a topological\nring. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (e : C ‚âå D),\n  (CategoryTheory.WellPowered C : Prop) ‚Üî (CategoryTheory.WellPowered D : Prop)","name":"CategoryTheory.wellPowered_congr","isProp":true,"docString":"Being well-powered is preserved by equivalences, as long as the two categories involved have\ntheir morphisms in the same universe. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} {R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R)\n  [inst_1 : CategoryTheory.StrongMono (f ‚â´ g)], CategoryTheory.StrongMono f","name":"CategoryTheory.strongMono_of_strongMono","isProp":true,"docString":"If `f ‚â´ g` is a strong monomorphism, then so is `f`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Group Œ±] {s : Set Œ±} {t : Set Œ±} (a : Disjoint s t), ¬¨(1 ‚àà s / t : Prop)","name":"Disjoint.one_not_mem_div_set","isProp":true,"docString":"**Alias** of the reverse direction of `Set.not_one_mem_div_iff`."},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {A : Type v} [inst_1 : Semiring A] [inst_2 : Algebra R A] (M : Submodule R A)\n  {C : (a : A) ‚Üí Prop} (hr : ‚àÄ (r : R), C (‚Üë(algebraMap R A) r))\n  (hadd : ‚àÄ (x : A) (y : A) (a : C x) (a : C y), C (x + y)) (hmul : ‚àÄ (m : A) (a : m ‚àà M) (x : A) (a : C x), C (m * x))\n  {x : A} {n : ‚Ñï} (hx : x ‚àà M ^ n), C x","name":"Submodule.pow_induction_on_left","isProp":true,"docString":"To show a property on elements of `M ^ n` holds, it suffices to show that it holds for scalars,\nis closed under addition, and holds for `m * x` where `m ‚àà M` and it holds for `x` "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : OrderedSemiring ùïú] [inst_1 : TopologicalSpace E] [inst_2 : AddCommMonoid E]\n  [inst_3 : Module ùïú E] {s : Set E} (h : IsOpen s) (hs : Convex ùïú s), StrictConvex ùïú s","name":"Convex.strictConvex_of_open","isProp":true,"docString":"An open convex set is strictly convex. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥) {x : Œ±} {x' : Œ±} {y : Œ≤} {y' : Œ≤}\n  (hx : x = x') (hy : y = y'), f x y = f x' y'","name":"congr_arg‚ÇÇ","isProp":true,"docString":"**Alias** of `congrArg‚ÇÇ`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Semiring Œ±] [inst_1 : Semiring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsSemiringHom f),\n  IsMonoidHom f","name":"IsSemiringHom.to_isMonoidHom","isProp":true,"docString":"A semiring homomorphism is a monoid homomorphism. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C]\n  [inst_2 : CategoryTheory.Limits.HasCoequalizers C], CategoryTheory.Limits.HasPushouts C","name":"CategoryTheory.Limits.hasPushouts_of_hasBinaryCoproducts_of_hasCoequalizers","isProp":true,"docString":"If a category has all binary coproducts and all coequalizers, then it also has all pushouts.\nAs usual, this is not an instance, since there may be a more direct way to construct\npushouts. "},{"type":"‚àÄ {Œ± : Type u_1} {m : Type u_2} {R : Type v} [inst : CommRing R] {M : Matrix m m R} {b : (a : m) ‚Üí Œ±}\n  [inst_1 : DecidableEq m] [inst_2 : Fintype m] [inst_3 : LinearOrder Œ±] [inst_4 : Invertible M]\n  (hM : Matrix.BlockTriangular M b) (k : Œ±),\n  (Matrix.toBlock M (fun (i : m) ‚Ü¶ b i < k) fun (i : m) ‚Ü¶ b i < k)‚Åª¬π =\n    Matrix.toBlock M‚Åª¬π (fun (i : m) ‚Ü¶ b i < k) fun (i : m) ‚Ü¶ b i < k","name":"Matrix.BlockTriangular.inv_toBlock","isProp":true,"docString":"The inverse of an upper-left subblock of a block-triangular matrix `M` is the upper-left\nsubblock of `M‚Åª¬π`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {J : Type w}\n  [inst_2 : CategoryTheory.Category J] (K : J ‚•§ C) (F : C ‚•§ D) [inst_3 : CategoryTheory.Limits.HasColimit (K ‚ãô F)]\n  [inst_4 : CategoryTheory.CreatesColimit K F], CategoryTheory.Limits.HasColimit K","name":"CategoryTheory.hasColimit_of_created","isProp":true,"docString":"If `F` creates the limit of `K` and `K ‚ãô F` has a limit, then `K` has a limit. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M],\n  (AddMonoid.Fg M : Prop) ‚Üî (‚àÉ (S : Set M), (AddSubmonoid.closure S = ‚ä§ : Prop) ‚àß (Set.Finite S : Prop) : Prop)","name":"AddMonoid.fg_iff","isProp":true,"docString":"An equivalent expression of `AddMonoid.Fg` in terms of `Set.Finite` instead of `Finset`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {l' : Œ±}\n  {s : Set Œ±} (hl' : l' < a),\n  (s ‚àà nhdsWithin a (Set.Iic a) : Prop) ‚Üî (‚àÉ (l : Œ±), (l ‚àà Set.Iio a : Prop) ‚àß (Set.Ioc l a ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Iic_iff_exists_Ioc_subset'","isProp":true,"docString":"A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`\nwith `l < a`, provided `a` is not a bottom element. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_1} (e : Œ± ‚âÉ Œ≤), Equiv.optionCongr e = EquivFunctor.mapEquiv Option e","name":"Equiv.optionCongr_eq_equivFunctor_mapEquiv","isProp":true,"docString":"When `Œ±` and `Œ≤` are in the same universe, this is the same as the result of\n`EquivFunctor.mapEquiv`. "},{"type":"‚àÄ (C : Type u_1) [inst : CategoryTheory.Category C],\n  (CategoryTheory.IsIdempotentComplete C : Prop) ‚Üî\n    (‚àÄ (X : C) (p : X ‚ü∂ X) (a : p ‚â´ p = p), CategoryTheory.Limits.HasEqualizer (ùüô X) p : Prop)","name":"CategoryTheory.Idempotents.isIdempotentComplete_iff_hasEqualizer_of_id_and_idempotent","isProp":true,"docString":"A category is idempotent complete iff for all idempotent endomorphisms,\nthe equalizer of the identity and this idempotent exists. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : SeminormedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  (p : Seminorm ùïú E) (r : ‚Ñù), Balanced ùïú (Seminorm.closedBall p 0 r)","name":"Seminorm.balanced_closedBall_zero","isProp":true,"docString":"Closed seminorm-balls at the origin are balanced. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (a_1 : IsMaxOn f s a),\n  IsMinOn (‚ÜëOrderDual.toDual ‚àò f) s a","name":"IsMaxOn.dual","isProp":true,"docString":"**Alias** of the reverse direction of `isMinOn_dual_iff`."},{"type":"‚àÄ {R : Type u} [inst : Ring R] {s : Set R} {t : Subring R}, (Subring.closure s ‚â§ t : Prop) ‚Üî (s ‚äÜ ‚Üët : Prop)","name":"Subring.closure_le","isProp":true,"docString":"A subring `t` includes `closure s` if and only if it includes `s`. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : Set P) (t : Set P), affineSpan k (s ‚à™ t) = affineSpan k s ‚äî affineSpan k t","name":"AffineSubspace.span_union","isProp":true,"docString":"The span of a union of sets is the sup of their spans. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P}, (p‚ÇÅ ‚àà affineSpan k {p‚ÇÇ} : Prop) ‚Üî (p‚ÇÅ = p‚ÇÇ : Prop)","name":"AffineSubspace.mem_affineSpan_singleton","isProp":true,"docString":"A point is in the affine span of a single point if and only if they are equal. "},{"type":"‚àÄ {p : ‚Ñù} (a : p ‚â§ 0), ENNReal.ofReal p = 0","name":"ENNReal.ofReal_of_nonpos","isProp":true,"docString":"**Alias** of the reverse direction of `ENNReal.ofReal_eq_zero`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤),\n  (0 = 1 : Prop) ‚Üî (‚Üëf 1 = 0 : Prop)","name":"RingHom.codomain_trivial_iff_map_one_eq_zero","isProp":true,"docString":"`f : Œ± ‚Üí+* Œ≤` has a trivial codomain iff `f 1 = 0`. "},{"type":"‚àÄ {K : Type u} {Œ∑ : Type u‚ÇÅ'} {œÜ : (a : Œ∑) ‚Üí Type u_1} [inst : Ring K] [inst_1 : StrongRankCondition K]\n  [inst_2 : (i : Œ∑) ‚Üí AddCommGroup (œÜ i)] [inst_3 : (i : Œ∑) ‚Üí Module K (œÜ i)] [inst_4 : ‚àÄ (i : Œ∑), Module.Free K (œÜ i)]\n  [inst_5 : Finite Œ∑], Module.rank K ((i : Œ∑) ‚Üí œÜ i) = Cardinal.sum fun (i : Œ∑) ‚Ü¶ Module.rank K (œÜ i)","name":"rank_pi","isProp":true,"docString":"The rank of a finite product of free modules is the sum of the ranks. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (h : 0 < (1 - r) * (b - a)),\n  (‚Üë(AffineMap.lineMap (f a) (f b)) r ‚â§ f (‚Üë(AffineMap.lineMap a b) r) : Prop) ‚Üî\n    (slope f (‚Üë(AffineMap.lineMap a b) r) b ‚â§ slope f a b : Prop)","name":"lineMap_le_map_iff_slope_le_slope_right","isProp":true,"docString":"Given `c = lineMap a b r`, `c < b`, the point `(c, f c)` is non-strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f c b ‚â§ slope f a b`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [inst : NonUnitalNonAssocSemiring Œ±]\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [inst_2 : NonUnitalNonAssocSemiring Œ≥] {Œ¥ : Type u_1}\n  {x : NonUnitalNonAssocSemiring Œ¥} (f : Œ± ‚Üí‚Çô+* Œ≤) (g : Œ≤ ‚Üí‚Çô+* Œ≥) (h : Œ≥ ‚Üí‚Çô+* Œ¥),\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)","name":"NonUnitalRingHom.comp_assoc","isProp":true,"docString":"Composition of non-unital ring homomorphisms is associative. "},{"type":"‚àÄ {Œ± : Type u_1} {E' : Type u_2} {F' : Type u_3} [inst : SeminormedAddCommGroup E'] [inst_1 : SeminormedAddCommGroup F']\n  {f' : (a : Œ±) ‚Üí E'} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =o[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ),\n  f' =o[l] g'","name":"Asymptotics.IsLittleO.of_norm_norm","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_norm_norm`."},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (M : Submonoid R), Submonoid.subsemiringClosure M = Subsemiring.closure ‚ÜëM","name":"Submonoid.subsemiringClosure_eq_closure","isProp":true,"docString":"The `Subsemiring` generated by a multiplicative submonoid coincides with the\n`Subsemiring.closure` of the submonoid itself . "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {P : Type (max u v)} [inst_1 : AddCommMonoid P] [inst_2 : Module R P]\n  (huniv :\n    ‚àÄ {M : Type (max v u)} {N : Type (max u v)} [inst_3 : AddCommMonoid M] [inst_4 : AddCommMonoid N]\n      [inst_5 : Module R M] [inst_6 : Module R N] (f : M ‚Üí‚Çó[R] N) (g : P ‚Üí‚Çó[R] N) (a : Function.Surjective ‚Üëf),\n      ‚àÉ (h : P ‚Üí‚Çó[R] M), LinearMap.comp f h = g),\n  Module.Projective R P","name":"Module.Projective.of_lifting_property'","isProp":true,"docString":"A module which satisfies the universal property is projective. Note that the universe variables\nin `huniv` are somewhat restricted. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {W : C} {X : C} {Y : C} {Z : C} {f : W ‚ü∂ X} {g : W ‚ü∂ Y} {h : X ‚ü∂ Z}\n  {i : Y ‚ü∂ Z} (self : CategoryTheory.BicartesianSq f g h i),\n  Nonempty\n    (CategoryTheory.Limits.IsColimit\n      (CategoryTheory.Limits.PushoutCocone.mk h i\n        ((CategoryTheory.CommSq.w\n              ((CategoryTheory.IsPullback.toCommSq\n                    ((CategoryTheory.BicartesianSq.toIsPullback\n                          self=:CategoryTheory.IsPullback f g h\n                          i)=:CategoryTheory.IsPullback f g h\n                        i)=:CategoryTheory.CommSq f g h\n                    i)=:CategoryTheory.CommSq f g h i)=:f ‚â´ h = g ‚â´ i)=:f ‚â´ h = g ‚â´ i)))","name":"CategoryTheory.BicartesianSq.isColimit'","isProp":true,"docString":"the pushout cocone is a colimit "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r)\n  (hf : Filter.Tendsto f l Filter.atBot), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atBot","name":"Filter.Tendsto.const_mul_atBot","isProp":true,"docString":"If a function tends to negative infinity along a filter, then this function multiplied by\na positive constant (on the left) also tends to negative infinity. "},{"type":"‚àÄ {œÉ : Type u} {R : Type u} [inst : CommSemiring R],\n  Cardinal.mk (MvPolynomial œÉ R) ‚â§ max (max (Cardinal.mk R) (Cardinal.mk œÉ)) Cardinal.aleph0","name":"MvPolynomial.cardinal_mk_le_max","isProp":true,"docString":"The cardinality of the multivariate polynomial ring, `MvPolynomial œÉ R` is at most the maximum\nof `#R`, `#œÉ` and `‚Ñµ‚ÇÄ` "},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : TopologicalSpace.SecondCountableTopology Œ±],\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts Œ±)","name":"EMetric.NonemptyCompacts.secondCountableTopology","isProp":true,"docString":"In a second countable space, the type of nonempty compact subsets is second countable "},{"type":"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsMaximal I], IsCoatom I","name":"Ideal.IsMaximal.out","isProp":true,"docString":"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Set Œ≤) {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Surjective f),\n  Function.Surjective (Set.restrictPreimage t f)","name":"Function.Surjective.restrictPreimage","isProp":true,"docString":"**Alias** of `Set.restrictPreimage_surjective`."},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] [inst_1 : OrderTop Œ±] (x : Œ±) (y : Œ±), (x ‚®Ø y) = x ‚äì y","name":"CategoryTheory.Limits.CompleteLattice.prod_eq_inf","isProp":true,"docString":"The binary product in the category of a `SemilatticeInf` with `OrderTop` is the same as the\ninfimum.\n"},{"type":"‚àÄ (S : Type u_1) [inst : Ring S] (a : ‚Ñï), ‚Üë(Nat.descFactorial a 2) = ‚Üëa * (‚Üëa - 1)","name":"Nat.cast_descFactorial_two","isProp":true,"docString":"Convenience lemma. The `a - 1` is not using truncated subtraction, as opposed to the definition\nof `Nat.descFactorial` as a natural. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : (a : Œπ) ‚Üí Type w}\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (s : Finset Œπ) (c : R)\n  (x : (i : ‚Üë‚Üës) ‚Üí M ‚Üëi), ‚Üë(DirectSum.mk M s) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.mk M s) x","name":"DirectSum.mk_smul","isProp":true,"docString":"Scalar multiplication commutes with direct sums. "},{"type":"‚àÄ (M : Type u) [inst : CancelMonoid M], IsCancelMul M","name":"CancelMonoid.toIsCancelMul","isProp":true,"docString":"Any `CancelMonoid G` satisfies `IsCancelMul G`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ≥}\n  (hf : LowerSemicontinuous f) (hg : LowerSemicontinuous g)\n  (hcont : ‚àÄ (x : Œ±), ContinuousAt (fun (p : Œ≥ √ó Œ≥) ‚Ü¶ Prod.fst p + Prod.snd p) (f x, g x)),\n  LowerSemicontinuous fun (z : Œ±) ‚Ü¶ f z + g z","name":"LowerSemicontinuous.add'","isProp":true,"docString":"The sum of two lower semicontinuous functions is lower semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. "},{"type":"‚àÄ {p : Prop} [dec : Decidable (p : Prop)] (h : ‚àÄ (a : ¬¨(p : Prop)), False), p","name":"Decidable.by_contradiction","isProp":true,"docString":"**Alias** of `Decidable.byContradiction`."},{"type":"‚àÄ {R : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_1} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R‚ÇÇ] [inst_4 : AddCommMonoid M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  {s : Set M} {f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} {g : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (H : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(Submodule.span R s)","name":"LinearMap.eqOn_span'","isProp":true,"docString":"If two linear maps are equal on a set `s`, then they are equal on `submodule.span s`.\n\nThis version uses `set.eq_on`, and the hidden argument will expand to `h : x ‚àà (span R s : set M)`.\nSee `linear_map.eq_on_span` for a version that takes `h : x ‚àà span R s` as an argument. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (hf : MonotoneOn f s) (hg : StrictMonoOn g s),\n  StrictMonoOn (fun (x : Œ≤) ‚Ü¶ f x + g x) s","name":"MonotoneOn.add_strictMono","isProp":true,"docString":"The sum of a monotone function and a strictly monotone function is\nstrictly monotone."},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ] (Œ≥ : Œì‚ÇÄÀ£), nhds ‚ÜëŒ≥ = pure ‚ÜëŒ≥","name":"WithZeroTopology.nhds_coe_units","isProp":true,"docString":"The neighbourhood filter of an invertible element consists of all sets containing that\nelement. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} (hf : Function.Injective2 f) (a : Œ±),\n  Function.Injective (f a)","name":"Function.Injective2.right","isProp":true,"docString":"A binary injective function is injective when only the right argument varies. "},{"type":"‚àÄ {x : ‚Ñ§} {y : ‚Ñ§} {z : ‚Ñ§} (k : ‚Ñ§) (hk : k ‚â† 0),\n  (PythagoreanTriple (k * x) (k * y) (k * z) : Prop) ‚Üî (PythagoreanTriple x y z : Prop)","name":"PythagoreanTriple.mul_iff","isProp":true,"docString":"`(k*x, k*y, k*z)` is a Pythagorean triple if and only if\n`(x, y, z)` is also a triple. "},{"type":"‚àÄ {Œ± : Type u} [inst : CanonicallyLinearOrderedMonoid Œ±], ‚ä• = 1","name":"bot_eq_one'","isProp":true,"docString":"In a linearly ordered monoid, we are happy for `bot_eq_one` to be a `@[simp]` lemma. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {K : NNReal} {f : (a : Œ±) ‚Üí Œ±} (hf : ContractingWith K f) (g : (a : Œ±) ‚Üí Œ±)\n  {x : Œ±} {y : Œ±} (hx : Function.IsFixedPt f x) (hy : Function.IsFixedPt g y) {C : ‚Ñù}\n  (hfg : ‚àÄ (z : Œ±), dist (f z) (g z) ‚â§ C), dist x y ‚â§ C / (1 - ‚ÜëK)","name":"ContractingWith.dist_fixedPoint_fixedPoint_of_dist_le'","isProp":true,"docString":"Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ‚â§ C / (1 - K)`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} {g : (a : E) ‚Üí Œ≤} (hf : ConvexOn ùïú s f) (hg : ConvexOn ùïú s g), ConvexOn ùïú s (f ‚äî g)","name":"ConvexOn.sup","isProp":true,"docString":"The pointwise maximum of convex functions is convex. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] [self : RankCondition R] {n : ‚Ñï} {m : ‚Ñï}\n  (f : ((a : Fin n) ‚Üí R) ‚Üí‚Çó[R] (a : Fin m) ‚Üí R) (a : Function.Surjective ‚Üëf), m ‚â§ n","name":"RankCondition.le_of_fin_surjective","isProp":true,"docString":"Any surjective linear map from `R‚Åø` to `R·µê` guarantees `m ‚â§ n`. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} {v : V} {p : (a : Œπ) ‚Üí P},\n  (v ‚àà vectorSpan k (Set.range p) : Prop) ‚Üî\n    (‚àÉ (s : Finset Œπ),\n        ‚àÉ (w : (a : Œπ) ‚Üí k), ‚àÉ (x : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 0), v = ‚Üë(Finset.weightedVSub s p) w :\n      Prop)","name":"mem_vectorSpan_iff_eq_weightedVSub","isProp":true,"docString":"A vector is in the `vectorSpan` of an indexed family if and only\nif it is a `weightedVSub` with sum of weights 0. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Bornology Œ±] {s : Set Œ±} (a : Bornology.IsBounded s), Bornology.IsCobounded (s·∂ú)","name":"Bornology.IsBounded.compl","isProp":true,"docString":"**Alias** of the reverse direction of `Bornology.isCobounded_compl_iff`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)]\n  [inst_2 : (i : Œπ) ‚Üí Zero (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}, (0 < hammingNorm x : Prop) ‚Üî (x ‚â† 0 : Prop)","name":"hammingNorm_pos_iff","isProp":true,"docString":"Corresponds to `norm_pos_iff`. "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] ‚¶És : Set R‚¶Ñ ‚¶Ét : Set R‚¶Ñ (h : s ‚äÜ t),\n  Subsemiring.closure s ‚â§ Subsemiring.closure t","name":"Subsemiring.closure_mono","isProp":true,"docString":"Subsemiring closure of a set is monotone in its argument: if `s ‚äÜ t`,\nthen `closure s ‚â§ closure t`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonAssocRing Œ±]\n  [inst_1 : OrderedSemiring Œ≤] [self : MulRingNormClass F Œ± Œ≤] (f : F) {a : Œ±} (a_1 : ‚Üëf a = 0), a = 0","name":"MulRingNormClass.eq_zero_of_map_eq_zero","isProp":true,"docString":"The argument is zero if its image under the map is zero. "},{"type":"‚àÄ {Œ± : Type u_1} {m : ‚Ñï} {n : ‚Ñï} (A : Matrix (Fin m) (Fin n) Œ±), Matrix.transpose·µ£ A = Matrix.transpose A","name":"Matrix.transpose·µ£_eq","isProp":true,"docString":"This can be used to prove\n```lean\nexample (a b c d : Œ±) : transpose !![a, b; c, d] = !![a, c; b, d] := (transpose·µ£_eq _).symm\n```\n"},{"type":"‚àÄ {G : Type u} {x : G} [inst : AddGroup G] [inst_1 : Fintype G],\n  addOrderOf x = Fintype.card { x_1 : G // x_1 ‚àà AddSubgroup.zmultiples x }","name":"addOrderOf_eq_card_zmultiples","isProp":true,"docString":"See also `addOrderOf_eq_card_zmultiples'`."},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a < b), ¬¨(b < a : Prop)","name":"LT.lt.asymm","isProp":true,"docString":"**Alias** of `lt_asymm`."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {m : ‚Ñï} {n : ‚Ñï} (s : Affine.Simplex k P m) (e : Fin (m + 1) ‚âÉ Fin (n + 1)),\n  Affine.Simplex.reindex (Affine.Simplex.reindex s e) (Equiv.symm e) = s","name":"Affine.Simplex.reindex_reindex_symm","isProp":true,"docString":"Reindexing by an equivalence and its inverse yields the original simplex. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.IsFilteredOrEmpty C] (X : C) (Y : C),\n  ‚àÉ (Z : C), ‚àÉ (x : X ‚ü∂ Z), ‚àÉ (x : Y ‚ü∂ Z), True","name":"CategoryTheory.IsFilteredOrEmpty.cocone_objs","isProp":true,"docString":"for every pair of objects there exists another object \"to the right\" "},{"type":"‚àÄ {f : (a : ‚Ñï) ‚Üí ‚Ñï} (hf : Nat.Primrec f), ‚àÉ (m : ‚Ñï), ‚àÄ (n : ‚Ñï), f n < ack m n","name":"exists_lt_ack_of_nat_primrec","isProp":true,"docString":"If `f` is primitive recursive, there exists `m` such that `f n < ack m n` for all `n`. "},{"type":"‚àÄ {R : Type u_1} [inst : Mul R] {a : R}, (IsLeftRegular a : Prop) ‚Üî (IsSMulRegular R a : Prop)","name":"isLeftRegular_iff","isProp":true,"docString":"Left-regular multiplication on `R` is equivalent to `R`-regularity of `R` itself. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (hab : a < b) (h‚ÇÄ : 0 < r) (h‚ÇÅ : r < 1),\n  (‚Üë(AffineMap.lineMap (f a) (f b)) r < f (‚Üë(AffineMap.lineMap a b) r) : Prop) ‚Üî\n    (slope f (‚Üë(AffineMap.lineMap a b) r) b < slope f a (‚Üë(AffineMap.lineMap a b) r) : Prop)","name":"lineMap_lt_map_iff_slope_lt_slope","isProp":true,"docString":"Given `c = lineMap a b r`, `a < c < b`, the point `(c, f c)` is strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f c b < slope f a c`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤]\n  [inst_2 : MulOneClass Œ±] [inst_3 : MulOneClass Œ≤] [self : OrderMonoidHomClass F Œ± Œ≤] (f : F), Monotone ‚Üëf","name":"OrderMonoidHomClass.monotone","isProp":true,"docString":"An `OrderMonoidHom` is a monotone function. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)) = Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (AntivaryOn f (g ‚àò ‚ÜëœÉ) ‚Üës : Prop)","name":"AntivaryOn.sum_smul_eq_sum_smul_comp_perm_iff","isProp":true,"docString":"**Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which antivary together, is unchanged by a permutation if and only if `f` and `g ‚àò œÉ` antivary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : CategoryTheory.Presieve X},\n  ((CategoryTheory.Presieve.IsSeparatedFor P R : Prop) ‚àß\n        (‚àÄ (x : CategoryTheory.Presieve.FamilyOfElements P R)\n            (a : CategoryTheory.Presieve.FamilyOfElements.Compatible x),\n            ‚àÉ (t : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor P) (Opposite.op X)),\n              CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation x t :\n          Prop) :\n      Prop) ‚Üî\n    (CategoryTheory.Presieve.IsSheafFor P R : Prop)","name":"CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor","isProp":true,"docString":"`P` is a sheaf for `R` iff it is separated for `R` and there exists an amalgamation. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : OrderBot Œ±] (x : Œ±) (y : Œ±) (z : Œ±) (f : z ‚ü∂ x) (g : z ‚ü∂ y),\n  CategoryTheory.Limits.pushout f g = x ‚äî y","name":"CategoryTheory.Limits.CompleteLattice.pushout_eq_sup","isProp":true,"docString":"The pushout in the category of a `SemilatticeSup` with `OrderBot` is the same as the supremum\nover the objects.\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] (t : List Œπ) (f‚ÇÅ : (a : Œπ) ‚Üí Set Œ±) (f‚ÇÇ : (a : Œπ) ‚Üí Set Œ±)\n  (hf : ‚àÄ (i : Œπ) (a : i ‚àà t), f‚ÇÅ i ‚äÜ f‚ÇÇ i), List.prod (List.map f‚ÇÅ t) ‚äÜ List.prod (List.map f‚ÇÇ t)","name":"Set.list_prod_subset_list_prod","isProp":true,"docString":"An n-ary version of `Set.mul_subset_mul`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_3} {Œπ' : Sort u_2} {s : (a : Œπ) ‚Üí (a : Œπ') ‚Üí Set Œ±},\n  (Set.union·µ¢ fun (j : Œπ') ‚Ü¶ Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ s i j) ‚äÜ Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (j : Œπ') ‚Ü¶ s i j","name":"Set.union·µ¢_inter·µ¢_subset","isProp":true,"docString":"An equality version of this lemma is `union·µ¢_inter·µ¢_of_monotone` in `Data.Set.Finite`. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Nontrivial R]\n  {Œπ : Type w} (b : Basis Œπ R M) [inst_4 : Infinite Œπ] {Œ∫ : Type w} (v : (a : Œ∫) ‚Üí M) (i : LinearIndependent R v)\n  (m : LinearIndependent.Maximal i), Cardinal.mk Œπ ‚â§ Cardinal.mk Œ∫","name":"infinite_basis_le_maximal_linearIndependent","isProp":true,"docString":"Over any ring `R`, if `b` is an infinite basis for a module `M`,\nand `s` is a maximal linearly independent set,\nthen the cardinality of `b` is bounded by the cardinality of `s`.\n"},{"type":"‚àÄ {C : Type u} {A : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : AddMonoid A]\n  (self : CategoryTheory.ShiftMkCore C A) (n : A) (X : C),\n  (CategoryTheory.Iso.hom (CategoryTheory.ShiftMkCore.add self n 0)).app X =\n    CategoryTheory.eqToHom\n        ((id\n              ((Eq.mpr\n                    ((id\n                          ((Eq.ndrec\n                                ((Eq.refl\n                                      (Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor\n                                              (CategoryTheory.ShiftMkCore.F self (n + 0)))\n                                            X =\n                                          Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                            X :\n                                        Prop)=:(Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor\n                                              (CategoryTheory.ShiftMkCore.F self (n + 0)))\n                                            X =\n                                          Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                            X :\n                                        Prop) =\n                                      (Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor\n                                              (CategoryTheory.ShiftMkCore.F self (n + 0)))\n                                            X =\n                                          Prefunctor.obj\n                                            (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                            X :\n                                        Prop))=:(Prefunctor.obj\n                                          (CategoryTheory.Functor.toPrefunctor\n                                            (CategoryTheory.ShiftMkCore.F self (n + 0)))\n                                          X =\n                                        Prefunctor.obj\n                                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                          X :\n                                      Prop) =\n                                    (Prefunctor.obj\n                                          (CategoryTheory.Functor.toPrefunctor\n                                            (CategoryTheory.ShiftMkCore.F self (n + 0)))\n                                          X =\n                                        Prefunctor.obj\n                                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                          X :\n                                      Prop))\n                                ((add_zero\n                                      n=:n + 0 =\n                                      n)=:n + 0 =\n                                    n)=:(Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (n + 0)))\n                                      X =\n                                    Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X :\n                                  Prop) =\n                                (Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                                    Prefunctor.obj\n                                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X :\n                                  Prop))=:(Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (n + 0)))\n                                    X =\n                                  Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X :\n                                Prop) =\n                              (Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                                  Prefunctor.obj\n                                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X :\n                                Prop))=:(Prefunctor.obj\n                                (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (n + 0))) X =\n                              Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                X :\n                            Prop) =\n                          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                X =\n                              Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                                X :\n                            Prop))=:(Prefunctor.obj\n                              (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (n + 0))) X =\n                            Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                              X :\n                          Prop) =\n                        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                            Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                              X :\n                          Prop))\n                    ((Eq.refl\n                          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                            X)=:Prefunctor.obj\n                            (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                          Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                            X)=:Prefunctor.obj\n                          (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X =\n                        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                          X)=:Prefunctor.obj\n                      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (n + 0))) X =\n                    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                      X)=:Prefunctor.obj\n                    (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (n + 0))) X =\n                  Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                    X)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (n + 0)))\n                X =\n              Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (ùü≠ C))\n                (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n))\n                  X))=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self (n + 0)))\n              X =\n            Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (ùü≠ C))\n              (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X)) ‚â´\n      (CategoryTheory.Iso.inv (CategoryTheory.ShiftMkCore.zero self)).app\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ShiftMkCore.F self n)) X)","name":"CategoryTheory.ShiftMkCore.add_zero_hom_app","isProp":true,"docString":"compatibility with the right addition with 0 "},{"type":"‚àÄ {m : Type u} {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±]\n  (A : Matrix n n Œ±) (B : Matrix n m Œ±) [inst_3 : Invertible A], Matrix.mul (‚ÖüA) (Matrix.mul A B) = B","name":"Matrix.invOf_mul_self_assoc","isProp":true,"docString":"A copy of `invOf_mul_self_assoc` using `‚¨ù` not `*`. "},{"type":"‚àÄ (x : ‚Ñï) (y : ‚Ñï), ‚Üë(Nat.gcd x y) = ‚Üëx * Nat.gcdA x y + ‚Üëy * Nat.gcdB x y","name":"Nat.gcd_eq_gcd_ab","isProp":true,"docString":"**B√©zout's lemma**: given `x y : ‚Ñï`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and\n`b = gcd_b x y` are computed by the extended Euclidean algorithm.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {Œ¥ : Type u_1} [inst_4 : LinearOrder Œ¥] [inst_5 : TopologicalSpace Œ¥]\n  [inst_6 : OrderClosedTopology Œ¥] {f : (a : Œ±) ‚Üí Œ¥} (hf : Continuous f)\n  (h_top : Filter.Tendsto f Filter.atBot Filter.atTop) (h_bot : Filter.Tendsto f Filter.atTop Filter.atBot),\n  Function.Surjective f","name":"Continuous.surjective'","isProp":true,"docString":"A continuous function which tendsto `Filter.atBot` along `Filter.atTop` and to `Filter.atTop`\nalong `atBot` is surjective. "},{"type":"‚àÄ {M : Type u_2} {N : Type u_1} [inst : Mul M] [inst_1 : Mul N] {c : Con M} {d : Con N}\n  {C : (a : Con.Quotient c) ‚Üí (a : Con.Quotient d) ‚Üí Prop} (p : Con.Quotient c) (q : Con.Quotient d)\n  (H : ‚àÄ (x : M) (y : N), C ‚Üëx ‚Üëy), C p q","name":"Con.induction_on‚ÇÇ","isProp":true,"docString":"A version of `con.induction_on` for predicates which take two arguments. "},{"type":"‚àÄ {f : (a : ‚Ñï) ‚Üí ‚Ñù} (hf : ‚àÄ (i : ‚Ñï), 0 ‚â§ f i) (r : ‚Ñù),\n  (HasSum f r : Prop) ‚Üî\n    (Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f i) Filter.atTop (nhds r) : Prop)","name":"hasSum_iff_tendsto_nat_of_nonneg","isProp":true,"docString":"A series of non-negative real numbers converges to `r` in the sense of `HasSum` if and only if\nthe sequence of partial sum converges to `r`. "},{"type":"‚àÄ {S : Set Ordinal} (hS : Set.Unbounded (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x < x_1) S) {o : Ordinal},\n  Set.Nonempty\n    (setOf fun (x : Ordinal) ‚Ü¶ (x ‚àà S : Prop) ‚àß (‚àÄ (c : Ordinal) (a : c < o), Ordinal.enumOrd S c < x : Prop))","name":"Ordinal.enumOrd_def_nonempty","isProp":true,"docString":"The set in `enumOrd_def` is nonempty. "},{"type":"‚àÄ {n : ‚Ñï} {F : (a : TypeVec n) ‚Üí Type u_2} [inst : MvFunctor F] [self : LawfulMvFunctor F] {Œ± : TypeVec n}\n  {Œ≤ : TypeVec n} {Œ≥ : TypeVec n} (g : TypeVec.Arrow Œ± Œ≤) (h : TypeVec.Arrow Œ≤ Œ≥) (x : F Œ±),\n  MvFunctor.map (TypeVec.comp h g) x = MvFunctor.map h (MvFunctor.map g x)","name":"LawfulMvFunctor.comp_map","isProp":true,"docString":"`map` preserves compositions "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SeminormedRing Œ±] (a : Œ±) {n : ‚Ñï} (a_1 : 0 < n), ‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n","name":"nnnorm_pow_le'","isProp":true,"docString":"If `Œ±` is a seminormed ring, then `‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n` for `n > 0`.\nSee also `nnnorm_pow_le`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonUnitalNonAssocSemiring Œ±] [inst_1 : NonUnitalNonAssocSemiring Œ≤]\n  (self : Œ± ‚Üí‚Çô+* Œ≤), MulHom.toFun (NonUnitalRingHom.toMulHom self) 0 = 0","name":"NonUnitalRingHom.map_zero'","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : CommSemiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) [inst_5 : Fintype Œπ] (c : (a : Œπ) ‚Üí R) (m : (i : Œπ) ‚Üí M‚ÇÅ i),\n  (‚Üëf fun (i : Œπ) ‚Ü¶ c i ‚Ä¢ m i) = (Finset.prod Finset.univ fun (i : Œπ) ‚Ü¶ c i) ‚Ä¢ ‚Üëf m","name":"MultilinearMap.map_smul_univ","isProp":true,"docString":"Multiplicativity of a multilinear map along all coordinates at the same time,\nwriting `f (fun i => c i ‚Ä¢ m i)` as `(‚àè i, c i) ‚Ä¢ f m`. "},{"type":"‚àÄ [inst : (P : Prop) ‚Üí Decidable (P : Prop)] {Œ± : Type u_1} {Œ≤ : Type u_1} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥)\n  (s : Finset Œ±) (t : Finset Œ≤), Finset.image‚ÇÇ f s t = Seq.seq (f <$> s) fun (x : Unit) ‚Ü¶ t","name":"Finset.image‚ÇÇ_def","isProp":true,"docString":"`Finset.image‚ÇÇ` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. "},{"type":"‚àÄ {M : Type u_1} {X : Type u_2} [inst : VAdd M X] [inst_1 : TopologicalSpace M] [inst_2 : TopologicalSpace X]\n  [self : ContinuousVAdd M X], Continuous fun (p : M √ó X) ‚Ü¶ Prod.fst p +·µ• Prod.snd p","name":"ContinuousVAdd.continuous_vadd","isProp":true,"docString":"The additive action `(+·µ•)` is continuous. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : TopologicalSpace Œ±]\n  [inst_1 : TopologicalSpace Œ≤] [self : CocompactMapClass F Œ± Œ≤] (f : F),\n  Filter.Tendsto (‚Üëf) (Filter.cocompact Œ±) (Filter.cocompact Œ≤)","name":"CocompactMapClass.cocompact_tendsto","isProp":true,"docString":"The cocompact filter on `Œ±` tends to the cocompact filter on `Œ≤` under the function "},{"type":"‚àÄ {R : Type w} [inst : Semiring R] {C : Type u} [inst_1 : CategoryTheory.Category C]\n  [inst_2 : CategoryTheory.Preadditive C] [self : CategoryTheory.Linear R C] (X : C) (Y : C) (Z : C) (r : R) (f : X ‚ü∂ Y)\n  (g : Y ‚ü∂ Z), (r ‚Ä¢ f) ‚â´ g = r ‚Ä¢ f ‚â´ g","name":"CategoryTheory.Linear.smul_comp","isProp":true,"docString":"compatibility of the scalar multiplication with the post-composition "},{"type":"‚àÄ {R : Type u} [inst : Star R] [self : TrivialStar R] (r : R), star r = r","name":"TrivialStar.star_trivial","isProp":true,"docString":"Condition that star is trivial"},{"type":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] {l : Filter Œ≤} {f‚ÇÅ : (a : Œ≤) ‚Üí Œ±} {f‚ÇÇ : (a : Œ≤) ‚Üí Œ±}\n  {f‚ÇÉ : (a : Œ≤) ‚Üí Œ±} (h‚ÇÅ‚ÇÇ : Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ (f‚ÇÅ x, f‚ÇÇ x)) l (uniformity Œ±))\n  (h‚ÇÇ‚ÇÉ : Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ (f‚ÇÇ x, f‚ÇÉ x)) l (uniformity Œ±)),\n  Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ (f‚ÇÅ x, f‚ÇÉ x)) l (uniformity Œ±)","name":"Filter.Tendsto.uniformity_trans","isProp":true,"docString":"Relation `fun f g ‚Ü¶ Tendsto (fun x ‚Ü¶ (f x, g x)) l (ùì§ Œ±)` is transitive. "},{"type":"‚àÄ {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} [inst : DecidablePred p] {s : Finset Œ±} (h : ‚àÄ (x : Œ±) (a : x ‚àà s), p x),\n  Finset.map (Function.Embedding.subtype p) (Finset.subtype p s) = s","name":"Finset.subtype_map_of_mem","isProp":true,"docString":"If all elements of a `Finset` satisfy the predicate `p`,\n`s.subtype p` converts back to `s` with `Embedding.subtype`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ} (h : TendstoUniformly F f p) (x : Œ±), Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n x) p (nhds (f x))","name":"TendstoUniformly.tendsto_at","isProp":true,"docString":"Uniform converence implies pointwise convergence. "},{"type":"‚àÄ {R : Type v} [inst : CommRing R] {n : ‚Ñï} (A : Matrix (Fin (Nat.succ n)) (Fin (Nat.succ n)) R),\n  Matrix.det A =\n    Finset.sum Finset.univ fun (j : Fin (Nat.succ n)) ‚Ü¶\n      (-1) ^ ‚Üëj * A 0 j * Matrix.det (Matrix.submatrix A Fin.succ ‚Üë(Fin.succAbove j))","name":"Matrix.det_succ_row_zero","isProp":true,"docString":"Laplacian expansion of the determinant of an `n+1 √ó n+1` matrix along row 0. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasPullbacks C] {X : C} {Y : C}\n  (g : Y ‚ü∂ X) [inst_2 : CategoryTheory.Mono g] (f‚ÇÅ : CategoryTheory.Subobject Y) (f‚ÇÇ : CategoryTheory.Subobject Y),\n  Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Subobject.map g)) (f‚ÇÅ ‚äì f‚ÇÇ) =\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Subobject.map g)) f‚ÇÅ ‚äì\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Subobject.map g)) f‚ÇÇ","name":"CategoryTheory.Subobject.inf_map","isProp":true,"docString":"`‚äì` commutes with map. "},{"type":"‚àÄ {H : Type u} {M : Type u_1} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  {G : StructureGroupoid H} {e : LocalHomeomorph M H} {e' : LocalHomeomorph M H}\n  (he : e ‚àà StructureGroupoid.maximalAtlas M G) (he' : e' ‚àà StructureGroupoid.maximalAtlas M G),\n  LocalHomeomorph.trans (LocalHomeomorph.symm e) e' ‚àà G","name":"StructureGroupoid.compatible_of_mem_maximalAtlas","isProp":true,"docString":"Changing coordinates between two elements of the maximal atlas gives rise to an element\nof the structure groupoid. "},{"type":"‚àÄ {n : ‚Ñï} {k : ‚Ñï} (a : k ‚â§ n), Nat.factorial (n - k) * Nat.descFactorial n k = Nat.factorial n","name":"Nat.factorial_mul_descFactorial","isProp":true,"docString":"`n.descFactorial k = n! / (n - k)!` but without ‚Ñï-division. See `Nat.descFactorial_eq_div`\nfor the version using ‚Ñï-division. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (J : CategoryTheory.GrothendieckTopology C)\n  (f : Y ‚ü∂ X) (S : CategoryTheory.Sieve X) (R : CategoryTheory.Sieve X)\n  (h : CategoryTheory.GrothendieckTopology.Covers J S f)\n  (a : ‚àÄ {Z : C} (g : Z ‚ü∂ X) (a : CategoryTheory.Sieve.arrows S g), CategoryTheory.GrothendieckTopology.Covers J R g),\n  CategoryTheory.GrothendieckTopology.Covers J R f","name":"CategoryTheory.GrothendieckTopology.arrow_trans","isProp":true,"docString":"The transitivity axiom in 'arrow' form: If `S` covers `f` and every arrow in `S` is covered by\n`R`, then `R` covers `f`.\n"},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} {Œ≤ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : AddCommGroup F] [inst_3 : OrderedAddCommMonoid Œ≤] [inst_4 : Module ùïú E] [inst_5 : Module ùïú F]\n  [inst_6 : SMul ùïú Œ≤] {f : (a : F) ‚Üí Œ≤} (g : E ‚Üí·µÉ[ùïú] F) {s : Set F} (hf : ConvexOn ùïú s f),\n  ConvexOn ùïú (‚Üëg ‚Åª¬π' s) (f ‚àò ‚Üëg)","name":"ConvexOn.comp_affineMap","isProp":true,"docString":"If a function is convex on `s`, it remains convex when precomposed by an affine map. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C], CategoryTheory.Limits.HasCoequalizers C","name":"CategoryTheory.NormalEpiCategory.hasCoequalizers","isProp":true,"docString":"A `NormalEpiCategory` category with finite coproducts and cokernels has all coequalizers. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R] [inst_3 : GCDMonoid R]\n  (a : R) (b : R), ‚àÉ (x : R), ‚àÉ (y : R), gcd a b = a * x + b * y","name":"exists_gcd_eq_mul_add_mul","isProp":true,"docString":"**B√©zout's lemma** "},{"type":"‚àÄ (G : Type u_1) [inst : Monoid G] (L : Type u_2) [inst_1 : CommRing L] [inst_2 : NoZeroDivisors L],\n  LinearIndependent L fun (f : G ‚Üí* L) ‚Ü¶ ‚Üëf","name":"linearIndependent_monoidHom","isProp":true,"docString":"Dedekind's linear independence of characters "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R} (hP : Ideal.IsPrime P)\n  (hfl : ¬¨(Polynomial.leadingCoeff f ‚àà P : Prop))\n  (hfP : ‚àÄ (n : ‚Ñï) (a : ‚Üën < Polynomial.degree f), Polynomial.coeff f n ‚àà P) (hfd0 : 0 < Polynomial.degree f)\n  (h0 : ¬¨(Polynomial.coeff f 0 ‚àà P ^ 2 : Prop)) (hu : Polynomial.IsPrimitive f), Irreducible f","name":"Polynomial.irreducible_of_eisenstein_criterion","isProp":true,"docString":"If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\nirreducible. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Type u_1} [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] {A : (a : Œπ) ‚Üí Submodule R M} (h : DirectSum.IsInternal A), CompleteLattice.Independent A","name":"DirectSum.IsInternal.submodule_independent","isProp":true,"docString":"If a direct sum of submodules is internal then the submodules are independent. "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f1 : Œ± ‚Üí‚ÇÄ M} {f2 : Œ± ‚Üí‚ÇÄ M}\n  (hd : Disjoint (Finsupp.support f1) (Finsupp.support f2)) {Œ≤ : Type u_3} [inst_1 : AddCommMonoid Œ≤]\n  (g : (a : Œ±) ‚Üí (a : M) ‚Üí Œ≤), Finsupp.sum (f1 + f2) g = Finsupp.sum f1 g + Finsupp.sum f2 g","name":"Finsupp.sum_add_index_of_disjoint","isProp":true,"docString":"For disjoint `f1` and `f2`, and function `g`, the sum of the sums of `g`\nover `f1` and `f2` equals the sum of `g` over `f1 + f2`"},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_3} [inst_1 : AddCommMonoid N] {P : Type u_2}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëg ‚Üëy)) {x : M} {y : M}\n  (h : ‚Üë(AddSubmonoid.LocalizationMap.toMap f) x = ‚Üë(AddSubmonoid.LocalizationMap.toMap f) y), ‚Üëg x = ‚Üëg y","name":"AddSubmonoid.LocalizationMap.eq_of_eq","isProp":true,"docString":"Given a Localization map `f : M ‚Üí+ N` for a Submonoid `S ‚äÜ M` and a map of\n`AddCommMonoid`s `g : M ‚Üí+ P` such that `g(S) ‚äÜ AddUnits P`, `f x = f y ‚Üí g x = g y`\nfor all `x y : M`."},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] (S : AddSubmonoid M), addLocalization.zero S = Zero.zero","name":"addLocalization.zero_def","isProp":true,"docString":"The identity element of an `addLocalization` is defined as `‚ü®0, 0‚ü©`.\n\nShould not be confused with the ring localization counterpart `Localization.zero`,\nwhich is defined as `‚ü®0, 1‚ü©`."},{"type":"‚àÄ {Œ± : Type u_2} {F : Type u_3} {ùïú : Type u_1} [inst : Norm F] [inst_1 : NormedField ùïú] {g : (a : Œ±) ‚Üí F} {l : Filter Œ±}\n  {c : ùïú} {f : (a : Œ±) ‚Üí ùïú} (hc : c ‚â† 0) (a : f =Œò[l] g), (fun (x : Œ±) ‚Ü¶ c * f x) =Œò[l] g","name":"Asymptotics.IsTheta.const_mul_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isTheta_const_mul_left`."},{"type":"‚àÄ {G : Type u} {x : G} {y : G} [inst : Monoid G] (h : Commute x y) (hy : IsOfFinOrder y)\n  (hdvd : ‚àÄ (p : ‚Ñï) (a : Nat.Prime p) (a : p ‚à£ orderOf x), p * orderOf x ‚à£ orderOf y), orderOf (x * y) = orderOf y","name":"Commute.orderOf_mul_eq_right_of_forall_prime_mul_dvd","isProp":true,"docString":"If each prime factor of `orderOf x` has higher multiplicity in `orderOf y`, and `x` commutes\nwith `y`, then `x * y` has the same order as `y`. "},{"type":"‚àÄ {f : (a : Ordinal) ‚Üí Ordinal} (H : Ordinal.IsNormal f), Ordinal.deriv f = Ordinal.enumOrd (Function.fixedPoints f)","name":"Ordinal.deriv_eq_enumOrd","isProp":true,"docString":"`ordinal.deriv` enumerates the fixed points of a normal function. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : Nonempty J] (s : CategoryTheory.Limits.Cotrident f) {W : C} {k : CategoryTheory.Limits.Cocone.pt s ‚ü∂ W}\n  {l : CategoryTheory.Limits.Cocone.pt s ‚ü∂ W}\n  (h : CategoryTheory.Limits.Cotrident.œÄ s ‚â´ k = CategoryTheory.Limits.Cotrident.œÄ s ‚â´ l)\n  (j : CategoryTheory.Limits.WalkingParallelFamily J),\n  (CategoryTheory.Limits.Cocone.Œπ s).app j ‚â´ k = (CategoryTheory.Limits.Cocone.Œπ s).app j ‚â´ l","name":"CategoryTheory.Limits.Cotrident.coequalizer_ext","isProp":true,"docString":"To check whether two maps are coequalized by both maps of a cotrident, it suffices to check it\nfor the second map "},{"type":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] (f : (a : Œ≤) ‚Üí Œ±) (l : Filter Œ≤),\n  Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ (f x, f x)) l (uniformity Œ±)","name":"tendsto_diag_uniformity","isProp":true,"docString":"Relation `Œª f g, tendsto (Œª x, (f x, g x)) l (ùì§ Œ±)` is reflexive. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Star R] [inst_1 : Star S]\n  [self : StarHomClass F R S] (f : F) (r : R), ‚Üëf (star r) = star (‚Üëf r)","name":"StarHomClass.map_star","isProp":true,"docString":"the maps preserve star "},{"type":"‚àÄ {J : Type v} {K : Type v} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.SmallCategory K]\n  {C : Type u} [inst_2 : CategoryTheory.Category C] (F : J √ó K ‚•§ C)\n  [inst_3 : CategoryTheory.Limits.HasLimitsOfShape J C] [inst_4 : CategoryTheory.Limits.HasColimitsOfShape K C] (j : J)\n  (k : K),\n  CategoryTheory.Limits.colimit.Œπ\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.curry) (CategoryTheory.Prod.swap K J ‚ãô F) ‚ãô\n          CategoryTheory.Limits.lim)\n        k ‚â´\n      CategoryTheory.Limits.colimitLimitToLimitColimit F ‚â´\n        CategoryTheory.Limits.limit.œÄ\n          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.curry) F ‚ãô CategoryTheory.Limits.colim)\n          j =\n    CategoryTheory.Limits.limit.œÄ\n        (Prefunctor.obj\n          (CategoryTheory.Functor.toPrefunctor\n            (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.curry)\n              (CategoryTheory.Prod.swap K J ‚ãô F)))\n          k)\n        j ‚â´\n      CategoryTheory.Limits.colimit.Œπ\n        (Prefunctor.obj\n          (CategoryTheory.Functor.toPrefunctor\n            (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.curry) F))\n          j)\n        k","name":"CategoryTheory.Limits.Œπ_colimitLimitToLimitColimit_œÄ","isProp":true,"docString":"Since `colimit_limit_to_limit_colimit` is a morphism from a colimit to a limit,\nthis lemma characterises it.\n"},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (g : G) (p1 : P) (p2 : P),\n  g +·µ• p1 -·µ• p2 = g + (p1 -·µ• p2)","name":"vadd_vsub_assoc","isProp":true,"docString":"Adding a group element to a point, then subtracting another point,\nproduces the same result as subtracting the points then adding the\ngroup element. "},{"type":"‚àÄ {M : Type u} [self : AddRightCancelMonoid M] (a : M), a + 0 = a","name":"AddRightCancelMonoid.add_zero","isProp":true,"docString":"Zero is a right neutral element for addition "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  [inst_2 : CategoryTheory.Limits.HasColimit F] (c : CategoryTheory.Limits.Cocone F) (j : J),\n  CategoryTheory.Limits.colimit.Œπ F j ‚â´ CategoryTheory.Limits.colimit.desc F c =\n    (CategoryTheory.Limits.Cocone.Œπ c).app j","name":"CategoryTheory.Limits.colimit.Œπ_desc","isProp":true,"docString":"We have lots of lemmas describing how to simplify `colimit.Œπ F j ‚â´ _`,\nand combined with `colimit.ext` we rely on these lemmas for many calculations.\n\nHowever, since `Category.assoc` is a `@[simp]` lemma, often expressions are\nright associated, and it's hard to apply these lemmas about `colimit.Œπ`.\n\nWe thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.\n(see `Tactic/reassoc_axiom.lean`)\n "},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_2} [inst : Ring R] {M : Type u_1} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {v : (a : Œπ) ‚Üí M} (li : LinearIndependent R v) (c : R) (d : R) (i : Œπ) (j : Œπ) (hc : c ‚â† 0) (h : c ‚Ä¢ v i = d ‚Ä¢ v j),\n  i = j","name":"LinearIndependent.eq_of_smul_apply_eq_smul_apply","isProp":true,"docString":"Linear independent families are injective, even if you multiply either side. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {t : Set Œ≤} (h : Set.MapsTo f s t) (a : LipschitzOnWith K f s),\n  LipschitzWith K (Set.MapsTo.restrict f s t h)","name":"LipschitzOnWith.to_restrict_mapsTo","isProp":true,"docString":"**Alias** of the forward direction of `MapsTo.lipschitzOnWith_iff_restrict`."},{"type":"‚àÄ {X : Type v} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], ParacompactSpace X","name":"paracompact_of_compact","isProp":true,"docString":"A compact space is paracompact. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} (a : l <:+ []), l = []","name":"List.eq_nil_of_suffix_nil","isProp":true,"docString":"**Alias** of the forward direction of `List.suffix_nil_iff`."},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M),\n  AddCon.addKer AddCon.toQuotient\n      (fun (x : M) ‚Ü¶ (_ : ‚àÄ (x_1 : M), ‚Üë(x + x_1) = ‚Üë(x + x_1))=:‚àÄ (x : M) (x_1 : M), ‚Üë(x + x_1) = ‚Üë(x + x_1)) =\n    c","name":"AddCon.add_ker_mk_eq","isProp":true,"docString":"The kernel of the quotient map induced by an additive congruence\nrelation `c` equals `c`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (a_1 : IsAtom a), IsCoatom (‚ÜëOrderDual.toDual a)","name":"IsAtom.dual","isProp":true,"docString":"**Alias** of the reverse direction of `isCoatom_dual_iff_isAtom`."},{"type":"‚àÄ {Œ± : Type u_1} {r : Setoid Œ±} {s : Setoid Œ±}, r ‚äî s = EqvGen.Setoid (Setoid.Rel r ‚äî Setoid.Rel s)","name":"Setoid.sup_def","isProp":true,"docString":"The supremum of 2 equivalence relations r and s is the equivalence closure of the\nsupremum of the underlying binary operations. "},{"type":"‚àÄ {A : Class} (hA : Class.powerset A ‚äÜ A), A = Class.univ","name":"Class.eq_univ_of_powerset_subset","isProp":true,"docString":"An induction principle for sets. If every subset of a class is a member, then the class is\nuniversal. "},{"type":"‚àÄ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a : K} {b : K} {c : K} (ha : a ‚â† 0)\n  (h : ‚àÉ (s : K), discrim a b c = s * s), ‚àÉ (x : K), a * x * x + b * x + c = 0","name":"exists_quadratic_eq_zero","isProp":true,"docString":"A quadratic has roots if its discriminant has square roots "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : TopologicalSpace ùïú] [inst_1 : OrderedRing ùïú] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ùïú E] [inst_5 : Nontrivial ùïú] {A : Set E} {B : Set E}\n  (hAB : IsExposed ùïú A B), ‚àÉ (l : E ‚ÜíL[ùïú] ùïú), ‚àÉ (a : ùïú), B = setOf fun (x : E) ‚Ü¶ (x ‚àà A : Prop) ‚àß (a ‚â§ ‚Üël x : Prop)","name":"IsExposed.eq_inter_halfspace","isProp":true,"docString":"For nontrivial `ùïú`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\nhalfspace doesn't intersect `A`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a - b < 0), a < b","name":"lt_of_sub_neg","isProp":true,"docString":"**Alias** of the forward direction of `sub_neg`."},{"type":"‚àÄ {Œ± : Type u_1} {S : Set (Set Œ±)} (self : FiniteInter S), Set.univ ‚àà S","name":"FiniteInter.univ_mem","isProp":true,"docString":"`univ_mem` states that `Set.univ` is in `S`. "},{"type":"‚àÄ {Œ≤ : Type u_2} [inst : TopologicalSpace Œ≤] {Œ∫ : Type u_1} {f : (a : Œ∫) ‚Üí Œ≤} (hf : Function.Surjective f), DenseRange f","name":"Function.Surjective.denseRange","isProp":true,"docString":"A surjective map has dense range. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (g : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct Y Y],\n  f + g = CategoryTheory.Limits.biprod.lift f g ‚â´ CategoryTheory.Limits.biprod.desc (ùüô Y) (ùüô Y)","name":"CategoryTheory.Limits.biprod.add_eq_lift_desc_id","isProp":true,"docString":"The existence of binary biproducts implies that there is at most one preadditive structure. "},{"type":"‚àÄ {Œ± : Sort u} (self : Unique Œ±) (a : Œ±), a = default","name":"Unique.uniq","isProp":true,"docString":"In a `Unique` type, every term is equal to the default element (from `Inhabited`). "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C)\n  [inst_3 : CategoryTheory.Limits.HasBinaryBiproduct X Y],\n  CategoryTheory.IsPushout CategoryTheory.Limits.biprod.inl 0 CategoryTheory.Limits.biprod.snd 0","name":"CategoryTheory.IsPushout.inl_snd","isProp":true,"docString":"The square\n```\n  X --inl--> X ‚äû Y\n  |            |\n  0           snd\n  |            |\n  v            v\n  0 ---0-----> Y\n```\nis a pushout square.\n"},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (m : ‚Ñï), (padicNorm p ‚Üëm = 1 : Prop) ‚Üî (¬¨(p ‚à£ m : Prop) : Prop)","name":"padicNorm.nat_eq_one_iff","isProp":true,"docString":"The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥) (s : Set Œ±) (t : Set Œ≤),\n  Set.image2 f s t =\n    Set.union·µ¢ fun (i : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà s) ‚Ü¶ Set.union·µ¢ fun (j : Œ≤) ‚Ü¶ Set.union·µ¢ fun (h : j ‚àà t) ‚Ü¶ {f i j}","name":"Set.image2_eq_union·µ¢","isProp":true,"docString":"The `Set.image2` version of `Set.image_eq_union·µ¢` "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\n  [inst_2 : NonUnitalRingHomClass F R S] (f : F) (hf : Function.Surjective ‚Üëf), NonUnitalRingHom.srange f = ‚ä§","name":"NonUnitalRingHom.srange_top_of_surjective","isProp":true,"docString":"The range of a surjective non-unital ring homomorphism is the whole of the codomain. "},{"type":"‚àÄ {a : Prop} {c : Prop} {b : Prop} {d : Prop} (h‚ÇÅ : (a : Prop) ‚Üî (c : Prop)) (h‚ÇÇ : (b : Prop) ‚Üî (d : Prop)),\n  (‚àÄ (a : a), b : Prop) ‚Üî (‚àÄ (a : c), d : Prop)","name":"Iff.imp","isProp":true,"docString":"**Alias** of `imp_congr`."},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeInf Œ±] (s : Set Œ±) (a : Œ±) (a_1 : ‚àÄ (b : Œ±) (a_1 : b ‚àà s), a ‚â§ b),\n  a ‚â§ inf‚Çõ s","name":"CompleteSemilatticeInf.le_inf‚Çõ","isProp":true,"docString":"Any lower bound is less than the set infimum. "},{"type":"‚àÄ {Œ≤ : Type u_2} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ≤] [inst_1 : TopologicalSpace Œ≥] {Œ∫ : Type u_3}\n  {g : (a : Œ≤) ‚Üí Œ≥} {f : (a : Œ∫) ‚Üí Œ≤} (hg : DenseRange g) (hf : DenseRange f) (cg : Continuous g), DenseRange (g ‚àò f)","name":"DenseRange.comp","isProp":true,"docString":"Composition of a continuous map with dense range and a function with dense range has dense\nrange. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C]\n  [self : CategoryTheory.Pretriangulated C] (T‚ÇÅ : CategoryTheory.Pretriangulated.Triangle C)\n  (T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle C) (x : T‚ÇÅ ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles)\n  (x : T‚ÇÇ ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles)\n  (a : CategoryTheory.Pretriangulated.Triangle.obj‚ÇÅ T‚ÇÅ ‚ü∂ CategoryTheory.Pretriangulated.Triangle.obj‚ÇÅ T‚ÇÇ)\n  (b : CategoryTheory.Pretriangulated.Triangle.obj‚ÇÇ T‚ÇÅ ‚ü∂ CategoryTheory.Pretriangulated.Triangle.obj‚ÇÇ T‚ÇÇ)\n  (x : CategoryTheory.Pretriangulated.Triangle.mor‚ÇÅ T‚ÇÅ ‚â´ b = a ‚â´ CategoryTheory.Pretriangulated.Triangle.mor‚ÇÅ T‚ÇÇ),\n  ‚àÉ (c : CategoryTheory.Pretriangulated.Triangle.obj‚ÇÉ T‚ÇÅ ‚ü∂ CategoryTheory.Pretriangulated.Triangle.obj‚ÇÉ T‚ÇÇ),\n    (CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T‚ÇÅ ‚â´ c = b ‚â´ CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T‚ÇÇ : Prop) ‚àß\n      (CategoryTheory.Pretriangulated.Triangle.mor‚ÇÉ T‚ÇÅ ‚â´\n            Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.shiftFunctor C 1)) a =\n          c ‚â´ CategoryTheory.Pretriangulated.Triangle.mor‚ÇÉ T‚ÇÇ :\n        Prop)","name":"CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphism","isProp":true,"docString":"given two distinguished triangle, a commutative square\ncan be extended as morphism of triangles "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}\n  [inst_1 : CategoryTheory.Limits.HasPushout f g] [inst_2 : CategoryTheory.Epi g],\n  CategoryTheory.Epi CategoryTheory.Limits.pushout.inl","name":"CategoryTheory.Limits.pushout.inl_of_epi","isProp":true,"docString":"The pushout of an epimorphism is an epimorphism "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} {Œ±_1 : Type u_1} {f : (a : Œ±) ‚Üí Œ±_1}\n  [inst : Functor m] [inst_1 : LawfulFunctor m] {x : m Œ±} (hx : SatisfiesM p x),\n  SatisfiesM (fun (b : Œ±_1) ‚Ü¶ ‚àÉ (a : Œ±), (p a : Prop) ‚àß (b = f a : Prop)) (f <$> x)","name":"SatisfiesM.map_post","isProp":true,"docString":"`SatisfiesM` distributes over `<$>`, strongest postcondition version.\n(Use this for reasoning forward from assumptions.)\n"},{"type":"‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] [inst_1 : IsTrans Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±} {c : Œ±}\n  (a_1 : a ‚äÇ b) (a_2 : b ‚äÇ c), a ‚äÇ c","name":"HasSSubset.SSubset.trans","isProp":true,"docString":"**Alias** of `ssubset_trans`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.RegularEpi f]\n  [inst_2 : CategoryTheory.Mono f], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_regularEpi_of_mono","isProp":true,"docString":"A regular epimorphism is an isomorphism if it is a monomorphism. "},{"type":"‚àÄ {R : Type u_1} {R‚Çò : Type u_2} [inst : CommRing R] [inst_1 : CommRing R‚Çò] {M : Submonoid R} (hM : ¬¨(0 ‚àà M : Prop))\n  (hR : IsField R) [inst_2 : Algebra R R‚Çò] [inst_3 : IsLocalization M R‚Çò], Function.Bijective ‚Üë(algebraMap R R‚Çò)","name":"IsField.localization_map_bijective","isProp":true,"docString":"If `R` is a field, then localizing at a submonoid not containing `0` adds no new elements. "},{"type":"‚àÄ (R : Type u_1) {K : Type u_2} [inst : CommRing R] [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst : CharZero R], CharZero K","name":"IsFractionRing.charZero_of_isFractionRing","isProp":true,"docString":"If `R` has characteristic `0`, then so does Frac(R). "},{"type":"‚àÄ {R : Type u_2} {N‚ÇÅ : Type u_1} [inst : Semiring R] [inst_1 : AddCommGroup N‚ÇÅ] [inst_2 : Module R N‚ÇÅ] (z : ‚Ñ§) (m : N‚ÇÅ),\n  ‚Üë‚Üëz m = z ‚Ä¢ m","name":"Module.End.intCast_apply","isProp":true,"docString":"See also `Module.End.intCast_def`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (S : Set (AddCon M)), AddCon.toSetoid (inf‚Çõ S) = inf‚Çõ (AddCon.toSetoid '' S)","name":"AddCon.inf‚Çõ_toSetoid","isProp":true,"docString":"The infimum of a set of additive congruence relations is the same as the infimum of\nthe set's image under the map to the underlying equivalence relation."},{"type":"‚àÄ {Œ± : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition ‚Üë(Finpartition.parts f)","name":"Finpartition.isPartition_parts","isProp":true,"docString":"A finpartition gives rise to a setoid partition "},{"type":"‚àÄ {n : Type u_3} {p : Type u_1} {ùïú : Type u_2} [inst : Field ùïú] [inst_1 : DecidableEq n] [inst_2 : DecidableEq p]\n  [inst_3 : Fintype n] [inst_4 : Fintype p] (M : Matrix p p ùïú) (e : p ‚âÉ n)\n  (H :\n    ‚àÉ (L : List (Matrix.TransvectionStruct n ùïú)),\n      ‚àÉ (L' : List (Matrix.TransvectionStruct n ùïú)),\n        ‚àÉ (D : (a : n) ‚Üí ùïú),\n          Matrix.mul\n              (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L)) (‚Üë(Matrix.reindexAlgEquiv ùïú e) M))\n              (List.prod (List.map Matrix.TransvectionStruct.toMatrix L')) =\n            Matrix.diagonal D),\n  ‚àÉ (L : List (Matrix.TransvectionStruct p ùïú)),\n    ‚àÉ (L' : List (Matrix.TransvectionStruct p ùïú)),\n      ‚àÉ (D : (a : p) ‚Üí ùïú),\n        Matrix.mul (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L)) M)\n            (List.prod (List.map Matrix.TransvectionStruct.toMatrix L')) =\n          Matrix.diagonal D","name":"Matrix.Pivot.reindex_exists_list_transvec_mul_mul_list_transvec_eq_diagonal","isProp":true,"docString":"Reduction to diagonal form by elementary operations is invariant under reindexing. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteColimits C],\n  CategoryTheory.Limits.HasFiniteWidePushouts C","name":"CategoryTheory.Limits.hasFiniteWidePushouts_of_has_finite_limits","isProp":true,"docString":"Finite wide pushouts are finite colimits, so if `C` has all finite colimits,\nit also has finite wide pushouts\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {e' : LocalEquiv Œ± Œ≤}\n  (h : ‚àÄ (x : Œ±), LocalEquiv.toFun e x = LocalEquiv.toFun e' x)\n  (hsymm : ‚àÄ (x : Œ≤), LocalEquiv.toFun (LocalEquiv.symm e) x = LocalEquiv.toFun (LocalEquiv.symm e') x)\n  (hs : LocalEquiv.source e = LocalEquiv.source e'), e = e'","name":"LocalEquiv.ext","isProp":true,"docString":"Two local equivs that have the same `source`, same `toFun` and same `invFun`, coincide. "},{"type":"‚àÄ {Œ± : Type u_3} {F : Type u_4} {E' : Type u_2} {ùïú : Type u_1} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E']\n  [inst_2 : NormedField ùïú] {g : (a : Œ±) ‚Üí F} {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} [inst_3 : NormedSpace ùïú E'] {c : ùïú}\n  (hc : c ‚â† 0) (a : (fun (x : Œ±) ‚Ü¶ c ‚Ä¢ f' x) =Œò[l] g), f' =Œò[l] g","name":"Asymptotics.IsTheta.of_const_smul_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isTheta_const_smul_left`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ±}\n  (Hf : MonotoneOn f t) (Hst : s ‚äÜ t) (a : Set.Nonempty (upperBounds s ‚à© t)), BddAbove (f '' s)","name":"MonotoneOn.map_bddAbove","isProp":true,"docString":"The image under a monotone function on a set `t` of a subset which has an upper bound in `t`\nis bounded above. "},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] (q : ‚Ñï) (n : ‚Ñï) (m : ‚Ñï)\n  (hnm : ComplexShape.Rel AlgebraicTopology.DoldKan.c m n) {X : CategoryTheory.SimplicialObject C}\n  {Y : CategoryTheory.SimplicialObject C} (f : X ‚ü∂ Y),\n  f.app (Opposite.op (SimplexCategory.mk n)) ‚â´ AlgebraicTopology.DoldKan.hœÉ' q n m hnm =\n    AlgebraicTopology.DoldKan.hœÉ' q n m hnm ‚â´ f.app (Opposite.op (SimplexCategory.mk m))","name":"AlgebraicTopology.DoldKan.hœÉ'_naturality","isProp":true,"docString":"The maps `hœÉ' q n m hnm` are natural on the simplicial object "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {f : (a : Œ±) ‚Üí E} {a : (a : Œ±) ‚Üí ‚Ñù} {t‚ÇÄ : Filter Œ±}\n  (h : ‚àÄ (n : Œ±), ‚Äñf n‚Äñ ‚â§ a n) (a : Filter.Tendsto a t‚ÇÄ (nhds 0)), Filter.Tendsto f t‚ÇÄ (nhds 1)","name":"squeeze_one_norm","isProp":true,"docString":"Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\ntends to `0`, then `f` tends to `1`. "},{"type":"‚àÄ {Œ± : Sort u} [self : Setoid Œ±], Equivalence Setoid.r","name":"Setoid.iseqv","isProp":true,"docString":"The relation `x ‚âà y` is an equivalence relation. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R} {n : ‚Ñï} (a : Polynomial.degree p ‚â§ ‚Üën), Polynomial.natDegree p ‚â§ n","name":"Polynomial.natDegree_le_of_degree_le","isProp":true,"docString":"**Alias** of the reverse direction of `Polynomial.natDegree_le_iff_degree_le`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : BoundedOrder Œ±]\n  [inst_3 : BoundedOrder Œ≤] (self : BoundedOrderHom Œ± Œ≤), ‚Üë(BoundedOrderHom.toOrderHom self) ‚ä• = ‚ä•","name":"BoundedOrderHom.map_bot'","isProp":true,"docString":"The function preserves the bottom element. The preferred spelling is `map_bot`. "},{"type":"‚àÄ (n : ‚Ñï), (Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ i) = n * (n - 1) / 2","name":"Finset.sum_range_id","isProp":true,"docString":"Gauss' summation formula "},{"type":"‚àÄ {obj : Type u} [self : CategoryTheory.Category obj] {W : obj} {X : obj} {Y : obj} {Z : obj} (f : W ‚ü∂ X) (g : X ‚ü∂ Y)\n  (h : Y ‚ü∂ Z), (f ‚â´ g) ‚â´ h = f ‚â´ g ‚â´ h","name":"CategoryTheory.Category.assoc","isProp":true,"docString":"Composition in a category is associative. "},{"type":"‚àÄ {R : Type u} {M : Type v} {M‚ÇÇ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : Module R M] [inst_4 : Module R M‚ÇÇ] {f : (a : M) ‚Üí M‚ÇÇ} (self : IsLinearMap R f) (c : R) (x : M),\n  f (c ‚Ä¢ x) = c ‚Ä¢ f x","name":"IsLinearMap.map_smul","isProp":true,"docString":"A linear map preserves scalar multiplication. "},{"type":"‚àÄ {K : Type u} [self : DivisionRing K] (n : ‚Ñï) (a : K),\n  DivisionRing.zpow (Int.negSucc n) a = (DivisionRing.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"DivisionRing.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [inst_1 : IsModularLattice Œ±] [inst_2 : IsCompactlyGenerated Œ±]\n  [inst_3 : ComplementedLattice Œ±], IsAtomistic Œ±","name":"isAtomistic_of_complementedLattice","isProp":true,"docString":"See [Lemma 5.1][calugareanu]. "},{"type":"‚àÄ {p : ‚Ñï}, padicNorm p 1 = 1","name":"padicNorm.one","isProp":true,"docString":"The `p`-adic norm of `1` is `1`. "},{"type":"‚àÄ {M : Type u} [self : Monoid M] (x : M), Monoid.npow 0 x = 1","name":"Monoid.npow_zero","isProp":true,"docString":"Raising to the power `(0 : ‚Ñï)` gives `1`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (g : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X X],\n  f + g = CategoryTheory.Limits.biprod.lift (ùüô X) (ùüô X) ‚â´ CategoryTheory.Limits.biprod.desc f g","name":"CategoryTheory.Limits.biprod.add_eq_lift_id_desc","isProp":true,"docString":"The existence of binary biproducts implies that there is at most one preadditive structure. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {E : Type u_3}\n  [inst_2 : Norm E] {F : Type u_4} [inst_3 : Norm F] (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : (a : Œ≤) ‚Üí E} {g : (a : Œ≤) ‚Üí F},\n  (f =o[nhds b] g : Prop) ‚Üî ((f ‚àò ‚Üëe) =o[nhds (‚Üë(Homeomorph.symm e) b)] (g ‚àò ‚Üëe) : Prop)","name":"Homeomorph.isLittleO_congr","isProp":true,"docString":"Transfer `IsLittleO` over a `Homeomorph`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : SMul ùïú E] {x : E}\n  {s : Set E},\n  (StarConvex ùïú x s : Prop) ‚Üî\n    (‚àÄ ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 ‚â§ a) (a_2 : 0 ‚â§ b) (a_3 : a + b = 1), a ‚Ä¢ {x} + b ‚Ä¢ s ‚äÜ s : Prop)","name":"starConvex_iff_pointwise_add_subset","isProp":true,"docString":"Alternative definition of star-convexity, in terms of pointwise set operations. "},{"type":"‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : a < b) (a_2 : 0 < c), c * a < c * b","name":"StrictOrderedSemiring.mul_lt_mul_of_pos_left","isProp":true,"docString":"Left multiplication by a positive element is strictly monotone. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {m : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} {Œπ : Type u_1} [inst : Countable Œπ]\n  [inst : Nonempty Œπ] (t : (a : Œπ) ‚Üí Set Œ±) (t_meas : ‚àÄ (n : Œπ), MeasurableSet (t n)) (g : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤)\n  (hg : ‚àÄ (n : Œπ), Measurable (g n)) (ht : Pairwise fun (i : Œπ) (j : Œπ) ‚Ü¶ Set.EqOn (g i) (g j) (t i ‚à© t j)),\n  ‚àÉ (f : (a : Œ±) ‚Üí Œ≤), (Measurable f : Prop) ‚àß (‚àÄ (n : Œπ), Set.EqOn f (g n) (t n) : Prop)","name":"exists_measurable_piecewise","isProp":true,"docString":"Let `t i` be a nonempty countable family of measurable sets in `Œ±`. Let `g i : Œ± ‚Üí Œ≤` be a\nfamily of measurable functions such that `g i` agrees with `g j` on `t i ‚à© t j`. Then there exists\na measurable function `f : Œ± ‚Üí Œ≤` that agrees with each `g i` on `t i`.\n\nWe only need the assumption `[Nonempty Œπ]` to prove `[Nonempty (Œ± ‚Üí Œ≤)]`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] (t : Finset Œπ) (f‚ÇÅ : (a : Œπ) ‚Üí Set Œ±) (f‚ÇÇ : (a : Œπ) ‚Üí Set Œ±)\n  (hf : ‚àÄ (i : Œπ) (a : i ‚àà t), f‚ÇÅ i ‚äÜ f‚ÇÇ i), (Finset.sum t fun (i : Œπ) ‚Ü¶ f‚ÇÅ i) ‚äÜ Finset.sum t fun (i : Œπ) ‚Ü¶ f‚ÇÇ i","name":"Set.finset_sum_subset_finset_sum","isProp":true,"docString":"An n-ary version of `Set.add_subset_add`. "},{"type":"‚àÄ {ùìï : Type u_1} {E : Type u_2} {F : Type u_3} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F]\n  [inst_2 : MonoidHomClass ùìï E F] (f : ùìï) (C : ‚Ñù) (h : ‚àÄ (x : E), ‚Äñ‚Üëf x‚Äñ ‚â§ C * ‚Äñx‚Äñ), Continuous ‚Üëf","name":"MonoidHomClass.continuous_of_bound","isProp":true,"docString":"A homomorphism `f` of seminormed groups is continuous, if there exists a constant `C` such that\nfor all `x`, one has `‚Äñf x‚Äñ ‚â§ C * ‚Äñx‚Äñ`. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [inst : Semiring k] [inst_1 : AddZeroClass G] (f : AddMonoidAlgebra k G),\n  f ‚àà Submodule.span k (‚Üë(AddMonoidAlgebra.of k G) '' ‚Üë(Finsupp.support f))","name":"AddMonoidAlgebra.mem_span_support","isProp":true,"docString":"An element of `AddMonoidAlgebra k G` is in the submodule generated by its support. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : a < 1) (hb : b < 1), a * b < 1","name":"Right.mul_lt_one'","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one'`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : NoMinOrder Œ±]\n  [inst_4 : DenselyOrdered Œ±] {a : Œ±} {s : Set Œ±},\n  (s ‚àà nhdsWithin a (Set.Iic a) : Prop) ‚Üî (‚àÉ (l : Œ±), (l < a : Prop) ‚àß (Set.Icc l a ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Iic_iff_exists_Icc_subset","isProp":true,"docString":"A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`\nwith `l < a`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {K : NNReal} {f : (a : Œ±) ‚Üí Œ±} [inst_1 : Nonempty Œ±] [inst_2 : CompleteSpace Œ±]\n  {n : ‚Ñï} (hf : ContractingWith K (f^[n])), Function.IsFixedPt f (ContractingWith.fixedPoint (f^[n]) hf)","name":"ContractingWith.isFixedPt_fixedPoint_iterate","isProp":true,"docString":"If a map `f` has a contracting iterate `f^[n]`, then the fixed point of `f^[n]` is also a fixed\npoint of `f`. "},{"type":"‚àÄ {n : ‚Ñï} {n' : ‚Ñï} (m : ‚Ñï) (i : Fin n') (h : n' = n),\n  ‚Üë(Fin.natAdd m) (‚Üë(Fin.cast h) i) =\n    ‚Üë(Fin.cast ((congr_arg (HAdd.hAdd m) h=:m + n' = m + n)=:m + n' = m + n)) (‚Üë(Fin.natAdd m) i)","name":"Fin.natAdd_cast","isProp":true,"docString":"For rewriting in the reverse direction, see `Fin.cast_natAdd_right`. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {g : Equiv.Perm Œ±} {x : Œ±} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±]\n  (hf : Equiv.Perm.IsCycle f) (hg : Equiv.Perm.IsCycle g)\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà Equiv.Perm.support f ‚à© Equiv.Perm.support g), ‚Üëf x = ‚Üëg x) (hx : ‚Üëf x = ‚Üëg x)\n  (hx' : x ‚àà Equiv.Perm.support f), f = g","name":"Equiv.Perm.IsCycle.eq_on_support_inter_nonempty_congr","isProp":true,"docString":"If two cyclic permutations agree on all terms in their intersection,\nand that intersection is not empty, then the two cyclic permutations must be equal. "},{"type":"‚àÄ {Œ± : Type u} (l : List Œ±) (n : ‚Ñï) (k : ‚Ñï) (hk : k < List.length l),\n  List.nthLe (List.rotate l n) ((List.length l - n % List.length l + k) % List.length l)\n      ((LT.lt.trans_le\n            ((Nat.mod_lt (List.length l - n % List.length l + k)\n                  ((LE.le.trans_lt ((Nat.zero_le k=:0 ‚â§ k)=:0 ‚â§ k)\n                        hk=:0 <\n                        List.length\n                          l)=:0 <\n                      List.length\n                        l)=:(List.length l - n % List.length l + k) % List.length l <\n                  List.length l)=:(List.length l - n % List.length l + k) % List.length l < List.length l)\n            ((Eq.ge\n                  ((List.length_rotate l\n                        n=:List.length (List.rotate l n) =\n                        List.length\n                          l)=:List.length (List.rotate l n) =\n                      List.length\n                        l)=:List.length l ‚â§\n                  List.length\n                    (List.rotate l\n                      n))=:List.length l ‚â§\n                List.length\n                  (List.rotate l\n                    n))=:(List.length l - n % List.length l + k) % List.length l <\n            List.length\n              (List.rotate l\n                n))=:(List.length l - n % List.length l + k) % List.length l < List.length (List.rotate l n)) =\n    List.nthLe l k hk","name":"List.nthLe_rotate'","isProp":true,"docString":"A variant of `List.nthLe_rotate` useful for rewrites from right to left. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {S : Set Œ±} {U : Set Œ±} (hS : IsPreirreducible S) (hU : IsOpen U)\n  (h : Set.Nonempty (S ‚à© U)), S ‚äÜ closure (S ‚à© U)","name":"subset_closure_inter_of_isPreirreducible_of_isOpen","isProp":true,"docString":"A nonempty open subset of a preirreducible subspace is dense in the subspace. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasKernel f] {Z : C} (h : Y ‚ü∂ Z)\n  [inst_3 : CategoryTheory.Limits.HasKernel (f ‚â´ h)],\n  CategoryTheory.Limits.kernelSubobject f ‚â§ CategoryTheory.Limits.kernelSubobject (f ‚â´ h)","name":"CategoryTheory.Limits.kernelSubobject_comp_le","isProp":true,"docString":"The kernel of `f` is always a smaller subobject than the kernel of `f ‚â´ h`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] {X : C} {Y : C} {Z : C} (a : X ‚ü∂ Y) (b : X ‚ü∂ Z)\n  [inst_5 : CategoryTheory.Epi a] [inst_6 : CategoryTheory.Epi b],\n  CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span a b)","name":"CategoryTheory.NormalEpiCategory.pushout_of_epi","isProp":true,"docString":"The pushout of two epimorphisms exists. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {s : Set R} {p : (a : R) ‚Üí Prop} {x : R} (h : x ‚àà Subring.closure s)\n  (Hs : ‚àÄ (x : R) (a : x ‚àà s), p x) (H0 : p 0) (H1 : p 1) (Hadd : ‚àÄ (x : R) (y : R) (a : p x) (a : p y), p (x + y))\n  (Hneg : ‚àÄ (x : R) (a : p x), p (-x)) (Hmul : ‚àÄ (x : R) (y : R) (a : p x) (a : p y), p (x * y)), p x","name":"Subring.closure_induction","isProp":true,"docString":"An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition, negation, and multiplication, then `p` holds for all\nelements of the closure of `s`. "},{"type":"‚àÄ {M : Type u_1} {X : Type u_2} [inst : SMul M X] [inst_1 : TopologicalSpace M] [inst_2 : TopologicalSpace X]\n  [self : ContinuousSMul M X], Continuous fun (p : M √ó X) ‚Ü¶ Prod.fst p ‚Ä¢ Prod.snd p","name":"ContinuousSMul.continuous_smul","isProp":true,"docString":"The calar multiplication `(‚Ä¢)` is continuous. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhdsWithin a (Set.Ici a))\n  (hfs : f '' s ‚àà nhdsWithin (f a) (Set.Ici (f a))), ContinuousWithinAt f (Set.Ici a) a","name":"StrictMonoOn.continuousWithinAt_right_of_image_mem_nhdsWithin","isProp":true,"docString":"If a function `f` with a densely ordered codomain is strictly monotone on a right neighborhood\nof `a` and the image of this neighborhood under `f` is a right neighborhood of `f a`, then `f` is\ncontinuous at `a` from the right. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_3} {S : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (p : Submodule R M) [inst_3 : Semiring S] [inst_4 : SMul S R] [inst_5 : Module S M] [inst_6 : IsScalarTower S R M],\n  Submodule.span S ‚Üëp = Submodule.restrictScalars S p","name":"Submodule.span_coe_eq_restrictScalars","isProp":true,"docString":"A version of `submodule.span_eq` for when the span is by a smaller ring. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] {p1 : P} {p2 : P} {p : P},\n  (p1 -·µ• p = p2 -·µ• p : Prop) ‚Üî (p1 = p2 : Prop)","name":"vsub_left_cancel_iff","isProp":true,"docString":"The same point subtracted from two points produces equal results\nif and only if those points are equal. "},{"type":"‚àÄ {G : Type u} [inst : AddGroup G] (B : AddGroupFilterBasis G), TopologicalAddGroup G","name":"AddGroupFilterBasis.isTopologicalAddGroup","isProp":true,"docString":"If a group is endowed with a topological structure coming from a group filter basis\nthen it's a topological group."},{"type":"‚àÄ {Œ± : Type u} [inst : OrderedRing Œ±] {a : Œ±} {b : Œ±} (hb : b ‚â§ 0) (h : a ‚â§ 1), b ‚â§ a * b","name":"le_mul_of_le_one_left","isProp":true,"docString":"Variant of `mul_le_of_le_one_left` for `b` non-positive instead of non-negative.  "},{"type":"‚àÄ {Œ≥ : Type w} [inst : LinearOrder Œ≥] {a : Œ≥} {b : Œ≥} {s : Set Œ≥} {t : Set Œ≥} (ha : IsGreatest s a)\n  (hb : IsGreatest t b), IsGreatest (s ‚à™ t) (max a b)","name":"IsGreatest.union","isProp":true,"docString":"If `a` is the greatest element of `s` and `b` is the greatest element of `t`,\nthen `max a b` is the greatest element of `s ‚à™ t`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : SuccOrder Œ±] {a : Œ±} (a_1 : IsMax a), Order.succ a = a","name":"IsMax.succ_eq","isProp":true,"docString":"**Alias** of the reverse direction of `Order.succ_eq_iff_isMax`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {r : Œ±} {s : Œ±},\n  (Finset.toColex {r} ‚â§ Finset.toColex {s} : Prop) ‚Üî (r ‚â§ s : Prop)","name":"Colex.singleton_le_iff_le","isProp":true,"docString":"Colex is an extension of the base ordering on Œ±. "},{"type":"‚àÄ {Œπ : Type u_1} {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_3} [inst : CommRing R‚ÇÇ] [inst_1 : AddCommGroup M‚ÇÇ] [inst_2 : Module R‚ÇÇ M‚ÇÇ]\n  [inst_3 : DecidableEq Œπ] (e : Basis Œπ R‚ÇÇ M‚ÇÇ) {w : (a : Œπ) ‚Üí R‚ÇÇ} (hw : ‚àÄ (i : Œπ), IsUnit (w i)),\n  Basis.toMatrix e ‚Üë(Basis.isUnitSMul e hw) = Matrix.diagonal w","name":"Basis.toMatrix_isUnitSMul","isProp":true,"docString":"The basis constructed by `isUnitSMul` has vectors given by a diagonal matrix. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : ‚Ñï) {w : M} {x : M} (a : ‚Üëc w x), ‚Üëc (w ^ n) (x ^ n)","name":"Con.pow","isProp":true,"docString":"Multiplicative congruence relations preserve natural powers. "},{"type":"‚àÄ {R : Type u_2} [inst : StrictOrderedCommSemiring R] {M : Type u_1} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {v‚ÇÅ : M} {v‚ÇÇ : M} (hv‚ÇÅ : v‚ÇÅ ‚â† 0) (hv‚ÇÇ : v‚ÇÇ ‚â† 0),\n  (rayOfNeZero R v‚ÇÅ hv‚ÇÅ = rayOfNeZero R v‚ÇÇ hv‚ÇÇ : Prop) ‚Üî (SameRay R v‚ÇÅ v‚ÇÇ : Prop)","name":"ray_eq_iff","isProp":true,"docString":"The rays given by two nonzero vectors are equal if and only if those vectors\nsatisfy `SameRay`. "},{"type":"‚àÄ {M : Type u_1} [inst : Semigroup M] [inst_1 : Nonempty M] (s : Set (Set M)) (sfin : Set.Finite s) (scov : ‚ä§ ‚äÜ ‚ãÉ‚ÇÄ s),\n  ‚àÉ (c : Set M), (c ‚àà s : Prop) ‚àß (‚àÉ (a : Stream' M), Hindman.FP a ‚äÜ c : Prop)","name":"Hindman.exists_FP_of_finite_cover","isProp":true,"docString":"The weak form of **Hindman's theorem**: in any finite cover of a nonempty semigroup, one of the\nparts contains an FP-set. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_1} [inst : DecidableEq Œ≥] {f : (a : Œ±) ‚Üí (a : Œ≥) ‚Üí Œ≥} {a : Œ±} (h : ‚àÄ (b : Œ≥), f a b = b)\n  (t : Finset Œ≥), Finset.image‚ÇÇ f {a} t = t","name":"Finset.image‚ÇÇ_left_identity","isProp":true,"docString":"If `a` is a left identity for `f : Œ± ‚Üí Œ≤ ‚Üí Œ≤`, then `{a}` is a left identity for\n`Finset.image‚ÇÇ f`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Type u_1} [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] {A : (a : Œπ) ‚Üí Submodule R M} (h : DirectSum.IsInternal A), sup·µ¢ A = ‚ä§","name":"DirectSum.IsInternal.submodule_sup·µ¢_eq_top","isProp":true,"docString":"If a direct sum of submodules is internal then the submodules span the module. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} {f : Filter Œ±} {g : Filter Œ≤} {h : Filter Œ≥}\n  {k : Filter Œ¥},\n  Filter.map\n      (fun (p : (Œ± √ó Œ≤) √ó Œ≥ √ó Œ¥) ‚Ü¶\n        ((Prod.fst (Prod.fst p), Prod.fst (Prod.snd p)), Prod.snd (Prod.fst p), Prod.snd (Prod.snd p)))\n      (Filter.prod (Filter.prod f g) (Filter.prod h k)) =\n    Filter.prod (Filter.prod f h) (Filter.prod g k)","name":"Filter.map_swap4_prod","isProp":true,"docString":"A useful lemma when dealing with uniformities. "},{"type":"‚àÄ {Œ± : Type u_3} {Œπ : Type u_1} {Œπ' : Type u_2} [inst : DistribLattice Œ±] [inst_1 : OrderBot Œ±] [inst_2 : DecidableEq Œπ]\n  {s : Finset Œπ'} {g : (a : Œπ') ‚Üí Finset Œπ} {f : (a : Œπ) ‚Üí Œ±} (hs : Finset.SupIndep s fun (i : Œπ') ‚Ü¶ Finset.sup (g i) f)\n  (hg : ‚àÄ (i' : Œπ') (a : i' ‚àà s), Finset.SupIndep (g i') f), Finset.SupIndep (Finset.bunion·µ¢ s g) f","name":"Finset.SupIndep.bunion·µ¢","isProp":true,"docString":"Bind operation for `SupIndep`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {x : Œ±} (hab : a ‚ãñ b) (hbc : b ‚ãñ c) (hax : a < x)\n  (hxc : x < c), x = b","name":"Covby.eq_of_between","isProp":true,"docString":"If `a`, `b`, `c` are consecutive and `a < x < c` then `x = b`. "},{"type":"‚àÄ {Œ± : Type u_2} {ùïú : Type u_1} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {S : Set Œ±} [inst : TopologicalSpace Œ±]\n  [inst_1 : TopologicalSpace ùïú] [inst_2 : T1Space ùïú] [inst_3 : Field ùïú] [inst_4 : HasContinuousInv‚ÇÄ ùïú]\n  [inst_5 : ContinuousMul ùïú] (hS : IsPreconnected S) (hf : ContinuousOn f S) (hg : ContinuousOn g S)\n  (hsq : Set.EqOn (f ^ 2) (g ^ 2) S) (hg_ne : ‚àÄ {x : Œ±} (a : x ‚àà S), g x ‚â† 0) {y : Œ±} (hy : y ‚àà S) (hy' : f y = g y),\n  Set.EqOn f g S","name":"IsPreconnected.eq_of_sq_eq","isProp":true,"docString":"If `f, g` are functions `Œ± ‚Üí ùïú`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ‚â† 0` all `z ‚àà S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ] (h : 0 = 1) (a : M‚ÇÄ), a = 0","name":"eq_zero_of_zero_eq_one","isProp":true,"docString":"In a monoid with zero, if zero equals one, then zero is the only element. "},{"type":"‚àÄ (M : Type u_1) (N : Type u_2) (Œ± : Type u_3) [inst : SMul M Œ±] [inst_1 : SMul N Œ±] [inst_2 : SMulCommClass M N Œ±],\n  SMulCommClass N M Œ±","name":"SMulCommClass.symm","isProp":true,"docString":"Commutativity of actions is a symmetric relation. This lemma can't be an instance because this\nwould cause a loop in the instance search graph. "},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {a‚ÇÅ : X} {a‚ÇÇ : X} {a‚ÇÉ : X}\n  {b‚ÇÅ : Y} {b‚ÇÇ : Y} {b‚ÇÉ : Y} (Œ≥‚ÇÅ : Path a‚ÇÅ a‚ÇÇ) (Œ¥‚ÇÅ : Path a‚ÇÇ a‚ÇÉ) (Œ≥‚ÇÇ : Path b‚ÇÅ b‚ÇÇ) (Œ¥‚ÇÇ : Path b‚ÇÇ b‚ÇÉ),\n  Path.trans (Path.prod Œ≥‚ÇÅ Œ≥‚ÇÇ) (Path.prod Œ¥‚ÇÅ Œ¥‚ÇÇ) = Path.prod (Path.trans Œ≥‚ÇÅ Œ¥‚ÇÅ) (Path.trans Œ≥‚ÇÇ Œ¥‚ÇÇ)","name":"Path.trans_prod_eq_prod_trans","isProp":true,"docString":"Path composition commutes with products "},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\n  {f : (a : X) ‚Üí Y} (hf : Embedding f), DiscreteTopology X","name":"Embedding.discreteTopology","isProp":true,"docString":"The topology induced under an inclusion `f : X ‚Üí Y` from the discrete topological space `Y`\nis the discrete topology on `X`. "},{"type":"‚àÄ {E : Sort u_2} {Œ± : Sort u_3} {Œ≤ : Sort u_1} [iE : EquivLike E Œ± Œ≤] (e : E) (b : Œ≤), ‚Üëe (EquivLike.inv e b) = b","name":"EquivLike.apply_inv_apply","isProp":true,"docString":"This lemma is only supposed to be used in the generic context, when working with instances\nof classes extending `EquivLike`.\nFor concrete isomorphism types such as `Equiv`, you should use `Equiv.apply_symm_apply`\nor its equivalent.\n\nTODO: define a generic form of `Equiv.symm`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} (h‚ÇÅ : min a b < max c d)\n  (h‚ÇÇ : min c d < max a b), Set.Icc a b ‚à™ Set.Icc c d = Set.Icc (min a c) (max b d)","name":"Set.Icc_union_Icc","isProp":true,"docString":"We cannot replace `<` by `‚â§` in the hypotheses.\nOtherwise for `b < a = d < c` the l.h.s. is `‚àÖ` and the r.h.s. is `{a}`.\n"},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddMonoid M] [inst_1 : AddMonoid N] (f : M ‚Üí+ N) (l : List M),\n  ‚Üëf (List.sum l) = List.sum (List.map (‚Üëf) l)","name":"AddMonoidHom.map_list_sum","isProp":true,"docString":"Deprecated, use `_root_.map_list_sum` instead."},{"type":"‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] {x : F} {y : F} (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ),\n  (SameRay ‚Ñù x y : Prop) ‚Üî (x = y : Prop)","name":"sameRay_iff_of_norm_eq","isProp":true,"docString":"Two vectors of the same norm are on the same ray if and only if they are equal. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) (x : M), ‚Üëc x x","name":"AddCon.refl","isProp":true,"docString":"Additive congruence relations are reflexive."},{"type":"Function.Injective Fin","name":"fin_injective","isProp":true,"docString":"`Fin` as a map from `‚Ñï` to `Type` is injective. Note that since this is a statement about\nequality of types, using it should be avoided if possible. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  (a_1 : 1 < a‚Åª¬π), a < 1","name":"inv_of_one_lt_inv","isProp":true,"docString":"**Alias** of the forward direction of `Left.one_lt_inv_iff`."},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} (hq : q ‚â† 0) {k : ‚Ñï}, padicValRat p (q ^ k) = ‚Üëk * padicValRat p q","name":"padicValRat.pow","isProp":true,"docString":"A rewrite lemma for `padicValRat p (q^k)` with condition `q ‚â† 0`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (self : AddSubmonoid M),\n  0 ‚àà AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup self)","name":"AddSubmonoid.zero_mem'","isProp":true,"docString":"An additive submonoid contains `0`. "},{"type":"‚àÄ {M : Type u_1} [inst : Nonempty M] [inst : AddSemigroup M] [inst_1 : TopologicalSpace M] [inst_2 : CompactSpace M]\n  [inst_3 : T2Space M] (continuous_mul_left : ‚àÄ (r : M), Continuous fun (x : M) ‚Ü¶ x + r), ‚àÉ (m : M), m + m = m","name":"exists_idempotent_of_compact_t2_of_continuous_add_left","isProp":true,"docString":"Any nonempty compact Hausdorff additive semigroup where right-addition is continuous\ncontains an idempotent, i.e. an `m` such that `m + m = m`"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] (X : C)\n  (h : ‚àÄ {Z : C} (f : X ‚ü∂ Z) [inst_2 : CategoryTheory.Epi f], (CategoryTheory.IsIso f : Prop) ‚Üî (f ‚â† 0 : Prop)),\n  CategoryTheory.Simple X","name":"CategoryTheory.simple_of_cosimple","isProp":true,"docString":"In an abelian category, an object satisfying the dual of the definition of a simple object is\nsimple. "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} [inst : DecidableEq V] {u : V} {v : V} {w : V} (p : SimpleGraph.Walk G v w)\n  (h : u ‚àà SimpleGraph.Walk.support p),\n  SimpleGraph.Walk.append (SimpleGraph.Walk.takeUntil p u h) (SimpleGraph.Walk.dropUntil p u h) = p","name":"SimpleGraph.Walk.take_spec","isProp":true,"docString":"The `takeUntil` and `dropUntil` functions split a walk into two pieces.\nThe lemma `SimpleGraph.Walk.count_support_takeUntil_eq_one` specifies where this split occurs. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] [inst_1 : Nontrivial R] {p : (a : Fin 2) ‚Üí R} (h : IsCoprime (p 0) (p 1)), p ‚â† 0","name":"IsCoprime.ne_zero","isProp":true,"docString":"If a 2-vector `p` satisfies `IsCoprime (p 0) (p 1)`, then `p ‚â† 0`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {c : Con M} {f : (a : M) ‚Üí N}\n  (H : ‚àÄ (x : M) (y : M), f (x * y) = f x * f y) (h : Con.mulKer f H ‚â§ c) (hf : Function.Surjective f),\n  Con.mapGen c f = Con.mapOfSurjective c f H h hf","name":"Con.mapOfSurjective_eq_mapGen","isProp":true,"docString":"A specialization of 'the smallest congruence relation containing a congruence relation `c`\nequals `c`'. "},{"type":"‚àÄ {P : Type u_1} [inst : LE P] {I : Set P} (self : Order.IsIdeal I), IsLowerSet I","name":"Order.IsIdeal.IsLowerSet","isProp":true,"docString":"The ideal is downward closed. "},{"type":"‚àÄ {as : List Prop} {ps : List Prop} {p : Prop} (as‚ÇÅ : List Prop) (a : as = List.reverseAux as‚ÇÅ ps)\n  (a : Sat.Valuation.implies (Sat.Valuation.mk as) (p : Prop) ps (List.length as‚ÇÅ)), p","name":"Sat.Valuation.mk_implies","isProp":true,"docString":"The fundamental relationship between `mk` and `implies`:\n`(mk ps).implies p ps 0` is equivalent to `p`. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : CommMonoid Œ≤] {n : ‚Ñï} (f : (a : Fin (n + 1)) ‚Üí Œ≤) (x : Fin (n + 1)),\n  (Finset.prod Finset.univ fun (i : Fin (n + 1)) ‚Ü¶ f i) =\n    f x * Finset.prod Finset.univ fun (i : Fin n) ‚Ü¶ f (‚Üë(Fin.succAbove x) i)","name":"Fin.prod_univ_succAbove","isProp":true,"docString":"A product of a function `f : Fin (n + 1) ‚Üí Œ≤` over all `Fin (n + 1)`\nis the product of `f x`, for some `x : Fin (n + 1)` times the remaining product "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C·µí·µñ} {Y : C·µí·µñ} (f : X ‚ü∂ Y)\n  [inst_1 : CategoryTheory.IsIso (Prefunctor.map (CategoryTheory.Functor.toPrefunctor CategoryTheory.coyoneda) f)],\n  CategoryTheory.IsIso f","name":"CategoryTheory.Coyoneda.isIso","isProp":true,"docString":"If `coyoneda.map f` is an isomorphism, so was `f`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} (a : Finset.Nonempty s), 0 < Finset.card s","name":"Finset.Nonempty.card_pos","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.card_pos`."},{"type":"‚àÄ {Œ± : Type uu} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : DecidableRel r] (a : Œ±) (l : List Œ±),\n  List.orderedInsert r a l =\n    List.takeWhile (fun (b : Œ±) ‚Ü¶ decide (¬¨(r a b : Prop) : Prop)) l ++\n      a :: List.dropWhile (fun (b : Œ±) ‚Ü¶ decide (¬¨(r a b : Prop) : Prop)) l","name":"List.orderedInsert_eq_take_drop","isProp":true,"docString":"An alternative definition of `orderedInsert` using `takeWhile` and `dropWhile`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : Œ± ‚âÉ. Œ≤} (h : ‚àÄ (a : Œ±), Option.isSome (‚Üëf a) = true), Function.Injective ‚Üëf","name":"PEquiv.injective_of_forall_isSome","isProp":true,"docString":"If the domain of a `PEquiv` is all of `Œ±`, its forward direction is injective. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : DecidableEq Œ±] [inst_1 : DecidableEq Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (s : Multiset Œ±)\n  (hf : Function.Injective f) (x : Œ±), Multiset.count (f x) (Multiset.map f s) = Multiset.count x s","name":"Multiset.count_map_eq_count'","isProp":true,"docString":"`Multiset.map f` preserves `count` if `f` is injective "},{"type":"‚àÄ {C : Type u_4} [inst : CategoryTheory.Category C] {D : Type u_1} [inst_1 : CategoryTheory.Category D] (Œµ : C ‚âå D),\n  (CategoryTheory.IsIdempotentComplete C : Prop) ‚Üî (CategoryTheory.IsIdempotentComplete D : Prop)","name":"CategoryTheory.Idempotents.isIdempotentComplete_iff_of_equivalence","isProp":true,"docString":"If `C` and `D` are equivalent categories, that `C` is idempotent complete iff `D` is. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {A : CategoryTheory.Limits.Cone F} {B : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.ConeMorphism A B)\n  (j : J),\n  CategoryTheory.Limits.ConeMorphism.Hom self ‚â´ (CategoryTheory.Limits.Cone.œÄ B).app j =\n    (CategoryTheory.Limits.Cone.œÄ A).app j","name":"CategoryTheory.Limits.ConeMorphism.w","isProp":true,"docString":"The triangle consisting of the two natural tranformations and `Hom` commutes "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasLimitsOfSize C] (J : Type u‚ÇÅ)\n  [inst_1 : CategoryTheory.Category J], CategoryTheory.Limits.HasLimitsOfShape J C","name":"CategoryTheory.Limits.HasLimitsOfSize.has_limits_of_shape","isProp":true,"docString":"All functors `F : J ‚•§ C` from all small `J` have limits "},{"type":"‚àÄ {F : Type u_1} {E : Type u_2} [inst : Field F] [inst_1 : Ring E] [inst_2 : Algebra F E] {S : Subalgebra F E},\n  (FiniteDimensional F { x : E // x ‚àà ‚ÜëSubalgebra.toSubmodule S } : Prop) ‚Üî\n    (FiniteDimensional F { x : E // x ‚àà S } : Prop)","name":"Subalgebra.finiteDimensional_toSubmodule","isProp":true,"docString":"A `Subalgebra` is `FiniteDimensional` iff it is `FiniteDimensional` as a submodule. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type v'}\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'] (f : M ‚Üí‚Çó[R] M'),\n  Cardinal.lift (Module.rank R { x : M' // x ‚àà LinearMap.range f }) ‚â§ Cardinal.lift (Module.rank R M)","name":"lift_rank_range_le","isProp":true,"docString":"The rank of the range of a linear map is at most the rank of the source. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ‚Ñï) [hp : Fact (Nat.Prime p : Prop)]\n  (hdvd : p ‚à£ Fintype.card G), ‚àÉ (x : G), orderOf x = p","name":"exists_prime_orderOf_dvd_card","isProp":true,"docString":"For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : SuccOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a < b), SuccOrder.succ a ‚â§ b","name":"SuccOrder.succ_le_of_lt","isProp":true,"docString":"Proof that `succ` satifies ordering invariants betweeen `LT` and `LE`"},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type u_1}\n  [inst_3 : Fintype Œπ] {b : (a : Œπ) ‚Üí V},\n  (LinearIndependent K b : Prop) ‚Üî (Fintype.card Œπ = Set.finrank K (Set.range b) : Prop)","name":"linearIndependent_iff_card_eq_finrank_span","isProp":true,"docString":"A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. "},{"type":"‚àÄ (a : Ordinal),\n  ‚àÉ (f : (b : Ordinal) ‚Üí (a : b < Cardinal.ord (Ordinal.cof a)) ‚Üí Ordinal),\n    Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f","name":"Ordinal.exists_fundamental_sequence","isProp":true,"docString":"Every ordinal has a fundamental sequence. "},{"type":"‚àÄ {G : Type u} {x : G} {y : G} [inst : AddMonoid G] (h : AddCommute x y) (hx : IsOfFinAddOrder x)\n  (hy : IsOfFinAddOrder y), IsOfFinAddOrder (x + y)","name":"AddCommute.isOfFinAddOrder_add","isProp":true,"docString":"Commuting elements of finite additive order are closed under addition."},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : Monoid A] [inst_1 : SMul R A] [inst_2 : IsScalarTower R A A]\n  [inst_3 : TopologicalSpace A] [inst : ContinuousMul A], ContinuousConstSMul R A","name":"IsScalarTower.continuousConstSMul","isProp":true,"docString":"If `R` acts on `A` via `A`, then continuous multiplication implies continuous scalar\nmultiplication by constants.\n\nNotably, this instances applies when `R = A`, or when `[Algebra R A]` is available. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {b‚ÇÅ : Basis Œπ R M} {b‚ÇÇ : Basis Œπ R M} (h : ‚àÄ (x : M) (i : Œπ), ‚Üë(‚Üë(Basis.repr b‚ÇÅ) x) i = ‚Üë(‚Üë(Basis.repr b‚ÇÇ) x) i),\n  b‚ÇÅ = b‚ÇÇ","name":"Basis.eq_ofRepr_eq_repr","isProp":true,"docString":"Two bases are equal if they assign the same coordinates. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±},\n  (s ‚àà Finset.shadow ùíú : Prop) ‚Üî (‚àÉ (a : Œ±), ‚àÉ (x : ¬¨(a ‚àà s : Prop)), insert a s ‚àà ùíú : Prop)","name":"Finset.mem_shadow_iff_insert_mem","isProp":true,"docString":"`t` is in the shadow of `ùíú` iff we can add an element to it so that the resulting finset is in\n`ùíú`. "},{"type":"‚àÄ {A : Type u_1} [inst : AddMonoid A] {s : Set A} (self : IsAddSubmonoid s), 0 ‚àà s","name":"IsAddSubmonoid.zero_mem","isProp":true,"docString":"The proposition that s contains 0. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero M] [inst_1 : CommMonoid N] {s : Finset Œ±} {f : (a : Œ±) ‚Üí M}\n  {g : (a : Œ±) ‚Üí (a : M) ‚Üí N} (hf : ‚àÄ (a : Œ±) (a_1 : f a ‚â† 0), a ‚àà s) (hg : ‚àÄ (a : Œ±), g a 0 = 1),\n  Finsupp.prod (Finsupp.onFinset s f hf) g = Finset.prod s fun (a : Œ±) ‚Ü¶ g a (f a)","name":"Finsupp.onFinset_prod","isProp":true,"docString":"If `g` maps a second argument of 0 to 1, then multiplying it over the\nresult of `onFinset` is the same as multiplying it over the original `Finset`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : CoheytingAlgebra Œ±]\n  [inst_1 : CoheytingAlgebra Œ≤] [self : CoheytingHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä§ = ‚ä§","name":"CoheytingHomClass.map_top","isProp":true,"docString":"The proposition that a co-Heyting homomorphism preserves the top element."},{"type":"‚àÄ {B : Type u_2} {F : Type u_1} {Z : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  {proj : (a : Z) ‚Üí B} [inst_2 : Nonempty F], Function.Injective Pretrivialization.toLocalEquiv","name":"Pretrivialization.toLocalEquiv_injective","isProp":true,"docString":"If the fiber is nonempty, then the projection to "},{"type":"‚àÄ {M‚ÇÄ : Type u} [self : MonoidWithZero M‚ÇÄ] (a : M‚ÇÄ), 0 * a = 0","name":"MonoidWithZero.zero_mul","isProp":true,"docString":"Zero is a left absorbing element for multiplication "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Finset Œ±} {k : ‚Ñï} (h : Finset.card s = k) (hz : 0 < k),\n  ‚Üë(Finset.orderEmbOfFin s h) { val := 0, isLt := hz } =\n    Finset.min' s\n      ((Iff.mp\n            ((Finset.card_pos=:(0 < Finset.card s : Prop) ‚Üî\n                  (Finset.Nonempty s : Prop))=:(0 < Finset.card s : Prop) ‚Üî (Finset.Nonempty s : Prop))\n            ((Eq.rec hz\n                  ((Eq.symm\n                        h=:k =\n                        Finset.card\n                          s)=:k =\n                      Finset.card s)=:0 < Finset.card s)=:0 < Finset.card s)=:Finset.Nonempty s)=:Finset.Nonempty s)","name":"Finset.orderEmbOfFin_zero","isProp":true,"docString":"The bijection `orderEmbOfFin s h` sends `0` to the minimum of `s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : AddCommMonoid M] {s : Set Œ±} {t : Set Œ≤} {f : (a : Œ±) ‚Üí M}\n  {g : (a : Œ≤) ‚Üí M} (e : (a : Œ±) ‚Üí Œ≤) (he‚ÇÄ : Set.BijOn e s t) (he‚ÇÅ : ‚àÄ (x : Œ±) (a : x ‚àà s), f x = g (e x)),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) = finsum fun (j : Œ≤) ‚Ü¶ finsum fun (h : j ‚àà t) ‚Ü¶ g j","name":"finsum_mem_eq_of_bijOn","isProp":true,"docString":"See also `Finset.sum_bij`."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =O[l] fun (x : Œ±) ‚Ü¶ -g' x), f =O[l] g'","name":"Asymptotics.IsBigO.of_neg_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigO_neg_right`."},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K : Set G} {U : Set G}\n  (hK : IsCompact K) (hU : IsOpen U) (hKU : K ‚äÜ U), ‚àÉ (V : Set G), (V ‚àà nhds 0 : Prop) ‚àß (V + K ‚äÜ U : Prop)","name":"compact_open_separated_add_left","isProp":true,"docString":"Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of\n`0` such that `V + K ‚äÜ U`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {p : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop} {x‚ÇÄ : (a : Œ±) √ó Subtype (p a)}\n  {x‚ÇÅ : (a : Œ±) √ó Subtype (p a)} (a : Sigma.fst x‚ÇÄ = Sigma.fst x‚ÇÅ) (a : ‚Üë(Sigma.snd x‚ÇÄ) = ‚Üë(Sigma.snd x‚ÇÅ)), x‚ÇÄ = x‚ÇÅ","name":"Sigma.subtype_ext","isProp":true,"docString":"A specialized ext lemma for equality of sigma types over an indexed subtype. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommMonoid M] [inst_2 : Nontrivial R] {m : M}\n  {S : Set M}, (AddMonoidAlgebra.of' R M m ‚àà Submodule.span R (AddMonoidAlgebra.of' R M '' S) : Prop) ‚Üî (m ‚àà S : Prop)","name":"AddMonoidAlgebra.of'_mem_span","isProp":true,"docString":"The image of an element `m : M` in `AddMonoidAlgebra R M` belongs the submodule generated by\n`S : Set M` if and only if `m ‚àà S`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C","name":"CategoryTheory.Limits.hasZeroObject_of_hasFiniteBiproducts","isProp":true,"docString":"A category with finite biproducts has a zero object. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] (x : Œ±) {s : Set Œ±} (hs : s ‚àà nhds x)\n  (hsf : Set.Finite s), IsOpen {x}","name":"isOpen_singleton_of_finite_mem_nhds","isProp":true,"docString":"A point with a finite neighborhood has to be isolated. "},{"type":"‚àÄ {s : Set ‚Ñù} (a : IsPreconnected s), Convex ‚Ñù s","name":"IsPreconnected.convex","isProp":true,"docString":"**Alias** of the reverse direction of `Real.convex_iff_isPreconnected`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : CompactSpace Œ≤], CompactSpace (Œ± ‚äï Œ≤)","name":"instCompactSpaceSumInstTopologicalSpaceSum","isProp":true,"docString":"The disjoint union of two compact spaces is compact. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ≤] [inst_1 : T2Space Œ≤], T2Space (UniformFun Œ± Œ≤)","name":"UniformFun.instT2SpaceUniformFunTopologicalSpace","isProp":true,"docString":"The topology of uniform convergence is T‚ÇÇ. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (Cf : ContinuousAt f (inf‚Çõ s)) (Af : Antitone f) (ftop : f ‚ä§ = ‚ä•), f (inf‚Çõ s) = sup‚Çõ (f '' s)","name":"Antitone.map_inf‚Çõ_of_continuousAt","isProp":true,"docString":"An antitone function `f` sending `top` to `bot` and continuous at the infimum of a set sends\nthis infimum to the supremum of the image of this set. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] (P : C) (Q : C),\n  CategoryTheory.Iso.hom (CategoryTheory.Limits.biprod.braiding P Q) ‚â´\n      CategoryTheory.Iso.hom (CategoryTheory.Limits.biprod.braiding Q P) =\n    ùüô (P ‚äû Q)","name":"CategoryTheory.Limits.biprod.symmetry","isProp":true,"docString":"The braiding isomorphism is symmetric. "},{"type":"‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] {x : F} {y : F} (hx : x ‚â† 0) (hy : y ‚â† 0),\n  (SameRay ‚Ñù x y : Prop) ‚Üî (‚Äñx‚Äñ‚Åª¬π ‚Ä¢ x = ‚Äñy‚Äñ‚Åª¬π ‚Ä¢ y : Prop)","name":"sameRay_iff_inv_norm_smul_eq_of_ne","isProp":true,"docString":"Two nonzero vectors `x y` in a real normed space are on the same ray if and only if the unit\nvectors `‚Äñx‚Äñ‚Åª¬π ‚Ä¢ x` and `‚Äñy‚Äñ‚Åª¬π ‚Ä¢ y` are equal. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (e : LocalHomeomorph Œ± Œ≤),\n  LocalHomeomorph.trans e (LocalHomeomorph.symm e) ‚âà\n    LocalHomeomorph.ofSet (LocalEquiv.source (LocalHomeomorph.toLocalEquiv e))\n      ((LocalHomeomorph.open_source\n            e=:IsOpen\n            (LocalEquiv.source\n              (LocalHomeomorph.toLocalEquiv e)))=:IsOpen (LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)))","name":"LocalHomeomorph.trans_self_symm","isProp":true,"docString":"Composition of a local homeomorphism and its inverse is equivalent to the restriction of the\nidentity to the source "},{"type":"‚àÄ (n : ‚Ñï), (Finset.sum (Finset.range (n + 1)) fun (m : ‚Ñï) ‚Ü¶ Nat.choose n m) = 2 ^ n","name":"Nat.sum_range_choose","isProp":true,"docString":"The sum of entries in a row of Pascal's triangle "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommRing R] {M : Type u_3} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {BR : RingFilterBasis R} {B : (a : Œπ) ‚Üí Submodule R M} (self : RingFilterBasis.SubmodulesBasis BR B) (i : Œπ) (j : Œπ),\n  ‚àÉ (k : Œπ), B k ‚â§ B i ‚äì B j","name":"RingFilterBasis.SubmodulesBasis.inter","isProp":true,"docString":"Condition for `B` to be a filter basis on `M`. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroClass M‚ÇÄ] [inst_1 : NoZeroDivisors M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ},\n  (a * b ‚â† 0 : Prop) ‚Üî (b * a ‚â† 0 : Prop)","name":"mul_ne_zero_comm","isProp":true,"docString":"If `Œ±` has no zero divisors, then for elements `a, b : Œ±`, `a * b` is nonzero iff so is\n`b * a`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Bornology Œ±] {s : Set Œ±} (a : Bornology.IsCobounded s), Bornology.IsBounded (s·∂ú)","name":"Bornology.IsCobounded.compl","isProp":true,"docString":"**Alias** of the reverse direction of `Bornology.isBounded_compl_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedOrderedGroup Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx / y‚Äñ","name":"NormedOrderedGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {E : Sort u_1} {Œ± : outParam (Sort u_2)} {Œ≤ : outParam (Sort u_3)} [self : EquivLike E Œ± Œ≤] (e : E) (g : E)\n  (a : EquivLike.coe e = EquivLike.coe g) (a : EquivLike.inv e = EquivLike.inv g), e = g","name":"EquivLike.coe_injective'","isProp":true,"docString":"If two coercions to functions are jointly injective. "},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeGroup.Red L (FreeGroup.reduce L)","name":"FreeGroup.reduce.red","isProp":true,"docString":"The first theorem that characterises the function `reduce`: a word reduces to its maximal\nreduction. "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_1} {N : Type u_2} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid N] {s : Set Œ±}\n  {f : (a : Œ±) ‚Üí M} (g : M ‚Üí+ N) (h‚ÇÄ : Set.Finite (s ‚à© Function.support f)),\n  ‚Üëg (finsum fun (j : Œ±) ‚Ü¶ finsum fun (h : j ‚àà s) ‚Ü¶ f j) = finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ ‚Üëg (f i)","name":"AddMonoidHom.map_finsum_mem'","isProp":true,"docString":"A more general version of `AddMonoidHom.map_finsum_mem` that requires\n`s ‚à© support f` rather than `s` to be finite."},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Inf Œ±] [inst_1 : Inf Œ≤] [inst_2 : Top Œ±]\n  [inst_3 : Top Œ≤] [self : InfTopHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä§ = ‚ä§","name":"InfTopHomClass.map_top","isProp":true,"docString":"An `InfTopHomClass` morphism preserves the top element. "},{"type":"‚àÄ {K : Type v} [inst : Field K] {P : Polynomial K} (hmo : Polynomial.Monic P) (hP : Polynomial.Splits (RingHom.id K) P),\n  Polynomial.nextCoeff P = -Multiset.sum (Polynomial.roots P)","name":"Polynomial.sum_roots_eq_nextCoeff_of_monic_of_split","isProp":true,"docString":"If `P` is a monic polynomial that splits, then `P.nextCoeff` equals the sum of the roots. "},{"type":"‚àÄ {Œ± : Type v} {s : Finset Œ±} {M : Type u_1} [inst : AddCommMonoid M] (f : (a : Œ±) ‚Üí M) (p : (a : M) ‚Üí Prop)\n  (hom : ‚àÄ (a : M) (b : M) (a_1 : p a) (a_2 : p b), p (a + b)) (nonempty : Finset.Nonempty s)\n  (base : ‚àÄ (x : Œ±) (a : x ‚àà s), p (f x)), p (Finset.sum s fun (x : Œ±) ‚Ü¶ f x)","name":"Finset.sum_induction_nonempty","isProp":true,"docString":"To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : NonUnitalNonAssocSemiring Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} {g : (a : ‚Ñï) ‚Üí Œ±}\n  [inst_2 : T3Space Œ±] [inst_3 : TopologicalSemiring Œ±] (hf : Summable f) (hg : Summable g)\n  (hfg : Summable fun (x : ‚Ñï √ó ‚Ñï) ‚Ü¶ f (Prod.fst x) * g (Prod.snd x)),\n  ((tsum fun (n : ‚Ñï) ‚Ü¶ f n) * tsum fun (n : ‚Ñï) ‚Ü¶ g n) =\n    tsum fun (n : ‚Ñï) ‚Ü¶ Finset.sum (Finset.Nat.antidiagonal n) fun (kl : ‚Ñï √ó ‚Ñï) ‚Ü¶ f (Prod.fst kl) * g (Prod.snd kl)","name":"tsum_mul_tsum_eq_tsum_sum_antidiagonal","isProp":true,"docString":"The **Cauchy product formula** for the product of two infinites sums indexed by `‚Ñï`, expressed\nby summing on `Finset.Nat.antidiagonal`.\n\nSee also `tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm` if `f` and `g` are absolutely\nsummable. "},{"type":"‚àÄ {g : Equiv.Perm (Fin 5)} (h : 3 ‚àà Equiv.Perm.cycleType g), Equiv.Perm.IsThreeCycle (g * g)","name":"Equiv.Perm.isThreeCycle_sq_of_three_mem_cycleType_five","isProp":true,"docString":"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (I : Ideal R) (f : R ‚âÉ+* S),\n  Ideal.map (‚Üëf) I = Ideal.comap (RingEquiv.symm f) I","name":"Ideal.map_comap_of_equiv","isProp":true,"docString":"If `f : R ‚âÉ+* S` is a ring isomorphism and `I : Ideal R`, then `map f I = comap f.symm I`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] (r : ‚Ñù) (C : ‚Ñù) (hr : r < 1) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu : ‚àÄ (n : ‚Ñï), dist (f n) (f (n + 1)) ‚â§ C * r ^ n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) (n : ‚Ñï),\n  dist (f n) a ‚â§ C * r ^ n / (1 - r)","name":"dist_le_of_le_geometric_of_tendsto","isProp":true,"docString":"If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C / (1 - r)`. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s‚ÇÅ : Set M} {s‚ÇÇ : Set M} (is‚ÇÅ : IsSubmonoid s‚ÇÅ) (is‚ÇÇ : IsSubmonoid s‚ÇÇ),\n  IsSubmonoid (s‚ÇÅ ‚à© s‚ÇÇ)","name":"IsSubmonoid.inter","isProp":true,"docString":"The intersection of two submonoids of a monoid `M` is a submonoid of `M`. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {K : Set G} {V : Set G}\n  (hK : IsCompact K) (hV : Set.Nonempty (interior V)),\n  ‚àÉ (t : Finset G), K ‚äÜ Set.union·µ¢ fun (g : G) ‚Ü¶ Set.union·µ¢ fun (h : g ‚àà t) ‚Ü¶ (fun (h : G) ‚Ü¶ g * h) ‚Åª¬π' V","name":"compact_covered_by_mul_left_translates","isProp":true,"docString":"A compact set is covered by finitely many left multiplicative translates of a set\nwith non-empty interior. "},{"type":"‚àÄ {Œ± : Type u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (hwf : WellFounded r),\n  ‚àÉ (s : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop), (r ‚â§ s : Prop) ‚àß (IsWellOrder Œ± s : Prop)","name":"WellFounded.exists_well_order_ge","isProp":true,"docString":"Any well-founded relation can be extended to a well-ordering on that type. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] (S : AddSubmonoid M), addLocalization.nsmul S = AddMonoid.nsmul","name":"addLocalization.nsmul_def","isProp":true,"docString":"Multiplication with a natural in an `AddLocalization` is defined as\n`n ‚Ä¢ ‚ü®a, b‚ü© = ‚ü®n ‚Ä¢ a, n ‚Ä¢ b‚ü©`.\n\nThis is a separate `irreducible` def to ensure the elaborator doesn't waste its time\ntrying to unify some huge recursive definition with itself, but unfolded one step less."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M],\n  (IsSMulRegular M 0 : Prop) ‚Üî (Subsingleton M : Prop)","name":"IsSMulRegular.zero_iff_subsingleton","isProp":true,"docString":"The element `0` is `M`-regular if and only if `M` is trivial. "},{"type":"‚àÄ {Œ± : Type u_3} [inst : CompleteLattice Œ±] {Œπ : Sort u_1} {Œπ' : Sort u_2} {t : (a : Œπ) ‚Üí Œ±} {f : (a : Œπ') ‚Üí Œπ}\n  (ht : CompleteLattice.Independent t) (hf : Function.Injective f), CompleteLattice.Independent (t ‚àò f)","name":"CompleteLattice.Independent.comp","isProp":true,"docString":"Composing an independent indexed family with an injective function on the index results in\nanother indepedendent indexed family. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : P} (hp : p ‚àà s),\n  vectorSpan k s = Submodule.span k ((fun (x : P) ‚Ü¶ x -·µ• p) '' (s \\ {p}))","name":"vectorSpan_eq_span_vsub_set_right_ne","isProp":true,"docString":"The `vectorSpan` is the span of the pairwise subtractions with a given point on the right,\nexcluding the subtraction of that point from itself. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 1 = 1","name":"RingHom.map_one","isProp":true,"docString":"Ring homomorphisms map one to one. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {S : Type v} [inst_1 : Semiring S] [inst_2 : Algebra R S] {p : Polynomial S}\n  (r : R) (hp : p ‚àà Polynomial.lifts (algebraMap R S)), r ‚Ä¢ p ‚àà Polynomial.lifts (algebraMap R S)","name":"Polynomial.smul_mem_lifts","isProp":true,"docString":"If `p` lifts and `(r : R)` then `r ‚Ä¢ p` lifts. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Module.Ray R M), Module.Ray.someVector x ‚â† 0","name":"Module.Ray.someVector_ne_zero","isProp":true,"docString":"`someVector` is nonzero. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {s : Set Œ±} (a : IsLowerSet s), IsUpperSet (‚ÜëOrderDual.ofDual ‚Åª¬π' s)","name":"IsLowerSet.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `isUpperSet_preimage_ofDual_iff`."},{"type":"‚àÄ {M : Type u} [self : CommMonoid M] (a : M) (b : M), a * b = b * a","name":"CommMonoid.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] {M : Type u_4} [inst_5 : Monoid M] [inst_6 : DistribMulAction M F]\n  [inst_7 : SMulCommClass R M F] (f : E ‚Üí‚Çó.[R] F) (z : M),\n  LinearPMap.graph (z ‚Ä¢ f) = Submodule.map (LinearMap.prodMap LinearMap.id (z ‚Ä¢ LinearMap.id)) (LinearPMap.graph f)","name":"LinearPMap.smul_graph","isProp":true,"docString":"The graph of `z ‚Ä¢ f` as a pushforward. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop},\n  Function.Injective fun (f : r ‚Ü™r s) ‚Ü¶ ‚Üëf","name":"RelEmbedding.coe_fn_injective","isProp":true,"docString":"The map `coe_fn : (r ‚Ü™r s) ‚Üí (Œ± ‚Üí Œ≤)` is injective. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] {s : Set M} {p : (a : M) ‚Üí Prop} {x : M} (h : x ‚àà Submonoid.closure s)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s), p x) (H1 : p 1) (Hmul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x * y)), p x","name":"Submonoid.closure_induction","isProp":true,"docString":"An induction principle for closure membership. If `p` holds for `1` and all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : Set P), s ‚äÜ spanPoints k s","name":"subset_spanPoints","isProp":true,"docString":"A set is contained in its `spanPoints`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =o[l] g'), f =o[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ","name":"Asymptotics.IsLittleO.norm_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_norm_right`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [inst_1 : IsCompactlyGenerated Œ±] {a : Œ±} {s : Set Œ±}\n  (h : DirectedOn (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) s), a ‚äì sup‚Çõ s = sup·µ¢ fun (b : Œ±) ‚Ü¶ sup·µ¢ fun (h : b ‚àà s) ‚Ü¶ a ‚äì b","name":"DirectedOn.inf_sup‚Çõ_eq","isProp":true,"docString":"This property is sometimes referred to as `Œ±` being upper continuous. "},{"type":"‚àÄ {R : Type u‚ÇÅ} [inst : LinearOrderedRing R] {a : R} (H : -1 ‚â§ a) (n : ‚Ñï), 1 + ‚Üën * (a - 1) ‚â§ a ^ n","name":"one_add_mul_sub_le_pow","isProp":true,"docString":"Bernoulli's inequality reformulated to estimate `a^n`. "},{"type":"‚àÄ {f : ‚Ñï ‚Üí‚ÇÄ ‚Ñï} (hf : ¬¨(0 ‚àà Finsupp.support f : Prop)), 0 < Finsupp.prod f fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x ^ x_1","name":"Nat.prod_pow_pos_of_zero_not_mem_support","isProp":true,"docString":"If `0 : ‚Ñï` is not in the support of `f : ‚Ñï ‚Üí‚ÇÄ ‚Ñï` then `0 < ‚àè x in f.support, x ^ (f x)`. "},{"type":"‚àÄ {p : (a : ‚Ñï) ‚Üí Prop} (a : ‚àÉ (x : ‚Ñï), p x), WellFounded (Nat.Upto.GT p)","name":"Nat.Upto.wf","isProp":true,"docString":"The \"greater than\" relation on `Upto p` is well founded if (and only if) there exists a value\nsatisfying `p`. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {d : Con M}, Setoid.r = Setoid.r ‚äì Setoid.r","name":"Con.inf_def","isProp":true,"docString":"The infimum of two congruence relations equals the infimum of the underlying binary\noperations. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] (w : (a : œÉ) ‚Üí M)\n  (r : R), MvPolynomial.IsWeightedHomogeneous w (‚ÜëMvPolynomial.C r) 0","name":"MvPolynomial.isWeightedHomogeneous_C","isProp":true,"docString":"Constant polynomials are weighted homogeneous of degree 0. "},{"type":"‚àÄ {Œ± : Type u} [inst : StrictOrderedSemiring Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} [inst_1 : ExistsAddOfLE Œ±] (hba : b < a)\n  (hdc : d < c), a ‚Ä¢ d + b ‚Ä¢ c < a ‚Ä¢ c + b ‚Ä¢ d","name":"mul_add_mul_lt_mul_add_mul'","isProp":true,"docString":"Binary **rearrangement inequality**. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Finset Œ±} (h : Monotone f)\n  (h' : ‚àÄ (x : Œ±), ‚àÉ (n : Œ≤), x ‚àà f n), Filter.Tendsto f Filter.atTop Filter.atTop","name":"Filter.tendsto_atTop_finset_of_monotone","isProp":true,"docString":"If `f` is a monotone sequence of `Finset`s and each `x` belongs to one of `f n`, then\n`Tendsto f atTop atTop`. "},{"type":"‚àÄ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g‚ÇÅ : Polynomial R} {g‚ÇÇ : Polynomial R}\n  (hg‚ÇÅ : Polynomial.Monic g‚ÇÅ) (hg‚ÇÇ : Polynomial.Monic g‚ÇÇ) (hcoprime : IsCoprime g‚ÇÅ g‚ÇÇ),\n  ‚àÉ (q : Polynomial R),\n    ‚àÉ (r‚ÇÅ : Polynomial R),\n      ‚àÉ (r‚ÇÇ : Polynomial R),\n        (Polynomial.degree r‚ÇÅ < Polynomial.degree g‚ÇÅ : Prop) ‚àß\n          ((Polynomial.degree r‚ÇÇ < Polynomial.degree g‚ÇÇ : Prop) ‚àß\n              (‚Üëf / (‚Üëg‚ÇÅ * ‚Üëg‚ÇÇ) = ‚Üëq + ‚Üër‚ÇÅ / ‚Üëg‚ÇÅ + ‚Üër‚ÇÇ / ‚Üëg‚ÇÇ : Prop) :\n            Prop)","name":"div_eq_quo_add_rem_div_add_rem_div","isProp":true,"docString":"Let R be an integral domain and f, g‚ÇÅ, g‚ÇÇ ‚àà R[X]. Let g‚ÇÅ and g‚ÇÇ be monic and coprime.\nThen, ‚àÉ q, r‚ÇÅ, r‚ÇÇ ‚àà R[X] such that f / g‚ÇÅg‚ÇÇ = q + r‚ÇÅ/g‚ÇÅ + r‚ÇÇ/g‚ÇÇ and deg(r‚ÇÅ) < deg(g‚ÇÅ) and\ndeg(r‚ÇÇ) < deg(g‚ÇÇ).\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] [self : IsCoatomic Œ±] (b : Œ±),\n  (b = ‚ä§ : Prop) ‚à® (‚àÉ (a : Œ±), (IsCoatom a : Prop) ‚àß (b ‚â§ a : Prop) : Prop)","name":"IsCoatomic.eq_top_or_exists_le_coatom","isProp":true,"docString":"Every element other than `‚ä§` has an atom above it. "},{"type":"‚àÄ {L : FirstOrder.Language} [self : FirstOrder.Language.IsAlgebraic L] (n : ‚Ñï),\n  IsEmpty (FirstOrder.Language.Relations L n)","name":"FirstOrder.Language.IsAlgebraic.empty_relations","isProp":true,"docString":"There are no relation symbols in the language. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : Module ùïú E] {x : E}\n  {z : E} {s : Set E} (hs : StarConvex ùïú (x + z) s), StarConvex ùïú x ((fun (x : E) ‚Ü¶ x + z) ‚Åª¬π' s)","name":"StarConvex.preimage_add_left","isProp":true,"docString":"The translation of a star-convex set is also star-convex. "},{"type":"‚àÄ (M : Type u_3) (Œ± : Type u_2) [inst : Group M] [inst_1 : MulAction M Œ±] {Œπ : Sort u_1} {s : (a : Œπ) ‚Üí Set Œ±},\n  fixingSubgroup M (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ s i) = inf·µ¢ fun (i : Œπ) ‚Ü¶ fixingSubgroup M (s i)","name":"fixingSubgroup_union·µ¢","isProp":true,"docString":"Fixing subgroup of union·µ¢ is intersection "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.MonoidalCategory C] [self : CategoryTheory.MonoidalPreadditive C] {W : C} {X : C} {Y : C}\n  {Z : C} (f : Y ‚ü∂ Z), 0 ‚äó f = 0","name":"CategoryTheory.MonoidalPreadditive.zero_tensor","isProp":true,"docString":"tensoring on the left with a zero morphism gives zero "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {a : Œ±} {b : Œ±} (hab : a ‚â† b), closure (Set.Ioo a b) = Set.Icc a b","name":"closure_Ioo","isProp":true,"docString":"The closure of the open interval `(a, b)` is the closed interval `[a, b]`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±} (H : IsGreatest s a), sup‚Çõ s = a","name":"IsGreatest.csup‚Çõ_eq","isProp":true,"docString":"A greatest element of a set is the supremum of this set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] [inst_1 : DecidableRel Disjoint]\n  [inst_2 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {s : Finset Œ±} {u : Œ±} {v : Œ±} {a : Œ±}\n  (ha : a ‚àà UV.compression u v s) (hva : v ‚â§ a) (hua : Disjoint u a), (a ‚äî u) \\ v ‚àà s","name":"UV.sup_sdiff_mem_of_mem_compression","isProp":true,"docString":"If `a` is in the family compression and can be compressed, then its compression is in the\noriginal family. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] (p : Polynomial R) (q : Polynomial R),\n  ‚ÜëPolynomial.derivative (Polynomial.eval‚ÇÇ Polynomial.C q p) =\n    Polynomial.eval‚ÇÇ Polynomial.C q (‚ÜëPolynomial.derivative p) * ‚ÜëPolynomial.derivative q","name":"Polynomial.derivative_eval‚ÇÇ_C","isProp":true,"docString":"Chain rule for formal derivative of polynomials. "},{"type":"‚àÄ (n : ‚Ñï) (k : ‚Ñï) (hn : 0 < n) (hk : 0 < k),\n  ({ val := n, property := hn } ‚â§ { val := k, property := hk } : Prop) ‚Üî (n ‚â§ k : Prop)","name":"PNat.mk_le_mk","isProp":true,"docString":"We now define a long list of structures on ‚Ñï+ induced by\nsimilar structures on ‚Ñï. Most of these behave in a completely\nobvious way, but there are a few things to be said about\nsubtraction, division and powers.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsTerminal X) (f : X ‚ü∂ Y),\n  CategoryTheory.IsSplitMono f","name":"CategoryTheory.Limits.IsTerminal.isSplitMono_from","isProp":true,"docString":"Any morphism from a terminal object is split mono. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonUnitalNonAssocSemiring Œ±]\n  [inst_1 : NonUnitalNonAssocSemiring Œ≤] [self : NonUnitalRingHomClass F Œ± Œ≤] (f : F), ‚Üëf 0 = 0","name":"NonUnitalRingHomClass.map_zero","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (a‚Åª¬π < 1 : Prop) ‚Üî (1 < a : Prop)","name":"Left.inv_lt_one_iff","isProp":true,"docString":"Uses `left` co(ntra)variant. "},{"type":"‚àÄ {R : Type u_1} {a : R} [inst : Monoid R] {n : ‚Ñï} (n0 : 0 < n),\n  (IsLeftRegular (a ^ n) : Prop) ‚Üî (IsLeftRegular a : Prop)","name":"IsLeftRegular.pow_iff","isProp":true,"docString":"An element `a` is left-regular if and only if a positive power of `a` is left-regular. "},{"type":"‚àÄ {Œ± : Type u} [inst : Ring Œ±], IsRingHom id","name":"IsRingHom.id","isProp":true,"docString":"The identity map is a ring homomorphism. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (n : ‚Ñï)\n  [inst_3 : Fact (FiniteDimensional.finrank K V = n + 1 : Prop)], FiniteDimensional K V","name":"FiniteDimensional.fact_finiteDimensional_of_finrank_eq_succ","isProp":true,"docString":"We can infer `FiniteDimensional K V` in the presence of `[Fact (finrank K V = n + 1)]`. Declare\nthis as a local instance where needed. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M], SMulCommClass { x : M // x ‚àà Submonoid.center M } M M","name":"Submonoid.center.smulCommClass_left","isProp":true,"docString":"The center of a monoid acts commutatively on that monoid. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (P : AddSubgroup G),\n  (AddSubgroup.Fg P : Prop) ‚Üî (‚àÉ (S : Set G), (AddSubgroup.closure S = P : Prop) ‚àß (Set.Finite S : Prop) : Prop)","name":"AddSubgroup.fg_iff","isProp":true,"docString":"An equivalent expression of `AddSubgroup.fg` in terms of `Set.Finite` instead of\n`Finset`."},{"type":"‚àÄ {n : ‚Ñï} {m : ‚Ñï} (h : n = m),\n  RelIso.toEquiv (Fin.cast h) =\n    Equiv.cast ((Eq.rec ((rfl=:Fin n = Fin n)=:Fin n = Fin n) h=:Fin n = Fin m)=:Fin n = Fin m)","name":"Fin.cast_to_equiv","isProp":true,"docString":"While in many cases `Fin.cast` is better than `Equiv.cast`/`cast`, sometimes we want to apply\na generic theorem about `cast`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f) (hg : Monotone g), Monotone fun (x : Œ±) ‚Ü¶ max (f x) (g x)","name":"Monotone.max","isProp":true,"docString":"Pointwise maximum of two monotone functions is a monotone function. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Isometry f), Continuous f","name":"Isometry.continuous","isProp":true,"docString":"An isometry is continuous. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : UniformSpace Œ±] [inst_2 : UniformAddGroup Œ±]\n  (f : (a : Œ≤) ‚Üí Œ±),\n  Filter.Tendsto (fun (s : Finset Œ≤) ‚Ü¶ tsum fun (b : { x : Œ≤ // ¬¨(x ‚àà s : Prop) }) ‚Ü¶ f ‚Üëb) Filter.atTop (nhds 0)","name":"tendsto_tsum_compl_atTop_zero","isProp":true,"docString":"The sum over the complement of a finset tends to `0` when the finset grows to cover the whole\nspace. This does not need a summability assumption, as otherwise all sums are zero. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {s : Set Œ±} {t : Set Œ±}\n  {Œ¶ : (a : Œ±) ‚Üí Œ≤} (h : Isometry Œ¶), EMetric.hausdorffEdist (Œ¶ '' s) (Œ¶ '' t) = EMetric.hausdorffEdist s t","name":"EMetric.hausdorffEdist_image","isProp":true,"docString":"The Hausdorff edistance is invariant under eisometries "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí Preorder (œÄ i)] {a : (i : Œπ) ‚Üí œÄ i} {b : (i : Œπ) ‚Üí œÄ i}\n  [inst_1 : Nonempty Œπ] (h : StrongLT a b), a < b","name":"StrongLT.lt","isProp":true,"docString":"**Alias** of `lt_of_strongLT`."},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (s : Finset Œπ) (p : (a : Œπ) ‚Üí P),\n  Finset.centroid k s p = ‚Üë(Finset.affineCombination k s p) (Finset.centroidWeights k s)","name":"Finset.centroid_def","isProp":true,"docString":"The definition of the centroid. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  (h : a ‚äÜ b), ¬¨(b ‚äÇ a : Prop)","name":"HasSubset.Subset.not_ssubset","isProp":true,"docString":"**Alias** of `not_ssubset_of_subset`."},{"type":"‚àÄ {Œ± : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsWellFounded Œ± r] {C : (a : Œ±) ‚Üí Sort u_1}\n  (F : (x : Œ±) ‚Üí (a : (y : Œ±) ‚Üí (a : r y x) ‚Üí C y) ‚Üí C x) (x : Œ±),\n  IsWellFounded.fix r F x = F x fun (y : Œ±) (x : r y x) ‚Ü¶ IsWellFounded.fix r F y","name":"IsWellFounded.fix_eq","isProp":true,"docString":"The value from `IsWellFounded.fix` is built from the previous ones as specified. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {A : Set E}\n  [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul ùïú E] (hA : Balanced ùïú A) (h : 0 ‚àà interior A),\n  Balanced ùïú (interior A)","name":"Balanced.interior","isProp":true,"docString":"The interior of a balanced set is balanced if it contains the origin. "},{"type":"‚àÄ {R : Type u_3} {E : Type u_2} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E] [inst_2 : Module R E]\n  {Œπ : Sort u_1} {w : (a : Œπ) ‚Üí R} {z : (a : Œπ) ‚Üí E} {s : Set E} (hs : Convex R s) (h‚ÇÄ : ‚àÄ (i : Œπ), 0 ‚â§ w i)\n  (h‚ÇÅ : (finsum fun (i : Œπ) ‚Ü¶ w i) = 1) (hz : ‚àÄ (i : Œπ) (a : w i ‚â† 0), z i ‚àà s), (finsum fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ z i) ‚àà s","name":"Convex.finsum_mem","isProp":true,"docString":"A version of `Convex.sum_mem` for `finsum`s. If `s` is a convex set, `w : Œπ ‚Üí R` is a family of\nnonnegative weights with sum one and `z : Œπ ‚Üí E` is a family of elements of a module over `R` such\nthat `z i ‚àà s` whenever `w i ‚â† 0`, then the sum `‚àë·∂† i, w i ‚Ä¢ z i` belongs to `s`. See also\n`PartitionOfUnity.finsum_smul_mem_convex`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} (a : Disjoint s t) ‚¶Éa : Œ±‚¶Ñ (a_1 : a ‚àà s) ‚¶Éb : Œ±‚¶Ñ (a_2 : b ‚àà t), a ‚â† b","name":"Disjoint.ne_of_mem","isProp":true,"docString":"**Alias** of the forward direction of `Set.disjoint_iff_forall_ne`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] (a : Œ±) [inst_4 : NoMaxOrder Œ±], closure (Set.Ioi a) = Set.Ici a","name":"closure_Ioi","isProp":true,"docString":"The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {a : Option Œ±} {b : Option Œ≤} {Œ¥ : Type u_1}\n  {Œ±' : Type u_2} {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ¥} {g' : (a : Œ±) ‚Üí Œ±'}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' (g' a) b),\n  Option.map g (Option.map‚ÇÇ f a b) = Option.map‚ÇÇ f' (Option.map g' a) b","name":"Option.map_map‚ÇÇ_distrib_left","isProp":true,"docString":"Symmetric statement to `Option.map‚ÇÇ_map_left_comm`. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G]\n  [inst_3 : TopologicalSpace.SeparableSpace G] [inst_4 : LocallyCompactSpace G], SigmaCompactSpace G","name":"SeparableLocallyCompactAddGroup.sigmaCompactSpace","isProp":true,"docString":"Every locally\ncompact separable topological group is œÉ-compact.\nNote: this is not true if we drop the topological group hypothesis."},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] (a : Œ±), Filter.atTop = Filter.comap Subtype.val Filter.atTop","name":"Filter.atTop_Ici_eq","isProp":true,"docString":"The `atTop` filter for an open interval `Ici a` comes from the `atTop` filter in the ambient\norder. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} {œÉ : Equiv.Perm Œ±} (hs : (setOf fun (a : Œ±) ‚Ü¶ ‚ÜëœÉ a ‚â† a) ‚äÜ s), ‚ÜëœÉ '' s = s","name":"Set.image_perm","isProp":true,"docString":"If the only elements outside `s` are those left fixed by `œÉ`, then mapping by `œÉ` has no effect.\n"},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {Œº : (a : M) ‚Üí (a : N) ‚Üí N} {r : (a : N) ‚Üí (a : N) ‚Üí Prop}\n  [self : ContravariantClass M N Œº r], Contravariant M N Œº r","name":"ContravariantClass.elim","isProp":true,"docString":"For all `m ‚àà M` and all elements `n‚ÇÅ, n‚ÇÇ ‚àà N`, if the relation `r` holds for the\npair `(Œº m n‚ÇÅ, Œº m n‚ÇÇ)` obtained from `(n‚ÇÅ, n‚ÇÇ)` by acting upon it by `m`, then, the relation\n`r` also holds for the pair `(n‚ÇÅ, n‚ÇÇ)`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (h : s ‚äÜ t), EMetric.diam s ‚â§ EMetric.diam t","name":"EMetric.diam_mono","isProp":true,"docString":"The diameter is monotonous with respect to inclusion "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] (l : List M), Option.getD (List.get? l 0) 1 * List.prod (List.tail l) = List.prod l","name":"List.get?_zero_mul_tail_prod","isProp":true,"docString":"We'd like to state this as `L.headI * L.tail.prod = L.prod`, but because `L.headI` relies on an\ninhabited instance to return a garbage value on the empty list, this is not possible.\nInstead, we write the statement in terms of `(L.get? 0).getD 1`.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\n  CategoryTheory.GrothendieckTopology.Cover.Relation.g‚ÇÅ self ‚â´\n      CategoryTheory.GrothendieckTopology.Cover.Relation.f‚ÇÅ self =\n    CategoryTheory.GrothendieckTopology.Cover.Relation.g‚ÇÇ self ‚â´\n      CategoryTheory.GrothendieckTopology.Cover.Relation.f‚ÇÇ self","name":"CategoryTheory.GrothendieckTopology.Cover.Relation.w","isProp":true,"docString":"The relation itself. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] {s : Finset Œ±} (hc : Finset.card s ‚â§ 1) {f : (a : Œ±) ‚Üí Œ≤} {b : Œ≤}\n  (h : (Finset.prod s fun (x : Œ±) ‚Ü¶ f x) = b) (x : Œ±) (a : x ‚àà s), f x = b","name":"Finset.eq_of_card_le_one_of_prod_eq","isProp":true,"docString":"If a product of a `Finset` of size at most 1 has a given value, so\ndo the terms in that product. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {Œ≤ : Type u_1} {p : (a : Œ≤) ‚Üí Prop} {f : (a : Œ≤) ‚Üí ‚Ñù}\n  (hf‚ÇÄ : ‚àÄ (i : Œ≤) (a : p i), 0 < f i) (hf : ‚àÄ ‚¶ÉŒµ : ‚Ñù‚¶Ñ (a : 0 < Œµ), ‚àÉ (i : Œ≤), (p i : Prop) ‚àß (f i ‚â§ Œµ : Prop)),\n  Filter.HasBasis (uniformity Œ±) p fun (i : Œ≤) ‚Ü¶ setOf fun (p : Œ± √ó Œ±) ‚Ü¶ dist (Prod.fst p) (Prod.snd p) < f i","name":"Metric.mk_uniformity_basis","isProp":true,"docString":"Given `f : Œ≤ ‚Üí ‚Ñù`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `ùì§ Œ±`.\n\nFor specific bases see `uniformity_basis_dist`, `uniformity_basis_dist_inv_nat_succ`,\nand `uniformity_basis_dist_inv_nat_pos`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalRing Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚à£ b), (a ‚à£ b + c : Prop) ‚Üî (a ‚à£ c : Prop)","name":"dvd_add_right","isProp":true,"docString":"If an element `a` divides another element `b` in a ring, `a` divides the sum of `b` and another\nelement `c` iff `a` divides `c`. "},{"type":"‚àÄ {I : Type u} {f : (a : I) ‚Üí Type v} [inst : DecidableEq I] [inst_1 : (i : I) ‚Üí MulOneClass (f i)],\n  Pairwise fun (i : I) (j : I) ‚Ü¶ ‚àÄ (x : f i) (y : f j), Commute (Pi.mulSingle i x) (Pi.mulSingle j y)","name":"Pi.mulSingle_commute","isProp":true,"docString":"The injection into a pi group at different indices commutes.\n\nFor injections of commuting elements at the same index, see `Commute.map` "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (a_1 : Fermat42.Minimal a b c), Fermat42.Minimal a b (-c)","name":"Fermat42.neg_of_minimal","isProp":true,"docString":"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} [inst : AddGroup Œ±] [self : NonarchAddGroupNormClass F Œ±] (f : F) {a : Œ±}\n  (a_1 : ‚Üëf a = 0), a = 0","name":"NonarchAddGroupNormClass.eq_zero_of_map_eq_zero","isProp":true,"docString":"If the image under the norm is zero, then the argument is zero. "},{"type":"‚àÄ {Œ± : Type u_1}, star 1 = 1","name":"FreeMonoid.star_one","isProp":true,"docString":"Note that `star_one` is already a global simp lemma, but this one works with dsimp too "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedSemifield Œ±] (a : Œ±) (b : Œ±), a / b = a * b‚Åª¬π","name":"LinearOrderedSemifield.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"¬¨(Set.Countable Set.univ : Prop)","name":"Cardinal.not_countable_real","isProp":true,"docString":"**Non-Denumerability of the Continuum**: The reals are not countable. "},{"type":"‚àÄ {Œ± : Type u_1} (self : Filter Œ±), Set.univ ‚àà Filter.sets self","name":"Filter.univ_sets","isProp":true,"docString":"The set `Set.univ` belongs to any filter. "},{"type":"‚àÄ {p : ‚Ñï} {a : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (n : ‚Ñï) (ha : a ‚â† 0), padicValNat p (a ^ n) = n * padicValNat p a","name":"padicValNat.pow","isProp":true,"docString":"A version of `padicValRat.pow` for `padicValNat`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {œÉ : (a : Œ±) ‚Üí Type u_1} (s : Finset Œ±)\n  (t : (a : Œ±) ‚Üí Finset (œÉ a)) (f : (a : Sigma œÉ) ‚Üí Œ≤),\n  (Finset.sum (Finset.sigma s t) fun (x : (i : Œ±) √ó œÉ i) ‚Ü¶ f x) =\n    Finset.sum s fun (a : Œ±) ‚Ü¶ Finset.sum (t a) fun (s : œÉ a) ‚Ü¶ f { fst := a, snd := s }","name":"Finset.sum_sigma","isProp":true,"docString":"Sum over a sigma type equals the sum of fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_sigma'`"},{"type":"‚àÄ (R : Type u_1) (M : Type u_2) [inst : Semiring R] [inst_1 : Subsingleton R] [inst_2 : AddCommMonoid M]\n  [inst : Module R M], Subsingleton M","name":"Module.subsingleton","isProp":true,"docString":"A module over a `Subsingleton` semiring is a `Subsingleton`. We cannot register this\nas an instance because Lean has no way to guess `R`. "},{"type":"‚àÄ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : IsDomain B] (e : A ‚âÉ+* B), IsDomain A","name":"RingEquiv.isDomain","isProp":true,"docString":"If two rings are isomorphic, and the second is a domain, then so is the first. "},{"type":"‚àÄ {H : Type u_1} {M : Type u_2} {H' : Type u_3} {M' : Type u_4} [inst : TopologicalSpace H]\n  [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M] [inst_3 : TopologicalSpace H']\n  [inst_4 : TopologicalSpace M'] [inst_5 : ChartedSpace H' M'] {G : StructureGroupoid H} {G' : StructureGroupoid H'}\n  {e : LocalHomeomorph M H} {f : LocalHomeomorph M' H'} {P : (a : (a : H) ‚Üí H') ‚Üí (a : Set H) ‚Üí (a : H) ‚Üí Prop}\n  {g : (a : M) ‚Üí M'} {s : Set M} {x : M} (hG : StructureGroupoid.LocalInvariantProp G G' P) [inst_6 : HasGroupoid M G]\n  [inst_7 : HasGroupoid M' G'] (he : e ‚àà StructureGroupoid.maximalAtlas M G)\n  (xe : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)) (hf : f ‚àà StructureGroupoid.maximalAtlas M' G')\n  (xf : g x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv f)),\n  (ChartedSpace.LiftPropWithinAt P g s x : Prop) ‚Üî\n    ((ContinuousWithinAt g s x : Prop) ‚àß\n        (ChartedSpace.LiftPropWithinAt P (‚Üëf ‚àò g ‚àò ‚Üë(LocalHomeomorph.symm e)) (‚Üë(LocalHomeomorph.symm e) ‚Åª¬π' s) (‚Üëe x) :\n          Prop) :\n      Prop)","name":"StructureGroupoid.LocalInvariantProp.liftPropWithinAt_indep_chart'","isProp":true,"docString":"A version of `liftPropWithinAt_indep_chart`, that uses `LiftPropWithinAt` on both sides. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : DecidableEq Œ≤] [inst_1 : SMul Œ± Œ≤] {u : Finset Œ≤} {s : Set Œ±} {t : Set Œ≤}\n  (a : ‚Üëu ‚äÜ s ‚Ä¢ t),\n  ‚àÉ (s' : Finset Œ±), ‚àÉ (t' : Finset Œ≤), (‚Üës' ‚äÜ s : Prop) ‚àß ((‚Üët' ‚äÜ t : Prop) ‚àß (u ‚äÜ s' ‚Ä¢ t' : Prop) : Prop)","name":"Finset.subset_smul","isProp":true,"docString":"If a finset `u` is contained in the scalar product of two sets `s ‚Ä¢ t`, we can find two finsets\n`s'`, `t'` such that `s' ‚äÜ s`, `t' ‚äÜ t` and `u ‚äÜ s' ‚Ä¢ t'`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : NNReal}, EMetric.closedBall x ‚ÜëŒµ = Metric.closedBall x ‚ÜëŒµ","name":"Metric.emetric_closedBall_nnreal","isProp":true,"docString":"Closed balls defined using the distance or the edistance coincide "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : Metric.Bounded s) (ht : Metric.Bounded t),\n  Metric.Bounded (s ‚à™ t)","name":"Metric.Bounded.union","isProp":true,"docString":"The union of two bounded sets is bounded. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : 1 < a) (hb : 1 < b), 1 < a * b","name":"Right.one_lt_mul'","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul'`. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (S : Subgroup G)\n  (hS : Filter.Tendsto (‚Üë(Subgroup.subtype S)) Filter.cofinite (Filter.cocompact G)),\n  ProperlyDiscontinuousSMul { x : G // x ‚àà S } G","name":"Subgroup.properlyDiscontinuousSMul_of_tendsto_cofinite","isProp":true,"docString":"A subgroup `S` of a topological group `G` acts on `G` properly discontinuously on the left, if\nit is discrete in the sense that `S ‚à© K` is finite for all compact `K`. (See also\n`DiscreteTopology`.) "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type u_1} [inst_1 : CompactSpace Œ±] {f : (a : Œπ) ‚Üí Set Œ±}\n  (hf : LocallyFinite f) (hne : ‚àÄ (i : Œπ), Set.Nonempty (f i)), Set.Finite Set.univ","name":"LocallyFinite.finite_of_compact","isProp":true,"docString":"If `Œ±` is a compact space, then a locally finite family of nonempty sets of `Œ±` can have only\nfinitely many elements, `Set.Finite` version. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Inv G] [inst_2 : Mul G] [inst_3 : ContinuousMul G]\n  [inst_4 : ContinuousInv G], Continuous fun (g : G √ó G) ‚Ü¶ Prod.fst g * Prod.snd g * (Prod.fst g)‚Åª¬π","name":"TopologicalGroup.continuous_conj_prod","isProp":true,"docString":"Conjugation is jointly continuous on `G √ó G` when both `mul` and `inv` are continuous. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} (h : ‚àÄ (x : Œ±), f x = g x),\n  f '' s = g '' s","name":"Set.image_congr'","isProp":true,"docString":"A common special case of `image_congr` "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {a : Œ±} {s : Set Œ±} (f : (a : Œ±) ‚Üí M) (h : ¬¨(a ‚àà s : Prop))\n  (hs : Set.Finite s),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà insert a s) ‚Ü¶ f i) = f a + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i","name":"finsum_mem_insert","isProp":true,"docString":"Given a finite set `s` and an element `a ‚àâ s`, the sum of `f i` over `i ‚àà insert a s`\nequals `f a` plus the sum of `f i` over `i ‚àà s`."},{"type":"‚àÄ {Œ± : Type u} [self : CommRing Œ±] (a : Œ±) (b : Œ±), a * b = b * a","name":"CommRing.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {p : Prop} {q : Prop} {r : Prop} (h‚ÇÅ : ‚àÄ (a : p), q) (h‚ÇÇ : ‚àÄ (a : q), r) (a : p), r","name":"Implies.trans","isProp":true,"docString":"Implication `‚Üí` is transitive. If `P ‚Üí Q` and `Q ‚Üí R` then `P ‚Üí R`. "},{"type":"‚àÄ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {W : Type u_3} [inst_4 : AddCommGroup W] [inst_5 : Module K W]\n  [inst_6 : FiniteDimensional K W] {A : Type u_4} [inst_7 : Ring A] [inst_8 : Algebra K A] [inst_9 : Module A V]\n  [inst_10 : IsScalarTower K A V] [inst_11 : Module A W] [inst_12 : IsScalarTower K A W],\n  FiniteDimensional K (V ‚Üí‚Çó[A] W)","name":"LinearMap.finiteDimensional'","isProp":true,"docString":"Linear maps over a `k`-algebra are finite dimensional (over `k`) if both the source and\ntarget are, as they form a subspace of all `k`-linear maps. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (self : Con M) {w : M} {x : M} {y : M} {z : M} (a : Setoid.r w x) (a : Setoid.r y z),\n  Setoid.r (w * y) (x * z)","name":"Con.mul'","isProp":true,"docString":"Congruence relations are closed under multiplication "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {G' : SimpleGraph V} (h : G ‚â§ G') {u : V} {v : V} {p : SimpleGraph.Walk G u v}\n  (a : SimpleGraph.Walk.IsTrail (SimpleGraph.Walk.mapLe h p)), SimpleGraph.Walk.IsTrail p","name":"SimpleGraph.Walk.IsTrail.of_mapLe","isProp":true,"docString":"**Alias** of the forward direction of `SimpleGraph.Walk.mapLe_isTrail`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] [inst_1 : DecidableRel Disjoint]\n  [inst_2 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (u : Œ±) (s : Finset Œ±), UV.IsCompressed u u s","name":"UV.is_compressed_self","isProp":true,"docString":"Any family is compressed along two identical elements. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CommSemiring Œ≤] {Œ¥ : (a : Œ±) ‚Üí Type u_1} [inst_1 : DecidableEq Œ±]\n  [inst_2 : (a : Œ±) ‚Üí DecidableEq (Œ¥ a)] {s : Finset Œ±} {t : (a : Œ±) ‚Üí Finset (Œ¥ a)} {f : (a : Œ±) ‚Üí (a : Œ¥ a) ‚Üí Œ≤},\n  (Finset.prod s fun (a : Œ±) ‚Ü¶ Finset.sum (t a) fun (b : Œ¥ a) ‚Ü¶ f a b) =\n    Finset.sum (Finset.pi s t) fun (p : (a : Œ±) ‚Üí (a_1 : a ‚àà s) ‚Üí Œ¥ a) ‚Ü¶\n      Finset.prod (Finset.attach s) fun (x : { x : Œ± // x ‚àà s }) ‚Ü¶ f (‚Üëx) (p ‚Üëx ((Subtype.property x=:‚Üëx ‚àà s)=:‚Üëx ‚àà s))","name":"Finset.prod_sum","isProp":true,"docString":"The product over a sum can be written as a sum over the product of sets, `Finset.Pi`.\n`Finset.prod_univ_sum` is an alternative statement when the product is over `univ`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ±] {s : Set Œ≤}\n  (hs : Dense s) {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f) (hg : Continuous g) (h : Set.EqOn f g s), f = g","name":"Continuous.ext_on","isProp":true,"docString":"If two continuous functions are equal on a dense set, then they are equal. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (a : G), ‚Üë(Equiv.symm (Equiv.addRight a)) = fun (x : G) ‚Ü¶ x + -a","name":"Equiv.addRight_symm_apply","isProp":true,"docString":"Extra simp lemma that `dsimp` can use. `simp` will never use this."},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} [inst : AddCommMonoid Œ≤] {f : (a : Œ±) ‚Üí Prop} [inst_1 : DecidablePred f]\n  (hf : Set.PairwiseDisjoint (‚Üës) f) (a : Œ≤),\n  (Finset.sum s fun (i : Œ±) ‚Ü¶ if (f i : Prop) then a else 0) =\n    if (‚àÉ (i : Œ±), (i ‚àà s : Prop) ‚àß (f i : Prop) : Prop) then a else 0","name":"Finset.sum_ite_zero","isProp":true,"docString":"See also `Finset.sum_boole`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} (self : r ‚Üír s) {a : Œ±}\n  {b : Œ±} (a_1 : r a b), s (RelHom.toFun self a) (RelHom.toFun self b)","name":"RelHom.map_rel'","isProp":true,"docString":"A `RelHom` sends related elements to related elements "},{"type":"‚àÄ {V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ] (f : V‚ÇÅ ‚Üí+ V‚ÇÇ)\n  {C : ‚Ñù} (hC : 0 ‚â§ C) (h : ‚àÄ (x : V‚ÇÅ), ‚Äñ‚Üëf x‚Äñ ‚â§ C * ‚Äñx‚Äñ), ‚ÄñAddMonoidHom.mkNormedAddGroupHom f C h‚Äñ ‚â§ C","name":"AddMonoidHom.mkNormedAddGroupHom_norm_le","isProp":true,"docString":"**Alias** of `NormedAddGroupHom.mkNormedAddGroupHom_norm_le`."},{"type":"‚àÄ {Œπ : Type w} {Œπ' : Type w'} {R : Type u} [inst : Ring R] [inst_1 : InvariantBasisNumber R] {M : Type v}\n  [inst_2 : AddCommGroup M] [inst_3 : Module R M] (v : Basis Œπ R M) (v' : Basis Œπ' R M),\n  Cardinal.lift (Cardinal.mk Œπ) = Cardinal.lift (Cardinal.mk Œπ')","name":"mk_eq_mk_of_basis","isProp":true,"docString":"The dimension theorem: if `v` and `v'` are two bases, their index types\nhave the same cardinalities. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_3} {E : Type u_2} [inst : SeminormedAddCommGroup E] {f : (a : Œπ) ‚Üí E}\n  (hf : Summable fun (a : Œπ) ‚Ü¶ ‚Äñf a‚Äñ) {s : (a : Œ±) ‚Üí Finset Œπ} {p : Filter Œ±} [inst_1 : Filter.NeBot p]\n  (hs : Filter.Tendsto s p Filter.atTop) {a : E}\n  (ha : Filter.Tendsto (fun (b : Œ±) ‚Ü¶ Finset.sum (s b) fun (i : Œπ) ‚Ü¶ f i) p (nhds a)), HasSum f a","name":"hasSum_of_subseq_of_summable","isProp":true,"docString":"If a function `f` is summable in norm, and along some sequence of finsets exhausting the space\nits sum is converging to a limit `a`, then this holds along all finsets, i.e., `f` is summable\nwith sum `a`. "},{"type":"‚àÄ {Œπ : Type u_1} (f : (a : Œπ) ‚Üí Cardinal) (g : (a : Œπ) ‚Üí Cardinal) (H : ‚àÄ (i : Œπ), f i < g i),\n  Cardinal.sum f < Cardinal.prod g","name":"Cardinal.sum_lt_prod","isProp":true,"docString":"**K√∂nig's theorem** "},{"type":"‚àÄ {X : (a : ‚Ñï) ‚Üí Type u} [inst : (n : ‚Ñï) ‚Üí MetricSpace (X n)] {f : (n : ‚Ñï) ‚Üí (a : X n) ‚Üí X (n + 1)}\n  (I : ‚àÄ (n : ‚Ñï), Isometry (f n)) (n : ‚Ñï), Metric.toInductiveLimit I (Nat.succ n) ‚àò f n = Metric.toInductiveLimit I n","name":"Metric.toInductiveLimit_commute","isProp":true,"docString":"The maps `toInductiveLimit n` are compatible with the maps `f n`. "},{"type":"‚àÄ {R : Type u_1} [inst : Star R] [inst_1 : TrivialStar R] (r : R), IsSelfAdjoint r","name":"IsSelfAdjoint.all","isProp":true,"docString":"All elements are self-adjoint when `star` is trivial. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] [inst_1 : StarRing R] {x : R}, ‚Üë(starRingEnd R) x = star x","name":"starRingEnd_apply","isProp":true,"docString":"This is not a simp lemma, since we usually want simp to keep `starRingEnd` bundled.\nFor example, for complex conjugation, we don't want simp to turn `conj x`\ninto the bare function `star x` automatically since most lemmas are about `conj x`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p1 : P} {p2 : P} (hp1 : p1 ‚àà s),\n  AffineSubspace.direction (affineSpan k (insert p2 ‚Üës)) = Submodule.span k {p2 -·µ• p1} ‚äî AffineSubspace.direction s","name":"AffineSubspace.direction_affineSpan_insert","isProp":true,"docString":"The direction of the span of the result of adding a point to a nonempty affine subspace is the\nsup of the direction of that subspace and of any one difference between that point and a point in\nthe subspace. "},{"type":"‚àÄ {I : Type u} {Œ≤ : Type u_1} [inst : DecidableEq I] [inst_1 : Zero Œ≤] (i : I) (x : Œ≤) (i' : I),\n  Pi.single i x i' = if (i' = i : Prop) then x else 0","name":"Pi.single_apply","isProp":true,"docString":"On non-dependent functions, `Pi.single` can be expressed as an `ite`"},{"type":"‚àÄ (n : ‚Ñï), (n + 1) * Nat.centralBinom (n + 1) = 2 * (2 * n + 1) * Nat.centralBinom n","name":"Nat.succ_mul_centralBinom_succ","isProp":true,"docString":"An inductive property of the central binomial coefficient.\n"},{"type":"‚àÄ {A : Type u_1} {Œπ : Type u_2} [inst : Ring A] {B : (a : Œπ) ‚Üí AddSubgroup A} (self : RingSubgroupsBasis B) (x : A)\n  (i : Œπ), ‚àÉ (j : Œπ), ‚Üë(B j) ‚äÜ (fun (x_1 : A) ‚Ü¶ x * x_1) ‚Åª¬π' ‚Üë(B i)","name":"RingSubgroupsBasis.leftMul","isProp":true,"docString":"For any element `x : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `B' * x` is in `B`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} (h : Set.Nonempty ‚Üës), ‚Üë(AffineSubspace.direction s) = ‚Üës -·µ• ‚Üës","name":"AffineSubspace.coe_direction_eq_vsub_set","isProp":true,"docString":"The set of vectors in the direction of a nonempty affine subspace is given by `vsub_set`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} {Œ≥ : Type u_1} [inst : UniformSpace Œ≤] {ùîñ : Set (Set Œ±)} [inst_1 : UniformSpace Œ≥]\n  {f : (a : Œ≥) ‚Üí Œ≤} (hf : UniformInducing f),\n  UniformInducing\n    (‚Üë(UniformOnFun.ofFun ùîñ) ‚àò (fun (x : (a : Œ≥) ‚Üí Œ≤) (x_1 : (a : Œ±) ‚Üí Œ≥) ‚Ü¶ x ‚àò x_1) f ‚àò ‚Üë(UniformOnFun.toFun ùîñ))","name":"UniformOnFun.postcomp_uniformInducing","isProp":true,"docString":"Post-composition by a uniform inducing is a uniform inducing for the\nuniform structures of `ùîñ`-convergence.\n\nMore precisely, if `f : Œ≥ ‚Üí Œ≤` is a uniform inducing, then\n`(Œª g, f ‚àò g) : (Œ± ‚Üí·µ§[ùîñ] Œ≥) ‚Üí (Œ± ‚Üí·µ§[ùîñ] Œ≤)` is a uniform inducing. "},{"type":"‚àÄ {Œ± : Type u_1} (s : Set Œ±) (a : Œ±), ùí´ insert a s = ùí´ s ‚à™ insert a '' ùí´ s","name":"Set.powerset_insert","isProp":true,"docString":"The powerset of `{a} ‚à™ s` is `ùí´ s` together with `{a} ‚à™ t` for each `t ‚àà ùí´ s`. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f x y), Equiv.Perm.SameCycle f (‚Üëf x) y","name":"Equiv.Perm.SameCycle.apply_left","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_apply_left`."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  [self : CategoryTheory.Limits.HasColimit F], Nonempty (CategoryTheory.Limits.ColimitCocone F)","name":"CategoryTheory.Limits.HasColimit.exists_colimit","isProp":true,"docString":"There exists a colimit for `F` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : AddCommMonoid Œ±] [inst_2 : T2Space Œ±]\n  [inst_3 : ContinuousAdd Œ±] {f : (a : Œ≤) ‚Üí Œ±} {a : Œ±} (hf : HasSum f a) (b : Œ≤) (a' : Œ±)\n  (hf' : HasSum (fun (n : Œ≤) ‚Ü¶ if (n = b : Prop) then 0 else f n) a'), a = a' + f b","name":"eq_add_of_hasSum_ite","isProp":true,"docString":"Version of `hasSum_ite_sub_hasSum` for `AddCommMonoid` rather than `AddCommGroup`.\nRather than showing that the `ite` expression has a specific sum in terms of `HasSum`,\nit gives a relationship between the sums of `f` and `ite (n = b) 0 (f n)` given that both exist. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : TopologicalSpace M]\n  [inst_3 : AddCommGroup M] [inst_4 : ContinuousAdd M] [inst_5 : Module R M] [inst_6 : ContinuousSMul R M]\n  [inst_7 : Filter.NeBot (nhdsWithin 0 (setOf fun (x : R) ‚Ü¶ IsUnit x))] (s : Submodule R M)\n  (hs : Set.Nonempty (interior ‚Üës)), s = ‚ä§","name":"Submodule.eq_top_of_nonempty_interior'","isProp":true,"docString":"If `M` is a topological module over `R` and `0` is a limit of invertible elements of `R`, then\n`‚ä§` is the only submodule of `M` with a nonempty interior.\nThis is the case, e.g., if `R` is a nontrivially normed field. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} {c : Œ±} [inst : Mul Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±]\n  [inst_3 : PosMulReflectLT Œ±] (h : a * b < a * c) (a0 : 0 ‚â§ a), b < c","name":"lt_of_mul_lt_mul_of_nonneg_left","isProp":true,"docString":"**Alias** of `lt_of_mul_lt_mul_left`."},{"type":"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (œÉ : Equiv.Perm n),\n  Matrix.det (PEquiv.toMatrix (Equiv.toPEquiv œÉ)) = ‚Üë‚Üë(‚ÜëEquiv.Perm.sign œÉ)","name":"Matrix.det_permutation","isProp":true,"docString":"The determinant of a permutation matrix equals its sign. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} (h : Set.Nonempty s), EMetric.infEdist x s ‚â† ‚ä§","name":"Metric.infEdist_ne_top","isProp":true,"docString":"In a metric space, the minimal edistance to a nonempty set is finite. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\n  ¬¨(Continuous ‚Üë(Equiv.symm CofiniteTopology.of) : Prop)","name":"Alexandroff.not_continuous_cofiniteTopology_of_symm","isProp":true,"docString":"If `X` is an infinite type with discrete topology (e.g., `‚Ñï`), then the identity map from\n`CofiniteTopology (Alexandroff X)` to `Alexandroff X` is not continuous. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {f : M ‚Üí* P} (x : M),\n  ‚Üë(Con.ker f) x = ‚Üëf ‚Åª¬π' {‚Üëf x}","name":"Con.ker_apply_eq_preimage","isProp":true,"docString":"The elements related to `x ‚àà M`, `M` a monoid, by the kernel of a monoid homomorphism are\nthose in the preimage of `f(x)` under `f`. "},{"type":"‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (x : V),\n  FiniteDimensional K { x_1 : V // x_1 ‚àà Submodule.span K {x} }","name":"FiniteDimensional.span_singleton","isProp":true,"docString":"The submodule generated by a single element is finite-dimensional. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] [inst_2 : CommMonoid Œ≤]\n  {Œ¥ : (a : Œ±) ‚Üí Type u_3} {t : (a : Œ±) ‚Üí Finset (Œ¥ a)} (f : (a : (a : Œ±) ‚Üí (a_1 : a ‚àà Finset.univ) ‚Üí Œ¥ a) ‚Üí Œ≤),\n  (Finset.prod (Finset.pi Finset.univ t) fun (x : (a : Œ±) ‚Üí (a_1 : a ‚àà Finset.univ) ‚Üí Œ¥ a) ‚Ü¶ f x) =\n    Finset.prod (Fintype.piFinset t) fun (x : (a : Œ±) ‚Üí Œ¥ a) ‚Ü¶ f fun (a : Œ±) (x_1 : a ‚àà Finset.univ) ‚Ü¶ x a","name":"Finset.prod_univ_pi","isProp":true,"docString":"Taking a product over `univ.pi t` is the same as taking the product over `Fintype.piFinset t`.\n`univ.pi t` and `Fintype.piFinset t` are essentially the same `Finset`, but differ\nin the type of their element, `univ.pi t` is a `Finset (Œ† a ‚àà univ, t a)` and\n`Fintype.piFinset t` is a `Finset (Œ† a, t a)`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P), vectorSpan k {p} = ‚ä•","name":"vectorSpan_singleton","isProp":true,"docString":"The `vectorSpan` of a single point is `‚ä•`. "},{"type":"‚àÄ {Œ± : Type v} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±] {s : Set Œ±}\n  (hs : IsConnected s) {a : Œ±} {b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s), Set.Icc a b ‚äÜ s","name":"IsConnected.Icc_subset","isProp":true,"docString":"If a preconnected set contains endpoints of an interval, then it includes the whole interval. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrder Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"LinearOrder.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {D : Type u‚ÇÑ}\n  [inst_2 : CategoryTheory.Category D] (F : C ‚•§ D) [inst_3 : CategoryTheory.ReflectsIsomorphisms F] (K : J ‚•§ C),\n  CategoryTheory.ReflectsIsomorphisms (CategoryTheory.Limits.Cocones.functoriality K F)","name":"CategoryTheory.Limits.Cocones.reflects_cocone_isomorphism","isProp":true,"docString":"If `F` reflects isomorphisms, then `cocones.functoriality F` reflects isomorphisms\nas well.\n"},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [inst : SetLike S R] [inst_1 : One R] [inst_2 : Zero Œπ] {A : (a : Œπ) ‚Üí S}\n  [self : SetLike.GradedOne A], 1 ‚àà A 0","name":"SetLike.GradedOne.one_mem","isProp":true,"docString":"One has grade zero "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (Œ¥ : ‚Ñù), Metric.thickening Œ¥ ‚àÖ = ‚àÖ","name":"Metric.thickening_empty","isProp":true,"docString":"The (open) thickening of the empty set is empty. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] (L : List M) (h : List.sum L ‚â† 0), 0 < List.length L","name":"List.length_pos_of_sum_ne_zero","isProp":true,"docString":"A list with sum not zero must have positive length."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] (a : Œ±) (b : Œ±), abs (a + b) ‚â§ abs a + abs b","name":"abs_add","isProp":true,"docString":"The **triangle inequality** in `LinearOrderedAddCommGroup`s. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] (s : AddSubmonoid M) {l : List M} (hl : ‚àÄ (x : M) (a : x ‚àà l), x ‚àà s),\n  List.sum l ‚àà s","name":"AddSubmonoid.list_sum_mem","isProp":true,"docString":"Sum of a list of elements in an `AddSubmonoid` is in the `AddSubmonoid`."},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : TopologicalSpace A]\n  [inst_3 : Semiring A] [inst_4 : Algebra R A] [inst_5 : StarRing A] [inst_6 : StarModule R A] {S‚ÇÅ : StarSubalgebra R A}\n  {S‚ÇÇ : StarSubalgebra R A} (h : S‚ÇÅ ‚â§ S‚ÇÇ) (hS‚ÇÅ : IsClosed ‚ÜëS‚ÇÅ), ClosedEmbedding ‚Üë(StarSubalgebra.inclusion h)","name":"StarSubalgebra.closedEmbedding_inclusion","isProp":true,"docString":"The `StarSubalgebra.inclusion` of a closed star subalgebra is a `ClosedEmbedding`. "},{"type":"‚àÄ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R] (hR : ringChar R ‚â† 2), Set.InjOn Int.cast {0, 1, -1}","name":"Int.cast_injOn_of_ringChar_ne_two","isProp":true,"docString":"If two integers from `{0, 1, -1}` result in equal elements in a ring `R`\nthat is nontrivial and of characteristic not `2`, then they are equal. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Filter Œ±} {p : (a : Œ± √ó Œ±) ‚Üí Prop}\n  (h : Filter.Eventually (fun (i : Œ± √ó Œ±) ‚Ü¶ p i) (Filter.prod f f)), Filter.Eventually (fun (i : Œ±) ‚Ü¶ p (i, i)) f","name":"Filter.Eventually.diag_of_prod","isProp":true,"docString":"A fact that is eventually true about all pairs `l √ó·∂† l` is eventually true about\nall diagonal pairs `(i, i)` "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} [inst : Norm F] {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} (a : u =o[l] g),\n  (fun (x : Œ±) ‚Ü¶ abs (u x)) =o[l] g","name":"Asymptotics.IsLittleO.abs_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_abs_left`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasLimits C]\n  [inst_2 : CategoryTheory.WellPowered C] {ùí¢ : Set C} [inst_3 : Small ‚Üëùí¢] (hùí¢ : CategoryTheory.IsCoseparating ùí¢),\n  CategoryTheory.Limits.HasColimits C","name":"CategoryTheory.Limits.hasColimits_of_hasLimits_of_isCoseparating","isProp":true,"docString":"A consequence of the special adjoint functor theorem: if `C` is complete, well-powered and\nhas a small coseparating set, then it is cocomplete. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p : Prop)]\n  (hp : p ‚à£ Fintype.card R), ¬¨(IsUnit ‚Üëp : Prop)","name":"not_isUnit_prime_of_dvd_card","isProp":true,"docString":"A prime that does not divide the cardinality of a finite commutative ring `R`\nis a unit in `R`. "},{"type":"‚àÄ {Œ± : Type u_2} {R : Type u_1} {l : Filter Œ±} {f : (a : Œ±) ‚Üí R} {r : R} [inst : LinearOrderedSemiring R]\n  [inst_1 : Archimedean R] (hr : 0 < r) (hf : Filter.Tendsto f l Filter.atTop),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ r * f x) l Filter.atTop","name":"Filter.Tendsto.const_mul_atTop'","isProp":true,"docString":"If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the left) also tends to infinity. The archimedean assumption is convenient to get a\nstatement that works on `‚Ñï`, `‚Ñ§` and `‚Ñù`, although not necessary (a version in ordered fields is\ngiven in `Filter.Tendsto.const_mul_atTop`). "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_3}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_4} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ] [inst_8 : RingHomSurjective œÉ‚ÇÅ‚ÇÇ]\n  [inst_9 : TopologicalSpace R‚ÇÅ] [inst_10 : TopologicalSpace R‚ÇÇ] [inst_11 : ContinuousSMul R‚ÇÅ M‚ÇÅ]\n  [inst_12 : ContinuousAdd M‚ÇÅ] [inst_13 : ContinuousSMul R‚ÇÇ M‚ÇÇ] [inst_14 : ContinuousAdd M‚ÇÇ] {f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ}\n  (hf' : DenseRange ‚Üëf) {s : Submodule R‚ÇÅ M‚ÇÅ} (hs : Submodule.topologicalClosure s = ‚ä§),\n  Submodule.topologicalClosure (Submodule.map (‚Üëf) s) = ‚ä§","name":"DenseRange.topologicalClosure_map_submodule","isProp":true,"docString":"Under a dense continuous linear map, a submodule whose `TopologicalClosure` is `‚ä§` is sent to\nanother such submodule.  That is, the image of a dense set under a map with dense range is dense.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (-a ‚â§ 0 : Prop) ‚Üî (0 ‚â§ a : Prop)","name":"Left.neg_nonpos_iff","isProp":true,"docString":"Uses `left` co(ntra)variant."},{"type":"‚àÄ {Œπ : Type u_1} {I : BoxIntegral.Box Œπ} [inst : Finite Œπ] (œÄ : BoxIntegral.Prepartition I),\n  ‚àÉ (œÄ' : BoxIntegral.Prepartition I), BoxIntegral.Prepartition.union·µ¢ œÄ' = ‚ÜëI \\ BoxIntegral.Prepartition.union·µ¢ œÄ","name":"BoxIntegral.Prepartition.exists_union·µ¢_eq_diff","isProp":true,"docString":"For every prepartition `œÄ` of `I` there exists a prepartition that covers exactly\n`I \\ œÄ.union·µ¢`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (Alexandroff X)","name":"Alexandroff.instNormalSpaceAlexandroffInstTopologicalSpaceAlexandroff","isProp":true,"docString":"The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. "},{"type":"‚àÄ {a : Ordinal} {b : Ordinal} (h : b ‚â† 0), Set.Nonempty (setOf fun (o : Ordinal) ‚Ü¶ a < b * Order.succ o)","name":"Ordinal.div_nonempty","isProp":true,"docString":"The set in the definition of division is nonempty. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} (f : X ‚ü∂ 0), f = 0","name":"CategoryTheory.Limits.zero_of_to_zero","isProp":true,"docString":"An arrow ending in the zero object is zero "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (self : C(Œ±, Œ≤)),\n  Continuous (ContinuousMap.toFun self)","name":"ContinuousMap.continuous_toFun","isProp":true,"docString":"Proposition that `toFun` is continuous "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} (a : Set.Subsingleton s), Equiv.Perm.IsCycleOn 1 s","name":"Set.Subsingleton.isCycleOn_one","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.isCycleOn_one`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y),\n  CategoryTheory.IsIso (CategoryTheory.Limits.equalizer.Œπ f f)","name":"CategoryTheory.Limits.equalizer.Œπ_of_self","isProp":true,"docString":"The equalizer inclusion for `(f, f)` is an isomorphism. "},{"type":"‚àÄ {F : Sort u_2} {Œ± : Sort u_3} {Œ≤ : (a : Œ±) ‚Üí Sort u_1} [i : FunLike F Œ± Œ≤] [inst : ‚àÄ (a : Œ±), Subsingleton (Œ≤ a)],\n  Subsingleton F","name":"FunLike.subsingleton_cod","isProp":true,"docString":"This is not an instance to avoid slowing down every single `Subsingleton` typeclass search."},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f‚Åª¬π x y), Equiv.Perm.SameCycle f x y","name":"Equiv.Perm.SameCycle.of_inv","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.sameCycle_inv`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CompleteLattice Œ±] [inst_1 : CompleteLattice Œ≤] (self : CompleteLatticeHom Œ± Œ≤)\n  (s : Set Œ±),\n  Inf‚ÇõHom.toFun (CompleteLatticeHom.toInf‚ÇõHom self) (sup‚Çõ s) =\n    sup‚Çõ (Inf‚ÇõHom.toFun (CompleteLatticeHom.toInf‚ÇõHom self) '' s)","name":"CompleteLatticeHom.map_sup‚Çõ'","isProp":true,"docString":"The proposition that complete lattice homomorphism commutes with arbitrary suprema/joins. "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï}, (m ‚à£ n + m : Prop) ‚Üî (m ‚à£ n : Prop)","name":"Nat.dvd_add_self_right","isProp":true,"docString":"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalSeminormedRing Œ±] (x : Œ±) (y : Œ±), ‚Äñ‚Üë(AddMonoidHom.mulRight x) y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ","name":"mulRight_bound","isProp":true,"docString":"In a seminormed ring, the right-multiplication `AddMonoidHom` is bounded. "},{"type":"‚àÄ {Œ± : Sort u} [inst : DecidableEq Œ±] {Œ≤ : Sort u_1} (f : (a : Œ±) ‚Üí Œ≤) (a' : Œ±) (b : Œ≤) (a : Œ±),\n  Function.update f a' b a = if (a = a' : Prop) then b else f a","name":"Function.update_apply","isProp":true,"docString":"On non-dependent functions, `Function.update` can be expressed as an `ite` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : (a : Œ±) ‚Üí Set Œ≤} {y : Œ≤} (h : ‚àÄ (x : Œ±) (a : x ‚àà s), y ‚àà t x),\n  y ‚àà Set.inter·µ¢ fun (x : Œ±) ‚Ü¶ Set.inter·µ¢ fun (h : x ‚àà s) ‚Ü¶ t x","name":"Set.mem_binter·µ¢","isProp":true,"docString":"A specialization of `mem_inter·µ¢‚ÇÇ`. "},{"type":"‚àÄ (a : ‚Ñù), Filter.Tendsto (‚Üë(AddSubgroup.subtype (AddSubgroup.zmultiples a))) Filter.cofinite (Filter.cocompact ‚Ñù)","name":"AddSubgroup.tendsto_zmultiples_subtype_cofinite","isProp":true,"docString":"The subgroup \"multiples of `a`\" (`zmultiples a`) is a discrete subgroup of `‚Ñù`, i.e. its\nintersection with compact sets is finite. "},{"type":"‚àÄ {S : Type u_1} {G : Type u_2} [inst : Inv G] [inst_1 : SetLike S G] [self : InvMemClass S G] {s : S} {x : G}\n  (a : x ‚àà s), x‚Åª¬π ‚àà s","name":"InvMemClass.inv_mem","isProp":true,"docString":"`s` is closed under inverses "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] (h : IsComplete Set.univ), CompleteSpace Œ±","name":"completeSpace_of_isComplete_univ","isProp":true,"docString":"If `univ` is complete, the space is a complete space "},{"type":"‚àÄ {M : Type u_2} [inst : AddMonoid M] {Œπ : Type u_1} [hŒπ : Nonempty Œπ] {s : (a : Œπ) ‚Üí Set M}\n  (hs : ‚àÄ (i : Œπ), IsAddSubmonoid (s i))\n  (Directed : ‚àÄ (i : Œπ) (j : Œπ), ‚àÉ (k : Œπ), (s i ‚äÜ s k : Prop) ‚àß (s j ‚äÜ s k : Prop)),\n  IsAddSubmonoid (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ s i)","name":"isAddSubmonoid_union·µ¢_of_directed","isProp":true,"docString":"The union of an indexed, directed, nonempty set of `AddSubmonoid`s of an `AddMonoid` `M`\nis an `AddSubmonoid` of `M`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ‚Ñï}\n  (h : Finset.card fs = m + 1) (i : Fin (m + 1)),\n  Affine.Simplex.points (Affine.Simplex.face s h) i = Affine.Simplex.points s (‚Üë(Finset.orderEmbOfFin fs h) i)","name":"Affine.Simplex.face_points","isProp":true,"docString":"The points of a face of a simplex are given by `mono_of_fin`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (self : AddGroupNorm G) (x : G)\n  (a : AddGroupSeminorm.toFun (AddGroupNorm.toAddGroupSeminorm self) x = 0), x = 0","name":"AddGroupNorm.eq_zero_of_map_eq_zero'","isProp":true,"docString":"If the image under the seminorm is zero, then the argument is zero. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±), EMetric.ball x ‚ä§ = Set.univ","name":"Metric.eball_top_eq_univ","isProp":true,"docString":"In a pseudometric space, an open ball of infinite radius is the whole space "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] (c : ClosureOperator Œ±),\n  ClosureOperator.closed c = Set.range ‚Üë(ClosureOperator.toOrderHom c)","name":"ClosureOperator.closed_eq_range_close","isProp":true,"docString":"The set of closed elements for `c` is exactly its range. "},{"type":"‚àÄ {Œ± : Type u_1} [self : BiheytingAlgebra Œ±] (a : Œ±) (b : Œ±) (c : Œ±), (a \\ b ‚â§ c : Prop) ‚Üî (a ‚â§ b ‚äî c : Prop)","name":"BiheytingAlgebra.sdiff_le_iff","isProp":true,"docString":"`\\ a` is right adjoint to `‚äî a` "},{"type":"‚àÄ {n : ‚Ñï} {p : ‚Ñï} {k : ‚Ñï} (hn : n ‚â† 0) (h : Nat.factorization n = Finsupp.single p k), n = p ^ k","name":"Nat.eq_pow_of_factorization_eq_single","isProp":true,"docString":"If the factorization of `n` contains just one number `p` then `n` is a power of `p` "},{"type":"‚àÄ {p : ‚Ñï}, padicNorm p 0 = 0","name":"padicNorm.zero","isProp":true,"docString":"The `p`-adic norm of `0` is `0`. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {a : M} {x : MÀ£} {y : MÀ£} (h : SemiconjBy a ‚Üëx ‚Üëy), SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π","name":"SemiconjBy.units_inv_right","isProp":true,"docString":"If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `x‚Åª¬π` to `y‚Åª¬π`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] [inst_4 : Nontrivial Œ±] {s : Set Œ±},\n  (Dense s : Prop) ‚Üî\n    (‚àÄ (a : Œ±) (b : Œ±) (a_1 : a < b), ‚àÉ (c : Œ±), (c ‚àà s : Prop) ‚àß ((a < c : Prop) ‚àß (c < b : Prop) : Prop) : Prop)","name":"dense_iff_exists_between","isProp":true,"docString":"A set in a nontrivial densely linear ordered type is dense in the sense of topology if and only\nif for any `a < b` there exists `c ‚àà s`, `a < c < b`. Each implication requires less typeclass\nassumptions. "},{"type":"‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {A : Set V}\n  (hA : Set.Finite A), FiniteDimensional K { x : V // x ‚àà Submodule.span K A }","name":"FiniteDimensional.span_of_finite","isProp":true,"docString":"The submodule generated by a finite set is finite-dimensional. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CommSemiring Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (g : (a : Œ±) ‚Üí Œ≤) (s : Finset Œ±),\n  (Finset.prod s fun (a : Œ±) ‚Ü¶ f a + g a) =\n    Finset.sum (Finset.powerset s) fun (t : Finset Œ±) ‚Ü¶\n      (Finset.prod t fun (a : Œ±) ‚Ü¶ f a) * Finset.prod (s \\ t) fun (a : Œ±) ‚Ü¶ g a","name":"Finset.prod_add","isProp":true,"docString":"The product of `f a + g a` over all of `s` is the sum\nover the powerset of `s` of the product of `f` over a subset `t` times\nthe product of `g` over the complement of `t`  "},{"type":"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsAtomistic (Submodule K V)","name":"instIsAtomisticSubmoduleToSemiringToDivisionSemiringToAddCommMonoidCompleteLattice","isProp":true,"docString":"The lattice of submodules of a module over a division ring is atomistic. "},{"type":"‚àÄ {Œπ : Type u_1} [inst : Fintype Œπ], stdSimplex ‚Ñù Œπ ‚äÜ Metric.closedBall 0 1","name":"stdSimplex_subset_closedBall","isProp":true,"docString":"Every vector in `stdSimplex ùïú Œπ` has `max`-norm at most `1`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.WellPowered C]\n  [inst_2 : CategoryTheory.Limits.HasLimits C] {ùí¢ : Set C} [inst_3 : Small ‚Üëùí¢] (hùí¢ : CategoryTheory.IsCoseparating ùí¢),\n  CategoryTheory.Limits.HasInitial C","name":"CategoryTheory.hasInitial_of_isCoseparating","isProp":true,"docString":"An ingredient of the proof of the Special Adjoint Functor Theorem: a complete well-powered\ncategory with a small coseparating set has an initial object.\n\nIn fact, it follows from the Special Adjoint Functor Theorem that `C` is already cocomplete,\nsee `hasColimits_of_hasLimits_of_isCoseparating`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ±] [inst_1 : AddCommMonoid Œ≤] {s : Finset Œ±} {x : Œ±}\n  (h : ¬¨(x ‚àà s : Prop)) (f : (a : Finset Œ±) ‚Üí Œ≤),\n  (Finset.sum (Finset.powerset (insert x s)) fun (a : Finset Œ±) ‚Ü¶ f a) =\n    (Finset.sum (Finset.powerset s) fun (a : Finset Œ±) ‚Ü¶ f a) +\n      Finset.sum (Finset.powerset s) fun (t : Finset Œ±) ‚Ü¶ f (insert x t)","name":"Finset.sum_powerset_insert","isProp":true,"docString":"A sum over all subsets of `s ‚à™ {x}` is obtained by summing the sum over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddGroup Œ±] [inst_1 : AddCommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : IsAddGroupHom f) (hg : IsAddGroupHom g), IsAddGroupHom fun (a : Œ±) ‚Ü¶ f a + g a","name":"IsAddGroupHom.add","isProp":true,"docString":"The sum of two additive group homomorphisms is an additive group homomorphism\nif the target is commutative."},{"type":"‚àÄ {Œπ : Sort u_1} {f : (a : Œπ) ‚Üí ‚Ñù} (hf : ‚àÄ (i : Œπ), 0 ‚â§ f i), 0 ‚â§ inf·µ¢ f","name":"Real.inf·µ¢_nonneg","isProp":true,"docString":"As `0` is the default value for `Real.inf‚Çõ` of the empty set, it suffices to show that `f i` is\nbounded below by `0` to show that `0 ‚â§ inf·µ¢ f`.\n"},{"type":"‚àÄ {Œ± : Type u_1} (s : Finset Œ±), Finset.card (Finset.powerset s) = 2 ^ Finset.card s","name":"Finset.card_powerset","isProp":true,"docString":"**Number of Subsets of a Set** "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] (self : Flag Œ±), IsChain (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) (Flag.carrier self)","name":"Flag.Chain'","isProp":true,"docString":"By definition, a flag is a chain "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : StrictAntiOn f s), StrictMonoOn (f ‚àò ‚ÜëOrderDual.ofDual) s","name":"StrictAntiOn.dual_left","isProp":true,"docString":"**Alias** of the reverse direction of `strictMonoOn_comp_ofDual_iff`."},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : CancelMonoidWithZero M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ} (h‚ÇÅ : b ‚â† 1) (h‚ÇÇ : a * b = a), a = 0","name":"eq_zero_of_mul_eq_self_right","isProp":true,"docString":"An element of a `CancelMonoidWithZero` fixed by right multiplication by an element other\nthan one must be zero. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ≤]\n  (f : CocompactMap Œ± Œ≤) ‚¶És : Set Œ≤‚¶Ñ (hs : IsCompact s), IsCompact (‚Üëf ‚Åª¬π' s)","name":"CocompactMap.isCompact_preimage","isProp":true,"docString":"If the codomain is Hausdorff, preimages of compact sets are compact under a cocompact\ncontinuous map. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±]\n  (H : FreeAddGroup.Red (FreeAddGroup.reduce L‚ÇÅ) L‚ÇÇ), FreeAddGroup.reduce L‚ÇÅ = L‚ÇÇ","name":"FreeAddGroup.reduce.min","isProp":true,"docString":"The second theorem that characterises the function `reduce`: the maximal reduction of\na word  only reduces to itself."},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : Semiring R] [inst_1 : NoZeroDivisors R] [inst_2 : AddRightCancelSemigroup A]\n  [inst_3 : LinearOrder A]\n  [inst_4 : CovariantClass A A (fun (x : A) (x_1 : A) ‚Ü¶ x + x_1) fun (x : A) (x_1 : A) ‚Ü¶ x < x_1],\n  NoZeroDivisors (AddMonoidAlgebra R A)","name":"AddMonoidAlgebra.NoZeroDivisors.of_left_ordered","isProp":true,"docString":"If `R` is a semiring with no non-trivial zero-divisors and `A` is a left-ordered add right\ncancel semigroup, then `AddMonoidAlgebra R A` also contains no non-zero zero-divisors. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atTop),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atBot : Prop) ‚Üî (r < 0 : Prop)","name":"Filter.tendsto_const_mul_atBot_iff_neg","isProp":true,"docString":"If `f` tends to infinity along a nontrivial filter `l`, then `Œª x, r * f x` tends to negative\ninfinity if and only if `r < 0. `"},{"type":"‚àÄ (R : Type u) [inst : Field R], IsField R","name":"Field.toIsField","isProp":true,"docString":"Transferring from `Field` to `IsField`. "},{"type":"‚àÄ {K : Type u} [self : DivisionRing K], 0‚Åª¬π = 0","name":"DivisionRing.inv_zero","isProp":true,"docString":"We define the inverse of `0` to be `0`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (a_1 : IsMin a), a = ‚ä•","name":"IsMin.eq_bot","isProp":true,"docString":"**Alias** of the forward direction of `isMin_iff_eq_bot`."},{"type":"‚àÄ {S‚ÇÄ : Type u} [self : SemigroupWithZero S‚ÇÄ] (a : S‚ÇÄ), a * 0 = 0","name":"SemigroupWithZero.mul_zero","isProp":true,"docString":"Zero is a right absorbing element for multiplication "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {a : R} {b : R} [inst : Monoid R] [inst_1 : MulAction R M] (h : a * b = 1),\n  IsSMulRegular M b","name":"IsSMulRegular.of_mul_eq_one","isProp":true,"docString":"An element of `R` admitting a left inverse is `M`-regular. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SeparableSpace Œ±] {Œπ : Type u_1} {s : (a : Œπ) ‚Üí Set Œ±}\n  {a : Set Œπ} (h : Set.PairwiseDisjoint a s) (ha : ‚àÄ (i : Œπ) (a : i ‚àà a), Set.Nonempty (interior (s i))),\n  Set.Countable a","name":"Set.PairwiseDisjoint.countable_of_nonempty_interior","isProp":true,"docString":"In a separable space, a family of disjoint sets with nonempty interiors is countable. "},{"type":"‚àÄ {Œ± : Type u_1} (s : Set Œ±), (fun (x : Œ±) ‚Ü¶ x) '' s = s","name":"Set.image_id'","isProp":true,"docString":"A variant of `image_id` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {m : ‚Ñï} {n : ‚Ñï}\n  (hùíú : IsAntichain (fun (x : Finset Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚äÜ x_1) ‚Üëùíú),\n  Disjoint (Finset.slice ùíú m) (Finset.shadow (Finset.falling n ùíú))","name":"Finset.IsAntichain.disjoint_slice_shadow_falling","isProp":true,"docString":"The shadow of `falling m ùíú` is disjoint from the `n`-sized elements of `ùíú`, thanks to the\nantichain property. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±]\n  (L :\n    ‚àÄ (x : Œ±) (a : x ‚àà s) (u : Set (Œ≤ √ó Œ≤)) (a : u ‚àà uniformity Œ≤),\n      ‚àÉ (t : Set Œ±),\n        (t ‚àà nhdsWithin x s : Prop) ‚àß\n          (‚àÉ (F : (a : Œ±) ‚Üí Œ≤), (ContinuousWithinAt F s x : Prop) ‚àß (‚àÄ (y : Œ±) (a : y ‚àà t), (f y, F y) ‚àà u : Prop) :\n            Prop)),\n  ContinuousOn f s","name":"continuousOn_of_locally_uniform_approx_of_continuousWithinAt","isProp":true,"docString":"A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Monotone f) {x : Œ±}\n  [inst_4 : TopologicalSpace Œ±] [inst_5 : OrderTopology Œ±],\n  (ContinuousWithinAt f (Set.Ioi x) x : Prop) ‚Üî (Function.rightLim f x = f x : Prop)","name":"Monotone.continuousWithinAt_Ioi_iff_rightLim_eq","isProp":true,"docString":"A monotone function is continuous to the right at a point if and only if its right limit\ncoincides with the value of the function. "},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï} {k : ‚Ñï} {b : ‚Ñï} (hp : Nat.Prime p) (hkn : k ‚â§ n) (hnb : Nat.log p n < b),\n  multiplicity p (Nat.choose n k) =\n    ‚Üë(Finset.card (Finset.filter (fun (i : ‚Ñï) ‚Ü¶ p ^ i ‚â§ k % p ^ i + (n - k) % p ^ i) (Finset.Ico 1 b)))","name":"Nat.Prime.multiplicity_choose","isProp":true,"docString":"The multiplicity of `p` in `choose n k` is the number of carries when `k` and `n - k`\nare added in base `p`. The set is expressed by filtering `Ico 1 b` where `b`\nis any bound greater than `log p n`. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (S : Type u_1) [inst_1 : SetLike S K] [h : SubfieldClass S K], SubgroupClass S K","name":"SubfieldClass.toSubgroupClass","isProp":true,"docString":"A subfield contains `1`, products and inverses.\n\nBe assured that we're not actually proving that subfields are subgroups:\n`SubgroupClass` is really an abbreviation of `SubgroupWithOrWithoutZeroClass`.\n "},{"type":"‚àÄ {R : Type u_6} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_5} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] {P : Type u_3} [inst_3 : CommSemiring P] [inst_4 : IsLocalization M S] {g : R ‚Üí+* P}\n  {T : Submonoid P} {Q : Type u_4} [inst_5 : CommSemiring Q] (hy : M ‚â§ Submonoid.comap g T) [inst_6 : Algebra P Q]\n  [inst_7 : IsLocalization T Q] {A : Type u_1} [inst_8 : CommSemiring A] {U : Submonoid A} {W : Type u_2}\n  [inst_9 : CommSemiring W] [inst_10 : Algebra A W] [inst_11 : IsLocalization U W] {l : P ‚Üí+* A}\n  (hl : T ‚â§ Submonoid.comap l U) (x : S),\n  ‚Üë(IsLocalization.map W l hl) (‚Üë(IsLocalization.map Q g hy) x) =\n    ‚Üë(IsLocalization.map W (RingHom.comp l g)\n          (fun (x : R) ‚Ü¶\n            (_ : ‚àÄ (hx : x ‚àà M), ‚Üëg x ‚àà Submonoid.comap l U)=:‚àÄ (x : R) (hx : x ‚àà M), ‚Üëg x ‚àà Submonoid.comap l U))\n      x","name":"IsLocalization.map_map","isProp":true,"docString":"If `CommSemiring` homs `g : R ‚Üí+* P, l : P ‚Üí+* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ‚àò g`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} [inst : DecidableEq Œ≤']\n  [inst_1 : DecidableEq Œ≥] [inst_2 : DecidableEq Œ¥] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥}\n  {g : (a : Œ≤) ‚Üí Œ≤'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_right_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), f a (g b) = g' (f' b a)),\n  Finset.image‚ÇÇ f s (Finset.image g t) = Finset.image g' (Finset.image‚ÇÇ f' t s)","name":"Finset.image_image‚ÇÇ_right_anticomm","isProp":true,"docString":"Symmetric statement to `Finset.image_image‚ÇÇ_antidistrib_right`. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±}, (List.Sublist l [] : Prop) ‚Üî (l = [] : Prop)","name":"List.sublist_nil_iff_eq_nil","isProp":true,"docString":"**Alias** of `List.sublist_nil`."},{"type":"‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddCommGroup Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (a : Œ±),\n  abs (abs a) = abs a","name":"LatticeOrderedCommGroup.abs_abs","isProp":true,"docString":"The unary operation of taking the absolute value is idempotent."},{"type":"‚àÄ {b : ‚Ñï} {m : ‚Ñï} {d : ‚Ñï} (a : d ‚àà Nat.digits (b + 2) m), d < b + 2","name":"Nat.digits_lt_base'","isProp":true,"docString":"The digits in the base b+2 expansion of n are all less than b+2 "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {i : D ‚•§ C}\n  [inst_2 : CategoryTheory.Reflective i] {A : C} {B : D}\n  (f :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor i)\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.leftAdjoint i)) A) ‚ü∂\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor i) B),\n  ‚Üë(Equiv.symm (CategoryTheory.unitCompPartialBijectiveAux A B)) f =\n    (CategoryTheory.Adjunction.unit (CategoryTheory.Adjunction.ofRightAdjoint i)).app A ‚â´ f","name":"CategoryTheory.unitCompPartialBijectiveAux_symm_apply","isProp":true,"docString":"The description of the inverse of the bijection `unitCompPartialBijectiveAux`. "},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (hab : Nat.coprime a b), Nat.factorization (a * b) = Nat.factorization a + Nat.factorization b","name":"Nat.factorization_mul_of_coprime","isProp":true,"docString":"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  {s : Set Œ±} (hs : IsPreconnected s),\n  s ‚àà\n    {Set.Icc (inf‚Çõ s) (sup‚Çõ s), Set.Ico (inf‚Çõ s) (sup‚Çõ s), Set.Ioc (inf‚Çõ s) (sup‚Çõ s), Set.Ioo (inf‚Çõ s) (sup‚Çõ s),\n      Set.Ici (inf‚Çõ s), Set.Ioi (inf‚Çõ s), Set.Iic (sup‚Çõ s), Set.Iio (sup‚Çõ s), Set.univ, ‚àÖ}","name":"IsPreconnected.mem_intervals","isProp":true,"docString":"A preconnected set in a conditionally complete linear order is either one of the intervals\n`[Inf s, Sup s]`, `[Inf s, Sup s)`, `(Inf s, Sup s]`, `(Inf s, Sup s)`, `[Inf s, +‚àû)`,\n`(Inf s, +‚àû)`, `(-‚àû, Sup s]`, `(-‚àû, Sup s)`, `(-‚àû, +‚àû)`, or `‚àÖ`. The converse statement requires\n`Œ±` to be densely ordererd. "},{"type":"‚àÄ {R : Type u‚ÇÅ} [inst : NonUnitalNonAssocSemiring R], SMulCommClass ‚Ñï R R","name":"NonUnitalNonAssocSemiring.nat_smulCommClass","isProp":true,"docString":"Note that `AddCommMonoid.nat_smulCommClass` requires stronger assumptions on `R`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasKernels C], CategoryTheory.Limits.HasEqualizers C","name":"CategoryTheory.Preadditive.hasEqualizers_of_hasKernels","isProp":true,"docString":"If a preadditive category has all kernels, then it also has all equalizers. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhdsWithin a (Set.Ici a))\n  (hfs : ‚àÄ (b : Œ≤) (a_1 : b > f a), ‚àÉ (c : Œ±), (c ‚àà s : Prop) ‚àß (f c ‚àà Set.Ioc (f a) b : Prop)),\n  ContinuousWithinAt f (Set.Ici a) a","name":"StrictMonoOn.continuousWithinAt_right_of_exists_between","isProp":true,"docString":"If `f` is a function strictly monotone on a right neighborhood of `a` and the\nimage of this neighborhood under `f` meets every interval `(f a, b]`, `b > f a`, then `f` is\ncontinuous at `a` from the right.\n\nThe assumption `hfs : ‚àÄ b > f a, ‚àÉ c ‚àà s, f c ‚àà Ioc (f a) b` is required because otherwise the\nfunction `f : ‚Ñù ‚Üí ‚Ñù` given by `f x = if x ‚â§ 0 then x else x + 1` would be a counter-example at\n`a = 0`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Infinite Œ≤] (f : (a : Œ±) ‚Üí Finset Œ≤)\n  (w : (Set.union·µ¢ fun (a : Œ±) ‚Ü¶ ‚Üë(f a)) = ‚ä§), Cardinal.mk Œ≤ ‚â§ Cardinal.mk ‚Üë(Set.range f)","name":"Cardinal.le_range_of_union_finset_eq_top","isProp":true,"docString":"If an infinite type `Œ≤` can be expressed as a union of finite sets,\nthen the cardinality of the collection of those finite sets\nmust be at least the cardinality of `Œ≤`.\n"},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel (SimpleGraph.Adj G)]\n  [inst_2 : Fintype (Sym2 V)] [inst_3 : DecidableEq V],\n  (Finset.sum Finset.univ fun (v : V) ‚Ü¶ SimpleGraph.degree G v) = 2 * Finset.card (SimpleGraph.edgeFinset G)","name":"SimpleGraph.sum_degrees_eq_twice_card_edges","isProp":true,"docString":"The degree-sum formula.  This is also known as the handshaking lemma, which might\nmore specifically refer to `SimpleGraph.even_card_odd_degree_vertices`. "},{"type":"‚àÄ {P : Type u_1} [inst : Preorder P] (s : Order.PFilter P) (t : Order.PFilter P) (h : ‚Üës = ‚Üët), s = t","name":"Order.PFilter.ext","isProp":true,"docString":"Two filters are equal when their underlying sets are equal. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {s : Set M} {a : M} (hs : IsAddSubmonoid s) (h : a ‚àà s) {n : ‚Ñï}, n ‚Ä¢ a ‚àà s","name":"IsAddSubmonoid.nsmul_mem","isProp":true,"docString":"An `AddSubmonoid` is closed under multiplication by naturals."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T0Space Œ±] ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : Inseparable x y), x = y","name":"T0Space.t0","isProp":true,"docString":"Two inseparable points in a T‚ÇÄ space are equal. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (connected_fibers : ‚àÄ (t : Œ≤), IsConnected (f ‚Åª¬π' {t}))\n  (hcl : ‚àÄ (T : Set Œ≤), (IsClosed T : Prop) ‚Üî (IsClosed (f ‚Åª¬π' T) : Prop)) (t : Œ≤),\n  IsConnected (f ‚Åª¬π' connectedComponent t)","name":"preimage_connectedComponent_connected","isProp":true,"docString":"The preimage of a connected component is preconnected if the function has connected fibers\nand a subset is closed iff the preimage is. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (F : C·µí·µñ ‚•§ Type v),\n  CategoryTheory.Functor.rightOp (CategoryTheory.CategoryOfElements.toCostructuredArrow F) ‚ãô\n      CategoryTheory.CategoryOfElements.fromCostructuredArrow F =\n    ùü≠ (CategoryTheory.Functor.Elements F)","name":"CategoryTheory.CategoryOfElements.from_toCostructuredArrow_eq","isProp":true,"docString":"The unit of the equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)` is indeed iso. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (h : M ‚âÉ+ N), IsAddMonoidHom ‚Üëh","name":"AddEquiv.isAddMonoidHom","isProp":true,"docString":"An additive bijection between two additive monoids is an additive\nmonoid hom (deprecated). "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (habc : btw a b c) (hcba : ¬¨(btw c b a : Prop)),\n  sbtw a b c","name":"Btw.btw.sbtw_of_not_btw","isProp":true,"docString":"**Alias** of `sbtw_of_btw_not_btw`."},{"type":"‚àÄ {M : Type u_3} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {P : Type u_1}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëg ‚Üëy)) (z : N) (v : (fun (x : N) ‚Ü¶ P) z),\n  (‚Üë(Submonoid.LocalizationMap.lift f hg) z = v : Prop) ‚Üî\n    (‚Üëg (Prod.fst (Submonoid.LocalizationMap.sec f z)) = ‚Üëg ‚Üë(Prod.snd (Submonoid.LocalizationMap.sec f z)) * v : Prop)","name":"Submonoid.LocalizationMap.lift_spec","isProp":true,"docString":"Given a Localization map `f : M ‚Üí* N` for a Submonoid `S ‚äÜ M`, if a `CommMonoid` map\n`g : M ‚Üí* P` induces a map `f.lift hg : N ‚Üí* P` then for all `z : N, v : P`, we have\n`f.lift hg z = v ‚Üî g x = g y * v`, where `x : M, y ‚àà S` are such that `z * f y = f x`. "},{"type":"‚àÄ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K ‚Üí+* L) (f : Polynomial K),\n  (Polynomial.Splits i f : Prop) ‚Üî\n    ((f = 0 : Prop) ‚à®\n        (‚àÄ {g : Polynomial L} (a : Irreducible g) (a : g ‚à£ Polynomial.map i f), Polynomial.degree g = 1 : Prop) :\n      Prop)","name":"Polynomial.splits_iff","isProp":true,"docString":"This lemma is for polynomials over a field. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G} (a : ‚àÄ (x : G) (a : x ‚àà l), x ‚àà K), List.prod l ‚àà K","name":"Subgroup.list_prod_mem","isProp":true,"docString":"Product of a list of elements in a subgroup is in the subgroup. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  [self : CategoryTheory.Functor.PreservesEpimorphisms F] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Epi f],\n  CategoryTheory.Epi (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)","name":"CategoryTheory.Functor.PreservesEpimorphisms.preserves","isProp":true,"docString":"A functor preserves epimorphisms if it maps epimorphisms to epimorphisms. "},{"type":"‚àÄ {G : Type u} [self : SubtractionCommMonoid G] (a : G) (b : G), a + b = b + a","name":"SubtractionCommMonoid.add_comm","isProp":true,"docString":"Addition is commutative in an additive commutative semigroup. "},{"type":"‚àÄ {n : ‚Ñï} {p : ‚Ñï √ó ‚Ñï} {q : ‚Ñï √ó ‚Ñï} (hp : p ‚àà Finset.Nat.antidiagonal n) (hq : q ‚àà Finset.Nat.antidiagonal n),\n  (p = q : Prop) ‚Üî (Prod.fst p = Prod.fst q : Prop)","name":"Finset.Nat.antidiagonal_congr","isProp":true,"docString":"A point in the antidiagonal is determined by its first co-ordinate. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : CommMonoid M] {g : (a : Œ≤) ‚Üí M} (e : (a : Œ±) ‚Üí Œ≤)\n  (he‚ÇÄ : Function.Bijective e), (finprod fun (i : Œ±) ‚Ü¶ g (e i)) = finprod fun (j : Œ≤) ‚Ü¶ g j","name":"finprod_comp","isProp":true,"docString":"See also `finprod_eq_of_bijective`, `Fintype.prod_bijective` and `Finset.prod_bij`. "},{"type":"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a : S} {b : S} {x : S} {y : S} {z : S} (ha : AddSemiconjBy a y z)\n  (hb : AddSemiconjBy b x y), AddSemiconjBy (a + b) x z","name":"AddSemiconjBy.add_left","isProp":true,"docString":"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a + b`\nsemiconjugates `x` to `z`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (G : CategoryTheory.Comonad C)\n  {X : CategoryTheory.Comonad.Coalgebra G} {Y : CategoryTheory.Comonad.Coalgebra G} (f : X ‚ü∂ Y)\n  [h : CategoryTheory.Mono (CategoryTheory.Comonad.Coalgebra.Hom.f f)], CategoryTheory.Mono f","name":"CategoryTheory.Comonad.algebra_mono_of_mono","isProp":true,"docString":"Given a coalgebra morphism whose carrier part is a monomorphism, we get an algebra monomorphism.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst : LowerTopology Œ±], T0Space Œ±","name":"LowerTopology.t0Space","isProp":true,"docString":"The lower topology on a partial order is T‚ÇÄ. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {g : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} {p : (a : Œ≤) ‚Üí Prop} [inst : DecidablePred p]\n  {f : Œ± ‚âÉ Subtype p} (a : Equiv.Perm.SameCycle g x y),\n  Equiv.Perm.SameCycle (Equiv.Perm.extendDomain g f) ‚Üë(‚Üëf x) ‚Üë(‚Üëf y)","name":"Equiv.Perm.SameCycle.extendDomain","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_extendDomain`."},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) {v : V} {w : V},\n  (SimpleGraph.Adj G v w : Prop) ‚Üî\n    ((v ‚â† w : Prop) ‚àß\n        (‚àÉ (e : Sym2 V), (e ‚àà SimpleGraph.edgeSet G : Prop) ‚àß ((v ‚àà e : Prop) ‚àß (w ‚àà e : Prop) : Prop) : Prop) :\n      Prop)","name":"SimpleGraph.adj_iff_exists_edge","isProp":true,"docString":"Two vertices are adjacent iff there is an edge between them. The\ncondition `v ‚â† w` ensures they are different endpoints of the edge,\nwhich is necessary since when `v = w` the existential\n`‚àÉ (e ‚àà G.edgeSet), v ‚àà e ‚àß w ‚àà e` is satisfied by every edge\nincident to `v`. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R) (hqf : IsField (R ‚ß∏ I)), Ideal.IsMaximal I","name":"Ideal.Quotient.maximal_of_isField","isProp":true,"docString":"If the quotient by an ideal is a field, then the ideal is maximal. "},{"type":"‚àÄ (Œπ : Type u_1) (R : Type u) (M : Type v) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M] [inst_4 : Finite Œπ], Module.Free R ((a : Œπ) ‚Üí M)","name":"Module.Free.function","isProp":true,"docString":"The product of finitely many free modules is free (non-dependent version to help with typeclass\nsearch). "},{"type":"‚àÄ {Œ± : Type u_1} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (a : l‚ÇÅ <+: l‚ÇÇ), List.reverse l‚ÇÅ <:+ List.reverse l‚ÇÇ","name":"List.isPrefix.reverse","isProp":true,"docString":"**Alias** of the reverse direction of `List.reverse_suffix`."},{"type":"‚àÄ {p : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (hpb : p ‚àà Nat.factors b) (ha : a ‚â† 0), p ‚àà Nat.factors (a * b)","name":"Nat.mem_factors_mul_right","isProp":true,"docString":"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} {K : Subgroup G} (h : ‚àÄ (x : G), (x ‚àà H : Prop) ‚Üî (x ‚àà K : Prop)),\n  H = K","name":"Subgroup.ext","isProp":true,"docString":"Two subgroups are equal if they have the same elements. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {e' : LocalHomeomorph Œ± Œ≤} (h : e ‚âà e'), Set.EqOn (‚Üëe) (‚Üëe') (LocalEquiv.source (LocalHomeomorph.toLocalEquiv e))","name":"LocalHomeomorph.EqOnSource.eqOn","isProp":true,"docString":"Two equivalent local homeomorphisms have coinciding `toFun` on the source "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : MonovaryOn f g ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i) ‚Ä¢ Finset.sum s fun (i : Œπ) ‚Ü¶ g i) ‚â§\n    Finset.card s ‚Ä¢ Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i","name":"MonovaryOn.sum_smul_sum_le_card_smul_sum","isProp":true,"docString":"**Chebyshev's Sum Inequality**: When `f` and `g` monovary together (eg they are both\nmonotone/antitone), the scalar product of their sum is less than the size of the set times their\nscalar product. "},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_1} {M : Type u_2} {v : (a : Œπ) ‚Üí M} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] {s : Set Œπ},\n  (¬¨(LinearIndependent R (v ‚àò Subtype.val) : Prop) : Prop) ‚Üî\n    (‚àÉ (f : Œπ ‚Üí‚ÇÄ R),\n        (f ‚àà Finsupp.supported R R s : Prop) ‚àß\n          (((Finset.sum (Finsupp.support f) fun (i : Œπ) ‚Ü¶ ‚Üëf i ‚Ä¢ v i) = 0 : Prop) ‚àß (f ‚â† 0 : Prop) : Prop) :\n      Prop)","name":"linearDependent_comp_subtype","isProp":true,"docString":"A version of `linearDependent_comp_subtype'` with `Finsupp.total` unfolded. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {S : Set Œ≤}\n  {f : (x : Œ≤) ‚Üí (a : x ‚àà S) ‚Üí Set Œ±} (ho : ‚àÄ (s : Œ≤) (H : s ‚àà S), IsGŒ¥ (f s H)) (hS : Set.Countable S)\n  (hd : ‚àÄ (s : Œ≤) (H : s ‚àà S), Dense (f s H)), Dense (Set.inter·µ¢ fun (s : Œ≤) ‚Ü¶ Set.inter·µ¢ fun (h : s ‚àà S) ‚Ü¶ f s h)","name":"dense_binter·µ¢_of_GŒ¥","isProp":true,"docString":"Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with\nan index set which is a countable set in any type. "},{"type":"‚àÄ (Œπ : Type u_1) [inst : Fintype Œπ], Metric.Bounded (stdSimplex ‚Ñù Œπ)","name":"bounded_stdSimplex","isProp":true,"docString":"`stdSimplex ‚Ñù Œπ` is bounded. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  {c : CategoryTheory.Limits.Cofork f g} (i : CategoryTheory.Limits.IsColimit c),\n  CategoryTheory.Epi (CategoryTheory.Limits.Cofork.œÄ c)","name":"CategoryTheory.Limits.epi_of_isColimit_cofork","isProp":true,"docString":"The coequalizer morphism in any colimit cocone is an epimorphism. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} {d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d), a + c < b + d","name":"Left.add_lt_add","isProp":true,"docString":"Only assumes left strict covariance"},{"type":"‚àÄ (N : ‚Ñï) (i : ‚Ñï), Polynomial.revAtFun N i = ‚Üë(Polynomial.revAt N) i","name":"Polynomial.revAtFun_eq","isProp":true,"docString":"We prefer to use the bundled `revAt` over unbundled `revAtfun`. "},{"type":"‚àÄ {M : Type u_2} [inst : Mul M] {Œ≤ : Sort u_1} (c : Con M) (f : (a : M) ‚Üí Œ≤)\n  (h : ‚àÄ (a : M) (b : M) (a_1 : ‚Üëc a b), f a = f b) (x : M), Con.liftOn (‚Üëx) f h = f x","name":"Con.liftOn_coe","isProp":true,"docString":"Definition of the function on the quotient by a congruence relation `c` induced by a function\nthat is constant on `c`'s equivalence classes. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] {f : Filter Œ≤} {u : (a : Œ≤) ‚Üí Œ±} {a : Œ±} (hinf : a ‚â§ Filter.liminf u f)\n  (hsup : Filter.limsup u f ‚â§ a)\n  (h : autoParam (Filter.IsBoundedUnder (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) f u : Prop) _auto‚úù)\n  (h' : autoParam (Filter.IsBoundedUnder (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â• x_1) f u : Prop) _auto‚úù¬π),\n  Filter.Tendsto u f (nhds a)","name":"tendsto_of_le_liminf_of_limsup_le","isProp":true,"docString":"If a number `a` is less than or equal to the `liminf` of a function `f` at some filter\nand is greater than or equal to the `limsup` of `f`, then `f` tends to `a` along this filter. "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_2} {N : Type u_4} {R : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid N] [inst_3 : DistribMulAction R M] [inst_4 : DistribMulAction R N] {f : (Œ± ‚Üí‚ÇÄ M) ‚Üí+[R] N}\n  {g : (Œ± ‚Üí‚ÇÄ M) ‚Üí+[R] N}\n  (h :\n    ‚àÄ (a : Œ±),\n      DistribMulActionHom.comp f (Finsupp.DistribMulActionHom.single a) =\n        DistribMulActionHom.comp g (Finsupp.DistribMulActionHom.single a)),\n  f = g","name":"Finsupp.distribMulActionHom_ext'","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (H : Subgroup G) {f : N ‚Üí* G}\n  (hf : Function.Surjective ‚Üëf), Subgroup.comap f (Subgroup.normalizer H) = Subgroup.normalizer (Subgroup.comap f H)","name":"Subgroup.comap_normalizer_eq_of_surjective","isProp":true,"docString":"The preimage of the normalizer is equal to the normalizer of the preimage of a surjective\nfunction. "},{"type":"‚àÄ {R : Type v} [inst : CommRing R] {n : Type u_1} [inst_1 : Unique n] [inst_2 : DecidableEq n] [inst_3 : Fintype n]\n  (A : Matrix n n R), Matrix.det A = A default default","name":"Matrix.det_unique","isProp":true,"docString":"If `n` has only one element, the determinant of an `n` by `n` matrix is just that element.\nAlthough `Unique` implies `DecidableEq` and `Fintype`, the instances might\nnot be syntactically equal. Thus, we need to fill in the args explicitly. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (ht : IsCompact t) (hs : IsClosed s),\n  IsCompact (s ‚à© t)","name":"IsCompact.inter_left","isProp":true,"docString":"The intersection of a closed set and a compact set is a compact set. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hab : a = b) (hbc : b ‚â§ c), a ‚â§ c","name":"Eq.trans_le","isProp":true,"docString":"**Alias** of `le_of_eq_of_le`."},{"type":"‚àÄ {x : ‚Ñù} (a : 0 < x), 0 < Real.sqrt x","name":"Real.sqrt_pos_of_pos","isProp":true,"docString":"**Alias** of the reverse direction of `Real.sqrt_pos`."},{"type":"PNat.factorMultiset 1 = 0","name":"PNat.factorMultiset_one","isProp":true,"docString":"Factoring gives a homomorphism from the multiplicative\nmonoid ‚Ñï+ to the additive monoid of multisets. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)\n  [inst_3 : CategoryTheory.Epi g], CategoryTheory.Epi CategoryTheory.Limits.pullback.fst","name":"CategoryTheory.Abelian.epi_pullback_of_epi_g","isProp":true,"docString":"In an abelian category, the pullback of an epimorphism is an epimorphism. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (a : G), ‚Üë(Equiv.symm (Equiv.mulLeft a)) = fun (x : G) ‚Ü¶ a‚Åª¬π * x","name":"Equiv.mulLeft_symm_apply","isProp":true,"docString":"Extra simp lemma that `dsimp` can use. `simp` will never use this. "},{"type":"‚àÄ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  (Nonempty (V ‚âÉ‚Çó[K] V') : Prop) ‚Üî (Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') : Prop)","name":"LinearEquiv.nonempty_equiv_iff_lift_rank_eq","isProp":true,"docString":"Two vector spaces are isomorphic if and only if they have the same dimension. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : CommSemiring R] [inst_1 : CommSemiring S] [inst_2 : Algebra R S] (I : Ideal S)\n  (J : Ideal S), Submodule.restrictScalars R (I * J) = Submodule.restrictScalars R I * Submodule.restrictScalars R J","name":"Ideal.restrictScalars_mul","isProp":true,"docString":"The smallest `S`-submodule that contains all `x ‚àà I * y ‚àà J`\nis also the smallest `R`-submodule that does so. "},{"type":"‚àÄ {G : Type u} [inst : Group G] (B : GroupFilterBasis G), TopologicalGroup G","name":"GroupFilterBasis.isTopologicalGroup","isProp":true,"docString":"If a group is endowed with a topological structure coming from a group filter basis then it's a\ntopological group. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2}, Filter.coprod Filter.cofinite Filter.cofinite = Filter.cofinite","name":"Filter.coprod_cofinite","isProp":true,"docString":"The coproduct of the cofinite filters on two types is the cofinite filter on their product. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] {s : Set M} {p : (a : M) ‚Üí (a : M) ‚Üí Prop} {x : M} {y : M}\n  (hx : x ‚àà Submonoid.closure s) (hy : y ‚àà Submonoid.closure s) (Hs : ‚àÄ (x : M) (a : x ‚àà s) (y : M) (a : y ‚àà s), p x y)\n  (H1_left : ‚àÄ (x : M), p 1 x) (H1_right : ‚àÄ (x : M), p x 1)\n  (Hmul_left : ‚àÄ (x : M) (y : M) (z : M) (a : p x z) (a : p y z), p (x * y) z)\n  (Hmul_right : ‚àÄ (x : M) (y : M) (z : M) (a : p z x) (a : p z y), p z (x * y)), p x y","name":"Submonoid.closure_induction‚ÇÇ","isProp":true,"docString":"An induction principle for closure membership for predicates with two arguments.  "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [self : IsDirected Œ± r] (a : Œ±) (b : Œ±),\n  ‚àÉ (c : Œ±), (r a c : Prop) ‚àß (r b c : Prop)","name":"IsDirected.directed","isProp":true,"docString":"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hb : 0 ‚â§ b) (hc : 0 ‚â§ c) (h : a ‚â§ b / c),\n  a * c ‚â§ b","name":"mul_le_of_nonneg_of_le_div","isProp":true,"docString":"One direction of `div_le_iff` where `c` is allowed to be `0` (but `b` must be nonnegative) "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] {s : Set Œ±} {b : Œ±} (hs : Set.Nonempty s)\n  (hb : inf‚Çõ s < b), ‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (a < b : Prop)","name":"exists_lt_of_cinf‚Çõ_lt","isProp":true,"docString":"When `inf‚Çõ s < b`, there is an element `a` in `s` with `a < b`, if `s` is nonempty and the order\nis a linear order."},{"type":"‚àÄ {Œ± : Type u_1} {rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {C : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (a : WellFounded rŒ±)\n  (a :\n    ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ±)\n      (a :\n        ‚àÄ (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ±)\n          (a : Sym2.GameAdd rŒ± (Quotient.mk (Sym2.Rel.setoid Œ±) (a‚ÇÇ, b‚ÇÇ)) (Quotient.mk (Sym2.Rel.setoid Œ±) (a‚ÇÅ, b‚ÇÅ))),\n          C a‚ÇÇ b‚ÇÇ),\n      C a‚ÇÅ b‚ÇÅ)\n  (a : Œ±) (b : Œ±), C a b","name":"Sym2.GameAdd.induction","isProp":true,"docString":"Induction on the well-founded `Sym2.GameAdd` relation. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : D ‚•§ C}\n  (self : CategoryTheory.IsSkeletonOf C D F), CategoryTheory.Skeletal D","name":"CategoryTheory.IsSkeletonOf.skel","isProp":true,"docString":"The category `D` has isomorphic objects equal "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±],\n  Filter.HasBasis (uniformity Œ±) (fun (s : Set (Œ± √ó Œ±)) ‚Ü¶ (s ‚àà uniformity Œ± : Prop) ‚àß (SymmetricRel s : Prop)) id","name":"UniformSpace.hasBasis_symmetric","isProp":true,"docString":"Symmetric entourages form a basis of `ùì§ Œ±` "},{"type":"‚àÄ (R : Type u_1) (M : Type u_2) [inst : Subsingleton R] [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M], IsNoetherian R M","name":"isNoetherian_of_subsingleton","isProp":true,"docString":"Modules over the trivial ring are Noetherian. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}\n  {y : (i : Œπ) ‚Üí Œ≤ i} (a : hammingDist x y = 0), x = y","name":"eq_of_hammingDist_eq_zero","isProp":true,"docString":"Corresponds to `eq_of_dist_eq_zero`. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] (s : Multiset (Polynomial R)) (x : R),\n  Polynomial.eval x (Multiset.prod s) = Multiset.prod (Multiset.map (Polynomial.eval x) s)","name":"Polynomial.eval_multiset_prod","isProp":true,"docString":"Polynomial evaluation commutes with `Multiset.prod`\n"},{"type":"‚àÄ {Œ± : Type u} [self : OrderedCancelCommMonoid Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a : a * b ‚â§ a * c), b ‚â§ c","name":"OrderedCancelCommMonoid.le_of_mul_le_mul_left","isProp":true,"docString":"Cancellation is compatible with the order in an ordered cancellative commutative monoid. "},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : (a : X) ‚Üí Y} (hf : SeqContinuous f), Continuous f","name":"SeqContinuous.continuous","isProp":true,"docString":"A sequentially continuous function defined on a sequential space is continuous. "},{"type":"‚àÄ {a : ‚Ñï} (a1 : 1 < a) {x : ‚Ñï} {y : ‚Ñï} (hp : x * x - Pell.d a1 * y * y = 1),\n  ‚àÉ (n : ‚Ñï), (x = Pell.xn a1 n : Prop) ‚àß (y = Pell.yn a1 n : Prop)","name":"Pell.eq_pell","isProp":true,"docString":"Every solution to **Pell's equation** is recursively obtained from the initial solution\n`(1,0)` using the recursion `pell`. "},{"type":"‚àÄ {Œ± : Type u} [inst : MetricSpace Œ±] [inst_1 : ProperSpace Œ±] {R : (a : Œ±) ‚Üí ‚Ñù} (hR : ‚àÄ (x : Œ±), 0 < R x),\n  ‚àÉ (Œπ : Type u),\n    ‚àÉ (c : (a : Œπ) ‚Üí Œ±),\n      ‚àÉ (r : (a : Œπ) ‚Üí ‚Ñù),\n        ‚àÉ (r' : (a : Œπ) ‚Üí ‚Ñù),\n          (‚àÄ (i : Œπ), (0 < r i : Prop) ‚àß ((r i < r' i : Prop) ‚àß (r' i < R (c i) : Prop) : Prop) : Prop) ‚àß\n            ((LocallyFinite fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r' i) : Prop) ‚àß\n                ((Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r i)) = Set.univ : Prop) :\n              Prop)","name":"exists_locallyFinite_union·µ¢_eq_ball_radius_lt","isProp":true,"docString":"Let `R : Œ± ‚Üí ‚Ñù` be a (possibly discontinuous) positive function on a proper metric space. Then\nthere exists a collection of pairs of balls `Metric.ball (c i) (r i)`, `Metric.ball (c i) (r' i)`\nsuch that\n\n* for all `i` we have `0 < r i < r' i < R (c i)`;\n* the family of balls `Metric.ball (c i) (r' i)` is locally finite;\n* the balls `Metric.ball (c i) (r i)` cover the whole space.\n\nThis is a simple corollary of `refinement_of_locallyCompact_sigmaCompact_of_nhds_basis`\nand `exists_union·µ¢_ball_eq_radius_pos_lt` or `exists_locallyFinite_subset_union·µ¢_ball_radius_lt`. "},{"type":"‚àÄ {P : (a : ‚Ñ§) ‚Üí Prop} [inst : DecidablePred P] (Hbdd : ‚àÉ (b : ‚Ñ§), ‚àÄ (z : ‚Ñ§) (a : P z), z ‚â§ b) (Hinh : ‚àÉ (z : ‚Ñ§), P z),\n  ‚àÉ (ub : ‚Ñ§), (P ub : Prop) ‚àß (‚àÄ (z : ‚Ñ§) (a : P z), z ‚â§ ub : Prop)","name":"Int.exists_greatest_of_bdd","isProp":true,"docString":"If `P : ‚Ñ§ ‚Üí Prop` is a predicate such that the set `{m : P m}` is bounded above and nonempty,\nthen this set has the greatest element. This lemma uses classical logic to avoid assumption\n`[DecidablePred P]`. See `Int.greatestOfBdd` for a constructive counterpart. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasEqualizers C]\n  {X' : C} (h : X' ‚ü∂ X) [inst_2 : CategoryTheory.IsIso h] (f : X ‚ü∂ Y) [inst_3 : CategoryTheory.Limits.HasImage f],\n  CategoryTheory.Limits.imageSubobject (h ‚â´ f) = CategoryTheory.Limits.imageSubobject f","name":"CategoryTheory.Limits.imageSubobject_iso_comp","isProp":true,"docString":"Precomposing by an isomorphism does not change the image subobject. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {x : ùïú} {y : ùïú} {z : ùïú} (h : x < y),\n  (z ‚àà Set.Ioc x y : Prop) ‚Üî\n    (‚àÉ (a : ùïú),\n        ‚àÉ (b : ùïú), (0 ‚â§ a : Prop) ‚àß ((0 < b : Prop) ‚àß ((a + b = 1 : Prop) ‚àß (a * x + b * y = z : Prop) : Prop) : Prop) :\n      Prop)","name":"Convex.mem_Ioc","isProp":true,"docString":"A point is in an `Ioc` iff it can be expressed as a semistrict convex combination of the\nendpoints. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Fintype Œ±] [inst_1 : CompleteLattice Œ≤] (f : (a : Œ±) ‚Üí Œ≤),\n  Finset.inf Finset.univ f = inf·µ¢ f","name":"Finset.inf_univ_eq_inf·µ¢","isProp":true,"docString":"A special case of `Finset.inf_eq_inf·µ¢` that omits the useless `x ‚àà univ` binder. "},{"type":"‚àÄ {Œ± : Type u_1} [t : TopologicalSpace Œ±] (h : t = ‚ä§) (U : TopologicalSpace.Opens Œ±), (U = ‚ä• : Prop) ‚à® (U = ‚ä§ : Prop)","name":"TopologicalSpace.Opens.eq_bot_or_top","isProp":true,"docString":"An open set in the indiscrete topology is either empty or the whole space. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasCokernel f]\n  [inst_4 : CategoryTheory.Epi f], CategoryTheory.Limits.cokernel.œÄ f = 0","name":"CategoryTheory.Limits.cokernel.œÄ_of_epi","isProp":true,"docString":"The cokernel morphism of an epimorphism is a zero morphism "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalRing Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚à£ b), (a ‚à£ b - c : Prop) ‚Üî (a ‚à£ c : Prop)","name":"dvd_sub_right","isProp":true,"docString":"If an element `a` divides another element `b` in a ring, `a` divides the difference of `b` and\nanother element `c` iff `a` divides `c`. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] [inst_3 : PosMulMono Œ±]\n  (ha : 1 ‚â§ a) (hb : 1 ‚â§ b) (a0 : 0 ‚â§ a), 1 ‚â§ a * b","name":"Left.one_le_mul_of_le_of_le","isProp":true,"docString":"Assumes left covariance. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : TopologicalSpace E] [inst_2 : AddCommGroup E]\n  [inst_3 : Module ùïú E] [inst_4 : ContinuousAdd E] {s : Set E} (hs : StrictConvex ùïú s) (x : E), StrictConvex ùïú (x +·µ• s)","name":"StrictConvex.vadd","isProp":true,"docString":"The translation of a strictly convex set is also strictly convex. "},{"type":"‚àÄ {ùïÜ : Type u_1} {Œ± : Type u_2} [inst : Preorder ùïÜ] [inst_1 : Preorder Œ±] [self : GradeOrder ùïÜ Œ±] ‚¶Éa : Œ±‚¶Ñ ‚¶Éb : Œ±‚¶Ñ\n  (a_1 : a ‚ãñ b), GradeOrder.grade a ‚ãñ GradeOrder.grade b","name":"GradeOrder.covby_grade","isProp":true,"docString":"`grade` preserves `Covby`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {a : Œ±} {f : (a : Œ±) ‚Üí Œ≤} [inst : AddCommMonoid Œ≤] [inst_1 : DecidableEq Œ±]\n  (h : ‚àÄ (a_1 : ¬¨(a ‚àà s : Prop)), f a = 0), (Finset.sum (insert a s) fun (x : Œ±) ‚Ü¶ f x) = Finset.sum s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.sum_insert_of_eq_zero_if_not_mem","isProp":true,"docString":"The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `a` is in `s` or `f a = 0`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : SigmaCompactSpace Œ±] {f : (a : Œ±) ‚Üí Set Œ±}\n  (hf : ‚àÄ (x : Œ±), f x ‚àà nhds x),\n  ‚àÉ (s : Set Œ±),\n    (Set.Countable s : Prop) ‚àß ((Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà s) ‚Ü¶ f x) = Set.univ : Prop)","name":"countable_cover_nhds_of_sigma_compact","isProp":true,"docString":"In a topological space with sigma compact topology, if `f` is a function that sends each\npoint `x` to a neighborhood of `x`, then for some countable set `s`, the neighborhoods `f x`,\n`x ‚àà s`, cover the whole space. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {s‚ÇÅ : Set M} {s‚ÇÇ : Set M} (is‚ÇÅ : IsAddSubmonoid s‚ÇÅ) (is‚ÇÇ : IsAddSubmonoid s‚ÇÇ),\n  IsAddSubmonoid (s‚ÇÅ ‚à© s‚ÇÇ)","name":"IsAddSubmonoid.inter","isProp":true,"docString":"The intersection of two `AddSubmonoid`s of an `AddMonoid` `M` is an `AddSubmonoid` of M."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hi : Inducing f) (ho : IsOpen (Set.range f)), IsOpenMap f","name":"Inducing.isOpenMap","isProp":true,"docString":"An inducing map with an open range is an open map. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedField Œ±] (a : ‚Ñö) (x : Œ±), LinearOrderedField.qsmul a x = ‚Üëa * x","name":"LinearOrderedField.qsmul_eq_mul'","isProp":true,"docString":"However `qsmul` is defined,\npropositionally it must be equal to multiplication by `ratCast`. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {E' : Type u_3} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : f' =Œò[l] g), (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =Œò[l] g","name":"Asymptotics.IsTheta.norm_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isTheta_norm_left`."},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : (a : Œπ) ‚Üí Type u_1} [inst : Finite Œπ] [inst : DecidableEq Œπ]\n  [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ± i)] [inst_2 : (i : Œπ) ‚Üí LinearOrder (Œ± i)]\n  {p : (a : (i : Œπ) ‚Üí Finset (Œ± i)) ‚Üí Prop} (f : (i : Œπ) ‚Üí Finset (Œ± i)) (h0 : p fun (x : Œπ) ‚Ü¶ ‚àÖ)\n  (step :\n    ‚àÄ (g : (i : Œπ) ‚Üí Finset (Œ± i)) (i : Œπ) (x : Œ± i) (a : ‚àÄ (y : Œ± i) (a : y ‚àà g i), x < y) (a : p g),\n      p (Function.update g i (insert x (g i)))),\n  p f","name":"Finset.induction_on_pi_min","isProp":true,"docString":"Given a predicate on functions `‚àÄ i, Finset (Œ± i)` defined on a finite type, it is true on all\nmaps provided that it is true on `fun _ ‚Ü¶ ‚àÖ` and for any function `g : ‚àÄ i, Finset (Œ± i)`, an index\n`i : Œπ`, and an element`x : Œ± i` that is strictly less than all elements of `g i`, `p g` implies\n`p (update g i (insert x (g i)))`.\n\nThis lemma requires `LinearOrder` instances on all `Œ± i`. See also `Finset.induction_on_pi` for a\nversion that `x ‚àâ g i` instead of ` does not need `‚àÄ i, LinearOrder (Œ± i)`. "},{"type":"‚àÄ {R : Type u_2} {S : Type u_1} {M : Type u_3} {a : R} {s : S} [inst : Monoid S] [inst_1 : SMul R M] [inst_2 : SMul R S]\n  [inst_3 : MulAction S M] [inst_4 : IsScalarTower R S M] (h : a ‚Ä¢ s = 1), IsSMulRegular M s","name":"IsSMulRegular.of_smul_eq_one","isProp":true,"docString":"An element of `S` admitting a left inverse in `R` is `M`-regular. "},{"type":"‚àÄ {p : Prop} {q : Prop} (hpq : ‚àÄ (a : p), q) (hnpq : ‚àÄ (a : ¬¨(p : Prop)), q), q","name":"Classical.by_cases","isProp":true,"docString":"**Alias** of `Classical.byCases`."},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteBooleanAlgebra Œ±] (s : Set Œ±) (a : Œ±) (a_1 : ‚àÄ (b : Œ±) (a_1 : b ‚àà s), b ‚â§ a),\n  sup‚Çõ s ‚â§ a","name":"CompleteBooleanAlgebra.sup‚Çõ_le","isProp":true,"docString":"Any upper bound is more than the set supremum. "},{"type":"‚àÄ {m : Type u_1} {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : DecidableEq m]\n  [inst_3 : Fintype m] {R : Type v} [inst_4 : CommRing R] (A : Matrix m m R) (B : Matrix m n R) (D : Matrix n n R),\n  Matrix.det (Matrix.fromBlocks A B 0 D) = Matrix.det A * Matrix.det D","name":"Matrix.det_fromBlocks_zero‚ÇÇ‚ÇÅ","isProp":true,"docString":"The determinant of a 2√ó2 block matrix with the lower-left block equal to zero is the product of\nthe determinants of the diagonal blocks. For the generalization to any number of blocks, see\n`Matrix.det_of_upper_triangular`. "},{"type":"‚àÄ {R : Type u_1} [inst : Mul R] {a : R}, (IsRightRegular a : Prop) ‚Üî (IsSMulRegular R { unop := a } : Prop)","name":"isRightRegular_iff","isProp":true,"docString":"Right-regular multiplication on `R` is equivalent to `R·µê·µí·µñ`-regularity of `R` itself. "},{"type":"‚àÄ (u : PNat.XgcdType) (hr : PNat.XgcdType.r u ‚â† 0),\n  PNat.XgcdType.v (PNat.XgcdType.step u) = Prod.swap (PNat.XgcdType.v u)","name":"PNat.XgcdType.step_v","isProp":true,"docString":"The reduction step does not change the product vector. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] {X : C} {Y : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Y),\n  CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair f g)","name":"CategoryTheory.NormalEpiCategory.hasColimit_parallelPair","isProp":true,"docString":"The coequalizer of `f` and `g` exists. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedSemifield Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atTop : Prop) ‚Üî (Filter.Tendsto f l Filter.atTop : Prop)","name":"Filter.tendsto_const_mul_atTop_of_pos","isProp":true,"docString":"If `r` is a positive constant, then `Œª x, r * f x` tends to infinity along a filter if and only\nif `f` tends to infinity along the same filter. "},{"type":"‚àÄ {R : Type u_3} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} {S : Type u_1} [inst_3 : Monoid S] [inst_4 : DistribMulAction S M] [inst_5 : SMulCommClass R S M]\n  (h : SameRay R x y) (s : S), SameRay R (s ‚Ä¢ x) (s ‚Ä¢ y)","name":"SameRay.smul","isProp":true,"docString":"If two vectors are on the same ray then both scaled by the same action are also on the same\nray. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {Z : C} {X : C} {Y : C} {P : C} {inl : X ‚ü∂ P} {inr : Y ‚ü∂ P}\n  (h : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.BinaryCofan.mk inl inr))\n  (t : CategoryTheory.Limits.IsInitial Z),\n  CategoryTheory.IsPushout (CategoryTheory.Limits.IsInitial.to t X) (CategoryTheory.Limits.IsInitial.to t Y) inl inr","name":"CategoryTheory.IsPushout.of_is_coproduct'","isProp":true,"docString":"A variant of `of_is_coproduct` that is more useful with `apply`. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {E' : Type u_3} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {c : ‚Ñù}\n  {g : (a : Œ±) ‚Üí F} {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l f' g),\n  Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) g","name":"Asymptotics.IsBigOWith.norm_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigOWith_norm_left`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] [inst_6 : Nonempty Œ≥] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ≥) ‚Üí Œ±}\n  (Cf : ContinuousAt f (inf·µ¢ fun (i : Œ≥) ‚Ü¶ g i)) (Mf : Monotone f) (H : BddBelow (Set.range g)),\n  f (inf·µ¢ fun (i : Œ≥) ‚Ü¶ g i) = inf·µ¢ fun (i : Œ≥) ‚Ü¶ f (g i)","name":"Monotone.map_cinf·µ¢_of_continuousAt","isProp":true,"docString":"A continuous monotone function sends indexed infimum to indexed infimum in conditionally\ncomplete linear order, under a boundedness assumption. "},{"type":"‚àÄ {G : Type u_1} [inst : AddCommGroup G] (K : AddSubgroup G) {Œπ : Type u_2} {t : Finset Œπ} {f : (a : Œπ) ‚Üí G}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà K), (Finset.sum t fun (c : Œπ) ‚Ü¶ f c) ‚àà K","name":"AddSubgroup.sum_mem","isProp":true,"docString":"Sum of elements in an `AddSubgroup` of an `AddCommGroup` indexed by a `Finset`\nis in the `AddSubgroup`."},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Finite R M] (s : Submodule R M),\n  FiniteDimensional.finrank R (M ‚ß∏ s) ‚â§ FiniteDimensional.finrank R M","name":"Submodule.finrank_quotient_le","isProp":true,"docString":"The dimension of a quotient is bounded by the dimension of the ambient space. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : (a : Œ±) ‚Üí Type u_2} {R : (x : Œ±) ‚Üí (a : Œ≤ x) ‚Üí Prop} [inst : (a : Œ±) ‚Üí Encodable (Œ≤ a)]\n  [inst : (x : Œ±) ‚Üí (y : Œ≤ x) ‚Üí Decidable (R x y : Prop)] (H : ‚àÄ (x : Œ±), ‚àÉ (y : Œ≤ x), R x y),\n  ‚àÉ (f : (a : Œ±) ‚Üí Œ≤ a), ‚àÄ (x : Œ±), R x (f x)","name":"Encodable.axiom_of_choice","isProp":true,"docString":"A constructive version of `Classical.axiom_of_choice` for `Encodable` types. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ‚Ñï} {i : Fin (n + 2)}\n  {j : Fin (n + 2)} (H : i ‚â§ j),\n  CategoryTheory.SimplicialObject.Œ¥ X (Fin.succ j) ‚â´ CategoryTheory.SimplicialObject.Œ¥ X i =\n    CategoryTheory.SimplicialObject.Œ¥ X (‚ÜëFin.castSucc i) ‚â´ CategoryTheory.SimplicialObject.Œ¥ X j","name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥","isProp":true,"docString":"The generic case of the first simplicial identity "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {l : Filter Œπ}\n  [inst_2 : Filter.NeBot l] {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} {f : (a : X) ‚Üí Œ±} (h‚ÇÅ : Filter.Tendsto F l (nhds f))\n  (h‚ÇÇ : Equicontinuous F), Continuous f","name":"Filter.Tendsto.continuous_of_equicontinuous_at","isProp":true,"docString":"If `ùìï : Œπ ‚Üí X ‚Üí Œ±` tends to `f : X ‚Üí Œ±` *pointwise* along some nontrivial filter, and if the\nfamily `ùìï` is equicontinuous, then the limit is continuous. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (h : Reflexive r) {x : Œ±} {y : Œ±} (hr : ‚àÄ (a : x ‚â† y), r x y), r x y","name":"Reflexive.rel_of_ne_imp","isProp":true,"docString":"To show a reflexive relation `r : Œ± ‚Üí Œ± ‚Üí Prop` holds over `x y : Œ±`,\nit suffices to show it holds when `x ‚â† y`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (h : M ‚âÉ+ N), ‚Üëh 0 = 0","name":"AddEquiv.map_zero","isProp":true,"docString":"An additive isomorphism of additive monoids sends `0` to `0`\n(and is hence an additive monoid isomorphism)."},{"type":"‚àÄ {R : Type u_1} [inst : Add R] {c : R} (self : IsAddRegular c), IsAddLeftRegular c","name":"IsAddRegular.left","isProp":true,"docString":"An add-regular element `c` is left-regular "},{"type":"‚àÄ {r : NNReal} (hr : r < 1), HasSum (fun (n : ‚Ñï) ‚Ü¶ r ^ n) (1 - r)‚Åª¬π","name":"NNReal.hasSum_geometric","isProp":true,"docString":"**Sum of a Geometric Series** "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Inducing f) {s : Set Œ±}, (IsCompact (f '' s) : Prop) ‚Üî (IsCompact s : Prop)","name":"Inducing.isCompact_iff","isProp":true,"docString":"If `f : Œ± ‚Üí Œ≤` is an `Inducing` map, then the image `f '' s` of a set `s` is compact if and only\nif the set `s` is closed. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} {s : Set Œπ} (b : Basis (‚Üës) R M) (h : Module.rank R M < Cardinal.aleph0),\n  Set.Finite s","name":"Basis.finite_index_of_rank_lt_aleph0","isProp":true,"docString":"If a module has a finite dimension, all bases are indexed by a finite set. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} {M‚ÇÄ' : Type u_2} [inst : Mul M‚ÇÄ] [inst_1 : Zero M‚ÇÄ] [inst_2 : Mul M‚ÇÄ'] [inst_3 : Zero M‚ÇÄ']\n  [inst_4 : NoZeroDivisors M‚ÇÄ'] (f : (a : M‚ÇÄ) ‚Üí M‚ÇÄ') (hf : Function.Injective f) (zero : f 0 = 0)\n  (mul : ‚àÄ (x : M‚ÇÄ) (y : M‚ÇÄ), f (x * y) = f x * f y), NoZeroDivisors M‚ÇÄ","name":"Function.Injective.noZeroDivisors","isProp":true,"docString":"Pushforward a `NoZeroDivisors` instance along an injective function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {f : (a : ‚Ñï) ‚Üí Set Œ±}\n  (ho : ‚àÄ (n : ‚Ñï), IsOpen (f n)) (hd : ‚àÄ (n : ‚Ñï), Dense (f n)), Dense (Set.inter·µ¢ fun (n : ‚Ñï) ‚Ü¶ f n)","name":"dense_inter·µ¢_of_open_nat","isProp":true,"docString":"Definition of a Baire space. "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] {Œπ : Type u}, Module.rank R (Œπ ‚Üí‚ÇÄ R) = Cardinal.mk Œπ","name":"rank_finsupp_self'","isProp":true,"docString":"If `R` and `Œπ` lie in the same universe, the rank of `(Œπ ‚Üí‚ÇÄ R)` is `# Œπ`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : TopologicalSpace.FirstCountableTopology Œ±] {u : (a : ‚Ñï) ‚Üí Œ±} {x : Œ±}\n  (hx : MapClusterPt x Filter.atTop u),\n  ‚àÉ (œà : (a : ‚Ñï) ‚Üí ‚Ñï), (StrictMono œà : Prop) ‚àß (Filter.Tendsto (u ‚àò œà) Filter.atTop (nhds x) : Prop)","name":"TopologicalSpace.FirstCountableTopology.tendsto_subseq","isProp":true,"docString":"In a first-countable space, a cluster point `x` of a sequence\nis the limit of some subsequence. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List Œ±) (i : Fin (List.length L)), List.drop (‚Üëi) (List.take (‚Üëi + 1) L) = [List.get L i]","name":"List.drop_take_succ_eq_cons_get","isProp":true,"docString":"Taking only the first `i+1` elements in a list, and then dropping the first `i` ones, one is\nleft with a list of length `1` made of the `i`-th element of the original list. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {Y : C} {R : CategoryTheory.Presieve X}\n  {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : CategoryTheory.Presieve.FamilyOfElements.Compatible x)\n  {f : Y ‚ü∂ X} (hf : R f),\n  CategoryTheory.Presieve.FamilyOfElements.sieveExtend x f\n      ((CategoryTheory.Sieve.le_generate R Y\n            hf=:f ‚àà\n            CategoryTheory.Sieve.arrows\n              (CategoryTheory.Sieve.generate R))=:f ‚àà CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R)) =\n    x f hf","name":"CategoryTheory.Presieve.extend_agrees","isProp":true,"docString":"The extension of a family agrees with the original family. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : PartialOrder Œ±] {s : Set Œ±}\n  [inst_2 : TopologicalSpace.SeparableSpace ‚Üës] (hs : Dense s),\n  ‚àÉ (t : Set Œ±),\n    (t ‚äÜ s : Prop) ‚àß\n      ((Set.Countable t : Prop) ‚àß\n          ((Dense t : Prop) ‚àß\n              ((‚àÄ (x : Œ±) (a : IsBot x) (a : x ‚àà s), x ‚àà t : Prop) ‚àß\n                  (‚àÄ (x : Œ±) (a : IsTop x) (a : x ‚àà s), x ‚àà t : Prop) :\n                Prop) :\n            Prop) :\n        Prop)","name":"Dense.exists_countable_dense_subset_bot_top","isProp":true,"docString":"Let `s` be a dense set in a topological space `Œ±` with partial order structure. If `s` is a\nseparable space (e.g., if `Œ±` has a second countable topology), then there exists a countable\ndense subset `t ‚äÜ s` such that `t` contains bottom/top element of `Œ±` when they exist and belong\nto `s`. For a dense subset containing neither bot nor top elements, see\n`Dense.exists_countable_dense_subset_no_bot_top`. "},{"type":"‚àÄ {Œ± : Type u_1} {S : Set (Set Œ±)} (h : S ‚äÜ {‚àÖ, Set.univ}), ‚ãÉ‚ÇÄ S ‚àà {‚àÖ, Set.univ}","name":"Set.union‚Çõ_mem_empty_univ","isProp":true,"docString":"If all sets in a collection are either `‚àÖ` or `Set.univ`, then so is their union. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] (r : R), ‚ÜëPolynomial.C r = ‚Üë(algebraMap R (Polynomial R)) r","name":"Polynomial.C_eq_algebraMap","isProp":true,"docString":"When we have `[CommSemiring R]`, the function `C` is the same as `algebraMap R R[X]`.\n\n(But note that `C` is defined when `R` is not necessarily commutative, in which case\n`algebraMap` is not available.)\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±] {x : Œ±} {y : Œ±} (xpos : 0 < x) (hx : x ‚â§ 1)\n  (ypos : 0 < y) (hy : y < 1), ‚àÉ (n : ‚Ñï), (y ^ (n + 1) < x : Prop) ‚àß (x ‚â§ y ^ n : Prop)","name":"exists_nat_pow_near_of_lt_one","isProp":true,"docString":"Given `x` and `y` between `0` and `1`, `x` is between two successive powers of `y`.\nThis is the same as `exists_nat_pow_near`, but for elements between `0` and `1` "},{"type":"‚àÄ {Œ± : Type u_1} {ùïú : Type u_2} [inst : NormedField ùïú] {l : Filter Œ±} {u : (a : Œ±) ‚Üí ùïú} {v : (a : Œ±) ‚Üí ùïú}\n  (a : u =O[l] v),\n  ‚àÉ (œÜ : (a : Œ±) ‚Üí ùïú), ‚àÉ (_hœÜ : Filter.IsBoundedUnder (fun (x : ‚Ñù) (x_1 : ‚Ñù) ‚Ü¶ x ‚â§ x_1) l (norm ‚àò œÜ)), u =·∂†[l] œÜ * v","name":"Asymptotics.IsBigO.exists_eq_mul","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigO_iff_exists_eq_mul`."},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R}\n  (hroots : ‚ÜëMultiset.card (Polynomial.roots p) = Polynomial.natDegree p),\n  ‚ÜëPolynomial.C (Polynomial.leadingCoeff p) *\n      Multiset.prod (Multiset.map (fun (a : R) ‚Ü¶ Polynomial.X - ‚ÜëPolynomial.C a) (Polynomial.roots p)) =\n    p","name":"Polynomial.C_leadingCoeff_mul_prod_multiset_X_sub_C","isProp":true,"docString":"A polynomial `p` that has as many roots as its degree\ncan be written `p = p.leadingCoeff * ‚àè(X - a)`, for `a` in `p.roots`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {p : Prop} {q : Prop} {s : (a : p) ‚Üí (a : q) ‚Üí Œ±},\n  (inf·µ¢ fun (h‚ÇÅ : p) ‚Ü¶ inf·µ¢ fun (h‚ÇÇ : q) ‚Ü¶ s h‚ÇÅ h‚ÇÇ) =\n    inf·µ¢ fun (h : (p : Prop) ‚àß (q : Prop)) ‚Ü¶ s ((And.left h=:p)=:p) ((And.right h=:q)=:q)","name":"inf·µ¢_and'","isProp":true,"docString":"The symmetric case of `inf·µ¢_and`, useful for rewriting into a infimum over a conjunction "},{"type":"‚àÄ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), (I = ‚ä• : Prop) ‚à® (I = ‚ä§ : Prop)","name":"Ideal.eq_bot_or_top","isProp":true,"docString":"All ideals in a division (semi)ring are trivial. "},{"type":"‚àÄ (G : Type u) [inst : Group G] [us : UniformSpace G] [inst_1 : UniformGroup G]\n  [inst_2 : TopologicalSpace.FirstCountableTopology G] (N : Subgroup G) [inst_3 : Subgroup.Normal N]\n  [hG : CompleteSpace G], CompleteSpace (G ‚ß∏ N)","name":"QuotientGroup.completeSpace","isProp":true,"docString":"The quotient `G ‚ß∏ N` of a complete first countable uniform group `G` by a normal subgroup\nis itself complete. In constrast to `QuotientGroup.completeSpace'`, in this version `G` is\nalready equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G ‚ß∏ N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalGroup.to_uniformSpace`.\nIn the most common use cases, this coincides (definitionally) with the uniform structure on the\nquotient obtained via other means.  "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}\n  {y : (i : Œπ) ‚Üí Œ≤ i}, (hammingDist x y = 0 : Prop) ‚Üî (x = y : Prop)","name":"hammingDist_eq_zero","isProp":true,"docString":"Corresponds to `dist_eq_zero`. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (g : G) (n : ‚Ñ§), ‚Üëf (g ^ n) = ‚Üëf g ^ n","name":"map_zpow","isProp":true,"docString":"Group homomorphisms preserve integer power. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Type u_1} [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] {A : (a : Œπ) ‚Üí Submodule R M} (hi : CompleteLattice.Independent A) (hs : sup·µ¢ A = ‚ä§),\n  DirectSum.IsInternal A","name":"DirectSum.isInternal_submodule_of_independent_of_sup·µ¢_eq_top","isProp":true,"docString":"Note that this is not generally true for `[Semiring R]`; see\n`CompleteLattice.Independent.dfinsupp_lsum_injective` for details. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} (a : Set.Nonempty s), Set.Nonempty ‚Üë(affineSpan k s)","name":"Set.Nonempty.affineSpan","isProp":true,"docString":"**Alias** of the reverse direction of `affineSpan_nonempty`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  (h : ‚àÄ (A : C) (f : A ‚ü∂ ‚ä•_ C), CategoryTheory.IsIso f), CategoryTheory.Limits.HasStrictInitialObjects C","name":"CategoryTheory.Limits.hasStrictInitialObjects_of_initial_is_strict","isProp":true,"docString":"If `C` has an initial object such that every morphism *to* it is an isomorphism, then `C`\nhas strict initial objects. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCancelCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : SMul ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (hf : StrictConvexOn ùïú s f) (c : E), StrictConvexOn ùïú ((fun (z : E) ‚Ü¶ c + z) ‚Åª¬π' s) (f ‚àò fun (z : E) ‚Ü¶ z + c)","name":"StrictConvexOn.translate_left","isProp":true,"docString":"Left translation preserves strict convexity. "},{"type":"‚àÄ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Module.rank K (V √ó V') = Cardinal.lift (Module.rank K V) + Cardinal.lift (Module.rank K V')","name":"rank_prod","isProp":true,"docString":"If `M` and `N` are free, then the rank of `M √ó N` is\n`(module.rank R M).lift + (module.rank R N).lift`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} {s : Set Œ±} {x : Œ±},\n  EMetric.infEdist x s ‚â§ EMetric.infEdist x (Metric.cthickening Œ¥ s) + ENNReal.ofReal Œ¥","name":"Metric.infEdist_le_infEdist_cthickening_add","isProp":true,"docString":"For the equality, see `infEdist_cthickening`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] (t : Finset Œπ) (f : (a : Œπ) ‚Üí Set Œ±) (g : (a : Œπ) ‚Üí Œ±)\n  (hg : ‚àÄ (i : Œπ) (a : i ‚àà t), g i ‚àà f i), (Finset.sum t fun (i : Œπ) ‚Ü¶ g i) ‚àà Finset.sum t fun (i : Œπ) ‚Ü¶ f i","name":"Set.finset_sum_mem_finset_sum","isProp":true,"docString":"An n-ary version of `Set.add_mem_add`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v : V)\n  (nz : v ‚â† 0), (FiniteDimensional.finrank K V = 1 : Prop) ‚Üî (‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w : Prop)","name":"finrank_eq_one_iff_of_nonzero'","isProp":true,"docString":"A module with a nonzero vector `v` has dimension 1 iff every vector is a multiple of `v`.\n"},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : VAdd G P] [self : FaithfulVAdd G P] {g‚ÇÅ : G} {g‚ÇÇ : G}\n  (a : ‚àÄ (p : P), g‚ÇÅ +·µ• p = g‚ÇÇ +·µ• p), g‚ÇÅ = g‚ÇÇ","name":"FaithfulVAdd.eq_of_vadd_eq_vadd","isProp":true,"docString":"Two elements `g‚ÇÅ` and `g‚ÇÇ` are equal whenever they act in the same way on all points. "},{"type":"‚àÄ {Œ± : Type u} {G : Type u_1} [inst : Group G] (f : FreeGroup Œ± ‚Üí* G) (g : FreeGroup Œ± ‚Üí* G)\n  (h : ‚àÄ (a : Œ±), ‚Üëf (FreeGroup.of a) = ‚Üëg (FreeGroup.of a)), f = g","name":"FreeGroup.ext_hom","isProp":true,"docString":"Two homomorphisms out of a free group are equal if they are equal on generators.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {s : Finset Œ±} {t : Finset Œ≤} (hc : Finset.card t < Finset.card s) {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚àà t),\n  ‚àÉ (x : Œ±), (x ‚àà s : Prop) ‚àß (‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß ((x ‚â† y : Prop) ‚àß (f x = f y : Prop) : Prop) : Prop)","name":"Finset.exists_ne_map_eq_of_card_lt_of_maps_to","isProp":true,"docString":"If there are more pigeons than pigeonholes, then there are two pigeons in the same pigeonhole.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.IsCofiltered C], Nonempty C","name":"CategoryTheory.IsCofiltered.Nonempty","isProp":true,"docString":"a cofiltered category must be non empty "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasFiniteProducts C","name":"CategoryTheory.hasFiniteProducts_of_has_binary_and_terminal","isProp":true,"docString":"If `C` has a terminal object and binary products, then it has finite products. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsInitial X) (f : X ‚ü∂ Y)\n  (g : X ‚ü∂ Y), f = g","name":"CategoryTheory.Limits.IsInitial.hom_ext","isProp":true,"docString":"Any two morphisms from an initial object are equal. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (a : Œ±),\n  derangements.Equiv.RemoveNone.fiber (some a) = setOf fun (f : Equiv.Perm Œ±) ‚Ü¶ Function.fixedPoints ‚Üëf ‚äÜ {a}","name":"derangements.Equiv.RemoveNone.fiber_some","isProp":true,"docString":"For any `a : Œ±`, the fiber over `some a` is the set of permutations\nwhere `a` is the only possible fixed point. "},{"type":"‚àÄ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {f : (a : ‚Ñï) ‚Üí R} {g : (a : ‚Ñï) ‚Üí R}\n  (hf : Summable fun (x : ‚Ñï) ‚Ü¶ ‚Äñf x‚Äñ) (hg : Summable fun (x : ‚Ñï) ‚Ü¶ ‚Äñg x‚Äñ),\n  ((tsum fun (n : ‚Ñï) ‚Ü¶ f n) * tsum fun (n : ‚Ñï) ‚Ü¶ g n) =\n    tsum fun (n : ‚Ñï) ‚Ü¶ Finset.sum (Finset.Nat.antidiagonal n) fun (kl : ‚Ñï √ó ‚Ñï) ‚Ü¶ f (Prod.fst kl) * g (Prod.snd kl)","name":"tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm","isProp":true,"docString":"The Cauchy product formula for the product of two infinite sums indexed by `‚Ñï`,\nexpressed by summing on `Finset.Nat.antidiagonal`.\nSee also `tsum_mul_tsum_eq_tsum_sum_antidiagonal` if `f` and `g` are\n*not* absolutely summable. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] {a : Œ±} {s : Set Œ≤} (a : Set.Finite (a ‚Ä¢ s)),\n  Set.Finite s","name":"Set.Finite.of_smul_set","isProp":true,"docString":"**Alias** of the forward direction of `Set.finite_smul_set`."},{"type":"‚àÄ (n : ‚Ñï), List.toFinset (Nat.factors n) = Finset.filter Nat.Prime (Nat.divisors n)","name":"Nat.prime_divisors_eq_to_filter_divisors_prime","isProp":true,"docString":"The factors of `n` are the prime divisors "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] {s : Set Œ±} (h : TotallyBounded s), TotallyBounded (closure s)","name":"TotallyBounded.closure","isProp":true,"docString":"The closure of a totally bounded set is totally bounded. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonAssocRing Œ±] (n : ‚Ñï), IntCast.intCast (Int.negSucc n) = -‚Üë(n + 1)","name":"NonAssocRing.intCast_negSucc","isProp":true,"docString":"The canonical homorphism `‚Ñ§ ‚Üí R` for negative values is just the negation of the values\nof the canonical homomorphism `‚Ñï ‚Üí R`. "},{"type":"‚àÄ {Œ± : Type u} (s : Set Œ±), (Subsingleton ‚Üës : Prop) ‚Üî (Set.Subsingleton s : Prop)","name":"Set.subsingleton_coe","isProp":true,"docString":"`s`, coerced to a type, is a subsingleton type if and only if `s` is a subsingleton set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} [inst : CompleteLattice Œ±] [inst_1 : Fintype Œπ] {f : (a : Œπ) ‚Üí Œ±}\n  (a : Finset.SupIndep Finset.univ f), CompleteLattice.Independent f","name":"Finset.SupIndep.independent_of_univ","isProp":true,"docString":"**Alias** of the reverse direction of `CompleteLattice.independent_iff_supIndep_univ`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasColimits C],\n  CategoryTheory.Limits.HasLimits C·µí·µñ","name":"CategoryTheory.Limits.hasLimits_op_of_hasColimits","isProp":true,"docString":"If `C` has colimits, we can construct limits for `C·µí·µñ`.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (a : Isometry f) (x : Œ±) (y : Œ±), dist (f x) (f y) = dist x y","name":"Isometry.dist_eq","isProp":true,"docString":"An isometry preserves distances. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (r : (a : M) ‚Üí (a : M) ‚Üí Prop), conGen ‚Üë(conGen r) = conGen r","name":"Con.conGen_idem","isProp":true,"docString":"The map sending a binary relation to the smallest congruence relation in which it is\ncontained is idempotent. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  (h :\n    ‚àÄ (J : Type w) {ùí• : CategoryTheory.SmallCategory J} (x : CategoryTheory.FinCategory J),\n      CategoryTheory.Limits.HasLimitsOfShape J C),\n  CategoryTheory.Limits.HasFiniteLimits C","name":"CategoryTheory.Limits.hasFiniteLimits_of_hasFiniteLimits_of_size","isProp":true,"docString":"We can always derive `HasFiniteLimits C` by providing limits at an\narbitrary universe. "},{"type":"‚àÄ {F : Type u_2} {E : Type u_1} [inst : Field F] [inst_1 : Ring E] [inst_2 : Algebra F E] [inst_3 : Nontrivial E]\n  (a : Module.rank F E = 1), ‚ä• = ‚ä§","name":"Subalgebra.bot_eq_top_of_rank_eq_one","isProp":true,"docString":"**Alias** of the reverse direction of `Subalgebra.bot_eq_top_iff_rank_eq_one`."},{"type":"‚àÄ {X : (a : ‚Ñï) ‚Üí Type u} [inst : (n : ‚Ñï) ‚Üí MetricSpace (X n)] {f : (n : ‚Ñï) ‚Üí (a : X n) ‚Üí X (n + 1)}\n  (I : ‚àÄ (n : ‚Ñï), Isometry (f n)) (n : ‚Ñï), Isometry (Metric.toInductiveLimit I n)","name":"Metric.toInductiveLimit_isometry","isProp":true,"docString":"The map `toInductiveLimit n` mapping `X n` to the inductive limit is an isometry. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i) = Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (AntivaryOn (f ‚àò ‚ÜëœÉ) g ‚Üës : Prop)","name":"AntivaryOn.sum_mul_eq_sum_comp_perm_mul_iff","isProp":true,"docString":"**Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together, is unchanged by a permutation if and only if `f ‚àò œÉ` and `g` antivary\ntogether. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C)\n  [inst_3 : CategoryTheory.Limits.HasBinaryBiproduct X Y],\n  CategoryTheory.IsPullback CategoryTheory.Limits.biprod.inl 0 CategoryTheory.Limits.biprod.snd 0","name":"CategoryTheory.IsPullback.inl_snd","isProp":true,"docString":"The square\n```\n  X --inl--> X ‚äû Y\n  |            |\n  0           snd\n  |            |\n  v            v\n  0 ---0-----> Y\n```\nis a pullback square.\n"},{"type":"‚àÄ {Œ¥ : Type u_1} {Œ∫ : (a : Œ¥) ‚Üí Type u_2} [inst : (d : Œ¥) ‚Üí TopologicalSpace (Œ∫ d)],\n  (Filter.coprod·µ¢ fun (d : Œ¥) ‚Ü¶ Filter.cocompact (Œ∫ d)) = Filter.cocompact ((d : Œ¥) ‚Üí Œ∫ d)","name":"Filter.coprod·µ¢_cocompact","isProp":true,"docString":"**Tychonoff's theorem** formulated in terms of filters: `Filter.cocompact` on an indexed product\ntype `Œ† d, Œ∫ d` the `Filter.coprod·µ¢` of filters `Filter.cocompact` on `Œ∫ d`. "},{"type":"‚àÄ {R : Type u_3} {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_1} [inst_1 : AddCommMonoid M] (w : (a : œÉ) ‚Üí M)\n  (d : œÉ ‚Üí‚ÇÄ ‚Ñï) (r : R) {m : M} (hm : ‚Üë(MvPolynomial.weightedDegree' w) d = m),\n  MvPolynomial.IsWeightedHomogeneous w (‚Üë(MvPolynomial.monomial d) r) m","name":"MvPolynomial.isWeightedHomogeneous_monomial","isProp":true,"docString":"Monomials are weighted homogeneous. "},{"type":"‚àÄ {Œ± : Type u_1} [self : Order.Coframe Œ±] (a : Œ±) (s : Set Œ±),\n  (inf·µ¢ fun (b : Œ±) ‚Ü¶ inf·µ¢ fun (h : b ‚àà s) ‚Ü¶ a ‚äî b) ‚â§ a ‚äî inf‚Çõ s","name":"Order.Coframe.inf·µ¢_sup_le_sup_inf‚Çõ","isProp":true,"docString":"In a coframe, `‚äî` distributes over `‚®Ö`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {R' : Type u_2} [inst_1 : Monoid R'] {M : Type u_3} {N : Type u_4}\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : DistribMulAction R' M] [inst_7 : SMulCommClass R R' M] {R'‚ÇÇ : Type u_5} [inst_8 : Monoid R'‚ÇÇ]\n  [inst_9 : DistribMulAction R'‚ÇÇ M] [inst_10 : SMulCommClass R R'‚ÇÇ M] [inst_11 : SMul R'‚ÇÇ R']\n  [inst_12 : IsScalarTower R'‚ÇÇ R' M], IsScalarTower R'‚ÇÇ R' (TensorProduct R M N)","name":"TensorProduct.isScalarTower_left","isProp":true,"docString":"`IsScalarTower R'‚ÇÇ R' M` implies `IsScalarTower R'‚ÇÇ R' (M ‚äó[R] N)` "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (H : Subgroup G) {f : G ‚Üí* N}\n  (hf : Function.Bijective ‚Üëf), Subgroup.map f (Subgroup.normalizer H) = Subgroup.normalizer (Subgroup.map f H)","name":"Subgroup.map_normalizer_eq_of_bijective","isProp":true,"docString":"The image of the normalizer is equal to the normalizer of the image of a bijective\nfunction. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ±) ‚Üí M}\n  (hf : Set.Finite (Function.support f)) (hg : Set.Finite (Function.support g)),\n  (finsum fun (i : Œ±) ‚Ü¶ f i + g i) = (finsum fun (i : Œ±) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ g i","name":"finsum_add_distrib","isProp":true,"docString":"If the additive supports of `f` and `g` are finite, then the sum of `f i + g i`\nequals the sum of `f i` plus the sum of `g i`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_1}, Monotone (@UniformFun.uniformSpace Œ± Œ≥)","name":"UniformFun.mono","isProp":true,"docString":"If `u‚ÇÅ` and `u‚ÇÇ` are two uniform structures on `Œ≥` and `u‚ÇÅ ‚â§ u‚ÇÇ`, then\n`ùí∞(Œ±, Œ≥, u‚ÇÅ) ‚â§ ùí∞(Œ±, Œ≥, u‚ÇÇ)`. "},{"type":"‚àÄ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R] {a : R} {b : R} {c : R}\n  (ha : a ‚â† 0) (a_1 : ‚àÄ {d : R} (a : d ‚à£ a) (a : d ‚à£ c), ¬¨(Prime d : Prop)) (a_2 : a ‚à£ b * c), a ‚à£ b","name":"UniqueFactorizationMonoid.dvd_of_dvd_mul_left_of_no_prime_factors","isProp":true,"docString":"Euclid's lemma: if `a ‚à£ b * c` and `a` and `c` have no common prime factors, `a ‚à£ b`.\nCompare `IsCoprime.dvd_of_dvd_mul_left`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_1} ‚¶Éu‚ÇÅ : UniformSpace Œ≥‚¶Ñ ‚¶Éu‚ÇÇ : UniformSpace Œ≥‚¶Ñ (hu : u‚ÇÅ ‚â§ u‚ÇÇ) ‚¶Éùîñ‚ÇÅ : Set (Set Œ±)‚¶Ñ\n  ‚¶Éùîñ‚ÇÇ : Set (Set Œ±)‚¶Ñ (hùîñ : ùîñ‚ÇÇ ‚äÜ ùîñ‚ÇÅ), UniformOnFun.uniformSpace Œ± Œ≥ ùîñ‚ÇÅ ‚â§ UniformOnFun.uniformSpace Œ± Œ≥ ùîñ‚ÇÇ","name":"UniformOnFun.mono","isProp":true,"docString":"Let `u‚ÇÅ`, `u‚ÇÇ` be two uniform structures on `Œ≥` and `ùîñ‚ÇÅ ùîñ‚ÇÇ : Set (Set Œ±)`. If `u‚ÇÅ ‚â§ u‚ÇÇ` and\n`ùîñ‚ÇÇ ‚äÜ ùîñ‚ÇÅ` then `ùí±(Œ±, Œ≥, ùîñ‚ÇÅ, u‚ÇÅ) ‚â§ ùí±(Œ±, Œ≥, ùîñ‚ÇÇ, u‚ÇÇ)`. "},{"type":"‚àÄ {ùïú : Type u_2} {Œ± : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : DecidableEq Œ±] {k : ‚Ñï} {ùíú : Finset (Finset Œ±)}\n  [inst_2 : Fintype Œ±] (hk : k ‚â§ Fintype.card Œ±) (hùíú : IsAntichain (fun (x : Finset Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚äÜ x_1) ‚Üëùíú),\n  (Finset.sum (Finset.range (k + 1)) fun (r : ‚Ñï) ‚Ü¶\n      ‚Üë(Finset.card (Finset.slice ùíú (Fintype.card Œ± - r))) / ‚Üë(Nat.choose (Fintype.card Œ±) (Fintype.card Œ± - r))) ‚â§\n    ‚Üë(Finset.card (Finset.falling (Fintype.card Œ± - k) ùíú)) / ‚Üë(Nat.choose (Fintype.card Œ±) (Fintype.card Œ± - k))","name":"Finset.le_card_falling_div_choose","isProp":true,"docString":"A bound on any top part of the sum in LYM in terms of the size of `falling k ùíú`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_4} [inst : CommSemiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] (b : Basis Œπ R M) (b' : Basis Œπ' R M) [inst_3 : DecidableEq Œπ] [inst_4 : Fintype Œπ'],\n  Matrix.mul (Basis.toMatrix b ‚Üëb') (Basis.toMatrix b' ‚Üëb) = 1","name":"Basis.toMatrix_mul_toMatrix_flip","isProp":true,"docString":"`b.toMatrix b'` and `b'.toMatrix b` are inverses. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Nonempty s), ‚àÖ ‚äÇ s","name":"Set.Nonempty.empty_ssubset","isProp":true,"docString":"**Alias** of the reverse direction of `Set.empty_ssubset`."},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {i : D ‚•§ C}\n  [inst_2 : CategoryTheory.Reflective i] {A : C}\n  [inst_3 :\n    CategoryTheory.IsSplitMono ((CategoryTheory.Adjunction.unit (CategoryTheory.Adjunction.ofRightAdjoint i)).app A)],\n  A ‚àà CategoryTheory.Functor.essImage i","name":"CategoryTheory.mem_essImage_of_unit_isSplitMono","isProp":true,"docString":"If `Œ∑_A` is a split monomorphism, then `A` is in the reflective subcategory. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {e' : LocalHomeomorph Œ± Œ≤} (h : e ‚âà e'),\n  LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) = LocalEquiv.target (LocalHomeomorph.toLocalEquiv e')","name":"LocalHomeomorph.EqOnSource.target_eq","isProp":true,"docString":"Two equivalent local homeomorphisms have the same target "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasKernel f]\n  [inst_4 : CategoryTheory.Mono f], CategoryTheory.Limits.kernel.Œπ f = 0","name":"CategoryTheory.Limits.kernel.Œπ_of_mono","isProp":true,"docString":"The kernel morphism of a monomorphism is a zero morphism "},{"type":"‚àÄ (n : ‚Ñï), Nat.factors (n + 2) = Nat.minFac (n + 2) :: Nat.factors ((n + 2) / Nat.minFac (n + 2))","name":"Nat.factors_add_two","isProp":true,"docString":"`factors` can be constructed inductively by extracting `minFac`, for sufficiently large `n`. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Monoid R]\n  [inst_1 : NonUnitalNonAssocSemiring A] [inst_2 : NonUnitalNonAssocSemiring B] [inst_3 : DistribMulAction R A]\n  [inst_4 : DistribMulAction R B] [self : NonUnitalAlgHomClass F R A B] (f : F) (x : A) (y : A),\n  ‚Üëf (x * y) = ‚Üëf x * ‚Üëf y","name":"NonUnitalAlgHomClass.map_mul","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {n : ‚Ñï}, Fin.succAbove (Fin.last n) = Fin.castSucc","name":"Fin.succAbove_last","isProp":true,"docString":"Embedding `Fin n` into `Fin (n + 1)` with a hole around `last n` embeds by `castSucc`. "},{"type":"‚àÄ {n : ‚Ñï} (p : Fin (n + 1)) (i : Fin n), ‚Üë(Fin.succAbove p) i ‚â† p","name":"Fin.succAbove_ne","isProp":true,"docString":"Embedding `i : Fin n` into `Fin (n + 1)` with a hole around `p : Fin (n + 1)`\nnever results in `p` itself "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommRing Œ±] (E : LinearRecurrence Œ±) (q : Œ±),\n  (LinearRecurrence.IsSolution E fun (n : ‚Ñï) ‚Ü¶ q ^ n : Prop) ‚Üî\n    (Polynomial.IsRoot (LinearRecurrence.charPoly E) q : Prop)","name":"LinearRecurrence.geom_sol_iff_root_charPoly","isProp":true,"docString":"The geometric sequence `q^n` is a solution of `E` iff\n`q` is a root of `E`'s characteristic polynomial. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} {s : Set Œ±} {x : Œ±},\n  EMetric.infEdist x s ‚â§ EMetric.infEdist x (Metric.thickening Œ¥ s) + ENNReal.ofReal Œ¥","name":"Metric.infEdist_le_infEdist_thickening_add","isProp":true,"docString":"For the equality, see `infEdist_thickening`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} [inst : UniformSpace Œ≤] {f : (a : Œ≥) ‚Üí Œ≤},\n  UniformFun.uniformSpace Œ± Œ≥ = UniformSpace.comap (fun (x : (a : Œ±) ‚Üí Œ≥) ‚Ü¶ f ‚àò x) (UniformFun.uniformSpace Œ± Œ≤)","name":"UniformFun.comap_eq","isProp":true,"docString":"If `u` is a uniform structures on `Œ≤` and `f : Œ≥ ‚Üí Œ≤`, then\n`ùí∞(Œ±, Œ≥, comap f u) = comap (Œª g, f ‚àò g) ùí∞(Œ±, Œ≥, u‚ÇÅ)`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), (S = ‚ä• : Prop) ‚à® (Nontrivial { x : M // x ‚àà S } : Prop)","name":"AddSubmonoid.bot_or_nontrivial","isProp":true,"docString":"An additive submonoid is either the trivial additive submonoid or nontrivial."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] {A : Finset Œ±} (hA : Finset.Nonempty A) (B : Finset Œ±)\n  (n : ‚Ñï), ‚Üë(Finset.card (B ^ n)) ‚â§ (‚Üë(Finset.card (A / B)) / ‚Üë(Finset.card A)) ^ n * ‚Üë(Finset.card A)","name":"Finset.card_pow_le'","isProp":true,"docString":"Special case of the **Pl√ºnnecke-Ruzsa inequality**. Division version. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {d : Con M} {x : M} {y : M},\n  (‚Üë(c ‚äì d) x y : Prop) ‚Üî ((‚Üëc x y : Prop) ‚àß (‚Üëd x y : Prop) : Prop)","name":"Con.inf_iff_and","isProp":true,"docString":"Definition of the infimum of two congruence relations. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_4} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1), ‚Üë(Finset.affineCombination k s fun (x : Œπ) ‚Ü¶ p) w = p","name":"Finset.affineCombination_apply_const","isProp":true,"docString":"The value of `affineCombination`, where the given points are equal. "},{"type":"AbsoluteValue.IsEuclidean AbsoluteValue.abs","name":"AbsoluteValue.abs_isEuclidean","isProp":true,"docString":"`abs : ‚Ñ§ ‚Üí ‚Ñ§` is a Euclidean absolute value "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±], Finset.shadow ‚àÖ = ‚àÖ","name":"Finset.shadow_empty","isProp":true,"docString":"The shadow of the empty set is empty. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {s‚ÇÅ : Setoid Œ±} {s‚ÇÇ : Setoid Œ≤} {p : (a : Quotient s‚ÇÅ) ‚Üí (a : Quotient s‚ÇÇ) ‚Üí Prop}\n  (h : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ≤), p (Quotient.mk'' a‚ÇÅ) (Quotient.mk'' a‚ÇÇ)) (q‚ÇÅ : Quotient s‚ÇÅ) (q‚ÇÇ : Quotient s‚ÇÇ), p q‚ÇÅ q‚ÇÇ","name":"Quotient.ind‚ÇÇ'","isProp":true,"docString":"A version of `Quotient.ind‚ÇÇ` taking `{s‚ÇÅ : Setoid Œ±} {s‚ÇÇ : Setoid Œ≤}` as implicit arguments\ninstead of instance arguments. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} (a : Set.Nonempty (s ‚à© t)), ¬¨(Disjoint s t : Prop)","name":"Set.Nonempty.not_disjoint","isProp":true,"docString":"**Alias** of the reverse direction of `Set.not_disjoint_iff_nonempty_inter`."},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] (a : M) (u : AddUnits M), (IsAddUnit (a + ‚Üëu) : Prop) ‚Üî (IsAddUnit a : Prop)","name":"AddUnits.isAddUnit_add_addUnits","isProp":true,"docString":"Addition of a `u : AddUnits M` on the right doesn't affect `IsAddUnit`."},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±}, (a - b < 0 : Prop) ‚Üî (a < b : Prop)","name":"sub_lt_zero","isProp":true,"docString":"**Alias** of `sub_neg`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (L : List G),\n  List.prod (List.reverse L) = (List.prod (List.map (fun (x : G) ‚Ü¶ x‚Åª¬π) L))‚Åª¬π","name":"List.prod_reverse_noncomm","isProp":true,"docString":"A non-commutative variant of `List.prod_reverse` "},{"type":"‚àÄ (m : ‚Ñ§) {n : ‚Ñ§} (hn : 0 < n),\n  (‚àÉ (k : ‚Ñ§), (n * k < m : Prop) ‚àß (m < n * (k + 1) : Prop) : Prop) ‚Üî (¬¨(n ‚à£ m : Prop) : Prop)","name":"Int.exists_lt_and_lt_iff_not_dvd","isProp":true,"docString":"If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`\nfor some `k`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictAnti f) (hg : Antitone g), StrictAnti fun (x : Œ≤) ‚Ü¶ f x + g x","name":"StrictAnti.add_antitone","isProp":true,"docString":"The sum of a strictly antitone function and a antitone function is\nstrictly antitone."},{"type":"‚àÄ {n : ‚Ñï} [inst : NeZero n] (p : Fin (n + 1)) (i : Fin n) (h : 0 < i), 0 < ‚Üë(Fin.succAbove p) i","name":"Fin.succAbove_pos","isProp":true,"docString":"Embedding a positive `Fin n` results in a positive `Fin (n + 1)` "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D]\n  (F : CategoryTheory.MonoidalFunctor C D)\n  [inst_4 :\n    CategoryTheory.IsEquivalence\n      (CategoryTheory.LaxMonoidalFunctor.toFunctor (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F))]\n  [inst_5 : CategoryTheory.MonoidalClosed D] {X : C} {Y : C} {Z : C}\n  (f : Y ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.ihom X)) Z),\n  CategoryTheory.MonoidalClosed.uncurry f =\n    (CategoryTheory.Iso.inv (CategoryTheory.compInvIso (CategoryTheory.MonoidalFunctor.commTensorLeft F X))).app Y ‚â´\n      ‚Üë(Equiv.symm\n            (CategoryTheory.Adjunction.homEquiv\n              (CategoryTheory.Functor.adjunction\n                (CategoryTheory.Functor.inv\n                  (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                    (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F))))\n              (Prefunctor.obj\n                  (CategoryTheory.Functor.toPrefunctor\n                    (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                      (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))\n                  X ‚äó\n                Prefunctor.obj\n                  (CategoryTheory.Functor.toPrefunctor\n                    (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                      (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))\n                  Y)\n              Z))\n        (CategoryTheory.MonoidalClosed.uncurry\n          (‚Üë(Equiv.symm\n                (CategoryTheory.Adjunction.homEquiv\n                  (CategoryTheory.Functor.adjunction\n                    (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                      (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))\n                  Y\n                  (Prefunctor.obj\n                    (CategoryTheory.Functor.toPrefunctor\n                      (CategoryTheory.ihom\n                        (Prefunctor.obj\n                          (CategoryTheory.Functor.toPrefunctor\n                            (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                              (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))\n                          X)))\n                    (Prefunctor.obj\n                      (CategoryTheory.Functor.toPrefunctor\n                        (CategoryTheory.LaxMonoidalFunctor.toFunctor\n                          (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F)))\n                      Z))))\n            f))","name":"CategoryTheory.MonoidalClosed.ofEquiv_uncurry_def","isProp":true,"docString":"Suppose we have a monoidal equivalence `F : C ‚âå D`, with `D` monoidal closed. We can pull the\nmonoidal closed instance back along the equivalence. For `X, Y, Z : C`, this lemma describes the\nresulting uncurrying map `Hom(Y, (X ‚ü∂[C] Z)) ‚Üí Hom(X ‚äó Y ‚ü∂ Z)`. (`X ‚ü∂[C] Z` is\ndefined to be `F‚Åª¬π(F(X) ‚ü∂[D] F(Z))`, so uncurrying in `C` is given by essentially conjugating\nuncurrying in `D` by `F.`) "},{"type":"‚àÄ {G : Type u} [inst : Group G] {x : G}, (IsOfFinOrder x‚Åª¬π : Prop) ‚Üî (IsOfFinOrder x : Prop)","name":"isOfFinOrder_inv_iff","isProp":true,"docString":"Inverses of elements of finite order have finite order. "},{"type":"‚àÄ {Œ± : Type u_1} [self : Quandle Œ±] {x : Œ±}, Shelf.act x x = x","name":"Quandle.fix","isProp":true,"docString":"The fixing property of a Quandle "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±]\n  (H : FreeGroup.Red (FreeGroup.reduce L‚ÇÅ) L‚ÇÇ), FreeGroup.reduce L‚ÇÅ = L‚ÇÇ","name":"FreeGroup.reduce.min","isProp":true,"docString":"The second theorem that characterises the function `reduce`: the maximal reduction of a word\nonly reduces to itself. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {‚Ñ¨ : Finset (Finset Œ±)} {s : Finset Œ±}\n  (hùíú : IsLowerSet ‚Üëùíú) (h‚Ñ¨ : IsLowerSet ‚Üë‚Ñ¨) (hùíús : ‚àÄ (t : Finset Œ±) (a : t ‚àà ùíú), t ‚äÜ s)\n  (h‚Ñ¨s : ‚àÄ (t : Finset Œ±) (a : t ‚àà ‚Ñ¨), t ‚äÜ s), Finset.card ùíú * Finset.card ‚Ñ¨ ‚â§ 2 ^ Finset.card s * Finset.card (ùíú ‚à© ‚Ñ¨)","name":"IsLowerSet.le_card_inter_finset'","isProp":true,"docString":"**Harris-Kleitman inequality**: Any two lower sets of finsets correlate. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (h : 0 < (1 - r) * (b - a)),\n  (f (‚Üë(AffineMap.lineMap a b) r) ‚â§ ‚Üë(AffineMap.lineMap (f a) (f b)) r : Prop) ‚Üî\n    (slope f a b ‚â§ slope f (‚Üë(AffineMap.lineMap a b) r) b : Prop)","name":"map_le_lineMap_iff_slope_le_slope_right","isProp":true,"docString":"Given `c = lineMap a b r`, `c < b`, the point `(c, f c)` is non-strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a b ‚â§ slope f c b`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {k : Set G}, k ‚äÜ ‚Üë(Subgroup.closure k)","name":"Subgroup.subset_closure","isProp":true,"docString":"The subgroup generated by a set includes the set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} {s : Set Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] [inst_4 : ContinuousAdd Œ≥] {f : (a : Œ±) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ≥} (hf : LowerSemicontinuousWithinAt f s x) (hg : LowerSemicontinuousWithinAt g s x),\n  LowerSemicontinuousWithinAt (fun (z : Œ±) ‚Ü¶ f z + g z) s x","name":"LowerSemicontinuousWithinAt.add","isProp":true,"docString":"The sum of two lower semicontinuous functions is lower semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C] {P : C} {Q : C}\n  (f : P ‚ü∂ Q), CategoryTheory.Abelian.coimage.œÄ f ‚â´ CategoryTheory.Abelian.factorThruCoimage f = f","name":"CategoryTheory.Abelian.coimage.fac","isProp":true,"docString":"`f` factors through its coimage via the canonical morphism `p`. "},{"type":"‚àÄ (P : (a : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí Prop) (ha : ‚àÄ (a : ‚Ñï), P (a + 1) (a + 1)) (hb : ‚àÄ (b : ‚Ñï), P 0 (b + 1))\n  (hd : ‚àÄ (a : ‚Ñï) (b : ‚Ñï) (a_1 : a < b) (a_2 : P (a + 1) b) (a_3 : P a (b + 1)), P (a + 1) (b + 1)) (a : ‚Ñï) (b : ‚Ñï)\n  (a_1 : a < b), P a b","name":"Nat.diag_induction","isProp":true,"docString":"Given a predicate on two naturals `P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop`, `P a b` is true for all `a < b` if\n`P (a + 1) (a + 1)` is true for all `a`, `P 0 (b + 1)` is true for all `b` and for all\n`a < b`, `P (a + 1) b` is true and `P a (b + 1)` is true implies `P (a + 1) (b + 1)` is true. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {c : AddCon M} {f : M ‚Üí+ P}\n  (H : c ‚â§ AddCon.ker f), AddMonoidHom.comp (AddCon.lift c f H) (AddCon.mk' c) = f","name":"AddCon.lift_comp_mk'","isProp":true,"docString":"The diagram describing the universal property for quotients of\n`AddMonoid`s commutes."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] (c : ClosureOperator Œ±),\n  GaloisConnection.closureOperator\n      ((GaloisInsertion.gc\n            (ClosureOperator.gi\n              c)=:GaloisConnection (ClosureOperator.toClosed c)\n            Subtype.val)=:GaloisConnection (ClosureOperator.toClosed c) Subtype.val) =\n    c","name":"closureOperator_gi_self","isProp":true,"docString":"The Galois insertion associated to a closure operator can be used to reconstruct the closure\noperator.\nNote that the inverse in the opposite direction does not hold in general. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {Y : C} [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  (f : ‚ä§_ C ‚ü∂ Y), CategoryTheory.IsSplitMono f","name":"CategoryTheory.Limits.terminal.isSplitMono_from","isProp":true,"docString":"Any morphism from a terminal object is split mono. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] (n : Type) [inst_1 : Fintype n] [inst_2 : DecidableEq n] (M : Matrix n n ùïú),\n  ‚àÉ (L : List (Matrix.TransvectionStruct n ùïú)),\n    ‚àÉ (L' : List (Matrix.TransvectionStruct n ùïú)),\n      ‚àÉ (D : (a : n) ‚Üí ùïú),\n        Matrix.mul (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L)) M)\n            (List.prod (List.map Matrix.TransvectionStruct.toMatrix L')) =\n          Matrix.diagonal D","name":"Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_aux","isProp":true,"docString":"Any matrix can be reduced to diagonal form by elementary operations. Formulated here on `Type 0`\nbecause we will make an induction using `Fin r`.\nSee `exists_list_transvec_mul_mul_list_transvec_eq_diagonal` for the general version (which follows\nfrom this one and reindexing). "},{"type":"Cardinal.ord ‚àò Cardinal.aleph =\n  Ordinal.enumOrd (setOf fun (b : Ordinal) ‚Ü¶ (Cardinal.ord (Ordinal.card b) = b : Prop) ‚àß (Ordinal.omega ‚â§ b : Prop))","name":"Cardinal.ord_aleph_eq_enum_card","isProp":true,"docString":"`ord ‚àò aleph` enumerates the infinite ordinals that are cardinals. "},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ], Filter.HasBasis (nhds 0) (fun (Œ≥ : Œì‚ÇÄ) ‚Ü¶ Œ≥ ‚â† 0) Set.Iio","name":"WithZeroTopology.hasBasis_nhds_zero","isProp":true,"docString":"In a linearly ordered group with zero element adjoined, `U` is a neighbourhood of `0` if and\nonly if there exists a nonzero element `Œ≥‚ÇÄ` such that `Iio Œ≥‚ÇÄ ‚äÜ U`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : C ‚•§ D} (Œ± : F ‚ü∂ G) [inst_2 : ‚àÄ (X : C), CategoryTheory.IsIso (Œ±.app X)], CategoryTheory.IsIso Œ±","name":"CategoryTheory.NatIso.isIso_of_isIso_app","isProp":true,"docString":"A natural transformation is an isomorphism if all its components are isomorphisms.\n"},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] (c : AddCon M) (f : M ‚Üí+ P)\n  (H : c ‚â§ AddCon.ker f) (h : Function.Injective ‚Üë(AddCon.lift c f H)), AddCon.ker f = c","name":"AddCon.ker_eq_lift_of_injective","isProp":true,"docString":"Given an `AddMonoid` homomorphism `f` from `M` to `P`, the kernel of `f`\nis the unique additive congruence relation on `M` whose induced map from the quotient of `M`\nto `P` is injective."},{"type":"‚àÄ {R : Type u_2} [inst : LinearOrderedCommRing R] {M : Type u_1} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {v‚ÇÅ : M} {v‚ÇÇ : M} (h : v‚ÇÅ ‚àà MulAction.orbit { x : RÀ£ // x ‚àà Units.posSubgroup R } v‚ÇÇ), SameRay R v‚ÇÅ v‚ÇÇ","name":"sameRay_of_mem_orbit","isProp":true,"docString":"`SameRay` follows from membership of `MulAction.orbit` for the `Units.posSubgroup`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  {t : CategoryTheory.Limits.Cofork f g} {Z : C} {Z' : C} (q : Z ‚ü∂ Z') (ht : CategoryTheory.Limits.IsColimit t)\n  (k : CategoryTheory.Limits.Cocone.pt t ‚ü∂ Z),\n  ‚Üë(‚Üë(CategoryTheory.Limits.Cofork.IsColimit.homIso ht Z') (k ‚â´ q)) =\n    ‚Üë(‚Üë(CategoryTheory.Limits.Cofork.IsColimit.homIso ht Z) k) ‚â´ q","name":"CategoryTheory.Limits.Cofork.IsColimit.homIso_natural","isProp":true,"docString":"The bijection of `Cofork.IsColimit.homIso` is natural in `Z`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedAddGroup E] {f : (a : Œ±) ‚Üí E} {a : (a : Œ±) ‚Üí ‚Ñù} {t‚ÇÄ : Filter Œ±}\n  (h : ‚àÄ (n : Œ±), ‚Äñf n‚Äñ ‚â§ a n) (a : Filter.Tendsto a t‚ÇÄ (nhds 0)), Filter.Tendsto f t‚ÇÄ (nhds 0)","name":"squeeze_zero_norm","isProp":true,"docString":"Special case of the sandwich theorem: if the norm of `f` is bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `0`."},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : ConditionallyCompleteLinearOrder R] (s : Finset S)\n  (f : (a : S) ‚Üí Tropical (WithTop R)),\n  Tropical.untrop (Finset.sum s fun (i : S) ‚Ü¶ f i) = inf·µ¢ fun (i : { x : S // x ‚àà s }) ‚Ü¶ Tropical.untrop (f ‚Üëi)","name":"Finset.untrop_sum","isProp":true,"docString":"Note we cannot use `i ‚àà s` instead of `i : s` here\nas it is simply not true on conditionally complete lattices! "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {K : NNReal} {f : (a : Œ±) ‚Üí Œ±} (hf : ContractingWith K f) [inst_1 : Nonempty Œ±]\n  [inst_2 : CompleteSpace Œ±], Function.IsFixedPt f (ContractingWith.fixedPoint f hf)","name":"ContractingWith.fixedPoint_isFixedPt","isProp":true,"docString":"The point provided by `ContractingWith.fixedPoint` is actually a fixed point. "},{"type":"‚àÄ {Œ± : Type u_1} (self : Filter Œ±) {x : Set Œ±} {y : Set Œ±} (a : x ‚àà Filter.sets self) (a : x ‚äÜ y), y ‚àà Filter.sets self","name":"Filter.sets_of_superset","isProp":true,"docString":"If a set belongs to a filter, then its superset belongs to the filter as well. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [self : CommMonoidWithZero M‚ÇÄ] (a : M‚ÇÄ), 0 * a = 0","name":"CommMonoidWithZero.zero_mul","isProp":true,"docString":"Zero is a left absorbing element for multiplication "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] [inst_1 : Preorder M]\n  [inst_2 : CovariantClass M M (fun (x : M) (x_1 : M) ‚Ü¶ x * x_1) fun (x : M) (x_1 : M) ‚Ü¶ x < x_1]\n  [inst_3 : CovariantClass M M (Function.swap fun (x : M) (x_1 : M) ‚Ü¶ x * x_1) fun (x : M) (x_1 : M) ‚Ü¶ x < x_1] {n : ‚Ñï}\n  (hn : n ‚â† 0), StrictMono fun (a : M) ‚Ü¶ a ^ n","name":"pow_strictMono_right'","isProp":true,"docString":"See also `pow_strictMono_right` "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {l : Filter Œ±} {f : (a : Œ±) ‚Üí Œ≤} {lb : Filter Œ≤} (a : Filter.Tendsto f l lb),\n  Filter.Germ.Tendsto (‚Üëf) lb","name":"Filter.Tendsto.germ_tendsto","isProp":true,"docString":"**Alias** of the reverse direction of `Filter.Germ.coe_tendsto`."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u}, Function.Injective2 Fin.cons","name":"Fin.cons_injective2","isProp":true,"docString":"As a binary function, `Fin.cons` is injective. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C] [hC : CategoryTheory.Pretriangulated C]\n  (T : CategoryTheory.Pretriangulated.Triangle C) (H : T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles),\n  CategoryTheory.Pretriangulated.Triangle.rotate T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles","name":"CategoryTheory.Pretriangulated.rot_of_dist_triangle","isProp":true,"docString":"Given any distinguished triangle `T`, then we know `T.rotate` is also distinguished.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} {f : P ‚ü∂ Q} [self : CategoryTheory.StrongMono f],\n  CategoryTheory.Mono f","name":"CategoryTheory.StrongMono.mono","isProp":true,"docString":"The monomorphism condition on `f` "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R ‚Üí+* S) (hf : Function.Surjective ‚Üëf),\n  RingHom.range f = ‚ä§","name":"RingHom.range_top_of_surjective","isProp":true,"docString":"The range of a surjective ring homomorphism is the whole of the codomain. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : Subsingleton Œ±À£] {a : Œ±} {b : Œ±} (a_1 : a ‚à£ b)\n  (a_2 : b ‚à£ a), b = a","name":"Dvd.dvd.antisymm'","isProp":true,"docString":"**Alias** of `dvd_antisymm'`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {S : D}\n  {T : C ‚•§ D} {A : CategoryTheory.StructuredArrow S T} {B : CategoryTheory.StructuredArrow S T} (f : A ‚ü∂ B)\n  [h : CategoryTheory.Mono (CategoryTheory.CommaMorphism.right f)], CategoryTheory.Mono f","name":"CategoryTheory.StructuredArrow.mono_of_mono_right","isProp":true,"docString":"The converse of this is true with additional assumptions, see `mono_iff_mono_right`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (s : R)\n  (x : M), (r + s) ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x","name":"Module.Core.add_smul","isProp":true,"docString":"Scalar multiplication distributes over addition from the right. "},{"type":"‚àÄ (m : ‚Ñï) (n : ‚Ñï) (k : ‚Ñï),\n  Nat.choose (m + n) k =\n    Finset.sum (Finset.Nat.antidiagonal k) fun (ij : ‚Ñï √ó ‚Ñï) ‚Ü¶ Nat.choose m (Prod.fst ij) * Nat.choose n (Prod.snd ij)","name":"Nat.add_choose_eq","isProp":true,"docString":"Vandermonde's identity "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ‚Ñï} {i : Fin (n + 1)}\n  {j : Fin (n + 1)} (H : i ‚â§ j),\n  CategoryTheory.SimplicialObject.œÉ X j ‚â´ CategoryTheory.SimplicialObject.œÉ X (‚ÜëFin.castSucc i) =\n    CategoryTheory.SimplicialObject.œÉ X i ‚â´ CategoryTheory.SimplicialObject.œÉ X (Fin.succ j)","name":"CategoryTheory.SimplicialObject.œÉ_comp_œÉ","isProp":true,"docString":"The fifth simplicial identity "},{"type":"‚àÄ {K : Type u} [inst : Field K] ‚¶És : Set K‚¶Ñ ‚¶Ét : Set K‚¶Ñ (h : s ‚äÜ t), Subfield.closure s ‚â§ Subfield.closure t","name":"Subfield.closure_mono","isProp":true,"docString":"Subfield closure of a set is monotone in its argument: if `s ‚äÜ t`,\nthen `closure s ‚â§ closure t`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≤' : Type u_5} {Œ≥ : Type u_2} {Œ¥ : Type u_1} [inst : DecidableEq Œ≤']\n  [inst_1 : DecidableEq Œ≥] [inst_2 : DecidableEq Œ¥] {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Finset Œ±} {t : Finset Œ≤}\n  {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ¥} {g' : (a : Œ≤) ‚Üí Œ≤'}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' a (g' b)),\n  Finset.image g (Finset.image‚ÇÇ f s t) = Finset.image‚ÇÇ f' s (Finset.image g' t)","name":"Finset.image_image‚ÇÇ_distrib_right","isProp":true,"docString":"Symmetric statement to `Finset.image_image‚ÇÇ_right_comm`. "},{"type":"‚àÄ {L : Type v} [self : LieRing L] (x : L) (y : L) (z : L), ‚ÅÖx, ‚ÅÖy, z‚ÅÜ‚ÅÜ = ‚ÅÖ‚ÅÖx, y‚ÅÜ, z‚ÅÜ + ‚ÅÖy, ‚ÅÖx, z‚ÅÜ‚ÅÜ","name":"LieRing.leibniz_lie","isProp":true,"docString":"A Lie ring bracket satisfies a Leibniz / Jacobi identity. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] [inst_1 : IsIrrefl Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±}, ¬¨(a ‚äÇ a : Prop)","name":"HasSSubset.SSubset.false","isProp":true,"docString":"**Alias** of `ssubset_irrfl`."},{"type":"‚àÄ {S : Type u_1} [inst : Semigroup S] {a : S} {b : S} {c : S} (hab : Commute a b) (hac : Commute a c), Commute a (b * c)","name":"Commute.mul_right","isProp":true,"docString":"If `a` commutes with both `b` and `c`, then it commutes with their product. "},{"type":"‚àÄ {M : Type u} [self : AddRightCancelMonoid M] (x : M), AddRightCancelMonoid.nsmul 0 x = 0","name":"AddRightCancelMonoid.nsmul_zero","isProp":true,"docString":"Multiplication by `(0 : ‚Ñï)` gives `0`. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R ‚Üí+* S} {g : R ‚Üí+* S} {s : Set R}\n  (h : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subring.closure s)","name":"RingHom.eqOn_set_closure","isProp":true,"docString":"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. "},{"type":"‚àÄ {Œ≤ : Type v} {œÄ : (a : Œ≤) ‚Üí Type u_1} [inst : Fintype Œ≤] [inst_1 : (b : Œ≤) ‚Üí PseudoMetricSpace (œÄ b)]\n  [inst_2 : Nonempty Œ≤] (x : (b : Œ≤) ‚Üí œÄ b) (r : ‚Ñù), Metric.ball x r = Set.pi Set.univ fun (b : Œ≤) ‚Ü¶ Metric.ball (x b) r","name":"ball_pi'","isProp":true,"docString":"An open ball in a product space is a product of open balls. See also `metric.ball_pi`\nfor a version assuming `0 < r` instead of `Nonempty Œ≤`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] {s : TopologicalSpace.Opens Œ±},\n  (IsCoatom s : Prop) ‚Üî (‚àÉ (x : Œ±), s = TopologicalSpace.Closeds.compl (TopologicalSpace.Closeds.singleton x) : Prop)","name":"TopologicalSpace.Opens.isCoatom_iff","isProp":true,"docString":"in a `T1Space`, coatoms of `TopologicalSpace.Opens Œ±` are precisely complements of singletons:\n`(TopologicalSpace.Closeds.singleton x).compl`. "},{"type":"‚àÄ {X : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E]\n  [inst_2 : TopologicalSpace X] {f : (a : X) ‚Üí E} {c : X} {y : E} (h : IsLocalMax (norm ‚àò f) c)\n  (hy : SameRay ‚Ñù (f c) y), IsLocalMax (fun (x : X) ‚Ü¶ ‚Äñf x + y‚Äñ) c","name":"IsLocalMax.norm_add_sameRay","isProp":true,"docString":"If `f : Œ± ‚Üí E` is a function such that `norm ‚àò f` has a local maximum at a point `c` and `y` is\na vector on the same ray as `f c`, then the function `fun x => ‚Äñf x + y‚Äñ` has a local maximum\nat `c`. "},{"type":"‚àÄ {K : Type u_2} [inst : Field K] {Œ≤ : Type u_1} {f : (a : Œ≤) ‚Üí Polynomial K} (s : Finset Œ≤) {x : Œ≤} (hx : x ‚àà s)\n  (hfz : f x ‚â† 0), (Finset.gcd s fun (b : Œ≤) ‚Ü¶ f b / Finset.gcd s f) = 1","name":"Finset.Polynomial.gcd_div_eq_one","isProp":true,"docString":"Given a nonempty Finset `s` and a function `f` from `s` to `K[X]`, if `d = s.gcd f`,\nthen the `gcd` of `(f i) / d` is equal to `1`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K] {U : Set (G √ó K)} (hU : U ‚àà nhds 1),\n  ‚àÉ (V : OpenSubgroup G), ‚àÉ (W : OpenSubgroup K), ‚ÜëV √óÀ¢ ‚ÜëW ‚äÜ U","name":"NonarchimedeanGroup.prod_subset","isProp":true,"docString":"An open neighborhood of the identity in the cartesian product of two nonarchimedean groups\ncontains the cartesian product of an open neighborhood in each group. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : a < b) (a_2 : b ‚â§ c), a < c","name":"LT.lt.trans_le","isProp":true,"docString":"**Alias** of `lt_of_lt_of_le`."},{"type":"‚àÄ {Œ± : Type u_1} {Œπ' : Sort u_2} [inst : CompleteLattice Œ±] (s : (a : Œπ') ‚Üí Œ±),\n  (inf·µ¢ fun (i : Œπ') ‚Ü¶ s i) =\n    inf·µ¢ fun (t : Finset (PLift Œπ')) ‚Ü¶ inf·µ¢ fun (i : PLift Œπ') ‚Ü¶ inf·µ¢ fun (h : i ‚àà t) ‚Ü¶ s (PLift.down i)","name":"inf·µ¢_eq_inf·µ¢_finset'","isProp":true,"docString":"Infimum of `s i`, `i : Œπ`, is equal to the infimum over `t : Finset Œπ` of infima\n`‚®Ö i ‚àà t, s i`. This version works for `Œπ : Sort*`. See `inf·µ¢_eq_inf·µ¢_finset` for a version\nthat assumes `Œπ : Type _` but has no `plift`s. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C]\n  [self : CategoryTheory.Pretriangulated C] (X : C),\n  CategoryTheory.Pretriangulated.contractibleTriangle X ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles","name":"CategoryTheory.Pretriangulated.contractible_distinguished","isProp":true,"docString":"obvious triangles `X ‚ü∂ X ‚ü∂ 0 ‚ü∂ X‚ü¶1‚üß` are distinguished "},{"type":"‚àÄ {Œ± : Type ua} {Œ≤ : Type ub} [inst : UniformSpace Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ± √ó Œ±}\n  (h : Filter.Tendsto f l (uniformity Œ±)),\n  Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ (Prod.snd (f x), Prod.fst (f x))) l (uniformity Œ±)","name":"Filter.Tendsto.uniformity_symm","isProp":true,"docString":"Relation `Œª f g, tendsto (Œª x, (f x, g x)) l (ùì§ Œ±)` is symmetric "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] (x : (i : Œπ) ‚Üí Œ≤ i)\n  (y : (i : Œπ) ‚Üí Œ≤ i) (z : (i : Œπ) ‚Üí Œ≤ i), hammingDist x y ‚â§ hammingDist z x + hammingDist z y","name":"hammingDist_triangle_left","isProp":true,"docString":"Corresponds to `dist_triangle_left`. "},{"type":"‚àÄ {R : Type u} [self : Ring R] (n : ‚Ñï), IntCast.intCast ‚Üën = ‚Üën","name":"Ring.intCast_ofNat","isProp":true,"docString":"The canonical homorphism `‚Ñ§ ‚Üí R` agrees with the one from `‚Ñï ‚Üí R` on `‚Ñï`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C],\n  CategoryTheory.preadditiveCoyoneda ‚ãô\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.whiskeringRight C AddCommGroupCat (Type v)))\n        (CategoryTheory.forget AddCommGroupCat) =\n    CategoryTheory.coyoneda","name":"CategoryTheory.whiskering_preadditiveCoyoneda","isProp":true,"docString":"Composing the preadditive yoneda embedding with the forgetful functor yields the regular\nYoneda embedding.\n"},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedSemifield R] [inst_1 : FloorSemiring R] {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñ§} {r : R}\n  (hr : 0 < r), (r ‚â§ ‚Üëb ^ x : Prop) ‚Üî (Int.clog b r ‚â§ x : Prop)","name":"Int.le_zpow_iff_clog_le","isProp":true,"docString":"`Int.clog b` and `zpow b` (almost) form a Galois connection. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} (h : Equicontinuous F) (i : Œπ), Continuous (F i)","name":"Equicontinuous.continuous","isProp":true,"docString":"Each function of an equicontinuous family is continuous. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {l : Filter Œ±} {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} (a : f =·∂†[l] g), ‚Üëf = ‚Üëg","name":"Filter.EventuallyEq.germ_eq","isProp":true,"docString":"**Alias** of the reverse direction of `Filter.Germ.coe_eq`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : Ring ùïú] [inst_1 : SeminormedAddCommGroup E] [inst_2 : Module ùïú E]\n  {s : Submodule ùïú E} (x : { x : E // x ‚àà s }), ‚Äñ‚Üëx‚Äñ = ‚Äñx‚Äñ","name":"Submodule.norm_coe","isProp":true,"docString":"If `x` is an element of a submodule `s` of a normed group `E`, its norm in `E` is equal to its\nnorm in `s`.\n\nThis is a reversed version of the `simp` lemma `Submodule.coe_norm` for use by `norm_cast`. "},{"type":"‚àÄ {Œ± : Type u} [inst : LT Œ±] [self : DenselyOrdered Œ±] (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (a : a‚ÇÅ < a‚ÇÇ),\n  ‚àÉ (a : Œ±), (a‚ÇÅ < a : Prop) ‚àß (a < a‚ÇÇ : Prop)","name":"DenselyOrdered.dense","isProp":true,"docString":"An order is dense if there is an element between any pair of distinct elements. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f) (hg : Antitone g), Antitone fun (x : Œ±) ‚Ü¶ max (f x) (g x)","name":"Antitone.max","isProp":true,"docString":"Pointwise maximum of two monotone functions is a monotone function. "},{"type":"‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (self : Œ±À£), ‚Üëself * Units.inv self = 1","name":"Units.val_inv","isProp":true,"docString":"`inv` is the right inverse of `val` in the base `Monoid`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] (x : Œ±),\n  Disjoint (nhds x) (Filter.cocompact Œ±)","name":"disjoint_nhds_cocompact","isProp":true,"docString":"In a locally compact space, the filters `ùìù x` and `cocompact Œ±` are disjoint for all `Œ±`. "},{"type":"‚àÄ {Œ± : Type u} {l : List Œ±} (hn : List.Nodup l), List.Nodup (List.cyclicPermutations l)","name":"List.Nodup.cyclicPermutations","isProp":true,"docString":"If a `l : List Œ±` is `Nodup l`, then all of its cyclic permutants are distinct. "},{"type":"‚àÄ {Œ± : Type u_2} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : UniqueFactorizationMonoid Œ±] {Œ≤ : Type u_1}\n  [inst_2 : CancelCommMonoidWithZero Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (a : Œ±) (b : Œ±) (h0 : f 0 = 0)\n  (h1 : ‚àÄ {x : Œ±} {y : Œ±} (a : IsUnit y), f (x * y) = f x * f y)\n  (hpr : ‚àÄ {p : Œ±} (i : ‚Ñï) (a : Prime p), f (p ^ i) = f p ^ i)\n  (hcp : ‚àÄ {x : Œ±} {y : Œ±} (a : ‚àÄ (p : Œ±) (a : p ‚à£ x) (a : p ‚à£ y), IsUnit p), f (x * y) = f x * f y),\n  f (a * b) = f a * f b","name":"UniqueFactorizationMonoid.multiplicative_of_coprime","isProp":true,"docString":"If `f` maps `p ^ i` to `(f p) ^ i` for primes `p`, and `f`\nis multiplicative on coprime elements, then `f` is multiplicative everywhere. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R) {Œπ : Type u_1} [inst_1 : Finite Œπ] {Œπ' : Type w} (x : (a : Œπ) ‚Üí R)\n  (hi : ‚àÄ (i : Œπ), x i ‚àà I) (f : ((a : Œπ) ‚Üí R) ‚Üí‚Çó[R] (a : Œπ') ‚Üí R) (i : Œπ'), ‚Üëf x i ‚àà I","name":"Ideal.map_pi","isProp":true,"docString":"If `f : R^n ‚Üí R^m` is an `R`-linear map and `I ‚äÜ R` is an ideal, then the image of `I^n` is\ncontained in `I^m`. "},{"type":"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)} (hc : Setoid.IsPartition c) {s : Set Œ±} (h : s ‚àà c), Set.Nonempty s","name":"Setoid.nonempty_of_mem_partition","isProp":true,"docString":"A partition of `Œ±` does not contain the empty set. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  (h :\n    ‚àÄ (J : Type w) {ùí• : CategoryTheory.SmallCategory J} (x : CategoryTheory.FinCategory J),\n      CategoryTheory.Limits.HasColimitsOfShape J C),\n  CategoryTheory.Limits.HasFiniteColimits C","name":"CategoryTheory.Limits.hasFiniteColimits_of_hasFiniteColimits_of_size","isProp":true,"docString":"We can always derive `HasFiniteColimits C` by providing colimits at an\narbitrary universe. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C} {X : C} {Y : C} {Z : C} {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y}\n  {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (w : CategoryTheory.CommSq fst snd f g)\n  (h : CategoryTheory.Limits.IsLimit (CategoryTheory.CommSq.cone w)), CategoryTheory.IsPullback fst snd f g","name":"CategoryTheory.IsPullback.of_isLimit'","isProp":true,"docString":"A variant of `of_isLimit` that is more useful with `apply`. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.weightedVSub s p) w =\n    Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p i -·µ• Classical.choice ((AddTorsor.Nonempty=:Nonempty P)=:Nonempty P))","name":"Finset.weightedVSub_apply","isProp":true,"docString":"Applying `weightedVSub` with given weights.  This is for the case\nwhere a result involving a default base point is OK (for example, when\nthat base point will cancel out later); a more typical use case for\n`weightedVSub` would involve selecting a preferred base point with\n`weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero` and then\nusing `weightedVSubOfPoint_apply`. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R) {x : R} {y : R} (a : x ‚àà s) (a : y ‚àà s), x + y ‚àà s","name":"Subring.add_mem","isProp":true,"docString":"A subring is closed under addition. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasPullbacks C","name":"CategoryTheory.Abelian.hasPullbacks","isProp":true,"docString":"Any abelian category has pullbacks "},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : (a : Œ±) ‚Üí Sort v} {f : (x : Œ±) ‚Üí Œ≤ x} {g : (x : Œ±) ‚Üí Œ≤ x} (h : f = g) (a : Œ±), f a = g a","name":"congrFun","isProp":true,"docString":"Congruence in the function part of an application: If `f = g` then `f a = g a`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  (a_1 : 1 ‚â§ a‚Åª¬π), a ‚â§ 1","name":"le_one_of_one_le_inv","isProp":true,"docString":"**Alias** of the forward direction of `Left.one_le_inv_iff`."},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Type u_2} {Œ≥ : Sort u_3} [inst : DecidableEq Œ≤] (g : (a : Œ≤) ‚Üí Œ≥) {f : (a : Œ±) ‚Üí Œ≤} {i : Œ≤}\n  (a : Œ≥) (h : ¬¨(i ‚àà Set.range f : Prop)), Function.update g i a ‚àò f = g ‚àò f","name":"Function.update_comp_eq_of_not_mem_range","isProp":true,"docString":"Non-dependent version of `Function.update_comp_eq_of_not_mem_range'` "},{"type":"‚àÄ {Œ± : Type u} [inst : MetricSpace Œ±]\n  (H :\n    ‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n      ‚àÉ (Œ≤ : Type u_1), ‚àÉ (x : Encodable Œ≤), ‚àÉ (F : (a : Œ±) ‚Üí Œ≤), ‚àÄ (x : Œ±) (y : Œ±) (a : F x = F y), dist x y ‚â§ Œµ),\n  TopologicalSpace.SecondCountableTopology Œ±","name":"Metric.secondCountable_of_countable_discretization","isProp":true,"docString":"A metric space is second countable if one can reconstruct up to any `Œµ>0` any element of the\nspace from countably many data. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {a : Œ±} {f : (a : Œ±) ‚Üí Œ≤} [inst : AddCommMonoid Œ≤] [inst_1 : DecidableEq Œ±]\n  (h : f a = 0), (Finset.sum (insert a s) fun (x : Œ±) ‚Ü¶ f x) = Finset.sum s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.sum_insert_zero","isProp":true,"docString":"The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `f a = 0`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsPreconnected s : Prop) ‚Üî\n    (‚àÄ (u : Set Œ±) (v : Set Œ±) (a : IsClosed u) (a : IsClosed v) (a : s ‚äÜ u ‚à™ v) (a : s ‚à© (u ‚à© v) = ‚àÖ),\n        (s ‚äÜ u : Prop) ‚à® (s ‚äÜ v : Prop) :\n      Prop)","name":"isPreconnected_iff_subset_of_disjoint_closed","isProp":true,"docString":"A set `s` is preconnected if and only if\nfor every cover by two closed sets that are disjoint on `s`,\nit is contained in one of the two covering sets. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {d : AddCon M}, c ‚äî d = addConGen (Setoid.r ‚äî Setoid.r)","name":"AddCon.sup_def","isProp":true,"docString":"The supremum of two additive congruence relations equals the smallest additive\ncongruence relation containing the supremum of the underlying binary operations."},{"type":"‚àÄ {R : Type u} [inst : Semiring R] (r : R), Polynomial.X * ‚ÜëPolynomial.C r = ‚ÜëPolynomial.C r * Polynomial.X","name":"Polynomial.X_mul_C","isProp":true,"docString":"Prefer putting constants to the left of `X`.\n\nThis lemma is the loop-avoiding `simp` version of `Polynomial.X_mul`. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} {n : ‚Ñ§} (a : Equiv.Perm.SameCycle f (‚Üë(f ^ n) x) y),\n  Equiv.Perm.SameCycle f x y","name":"Equiv.Perm.SameCycle.of_zpow_left","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.sameCycle_zpow_left`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [inst_1 : ProperSpace Œ±], LocallyCompactSpace Œ±","name":"locally_compact_of_proper","isProp":true,"docString":"A proper space is locally compact "},{"type":"‚àÄ {m : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} (hmc : Nat.gcd m c = 1) (h : a * c ‚â° b * c [MOD m]), a ‚â° b [MOD m]","name":"Nat.ModEq.cancel_right_of_coprime","isProp":true,"docString":"A common factor that's coprime with the modulus can be cancelled from a `ModEq` "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] [h : CompleteSpace Œ±], CompleteSpace (ULift Œ±)","name":"ULift.completeSpace","isProp":true,"docString":"The lift of a complete space to another universe is still complete. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n  {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (sup·µ¢ g)) (Mf : Monotone f) (fbot : f ‚ä• = ‚ä•),\n  f (sup·µ¢ fun (i : Œπ) ‚Ü¶ g i) = sup·µ¢ fun (i : Œπ) ‚Ü¶ f (g i)","name":"Monotone.map_sup·µ¢_of_continuousAt","isProp":true,"docString":"If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over\na `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. "},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : Type u_1} [inst : Preorder Œπ] [inst_1 : DecidableEq Œπ] [inst_2 : Preorder Œ±] {f : (a : Œπ) ‚Üí Œ±}\n  {i : Œπ} {j : Œπ} (h‚ÇÅ : i < j) (h‚ÇÇ : f j < f i), ‚ÜëtoLex (f ‚àò ‚Üë(Equiv.swap i j)) < ‚ÜëtoLex f","name":"Pi.lex_desc","isProp":true,"docString":"If we swap two strictly decreasing values in a function, then the result is lexicographically\nsmaller than the original function. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : T2Space Œ±] [inst_2 : ProperSpace Œ±],\n  (IsCompact s : Prop) ‚Üî ((IsClosed s : Prop) ‚àß (Metric.Bounded s : Prop) : Prop)","name":"Metric.isCompact_iff_isClosed_bounded","isProp":true,"docString":"The **Heine‚ÄìBorel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (e : M ‚âÉ+ N) (y : N), ‚Üëe (‚Üë(AddEquiv.symm e) y) = y","name":"AddEquiv.apply_symm_apply","isProp":true,"docString":"`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {f : (a : Œ±) ‚Üí ‚Ñù} (K : ‚Ñù)\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s), f x ‚â§ f y + K * dist x y), LipschitzOnWith (Real.toNNReal K) f s","name":"LipschitzOnWith.of_le_add_mul'","isProp":true,"docString":"For functions to `‚Ñù`, it suffices to prove `f x ‚â§ f y + K * dist x y`; this version\ndoesn't assume `0‚â§K`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] (self : UpperSet Œ±), IsUpperSet (UpperSet.carrier self)","name":"UpperSet.upper'","isProp":true,"docString":"The carrier of an `UpperSet` is an upper set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (ha : a < 0) (hb : b < 0), a + b < 0","name":"Right.add_neg","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg`."},{"type":"‚àÄ {R : Type u} {œÉ : Type v} [inst : CommRing R] (I : Ideal (MvPolynomial œÉ R)) (p : MvPolynomial œÉ R)\n  (hcoe : ‚àÄ (m : œÉ ‚Üí‚ÇÄ ‚Ñï), MvPolynomial.coeff m p ‚àà Ideal.comap MvPolynomial.C I), p ‚àà I","name":"MvPolynomial.mem_ideal_of_coeff_mem_ideal","isProp":true,"docString":"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\nmultivariate version. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {Œπ : Type w} {b : Finset Œπ} (h : Basis { x : Œπ // x ‚àà b } K V),\n  FiniteDimensional.finrank K V = Finset.card b","name":"FiniteDimensional.finrank_eq_card_finset_basis","isProp":true,"docString":"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. This lemma uses a `Finset` instead of indexed types. "},{"type":"‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x : Œ±) (y : Œ±), x ‚á® y = y ‚äî x·∂ú","name":"BooleanAlgebra.himp_eq","isProp":true,"docString":"`x ‚á® y` is equal to `y ‚äî x·∂ú` "},{"type":"‚àÄ {m : Type u} {Œ± : Type v} [inst : CommRing Œ±] [inst_1 : Fintype m] [inst_2 : DecidableEq m] {M : Matrix m m Œ±}\n  (h : IsUnit M) (N : Matrix m m Œ±), Matrix.det (Matrix.mul (Matrix.mul M‚Åª¬π N) M) = Matrix.det N","name":"Matrix.det_conj'","isProp":true,"docString":"A variant of `Matrix.det_units_conj'`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] {A : Finset Œ±} (hA : Finset.Nonempty A) (B : Finset Œ±)\n  (n : ‚Ñï), ‚Üë(Finset.card (B ^ n)) ‚â§ (‚Üë(Finset.card (A * B)) / ‚Üë(Finset.card A)) ^ n * ‚Üë(Finset.card A)","name":"Finset.card_pow_le","isProp":true,"docString":"Special case of the **Pl√ºnnecke-Ruzsa inequality**. Multiplication version. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCancelCommMonoid Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"LinearOrderedCancelCommMonoid.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±·µí·µà} (a_1 : IsTop a), IsBot (‚ÜëOrderDual.ofDual a)","name":"IsTop.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `isBot_ofDual_iff`."},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {c : AddCon M}\n  (f : AddCon.Quotient c ‚Üí+ P),\n  AddCon.lift c (AddMonoidHom.comp f (AddCon.mk' c))\n      (fun (x : M) ‚Ü¶ (_ : ‚àÄ (y : M) (h : ‚Üëc x y), ‚Üëf ‚Üëx = ‚Üëf ‚Üëy)=:‚àÄ (x : M) (y : M) (h : ‚Üëc x y), ‚Üëf ‚Üëx = ‚Üëf ‚Üëy) =\n    f","name":"AddCon.lift_apply_mk'","isProp":true,"docString":"Given a homomorphism `f` from the quotient of an `AddMonoid` by an\nadditive congruence relation, `f` equals the homomorphism on the quotient induced by `f` composed\nwith the natural map from the `AddMonoid` to the quotient."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Lattice Œ±] [inst_1 : Lattice Œ≤] [inst_2 : BoundedOrder Œ±]\n  [inst_3 : BoundedOrder Œ≤] (self : BoundedLatticeHom Œ± Œ≤),\n  SupHom.toFun (LatticeHom.toSupHom (BoundedLatticeHom.toLatticeHom self)) ‚ä§ = ‚ä§","name":"BoundedLatticeHom.map_top'","isProp":true,"docString":"A `BoundedLatticeHom` preserves the top element. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {t : Set Œ±}\n  (Hf : AntitoneOn f t) {a : Œ±} (a_1 : IsGreatest t a), IsLeast (f '' t) (f a)","name":"AntitoneOn.map_isGreatest","isProp":true,"docString":"An antitone map sends a greatest element of a set to a least element of its image. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {M : Type u_3} {N : Type u_1} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid N]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Œ± ‚Üí‚ÇÄ M} (h : (a : Œ≤) ‚Üí M ‚Üí+ N),\n  (Finsupp.sum (Finsupp.mapDomain f s) fun (b : Œ≤) (m : M) ‚Ü¶ ‚Üë(h b) m) =\n    Finsupp.sum s fun (a : Œ±) (m : M) ‚Ü¶ ‚Üë(h (f a)) m","name":"Finsupp.sum_mapDomain_index_addMonoidHom","isProp":true,"docString":"A version of `sum_mapDomain_index` that takes a bundled `AddMonoidHom`,\nrather than separate linearity hypotheses.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C]\n  [self : CategoryTheory.Pretriangulated C] (T‚ÇÅ : CategoryTheory.Pretriangulated.Triangle C)\n  (a : T‚ÇÅ ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles) (T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle C)\n  (x : T‚ÇÇ ‚âÖ T‚ÇÅ), T‚ÇÇ ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles","name":"CategoryTheory.Pretriangulated.isomorphic_distinguished","isProp":true,"docString":"a triangle that is isomorphic to a distinguished triangle is distinguished "},{"type":"‚àÄ {R : Type u} {n : ‚Ñï} {M : (a : Fin (Nat.succ n)) ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Fin (Nat.succ n)) ‚Üí AddCommMonoid (M i)] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : (i : Fin (Nat.succ n)) ‚Üí Module R (M i)] [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M M‚ÇÇ)\n  (m : (i : Fin n) ‚Üí M (Fin.succ i)) (x : M 0) (y : M 0),\n  ‚Üëf (Fin.cons (x + y) m) = ‚Üëf (Fin.cons x m) + ‚Üëf (Fin.cons y m)","name":"MultilinearMap.cons_add","isProp":true,"docString":"In the specific case of multilinear maps on spaces indexed by `Fin (n+1)`, where one can build\nan element of `‚àÄ (i : Fin (n+1)), M i` using `cons`, one can express directly the additivity of a\nmultilinear map along the first variable. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonAssocRing Œ±] (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1","name":"NonAssocRing.natCast_succ","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` is a homomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [inst_1 : IsModularLattice Œ±] [inst_2 : IsCompactlyGenerated Œ±]\n  (h : sup‚Çõ (setOf fun (a : Œ±) ‚Ü¶ IsAtom a) = ‚ä§), ComplementedLattice Œ±","name":"complementedLattice_of_sup‚Çõ_atoms_eq_top","isProp":true,"docString":"See [Theorem 6.6][calugareanu]. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient (DiscreteQuotient.toSetoid S))","name":"DiscreteQuotient.instFiniteQuotientToSetoid","isProp":true,"docString":"If `X` is a compact space, then any discrete quotient of `X` is finite. "},{"type":"‚àÄ (p : ‚Ñï+) (q : ‚Ñï+) (r : ‚Ñï+), (1 < ADEInequality.sumInv {p, q, r} : Prop) ‚Üî (ADEInequality.Admissible {p, q, r} : Prop)","name":"ADEInequality.classification","isProp":true,"docString":"A multiset `{p,q,r}` of positive natural numbers\nis a solution to `(p‚Åª¬π + q‚Åª¬π + r‚Åª¬π : ‚Ñö) > 1` if and only if\nit is `admissible` which means it is one of:\n\n* `A' q r := {1,q,r}`\n* `D' r := {2,2,r}`\n* `E6 := {2,3,3}`, or `E7 := {2,3,4}`, or `E8 := {2,3,5}`\n"},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : b ‚â§ c) (a_2 : a ‚â§ b), a ‚â§ c","name":"LE.le.trans'","isProp":true,"docString":"**Alias** of `le_trans'`."},{"type":"‚àÄ {Œ± : Type u_1} {m : PseudoMetricSpace Œ±} {m' : PseudoMetricSpace Œ±}\n  (h : PseudoMetricSpace.toDist = PseudoMetricSpace.toDist), m = m'","name":"PseudoMetricSpace.ext","isProp":true,"docString":"Two pseudo metric space structures with the same distance function coincide. "},{"type":"‚àÄ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\n  [inst_3 : Archimedean G] (S : AddSubgroup G), (Dense ‚ÜëS : Prop) ‚à® (‚àÉ (a : G), S = AddSubgroup.closure {a} : Prop)","name":"AddSubgroup.dense_or_cyclic","isProp":true,"docString":"An additive subgroup of an archimedean linear ordered additive commutative group `G` with order\ntopology either is dense in `G` or is a cyclic subgroup. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±]\n  [inst_3 : MulPosStrictMono Œ±] (ha : a < 1) (hb : b ‚â§ 1) (b0 : 0 < b), a * b < 1","name":"Right.mul_lt_one_of_lt_of_le_of_pos","isProp":true,"docString":"Assumes right covariance. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (s : Set Œ≤)\n  (h : Inducing f), Inducing (Set.restrictPreimage s f)","name":"Inducing.restrictPreimage","isProp":true,"docString":"**Alias** of `Set.restrictPreimage_inducing`."},{"type":"‚àÄ {Œπ : Type u_1} [inst : Finite Œπ] (s : Finset (BoxIntegral.Box Œπ)),\n  Filter.Eventually\n    (fun (t : Finset (Œπ √ó ‚Ñù)) ‚Ü¶\n      ‚àÄ (I : BoxIntegral.Box Œπ) (J : BoxIntegral.Box Œπ) (a : J ‚àà s) (J' : BoxIntegral.Box Œπ)\n        (a : J' ‚àà BoxIntegral.Prepartition.splitMany I t) (a : ¬¨(Disjoint ‚ÜëJ ‚ÜëJ' : Prop)), J' ‚â§ J)\n    Filter.atTop","name":"BoxIntegral.Prepartition.eventually_not_disjoint_imp_le_of_mem_splitMany","isProp":true,"docString":"Let `s` be a finite set of boxes in `‚Ñù‚Åø = Œπ ‚Üí ‚Ñù`. Then there exists a finite set `t‚ÇÄ` of\nhyperplanes (namely, the set of all hyperfaces of boxes in `s`) such that for any `t ‚äá t‚ÇÄ`\nand any box `I` in `‚Ñù‚Åø` the following holds. The hyperplanes from `t` split `I` into subboxes.\nLet `J'` be one of them, and let `J` be one of the boxes in `s`. If these boxes have a nonempty\nintersection, then `J' ‚â§ J`. "},{"type":"‚àÄ {R : Type u} [inst : NonUnitalSemiring R] [inst_1 : PartialOrder R] [self : StarOrderedRing R] (r : R),\n  (0 ‚â§ r : Prop) ‚Üî (‚àÉ (s : R), r = star s * s : Prop)","name":"StarOrderedRing.nonneg_iff","isProp":true,"docString":"characterization of non-negativity  "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú)\n  (hM : M (Sum.inr ()) (Sum.inr ()) ‚â† 0) (i : Fin r),\n  Matrix.mul (Matrix.mul (List.prod (Matrix.Pivot.listTransvecCol M)) M) (List.prod (Matrix.Pivot.listTransvecRow M))\n      (Sum.inr ()) (Sum.inl i) =\n    0","name":"Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_col","isProp":true,"docString":"Multiplying by all the matrices either in `listTransvecCol M` and `listTransvecRow M` kills\nall the coefficients in the last row but the last one. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ‚ß∏ S)","name":"FiniteDimensional.finiteDimensional_quotient","isProp":true,"docString":"A quotient of a finite-dimensional space is also finite-dimensional. "},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] {P : Type u_1} [inst_2 : FirstOrder.Language.Structure L P]\n  {Q : Type u_2} [inst_3 : FirstOrder.Language.Structure L Q] (f : FirstOrder.Language.Equiv L M N)\n  (g : FirstOrder.Language.Equiv L N P) (h : FirstOrder.Language.Equiv L P Q),\n  FirstOrder.Language.Equiv.comp (FirstOrder.Language.Equiv.comp h g) f =\n    FirstOrder.Language.Equiv.comp h (FirstOrder.Language.Equiv.comp g f)","name":"FirstOrder.Language.Equiv.comp_assoc","isProp":true,"docString":"Composition of first-order homomorphisms is associative. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {A : C} {B : C} {X : C} {Y : C} {f : A ‚ü∂ X} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\n  {g : B ‚ü∂ Y} {sq : CategoryTheory.CommSq f i p g} [self : CategoryTheory.CommSq.HasLift sq],\n  Nonempty (CategoryTheory.CommSq.LiftStruct sq)","name":"CategoryTheory.CommSq.HasLift.exists_lift","isProp":true,"docString":"Square has a `LiftStruct`. "},{"type":"‚àÄ {Œπ : Type u} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] [inst : (i : Œπ) ‚Üí AddZeroClass (Œ≤ i)] {Œ≥ : Type w}\n  [inst_1 : AddZeroClass Œ≥] ‚¶Éf : (Dfinsupp fun (i : Œπ) ‚Ü¶ Œ≤ i) ‚Üí+ Œ≥‚¶Ñ ‚¶Ég : (Dfinsupp fun (i : Œπ) ‚Ü¶ Œ≤ i) ‚Üí+ Œ≥‚¶Ñ\n  (H : ‚àÄ (x : Œπ), AddMonoidHom.comp f (Dfinsupp.singleAddHom Œ≤ x) = AddMonoidHom.comp g (Dfinsupp.singleAddHom Œ≤ x)),\n  f = g","name":"Dfinsupp.addHom_ext'","isProp":true,"docString":"If two additive homomorphisms from `Œ†‚ÇÄ i, Œ≤ i` are equal on each `single a b`, then\nthey are equal.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] (S : Submonoid M) {Œπ : Type u_2} {t : Finset Œπ} {f : (a : Œπ) ‚Üí M}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà S), (Finset.prod t fun (c : Œπ) ‚Ü¶ f c) ‚àà S","name":"Submonoid.prod_mem","isProp":true,"docString":"Product of elements of a submonoid of a `CommMonoid` indexed by a `Finset` is in the\nsubmonoid. "},{"type":"‚àÄ {E : (a : ‚Ñï) ‚Üí Type u_2} {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] {f : (a : (n : ‚Ñï) ‚Üí E n) ‚Üí Œ±},\n  (‚àÄ (x : (n : ‚Ñï) ‚Üí E n) (y : (n : ‚Ñï) ‚Üí E n), dist (f x) (f y) ‚â§ dist x y : Prop) ‚Üî\n    (‚àÄ (x : (n : ‚Ñï) ‚Üí E n) (y : (n : ‚Ñï) ‚Üí E n) (n : ‚Ñï) (a : y ‚àà PiNat.cylinder x n), dist (f x) (f y) ‚â§ (1 / 2) ^ n :\n      Prop)","name":"PiNat.lipschitz_with_one_iff_forall_dist_image_le_of_mem_cylinder","isProp":true,"docString":"A function to a pseudo-metric-space is `1`-Lipschitz if and only if points in the same cylinder\nof length `n` are sent to points within distance `(1/2)^n`.\nNot expressed using `LipschitzWith` as we don't have a metric space structure "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {G' : SimpleGraph V} (h : G ‚â§ G') {u : V} {p : SimpleGraph.Walk G u u}\n  (a : SimpleGraph.Walk.IsCycle p), SimpleGraph.Walk.IsCycle (SimpleGraph.Walk.mapLe h p)","name":"SimpleGraph.Walk.IsCycle.mapLe","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.Walk.mapLe_isCycle`."},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p : P} {ps : Set P} (h : p ‚àà affineSpan k ps), vectorSpan k (insert p ps) = vectorSpan k ps","name":"vectorSpan_insert_eq_vectorSpan","isProp":true,"docString":"If a point is in the affine span of a set, adding it to that set does not change the vector\nspan. "},{"type":"‚àÄ {Œ± : Type u_1} {r‚ÇÅ : Setoid Œ±} {r‚ÇÇ : Setoid Œ±},\n  (r‚ÇÅ = r‚ÇÇ : Prop) ‚Üî (‚àÄ (x : Œ±), (setOf fun (y : Œ±) ‚Ü¶ Setoid.Rel r‚ÇÅ x y) = setOf fun (y : Œ±) ‚Ü¶ Setoid.Rel r‚ÇÇ x y : Prop)","name":"Setoid.eq_iff_classes_eq","isProp":true,"docString":"Two equivalence relations are equal iff all their equivalence classes are equal. "},{"type":"‚àÄ {Œπ : Type u_1} {I : BoxIntegral.Box Œπ} (œÄ : BoxIntegral.Prepartition I) (x : (a : Œπ) ‚Üí ‚Ñù),\n  Set.InjOn (fun (J : BoxIntegral.Box Œπ) ‚Ü¶ setOf fun (i : Œπ) ‚Ü¶ BoxIntegral.Box.lower J i = x i)\n    (setOf fun (J : BoxIntegral.Box Œπ) ‚Ü¶ (J ‚àà œÄ : Prop) ‚àß (x ‚àà ‚ÜëBoxIntegral.Box.Icc J : Prop))","name":"BoxIntegral.Prepartition.injOn_setOf_mem_Icc_setOf_lower_eq","isProp":true,"docString":"An auxiliary lemma used to prove that the same point can't belong to more than\n`2 ^ Fintype.card Œπ` closed boxes of a prepartition. "},{"type":"‚àÄ {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {A : V} {B : V}\n  {C : V} (f : A ‚ü∂ B) [inst_2 : CategoryTheory.Limits.HasImages V] [inst_3 : CategoryTheory.Epi f],\n  CategoryTheory.Epi\n    (imageToKernel f 0\n      ((of_eq_true\n            ((Eq.trans\n                  ((congrFun\n                        ((congrArg Eq\n                              ((CategoryTheory.Limits.comp_zero=:f ‚â´ 0 =\n                                    0)=:f ‚â´ 0 = 0)=:Eq (f ‚â´ 0) = Eq 0)=:Eq (f ‚â´ 0) = Eq 0)\n                        0=:(f ‚â´ 0 = 0 : Prop) = (0 = 0 : Prop))=:(f ‚â´ 0 = 0 : Prop) = (0 = 0 : Prop))\n                  ((eq_self\n                        0=:(0 = 0 : Prop) =\n                        (True :\n                          Prop))=:(0 = 0 : Prop) =\n                      (True :\n                        Prop))=:(f ‚â´ 0 = 0 : Prop) =\n                  (True : Prop))=:(f ‚â´ 0 = 0 : Prop) = (True : Prop))=:f ‚â´ 0 = 0)=:f ‚â´ 0 = 0))","name":"imageToKernel_epi_of_epi_of_zero","isProp":true,"docString":"`imageToKernel` for `A --f--> B --0--> C`, where `g` is an epi is itself an epi\n(i.e. the sequence is exact at `B`).\n"},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : Sort v}, Function.Injective fun (e : Œ± ‚âÉ Œ≤) ‚Ü¶ ‚Üëe","name":"Equiv.coe_fn_injective","isProp":true,"docString":"The map `(r ‚âÉ s) ‚Üí (r ‚Üí s)` is injective. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroClass M‚ÇÄ] [inst_1 : NoZeroDivisors M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ},\n  (0 = a * b : Prop) ‚Üî ((a = 0 : Prop) ‚à® (b = 0 : Prop) : Prop)","name":"zero_eq_mul","isProp":true,"docString":"If `Œ±` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : P} {v : V} (hp : p ‚àà spanPoints k s) (hv : v ‚àà vectorSpan k s),\n  v +·µ• p ‚àà spanPoints k s","name":"vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan","isProp":true,"docString":"Adding a point in the affine span and a vector in the spanning submodule produces a point in the\naffine span. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : (a : Fin n) ‚Üí Œ±} {œÉ : Equiv.Perm (Fin n)},\n  (œÉ = Tuple.sort f : Prop) ‚Üî\n    ((Monotone (f ‚àò ‚ÜëœÉ) : Prop) ‚àß\n        (‚àÄ (i : Fin n) (j : Fin n) (a : i < j) (a : f (‚ÜëœÉ i) = f (‚ÜëœÉ j)), ‚ÜëœÉ i < ‚ÜëœÉ j : Prop) :\n      Prop)","name":"Tuple.eq_sort_iff","isProp":true,"docString":"A permutation `œÉ` equals `sort f` if and only if `f ‚àò œÉ` is monotone and whenever `i < j`\nand `f (œÉ i) = f (œÉ j)`, then `œÉ i < œÉ j`. This means that `sort f` is the lexicographically\nsmallest permutation `œÉ` such that `f ‚àò œÉ` is monotone. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddZeroClass Œ±] [inst_1 : AddCommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : IsAddMonoidHom f), IsAddMonoidHom fun (a : Œ±) ‚Ü¶ -f a","name":"IsAddMonoidHom.neg","isProp":true,"docString":"The negation of a map which preserves addition, preserves addition\nwhen the target is commutative."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {G‚ÇÄ : Type u_2} [inst : GroupWithZero G‚ÇÄ] [inst_1 : TopologicalSpace G‚ÇÄ]\n  [inst_2 : HasContinuousInv‚ÇÄ G‚ÇÄ] [inst_3 : ContinuousMul G‚ÇÄ] [inst_4 : TopologicalSpace Œ±]\n  [inst_5 : TopologicalSpace Œ≤] {a : Œ±} {f : (a : Œ±) ‚Üí G‚ÇÄ} {g : (a : Œ±) ‚Üí G‚ÇÄ} (h : (a : Œ±) ‚Üí (a : G‚ÇÄ) ‚Üí Œ≤)\n  (hf : ContinuousAt f a) (hg : ContinuousAt g a) (hh : ‚àÄ (a_1 : g a ‚â† 0), ContinuousAt (‚Üøh) (a, f a / g a))\n  (h2h : ‚àÄ (a_1 : g a = 0), Filter.Tendsto (‚Üøh) (Filter.prod (nhds a) ‚ä§) (nhds (h a 0))),\n  ContinuousAt (fun (x : Œ±) ‚Ü¶ h x (f x / g x)) a","name":"ContinuousAt.comp_div_cases","isProp":true,"docString":"The function `f x / g x` is discontinuous when `g x = 0`. However, under appropriate\nconditions, `h x (f x / g x)` is still continuous.  The condition is that if `g a = 0` then `h x y`\nmust tend to `h a 0` when `x` tends to `a`, with no information about `y`. This is represented by\nthe `‚ä§` filter.  Note: `tendsto_prod_top_iff` characterizes this convergence in uniform spaces.  See\nalso `Filter.prod_top` and `Filter.mem_prod_top`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] [inst_1 : Fintype Œπ] (S : (a : Œπ) ‚Üí Set Œ±),\n  (fun (f : (a : Œπ) ‚Üí Œ±) ‚Ü¶ Finset.prod Finset.univ fun (i : Œπ) ‚Ü¶ f i) '' Set.pi Set.univ S =\n    Finset.prod Finset.univ fun (i : Œπ) ‚Ü¶ S i","name":"Set.image_fintype_prod_pi","isProp":true,"docString":"A special case of `set.image_finset_prod_pi` for `finset.univ`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {s : Set Œ±}\n  (hl : ‚àÉ (l : Œ±), l < a) (hu : ‚àÉ (u : Œ±), a < u),\n  (s ‚àà nhds a : Prop) ‚Üî (‚àÉ (l : Œ±), ‚àÉ (u : Œ±), (a ‚àà Set.Ioo l u : Prop) ‚àß (Set.Ioo l u ‚äÜ s : Prop) : Prop)","name":"mem_nhds_iff_exists_Ioo_subset'","isProp":true,"docString":"A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,\nprovided `a` is neither a bottom element nor a top element. "},{"type":"‚àÄ {Œ± : Sort u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [self : Antisymm r] {a : Œ±} {b : Œ±} (a_1 : r a b) (a_2 : r b a), a = b","name":"Antisymm.antisymm","isProp":true,"docString":"An antisymmetric relation `(¬∑‚â§¬∑)` satisfies `a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b`. "},{"type":"‚àÄ {E : Sort u_1} {Œ± : outParam (Sort u_2)} {Œ≤ : outParam (Sort u_3)} [self : EquivLike E Œ± Œ≤] (e : E),\n  Function.RightInverse (EquivLike.inv e) (EquivLike.coe e)","name":"EquivLike.right_inv","isProp":true,"docString":"The coercions are right inverses. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú)\n  (hM : M (Sum.inr ()) (Sum.inr ()) ‚â† 0) (i : Fin r),\n  Matrix.mul (Matrix.mul (List.prod (Matrix.Pivot.listTransvecCol M)) M) (List.prod (Matrix.Pivot.listTransvecRow M))\n      (Sum.inl i) (Sum.inr ()) =\n    0","name":"Matrix.Pivot.listTransvecCol_mul_mul_listTransvecRow_last_row","isProp":true,"docString":"Multiplying by all the matrices either in `listTransvecCol M` and `listTransvecRow M` kills\nall the coefficients in the last column but the last one. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ≤) ‚Üí Œ±}\n  (hg : Set.InjOn g (Function.support (f ‚àò g))),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà Set.range g) ‚Ü¶ f i) = finsum fun (j : Œ≤) ‚Ü¶ f (g j)","name":"finsum_mem_range'","isProp":true,"docString":"The sum of `f y` over `y ‚àà Set.range g` equals the sum of `f (g i)` over all `i`\nprovided that `g` is injective on `support (f ‚àò g)`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : VSub Œ± Œ≤] [inst_1 : DecidableEq Œ±] {u : Finset Œ±} {s : Set Œ≤} {t : Set Œ≤}\n  (a : ‚Üëu ‚äÜ s -·µ• t),\n  ‚àÉ (s' : Finset Œ≤), ‚àÉ (t' : Finset Œ≤), (‚Üës' ‚äÜ s : Prop) ‚àß ((‚Üët' ‚äÜ t : Prop) ‚àß (u ‚äÜ s' -·µ• t' : Prop) : Prop)","name":"Finset.subset_vsub","isProp":true,"docString":"If a finset `u` is contained in the pointwise subtraction of two sets `s -·µ• t`, we can find two\nfinsets `s'`, `t'` such that `s' ‚äÜ s`, `t' ‚äÜ t` and `u ‚äÜ s' -·µ• t'`. "},{"type":"‚àÄ {ùïú : Type u_3} {E : Type u_2} {Œπ : Type u_1} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïú E] {p : (a : Œπ) ‚Üí E} (hi : Function.Injective p),\n  (ConvexIndependent ùïú Subtype.val : Prop) ‚Üî (ConvexIndependent ùïú p : Prop)","name":"Function.Injective.convexIndependent_iff_set","isProp":true,"docString":"The range of an injective indexed family of points is convex independent iff that family is. "},{"type":"‚àÄ {M : Type u_1} [inst : CancelCommMonoidWithZero M] {q : Associates M} {n : ‚Ñï} (hn : n ‚â† 0)\n  {c : (a : Fin (n + 1)) ‚Üí Associates M} (h‚ÇÅ : StrictMono c)\n  (h‚ÇÇ : ‚àÄ {r : Associates M}, (r ‚â§ q : Prop) ‚Üî (‚àÉ (i : Fin (n + 1)), r = c i : Prop)) (hq : q ‚â† 0), Irreducible (c 1)","name":"DivisorChain.second_of_chain_is_irreducible","isProp":true,"docString":"The second element of a chain is irreducible. "},{"type":"‚àÄ {Œ± : Type u_1} {G‚ÇÄ : Type u_2} [inst : Zero G‚ÇÄ] [inst_1 : Inv G‚ÇÄ] [inst_2 : TopologicalSpace G‚ÇÄ]\n  [inst_3 : HasContinuousInv‚ÇÄ G‚ÇÄ] {l : Filter Œ±} {f : (a : Œ±) ‚Üí G‚ÇÄ} {a : G‚ÇÄ} (hf : Filter.Tendsto f l (nhds a))\n  (ha : a ‚â† 0), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ (f x)‚Åª¬π) l (nhds a‚Åª¬π)","name":"Filter.Tendsto.inv‚ÇÄ","isProp":true,"docString":"If a function converges to a nonzero value, its inverse converges to the inverse of this value.\nWe use the name `Filter.Tendsto.inv‚ÇÄ` as `Filter.Tendsto.inv` is already used in multiplicative\ntopological groups. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (Cf : ContinuousAt f (inf‚Çõ s)) (Mf : Monotone f) (ftop : f ‚ä§ = ‚ä§), f (inf‚Çõ s) = inf‚Çõ (f '' s)","name":"Monotone.map_inf‚Çõ_of_continuousAt","isProp":true,"docString":"A monotone function `f` sending `top` to `top` and continuous at the infimum of a set sends\nthis infimum to the infimum of the image of this set. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (x : Œ± 0) (p : (i : Fin n) ‚Üí Œ± (Fin.succ i)) (i : Fin n)\n  (y : Œ± (Fin.succ i)), Fin.cons x (Function.update p i y) = Function.update (Fin.cons x p) (Fin.succ i) y","name":"Fin.cons_update","isProp":true,"docString":"Updating a tuple and adding an element at the beginning commute. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P), ‚Üë(affineSpan k {p}) = {p}","name":"AffineSubspace.coe_affineSpan_singleton","isProp":true,"docString":"The affine span of a single point, coerced to a set, contains just that point. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±} [inst_1 : Fintype Œπ]\n  (hfg : Antivary f g),\n  (‚Üë(Fintype.card Œπ) * Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i) ‚â§\n    (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i) * Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ g i","name":"Antivary.card_mul_sum_le_sum_mul_sum","isProp":true,"docString":"**Chebyshev's Sum Inequality**: When `f` and `g` antivary together (eg one is monotone, the\nother is antitone), the product of their sum is less than the size of the set times their scalar\nproduct. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] (P : Submonoid M),\n  (Submonoid.Fg P : Prop) ‚Üî (‚àÉ (S : Set M), (Submonoid.closure S = P : Prop) ‚àß (Set.Finite S : Prop) : Prop)","name":"Submonoid.fg_iff","isProp":true,"docString":"An equivalent expression of `Submonoid.Fg` in terms of `Set.Finite` instead of `Finset`. "},{"type":"‚àÄ (f : CircleDeg1Lift) (hf : Continuous ‚Üëf), ‚àÉ (x : ‚Ñù), ‚Üëf x = x + CircleDeg1Lift.translationNumber f","name":"CircleDeg1Lift.exists_eq_add_translationNumber","isProp":true,"docString":"If `f` is a continuous monotone map `‚Ñù ‚Üí ‚Ñù`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + œÑ f`. "},{"type":"‚àÄ {I : Type u} {f : (a : I) ‚Üí Type v} [inst : DecidableEq I] [inst_1 : (i : I) ‚Üí AddZeroClass (f i)],\n  Pairwise fun (i : I) (j : I) ‚Ü¶ ‚àÄ (x : f i) (y : f j), AddCommute (Pi.single i x) (Pi.single j y)","name":"Pi.single_commute","isProp":true,"docString":"The injection into an additive pi group at different indices commutes.\n\nFor injections of commuting elements at the same index, see `AddCommute.map`"},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : SMul R M] (self : SubMulAction R M) (c : R) {x : M}\n  (a : x ‚àà SubMulAction.carrier self), c ‚Ä¢ x ‚àà SubMulAction.carrier self","name":"SubMulAction.smul_mem'","isProp":true,"docString":"The carrier set is closed under scalar multiplication. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] [inst_3 : T2Space G]\n  (K : TopologicalSpace.PositiveCompacts G), LocallyCompactSpace G","name":"TopologicalSpace.PositiveCompacts.locallyCompactSpace_of_AddGroup","isProp":true,"docString":"Every separated topological group in which there exists a compact set with nonempty\ninterior is locally compact."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasStrongEpiMonoFactorisations C","name":"CategoryTheory.Abelian.instHasStrongEpiMonoFactorisations","isProp":true,"docString":"An abelian category has strong epi-mono factorisations. "},{"type":"‚àÄ {Œπ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : (a : Œπ) ‚Üí Set X}\n  (uo : ‚àÄ (i : Œπ), IsOpen (u i)) (uf : ‚àÄ (x : X), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ x ‚àà u i))\n  (uU : (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ u i) = Set.univ),\n  ‚àÉ (v : (a : Œπ) ‚Üí Set X),\n    (Set.union·µ¢ v = Set.univ : Prop) ‚àß\n      ((‚àÄ (i : Œπ), IsOpen (v i) : Prop) ‚àß (‚àÄ (i : Œπ), closure (v i) ‚äÜ u i : Prop) : Prop)","name":"exists_union·µ¢_eq_closure_subset","isProp":true,"docString":"Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new open cover so that the closure of each new open set is contained in the corresponding\noriginal open set. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {R : D ‚•§ C} (adj : L ‚ä£ R), CategoryTheory.Functor.Final R","name":"CategoryTheory.Functor.final_of_adjunction","isProp":true,"docString":"If a functor `R : D ‚•§ C` is a right adjoint, it is final. "},{"type":"‚àÄ {Œ± : Type u_4} {M : Type u_1} {N : Type u_2} {P : Type u_3} [inst : Zero M] [inst_1 : AddCommMonoid N]\n  [inst_2 : AddCommMonoid P] (h : N ‚Üí+ P) (f : Œ± ‚Üí‚ÇÄ M) (g : (a : Œ±) ‚Üí (a : M) ‚Üí N),\n  ‚Üëh (Finsupp.sum f g) = Finsupp.sum f fun (a : Œ±) (b : M) ‚Ü¶ ‚Üëh (g a b)","name":"AddMonoidHom.map_finsupp_sum","isProp":true,"docString":"Deprecated, use `_root_.map_finsupp_sum` instead."},{"type":"‚àÄ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\n  [inst_3 : TopologicalSpace.FirstCountableTopology G],\n  ‚àÉ (u : (a : ‚Ñï) ‚Üí Set G), (Filter.HasAntitoneBasis (nhds 1) u : Prop) ‚àß (‚àÄ (n : ‚Ñï), u (n + 1) * u (n + 1) ‚äÜ u n : Prop)","name":"TopologicalGroup.exists_antitone_basis_nhds_one","isProp":true,"docString":"Any first countable topological group has an antitone neighborhood basis `u : ‚Ñï ‚Üí Set G` for\nwhich `(u (n + 1)) ^ 2 ‚äÜ u n`. The existence of such a neighborhood basis is a key tool for\n`QuotientGroup.completeSpace` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : ¬¨(a < b : Prop)),\n  Multiset.Ico a b = 0","name":"Multiset.Ico_eq_zero","isProp":true,"docString":"**Alias** of the reverse direction of `Multiset.Ico_eq_zero_iff`."},{"type":"‚àÄ (self : ‚Ñö), Nat.coprime (Int.natAbs (Rat.num self)) (Rat.den self)","name":"Rat.reduced","isProp":true,"docString":"The numerator and denominator are coprime: it is in \"reduced form\". "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : D ‚•§ C} (self : F ‚ä£ G) {X : C} {Y : D} {f : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X ‚ü∂ Y},\n  ‚Üë(CategoryTheory.Adjunction.homEquiv self X Y) f =\n    (CategoryTheory.Adjunction.unit self).app X ‚â´ Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) f","name":"CategoryTheory.Adjunction.homEquiv_unit","isProp":true,"docString":"Naturality of the unit of an adjunction "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (H : WellFounded r) (s : Set Œ±) (a : Set.Nonempty s),\n  ‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (‚àÄ (x : Œ±) (a_1 : x ‚àà s), ¬¨(r x a : Prop) : Prop)","name":"WellFounded.has_min","isProp":true,"docString":"If `r` is a well-founded relation, then any nonempty set has a minimal element\nwith respect to `r`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_4} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1) (b : P),\n  ‚Üë(Finset.affineCombination k s p) w = ‚Üë(Finset.weightedVSubOfPoint s p b) w +·µ• b","name":"Finset.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one","isProp":true,"docString":"`affineCombination` gives the sum with any base point, when the\nsum of the weights is 1. "},{"type":"‚àÄ {M : Type u_1} {A : Type u_2} [inst : AddCommMonoid M] {s : Set M} (hs : IsAddSubmonoid s) (f : (a : A) ‚Üí M)\n  (t : Finset A) (a : ‚àÄ (b : A) (a : b ‚àà t), f b ‚àà s), (Finset.sum t fun (b : A) ‚Ü¶ f b) ‚àà s","name":"IsAddSubmonoid.finset_sum_mem","isProp":true,"docString":"The sum of elements of an `AddSubmonoid` of an `AddCommMonoid` indexed by\na `Finset` is an element of the `AddSubmonoid`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddZeroClass Œ±] [inst_1 : AddZeroClass Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddMonoidHom f)\n  (x : Œ±) (y : Œ±), f (x + y) = f x + f y","name":"IsAddMonoidHom.map_add'","isProp":true,"docString":"An additive monoid homomorphism preserves addition."},{"type":"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] (G : StructureGroupoid H) {M : Type u_2} [inst_1 : TopologicalSpace M]\n  [inst_2 : ChartedSpace H M] [inst_3 : HasGroupoid M G] {e : LocalHomeomorph M H} {e' : LocalHomeomorph M H}\n  (he : e ‚àà atlas) (he' : e' ‚àà atlas), LocalHomeomorph.trans (LocalHomeomorph.symm e) e' ‚àà G","name":"StructureGroupoid.compatible","isProp":true,"docString":"Reformulate in the `StructureGroupoid` namespace the compatibility condition of charts in a\ncharted space admitting a structure groupoid, to make it more easily accessible with dot\nnotation. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {s : Set Œ±}\n  (ha : IsGLB s a) (hs : Set.Nonempty s) (sc : IsClosed s), a ‚àà s","name":"IsClosed.isGLB_mem","isProp":true,"docString":"**Alias** of `IsGLB.mem_of_isClosed`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ±) ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : ContinuousAt f x),\n  ContinuousAt (fun (a : Œ±) ‚Ü¶ Prod.fst (f a)) x","name":"ContinuousAt.fst","isProp":true,"docString":"Postcomposing `f` with `Prod.fst` is continuous at `x` "},{"type":"‚àÄ {Œ± : Type u} (s : Stream'.Seq Œ±) {m : ‚Ñï} {n : ‚Ñï} (a : m ‚â§ n) (a : Stream'.Seq.TerminatedAt s m),\n  Stream'.Seq.TerminatedAt s n","name":"Stream'.Seq.terminated_stable","isProp":true,"docString":"If a sequence terminated at position `n`, it also terminated at `m ‚â• n `. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] (c : Set (Ideal R)) (hs : c ‚äÜ nonPrincipals R)\n  (hchain : IsChain (fun (x : Ideal R) (x_1 : Ideal R) ‚Ü¶ x ‚â§ x_1) c) {K : Ideal R} (hKmem : K ‚àà c),\n  ‚àÉ (I : Ideal R), (I ‚àà nonPrincipals R : Prop) ‚àß (‚àÄ (J : Ideal R) (a : J ‚àà c), J ‚â§ I : Prop)","name":"nonPrincipals_zorn","isProp":true,"docString":"Any chain in the set of non-principal ideals has an upper bound which is non-principal.\n(Namely, the union of the chain is such an upper bound.)\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SemilatticeInf Œ±] [inst_1 : OrderBot Œ±] [inst_2 : SemilatticeInf Œ≤]\n  [inst_3 : OrderBot Œ≤] {a : Œ±} {b : Œ±} (f : Œ± ‚âÉo Œ≤) (ha : Disjoint a b), Disjoint (‚Üëf a) (‚Üëf b)","name":"Disjoint.map_orderIso","isProp":true,"docString":"Note that this goal could also be stated `(Disjoint on f) a b` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalNonAssocRing Œ±] (k : Œ±) (h : ‚àÄ (x : Œ±) (a : x * k = 0), x = 0), IsRightRegular k","name":"isRightRegular_of_non_zero_divisor","isProp":true,"docString":"Right `Mul` by a `k : Œ±` over `[Ring Œ±]` is injective, if `k` is not a zero divisor.\nThe typeclass that restricts all terms of `Œ±` to have this property is `NoZeroDivisors`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (-a < 0 : Prop) ‚Üî (0 < a : Prop)","name":"Right.neg_neg_iff","isProp":true,"docString":"Uses `right` co(ntra)variant."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l],\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atBot : Prop) ‚Üî\n    (((0 < r : Prop) ‚àß (Filter.Tendsto f l Filter.atBot : Prop) : Prop) ‚à®\n        ((r < 0 : Prop) ‚àß (Filter.Tendsto f l Filter.atTop : Prop) : Prop) :\n      Prop)","name":"Filter.tendsto_mul_const_atBot_iff","isProp":true,"docString":"The function `Œª x, f x * r` tends to negative infinity along a nontrivial filter if and only if\n`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D) {A : C}\n  {A' : C} {B : C} {B' : C} [inst_2 : CategoryTheory.Limits.HasBinaryProduct A B]\n  [inst_3 : CategoryTheory.Limits.HasBinaryProduct A' B']\n  [inst_4 :\n    CategoryTheory.Limits.HasBinaryProduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) A)\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) B)]\n  [inst_5 :\n    CategoryTheory.Limits.HasBinaryProduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) A')\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) B')]\n  (f : A ‚ü∂ A') (g : B ‚ü∂ B') [inst_6 : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A B)]\n  [inst_7 : CategoryTheory.IsIso (CategoryTheory.Limits.prodComparison F A' B')],\n  CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A B) ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.Limits.prod.map f g) =\n    CategoryTheory.Limits.prod.map (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)\n        (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) g) ‚â´\n      CategoryTheory.inv (CategoryTheory.Limits.prodComparison F A' B')","name":"CategoryTheory.Limits.prodComparison_inv_natural","isProp":true,"docString":"If the product comparison morphism is an iso, its inverse is natural. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (self : GroupSeminorm G) (x : G),\n  GroupSeminorm.toFun self x‚Åª¬π = GroupSeminorm.toFun self x","name":"GroupSeminorm.inv'","isProp":true,"docString":"The seminorm is invariant under inversion. "},{"type":"‚àÄ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S} {x : M}\n  {y : M} (hx : x ‚àà H) (hy : y ‚àà H), x / y ‚àà H","name":"div_mem","isProp":true,"docString":"A subgroup is closed under division. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {S : Set M} {x : M}\n  (hx : x ‚àà Submodule.span R S), ‚àÉ (T : Finset M), (‚ÜëT ‚äÜ S : Prop) ‚àß (x ‚àà Submodule.span R ‚ÜëT : Prop)","name":"Submodule.mem_span_finite_of_mem_span","isProp":true,"docString":"For every element in the span of a set, there exists a finite subset of the set\nsuch that the element is contained in the span of the subset. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_4} {F : Type u_1} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : AddCommMonoid F] [inst_3 : OrderedAddCommMonoid Œ≤] [inst_4 : Module ùïú E] [inst_5 : Module ùïú F]\n  [inst_6 : SMul ùïú Œ≤] {f : (a : F) ‚Üí Œ≤} {s : Set F} (hf : ConcaveOn ùïú s f) (g : E ‚Üí‚Çó[ùïú] F),\n  ConcaveOn ùïú (‚Üëg ‚Åª¬π' s) (f ‚àò ‚Üëg)","name":"ConcaveOn.comp_linearMap","isProp":true,"docString":"If `g` is concave on `s`, so is `(g ‚àò f)` on `f ‚Åª¬π' s` for a linear `f`. "},{"type":"‚àÄ (n : ‚Ñï), (Nat.factorization n = 0 : Prop) ‚Üî ((n = 0 : Prop) ‚à® (n = 1 : Prop) : Prop)","name":"Nat.factorization_eq_zero_iff'","isProp":true,"docString":"The only numbers with empty prime factorization are `0` and `1` "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : TopologicalSpace R] [inst_1 : TopologicalSpace M] [inst_2 : Semiring R]\n  [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module R·µê·µí·µñ M] [inst_6 : TopologicalSemiring R]\n  [inst_7 : ContinuousAdd M] [inst_8 : ContinuousSMul R M] [inst_9 : ContinuousSMul R·µê·µí·µñ M],\n  TopologicalSemiring (TrivSqZeroExt R M)","name":"TrivSqZeroExt.topologicalSemiring","isProp":true,"docString":"This is not an instance due to complaints by the `fails_quickly` linter. At any rate, we only\nreally care about the `TopologicalRing` instance below. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : SMul ùïú E] {A : Set E}\n  {x : E}, (x ‚àà Set.extremePoints ùïú A : Prop) ‚Üî (IsExtreme ùïú A {x} : Prop)","name":"mem_extremePoints_iff_extreme_singleton","isProp":true,"docString":"x is an extreme point to A iff {x} is an extreme set of A. "},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï}, padicValInt p ‚Üën = padicValNat p n","name":"padicValInt.of_nat","isProp":true,"docString":"The `p`-adic value of a natural is its `p`-adic value as an integer. "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [self : CommGroupWithZero G‚ÇÄ] (a : G‚ÇÄ) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"CommGroupWithZero.mul_inv_cancel","isProp":true,"docString":"Every nonzero element of a group with zero is invertible. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [self : TopologicalSpace.SecondCountableTopology Œ±],\n  ‚àÉ (b : Set (Set Œ±)), (Set.Countable b : Prop) ‚àß (t = TopologicalSpace.generateFrom b : Prop)","name":"TopologicalSpace.SecondCountableTopology.is_open_generated_countable","isProp":true,"docString":"There exists a countable set of sets that generates the topology. "},{"type":"‚àÄ {M : Type u} [self : AddLeftCancelMonoid M] (a : M), a + 0 = a","name":"AddLeftCancelMonoid.add_zero","isProp":true,"docString":"Zero is a right neutral element for addition "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.IsIso f],\n  CategoryTheory.IsIso (Quiver.Hom.op f)","name":"CategoryTheory.isIso_op","isProp":true,"docString":"If `f` is an isomorphism, so is `f.op` "},{"type":"‚àÄ {E : Type u_3} {Œπ : Type u_1} {ùïù : Type u_2} [inst : NontriviallyNormedField ùïù] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïù E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul ùïù E] {Œµ : (a : Œπ) ‚Üí ùïù} {l : Filter Œπ}\n  [inst_5 : Filter.NeBot l] (hŒµ : Filter.Tendsto Œµ l (nhdsWithin 0 ({0}·∂ú))) {S : Set E},\n  (Bornology.IsVonNBounded ùïù S : Prop) ‚Üî\n    (‚àÄ (x : (a : Œπ) ‚Üí E) (a : ‚àÄ (n : Œπ), x n ‚àà S), Filter.Tendsto (Œµ ‚Ä¢ x) l (nhds 0) : Prop)","name":"Bornology.isVonNBounded_iff_smul_tendsto_zero","isProp":true,"docString":"Given any sequence `Œµ` of scalars which tends to `ùìù[‚â†] 0`, we have that a set `S` is bounded\nif and only if for any sequence `x : ‚Ñï ‚Üí S`, `Œµ ‚Ä¢ x` tends to 0. This actually works for any\nindexing type `Œπ`, but in the special case `Œπ = ‚Ñï` we get the important fact that convergent\nsequences fully characterize bounded sets. "},{"type":"‚àÄ (k : Type u_2) [inst : DivisionRing k] {Œπ : Type u_1} (s : Finset Œπ) [inst_1 : Fintype Œπ],\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ Finset.centroidWeightsIndicator k s i) =\n    Finset.sum s fun (i : Œπ) ‚Ü¶ Finset.centroidWeights k s i","name":"Finset.sum_centroidWeightsIndicator","isProp":true,"docString":"The sum of the weights for the centroid indexed by a `Fintype`. "},{"type":"‚àÄ {Œ≤ : Type u_1} {f : (a : Œ≤) ‚Üí NNReal} {g : (a : Œ≤) ‚Üí NNReal} {r : NNReal} (hgf : ‚àÄ (b : Œ≤), g b ‚â§ f b)\n  (hfr : HasSum f r), ‚àÉ (p : NNReal), (p ‚â§ r : Prop) ‚àß (HasSum g p : Prop)","name":"NNReal.exists_le_hasSum_of_le","isProp":true,"docString":"Comparison test of convergence of `‚Ñù‚â•0`-valued series. "},{"type":"‚àÄ {F : Sort u_1} {Œ± : outParam (Sort u_2)} {Œ≤ : outParam (Sort u_3)} [self : EmbeddingLike F Œ± Œ≤] (f : F),\n  Function.Injective ‚Üëf","name":"EmbeddingLike.injective'","isProp":true,"docString":"The coercion to functions must produce injective functions. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {a : R} {b : R} (h : a * b = 1), IsRightRegular a","name":"isRightRegular_of_mul_eq_one","isProp":true,"docString":"An element admitting a right inverse is right-regular. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí SeminormedAddGroup (œÄ i)]\n  (f : (i : Œπ) ‚Üí œÄ i), (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ ‚Äñf i‚Äñ‚Çä) ‚â§ Fintype.card Œπ ‚Ä¢ ‚Äñf‚Äñ‚Çä","name":"Pi.sum_nnnorm_apply_le_nnnorm","isProp":true,"docString":"The $L^1$ norm is less than the $L^\\infty$ norm\nscaled by the cardinality."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ±}\n  (Hf : AntitoneOn f t) (Hst : s ‚äÜ t) (a : Set.Nonempty (upperBounds s ‚à© t)), BddBelow (f '' s)","name":"AntitoneOn.map_bddAbove","isProp":true,"docString":"The image under an antitone function of a set which is bounded above is bounded below. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [inst : SeminormedAddGroup E]\n  [inst_1 : SeminormedAddGroup F] [inst_2 : SeminormedAddGroup G] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F} {l : Filter Œ±}\n  (hf : Filter.Tendsto f l (nhds 0)) (hg : Filter.IsBoundedUnder (fun (x : ‚Ñù) (x_1 : ‚Ñù) ‚Ü¶ x ‚â§ x_1) l (norm ‚àò g))\n  (op : (a : E) ‚Üí (a : F) ‚Üí G) (h_op : ‚àÉ (A : ‚Ñù), ‚àÄ (x : E) (y : F), ‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ op (f x) (g x)) l (nhds 0)","name":"Filter.Tendsto.op_zero_isBoundedUnder_le'","isProp":true,"docString":"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ` for some constant A instead\nof multiplication so that it can be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`."},{"type":"‚àÄ (Œ≤ : Type) (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasCoproducts C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C], CategoryTheory.Faithful (CategoryTheory.GradedObject.total Œ≤ C)","name":"CategoryTheory.GradedObject.instFaithfulGradedObjectCategoryOfGradedObjectsTotalType","isProp":true,"docString":"The `total` functor taking a graded object to the coproduct of its graded components is faithful.\nTo prove this, we need to know that the coprojections into the coproduct are monomorphisms,\nwhich follows from the fact we have zero morphisms and decidable equality for the grading.\n"},{"type":"‚àÄ {Œ≤ : Type v} [inst : UniformSpace Œ≤] {Œ± : Type u_1} {f : (a : Œ±) ‚Üí Œ≤} {s : Set (Œ≤ √ó Œ≤)} (hs : s ‚àà uniformity Œ≤)\n  (hf : Pairwise fun (x : Œ±) (y : Œ±) ‚Ü¶ ¬¨((f x, f y) ‚àà s : Prop)), UniformEmbedding f","name":"uniformEmbedding_of_spaced_out","isProp":true,"docString":"If a map `f : Œ± ‚Üí Œ≤` sends any two distinct points to point that are **not** related by a fixed\n`s ‚àà ùì§ Œ≤`, then `f` is a uniform embedding with respect to the discrete uniformity on `Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hst : Disjoint s t)\n  (hs : Set.Finite (s ‚à© Function.mulSupport f)) (ht : Set.Finite (t ‚à© Function.mulSupport f)),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) =\n    (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà t) ‚Ü¶ f i","name":"finprod_mem_union'","isProp":true,"docString":"A more general version of `finprod_mem_union` that requires `s ‚à© mulSupport f` and\n`t ‚à© mulSupport f` rather than `s` and `t` to be finite. "},{"type":"‚àÄ (M : Type u_3) (Œ± : Type u_2) [inst : Monoid M] [inst_1 : MulAction M Œ±] {Œπ : Sort u_1} {s : (a : Œπ) ‚Üí Set Œ±},\n  fixingSubmonoid M (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ s i) = inf·µ¢ fun (i : Œπ) ‚Ü¶ fixingSubmonoid M (s i)","name":"fixingSubmonoid_union·µ¢","isProp":true,"docString":"Fixing submonoid of union·µ¢ is intersection "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {l : Filter Œ±} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} (h : Filter.HasBasis l p s)\n  {q : (a : Œπ) ‚Üí Prop} (hq : ‚àÄ (i : Œπ) (a : p i), ‚àÉ (j : Œπ), (p j : Prop) ‚àß ((q j : Prop) ‚àß (s j ‚äÜ s i : Prop) : Prop)),\n  Filter.HasBasis l (fun (i : Œπ) ‚Ü¶ (p i : Prop) ‚àß (q i : Prop)) s","name":"Filter.HasBasis.restrict","isProp":true,"docString":"If `{s i | p i}` is a basis of a filter `l` and each `s i` includes `s j` such that\n`p j ‚àß q j`, then `{s j | p j ‚àß q j}` is a basis of `l`. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCommGroup Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"LinearOrderedCommGroup.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {C : Type u} [ùíû : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)\n  [inst : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)]\n  [inst :\n    CategoryTheory.Limits.HasLimit\n      (CategoryTheory.Limits.parallelPair (CategoryTheory.Limits.prod.fst ‚â´ f) (CategoryTheory.Limits.prod.snd ‚â´ g))],\n  CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)","name":"CategoryTheory.Limits.hasLimit_cospan_of_hasLimit_pair_of_hasLimit_parallelPair","isProp":true,"docString":"If the product `X ‚®Ø Y` and the equalizer of `œÄ‚ÇÅ ‚â´ f` and `œÄ‚ÇÇ ‚â´ g` exist, then the\npullback of `f` and `g` exists: It is given by composing the equalizer with the projections. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {x‚ÇÄ : Œ±} {K : Set Œ≤}\n  (hK : IsCompact K) {P : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop}\n  (hP : ‚àÄ (y : Œ≤) (a : y ‚àà K), Filter.Eventually (fun (z : Œ± √ó Œ≤) ‚Ü¶ P (Prod.fst z) (Prod.snd z)) (nhds (x‚ÇÄ, y))),\n  Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚àÄ (y : Œ≤) (a : y ‚àà K), P x y) (nhds x‚ÇÄ)","name":"IsCompact.eventually_forall_of_forall_eventually","isProp":true,"docString":"To show that `‚àÄ y ‚àà K, P x y` holds for `x` close enough to `x‚ÇÄ` when `K` is compact,\nit is sufficient to show that for all `y‚ÇÄ ‚àà K` there `P x y` holds for `(x, y)` close enough\nto `(x‚ÇÄ, y‚ÇÄ)`.\n"},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {t : Set P} (ha : AffineIndependent k fun (x : ‚Üët) ‚Ü¶ ‚Üëx) (hs : s ‚äÜ t),\n  AffineIndependent k fun (x : ‚Üës) ‚Ü¶ ‚Üëx","name":"AffineIndependent.mono","isProp":true,"docString":"If a set of points is affinely independent, so is any subset. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G} (self : IsNormalSubgroup s) (n : G) (a : n ‚àà s) (g : G), g * n * g‚Åª¬π ‚àà s","name":"IsNormalSubgroup.normal","isProp":true,"docString":"The proposition that `s` is closed under conjugation. "},{"type":"‚àÄ {a : ENNReal}, a - ‚ä§ = 0","name":"ENNReal.sub_top","isProp":true,"docString":"This is a special case of `WithTop.sub_top` in the `ENNReal` namespace "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] {f : R ‚âÉ+* S}\n  {g : R ‚âÉ+* S} (h : ‚àÄ (x : R), ‚Üëf x = ‚Üëg x), f = g","name":"RingEquiv.ext","isProp":true,"docString":"Two ring isomorphisms agree if they are defined by the\nsame underlying function. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictMono f) (hg : StrictMono g), StrictMono fun (x : Œ≤) ‚Ü¶ f x + g x","name":"StrictMono.add","isProp":true,"docString":"The sum of two strictly monotone functions is strictly monotone."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : (a : Œ±) ‚Üí Œ≤) (g : (a : Œ≤) ‚Üí Œ±),\n  Set.InvOn f g (Function.fixedPoints (f ‚àò g)) (Function.fixedPoints (g ‚àò f))","name":"Function.invOn_fixedPoints_comp","isProp":true,"docString":"Any two maps `f : Œ± ‚Üí Œ≤` and `g : Œ≤ ‚Üí Œ±` are inverse of each other on the sets of fixed points\nof `f ‚àò g` and `g ‚àò f`, respectively. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : CommMonoid M] {s : Set Œ±} {t : Set Œ≤} (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí M)\n  (hs : Set.Finite s) (ht : Set.Finite t),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ finprod fun (j : Œ≤) ‚Ü¶ finprod fun (h : j ‚àà t) ‚Ü¶ f i j) =\n    finprod fun (j : Œ≤) ‚Ü¶ finprod fun (h : j ‚àà t) ‚Ü¶ finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i j","name":"finprod_mem_comm","isProp":true,"docString":"If `s : Set Œ±` and `t : Set Œ≤` are finite sets, then taking the product over `s` commutes with\ntaking the product over `t`. "},{"type":"‚àÄ {c : (a : Type u) ‚Üí Type u} {hom : ‚¶ÉŒ± : Type u‚¶Ñ ‚Üí ‚¶ÉŒ≤ : Type u‚¶Ñ ‚Üí (x : c Œ±) ‚Üí (x : c Œ≤) ‚Üí Type u}\n  (self : CategoryTheory.BundledHom hom) {Œ± : Type u} (I : c Œ±),\n  CategoryTheory.BundledHom.toFun self I I (CategoryTheory.BundledHom.id self I) = id","name":"CategoryTheory.BundledHom.id_toFun","isProp":true,"docString":"compatibility with identities "},{"type":"‚àÄ {Œ± : Type u_3} {Œ±' : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_2} {Œ¥ : Type u_1} [inst : DecidableEq Œ±']\n  [inst_1 : DecidableEq Œ≥] [inst_2 : DecidableEq Œ¥] {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Finset Œ±} {t : Finset Œ≤}\n  {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ≤) ‚Üí (a : Œ±') ‚Üí Œ¥} {g' : (a : Œ±) ‚Üí Œ±'}\n  (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' b (g' a)),\n  Finset.image g (Finset.image‚ÇÇ f s t) = Finset.image‚ÇÇ f' t (Finset.image g' s)","name":"Finset.image_image‚ÇÇ_antidistrib_right","isProp":true,"docString":"Symmetric statement to `Finset.image_image‚ÇÇ_right_anticomm`. "},{"type":"‚àÄ {R' : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : NonAssocSemiring R'] [inst_1 : SMul Œ± Œ≤] [inst_2 : SMul R' Œ±]\n  [inst_3 : SMul R' Œ≤] [inst_4 : IsScalarTower R' Œ± Œ≤] (S : Subsemiring R'), IsScalarTower { x : R' // x ‚àà S } Œ± Œ≤","name":"Subsemiring.isScalarTower","isProp":true,"docString":"Note that this provides `IsScalarTower S R R` which is needed by `smul_mul_assoc`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Countable s), Cardinal.mk ‚Üës ‚â§ Cardinal.aleph0","name":"Set.Countable.le_aleph0","isProp":true,"docString":"**Alias** of the reverse direction of `Cardinal.le_aleph0_iff_set_countable`."},{"type":"‚àÄ {Œ± : Type u} [self : OrderedRing Œ±], 0 ‚â§ 1","name":"OrderedRing.zero_le_one","isProp":true,"docString":"`0 ‚â§ 1` in any ordered ring. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s) {a : ùïú} {b : ùïú} (ha : 0 < a) (hb : 0 ‚â§ b) (hab : a + b = 1), a ‚Ä¢ interior s + b ‚Ä¢ s ‚äÜ interior s","name":"Convex.combo_interior_self_subset_interior","isProp":true,"docString":"If `s` is a convex set, then `a ‚Ä¢ interior s + b ‚Ä¢ s ‚äÜ interior s` for all `0 < a`, `0 ‚â§ b`,\n`a + b = 1`. See also `Convex.combo_interior_closure_subset_interior` for a stronger version. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {p : Polynomial R} (r : R), Polynomial.eval r (p * (Polynomial.X - ‚ÜëPolynomial.C r)) = 0","name":"Polynomial.eval_mul_X_sub_C","isProp":true,"docString":"The evaluation map is not generally multiplicative when the coefficient ring is noncommutative,\nbut nevertheless any polynomial of the form `p * (X - monomial 0 r)` is sent to zero\nwhen evaluated at `r`.\n\nThis is the key step in our proof of the Cayley-Hamilton theorem.\n"},{"type":"‚àÄ (n : ‚Ñï) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {b : ‚Ñ§} (hb : b ‚â† 0) (A : (a : Fin n) ‚Üí ‚Ñ§),\n  ‚àÉ (t : (a : Fin n) ‚Üí Fin ‚åà1 / Œµ‚åâ‚Çä),\n    ‚àÄ (i‚ÇÄ : Fin n) (i‚ÇÅ : Fin n) (a : t i‚ÇÄ = t i‚ÇÅ), ‚Üë(abs (A i‚ÇÅ % b - A i‚ÇÄ % b)) < abs b ‚Ä¢ Œµ","name":"AbsoluteValue.exists_partition_int","isProp":true,"docString":"We can partition a finite family into `partition_card Œµ` sets, such that the remainders\nin each set are close together. "},{"type":"‚àÄ {R : Type u_2} {G : Type u_1} [inst : CommGroup G] [inst_1 : CommRing R] [inst_2 : Nontrivial R],\n  (Algebra.FiniteType R (MonoidAlgebra R G) : Prop) ‚Üî (Group.Fg G : Prop)","name":"MonoidAlgebra.finiteType_iff_group_fg","isProp":true,"docString":"A group `G` is finitely generated if and only if `AddMonoidAlgebra R G` is of finite type. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} {g : (a : E) ‚Üí Œ≤} (hf : StrictConcaveOn ùïú s f) (hg : StrictConcaveOn ùïú s g),\n  StrictConcaveOn ùïú s (f ‚äì g)","name":"StrictConcaveOn.inf","isProp":true,"docString":"The pointwise minimum of strictly concave functions is strictly concave. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {r : (a : M) ‚Üí (a : M) ‚Üí Prop} {c : AddCon M}\n  (h : ‚àÄ (x : M) (y : M) (a : r x y), Setoid.r x y), addConGen r ‚â§ c","name":"AddCon.addConGen_le","isProp":true,"docString":"The smallest additive congruence relation containing a binary\nrelation `r` is contained in any additive congruence relation containing `r`."},{"type":"‚àÄ {v : Sat.Valuation} {a : Prop} {n : ‚Ñï} (h : (v n : Prop) ‚Üî (a : Prop)),\n  Sat.Literal.reify v (Sat.Literal.neg n) (a : Prop)","name":"Sat.Literal.reify_neg","isProp":true,"docString":"The reification of a negative literal `¬¨‚ü¶¬¨a‚üß_v ‚â° a`. "},{"type":"‚àÄ (V : Type u_2) {P : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : PseudoMetricSpace P]\n  [inst_2 : NormedAddTorsor V P] (x : P) (y : P), dist x y = ‚Äñy -·µ• x‚Äñ","name":"dist_eq_norm_vsub'","isProp":true,"docString":"The distance equals the norm of subtracting two points. In this\nlemma, it is necessary to have `V` as an explicit argument; otherwise\n`rw dist_eq_norm_vsub'` sometimes doesn't work. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : NormalSpace Œ±], NormalSpace (SeparationQuotient Œ±)","name":"SeparationQuotient.instNormalSpaceSeparationQuotientInstTopologicalSpaceSeparationQuotient","isProp":true,"docString":"The `SeparationQuotient` of a normal space is a T‚ÇÑ space. We don't have separate typeclasses\nfor normal spaces (without T‚ÇÅ assumption) and T‚ÇÑ spaces, so we use the same class for assumption\nand for conclusion.\n\nOne can prove this using a homeomorphism between `Œ±` and `SeparationQuotient Œ±`. We give an\nalternative proof that works without assuming that `Œ±` is a T‚ÇÅ space. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {m‚ÇÅ : (a : Œ±) ‚Üí Œ≤} {m‚ÇÇ : (a : Œ±) ‚Üí Œ≤} {f : Filter Œ±} (h : m‚ÇÅ =·∂†[f] m‚ÇÇ),\n  Filter.map m‚ÇÅ f = Filter.map m‚ÇÇ f","name":"Filter.map_congr","isProp":true,"docString":"If functions `m‚ÇÅ` and `m‚ÇÇ` are eventually equal at a filter `f`, then\nthey map this filter to the same filter. "},{"type":"‚àÄ {Œ± : Type u} [self : Rack Œ±] (x : Œ±), Function.LeftInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.left_inv","isProp":true,"docString":"Proof of left inverse "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±], TopologicalDivisionRing Œ±","name":"NormedDivisionRing.to_topologicalDivisionRing","isProp":true,"docString":"A normed division ring is a topological division ring. "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [self : CommGroupWithZero G‚ÇÄ], 0‚Åª¬π = 0","name":"CommGroupWithZero.inv_zero","isProp":true,"docString":"The inverse of `0` in a group with zero is `0`. "},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalCommSemiring Œ±] (a : Œ±) (b : Œ±), a * b = b * a","name":"NonUnitalCommSemiring.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  (Dense ‚Üës : Prop) ‚Üî (Submodule.topologicalClosure s = ‚ä§ : Prop)","name":"Submodule.dense_iff_topologicalClosure_eq_top","isProp":true,"docString":"A subspace is dense iff its topological closure is the entire space. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : LowerTopology Œ±]\n  [inst_3 : TopologicalSpace Œ≤] {f : (a : Œ≤) ‚Üí Œ±} (h : ‚àÄ (a : Œ±), IsClosed (f ‚Åª¬π' Set.Ici a)), Continuous f","name":"LowerTopology.continuous_of_Ici","isProp":true,"docString":"A function `f : Œ≤ ‚Üí Œ±` with lower topology in the codomain is continuous provided that the\npreimage of every interval `Set.Ici a` is a closed set.\n\nTODO: upgrade to an `iff`. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : PosMulMono Œ±] (ha : 0 ‚â§ a)\n  (hb : 0 ‚â§ b), 0 ‚â§ a * b","name":"Left.mul_nonneg","isProp":true,"docString":"Assumes left covariance. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Mul Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsMulHom f) (x : Œ±) (y : Œ±),\n  f (x * y) = f x * f y","name":"IsMulHom.map_mul","isProp":true,"docString":"The proposition that `f` preserves multiplication. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroClass M‚ÇÄ] [inst_1 : NoZeroDivisors M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ},\n  (a * b = 0 : Prop) ‚Üî ((a = 0 : Prop) ‚à® (b = 0 : Prop) : Prop)","name":"mul_eq_zero","isProp":true,"docString":"If `Œ±` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. "},{"type":"‚àÄ {R : Type w} [inst : Semiring R] {C : Type u} [inst_1 : CategoryTheory.Category C]\n  [inst_2 : CategoryTheory.Preadditive C] [self : CategoryTheory.Linear R C] (X : C) (Y : C) (Z : C) (f : X ‚ü∂ Y) (r : R)\n  (g : Y ‚ü∂ Z), f ‚â´ (r ‚Ä¢ g) = r ‚Ä¢ f ‚â´ g","name":"CategoryTheory.Linear.comp_smul","isProp":true,"docString":"compatibility of the scalar multiplication with the pre-composition "},{"type":"‚àÄ {X : Type u_2} {Y : Type u_1} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : UniformSpace Œ±] {A : Set Y} {u : (a : Y) ‚Üí (a : X) ‚Üí Œ±} (hA : Equicontinuous (u ‚àò Subtype.val))\n  (hu : Continuous u), Equicontinuous (u ‚àò Subtype.val)","name":"Equicontinuous.closure'","isProp":true,"docString":"A version of `Equicontinuous.closure` applicable to subsets of types which embed continuously\ninto `X ‚Üí Œ±` with the product topology. It turns out we don't need any other condition on the\nembedding than continuity, but in practice this will mostly be applied to `FunLike` types where\nthe coercion is injective. "},{"type":"‚àÄ {Œ± : Type uu} [M : AddMonoid Œ±] {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (h : l‚ÇÅ ~ l‚ÇÇ) (hc : List.Pairwise AddCommute l‚ÇÅ),\n  List.sum l‚ÇÅ = List.sum l‚ÇÇ","name":"List.Perm.sum_eq'","isProp":true,"docString":"If elements of a list additively commute with each other, then their sum does not\ndepend on the order of elements."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (self : SpectralMap Œ± Œ≤),\n  IsSpectralMap (SpectralMap.toFun self)","name":"SpectralMap.spectral'","isProp":true,"docString":"proof that `toFun` is a spectral map"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst : TopologicalSpace.SecondCountableTopology Œ±],\n  Set.Countable (setOf fun (x : Œ±) ‚Ü¶ ‚àÉ (y : Œ±), (x < y : Prop) ‚àß (Set.Ioo x y = ‚àÖ : Prop))","name":"countable_of_isolated_right'","isProp":true,"docString":"The set of points which are isolated on the right is countable when the space is\nsecond-countable. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] {W : C} {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Y) (g : Z ‚ü∂ W),\n  CategoryTheory.Limits.biprod.map f g ‚â´ CategoryTheory.Iso.hom (CategoryTheory.Limits.biprod.braiding Y W) =\n    CategoryTheory.Iso.hom (CategoryTheory.Limits.biprod.braiding X Z) ‚â´ CategoryTheory.Limits.biprod.map g f","name":"CategoryTheory.Limits.biprod.braid_natural","isProp":true,"docString":"The braiding isomorphism can be passed through a map by swapping the order. "},{"type":"‚àÄ {Œ± : Type u}, DenseRange pure","name":"denseRange_pure","isProp":true,"docString":"The range of `pure : Œ± ‚Üí Ultrafilter Œ±` is dense in `Ultrafilter Œ±`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : (a : ‚Ñï) ‚Üí Œ±},\n  (CauchySeq s : Prop) ‚Üî\n    (‚àÉ (b : (a : ‚Ñï) ‚Üí ‚Ñù),\n        (‚àÄ (n : ‚Ñï), 0 ‚â§ b n : Prop) ‚àß\n          ((‚àÄ (n : ‚Ñï) (m : ‚Ñï) (N : ‚Ñï) (a : N ‚â§ n) (a : N ‚â§ m), dist (s n) (s m) ‚â§ b N : Prop) ‚àß\n              (Filter.Tendsto b Filter.atTop (nhds 0) : Prop) :\n            Prop) :\n      Prop)","name":"cauchySeq_iff_le_tendsto_0","isProp":true,"docString":"Yet another metric characterization of Cauchy sequences on integers. This one is often the\nmost efficient. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C}\n  (self : CategoryTheory.SheafOfTypes J), CategoryTheory.Presieve.IsSheaf J (CategoryTheory.SheafOfTypes.val self)","name":"CategoryTheory.SheafOfTypes.cond","isProp":true,"docString":"the condition that the presheaf is a sheaf "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F}\n  {l : Filter Œ±}, (f =O[l] g : Prop) ‚Üî (‚àÉ (c : ‚Ñù), Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) l : Prop)","name":"Asymptotics.isBigO_iff","isProp":true,"docString":"Definition of `IsBigO` in terms of filters. "},{"type":"‚àÄ {a : Prop} {b : Prop} {p : (a : Prop) ‚Üí Prop} (h‚ÇÅ : (a : Prop) ‚Üî (b : Prop)) (h‚ÇÇ : p (a : Prop)), p (b : Prop)","name":"Iff.subst","isProp":true,"docString":"Iff can now be used to do substitutions in a calculation "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G) (x : G),\n  nhds ‚Üëx = Filter.map QuotientGroup.mk (nhds x)","name":"QuotientGroup.nhds_eq","isProp":true,"docString":"Neighborhoods in the quotient are precisely the map of neighborhoods in the prequotient. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SemilatticeInf Œ±] [inst_1 : OrderTop Œ±] {s : Finset Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {a : Œ±}\n  (a_1 : ‚àÄ (b : Œ≤) (a_1 : b ‚àà s), a ‚â§ f b), a ‚â§ Finset.inf s f","name":"Finset.le_inf","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.le_inf_iff`."},{"type":"‚àÄ {F : Type u_1} {ùïú : outParam (Type u_2)} {E : outParam (Type u_3)} [inst : SeminormedRing ùïú] [inst_1 : AddGroup E]\n  [inst_2 : SMul ùïú E] [self : SeminormClass F ùïú E] (f : F) (a : ùïú) (x : E), ‚Üëf (a ‚Ä¢ x) = ‚Äña‚Äñ * ‚Üëf x","name":"SeminormClass.map_smul_eq_mul","isProp":true,"docString":"The seminorm of a scalar multiplication is the product of the absolute value of the scalar\nand the original seminorm. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PartialOrder Œ±] {f : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Œ±}\n  (comm : ‚àÄ (a : Œ≤) (b : Œ≤), f a b ‚â§ f b a) (a : Œ≤) (b : Œ≤), f a b = f b a","name":"commutative_of_le","isProp":true,"docString":"To prove commutativity of a binary operation `‚óã`, we only to check `a ‚óã b ‚â§ b ‚óã a` for all `a`,\n`b`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±}\n  {b : Œ±} {c : Œ±} [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1],\n  a + b - c ‚â§ a + (b - c)","name":"add_tsub_le_assoc","isProp":true,"docString":"See `add_tsub_assoc_of_le` for the equality. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Sup Œ±] [inst_1 : Sup Œ≤] [inst_2 : Bot Œ±] [inst_3 : Bot Œ≤]\n  (self : SupBotHom Œ± Œ≤), SupHom.toFun (SupBotHom.toSupHom self) ‚ä• = ‚ä•","name":"SupBotHom.map_bot'","isProp":true,"docString":"A `SupBotHom` preserves the bottom element. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {‚Ñ¨ : Finset (Finset Œ±)} [inst_1 : Fintype Œ±]\n  (hùíú : IsUpperSet ‚Üëùíú) (h‚Ñ¨ : IsLowerSet ‚Üë‚Ñ¨), 2 ^ Fintype.card Œ± * Finset.card (ùíú ‚à© ‚Ñ¨) ‚â§ Finset.card ùíú * Finset.card ‚Ñ¨","name":"IsUpperSet.card_inter_le_finset","isProp":true,"docString":"**Harris-Kleitman inequality**: Upper sets and lower sets of finsets anticorrelate. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤},\n  ((¬¨(Monotone f : Prop) : Prop) ‚àß (¬¨(Antitone f : Prop) : Prop) : Prop) ‚Üî\n    (‚àÉ (a : Œ±),\n        ‚àÉ (b : Œ±),\n          ‚àÉ (c : Œ±),\n            (a ‚â§ b : Prop) ‚àß\n              ((b ‚â§ c : Prop) ‚àß\n                  (((f a < f b : Prop) ‚àß (f c < f b : Prop) : Prop) ‚à® ((f b < f a : Prop) ‚àß (f b < f c : Prop) : Prop) :\n                    Prop) :\n                Prop) :\n      Prop)","name":"not_monotone_not_antitone_iff_exists_le_le","isProp":true,"docString":"A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. "},{"type":"‚àÄ {Œπ : Type u_2} {œÄ : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)] [inst_1 : (i : Œπ) ‚Üí One (œÄ i)]\n  [inst_2 : DecidableEq Œπ] (i : Œπ), Continuous fun (x : œÄ i) ‚Ü¶ Pi.mulSingle i x","name":"continuous_mulSingle","isProp":true,"docString":"`Pi.mulSingle i x` is continuous in `x`. "},{"type":"‚àÄ {G : Type u} [inst : Group G] (H : Subgroup G) (h : Subsingleton (G ‚ß∏ H)), H = ‚ä§","name":"QuotientGroup.subgroup_eq_top_of_subsingleton","isProp":true,"docString":"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú} (hf : StrictConvexOn ùïú s f) {x : ùïú} {y : ùïú}\n  {z : ùïú} (hx : x ‚àà s) (hz : z ‚àà s) (hxy : x < y) (hyz : y < z), (f y - f x) / (y - x) < (f z - f y) / (z - y)","name":"StrictConvexOn.slope_strict_mono_adjacent","isProp":true,"docString":"If `f : ùïú ‚Üí ùïú` is strictly convex, then for any three points `x < y < z` the slope of the\nsecant line of `f` on `[x, y]` is strictly less than the slope of the secant line of `f` on\n`[x, z]`. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommRing R] {M : Type u_3} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : TopologicalSpace R] {B : (a : Œπ) ‚Üí Submodule R M} (self : SubmodulesBasis B) (i : Œπ) (j : Œπ),\n  ‚àÉ (k : Œπ), B k ‚â§ B i ‚äì B j","name":"SubmodulesBasis.inter","isProp":true,"docString":"Condition for `B` to be a filter basis on `M`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {K : Set Œ±} {U : Set Œ±} {V : Set Œ±} (hK : IsCompact K)\n  (hU : IsOpen U) (hV : IsOpen V) (h2K : K ‚äÜ U ‚à™ V),\n  ‚àÉ (K‚ÇÅ : Set Œ±),\n    ‚àÉ (K‚ÇÇ : Set Œ±),\n      (IsCompact K‚ÇÅ : Prop) ‚àß\n        ((IsCompact K‚ÇÇ : Prop) ‚àß ((K‚ÇÅ ‚äÜ U : Prop) ‚àß ((K‚ÇÇ ‚äÜ V : Prop) ‚àß (K = K‚ÇÅ ‚à™ K‚ÇÇ : Prop) : Prop) : Prop) : Prop)","name":"IsCompact.binary_compact_cover","isProp":true,"docString":"If a compact set is covered by two open sets, then we can cover it by two compact subsets. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} [inst : AddCommMonoid Œ±] {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≥) ‚Üí Œ±}\n  (h_eq :\n    ‚àÄ (u : Finset Œ≥),\n      ‚àÉ (v : Finset Œ≤),\n        ‚àÄ (v' : Finset Œ≤) (a : v ‚äÜ v'),\n          ‚àÉ (u' : Finset Œ≥),\n            (u ‚äÜ u' : Prop) ‚àß ((Finset.sum u' fun (x : Œ≥) ‚Ü¶ g x) = Finset.sum v' fun (b : Œ≤) ‚Ü¶ f b : Prop)),\n  Filter.map (fun (s : Finset Œ≤) ‚Ü¶ Finset.sum s fun (b : Œ≤) ‚Ü¶ f b) Filter.atTop ‚â§\n    Filter.map (fun (s : Finset Œ≥) ‚Ü¶ Finset.sum s fun (x : Œ≥) ‚Ü¶ g x) Filter.atTop","name":"Filter.map_atTop_finset_sum_le_of_sum_eq","isProp":true,"docString":"Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives\na sufficient condition for comparison of the filter `atTop.map (Œª s, ‚àë b in s, f b)` with\n`atTop.map (Œª s, ‚àë b in s, g b)`. This is useful to compare the set of limit points of\n`‚àë b in s, f b` as `s ‚Üí atTop` with the similar set for `g`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {f : X ‚ü∂ Y} [self : CategoryTheory.NormalMono f], f ‚â´ CategoryTheory.NormalMono.g = 0","name":"CategoryTheory.NormalMono.w","isProp":true,"docString":"A normal monomorphism is a morphism which is the kernel of some morphism. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : Norm E] {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù}\n  (a : f =O[l] fun (x : Œ±) ‚Ü¶ abs (u x)), f =O[l] u","name":"Asymptotics.IsBigO.of_abs_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigO_abs_right`."},{"type":"‚àÄ {K : Type u} {V : Type v} {V‚ÇÅ : Type v} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V‚ÇÅ] [inst_6 : Module K V‚ÇÅ]\n  [inst_7 : Module.Free K V‚ÇÅ], (Nonempty (V ‚âÉ‚Çó[K] V‚ÇÅ) : Prop) ‚Üî (Module.rank K V = Module.rank K V‚ÇÅ : Prop)","name":"LinearEquiv.nonempty_equiv_iff_rank_eq","isProp":true,"docString":"Two vector spaces are isomorphic if and only if they have the same dimension. "},{"type":"‚àÄ {Œ± : Type u_1} [self : HeytingAlgebra Œ±] (a : Œ±), a ‚á® ‚ä• = a·∂ú","name":"HeytingAlgebra.himp_bot","isProp":true,"docString":"`a ‚á®` is right adjoint to `a ‚äì` "},{"type":"‚àÄ {Œπ : Type u_2} {œÄ : (a : Œπ) ‚Üí Type u_3} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)] {X : Type u_1}\n  (f : (i : Œπ) ‚Üí (a : X) ‚Üí œÄ i), Inducing fun (x : X) (i : Œπ) ‚Ü¶ f i x","name":"inducing_inf·µ¢_to_pi","isProp":true,"docString":"Suppose `œÄ i` is a family of topological spaces indexed by `i : Œπ`, and `X` is a type\nendowed with a family of maps `f i : X ‚Üí œÄ i` for every `i : Œπ`, hence inducing a\nmap `g : X ‚Üí Œ† i, œÄ i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : Œπ` varies is simply the topology on `X` induced by `g : X ‚Üí Œ† i, œÄ i`\nwhere `Œ† i, œÄ i` is endowed with the usual product topology. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {rŒ≤ : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} (hŒ± : WellFounded rŒ±)\n  (hŒ≤ : WellFounded rŒ≤), WellFounded (Prod.GameAdd rŒ± rŒ≤)","name":"WellFounded.prod_gameAdd","isProp":true,"docString":"The `Prod.GameAdd` relation on well-founded inputs is well-founded.\n\nIn particular, the sum of two well-founded games is well-founded. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  [inst_2 : CategoryTheory.Limits.HasColimitsOfSize D] [inst_3 : CategoryTheory.CreatesColimitsOfSize F],\n  CategoryTheory.Limits.HasColimitsOfSize C","name":"CategoryTheory.has_colimits_of_has_colimits_creates_colimits","isProp":true,"docString":"If `F` creates colimits, and `D` has all colimits, then `C` has all colimits. "},{"type":"‚àÄ {R : Type u} {S : Type v} {F : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] [rc : RingHomClass F R S] (f : F)\n  {G : Type u_1} [rcg : RingHomClass G S R] (g : G) (I : Ideal S) (h : Function.LeftInverse ‚Üëg ‚Üëf),\n  Ideal.comap f I ‚â§ Ideal.map g I","name":"Ideal.comap_le_map_of_inverse","isProp":true,"docString":"The `Ideal` version of `Set.preimage_subset_image_of_inverse`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ico (f n) (f (Order.pred n)))","name":"Antitone.pairwise_disjoint_on_Ico_pred","isProp":true,"docString":"If `Œ±` is a linear pred order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is an antitone function, then\nthe intervals `Set.Ico (f n) (f (Order.pred n))` are pairwise disjoint. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Module.Ray R M), Quotient.mk (RayVector.Setoid R M) (Module.Ray.someRayVector x) = x","name":"Module.Ray.someRayVector_ray","isProp":true,"docString":"The ray of `someRayVector`. "},{"type":"‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Preadditive V]\n  {c : ComplexShape Œπ} {C : HomologicalComplex V c} {D : HomologicalComplex V c} {E : HomologicalComplex V c}\n  (f : C ‚ü∂ D) (hom : (i : Œπ) ‚Üí (j : Œπ) ‚Üí HomologicalComplex.X D i ‚ü∂ HomologicalComplex.X E j),\n  f ‚â´ Homotopy.nullHomotopicMap hom =\n    Homotopy.nullHomotopicMap fun (i : Œπ) (j : Œπ) ‚Ü¶ HomologicalComplex.Hom.f f i ‚â´ hom i j","name":"Homotopy.comp_nullHomotopicMap","isProp":true,"docString":"Compatibility of `nullHomotopicMap` with the precomposition by a morphism\nof complexes. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedAddMonoid Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"CanonicallyLinearOrderedAddMonoid.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : AddCommMonoid M] {g : (a : Œ≤) ‚Üí M} (e : (a : Œ±) ‚Üí Œ≤)\n  (he‚ÇÄ : Function.Bijective e), (finsum fun (i : Œ±) ‚Ü¶ g (e i)) = finsum fun (j : Œ≤) ‚Ü¶ g j","name":"finsum_comp","isProp":true,"docString":"See also `finsum_eq_of_bijective`, `Fintype.sum_bijective` and `Finset.sum_bij`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [t : TopologicalSpace Œ≤] [inst : PolishSpace Œ≤] (f : Œ± ‚âÉ Œ≤), PolishSpace Œ±","name":"Equiv.polishSpace_induced","isProp":true,"docString":"Pulling back a Polish topology under an equiv gives again a Polish topology. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : SeminormedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : SMul ùïú E] {x : E} {y : E}\n  {r : ‚Ñù} (p : Seminorm ùïú E), x +·µ• Seminorm.ball p y r = Seminorm.ball p (x +·µ• y) r","name":"Seminorm.vadd_ball","isProp":true,"docString":"The image of a ball under addition with a singleton is another ball. "},{"type":"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] {x : MvPolynomial œÉ R} {s : Set (œÉ ‚Üí‚ÇÄ ‚Ñï)},\n  (x ‚àà Ideal.span ((fun (s : œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Ü¶ ‚Üë(MvPolynomial.monomial s) 1) '' s) : Prop) ‚Üî\n    (‚àÄ (xi : œÉ ‚Üí‚ÇÄ ‚Ñï) (a : xi ‚àà MvPolynomial.support x), ‚àÉ (si : œÉ ‚Üí‚ÇÄ ‚Ñï), (si ‚àà s : Prop) ‚àß (si ‚â§ xi : Prop) : Prop)","name":"MvPolynomial.mem_ideal_span_monomial_image","isProp":true,"docString":"`x` is in a monomial ideal generated by `s` iff every element of of its support dominates one of\nthe generators. Note that `si ‚â§ xi` is analogous to saying that the monomial corresponding to `si`\ndivides the monomial corresponding to `xi`. "},{"type":"‚àÄ (Œ± : Type u) (Œ≤ : Type v) [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] [inst_2 : Fintype Œ±] [inst_3 : Fintype Œ≤]\n  [inst_4 : Fintype (Quotient (AddAction.orbitRel Œ± Œ≤))]\n  [inst_5 : (b : Œ≤) ‚Üí Fintype { x : Œ± // x ‚àà AddAction.stabilizer Œ± b }],\n  Fintype.card Œ≤ =\n    Finset.sum Finset.univ fun (œâ : Quotient (AddAction.orbitRel Œ± Œ≤)) ‚Ü¶\n      Fintype.card Œ± / Fintype.card { x : Œ± // x ‚àà AddAction.stabilizer Œ± (Quotient.out' œâ) }","name":"AddAction.card_eq_sum_card_addGroup_sub_card_stabilizer","isProp":true,"docString":"**Class formula** for a finite group acting on a finite type."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFiltered C] (O : Finset C),\n  ‚àÉ (S : C), ‚àÄ {X : C} (a : X ‚àà O), Nonempty (X ‚ü∂ S)","name":"CategoryTheory.IsFiltered.sup_objs_exists","isProp":true,"docString":"Any finite collection of objects in a filtered category has an object \"to the right\".\n"},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {op : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Œ≤} [hc : IsCommutative Œ≤ op] [ha : IsAssociative Œ≤ op]\n  {f : (a : Œ±) ‚Üí Œ≤} {b : Œ≤} {s : Finset Œ±} {g : (a : Œ±) ‚Üí Œ≤} (hb : op b b = b) (p : (a : Œ±) ‚Üí Prop)\n  [inst : DecidablePred p],\n  Finset.fold op b (fun (i : Œ±) ‚Ü¶ if (p i : Prop) then f i else g i) s =\n    op (Finset.fold op b f (Finset.filter p s)) (Finset.fold op b g (Finset.filter (fun (i : Œ±) ‚Ü¶ ¬¨(p i : Prop)) s))","name":"Finset.fold_ite'","isProp":true,"docString":"A stronger version of `Finset.fold_ite`, but relies on\nan explicit proof of idempotency on the seed element, rather\nthan relying on typeclass idempotency over the whole type. "},{"type":"‚àÄ {Œ± : Sort u} {f : (a : Œ±) ‚Üí Œ±} (h : Function.Involutive f) {x : Œ±} {y : Œ±}, (f x = y : Prop) ‚Üî (x = f y : Prop)","name":"Function.Involutive.eq_iff","isProp":true,"docString":"An involution commutes across an equality. Compare to `Function.Injective.eq_iff`. "},{"type":"‚àÄ {Œ± : Sort u_1} {p : (a : Œ±) ‚Üí Prop} {q : (x : Œ±) ‚Üí (a : p x) ‚Üí Prop},\n  (‚àÉ (x : Œ±), ‚àÉ (h : p x), q x h : Prop) ‚Üî (‚àÉ (x : { a : Œ± // p a }), q ‚Üëx ((Subtype.property x=:p ‚Üëx)=:p ‚Üëx) : Prop)","name":"Subtype.exists'","isProp":true,"docString":"An alternative version of `Subtype.exists`. This one is useful if Lean cannot figure out `q`\nwhen using `Subtype.exists` from right to left. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) {i : ‚Ñï} {j : ‚Ñï} (hi : i < List.length L)\n  (hj : j < List.length (List.nthLe L i hi)),\n  List.sum (List.take i (List.map List.length L)) + j < List.sum (List.take (i + 1) (List.map List.length L))","name":"List.sum_take_map_length_lt1","isProp":true,"docString":"Auxiliary lemma to control elements in a join. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} {f : (a : Œπ) ‚Üí Œ±} [h : Unique Œπ], Set.range f = {f default}","name":"Set.range_unique","isProp":true,"docString":"The range of a function from a `unique` type contains just the\nfunction applied to its single value. "},{"type":"‚àÄ {Œ± : Type u} [self : Semiring Œ±] (n : ‚Ñï) (x : Œ±), Semiring.npow (n + 1) x = x * Semiring.npow n x","name":"Semiring.npow_succ","isProp":true,"docString":"Raising to the power `(n + 1 : ‚Ñï)` behaves as expected. "},{"type":"‚àÄ {Œ± : Type u_2} [inst : TopologicalSpace Œ±] {Œπ : Type u_1} (b : (a : Œπ) ‚Üí TopologicalSpace.Opens Œ±)\n  (hb : TopologicalSpace.Opens.IsBasis (Set.range b)) (hb' : ‚àÄ (i : Œπ), IsCompact ‚Üë(b i)) (U : Set Œ±),\n  ((IsCompact U : Prop) ‚àß (IsOpen U : Prop) : Prop) ‚Üî\n    (‚àÉ (s : Set Œπ), (Set.Finite s : Prop) ‚àß (U = Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà s) ‚Ü¶ ‚Üë(b i) : Prop) :\n      Prop)","name":"TopologicalSpace.Opens.IsBasis.isCompact_open_iff_eq_finite_union·µ¢","isProp":true,"docString":"If `Œ±` has a basis consisting of compact opens, then an open set in `Œ±` is compact open iff\nit is a finite union of some elements in the basis "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {s : Set Œ±} {t : Set Œ±} {p : Set Œ±} (hs : IsLUB s a) (hp : IsLUB p a)\n  (hst : s ‚äÜ t) (htp : t ‚äÜ p), IsLUB t a","name":"IsLUB.of_subset_of_superset","isProp":true,"docString":"If `a` is a least upper bound for sets `s` and `p`, then it is a least upper bound for any\nset `t`, `s ‚äÜ t ‚äÜ p`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteBooleanAlgebra Œ±] (s : Set Œ±) (a : Œ±) (a_1 : a ‚àà s), inf‚Çõ s ‚â§ a","name":"CompleteBooleanAlgebra.inf‚Çõ_le","isProp":true,"docString":"Any element of a set is more than the set infimum. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : CommSemiring A] [inst_2 : Algebra R A]\n  (S : Subalgebra R A) (T : Subalgebra R A),\n  ‚ÜëSubalgebra.toSubmodule S * ‚ÜëSubalgebra.toSubmodule T = ‚ÜëSubalgebra.toSubmodule (S ‚äî T)","name":"Subalgebra.mul_toSubmodule","isProp":true,"docString":"When `A` is commutative, `Subalgebra.mul_toSubmodule_le` is strict. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ' : Sort u_2} [inst : CompleteLattice Œ±] (s : (a : Œπ') ‚Üí Œ±),\n  (sup·µ¢ fun (i : Œπ') ‚Ü¶ s i) =\n    sup·µ¢ fun (t : Finset (PLift Œπ')) ‚Ü¶ sup·µ¢ fun (i : PLift Œπ') ‚Ü¶ sup·µ¢ fun (h : i ‚àà t) ‚Ü¶ s (PLift.down i)","name":"sup·µ¢_eq_sup·µ¢_finset'","isProp":true,"docString":"Supremum of `s i`, `i : Œπ`, is equal to the supremum over `t : Finset Œπ` of suprema\n`‚®Ü i ‚àà t, s i`. This version works for `Œπ : Sort*`. See `sup·µ¢_eq_sup·µ¢_finset` for a version\nthat assumes `Œπ : Type _` but has no `plift`s. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±) (b : Œ±), a / b = a * b‚Åª¬π","name":"CanonicallyLinearOrderedSemifield.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {R : Type u_1} [inst : EuclideanDomain R] {abv : AbsoluteValue R ‚Ñ§} (self : AbsoluteValue.IsAdmissible abv) (n : ‚Ñï)\n  {Œµ : ‚Ñù} (x : 0 < Œµ) {b : R} (x : b ‚â† 0) (A : (a : Fin n) ‚Üí R),\n  ‚àÉ (t : (a : Fin n) ‚Üí Fin (AbsoluteValue.IsAdmissible.card self Œµ)),\n    ‚àÄ (i‚ÇÄ : Fin n) (i‚ÇÅ : Fin n) (a : t i‚ÇÄ = t i‚ÇÅ), ‚Üë(‚Üëabv (A i‚ÇÅ % b - A i‚ÇÄ % b)) < ‚Üëabv b ‚Ä¢ Œµ","name":"AbsoluteValue.IsAdmissible.exists_partition'","isProp":true,"docString":"For all `Œµ > 0` and finite families `A`, we can partition the remainders of `A` mod `b`\ninto `abv.card Œµ` sets, such that all elements in each part of remainders are close together. "},{"type":"‚àÄ {R : Type u_1} [inst : Rack R] {G : Type u_2} [inst_1 : Group G] (f : ShelfHom R (Quandle.Conj G))\n  {a : Rack.PreEnvelGroup R} {b : Rack.PreEnvelGroup R} (a_1 : Rack.PreEnvelGroupRel' R a b),\n  Rack.toEnvelGroup.mapAux f a = Rack.toEnvelGroup.mapAux f b","name":"Rack.toEnvelGroup.mapAux.well_def","isProp":true,"docString":"Show that `toEnvelGroup.mapAux` sends equivalent expressions to equal terms.\n"},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±},\n  (Equiv.Perm.IsCycle f : Prop) ‚Üî\n    (‚àÉ (s : Set Œ±),\n        (Set.Nontrivial s : Prop) ‚àß\n          ((Equiv.Perm.IsCycleOn f s : Prop) ‚àß (‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : ¬¨(Function.IsFixedPt (‚Üëf) x : Prop)), x ‚àà s : Prop) :\n            Prop) :\n      Prop)","name":"Equiv.Perm.isCycle_iff_exists_isCycleOn","isProp":true,"docString":"This lemma demonstrates the relation between `Equiv.Perm.IsCycle` and `Equiv.Perm.IsCycleOn`\nin non-degenerate cases. "},{"type":"‚àÄ {M‚ÇÄ : Type u} [self : MonoidWithZero M‚ÇÄ] (a : M‚ÇÄ), a * 0 = 0","name":"MonoidWithZero.mul_zero","isProp":true,"docString":"Zero is a right absorbing element for multiplication "},{"type":"‚àÄ {Œ± : Type u_1} [self : DenselyNormedField Œ±] (x : ‚Ñù) (y : ‚Ñù) (a : 0 ‚â§ x) (a : x < y),\n  ‚àÉ (a : Œ±), (x < ‚Äña‚Äñ : Prop) ‚àß (‚Äña‚Äñ < y : Prop)","name":"DenselyNormedField.lt_norm_lt","isProp":true,"docString":"The range of the norm is dense in the collection of nonnegative real numbers. "},{"type":"‚àÄ {Œ± : Type u_1} {m : ‚Ñï} (P : (a : (a : Fin m) ‚Üí Œ±) ‚Üí Prop),\n  (FinVec.Exists P : Prop) ‚Üî (‚àÉ (x : (a : Fin m) ‚Üí Œ±), P x : Prop)","name":"FinVec.exists_iff","isProp":true,"docString":"This can be use to prove\n```lean\nexample (P : (Fin 2 ‚Üí Œ±) ‚Üí Prop) : (‚àÉ f, P f) ‚Üî ‚àÉ a‚ÇÄ a‚ÇÅ, P ![a‚ÇÄ, a‚ÇÅ] :=\n  (exists_iff _).symm\n```\n"},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommMonoid M] [inst_1 : CommRing R] [inst_2 : Nontrivial R]\n  [h : Algebra.FiniteType R (MonoidAlgebra R M)], Monoid.Fg M","name":"MonoidAlgebra.fg_of_finiteType","isProp":true,"docString":"If `MonoidAlgebra R M` is of finite type then `M` is finitely generated. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {I : C} {T : C} (hI : CategoryTheory.Limits.IsInitial I)\n  (hT : CategoryTheory.Limits.IsTerminal T) (x : CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI T)),\n  CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.InitialMonoClass.of_isTerminal","isProp":true,"docString":"To show a category is a `InitialMonoClass` it suffices to show the unique morphism from an\ninitial object to a terminal object is a monomorphism. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (s : Set M) {p : (x : M) ‚Üí (a : x ‚àà AddSubmonoid.closure s) ‚Üí Prop}\n  (Hs :\n    ‚àÄ (x : M) (h : x ‚àà s),\n      p x ((AddSubmonoid.subset_closure h=:x ‚àà ‚Üë(AddSubmonoid.closure s))=:x ‚àà ‚Üë(AddSubmonoid.closure s)))\n  (H1 : p 0 ((zero_mem (AddSubmonoid.closure s)=:0 ‚àà AddSubmonoid.closure s)=:0 ‚àà AddSubmonoid.closure s))\n  (Hmul :\n    ‚àÄ (x : M) (hx : x ‚àà AddSubmonoid.closure s) (y : M) (hy : y ‚àà AddSubmonoid.closure s) (a : p x hx) (a : p y hy),\n      p (x + y) ((add_mem hx hy=:x + y ‚àà AddSubmonoid.closure s)=:x + y ‚àà AddSubmonoid.closure s))\n  {x : M} (hx : x ‚àà AddSubmonoid.closure s), p x hx","name":"AddSubmonoid.closure_induction'","isProp":true,"docString":"A dependent version of `AddSubmonoid.closure_induction`. "},{"type":"‚àÄ {Œπa : Type u_4} {Œπb : Type u_6} [inst : Fintype Œπa] [inst_1 : Fintype Œπb] {R' : Type u_1} {M·µ¢ : Type u_2}\n  {N‚ÇÅ : Type u_3} {N‚ÇÇ : Type u_5} [inst_2 : CommSemiring R'] [inst_3 : AddCommGroup N‚ÇÅ] [inst_4 : Module R' N‚ÇÅ]\n  [inst_5 : AddCommGroup N‚ÇÇ] [inst_6 : Module R' N‚ÇÇ] [inst_7 : AddCommMonoid M·µ¢] [inst_8 : Module R' M·µ¢]\n  [inst_9 : DecidableEq Œπa] [inst_10 : DecidableEq Œπb] (a : AlternatingMap R' M·µ¢ N‚ÇÅ Œπa) (b : AlternatingMap R' M·µ¢ N‚ÇÇ Œπb)\n  (œÉ : Equiv.Perm.ModSumCongr Œπa Œπb) {v : (a : Œπa ‚äï Œπb) ‚Üí M·µ¢} {i : Œπa ‚äï Œπb} {j : Œπa ‚äï Œπb} (hv : v i = v j) (hij : i ‚â† j)\n  (a_1 : Equiv.swap i j ‚Ä¢ œÉ = œÉ), ‚Üë(AlternatingMap.domCoprod.summand a b œÉ) v = 0","name":"AlternatingMap.domCoprod.summand_eq_zero_of_smul_invariant","isProp":true,"docString":"Swapping elements in `œÉ` with equal values in `v` result in zero if the swap has no effect\non the quotient. "},{"type":"WithTop.some = Nat.cast","name":"ENat.some_eq_coe","isProp":true,"docString":"Lemmas about `WithTop` expect (and can output) `WithTop.some` but the normal form for coercion\n`‚Ñï ‚Üí ‚Ñï‚àû` is `Nat.cast`. "},{"type":"‚àÄ (a : Ordinal) {b : Ordinal} (a_1 : Ordinal.IsLimit b), Ordinal.IsLimit (a + b)","name":"Ordinal.IsLimit.add","isProp":true,"docString":"**Alias** of `Ordinal.add_isLimit`."},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (n : ‚Ñï) (m : M),\n  ‚Üë‚Üën m = n ‚Ä¢ m","name":"Module.End.natCast_apply","isProp":true,"docString":"See also `Module.End.natCast_def`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (a : G) (x : G), AddSemiconjBy a x (a + x + -a)","name":"AddSemiconjBy.conj_mk","isProp":true,"docString":"`a` semiconjugates `x` to `a + x + -a`."},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : NoMaxOrder Œ±] (a : Œ±),\n  ‚àÉ (f : (a : ‚Ñï) ‚Üí Œ±), (StrictMono f : Prop) ‚àß (f 0 = a : Prop)","name":"Nat.exists_strictMono'","isProp":true,"docString":"If `Œ±` is a preorder with no maximal elements, then there exists a strictly monotone function\n`‚Ñï ‚Üí Œ±` with any prescribed value of `f 0`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (Œ¥ : ‚Ñù) (E : Set Œ±), Metric.thickening Œ¥ E ‚äÜ Metric.cthickening Œ¥ E","name":"Metric.thickening_subset_cthickening","isProp":true,"docString":"The open thickening `Metric.thickening Œ¥ E` is contained in the closed thickening\n`Metric.cthickening Œ¥ E` with the same radius. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddZeroClass Œ±] [inst_1 : AddZeroClass Œ≤] (f : Œ±·µê·µí·µñ ‚Üí+ Œ≤) (g : Œ±·µê·µí·µñ ‚Üí+ Œ≤)\n  (h :\n    AddMonoidHom.comp f (AddEquiv.toAddMonoidHom MulOpposite.opAddEquiv) =\n      AddMonoidHom.comp g (AddEquiv.toAddMonoidHom MulOpposite.opAddEquiv)),\n  f = g","name":"AddMonoidHom.mul_op_ext","isProp":true,"docString":"This ext lemma changes equalities on `Œ±·µê·µí·µñ ‚Üí+ Œ≤` to equalities on `Œ± ‚Üí+ Œ≤`.\nThis is useful because there are often ext lemmas for specific `Œ±`s that will apply\nto an equality of `Œ± ‚Üí+ Œ≤` such as `Finsupp.addHom_ext'`. "},{"type":"‚àÄ {B : Type u_1} (F : Type u_2) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F],\n  IsHomeomorphicTrivialFiberBundle F Prod.snd","name":"isHomeomorphicTrivialFiberBundle_snd","isProp":true,"docString":"The second projection in a product is a trivial fiber bundle. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (P : AddSubgroup G),\n  (AddSubgroup.Fg P : Prop) ‚Üî (AddSubmonoid.Fg (AddSubgroup.toAddSubmonoid P) : Prop)","name":"AddSubgroup.fg_iff_addSubmonoid_fg","isProp":true,"docString":"An additive subgroup is finitely generated if\nand only if it is finitely generated as an additive submonoid."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) (hnc : NormalizerCondition G) (hmax : IsCoatom H), Subgroup.Normal H","name":"Subgroup.NormalizerCondition.normal_of_coatom","isProp":true,"docString":"In a group that satisifes the normalizer condition, every maximal subgroup is normal "},{"type":"‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {Œ± : Type u_1}\n  {Œ≤ : Type u_2} [inst_3 : SMul Œ± Œ≤] [inst_4 : SMul A Œ±] [inst_5 : SMul A Œ≤] [inst_6 : IsScalarTower A Œ± Œ≤]\n  (S : Subalgebra R A), IsScalarTower { x : A // x ‚àà S } Œ± Œ≤","name":"Subalgebra.isScalarTower_left","isProp":true,"docString":"Note that this provides `IsScalarTower S R R` which is needed by `smul_mul_assoc`. "},{"type":"‚àÄ {K : Type u} [self : Field K] (n : ‚Ñï) (a : K), Field.zpow (Int.ofNat (Nat.succ n)) a = a * Field.zpow (Int.ofNat n) a","name":"Field.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x : X} {y : X} (a : x ‚§≥ y), y ‚àà closure {x}","name":"Specializes.mem_closure","isProp":true,"docString":"**Alias** of the forward direction of `specializes_iff_mem_closure`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Nonempty Œ±] {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (h : Nat.card Œ± = 0),\n  Nat.card Œ≤ = 0","name":"Finite.card_eq_zero_of_injective","isProp":true,"docString":"NB: `Nat.card` is defined to be `0` for infinite types. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {c : Set Œ±} (hc : IsChain r c),\n  ‚àÉ (M : Set Œ±), (IsMaxChain r M : Prop) ‚àß (c ‚äÜ M : Prop)","name":"IsChain.exists_maxChain","isProp":true,"docString":"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\n"},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≤' : Type u_5} {Œ≥ : Type u_2} {Œ¥ : Type u_1} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±}\n  {t : Set Œ≤} {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ≤') ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ≤) ‚Üí Œ≤'}\n  (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' (g' b) a), g '' Set.image2 f s t = Set.image2 f' (g' '' t) s","name":"Set.image_image2_antidistrib_left","isProp":true,"docString":"Symmetric statement to `Set.image2_image_left_anticomm`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : Set P), ‚Üë(affineSpan k s) = spanPoints k s","name":"coe_affineSpan","isProp":true,"docString":"The affine span, converted to a set, is `spanPoints`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {a : Œ±} (h_mono : MonotoneOn f s) (hs : s ‚àà nhds a)\n  (hfs_l : ‚àÄ (b : Œ≤) (a_1 : b < f a), ‚àÉ (c : Œ±), (c ‚àà s : Prop) ‚àß (f c ‚àà Set.Ioo b (f a) : Prop))\n  (hfs_r : ‚àÄ (b : Œ≤) (a_1 : b > f a), ‚àÉ (c : Œ±), (c ‚àà s : Prop) ‚àß (f c ‚àà Set.Ioo (f a) b : Prop)), ContinuousAt f a","name":"continuousAt_of_monotoneOn_of_exists_between","isProp":true,"docString":"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {x : M} (m : ‚Ñï) {n : ‚Ñï} (h : n ‚Ä¢ x = 0), m ‚Ä¢ x = (m % n) ‚Ä¢ x","name":"nsmul_eq_mod_nsmul","isProp":true,"docString":"If `n ‚Ä¢ x = 0`, then `m ‚Ä¢ x` is the same as `(m % n) ‚Ä¢ x`"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f) (hg : Antitone g), Antitone fun (x : Œ±) ‚Ü¶ min (f x) (g x)","name":"Antitone.min","isProp":true,"docString":"Pointwise minimum of two monotone functions is a monotone function. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g] {W : C} {k : W ‚ü∂ CategoryTheory.Limits.pullback f g}\n  {l : W ‚ü∂ CategoryTheory.Limits.pullback f g}\n  (h‚ÇÄ : k ‚â´ CategoryTheory.Limits.pullback.fst = l ‚â´ CategoryTheory.Limits.pullback.fst)\n  (h‚ÇÅ : k ‚â´ CategoryTheory.Limits.pullback.snd = l ‚â´ CategoryTheory.Limits.pullback.snd), k = l","name":"CategoryTheory.Limits.pullback.hom_ext","isProp":true,"docString":"Two morphisms into a pullback are equal if their compositions with the pullback morphisms are\nequal "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±]\n  (h : ‚àÄ (x : Œ±), ‚àÉ (s : Set Œ±), (s ‚àà nhds x : Prop) ‚àß (IsCompact s : Prop)), LocallyCompactSpace Œ±","name":"locally_compact_of_compact_nhds","isProp":true,"docString":"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. "},{"type":"‚àÄ (j : ‚Ñï), ¬¨(ComplexShape.Rel AlgebraicTopology.DoldKan.c 0 j : Prop)","name":"AlgebraicTopology.DoldKan.cs_down_0_not_rel_left","isProp":true,"docString":"This lemma is meant to be used with `nullHomotopicMap'_f_of_not_rel_left` "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (S : AddSubsemigroup M), AddSubsemigroup.closure ‚ÜëS = S","name":"AddSubsemigroup.closure_eq","isProp":true,"docString":"Additive closure of an additive subsemigroup `S` equals `S`"},{"type":"‚àÄ {R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [inst : CommRing R] [inst_1 : LieRing L]\n  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : LieRingModule L M] [inst_7 : LieRingModule L N] (self : M ‚âÉ‚Çó‚ÅÖR,L‚ÅÜ N),\n  Function.LeftInverse (LieModuleEquiv.invFun self)\n    (AddHom.toFun (LinearMap.toAddHom ‚Üë(LieModuleEquiv.toLieModuleHom self)))","name":"LieModuleEquiv.left_inv","isProp":true,"docString":"The inverse function of an equivalence of Lie modules is a left inverse of the underlying\nfunction. "},{"type":"‚àÄ {Œ± : Type u_1} {m : ‚Ñï} {n : ‚Ñï} (P : (a : Matrix (Fin m) (Fin n) Œ±) ‚Üí Prop),\n  (Matrix.Forall P : Prop) ‚Üî (‚àÄ (x : Matrix (Fin m) (Fin n) Œ±), P x : Prop)","name":"Matrix.forall_iff","isProp":true,"docString":"This can be use to prove\n```lean\nexample (P : Matrix (Fin 2) (Fin 3) Œ± ‚Üí Prop) :\n  (‚àÄ x, P x) ‚Üî ‚àÄ a b c d e f, P !![a, b, c; d, e, f] :=\n(forall_iff _).symm\n```\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : PolishSpace Œ±], PolishSpace ((a : ‚Ñï) ‚Üí Œ±)","name":"PolishSpace.nat_fun","isProp":true,"docString":"Without this instance, Lean 3 was unable to find `PolishSpace (‚Ñï ‚Üí ‚Ñï)` by typeclass inference.\nPorting note: TODO: test with Lean 4. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (hab : a ‚â§ b), (a < b : Prop) ‚à® (a = b : Prop)","name":"LE.le.lt_or_eq_dec","isProp":true,"docString":"**Alias** of `Decidable.lt_or_eq_of_le`."},{"type":"‚àÄ {C : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.MonoidalCategory C] [inst_3 : CategoryTheory.MonoidalPreadditive C] {D : Type u_1}\n  [inst_4 : CategoryTheory.Category D] [inst_5 : CategoryTheory.Preadditive D]\n  [inst_6 : CategoryTheory.MonoidalCategory D] (F : CategoryTheory.MonoidalFunctor D C)\n  [inst_7 :\n    CategoryTheory.Faithful\n      (CategoryTheory.LaxMonoidalFunctor.toFunctor (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F))]\n  [inst :\n    CategoryTheory.Functor.Additive\n      (CategoryTheory.LaxMonoidalFunctor.toFunctor (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F))],\n  CategoryTheory.MonoidalPreadditive D","name":"CategoryTheory.monoidalPreadditive_of_faithful","isProp":true,"docString":"A faithful additive monoidal functor to a monoidal preadditive category\nensures that the domain is monoidal preadditive. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : CommSemiring R]\n  [inst_1 : Semiring A] [inst_2 : Semiring B] [inst_3 : Algebra R A] [inst_4 : Algebra R B]\n  [self : AlgEquivClass F R A B] (f : F) (r : R), ‚Üëf (‚Üë(algebraMap R A) r) = ‚Üë(algebraMap R B) r","name":"AlgEquivClass.commutes","isProp":true,"docString":"An equivalence of algebras commutes with the action of scalars. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {S : C ‚•§ D}\n  {T : D} {A : CategoryTheory.CostructuredArrow S T} {P : (CategoryTheory.CostructuredArrow S T)·µí·µñ}\n  (f : P ‚ü∂ Opposite.op A)\n  [inst_2 : CategoryTheory.Mono (Quiver.Hom.op (CategoryTheory.CommaMorphism.left (Quiver.Hom.unop f)))],\n  CategoryTheory.CommaMorphism.left (Quiver.Hom.unop f) ‚â´\n      Quiver.Hom.unop\n        (CategoryTheory.Iso.hom\n          (CategoryTheory.Subobject.underlyingIso\n            (Quiver.Hom.op (CategoryTheory.CommaMorphism.left (Quiver.Hom.unop f))))) =\n    Quiver.Hom.unop\n      (CategoryTheory.Subobject.arrow\n        (CategoryTheory.Subobject.mk (Quiver.Hom.op (CategoryTheory.CommaMorphism.left (Quiver.Hom.unop f)))))","name":"CategoryTheory.CostructuredArrow.unop_left_comp_underlyingIso_hom_unop","isProp":true,"docString":"Technical lemma for `lift_projectQuotient`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : LinearOrder E] {s : Set E}\n  {f : (a : E) ‚Üí Œ≤} (hs : Convex ùïú s)\n  (hf :\n    ‚àÄ ‚¶Éx : E‚¶Ñ (a : x ‚àà s) ‚¶Éy : E‚¶Ñ (a : y ‚àà s) (a : x < y) ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 < a) (a_2 : 0 < b) (a_3 : a + b = 1),\n      a ‚Ä¢ f x + b ‚Ä¢ f y ‚â§ f (a ‚Ä¢ x + b ‚Ä¢ y)),\n  ConcaveOn ùïú s f","name":"LinearOrder.concaveOn_of_lt","isProp":true,"docString":"For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is concave it suffices to\nverify the inequality `a ‚Ä¢ f x + b ‚Ä¢ f y ‚â§ f (a ‚Ä¢ x + b ‚Ä¢ y)` for `x < y` and positive `a`, `b`. The\nmain use case is `E = ‚Ñù` however one can apply it, e.g., to `‚Ñù^n` with lexicographic order. "},{"type":"‚àÄ {R : Type u} [inst : NonUnitalSemiring R] [self : StarRing R] (r : R) (s : R), star (r + s) = star r + star s","name":"StarRing.star_add","isProp":true,"docString":"`star` commutes with addition "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}\n  [inst_1 : CategoryTheory.Category D] [inst_2 : CategoryTheory.ConcreteCategory D]\n  [inst_3 : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)]\n  [inst_4 : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ D]\n  [inst_5 :\n    ‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\n  [inst_6 :\n    (X : C) ‚Üí\n      CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ\n        (CategoryTheory.forget D)]\n  [inst_7 : CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget D)] (P : C·µí·µñ ‚•§ D),\n  CategoryTheory.Presheaf.IsSheaf J\n    (CategoryTheory.GrothendieckTopology.plusObj J (CategoryTheory.GrothendieckTopology.plusObj J P))","name":"CategoryTheory.GrothendieckTopology.Plus.isSheaf_plus_plus","isProp":true,"docString":"`P‚Å∫‚Å∫` is always a sheaf. "},{"type":"‚àÄ {B : Type u_2} (F : Type u_1) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : (a : B) ‚Üí Type u_3)\n  [inst_2 : TopologicalSpace (Bundle.TotalSpace E)] [inst_3 : (b : B) ‚Üí TopologicalSpace (E b)] [inst : FiberBundle F E]\n  [inst : Nonempty F], Function.Surjective Bundle.TotalSpace.proj","name":"FiberBundle.surjective_proj","isProp":true,"docString":"The projection from a fiber bundle with a nonempty fiber to its base is a surjective\nmap. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Semiring Œ±] [inst_1 : Semiring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsSemiringHom f) (x : Œ±)\n  (y : Œ±), f (x * y) = f x * f y","name":"IsSemiringHom.map_mul","isProp":true,"docString":"The proposition that `f` preserves multiplication. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a : Œ±} {b : Œ±} (a_1 : (a == b) = true), (b == a) = true","name":"PartialEquivBEq.symm","isProp":true,"docString":"Symmetry for `BEq`. If `a == b` then `b == a`. "},{"type":"‚àÄ {Œ≤ : Type u_1} {Œ± : Type u_2} {A : (a : List Œ≤) ‚Üí Set Œ±} (x : ‚Üë(Sigma.fst (CantorScheme.inducedMap A))) (n : ‚Ñï),\n  Sigma.snd (CantorScheme.inducedMap A) x ‚àà A (PiNat.res (‚Üëx) n)","name":"CantorScheme.map_mem","isProp":true,"docString":"If `x` is in the domain of the induced map of a scheme `A`,\nits image under this map is in each set along the corresponding branch. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) {x : G} {y : G} (a : x ‚àà H) (a : y ‚àà H), x + y ‚àà H","name":"AddSubgroup.add_mem","isProp":true,"docString":"An `AddSubgroup` is closed under addition."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤}, Monotone (Set.image f)","name":"Set.monotone_image","isProp":true,"docString":"`Set.image` is monotone. See `Set.image_subset` for the statement in terms of `‚äÜ`. "},{"type":"‚àÄ {k : Type u_1} {V1 : Type u_2} {V2 : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1]\n  [inst_3 : AddCommGroup V2] [inst_4 : Module k V2] (f : V1 ‚Üí·µÉ[k] V2), ‚Üë(AffineMap.linear f) = ‚Üëf - fun (x : V1) ‚Ü¶ ‚Üëf 0","name":"AffineMap.decomp'","isProp":true,"docString":"Decomposition of an affine map in the special case when the point space and vector space\nare the same. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 < a) (hb : 1 < b), 1 < a * b","name":"one_lt_mul''","isProp":true,"docString":"**Alias** of `Left.one_lt_mul'`."},{"type":"‚àÄ {R : Type v} {n : Type w} [inst : Fintype n] [inst_1 : PartialOrder R] [inst_2 : NonUnitalRing R]\n  [inst_3 : StarOrderedRing R] [inst_4 : NoZeroDivisors R] {v : (a : n) ‚Üí R},\n  (Matrix.dotProduct v (star v) = 0 : Prop) ‚Üî (v = 0 : Prop)","name":"Matrix.dotProduct_self_star_eq_zero","isProp":true,"docString":"Note that this applies to `‚ÑÇ` via `Complex.strictOrderedCommRing`. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : AddCommMonoid Œ≤] (f : (a : Fin 0) ‚Üí Œ≤), (Finset.sum Finset.univ fun (i : Fin 0) ‚Ü¶ f i) = 0","name":"Fin.sum_univ_zero","isProp":true,"docString":"A sum of a function `f : Fin 0 ‚Üí Œ≤` is `0` because `Fin 0` is empty"},{"type":"‚àÄ {E : Sort u_2} {Œ± : Sort u_1} {Œ≤ : Sort u_3} [iE : EquivLike E Œ± Œ≤] (e : E) (a : Œ±), EquivLike.inv e (‚Üëe a) = a","name":"EquivLike.inv_apply_apply","isProp":true,"docString":"This lemma is only supposed to be used in the generic context, when working with instances\nof classes extending `EquivLike`.\nFor concrete isomorphism types such as `Equiv`, you should use `Equiv.symm_apply_apply`\nor its equivalent.\n\nTODO: define a generic form of `Equiv.symm`. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]\n  {B : (a : Œπ) ‚Üí Submodule R A} (self : SubmodulesRingBasis B) (i : Œπ) (j : Œπ), ‚àÉ (k : Œπ), B k ‚â§ B i ‚äì B j","name":"SubmodulesRingBasis.inter","isProp":true,"docString":"Condition for `B` to be a filter basis on `A`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (e : LocalHomeomorph Œ± Œ≤)\n  {x : Œ≤} (h : x ‚àà LocalEquiv.target (LocalHomeomorph.toLocalEquiv e)), ContinuousAt (‚Üë(LocalHomeomorph.symm e)) x","name":"LocalHomeomorph.continuousAt_symm","isProp":true,"docString":"A local homeomorphism inverse is continuous at any point of its target "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {t : Finset V} (h : FiniteDimensional.finrank K V + 1 < Finset.card t),\n  ‚àÉ (f : (a : V) ‚Üí K),\n    ((Finset.sum t fun (e : V) ‚Ü¶ f e ‚Ä¢ e) = 0 : Prop) ‚àß\n      (((Finset.sum t fun (e : V) ‚Ü¶ f e) = 0 : Prop) ‚àß (‚àÉ (x : V), (x ‚àà t : Prop) ‚àß (f x ‚â† 0 : Prop) : Prop) : Prop)","name":"FiniteDimensional.exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card","isProp":true,"docString":"If a finset has cardinality larger than `finrank + 1`,\nthen there is a nontrivial linear relation amongst its elements,\nsuch that the coefficients of the relation sum to zero.\n"},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K] {U : Set (G √ó K)}\n  (hU : U ‚àà nhds 0), ‚àÉ (V : OpenAddSubgroup G), ‚àÉ (W : OpenAddSubgroup K), ‚ÜëV √óÀ¢ ‚ÜëW ‚äÜ U","name":"NonarchimedeanAddGroup.prod_subset","isProp":true,"docString":"An open neighborhood of the identity in\nthe cartesian product of two nonarchimedean groups contains the cartesian product of\nan open neighborhood in each group."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : QuasiSeparatedSpace Œ±] (U : Set Œ±) (V : Set Œ±) (a : IsOpen U)\n  (a : IsCompact U) (a : IsOpen V) (a : IsCompact V), IsCompact (U ‚à© V)","name":"QuasiSeparatedSpace.inter_isCompact","isProp":true,"docString":"The intersection of two open compact subsets of a quasi-separated space is compact."},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : NonUnitalSemiring A] [inst_2 : Module R A]\n  [inst_3 : SMulCommClass R A A] [inst_4 : IsScalarTower R A A] {C : Type u_3} [inst_5 : Semiring C]\n  [inst_6 : Algebra R C] {œÜ : Unitization R A ‚Üí‚Çê[R] C} {œà : Unitization R A ‚Üí‚Çê[R] C}\n  (h :\n    NonUnitalAlgHom.comp (‚ÜëœÜ) (Unitization.inrNonUnitalAlgHom R A) =\n      NonUnitalAlgHom.comp (‚Üëœà) (Unitization.inrNonUnitalAlgHom R A)),\n  œÜ = œà","name":"Unitization.algHom_ext'","isProp":true,"docString":"See note [partially-applied ext lemmas] "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : OrderBot Œ±] (x : Œ±) (y : Œ±), (x ‚®ø y) = x ‚äî y","name":"CategoryTheory.Limits.CompleteLattice.coprod_eq_sup","isProp":true,"docString":"The binary coproduct in the category of a `SemilatticeSup` with `OrderBot` is the same as the\nsupremum.\n"},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : LinearOrderedRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] {Œπ : Type u_4} {p : (a : Œπ) ‚Üí P} (h : AffineIndependent k p)\n  {w : (a : Œπ) ‚Üí k} {s : Finset Œπ} (hw : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1) {i‚ÇÅ : Œπ} {i‚ÇÇ : Œπ} {i‚ÇÉ : Œπ} (h‚ÇÅ : i‚ÇÅ ‚àà s)\n  (h‚ÇÇ : i‚ÇÇ ‚àà s) (h‚ÇÉ : i‚ÇÉ ‚àà s) (h‚ÇÅ‚ÇÇ : i‚ÇÅ ‚â† i‚ÇÇ) (h‚ÇÅ‚ÇÉ : i‚ÇÅ ‚â† i‚ÇÉ) (h‚ÇÇ‚ÇÉ : i‚ÇÇ ‚â† i‚ÇÉ) {c : k} (hc0 : 0 < c) (hc1 : c < 1)\n  (hs : ‚Üë(Finset.affineCombination k s p) w ‚àà affineSpan k {p i‚ÇÅ, ‚Üë(AffineMap.lineMap (p i‚ÇÇ) (p i‚ÇÉ)) c}),\n  ‚ÜëSignType.sign (w i‚ÇÇ) = ‚ÜëSignType.sign (w i‚ÇÉ)","name":"sign_eq_of_affineCombination_mem_affineSpan_single_lineMap","isProp":true,"docString":"Given an affinely independent family of points, suppose that an affine combination lies in\nthe span of one point of that family and a combination of another two points of that family given\nby `lineMap` with coefficient between 0 and 1. Then the coefficients of those two points in the\ncombination lying in the span have the same sign. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {x‚ÇÅ : R} {x‚ÇÇ : R} {x‚ÇÉ : R} {x‚ÇÑ : R} {y‚ÇÅ : R} {y‚ÇÇ : R} {y‚ÇÉ : R} {y‚ÇÑ : R},\n  (x‚ÇÅ ^ 2 + x‚ÇÇ ^ 2 + x‚ÇÉ ^ 2 + x‚ÇÑ ^ 2) * (y‚ÇÅ ^ 2 + y‚ÇÇ ^ 2 + y‚ÇÉ ^ 2 + y‚ÇÑ ^ 2) =\n    (x‚ÇÅ * y‚ÇÅ - x‚ÇÇ * y‚ÇÇ - x‚ÇÉ * y‚ÇÉ - x‚ÇÑ * y‚ÇÑ) ^ 2 + (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ + x‚ÇÉ * y‚ÇÑ - x‚ÇÑ * y‚ÇÉ) ^ 2 +\n        (x‚ÇÅ * y‚ÇÉ - x‚ÇÇ * y‚ÇÑ + x‚ÇÉ * y‚ÇÅ + x‚ÇÑ * y‚ÇÇ) ^ 2 +\n      (x‚ÇÅ * y‚ÇÑ + x‚ÇÇ * y‚ÇÉ - x‚ÇÉ * y‚ÇÇ + x‚ÇÑ * y‚ÇÅ) ^ 2","name":"sum_four_sq_mul_sum_four_sq","isProp":true,"docString":"Euler's four-square identity, see <https://en.wikipedia.org/wiki/Euler%27s_four-square_identity>.\n\nThis sign choice here corresponds to the signs obtained by multiplying two quaternions.\n"},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) (i : Fin (List.length L)),\n  List.drop (List.sum (List.take (‚Üëi) (List.map List.length L)))\n      (List.take (List.sum (List.take (‚Üëi + 1) (List.map List.length L))) (List.join L)) =\n    List.get L i","name":"List.drop_take_succ_join_eq_get","isProp":true,"docString":"In a join of sublists, taking the slice between the indices `A` and `B - 1` gives back the\noriginal sublist of index `i` if `A` is the sum of the lenghts of sublists of index `< i`, and\n`B` is the sum of the lengths of sublists of index `‚â§ i`. "},{"type":"‚àÄ {l : List ‚Ñ§} (h : List.prod l = -1), -1 ‚àà l","name":"List.neg_one_mem_of_prod_eq_neg_one","isProp":true,"docString":"If a product of integers is `-1`, then at least one factor must be `-1`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {Œπ : Type u_1} [inst : Encodable Œπ] {U : (a : Œπ) ‚Üí Set Œ±}\n  [inst : ‚àÄ (i : Œπ), TopologicalSpace.SecondCountableTopology ‚Üë(U i)] (Uo : ‚àÄ (i : Œπ), IsOpen (U i))\n  (hc : (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ U i) = Set.univ), TopologicalSpace.SecondCountableTopology Œ±","name":"TopologicalSpace.secondCountableTopology_of_countable_cover","isProp":true,"docString":"A countable open cover induces a second-countable topology if all open covers\nare themselves second countable. "},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_2} {N : Type u_1} [inst : AddCommMonoid M] [inst_1 : OrderedAddCommMonoid N]\n  (f : (a : M) ‚Üí N) (h_one : f 0 = 0) (h_mul : ‚àÄ (x : M) (y : M), f (x + y) ‚â§ f x + f y) (s : Finset Œπ)\n  (g : (a : Œπ) ‚Üí M), f (Finset.sum s fun (i : Œπ) ‚Ü¶ g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f (g i)","name":"Finset.le_sum_of_subadditive","isProp":true,"docString":"If `f : M ‚Üí N` is a subadditive function, `f (x + y) ‚â§ f x + f y`, `f 0 = 0`, and `g i`,\n`i ‚àà s`, is a finite family of elements of `M`, then `f (‚àë i in s, g i) ‚â§ ‚àë i in s, f (g i)`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {e' : LocalEquiv Œ± Œ≤} (h : e ‚âà e'),\n  Set.EqOn (LocalEquiv.toFun e) (LocalEquiv.toFun e') (LocalEquiv.source e)","name":"LocalEquiv.EqOnSource.eqOn","isProp":true,"docString":"Two equivalent local equivs coincide on the source "},{"type":"‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (u‚ÇÅ : Œ±À£) (u‚ÇÇ : Œ±À£), ‚Üë(u‚ÇÅ / u‚ÇÇ) = ‚Üëu‚ÇÅ /‚Çö u‚ÇÇ","name":"val_div_eq_divp","isProp":true,"docString":"`field_simp` moves division inside `Œ±À£` to the right, and this lemma\nlifts the calculation to `Œ±`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {‚Ñ¨ : Finset (Finset Œ±)} [inst_1 : Fintype Œ±]\n  (hùíú : IsLowerSet ‚Üëùíú) (h‚Ñ¨ : IsUpperSet ‚Üë‚Ñ¨), 2 ^ Fintype.card Œ± * Finset.card (ùíú ‚à© ‚Ñ¨) ‚â§ Finset.card ùíú * Finset.card ‚Ñ¨","name":"IsLowerSet.card_inter_le_finset","isProp":true,"docString":"**Harris-Kleitman inequality**: Lower sets and upper sets of finsets anticorrelate. "},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ] {Œ≥ : Œì‚ÇÄ} (h‚ÇÄ : Œ≥ ‚â† 0), nhds Œ≥ = pure Œ≥","name":"WithZeroTopology.nhds_of_ne_zero","isProp":true,"docString":"The neighbourhood filter of a nonzero element consists of all sets containing that\nelement. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroClass M‚ÇÄ] [inst_1 : NoZeroDivisors M‚ÇÄ] {a : M‚ÇÄ} {b : M‚ÇÄ},\n  (a * b ‚â† 0 : Prop) ‚Üî ((a ‚â† 0 : Prop) ‚àß (b ‚â† 0 : Prop) : Prop)","name":"mul_ne_zero_iff","isProp":true,"docString":"If `Œ±` has no zero divisors, then the product of two elements is nonzero iff both of them\nare nonzero. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Setoid Œ±} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n  {H :\n    ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÅ : Œ±) (b‚ÇÇ : Œ±) (a : Setoid.r a‚ÇÅ b‚ÇÅ) (a : Setoid.r a‚ÇÇ b‚ÇÇ),\n      (r a‚ÇÅ a‚ÇÇ : Prop) = (r b‚ÇÅ b‚ÇÇ : Prop)}\n  (a : WellFounded fun (x : Quotient s) (y : Quotient s) ‚Ü¶ Quotient.liftOn‚ÇÇ' x y r H), WellFounded r","name":"WellFounded.of_quotient_liftOn‚ÇÇ'","isProp":true,"docString":"**Alias** of the forward direction of `wellFounded_liftOn‚ÇÇ'_iff`."},{"type":"CategoryTheory.Limits.HasLimitsOfSize TypeMax","name":"CategoryTheory.Limits.Types.hasLimitsOfSize","isProp":true,"docString":"The category of types has all limits.\n\nSee <https://stacks.math.columbia.edu/tag/002U>.\n"},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Group H] [inst_2 : Monoid M]\n  [inst_3 : MulAction G M] [inst_4 : SMulCommClass G M M] [inst_5 : MulAction H M] [inst_6 : SMulCommClass H M M]\n  [inst_7 : IsScalarTower G M M] [inst_8 : IsScalarTower H M M] [inst_9 : SMulCommClass G H M], SMulCommClass G H MÀ£","name":"Units.smulCommClass'","isProp":true,"docString":"Transfer `SMulCommClass G H M` to `SMulCommClass G H MÀ£` "},{"type":"‚àÄ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Add A] [inst_1 : Add B]\n  [self : AddEquivClass F A B] (f : F) (a : A) (b : A), ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b","name":"AddEquivClass.map_add","isProp":true,"docString":"Preserves addition. "},{"type":"‚àÄ {M : Type u_2} [inst : Monoid M] {A : Type u_1} [inst_1 : Monoid A] {f : (a : M) ‚Üí A} (hf : IsMonoidHom f)\n  (s : Set M), f '' Monoid.Closure s = Monoid.Closure (f '' s)","name":"Monoid.image_closure","isProp":true,"docString":"The image under a monoid hom of the submonoid generated by a set equals the submonoid generated\nby the image of the set under the monoid hom. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u} [inst : CommRing R] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Ideal R} (a : Œπ) (b : Œπ)\n  (hp : ‚àÄ (i : Œπ) (a_1 : i ‚àà s) (a : i ‚â† a) (a : i ‚â† b), Ideal.IsPrime (f i)) {I : Ideal R},\n  (‚ÜëI ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà ‚Üës) ‚Ü¶ ‚Üë(f i) : Prop) ‚Üî\n    (‚àÉ (i : Œπ), (i ‚àà s : Prop) ‚àß (I ‚â§ f i : Prop) : Prop)","name":"Ideal.subset_union_prime","isProp":true,"docString":"Prime avoidance. Atiyah-Macdonald 1.11, Eisenbud 3.3, Stacks 00DS, Matsumura Ex.1.6. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : MonotoneOn f s) (hs : s ‚àà nhds a) (hfs : f '' s ‚àà nhds (f a)),\n  ContinuousAt f a","name":"continuousAt_of_monotoneOn_of_image_mem_nhds","isProp":true,"docString":"If a function `f` with a densely ordered codomain is monotone on a neighborhood of `a` and the\nimage of this neighborhood under `f` is a neighborhood of `f a`, then `f` is continuous at `a`. "},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±), a * (b + c) = a * b + a * c","name":"NonUnitalNonAssocSemiring.left_distrib","isProp":true,"docString":"Multiplication is left distributive over addition "},{"type":"‚àÄ {Œ± : Type u_1} {ùíú : Finset (Finset Œ±)} {r : ‚Ñï}, Finset.slice ùíú r ‚äÜ ùíú","name":"Finset.slice_subset","isProp":true,"docString":"The `r`-th slice of `ùíú` is a subset of `ùíú`. "},{"type":"‚àÄ {M : Type u_2} [inst : AddMonoid M] {Œπ : Sort u_1} {s : (a : Œπ) ‚Üí Set M} (h : ‚àÄ (y : Œπ), IsAddSubmonoid (s y)),\n  IsAddSubmonoid (Set.inter·µ¢ s)","name":"IsAddSubmonoid.inter·µ¢","isProp":true,"docString":"The intersection of an indexed set of `AddSubmonoid`s of an `AddMonoid` `M` is\nan `AddSubmonoid` of `M`."},{"type":"‚àÄ {Œ± : Type u} (f : (a : Fin 0) ‚Üí Œ±), List.ofFn f = []","name":"List.ofFn_zero","isProp":true,"docString":"`ofFn` on an empty domain is the empty list. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] (B : RingFilterBasis R), TopologicalRing R","name":"RingFilterBasis.isTopologicalRing","isProp":true,"docString":"If a ring is endowed with a topological structure coming from\na ring filter basis then it's a topological ring. "},{"type":"‚àÄ {a : Prop}, (¬¨(¬¨(a : Prop) : Prop) : Prop) ‚Üî (a : Prop)","name":"Classical.not_not","isProp":true,"docString":"The Double Negation Theorem: `¬¨¬¨P` is equivalent to `P`.\nThe left-to-right direction, double negation elimination (DNE),\nis classically true but not constructively. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {‚Ñ¨ : Finset (Finset Œ±)} [inst_1 : Fintype Œ±]\n  (hùíú : IsLowerSet ‚Üëùíú) (h‚Ñ¨ : IsLowerSet ‚Üë‚Ñ¨), Finset.card ùíú * Finset.card ‚Ñ¨ ‚â§ 2 ^ Fintype.card Œ± * Finset.card (ùíú ‚à© ‚Ñ¨)","name":"IsLowerSet.le_card_inter_finset","isProp":true,"docString":"**Harris-Kleitman inequality**: Any two lower sets of finsets correlate. "},{"type":"‚àÄ (R : Type u_1) (S : Type v) [inst : AddMonoidWithOne R] [inst_1 : AddMonoidWithOne S] (p : ‚Ñï) [inst_2 : CharP R p]\n  [inst_3 : CharP S p], CharP (R √ó S) p","name":"Prod.charP","isProp":true,"docString":"The characteristic of the product of two rings of the same characteristic\nis the same as the characteristic of the rings "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (B : (a : ‚Ñï) ‚Üí ENNReal) (hB : ‚àÄ (n : ‚Ñï), 0 < B n)\n  (H :\n    ‚àÄ (u : (a : ‚Ñï) ‚Üí Œ±) (a : ‚àÄ (N : ‚Ñï) (n : ‚Ñï) (m : ‚Ñï) (a : N ‚â§ n) (a : N ‚â§ m), edist (u n) (u m) < B N),\n      ‚àÉ (x : Œ±), Filter.Tendsto u Filter.atTop (nhds x)),\n  CompleteSpace Œ±","name":"EMetric.complete_of_convergent_controlled_sequences","isProp":true,"docString":"A very useful criterion to show that a space is complete is to show that all sequences\nwhich satisfy a bound of the form `edist (u n) (u m) < B N` for all `n m ‚â• N` are\nconverging. This is often applied for `B N = 2^{-N}`, i.e., with a very fast convergence to\n`0`, which makes it possible to use arguments of converging series, while this is impossible\nto do in general for arbitrary Cauchy sequences. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} {n : ‚Ñï} (a : Equiv.Perm.SameCycle f x y),\n  Equiv.Perm.SameCycle f x (‚Üë(f ^ n) y)","name":"Equiv.Perm.SameCycle.pow_right","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_pow_right`."},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±],\n  IsClosed (Set.range TopologicalSpace.NonemptyCompacts.toCloseds)","name":"EMetric.NonemptyCompacts.isClosed_in_closeds","isProp":true,"docString":"The range of `NonemptyCompacts.toCloseds` is closed in a complete space "},{"type":"‚àÄ {M : Type u_3} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N] {P : Type u_4}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P} {T : AddSubmonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_1} [inst_3 : AddCommMonoid Q]\n  {k : AddSubmonoid.LocalizationMap T Q} (z : N) (u : Q),\n  (‚Üë(AddSubmonoid.LocalizationMap.map f hy k) z = u : Prop) ‚Üî\n    (‚Üë(AddSubmonoid.LocalizationMap.toMap k) (‚Üëg (Prod.fst (AddSubmonoid.LocalizationMap.sec f z))) =\n        ‚Üë(AddSubmonoid.LocalizationMap.toMap k) (‚Üëg ‚Üë(Prod.snd (AddSubmonoid.LocalizationMap.sec f z))) + u :\n      Prop)","name":"AddSubmonoid.LocalizationMap.map_spec","isProp":true,"docString":"Given Localization maps `f : M ‚Üí+ N, k : P ‚Üí+ Q` for Submonoids `S, T` respectively, if an\n`AddCommMonoid` homomorphism `g : M ‚Üí+ P` induces a `f.map hy k : N ‚Üí+ Q`, then for all `z : N`,\n`u : Q`, we have `f.map hy k z = u ‚Üî k (g x) = k (g y) + u` where `x : M, y ‚àà S` are such that\n`z + f y = f x`."},{"type":"‚àÄ {S : Type v} [inst : CommRing S] {R : Type u} (c : ‚Ñ§ ‚Üí+* S) (f : MvPolynomial R ‚Ñ§ ‚Üí+* S) (x : MvPolynomial R ‚Ñ§),\n  MvPolynomial.eval‚ÇÇ c (‚Üëf ‚àò MvPolynomial.X) x = ‚Üëf x","name":"MvPolynomial.eval‚ÇÇHom_X","isProp":true,"docString":"A ring homomorphism f : Z[X_1, X_2, ...] ‚Üí R\nis determined by the evaluations f(X_1), f(X_2), ... "},{"type":"‚àÄ {P : (a : ‚Ñ§) ‚Üí Prop} {m : ‚Ñ§} (h0 : P m) (h1 : ‚àÄ (n : ‚Ñ§) (a : n ‚â§ m) (a : P n), P (n - 1)) (n : ‚Ñ§) (a : n ‚â§ m), P n","name":"Int.le_induction_down","isProp":true,"docString":"See `Int.inductionOn'` for an induction in both directions. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} (a : FreeAddGroup.Red.Step L‚ÇÅ L‚ÇÇ),\n  List.length L‚ÇÇ + 2 = List.length L‚ÇÅ","name":"FreeAddGroup.Red.Step.length","isProp":true,"docString":"Predicate asserting that the word `w‚ÇÅ` can be reduced to `w‚ÇÇ` in one step, i.e. there\nare words `w‚ÇÉ w‚ÇÑ` and letter `x` such that `w‚ÇÅ = w‚ÇÉ + x + (-x) + w‚ÇÑ` and `w‚ÇÇ = w‚ÇÉw‚ÇÑ`"},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x : R // x ‚àà s }","name":"Subring.instIsDomainSubtypeMemSubringInstMembershipInstSetLikeSubringToSemiringToRing","isProp":true,"docString":"A subring of a domain is a domain. "},{"type":"‚àÄ {k : Type u_2} {G : Type u_1} [inst : Monoid G] [inst_1 : Semiring k] {s : Set G} {x : MonoidAlgebra k G},\n  (x ‚àà Ideal.span (‚Üë(MonoidAlgebra.of k G) '' s) : Prop) ‚Üî\n    (‚àÄ (m : G) (a : m ‚àà Finsupp.support x), ‚àÉ (m' : G), (m' ‚àà s : Prop) ‚àß (‚àÉ (d : G), m = d * m' : Prop) : Prop)","name":"MonoidAlgebra.mem_ideal_span_of_image","isProp":true,"docString":"If `x` belongs to the ideal generated by generators in `s`, then every element of the support of\n`x` factors through an element of `s`.\n\nWe could spell `‚àÉ d, m = d * m` as `mul_opposite.op m' ‚à£ mul_opposite.op m` but this would be worse.\n"},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {X : CategoryTheory.SimplicialObject C} (n : ‚Ñï) (q : ‚Ñï),\n  HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.Q q) (n + 1) =\n    Finset.sum (Finset.filter (fun (i : Fin (n + 1)) ‚Ü¶ ‚Üëi < q) Finset.univ) fun (i : Fin (n + 1)) ‚Ü¶\n      HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.P ‚Üëi) (n + 1) ‚â´\n        CategoryTheory.SimplicialObject.Œ¥ X (Fin.succ (‚ÜëFin.rev i)) ‚â´ CategoryTheory.SimplicialObject.œÉ X (‚ÜëFin.rev i)","name":"AlgebraicTopology.DoldKan.decomposition_Q","isProp":true,"docString":"In each positive degree, this lemma decomposes the idempotent endomorphism\n`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.\nAs `Q q` is the complement projection to `P q`, this implies that in the case of\nsimplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as\n$x = x' + \\sum (i=0}^{q-1} œÉ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and\nthe $y_i$ are in degree $n$. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Nonempty s), Filter.NeBot (Filter.principal s)","name":"Set.Nonempty.principal_neBot","isProp":true,"docString":"**Alias** of the reverse direction of `Filter.principal_neBot_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hst : Disjoint s t)\n  (hs : Set.Finite s) (ht : Set.Finite t),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) =\n    (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà t) ‚Ü¶ f i","name":"finprod_mem_union","isProp":true,"docString":"Given two finite disjoint sets `s` and `t`, the product of `f i` over `i ‚àà s ‚à™ t` equals the\nproduct of `f i` over `i ‚àà s` times the product of `f i` over `i ‚àà t`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±},\n  (s ‚àà Finset.upShadow ùíú : Prop) ‚Üî\n    (‚àÉ (t : Finset Œ±), (t ‚àà ùíú : Prop) ‚àß (‚àÉ (a : Œ±), ‚àÉ (x : ¬¨(a ‚àà t : Prop)), insert a t = s : Prop) : Prop)","name":"Finset.mem_upShadow_iff","isProp":true,"docString":"`s` is in the upper shadow of `ùíú` iff there is an `t ‚àà ùíú` from which we can remove one element\nto get `s`. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type u_1} (p : (a : Œπ) ‚Üí Prop) [h : Finite ‚Üë(setOf fun (x : Œπ) ‚Ü¶ p x)] (t : (a : Œπ) ‚Üí Set Œ±)\n  [inst : ‚àÄ (i : Œπ), Finite ‚Üë(t i)], Finite ‚Üë(Set.union·µ¢ fun (x : Œπ) ‚Ü¶ Set.union·µ¢ fun (_h : p x) ‚Ü¶ t x)","name":"Finite.Set.finite_bunion·µ¢''","isProp":true,"docString":"Example: `Finite (‚ãÉ (i < n), f i)` where `f : ‚Ñï ‚Üí set Œ±` and `[‚àÄ i, Finite (f i)]`\n(when given instances from `Data.Nat.Interval`).\n"},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} {c : Œ±} [inst : LinearOrder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±]\n  [inst_3 : OrderedSub Œ±], (a < b - c : Prop) ‚Üî (c + a < b : Prop)","name":"lt_tsub_iff_left","isProp":true,"docString":"See `lt_tsub_iff_left_of_le` for a weaker statement in a partial order. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] (a : Œ≥) {s : Set Œ≥}, (BddBelow (insert a s) : Prop) ‚Üî (BddBelow s : Prop)","name":"bddBelow_insert","isProp":true,"docString":"Adding a point to a set preserves its boundedness below."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddCommGroup Œ≤] (g : FreeAbelianGroup Œ± ‚Üí+ Œ≤) (h : FreeAbelianGroup Œ± ‚Üí+ Œ≤)\n  (H : ‚àÄ (x : Œ±), ‚Üëg (FreeAbelianGroup.of x) = ‚Üëh (FreeAbelianGroup.of x)), g = h","name":"FreeAbelianGroup.lift.ext","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] (M : Submonoid R) {S : Type u_2} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] (z : S),\n  ‚àÉ (x : R √ó { x : R // x ‚àà M }), z * ‚Üë(algebraMap R S) ‚Üë(Prod.snd x) = ‚Üë(algebraMap R S) (Prod.fst x)","name":"IsLocalization.surj","isProp":true,"docString":"the `algebraMap` is surjective "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [self : OreLocalization.OreSet S] (r‚ÇÅ : R) (r‚ÇÇ : R)\n  (s : { x : R // x ‚àà S }) (a : ‚Üës * r‚ÇÅ = ‚Üës * r‚ÇÇ), ‚àÉ (s' : { x : R // x ‚àà S }), r‚ÇÅ * ‚Üës' = r‚ÇÇ * ‚Üës'","name":"OreLocalization.OreSet.ore_left_cancel","isProp":true,"docString":"Common factors on the left can be turned into common factors on the right, a weak form of\ncancellability. "},{"type":"‚àÄ {n : ‚Ñï}, Function.Injective Fin.succAbove","name":"Fin.succAbove_left_injective","isProp":true,"docString":"`succAbove` is injective at the pivot "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] {P : (a : Submodule R M) ‚Üí Prop}\n  (hgt : ‚àÄ (I : Submodule R M) (a : ‚àÄ (J : Submodule R M) (a : J > I), P J), P I) (I : Submodule R M), P I","name":"IsNoetherian.induction","isProp":true,"docString":"If `‚àÄ I > J, P I` implies `P J`, then `P` holds for all submodules. "},{"type":"‚àÄ {M : Type u_2} [inst : Mul M] {N : Type u_1} [inst_1 : Mul N] (f : M ‚Üí‚Çô* N) (hf : Function.Surjective ‚Üëf),\n  MulHom.srange f = ‚ä§","name":"MulHom.srange_top_of_surjective","isProp":true,"docString":"The range of a surjective semigroup hom is the whole of the codomain. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] [inst_4 : TopologicalSpace Œ≤] {f : (a : Œ≤) ‚Üí Œ±} {K : Set Œ≤} (hK : IsCompact K)\n  (hf : ContinuousOn f K), BddBelow (f '' K)","name":"IsCompact.bddBelow_image","isProp":true,"docString":"A continuous function is bounded below on a compact set. "},{"type":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±] (i : Œ±) (j : Œ±), Function.Involutive fun (x : Equiv.Perm Œ±) ‚Ü¶ x * Equiv.swap i j","name":"Equiv.mul_swap_involutive","isProp":true,"docString":"A stronger version of `mul_left_injective` "},{"type":"‚àÄ {Œ≤ : Type v} {œÄ : (a : Œ≤) ‚Üí Type u_1} [inst : Fintype Œ≤] [inst_1 : (b : Œ≤) ‚Üí PseudoMetricSpace (œÄ b)]\n  [inst_2 : Nonempty Œ≤] (x : (b : Œ≤) ‚Üí œÄ b) (r : ‚Ñù),\n  Metric.closedBall x r = Set.pi Set.univ fun (b : Œ≤) ‚Ü¶ Metric.closedBall (x b) r","name":"closedBall_pi'","isProp":true,"docString":"A closed ball in a product space is a product of closed balls. See also `metric.closed_ball_pi`\nfor a version assuming `0 ‚â§ r` instead of `Nonempty Œ≤`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : DecidableEq Œ≥] (s : Finset Œ±) (t : Finset Œ≤)\n  (f : (a : Œ± √ó Œ≤) ‚Üí Finset Œ≥),\n  Finset.bunion·µ¢ (s √ó·∂† t) f = Finset.bunion·µ¢ s fun (a : Œ±) ‚Ü¶ Finset.bunion·µ¢ t fun (b : Œ≤) ‚Ü¶ f (a, b)","name":"Finset.product_bunion·µ¢","isProp":true,"docString":"See also `Finset.sup_product_left`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : LocallyCompactSpace Œ±] (a : Œ±), Continuous fun (f : C(Œ±, Œ≤)) ‚Ü¶ ‚Üëf a","name":"ContinuousMap.continuous_eval_const'","isProp":true,"docString":"See also `ContinuousMap.continuous_eval_const` "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (h : Fermat42 a b c), ‚àÉ (a0 : ‚Ñ§), ‚àÉ (b0 : ‚Ñ§), ‚àÉ (c0 : ‚Ñ§), Fermat42.Minimal a0 b0 c0","name":"Fermat42.exists_minimal","isProp":true,"docString":"if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CanonicallyLinearOrderedAddMonoid Œ±] [inst_1 : Sub Œ±] [inst_2 : OrderedSub Œ±] {a : Œ±} {b : Œ±}\n  {c : Œ±} [inst_3 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (h : c ‚â§ a), (a - c < b - c : Prop) ‚Üî (a < b : Prop)","name":"tsub_lt_tsub_iff_right","isProp":true,"docString":"This lemma also holds for `ENNReal`, but we need a different proof for that. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 1) (hb : b ‚â§ 1), a * b < 1","name":"mul_lt_one_of_lt_of_le","isProp":true,"docString":"**Alias** of `Left.mul_lt_one_of_lt_of_le`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (x : Œ±)\n  (H :\n    ‚àÄ (y : Œ±) (a : y ‚àà s),\n      ‚àÉ (t : Set Œ±), (t ‚äÜ s : Prop) ‚àß ((x ‚àà t : Prop) ‚àß ((y ‚àà t : Prop) ‚àß (IsPreconnected t : Prop) : Prop) : Prop)),\n  IsPreconnected s","name":"isPreconnected_of_forall","isProp":true,"docString":"If any point of a set is joined to a fixed point by a preconnected subset,\nthen the original set is preconnected as well. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (a : Œ± ‚Ü™ Œ≤) (a : Œ≤ ‚Ü™ Œ±), Nonempty (Œ± ‚âÉ Œ≤)","name":"Function.Embedding.antisymm","isProp":true,"docString":"**The Schr√∂der-Bernstein Theorem**: Given embeddings `Œ± ‚Ü™ Œ≤` and `Œ≤ ‚Ü™ Œ±`, there exists an\nequivalence `Œ± ‚âÉ Œ≤`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±], IsAddGroupHom Neg.neg","name":"Neg.isAddGroupHom","isProp":true,"docString":"Negation is an `AddGroup` homomorphism if the `AddGroup` is commutative."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : AddCommMonoid Œ±] {m : ‚Ñï} (a : (a : Fin m) ‚Üí Œ±) (b : (a : Fin m) ‚Üí Œ±),\n  Matrix.dotProduct·µ£ a b = Matrix.dotProduct a b","name":"Matrix.dotProduct·µ£_eq","isProp":true,"docString":"This can be used to prove\n```lean\nexample (a b c d : Œ±) [Mul Œ±] [AddCommMonoid Œ±] :\n  dot_product ![a, b] ![c, d] = a * c + b * d :=\n(dot_product·µ£_eq _ _).symm\n```\n"},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), (H = ‚ä• : Prop) ‚à® (Nontrivial { x : G // x ‚àà H } : Prop)","name":"AddSubgroup.bot_or_nontrivial","isProp":true,"docString":"A subgroup is either the trivial subgroup or nontrivial."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : SMul ùïú E] {s : Set E},\n  (Convex ùïú s : Prop) ‚Üî (‚àÄ ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 ‚â§ a) (a_2 : 0 ‚â§ b) (a_3 : a + b = 1), a ‚Ä¢ s + b ‚Ä¢ s ‚äÜ s : Prop)","name":"convex_iff_pointwise_add_subset","isProp":true,"docString":"Alternative definition of set convexity, in terms of pointwise set operations. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} (h_mono : Monotone f) (h_surj : Function.Surjective f), Continuous f","name":"Monotone.continuous_of_surjective","isProp":true,"docString":"A monotone surjective function with a densely ordered codomain is continuous. "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (self : C ‚âå D)\n  (X : C),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.functor self))\n        ((CategoryTheory.Iso.hom (CategoryTheory.Equivalence.unitIso self)).app X) ‚â´\n      (CategoryTheory.Iso.hom (CategoryTheory.Equivalence.counitIso self)).app\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.functor self)) X) =\n    ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.functor self)) X)","name":"CategoryTheory.Equivalence.functor_unitIso_comp","isProp":true,"docString":"The natural isomorphism compose to the identity "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M) (s : Function.Surjective ‚Üëf), Function.Injective ‚Üëf","name":"IsNoetherian.injective_of_surjective_endomorphism","isProp":true,"docString":"Any surjective endomorphism of a Noetherian module is injective. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedMonoid Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"CanonicallyLinearOrderedMonoid.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Infinite Œ±] (s : Finset Œ±) (n : ‚Ñï) (hn : Finset.card s ‚â§ n),\n  ‚àÉ (t : Finset Œ±), (s ‚äÜ t : Prop) ‚àß (Finset.card t = n : Prop)","name":"Infinite.exists_superset_card_eq","isProp":true,"docString":"See `Infinite.exists_subset_card_eq` for a version that provides an arbitrary\n`s : Finset Œ±` for any cardinality. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (self : GroupSeminorm G) (x : G) (y : G),\n  GroupSeminorm.toFun self (x * y) ‚â§ GroupSeminorm.toFun self x + GroupSeminorm.toFun self y","name":"GroupSeminorm.mul_le'","isProp":true,"docString":"The seminorm applied to a product is dominated by the sum of the seminorm applied to the\nfactors. "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±], (sup·µ¢ fun (x : Œ±) ‚Ü¶ nhds (x, x)) ‚â§ uniformity Œ±","name":"sup·µ¢_nhds_le_uniformity","isProp":true,"docString":"Entourages are neighborhoods of the diagonal. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a ‚â§ b), a - b ‚â§ 0","name":"sub_nonpos_of_le","isProp":true,"docString":"**Alias** of the reverse direction of `sub_nonpos`."},{"type":"‚àÄ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\n  [inst_2 : CategoryTheory.Preadditive C] [inst_3 : CategoryTheory.Preadditive D] {F : C ‚•§ D}\n  [self : CategoryTheory.Functor.Additive F] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y},\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (f + g) =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f + Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) g","name":"CategoryTheory.Functor.Additive.map_add","isProp":true,"docString":"the addition of two morphisms is mapped to the sum of their images "},{"type":"‚àÄ (J : Type u_1) (C : Type u_2) [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.Category C],\n  CategoryTheory.Idempotents.toKaroubi (J ‚•§ C) ‚ãô CategoryTheory.Idempotents.karoubiFunctorCategoryEmbedding J C =\n    Prefunctor.obj\n      (CategoryTheory.Functor.toPrefunctor (CategoryTheory.whiskeringRight J C (CategoryTheory.Idempotents.Karoubi C)))\n      (CategoryTheory.Idempotents.toKaroubi C)","name":"CategoryTheory.Idempotents.toKaroubi_comp_karoubiFunctorCategoryEmbedding","isProp":true,"docString":"The composition of `(J ‚•§ C) ‚•§ Karoubi (J ‚•§ C)` and `Karoubi (J ‚•§ C) ‚•§ (J ‚•§ Karoubi C)`\nequals the functor `(J ‚•§ C) ‚•§ (J ‚•§ Karoubi C)` given by the composition with\n`toKaroubi C : C ‚•§ Karoubi C`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictAnti f) (hg : StrictAnti g), StrictAnti fun (x : Œ≤) ‚Ü¶ f x * g x","name":"StrictAnti.mul'","isProp":true,"docString":"The product of two strictly antitone functions is strictly antitone. "},{"type":"‚àÄ {Œ± : Type uu} [inst : DecidableEq Œ±] {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±}\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà l‚ÇÅ), List.count x l‚ÇÅ ‚â§ List.count x l‚ÇÇ), l‚ÇÅ ++ List.diff l‚ÇÇ l‚ÇÅ ~ l‚ÇÇ","name":"List.subperm_append_diff_self_of_count_le","isProp":true,"docString":"The list version of `add_tsub_cancel_of_le` for multisets. "},{"type":"‚àÄ {Œ± : Type u_1} [self : ConditionallyCompleteLinearOrder Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"ConditionallyCompleteLinearOrder.le_total","isProp":true,"docString":"A `ConditionallyCompleteLinearOrder` is total. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} {t : Set Œ±} (a : s ‚äÇ t), s < t","name":"HasSSubset.SSubset.lt","isProp":true,"docString":"**Alias** of the reverse direction of `Set.lt_iff_ssubset`."},{"type":"‚àÄ {a : Prop} {b : Prop} {c : Prop},\n  (((a : Prop) ‚àß (b : Prop) : Prop) ‚à® (c : Prop) : Prop) ‚Üî\n    (((a : Prop) ‚à® (c : Prop) : Prop) ‚àß ((b : Prop) ‚à® (c : Prop) : Prop) : Prop)","name":"and_or_right","isProp":true,"docString":"`‚à®` distributes over `‚àß` (on the right). "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} [inst_4 : Nontrivial k] {p : (a : Œπ) ‚Üí P} (ha : AffineIndependent k p) (i : Œπ)\n  (s : Set Œπ), ¬¨(p i ‚àà affineSpan k (p '' (s \\ {i})) : Prop)","name":"AffineIndependent.not_mem_affineSpan_diff","isProp":true,"docString":"If a family is affinely independent, a point in the family is not\nin the affine span of the other points, if the underlying ring is\nnontrivial. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} (h : padicNorm p q = 0), q = 0","name":"padicNorm.zero_of_padicNorm_eq_zero","isProp":true,"docString":"If the `p`-adic norm of `q` is 0, then `q` is `0`. "},{"type":"‚àÄ {R : Type u} {œÉ : Type v} [inst : CommRing R] {I : Ideal R} {f : MvPolynomial œÉ R},\n  (f ‚àà Ideal.map MvPolynomial.C I : Prop) ‚Üî (‚àÄ (m : œÉ ‚Üí‚ÇÄ ‚Ñï), MvPolynomial.coeff m f ‚àà I : Prop)","name":"MvPolynomial.mem_map_C_iff","isProp":true,"docString":"The push-forward of an ideal `I` of `R` to `MvPolynomial œÉ R` via inclusion\nis exactly the set of polynomials whose coefficients are in `I` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst : TopologicalSpace.SecondCountableTopology Œ±], Set.Countable (setOf fun (x : Œ±) ‚Ü¶ ‚àÉ (y : Œ±), x ‚ãñ y)","name":"countable_setOf_covby_right","isProp":true,"docString":"The set of points which are isolated on the right is countable when the space is\nsecond-countable. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : PseudoMetricSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {x‚ÇÄ : Œ≤},\n  (EquicontinuousAt F x‚ÇÄ : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n        ‚àÉ (Œ¥ : ‚Ñù), (Œ¥ > 0 : Prop) ‚àß (‚àÄ (x : Œ≤) (a : dist x x‚ÇÄ < Œ¥) (i : Œπ), dist (F i x‚ÇÄ) (F i x) < Œµ : Prop) :\n      Prop)","name":"Metric.equicontinuousAt_iff","isProp":true,"docString":"Characterization of equicontinuity for families of functions between (pseudo) metric spaces. "},{"type":"‚àÄ {Œ± : Type u} (ls : List (List Œ±)) [inst : DecidableEq Œ±] (x : Œ±) (hx : ‚àÄ (l : List Œ±) (a : l ‚àà ls), ¬¨(x ‚àà l : Prop))\n  (hls : ls ‚â† []), List.splitOn x (List.intercalate [x] ls) = ls","name":"List.splitOn_intercalate","isProp":true,"docString":"`splitOn x` is the left inverse of `intercalate [x]`, on the domain\nconsisting of each nonempty list of lists `ls` whose elements do not contain `x`  "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {S : Type u_2} {F : Filter Œπ} [inst : Filter.NeBot F] [inst : CompleteLinearOrder R]\n  [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R] [inst_3 : CompleteLinearOrder S]\n  [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {f : (a : R) ‚Üí S} (f_incr : Monotone f) (a : (a : Œπ) ‚Üí R)\n  (f_cont : ContinuousAt f (Filter.liminf a F)), f (Filter.liminf a F) = Filter.liminf (f ‚àò a) F","name":"Monotone.map_liminf_of_continuousAt","isProp":true,"docString":"A continuous monotone function between complete linear ordered spaces sends a `Filter.liminf`\nto the `Filter.liminf` of the images. "},{"type":"‚àÄ (R : Type u_1) (M : Type u_2) [inst : AddCommMonoid M] [inst_1 : CommRing R] [h : AddMonoid.Fg M],\n  Algebra.FiniteType R (AddMonoidAlgebra R M)","name":"AddMonoidAlgebra.finiteType_of_fg","isProp":true,"docString":"If an additive monoid `M` is finitely generated then `AddMonoidAlgebra R M` is of finite\ntype. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictMono f) (hg : Monotone g), StrictMono fun (x : Œ≤) ‚Ü¶ f x + g x","name":"StrictMono.add_monotone","isProp":true,"docString":"The sum of a strictly monotone function and a monotone function is\nstrictly monotone."},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (q : ‚Ñö) (r : ‚Ñö), padicNorm p (q + r) ‚â§ padicNorm p q + padicNorm p r","name":"padicNorm.triangle_ineq","isProp":true,"docString":"The `p`-adic norm respects the triangle inequality: the norm of `p + q` is at most the norm of\n`p` plus the norm of `q`. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} (a : Set.Nontrivial s), Set.Nonempty (Set.offDiag s)","name":"Set.Nontrivial.offDiag_nonempty","isProp":true,"docString":"**Alias** of the reverse direction of `Set.offDiag_nonempty`."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} (h : Set.Nonempty ‚Üës) (v : V),\n  (v ‚àà AffineSubspace.direction s : Prop) ‚Üî\n    (‚àÉ (p1 : P), (p1 ‚àà s : Prop) ‚àß (‚àÉ (p2 : P), (p2 ‚àà s : Prop) ‚àß (v = p1 -·µ• p2 : Prop) : Prop) : Prop)","name":"AffineSubspace.mem_direction_iff_eq_vsub","isProp":true,"docString":"A vector is in the direction of a nonempty affine subspace if and only if it is the subtraction\nof two vectors in the subspace. "},{"type":"‚àÄ {Œπ : Type u_2} {œÄ : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)] [inst_1 : (i : Œπ) ‚Üí Zero (œÄ i)]\n  [inst_2 : DecidableEq Œπ] (i : Œπ), Continuous fun (x : œÄ i) ‚Ü¶ Pi.single i x","name":"continuous_single","isProp":true,"docString":"`Pi.single i x` is continuous in `x`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : T2Space Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (h : Continuous f), IsClosedMap f","name":"Continuous.isClosedMap","isProp":true,"docString":"A continuous map from a compact space to a Hausdorff space is a closed map. "},{"type":"‚àÄ {Œ± : Type u} (e : Equiv.Perm Œ±) (p : Equiv.Perm Œ±), ‚Üë(Equiv.permCongr e) p = e * p * e‚Åª¬π","name":"Equiv.Perm.permCongr_eq_mul","isProp":true,"docString":"If `e` is also a permutation, we can write `permCongr`\ncompletely in terms of the group structure. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {m : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} {s : Set Œ±} (a : MeasurableSet s),\n  MeasurableSet (Sum.inl '' s)","name":"MeasurableSet.inl_image","isProp":true,"docString":"**Alias** of the reverse direction of `measurableSet_inl_image`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±}\n  (hs : s ‚àà Finset.upShadow ùíú), ‚àÉ (t : Finset Œ±), (t ‚àà ùíú : Prop) ‚àß (t ‚äÜ s : Prop)","name":"Finset.exists_subset_of_mem_upShadow","isProp":true,"docString":"Being in the upper shadow of `ùíú` means we have a superset in `ùíú`. "},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocRing Œ±] (a : Œ±), 0 * a = 0","name":"NonUnitalNonAssocRing.zero_mul","isProp":true,"docString":"Zero is a left absorbing element for multiplication "},{"type":"‚àÄ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a","name":"AddCommute.refl","isProp":true,"docString":"Any element commutes with itself."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : SuccOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a < SuccOrder.succ b), a ‚â§ b","name":"SuccOrder.le_of_lt_succ","isProp":true,"docString":"Proof that `succ` satifies ordering invariants betweeen `LE` and `LT`"},{"type":"‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : Semiring A]\n  [inst_3 : Algebra R A] [inst_4 : StarRing A] [inst_5 : StarModule R A] {s : Set A}\n  {p : (a : { x : A // x ‚àà StarSubalgebra.adjoin R s }) ‚Üí Prop} (a : { x : A // x ‚àà StarSubalgebra.adjoin R s })\n  (Hs :\n    ‚àÄ (x : A) (h : x ‚àà s),\n      p\n        { val := x,\n          property :=\n            ((StarSubalgebra.subset_adjoin R s\n                  h=:x ‚àà ‚Üë(StarSubalgebra.adjoin R s))=:x ‚àà ‚Üë(StarSubalgebra.adjoin R s)) })\n  (Halg : ‚àÄ (r : R), p (‚Üë(algebraMap R { x : A // x ‚àà StarSubalgebra.adjoin R s }) r))\n  (Hadd :\n    ‚àÄ (x : { x : A // x ‚àà StarSubalgebra.adjoin R s }) (y : { x : A // x ‚àà StarSubalgebra.adjoin R s }) (a : p x)\n      (a : p y), p (x + y))\n  (Hmul :\n    ‚àÄ (x : { x : A // x ‚àà StarSubalgebra.adjoin R s }) (y : { x : A // x ‚àà StarSubalgebra.adjoin R s }) (a : p x)\n      (a : p y), p (x * y))\n  (Hstar : ‚àÄ (x : { x : A // x ‚àà StarSubalgebra.adjoin R s }) (a : p x), p (star x)), p a","name":"StarSubalgebra.adjoin_induction'","isProp":true,"docString":"The difference with `StarSubalgebra.adjoin_induction` is that this acts on the subtype. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  (h : Function.Injective ‚Üë(algebraMap R A)) (p : ‚Ñï) [inst : CharP R p], CharP A p","name":"charP_of_injective_algebraMap","isProp":true,"docString":"If the algebra map `R ‚Üí+* A` is injective then `A` has the same characteristic as `R`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] [inst_4 : ContinuousAdd Œ≥] {f : (a : Œ±) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ≥} (hf : UpperSemicontinuous f) (hg : UpperSemicontinuous g),\n  UpperSemicontinuous fun (z : Œ±) ‚Ü¶ f z + g z","name":"UpperSemicontinuous.add","isProp":true,"docString":"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. "},{"type":"‚àÄ {F : PFunctor} {R : (a : PFunctor.M F) ‚Üí (a : PFunctor.M F) ‚Üí Prop} (self : PFunctor.M.IsBisimulation R)\n  {a : PFunctor.A F} {a' : PFunctor.A F} {f : (a : PFunctor.B F a) ‚Üí PFunctor.M F}\n  {f' : (a : PFunctor.B F a') ‚Üí PFunctor.M F}\n  (a_1 : R (PFunctor.M.mk { fst := a, snd := f }) (PFunctor.M.mk { fst := a', snd := f' })), a = a'","name":"PFunctor.M.IsBisimulation.head","isProp":true,"docString":"The head of the trees are equal "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i) < Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (¬¨(Monovary (f ‚àò ‚ÜëœÉ) g : Prop) : Prop)","name":"Monovary.sum_comp_perm_mul_lt_sum_mul_iff","isProp":true,"docString":"**Strict inequality case of Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (ha : 0 < a) (hb : 0 < b), 0 < a + b","name":"Right.add_pos","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  (hfg : MonovaryOn f g ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i) * Finset.sum s fun (i : Œπ) ‚Ü¶ g i) ‚â§\n    ‚Üë(Finset.card s) * Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i","name":"MonovaryOn.sum_mul_sum_le_card_mul_sum","isProp":true,"docString":"**Chebyshev's Sum Inequality**: When `f` and `g` monovary together (eg they are both\nmonotone/antitone), the product of their sum is less than the size of the set times their scalar\nproduct. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] (f : V ‚Üí‚Çó[K] V‚ÇÇ) (w : Function.Injective ‚Üëf)\n  [inst_5 : FiniteDimensional K V‚ÇÇ], FiniteDimensional K V","name":"FiniteDimensional.of_injective","isProp":true,"docString":"If the codomain of an injective linear map is finite dimensional, the domain must be as well. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (I : Ideal R) (h : Ideal.Fg I),\n  (IsIdempotentElem I : Prop) ‚Üî (‚àÉ (e : R), (IsIdempotentElem e : Prop) ‚àß (I = Submodule.span R {e} : Prop) : Prop)","name":"Ideal.isIdempotentElem_iff_of_fg","isProp":true,"docString":"A finitely generated idempotent ideal is generated by an idempotent element "},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module R E] [inst_4 : Module R F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : ContinuousAdd E] [inst_8 : ContinuousAdd F] [inst_9 : TopologicalSpace R] [inst_10 : ContinuousSMul R E]\n  [inst_11 : ContinuousSMul R F] (f : E ‚Üí‚Çó.[R] F), LinearPMap.HasCore (LinearPMap.closure f) (LinearPMap.domain f)","name":"LinearPMap.closureHasCore","isProp":true,"docString":"For every unbounded operator `f` the submodule `f.domain` is a core of its closure.\n\nNote that we don't require that `f` is closable, due to the definition of the closure. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictMonoOn f s) (hg : MonotoneOn g s), StrictMonoOn (fun (x : Œ≤) ‚Ü¶ f x + g x) s","name":"StrictMonoOn.add_monotone","isProp":true,"docString":"The sum of a strictly monotone function and a monotone function is\nstrictly monotone."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ioc (f n) (f (Order.succ n)))","name":"Monotone.pairwise_disjoint_on_Ioc_succ","isProp":true,"docString":"If `Œ±` is a linear succ order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is a monotone function, then\nthe intervals `Set.Ioc (f n) (f (Order.succ n))` are pairwise disjoint. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeInf Œ±] (s : Set Œ±) (a : Œ±) (a_1 : a ‚àà s), inf‚Çõ s ‚â§ a","name":"CompleteSemilatticeInf.inf‚Çõ_le","isProp":true,"docString":"Any element of a set is more than the set infimum. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : RankCondition R] {M : Type v} [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  {Œπ : Type u_1} (b : Basis Œπ R M) {w : Set M} [inst_4 : Fintype ‚Üëw] (s : Submodule.span R w = ‚ä§),\n  Cardinal.mk Œπ ‚â§ ‚Üë(Fintype.card ‚Üëw)","name":"basis_le_span'","isProp":true,"docString":"Another auxiliary lemma for `Basis.le_span`, which does not require assuming the basis is finite,\nbut still assumes we have a finite spanning set.\n"},{"type":"‚àÄ {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {Œ≤ : (a : Œπ) ‚Üí Type w} [inst : (i : Œπ) ‚Üí AddCommMonoid (Œ≤ i)] {Œ≥ : Type u_1}\n  [inst_1 : AddMonoid Œ≥] ‚¶Éf : (DirectSum Œπ fun (i : Œπ) ‚Ü¶ Œ≤ i) ‚Üí+ Œ≥‚¶Ñ ‚¶Ég : (DirectSum Œπ fun (i : Œπ) ‚Ü¶ Œ≤ i) ‚Üí+ Œ≥‚¶Ñ\n  (H :\n    ‚àÄ (i : Œπ),\n      AddMonoidHom.comp f (DirectSum.of (fun (i : Œπ) ‚Ü¶ Œ≤ i) i) =\n        AddMonoidHom.comp g (DirectSum.of (fun (i : Œπ) ‚Ü¶ Œ≤ i) i)),\n  f = g","name":"DirectSum.addHom_ext'","isProp":true,"docString":"If two additive homomorphisms from `‚®Å i, Œ≤ i` are equal on each `of Œ≤ i y`,\nthen they are equal.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {p : Filter Œπ} [inst : UniformSpace Œ≤] {ùîñ : Set (Set Œ±)}\n  {F : (a : Œπ) ‚Üí UniformOnFun Œ± Œ≤ ùîñ} {f : UniformOnFun Œ± Œ≤ ùîñ},\n  (Filter.Tendsto F p (nhds f) : Prop) ‚Üî (‚àÄ (s : Set Œ±) (a : s ‚àà ùîñ), TendstoUniformlyOn F f p s : Prop)","name":"UniformOnFun.tendsto_iff_tendstoUniformlyOn","isProp":true,"docString":"Convergence in the topology of `ùîñ`-convergence means uniform convergence on `S` (in the sense\nof `TendstoUniformlyOn`) for all `S ‚àà ùîñ`. "},{"type":"‚àÄ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [self : LeftDistribClass R] (a : R) (b : R) (c : R),\n  a * (b + c) = a * b + a * c","name":"LeftDistribClass.left_distrib","isProp":true,"docString":"Multiplication is left distributive over addition "},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_1} {M : Type u_2} {v : (a : Œπ) ‚Üí M} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Fintype Œπ],\n  (LinearIndependent R v : Prop) ‚Üî\n    (LinearMap.ker (‚Üë(LinearMap.lsum R (fun (x : Œπ) ‚Ü¶ R) ‚Ñï) fun (i : Œπ) ‚Ü¶ LinearMap.smulRight LinearMap.id (v i)) = ‚ä• :\n      Prop)","name":"Fintype.linearIndependent_iff'","isProp":true,"docString":"A finite family of vectors `v i` is linear independent iff the linear map that sends\n`c : Œπ ‚Üí R` to `‚àë i, c i ‚Ä¢ v i` has the trivial kernel. "},{"type":"‚àÄ (k : Type u‚ÇÅ) {G : Type u‚ÇÇ} {R : Type u_1} [inst : Semiring k] [inst_1 : DistribSMul R k] [inst_2 : Mul G]\n  [inst_3 : SMulCommClass R k k], SMulCommClass R (MonoidAlgebra k G) (MonoidAlgebra k G)","name":"MonoidAlgebra.sMulCommClass_self","isProp":true,"docString":"Note that if `k` is a `CommSemiring` then we have `SMulCommClass k k k` and so we can take\n`R = k` in the below. In other words, if the coefficients are commutative amongst themselves, they\nalso commute with the algebra multiplication. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {x : Œ±} (fin : EMetric.hausdorffEdist s t ‚â† ‚ä§),\n  Metric.infDist x t ‚â§ Metric.infDist x s + Metric.hausdorffDist s t","name":"Metric.infDist_le_infDist_add_hausdorffDist","isProp":true,"docString":"The infimum distance to `s` and `t` are the same, up to the Hausdorff distance\nbetween `s` and `t` "},{"type":"‚àÄ {R : Type u} {Œπ : Type v} {M‚ÇÅ : (a : Œπ) ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] [inst_5 : (i : Œπ) ‚Üí TopologicalSpace (M‚ÇÅ i)] [inst_6 : TopologicalSpace M‚ÇÇ]\n  (f : ContinuousMultilinearMap R M‚ÇÅ M‚ÇÇ) {Œ± : (a : Œπ) ‚Üí Type u_1} [inst_7 : Fintype Œπ] (g : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí M‚ÇÅ i)\n  [inst_8 : DecidableEq Œπ] [inst_9 : (i : Œπ) ‚Üí Fintype (Œ± i)],\n  (‚Üëf fun (i : Œπ) ‚Ü¶ Finset.sum Finset.univ fun (j : Œ± i) ‚Ü¶ g i j) =\n    Finset.sum Finset.univ fun (r : (i : Œπ) ‚Üí Œ± i) ‚Ü¶ ‚Üëf fun (i : Œπ) ‚Ü¶ g i (r i)","name":"ContinuousMultilinearMap.map_sum","isProp":true,"docString":"If `f` is continuous multilinear, then `f (Œ£_{j‚ÇÅ} g‚ÇÅ j‚ÇÅ, ..., Œ£_{j‚Çô} g‚Çô j‚Çô)` is the sum of\n`f (g‚ÇÅ (r 1), ..., g‚Çô (r n))` where `r` ranges over all functions `r`. This follows from\nmultilinearity by expanding successively with respect to each coordinate. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±}, Set.range Subtype.val = s","name":"Subtype.range_val","isProp":true,"docString":"A variant of `range_coe`. Try to use `range_coe` if possible.\nThis version is useful when defining a new type that is defined as the subtype of something.\nIn that case, the coercion doesn't fire anymore. "},{"type":"‚àÄ {G : Type w} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousAdd G] {Œì : AddSubgroup G}\n  [inst_3 : TopologicalSpace.SecondCountableTopology G], TopologicalSpace.SecondCountableTopology (G ‚ß∏ Œì)","name":"QuotientAddGroup.secondCountableTopology","isProp":true,"docString":"The quotient of a second countable additive topological group by a subgroup is second\ncountable."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : ProperSpace Œ±] (hc : IsClosed s)\n  (hb : Metric.Bounded s), IsCompact s","name":"Metric.isCompact_of_isClosed_bounded","isProp":true,"docString":"The **Heine‚ÄìBorel theorem**: In a proper space, a closed bounded set is compact. "},{"type":"‚àÄ (M : Type u_2) {Œ± : Type u_1} [inst : Monoid M] [inst_1 : MulAction M Œ±], (fun (x : M) (x_1 : Œ±) ‚Ü¶ x ‚Ä¢ x_1) 1 = id","name":"one_smul_eq_id","isProp":true,"docString":"`SMul` version of `one_mul_eq_id` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {b : M}\n  [inst_1 : LinearOrderedCommSemiring M] (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚àà t) (ht : Finset.Nonempty t)\n  (hb : Finset.card t ‚Ä¢ b ‚â§ ‚Üë(Finset.card s)),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (b ‚â§ ‚Üë(Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s)) : Prop)","name":"Finset.exists_le_card_fiber_of_nsmul_le_card_of_maps_to","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by heads: given a function between\nfinite sets `s` and `t` and a number `b` such that `card t ‚Ä¢ b ‚â§ card s`, there exists `y ‚àà t` such\nthat its preimage in `s` has at least `b` elements.\nSee also `Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to` for a stronger statement. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±}\n  {p : Filter Œπ} {g : (a : Œπ) ‚Üí Œ±} [inst_1 : TopologicalSpace Œ±] (h : ContinuousAt f x)\n  (hg : Filter.Tendsto g p (nhds x))\n  (hunif :\n    ‚àÄ (u : Set (Œ≤ √ó Œ≤)) (a : u ‚àà uniformity Œ≤),\n      ‚àÉ (t : Set Œ±),\n        (t ‚àà nhds x : Prop) ‚àß (Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (y : Œ±) (a : y ‚àà t), (f y, F n y) ‚àà u) p : Prop)),\n  Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n (g n)) p (nhds (f x))","name":"tendsto_comp_of_locally_uniform_limit","isProp":true,"docString":"If `F‚Çô` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `g‚Çô` tends to `x`, then `F‚Çô (g‚Çô)` tends to `f x`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {d : AddCon M} {x : M} {y : M},\n  (‚Üë(c ‚äì d) x y : Prop) ‚Üî ((‚Üëc x y : Prop) ‚àß (‚Üëd x y : Prop) : Prop)","name":"AddCon.inf_iff_and","isProp":true,"docString":"Definition of the infimum of two additive congruence relations."},{"type":"‚àÄ {Œ± : Type u} [inst : StrictOrderedSemiring Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} [inst_1 : ExistsAddOfLE Œ±] (hba : b ‚â§ a)\n  (hdc : d ‚â§ c), a ‚Ä¢ d + b ‚Ä¢ c ‚â§ a ‚Ä¢ c + b ‚Ä¢ d","name":"mul_add_mul_le_mul_add_mul'","isProp":true,"docString":"Binary **rearrangement inequality**. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {a : Œ±} {bot : Œ±} (ha : Acc r a) {C : (a : Œ≤) ‚Üí Prop}\n  {f : (a : Œ±) ‚Üí Œ≤} (ih : ‚àÄ (b : Œ±) (a : f b ‚â† f bot) (a : C (f b)), ‚àÉ (c : Œ±), (r c b : Prop) ‚àß (C (f c) : Prop))\n  (a : C (f a)), C (f bot)","name":"Acc.induction_bot'","isProp":true,"docString":"Let `r` be a relation on `Œ±`, let `f : Œ± ‚Üí Œ≤` be a function, let `C : Œ≤ ‚Üí Prop`, and\nlet `bot : Œ±`. This induction principle shows that `C (f bot)` holds, given that\n* some `a` that is accessible by `r` satisfies `C (f a)`, and\n* for each `b` such that `f b ‚â† f bot` and `C (f b)` holds, there is `c`\n  satisfying `r c b` and `C (f c)`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Lattice Œ±] [inst_1 : Lattice Œ≤]\n  [self : LatticeHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a ‚äì b) = ‚Üëf a ‚äì ‚Üëf b","name":"LatticeHomClass.map_inf","isProp":true,"docString":"A `LatticeHomClass` morphism preserves infima. "},{"type":"‚àÄ {Œ± : Type u_1} {m : ‚Ñï} {n : ‚Ñï} (A : Matrix (Fin m) (Fin n) Œ±), Matrix.etaExpand A = A","name":"Matrix.etaExpand_eq","isProp":true,"docString":"This can be used to prove\n```lean\nexample (A : Matrix (Fin 2) (Fin 2) Œ±) :\n  A = !![A 0 0, A 0 1;\n         A 1 0, A 1 1] :=\n(etaExpand_eq _).symm\n```\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasColimitsOfSize C] (J : Type u‚ÇÅ)\n  [inst_1 : CategoryTheory.Category J], CategoryTheory.Limits.HasColimitsOfShape J C","name":"CategoryTheory.Limits.HasColimitsOfSize.has_colimits_of_shape","isProp":true,"docString":"All `F : J ‚•§ C` have colimits for all small `J` "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasProducts C],\n  CategoryTheory.Limits.HasFiniteProducts C","name":"CategoryTheory.Limits.hasFiniteProducts_of_hasProducts","isProp":true,"docString":"If a category has all products then in particular it has finite products.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ≤] [inst_2 : SuccOrder Œ≤]\n  [inst_3 : IsSuccArchimedean Œ≤] {s : (a : Œ≤) ‚Üí Set Œ±} {t : Set Œ≤} (ht : Set.OrdConnected t)\n  (H : ‚àÄ (n : Œ≤) (a : n ‚àà t), IsPreconnected (s n))\n  (K : ‚àÄ (n : Œ≤) (a : n ‚àà t) (a : Order.succ n ‚àà t), Set.Nonempty (s n ‚à© s (Order.succ n))),\n  IsPreconnected (Set.union·µ¢ fun (n : Œ≤) ‚Ü¶ Set.union·µ¢ fun (h : n ‚àà t) ‚Ü¶ s n)","name":"IsPreconnected.bunion·µ¢_of_chain","isProp":true,"docString":"The union·µ¢ of preconnected sets indexed by a subset of a type with an archimedean successor\n(like `‚Ñï` or `‚Ñ§`) such that any two neighboring sets meet is preconnected. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {s : Set Œ±} (hf : Equiv.Perm.IsCycleOn f s) (hs : Set.Nontrivial s),\n  Equiv.Perm.IsCycle\n    (Equiv.Perm.subtypePerm f\n      (fun (x : Œ±) ‚Ü¶ (_ : (x ‚àà s : Prop) ‚Üî (‚Üëf x ‚àà s : Prop))=:‚àÄ (x : Œ±), (x ‚àà s : Prop) ‚Üî (‚Üëf x ‚àà s : Prop)))","name":"Equiv.Perm.IsCycleOn.isCycle_subtypePerm","isProp":true,"docString":"Note that the identity satisfies `IsCycleOn` for any subsingleton set, but not `IsCycle`. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Ring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] [inst_5 : Nonempty Œπ] (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) (p : (i : Œπ) ‚Üí Submodule R (M‚ÇÅ i)),\n  Set.Nonempty ‚Üë(MultilinearMap.map f p)","name":"MultilinearMap.map_nonempty","isProp":true,"docString":"The map is always nonempty. This lemma is needed to apply `SubMulAction.zero_mem`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±}\n  {s : Set Œ±} (a : ContinuousWithinAt f s x), ContinuousWithinAt f (insert x s) x","name":"ContinuousWithinAt.insert_self","isProp":true,"docString":"**Alias** of the reverse direction of `continuousWithinAt_insert_self`."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {m : ‚Ñï} {n : ‚Ñï} (s : Affine.Simplex k P m) (e : Fin (m + 1) ‚âÉ Fin (n + 1)),\n  Set.range (Affine.Simplex.points (Affine.Simplex.reindex s e)) = Set.range (Affine.Simplex.points s)","name":"Affine.Simplex.reindex_range_points","isProp":true,"docString":"Reindexing a simplex produces one with the same set of points. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ±' : Type u_6} {Œ≤ : Type u_5} {Œ≤' : Type u_7} {Œ≥ : Type u_3} {Œ¥ : Type u_2} {Œµ : Type u_1} {s : Set Œ±}\n  {t : Set Œ≤} {u : Set Œ≥} {f : (a : Œ¥) ‚Üí (a : Œ≥) ‚Üí Œµ} {g : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {f‚ÇÅ : (a : Œ±) ‚Üí (a : Œ≥) ‚Üí Œ±'}\n  {f‚ÇÇ : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Œ≤'} {g' : (a : Œ±') ‚Üí (a : Œ≤') ‚Üí Œµ}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), f (g a b) c = g' (f‚ÇÅ a c) (f‚ÇÇ b c)),\n  Set.image2 f (Set.image2 g s t) u ‚äÜ Set.image2 g' (Set.image2 f‚ÇÅ s u) (Set.image2 f‚ÇÇ t u)","name":"Set.image2_distrib_subset_right","isProp":true,"docString":"The other direction does not hold because of the `u`-`u` cross terms on the RHS. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CanonicallyOrderedCommSemiring Œ±] [inst_1 : Sub Œ±] [inst_2 : OrderedSub Œ±]\n  [inst_3 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (m : ‚Ñï) (n : ‚Ñï),\n  ‚Üë(m - n) = ‚Üëm - ‚Üën","name":"Nat.cast_tsub","isProp":true,"docString":"A version of `Nat.cast_sub` that works for `‚Ñù‚â•0` and `‚Ñö‚â•0`. Note that this proof doesn't work\nfor `‚Ñï‚àû` and `‚Ñù‚â•0‚àû`, so we use type-specific lemmas for these types. "},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ], T5Space Œì‚ÇÄ","name":"WithZeroTopology.t5Space","isProp":true,"docString":"The topology on a linearly ordered group with zero element adjoined is T‚ÇÖ. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} {Œ≥ : Type u_1} [inst : UniformSpace Œ≤] [inst_1 : UniformSpace Œ≥] {f : (a : Œ≥) ‚Üí Œ≤}\n  (hf : UniformInducing f), UniformInducing (‚ÜëUniformFun.ofFun ‚àò (fun (x : (a : Œ±) ‚Üí Œ≥) ‚Ü¶ f ‚àò x) ‚àò ‚ÜëUniformFun.toFun)","name":"UniformFun.postcomp_uniformInducing","isProp":true,"docString":"Post-composition by a uniform inducing is a uniform inducing for the\nuniform structures of uniform convergence.\n\nMore precisely, if `f : Œ≥ ‚Üí Œ≤` is a uniform inducing, then `(Œª g, f ‚àò g) : (Œ± ‚Üí·µ§ Œ≥) ‚Üí (Œ± ‚Üí·µ§ Œ≤)` is\na uniform inducing. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] (r : ENNReal) (C : ENNReal) (hr : r < 1) (hC : C ‚â† ‚ä§) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu : ‚àÄ (n : ‚Ñï), edist (f n) (f (n + 1)) ‚â§ C * r ^ n), CauchySeq f","name":"cauchySeq_of_edist_le_geometric","isProp":true,"docString":"If `edist (f n) (f (n+1))` is bounded by `C * r^n`, `C ‚â† ‚àû`, `r < 1`,\nthen `f` is a Cauchy sequence."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : PolishSpace Œ±] [inst_2 : TopologicalSpace Œ≤]\n  [inst_3 : PolishSpace Œ≤], PolishSpace (Œ± ‚äï Œ≤)","name":"PolishSpace.sum","isProp":true,"docString":"The disjoint union of two Polish spaces is Polish. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : Group Œ±] [inst_2 : UniformGroup Œ±] {hom : Type u_1}\n  [inst_3 : UniformSpace Œ≤] [inst_4 : DiscreteTopology Œ≤] [inst_5 : Group Œ≤] [inst_6 : UniformGroup Œ≤]\n  [inst_7 : MonoidHomClass hom Œ± Œ≤] {f : hom}, (UniformContinuous ‚Üëf : Prop) ‚Üî (IsOpen ‚Üë(MonoidHom.ker ‚Üëf) : Prop)","name":"UniformGroup.uniformContinuous_iff_open_ker","isProp":true,"docString":"A homomorphism from a uniform group to a discrete uniform group is continuous if and only if\nits kernel is open. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  [inst_2 : Filter.IsCountablyGenerated (uniformity Œ≤)] (f : (a : Œ±) ‚Üí Œ≤), IsGŒ¥ (setOf fun (x : Œ±) ‚Ü¶ ContinuousAt f x)","name":"isGŒ¥_setOf_continuousAt","isProp":true,"docString":"The set of points where a function is continuous is a GŒ¥ set. "},{"type":"‚àÄ {R : Type u} [self : InvolutiveStar R], Function.Involutive star","name":"InvolutiveStar.star_involutive","isProp":true,"docString":"Involutive condition. "},{"type":"‚àÄ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {W : CategoryTheory.MorphismProperty C} {E : Type u_5} [inst_2 : CategoryTheory.Category E]\n  (self : CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L W E) (F‚ÇÅ : D ‚•§ E) (F‚ÇÇ : D ‚•§ E)\n  (x : L ‚ãô F‚ÇÅ = L ‚ãô F‚ÇÇ), F‚ÇÅ = F‚ÇÇ","name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.uniq","isProp":true,"docString":"uniqueness of the lifted functor "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} {b : Œ±} (ha : 0 < a) (hb : 0 < b),\n  (a‚Åª¬π ‚â§ b : Prop) ‚Üî (b‚Åª¬π ‚â§ a : Prop)","name":"inv_le","isProp":true,"docString":"In a linear ordered field, for positive `a` and `b` we have `a‚Åª¬π ‚â§ b ‚Üî b‚Åª¬π ‚â§ a`.\nSee also `inv_le_of_inv_le` for a one-sided implication with one fewer assumption. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 : AffineSubspace k P) (s2 : AffineSubspace k P), (s1 < s2 : Prop) ‚Üî (‚Üës1 ‚äÇ ‚Üës2 : Prop)","name":"AffineSubspace.lt_def","isProp":true,"docString":"The `<` order on subspaces is the same as that on the corresponding sets. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : T2Space Œ±]\n  [inst_3 : CompleteLattice Œ≤] (m : (a : Œ≤) ‚Üí Œ±) (m0 : m ‚ä• = 0) (R : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop)\n  (m_sup·µ¢ : ‚àÄ (s : (a : ‚Ñï) ‚Üí Œ≤), R (m (sup·µ¢ fun (i : ‚Ñï) ‚Ü¶ s i)) (tsum fun (i : ‚Ñï) ‚Ü¶ m (s i))) (s‚ÇÅ : Œ≤) (s‚ÇÇ : Œ≤),\n  R (m (s‚ÇÅ ‚äî s‚ÇÇ)) (m s‚ÇÅ + m s‚ÇÇ)","name":"rel_sup_add","isProp":true,"docString":"If a function is countably sub-additive then it is binary sub-additive "},{"type":"‚àÄ (Œº : YoungDiagram) {i1 : ‚Ñï} {i2 : ‚Ñï} {j1 : ‚Ñï} {j2 : ‚Ñï} (hi : i1 ‚â§ i2) (hj : j1 ‚â§ j2) (hcell : (i2, j2) ‚àà Œº),\n  (i1, j1) ‚àà Œº","name":"YoungDiagram.up_left_mem","isProp":true,"docString":"In \"English notation\", a Young diagram is drawn so that (i1, j1) ‚â§ (i2, j2)\nmeans (i1, j1) is weakly up-and-left of (i2, j2). "},{"type":"‚àÄ (n : ‚Ñï), (tsum fun (i : ‚Ñï) ‚Ü¶ if (n ‚â§ i : Prop) then 2‚Åª¬π ^ i else 0) = 2 * 2‚Åª¬π ^ n","name":"tsum_geometric_inv_two_ge","isProp":true,"docString":"The sum of `2‚Åª¬π ^ i` for `n ‚â§ i` equals `2 * 2‚Åª¬π ^ n`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ‚Üës = s","name":"AffineSubspace.affineSpan_coe","isProp":true,"docString":"Coercing a subspace to a set then taking the affine span produces the original subspace. "},{"type":"‚àÄ {Œ≤ : Type v} [inst : UniformSpace Œ≤] {Œ± : Type u_1} {f : (a : Œ±) ‚Üí Œ≤} {s : Set (Œ≤ √ó Œ≤)} (hs : s ‚àà uniformity Œ≤)\n  (hf : Pairwise fun (x : Œ±) (y : Œ±) ‚Ü¶ ¬¨((f x, f y) ‚àà s : Prop)),\n  Filter.comap (Prod.map f f) (uniformity Œ≤) = Filter.principal idRel","name":"comap_uniformity_of_spaced_out","isProp":true,"docString":"If a map `f : Œ± ‚Üí Œ≤` sends any two distinct points to point that are **not** related by a fixed\n`s ‚àà ùì§ Œ≤`, then `f` is uniform inducing with respect to the discrete uniformity on `Œ±`:\nthe preimage of `ùì§ Œ≤` under `prod.map f f` is the principal filter generated by the diagonal in\n`Œ± √ó Œ±`. "},{"type":"‚àÄ {X : Type u} [inst : Lattice X] [inst_1 : JordanHolderLattice X] {s‚ÇÅ : CompositionSeries X} {s‚ÇÇ : CompositionSeries X}\n  (hl : CompositionSeries.length s‚ÇÅ = CompositionSeries.length s‚ÇÇ)\n  (h :\n    ‚àÄ (i : Fin (CompositionSeries.length s‚ÇÅ + 1)),\n      CompositionSeries.series s‚ÇÅ i =\n        CompositionSeries.series s‚ÇÇ\n          (‚Üë(Fin.cast\n                ((congr_arg Nat.succ\n                      hl=:Nat.succ (CompositionSeries.length s‚ÇÅ) =\n                      Nat.succ\n                        (CompositionSeries.length\n                          s‚ÇÇ))=:Nat.succ (CompositionSeries.length s‚ÇÅ) = Nat.succ (CompositionSeries.length s‚ÇÇ)))\n            i)),\n  s‚ÇÅ = s‚ÇÇ","name":"CompositionSeries.ext_fun","isProp":true,"docString":"Two `CompositionSeries` are equal if they are the same length and\nhave the same `i`th element for every `i` "},{"type":"‚àÄ {k : Type u_2} {V : Type u_4} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) {w‚ÇÅ : (a : Œπ) ‚Üí k} {w‚ÇÇ : (a : Œπ) ‚Üí k}\n  (hw : ‚àÄ (i : Œπ) (a : i ‚àà s), w‚ÇÅ i = w‚ÇÇ i) {p‚ÇÅ : (a : Œπ) ‚Üí P} {p‚ÇÇ : (a : Œπ) ‚Üí P}\n  (hp : ‚àÄ (i : Œπ) (a : i ‚àà s), p‚ÇÅ i = p‚ÇÇ i), ‚Üë(Finset.weightedVSub s p‚ÇÅ) w‚ÇÅ = ‚Üë(Finset.weightedVSub s p‚ÇÇ) w‚ÇÇ","name":"Finset.weightedVSub_congr","isProp":true,"docString":"`weightedVSub` gives equal results for two families of weights and two families of points\nthat are equal on `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {S : Set (Set Œ±)}\n  (ho : ‚àÄ (s : Set Œ±) (a : s ‚àà S), IsGŒ¥ s) (hS : Set.Countable S) (hd : ‚àÄ (s : Set Œ±) (a : s ‚àà S), Dense s),\n  Dense (‚ãÇ‚ÇÄ S)","name":"dense_inter‚Çõ_of_GŒ¥","isProp":true,"docString":"Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with ‚ãÇ‚ÇÄ. "},{"type":"‚àÄ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyCompactSpace H], LocallyCompactSpace M","name":"ChartedSpace.locallyCompact","isProp":true,"docString":"If a topological space admits an atlas with locally compact charts, then the space itself\nis locally compact. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Antivary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (Antivary f (g ‚àò ‚ÜëœÉ) : Prop)","name":"Antivary.sum_smul_eq_sum_smul_comp_perm_iff","isProp":true,"docString":"**Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which antivary together, is unchanged by a permutation if and only if `f` and `g ‚àò œÉ` antivary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsGroupHom f),\n  (Function.Injective f : Prop) ‚Üî (‚àÄ (a : Œ±) (a_1 : f a = 1), a = 1 : Prop)","name":"IsGroupHom.injective_iff","isProp":true,"docString":"A group homomorphism is injective iff its kernel is trivial. "},{"type":"‚àÄ {c : Cardinal} (h : Cardinal.aleph0 ‚â§ c), c * c = c","name":"Cardinal.mul_eq_self","isProp":true,"docString":"If `Œ±` is an infinite type, then `Œ± √ó Œ±` and `Œ±` have the same cardinality. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i0 : Œπ),\n  vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i -·µ• p i0)","name":"vectorSpan_range_eq_span_range_vsub_right","isProp":true,"docString":"The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the right. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí. Œ≤ ‚äï Œ±} {a : Œ±} {a' : Œ±} (ha' : Sum.inr a' ‚àà f a), PFun.fix f a = PFun.fix f a'","name":"PFun.fix_fwd_eq","isProp":true,"docString":"If advancing one step from `a` on `f` leads to `a' : Œ±`, then `f.fix a = f.fix a'` "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} {f : (a : Fin n) ‚Üí Œ±} {g : (a : Fin n) ‚Üí Œ±}, (List.ofFn f = List.ofFn g : Prop) ‚Üî (f = g : Prop)","name":"List.ofFn_inj","isProp":true,"docString":"A special case of `List.ofFn_inj` for when the two functions are indexed by defeq `n`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {r : Set (Œ≤ √ó Œ≤)} {s : Set Œ±}\n  (hs : IsCompact s) (f : (a : Œ±) ‚Üí Œ≤) (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), ContinuousAt f a) (hr : r ‚àà uniformity Œ≤),\n  (setOf fun (x : Œ± √ó Œ±) ‚Ü¶ ‚àÄ (a : Prod.fst x ‚àà s), (f (Prod.fst x), f (Prod.snd x)) ‚àà r) ‚àà uniformity Œ±","name":"IsCompact.uniformContinuousAt_of_continuousAt","isProp":true,"docString":"If `s` is compact and `f` is continuous at all points of `s`, then `f` is\n\"uniformly continuous at the set `s`\", i.e. `f x` is close to `f y` whenever `x ‚àà s` and `y` is\nclose to `x` (even if `y` is not itself in `s`, so this is a stronger assertion than\n`UniformContinuousOn s`). "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (a : A), ‚Üëf (star a) = star (‚Üëf a)","name":"StarAlgEquivClass.map_star","isProp":true,"docString":"By definition, a ‚ãÜ-algebra equivalence preserves the `star` operation. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {a : R} {b : R},\n  a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)","name":"pow_four_add_four_mul_pow_four'","isProp":true,"docString":"Sophie Germain's identity, see <https://www.cut-the-knot.org/blue/SophieGermainIdentity.shtml>.\n"},{"type":"‚àÄ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R} (rra : IsRightRegular a) (rrb : IsRightRegular b),\n  IsRightRegular (a * b)","name":"IsRightRegular.mul","isProp":true,"docString":"In a semigroup, the product of right-regular elements is right-regular. "},{"type":"‚àÄ {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {A : V} {B : V}\n  {C : V} (f : A ‚ü∂ B) [inst_2 : CategoryTheory.Limits.HasImage f] (g : B ‚ü∂ C)\n  [inst_3 : CategoryTheory.Limits.HasKernel g] (w : f ‚â´ g = 0)\n  (h : CategoryTheory.Limits.imageSubobject f ‚â§ CategoryTheory.Limits.kernelSubobject g),\n  CategoryTheory.Subobject.ofLE (CategoryTheory.Limits.imageSubobject f) (CategoryTheory.Limits.kernelSubobject g) h =\n    imageToKernel f g w","name":"subobject_ofLE_as_imageToKernel","isProp":true,"docString":"Prefer `imageToKernel`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ‚â† 0","name":"AddSubgroup.FiniteIndex.finiteIndex","isProp":true,"docString":"The additive subgroup has finite index "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {S : D}\n  {T : C ‚•§ D} [inst_2 : CategoryTheory.WellPowered C] [inst_3 : CategoryTheory.Limits.HasLimits C]\n  [inst_4 : CategoryTheory.Limits.PreservesLimits T], CategoryTheory.WellPowered (CategoryTheory.StructuredArrow S T)","name":"CategoryTheory.StructuredArrow.wellPowered_structuredArrow","isProp":true,"docString":"If `C` is well-powered and complete and `T` preserves limits, then `StructuredArrow S T` is\nwell-powered. "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] {Œπ : Type v} (M : (a : Œπ) ‚Üí Type w)\n  [inst_2 : (i : Œπ) ‚Üí AddCommGroup (M i)] [inst_3 : (i : Œπ) ‚Üí Module R (M i)] [inst_4 : ‚àÄ (i : Œπ), Module.Free R (M i)],\n  Module.rank R (DirectSum Œπ fun (i : Œπ) ‚Ü¶ M i) = Cardinal.sum fun (i : Œπ) ‚Ü¶ Module.rank R (M i)","name":"rank_directSum","isProp":true,"docString":"The rank of the direct sum is the sum of the ranks. "},{"type":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±] [inst_1 : Finite Œ±] {P : (a : Equiv.Perm Œ±) ‚Üí Prop} (f : Equiv.Perm Œ±) (a : P 1)\n  (a : ‚àÄ (f : Equiv.Perm Œ±) (x : Œ±) (y : Œ±) (a : x ‚â† y) (a : P f), P (Equiv.swap x y * f)), P f","name":"Equiv.Perm.swap_induction_on","isProp":true,"docString":"An induction principle for permutations. If `P` holds for the identity permutation, and\nis preserved under composition with a non-trivial swap, then `P` holds for all permutations. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhds a)\n  (hfs_l : ‚àÄ (b : Œ≤) (a_1 : b < f a), ‚àÉ (c : Œ±), (c ‚àà s : Prop) ‚àß (f c ‚àà Set.Ico b (f a) : Prop))\n  (hfs_r : ‚àÄ (b : Œ≤) (a_1 : b > f a), ‚àÉ (c : Œ±), (c ‚àà s : Prop) ‚àß (f c ‚àà Set.Ioc (f a) b : Prop)), ContinuousAt f a","name":"StrictMonoOn.continuousAt_of_exists_between","isProp":true,"docString":"If a function `f` is strictly monotone on a neighborhood of `a` and the image of this\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval\n`(f a, b]`, `b > f a`, then `f` is continuous at `a`. "},{"type":"‚àÄ (œÉ : Type u_1) (R : Type u_2) [inst : CommSemiring R] [inst_1 : Fintype œÉ] (n : ‚Ñï),\n  MvPolynomial.esymm œÉ R n =\n    Finset.sum (Finset.powersetLen n Finset.univ) fun (t : Finset œÉ) ‚Ü¶\n      ‚Üë(MvPolynomial.monomial (Finset.sum t fun (i : œÉ) ‚Ü¶ Finsupp.single i 1)) 1","name":"MvPolynomial.esymm_eq_sum_monomial","isProp":true,"docString":"We can define `esymm œÉ R n` as a sum over explicit monomials "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : (a : Œ±) ‚Üí Œ≤), (Function.Injective f : Prop) ‚Üî (Setoid.ker f = ‚ä• : Prop)","name":"Setoid.injective_iff_ker_bot","isProp":true,"docString":"A function from Œ± to Œ≤ is injective iff its kernel is the bottom element of the complete lattice\nof equivalence relations on Œ±. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : IsEmpty Œ±], Finset.univ = ‚àÖ","name":"Fintype.univ_of_isEmpty","isProp":true,"docString":"Note: this lemma is specifically about `Fintype.of_isEmpty`. For a statement about\narbitrary `Fintype` instances, use `Finset.univ_eq_empty`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±} {t : Set Œ±} (h : BddBelow t), BddBelow (s ‚à© t)","name":"BddBelow.inter_of_right","isProp":true,"docString":"If `t` is bounded, then so is `s ‚à© t` "},{"type":"‚àÄ {a : Prop} {b : Prop} (h : (a : Prop) ‚Üî (b : Prop)), (¬¨(a : Prop) : Prop) ‚Üî (¬¨(b : Prop) : Prop)","name":"Iff.not","isProp":true,"docString":"**Alias** of `not_congr`."},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (I : Ideal R) (f : R ‚âÉ+* S),\n  Ideal.comap (‚Üëf) (Ideal.comap (‚Üë(RingEquiv.symm f)) I) = I","name":"Ideal.comap_of_equiv","isProp":true,"docString":"If `f : R ‚âÉ+* S` is a ring isomorphism and `I : Ideal R`, then `comap f.symm (comap f) = I`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : r < 0)\n  (hf : Filter.Tendsto f l Filter.atTop), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atBot","name":"Filter.Tendsto.neg_const_mul_atTop","isProp":true,"docString":"If a function tends to infinity along a filter, then this function multiplied by a negative\nconstant (on the left) tends to negative infinity. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Finite Œ±] {f : (a : Œ±) ‚Üí Œ≤} (e : Œ± ‚âÉ Œ≤) (a : Function.Surjective f),\n  Function.Injective f","name":"Function.Surjective.injective_of_fintype","isProp":true,"docString":"**Alias** of the reverse direction of `Finite.injective_iff_surjective_of_equiv`."},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (hab : Nat.coprime a b),\n  Disjoint (Finsupp.support (Nat.factorization a)) (Finsupp.support (Nat.factorization b))","name":"Nat.factorization_disjoint_of_coprime","isProp":true,"docString":"The prime factorizations of coprime `a` and `b` are disjoint "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] [inst_1 : Fintype Œπ] (S : (a : Œπ) ‚Üí Set Œ±),\n  (fun (f : (a : Œπ) ‚Üí Œ±) ‚Ü¶ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i) '' Set.pi Set.univ S =\n    Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ S i","name":"Set.image_fintype_sum_pi","isProp":true,"docString":"A special case of `set.image_finset_sum_pi` for `finset.univ`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} {t : Finset Œ≥} {f : (a : Œ±) ‚Üí Œ≤}\n  {g : (a : Œ≥) ‚Üí Œ≤} (i : (a : Œ±) ‚Üí (a : a ‚àà s) ‚Üí Œ≥) (hi : ‚àÄ (a : Œ±) (ha : a ‚àà s), i a ha ‚àà t)\n  (h : ‚àÄ (a : Œ±) (ha : a ‚àà s), f a = g (i a ha))\n  (i_inj : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (ha‚ÇÅ : a‚ÇÅ ‚àà s) (ha‚ÇÇ : a‚ÇÇ ‚àà s) (a : i a‚ÇÅ ha‚ÇÅ = i a‚ÇÇ ha‚ÇÇ), a‚ÇÅ = a‚ÇÇ)\n  (i_surj : ‚àÄ (b : Œ≥) (a : b ‚àà t), ‚àÉ (a : Œ±), ‚àÉ (ha : a ‚àà s), b = i a ha),\n  (Finset.sum s fun (x : Œ±) ‚Ü¶ f x) = Finset.sum t fun (x : Œ≥) ‚Ü¶ g x","name":"Finset.sum_bij","isProp":true,"docString":"Reorder a sum.\n\nThe difference with `sum_bij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =O[l] g'), f =O[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ","name":"Asymptotics.IsBigO.norm_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigO_norm_right`."},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] {s : Set R} {t : NonUnitalSubsemiring R},\n  (NonUnitalSubsemiring.closure s ‚â§ t : Prop) ‚Üî (s ‚äÜ ‚Üët : Prop)","name":"NonUnitalSubsemiring.closure_le","isProp":true,"docString":"A non-unital subsemiring `S` includes `closure s` if and only if it includes `s`. "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra R‚ÇÅ A] [inst_4 : Algebra R‚ÇÅ B] (f : A ‚Üí‚Çê[R‚ÇÅ] B), Function.Injective ‚Üë(Ideal.kerLiftAlg f)","name":"Ideal.kerLiftAlg_injective","isProp":true,"docString":"The induced algebra morphism from the quotient by the kernel is injective. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (a : Set.Nonempty s), Set.Nonempty (closure s)","name":"Set.Nonempty.closure","isProp":true,"docString":"**Alias** of the reverse direction of `closure_nonempty_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : HeytingAlgebra Œ±] [inst_1 : HeytingAlgebra Œ≤] (self : HeytingHom Œ± Œ≤) (a : Œ±)\n  (b : Œ±),\n  SupHom.toFun (LatticeHom.toSupHom (HeytingHom.toLatticeHom self)) (a ‚á® b) =\n    SupHom.toFun (LatticeHom.toSupHom (HeytingHom.toLatticeHom self)) a ‚á®\n      SupHom.toFun (LatticeHom.toSupHom (HeytingHom.toLatticeHom self)) b","name":"HeytingHom.map_himp'","isProp":true,"docString":"The proposition that a Heyting homomorphism preserves the Heyting implication."},{"type":"‚àÄ {x : ‚Ñ§} {y : ‚Ñ§} {z : ‚Ñ§} (h : PythagoreanTriple x y z),\n  (PythagoreanTriple x y z : Prop) ‚Üî\n    (‚àÉ (k : ‚Ñ§),\n        ‚àÉ (m : ‚Ñ§),\n          ‚àÉ (n : ‚Ñ§),\n            (((x = k * (m ^ 2 - n ^ 2) : Prop) ‚àß (y = k * (2 * m * n) : Prop) : Prop) ‚à®\n                  ((x = k * (2 * m * n) : Prop) ‚àß (y = k * (m ^ 2 - n ^ 2) : Prop) : Prop) :\n                Prop) ‚àß\n              ((z = k * (m ^ 2 + n ^ 2) : Prop) ‚à® (z = -k * (m ^ 2 + n ^ 2) : Prop) : Prop) :\n      Prop)","name":"PythagoreanTriple.classification","isProp":true,"docString":"**Formula for Pythagorean Triples** "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (r : k) (p‚ÇÅ : P) (p‚ÇÇ : P), r ‚Ä¢ (p‚ÇÇ -·µ• p‚ÇÅ) +·µ• p‚ÇÅ ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ}","name":"smul_vsub_vadd_mem_affineSpan_pair","isProp":true,"docString":"A multiple of the difference of two points added to the first point lies in their affine\nspan. "},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} {k : ‚Ñï} (h_ab_coprime : Nat.coprime a b) (hka : k ‚à£ a) (hkb : k ‚à£ b), k = 1","name":"Nat.eq_one_of_dvd_coprimes","isProp":true,"docString":"If `k:‚Ñï` divides coprime `a` and `b` then `k = 1` "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] (u : MÀ£) (a : M), (IsUnit (‚Üëu * a) : Prop) ‚Üî (IsUnit a : Prop)","name":"Units.isUnit_units_mul","isProp":true,"docString":"Multiplication by a `u : MÀ£` on the left doesn't affect `IsUnit`. "},{"type":"‚àÄ {R : Type u_1} [inst : Mul R] {c : R} (self : IsRegular c), IsRightRegular c","name":"IsRegular.right","isProp":true,"docString":"A regular element `c` is right-regular "},{"type":"‚àÄ {R : Type u_1} [inst : Add R] [inst_1 : Mul R] (c : RingCon R) {a : R} {b : R}, (‚Üëa = ‚Üëb : Prop) ‚Üî (‚Üëc a b : Prop)","name":"RingCon.eq","isProp":true,"docString":"Two elements are related by a congruence relation `c` iff they are represented by the same\nelement of the quotient by `c`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1], 0 < 3","name":"three_pos","isProp":true,"docString":"**Alias** of `zero_lt_three`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (self : CategoryTheory.GrothendieckTopology C) (X : C),\n  ‚ä§ ‚àà CategoryTheory.GrothendieckTopology.sieves self X","name":"CategoryTheory.GrothendieckTopology.top_mem'","isProp":true,"docString":"The sieves associated to each object must contain the top sieve.\nUse `GrothendieckTopology.top_mem`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P) (direction : Submodule k V), Set.Nonempty ‚Üë(AffineSubspace.mk' p direction)","name":"AffineSubspace.mk'_nonempty","isProp":true,"docString":"An affine subspace constructed from a point and a direction is nonempty. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {R : C} {X : C} {Y : C} (f : X ‚ü∂ Y) (a : R ‚ü∂ X) (b : R ‚ü∂ X),\n  Subsingleton (CategoryTheory.IsKernelPair f a b : Prop)","name":"CategoryTheory.IsKernelPair.instSubsingletonIsKernelPair","isProp":true,"docString":"The data expressing that `(a, b)` is a kernel pair is subsingleton. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (hf : MonotoneOn f s) (hs : s ‚àà nhdsWithin a (Set.Iic a))\n  (hfs : closure (f '' s) ‚àà nhdsWithin (f a) (Set.Iic (f a))), ContinuousWithinAt f (Set.Iic a) a","name":"continuousWithinAt_left_of_monotoneOn_of_closure_image_mem_nhdsWithin","isProp":true,"docString":"If a function `f` with a densely ordered codomain is monotone on a left neighborhood of `a` and\nthe closure of the image of this neighborhood under `f` is a left neighborhood of `f a`, then `f` is\ncontinuous at `a` from the left "},{"type":"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p : Prop)], (p % 2 = 1 : Prop) ‚Üî (p ‚â† 2 : Prop)","name":"Nat.Prime.mod_two_eq_one_iff_ne_two","isProp":true,"docString":"A prime `p` satisfies `p % 2 = 1` if and only if `p ‚â† 2`. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} {x1 : Œ±} {b1 : Bool} {x2 : Œ±} {b2 : Bool}\n  (H1 : (x1, b1) ‚â† (x2, b2)) (H2 : FreeGroup.Red ((x1, b1) :: L‚ÇÅ) ((x2, b2) :: L‚ÇÇ)),\n  FreeGroup.Red L‚ÇÅ ((x1, !b1) :: (x2, b2) :: L‚ÇÇ)","name":"FreeGroup.Red.inv_of_red_of_ne","isProp":true,"docString":"If `x` and `y` are distinct letters and `w‚ÇÅ w‚ÇÇ` are words such that `xw‚ÇÅ` reduces to `yw‚ÇÇ`, then\n`w‚ÇÅ` reduces to `x‚Åª¬πyw‚ÇÇ`. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} (a : Finset.Nonempty s), ‚àÖ ‚äÇ s","name":"Finset.Nonempty.empty_ssubset","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.empty_ssubset`."},{"type":"‚àÄ {n : ‚Ñï} [inst : NeZero n] (i : Fin (n + 1)), ‚Üë(Fin.succAbove (Fin.succ i)) 1 = Fin.succ (‚Üë(Fin.succAbove i) 0)","name":"Fin.succ_succAbove_one","isProp":true,"docString":"By moving `succ` to the outside of this expression, we create opportunities for further\nsimplification using `succAbove_zero` or `succ_succAbove_zero`. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (c : Con M), Con.ker (Con.mk' c) = c","name":"Con.mk'_ker","isProp":true,"docString":"The kernel of the natural homomorphism from a monoid to its quotient by a congruence\nrelation `c` equals `c`. "},{"type":"‚àÄ {ùíú : Type u_2} [inst : CategoryTheory.Category ùíú] [inst_1 : CategoryTheory.Preadditive ùíú]\n  [inst_2 : CategoryTheory.Limits.HasKernels ùíú] [inst_3 : CategoryTheory.Limits.HasImages ùíú]\n  [inst_4 : CategoryTheory.Limits.HasBinaryBiproducts ùíú] (A : ùíú) (B : ùíú),\n  CategoryTheory.Exact CategoryTheory.Limits.biprod.inr CategoryTheory.Limits.biprod.fst","name":"CategoryTheory.exact_inr_fst","isProp":true,"docString":"The sequence `B ‚ü∂ A ‚äû B ‚ü∂ A` is exact. "},{"type":"‚àÄ {G : Type w} [inst : Group G] {g : G} {P : (a : G) ‚Üí Prop} (h_one : P 1) (h_mul : ‚àÄ (a : G) (a_1 : P a), P (a * g))\n  (h_inv : ‚àÄ (a : G) (a_1 : P a), P (a * g‚Åª¬π)) (n : ‚Ñ§), P (g ^ n)","name":"zpow_induction_right","isProp":true,"docString":"To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `g‚Åª¬π` on the right. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_right`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {a : Œ±} {s : Set Œ±},\n  inf‚Çõ s ‚äî a ‚â§ inf·µ¢ fun (b : Œ±) ‚Ü¶ inf·µ¢ fun (h : b ‚àà s) ‚Ü¶ b ‚äî a","name":"inf‚Çõ_sup_le_inf·µ¢_sup","isProp":true,"docString":"This is a weaker version of `inf‚Çõ_sup_eq` "},{"type":"‚àÄ {Œ± : Type u_1} {A : Set (Finset Œ±)} {B : Set (Finset Œ±)} {r : ‚Ñï}\n  (a : (Set.Sized r A : Prop) ‚àß (Set.Sized r B : Prop)), Set.Sized r (A ‚à™ B)","name":"Set.sized.union","isProp":true,"docString":"**Alias** of the reverse direction of `Set.sized_union`."},{"type":"‚àÄ (R : Type u_1) [inst : Nontrivial R] [inst : Semiring R] [inst_1 : Algebra ‚Ñö R], CharP R 0","name":"algebraRat.charP_zero","isProp":true,"docString":"A nontrivial `‚Ñö`-algebra has `CharP` equal to zero.\n\nThis cannot be a (local) instance because it would immediately form a loop with the\ninstance `algebraRat`. It's probably easier to go the other way: prove `CharZero R` and\nautomatically receive an `Algebra ‚Ñö R` instance.\n"},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {G' : SimpleGraph V} (h : G ‚â§ G') {u : V} {v : V} {p : SimpleGraph.Walk G u v}\n  (a : SimpleGraph.Walk.IsPath p), SimpleGraph.Walk.IsPath (SimpleGraph.Walk.mapLe h p)","name":"SimpleGraph.Walk.IsPath.mapLe","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.Walk.mapLe_isPath`."},{"type":"‚àÄ {Œ± : Type u_1} (G : SimpleGraph Œ±) [inst : Fintype Œ±] [inst_1 : DecidableEq Œ±]\n  [inst_2 : DecidableRel (SimpleGraph.Adj G)] {n : ‚Ñï} (a : SimpleGraph.CliqueFree G n), SimpleGraph.cliqueFinset G n = ‚àÖ","name":"SimpleGraph.CliqueFree.cliqueFinset","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.cliqueFinset_eq_empty_iff`."},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type v} [inst : MetricSpace Œ±] [inst_1 : ProperSpace Œ±] {c : (a : Œπ) ‚Üí Œ±} {r : (a : Œπ) ‚Üí ‚Ñù}\n  (hr : ‚àÄ (i : Œπ), 0 < r i) (uf : ‚àÄ (x : Œ±), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ x ‚àà Metric.ball (c i) (r i)))\n  (uU : (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r i)) = Set.univ),\n  ‚àÉ (r' : (a : Œπ) ‚Üí ‚Ñù),\n    ((Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r' i)) = Set.univ : Prop) ‚àß (‚àÄ (i : Œπ), r' i ‚àà Set.Ioo 0 (r i) : Prop)","name":"exists_union·µ¢_ball_eq_radius_pos_lt","isProp":true,"docString":"Shrinking lemma for coverings by open balls in a proper metric space. A point-finite open cover\nof a proper metric space by nonempty open balls can be shrunk to a new cover by nonempty open balls\nso that each of the new balls has strictly smaller radius than the old one. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {U : Set (G √ó G)}\n  (hU : U ‚àà nhds 1), ‚àÉ (V : OpenSubgroup G), ‚ÜëV √óÀ¢ ‚ÜëV ‚äÜ U","name":"NonarchimedeanGroup.prod_self_subset","isProp":true,"docString":"An open neighborhood of the identity in the cartesian square of a nonarchimedean group\ncontains the cartesian square of an open neighborhood in the group. "},{"type":"‚àÄ {G : Type u_1} [inst : DivInvMonoid G] (a : G) (b : G), a / b = a * b‚Åª¬π","name":"div_eq_mul_inv","isProp":true,"docString":"Dividing by an element is the same as multiplying by its inverse.\n\nThis is a duplicate of `DivInvMonoid.div_eq_mul_inv` ensuring that the types unfold better.\n"},{"type":"‚àÄ {Œπ : Type u} {Œ≥ : Type w} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] [inst : (i : Œπ) ‚Üí AddZeroClass (Œ≤ i)]\n  [inst_1 : (i : Œπ) ‚Üí (x : Œ≤ i) ‚Üí Decidable (x ‚â† 0 : Prop)] [inst_2 : AddCommMonoid Œ≥] (œÜ : (i : Œπ) ‚Üí Œ≤ i ‚Üí+ Œ≥)\n  (f : Dfinsupp fun (i : Œπ) ‚Ü¶ Œ≤ i), ‚Üë(Dfinsupp.sumAddHom œÜ) f = Dfinsupp.sum f fun (x : Œπ) ‚Ü¶ ‚Üë(œÜ x)","name":"Dfinsupp.sumAddHom_apply","isProp":true,"docString":"While we didn't need decidable instances to define it, we do to reduce it to a sum "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {x : M} {y : M} {z : M} (a : ‚Üëc x y) (a : ‚Üëc y z), ‚Üëc x z","name":"AddCon.trans","isProp":true,"docString":"Additive congruence relations are transitive."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {f : Filter Œ±},\n  (Cauchy f : Prop) ‚Üî\n    ((f ‚â† ‚ä• : Prop) ‚àß\n        (‚àÄ (Œµ : ENNReal) (a : Œµ > 0),\n            ‚àÉ (t : Set Œ±), (t ‚àà f : Prop) ‚àß (‚àÄ (x : Œ±) (a : x ‚àà t) (y : Œ±) (a : y ‚àà t), edist x y < Œµ : Prop) :\n          Prop) :\n      Prop)","name":"EMetric.cauchy_iff","isProp":true,"docString":"Œµ-Œ¥ characterization of Cauchy sequences on pseudoemetric spaces "},{"type":"‚àÄ {A : Type u_1} [inst : AddMonoid A] {x : A} {y : A},\n  (y ‚àà AddSubmonoid.closure {x} : Prop) ‚Üî (‚àÉ (n : ‚Ñï), n ‚Ä¢ x = y : Prop)","name":"AddSubmonoid.mem_closure_singleton","isProp":true,"docString":"The `AddSubmonoid` generated by an element of an `AddMonoid` equals the set of\nnatural number multiples of the element. "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} (hn : Odd n) (hm : m ‚à£ n), m ‚â† 2","name":"Odd.ne_two_of_dvd_nat","isProp":true,"docString":"`2` is not a factor of an odd natural number. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonAssocSemiring Œ±]\n  [inst_1 : NonAssocSemiring Œ≤] [self : RingHomClass F Œ± Œ≤] (f : F), ‚Üëf 0 = 0","name":"RingHomClass.map_zero","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ≤] {Œ± : Type u_1} [inst_1 : MetricSpace Œ±] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤}\n  [inst_2 : ProperSpace Œ±] (hK : AntilipschitzWith K f) (f_cont : Continuous f) (hf : Function.Surjective f),\n  ProperSpace Œ≤","name":"AntilipschitzWith.properSpace","isProp":true,"docString":"The image of a proper space under an expanding onto map is proper. "},{"type":"‚àÄ {Œ± : Type u} [inst : NonUnitalNonAssocRing Œ±] (a : Œ±) (b : Œ±) (c : Œ±), a * (b - c) = a * b - a * c","name":"mul_sub","isProp":true,"docString":"**Alias** of `mul_sub_left_distrib`."},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonAssocRing Œ±]\n  [inst_1 : OrderedSemiring Œ≤] [self : MulRingSeminormClass F Œ± Œ≤] (f : F) (x : Œ±) (y : Œ±), ‚Üëf (x * y) = ‚Üëf x * ‚Üëf y","name":"MulRingSeminormClass.map_mul","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G} {t : Set G} (ht : IsNormalSubgroup t) (h : s ‚äÜ t),\n  Group.normalClosure s ‚äÜ t","name":"Group.normalClosure_subset","isProp":true,"docString":"The normal closure of s is the smallest normal subgroup containing s. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (x : X) (y : X),\n  List.TFAE\n    [(x ‚§≥ y : Prop), (pure x ‚â§ nhds y : Prop), (‚àÄ (s : Set X) (a : IsOpen s) (a : y ‚àà s), x ‚àà s : Prop),\n      (‚àÄ (s : Set X) (a : IsClosed s) (a : x ‚àà s), y ‚àà s : Prop), (y ‚àà closure {x} : Prop),\n      (closure {y} ‚äÜ closure {x} : Prop), (ClusterPt y (pure x) : Prop)]","name":"specializes_TFAE","isProp":true,"docString":"A collection of equivalent definitions of `x ‚§≥ y`. The public API is given by `iff` lemmas\nbelow. "},{"type":"‚àÄ (n : ‚Ñï) (a : ‚Ñï) (p : (a : ‚Ñï) ‚Üí Prop) [inst : DecidablePred p] (pp : Function.Periodic p a),\n  Finset.card (Finset.filter p (Finset.Ico n (n + a))) = Nat.count p a","name":"Nat.filter_Ico_card_eq_of_periodic","isProp":true,"docString":"An interval of length `a` filtered over a periodic predicate of period `a` has cardinality\nequal to the number naturals below `a` for which `p a` is true. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] [inst_1 : OrderTop Œ±] {Œπ : Type u} [inst_2 : Fintype Œπ] (f : (a : Œπ) ‚Üí Œ±),\n  (‚àè f) = Finset.inf Fintype.elems f","name":"CategoryTheory.Limits.CompleteLattice.finite_product_eq_finset_inf","isProp":true,"docString":"A finite product in the category of a `SemilatticeInf` with `OrderTop` is the same as the infimum.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (Œ¥ : ‚Ñù), Metric.cthickening Œ¥ ‚àÖ = ‚àÖ","name":"Metric.cthickening_empty","isProp":true,"docString":"The closed thickening of the empty set is empty. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {Œº : (a : M) ‚Üí (a : N) ‚Üí N} [inst : Preorder N]\n  [inst_1 : CovariantClass M N Œº fun (x : N) (x_1 : N) ‚Ü¶ x ‚â§ x_1] (m : M), Monotone (Œº m)","name":"Covariant.monotone_of_const","isProp":true,"docString":"The partial application of a constant to a covariant operator is monotone. "},{"type":"‚àÄ (n : ‚Ñï), ‚àÉ (p : ‚Ñï), (n ‚â§ p : Prop) ‚àß (Nat.Prime p : Prop)","name":"Nat.exists_infinite_primes","isProp":true,"docString":"Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p ‚â• n`. "},{"type":"‚àÄ (k : Type u‚ÇÅ) {G : Type u‚ÇÇ} {R : Type u_1} [inst : Semiring k] [inst_1 : DistribSMul R k] [inst_2 : Add G]\n  [inst_3 : SMulCommClass R k k], SMulCommClass R (AddMonoidAlgebra k G) (AddMonoidAlgebra k G)","name":"AddMonoidAlgebra.sMulCommClass_self","isProp":true,"docString":"Note that if `k` is a `CommSemiring` then we have `SMulCommClass k k k` and so we can take\n`R = k` in the below. In other words, if the coefficients are commutative amongst themselves, they\nalso commute with the algebra multiplication. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : ConditionallyCompleteLattice Œ±] {f : (a : Œπ) ‚Üí Œ±} (H : BddBelow (Set.range f))\n  (c : Œπ), inf·µ¢ f ‚â§ f c","name":"cinf·µ¢_le","isProp":true,"docString":"The indexed infimum of a function is bounded above by the value taken at one point"},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (m : Multiset M)\n  (a : ‚àÄ (a : M) (a_1 : a ‚àà m), a ‚àà s), Multiset.prod m ‚àà s","name":"IsSubmonoid.multiset_prod_mem","isProp":true,"docString":"The product of a multiset of elements of a submonoid of a `CommMonoid` is an element of\nthe submonoid. "},{"type":"‚àÄ {B : Type u_2} {S : B} {M : Type u_1} [inst : CommMonoid M] [inst_1 : SetLike B M] [inst_2 : SubmonoidClass B M]\n  (m : Multiset M) (hm : ‚àÄ (a : M) (a_1 : a ‚àà m), a ‚àà S), Multiset.prod m ‚àà S","name":"multiset_prod_mem","isProp":true,"docString":"Product of a multiset of elements in a submonoid of a `CommMonoid` is in the submonoid. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] [inst_6 : Nonempty Œ≥] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ≥) ‚Üí Œ±}\n  (Cf : ContinuousAt f (sup·µ¢ fun (i : Œ≥) ‚Ü¶ g i)) (Af : Antitone f) (H : BddAbove (Set.range g)),\n  f (sup·µ¢ fun (i : Œ≥) ‚Ü¶ g i) = inf·µ¢ fun (i : Œ≥) ‚Ü¶ f (g i)","name":"Antitone.map_csupr_of_continuousAt","isProp":true,"docString":"If an antitone function is continuous at the indexed supremum of a bounded function on\na nonempty `Sort`, then it sends this supremum to the infimum of the composition. "},{"type":"‚àÄ {ùïú : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NormedCommRing ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : AddCommMonoid F] [inst_3 : Module ùïú E] [inst_4 : Module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) (s : Set E),\n  IsClosed (LinearMap.polar B s)","name":"LinearMap.polar_weak_closed","isProp":true,"docString":"The polar set is closed in the weak topology induced by `B.flip`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasZeroMorphisms C] (X : C) {Y : C}\n  {Z : C} (f : Y ‚ü∂ Z), 0 ‚â´ f = 0","name":"CategoryTheory.Limits.HasZeroMorphisms.zero_comp","isProp":true,"docString":"`0` composed with `f` is `0` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a : Œ±} {b : Œ±} (h : a < b),\n  ‚àÉ (a' : Œ±),\n    (a' > a : Prop) ‚àß (‚àÉ (b' : Œ±), (b' < b : Prop) ‚àß (‚àÄ (x : Œ±) (a : x < a') (y : Œ±) (a : y > b'), x < y : Prop) : Prop)","name":"LT.lt.exists_disjoint_Iio_Ioi","isProp":true,"docString":"If `a < b` then there exist `a' > a` and `b' < b` such that `Set.Iio a'` is strictly to the left\nof `Set.Ioi b'`. "},{"type":"‚àÄ {n : ‚Ñï} [inst : NeZero n] (a : Fin n), ‚Üë‚Üëa = a","name":"Fin.cast_val_eq_self","isProp":true,"docString":"Converting the value of a `Fin (n + 1)` to `Fin (n + 1)` results\nin the same value.  "},{"type":"‚àÄ (n : ‚Ñï), List.length (List.Nat.antidiagonal n) = n + 1","name":"List.Nat.length_antidiagonal","isProp":true,"docString":"The length of the antidiagonal of `n` is `n + 1`. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)], IsAbsoluteValue (padicNorm p)","name":"padicNorm.instIsAbsoluteValueRatInstOrderedSemiringRatSemiringPadicNorm","isProp":true,"docString":"The `p`-adic norm is an absolute value: positive-definite and multiplicative, satisfying the\ntriangle inequality. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Fin n) ‚Üí Œ±} {g : (a : Fin n) ‚Üí Œ±} (hf : StrictMono f)\n  (hg : StrictMono g) (h : Set.range f = Set.range g), f = g","name":"Fin.strictMono_unique","isProp":true,"docString":"Two strictly monotone functions from `Fin n` are equal provided that their ranges\nare equal. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} (h : Set.Nonempty s),\n  (x ‚àà closure s : Prop) ‚Üî (Metric.infDist x s = 0 : Prop)","name":"Metric.mem_closure_iff_infDist_zero","isProp":true,"docString":"A point belongs to the closure of `s` iff its infimum distance to this set vanishes "},{"type":"‚àÄ {Œ± : Type u_2} {n : Type u_3} {m : Type u_1} [inst : Mul Œ±] [inst_1 : AddCommMonoid Œ±] (A : Matrix m n Œ±)\n  [inst_2 : Fintype m], (Matrix.HasOrthogonalRows (Matrix.transpose A) : Prop) ‚Üî (Matrix.HasOrthogonalCols A : Prop)","name":"Matrix.transpose_hasOrthogonalRows_iff_hasOrthogonalCols","isProp":true,"docString":"`A·µÄ` has orthogonal rows iff `A` has orthogonal columns. "},{"type":"‚àÄ {Œ± : Type u} (L : List Œ±) {j : ‚Ñï} {i : Fin (List.length (List.take j L))},\n  List.get (List.take j L) i =\n    List.get L\n      { val := ‚Üëi,\n        isLt :=\n          ((lt_of_lt_of_le ((Fin.isLt i=:‚Üëi < List.length (List.take j L))=:‚Üëi < List.length (List.take j L))\n                ((of_eq_true\n                      ((Eq.trans\n                            ((Eq.trans\n                                  ((Eq.trans\n                                        ((congrFun\n                                              ((congrArg LE.le\n                                                    ((List.length_take j\n                                                          L=:List.length (List.take j L) =\n                                                          min j\n                                                            (List.length\n                                                              L))=:List.length (List.take j L) =\n                                                        min j\n                                                          (List.length\n                                                            L))=:LE.le (List.length (List.take j L)) =\n                                                    LE.le\n                                                      (min j\n                                                        (List.length\n                                                          L)))=:LE.le (List.length (List.take j L)) =\n                                                  LE.le (min j (List.length L)))\n                                              (List.length\n                                                L)=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                              (min j (List.length L) ‚â§ List.length L :\n                                                Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                            (min j (List.length L) ‚â§ List.length L : Prop))\n                                        ((Mathlib.Order.MinMax._auxLemma.3=:(min j (List.length L) ‚â§ List.length L :\n                                                Prop) =\n                                              ((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) :\n                                                Prop))=:(min j (List.length L) ‚â§ List.length L : Prop) =\n                                            ((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) :\n                                              Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                        ((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) :\n                                          Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                      ((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) : Prop))\n                                  ((congrArg (Or (j ‚â§ List.length L : Prop))\n                                        ((Mathlib.Init.Algebra.Order._auxLemma.1\n                                              (List.length\n                                                L)=:(List.length L ‚â§ List.length L : Prop) =\n                                              (True :\n                                                Prop))=:(List.length L ‚â§ List.length L : Prop) =\n                                            (True :\n                                              Prop))=:((j ‚â§ List.length L : Prop) ‚à®\n                                            (List.length L ‚â§ List.length L : Prop) :\n                                          Prop) =\n                                        ((j ‚â§ List.length L : Prop) ‚à® (True : Prop) :\n                                          Prop))=:((j ‚â§ List.length L : Prop) ‚à® (List.length L ‚â§ List.length L : Prop) :\n                                        Prop) =\n                                      ((j ‚â§ List.length L : Prop) ‚à® (True : Prop) :\n                                        Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                  ((j ‚â§ List.length L : Prop) ‚à® (True : Prop) :\n                                    Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                                ((j ‚â§ List.length L : Prop) ‚à® (True : Prop) : Prop))\n                            ((or_true\n                                  (j ‚â§ List.length L :\n                                    Prop)=:((j ‚â§ List.length L : Prop) ‚à® (True : Prop) : Prop) =\n                                  (True :\n                                    Prop))=:((j ‚â§ List.length L : Prop) ‚à® (True : Prop) : Prop) =\n                                (True :\n                                  Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                            (True :\n                              Prop))=:(List.length (List.take j L) ‚â§ List.length L : Prop) =\n                          (True :\n                            Prop))=:List.length (List.take j L) ‚â§\n                      List.length\n                        L)=:List.length (List.take j L) ‚â§ List.length L)=:‚Üëi < List.length L)=:‚Üëi < List.length L) }","name":"List.get_take'","isProp":true,"docString":"The `i`-th element of a list coincides with the `i`-th element of any of its prefixes of\nlength `> i`. Version designed to rewrite from the small list to the big list. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 : AffineSubspace k P) (s2 : AffineSubspace k P),\n  (s1 ‚â§ s2 : Prop) ‚Üî (‚àÄ (p : P) (a : p ‚àà s1), p ‚àà s2 : Prop)","name":"AffineSubspace.le_def'","isProp":true,"docString":"One subspace is less than or equal to another if and only if all its points are in the second\nsubspace. "},{"type":"‚àÄ {G : Type u_2} {P : Type u_1} [inst : AddGroup G] [T : AddTorsor G P] {g1 : G} {g2 : G} (p : P)\n  (h : g1 +·µ• p = g2 +·µ• p), g1 = g2","name":"vadd_right_cancel","isProp":true,"docString":"If the same point added to two group elements produces equal\nresults, those group elements are equal. "},{"type":"‚àÄ {t : (a : Type u) ‚Üí Type u} [inst : Traversable t] [self : IsLawfulTraversable t] {F : (a : Type u) ‚Üí Type u}\n  {G : (a : Type u) ‚Üí Type u} [inst_1 : Applicative F] [inst_2 : Applicative G] [inst_3 : LawfulApplicative F]\n  [inst_4 : LawfulApplicative G] (Œ∑ : ApplicativeTransformation F G) {Œ± : Type u} {Œ≤ : Type u} (f : (a : Œ±) ‚Üí F Œ≤)\n  (x : t Œ±),\n  (fun {Œ± : Type u} ‚Ü¶ ApplicativeTransformation.app Œ∑ Œ±) (traverse f x) =\n    traverse ((fun {Œ± : Type u} ‚Ü¶ ApplicativeTransformation.app Œ∑ Œ±) ‚àò f) x","name":"IsLawfulTraversable.naturality","isProp":true,"docString":"The naturality axiom explaining how lawful traversable functors should play with\nlawful applicative functors. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] [inst_1 : HasDistribNeg Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚à£ -b), a ‚à£ b","name":"Dvd.dvd.of_neg_right","isProp":true,"docString":"**Alias** of the forward direction of `dvd_neg`."},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : One M] {s : Set Œ±} {f : (a : Œ±) ‚Üí M} {a : Œ±} (h : Set.mulIndicator s f a ‚â† 1),\n  a ‚àà s","name":"Set.mem_of_mulIndicator_ne_one","isProp":true,"docString":"If a multiplicative indicator function is not equal to `1` at a point, then that point is in the\nset. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCommGroup Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"LinearOrderedCommGroup.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ioo (f n) (f (Order.succ n)))","name":"Monotone.pairwise_disjoint_on_Ioo_succ","isProp":true,"docString":"If `Œ±` is a linear succ order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is a monotone function, then\nthe intervals `Set.Ioo (f n) (f (Order.succ n))` are pairwise disjoint. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a : Œ±} {b : Œ±}, (a ‚à£ a - b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"dvd_sub_self_left","isProp":true,"docString":"An element `a` divides the difference `a - b` if and only if `a` divides `b`. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {f : M ‚Üí* N}\n  (hf : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëf ‚Üëy)) {y : { x : M // x ‚àà S }} {z : { x : M // x ‚àà S }}\n  (h : (‚Üë(IsUnit.liftRight (MonoidHom.restrict f S) hf) y)‚Åª¬π = (‚Üë(IsUnit.liftRight (MonoidHom.restrict f S) hf) z)‚Åª¬π),\n  ‚Üëf ‚Üëy = ‚Üëf ‚Üëz","name":"Submonoid.LocalizationMap.inv_inj","isProp":true,"docString":"Given a MonoidHom `f : M ‚Üí* N` and Submonoid `S ‚äÜ M` such that `f(S) ‚äÜ NÀ£`, for all\n`y, z ‚àà S`, we have `(f y)‚Åª¬π = (f z)‚Åª¬π ‚Üí f y = f z`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Nontrivial Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Surjective f), Nontrivial Œ±","name":"Function.Surjective.nontrivial","isProp":true,"docString":"Pullback a `nontrivial` instance along a surjective function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] [inst_1 : HasDistribNeg Œ±] {a : Œ±} {b : Œ±}, (-a ‚à£ b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"neg_dvd","isProp":true,"docString":"The negation of an element `a` of a semigroup with a distributive negation divides another\nelement `b` iff `a` divides `b`. "},{"type":"‚àÄ {M : Type u_2} [inst : AddZeroClass M] {Œπ : Sort u_1} (S : (a : Œπ) ‚Üí AddSubmonoid M)\n  {C : (x : M) ‚Üí (a : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) ‚Üí Prop}\n  (hp :\n    ‚àÄ (i : Œπ) (x : M) (hxS : x ‚àà S i),\n      C x ((AddSubmonoid.mem_sup·µ¢_of_mem i hxS=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (h1 : C 0 ((zero_mem (sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:0 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:0 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (hmul :\n    ‚àÄ (x : M) (y : M) (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hy : y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (a : C x hx) (a : C y hy),\n      C (x + y) ((add_mem hx hy=:x + y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x + y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  {x : M} (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i), C x hx","name":"AddSubmonoid.sup·µ¢_induction'","isProp":true,"docString":"A dependent version of `AddSubmonoid.sup·µ¢_induction`. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] {a : Œ±} {b : Œ±} [inst_1 : IsRefl Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1] (a_1 : a = b),\n  a ‚äÜ b","name":"Eq.subset'","isProp":true,"docString":"**Alias** of `subset_of_eq`."},{"type":"‚àÄ {G : Type u} [self : DivInvMonoid G] (a : G), DivInvMonoid.zpow 0 a = 1","name":"DivInvMonoid.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s : Set P} (hs : Set.Nonempty s), (affineSpan k s = ‚ä§ : Prop) ‚Üî (vectorSpan k s = ‚ä§ : Prop)","name":"AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty","isProp":true,"docString":"For a nonempty set, the affine span is `‚ä§` iff its vector span is `‚ä§`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  [inst_2 : CategoryTheory.Simple Y] {f : X ‚ü∂ Y} [inst_3 : CategoryTheory.Mono f] (w : f ‚â† 0), CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_mono_of_nonzero","isProp":true,"docString":"A nonzero monomorphism to a simple object is an isomorphism. "},{"type":"‚àÄ {Œ± : Sort u} (a : Œ±), PLift.down { down := a } = a","name":"PLift.down_up","isProp":true,"docString":"Bijection between `Œ±` and `PLift Œ±` "},{"type":"‚àÄ {Œ± : Type u_1} {o : Part Œ±} {p : Part Œ±} (x : (Part.Dom o : Prop) ‚Üî (Part.Dom p : Prop))\n  (x : ‚àÄ (h‚ÇÅ : Part.Dom o) (h‚ÇÇ : Part.Dom p), Part.get o h‚ÇÅ = Part.get p h‚ÇÇ), o = p","name":"Part.ext'","isProp":true,"docString":"`Part` extensionality "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : LinearOrder Œ≤] {U : Filter (Œ± √ó Œ±)} (z : Œ≤) (D : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Œ≤)\n  (H :\n    ‚àÄ (s : Set (Œ± √ó Œ±)),\n      (s ‚àà U : Prop) ‚Üî (‚àÉ (Œµ : Œ≤), (Œµ > z : Prop) ‚àß (‚àÄ {a : Œ±} {b : Œ±} (a_1 : D a b < Œµ), (a, b) ‚àà s : Prop) : Prop)),\n  U =\n    inf·µ¢ fun (Œµ : Œ≤) ‚Ü¶ inf·µ¢ fun (h : Œµ > z) ‚Ü¶ Filter.principal (setOf fun (p : Œ± √ó Œ±) ‚Ü¶ D (Prod.fst p) (Prod.snd p) < Œµ)","name":"uniformity_dist_of_mem_uniformity","isProp":true,"docString":"Characterizing uniformities associated to a (generalized) distance function `D`\nin terms of the elements of the uniformity. "},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} (w : f = g) {Z : C}\n  (h : Y ‚ü∂ Z), f ‚â´ h = g ‚â´ h","name":"CategoryTheory.eq_whisker'","isProp":true,"docString":"A variant of `eq_whisker` with a more convenient argument order for use in tactics.  "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} {Œπ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤] {s : Set E}\n  {f : (a : E) ‚Üí Œ≤} {t : Finset Œπ} {w : (a : Œπ) ‚Üí ùïú} {p : (a : Œπ) ‚Üí E} (hf : ConcaveOn ùïú s f)\n  (h‚ÇÄ : ‚àÄ (i : Œπ) (a : i ‚àà t), 0 ‚â§ w i) (h‚ÇÅ : (Finset.sum t fun (i : Œπ) ‚Ü¶ w i) = 1)\n  (hmem : ‚àÄ (i : Œπ) (a : i ‚àà t), p i ‚àà s),\n  (Finset.sum t fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ f (p i)) ‚â§ f (Finset.sum t fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ p i)","name":"ConcaveOn.le_map_sum","isProp":true,"docString":"Concave **Jensen's inequality**, `Finset.sum` version. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)) < Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (¬¨(MonovaryOn f (g ‚àò ‚ÜëœÉ) ‚Üës : Prop) : Prop)","name":"MonovaryOn.sum_mul_comp_perm_lt_sum_mul_iff","isProp":true,"docString":"**Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {m : ‚Ñ§} {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (hm : 0 < m) (h : a * c ‚â° b * c [ZMOD m]), a ‚â° b [ZMOD m / ‚Üë(Int.gcd m c)]","name":"Int.ModEq.cancel_right_div_gcd","isProp":true,"docString":"To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] (S : Set (Set Œ±)) (hS : ‚àÄ (s : ‚ÜëS), IsOpen ‚Üës)\n  [hS' : ‚àÄ (s : ‚ÜëS), QuasiSober ‚Üë‚Üës] (hS'' : ‚ãÉ‚ÇÄ S = ‚ä§), QuasiSober Œ±","name":"quasiSober_of_open_cover","isProp":true,"docString":"A space is quasi sober if it can be covered by open quasi sober subsets. "},{"type":"‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} {v : (a : Œ±) ‚Üí ‚Ñù} (a : u =O[l] v),\n  (fun (x : Œ±) ‚Ü¶ abs (u x)) =O[l] fun (x : Œ±) ‚Ü¶ abs (v x)","name":"Asymptotics.IsBigO.abs_abs","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigO_abs_abs`."},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Neg G] [inst_2 : Add G] [inst_3 : ContinuousAdd G] (g : G),\n  Continuous fun (h : G) ‚Ü¶ g + h + -g","name":"TopologicalAddGroup.continuous_conj","isProp":true,"docString":"Conjugation by a fixed element is continuous when `add` is continuous."},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : Nonempty J] (s : CategoryTheory.Limits.Trident f) {W : C} {k : W ‚ü∂ CategoryTheory.Limits.Cone.pt s}\n  {l : W ‚ü∂ CategoryTheory.Limits.Cone.pt s}\n  (h : k ‚â´ CategoryTheory.Limits.Trident.Œπ s = l ‚â´ CategoryTheory.Limits.Trident.Œπ s)\n  (j : CategoryTheory.Limits.WalkingParallelFamily J),\n  k ‚â´ (CategoryTheory.Limits.Cone.œÄ s).app j = l ‚â´ (CategoryTheory.Limits.Cone.œÄ s).app j","name":"CategoryTheory.Limits.Trident.equalizer_ext","isProp":true,"docString":"To check whether two maps are equalized by both maps of a trident, it suffices to check it for\nthe first map "},{"type":"‚àÄ (R : Type u_1) [inst : Nontrivial R] [inst : Ring R] [inst_1 : Algebra ‚Ñö R], CharZero R","name":"algebraRat.charZero","isProp":true,"docString":"A nontrivial `‚Ñö`-algebra has characteristic zero.\n\nThis cannot be a (local) instance because it would immediately form a loop with the\ninstance `algebraRat`. It's probably easier to go the other way: prove `CharZero R` and\nautomatically receive an `Algebra ‚Ñö R` instance.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_1} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥) (a : Option Œ±) (b : Option Œ≤),\n  Option.map‚ÇÇ f a b = Seq.seq (f <$> a) fun (x : Unit) ‚Ü¶ b","name":"Option.map‚ÇÇ_def","isProp":true,"docString":"`Option.map‚ÇÇ` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] [inst_4 : TopologicalSpace Œ≤] [inst_5 : One Œ±] {f : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f)\n  (h : HasCompactMulSupport f), BddBelow (Set.range f)","name":"Continuous.bddBelow_range_of_hasCompactMulSupport","isProp":true,"docString":"A continuous function with compact support is bounded below. "},{"type":"‚àÄ {k : Type u_1} {M : Type u_2} [inst : OrderedRing k] [inst_1 : OrderedAddCommGroup M] [inst_2 : Module k M]\n  [inst_3 : OrderedSMul k M] {a : M} {c : k} (hc : c < 0) (a_1 : a < 0), 0 < c ‚Ä¢ a","name":"smul_pos_of_neg_of_neg","isProp":true,"docString":"**Alias** of the reverse direction of `smul_pos_iff_of_neg`."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F]\n  [inst_2 : SeminormedGroup G] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} (hf : Filter.Tendsto f l (nhds 1))\n  (hg : Filter.IsBoundedUnder (fun (x : ‚Ñù) (x_1 : ‚Ñù) ‚Ü¶ x ‚â§ x_1) l (norm ‚àò g)) (op : (a : E) ‚Üí (a : F) ‚Üí G)\n  (h_op : ‚àÄ (x : E) (y : F), ‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ op (f x) (g x)) l (nhds 1)","name":"Filter.Tendsto.op_one_isBoundedUnder_le","isProp":true,"docString":"A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ ‚Äñx‚Äñ * ‚Äñy‚Äñ` instead of multiplication so that it\ncan be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`. "},{"type":"‚àÄ {n : ‚Ñ§} {a : ‚Ñ§} {b : ‚Ñ§} (a_1 : a ‚â° b [ZMOD n]), n ‚à£ b - a","name":"Int.ModEq.dvd","isProp":true,"docString":"**Alias** of the forward direction of `Int.modEq_iff_dvd`."},{"type":"‚àÄ {t : (a : Type u) ‚Üí Type u} [inst : Traversable t] [self : IsLawfulTraversable t] {F : (a : Type u) ‚Üí Type u}\n  {G : (a : Type u) ‚Üí Type u} [inst_1 : Applicative F] [inst_2 : Applicative G] [inst_3 : LawfulApplicative F]\n  [inst_4 : LawfulApplicative G] {Œ± : Type u} {Œ≤ : Type u} {Œ≥ : Type u} (f : (a : Œ≤) ‚Üí F Œ≥) (g : (a : Œ±) ‚Üí G Œ≤)\n  (x : t Œ±), traverse (Functor.Comp.mk ‚àò Functor.map f ‚àò g) x = Functor.Comp.mk (traverse f <$> traverse g x)","name":"IsLawfulTraversable.comp_traverse","isProp":true,"docString":"`traverse` plays well with composition of applicative functors. "},{"type":"‚àÄ {Œπ : Type u_1} [inst : Countable Œπ] {E : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (E i)]\n  [inst_1 : ‚àÄ (i : Œπ), PolishSpace (E i)], PolishSpace ((i : Œπ) ‚Üí E i)","name":"PolishSpace.pi_countable","isProp":true,"docString":"A countable product of Polish spaces is Polish. "},{"type":"‚àÄ {Œ± : Type u} [inst : MulOneClass Œ±] [inst_1 : HasDistribNeg Œ±] (a : Œ±), a * -1 = -a","name":"mul_neg_one","isProp":true,"docString":"An element of a ring multiplied by the additive inverse of one is the element's additive\ninverse. "},{"type":"‚àÄ {R : Type u_1} {X : Type u_2} [inst : CommSemiring R] (p : ‚Ñï) [inst_1 : CharP R p], CharP (FreeAlgebra R X) p","name":"FreeAlgebra.charP","isProp":true,"docString":"If `R` has characteristic `p`, then so does `FreeAlgebra R X`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤),\n  ContinuousMap.comp (Homeomorph.toContinuousMap f) (Homeomorph.toContinuousMap (Homeomorph.symm f)) =\n    ContinuousMap.id Œ≤","name":"Homeomorph.toContinuousMap_comp_symm","isProp":true,"docString":"Right inverse to a continuous map from a homeomorphism, mirroring `Equiv.self_comp_symm`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {e : LocalHomeomorph Œ± Œ≤} {e' : LocalHomeomorph Œ± Œ≤} {f : LocalHomeomorph Œ≤ Œ≥}\n  {f' : LocalHomeomorph Œ≤ Œ≥} (he : e ‚âà e') (hf : f ‚âà f'), LocalHomeomorph.trans e f ‚âà LocalHomeomorph.trans e' f'","name":"LocalHomeomorph.EqOnSource.trans'","isProp":true,"docString":"Composition of local homeomorphisms respects equivalence "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ≤} {g : (a : Œ≤) ‚Üí Œ±}\n  (hg : Set.InjOn g (s ‚à© Function.mulSupport (f ‚àò g))),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà g '' s) ‚Ü¶ f i) = finprod fun (j : Œ≤) ‚Ü¶ finprod fun (h : j ‚àà s) ‚Ü¶ f (g j)","name":"finprod_mem_image'","isProp":true,"docString":"The product of `f y` over `y ‚àà g '' s` equals the product of `f (g i)` over `s`\nprovided that `g` is injective on `s ‚à© mulSupport (f ‚àò g)`. "},{"type":"‚àÄ {Œ± : Type u_1} (v : Vector Œ± 1), Vector.toList v = [Vector.head v]","name":"Vector.toList_singleton","isProp":true,"docString":"The list that makes up a `Vector` made up of a single element,\nretrieved via `toList`, is equal to the list of that single element. "},{"type":"‚àÄ {Œ± : Type u_1} {S : Finset Œ±} {g : (a : Œ±) ‚Üí ‚Ñï} (hS : ‚àÄ (x : Œ±) (a : x ‚àà S), g x ‚â† 0),\n  Nat.factorization (Finset.prod S g) = Finset.sum S fun (x : Œ±) ‚Ü¶ Nat.factorization (g x)","name":"Nat.factorization_prod","isProp":true,"docString":"For any `p : ‚Ñï` and any function `g : Œ± ‚Üí ‚Ñï` that's non-zero on `S : Finset Œ±`,\nthe power of `p` in `S.prod g` equals the sum over `x ‚àà S` of the powers of `p` in `g x`.\nGeneralises `factorization_mul`, which is the special case where `S.card = 2` and `g = id`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddMonoid Œ±] (self : AddUnits Œ±), AddUnits.neg self + ‚Üëself = 0","name":"AddUnits.neg_val","isProp":true,"docString":"`neg` is the left additive inverse of `val` in the base `AddMonoid`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {s : Set E},\n  (ConvexIndependent ùïú Subtype.val : Prop) ‚Üî\n    (‚àÄ (x : E) (a : x ‚àà s), ¬¨(x ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) (s \\ {x}) : Prop) : Prop)","name":"convexIndependent_set_iff_not_mem_convexHull_diff","isProp":true,"docString":"If a set is convex independent, a point in the set is not in the convex hull of the other\npoints. See `convexIndependent_iff_not_mem_convexHull_diff` for the indexed family version. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Neg G] [inst_2 : Add G] [inst_3 : ContinuousAdd G]\n  [inst_4 : ContinuousNeg G], Continuous fun (g : G √ó G) ‚Ü¶ Prod.fst g + Prod.snd g + -Prod.fst g","name":"TopologicalAddGroup.continuous_conj_sum","isProp":true,"docString":"Conjugation is jointly continuous on `G √ó G` when both `add` and `neg` are continuous."},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommSemiring R] {t : Finset Œπ} (h : Finset.Nonempty t) (I : (a : Œπ) ‚Üí Ideal R),\n  ((sup·µ¢ fun (i : Œπ) ‚Ü¶\n          sup·µ¢ fun (h : i ‚àà t) ‚Ü¶ inf·µ¢ fun (j : Œπ) ‚Ü¶ inf·µ¢ fun (_hj : j ‚àà t) ‚Ü¶ inf·µ¢ fun (_ij : j ‚â† i) ‚Ü¶ I j) =\n        ‚ä§ :\n      Prop) ‚Üî\n    (Set.Pairwise ‚Üët fun (i : Œπ) (j : Œπ) ‚Ü¶ I i ‚äî I j = ‚ä§ : Prop)","name":"Ideal.sup·µ¢_inf·µ¢_eq_top_iff_pairwise","isProp":true,"docString":"A finite family of ideals is pairwise coprime (that is, any two of them generate the whole ring)\niff when taking all the possible intersections of all but one of these ideals, the resulting family\nof ideals still generate the whole ring.\n\nFor example with three ideals : `I ‚äî J = I ‚äî K = J ‚äî K = ‚ä§ ‚Üî (I ‚äì J) ‚äî (I ‚äì K) ‚äî (J ‚äì K) = ‚ä§`.\n\nWhen ideals are all of the form `I i = R ‚àô s i`, this is equivalent to the\n`exists_sum_eq_one_iff_pairwise_coprime` lemma."},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} {R‚ÇÉ : Type u_3} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Semiring R‚ÇÉ]\n  {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} [inst_3 : RingHomCompTriple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ]\n  [inst_4 : RingHomSurjective œÉ‚ÇÅ‚ÇÇ] [inst_5 : RingHomSurjective œÉ‚ÇÇ‚ÇÉ], RingHomSurjective œÉ‚ÇÅ‚ÇÉ","name":"RingHomSurjective.comp","isProp":true,"docString":"This cannot be an instance as there is no way to infer `œÉ‚ÇÅ‚ÇÇ` and `œÉ‚ÇÇ‚ÇÉ`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (a_1 : -a ‚â§ -b), b ‚â§ a","name":"le_of_neg_le_neg","isProp":true,"docString":"**Alias** of the forward direction of `neg_le_neg_iff`."},{"type":"‚àÄ {Œ± : Type u_2} {G : Type u_1} {s : Set Œ±} [inst : SubtractionCommMonoid G] (f : (a : Œ±) ‚Üí G) (g : (a : Œ±) ‚Üí G)\n  (hs : Set.Finite s),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i - g i) =\n    (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) - finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ g i","name":"finsum_mem_sub_distrib","isProp":true,"docString":"Given a finite set `s`, the sum of `f i / g i` over `i ‚àà s` equals the sum of `f i`\nover `i ‚àà s` minus the sum of `g i` over `i ‚àà s`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {a : Œ±} {s : Set Œ±},\n  (sup·µ¢ fun (b : Œ±) ‚Ü¶ sup·µ¢ fun (h : b ‚àà s) ‚Ü¶ b ‚äì a) ‚â§ sup‚Çõ s ‚äì a","name":"sup·µ¢_inf_le_sup‚Çõ_inf","isProp":true,"docString":"This is a weaker version of `sup‚Çõ_inf_eq` "},{"type":"‚àÄ {Œπ : Type u_1} {Œπ' : Type u_2} {Œ± : Type u_3} [inst : Finite Œπ] [inst : Preorder Œπ']\n  [inst_1 : IsDirected Œπ' fun (x : Œπ') (x_1 : Œπ') ‚Ü¶ x ‚â§ x_1] [inst_2 : Nonempty Œπ'] {s : (a : Œπ) ‚Üí (a : Œπ') ‚Üí Set Œ±}\n  (hs : ‚àÄ (i : Œπ), Monotone (s i)),\n  (Set.union·µ¢ fun (j : Œπ') ‚Ü¶ Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ s i j) = Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (j : Œπ') ‚Ü¶ s i j","name":"Set.union·µ¢_inter·µ¢_of_monotone","isProp":true,"docString":"An increasing union distributes over finite intersection. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} (f : P ‚ü∂ Q) [inst_1 : CategoryTheory.Mono f]\n  [inst_2 : CategoryTheory.StrongEpi f], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_mono_of_strongEpi","isProp":true,"docString":"A strong epimorphism that is a monomorphism is an isomorphism. "},{"type":"‚àÄ (z : ‚ÑÇ), ‚Üë(Complex.re z) = (z + ‚Üë(starRingEnd ‚ÑÇ) z) / 2","name":"Complex.re_eq_add_conj","isProp":true,"docString":"A complex number `z` plus its conjugate `conj z` is `2` times its real part. "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_2} {N : Type u_4} {R : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : AddCommMonoid N] [inst_4 : Module R N] ‚¶ÉœÜ : (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] N‚¶Ñ ‚¶Éœà : (Œ± ‚Üí‚ÇÄ M) ‚Üí‚Çó[R] N‚¶Ñ\n  (h : ‚àÄ (a : Œ±), LinearMap.comp œÜ (Finsupp.lsingle a) = LinearMap.comp œà (Finsupp.lsingle a)), œÜ = œà","name":"Finsupp.lhom_ext'","isProp":true,"docString":"Two `R`-linear maps from `Finsupp X M` which agree on each `single x y` agree everywhere.\n\nWe formulate this fact using equality of linear maps `œÜ.comp (lsingle a)` and `œà.comp (lsingle a)`\nso that the `ext` tactic can apply a type-specific extensionality lemma to prove equality of these\nmaps. E.g., if `M = R`, then it suffices to verify `œÜ (single a 1) = œà (single a 1)`. "},{"type":"‚àÄ {R : Type u_3} {E : Type u_4} {Œπ : Type u_1} {Œπ' : Type u_2} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E]\n  [inst_2 : Module R E] (s : Finset Œπ) (t : Finset Œπ') (ws : (a : Œπ) ‚Üí R) (zs : (a : Œπ) ‚Üí E) (wt : (a : Œπ') ‚Üí R)\n  (zt : (a : Œπ') ‚Üí E) (hws : (Finset.sum s fun (i : Œπ) ‚Ü¶ ws i) = 1) (hwt : (Finset.sum t fun (i : Œπ') ‚Ü¶ wt i) = 1)\n  (a : R) (b : R) (hab : a + b = 1),\n  a ‚Ä¢ Finset.centerMass s ws zs + b ‚Ä¢ Finset.centerMass t wt zt =\n    Finset.centerMass (Finset.disjSum s t) (Sum.elim (fun (i : Œπ) ‚Ü¶ a * ws i) fun (j : Œπ') ‚Ü¶ b * wt j) (Sum.elim zs zt)","name":"Finset.centerMass_segment'","isProp":true,"docString":"A convex combination of two centers of mass is a center of mass as well. This version\ndeals with two different index types. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {Œ±_1 : Type u_1} {p‚ÇÅ : (a : (a : Œ±) ‚Üí Œ±_1) ‚Üí Prop}\n  {f : m ((a : Œ±) ‚Üí Œ±_1)} {p‚ÇÇ : (a : Œ±) ‚Üí Prop} [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m Œ±}\n  (hf : SatisfiesM p‚ÇÅ f) (hx : SatisfiesM p‚ÇÇ x),\n  SatisfiesM\n    (fun (c : Œ±_1) ‚Ü¶ ‚àÉ (f : (a : Œ±) ‚Üí Œ±_1), ‚àÉ (a : Œ±), (p‚ÇÅ f : Prop) ‚àß ((p‚ÇÇ a : Prop) ‚àß (c = f a : Prop) : Prop))\n    (Seq.seq f fun (x_1 : Unit) ‚Ü¶ x)","name":"SatisfiesM.seq_post","isProp":true,"docString":"`SatisfiesM` distributes over `<*>`, strongest postcondition version. "},{"type":"‚àÄ {R : Type u_5} [inst : CommSemiring R] {k : Type u_2} {l : Type u_1} {m : Type u_3} {n : Type u_4}\n  [inst_1 : Fintype n] [inst_2 : DecidableEq n] [inst_3 : Fintype l] [inst_4 : DecidableEq l] (e‚ÇÅ : k ‚âÉ m) (e‚ÇÇ : l ‚âÉ n)\n  (M : Matrix k l R),\n  ‚ÜëMatrix.toLin' (‚Üë(Matrix.reindex e‚ÇÅ e‚ÇÇ) M) =\n    LinearMap.comp (‚Üë(LinearEquiv.funCongrLeft R R (Equiv.symm e‚ÇÅ)))\n      (LinearMap.comp (‚ÜëMatrix.toLin' M) ‚Üë(LinearEquiv.funCongrLeft R R e‚ÇÇ))","name":"Matrix.toLin'_reindex","isProp":true,"docString":"A variant of `Matrix.toLin'_submatrix` that keeps around `LinearEquiv`s. "},{"type":"‚àÄ {Œ± : Type u} (x : Œ±), ùí´{x} = {‚àÖ, {x}}","name":"Set.powerset_singleton","isProp":true,"docString":"The powerset of a singleton contains only `‚àÖ` and the singleton itself. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] (self : AddCommGroup.TotalPositiveCone Œ±) (a : Œ±),\n  (AddCommGroup.PositiveCone.nonneg (AddCommGroup.TotalPositiveCone.toPositiveCone self) a : Prop) ‚à®\n    (AddCommGroup.PositiveCone.nonneg (AddCommGroup.TotalPositiveCone.toPositiveCone self) (-a) : Prop)","name":"AddCommGroup.TotalPositiveCone.nonneg_total","isProp":true,"docString":"Either `a` or `-a` is `nonneg` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {J : Type u} [inst_1 : CategoryTheory.Category J] {j : J}\n  (I : CategoryTheory.Limits.IsInitial j) (F : J ‚•§ C) [inst_2 : CategoryTheory.Limits.HasLimit F],\n  CategoryTheory.IsIso (CategoryTheory.Limits.limit.œÄ F j)","name":"CategoryTheory.Limits.isIso_œÄ_of_isInitial","isProp":true,"docString":"If `j` is initial in the index category, then the map `limit.œÄ F j` is an isomorphism.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Sup Œ±] [inst_1 : Inf Œ±] (sup_comm : ‚àÄ (a : Œ±) (b : Œ±), a ‚äî b = b ‚äî a)\n  (sup_assoc : ‚àÄ (a : Œ±) (b : Œ±) (c : Œ±), a ‚äî b ‚äî c = a ‚äî (b ‚äî c)) (sup_idem : ‚àÄ (a : Œ±), a ‚äî a = a)\n  (inf_comm : ‚àÄ (a : Œ±) (b : Œ±), a ‚äì b = b ‚äì a) (inf_assoc : ‚àÄ (a : Œ±) (b : Œ±) (c : Œ±), a ‚äì b ‚äì c = a ‚äì (b ‚äì c))\n  (inf_idem : ‚àÄ (a : Œ±), a ‚äì a = a) (sup_inf_self : ‚àÄ (a : Œ±) (b : Œ±), a ‚äî a ‚äì b = a)\n  (inf_sup_self : ‚àÄ (a : Œ±) (b : Œ±), a ‚äì (a ‚äî b) = a), SemilatticeSup.toPartialOrder = SemilatticeInf.toPartialOrder","name":"semilatticeSup_mk'_partialOrder_eq_semilatticeInf_mk'_partialOrder","isProp":true,"docString":"The partial orders from `SemilatticeSup_mk'` and `SemilatticeInf_mk'` agree\nif `sup` and `inf` satisfy the lattice absorption laws `sup_inf_self` (`a ‚äî a ‚äì b = a`)\nand `inf_sup_self` (`a ‚äì (a ‚äî b) = a`). "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Inf Œ±] [inst_1 : Inf Œ≤] (self : InfHom Œ± Œ≤) (a : Œ±) (b : Œ±),\n  InfHom.toFun self (a ‚äì b) = InfHom.toFun self a ‚äì InfHom.toFun self b","name":"InfHom.map_inf'","isProp":true,"docString":"An `InfHom` preserves infima. "},{"type":"‚àÄ (m : ‚Ñï+) (n : ‚Ñï+), PNat.factorMultiset (PNat.gcd m n) = PNat.factorMultiset m ‚äì PNat.factorMultiset n","name":"PNat.factorMultiset_gcd","isProp":true,"docString":"The gcd and lcm operations on positive integers correspond\nto the inf and sup operations on multisets. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {t : Set Œ±}\n  (Hf : AntitoneOn f t) {a : Œ±} (a_1 : IsLeast t a), IsGreatest (f '' t) (f a)","name":"AntitoneOn.map_isLeast","isProp":true,"docString":"An antitone map sends a least element of a set to a greatest element of its image. "},{"type":"‚àÄ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : Monoid A] [self : MulDistribMulAction M A] (r : M),\n  r ‚Ä¢ 1 = 1","name":"MulDistribMulAction.smul_one","isProp":true,"docString":"Multiplying `1` by a scalar gives `1` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  [self : CategoryTheory.Full F] {X : C} {Y : C}\n  (f :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X ‚ü∂\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.Full.preimage f) = f","name":"CategoryTheory.Full.witness","isProp":true,"docString":"The property that `Full.preimage f` of maps to `f` via `F.map`. "},{"type":"‚àÄ (a : Cardinal), Cardinal.lift a = a","name":"Cardinal.lift_id","isProp":true,"docString":"A cardinal lifted to the same universe equals itself. "},{"type":"‚àÄ {n : ‚Ñï} (a : ZMod n), ‚Üë‚Üëa = a","name":"ZMod.int_cast_zmod_cast","isProp":true,"docString":"So-named because the outer coercion is `Int.cast` into `ZMod`. For `Int.cast` into an arbitrary\nring, see `ZMod.int_cast_cast`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Add Œ±] {u : Finset Œ±} {s : Set Œ±} {t : Set Œ±} (a : ‚Üëu ‚äÜ s + t),\n  ‚àÉ (s' : Finset Œ±), ‚àÉ (t' : Finset Œ±), (‚Üës' ‚äÜ s : Prop) ‚àß ((‚Üët' ‚äÜ t : Prop) ‚àß (u ‚äÜ s' + t' : Prop) : Prop)","name":"Finset.subset_add","isProp":true,"docString":"If a finset `u` is contained in the sum of two sets `s + t`, we can find two finsets\n`s'`, `t'` such that `s' ‚äÜ s`, `t' ‚äÜ t` and `u ‚äÜ s' + t'`."},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] [inst_1 : Filter.IsCountablyGenerated (uniformity Œ±)] (U : (a : ‚Ñï) ‚Üí Set (Œ± √ó Œ±))\n  (U_mem : ‚àÄ (n : ‚Ñï), U n ‚àà uniformity Œ±)\n  (HU :\n    ‚àÄ (u : (a : ‚Ñï) ‚Üí Œ±) (a : ‚àÄ (N : ‚Ñï) (m : ‚Ñï) (n : ‚Ñï) (a : N ‚â§ m) (a : N ‚â§ n), (u m, u n) ‚àà U N),\n      ‚àÉ (a : Œ±), Filter.Tendsto u Filter.atTop (nhds a)),\n  CompleteSpace Œ±","name":"UniformSpace.complete_of_convergent_controlled_sequences","isProp":true,"docString":"A uniform space is complete provided that (a) its uniformity filter has a countable basis;\n(b) any sequence satisfying a \"controlled\" version of the Cauchy condition converges. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {Z : C} {X : C} {Y : C} {c : CategoryTheory.Limits.BinaryCofan X Y}\n  (h : CategoryTheory.Limits.IsColimit c) (t : CategoryTheory.Limits.IsInitial Z),\n  CategoryTheory.IsPushout\n    (CategoryTheory.Limits.IsInitial.to t\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Limits.pair X Y))\n        { as := CategoryTheory.Limits.WalkingPair.left }))\n    (CategoryTheory.Limits.IsInitial.to t\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Limits.pair X Y))\n        { as := CategoryTheory.Limits.WalkingPair.right }))\n    (CategoryTheory.Limits.BinaryCofan.inl c) (CategoryTheory.Limits.BinaryCofan.inr c)","name":"CategoryTheory.IsPushout.of_is_coproduct","isProp":true,"docString":"If `c` is a colimiting binary coproduct cocone, and we have an initial object,\nthen we have `IsPushout 0 0 c.inl c.inr`\n(where each `0` is the unique morphism from the initial object). "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderBot Œ±]\n  (h :\n    ‚àÄ (c : Set Œ±) (a : IsChain (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) c) (a : Set.Nonempty c) (a : ¬¨(‚ä• ‚àà c : Prop)),\n      ‚àÉ (x : Œ±), ‚àÉ (x_1 : x ‚â† ‚ä•), x ‚àà lowerBounds c),\n  IsAtomic Œ±","name":"IsAtomic.of_isChain_bounded","isProp":true,"docString":"**Zorn's lemma**: A partial order is atomic if every nonempty chain `c`, `‚ä• ‚àâ c`, has an lower\nbound not equal to `‚ä•`. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) (b : P) (pred : (a : Œπ) ‚Üí Prop)\n  [inst_3 : DecidablePred pred],\n  (‚Üë(Finset.weightedVSubOfPoint (Finset.subtype pred s) (fun (i : Subtype pred) ‚Ü¶ p ‚Üëi) b) fun (i : Subtype pred) ‚Ü¶\n      w ‚Üëi) =\n    ‚Üë(Finset.weightedVSubOfPoint (Finset.filter pred s) p b) w","name":"Finset.weightedVSubOfPoint_subtype_eq_filter","isProp":true,"docString":"A weighted sum over `s.subtype pred` equals one over `s.filter pred`. "},{"type":"‚àÄ {Œ¥ : Type u_1} [inst : Finite Œ¥] {Œ∫ : (a : Œ¥) ‚Üí Type u_2} {t : (d : Œ¥) ‚Üí Set (Œ∫ d)}\n  (ht : ‚àÄ (d : Œ¥), Set.Finite (t d)), Set.Finite (Set.pi Set.univ t)","name":"Set.Finite.pi","isProp":true,"docString":"Finite product of finite sets is finite "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] {X : C} {Y : C}\n  {f : X ‚ü∂ Y} (h : f = 0) [inst_4 : CategoryTheory.Limits.HasImage f], CategoryTheory.Limits.image.Œπ f = 0","name":"CategoryTheory.Limits.image.Œπ_zero'","isProp":true,"docString":"If we know `f = 0`,\nit requires a little work to conclude `image.Œπ f = 0`,\nbecause `f = g` only implies `image f ‚âÖ image g`.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} (se : CategoryTheory.SplitEpi f),\n  CategoryTheory.IsSplitEpi f","name":"CategoryTheory.IsSplitEpi.mk'","isProp":true,"docString":"A constructor for `IsSplitEpi f` taking a `SplitEpi f` as an argument "},{"type":"‚àÄ {Œ± : Type uu} (a : Œ±) {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (a_1 : l‚ÇÅ <+~ l‚ÇÇ), a :: l‚ÇÅ <+~ a :: l‚ÇÇ","name":"List.subperm.cons","isProp":true,"docString":"**Alias** of the reverse direction of `List.subperm_cons`."},{"type":"‚àÄ (self : YoungDiagram), IsLowerSet ‚Üë(YoungDiagram.cells self)","name":"YoungDiagram.isLowerSet","isProp":true,"docString":"Cells are up-left justified, witnessed by the fact that `cells` is a lower set in `‚Ñï √ó ‚Ñï`. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : AddGroup G] [inst_1 : SubtractionMonoid H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F) (n : ‚Ñ§) (g : G), ‚Üëf (n ‚Ä¢ g) = n ‚Ä¢ ‚Üëf g","name":"map_zsmul","isProp":true,"docString":"Additive group homomorphisms preserve integer scaling."},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {L‚ÇÅ : C ‚•§ D}\n  {L‚ÇÇ : C ‚•§ D} {R‚ÇÅ : D ‚•§ C} {R‚ÇÇ : D ‚•§ C} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (f : L‚ÇÇ ‚ü∂ L‚ÇÅ)\n  [inst_2 : CategoryTheory.IsIso f], CategoryTheory.IsIso (‚Üë(CategoryTheory.transferNatTransSelf adj‚ÇÅ adj‚ÇÇ) f)","name":"CategoryTheory.transferNatTransSelf_iso","isProp":true,"docString":"If `f` is an isomorphism, then the transferred natural transformation is an isomorphism.\nThe converse is given in `transferNatTransSelf_of_iso`.\n"},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M ‚Üí+ N) {x : M} {y : M}\n  (h : x = y), ‚Üëf x = ‚Üëf y","name":"AddMonoidHom.congr_arg","isProp":true,"docString":"Deprecated: use `FunLike.congr_arg` instead."},{"type":"‚àÄ {M : Type u_1} {M‚ÇÇ : Type u_2} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid M‚ÇÇ] {R : Type u_3} {S : Type u_4}\n  [inst_2 : Semiring S] [inst_3 : SMul R M] [inst_4 : Module S M] [inst_5 : SMul R M‚ÇÇ] [inst_6 : Module S M‚ÇÇ]\n  [self : LinearMap.CompatibleSMul M M‚ÇÇ R S] (f‚Çó : M ‚Üí‚Çó[S] M‚ÇÇ) (c : R) (x : M), ‚Üëf‚Çó (c ‚Ä¢ x) = c ‚Ä¢ ‚Üëf‚Çó x","name":"LinearMap.CompatibleSMul.map_smul","isProp":true,"docString":"Scalar multiplication by `R` of `M` can be moved through linear maps. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} (a_1 : Order.IsSuccLimit a), Order.IsPredLimit (‚ÜëOrderDual.toDual a)","name":"Order.isSuccLimit.dual","isProp":true,"docString":"**Alias** of the reverse direction of `Order.isPredLimit_toDual_iff`."},{"type":"‚àÄ {p : ‚Ñï}, padicValInt p 0 = 0","name":"padicValInt.zero","isProp":true,"docString":"`padicValInt p 0` is `0` for any `p`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {m‚ÇÅ : MeasurableSpace Œ±} {m‚ÇÇ : MeasurableSpace Œ≤} {f : (a : Œ±) ‚Üí Œ≤} (a : Measurable f),\n  MeasurableSpace.comap f m‚ÇÇ ‚â§ m‚ÇÅ","name":"Measurable.comap_le","isProp":true,"docString":"**Alias** of the forward direction of `measurable_iff_comap_le`."},{"type":"‚àÄ (Œ± : Type u) [inst : Preorder Œ±] [inst_1 : Nonempty Œ±] [inst_2 : NoMaxOrder Œ±], ‚àÉ (f : (a : ‚Ñï) ‚Üí Œ±), StrictMono f","name":"Nat.exists_strictMono","isProp":true,"docString":"If `Œ±` is a nonempty preorder with no maximal elements, then there exists a strictly monotone\nfunction `‚Ñï ‚Üí Œ±`. "},{"type":"‚àÄ {Œ± : Sort u_1} {p : (a : Œ±) ‚Üí Prop} (hp : ‚àÄ (a : Œ±), ¬¨(p a : Prop)), IsEmpty (Subtype p)","name":"Subtype.isEmpty_of_false","isProp":true,"docString":"subtypes by an all-false predicate are false. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} [inst_1 : TopologicalSpace Œ±]\n  (L :\n    ‚àÄ (u : Set (Œ≤ √ó Œ≤)) (a : u ‚àà uniformity Œ≤),\n      ‚àÉ (F : (a : Œ±) ‚Üí Œ≤), (ContinuousOn F s : Prop) ‚àß (‚àÄ (y : Œ±) (a : y ‚àà s), (f y, F y) ‚àà u : Prop)),\n  ContinuousOn f s","name":"continuousOn_of_uniform_approx_of_continuousOn","isProp":true,"docString":"A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. "},{"type":"‚àÄ {Œ± : Sort u} {p : Prop} (h‚ÇÅ : Nonempty Œ±) (h‚ÇÇ : ‚àÄ (a : Œ±), p), p","name":"Nonempty.elim","isProp":true,"docString":"The elimination principle for `Nonempty Œ±`. If `Nonempty Œ±`, and we can\nprove `p` given any element `x : Œ±`, then `p` holds. Note that it is essential\nthat `p` is a `Prop` here; the version with `p` being a `Sort u` is equivalent\nto `Classical.choice`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhdsWithin a (Set.Iic a))\n  (hfs : ‚àÄ (b : Œ≤) (a_1 : b < f a), ‚àÉ (c : Œ±), (c ‚àà s : Prop) ‚àß (f c ‚àà Set.Ico b (f a) : Prop)),\n  ContinuousWithinAt f (Set.Iic a) a","name":"StrictMonoOn.continuousWithinAt_left_of_exists_between","isProp":true,"docString":"If `f` is a strictly monotone function on a left neighborhood of `a` and the image of this\nneighborhood under `f` meets every interval `[b, f a)`, `b < f a`, then `f` is continuous at `a`\nfrom the left.\n\nThe assumption `hfs : ‚àÄ b < f a, ‚àÉ c ‚àà s, f c ‚àà Ico b (f a)` is required because otherwise the\nfunction `f : ‚Ñù ‚Üí ‚Ñù` given by `f x = if x < 0 then x else x + 1` would be a counter-example at\n`a = 0`. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} {c : Œ±} [inst : LinearOrder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±]\n  [inst_3 : OrderedSub Œ±] (h : a - c < b - c), a < b","name":"lt_of_tsub_lt_tsub_right","isProp":true,"docString":"See `lt_of_tsub_lt_tsub_right_of_le` for a weaker statement in a partial order. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : sbtw a b c), sbtw b c a","name":"SBtw.sbtw.cyclic_left","isProp":true,"docString":"**Alias** of `sbtw_cyclic_left`."},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} {F : Type u_3} [inst : MulOneClass R] [inst_1 : Monoid S]\n  [inst_2 : MonoidHomClass F R S] (f : F) (r : R) [inst_3 : Invertible r] [ifr : Invertible (‚Üëf r)], ‚Üëf ‚Öür = ‚Öü(‚Üëf r)","name":"map_invOf","isProp":true,"docString":"Note that the `invertible (f r)` argument can be satisfied by using `letI := invertible.map f r`\nbefore applying this lemma. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±} (a_1 : IsTop a), IsBot (‚ÜëOrderDual.toDual a)","name":"IsTop.toDual","isProp":true,"docString":"**Alias** of the reverse direction of `isBot_toDual_iff`."},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Monoid R] [inst_1 : MulAction R M] {p : SubMulAction R M} (m : { x : M // x ‚àà p }),\n  Subtype.val '' MulAction.orbit R m = MulAction.orbit R ‚Üëm","name":"SubMulAction.val_image_orbit","isProp":true,"docString":"Orbits in a `SubMulAction` coincide with orbits in the ambient space. "},{"type":"‚àÄ {l : ‚Ñï} {m : ‚Ñï} {n : ‚Ñï} {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : AddCommMonoid Œ±] (A : Matrix (Fin l) (Fin m) Œ±)\n  (B : Matrix (Fin m) (Fin n) Œ±), Matrix.mul·µ£ A B = Matrix.mul A B","name":"Matrix.mul·µ£_eq","isProp":true,"docString":"This can be used to prove\n```lean\nexample [AddCommMonoid Œ±] [Mul Œ±] (a‚ÇÅ‚ÇÅ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÅ a‚ÇÇ‚ÇÇ b‚ÇÅ‚ÇÅ b‚ÇÅ‚ÇÇ b‚ÇÇ‚ÇÅ b‚ÇÇ‚ÇÇ : Œ±) :\n  !![a‚ÇÅ‚ÇÅ, a‚ÇÅ‚ÇÇ;\n     a‚ÇÇ‚ÇÅ, a‚ÇÇ‚ÇÇ] ‚¨ù !![b‚ÇÅ‚ÇÅ, b‚ÇÅ‚ÇÇ;\n                    b‚ÇÇ‚ÇÅ, b‚ÇÇ‚ÇÇ] =\n  !![a‚ÇÅ‚ÇÅ*b‚ÇÅ‚ÇÅ + a‚ÇÅ‚ÇÇ*b‚ÇÇ‚ÇÅ, a‚ÇÅ‚ÇÅ*b‚ÇÅ‚ÇÇ + a‚ÇÅ‚ÇÇ*b‚ÇÇ‚ÇÇ;\n     a‚ÇÇ‚ÇÅ*b‚ÇÅ‚ÇÅ + a‚ÇÇ‚ÇÇ*b‚ÇÇ‚ÇÅ, a‚ÇÇ‚ÇÅ*b‚ÇÅ‚ÇÇ + a‚ÇÇ‚ÇÇ*b‚ÇÇ‚ÇÇ] :=\n(mul·µ£_eq _ _).symm\n```\n"},{"type":"‚àÄ {a : ‚Ñù} {b : ‚Ñù} (h : a < b), Cardinal.mk ‚Üë(Set.Ioo a b) = Cardinal.continuum","name":"Cardinal.mk_Ioo_real","isProp":true,"docString":"The cardinality of the interval (a, b). "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : Module.Ray R M),\n  rayOfNeZero R (Module.Ray.someVector x)\n      ((Module.Ray.someVector_ne_zero x=:Module.Ray.someVector x ‚â† 0)=:Module.Ray.someVector x ‚â† 0) =\n    x","name":"Module.Ray.someVector_ray","isProp":true,"docString":"The ray of `someVector`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] (S : AddSubmonoid M), addLocalization.r S = addLocalization.r' S","name":"addLocalization.r_eq_r'","isProp":true,"docString":"The additive congruence relation used to localize an `AddCommMonoid` at a submonoid can be\nexpressed equivalently as an infimum (see `addLocalization.r`) or explicitly\n(see `addLocalization.r'`)."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommSemigroup Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ExistsAddOfLE Œ±]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [inst_4 : Sub Œ±]\n  [inst_5 : OrderedSub Œ±] {a : Œ±} {b : Œ±} {c : Œ±}\n  [inst_6 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] (hca : c ‚â§ a)\n  (h : a - b < a - c), c < b","name":"lt_of_tsub_lt_tsub_left_of_le","isProp":true,"docString":"See `lt_of_tsub_lt_tsub_left` for a stronger statement in a linear order. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤] {Œ∫ : Type u_2} {f : (a : Œ∫) ‚Üí Œ≤} (hf : DenseRange f) {s : Set Œ≤}\n  (hs : IsOpen s), s ‚äÜ closure (f '' (f ‚Åª¬π' s))","name":"DenseRange.subset_closure_image_preimage_of_isOpen","isProp":true,"docString":"If `f` has dense range and `s` is an open set in the codomain of `f`, then the image of the\npreimage of `s` under `f` is dense in `s`. "},{"type":"‚àÄ {p : ‚Ñï} (hp : Nat.Prime p) {n : ‚Ñï} {b : ‚Ñï} (a : Nat.log p n < b),\n  multiplicity p (Nat.factorial n) = ‚Üë(Finset.sum (Finset.Ico 1 b) fun (i : ‚Ñï) ‚Ü¶ n / p ^ i)","name":"Nat.Prime.multiplicity_factorial","isProp":true,"docString":"**Legendre's Theorem**\n\nThe multiplicity of a prime in `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G], MulAction.IsPretransitive G·µê·µí·µñ G","name":"MulAction.OppositeRegular.isPretransitive","isProp":true,"docString":"The right regular action of a group on itself is transitive. "},{"type":"‚àÄ {Œ± : Sort u} {a : Œ±} {b : Œ±} (h : a = b), b = a","name":"Eq.symm","isProp":true,"docString":"Equality is symmetric: if `a = b` then `b = a`.\n\nBecause this is in the `Eq` namespace, if you have a variable `h : a = b`,\n`h.symm` can be used as shorthand for `Eq.symm h` as a proof of `b = a`.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"type":"failed to pretty print expression (use 'set_option pp.rawOnError true' for raw representation)","name":"padicValRat.of_int_multiplicity","isProp":true,"docString":"The `p`-adic value of an integer `z ‚â† 0` is the multiplicity of `p` in `z`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≤' : Type u_5} {Œ≥ : Type u_2} {Œ¥ : Type u_1} {m : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {f : Filter Œ±}\n  {g : Filter Œ≤} {n : (a : Œ≥) ‚Üí Œ¥} {m' : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ¥} {n' : (a : Œ≤) ‚Üí Œ≤'}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), n (m a b) = m' a (n' b)),\n  Filter.map n (Filter.map‚ÇÇ m f g) = Filter.map‚ÇÇ m' f (Filter.map n' g)","name":"Filter.map_map‚ÇÇ_distrib_right","isProp":true,"docString":"Symmetric statement to `Filter.map_map‚ÇÇ_right_comm`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (E : Set Œ±) (s : Set ‚Ñù)\n  (hs : ‚àÄ (Œµ : ‚Ñù) (a : 0 < Œµ), Set.Nonempty (s ‚à© Set.Ioc 0 Œµ)),\n  closure E = Set.inter·µ¢ fun (Œ¥ : ‚Ñù) ‚Ü¶ Set.inter·µ¢ fun (h : Œ¥ ‚àà s) ‚Ü¶ Metric.cthickening Œ¥ E","name":"Metric.closure_eq_inter·µ¢_cthickening'","isProp":true,"docString":"The closure of a set equals the intersection of its closed thickenings of positive radii\naccumulating at zero. "},{"type":"‚àÄ {M : Type u_3} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_4} [inst_1 : CommMonoid N] {P : Type u_1}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P} {T : Submonoid P} {Q : Type u_2}\n  [inst_3 : CommMonoid Q] (hg : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) (k : Submonoid.LocalizationMap T Q) {x : M}\n  {y : M} (h : ‚Üë(Submonoid.LocalizationMap.toMap f) x = ‚Üë(Submonoid.LocalizationMap.toMap f) y),\n  ‚Üë(Submonoid.LocalizationMap.toMap k) (‚Üëg x) = ‚Üë(Submonoid.LocalizationMap.toMap k) (‚Üëg y)","name":"Submonoid.LocalizationMap.comp_eq_of_eq","isProp":true,"docString":"Given `CommMonoid`s `M, P`, Localization maps `f : M ‚Üí* N, k : P ‚Üí* Q` for Submonoids\n`S, T` respectively, and `g : M ‚Üí* P` such that `g(S) ‚äÜ T`, `f x = f y` implies\n`k (g x) = k (g y)`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (e : C ‚âå D)\n  (Y : D),\n  (CategoryTheory.Equivalence.unit e).app\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.inverse e)) Y) ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.inverse e))\n        ((CategoryTheory.Equivalence.counit e).app Y) =\n    ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.inverse e)) Y)","name":"CategoryTheory.Equivalence.unit_inverse_comp","isProp":true,"docString":"The other triangle equality. The proof follows the following proof in Globular:\nhttp://globular.science/1905.001 "},{"type":"‚àÄ {p : Prop} (a : Erased (p : Prop)), p","name":"Erased.out_proof","isProp":true,"docString":"Extracts the erased value, if it is a proof. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) {Z : C} (g : Y ‚ü∂ Z) {W : C} (h : Z ‚ü∂ W)\n  [inst_1 : CategoryTheory.Limits.HasImage (g ‚â´ h)] [inst_2 : CategoryTheory.Limits.HasImage (f ‚â´ g ‚â´ h)]\n  [inst_3 : CategoryTheory.Limits.HasImage h] [inst_4 : CategoryTheory.Limits.HasImage ((f ‚â´ g) ‚â´ h)],\n  CategoryTheory.Limits.image.preComp f (g ‚â´ h) ‚â´ CategoryTheory.Limits.image.preComp g h =\n    CategoryTheory.Limits.image.eqToHom\n        ((Eq.symm\n              ((CategoryTheory.Category.assoc f g\n                    h=:(f ‚â´ g) ‚â´ h =\n                    f ‚â´ g ‚â´ h)=:(f ‚â´ g) ‚â´ h = f ‚â´ g ‚â´ h)=:f ‚â´ g ‚â´ h = (f ‚â´ g) ‚â´ h)=:f ‚â´ g ‚â´ h = (f ‚â´ g) ‚â´ h) ‚â´\n      CategoryTheory.Limits.image.preComp (f ‚â´ g) h","name":"CategoryTheory.Limits.image.preComp_comp","isProp":true,"docString":"The two step comparison map\n  `image (f ‚â´ (g ‚â´ h)) ‚ü∂ image (g ‚â´ h) ‚ü∂ image h`\nagrees with the one step comparison map\n  `image (f ‚â´ (g ‚â´ h)) ‚âÖ image ((f ‚â´ g) ‚â´ h) ‚ü∂ image h`.\n "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} {r : R} (h : SameRay R x y) (hr : 0 < r), SameRay R x (r ‚Ä¢ y)","name":"SameRay.pos_smul_right","isProp":true,"docString":"A vector is in the same ray as a positive multiple of one it is in the same ray as. "},{"type":"‚àÄ {R : Type u} [inst : OrderedRing R] [inst_1 : StarOrderedRing R] [inst_2 : Algebra ‚Ñù R] [inst_3 : OrderedSMul ‚Ñù R]\n  [inst_4 : StarModule ‚Ñù R] (A‚ÇÄ : R) (A‚ÇÅ : R) (B‚ÇÄ : R) (B‚ÇÅ : R) (T : IsCHSHTuple A‚ÇÄ A‚ÇÅ B‚ÇÄ B‚ÇÅ),\n  A‚ÇÄ * B‚ÇÄ + A‚ÇÄ * B‚ÇÅ + A‚ÇÅ * B‚ÇÄ - A‚ÇÅ * B‚ÇÅ ‚â§ Real.sqrt 2 ^ 3 ‚Ä¢ 1","name":"tsirelson_inequality","isProp":true,"docString":"In a noncommutative ordered `*`-algebra over ‚Ñù,\nTsirelson's bound for a CHSH tuple (A‚ÇÄ, A‚ÇÅ, B‚ÇÄ, B‚ÇÅ) is\n`A‚ÇÄ * B‚ÇÄ + A‚ÇÄ * B‚ÇÅ + A‚ÇÅ * B‚ÇÄ - A‚ÇÅ * B‚ÇÅ ‚â§ 2^(3/2) ‚Ä¢ 1`.\n\nWe prove this by providing an explicit sum-of-squares decomposition\nof the difference.\n\n(We could work over `‚Ñ§[2^(1/2), 2^(-1/2)]` if we really wanted to!)\n"},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_2} {Œ≤ : Type u_1} (f : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ≤) (b : Œ≤) (v : Vector Œ± n),\n  Vector.toList (Vector.scanl f b v) = List.scanl f b (Vector.toList v)","name":"Vector.toList_scanl","isProp":true,"docString":"The `toList` of a `Vector` after a `scanl` is the `List.scanl`\nof the `toList` of the original `Vector`.\n"},{"type":"‚àÄ {Œ± : Sort u_1} {s‚ÇÅ : Setoid Œ±} {p : (a : Quotient s‚ÇÅ) ‚Üí Prop} (q : Quotient s‚ÇÅ) (h : ‚àÄ (a : Œ±), p (Quotient.mk'' a)),\n  p q","name":"Quotient.inductionOn'","isProp":true,"docString":"A version of `Quotient.inductionOn` taking `{s : Setoid Œ±}` as an implicit argument instead\nof an instance argument. "},{"type":"‚àÄ (a : ‚Ñ§), ‚Üë(Int.natAbs a) ‚â§ a ^ 2","name":"Int.natAbs_le_self_pow_two","isProp":true,"docString":"**Alias** of `Int.natAbs_le_self_sq`."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s1 : AffineSubspace k P} {s2 : AffineSubspace k P} (h1 : Set.Nonempty ‚Üës1)\n  (h2 : Set.Nonempty ‚Üës2) (he : ‚Üës1 ‚à© ‚Üës2 = ‚àÖ),\n  AffineSubspace.direction s1 ‚äî AffineSubspace.direction s2 < AffineSubspace.direction (s1 ‚äî s2)","name":"AffineSubspace.sup_direction_lt_of_nonempty_of_inter_empty","isProp":true,"docString":"The sup of the directions of two nonempty affine subspaces with empty intersection is less than\nthe direction of their sup. "},{"type":"‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} {v : (a : Œ±) ‚Üí ‚Ñù}\n  (a : (fun (x : Œ±) ‚Ü¶ abs (u x)) =o[l] fun (x : Œ±) ‚Ü¶ abs (v x)), u =o[l] v","name":"Asymptotics.IsLittleO.of_abs_abs","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_abs_abs`."},{"type":"‚àÄ {n : ‚Ñï} (p : Fin n) (i : Fin n), Fin.predAbove p (‚Üë(Fin.succAbove (‚ÜëFin.castSucc p)) i) = i","name":"Fin.predAbove_succAbove","isProp":true,"docString":"Sending `Fin n` into `Fin (n + 1)` with a gap at `p`\nthen back to `Fin n` by subtracting one from anything above `p` is the identity. "},{"type":"‚àÄ (M : Type u_2) (Œ± : Type u_1) [inst : Monoid M] [inst_1 : MulAction M Œ±] {s : Set Œ±} {t : Set Œ±},\n  fixingSubmonoid M (s ‚à™ t) = fixingSubmonoid M s ‚äì fixingSubmonoid M t","name":"fixingSubmonoid_union","isProp":true,"docString":"Fixing submonoid of union is intersection "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Semiring Œ±] [inst_1 : Semiring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsSemiringHom f) (x : Œ±)\n  (y : Œ±), f (x + y) = f x + f y","name":"IsSemiringHom.map_add","isProp":true,"docString":"The proposition that `f` preserves addition. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : a ‚â§ b) (a_2 : b ‚â§ c), a ‚â§ c","name":"LE.le.trans","isProp":true,"docString":"**Alias** of `le_trans`."},{"type":"‚àÄ {Œ± : Type u_2} {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddCommGroup G] [inst_2 : TopologicalAddGroup G]\n  {f : (a : Œ±) ‚Üí G} (hf : Summable f), Filter.Tendsto f Filter.cofinite (nhds 0)","name":"Summable.tendsto_cofinite_zero","isProp":true,"docString":"Series divergence test: if `f` is a convergent series, then `f x` tends to zero along\n`cofinite`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [inst_1 : Preorder Œ±] [inst_2 : CompactIccSpace Œ±] {s : Set Œ±}\n  (h‚ÇÅ : BddAbove s) (h‚ÇÇ : BddBelow s), Metric.Bounded s","name":"Metric.bounded_of_bddAbove_of_bddBelow","isProp":true,"docString":"In a pseudo metric space with a conditionally complete linear order such that the order and the\nmetric structure give the same topology, any order-bounded set is metric-bounded. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (e : M ‚âÉ‚Çó[R] M) (v : Module.Ray R M), e ‚Ä¢ v = ‚Üë(Module.Ray.map e) v","name":"Module.Ray.linearEquiv_smul_eq_map","isProp":true,"docString":"The action via `LinearEquiv.apply_distribMulAction` corresponds to `Module.Ray.map`. "},{"type":"‚àÄ (V : Type u_1) [inst : SeminormedAddCommGroup V], ‚ÄñNormedAddGroupHom.id V‚Äñ ‚â§ 1","name":"NormedAddGroupHom.norm_id_le","isProp":true,"docString":"The norm of the identity is at most `1`. It is in fact `1`, except when the norm of every\nelement vanishes, where it is `0`. (Since we are working with seminorms this can happen even if the\nspace is non-trivial.) It means that one can not do better than an inequality in general. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_4} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {V‚ÇÇ : Type u_5} {P‚ÇÇ : Type u_3} [inst_4 : AddCommGroup V‚ÇÇ] [inst_5 : Module k V‚ÇÇ]\n  [inst_6 : AddTorsor V‚ÇÇ P‚ÇÇ] {s : Set P} (e : P ‚âÉ·µÉ[k] P‚ÇÇ),\n  (AffineIndependent k Subtype.val : Prop) ‚Üî (AffineIndependent k Subtype.val : Prop)","name":"AffineEquiv.affineIndependent_set_of_eq_iff","isProp":true,"docString":"Affine equivalences preserve affine independence of subsets. "},{"type":"‚àÄ {X : outParam (Type u_1)} {Y : outParam (Type u_2)} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  {F : Type u_3} {f‚ÇÄ : outParam C(X, Y)} {f‚ÇÅ : outParam C(X, Y)} [self : ContinuousMap.HomotopyLike F f‚ÇÄ f‚ÇÅ] (f : F)\n  (x : X), ‚Üëf (1, x) = ‚Üëf‚ÇÅ x","name":"ContinuousMap.HomotopyLike.map_one_left","isProp":true,"docString":"value of the homotopy at 1 "},{"type":"‚àÄ (Œ± : Type u), IsEquiv Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x = x_1","name":"eq_isEquiv","isProp":true,"docString":"Equality is an equivalence relation. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.StrongMonoCategory C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.Mono f], CategoryTheory.StrongMono f","name":"CategoryTheory.StrongMonoCategory.strongMono_of_mono","isProp":true,"docString":"A strong mono category is a category in which every monomorphism is strong. "},{"type":"‚àÄ {Œ± : Type u_1} (A : Finset Œ±) (i : ‚Ñï) (h‚ÇÅ : i ‚â§ Finset.card A),\n  ‚àÉ (B : Finset Œ±), (B ‚äÜ A : Prop) ‚àß (Finset.card B = i : Prop)","name":"Finset.exists_smaller_set","isProp":true,"docString":"We can shrink `A` to any smaller size. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] (r : ‚Ñù) (C : ‚Ñù) (hr : r < 1) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu : ‚àÄ (n : ‚Ñï), dist (f n) (f (n + 1)) ‚â§ C * r ^ n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a)),\n  dist (f 0) a ‚â§ C / (1 - r)","name":"dist_le_of_le_geometric_of_tendsto‚ÇÄ","isProp":true,"docString":"If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then the distance from\n`f n` to the limit of `f` is bounded above by `C * r^n / (1 - r)`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {x : Œ±} (hx : x ‚àà s)\n  (fin : EMetric.hausdorffEdist s t ‚â† ‚ä§), Metric.infDist x t ‚â§ Metric.hausdorffDist s t","name":"Metric.infDist_le_hausdorffDist_of_mem","isProp":true,"docString":"The distance to a set is controlled by the Hausdorff distance "},{"type":"‚àÄ {a : Prop} {b : Prop} {c : Prop} (h : (a : Prop) ‚à® (b : Prop)) (left : ‚àÄ (a : a), c) (right : ‚àÄ (a : b), c), c","name":"Or.elim","isProp":true,"docString":"Proof by cases on an `Or`. If `a ‚à® b`, and both `a` and `b` imply\nproposition `c`, then `c` is true.\n"},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_2} {N : Type u_1} [inst : CommMonoid M] [inst_1 : OrderedCommMonoid N] (f : (a : M) ‚Üí N)\n  (h_mul : ‚àÄ (x : M) (y : M), f (x * y) ‚â§ f x * f y) {s : Finset Œπ} (hs : Finset.Nonempty s) (g : (a : Œπ) ‚Üí M),\n  f (Finset.prod s fun (i : Œπ) ‚Ü¶ g i) ‚â§ Finset.prod s fun (i : Œπ) ‚Ü¶ f (g i)","name":"Finset.le_prod_nonempty_of_submultiplicative","isProp":true,"docString":"If `f : M ‚Üí N` is a submultiplicative function, `f (x * y) ‚â§ f x * f y` and `g i`, `i ‚àà s`, is a\nnonempty finite family of elements of `M`, then `f (‚àè i in s, g i) ‚â§ ‚àè i in s, f (g i)`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] [inst_1 : Fintype Œπ] (f : (a : Œπ) ‚Üí Set Œ±) (a : Œ±),\n  (a ‚àà Finset.prod Finset.univ fun (i : Œπ) ‚Ü¶ f i : Prop) ‚Üî\n    (‚àÉ (g : (a : Œπ) ‚Üí Œ±), ‚àÉ (x : ‚àÄ (i : Œπ), g i ‚àà f i), (Finset.prod Finset.univ fun (i : Œπ) ‚Ü¶ g i) = a : Prop)","name":"Set.mem_fintype_prod","isProp":true,"docString":"A version of `Set.mem_finset_prod` with a simpler RHS for products over a Fintype. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : PseudoMetricSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±},\n  (UniformEquicontinuous F : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n        ‚àÉ (Œ¥ : ‚Ñù), (Œ¥ > 0 : Prop) ‚àß (‚àÄ (x : Œ≤) (y : Œ≤) (a : dist x y < Œ¥) (i : Œπ), dist (F i x) (F i y) < Œµ : Prop) :\n      Prop)","name":"Metric.uniformEquicontinuous_iff","isProp":true,"docString":"Characterization of uniform equicontinuity for families of functions between\n(pseudo) metric spaces. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p : P), Function.Injective fun (x : G) ‚Ü¶ x +·µ• p","name":"vadd_right_injective","isProp":true,"docString":"Adding a group element to the point `p` is an injective\nfunction. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {œÉ' : S ‚Üí+* R}\n  [inst_2 : RingHomInvPair œÉ œÉ'] [inst_3 : RingHomInvPair œÉ' œÉ] {M : Type u_3} {M‚ÇÇ : Type u_4}\n  [inst_4 : AddCommMonoid M] [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R M] [inst_7 : Module S M‚ÇÇ]\n  (self : M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ), Function.LeftInverse (LinearEquiv.invFun self) (AddHom.toFun (LinearMap.toAddHom ‚Üëself))","name":"LinearEquiv.left_inv","isProp":true,"docString":"`LinearEquiv.invFun` is a left inverse to the linear equivalence's underlying function. "},{"type":"‚àÄ {k : Type u_2} {E : Type u_1} {PE : Type u_3} [inst : Field k] [inst_1 : AddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : AddTorsor E PE] (f : (a : k) ‚Üí PE) (a : k) (b : k) (c : k),\n  ((b - a) / (c - a)) ‚Ä¢ slope f a b + ((c - b) / (c - a)) ‚Ä¢ slope f b c = slope f a c","name":"sub_div_sub_smul_slope_add_sub_div_sub_smul_slope","isProp":true,"docString":"`slope f a c` is a linear combination of `slope f a b` and `slope f b c`. This version\nexplicitly provides coefficients. If `a ‚â† c`, then the sum of the coefficients is `1`, so it is\nactually an affine combination, see `lineMap_slope_slope_sub_div_sub`. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (hab : a < b) (h‚ÇÄ : 0 < r) (h‚ÇÅ : r < 1),\n  (f (‚Üë(AffineMap.lineMap a b) r) ‚â§ ‚Üë(AffineMap.lineMap (f a) (f b)) r : Prop) ‚Üî\n    (slope f a (‚Üë(AffineMap.lineMap a b) r) ‚â§ slope f (‚Üë(AffineMap.lineMap a b) r) b : Prop)","name":"map_le_lineMap_iff_slope_le_slope","isProp":true,"docString":"Given `c = lineMap a b r`, `a < c < b`, the point `(c, f c)` is non-strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a c ‚â§ slope f c b`. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} (i : Œπ) [inst : Infinite (œÄ i)] [inst : (i : Œπ) ‚Üí Zero (œÄ i)],\n  Infinite (Dfinsupp fun (i : Œπ) ‚Ü¶ œÄ i)","name":"Dfinsupp.infinite_of_exists_right","isProp":true,"docString":"See `Dfinsupp.infinite_of_right` for this in instance form, with the drawback that\nit needs all `œÄ i` to be infinite. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {B : C} {A : C} {X : CategoryTheory.Subobject B} (f : A ‚ü∂ B)\n  [inst_1 : CategoryTheory.Mono f]\n  (i : A ‚âÖ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.Subobject.underlying) X)\n  (w : CategoryTheory.Iso.hom i ‚â´ CategoryTheory.Subobject.arrow X = f), CategoryTheory.Subobject.mk f = X","name":"CategoryTheory.Subobject.mk_eq_of_comm","isProp":true,"docString":"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. "},{"type":"‚àÄ {G‚ÇÄ : Type u} [self : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ), GroupWithZero.zpow 0 a = 1","name":"GroupWithZero.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.CategoryStruct C] {X : CategoryTheory.LocallyDiscrete C}\n  {Y : CategoryTheory.LocallyDiscrete C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} (Œ∑ : f ‚ü∂ g), f = g","name":"CategoryTheory.LocallyDiscrete.eq_of_hom","isProp":true,"docString":"Extract the equation from a 2-morphism in a locally discrete 2-category. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {u : (a : Œπ) ‚Üí Set X} {s : Set X}\n  (self : ShrinkingLemma.PartialRefinement u s) {i : Œπ}\n  (a : ¬¨(i ‚àà ShrinkingLemma.PartialRefinement.carrier self : Prop)), ShrinkingLemma.PartialRefinement.toFun self i = u i","name":"ShrinkingLemma.PartialRefinement.apply_eq","isProp":true,"docString":"Sets that correspond to `i ‚àâ carrier` are not modified. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Set Œ≤) {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Bijective f),\n  Function.Bijective (Set.restrictPreimage t f)","name":"Function.Bijective.restrictPreimage","isProp":true,"docString":"**Alias** of `Set.restrictPreimage_bijective`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 0) (hb : b ‚â§ 0), a + b < 0","name":"add_neg_of_neg_of_nonpos","isProp":true,"docString":"**Alias** of `Left.add_neg_of_neg_of_nonpos`."},{"type":"‚àÄ {c : (a : Type u) ‚Üí Type u} {hom : ‚¶ÉŒ± : Type u‚¶Ñ ‚Üí ‚¶ÉŒ≤ : Type u‚¶Ñ ‚Üí (x : c Œ±) ‚Üí (x : c Œ≤) ‚Üí Type u}\n  (self : CategoryTheory.BundledHom hom) {Œ± : Type u} {Œ≤ : Type u} {Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥)\n  (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥),\n  CategoryTheory.BundledHom.toFun self IŒ± IŒ≥ (CategoryTheory.BundledHom.comp self IŒ± IŒ≤ IŒ≥ g f) =\n    CategoryTheory.BundledHom.toFun self IŒ≤ IŒ≥ g ‚àò CategoryTheory.BundledHom.toFun self IŒ± IŒ≤ f","name":"CategoryTheory.BundledHom.comp_toFun","isProp":true,"docString":"compatibility with the composition "},{"type":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±] (i : Œ±) (j : Œ±),\n  Function.Involutive ((fun (x : Equiv.Perm Œ±) (x_1 : Equiv.Perm Œ±) ‚Ü¶ x * x_1) (Equiv.swap i j))","name":"Equiv.swap_mul_involutive","isProp":true,"docString":"A stronger version of `mul_right_injective` "},{"type":"‚àÄ {G‚ÇÄ : Type u} [self : GroupWithZero G‚ÇÄ] (n : ‚Ñï) (a : G‚ÇÄ),\n  GroupWithZero.zpow (Int.ofNat (Nat.succ n)) a = a * GroupWithZero.zpow (Int.ofNat n) a","name":"GroupWithZero.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ {Œ± : Type u_1} (f : (a : Œ±) ‚Üí Set Œ±), ¬¨(Function.Surjective f : Prop)","name":"Function.cantor_surjective","isProp":true,"docString":"**Cantor's diagonal argument** implies that there are no surjective functions from `Œ±`\nto `Set Œ±`. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} {M‚ÇÉ : Type v‚ÇÉ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : AddCommMonoid M‚ÇÉ]\n  [inst_4 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)] [inst_5 : Module R M‚ÇÇ] [inst_6 : Module R M‚ÇÉ] (g : M‚ÇÇ ‚Üí‚Çó[R] M‚ÇÉ)\n  (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) (p : Submodule R M‚ÇÉ) (h : ‚àÄ (c : M‚ÇÇ), ‚Üëg c ‚àà p),\n  LinearMap.compMultilinearMap (LinearMap.codRestrict p g h) f =\n    MultilinearMap.codRestrict (LinearMap.compMultilinearMap g f) p\n      (fun (v : (i : Œπ) ‚Üí M‚ÇÅ i) ‚Ü¶ (_ : ‚Üëg (‚Üëf v) ‚àà p)=:‚àÄ (v : (i : Œπ) ‚Üí M‚ÇÅ i), ‚Üëg (‚Üëf v) ‚àà p)","name":"LinearMap.compMultilinearMap_codRestrict","isProp":true,"docString":"The multilinear version of `LinearMap.comp_codRestrict` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {G : CategoryTheory.Comonad C}\n  {A : CategoryTheory.Comonad.Coalgebra G} {B : CategoryTheory.Comonad.Coalgebra G}\n  (self : CategoryTheory.Comonad.Coalgebra.Hom A B),\n  CategoryTheory.Comonad.Coalgebra.a A ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Comonad.toFunctor G))\n        (CategoryTheory.Comonad.Coalgebra.Hom.f self) =\n    CategoryTheory.Comonad.Coalgebra.Hom.f self ‚â´ CategoryTheory.Comonad.Coalgebra.a B","name":"CategoryTheory.Comonad.Coalgebra.Hom.h","isProp":true,"docString":"Compatibility with the structure morphism, for a morphism of coalgebras. "},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteCoproducts C]\n  [inst_2 : CategoryTheory.Preadditive C] {X : CategoryTheory.SimplicialObject C} (s : SimplicialObject.Splitting X)\n  {n : ‚Ñï} (A : SimplicialObject.Splitting.IndexSet (Opposite.op (SimplexCategory.mk n)))\n  (hA : ¬¨(SimplicialObject.Splitting.IndexSet.EqId A : Prop)),\n  SimplicialObject.Splitting.ŒπSummand s A ‚â´ HomologicalComplex.Hom.f AlgebraicTopology.DoldKan.PInfty n = 0","name":"SimplicialObject.Splitting.ŒπSummand_comp_PInfty_eq_zero","isProp":true,"docString":"If a simplicial object `X` in an additive category is split,\nthen `PInfty` vanishes on all the summands of `X _[n]` which do\nnot correspond to the identity of `[n]`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)],\n  Function.swap hammingDist = hammingDist","name":"swap_hammingDist","isProp":true,"docString":"Corresponds to `swap_dist`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteBooleanAlgebra Œ±] (s : Set Œ±) (a : Œ±) (a_1 : ‚àÄ (b : Œ±) (a_1 : b ‚àà s), a ‚â§ b),\n  a ‚â§ inf‚Çõ s","name":"CompleteBooleanAlgebra.le_inf‚Çõ","isProp":true,"docString":"Any lower bound is less than the set infimum. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommMonoidWithZero Œ±], 0 ‚â§ 1","name":"LinearOrderedCommMonoidWithZero.zero_le_one","isProp":true,"docString":"`0 ‚â§ 1` in any linearly ordered commutative monoid. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} {t : Set Œ≤},\n  (IsOpen (s √óÀ¢ t) : Prop) ‚Üî\n    (((IsOpen s : Prop) ‚àß (IsOpen t : Prop) : Prop) ‚à® ((s = ‚àÖ : Prop) ‚à® (t = ‚àÖ : Prop) : Prop) : Prop)","name":"isOpen_prod_iff'","isProp":true,"docString":"A product set is open in a product space if and only if each factor is open, or one of them is\nempty "},{"type":"‚àÄ {G : Type u_1} [inst : DivInvMonoid G] (a : G) (b : G), a / b = a * b‚Åª¬π","name":"division_def","isProp":true,"docString":"**Alias** of `div_eq_mul_inv`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : IsPreconnected s) (ht : IsClopen t)\n  (hne : Set.Nonempty (s ‚à© t)), s ‚äÜ t","name":"IsPreconnected.subset_clopen","isProp":true,"docString":"Preconnected sets are either contained in or disjoint to any given clopen set. "},{"type":"‚àÄ {M : Type u_1} [inst : CommGroup M] (f : (a : ‚Ñï) ‚Üí M) (n : ‚Ñï),\n  (Finset.prod (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f (i + 1) / f i) = f n / f 0","name":"Finset.prod_range_div","isProp":true,"docString":"A telescoping product along `{0, ..., n - 1}` of a commutative group valued function reduces to\nthe ratio of the last and first factors. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {s : Set Œ±} (hs : Set.Finite s),\n  ‚àÉ (U : (a : Œ±) ‚Üí Set Œ±),\n    (‚àÄ (x : Œ±), (x ‚àà U x : Prop) ‚àß (IsOpen (U x) : Prop) : Prop) ‚àß (Set.PairwiseDisjoint s U : Prop)","name":"Set.Finite.t2_separation","isProp":true,"docString":"Points of a finite set can be separated by open sets from each other. "},{"type":"‚àÄ {S : Type u_1} [inst : Mul S] (a : S), Commute a a","name":"Commute.refl","isProp":true,"docString":"Any element commutes with itself. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : SigmaCompactSpace Œ±],\n  ‚àÉ (K : (a : ‚Ñï) ‚Üí Set Œ±), (‚àÄ (n : ‚Ñï), IsCompact (K n) : Prop) ‚àß ((Set.union·µ¢ fun (n : ‚Ñï) ‚Ü¶ K n) = Set.univ : Prop)","name":"SigmaCompactSpace.exists_compact_covering","isProp":true,"docString":"In a œÉ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±·µí·µà} {b : Œ±·µí·µà} (a_1 : b < a), ‚ÜëOrderDual.ofDual a < ‚ÜëOrderDual.ofDual b","name":"LT.lt.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `OrderDual.ofDual_lt_ofDual`."},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C],\n  (CategoryTheory.EssentiallySmall C : Prop) ‚Üî\n    ((Small (CategoryTheory.Skeleton C) : Prop) ‚àß (CategoryTheory.LocallySmall C : Prop) : Prop)","name":"CategoryTheory.essentiallySmall_iff","isProp":true,"docString":"A category is essentially small if and only if\nthe underlying type of its skeleton (i.e. the \"set\" of isomorphism classes) is small,\nand it is locally small.\n"},{"type":"‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (a : Œ±), a ‚â§ ‚ä§","name":"BooleanAlgebra.le_top","isProp":true,"docString":"`‚ä§` is the greatest element "},{"type":"‚àÄ {n : Type v} {Œ± : Type w} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  (B : Matrix n n Œ±), Matrix.adjugate (Matrix.mul A B) = Matrix.mul (Matrix.adjugate B) (Matrix.adjugate A)","name":"Matrix.adjugate_mul_distrib","isProp":true,"docString":"Proof follows from \"The trace Cayley-Hamilton theorem\" by Darij Grinberg, Section 5.3\n"},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] [inst_5 : T2Space E] {s : Set E} (hs : Set.Finite s),\n  IsClosed (‚Üë(ClosureOperator.toOrderHom (convexHull ‚Ñù)) s)","name":"Set.Finite.isClosed_convexHull","isProp":true,"docString":"Convex hull of a finite set is closed. "},{"type":"‚àÄ {k : Type u_2} {M : Type u_1} [inst : OrderedRing k] [inst_1 : OrderedAddCommGroup M] [inst_2 : Module k M]\n  [inst_3 : OrderedSMul k M]\n  [inst_4 : ContravariantClass M M (fun (x : M) (x_1 : M) ‚Ü¶ x + x_1) fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {a : k} {b : k}\n  {c : M} {d : M} (hba : b ‚â§ a) (hdc : d ‚â§ c), a ‚Ä¢ d + b ‚Ä¢ c ‚â§ a ‚Ä¢ c + b ‚Ä¢ d","name":"smul_add_smul_le_smul_add_smul'","isProp":true,"docString":"Binary **rearrangement inequality**. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {c : ‚Ñù} {f : (a : Œ±) ‚Üí E}\n  {g : (a : Œ±) ‚Üí F} {l : Filter Œ±},\n  (Asymptotics.IsBigOWith c l f g : Prop) ‚Üî (Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) l : Prop)","name":"Asymptotics.isBigOWith_iff","isProp":true,"docString":"Definition of `IsBigOWith`. We record it in a lemma as `IsBigOWith` is irreducible. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [inst : Semiring k] [inst_1 : AddMonoid G] [inst_2 : Semiring R]\n  {f : AddMonoidAlgebra k G ‚Üí+* R} {g : AddMonoidAlgebra k G ‚Üí+* R}\n  (h‚ÇÄ : ‚àÄ (b : k), ‚Üëf (AddMonoidAlgebra.single 0 b) = ‚Üëg (AddMonoidAlgebra.single 0 b))\n  (h_of : ‚àÄ (a : G), ‚Üëf (AddMonoidAlgebra.single a 1) = ‚Üëg (AddMonoidAlgebra.single a 1)), f = g","name":"AddMonoidAlgebra.ringHom_ext","isProp":true,"docString":"If two ring homomorphisms from `AddMonoidAlgebra k G` are equal on all `single a 1`\nand `single 0 b`, then they are equal. "},{"type":"‚àÄ {Œ± : Type u} (v : Vector Œ± 0), v = Vector.nil","name":"Vector.eq_nil","isProp":true,"docString":"A vector of length `0` is a `nil` vector. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {Œº : (a : M) ‚Üí (a : N) ‚Üí N} {Œ± : Type u_3} [inst : Preorder Œ±] [inst_1 : Preorder N]\n  {f : (a : N) ‚Üí Œ±} [inst_2 : CovariantClass M N Œº fun (x : N) (x_1 : N) ‚Ü¶ x ‚â§ x_1] (hf : Monotone f) (m : M),\n  Monotone fun (n : N) ‚Ü¶ f (Œº m n)","name":"Monotone.covariant_of_const","isProp":true,"docString":"A monotone function remains monotone when composed with the partial application\nof a covariant operator. E.g., `‚àÄ (m : ‚Ñï), Monotone f ‚Üí Monotone (Œª n, f (m + n))`. "},{"type":"‚àÄ {Œ± : Type u_1} (U : Set Œ±), (IsOpen U : Prop) ‚Üî ((U = ‚àÖ : Prop) ‚à® (U = Set.univ : Prop) : Prop)","name":"TopologicalSpace.isOpen_top_iff","isProp":true,"docString":"The only open sets in the indiscrete topology are the empty set and the whole space. "},{"type":"‚àÄ {R : Type v} {n : Type w} [inst : Fintype n] [inst_1 : PartialOrder R] [inst_2 : NonUnitalRing R]\n  [inst_3 : StarOrderedRing R] [inst_4 : NoZeroDivisors R] {v : (a : n) ‚Üí R},\n  (Matrix.dotProduct (star v) v = 0 : Prop) ‚Üî (v = 0 : Prop)","name":"Matrix.dotProduct_star_self_eq_zero","isProp":true,"docString":"Note that this applies to `‚ÑÇ` via `Complex.strictOrderedCommRing`. "},{"type":"‚àÄ {Œπ : Type u_3} {B : Type u_2} {F : Type u_1} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (Z : FiberBundleCore Œπ B F) (b : B), Continuous (Bundle.totalSpaceMk b)","name":"FiberBundleCore.continuous_totalSpaceMk","isProp":true,"docString":"The inclusion of a fiber into the total space is a continuous map. "},{"type":"‚àÄ {C : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {D : Type u_1}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.Preadditive D] (G : C ‚•§ D)\n  [inst_4 : CategoryTheory.Functor.Additive G] (X : CategoryTheory.SimplicialObject C) (q : ‚Ñï) (n : ‚Ñï),\n  HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HœÉ q) n =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) (HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.HœÉ q) n)","name":"AlgebraicTopology.DoldKan.map_HœÉ","isProp":true,"docString":"The null homotopic maps `HœÉ` are compatible with the application of additive functors. "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±],\n  Filter.HasBasis (uniformity Œ±) (fun (V : Set (Œ± √ó Œ±)) ‚Ü¶ (V ‚àà uniformity Œ± : Prop) ‚àß (IsOpen V : Prop)) id","name":"uniformity_hasBasis_open","isProp":true,"docString":"Open elements of `ùì§ Œ±` form a basis of `ùì§ Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} (d : (a : ‚Ñï) ‚Üí ‚Ñù)\n  (hf : ‚àÄ (n : ‚Ñï), dist (f n) (f (Nat.succ n)) ‚â§ d n) (hd : Summable d), CauchySeq f","name":"cauchySeq_of_dist_le_of_summable","isProp":true,"docString":"If the distance between consecutive points of a sequence is estimated by a summable series,\nthen the original sequence is a Cauchy sequence. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S‚ÇÅ : Submodule K V)\n  (S‚ÇÇ : Submodule K V) [h‚ÇÅ : FiniteDimensional K { x : V // x ‚àà S‚ÇÅ }] [h‚ÇÇ : FiniteDimensional K { x : V // x ‚àà S‚ÇÇ }],\n  FiniteDimensional K { x : V // x ‚àà S‚ÇÅ ‚äî S‚ÇÇ }","name":"Submodule.finiteDimensional_sup","isProp":true,"docString":"The sup of two finite-dimensional submodules is\nfinite-dimensional. "},{"type":"‚àÄ {V : Type u_1} [inst : CategoryTheory.Category V] {A‚ÇÅ : V} {B‚ÇÅ : V} {C‚ÇÅ : V} {A‚ÇÇ : V} {B‚ÇÇ : V} {C‚ÇÇ : V} {A‚ÇÉ : V}\n  {B‚ÇÉ : V} {C‚ÇÉ : V} {f‚ÇÅ : A‚ÇÅ ‚ü∂ B‚ÇÅ} {g‚ÇÅ : B‚ÇÅ ‚ü∂ C‚ÇÅ} {f‚ÇÇ : A‚ÇÇ ‚ü∂ B‚ÇÇ} {g‚ÇÇ : B‚ÇÇ ‚ü∂ C‚ÇÇ} {f‚ÇÉ : A‚ÇÉ ‚ü∂ B‚ÇÉ} {g‚ÇÉ : B‚ÇÉ ‚ü∂ C‚ÇÉ}\n  {Œ±‚ÇÅ : CategoryTheory.Arrow.mk f‚ÇÅ ‚ü∂ CategoryTheory.Arrow.mk f‚ÇÇ}\n  {Œ≤‚ÇÅ : CategoryTheory.Arrow.mk g‚ÇÅ ‚ü∂ CategoryTheory.Arrow.mk g‚ÇÇ}\n  {Œ±‚ÇÇ : CategoryTheory.Arrow.mk f‚ÇÇ ‚ü∂ CategoryTheory.Arrow.mk f‚ÇÉ}\n  {Œ≤‚ÇÇ : CategoryTheory.Arrow.mk g‚ÇÇ ‚ü∂ CategoryTheory.Arrow.mk g‚ÇÉ}\n  (p‚ÇÅ : CategoryTheory.CommaMorphism.right Œ±‚ÇÅ = CategoryTheory.CommaMorphism.left Œ≤‚ÇÅ)\n  (p‚ÇÇ : CategoryTheory.CommaMorphism.right Œ±‚ÇÇ = CategoryTheory.CommaMorphism.left Œ≤‚ÇÇ),\n  CategoryTheory.CommaMorphism.right (Œ±‚ÇÅ ‚â´ Œ±‚ÇÇ) = CategoryTheory.CommaMorphism.left (Œ≤‚ÇÅ ‚â´ Œ≤‚ÇÇ)","name":"homology.comp_right_eq_comp_left","isProp":true,"docString":"Auxiliary lemma for homology computations. "},{"type":"‚àÄ {Œπ : Type u_1} {N : Type u_2} [inst : OrderedAddCommMonoid N] {f : (a : Œπ) ‚Üí N} {g : (a : Œπ) ‚Üí N} {s : Finset Œπ}\n  (h : ‚àÄ (i : Œπ) (a : i ‚àà s), f i ‚â§ g i), (Finset.sum s fun (i : Œπ) ‚Ü¶ f i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ g i","name":"Finset.sum_le_sum","isProp":true,"docString":"In an ordered additive commutative monoid, if each summand `f i` of one finite sum is less than\nor equal to the corresponding summand `g i` of another finite sum, then\n`‚àë i in s, f i ‚â§ ‚àë i in s, g i`. "},{"type":"‚àÄ {Œ± : Type ua} [hŒ± : UniformSpace Œ±] (h : uniformity Œ± = Filter.principal idRel), DiscreteTopology Œ±","name":"discreteTopology_of_discrete_uniformity","isProp":true,"docString":"A uniform space with the discrete uniformity has the discrete topology. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C],\n  CategoryTheory.Limits.HasInitial C","name":"CategoryTheory.Limits.HasZeroObject.hasInitial","isProp":true,"docString":"A zero object is in particular initial. "},{"type":"‚àÄ {n : SimplexCategory} {m : SimplexCategory} {f : n ‚ü∂ m},\n  (CategoryTheory.Mono f : Prop) ‚Üî (Function.Injective ‚Üë(SimplexCategory.Hom.toOrderHom f) : Prop)","name":"SimplexCategory.mono_iff_injective","isProp":true,"docString":"A morphism in `SimplexCategory` is a monomorphism precisely when it is an injective function\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedSemifield Œ±] (a : Œ±) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"LinearOrderedSemifield.mul_inv_cancel","isProp":true,"docString":"Every nonzero element of a group with zero is invertible. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : (a : Œ±) ‚Üí Œ≤) (P : Prop) [inst : Decidable (P : Prop)] (x : (a : P) ‚Üí Œ±)\n  (y : (a : ¬¨(P : Prop)) ‚Üí Œ±), f (dite (P : Prop) x y) = if h : (P : Prop) then f (x h) else f (y h)","name":"apply_dite","isProp":true,"docString":"A function applied to a `dite` is a `dite` of that function applied to each of the branches. "},{"type":"CategoryTheory.Limits.HasColimitsOfSize TypeMax","name":"CategoryTheory.Limits.Types.hasColimitsOfSize","isProp":true,"docString":"The category of types has all colimits.\n\nSee <https://stacks.math.columbia.edu/tag/002U>.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {p : Filter Œπ} (a : TendstoUniformlyOnFilter F f p (Filter.principal s)), TendstoUniformlyOn F f p s","name":"TendstoUniformlyOnFilter.tendstoUniformlyOn","isProp":true,"docString":"**Alias** of the reverse direction of `tendstoUniformlyOn_iff_tendstoUniformlyOnFilter`."},{"type":"‚àÄ {J : Type v} [inst : CategoryTheory.SmallCategory J] {C : Type u} [inst_1 : CategoryTheory.Category C] {B : C}\n  [inst_2 : CategoryTheory.IsConnected J] [inst_3 : CategoryTheory.Limits.HasLimitsOfShape J C],\n  CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.Over B)","name":"CategoryTheory.Over.has_connected_limits","isProp":true,"docString":"The over category has any connected limit which the original category has. "},{"type":"‚àÄ {R : Type u_1} {A : Type u} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A],\n  (Algebra.FiniteType R A : Prop) ‚Üî (‚àÉ (n : ‚Ñï), ‚àÉ (f : MvPolynomial (Fin n) R ‚Üí‚Çê[R] A), Function.Surjective ‚Üëf : Prop)","name":"Algebra.FiniteType.iff_quotient_mvPolynomial''","isProp":true,"docString":"An algebra is finitely generated if and only if it is a quotient of a polynomial ring in `n`\nvariables. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : CategoryTheory.Presieve X}\n  {x : CategoryTheory.Presieve.FamilyOfElements P R} (t : CategoryTheory.Presieve.FamilyOfElements.Compatible x),\n  CategoryTheory.Presieve.FamilyOfElements.restrict\n      ((CategoryTheory.Sieve.le_generate\n            R=:R ‚â§\n            CategoryTheory.Sieve.arrows\n              (CategoryTheory.Sieve.generate R))=:R ‚â§ CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R))\n      (CategoryTheory.Presieve.FamilyOfElements.sieveExtend x) =\n    x","name":"CategoryTheory.Presieve.restrict_extend","isProp":true,"docString":"The restriction of an extension is the original. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : LeftCancelMonoid Œ±], FaithfulSMul Œ±·µê·µí·µñ Œ±","name":"LeftCancelMonoid.toFaithfulSMul_opposite","isProp":true,"docString":"`Monoid.toOppositeMulAction` is faithful on cancellative monoids. "},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : (a : Œ±) ‚Üí Sort v} {f : (x : Œ±) ‚Üí Œ≤ x} {g : (x : Œ±) ‚Üí Œ≤ x} (h : f = g) (a : Œ±), f a = g a","name":"congr_fun","isProp":true,"docString":"**Alias** of `congrFun`."},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} {f : M ‚Üí* P}\n  (h : c ‚â§ Con.ker f) (hf : Function.Surjective ‚Üëf), Function.Surjective ‚Üë(Con.lift c f h)","name":"Con.lift_surjective_of_surjective","isProp":true,"docString":"Surjective monoid homomorphisms constant on a congruence relation `c`'s equivalence classes\ninduce a surjective homomorphism on `c`'s quotient. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±}, Metric.infDist x (closure s) = Metric.infDist x s","name":"Metric.infDist_closure","isProp":true,"docString":"The minimal distance to a set and its closure coincide "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {x : M}, 1 ‚àà powers x","name":"powers.one_mem","isProp":true,"docString":"1 is in the set of natural number powers of an element of a monoid. "},{"type":"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] (G : StructureGroupoid H) [inst_1 : ClosedUnderRestriction G],\n  StructureGroupoid.LocalInvariantProp G G (StructureGroupoid.IsLocalStructomorphWithinAt G)","name":"StructureGroupoid.isLocalStructomorphWithinAt_localInvariantProp","isProp":true,"docString":"For a groupoid `G` which is `ClosedUnderRestriction`, being a local structomorphism is a local\ninvariant property. "},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (w : a ‚à£ b) (h : b < a), b = 0","name":"Nat.eq_zero_of_dvd_of_lt","isProp":true,"docString":"If a small natural number is divisible by a larger natural number,\nthe small number is zero. "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±],\n  Filter.HasBasis (uniformity Œ±) (fun (V : Set (Œ± √ó Œ±)) ‚Ü¶ V ‚àà uniformity Œ±) closure","name":"uniformity_hasBasis_closure","isProp":true,"docString":"Closed entourages form a basis of the uniformity filter. "},{"type":"‚àÄ {Œ± : Type u_1} (self : MeasurableSpace.DynkinSystem Œ±) {f : (a : ‚Ñï) ‚Üí Set Œ±} (a : Pairwise (Disjoint on f))\n  (a : ‚àÄ (i : ‚Ñï), MeasurableSpace.DynkinSystem.Has self (f i)),\n  MeasurableSpace.DynkinSystem.Has self (Set.union·µ¢ fun (i : ‚Ñï) ‚Ü¶ f i)","name":"MeasurableSpace.DynkinSystem.has_union·µ¢_nat","isProp":true,"docString":"A Dynkin system is closed under countable union of pairwise disjoint sets. Use a more general\n`MeasurableSpace.DynkinSystem.has_union·µ¢` instead."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {e' : LocalEquiv Œ± Œ≤} (h : e ‚âà e'),\n  LocalEquiv.target e = LocalEquiv.target e'","name":"LocalEquiv.EqOnSource.target_eq","isProp":true,"docString":"Two equivalent local equivs have the same target "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï}, Function.Injective List.ofFn","name":"List.ofFn_injective","isProp":true,"docString":"Note we can only state this when the two functions are indexed by defeq `n`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_1} {Œπ : Type u_3} {u : (a : Œπ) ‚Üí UniformSpace Œ≥},\n  UniformFun.uniformSpace Œ± Œ≥ = inf·µ¢ fun (i : Œπ) ‚Ü¶ UniformFun.uniformSpace Œ± Œ≥","name":"UniformFun.inf·µ¢_eq","isProp":true,"docString":"If `u` is a family of uniform structures on `Œ≥`, then\n`ùí∞(Œ±, Œ≥, (‚®Ö i, u i)) = ‚®Ö i, ùí∞(Œ±, Œ≥, u i)`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : UniformSpace Œ≤] {ùîñ : Set (Set Œ±)} {ùîó : Set (Set Œ≥)}\n  {f : (a : Œ≥) ‚Üí Œ±} (hf : ùîó ‚äÜ Set.image f ‚Åª¬π' ùîñ),\n  UniformContinuous fun (g : UniformOnFun Œ± Œ≤ ùîñ) ‚Ü¶ ‚Üë(UniformOnFun.ofFun ùîó) (g ‚àò f)","name":"UniformOnFun.precomp_uniformContinuous","isProp":true,"docString":"Let `f : Œ≥ ‚Üí Œ±`, `ùîñ : Set (Set Œ±)`, `ùîó : Set (Set Œ≥)`, and assume that `‚àÄ T ‚àà ùîó, f '' T ‚àà ùîñ`.\nThen, the function `(Œª g, g ‚àò f) : (Œ± ‚Üí·µ§[ùîñ] Œ≤) ‚Üí (Œ≥ ‚Üí·µ§[ùîó] Œ≤)` is uniformly continuous.\n\nNote that one can easily see that assuming `‚àÄ T ‚àà ùîó, ‚àÉ S ‚àà ùîñ, f '' T ‚äÜ S` would work too, but\nwe will get this for free when we prove that `ùí±(Œ±, Œ≤, ùîñ, uŒ≤) = ùí±(Œ±, Œ≤, ùîñ', uŒ≤)` where `ùîñ'` is the\n***noncovering*** bornology generated by `ùîñ`. "},{"type":"‚àÄ {Œ± : Type u_1} {n : Type u_2} [inst : Semiring Œ±] [inst_1 : Fintype n] [inst_2 : AddGroup n] (v : (a : n) ‚Üí Œ±)\n  (w : (a : n) ‚Üí Œ±),\n  Matrix.mul (Matrix.circulant v) (Matrix.circulant w) = Matrix.circulant (Matrix.mulVec (Matrix.circulant v) w)","name":"Matrix.circulant_mul","isProp":true,"docString":"The product of two circulant matrices `circulant v` and `circulant w` is\nthe circulant matrix generated by `mulVec (circulant v) w`. "},{"type":"Cardinal.mk ‚ÑÇ = Cardinal.continuum","name":"mk_complex","isProp":true,"docString":"The cardinality of the complex numbers, as a type. "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {Œ¥ : Type u_1} [inst_4 : LinearOrder Œ¥] [inst_5 : TopologicalSpace Œ¥]\n  [inst_6 : OrderClosedTopology Œ¥] {f : (a : Œ±) ‚Üí Œ¥} {s : Set Œ±} [inst_7 : Set.OrdConnected s] (hs : Set.Nonempty s)\n  (hf : ContinuousOn f s) (hbot : Filter.Tendsto (fun (x : ‚Üës) ‚Ü¶ f ‚Üëx) Filter.atBot Filter.atBot)\n  (htop : Filter.Tendsto (fun (x : ‚Üës) ‚Ü¶ f ‚Üëx) Filter.atTop Filter.atTop), Set.SurjOn f s Set.univ","name":"ContinuousOn.surjOn_of_tendsto","isProp":true,"docString":"If a function `f : Œ± ‚Üí Œ≤` is continuous on a nonempty interval `s`, its restriction to `s`\ntends to `at_bot : Filter Œ≤` along `at_bot : Filter ‚Ü•s` and tends to `Filter.atTop : Filter Œ≤` along\n`Filter.atTop : Filter ‚Ü•s`, then the restriction of `f` to `s` is surjective. We formulate the\nconclusion as `Function.surjOn f s Set.univ`. "},{"type":"‚àÄ (R : Type u_1) [inst : Ring R], algebraMap ‚Ñ§ R = Int.castRingHom R","name":"algebraMap_int_eq","isProp":true,"docString":"A special case of `eq_intCast'` that happens to be true definitionally "},{"type":"‚àÄ {K : Type u} {V : Type v} {V‚ÇÅ : Type v} {V‚ÇÇ : Type v} {V‚ÇÉ : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V]\n  [inst_2 : Module K V] [inst_3 : AddCommGroup V‚ÇÅ] [inst_4 : Module K V‚ÇÅ] [inst_5 : AddCommGroup V‚ÇÇ]\n  [inst_6 : Module K V‚ÇÇ] [inst_7 : AddCommGroup V‚ÇÉ] [inst_8 : Module K V‚ÇÉ] (db : V‚ÇÇ ‚Üí‚Çó[K] V) (eb : V‚ÇÉ ‚Üí‚Çó[K] V)\n  (cd : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÇ) (ce : V‚ÇÅ ‚Üí‚Çó[K] V‚ÇÉ) (hde : ‚ä§ ‚â§ LinearMap.range db ‚äî LinearMap.range eb) (hgd : LinearMap.ker cd = ‚ä•)\n  (eq : LinearMap.comp db cd = LinearMap.comp eb ce)\n  (eq‚ÇÇ : ‚àÄ (d : V‚ÇÇ) (e : V‚ÇÉ) (a : ‚Üëdb d = ‚Üëeb e), ‚àÉ (c : V‚ÇÅ), (‚Üëcd c = d : Prop) ‚àß (‚Üëce c = e : Prop)),\n  Module.rank K V + Module.rank K V‚ÇÅ = Module.rank K V‚ÇÇ + Module.rank K V‚ÇÉ","name":"rank_add_rank_split","isProp":true,"docString":"This is mostly an auxiliary lemma for `Submodule.rank_sup_add_rank_inf_eq`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ},\n  (TendstoUniformly F f p : Prop) ‚Üî\n    (Filter.Tendsto (fun (q : Œπ √ó Œ±) ‚Ü¶ (f (Prod.snd q), F (Prod.fst q) (Prod.snd q))) (Filter.prod p ‚ä§) (uniformity Œ≤) :\n      Prop)","name":"tendstoUniformly_iff_tendsto","isProp":true,"docString":"A sequence of functions `F‚Çô` converges uniformly to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √ó·∂† ‚ä§` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit.\n"},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s) {a : ùïú} {b : ùïú} (ha : 0 < a) (hb : 0 ‚â§ b) (hab : a + b = 1),\n  a ‚Ä¢ interior s + b ‚Ä¢ closure s ‚äÜ interior s","name":"Convex.combo_interior_closure_subset_interior","isProp":true,"docString":"If `s` is a convex set, then `a ‚Ä¢ interior s + b ‚Ä¢ closure s ‚äÜ interior s` for all `0 < a`,\n`0 ‚â§ b`, `a + b = 1`. See also `Convex.combo_interior_self_subset_interior` for a weaker version. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤]\n  [inst_2 : MulZeroOneClass Œ±] [inst_3 : MulZeroOneClass Œ≤] [self : OrderMonoidWithZeroHomClass F Œ± Œ≤] (f : F),\n  Monotone ‚Üëf","name":"OrderMonoidWithZeroHomClass.monotone","isProp":true,"docString":"An `OrderMonoidWithZeroHom` is a monotone function. "},{"type":"‚àÄ {q : ‚Ñï+} (i : ‚Ñï), ‚Üë(LucasLehmer.s i) = LucasLehmer.X.œâ ^ 2 ^ i + LucasLehmer.X.œâb ^ 2 ^ i","name":"LucasLehmer.X.closed_form","isProp":true,"docString":"A closed form for the recurrence relation. "},{"type":"‚àÄ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A} (self : AddSubgroup.IsCommutative H),\n  IsCommutative { x : A // x ‚àà H } fun (x : { x : A // x ‚àà H }) (x_1 : { x : A // x ‚àà H }) ‚Ü¶ x + x_1","name":"AddSubgroup.IsCommutative.is_comm","isProp":true,"docString":"`+` is commutative on `H` "},{"type":"‚àÄ {Œ± : Type u} (p : (a : Œ±) ‚Üí Bool) (as : List Œ±),\n  List.join\n      (List.zipWith (fun (x : List Œ±) (x_1 : List Œ±) ‚Ü¶ x ++ x_1) (List.splitOnP p as)\n        (List.map (fun (x : Œ±) ‚Ü¶ [x]) (List.filter p as) ++ [[]])) =\n    as","name":"List.splitOnP_spec","isProp":true,"docString":"The original list `L` can be recovered by joining the lists produced by `splitOnP p L`,\ninterspersed with the elements `L.filter p`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} {Œµ : ‚Ñù} (hŒµ : 0 ‚â§ Œµ) (hŒ¥ : 0 ‚â§ Œ¥) (s : Set Œ±),\n  Metric.cthickening Œµ (Metric.cthickening Œ¥ s) ‚äÜ Metric.cthickening (Œµ + Œ¥) s","name":"Metric.cthickening_cthickening_subset","isProp":true,"docString":"For the equality, see `cthickening_cthickening`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (self : GroupNorm G) (x : G)\n  (a : GroupSeminorm.toFun (GroupNorm.toGroupSeminorm self) x = 0), x = 1","name":"GroupNorm.eq_one_of_map_eq_zero'","isProp":true,"docString":"If the image under the norm is zero, then the argument is one. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] [inst_1 : DecidableEq Œ±] (s : Finset Œ±) (a : Œ±) (b : (a : Œ±) ‚Üí Œ≤),\n  (Finset.sum s fun (x : Œ±) ‚Ü¶ if (x = a : Prop) then b x else 0) = if (a ‚àà s : Prop) then b a else 0","name":"Finset.sum_ite_eq'","isProp":true,"docString":"A sum taken over a conditional whose condition is an equality\ntest on the index and whose alternative is `0` has value either the term at that index or `0`.\n\nThe difference with `Finset.sum_ite_eq` is that the arguments to `eq` are swapped."},{"type":"‚àÄ (R : Type u) [inst : Semifield R], IsField R","name":"Semifield.toIsField","isProp":true,"docString":"Transferring from `Semifield` to `IsField`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a * b ‚â§ c), b ‚â§ a‚Åª¬π * c","name":"le_inv_mul_of_mul_le","isProp":true,"docString":"**Alias** of the reverse direction of `le_inv_mul_iff_mul_le`."},{"type":"‚àÄ {Œ± : Sort u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {a : Œ±} {bot : Œ±} (ha : Acc r a) {C : (a : Œ±) ‚Üí Prop}\n  (ih : ‚àÄ (b : Œ±) (a : b ‚â† bot) (a : C b), ‚àÉ (c : Œ±), (r c b : Prop) ‚àß (C c : Prop)) (a : C a), C bot","name":"Acc.induction_bot","isProp":true,"docString":"Let `r` be a relation on `Œ±`, let `C : Œ± ‚Üí Prop` and let `bot : Œ±`.\nThis induction principle shows that `C bot` holds, given that\n* some `a` that is accessible by `r` satisfies `C a`, and\n* for each `b ‚â† bot` such that `C b` holds, there is `c` satisfying `r c b` and `C c`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_4} [inst : CommSemiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Fintype Œπ'] [inst_4 : Fintype Œπ] [inst_5 : DecidableEq Œπ] [inst_6 : DecidableEq Œπ']\n  (b : Basis Œπ R M) (v : (a : Œπ') ‚Üí M) (e : Œπ ‚âÉ Œπ'),\n  Basis.toMatrix (Basis.reindex b e) v = ‚Üë(Matrix.reindexAlgEquiv R e) (Basis.toMatrix b (v ‚àò ‚Üëe))","name":"Basis.toMatrix_reindex'","isProp":true,"docString":"See also `Basis.toMatrix_reindex` which gives the `simp` normal form of this result. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±} [inst_1 : Fintype Œπ]\n  (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i) * Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ g i) ‚â§\n    ‚Üë(Fintype.card Œπ) * Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i","name":"Monovary.sum_mul_sum_le_card_mul_sum","isProp":true,"docString":"**Chebyshev's Sum Inequality**: When `f` and `g` monovary together (eg they are both\nmonotone/antitone), the product of their sum is less than the size of the set times their scalar\nproduct. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.NonPreadditiveAbelian C] {P : C} {Q : C}\n  (f : P ‚ü∂ Q), CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f)","name":"CategoryTheory.NonPreadditiveAbelian.instEpiImageToHasZeroMorphismsHas_kernelsHas_cokernelsFactorThruImage","isProp":true,"docString":"The map `p : P ‚ü∂ image f` is an epimorphism "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {k : ‚Ñï} {l : ‚Ñï} {s : Finset Œ±} {i : Fin k} {j : Fin l} {h : Finset.card s = k}\n  {h' : Finset.card s = l}, (‚Üë(Finset.orderEmbOfFin s h) i = ‚Üë(Finset.orderEmbOfFin s h') j : Prop) ‚Üî (‚Üëi = ‚Üëj : Prop)","name":"Finset.orderEmbOfFin_eq_orderEmbOfFin_iff","isProp":true,"docString":"Two parametrizations `orderEmbOfFin` of the same set take the same value on `i` and `j` if\nand only if `i = j`. Since they can be defined on a priori not defeq types `Fin k` and `Fin l`\n(although necessarily `k = l`), the conclusion is rather written `(i : ‚Ñï) = (j : ‚Ñï)`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] ‚¶Éf : M ‚Üí*‚ÇÄ N‚¶Ñ ‚¶Ég : M ‚Üí*‚ÇÄ N‚¶Ñ\n  (h : ‚Üëf = ‚Üëg), f = g","name":"MonoidWithZeroHom.coe_inj","isProp":true,"docString":"Deprecated: use `FunLike.coe_injective` instead. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (R : D ‚•§ C)\n  [inst_2 : CategoryTheory.Reflective R] [inst : CategoryTheory.Limits.HasColimitsOfSize C],\n  CategoryTheory.Limits.HasColimitsOfSize D","name":"CategoryTheory.has_colimits_of_reflective","isProp":true,"docString":"If `C` has colimits then any reflective subcategory has colimits. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±]\n  (l : List (Matrix n n Œ±)), (List.prod l)‚Åª¬π = List.prod (List.map Inv.inv (List.reverse l))","name":"Matrix.list_prod_inv_reverse","isProp":true,"docString":"A version of `List.prod_inv_reverse` for `Matrix.inv`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {B : C} {A : C} {X : CategoryTheory.Subobject B} (f : A ‚ü∂ B)\n  [inst_1 : CategoryTheory.Mono f]\n  (i : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.Subobject.underlying) X ‚âÖ A)\n  (w : CategoryTheory.Iso.hom i ‚â´ f = CategoryTheory.Subobject.arrow X), X = CategoryTheory.Subobject.mk f","name":"CategoryTheory.Subobject.eq_mk_of_comm","isProp":true,"docString":"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C","name":"CategoryTheory.Abelian.hasFiniteBiproducts","isProp":true,"docString":"An abelian category has finite biproducts. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±}, 0 ‚â§ Metric.infDist x s","name":"Metric.infDist_nonneg","isProp":true,"docString":"The minimal distance is always nonnegative "},{"type":"‚àÄ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] {i : K ‚Üí+* L} {f : Polynomial K}\n  (h : Polynomial.Splits i f),\n  (f = 0 : Prop) ‚à®\n    (‚àÄ {g : Polynomial L} (a : Irreducible g) (a : g ‚à£ Polynomial.map i f), Polynomial.degree g = 1 : Prop)","name":"Polynomial.Splits.def","isProp":true,"docString":"This lemma is for polynomials over a field. "},{"type":"‚àÄ {Œ± : Type u_1} {ùïú : Type u_2} [inst : NormedField ùïú] {c : ‚Ñù} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ùïú} {v : (a : Œ±) ‚Üí ùïú}\n  (œÜ : (a : Œ±) ‚Üí ùïú) (hœÜ : Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚ÄñœÜ x‚Äñ ‚â§ c) l) (h : u =·∂†[l] œÜ * v),\n  Asymptotics.IsBigOWith c l u v","name":"Asymptotics.isBigOWith_of_eq_mul","isProp":true,"docString":"If `‚ÄñœÜ‚Äñ` is eventually bounded by `c`, and `u =·∂†[l] œÜ * v`, then we have `IsBigOWith c u v l`.\nThis does not require any assumptions on `c`, which is why we keep this version along with\n`IsBigOWith_iff_exists_eq_mul`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N] {f : M ‚Üí+ N}\n  (h : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëf ‚Üëy)) {x‚ÇÅ : M} {x‚ÇÇ : M} {y‚ÇÅ : { x : M // x ‚àà S }}\n  {y‚ÇÇ : { x : M // x ‚àà S }},\n  (‚Üëf x‚ÇÅ + ‚Üë(-‚Üë(IsAddUnit.liftRight (AddMonoidHom.restrict f S) h) y‚ÇÅ) =\n        ‚Üëf x‚ÇÇ + ‚Üë(-‚Üë(IsAddUnit.liftRight (AddMonoidHom.restrict f S) h) y‚ÇÇ) :\n      Prop) ‚Üî\n    (‚Üëf (x‚ÇÅ + ‚Üëy‚ÇÇ) = ‚Üëf (x‚ÇÇ + ‚Üëy‚ÇÅ) : Prop)","name":"AddSubmonoid.LocalizationMap.add_neg","isProp":true,"docString":"Given an AddMonoidHom `f : M ‚Üí+ N` and Submonoid `S ‚äÜ M` such that\n`f(S) ‚äÜ AddUnits N`, for all `x‚ÇÅ x‚ÇÇ : M` and `y‚ÇÅ, y‚ÇÇ ‚àà S`, we have\n`f x‚ÇÅ - f y‚ÇÅ = f x‚ÇÇ - f y‚ÇÇ ‚Üî f (x‚ÇÅ + y‚ÇÇ) = f (x‚ÇÇ + y‚ÇÅ)`."},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : UniformSpace Œ≤],\n  Filter.HasBasis (uniformity (UniformFun Œ± Œ≤)) (fun (V : Set (Œ≤ √ó Œ≤)) ‚Ü¶ V ‚àà uniformity Œ≤) (UniformFun.gen Œ± Œ≤)","name":"UniformFun.hasBasis_uniformity","isProp":true,"docString":"By definition, the uniformity of `Œ± ‚Üí·µ§ Œ≤` admits the family `{(f, g) | ‚àÄ x, (f x, g x) ‚àà V}`\nfor `V ‚àà ùì§ Œ≤` as a filter basis. "},{"type":"‚àÄ {n : Type u_1} {R : Type u‚ÇÇ} [inst : DecidableEq n] [inst_1 : CommRing R] (i : n) (j : n) [inst_2 : Finite n] (c : R),\n  Matrix.updateRow 1 i (OfNat.ofNat 1 i + c ‚Ä¢ OfNat.ofNat 1 j) = Matrix.transvection i j c","name":"Matrix.updateRow_eq_transvection","isProp":true,"docString":"A transvection matrix is obtained from the identity by adding `c` times the `j`-th row to\nthe `i`-th row. "},{"type":"‚àÄ {M : Type uM} [inst : AddCommGroup M] (z : ‚Ñ§) (m : M), ‚Üë‚Üëz m = z ‚Ä¢ m","name":"AddMonoid.End.int_cast_apply","isProp":true,"docString":"See also `AddMonoid.End.intCast_def`. "},{"type":"‚àÄ {S : Set Ordinal} (o : Ordinal),\n  Ordinal.enumOrd S o = inf‚Çõ (S ‚à© Set.Ici (Ordinal.blsub o fun (a : Ordinal) (x : a < o) ‚Ü¶ Ordinal.enumOrd S a))","name":"Ordinal.enumOrd_def'","isProp":true,"docString":"The equation that characterizes `enumOrd` definitionally. This isn't the nicest expression to\nwork with, so consider using `enumOrd_def` instead. "},{"type":"‚àÄ {Œ± : Type u_1} [self : OrderedCommMonoid Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c * a ‚â§ c * b","name":"OrderedCommMonoid.mul_le_mul_left","isProp":true,"docString":"Multiplication is monotone in an `OrderedCommMonoid`. "},{"type":"‚àÄ (m : ‚Ñï) (n : ‚Ñï), m - Nat.succ n = m - n - 1","name":"Nat.sub_succ'","isProp":true,"docString":"A version of `Nat.sub_succ` in the form `_ - 1` instead of `Nat.pred _`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (self : AddGroupSeminorm G) (r : G),\n  AddGroupSeminorm.toFun self (-r) = AddGroupSeminorm.toFun self r","name":"AddGroupSeminorm.neg'","isProp":true,"docString":"The seminorm is invariant under negation. "},{"type":"‚àÄ {p : ‚Ñï} (hp : 1 < p), padicNorm p ‚Üëp = (‚Üëp)‚Åª¬π","name":"padicNorm.padicNorm_p","isProp":true,"docString":"The `p`-adic norm of `p` is `p‚Åª¬π` if `p > 1`.\n\nSee also `padicNorm.padicNorm_p_of_prime` for a version assuming `p` is prime. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M‚ÇÅ : Type v}\n  [inst_3 : AddCommGroup M‚ÇÅ] [inst_4 : Module R M‚ÇÅ] (f : M ‚âÉ‚Çó[R] M‚ÇÅ) (p : Submodule R M),\n  Module.rank R { x : M‚ÇÅ // x ‚àà Submodule.map (‚Üëf) p } = Module.rank R { x : M // x ‚àà p }","name":"LinearEquiv.rank_map_eq","isProp":true,"docString":"Pushforwards of submodules along a `LinearEquiv` have the same dimension. "},{"type":"‚àÄ {I : Type u} {Œ≤ : Type u_1} [inst : DecidableEq I] [inst_1 : Zero Œ≤] (i : I) (x : Œ≤) (i' : I),\n  Pi.single i x i' = Pi.single i' x i","name":"Pi.single_comm","isProp":true,"docString":"On non-dependent functions, `Pi.single` is symmetric in the two indices."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : Monotone f),\n  Monotone (WithTop.map f)","name":"Monotone.withTop_map","isProp":true,"docString":"**Alias** of the reverse direction of `WithTop.monotone_map_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (h : WellFounded rŒ±), WellFounded (Sym2.GameAdd rŒ±)","name":"WellFounded.sym2_gameAdd","isProp":true,"docString":"The `Sym2.GameAdd` relation on well-founded inputs is well-founded. "},{"type":"‚àÄ {X : Type u_3} [inst : TopologicalSpace X] {Œ± : Type u_1} {Œ≤ : Type u_2} (f : (a : X) ‚Üí Œ±) (g : (a : Œ±) ‚Üí Œ≤)\n  (h : IsLocallyConstant (g ‚àò f)) (inj : Function.Injective g), IsLocallyConstant f","name":"IsLocallyConstant.desc","isProp":true,"docString":"If a composition of a function `f` followed by an injection `g` is locally\nconstant, then the locally constant property descends to `f`. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} [inst_3 : IsTrans Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1] (h‚ÇÅ : a ‚äÜ b) (h‚ÇÇ : b ‚äÇ c), a ‚äÇ c","name":"HasSubset.Subset.trans_ssubset","isProp":true,"docString":"**Alias** of `ssubset_of_subset_of_ssubset`."},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} {n : ‚Ñ§} (a : Equiv.Perm.SameCycle f x y),\n  Equiv.Perm.SameCycle f x (‚Üë(f ^ n) y)","name":"Equiv.Perm.SameCycle.zpow_right","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_zpow_right`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {a : Œ±} {b : Œ±} (h : a = b), a ‚à£ b","name":"Eq.dvd","isProp":true,"docString":"**Alias** of `dvd_of_eq`."},{"type":"‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x : Œ±) (y : Œ±), x \\ y = x ‚äì y·∂ú","name":"BooleanAlgebra.sdiff_eq","isProp":true,"docString":"`x \\ y` is equal to `x ‚äì y·∂ú` "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {u : Set Œ±} (fin : EMetric.hausdorffEdist s t ‚â† ‚ä§),\n  Metric.hausdorffDist s u ‚â§ Metric.hausdorffDist s t + Metric.hausdorffDist t u","name":"Metric.hausdorffDist_triangle","isProp":true,"docString":"The Hausdorff distance satisfies the triangular inequality "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] (m : Type u_1) (n : Type u_2) [inst_2 : Fintype m]\n  [inst_3 : Fintype n], FiniteDimensional.finrank R (Matrix m n R) = Fintype.card m * Fintype.card n","name":"FiniteDimensional.finrank_matrix","isProp":true,"docString":"If `m` and `n` are `Fintype`, the finrank of `m √ó n` matrices is\n`(Fintype.card m) * (Fintype.card n)`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  [inst_2 : CategoryTheory.IsEquivalence F], CategoryTheory.EssSurj F","name":"CategoryTheory.Equivalence.essSurj_of_equivalence","isProp":true,"docString":"An equivalence is essentially surjective.\n\nSee <https://stacks.math.columbia.edu/tag/02C3>.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (t :\n    CategoryTheory.Limits.IsColimit\n      (CategoryTheory.Limits.PushoutCocone.mk (ùüô Y) (ùüô Y) ((rfl=:f ‚â´ ùüô Y = f ‚â´ ùüô Y)=:f ‚â´ ùüô Y = f ‚â´ ùüô Y))),\n  CategoryTheory.Epi f","name":"CategoryTheory.Limits.PushoutCocone.epi_of_isColimitMkIdId","isProp":true,"docString":"`f` is an epi if the pushout cocone `(ùüô X, ùüô X)` is a colimit for the pair `(f, f)`.\nThe converse is given in `PushoutCocone.isColimitMkIdId`.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : C ‚•§ D} (self : CategoryTheory.NatTrans F G) ‚¶ÉX : C‚¶Ñ ‚¶ÉY : C‚¶Ñ (f : X ‚ü∂ Y),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f ‚â´ self.app Y =\n    self.app X ‚â´ Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) f","name":"CategoryTheory.NatTrans.naturality","isProp":true,"docString":"The naturality square for a given morphism. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommSemiring Œ±] (E : LinearRecurrence Œ±) {u : (a : ‚Ñï) ‚Üí Œ±}\n  {init : (a : Fin (LinearRecurrence.order E)) ‚Üí Œ±} (h : LinearRecurrence.IsSolution E u)\n  (heq : ‚àÄ (n : Fin (LinearRecurrence.order E)), u ‚Üën = init n), u = LinearRecurrence.mkSol E init","name":"LinearRecurrence.eq_mk_of_is_sol_of_eq_init'","isProp":true,"docString":"If `u` is a solution to `E` and `init` designates its first `E.order` values,\nthen `u = E.mkSol init`. This proves that `E.mkSol init` is the only solution\nof `E` whose first `E.order` values are given by `init`. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) (i : ‚Ñï),\n  List.drop (List.sum (List.take i (List.map List.length L))) (List.join L) = List.join (List.drop i L)","name":"List.drop_sum_join","isProp":true,"docString":"In a join, dropping all the elements up to an index which is the sum of the lengths of the\nfirst `i` sublists, is the same as taking the join after dropping the first `i` sublists. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s)","name":"Subgroup.normalClosure_normal","isProp":true,"docString":"The normal closure of `s` is a normal subgroup. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ}\n  (h : CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.arrows S)) {f : CategoryTheory.Sieve.functor S ‚ü∂ P}\n  (t : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda) X ‚ü∂ P)\n  (ht : CategoryTheory.Sieve.functorInclusion S ‚â´ t = f), t = CategoryTheory.Presieve.IsSheafFor.extend h f","name":"CategoryTheory.Presieve.IsSheafFor.unique_extend","isProp":true,"docString":"The extension of `f` to `yoneda.obj X` is unique. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±}\n  {b : Œ±} {c : Œ±} [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1],\n  a + b - c ‚â§ a - c + b","name":"add_tsub_le_tsub_add","isProp":true,"docString":"See `tsub_add_eq_add_tsub` for the equality. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Primcodable Œ±] {f : (a : Œ±) ‚Üí ‚Ñï} (h‚ÇÅ : Primrec.PrimrecBounded f)\n  (h‚ÇÇ : PrimrecRel fun (a : Œ±) (b : ‚Ñï) ‚Ü¶ f a = b), Primrec f","name":"Primrec.of_graph","isProp":true,"docString":"To show a function `f : Œ± ‚Üí ‚Ñï` is primitive recursive, it is enough to show that the function\nis bounded by a primitive recursive function and that its graph is primitive recursive "},{"type":"‚àÄ (m : ‚Ñï) (n : ‚Ñï), Nat.fib (m + n + 1) = Nat.fib m * Nat.fib n + Nat.fib (m + 1) * Nat.fib (n + 1)","name":"Nat.fib_add","isProp":true,"docString":"See https://proofwiki.org/wiki/Fibonacci_Number_in_terms_of_Smaller_Fibonacci_Numbers "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hq : ExpChar R q], (Nat.Prime q : Prop) ‚à® (q = 1 : Prop)","name":"expChar_is_prime_or_one","isProp":true,"docString":"The exponential characteristic is a prime number or one. "},{"type":"‚àÄ (R : Type u_1) {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherianRing R] {A : Set M} (hA : Set.Finite A), IsNoetherian R { x : M // x ‚àà Submodule.span R A }","name":"isNoetherian_span_of_finite","isProp":true,"docString":"In a module over a Noetherian ring, the submodule generated by finitely many vectors is\nNoetherian. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 1)},\n  CategoryTheory.CosimplicialObject.Œ¥ X (‚ÜëFin.castSucc i) ‚â´ CategoryTheory.CosimplicialObject.œÉ X i =\n    ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor X) (SimplexCategory.mk n))","name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_self","isProp":true,"docString":"The first part of the third cosimplicial identity "},{"type":"‚àÄ {M : Type u_6} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_4} [inst_1 : CommMonoid N] {P : Type u_3}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P} {T : Submonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_5} [inst_3 : CommMonoid Q]\n  {k : Submonoid.LocalizationMap T Q} {A : Type u_1} [inst_4 : CommMonoid A] {U : Submonoid A} {R : Type u_2}\n  [inst_5 : CommMonoid R] (j : Submonoid.LocalizationMap U R) {l : P ‚Üí* A} (hl : ‚àÄ (w : { x : P // x ‚àà T }), ‚Üël ‚Üëw ‚àà U),\n  MonoidHom.comp (Submonoid.LocalizationMap.map k hl j) (Submonoid.LocalizationMap.map f hy k) =\n    Submonoid.LocalizationMap.map f\n      (fun (x : { x : M // x ‚àà S }) ‚Ü¶\n        (_ : ‚Üë(MonoidHom.comp l g) ‚Üëx ‚àà U)=:‚àÄ (x : { x : M // x ‚àà S }), ‚Üë(MonoidHom.comp l g) ‚Üëx ‚àà U)\n      j","name":"Submonoid.LocalizationMap.map_comp_map","isProp":true,"docString":"If `CommMonoid` homs `g : M ‚Üí* P, l : P ‚Üí* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ‚àò g`. "},{"type":"‚àÄ {M : Type u} {R : Type v} [inst : Monoid M] [inst_1 : Semiring R] [self : MulSemiringAction M R] (g : M) (x : R)\n  (y : R), g ‚Ä¢ (x * y) = g ‚Ä¢ x * g ‚Ä¢ y","name":"MulSemiringAction.smul_mul","isProp":true,"docString":"Scalara multiplication distributes across multiplication "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {R : D ‚•§ C} (adj : L ‚ä£ R), CategoryTheory.Functor.Initial L","name":"CategoryTheory.Functor.initial_of_adjunction","isProp":true,"docString":"If a functor `L : C ‚•§ D` is a left adjoint, it is initial. "},{"type":"‚àÄ {M : Type u_1} [inst : Semigroup M] {a : Stream' M} {m : M} (hm : m ‚àà Hindman.FP a),\n  ‚àÉ (n : ‚Ñï), ‚àÄ (m' : M) (a_1 : m' ‚àà Hindman.FP (Stream'.drop n a)), m * m' ‚àà Hindman.FP a","name":"Hindman.FP.mul","isProp":true,"docString":"If `m` and `m'` are finite products in `M`, then so is `m * m'`, provided that `m'` is obtained\nfrom a subsequence of `M` starting sufficiently late. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, (IsSeqClosed s : Prop) ‚Üî (seqClosure s = s : Prop)","name":"isSeqClosed_iff","isProp":true,"docString":"A set is sequentially closed iff it is equal to its sequential closure. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] {s : TopologicalSpace.Closeds Œ±},\n  (IsAtom s : Prop) ‚Üî (‚àÉ (x : Œ±), s = TopologicalSpace.Closeds.singleton x : Prop)","name":"TopologicalSpace.Closeds.isAtom_iff","isProp":true,"docString":"in a `T1Space`, atoms of `TopologicalSpace.Closeds Œ±` are precisely the\n`TopologicalSpace.Closeds.singleton`s.\n\nTODO: use `minimal_nonempty_closed_eq_singleton` to show that an atom in `TopologicalSpace.Closeds`\nin a T‚ÇÄ space is a singleton. "},{"type":"‚àÄ {Œ± : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsSymm Œ± r] {a : Œ±} {b : Œ±}, (r a b : Prop) ‚Üî (r b a : Prop)","name":"comm_of","isProp":true,"docString":"A version of `comm` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `Init.Algebra.Classes`, but is missing there.  "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] {f : Filter Œ≤} {u : (a : Œ≤) ‚Üí Œ±} {a : Œ±} (hinf : Filter.liminf u f = a)\n  (hsup : Filter.limsup u f = a)\n  (h : autoParam (Filter.IsBoundedUnder (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) f u : Prop) _auto‚úù)\n  (h' : autoParam (Filter.IsBoundedUnder (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â• x_1) f u : Prop) _auto‚úù¬π),\n  Filter.Tendsto u f (nhds a)","name":"tendsto_of_liminf_eq_limsup","isProp":true,"docString":"If the liminf and the limsup of a function coincide, then the limit of the function\nexists and has the same value. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : (a : Fin n) ‚Üí Œ±} (h : f ‚â† f ‚àò ‚Üë(Tuple.sort f)),\n  ‚àÉ (i : Fin n), ‚àÉ (j : Fin n), (i < j : Prop) ‚àß (f j < f i : Prop)","name":"Tuple.antitone_pair_of_not_sorted","isProp":true,"docString":"If the tuple `f` is not the same as `f ‚àò sort f`, then `f` has a pair of strictly decreasing\nentries. "},{"type":"‚àÄ {Œπ : Type u_1} {N : Type u_2} [inst : OrderedCommMonoid N] {f : (a : Œπ) ‚Üí N} {g : (a : Œπ) ‚Üí N} {s : Finset Œπ}\n  (h : ‚àÄ (i : Œπ) (a : i ‚àà s), f i ‚â§ g i), (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) ‚â§ Finset.prod s fun (i : Œπ) ‚Ü¶ g i","name":"Finset.prod_le_prod'","isProp":true,"docString":"In an ordered commutative monoid, if each factor `f i` of one finite product is less than or\nequal to the corresponding factor `g i` of another finite product, then\n`‚àè i in s, f i ‚â§ ‚àè i in s, g i`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_3} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) (c : k),\n  ‚Üë(Finset.weightedVSub s p) (c ‚Ä¢ w) = c ‚Ä¢ ‚Üë(Finset.weightedVSub s p) w","name":"Finset.weightedVSub_const_smul","isProp":true,"docString":"A constant multiplier of the weights in `weightedVSub_of` may be moved outside the sum. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} [inst_1 : T25Space Œ±] (hC : Perfect C)\n  (hnonempty : Set.Nonempty C),\n  ‚àÉ (C‚ÇÄ : Set Œ±),\n    ‚àÉ (C‚ÇÅ : Set Œ±),\n      ((Perfect C‚ÇÄ : Prop) ‚àß ((Set.Nonempty C‚ÇÄ : Prop) ‚àß (C‚ÇÄ ‚äÜ C : Prop) : Prop) : Prop) ‚àß\n        (((Perfect C‚ÇÅ : Prop) ‚àß ((Set.Nonempty C‚ÇÅ : Prop) ‚àß (C‚ÇÅ ‚äÜ C : Prop) : Prop) : Prop) ‚àß (Disjoint C‚ÇÄ C‚ÇÅ : Prop) :\n          Prop)","name":"Perfect.splitting","isProp":true,"docString":"Given a perfect nonempty set in a T2.5 space, we can find two disjoint perfect subsets.\nThis is the main inductive step in the proof of the Cantor-Bendixson Theorem. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {rŒ≤ : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} {a : Œ±} {b : Œ≤}\n  (ha : Acc rŒ± a) (hb : Acc rŒ≤ b), Acc (Prod.GameAdd rŒ± rŒ≤) (a, b)","name":"Acc.prod_gameAdd","isProp":true,"docString":"If `a` is accessible under `rŒ±` and `b` is accessible under `rŒ≤`, then `(a, b)` is\naccessible under `Prod.GameAdd rŒ± rŒ≤`. Notice that `Prod.lexAccessible` requires the\nstronger condition `‚àÄ b, Acc rŒ≤ b`. "},{"type":"‚àÄ {Œπ : Type u'} {Œπ' : Type u_3} {R : Type u_1} {M : Type u_2} {v : (a : Œπ) ‚Üí M} [inst : Semiring R]\n  [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (h : LinearIndependent R v) (f : (a : Œπ') ‚Üí Œπ)\n  (hf : Function.Injective f), LinearIndependent R (v ‚àò f)","name":"LinearIndependent.comp","isProp":true,"docString":"A subfamily of a linearly independent family (i.e., a composition with an injective map) is a\nlinearly independent family. "},{"type":"‚àÄ {R : Type u_1} {K : Type u_2} [inst : Semiring R] [inst_1 : CommSemiring K] {b : R} {bi : K} (i : R ‚Üí+* K)\n  (f : Polynomial R) (a : R) (bu : bi * ‚Üëi b = 1), DenomsClearable a b (Polynomial.natDegree f) f i","name":"denomsClearable_natDegree","isProp":true,"docString":"If `i : R ‚Üí K` is a ring homomorphism, `f` is a polynomial with coefficients in `R`,\n`a, b` are elements of `R`, with `i b` invertible, then there is a `D ‚àà R` such that\n`b ^ f.natDegree * f (a / b)` equals `i D`. "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {M : (a : Œπ) ‚Üí Type u_2} {N : Type u_4} [dec_Œπ : DecidableEq Œπ] [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] [inst_3 : AddCommMonoid N]\n  [inst_4 : Module R N] ‚¶ÉœÜ : (Dfinsupp fun (i : Œπ) ‚Ü¶ M i) ‚Üí‚Çó[R] N‚¶Ñ ‚¶Éœà : (Dfinsupp fun (i : Œπ) ‚Ü¶ M i) ‚Üí‚Çó[R] N‚¶Ñ\n  (h : ‚àÄ (i : Œπ) (x : M i), ‚ÜëœÜ (Dfinsupp.single i x) = ‚Üëœà (Dfinsupp.single i x)), œÜ = œà","name":"Dfinsupp.lhom_ext","isProp":true,"docString":"Two `R`-linear maps from `Œ†‚ÇÄ i, M i` which agree on each `single i x` agree everywhere. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [self : InfConvergenceClass Œ±] (a : Œ±) (s : Set Œ±)\n  (a_1 : IsGLB s a), Filter.Tendsto CoeTC.coe Filter.atBot (nhds a)","name":"InfConvergenceClass.tendsto_coe_atBot_isGLB","isProp":true,"docString":"proof that a monotone function tends to `ùìù a` as `x ‚Üí -‚àû`"},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], affineSpan k ‚àÖ = ‚ä•","name":"AffineSubspace.span_empty","isProp":true,"docString":"The span of the empty set is `‚ä•`. "},{"type":"‚àÄ {M : Type u_1} {Œ± : Type u_2} [inst : VAdd M Œ±] [inst_1 : VAdd M·µÉ·µí·µñ Œ±] [self : IsCentralVAdd M Œ±] (m : M) (a : Œ±),\n  { unop := m } +·µ• a = m +·µ• a","name":"IsCentralVAdd.op_vadd_eq_vadd","isProp":true,"docString":"The right and left actions of `M` on `Œ±` are equal. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : Preorder Œ≥]\n  {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±} {t : Set Œ≤} (h‚ÇÄ : ‚àÄ (b : Œ≤), Monotone (Function.swap f b))\n  (h‚ÇÅ : ‚àÄ (a : Œ±), Monotone (f a)) (a : BddBelow s) (a : BddBelow t), BddBelow (Set.image2 f s t)","name":"BddBelow.image2","isProp":true,"docString":"See also `Monotone.map_bddBelow`. "},{"type":"‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Preadditive V]\n  {c : ComplexShape Œπ} {C : HomologicalComplex V c} {D : HomologicalComplex V c} {f : C ‚ü∂ D} {g : C ‚ü∂ D}\n  [inst_2 : CategoryTheory.Limits.HasEqualizers V] [inst_3 : CategoryTheory.Limits.HasCokernels V]\n  [inst_4 : CategoryTheory.Limits.HasImages V] [inst_5 : CategoryTheory.Limits.HasImageMaps V] (h : Homotopy f g)\n  (i : Œπ),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor (homologyFunctor V c i)) f =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor (homologyFunctor V c i)) g","name":"homology_map_eq_of_homotopy","isProp":true,"docString":"Homotopic maps induce the same map on homology.\n"},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] (self : LocallyConstant X Y),\n  IsLocallyConstant (LocallyConstant.toFun self)","name":"LocallyConstant.isLocallyConstant","isProp":true,"docString":"The map is locally constant. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ‚àà s) (p2 : P),\n  (p2 -·µ• p ‚àà AffineSubspace.direction s : Prop) ‚Üî (p2 ‚àà s : Prop)","name":"AffineSubspace.vsub_right_mem_direction_iff_mem","isProp":true,"docString":"Given a point in an affine subspace, a result of subtracting that point on the right is in the\ndirection if and only if the other point is in the subspace. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] [inst_3 : MulPosMono Œ±]\n  (ha : 1 ‚â§ a) (hb : 1 < b) (b0 : 0 ‚â§ b), 1 < a * b","name":"Right.one_lt_mul_of_le_of_lt_of_nonneg","isProp":true,"docString":"Assumes right covariance. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {a : Œ±} {b : Œ±} (h : a ‚â† b),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà {a, b}) ‚Ü¶ f i) = f a + f b","name":"finsum_mem_pair","isProp":true,"docString":"The sum of `f i` over `i ‚àà {a, b}`, `a ‚â† b`, is equal to `f a + f b`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : EmptyCollection Œ≤] [inst_1 : Insert Œ± Œ≤] [inst_2 : Singleton Œ± Œ≤]\n  [self : IsLawfulSingleton Œ± Œ≤] (x : Œ±), insert x ‚àÖ = {x}","name":"IsLawfulSingleton.insert_emptyc_eq","isProp":true,"docString":"`insert x ‚àÖ = {x}` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} {U : Set Œ±} (hC : Preperfect C) (hU : IsOpen U),\n  Preperfect (U ‚à© C)","name":"Preperfect.open_inter","isProp":true,"docString":"The intersection of a preperfect set and an open set is preperfect. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f),\n  Filter.comap f Filter.cofinite = Filter.cofinite","name":"Function.Injective.comap_cofinite_eq","isProp":true,"docString":"The pullback of the `Filter.cofinite` under an injective function is equal to `Filter.cofinite`.\nSee also `Filter.comap_cofinite_le` and `Function.Injective.tendsto_cofinite`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (self : M ‚Üí‚Çô* N) (x : M) (y : M),\n  MulHom.toFun self (x * y) = MulHom.toFun self x * MulHom.toFun self y","name":"MulHom.map_mul'","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {x : E}\n  {s : Set E},\n  (StarConvex ùïú x s : Prop) ‚Üî\n    (‚àÄ ‚¶Éy : E‚¶Ñ (a : y ‚àà s) ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 ‚â§ a) (a_2 : 0 ‚â§ b) (a_3 : 0 < a + b),\n        (a / (a + b)) ‚Ä¢ x + (b / (a + b)) ‚Ä¢ y ‚àà s :\n      Prop)","name":"starConvex_iff_div","isProp":true,"docString":"Alternative definition of star-convexity, using division. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} [inst : IsWellOrder Œ≤ s],\n  Subsingleton (r ‚â∫i s)","name":"PrincipalSeg.instSubsingletonPrincipalSeg","isProp":true,"docString":"Given a well order `s`, there is a most one principal segment embedding of `r` into `s`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X},\n  CategoryTheory.Mono (CategoryTheory.Sieve.functorInclusion S)","name":"CategoryTheory.Sieve.functorInclusion_is_mono","isProp":true,"docString":"The presheaf induced by a sieve is a subobject of the yoneda embedding. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {a : G} {b : G} (a_1 : a = b), a - b = 0","name":"sub_eq_zero_of_eq","isProp":true,"docString":"**Alias** of the reverse direction of `sub_eq_zero`."},{"type":"‚àÄ {n : ‚Ñï} (p : Fin (n + 1)) (i : Fin n), (‚ÜëFin.castSucc i < p : Prop) ‚à® (p ‚â§ ‚ÜëFin.castSucc i : Prop)","name":"Fin.succAbove_lt_ge","isProp":true,"docString":"Embedding `i : Fin n` into `Fin (n + 1)` is always about some hole `p`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsGroupHom f) {Œ≥ : Type u_1}\n  [inst_2 : Group Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} (hg : IsGroupHom g), IsGroupHom (g ‚àò f)","name":"IsGroupHom.comp","isProp":true,"docString":"The composition of two group homomorphisms is a group homomorphism. "},{"type":"‚àÄ {V : Type u_2} {Œ± : Type u_1} [inst : MulZeroOneClass Œ±] [inst_1 : Nontrivial Œ±] {A : Matrix V V Œ±}\n  (h : Matrix.IsAdjMatrix A) [inst_2 : DecidableEq Œ±], SimpleGraph.adjMatrix Œ± (Matrix.IsAdjMatrix.toGraph h) = A","name":"Matrix.IsAdjMatrix.adjMatrix_toGraph_eq","isProp":true,"docString":"If `A` is qualified as an adjacency matrix,\nthen the adjacency matrix of the graph induced by `A` is itself. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : LinearOrderedCommGroupWithZero Œ±] (ha : 1 ‚â§ a) (hb : 1 ‚â§ b), 1 ‚â§ a * b","name":"one_le_mul‚ÇÄ","isProp":true,"docString":"Alias of `one_le_mul'` for unification. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : Setoid Œ±} {f : (a : Œ±) ‚Üí Œ≤} (h : Setoid.ker f ‚â§ r) (hf : Function.Surjective f),\n  Setoid.map r f = Setoid.mapOfSurjective r f h hf","name":"Setoid.mapOfSurjective_eq_map","isProp":true,"docString":"A special case of the equivalence closure of an equivalence relation r equalling r. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F‚ÇÅ : D ‚•§ C}\n  {F‚ÇÇ : D ‚•§ C} [inst_2 : Quiver.IsThin C] (hC : CategoryTheory.Skeletal C) (hF : F‚ÇÅ ‚âÖ F‚ÇÇ), F‚ÇÅ = F‚ÇÇ","name":"CategoryTheory.Functor.eq_of_iso","isProp":true,"docString":"If `C` is thin and skeletal, then any naturally isomorphic functors to `C` are equal. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {W : CategoryTheory.MorphismProperty C}\n  (P : CategoryTheory.MorphismProperty (CategoryTheory.MorphismProperty.Localization W))\n  (hP‚ÇÅ :\n    ‚àÄ ‚¶ÉX : C‚¶Ñ ‚¶ÉY : C‚¶Ñ (f : X ‚ü∂ Y),\n      P (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.MorphismProperty.Q W)) f))\n  (hP‚ÇÇ : ‚àÄ ‚¶ÉX : C‚¶Ñ ‚¶ÉY : C‚¶Ñ (w : X ‚ü∂ Y) (hw : W w), P (CategoryTheory.Localization.Construction.winv w hw))\n  (hP‚ÇÉ : CategoryTheory.MorphismProperty.StableUnderComposition P), P = ‚ä§","name":"CategoryTheory.Localization.Construction.morphismProperty_is_top","isProp":true,"docString":"A `MorphismProperty` in `W.Localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, the inverses of the morphisms\nin `W` and if it is stable under composition "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedCancelAddCommMonoid Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c + a ‚â§ c + b","name":"OrderedCancelAddCommMonoid.add_le_add_left","isProp":true,"docString":"Addition is monotone in an ordered cancellative additive commutative monoid. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {A : Set ((a : Œ≤) ‚Üí Œ±)}\n  (hA : Set.UniformEquicontinuous A), Set.UniformEquicontinuous (closure A)","name":"UniformEquicontinuous.closure","isProp":true,"docString":"If a set of functions is uniformly equicontinuous, its closure for the product topology is also\nuniformly equicontinuous. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G} {p : (a : G) ‚Üí Prop} {x : G} (h : x ‚àà Subgroup.closure s) (H1 : p 1)\n  (Hmul : ‚àÄ (x : G) (a : x ‚àà s) (y : G) (a : p y), p (x * y))\n  (Hinv : ‚àÄ (x : G) (a : x ‚àà s) (y : G) (a : p y), p (x‚Åª¬π * y)), p x","name":"Subgroup.closure_induction_left","isProp":true,"docString":"For subgroups generated by a single element, see the simpler `zpow_induction_left`. "},{"type":"‚àÄ {n : ‚Ñï} {F : (a : TypeVec n) ‚Üí Type u_2} [inst : MvFunctor F] [self : LawfulMvFunctor F] {Œ± : TypeVec n} (x : F Œ±),\n  MvFunctor.map TypeVec.id x = x","name":"LawfulMvFunctor.id_map","isProp":true,"docString":"`map` preserved identities, i.e., maps identity on `Œ±` to identity on `F Œ±` "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] (P : Ideal R),\n  (Ideal.IsPrime (Ideal.map Polynomial.C P) : Prop) ‚Üî (Ideal.IsPrime P : Prop)","name":"Ideal.isPrime_map_C_iff_isPrime","isProp":true,"docString":"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : Fintype Œ±], Finite Œ±","name":"Finite.of_fintype","isProp":true,"docString":"For efficiency reasons, we want `Finite` instances to have higher\npriority than ones coming from `Fintype` instances. "},{"type":"‚àÄ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A} (self : AddSubgroup.Characteristic H) (œï : A ‚âÉ+ A),\n  AddSubgroup.comap (AddEquiv.toAddMonoidHom œï) H = H","name":"AddSubgroup.Characteristic.fixed","isProp":true,"docString":"`H` is fixed by all automorphisms "},{"type":"‚àÄ {Œ± : Type u} (p : (a : Œ±) ‚Üí Bool) (xs : List Œ±) (h : ‚àÄ (x : Œ±) (a : x ‚àà xs), ¬¨(p x = true : Prop)),\n  List.splitOnP p xs = [xs]","name":"List.splitOnP_eq_single","isProp":true,"docString":"If no element satisfies `p` in the list `xs`, then `xs.splitOnP p = [xs]` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : PredOrder Œ±] {a : Œ±} {b : Œ±} [inst_2 : NoMinOrder Œ±]\n  (a_1 : Order.pred a ‚â§ Order.pred b), a ‚â§ b","name":"Order.le_of_pred_le_pred","isProp":true,"docString":"**Alias** of the forward direction of `Order.pred_le_pred_iff`."},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] {Œπ : Type v} [inst_2 : Fintype Œπ],\n  FiniteDimensional.finrank R ((a : Œπ) ‚Üí R) = Fintype.card Œπ","name":"FiniteDimensional.finrank_pi","isProp":true,"docString":"The finrank of `(Œπ ‚Üí R)` is `Fintype.card Œπ`. "},{"type":"‚àÄ {R : Type u} {n : ‚Ñï} {M : (a : Fin (Nat.succ n)) ‚Üí Type w} {M‚ÇÇ : Type w‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Fin (Nat.succ n)) ‚Üí AddCommMonoid (M i)] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : (i : Fin (Nat.succ n)) ‚Üí Module R (M i)] [inst_4 : Module R M‚ÇÇ]\n  [inst_5 : (i : Fin (Nat.succ n)) ‚Üí TopologicalSpace (M i)] [inst_6 : TopologicalSpace M‚ÇÇ]\n  (f : ContinuousMultilinearMap R M M‚ÇÇ) (m : (i : Fin n) ‚Üí M (Fin.succ i)) (c : R) (x : M 0),\n  ‚Üëf (Fin.cons (c ‚Ä¢ x) m) = c ‚Ä¢ ‚Üëf (Fin.cons x m)","name":"ContinuousMultilinearMap.cons_smul","isProp":true,"docString":"In the specific case of continuous multilinear maps on spaces indexed by `Fin (n+1)`, where one\ncan build an element of `(i : Fin (n+1)) ‚Üí M i` using `cons`, one can express directly the\nmultiplicativity of a multilinear map along the first variable. "},{"type":"‚àÄ {B : Type u_1} (F : Type u_2) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F],\n  IsHomeomorphicTrivialFiberBundle F Prod.fst","name":"isHomeomorphicTrivialFiberBundle_fst","isProp":true,"docString":"The first projection in a product is a trivial fiber bundle. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±} (a_1 : IsMin a), IsMax (‚ÜëOrderDual.toDual a)","name":"IsMin.toDual","isProp":true,"docString":"**Alias** of the reverse direction of `isMax_toDual_iff`."},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {Œ±_1 : Type u_1} {p‚ÇÅ : (a : (a : Œ±) ‚Üí Œ±_1) ‚Üí Prop}\n  {f : m ((a : Œ±) ‚Üí Œ±_1)} {p‚ÇÇ : (a : Œ±) ‚Üí Prop} {q : (a : Œ±_1) ‚Üí Prop} [inst : Applicative m]\n  [inst_1 : LawfulApplicative m] {x : m Œ±} (hf : SatisfiesM p‚ÇÅ f) (hx : SatisfiesM p‚ÇÇ x)\n  (H : ‚àÄ {f : (a : Œ±) ‚Üí Œ±_1} {a : Œ±} (a_1 : p‚ÇÅ f) (a_2 : p‚ÇÇ a), q (f a)), SatisfiesM q (Seq.seq f fun (x_1 : Unit) ‚Ü¶ x)","name":"SatisfiesM.seq","isProp":true,"docString":"`SatisfiesM` distributes over `<*>`, general version. "},{"type":"‚àÄ {R : Type u_1} [inst : AddMonoid R] (a : AddUnits R), IsAddRegular ‚Üëa","name":"AddUnits.isAddRegular","isProp":true,"docString":"If `R` is an additive monoid, an element in `add_units R` is add-regular."},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul ùïú E], ‚ãÉ‚ÇÄ setOf (Bornology.IsVonNBounded ùïú) = Set.univ","name":"Bornology.isVonNBounded_covers","isProp":true,"docString":"The union of all bounded set is the whole space. "},{"type":"‚àÄ {p : ‚Ñï} {z : ‚Ñ§}, padicValRat p ‚Üëz = ‚Üë(padicValInt p z)","name":"padicValRat.of_int","isProp":true,"docString":"The `p`-adic value of an integer `z ‚â† 0` is its `p`-adic_value as a rational. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.MonoCoprod C] ‚¶ÉA : C‚¶Ñ ‚¶ÉB : C‚¶Ñ\n  (c : CategoryTheory.Limits.BinaryCofan A B) (x : CategoryTheory.Limits.IsColimit c),\n  CategoryTheory.Mono (CategoryTheory.Limits.BinaryCofan.inl c)","name":"CategoryTheory.Limits.MonoCoprod.binaryCofan_inl","isProp":true,"docString":"the left inclusion of a colimit binary cofan is mono "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : CommMonoid Œ≤] [inst_1 : CommMonoid Œ≥] (g : Œ≤ ‚Üí* Œ≥) (f : (a : Œ±) ‚Üí Œ≤)\n  (s : Finset Œ±), ‚Üëg (Finset.prod s fun (x : Œ±) ‚Ü¶ f x) = Finset.prod s fun (x : Œ±) ‚Ü¶ ‚Üëg (f x)","name":"MonoidHom.map_prod","isProp":true,"docString":"Deprecated: use `_root_.map_prod` instead. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : c ‚àà Set.uIcc a b),\n  abs (c - a) ‚â§ abs (b - a)","name":"Set.abs_sub_left_of_mem_uIcc","isProp":true,"docString":"If `c ‚àà [a, b]`, then the distance between `a` and `c` is less than or equal to\nthat of `a` and `b`  "},{"type":"‚àÄ {Œ± : Type u} {l : List Œ±} (a : List.Nodup l), List.Nodup (List.sublists' l)","name":"List.nodup.sublists'","isProp":true,"docString":"**Alias** of the reverse direction of `List.nodup_sublists'`."},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasColimitsOfSize C],\n  CategoryTheory.Limits.HasColimitsOfSize C","name":"CategoryTheory.Limits.hasColimitsOfSize_shrink","isProp":true,"docString":"`hasColimitsOfSizeShrink.{v u} C` tries to obtain `HasColimitsOfSize.{v u} C`\nfrom some other `HasColimitsOfSize C`.\n"},{"type":"‚àÄ {p : ‚Ñï} [inst : Fact (Nat.Prime p : Prop)], padicNorm p ‚Üëp < 1","name":"padicNorm.padicNorm_p_lt_one_of_prime","isProp":true,"docString":"The `p`-adic norm of `p` is less than `1` if `p` is prime.\n\nSee also `padicNorm.padicNorm_p_lt_one` for a version assuming `1 < p`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : EMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (h : Isometry f),\n  Function.Injective f","name":"Isometry.injective","isProp":true,"docString":"An isometry from an emetric space is injective "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] (s : Set Œ±),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ 0) = 0","name":"finsum_mem_zero","isProp":true,"docString":"The product of the constant function `0` over any set equals `0`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : SeminormedRing Œ±] [inst_1 : NormOneClass Œ±] (a : Œ±) (n : ‚Ñï), ‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n","name":"nnnorm_pow_le","isProp":true,"docString":"If `Œ±` is a seminormed ring with `‚Äñ1‚Äñ‚Çä = 1`, then `‚Äña ^ n‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä ^ n`.\nSee also `nnnorm_pow_le'`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] [inst_1 : LinearOrderedField Œ≤] [inst_2 : Archimedean Œ≤],\n  Subsingleton (Œ± ‚Üí+*o Œ≤)","name":"OrderRingHom.subsingleton","isProp":true,"docString":"There is at most one ordered ring homomorphism from a linear ordered field to an archimedean\nlinear ordered field. "},{"type":"‚àÄ {Œ± : Type u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {a : Œ±} {b : Œ±} (h : Relation.ReflTransGen r a b),\n  ‚àÉ (l : List Œ±),\n    (List.Chain r a l : Prop) ‚àß (List.getLast (a :: l) ((List.cons_ne_nil a l=:a :: l ‚â† [])=:a :: l ‚â† []) = b : Prop)","name":"List.exists_chain_of_relationReflTransGen","isProp":true,"docString":"If `a` and `b` are related by the reflexive transitive closure of `r`, then there is a `r`-chain\nstarting from `a` and ending on `b`.\nThe converse of `relationReflTransGen_of_exists_chain`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (hf : AntitoneOn f s) (hg : StrictAntiOn g s),\n  StrictAntiOn (fun (x : Œ≤) ‚Ü¶ f x + g x) s","name":"AntitoneOn.add_strictAnti","isProp":true,"docString":"The sum of a antitone function and a strictly antitone function is\nstrictly antitone."},{"type":"Filter.cofinite = Filter.atTop","name":"Nat.cofinite_eq_atTop","isProp":true,"docString":"For natural numbers the filters `Filter.cofinite` and `Filter.atTop` coincide. "},{"type":"‚àÄ {M : Type u_2} [inst : CommMonoid M] {Œπ : Type u_1} [inst_1 : Subsingleton Œπ] {s : Finset Œπ} {f : (a : Œπ) ‚Üí M} {b : M}\n  (h : (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) = b) (i : Œπ) (a : i ‚àà s), f i = b","name":"Fintype.eq_of_subsingleton_of_prod_eq","isProp":true,"docString":"If a product of a `Finset` of a subsingleton type has a given\nvalue, so do the terms in that product. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeSup Œ±] {f : (a : Œ±) ‚Üí Œ≤} {r : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop}\n  (H : ‚àÄ ‚¶Éi : Œ±‚¶Ñ ‚¶Éj : Œ±‚¶Ñ (a : i ‚â§ j), r (f i) (f j)), Directed r f","name":"directed_of_sup","isProp":true,"docString":"A monotone function on a sup-semilattice is directed. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] {ùíú : Finset (Finset Œ±)} {r : ‚Ñï} (hùíú : Set.Sized r ‚Üëùíú),\n  Finset.card ùíú * r ‚â§ Finset.card (Finset.shadow ùíú) * (Fintype.card Œ± - r + 1)","name":"Finset.card_mul_le_card_shadow_mul","isProp":true,"docString":"The downward **local LYM inequality**, with cancelled denominators. `ùíú` takes up less of `Œ±^(r)`\n(the finsets of card `r`) than `‚àÇùíú` takes up of `Œ±^(r - 1)`. "},{"type":"‚àÄ (n : ‚Ñï) (x : 0 < n), 4 ^ n ‚â§ 2 * n * Nat.centralBinom n","name":"Nat.four_pow_le_two_mul_self_mul_centralBinom","isProp":true,"docString":"An exponential lower bound on the central binomial coefficient.\nThis bound is weaker than `Nat.four_pow_lt_mul_centralBinom`, but it is of historical interest\nbecause it appears in Erd≈ës's proof of Bertrand's postulate.\n"},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] (f : (a : Œ±) ‚Üí M) {s : Finset Œ±} {t : Finset Œ±} (h : s ‚äÜ t),\n  (Finset.prod s fun (i : Œ±) ‚Ü¶ f i) = Finset.prod t fun (i : Œ±) ‚Ü¶ Set.mulIndicator (‚Üës) f i","name":"Set.prod_mulIndicator_subset","isProp":true,"docString":"Taking the product of an indicator function over a possibly larger `Finset` is the same as\ntaking the original function over the original `Finset`. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {Œ≤ : Type u_1} {p : (a : Œ±) ‚Üí Prop} {x : m Œ±} {q : (a : Œ≤) ‚Üí Prop}\n  [inst : Monad m] [inst_1 : LawfulMonad m] {f : (a : Œ±) ‚Üí m Œ≤} (hx : SatisfiesM p x)\n  (hf : ‚àÄ (a : Œ±) (a_1 : p a), SatisfiesM q (f a)), SatisfiesM q (x >>= f)","name":"SatisfiesM.bind","isProp":true,"docString":"`SatisfiesM` distributes over `>>=`, general version. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (Hf : Function.Injective f), Function.Injective (Option.map f)","name":"Option.map_injective","isProp":true,"docString":"`Option.map f` is injective if `f` is injective. "},{"type":"‚àÄ (n : ‚Ñï), Nat.coprime (Nat.fib n) (Nat.fib (n + 1))","name":"Nat.fib_coprime_fib_succ","isProp":true,"docString":"Subsequent Fibonacci numbers are coprime,\nsee https://proofwiki.org/wiki/Consecutive_Fibonacci_Numbers_are_Coprime "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] (x : (i : Œπ) ‚Üí Œ≤ i),\n  hammingDist x x = 0","name":"hammingDist_self","isProp":true,"docString":"Corresponds to `dist_self`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {F' : C ‚•§ D} (h : F ‚âÖ F'), CategoryTheory.Functor.essImage F = CategoryTheory.Functor.essImage F'","name":"CategoryTheory.Functor.essImage_eq_of_natIso","isProp":true,"docString":"Isomorphic functors have equal essential images. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R)\n  (r : R), ‚àÉ (V : OpenAddSubgroup R), r ‚Ä¢ ‚ÜëV ‚äÜ ‚ÜëU","name":"NonarchimedeanRing.left_mul_subset","isProp":true,"docString":"Given an open subgroup `U` and an element `r` of a nonarchimedean ring, there is an open\nsubgroup `V` such that `r ‚Ä¢ V` is contained in `U`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, (Metric.Bounded s : Prop) ‚Üî (EMetric.diam s ‚â† ‚ä§ : Prop)","name":"Metric.bounded_iff_ediam_ne_top","isProp":true,"docString":"Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. "},{"type":"‚àÄ (p : Prop), (p : Prop) ‚à® (¬¨(p : Prop) : Prop)","name":"em","isProp":true,"docString":"**Alias** of `Classical.em`."},{"type":"‚àÄ (n : ‚Ñï), Nat.choose n 2 = n * (n - 1) / 2","name":"Nat.choose_two_right","isProp":true,"docString":"`choose n 2` is the `n`-th triangle number. "},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {f‚ÇÅ : (a : Œ±) ‚Üí Œ≤} {f‚ÇÇ : (a : Œ±) ‚Üí Œ≤} {a‚ÇÅ : Œ±} {a‚ÇÇ : Œ±} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : a‚ÇÅ = a‚ÇÇ),\n  f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ","name":"congr","isProp":true,"docString":"Congruence in both function and argument. If `f‚ÇÅ = f‚ÇÇ` and `a‚ÇÅ = a‚ÇÇ` then\n`f‚ÇÅ a‚ÇÅ = f‚ÇÇ a‚ÇÇ`. This only works for nondependent functions; the theorem\nstatement is more complex in the dependent case.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"type":"‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a - b < c), a < b + c","name":"lt_add_of_sub_left_lt","isProp":true,"docString":"**Alias** of the forward direction of `sub_lt_iff_lt_add'`."},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] (I : Ideal R)\n  (N : Submodule R M) (hn : Submodule.Fg N) (hin : N ‚â§ I ‚Ä¢ N),\n  ‚àÉ (r : R), (r - 1 ‚àà I : Prop) ‚àß (‚àÄ (n : M) (a : n ‚àà N), r ‚Ä¢ n = 0 : Prop)","name":"Submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul","isProp":true,"docString":"**Nakayama's Lemma**. Atiyah-Macdonald 2.5, Eisenbud 4.7, Matsumura 2.2,\n[Stacks 00DV](https://stacks.math.columbia.edu/tag/00DV) "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = ‚ä§) (x : M) (H : ‚àÄ (r : ‚Üës), ‚àÉ (n : ‚Ñï), ‚Üër ^ n ‚Ä¢ x ‚àà M'), x ‚àà M'","name":"Submodule.mem_of_span_eq_top_of_smul_pow_mem","isProp":true,"docString":"Given `s`, a generating set of `R`, to check that an `x : M` falls in a\nsubmodule `M'` of `x`, we only need to show that `r ^ n ‚Ä¢ x ‚àà M'` for some `n` for each `r : s`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] {œÜ : MvPolynomial œÉ R}\n  {œà : MvPolynomial œÉ R} {n : M} {w : (a : œÉ) ‚Üí M} (hœÜ : MvPolynomial.IsWeightedHomogeneous w œÜ n)\n  (hœà : MvPolynomial.IsWeightedHomogeneous w œà n), MvPolynomial.IsWeightedHomogeneous w (œÜ + œà) n","name":"MvPolynomial.IsWeightedHomogeneous.add","isProp":true,"docString":"The sum of two weighted homogeneous polynomials of degree `n` is weighted homogeneous of\nweighted degree `n`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : a ‚â§ 0) (hb : b < 0), a + b < 0","name":"Left.add_neg_of_nonpos_of_neg","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg_of_nonpos_of_neg`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddSemigroup Œ±] (x : Œ±) (y : Œ±),\n  ((fun (x_1 : Œ±) ‚Ü¶ x + x_1) ‚àò fun (x : Œ±) ‚Ü¶ y + x) = fun (x_1 : Œ±) ‚Ü¶ x + y + x_1","name":"comp_add_left","isProp":true,"docString":"Composing two additions on the left by `y` then `x`\nis equal to a addition on the left by `x + y`."},{"type":"‚àÄ {a : ‚Ñï}, ‚Üë(Nat.sqrt a) ‚â§ Real.sqrt ‚Üëa","name":"Real.nat_sqrt_le_real_sqrt","isProp":true,"docString":"The natural square root is at most the real square root "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (1 ‚â§ a‚Åª¬π : Prop) ‚Üî (a ‚â§ 1 : Prop)","name":"Right.one_le_inv_iff","isProp":true,"docString":"Uses `right` co(ntra)variant. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ioc (f (Order.pred n)) (f n))","name":"Monotone.pairwise_disjoint_on_Ioc_pred","isProp":true,"docString":"If `Œ±` is a linear pred order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is a monotone function, then\nthe intervals `Set.Ioc (f Order.pred n) (f n)` are pairwise disjoint. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] [inst_1 : Fintype Œ±] [inst_2 : DecidableEq Œ±] (s : Finset Œ±)\n  (f : (a : Œ±) ‚Üí Œ≤),\n  ((Finset.sum s fun (i : Œ±) ‚Ü¶ f i) + Finset.sum (s·∂ú) fun (i : Œ±) ‚Ü¶ f i) = Finset.sum Finset.univ fun (i : Œ±) ‚Ü¶ f i","name":"Finset.sum_add_sum_compl","isProp":true,"docString":"Adding the sums of a function over `s` and over `s·∂ú` gives the whole sum.\nFor a version expressed with subtypes, see `Fintype.sum_subtype_add_sum_subtype`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±], IsGroupHom id","name":"IsGroupHom.id","isProp":true,"docString":"The identity is a group homomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : Setoid Œ±} (h : ‚àÄ (x : Œ±) (y : Œ±) (a : r x y), Setoid.Rel s x y),\n  EqvGen.Setoid r ‚â§ s","name":"Setoid.eqvGen_le","isProp":true,"docString":"The equivalence closure of a binary relation r is contained in any equivalence\nrelation containing r. "},{"type":"‚àÄ {k : Type u_1} {V1 : Type u_6} {P1 : Type u_7} {V2 : Type u_2} {P2 : Type u_3} {V3 : Type u_4} {P3 : Type u_5}\n  [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1] [inst_3 : AddTorsor V1 P1]\n  [inst_4 : AddCommGroup V2] [inst_5 : Module k V2] [inst_6 : AddTorsor V2 P2] [inst_7 : AddCommGroup V3]\n  [inst_8 : Module k V3] [inst_9 : AddTorsor V3 P3] (f : P2 ‚Üí·µÉ[k] P3) (g : P1 ‚Üí·µÉ[k] P2) (p : P1),\n  ‚Üë(AffineMap.comp f g) p = ‚Üëf (‚Üëg p)","name":"AffineMap.comp_apply","isProp":true,"docString":"Composition of affine maps acts as applying the two functions. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} (a : x ‚àà s), x‚Åª¬π ‚àà s","name":"Subfield.inv_mem","isProp":true,"docString":"A subfield is closed under inverses. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass { x : G // x ‚àà Subgroup.center G } G G","name":"Subgroup.center.smulCommClass_left","isProp":true,"docString":"The center of a group acts commutatively on that group. "},{"type":"‚àÄ (G : Type u) [inst : CommSemigroup G] [inst_1 : IsLeftCancelMul G], IsRightCancelMul G","name":"CommSemigroup.IsLeftCancelMul.toIsRightCancelMul","isProp":true,"docString":"Any `CommSemigroup G` that satisfies `IsLeftCancelMul G` also satisfies\n`IsRightCancelMul G`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] [inst_1 : DecidableRel Disjoint]\n  [inst_2 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (u : Œ±) (v : Œ±) (s : Finset Œ±),\n  Finset.card (UV.compression u v s) = Finset.card s","name":"UV.card_compression","isProp":true,"docString":"Compressing a family doesn't change its size. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] {A : Matrix n n Œ±}\n  {B : Matrix n n Œ±} {C : Matrix n n Œ±} (h : Matrix.mul B A = 1) (g : Matrix.mul C A = 1), B = C","name":"Matrix.left_inv_eq_left_inv","isProp":true,"docString":"The left inverse of matrix A is unique when existing. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C] (h : CategoryTheory.Mono (CategoryTheory.Limits.initial.to (‚ä§_ C))),\n  CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.InitialMonoClass.of_terminal","isProp":true,"docString":"To show a category is a `InitialMonoClass` it suffices to show the unique morphism from the\ninitial object to a terminal object is a monomorphism. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : FrechetUrysohnSpace X] {s : Set X} {a : X},\n  (a ‚àà closure s : Prop) ‚Üî\n    (‚àÉ (x : (a : ‚Ñï) ‚Üí X), (‚àÄ (n : ‚Ñï), x n ‚àà s : Prop) ‚àß (Filter.Tendsto x Filter.atTop (nhds a) : Prop) : Prop)","name":"mem_closure_iff_seq_limit","isProp":true,"docString":"In a Fr√©chet-Urysohn space, a point belongs to the closure of a set iff it is a limit\nof a sequence taking values in this set. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} (a : Set.Nontrivial s), Set.Nonempty (Set.offDiag s)","name":"Set.Subsingleton.offDiag_eq_empty","isProp":true,"docString":"**Alias** of the reverse direction of `Set.offDiag_nonempty`."},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]\n  {B : (a : Œπ) ‚Üí Submodule R A} (self : SubmodulesRingBasis B) (i : Œπ), ‚àÉ (j : Œπ), ‚Üë(B j) * ‚Üë(B j) ‚äÜ ‚Üë(B i)","name":"SubmodulesRingBasis.mul","isProp":true,"docString":"For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\nthat the set-theoretic product `B' * B'` is in `B`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {Œ± : Type u_3} [inst : VAdd M N] [inst_1 : VAdd N Œ±] [inst_2 : VAdd M Œ±]\n  [self : VAddAssocClass M N Œ±] (x : M) (y : N) (z : Œ±), x +·µ• y +·µ• z = x +·µ• (y +·µ• z)","name":"VAddAssocClass.vadd_assoc","isProp":true,"docString":"Associativity of `+·µ•` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} (g : (a : Œ≤) ‚Üí Œ≥) (f : (a : Œ±) ‚Üí Œ≤) (s : Set Œ±),\n  g '' (f '' s) = (fun (x : Œ±) ‚Ü¶ g (f x)) '' s","name":"Set.image_image","isProp":true,"docString":"A variant of `image_comp`, useful for rewriting "},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module R E] [inst_4 : Module R F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : ContinuousAdd E] [inst_8 : ContinuousAdd F] [inst_9 : TopologicalSpace R] [inst_10 : ContinuousSMul R E]\n  [inst_11 : ContinuousSMul R F] {f : E ‚Üí‚Çó.[R] F} (hf : LinearPMap.IsClosable f),\n  ‚àÉ! (f' : E ‚Üí‚Çó.[R] F), Submodule.topologicalClosure (LinearPMap.graph f) = LinearPMap.graph f'","name":"LinearPMap.IsClosable.existsUnique","isProp":true,"docString":"The closure is unique. "},{"type":"‚àÄ {k : Type u_1} {V1 : Type u_6} {P1 : Type u_7} {V2 : Type u_2} {P2 : Type u_3} {V3 : Type u_4} {P3 : Type u_5}\n  [inst : Ring k] [inst_1 : AddCommGroup V1] [inst_2 : Module k V1] [inst_3 : AddTorsor V1 P1]\n  [inst_4 : AddCommGroup V2] [inst_5 : Module k V2] [inst_6 : AddTorsor V2 P2] [inst_7 : AddCommGroup V3]\n  [inst_8 : Module k V3] [inst_9 : AddTorsor V3 P3] (f : P2 ‚Üí·µÉ[k] P3) (g : P1 ‚Üí·µÉ[k] P2), ‚Üë(AffineMap.comp f g) = ‚Üëf ‚àò ‚Üëg","name":"AffineMap.coe_comp","isProp":true,"docString":"Composition of affine maps acts as applying the two functions. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : LE Œ±] [inst_3 : ZeroLEOneClass Œ±], 0 ‚â§ 1","name":"zero_le_one'","isProp":true,"docString":"`zero_le_one` with the type argument explicit. "},{"type":"‚àÄ {Œ± : Type u} [inst : BEq Œ±] [self : LawfulBEq Œ±] {a : Œ±}, (a == a) = true","name":"LawfulBEq.rfl","isProp":true,"docString":"`==` is reflexive, that is, `(a == a) = true`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Finset Œ±} {t : Finset Œ±}\n  (h :\n    ‚àÄ (x : Œ±) (x_1 : x ‚àà s) (y : Œ±) (x_2 : y ‚àà s) (a : x < y) (a : ‚àÄ (z : Œ±) (a : z ‚àà s), ¬¨(z ‚àà Set.Ioo x y : Prop)),\n      ‚àÉ (z : Œ±), (z ‚àà t : Prop) ‚àß ((x < z : Prop) ‚àß (z < y : Prop) : Prop)),\n  Finset.card s ‚â§ Finset.card t + 1","name":"Finset.card_le_of_interleaved","isProp":true,"docString":"If finsets `s` and `t` are interleaved, then `Finset.card s ‚â§ Finset.card t + 1`. "},{"type":"‚àÄ {Œì : Type u_1} [inst : AddGroup Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Œì T]\n  [inst_3 : Finite Œì], ProperlyDiscontinuousVAdd Œì T","name":"Finite.to_properlyDiscontinuousVAdd","isProp":true,"docString":"A finite group action is always properly discontinuous."},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {u : (a : Œπ) ‚Üí Set X} {s : Set X}\n  (self : ShrinkingLemma.PartialRefinement u s) (i : Œπ), IsOpen (ShrinkingLemma.PartialRefinement.toFun self i)","name":"ShrinkingLemma.PartialRefinement.isOpen","isProp":true,"docString":"Each set from the partially refined family is open. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasZeroObject C],\n  ‚àÉ (X : C), CategoryTheory.Limits.IsZero X","name":"CategoryTheory.Limits.HasZeroObject.zero","isProp":true,"docString":"there exists a zero object "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X‚ÇÅ‚ÇÅ : C} {X‚ÇÅ‚ÇÇ : C} {X‚ÇÇ‚ÇÅ : C} {X‚ÇÇ‚ÇÇ : C} {X‚ÇÉ‚ÇÅ : C} {X‚ÇÉ‚ÇÇ : C}\n  {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÉ‚ÇÅ : X‚ÇÉ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÇ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÅ}\n  {v‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÉ‚ÇÇ} (s : CategoryTheory.IsPushout h‚ÇÅ‚ÇÅ (v‚ÇÅ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÅ) (v‚ÇÅ‚ÇÇ ‚â´ v‚ÇÇ‚ÇÇ) h‚ÇÉ‚ÇÅ) (p : h‚ÇÇ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÇ = v‚ÇÇ‚ÇÅ ‚â´ h‚ÇÉ‚ÇÅ)\n  (t : CategoryTheory.IsPushout h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ), CategoryTheory.IsPushout h‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÇ h‚ÇÉ‚ÇÅ","name":"CategoryTheory.IsPushout.of_bot","isProp":true,"docString":"Given a pushout square assembled from a pushout square on the top and\na commuting square on the bottom, the bottom square is a pushout square. "},{"type":"‚àÄ {l : Type u_4} {m : Type u_3} {n : Type u_2} {o : Type u_1} {Œ± : Type u_5} {A : Matrix (n ‚äï o) (l ‚äï m) Œ±}\n  {B : Matrix (n ‚äï o) (l ‚äï m) Œ±},\n  (A = B : Prop) ‚Üî\n    ((Matrix.toBlocks‚ÇÅ‚ÇÅ A = Matrix.toBlocks‚ÇÅ‚ÇÅ B : Prop) ‚àß\n        ((Matrix.toBlocks‚ÇÅ‚ÇÇ A = Matrix.toBlocks‚ÇÅ‚ÇÇ B : Prop) ‚àß\n            ((Matrix.toBlocks‚ÇÇ‚ÇÅ A = Matrix.toBlocks‚ÇÇ‚ÇÅ B : Prop) ‚àß (Matrix.toBlocks‚ÇÇ‚ÇÇ A = Matrix.toBlocks‚ÇÇ‚ÇÇ B : Prop) :\n              Prop) :\n          Prop) :\n      Prop)","name":"Matrix.ext_iff_blocks","isProp":true,"docString":"Two block matrices are equal if their blocks are equal. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s : Set X} {t : Set X} (hs : IsClosed s)\n  (ht : IsClosed t) (hd : Disjoint s t),\n  ‚àÉ (f : C(X, ‚Ñù)),\n    (Set.EqOn (‚Üëf) 0 s : Prop) ‚àß ((Set.EqOn (‚Üëf) 1 t : Prop) ‚àß (‚àÄ (x : X), ‚Üëf x ‚àà Set.Icc 0 1 : Prop) : Prop)","name":"exists_continuous_zero_one_of_closed","isProp":true,"docString":"Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nthen there exists a continuous function `f : X ‚Üí ‚Ñù` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ‚â§ f x ‚â§ 1` for all `x`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±], Isometry id","name":"isometry_id","isProp":true,"docString":"The identity is an isometry "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (1 < a‚Åª¬π : Prop) ‚Üî (a < 1 : Prop)","name":"Right.one_lt_inv_iff","isProp":true,"docString":"Uses `right` co(ntra)variant. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\n  CategoryTheory.Sieve.arrows (CategoryTheory.GrothendieckTopology.Cover.sieve S)\n    (CategoryTheory.GrothendieckTopology.Cover.Relation.f‚ÇÅ self)","name":"CategoryTheory.GrothendieckTopology.Cover.Relation.h‚ÇÅ","isProp":true,"docString":"The first arrow which is part of the relation is contained in the given sieve. "},{"type":"‚àÄ {Œ± : Type u} [inst : StrictOrderedRing Œ±] {a : Œ±} {b : Œ±} (ha : a < 0) (h : b < 1), a < a * b","name":"lt_mul_of_lt_one_right","isProp":true,"docString":"Variant of `mul_lt_of_lt_one_right` for `a` negative instead of positive. "},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} [inst : DecidableEq Œ±], FreeGroup.reduce (FreeGroup.reduce L) = FreeGroup.reduce L","name":"FreeGroup.reduce.idem","isProp":true,"docString":"`reduce` is idempotent, i.e. the maximal reduction of the maximal reduction of a word is the\nmaximal reduction of the word. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (h : Set.Finite s), Finite ‚Üës","name":"Set.Finite.to_subtype","isProp":true,"docString":"Projection of `Set.Finite` to its `Finite` instance.\nThis is intended to be used with dot notation.\nSee also `Set.Finite.Fintype` and `Set.Finite.nonempty_fintype`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (H : Subgroup G) (f : G ‚âÉ* N),\n  Subgroup.map (MulEquiv.toMonoidHom f) (Subgroup.normalizer H) =\n    Subgroup.normalizer (Subgroup.map (MulEquiv.toMonoidHom f) H)","name":"Subgroup.map_equiv_normalizer_eq","isProp":true,"docString":"The image of the normalizer is equal to the normalizer of the image of an isomorphism. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (r : (a : M) ‚Üí (a : M) ‚Üí Prop),\n  conGen r = inf‚Çõ (setOf fun (s : Con M) ‚Ü¶ ‚àÄ (x : M) (y : M) (a : r x y), ‚Üës x y)","name":"Con.conGen_eq","isProp":true,"docString":"The inductively defined smallest congruence relation containing a binary relation `r` equals\nthe infimum of the set of congruence relations containing `r`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : IdemSemiring Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b), a + b = b","name":"LE.le.add_eq_right","isProp":true,"docString":"**Alias** of the reverse direction of `add_eq_right_iff_le`."},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : P} (hp : p ‚àà s),\n  vectorSpan k s = Submodule.span k ((fun (x : P) (x_1 : P) ‚Ü¶ x -·µ• x_1) p '' s)","name":"vectorSpan_eq_span_vsub_set_left","isProp":true,"docString":"The `vectorSpan` is the span of the pairwise subtractions with a given point on the left. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : Preorder Œ≤] {a : Œ±} {f : (a : Œ±) ‚Üí Œ≤}\n  (h‚ÇÅ : AntitoneOn f (Set.Iic a)) (h‚ÇÇ : AntitoneOn f (Set.Ici a)), Antitone f","name":"AntitoneOn.Iic_union_Ici","isProp":true,"docString":"If `f` is antitone both on `(-‚àû, a]` and `[a, ‚àû)`, then it is antitone on the whole line. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚äì b = a), a ‚â§ b","name":"le_of_inf_eq","isProp":true,"docString":"**Alias** of the forward direction of `inf_eq_left`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Y)\n  [inst_1 : CategoryTheory.HasSplitCoequalizer f g], CategoryTheory.Limits.HasCoequalizer f g","name":"CategoryTheory.Limits.hasCoequalizer_of_hasSplitCoequalizer","isProp":true,"docString":"If a pair has a split coequalizer, it has a coequalizer. "},{"type":"‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a : Œ±) (b : Œ±) (a_1 : 0 < a) (a_2 : 0 < b), 0 < a * b","name":"StrictOrderedRing.mul_pos","isProp":true,"docString":"The product of two positive elements is positive. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} {d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d), a + c < b + d","name":"add_lt_add","isProp":true,"docString":"**Alias** of `add_lt_add_of_lt_of_lt`."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {c : ‚Ñù}\n  {f : (a : Œ±) ‚Üí E} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l f g'),\n  Asymptotics.IsBigOWith c l f fun (x : Œ±) ‚Ü¶ -g' x","name":"Asymptotics.IsBigOWith.neg_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigOWith_neg_right`."},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C] [hC : CategoryTheory.Pretriangulated C]\n  (T : CategoryTheory.Pretriangulated.Triangle C) (H : T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles),\n  CategoryTheory.Pretriangulated.Triangle.mor‚ÇÉ T ‚â´\n      Prefunctor.map\n        (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Equivalence.functor (CategoryTheory.shiftEquiv C 1)))\n        (CategoryTheory.Pretriangulated.Triangle.mor‚ÇÅ T) =\n    0","name":"CategoryTheory.Pretriangulated.comp_dist_triangle_mor_zero‚ÇÉ‚ÇÅ","isProp":true,"docString":"Given any distinguished triangle\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\nthe composition `h ‚â´ f‚ü¶1‚üß = 0`.\nSee <https://stacks.math.columbia.edu/tag/0146>\n"},{"type":"‚àÄ (R : Type u_1) [inst : NonAssocRing R] (p : ‚Ñï) [inst : CharP R p] [inst : Finite R], p ‚â† 0","name":"CharP.char_ne_zero_of_finite","isProp":true,"docString":"The characteristic of a finite ring cannot be zero. "},{"type":"‚àÄ {n : ‚Ñï} {p : (a : Fin n) ‚Üí Prop} [inst : DecidablePred p],\n  (Fin.find p = none : Prop) ‚Üî (‚àÄ (i : Fin n), ¬¨(p i : Prop) : Prop)","name":"Fin.find_eq_none_iff","isProp":true,"docString":"`find p` returns `none` if and only if `p i` never holds. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {y : Œ±} {Œµ : ‚Ñù} (h : x ‚àà Metric.ball y Œµ),\n  ‚àÉ (Œµ' : ‚Ñù), (Œµ' < Œµ : Prop) ‚àß (x ‚àà Metric.ball y Œµ' : Prop)","name":"Metric.exists_lt_mem_ball_of_mem_ball","isProp":true,"docString":"If a point belongs to an open ball, then there is a strictly smaller radius whose ball also\ncontains it.\n\nSee also `exists_lt_subset_ball`. "},{"type":"‚àÄ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R} (lra : IsLeftRegular a) (lrb : IsLeftRegular b),\n  IsLeftRegular (a * b)","name":"IsLeftRegular.mul","isProp":true,"docString":"In a semigroup, the product of left-regular elements is left-regular. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±} {s' : Set Œ±} {t : Set Œ≤}\n  {t' : Set Œ≤} (hs : s ‚äÜ s') (ht : t ‚äÜ t'), Set.image2 f s t ‚äÜ Set.image2 f s' t'","name":"Set.image2_subset","isProp":true,"docString":"image2 is monotone with respect to `‚äÜ`. "},{"type":"‚àÄ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M","name":"AddCancelMonoid.toIsCancelAdd","isProp":true,"docString":"Any `AddCancelMonoid G` satisfies `IsCancelAdd G`."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {K : J ‚•§ C}\n  {c : CategoryTheory.Limits.Cone K} {d : CategoryTheory.Limits.Cone K} (f : c ‚ü∂ d)\n  [i : CategoryTheory.IsIso (CategoryTheory.Limits.ConeMorphism.Hom f)], CategoryTheory.IsIso f","name":"CategoryTheory.Limits.Cones.cone_iso_of_hom_iso","isProp":true,"docString":"Given a cone morphism whose object part is an isomorphism, produce an\nisomorphism of cones.\n"},{"type":"‚àÄ {M : Type u} [self : LeftCancelMonoid M] (a : M), a * 1 = a","name":"LeftCancelMonoid.mul_one","isProp":true,"docString":"One is a right neutral element for multiplication "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {p : E}\n  {q : E} {u : E} {v : E} {x : E} {y : E} {z : E} (hz : z ‚àà segment ùïú x y) (hu : u ‚àà segment ùïú x p)\n  (hv : v ‚àà segment ùïú y q), ¬¨(Disjoint (segment ùïú u v) (‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) {p, q, z}) : Prop)","name":"not_disjoint_segment_convexHull_triple","isProp":true,"docString":"In a tetrahedron with vertices `x`, `y`, `p`, `q`, any segment `[u, v]` joining the opposite\nedges `[x, p]` and `[y, q]` passes through any triangle of vertices `p`, `q`, `z` where\n`z ‚àà [x, y]`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {œÉ' : S ‚Üí+* R}\n  [inst_2 : RingHomInvPair œÉ œÉ'] [inst_3 : RingHomInvPair œÉ' œÉ] {M : Type u_3} {M‚ÇÇ : Type u_4}\n  [inst_4 : AddCommMonoid M] [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R M] [inst_7 : Module S M‚ÇÇ]\n  (self : M ‚âÉ‚Çõ‚Çó[œÉ] M‚ÇÇ), Function.RightInverse (LinearEquiv.invFun self) (AddHom.toFun (LinearMap.toAddHom ‚Üëself))","name":"LinearEquiv.right_inv","isProp":true,"docString":"`LinearEquiv.invFun` is a right inverse to the linear equivalence's underlying function. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] [t : OrderTopology Œ±] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {h : (a : Œ≤) ‚Üí Œ±} {b : Filter Œ≤} {a : Œ±} (hg : Filter.Tendsto g b (nhds a))\n  (hh : Filter.Tendsto h b (nhds a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h), Filter.Tendsto f b (nhds a)","name":"tendsto_of_tendsto_of_tendsto_of_le_of_le","isProp":true,"docString":"**Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities\nhold everywhere. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {g : G} {H : AddSubgroup G} (a : g ‚àà H), AddSubgroup.zmultiples g ‚â§ H","name":"AddSubgroup.zmultiples_le_of_mem","isProp":true,"docString":"**Alias** of the reverse direction of `AddSubgroup.zmultiples_le`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {k : Set G} {p : (a : G) ‚Üí Prop} {x : G} (h : x ‚àà Subgroup.closure k)\n  (Hk : ‚àÄ (x : G) (a : x ‚àà k), p x) (H1 : p 1) (Hmul : ‚àÄ (x : G) (y : G) (a : p x) (a : p y), p (x * y))\n  (Hinv : ‚àÄ (x : G) (a : p x), p x‚Åª¬π), p x","name":"Subgroup.closure_induction","isProp":true,"docString":"An induction principle for closure membership. If `p` holds for `1` and all elements of `k`, and\nis preserved under multiplication and inverse, then `p` holds for all elements of the closure\nof `k`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {œÉ' : S ‚Üí+* R}\n  [inst_2 : RingHomInvPair œÉ œÉ'] [inst_3 : RingHomInvPair œÉ' œÉ] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : AddCommMonoid M] {M‚ÇÇ : Type u_4} [inst_6 : TopologicalSpace M‚ÇÇ] [inst_7 : AddCommMonoid M‚ÇÇ]\n  [inst_8 : Module R M] [inst_9 : Module S M‚ÇÇ] (self : M ‚âÉSL[œÉ] M‚ÇÇ),\n  Continuous (AddHom.toFun (LinearMap.toAddHom ‚Üë(ContinuousLinearEquiv.toLinearEquiv self)))","name":"ContinuousLinearEquiv.continuous_toFun","isProp":true,"docString":"Continuous linear equivalences between modules. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `M‚ÇÇ` will be topological modules over the\ntopological semiring `R`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] (t : List Œπ) (f : (a : Œπ) ‚Üí Set Œ±) (g : (a : Œπ) ‚Üí Œ±)\n  (hg : ‚àÄ (i : Œπ) (a : i ‚àà t), g i ‚àà f i), List.prod (List.map g t) ‚àà List.prod (List.map f t)","name":"Set.list_prod_mem_list_prod","isProp":true,"docString":"An n-ary version of `Set.mul_mem_mul`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (r : (a : M) ‚Üí (a : M) ‚Üí Prop), addConGen ‚Üë(addConGen r) = addConGen r","name":"AddCon.addConGen_idem","isProp":true,"docString":"The map sending a binary relation to the smallest additive\ncongruence relation in which it is contained is idempotent."},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a‚Åª¬π ‚â§ b), b‚Åª¬π ‚â§ a","name":"inv_le_of_inv_le'","isProp":true,"docString":"**Alias** of the forward direction of `inv_le'`."},{"type":"‚àÄ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V}\n  [inst_2 : DecidableRel (SimpleGraph.Adj G)] {n : ‚Ñï} {k : ‚Ñï} {‚Ñì : ‚Ñï} {Œº : ‚Ñï} (h : SimpleGraph.IsSRGWith G n k ‚Ñì Œº),\n  SimpleGraph.IsSRGWith (G·∂ú) n (n - k - 1) (n - (2 * k - Œº) - 2) (n - (2 * k - ‚Ñì))","name":"SimpleGraph.IsSRGWith.compl","isProp":true,"docString":"The complement of a strongly regular graph is strongly regular. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedAddCommMonoidWithTop Œ±] (x : Œ±), ‚ä§ + x = ‚ä§","name":"LinearOrderedAddCommMonoidWithTop.top_add'","isProp":true,"docString":"In a `LinearOrderedAddCommMonoidWithTop`, the `‚ä§` element is invariant under addition. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±}\n  {b : Œ±} {c : Œ±} {d : Œ±}\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1],\n  a + b - (c + d) ‚â§ a - c + (b - d)","name":"add_tsub_add_le_tsub_add_tsub","isProp":true,"docString":"See `tsub_add_tsub_comm` for the equality. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} {f : P ‚ü∂ Q} [self : CategoryTheory.StrongEpi f],\n  CategoryTheory.Epi f","name":"CategoryTheory.StrongEpi.epi","isProp":true,"docString":"The epimorphism condition on `f` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±·µí·µà} (a_1 : IsMax a), IsMin (‚ÜëOrderDual.ofDual a)","name":"IsMax.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `isMin_ofDual_iff`."},{"type":"‚àÄ {Œ± : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsPartialOrder Œ± r],\n  ‚àÉ (s : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop), ‚àÉ (x : IsLinearOrder Œ± s), r ‚â§ s","name":"extend_partialOrder","isProp":true,"docString":"Any partial order can be extended to a linear order.\n"},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] ‚¶És : Set M‚¶Ñ ‚¶Ét : Set M‚¶Ñ (h : s ‚äÜ t), Subsemigroup.closure s ‚â§ Subsemigroup.closure t","name":"Subsemigroup.closure_mono","isProp":true,"docString":"subsemigroup closure of a set is monotone in its argument: if `s ‚äÜ t`,\nthen `closure s ‚â§ closure t`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.CoproductsDisjoint C],\n  CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.initialMonoClass_of_disjoint_coproducts","isProp":true,"docString":"If `C` has disjoint coproducts, any morphism out of initial is mono. Note it isn't true in\ngeneral that `C` has strict initial objects, for instance consider the category of types and\npartial functions. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X‚ÇÅ‚ÇÅ : C} {X‚ÇÅ‚ÇÇ : C} {X‚ÇÅ‚ÇÉ : C} {X‚ÇÇ‚ÇÅ : C} {X‚ÇÇ‚ÇÇ : C} {X‚ÇÇ‚ÇÉ : C}\n  {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÉ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÉ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ}\n  {v‚ÇÅ‚ÇÉ : X‚ÇÅ‚ÇÉ ‚ü∂ X‚ÇÇ‚ÇÉ} (s : CategoryTheory.IsPushout (h‚ÇÅ‚ÇÅ ‚â´ h‚ÇÅ‚ÇÇ) v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÉ (h‚ÇÇ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÇ)) (p : h‚ÇÅ‚ÇÇ ‚â´ v‚ÇÅ‚ÇÉ = v‚ÇÅ‚ÇÇ ‚â´ h‚ÇÇ‚ÇÇ)\n  (t : CategoryTheory.IsPushout h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ), CategoryTheory.IsPushout h‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÇ","name":"CategoryTheory.IsPushout.of_right","isProp":true,"docString":"Given a pushout square assembled from a pushout square on the left and\na commuting square on the right, the right square is a pushout square. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ≤) (b : Œ≤) {v : Vector Œ± n},\n  ‚Üë(Vector.scanl f b v) = List.scanl f b ‚Üëv","name":"Vector.scanl_val","isProp":true,"docString":"The underlying `List` of a `Vector` after a `scanl` is the `List.scanl`\nof the underlying `List` of the original `Vector`.\n"},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : LinearOrder Œ≤] [inst_1 : NoMinOrder Œ≤] {u : (a : ‚Ñï) ‚Üí Œ≤}\n  (hu : Filter.Tendsto u Filter.atTop Filter.atBot),\n  Filter.Frequently (fun (n : ‚Ñï) ‚Ü¶ ‚àÄ (k : ‚Ñï) (a : k < n), u n < u k) Filter.atTop","name":"Filter.frequently_low_scores","isProp":true,"docString":"If `u` is a sequence which is unbounded below,\nthen it `Frequently` reaches a value strictly smaller than all previous values.\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : Denumerable Œ±] (n : ‚Ñï),\n  ‚àÉ (a : Œ±), (a ‚àà Encodable.decode n : Prop) ‚àß (Encodable.encode a = n : Prop)","name":"Denumerable.decode_inv","isProp":true,"docString":"`decode` and `encode` are inverses. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : LocallyCompactSpace (Œ± √ó Œ≤)], Continuous ContinuousMap.curry","name":"ContinuousMap.continuous_curry","isProp":true,"docString":"The currying process is a continuous map between function spaces. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {B : C} {A‚ÇÅ : C} {A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) (g : A‚ÇÇ ‚ü∂ B)\n  [inst_1 : CategoryTheory.Mono f] [inst_2 : CategoryTheory.Mono g] (i : A‚ÇÅ ‚âÖ A‚ÇÇ)\n  (w : CategoryTheory.Iso.hom i ‚â´ g = f), CategoryTheory.Subobject.mk f = CategoryTheory.Subobject.mk g","name":"CategoryTheory.Subobject.mk_eq_mk_of_comm","isProp":true,"docString":"To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. "},{"type":"‚àÄ {w : List ‚Ñï} {hw : List.Sorted (fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x ‚â• x_1) w} (hpos : ‚àÄ (x : ‚Ñï) (a : x ‚àà w), 0 < x),\n  YoungDiagram.rowLens (YoungDiagram.ofRowLens w hw) = w","name":"YoungDiagram.rowLens_ofRowLens_eq_self","isProp":true,"docString":"The right_inv direction of the equivalence "},{"type":"‚àÄ {x : ‚Ñ§} {y : ‚Ñ§} {z : ‚Ñ§} (h : PythagoreanTriple x y z) (h_coprime : Int.gcd x y = 1) (h_parity : x % 2 = 1)\n  (h_pos : 0 < z),\n  ‚àÉ (m : ‚Ñ§),\n    ‚àÉ (n : ‚Ñ§),\n      (x = m ^ 2 - n ^ 2 : Prop) ‚àß\n        ((y = 2 * m * n : Prop) ‚àß\n            ((z = m ^ 2 + n ^ 2 : Prop) ‚àß\n                ((Int.gcd m n = 1 : Prop) ‚àß\n                    ((((m % 2 = 0 : Prop) ‚àß (n % 2 = 1 : Prop) : Prop) ‚à®\n                            ((m % 2 = 1 : Prop) ‚àß (n % 2 = 0 : Prop) : Prop) :\n                          Prop) ‚àß\n                        (0 ‚â§ m : Prop) :\n                      Prop) :\n                  Prop) :\n              Prop) :\n          Prop)","name":"PythagoreanTriple.coprime_classification'","isProp":true,"docString":"by assuming `x` is odd and `z` is positive we get a slightly more precise classification of\nthe Pythagorean triple `x ^ 2 + y ^ 2 = z ^ 2`"},{"type":"‚àÄ {M : Type u} [self : RightCancelMonoid M] (a : M), a * 1 = a","name":"RightCancelMonoid.mul_one","isProp":true,"docString":"One is a right neutral element for multiplication "},{"type":"‚àÄ {F : Type u_2} {Œ± : Type u_1} [inst : MonoidWithZero Œ±] [inst_1 : MonoidWithZeroHomClass F ‚Ñ§ Œ±] {f : F} {g : F}\n  (h_neg_one : ‚Üëf (-1) = ‚Üëg (-1)) (h_pos : ‚àÄ (n : ‚Ñï) (a : 0 < n), ‚Üëf ‚Üën = ‚Üëg ‚Üën), f = g","name":"ext_int'","isProp":true,"docString":"If two `MonoidWithZeroHom`s agree on `-1` and the _positive_ naturals then they are equal. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {w : (a : Œ±) ‚Üí M} {b : M} [inst_1 : LinearOrderedCancelAddCommMonoid M] (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚àà t)\n  (hb : (Finset.sum s fun (x : Œ±) ‚Ü¶ w x) < Finset.card t ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß ((Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x) < b : Prop)","name":"Finset.exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:\nif the total weight of a finite set of pigeons is less than `n ‚Ä¢ b`, and they are sorted into `n`\npigeonholes, then for some pigeonhole, the total weight of the pigeons in this pigeonhole is less\nthan `b`. "},{"type":"‚àÄ {obj : Type u} [self : CategoryTheory.Category obj] {X : obj} {Y : obj} (f : X ‚ü∂ Y), f ‚â´ ùüô Y = f","name":"CategoryTheory.Category.comp_id","isProp":true,"docString":"Identity morphisms are right identities for composition. "},{"type":"‚àÄ {Œ± : Type u} [inst : CanonicallyLinearOrderedAddMonoid Œ±], ‚ä• = 0","name":"bot_eq_zero'","isProp":true,"docString":"In a linearly ordered monoid, we are happy for `bot_eq_zero` to be a `@[simp]` lemma"},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {X : CategoryTheory.SimplicialObject C} (q : ‚Ñï),\n  HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.P q) 0 =\n    ùüô (HomologicalComplex.X (AlgebraicTopology.AlternatingFaceMapComplex.obj X) 0)","name":"AlgebraicTopology.DoldKan.P_f_0_eq","isProp":true,"docString":"All the `P q` coincide with `ùüô _` in degree 0. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R]\n  [inst_3 : Semiring S] (f : R ‚Üí+* S) (s : Submonoid S) (a : R) (ha : a ‚â† 0)\n  (h : ‚àÄ (b : R) (a : b ‚àà PrincipalIdealRing.factors a), ‚Üëf b ‚àà s) (hf : ‚àÄ (c : RÀ£), ‚Üëf ‚Üëc ‚àà s), ‚Üëf a ‚àà s","name":"PrincipalIdealRing.ringHom_mem_submonoid_of_factors_subset_of_units_subset","isProp":true,"docString":"If a `RingHom` maps all units and all factors of an element `a` into a submonoid `s`, then it\nalso maps `a` into that submonoid. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] {s : Set M} {S : Submonoid M},\n  (Submonoid.closure s ‚â§ S : Prop) ‚Üî (s ‚äÜ ‚ÜëS : Prop)","name":"Submonoid.closure_le","isProp":true,"docString":"A submonoid `S` includes `closure s` if and only if it includes `s`. "},{"type":"CategoryTheory.Bicategory.Strict CategoryTheory.Cat","name":"CategoryTheory.Cat.bicategory.strict","isProp":true,"docString":"`Cat` is a strict bicategory. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (s : Multiset Œ±), s - 0 = s","name":"Multiset.sub_zero","isProp":true,"docString":"This is a special case of `tsub_zero`, which should be used instead of this.\nThis is needed to prove `OrderedSub (Multiset Œ±)`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : IsGroupHom f) (hg : IsGroupHom g), IsGroupHom fun (a : Œ±) ‚Ü¶ f a * g a","name":"IsGroupHom.mul","isProp":true,"docString":"The product of group homomorphisms is a group homomorphism if the target is commutative. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) [inst : Subsingleton Œ≤], Subsingleton Œ±","name":"Function.Injective.subsingleton","isProp":true,"docString":"If the codomain of an injective function is a subsingleton, then the domain\nis a subsingleton as well. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] {f : (a : Œ≤) ‚Üí Œ±} {l : Filter Œ≤} {s : Set Œ≤} {a : Œ±}\n  (h : ‚àÄ (x : Œ≤) (x_1 : ¬¨(x ‚àà s : Prop)), f x = a),\n  (Filter.Tendsto f (l ‚äì Filter.principal s) (nhds a) : Prop) ‚Üî (Filter.Tendsto f l (nhds a) : Prop)","name":"tendsto_inf_principal_nhds_iff_of_forall_eq","isProp":true,"docString":"Suppose that `f` sends the complement to `s` to a single point `a`, and `l` is some filter.\nThen `f` tends to `a` along `l` restricted to `s` if and only if it tends to `a` along `l`. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {L : List M‚ÇÄ} (h : 0 ‚àà L), List.prod L = 0","name":"List.prod_eq_zero","isProp":true,"docString":"If zero is an element of a list `L`, then `List.prod L = 0`. If the domain is a nontrivial\nmonoid with zero with no divisors, then this implication becomes an `iff`, see\n`List.prod_eq_zero_iff`. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {Œ≤ : Type u_1} {q : (a : Œ≤) ‚Üí Prop} {x : m Œ±} [inst : Monad m]\n  [inst_1 : LawfulMonad m] {f : (a : Œ±) ‚Üí m Œ≤} (hx : SatisfiesM (fun (a : Œ±) ‚Ü¶ SatisfiesM q (f a)) x),\n  SatisfiesM q (x >>= f)","name":"SatisfiesM.bind_pre","isProp":true,"docString":"`SatisfiesM` distributes over `>>=`, weakest precondition version. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : SemilatticeInf Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (hf : MonotoneOn f s) (hg : MonotoneOn g s), MonotoneOn (f ‚äì g) s","name":"MonotoneOn.inf","isProp":true,"docString":"Pointwise infimum of two monotone functions is a monotone function. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : BiheytingAlgebra Œ±]\n  [inst_1 : BiheytingAlgebra Œ≤] [self : BiheytingHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a ‚á® b) = ‚Üëf a ‚á® ‚Üëf b","name":"BiheytingHomClass.map_himp","isProp":true,"docString":"The proposition that a bi-Heyting homomorphism preserves the Heyting implication."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Fintype Œ±] [inst_1 : Fintype Œ≤] (f : (a : Œ±) ‚Üí Œ≤)\n  (h : Fintype.card Œ≤ < Fintype.card Œ±), ‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚â† y : Prop) ‚àß (f x = f y : Prop)","name":"Fintype.exists_ne_map_eq_of_card_lt","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons and pigeonholes.\nThis is the `Fintype` version of `Finset.exists_ne_map_eq_of_card_lt_of_maps_to`.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (hf : AntitoneOn f s) (hg : AntitoneOn g s), AntitoneOn (fun (x : Œ±) ‚Ü¶ max (f x) (g x)) s","name":"AntitoneOn.max","isProp":true,"docString":"Pointwise maximum of two antitone functions is a antitone function. "},{"type":"‚àÄ {Œπ : Type u_1} {M : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí Monoid (M i)] (self : FreeProduct.Word M)\n  (l : (i : Œπ) √ó M i) (a : l ‚àà FreeProduct.Word.toList self), Sigma.snd l ‚â† 1","name":"FreeProduct.Word.ne_one","isProp":true,"docString":"A reduced word does not contain `1` "},{"type":"‚àÄ {R : Type u} [inst : OrderedCommRing R] [inst_1 : StarOrderedRing R] [inst_2 : Algebra ‚Ñù R] [inst_3 : OrderedSMul ‚Ñù R]\n  (A‚ÇÄ : R) (A‚ÇÅ : R) (B‚ÇÄ : R) (B‚ÇÅ : R) (T : IsCHSHTuple A‚ÇÄ A‚ÇÅ B‚ÇÄ B‚ÇÅ), A‚ÇÄ * B‚ÇÄ + A‚ÇÄ * B‚ÇÅ + A‚ÇÅ * B‚ÇÄ - A‚ÇÅ * B‚ÇÅ ‚â§ 2","name":"CHSH_inequality_of_comm","isProp":true,"docString":"Given a CHSH tuple (A‚ÇÄ, A‚ÇÅ, B‚ÇÄ, B‚ÇÅ) in a *commutative* ordered `*`-algebra over ‚Ñù,\n`A‚ÇÄ * B‚ÇÄ + A‚ÇÄ * B‚ÇÅ + A‚ÇÅ * B‚ÇÄ - A‚ÇÅ * B‚ÇÅ ‚â§ 2`.\n\n(We could work over ‚Ñ§[‚Öü2] if we wanted to!)\n"},{"type":"‚àÄ {Œπ : Type u} (f : (a : Œπ) ‚Üí Ordinal), BddAbove (Set.range f)","name":"Ordinal.bddAbove_range","isProp":true,"docString":"The range of an indexed ordinal function, whose outputs live in a higher universe than the\ninputs, is always bounded above. See `Ordinal.lsub` for an explicit bound. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.NonPreadditiveAbelian C] {P : C} {Q : C}\n  (f : P ‚ü∂ Q), CategoryTheory.Mono (CategoryTheory.Abelian.factorThruCoimage f)","name":"CategoryTheory.NonPreadditiveAbelian.instMonoCoimageToHasZeroMorphismsHas_kernelsHas_cokernelsFactorThruCoimage","isProp":true,"docString":"The canonical morphism `i : coimage f ‚ü∂ Q` is a monomorphism "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : NoMinOrder Œ±] (a : Œ±),\n  ‚àÉ (f : (a : ‚Ñï) ‚Üí Œ±), (StrictAnti f : Prop) ‚àß (f 0 = a : Prop)","name":"Nat.exists_strictAnti'","isProp":true,"docString":"If `Œ±` is a preorder with no maximal elements, then there exists a strictly antitone function\n`‚Ñï ‚Üí Œ±` with any prescribed value of `f 0`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] [inst_4 : ContinuousAdd Œ≥] {f : (a : Œ±) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ≥} (hf : LowerSemicontinuous f) (hg : LowerSemicontinuous g),\n  LowerSemicontinuous fun (z : Œ±) ‚Ü¶ f z + g z","name":"LowerSemicontinuous.add","isProp":true,"docString":"The sum of two lower semicontinuous functions is lower semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {a : MÀ£} {x : M} {y : M} (h : SemiconjBy (‚Üëa) x y), SemiconjBy (‚Üëa‚Åª¬π) y x","name":"SemiconjBy.units_inv_symm_left","isProp":true,"docString":"If a unit `a` semiconjugates `x` to `y`, then `a‚Åª¬π` semiconjugates `y` to `x`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : MulOneClass Œ±] [inst_1 : MulOneClass Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsMonoidHom f)\n  (x : Œ±) (y : Œ±), f (x * y) = f x * f y","name":"IsMonoidHom.map_mul'","isProp":true,"docString":"A monoid homomorphism preserves multiplication. "},{"type":"‚àÄ {M : Type u_2} [inst : Monoid M] {Œ≥ : Type u_1} [inst_1 : Monoid Œ≥] {f : (a : M) ‚Üí Œ≥} (hf : IsMonoidHom f),\n  IsSubmonoid (Set.range f)","name":"Range.isSubmonoid","isProp":true,"docString":"The image of a monoid hom is a submonoid of the codomain. "},{"type":"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] {G : StructureGroupoid H} [inst_1 : ClosedUnderRestriction G]\n  (f : LocalHomeomorph H H) {s : Set H} {x : H} (hs : LocalEquiv.source (LocalHomeomorph.toLocalEquiv f) ‚äÜ s)\n  (hx : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv f) ‚à™ s·∂ú),\n  (StructureGroupoid.IsLocalStructomorphWithinAt G (‚Üëf) s x : Prop) ‚Üî\n    (‚àÄ (a : x ‚àà s),\n        ‚àÉ (e : LocalHomeomorph H H),\n          (e ‚àà G : Prop) ‚àß\n            ((LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚äÜ LocalEquiv.source (LocalHomeomorph.toLocalEquiv f) :\n                  Prop) ‚àß\n                ((Set.EqOn (‚Üëf) (‚Üëe) (LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)) : Prop) ‚àß\n                    (x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) : Prop) :\n                  Prop) :\n              Prop) :\n      Prop)","name":"LocalHomeomorph.isLocalStructomorphWithinAt_iff'","isProp":true,"docString":"A slight reformulation of `IsLocalStructomorphWithinAt` when `f` is a local homeomorph and\nthe set we're considering is a superset of `f.source`. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] (Œπ : Type v) [dec_Œπ : DecidableEq Œπ] {M : (a : Œπ) ‚Üí Type w}\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (N : Type u‚ÇÅ) [inst_3 : AddCommMonoid N]\n  [inst_4 : Module R N] (œÜ : (i : Œπ) ‚Üí M i ‚Üí‚Çó[R] N),\n  ‚Üë(DirectSum.toModule R Œπ N œÜ) = ‚Üë(DirectSum.toAddMonoid fun (i : Œπ) ‚Ü¶ LinearMap.toAddMonoidHom (œÜ i))","name":"DirectSum.coe_toModule_eq_coe_toAddMonoid","isProp":true,"docString":"Coproducts in the categories of modules and additive monoids commute with the forgetful functor\nfrom modules to additive monoids. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C] [hC : CategoryTheory.Pretriangulated C]\n  (T : CategoryTheory.Pretriangulated.Triangle C) (H : T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles),\n  CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T ‚â´ CategoryTheory.Pretriangulated.Triangle.mor‚ÇÉ T = 0","name":"CategoryTheory.Pretriangulated.comp_dist_triangle_mor_zero‚ÇÇ‚ÇÉ","isProp":true,"docString":"Given any distinguished triangle\n```\n      f       g       h\n  X  ‚îÄ‚îÄ‚îÄ> Y  ‚îÄ‚îÄ‚îÄ> Z  ‚îÄ‚îÄ‚îÄ> X‚ü¶1‚üß\n```\nthe composition `g ‚â´ h = 0`.\nSee <https://stacks.math.columbia.edu/tag/0146>\n"},{"type":"‚àÄ {Œ± : Type u} [inst : Setoid Œ±] [inst_1 : TopologicalSpace Œ±] {s : Set Œ±} (H : Dense s), Dense (Quotient.mk' '' s)","name":"Dense.quotient","isProp":true,"docString":"The image of a dense set under `Quotient.mk'` is a dense set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : r < 0),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atBot : Prop) ‚Üî (Filter.Tendsto f l Filter.atTop : Prop)","name":"Filter.tendsto_const_mul_atBot_of_neg","isProp":true,"docString":"If `r` is a negative constant, then `Œª x, r * f x` tends to negative infinity along a filter if\nand only if `f` tends to infinity along the same filter. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (a : ‚àÄ (x : Œ±) (y : Œ±), dist (f x) (f y) = dist x y), Isometry f","name":"Isometry.of_dist_eq","isProp":true,"docString":"A map that preserves distances is an isometry "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] (p : Polynomial R) (q : Polynomial R) (n : ‚Ñï),\n  Polynomial.coeff (p * q) n =\n    Finset.sum (Finset.Nat.antidiagonal n) fun (x : ‚Ñï √ó ‚Ñï) ‚Ü¶\n      Polynomial.coeff p (Prod.fst x) * Polynomial.coeff q (Prod.snd x)","name":"Polynomial.coeff_mul","isProp":true,"docString":"Decomposes the coefficient of the product `p * q` as a sum\nover `Nat.antidiagonal`. A version which sums over `range (n + 1)` can be obtained\nby using `Finset.Nat.sum_antidiagonal_eq_sum_range_succ`. "},{"type":"‚àÄ {m : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} (hm : 0 < m) (h : c * a ‚â° c * b [MOD m]), a ‚â° b [MOD m / Nat.gcd m c]","name":"Nat.ModEq.cancel_left_div_gcd","isProp":true,"docString":"To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c` "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Sup Œ±] [inst_1 : Sup Œ≤] [inst_2 : Bot Œ±]\n  [inst_3 : Bot Œ≤] [self : SupBotHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä• = ‚ä•","name":"SupBotHomClass.map_bot","isProp":true,"docString":"A `SupBotHomClass` morphism preserves the bottom element. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (e : LocalEquiv Œ± Œ≤),\n  LocalEquiv.trans e (LocalEquiv.symm e) ‚âà LocalEquiv.ofSet (LocalEquiv.source e)","name":"LocalEquiv.trans_self_symm","isProp":true,"docString":"Composition of a local equiv and its inverse is equivalent to the restriction of the identity\nto the source "},{"type":"‚àÄ (k : Type u_1) {V : Type u_2} (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P) (s : AffineSubspace k P), (p ‚àà ‚Üës : Prop) ‚Üî (p ‚àà s : Prop)","name":"AffineSubspace.mem_coe","isProp":true,"docString":"A point is in an affine subspace coerced to a set if and only if it is in that affine\nsubspace. "},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_1} {M : Type u_2} {M' : Type u_3} {v : (a : Œπ) ‚Üí M} [inst : Semiring R]\n  [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M'] [inst_3 : Module R M] [inst_4 : Module R M'] (f : M ‚Üí‚Çó[R] M')\n  (hf_inj : LinearMap.ker f = ‚ä•), (LinearIndependent R (‚Üëf ‚àò v) : Prop) ‚Üî (LinearIndependent R v : Prop)","name":"LinearMap.linearIndependent_iff","isProp":true,"docString":"If `f` is an injective linear map, then the family `f ‚àò v` is linearly independent\nif and only if the family `v` is linearly independent. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f)","name":"CategoryTheory.IsSplitEpi.exists_splitEpi","isProp":true,"docString":"There is a splitting "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f : Con.Quotient c ‚Üí* P),\n  Con.lift c (MonoidHom.comp f (Con.mk' c))\n      (fun (x : M) ‚Ü¶ (_ : ‚àÄ (y : M) (h : ‚Üëc x y), ‚Üëf ‚Üëx = ‚Üëf ‚Üëy)=:‚àÄ (x : M) (y : M) (h : ‚Üëc x y), ‚Üëf ‚Üëx = ‚Üëf ‚Üëy) =\n    f","name":"Con.lift_apply_mk'","isProp":true,"docString":"Given a homomorphism `f` from the quotient of a monoid by a congruence relation, `f` equals the\nhomomorphism on the quotient induced by `f` composed with the natural map from the monoid to\nthe quotient. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {f : (a : Œ±) ‚Üí Œ≤} {r : Setoid Œ≤}, Setoid.comap f r = Setoid.ker (Quotient.mk'' ‚àò f)","name":"Setoid.comap_eq","isProp":true,"docString":"Given a map `f : N ‚Üí M` and an equivalence relation `r` on `Œ≤`, the equivalence relation\ninduced on `Œ±` by `f` equals the kernel of `r`'s quotient map composed with `f`. "},{"type":"‚àÄ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : AddGroup G] [inst_1 : AddZeroClass H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F),\n  (Function.Injective ‚Üëf : Prop) ‚Üî (‚àÄ (a : G), (‚Üëf a = 0 : Prop) ‚Üî (a = 0 : Prop) : Prop)","name":"injective_iff_map_eq_zero'","isProp":true,"docString":"A homomorphism from an additive group to an additive monoid is injective iff its\nkernel is trivial, stated as an iff on the triviality of the kernel. For the implication, see\n`injective_iff_map_eq_zero`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : IsPredArchimedean Œ±] {P : (a : Œ±) ‚Üí Prop} {m : Œ±}\n  (h0 : P m) (h1 : ‚àÄ (n : Œ±) (a : n ‚â§ m) (a : P n), P (Order.pred n)) ‚¶Én : Œ±‚¶Ñ (hmn : n ‚â§ m), P n","name":"Pred.rec","isProp":true,"docString":"Induction principle on a type with a `PredOrder` for all elements below a given element `m`. "},{"type":"‚àÄ {M : Type u_2} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_3} [inst_1 : CommMonoid N] {P : Type u_1}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëg ‚Üëy)) (z : N),\n  ‚Üë(Submonoid.LocalizationMap.lift f hg) z * ‚Üëg ‚Üë(Prod.snd (Submonoid.LocalizationMap.sec f z)) =\n    ‚Üëg (Prod.fst (Submonoid.LocalizationMap.sec f z))","name":"Submonoid.LocalizationMap.lift_mul_right","isProp":true,"docString":"Given a Localization map `f : M ‚Üí* N` for a Submonoid `S ‚äÜ M`, if a `CommMonoid` map\n`g : M ‚Üí* P` induces a map `f.lift hg : N ‚Üí* P` then for all `z : N`, we have\n`f.lift hg z * g y = g x`, where `x : M, y ‚àà S` are such that `z * f y = f x`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {A : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category A]\n  (J : CategoryTheory.GrothendieckTopology C) (P : C·µí·µñ ‚•§ A) [inst_2 : CategoryTheory.Limits.HasProducts A]\n  [inst_3 : CategoryTheory.Limits.HasPullbacks C],\n  (CategoryTheory.Presheaf.IsSheaf J P : Prop) ‚Üî (CategoryTheory.Presheaf.IsSheaf' J P : Prop)","name":"CategoryTheory.Presheaf.isSheaf_iff_isSheaf'","isProp":true,"docString":"The equalizer definition of a sheaf given by `isSheaf'` is equivalent to `isSheaf`. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : DecidableEq Œ≤] (s : Finset Œ≤) (b : Œ≤),\n  Finset.filter (fun (a : Œ≤) ‚Ü¶ a = b) s = if (b ‚àà s : Prop) then {b} else ‚àÖ","name":"Finset.filter_eq'","isProp":true,"docString":"After filtering out everything that does not equal a given value, at most that value remains.\n\nThis is equivalent to `filter_eq` with the equality the other way.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [inst_1 : ProperSpace Œ±] {x : Œ±} {r : ‚Ñù} {s : Set Œ±} (hr : 0 < r)\n  (hs : IsClosed s) (h : s ‚äÜ Metric.ball x r), ‚àÉ (r' : ‚Ñù), (r' ‚àà Set.Ioo 0 r : Prop) ‚àß (s ‚äÜ Metric.ball x r' : Prop)","name":"exists_pos_lt_subset_ball","isProp":true,"docString":"If a nonempty ball in a proper space includes a closed set `s`, then there exists a nonempty\nball with the same center and a strictly smaller radius that includes `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] (r : ‚Ñù) (C : ‚Ñù) (hr : r < 1) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu : ‚àÄ (n : ‚Ñï), dist (f n) (f (n + 1)) ‚â§ C * r ^ n), CauchySeq f","name":"cauchySeq_of_le_geometric","isProp":true,"docString":"If `dist (f n) (f (n+1))` is bounded by `C * r^n`, `r < 1`, then `f` is a Cauchy sequence.\nNote that this lemma does not assume `0 ‚â§ C` or `0 ‚â§ r`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : a ‚â§ 1) (hb : b ‚â§ 1), a * b ‚â§ 1","name":"Right.mul_le_one","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_le_one`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} {F : Type u_3} [inst : TopologicalSpace ùïú] [inst_1 : CommSemiring ùïú]\n  [inst_2 : AddCommMonoid E] [inst_3 : Module ùïú E] [inst_4 : AddCommMonoid F] [inst_5 : Module ùïú F]\n  (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú), Continuous fun (x : WeakBilin B) (y : F) ‚Ü¶ ‚Üë(‚ÜëB x) y","name":"WeakBilin.coeFn_continuous","isProp":true,"docString":"The coercion `(fun x y => B x y) : E ‚Üí (F ‚Üí ùïú)` is continuous. "},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Hom L M N) {n : ‚Ñï}\n  (r : FirstOrder.Language.Relations L n) (x : (a : Fin n) ‚Üí M) (a : FirstOrder.Language.Structure.rel_map r x),\n  FirstOrder.Language.Structure.rel_map r (FirstOrder.Language.Hom.toFun self ‚àò x)","name":"FirstOrder.Language.Hom.map_rel'","isProp":true,"docString":"The homomorphism sends related elements to related elements "},{"type":"‚àÄ {G : Type u} {x : G} {y : G} [inst : AddCommMonoid G] (hx : IsOfFinAddOrder x) (hy : IsOfFinAddOrder y),\n  IsOfFinAddOrder (x + y)","name":"IsOfFinAddOrder.add","isProp":true,"docString":"Elements of finite additive order are closed under addition."},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : Set P), s -·µ• s ‚äÜ ‚Üë(vectorSpan k s)","name":"vsub_set_subset_vectorSpan","isProp":true,"docString":"The `s -·µ• s` lies within the `vectorSpan k s`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Y) {g : Y ‚ü∂ Z} {h : Y ‚ü∂ Z}\n  (w : g = h), f ‚â´ g = f ‚â´ h","name":"CategoryTheory.whisker_eq","isProp":true,"docString":"precompose an equation between morphisms by another morphism "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (b : Basis Œπ R M) {x : M} {y : M} (a : ‚àÄ (i : Œπ), ‚Üë(‚Üë(Basis.repr b) x) i = ‚Üë(‚Üë(Basis.repr b) y) i), x = y","name":"Basis.ext_elem","isProp":true,"docString":"**Alias** of the reverse direction of `Basis.ext_elem_iff`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}, (Dense (closure s) : Prop) ‚Üî (Dense s : Prop)","name":"dense_closure","isProp":true,"docString":"The closure of a set `s` is dense if and only if `s` is dense. "},{"type":"‚àÄ {V : Type u_2} {W : Type u_3} {V‚ÇÅ : Type u_1} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W]\n  [inst_2 : SeminormedAddCommGroup V‚ÇÅ] {f : NormedAddGroupHom V W} {g : NormedAddGroupHom V W}\n  (œÜ : NormedAddGroupHom V‚ÇÅ V) (h : NormedAddGroupHom.comp f œÜ = NormedAddGroupHom.comp g œÜ) (C : ‚Ñù) (hœÜ : ‚ÄñœÜ‚Äñ ‚â§ C),\n  ‚ÄñNormedAddGroupHom.Equalizer.lift œÜ h‚Äñ ‚â§ C","name":"NormedAddGroupHom.Equalizer.norm_lift_le","isProp":true,"docString":"If `œÜ` satisfies `‚ÄñœÜ‚Äñ ‚â§ C`, then the same is true for the lifted morphism. "},{"type":"‚àÄ {a : ‚Ñ§} {m : ‚Ñï} {n : ‚Ñï} (h : Int.gcd a (‚Üëm * ‚Üën) = 1), Int.gcd a ‚Üëm = 1","name":"Int.gcd_eq_one_of_gcd_mul_right_eq_one_left","isProp":true,"docString":"If `gcd a (m * n) = 1`, then `gcd a m = 1`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : TotallyDisconnectedSpace Œ±], IsTotallyDisconnected Set.univ","name":"TotallyDisconnectedSpace.isTotallyDisconnected_univ","isProp":true,"docString":"The universal set `Set.univ` in a totally disconnected space is totally disconnected. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {f : (a : Œ±) ‚Üí ENNReal} (h : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚â† ‚ä§),\n  (Finset.prod s fun (a : Œ±) ‚Ü¶ f a) < ‚ä§","name":"ENNReal.prod_lt_top","isProp":true,"docString":"A product of finite numbers is still finite "},{"type":"‚àÄ {Œ≤ : Type u} {Œ≥ : Type w} [inst : Semiring Œ≤] [inst_1 : Semiring Œ≥] (f : Œ≤ ‚Üí+* Œ≥·µê·µí·µñ) (l : List Œ≤),\n  MulOpposite.unop (‚Üëf (List.prod l)) = List.prod (List.reverse (List.map (MulOpposite.unop ‚àò ‚Üëf) l))","name":"RingHom.unop_map_list_prod","isProp":true,"docString":"A morphism into the opposite ring acts on the product by acting on the reversed elements. "},{"type":"‚àÄ {Œ± : Type u_1} {o : Part Œ±} {p : Part Œ±} (H : ‚àÄ (a : Œ±), (a ‚àà o : Prop) ‚Üî (a ‚àà p : Prop)), o = p","name":"Part.ext","isProp":true,"docString":"`Part` extensionality "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Nontrivial R]\n  {Œπ : Type w} (b : Basis Œπ R M) [inst_4 : Infinite Œπ] {Œ∫ : Type w'} (v : (a : Œ∫) ‚Üí M) (i : LinearIndependent R v)\n  (m : LinearIndependent.Maximal i), Cardinal.lift (Cardinal.mk Œπ) ‚â§ Cardinal.lift (Cardinal.mk Œ∫)","name":"infinite_basis_le_maximal_linearIndependent'","isProp":true,"docString":"Over any ring `R`, if `b` is an infinite basis for a module `M`,\nand `s` is a maximal linearly independent set,\nthen the cardinality of `b` is bounded by the cardinality of `s`.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (x : Œ± √ó Œ≤),\n  Filter.map Prod.snd (nhdsWithin x (Prod.fst ‚Åª¬π' {Prod.fst x})) = nhds (Prod.snd x)","name":"map_snd_nhdsWithin","isProp":true,"docString":"`Prod.snd` maps neighborhood of `x : Œ± √ó Œ≤` within the section `Prod.fst ‚Åª¬π' {x.1}`\nto `ùìù x.2`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} (self : r ‚âºi s) (a : Œ±)\n  (b : Œ≤) (a : s b (‚Üë(InitialSeg.toRelEmbedding self) a)), ‚àÉ (a' : Œ±), ‚Üë(InitialSeg.toRelEmbedding self) a' = b","name":"InitialSeg.init'","isProp":true,"docString":"The order embedding is an initial segment "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =o[l] fun (x : Œ±) ‚Ü¶ -g' x), f =o[l] g'","name":"Asymptotics.IsLittleO.of_neg_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_neg_right`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ≤}\n  (hf : Continuous f), f ‚Åª¬π' interior s ‚äÜ interior (f ‚Åª¬π' s)","name":"preimage_interior_subset_interior_preimage","isProp":true,"docString":"See also `interior_preimage_subset_preimage_interior`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (r : k) (p‚ÇÅ : P) (p‚ÇÇ : P), ‚Üë(AffineMap.lineMap p‚ÇÅ p‚ÇÇ) r ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ}","name":"AffineMap.lineMap_mem_affineSpan_pair","isProp":true,"docString":"A combination of two points expressed with `lineMap` lies in their affine span. "},{"type":"‚àÄ {Œ± : Type u} (s : Set (Set Œ±)),\n  Cardinal.mk ‚Üë(setOf fun (t : Set Œ±) ‚Ü¶ MeasurableSet t) ‚â§ max (Cardinal.mk ‚Üës) 2 ^ Cardinal.aleph0","name":"MeasurableSpace.cardinalMeasurableSet_le","isProp":true,"docString":"If a sigma-algebra is generated by a set of sets `s`, then the sigma\nalgebra has cardinality at most `(max (#s) 2) ^ ‚Ñµ‚ÇÄ`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {G : CategoryTheory.Comonad C}\n  (self : CategoryTheory.Comonad.Coalgebra G),\n  CategoryTheory.Comonad.Coalgebra.a self ‚â´ (CategoryTheory.Comonad.Œ¥ G).app (CategoryTheory.Comonad.Coalgebra.A self) =\n    CategoryTheory.Comonad.Coalgebra.a self ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Comonad.toFunctor G))\n        (CategoryTheory.Comonad.Coalgebra.a self)","name":"CategoryTheory.Comonad.Coalgebra.coassoc","isProp":true,"docString":"The coassociativity axiom associated to a coalgebra. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b),\n  (¬¨(a ‚ãñ b : Prop) : Prop) ‚Üî (‚àÉ (c : Œ±), (a < c : Prop) ‚àß (c < b : Prop) : Prop)","name":"not_covby_iff","isProp":true,"docString":"If `a < b`, then `b` does not cover `a` iff there's an element in between. "},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí SMul M (Œ± i)] (i : Œπ)\n  [inst_1 : FaithfulSMul M (Œ± i)], FaithfulSMul M ((i : Œπ) √ó Œ± i)","name":"Sigma.FaithfulSMul'","isProp":true,"docString":"This is not an instance because `i` becomes a metavariable. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedOrderedAddGroup Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx - y‚Äñ","name":"NormedOrderedAddGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {X : Type u_2} [inst : EMetricSpace X] {Œπ : Type u_1} {I : Finset Œπ} {s : Set X} {t : (a : Œπ) ‚Üí Set X}\n  (a : ‚àÄ (i : Œπ) (a : i ‚àà I), IsMetricSeparated s (t i)),\n  IsMetricSeparated s (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà I) ‚Ü¶ t i)","name":"IsMetricSeparated.finset_union·µ¢_right","isProp":true,"docString":"**Alias** of the reverse direction of `IsMetricSeparated.finset_union·µ¢_right_iff`."},{"type":"‚àÄ (S : Set ‚Ñù) (hS : ‚àÄ (x : ‚Ñù) (a : x ‚àà S), 0 ‚â§ x), 0 ‚â§ inf‚Çõ S","name":"Real.inf‚Çõ_nonneg","isProp":true,"docString":"As `0` is the default value for `Real.inf‚Çõ` of the empty set, it suffices to show that `S` is\nbounded below by `0` to show that `0 ‚â§ inf‚Çõ S`.\n"},{"type":"‚àÄ {I : Type u} {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Monoid Œ±] [inst_1 : AddMonoid Œ≤] [inst_2 : DistribMulAction Œ± Œ≤]\n  [inst_3 : DecidableEq I] (i : I) (r : Œ±) (x : Œ≤), Pi.single i (r ‚Ä¢ x) = r ‚Ä¢ Pi.single i x","name":"Pi.single_smul'","isProp":true,"docString":"A version of `Pi.single_smul` for non-dependent functions. It is useful in cases where Lean\nfails to apply `Pi.single_smul`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddCommGroup Œ±] (a : Œ±) (h : 0 ‚â§ a), a‚Å∫ = a","name":"LatticeOrderedCommGroup.pos_of_nonneg","isProp":true,"docString":"If `a` is positive, then it is equal to its positive component `a‚Å∫`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {G : CategoryTheory.Comonad C}\n  (self : CategoryTheory.Comonad.Coalgebra G),\n  CategoryTheory.Comonad.Coalgebra.a self ‚â´ (CategoryTheory.Comonad.Œµ G).app (CategoryTheory.Comonad.Coalgebra.A self) =\n    ùüô (CategoryTheory.Comonad.Coalgebra.A self)","name":"CategoryTheory.Comonad.Coalgebra.counit","isProp":true,"docString":"The counit axiom associated to a coalgebra. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (a : Œ±), nndist a a = 0","name":"nndist_self","isProp":true,"docString":"`nndist x x` vanishes"},{"type":"‚àÄ {R : Type u_3} [inst : CommSemiring R] {R' : Type u_1} [inst_1 : Monoid R'] {M : Type u_4} {N : Type u_2}\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : DistribMulAction R' M] [inst_7 : DistribMulAction R' N] [inst_8 : TensorProduct.CompatibleSMul R R' M N]\n  (r : R') (m : M) (n : N), (r ‚Ä¢ m) ‚äó‚Çú[R] n = m ‚äó‚Çú[R] (r ‚Ä¢ n)","name":"TensorProduct.smul_tmul","isProp":true,"docString":"`smul` can be moved from one side of the product to the other ."},{"type":"‚àÄ (Œ± : Type u_1) [inst : CompleteLattice Œ±] (k : Œ±),\n  (CompleteLattice.IsCompactElement k : Prop) ‚Üî\n    (‚àÄ (s : Set Œ±) (a : Set.Nonempty s) (a : DirectedOn (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) s) (a : k ‚â§ sup‚Çõ s),\n        ‚àÉ (x : Œ±), (x ‚àà s : Prop) ‚àß (k ‚â§ x : Prop) :\n      Prop)","name":"CompleteLattice.isCompactElement_iff_le_of_directed_sup‚Çõ_le","isProp":true,"docString":"An element `k` is compact if and only if any directed set with `sup‚Çõ` above\n`k` already got above `k` at some point in the set. "},{"type":"‚àÄ {G : Type u} [self : DivInvMonoid G] (n : ‚Ñï) (a : G),\n  DivInvMonoid.zpow (Int.negSucc n) a = (DivInvMonoid.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"DivInvMonoid.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ (p : (a : True) ‚Üí Prop), (‚àÉ (x : True), p x : Prop) ‚Üî (p (True.intro=:True) : Prop)","name":"exists_true_left","isProp":true,"docString":"See `IsEmpty.exists_iff` for the `false` version. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïú E] {p : (a : Œπ) ‚Üí E},\n  (ConvexIndependent ùïú p : Prop) ‚Üî\n    (‚àÄ (s : Finset Œπ) (x : Œπ) (a : p x ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üë(Finset.image p s)), x ‚àà s :\n      Prop)","name":"convexIndependent_iff_finset","isProp":true,"docString":"To check convex independence, one only has to check finsets thanks to Carath√©odory's theorem. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : T2Space Œ±] [inst_3 : Encodable Œ≥] (m : (a : Set Œ≤) ‚Üí Œ±) (m0 : m ‚àÖ = 0) (s : (a : Œ≥) ‚Üí Set Œ≤),\n  (tsum fun (i : ‚Ñï) ‚Ü¶ m (Set.union·µ¢ fun (b : Œ≥) ‚Ü¶ Set.union·µ¢ fun (h : b ‚àà Encodable.decode‚ÇÇ Œ≥ i) ‚Ü¶ s b)) =\n    tsum fun (b : Œ≥) ‚Ü¶ m (s b)","name":"tsum_union·µ¢_decode‚ÇÇ","isProp":true,"docString":"`tsum_sup·µ¢_decode‚ÇÇ` specialized to the complete lattice of sets. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p‚ÇÅ : P) (p‚ÇÇ : P), p‚ÇÇ ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ}","name":"right_mem_affineSpan_pair","isProp":true,"docString":"The second of two points lies in their affine span. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±}, Continuous fun (x : Œ±) ‚Ü¶ EMetric.infEdist x s","name":"EMetric.continuous_infEdist","isProp":true,"docString":"The edist to a set depends continuously on the point "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} {k : ‚Ñï} (h : m % k = n % k), (m - n) % k = 0","name":"Nat.sub_mod_eq_zero_of_mod_eq","isProp":true,"docString":"If `m` and `n` are equal mod `k`, `m - n` is zero mod `k`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤]\n  (f : (a : Œ±) ‚Üí Œ≤) {b : M} [inst_3 : LinearOrderedCommSemiring M] [inst_4 : Nonempty Œ≤]\n  (hb : ‚Üë(Fintype.card Œ±) ‚â§ Fintype.card Œ≤ ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), ‚Üë(Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ)) ‚â§ b","name":"Fintype.exists_card_fiber_le_of_card_le_nsmul","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function `f`\nbetween finite types `Œ±` and `Œ≤` and a number `b` such that `card Œ± ‚â§ card Œ≤ ‚Ä¢ b`, there exists an\nelement `y : Œ≤` such that its preimage has at most `b` elements.\nSee also `Fintype.exists_card_fiber_lt_of_card_lt_nsmul` for a stronger statement. "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R), Subsemiring.closure ‚Üës = s","name":"Subsemiring.closure_eq","isProp":true,"docString":"Closure of a subsemiring `S` equals `S`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±} (h : x ‚àà s), EMetric.infEdist x s = 0","name":"EMetric.infEdist_zero_of_mem","isProp":true,"docString":"If a point `x` belongs to `s`, then its edist to `s` vanishes "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} {Œ¥ : Type u_1} {g : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Œ¥}\n  {g' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Œ¥} {s : Set Œ±} {t : Set Œ≤} {u : Set Œ≥}\n  (h : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), g a b c = g' a b c), Set.image3 g s t u = Set.image3 g' s t u","name":"Set.image3_congr'","isProp":true,"docString":"A common special case of `image3_congr` "},{"type":"‚àÄ {p : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (hab : Nat.coprime a b),\n  ‚Üë(Nat.factorization (a * b)) p = ‚Üë(Nat.factorization a) p + ‚Üë(Nat.factorization b) p","name":"Nat.factorization_mul_apply_of_coprime","isProp":true,"docString":"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] {c : AddCon M}, Function.Surjective ‚Üë(AddCon.mk' c)","name":"AddCon.mk'_surjective","isProp":true,"docString":"The natural homomorphism from an `AddMonoid` to its quotient by a congruence\nrelation is surjective."},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (x : X) [h : Filter.NeBot (nhdsWithin x ({x}·∂ú))],\n  Filter.NeBot (nhdsWithin (‚Üëx) ({‚Üëx}·∂ú))","name":"Alexandroff.nhdsWithin_compl_coe_neBot","isProp":true,"docString":"If `x` is not an isolated point of `X`, then `x : Alexandroff X` is not an isolated point\nof `Alexandroff X`. "},{"type":"‚àÄ {Œπ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : (a : Œπ) ‚Üí Set X} {s : Set X}\n  (hs : IsClosed s) (uo : ‚àÄ (i : Œπ), IsOpen (u i))\n  (uf : ‚àÄ (x : X) (a : x ‚àà s), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ x ‚àà u i)) (us : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ u i),\n  ‚àÉ (v : (a : Œπ) ‚Üí Set X),\n    (s ‚äÜ Set.union·µ¢ v : Prop) ‚àß ((‚àÄ (i : Œπ), IsOpen (v i) : Prop) ‚àß (‚àÄ (i : Œπ), closure (v i) ‚äÜ u i : Prop) : Prop)","name":"exists_subset_union·µ¢_closure_subset","isProp":true,"docString":"**Shrinking lemma**. A point-finite open cover of a closed subset of a normal space can be\n\"shrunk\" to a new open cover so that the closure of each new open set is contained in the\ncorresponding original open set. "},{"type":"‚àÄ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a","name":"MulOneClass.mul_one","isProp":true,"docString":"One is a right neutral element for multiplication "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  {f : Filter Œ±} {a : Œ±} [inst_3 : Filter.NeBot f] (a_1 : f ‚â§ nhds a), Filter.limsup‚Çõ f = a","name":"limsup‚Çõ_eq_of_le_nhds","isProp":true,"docString":"If a filter is converging, its liminf coincides with its limit. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F}\n  {l : Filter Œ±}, (f =o[l] g : Prop) ‚Üî (‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ (a : 0 < c), Asymptotics.IsBigOWith c l f g : Prop)","name":"Asymptotics.isLittleO_iff_forall_isBigOWith","isProp":true,"docString":"Definition of `IsLittleO` in terms of `IsBigOWith`. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] {M : Type u_1}\n  {hom : Type u_2} [inst_3 : AddZeroClass M] [inst_4 : TopologicalSpace M] [inst_5 : ContinuousAdd M]\n  [inst_6 : AddMonoidHomClass hom G M] (f : hom) (hf : ContinuousAt (‚Üëf) 0), Continuous ‚Üëf","name":"continuous_of_continuousAt_zero","isProp":true,"docString":"An additive monoid homomorphism (a bundled morphism of a type that implements\n`AddMonoidHomClass`) from an additive topological group to an additive topological monoid is\ncontinuous provided that it is continuous at zero. See also\n`uniformContinuous_of_continuousAt_zero`."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} {v : Vector Œ± n} {w : Vector Œ± n} (x : ‚àÄ (m : Fin n), Vector.get v m = Vector.get w m), v = w","name":"Vector.ext","isProp":true,"docString":"Two `v w : Vector Œ± n` are equal iff they are equal at every single index. "},{"type":"‚àÄ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {a : M} {b : M}\n  (ha : b * a = 1), Filter.Tendsto (fun (x : M) ‚Ü¶ a * x) (Filter.cocompact M) (Filter.cocompact M)","name":"Filter.tendsto_cocompact_mul_left","isProp":true,"docString":"Left-multiplication by a left-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} [inst_1 : DenselyOrdered Œ±], ¬¨(a ‚ãñ b : Prop)","name":"not_covby","isProp":true,"docString":"In a dense order, nothing covers anything. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hf : ContinuousOn f s)\n  (hsc : IsClosed s) {x‚ÇÄ : Œ≤} (h‚ÇÄ : x‚ÇÄ ‚àà s)\n  (hc : Filter.Eventually (fun (x : Œ≤) ‚Ü¶ f x ‚â§ f x‚ÇÄ) (Filter.cocompact Œ≤ ‚äì Filter.principal s)),\n  ‚àÉ (x : Œ≤), (x ‚àà s : Prop) ‚àß (IsMaxOn f s x : Prop)","name":"ContinuousOn.exists_isMaxOn'","isProp":true,"docString":"The **extreme value theorem**: if a function `f` is continuous on a closed set `s` and it is\nsmaller than a value in its image away from compact sets, then it has a maximum on this set. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : (a : Fin n) ‚Üí Œ±} {P : (a : (a : Fin n) ‚Üí Œ±) ‚Üí Prop} (hf : P f)\n  (h :\n    ‚àÄ (œÉ : Equiv.Perm (Fin n)) (i : Fin n) (j : Fin n) (a : i < j) (a : (f ‚àò ‚ÜëœÉ) j < (f ‚àò ‚ÜëœÉ) i) (a : P (f ‚àò ‚ÜëœÉ)),\n      P (f ‚àò ‚ÜëœÉ ‚àò ‚Üë(Equiv.swap i j))),\n  P (f ‚àò ‚Üë(Tuple.sort f))","name":"Tuple.bubble_sort_induction'","isProp":true,"docString":"*Bubble sort induction*: Prove that the sorted version of `f` has some property `P`\nif `f` satsifies `P` and `P` is preserved on permutations of `f` when swapping two\nantitone values. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±] {x : Œ±} {y : Œ±} (hx : 0 < x) (hy : 1 < y),\n  ‚àÉ (n : ‚Ñ§), x ‚àà Set.Ico (y ^ n) (y ^ (n + 1))","name":"exists_mem_Ico_zpow","isProp":true,"docString":"Every positive `x` is between two successive integer powers of\nanother `y` greater than one. This is the same as `exists_mem_Ioc_zpow`,\nbut with ‚â§ and < the other way around. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤], IsOpenMap Prod.snd","name":"isOpenMap_snd","isProp":true,"docString":"The second projection in a product of topological spaces sends open sets to open sets. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} {c : Œ±} [inst : LinearOrder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±]\n  [inst_3 : OrderedSub Œ±]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (h : a - b < a - c),\n  c < b","name":"lt_of_tsub_lt_tsub_left","isProp":true,"docString":"See `lt_of_tsub_lt_tsub_left_of_le` for a weaker statement in a partial order. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±·µí·µà} (a_1 : IsBot a), IsTop (‚ÜëOrderDual.ofDual a)","name":"IsBot.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `isTop_ofDual_iff`."},{"type":"‚àÄ {X : CompHaus} {Y : CompHaus} (f : X ‚ü∂ Y),\n  IsClosedMap (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget CompHaus)) f)","name":"CompHaus.isClosedMap","isProp":true,"docString":"Any continuous function on compact Hausdorff spaces is a closed map. "},{"type":"‚àÄ {S : Type u_1} [inst : Mul S] {a : S} {b : S} (h : Commute a b), Commute b a","name":"Commute.symm","isProp":true,"docString":"If `a` commutes with `b`, then `b` commutes with `a`. "},{"type":"‚àÄ {a : ‚Ñù} {b : ‚Ñù} (h : a < b), Cardinal.mk ‚Üë(Set.Icc a b) = Cardinal.continuum","name":"Cardinal.mk_Icc_real","isProp":true,"docString":"The cardinality of the interval [a, b]. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C]\n  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasCoequalizers C","name":"CategoryTheory.Limits.hasCoequalizers_of_hasPushouts_and_binary_coproducts","isProp":true,"docString":"Any category with pullbacks and binary products, has equalizers. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [self : IsCoatomistic Œ±] (b : Œ±),\n  ‚àÉ (s : Set Œ±), (b = inf‚Çõ s : Prop) ‚àß (‚àÄ (a : Œ±) (a_1 : a ‚àà s), IsCoatom a : Prop)","name":"IsCoatomistic.eq_inf‚Çõ_coatoms","isProp":true,"docString":"Every element is a `inf‚Çõ` of a set of coatoms. "},{"type":"‚àÄ {Œ± : Type u_1} {R : Type u_2} [inst : CommSemiring R] (a : R) (b : R) (s : Finset Œ±),\n  (Finset.sum (Finset.powerset s) fun (t : Finset Œ±) ‚Ü¶ a ^ Finset.card t * b ^ (Finset.card s - Finset.card t)) =\n    (a + b) ^ Finset.card s","name":"Finset.sum_pow_mul_eq_add_pow","isProp":true,"docString":"Summing `a^s.card * b^(n-s.card)` over all finite subsets `s` of a `Finset`\ngives `(a + b)^s.card`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {b : Œ±} {c : Œ±}\n  (bc : b < c) (a : Œ±), a * b < a * c","name":"OrderedCommGroup.mul_lt_mul_left'","isProp":true,"docString":"**Alias** of `mul_lt_mul_left'`."},{"type":"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {u : (a : ‚Ñï) ‚Üí E} {l : E}\n  (h : Filter.Tendsto u Filter.atTop (nhds l)),\n  Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ (‚Üën)‚Åª¬π ‚Ä¢ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ u i) Filter.atTop (nhds l)","name":"Filter.Tendsto.cesaro_smul","isProp":true,"docString":"The Cesaro average of a converging sequence converges to the same limit. "},{"type":"‚àÄ {V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ] (f : V‚ÇÅ ‚Üí+ V‚ÇÇ)\n  {C : ‚Ñù} (h : ‚àÄ (x : V‚ÇÅ), ‚Äñ‚Üëf x‚Äñ ‚â§ C * ‚Äñx‚Äñ), ‚ÄñAddMonoidHom.mkNormedAddGroupHom f C h‚Äñ ‚â§ max C 0","name":"AddMonoidHom.mkNormedAddGroupHom_norm_le'","isProp":true,"docString":"**Alias** of `NormedAddGroupHom.mkNormedAddGroupHom_norm_le'`."},{"type":"‚àÄ {Œ± : Type u} [self : Shelf Œ±] {x : Œ±} {y : Œ±} {z : Œ±},\n  Shelf.act x (Shelf.act y z) = Shelf.act (Shelf.act x y) (Shelf.act x z)","name":"Shelf.self_distrib","isProp":true,"docString":"A verification that `act` is self-distributive"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : TopologicalSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±} {p : Filter Œπ} {s : Set Œ≤},\n  (TendstoLocallyUniformlyOn F f p s : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0) (x : Œ≤) (a : x ‚àà s),\n        ‚àÉ (t : Set Œ≤),\n          (t ‚àà nhdsWithin x s : Prop) ‚àß\n            (Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (y : Œ≤) (a : y ‚àà t), dist (f y) (F n y) < Œµ) p : Prop) :\n      Prop)","name":"Metric.tendstoLocallyUniformlyOn_iff","isProp":true,"docString":"Expressing locally uniform convergence on a set using `dist`. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} {l' : List Œ±},\n  (List.Sublist l l' : Prop) ‚Üî (‚àÉ (f : ‚Ñï ‚Ü™o ‚Ñï), ‚àÄ (ix : ‚Ñï), List.get? l ix = List.get? l' (‚Üëf ix) : Prop)","name":"List.sublist_iff_exists_orderEmbedding_get?_eq","isProp":true,"docString":"A `l : List Œ±` is `Sublist l l'` for `l' : List Œ±` iff\nthere is `f`, an order-preserving embedding of `‚Ñï` into `‚Ñï` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`.\n"},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {s : Set E} {x : E}\n  (hx : x ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ‚Ñù)) s) (y : E),\n  ‚àÉ (x' : E), (x' ‚àà s : Prop) ‚àß (dist x y ‚â§ dist x' y : Prop)","name":"convexHull_exists_dist_ge","isProp":true,"docString":"Given a point `x` in the convex hull of `s` and a point `y`, there exists a point\nof `s` at distance at least `dist x y` from `y`. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {s : Set R} {p : (a : R) ‚Üí (a : R) ‚Üí Prop} {a : R} {b : R} (ha : a ‚àà Subring.closure s)\n  (hb : b ‚àà Subring.closure s) (Hs : ‚àÄ (x : R) (a : x ‚àà s) (y : R) (a : y ‚àà s), p x y) (H0_left : ‚àÄ (x : R), p 0 x)\n  (H0_right : ‚àÄ (x : R), p x 0) (H1_left : ‚àÄ (x : R), p 1 x) (H1_right : ‚àÄ (x : R), p x 1)\n  (Hneg_left : ‚àÄ (x : R) (y : R) (a : p x y), p (-x) y) (Hneg_right : ‚àÄ (x : R) (y : R) (a : p x y), p x (-y))\n  (Hadd_left : ‚àÄ (x‚ÇÅ : R) (x‚ÇÇ : R) (y : R) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ + x‚ÇÇ) y)\n  (Hadd_right : ‚àÄ (x : R) (y‚ÇÅ : R) (y‚ÇÇ : R) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ + y‚ÇÇ))\n  (Hmul_left : ‚àÄ (x‚ÇÅ : R) (x‚ÇÇ : R) (y : R) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ * x‚ÇÇ) y)\n  (Hmul_right : ‚àÄ (x : R) (y‚ÇÅ : R) (y‚ÇÇ : R) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ * y‚ÇÇ)), p a b","name":"Subring.closure_induction‚ÇÇ","isProp":true,"docString":"An induction principle for closure membership, for predicates with two arguments. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] [inst_2 : Encodable Œπ] {s : Set Œ±}\n  (hs : IsGŒ¥ s) (hd : Dense s) {f : (a : Œπ) ‚Üí Set Œ±} (hc : ‚àÄ (i : Œπ), IsClosed (f i))\n  (hU : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ f i), Dense (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ interior (f i))","name":"IsGŒ¥.dense_union·µ¢_interior_of_closed","isProp":true,"docString":"If a countable family of closed sets cover a dense `GŒ¥` set, then the union of their interiors\nis dense. Formulated here with `‚ãÉ`. "},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], CompleteSpace (TopologicalSpace.NonemptyCompacts Œ±)","name":"EMetric.NonemptyCompacts.completeSpace","isProp":true,"docString":"In a complete space, the type of nonempty compact subsets is complete. This follows\nfrom the same statement for closed subsets "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Fintype Œ±] [inst_1 : DecidableEq Œ≤] {t : Finset Œ≤}\n  (hŒ±t : Fintype.card Œ± = Finset.card t) {s : Finset Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hfst : Finset.image f s ‚äÜ t)\n  (hfs : Set.InjOn f ‚Üës), ‚àÉ (g : Œ± ‚âÉ { x : Œ≤ // x ‚àà t }), ‚àÄ (i : Œ±) (a : i ‚àà s), ‚Üë(‚Üëg i) = f i","name":"Finset.exists_equiv_extend_of_card_eq","isProp":true,"docString":"Any injection from a finset `s` in a fintype `Œ±` to a finset `t` of the same cardinality as `Œ±`\ncan be extended to a bijection between `Œ±` and `t`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {xs : List Œ±} {ys : List Œ≤} {x : Œ±} {y : Œ≤},\n  ((x, y) ‚àà xs √óÀ¢ ys : Prop) ‚Üî ((x ‚àà xs : Prop) ‚àß (y ‚àà ys : Prop) : Prop)","name":"List.pair_mem_product","isProp":true,"docString":"List.prod satisfies a specification of cartesian product on lists. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V}, (Function.Injective ‚Üëf : Prop) ‚Üî (Function.Surjective ‚Üëf : Prop)","name":"LinearMap.injective_iff_surjective","isProp":true,"docString":"On a finite-dimensional space, a linear map is injective if and only if it is surjective. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {x : R} {y : R} (h : Commute x y) (n : ‚Ñï),\n  (x + y) ^ n = Finset.sum (Finset.range (n + 1)) fun (m : ‚Ñï) ‚Ü¶ x ^ m * y ^ (n - m) * ‚Üë(Nat.choose n m)","name":"Commute.add_pow","isProp":true,"docString":"A version of the **binomial theorem** for commuting elements in noncommutative semirings. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] [inst_1 : Preorder M] (L : List M) (h : 0 < List.sum L), 0 < List.length L","name":"List.length_pos_of_sum_pos","isProp":true,"docString":"A list with positive sum must have positive length."},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : CommMonoid Œ≤] {s : Finset Œ≥} {t : (a : Œ≥) ‚Üí Finset Œ±} {t' : Finset Œ±}\n  {s' : (a : Œ±) ‚Üí Finset Œ≥}\n  (h : ‚àÄ (x : Œ≥) (y : Œ±), ((x ‚àà s : Prop) ‚àß (y ‚àà t x : Prop) : Prop) ‚Üî ((x ‚àà s' y : Prop) ‚àß (y ‚àà t' : Prop) : Prop))\n  {f : (a : Œ≥) ‚Üí (a : Œ±) ‚Üí Œ≤},\n  (Finset.prod s fun (x : Œ≥) ‚Ü¶ Finset.prod (t x) fun (y : Œ±) ‚Ü¶ f x y) =\n    Finset.prod t' fun (y : Œ±) ‚Ü¶ Finset.prod (s' y) fun (x : Œ≥) ‚Ü¶ f x y","name":"Finset.prod_comm'","isProp":true,"docString":"Generalization of `Finset.prod_comm` to the case when the inner `Finset`s depend on the outer\nvariable. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] [inst_2 : Zero Œ±]\n  [inst_3 : Zero Œ≤] [inst_4 : SMul Œ± Œ≤] [inst_5 : BoundedSMul Œ± Œ≤], ContinuousSMul Œ± Œ≤","name":"BoundedSMul.continuousSMul","isProp":true,"docString":"The typeclass `BoundedSMul` on a metric-space scalar action implies continuity of the action. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C],\n  CategoryTheory.Limits.HasStrongEpiImages C","name":"CategoryTheory.Limits.hasStrongEpiImages_of_hasStrongEpiMonoFactorisations","isProp":true,"docString":"If we constructed our images from strong epi-mono factorisations, then these images are\nstrong epi images. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ‚Ñï} {i : Fin (n + 1)},\n  CategoryTheory.SimplicialObject.œÉ X i ‚â´ CategoryTheory.SimplicialObject.Œ¥ X (Fin.succ i) =\n    ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor X) (Opposite.op (SimplexCategory.mk n)))","name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_succ","isProp":true,"docString":"The second part of the third simplicial identity "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) [inst_5 : DecidableEq Œπ] [inst_6 : Fintype Œπ] (m : (i : Œπ) ‚Üí M‚ÇÅ i)\n  (m' : (i : Œπ) ‚Üí M‚ÇÅ i), ‚Üëf (m + m') = Finset.sum Finset.univ fun (s : Finset Œπ) ‚Ü¶ ‚Üëf (Finset.piecewise s m m')","name":"MultilinearMap.map_add_univ","isProp":true,"docString":"Additivity of a multilinear map along all coordinates at the same time,\nwriting `f (m + m')` as the sum  of `f (s.piecewise m m')` over all sets `s`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p1 : P} {p2 : P} (hp1 : p1 ‚àà spanPoints k s) (hp2 : p2 ‚àà spanPoints k s),\n  p1 -·µ• p2 ‚àà vectorSpan k s","name":"vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints","isProp":true,"docString":"Subtracting two points in the affine span produces a vector in the spanning submodule. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ≤} {g : (a : Œ≤) ‚Üí Œ±}\n  (hg : Set.InjOn g s),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà g '' s) ‚Ü¶ f i) = finsum fun (j : Œ≤) ‚Ü¶ finsum fun (h : j ‚àà s) ‚Ü¶ f (g j)","name":"finsum_mem_image","isProp":true,"docString":"The sum of `f y` over `y ‚àà g '' s` equals the sum of `f (g i)` over `s` provided that\n`g` is injective on `s`."},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Add Œ±] [inst_1 : LinearOrder Œ≤]\n  [self : NonarchimedeanHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a + b) ‚â§ max (‚Üëf a) (‚Üëf b)","name":"NonarchimedeanHomClass.map_add_le_max","isProp":true,"docString":"the image of a sum is less or equal than the maximum of the images. "},{"type":"‚àÄ {V : Type u_2} (Œ± : Type u_1) (G : SimpleGraph V) [inst : DecidableRel (SimpleGraph.Adj G)]\n  [inst_1 : MulZeroOneClass Œ±] [inst_2 : Nontrivial Œ±],\n  Matrix.IsAdjMatrix.toGraph\n      ((SimpleGraph.isAdjMatrix_adjMatrix Œ±\n            G=:Matrix.IsAdjMatrix (SimpleGraph.adjMatrix Œ± G))=:Matrix.IsAdjMatrix (SimpleGraph.adjMatrix Œ± G)) =\n    G","name":"SimpleGraph.toGraph_adjMatrix_eq","isProp":true,"docString":"The graph induced by the adjacency matrix of `G` is `G` itself. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} (w : f = g)\n  (h : Y ‚ü∂ Z), f ‚â´ h = g ‚â´ h","name":"CategoryTheory.eq_whisker","isProp":true,"docString":"postcompose an equation between morphisms by another morphism "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] (t : Multiset Œπ) (f‚ÇÅ : (a : Œπ) ‚Üí Set Œ±) (f‚ÇÇ : (a : Œπ) ‚Üí Set Œ±)\n  (hf : ‚àÄ (i : Œπ) (a : i ‚àà t), f‚ÇÅ i ‚äÜ f‚ÇÇ i), Multiset.sum (Multiset.map f‚ÇÅ t) ‚äÜ Multiset.sum (Multiset.map f‚ÇÇ t)","name":"Set.multiset_sum_subset_multiset_sum","isProp":true,"docString":"An n-ary version of `Set.add_subset_add`. "},{"type":"‚àÄ {p : (a : ZFSet) ‚Üí Prop} {x : ZFSet} (a : ZFSet.Hereditarily p x),\n  (p x : Prop) ‚àß (‚àÄ (y : ZFSet) (a : y ‚àà x), ZFSet.Hereditarily p y : Prop)","name":"ZFSet.Hereditarily.def","isProp":true,"docString":"**Alias** of the forward direction of `ZFSet.hereditarily_iff`."},{"type":"‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] [inst_2 : Nontrivial E] {x : E} {r : ‚Ñù},\n  (Set.Nonempty (Metric.sphere x r) : Prop) ‚Üî (0 ‚â§ r : Prop)","name":"NormedSpace.sphere_nonempty","isProp":true,"docString":"In a nontrivial real normed space, a sphere is nonempty if and only if its radius is\nnonnegative. "},{"type":"‚àÄ {Œπ : Type u_3} {X : Type u_4} {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  [inst_2 : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} {u : (a : Œ±) ‚Üí Œ≤} (hu : UniformInducing u),\n  (Equicontinuous F : Prop) ‚Üî (Equicontinuous ((fun (x : (a : Œ±) ‚Üí Œ≤) (x_1 : (a : X) ‚Üí Œ±) ‚Ü¶ x ‚àò x_1) u ‚àò F) : Prop)","name":"UniformInducing.equicontinuous_iff","isProp":true,"docString":"Given `u : Œ± ‚Üí Œ≤` a uniform inducing map, a family `ùìï : Œπ ‚Üí X ‚Üí Œ±` is equicontinuous iff the\nfamily `ùìï'`, obtained by precomposing each function of `ùìï` by `u`, is equicontinuous. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {œÉ : outParam (R ‚Üí+* S)} {M : outParam (Type u_4)} [inst_2 : TopologicalSpace M] [inst_3 : AddCommMonoid M]\n  {M‚ÇÇ : outParam (Type u_5)} [inst_4 : TopologicalSpace M‚ÇÇ] [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R M]\n  [inst_7 : Module S M‚ÇÇ] [self : ContinuousSemilinearMapClass F œÉ M M‚ÇÇ] (f : F), Continuous ‚Üëf","name":"ContinuousSemilinearMapClass.map_continuous","isProp":true,"docString":"Continuity "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Bornology Œ±] {s : Set Œ±} (a : Bornology.IsCobounded (s·∂ú)), Bornology.IsBounded s","name":"Bornology.IsCobounded.of_compl","isProp":true,"docString":"**Alias** of the forward direction of `Bornology.isCobounded_compl_iff`."},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (-a ‚â§ 0 : Prop) ‚Üî (0 ‚â§ a : Prop)","name":"Right.neg_nonpos_iff","isProp":true,"docString":"Uses `right` co(ntra)variant."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} {g : (a : E) ‚Üí Œ≤} (hf : StrictConvexOn ùïú s f) (hg : StrictConvexOn ùïú s g),\n  StrictConvexOn ùïú s (f ‚äî g)","name":"StrictConvexOn.sup","isProp":true,"docString":"The pointwise maximum of strictly convex functions is strictly convex. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±], 0‚Åª¬π = 0","name":"LinearOrderedCommGroupWithZero.inv_zero","isProp":true,"docString":"The inverse of `0` in a group with zero is `0`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (f : (a : ‚Ñï) ‚Üí Œ±) {m : ‚Ñï} {n : ‚Ñï} (h : m ‚â§ n),\n  dist (f m) (f n) ‚â§ Finset.sum (Finset.Ico m n) fun (i : ‚Ñï) ‚Ü¶ dist (f i) (f (i + 1))","name":"dist_le_Ico_sum_dist","isProp":true,"docString":"The triangle (polygon) inequality for sequences of points; `Finset.Ico` version. "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {M : (a : Œπ) ‚Üí Type u_2} {N : Type u_4} [dec_Œπ : DecidableEq Œπ] [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] [inst_3 : AddCommMonoid N]\n  [inst_4 : Module R N] ‚¶ÉœÜ : (Dfinsupp fun (i : Œπ) ‚Ü¶ M i) ‚Üí‚Çó[R] N‚¶Ñ ‚¶Éœà : (Dfinsupp fun (i : Œπ) ‚Ü¶ M i) ‚Üí‚Çó[R] N‚¶Ñ\n  (h : ‚àÄ (i : Œπ), LinearMap.comp œÜ (Dfinsupp.lsingle i) = LinearMap.comp œà (Dfinsupp.lsingle i)), œÜ = œà","name":"Dfinsupp.lhom_ext'","isProp":true,"docString":"Two `R`-linear maps from `Œ†‚ÇÄ i, M i` which agree on each `single i x` agree everywhere.\n\nSee note [partially-applied ext lemmas].\nAfter apply this lemma, if `M = R` then it suffices to verify `œÜ (single a 1) = œà (single a 1)`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {u : Set Œ±} (hs : IsPreconnected s) (hu : IsOpen u)\n  (h'u : Set.Nonempty (s ‚à© u)) (h : closure u ‚à© s ‚äÜ u), s ‚äÜ u","name":"IsPreconnected.subset_of_closure_inter_subset","isProp":true,"docString":"If a preconnected set `s` intersects an open set `u`, and limit points of `u` inside `s` are\ncontained in `u`, then the whole set `s` is contained in `u`. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P), ¬¨(p ‚àà ‚ä• : Prop)","name":"AffineSubspace.not_mem_bot","isProp":true,"docString":"No points are in `‚ä•`. "},{"type":"‚àÄ {Œ± : Type u_1} {n : Type u_2} [inst : CommSemigroup Œ±] [inst_1 : AddCommMonoid Œ±] [inst_2 : Fintype n]\n  [inst_3 : AddCommGroup n] (v : (a : n) ‚Üí Œ±) (w : (a : n) ‚Üí Œ±),\n  Matrix.mul (Matrix.circulant v) (Matrix.circulant w) = Matrix.mul (Matrix.circulant w) (Matrix.circulant v)","name":"Matrix.circulant_mul_comm","isProp":true,"docString":"Multiplication of circulant matrices commutes when the elements do. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] {a : Œ±} {b : Œ±} [inst_1 : IsRefl Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1] (a_1 : a = b),\n  b ‚äÜ a","name":"Eq.superset","isProp":true,"docString":"**Alias** of `superset_of_eq`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasEqualizers C] {X : C} {Y : C} [inst_3 : CategoryTheory.Simple Y] {f : X ‚ü∂ Y}\n  [inst_4 : CategoryTheory.Limits.HasImage f] (w : f ‚â† 0), CategoryTheory.Epi f","name":"CategoryTheory.epi_of_nonzero_to_simple","isProp":true,"docString":"A nonzero morphism `f` to a simple object is an epimorphism\n(assuming `f` has an image, and `C` has equalizers).\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (p : X = Y) (q : Y ‚ü∂ Z),\n  Eq.mpr ((congrArg (fun (W : C) ‚Ü¶ W ‚ü∂ Z) p=:(X ‚ü∂ Z) = (Y ‚ü∂ Z))=:(X ‚ü∂ Z) = (Y ‚ü∂ Z)) q = CategoryTheory.eqToHom p ‚â´ q","name":"CategoryTheory.congrArg_mpr_hom_left","isProp":true,"docString":"If we (perhaps unintentionally) perform equational rewriting on\nthe source object of a morphism,\nwe can replace the resulting `_.mpr f` term by a composition with an `eqToHom`.\n\nIt may be advisable to introduce any necessary `eqToHom` morphisms manually,\nrather than relying on this lemma firing.\n"},{"type":"‚àÄ {p : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (a_1 : a ‚â† 0) (a_2 : b ‚â† 0),\n  padicValNat p (a * b) = padicValNat p a + padicValNat p b","name":"padicValNat.mul","isProp":true,"docString":"A rewrite lemma for `padicValNat p (a * b)` with conditions `a ‚â† 0`, `b ‚â† 0`. "},{"type":"‚àÄ {M : Type u_1} {S : Type u_2} [inst : SubNegMonoid M] [inst_1 : SetLike S M] [hSM : AddSubgroupClass S M] {H : S}\n  {x : M} {y : M} (hx : x ‚àà H) (hy : y ‚àà H), x - y ‚àà H","name":"sub_mem","isProp":true,"docString":"An additive subgroup is closed under subtraction."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D) {A : C}\n  {A' : C} {B : C} {B' : C} [inst_2 : CategoryTheory.Limits.HasBinaryProduct A B]\n  [inst_3 : CategoryTheory.Limits.HasBinaryProduct A' B']\n  [inst_4 :\n    CategoryTheory.Limits.HasBinaryProduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) A)\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) B)]\n  [inst_5 :\n    CategoryTheory.Limits.HasBinaryProduct (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) A')\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) B')]\n  (f : A ‚ü∂ A') (g : B ‚ü∂ B'),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.Limits.prod.map f g) ‚â´\n      CategoryTheory.Limits.prodComparison F A' B' =\n    CategoryTheory.Limits.prodComparison F A B ‚â´\n      CategoryTheory.Limits.prod.map (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)\n        (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) g)","name":"CategoryTheory.Limits.prodComparison_natural","isProp":true,"docString":"Naturality of the `prodComparison` morphism in both arguments. "},{"type":"‚àÄ {Œ± : Type u} [inst : Semiring Œ±], IsSemiringHom id","name":"IsSemiringHom.id","isProp":true,"docString":"The identity map is a semiring homomorphism. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} (S : Type u_2) [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] (y : { x : R // x ‚àà M }), IsUnit (‚Üë(algebraMap R S) ‚Üëy)","name":"IsLocalization.map_units","isProp":true,"docString":"Everything in the image of `algebraMap` is a unit "},{"type":"‚àÄ {Œ± : Type u_1} {S : Set (Set Œ±)} (self : FiniteInter S) ‚¶És : Set Œ±‚¶Ñ (a : s ‚àà S) ‚¶Ét : Set Œ±‚¶Ñ (a : t ‚àà S), s ‚à© t ‚àà S","name":"FiniteInter.inter_mem","isProp":true,"docString":"`inter_mem` states that any two intersections of sets in `S` is also in `S`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : LocallyCompactSpace Œ≤],\n  Continuous fun (x : C(Œ±, Œ≤) √ó C(Œ≤, Œ≥)) ‚Ü¶ ContinuousMap.comp (Prod.snd x) (Prod.fst x)","name":"ContinuousMap.continuous_comp'","isProp":true,"docString":"Composition is a continuous map from `C(Œ±, Œ≤) √ó C(Œ≤, Œ≥)` to `C(Œ±, Œ≥)`, provided that `Œ≤` is\nlocally compact. This is Prop. 9 of Chap. X, ¬ß3, ‚Ññ. 4 of Bourbaki's *Topologie G√©n√©rale*. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  (T2Space Œ± : Prop) ‚Üî (‚àÄ {x : Œ±} {y : Œ±} (a : Filter.NeBot (nhds x ‚äì nhds y)), x = y : Prop)","name":"t2_iff_nhds","isProp":true,"docString":"A space is T‚ÇÇ iff the neighbourhoods of distinct points generate the bottom filter. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 ‚â§ a) (hb : 1 < b), 1 < a * b","name":"one_lt_mul_of_le_of_lt'","isProp":true,"docString":"**Alias** of `Left.one_lt_mul_of_le_of_lt`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±},\n  (Metric.Bounded (s ‚à™ t) : Prop) ‚Üî ((Metric.Bounded s : Prop) ‚àß (Metric.Bounded t : Prop) : Prop)","name":"Metric.bounded_union","isProp":true,"docString":"The union of two sets is bounded iff each of the sets is bounded. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhds a)\n  (hfs : closure (f '' s) ‚àà nhds (f a)), ContinuousAt f a","name":"StrictMonoOn.continuousAt_of_closure_image_mem_nhds","isProp":true,"docString":"If a function `f` with a densely ordered codomain is strictly monotone on a neighborhood of `a`\nand the closure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\ncontinuous at `a`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±}\n  {r : ‚Ñù} (hr : 0 < r) (K : ‚Ñù) (h : ‚àÄ (y : Œ±) (a : dist y x < r), dist (f y) (f x) ‚â§ K * dist y x), ContinuousAt f x","name":"continuousAt_of_locally_lipschitz","isProp":true,"docString":"If a function is locally Lipschitz around a point, then it is continuous at this point. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú} (hs : Convex ùïú s)\n  (hf :\n    ‚àÄ {x : ùïú} {y : ùïú} {z : ùïú} (a : x ‚àà s) (a : z ‚àà s) (a : x < y) (a : y < z),\n      (f y - f x) / (y - x) ‚â§ (f z - f y) / (z - y)),\n  ConvexOn ùïú s f","name":"convexOn_of_slope_mono_adjacent","isProp":true,"docString":"If for any three points `x < y < z`, the slope of the secant line of `f : ùïú ‚Üí ùïú` on `[x, y]` is\nless than the slope of the secant line of `f` on `[x, z]`, then `f` is convex. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : (a : Fin n) ‚Üí Œ±} {P : (a : (a : Fin n) ‚Üí Œ±) ‚Üí Prop} (hf : P f)\n  (h :\n    ‚àÄ (g : (a : Fin n) ‚Üí Œ±) (i : Fin n) (j : Fin n) (a : i < j) (a : g j < g i) (a : P g), P (g ‚àò ‚Üë(Equiv.swap i j))),\n  P (f ‚àò ‚Üë(Tuple.sort f))","name":"Tuple.bubble_sort_induction","isProp":true,"docString":"*Bubble sort induction*: Prove that the sorted version of `f` has some property `P`\nif `f` satsifies `P` and `P` is preserved when swapping two antitone values. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} (a : Œ±) (b : Œ≤) (i : Œπ),\n  Filter.map (Prod.map (fun (x : Œ±) ‚Ü¶ b) id) (Filter.coprod (Filter.principal {a}) (Filter.principal {i})) =\n    Filter.principal ({b} √óÀ¢ Set.univ)","name":"Filter.map_prod_map_const_id_principal_coprod_principal","isProp":true,"docString":"Characterization of the `filter.map` of the coproduct of two principal filters `ùìü {a}` and\n`ùìü {i}`, under the `prod.map` of two functions, respectively the constant function `Œª a, b` and the\nidentity function.  Together with the previous lemma,\n`map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality\nin the lemma `map_prod_map_coprod_le` can be strict. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : OrderedSemiring Œ±] [self : FloorSemiring Œ±] {a : Œ±} {n : ‚Ñï} (ha : 0 ‚â§ a),\n  (n ‚â§ FloorSemiring.floor a : Prop) ‚Üî (‚Üën ‚â§ a : Prop)","name":"FloorSemiring.gc_floor","isProp":true,"docString":"A natural number `n` is smaller than `FloorSemiring.floor a` iff its coercion to `Œ±` is\nsmaller than `a`."},{"type":"‚àÄ {Œ± : Type u_1} (G : SimpleGraph Œ±) {s : Set Œ±},\n  (SimpleGraph.IsClique G s : Prop) ‚Üî (SimpleGraph.induce s G = ‚ä§ : Prop)","name":"SimpleGraph.isClique_iff_induce_eq","isProp":true,"docString":"A clique is a set of vertices whose induced graph is complete. "},{"type":"‚àÄ {n : ‚Ñï} (p : Fin (n + 1)) (i : Fin n) (h : ‚ÜëFin.castSucc i < p), ‚Üë(Fin.succAbove p) i = ‚ÜëFin.castSucc i","name":"Fin.succAbove_below","isProp":true,"docString":"Embedding `i : Fin n` into `Fin (n + 1)` with a hole around `p : Fin (n + 1)`\nembeds `i` by `castSucc` when the resulting `i.castSucc < p`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {s : Set Œ±} {t : Set Œ≤}\n  {f : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥} {g : (a : Œ≤) ‚Üí Œ≤'} {f' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_right_comm : ‚àÄ (a : Œ±) (b : Œ≤), f a (g b) = g' (f' a b)), Set.image2 f s (g '' t) = g' '' Set.image2 f' s t","name":"Set.image_image2_right_comm","isProp":true,"docString":"Symmetric statement to `Set.image_image2_distrib_right`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±} (hs : s ‚àà Finset.shadow ùíú),\n  ‚àÉ (t : Finset Œ±), (t ‚àà ùíú : Prop) ‚àß (s ‚äÜ t : Prop)","name":"Finset.exists_subset_of_mem_shadow","isProp":true,"docString":"Being in the shadow of `ùíú` means we have a superset in `ùíú`. "},{"type":"‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a : B} {b : B}\n  (f : a ‚ü∂ b), ùüô a ‚â´ f = f","name":"CategoryTheory.Bicategory.Strict.id_comp","isProp":true,"docString":"Identity morphisms are left identities for composition. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} (d : (a : ‚Ñï) ‚Üí ENNReal)\n  (hf : ‚àÄ (n : ‚Ñï), edist (f n) (f (Nat.succ n)) ‚â§ d n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) (n : ‚Ñï),\n  edist (f n) a ‚â§ tsum fun (m : ‚Ñï) ‚Ü¶ d (n + m)","name":"edist_le_tsum_of_edist_le_of_tendsto","isProp":true,"docString":"If `edist (f n) (f (n+1))` is bounded above by a function `d : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû`,\nthen the distance from `f n` to the limit is bounded by `‚àë'_{k=n}^‚àû d k`. "},{"type":"‚àÄ {Œ± : Type u_1} {ùïú : Type u_2} [inst : NormedField ùïú] {l : Filter Œ±} {u : (a : Œ±) ‚Üí ùïú} {v : (a : Œ±) ‚Üí ùïú}\n  (h : u =O[l] v), u / v * v =·∂†[l] u","name":"Asymptotics.IsBigO.eventually_mul_div_cancel","isProp":true,"docString":"If `u = O(v)` along `l`, then `(u / v) * v = u` eventually at `l`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {s : Set Œ±} (hs : CompleteLattice.SetIndependent s),\n  Set.PairwiseDisjoint s id","name":"CompleteLattice.SetIndependent.pairwiseDisjoint","isProp":true,"docString":"If the elements of a set are independent, then any pair within that set is disjoint. "},{"type":"Finset.Nat.antidiagonal 0 = {(0, 0)}","name":"Finset.Nat.antidiagonal_zero","isProp":true,"docString":"The antidiagonal of `0` is the list `[(0, 0)]` "},{"type":"‚àÄ {L : Type v} [self : LieRing L] (x : L) (y : L) (z : L), ‚ÅÖx + y, z‚ÅÜ = ‚ÅÖx, z‚ÅÜ + ‚ÅÖy, z‚ÅÜ","name":"LieRing.add_lie","isProp":true,"docString":"A Lie ring bracket is additive in its first component. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {a : Œ±} {b : Œ±} {c : Œ±}\n  (h :\n    ‚àÄ (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : r a b) (a : r a c),\n      ‚àÉ (d : Œ±), (Relation.ReflGen r b d : Prop) ‚àß (Relation.ReflTransGen r c d : Prop))\n  (hab : Relation.ReflTransGen r a b) (hac : Relation.ReflTransGen r a c), Relation.Join (Relation.ReflTransGen r) b c","name":"Relation.church_rosser","isProp":true,"docString":"A sufficient condition for the Church-Rosser property. "},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï} {k : ‚Ñï}, ‚Üë(Nat.factorization (Nat.choose n k)) p ‚â§ Nat.log p n","name":"Nat.factorization_choose_le_log","isProp":true,"docString":"A logarithmic upper bound on the multiplicity of a prime in a binomial coefficient. "},{"type":"‚àÄ {R : Type u} {Œπ : Type w} (s : Finset Œπ) [inst : CommSemiring R] (f : (a : Œπ) ‚Üí Polynomial R)\n  (h : (Finset.prod s fun (i : Œπ) ‚Ü¶ Polynomial.leadingCoeff (f i)) ‚â† 0),\n  Polynomial.leadingCoeff (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) = Finset.prod s fun (i : Œπ) ‚Ü¶ Polynomial.leadingCoeff (f i)","name":"Polynomial.leadingCoeff_prod'","isProp":true,"docString":"The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients, provided that this product is nonzero.\n\nSee `Polynomial.leadingCoeff_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [self : HasDistribNeg Œ±] (x : Œ±) (y : Œ±), -x * y = -(x * y)","name":"HasDistribNeg.neg_mul","isProp":true,"docString":"Negation is left distributive over multiplication "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {a : Set Œ±} {b : Set Œ±} (f : (a : Œ±) ‚Üí Œ≤) (h : a ‚äÜ b), f '' a ‚äÜ f '' b","name":"Set.image_subset","isProp":true,"docString":"Image is monotone with respect to `‚äÜ`. See `Set.monotone_image` for the statement in\nterms of `‚â§`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ‚Ñï) [inst_2 : Fact (Nat.Prime p : Prop)],\n  (p ‚à£ ringChar R : Prop) ‚Üî (p ‚à£ Fintype.card R : Prop)","name":"prime_dvd_char_iff_dvd_card","isProp":true,"docString":"The prime divisors of the characteristic of a finite commutative ring are exactly\nthe prime divisors of its cardinality. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : NormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E]\n  {c : ùïú} (hc : 1 < ‚Äñc‚Äñ) {R : ‚Ñù} (hR : ‚Äñc‚Äñ < R) {F : Subspace ùïú E} (hFc : IsClosed ‚ÜëF)\n  (hF : ‚àÉ (x : E), ¬¨(x ‚àà F : Prop)), ‚àÉ (x‚ÇÄ : E), (‚Äñx‚ÇÄ‚Äñ ‚â§ R : Prop) ‚àß (‚àÄ (y : E) (a : y ‚àà F), 1 ‚â§ ‚Äñx‚ÇÄ - y‚Äñ : Prop)","name":"riesz_lemma_of_norm_lt","isProp":true,"docString":"A version of Riesz lemma: given a strict closed subspace `F`, one may find an element of norm `‚â§ R`\nwhich is at distance  at least `1` of every element of `F`. Here, `R` is any given constant\nstrictly larger than the norm of an element of norm `> 1`. For a version without an `R`, see\n`riesz_lemma`.\n\nSince we are considering a general nontrivially normed field, there may be a gap in possible norms\n(for instance no element of norm in `(1,2)`). Hence, we can not allow `R` arbitrarily close to `1`,\nand require `R > ‚Äñc‚Äñ` for some `c : ùïú` with norm `> 1`.\n"},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] {A : Matrix n n Œ±}\n  {B : Matrix n n Œ±} (h : Matrix.mul B A = 1), A‚Åª¬π = B","name":"Matrix.inv_eq_left_inv","isProp":true,"docString":"If matrix A is left invertible, then its inverse equals its left inverse. "},{"type":"‚àÄ {T : Type u‚ÇÅ} [inst : CategoryTheory.Category T] {X : T} {f : CategoryTheory.Under X} {g : CategoryTheory.Under X}\n  (k : f ‚ü∂ g) [hk : CategoryTheory.Epi (CategoryTheory.CommaMorphism.right k)], CategoryTheory.Epi k","name":"CategoryTheory.Under.epi_of_epi_right","isProp":true,"docString":"If `k.right` is a epimorphism, then `k` is a epimorphism. In other words, `Under.forget X` reflects\nepimorphisms.\nThe converse of `CategoryTheory.Under.epi_right_of_epi`.\n\nThis lemma is not an instance, to avoid loops in type class inference.\n"},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} (s : (a : Œπ) ‚Üí Set Œ±),\n  Filter.HasBasis (inf·µ¢ fun (i : Œπ) ‚Ü¶ Filter.principal (s i)) (fun (t : Set Œπ) ‚Ü¶ Set.Finite t) fun (t : Set Œπ) ‚Ü¶\n    Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà t) ‚Ü¶ s i","name":"Filter.hasBasis_inf·µ¢_principal_finite","isProp":true,"docString":"If `s : Œπ ‚Üí Set Œ±` is an indexed family of sets, then finite intersections of `s i` form a basis\nof `‚®Ö i, ùìü (s i)`.  "},{"type":"‚àÄ {Œπ : Type u_1} {Œπ' : Type u_2} {Œ± : Type u_3} [inst : Finite Œπ] [inst : Preorder Œπ']\n  [inst_1 : IsDirected Œπ' fun (x : Œπ') (x_1 : Œπ') ‚Ü¶ x ‚â§ x_1] [inst_2 : Nonempty Œπ'] {s : (a : Œπ) ‚Üí (a : Œπ') ‚Üí Set Œ±}\n  (hs : ‚àÄ (i : Œπ), Antitone (s i)),\n  (Set.inter·µ¢ fun (j : Œπ') ‚Ü¶ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ s i j) = Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (j : Œπ') ‚Ü¶ s i j","name":"Set.inter·µ¢_union·µ¢_of_antitone","isProp":true,"docString":"A decreasing intersection distributes over finite union. "},{"type":"‚àÄ {Œ± : Type u_1} {A : Finset Œ±} {B : Finset Œ±} (i : ‚Ñï) (h‚ÇÅ : i + Finset.card B ‚â§ Finset.card A) (h‚ÇÇ : B ‚äÜ A),\n  ‚àÉ (C : Finset Œ±), (B ‚äÜ C : Prop) ‚àß ((C ‚äÜ A : Prop) ‚àß (Finset.card C = i + Finset.card B : Prop) : Prop)","name":"Finset.exists_intermediate_set","isProp":true,"docString":"Given a set `A` and a set `B` inside it, we can shrink `A` to any appropriate size, and keep `B`\ninside it. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ±' : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_2} {Œ¥ : Type u_1} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±}\n  {t : Set Œ≤} {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ≤) ‚Üí (a : Œ±') ‚Üí Œ¥} {g' : (a : Œ±) ‚Üí Œ±'}\n  (h_antidistrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' b (g' a)), g '' Set.image2 f s t = Set.image2 f' t (g' '' s)","name":"Set.image_image2_antidistrib_right","isProp":true,"docString":"Symmetric statement to `Set.image_image2_right_anticomm`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {E : Type u‚ÇÉ}\n  [inst_2 : CategoryTheory.Category E] {F : C ‚•§ D} {G : D ‚•§ E} {H : C ‚•§ E} [inst_3 : CategoryTheory.Faithful H]\n  (h : F ‚ãô G ‚âÖ H), CategoryTheory.Faithful F","name":"CategoryTheory.Iso.faithful_of_comp","isProp":true,"docString":"**Alias** of `CategoryTheory.Faithful.of_comp_iso`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}\n  [inst_1 : CategoryTheory.Limits.HasPushout f g] [inst_2 : CategoryTheory.Epi f],\n  CategoryTheory.Epi CategoryTheory.Limits.pushout.inr","name":"CategoryTheory.Limits.pushout.inr_of_epi","isProp":true,"docString":"The pushout of an epimorphism is an epimorphism "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {F : C ‚•§ Type v‚ÇÅ} [self : CategoryTheory.Functor.Corepresentable F],\n  ‚àÉ (X : C·µí·µñ),\n    ‚àÉ (f : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.coyoneda) X ‚ü∂ F), CategoryTheory.IsIso f","name":"CategoryTheory.Functor.Corepresentable.has_corepresentation","isProp":true,"docString":"`Hom(X,-) ‚âÖ F` via `f` "},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí LinearOrder (Œ± i)]\n  [inst_1 : ‚àÄ (i : Œπ), IsWellOrder (Œ± i) fun (x : Œ± i) (x_1 : Œ± i) ‚Ü¶ x < x_1] [inst_2 : Finite Œπ]\n  (s : Set ((i : Œπ) ‚Üí Œ± i)), Set.IsPwo s","name":"Pi.isPwo","isProp":true,"docString":"A version of **Dickson's lemma** any subset of functions `Œ† s : œÉ, Œ± s` is partially well\nordered, when `œÉ` is a `Fintype` and each `Œ± s` is a linear well order.\nThis includes the classical case of Dickson's lemma that `‚Ñï ^ n` is a well partial order.\nSome generalizations would be possible based on this proof, to include cases where the target is\npartially well ordered, and also to consider the case of `Set.PartiallyWellOrderedOn` instead of\n`Set.IsPwo`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Set Œ≤) {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f),\n  Function.Injective (Set.restrictPreimage t f)","name":"Function.Injective.restrictPreimage","isProp":true,"docString":"**Alias** of `Set.restrictPreimage_injective`."},{"type":"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] {x : MvPolynomial œÉ R} {s : Set œÉ},\n  (x ‚àà Ideal.span (MvPolynomial.X '' s) : Prop) ‚Üî\n    (‚àÄ (m : œÉ ‚Üí‚ÇÄ ‚Ñï) (a : m ‚àà MvPolynomial.support x), ‚àÉ (i : œÉ), (i ‚àà s : Prop) ‚àß (‚Üëm i ‚â† 0 : Prop) : Prop)","name":"MvPolynomial.mem_ideal_span_X_image","isProp":true,"docString":"`x` is in a monomial ideal generated by variables `X` iff every element of of its support\nhas a component in `s`. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} (v : (a : Œπ) ‚Üí M) (i : LinearIndependent R v) (w : Set M) [inst_4 : Fintype ‚Üëw]\n  (s : Set.range v ‚â§ ‚Üë(Submodule.span R w)), Cardinal.mk Œπ ‚â§ ‚Üë(Fintype.card ‚Üëw)","name":"linearIndependent_le_span'","isProp":true,"docString":"If `R` satisfies the strong rank condition,\nthen for any linearly independent family `v : Œπ ‚Üí M`\ncontained in the span of some finite `w : Set M`,\nthe cardinality of `Œπ` is bounded by the cardinality of `w`.\n"},{"type":"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] {M : Matrix n n R}\n  {i : n} {j : n} (i_ne_j : i ‚â† j) (hij : M i = M j), Matrix.det M = 0","name":"Matrix.det_zero_of_row_eq","isProp":true,"docString":"If a matrix has a repeated row, the determinant will be zero. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (S : Subsemigroup M) {x : M} {y : M} (a : x ‚àà S) (a : y ‚àà S), x * y ‚àà S","name":"Subsemigroup.mul_mem","isProp":true,"docString":"A subsemigroup is closed under multiplication. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s) {a : ùïú} {b : ùïú} (ha : 0 ‚â§ a) (hb : 0 < b) (hab : a + b = 1),\n  a ‚Ä¢ closure s + b ‚Ä¢ interior s ‚äÜ interior s","name":"Convex.combo_closure_interior_subset_interior","isProp":true,"docString":"If `s` is a convex set, then `a ‚Ä¢ closure s + b ‚Ä¢ interior s ‚äÜ interior s` for all `0 ‚â§ a`,\n`0 < b`, `a + b = 1`. See also `Convex.combo_self_interior_subset_interior` for a weaker version. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (f : AddHom M N) {x : M} {y : M} (h : x = y),\n  ‚Üëf x = ‚Üëf y","name":"AddHom.congr_arg","isProp":true,"docString":"Deprecated: use `FunLike.congr_arg` instead."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ} {p' : Filter Œ±},\n  (TendstoUniformlyOnFilter F f p p' : Prop) ‚Üî\n    (Filter.Tendsto (fun (q : Œπ √ó Œ±) ‚Ü¶ (f (Prod.snd q), F (Prod.fst q) (Prod.snd q))) (Filter.prod p p')\n        (uniformity Œ≤) :\n      Prop)","name":"tendstoUniformlyOnFilter_iff_tendsto","isProp":true,"docString":"A sequence of functions `F‚Çô` converges uniformly on a filter `p'` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √ó·∂† p'` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `p'`.\n"},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (self : AddHom M N) (x : M) (y : M),\n  AddHom.toFun self (x + y) = AddHom.toFun self x + AddHom.toFun self y","name":"AddHom.map_add'","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hab : a < b) (hbc : b = c), a < c","name":"LT.lt.trans_eq","isProp":true,"docString":"**Alias** of `lt_of_lt_of_eq`."},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {F : Type v} [inst_1 : DivisionRing F] [inst_2 : MulSemiringAction M F] (x : M)\n  (m : F), x ‚Ä¢ m‚Åª¬π = (x ‚Ä¢ m)‚Åª¬π","name":"smul_inv''","isProp":true,"docString":"Note that `smul_inv'` refers to the group case, and `smul_inv` has an additional inverse\non `x`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedCommGroup Œ±] {n : ‚Ñ§} {a : Œ±} {b : Œ±} (hn : n ‚â† 0),\n  (a ^ n = b ^ n : Prop) ‚Üî (a = b : Prop)","name":"zpow_eq_zpow_iff'","isProp":true,"docString":"Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and\n`zsmul_lt_zsmul_iff'`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Monoid Œ≤] (f : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Œ≤) (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop)\n  [t : IsTotal Œ± r] (hswap : ‚àÄ (a : Œ±) (b : Œ±), f a b * f b a = 1)\n  (hmul : ‚àÄ {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : r a b) (a_2 : r b c), f a c = f a b * f b c) (a : Œ±) (b : Œ±) (c : Œ±),\n  f a c = f a b * f b c","name":"multiplicative_of_isTotal","isProp":true,"docString":"If a binary function from a type equipped with a total relation `r` to a monoid is\nanti-symmetric (i.e. satisfies `f a b * f b a = 1`), in order to show it is multiplicative\n(i.e. satisfies `f a c = f a b * f b c`), we may assume `r a b` and `r b c` are satisfied. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (H‚ÇÅ : AddSubgroup G) (H‚ÇÇ : AddSubgroup G) (hH‚ÇÅ : AddSubgroup.Normal H‚ÇÅ)\n  (hH‚ÇÇ : AddSubgroup.Normal H‚ÇÇ) (hdis : Disjoint H‚ÇÅ H‚ÇÇ) (x : G) (y : G) (hx : x ‚àà H‚ÇÅ) (hy : y ‚àà H‚ÇÇ), AddCommute x y","name":"AddSubgroup.commute_of_normal_of_disjoint","isProp":true,"docString":"Elements of disjoint, normal subgroups commute."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} [self : CategoryTheory.Limits.HasImage f],\n  Nonempty (CategoryTheory.Limits.ImageFactorisation f)","name":"CategoryTheory.Limits.HasImage.exists_image","isProp":true,"docString":"`has_image f` means that there exists an image factorisation of `f`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin Alexandroff.infty ({Alexandroff.infty}·∂ú))","name":"Alexandroff.nhdsWithin_compl_infty_neBot","isProp":true,"docString":"If `X` is a non-compact space, then `‚àû` is not an isolated point of `Alexandroff X`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type u_1} {f : (a : Œπ) ‚Üí Set Œ±} (hf : LocallyFinite f) {s : Set Œ±}\n  (hs : IsCompact s), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ Set.Nonempty (f i ‚à© s))","name":"LocallyFinite.finite_nonempty_inter_compact","isProp":true,"docString":"If `s` is a compact set in a topological space `Œ±` and `f : Œπ ‚Üí Set Œ±` is a locally finite\nfamily of sets, then `f i ‚à© s` is nonempty only for a finitely many `i`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] (a : Œ±),\n  Finset.min' {a} ((Finset.singleton_nonempty a=:Finset.Nonempty {a})=:Finset.Nonempty {a}) = a","name":"Finset.min'_singleton","isProp":true,"docString":"`{a}.min' _` is `a`. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  (h : Function.Injective ‚Üë(algebraMap R A)) [inst : CharZero R], CharZero A","name":"charZero_of_injective_algebraMap","isProp":true,"docString":"If the algebra map `R ‚Üí+* A` is injective and `R` has characteristic zero then so does `A`. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {m : M}\n  {s : Set M},\n  (m ‚àà Submodule.span R s : Prop) ‚Üî\n    (‚àÉ (c : M ‚Üí‚ÇÄ R), (‚Üë(Finsupp.support c) ‚äÜ s : Prop) ‚àß ((Finsupp.sum c fun (mi : M) (r : R) ‚Ü¶ r ‚Ä¢ mi) = m : Prop) :\n      Prop)","name":"mem_span_set","isProp":true,"docString":"An element `m ‚àà M` is contained in the `R`-submodule spanned by a set `s ‚äÜ M`, if and only if\n`m` can be written as a finite `R`-linear combination of elements of `s`.\nThe implementation uses `Finsupp.sum`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {s : Set M} {S : AddSubsemigroup M},\n  (AddSubsemigroup.closure s ‚â§ S : Prop) ‚Üî (s ‚äÜ ‚ÜëS : Prop)","name":"AddSubsemigroup.closure_le","isProp":true,"docString":"An additive subsemigroup `S` includes `closure s` if and only if it includes `s`"},{"type":"‚àÄ {x : ‚Ñï} {k : ‚Ñï} {l : ‚Ñï} (w : 1 < x), (x ^ k ‚à£ x ^ l : Prop) ‚Üî (k ‚â§ l : Prop)","name":"Nat.pow_dvd_pow_iff_le_right","isProp":true,"docString":"If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K : Set G} {U : Set G}\n  (hK : IsCompact K) (hU : IsOpen U) (hKU : K ‚äÜ U), ‚àÉ (V : Set G), (V ‚àà nhds 1 : Prop) ‚àß (V * K ‚äÜ U : Prop)","name":"compact_open_separated_mul_left","isProp":true,"docString":"Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of `1`\nsuch that `V * K ‚äÜ U`. "},{"type":"‚àÄ {n : ‚Ñï} {i : Fin (n + 1)} {j : Fin (n + 1)} (H : i ‚â§ j),\n  SimplexCategory.œÉ (‚ÜëFin.castSucc i) ‚â´ SimplexCategory.œÉ j = SimplexCategory.œÉ (Fin.succ j) ‚â´ SimplexCategory.œÉ i","name":"SimplexCategory.œÉ_comp_œÉ","isProp":true,"docString":"The fifth simplicial identity "},{"type":"‚àÄ {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Infinite R] {œÉ : Type u_1} {p : MvPolynomial œÉ R}\n  {q : MvPolynomial œÉ R} (h : ‚àÄ (x : (a : œÉ) ‚Üí R), ‚Üë(MvPolynomial.eval x) p = ‚Üë(MvPolynomial.eval x) q), p = q","name":"MvPolynomial.funext","isProp":true,"docString":"Two multivariate polynomials over an infinite integral domain are equal\nif they are equal upon evaluating them on an arbitrary assignment of the variables. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] [inst_1 : IsIrrefl Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  (a_1 : a ‚äÇ b), b ‚â† a","name":"HasSSubset.SSubset.ne'","isProp":true,"docString":"**Alias** of `ne_of_ssuperset`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : (a : Œ±) ‚Üí Œ≤),\n  Function.Injective\n    (Quotient.lift f\n      (fun (x : Œ±) ‚Ü¶ (_ : ‚àÄ (x_1 : Œ±) (h : x ‚âà x_1), x ‚âà x_1)=:‚àÄ (x : Œ±) (x_1 : Œ±) (h : x ‚âà x_1), x ‚âà x_1))","name":"Setoid.ker_lift_injective","isProp":true,"docString":"Given a map f from Œ± to Œ≤, the natural map from the quotient of Œ± by the kernel of f is\ninjective. "},{"type":"List.Nat.antidiagonal 0 = [(0, 0)]","name":"List.Nat.antidiagonal_zero","isProp":true,"docString":"The antidiagonal of `0` is the list `[(0, 0)]` "},{"type":"‚àÄ {Œ± : Type u} [self : Lattice Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : a ‚â§ b) (a_2 : a ‚â§ c), a ‚â§ b ‚äì c","name":"Lattice.le_inf","isProp":true,"docString":"The infimum is the *greatest* lower bound "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±] {s : Set (Œ± √ó Œ±)} (hs : s ‚àà uniformity Œ±),\n  Filter.Eventually (fun (t : Set (Œ± √ó Œ±)) ‚Ü¶ compRel t t ‚äÜ s) (Filter.smallSets (uniformity Œ±))","name":"eventually_uniformity_comp_subset","isProp":true,"docString":"If `s ‚àà ùì§ Œ±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ùì§ Œ±`,\nwe have `t ‚óã t ‚äÜ s`. "},{"type":"‚àÄ {R : Type u_1} [inst : Add R] {c : R} (self : IsAddRegular c), IsAddRightRegular c","name":"IsAddRegular.right","isProp":true,"docString":"An add-regular element `c` is right-regular "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s‚ÇÅ : AffineSubspace k P} {s‚ÇÇ : AffineSubspace k P} {p : P} (h‚ÇÅ : p ‚àà s‚ÇÅ) (h‚ÇÇ : p ‚àà s‚ÇÇ),\n  (s‚ÇÅ = s‚ÇÇ : Prop) ‚Üî (AffineSubspace.direction s‚ÇÅ = AffineSubspace.direction s‚ÇÇ : Prop)","name":"AffineSubspace.eq_iff_direction_eq_of_mem","isProp":true,"docString":"Two affine subspaces with nonempty intersection are equal if and only if their directions are\nequal. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasPullbacks C] {ùí¢ : Set C}\n  [inst_2 : Small ‚Üëùí¢] (hùí¢ : CategoryTheory.IsDetecting ùí¢), CategoryTheory.WellPowered C","name":"CategoryTheory.wellPowered_of_isDetecting","isProp":true,"docString":"A category with pullbacks and a small detecting set is well-powered. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {Œπ : Type v} (hs : IsCompact s) (Z : (a : Œπ) ‚Üí Set Œ±)\n  (hZc : ‚àÄ (i : Œπ), IsClosed (Z i)) (hsZ : (s ‚à© Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Z i) = ‚àÖ),\n  ‚àÉ (t : Finset Œπ), (s ‚à© Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà t) ‚Ü¶ Z i) = ‚àÖ","name":"IsCompact.elim_finite_subfamily_closed","isProp":true,"docString":"For every family of closed sets whose intersection avoids a compact set,\nthere exists a finite subfamily whose intersection avoids this compact set. "},{"type":"‚àÄ {a : ‚Ñù} (ha : a ‚â† 0), Filter.Tendsto (‚Üë(‚Üë(zmultiplesHom ‚Ñù) a)) Filter.cofinite (Filter.cocompact ‚Ñù)","name":"Int.tendsto_zmultiplesHom_cofinite","isProp":true,"docString":"For nonzero `a`, the \"multiples of `a`\" map `zmultiples_hom` from `‚Ñ§` to `‚Ñù` is discrete, i.e.\ninverse images of compact sets are finite. "},{"type":"‚àÄ {n : ‚Ñï} (R : Type u_1) [inst : Ring R] [inst_1 : NeZero n], Nat.cast ‚àò ZMod.val = ZMod.cast","name":"ZMod.nat_cast_comp_val","isProp":true,"docString":"The coercions are respectively `Nat.cast` and `ZMod.cast`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {fa : (a : Œ±) ‚Üí Œ±} {fb : (a : Œ≤) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} (h : Function.Semiconj g fa fb),\n  Set.MapsTo g (Function.fixedPoints fa) (Function.fixedPoints fb)","name":"Function.Semiconj.mapsTo_fixedPoints","isProp":true,"docString":"If `g` semiconjugates `fa` to `fb`, then it sends fixed points of `fa` to fixed points\nof `fb`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} {p : Filter Œπ} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí UniformFun Œ± Œ≤}\n  {f : UniformFun Œ± Œ≤}, (Filter.Tendsto F p (nhds f) : Prop) ‚Üî (TendstoUniformly F f p : Prop)","name":"UniformFun.tendsto_iff_tendstoUniformly","isProp":true,"docString":"The topology of uniform convergence indeed gives the same notion of convergence as\n`TendstoUniformly`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Setoid Œ±] {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n  {H : ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ±) (a : a‚ÇÅ ‚âà a‚ÇÇ) (a : b‚ÇÅ ‚âà b‚ÇÇ), (r a‚ÇÅ b‚ÇÅ : Prop) = (r a‚ÇÇ b‚ÇÇ : Prop)},\n  (WellFounded (Quotient.lift‚ÇÇ r H) : Prop) ‚Üî (WellFounded r : Prop)","name":"wellFounded_lift‚ÇÇ_iff","isProp":true,"docString":"A relation is well founded iff its lift to a quotient is. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] [inst_1 : Monoid M] {S : Set (MonoidAlgebra R M)}\n  (hS : Algebra.adjoin R S = ‚ä§),\n  Algebra.adjoin R\n      (‚Üë(MonoidAlgebra.of R M) ''\n        Set.union·µ¢ fun (f : MonoidAlgebra R M) ‚Ü¶ Set.union·µ¢ fun (h : f ‚àà S) ‚Ü¶ ‚Üë(Finsupp.support f)) =\n    ‚ä§","name":"MonoidAlgebra.support_gen_of_gen'","isProp":true,"docString":"If a set `S` generates, as algebra, `MonoidAlgebra R M`, then the image of the union of the\nsupports of elements of `S` generates `MonoidAlgebra R M`. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {a‚ÇÅ : Œ≥} {a‚ÇÇ : Œ≥} {s : Set Œ≥} {t : Set Œ≥} (hs : IsGLB s a‚ÇÅ) (ht : IsGLB t a‚ÇÇ),\n  IsGLB (s ‚à™ t) (a‚ÇÅ ‚äì a‚ÇÇ)","name":"IsGLB.union","isProp":true,"docString":"If `a` is the greatest lower bound of `s` and `b` is the greatest lower bound of `t`,\nthen `a ‚äì b` is the greatest lower bound of `s ‚à™ t`. "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±],\n  (Filter.lift' (uniformity Œ±) fun (s : Set (Œ± √ó Œ±)) ‚Ü¶ compRel s (compRel s s)) ‚â§ uniformity Œ±","name":"comp_le_uniformity3","isProp":true,"docString":"See also `comp3_mem_uniformity`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {x‚ÇÅ : R} {x‚ÇÇ : R} {y‚ÇÅ : R} {y‚ÇÇ : R},\n  (x‚ÇÅ ^ 2 + x‚ÇÇ ^ 2) * (y‚ÇÅ ^ 2 + y‚ÇÇ ^ 2) = (x‚ÇÅ * y‚ÇÅ - x‚ÇÇ * y‚ÇÇ) ^ 2 + (x‚ÇÅ * y‚ÇÇ + x‚ÇÇ * y‚ÇÅ) ^ 2","name":"sq_add_sq_mul_sq_add_sq","isProp":true,"docString":"Brahmagupta-Fibonacci identity or Diophantus identity, see\n<https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity>.\n\nThis sign choice here corresponds to the signs obtained by multiplying two complex numbers.\n"},{"type":"‚àÄ {Œ± : Type u_2} {G : Type u_1} {s : Set Œ±} [inst : DivisionCommMonoid G] (f : (a : Œ±) ‚Üí G) (g : (a : Œ±) ‚Üí G)\n  (hs : Set.Finite s),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i / g i) =\n    (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) / finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ g i","name":"finprod_mem_div_distrib","isProp":true,"docString":"Given a finite set `s`, the product of `f i / g i` over `i ‚àà s` equals the product of `f i`\nover `i ‚àà s` divided by the product of `g i` over `i ‚àà s`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] {I : Set Œ≤} {s : (a : Œ≤) ‚Üí Set Œ±} (H : Set.Finite I),\n  (Metric.Bounded (Set.union·µ¢ fun (i : Œ≤) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà I) ‚Ü¶ s i) : Prop) ‚Üî\n    (‚àÄ (i : Œ≤) (a : i ‚àà I), Metric.Bounded (s i) : Prop)","name":"Metric.bounded_bunion·µ¢","isProp":true,"docString":"A finite union of bounded sets is bounded "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} (hc : Finset.card s ‚â§ 1) {f : (a : Œ±) ‚Üí Œ≤} {b : Œ≤}\n  (h : (Finset.sum s fun (x : Œ±) ‚Ü¶ f x) = b) (x : Œ±) (a : x ‚àà s), f x = b","name":"Finset.eq_of_card_le_one_of_sum_eq","isProp":true,"docString":"If a sum of a `Finset` of size at most 1 has a given\nvalue, so do the terms in that sum."},{"type":"‚àÄ {Œ± : Type u} {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J]\n  [inst_2 : SemilatticeSup Œ±] [inst_3 : OrderBot Œ±] (F : J ‚•§ Œ±),\n  CategoryTheory.Limits.colimit F = Finset.sup Finset.univ (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F))","name":"CategoryTheory.Limits.CompleteLattice.finite_colimit_eq_finset_univ_sup","isProp":true,"docString":"The colimit of a functor from a finite diagram into a `SemilatticeSup` with `OrderBot`\nis the supremum of the objects in the image.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {K : NNReal}\n  {f : (a : Œ±) ‚Üí Œ≤} (a : ‚àÄ (x : Œ±) (y : Œ±), nndist x y ‚â§ K * nndist (f x) (f y)), AntilipschitzWith K f","name":"AntilipschitzWith.of_le_mul_nndist","isProp":true,"docString":"**Alias** of the reverse direction of `antilipschitzWith_iff_le_mul_nndist`."},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Group Œ±] [inst_1 : OrderedAddCommMonoid Œ≤]\n  [self : GroupNormClass F Œ± Œ≤] (f : F) {a : Œ±} (a_1 : ‚Üëf a = 0), a = 1","name":"GroupNormClass.eq_one_of_map_eq_zero","isProp":true,"docString":"The argument is one if its image under the map is zero. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {k : Œ±} (hk : CompleteLattice.IsCompactElement k) {s : Set Œ±}\n  (hemp : Set.Nonempty s) (hdir : DirectedOn (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) s)\n  (hbelow : ‚àÄ (x : Œ±) (a : x ‚àà s), x < k), sup‚Çõ s < k","name":"CompleteLattice.IsCompactElement.directed_sup‚Çõ_lt_of_lt","isProp":true,"docString":"A compact element `k` has the property that any directed set lying strictly below `k` has\nits `sup‚Çõ` strictly below `k`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {s : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤}\n  (hs : IsCompact s) (hf : ContinuousOn f s), UniformContinuousOn f s","name":"IsCompact.uniformContinuousOn_of_continuous","isProp":true,"docString":"Heine-Cantor: a continuous function on a compact set of a uniform space is uniformly\ncontinuous. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Monoid Œ±] [inst_2 : ContinuousMul Œ±], ContinuousMul Œ±À£","name":"Units.instContinuousMulUnitsInstTopologicalSpaceUnitsToMulInstMulOneClassUnits","isProp":true,"docString":"If multiplication on a monoid is continuous, then multiplication on the units of the monoid,\nwith respect to the induced topology, is continuous.\n\nInversion is also continuous, but we register this in a later file, `Topology.Algebra.Group`,\nbecause the predicate `ContinuousInv` has not yet been defined. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {A : Type v} [inst_1 : Semiring A] [inst_2 : Algebra R A] (M : Submodule R A)\n  {C : (n : ‚Ñï) ‚Üí (x : A) ‚Üí (a : x ‚àà M ^ n) ‚Üí Prop}\n  (hr :\n    ‚àÄ (r : R),\n      C 0 (‚Üë(algebraMap R A) r) ((Submodule.algebraMap_mem r=:‚Üë(algebraMap R A) r ‚àà 1)=:‚Üë(algebraMap R A) r ‚àà 1))\n  (hadd :\n    ‚àÄ (x : A) (y : A) (i : ‚Ñï) (hx : x ‚àà M ^ i) (hy : y ‚àà M ^ i) (a : C i x hx) (a : C i y hy),\n      C i (x + y) ((add_mem hx hy=:x + y ‚àà M ^ i)=:x + y ‚àà M ^ i))\n  (hmul :\n    ‚àÄ (m : A) (hm : m ‚àà M) (i : ‚Ñï) (x : A) (hx : x ‚àà M ^ i) (a : C i x hx),\n      C (Nat.succ i) (m * x) ((Submodule.mul_mem_mul hm hx=:m * x ‚àà M * npowRec i M)=:m * x ‚àà M * npowRec i M))\n  {x : A} {n : ‚Ñï} (hx : x ‚àà M ^ n), C n x hx","name":"Submodule.pow_induction_on_left'","isProp":true,"docString":"Dependent version of `Submodule.pow_induction_on_left`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Antitone f) {x : Œ±}\n  [inst_4 : TopologicalSpace Œ±] [inst_5 : OrderTopology Œ±],\n  (ContinuousWithinAt f (Set.Ioi x) x : Prop) ‚Üî (Function.rightLim f x = f x : Prop)","name":"Antitone.continuousWithinAt_Ioi_iff_rightLim_eq","isProp":true,"docString":"An antitone function is continuous to the right at a point if and only if its right limit\ncoincides with the value of the function. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] (f : V ‚Üí‚Çó[K] V‚ÇÇ) (w : Function.Surjective ‚Üëf)\n  [inst_5 : FiniteDimensional K V], FiniteDimensional K V‚ÇÇ","name":"FiniteDimensional.of_surjective","isProp":true,"docString":"If the domain of a surjective linear map is finite dimensional, the codomain must be as well. "},{"type":"‚àÄ {Œ± : Sort u_1} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop), Function.Surjective (Quot.mk r)","name":"surjective_quot_mk","isProp":true,"docString":"`Quot.mk r` is a surjective function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {p : (a : Œ±) ‚Üí Prop},\n  (Filter.Eventually (fun (x : Œ±) ‚Ü¶ p x) (residual Œ±) : Prop) ‚Üî\n    (‚àÉ (t : Set Œ±), (IsGŒ¥ t : Prop) ‚àß ((Dense t : Prop) ‚àß (‚àÄ (x : Œ±) (a : x ‚àà t), p x : Prop) : Prop) : Prop)","name":"eventually_residual","isProp":true,"docString":"A property holds on a residual (comeagre) set if and only if it holds on some dense `GŒ¥` set. "},{"type":"‚àÄ {P : Type u_1} [inst : Preorder P] [inst_1 : OrderTop P] {F : Order.PFilter P}, ‚ä§ ‚àà F","name":"Order.PFilter.top_mem","isProp":true,"docString":"A specific witness of `pfilter.nonempty` when `P` has a top element. "},{"type":"‚àÄ {Œ± : Sort u} [self : Countable Œ±], ‚àÉ (f : (a : Œ±) ‚Üí ‚Ñï), Function.Injective f","name":"Countable.exists_injective_nat'","isProp":true,"docString":"A type `Œ±` is countable if there exists an injective map `Œ± ‚Üí ‚Ñï`. "},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {f : (a : X) ‚Üí Y}\n  {x : X} (h : ‚àÉ (y : Y), Filter.Tendsto f (nhdsWithin x A) (nhds y)),\n  Filter.Tendsto f (nhdsWithin x A) (nhds (extendFrom A f x))","name":"tendsto_extendFrom","isProp":true,"docString":"If `f` converges to some `y` as `x` tends to `x‚ÇÄ` within `A`,\nthen `f` tends to `extendFrom A f x` as `x` tends to `x‚ÇÄ`. "},{"type":"‚àÄ {Œ± : Type u_1} (S : Set (Setoid Œ±)),\n  sup‚Çõ S = EqvGen.Setoid fun (x : Œ±) (y : Œ±) ‚Ü¶ ‚àÉ (r : Setoid Œ±), (r ‚àà S : Prop) ‚àß (Setoid.Rel r x y : Prop)","name":"Setoid.sup‚Çõ_eq_eqvGen","isProp":true,"docString":"The supremum of a set S of equivalence relations is the equivalence closure of the binary\nrelation `there exists r ‚àà S relating x and y`. "},{"type":"‚àÄ {Œ± : Type u_1} (s : Multiset Œ±) (p : (a : Œ±) ‚Üí Prop) [inst : DecidablePred p],\n  Multiset.count (True : Prop) (Multiset.map p s) = ‚ÜëMultiset.card (Multiset.filter p s)","name":"Multiset.map_count_True_eq_filter_card","isProp":true,"docString":"Mapping a multiset through a predicate and counting the `True`s yields the cardinality of the set\nfiltered by the predicate. Note that this uses the notion of a multiset of `Prop`s - due to the\ndecidability requirements of `count`, the decidability instance on the LHS is different from the\nRHS. In particular, the decidability instance on the left leaks `Classical.decEq`.\nSee [here](https://github.com/leanprover-community/mathlib/pull/11306#discussion_r782286812)\nfor more discussion.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 ‚â§ a) (hb : 0 ‚â§ b), 0 ‚â§ a + b","name":"add_nonneg","isProp":true,"docString":"**Alias** of `Left.add_nonneg`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] (x : Œ±) (y : Œ±), edist x y < ‚ä§","name":"edist_lt_top","isProp":true,"docString":"In a pseudometric space, the extended distance is always finite"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {a : Œ±} {u : Œ±À£}, ‚Üëu ‚à£ a","name":"Units.coe_dvd","isProp":true,"docString":"Elements of the unit group of a monoid represented as elements of the monoid\ndivide any element of the monoid. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), 1 ‚àà s","name":"Subring.one_mem","isProp":true,"docString":"A subring contains the ring's 1. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryProducts C], CategoryTheory.Limits.HasBinaryBiproducts C","name":"CategoryTheory.Limits.HasBinaryBiproducts.of_hasBinaryProducts","isProp":true,"docString":"In a preadditive category, if all binary products exist, then all binary biproducts exist. "},{"type":"‚àÄ {Œ± : Type u_1} (self : MeasurableSpace Œ±), MeasurableSpace.MeasurableSet' self ‚àÖ","name":"MeasurableSpace.measurableSet_empty","isProp":true,"docString":"The empty set is a measurable set. Use `MeasurableSet.empty` instead. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (K : AddSubgroup G) {k : Set G},\n  (AddSubgroup.closure k ‚â§ K : Prop) ‚Üî (k ‚äÜ ‚ÜëK : Prop)","name":"AddSubgroup.closure_le","isProp":true,"docString":"An additive subgroup `K` includes `closure k` if and only if it includes `k`"},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {c : AddCon M} {f : M ‚Üí+ P}\n  (H : c ‚â§ AddCon.ker f) (g : AddCon.Quotient c ‚Üí+ P) (Hg : AddMonoidHom.comp g (AddCon.mk' c) = f),\n  g = AddCon.lift c f H","name":"AddCon.lift_unique","isProp":true,"docString":"The uniqueness part of the universal property for quotients of `AddMonoid`s."},{"type":"‚àÄ {Œ± : Type u} [inst : AddMonoid Œ±] (self : AddUnits Œ±), ‚Üëself + AddUnits.neg self = 0","name":"AddUnits.val_neg","isProp":true,"docString":"`neg` is the right additive inverse of `val` in the base `AddMonoid`. "},{"type":"‚àÄ {S : Type u_1} {G : Type u_2} [inst : Neg G] [inst_1 : SetLike S G] [self : NegMemClass S G] {s : S} {x : G}\n  (a : x ‚àà s), -x ‚àà s","name":"NegMemClass.neg_mem","isProp":true,"docString":"`s` is closed under negation "},{"type":"‚àÄ {k : Type u_1} {V : Type u_3} {P : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] [inst_4 : Nontrivial k] {s : Set P} {p : P} (hp : p ‚àà s) (w : (a : ‚Üës) ‚Üí kÀ£),\n  affineSpan k (Set.range fun (q : ‚Üës) ‚Ü¶ ‚Üë(AffineMap.lineMap p ‚Üëq) ‚Üë(w q)) = affineSpan k s","name":"affineSpan_eq_affineSpan_lineMap_units","isProp":true,"docString":"Given a set of points, together with a chosen base point in this set, if we affinely transport\nall other members of the set along the line joining them to this base point, the affine span is\nunchanged. "},{"type":"‚àÄ {Œ± : Type u_1} {a : (ii : ‚Ñï) √ó ((a : Fin ii) ‚Üí Œ±)} {b : (ii : ‚Ñï) √ó ((a : Fin ii) ‚Üí Œ±)},\n  (a = b : Prop) ‚Üî (‚àÉ (h : Sigma.fst a = Sigma.fst b), Sigma.snd a = Sigma.snd b ‚àò ‚Üë(Fin.cast h) : Prop)","name":"Fin.sigma_eq_iff_eq_comp_cast","isProp":true,"docString":"`Fin.sigma_eq_of_eq_comp_cast` as an `iff`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : CompleteLinearOrder R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R]\n  [inst_3 : CompleteLinearOrder S] [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {F : Filter R}\n  [inst_6 : Filter.NeBot F] {f : (a : R) ‚Üí S} (f_decr : Antitone f) (f_cont : ContinuousAt f (Filter.liminf‚Çõ F)),\n  f (Filter.liminf‚Çõ F) = Filter.limsup f F","name":"Antitone.map_liminf‚Çõ_of_continuousAt","isProp":true,"docString":"An antitone function between complete linear ordered spaces sends a `Filter.liminf‚Çõ`\nto the `Filter.limsup` of the image if it is continuous at the `liminf‚Çõ`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteBooleanAlgebra Œ±] (s : Set Œ±) (a : Œ±) (a_1 : a ‚àà s), a ‚â§ sup‚Çõ s","name":"CompleteBooleanAlgebra.le_sup‚Çõ","isProp":true,"docString":"Any element of a set is less than the set supremum. "},{"type":"‚àÄ {R : Type u_1} [inst : Semigroup R] {a : R} (b : R) (ha : IsRightRegular a),\n  (IsRightRegular (b * a) : Prop) ‚Üî (IsRightRegular b : Prop)","name":"mul_isRightRegular_iff","isProp":true,"docString":"An element is right-regular if and only if multiplying it on the right with a right-regular\nelement is right-regular. "},{"type":"‚àÄ {Œ≤ : Type ub} {V : Set (Œ≤ √ó Œ≤)} {W : Set (Œ≤ √ó Œ≤)} {x : Œ≤} {y : Œ≤} {z : Œ≤} (h : y ‚àà UniformSpace.ball x V)\n  (h' : z ‚àà UniformSpace.ball y W), z ‚àà UniformSpace.ball x (compRel V W)","name":"mem_ball_comp","isProp":true,"docString":"The triangle inequality for `UniformSpace.ball` "},{"type":"‚àÄ (Œ± : Type u) [inst : OrderedAddCommGroup Œ±],\n  ContravariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1","name":"OrderedAddCommGroup.to_contravariantClass_right_le","isProp":true,"docString":"A choice-free shortcut instance."},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {S : Set (AddCon M)}, sup‚Çõ S = addConGen (sup‚Çõ (FunLike.coe '' S))","name":"AddCon.sup‚Çõ_def","isProp":true,"docString":"The supremum of a set of additive congruence relations is the same as the smallest\nadditive congruence relation containing the supremum of the set's image under the map to the\nunderlying binary relation."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  FaithfulSMul (M ‚âÉ‚Çó[R] M) M","name":"LinearEquiv.apply_faithfulSMul","isProp":true,"docString":"`LinearEquiv.applyDistribMulAction` is faithful. "},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (a : Œ±) (b : Œ±),\n  ((min a b = a : Prop) ‚àß (a ‚â§ b : Prop) : Prop) ‚à® ((min a b = b : Prop) ‚àß (b < a : Prop) : Prop)","name":"min_cases","isProp":true,"docString":"For elements `a` and `b` of a linear order, either `min a b = a` and `a ‚â§ b`,\nor `min a b = b` and `b < a`.\nUse cases on this lemma to automate linarith in inequalities "},{"type":"‚àÄ {M : Type u} [inst : Monoid M] {x : M} {y : M} (hxy : x ‚à£ y) {n : ‚Ñï} (x_1 : n ‚â† 0), x ‚à£ y ^ n","name":"Dvd.dvd.pow","isProp":true,"docString":"**Alias** of `dvd_pow`."},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f x y), Equiv.Perm.SameCycle f x (‚Üëf‚Åª¬π y)","name":"Equiv.Perm.SameCycle.inv_apply_right","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_inv_apply_right`."},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"CanonicallyLinearOrderedSemifield.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {X : Type v} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : SigmaCompactSpace X]\n  [inst_3 : T2Space X], ParacompactSpace X","name":"paracompact_of_locallyCompact_sigmaCompact","isProp":true,"docString":"A locally compact sigma compact Hausdorff space is paracompact. See also\n`refinement_of_locallyCompact_sigmaCompact_of_nhds_basis` for a more precise statement. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (s : Set Œ±)\n  (hs :\n    ‚àÄ (Œµ : ENNReal) (a : Œµ > 0),\n      ‚àÉ (t : Set Œ±),\n        (Set.Countable t : Prop) ‚àß\n          (s ‚äÜ Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà t) ‚Ü¶ EMetric.closedBall x Œµ : Prop)),\n  ‚àÉ (t : Set Œ±), (t ‚äÜ s : Prop) ‚àß ((Set.Countable t : Prop) ‚àß (s ‚äÜ closure t : Prop) : Prop)","name":"EMetric.subset_countable_closure_of_almost_dense_set","isProp":true,"docString":"For a set `s` in a pseudo emetric space, if for every `Œµ > 0` there exists a countable\nset that is `Œµ`-dense in `s`, then there exists a countable subset `t ‚äÜ s` that is dense in `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : IsUpperModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚äì b ‚ãñ a), b ‚ãñ a ‚äî b","name":"Covby.sup_of_inf_left","isProp":true,"docString":"**Alias** of `covby_sup_of_inf_covby_left`."},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] (u : MÀ£) (x : M), SemiconjBy (‚Üëu) x (‚Üëu * x * ‚Üëu‚Åª¬π)","name":"Units.mk_semiconjBy","isProp":true,"docString":"`a` semiconjugates `x` to `a * x * a‚Åª¬π`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : MeasurableEmbedding f), Measurable f","name":"MeasurableEmbedding.measurable","isProp":true,"docString":"A measurable embedding is a measurable function. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedMonoid Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b), ‚àÉ (c : Œ±), b = a * c","name":"CanonicallyOrderedMonoid.exists_mul_of_le","isProp":true,"docString":"For `a ‚â§ b`, there is a `c` so `b = a * c`. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {x : M} (m : ‚Ñï) {n : ‚Ñï} (h : x ^ n = 1), x ^ m = x ^ (m % n)","name":"pow_eq_pow_mod","isProp":true,"docString":"If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommSemigroup Œ±] {a : Œ±} {b : Œ±} (c : Œ±) (h : c * a = b), a ‚à£ b","name":"dvd_of_mul_left_eq","isProp":true,"docString":"**Alias** of `Dvd.intro_left`."},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {s : Set E} (hs : Convex ‚Ñù s),\n  ConvexOn ‚Ñù s norm","name":"convexOn_norm","isProp":true,"docString":"The norm on a real normed space is convex on any convex set. See also `Seminorm.convexOn`\nand `convexOn_univ_norm`. "},{"type":"‚àÄ {Œ± : Type u_1} (v : Vector Œ± 1), Vector.tail v = Vector.nil","name":"Vector.singleton_tail","isProp":true,"docString":"The `tail` of a vector made up of one element is `nil`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)]\n  [inst_2 : (i : Œπ) ‚Üí Zero (Œ≤ i)], hammingDist 0 = hammingNorm","name":"hammingDist_zero_left","isProp":true,"docString":"Corresponds to `dist_zero_left`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : DenselyOrdered ùïú] [inst_4 : NoZeroSMulDivisors ùïú E] {A : Set E} {x : E},\n  (x ‚àà Set.extremePoints ùïú A : Prop) ‚Üî\n    ((x ‚àà A : Prop) ‚àß\n        (‚àÄ (x‚ÇÅ : E) (x_1 : x‚ÇÅ ‚àà A) (x‚ÇÇ : E) (x_2 : x‚ÇÇ ‚àà A) (a : x ‚àà segment ùïú x‚ÇÅ x‚ÇÇ),\n            (x‚ÇÅ = x : Prop) ‚à® (x‚ÇÇ = x : Prop) :\n          Prop) :\n      Prop)","name":"mem_extremePoints_iff_forall_segment","isProp":true,"docString":"A useful restatement using `segment`: `x` is an extreme point iff the only (closed) segments\nthat contain it are those with `x` as one of their endpoints. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C},\n  CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.œÄ 0)","name":"CategoryTheory.Limits.cokernel.œÄ_zero_isIso","isProp":true,"docString":"The cokernel of the zero morphism is an isomorphism "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PartialOrder Œ±] [inst_1 : Preorder Œ≤] {œà : (a : Œ±) ‚Üí Œ≤} [inst_2 : SuccOrder Œ±]\n  [inst_3 : IsSuccArchimedean Œ±] {n : Œ±} (hœà : ‚àÄ (m : Œ±) (a : m < n), œà m < œà (Order.succ m)),\n  StrictMonoOn œà (Set.Iic n)","name":"strictMonoOn_Iic_of_lt_succ","isProp":true,"docString":"A function `œà` on a `SuccOrder` is strictly monotone before some `n` if for all `m` such that\n`m < n`, we have `œà m < œà (succ m)`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : C ‚•§ D} (Œ± : F ‚ü∂ G) [inst_2 : ‚àÄ (X : C), CategoryTheory.Epi (Œ±.app X)], CategoryTheory.Epi Œ±","name":"CategoryTheory.NatTrans.epi_of_epi_app","isProp":true,"docString":"A natural transformation is an epimorphism if each component is. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {s : Set Œ±} {b : Œ±} (a : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), b ‚â§ a)\n  (a : ‚àÄ (w : Œ±) (a : b < w), ‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (a < w : Prop)), inf‚Çõ s = b","name":"inf‚Çõ_eq_of_forall_ge_of_forall_gt_exists_lt","isProp":true,"docString":"Introduction rule to prove that `b` is the infimum of `s`: it suffices to check that `b`\nis smaller than all elements of `s`, and that this is not the case of any `w > b`.\nSee `cinf‚Çõ_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in conditionally complete\nlattices. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {c : AddCon M} {d : AddCon M}\n  (H : ‚àÄ (x : M) (y : M), (‚Üëc x y : Prop) ‚Üî (‚Üëd x y : Prop)), c = d","name":"AddCon.ext","isProp":true,"docString":"Extensionality rule for additive congruence relations."},{"type":"‚àÄ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M] (a : RÀ£), IsSMulRegular M ‚Üëa","name":"Units.isSMulRegular","isProp":true,"docString":"Any element in `RÀ£` is `M`-regular. "},{"type":"‚àÄ {G : Type u} [inst : AddMonoid G] {x : G} (h : Function.Injective fun (n : ‚Ñï) ‚Ü¶ n ‚Ä¢ x), ¬¨(IsOfFinAddOrder x : Prop)","name":"not_isOfFinAddOrder_of_injective_nsmul","isProp":true,"docString":"See also `injective_nsmul_iff_not_isOfFinAddOrder`."},{"type":"‚àÄ {Œ± : Type u} {s : Computation Œ±} [self : Computation.Terminates s], ‚àÉ (a : Œ±), a ‚àà s","name":"Computation.Terminates.term","isProp":true,"docString":"assertion that there is some term `a` such that the `Computation` terminates "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 :\n    ‚àÄ {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z},\n      CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.span f g)],\n  CategoryTheory.Limits.HasPushouts C","name":"CategoryTheory.Limits.hasPushouts_of_hasColimit_span","isProp":true,"docString":"If `C` has all colimits of diagrams `span f g`, then it has all pushouts "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú},\n  (StrictConvexOn ùïú s f : Prop) ‚Üî\n    ((Convex ùïú s : Prop) ‚àß\n        (‚àÄ ‚¶Éx : ùïú‚¶Ñ ‚¶Éy : ùïú‚¶Ñ ‚¶Éz : ùïú‚¶Ñ (a : x ‚àà s) (a : z ‚àà s) (a : x < y) (a : y < z),\n            (f y - f x) / (y - x) < (f z - f y) / (z - y) :\n          Prop) :\n      Prop)","name":"strictConvexOn_iff_slope_strict_mono_adjacent","isProp":true,"docString":"A function `f : ùïú ‚Üí ùïú` is strictly convex iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly less than the slope of the secant line of `f` on\n`[x, z]`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : a < b) (a_2 : 0 < c),\n  c * a < c * b","name":"CanonicallyLinearOrderedSemifield.mul_lt_mul_of_pos_left","isProp":true,"docString":"Left multiplication by a positive element is strictly monotone. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] [inst_1 : CommSemiring R] {S : Set M}\n  (hS : AddSubmonoid.closure S = ‚ä§),\n  Function.Surjective ‚Üë(MvPolynomial.aeval fun (s : ‚ÜëS) ‚Ü¶ AddMonoidAlgebra.of' R M ‚Üës)","name":"AddMonoidAlgebra.mvPolynomial_aeval_of_surjective_of_closure","isProp":true,"docString":"If a set `S` generates an additive monoid `M`, then the image of `M` generates, as algebra,\n`AddMonoidAlgebra R M`. "},{"type":"‚àÄ {p : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (hpa : p ‚àà Nat.factors a) (hb : b ‚â† 0), p ‚àà Nat.factors (a * b)","name":"Nat.mem_factors_mul_left","isProp":true,"docString":"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Preadditive C] (P : C) (Q : C) (R : C)\n  (f : P ‚ü∂ Q) (g : Q ‚ü∂ R) (g' : Q ‚ü∂ R), f ‚â´ (g + g') = f ‚â´ g + f ‚â´ g'","name":"CategoryTheory.Preadditive.comp_add","isProp":true,"docString":"A category is called preadditive if `P ‚ü∂ Q` is an abelian group such that composition is\nlinear in both variables. "},{"type":"‚àÄ {G : Type u} {n : ‚Ñï} [inst : AddLeftCancelMonoid G] [inst_1 : Finite G] (x : G),\n  addOrderOf (n ‚Ä¢ x) = addOrderOf x / Nat.gcd (addOrderOf x) n","name":"addOrderOf_nsmul","isProp":true,"docString":"This is the same as `addOrderOf_nsmul'` and\n`addOrderOf_nsmul` but with one assumption less which is automatic in the case of a\nfinite cancellative additive monoid."},{"type":"‚àÄ {Œ± : Type u_1} [self : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±},\n  (sbtw a b c : Prop) ‚Üî ((btw a b c : Prop) ‚àß (¬¨(btw c b a : Prop) : Prop) : Prop)","name":"CircularPreorder.sbtw_iff_btw_not_btw","isProp":true,"docString":"Strict betweenness is given by betweenness in one direction and non-betweenness in the other.\n\nI.e., if `b` is between `a` and `c` but not between `c` and `a`, then we say `b` is strictly\nbetween `a` and `c`. "},{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y], Isometry Sum.inr","name":"Metric.isometry_inr","isProp":true,"docString":"The right injection of a space in a disjoint union is an isometry "},{"type":"‚àÄ {n : ‚Ñï} {n' : ‚Ñï} (i : Fin n) (h : Nat.succ n = Nat.succ n'),\n  ‚Üë(Fin.cast h) (Fin.succ i) = Fin.succ (‚Üë(Fin.cast ((Nat.succ.inj h=:n = n')=:n = n')) i)","name":"Fin.cast_succ_eq","isProp":true,"docString":"The cast of the successor is the succesor of the cast. See `Fin.succ_cast_eq` for rewriting in\nthe reverse direction. "},{"type":"‚àÄ {G‚ÇÄ : Type u} [self : GroupWithZero G‚ÇÄ] (n : ‚Ñï) (a : G‚ÇÄ),\n  GroupWithZero.zpow (Int.negSucc n) a = (GroupWithZero.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"GroupWithZero.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : (x : P) ‚Üí (a : x ‚àà affineSpan k s) ‚Üí Prop}\n  (Hs : ‚àÄ (y : P) (hys : y ‚àà s), p y ((subset_affineSpan k s hys=:y ‚àà ‚Üë(affineSpan k s))=:y ‚àà ‚Üë(affineSpan k s)))\n  (Hc :\n    ‚àÄ (c : k) (u : P) (hu : u ‚àà affineSpan k s) (v : P) (hv : v ‚àà affineSpan k s) (w : P) (hw : w ‚àà affineSpan k s)\n      (a : p u hu) (a : p v hv) (a : p w hw),\n      p (c ‚Ä¢ (u -·µ• v) +·µ• w)\n        ((AffineSubspace.smul_vsub_vadd_mem (affineSpan k s) c hu hv\n              hw=:c ‚Ä¢ (u -·µ• v) +·µ• w ‚àà\n              AffineSubspace.carrier (affineSpan k s))=:c ‚Ä¢ (u -·µ• v) +·µ• w ‚àà AffineSubspace.carrier (affineSpan k s)))\n  {x : P} (h : x ‚àà affineSpan k s), p x h","name":"affineSpan_induction'","isProp":true,"docString":"A dependent version of `affineSpan_induction`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≤} {a : Œ±} (h : ‚àÄ (b : Œ≤), f a b = b) (o : Option Œ≤),\n  Option.map‚ÇÇ f (some a) o = o","name":"Option.map‚ÇÇ_left_identity","isProp":true,"docString":"If `a` is a left identity for a binary operation `f`, then `some a` is a left identity for\n`Option.map‚ÇÇ f`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasFiniteLimits C] (J : Type)\n  [ùí• : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J],\n  CategoryTheory.Limits.HasLimitsOfShape J C","name":"CategoryTheory.Limits.HasFiniteLimits.out","isProp":true,"docString":"`C` has all limits over any type `J` whose objects and morphisms lie in the same universe\nand which has `FinType` objects and morphisms"},{"type":"‚àÄ {Œπ : Type u} {Œ≥ : Type w} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] [inst : (i : Œπ) ‚Üí AddZeroClass (Œ≤ i)]\n  [inst_1 : AddCommMonoid Œ≥] (f : (i : Œπ) ‚Üí Œ≤ i ‚Üí+ Œ≥) (i : Œπ) (x : Œ≤ i),\n  ‚Üë(‚ÜëDfinsupp.liftAddHom f) (Dfinsupp.single i x) = ‚Üë(f i) x","name":"Dfinsupp.liftAddHom_apply_single","isProp":true,"docString":"The `Dfinsupp` version of `Finsupp.liftAddHom_apply_single`,"},{"type":"‚àÄ {n : ‚Ñï} (self : Fin n), ‚Üëself < n","name":"Fin.isLt","isProp":true,"docString":"If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalSeminormedRing Œ±], TopologicalRing Œ±","name":"semi_normed_top_ring","isProp":true,"docString":"A seminormed ring is a topological ring. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {e' : LocalHomeomorph Œ± Œ≤} (h : e ‚âà e'),\n  LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) = LocalEquiv.source (LocalHomeomorph.toLocalEquiv e')","name":"LocalHomeomorph.EqOnSource.source_eq","isProp":true,"docString":"Two equivalent local homeomorphisms have the same source "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : Zero M] {s : Set Œ±} {f : (a : Œ±) ‚Üí M} {a : Œ±} (h : Set.indicator s f a ‚â† 0),\n  a ‚àà s","name":"Set.mem_of_indicator_ne_zero","isProp":true,"docString":"If an additive indicator function is not equal to `0` at a point, then that point is\nin the set."},{"type":"‚àÄ {G : Type u_2} {P : Type u_1} [inst : AddGroup G] [T : AddTorsor G P] (p1 : P) (p2 : P), p1 -·µ• p2 +·µ• p2 = p1","name":"vsub_vadd","isProp":true,"docString":"Adding the result of subtracting from another point produces that\npoint. "},{"type":"‚àÄ (a : ‚Ñù), Cardinal.mk ‚Üë(Set.Iic a) = Cardinal.continuum","name":"Cardinal.mk_Iic_real","isProp":true,"docString":"The cardinality of the interval (-‚àû, a]. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G} {y : G} (hx : x ‚àà H) (hy : y ‚àà H), x / y ‚àà H","name":"Subgroup.div_mem","isProp":true,"docString":"A subgroup is closed under division. "},{"type":"‚àÄ {p : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (hab : Nat.coprime a b) (hpb : p ‚àà Nat.factors b),\n  ‚Üë(Nat.factorization (a * b)) p = ‚Üë(Nat.factorization b) p","name":"Nat.factorization_eq_of_coprime_right","isProp":true,"docString":"If `p` is a prime factor of `b` then the power of `p` in `b` is the same that in `a * b`,\nfor any `a` coprime to `b`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (self : C ‚•§ D)\n  {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor self) (f ‚â´ g) =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor self) f ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor self) g","name":"CategoryTheory.Functor.map_comp","isProp":true,"docString":"A functor preserves composition. "},{"type":"‚àÄ (n : ‚Ñï) (p : ‚Ñï), Finset.card (Finset.filter (fun (x : ‚Ñï) ‚Ü¶ p ‚à£ x) (Finset.Ioc 0 n)) = n / p","name":"Nat.Ioc_filter_dvd_card_eq_div","isProp":true,"docString":"Exactly `n / p` naturals in `(0, n]` are multiples of `p`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : btw a b c), ¬¨(sbtw c b a : Prop)","name":"Btw.btw.not_sbtw","isProp":true,"docString":"**Alias** of `not_sbtw_of_btw`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ≥}\n  (hf : UpperSemicontinuous f) (hg : UpperSemicontinuous g)\n  (hcont : ‚àÄ (x : Œ±), ContinuousAt (fun (p : Œ≥ √ó Œ≥) ‚Ü¶ Prod.fst p + Prod.snd p) (f x, g x)),\n  UpperSemicontinuous fun (z : Œ±) ‚Ü¶ f z + g z","name":"UpperSemicontinuous.add'","isProp":true,"docString":"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (hf : Antitone f) (hg : StrictAnti g), StrictAnti fun (x : Œ≤) ‚Ü¶ f x * g x","name":"Antitone.mul_strictAnti'","isProp":true,"docString":"The product of a antitone function and a strictly antitone function is strictly antitone. "},{"type":"‚àÄ {R : Type u_6} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_4} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] {P : Type u_3} [inst_3 : CommSemiring P] [inst_4 : IsLocalization M S] {g : R ‚Üí+* P}\n  {T : Submonoid P} {Q : Type u_5} [inst_5 : CommSemiring Q] (hy : M ‚â§ Submonoid.comap g T) [inst_6 : Algebra P Q]\n  [inst_7 : IsLocalization T Q] {A : Type u_1} [inst_8 : CommSemiring A] {U : Submonoid A} {W : Type u_2}\n  [inst_9 : CommSemiring W] [inst_10 : Algebra A W] [inst_11 : IsLocalization U W] {l : P ‚Üí+* A}\n  (hl : T ‚â§ Submonoid.comap l U),\n  RingHom.comp (IsLocalization.map W l hl) (IsLocalization.map Q g hy) =\n    IsLocalization.map W (RingHom.comp l g)\n      (fun (x : R) ‚Ü¶\n        (_ : ‚àÄ (hx : x ‚àà M), ‚Üëg x ‚àà Submonoid.comap l U)=:‚àÄ (x : R) (hx : x ‚àà M), ‚Üëg x ‚àà Submonoid.comap l U)","name":"IsLocalization.map_comp_map","isProp":true,"docString":"If `CommSemiring` homs `g : R ‚Üí+* P, l : P ‚Üí+* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ‚àò g`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : AddCommGroup Œ±] (s : Finset Œ±) {t : Finset Œ±}\n  (ht : Finset.Nonempty t),\n  ‚àÉ (u : Finset Œ±), (Finset.card u * Finset.card t ‚â§ Finset.card (s + t) : Prop) ‚àß (s ‚äÜ u + t - t : Prop)","name":"Finset.exists_subset_add_sub","isProp":true,"docString":"**Ruzsa's covering lemma**"},{"type":"‚àÄ {Œ± : Type u_1} [inst : EMetricSpace Œ±] [cs : CompleteSpace Œ±] {K : NNReal} {f : (a : Œ±) ‚Üí Œ±}\n  (hf : ContractingWith K f) (x : Œ±) (hx : edist x (f x) ‚â† ‚ä§),\n  ‚àÉ (y : Œ±),\n    (Function.IsFixedPt f y : Prop) ‚àß\n      ((Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ (f^[n]) x) Filter.atTop (nhds y) : Prop) ‚àß\n          (‚àÄ (n : ‚Ñï), edist ((f^[n]) x) y ‚â§ edist x (f x) * ‚ÜëK ^ n / (1 - ‚ÜëK) : Prop) :\n        Prop)","name":"ContractingWith.exists_fixedPoint","isProp":true,"docString":"Banach fixed-point theorem, contraction mapping theorem, `EMetricSpace` version.\nA contracting map on a complete metric space has a fixed point.\nWe include more conclusions in this theorem to avoid proving them again later.\n\nThe main API for this theorem are the functions `efixedPoint` and `fixedPoint`,\nand lemmas about these functions. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasWideEqualizer f] [inst_2 : Nonempty J],\n  CategoryTheory.Mono (CategoryTheory.Limits.wideEqualizer.Œπ f)","name":"CategoryTheory.Limits.wideEqualizer.Œπ_mono","isProp":true,"docString":"A wide equalizer morphism is a monomorphism "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] {M‚ÇÅ' : (a : Œπ) ‚Üí Type u_1} [inst_5 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ' i)]\n  [inst_6 : (i : Œπ) ‚Üí Module R (M‚ÇÅ' i)] (f : (i : Œπ) ‚Üí M‚ÇÅ i ‚Üí‚Çó[R] M‚ÇÅ' i) (hf : ‚àÄ (i : Œπ), Function.Surjective ‚Üë(f i)),\n  Function.Injective fun (g : MultilinearMap R M‚ÇÅ' M‚ÇÇ) ‚Ü¶ MultilinearMap.compLinearMap g f","name":"MultilinearMap.compLinearMap_injective","isProp":true,"docString":"Composing with a family of surjective linear maps is injective. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : a ‚â§ b) (a_2 : b ‚â§ c), a ‚â§ c","name":"le_trans","isProp":true,"docString":"The relation `‚â§` on a preorder is transitive. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) {Œ± : (a : Œπ) ‚Üí Type u_1} (g : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí M‚ÇÅ i)\n  (A : (i : Œπ) ‚Üí Finset (Œ± i)) [inst_5 : DecidableEq Œπ] [inst_6 : Fintype Œπ],\n  (‚Üëf fun (i : Œπ) ‚Ü¶ Finset.sum (A i) fun (j : Œ± i) ‚Ü¶ g i j) =\n    Finset.sum (Fintype.piFinset A) fun (r : (a : Œπ) ‚Üí Œ± a) ‚Ü¶ ‚Üëf fun (i : Œπ) ‚Ü¶ g i (r i)","name":"MultilinearMap.map_sum_finset","isProp":true,"docString":"If `f` is multilinear, then `f (Œ£_{j‚ÇÅ ‚àà A‚ÇÅ} g‚ÇÅ j‚ÇÅ, ..., Œ£_{j‚Çô ‚àà A‚Çô} g‚Çô j‚Çô)` is the sum of\n`f (g‚ÇÅ (r 1), ..., g‚Çô (r n))` where `r` ranges over all functions with `r 1 ‚àà A‚ÇÅ`, ...,\n`r n ‚àà A‚Çô`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : ConditionallyCompleteLattice Œ≤] {s : Set (WithTop Œ≤)} (hs : BddBelow s), IsGLB s (inf‚Çõ s)","name":"WithTop.isGLB_inf‚Çõ'","isProp":true,"docString":"The `inf‚Çõ` of a bounded-below set is its greatest lower bound for a conditionally\ncomplete lattice with a top. "},{"type":"‚àÄ {Œì : Type u_2} [inst : Group Œì] {T : Type u_1} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Œì T]\n  [inst_3 : TopologicalSpace.SecondCountableTopology T] [inst_4 : ContinuousConstSMul Œì T],\n  TopologicalSpace.SecondCountableTopology (Quotient (MulAction.orbitRel Œì T))","name":"ContinuousConstSMul.secondCountableTopology","isProp":true,"docString":"The quotient of a second countable space by a group action is second countable. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\n  [inst_3 : LocallyCompactSpace G] {U : Set G} (hU : U ‚àà nhds 1),\n  ‚àÉ (K : Set G), (IsCompact K : Prop) ‚àß ((IsClosed K : Prop) ‚àß ((K ‚äÜ U : Prop) ‚àß (1 ‚àà interior K : Prop) : Prop) : Prop)","name":"local_isCompact_isClosed_nhds_of_group","isProp":true,"docString":"In a locally compact group, any neighborhood of the identity contains a compact closed\nneighborhood of the identity, even without separation assumptions on the space. "},{"type":"‚àÄ (n : ‚Ñï) {p : ‚Ñï} (pp : Nat.Prime p),\n  Finset.Icc 1 (‚Üë(Nat.factorization n) p) = Finset.filter (fun (i : ‚Ñï) ‚Ü¶ p ^ i ‚à£ n) (Finset.Ico 1 n)","name":"Nat.Icc_factorization_eq_pow_dvd","isProp":true,"docString":"The set of positive powers of prime `p` that divide `n` is exactly the set of\npositive natural numbers up to `n.factorization p`. "},{"type":"‚àÄ {R : Type u} {S : Type v} {œÉ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n  {f‚ÇÅ : MvPolynomial œÉ R ‚Üí+* S} {f‚ÇÇ : MvPolynomial œÉ R ‚Üí+* S} {p‚ÇÅ : MvPolynomial œÉ R} {p‚ÇÇ : MvPolynomial œÉ R}\n  (hC : RingHom.comp f‚ÇÅ MvPolynomial.C = RingHom.comp f‚ÇÇ MvPolynomial.C)\n  (hv :\n    ‚àÄ (i : œÉ) (a : i ‚àà MvPolynomial.vars p‚ÇÅ) (a : i ‚àà MvPolynomial.vars p‚ÇÇ),\n      ‚Üëf‚ÇÅ (MvPolynomial.X i) = ‚Üëf‚ÇÇ (MvPolynomial.X i))\n  (hp : p‚ÇÅ = p‚ÇÇ), ‚Üëf‚ÇÅ p‚ÇÅ = ‚Üëf‚ÇÇ p‚ÇÇ","name":"MvPolynomial.hom_congr_vars","isProp":true,"docString":"If `f‚ÇÅ` and `f‚ÇÇ` are ring homs out of the polynomial ring and `p‚ÇÅ` and `p‚ÇÇ` are polynomials,\nthen `f‚ÇÅ p‚ÇÅ = f‚ÇÇ p‚ÇÇ` if `p‚ÇÅ = p‚ÇÇ` and `f‚ÇÅ` and `f‚ÇÇ` are equal on `R` and on the variables\nof `p‚ÇÅ`.  "},{"type":"‚àÄ {S : Type u_1} {M : Type u_2} [inst : Add M] [inst_1 : SetLike S M] [self : AddMemClass S M] {s : S} {a : M} {b : M}\n  (a_1 : a ‚àà s) (a_2 : b ‚àà s), a + b ‚àà s","name":"AddMemClass.add_mem","isProp":true,"docString":"A substructure satisfying `AddMemClass` is closed under addition. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {r : HomRel C} [self : CategoryTheory.Congruence r] {X : C} {Y : C},\n  IsEquiv (X ‚ü∂ Y) r","name":"CategoryTheory.Congruence.isEquiv","isProp":true,"docString":"`r` is an equivalence on every hom-set. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {K : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category K] {C : Type u}\n  [inst_2 : CategoryTheory.Category C] {F : J ‚•§ C} (e : K ‚âå J)\n  [inst_3 : CategoryTheory.Limits.HasColimit (CategoryTheory.Equivalence.functor e ‚ãô F)],\n  CategoryTheory.Limits.HasColimit F","name":"CategoryTheory.Limits.hasColimit_of_equivalence_comp","isProp":true,"docString":"If a `E ‚ãô F` has a colimit, and `E` is an equivalence, we can construct a colimit of `F`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} (self : TopologicalSpace.OpenNhdsOf x),\n  x ‚àà TopologicalSpace.Opens.carrier (TopologicalSpace.OpenNhdsOf.toOpens self)","name":"TopologicalSpace.OpenNhdsOf.mem'","isProp":true,"docString":"The point `x` belongs to every `U : TopologicalSpace.OpenNhdsOf x`. "},{"type":"‚àÄ (Œ± : Type u_2) (Œ≤ : Type u_1) (ùìë : Filter (Œ≤ √ó Œ≤)),\n  Filter.IsBasis (fun (V : Set (Œ≤ √ó Œ≤)) ‚Ü¶ V ‚àà ùìë) (UniformFun.gen Œ± Œ≤)","name":"UniformFun.isBasis_gen","isProp":true,"docString":"If `ùìï` is a filter on `Œ≤ √ó Œ≤`, then the set of all `UniformFun.gen Œ± Œ≤ V` for\n`V ‚àà ùìï` is a filter basis on `(Œ± ‚Üí·µ§ Œ≤) √ó (Œ± ‚Üí·µ§ Œ≤)`. This will only be applied to `ùìï = ùì§ Œ≤` when\n`Œ≤` is equipped with a `UniformSpace` structure, but it is useful to define it for any filter in\norder to be able to state that it has a lower adjoint (see `UniformFun.gc`). "},{"type":"‚àÄ {Œπ : Type u_1} {Œπ' : Type u_2} {Œ± : Type u_3} [inst : Finite Œπ] [inst : Preorder Œπ']\n  [inst_1 : IsDirected Œπ' (Function.swap fun (x : Œπ') (x_1 : Œπ') ‚Ü¶ x ‚â§ x_1)] [inst_2 : Nonempty Œπ']\n  {s : (a : Œπ) ‚Üí (a : Œπ') ‚Üí Set Œ±} (hs : ‚àÄ (i : Œπ), Monotone (s i)),\n  (Set.inter·µ¢ fun (j : Œπ') ‚Ü¶ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ s i j) = Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (j : Œπ') ‚Ü¶ s i j","name":"Set.inter·µ¢_union·µ¢_of_monotone","isProp":true,"docString":"An increasing intersection distributes over finite union. "},{"type":"‚àÄ (k : Type u_1) [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ) [inst_1 : CharZero k] {n : ‚Ñï}\n  (h : Finset.card s = n + 1), (Finset.sum s fun (i : Œπ) ‚Ü¶ Finset.centroidWeights k s i) = 1","name":"Finset.sum_centroidWeights_eq_one_of_card_eq_add_one","isProp":true,"docString":"In the characteristic zero case, the weights in the centroid sum\nto 1 if the number of points is `n + 1`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 :\n    ‚àÄ {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y},\n      CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair f g)],\n  CategoryTheory.Limits.HasCoequalizers C","name":"CategoryTheory.Limits.hasCoequalizers_of_hasColimit_parallelPair","isProp":true,"docString":"If `C` has all colimits of diagrams `parallelPair f g`, then it has all coequalizers "},{"type":"‚àÄ {c : ‚Ñù} (h1 : 0 < c) (h2 : c < 1 / 2) {n : ‚Ñï} {f : (a : ‚Ñï) ‚Üí Bool} {g : (a : ‚Ñï) ‚Üí Bool}\n  (hn : ‚àÄ (k : ‚Ñï) (a : k < n), f k = g k) (fn : f n = false) (gn : g n = true),\n  Cardinal.cantorFunction c f < Cardinal.cantorFunction c g","name":"Cardinal.increasing_cantorFunction","isProp":true,"docString":"`cantorFunction c` is strictly increasing with if `0 < c < 1/2`, if we endow `‚Ñï ‚Üí Bool` with a\nlexicographic order. The lexicographic order doesn't exist for these infinitary products, so we\nexplicitly write out what it means. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {E' : Type u_3} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : f' =o[l] g), (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =o[l] g","name":"Asymptotics.IsLittleO.norm_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_norm_left`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T2Space Œ±] {s : Set Œ≤}\n  {t : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (h : Set.EqOn f g s) (hf : ContinuousOn f t) (hg : ContinuousOn g t)\n  (hst : s ‚äÜ t) (hts : t ‚äÜ closure s), Set.EqOn f g t","name":"Set.EqOn.of_subset_closure","isProp":true,"docString":"If `f x = g x` for all `x ‚àà s` and `f`, `g` are continuous on `t`, `s ‚äÜ t ‚äÜ closure s`, then\n`f x = g x` for all `x ‚àà t`. See also `Set.EqOn.closure`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±}, 0 ‚â§ Metric.hausdorffDist s t","name":"Metric.hausdorffDist_nonneg","isProp":true,"docString":"The Hausdorff distance is nonnegative "},{"type":"‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_4 : AddCommMonoid M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ]\n  [inst_6 : RingHomSurjective œÉ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : Set M),\n  Submodule.map f (Submodule.span R s) = Submodule.span R‚ÇÇ (‚Üëf '' s)","name":"LinearMap.map_span","isProp":true,"docString":"**Alias** of `Submodule.map_span`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C), CategoryTheory.IsPushout (ùüô X) 0 0 0","name":"CategoryTheory.IsPushout.zero_bot","isProp":true,"docString":"The square with `0 : 0 ‚ü∂ 0` on the bottom and `ùüô X` on the top is a pushout square. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.Limits.HasEqualizers C], CategoryTheory.Limits.HasFiniteLimits C","name":"CategoryTheory.Limits.hasFiniteLimits_of_hasEqualizers_and_finite_products","isProp":true,"docString":"Any category with finite products and equalizers has all finite limits.\n\nSee <https://stacks.math.columbia.edu/tag/002O>.\n"},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {s : Set M} {t : Set M} {x : M},\n  (x ‚àà AddMonoid.Closure (s ‚à™ t) : Prop) ‚Üî\n    (‚àÉ (y : M),\n        (y ‚àà AddMonoid.Closure s : Prop) ‚àß (‚àÉ (z : M), (z ‚àà AddMonoid.Closure t : Prop) ‚àß (y + z = x : Prop) : Prop) :\n      Prop)","name":"AddMonoid.mem_closure_union_iff","isProp":true,"docString":"Given sets `s, t` of a commutative `AddMonoid M`, `x ‚àà M` is in the `AddSubmonoid`\nof `M` generated by `s ‚à™ t` iff there exists an element of the `AddSubmonoid` generated by `s`\nand an element of the `AddSubmonoid` generated by `t` whose sum is `x`."},{"type":"‚àÄ {Œ± : Type u_1} (self : MeasurableSpace Œ±) (s : Set Œ±) (a : MeasurableSpace.MeasurableSet' self s),\n  MeasurableSpace.MeasurableSet' self (s·∂ú)","name":"MeasurableSpace.measurableSet_compl","isProp":true,"docString":"The complement of a measurable set is a measurable set. Use `MeasurableSet.compl` instead. "},{"type":"‚àÄ {R : Type u_3} {S : Type u_4} {M : Type u_1} {M‚ÇÉ : Type u_2} [inst : Semiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÉ] [inst_4 : Module R M] [inst_5 : Module S M‚ÇÉ] {œÉ : R ‚Üí+* S}\n  {f : M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÉ} {g : M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÉ} (h : f = g) (x : M), ‚Üëf x = ‚Üëg x","name":"LinearMap.congr_fun","isProp":true,"docString":"If two linear maps are equal, they are equal at each point. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1], 0 < 2","name":"zero_lt_two","isProp":true,"docString":"See `zero_lt_two'` for a version with the type explicit. "},{"type":"‚àÄ {Œ± : Type u_1} (self : FilterBasis Œ±) {x : Set Œ±} {y : Set Œ±} (a : x ‚àà FilterBasis.sets self)\n  (a : y ‚àà FilterBasis.sets self), ‚àÉ (z : Set Œ±), (z ‚àà FilterBasis.sets self : Prop) ‚àß (z ‚äÜ x ‚à© y : Prop)","name":"FilterBasis.inter_sets","isProp":true,"docString":"The set of filter basis sets is directed downwards. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v} {M‚ÇÇ : Type w} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (self : MultilinearMap R M‚ÇÅ M‚ÇÇ) [inst_5 : DecidableEq Œπ] (m : (i : Œπ) ‚Üí M‚ÇÅ i) (i : Œπ)\n  (x : M‚ÇÅ i) (y : M‚ÇÅ i),\n  MultilinearMap.toFun self (Function.update m i (x + y)) =\n    MultilinearMap.toFun self (Function.update m i x) + MultilinearMap.toFun self (Function.update m i y)","name":"MultilinearMap.map_add'","isProp":true,"docString":"A multilinear map is additive in every argument. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] (p : ‚Ñï) [hp : CharP R p] [hq : ExpChar R 1], p = 0","name":"char_zero_of_expChar_one","isProp":true,"docString":"The exponential characteristic is one if the characteristic is zero. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  {t : CategoryTheory.Limits.Fork f g} (ht : CategoryTheory.Limits.IsLimit t) {Z : C} {Z' : C} (q : Z' ‚ü∂ Z)\n  (k : Z ‚ü∂ CategoryTheory.Limits.Cone.pt t),\n  ‚Üë(‚Üë(CategoryTheory.Limits.Fork.IsLimit.homIso ht Z') (q ‚â´ k)) =\n    q ‚â´ ‚Üë(‚Üë(CategoryTheory.Limits.Fork.IsLimit.homIso ht Z) k)","name":"CategoryTheory.Limits.Fork.IsLimit.homIso_natural","isProp":true,"docString":"The bijection of `Fork.IsLimit.homIso` is natural in `Z`. "},{"type":"‚àÄ {M : Type u_2} [inst : AddMonoid M] {A : Type u_1} [inst_1 : AddMonoid A] {f : (a : M) ‚Üí A} (hf : IsAddMonoidHom f)\n  (s : Set M), f '' AddMonoid.Closure s = AddMonoid.Closure (f '' s)","name":"AddMonoid.image_closure","isProp":true,"docString":"The image under an `AddMonoid` hom of the `AddSubmonoid` generated by a set equals\nthe `AddSubmonoid` generated by the image of the set under the `AddMonoid` hom."},{"type":"‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} {Œ≥ : Type u_3} {a : Option Œ±} {b : Option Œ≤} {Œ≤' : Type u_1} {Œ¥ : Type u_2}\n  {f : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥} {g : (a : Œ≤) ‚Üí Œ≤'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_right_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), f a (g b) = g' (f' b a)),\n  Option.map‚ÇÇ f a (Option.map g b) = Option.map g' (Option.map‚ÇÇ f' b a)","name":"Option.map_map‚ÇÇ_right_anticomm","isProp":true,"docString":"Symmetric statement to `Option.map_map‚ÇÇ_antidistrib_right`. "},{"type":"Set.Unbounded (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x < x_1)\n  (setOf fun (b : Ordinal) ‚Ü¶ (Cardinal.ord (Ordinal.card b) = b : Prop) ‚àß (Ordinal.omega ‚â§ b : Prop))","name":"Cardinal.ord_card_unbounded'","isProp":true,"docString":"Infinite ordinals that are cardinals are unbounded. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} {t : Set Œ≤}\n  {f : (a : Œ±) ‚Üí Œ≤} (h : Set.MapsTo f s t) (hc : Continuous f), Set.MapsTo f (closure s) (closure t)","name":"Set.MapsTo.closure","isProp":true,"docString":"If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ‚Üë(Con.mk' c)","name":"Con.mk'_surjective","isProp":true,"docString":"The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí SeminormedAddGroup (œÄ i)]\n  {x : (i : Œπ) ‚Üí œÄ i} {r : ‚Ñù} (hr : 0 < r), (‚Äñx‚Äñ < r : Prop) ‚Üî (‚àÄ (i : Œπ), ‚Äñx i‚Äñ < r : Prop)","name":"pi_norm_lt_iff","isProp":true,"docString":"The seminorm of an element in a product space is `< r` if and only\nif the norm of each component is."},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {l : List R} (a : ‚àÄ (x : R) (a : x ‚àà l), x ‚àà s),\n  List.sum l ‚àà s","name":"Subsemiring.list_sum_mem","isProp":true,"docString":"Sum of a list of elements in a `Subsemiring` is in the `Subsemiring`. "},{"type":"‚àÄ (G : Type u) [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G]\n  [inst_3 : TopologicalSpace.FirstCountableTopology G] (N : Subgroup G) [inst_4 : Subgroup.Normal N]\n  [inst_5 : CompleteSpace G], CompleteSpace (G ‚ß∏ N)","name":"QuotientGroup.completeSpace'","isProp":true,"docString":"The quotient `G ‚ß∏ N` of a complete first countable topological group `G` by a normal subgroup\nis itself complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause a topological group is not equipped with a `UniformSpace` instance by default, we must\nexplicitly provide it in order to consider completeness. See `QuotientGroup.completeSpace` for a\nversion in which `G` is already equipped with a uniform structure. "},{"type":"‚àÄ {d : ‚Ñ§}, MonoidHom.mker Zsqrtd.normMonoidHom = unitary (‚Ñ§‚àöd)","name":"Zsqrtd.mker_norm_eq_unitary","isProp":true,"docString":"The kernel of the norm map on `‚Ñ§‚àöd` equals the submonoid of unitary elements. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} (h : Set.Finite s), Metric.Bounded s","name":"Metric.bounded_of_finite","isProp":true,"docString":"A finite set is bounded "},{"type":"‚àÄ {Œ± : Type u} [inst : LT Œ±] [inst_1 : WellFoundedLT Œ±] {C : (a : Œ±) ‚Üí Prop} (a : Œ±)\n  (a_1 : ‚àÄ (x : Œ±) (a : ‚àÄ (y : Œ±) (a : y < x), C y), C x), C a","name":"WellFoundedLT.induction","isProp":true,"docString":"Inducts on a well-founded `<` relation. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {A : Set E}\n  (hA : Balanced ùïú A), Absorbs ùïú A A","name":"Balanced.absorbs_self","isProp":true,"docString":"A balanced set absorbs itself. "},{"type":"‚àÄ {Œ± : Sort u_1} (P : Prop) [inst : Decidable (P : Prop)] (a : Œ±) (b : Œ±),\n  (if x : (P : Prop) then a else b) = if (P : Prop) then a else b","name":"dite_eq_ite","isProp":true,"docString":"A `dite` whose results do not actually depend on the condition may be reduced to an `ite`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p : Prop)]\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {a : Associates Œ±}\n  {p : Associates Œ±} (hp : Irreducible p) [inst_2 : (n : ‚Ñï) ‚Üí Decidable (a ‚à£ p ^ n : Prop)] {n : ‚Ñï} (h : a ‚à£ p ^ n),\n  a = p ^ Nat.find ((Exists.intro n h=:‚àÉ (n : ‚Ñï), (fun (n : ‚Ñï) ‚Ü¶ a ‚à£ p ^ n) n)=:‚àÉ (n : ‚Ñï), (fun (n : ‚Ñï) ‚Ü¶ a ‚à£ p ^ n) n)","name":"Associates.eq_pow_find_of_dvd_irreducible_pow","isProp":true,"docString":"The only divisors of prime powers are prime powers. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedAddGroup E] {l : Filter Œ±} {f : (a : Œ±) ‚Üí E}\n  (h : Filter.Tendsto (fun (y : Œ±) ‚Ü¶ ‚Äñf y‚Äñ) l Filter.atTop) (x : E), Filter.Eventually (fun (y : Œ±) ‚Ü¶ f y ‚â† x) l","name":"eventually_ne_of_tendsto_norm_atTop","isProp":true,"docString":"If `‚Äñy‚Äñ‚Üí‚àû`, then we can assume `y‚â†x` for any\nfixed `x`"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] [inst_1 : HasDistribNeg Œ±] {a : Œ±} {b : Œ±} (a_1 : -a ‚à£ b), a ‚à£ b","name":"Dvd.dvd.of_neg_left","isProp":true,"docString":"**Alias** of the forward direction of `neg_dvd`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 0) (hb : b < 0), a + b < 0","name":"add_neg'","isProp":true,"docString":"**Alias** of `Left.add_neg'`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Œ±) ‚Üí Œ±} (h : id ‚â§ f) (n : ‚Ñï), id ‚â§ f^[n]","name":"Function.id_le_iterate_of_id_le","isProp":true,"docString":"If $x ‚â§ f x$ for all $x$ (we write this as `id ‚â§ f`), then the same is true for any iterate\n`f^[n]` of `f`. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (a : M), SemiconjBy a 1 1","name":"SemiconjBy.one_right","isProp":true,"docString":"Any element semiconjugates `1` to `1`. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : (a : Fin n) ‚Üí Œ±} {œÉ : Equiv.Perm (Fin n)}\n  (h : f ‚àò ‚ÜëœÉ ‚â† f ‚àò ‚Üë(Tuple.sort f)), ‚àÉ (i : Fin n), ‚àÉ (j : Fin n), (i < j : Prop) ‚àß ((f ‚àò ‚ÜëœÉ) j < (f ‚àò ‚ÜëœÉ) i : Prop)","name":"Tuple.antitone_pair_of_not_sorted'","isProp":true,"docString":"If a permutation `f ‚àò œÉ` of the tuple `f` is not the same as `f ‚àò sort f`, then `f ‚àò œÉ`\nhas a pair of strictly decreasing entries. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} (hf : Set.EqOn f 0 s),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) = 0","name":"finsum_mem_of_eqOn_zero","isProp":true,"docString":"If a function `f` equals `0` on a set `s`, then the product of `f i` over `i ‚àà s`\nequals `0`."},{"type":"‚àÄ {Œπ : Type u_2} {N : Type u_1} [dec_Œπ : DecidableEq Œπ] [inst : AddCommGroup N] {p : (a : Œπ) ‚Üí AddSubgroup N}\n  (h : CompleteLattice.Independent p), Function.Injective ‚Üë(Dfinsupp.sumAddHom fun (i : Œπ) ‚Ü¶ AddSubgroup.subtype (p i))","name":"CompleteLattice.Independent.dfinsupp_sumAddHom_injective","isProp":true,"docString":"The canonical map out of a direct sum of a family of additive subgroups is injective when the\nadditive subgroups are `CompleteLattice.Independent`. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] {p1 : P} {p2 : P} {p : P}\n  (h : p -·µ• p1 = p -·µ• p2), p1 = p2","name":"vsub_right_cancel","isProp":true,"docString":"If subtracting two points from the same point produces equal\nresults, those points are equal. "},{"type":"‚àÄ {R : Type u_2} [inst : StrictOrderedCommSemiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {N : Type u_4} [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {x : M} {y : M} {F : Type u_1}\n  [inst_5 : LinearMapClass F R M N] {f : F} (hf : Function.Injective ‚Üëf),\n  (SameRay R (‚Üëf x) (‚Üëf y) : Prop) ‚Üî (SameRay R x y : Prop)","name":"Function.Injective.sameRay_map_iff","isProp":true,"docString":"The images of two vectors under an injective linear map are on the same ray if and only if the\noriginal vectors are on the same ray. "},{"type":"‚àÄ {Œπ : Type u} {Œ± : Type v} [inst : DecidableEq Œ±] {t : (a : Œπ) ‚Üí Finset Œ±} [inst_1 : Fintype Œπ] {n : ‚Ñï}\n  (hn : Fintype.card Œπ = n + 1) (ht : ‚àÄ (s : Finset Œπ), Finset.card s ‚â§ Finset.card (Finset.bunion·µ¢ s t))\n  (ih :\n    ‚àÄ {Œπ' : Type u} [inst_2 : Fintype Œπ'] (t' : (a : Œπ') ‚Üí Finset Œ±) (a : Fintype.card Œπ' ‚â§ n)\n      (a : ‚àÄ (s' : Finset Œπ'), Finset.card s' ‚â§ Finset.card (Finset.bunion·µ¢ s' t')),\n      ‚àÉ (f : (a : Œπ') ‚Üí Œ±), (Function.Injective f : Prop) ‚àß (‚àÄ (x : Œπ'), f x ‚àà t' x : Prop))\n  (ha :\n    ‚àÄ (s : Finset Œπ) (a : Finset.Nonempty s) (a : s ‚â† Finset.univ), Finset.card s < Finset.card (Finset.bunion·µ¢ s t)),\n  ‚àÉ (f : (a : Œπ) ‚Üí Œ±), (Function.Injective f : Prop) ‚àß (‚àÄ (x : Œπ), f x ‚àà t x : Prop)","name":"HallMarriageTheorem.hall_hard_inductive_step_A","isProp":true,"docString":"First case of the inductive step: assuming that\n`‚àÄ (s : Finset Œπ), s.Nonempty ‚Üí s ‚â† univ ‚Üí s.card < (s.bunion·µ¢ t).card`\nand that the statement of **Hall's Marriage Theorem** is true for all\n`Œπ'` of cardinality ‚â§ `n`, then it is true for `Œπ` of cardinality `n + 1`.\n"},{"type":"‚àÄ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (n : ‚Ñ§) (x : E), (‚Üën)‚Åª¬π ‚Ä¢ x = (‚Üën)‚Åª¬π ‚Ä¢ x","name":"inv_int_cast_smul_eq","isProp":true,"docString":"If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on inverses of integer numbers in `R` and `S`. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCancelCommMonoid Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"LinearOrderedCancelCommMonoid.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±]\n  [inst_3 : PosMulStrictMono Œ±] (ha : 1 ‚â§ a) (hb : 1 < b) (a0 : 0 < a), 1 < a * b","name":"Left.one_lt_mul_of_le_of_lt_of_pos","isProp":true,"docString":"Assumes left covariance. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : DecidableEq E] {t : Finset E} (h : ¬¨(AffineIndependent ùïú Subtype.val : Prop)) {x : E}\n  (m : x ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üët),\n  ‚àÉ (y : ‚Üë‚Üët), x ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üë(Finset.erase t ‚Üëy)","name":"Caratheodory.mem_convexHull_erase","isProp":true,"docString":"If `x` is in the convex hull of some finset `t` whose elements are not affine-independent,\nthen it is in the convex hull of a strict subset of `t`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"CanonicallyLinearOrderedSemifield.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {d : Con M} (H : ‚àÄ (x : M) (y : M), (‚Üëc x y : Prop) ‚Üî (‚Üëd x y : Prop)),\n  c = d","name":"Con.ext","isProp":true,"docString":"Extensionality rule for congruence relations. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ},\n  (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.arrows S) : Prop) ‚Üî\n    (CategoryTheory.Presieve.YonedaSheafCondition P S : Prop)","name":"CategoryTheory.Presieve.isSheafFor_iff_yonedaSheafCondition","isProp":true,"docString":"The yoneda version of the sheaf condition is equivalent to the sheaf condition.\n\nC2.1.4 of [Elephant].\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 1)}\n  {j : Fin (n + 1)} (H : i ‚â§ j),\n  CategoryTheory.CosimplicialObject.œÉ X (‚ÜëFin.castSucc i) ‚â´ CategoryTheory.CosimplicialObject.œÉ X j =\n    CategoryTheory.CosimplicialObject.œÉ X (Fin.succ j) ‚â´ CategoryTheory.CosimplicialObject.œÉ X i","name":"CategoryTheory.CosimplicialObject.œÉ_comp_œÉ","isProp":true,"docString":"The fifth cosimplicial identity "},{"type":"‚àÄ {R : Type u} [inst : Ring R], SMulCommClass { x : R // x ‚àà Subring.center R } R R","name":"Subring.center.smulCommClass_left","isProp":true,"docString":"The center of a semiring acts commutatively on that semiring. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {M : Type u_3} {M‚ÇÇ : Type u_4}\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module S M‚ÇÇ]\n  (self : M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÇ) (r : R) (x : M),\n  AddHom.toFun (LinearMap.toAddHom self) (r ‚Ä¢ x) = ‚ÜëœÉ r ‚Ä¢ AddHom.toFun (LinearMap.toAddHom self) x","name":"LinearMap.map_smul'","isProp":true,"docString":"A linear map preserves scalar multiplication.\nWe prefer the spelling `_root_.map_smul` instead. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : (a : Œ±) ‚Üí Finset Œ≤) (h : Set.Finite (Set.range f)),\n  Set.Finite (Set.union·µ¢ fun (a : Œ±) ‚Ü¶ ‚Üë(f a))","name":"Set.union_finset_finite_of_range_finite","isProp":true,"docString":"A finite union of finsets is finite. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] (c : ClosureOperator Œ±) (x : Œ±), x ‚â§ ‚Üë(ClosureOperator.toOrderHom c) x","name":"ClosureOperator.le_closure","isProp":true,"docString":"Every element is less than its closure. This property is sometimes referred to as extensivity or\ninflationarity. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {s : Set Œ±} (a : IsUpperSet s), IsLowerSet (‚ÜëOrderDual.ofDual ‚Åª¬π' s)","name":"IsUpperSet.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `isLowerSet_preimage_ofDual_iff`."},{"type":"‚àÄ {Œ± : Type u_1} (n : ‚Ñï) (s : Finset Œ±), Finset.card (Finset.powersetLen n s) = Nat.choose (Finset.card s) n","name":"Finset.card_powersetLen","isProp":true,"docString":"**Formula for the Number of Combinations** "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : sbtw a b c), sbtw c a b","name":"SBtw.sbtw.cyclic_right","isProp":true,"docString":"**Alias** of `sbtw_cyclic_right`."},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} [inst_4 : Fintype Œπ] (p : (a : Œπ) ‚Üí P),\n  (AffineIndependent k p : Prop) ‚Üî\n    (‚àÄ (w : (a : Œπ) ‚Üí k) (a : (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ w i) = 0)\n        (a : ‚Üë(Finset.weightedVSub Finset.univ p) w = 0) (i : Œπ), w i = 0 :\n      Prop)","name":"affineIndependent_iff_of_fintype","isProp":true,"docString":"A family indexed by a `Fintype` is affinely independent if and\nonly if no nontrivial weighted subtractions over `Finset.univ` (where\nthe sum of the weights is 0) are 0. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X","name":"PathConnectedSpace.Nonempty","isProp":true,"docString":"A path-connected space must be nonempty. "},{"type":"‚àÄ {X : Type u_2} {R : Type u_3} {Œπ : Type u_1} {U : (a : Œπ) ‚Üí Set X} [inst : TopologicalSpace X] [inst_1 : One R]\n  {f : (a : Œπ) ‚Üí (a : X) ‚Üí R} (hlf : LocallyFinite fun (i : Œπ) ‚Ü¶ Function.mulSupport (f i))\n  (hso : ‚àÄ (i : Œπ), mulTSupport (f i) ‚äÜ U i) (ho : ‚àÄ (i : Œπ), IsOpen (U i)) (x : X),\n  ‚àÉ (is : Finset Œπ),\n    ‚àÉ (n : Set X),\n      (n ‚àà nhds x : Prop) ‚àß\n        ((n ‚äÜ Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà is) ‚Ü¶ U i : Prop) ‚àß\n            (‚àÄ (z : X) (a : z ‚àà n), (Function.mulSupport fun (i : Œπ) ‚Ü¶ f i z) ‚äÜ ‚Üëis : Prop) :\n          Prop)","name":"LocallyFinite.exists_finset_nhd_mulSupport_subset","isProp":true,"docString":"If a family of functions `f` has locally-finite multiplicative support, subordinate to a family\nof open sets, then for any point we can find a neighbourhood on which only finitely-many members of\n`f` are not equal to 1. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : PosMulMono Œ±] (ha : 0 ‚â§ a)\n  (hb : 0 ‚â§ b), 0 ‚â§ a * b","name":"mul_nonneg","isProp":true,"docString":"**Alias** of `Left.mul_nonneg`."},{"type":"‚àÄ (u : PNat.XgcdType), PNat.XgcdType.r u + (PNat.XgcdType.bp u + 1) * PNat.XgcdType.q u = PNat.XgcdType.ap u + 1","name":"PNat.XgcdType.rq_eq","isProp":true,"docString":"Properties of division with remainder for a / b.  "},{"type":"‚àÄ {Œ± : Sort u_1} [inst : IsEmpty Œ±] (p : (a : Œ±) ‚Üí Prop), IsEmpty (Subtype p)","name":"instIsEmptySubtype","isProp":true,"docString":"subtypes of an empty type are empty "},{"type":"‚àÄ {R : Type u} {A' : Type u_1} {B' : Type u_2} [inst : CommSemiring A'] [inst_1 : Semiring B'] [inst_2 : CommSemiring R]\n  [inst_3 : Algebra R A'] [inst_4 : Algebra R B'] {f : Polynomial A' ‚Üí‚Çê[R] B'} {g : Polynomial A' ‚Üí‚Çê[R] B'}\n  (h‚ÇÅ :\n    AlgHom.comp f (IsScalarTower.toAlgHom R A' (Polynomial A')) =\n      AlgHom.comp g (IsScalarTower.toAlgHom R A' (Polynomial A')))\n  (h‚ÇÇ : ‚Üëf Polynomial.X = ‚Üëg Polynomial.X), f = g","name":"Polynomial.algHom_ext'","isProp":true,"docString":"Extensionality lemma for algebra maps out of `A'[X]` over a smaller base ring than `A'`\n"},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {Œ≥ : Sort w} {g : (a : Œ≤) ‚Üí Œ≥} (hg : Function.Surjective g),\n  Function.Surjective ((fun (x : (a : Œ≤) ‚Üí Œ≥) (x_1 : (a : Œ±) ‚Üí Œ≤) ‚Ü¶ x ‚àò x_1) g)","name":"Function.Surjective.comp_left","isProp":true,"docString":"Composition by an surjective function on the left is itself surjective. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Isometry f), UniformContinuous f","name":"Isometry.uniformContinuous","isProp":true,"docString":"An isometry from a metric space is a uniform continuous map "},{"type":"‚àÄ {Œ≤ : Type u_1} {Œ± : Type u_2} {A : (a : List Œ≤) ‚Üí Set Œ±} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : DiscreteTopology Œ≤] (hA : CantorScheme.VanishingDiam A), Continuous (Sigma.snd (CantorScheme.inducedMap A))","name":"CantorScheme.VanishingDiam.map_continuous","isProp":true,"docString":"A scheme with vanishing diameter along each branch induces a continuous map. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)]\n  [inst_1 : ‚àÄ (i : Œπ), LocallyCompactSpace (œÄ i)] [inst_2 : Finite Œπ], LocallyCompactSpace ((i : Œπ) ‚Üí œÄ i)","name":"LocallyCompactSpace.pi_finite","isProp":true,"docString":"In general it suffices that all but finitely many of the spaces are compact,\nbut that's not straightforward to state and use. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±}\n  (hs : ‚àÄ (f : (a : Œ±) ‚Üí Bool) (a : ContinuousOn f s) (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s), f x = f y),\n  IsPreconnected s","name":"isPreconnected_of_forall_constant","isProp":true,"docString":"If every map to `Bool` (a discrete two-element space), that is\ncontinuous on a set `s`, is constant on s, then s is preconnected "},{"type":"‚àÄ {k : Type u_1} [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ) (h : ‚Üë(Finset.card s) ‚â† 0),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ Finset.centroidWeights k s i) = 1","name":"Finset.sum_centroidWeights_eq_one_of_cast_card_ne_zero","isProp":true,"docString":"The weights in the centroid sum to 1, if the number of points,\nconverted to `k`, is not zero. "},{"type":"‚àÄ {Œπ : Type u_1} (self : ComplexShape Œπ) {i : Œπ} {i' : Œπ} {j : Œπ} (a : ComplexShape.Rel self i j)\n  (a : ComplexShape.Rel self i' j), i = i'","name":"ComplexShape.prev_eq","isProp":true,"docString":"There is at most one nonzero differential to `X j`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V} {g : V ‚Üí‚Çó[K] V} (hfg : f * g = 1), g * f = 1","name":"LinearMap.mul_eq_one_of_mul_eq_one","isProp":true,"docString":"In a finite-dimensional space, if linear maps are inverse to each other on one side then they\nare also inverse to each other on the other side. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (H : IsPreconnected s), IsPreconnected (closure s)","name":"IsPreconnected.closure","isProp":true,"docString":"The closure of a (pre)connected set is (pre)connected as well. "},{"type":"‚àÄ {G : Type u} [inst : Add G] [self : IsLeftCancelAdd G] (a : G) (b : G) (c : G) (a : a + b = a + c), b = c","name":"IsLeftCancelAdd.add_left_cancel","isProp":true,"docString":"Addition is left cancellative. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {r : ENNReal}\n  (H1 : ‚àÄ (x : Œ±) (a : x ‚àà s), ‚àÉ (y : Œ±), (y ‚àà t : Prop) ‚àß (edist x y ‚â§ r : Prop))\n  (H2 : ‚àÄ (x : Œ±) (a : x ‚àà t), ‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (edist x y ‚â§ r : Prop)), EMetric.hausdorffEdist s t ‚â§ r","name":"EMetric.hausdorffEdist_le_of_mem_edist","isProp":true,"docString":"Bounding the Hausdorff edistance by exhibiting, for any point in each set,\nanother point in the other set at controlled distance "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (Cf : ContinuousAt f (sup‚Çõ s)) (Af : Antitone f) (hs : Set.Nonempty s), f (sup‚Çõ s) = inf‚Çõ (f '' s)","name":"Antitone.map_sup‚Çõ_of_continuousAt'","isProp":true,"docString":"An antitone function continuous at the supremum of a nonempty set sends this supremum to\nthe infimum of the image of this set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] [inst_2 : AddCommMonoid Œ≤]\n  {Œ¥ : (a : Œ±) ‚Üí Type u_3} {t : (a : Œ±) ‚Üí Finset (Œ¥ a)} (f : (a : (a : Œ±) ‚Üí (a_1 : a ‚àà Finset.univ) ‚Üí Œ¥ a) ‚Üí Œ≤),\n  (Finset.sum (Finset.pi Finset.univ t) fun (x : (a : Œ±) ‚Üí (a_1 : a ‚àà Finset.univ) ‚Üí Œ¥ a) ‚Ü¶ f x) =\n    Finset.sum (Fintype.piFinset t) fun (x : (a : Œ±) ‚Üí Œ¥ a) ‚Ü¶ f fun (a : Œ±) (x_1 : a ‚àà Finset.univ) ‚Ü¶ x a","name":"Finset.sum_univ_pi","isProp":true,"docString":"Taking a sum over `univ.pi t` is the same as taking the sum over\n`Fintype.piFinset t`. `univ.pi t` and `Fintype.piFinset t` are essentially the same `Finset`,\nbut differ in the type of their element, `univ.pi t` is a `Finset (Œ† a ‚àà univ, t a)` and\n`Fintype.piFinset t` is a `Finset (Œ† a, t a)`."},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : TopologicalSpace A]\n  [inst_3 : Semiring A] [inst_4 : Algebra R A] [inst_5 : StarRing A] [inst_6 : StarModule R A] {S‚ÇÅ : StarSubalgebra R A}\n  {S‚ÇÇ : StarSubalgebra R A} (h : S‚ÇÅ ‚â§ S‚ÇÇ), Embedding ‚Üë(StarSubalgebra.inclusion h)","name":"StarSubalgebra.embedding_inclusion","isProp":true,"docString":"The `StarSubalgebra.inclusion` of a star subalgebra is an `Embedding`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : DecidableEq Œ≤] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (h‚ÇÅ : StrictMono f) (A : Finset Œ±) (B : Finset Œ±),\n  (Finset.toColex (Finset.image f A) < Finset.toColex (Finset.image f B) : Prop) ‚Üî\n    (Finset.toColex A < Finset.toColex B : Prop)","name":"Colex.hom_lt_iff","isProp":true,"docString":"Strictly monotone functions preserve the colex ordering. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {v : V} (p : P) {direction : Submodule k V} (hv : v ‚àà direction),\n  v +·µ• p ‚àà AffineSubspace.mk' p direction","name":"AffineSubspace.vadd_mem_mk'","isProp":true,"docString":"An affine subspace constructed from a point and a direction contains the result of adding a\nvector in that direction to that point. "},{"type":"‚àÄ {Œπ : Type u_3} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Preadditive V]\n  {c : ComplexShape Œπ} {C : HomologicalComplex V c} {D : HomologicalComplex V c} {W : Type u_1}\n  [inst_2 : CategoryTheory.Category W] [inst_3 : CategoryTheory.Preadditive W] (G : V ‚•§ W)\n  [inst_4 : CategoryTheory.Functor.Additive G]\n  (hom : (i : Œπ) ‚Üí (j : Œπ) ‚Üí HomologicalComplex.X C i ‚ü∂ HomologicalComplex.X D j),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Functor.mapHomologicalComplex G c))\n      (Homotopy.nullHomotopicMap hom) =\n    Homotopy.nullHomotopicMap fun (i : Œπ) (j : Œπ) ‚Ü¶ Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) (hom i j)","name":"Homotopy.map_nullHomotopicMap","isProp":true,"docString":"Compatibility of `nullHomotopicMap` with the application of additive functors "},{"type":"‚àÄ {Œ± : Type u_1} (f : Filter Œ±) [inst : Filter.IsCountablyGenerated f] [inst : Filter.NeBot f],\n  ‚àÉ (x : (a : ‚Ñï) ‚Üí Œ±), Filter.Tendsto x Filter.atTop f","name":"Filter.exists_seq_tendsto","isProp":true,"docString":"If `f` is a nontrivial countably generated filter, then there exists a sequence that converges\nto `f`. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} (a : Equiv.Perm.IsCycleOn 1 s), Set.Subsingleton s","name":"Equiv.Perm.IsCycleOn.subsingleton","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.isCycleOn_one`."},{"type":"‚àÄ {Œ≥ : Type w} [inst : MetricSpace Œ≥] {x : Œ≥} {y : Œ≥} (a : nndist x y = 0), x = y","name":"eq_of_nndist_eq_zero","isProp":true,"docString":"Deduce the equality of points with the vanishing of the nonnegative distance"},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : CommRing S] [inst_2 : IsDomain S] (m : R ‚Üí+* S) (d : ‚Ñï)\n  {U : Set R} (h : Set.Finite U),\n  Set.Finite\n    (Set.union·µ¢ fun (f : Polynomial R) ‚Ü¶\n      Set.union·µ¢ fun (_hf : (Polynomial.natDegree f ‚â§ d : Prop) ‚àß (‚àÄ (i : ‚Ñï), Polynomial.coeff f i ‚àà U : Prop)) ‚Ü¶\n        ‚Üë(Multiset.toFinset (Polynomial.roots (Polynomial.map m f))))","name":"Polynomial.bUnion_roots_finite","isProp":true,"docString":"The set of roots of all polynomials of bounded degree and having coefficients in a finite set\nis finite. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : MonotoneOn f s) (hs : s ‚àà nhdsWithin a (Set.Iic a))\n  (hfs : f '' s ‚àà nhdsWithin (f a) (Set.Iic (f a))), ContinuousWithinAt f (Set.Iic a) a","name":"continuousWithinAt_left_of_monotoneOn_of_image_mem_nhdsWithin","isProp":true,"docString":"If a function `f` with a densely ordered codomain is monotone on a left neighborhood of `a` and\nthe image of this neighborhood under `f` is a left neighborhood of `f a`, then `f` is continuous at\n`a` from the left. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : LinearOrder Œ≤] [inst_1 : NoMaxOrder Œ≤] {u : (a : ‚Ñï) ‚Üí Œ≤}\n  (hu : Filter.Tendsto u Filter.atTop Filter.atTop),\n  Filter.Frequently (fun (n : ‚Ñï) ‚Ü¶ ‚àÄ (k : ‚Ñï) (a : k < n), u k < u n) Filter.atTop","name":"Filter.frequently_high_scores","isProp":true,"docString":"If `u` is a sequence which is unbounded above,\nthen it `Frequently` reaches a value strictly greater than all previous values.\n"},{"type":"‚àÄ {Œ± : Sort u_1} (a : Finite Œ±), ¬¨(Infinite Œ± : Prop)","name":"Finite.not_infinite","isProp":true,"docString":"**Alias** of the reverse direction of `not_infinite_iff_finite`."},{"type":"‚àÄ {F : Type u_3} {G : Type u_1} {H : Type u_2} [inst : AddGroup G] [inst_1 : AddZeroClass H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F),\n  (Function.Injective ‚Üëf : Prop) ‚Üî (‚àÄ (a : G) (a_1 : ‚Üëf a = 0), a = 0 : Prop)","name":"injective_iff_map_eq_zero","isProp":true,"docString":"A homomorphism from an additive group to an additive monoid is injective iff\nits kernel is trivial. For the iff statement on the triviality of the kernel,\nsee `injective_iff_map_eq_zero'`."},{"type":"‚àÄ {G : Type w} [inst : AddGroup G] {g : G} {P : (a : G) ‚Üí Prop} (h_one : P 0) (h_mul : ‚àÄ (a : G) (a_1 : P a), P (a + g))\n  (h_inv : ‚àÄ (a : G) (a_1 : P a), P (a + -g)) (n : ‚Ñ§), P (n ‚Ä¢ g)","name":"zsmul_induction_right","isProp":true,"docString":"To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the right. For additive subgroups generated by more than one element,\nsee `AddSubgroup.closure_induction_right`."},{"type":"‚àÄ {Œ± : Type u_1} {r‚ÇÅ : Setoid Œ±} {r‚ÇÇ : Setoid Œ±}, (r‚ÇÅ = r‚ÇÇ : Prop) ‚Üî (Setoid.classes r‚ÇÅ = Setoid.classes r‚ÇÇ : Prop)","name":"Setoid.classes_inj","isProp":true,"docString":"Two equivalence relations are equal iff their equivalence classes are equal. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_4} {P : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] (p : (a : Œπ) ‚Üí P) {i : Œπ} {j : Œπ}\n  (hi : i ‚àà s) (hj : j ‚àà s) (c : k),\n  ‚Üë(Finset.affineCombination k s p) (Finset.affineCombinationLineMapWeights i j c) = ‚Üë(AffineMap.lineMap (p i) (p j)) c","name":"Finset.affineCombination_affineCombinationLineMapWeights","isProp":true,"docString":"An affine combination with `affineCombinationLineMapWeights` gives the result of\n`line_map`. "},{"type":"‚àÄ {F : Type u_1} {G : Type u_2} {N : Type u_3} [inst : DivisionMonoid G] [inst_1 : Monoid N]\n  [inst_2 : MonoidHomClass F G N] {x : G} (hx : IsUnit x) (f : F) (g : F) (h : ‚Üëf x = ‚Üëg x), ‚Üëf x‚Åª¬π = ‚Üëg x‚Åª¬π","name":"IsUnit.eq_on_inv","isProp":true,"docString":"If two homomorphisms from a division monoid to a monoid are equal at a unit `x`, then they are\nequal at `x‚Åª¬π`. "},{"type":"‚àÄ {X : Pointed} {Y : Pointed} (self : Pointed.Hom X Y), Pointed.Hom.toFun self (Pointed.point X) = Pointed.point Y","name":"Pointed.Hom.map_point","isProp":true,"docString":"compatibility with the distinguished points "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : (a : Œ≥) ‚Üí Œ±} {s : Set Œ≥}\n  (h : s ‚äÜ f ‚Åª¬π' LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)),\n  (ContinuousOn f s : Prop) ‚Üî (ContinuousOn (‚Üëe ‚àò f) s : Prop)","name":"LocalHomeomorph.continuousOn_iff_continuousOn_comp_left","isProp":true,"docString":"A function is continuous on a set if and only if its composition with a local homeomorphism\non the left is continuous on the corresponding set. "},{"type":"‚àÄ {M : Type u_3} {N : Type u_4} {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : SMul M Œ±] [inst_1 : SMul Œ≤ Œ±]\n  [inst_2 : SMulCommClass M Œ≤ Œ±] (g : (a : N) ‚Üí M), SMulCommClass N Œ≤ Œ±","name":"SMul.comp.smulCommClass","isProp":true,"docString":"This cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables.\n"},{"type":"‚àÄ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\n  [inst_3 : Archimedean G] (S : AddSubgroup G) (hbot : S ‚â† ‚ä•)\n  (H : ¬¨(‚àÉ (a : G), IsLeast (setOf fun (g : G) ‚Ü¶ (g ‚àà S : Prop) ‚àß (0 < g : Prop)) a : Prop)), Dense ‚ÜëS","name":"AddSubgroup.dense_of_no_min","isProp":true,"docString":"Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\nelement, then `S` is dense `G`. "},{"type":"‚àÄ {R : Type u} {M : Type v} {M‚ÇÇ : Type w} {M‚ÇÉ : Type y} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : AddCommGroup M‚ÇÇ] [inst_3 : AddCommGroup M‚ÇÉ] [inst_4 : Module R M] [inst_5 : Module R M‚ÇÇ]\n  [inst_6 : Module R M‚ÇÉ] {f : M ‚Üí‚Çó[R] M‚ÇÇ} {g : M ‚Üí‚Çó[R] M‚ÇÉ} (h : LinearMap.ker f ‚äî LinearMap.ker g = ‚ä§),\n  LinearMap.range (LinearMap.prod f g) = Submodule.prod (LinearMap.range f) (LinearMap.range g)","name":"LinearMap.range_prod_eq","isProp":true,"docString":"If the union of the kernels `ker f` and `ker g` spans the domain, then the range of\n`Prod f g` is equal to the product of `range f` and `range g`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {l : Filter Œ±} (hs : IsCompact s),\n  (Disjoint l (nhdsSet s) : Prop) ‚Üî (‚àÄ (x : Œ±) (a : x ‚àà s), Disjoint l (nhds x) : Prop)","name":"IsCompact.disjoint_nhdsSet_right","isProp":true,"docString":"A filter `l` is disjoint with the neighborhood filter of a compact set if and only if it is\ndisjoint with the neighborhood filter of each point of this set. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s : Set Œ≥} {t : Set Œ≥},\n  (BddAbove (s ‚à™ t) : Prop) ‚Üî ((BddAbove s : Prop) ‚àß (BddAbove t : Prop) : Prop)","name":"bddAbove_union","isProp":true,"docString":"The union of two sets is bounded above if and only if each of the sets is. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N]\n  (f : Submonoid.LocalizationMap S N) (x : M) (y : { x : M // x ‚àà S }),\n  ‚àÉ (c : { x : M // x ‚àà S }),\n    ‚Üëc * (‚Üë(Prod.snd (Submonoid.LocalizationMap.sec f (Submonoid.LocalizationMap.mk' f x y))) * x) =\n      ‚Üëc * (‚Üëy * Prod.fst (Submonoid.LocalizationMap.sec f (Submonoid.LocalizationMap.mk' f x y)))","name":"Submonoid.LocalizationMap.exists_of_sec_mk'","isProp":true,"docString":"Given a Localization map `f : M ‚Üí* N` for a Submonoid `S ‚äÜ M`, for all `x‚ÇÅ : M` and `y‚ÇÅ ‚àà S`,\nif `x‚ÇÇ : M, y‚ÇÇ ‚àà S` are such that `f x‚ÇÅ * (f y‚ÇÅ)‚Åª¬π * f y‚ÇÇ = f x‚ÇÇ`, then there exists `c ‚àà S`\nsuch that `x‚ÇÅ * y‚ÇÇ * c = x‚ÇÇ * y‚ÇÅ * c`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} (d : (a : ‚Ñï) ‚Üí NNReal)\n  (hf : ‚àÄ (n : ‚Ñï), edist (f n) (f (Nat.succ n)) ‚â§ ‚Üë(d n)) (hd : Summable d), CauchySeq f","name":"cauchySeq_of_edist_le_of_summable","isProp":true,"docString":"If the extended distance between consecutive points of a sequence is estimated\nby a summable series of `NNReal`s, then the original sequence is a Cauchy sequence. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [inst_1 : ProperSpace Œ±] {x : Œ±} {r : ‚Ñù} {s : Set Œ±} (hs : IsClosed s)\n  (h : s ‚äÜ Metric.ball x r), ‚àÉ (r' : ‚Ñù), (r' < r : Prop) ‚àß (s ‚äÜ Metric.ball x r' : Prop)","name":"exists_lt_subset_ball","isProp":true,"docString":"If a ball in a proper space includes a closed set `s`, then there exists a ball with the same\ncenter and a strictly smaller radius that includes `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : a < 0) (hb : b < 0), a + b < 0","name":"Right.add_neg'","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg'`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictAntiOn f s) (hg : AntitoneOn g s), StrictAntiOn (fun (x : Œ≤) ‚Ü¶ f x + g x) s","name":"StrictAntiOn.add_antitone","isProp":true,"docString":"The sum of a strictly antitone function and a antitone function is\nstrictly antitone."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] [inst_6 : Nonempty Œ≥] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ≥) ‚Üí Œ±}\n  (Cf : ContinuousAt f (sup·µ¢ fun (i : Œ≥) ‚Ü¶ g i)) (Mf : Monotone f) (H : BddAbove (Set.range g)),\n  f (sup·µ¢ fun (i : Œ≥) ‚Ü¶ g i) = sup·µ¢ fun (i : Œ≥) ‚Ü¶ f (g i)","name":"Monotone.map_csupr_of_continuousAt","isProp":true,"docString":"If a monotone function is continuous at the indexed supremum of a bounded function on\na nonempty `Sort`, then it sends this supremum to the supremum of the composition. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} [inst : AddCommMonoid Œ±] {g : (a : Œ≥) ‚Üí Œ≤} (hg : Function.Injective g)\n  {f : (a : Œ≤) ‚Üí Œ±} (hf : ‚àÄ (x : Œ≤) (a : ¬¨(x ‚àà Set.range g : Prop)), f x = 0),\n  Filter.map (fun (s : Finset Œ≥) ‚Ü¶ Finset.sum s fun (i : Œ≥) ‚Ü¶ f (g i)) Filter.atTop =\n    Filter.map (fun (s : Finset Œ≤) ‚Ü¶ Finset.sum s fun (i : Œ≤) ‚Ü¶ f i) Filter.atTop","name":"Function.Injective.map_atTop_finset_sum_eq","isProp":true,"docString":"Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`\nto an additive commutative monoid. Suppose that `f x = 0` outside of the range of `g`. Then the\nfilters `atTop.map (Œª s, ‚àë i in s, f (g i))` and `atTop.map (Œª s, ‚àë i in s, f i)` coincide.\n\nThis lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under\nthe same assumptions."},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {M : Type u_3} {v : (a : Œπ) ‚Üí M} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] {hli : LinearIndependent R v} {hsp : ‚ä§ ‚â§ Submodule.span R (Set.range v)} {i : Œπ} {j : Œπ}\n  (h : j ‚â† i), ‚Üë(Basis.coord (Basis.mk hli hsp) i) (v j) = 0","name":"Basis.mk_coord_apply_ne","isProp":true,"docString":"Given a basis, the `i`th element of the dual basis evaluates to 0 on the `j`th element of the\nbasis if `j ‚â† i`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} {y : Œ±},\n  Metric.infDist x s ‚â§ Metric.infDist y s + dist x y","name":"Metric.infDist_le_infDist_add_dist","isProp":true,"docString":"The minimal distance from `x` to `s` is bounded by the distance from `y` to `s`, modulo\nthe distance between `x` and `y` "},{"type":"‚àÄ {Œ± : Type u} {s : Set (Set Œ±)} (hs : Set.Countable s) (a : ‚àÄ (a : Set Œ±) (a_1 : a ‚àà s), Set.Countable a),\n  Set.Countable (‚ãÉ‚ÇÄ s)","name":"Set.Countable.union‚Çõ","isProp":true,"docString":"**Alias** of the reverse direction of `Set.Countable.union‚Çõ_iff`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : SemilatticeSup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f) (hg : Antitone g), Antitone (f ‚äî g)","name":"Antitone.sup","isProp":true,"docString":"Pointwise supremum of two monotone functions is a monotone function. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R ‚Üí+* S) (s : Set R),\n  Subring.map f (Subring.closure s) = Subring.closure (‚Üëf '' s)","name":"RingHom.map_closure","isProp":true,"docString":"The image under a ring homomorphism of the subring generated by a set equals\nthe subring generated by the image of the set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œ±} (a : IsOpen s), nhdsSet s = Filter.principal s","name":"IsOpen.nhdsSet_eq","isProp":true,"docString":"**Alias** of the reverse direction of `nhdsSet_eq_principal_iff`."},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : Nonempty J] {t : CategoryTheory.Limits.Trident f} (ht : CategoryTheory.Limits.IsLimit t) {Z : C} {Z' : C}\n  (q : Z' ‚ü∂ Z) (k : Z ‚ü∂ CategoryTheory.Limits.Cone.pt t),\n  ‚Üë(‚Üë(CategoryTheory.Limits.Trident.IsLimit.homIso ht Z') (q ‚â´ k)) =\n    q ‚â´ ‚Üë(‚Üë(CategoryTheory.Limits.Trident.IsLimit.homIso ht Z) k)","name":"CategoryTheory.Limits.Trident.IsLimit.homIso_natural","isProp":true,"docString":"The bijection of `Trident.IsLimit.homIso` is natural in `Z`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] {œÜ : MvPolynomial œÉ R}\n  {n : M} {w : (a : œÉ) ‚Üí M} (hœÜ : MvPolynomial.IsWeightedHomogeneous w œÜ n) (d : œÉ ‚Üí‚ÇÄ ‚Ñï)\n  (hd : ‚Üë(MvPolynomial.weightedDegree' w) d ‚â† n), MvPolynomial.coeff d œÜ = 0","name":"MvPolynomial.IsWeightedHomogeneous.coeff_eq_zero","isProp":true,"docString":"The weighted degree of a weighted homogeneous polynomial controls its support. "},{"type":"‚àÄ {G : Type u} [self : AddCommSemigroup G] (a : G) (b : G), a + b = b + a","name":"AddCommSemigroup.add_comm","isProp":true,"docString":"Addition is commutative in an additive commutative semigroup. "},{"type":"‚àÄ (k : Type u_1) [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ) [inst_1 : CharZero k] (h : Finset.Nonempty s),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ Finset.centroidWeights k s i) = 1","name":"Finset.sum_centroidWeights_eq_one_of_nonempty","isProp":true,"docString":"In the characteristic zero case, the weights in the centroid sum\nto 1 if the set is nonempty. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A + C) * Finset.card B ‚â§ Finset.card (A + B) * Finset.card (B - C)","name":"Finset.card_add_mul_le_card_add_mul_card_sub","isProp":true,"docString":"**Ruzsa's triangle inequality**. Add-add-sub version."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {r : ‚Ñù}, Metric.Bounded (Metric.sphere x r)","name":"Metric.bounded_sphere","isProp":true,"docString":"Spheres are bounded "},{"type":"‚àÄ (M : Type u_2) (Œ± : Type u_1) [inst : Monoid M] [inst_1 : MulAction M Œ±],\n  GaloisConnection (‚ÜëOrderDual.toDual ‚àò fixingSubmonoid M)\n    ((fun (P : Submonoid M) ‚Ü¶ MulAction.fixedPoints { x : M // x ‚àà P } Œ±) ‚àò ‚ÜëOrderDual.ofDual)","name":"fixingSubmonoid_fixedPoints_gc","isProp":true,"docString":"The Galois connection between fixing submonoids and fixed points of a monoid action "},{"type":"‚àÄ {Œ≤ : Type u} [inst : CommMonoid Œ≤] (f : (a : ‚Ñï) ‚Üí Œ≤) (s : (a : ‚Ñï) ‚Üí Œ≤) (base : s 0 = 1)\n  (step : ‚àÄ (n : ‚Ñï), s (n + 1) = s n * f n) (n : ‚Ñï), (Finset.prod (Finset.range n) fun (k : ‚Ñï) ‚Ü¶ f k) = s n","name":"Finset.prod_range_induction","isProp":true,"docString":"For any product along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can verify\nthat it's equal to a different function just by checking ratios of adjacent terms.\n\nThis is a multiplicative discrete analogue of the fundamental theorem of calculus. "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} (a : m ‚â§ n), ‚Üëm ‚â§ ‚Üën","name":"Int.ofNat_le_ofNat_of_le","isProp":true,"docString":"**Alias** of the reverse direction of `Int.ofNat_le`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤},\n  (Isometry f : Prop) ‚Üî (‚àÄ (x : Œ±) (y : Œ±), nndist (f x) (f y) = nndist x y : Prop)","name":"isometry_iff_nndist_eq","isProp":true,"docString":"On pseudometric spaces, a map is an isometry if and only if it preserves nonnegative\ndistances. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CompleteLattice Œ±] {t : (a : Œπ) ‚Üí Œ±} (ht : CompleteLattice.Independent t)\n  {x : Œπ} {y : Set Œπ} (hx : ¬¨(x ‚àà y : Prop)), Disjoint (t x) (sup·µ¢ fun (i : Œπ) ‚Ü¶ sup·µ¢ fun (h : i ‚àà y) ‚Ü¶ t i)","name":"CompleteLattice.Independent.disjoint_bsup·µ¢","isProp":true,"docString":"If the elements of a set are independent, then any element is disjoint from the `supr` of some\nsubset of the rest. "},{"type":"‚àÄ {G : Type u} {x : G} {y : G} [inst : CommMonoid G] (hx : IsOfFinOrder x) (hy : IsOfFinOrder y), IsOfFinOrder (x * y)","name":"IsOfFinOrder.mul","isProp":true,"docString":"Elements of finite order are closed under multiplication. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Sort x} {f : (a : Œπ) ‚Üí Filter Œ±} [hn : Nonempty Œ±]\n  (hd : Directed (fun (x : Filter Œ±) (x_1 : Filter Œ±) ‚Ü¶ x ‚â• x_1) f) (hb : ‚àÄ (i : Œπ), Filter.NeBot (f i)),\n  Filter.NeBot (inf·µ¢ f)","name":"Filter.inf·µ¢_neBot_of_directed","isProp":true,"docString":"If `f : Œπ ‚Üí Filter Œ±` is directed, `Œ±` is not empty, and `‚àÄ i, f i ‚â† ‚ä•`, then `inf·µ¢ f ‚â† ‚ä•`.\nSee also `inf·µ¢_neBot_of_directed'` for a version assuming `Nonempty Œπ` instead of `Nonempty Œ±`. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : CommSemiring R] [inst_1 : Semiring S] [inst_2 : Algebra R S] (a : Set R),\n  Submodule.span R (‚Üë(algebraMap R S) '' a) = Submodule.map (Algebra.linearMap R S) (Submodule.span R a)","name":"Submodule.span_algebraMap_image","isProp":true,"docString":"A variant of `Submodule.span_image` for `algebraMap`. "},{"type":"‚àÄ (self : CompHaus), CompactSpace (CategoryTheory.Bundled.Œ± (CompHaus.toTop self))","name":"CompHaus.is_compact","isProp":true,"docString":"The underlying topological space is compact."},{"type":"‚àÄ {M : Type u_1} {Œ± : Type u_2} [inst : SMul M Œ±] [self : MulAction.IsPretransitive M Œ±] (x : Œ±) (y : Œ±),\n  ‚àÉ (g : M), g ‚Ä¢ x = y","name":"MulAction.IsPretransitive.exists_smul_eq","isProp":true,"docString":"There is `g` such that `g ‚Ä¢ x = y`. "},{"type":"‚àÄ {Œπ : Type u_1} {M : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí Monoid (M i)] (w : FreeProduct.Word M)\n  (h : w ‚â† FreeProduct.Word.empty),\n  ‚àÉ (i : Œπ), ‚àÉ (j : Œπ), ‚àÉ (w' : FreeProduct.NeWord M i j), FreeProduct.NeWord.toWord w' = w","name":"FreeProduct.NeWord.of_word","isProp":true,"docString":"Every nonempty `Word M` can be constructed as a `NeWord M i j` "},{"type":"‚àÄ {Œ± : Type u_1} {A : Set Œ±} {Œ≤ : Type u_2} [inst : AddCommMonoid Œ±] [inst_1 : AddCommMonoid Œ≤] {n : ‚Ñï}\n  (self : A ‚Üí+[n] Œ≤) {s : Multiset Œ±} {t : Multiset Œ±} (hsA : ‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà s), x ‚àà A)\n  (htA : ‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà t), x ‚àà A) (hs : ‚ÜëMultiset.card s = n) (ht : ‚ÜëMultiset.card t = n)\n  (h : Multiset.sum s = Multiset.sum t),\n  Multiset.sum (Multiset.map (AddFreimanHom.toFun self) s) = Multiset.sum (Multiset.map (AddFreimanHom.toFun self) t)","name":"AddFreimanHom.map_sum_eq_map_sum'","isProp":true,"docString":"An additive `n`-Freiman homomorphism preserves sums of `n` elements. "},{"type":"‚àÄ {Œ± : Type u_2} {G‚ÇÄ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : GroupWithZero G‚ÇÄ] [inst_2 : MulAction G‚ÇÄ Œ±]\n  [inst_3 : ContinuousConstSMul G‚ÇÄ Œ±] {c : G‚ÇÄ} (hc : c ‚â† 0), IsClosedMap fun (x : Œ±) ‚Ü¶ c ‚Ä¢ x","name":"isClosedMap_smul_of_ne_zero","isProp":true,"docString":"`smul` is a closed map in the second argument.\n\nThe lemma that `smul` is a closed map in the first argument (for a normed space over a complete\nnormed field) is `isClosedMap_smul_left` in `Analysis.NormedSpace.FiniteDimension`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±} {t : Set Œ±} (h : x ‚àà s),\n  EMetric.infEdist x t ‚â§ EMetric.hausdorffEdist s t","name":"EMetric.infEdist_le_hausdorffEdist_of_mem","isProp":true,"docString":"The distance to a set is controlled by the Hausdorff distance "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : DecidableEq Œ±] [inst_1 : DecidableEq Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (s : Multiset Œ±)\n  (hf : Set.InjOn f (setOf fun (x : Œ±) ‚Ü¶ x ‚àà s)) (x : Œ±) (H : x ‚àà s),\n  Multiset.count (f x) (Multiset.map f s) = Multiset.count x s","name":"Multiset.count_map_eq_count","isProp":true,"docString":"`Multiset.map f` preserves `count` if `f` is injective on the set of elements contained in\nthe multiset "},{"type":"‚àÄ {F : Type u_1} {G‚ÇÄ : Type u_2} {G‚ÇÄ' : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : GroupWithZero G‚ÇÄ']\n  [inst_2 : MonoidWithZeroHomClass F G‚ÇÄ G‚ÇÄ'] (f : F) (x : G‚ÇÄ) (n : ‚Ñ§), ‚Üëf (x ^ n) = ‚Üëf x ^ n","name":"map_zpow‚ÇÄ","isProp":true,"docString":"If a monoid homomorphism `f` between two `GroupWithZero`s maps `0` to `0`, then it maps `x^n`,\n`n : ‚Ñ§`, to `(f x)^n`. "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  {f : Filter Œ±} {a : Œ±} (hl : Filter.IsBounded (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) f)\n  (hg : Filter.IsBounded (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â• x_1) f) (hs : Filter.limsup‚Çõ f = a) (hi : Filter.liminf‚Çõ f = a),\n  f ‚â§ nhds a","name":"le_nhds_of_limsup‚Çõ_eq_liminf‚Çõ","isProp":true,"docString":"If the liminf and the limsup of a filter coincide, then this filter converges to\ntheir common value, at least if the filter is eventually bounded above and below. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 : AffineSubspace k P) (s2 : AffineSubspace k P), ‚Üës1 ‚äì ‚Üës2 = ‚Üës1 ‚à© ‚Üës2","name":"AffineSubspace.inf_coe","isProp":true,"docString":"The inf of two affine subspaces, coerced to a set, is the intersection of the two sets of\npoints. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} (a : FreeGroup.Red.Step L‚ÇÅ L‚ÇÇ),\n  List.length L‚ÇÇ + 2 = List.length L‚ÇÅ","name":"FreeGroup.Red.Step.length","isProp":true,"docString":"Predicate asserting that the word `w‚ÇÅ` can be reduced to `w‚ÇÇ` in one step, i.e. there are words\n`w‚ÇÉ w‚ÇÑ` and letter `x` such that `w‚ÇÅ = w‚ÇÉxx‚Åª¬πw‚ÇÑ` and `w‚ÇÇ = w‚ÇÉw‚ÇÑ`  "},{"type":"‚àÄ {Œ± : Sort u_1} {p : (a : Œ±) ‚Üí Prop} (x : Subtype p), p ‚Üëx","name":"Subtype.prop","isProp":true,"docString":"A version of `x.property` or `x.2` where `p` is syntactically applied to the coercion of `x`\ninstead of `x.1`. A similar result is `Subtype.mem` in `Data.Set.Basic`. "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_1} (R : Type u_2) [inst : Fintype Œ±] [inst_1 : Semiring R] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] {v : (a : Œ±) ‚Üí M},\n  (‚ä§ ‚â§ Submodule.span R (Set.range v) : Prop) ‚Üî\n    (‚àÄ (x : M), ‚àÉ (c : (a : Œ±) ‚Üí R), (Finset.sum Finset.univ fun (i : Œ±) ‚Ü¶ c i ‚Ä¢ v i) = x : Prop)","name":"top_le_span_range_iff_forall_exists_fun","isProp":true,"docString":"A family `v : Œ± ‚Üí V` is generating `V` iff every element `(x : V)`\ncan be written as sum `‚àë c·µ¢ ‚Ä¢ v·µ¢ = x`.\n"},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  [inst_3 : NoZeroDivisors A] (h : Function.Injective ‚Üë(algebraMap R A)), NoZeroSMulDivisors R A","name":"NoZeroSMulDivisors.of_algebraMap_injective","isProp":true,"docString":"If `algebraMap R A` is injective and `A` has no zero divisors,\n`R`-multiples in `A` are zero only if one of the factors is zero.\n\nCannot be an instance because there is no `Injective (algebraMap R A)` typeclass.\n"},{"type":"‚àÄ {b : Ordinal} {x : Ordinal} (h : 1 < b), Set.Nonempty (setOf fun (o : Ordinal) ‚Ü¶ x < b ^ o)","name":"Ordinal.log_nonempty","isProp":true,"docString":"The set in the definition of `log` is nonempty. "},{"type":"‚àÄ {x : SimplexCategory} {y : SimplexCategory} {f : x ‚ü∂ y} (a : CategoryTheory.Epi f),\n  SimplexCategory.len y ‚â§ SimplexCategory.len x","name":"SimplexCategory.len_le_of_epi","isProp":true,"docString":"An epimorphism in `SimplexCategory` must decrease lengths"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {c : CategoryTheory.Limits.Cofork f f}\n  (h : CategoryTheory.Limits.IsColimit c), CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.œÄ c)","name":"CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_self","isProp":true,"docString":"Every coequalizer of `(f, f)` is an isomorphism. "},{"type":"‚àÄ {G : Type u_1} [inst : AddCommGroup G] (L : List G) (n : ‚Ñï) (a : G),\n  List.sum (List.set L n a) = List.sum L + if hn : (n < List.length L : Prop) then -List.nthLe L n hn + a else 0","name":"List.sum_set'","isProp":true,"docString":"Alternative version of `List.sum_set` when the list is over a group"},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {Y : CategoryTheory.Idempotents.Karoubi (CategoryTheory.SimplicialObject C)} (n : ‚Ñï),\n  CategoryTheory.Idempotents.Karoubi.Hom.f (HomologicalComplex.Hom.f AlgebraicTopology.DoldKan.PInfty n) =\n    (CategoryTheory.Idempotents.Karoubi.p Y).app (Opposite.op (SimplexCategory.mk n)) ‚â´\n      HomologicalComplex.Hom.f AlgebraicTopology.DoldKan.PInfty n","name":"AlgebraicTopology.DoldKan.karoubi_PInfty_f","isProp":true,"docString":"Given an object `Y : Karoubi (SimplicialObject C)`, this lemma\ncomputes `PInfty` for the associated object in `SimplicialObject (Karoubi C)`\nin terms of `PInfty` for `Y.X : SimplicialObject C` and `Y.p`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±}, EMetric.hausdorffEdist s s = 0","name":"EMetric.hausdorffEdist_self","isProp":true,"docString":"The Hausdorff edistance of a set to itself vanishes "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Add Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsAddHom f) (x : Œ±) (y : Œ±),\n  f (x + y) = f x + f y","name":"IsAddHom.map_add","isProp":true,"docString":"The proposition that `f` preserves addition. "},{"type":"‚àÄ {n : ‚Ñ§} {a : ‚Ñ§} {b : ‚Ñ§} (a_1 : n ‚à£ b - a), a ‚â° b [ZMOD n]","name":"Int.modEq_of_dvd","isProp":true,"docString":"**Alias** of the reverse direction of `Int.modEq_iff_dvd`."},{"type":"‚àÄ {G : Type u_2} {H : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : OrderedAddCommGroup H] {f : (a : G) ‚Üí H}\n  (h‚ÇÅ : ‚àÄ (x : G), f (-x) = -f x) (h‚ÇÇ : MonotoneOn f (Set.Ici 0)), Monotone f","name":"monotone_of_odd_of_monotoneOn_nonneg","isProp":true,"docString":"An odd function on a linear ordered additive commutative group is monotone on the whole group\nprovided that it is monotone on `Set.Ici 0`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ} {s : Set Œ±},\n  (TendstoUniformlyOn F f p s : Prop) ‚Üî\n    (Filter.Tendsto (fun (q : Œπ √ó Œ±) ‚Ü¶ (f (Prod.snd q), F (Prod.fst q) (Prod.snd q)))\n        (Filter.prod p (Filter.principal s)) (uniformity Œ≤) :\n      Prop)","name":"tendstoUniformlyOn_iff_tendsto","isProp":true,"docString":"A sequence of functions `F‚Çô` converges uniformly on a set `s` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √ó·∂† ùìü s` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `s`.\n"},{"type":"‚àÄ (Œ± : Type u) [inst : OrderedAddCommGroup Œ±],\n  ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1","name":"OrderedAddCommGroup.to_contravariantClass_left_le","isProp":true,"docString":"A choice-free shortcut instance."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : OrderedRing ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : AddCommGroup F] [inst_3 : Module ùïú E] [inst_4 : Module ùïú F] {x : E} (f : E ‚Üí·µÉ[ùïú] F) {s : Set E}\n  (hs : StarConvex ùïú x s), StarConvex ùïú (‚Üëf x) (‚Üëf '' s)","name":"StarConvex.affine_image","isProp":true,"docString":"The image of a star-convex set under an affine map is star-convex. "},{"type":"‚àÄ {Œì : Type u_1} [inst : AddGroup Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Œì T]\n  [inst_3 : ContinuousConstVAdd Œì T], IsOpenMap Quotient.mk'","name":"isOpenMap_quotient_mk'_add","isProp":true,"docString":"The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] [inst_6 : Nonempty Œ≥] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ≥) ‚Üí Œ±}\n  (Cf : ContinuousAt f (inf·µ¢ fun (i : Œ≥) ‚Ü¶ g i)) (Af : Antitone f) (H : BddBelow (Set.range g)),\n  f (inf·µ¢ fun (i : Œ≥) ‚Ü¶ g i) = sup·µ¢ fun (i : Œ≥) ‚Ü¶ f (g i)","name":"Antitone.map_cinf·µ¢_of_continuousAt","isProp":true,"docString":"A continuous antitone function sends indexed infimum to indexed supremum in conditionally\ncomplete linear order, under a boundedness assumption. "},{"type":"‚àÄ {n : ‚Ñï} {p : (a : Fin n) ‚Üí Prop} [inst : DecidablePred p],\n  (Option.isSome (Fin.find p) = true : Prop) ‚Üî (‚àÉ (i : Fin n), p i : Prop)","name":"Fin.isSome_find_iff","isProp":true,"docString":"`find p` does not return `none` if and only if `p i` holds at some index `i`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [self : SupConvergenceClass Œ±] (a : Œ±) (s : Set Œ±)\n  (a_1 : IsLUB s a), Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)","name":"SupConvergenceClass.tendsto_coe_atTop_isLUB","isProp":true,"docString":"proof that a monotone function tends to `ùìù a` as `x ‚Üí ‚àû` "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±],\n  UniformContinuous fun (p : UniformSpace.Completion Œ± √ó UniformSpace.Completion Œ±) ‚Ü¶ dist (Prod.fst p) (Prod.snd p)","name":"UniformSpace.Completion.uniformContinuous_dist","isProp":true,"docString":"The new distance is uniformly continuous. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasZeroMorphisms D] {F : C ‚•§ D}\n  [self : CategoryTheory.Functor.PreservesZeroMorphisms F] (X : C) (Y : C),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) 0 = 0","name":"CategoryTheory.Functor.PreservesZeroMorphisms.map_zero","isProp":true,"docString":"For any pair objects `F (0: X ‚ü∂  Y) = (0 : F X ‚ü∂  F Y)` "},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrderedRing Œ±] {x : Œ±} {y : Œ±},\n  (x * x + y * y = 0 : Prop) ‚Üî ((x = 0 : Prop) ‚àß (y = 0 : Prop) : Prop)","name":"mul_self_add_mul_self_eq_zero","isProp":true,"docString":"The sum of two squares is zero iff both elements are zero. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasCoproducts C]\n  [inst_2 : CategoryTheory.Limits.HasCoequalizers C], CategoryTheory.Limits.HasColimitsOfSize C","name":"CategoryTheory.Limits.has_colimits_of_hasCoequalizers_and_coproducts","isProp":true,"docString":"Any category with coproducts and coequalizers has all colimits.\n\nSee <https://stacks.math.columbia.edu/tag/002P>.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : Nonempty Œ±] [inst : NoMaxOrder Œ±], Infinite Œ±","name":"NoMaxOrder.infinite","isProp":true,"docString":"A nonempty preorder with no maximal element is infinite. This is not an instance to avoid\na cycle with `Infinite Œ± ‚Üí Nontrivial Œ± ‚Üí Nonempty Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±}, Finset.card (Finset.Iio s) = 2 ^ Finset.card s - 1","name":"Finset.card_Iio_finset","isProp":true,"docString":"Cardinality of an `Iio` of finsets. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±], HasSum (fun (x : Œ≤) ‚Ü¶ 0) 0","name":"hasSum_zero","isProp":true,"docString":"Constant zero function has sum `0` "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} (v : Vector Œ± n), List.length (Vector.toList v) = n","name":"Vector.toList_length","isProp":true,"docString":"The length of the list to which a vector of length `n` maps is `n`. "},{"type":"‚àÄ {S : Set Ordinal} (f : (a : Ordinal) ‚Üí Ordinal) (hS : Set.Unbounded (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x < x_1) S),\n  ((StrictMono f : Prop) ‚àß (Set.range f = S : Prop) : Prop) ‚Üî (f = Ordinal.enumOrd S : Prop)","name":"Ordinal.eq_enumOrd","isProp":true,"docString":"A characterization of `enumOrd`: it is the unique strict monotonic function with range `S`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 : AffineSubspace k P) (s2 : AffineSubspace k P), (s1 ‚â§ s2 : Prop) ‚Üî (‚Üës1 ‚äÜ ‚Üës2 : Prop)","name":"AffineSubspace.le_def","isProp":true,"docString":"The `‚â§` order on subspaces is the same as that on the corresponding sets. "},{"type":"‚àÄ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X","name":"OrderTopology.t5Space","isProp":true,"docString":"A linear order with order topology is a completely normal Hausdorff topological space. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : SemilatticeInf Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f) (hg : Monotone g), Monotone (f ‚äì g)","name":"Monotone.inf","isProp":true,"docString":"Pointwise infimum of two monotone functions is a monotone function. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {op : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Œ≤} [hc : IsCommutative Œ≤ op] [ha : IsAssociative Œ≤ op]\n  {f : (a : Œ±) ‚Üí Œ≤} {b : Œ≤} {s : Finset Œ±} [inst : IsIdempotent Œ≤ op] {g : (a : Œ±) ‚Üí Œ≤} (p : (a : Œ±) ‚Üí Prop)\n  [inst : DecidablePred p],\n  Finset.fold op b (fun (i : Œ±) ‚Ü¶ if (p i : Prop) then f i else g i) s =\n    op (Finset.fold op b f (Finset.filter p s)) (Finset.fold op b g (Finset.filter (fun (i : Œ±) ‚Ü¶ ¬¨(p i : Prop)) s))","name":"Finset.fold_ite","isProp":true,"docString":"A weaker version of `Finset.fold_ite'`,\nrelying on typeclass idempotency over the whole type,\ninstead of solely on the seed element.\nHowever, this is easier to use because it does not generate side goals. "},{"type":"‚àÄ {Œ± : Type u_1} (f : (a : Œ±) ‚Üí Œ±) (x : Œ±),\n  Function.periodicOrbit f x = ‚Üë(List.map (fun (n : ‚Ñï) ‚Ü¶ (f^[n]) x) (List.range (Function.minimalPeriod f x)))","name":"Function.periodicOrbit_def","isProp":true,"docString":"The definition of a periodic orbit, in terms of `List.map`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], CategoryTheory.Limits.HasZeroObject C","name":"CategoryTheory.Limits.hasZeroObject_of_hasInitial_object","isProp":true,"docString":"If there are zero morphisms, any initial object is a zero object. "},{"type":"‚àÄ {obj : Type u} [self : CategoryTheory.Groupoid obj] {X : obj} {Y : obj} (f : X ‚ü∂ Y),\n  CategoryTheory.Groupoid.inv f ‚â´ f = ùüô Y","name":"CategoryTheory.Groupoid.inv_comp","isProp":true,"docString":"`inv f` composed `f` is the identity "},{"type":"‚àÄ {Œ± : Type u_3} {Œπ : Type u_1} {Œπ' : Type u_2} [inst : DistribLattice Œ±] [inst_1 : OrderBot Œ±] [inst_2 : DecidableEq Œπ]\n  {s : Finset Œπ'} {g : (a : Œπ') ‚Üí Finset Œπ} {f : (a : Œπ) ‚Üí Œ±} (hs : Finset.SupIndep s fun (i : Œπ') ‚Ü¶ Finset.sup (g i) f)\n  (hg : ‚àÄ (i' : Œπ') (a : i' ‚àà s), Finset.SupIndep (g i') f), Finset.SupIndep (Finset.sup s g) f","name":"Finset.SupIndep.sup","isProp":true,"docString":"Bind operation for `SupIndep`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : OrderedAddCommMonoid Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c + a ‚â§ c + b","name":"OrderedAddCommMonoid.add_le_add_left","isProp":true,"docString":"Addition is monotone in an `OrderedAddCommMonoid`. "},{"type":"‚àÄ {p : ‚Ñï} (q : ‚Ñö), 0 ‚â§ padicNorm p q","name":"padicNorm.nonneg","isProp":true,"docString":"The `p`-adic norm is nonnegative. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\n  [inst_4 : NoZeroSMulDivisors K V] {n : ‚Ñï} (hn : FiniteDimensional.finrank K V = Nat.succ n), Nontrivial V","name":"FiniteDimensional.nontrivial_of_finrank_eq_succ","isProp":true,"docString":"A finite dimensional space is nontrivial if it has `finrank` equal to the successor of a\nnatural number. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (x : Œ±), CanonicallyOrderedCommSemiring.npow 0 x = 1","name":"CanonicallyOrderedCommSemiring.npow_zero","isProp":true,"docString":"Raising to the power `(0 : ‚Ñï)` gives `1`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Mul Œ±] [inst_1 : Mul Œ≤] {Œ≥ : Type u_1} [inst_2 : Mul Œ≥] {f : (a : Œ±) ‚Üí Œ≤}\n  {g : (a : Œ≤) ‚Üí Œ≥} (hf : IsMulHom f) (hg : IsMulHom g), IsMulHom (g ‚àò f)","name":"IsMulHom.comp","isProp":true,"docString":"The composition of maps which preserve multiplication, also preserves multiplication. "},{"type":"‚àÄ {Œ± : Type u_1} {r : Setoid Œ±} (a : Œ±), ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà Setoid.classes r), a ‚àà b","name":"Setoid.classes_eqv_classes","isProp":true,"docString":"Equivalence classes partition the type. "},{"type":"‚àÄ {n : ‚Ñï} {m : ‚Ñï} (e : Fin n ‚âÉo Fin m) (i : Fin n), ‚Üë(‚Üëe i) = ‚Üëi","name":"Fin.coe_orderIso_apply","isProp":true,"docString":"If `e` is an `orderIso` between `Fin n` and `Fin m`, then `n = m` and `e` is the identity\nmap. In this lemma we state that for each `i : Fin n` we have `(e i : ‚Ñï) = (i : ‚Ñï)`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : a ‚à£ b) (a_2 : b ‚à£ c), a ‚à£ c","name":"Dvd.dvd.trans","isProp":true,"docString":"**Alias** of `dvd_trans`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±) (y : Œ±), nndist x y = ENNReal.toNNReal (edist x y)","name":"nndist_edist","isProp":true,"docString":"Express `nndist` in terms of `edist`"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] (m : Œ±) (a : ‚àÉ (c : Œ±), m = c ^ 2), IsSquare m","name":"isSquare_of_exists_sq","isProp":true,"docString":"**Alias** of the reverse direction of `isSquare_iff_exists_sq`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 < a) (hb : 0 < b), 0 < a + b","name":"Left.add_pos","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos`."},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p : P} (hp : p ‚àà s),\n  vectorSpan k s = Submodule.span k ((fun (x : P) (x_1 : P) ‚Ü¶ x -·µ• x_1) p '' (s \\ {p}))","name":"vectorSpan_eq_span_vsub_set_left_ne","isProp":true,"docString":"The `vectorSpan` is the span of the pairwise subtractions with a given point on the left,\nexcluding the subtraction of that point from itself. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)), List.reverse (List.join L) = List.join (List.reverse (List.map List.reverse L))","name":"List.reverse_join","isProp":true,"docString":"Reversing a join is the same as reversing the order of parts and reversing all parts. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.IsCofilteredOrEmpty C] ‚¶ÉX : C‚¶Ñ ‚¶ÉY : C‚¶Ñ\n  (f : X ‚ü∂ Y) (g : X ‚ü∂ Y), ‚àÉ (W : C), ‚àÉ (h : W ‚ü∂ X), h ‚â´ f = h ‚â´ g","name":"CategoryTheory.IsCofilteredOrEmpty.cone_maps","isProp":true,"docString":"for every pair of parallel morphisms there exists a morphism to the left\nso the compositions are equal "},{"type":"Function.Injective fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x ‚à£ x_1","name":"Nat.dvd_left_injective","isProp":true,"docString":"`dvd` is injective in the left argument "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} (self : r ‚âÉr s) {a : Œ±}\n  {b : Œ±}, (s (‚Üë(RelIso.toEquiv self) a) (‚Üë(RelIso.toEquiv self) b) : Prop) ‚Üî (r a b : Prop)","name":"RelIso.map_rel_iff'","isProp":true,"docString":"Elements are related iff they are related after apply a `RelIso` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : Type v‚ÇÇ)\n  [inst_1 : CategoryTheory.Limits.HasCoproductsOfShape X C], CategoryTheory.Limits.HasProductsOfShape X C·µí·µñ","name":"CategoryTheory.Limits.hasProductsOfShape_opposite","isProp":true,"docString":"If `C` has coproducts indexed by `X`, then `C·µí·µñ` has products indexed by `X`.\n"},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {S : Subsemigroup M} {T : Subsemigroup M}\n  (h : ‚àÄ (x : M), (x ‚àà S : Prop) ‚Üî (x ‚àà T : Prop)), S = T","name":"Subsemigroup.ext","isProp":true,"docString":"Two subsemigroups are equal if they have the same elements. "},{"type":"‚àÄ (n : ‚Ñï), Nat.totient n = Nat.card ‚Üë(setOf fun (m : ‚Ñï) ‚Ü¶ (m < n : Prop) ‚àß (Nat.coprime n m : Prop))","name":"Nat.totient_eq_card_lt_and_coprime","isProp":true,"docString":"A characterisation of `Nat.totient` that avoids `Finset`. "},{"type":"‚àÄ {R : Type u‚ÇÅ} [inst : NonUnitalNonAssocSemiring R], IsScalarTower ‚Ñï R R","name":"NonUnitalNonAssocSemiring.nat_isScalarTower","isProp":true,"docString":"Note that `AddCommMonoid.nat_isScalarTower` requires stronger assumptions on `R`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {K : NNReal}\n  {f : (a : Œ±) ‚Üí Œ≤} (a : AntilipschitzWith K f) (x : Œ±) (y : Œ±), nndist x y ‚â§ K * nndist (f x) (f y)","name":"AntilipschitzWith.le_mul_nndist","isProp":true,"docString":"**Alias** of the forward direction of `antilipschitzWith_iff_le_mul_nndist`."},{"type":"‚àÄ {n : ‚Ñï} {x : ‚Ñï √ó ‚Ñï}, (x ‚àà Multiset.Nat.antidiagonal n : Prop) ‚Üî (Prod.fst x + Prod.snd x = n : Prop)","name":"Multiset.Nat.mem_antidiagonal","isProp":true,"docString":"A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : CommMonoid M] (s : Finset (Œ± √ó Œ≤)) (f : (a : Œ± √ó Œ≤) ‚Üí M),\n  (finprod fun (ab : Œ± √ó Œ≤) ‚Ü¶ finprod fun (_h : ab ‚àà s) ‚Ü¶ f ab) =\n    finprod fun (a : Œ±) ‚Ü¶ finprod fun (b : Œ≤) ‚Ü¶ finprod fun (_h : (a, b) ‚àà s) ‚Ü¶ f (a, b)","name":"finprod_mem_finset_product","isProp":true,"docString":"See also `finprod_mem_finset_product'`. "},{"type":"‚àÄ {a : Prop} {b : Prop} (a_1 : ‚àÄ (a : a), b) (a_2 : ¬¨(b : Prop)), ¬¨(a : Prop)","name":"Function.mt","isProp":true,"docString":"Provide modus tollens (`mt`) as dot notation for implications. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {b : Œ±}\n  (h : a < b) (s : Set Œ±),\n  List.TFAE\n    [(s ‚àà nhdsWithin b (Set.Iic b) : Prop), (s ‚àà nhdsWithin b (Set.Icc a b) : Prop),\n      (s ‚àà nhdsWithin b (Set.Ioc a b) : Prop), (‚àÉ (l : Œ±), (l ‚àà Set.Ico a b : Prop) ‚àß (Set.Ioc l b ‚äÜ s : Prop) : Prop),\n      (‚àÉ (l : Œ±), (l ‚àà Set.Iio b : Prop) ‚àß (Set.Ioc l b ‚äÜ s : Prop) : Prop)]","name":"TFAE_mem_nhdsWithin_Iic","isProp":true,"docString":"The following statements are equivalent:\n\n0. `s` is a neighborhood of `b` within `(-‚àû, b]`\n1. `s` is a neighborhood of `b` within `[a, b]`\n2. `s` is a neighborhood of `b` within `(a, b]`\n3. `s` includes `(l, b]` for some `l ‚àà [a, b)`\n4. `s` includes `(l, b]` for some `l < b` "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : Nontrivial R] [inst_2 : IsNoetherianRing R], StrongRankCondition R","name":"IsNoetherianRing.strongRankCondition","isProp":true,"docString":"Any nontrivial noetherian ring satisfies the strong rank condition.\n\nAn injective map `((Fin n ‚äï Fin (1 + m)) ‚Üí R) ‚Üí‚Çó[R] (Fin n ‚Üí R)` for some left-noetherian `R`\nwould force `Fin (1 + m) ‚Üí R ‚âÉ‚Çó PUnit` (via `IsNoetherian.equivPunitOfProdInjective`),\nwhich is not the case!\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Set Œ±},\n  (¬¨(BddAbove s : Prop) : Prop) ‚Üî (‚àÄ (x : Œ±), ‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (x < y : Prop) : Prop)","name":"not_bddAbove_iff","isProp":true,"docString":"A set `s` is not bounded above if and only if for each `x` there exists `y ‚àà s` that is greater\nthan `x`. A version for preorders is called `not_bddAbove_iff'`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {v : V} (hv : v ‚àà AffineSubspace.direction s) {p : P},\n  (v +·µ• p ‚àà s : Prop) ‚Üî (p ‚àà s : Prop)","name":"AffineSubspace.vadd_mem_iff_mem_of_mem_direction","isProp":true,"docString":"Adding a vector in the direction to a point produces a point in the subspace if and only if\nthe original point is in the subspace. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±}\n  {b : Œ±}, b - (b - a) ‚â§ a","name":"tsub_tsub_le","isProp":true,"docString":"See `tsub_tsub_cancel_of_le` for the equality. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S : Submodule R M)\n  (T : Submodule R M) (hST : T ‚â§ S) [inst_3 : DecidablePred fun (x : M ‚ß∏ T) ‚Ü¶ x ‚àà Submodule.map (Submodule.mkQ T) S]\n  [inst_4 : Fintype (M ‚ß∏ S)] [inst_5 : Fintype (M ‚ß∏ T)],\n  Fintype.card { x : M ‚ß∏ T // x ‚àà Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ‚ß∏ S) = Fintype.card (M ‚ß∏ T)","name":"Submodule.card_quotient_mul_card_quotient","isProp":true,"docString":"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace M‚ÇÇ]\n  [inst_2 : Semiring R] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M‚ÇÇ] [inst_5 : AddCommMonoid M]\n  [inst_6 : Module R M] (e : M ‚âÉL[R] M‚ÇÇ), ContinuousLinearMap.inverse ‚Üëe = ‚Üë(ContinuousLinearEquiv.symm e)","name":"ContinuousLinearMap.inverse_equiv","isProp":true,"docString":"By definition, if `f` is invertible then `inverse f = f.symm`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} {c : Œ±},\n  Finset.uIcc a c ‚äÜ Finset.uIcc a b ‚à™ Finset.uIcc b c","name":"Finset.uIcc_subset_uIcc_union_uIcc","isProp":true,"docString":"A sort of triangle inequality. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsRingHom f) {Œ≥ : Type u_1}\n  [inst_2 : Ring Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} (hg : IsRingHom g), IsRingHom (g ‚àò f)","name":"IsRingHom.comp","isProp":true,"docString":"The composition of two ring homomorphisms is a ring homomorphism. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T5Space Œ±] {p : (a : Œ±) ‚Üí Prop}, T5Space { x : Œ± // p x }","name":"instT5SpaceSubtypeInstTopologicalSpaceSubtype","isProp":true,"docString":"A subspace of a `T‚ÇÖ` space is a `T‚ÇÖ` space. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : OrderedSemiring S] (self : AbsoluteValue R S) (x : R),\n  (MulHom.toFun (AbsoluteValue.toMulHom self) x = 0 : Prop) ‚Üî (x = 0 : Prop)","name":"AbsoluteValue.eq_zero'","isProp":true,"docString":"The absolute value is positive definitive "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ), a / a * a = a","name":"div_self_mul_self","isProp":true,"docString":"Dividing `a` by itself and then multiplying by itself results in `a`, whether or not `a` is\nzero. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : (a : C) ‚Üí D}\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] (X : C) (Y : C) (Z : C),\n  (CategoryTheory.LaxMonoidal.Œº X Y ‚äó ùüô (F Z)) ‚â´\n      CategoryTheory.LaxMonoidal.Œº (X ‚äó Y) Z ‚â´ CategoryTheory.map F (CategoryTheory.Iso.hom (Œ±_ X Y Z)) =\n    CategoryTheory.Iso.hom (Œ±_ (F X) (F Y) (F Z)) ‚â´\n      (ùüô (F X) ‚äó CategoryTheory.LaxMonoidal.Œº Y Z) ‚â´ CategoryTheory.LaxMonoidal.Œº X (Y ‚äó Z)","name":"CategoryTheory.LaxMonoidal.associativity","isProp":true,"docString":"associativity of the tensorator "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} {G : Type u_4} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F]\n  [inst_2 : SeminormedGroup G] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} (hf : Filter.Tendsto f l (nhds 1))\n  (hg : Filter.IsBoundedUnder (fun (x : ‚Ñù) (x_1 : ‚Ñù) ‚Ü¶ x ‚â§ x_1) l (norm ‚àò g)) (op : (a : E) ‚Üí (a : F) ‚Üí G)\n  (h_op : ‚àÉ (A : ‚Ñù), ‚àÄ (x : E) (y : F), ‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ op (f x) (g x)) l (nhds 1)","name":"Filter.Tendsto.op_one_isBoundedUnder_le'","isProp":true,"docString":"A helper lemma used to prove that the (scalar or usual) product of a function that tends to one\nand a bounded function tends to one. This lemma is formulated for any binary operation\n`op : E ‚Üí F ‚Üí G` with an estimate `‚Äñop x y‚Äñ ‚â§ A * ‚Äñx‚Äñ * ‚Äñy‚Äñ` for some constant A instead of\nmultiplication so that it can be applied to `(*)`, `flip (*)`, `(‚Ä¢)`, and `flip (‚Ä¢)`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\n  [inst_3 : OrderedSMul R M] {a : M} {c : R} (hc : 0 < c) (a_1 : 0 < a), 0 < c ‚Ä¢ a","name":"smul_pos","isProp":true,"docString":"**Alias** of the reverse direction of `smul_pos_iff_of_pos`."},{"type":"‚àÄ {Œ± : Type u} (self : UniformSpace.Core Œ±), Filter.principal idRel ‚â§ UniformSpace.Core.uniformity self","name":"UniformSpace.Core.refl","isProp":true,"docString":"Every set in the uniformity filter includes the diagonal. "},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ], ContinuousMul Œì‚ÇÄ","name":"WithZeroTopology.instContinuousMulTopologicalSpaceToMulToMulZeroClassToMulZeroOneClassToMonoidWithZeroToGroupWithZeroToCommGroupWithZero","isProp":true,"docString":"The topology on a linearly ordered group with zero element adjoined makes it a topological\nmonoid. "},{"type":"‚àÄ {p : ‚Ñï}, padicValNat p 1 = 0","name":"padicValNat.one","isProp":true,"docString":"`padicValNat p 1` is `0` for any `p`. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {a : Œ±} {s : Set Œ±} (f : (a : Œ±) ‚Üí M) (h : ¬¨(a ‚àà s : Prop))\n  (hs : Set.Finite (s ‚à© Function.mulSupport f)),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà insert a s) ‚Ü¶ f i) =\n    f a * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i","name":"finprod_mem_insert'","isProp":true,"docString":"A more general version of `finprod_mem_insert` that requires `s ‚à© mulSupport f` rather than `s`\nto be finite. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)]\n  [inst_2 : (i : Œπ) ‚Üí Zero (Œ≤ i)], hammingNorm 0 = 0","name":"hammingNorm_zero","isProp":true,"docString":"Corresponds to `norm_zero`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : IsSuccArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico m n), r (Order.succ i) i)\n  (hmn : m ‚â§ n), Relation.ReflTransGen r n m","name":"reflTransGen_of_succ_of_ge","isProp":true,"docString":"For `m ‚â§ n`, `(n, m)` is in the reflexive-transitive closure of `~` if `succ i ~ i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ {Œ± : Type u} (s : Set (Set Œ±)) (i : WellOrder.Œ± (Quotient.out (Cardinal.ord (Cardinal.aleph 1)))),\n  Cardinal.mk ‚Üë(MeasurableSpace.generateMeasurableRec s i) ‚â§ max (Cardinal.mk ‚Üës) 2 ^ Cardinal.aleph0","name":"MeasurableSpace.cardinal_generateMeasurableRec_le","isProp":true,"docString":"At each step of the inductive construction, the cardinality bound `‚â§ (max (#s) 2) ^ ‚Ñµ‚ÇÄ` holds.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {K : NNReal}\n  {f : (a : Œ±) ‚Üí Œ≤} (a : ‚àÄ (x : Œ±) (y : Œ±), dist x y ‚â§ ‚ÜëK * dist (f x) (f y)), AntilipschitzWith K f","name":"AntilipschitzWith.of_le_mul_dist","isProp":true,"docString":"**Alias** of the reverse direction of `antilipschitzWith_iff_le_mul_dist`."},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {Œπ : Type u_1} (s : Finset Œπ) (f : (a : Œπ) ‚Üí Polynomial R) (I : Ideal R)\n  (n : (a : Œπ) ‚Üí ‚Ñï) (h : ‚àÄ (i : Œπ) (a : i ‚àà s) (k : ‚Ñï), Polynomial.coeff (f i) k ‚àà I ^ (n i - k)) (k : ‚Ñï),\n  Polynomial.coeff (Finset.prod s f) k ‚àà I ^ (Finset.sum s n - k)","name":"Polynomial.coeff_prod_mem_ideal_pow_tsub","isProp":true,"docString":"If `I` is an ideal, and `p·µ¢` is a finite family of polynomials each satisfying\n`‚àÄ k, (p·µ¢)‚Çñ ‚àà I‚Åø‚Å±‚Åª·µè` for some `n·µ¢`, then `p = ‚àè p·µ¢` also satisfies `‚àÄ k, p‚Çñ ‚àà I‚Åø‚Åª·µè` with `n = ‚àë n·µ¢`.\n"},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] {s : Set R} {p : (a : R) ‚Üí (a : R) ‚Üí Prop} {x : R} {y : R}\n  (hx : x ‚àà NonUnitalSubsemiring.closure s) (hy : y ‚àà NonUnitalSubsemiring.closure s)\n  (Hs : ‚àÄ (x : R) (a : x ‚àà s) (y : R) (a : y ‚àà s), p x y) (H0_left : ‚àÄ (x : R), p 0 x) (H0_right : ‚àÄ (x : R), p x 0)\n  (Hadd_left : ‚àÄ (x‚ÇÅ : R) (x‚ÇÇ : R) (y : R) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ + x‚ÇÇ) y)\n  (Hadd_right : ‚àÄ (x : R) (y‚ÇÅ : R) (y‚ÇÇ : R) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ + y‚ÇÇ))\n  (Hmul_left : ‚àÄ (x‚ÇÅ : R) (x‚ÇÇ : R) (y : R) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ * x‚ÇÇ) y)\n  (Hmul_right : ‚àÄ (x : R) (y‚ÇÅ : R) (y‚ÇÇ : R) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ * y‚ÇÇ)), p x y","name":"NonUnitalSubsemiring.closure_induction‚ÇÇ","isProp":true,"docString":"An induction principle for closure membership for predicates with two arguments. "},{"type":"‚àÄ {R : Type u_1} [inst : AddMonoid R] {a : R} {b : R} (h : a + b = 0), IsAddRightRegular a","name":"isAddRightRegular_of_add_eq_zero","isProp":true,"docString":"An element admitting a right additive opposite is add-right-regular."},{"type":"‚àÄ {Œ± : Type u_1} [self : Fintype Œ±] (x : Œ±), x ‚àà Fintype.elems","name":"Fintype.complete","isProp":true,"docString":"A proof that `elems` contains every element of the type "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  (Q : AffineSubspace ùïú E), Convex ùïú ‚ÜëQ","name":"AffineSubspace.convex","isProp":true,"docString":"Affine subspaces are convex. "},{"type":"‚àÄ (Œ± : Type u) [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SeparableSpace Œ±] [inst_1 : Nonempty Œ±],\n  DenseRange (TopologicalSpace.denseSeq Œ±)","name":"TopologicalSpace.denseRange_denseSeq","isProp":true,"docString":"The sequence `TopologicalSpace.denseSeq Œ±` has dense range. "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (h : Fermat42.Minimal a b c), IsCoprime a b","name":"Fermat42.coprime_of_minimal","isProp":true,"docString":"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] {s‚ÇÇ : Finset Œπ} (h : s‚ÇÇ ‚äÜ s)\n  (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) (b : P),\n  ‚Üë(Finset.weightedVSubOfPoint (s \\ s‚ÇÇ) p b) w + ‚Üë(Finset.weightedVSubOfPoint s‚ÇÇ p b) w =\n    ‚Üë(Finset.weightedVSubOfPoint s p b) w","name":"Finset.weightedVSubOfPoint_sdiff","isProp":true,"docString":"A weighted sum may be split into such sums over two subsets. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : LE Œ±] [inst_3 : ZeroLEOneClass Œ±], 0 ‚â§ 1","name":"zero_le_one","isProp":true,"docString":"`zero_le_one` with the type argument implicit. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (E : C ‚•§ D)\n  [inst_2 : CategoryTheory.IsEquivalence E] [inst_3 : CategoryTheory.Limits.HasColimitsOfSize D],\n  CategoryTheory.Limits.HasColimitsOfSize C","name":"CategoryTheory.Adjunction.has_colimits_of_equivalence","isProp":true,"docString":"Transport a `HasColimitsOfSize` instance across an equivalence. "},{"type":"‚àÄ (R : Type u_1) [inst : CommRing R] (m : ‚Ñï) (k : ‚Ñï),\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k","name":"Polynomial.Chebyshev.mul_T","isProp":true,"docString":"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. "},{"type":"‚àÄ {a : Prop} {b : Prop} [inst : Decidable (a : Prop)] (h : ‚àÄ (a : ¬¨(a : Prop)), b) (hb : ¬¨(b : Prop)), a","name":"Not.decidable_imp_symm","isProp":true,"docString":"**Alias** of `Decidable.not_imp_symm`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : a ‚â§ 0) (hb : b < 0), a + b < 0","name":"add_neg_of_nonpos_of_neg","isProp":true,"docString":"**Alias** of `Left.add_neg_of_nonpos_of_neg`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1], 0 < 4","name":"four_pos","isProp":true,"docString":"**Alias** of `zero_lt_four`."},{"type":"‚àÄ {n : ‚Ñï} {m : ‚Ñï} (h : n = m), ‚Üë(Fin.cast h) = ‚Üë(Fin.cast ((Eq.rec ((rfl=:n = n)=:n = n) h=:n = m)=:n = m))","name":"Fin.cast_eq_cast","isProp":true,"docString":"While in many cases `Fin.cast` is better than `Equiv.cast`/`cast`, sometimes we want to apply\na generic theorem about `cast`. "},{"type":"(Ordinal.type fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x < x_1) = Ordinal.omega","name":"Ordinal.type_nat_lt","isProp":true,"docString":"Note that the presence of this lemma makes `simp [omega]` form a loop. "},{"type":"Ordinal.lift = Ordinal.lift","name":"Ordinal.lift_umax'","isProp":true,"docString":"`lift.{(max v u) u}` equals `lift.{v u}`. Using `set_option pp.universes true` will make it much\neasier to understand what's happening when using this lemma. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} (s : (a : Œπ) ‚Üí Set Œ±),\n  (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ s i) =\n    Set.union·µ¢ fun (t : Finset Œπ) ‚Ü¶ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà t) ‚Ü¶ s i","name":"Set.union·µ¢_eq_union·µ¢_finset","isProp":true,"docString":"Union of an indexed family of sets `s : Œπ ‚Üí Set Œ±` is equal to the union of the unions\nof finite subfamilies. This version assumes `Œπ : Type _`. See also `union·µ¢_eq_union·µ¢_finset'` for\na version that works for `Œπ : Sort*`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} {hs : Set.Finite s} {ht : Set.Finite t} (a : s ‚äÜ t),\n  Set.Finite.toFinset hs ‚äÜ Set.Finite.toFinset ht","name":"Set.Finite.toFinset_mono","isProp":true,"docString":"**Alias** of the reverse direction of `Set.Finite.toFinset_subset_toFinset`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} (J : CategoryTheory.GrothendieckTopology C)\n  {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') (h : CategoryTheory.Presieve.IsSheaf J P), CategoryTheory.Presieve.IsSheaf J P'","name":"CategoryTheory.Presieve.isSheaf_iso","isProp":true,"docString":"The property of being a sheaf is preserved by isomorphism. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} (hf : Antitone f) (n : ‚Ñï) {x : Œ±} (h1 : f (n + 1) < x)\n  (h2 : x < f n) (a : ‚Ñï), f a ‚â† x","name":"Antitone.ne_of_lt_of_lt_nat","isProp":true,"docString":"If `f` is an antitone function from `‚Ñï` to a preorder such that `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} (self : CategoryTheory.Limits.IsZero X) (Y : C),\n  Nonempty (Unique (X ‚ü∂ Y))","name":"CategoryTheory.Limits.IsZero.unique_to","isProp":true,"docString":"there are unique morphisms to the object "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {E' : Type u_3} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =Œò[l] g), f' =Œò[l] g","name":"Asymptotics.IsTheta.of_norm_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isTheta_norm_left`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C), CategoryTheory.IsPushout 0 (ùüô X) 0 0","name":"CategoryTheory.IsPushout.zero_right","isProp":true,"docString":"The square with `0 : 0 ‚ü∂ 0` on the right and `ùüô X` on the left is a pushout square. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (IsNoetherian K V : Prop) ‚Üî (Module.Finite K V : Prop)","name":"IsNoetherian.iff_fg","isProp":true,"docString":"A module over a division ring is noetherian if and only if it is finitely generated. "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï}, (Even (m ^ n) : Prop) ‚Üî ((Even m : Prop) ‚àß (n ‚â† 0 : Prop) : Prop)","name":"Nat.even_pow","isProp":true,"docString":"If `m` and `n` are natural numbers, then the natural number `m^n` is even\nif and only if `m` is even and `n` is positive. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] {f : (a : Œ≤) ‚Üí Œ±} [inst_1 : TopologicalSpace Œ≤]\n  (hf : Inducing f) {s : Set Œ±} (hs : TopologicalSpace.IsSeparable s), TopologicalSpace.IsSeparable (f ‚Åª¬π' s)","name":"Inducing.isSeparable_preimage","isProp":true,"docString":"The preimage of a separable set by an inducing map is separable. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {k : Set G} {p : (x : G) ‚Üí (a : x ‚àà AddSubgroup.closure k) ‚Üí Prop}\n  (Hs :\n    ‚àÄ (x : G) (h : x ‚àà k),\n      p x ((AddSubgroup.subset_closure h=:x ‚àà ‚Üë(AddSubgroup.closure k))=:x ‚àà ‚Üë(AddSubgroup.closure k)))\n  (H1 : p 0 ((zero_mem (AddSubgroup.closure k)=:0 ‚àà AddSubgroup.closure k)=:0 ‚àà AddSubgroup.closure k))\n  (Hmul :\n    ‚àÄ (x : G) (hx : x ‚àà AddSubgroup.closure k) (y : G) (hy : y ‚àà AddSubgroup.closure k) (a : p x hx) (a : p y hy),\n      p (x + y) ((add_mem hx hy=:x + y ‚àà AddSubgroup.closure k)=:x + y ‚àà AddSubgroup.closure k))\n  (Hinv :\n    ‚àÄ (x : G) (hx : x ‚àà AddSubgroup.closure k) (a : p x hx),\n      p (-x) ((neg_mem hx=:-x ‚àà AddSubgroup.closure k)=:-x ‚àà AddSubgroup.closure k))\n  {x : G} (hx : x ‚àà AddSubgroup.closure k), p x hx","name":"AddSubgroup.closure_induction'","isProp":true,"docString":"A dependent version of `AddSubgroup.closure_induction`. "},{"type":"‚àÄ {Œ± : Sort u_1} (P : Prop) [inst : Decidable (P : Prop)] (x : Œ±) (y : Œ±),\n  (if (¬¨(P : Prop) : Prop) then x else y) = if (P : Prop) then y else x","name":"ite_not","isProp":true,"docString":"Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches. "},{"type":"‚àÄ {p : (a : NatOrdinal) ‚Üí Prop} (i : NatOrdinal)\n  (x : ‚àÄ (j : NatOrdinal) (a : ‚àÄ (k : NatOrdinal) (a : k < j), p k), p j), p i","name":"NatOrdinal.induction","isProp":true,"docString":"`Ordinal.induction` but for `NatOrdinal`. "},{"type":"‚àÄ {G : Type u} [inst : Add G] [self : IsRightCancelAdd G] (a : G) (b : G) (c : G) (a_1 : a + b = c + b), a = c","name":"IsRightCancelAdd.add_right_cancel","isProp":true,"docString":"Addition is right cancellative. "},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : C(Œ±, Œ≤)} {Œπ : Type u‚ÇÉ}\n  {p : Filter Œπ} {F : (a : Œπ) ‚Üí C(Œ±, Œ≤)} [inst_2 : CompactSpace Œ±],\n  (Filter.Tendsto F p (nhds f) : Prop) ‚Üî (TendstoUniformly (fun (i : Œπ) (a : Œ±) ‚Ü¶ ‚Üë(F i) a) (‚Üëf) p : Prop)","name":"ContinuousMap.tendsto_iff_tendstoUniformly","isProp":true,"docString":"Convergence in the compact-open topology is the same as uniform convergence for sequences of\ncontinuous functions on a compact space. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t) (s : CategoryTheory.Limits.Cone F)\n  (j : J),\n  CategoryTheory.Limits.IsLimit.lift self s ‚â´ (CategoryTheory.Limits.Cone.œÄ t).app j =\n    (CategoryTheory.Limits.Cone.œÄ s).app j","name":"CategoryTheory.Limits.IsLimit.fac","isProp":true,"docString":"The map makes the triangle with the two natural transformations commute "},{"type":"‚àÄ {Œ± : Type u_1} [self : Semifield Œ±], 0‚Åª¬π = 0","name":"Semifield.inv_zero","isProp":true,"docString":"The inverse of `0` in a group with zero is `0`. "},{"type":"‚àÄ (R : Type u_1) (A : Type u_2) [inst : CommSemiring R], Pi.constRingHom A R = algebraMap R ((a : A) ‚Üí R)","name":"Pi.constRingHom_eq_algebraMap","isProp":true,"docString":"When `R` is commutative and permits an `algebraMap`, `Pi.constRingHom` is equal to that\nmap. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {A : C} {B : C} {f : A ‚ü∂ B} {g : A ‚ü∂ B}\n  [inst_1 : CategoryTheory.IsCoreflexivePair f g], CategoryTheory.IsCoreflexivePair g f","name":"CategoryTheory.IsCoreflexivePair.swap","isProp":true,"docString":"If `f,g` is coreflexive, then `g,f` is coreflexive. "},{"type":"‚àÄ {Œ± : Type u_1} (r : Setoid Œ±) (s : Setoid Œ±),\n  r ‚äî s = EqvGen.Setoid fun (x : Œ±) (y : Œ±) ‚Ü¶ (Setoid.Rel r x y : Prop) ‚à® (Setoid.Rel s x y : Prop)","name":"Setoid.sup_eq_eqvGen","isProp":true,"docString":"The supremum of two equivalence relations r and s is the equivalence closure of the binary\nrelation `x is related to y by r or s`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {k : Set G} {p : (a : G) ‚Üí (a : G) ‚Üí Prop} {x : G} {y : G}\n  (hx : x ‚àà Subgroup.closure k) (hy : y ‚àà Subgroup.closure k) (Hk : ‚àÄ (x : G) (a : x ‚àà k) (y : G) (a : y ‚àà k), p x y)\n  (H1_left : ‚àÄ (x : G), p 1 x) (H1_right : ‚àÄ (x : G), p x 1)\n  (Hmul_left : ‚àÄ (x‚ÇÅ : G) (x‚ÇÇ : G) (y : G) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ * x‚ÇÇ) y)\n  (Hmul_right : ‚àÄ (x : G) (y‚ÇÅ : G) (y‚ÇÇ : G) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ * y‚ÇÇ))\n  (Hinv_left : ‚àÄ (x : G) (y : G) (a : p x y), p x‚Åª¬π y) (Hinv_right : ‚àÄ (x : G) (y : G) (a : p x y), p x y‚Åª¬π), p x y","name":"Subgroup.closure_induction‚ÇÇ","isProp":true,"docString":"An induction principle for closure membership for predicates with two arguments. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SupSet Œ±] [inst_1 : SupSet Œ≤] (self : Sup‚ÇõHom Œ± Œ≤) (s : Set Œ±),\n  Sup‚ÇõHom.toFun self (sup‚Çõ s) = sup‚Çõ (Sup‚ÇõHom.toFun self '' s)","name":"Sup‚ÇõHom.map_sup‚Çõ'","isProp":true,"docString":"The proposition that a `Sup‚ÇõHom` commutes with arbitrary suprema/joins. "},{"type":"‚àÄ {R : Type u‚ÇÅ} [inst : NonUnitalNonAssocRing R], IsScalarTower ‚Ñ§ R R","name":"NonUnitalNonAssocRing.int_isScalarTower","isProp":true,"docString":"Note that `AddCommGroup.int_isScalarTower` requires stronger assumptions on `R`. "},{"type":"‚àÄ {Œ± : Type u} {m : ‚Ñï} {n : ‚Ñï} (f : (a : Fin (m + n)) ‚Üí Œ±),\n  List.ofFn f =\n    (List.ofFn fun (i : Fin m) ‚Ü¶ f (‚Üë(Fin.castAdd n) i)) ++ List.ofFn fun (j : Fin n) ‚Ü¶ f (‚Üë(Fin.natAdd m) j)","name":"List.ofFn_add","isProp":true,"docString":"Note this matches the convention of `List.ofFn_succ'`, putting the `Fin m` elements first. "},{"type":"‚àÄ {M : Type u_2} [inst : AddCommGroup M] {R : Type u_1} (v : RayVector R M), ‚Üë(-v) = -‚Üëv","name":"RayVector.coe_neg","isProp":true,"docString":"Negating a nonzero vector commutes with coercion to the underlying module. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] ‚¶Éf : M ‚Üí‚Çô* N‚¶Ñ ‚¶Ég : M ‚Üí‚Çô* N‚¶Ñ (h : ‚Üëf = ‚Üëg), f = g","name":"MulHom.coe_inj","isProp":true,"docString":"Deprecated: use `FunLike.coe_injective` instead. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s) (h : Set.Pairwise (s \\ interior s) fun (x : E) (y : E) ‚Ü¶ Set.Nonempty (segment ùïú x y \\ frontier s)),\n  StrictConvex ùïú s","name":"Convex.strictConvex","isProp":true,"docString":"A convex set `s` is strictly convex provided that for any two distinct points `x`, `y` of\n`s \\ interior s`, the segment with endpoints `x`, `y` has nonempty intersection with\n`interior s`. "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] (m : Type v) (n : Type v) [inst_2 : Finite m]\n  [inst_3 : Finite n], Module.rank R (Matrix m n R) = Cardinal.lift (Cardinal.mk m * Cardinal.mk n)","name":"rank_matrix'","isProp":true,"docString":"If `m` and `n` are `Fintype` that lie in the same universe, the rank of `m √ó n` matrices is\n`(# n * # m).lift`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A * C) * Finset.card B ‚â§ Finset.card (A / B) * Finset.card (B / C)","name":"Finset.card_mul_mul_le_card_div_mul_card_div","isProp":true,"docString":"**Ruzsa's triangle inequality**. Add-sub-sub version. "},{"type":"‚àÄ {A : Type u_1} [inst : CommMonoid A] (a : A) (b : A) (c : A),\n  (c ‚àà Submonoid.closure {a, b} : Prop) ‚Üî (‚àÉ (m : ‚Ñï), ‚àÉ (n : ‚Ñï), a ^ m * b ^ n = c : Prop)","name":"Submonoid.mem_closure_pair","isProp":true,"docString":"An element is in the closure of a two-element set if it is a linear combination of those two\nelements. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (g : G) (p : P), g +·µ• p -·µ• p = g","name":"vadd_vsub","isProp":true,"docString":"Adding a group element then subtracting the original point\nproduces that group element. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  {W : C} {X : C} {Y : C} {Z : C} {f : W ‚ü∂ X} {g : W ‚ü∂ Y} {h : X ‚ü∂ Z} {i : Y ‚ü∂ Z}\n  [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan h i) F]\n  (s : CategoryTheory.IsPullback f g h i),\n  CategoryTheory.IsPullback (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) g)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) h)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) i)","name":"CategoryTheory.IsPullback.map","isProp":true,"docString":"**Alias** of `CategoryTheory.Functor.map_isPullback`."},{"type":"‚àÄ {Œ± : Sort u_1} [self : Infinite Œ±], ¬¨(Finite Œ± : Prop)","name":"Infinite.not_finite","isProp":true,"docString":"assertion that `Œ±` is `¬¨Finite`"},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±], 0 ‚â§ 1","name":"CanonicallyLinearOrderedSemifield.zero_le_one","isProp":true,"docString":"In a strict ordered semiring, `0 ‚â§ 1`. "},{"type":"‚àÄ {R : Type u} [inst : AddMonoid R] [self : StarAddMonoid R] (r : R) (s : R), star (r + s) = star r + star s","name":"StarAddMonoid.star_add","isProp":true,"docString":"`star` commutes with addition "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_3}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_4} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ] (f : M‚ÇÅ ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)\n  (h : Continuous (AddHom.toFun (LinearMap.toAddHom f))), ‚Üë(ContinuousLinearMap.mk f) = f","name":"ContinuousLinearMap.coe_mk","isProp":true,"docString":"Coerce continuous linear maps to functions. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±] (H : FreeGroup.Red L‚ÇÅ L‚ÇÇ),\n  FreeGroup.Red L‚ÇÇ (FreeGroup.reduce L‚ÇÅ)","name":"FreeGroup.reduce.rev","isProp":true,"docString":"If words `w‚ÇÅ w‚ÇÇ` are such that `w‚ÇÅ` reduces to `w‚ÇÇ`, then `w‚ÇÇ` reduces to the maximal reduction\nof `w‚ÇÅ`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] {f : Equiv.Perm Œ±} {c : Equiv.Perm Œ±} {a : Œ±}\n  (ha : a ‚àà Equiv.Perm.support c) (hc : c ‚àà Equiv.Perm.cycleFactorsFinset f), c = Equiv.Perm.cycleOf f a","name":"Equiv.Perm.cycle_is_cycleOf","isProp":true,"docString":"If c is a cycle, a ‚àà c.support and c is a cycle of f, then `c = f.cycleOf a` "},{"type":"‚àÄ {M : Type u_1} {Œ± : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : SMul M Œ±] [inst_2 : ContinuousConstSMul M Œ±]\n  [inst_3 : SMul M·µê·µí·µñ Œ±] [inst_4 : IsCentralScalar M Œ±], ContinuousConstSMul M·µê·µí·µñ Œ±","name":"ContinuousConstSMul.op","isProp":true,"docString":"If a scalar is central, then its right action is continuous when its left action is. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T5Space Œ±] ‚¶És : Set Œ±‚¶Ñ ‚¶Ét : Set Œ±‚¶Ñ (a : Disjoint (closure s) t)\n  (a : Disjoint s (closure t)), Disjoint (nhdsSet s) (nhdsSet t)","name":"T5Space.completely_normal","isProp":true,"docString":"If `closure s` is disjoint with `t` and `s` is disjoint with `closure t`, then `s` and `t`\nadmit disjoint neighbourhoods. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CompleteLattice Œ±] (a : Œ±) (f : (a : Œ≤) ‚Üí Œ±),\n  (sup·µ¢ fun (o : Option Œ≤) ‚Ü¶ Option.elim o a f) = a ‚äî sup·µ¢ fun (b : Œ≤) ‚Ü¶ f b","name":"sup·µ¢_option_elim","isProp":true,"docString":"A version of `sup·µ¢_option` useful for rewriting right-to-left. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] (self : DiscreteQuotient X) (x : X),\n  IsOpen (setOf (Setoid.Rel (DiscreteQuotient.toSetoid self) x))","name":"DiscreteQuotient.isOpen_setOf_rel","isProp":true,"docString":"For every point `x`, the set `{ y | Rel x y }` is a clopen set. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±), CanonicallyLinearOrderedSemifield.zpow 0 a = 1","name":"CanonicallyLinearOrderedSemifield.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : Preorder Œπ] [inst_1 : Preorder Œ±] {l : Filter Œπ} {u : (a : Œπ) ‚Üí Œ±}\n  (h : Monotone u) [inst_2 : Filter.NeBot l] (hu : Filter.Tendsto u l Filter.atTop),\n  Filter.Tendsto u Filter.atTop Filter.atTop","name":"Filter.tendsto_atTop_of_monotone_of_filter","isProp":true,"docString":"If a monotone function `u : Œπ ‚Üí Œ±` tends to `atTop` along *some* non-trivial filter `l`, then\nit tends to `atTop` along `atTop`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ±}\n  {c : Œ±} (h‚ÇÅ : AntitoneOn f s) (h‚ÇÇ : AntitoneOn f t) (hs : IsGreatest s c) (ht : IsLeast t c), AntitoneOn f (s ‚à™ t)","name":"AntitoneOn.union_right","isProp":true,"docString":"If `f` is antitone both on `s` and `t`, with `s` to the left of `t` and the center\npoint belonging to both `s` and `t`, then `f` is antitone on `s ‚à™ t` "},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Embedding L M N) {n : ‚Ñï}\n  (f : FirstOrder.Language.Functions L n) (x : (a : Fin n) ‚Üí M),\n  Function.Embedding.toFun (FirstOrder.Language.Embedding.toEmbedding self) (FirstOrder.Language.Structure.funMap f x) =\n    FirstOrder.Language.Structure.funMap f\n      (Function.Embedding.toFun (FirstOrder.Language.Embedding.toEmbedding self) ‚àò x)","name":"FirstOrder.Language.Embedding.map_fun'","isProp":true,"docString":"The homomorphism commutes with the interpretations of the function symbols "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : (a : Œ≥) ‚Üí Œ±} {s : Set Œ≥} {x : Œ≥}\n  (hx : f x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e))\n  (h : f ‚Åª¬π' LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚àà nhdsWithin x s),\n  (ContinuousWithinAt f s x : Prop) ‚Üî (ContinuousWithinAt (‚Üëe ‚àò f) s x : Prop)","name":"LocalHomeomorph.continuousWithinAt_iff_continuousWithinAt_comp_left","isProp":true,"docString":"Continuity within a set at a point can be read under left composition with a local\nhomeomorphism if a neighborhood of the initial point is sent to the source of the local\nhomeomorphism"},{"type":"‚àÄ (f : (a : Bool) ‚Üí Bool) (x : Bool), f (f (f x)) = f x","name":"Bool.apply_apply_apply","isProp":true,"docString":"**Kaminski's Equation** "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  {c : CategoryTheory.Limits.Cofork f g} (h : CategoryTheory.Limits.IsColimit c)\n  [inst_1 : CategoryTheory.Mono (CategoryTheory.Limits.Cofork.œÄ c)],\n  CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.œÄ c)","name":"CategoryTheory.Limits.isIso_limit_cocone_parallelPair_of_epi","isProp":true,"docString":"A coequalizer that is a monomorphism is an isomorphism. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (L : List G) (i : ‚Ñï) (p : i < List.length L),\n  List.prod (List.drop (i + 1) L) = (List.nthLe L i p)‚Åª¬π * List.prod (List.drop i L)","name":"List.prod_drop_succ","isProp":true,"docString":"Counterpart to `List.prod_take_succ` when we have an inverse operation "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : SemilatticeSup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f) (hg : Monotone g), Monotone (f ‚äî g)","name":"Monotone.sup","isProp":true,"docString":"Pointwise supremum of two monotone functions is a monotone function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±} {b : Œ±} (hs : BddAbove s) (ha : a ‚àà s)\n  (h : b < a), b < sup‚Çõ s","name":"lt_csup‚Çõ_of_lt","isProp":true,"docString":"`b < sup‚Çõ s` when there is an element `a` in `s` with `b < a`, when `s` is bounded above.\nThis is essentially an iff, except that the assumptions for the two implications are\nslightly different (one needs boundedness above for one direction, nonemptiness and linear\norder for the other one), so we formulate separately the two implications, contrary to\nthe `CompleteLattice` case."},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} {f : M ‚Üí* P}\n  (H : c ‚â§ Con.ker f) (g : Con.Quotient c ‚Üí* P) (Hg : MonoidHom.comp g (Con.mk' c) = f), g = Con.lift c f H","name":"Con.lift_unique","isProp":true,"docString":"The uniqueness part of the universal property for quotients of monoids. "},{"type":"‚àÄ {Œ± : Type u} {p : Set Œ±} (s : Finset Œ±) (H : ‚àÄ (x : Œ±), (x ‚àà s : Prop) ‚Üî (x ‚àà p : Prop)), Set.Finite p","name":"Set.Finite.ofFinset","isProp":true,"docString":"Construct a `Finite` instance for a `Set` from a `Finset` with the same elements. "},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤] {K : Set Œ±} {V : Set (Œ≤ √ó Œ≤)}\n  (f : C(Œ±, Œ≤)) (hK : IsCompact K) (hV : V ‚àà uniformity Œ≤),\n  ‚àÉ (Œπ : Type u‚ÇÅ),\n    ‚àÉ (x : Fintype Œπ),\n      ‚àÉ (C : (a : Œπ) ‚Üí Set Œ±),\n        ‚àÉ (_hC : ‚àÄ (i : Œπ), IsCompact (C i)),\n          ‚àÉ (U : (a : Œπ) ‚Üí Set Œ≤),\n            ‚àÉ (_hU : ‚àÄ (i : Œπ), IsOpen (U i)),\n              (f ‚àà Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ ContinuousMap.CompactOpen.gen (C i) (U i) : Prop) ‚àß\n                ((Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ ContinuousMap.CompactOpen.gen (C i) (U i)) ‚äÜ\n                    ContinuousMap.compactConvNhd K V f :\n                  Prop)","name":"ContinuousMap.inter·µ¢_compactOpen_gen_subset_compactConvNhd","isProp":true,"docString":"The point `f` in `ContinuousMap.compactConvNhd K V f` is also an interior point wrt the\ncompact-open topology.\n\nSince `ContinuousMap.compactConvNhd K V f` are a neighbourhood basis at `f` for each `f`, it follows\nthat the compact-open topology is at least as fine as the topology of compact convergence. "},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) {Œπ : Type u_3} [inst : UniformSpace Œ≤] (ùîñ : Set (Set Œ±)) (f : UniformOnFun Œ± Œ≤ ùîñ)\n  (h : Set.Nonempty ùîñ) (h' : DirectedOn (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äÜ x_1) ùîñ) {p : (a : Œπ) ‚Üí Prop}\n  {s : (a : Œπ) ‚Üí Set (Œ≤ √ó Œ≤)} (hb : Filter.HasBasis (uniformity Œ≤) p s),\n  Filter.HasBasis (nhds f) (fun (Si : Set Œ± √ó Œπ) ‚Ü¶ (Prod.fst Si ‚àà ùîñ : Prop) ‚àß (p (Prod.snd Si) : Prop))\n    fun (Si : Set Œ± √ó Œπ) ‚Ü¶\n    setOf fun (g : UniformOnFun Œ± Œ≤ ùîñ) ‚Ü¶ (g, f) ‚àà UniformOnFun.gen ùîñ (Prod.fst Si) (s (Prod.snd Si))","name":"UniformOnFun.hasBasis_nhds_of_basis","isProp":true,"docString":"For `f : Œ± ‚Üí·µ§[ùîñ] Œ≤`, where `ùîñ : Set (Set Œ±)` is nonempty and directed, `ùìù f` admits the\nfamily `{g | ‚àÄ x ‚àà S, (f x, g x) ‚àà V}` for `S ‚àà ùîñ` and `V ‚àà ùìë` as a filter basis, for any basis\n`ùìë` of `ùì§ Œ≤`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [self : TopologicalSpace.FirstCountableTopology Œ±] (a : Œ±),\n  Filter.IsCountablyGenerated (nhds a)","name":"TopologicalSpace.FirstCountableTopology.nhds_generated_countable","isProp":true,"docString":"The filter `ùìù a` is countably generated for all points `a`. "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} {m : ‚Ñï} (v : Vector Œ± m), Vector.toList (Vector.take n v) = List.take n (Vector.toList v)","name":"Vector.toList_take","isProp":true,"docString":"`take` of vectors corresponds under `toList` to `take` of lists. "},{"type":"‚àÄ (k : Type u_1) [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ) [inst_1 : CharZero k] [inst_2 : Fintype Œπ]\n  (h : Finset.card s ‚â† 0), (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ Finset.centroidWeightsIndicator k s i) = 1","name":"Finset.sum_centroidWeightsIndicator_eq_one_of_card_ne_zero","isProp":true,"docString":"In the characteristic zero case, the weights in the centroid\nindexed by a `Fintype` sum to 1 if the number of points is not\nzero. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} (H : 1 < a) (n : ‚Ñï), ‚Üën ‚â§ a ^ n / (a - 1)","name":"Nat.cast_le_pow_div_sub","isProp":true,"docString":"For any `a > 1` and a natural `n` we have `n ‚â§ a ^ n / (a - 1)`. See also\n`nat.cast_le_pow_sub_div_sub` for a stronger inequality with `a ^ n - 1` in the numerator. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : CommMonoid Œ≤] {s : Finset Œ≥} {t : Finset Œ±}\n  {f : (a : Œ≥) ‚Üí (a : Œ±) ‚Üí Œ≤},\n  (Finset.prod (s √ó·∂† t) fun (x : Œ≥ √ó Œ±) ‚Ü¶ f (Prod.fst x) (Prod.snd x)) =\n    Finset.prod s fun (x : Œ≥) ‚Ü¶ Finset.prod t fun (y : Œ±) ‚Ü¶ f x y","name":"Finset.prod_product'","isProp":true,"docString":"An uncurried version of `Finset.prod_product`. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï}\n  (IH :\n    ‚àÄ (M : Matrix (Fin r) (Fin r) ùïú),\n      ‚àÉ (L‚ÇÄ : List (Matrix.TransvectionStruct (Fin r) ùïú)),\n        ‚àÉ (L‚ÇÄ' : List (Matrix.TransvectionStruct (Fin r) ùïú)),\n          ‚àÉ (D‚ÇÄ : (a : Fin r) ‚Üí ùïú),\n            Matrix.mul (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L‚ÇÄ)) M)\n                (List.prod (List.map Matrix.TransvectionStruct.toMatrix L‚ÇÄ')) =\n              Matrix.diagonal D‚ÇÄ)\n  (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú),\n  ‚àÉ (L : List (Matrix.TransvectionStruct (Fin r ‚äï Unit) ùïú)),\n    ‚àÉ (L' : List (Matrix.TransvectionStruct (Fin r ‚äï Unit) ùïú)),\n      ‚àÉ (D : (a : Fin r ‚äï Unit) ‚Üí ùïú),\n        Matrix.mul (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L)) M)\n            (List.prod (List.map Matrix.TransvectionStruct.toMatrix L')) =\n          Matrix.diagonal D","name":"Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal_induction","isProp":true,"docString":"Inductive step for the reduction: if one knows that any size `r` matrix can be reduced to\ndiagonal form by elementary operations, then one deduces it for matrices over `Fin r ‚äï Unit`. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {d : Con M}, c ‚äî d = conGen (Setoid.r ‚äî Setoid.r)","name":"Con.sup_def","isProp":true,"docString":"The supremum of two congruence relations equals the smallest congruence relation containing\nthe supremum of the underlying binary operations. "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] {s : Set R} {t : Subsemiring R},\n  (Subsemiring.closure s ‚â§ t : Prop) ‚Üî (s ‚äÜ ‚Üët : Prop)","name":"Subsemiring.closure_le","isProp":true,"docString":"A subsemiring `S` includes `closure s` if and only if it includes `s`. "},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : (a : X) ‚Üí Y)\n  (h :\n    ‚àÄ (x : X),\n      ‚àÉ (e : LocalHomeomorph X Y),\n        (x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) : Prop) ‚àß\n          (‚àÄ (y : X) (a : y ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)), f y = ‚Üëe y : Prop)),\n  IsLocallyHomeomorph f","name":"IsLocallyHomeomorph.mk","isProp":true,"docString":"Proves that `f` satisfies `IsLocallyHomeomorph f`. The condition `h` is weaker than the\ndefinition of `IsLocallyHomeomorph f`, since it only requires `e : LocalHomeomorph X Y` to\nagree with `f` on its source `e.source`, as opposed to on the whole space `X`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C],\n  CategoryTheory.preadditiveYoneda ‚ãô\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.whiskeringRight C·µí·µñ AddCommGroupCat (Type v)))\n        (CategoryTheory.forget AddCommGroupCat) =\n    CategoryTheory.yoneda","name":"CategoryTheory.whiskering_preadditiveYoneda","isProp":true,"docString":"Composing the preadditive yoneda embedding with the forgetful functor yields the regular\nYoneda embedding.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {x : Œ± √ó Œ≤} (hf : ContinuousAt f (Prod.fst x)),\n  ContinuousAt (fun (x : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst x)) x","name":"ContinuousAt.fst''","isProp":true,"docString":"Precomposing `f` with `Prod.fst` is continuous at `x : Œ± √ó Œ≤` "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {f : Filter Œ±} {g : Filter Œ≤}\n  {m : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥} {n : (a : Œ≤) ‚Üí Œ≤'} {m' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {n' : (a : Œ¥) ‚Üí Œ≥}\n  (h_right_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), m a (n b) = n' (m' b a)),\n  Filter.map‚ÇÇ m f (Filter.map n g) = Filter.map n' (Filter.map‚ÇÇ m' g f)","name":"Filter.map_map‚ÇÇ_right_anticomm","isProp":true,"docString":"Symmetric statement to `Filter.map_map‚ÇÇ_antidistrib_right`. "},{"type":"‚àÄ {Œ∑ : Type u_1} {Gs : (a : Œ∑) ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (Gs i)] (H : (i : Œ∑) ‚Üí Subgroup (Gs i))\n  (K : (i : Œ∑) ‚Üí Subgroup (Gs i)),\n  ‚ÅÖSubgroup.pi Set.univ H, Subgroup.pi Set.univ K‚ÅÜ ‚â§ Subgroup.pi Set.univ fun (i : Œ∑) ‚Ü¶ ‚ÅÖH i, K i‚ÅÜ","name":"Subgroup.commutator_pi_pi_le","isProp":true,"docString":"The commutator of direct product is contained in the direct product of the commutators.\n\nSee `commutator_pi_pi_of_finite` for equality given `Fintype Œ∑`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {Œ¥ : Type u_1} [inst_4 : LinearOrder Œ¥] [inst_5 : TopologicalSpace Œ¥]\n  [inst_6 : OrderClosedTopology Œ¥] {f : (a : Œ±) ‚Üí Œ¥} (hf : Continuous f)\n  (h_top : Filter.Tendsto f Filter.atTop Filter.atTop) (h_bot : Filter.Tendsto f Filter.atBot Filter.atBot),\n  Function.Surjective f","name":"Continuous.surjective","isProp":true,"docString":"A continuous function which tendsto `Fitler.atTop` along `Filter.atTop` and to `atBot` along\n`at_bot` is surjective. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : EMetricSpace Œ≥] {s : Set Œ≥} (hs : IsCompact s),\n  ‚àÉ (t : Set Œ≥), (t ‚äÜ s : Prop) ‚àß ((Set.Countable t : Prop) ‚àß (s = closure t : Prop) : Prop)","name":"EMetric.countable_closure_of_compact","isProp":true,"docString":"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : (a : Fin n) ‚Üí Œ±},\n  (Tuple.sort f = Equiv.refl (Fin n) : Prop) ‚Üî (Monotone f : Prop)","name":"Tuple.sort_eq_refl_iff_monotone","isProp":true,"docString":"The permutation that sorts `f` is the identity if and only if `f` is monotone. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M ‚Üí* N), ‚Üëf 1 = 1","name":"MonoidHom.map_one","isProp":true,"docString":"If `f` is a monoid homomorphism then `f 1 = 1`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_1} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±] {f : (a : Œ≤) ‚Üí Œ±}\n  [inst_2 : AddCommMonoid Œ≥] [inst_3 : TopologicalSpace Œ≥] {G : Type u_2} [inst_4 : AddEquivClass G Œ± Œ≥] (g : G)\n  (hg : Continuous ‚Üëg) (hg' : Continuous (EquivLike.inv g)), (Summable (‚Üëg ‚àò f) : Prop) ‚Üî (Summable f : Prop)","name":"Summable.map_iff_of_equiv","isProp":true,"docString":"A special case of `Summable.map_iff_of_leftInverse` for convenience "},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E} (hs : Convex ‚Ñù s) {x : E}\n  (hx : x ‚àà interior s) (t : ‚Ñù) (ht : 1 < t), s ‚äÜ interior (‚Üë(AffineMap.homothety x t) '' s)","name":"Convex.subset_interior_image_homothety_of_one_lt","isProp":true,"docString":"If we dilate a convex set about a point in its interior by a scale `t > 1`, the interior of\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (x : Œ±) (C : Set Œ±),\n  (AccPt x (Filter.principal C) : Prop) ‚Üî (ClusterPt x (Filter.principal (C \\ {x})) : Prop)","name":"acc_principal_iff_cluster","isProp":true,"docString":"`x` is an accumulation point of a set `C` iff it is a cluster point of `C ‚àñ {x}`."},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {f : (a : X) ‚Üí Y} (hf : IsLocallyConstant f) {s : Set X}\n  (hs : IsPreconnected s) {x : X} {y : X} (hx : x ‚àà s) (hy : y ‚àà s), f x = f y","name":"IsLocallyConstant.apply_eq_of_isPreconnected","isProp":true,"docString":"A locally constant function is constant on any preconnected set. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  {f : X ‚ü∂ Y} [self : CategoryTheory.NormalEpi f], CategoryTheory.NormalEpi.g ‚â´ f = 0","name":"CategoryTheory.NormalEpi.w","isProp":true,"docString":"A normal epimorphism is a morphism which is the cokernel of some morphism. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} (h : SameRay R x y), SameRay R y x","name":"SameRay.symm","isProp":true,"docString":"`SameRay` is symmetric. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsTerminal X) (f : X ‚ü∂ Y),\n  CategoryTheory.Mono f","name":"CategoryTheory.Limits.IsTerminal.mono_from","isProp":true,"docString":"Any morphism from a terminal object is mono. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {W : C} {X : C} {Y : C} {Z : C} {f : W ‚ü∂ X} {g : W ‚ü∂ Y} {h : X ‚ü∂ Z}\n  {i : Y ‚ü∂ Z} (p : CategoryTheory.CommSq f g h i),\n  CategoryTheory.CommSq (Quiver.Hom.op i) (Quiver.Hom.op h) (Quiver.Hom.op g) (Quiver.Hom.op f)","name":"CategoryTheory.CommSq.op","isProp":true,"docString":"The commutative square in the opposite category associated to a commutative square. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤] (f : (a : Œ±) ‚Üí Œ≤) {n : ‚Ñï}\n  (hn : Fintype.card Œ± < Fintype.card Œ≤ * n),\n  ‚àÉ (y : Œ≤), Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ) < n","name":"Fintype.exists_card_fiber_lt_of_card_lt_mul","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at most as many pigeons as\nthe floor of the average number of pigeons across all pigeonholes.\n(\"The minimum is at most the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `Œ±` and `Œ≤` and a number `n` such that\n`card Œ± < card Œ≤ * n`, there exists an element `y : Œ≤` such that its preimage has less than `n`\nelements. "},{"type":"‚àÄ {Œ± : Type u_1} (P : (a : Œ±) ‚Üí Prop) (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop)\n  (h :\n    ‚àÄ (s : Finset Œ±) (a : ‚àÄ (x : Œ±) (a : x ‚àà s), P x), ‚àÉ (y : Œ±), (P y : Prop) ‚àß (‚àÄ (x : Œ±) (a : x ‚àà s), r x y : Prop)),\n  ‚àÉ (f : (a : ‚Ñï) ‚Üí Œ±), (‚àÄ (n : ‚Ñï), P (f n) : Prop) ‚àß (‚àÄ (m : ‚Ñï) (n : ‚Ñï) (a : m < n), r (f m) (f n) : Prop)","name":"exists_seq_of_forall_finset_exists","isProp":true,"docString":"Induction principle to build a sequence, by adding one point at a time satisfying a given\nrelation with respect to all the previously chosen points.\n\nMore precisely, Assume that, for any finite set `s`, one can find another point satisfying\nsome relation `r` with respect to all the points in `s`. Then one may construct a\nfunction `f : ‚Ñï ‚Üí Œ±` such that `r (f m) (f n)` holds whenever `m < n`.\nWe also ensure that all constructed points satisfy a given predicate `P`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : Dense s) (ht : Dense t) (hso : IsOpen s),\n  Dense (s ‚à© t)","name":"Dense.inter_of_open_left","isProp":true,"docString":"The intersection of an open dense set with a dense set is a dense set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤),\n  ContinuousMap.comp (Homeomorph.toContinuousMap (Homeomorph.symm f)) (Homeomorph.toContinuousMap f) =\n    ContinuousMap.id Œ±","name":"Homeomorph.symm_comp_toContinuousMap","isProp":true,"docString":"Left inverse to a continuous map from a homeomorphism, mirroring `Equiv.symm_comp_self`. "},{"type":"‚àÄ {R : Type u_2} {E : Type u_3} {Œπ : Type u_1} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E]\n  [inst_2 : Module R E] (s : Finset Œπ) (w‚ÇÅ : (a : Œπ) ‚Üí R) (w‚ÇÇ : (a : Œπ) ‚Üí R) (z : (a : Œπ) ‚Üí E)\n  (hw‚ÇÅ : (Finset.sum s fun (i : Œπ) ‚Ü¶ w‚ÇÅ i) = 1) (hw‚ÇÇ : (Finset.sum s fun (i : Œπ) ‚Ü¶ w‚ÇÇ i) = 1) (a : R) (b : R)\n  (hab : a + b = 1),\n  a ‚Ä¢ Finset.centerMass s w‚ÇÅ z + b ‚Ä¢ Finset.centerMass s w‚ÇÇ z =\n    Finset.centerMass s (fun (i : Œπ) ‚Ü¶ a * w‚ÇÅ i + b * w‚ÇÇ i) z","name":"Finset.centerMass_segment","isProp":true,"docString":"A convex combination of two centers of mass is a center of mass as well. This version\nworks if two centers of mass share the set of original points. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : (a : Œ±) ‚Üí Set Œ≤} {x : Œ±} (xs : x ‚àà s),\n  (Set.inter·µ¢ fun (x : Œ±) ‚Ü¶ Set.inter·µ¢ fun (h : x ‚àà s) ‚Ü¶ t x) ‚äÜ t x","name":"Set.binter·µ¢_subset_of_mem","isProp":true,"docString":"A specialization of `inter·µ¢‚ÇÇ_subset`. "},{"type":"‚àÄ {Œ± : Type u_1} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [wo : IsWellOrder Œ± r] {s : Set (Set Œ±)} (h‚ÇÅ : Set.Unbounded r (‚ãÉ‚ÇÄ s))\n  (h‚ÇÇ : Cardinal.mk ‚Üës < StrictOrder.cof r), ‚àÉ (x : Set Œ±), (x ‚àà s : Prop) ‚àß (Set.Unbounded r x : Prop)","name":"Ordinal.unbounded_of_unbounded_union‚Çõ","isProp":true,"docString":"If the union of s is unbounded and s is smaller than the cofinality,\nthen s has an unbounded member "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : Set P), AffineSubspace.direction (affineSpan k s) = vectorSpan k s","name":"direction_affineSpan","isProp":true,"docString":"The direction of the affine span is the `vectorSpan`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (p : X ‚ü∂ Y) (q : Z = Y),\n  Eq.mpr ((congrArg (fun (W : C) ‚Ü¶ X ‚ü∂ W) q=:(X ‚ü∂ Z) = (X ‚ü∂ Y))=:(X ‚ü∂ Z) = (X ‚ü∂ Y)) p =\n    p ‚â´ CategoryTheory.eqToHom ((Eq.symm q=:Y = Z)=:Y = Z)","name":"CategoryTheory.congrArg_mpr_hom_right","isProp":true,"docString":"If we (perhaps unintentionally) perform equational rewriting on\nthe target object of a morphism,\nwe can replace the resulting `_.mpr f` term by a composition with an `eqToHom`.\n\nIt may be advisable to introduce any necessary `eqToHom` morphisms manually,\nrather than relying on this lemma firing.\n"},{"type":"‚àÄ {C : Type v} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X : C} {Y : C}\n  {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} (h : f = g)\n  (x : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.ConcreteCategory.Forget) X),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget C)) f x =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget C)) g x","name":"CategoryTheory.congr_hom","isProp":true,"docString":"Analogue of `congr_fun h x`,\nwhen `h : f = g` is an equality between morphisms in a concrete category.\n"},{"type":"‚àÄ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)","name":"Group.normalClosure.is_normal","isProp":true,"docString":"The normal closure of s is a normal subgroup. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasCoequalizer f g] (h : f = g),\n  CategoryTheory.IsIso (CategoryTheory.Limits.coequalizer.œÄ f g)","name":"CategoryTheory.Limits.coequalizer.œÄ_of_eq","isProp":true,"docString":"The coequalizer of `(f, g)`, where `f = g`, is an isomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : UniformSpace Œ≤] {f : (a : Œ≥) ‚Üí Œ±},\n  UniformContinuous fun (g : UniformFun Œ± Œ≤) ‚Ü¶ ‚ÜëUniformFun.ofFun (g ‚àò f)","name":"UniformFun.precomp_uniformContinuous","isProp":true,"docString":"Pre-composition by a any function is uniformly continuous for the uniform structures of\nuniform convergence.\n\nMore precisely, for any `f : Œ≥ ‚Üí Œ±`, the function `(Œª g, g ‚àò f) : (Œ± ‚Üí·µ§ Œ≤) ‚Üí (Œ≥ ‚Üí·µ§ Œ≤)` is uniformly\ncontinuous. "},{"type":"‚àÄ {Œ± : Type u_1} (self : TwoPointing Œ±), Prod.fst (TwoPointing.toProd self) ‚â† Prod.snd (TwoPointing.toProd self)","name":"TwoPointing.fst_ne_snd","isProp":true,"docString":"`fst` and `snd` are distinct terms "},{"type":"‚àÄ {R : Type u_2} {R‚ÇÇ : Type u_3} {M : Type u_1} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R‚ÇÇ] [inst_4 : AddCommMonoid M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  {s : Set M} {f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} {g : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (H : Set.EqOn (‚Üëf) (‚Üëg) s) ‚¶Éx : M‚¶Ñ (h : x ‚àà Submodule.span R s),\n  ‚Üëf x = ‚Üëg x","name":"LinearMap.eqOn_span","isProp":true,"docString":"If two linear maps are equal on a set `s`, then they are equal on `submodule.span s`.\n\nSee also `linear_map.eq_on_span'` for a version using `set.eq_on`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} (c : Œ±),\n  (Metric.Bounded s : Prop) ‚Üî (‚àÉ (r : ‚Ñù), s ‚äÜ Metric.closedBall c r : Prop)","name":"Metric.bounded_iff_subset_ball","isProp":true,"docString":"Given a point, a bounded subset is included in some ball around this point "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Antitone f) {x : Œ±}\n  [inst_4 : TopologicalSpace Œ±] [inst_5 : OrderTopology Œ±],\n  (ContinuousAt f x : Prop) ‚Üî (Function.leftLim f x = Function.rightLim f x : Prop)","name":"Antitone.continuousAt_iff_leftLim_eq_rightLim","isProp":true,"docString":"An antitone function is continuous at a point if and only if its left and right limits\ncoincide. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasCofilteredLimitsOfSize C]\n  (I : Type w) [inst_1 : CategoryTheory.Category I] [inst_2 : CategoryTheory.IsCofiltered I],\n  CategoryTheory.Limits.HasLimitsOfShape I C","name":"CategoryTheory.Limits.HasCofilteredLimitsOfSize.HasLimitsOfShape","isProp":true,"docString":"For all filtered types of size `w`, we have limits "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Mul Œ±] [inst_2 : ContinuousMul Œ±], ContinuousMul Œ±·µê·µí·µñ","name":"MulOpposite.instContinuousMulMulOppositeInstTopologicalSpaceMulOppositeMul","isProp":true,"docString":"If multiplication is continuous in `Œ±`, then it also is in `Œ±·µê·µí·µñ`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : D ‚•§ C} (adj : F ‚ä£ G) (B : D),\n  CategoryTheory.IsReflexivePair\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F)\n      (Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) ((CategoryTheory.Adjunction.counit adj).app B)))\n    ((CategoryTheory.Adjunction.counit adj).app\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F)\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) B)))","name":"CategoryTheory.instIsReflexivePairObjToQuiverToCategoryStructToQuiverToCategoryStructToPrefunctorObjToPrefunctorObjToPrefunctorCompIdMapMapAppCounit","isProp":true,"docString":"For an adjunction `F ‚ä£ G` with counit `Œµ`, the pair `(FGŒµ_B, Œµ_FGB)` is reflexive. "},{"type":"‚àÄ {M : Type u_2} {N : Type u_3} [inst : Monoid M] [inst_1 : Monoid N] {F : Type u_1} [inst_2 : MonoidHomClass F M N·µê·µí·µñ]\n  (f : F) (l : List M),\n  MulOpposite.unop (‚Üëf (List.prod l)) = List.prod (List.reverse (List.map (MulOpposite.unop ‚àò ‚Üëf) l))","name":"unop_map_list_prod","isProp":true,"docString":"A morphism into the opposite monoid acts on the product by acting on the reversed elements. "},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : C(Œ±, Œ≤)} {Œπ : Type u‚ÇÉ}\n  {p : Filter Œπ} {F : (a : Œπ) ‚Üí C(Œ±, Œ≤)} (hŒ± : ‚àÄ (x : Œ±), ‚àÉ (n : Set Œ±), (IsCompact n : Prop) ‚àß (n ‚àà nhds x : Prop))\n  (h : Filter.Tendsto F p (nhds f)), TendstoLocallyUniformly (fun (i : Œπ) (a : Œ±) ‚Ü¶ ‚Üë(F i) a) (‚Üëf) p","name":"ContinuousMap.tendstoLocallyUniformly_of_tendsto","isProp":true,"docString":"If every point has a compact neighbourhood, then convergence in the compact-open topology\nimplies locally uniform convergence.\n\nSee also `ContinuousMap.tendsto_iff_tendstoLocallyUniformly`, especially for T2 spaces. "},{"type":"‚àÄ {K : Type u} [self : Field K] (n : ‚Ñï) (a : K), Field.zpow (Int.negSucc n) a = (Field.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"Field.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (self : Finpartition a),\n  Finset.sup (Finpartition.parts self) id = a","name":"Finpartition.supParts","isProp":true,"docString":"The supremum of the partition is `a` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  [self : CategoryTheory.Faithful F] {X : C} {Y : C},\n  Function.Injective (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F))","name":"CategoryTheory.Faithful.map_injective","isProp":true,"docString":"`F.map` is injective for each `X Y : C`. "},{"type":"‚àÄ {œÑ : Type u_1} [inst : TopologicalSpace œÑ] [inst_1 : AddCommGroup œÑ] [inst_2 : TopologicalAddGroup œÑ] {Œ± : Type u_2}\n  [inst_3 : TopologicalSpace Œ±] (f : Filter œÑ) (œï : Flow œÑ Œ±) (s : Set Œ±)\n  (hf : ‚àÄ (t : œÑ), Filter.Tendsto (fun (x : œÑ) ‚Ü¶ x + t) f f) (t : œÑ),\n  omegaLimit f (Flow.toFun œï) (Flow.toFun œï t '' s) = omegaLimit f (Flow.toFun œï) s","name":"Flow.omegaLimit_image_eq","isProp":true,"docString":"the œâ-limit of a forward image of `s` is the same as the œâ-limit of `s`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} {M : Type u_1} {R : Type u_2} [inst : AddMonoid M] [inst_1 : Monoid R]\n  [inst_2 : DistribMulAction R M] {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (r : R) (v : Œ≤ ‚Üí‚ÇÄ M),\n  Finsupp.comapDomain f (r ‚Ä¢ v)\n      ((Function.Injective.injOn hf\n            (f ‚Åª¬π'\n              ‚Üë(Finsupp.support\n                  (r ‚Ä¢\n                    v)))=:Set.InjOn f\n            (f ‚Åª¬π' ‚Üë(Finsupp.support (r ‚Ä¢ v))))=:Set.InjOn f (f ‚Åª¬π' ‚Üë(Finsupp.support (r ‚Ä¢ v)))) =\n    r ‚Ä¢\n      Finsupp.comapDomain f v\n        ((Function.Injective.injOn hf\n              (f ‚Åª¬π'\n                ‚Üë(Finsupp.support\n                    v))=:Set.InjOn f (f ‚Åª¬π' ‚Üë(Finsupp.support v)))=:Set.InjOn f (f ‚Åª¬π' ‚Üë(Finsupp.support v)))","name":"Finsupp.comapDomain_smul_of_injective","isProp":true,"docString":"A version of `Finsupp.comapDomain_smul` that's easier to use. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {A : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category A]\n  (J : CategoryTheory.GrothendieckTopology C) (P : C·µí·µñ ‚•§ A),\n  (CategoryTheory.Presheaf.IsSheaf J P : Prop) ‚Üî\n    (‚àÄ ‚¶ÉX : C‚¶Ñ (S : CategoryTheory.Sieve X) (a : S ‚àà CategoryTheory.GrothendieckTopology.sieves J X),\n        Nonempty\n          (CategoryTheory.Limits.IsLimit\n            (CategoryTheory.Functor.mapCone P\n              (CategoryTheory.Limits.Cocone.op (CategoryTheory.Presieve.cocone (CategoryTheory.Sieve.arrows S))))) :\n      Prop)","name":"CategoryTheory.Presheaf.isSheaf_iff_isLimit","isProp":true,"docString":"A presheaf `P` is a sheaf for the Grothendieck topology `J` iff for every covering sieve\n`S` of `J`, the natural cone associated to `P` and `S` is a limit cone. "},{"type":"‚àÄ {G : Type u_1} [inst : CommGroup G] {n : ‚Ñ§} {s : Set G} (hs : (fun (x : G) ‚Ü¶ x ^ n) ‚Åª¬π' s = s) {g : G} {j : ‚Ñï}\n  (hg : g ^ n ^ j = 1), g ‚Ä¢ s = s","name":"smul_eq_self_of_preimage_zpow_eq_self","isProp":true,"docString":"Let `n : ‚Ñ§` and `s` a subset of a commutative group `G` that is invariant under preimage for\nthe map `x ‚Ü¶ x^n`. Then `s` is invariant under the pointwise action of the subgroup of elements\n`g : G` such that `g^(n^j) = 1` for some `j : ‚Ñï`. (This subgroup is called the Pr√ºfer subgroup when\n `G` is the `Circle` and `n` is prime.) "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ","name":"Univ.isSubmonoid","isProp":true,"docString":"A monoid is a submonoid of itself. "},{"type":"‚àÄ {K : Type u_1} [inst : LinearOrderedField K] {a : K} {b : K} {c : K} (ha : a ‚â† 0)\n  (h : ‚àÄ (x : K), 0 < a * x * x + b * x + c), discrim a b c < 0","name":"discrim_lt_zero","isProp":true,"docString":"If a polynomial of degree 2 is always positive, then its discriminant is negative,\nat least when the coefficient of the quadratic term is nonzero.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {R : CategoryTheory.Sieve X}\n  (J : CategoryTheory.GrothendieckTopology C) (rj : R ‚àà CategoryTheory.GrothendieckTopology.sieves J X)\n  (sj : S ‚àà CategoryTheory.GrothendieckTopology.sieves J X), R ‚äì S ‚àà CategoryTheory.GrothendieckTopology.sieves J X","name":"CategoryTheory.GrothendieckTopology.intersection_covering","isProp":true,"docString":"The intersection of two covering sieves is covering.\n\nSee <https://stacks.math.columbia.edu/tag/00Z5> (1), or [MM92] Chapter III,\nSection 2, Definition 1 (iv).\n"},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {M : Type u_3} [inst : SMul G H] [inst_1 : Group G] [inst_2 : Group H]\n  [inst_3 : Monoid M] [inst_4 : MulAction G M] [inst_5 : SMulCommClass G M M] [inst_6 : MulAction H M]\n  [inst_7 : SMulCommClass H M M] [inst_8 : IsScalarTower G M M] [inst_9 : IsScalarTower H M M]\n  [inst_10 : IsScalarTower G H M], IsScalarTower G H MÀ£","name":"Units.isScalarTower'","isProp":true,"docString":"Transfer `IsScalarTower G H M` to `IsScalarTower G H MÀ£` "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} (a_1 : a < b + c), a - c < b","name":"sub_right_lt_of_lt_add","isProp":true,"docString":"**Alias** of the reverse direction of `sub_lt_iff_lt_add`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±],\n  (TotallyDisconnectedSpace Œ± : Prop) ‚Üî (TotallySeparatedSpace Œ± : Prop)","name":"compact_t2_tot_disc_iff_tot_sep","isProp":true,"docString":"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (g : Y ‚ü∂ Z)\n  [inst_1 : CategoryTheory.Limits.HasEqualizers C] (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.IsIso f]\n  [inst_3 : CategoryTheory.Limits.HasImage g], CategoryTheory.IsIso (CategoryTheory.Limits.image.preComp f g)","name":"CategoryTheory.Limits.image.isIso_precomp_iso","isProp":true,"docString":"`image.preComp f g` is an isomorphism when `f` is an isomorphism\n(we need `C` to have equalizers to prove this).\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofilteredOrEmpty C] {i : C} {j : C}\n  {j' : C} (f : j ‚ü∂ i) (f' : j' ‚ü∂ i), ‚àÉ (k : C), ‚àÉ (g : k ‚ü∂ j), ‚àÉ (g' : k ‚ü∂ j'), g ‚â´ f = g' ‚â´ f'","name":"CategoryTheory.IsCofiltered.cospan","isProp":true,"docString":"For every cospan `j ‚ü∂ i ‚üµ j'`,\nthere exists a cone `j ‚üµ k ‚ü∂ j'` such that the square commutes. "},{"type":"‚àÄ {R : Type u_1} [inst : AddSemigroup R] {a : R} {b : R} (ab : IsAddRegular (a + b)) (ba : IsAddRegular (b + a)),\n  (IsAddRegular a : Prop) ‚àß (IsAddRegular b : Prop)","name":"IsAddRegular.and_of_add_of_add","isProp":true,"docString":"The \"most used\" implication of `add_and_add_iff`, with split\nhypotheses, instead of `‚àß`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Nonempty Œ±] [inst : SemilatticeSup Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f), (Filter.Tendsto f Filter.atTop Filter.atTop : Prop) ‚Üî (‚àÄ (b : Œ≤), ‚àÉ (a : Œ±), b ‚â§ f a : Prop)","name":"Monotone.tendsto_atTop_atTop_iff","isProp":true,"docString":"**Alias** of `Filter.tendsto_atTop_atTop_iff_of_monotone`."},{"type":"‚àÄ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M}\n  (hU : U ‚àà nhds 0), ‚àÉ (V : Set M), (IsOpen V : Prop) ‚àß ((0 ‚àà V : Prop) ‚àß (V + V ‚äÜ U : Prop) : Prop)","name":"exists_open_nhds_zero_add_subset","isProp":true,"docString":"Given a open neighborhood `U` of `0` there is a open neighborhood `V` of `0`\nsuch that `V + V ‚äÜ U`."},{"type":"‚àÄ {R : Type u} [inst : Ring R] {Œì‚ÇÄ : Type v} [inst_1 : LinearOrderedCommGroupWithZero Œì‚ÇÄ] (v : Valuation R Œì‚ÇÄ),\n  RingSubgroupsBasis fun (Œ≥ : Œì‚ÇÄÀ£) ‚Ü¶ Valuation.ltAddSubgroup v Œ≥","name":"Valuation.subgroups_basis","isProp":true,"docString":"The basis of open subgroups for the topology on a ring determined by a valuation. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {ta1 : TopologicalSpace Œ±}\n  {ta2 : TopologicalSpace Œ±} {tb1 : TopologicalSpace Œ≤} {tb2 : TopologicalSpace Œ≤} {tc1 : TopologicalSpace Œ≥}\n  (h : Continuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)),\n  Continuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)","name":"continuous_inf_dom_right‚ÇÇ","isProp":true,"docString":"A version of `continuous_inf_dom_right` for binary functions "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_1} [inst : UniformSpace Œ±] {f : (a : Œ±) ‚Üí Œ≥} [inst_1 : TopologicalSpace Œ≥]\n  [inst_2 : Zero Œ≥] (h : HasCompactSupport f), Filter.Tendsto f (Filter.cocompact Œ±) (nhds 0)","name":"HasCompactSupport.is_zero_at_infty","isProp":true,"docString":"If `f` has compact support, then `f` tends to zero at infinity."},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero M] [inst_1 : AddCommMonoid N] {s : Finset Œ±}\n  {f : (a : Œ±) ‚Üí M} {g : (a : Œ±) ‚Üí (a : M) ‚Üí N} (hf : ‚àÄ (a : Œ±) (a_1 : f a ‚â† 0), a ‚àà s) (hg : ‚àÄ (a : Œ±), g a 0 = 0),\n  Finsupp.sum (Finsupp.onFinset s f hf) g = Finset.sum s fun (a : Œ±) ‚Ü¶ g a (f a)","name":"Finsupp.onFinset_sum","isProp":true,"docString":"If `g` maps a second argument of 0 to 0, summing it over the\nresult of `onFinset` is the same as summing it over the original `Finset`."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f : (a : Œ±) ‚Üí E}\n  {s : Set Œ±} {c : Œ±} {y : E} (h : IsMaxOn (norm ‚àò f) s c) (hy : SameRay ‚Ñù (f c) y),\n  IsMaxOn (fun (x : Œ±) ‚Ü¶ ‚Äñf x + y‚Äñ) s c","name":"IsMaxOn.norm_add_sameRay","isProp":true,"docString":"If `f : Œ± ‚Üí E` is a function such that `norm ‚àò f` has a maximum on a set `s` at a point `c` and\n`y` is a vector on the same ray as `f c`, then the function `fun x => ‚Äñf x + y‚Äñ` has a maximum\non `s` at `c`. "},{"type":"‚àÄ {s : Set ‚Ñï} (hs : Set.Infinite s) {k : ‚Ñï} (hk : 0 < k),\n  ‚àÉ (m : ‚Ñï), (m ‚àà s : Prop) ‚àß (‚àÉ (n : ‚Ñï), (n ‚àà s : Prop) ‚àß ((m < n : Prop) ‚àß (m ‚â° n [MOD k] : Prop) : Prop) : Prop)","name":"Nat.exists_lt_modEq_of_infinite","isProp":true,"docString":"If `s` is an infinite set of natural numbers and `k > 0`, then `s` contains two elements `m < n`\nthat are equal mod `k`. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] [inst_1 : AddMonoid M] {S : Set (AddMonoidAlgebra R M)}\n  (hS : Algebra.adjoin R S = ‚ä§),\n  Algebra.adjoin R\n      (Set.union·µ¢ fun (f : AddMonoidAlgebra R M) ‚Ü¶\n        Set.union·µ¢ fun (h : f ‚àà S) ‚Ü¶ AddMonoidAlgebra.of' R M '' ‚Üë(Finsupp.support f)) =\n    ‚ä§","name":"AddMonoidAlgebra.support_gen_of_gen","isProp":true,"docString":"If a set `S` generates, as algebra, `AddMonoidAlgebra R M`, then the set of supports of\nelements of `S` generates `AddMonoidAlgebra R M`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] {s : Set Œ±} {b : Œ±} (hs : Set.Nonempty s)\n  (hb : b < sup‚Çõ s), ‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (b < a : Prop)","name":"exists_lt_of_lt_csup‚Çõ","isProp":true,"docString":"When `b < sup‚Çõ s`, there is an element `a` in `s` with `b < a`, if `s` is nonempty and the order\nis a linear order. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (s : Set Œ±), LipschitzWith 1 fun (x : Œ±) ‚Ü¶ Metric.infNndist x s","name":"Metric.lipschitz_infNndist_pt","isProp":true,"docString":"The minimal distance to a set (as `‚Ñù‚â•0`) is Lipschitz in point with constant 1 "},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} [inst : FirstOrder.Language.Structure L M]\n  [h : Nonempty (FirstOrder.Language.Constants L)], Nonempty M","name":"FirstOrder.Language.nonempty_of_nonempty_constants","isProp":true,"docString":"Given a language with a nonempty type of constants, any structure will be nonempty. This cannot\nbe a global instance, because `L` becomes a metavariable. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (self : Finpartition a),\n  Finset.SupIndep (Finpartition.parts self) id","name":"Finpartition.supIndep","isProp":true,"docString":"The partition is supremum-independent "},{"type":"‚àÄ {V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_1} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ]\n  (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ) {M : ‚Ñù} (hMp : 0 ‚â§ M) (hM : ‚àÄ (x : V‚ÇÅ), ‚Äñ‚Üëf x‚Äñ ‚â§ M * ‚Äñx‚Äñ), ‚Äñf‚Äñ ‚â§ M","name":"NormedAddGroupHom.opNorm_le_bound","isProp":true,"docString":"If one controls the norm of every `f x`, then one controls the norm of `f`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeSup Œ±] (s : Set Œ±) (a : Œ±) (a_1 : a ‚àà s), a ‚â§ sup‚Çõ s","name":"CompleteSemilatticeSup.le_sup‚Çõ","isProp":true,"docString":"Any element of a set is less than the set supremum. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (s : Submodule K V),\n  (Submodule.Fg s : Prop) ‚Üî (FiniteDimensional K { x : V // x ‚àà s } : Prop)","name":"Submodule.fg_iff_finiteDimensional","isProp":true,"docString":"A submodule is finitely generated if and only if it is finite-dimensional "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : ‚àÄ {X : C} {Y : C} (f : X ‚ü∂ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\n  CategoryTheory.Limits.HasImages C","name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.hasImages","isProp":true,"docString":"A category in which coimage-image comparisons are all isomorphisms has images. "},{"type":"‚àÄ {X : Type v} {Y : Type w} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\n  [inst_3 : ParacompactSpace Y], ParacompactSpace (X √ó Y)","name":"instParacompactSpaceProdInstTopologicalSpaceProd","isProp":true,"docString":"The product of a compact space and a paracompact space is a paracompact space. The formalization\nis based on https://dantopology.wordpress.com/2009/10/24/compact-x-paracompact-is-paracompact/\nwith some minor modifications.\n\nThis version assumes that `X` in `X √ó Y` is compact and `Y` is paracompact, see next lemma for the\nother case. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  [inst_2 : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)],\n  CategoryTheory.IsSplitEpi CategoryTheory.Limits.prod.fst","name":"CategoryTheory.Limits.isSplitEpi_prod_fst","isProp":true,"docString":"In the presence of zero morphisms, projections into a product are (split) epimorphisms. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {b : Œ±} (ha : a < 0) (hb : b < 0),\n  (1 / a ‚â§ 1 / b : Prop) ‚Üî (b ‚â§ a : Prop)","name":"one_div_le_one_div_of_neg","isProp":true,"docString":"For the single implications with fewer assumptions, see `one_div_lt_one_div_of_neg_of_lt` and\n`lt_of_one_div_lt_one_div` "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : Nonempty J]\n  (h :\n    ‚àÄ (j‚ÇÅ : J) (j‚ÇÇ : J),\n      ‚àÉ (l : List J),\n        (List.Chain CategoryTheory.Zag j‚ÇÅ l : Prop) ‚àß\n          (List.getLast (j‚ÇÅ :: l) ((List.cons_ne_nil j‚ÇÅ l=:j‚ÇÅ :: l ‚â† [])=:j‚ÇÅ :: l ‚â† []) = j‚ÇÇ : Prop)),\n  CategoryTheory.IsConnected J","name":"CategoryTheory.isConnected_of_zigzag","isProp":true,"docString":"If any two objects in an nonempty category are linked by a sequence of (potentially reversed)\nmorphisms, then J is connected.\n\nThe converse of `exists_zigzag'`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} {b : Œ±} (ha : 0 < a) (hb : 0 < b),\n  (1 / a ‚â§ 1 / b : Prop) ‚Üî (b ‚â§ a : Prop)","name":"one_div_le_one_div","isProp":true,"docString":"For the single implications with fewer assumptions, see `one_div_le_one_div_of_le` and\n`le_of_one_div_le_one_div` "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] {p : Polynomial R} {q : Polynomial R} (a : R) (hzero : p + q ‚â† 0),\n  min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) ‚â§ Polynomial.rootMultiplicity a (p + q)","name":"Polynomial.rootMultiplicity_add","isProp":true,"docString":"The multiplicity of `p + q` is at least the minimum of the multiplicities. "},{"type":"‚àÄ {n : ‚Ñï} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : ‚ÜëFin.castSucc j < i),\n  SimplexCategory.Œ¥ (Fin.succ i) ‚â´ SimplexCategory.œÉ (‚ÜëFin.castSucc j) = SimplexCategory.œÉ j ‚â´ SimplexCategory.Œ¥ i","name":"SimplexCategory.Œ¥_comp_œÉ_of_gt","isProp":true,"docString":"The fourth simplicial identity "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] ‚¶Éf : OneHom M N‚¶Ñ ‚¶Ég : OneHom M N‚¶Ñ (h : ‚Üëf = ‚Üëg), f = g","name":"OneHom.coe_inj","isProp":true,"docString":"Deprecated: use `FunLike.coe_injective` instead. "},{"type":"‚àÄ {n : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (a_1 : a ‚â° b [MOD n]), ‚Üën ‚à£ ‚Üëb - ‚Üëa","name":"Nat.ModEq.dvd","isProp":true,"docString":"**Alias** of the forward direction of `Nat.modEq_iff_dvd`."},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : NoZeroSMulDivisors K V] [inst_4 : StrongRankCondition K] (v : V) (h : ‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w),\n  FiniteDimensional.finrank K V ‚â§ 1","name":"finrank_le_one","isProp":true,"docString":"If every vector is a multiple of some `v : V`, then `V` has dimension at most one.\n"},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {k : Set G} {p : (a : G) ‚Üí (a : G) ‚Üí Prop} {x : G} {y : G}\n  (hx : x ‚àà AddSubgroup.closure k) (hy : y ‚àà AddSubgroup.closure k)\n  (Hk : ‚àÄ (x : G) (a : x ‚àà k) (y : G) (a : y ‚àà k), p x y) (H1_left : ‚àÄ (x : G), p 0 x) (H1_right : ‚àÄ (x : G), p x 0)\n  (Hmul_left : ‚àÄ (x‚ÇÅ : G) (x‚ÇÇ : G) (y : G) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ + x‚ÇÇ) y)\n  (Hmul_right : ‚àÄ (x : G) (y‚ÇÅ : G) (y‚ÇÇ : G) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ + y‚ÇÇ))\n  (Hinv_left : ‚àÄ (x : G) (y : G) (a : p x y), p (-x) y) (Hinv_right : ‚àÄ (x : G) (y : G) (a : p x y), p x (-y)), p x y","name":"AddSubgroup.closure_induction‚ÇÇ","isProp":true,"docString":"An induction principle for additive closure membership, for\npredicates with two arguments."},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M} (self : IsSubmonoid s) {a : M} {b : M} (a_1 : a ‚àà s) (a_2 : b ‚àà s),\n  a * b ‚àà s","name":"IsSubmonoid.mul_mem","isProp":true,"docString":"The proposition that s is closed under multiplication. "},{"type":"‚àÄ {M : Type u_1} {A : Type u_2} [inst : Monoid M] [inst_1 : AddMonoid A] [self : DistribMulAction M A] (a : M),\n  a ‚Ä¢ 0 = 0","name":"DistribMulAction.smul_zero","isProp":true,"docString":"Multiplying `0` by a scalar gives `0` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : DiscreteTopology Œ±] {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥}\n  (hf : ‚àÄ (a : Œ±), Continuous (f a)), Continuous (Function.uncurry f)","name":"continuous_uncurry_of_discreteTopology","isProp":true,"docString":"If a function `f x y` is such that `y ‚Ü¶ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {s : Set Œ±} {t : (a : Œπ) ‚Üí Set Œ±} (i : Œπ) (h : s ‚äÜ t i),\n  s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ t i","name":"Set.subset_union·µ¢_of_subset","isProp":true,"docString":"This rather trivial consequence of `subset_union·µ¢`is convenient with `apply`, and has `i`\nexplicit for this purpose. "},{"type":"‚àÄ (K : Type u) {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (s : Finset V),\n  FiniteDimensional K { x : V // x ‚àà Submodule.span K ‚Üës }","name":"FiniteDimensional.span_finset","isProp":true,"docString":"The submodule generated by a finset is finite-dimensional. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P) (s : Set P) (a : p ‚àà s), p ‚àà spanPoints k s","name":"mem_spanPoints","isProp":true,"docString":"A point in a set is in its affine span. "},{"type":"‚àÄ {Œπa : Type u_4} {Œπb : Type u_6} [inst : Fintype Œπa] [inst_1 : Fintype Œπb] {R' : Type u_1} {M·µ¢ : Type u_2}\n  {N‚ÇÅ : Type u_3} {N‚ÇÇ : Type u_5} [inst_2 : CommSemiring R'] [inst_3 : AddCommGroup N‚ÇÅ] [inst_4 : Module R' N‚ÇÅ]\n  [inst_5 : AddCommGroup N‚ÇÇ] [inst_6 : Module R' N‚ÇÇ] [inst_7 : AddCommMonoid M·µ¢] [inst_8 : Module R' M·µ¢]\n  [inst_9 : DecidableEq Œπa] [inst_10 : DecidableEq Œπb] (a : AlternatingMap R' M·µ¢ N‚ÇÅ Œπa) (b : AlternatingMap R' M·µ¢ N‚ÇÇ Œπb)\n  (œÉ : Equiv.Perm.ModSumCongr Œπa Œπb) {v : (a : Œπa ‚äï Œπb) ‚Üí M·µ¢} {i : Œπa ‚äï Œπb} {j : Œπa ‚äï Œπb} (hv : v i = v j)\n  (hij : i ‚â† j),\n  ‚Üë(AlternatingMap.domCoprod.summand a b œÉ) v + ‚Üë(AlternatingMap.domCoprod.summand a b (Equiv.swap i j ‚Ä¢ œÉ)) v = 0","name":"AlternatingMap.domCoprod.summand_add_swap_smul_eq_zero","isProp":true,"docString":"Swapping elements in `œÉ` with equal values in `v` results in an addition that cancels "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] (f : R ‚Üí+* S) (n : ‚Ñï),\n  Polynomial.X ^ n ‚àà Polynomial.lifts f","name":"Polynomial.X_pow_mem_lifts","isProp":true,"docString":"The polynomial `X ^ n` lifts. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] (self : ClosureOperator Œ±) (x : Œ±), x ‚â§ ‚Üë(ClosureOperator.toOrderHom self) x","name":"ClosureOperator.le_closure'","isProp":true,"docString":"An element is less than or equal its closure "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] (g : GroupTopology Œ±), Continuous fun (p : Œ± √ó Œ±) ‚Ü¶ Prod.fst p * Prod.snd p","name":"GroupTopology.continuous_mul'","isProp":true,"docString":"A version of the global `continuous_mul` suitable for dot notation. "},{"type":"‚àÄ {R : Type u} [self : Ring R] (n : ‚Ñï), IntCast.intCast (Int.negSucc n) = -‚Üë(n + 1)","name":"Ring.intCast_negSucc","isProp":true,"docString":"The canonical homorphism `‚Ñ§ ‚Üí R` for negative values is just the negation of the values\nof the canonical homomorphism `‚Ñï ‚Üí R`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] (self : M ‚Üí*‚ÇÄ N),\n  ZeroHom.toFun (‚Üëself) 1 = 1","name":"MonoidWithZeroHom.map_one'","isProp":true,"docString":"The proposition that the function preserves 1 "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±}, Nonempty ‚Üë(Set.Iic a)","name":"Set.nonempty_Iic_subtype","isProp":true,"docString":"An interval `Iic a` is nonempty. "},{"type":"‚àÄ {F : Type u_3} {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : BooleanAlgebra Œ±] [inst_1 : BooleanAlgebra Œ≤]\n  [inst_2 : BoundedLatticeHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a \\ b) = ‚Üëf a \\ ‚Üëf b","name":"map_sdiff'","isProp":true,"docString":"Special case of `map_sdiff` for boolean algebras. "},{"type":"‚àÄ {X : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E]\n  [inst_2 : TopologicalSpace X] {f : (a : X) ‚Üí E} {c : X} (h : IsLocalMax (norm ‚àò f) c),\n  IsLocalMax (fun (x : X) ‚Ü¶ ‚Äñf x + f c‚Äñ) c","name":"IsLocalMax.norm_add_self","isProp":true,"docString":"If `f : Œ± ‚Üí E` is a function such that `norm ‚àò f` has a local maximum at a point `c`, then the\nfunction `fun x => ‚Äñf x + f c‚Äñ` has a local maximum at `c`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} (Mf : Monotone f) (x : Œ±),\n  Filter.Tendsto f (nhdsWithin x (Set.Ioi x)) (nhds (inf‚Çõ (f '' Set.Ioi x)))","name":"Monotone.tendsto_nhdsWithin_Ioi","isProp":true,"docString":"A monotone map has a limit to the right of any point `x`, equal to `inf‚Çõ (f '' (Ioi x))`. "},{"type":"‚àÄ {Œ± : Type u} {L : List Œ±} {L' : List Œ±} (h : L = L') {i : ‚Ñï} (hi : i < List.length L),\n  List.nthLe L i hi = List.nthLe L' i ((Eq.rec hi h=:i < List.length L')=:i < List.length L')","name":"List.nthLe_of_eq","isProp":true,"docString":"If one has `nthLe L i hi` in a formula and `h : L = L'`, one can not `rw h` in the formula as\n`hi` gives `i < L.length` and not `i < L'.length`. The lemma `nth_le_of_eq` can be used to make\nsuch a rewrite, with `rw (nth_le_of_eq h)`. "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroSMulDivisors R M] {x : M} {y : M},\n  ((SameRay R x y : Prop) ‚à® (SameRay R x (-y) : Prop) : Prop) ‚Üî (¬¨(LinearIndependent R ![x, y] : Prop) : Prop)","name":"sameRay_or_sameRay_neg_iff_not_linearIndependent","isProp":true,"docString":"Two vectors are in the same ray, or the first is in the same ray as the negation of the\nsecond, if and only if they are not linearly independent. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : OpenEmbedding f), IsOpen (Set.range f)","name":"OpenEmbedding.open_range","isProp":true,"docString":"The range of an open embedding is an open set. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : Filter Œ±}, IsClosed (setOf fun (x : Œ±) ‚Ü¶ ClusterPt x f)","name":"isClosed_setOf_clusterPt","isProp":true,"docString":"The set of cluster points of a filter is closed. In particular, the set of limit points\nof a sequence is closed. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : Quiver.IsThin C],\n  (CategoryTheory.EssentiallySmall C : Prop) ‚Üî (Small (CategoryTheory.Skeleton C) : Prop)","name":"CategoryTheory.essentiallySmall_iff_of_thin","isProp":true,"docString":"A thin category is essentially small if and only if the underlying type of its skeleton is small.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : LowerTopology Œ±] {s : Set Œ±}\n  (h : IsOpen s), IsLowerSet s","name":"LowerTopology.isLowerSet_of_isOpen","isProp":true,"docString":"Every set open in the lower topology is a lower set. "},{"type":"‚àÄ {S : Type u_2} [inst : CommRing S] (A : Type u_1) [inst_1 : CommRing A] [inst_2 : IsDomain A] [inst_3 : Algebra A S]\n  {M : Submonoid A} [inst_4 : IsLocalization M S] (hM : M ‚â§ nonZeroDivisors A), NoZeroDivisors S","name":"IsLocalization.noZeroDivisors_of_le_nonZeroDivisors","isProp":true,"docString":"A `CommRing` `S` which is the localization of a ring `R` without zero divisors at a subset of\nnon-zero elements does not have zero divisors.\nSee note [reducible non-instances]. "},{"type":"‚àÄ {R : Type u_1} [inst : DivisionRing R] [inst_1 : CharZero R] {p : R} {r : R} {z : ‚Ñ§} (hz : z ‚â† 0),\n  (z ‚Ä¢ r ‚àà AddSubgroup.zmultiples p : Prop) ‚Üî\n    (‚àÉ (k : Fin (Int.natAbs z)), r - ‚Üëk ‚Ä¢ (p / ‚Üëz) ‚àà AddSubgroup.zmultiples p : Prop)","name":"AddSubgroup.zsmul_mem_zmultiples_iff_exists_sub_div","isProp":true,"docString":"`z ‚Ä¢ r` is a multiple of `p` iff `r` is `pk/z` above a multiple of `p`, where `0 ‚â§ k < |z|`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 < a) (hb : 0 < b), 0 < a + b","name":"add_pos","isProp":true,"docString":"**Alias** of `Left.add_pos`."},{"type":"‚àÄ {Œ± : Type v} {s : Finset Œ±} {M : Type u_1} [inst : CommMonoid M] (f : (a : Œ±) ‚Üí M) (p : (a : M) ‚Üí Prop)\n  (hom : ‚àÄ (a : M) (b : M) (a_1 : p a) (a_2 : p b), p (a * b)) (unit : p 1) (base : ‚àÄ (x : Œ±) (a : x ‚àà s), p (f x)),\n  p (Finset.prod s fun (x : Œ±) ‚Ü¶ f x)","name":"Finset.prod_induction","isProp":true,"docString":"To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors. "},{"type":"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)} (H : ‚àÄ (a : Œ±), ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà c), a ‚àà b), Set.PairwiseDisjoint c id","name":"Setoid.eqv_classes_disjoint","isProp":true,"docString":"Distinct elements of a set of sets partitioning Œ± are disjoint. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : PseudoMetricSpace Œ≤]\n  (b : (a : ‚Ñù) ‚Üí ‚Ñù) (b_lim : Filter.Tendsto b (nhds 0) (nhds 0)) (F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±)\n  (H : ‚àÄ (x : Œ≤) (y : Œ≤) (i : Œπ), dist (F i x) (F i y) ‚â§ b (dist x y)), Equicontinuous F","name":"Metric.equicontinuous_of_continuity_modulus","isProp":true,"docString":"For a family of functions between (pseudo) metric spaces, a convenient way to prove\nequicontinuity is to show that all of the functions share a common *global* continuity modulus. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommSemiring Œ≤] {s : Finset Œ±} {i : Œ±} {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  {h : (a : Œ±) ‚Üí Œ≤} (hi : i ‚àà s) (h1 : g i + h i = f i) (h2 : ‚àÄ (j : Œ±) (a : j ‚àà s) (a : j ‚â† i), g j = f j)\n  (h3 : ‚àÄ (j : Œ±) (a : j ‚àà s) (a : j ‚â† i), h j = f j),\n  ((Finset.prod s fun (i : Œ±) ‚Ü¶ g i) + Finset.prod s fun (i : Œ±) ‚Ü¶ h i) = Finset.prod s fun (i : Œ±) ‚Ü¶ f i","name":"Finset.prod_add_prod_eq","isProp":true,"docString":"If `f = g = h` everywhere but at `i`, where `f i = g i + h i`, then the product of `f` over `s`\nis the sum of the products of `g` and `h`. "},{"type":"‚àÄ {R : Type u} [inst : Ring R], ¬¨(IsField (Polynomial R) : Prop)","name":"Ideal.polynomial_not_isField","isProp":true,"docString":"`R[X]` is never a field for any ring `R`. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type uu} [inst : Preorder Œ±] {f : (a : Fin n) ‚Üí Œ±} (a : Monotone f),\n  List.Sorted (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) (List.ofFn f)","name":"Monotone.ofFn_sorted","isProp":true,"docString":"The list obtained from a monotone tuple is sorted. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : EMetricSpace Œ≤] {a : Œ≤} {r : ENNReal} (x : ‚Üë(EMetric.ball a r)) (y : ‚Üë(EMetric.ball a r)),\n  edist ‚Üëx ‚Üëy ‚â† ‚ä§","name":"edist_ne_top_of_mem_ball","isProp":true,"docString":"In an emetric ball, the distance between points is everywhere finite "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (hf : MonotoneOn f s) (hg : MonotoneOn g s), MonotoneOn (fun (x : Œ±) ‚Ü¶ max (f x) (g x)) s","name":"MonotoneOn.max","isProp":true,"docString":"Pointwise maximum of two monotone functions is a monotone function. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (hp‚ÇÅp‚ÇÇ : p‚ÇÅ ‚â† p‚ÇÇ) (hp‚ÇÅ : p‚ÇÅ ‚àà s)\n  (hp‚ÇÇ : p‚ÇÇ ‚àà s) (hp‚ÇÉ : ¬¨(p‚ÇÉ ‚àà s : Prop)), AffineIndependent k ![p‚ÇÅ, p‚ÇÇ, p‚ÇÉ]","name":"affineIndependent_of_ne_of_mem_of_mem_of_not_mem","isProp":true,"docString":"If distinct points `p‚ÇÅ` and `p‚ÇÇ` lie in `s` but `p‚ÇÉ` does not, the three points are affinely\nindependent. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : (a : C) ‚Üí D}\n  [self : CategoryTheory.Functorial F] (X : C), CategoryTheory.Functorial.map' (ùüô X) = ùüô (F X)","name":"CategoryTheory.Functorial.map_id'","isProp":true,"docString":"A functorial map preserves identities. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : BiheytingAlgebra Œ±] [inst_1 : BiheytingAlgebra Œ≤] (self : BiheytingHom Œ± Œ≤)\n  (a : Œ±) (b : Œ±),\n  SupHom.toFun (LatticeHom.toSupHom (BiheytingHom.toLatticeHom self)) (a \\ b) =\n    SupHom.toFun (LatticeHom.toSupHom (BiheytingHom.toLatticeHom self)) a \\\n      SupHom.toFun (LatticeHom.toSupHom (BiheytingHom.toLatticeHom self)) b","name":"BiheytingHom.map_sdiff'","isProp":true,"docString":"The proposition that a bi-Heyting homomorphism preserves the difference operation."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : (a : Œ±) ‚Üí Œ≤}, (f '' s ‚äÜ t : Prop) ‚Üî (s ‚äÜ f ‚Åª¬π' t : Prop)","name":"Set.image_subset_iff","isProp":true,"docString":"image and preimage are a Galois connection "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : CompactSpace Œ±], Metric.Bounded s","name":"Metric.bounded_of_compactSpace","isProp":true,"docString":"In a compact space, all sets are bounded "},{"type":"‚àÄ {C : Type u_4} {D : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {G : C ‚•§ D}\n  {F : D ‚•§ C} {A : C} {B : C} {X : D} {Y : D} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\n  {u : A ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X}\n  {v : B ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y}\n  (sq : CategoryTheory.CommSq u i (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) p) v) (adj : G ‚ä£ F),\n  (CategoryTheory.CommSq.HasLift\n        ((CategoryTheory.CommSq.left_adjoint sq\n              adj=:CategoryTheory.CommSq (‚Üë(Equiv.symm (CategoryTheory.Adjunction.homEquiv adj A X)) u)\n              (Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) i) p\n              (‚Üë(Equiv.symm (CategoryTheory.Adjunction.homEquiv adj B Y))\n                v))=:CategoryTheory.CommSq (‚Üë(Equiv.symm (CategoryTheory.Adjunction.homEquiv adj A X)) u)\n            (Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) i) p\n            (‚Üë(Equiv.symm (CategoryTheory.Adjunction.homEquiv adj B Y)) v)) :\n      Prop) ‚Üî\n    (CategoryTheory.CommSq.HasLift sq : Prop)","name":"CategoryTheory.CommSq.left_adjoint_hasLift_iff","isProp":true,"docString":"A (left) adjoint square has a lifting if and only if the original square has a lifting. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : StrictAntiOn f s), StrictMonoOn (‚ÜëOrderDual.toDual ‚àò f) s","name":"StrictAntiOn.dual_right","isProp":true,"docString":"**Alias** of the reverse direction of `strictMonoOn_toDual_comp_iff`."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : Preorder Œ±] {f : Fin n ‚Ü™o Œ±} {g : Fin n ‚Ü™o Œ±} (h : Set.range ‚Üëf = Set.range ‚Üëg), f = g","name":"Fin.orderEmbedding_eq","isProp":true,"docString":"Two order embeddings of `Fin n` are equal provided that their ranges are equal. "},{"type":"AbsoluteValue.uniformSpace AbsoluteValue.abs = PseudoMetricSpace.toUniformSpace","name":"Rat.uniformSpace_eq","isProp":true,"docString":"The metric space uniform structure on ‚Ñö (which presupposes the existence\nof real numbers) agrees with the one coming directly from (abs : ‚Ñö ‚Üí ‚Ñö). "},{"type":"‚àÄ {G : Type u_2} [inst : AddGroup G] {Œπ : Sort u_1} (S : (a : Œπ) ‚Üí AddSubgroup G) {C : (a : G) ‚Üí Prop} {x : G}\n  (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hp : ‚àÄ (i : Œπ) (x : G) (a : x ‚àà S i), C x) (h1 : C 0)\n  (hmul : ‚àÄ (x : G) (y : G) (a : C x) (a : C y), C (x + y)), C x","name":"AddSubgroup.sup·µ¢_induction","isProp":true,"docString":" An induction principle for elements of `‚®Ü i, S i`.\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `S`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SeparableSpace Œ±] {Œπ : Type u_1} {s : (a : Œπ) ‚Üí Set Œ±}\n  {a : Set Œπ} (h : Set.PairwiseDisjoint a s) (ha : ‚àÄ (i : Œπ) (a : i ‚àà a), IsOpen (s i))\n  (h'a : ‚àÄ (i : Œπ) (a : i ‚àà a), Set.Nonempty (s i)), Set.Countable a","name":"Set.PairwiseDisjoint.countable_of_isOpen","isProp":true,"docString":"In a separable space, a family of nonempty disjoint open sets is countable. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} (a_1 : a < c - b), a + b < c","name":"add_lt_of_lt_sub_right","isProp":true,"docString":"**Alias** of the forward direction of `lt_sub_iff_add_lt`."},{"type":"‚àÄ {R : Type u_1} {Œπ : Type u_2} {M : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Finite Œπ] [inst_4 : IsNoetherian R M], IsNoetherian R ((a : Œπ) ‚Üí M)","name":"isNoetherian_pi'","isProp":true,"docString":"A version of `isNoetherian_pi` for non-dependent functions. We need this instance because\nsometimes Lean fails to apply the dependent version in non-dependent settings (e.g., it fails to\nprove that `Œπ ‚Üí ‚Ñù` is finite dimensional over `‚Ñù`). "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±}\n  (hs : Set.Finite (s ‚à© Function.support f)) (ht : Set.Finite (t ‚à© Function.support f)),\n  ((finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s ‚à© t) ‚Ü¶ f i) =\n    (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà t) ‚Ü¶ f i","name":"finsum_mem_union_inter'","isProp":true,"docString":"A more general version of `finsum_mem_union_inter` that requires `s ‚à© support f` and\n`t ‚à© support f` rather than `s` and `t` to be finite."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} {o : Ordering} (a_1 : Ordering.Compares o b a),\n  Ordering.Compares (Ordering.swap o) a b","name":"Ordering.Compares.swap","isProp":true,"docString":"**Alias** of the reverse direction of `Ordering.compares_swap`."},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {r : (a : M) ‚Üí (a : M) ‚Üí Prop} {s : (a : M) ‚Üí (a : M) ‚Üí Prop}\n  (h : ‚àÄ (x : M) (y : M) (a : r x y), s x y), addConGen r ‚â§ addConGen s","name":"AddCon.addConGen_mono","isProp":true,"docString":"Given binary relations `r, s` with `r` contained in `s`, the\nsmallest additive congruence relation containing `s` contains the smallest additive congruence\nrelation containing `r`."},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : TopologicalSpace G‚ÇÄ] [inst_1 : GroupWithZero G‚ÇÄ] [inst_2 : ContinuousMul G‚ÇÄ]\n  (h : Filter.Tendsto Inv.inv (nhds 1) (nhds 1)), HasContinuousInv‚ÇÄ G‚ÇÄ","name":"HasContinuousInv‚ÇÄ.of_nhds_one","isProp":true,"docString":"If a group with zero has continuous multiplication and `fun x ‚Ü¶ x‚Åª¬π` is continuous at one,\nthen it is continuous at any unit. "},{"type":"‚àÄ (K : Type u) [inst : Ring K] [inst_1 : StrongRankCondition K] {Œπ : Type v} [inst_2 : Fintype Œπ],\n  FiniteDimensional.finrank K ((a : Œπ) ‚Üí K) = Fintype.card Œπ","name":"FiniteDimensional.finrank_fintype_fun_eq_card","isProp":true,"docString":"The vector space of functions on a `Fintype Œπ` has finrank equal to the cardinality of `Œπ`. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (S : Set (Con M)), Con.toSetoid (inf‚Çõ S) = inf‚Çõ (Con.toSetoid '' S)","name":"Con.inf‚Çõ_toSetoid","isProp":true,"docString":"The infimum of a set of congruence relations is the same as the infimum of the set's image\nunder the map to the underlying equivalence relation. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : LocallyFiniteOrder Œ±] (a : Œ±) (b : Œ±) (x : Œ±),\n  (x ‚àà LocallyFiniteOrder.finsetIcc a b : Prop) ‚Üî ((a ‚â§ x : Prop) ‚àß (x ‚â§ b : Prop) : Prop)","name":"LocallyFiniteOrder.finset_mem_Icc","isProp":true,"docString":"`x ‚àà finsetIcc a b ‚Üî a ‚â§ x ‚àß x ‚â§ b` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} (a_1 : Order.IsPredLimit a), Order.IsSuccLimit (‚ÜëOrderDual.toDual a)","name":"Order.isPredLimit.dual","isProp":true,"docString":"**Alias** of the reverse direction of `Order.isSuccLimit_toDual_iff`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (P : Subgroup G),\n  (Subgroup.Fg P : Prop) ‚Üî (Submonoid.Fg (Subgroup.toSubmonoid P) : Prop)","name":"Subgroup.fg_iff_submonoid_fg","isProp":true,"docString":"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {t : Set Œ±} (sne : Set.Nonempty s)\n  (tne : Set.Nonempty t) (hst : ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà t), x ‚â§ y),\n  Set.Nonempty (upperBounds s ‚à© lowerBounds t)","name":"exists_between_of_forall_le","isProp":true,"docString":"If all elements of a nonempty set `s` are less than or equal to all elements\nof a nonempty set `t`, then there exists an element between these sets. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : PartialOrder Œ±] {f : (a : Fin n) ‚Üí Œ±} {œÉ : Equiv.Perm (Fin n)} {œÑ : Equiv.Perm (Fin n)}\n  (hfœÉ : Monotone (f ‚àò ‚ÜëœÉ)) (hfœÑ : Monotone (f ‚àò ‚ÜëœÑ)), f ‚àò ‚ÜëœÉ = f ‚àò ‚ÜëœÑ","name":"Tuple.unique_monotone","isProp":true,"docString":"If two permutations of a tuple `f` are both monotone, then they are equal. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (h : p‚ÇÅ ‚àà affineSpan k {p‚ÇÇ, p‚ÇÉ}),\n  affineSpan k {p‚ÇÇ, p‚ÇÅ} ‚â§ affineSpan k {p‚ÇÇ, p‚ÇÉ}","name":"affineSpan_pair_le_of_right_mem","isProp":true,"docString":"One line is contained in another differing in the second point if the second point of the\nfirst line is contained in the second line. "},{"type":"‚àÄ {R : Type u} [self : EuclideanDomain R] (a : R) (b : R),\n  b * EuclideanDomain.quotient a b + EuclideanDomain.remainder a b = a","name":"EuclideanDomain.quotient_mul_add_remainder_eq","isProp":true,"docString":"The property that links the quotient and remainder functions.\nThis allows us to compute GCDs and LCMs. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} {N : Type u_2} [inst_1 : AddGroup N] (f : G ‚Üí+ N),\n  AddSubgroup.map f (AddSubgroup.normalizer H) ‚â§ AddSubgroup.normalizer (AddSubgroup.map f H)","name":"AddSubgroup.le_normalizer_map","isProp":true,"docString":"The image of the normalizer is contained in the normalizer of the image."},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {s : Set M} {t : Set M} {x : M},\n  (x ‚àà Monoid.Closure (s ‚à™ t) : Prop) ‚Üî\n    (‚àÉ (y : M), (y ‚àà Monoid.Closure s : Prop) ‚àß (‚àÉ (z : M), (z ‚àà Monoid.Closure t : Prop) ‚àß (y * z = x : Prop) : Prop) :\n      Prop)","name":"Monoid.mem_closure_union_iff","isProp":true,"docString":"Given sets `s, t` of a commutative monoid `M`, `x ‚àà M` is in the submonoid of `M` generated by\n`s ‚à™ t` iff there exists an element of the submonoid generated by `s` and an element of the\nsubmonoid generated by `t` whose product is `x`. "},{"type":"‚àÄ (n : ‚Ñï), n + 1 ‚à£ Nat.centralBinom n","name":"Nat.succ_dvd_centralBinom","isProp":true,"docString":"A crucial lemma to ensure that Catalan numbers can be defined via their explicit formula\n`catalan n = n.centralBinom / (n + 1)`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A - C) * Finset.card B ‚â§ Finset.card (A - B) * Finset.card (B - C)","name":"Finset.card_sub_mul_le_card_sub_mul_card_sub","isProp":true,"docString":"**Ruzsa's triangle inequality**. Subtraction version."},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] [inst_5 : FiniteDimensional K V] (f : V ‚Üí‚Çó[K] V‚ÇÇ)\n  (hf : LinearMap.range f = ‚ä§), FiniteDimensional K V‚ÇÇ","name":"LinearMap.finiteDimensional_of_surjective","isProp":true,"docString":"The image under an onto linear map of a finite-dimensional space is also finite-dimensional. "},{"type":"‚àÄ {Œ± : Type u_1} [self : ConditionallyCompleteLattice Œ±] (s : Set Œ±) (a : Œ±) (a_1 : BddAbove s) (a_2 : a ‚àà s),\n  a ‚â§ sup‚Çõ s","name":"ConditionallyCompleteLattice.le_csup‚Çõ","isProp":true,"docString":"`a ‚â§ sup‚Çõ s` for all `a ‚àà s`. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} {f : M ‚Üí* P}\n  (H : c ‚â§ Con.ker f), MonoidHom.comp (Con.lift c f H) (Con.mk' c) = f","name":"Con.lift_comp_mk'","isProp":true,"docString":"The diagram describing the universal property for quotients of monoids commutes. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (p : Submodule R M)\n  {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_4} [inst_3 : Ring R‚ÇÇ] [inst_4 : AddCommGroup M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  ‚¶Éf : M ‚ß∏ p ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ‚¶Ñ ‚¶Ég : M ‚ß∏ p ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ‚¶Ñ\n  (h : LinearMap.comp f (Submodule.mkQ p) = LinearMap.comp g (Submodule.mkQ p)), f = g","name":"Submodule.linearMap_qext","isProp":true,"docString":"Two `linear_map`s from a quotient module are equal if their compositions with\n`submodule.mkQ` are equal.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {i : D ‚•§ C}\n  [inst_2 : CategoryTheory.Reflective i] {B : D},\n  CategoryTheory.IsIso\n    ((CategoryTheory.Adjunction.unit (CategoryTheory.Adjunction.ofRightAdjoint i)).app\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor i) B))","name":"CategoryTheory.isIso_unit_obj","isProp":true,"docString":"When restricted to objects in `D` given by `i : D ‚•§ C`, the unit is an isomorphism. In other words,\n`Œ∑_iX` is an isomorphism for any `X` in `D`.\nMore generally this applies to objects essentially in the reflective subcategory, see\n`Functor.essImage.unit_isIso`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Mul Œ≤] [inst_2 : Add Œ±] [inst_3 : Add Œ≤] [inst_4 : LE Œ±]\n  [inst_5 : LE Œ≤] (self : Œ± ‚âÉ+*o Œ≤) {a : Œ±} {b : Œ±},\n  (Equiv.toFun (RingEquiv.toEquiv (OrderRingIso.toRingEquiv self)) a ‚â§\n        Equiv.toFun (RingEquiv.toEquiv (OrderRingIso.toRingEquiv self)) b :\n      Prop) ‚Üî\n    (a ‚â§ b : Prop)","name":"OrderRingIso.map_le_map_iff'","isProp":true,"docString":"The proposition that the function preserves the order bijectively. "},{"type":"‚àÄ {P : (a : ‚Ñ§) ‚Üí Prop} [inst : DecidablePred P] (Hbdd : ‚àÉ (b : ‚Ñ§), ‚àÄ (z : ‚Ñ§) (a : P z), b ‚â§ z) (Hinh : ‚àÉ (z : ‚Ñ§), P z),\n  ‚àÉ (lb : ‚Ñ§), (P lb : Prop) ‚àß (‚àÄ (z : ‚Ñ§) (a : P z), lb ‚â§ z : Prop)","name":"Int.exists_least_of_bdd","isProp":true,"docString":"If `P : ‚Ñ§ ‚Üí Prop` is a predicate such that the set `{m : P m}` is bounded below and nonempty,\nthen this set has the least element. This lemma uses classical logic to avoid assumption\n`[DecidablePred P]`. See `Int.leastOfBdd` for a constructive counterpart. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : DecidableEq Œ±] [inst_1 : AddZeroClass M]\n  [inst_2 : AddCommMonoid N] {f : Œ± ‚Üí‚ÇÄ M} {g : Œ± ‚Üí‚ÇÄ M} {h : (a : Œ±) ‚Üí (a : M) ‚Üí N}\n  (h_zero : ‚àÄ (a : Œ±) (a_1 : a ‚àà Finsupp.support f ‚à™ Finsupp.support g), h a 0 = 0)\n  (h_add :\n    ‚àÄ (a : Œ±) (a_1 : a ‚àà Finsupp.support f ‚à™ Finsupp.support g) (b‚ÇÅ : M) (b‚ÇÇ : M), h a (b‚ÇÅ + b‚ÇÇ) = h a b‚ÇÅ + h a b‚ÇÇ),\n  Finsupp.sum (f + g) h = Finsupp.sum f h + Finsupp.sum g h","name":"Finsupp.sum_add_index","isProp":true,"docString":"Taking the product under `h` is an additive homomorphism of finsupps,  if `h` is an\nadditive homomorphism on the support. This is a more general version of\n`Finsupp.sum_add_index'`; the latter has simpler hypotheses."},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {œÄ : (a : X) ‚Üí Y}\n  {V : Set (Set X)} (hV : TopologicalSpace.IsTopologicalBasis V) (h' : QuotientMap œÄ) (h : IsOpenMap œÄ),\n  TopologicalSpace.IsTopologicalBasis (Set.image œÄ '' V)","name":"TopologicalSpace.IsTopologicalBasis.quotientMap","isProp":true,"docString":"The image of a topological basis under an open quotient map is a topological basis. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] [inst_1 : StarRing R] (x : R), ‚Üë(starRingEnd R) (‚Üë(starRingEnd R) x) = x","name":"Complex.conj_conj","isProp":true,"docString":"**Alias** of `starRingEnd_self_apply`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)) < Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (¬¨(Monovary f (g ‚àò ‚ÜëœÉ) : Prop) : Prop)","name":"Monovary.sum_smul_comp_perm_lt_sum_smul_iff","isProp":true,"docString":"**Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 2)},\n  CategoryTheory.CosimplicialObject.Œ¥ X i ‚â´ CategoryTheory.CosimplicialObject.Œ¥ X (‚ÜëFin.castSucc i) =\n    CategoryTheory.CosimplicialObject.Œ¥ X i ‚â´ CategoryTheory.CosimplicialObject.Œ¥ X (Fin.succ i)","name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥_self","isProp":true,"docString":"The special case of the first cosimplicial identity "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1], 0 < 4","name":"zero_lt_four","isProp":true,"docString":"See `zero_lt_four'` for a version with the type explicit. "},{"type":"‚àÄ {b : Ordinal} {o : Ordinal} {x : Ordinal √ó Ordinal} (h : x ‚àà Ordinal.CNF b o), Prod.fst x ‚â§ o","name":"Ordinal.CNF_fst_le","isProp":true,"docString":"Every exponent in the Cantor normal form `CNF b o` is less or equal to `o`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : BoundedOrder Œ±]\n  [inst_3 : BoundedOrder Œ≤] (self : BoundedOrderHom Œ± Œ≤), ‚Üë(BoundedOrderHom.toOrderHom self) ‚ä§ = ‚ä§","name":"BoundedOrderHom.map_top'","isProp":true,"docString":"The function preserves the top element. The preferred spelling is `map_top`. "},{"type":"‚àÄ {Œ± : Sort u_2} {œÉ : (a : Œ±) ‚Üí Sort u_1} (P : Prop) [inst : Decidable (P : Prop)] (f : (a : P) ‚Üí (a : Œ±) ‚Üí œÉ a)\n  (g : (a : ¬¨(P : Prop)) ‚Üí (a : Œ±) ‚Üí œÉ a) (a : Œ±), dite (P : Prop) f g a = if h : (P : Prop) then f h a else g h a","name":"dite_apply","isProp":true,"docString":"A 'dite' producing a `Pi` type `Œ† a, œÉ a`, applied to a value `a : Œ±` is a `dite` that applies\neither branch to `a`. "},{"type":"‚àÄ {X : CompHaus} {Y : CompHaus} (f : X ‚ü∂ Y)\n  (bij : Function.Bijective (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget CompHaus)) f)),\n  CategoryTheory.IsIso f","name":"CompHaus.isIso_of_bijective","isProp":true,"docString":"Any continuous bijection of compact Hausdorff spaces is an isomorphism. "},{"type":"‚àÄ {Œπ : Type u_1} {Œπ' : Type u_2} {R : Type u_3} {M : Type u_4} [inst : CommSemiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] (b : Basis Œπ R M) (b' : Basis Œπ' R M) [inst_3 : Fintype Œπ'] [inst_4 : Fintype Œπ]\n  [inst_5 : DecidableEq Œπ], ‚Üë(LinearMap.toMatrix b b') LinearMap.id = Basis.toMatrix b' ‚Üëb","name":"LinearMap.toMatrix_id_eq_basis_toMatrix","isProp":true,"docString":"A generalization of `LinearMap.toMatrix_id`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (g : C(Œ≤, Œ≥)), Continuous (ContinuousMap.comp g)","name":"ContinuousMap.continuous_comp","isProp":true,"docString":"C(Œ±, -) is a functor. "},{"type":"‚àÄ {Œ± : Type u_1} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (a : l‚ÇÅ <:+: l‚ÇÇ), List.reverse l‚ÇÅ <:+: List.reverse l‚ÇÇ","name":"List.isInfix.reverse","isProp":true,"docString":"**Alias** of the reverse direction of `List.reverse_infix`."},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] {f : Filter Œ±} (hf : Cauchy f) {U : (a : ‚Ñï) ‚Üí Set (Œ± √ó Œ±)}\n  (U_mem : ‚àÄ (n : ‚Ñï), U n ‚àà uniformity Œ±) (U_le : ‚àÄ (s : Set (Œ± √ó Œ±)) (a : s ‚àà uniformity Œ±), ‚àÉ (n : ‚Ñï), U n ‚äÜ s)\n  ‚¶Éa : Œ±‚¶Ñ (ha : Filter.Tendsto (SequentiallyComplete.seq hf U_mem) Filter.atTop (nhds a)), f ‚â§ nhds a","name":"SequentiallyComplete.le_nhds_of_seq_tendsto_nhds","isProp":true,"docString":"If the sequence `SequentiallyComplete.seq` converges to `a`, then `f ‚â§ ùìù a`. "},{"type":"‚àÄ (n : ‚Ñï) (n_big : 4 ‚â§ n), 4 ^ n < n * Nat.centralBinom n","name":"Nat.four_pow_lt_mul_centralBinom","isProp":true,"docString":"An exponential lower bound on the central binomial coefficient.\nThis bound is of interest because it appears in\n[Tochiori's refinement of Erd≈ës's proof of Bertrand's postulate](tochiori_bertrand).\n"},{"type":"‚àÄ {R : Type u} {Œπ : Type w} (s : Finset Œπ) [inst : CommSemiring R] (f : (a : Œπ) ‚Üí Polynomial R)\n  (h : (Finset.prod s fun (i : Œπ) ‚Ü¶ Polynomial.leadingCoeff (f i)) ‚â† 0),\n  Polynomial.natDegree (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) = Finset.sum s fun (i : Œπ) ‚Ü¶ Polynomial.natDegree (f i)","name":"Polynomial.natDegree_prod'","isProp":true,"docString":"The degree of a product of polynomials is equal to\nthe sum of the degrees, provided that the product of leading coefficients is nonzero.\n\nSee `Polynomial.natDegree_prod` (without the `'`) for a version for integral domains,\nwhere this condition is automatically satisfied.\n"},{"type":"‚àÄ {V : Type u} [inst : Quiver V] (r : V) [inst_1 : Quiver.RootedConnected r] {a : V} (p : Quiver.Path r a),\n  Quiver.Path.length (Quiver.shortestPath r a) ‚â§ Quiver.Path.length p","name":"Quiver.shortest_path_spec","isProp":true,"docString":"The length of a path is at least the length of the shortest path "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : Norm E] {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} (a : f =O[l] u),\n  f =O[l] fun (x : Œ±) ‚Ü¶ abs (u x)","name":"Asymptotics.IsBigO.abs_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigO_abs_right`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddGroup Œ±] [inst_1 : SubtractionMonoid Œ≤] (f : Œ± ‚Üí+ Œ≤) (g : Œ±) (h : Œ±),\n  ‚Üëf (g + -h) = ‚Üëf g + -‚Üëf h","name":"AddMonoidHom.map_add_neg","isProp":true,"docString":"Additive group homomorphisms preserve subtraction."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X‚ÇÅ‚ÇÅ : C} {X‚ÇÅ‚ÇÇ : C} {X‚ÇÇ‚ÇÅ : C} {X‚ÇÇ‚ÇÇ : C} {X‚ÇÉ‚ÇÅ : C} {X‚ÇÉ‚ÇÇ : C}\n  {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÉ‚ÇÅ : X‚ÇÉ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÇ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÅ}\n  {v‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÉ‚ÇÇ} (s : CategoryTheory.IsPushout h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) (t : CategoryTheory.IsPushout h‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÇ h‚ÇÉ‚ÇÅ),\n  CategoryTheory.IsPushout h‚ÇÅ‚ÇÅ (v‚ÇÅ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÅ) (v‚ÇÅ‚ÇÇ ‚â´ v‚ÇÇ‚ÇÇ) h‚ÇÉ‚ÇÅ","name":"CategoryTheory.IsPushout.paste_vert","isProp":true,"docString":"Paste two pushout squares \"vertically\" to obtain another pushout square. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : LocallyCompactSpace Œ≤] (f : C(Œ±, C(Œ≤, Œ≥))),\n  Continuous (Function.uncurry fun (x : Œ±) (y : Œ≤) ‚Ü¶ ‚Üë(‚Üëf x) y)","name":"ContinuousMap.continuous_uncurry_of_continuous","isProp":true,"docString":"The uncurried form of a continuous map `Œ± ‚Üí C(Œ≤, Œ≥)` is a continuous map `Œ± √ó Œ≤ ‚Üí Œ≥`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (r : k) (p‚ÇÅ : P) (p‚ÇÇ : P), r ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ) ‚àà vectorSpan k {p‚ÇÅ, p‚ÇÇ}","name":"smul_vsub_mem_vectorSpan_pair","isProp":true,"docString":"A multiple of the difference between two points lies in their `vectorSpan`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] (P : AddSubmonoid M),\n  (AddSubmonoid.Fg P : Prop) ‚Üî (‚àÉ (S : Set M), (AddSubmonoid.closure S = P : Prop) ‚àß (Set.Finite S : Prop) : Prop)","name":"AddSubmonoid.fg_iff","isProp":true,"docString":"An equivalent expression of `AddSubmonoid.Fg` in terms of `Set.Finite` instead of\n`Finset`."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C] {J' : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category J'] (e : J ‚âå J') [inst : CategoryTheory.Limits.HasColimitsOfShape J C],\n  CategoryTheory.Limits.HasColimitsOfShape J' C","name":"CategoryTheory.Limits.hasColimitsOfShape_of_equivalence","isProp":true,"docString":"We can transport colimits of shape `J` along an equivalence `J ‚âå J'`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {x : Œ±},\n  connectedComponent x ‚äÜ Set.inter·µ¢ fun (Z : { Z : Set Œ± // (IsClopen Z : Prop) ‚àß (x ‚àà Z : Prop) }) ‚Ü¶ ‚ÜëZ","name":"connectedComponent_subset_inter·µ¢_clopen","isProp":true,"docString":"The connected component of a point is always a subset of the intersection of all its clopen\nneighbourhoods. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : SemilatticeSup Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} (hf : Monotone f) (hg : Antitone g) (h : f ‚â§ g),\n  (sup·µ¢ fun (n : Œ≤) ‚Ü¶ f n) ‚àà Set.inter·µ¢ fun (n : Œ≤) ‚Ü¶ Set.Icc (f n) (g n)","name":"Monotone.csup·µ¢_mem_Inter_Icc_of_antitone","isProp":true,"docString":"Nested intervals lemma: if `f` is a monotone sequence, `g` is an antitone sequence, and\n`f n ‚â§ g n` for all `n`, then `‚®Ü n, f n` belongs to all the intervals `[f n, g n]`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommSemigroup Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ExistsAddOfLE Œ±]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [inst_4 : Sub Œ±]\n  [inst_5 : OrderedSub Œ±] {a : Œ±} {b : Œ±} {c : Œ±}\n  [inst_6 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (h : c ‚â§ b),\n  (a < b - c : Prop) ‚Üî (c + a < b : Prop)","name":"lt_tsub_iff_left_of_le","isProp":true,"docString":"See `lt_tsub_iff_left` for a stronger statement in a linear order. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] (x : R) (y : R) (n : ‚Ñï),\n  (x + y) ^ n = Finset.sum (Finset.range (n + 1)) fun (m : ‚Ñï) ‚Ü¶ x ^ m * y ^ (n - m) * ‚Üë(Nat.choose n m)","name":"add_pow","isProp":true,"docString":"The **binomial theorem** "},{"type":"‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (x : Œ±) (y : Œ±) (u : Œ±À£), x * (y /‚Çö u) = x * y /‚Çö u","name":"divp_assoc'","isProp":true,"docString":"`field_simp` needs the reverse direction of `divp_assoc` to move all `/‚Çö` to the right. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M} {a : M} (h : a ‚àà Monoid.Closure s),\n  ‚àÉ (l : List M), (‚àÄ (x : M) (a : x ‚àà l), x ‚àà s : Prop) ‚àß (List.prod l = a : Prop)","name":"Monoid.exists_list_of_mem_closure","isProp":true,"docString":"Given an element `a` of the submonoid of a monoid `M` generated by a set `s`, there exists\na list of elements of `s` whose product is `a`. "},{"type":"‚àÄ {X : Type u} {m‚ÇÅ : (a : X) ‚Üí (a : X) ‚Üí X} {m‚ÇÇ : (a : X) ‚Üí (a : X) ‚Üí X} {e‚ÇÅ : X} {e‚ÇÇ : X}\n  (h‚ÇÅ : EckmannHilton.IsUnital m‚ÇÅ e‚ÇÅ) (h‚ÇÇ : EckmannHilton.IsUnital m‚ÇÇ e‚ÇÇ)\n  (distrib : ‚àÄ (a : X) (b : X) (c : X) (d : X), m‚ÇÅ (m‚ÇÇ a b) (m‚ÇÇ c d) = m‚ÇÇ (m‚ÇÅ a c) (m‚ÇÅ b d)), e‚ÇÅ = e‚ÇÇ","name":"EckmannHilton.one","isProp":true,"docString":"If a type carries two unital binary operations that distribute over each other,\nthen they have the same unit elements.\n\nIn fact, the two operations are the same, and give a commutative monoid structure,\nsee `eckmann_hilton.CommMonoid`. "},{"type":"‚àÄ {Œπ : Type u_1} {x : ‚Ñï} {s : (a : Œπ) ‚Üí ‚Ñï} {t : Finset Œπ} (a : ‚àÄ (i : Œπ) (a : i ‚àà t), Nat.coprime (s i) x),\n  Nat.coprime (Finset.prod t fun (i : Œπ) ‚Ü¶ s i) x","name":"Nat.coprime_prod_left","isProp":true,"docString":"See `IsCoprime.prod_left` for the corresponding lemma about `IsCoprime` "},{"type":"‚àÄ {x : PSet} {y : PSet}, (PSet.Equiv x y : Prop) ‚Üî (PSet.toSet x = PSet.toSet y : Prop)","name":"PSet.Equiv.eq","isProp":true,"docString":"Two pre-sets are equivalent iff they have the same members. "},{"type":"PrimeMultiset.prod 0 = 1","name":"PrimeMultiset.prod_zero","isProp":true,"docString":"The product map gives a homomorphism from the additive monoid\nof multisets to the multiplicative monoid ‚Ñï+. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hst : s ‚äÜ t)\n  (ht : Set.Finite t),\n  ((finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà t \\ s) ‚Ü¶ f i) =\n    finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà t) ‚Ü¶ f i","name":"finprod_mem_mul_diff","isProp":true,"docString":"Given a finite set `t` and a subset `s` of `t`, the product of `f i` over `i ‚àà s`\ntimes the product of `f i` over `t \\ s` equals the product of `f i` over `i ‚àà t`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {b : M}\n  [inst_1 : LinearOrderedCommSemiring M] (ht : ‚Üë(Finset.card s) < Finset.card t ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (‚Üë(Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s)) < b : Prop)","name":"Finset.exists_card_fiber_lt_of_card_lt_nsmul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with\nat most as many pigeons as the floor of the average number of pigeons across all pigeonholes. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulZeroClass Œ±] [inst_1 : Preorder Œ±] [inst_2 : MulPosStrictMono Œ±]\n  (ha : 0 < a) (hb : 0 < b), 0 < a * b","name":"Right.mul_pos","isProp":true,"docString":"Assumes right covariance. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {f : ‚Ñ§ ‚Üí* M} {g : ‚Ñ§ ‚Üí* M} (h_neg_one : ‚Üëf (-1) = ‚Üëg (-1))\n  (h_nat : MonoidHom.comp f ‚ÜëInt.ofNatHom = MonoidHom.comp g ‚ÜëInt.ofNatHom), f = g","name":"MonoidHom.ext_int","isProp":true,"docString":"If two `MonoidHom`s agree on `-1` and the naturals then they are equal. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] {f : ZeroHom M N} {g : ZeroHom M N} (h : f = g)\n  (x : M), ‚Üëf x = ‚Üëg x","name":"ZeroHom.congr_fun","isProp":true,"docString":"Deprecated: use `FunLike.congr_fun` instead."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasEqualizers C]\n  {X' : C} (h : X' ‚ü∂ X) [inst_2 : CategoryTheory.Epi h] (f : X ‚ü∂ Y) [inst_3 : CategoryTheory.Limits.HasImage f]\n  [inst_4 : CategoryTheory.Limits.HasImage (h ‚â´ f)],\n  CategoryTheory.Epi\n    (CategoryTheory.Subobject.ofLE (CategoryTheory.Limits.imageSubobject (h ‚â´ f))\n      (CategoryTheory.Limits.imageSubobject f)\n      ((CategoryTheory.Limits.imageSubobject_comp_le h\n            f=:CategoryTheory.Limits.imageSubobject (h ‚â´ f) ‚â§\n            CategoryTheory.Limits.imageSubobject\n              f)=:CategoryTheory.Limits.imageSubobject (h ‚â´ f) ‚â§ CategoryTheory.Limits.imageSubobject f))","name":"CategoryTheory.Limits.imageSubobject_comp_le_epi_of_epi","isProp":true,"docString":"The morphism `imageSubobject (h ‚â´ f) ‚ü∂ imageSubobject f`\nis an epimorphism when `h` is an epimorphism.\nIn general this does not imply that `imageSubobject (h ‚â´ f) = imageSubobject f`,\nalthough it will when the ambient category is abelian.\n "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M],\n  (¬¨(IsSMulRegular M 0 : Prop) : Prop) ‚Üî (Nontrivial M : Prop)","name":"IsSMulRegular.not_zero_iff","isProp":true,"docString":"The `0` element is not `M`-regular, on a non-trivial module. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : LE Œ±] [inst_1 : LE Œ≤]\n  [inst_2 : BoundedOrder Œ±] [inst_3 : BoundedOrder Œ≤] [self : BoundedOrderHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä• = ‚ä•","name":"BoundedOrderHomClass.map_bot","isProp":true,"docString":"Morphisms preserve the bottom element. The preferred spelling is `_root_.map_bot`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderBot Œ±] [self : IsAtomic Œ±] (b : Œ±),\n  (b = ‚ä• : Prop) ‚à® (‚àÉ (a : Œ±), (IsAtom a : Prop) ‚àß (a ‚â§ b : Prop) : Prop)","name":"IsAtomic.eq_bot_or_exists_atom_le","isProp":true,"docString":"Every element other than `‚ä•` has an atom below it. "},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) (s : Set (Sym2 V)),\n  SimpleGraph.edgeSet G \\ (s \\ setOf fun (e : Sym2 V) ‚Ü¶ Sym2.IsDiag e) = SimpleGraph.edgeSet G \\ s","name":"SimpleGraph.edgeSet_sdiff_sdiff_isDiag","isProp":true,"docString":"This lemma, combined with `edgeSet_sdiff` and `edgeSet_from_edgeSet`,\nallows proving `(G \\ from_edgeSet s).edge_set = G.edgeSet \\ s` by `simp`. "},{"type":"‚àÄ {R : Type u_1} {F : Type u_2} [inst : AddCommGroup F] [inst_1 : TopologicalSpace F] [inst_2 : TopologicalAddGroup F]\n  [inst_3 : Ring R] [inst_4 : Module R F] [inst_5 : TopologicalSpace R] [inst_6 : ContinuousSMul R F] {p : F} {v : F},\n  Continuous ‚Üë(AffineMap.lineMap p v)","name":"AffineMap.lineMap_continuous","isProp":true,"docString":"The line map is continuous. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M]\n  [inst_2 : SemilatticeSup M] [inst_3 : OrderBot M] (w : (a : œÉ) ‚Üí M), MvPolynomial.weightedTotalDegree w 0 = ‚ä•","name":"MvPolynomial.weightedTotalDegree_zero","isProp":true,"docString":"The `weightedTotalDegree` of the zero polynomial is `‚ä•`. "},{"type":"‚àÄ {H : Type u_1} {M : Type u_2} {H' : Type u_3} {M' : Type u_4} [inst : TopologicalSpace H]\n  [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M] [inst_3 : TopologicalSpace H']\n  [inst_4 : TopologicalSpace M'] [inst_5 : ChartedSpace H' M'] {G : StructureGroupoid H} {G' : StructureGroupoid H'}\n  {P : (a : (a : H) ‚Üí H') ‚Üí (a : Set H) ‚Üí (a : H) ‚Üí Prop} {s : Set M} {x : M}\n  (hG : StructureGroupoid.LocalInvariantProp G G' P) {f : (a : M) ‚Üí M'},\n  (ChartedSpace.LiftPropWithinAt P f s x : Prop) ‚Üî\n    ((ContinuousWithinAt f s x : Prop) ‚àß\n        (P (‚Üë(chartAt (f x)) ‚àò f ‚àò ‚Üë(LocalHomeomorph.symm (chartAt x)))\n            (LocalEquiv.target (LocalHomeomorph.toLocalEquiv (chartAt x)) ‚à©\n              ‚Üë(LocalHomeomorph.symm (chartAt x)) ‚Åª¬π'\n                (s ‚à© f ‚Åª¬π' LocalEquiv.source (LocalHomeomorph.toLocalEquiv (chartAt (f x)))))\n            (‚Üë(chartAt x) x) :\n          Prop) :\n      Prop)","name":"StructureGroupoid.LocalInvariantProp.liftPropWithinAt_iff","isProp":true,"docString":"`LiftPropWithinAt P f s x` is equivalent to a definition where we restrict the set we are\nconsidering to the domain of the charts at `x` and `f x`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  (a_1 : a‚Åª¬π ‚â§ 1), 1 ‚â§ a","name":"one_le_of_inv_le_one","isProp":true,"docString":"**Alias** of the forward direction of `Left.inv_le_one_iff`."},{"type":"‚àÄ {R : Type u_2} [inst : CommRing R] (M : Submonoid R) {S : Type u_3} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsLocalization M S] {Œπ : Type u_1} (s : Finset Œπ) (f : (a : Œπ) ‚Üí S),\n  ‚àÉ (b : { x : R // x ‚àà M }), ‚àÄ (i : Œπ) (a : i ‚àà s), IsLocalization.IsInteger R (‚Üëb ‚Ä¢ f i)","name":"IsLocalization.exist_integer_multiples","isProp":true,"docString":"We can clear the denominators of a `Finset`-indexed family of fractions. "},{"type":"‚àÄ {Œ± : Type u} [self : Lattice Œ±] (a : Œ±) (b : Œ±), a ‚äì b ‚â§ b","name":"Lattice.inf_le_right","isProp":true,"docString":"The infimum is a lower bound on the second argument "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {X' : C} (h : X' ‚ü∂ X) (f : X ‚ü∂ Y)\n  [inst_1 : CategoryTheory.Limits.HasImage f] [inst_2 : CategoryTheory.Limits.HasImage (h ‚â´ f)],\n  CategoryTheory.Limits.imageSubobject (h ‚â´ f) ‚â§ CategoryTheory.Limits.imageSubobject f","name":"CategoryTheory.Limits.imageSubobject_comp_le","isProp":true,"docString":"The image of `h ‚â´ f` is always a smaller subobject than the image of `f`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsClosed s : Prop) ‚Üî (‚àÄ (x : Œ±) (a : Filter.Frequently (fun (y : Œ±) ‚Ü¶ y ‚àà s) (nhds x)), x ‚àà s : Prop)","name":"isClosed_iff_frequently","isProp":true,"docString":"A set `s` is closed iff for every point `x`, if there is a point `y` close to `x` that belongs\nto `s` then `x` is in `s`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} (H : IsPreconnected s)\n  (f : (a : Œ±) ‚Üí Œ≤) (hf : ContinuousOn f s), IsPreconnected (f '' s)","name":"IsPreconnected.image","isProp":true,"docString":"The image of a (pre)connected set is (pre)connected as well. "},{"type":"‚àÄ {Œ± : Type u} [inst : LT Œ±] [inst_1 : WellFoundedLT Œ±] (a : Œ±), Acc (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1) a","name":"WellFoundedLT.apply","isProp":true,"docString":"All values are accessible under the well-founded `<`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X‚ÇÅ‚ÇÅ : C} {X‚ÇÅ‚ÇÇ : C} {X‚ÇÅ‚ÇÉ : C} {X‚ÇÇ‚ÇÅ : C} {X‚ÇÇ‚ÇÇ : C} {X‚ÇÇ‚ÇÉ : C}\n  {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÅ‚ÇÉ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÉ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ}\n  {v‚ÇÅ‚ÇÉ : X‚ÇÅ‚ÇÉ ‚ü∂ X‚ÇÇ‚ÇÉ} (s : CategoryTheory.IsPullback h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) (t : CategoryTheory.IsPullback h‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÇ v‚ÇÅ‚ÇÉ h‚ÇÇ‚ÇÇ),\n  CategoryTheory.IsPullback (h‚ÇÅ‚ÇÅ ‚â´ h‚ÇÅ‚ÇÇ) v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÉ (h‚ÇÇ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÇ)","name":"CategoryTheory.IsPullback.paste_horiz","isProp":true,"docString":"Paste two pullback squares \"horizontally\" to obtain another pullback square. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤} (a : LocalEquiv.IsImage e s t),\n  LocalEquiv.source e ‚à© LocalEquiv.toFun e ‚Åª¬π' t = LocalEquiv.source e ‚à© s","name":"LocalEquiv.IsImage.preimage_eq","isProp":true,"docString":"**Alias** of the forward direction of `LocalEquiv.IsImage.iff_preimage_eq`."},{"type":"‚àÄ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M‚ÇÅ : Type v}\n  [inst_3 : AddCommGroup M‚ÇÅ] [inst_4 : Module R M‚ÇÅ] (f : M ‚âÉ‚Çó[R] M‚ÇÅ), Module.rank R M = Module.rank R M‚ÇÅ","name":"LinearEquiv.rank_eq","isProp":true,"docString":"Two linearly equivalent vector spaces have the same dimension. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] (x : Œ≤),\n  MulAction.IsPretransitive Œ± ‚Üë(MulAction.orbit Œ± x)","name":"MulAction.instIsPretransitiveElemOrbitToMonoidToDivInvMonoidToSMulInstMulActionElemOrbit","isProp":true,"docString":"The action of a group on an orbit is transitive. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] ‚¶És : Set M‚¶Ñ ‚¶Ét : Set M‚¶Ñ (h : s ‚äÜ t),\n  AddSubsemigroup.closure s ‚â§ AddSubsemigroup.closure t","name":"AddSubsemigroup.closure_mono","isProp":true,"docString":"Additive subsemigroup closure of a set is monotone in its argument: if `s ‚äÜ t`,\nthen `closure s ‚â§ closure t`"},{"type":"‚àÄ {Y : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : TopologicalSpace Y] [inst_1 : UniformSpace Œ±]\n  [inst_2 : UniformSpace Œ≤] {A : Set Y} {u : (a : Y) ‚Üí (a : Œ≤) ‚Üí Œ±} (hA : UniformEquicontinuous (u ‚àò Subtype.val))\n  (hu : Continuous u), UniformEquicontinuous (u ‚àò Subtype.val)","name":"UniformEquicontinuous.closure'","isProp":true,"docString":"A version of `UniformEquicontinuous.closure` applicable to subsets of types which embed\ncontinuously into `Œ≤ ‚Üí Œ±` with the product topology. It turns out we don't need any other condition\non the embedding than continuity, but in practice this will mostly be applied to `FunLike` types\nwhere the coercion is injective. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {m : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤} {p : (a : Œ≤) ‚Üí Prop}\n  {f : (a : Œ±) ‚Üí Subtype p} (hf : Measurable f), Measurable fun (a : Œ±) ‚Ü¶ ‚Üë(f a)","name":"Measurable.subtype_val","isProp":true,"docString":"**Alias** of `Measurable.subtype_coe`."},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_1} {M : Type u_2} {M' : Type u_3} {v : (a : Œπ) ‚Üí M} [inst : Semiring R]\n  [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M'] [inst_3 : Module R M] [inst_4 : Module R M']\n  (hv : LinearIndependent R v) {f : M ‚Üí‚Çó[R] M'} (hf_inj : Disjoint (Submodule.span R (Set.range v)) (LinearMap.ker f)),\n  LinearIndependent R (‚Üëf ‚àò v)","name":"LinearIndependent.map","isProp":true,"docString":"If `v` is a linearly independent family of vectors and the kernel of a linear map `f` is\ndisjoint with the submodule spanned by the vectors of `v`, then `f ‚àò v` is a linearly independent\nfamily of vectors. See also `LinearIndependent.map'` for a special case assuming `ker f = ‚ä•`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (h : Set.Nonempty (s ‚à© t)),\n  Metric.diam (s ‚à™ t) ‚â§ Metric.diam s + Metric.diam t","name":"Metric.diam_union'","isProp":true,"docString":"If two sets intersect, the diameter of the union is bounded by the sum of the diameters. "},{"type":"‚àÄ (b : Ordinal) (o : Ordinal),\n  List.Sorted (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x > x_1) (List.map Prod.fst (Ordinal.CNF b o))","name":"Ordinal.CNF_sorted","isProp":true,"docString":"The exponents of the Cantor normal form are decreasing. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : C ‚•§ D} (Œ± : F ‚ü∂ G) [inst_2 : CategoryTheory.IsIso Œ±] (X : C), CategoryTheory.IsIso (Œ±.app X)","name":"CategoryTheory.NatIso.isIso_app_of_isIso","isProp":true,"docString":"The components of a natural isomorphism are isomorphisms.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompactSpace Œ±], CompactSpace (TopologicalSpace.Closeds Œ±)","name":"EMetric.Closeds.compactSpace","isProp":true,"docString":"In a compact space, the type of closed subsets is compact. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} {r : ‚Ñö} (hqr : q + r ‚â† 0) (h : padicValRat p q ‚â§ padicValRat p r),\n  padicValRat p q ‚â§ padicValRat p (q + r)","name":"padicValRat.le_padicValRat_add_of_le","isProp":true,"docString":"Sufficient conditions to show that the `p`-adic valuation of `q` is less than or equal to the\n`p`-adic valuation of `q + r`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ‚àà s),\n  ‚Üë(AffineSubspace.direction s) = (fun (x : P) (x_1 : P) ‚Ü¶ x -·µ• x_1) p '' ‚Üës","name":"AffineSubspace.coe_direction_eq_vsub_set_left","isProp":true,"docString":"Given a point in an affine subspace, the set of vectors in its direction equals the set of\nvectors subtracting that point on the left. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} [inst : DistribLattice Œ±] [inst_1 : OrderBot Œ±] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  (a : Finset.SupIndep s f), Set.PairwiseDisjoint (‚Üës) f","name":"Finset.sup_indep.pairwise_disjoint","isProp":true,"docString":"**Alias** of the forward direction of `Finset.supIndep_iff_pairwiseDisjoint`."},{"type":"‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\n  (Nonempty (M ‚âÉ‚Çó[R] N) : Prop) ‚Üî (FiniteDimensional.finrank R M = FiniteDimensional.finrank R N : Prop)","name":"FiniteDimensional.nonempty_linearEquiv_iff_finrank_eq","isProp":true,"docString":"Two finite and free modules are isomorphic if and only if they have the same (finite) rank. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Div Œ±] {u : Finset Œ±} {s : Set Œ±} {t : Set Œ±} (a : ‚Üëu ‚äÜ s / t),\n  ‚àÉ (s' : Finset Œ±), ‚àÉ (t' : Finset Œ±), (‚Üës' ‚äÜ s : Prop) ‚àß ((‚Üët' ‚äÜ t : Prop) ‚àß (u ‚äÜ s' / t' : Prop) : Prop)","name":"Finset.subset_div","isProp":true,"docString":"If a finset `u` is contained in the product of two sets `s / t`, we can find two finsets `s'`,\n`t'` such that `s' ‚äÜ s`, `t' ‚äÜ t` and `u ‚äÜ s' / t'`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {t : Set Œ≤} {f : (a : Œ±) ‚Üí Œ≤} (h : ‚àÄ (x : ‚Üës), f ‚Üëx ‚àà t),\n  Set.codRestrict (Set.restrict s f) t h =\n    Set.MapsTo.restrict f s t\n      (fun (x : Œ±) ‚Ü¶\n        (_ :\n          ‚àÄ (hx : x ‚àà s),\n            f ‚Üë{ val := x, property := hx } ‚àà t)=:‚àÄ (x : Œ±) (hx : x ‚àà s), f ‚Üë{ val := x, property := hx } ‚àà t)","name":"Set.codRestrict_restrict","isProp":true,"docString":"Restricting the domain and then the codomain is the same as `MapsTo.restrict`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] (a : Œ±),\n  Finset.max' {a} ((Finset.singleton_nonempty a=:Finset.Nonempty {a})=:Finset.Nonempty {a}) = a","name":"Finset.max'_singleton","isProp":true,"docString":"`{a}.max' _` is `a`. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] (I : Ideal R) (J : Ideal R), I ‚Ä¢ J = I * J","name":"Ideal.smul_eq_mul","isProp":true,"docString":"This duplicates the global `smul_eq_mul`, but doesn't have to unfold anywhere near as much to\napply. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {x : M} {y : M}, (y ‚àà Submonoid.closure {x} : Prop) ‚Üî (‚àÉ (n : ‚Ñï), x ^ n = y : Prop)","name":"Submonoid.mem_closure_singleton","isProp":true,"docString":"The submonoid generated by an element of a monoid equals the set of natural number powers of\nthe element. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hab : a = b) (hbc : b < c), a < c","name":"Eq.trans_lt","isProp":true,"docString":"**Alias** of `lt_of_eq_of_lt`."},{"type":"‚àÄ {S : Type v} [inst : CommRing S] (d : ‚Ñï) (y : S),\n  Polynomial.eval (1 + y) (‚Üë(Polynomial.monomial d) (‚Üëd + 1)) - Polynomial.eval y (‚Üë(Polynomial.monomial d) (‚Üëd + 1)) =\n    Finset.sum (Finset.range (d + 1)) fun (x_1 : ‚Ñï) ‚Ü¶ ‚Üë(Nat.choose (d + 1) x_1) * (‚Üëx_1 * y ^ (x_1 - 1))","name":"Polynomial.eval_monomial_one_add_sub","isProp":true,"docString":"A reformulation of the expansion of (1 + y)^d:\n$$(d + 1) (1 + y)^d - (d + 1)y^d = \\sum_{i = 0}^d {d + 1 \\choose i} \\cdot i \\cdot y^{i - 1}.$$\n"},{"type":"‚àÄ {k : Type u_3} {V : Type u_5} {P : Type u_6} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_4} (s : Finset Œπ) {V‚ÇÇ : Type u_1} {P‚ÇÇ : Type u_2} [inst_3 : AddCommGroup V‚ÇÇ]\n  [inst_4 : Module k V‚ÇÇ] [inst_5 : AddTorsor V‚ÇÇ P‚ÇÇ] (p : (a : Œπ) ‚Üí P) (w : (a : Œπ) ‚Üí k) (hw : Finset.sum s w = 1)\n  (f : P ‚Üí·µÉ[k] P‚ÇÇ), ‚Üëf (‚Üë(Finset.affineCombination k s p) w) = ‚Üë(Finset.affineCombination k s (‚Üëf ‚àò p)) w","name":"Finset.map_affineCombination","isProp":true,"docString":"Affine maps commute with affine combinations. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) (E : Set Œ±), closure E ‚äÜ Metric.thickening Œ¥ E","name":"Metric.closure_subset_thickening","isProp":true,"docString":"The (open) thickening of a set contains the closure of the set. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : D ‚•§ C} (self : CategoryTheory.Adjunction.CoreUnitCounit F G),\n  CategoryTheory.whiskerRight (CategoryTheory.Adjunction.CoreUnitCounit.unit self) F ‚â´\n      CategoryTheory.Iso.hom (CategoryTheory.Functor.associator F G F) ‚â´\n        CategoryTheory.whiskerLeft F (CategoryTheory.Adjunction.CoreUnitCounit.counit self) =\n    CategoryTheory.NatTrans.id (ùü≠ C ‚ãô F)","name":"CategoryTheory.Adjunction.CoreUnitCounit.left_triangle","isProp":true,"docString":"Equality of the composition of the unit, associator, and counit with the identity\n`F ‚ü∂ (F G) F ‚ü∂ F (G F) ‚ü∂ F = NatTrans.id F` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (H : IsPreconnected s) (Kst : s ‚äÜ t)\n  (Ktcs : t ‚äÜ closure s), IsPreconnected t","name":"IsPreconnected.subset_closure","isProp":true,"docString":"Theorem of bark and tree: if a set is within a (pre)connected set\nand its closure, then it is (pre)connected as well. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} (f : 0 ‚ü∂ X), f = 0","name":"CategoryTheory.Limits.zero_of_from_zero","isProp":true,"docString":"An arrow starting at the zero object is zero "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : T2Space Œ±] [inst_3 : Countable Œ≥] [inst_4 : CompleteLattice Œ≤] (m : (a : Œ≤) ‚Üí Œ±) (m0 : m ‚ä• = 0)\n  (R : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop)\n  (m_sup·µ¢ : ‚àÄ (s : (a : ‚Ñï) ‚Üí Œ≤), R (m (sup·µ¢ fun (i : ‚Ñï) ‚Ü¶ s i)) (tsum fun (i : ‚Ñï) ‚Ü¶ m (s i))) (s : (a : Œ≥) ‚Üí Œ≤),\n  R (m (sup·µ¢ fun (b : Œ≥) ‚Ü¶ s b)) (tsum fun (b : Œ≥) ‚Ü¶ m (s b))","name":"rel_sup·µ¢_tsum","isProp":true,"docString":"If a function is countably sub-additive then it is sub-additive on countable types "},{"type":"‚àÄ {l : ‚Ñï} {m : ‚Ñï} {Œ± : Type u_1} [inst : NonUnitalNonAssocSemiring Œ±] (A : Matrix (Fin l) (Fin m) Œ±)\n  (v : (a : Fin m) ‚Üí Œ±), Matrix.mulVec·µ£ A v = Matrix.mulVec A v","name":"Matrix.mulVec·µ£_eq","isProp":true,"docString":"This can be used to prove\n```lean\nexample [NonUnitalNonAssocSemiring Œ±] (a‚ÇÅ‚ÇÅ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÅ a‚ÇÇ‚ÇÇ b‚ÇÅ b‚ÇÇ : Œ±) :\n  !![a‚ÇÅ‚ÇÅ, a‚ÇÅ‚ÇÇ;\n     a‚ÇÇ‚ÇÅ, a‚ÇÇ‚ÇÇ].mulVec ![b‚ÇÅ, b‚ÇÇ] = ![a‚ÇÅ‚ÇÅ*b‚ÇÅ + a‚ÇÅ‚ÇÇ*b‚ÇÇ, a‚ÇÇ‚ÇÅ*b‚ÇÅ + a‚ÇÇ‚ÇÇ*b‚ÇÇ] :=\n(mulVec·µ£_eq _ _).symm\n```\n"},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] ‚¶És : Set Œ±‚¶Ñ ‚¶Ét : Set Œ±‚¶Ñ (h : s ‚äÜ t) (a : BddBelow t), BddBelow s","name":"BddBelow.mono","isProp":true,"docString":"If `s ‚äÜ t` and `t` is bounded below, then so is `s`. "},{"type":"‚àÄ {A : Type u_1} {Œπ : Type u_2} [inst : Ring A] {B : (a : Œπ) ‚Üí AddSubgroup A} (self : RingSubgroupsBasis B) (i : Œπ)\n  (j : Œπ), ‚àÉ (k : Œπ), B k ‚â§ B i ‚äì B j","name":"RingSubgroupsBasis.inter","isProp":true,"docString":"Condition for `B` to be a filter basis on `A`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a < b), ¬¨(IsMax a : Prop)","name":"LT.lt.not_isMax","isProp":true,"docString":"**Alias** of `not_isMax_of_lt`."},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M} {t : Set M} (ht : IsSubmonoid t) (h : s ‚äÜ t), Monoid.Closure s ‚äÜ t","name":"Monoid.closure_subset","isProp":true,"docString":"The submonoid generated by a set is contained in any submonoid that contains the set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Setoid Œ±] {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n  {H : ‚àÄ (a‚ÇÅ : Œ±) (b‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) (b‚ÇÇ : Œ±) (a : a‚ÇÅ ‚âà a‚ÇÇ) (a : b‚ÇÅ ‚âà b‚ÇÇ), (r a‚ÇÅ b‚ÇÅ : Prop) = (r a‚ÇÇ b‚ÇÇ : Prop)}\n  (a : WellFounded (Quotient.lift‚ÇÇ r H)), WellFounded r","name":"WellFounded.of_quotient_lift‚ÇÇ","isProp":true,"docString":"**Alias** of the forward direction of `wellFounded_lift‚ÇÇ_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedLinearOrderedField Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx - y‚Äñ","name":"NormedLinearOrderedField.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C], CategoryTheory.Bicategory.Strict (CategoryTheory.LocallyDiscrete C)","name":"CategoryTheory.locallyDiscreteBicategory.strict","isProp":true,"docString":"A locally discrete bicategory is strict. "},{"type":"‚àÄ {Œ± : Type u_1} {la : Filter Œ±} {s : Set (Œ± √ó Œ±)},\n  (s ‚àà Filter.prod la la : Prop) ‚Üî (‚àÉ (t : Set Œ±), (t ‚àà la : Prop) ‚àß (t √óÀ¢ t ‚äÜ s : Prop) : Prop)","name":"Filter.mem_prod_same_iff","isProp":true,"docString":"**Alias** of `Filter.mem_prod_self_iff`."},{"type":"‚àÄ {m : Type u_1} {n : Type u_2} {Œ± : Type v} [inst : Star Œ±] (M : Matrix m n Œ±) (i : m) (j : n),\n  Matrix.conjTranspose M j i = star (M i j)","name":"Matrix.conjTranspose_apply","isProp":true,"docString":"Tell `simp` what the entries are in a conjugate transposed matrix.\n\nCompare with `mul_apply`, `diagonal_apply_eq`, etc.\n"},{"type":"‚àÄ {Œ± : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsWellFounded Œ± r] (a : Œ±), Acc r a","name":"IsWellFounded.apply","isProp":true,"docString":"All values are accessible under the well-founded relation. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {a : Œ±} {b : Œ±} (h : a ‚â† b),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà {a, b}) ‚Ü¶ f i) = f a * f b","name":"finprod_mem_pair","isProp":true,"docString":"The product of `f i` over `i ‚àà {a, b}`, `a ‚â† b`, is equal to `f a * f b`. "},{"type":"‚àÄ (a : Prop), ((a : Prop) = (True : Prop) : Prop) ‚à® ((a : Prop) = (False : Prop) : Prop)","name":"Classical.prop_complete","isProp":true,"docString":"**Alias** of `Classical.propComplete`."},{"type":"‚àÄ {Œπ : Type u_1} {x : ‚Ñï} {s : (a : Œπ) ‚Üí ‚Ñï} {t : Finset Œπ} (a : ‚àÄ (i : Œπ) (a : i ‚àà t), Nat.coprime x (s i)),\n  Nat.coprime x (Finset.prod t fun (i : Œπ) ‚Ü¶ s i)","name":"Nat.coprime_prod_right","isProp":true,"docString":"See `IsCoprime.prod_right` for the corresponding lemma about `IsCoprime` "},{"type":"‚àÄ (R : Type u_1) {S : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M]\n  [inst_3 : SMul R S] [inst_4 : Module S M] [inst_5 : Module R M] [inst_6 : IsScalarTower R S M] (h : IsNoetherian R M),\n  IsNoetherian S M","name":"isNoetherian_of_tower","isProp":true,"docString":"If `M / S / R` is a scalar tower, and `M / R` is Noetherian, then `M / S` is\nalso noetherian. "},{"type":"‚àÄ {k : Type u_1} {M : Type u_2} [inst : OrderedSemiring k] [inst_1 : OrderedAddCommGroup M] [inst_2 : Module k M]\n  [inst_3 : OrderedSMul k M] {a : M} {c : k} (hc : 0 < c) (a_1 : a < 0), c ‚Ä¢ a < 0","name":"smul_neg_of_pos_of_neg","isProp":true,"docString":"**Alias** of the reverse direction of `smul_neg_iff_of_pos`."},{"type":"‚àÄ {R : Type u_1} {X : Type u_2} [inst : CommSemiring R] [inst_1 : CharZero R], CharZero (FreeAlgebra R X)","name":"FreeAlgebra.charZero","isProp":true,"docString":"If `R` has characteristic `0`, then so does `FreeAlgebra R X`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set (Set Œ±)} (hs : Cardinal.mk ‚Üës ‚â§ Cardinal.continuum),\n  Cardinal.mk ‚Üë(setOf fun (t : Set Œ±) ‚Ü¶ MeasurableSpace.GenerateMeasurable s t) ‚â§ Cardinal.continuum","name":"MeasurableSpace.cardinal_generateMeasurable_le_continuum","isProp":true,"docString":"If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,\nthen the sigma algebra has the same cardinality bound. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b) (a_2 : b ‚â† a), a < b","name":"LE.le.lt_of_ne'","isProp":true,"docString":"**Alias** of `lt_of_le_of_ne'`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (hs : IsCompact s) {f : Filter Œ±}\n  (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), s·∂ú ‚àà nhds a ‚äì f), s·∂ú ‚àà f","name":"IsCompact.compl_mem_sets","isProp":true,"docString":"The complement to a compact set belongs to a filter `f` if it belongs to each filter\n`ùìù a ‚äì f`, `a ‚àà s`. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (p : Polynomial R),\n  Multiset.prod (Multiset.map (fun (a : R) ‚Ü¶ Polynomial.X - ‚ÜëPolynomial.C a) (Polynomial.roots p)) ‚à£ p","name":"Polynomial.prod_multiset_X_sub_C_dvd","isProp":true,"docString":"The product `‚àè (X - a)` for `a` inside the multiset `p.roots` divides `p`. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Inv G] [inst_2 : ContinuousInv G] {Œπ : Type u_1},\n  ContinuousInv ((a : Œπ) ‚Üí G)","name":"Pi.has_continuous_inv'","isProp":true,"docString":"A version of `Pi.continuousInv` for non-dependent functions. It is needed because sometimes\nLean fails to use `Pi.continuousInv` for non-dependent functions. "},{"type":"‚àÄ {R : Type u_2} [inst : EuclideanDomain R] {abv : AbsoluteValue R ‚Ñ§} {Œπ : Type u_1} [inst_1 : Fintype Œπ] {Œµ : ‚Ñù}\n  (hŒµ : 0 < Œµ) {b : R} (hb : b ‚â† 0) (A : (a : Œπ) ‚Üí R) (h : AbsoluteValue.IsAdmissible abv),\n  ‚àÉ (t : (a : Œπ) ‚Üí Fin (AbsoluteValue.IsAdmissible.card h Œµ)),\n    ‚àÄ (i‚ÇÄ : Œπ) (i‚ÇÅ : Œπ) (a : t i‚ÇÄ = t i‚ÇÅ), ‚Üë(‚Üëabv (A i‚ÇÅ % b - A i‚ÇÄ % b)) < ‚Üëabv b ‚Ä¢ Œµ","name":"AbsoluteValue.IsAdmissible.exists_partition","isProp":true,"docString":"For all `Œµ > 0` and finite families `A`, we can partition the remainders of `A` mod `b`\ninto `abv.card Œµ` sets, such that all elements in each part of remainders are close together. "},{"type":"‚àÄ {Œ± : Type u_1} (f : Filter Œ±) [inst : Filter.IsCountablyGenerated f],\n  ‚àÉ (x : (a : ‚Ñï) ‚Üí Set Œ±), Filter.HasAntitoneBasis f x","name":"Filter.exists_antitone_basis","isProp":true,"docString":"A countably generated filter admits a basis formed by an antitone sequence of sets. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [inst : CommSemiring k] [inst_1 : Monoid G] {A : Type u‚ÇÉ} [inst_2 : Semiring A]\n  [inst_3 : Algebra k A] ‚¶ÉœÜ‚ÇÅ : MonoidAlgebra k G ‚Üí‚Çê[k] A‚¶Ñ ‚¶ÉœÜ‚ÇÇ : MonoidAlgebra k G ‚Üí‚Çê[k] A‚¶Ñ\n  (h : MonoidHom.comp (‚ÜëœÜ‚ÇÅ) (MonoidAlgebra.of k G) = MonoidHom.comp (‚ÜëœÜ‚ÇÇ) (MonoidAlgebra.of k G)), œÜ‚ÇÅ = œÜ‚ÇÇ","name":"MonoidAlgebra.algHom_ext'","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {p‚ÇÅ : (a : Œ±) ‚Üí Prop} {a : Type u_1} {p‚ÇÇ : (a : a) ‚Üí Prop} {y : m a}\n  {q : (a : Œ±) ‚Üí Prop} [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m Œ±} (hx : SatisfiesM p‚ÇÅ x)\n  (hy : SatisfiesM p‚ÇÇ y) (H : ‚àÄ {a_1 : Œ±} {b : a} (a : p‚ÇÅ a_1) (a : p‚ÇÇ b), q a_1),\n  SatisfiesM q (SeqLeft.seqLeft x fun (x : Unit) ‚Ü¶ y)","name":"SatisfiesM.seqLeft","isProp":true,"docString":"`SatisfiesM` distributes over `<*`, general version. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] (x : (i : Œπ) ‚Üí Œ≤ i)\n  (y : (i : Œπ) ‚Üí Œ≤ i) (z : (i : Œπ) ‚Üí Œ≤ i), hammingDist x z ‚â§ hammingDist x y + hammingDist y z","name":"hammingDist_triangle","isProp":true,"docString":"Corresponds to `dist_triangle`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommMonoidWithZero Œ±] (a : Œ±), 0 * a = 0","name":"LinearOrderedCommMonoidWithZero.zero_mul","isProp":true,"docString":"Zero is a left absorbing element for multiplication "},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} {m : ‚Ñï} (hc : c ‚â† 0) (a_1 : c * a ‚â° c * b [MOD c * m]), a ‚â° b [MOD m]","name":"Nat.ModEq.mul_left_cancel'","isProp":true,"docString":"Cancel left multiplication on both sides of the `‚â°` and in the modulus.\n\nFor cancelling left multiplication in the modulus, see `Nat.ModEq.of_mul_left`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] ‚¶Éf : M ‚Üí* N‚¶Ñ ‚¶Ég : M ‚Üí* N‚¶Ñ (h : ‚Üëf = ‚Üëg),\n  f = g","name":"MonoidHom.coe_inj","isProp":true,"docString":"Deprecated: use `FunLike.coe_injective` instead. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {Œπ : Type v} (hs : IsCompact s) (Z : (a : Œπ) ‚Üí Set Œ±)\n  (hZc : ‚àÄ (i : Œπ), IsClosed (Z i))\n  (hsZ : ‚àÄ (t : Finset Œπ), Set.Nonempty (s ‚à© Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà t) ‚Ü¶ Z i)),\n  Set.Nonempty (s ‚à© Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Z i)","name":"IsCompact.inter_inter·µ¢_nonempty","isProp":true,"docString":"To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. "},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_1} {M : Type u_2} {v : (a : Œπ) ‚Üí M} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] (a : LinearIndependent R v), Function.Injective ‚Üë(Finsupp.total Œπ M R v)","name":"LinearIndependent.injective_total","isProp":true,"docString":"**Alias** of the forward direction of `linearIndependent_iff_injective_total`."},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : Add A] [inst_1 : Add B] [inst_2 : Mul A] [inst_3 : Mul B]\n  [inst_4 : SMul R A] [inst_5 : SMul R B] [inst_6 : Star A] [inst_7 : Star B] (self : A ‚âÉ‚ãÜ‚Çê[R] B) (a : A),\n  Equiv.toFun (RingEquiv.toEquiv (StarAlgEquiv.toRingEquiv self)) (star a) =\n    star (Equiv.toFun (RingEquiv.toEquiv (StarAlgEquiv.toRingEquiv self)) a)","name":"StarAlgEquiv.map_star'","isProp":true,"docString":"By definition, a ‚ãÜ-algebra equivalence preserves the `star` operation. "},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : C(Œ±, Œ≤)} {Œπ : Type u‚ÇÉ}\n  {p : Filter Œπ} {F : (a : Œπ) ‚Üí C(Œ±, Œ≤)} (h : TendstoLocallyUniformly (fun (i : Œπ) (a : Œ±) ‚Ü¶ ‚Üë(F i) a) (‚Üëf) p),\n  Filter.Tendsto F p (nhds f)","name":"ContinuousMap.tendsto_of_tendstoLocallyUniformly","isProp":true,"docString":"Locally uniform convergence implies convergence in the compact-open topology. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [hf : CategoryTheory.IsSplitEpi f]\n  [hf' : CategoryTheory.Epi (CategoryTheory.section_ f)], CategoryTheory.IsIso f","name":"CategoryTheory.IsIso.of_epi_section","isProp":true,"docString":"Every split epi whose section is epi is an iso. "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] ‚¶Éf : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ N‚¶Ñ\n  ‚¶Ég : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ N‚¶Ñ (H : ‚àÄ (x : Œ±) (y : M), ‚Üëf (Finsupp.single x y) = ‚Üëg (Finsupp.single x y)), f = g","name":"Finsupp.addHom_ext","isProp":true,"docString":"If two additive homomorphisms from `Œ± ‚Üí‚ÇÄ M` are equal on each `single a b`,\nthen they are equal. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  {X : C} {Y : C} (p : X = Y),\n  CategoryTheory.Functor.mapIso F (CategoryTheory.eqToIso p) =\n    CategoryTheory.eqToIso\n      ((congr_arg (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F))\n            p=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X =\n            Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F)\n              Y)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X =\n          Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y)","name":"CategoryTheory.eqToIso_map","isProp":true,"docString":"See the note on `eqToHom_map` regarding using this as a `simp` lemma.\n"},{"type":"‚àÄ (G : Type u) [inst : RightCancelSemigroup G], IsRightCancelMul G","name":"RightCancelSemigroup.toIsRightCancelMul","isProp":true,"docString":"Any `RightCancelSemigroup` satisfies `IsRightCancelMul`. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\n  (œÜ : R ‚Üí+* S) (f : Polynomial R) (h_mon : Polynomial.Monic f) (h_irr : Irreducible (Polynomial.map œÜ f)),\n  Irreducible f","name":"Polynomial.Monic.irreducible_of_irreducible_map","isProp":true,"docString":"A polynomial over an integral domain `R` is irreducible if it is monic and\nirreducible after mapping into an integral domain `S`.\n\nA special case of this lemma is that a polynomial over `‚Ñ§` is irreducible if\nit is monic and irreducible over `‚Ñ§/p‚Ñ§` for some prime `p`.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ}\n  (h : CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.arrows S)) (f : CategoryTheory.Sieve.functor S ‚ü∂ P),\n  CategoryTheory.Sieve.functorInclusion S ‚â´ CategoryTheory.Presieve.IsSheafFor.extend h f = f","name":"CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend","isProp":true,"docString":"Show that the extension of `f : S.functor ‚ü∂ P` to all of `yoneda.obj X` is in fact an extension, ie\nthat the triangle below commutes, provided `P` is a sheaf for `S`\n\n      f\n   S  ‚Üí  P\n   ‚Üì  ‚Üó\n   yX\n\n"},{"type":"‚àÄ (Œ± : Type u) [inst : Preorder Œ±] [inst_1 : Nonempty Œ±] [inst_2 : NoMinOrder Œ±], ‚àÉ (f : (a : ‚Ñï) ‚Üí Œ±), StrictAnti f","name":"Nat.exists_strictAnti","isProp":true,"docString":"If `Œ±` is a nonempty preorder with no minimal elements, then there exists a strictly antitone\nfunction `‚Ñï ‚Üí Œ±`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {t : Set Œ±}\n  (Hf : MonotoneOn f t) {a : Œ±} (Ha : IsLeast t a), IsLeast (f '' t) (f a)","name":"MonotoneOn.map_isLeast","isProp":true,"docString":"A monotone map sends a least element of a set to a least element of its image. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C]\n  [inst_2 : CategoryTheory.Limits.HasPushouts C] {W : C} {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (g‚ÇÅ : X ‚ü∂ W)\n  [inst_3 : CategoryTheory.Epi g‚ÇÅ] (g‚ÇÇ : W ‚ü∂ Z) [inst_4 : CategoryTheory.Mono g‚ÇÇ] (hg : g‚ÇÅ ‚â´ g‚ÇÇ = g) (f' : W ‚ü∂ Y)\n  (hf : g‚ÇÅ ‚â´ f' = f) (t : CategoryTheory.Limits.PushoutCocone f g) (ht : CategoryTheory.Limits.IsColimit t),\n  CategoryTheory.Mono (CategoryTheory.Limits.PushoutCocone.inl t)","name":"CategoryTheory.Abelian.mono_inl_of_factor_thru_epi_mono_factorization","isProp":true,"docString":"Suppose `f` and `g` are two morphisms with a common domain and suppose we have written `g` as\nan epimorphism followed by a monomorphism. If `f` factors through the epi part of this\nfactorization, then any pushout of `g` along `f` is a monomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {c : ‚Ñù} {f : (a : Œ±) ‚Üí E}\n  {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l f g),\n  Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) l","name":"Asymptotics.IsBigOWith.bound","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigOWith_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {a : Œ±} {u : Œ±} (hu : IsUnit u), u ‚à£ a","name":"IsUnit.dvd","isProp":true,"docString":"Units of a monoid divide any element of the monoid. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] [inst_1 : Inhabited M] (l : List M) (h : l ‚â† []),\n  List.headI l * List.prod (List.tail l) = List.prod l","name":"List.headI_mul_tail_prod_of_ne_nil","isProp":true,"docString":"Same as `get?_zero_mul_tail_prod`, but avoiding the `List.headI` garbage complication by\nrequiring the list to be nonempty. "},{"type":"‚àÄ {Œ± : Type u} (f : Filter Œ±), (sup·µ¢ fun (g : Ultrafilter Œ±) ‚Ü¶ sup·µ¢ fun (_hg : ‚Üëg ‚â§ f) ‚Ü¶ ‚Üëg) = f","name":"Filter.sup·µ¢_ultrafilter_le_eq","isProp":true,"docString":"A filter equals the intersection of all the ultrafilters which contain it. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Nonempty Œ±] [inst : SemilatticeSup Œ±] {Œ≤ : Type u_2} [inst_1 : SeminormedAddCommGroup Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {b : Œ≤},\n  (Filter.Tendsto f Filter.atTop (nhds b) : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : 0 < Œµ), ‚àÉ (N : Œ±), ‚àÄ (n : Œ±) (a : N ‚â§ n), ‚Äñf n - b‚Äñ < Œµ : Prop)","name":"NormedAddCommGroup.tendsto_atTop","isProp":true,"docString":"A restatement of `MetricSpace.tendsto_atTop` in terms of the norm. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : D ‚•§ C} (self : CategoryTheory.Adjunction.CoreHomEquiv F G) {X' : C} {X : C} {Y : D} (f : X' ‚ü∂ X)\n  (g : X ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) Y),\n  ‚Üë(Equiv.symm (CategoryTheory.Adjunction.CoreHomEquiv.homEquiv self X' Y)) (f ‚â´ g) =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f ‚â´\n      ‚Üë(Equiv.symm (CategoryTheory.Adjunction.CoreHomEquiv.homEquiv self X Y)) g","name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_left_symm","isProp":true,"docString":"The property that describes how `homEquiv.symm` transforms compositions `X' ‚ü∂ X ‚ü∂ G Y` "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_1} {N : Type u_2} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid N] {s : Set Œ±}\n  (f : (a : Œ±) ‚Üí M) (g : M ‚Üí+ N) (hs : Set.Finite s),\n  ‚Üëg (finsum fun (j : Œ±) ‚Ü¶ finsum fun (h : j ‚àà s) ‚Ü¶ f j) = finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ ‚Üëg (f i)","name":"AddMonoidHom.map_finsum_mem","isProp":true,"docString":"Given an additive monoid homomorphism `g : M ‚Üí* N` and a function `f : Œ± ‚Üí M`, the\nvalue of `g` at the sum of `f i` over `i ‚àà s` equals the sum of `g (f i)` over `s`."},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {f : M ‚Üí* N} {g : M ‚Üí* N} (h : f = g)\n  (x : M), ‚Üëf x = ‚Üëg x","name":"MonoidHom.congr_fun","isProp":true,"docString":"Deprecated: use `FunLike.congr_fun` instead. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (a : IsOpen s), IsClosed (s·∂ú)","name":"IsOpen.isClosed_compl","isProp":true,"docString":"**Alias** of the reverse direction of `isClosed_compl_iff`."},{"type":"‚àÄ {L : outParam FirstOrder.Language} {F : Type u_3} {M : outParam (Type u_4)} {N : outParam (Type u_5)}\n  [inst : FunLike F M fun (x : M) ‚Ü¶ N] [inst_1 : FirstOrder.Language.Structure L M]\n  [inst_2 : FirstOrder.Language.Structure L N] [self : FirstOrder.Language.HomClass L F M N] (œÜ : F) {n : ‚Ñï}\n  (f : FirstOrder.Language.Functions L n) (x : (a : Fin n) ‚Üí M),\n  ‚ÜëœÜ (FirstOrder.Language.Structure.funMap f x) = FirstOrder.Language.Structure.funMap f (‚ÜëœÜ ‚àò x)","name":"FirstOrder.Language.HomClass.map_fun","isProp":true,"docString":"The homomorphism commutes with the interpretations of the function symbols "},{"type":"‚àÄ {n : ‚Ñï} {m : ‚Ñï} (h : ‚àÄ (i : ‚Ñï), Nat.testBit n i = Nat.testBit m i), n = m","name":"Nat.eq_of_testBit_eq","isProp":true,"docString":"Bitwise extensionality: Two numbers agree if they agree at every bit position. "},{"type":"‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (u : Œ±À£), ‚Üë(1 / u) = 1 /‚Çö u","name":"inv_eq_one_divp'","isProp":true,"docString":"Used for `field_simp` to deal with inverses of units. This form of the lemma\nis essential since `field_simp` likes to use `inv_eq_one_div` to rewrite\n`‚Üëu‚Åª¬π = ‚Üë(1 / u)`.\n"},{"type":"‚àÄ {k : Type u_2} {E : Type u_1} {PE : Type u_3} [inst : Field k] [inst_1 : AddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : AddTorsor E PE] (f : (a : k) ‚Üí PE) (a : k) (b : k) (r : k),\n  ‚Üë(AffineMap.lineMap (slope f (‚Üë(AffineMap.lineMap a b) r) b) (slope f a (‚Üë(AffineMap.lineMap a b) r))) r = slope f a b","name":"lineMap_slope_lineMap_slope_lineMap","isProp":true,"docString":"`slope f a b` is an affine combination of `slope f a (lineMap a b r)` and\n`slope f (lineMap a b r) b`. We use `lineMap` to express this property. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p‚ÇÅ : (a : Œπ) ‚Üí P) (p‚ÇÇ : (a : Œπ) ‚Üí P) (b : P),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ i)) =\n    ‚Üë(Finset.weightedVSubOfPoint s p‚ÇÅ b) w - ‚Üë(Finset.weightedVSubOfPoint s p‚ÇÇ b) w","name":"Finset.sum_smul_vsub_eq_weightedVSubOfPoint_sub","isProp":true,"docString":"A weighted sum of pairwise subtractions, expressed as a subtraction of two\n`weightedVSubOfPoint` expressions. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M]\n  [sM : Subsingleton M], IsSMulRegular M 0","name":"IsSMulRegular.zero","isProp":true,"docString":"The element `0` is `M`-regular when `M` is trivial. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] (u : AddUnits M) (a : M), (IsAddUnit (‚Üëu + a) : Prop) ‚Üî (IsAddUnit a : Prop)","name":"AddUnits.isAddUnit_addUnits_add","isProp":true,"docString":"Addition of a `u : AddUnits M` on the left doesn't affect `IsAddUnit`."},{"type":"‚àÄ {Œ± : Type u_1} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r","name":"Setoid.eqvGen_idem","isProp":true,"docString":"Equivalence closure is idempotent. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {Œº : (a : M) ‚Üí (a : N) ‚Üí N} {r : (a : N) ‚Üí (a : N) ‚Üí Prop}\n  [self : CovariantClass M N Œº r], Covariant M N Œº r","name":"CovariantClass.elim","isProp":true,"docString":"For all `m ‚àà M` and all elements `n‚ÇÅ, n‚ÇÇ ‚àà N`, if the relation `r` holds for the pair\n`(n‚ÇÅ, n‚ÇÇ)`, then, the relation `r` also holds for the pair `(Œº m n‚ÇÅ, Œº m n‚ÇÇ)` "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±] {s : Set (Œ± √ó Œ±)} (hs : s ‚àà uniformity Œ±) (n : ‚Ñï),\n  Filter.Eventually (fun (t : Set (Œ± √ó Œ±)) ‚Ü¶ ((fun (x : Set (Œ± √ó Œ±)) (x_1 : Set (Œ± √ó Œ±)) ‚Ü¶ compRel x x_1) t^[n]) t ‚äÜ s)\n    (Filter.smallSets (uniformity Œ±))","name":"eventually_uniformity_iterate_comp_subset","isProp":true,"docString":"If `s ‚àà ùì§ Œ±`, then for any natural `n`, for a subset `t` of a sufficiently small set in `ùì§ Œ±`,\nwe have `t ‚óã t ‚óã ... ‚óã t ‚äÜ s` (`n` compositions). "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : CommSemiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) [inst_5 : DecidableEq Œπ] (c : (a : Œπ) ‚Üí R) (m : (i : Œπ) ‚Üí M‚ÇÅ i)\n  (s : Finset Œπ), ‚Üëf (Finset.piecewise s (fun (i : Œπ) ‚Ü¶ c i ‚Ä¢ m i) m) = (Finset.prod s fun (i : Œπ) ‚Ü¶ c i) ‚Ä¢ ‚Üëf m","name":"MultilinearMap.map_piecewise_smul","isProp":true,"docString":"If one multiplies by `c i` the coordinates in a finset `s`, then the image under a multilinear\nmap is multiplied by `‚àè i in s, c i`. This is mainly an auxiliary statement to prove the result when\n`s = univ`, given in `map_smul_univ`, although it can be useful in its own right as it does not\nrequire the index set `Œπ` to be finite. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : UniqueFactorizationMonoid Œ±]\n  [inst_2 : NormalizationMonoid Œ±] [inst_3 : DecidableEq Œ±] {n : Œ±},\n  Finsupp.support (factorization n) = Multiset.toFinset (UniqueFactorizationMonoid.normalizedFactors n)","name":"support_factorization","isProp":true,"docString":"The support of `factorization n` is exactly the Finset of normalized factors "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±),\n  A‚Åª¬π = Ring.inverse A","name":"Matrix.nonsing_inv_eq_ring_inverse","isProp":true,"docString":"The nonsingular inverse is the same as the general `Ring.inverse`. "},{"type":"‚àÄ {Œ± : Type u_1} (o : Part Œ±), { Dom := (Part.Dom o : Prop), get := fun (h : Part.Dom o) ‚Ü¶ Part.get o h } = o","name":"Part.eta","isProp":true,"docString":"`Part` eta expansion "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero M] [inst_1 : CommMonoid N] (f : Œ± ‚Üí‚ÇÄ M) (y : Œ±)\n  (g : (a : Œ±) ‚Üí (a : M) ‚Üí N) (hg : ‚àÄ (i : Œ±), g i 0 = 1),\n  g y (‚Üëf y) * Finsupp.prod (Finsupp.erase y f) g = Finsupp.prod f g","name":"Finsupp.mul_prod_erase'","isProp":true,"docString":"Generalization of `Finsupp.mul_prod_erase`: if `g` maps a second argument of 0 to 1,\nthen its product over `f : Œ± ‚Üí‚ÇÄ M` is the same as multiplying the value on any element\n`y : Œ±` by the product over `erase y f`. "},{"type":"‚àÄ {Œπ : Type u} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] [inst : (i : Œπ) ‚Üí AddCommMonoid (Œ≤ i)],\n  ‚ÜëDfinsupp.liftAddHom (Dfinsupp.singleAddHom Œ≤) = AddMonoidHom.id (Dfinsupp fun (i : Œπ) ‚Ü¶ Œ≤ i)","name":"Dfinsupp.liftAddHom_singleAddHom","isProp":true,"docString":"The `Dfinsupp` version of `Finsupp.liftAddHom_singleAddHom`,"},{"type":"‚àÄ {K : Type u} [self : Field K], 0‚Åª¬π = 0","name":"Field.inv_zero","isProp":true,"docString":"We define the inverse of `0` to be `0`. "},{"type":"‚àÄ {p : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (hab : Nat.coprime a b) (hpa : p ‚àà Nat.factors a),\n  ‚Üë(Nat.factorization (a * b)) p = ‚Üë(Nat.factorization a) p","name":"Nat.factorization_eq_of_coprime_left","isProp":true,"docString":"If `p` is a prime factor of `a` then the power of `p` in `a` is the same that in `a * b`,\nfor any `b` coprime to `a`. "},{"type":"‚àÄ {X : Type u} {Œ± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Œ±] [inst_2 : TopologicalSpace Œ±]\n  [inst_3 : OrderClosedTopology Œ±] [inst_4 : PreconnectedSpace X] {a : X} {b : X} {f : (a : X) ‚Üí Œ±} {g : (a : X) ‚Üí Œ±}\n  (hf : Continuous f) (hg : Continuous g) (ha : f a ‚â§ g a) (hb : g b ‚â§ f b), ‚àÉ (x : X), f x = g x","name":"intermediate_value_univ‚ÇÇ","isProp":true,"docString":"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ‚â§ g a` and `g b ‚â§ f b`, then for some `x` we have `f x = g x`. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (h : 0 < (1 - r) * (b - a)),\n  (f (‚Üë(AffineMap.lineMap a b) r) < ‚Üë(AffineMap.lineMap (f a) (f b)) r : Prop) ‚Üî\n    (slope f a b < slope f (‚Üë(AffineMap.lineMap a b) r) b : Prop)","name":"map_lt_lineMap_iff_slope_lt_slope_right","isProp":true,"docString":"Given `c = lineMap a b r`, `c < b`, the point `(c, f c)` is strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a b < slope f c b`. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P)\n  (i : Œπ), ‚Üë(Finset.weightedVSubOfPoint (Finset.erase s i) p (p i)) w = ‚Üë(Finset.weightedVSubOfPoint s p (p i)) w","name":"Finset.weightedVSubOfPoint_erase","isProp":true,"docString":"The weighted sum is unaffected by removing the base point, if\npresent, from the set of points. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {G : J ‚•§ C} [inst_2 : CategoryTheory.Limits.HasLimit F] (Œ± : F ‚âÖ G), CategoryTheory.Limits.HasLimit G","name":"CategoryTheory.Limits.hasLimitOfIso","isProp":true,"docString":"If a functor `F` has a limit, so does any naturally isomorphic functor.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (a_1 : a < b), a ‚â§ b","name":"LT.lt.le","isProp":true,"docString":"**Alias** of `le_of_lt`."},{"type":"‚àÄ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G]\n  [inst_3 : TopologicalSpace.FirstCountableTopology G],\n  ‚àÉ (u : (a : ‚Ñï) ‚Üí Set G), (Filter.HasAntitoneBasis (nhds 0) u : Prop) ‚àß (‚àÄ (n : ‚Ñï), u (n + 1) + u (n + 1) ‚äÜ u n : Prop)","name":"TopologicalAddGroup.exists_antitone_basis_nhds_zero","isProp":true,"docString":"Any first countable topological additive group has an antitone neighborhood basis\n`u : ‚Ñï ‚Üí set G` for which `u (n + 1) + u (n + 1) ‚äÜ u n`.\nThe existence of such a neighborhood basis is a key tool for `QuotientAddGroup.completeSpace`"},{"type":"‚àÄ {p : Prop} (a : ‚àÄ (a : ¬¨(p : Prop)), False), p","name":"by_contra","isProp":true,"docString":"**Alias** of `by_contradiction`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasStrongEpiMonoFactorisations C]\n  {X : C} {Y : C} (f : X ‚ü∂ Y), Nonempty (CategoryTheory.Limits.StrongEpiMonoFactorisation f)","name":"CategoryTheory.Limits.HasStrongEpiMonoFactorisations.has_fac","isProp":true,"docString":"A category has strong epi-mono factorisations if every morphism admits a strong epi-mono\nfactorisation. "},{"type":"‚àÄ {b : Prop} (a : Prop) (h : b), (a : Prop) ‚à® (b : Prop)","name":"Or.intro_right","isProp":true,"docString":"Alias for `Or.inr`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : Set Œ±} (h : IsChain r s), IsChain (flip r) s","name":"IsChain.symm","isProp":true,"docString":"This can be used to turn `IsChain (‚â•)` into `IsChain (‚â§)` and vice-versa. "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Monoid M]\n  [inst_1 : AddMonoid A] [inst_2 : AddMonoid B] [inst_3 : DistribMulAction M A] [inst_4 : DistribMulAction M B]\n  [self : DistribMulActionHomClass F M A B] (f : F), ‚Üëf 0 = 0","name":"DistribMulActionHomClass.map_zero","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Antitone f) {s : Set Œ±}\n  (a : BddBelow s), BddAbove (f '' s)","name":"Antitone.map_bddBelow","isProp":true,"docString":"The image under an antitone function of a set which is bounded below is bounded above. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {K : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category K] (F : J ‚•§ K)\n  {j‚ÇÅ : J} {j‚ÇÇ : J} (h : CategoryTheory.Zigzag j‚ÇÅ j‚ÇÇ),\n  CategoryTheory.Zigzag (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) j‚ÇÅ)\n    (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) j‚ÇÇ)","name":"CategoryTheory.zigzag_obj_of_zigzag","isProp":true,"docString":"If there is a zigzag from `j‚ÇÅ` to `j‚ÇÇ`, then there is a zigzag from `F j‚ÇÅ` to\n`F j‚ÇÇ` as long as `F` is a functor.\n"},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (a : R) (b : R), (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2","name":"sub_pow_two","isProp":true,"docString":"**Alias** of `sub_sq`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : CategoryTheory.Presieve X}\n  {x : CategoryTheory.Presieve.FamilyOfElements P R} (hx : CategoryTheory.Presieve.FamilyOfElements.Compatible x),\n  CategoryTheory.Presieve.FamilyOfElements.Compatible (CategoryTheory.Presieve.FamilyOfElements.sieveExtend x)","name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.sieveExtend","isProp":true,"docString":"The extension of a compatible family to the generated sieve is compatible. "},{"type":"‚àÄ {Œ≤ : Type u_2} {Œ≥ : Type u_1} [inst : DecidableEq Œ≥] {f : (a : Œ≥) ‚Üí (a : Œ≤) ‚Üí Œ≥} {b : Œ≤} (h : ‚àÄ (a : Œ≥), f a b = a)\n  (s : Finset Œ≥), Finset.image‚ÇÇ f s {b} = s","name":"Finset.image‚ÇÇ_right_identity","isProp":true,"docString":"If `b` is a right identity for `f : Œ± ‚Üí Œ≤ ‚Üí Œ±`, then `{b}` is a right identity for\n`Finset.image‚ÇÇ f`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  {X : C} {Y : C} (p : X = Y),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.eqToHom p) =\n    CategoryTheory.eqToHom\n      ((congr_arg (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F))\n            p=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X =\n            Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F)\n              Y)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X =\n          Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) Y)","name":"CategoryTheory.eqToHom_map","isProp":true,"docString":"This is not always a good idea as a `@[simp]` lemma,\nas we lose the ability to use results that interact with `F`,\ne.g. the naturality of a natural transformation.\n\nIn some files it may be appropriate to use `local attribute [simp] eqToHom_map`, however.\n"},{"type":"‚àÄ {Œ± : Type u} [self : SemilatticeInf Œ±] (a : Œ±) (b : Œ±), a ‚äì b ‚â§ b","name":"SemilatticeInf.inf_le_right","isProp":true,"docString":"The infimum is a lower bound on the second argument "},{"type":"‚àÄ {V : Type u} [inst : Quiver V] {a : V} {b : V} (p : Quiver.Path a b) {c : V} (q : Quiver.Path b c),\n  Quiver.Path.toList (Quiver.Path.comp p q) = Quiver.Path.toList q ++ Quiver.Path.toList p","name":"Quiver.Path.toList_comp","isProp":true,"docString":"`Quiver.Path.toList` is a contravariant functor. The inversion comes from `Quiver.Path` and\n`List` having different preferred directions for adding elements. "},{"type":"‚àÄ {Œ± : Type u} [inst : RightCancelMonoid Œ±], FaithfulSMul Œ± Œ±","name":"RightCancelMonoid.faithfulSMul","isProp":true,"docString":"`Monoid.toMulAction` is faithful on cancellative monoids. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : TopologicalSpace R] [inst_1 : DivisionRing R] [inst_2 : ContinuousSub R]\n  [inst_3 : AddCommGroup M] [inst_4 : TopologicalSpace M] [inst_5 : ContinuousAdd M] [inst_6 : Module R M]\n  [inst_7 : ContinuousSMul R M] (f : M ‚ÜíL[R] R) (hf : f ‚â† 0), IsOpenMap ‚Üëf","name":"ContinuousLinearMap.isOpenMap_of_ne_zero","isProp":true,"docString":"A nonzero continuous linear functional is open. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : Set Œ±} [inst : IsRefl Œ± r] (a : Set.Pairwise s r) ‚¶Éa : Œ±‚¶Ñ\n  (a_1 : a ‚àà s) ‚¶Éb : Œ±‚¶Ñ (a_2 : b ‚àà s), r a b","name":"Set.Pairwise.of_refl","isProp":true,"docString":"**Alias** of the forward direction of `Set.pairwise_iff_of_refl`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : BoundedOrder Œ±] {x : Œ±} {y : Œ±} (self : IsCompl x y), Codisjoint x y","name":"IsCompl.codisjoint","isProp":true,"docString":"If `x` and `y` are to be complementary in an order, they should be codisjoint. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x : X} {y : X} (Œ≥ : Path x y), Continuous (Path.extend Œ≥)","name":"Path.continuous_extend","isProp":true,"docString":"A useful special case of `Continuous.path_extend`. "},{"type":"‚àÄ (a : Cardinal), Cardinal.lift a = a","name":"Cardinal.lift_id'","isProp":true,"docString":"A cardinal lifted to a lower or equal universe equals itself. "},{"type":"‚àÄ {q : ‚Ñö} (a : q ‚â§ 0), Rat.toNNRat q = 0","name":"Rat.toNNRat_of_nonpos","isProp":true,"docString":"**Alias** of the reverse direction of `Rat.toNNRat_eq_zero`."},{"type":"‚àÄ {p : ‚Ñï} (q : ‚Ñö), padicValRat p (-q) = padicValRat p q","name":"padicValRat.neg","isProp":true,"docString":"`padicValRat p q` is symmetric in `q`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {u : Set Œ±},\n  EMetric.hausdorffEdist s u ‚â§ EMetric.hausdorffEdist s t + EMetric.hausdorffEdist t u","name":"EMetric.hausdorffEdist_triangle","isProp":true,"docString":"The Hausdorff distance satisfies the triangular inequality "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R], (IsRightRegular 0 : Prop) ‚Üî (Subsingleton R : Prop)","name":"isRightRegular_zero_iff_subsingleton","isProp":true,"docString":"The element `0` is right-regular if and only if `R` is trivial. "},{"type":"‚àÄ {M : Type u} [self : AddMonoid M] (a : M), a + 0 = a","name":"AddMonoid.add_zero","isProp":true,"docString":"Zero is a right neutral element for addition "},{"type":"‚àÄ {œÉ : Type w‚ÇÇ} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : (a : Œ±) ‚Üí (a : œÉ) ‚Üí œÉ √ó Œ≤) (x : List Œ±) (s : œÉ),\n  List.length (Prod.snd (List.mapAccumr f x s)) = List.length x","name":"List.length_mapAccumr","isProp":true,"docString":"Length of the list obtained by `mapAccumr`. "},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] {s : Set R} {p : (a : R) ‚Üí Prop} {x : R}\n  (h : x ‚àà NonUnitalSubsemiring.closure s) (Hs : ‚àÄ (x : R) (a : x ‚àà s), p x) (H0 : p 0)\n  (Hadd : ‚àÄ (x : R) (y : R) (a : p x) (a : p y), p (x + y)) (Hmul : ‚àÄ (x : R) (y : R) (a : p x) (a : p y), p (x * y)),\n  p x","name":"NonUnitalSubsemiring.closure_induction","isProp":true,"docString":"An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition and multiplication, then `p` holds for all elements\nof the closure of `s`. "},{"type":"‚àÄ {K : Type u} [self : DivisionRing K] (a : K) (b : K), a / b = a * b‚Åª¬π","name":"DivisionRing.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u_1} (s : Set Œ±) (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) (a : Set.Pairwise s r),\n  Pairwise fun (x : ‚Üës) (y : ‚Üës) ‚Ü¶ r ‚Üëx ‚Üëy","name":"Set.Pairwise.subtype","isProp":true,"docString":"**Alias** of the reverse direction of `pairwise_subtype_iff_pairwise_set`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {s : Set Œ≤} (hs : Set.Nontrivial s) {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Surjective f),\n  Set.Nontrivial (f ‚Åª¬π' s)","name":"Set.Nontrivial.preimage","isProp":true,"docString":"The preimage of a nontrivial set under a surjective map is nontrivial. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictMonoOn f s) (hg : StrictMonoOn g s), StrictMonoOn (fun (x : Œ≤) ‚Ü¶ f x + g x) s","name":"StrictMonoOn.add","isProp":true,"docString":"The sum of two strictly monotone functions is strictly monotone."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±], Filter.Tendsto abs Filter.atTop Filter.atTop","name":"Filter.tendsto_abs_atTop_atTop","isProp":true,"docString":"$\\lim_{x\\to+\\infty}|x|=+\\infty$ "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [self : CommGroupWithZero G‚ÇÄ] (a : G‚ÇÄ) (b : G‚ÇÄ), a / b = a * b‚Åª¬π","name":"CommGroupWithZero.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {g : Equiv.Perm (Fin 5)} (ha : g ‚àà alternatingGroup (Fin 5)) (h1 : g ‚â† 1)\n  (h2 : ‚àÄ (n : ‚Ñï) (a : n ‚àà Equiv.Perm.cycleType g), n = 2), IsConj (Equiv.swap 0 4 * Equiv.swap 1 3) g","name":"alternatingGroup.isConj_swap_mul_swap_of_cycleType_two","isProp":true,"docString":"Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps\nis conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation\nin $A_5$ is $A_5$. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, (Set.Nonempty ‚Üë(affineSpan k s) : Prop) ‚Üî (Set.Nonempty s : Prop)","name":"affineSpan_nonempty","isProp":true,"docString":"The affine span of a set is nonempty if and only if that set is. "},{"type":"‚àÄ {P : (a : ‚Ñ§) ‚Üí Prop} {m : ‚Ñ§} (h0 : P m) (h1 : ‚àÄ (n : ‚Ñ§) (a : m ‚â§ n) (a : P n), P (n + 1)) (n : ‚Ñ§) (a : m ‚â§ n), P n","name":"Int.le_induction","isProp":true,"docString":"See `Int.inductionOn'` for an induction in both directions. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {t : CategoryTheory.Limits.Cocone F} (h : CategoryTheory.Limits.IsColimit t) {W : C}\n  {f : CategoryTheory.Limits.Cocone.pt t ‚ü∂ W} {f' : CategoryTheory.Limits.Cocone.pt t ‚ü∂ W}\n  (w : ‚àÄ (j : J), (CategoryTheory.Limits.Cocone.Œπ t).app j ‚â´ f = (CategoryTheory.Limits.Cocone.Œπ t).app j ‚â´ f'), f = f'","name":"CategoryTheory.Limits.IsColimit.hom_ext","isProp":true,"docString":"Two morphisms out of a colimit are equal if their compositions with\neach cocone morphism are equal. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : CommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsMulHom f),\n  IsMulHom fun (a : Œ±) ‚Ü¶ (f a)‚Åª¬π","name":"IsMulHom.inv","isProp":true,"docString":"The inverse of a map which preserves multiplication,\npreserves multiplication when the target is commutative. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R], (¬¨(IsLeftRegular 0 : Prop) : Prop) ‚Üî (Nontrivial R : Prop)","name":"not_isLeftRegular_zero_iff","isProp":true,"docString":"In a non-trivial `MulZeroClass`, the `0` element is not left-regular. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : b ‚â§ a‚Åª¬π * c), a * b ‚â§ c","name":"mul_le_of_le_inv_mul","isProp":true,"docString":"**Alias** of the forward direction of `le_inv_mul_iff_mul_le`."},{"type":"‚àÄ {Œ± : Type u_1} (self : Ultrafilter Œ±) (g : Filter Œ±) (a : Filter.NeBot g) (a : g ‚â§ ‚Üëself), ‚Üëself ‚â§ g","name":"Ultrafilter.le_of_le","isProp":true,"docString":"If `g` is a nontrivial filter that is less than or equal to an ultrafilter, then it is greater\nthan or equal to the ultrafilter. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} [inst : DecidableEq Œ±']\n  [inst_1 : DecidableEq Œ≥] [inst_2 : DecidableEq Œ¥] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), f (g a) b = g' (f' b a)),\n  Finset.image‚ÇÇ f (Finset.image g s) t = Finset.image g' (Finset.image‚ÇÇ f' t s)","name":"Finset.image‚ÇÇ_image_left_anticomm","isProp":true,"docString":"Symmetric statement to `Finset.image_image‚ÇÇ_antidistrib_left`. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] [inst_1 : AddMonoid M] {S : Set (AddMonoidAlgebra R M)}\n  (hS : Algebra.adjoin R S = ‚ä§),\n  Algebra.adjoin R\n      (AddMonoidAlgebra.of' R M ''\n        Set.union·µ¢ fun (f : AddMonoidAlgebra R M) ‚Ü¶ Set.union·µ¢ fun (h : f ‚àà S) ‚Ü¶ ‚Üë(Finsupp.support f)) =\n    ‚ä§","name":"AddMonoidAlgebra.support_gen_of_gen'","isProp":true,"docString":"If a set `S` generates, as algebra, `AddMonoidAlgebra R M`, then the image of the union of\nthe supports of elements of `S` generates `AddMonoidAlgebra R M`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atTop),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atBot : Prop) ‚Üî (r < 0 : Prop)","name":"Filter.tendsto_mul_const_atBot_iff_neg","isProp":true,"docString":"If `f` tends to infinity along a nontrivial filter `l`, then `Œª x, f x * r` tends to negative\ninfinity if and only if `r < 0. `"},{"type":"‚àÄ {R : Type u} {S : Type v} {A : Type w} [inst : CommSemiring R] [inst_1 : CommSemiring S] [inst_2 : Semiring A]\n  [inst_3 : Algebra R S] [inst_4 : Algebra S A] [inst_5 : Algebra R A]\n  (h : algebraMap R A = RingHom.comp (algebraMap S A) (algebraMap R S)), IsScalarTower R S A","name":"IsScalarTower.of_algebraMap_eq'","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : DivisionRing ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : CharZero ùïú] [inst_3 : Algebra ‚Ñù ùïú]\n  [inst_4 : ContinuousSMul ‚Ñù ùïú] [inst_5 : TopologicalDivisionRing ùïú] (x : ùïú),\n  Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ ‚Üën / (‚Üën + x)) Filter.atTop (nhds 1)","name":"tendsto_coe_nat_div_add_atTop","isProp":true,"docString":"The limit of `n / (n + x)` is 1, for any constant `x` (valid in `‚Ñù` or any topological division\nalgebra over `‚Ñù`, e.g., `‚ÑÇ`).\n\nTODO: introduce a typeclass saying that `1 / n` tends to 0 at top, making it possible to get this\nstatement simultaneously on `‚Ñö`, `‚Ñù` and `‚ÑÇ`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\n  [self : OrderedSMul R M] {a : M} {b : M} {c : R} (a_1 : c ‚Ä¢ a < c ‚Ä¢ b) (a_2 : 0 < c), a < b","name":"OrderedSMul.lt_of_smul_lt_smul_of_pos","isProp":true,"docString":"If `c ‚Ä¢ a < c ‚Ä¢ b` for some positive `c`, then `a < b`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedSemifield Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r)\n  (hf : Filter.Tendsto f l Filter.atTop), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atTop","name":"Filter.Tendsto.const_mul_atTop","isProp":true,"docString":"If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the left) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use\n`filter.tendsto.const_mul_atTop'` instead. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±} {t : Set Œ±} (h : s ‚äÜ t),\n  EMetric.infEdist x t ‚â§ EMetric.infEdist x s","name":"EMetric.infEdist_anti","isProp":true,"docString":"The edist is antitone with respect to inclusion. "},{"type":"‚àÄ {n : ‚Ñï} {a : ‚Ñï} (ha : Even a), (Even (n % a) : Prop) ‚Üî (Even n : Prop)","name":"Even.mod_even_iff","isProp":true,"docString":"If `a` is even, then `n` is even iff `n % a` is even. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : NonUnitalNonAssocSemiring Œ±] [inst_3 : NonUnitalNonAssocSemiring Œ≤] [inst_4 : TopologicalSemiring Œ±]\n  [inst_5 : TopologicalSemiring Œ≤], TopologicalSemiring (Œ± √ó Œ≤)","name":"instTopologicalSemiringProdInstTopologicalSpaceProdInstNonUnitalNonAssocSemiringProd","isProp":true,"docString":"The product topology on the cartesian product of two topological semirings\nmakes the product into a topological semiring. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M} {a : M} (hs : IsSubmonoid s) (h : a ‚àà s), powers a ‚äÜ s","name":"IsSubmonoid.power_subset","isProp":true,"docString":"The set of natural number powers of an element of a submonoid is a subset of the submonoid. "},{"type":"‚àÄ {Œ± : Type u_1} (f : (a : Œ±) ‚Üí NNReal),\n  Filter.Tendsto (fun (s : Finset Œ±) ‚Ü¶ tsum fun (b : { x : Œ± // ¬¨(x ‚àà s : Prop) }) ‚Ü¶ f ‚Üëb) Filter.atTop (nhds 0)","name":"NNReal.tendsto_tsum_compl_atTop_zero","isProp":true,"docString":"The sum over the complement of a finset tends to `0` when the finset grows to cover the whole\nspace. This does not need a summability assumption, as otherwise all sums are zero. "},{"type":"‚àÄ {R : Type u} [self : AddCommGroupWithOne R] (n : ‚Ñï), IntCast.intCast ‚Üën = ‚Üën","name":"AddCommGroupWithOne.intCast_ofNat","isProp":true,"docString":"The canonical homorphism `‚Ñ§ ‚Üí R` agrees with the one from `‚Ñï ‚Üí R` on `‚Ñï`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : PseudoEMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  {s : (a : Œ≤) ‚Üí Œ±},\n  (CauchySeq s : Prop) ‚Üî\n    (‚àÉ (b : (a : Œ≤) ‚Üí ENNReal),\n        (‚àÄ (n : Œ≤) (m : Œ≤) (N : Œ≤) (a : N ‚â§ n) (a : N ‚â§ m), edist (s n) (s m) ‚â§ b N : Prop) ‚àß\n          (Filter.Tendsto b Filter.atTop (nhds 0) : Prop) :\n      Prop)","name":"EMetric.cauchySeq_iff_le_tendsto_0","isProp":true,"docString":"Yet another metric characterization of Cauchy sequences on integers. This one is often the\nmost efficient. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±}, (sbtw a b c : Prop) ‚Üî (sbtw c a b : Prop)","name":"sbtw_cyclic","isProp":true,"docString":"The order of the `‚Üî` has been chosen so that `rw sbtw_cyclic` cycles to the right while\n`rw ‚Üêsbtw_cyclic` cycles to the left (thus following the prepended arrow). "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {s : Set Œ±} {t : Set Œ≤}\n  (a :\n    LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à©\n        ‚Üë(LocalHomeomorph.symm e) ‚Åª¬π' (LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© s) =\n      LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à© t),\n  LocalHomeomorph.IsImage e s t","name":"LocalHomeomorph.IsImage.of_symm_preimage_eq'","isProp":true,"docString":"**Alias** of the reverse direction of `LocalHomeomorph.IsImage.iff_symm_preimage_eq'`."},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} (v : Vector Œ± (Nat.succ n)), Vector.head v ::·µ• Vector.tail v = v","name":"Vector.cons_head_tail","isProp":true,"docString":"Prepending the head of a vector to its tail gives the vector. "},{"type":"‚àÄ {Œì : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : VAdd Œì T] [self : ProperlyDiscontinuousVAdd Œì T]\n  {K : Set T} {L : Set T} (a : IsCompact K) (a : IsCompact L),\n  Set.Finite (setOf fun (Œ≥ : Œì) ‚Ü¶ (fun (x : T) ‚Ü¶ Œ≥ +·µ• x) '' K ‚à© L ‚â† ‚àÖ)","name":"ProperlyDiscontinuousVAdd.finite_disjoint_inter_image","isProp":true,"docString":"Given two compact sets `K` and `L`, `Œ≥ +·µ• K ‚à© L` is nonempty for finitely many `Œ≥`. "},{"type":"‚àÄ {Œ± : Type u_2} {E : Type u_3} {ùïú : Type u_1} [inst : Norm E] [inst_1 : NormedField ùïú] {f : (a : Œ±) ‚Üí E} {l : Filter Œ±}\n  {c : ùïú} {g : (a : Œ±) ‚Üí ùïú} (hc : c ‚â† 0) (a : f =Œò[l] fun (x : Œ±) ‚Ü¶ c * g x), f =Œò[l] g","name":"Asymptotics.IsTheta.of_const_mul_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isTheta_const_mul_right`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : TopologicalSpace ùïú] [inst_1 : CommSemiring ùïú]\n  [inst_2 : AddCommMonoid E] [inst_3 : Module ùïú E] [inst_4 : AddCommMonoid F] [inst_5 : Module ùïú F]\n  (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú) [inst_6 : ContinuousSMul ùïú ùïú], ContinuousSMul ùïú (WeakBilin B)","name":"WeakBilin.instContinuousSMul","isProp":true,"docString":"Scalar multiplication by `ùïú` on `WeakBilin B` is continuous. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±}\n  {b : Œ±} {c : Œ±} [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1],\n  a + b - (a + c) ‚â§ b - c","name":"add_tsub_add_le_tsub_left","isProp":true,"docString":"See `add_tsub_add_eq_tsub_left` for the equality. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [inst : CommSemiring k] [inst_1 : Monoid G] {A : Type u‚ÇÉ} [inst_2 : Semiring A]\n  [inst_3 : Algebra k A] (F : MonoidAlgebra k G ‚Üí‚Çê[k] A) (f : MonoidAlgebra k G),\n  ‚ÜëF f = Finsupp.sum f fun (a : G) (b : k) ‚Ü¶ b ‚Ä¢ ‚ÜëF (MonoidAlgebra.single a 1)","name":"MonoidAlgebra.lift_unique","isProp":true,"docString":"Decomposition of a `k`-algebra homomorphism from `MonoidAlgebra k G` by\nits values on `F (single a 1)`. "},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí VAdd M (Œ± i)] (i : Œπ)\n  [inst_1 : FaithfulVAdd M (Œ± i)], FaithfulVAdd M ((i : Œπ) √ó Œ± i)","name":"Sigma.FaithfulVAdd'","isProp":true,"docString":"This is not an instance because `i` becomes a metavariable."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] (g : Œ±) (x : Œ≤),\n  MulAction.stabilizer Œ± (g ‚Ä¢ x) = Subgroup.map (MulEquiv.toMonoidHom (‚ÜëMulAut.conj g)) (MulAction.stabilizer Œ± x)","name":"MulAction.stabilizer_smul_eq_stabilizer_map_conj","isProp":true,"docString":"If the stabilizer of `x` is `S`, then the stabilizer of `g ‚Ä¢ x` is `gSg‚Åª¬π`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (e : M ‚âÉ* N) (y : N), ‚Üëe (‚Üë(MulEquiv.symm e) y) = y","name":"MulEquiv.apply_symm_apply","isProp":true,"docString":"`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : CommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsGroupHom f),\n  IsGroupHom fun (a : Œ±) ‚Ü¶ (f a)‚Åª¬π","name":"IsGroupHom.inv","isProp":true,"docString":"The inverse of a group homomorphism is a group homomorphism if the target is commutative. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú} (hs : Convex ùïú s)\n  (hf :\n    ‚àÄ {x : ùïú} {y : ùïú} {z : ùïú} (a : x ‚àà s) (a : z ‚àà s) (a : x < y) (a : y < z),\n      (f z - f y) / (z - y) < (f y - f x) / (y - x)),\n  StrictConcaveOn ùïú s f","name":"strictConcaveOn_of_slope_strict_anti_adjacent","isProp":true,"docString":"If for any three points `x < y < z`, the slope of the secant line of `f : ùïú ‚Üí ùïú` on `[x, y]` is\nstrictly greater than the slope of the secant line of `f` on `[x, z]`, then `f` is strictly concave.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {x : Œ±} {y : Œ±} (h : Commute x y) (n : ‚Ñï),\n  (Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n","name":"Commute.geom_sum‚ÇÇ_mul_add","isProp":true,"docString":"$x^n-y^n = (x-y) \\sum x^ky^{n-1-k}$ reformulated without `-` signs. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (a : Œ±),\n  max a 0 - max (-a) 0 = a","name":"max_zero_sub_eq_self","isProp":true,"docString":"**Alias** of `max_zero_sub_max_neg_zero_eq_self`."},{"type":"‚àÄ {Œ≥ : Type w} [inst : EMetricSpace Œ≥] {x : Œ≥} {y : Œ≥} (h : ‚àÄ (Œµ : ENNReal) (a : Œµ > 0), edist x y ‚â§ Œµ), x = y","name":"eq_of_forall_edist_le","isProp":true,"docString":"Two points coincide if their distance is `< Œµ` for all positive Œµ "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (P : (a : Finset Œ±) ‚Üí (a : Finset Œ±) ‚Üí Prop)\n  (symm : ‚àÄ {a : Finset Œ±} {b : Finset Œ±} (a_1 : P a b), P b a) (empty_right : ‚àÄ {a : Finset Œ±}, P a ‚àÖ)\n  (singletons : ‚àÄ {a : Œ±} {b : Œ±}, P {a} {b})\n  (union_of : ‚àÄ {a : Finset Œ±} {b : Finset Œ±} {c : Finset Œ±} (a_1 : P a c) (a_2 : P b c), P (a ‚à™ b) c) (a : Finset Œ±)\n  (b : Finset Œ±), P a b","name":"Finset.induction_on_union","isProp":true,"docString":"To prove a relation on pairs of `Finset X`, it suffices to show that it is\n* symmetric,\n* it holds when one of the `Finset`s is empty,\n* it holds for pairs of singletons,\n* if it holds for `[a, c]` and for `[b, c]`, then it holds for `[a ‚à™ b, c]`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : PredOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : PredOrder.pred a < b), a ‚â§ b","name":"PredOrder.le_of_pred_lt","isProp":true,"docString":"Proof that `pred` satifies ordering invariants betweeen `LE` and `LT`"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {p : Filter Œπ}\n  {p' : Filter Œ±} {Œ≥ : Type u_1} (hf : UniformCauchySeqOnFilter F p p') (g : (a : Œ≥) ‚Üí Œ±),\n  UniformCauchySeqOnFilter (fun (n : Œπ) ‚Ü¶ F n ‚àò g) p (Filter.comap g p')","name":"UniformCauchySeqOnFilter.comp","isProp":true,"docString":"Composing on the right by a function preserves uniform Cauchy sequences "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} [self : Fin2.IsLT m n], m < n","name":"Fin2.IsLT.h","isProp":true,"docString":"The unique field of `Fin2.IsLT`, a proof that `m < n`. "},{"type":"‚àÄ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] (hR : ringChar R ‚â† 2)\n  {a : R}, (-a = a : Prop) ‚Üî (a = 0 : Prop)","name":"Ring.eq_self_iff_eq_zero_of_char_ne_two","isProp":true,"docString":"Characteristic `‚â† 2` in a domain implies that `-a = a` iff `a = 0`. "},{"type":"‚àÄ {ùïú : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {C : ùïú} (hC : 0 < C) (hf : Filter.Tendsto f l (nhds C))\n  (hg : Filter.Tendsto g l Filter.atTop), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * g x) l Filter.atTop","name":"Filter.Tendsto.mul_atTop","isProp":true,"docString":"In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and\n`g` tends to `Filter.atTop` then `f * g` tends to `Filter.atTop`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {b : Set (Set Œ±)} (hb : TopologicalSpace.IsTopologicalBasis b) {s : Set Œ±}\n  {a : Œ±}, (a ‚àà closure s : Prop) ‚Üî (‚àÄ (o : Set Œ±) (a_1 : o ‚àà b) (a : a ‚àà o), Set.Nonempty (o ‚à© s) : Prop)","name":"TopologicalSpace.IsTopologicalBasis.mem_closure_iff","isProp":true,"docString":"A point `a` is in the closure of `s` iff all basis sets containing `a` intersect `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : NonUnitalNonAssocRing Œ±] [inst_2 : TopologicalRing Œ±] (x : Œ±),\n  Continuous ‚Üë(AddMonoidHom.mulLeft x)","name":"mulLeft_continuous","isProp":true,"docString":"In a topological semiring, the left-multiplication `AddMonoidHom` is continuous. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Ü™ Œ≤) (h : ‚àÄ (a : Nat.card Œ≤ = 0), Nat.card Œ± = 0), Nat.card Œ± ‚â§ Nat.card Œ≤","name":"Finite.card_le_of_embedding'","isProp":true,"docString":"If `f` is an embedding, then `Nat.card Œ± ‚â§ Nat.card Œ≤`. We must also assume\n`Nat.card Œ≤ = 0 ‚Üí Nat.card Œ± = 0` since `Nat.card` is defined to be `0` for infinite types. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : StarAddMonoid E] [inst_2 : NormedStarGroup E],\n  Isometry star","name":"star_isometry","isProp":true,"docString":"The `star` map in a normed star group is an isometry "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type v} {m : Multiset ((a : Œ±) √ó Œ≤ a)} (a : Multiset.NodupKeys m),\n  Multiset.Nodup (Multiset.keys m)","name":"Multiset.NodupKeys.nodup_keys","isProp":true,"docString":"**Alias** of the reverse direction of `Multiset.nodup_keys`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : NormalizationMonoid Œ±], normUnit 0 = 1","name":"NormalizationMonoid.normUnit_zero","isProp":true,"docString":"The proposition that `normUnit` maps `0` to the identity. "},{"type":"‚àÄ {X : Type u_2} [inst : TopologicalSpace X] {œÄ : (a : X) ‚Üí Sort u_1} {f : (a : ‚Ñï) ‚Üí (x : X) ‚Üí œÄ x}\n  (hf : LocallyFinite fun (n : ‚Ñï) ‚Ü¶ setOf fun (x : X) ‚Ü¶ f (n + 1) x ‚â† f n x),\n  ‚àÉ (F : (x : X) ‚Üí œÄ x),\n    ‚àÄ (x : X),\n      Filter.Eventually (fun (p : ‚Ñï √ó X) ‚Ü¶ f (Prod.fst p) (Prod.snd p) = F (Prod.snd p))\n        (Filter.prod Filter.atTop (nhds x))","name":"LocallyFinite.exists_forall_eventually_eq_prod","isProp":true,"docString":"Let `f : ‚Ñï ‚Üí Œ† a, Œ≤ a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x ‚â† f n x}` is locally finite. Then there exists a\nfunction `F : Œ† a, Œ≤ a` such that for any `x`, we have `f n x = F x` on the product of an infinite\ninterval `[N, +‚àû)` and a neighbourhood of `x`.\n\nWe formulate the conclusion in terms of the product of filter `Filter.atTop` and `ùìù x`. "},{"type":"‚àÄ {œÑ : Type u_2} [inst : AddMonoid œÑ] [inst_1 : TopologicalSpace œÑ] [inst_2 : ContinuousAdd œÑ] {Œ± : Type u_3}\n  [inst_3 : TopologicalSpace Œ±] (œï : Flow œÑ Œ±) {Œ≤ : Type u_1} [inst_4 : TopologicalSpace Œ≤] {t : (a : Œ≤) ‚Üí œÑ}\n  (ht : Continuous t) {f : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f), Continuous fun (x : Œ≤) ‚Ü¶ Flow.toFun œï (t x) (f x)","name":"Continuous.flow","isProp":true,"docString":"**Alias** of `Flow.continuous`."},{"type":"‚àÄ {p : Prop} [inst : Decidable (p : Prop)], (¬¨(¬¨(p : Prop) : Prop) : Prop) ‚Üî (p : Prop)","name":"Decidable.not_not_iff","isProp":true,"docString":"**Alias** of `Decidable.not_not`."},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : Nonempty Œ±] (s : Finset Œ±), BddAbove ‚Üës","name":"Finset.bddAbove","isProp":true,"docString":"A finset is bounded above. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_4} {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : VAdd M Œ±] [inst_1 : VAdd M Œ≤] [inst_2 : VAdd Œ± Œ≤]\n  [inst_3 : VAddAssocClass M Œ± Œ≤] (g : (a : N) ‚Üí M), VAddAssocClass N Œ± Œ≤","name":"VAdd.comp.isScalarTower","isProp":true,"docString":"Given a tower of additive actions `M ‚Üí Œ± ‚Üí Œ≤`, if we use `SMul.comp` to pull back both of\n`M`'s actions by a map `g : N ‚Üí M`, then we obtain a new tower of scalar actions `N ‚Üí Œ± ‚Üí Œ≤`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables."},{"type":"‚àÄ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], ‚Üë(FiniteDimensional.finrank K V) = Module.rank K V","name":"FiniteDimensional.finrank_eq_rank'","isProp":true,"docString":"In a finite-dimensional space, its dimension (seen as a cardinal) coincides with its\n`finrank`. This is a copy of `finrank_eq_rank _ _` which creates easier typeclass searches. "},{"type":"‚àÄ {Œ± : Type u_1} [self : Nontrivial Œ±], ‚àÉ (x : Œ±), ‚àÉ (y : Œ±), x ‚â† y","name":"Nontrivial.exists_pair_ne","isProp":true,"docString":"In a nontrivial type, there exists a pair of distinct terms. "},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : Type u_1} {A : (a : Œπ) ‚Üí Type u_3} [inst : AddMonoid Œπ] [inst_1 : GradedMonoid.GMonoid A]\n  (l : List Œ±) (f : (a : Œ±) ‚Üí GradedMonoid A),\n  List.prod (List.map f l) =\n    GradedMonoid.mk (List.dProdIndex l fun (i : Œ±) ‚Ü¶ Sigma.fst (f i))\n      (List.dProd l (fun (i : Œ±) ‚Ü¶ Sigma.fst (f i)) fun (i : Œ±) ‚Ü¶ Sigma.snd (f i))","name":"GradedMonoid.list_prod_map_eq_dProd","isProp":true,"docString":"A variant of `GradedMonoid.mk_list_dProd` for rewriting in the other direction. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {f : (a : ‚Ñ§) ‚Üí Œ±} (hf : Antitone f) (n : ‚Ñ§) {x : Œ±} (h1 : f (n + 1) < x)\n  (h2 : x < f n) (a : ‚Ñ§), f a ‚â† x","name":"Antitone.ne_of_lt_of_lt_int","isProp":true,"docString":"If `f` is an antitone function from `‚Ñ§` to a preorder and `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. "},{"type":"‚àÄ {n : ‚Ñï} (P : MvPFunctor (n + 1)) {Œ± : TypeVec n} {C : (a : MvPFunctor.W P Œ±) ‚Üí Prop}\n  (ih :\n    ‚àÄ (a : MvPFunctor.A P) (f' : TypeVec.Arrow (MvPFunctor.B (MvPFunctor.drop P) a) Œ±)\n      (f : (a : PFunctor.B (MvPFunctor.last P) a) ‚Üí MvPFunctor.W P Œ±)\n      (a_1 : ‚àÄ (i : PFunctor.B (MvPFunctor.last P) a), C (f i)), C (MvPFunctor.wMk P a f' f))\n  (x : MvPFunctor.W P Œ±), C x","name":"MvPFunctor.w_ind","isProp":true,"docString":"Induction principle for `W` "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {c : ‚Ñù} {f : (a : Œ±) ‚Üí E}\n  {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} (a : Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) l),\n  Asymptotics.IsBigOWith c l f g","name":"Asymptotics.IsBigOWith.of_bound","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigOWith_iff`."},{"type":"Cardinal.mk ‚ÜëSet.univ = Cardinal.continuum","name":"Cardinal.mk_univ_real","isProp":true,"docString":"The cardinality of the reals, as a set. "},{"type":"‚àÄ {a : ENNReal} (h : a < ‚ä§), AddLECancellable a","name":"ENNReal.cancel_of_lt","isProp":true,"docString":"This lemma has an abbreviated name because it is used frequently. "},{"type":"‚àÄ {Œ≤ : Type u_1} {f : (a : Œ≤) ‚Üí NNReal} {g : (a : Œ≤) ‚Üí NNReal} (hgf : ‚àÄ (b : Œ≤), g b ‚â§ f b) (a : Summable f), Summable g","name":"NNReal.summable_of_le","isProp":true,"docString":"Comparison test of convergence of `‚Ñù‚â•0`-valued series. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (self : Œ± ‚âÉ. Œ≤) (a : Œ±) (b : Œ≤),\n  (a ‚àà PEquiv.invFun self b : Prop) ‚Üî (b ‚àà PEquiv.toFun self a : Prop)","name":"PEquiv.inv","isProp":true,"docString":"`invFun` is the partial inverse of `toFun`  "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedMonoid Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"CanonicallyLinearOrderedMonoid.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : SuccOrder Œ±] {a : Œ±} {b : Œ±} [inst_2 : NoMaxOrder Œ±] (a_1 : a ‚â† b),\n  Order.succ a ‚â† Order.succ b","name":"Order.succ_ne_succ","isProp":true,"docString":"**Alias** of the reverse direction of `Order.succ_ne_succ_iff`."},{"type":"‚àÄ {Œ± : Type u} (self : UniformSpace.Core Œ±),\n  (Filter.lift' (UniformSpace.Core.uniformity self) fun (s : Set (Œ± √ó Œ±)) ‚Ü¶ compRel s s) ‚â§\n    UniformSpace.Core.uniformity self","name":"UniformSpace.Core.comp","isProp":true,"docString":"For every set `u ‚àà uniformity`, there exists `v ‚àà uniformity` such that `v ‚óã v ‚äÜ u`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (hf : Antitone f) (hg : StrictAnti g), StrictAnti fun (x : Œ≤) ‚Ü¶ f x + g x","name":"Antitone.add_strictAnti","isProp":true,"docString":"The sum of a antitone function and a strictly antitone function is\nstrictly antitone."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (a_1 : IsAtom a), ‚ä• ‚ãñ a","name":"IsAtom.bot_covby","isProp":true,"docString":"**Alias** of the reverse direction of `bot_covby_iff`."},{"type":"‚àÄ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K ‚Üí+* L) {f : Polynomial K}\n  (hf : Polynomial.Splits i f) (hfd : Polynomial.degree (Polynomial.map i f) ‚â† 0),\n  Polynomial.rootOfSplits' i hf hfd =\n    Polynomial.rootOfSplits i hf\n      ((Eq.rec hfd\n            ((Polynomial.degree_map f\n                  i=:Polynomial.degree (Polynomial.map i f) =\n                  Polynomial.degree\n                    f)=:Polynomial.degree (Polynomial.map i f) =\n                Polynomial.degree f)=:Polynomial.degree f ‚â† 0)=:Polynomial.degree f ‚â† 0)","name":"Polynomial.rootOfSplits'_eq_rootOfSplits","isProp":true,"docString":"`rootOfSplits'` is definitionally equal to `rootOfSplits`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] [inst_1 : CommRing R] [inst_2 : Nontrivial R]\n  [h : Algebra.FiniteType R (AddMonoidAlgebra R M)], AddMonoid.Fg M","name":"AddMonoidAlgebra.fg_of_finiteType","isProp":true,"docString":"If `AddMonoidAlgebra R M` is of finite type then `M` is finitely generated. "},{"type":"‚àÄ (self : WellOrder), IsWellOrder (WellOrder.Œ± self) (WellOrder.r self)","name":"WellOrder.wo","isProp":true,"docString":"The proposition that `r` is a well-ordering for `Œ±`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] [inst_2 : IsDomain Œ≤] (e : Œ± ‚âÉ+* Œ≤), IsDomain Œ±","name":"Equiv.isDomain","isProp":true,"docString":"Transfer `IsDomain` across an `Equiv` "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (a‚Åª¬π < 1 : Prop) ‚Üî (1 < a : Prop)","name":"inv_lt_one'","isProp":true,"docString":"**Alias** of `Left.inv_lt_one_iff`."},{"type":"‚àÄ (n : ‚Ñï), Multiset.Nodup (Multiset.Nat.antidiagonal n)","name":"Multiset.Nat.nodup_antidiagonal","isProp":true,"docString":"The antidiagonal of `n` does not contain duplicate entries. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {Œπ : Sort u_1}\n  (p : (a : Œπ) ‚Üí Submodule R M) {C : (a : M) ‚Üí Prop} {x : M} (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ p i)\n  (hp : ‚àÄ (i : Œπ) (x : M) (a : x ‚àà p i), C x) (h0 : C 0) (hadd : ‚àÄ (x : M) (y : M) (a : C x) (a : C y), C (x + y)), C x","name":"Submodule.sup·µ¢_induction","isProp":true,"docString":"An induction principle for elements of `‚®Ü i, p i`.\nIf `C` holds for `0` and all elements of `p i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `p`. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  [inst_3 : IsAntisymm Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1] (h‚ÇÅ : a ‚â† b) (h‚ÇÇ : a ‚äÜ b), a ‚äÇ b","name":"Ne.ssubset_of_subset","isProp":true,"docString":"**Alias** of `ssubset_of_ne_of_subset`."},{"type":"‚àÄ {X : Type u} [inst : Preorder X] {x : X} {y : X} (h : x ‚ü∂ y), x ‚â§ y","name":"Quiver.Hom.le","isProp":true,"docString":"**Alias** of `CategoryTheory.leOfHom`."},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteDistribLattice Œ±] (a : Œ±) (s : Set Œ±),\n  (inf·µ¢ fun (b : Œ±) ‚Ü¶ inf·µ¢ fun (h : b ‚àà s) ‚Ü¶ a ‚äî b) ‚â§ a ‚äî inf‚Çõ s","name":"CompleteDistribLattice.inf·µ¢_sup_le_sup_inf‚Çõ","isProp":true,"docString":"In a completely distributive lattice, `‚äî` distributes over `‚®Ö`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : CommGroup Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (a : Œ±) (b : Œ±),\n  abs (a * b) ‚â§ abs a * abs b","name":"LatticeOrderedCommGroup.mabs_mul_le","isProp":true,"docString":"The absolute value satisfies the triangle inequality.\n"},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : Module ùïú E] {s : Set E}\n  (hs : Convex ùïú s) (z : E), Convex ùïú ((fun (x : E) ‚Ü¶ x + z) ‚Åª¬π' s)","name":"Convex.translate_preimage_left","isProp":true,"docString":"The translation of a convex set is also convex. "},{"type":"‚àÄ {M' : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : MulOneClass M'] [inst_1 : SMul Œ± Œ≤] [inst_2 : SMul M' Œ±]\n  [inst_3 : SMul M' Œ≤] [inst_4 : IsScalarTower M' Œ± Œ≤] (S : Submonoid M'), IsScalarTower { x : M' // x ‚àà S } Œ± Œ≤","name":"Submonoid.isScalarTower","isProp":true,"docString":"Note that this provides `IsScalarTower S M' M'` which is needed by `SMulMulAssoc`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {x : Œ±} {p : Filter Œπ} {g : (a : Œπ) ‚Üí Œ±} [inst_1 : TopologicalSpace Œ±] (h : ContinuousWithinAt f s x)\n  (hg : Filter.Tendsto g p (nhdsWithin x s))\n  (hunif :\n    ‚àÄ (u : Set (Œ≤ √ó Œ≤)) (a : u ‚àà uniformity Œ≤),\n      ‚àÉ (t : Set Œ±),\n        (t ‚àà nhdsWithin x s : Prop) ‚àß\n          (Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (y : Œ±) (a : y ‚àà t), (f y, F n y) ‚àà u) p : Prop)),\n  Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n (g n)) p (nhds (f x))","name":"tendsto_comp_of_locally_uniform_limit_within","isProp":true,"docString":"If `F‚Çô` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\nwhich is continuous at `x` within `s `, and `g‚Çô` tends to `x` within `s`, then `F‚Çô (g‚Çô)` tends\nto `f x`. "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] [inst_1 : TopologicalSpace G‚ÇÄ] [inst_2 : HasContinuousInv‚ÇÄ G‚ÇÄ],\n  Embedding Units.val","name":"Units.embedding_val‚ÇÄ","isProp":true,"docString":"If `G‚ÇÄ` is a group with zero with topology such that `x ‚Ü¶ x‚Åª¬π` is continuous at all nonzero\npoints. Then the coercion `G‚ÇÄÀ£ ‚Üí G‚ÇÄ` is a topological embedding. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]\n  (f : AddSubmonoid.LocalizationMap S N),\n  AddSubmonoid.LocalizationMap.ofAddEquivOfDom f\n      (let_fun this : AddSubmonoid.map (AddEquiv.toAddMonoidHom (AddEquiv.refl M)) S = S :=\n          ((AddSubmonoid.ext\n                (fun (x : M) ‚Ü¶\n                  (_ :\n                    (x ‚àà AddSubmonoid.map (AddEquiv.toAddMonoidHom (AddEquiv.refl M)) S : Prop) ‚Üî\n                      (x ‚àà S :\n                        Prop))=:‚àÄ (x : M),\n                    (x ‚àà AddSubmonoid.map (AddEquiv.toAddMonoidHom (AddEquiv.refl M)) S : Prop) ‚Üî\n                      (x ‚àà S :\n                        Prop))=:AddSubmonoid.map (AddEquiv.toAddMonoidHom (AddEquiv.refl M)) S =\n                S)=:AddSubmonoid.map (AddEquiv.toAddMonoidHom (AddEquiv.refl M)) S = S);\n        this=:AddSubmonoid.map (AddEquiv.toAddMonoidHom (AddEquiv.refl M)) S = S) =\n    f","name":"AddSubmonoid.LocalizationMap.ofAddEquivOfDom_id","isProp":true,"docString":"A special case of `f ‚àò id = f`, `f` a Localization map."},{"type":"‚àÄ {R : Type u_3} {M : Type u_4} [inst : CommSemiring R] {œÉ : Type u_2} [inst_1 : AddCommMonoid M] {Œπ : Type u_1}\n  (s : Finset Œπ) (œÜ : (a : Œπ) ‚Üí MvPolynomial œÉ R) (n : (a : Œπ) ‚Üí M) {w : (a : œÉ) ‚Üí M}\n  (a : ‚àÄ (i : Œπ) (a : i ‚àà s), MvPolynomial.IsWeightedHomogeneous w (œÜ i) (n i)),\n  MvPolynomial.IsWeightedHomogeneous w (Finset.prod s fun (i : Œπ) ‚Ü¶ œÜ i) (Finset.sum s fun (i : Œπ) ‚Ü¶ n i)","name":"MvPolynomial.IsWeightedHomogeneous.prod","isProp":true,"docString":"A product of weighted homogeneous polynomials is weighted homogeneous, with weighted degree\nequal to the sum of the weighted degrees. "},{"type":"‚àÄ {Œπ : Type v} {f : (a : Œπ) ‚Üí Cardinal} (hf : BddAbove (Set.range f)),\n  Cardinal.lift (sup·µ¢ f) = sup·µ¢ fun (i : Œπ) ‚Ü¶ Cardinal.lift (f i)","name":"Cardinal.lift_sup·µ¢","isProp":true,"docString":"The lift of a supremum is the supremum of the lifts. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} [inst : CompleteLattice Œ±] (s : (a : Œπ) ‚Üí Œ±),\n  (sup·µ¢ fun (i : Œπ) ‚Ü¶ s i) = sup·µ¢ fun (t : Finset Œπ) ‚Ü¶ sup·µ¢ fun (i : Œπ) ‚Ü¶ sup·µ¢ fun (h : i ‚àà t) ‚Ü¶ s i","name":"sup·µ¢_eq_sup·µ¢_finset","isProp":true,"docString":"Supremum of `s i`, `i : Œπ`, is equal to the supremum over `t : Finset Œπ` of suprema\n`‚®Ü i ‚àà t, s i`. This version assumes `Œπ` is a `Type _`. See `sup·µ¢_eq_sup·µ¢_finset'` for a version\nthat works for `Œπ : Sort*`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±}, Isometry Subtype.val","name":"isometry_subtype_coe","isProp":true,"docString":"The injection from a subtype is an isometry "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œµ : ENNReal} (Œµ0 : 0 < Œµ),\n  (setOf fun (p : Œ± √ó Œ±) ‚Ü¶ edist (Prod.fst p) (Prod.snd p) < Œµ) ‚àà uniformity Œ±","name":"edist_mem_uniformity","isProp":true,"docString":"Fixed size neighborhoods of the diagonal belong to the uniform structure "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤}\n  {f : (a : Œ±) ‚Üí Œ≤} {p : Filter Œπ} [inst_1 : UniformSpace Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} (hg : UniformContinuous g)\n  (h : TendstoUniformly F f p), TendstoUniformly (fun (i : Œπ) ‚Ü¶ g ‚àò F i) (g ‚àò f) p","name":"UniformContinuous.comp_tendstoUniformly","isProp":true,"docString":"Composing on the left by a uniformly continuous function preserves uniform convergence "},{"type":"‚àÄ {R : Type u} {œÉ : Type u_1} [inst : CommSemiring R] {P : (a : MvPolynomial œÉ R) ‚Üí Prop} (p : MvPolynomial œÉ R)\n  (h1 : ‚àÄ (u : œÉ ‚Üí‚ÇÄ ‚Ñï) (a : R), P (‚Üë(MvPolynomial.monomial u) a))\n  (h2 : ‚àÄ (p : MvPolynomial œÉ R) (q : MvPolynomial œÉ R) (a : P p) (a : P q), P (p + q)), P p","name":"MvPolynomial.induction_on'","isProp":true,"docString":"Analog of `Polynomial.induction_on'`.\nTo prove something about mv_polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonUnitalNormedRing Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx - y‚Äñ","name":"NonUnitalNormedRing.dist_eq","isProp":true,"docString":"The distance is induced by the norm. "},{"type":"‚àÄ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ‚ä§ ‚Üíg G'), Function.Injective ‚Üëf","name":"SimpleGraph.Hom.injective_of_top_hom","isProp":true,"docString":"Every graph homomomorphism from a complete graph is injective. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±]\n  [inst_2 : OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±}\n  (hf : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)),\n  Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x + g x) l Filter.atBot","name":"Filter.Tendsto.atBot_add","isProp":true,"docString":"In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`atBot` and `g` tends to `C` then `f + g` tends to `atBot`. "},{"type":"‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (self : Subalgebra R A)\n  (r : R),\n  ‚Üë(algebraMap R A) r ‚àà\n    Subsemigroup.carrier (Submonoid.toSubsemigroup (Subsemiring.toSubmonoid (Subalgebra.toSubsemiring self)))","name":"Subalgebra.algebraMap_mem'","isProp":true,"docString":"The image of `algebraMap` is contained in the underlying set of the subalgebra "},{"type":"‚àÄ {M : Type v} {X : Type x} [inst : UniformSpace X] [inst_1 : SMul M X] [inst_2 : SMul M·µê·µí·µñ X]\n  [inst_3 : IsCentralScalar M X] [inst_4 : UniformContinuousConstSMul M X], UniformContinuousConstSMul M·µê·µí·µñ X","name":"UniformContinuousConstSMul.op","isProp":true,"docString":"If a scalar action is central, then its right action is uniform continuous when its left action\nis. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) (p : Submodule R M‚ÇÇ) (h : ‚àÄ (v : (i : Œπ) ‚Üí M‚ÇÅ i), ‚Üëf v ‚àà p),\n  LinearMap.compMultilinearMap (Submodule.subtype p) (MultilinearMap.codRestrict f p h) = f","name":"LinearMap.subtype_compMultilinearMap_codRestrict","isProp":true,"docString":"The multilinear version of `LinearMap.subtype_comp_codRestrict` "},{"type":"‚àÄ {Œ± : Type u} (L : List Œ±) {i : ‚Ñï} {j : ‚Ñï} (h : j < List.length (List.drop i L)),\n  List.nthLe (List.drop i L) j h =\n    List.nthLe L (i + j)\n      ((Iff.mp\n            ((lt_tsub_iff_left=:(j < List.length L - i : Prop) ‚Üî\n                  (i + j < List.length L : Prop))=:(j < List.length L - i : Prop) ‚Üî (i + j < List.length L : Prop))\n            ((Eq.rec h\n                  ((List.length_drop i\n                        L=:List.length (List.drop i L) =\n                        List.length L -\n                          i)=:List.length (List.drop i L) =\n                      List.length L -\n                        i)=:j <\n                  List.length L - i)=:j < List.length L - i)=:i + j < List.length L)=:i + j < List.length L)","name":"List.nthLe_drop'","isProp":true,"docString":"The `i + j`-th element of a list coincides with the `j`-th element of the list obtained by\ndropping the first `i` elements. Version designed to rewrite from the small list to the big list. "},{"type":"‚àÄ {Œ± : Type u} [self : Semiring Œ±] (a : Œ±), a * 1 = a","name":"Semiring.mul_one","isProp":true,"docString":"One is a right neutral element for multiplication "},{"type":"‚àÄ {P : Type u_1} [inst : SemilatticeSup P] {x : P} {y : P} {s : Order.Ideal P} (hx : x ‚àà s) (hy : y ‚àà s), x ‚äî y ‚àà s","name":"Order.Ideal.sup_mem","isProp":true,"docString":"A specific witness of `I.directed` when `P` has joins. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p‚ÇÅ : P) (p‚ÇÇ : P), p‚ÇÅ ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ}","name":"left_mem_affineSpan_pair","isProp":true,"docString":"The first of two points lies in their affine span. "},{"type":"‚àÄ (R : Type u_1) [inst : Semiring R], (IsNoetherianRing R : Prop) ‚Üî (‚àÄ (I : Ideal R), Ideal.Fg I : Prop)","name":"isNoetherianRing_iff_ideal_fg","isProp":true,"docString":"A ring is Noetherian if and only if all its ideals are finitely-generated. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {œÉ : outParam (R ‚Üí+* S)} {M : outParam (Type u_4)} {M‚ÇÇ : outParam (Type u_5)} [inst_2 : AddCommMonoid M]\n  [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M] [inst_5 : Module S M‚ÇÇ] [self : SemilinearMapClass F œÉ M M‚ÇÇ] (f : F)\n  (r : R) (x : M), ‚Üëf (r ‚Ä¢ x) = ‚ÜëœÉ r ‚Ä¢ ‚Üëf x","name":"SemilinearMapClass.map_smul‚Çõ‚Çó","isProp":true,"docString":"A semilinear map preserves scalar multiplication up to some ring homomorphism `œÉ`.\nSee also `_root_.map_smul` for the case where `œÉ` is the identity. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {J : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category J] (F : J ‚•§ C·µí·µñ)\n  [inst_2 : CategoryTheory.Limits.HasColimit (CategoryTheory.Functor.leftOp F)], CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.Limits.hasLimit_of_hasColimit_leftOp","isProp":true,"docString":"If `F.leftOp : J·µí·µñ ‚•§ C` has a colimit, we can construct a limit for `F : J ‚•§ C·µí·µñ`.\n"},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhdsWithin a (Set.Iic a))\n  (hfs : closure (f '' s) ‚àà nhdsWithin (f a) (Set.Iic (f a))), ContinuousWithinAt f (Set.Iic a) a","name":"StrictMonoOn.continuousWithinAt_left_of_closure_image_mem_nhdsWithin","isProp":true,"docString":"If a function `f` with a densely ordered codomain is strictly monotone on a left neighborhood of\n`a` and the closure of the image of this neighborhood under `f` is a left neighborhood of `f a`,\nthen `f` is continuous at `a` from the left. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M)\n  (li : LinearIndependent R Subtype.val) (t : Finset ‚Üës), LinearIndependent R Subtype.val","name":"linearIndependent_finset_map_embedding_subtype","isProp":true,"docString":"Every finite subset of a linearly independent set is linearly independent. "},{"type":"‚àÄ {R : Type u_1} [inst : Rack R] {x : R} {y : R} {z : R},\n  (Shelf.act x (Shelf.act y z) = Shelf.act (Shelf.act x y) z : Prop) ‚Üî (Shelf.act x z = z : Prop)","name":"Rack.assoc_iff_id","isProp":true,"docString":"Associative racks are uninteresting.\n"},{"type":"‚àÄ (n : ‚Ñï) (i : ‚Ñï), Nat.testBit n i = List.getI (Nat.bits n) i","name":"Nat.testBit_eq_inth","isProp":true,"docString":"The ith bit is the ith element of `n.bits`. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M ‚Üí* P) {x : M} {y : M},\n  (‚Üë(Con.ker f) x y : Prop) ‚Üî (‚Üëf x = ‚Üëf y : Prop)","name":"Con.ker_rel","isProp":true,"docString":"The definition of the congruence relation defined by a monoid homomorphism's kernel. "},{"type":"‚àÄ {M : Type u_1} {Œ∫ : Type u_2} [inst : AddCommMonoid M] (S : Finset M) [inst_1 : Finite Œ∫] (C : (a : M) ‚Üí Œ∫),\n  ‚àÉ (a : ‚Ñï), (a > 0 : Prop) ‚àß (‚àÉ (b : M), ‚àÉ (c : Œ∫), ‚àÄ (s : M) (a_1 : s ‚àà S), C (a ‚Ä¢ s + b) = c : Prop)","name":"Combinatorics.exists_mono_homothetic_copy","isProp":true,"docString":"A generalization of Van der Waerden's theorem: if `M` is a finitely colored commutative\nmonoid, and `S` is a finite subset, then there exists a monochromatic homothetic copy of `S`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {n : Type u_2} [inst_1 : Fintype n] [inst_2 : DecidableEq n],\n  LinearMap.toMatrix (Pi.basisFun R n) (Pi.basisFun R n) = LinearMap.toMatrix'","name":"LinearMap.toMatrix_eq_toMatrix'","isProp":true,"docString":"`LinearMap.toMatrix'` is a particular case of `LinearMap.toMatrix`, for the standard basis\n`Pi.basisFun R n`. "},{"type":"‚àÄ (Œπ : Type u_1) [inst : Fintype Œπ], IsClosed (stdSimplex ‚Ñù Œπ)","name":"isClosed_stdSimplex","isProp":true,"docString":"`stdSimplex ‚Ñù Œπ` is closed. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] {a : Œ±} (a_1 : Even a), 2 ‚à£ a","name":"Even.two_dvd","isProp":true,"docString":"**Alias** of the forward direction of `even_iff_two_dvd`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ≤] [inst_2 : SuccOrder Œ≤]\n  [inst_3 : IsSuccArchimedean Œ≤] {s : (a : Œ≤) ‚Üí Set Œ±} (H : ‚àÄ (n : Œ≤), IsPreconnected (s n))\n  (K : ‚àÄ (n : Œ≤), Set.Nonempty (s n ‚à© s (Order.succ n))), IsPreconnected (Set.union·µ¢ fun (n : Œ≤) ‚Ü¶ s n)","name":"IsPreconnected.union·µ¢_of_chain","isProp":true,"docString":"The union·µ¢ of connected sets indexed by a type with an archimedean successor (like `‚Ñï` or `‚Ñ§`)\nsuch that any two neighboring sets meet is preconnected. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n  {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (sup·µ¢ g)) (Af : Antitone f) (fbot : f ‚ä• = ‚ä§),\n  f (sup·µ¢ fun (i : Œπ) ‚Ü¶ g i) = inf·µ¢ fun (i : Œπ) ‚Ü¶ f (g i)","name":"Antitone.map_sup·µ¢_of_continuousAt","isProp":true,"docString":"An antitone function sending `bot` to `top` is continuous at the indexed supremum over\na `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} {n : ‚Ñï} (a : Equiv.Perm.SameCycle f x y),\n  Equiv.Perm.SameCycle f (‚Üë(f ^ n) x) y","name":"Equiv.Perm.SameCycle.pow_left","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_pow_left`."},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] {f : (a : ‚Ñï) ‚Üí E} (g : (a : ‚Ñï) ‚Üí ‚Ñù)\n  (hg : CauchySeq fun (n : ‚Ñï) ‚Ü¶ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ g i) (hf : ‚àÄ (i : ‚Ñï), ‚Äñf i‚Äñ ‚â§ g i),\n  CauchySeq fun (n : ‚Ñï) ‚Ü¶ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f i","name":"cauchySeq_range_of_norm_bounded","isProp":true,"docString":"A version of the **direct comparison test** for conditionally convergent series.\nSee `cauchySeq_finset_of_norm_bounded` for the same statement about absolutely convergent ones. "},{"type":"‚àÄ {M : Type u_2} [inst : AddCommMonoid M] {Œπ : Type u_1} [inst_1 : Subsingleton Œπ] {s : Finset Œπ} {f : (a : Œπ) ‚Üí M}\n  {b : M} (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ f i) = b) (i : Œπ) (a : i ‚àà s), f i = b","name":"Fintype.eq_of_subsingleton_of_sum_eq","isProp":true,"docString":"If a sum of a `Finset` of a subsingleton type has a given\nvalue, so do the terms in that sum."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 ‚â§ a) (hb : 0 < b), 0 < a + b","name":"Left.add_pos_of_nonneg_of_pos","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos_of_nonneg_of_pos`."},{"type":"‚àÄ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R] (hR : ringChar R ‚â† 2), -1 ‚â† 1","name":"Ring.neg_one_ne_one_of_char_ne_two","isProp":true,"docString":"Characteristic `‚â† 2` and nontrivial implies that `-1 ‚â† 1`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : (a : Œπ) ‚Üí Type u_2} [inst : DecidableEq Œπ] [inst_1 : (i : Œπ) ‚Üí LinearOrder (Œ± i)]\n  (x : (i : Œπ) ‚Üí Œ± i) (y : (i : Œπ) ‚Üí Œ± i) (z : (i : Œπ) ‚Üí Œ± i),\n  (Set.Icc x z \\ Set.pi Set.univ fun (i : Œπ) ‚Ü¶ Set.Ioc (y i) (z i)) ‚äÜ\n    Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.Icc x (Function.update z i (y i))","name":"Set.Icc_diff_pi_univ_Ioc_subset","isProp":true,"docString":"If `x`, `y`, `z` are functions `Œ† i : Œπ, Œ± i`, then\nthe set difference between the box `[x, z]` and the product of the intervals `(y i, z i]`\nis covered by the union of the boxes `[x, update z i (y i)]`.\n\nE.g., if `x = y`, then this lemma states that the difference between a closed box\n`[x, y]` and the product of half-open intervals `{z | ‚àÄ i, x i < z i ‚â§ y i}` is covered by the union\nof the faces of `[x, y]` adjacent to `x`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤}\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {p : Filter Œπ} [inst_1 : UniformSpace Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} (hg : UniformContinuous g)\n  (h : TendstoUniformlyOn F f p s), TendstoUniformlyOn (fun (i : Œπ) ‚Ü¶ g ‚àò F i) (g ‚àò f) p s","name":"UniformContinuous.comp_tendstoUniformlyOn","isProp":true,"docString":"Composing on the left by a uniformly continuous function preserves\nuniform convergence on a set "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictMono f) (hg : Monotone g), StrictMono fun (x : Œ≤) ‚Ü¶ f x * g x","name":"StrictMono.mul_monotone'","isProp":true,"docString":"The product of a strictly monotone function and a monotone function is strictly monotone. "},{"type":"‚àÄ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (s : R) (x : A)\n  (y : A), x * s ‚Ä¢ y = s ‚Ä¢ (x * y)","name":"Algebra.mul_smul_comm","isProp":true,"docString":"This is just a special case of the global `mul_smul_comm` lemma that requires less typeclass\nsearch (and was here first). "},{"type":"‚àÄ (self : CompHaus), T2Space (CategoryTheory.Bundled.Œ± (CompHaus.toTop self))","name":"CompHaus.is_hausdorff","isProp":true,"docString":"The underlying topological space is T2."},{"type":"‚àÄ {k : Type u_2} {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P} {v : V},\n  (v ‚àà vectorSpan k {p‚ÇÅ, p‚ÇÇ} : Prop) ‚Üî (‚àÉ (r : k), r ‚Ä¢ (p‚ÇÇ -·µ• p‚ÇÅ) = v : Prop)","name":"mem_vectorSpan_pair_rev","isProp":true,"docString":"A vector lies in the `vectorSpan` of two points if and only if it is a multiple of their\ndifference (reversed). "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {y : Œ±} {s : Set Œ±} (h : y ‚àà s), EMetric.infEdist x s ‚â§ edist x y","name":"EMetric.infEdist_le_edist_of_mem","isProp":true,"docString":"The edist to a set is bounded above by the edist to any of its points "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) (p : (a : Œπ) ‚Üí P) (j : Œπ) (w‚ÇÅ : (a : Œπ) ‚Üí k) (w‚ÇÇ : (a : Œπ) ‚Üí k)\n  (hw : ‚àÄ (i : Œπ) (a : i ‚â† j), w‚ÇÅ i = w‚ÇÇ i),\n  ‚Üë(Finset.weightedVSubOfPoint s p (p j)) w‚ÇÅ = ‚Üë(Finset.weightedVSubOfPoint s p (p j)) w‚ÇÇ","name":"Finset.weightedVSubOfPoint_eq_of_weights_eq","isProp":true,"docString":"Given a family of points, if we use a member of the family as a base point, the\n`weightedVSubOfPoint` does not depend on the value of the weights at this point. "},{"type":"‚àÄ {f‚ÇÅ : CircleDeg1LiftÀ£} {f‚ÇÇ : CircleDeg1LiftÀ£}\n  (h : CircleDeg1Lift.translationNumber ‚Üëf‚ÇÅ = CircleDeg1Lift.translationNumber ‚Üëf‚ÇÇ),\n  ‚àÉ (F : CircleDeg1Lift), Function.Semiconj ‚ÜëF ‚Üë‚Üëf‚ÇÅ ‚Üë‚Üëf‚ÇÇ","name":"CircleDeg1Lift.units_semiconj_of_translationNumber_eq","isProp":true,"docString":"If two lifts of circle homeomorphisms have the same translation number, then they are\nsemiconjugate by a `CircleDeg1Lift`. This version uses arguments `f‚ÇÅ f‚ÇÇ : CircleDeg1LiftÀ£`\nto assume that `f‚ÇÅ` and `f‚ÇÇ` are homeomorphisms. "},{"type":"‚àÄ {n : ‚Ñï} (self : CompositionAsSet n), 0 ‚àà CompositionAsSet.boundaries self","name":"CompositionAsSet.zero_mem","isProp":true,"docString":"Proof that `0` is a member of `boundaries`"},{"type":"‚àÄ {Œ± : Type u_1} {a : (ii : ‚Ñï) √ó ((a : Fin ii) ‚Üí Œ±)} {b : (ii : ‚Ñï) √ó ((a : Fin ii) ‚Üí Œ±)} (h : Sigma.fst a = Sigma.fst b)\n  (a_1 : Sigma.snd a = Sigma.snd b ‚àò ‚Üë(Fin.cast h)), a = b","name":"Fin.sigma_eq_of_eq_comp_cast","isProp":true,"docString":"To show two sigma pairs of tuples agree, it to show the second elements are related via\n`Fin.cast`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} (self : Combinatorics.Line Œ± Œπ), ‚àÉ (i : Œπ), Combinatorics.Line.idxFun self i = none","name":"Combinatorics.Line.proper","isProp":true,"docString":"We require combinatorial lines to be nontrivial in the sense that `fun x ‚Ü¶ l x i` is `id` for\nat least one coordinate `i`. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] {a : Œ±} {b : Œ±} [inst_1 : IsAntisymm Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1]\n  (a_1 : a ‚äÜ b) (a_2 : b ‚äÜ a), a = b","name":"HasSubset.Subset.antisymm","isProp":true,"docString":"**Alias** of `subset_antisymm`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {e : LocalHomeomorph Œ± Œ≤} {s : Set Œ±} {t : Set Œ≥} {x : Œ±} {f : (a : Œ±) ‚Üí Œ≥}\n  (hf : ContinuousWithinAt f s x) (hxe : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)) (ht : t ‚àà nhds (f x)),\n  ‚Üë(LocalHomeomorph.symm e) ‚Åª¬π' s =·∂†[nhds (‚Üëe x)]\n    LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à© ‚Üë(LocalHomeomorph.symm e) ‚Åª¬π' (s ‚à© f ‚Åª¬π' t)","name":"LocalHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter","isProp":true,"docString":"This lemma is useful in the manifold library in the case that `e` is a chart. It states that\nlocally around `e x` the set `e.symm ‚Åª¬π' s` is the same as the set intersected with the target\nof `e` and some other neighborhood of `f x` (which will be the source of a chart on `Œ≥`).  "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PartialOrder Œ±] [inst_1 : PartialOrder Œ≤] {u : (a : Œ≤) ‚Üí Œ±}\n  (l : LowerAdjoint u), LowerAdjoint.closed l = Set.range (u ‚àò LowerAdjoint.toFun l)","name":"LowerAdjoint.closed_eq_range_close","isProp":true,"docString":"The set of closed elements for `l` is the range of `u ‚àò l`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : CancelMonoidWithZero Œ±] [inst_1 : Nontrivial Œ±], FaithfulSMul Œ±·µê·µí·µñ Œ±","name":"CancelMonoidWithZero.toFaithfulSMul_opposite","isProp":true,"docString":"`Monoid.toOppositeMulAction` is faithful on nontrivial cancellative monoids with zero. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (hf : AntitoneOn f s) (hg : AntitoneOn g s), AntitoneOn (fun (x : Œ≤) ‚Ü¶ f x + g x) s","name":"AntitoneOn.add","isProp":true,"docString":"The sum of two antitone functions is antitone."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ≤ : Type u_1} {p : (a : Œ≤) ‚Üí Prop} {f : (a : Œ≤) ‚Üí ENNReal}\n  (hf‚ÇÄ : ‚àÄ (x : Œ≤) (a : p x), 0 < f x) (hf : ‚àÄ (Œµ : ENNReal) (a : 0 < Œµ), ‚àÉ (x : Œ≤), (p x : Prop) ‚àß (f x ‚â§ Œµ : Prop)),\n  Filter.HasBasis (uniformity Œ±) p fun (x : Œ≤) ‚Ü¶ setOf fun (p : Œ± √ó Œ±) ‚Ü¶ edist (Prod.fst p) (Prod.snd p) ‚â§ f x","name":"EMetric.mk_uniformity_basis_le","isProp":true,"docString":"Given `f : Œ≤ ‚Üí ‚Ñù‚â•0‚àû`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed `f i`-neighborhoods of the diagonal form a basis of `ùì§ Œ±`.\n\nFor specific bases see `uniformity_basis_edist_le` and `uniformity_basis_edist_le'`. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Type u_1} [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] (A : (a : Œπ) ‚Üí Submodule R M),\n  (DirectSum.IsInternal A : Prop) ‚Üî ((CompleteLattice.Independent A : Prop) ‚àß (sup·µ¢ A = ‚ä§ : Prop) : Prop)","name":"DirectSum.isInternal_submodule_iff_independent_and_sup·µ¢_eq_top","isProp":true,"docString":"`iff` version of `DirectSum.isInternal_submodule_of_independent_of_sup·µ¢_eq_top`,\n`DirectSum.IsInternal.submodule_independent`, and `DirectSum.IsInternal.submodule_sup·µ¢_eq_top`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {S : CategoryTheory.Sieve X} {P : C·µí·µñ ‚•§ Type v‚ÇÅ}\n  (h : CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.arrows S))\n  (t‚ÇÅ : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda) X ‚ü∂ P)\n  (t‚ÇÇ : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda) X ‚ü∂ P)\n  (ht : CategoryTheory.Sieve.functorInclusion S ‚â´ t‚ÇÅ = CategoryTheory.Sieve.functorInclusion S ‚â´ t‚ÇÇ), t‚ÇÅ = t‚ÇÇ","name":"CategoryTheory.Presieve.IsSheafFor.hom_ext","isProp":true,"docString":"If `P` is a sheaf for the sieve `S` on `X`, then if two natural transformations from `yoneda.obj X`\nto `P` agree when restricted to the subfunctor given by `S`, they are equal.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (h : s ‚äÜ t) (ht : Metric.Bounded t),\n  Metric.diam s ‚â§ Metric.diam t","name":"Metric.diam_mono","isProp":true,"docString":"If `s ‚äÜ t`, then the diameter of `s` is bounded by that of `t`, provided `t` is bounded. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} (h‚ÇÄ : f = g)\n  {c : CategoryTheory.Limits.Cofork f g} (h : CategoryTheory.Limits.IsColimit c),\n  CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.œÄ c)","name":"CategoryTheory.Limits.isIso_colimit_cocone_parallelPair_of_eq","isProp":true,"docString":"Every coequalizer of `(f, g)`, where `f = g`, is an isomorphism. "},{"type":"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] {G : StructureGroupoid H} [inst_1 : ClosedUnderRestriction G]\n  (f : LocalHomeomorph H H) {x : H},\n  (StructureGroupoid.IsLocalStructomorphWithinAt G (‚Üëf) (LocalEquiv.source (LocalHomeomorph.toLocalEquiv f)) x : Prop) ‚Üî\n    (‚àÄ (a : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv f)),\n        ‚àÉ (e : LocalHomeomorph H H),\n          (e ‚àà G : Prop) ‚àß\n            ((LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚äÜ LocalEquiv.source (LocalHomeomorph.toLocalEquiv f) :\n                  Prop) ‚àß\n                ((Set.EqOn (‚Üëf) (‚Üëe) (LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)) : Prop) ‚àß\n                    (x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) : Prop) :\n                  Prop) :\n              Prop) :\n      Prop)","name":"LocalHomeomorph.isLocalStructomorphWithinAt_source_iff","isProp":true,"docString":"A slight reformulation of `IsLocalStructomorphWithinAt` when `f` is a local homeomorph and\nthe set we're considering is `f.source`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddMonoid Œ±] (m : Œ±) (a : Even m), ‚àÉ (c : Œ±), m = 2 ‚Ä¢ c","name":"Even.exists_two_nsmul","isProp":true,"docString":"Alias of the forwards direction of `even_iff_exists_two_nsmul`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {S : Set Œ≤} {f : (a : Œ≤) ‚Üí Set Œ±}\n  (hc : ‚àÄ (s : Œ≤) (a : s ‚àà S), IsClosed (f s)) (hS : Set.Countable S)\n  (hU : (Set.union·µ¢ fun (s : Œ≤) ‚Ü¶ Set.union·µ¢ fun (h : s ‚àà S) ‚Ü¶ f s) = Set.univ),\n  Dense (Set.union·µ¢ fun (s : Œ≤) ‚Ü¶ Set.union·µ¢ fun (h : s ‚àà S) ‚Ü¶ interior (f s))","name":"dense_bunion·µ¢_interior_of_closed","isProp":true,"docString":"Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±},\n  (UniformContinuousOn f s : Prop) ‚Üî\n    (‚àÄ (Œµ : ENNReal) (a : Œµ > 0),\n        ‚àÉ (Œ¥ : ENNReal),\n          (Œ¥ > 0 : Prop) ‚àß\n            (‚àÄ {a : Œ±} (a_1 : a ‚àà s) {b : Œ±} (a_2 : b ‚àà s) (a_3 : edist a b < Œ¥), edist (f a) (f b) < Œµ : Prop) :\n      Prop)","name":"EMetric.uniformContinuousOn_iff","isProp":true,"docString":"Œµ-Œ¥ characterization of uniform continuity on a set for pseudoemetric spaces "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {A : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category A] (P : C·µí·µñ ‚•§ A)\n  {X : C} (S : CategoryTheory.Sieve X),\n  (Nonempty\n        (CategoryTheory.Limits.IsLimit\n          (CategoryTheory.Functor.mapCone P\n            (CategoryTheory.Limits.Cocone.op (CategoryTheory.Presieve.cocone (CategoryTheory.Sieve.arrows S))))) :\n      Prop) ‚Üî\n    (‚àÄ (E : A·µí·µñ),\n        CategoryTheory.Presieve.IsSheafFor\n          (P ‚ãô Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.coyoneda) E)\n          (CategoryTheory.Sieve.arrows S) :\n      Prop)","name":"CategoryTheory.Presheaf.isLimit_iff_isSheafFor","isProp":true,"docString":"Given sieve `S` and presheaf `P : C·µí·µñ ‚•§ A`, their natural associated cone is a limit cone\niff `Hom (E, P -)` is a sheaf of types for the sieve `S` and all `E : A`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} [inst_4 : Nontrivial k] {p : (a : Œπ) ‚Üí P} (ha : AffineIndependent k p)\n  {s1 : Set Œπ} {s2 : Set Œπ} (hd : Disjoint s1 s2), Disjoint ‚Üë(affineSpan k (p '' s1)) ‚Üë(affineSpan k (p '' s2))","name":"AffineIndependent.affineSpan_disjoint_of_disjoint","isProp":true,"docString":"If a family is affinely independent, the spans of points indexed\nby disjoint subsets of the index type are disjoint, if the underlying\nring is nontrivial. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K), 0 ‚àà s","name":"Subfield.zero_mem","isProp":true,"docString":"A subfield contains the field's 0. "},{"type":"‚àÄ {m : Type u_2} {n : Type u_3} (R : Type u_1) [inst : CommRing R] [inst_1 : Fintype m] [inst_2 : DecidableEq m]\n  [inst_3 : Fintype n] [inst_4 : DecidableEq n] (e : m ‚âÉ n) (A : Matrix m m R),\n  Matrix.det (‚Üë(Matrix.reindexAlgEquiv R e) A) = Matrix.det A","name":"Matrix.det_reindexAlgEquiv","isProp":true,"docString":"Reindexing both indices along the same equivalence preserves the determinant.\n\nFor the `simp` version of this lemma, see `det_submatrix_equiv_self`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictMono f) (hg : StrictMono g), StrictMono fun (x : Œ≤) ‚Ü¶ f x * g x","name":"StrictMono.mul'","isProp":true,"docString":"The product of two strictly monotone functions is strictly monotone. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] (t : Finset Œπ) (f : (a : Œπ) ‚Üí Set Œ±) (a : Œ±),\n  (a ‚àà Finset.prod t fun (i : Œπ) ‚Ü¶ f i : Prop) ‚Üî\n    (‚àÉ (g : (a : Œπ) ‚Üí Œ±), ‚àÉ (x : ‚àÄ {i : Œπ} (a : i ‚àà t), g i ‚àà f i), (Finset.prod t fun (i : Œπ) ‚Ü¶ g i) = a : Prop)","name":"Set.mem_finset_prod","isProp":true,"docString":"The n-ary version of `Set.mem_mul`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : (a : Œ±) ‚Üí Œ≤} [inst : CommMonoid Œ≤] (R : Setoid Œ±)\n  [inst_1 : DecidableRel Setoid.r]\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s), (Finset.prod (Finset.filter (fun (y : Œ±) ‚Ü¶ y ‚âà x) s) fun (a : Œ±) ‚Ü¶ f a) = 1),\n  (Finset.prod s fun (x : Œ±) ‚Ü¶ f x) = 1","name":"Finset.prod_cancels_of_partition_cancels","isProp":true,"docString":"If we can partition a product into subsets that cancel out, then the whole product cancels. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (f : C(Œ± √ó Œ≤, Œ≥)), Continuous (ContinuousMap.curry' f)","name":"ContinuousMap.continuous_curry'","isProp":true,"docString":"If a map `Œ± √ó Œ≤ ‚Üí Œ≥` is continuous, then its curried form `Œ± ‚Üí C(Œ≤, Œ≥)` is continuous. "},{"type":"‚àÄ {Œ± : Type u} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (i : ‚Ñï), List.drop (List.length l‚ÇÅ + i) (l‚ÇÅ ++ l‚ÇÇ) = List.drop i l‚ÇÇ","name":"List.drop_append","isProp":true,"docString":"Dropping the elements up to `l‚ÇÅ.length + i` in `l‚ÇÅ + l‚ÇÇ` is the same as dropping the elements\nup to `i` in `l‚ÇÇ`. "},{"type":"‚àÄ {R : Type u} {L : Type v} {M : Type w} {N : Type w‚ÇÅ} [inst : CommRing R] [inst_1 : LieRing L]\n  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup N] [inst_4 : Module R M] [inst_5 : Module R N]\n  [inst_6 : LieRingModule L M] [inst_7 : LieRingModule L N] (self : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) {x : L} {m : M},\n  AddHom.toFun (LinearMap.toAddHom ‚Üëself) ‚ÅÖx, m‚ÅÜ = ‚ÅÖx, AddHom.toFun (LinearMap.toAddHom ‚Üëself) m‚ÅÜ","name":"LieModuleHom.map_lie'","isProp":true,"docString":"A module of Lie algebra modules is compatible with the action of the Lie algebra on the\nmodules. "},{"type":"‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)","name":"AddSubgroup.is_normal_topologicalClosure","isProp":true,"docString":"The topological closure of a normal additive subgroup is normal."},{"type":"‚àÄ {E : Type u_1} [self : NormedCommGroup E] (x : E) (y : E), dist x y = ‚Äñx / y‚Äñ","name":"NormedCommGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±]\n  (s : TopologicalSpace.Closeds Œ±),\n  ‚àÉ (S : Finset (TopologicalSpace.Closeds Œ±)),\n    (‚àÄ (k : { x : TopologicalSpace.Closeds Œ± // x ‚àà S }), IsIrreducible ‚Üë‚Üëk : Prop) ‚àß (s = Finset.sup S id : Prop)","name":"TopologicalSpace.NoetherianSpace.exists_finset_irreducible","isProp":true,"docString":"In a Noetherian space, every closed set is a finite union of irreducible closed sets. "},{"type":"‚àÄ {F : Type u_2} {E : Type u_1} [inst : Field F] [inst_1 : Ring E] [inst_2 : Algebra F E] [inst_3 : Nontrivial E]\n  (a : FiniteDimensional.finrank F E = 1), ‚ä• = ‚ä§","name":"Subalgebra.bot_eq_top_of_finrank_eq_one","isProp":true,"docString":"**Alias** of the reverse direction of `Subalgebra.bot_eq_top_iff_finrank_eq_one`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : IsGŒ¥ s) (ht : IsGŒ¥ t), IsGŒ¥ (s ‚à™ t)","name":"IsGŒ¥.union","isProp":true,"docString":"The union of two GŒ¥ sets is a GŒ¥ set. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  {s : (a : Œ≤) ‚Üí Œ±} (b : (a : Œ≤) ‚Üí ‚Ñù) (h : ‚àÄ (n : Œ≤) (m : Œ≤) (N : Œ≤) (a : N ‚â§ n) (a : N ‚â§ m), dist (s n) (s m) ‚â§ b N)\n  (h‚ÇÄ : Filter.Tendsto b Filter.atTop (nhds 0)), CauchySeq s","name":"cauchySeq_of_le_tendsto_0","isProp":true,"docString":"If the distance between `s n` and `s m`, `n, m ‚â• N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence.  "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a < b‚Åª¬π), b < a‚Åª¬π","name":"lt_inv_of_lt_inv","isProp":true,"docString":"**Alias** of the forward direction of `lt_inv'`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : BiheytingAlgebra Œ±] [inst_1 : BiheytingAlgebra Œ≤] (self : BiheytingHom Œ± Œ≤)\n  (a : Œ±) (b : Œ±),\n  SupHom.toFun (LatticeHom.toSupHom (BiheytingHom.toLatticeHom self)) (a ‚á® b) =\n    SupHom.toFun (LatticeHom.toSupHom (BiheytingHom.toLatticeHom self)) a ‚á®\n      SupHom.toFun (LatticeHom.toSupHom (BiheytingHom.toLatticeHom self)) b","name":"BiheytingHom.map_himp'","isProp":true,"docString":"The proposition that a bi-Heyting homomorphism preserves the Heyting implication."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasFilteredColimitsOfSize C]\n  (I : Type w) [inst_1 : CategoryTheory.Category I] [inst_2 : CategoryTheory.IsFiltered I],\n  CategoryTheory.Limits.HasColimitsOfShape I C","name":"CategoryTheory.Limits.HasFilteredColimitsOfSize.HasColimitsOfShape","isProp":true,"docString":"For all filtered types of a size `w`, we have colimits "},{"type":"‚àÄ {p : ‚Ñï}, padicValRat p 1 = 0","name":"padicValRat.one","isProp":true,"docString":"`padicValRat p 1` is `0` for any `p`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (a‚Åª¬π ‚â§ 1 : Prop) ‚Üî (1 ‚â§ a : Prop)","name":"Left.inv_le_one_iff","isProp":true,"docString":"Uses `left` co(ntra)variant. "},{"type":"‚àÄ {B : Type u_2} (F : Type u_1) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : (a : B) ‚Üí Type u_3)\n  [inst_2 : TopologicalSpace (Bundle.TotalSpace E)] [inst_3 : (b : B) ‚Üí TopologicalSpace (E b)]\n  [inst_4 : FiberBundle F E] [inst_5 : Nonempty F], QuotientMap Bundle.TotalSpace.proj","name":"FiberBundle.quotientMap_proj","isProp":true,"docString":"The projection from a fiber bundle with a nonempty fiber to its base is a quotient\nmap. "},{"type":"‚àÄ {Œ± : Type u} [inst : Subsingleton Œ±] {s : Set Œ±}, Subsingleton ‚Üës","name":"Set.subsingleton_coe_of_subsingleton","isProp":true,"docString":"The `coe_sort` of a set `s` in a subsingleton type is a subsingleton.\nFor the corresponding result for `subtype`, see `subtype.subsingleton`. "},{"type":"‚àÄ {T : Type u‚ÇÅ} [inst : CategoryTheory.Category T] {X : T} {f : CategoryTheory.Over X} {g : CategoryTheory.Over X}\n  (k : f ‚ü∂ g) [hk : CategoryTheory.Epi (CategoryTheory.CommaMorphism.left k)], CategoryTheory.Epi k","name":"CategoryTheory.Over.epi_of_epi_left","isProp":true,"docString":"If `k.left` is an epimorphism, then `k` is an epimorphism. In other words, `Over.forget X` reflects\nepimorphisms.\nThe converse does not hold without additional assumptions on the underlying category, see\n`CategoryTheory.Over.epi_left_of_epi`.\n"},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p : P) (ps : Set P), affineSpan k (insert p ‚Üë(affineSpan k ps)) = affineSpan k (insert p ps)","name":"affineSpan_insert_affineSpan","isProp":true,"docString":"Taking the affine span of a set, adding a point and taking the span again produces the same\nresults as adding the point to the set and taking the span. "},{"type":"‚àÄ {Œπ : Type u_2} {œÄ : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí TopologicalSpace (œÄ i)] {s : (i : Œπ) ‚Üí Set (œÄ i)}\n  (h : ‚àÄ (i : Œπ), IsCompact (s i)), IsCompact (Set.pi Set.univ s)","name":"isCompact_univ_pi","isProp":true,"docString":"**Tychonoff's theorem** formulated using `Set.pi`: product of compact sets is compact. "},{"type":"‚àÄ (G : Type u) [inst : AddLeftCancelSemigroup G], IsLeftCancelAdd G","name":"AddLeftCancelSemigroup.toIsLeftCancelAdd","isProp":true,"docString":"Any `AddLeftCancelSemigroup` satisfies\n`IsLeftCancelAdd`."},{"type":"‚àÄ {Œπ : Type u} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] [inst : (i : Œπ) ‚Üí Zero (Œ≤ i)] {b : (i : Œπ) ‚Üí Œ≤ i}\n  (h : ‚àÄ (i : Œπ), b i ‚â† 0), Function.Injective fun (i : Œπ) ‚Ü¶ Dfinsupp.single i (b i)","name":"Dfinsupp.single_left_injective","isProp":true,"docString":"`Dfinsupp.single a b` is injective in `a`. For the statement that it is injective in `b`, see\n`Dfinsupp.single_injective` "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N] {f : M ‚Üí+ N}\n  (h : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëf ‚Üëy)) (y : { x : M // x ‚àà S }) (w : N) (z : N),\n  (w + ‚Üë(-‚Üë(IsAddUnit.liftRight (AddMonoidHom.restrict f S) h) y) = z : Prop) ‚Üî (w = ‚Üëf ‚Üëy + z : Prop)","name":"AddSubmonoid.LocalizationMap.add_neg_left","isProp":true,"docString":"Given an AddMonoidHom `f : M ‚Üí+ N` and Submonoid `S ‚äÜ M` such that\n`f(S) ‚äÜ AddUnits N`, for all `w, z : N` and `y ‚àà S`, we have `w - f y = z ‚Üî w = f y + z`."},{"type":"‚àÄ {n : ‚Ñï} {a : Cardinal} (h : n ‚â† 0), (n ‚Ä¢ a < Cardinal.aleph0 : Prop) ‚Üî (a < Cardinal.aleph0 : Prop)","name":"Cardinal.nsmul_lt_aleph0_iff_of_ne_zero","isProp":true,"docString":"See also `Cardinal.nsmul_lt_aleph0_iff` for a hypothesis-free version. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =O[l] g'), f =O[l] fun (x : Œ±) ‚Ü¶ -g' x","name":"Asymptotics.IsBigO.neg_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigO_neg_right`."},{"type":"‚àÄ {G : Type u_1} [inst : CommGroup G] (L : List G) (n : ‚Ñï) (a : G),\n  List.prod (List.set L n a) = List.prod L * if hn : (n < List.length L : Prop) then (List.nthLe L n hn)‚Åª¬π * a else 1","name":"List.prod_set'","isProp":true,"docString":"Alternative version of `List.prod_set` when the list is over a group "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (hf : Monotone f) (hg : Monotone g), Monotone fun (x : Œ≤) ‚Ü¶ f x + g x","name":"Monotone.add","isProp":true,"docString":"The sum of two monotone functions is monotone."},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p‚ÇÅ : (a : Œπ) ‚Üí P) (p‚ÇÇ : (a : Œπ) ‚Üí P),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ i)) =\n    ‚Üë(Finset.affineCombination k s p‚ÇÅ) w -·µ• ‚Üë(Finset.affineCombination k s p‚ÇÇ) w","name":"Finset.sum_smul_vsub_eq_affineCombination_vsub","isProp":true,"docString":"A weighted sum of pairwise subtractions, expressed as a subtraction of two `affineCombination`\nexpressions. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Antivary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i)) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (Antivary f (g ‚àò ‚ÜëœÉ) : Prop)","name":"Antivary.sum_mul_eq_sum_mul_comp_perm_iff","isProp":true,"docString":"**Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together, is unchanged by a permutation if and only if `f` and `g ‚àò œÉ` antivary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ± : Type u_1} {c : ‚Ñù} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} {v : (a : Œ±) ‚Üí ‚Ñù} (a : Asymptotics.IsBigOWith c l u v),\n  Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ abs (u x)) fun (x : Œ±) ‚Ü¶ abs (v x)","name":"Asymptotics.IsBigOWith.abs_abs","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigOWith_abs_abs`."},{"type":"‚àÄ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R] (a : R) (x : a ‚â† 0) (b : R),\n  ‚àÉ (a' : R),\n    ‚àÉ (b' : R),\n      ‚àÉ (c' : R),\n        (‚àÄ {d : R} (a : d ‚à£ a') (a : d ‚à£ b'), IsUnit d : Prop) ‚àß ((c' * a' = a : Prop) ‚àß (c' * b' = b : Prop) : Prop)","name":"UniqueFactorizationMonoid.exists_reduced_factors","isProp":true,"docString":"If `a ‚â† 0, b` are elements of a unique factorization domain, then dividing\nout their common factor `c'` gives `a'` and `b'` with no factors in common. "},{"type":"‚àÄ {G : Type u} [self : CommGroup G] (a : G) (b : G), a * b = b * a","name":"CommGroup.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Nontrivial Œ±] {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f), Nontrivial Œ≤","name":"Function.Injective.nontrivial","isProp":true,"docString":"Pushforward a `nontrivial` instance along an injective function. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (F : C·µí·µñ ‚•§ Type v),\n  CategoryTheory.Functor.rightOp (CategoryTheory.CategoryOfElements.fromCostructuredArrow F) ‚ãô\n      CategoryTheory.CategoryOfElements.toCostructuredArrow F =\n    ùü≠ (CategoryTheory.CostructuredArrow CategoryTheory.yoneda F)","name":"CategoryTheory.CategoryOfElements.to_fromCostructuredArrow_eq","isProp":true,"docString":"The counit of the equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)` is indeed iso. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : UniqueFactorizationMonoid Œ±]\n  [inst_2 : NormalizationMonoid Œ±] [inst_3 : DecidableEq Œ±] {a : Œ±} {b : Œ±} (ha : a ‚â† 0) (hb : b ‚â† 0),\n  factorization (a * b) = factorization a + factorization b","name":"factorization_mul","isProp":true,"docString":"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop} (self : Concept Œ± Œ≤ r),\n  extentClosure r (Prod.snd (Concept.toProd self)) = Prod.fst (Concept.toProd self)","name":"Concept.closure_snd","isProp":true,"docString":"The axiom of a `Concept` stating that the closure of the second set is the first set. "},{"type":"‚àÄ {w : List ‚Ñï} {hw : List.Sorted (fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x ‚â• x_1) w} (hpos : ‚àÄ (x : ‚Ñï) (a : x ‚àà w), 0 < x),\n  List.length (YoungDiagram.rowLens (YoungDiagram.ofRowLens w hw)) = List.length w","name":"YoungDiagram.rowLens_length_ofRowLens","isProp":true,"docString":"The number of rows in `ofRowLens w hw` is the length of `w` "},{"type":"‚àÄ {m : ‚Ñ§} {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (hm : 0 < m) (h : c * a ‚â° c * b [ZMOD m]), a ‚â° b [ZMOD m / ‚Üë(Int.gcd m c)]","name":"Int.ModEq.cancel_left_div_gcd","isProp":true,"docString":"To cancel a common factor `c` from a `ModEq` we must divide the modulus `m` by `gcd m c`. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [inst : CommSemiring k] [inst_1 : Monoid G] {A : Type u‚ÇÉ} [inst_2 : Semiring A]\n  [inst_3 : Algebra k A] ‚¶ÉœÜ‚ÇÅ : MonoidAlgebra k G ‚Üí‚Çê[k] A‚¶Ñ ‚¶ÉœÜ‚ÇÇ : MonoidAlgebra k G ‚Üí‚Çê[k] A‚¶Ñ\n  (h : ‚àÄ (x : G), ‚ÜëœÜ‚ÇÅ (MonoidAlgebra.single x 1) = ‚ÜëœÜ‚ÇÇ (MonoidAlgebra.single x 1)), œÜ‚ÇÅ = œÜ‚ÇÇ","name":"MonoidAlgebra.algHom_ext","isProp":true,"docString":"A `k`-algebra homomorphism from `MonoidAlgebra k G` is uniquely defined by its\nvalues on the functions `single a 1`. "},{"type":"‚àÄ {Œπ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] [inst_1 : LT M] {s : Finset Œπ} {f : (a : Œπ) ‚Üí WithTop M}\n  (h : ‚àÄ (i : Œπ) (a : i ‚àà s), f i ‚â† ‚ä§), (Finset.sum s fun (i : Œπ) ‚Ü¶ f i) < ‚ä§","name":"WithTop.sum_lt_top","isProp":true,"docString":"A sum of finite numbers is still finite "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}\n  [inst_1 : CategoryTheory.Limits.HasPullback f g] [inst_2 : CategoryTheory.Mono f],\n  CategoryTheory.Mono CategoryTheory.Limits.pullback.snd","name":"CategoryTheory.Limits.pullback.snd_of_mono","isProp":true,"docString":"The pullback of a monomorphism is a monomorphism "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : Monotone f),\n  Monotone (WithBot.map f)","name":"Monotone.withBot_map","isProp":true,"docString":"**Alias** of the reverse direction of `WithBot.monotone_map_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} (hs : Set.Subsingleton s) (f : (a : Œ±) ‚Üí Œ≤), Set.Subsingleton (f '' s)","name":"Set.Subsingleton.image","isProp":true,"docString":"The image of a subsingleton is a subsingleton. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] [inst_4 : Nonempty Œ≤] [inst_5 : Zero Œ±] {f : (a : Œ≤) ‚Üí Œ±}\n  (hf : Continuous f) (h : HasCompactSupport f), ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f y ‚â§ f x","name":"Continuous.exists_forall_ge_of_hasCompactSupport","isProp":true,"docString":"A continuous function with compact support has a global maximum."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddSemigroup Œ±] [inst_1 : AddCommSemigroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {g : (a : Œ±) ‚Üí Œ≤} (hf : IsAddHom f) (hg : IsAddHom g), IsAddHom fun (a : Œ±) ‚Ü¶ f a + g a","name":"IsAddHom.add","isProp":true,"docString":"A sum of maps which preserves addition, preserves addition when the target\nis commutative."},{"type":"‚àÄ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a : K} {b : K} {c : K} (ha : a ‚â† 0) (h : discrim a b c = 0)\n  (x : K), (a * x * x + b * x + c = 0 : Prop) ‚Üî (x = -b / (2 * a) : Prop)","name":"quadratic_eq_zero_iff_of_discrim_eq_zero","isProp":true,"docString":"Root of a quadratic when its discriminant equals zero "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D]\n  {F : CategoryTheory.LaxMonoidalFunctor C D} {G : CategoryTheory.LaxMonoidalFunctor C D}\n  (self : CategoryTheory.MonoidalNatTrans F G) (X : C) (Y : C),\n  CategoryTheory.LaxMonoidalFunctor.Œº F X Y ‚â´ (CategoryTheory.MonoidalNatTrans.toNatTrans self).app (X ‚äó Y) =\n    ((CategoryTheory.MonoidalNatTrans.toNatTrans self).app X ‚äó\n        (CategoryTheory.MonoidalNatTrans.toNatTrans self).app Y) ‚â´\n      CategoryTheory.LaxMonoidalFunctor.Œº G X Y","name":"CategoryTheory.MonoidalNatTrans.tensor","isProp":true,"docString":"The tensor condition for a monoidal natural transformation. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (r : (a : M) ‚Üí (a : M) ‚Üí Prop),\n  addConGen r = inf‚Çõ (setOf fun (s : AddCon M) ‚Ü¶ ‚àÄ (x : M) (y : M) (a : r x y), ‚Üës x y)","name":"AddCon.addConGen_eq","isProp":true,"docString":"The inductively defined smallest additive congruence relation\ncontaining a binary relation `r` equals the infimum of the set of additive congruence relations\ncontaining `r`."},{"type":"‚àÄ {m : Type u_1} {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : DecidableEq m]\n  [inst_3 : Fintype m] {R : Type v} [inst_4 : CommRing R] (A : Matrix m m R) (C : Matrix n m R) (D : Matrix n n R),\n  Matrix.det (Matrix.fromBlocks A 0 C D) = Matrix.det A * Matrix.det D","name":"Matrix.det_fromBlocks_zero‚ÇÅ‚ÇÇ","isProp":true,"docString":"The determinant of a 2√ó2 block matrix with the upper-right block equal to zero is the product of\nthe determinants of the diagonal blocks. For the generalization to any number of blocks, see\n`Matrix.det_of_lower_triangular`. "},{"type":"‚àÄ {J : Type v} {K : Type v} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.SmallCategory K] {S : J}\n  {G : J ‚•§ K ‚•§ Type v} (x : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (G ‚ãô CategoryTheory.Limits.lim)) S)\n  (y : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (G ‚ãô CategoryTheory.Limits.lim)) S)\n  (w :\n    ‚àÄ (j : K),\n      CategoryTheory.Limits.limit.œÄ (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) S) j x =\n        CategoryTheory.Limits.limit.œÄ (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) S) j y),\n  x = y","name":"CategoryTheory.Limits.comp_lim_obj_ext","isProp":true,"docString":"`(G ‚ãô lim).obj S` = `limit (G.obj S)` definitionally, so this\nis just a variant of `limit_ext'`. "},{"type":"‚àÄ {Œπ : Type u_1} {I : BoxIntegral.Box Œπ} {i : Œπ} {x : ‚Ñù}\n  (h : ¬¨(x ‚àà Set.Ioo (BoxIntegral.Box.lower I i) (BoxIntegral.Box.upper I i) : Prop)),\n  BoxIntegral.Prepartition.split I i x = ‚ä§","name":"BoxIntegral.Prepartition.split_of_not_mem_Ioo","isProp":true,"docString":"If `x ‚àâ (I.lower i, I.upper i)`, then the hyperplane `{y | y i = x}` does not split `I`. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {G : Type u_3} [inst : Group G] [inst_1 : MulAction G Œ±] [inst_2 : AddCommMonoid M]\n  (g : G) (f : Œ± ‚Üí‚ÇÄ M) (a : Œ±), ‚Üë(g ‚Ä¢ f) a = ‚Üëf (g‚Åª¬π ‚Ä¢ a)","name":"Finsupp.comapSMul_apply","isProp":true,"docString":"When `G` is a group, `Finsupp.comapSMul` acts by precomposition with the action of `g‚Åª¬π`.\n"},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J]\n  (r : (a : J) ‚Üí (a : J) ‚Üí Prop) (hr : Equivalence r) (h : ‚àÄ {j‚ÇÅ : J} {j‚ÇÇ : J} (x : j‚ÇÅ ‚ü∂ j‚ÇÇ), r j‚ÇÅ j‚ÇÇ) (j‚ÇÅ : J)\n  (j‚ÇÇ : J), r j‚ÇÅ j‚ÇÇ","name":"CategoryTheory.equiv_relation","isProp":true,"docString":"Any equivalence relation containing (‚ü∂) holds for all pairs of a connected category. "},{"type":"‚àÄ {n : ‚Ñï} (a : Fin n), 0 < n","name":"Fin.size_positive","isProp":true,"docString":"If you actually have an element of `Fin n`, then the `n` is always positive "},{"type":"‚àÄ {R : Type u_1} {Œì‚ÇÄ : Type u_2} [inst : LinearOrderedCommMonoidWithZero Œì‚ÇÄ] [inst_1 : Ring R] (self : Valuation R Œì‚ÇÄ)\n  (x : R) (y : R),\n  ZeroHom.toFun (‚Üë(Valuation.toMonoidWithZeroHom self)) (x + y) ‚â§\n    max (ZeroHom.toFun (‚Üë(Valuation.toMonoidWithZeroHom self)) x)\n      (ZeroHom.toFun (‚Üë(Valuation.toMonoidWithZeroHom self)) y)","name":"Valuation.map_add_le_max'","isProp":true,"docString":"The valuation of a a sum is less that the sum of the valuations "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {s : Set M}, s ‚äÜ ‚Üë(Subsemigroup.closure s)","name":"Subsemigroup.subset_closure","isProp":true,"docString":"The subsemigroup generated by a set includes the set. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y}\n  (self : CategoryTheory.Limits.StrongEpiMonoFactorisation f),\n  CategoryTheory.StrongEpi\n    (CategoryTheory.Limits.MonoFactorisation.e\n      (CategoryTheory.Limits.StrongEpiMonoFactorisation.toMonoFactorisation self))","name":"CategoryTheory.Limits.StrongEpiMonoFactorisation.e_strong_epi","isProp":true,"docString":"A strong epi-mono factorisation is a decomposition `f = e ‚â´ m` with `e` a strong epimorphism\nand `m` a monomorphism. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a + b < c), b < c - a","name":"lt_sub_left_of_add_lt","isProp":true,"docString":"**Alias** of the reverse direction of `lt_sub_iff_add_lt'`."},{"type":"‚àÄ {Œ± : Type u} {m : ‚Ñï} {n : ‚Ñï} (f : (a : Fin (m * n)) ‚Üí Œ±),\n  List.ofFn f =\n    List.join\n      (List.ofFn fun (i : Fin n) ‚Ü¶\n        List.ofFn fun (j : Fin m) ‚Ü¶\n          f\n            { val := m * ‚Üëi + ‚Üëj,\n              isLt :=\n                ((Trans.trans\n                      ((LT.lt.trans_eq\n                            ((add_lt_add_left ((Fin.prop j=:‚Üëj < m)=:‚Üëj < m)\n                                  (m * ‚Üëi)=:m * ‚Üëi + ‚Üëj < m * ‚Üëi + m)=:m * ‚Üëi + ‚Üëj < m * ‚Üëi + m)\n                            ((Eq.symm\n                                  ((mul_add_one m\n                                        ‚Üëi=:m * (‚Üëi + 1) =\n                                        m * ‚Üëi +\n                                          m)=:m * (‚Üëi + 1) =\n                                      m * ‚Üëi +\n                                        m)=:m * ‚Üëi + m =\n                                  m *\n                                    (‚Üëi +\n                                      1))=:m * ‚Üëi + m =\n                                m * (‚Üëi + 1))=:m * ‚Üëi + ‚Üëj < m * (‚Üëi + 1))=:m * ‚Üëi + ‚Üëj < m * (‚Üëi + 1))\n                      ((Nat.mul_le_mul_left m\n                            ((Fin.prop\n                                  i=:‚Üëi <\n                                  n)=:‚Üëi <\n                                n)=:m * (‚Üëi + 1) ‚â§\n                            m * n)=:m * (‚Üëi + 1) ‚â§ m * n)=:m * ‚Üëi + ‚Üëj < m * n)=:m * ‚Üëi + ‚Üëj < m * n) })","name":"List.ofFn_mul'","isProp":true,"docString":"This breaks a list of `m*n` items into `n` groups each containing `m` elements. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : SemilatticeInf Œ≥] {s : Set Œ≥} {t : Set Œ≥},\n  (BddBelow (s ‚à™ t) : Prop) ‚Üî ((BddBelow s : Prop) ‚àß (BddBelow t : Prop) : Prop)","name":"bddBelow_union","isProp":true,"docString":"The union of two sets is bounded above if and only if each of the sets is."},{"type":"‚àÄ {Œ±' : Sort w} [inst : DecidableEq Œ±'] {Œ± : Sort u_1} {Œ≤ : Sort u_2} (g : (a : Œ±') ‚Üí Œ≤) {f : (a : Œ±) ‚Üí Œ±'} {i : Œ±'}\n  (a : Œ≤) (h : ‚àÄ (x : Œ±), f x ‚â† i), Function.update g i a ‚àò f = g ‚àò f","name":"Function.update_comp_eq_of_forall_ne","isProp":true,"docString":"Non-dependent version of `Function.update_comp_eq_of_forall_ne'` "},{"type":"‚àÄ {B : Type u_2} {F : Type u_4} {E : (a : B) ‚Üí Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (a : FiberPrebundle F E) {X : Type u_1} [inst_2 : TopologicalSpace X] {f : (a : Bundle.TotalSpace E) ‚Üí X} {s : Set B}\n  (hs : IsOpen s)\n  (hf :\n    ‚àÄ (b : B) (a_1 : b ‚àà s),\n      ContinuousOn\n        (f ‚àò\n          LocalEquiv.toFun (LocalEquiv.symm (Pretrivialization.toLocalEquiv (FiberPrebundle.pretrivializationAt a b))))\n        ((s ‚à© Pretrivialization.baseSet (FiberPrebundle.pretrivializationAt a b)) √óÀ¢ Set.univ)),\n  ContinuousOn f (Bundle.TotalSpace.proj ‚Åª¬π' s)","name":"FiberPrebundle.continuousOn_of_comp_right","isProp":true,"docString":"For a fiber bundle `E` over `B` constructed using the `FiberPrebundle` mechanism,\ncontinuity of a function `TotalSpace E ‚Üí X` on an open set `s` can be checked by precomposing at\neach point with the pretrivialization used for the construction at that point. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (1 ‚â§ a‚Åª¬π : Prop) ‚Üî (a ‚â§ 1 : Prop)","name":"Left.one_le_inv_iff","isProp":true,"docString":"Uses `left` co(ntra)variant. "},{"type":"‚àÄ {C : Type u_3} {D : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D]\n  {F : CategoryTheory.Idempotents.Karoubi C ‚•§ D} {G : CategoryTheory.Idempotents.Karoubi C ‚•§ D} (œÜ : F ‚ü∂ G)\n  (P : CategoryTheory.Idempotents.Karoubi C),\n  œÜ.app P =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (CategoryTheory.Idempotents.Karoubi.decompId_i P) ‚â´\n      œÜ.app\n          { X := CategoryTheory.Idempotents.Karoubi.X P, p := ùüô (CategoryTheory.Idempotents.Karoubi.X P),\n            idem :=\n              ((CategoryTheory.Idempotents.Karoubi.coe.proof_1\n                    (CategoryTheory.Idempotents.Karoubi.X\n                      P)=:ùüô (CategoryTheory.Idempotents.Karoubi.X P) ‚â´ ùüô (CategoryTheory.Idempotents.Karoubi.X P) =\n                    ùüô\n                      (CategoryTheory.Idempotents.Karoubi.X\n                        P))=:ùüô (CategoryTheory.Idempotents.Karoubi.X P) ‚â´ ùüô (CategoryTheory.Idempotents.Karoubi.X P) =\n                  ùüô (CategoryTheory.Idempotents.Karoubi.X P)) } ‚â´\n        Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) (CategoryTheory.Idempotents.Karoubi.decompId_p P)","name":"CategoryTheory.Idempotents.natTrans_eq","isProp":true,"docString":"A natural transformation between functors `Karoubi C ‚•§ D` is determined\nby its value on objects coming from `C`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 : AffineSubspace k P) (s2 : AffineSubspace k P),\n  (s1 < s2 : Prop) ‚Üî ((s1 ‚â§ s2 : Prop) ‚àß (‚àÉ (p : P), (p ‚àà s2 : Prop) ‚àß (¬¨(p ‚àà s1 : Prop) : Prop) : Prop) : Prop)","name":"AffineSubspace.lt_iff_le_and_exists","isProp":true,"docString":"A subspace is less than another if and only if it is less than or equal to the second subspace\nand there is a point only in the second. "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedRing Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c + a ‚â§ c + b","name":"OrderedRing.add_le_add_left","isProp":true,"docString":"Addition is monotone in a ordered additive commutative group. "},{"type":"‚àÄ {R : Type u} {Œπ : Type w} (s : Finset Œπ) [inst : CommSemiring R] [inst_1 : NoZeroDivisors R]\n  (f : (a : Œπ) ‚Üí Polynomial R) [inst_2 : Nontrivial R],\n  Polynomial.degree (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) = Finset.sum s fun (i : Œπ) ‚Ü¶ Polynomial.degree (f i)","name":"Polynomial.degree_prod","isProp":true,"docString":"The degree of a product of polynomials is equal to\nthe sum of the degrees, where the degree of the zero polynomial is ‚ä•.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} (hs : Set.Nonempty s) {C : ‚Ñù}\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s), dist x y ‚â§ C), Metric.diam s ‚â§ C","name":"Metric.diam_le_of_forall_dist_le_of_nonempty","isProp":true,"docString":"If the distance between any two points in a nonempty set is bounded by some constant,\nthis constant bounds the diameter. "},{"type":"‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_4 : AddCommMonoid M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ]\n  [inst_6 : RingHomSurjective œÉ‚ÇÅ‚ÇÇ] (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) {x : M} {s : Set M}\n  (h : ¬¨(‚Üëf x ‚àà Submodule.span R‚ÇÇ (‚Üëf '' s) : Prop)), ¬¨(x ‚àà Submodule.span R s : Prop)","name":"Submodule.not_mem_span_of_apply_not_mem_span_image","isProp":true,"docString":"`f` is an explicit argument so we can `apply` this theorem and obtain `h` as a new goal. "},{"type":"‚àÄ {n : ‚Ñï}, Finsupp.support (Nat.factorization n) = List.toFinset (Nat.factors n)","name":"Nat.support_factorization","isProp":true,"docString":"The support of `n.factorization` is exactly `n.factors.toFinset` "},{"type":"‚àÄ {I : Type v‚ÇÅ} {C : (a : I) ‚Üí Type u‚ÇÅ} [inst : (i : I) ‚Üí CategoryTheory.Category (C i)] {J : Type v‚ÇÅ}\n  [inst_1 : CategoryTheory.SmallCategory J] {F : J ‚•§ ((i : I) ‚Üí C i)}\n  [inst_2 : ‚àÄ (i : I), CategoryTheory.Limits.HasLimit (F ‚ãô CategoryTheory.Pi.eval C i)],\n  CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.pi.hasLimit_of_hasLimit_comp_eval","isProp":true,"docString":"If we have a functor `F : J ‚•§ Œ† i, C i` into a category of indexed families,\nand we have limits for each of the `F ‚ãô Pi.eval C i`,\nthen `F` has a limit.\n"},{"type":"‚àÄ {M : Type uM} [inst : AddCommMonoid M] (n : ‚Ñï) (m : M), ‚Üë‚Üën m = n ‚Ä¢ m","name":"AddMonoid.End.natCast_apply","isProp":true,"docString":"See also `AddMonoid.End.natCast_def`. "},{"type":"‚àÄ {R : Type u‚ÇÅ} [inst : StrictOrderedSemiring R] {a : R} (Hsq : 0 ‚â§ a * a) (Hsq' : 0 ‚â§ (1 + a) * (1 + a))\n  (H : 0 ‚â§ 2 + a) (n : ‚Ñï), 1 + ‚Üën * a ‚â§ (1 + a) ^ n","name":"one_add_mul_le_pow'","isProp":true,"docString":"Bernoulli's inequality. This version works for semirings but requires\nadditional hypotheses `0 ‚â§ a * a` and `0 ‚â§ (1 + a) * (1 + a)`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : CompleteLattice Œ±] (a : WellFounded fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x > x_1),\n  CompleteLattice.IsSupClosedCompact Œ±","name":"WellFounded.isSupClosedCompact","isProp":true,"docString":"**Alias** of the reverse direction of `CompleteLattice.isSupClosedCompact_iff_wellFounded`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {C : ‚Ñù}\n  (h : ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s), dist x y ‚â§ C), EMetric.diam s ‚â§ ENNReal.ofReal C","name":"Metric.ediam_le_of_forall_dist_le","isProp":true,"docString":"If the distance between any two points in a set is bounded by some constant `C`,\nthen `ENNReal.ofReal C`  bounds the emetric diameter of this set. "},{"type":"‚àÄ {Œ± : Type u} [inst : LE Œ±] [self : OrderTop Œ±] (a : Œ±), a ‚â§ ‚ä§","name":"OrderTop.le_top","isProp":true,"docString":"`‚ä§` is the greatest element "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] {c : AddCon M} {d : AddCon M} (h : c ‚â§ d) (x : AddCon.Quotient c),\n  ‚Üë(AddCon.map c d h) x =\n    ‚Üë(AddCon.lift c (AddCon.mk' d)\n          (fun (x : M) ‚Ü¶ (_ : ‚àÄ (x_1 : M) (hc : ‚Üëc x x_1), ‚Üëx = ‚Üëx_1)=:‚àÄ (x : M) (x_1 : M) (hc : ‚Üëc x x_1), ‚Üëx = ‚Üëx_1))\n      x","name":"AddCon.map_apply","isProp":true,"docString":"Given additive congruence relations `c, d` on an `AddMonoid` such that `d`\ncontains `c`, the definition of the homomorphism from the quotient by `c` to the quotient by `d`\ninduced by `d`'s quotient map."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] {f : Filter Œ≤} {u : (a : Œ≤) ‚Üí Œ±} {a : Œ±} [inst_3 : Filter.NeBot f]\n  (h : Filter.Tendsto u f (nhds a)), Filter.liminf u f = a","name":"Filter.Tendsto.liminf_eq","isProp":true,"docString":"If a function has a limit, then its liminf coincides with its limit. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r‚ÇÅ : R) (r‚ÇÇ : R)\n  (s : { x : R // x ‚àà S }) (h : ‚Üës * r‚ÇÅ = ‚Üës * r‚ÇÇ), ‚àÉ (s' : { x : R // x ‚àà S }), r‚ÇÅ * ‚Üës' = r‚ÇÇ * ‚Üës'","name":"OreLocalization.ore_left_cancel","isProp":true,"docString":"Common factors on the left can be turned into common factors on the right, a weak form of\ncancellability. "},{"type":"‚àÄ {Œ± : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsAntisymm Œ± r] {a : Œ±} {b : Œ±} (a_1 : r a b) (a_2 : r b a), b = a","name":"antisymm_of'","isProp":true,"docString":"A version of `antisymm'` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `Init.Algebra.Classes`, but is missing there.  "},{"type":"‚àÄ (p' : ‚Ñï), 2 < LucasLehmer.q (p' + 2)","name":"LucasLehmer.two_lt_q","isProp":true,"docString":"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] (self : Œ± ‚Üío Œ≤), Monotone ‚Üëself","name":"OrderHom.monotone'","isProp":true,"docString":"The underlying function of an `OrderHom` is monotone. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteLattice Œ±] (s : Set Œ±) (a : Œ±) (a_1 : ‚àÄ (b : Œ±) (a_1 : b ‚àà s), a ‚â§ b), a ‚â§ inf‚Çõ s","name":"CompleteLattice.le_inf‚Çõ","isProp":true,"docString":"Any lower bound is less than the set infimum. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_3} {Œ≤ : Type u_2} {S : (a : Œπ) ‚Üí Set Œ±} {f : (i : Œπ) ‚Üí (x : ‚Üë(S i)) ‚Üí Œ≤}\n  {hf :\n    ‚àÄ (i : Œπ) (j : Œπ) (x : Œ±) (hxi : x ‚àà S i) (hxj : x ‚àà S j),\n      f i { val := x, property := hxi } = f j { val := x, property := hxj }}\n  {T : Set Œ±} {hT : T ‚äÜ Set.union·µ¢ S} (c : ‚ÜëT) (ci : (i : Œπ) ‚Üí ‚Üë(S i)) (hci : ‚àÄ (i : Œπ), ‚Üë(ci i) = ‚Üëc) (cŒ≤ : Œ≤)\n  (h : ‚àÄ (i : Œπ), f i (ci i) = cŒ≤), Set.union·µ¢Lift S f hf T hT c = cŒ≤","name":"Set.union·µ¢Lift_const","isProp":true,"docString":"`union·µ¢Lift_const` is useful for proving that `union·µ¢Lift` is a homomorphism\nof algebraic structures when defined on the Union of algebraic subobjects.\nFor example, it could be used to prove that the lift of a collection\nof group homomorphisms on a union of subgroups preserves `1`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : IsEmpty Œ±], Fintype.card Œ± = 0","name":"Fintype.card_of_isEmpty","isProp":true,"docString":"Note: this lemma is specifically about `Fintype.of_is_empty`. For a statement about\narbitrary `Fintype` instances, use `Fintype.card_eq_zero_iff`. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_3} [inst : CommSemiring R] {œÉ : Type u_1} [inst_1 : AddCommMonoid M] {w : (a : œÉ) ‚Üí M}\n  (m : M) (n : M) (p : MvPolynomial œÉ R) (h : p ‚àà MvPolynomial.weightedHomogeneousSubmodule R w n),\n  ‚Üë(MvPolynomial.weightedHomogeneousComponent w m) p = if (m = n : Prop) then p else 0","name":"MvPolynomial.weightedHomogeneousComponent_weighted_homogeneous_polynomial","isProp":true,"docString":"The weighted homogeneous components of a weighted homogeneous polynomial. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y),\n  CategoryTheory.IsIso (CategoryTheory.Limits.coequalizer.œÄ f f)","name":"CategoryTheory.Limits.coequalizer.œÄ_of_self","isProp":true,"docString":"The coequalizer projection for `(f, f)` is an isomorphism. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {X : CategoryTheory.SimplicialObject C} (q : ‚Ñï) (n : ‚Ñï),\n  AlgebraicTopology.DoldKan.HigherFacesVanish q (HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.P q) (n + 1))","name":"AlgebraicTopology.DoldKan.HigherFacesVanish.of_P","isProp":true,"docString":"This lemma expresses the vanishing of\n`(P q).f (n+1) ‚â´ X.Œ¥ k : X _[n+1] ‚ü∂ X _[n]` when `k‚â†0` and `k‚â•n-q+2` "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±],\n  uniformity Œ± =\n    inf·µ¢ fun (Œµ : ENNReal) ‚Ü¶\n      inf·µ¢ fun (h : Œµ > 0) ‚Ü¶ Filter.principal (setOf fun (p : Œ± √ó Œ±) ‚Ü¶ edist (Prod.fst p) (Prod.snd p) < Œµ)","name":"uniformity_pseudoedist","isProp":true,"docString":"Reformulation of the uniform structure in terms of the extended distance "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] (f : CompleteLatticeHom Œ± Œ±) (a : Œ±),\n  ‚Üëf (Filter.limsup (fun (n : ‚Ñï) ‚Ü¶ (‚Üëf^[n]) a) Filter.atTop) = Filter.limsup (fun (n : ‚Ñï) ‚Ü¶ (‚Üëf^[n]) a) Filter.atTop","name":"Filter.CompleteLatticeHom.apply_limsup_iterate","isProp":true,"docString":"If `f : Œ± ‚Üí Œ±` is a morphism of complete lattices, then the limsup of its iterates of any\n`a : Œ±` is a fixed point. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_4} {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : SMul M Œ±] [inst_1 : SMul M Œ≤] [inst_2 : SMul Œ± Œ≤]\n  [inst_3 : IsScalarTower M Œ± Œ≤] (g : (a : N) ‚Üí M), IsScalarTower N Œ± Œ≤","name":"SMul.comp.isScalarTower","isProp":true,"docString":"Given a tower of scalar actions `M ‚Üí Œ± ‚Üí Œ≤`, if we use `SMul.comp`\nto pull back both of `M`'s actions by a map `g : N ‚Üí M`, then we obtain a new\ntower of scalar actions `N ‚Üí Œ± ‚Üí Œ≤`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : C ‚•§ D} {H : C ‚•§ D} (e : F ‚âÖ G) (e' : G ‚âÖ H) (hF : CategoryTheory.IsEquivalence F),\n  CategoryTheory.IsEquivalence.ofIso e' (CategoryTheory.IsEquivalence.ofIso e hF) =\n    CategoryTheory.IsEquivalence.ofIso (e ‚â™‚â´ e') hF","name":"CategoryTheory.IsEquivalence.ofIso_trans","isProp":true,"docString":"Compatibility of `ofIso` with the composition of isomorphisms of functors "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±},\n  (x ‚àà closure s : Prop) ‚Üî (‚àÄ (Œµ : ENNReal) (a : Œµ > 0), ‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (edist x y < Œµ : Prop) : Prop)","name":"EMetric.mem_closure_iff","isProp":true,"docString":"Œµ-characterization of the closure in pseudoemetric spaces "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : UniformSpace.Completion Œ±) (y : UniformSpace.Completion Œ±)\n  (h : dist x y = 0), x = y","name":"UniformSpace.Completion.eq_of_dist_eq_zero","isProp":true,"docString":"If two points are at distance 0, then they coincide. "},{"type":"‚àÄ {R : Type u_1} [inst : AddSemigroup R] {a : R} (b : R) (ha : IsAddRightRegular a),\n  (IsAddRightRegular (b + a) : Prop) ‚Üî (IsAddRightRegular b : Prop)","name":"add_isAddRightRegular_iff","isProp":true,"docString":"An element is add-right-regular if and only if adding it on the right to\na add-right-regular element is add-right-regular."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (x : M)\n  (y : M), r ‚Ä¢ (x + y) = r ‚Ä¢ x + r ‚Ä¢ y","name":"Module.Core.smul_add","isProp":true,"docString":"Scalar multiplication distributes over addition from the left. "},{"type":"‚àÄ {Œ± : Type u_1}, WellFounded fun (x : Multiset Œ±) (x_1 : Multiset Œ±) ‚Ü¶ x < x_1","name":"Multiset.wellFounded_lt","isProp":true,"docString":"Another way of expressing `strongInductionOn`: the `(<)` relation is well-founded. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤},\n  ((¬¨(Monotone f : Prop) : Prop) ‚àß (¬¨(Antitone f : Prop) : Prop) : Prop) ‚Üî\n    (‚àÉ (a : Œ±),\n        ‚àÉ (b : Œ±),\n          ‚àÉ (c : Œ±),\n            (a < b : Prop) ‚àß\n              ((b < c : Prop) ‚àß\n                  (((f a < f b : Prop) ‚àß (f c < f b : Prop) : Prop) ‚à® ((f b < f a : Prop) ‚àß (f b < f c : Prop) : Prop) :\n                    Prop) :\n                Prop) :\n      Prop)","name":"not_monotone_not_antitone_iff_exists_lt_lt","isProp":true,"docString":"A function between linear orders which is neither monotone nor antitone makes a dent upright or\ndownright. "},{"type":"‚àÄ {R : Type u_2} {R‚ÇÇ : Type u_4} {E : Type u_3} {E‚ÇÇ : Type u_5} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ]\n  [inst_4 : SeminormedAddCommGroup E] [inst_5 : SeminormedAddCommGroup E‚ÇÇ] [inst_6 : Module R E] [inst_7 : Module R‚ÇÇ E‚ÇÇ]\n  {Œπ : Type u_1} (b : Basis Œπ R E) {f‚ÇÅ : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} {f‚ÇÇ : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : ‚àÄ (i : Œπ), ‚Üëf‚ÇÅ (‚Üëb i) = ‚Üëf‚ÇÇ (‚Üëb i)),\n  f‚ÇÅ = f‚ÇÇ","name":"Basis.ext_linearIsometryEquiv","isProp":true,"docString":"Two linear isometric equivalences are equal if they are equal on basis vectors. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (H : AddSubgroup G) {f : N ‚Üí+ G}\n  (hf : Function.Surjective ‚Üëf),\n  AddSubgroup.comap f (AddSubgroup.normalizer H) = AddSubgroup.normalizer (AddSubgroup.comap f H)","name":"AddSubgroup.comap_normalizer_eq_of_surjective","isProp":true,"docString":"The preimage of the normalizer is equal to the normalizer of the preimage of\na surjective function."},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] [inst_1 : DecidableEq Œ±] (s : Finset Œ±) (f : (a : Œ±) ‚Üí Œ≤) {a : Œ±}\n  (h : a ‚àà s), (f a * Finset.prod (Finset.erase s a) fun (x : Œ±) ‚Ü¶ f x) = Finset.prod s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.mul_prod_erase","isProp":true,"docString":"Taking a product over `s : Finset Œ±` is the same as multiplying the value on a single element\n`f a` by the product of `s.erase a`.\n\nSee `Multiset.prod_map_erase` for the `Multiset` version. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : DecidableEq Œ±] {p : (a : Finset Œ±) ‚Üí Prop} (s : Finset Œ±) (h0 : p ‚àÖ)\n  (step : ‚àÄ (a : Œ±) (s : Finset Œ±) (a_1 : ‚àÄ (x : Œ±) (a_1 : x ‚àà s), a < x) (a_2 : p s), p (insert a s)), p s","name":"Finset.induction_on_min","isProp":true,"docString":"Induction principle for `Finset`s in a linearly ordered type: a predicate is true on all\n`s : Finset Œ±` provided that:\n\n* it is true on the empty `Finset`,\n* for every `s : Finset Œ±` and an element `a` strictly less than all elements of `s`, `p s`\n  implies `p (insert a s)`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N] {f : M ‚Üí+ N}\n  (hf : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëf ‚Üëy)) {y : { x : M // x ‚àà S }} {z : { x : M // x ‚àà S }}\n  (h :\n    -‚Üë(IsAddUnit.liftRight (AddMonoidHom.restrict f S) hf) y =\n      -‚Üë(IsAddUnit.liftRight (AddMonoidHom.restrict f S) hf) z),\n  ‚Üëf ‚Üëy = ‚Üëf ‚Üëz","name":"AddSubmonoid.LocalizationMap.neg_inj","isProp":true,"docString":"Given an AddMonoidHom `f : M ‚Üí+ N` and Submonoid `S ‚äÜ M` such that\n`f(S) ‚äÜ AddUnits N`, for all `y, z ‚àà S`, we have `- (f y) = - (f z) ‚Üí f y = f z`."},{"type":"‚àÄ {Œ± : Type u_1} {s : Set (Setoid Œ±)}, sup‚Çõ s = EqvGen.Setoid (sup‚Çõ (Setoid.Rel '' s))","name":"Setoid.sup‚Çõ_def","isProp":true,"docString":"The supremum of a set of equivalence relations is the equivalence closure of the\nsupremum of the set's image under the map to the underlying binary operation. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [self : IsUpperModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚äì b ‚ãñ a), b ‚ãñ a ‚äî b","name":"IsUpperModularLattice.covby_sup_of_inf_covby","isProp":true,"docString":"`a ‚äî b` covers `a` and `b` if either `a` or `b` covers `a ‚äì b` "},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ] (Œ≥ : Œì‚ÇÄÀ£), Set.Iio ‚ÜëŒ≥ ‚àà nhds 0","name":"WithZeroTopology.nhds_zero_of_units","isProp":true,"docString":"If `Œ≥` is an invertible element of a linearly ordered group with zero element adjoined, then\n`Iio (Œ≥ : Œì‚ÇÄ)` is a neighbourhood of `0`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {l : Filter Œ±} {a : Œ±} (a_1 : IsExtrFilter f l a),\n  IsExtrFilter (‚ÜëOrderDual.toDual ‚àò f) l a","name":"IsExtrFilter.dual","isProp":true,"docString":"**Alias** of the reverse direction of `isExtrFilter_dual_iff`."},{"type":"‚àÄ {Œ± : Type u} {f : Filter Œ±} {g : Filter Œ±} (h : ‚àÄ (s : Set Œ±), (s·∂ú ‚àà f : Prop) ‚Üî (s·∂ú ‚àà g : Prop)), f = g","name":"Filter.coext","isProp":true,"docString":"An extensionality lemma that is useful for filters with good lemmas about `s·∂ú ‚àà f` (e.g.,\n`Filter.comap`, `Filter.coprod`, `Filter.Coprod`, `Filter.cofinite`). "},{"type":"‚àÄ {Œ± : Type u_4} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {s : Set Œ±} {t : Set Œ≤}\n  {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_left_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), f (g a) b = g' (f' b a)), Set.image2 f (g '' s) t = g' '' Set.image2 f' t s","name":"Set.image2_image_left_anticomm","isProp":true,"docString":"Symmetric statement to `Set.image_image2_antidistrib_left`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±·µí·µà} (a_1 : IsMin a), IsMax (‚ÜëOrderDual.ofDual a)","name":"IsMin.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `isMax_ofDual_iff`."},{"type":"‚àÄ {œÑ : Type u_1} {Œ± : Type u_2} [inst : CanonicallyOrderedAddMonoid œÑ] {œï : (a : œÑ) ‚Üí (a : Œ±) ‚Üí Œ±} {s : Set Œ±},\n  (IsFwInvariant œï s : Prop) ‚Üî (IsInvariant œï s : Prop)","name":"isFwInvariant_iff_isInvariant","isProp":true,"docString":"If `œÑ` is a `CanonicallyOrderedAddMonoid` (e.g., `‚Ñï` or `‚Ñù‚â•0`), then the notions\n`IsFwInvariant` and `IsInvariant` are equivalent. "},{"type":"‚àÄ {M : Type u_2} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_4} [inst_1 : CommMonoid N] {P : Type u_3}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P} {T : Submonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_1} [inst_3 : CommMonoid Q]\n  {k : Submonoid.LocalizationMap T Q} (z : N),\n  ‚Üë(Submonoid.LocalizationMap.toMap k) (‚Üëg ‚Üë(Prod.snd (Submonoid.LocalizationMap.sec f z))) *\n      ‚Üë(Submonoid.LocalizationMap.map f hy k) z =\n    ‚Üë(Submonoid.LocalizationMap.toMap k) (‚Üëg (Prod.fst (Submonoid.LocalizationMap.sec f z)))","name":"Submonoid.LocalizationMap.map_mul_left","isProp":true,"docString":"Given Localization maps `f : M ‚Üí* N, k : P ‚Üí* Q` for Submonoids `S, T` respectively, if a\n`CommMonoid` homomorphism `g : M ‚Üí* P` induces a `f.map hy k : N ‚Üí* Q`, then for all `z : N`,\nwe have `k (g y) * f.map hy k z = k (g x)` where `x : M, y ‚àà S` are such that\n`z * f y = f x`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [self : MulActionWithZero R M] (r : R),\n  r ‚Ä¢ 0 = 0","name":"MulActionWithZero.smul_zero","isProp":true,"docString":"Scalar multiplication by any element send `0` to `0`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {a : Œ±} (hf : MonotoneOn f s) (hs : s ‚àà nhdsWithin a (Set.Iic a))\n  (hfs : ‚àÄ (b : Œ≤) (a_1 : b < f a), ‚àÉ (c : Œ±), (c ‚àà s : Prop) ‚àß (f c ‚àà Set.Ioo b (f a) : Prop)),\n  ContinuousWithinAt f (Set.Iic a) a","name":"continuousWithinAt_left_of_monotoneOn_of_exists_between","isProp":true,"docString":"If `f` is a monotone function on a left neighborhood of `a` and the image of this neighborhood\nunder `f` meets every interval `(b, f a)`, `b < f a`, then `f` is continuous at `a` from the left.\n\nThe assumption `hfs : ‚àÄ b < f a, ‚àÉ c ‚àà s, f c ‚àà Ioo b (f a)` cannot be replaced by the weaker\nassumption `hfs : ‚àÄ b < f a, ‚àÉ c ‚àà s, f c ‚àà Ico b (f a)` we use for strictly monotone functions\nbecause otherwise the function `floor : ‚Ñù ‚Üí ‚Ñ§` would be a counter-example at `a = 0`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b), Set.Iio a ‚äÜ Set.Iic b","name":"Set.Iio_subset_Iic","isProp":true,"docString":"If `a ‚â§ b`, then `(-‚àû, a) ‚äÜ (-‚àû, b]`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Iio_subset_Iic_iff`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : Setoid Œ±} (f : (a : Œ±) ‚Üí Œ≤)\n  (H : ‚àÄ (x : Œ±) (y : Œ±) (a : Setoid.Rel r x y), f x = f y) (h : Function.Injective (Quotient.lift f H)),\n  Setoid.ker f = r","name":"Setoid.ker_eq_lift_of_injective","isProp":true,"docString":"Given a map f from Œ± to Œ≤, the kernel of f is the unique equivalence relation on Œ± whose\ninduced map from the quotient of Œ± to Œ≤ is injective. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {l : Filter Œ±} {a : Œ±} (a_1 : IsMaxFilter f l a),\n  IsMinFilter (‚ÜëOrderDual.toDual ‚àò f) l a","name":"IsMaxFilter.dual","isProp":true,"docString":"**Alias** of the reverse direction of `isMinFilter_dual_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : IsWeakUpperModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚äì b ‚ãñ a)\n  (a_2 : a ‚äì b ‚ãñ b), a ‚ãñ a ‚äî b","name":"Covby.sup_of_inf_of_inf_left","isProp":true,"docString":"**Alias** of `covby_sup_of_inf_covby_of_inf_covby_left`."},{"type":"‚àÄ {a : Cardinal} {b : Cardinal} (ha : Cardinal.aleph0 ‚â§ a) (hb : Cardinal.aleph0 ‚â§ b), a * b = max a b","name":"Cardinal.mul_eq_max","isProp":true,"docString":"If `Œ±` and `Œ≤` are infinite types, then the cardinality of `Œ± √ó Œ≤` is the maximum\nof the cardinalities of `Œ±` and `Œ≤`. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M}, s ‚äÜ Monoid.Closure s","name":"Monoid.subset_closure","isProp":true,"docString":"A subset of a monoid is contained in the submonoid it generates. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : StrictAnti f),\n  StrictMono (‚ÜëOrderDual.toDual ‚àò f)","name":"StrictAnti.dual_right","isProp":true,"docString":"**Alias** of the reverse direction of `strictMono_toDual_comp_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Monotone f) {x : Œ±}\n  [inst_4 : TopologicalSpace Œ±] [inst_5 : OrderTopology Œ±],\n  (ContinuousAt f x : Prop) ‚Üî (Function.leftLim f x = Function.rightLim f x : Prop)","name":"Monotone.continuousAt_iff_leftLim_eq_rightLim","isProp":true,"docString":"A monotone function is continuous at a point if and only if its left and right limits\ncoincide. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} {s : Set Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ≥}\n  (hf : LowerSemicontinuousWithinAt f s x) (hg : LowerSemicontinuousWithinAt g s x)\n  (hcont : ContinuousAt (fun (p : Œ≥ √ó Œ≥) ‚Ü¶ Prod.fst p + Prod.snd p) (f x, g x)),\n  LowerSemicontinuousWithinAt (fun (z : Œ±) ‚Ü¶ f z + g z) s x","name":"LowerSemicontinuousWithinAt.add'","isProp":true,"docString":"The sum of two lower semicontinuous functions is lower semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. "},{"type":"‚àÄ {I : Type v‚ÇÅ} {C : (a : I) ‚Üí Type u‚ÇÅ} [inst : (i : I) ‚Üí CategoryTheory.Category (C i)] {J : Type v‚ÇÅ}\n  [inst_1 : CategoryTheory.SmallCategory J] {F : J ‚•§ ((i : I) ‚Üí C i)}\n  [inst_2 : ‚àÄ (i : I), CategoryTheory.Limits.HasColimit (F ‚ãô CategoryTheory.Pi.eval C i)],\n  CategoryTheory.Limits.HasColimit F","name":"CategoryTheory.pi.hasColimit_of_hasColimit_comp_eval","isProp":true,"docString":"If we have a functor `F : J ‚•§ Œ† i, C i` into a category of indexed families,\nand colimits exist for each of the `F ‚ãô Pi.eval C i`,\nthere is a colimit for `F`.\n"},{"type":"‚àÄ {Œ± : Type uu} [inst : DecidableEq Œ±] {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±},\n  (l‚ÇÅ <+~ l‚ÇÇ : Prop) ‚Üî (‚àÄ (x : Œ±) (a : x ‚àà l‚ÇÅ), List.count x l‚ÇÅ ‚â§ List.count x l‚ÇÇ : Prop)","name":"List.subperm_ext_iff","isProp":true,"docString":"The list version of `Multiset.le_iff_count`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {a : R} {b : R} [inst : CommSemigroup R] [inst_1 : SMul R M]\n  [inst_2 : IsScalarTower R R M],\n  (IsSMulRegular M (a * b) : Prop) ‚Üî ((IsSMulRegular M a : Prop) ‚àß (IsSMulRegular M b : Prop) : Prop)","name":"IsSMulRegular.mul_iff","isProp":true,"docString":"A product is `M`-regular if and only if the factors are. "},{"type":"‚àÄ (a : Ordinal), Ordinal.lift a = a","name":"Ordinal.lift_id'","isProp":true,"docString":"An ordinal lifted to a lower or equal universe equals itself. "},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : Type u_1} {s : (a : Œπ) ‚Üí Set Œ±} (hs : IndexedPartition s) (x : Œ±),\n  ‚Üë(IndexedPartition.out hs) (IndexedPartition.proj hs x) = IndexedPartition.some hs (IndexedPartition.index hs x)","name":"IndexedPartition.out_proj","isProp":true,"docString":"This lemma is analogous to `Quotient.mk_out'`. "},{"type":"‚àÄ {H : Type u_1} [inst : TopologicalSpace H] {x : H}, chartAt x = LocalHomeomorph.refl H","name":"chartAt_self_eq","isProp":true,"docString":"In the model space, `chartAt` is always the identity. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} {s : Set Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ≥}\n  (hf : UpperSemicontinuousWithinAt f s x) (hg : UpperSemicontinuousWithinAt g s x)\n  (hcont : ContinuousAt (fun (p : Œ≥ √ó Œ≥) ‚Ü¶ Prod.fst p + Prod.snd p) (f x, g x)),\n  UpperSemicontinuousWithinAt (fun (z : Œ±) ‚Ü¶ f z + g z) s x","name":"UpperSemicontinuousWithinAt.add'","isProp":true,"docString":"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 ‚â§ a) (hb : 1 < b), 1 < a * b","name":"Left.one_lt_mul_of_le_of_lt","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul_of_le_of_lt`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedSemifield Œ±] (a : Œ±), LinearOrderedSemifield.zpow 0 a = 1","name":"LinearOrderedSemifield.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {m‚ÇÅ : MeasurableSpace Œ±} {m‚ÇÇ : MeasurableSpace Œ≤} {f : (a : Œ±) ‚Üí Œ≤} (a : Measurable f),\n  m‚ÇÇ ‚â§ MeasurableSpace.map f m‚ÇÅ","name":"Measurable.le_map","isProp":true,"docString":"**Alias** of the forward direction of `measurable_iff_le_map`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] (x : (i : Œπ) ‚Üí Œ≤ i)\n  (y : (i : Œπ) ‚Üí Œ≤ i), hammingDist x y = hammingDist y x","name":"hammingDist_comm","isProp":true,"docString":"Corresponds to `dist_comm`. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R], (IsLeftRegular 0 : Prop) ‚Üî (Subsingleton R : Prop)","name":"isLeftRegular_zero_iff_subsingleton","isProp":true,"docString":"The element `0` is left-regular if and only if `R` is trivial. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G],\n  (NormalizerCondition G : Prop) ‚Üî (‚àÄ (H : Subgroup G) (a : Subgroup.normalizer H = H), H = ‚ä§ : Prop)","name":"normalizerCondition_iff_only_full_group_self_normalizing","isProp":true,"docString":"Alternative phrasing of the normalizer condition: Only the full group is self-normalizing.\nThis may be easier to work with, as it avoids inequalities and negations.  "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {s : Set M} {t : Set M} (h : s ‚äÜ t), AddMonoid.Closure s ‚äÜ AddMonoid.Closure t","name":"AddMonoid.closure_mono","isProp":true,"docString":"Given subsets `t` and `s` of an `AddMonoid M`, if `s ‚äÜ t`, the `AddSubmonoid`\nof `M` generated by `s` is contained in the `AddSubmonoid` generated by `t`."},{"type":"‚àÄ {R : Type u} [self : AddCommGroupWithOne R], NatCast.natCast 0 = 0","name":"AddCommGroupWithOne.natCast_zero","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` sends `0 : ‚Ñï` to `0 : R`. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {s : Set R}, s ‚äÜ ‚Üë(Subring.closure s)","name":"Subring.subset_closure","isProp":true,"docString":"The subring generated by a set includes the set. "},{"type":"‚àÄ {Œ± : Type u} [inst : Mul Œ±] [inst_1 : One Œ±] {a : Œ±} [self : Invertible a], ‚Öüa * a = 1","name":"Invertible.invOf_mul_self","isProp":true,"docString":"`invOf a` is a left inverse of `a` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : SemilatticeSup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (hf : MonotoneOn f s) (hg : MonotoneOn g s), MonotoneOn (f ‚äî g) s","name":"MonotoneOn.sup","isProp":true,"docString":"Pointwise supremum of two monotone functions is a monotone function. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : SemilatticeInf Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (hf : AntitoneOn f s) (hg : AntitoneOn g s), AntitoneOn (f ‚äì g) s","name":"AntitoneOn.inf","isProp":true,"docString":"Pointwise infimum of two antitone functions is a antitone function. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f x y), Equiv.Perm.SameCycle f‚Åª¬π x y","name":"Equiv.Perm.SameCycle.inv","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_inv`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : TotallySeparatedSpace Œ±], IsTotallySeparated Set.univ","name":"TotallySeparatedSpace.isTotallySeparated_univ","isProp":true,"docString":"The universal set `Set.univ` in a totally separated space is totally separated. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {x : Œ±} {s : Set Œ±},\n  (ClusterPt x (Filter.principal s) : Prop) ‚Üî (‚àÄ (U : Set Œ±) (a : U ‚àà nhds x), Set.Nonempty (U ‚à© s) : Prop)","name":"clusterPt_principal_iff","isProp":true,"docString":"`x` is a cluster point of a set `s` if every neighbourhood of `x` meets `s` on a nonempty\nset. See also `mem_closure_iff_clusterPt`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} {Œπ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : LinearOrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} {t : Finset Œπ} {w : (a : Œπ) ‚Üí ùïú} {p : (a : Œπ) ‚Üí E} (h : ConvexOn ùïú s f)\n  (hw‚ÇÄ : ‚àÄ (i : Œπ) (a : i ‚àà t), 0 ‚â§ w i) (hw‚ÇÅ : 0 < Finset.sum t fun (i : Œπ) ‚Ü¶ w i)\n  (hp : ‚àÄ (i : Œπ) (a : i ‚àà t), p i ‚àà s), ‚àÉ (i : Œπ), (i ‚àà t : Prop) ‚àß (f (Finset.centerMass t w p) ‚â§ f (p i) : Prop)","name":"ConvexOn.exists_ge_of_centerMass","isProp":true,"docString":"If a function `f` is convex on `s`, then the value it takes at some center of mass of points of\n`s` is less than the value it takes on one of those points. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : r < 0),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atTop : Prop) ‚Üî (Filter.Tendsto f l Filter.atBot : Prop)","name":"Filter.tendsto_mul_const_atTop_of_neg","isProp":true,"docString":"If `r` is a negative constant, then `Œª x, f x * r` tends to infinity along a filter if and only\nif `f` tends to negative infinity along the same filter. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] ‚¶És : Set R‚¶Ñ ‚¶Ét : Set R‚¶Ñ (h : s ‚äÜ t), Subring.closure s ‚â§ Subring.closure t","name":"Subring.closure_mono","isProp":true,"docString":"Subring closure of a set is monotone in its argument: if `s ‚äÜ t`,\nthen `closure s ‚â§ closure t`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : Countable Œπ] [t : TopologicalSpace Œ±] [p : PolishSpace Œ±]\n  (m : (a : Œπ) ‚Üí TopologicalSpace Œ±) (hm : ‚àÄ (n : Œπ), m n ‚â§ t) (h'm : ‚àÄ (n : Œπ), PolishSpace Œ±),\n  ‚àÉ (t' : TopologicalSpace Œ±), (‚àÄ (n : Œπ), t' ‚â§ m n : Prop) ‚àß ((t' ‚â§ t : Prop) ‚àß (PolishSpace Œ± : Prop) : Prop)","name":"PolishSpace.exists_polishSpace_forall_le","isProp":true,"docString":"Given a Polish space, and countably many finer Polish topologies, there exists another Polish\ntopology which is finer than all of them.\n\nPorting note: TODO: the topology `t'` is `t ‚äì ‚®Ö i, m i`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {P : C} {Q : C}\n  (self : CategoryTheory.Limits.BinaryBicone P Q),\n  CategoryTheory.Limits.BinaryBicone.inl self ‚â´ CategoryTheory.Limits.BinaryBicone.snd self = 0","name":"CategoryTheory.Limits.BinaryBicone.inl_snd","isProp":true,"docString":"A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ‚â´ fst = ùüô P`, `inl ‚â´ snd = 0`, `inr ‚â´ fst = 0`, and `inr ‚â´ snd = ùüô Q`\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] {f : Filter Œ≤} {g : (a : Œ≤) ‚Üí Œ±}\n  (h : ‚àÉ (a : Œ±), Filter.Tendsto g f (nhds a)), Filter.Tendsto g f (nhds (limUnder f g))","name":"tendsto_nhds_limUnder","isProp":true,"docString":"If `g` tends to some `ùìù a` along `f`, then it tends to `ùìù (Filter.limUnder f g)`. We formulate\nthis lemma with a `[Nonempty Œ±]` argument of `lim` derived from `h` to make it useful for types\nwithout a `[Nonempty Œ±]` instance. Because of the built-in proof irrelevance, Lean will unify this\ninstance with any other instance. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : ContinuousAdd Œ±] [inst_3 : RegularSpace Œ±] {f : (a : Œ≤ √ó Œ≥) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {a : Œ±} (ha : HasSum f a)\n  (hf : ‚àÄ (b : Œ≤), HasSum (fun (c : Œ≥) ‚Ü¶ f (b, c)) (g b)), HasSum g a","name":"HasSum.prod_fiberwise","isProp":true,"docString":"If a series `f` on `Œ≤ √ó Œ≥` has sum `a` and for each `b` the restriction of `f` to `{b} √ó Œ≥`\nhas sum `g b`, then the series `g` has sum `a`. "},{"type":"‚àÄ {Œπ‚ÇÅ : Type u_5} {Œπ‚ÇÇ : Type u_6} {R : Type u_1} {M‚Çó : Type u_2} {N‚Çó : Type u_4} {P‚Çó : Type u_3} [inst : CommSemiring R]\n  [inst_1 : AddCommMonoid M‚Çó] [inst_2 : AddCommMonoid N‚Çó] [inst_3 : AddCommMonoid P‚Çó] [inst_4 : Module R M‚Çó]\n  [inst_5 : Module R N‚Çó] [inst_6 : Module R P‚Çó] (b‚ÇÅ' : Basis Œπ‚ÇÅ R M‚Çó) (b‚ÇÇ' : Basis Œπ‚ÇÇ R N‚Çó) {B : M‚Çó ‚Üí‚Çó[R] N‚Çó ‚Üí‚Çó[R] P‚Çó}\n  (x : M‚Çó) (y : N‚Çó),\n  (Finsupp.sum (‚Üë(Basis.repr b‚ÇÅ') x) fun (i : Œπ‚ÇÅ) (xi : R) ‚Ü¶\n      Finsupp.sum (‚Üë(Basis.repr b‚ÇÇ') y) fun (j : Œπ‚ÇÇ) (yj : R) ‚Ü¶ xi ‚Ä¢ yj ‚Ä¢ ‚Üë(‚ÜëB (‚Üëb‚ÇÅ' i)) (‚Üëb‚ÇÇ' j)) =\n    ‚Üë(‚ÜëB x) y","name":"LinearMap.sum_repr_mul_repr_mul","isProp":true,"docString":"Write out `B x y` as a sum over `B (b i) (b j)` if `b` is a basis.\n\nVersion for bilinear maps, see `sum_repr_mul_repr_mul‚Çõ‚Çó` for the semi-bilinear version. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddCommGroup G] [inst_1 : AddTorsor G P] (p1 : P) (p2 : P) (p3 : P),\n  p3 -·µ• p2 - (p3 -·µ• p1) = p1 -·µ• p2","name":"vsub_sub_vsub_cancel_left","isProp":true,"docString":"Cancellation subtracting the results of two subtractions. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : ‚Ñù}, EMetric.ball x (ENNReal.ofReal Œµ) = Metric.ball x Œµ","name":"Metric.emetric_ball","isProp":true,"docString":"Balls defined using the distance or the edistance coincide "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ≤ : Type u_1} {p : (a : Œ≤) ‚Üí Prop} {f : (a : Œ≤) ‚Üí ENNReal}\n  (hf‚ÇÄ : ‚àÄ (x : Œ≤) (a : p x), 0 < f x) (hf : ‚àÄ (Œµ : ENNReal) (a : 0 < Œµ), ‚àÉ (x : Œ≤), (p x : Prop) ‚àß (f x ‚â§ Œµ : Prop)),\n  Filter.HasBasis (uniformity Œ±) p fun (x : Œ≤) ‚Ü¶ setOf fun (p : Œ± √ó Œ±) ‚Ü¶ edist (Prod.fst p) (Prod.snd p) < f x","name":"EMetric.mk_uniformity_basis","isProp":true,"docString":"Given `f : Œ≤ ‚Üí ‚Ñù‚â•0‚àû`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `ùì§ Œ±`.\n\nFor specific bases see `uniformity_basis_edist`, `uniformity_basis_edist'`,\n`uniformity_basis_edist_nnreal`, and `uniformity_basis_edist_inv_nat`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} [self : CategoryTheory.RegularMono f],\n  f ‚â´ CategoryTheory.RegularMono.left = f ‚â´ CategoryTheory.RegularMono.right","name":"CategoryTheory.RegularMono.w","isProp":true,"docString":"`f` equalizes the two maps "},{"type":"‚àÄ {B : Type u_2} {F : Type u_1} {Z : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  [inst_2 : TopologicalSpace Z] {proj : (a : Z) ‚Üí B} [inst_3 : Nonempty F]\n  (h : IsHomeomorphicTrivialFiberBundle F proj), QuotientMap proj","name":"IsHomeomorphicTrivialFiberBundle.quotientMap_proj","isProp":true,"docString":"The projection from a trivial fiber bundle to its base is open. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {f : (a : Œ±) ‚Üí ENNReal},\n  ((Finset.sum s fun (x : Œ±) ‚Ü¶ f x) = ‚ä§ : Prop) ‚Üî (‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (f a = ‚ä§ : Prop) : Prop)","name":"ENNReal.sum_eq_top_iff","isProp":true,"docString":"A sum of numbers is infinite iff one of them is infinite "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {t : Finset Œ±} (a : Finset.Nonempty (s ‚à© t)),\n  ¬¨(Disjoint s t : Prop)","name":"Finset.Nonempty.not_disjoint","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.not_disjoint_iff_nonempty_inter`."},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} (a_1 : a - c < b), a < b + c","name":"lt_add_of_sub_right_lt","isProp":true,"docString":"**Alias** of the forward direction of `sub_lt_iff_lt_add`."},{"type":"‚àÄ {ùïú : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {C : ùïú} (hC : 0 < C) (hf : Filter.Tendsto f l Filter.atTop)\n  (hg : Filter.Tendsto g l (nhds C)), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * g x) l Filter.atTop","name":"Filter.Tendsto.atTop_mul","isProp":true,"docString":"In a linearly ordered field with the order topology, if `f` tends to `Filter.atTop` and `g`\ntends to a positive constant `C` then `f * g` tends to `Filter.atTop`. "},{"type":"‚àÄ (r : ‚Ñï) (n : ‚Ñï), Nat.choose n r ‚â§ Nat.choose n (n / 2)","name":"Nat.choose_le_middle","isProp":true,"docString":"`choose n r` is maximised when `r` is `n/2`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] (t : Multiset Œπ) (f : (a : Œπ) ‚Üí Set Œ±) (g : (a : Œπ) ‚Üí Œ±)\n  (hg : ‚àÄ (i : Œπ) (a : i ‚àà t), g i ‚àà f i), Multiset.prod (Multiset.map g t) ‚àà Multiset.prod (Multiset.map f t)","name":"Set.multiset_prod_mem_multiset_prod","isProp":true,"docString":"An n-ary version of `Set.mul_mem_mul`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (ha : 1 < a) (hb : 1 < b), 1 < a * b","name":"Right.one_lt_mul","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : Fintype Œ±] [inst_1 : Fintype Œ≤] [inst_2 : AddCommMonoid M]\n  (e : (a : Œ±) ‚Üí Œ≤) (he : Function.Bijective e) (f : (a : Œ±) ‚Üí M) (g : (a : Œ≤) ‚Üí M) (h : ‚àÄ (x : Œ±), f x = g (e x)),\n  (Finset.sum Finset.univ fun (x : Œ±) ‚Ü¶ f x) = Finset.sum Finset.univ fun (x : Œ≤) ‚Ü¶ g x","name":"Fintype.sum_bijective","isProp":true,"docString":"`Fintype.sum_equiv` is a variant of `Finset.sum_bij` that accepts\n`Function.bijective`.\n\nSee `Function.bijective.sum_comp` for a version without `h`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : Semigroup Œ±] [inst_2 : LeftDistribClass Œ±] {a : Œ±} {b : Œ±} {c : Œ±}\n  (h‚ÇÅ : a ‚à£ b) (h‚ÇÇ : a ‚à£ c), a ‚à£ b + c","name":"Dvd.dvd.add","isProp":true,"docString":"**Alias** of `dvd_add`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤]\n  [inst_2 : PseudoEMetricSpace Œ≥] {g : (a : Œ≤) ‚Üí Œ≥} {f : (a : Œ±) ‚Üí Œ≤} (hg : Isometry g) (hf : Isometry f),\n  Isometry (g ‚àò f)","name":"Isometry.comp","isProp":true,"docString":"The composition of isometries is an isometry. "},{"type":"‚àÄ {p : ‚Ñï} (hp : 1 < p), padicValRat p ‚Üëp = 1","name":"padicValRat.self","isProp":true,"docString":"If `p ‚â† 0` and `p ‚â† 1`, then `padicValRat p p` is `1`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {f : (a : Œ±) ‚Üí Œ±} {p : (a : Œ±) ‚Üí Prop} {hf : ‚àÄ (x : Œ±), x ‚â§ f x}\n  {hfp : ‚àÄ (x : Œ±), p (f x)} {hmin : ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : x ‚â§ y) (a : p y), f x ‚â§ y} {x : Œ±} {y : Œ±} (hxy : x ‚â§ y)\n  (hy : p y), ‚Üë(ClosureOperator.toOrderHom (ClosureOperator.mk‚ÇÉ f p hf hfp hmin)) x ‚â§ y","name":"ClosureOperator.closure_le_mk‚ÇÉ_iff","isProp":true,"docString":"Analogue of `closure_le_closed_iff_le` but with the `p` that was fed into the `mk‚ÇÉ` constructor.\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Antivary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i) < Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i : Prop) ‚Üî\n    (¬¨(Antivary (f ‚àò ‚ÜëœÉ) g : Prop) : Prop)","name":"Antivary.sum_mul_lt_sum_comp_perm_mul_iff","isProp":true,"docString":"**Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f ‚àò œÉ` and `g` do not antivary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x : V // x ‚àà S }","name":"FiniteDimensional.finiteDimensional_submodule","isProp":true,"docString":"A subspace of a finite-dimensional space is also finite-dimensional. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] [inst_1 : NoZeroDivisors R] {p‚ÇÅ : Polynomial R} {p‚ÇÇ : Polynomial R}\n  {q‚ÇÅ : Polynomial R} {q‚ÇÇ : Polynomial R} (hp‚ÇÅ : p‚ÇÅ ‚â† 0) (hq‚ÇÅ : q‚ÇÅ ‚â† 0) (hp‚ÇÇ : p‚ÇÇ ‚â† 0) (hq‚ÇÇ : q‚ÇÇ ‚â† 0)\n  (h_eq : p‚ÇÅ * q‚ÇÇ = p‚ÇÇ * q‚ÇÅ),\n  ‚Üë(Polynomial.natDegree p‚ÇÅ) - ‚Üë(Polynomial.natDegree q‚ÇÅ) = ‚Üë(Polynomial.natDegree p‚ÇÇ) - ‚Üë(Polynomial.natDegree q‚ÇÇ)","name":"Polynomial.natDegree_sub_eq_of_prod_eq","isProp":true,"docString":"This lemma is useful for working with the `intDegree` of a rational function. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : List Œ±) (r : List Œ≤) (ys : List Œ±) (f : (a : List Œ±) ‚Üí Œ≤),\n  Prod.snd (List.permutationsAux2 t ts r ys f) =\n    List.map (fun (x : List Œ±) ‚Ü¶ f (x ++ ts)) (Prod.snd (List.permutationsAux2 t [] [] ys id)) ++ r","name":"List.permutationsAux2_snd_eq","isProp":true,"docString":"An expository lemma to show how all of `ts`, `r`, and `f` can be eliminated from\n`permutationsAux2`.\n\n`(permutationsAux2 t [] [] ys id).2`, which appears on the RHS, is a list whose elements are\nproduced by inserting `t` into every non-terminal position of `ys` in order. As an example:\n```lean\n#eval permutationsAux2 1 [] [] [2, 3, 4] id\n-- [[1, 2, 3, 4], [2, 1, 3, 4], [2, 3, 1, 4]]\n```\n"},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ], OrderClosedTopology Œì‚ÇÄ","name":"WithZeroTopology.orderClosedTopology","isProp":true,"docString":"The topology on a linearly ordered group with zero element adjoined is compatible with the order\nstructure: the set `{p : Œì‚ÇÄ √ó Œì‚ÇÄ | p.1 ‚â§ p.2}` is closed. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R} (hp : p ‚â† 0) (s : Multiset R),\n  (Multiset.prod (Multiset.map (fun (a : R) ‚Ü¶ Polynomial.X - ‚ÜëPolynomial.C a) s) ‚à£ p : Prop) ‚Üî\n    (s ‚â§ Polynomial.roots p : Prop)","name":"Multiset.prod_X_sub_C_dvd_iff_le_roots","isProp":true,"docString":"A Galois connection. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} [inst : NonUnitalNonAssocSemiring Œ±] [self : CentroidHomClass F Œ±] (f : F)\n  (a : Œ±) (b : Œ±), ‚Üëf (a * b) = a * ‚Üëf b","name":"CentroidHomClass.map_mul_left","isProp":true,"docString":"Commutativity of centroid homomorphims with left multiplication. "},{"type":"‚àÄ (k : Type u_3) {P‚ÇÅ : Type u_2} {V‚ÇÅ : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V‚ÇÅ] [inst_2 : Module k V‚ÇÅ]\n  [inst_3 : AddTorsor V‚ÇÅ P‚ÇÅ] {x : P‚ÇÅ} {y : P‚ÇÅ} (h : Function.Injective bit0),\n  (‚Üë(AffineEquiv.pointReflection k x) y = y : Prop) ‚Üî (y = x : Prop)","name":"AffineEquiv.pointReflection_fixed_iff_of_injective_bit0","isProp":true,"docString":"`x` is the only fixed point of `pointReflection x`. This lemma requires\n`x + x = y + y ‚Üî x = y`. There is no typeclass to use here, so we add it as an explicit argument. "},{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f‚ÇÄ : C(X, Y)} {f‚ÇÅ : C(X, Y)}\n  {P : (a : C(X, Y)) ‚Üí Prop} (self : ContinuousMap.HomotopyWith f‚ÇÄ f‚ÇÅ P) (t : ‚ÜëunitInterval),\n  P\n    (ContinuousMap.mk fun (x : X) ‚Ü¶\n      ContinuousMap.toFun (ContinuousMap.Homotopy.toContinuousMap (ContinuousMap.HomotopyWith.toHomotopy self)) (t, x))","name":"ContinuousMap.HomotopyWith.prop'","isProp":true,"docString":"the intermediate maps of the homotopy satisfy the property "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (c : Con M) (f : M ‚Üí* P)\n  (H : c ‚â§ Con.ker f) (h : Function.Injective ‚Üë(Con.lift c f H)), Con.ker f = c","name":"Con.ker_eq_lift_of_injective","isProp":true,"docString":"Given a monoid homomorphism `f` from `M` to `P`, the kernel of `f` is the unique congruence\nrelation on `M` whose induced map from the quotient of `M` to `P` is injective. "},{"type":"‚àÄ {a : ‚Ñï} {p : ‚Ñï} {k : ‚Ñï} (pp : Nat.Prime p) (h‚ÇÅ : ¬¨(a ‚à£ p ^ k : Prop)) (h‚ÇÇ : a ‚à£ p ^ (k + 1)), a = p ^ (k + 1)","name":"Nat.eq_prime_pow_of_dvd_least_prime_pow","isProp":true,"docString":"If `p` is prime,\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\nthen `a = p^(k+1)`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : PredOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a < b), a ‚â§ PredOrder.pred b","name":"PredOrder.le_pred_of_lt","isProp":true,"docString":"Proof that `pred` satifies ordering invariants betweeen `LT` and `LE`"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Membership Œ± Œ≤] {s : Œ≤} {t : Œ≤} {a : Œ±} (h : a ‚àà s) (a : ¬¨(a ‚àà t : Prop)), s ‚â† t","name":"Membership.mem.ne_of_not_mem'","isProp":true,"docString":"**Alias** of `ne_of_mem_of_not_mem'`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (rŒ± : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) (rŒ≤ : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop),\n  Prod.GameAdd rŒ± rŒ≤ ‚â§ Prod.Lex rŒ± rŒ≤","name":"Prod.gameAdd_le_lex","isProp":true,"docString":"`Prod.GameAdd` is a subrelation of `Prod.Lex`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonUnitalRing Œ±] (a : Œ±) (b : Œ±) (c : Œ±), a * b * c = a * (b * c)","name":"NonUnitalRing.mul_assoc","isProp":true,"docString":"Multiplication is associative "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set (Set Œ±)}\n  (hs : TopologicalSpace.IsTopologicalBasis s) {t : Set (Set Œ≤)} (ht : TopologicalSpace.IsTopologicalBasis t),\n  TopologicalSpace.IsTopologicalBasis ((fun (u : Set Œ±) ‚Ü¶ Sum.inl '' u) '' s ‚à™ (fun (u : Set Œ≤) ‚Ü¶ Sum.inr '' u) '' t)","name":"TopologicalSpace.IsTopologicalBasis.sum","isProp":true,"docString":"In a sum space `Œ± ‚äï Œ≤`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} {L‚ÇÉ : List (Œ± √ó Bool)} (a : FreeAddGroup.Red L‚ÇÅ L‚ÇÇ)\n  (a : FreeAddGroup.Red L‚ÇÅ L‚ÇÉ), Relation.Join FreeAddGroup.Red L‚ÇÇ L‚ÇÉ","name":"FreeAddGroup.Red.church_rosser","isProp":true,"docString":"**Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\nto `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\nrespectively. This is also known as Newman's diamond lemma."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {s : Set Œ±} {t : Set Œ≤}\n  {f : (a : Œ±) ‚Üí Œ≤} (h : Set.MapsTo f s t) (hc : Continuous f) (ht : IsClosed t), Set.MapsTo f (closure s) t","name":"Set.MapsTo.closure_left","isProp":true,"docString":"If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) {x : M} {y : M} {z : M} (a : ‚Üëc x y) (a : ‚Üëc y z), ‚Üëc x z","name":"Con.trans","isProp":true,"docString":"Congruence relations are transitive. "},{"type":"‚àÄ {v : Sat.Valuation}, Sat.Clause.reify v Sat.Clause.nil (True : Prop)","name":"Sat.Clause.reify_zero","isProp":true,"docString":"The reification of the empty clause is `True`: `¬¨‚ü¶‚ä•‚üß_v ‚â° True`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (f : AddHom M N) (s : Set M),\n  AddSubsemigroup.map f (AddSubsemigroup.closure s) = AddSubsemigroup.closure (‚Üëf '' s)","name":"AddHom.map_mclosure","isProp":true,"docString":"The image under an `AddSemigroup` hom of the `AddSubsemigroup` generated by a set\nequals the `AddSubsemigroup` generated by the image of the set."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (E : Set Œ±),\n  closure E = Set.inter·µ¢ fun (Œ¥ : ‚Ñù) ‚Ü¶ Set.inter·µ¢ fun (_h : 0 < Œ¥) ‚Ü¶ Metric.thickening Œ¥ E","name":"Metric.closure_eq_inter·µ¢_thickening","isProp":true,"docString":"The closure of a set equals the intersection of its (open) thickenings of positive radii. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [inst_1 : ProperSpace Œ±], CompleteSpace Œ±","name":"complete_of_proper","isProp":true,"docString":"A proper space is complete "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : ConditionallyCompleteLattice Œ±] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  (B : BddAbove (Set.range g)) (H : ‚àÄ (x : Œπ), f x ‚â§ g x), sup·µ¢ f ‚â§ sup·µ¢ g","name":"csup·µ¢_mono","isProp":true,"docString":"The indexed supremum of two functions are comparable if the functions are pointwise comparable"},{"type":"‚àÄ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)","name":"OneHom.comp_assoc","isProp":true,"docString":"Composition of monoid homomorphisms is associative. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {p : Prop} {q : Prop} {s : (a : p) ‚Üí (a : q) ‚Üí Œ±},\n  (sup·µ¢ fun (h‚ÇÅ : p) ‚Ü¶ sup·µ¢ fun (h‚ÇÇ : q) ‚Ü¶ s h‚ÇÅ h‚ÇÇ) =\n    sup·µ¢ fun (h : (p : Prop) ‚àß (q : Prop)) ‚Ü¶ s ((And.left h=:p)=:p) ((And.right h=:q)=:q)","name":"sup·µ¢_and'","isProp":true,"docString":"The symmetric case of `sup·µ¢_and`, useful for rewriting into a supremum over a conjunction "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : PreconnectedSpace Œ±], IsPreconnected Set.univ","name":"PreconnectedSpace.isPreconnected_univ","isProp":true,"docString":"The universal set `Set.univ` in a preconnected space is a preconnected set. "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedField R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {x : M}\n  {y : M} (h : SameRay R x y) (hx : x ‚â† 0), ‚àÉ (r : R), (0 ‚â§ r : Prop) ‚àß (r ‚Ä¢ x = y : Prop)","name":"SameRay.exists_nonneg_left","isProp":true,"docString":"If a vector `v‚ÇÇ` is on the same ray as a nonzero vector `v‚ÇÅ`, then it is equal to `c ‚Ä¢ v‚ÇÅ` for\nsome nonnegative `c`. "},{"type":"‚àÄ {M : Type u} [self : AddZeroClass M] (a : M), 0 + a = a","name":"AddZeroClass.zero_add","isProp":true,"docString":"Zero is a left neutral element for addition "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {p : (a : Œ±) ‚Üí Prop} {h : ‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf x) : Prop)}\n  {x : { x : Œ± // p x }} {y : { x : Œ± // p x }} (a : Equiv.Perm.SameCycle f ‚Üëx ‚Üëy),\n  Equiv.Perm.SameCycle (Equiv.Perm.subtypePerm f h) x y","name":"Equiv.Perm.SameCycle.subtypePerm","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_subtypePerm`."},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] [inst_1 : NoZeroDivisors R] (t : Multiset (Polynomial R)),\n  Polynomial.leadingCoeff (Multiset.prod t) =\n    Multiset.prod (Multiset.map (fun (f : Polynomial R) ‚Ü¶ Polynomial.leadingCoeff f) t)","name":"Polynomial.leadingCoeff_multiset_prod","isProp":true,"docString":"The leading coefficient of a product of polynomials is equal to\nthe product of the leading coefficients.\n\nSee `Polynomial.leadingCoeff_multiset_prod'` (with a `'`) for a version for commutative semirings,\nwhere additionally, the product of the leading coefficients must be nonzero.\n"},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±}, (Set.Nonempty s : Prop) ‚Üî (s ‚â† ‚àÖ : Prop)","name":"Set.nonempty_iff_ne_empty","isProp":true,"docString":"See also `Set.not_nonempty_iff_eq_empty`. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  (f : (a : J) ‚Üí C) [inst_2 : CategoryTheory.Limits.HasBiproduct f] {b : CategoryTheory.Limits.Bicone f}\n  (hb : CategoryTheory.Limits.Bicone.IsBilimit b),\n  CategoryTheory.Iso.inv\n      (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso (CategoryTheory.Limits.Bicone.IsBilimit.isLimit hb)\n        (CategoryTheory.Limits.biproduct.isLimit f)) =\n    CategoryTheory.Limits.biproduct.desc (CategoryTheory.Limits.Bicone.Œπ b)","name":"CategoryTheory.Limits.biproduct.conePointUniqueUpToIso_inv","isProp":true,"docString":"Auxiliary lemma for `biproduct.uniqueUpToIso`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop},\n  Function.Injective fun (f : r ‚Üír s) ‚Ü¶ ‚Üëf","name":"RelHom.coe_fn_injective","isProp":true,"docString":"The map `coe_fn : (r ‚Üír s) ‚Üí (Œ± ‚Üí Œ≤)` is injective. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Monoid M] [inst_1 : Monoid N] (f : M ‚Üí* N) (l : List M),\n  ‚Üëf (List.prod l) = List.prod (List.map (‚Üëf) l)","name":"MonoidHom.map_list_prod","isProp":true,"docString":"Deprecated, use `_root_.map_list_prod` instead. "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {S : Type u_2} {F : Filter Œπ} [inst : Filter.NeBot F] [inst : CompleteLinearOrder R]\n  [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R] [inst_3 : CompleteLinearOrder S]\n  [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {f : (a : R) ‚Üí S} (f_incr : Monotone f) (a : (a : Œπ) ‚Üí R)\n  (f_cont : ContinuousAt f (Filter.limsup a F)), f (Filter.limsup a F) = Filter.limsup (f ‚àò a) F","name":"Monotone.map_limsup_of_continuousAt","isProp":true,"docString":"A continuous monotone function between complete linear ordered spaces sends a `Filter.limsup`\nto the `Filter.limsup` of the images. "},{"type":"‚àÄ {n : ‚Ñï} {x : Fin (n + 1)}, Function.Injective ‚Üë(Fin.succAbove x)","name":"Fin.succAbove_right_injective","isProp":true,"docString":"Given a fixed pivot `x : Fin (n + 1)`, `x.succAbove` is injective "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n : ‚Ñï} {s‚ÇÅ : Affine.Simplex k P n} {s‚ÇÇ : Affine.Simplex k P n}\n  (h : Set.range (Affine.Simplex.points s‚ÇÅ) = Set.range (Affine.Simplex.points s‚ÇÇ)),\n  Finset.centroid k Finset.univ (Affine.Simplex.points s‚ÇÅ) = Finset.centroid k Finset.univ (Affine.Simplex.points s‚ÇÇ)","name":"Affine.Simplex.centroid_eq_of_range_eq","isProp":true,"docString":"Two simplices with the same points have the same centroid. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (Œ¥ : ‚Ñù) (E : Set Œ±),\n  Metric.thickening Œ¥ E = (fun (x : Œ±) ‚Ü¶ EMetric.infEdist x E) ‚Åª¬π' Set.Iio (ENNReal.ofReal Œ¥)","name":"Metric.thickening_eq_preimage_infEdist","isProp":true,"docString":"The (open) thickening equals the preimage of an open interval under `EMetric.infEdist`. "},{"type":"‚àÄ {R : Type u} {A‚ÇÅ : Type v} {A‚ÇÇ : Type w} [inst : CommSemiring R] [inst_1 : Semiring A‚ÇÅ] [inst_2 : Semiring A‚ÇÇ]\n  [inst_3 : Algebra R A‚ÇÅ] [inst_4 : Algebra R A‚ÇÇ] (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ), ‚Üë‚Üëe = ‚Üë‚Üëe","name":"AlgEquiv.coe_ringHom_commutes","isProp":true,"docString":"The two paths coercion can take to a `RingHom` are equivalent "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {Œ¥ : Type u_1} [inst_4 : LinearOrder Œ¥] [inst_5 : TopologicalSpace Œ¥]\n  [inst_6 : OrderClosedTopology Œ¥] {a : Œ±} {b : Œ±} (hab : a ‚â§ b) {f : (a : Œ±) ‚Üí Œ¥} (hf : ContinuousOn f (Set.Icc a b)),\n  Set.Icc (f b) (f a) ‚äÜ f '' Set.Icc a b","name":"intermediate_value_Icc'","isProp":true,"docString":"**Intermediate Value Theorem** for continuous functions on closed intervals, case\n`f a ‚â• t ‚â• f b`."},{"type":"‚àÄ {M : Type u_1} [inst : AddGroup M] (c : AddCon M) (n : ‚Ñ§) {w : M} {x : M} (a : ‚Üëc w x), ‚Üëc (n ‚Ä¢ w) (n ‚Ä¢ x)","name":"AddCon.zsmul","isProp":true,"docString":"Additive congruence relations preserve integer scaling."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  {s : Set E},\n  (Convex ùïú s : Prop) ‚Üî\n    (‚àÄ ‚¶Éx : E‚¶Ñ (a : x ‚àà s) ‚¶Éy : E‚¶Ñ (a : y ‚àà s) ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 ‚â§ a) (a_2 : 0 ‚â§ b) (a_3 : 0 < a + b),\n        (a / (a + b)) ‚Ä¢ x + (b / (a + b)) ‚Ä¢ y ‚àà s :\n      Prop)","name":"convex_iff_div","isProp":true,"docString":"Alternative definition of set convexity, using division. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (ha : 1 < a) (hb : 1 ‚â§ b), 1 < a * b","name":"Right.one_lt_mul_of_lt_of_le","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul_of_lt_of_le`. "},{"type":"‚àÄ {Œ± : Type u} (x : Œ±), Function.IsFixedPt id x","name":"Function.isFixedPt_id","isProp":true,"docString":"Every point is a fixed point of `id`. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} (hf : Function.Injective2 f)\n  [inst : Nonempty Œ≤], Function.Injective f","name":"Function.Injective2.left'","isProp":true,"docString":"As a map from the left argument to a unary function, `f` is injective. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : CoheytingAlgebra Œ±]\n  [inst_1 : CoheytingAlgebra Œ≤] [self : CoheytingHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a \\ b) = ‚Üëf a \\ ‚Üëf b","name":"CoheytingHomClass.map_sdiff","isProp":true,"docString":"The proposition that a co-Heyting homomorphism preserves the difference operation."},{"type":"‚àÄ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommMonoid E] [inst_1 : DivisionSemiring R]\n  [inst_2 : DivisionSemiring S] [inst_3 : Module R E] [inst_4 : Module S E] (n : ‚Ñï) (x : E), (‚Üën)‚Åª¬π ‚Ä¢ x = (‚Üën)‚Åª¬π ‚Ä¢ x","name":"inv_nat_cast_smul_eq","isProp":true,"docString":"If `E` is a vector space over two division semirings `R` and `S`, then scalar multiplications\nagree on inverses of natural numbers in `R` and `S`. "},{"type":"‚àÄ {F : Type u_3} {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : BooleanAlgebra Œ±] [inst_1 : BooleanAlgebra Œ≤]\n  [inst_2 : BoundedLatticeHomClass F Œ± Œ≤] (f : F) (a : Œ±), ‚Üëf (a·∂ú) = ‚Üëf a·∂ú","name":"map_compl'","isProp":true,"docString":"Special case of `map_compl` for boolean algebras. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C},\n  CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Œπ 0)","name":"CategoryTheory.Limits.kernel.Œπ_zero_isIso","isProp":true,"docString":"Every kernel of the zero morphism is an isomorphism "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\n  [inst_2 : NonUnitalRingHomClass F R S] [inst_3 : Finite R] (f : F), Finite { x : S // x ‚àà NonUnitalRingHom.srange f }","name":"NonUnitalRingHom.finite_srange","isProp":true,"docString":"The range of a morphism of non-unital semirings is finite if the domain is a finite. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (u : RÀ£) (hu : ‚Üëu < 0) (v : Module.Ray R M), u ‚Ä¢ v = -v","name":"Module.Ray.units_smul_of_neg","isProp":true,"docString":"Scaling by a negative unit is negation. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} {r : ‚Ñù} (hs : Set.Nonempty s),\n  (Metric.infDist x s < r : Prop) ‚Üî (‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (dist x y < r : Prop) : Prop)","name":"Metric.infDist_lt_iff","isProp":true,"docString":"The minimal distance to a set is `< r` iff there exists a point in this set at distance `< r` "},{"type":"‚àÄ {B : Type u_2} {F : Type u_3} {Z : Type u_4} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  {proj : (a : Z) ‚Üí B} [inst_2 : TopologicalSpace Z] {X : Type u_1} [inst_3 : TopologicalSpace X] {f : (a : Z) ‚Üí X}\n  {z : Z} (e : Trivialization F proj) (he : proj z ‚àà Trivialization.baseSet e)\n  (hf :\n    ContinuousAt\n      (f ‚àò LocalEquiv.toFun (LocalEquiv.symm (LocalHomeomorph.toLocalEquiv (Trivialization.toLocalHomeomorph e))))\n      (‚Üëe z)),\n  ContinuousAt f z","name":"Trivialization.continuousAt_of_comp_right","isProp":true,"docString":"Read off the continuity of a function `f : Z ‚Üí X` at `z : Z` by transferring via a\ntrivialization of `Z` containing `z`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : IsUpperModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚äì b ‚ãñ b), a ‚ãñ a ‚äî b","name":"Covby.sup_of_inf_right","isProp":true,"docString":"**Alias** of `covby_sup_of_inf_covby_right`."},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : Type u_2} [inst : Infinite œÄ] [inst : Nonempty Œπ], Infinite ((a : Œπ) ‚Üí œÄ)","name":"Function.infinite_of_right","isProp":true,"docString":"Non-dependent version of `Pi.infinite_of_exists_right` and `Pi.infinite_of_right`. "},{"type":"‚àÄ {K : Type v} [inst : Field K] {P : Polynomial K} (hmo : Polynomial.Monic P) (hP : Polynomial.Splits (RingHom.id K) P),\n  Polynomial.coeff P 0 = (-1) ^ Polynomial.natDegree P * Multiset.prod (Polynomial.roots P)","name":"Polynomial.prod_roots_eq_coeff_zero_of_monic_of_split","isProp":true,"docString":"If `P` is a monic polynomial that splits, then `coeff P 0` equals the product of the roots. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±} (a_1 : Codisjoint a a), a = ‚ä§","name":"Codisjoint.eq_top_of_self","isProp":true,"docString":"**Alias** of the forward direction of `codisjoint_self`."},{"type":"‚àÄ {E : Type u_1} {F : Type u_2} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F] {f : (a : E) ‚Üí F} {C : NNReal}\n  (a : LipschitzWith C f) (x : E) (y : E), ‚Äñf x / f y‚Äñ ‚â§ ‚ÜëC * ‚Äñx / y‚Äñ","name":"LipschitzWith.norm_div_le","isProp":true,"docString":"**Alias** of the forward direction of `lipschitzWith_iff_norm_div_le`."},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} {l : List Œ±} (a_1 : a ‚àà b :: l), (a = b : Prop) ‚à® (a ‚àà l : Prop)","name":"List.eq_or_mem_of_mem_cons","isProp":true,"docString":"**Alias** of the forward direction of `List.mem_cons`."},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommRing R] {M : Type u_3} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : TopologicalSpace R] {B : (a : Œπ) ‚Üí Submodule R M} (self : SubmodulesBasis B) (m : M) (i : Œπ),\n  Filter.Eventually (fun (a : R) ‚Ü¶ a ‚Ä¢ m ‚àà B i) (nhds 0)","name":"SubmodulesBasis.smul","isProp":true,"docString":"For any element `m : M` and any set `B` in the basis, `a ‚Ä¢ m` lies in `B` for all\n`a` sufficiently close to `0`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  {u : (a : Œ≤) ‚Üí Œ±},\n  (CauchySeq u : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0), ‚àÉ (N : Œ≤), ‚àÄ (m : Œ≤) (a : m ‚â• N) (n : Œ≤) (a : n ‚â• N), dist (u m) (u n) < Œµ : Prop)","name":"Metric.cauchySeq_iff","isProp":true,"docString":"In a pseudometric space, Cauchy sequences are characterized by the fact that, eventually,\nthe distance between its elements is arbitrarily small "},{"type":"‚àÄ {Œ± : Type u} {p : (a : Œ±) ‚Üí Prop} {a : Œ±} (h : a ‚àà setOf fun (x : Œ±) ‚Ü¶ p x), p a","name":"Membership.mem.out","isProp":true,"docString":"If `h : a ‚àà {x | p x}` then `h.out : p x`. These are definitionally equal, but this can\nnevertheless be useful for various reasons, e.g. to apply further projection notation or in an\nargument to `simp`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommSemiring Œ±] (E : LinearRecurrence Œ±) (init : (a : Fin (LinearRecurrence.order E)) ‚Üí Œ±)\n  (n : Fin (LinearRecurrence.order E)), LinearRecurrence.mkSol E init ‚Üën = init n","name":"LinearRecurrence.mkSol_eq_init","isProp":true,"docString":"`E.mkSol init`'s first `E.order` terms are `init`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±} (hf : IsRingHom f),\n  f (-x) = -f x","name":"IsRingHom.map_neg","isProp":true,"docString":"Ring homomorphisms preserve additive inverses. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {A : Type u_2} [inst_1 : Semiring A] (P : Algebra R A) (Q : Algebra R A)\n  (h : ‚àÄ (r : R), ‚Üë(algebraMap R A) r = ‚Üë(algebraMap R A) r), P = Q","name":"Algebra.algebra_ext","isProp":true,"docString":"To prove two algebra structures on a fixed `[CommSemiring R] [Semiring A]` agree,\nit suffices to check the `algebraMap`s agree.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} {a : Œ±}\n  (h : f =·∂†[nhds a] g), Filter.Eventually (fun (y : Œ±) ‚Ü¶ f =·∂†[nhds y] g) (nhds a)","name":"Filter.EventuallyEq.eventuallyEq_nhds","isProp":true,"docString":"If two functions are equal in a neighbourhood of `a`, then for `y` sufficiently close\nto `a` these functions are equal in a neighbourhood of `y`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} [inst : AddGroup Œ±] [self : NonarchAddGroupSeminormClass F Œ±] (f : F)\n  (a : Œ±), ‚Üëf (-a) = ‚Üëf a","name":"NonarchAddGroupSeminormClass.map_neg_eq_map'","isProp":true,"docString":"The seminorm is invariant under negation. "},{"type":"‚àÄ {t : (a : Type u) ‚Üí Type u} [inst : Traversable t] [self : IsLawfulTraversable t] {Œ± : Type u} {Œ≤ : Type u}\n  (f : (a : Œ±) ‚Üí Œ≤) (x : t Œ±), traverse (pure ‚àò f) x = id.mk (f <$> x)","name":"IsLawfulTraversable.traverse_eq_map_id","isProp":true,"docString":"An axiom for `traverse` involving `pure : Œ≤ ‚Üí Id Œ≤`. "},{"type":"‚àÄ {H : Type u} {M : Type u_1} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  (G : StructureGroupoid H) [inst_3 : HasGroupoid M G] (s : TopologicalSpace.Opens M)\n  [inst_4 : ClosedUnderRestriction G], HasGroupoid { x : M // x ‚àà s } G","name":"TopologicalSpace.Opens.instHasGroupoidSubtypeMemOpensInstMembershipInstSetLikeOpensInstTopologicalSpaceSubtypeInstChartedSpaceSubtypeMemOpensInstMembershipInstSetLikeOpensInstTopologicalSpaceSubtype","isProp":true,"docString":"If a groupoid `G` is `ClosedUnderRestriction`, then an open subset of a space which is\n`HasGroupoid G` is naturally `HasGroupoid G`. "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] (m : Type u) (n : Type u) [inst_2 : Finite m]\n  [inst_3 : Finite n], Module.rank R (Matrix m n R) = Cardinal.mk m * Cardinal.mk n","name":"rank_matrix''","isProp":true,"docString":"If `m` and `n` are `Fintype` that lie in the same universe as `R`, the rank of `m √ó n` matrices\nis `# m * # n`. "},{"type":"‚àÄ {Œ± : Type u} [self : Semiring Œ±] (a : Œ±), 1 * a = a","name":"Semiring.one_mul","isProp":true,"docString":"One is a left neutral element for multiplication "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} {R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R)\n  [inst_1 : CategoryTheory.StrongEpi (f ‚â´ g)], CategoryTheory.StrongEpi g","name":"CategoryTheory.strongEpi_of_strongEpi","isProp":true,"docString":"If `f ‚â´ g` is a strong epimorphism, then so is `g`. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí SeminormedAddGroup (œÄ i)]\n  {x : (i : Œπ) ‚Üí œÄ i} {r : ‚Ñù} (hr : 0 ‚â§ r), (‚Äñx‚Äñ ‚â§ r : Prop) ‚Üî (‚àÄ (i : Œπ), ‚Äñx i‚Äñ ‚â§ r : Prop)","name":"pi_norm_le_iff_of_nonneg","isProp":true,"docString":"The seminorm of an element in a product space is `‚â§ r` if\nand only if the norm of each component is."},{"type":"‚àÄ {Œ± : Type u_1} (f : (a : Set Œ±) ‚Üí Œ±), ¬¨(Function.Injective f : Prop)","name":"Function.cantor_injective","isProp":true,"docString":"**Cantor's diagonal argument** implies that there are no injective functions from `Set Œ±`\nto `Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : (a : Œ±) ‚Üí Type u_2} {Œ≥ : Type u_3} [inst : (a : Œ±) ‚Üí CommMonoid (Œ≤ a)] (s : Finset Œ≥)\n  (g : (a : Œ≥) ‚Üí (a : Œ±) ‚Üí Œ≤ a), (Finset.prod s fun (c : Œ≥) ‚Ü¶ g c) = fun (a : Œ±) ‚Ü¶ Finset.prod s fun (c : Œ≥) ‚Ü¶ g c a","name":"Finset.prod_fn","isProp":true,"docString":"An 'unapplied' analogue of `Finset.prod_apply`. "},{"type":"‚àÄ {F : Type u_1} {R : Type u_2} {S : Type u_3} [inst : Star R] [inst_1 : Star S] [inst_2 : StarHomClass F R S] {x : R}\n  (hx : IsSelfAdjoint x) (f : F), IsSelfAdjoint (‚Üëf x)","name":"IsSelfAdjoint.starHom_apply","isProp":true,"docString":"Functions in a `StarHomClass` preserve self-adjoint elements. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (a : Œ±),\n  Filter.HasBasis (nhds a) (fun (s : Set Œ±) ‚Ü¶ (a ‚àà s : Prop) ‚àß (IsOpen s : Prop)) fun (s : Set Œ±) ‚Ü¶ s","name":"nhds_basis_opens","isProp":true,"docString":"The open sets containing `a` are a basis for the neighborhood filter. See `nhds_basis_opens'`\nfor a variant using open neighborhoods instead. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} {E : Set Œ±}, IsOpen (Metric.thickening Œ¥ E)","name":"Metric.isOpen_thickening","isProp":true,"docString":"The (open) thickening is an open set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ioc (f n) (f (Order.pred n)))","name":"Antitone.pairwise_disjoint_on_Ioc_pred","isProp":true,"docString":"If `Œ±` is a linear pred order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is an antitone function, then\nthe intervals `Set.Ioc (f n) (f (Order.pred n))` are pairwise disjoint. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], Function.Injective SetLike.coe","name":"AffineSubspace.coe_injective","isProp":true,"docString":"Two affine subspaces are equal if they have the same points. "},{"type":"‚àÄ {V : Type u_1} [inst : Quiver V] [self : Quiver.HasInvolutiveReverse V] {a : V} {b : V} (f : a ‚ü∂ b),\n  Quiver.reverse (Quiver.reverse f) = f","name":"Quiver.HasInvolutiveReverse.inv'","isProp":true,"docString":"`reverse` is involutive "},{"type":"‚àÄ {R : Type x} [inst : NonUnitalNonAssocRing R] {a : R} {b : R} (h : Commute a b), a * a - b * b = (a + b) * (a - b)","name":"Commute.mul_self_sub_mul_self_eq","isProp":true,"docString":"Representation of a difference of two squares of commuting elements as a product. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : Type v‚ÇÇ)\n  [inst_1 : CategoryTheory.Limits.HasProductsOfShape X C], CategoryTheory.Limits.HasCoproductsOfShape X C·µí·µñ","name":"CategoryTheory.Limits.hasCoproductsOfShape_opposite","isProp":true,"docString":"If `C` has products indexed by `X`, then `C·µí·µñ` has coproducts indexed by `X`.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (I : C) (h : ‚àÄ (A : C) (f : I ‚ü∂ A), CategoryTheory.IsIso f),\n  CategoryTheory.Limits.HasStrictTerminalObjects C","name":"CategoryTheory.Limits.hasStrictTerminalObjects_of_terminal_is_strict","isProp":true,"docString":"If `C` has an object such that every morphism *from* it is an isomorphism, then `C`\nhas strict terminal objects. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : MonotoneOn f s) (hs : s ‚àà nhdsWithin a (Set.Ici a))\n  (hfs : closure (f '' s) ‚àà nhdsWithin (f a) (Set.Ici (f a))), ContinuousWithinAt f (Set.Ici a) a","name":"continuousWithinAt_right_of_monotoneOn_of_closure_image_mem_nhdsWithin","isProp":true,"docString":"If a function `f` with a densely ordered codomain is monotone on a right neighborhood of `a` and\nthe closure of the image of this neighborhood under `f` is a right neighborhood of `f a`, then `f`\nis continuous at `a` from the right. "},{"type":"‚àÄ (Œ± : Type u) [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] [inst_4 : TopologicalSpace.SeparableSpace Œ±], TopologicalSpace.SecondCountableTopology Œ±","name":"TopologicalSpace.SecondCountableTopology.of_separableSpace_orderTopology","isProp":true,"docString":"Let `Œ±` be a densely ordered linear order with order topology. If `Œ±` is a separable space, then\nit has second countable topology. Note that the \"densely ordered\" assumption cannot be droped, see\n[double arrow space](https://topology.pi-base.org/spaces/S000093) for a counterexample. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Monoid Œ≤] (s : Finset Œ±) (f : (a : Œ±) ‚Üí Œ≤)\n  (comm : Set.Pairwise ‚Üës fun (a : Œ±) (b : Œ±) ‚Ü¶ Commute (f a) (f b)),\n  Set.Pairwise (setOf fun (x : Œ≤) ‚Ü¶ x ‚àà Multiset.map f (Finset.val s)) Commute","name":"Finset.noncommProd_lemma","isProp":true,"docString":"Proof used in definition of `Finset.noncommProd "},{"type":"‚àÄ {Œ± : Type u} (b : ULift Œ±), { down := ULift.down b } = b","name":"ULift.up_down","isProp":true,"docString":"Bijection between `Œ±` and `ULift.{v} Œ±` "},{"type":"‚àÄ {M : Type u} [inst : Monoid M] (x : M) (n : ‚Ñï), { unop := x ^ n } = { unop := x } ^ n","name":"MulOpposite.op_pow","isProp":true,"docString":"Moving to the opposite monoid commutes with taking powers. "},{"type":"‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hf : Function.IsFixedPt f x) (n : ‚Ñï), Function.IsPeriodicPt f n x","name":"Function.IsFixedPt.isPeriodicPt","isProp":true,"docString":"A fixed point of `f` is a periodic point of `f` of any prescribed period. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {J : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category J] (F : J ‚•§ C·µí·µñ)\n  [inst_2 : CategoryTheory.Limits.HasLimit (CategoryTheory.Functor.leftOp F)], CategoryTheory.Limits.HasColimit F","name":"CategoryTheory.Limits.hasColimit_of_hasLimit_leftOp","isProp":true,"docString":"If `F.leftOp : J·µí·µñ ‚•§ C` has a limit, we can construct a colimit for `F : J ‚•§ C·µí·µñ`.\n"},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {f : Œ± ‚Ü™ Œ≤} {s : Finset Œ±} (a : Finset.Nonempty s), Finset.Nonempty (Finset.map f s)","name":"Finset.Nonempty.map","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.map_nonempty`."},{"type":"‚àÄ (R : Type u) (M : Type v) [inst : CommRing R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] (N : Type v) [inst_5 : AddCommGroup N] [inst_6 : Module R N]\n  [inst_7 : Module.Free R N], Module.rank R (TensorProduct R M N) = Module.rank R M * Module.rank R N","name":"rank_tensorProduct'","isProp":true,"docString":"If `M` and `N` lie in the same universe, the rank of `M ‚äó[R] N` is\n`(Module.rank R M) * (Module.rank R N)`. "},{"type":"‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a : B} {b : B}\n  (f : a ‚ü∂ b),\n  CategoryTheory.Bicategory.leftUnitor f =\n    CategoryTheory.eqToIso ((CategoryTheory.Bicategory.Strict.id_comp f=:ùüô a ‚â´ f = f)=:ùüô a ‚â´ f = f)","name":"CategoryTheory.Bicategory.Strict.leftUnitor_eqToIso","isProp":true,"docString":"The left unitors are given by equalities "},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (h : ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ ‚¶Éz : Œ±‚¶Ñ (a : x < y) (a : y < z), False) (x : Œ±) (y : Œ±)\n  (z : Œ±), (x = y : Prop) ‚à® ((y = z : Prop) ‚à® (x = z : Prop) : Prop)","name":"eq_or_eq_or_eq_of_forall_not_lt_lt","isProp":true,"docString":"If a linear order has no elements `x < y < z`, then it has at most two elements. "},{"type":"‚àÄ {Œπ : Type u_4} {K : Type u_1} [inst : Ring K] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module K M]\n  {N : Type u_3} [inst_3 : AddCommGroup N] [inst_4 : Module K N] [inst_5 : NoZeroSMulDivisors K N]\n  (f : AlternatingMap K M N Œπ) (v : (a : Œπ) ‚Üí M) (h : ¬¨(LinearIndependent K v : Prop)), ‚Üëf v = 0","name":"AlternatingMap.map_linearDependent","isProp":true,"docString":"If the arguments are linearly dependent then the result is `0`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S) (x : R)\n  (y : R), ‚Üëe (x + y) = ‚Üëe x + ‚Üëe y","name":"RingEquiv.map_add","isProp":true,"docString":"A ring isomorphism preserves addition. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±}\n  (hst : Disjoint (s ‚à© Function.mulSupport f) (t ‚à© Function.mulSupport f)) (hs : Set.Finite (s ‚à© Function.mulSupport f))\n  (ht : Set.Finite (t ‚à© Function.mulSupport f)),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) =\n    (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà t) ‚Ü¶ f i","name":"finprod_mem_union''","isProp":true,"docString":"A more general version of `finprod_mem_union'` that requires `s ‚à© mulSupport f` and\n`t ‚à© mulSupport f` rather than `s` and `t` to be disjoint "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s), Convex ùïú (closure s)","name":"Convex.closure","isProp":true,"docString":"In a topological vector space, the closure of a convex set is convex. "},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ : Œ±} {a‚ÇÇ : Œ±} (f : (a : Œ±) ‚Üí Œ≤) (h : a‚ÇÅ = a‚ÇÇ), f a‚ÇÅ = f a‚ÇÇ","name":"congrArg","isProp":true,"docString":"Congruence in the function argument: if `a‚ÇÅ = a‚ÇÇ` then `f a‚ÇÅ = f a‚ÇÇ` for\nany (nondependent) function `f`. This is more powerful than it might look at first, because\nyou can also use a lambda expression for `f` to prove that\n`<something containing a‚ÇÅ> = <something containing a‚ÇÇ>`. This function is used\ninternally by tactics like `congr` and `simp` to apply equalities inside\nsubterms.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ≤) ‚Üí Œ±}\n  (hg : Function.Injective g),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà Set.range g) ‚Ü¶ f i) = finsum fun (j : Œ≤) ‚Ü¶ f (g j)","name":"finsum_mem_range","isProp":true,"docString":"The sum of `f y` over `y ‚àà Set.range g` equals the sum of `f (g i)` over all `i`\nprovided that `g` is injective."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s1 : AffineSubspace k P} {s2 : AffineSubspace k P} (h : s1 < s2),\n  ‚àÉ (p : P), (p ‚àà s2 : Prop) ‚àß (¬¨(p ‚àà s1 : Prop) : Prop)","name":"AffineSubspace.exists_of_lt","isProp":true,"docString":"If a subspace is less than another, there is a point only in the second. "},{"type":"‚àÄ (R : Type u_2) {A : Type u_1} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : TopologicalSpace A]\n  [inst_3 : Semiring A] [inst_4 : StarRing A] [inst_5 : TopologicalSemiring A] [inst_6 : ContinuousStar A]\n  [inst_7 : Algebra R A] [inst_8 : StarModule R A] (x : A), ClosedEmbedding Subtype.val","name":"elementalStarAlgebra.closedEmbedding_coe","isProp":true,"docString":"The coercion from an elemental algebra to the full algebra as a `ClosedEmbedding`. "},{"type":"‚àÄ {C : Type u} [ùíû : CategoryTheory.Category C] [self : CategoryTheory.MonoidalCategory C] (W : C) (X : C) (Y : C)\n  (Z : C),\n  (CategoryTheory.Iso.hom (Œ±_ W X Y) ‚äó ùüô Z) ‚â´\n      CategoryTheory.Iso.hom (Œ±_ W (X ‚äó Y) Z) ‚â´ (ùüô W ‚äó CategoryTheory.Iso.hom (Œ±_ X Y Z)) =\n    CategoryTheory.Iso.hom (Œ±_ (W ‚äó X) Y Z) ‚â´ CategoryTheory.Iso.hom (Œ±_ W X (Y ‚äó Z))","name":"CategoryTheory.MonoidalCategory.pentagon","isProp":true,"docString":"The pentagon identity relating the isomorphism between `X ‚äó (Y ‚äó (Z ‚äó W))` and `((X ‚äó Y) ‚äó Z) ‚äó W`\n"},{"type":"‚àÄ {Œ± : Type u}, DenseEmbedding pure","name":"denseEmbedding_pure","isProp":true,"docString":"`pure : Œ± ‚Üí Ultrafilter Œ±` defines a dense embedding of `Œ±` in `Ultrafilter Œ±`. "},{"type":"‚àÄ {n : ‚Ñï} {m : ‚Ñï} (a : n < m), ‚Üën < ‚Üëm","name":"Int.ofNat_lt_ofNat_of_lt","isProp":true,"docString":"**Alias** of the reverse direction of `Int.ofNat_lt`."},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] {f : Filter Œ±} {x : Œ±} (hf : Cauchy f) (adhs : ClusterPt x f), f ‚â§ nhds x","name":"le_nhds_of_cauchy_adhp","isProp":true,"docString":"If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point\nfor `f`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤), ‚Üëf 0 = 0","name":"RingHom.map_zero","isProp":true,"docString":"Ring homomorphisms map zero to zero. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (s : Subring R) {Œπ : Type u_2} {t : Finset Œπ} {f : (a : Œπ) ‚Üí R}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà s), (Finset.prod t fun (i : Œπ) ‚Ü¶ f i) ‚àà s","name":"Subring.prod_mem","isProp":true,"docString":"Product of elements of a subring of a `CommRing` indexed by a `Finset` is in the\nsubring. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  [self : CategoryTheory.ReflectsIsomorphisms F] {A : C} {B : C} (f : A ‚ü∂ B)\n  [inst_2 : CategoryTheory.IsIso (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)], CategoryTheory.IsIso f","name":"CategoryTheory.ReflectsIsomorphisms.reflects","isProp":true,"docString":"For any `f`, if `F.map f` is an iso, then so was `f`"},{"type":"‚àÄ {Œπ : Type u_5} {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R]\n  [inst_1 : Semiring R‚ÇÇ] [inst_2 : AddCommMonoid M] [inst_3 : Module R M] [inst_4 : AddCommMonoid M‚ÇÇ]\n  [inst_5 : Module R‚ÇÇ M‚ÇÇ] [inst_6 : TopologicalSpace M] [inst_7 : TopologicalSpace M‚ÇÇ] {œÉ : R ‚Üí+* R‚ÇÇ} {f : (a : Œπ) ‚Üí M}\n  (œÜ : M ‚ÜíSL[œÉ] M‚ÇÇ) {x : M} (hf : HasSum f x), HasSum (fun (b : Œπ) ‚Ü¶ ‚ÜëœÜ (f b)) (‚ÜëœÜ x)","name":"ContinuousLinearMap.hasSum","isProp":true,"docString":"Applying a continuous linear map commutes with taking an (infinite) sum. "},{"type":"‚àÄ (R : Type u_1) [inst : CommRing R] (m : ‚Ñï) (n : ‚Ñï),\n  Polynomial.Chebyshev.T R (m * n) = Polynomial.comp (Polynomial.Chebyshev.T R m) (Polynomial.Chebyshev.T R n)","name":"Polynomial.Chebyshev.T_mul","isProp":true,"docString":"The `(m * n)`-th Chebyshev polynomial is the composition of the `m`-th and `n`-th "},{"type":"‚àÄ {Œπ : Type u_1} {R‚ÇÇ : Type u_2} {M‚ÇÇ : Type u_3} [inst : CommRing R‚ÇÇ] [inst_1 : AddCommGroup M‚ÇÇ] [inst_2 : Module R‚ÇÇ M‚ÇÇ]\n  [inst_3 : DecidableEq Œπ] (e : Basis Œπ R‚ÇÇ M‚ÇÇ) (w : (a : Œπ) ‚Üí R‚ÇÇÀ£),\n  Basis.toMatrix e ‚Üë(Basis.unitsSMul e w) = Matrix.diagonal (Units.val ‚àò w)","name":"Basis.toMatrix_unitsSMul","isProp":true,"docString":"The basis constructed by `unitsSMul` has vectors given by a diagonal matrix. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhdsWithin a (Set.Ici a)) (hfs : Set.SurjOn f s (Set.Ioi (f a))),\n  ContinuousWithinAt f (Set.Ici a) a","name":"StrictMonoOn.continuousWithinAt_right_of_surjOn","isProp":true,"docString":"If a function `f` is strictly monotone on a right neighborhood of `a` and the image of this\nneighborhood under `f` includes `Ioi (f a)`, then `f` is continuous at `a` from the right. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] (x : Œ±) (y : Œ±),\n  ((fun (x_1 : Œ±) ‚Ü¶ x * x_1) ‚àò fun (x : Œ±) ‚Ü¶ y * x) = fun (x_1 : Œ±) ‚Ü¶ x * y * x_1","name":"comp_mul_left","isProp":true,"docString":"Composing two multiplications on the left by `y` then `x`\nis equal to a multiplication on the left by `x * y`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {p : Œ±} (self : Irreducible p), ¬¨(IsUnit p : Prop)","name":"Irreducible.not_unit","isProp":true,"docString":"`p` is not a unit "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} (hf : Function.Injective2 f)\n  [inst : Nonempty Œ±], Function.Injective fun (b : Œ≤) (a : Œ±) ‚Ü¶ f a b","name":"Function.Injective2.right'","isProp":true,"docString":"As a map from the right argument to a unary function, `f` is injective. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_2} {Œ≤ : Type u_1} (f : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ≤) (b : Œ≤) (v : Vector Œ± n) (i : Fin n),\n  Vector.get (Vector.scanl f b v) (Fin.succ i) = f (Vector.get (Vector.scanl f b v) (‚ÜëFin.castSucc i)) (Vector.get v i)","name":"Vector.scanl_get","isProp":true,"docString":"For an index `i : Fin n`, the nth element of `scanl` of a\nvector `v : Vector Œ± n` at `i.succ`, is equal to the application\nfunction `f : Œ≤ ‚Üí Œ± ‚Üí Œ≤` of the `castSucc i` element of\n`scanl f b v` and `get v i`.\n\nThis lemma is the `get` version of `scanl_cons`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (f : Œ± ‚âÉ‚Çú Œ≤)\n  (K : TopologicalSpace.Compacts Œ±),\n  TopologicalSpace.Compacts.carrier (‚Üë(TopologicalSpace.Compacts.equiv f) K) =\n    ‚Üë(Homeomorph.symm f) ‚Åª¬π' TopologicalSpace.Compacts.carrier K","name":"TopologicalSpace.Compacts.equiv_to_fun_val","isProp":true,"docString":"The image of a compact set under a homeomorphism can also be expressed as a preimage. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (hab : a < b) (h‚ÇÄ : 0 < r) (h‚ÇÅ : r < 1),\n  (‚Üë(AffineMap.lineMap (f a) (f b)) r ‚â§ f (‚Üë(AffineMap.lineMap a b) r) : Prop) ‚Üî\n    (slope f (‚Üë(AffineMap.lineMap a b) r) b ‚â§ slope f a (‚Üë(AffineMap.lineMap a b) r) : Prop)","name":"lineMap_le_map_iff_slope_le_slope","isProp":true,"docString":"Given `c = lineMap a b r`, `a < c < b`, the point `(c, f c)` is non-strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f c b ‚â§ slope f a c`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Nontrivial s), Nontrivial ‚Üës","name":"Set.Nontrivial.coe_sort","isProp":true,"docString":"**Alias** of the reverse direction of `Set.nontrivial_coe_sort`."},{"type":"‚àÄ {R : Type v} [inst : CommRing R] {n : ‚Ñï} {A : Matrix (Fin (n + 1)) (Fin (n + 1)) R}\n  {B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (c : (a : Fin n) ‚Üí R) (A_zero : ‚àÄ (i : Fin (n + 1)), A i 0 = B i 0)\n  (A_succ : ‚àÄ (i : Fin (n + 1)) (j : Fin n), A i (Fin.succ j) = B i (Fin.succ j) + c j * A i (‚ÜëFin.castSucc j)),\n  Matrix.det A = Matrix.det B","name":"Matrix.det_eq_of_forall_col_eq_smul_add_pred","isProp":true,"docString":"If you add multiples of previous columns to the next columns, the determinant doesn't change. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} [inst : Norm F] {c : ‚Ñù} {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù}\n  (a : Asymptotics.IsBigOWith c l u g), Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ abs (u x)) g","name":"Asymptotics.IsBigOWith.abs_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigOWith_abs_left`."},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±} {a : Œ±} (h : IsGLB s a), BddBelow s","name":"IsGLB.bddBelow","isProp":true,"docString":"If `s` has a greatest lower bound, then it is bounded below. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] {T : Type u_2}\n  [inst_2 : Monoid T] (f : R ‚Üí* T) (fS : { x : R // x ‚àà S } ‚Üí* TÀ£) (hf : ‚àÄ (s : { x : R // x ‚àà S }), ‚Üëf ‚Üës = ‚Üë(‚ÜëfS s))\n  (œÜ : R[S‚Åª¬π] ‚Üí* T) (huniv : ‚àÄ (r : R), ‚ÜëœÜ (‚ÜëOreLocalization.numeratorHom r) = ‚Üëf r),\n  œÜ = OreLocalization.universalMulHom f fS hf","name":"OreLocalization.universalMulHom_unique","isProp":true,"docString":"The universal morphism `universalMulHom` is unique. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b) (a_2 : b ‚â§ a), b = a","name":"LE.le.antisymm'","isProp":true,"docString":"**Alias** of `ge_antisymm`."},{"type":"‚àÄ {n : ‚Ñï} {a : Fin n} {b : Fin n} (a_1 : a ‚ãñ b), ‚Üëa ‚ãñ ‚Üëb","name":"Covby.coe_fin","isProp":true,"docString":"**Alias** of the reverse direction of `Fin.coe_covby_iff`."},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (s : Submodule K V),\n  (Module.rank K { x : V // x ‚àà s } ‚â§ 1 : Prop) ‚Üî (‚àÉ (v‚ÇÄ : V), s ‚â§ Submodule.span K {v‚ÇÄ} : Prop)","name":"rank_submodule_le_one_iff'","isProp":true,"docString":"A submodule has dimension at most `1` if and only if there is a\nsingle vector, not necessarily in the submodule, such that the\nsubmodule is contained in its span. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚ãñ b), ‚ÜëOrderDual.toDual b ‚ãñ ‚ÜëOrderDual.toDual a","name":"Covby.toDual","isProp":true,"docString":"**Alias** of the reverse direction of `toDual_covby_toDual_iff`."},{"type":"‚àÄ {Œ± : Type u} (L : List Œ±) {i : ‚Ñï} {j : ‚Ñï} (hi : i < List.length L) (hj : i < j),\n  List.nthLe L i hi =\n    List.nthLe (List.take j L) i\n      ((Eq.rec ((lt_min hj hi=:i < min j (List.length L))=:i < min j (List.length L))\n            ((Eq.symm\n                  ((List.length_take j\n                        L=:List.length (List.take j L) =\n                        min j\n                          (List.length\n                            L))=:List.length (List.take j L) =\n                      min j\n                        (List.length\n                          L))=:min j (List.length L) =\n                  List.length\n                    (List.take j\n                      L))=:min j (List.length L) =\n                List.length (List.take j L))=:i < List.length (List.take j L))=:i < List.length (List.take j L))","name":"List.nthLe_take","isProp":true,"docString":"The `i`-th element of a list coincides with the `i`-th element of any of its prefixes of\nlength `> i`. Version designed to rewrite from the big list to the small list. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ioo (f (Order.pred n)) (f n))","name":"Monotone.pairwise_disjoint_on_Ioo_pred","isProp":true,"docString":"If `Œ±` is a linear pred order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is a monotone function, then\nthe intervals `Set.Ioo (f Order.pred n) (f n)` are pairwise disjoint. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddGroup Œ±] [inst_1 : AddMonoid Œ≤] [inst_2 : AddAction Œ≤ Œ±] {H : AddSubgroup Œ±}\n  [self : AddAction.QuotientAction Œ≤ H] (b : Œ≤) {a : Œ±} {a' : Œ±} (a_1 : -a + a' ‚àà H), -(b +·µ• a) + (b +·µ• a') ‚àà H","name":"AddAction.QuotientAction.inv_mul_mem","isProp":true,"docString":"The action fulfils a normality condition on summands that lie in `H`.\nThis ensures that the action descends to an action on the quotient `Œ± ‚ß∏ H`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : DecidableEq Œ±] {A : Finset Œ±} (hA : Finset.Nonempty A) (B : Finset Œ±)\n  (m : ‚Ñï) (n : ‚Ñï),\n  ‚Üë(Finset.card (m ‚Ä¢ B - n ‚Ä¢ B)) ‚â§ (‚Üë(Finset.card (A + B)) / ‚Üë(Finset.card A)) ^ (m + n) * ‚Üë(Finset.card A)","name":"Finset.card_nsmul_sub_nsmul_le","isProp":true,"docString":"The **Pl√ºnnecke-Ruzsa inequality**. Addition version. Note that this is genuinely\nharder than the subtraction version because we cannot use a double counting argument."},{"type":"‚àÄ {Œ± : Type u} [self : Rack Œ±] (x : Œ±), Function.RightInverse (Rack.invAct x) (Shelf.act x)","name":"Rack.right_inv","isProp":true,"docString":"Proof of right inverse "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : RegularSpace Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚§≥ b), b ‚§≥ a","name":"Specializes.symm","isProp":true,"docString":"**Alias** of the forward direction of `specializes_comm`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : CompactSpace Œ±], IsCompact Set.univ","name":"CompactSpace.isCompact_univ","isProp":true,"docString":"In a compact space, `Set.univ` is a compact set. "},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2),\n  GaloisConnection\n    (fun (ùìê : Filter (UniformFun Œ± Œ≤ √ó UniformFun Œ± Œ≤)) ‚Ü¶ Filter.map (UniformFun.phi Œ± Œ≤) (Filter.prod ùìê ‚ä§))\n    fun (ùìï : Filter (Œ≤ √ó Œ≤)) ‚Ü¶ UniformFun.filter Œ± Œ≤ ùìï","name":"UniformFun.gc","isProp":true,"docString":"The function `UniformFun.filter Œ± Œ≤ : Filter (Œ≤ √ó Œ≤) ‚Üí Filter ((Œ± ‚Üí·µ§ Œ≤) √ó (Œ± ‚Üí·µ§ Œ≤))`\nhas a lower adjoint `l` (in the sense of `GaloisConnection`). The exact definition of `l` is not\ninteresting; we will only use that it exists (in `UniformFun.mono` and\n`UniformFun.inf·µ¢_eq`) and that\n`l (Filter.map (Prod.map f f) ùìï) = Filter.map (Prod.map ((‚àò) f) ((‚àò) f)) (l ùìï)` for each\n`ùìï : Filter (Œ≥ √ó Œ≥)` and `f : Œ≥ ‚Üí Œ±` (in `UniformFun.comap_eq`). "},{"type":"‚àÄ {R : Type u_1} [inst : Zero R] [inst_1 : Pow R ‚Ñï] [self : IsReduced R] (x : R) (a : IsNilpotent x), x = 0","name":"IsReduced.eq_zero","isProp":true,"docString":"A reduced structure has no nonzero nilpotent elements. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {s‚ÇÅ : Setoid Œ±} {s‚ÇÇ : Setoid Œ≤} {s‚ÇÉ : Setoid Œ≥}\n  {p : (a : Quotient s‚ÇÅ) ‚Üí (a : Quotient s‚ÇÇ) ‚Üí (a : Quotient s‚ÇÉ) ‚Üí Prop} (q‚ÇÅ : Quotient s‚ÇÅ) (q‚ÇÇ : Quotient s‚ÇÇ)\n  (q‚ÇÉ : Quotient s‚ÇÉ) (h : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ≤) (a‚ÇÉ : Œ≥), p (Quotient.mk'' a‚ÇÅ) (Quotient.mk'' a‚ÇÇ) (Quotient.mk'' a‚ÇÉ)),\n  p q‚ÇÅ q‚ÇÇ q‚ÇÉ","name":"Quotient.inductionOn‚ÇÉ'","isProp":true,"docString":"A version of `Quotient.inductionOn‚ÇÉ` taking `{s‚ÇÅ : Setoid Œ±} {s‚ÇÇ : Setoid Œ≤} {s‚ÇÉ : Setoid Œ≥}`\nas implicit arguments instead of instance arguments. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±},\n  (f =O[l] g' : Prop) ‚Üî (Filter.Eventually (fun (c : ‚Ñù) ‚Ü¶ Asymptotics.IsBigOWith c l f g') Filter.atTop : Prop)","name":"Asymptotics.isBigO_iff_eventually_isBigOWith","isProp":true,"docString":"`f = O(g)` if and only if `IsBigOWith c f g` for all sufficiently large `c`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (self : M ‚Üí* N) (x : M) (y : M),\n  OneHom.toFun (‚Üëself) (x * y) = OneHom.toFun (‚Üëself) x * OneHom.toFun (‚Üëself) y","name":"MonoidHom.map_mul'","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atBot),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atBot : Prop) ‚Üî (0 < r : Prop)","name":"Filter.tendsto_const_mul_atBot_iff_pos","isProp":true,"docString":"If `f` tends to negative infinity along a nontrivial filter `l`, then `Œª x, r * f x` tends to\nnegative infinity if and only if `0 < r. `"},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Neg G] [inst_2 : ContinuousNeg G] {Œπ : Type u_1},\n  ContinuousNeg ((a : Œπ) ‚Üí G)","name":"Pi.has_continuous_neg'","isProp":true,"docString":"A version of `Pi.continuousNeg` for non-dependent functions. It is needed\nbecause sometimes Lean fails to use `Pi.continuousNeg` for non-dependent functions."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhdsWithin a (Set.Iic a)) (hfs : Set.SurjOn f s (Set.Iio (f a))),\n  ContinuousWithinAt f (Set.Iic a) a","name":"StrictMonoOn.continuousWithinAt_left_of_surjOn","isProp":true,"docString":"If a function `f` is strictly monotone on a left neighborhood of `a` and the image of this\nneighborhood under `f` includes `Iio (f a)`, then `f` is continuous at `a` from the left. "},{"type":"‚àÄ {F : Type u_2} {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] [inst_1 : MonoidWithZeroHomClass F ‚Ñö M‚ÇÄ] {f : F} {g : F}\n  (same_on_neg_one : ‚Üëf (-1) = ‚Üëg (-1)) (same_on_pnat : ‚àÄ (n : ‚Ñï) (a : 0 < n), ‚Üëf ‚Üën = ‚Üëg ‚Üën), f = g","name":"MonoidWithZeroHom.ext_rat_on_pnat","isProp":true,"docString":"Positive integer values of a morphism `œÜ` and its value on `-1` completely determine `œÜ`. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} {x1 : Œ±} {b1 : Bool} {x2 : Œ±} {b2 : Bool}\n  (H1 : (x1, b1) ‚â† (x2, b2)) (H2 : FreeAddGroup.Red ((x1, b1) :: L‚ÇÅ) ((x2, b2) :: L‚ÇÇ)),\n  FreeAddGroup.Red L‚ÇÅ ((x1, !b1) :: (x2, b2) :: L‚ÇÇ)","name":"FreeAddGroup.Red.neg_of_red_of_ne","isProp":true,"docString":"If `x` and `y` are distinct letters and `w‚ÇÅ w‚ÇÇ` are words such that `x + w‚ÇÅ` reduces\nto `y + w‚ÇÇ`, then `w‚ÇÅ` reduces to `-x + y + w‚ÇÇ`."},{"type":"‚àÄ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {œÉ : R ‚Üí+* R}\n  [inst_3 : RingHomSurjective œÉ] {Œπ : Sort u_2} (f : M ‚Üí‚Çõ‚Çó[œÉ] M) {p : (a : Œπ) ‚Üí Submodule R M}\n  (hf : ‚àÄ (i : Œπ) (v : M) (a : v ‚àà p i), ‚Üëf v ‚àà p i) (v : M) (a : v ‚àà inf·µ¢ p), ‚Üëf v ‚àà inf·µ¢ p","name":"LinearMap.inf·µ¢_invariant","isProp":true,"docString":"The infimum of a family of invariant submodule of an endomorphism is also an invariant\nsubmodule. "},{"type":"‚àÄ {Œì : Type u_1} [inst : Group Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Œì T]\n  [inst_3 : ContinuousConstSMul Œì T], IsOpenMap Quotient.mk'","name":"isOpenMap_quotient_mk'_mul","isProp":true,"docString":"The quotient map by a group action is open, i.e. the quotient by a group action is an open\nquotient. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {p : Filter Œπ} {g : (a : Œπ) ‚Üí Œ≤} {b : Œ≤}\n  (hg : Filter.Tendsto g p (nhds b)) (s : Set Œ±), TendstoUniformlyOn (fun (n : Œπ) (x : Œ±) ‚Ü¶ g n) (fun (x : Œ±) ‚Ü¶ b) p s","name":"Filter.Tendsto.tendstoUniformlyOn_const","isProp":true,"docString":"If a sequence `g` converges to some `b`, then the sequence of constant functions\n`Œª n, Œª a, g n` converges to the constant function `Œª a, b` on any set `s` "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±}, (UniformEquicontinuous F : Prop) ‚Üî (UniformEquicontinuous Subtype.val : Prop)","name":"uniformEquicontinuous_at_iff_range","isProp":true,"docString":"A family `ùìï : Œπ ‚Üí Œ≤ ‚Üí Œ±` is uniformly equicontinuous iff `range ùìï` is uniformly equicontinuous,\ni.e the family `(‚Üë) : range F ‚Üí Œ≤ ‚Üí Œ±` is uniformly equicontinuous. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFiltered C] (O : Finset C)\n  (H : Finset ((X : C) √ó' (Y : C) √ó' (_ : X ‚àà O) √ó' (_ : Y ‚àà O) √ó' (X ‚ü∂ Y))),\n  ‚àÉ (S : C),\n    ‚àÉ (T : {X : C} ‚Üí (a : X ‚àà O) ‚Üí X ‚ü∂ S),\n      ‚àÄ {X : C} {Y : C} (mX : X ‚àà O) (mY : Y ‚àà O) {f : X ‚ü∂ Y}\n        (a : { fst := X, snd := { fst := Y, snd := { fst := mX, snd := { fst := mY, snd := f } } } } ‚àà H),\n        f ‚â´ T mY = T mX","name":"CategoryTheory.IsFiltered.sup_exists","isProp":true,"docString":"Given any `Finset` of objects `{X, ...}` and\nindexed collection of `Finset`s of morphisms `{f, ...}` in `C`,\nthere exists an object `S`, with a morphism `T X : X ‚ü∂ S` from each `X`,\nsuch that the triangles commute: `f ‚â´ T Y = T X`, for `f : X ‚ü∂ Y` in the `Finset`.\n"},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : Norm E] {a : ùïú} {f : (a : ùïú) ‚Üí E}\n  (h : Filter.IsBoundedUnder (fun (x : ‚Ñù) (x_1 : ‚Ñù) ‚Ü¶ x ‚â§ x_1) (nhdsWithin a ({a}·∂ú)) (norm ‚àò f)),\n  f =o[nhdsWithin a ({a}·∂ú)] fun (x : ùïú) ‚Ü¶ (x - a)‚Åª¬π","name":"Filter.IsBoundedUnder.isLittleO_sub_self_inv","isProp":true,"docString":"If `f : ùïú ‚Üí E` is bounded in a punctured neighborhood of `a`, then `f(x) = o((x - a)‚Åª¬π)` as\n`x ‚Üí a`, `x ‚â† a`. "},{"type":"‚àÄ {n : ‚Ñï} {n' : ‚Ñï} (m : ‚Ñï) (i : Fin n') (h : n' = n),\n  ‚Üë(Fin.castAdd m) (‚Üë(Fin.cast h) i) =\n    ‚Üë(Fin.cast ((congr_arg (fun (x : ‚Ñï) ‚Ü¶ x + m) h=:n' + m = n + m)=:n' + m = n + m)) (‚Üë(Fin.castAdd m) i)","name":"Fin.castAdd_cast","isProp":true,"docString":"For rewriting in the reverse direction, see `Fin.cast_castAdd_left`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±} (a : BddBelow ‚Üë(upperClosure s)), BddBelow s","name":"BddBelow.of_upperClosure","isProp":true,"docString":"**Alias** of the forward direction of `bddBelow_upperClosure`."},{"type":"‚àÄ {Œ± : Type u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : Set Œ±} (a : DirectedOn r s), Directed r Subtype.val","name":"DirectedOn.directed_val","isProp":true,"docString":"**Alias** of the forward direction of `directedOn_iff_directed`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  [inst_3 : NoMaxOrder Œ≤] {u : (a : Œ≤) ‚Üí Œ±} {a : Œ±},\n  (Filter.Tendsto u Filter.atTop (nhds a) : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a_1 : Œµ > 0), ‚àÉ (N : Œ≤), ‚àÄ (n : Œ≤) (a_2 : n > N), dist (u n) a < Œµ : Prop)","name":"Metric.tendsto_at_top'","isProp":true,"docString":"A variant of `tendsto_at_top` that\nuses `‚àÉ N, ‚àÄ n > N, ...` rather than `‚àÉ N, ‚àÄ n ‚â• N, ...`\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] [inst_1 : BoundedOrder Œ±] [self : IsSimpleOrder Œ±] (a : Œ±),\n  (a = ‚ä• : Prop) ‚à® (a = ‚ä§ : Prop)","name":"IsSimpleOrder.eq_bot_or_eq_top","isProp":true,"docString":"Every element is either `‚ä•` or `‚ä§` "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {K : J ‚•§ C}\n  {c : CategoryTheory.Limits.Cocone K} {d : CategoryTheory.Limits.Cocone K} (f : c ‚ü∂ d)\n  [i : CategoryTheory.IsIso (CategoryTheory.Limits.CoconeMorphism.Hom f)], CategoryTheory.IsIso f","name":"CategoryTheory.Limits.Cocones.cocone_iso_of_hom_iso","isProp":true,"docString":"Given a cocone morphism whose object part is an isomorphism, produce an\nisomorphism of cocones.\n"},{"type":"‚àÄ (R : Type u_2) [inst : Semiring R] (M : Type u_1) [inst_1 : AddCommMonoidWithOne M] [inst_2 : CharZero M]\n  [inst_3 : Module R M], CharZero R","name":"CharZero.of_module","isProp":true,"docString":"If `M` is an `R`-module with one and `M` has characteristic zero, then `R` has characteristic\nzero as well. Usually `M` is an `R`-algebra. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedAddCommGroup Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"LinearOrderedAddCommGroup.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {P : (a : Type u) ‚Üí Prop} (of_equiv : ‚àÄ {Œ± : Type u} {Œ≤ : Type u} (a : Œ± ‚âÉ Œ≤) (a : P Œ±), P Œ≤) (h_empty : P PEmpty)\n  (h_option : ‚àÄ {Œ± : Type u} [inst : Fintype Œ±] (a : P Œ±), P (Option Œ±)) (Œ± : Type u) [inst : Finite Œ±], P Œ±","name":"Finite.induction_empty_option","isProp":true,"docString":"An induction principle for finite types, analogous to `Nat.rec`. It effectively says\nthat every `Fintype` is either `Empty` or `Option Œ±`, up to an `Equiv`. "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (h : a % b = c), b ‚à£ a - c","name":"Int.dvd_sub_of_emod_eq","isProp":true,"docString":"If `a % b = c` then `b` divides `a - c`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (xs : List Œ±) (x : Œ±) (d : Œ±) (d' : Œ±) (x_mem : x ‚àà xs)\n  (x_ne : x ‚â† List.getLast xs ((List.ne_nil_of_mem x_mem=:xs ‚â† [])=:xs ‚â† [])), List.nextOr xs x d = List.nextOr xs x d'","name":"List.nextOr_eq_nextOr_of_mem_of_ne","isProp":true,"docString":"`nextOr` does not depend on the default value, if the next value appears. "},{"type":"‚àÄ {H : Type u} [inst : TopologicalSpace H] (G : StructureGroupoid H),\n  LocalHomeomorph.refl H ‚àà StructureGroupoid.maximalAtlas H G","name":"StructureGroupoid.id_mem_maximalAtlas","isProp":true,"docString":"In the model space, the identity is in any maximal atlas. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : IsPredArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc m n), r i (Order.pred i))\n  (hnm : m < n), Relation.TransGen r n m","name":"transGen_of_pred_of_gt","isProp":true,"docString":"For `m < n`, `(n, m)` is in the transitive closure of a relation `~` for `n ‚â† m` if `i ~ pred i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ {Œ± : Type u} [self : Semiring Œ±] (x : Œ±), Semiring.npow 0 x = 1","name":"Semiring.npow_zero","isProp":true,"docString":"Raising to the power `(0 : ‚Ñï)` gives `1`. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] ‚¶És : Set M‚¶Ñ ‚¶Ét : Set M‚¶Ñ (h : s ‚äÜ t), Submonoid.closure s ‚â§ Submonoid.closure t","name":"Submonoid.closure_mono","isProp":true,"docString":"Submonoid closure of a set is monotone in its argument: if `s ‚äÜ t`,\nthen `closure s ‚â§ closure t`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.StrongEpiCategory C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.Epi f], CategoryTheory.StrongEpi f","name":"CategoryTheory.StrongEpiCategory.strongEpi_of_epi","isProp":true,"docString":"A strong epi category is a category in which every epimorphism is strong. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : DecidableEq Œ≤] (s : Finset Œ≤) (b : Œ≤),\n  Finset.filter (Eq b) s = if (b ‚àà s : Prop) then {b} else ‚àÖ","name":"Finset.filter_eq","isProp":true,"docString":"After filtering out everything that does not equal a given value, at most that value remains.\n\nThis is equivalent to `filter_eq'` with the equality the other way.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [tŒ± : TopologicalSpace Œ±] [tŒ≤ : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : Inducing f), tŒ± = TopologicalSpace.induced f tŒ≤","name":"Inducing.induced","isProp":true,"docString":"The topology on the domain is equal to the induced topology. "},{"type":"‚àÄ {Œ± : Type u_1} {r : Setoid Œ±} {s : Setoid Œ±}, Setoid.Rel (r ‚äì s) = Setoid.Rel r ‚äì Setoid.Rel s","name":"Setoid.inf_def","isProp":true,"docString":"The infimum of 2 equivalence relations r and s is the same relation as the infimum\nof the underlying binary operations. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±), a * (b + c) = a * b + a * c","name":"CanonicallyOrderedCommSemiring.left_distrib","isProp":true,"docString":"Multiplication is left distributive over addition "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {m : ‚Ñï} {n : ‚Ñï} (s : Affine.Simplex k P m) (e : Fin (n + 1) ‚âÉ Fin (m + 1)),\n  Affine.Simplex.reindex (Affine.Simplex.reindex s (Equiv.symm e)) e = s","name":"Affine.Simplex.reindex_symm_reindex","isProp":true,"docString":"Reindexing by the inverse of an equivalence and that equivalence yields the original simplex. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Fin (n + 1)) ‚Üí Œ±},\n  (Antitone f : Prop) ‚Üî (‚àÄ (i : Fin n), f (Fin.succ i) ‚â§ f (‚ÜëFin.castSucc i) : Prop)","name":"Fin.antitone_iff_succ_le","isProp":true,"docString":"A function `f` on `Fin (n + 1)` is antitone if and only if `f (i + 1) ‚â§ f i` for all `i`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P} {v : V},\n  (v +·µ• p‚ÇÇ ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ} : Prop) ‚Üî (‚àÉ (r : k), r ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ) = v : Prop)","name":"vadd_right_mem_affineSpan_pair","isProp":true,"docString":"A vector added to the second point lies in the affine span of two points if and only if it is\na multiple of their difference. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {s : Submodule K V} (h : s < ‚ä§),\n  FiniteDimensional.finrank K { x : V // x ‚àà s } < FiniteDimensional.finrank K V","name":"Submodule.finrank_lt","isProp":true,"docString":"The dimension of a strict submodule is strictly bounded by the dimension of the ambient\nspace. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : LocallyConnectedSpace Œ±] (x : Œ±),\n  Filter.HasBasis (nhds x) (fun (s : Set Œ±) ‚Ü¶ (IsOpen s : Prop) ‚àß ((x ‚àà s : Prop) ‚àß (IsConnected s : Prop) : Prop)) id","name":"LocallyConnectedSpace.open_connected_basis","isProp":true,"docString":"Open connected neighborhoods form a basis of the neighborhoods filter. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (a : ConvexOn ùïú s f), ConcaveOn ùïú s (-f)","name":"ConvexOn.neg","isProp":true,"docString":"**Alias** of the reverse direction of `neg_concaveOn_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {e' : LocalHomeomorph Œ± Œ≤} (h : e ‚âà e'),\n  Set.EqOn (‚Üë(LocalHomeomorph.symm e)) (‚Üë(LocalHomeomorph.symm e')) (LocalEquiv.target (LocalHomeomorph.toLocalEquiv e))","name":"LocalHomeomorph.EqOnSource.symm_eqOn_target","isProp":true,"docString":"Two equivalent local homeomorphisms have coinciding `invFun` on the target "},{"type":"‚àÄ (a : Ordinal), Ordinal.lift a = a","name":"Ordinal.lift_uzero","isProp":true,"docString":"An ordinal lifted to the zero universe equals itself. "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedRing R] (a : R), 0 ‚â§ a ^ 2","name":"pow_two_nonneg","isProp":true,"docString":"**Alias** of `sq_nonneg`."},{"type":"‚àÄ {Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hf : Function.IsFixedPt f x) (n : ‚Ñï), Function.IsFixedPt (f^[n]) x","name":"Function.IsFixedPt.iterate","isProp":true,"docString":"If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedCommRing Œ±] (x : Œ±) (y : Œ±), x * y = y * x","name":"NormedCommRing.mul_comm","isProp":true,"docString":"Multiplication is commutative. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [self : CategoryTheory.SplitMonoCategory C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.Mono f], CategoryTheory.IsSplitMono f","name":"CategoryTheory.SplitMonoCategory.isSplitMono_of_mono","isProp":true,"docString":"All monos are split "},{"type":"‚àÄ {R : Type u_2} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N' : Type u_4}\n  [inst_3 : AddCommGroup N'] [inst_4 : Module R N'] {Œπ : Type u_1} [inst_5 : DecidableEq Œπ] [inst_6 : Fintype Œπ]\n  (a : AlternatingMap R M N' Œπ), ‚ÜëMultilinearMap.alternatization ‚Üëa = Nat.factorial (Fintype.card Œπ) ‚Ä¢ a","name":"AlternatingMap.coe_alternatization","isProp":true,"docString":"Alternatizing a multilinear map that is already alternating results in a scale factor of `n!`,\nwhere `n` is the number of inputs. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCancelCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : SMul ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (hf : StrictConvexOn ùïú s f) (c : E), StrictConvexOn ùïú ((fun (z : E) ‚Ü¶ c + z) ‚Åª¬π' s) (f ‚àò fun (z : E) ‚Ü¶ c + z)","name":"StrictConvexOn.translate_right","isProp":true,"docString":"Right translation preserves strict convexity. "},{"type":"‚àÄ (a : ‚Ñï) (b : ‚Ñï) (ha : a ‚â† 0) (hb : b ‚â† 0),\n  (a = b : Prop) ‚Üî (‚àÄ (p : ‚Ñï) (a_1 : Nat.Prime p), padicValNat p a = padicValNat p b : Prop)","name":"Nat.eq_iff_prime_padicValNat_eq","isProp":true,"docString":"Two positive naturals are equal if their prime padic valuations are equal "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CommMonoid Œ±] [inst_1 : CommMonoid Œ≤] {n : ‚Ñï},\n  FreimanHomClass (Œ± ‚Üí* Œ≤) Set.univ Œ≤ n","name":"MonoidHom.freimanHomClass","isProp":true,"docString":"A monoid homomorphism is naturally a `FreimanHom` on its entire domain.\n\nWe can't leave the domain `A : Set Œ±` of the `FreimanHom` a free variable, since it wouldn't be\ninferrable. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (hs : IsCompact s) {p : (a : Set Œ±) ‚Üí Prop} (he : p ‚àÖ)\n  (hmono : ‚àÄ ‚¶És : Set Œ±‚¶Ñ ‚¶Ét : Set Œ±‚¶Ñ (a : s ‚äÜ t) (a : p t), p s)\n  (hunion : ‚àÄ ‚¶És : Set Œ±‚¶Ñ ‚¶Ét : Set Œ±‚¶Ñ (a : p s) (a : p t), p (s ‚à™ t))\n  (hnhds : ‚àÄ (x : Œ±) (a : x ‚àà s), ‚àÉ (t : Set Œ±), (t ‚àà nhdsWithin x s : Prop) ‚àß (p t : Prop)), p s","name":"IsCompact.induction_on","isProp":true,"docString":"If `p : Set Œ± ‚Üí Prop` is stable under restriction and union, and each point `x`\nof a compact set `s` has a neighborhood `t` within `s` such that `p t`, then `p s` holds. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G]\n  [inst_3 : NoncompactSpace G] {K : Set G} {L : Set G} (hK : IsCompact K) (hL : IsCompact L),\n  ‚àÉ (g : G), Disjoint K (g +·µ• L)","name":"exists_disjoint_vadd_of_isCompact","isProp":true,"docString":"Given two compact sets in a noncompact additive topological group, there is a\ntranslate of the second one that is disjoint from the first one."},{"type":"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (œÉ : Equiv.Perm n)\n  (M : Matrix n n R), (Matrix.det fun (i : n) ‚Ü¶ M (‚ÜëœÉ i)) = ‚Üë‚Üë(‚ÜëEquiv.Perm.sign œÉ) * Matrix.det M","name":"Matrix.det_permute","isProp":true,"docString":"Permuting the columns changes the sign of the determinant. "},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], CompleteSpace (TopologicalSpace.Closeds Œ±)","name":"EMetric.Closeds.completeSpace","isProp":true,"docString":"In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. "},{"type":"Filter.Tendsto Int.cast Filter.cofinite (Filter.cocompact ‚Ñù)","name":"Int.tendsto_coe_cofinite","isProp":true,"docString":"Under the coercion from `‚Ñ§` to `‚Ñù`, inverse images of compact sets are finite. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚äî b = b), a ‚â§ b","name":"le_of_sup_eq","isProp":true,"docString":"**Alias** of the forward direction of `sup_eq_right`."},{"type":"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)} (H : ‚àÄ (a : Œ±), ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà c), a ‚àà b) {x : Œ±} {b : Set Œ±}\n  {b' : Set Œ±} (hc : b ‚àà c) (hb : x ‚àà b) (hc' : b' ‚àà c) (hb' : x ‚àà b'), b = b'","name":"Setoid.eq_of_mem_eqv_class","isProp":true,"docString":"If x ‚àà Œ± is in 2 elements of a set of sets partitioning Œ±, those 2 sets are equal. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p1 : P} {p2 : P} (hp1 : p1 ‚àà s) (hp2 : p2 ‚àà s), p1 -·µ• p2 ‚àà vectorSpan k s","name":"vsub_mem_vectorSpan","isProp":true,"docString":"Each pairwise difference is in the `vectorSpan`. "},{"type":"‚àÄ {a : ENNReal} {b : ENNReal} {c : ENNReal} (hle : a ‚â§ b + c) (hb : ‚àÄ (a_1 : b = ‚ä§), a = ‚ä§)\n  (hc : ‚àÄ (a_1 : c = ‚ä§), a = ‚ä§), ENNReal.toReal a ‚â§ ENNReal.toReal b + ENNReal.toReal c","name":"ENNReal.toReal_le_add'","isProp":true,"docString":"If `a ‚â§ b + c` and `a = ‚àû` whenever `b = ‚àû` or `c = ‚àû`, then\n`ENNReal.toReal a ‚â§ ENNReal.toReal b + ENNReal.toReal c`. This lemma is useful to transfer\ntriangle-like inequalities from `ENNReal`s to `Real`s. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (x : Œ±) (y : Œ±) (z : Œ±), edist x y ‚â§ edist z x + edist z y","name":"edist_triangle_left","isProp":true,"docString":"Triangle inequality for the extended distance "},{"type":"‚àÄ {Œ± : Type u_1} {r : semiOutParam ((a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop)} {s : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n  [self : IsNonstrictStrictOrder Œ± r s] (a : Œ±) (b : Œ±),\n  (s a b : Prop) ‚Üî ((r a b : Prop) ‚àß (¬¨(r b a : Prop) : Prop) : Prop)","name":"IsNonstrictStrictOrder.right_iff_left_not_left","isProp":true,"docString":"The relation `r` is the nonstrict relation corresponding to the strict relation `s`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : SigmaCompactSpace Œ±] {Œπ : Type u_1} {f : (a : Œπ) ‚Üí Set Œ±}\n  (hf : LocallyFinite f) (hne : ‚àÄ (i : Œπ), Set.Nonempty (f i)), Set.Countable Set.univ","name":"LocallyFinite.countable_univ","isProp":true,"docString":"If `Œ±` is a `œÉ`-compact space, then a locally finite family of nonempty sets of `Œ±` can have\nonly countably many elements, `Set.Countable` version. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±], ParacompactSpace Œ±","name":"EMetric.instParacompactSpaceToTopologicalSpaceToUniformSpace","isProp":true,"docString":"A `PseudoEMetricSpace` is always a paracompact space. Formalization is based\non [MR0236876]. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {Œ≥ : Type u_3} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : T2Space Œ±] [inst_3 : Encodable Œ≥] [inst_4 : CompleteLattice Œ≤] (m : (a : Œ≤) ‚Üí Œ±) (m0 : m ‚ä• = 0)\n  (s : (a : Œ≥) ‚Üí Œ≤),\n  (tsum fun (i : ‚Ñï) ‚Ü¶ m (sup·µ¢ fun (b : Œ≥) ‚Ü¶ sup·µ¢ fun (h : b ‚àà Encodable.decode‚ÇÇ Œ≥ i) ‚Ü¶ s b)) =\n    tsum fun (b : Œ≥) ‚Ü¶ m (s b)","name":"tsum_sup·µ¢_decode‚ÇÇ","isProp":true,"docString":"You can compute a sum over an encodably type by summing over the natural numbers and\ntaking a supremum. This is useful for outer measures. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {A : C} {g : Y ‚ü∂ Z} {a‚ÇÅ : A ‚ü∂ Y} {a‚ÇÇ : A ‚ü∂ Y}\n  (h : CategoryTheory.IsKernelPair g a‚ÇÅ a‚ÇÇ) (f : X ‚ü∂ Z) [inst_1 : CategoryTheory.Limits.HasPullback f g]\n  [inst_2 : CategoryTheory.Limits.HasPullback f (a‚ÇÅ ‚â´ g)],\n  CategoryTheory.IsKernelPair CategoryTheory.Limits.pullback.fst\n    (CategoryTheory.Limits.pullback.map f (a‚ÇÅ ‚â´ g) f g (ùüô X) a‚ÇÅ (ùüô Z)\n      ((of_eq_true\n            ((Eq.trans\n                  ((congr\n                        ((congrArg Eq\n                              ((CategoryTheory.Category.comp_id\n                                    f=:f ‚â´ ùüô Z = f)=:f ‚â´ ùüô Z = f)=:Eq (f ‚â´ ùüô Z) = Eq f)=:Eq (f ‚â´ ùüô Z) = Eq f)\n                        ((CategoryTheory.Category.id_comp\n                              f=:ùüô X ‚â´ f =\n                              f)=:ùüô X ‚â´ f =\n                            f)=:(f ‚â´ ùüô Z = ùüô X ‚â´ f : Prop) =\n                        (f = f : Prop))=:(f ‚â´ ùüô Z = ùüô X ‚â´ f : Prop) = (f = f : Prop))\n                  ((eq_self\n                        f=:(f = f : Prop) =\n                        (True :\n                          Prop))=:(f = f : Prop) =\n                      (True :\n                        Prop))=:(f ‚â´ ùüô Z = ùüô X ‚â´ f : Prop) =\n                  (True : Prop))=:(f ‚â´ ùüô Z = ùüô X ‚â´ f : Prop) = (True : Prop))=:f ‚â´ ùüô Z = ùüô X ‚â´ f)=:f ‚â´ ùüô Z = ùüô X ‚â´ f)\n      ((CategoryTheory.Category.comp_id (a‚ÇÅ ‚â´ g)=:(a‚ÇÅ ‚â´ g) ‚â´ ùüô Z = a‚ÇÅ ‚â´ g)=:(a‚ÇÅ ‚â´ g) ‚â´ ùüô Z = a‚ÇÅ ‚â´ g))\n    (CategoryTheory.Limits.pullback.map f (a‚ÇÅ ‚â´ g) f g (ùüô X) a‚ÇÇ (ùüô Z)\n      ((of_eq_true\n            ((Eq.trans\n                  ((congr\n                        ((congrArg Eq\n                              ((CategoryTheory.Category.comp_id\n                                    f=:f ‚â´ ùüô Z = f)=:f ‚â´ ùüô Z = f)=:Eq (f ‚â´ ùüô Z) = Eq f)=:Eq (f ‚â´ ùüô Z) = Eq f)\n                        ((CategoryTheory.Category.id_comp\n                              f=:ùüô X ‚â´ f =\n                              f)=:ùüô X ‚â´ f =\n                            f)=:(f ‚â´ ùüô Z = ùüô X ‚â´ f : Prop) =\n                        (f = f : Prop))=:(f ‚â´ ùüô Z = ùüô X ‚â´ f : Prop) = (f = f : Prop))\n                  ((eq_self\n                        f=:(f = f : Prop) =\n                        (True :\n                          Prop))=:(f = f : Prop) =\n                      (True :\n                        Prop))=:(f ‚â´ ùüô Z = ùüô X ‚â´ f : Prop) =\n                  (True : Prop))=:(f ‚â´ ùüô Z = ùüô X ‚â´ f : Prop) = (True : Prop))=:f ‚â´ ùüô Z = ùüô X ‚â´ f)=:f ‚â´ ùüô Z = ùüô X ‚â´ f)\n      ((Eq.trans ((CategoryTheory.Category.comp_id (a‚ÇÅ ‚â´ g)=:(a‚ÇÅ ‚â´ g) ‚â´ ùüô Z = a‚ÇÅ ‚â´ g)=:(a‚ÇÅ ‚â´ g) ‚â´ ùüô Z = a‚ÇÅ ‚â´ g)\n            ((CategoryTheory.CommSq.w\n                  ((CategoryTheory.IsPullback.toCommSq\n                        h=:CategoryTheory.CommSq a‚ÇÅ a‚ÇÇ g\n                        g)=:CategoryTheory.CommSq a‚ÇÅ a‚ÇÇ g\n                      g)=:a‚ÇÅ ‚â´ g = a‚ÇÇ ‚â´ g)=:a‚ÇÅ ‚â´ g = a‚ÇÇ ‚â´ g)=:(a‚ÇÅ ‚â´ g) ‚â´ ùüô Z = a‚ÇÇ ‚â´ g)=:(a‚ÇÅ ‚â´ g) ‚â´ ùüô Z = a‚ÇÇ ‚â´ g))","name":"CategoryTheory.IsKernelPair.pullback","isProp":true,"docString":"If `a‚ÇÅ a‚ÇÇ : A ‚ü∂ Y` is a kernel pair for `g : Y ‚ü∂ Z`, then `a‚ÇÅ √ó[Z] X` and `a‚ÇÇ √ó[Z] X`\n(`A √ó[Z] X ‚ü∂ Y √ó[Z] X`) is a kernel pair for `Y √ó[Z] X ‚ü∂ X`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±],\n  Filter.HasBasis (uniformity Œ±) (fun (x : ‚Ñù) ‚Ü¶ 0 < x) fun (Œµ : ‚Ñù) ‚Ü¶\n    setOf fun (p : Œ± √ó Œ±) ‚Ü¶ dist (Prod.fst p) (Prod.snd p) ‚â§ Œµ","name":"Metric.uniformity_basis_dist_le","isProp":true,"docString":"Contant size closed neighborhoods of the diagonal form a basis\nof the uniformity filter. "},{"type":"‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c + a ‚â§ c + b","name":"StrictOrderedSemiring.add_le_add_left","isProp":true,"docString":"Addition is monotone in an ordered cancellative additive commutative monoid. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : PolishSpace Œ±] {s : Set Œ±} (hs : IsClosed s), PolishSpace ‚Üës","name":"IsClosed.polishSpace","isProp":true,"docString":"A closed subset of a Polish space is also Polish. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] [inst_3 : MulPosMono Œ±]\n  (ha : a ‚â§ 1) (hb : b ‚â§ 1) (b0 : 0 ‚â§ b), a * b ‚â§ 1","name":"Right.mul_le_one_of_le_of_le","isProp":true,"docString":"Assumes right covariance. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} (a : Finset.Nonempty s), Finset.Nonempty (Finset.sym2 s)","name":"Finset.nonempty.sym2","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.sym2_nonempty`."},{"type":"‚àÄ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] (abv : AbsoluteValue R S),\n  IsAbsoluteValue ‚Üëabv","name":"AbsoluteValue.isAbsoluteValue","isProp":true,"docString":"A bundled absolute value is an absolute value. "},{"type":"‚àÄ {Œπ : Sort u_2} {M : Type u_1} [inst : Add M] (S : (a : Œπ) ‚Üí AddSubsemigroup M)\n  {C : (x : M) ‚Üí (a : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) ‚Üí Prop}\n  (hp :\n    ‚àÄ (i : Œπ) (x : M) (hxS : x ‚àà S i),\n      C x ((AddSubsemigroup.mem_sup·µ¢_of_mem i hxS=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (hmul :\n    ‚àÄ (x : M) (y : M) (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hy : y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (a : C x hx) (a : C y hy),\n      C (x + y) ((add_mem hx hy=:x + y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x + y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  {x‚ÇÅ : M} (hx‚ÇÅ : x‚ÇÅ ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i), C x‚ÇÅ hx‚ÇÅ","name":"AddSubsemigroup.sup·µ¢_induction'","isProp":true,"docString":"A dependent version of `AddSubsemigroup.sup·µ¢_induction`."},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Sup Œ±] [inst_1 : Sup Œ≤]\n  [self : SupHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a ‚äî b) = ‚Üëf a ‚äî ‚Üëf b","name":"SupHomClass.map_sup","isProp":true,"docString":"A `SupHomClass` morphism preserves suprema. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} (f : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ≤) (b : Œ≤), Vector.scanl f b Vector.nil = b ::·µ• Vector.nil","name":"Vector.scanl_nil","isProp":true,"docString":"Providing an empty vector to `scanl` gives the starting value `b : Œ≤`. "},{"type":"‚àÄ {n : ‚Ñï} {p : ‚Ñï}, List.count p (Nat.factors n) = ‚Üë(Nat.factorization n) p","name":"Nat.factors_count_eq","isProp":true,"docString":"We can write both `n.factorization p` and `n.factors.count p` to represent the power\nof `p` in the factorization of `n`: we declare the former to be the simp-normal form. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasFiniteWidePullbacks C] (J : Type)\n  [inst_1 : Fintype J], CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WidePullbackShape J) C","name":"CategoryTheory.Limits.HasFiniteWidePullbacks.out","isProp":true,"docString":"`C` has all wide pullbacks any Fintype `J`"},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±], Function.Injective Equiv.Perm.cycleFactorsFinset","name":"Equiv.Perm.cycleFactorsFinset_injective","isProp":true,"docString":"Two permutations `f g : perm Œ±` have the same cycle factors iff they are the same. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : (a : Œ±) ‚Üí Œ≤) (s : Set Œ±) (hs : Set.Nontrivial (f '' s)), Set.Nontrivial s","name":"Set.nontrivial_of_image","isProp":true,"docString":"If the image of a set is nontrivial, the set is nontrivial. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±},\n  (s ‚àà Finset.shadow ùíú : Prop) ‚Üî\n    (‚àÉ (t : Finset Œ±), (t ‚àà ùíú : Prop) ‚àß (‚àÉ (a : Œ±), (a ‚àà t : Prop) ‚àß (Finset.erase t a = s : Prop) : Prop) : Prop)","name":"Finset.mem_shadow_iff","isProp":true,"docString":"`s` is in the shadow of `ùíú` iff there is an `t ‚àà ùíú` from which we can remove one element to\nget `s`. "},{"type":"‚àÄ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : RegularSpace Y]\n  {f : (a : X) ‚Üí Y} {A : Set X} (hA : Dense A) (hf : ‚àÄ (x : X), ‚àÉ (y : Y), Filter.Tendsto f (nhdsWithin x A) (nhds y)),\n  Continuous (extendFrom A f)","name":"continuous_extendFrom","isProp":true,"docString":"If a function `f` to a T‚ÇÉ space `Y` has a limit within a\ndense set `A` for any `x`, then `extendFrom A f` is continuous. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (e : LocalHomeomorph Œ± Œ≤)\n  (s : Set Œ≤),\n  LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© ‚Üëe ‚Åª¬π' interior s =\n    LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© interior (‚Üëe ‚Åª¬π' s)","name":"LocalHomeomorph.preimage_interior","isProp":true,"docString":"Preimage of interior or interior of preimage coincide for local homeomorphisms, when restricted\nto the source. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R‚ÇÅ : CategoryTheory.Presieve X}\n  {R‚ÇÇ : CategoryTheory.Presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ) {x : CategoryTheory.Presieve.FamilyOfElements P R‚ÇÇ}\n  (a : CategoryTheory.Presieve.FamilyOfElements.Compatible x),\n  CategoryTheory.Presieve.FamilyOfElements.Compatible (CategoryTheory.Presieve.FamilyOfElements.restrict h x)","name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.restrict","isProp":true,"docString":"The restriction of a compatible family is compatible. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J],\n  CategoryTheory.IsConnected J·µí·µñ","name":"CategoryTheory.isConnected_op","isProp":true,"docString":"If `J` is connected, then `J·µí·µñ` is connected as well. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} {t : Set Œ±} (a : s ‚â§ t), s ‚äÜ t","name":"LE.le.subset","isProp":true,"docString":"**Alias** of the forward direction of `Set.le_iff_subset`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}\n  (t : CategoryTheory.Limits.PullbackCone f g) {W : C} {k : W ‚ü∂ CategoryTheory.Limits.Cone.pt t}\n  {l : W ‚ü∂ CategoryTheory.Limits.Cone.pt t}\n  (h‚ÇÄ : k ‚â´ CategoryTheory.Limits.PullbackCone.fst t = l ‚â´ CategoryTheory.Limits.PullbackCone.fst t)\n  (h‚ÇÅ : k ‚â´ CategoryTheory.Limits.PullbackCone.snd t = l ‚â´ CategoryTheory.Limits.PullbackCone.snd t)\n  (j : CategoryTheory.Limits.WalkingCospan),\n  k ‚â´ (CategoryTheory.Limits.Cone.œÄ t).app j = l ‚â´ (CategoryTheory.Limits.Cone.œÄ t).app j","name":"CategoryTheory.Limits.PullbackCone.equalizer_ext","isProp":true,"docString":"To check whether a morphism is equalized by the maps of a pullback cone, it suffices to check\nit for `fst t` and `snd t` "},{"type":"‚àÄ {Œ± : Type u_1} (G : SimpleGraph Œ±) {n : ‚Ñï} (a : SimpleGraph.CliqueFree G n), SimpleGraph.cliqueSet G n = ‚àÖ","name":"SimpleGraph.CliqueFree.cliqueSet","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.cliqueSet_eq_empty_iff`."},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] (x : M‚ÇÄ) (h : ¬¨(IsUnit x : Prop)), Ring.inverse x = 0","name":"Ring.inverse_non_unit","isProp":true,"docString":"By definition, if `x` is not invertible then `inverse x = 0`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : OmegaCompletePartialOrder Œ±] [inst_1 : OmegaCompletePartialOrder Œ≤]\n  (c‚ÇÄ : OmegaCompletePartialOrder.Chain (Œ± ‚ÜíùíÑ Œ≤)) (c‚ÇÅ : OmegaCompletePartialOrder.Chain Œ±) (z : Œ≤),\n  (‚àÄ (i : ‚Ñï) (j : ‚Ñï), ‚Üë(OmegaCompletePartialOrder.ContinuousHom.toOrderHom (‚Üëc‚ÇÄ i)) (‚Üëc‚ÇÅ j) ‚â§ z : Prop) ‚Üî\n    (‚àÄ (i : ‚Ñï), ‚Üë(OmegaCompletePartialOrder.ContinuousHom.toOrderHom (‚Üëc‚ÇÄ i)) (‚Üëc‚ÇÅ i) ‚â§ z : Prop)","name":"OmegaCompletePartialOrder.ContinuousHom.forall_forall_merge","isProp":true,"docString":"When proving that a chain of applications is below a bound `z`, it suffices to consider the\nfunctions and values being selected from the same index in the chains.\n\nThis lemma is more specific than necessary, i.e. `c‚ÇÄ` only needs to be a\nchain of monotone functions, but it is only used with continuous functions. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±},\n  (s ‚àà Finset.upShadow ùíú : Prop) ‚Üî (‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (Finset.erase s a ‚àà ùíú : Prop) : Prop)","name":"Finset.mem_upShadow_iff_erase_mem","isProp":true,"docString":"`t` is in the upper shadow of `ùíú` iff we can remove an element from it so that the resulting\nfinset is in `ùíú`. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {E' : Type u_3} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =o[l] g), f' =o[l] g","name":"Asymptotics.IsLittleO.of_norm_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_norm_left`."},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} (v : List Œ±) (P : List.length v = n), Vector.toList { val := v, property := P } = v","name":"Vector.toList_mk","isProp":true,"docString":"Vector of length from a list `v`\nwith witness that `v` has length `n` maps to `v` under `toList`.  "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedSemifield R] [inst_1 : FloorSemiring R] {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñ§} {r : R}\n  (hr : 0 < r), (r < ‚Üëb ^ x : Prop) ‚Üî (Int.log b r < x : Prop)","name":"Int.lt_zpow_iff_log_lt","isProp":true,"docString":"`zpow b` and `Int.log b` (almost) form a Galois connection. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : EMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Isometry f),\n  Embedding f","name":"Isometry.embedding","isProp":true,"docString":"An isometry from an emetric space is an embedding "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} {M : Type u_3} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {I : Set Œπ}\n  {t : (a : Œπ) ‚Üí Set Œ±} (h : Set.PairwiseDisjoint I t) (hI : Set.Finite I)\n  (ht : ‚àÄ (i : Œπ) (a : i ‚àà I), Set.Finite (t i)),\n  (finsum fun (a : Œ±) ‚Ü¶ finsum fun (h : a ‚àà Set.union·µ¢ fun (x : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà I) ‚Ü¶ t x) ‚Ü¶ f a) =\n    finsum fun (i : Œπ) ‚Ü¶ finsum fun (h : i ‚àà I) ‚Ü¶ finsum fun (j : Œ±) ‚Ü¶ finsum fun (h : j ‚àà t i) ‚Ü¶ f j","name":"finsum_mem_bunion·µ¢","isProp":true,"docString":"Given a family of sets `t : Œπ ‚Üí Set Œ±`, a finite set `I` in the index type such that\nall sets `t i`, `i ‚àà I`, are finite, if all `t i`, `i ‚àà I`, are pairwise disjoint, then the\nsum of `f a` over `a ‚àà ‚ãÉ i ‚àà I, t i` is equal to the sum over `i ‚àà I` of the sums of `f a`\nover `a ‚àà t i`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Isometry f), UniformInducing f","name":"Isometry.uniformInducing","isProp":true,"docString":"An isometry from a metric space is a uniform inducing map "},{"type":"‚àÄ {Œ± : Type u_1} [inst : OrderedSemiring Œ±] [self : FloorSemiring Œ±], GaloisConnection FloorSemiring.ceil Nat.cast","name":"FloorSemiring.gc_ceil","isProp":true,"docString":"`FloorSemiring.ceil` is the lower adjoint of the coercion `‚Üë : ‚Ñï ‚Üí Œ±`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : HeytingAlgebra Œ±] {a : Œ±} {b : Œ±} (a_1 : Disjoint b a), a ‚â§ b·∂ú","name":"Disjoint.le_compl_left","isProp":true,"docString":"**Alias** of the reverse direction of `le_compl_iff_disjoint_left`."},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {a : Œ±} {s : Set Œ±} (h : f a = 0),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà insert a s) ‚Ü¶ f i) = finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i","name":"finsum_mem_insert_zero","isProp":true,"docString":"If `f a = 0`, then the sum of `f i` over `i ‚àà insert a s` equals the sum of `f i`\nover `i ‚àà s`."},{"type":"‚àÄ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} (hbot : H ‚â† ‚ä•)\n  {a : G} (h‚ÇÄ : 0 < a) (hd : Disjoint (‚ÜëH) (Set.Ioo 0 a)),\n  ‚àÉ (b : G), IsLeast (setOf fun (g : G) ‚Ü¶ (g ‚àà H : Prop) ‚àß (0 < g : Prop)) b","name":"AddSubgroup.exists_isLeast_pos","isProp":true,"docString":"If a nontrivial additive subgroup of a linear ordered additive commutative group is disjoint\nwith the interval `Set.Ioo 0 a` for some positive `a`, then the set of positive elements of this\ngroup admits the least element. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±}\n  {b : Œ±} {c : Œ±} [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1],\n  a + c - (b + c) ‚â§ a - b","name":"add_tsub_add_le_tsub_right","isProp":true,"docString":"See `add_tsub_add_eq_tsub_right` for the equality. "},{"type":"‚àÄ {Œ± : Type u_1} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsRefl Œ± r],\n  Set.Nonempty\n    (setOf fun (c : Cardinal) ‚Ü¶\n      ‚àÉ (S : Set Œ±), (‚àÄ (a : Œ±), ‚àÉ (b : Œ±), (b ‚àà S : Prop) ‚àß (r a b : Prop) : Prop) ‚àß (Cardinal.mk ‚ÜëS = c : Prop))","name":"Order.cof_nonempty","isProp":true,"docString":"The set in the definition of `Order.cof` is nonempty. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R],\n  (StrongRankCondition R : Prop) ‚Üî\n    (‚àÄ (n : ‚Ñï) (f : ((a : Fin (n + 1)) ‚Üí R) ‚Üí‚Çó[R] (a : Fin n) ‚Üí R), ¬¨(Function.Injective ‚Üëf : Prop) : Prop)","name":"strongRankCondition_iff_succ","isProp":true,"docString":"A ring satisfies the strong rank condition if and only if, for all `n : ‚Ñï`, any linear map\n`(Fin (n + 1) ‚Üí R) ‚Üí‚Çó[R] (Fin n ‚Üí R)` is not injective. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsPreconnected s : Prop) ‚Üî\n    (‚àÄ (u : Set Œ±) (v : Set Œ±) (a : IsOpen u) (a : IsOpen v) (a : s ‚äÜ u ‚à™ v) (a : s ‚à© (u ‚à© v) = ‚àÖ),\n        (s ‚äÜ u : Prop) ‚à® (s ‚äÜ v : Prop) :\n      Prop)","name":"isPreconnected_iff_subset_of_disjoint","isProp":true,"docString":"A set `s` is preconnected if and only if for every cover by two open sets that are disjoint on\n`s`, it is contained in one of the two covering sets. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A * C) * Finset.card B ‚â§ Finset.card (A * B) * Finset.card (B / C)","name":"Finset.card_mul_mul_le_card_mul_mul_card_div","isProp":true,"docString":"**Ruzsa's triangle inequality**. Mul-mul-div version. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] {f : OneHom M N} {g : OneHom M N} (h : f = g) (x : M),\n  ‚Üëf x = ‚Üëg x","name":"OneHom.congr_fun","isProp":true,"docString":"Deprecated: use `FunLike.congr_fun` instead. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : TopologicalSpace ùïú] [inst_1 : OrderedRing ùïú] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ùïú E] {A : Set E} {B : Set E} (hAB : IsExposed ùïú A B)\n  (hB : Set.Nonempty B), ‚àÉ (l : E ‚ÜíL[ùïú] ùïú), ‚àÉ (a : ùïú), B = setOf fun (x : E) ‚Ü¶ (x ‚àà A : Prop) ‚àß (a ‚â§ ‚Üël x : Prop)","name":"IsExposed.eq_inter_halfspace'","isProp":true,"docString":"If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. "},{"type":"‚àÄ {R : Type u} [inst : EuclideanDomain R] [inst_1 : DecidableEq R] (a : R) (b : R),\n  EuclideanDomain.gcd a b = a * EuclideanDomain.gcdA a b + b * EuclideanDomain.gcdB a b","name":"EuclideanDomain.gcd_eq_gcd_ab","isProp":true,"docString":"An explicit version of **B√©zout's lemma** for Euclidean domains. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {Œ± : Type u_3} [inst : SMul M N] [inst_1 : SMul N Œ±] [inst_2 : SMul M Œ±]\n  [self : IsScalarTower M N Œ±] (x : M) (y : N) (z : Œ±), (x ‚Ä¢ y) ‚Ä¢ z = x ‚Ä¢ y ‚Ä¢ z","name":"IsScalarTower.smul_assoc","isProp":true,"docString":"Associativity of `‚Ä¢` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Inv Œ±] {s : Finset Œ±} (a : Finset.Nonempty s‚Åª¬π), Finset.Nonempty s","name":"Finset.Nonempty.of_inv","isProp":true,"docString":"**Alias** of the forward direction of `Finset.inv_nonempty_iff`."},{"type":"‚àÄ {k : Type u_3} {V : Type u_4} {P : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) {s‚ÇÅ : Finset Œπ} {s‚ÇÇ : Finset Œπ} (h : s‚ÇÅ ‚äÜ s‚ÇÇ),\n  ‚Üë(Finset.affineCombination k s‚ÇÅ p) w = ‚Üë(Finset.affineCombination k s‚ÇÇ p) (Set.indicator (‚Üës‚ÇÅ) w)","name":"Finset.affineCombination_indicator_subset","isProp":true,"docString":"An affine combination is unaffected by changing the weights to the\ncorresponding indicator function and adding points to the set. "},{"type":"‚àÄ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1)","name":"QuotientGroup.nhds_one_isCountablyGenerated","isProp":true,"docString":"In a first countable topological group `G` with normal subgroup `N`, `1 : G ‚ß∏ N` has a\ncountable neighborhood basis. "},{"type":"‚àÄ {G : Type u_2} {P : Type u_1} [inst : AddGroup G] [T : AddTorsor G P] (p1 : P) (g : G) (p2 : P),\n  (p1 = g +·µ• p2 : Prop) ‚Üî (p1 -·µ• p2 = g : Prop)","name":"eq_vadd_iff_vsub_eq","isProp":true,"docString":"Convert between an equality with adding a group element to a point\nand an equality of a subtraction of two points with a group\nelement. "},{"type":"‚àÄ {M : Type u_2} {P : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {f : M ‚Üí+ P},\n  AddMonoidHom.mrange (AddCon.kerLift f) = AddMonoidHom.mrange f","name":"AddCon.kerLift_range_eq","isProp":true,"docString":"Given an `AddMonoid` homomorphism `f`, the induced homomorphism\non the quotient by `f`'s kernel has the same image as `f`."},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E] {s : Set E}\n  {t : Set E} (hc : ConvexIndependent ùïú Subtype.val) (hs : s ‚äÜ t), ConvexIndependent ùïú Subtype.val","name":"ConvexIndependent.mono","isProp":true,"docString":"A subset of a convex independent set of points is convex independent as well. "},{"type":"‚àÄ {K : Type u_1} [inst : Field K] (f : Polynomial K) (a : K) (hf' : Polynomial.eval a (‚ÜëPolynomial.derivative f) ‚â† 0),\n  IsCoprime (Polynomial.X - ‚ÜëPolynomial.C a) (f /‚Çò (Polynomial.X - ‚ÜëPolynomial.C a))","name":"Polynomial.isCoprime_of_is_root_of_eval_derivative_ne_zero","isProp":true,"docString":"If `f` is a polynomial over a field, and `a : K` satisfies `f' a ‚â† 0`,\nthen `f / (X - a)` is coprime with `X - a`.\nNote that we do not assume `f a = 0`, because `f / (X - a) = (f - f a) / (X - a)`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : PartialOrder Œ±] [inst_3 : ZeroLEOneClass Œ±]\n  [inst_4 : NeZero 1], 0 < 1","name":"one_pos","isProp":true,"docString":"**Alias** of `zero_lt_one`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i) = Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (AntivaryOn (f ‚àò ‚ÜëœÉ) g ‚Üës : Prop)","name":"AntivaryOn.sum_smul_eq_sum_comp_perm_smul_iff","isProp":true,"docString":"**Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which antivary together, is unchanged by a permutation if and only if `f ‚àò œÉ` and `g` antivary\ntogether. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CircularPreorder Œ±] (a : Œ±), btw a a a","name":"CircularPreorder.btw_refl","isProp":true,"docString":"`a` is between `a` and `a`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : D ‚•§ C} (self : CategoryTheory.Adjunction.CoreUnitCounit F G),\n  CategoryTheory.whiskerLeft G (CategoryTheory.Adjunction.CoreUnitCounit.unit self) ‚â´\n      CategoryTheory.Iso.inv (CategoryTheory.Functor.associator G F G) ‚â´\n        CategoryTheory.whiskerRight (CategoryTheory.Adjunction.CoreUnitCounit.counit self) G =\n    CategoryTheory.NatTrans.id (G ‚ãô ùü≠ C)","name":"CategoryTheory.Adjunction.CoreUnitCounit.right_triangle","isProp":true,"docString":"Equality of the composition of the unit, associator, and counit with the identity\n`G ‚ü∂ G (F G) ‚ü∂ (F G) F ‚ü∂ G = NatTrans.id G` "},{"type":"‚àÄ {Œ± : Type u}, DenseInducing pure","name":"denseInducing_pure","isProp":true,"docString":"`pure : Œ± ‚Üí Ultrafilter Œ±` defines a dense inducing of `Œ±` in `Ultrafilter Œ±`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [inst_1 : DiscreteTopology ‚Üës] {x : Œ±} (hx : x ‚àà s),\n  ‚àÉ (U : Set Œ±), (U ‚àà nhds x : Prop) ‚àß (U ‚à© s = {x} : Prop)","name":"nhds_inter_eq_singleton_of_mem_discrete","isProp":true,"docString":"A point `x` in a discrete subset `s` of a topological space admits a neighbourhood\nthat only meets `s` at `x`.  "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {A : Type v} [inst_1 : Semiring A] [inst_2 : Algebra R A] (M : Submodule R A)\n  {C : (a : A) ‚Üí Prop} (hr : ‚àÄ (r : R), C (‚Üë(algebraMap R A) r))\n  (hadd : ‚àÄ (x : A) (y : A) (a : C x) (a : C y), C (x + y)) (hmul : ‚àÄ (x : A) (a : C x) (m : A) (a : m ‚àà M), C (x * m))\n  {x : A} {n : ‚Ñï} (hx : x ‚àà M ^ n), C x","name":"Submodule.pow_induction_on_right","isProp":true,"docString":"To show a property on elements of `M ^ n` holds, it suffices to show that it holds for scalars,\nis closed under addition, and holds for `x * m` where `m ‚àà M` and it holds for `x` "},{"type":"‚àÄ (n : ‚Ñï), Finset.card (Finset.Nat.antidiagonal n) = n + 1","name":"Finset.Nat.card_antidiagonal","isProp":true,"docString":"The cardinality of the antidiagonal of `n` is `n + 1`. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} {x : Œ±},\n  (List.Duplicate x l : Prop) ‚Üî\n    (‚àÉ (n : Fin (List.length l)),\n        ‚àÉ (m : Fin (List.length l)), ‚àÉ (x_1 : n < m), (x = List.get l n : Prop) ‚àß (x = List.get l m : Prop) :\n      Prop)","name":"List.duplicate_iff_exists_distinct_get","isProp":true,"docString":"An element `x : Œ±` of `l : List Œ±` is a duplicate iff it can be found\nat two distinct indices `n m : ‚Ñï` inside the list `l`.\n"},{"type":"‚àÄ {K : Type u} [self : Field K] (a : ‚Ñ§) (b : ‚Ñï) (h1 : b ‚â† 0) (h2 : Nat.coprime (Int.natAbs a) b),\n  ‚Üë(Rat.mk' a b) = ‚Üëa * (‚Üëb)‚Åª¬π","name":"Field.ratCast_mk","isProp":true,"docString":"However `ratCast` is defined, propositionally it must be equal to `a * b‚Åª¬π`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : BoundedOrder Œ±] [inst_2 : IsSimpleOrder Œ±] {a : Œ±} {b : Œ±} (h : a < b),\n  b = ‚ä§","name":"IsSimpleOrder.LT.lt.eq_top","isProp":true,"docString":"**Alias** of `IsSimpleOrder.eq_top_of_lt`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (self : CocompactMap Œ± Œ≤),\n  Filter.Tendsto (ContinuousMap.toFun (CocompactMap.toContinuousMap self)) (Filter.cocompact Œ±) (Filter.cocompact Œ≤)","name":"CocompactMap.cocompact_tendsto'","isProp":true,"docString":"The cocompact filter on `Œ±` tends to the cocompact filter on `Œ≤` under the function "},{"type":"‚àÄ {R : Type u_1} [inst : AddLeftCancelSemigroup R] (g : R), IsAddLeftRegular g","name":"isAddLeftRegular_of_addLeftCancelSemigroup","isProp":true,"docString":"Elements of an add left cancel semigroup are add-left-regular."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±]\n  (h :\n    ‚àÄ (c : Set Œ±) (a : IsChain (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) c) (a : Set.Nonempty c) (a : ¬¨(‚ä§ ‚àà c : Prop)),\n      ‚àÉ (x : Œ±), ‚àÉ (x_1 : x ‚â† ‚ä§), x ‚àà upperBounds c),\n  IsCoatomic Œ±","name":"IsCoatomic.of_isChain_bounded","isProp":true,"docString":"**Zorn's lemma**: A partial order is coatomic if every nonempty chain `c`, `‚ä§ ‚àâ c`, has an upper\nbound not equal to `‚ä§`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (self : Œ± ‚âÉ‚Çú Œ≤),\n  Continuous (Equiv.toFun (Homeomorph.toEquiv self))","name":"Homeomorph.continuous_toFun","isProp":true,"docString":"The forward map of a homeomorphism is a continuous function. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±) (b : Œ±), a * b = b * a","name":"CanonicallyOrderedCommSemiring.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {x : WithTop Œ±}, (x < ‚ä§ : Prop) ‚Üî (x ‚â† ‚ä§ : Prop)","name":"WithTop.lt_top_iff_ne_top","isProp":true,"docString":"A version of `lt_top_iff_ne_top` for `WithTop` that only requires `LT Œ±`, not\n`PartialOrder Œ±`. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : Nonempty J]\n  (h :\n    ‚àÄ {Œ± : Type u‚ÇÅ} (F : (a : J) ‚Üí Œ±) (a : ‚àÄ {j‚ÇÅ : J} {j‚ÇÇ : J} (x : j‚ÇÅ ‚ü∂ j‚ÇÇ), F j‚ÇÅ = F j‚ÇÇ) (j : J) (j' : J),\n      F j = F j'),\n  CategoryTheory.IsConnected J","name":"CategoryTheory.IsConnected.of_constant_of_preserves_morphisms","isProp":true,"docString":"`J` is connected if: given any function `F : J ‚Üí Œ±` which is constant for any\n`j‚ÇÅ, j‚ÇÇ` for which there is a morphism `j‚ÇÅ ‚ü∂ j‚ÇÇ`, then `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse of `constant_of_preserves_morphisms`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} {d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d), a * c < b * d","name":"Right.mul_lt_mul","isProp":true,"docString":"Only assumes right strict covariance. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} {f : M ‚Üí* P}\n  (H : c ‚â§ Con.ker f), MonoidHom.mrange (Con.lift c f H) = MonoidHom.mrange f","name":"Con.lift_range","isProp":true,"docString":"Given a congruence relation `c` on a monoid and a homomorphism `f` constant on `c`'s\nequivalence classes, `f` has the same image as the homomorphism that `f` induces on the\nquotient. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_1} {Œ≥ : Type u_2} [inst : Preorder Œ≤] [inst_1 : Preorder Œ≥] {f : (a : Œ±) ‚Üí Œ≤}\n  {e : (a : Œ≤) ‚Üí Œ≥} {l : Filter Œ±} (hm : ‚àÄ (b‚ÇÅ : Œ≤) (b‚ÇÇ : Œ≤), (e b‚ÇÅ ‚â§ e b‚ÇÇ : Prop) ‚Üî (b‚ÇÅ ‚â§ b‚ÇÇ : Prop))\n  (hu : ‚àÄ (c : Œ≥), ‚àÉ (b : Œ≤), e b ‚â§ c),\n  (Filter.Tendsto (e ‚àò f) l Filter.atBot : Prop) ‚Üî (Filter.Tendsto f l Filter.atBot : Prop)","name":"Filter.tendsto_atBot_embedding","isProp":true,"docString":"A function `f` goes to `-‚àû` independent of an order-preserving embedding `e`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {G‚ÇÄ : Type u_2} [inst : GroupWithZero G‚ÇÄ] [inst_1 : TopologicalSpace G‚ÇÄ]\n  [inst_2 : HasContinuousInv‚ÇÄ G‚ÇÄ] [inst_3 : ContinuousMul G‚ÇÄ] [inst_4 : TopologicalSpace Œ±]\n  [inst_5 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí G‚ÇÄ} {g : (a : Œ±) ‚Üí G‚ÇÄ} (h : (a : Œ±) ‚Üí (a : G‚ÇÄ) ‚Üí Œ≤) (hf : Continuous f)\n  (hg : Continuous g) (hh : ‚àÄ (a : Œ±) (a_1 : g a ‚â† 0), ContinuousAt (‚Üøh) (a, f a / g a))\n  (h2h : ‚àÄ (a : Œ±) (a_1 : g a = 0), Filter.Tendsto (‚Üøh) (Filter.prod (nhds a) ‚ä§) (nhds (h a 0))),\n  Continuous fun (x : Œ±) ‚Ü¶ h x (f x / g x)","name":"Continuous.comp_div_cases","isProp":true,"docString":"`h x (f x / g x)` is continuous under certain conditions, even if the denominator is sometimes\n`0`. See docstring of `ContinuousAt.comp_div_cases`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : OrderedSemiring R] [inst_1 : OrderedAddCommMonoid M] [inst_2 : SMulWithZero R M]\n  [self : OrderedSMul R M] {a : M} {b : M} {c : R} (a_1 : a < b) (a_2 : 0 < c), c ‚Ä¢ a < c ‚Ä¢ b","name":"OrderedSMul.smul_lt_smul_of_pos","isProp":true,"docString":"Scalar multiplication by positive elements preserves the order. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommMonoidWithZero Œ±] (a : Œ±), a * 0 = 0","name":"LinearOrderedCommMonoidWithZero.mul_zero","isProp":true,"docString":"Zero is a right absorbing element for multiplication "},{"type":"‚àÄ (k : Type u_2) (V : Type u_4) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} [inst_4 : Nontrivial k] (p : (a : Œπ) ‚Üí P) (j : Œπ) (q : P),\n  (q ‚àà affineSpan k (Set.range p) : Prop) ‚Üî\n    (‚àÉ (s : Finset Œπ), ‚àÉ (w : (a : Œπ) ‚Üí k), q = ‚Üë(Finset.weightedVSubOfPoint s p (p j)) w +·µ• p j : Prop)","name":"mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd","isProp":true,"docString":"Given a family of points together with a chosen base point in that family, membership of the\naffine span of this family corresponds to an identity in terms of `weightedVSubOfPoint`, with\nweights that are not required to sum to 1. "},{"type":"‚àÄ {M : Type u_2} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_4} [inst_1 : AddCommMonoid N] {P : Type u_3}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P} {T : AddSubmonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_1} [inst_3 : AddCommMonoid Q]\n  {k : AddSubmonoid.LocalizationMap T Q} (z : N),\n  ‚Üë(AddSubmonoid.LocalizationMap.map f hy k) z +\n      ‚Üë(AddSubmonoid.LocalizationMap.toMap k) (‚Üëg ‚Üë(Prod.snd (AddSubmonoid.LocalizationMap.sec f z))) =\n    ‚Üë(AddSubmonoid.LocalizationMap.toMap k) (‚Üëg (Prod.fst (AddSubmonoid.LocalizationMap.sec f z)))","name":"AddSubmonoid.LocalizationMap.map_add_right","isProp":true,"docString":"Given Localization maps `f : M ‚Üí+ N, k : P ‚Üí+ Q` for Submonoids `S, T` respectively, if an\n`AddCommMonoid` homomorphism `g : M ‚Üí+ P` induces a `f.map hy k : N ‚Üí+ Q`, then for all `z : N`,\nwe have `f.map hy k z + k (g y) = k (g x)` where `x : M, y ‚àà S` are such that\n`z + f y = f x`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {k : Filter Œ±} {l : Filter Œ≤} [inst : Filter.IsCountablyGenerated k],\n  (Filter.Tendsto f k l : Prop) ‚Üî\n    (‚àÄ (x : (a : ‚Ñï) ‚Üí Œ±) (a : Filter.Tendsto x Filter.atTop k), Filter.Tendsto (f ‚àò x) Filter.atTop l : Prop)","name":"Filter.tendsto_iff_seq_tendsto","isProp":true,"docString":"An abstract version of continuity of sequentially continuous functions on metric spaces:\nif a filter `k` is countably generated then `Tendsto f k l` iff for every sequence `u`\nconverging to `k`, `f ‚àò u` tends to `l`. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : EMetricSpace Œ≥],\n  uniformity Œ≥ =\n    inf·µ¢ fun (Œµ : ENNReal) ‚Ü¶\n      inf·µ¢ fun (h : Œµ > 0) ‚Ü¶ Filter.principal (setOf fun (p : Œ≥ √ó Œ≥) ‚Ü¶ edist (Prod.fst p) (Prod.snd p) < Œµ)","name":"uniformity_edist","isProp":true,"docString":"Reformulation of the uniform structure in terms of the extended distance "},{"type":"‚àÄ {Œ± : Type u} {u : Ultrafilter (Ultrafilter Œ±)} {x : Ultrafilter Œ±}, (‚Üëu ‚â§ nhds x : Prop) ‚Üî (x = joinM u : Prop)","name":"ultrafilter_converges_iff","isProp":true,"docString":"Every ultrafilter `u` on `Ultrafilter Œ±` converges to a unique\npoint of `Ultrafilter Œ±`, namely `joinM u`. "},{"type":"Fact (1 ‚â§ ‚ä§ : Prop)","name":"fact_one_le_top_ennreal","isProp":true,"docString":"`(1 : ‚Ñù‚â•0‚àû) ‚â§ ‚àû`, recorded as a `Fact` for use with `Lp` spaces. "},{"type":"‚àÄ {R : Type u_1} (M : Type u_2) {a : R} [inst : Monoid R] [inst_1 : MulAction R M] (ua : IsUnit a), IsSMulRegular M a","name":"IsUnit.isSMulRegular","isProp":true,"docString":"A unit is `M`-regular. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} (h : IsClosed s) (hs : Set.Nonempty s),\n  (¬¨(x ‚àà s : Prop) : Prop) ‚Üî (0 < Metric.infDist x s : Prop)","name":"IsClosed.not_mem_iff_infDist_pos","isProp":true,"docString":"Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofiltered C] {D : Type u‚ÇÅ}\n  [inst_2 : CategoryTheory.Category D] {L : C ‚•§ D} {R : D ‚•§ C} (h : L ‚ä£ R), CategoryTheory.IsCofiltered D","name":"CategoryTheory.IsCofiltered.of_left_adjoint","isProp":true,"docString":"If `C` is cofiltered, and we have a functor `L : C ‚•§ D` with a right adjoint,\nthen `D` is cofiltered.\n"},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)} {x : Œ±} {b : Bool},\n  (FreeGroup.Red ((x, b) :: L) [] : Prop) ‚Üî (FreeGroup.Red L [(x, !b)] : Prop)","name":"FreeGroup.Red.cons_nil_iff_singleton","isProp":true,"docString":"If `x` is a letter and `w` is a word such that `xw` reduces to the empty word, then `w` reduces\nto `x‚Åª¬π` "},{"type":"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R) {x : R} {y : R} (hx : x ‚àà s) (hy : y ‚àà s), x - y ‚àà s","name":"Subring.sub_mem","isProp":true,"docString":"A subring is closed under subtraction "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±] {s : Set Œ±} {U : Set (Œ± √ó Œ±)} (hs : Dense s) (hU : U ‚àà uniformity Œ±),\n  (Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà s) ‚Ü¶ UniformSpace.ball x U) = Set.univ","name":"Dense.bunion·µ¢_uniformity_ball","isProp":true,"docString":"The uniform neighborhoods of all points of a dense set cover the whole space. "},{"type":"‚àÄ {b : Ordinal} {o : Ordinal} {x : Ordinal √ó Ordinal} (a : x ‚àà Ordinal.CNF b o), Prod.fst x ‚â§ Ordinal.log b o","name":"Ordinal.CNF_fst_le_log","isProp":true,"docString":"Every exponent in the Cantor normal form `CNF b o` is less or equal to `log b o`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ‚âÉ+* S) (x : R)\n  (y : R), ‚Üëe (x * y) = ‚Üëe x * ‚Üëe y","name":"RingEquiv.map_mul","isProp":true,"docString":"A ring isomorphism preserves multiplication. "},{"type":"‚àÄ {f : (a : ‚Ñï) ‚Üí ‚Ñï} (hf : Function.Injective f), Filter.Tendsto f Filter.atTop Filter.atTop","name":"Function.Injective.nat_tendsto_atTop","isProp":true,"docString":"An injective sequence `f : ‚Ñï ‚Üí ‚Ñï` tends to infinity at infinity. "},{"type":"‚àÄ {Œ± : Type uu} [M : Monoid Œ±] {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (h : l‚ÇÅ ~ l‚ÇÇ) (hc : List.Pairwise Commute l‚ÇÅ),\n  List.prod l‚ÇÅ = List.prod l‚ÇÇ","name":"List.Perm.prod_eq'","isProp":true,"docString":"If elements of a list commute with each other, then their product does not\ndepend on the order of elements. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (G : CategoryTheory.Comonad C)\n  {X : CategoryTheory.Comonad.Coalgebra G} {Y : CategoryTheory.Comonad.Coalgebra G} (f : X ‚ü∂ Y)\n  [h : CategoryTheory.Epi (CategoryTheory.Comonad.Coalgebra.Hom.f f)], CategoryTheory.Epi f","name":"CategoryTheory.Comonad.algebra_epi_of_epi","isProp":true,"docString":"Given a coalgebra morphism whose carrier part is an epimorphism, we get an algebra epimorphism.\n"},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] {M‚ÇÅ' : (a : Œπ) ‚Üí Type u_2} [inst_5 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ' i)]\n  [inst_6 : (i : Œπ) ‚Üí Module R (M‚ÇÅ' i)] {M‚ÇÅ'' : (a : Œπ) ‚Üí Type u_1} [inst_7 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ'' i)]\n  [inst_8 : (i : Œπ) ‚Üí Module R (M‚ÇÅ'' i)] (g : MultilinearMap R M‚ÇÅ'' M‚ÇÇ) (f‚ÇÅ : (i : Œπ) ‚Üí M‚ÇÅ' i ‚Üí‚Çó[R] M‚ÇÅ'' i)\n  (f‚ÇÇ : (i : Œπ) ‚Üí M‚ÇÅ i ‚Üí‚Çó[R] M‚ÇÅ' i),\n  MultilinearMap.compLinearMap (MultilinearMap.compLinearMap g f‚ÇÅ) f‚ÇÇ =\n    MultilinearMap.compLinearMap g fun (i : Œπ) ‚Ü¶ LinearMap.comp (f‚ÇÅ i) (f‚ÇÇ i)","name":"MultilinearMap.compLinearMap_assoc","isProp":true,"docString":"Composing a multilinear map twice with a linear map in each argument is\nthe same as composing with their composition. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.IsFilteredOrEmpty C] ‚¶ÉX : C‚¶Ñ ‚¶ÉY : C‚¶Ñ\n  (f : X ‚ü∂ Y) (g : X ‚ü∂ Y), ‚àÉ (Z : C), ‚àÉ (h : Y ‚ü∂ Z), f ‚â´ h = g ‚â´ h","name":"CategoryTheory.IsFilteredOrEmpty.cocone_maps","isProp":true,"docString":"for every pair of parallel morphisms there exists a morphism to the right\nso the compositions are equal "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] {x : Œ±} {dx : Œ±} {y : Œ±} {dy : Œ±} (h : dy < dx) (hx : 0 < dx),\n  Nonempty ‚Üë(Set.Ico x (x + dx) \\ Set.Ico y (y + dy))","name":"Set.nonempty_Ico_sdiff","isProp":true,"docString":"If we remove a smaller interval from a larger, the result is nonempty "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_1} {Œ≥ : Type u_2} [inst : SemilatticeSup Œ±] [inst_1 : OrderBot Œ±] (s : Finset Œ≤)\n  (t : Finset Œ≥) (f : (a : Œ≤ √ó Œ≥) ‚Üí Œ±),\n  Finset.sup (s √ó·∂† t) f = Finset.sup s fun (i : Œ≤) ‚Ü¶ Finset.sup t fun (i' : Œ≥) ‚Ü¶ f (i, i')","name":"Finset.sup_product_left","isProp":true,"docString":"See also `Finset.product_bunion·µ¢`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {T : CategoryTheory.Monad C} {J : Type u}\n  [inst_1 : CategoryTheory.Category J] (D : J ‚•§ CategoryTheory.Monad.Algebra T)\n  [inst_2 : CategoryTheory.Limits.HasLimit (D ‚ãô CategoryTheory.Monad.forget T)], CategoryTheory.Limits.HasLimit D","name":"CategoryTheory.Monad.hasLimit_of_comp_forget_hasLimit","isProp":true,"docString":"`D ‚ãô forget T` has a limit, then `D` has a limit. "},{"type":"‚àÄ {M : Type u} [self : AddLeftCancelMonoid M] (n : ‚Ñï) (x : M),\n  AddLeftCancelMonoid.nsmul (n + 1) x = x + AddLeftCancelMonoid.nsmul n x","name":"AddLeftCancelMonoid.nsmul_succ","isProp":true,"docString":"Multiplication by `(n + 1 : ‚Ñï)` behaves as expected. "},{"type":"‚àÄ {ùïú : Type u_1} {ùïú' : Type u_2} [inst : NormedField ùïú] [inst_1 : SeminormedRing ùïú'] [self : NormedAlgebra ùïú ùïú'] (r : ùïú)\n  (x : ùïú'), ‚Äñr ‚Ä¢ x‚Äñ ‚â§ ‚Äñr‚Äñ * ‚Äñx‚Äñ","name":"NormedAlgebra.norm_smul_le","isProp":true,"docString":"A normed algebra `ùïú'` over `ùïú` is normed module that is also an algebra.\n\nSee the implementation notes for `Algebra` for a discussion about non-unital algebras. Following\nthe strategy there, a non-unital *normed* algebra can be written as:\n```lean\nvariables [NormedField ùïú] [NonunitalSeminormedRing ùïú']\nvariables [NormedModule ùïú ùïú'] [SMulCommClass ùïú ùïú' ùïú'] [IsScalarTower ùïú ùïú' ùïú']\n```\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteSemilatticeSup Œ±] (s : Set Œ±) (a : Œ±) (a_1 : ‚àÄ (b : Œ±) (a_1 : b ‚àà s), b ‚â§ a),\n  sup‚Çõ s ‚â§ a","name":"CompleteSemilatticeSup.sup‚Çõ_le","isProp":true,"docString":"Any upper bound is more than the set supremum. "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_1} {N : Type u_2} [inst : CommMonoid M] [inst_1 : CommMonoid N] {s : Set Œ±}\n  (f : (a : Œ±) ‚Üí M) (g : M ‚Üí* N) (hs : Set.Finite s),\n  ‚Üëg (finprod fun (j : Œ±) ‚Ü¶ finprod fun (h : j ‚àà s) ‚Ü¶ f j) = finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ ‚Üëg (f i)","name":"MonoidHom.map_finprod_mem","isProp":true,"docString":"Given a monoid homomorphism `g : M ‚Üí* N` and a function `f : Œ± ‚Üí M`, the value of `g` at the\nproduct of `f i` over `i ‚àà s` equals the product of `g (f i)` over `s`. "},{"type":"‚àÄ {œÑ : Type u_2} {Œ± : Type u_3} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤] (f : Filter œÑ) (œï : (a : œÑ) ‚Üí (a : Œ±) ‚Üí Œ≤)\n  (x : Œ±) (y : Œ≤), (y ‚àà omegaLimit f œï {x} : Prop) ‚Üî (MapClusterPt y f fun (t : œÑ) ‚Ü¶ œï t x : Prop)","name":"mem_omegaLimit_singleton_iff_map_cluster_point","isProp":true,"docString":"An element `y` is in the œâ-limit of `x` w.r.t. `f` if the forward\nimages of `x` frequently (w.r.t. `f`) falls within an arbitrary\nneighbourhood of `y`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {f : CategoryTheory.Arrow C} {g : CategoryTheory.Arrow C}\n  [inst_1 : CategoryTheory.Limits.HasImage (CategoryTheory.Comma.hom f)]\n  [inst_2 : CategoryTheory.Limits.HasImage (CategoryTheory.Comma.hom g)] {sq : f ‚ü∂ g}\n  [self : CategoryTheory.Limits.HasImageMap sq], Nonempty (CategoryTheory.Limits.ImageMap sq)","name":"CategoryTheory.Limits.HasImageMap.has_image_map","isProp":true,"docString":"`HasImageMap sq` means that there is an `ImageMap` for the square `sq`. "},{"type":"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : (a : n) ‚Üí Œ±},\n  (Matrix.IsSymm (Matrix.circulant v) : Prop) ‚Üî (‚àÄ (i : n), v (-i) = v i : Prop)","name":"Matrix.circulant_isSymm_iff","isProp":true,"docString":"A circulant of `v` is symmetric iff `v` equals its reverse. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Fin (n + 1)) ‚Üí Œ±},\n  (StrictMono f : Prop) ‚Üî (‚àÄ (i : Fin n), f (‚ÜëFin.castSucc i) < f (Fin.succ i) : Prop)","name":"Fin.strictMono_iff_lt_succ","isProp":true,"docString":"A function `f` on `Fin (n + 1)` is strictly monotone if and only if `f i < f (i + 1)`\nfor all `i`. "},{"type":"‚àÄ {k : Type u_4} {V : Type u_3} {P : Type u_5} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} {Œπ‚ÇÇ : Type u_1} (s‚ÇÇ : Finset Œπ‚ÇÇ) (e : Œπ‚ÇÇ ‚Ü™ Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.weightedVSub (Finset.map e s‚ÇÇ) p) w = ‚Üë(Finset.weightedVSub s‚ÇÇ (p ‚àò ‚Üëe)) (w ‚àò ‚Üëe)","name":"Finset.weightedVSub_map","isProp":true,"docString":"A weighted subtraction, over the image of an embedding, equals a\nweighted subtraction with the same points and weights over the\noriginal `Finset`. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : AddMonoid A] [inst_1 : VAdd R A] [inst_2 : VAddAssocClass R A A]\n  [inst_3 : TopologicalSpace A] [inst : ContinuousAdd A], ContinuousConstVAdd R A","name":"VAddAssocClass.continuousConstVAdd","isProp":true,"docString":"If `R` acts on `A` via `A`, then continuous addition implies\ncontinuous affine addition by constants."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (s : Set Œ≤)\n  (h : ClosedEmbedding f), ClosedEmbedding (Set.restrictPreimage s f)","name":"ClosedEmbedding.restrictPreimage","isProp":true,"docString":"**Alias** of `Set.restrictPreimage_closedEmbedding`."},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) {x : G} {y : G} (hx : x ‚àà H) (hy : y ‚àà H), x - y ‚àà H","name":"AddSubgroup.sub_mem","isProp":true,"docString":"An `AddSubgroup` is closed under subtraction."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±), (l‚ÇÅ ‚â§ l‚ÇÇ : Prop) = (¬¨(l‚ÇÇ < l‚ÇÅ : Prop) : Prop)","name":"List.le_eq_not_gt","isProp":true,"docString":"`‚â§` implies not `>` for lists. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {E' : Type u_3} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =O[l] g), f' =O[l] g","name":"Asymptotics.IsBigO.of_norm_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigO_norm_left`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : PreirreducibleSpace Œ±], IsPreirreducible Set.univ","name":"PreirreducibleSpace.isPreirreducible_univ","isProp":true,"docString":"In a preirreducible space, `Set.univ` is a preirreducible set. "},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E} (hs : Convex ‚Ñù s) {x : E}\n  (hx : x ‚àà interior s) (t : ‚Ñù) (ht : 1 < t), closure s ‚äÜ ‚Üë(AffineMap.homothety x t) '' interior s","name":"Convex.closure_subset_image_homothety_interior_of_one_lt","isProp":true,"docString":"If we dilate the interior of a convex set about a point in its interior by a scale `t > 1`,\nthe result includes the closure of the original set.\n\nTODO Generalise this from convex sets to sets that are balanced / star-shaped about `x`. "},{"type":"‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Preadditive V]\n  {c : ComplexShape Œπ} {C : HomologicalComplex V c} {D : HomologicalComplex V c} {E : HomologicalComplex V c}\n  (hom : (i : Œπ) ‚Üí (j : Œπ) ‚Üí (a : ComplexShape.Rel c j i) ‚Üí HomologicalComplex.X C i ‚ü∂ HomologicalComplex.X D j)\n  (g : D ‚ü∂ E),\n  Homotopy.nullHomotopicMap' hom ‚â´ g =\n    Homotopy.nullHomotopicMap' fun (i : Œπ) (j : Œπ) (hij : ComplexShape.Rel c j i) ‚Ü¶\n      hom i j hij ‚â´ HomologicalComplex.Hom.f g j","name":"Homotopy.nullHomotopicMap'_comp","isProp":true,"docString":"Compatibility of `nullHomotopicMap'` with the postcomposition by a morphism\nof complexes. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±), a * b * c = a * (b * c)","name":"CanonicallyOrderedCommSemiring.mul_assoc","isProp":true,"docString":"Multiplication is associative "},{"type":"‚àÄ {R : Type u} [self : EuclideanDomain R] (a : R), EuclideanDomain.quotient a 0 = 0","name":"EuclideanDomain.quotient_zero","isProp":true,"docString":"Division by zero should always give zero by convention. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Y : Type u_1} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y]\n  (hp : PreconnectedSpace Œ±) {f : (a : Œ±) ‚Üí Y} (hf : Continuous f) {x : Œ±} {y : Œ±}, f x = f y","name":"PreconnectedSpace.constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected.constant` "},{"type":"‚àÉ (Œ± : Type),\n  ‚àÉ (Œ≤ : Type),\n    ‚àÉ (x : TopologicalSpace Œ±),\n      ‚àÉ (x_1 : TopologicalSpace Œ≤),\n        (CompactSpace Œ± : Prop) ‚àß\n          ((T1Space Œ≤ : Prop) ‚àß\n              (‚àÉ (f : Œ± ‚âÉ Œ≤), (Continuous ‚Üëf : Prop) ‚àß (¬¨(Continuous ‚Üë(Equiv.symm f) : Prop) : Prop) : Prop) :\n            Prop)","name":"Continuous.homeoOfEquivCompactToT2.t1_counterexample","isProp":true,"docString":"A concrete counterexample shows that  `Continuous.homeoOfEquivCompactToT2`\ncannot be generalized from `T2Space` to `T1Space`.\n\nLet `Œ± = Alexandroff ‚Ñï` be the one-point compactification of `‚Ñï`, and let `Œ≤` be the same space\n`Alexandroff ‚Ñï` with the cofinite topology.  Then `Œ±` is compact, `Œ≤` is T1, and the identity map\n`id : Œ± ‚Üí Œ≤` is a continuous equivalence that is not a homeomorphism.\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : ConditionallyCompleteLinearOrderBot Œ±], sup‚Çõ ‚àÖ = ‚ä•","name":"ConditionallyCompleteLinearOrderBot.csup‚Çõ_empty","isProp":true,"docString":"The supremum of the empty set is `‚ä•` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  [inst_2 : CategoryTheory.IsEquivalence F], CategoryTheory.Faithful F","name":"CategoryTheory.Equivalence.faithfulOfEquivalence","isProp":true,"docString":"An equivalence is faithful.\n\nSee <https://stacks.math.columbia.edu/tag/02C3>.\n"},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Mul Œ±] [inst_1 : Add Œ±] [inst_2 : LE Œ±]\n  [inst_3 : Mul Œ≤] [inst_4 : Add Œ≤] [inst_5 : LE Œ≤] [self : OrderRingIsoClass F Œ± Œ≤] (f : F) {a : Œ±} {b : Œ±},\n  (‚Üëf a ‚â§ ‚Üëf b : Prop) ‚Üî (a ‚â§ b : Prop)","name":"OrderRingIsoClass.map_le_map_iff","isProp":true,"docString":"The proposition that the function preserves the order bijectively. "},{"type":"‚àÄ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R], CharZero (FractionRing R)","name":"IsFractionRing.charZero","isProp":true,"docString":"If `R` has characteristic `0`, then so does `FractionRing R`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Mul Œ±] {u : Finset Œ±} {s : Set Œ±} {t : Set Œ±} (a : ‚Üëu ‚äÜ s * t),\n  ‚àÉ (s' : Finset Œ±), ‚àÉ (t' : Finset Œ±), (‚Üës' ‚äÜ s : Prop) ‚àß ((‚Üët' ‚äÜ t : Prop) ‚àß (u ‚äÜ s' * t' : Prop) : Prop)","name":"Finset.subset_mul","isProp":true,"docString":"If a finset `u` is contained in the product of two sets `s * t`, we can find two finsets `s'`,\n`t'` such that `s' ‚äÜ s`, `t' ‚äÜ t` and `u ‚äÜ s' * t'`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (hs : ‚àÄ (f : (a : Œ±) ‚Üí Bool) (a : Continuous f) (x : Œ±) (y : Œ±), f x = f y),\n  PreconnectedSpace Œ±","name":"preconnectedSpace_of_forall_constant","isProp":true,"docString":"A `PreconnectedSpace` version of `isPreconnected_of_forall_constant` "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (h : p‚ÇÅ ‚àà affineSpan k {p‚ÇÇ, p‚ÇÉ}),\n  affineSpan k {p‚ÇÅ, p‚ÇÉ} ‚â§ affineSpan k {p‚ÇÇ, p‚ÇÉ}","name":"affineSpan_pair_le_of_left_mem","isProp":true,"docString":"One line is contained in another differing in the first point if the first point of the first\nline is contained in the second line. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M‚ÇÅ M‚ÇÇ) {Œ± : (a : Œπ) ‚Üí Type u_1} (g : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí M‚ÇÅ i)\n  [inst_5 : DecidableEq Œπ] [inst_6 : Fintype Œπ] [inst_7 : (i : Œπ) ‚Üí Fintype (Œ± i)],\n  (‚Üëf fun (i : Œπ) ‚Ü¶ Finset.sum Finset.univ fun (j : Œ± i) ‚Ü¶ g i j) =\n    Finset.sum Finset.univ fun (r : (i : Œπ) ‚Üí Œ± i) ‚Ü¶ ‚Üëf fun (i : Œπ) ‚Ü¶ g i (r i)","name":"MultilinearMap.map_sum","isProp":true,"docString":"If `f` is multilinear, then `f (Œ£_{j‚ÇÅ} g‚ÇÅ j‚ÇÅ, ..., Œ£_{j‚Çô} g‚Çô j‚Çô)` is the sum of\n`f (g‚ÇÅ (r 1), ..., g‚Çô (r n))` where `r` ranges over all functions `r`. This follows from\nmultilinearity by expanding successively with respect to each coordinate. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (h : M ‚âÉ* N), IsMulHom ‚Üëh","name":"MulEquiv.isMulHom","isProp":true,"docString":"A multiplicative isomorphism preserves multiplication (deprecated). "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] [inst_1 : Nontrivial M‚ÇÄ] [inst_2 : NoZeroDivisors M‚ÇÄ] {L : List M‚ÇÄ},\n  (List.prod L = 0 : Prop) ‚Üî (0 ‚àà L : Prop)","name":"List.prod_eq_zero_iff","isProp":true,"docString":"Product of elements of a list `L` equals zero if and only if `0 ‚àà L`. See also\n`List.prod_eq_zero` for an implication that needs weaker typeclass assumptions. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {I : Ideal S} {f : R ‚Üí+* S},\n  Function.Injective\n    ‚Üë(Ideal.quotientMap I f ((le_rfl=:Ideal.comap f I ‚â§ Ideal.comap f I)=:Ideal.comap f I ‚â§ Ideal.comap f I))","name":"Ideal.quotientMap_injective","isProp":true,"docString":"If we take `J = I.comap f` then `quotient_map` is injective automatically. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] [inst_1 : Nonempty Œ±] (s : Finset Œ±), BddBelow ‚Üës","name":"Finset.bddBelow","isProp":true,"docString":"A finset is bounded below. "},{"type":"‚àÄ {M : Type u_1} [inst : AddGroup M] (c : AddCon M) {w : M} {x : M} {y : M} {z : M} (a : ‚Üëc w x) (a : ‚Üëc y z),\n  ‚Üëc (w - y) (x - z)","name":"AddCon.sub","isProp":true,"docString":"Additive congruence relations preserve subtraction."},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] [inst_1 : DecidableRel Disjoint]\n  [inst_2 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (u : Œ±) (v : Œ±) (s : Finset Œ±),\n  UV.compression u v (UV.compression u v s) = UV.compression u v s","name":"UV.compression_idem","isProp":true,"docString":"Compressing a family is idempotent. "},{"type":"‚àÄ {p : Prop} [self : Fact (p : Prop)], p","name":"Fact.out","isProp":true,"docString":"`Fact.out` contains the unwrapped witness for the fact represented by the instance of\n`Fact p`. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R)\n  (s : { x : R // x ‚àà S }) (s' : { x : R // x ‚àà S }), r /‚Çí s = r * ‚Üës' /‚Çí (s * s')","name":"OreLocalization.expand'","isProp":true,"docString":"A fraction is equal to its expansion by an factor from s. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : a ‚â§ 0) (hb : b < 0), a + b < 0","name":"Right.add_neg_of_nonpos_of_neg","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg_of_nonpos_of_neg`."},{"type":"‚àÄ {Œ± : Type uu} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [inst : DecidableRel r] {l : List Œ±} (x : List.Sorted r l),\n  List.insertionSort r l = l","name":"List.Sorted.insertionSort_eq","isProp":true,"docString":"If `l` is already `List.Sorted` with respect to `r`, then `insertionSort` does not change\nit. "},{"type":"‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] {a : B} {b : B} {c : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c),\n  CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Iso.hom (CategoryTheory.Bicategory.leftUnitor f)) g =\n    CategoryTheory.Iso.hom (CategoryTheory.Bicategory.associator (ùüô a) f g) ‚â´\n      CategoryTheory.Iso.hom (CategoryTheory.Bicategory.leftUnitor (f ‚â´ g))","name":"CategoryTheory.Bicategory.leftUnitor_whiskerRight","isProp":true,"docString":"We state it as a simp lemma, which is regarded as an involved version of\n`id_whiskerRight f g : ùüô f ‚ñ∑ g = ùüô (f ‚â´ g)`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [self : NoncompactSpace Œ±], ¬¨(IsCompact Set.univ : Prop)","name":"NoncompactSpace.noncompact_univ","isProp":true,"docString":"In a noncompact space, `Set.univ` is not a compact set. "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : Zero M] {b : M} (h : b ‚â† 0), Function.Injective fun (a : Œ±) ‚Ü¶ Finsupp.single a b","name":"Finsupp.single_left_injective","isProp":true,"docString":"`Finsupp.single a b` is injective in `a`. For the statement that it is injective in `b`, see\n`Finsupp.single_injective` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] (self : TopologicalSpace.Opens Œ±),\n  IsOpen (TopologicalSpace.Opens.carrier self)","name":"TopologicalSpace.Opens.is_open'","isProp":true,"docString":"The `TopologicalSpace.Opens.carrier _` is an open set. "},{"type":"‚àÄ {Œπ : Sort u_1} [inst : Nonempty Œπ] {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h : x ‚â† ‚ä§),\n  inf·µ¢ f * x = inf·µ¢ fun (i : Œπ) ‚Ü¶ f i * x","name":"ENNReal.inf·µ¢_mul","isProp":true,"docString":"If `x ‚â† ‚àû`, then right multiplication by `x` maps infimum over a nonempty type to infimum. See\nalso `ENNReal.inf·µ¢_mul_of_ne` that assumes `x ‚â† 0` but does not require `[Nonempty Œπ]`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s) {x : E} {y : E} (hx : x ‚àà s) (hy : y ‚àà interior s) {t : ùïú} (ht : t ‚àà Set.Ioc 0 1),\n  x + t ‚Ä¢ (y - x) ‚àà interior s","name":"Convex.add_smul_sub_mem_interior","isProp":true,"docString":"If `x ‚àà s` and `y ‚àà interior s`, then the segment `(x, y]` is included in `interior s`. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {d : Con M} (H : Setoid.r = Setoid.r), c = d","name":"Con.ext'","isProp":true,"docString":"The map sending a congruence relation to its underlying binary relation is injective. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} {m : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤}\n  [inst : MeasurableSingletonClass Œ±] (hf : Measurable f) (h : Set.Countable (setOf fun (x : Œ±) ‚Ü¶ f x ‚â† g x)),\n  Measurable g","name":"Measurable.measurable_of_countable_ne","isProp":true,"docString":"If a function coincides with a measurable function outside of a countable set, it is\nmeasurable. "},{"type":"‚àÄ (R : Type u) [inst : CommRing R] [inst_1 : StrongRankCondition R] (M : Type v) (N : Type w) [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : AddCommGroup N] [inst_6 : Module R N]\n  [inst_7 : Module.Free R N],\n  FiniteDimensional.finrank R (TensorProduct R M N) = FiniteDimensional.finrank R M * FiniteDimensional.finrank R N","name":"FiniteDimensional.finrank_tensorProduct","isProp":true,"docString":"The finrank of `M ‚äó[R] N` is `(finrank R M) * (finrank R N)`. "},{"type":"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (v : (a : n) ‚Üí R)\n  (A : Matrix n n R),\n  Matrix.det (‚ÜëMatrix.of fun (i : n) (j : n) ‚Ü¶ v i * A i j) = (Finset.prod Finset.univ fun (i : n) ‚Ü¶ v i) * Matrix.det A","name":"Matrix.det_mul_column","isProp":true,"docString":"Multiplying each column by a fixed `v j` multiplies the determinant by\nthe product of the `v`s. "},{"type":"‚àÄ (n : ‚Ñï) (b : ‚Ñï), (n + 1) / (b + 2) < n + 1","name":"Nat.div_lt_self'","isProp":true,"docString":"A version of `Nat.div_lt_self` using successors, rather than additional hypotheses. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : (a : Œ±) ‚Üí ‚Ñù} (K : ‚Ñù) (h : ‚àÄ (x : Œ±) (y : Œ±), f x ‚â§ f y + K * dist x y),\n  LipschitzWith (Real.toNNReal K) f","name":"LipschitzWith.of_le_add_mul'","isProp":true,"docString":"For functions to `‚Ñù`, it suffices to prove `f x ‚â§ f y + K * dist x y`; this version\ndoesn't assume `0‚â§K`. "},{"type":"‚àÄ {G : Type u} [self : AddSemigroup G] (a : G) (b : G) (c : G), a + b + c = a + (b + c)","name":"AddSemigroup.add_assoc","isProp":true,"docString":"Addition is associative "},{"type":"¬¨(Primrec‚ÇÇ ack : Prop)","name":"not_primrec‚ÇÇ_ack","isProp":true,"docString":"The Ackermann function is not primitive recursive. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)\n  [inst_1 : CategoryTheory.Limits.HasPullback f g],\n  CategoryTheory.IsPullback CategoryTheory.Limits.pullback.fst CategoryTheory.Limits.pullback.snd f g","name":"CategoryTheory.IsPullback.of_hasPullback","isProp":true,"docString":"The pullback provided by `HasPullback f g` fits into a `IsPullback`. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)), List.join (List.reverse L) = List.reverse (List.join (List.map List.reverse L))","name":"List.join_reverse","isProp":true,"docString":"Joining a reverse is the same as reversing all parts and reversing the joined result. "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ), a‚Åª¬π * a * a = a","name":"inv_mul_mul_self","isProp":true,"docString":"Multiplying `a‚Åª¬π` by `a` twice results in `a` (whether or not `a`\nis zero). "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} {t : Set Œ±} (a : s < t), s ‚äÇ t","name":"LT.lt.ssubset","isProp":true,"docString":"**Alias** of the forward direction of `Set.lt_iff_ssubset`."},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Subsingleton s), Cardinal.mk ‚Üës ‚â§ 1","name":"Set.Subsingleton.cardinal_mk_le_one","isProp":true,"docString":"**Alias** of the reverse direction of `Cardinal.mk_le_one_iff_set_subsingleton`."},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] (x : DualNumber R) (y : DualNumber R),\n  TrivSqZeroExt.snd (x * y) = TrivSqZeroExt.fst x * TrivSqZeroExt.snd y + TrivSqZeroExt.snd x * TrivSqZeroExt.fst y","name":"DualNumber.snd_mul","isProp":true,"docString":"A version of `TrivSqZeroExt.snd_mul` with `*` instead of `‚Ä¢`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] (A : Finset Œ±) (B : Finset Œ±),\n  (Finset.toColex (A \\ B) ‚â§ Finset.toColex (B \\ A) : Prop) ‚Üî (Finset.toColex A ‚â§ Finset.toColex B : Prop)","name":"Colex.sdiff_le_sdiff_iff_le","isProp":true,"docString":"Colex doesn't care if you remove the other set "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : Zero Œ±] {s : Finset Œπ} {f : Œπ ‚Üí‚ÇÄ Œ±} {t : Œπ ‚Üí‚ÇÄ Finset Œ±}\n  (ht : Finsupp.support t ‚äÜ s), (f ‚àà Finset.finsupp s ‚Üët : Prop) ‚Üî (‚àÄ (i : Œπ), ‚Üëf i ‚àà ‚Üët i : Prop)","name":"Finset.mem_finsupp_iff_of_support_subset","isProp":true,"docString":"When `t` is supported on `s`, `f ‚àà s.finsupp t` precisely means that `f` is pointwise in `t`. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCancelAddCommMonoid Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"LinearOrderedCancelAddCommMonoid.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.univ ‚äÜ s), s = Set.univ","name":"Set.eq_univ_of_univ_subset","isProp":true,"docString":"**Alias** of the forward direction of `Set.univ_subset_iff`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] {Œπ : Type u_1} {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±}\n  {p : Filter Œπ} {s : Set Œ≤},\n  (TendstoUniformlyOn F f p s : Prop) ‚Üî\n    (‚àÄ (Œµ : ENNReal) (a : Œµ > 0), Filter.Eventually (fun (n : Œπ) ‚Ü¶ ‚àÄ (x : Œ≤) (a : x ‚àà s), edist (f x) (F n x) < Œµ) p :\n      Prop)","name":"EMetric.tendstoUniformlyOn_iff","isProp":true,"docString":"Expressing uniform convergence on a set using `edist`. "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedAddCommGroup Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c + a ‚â§ c + b","name":"OrderedAddCommGroup.add_le_add_left","isProp":true,"docString":"Addition is monotone in a ordered additive commutative group. "},{"type":"‚àÄ {Œπ : Type u_3} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Preadditive V]\n  {c : ComplexShape Œπ} {C : HomologicalComplex V c} {D : HomologicalComplex V c} {W : Type u_1}\n  [inst_2 : CategoryTheory.Category W] [inst_3 : CategoryTheory.Preadditive W] (G : V ‚•§ W)\n  [inst_4 : CategoryTheory.Functor.Additive G]\n  (hom : (i : Œπ) ‚Üí (j : Œπ) ‚Üí (a : ComplexShape.Rel c j i) ‚Üí HomologicalComplex.X C i ‚ü∂ HomologicalComplex.X D j),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Functor.mapHomologicalComplex G c))\n      (Homotopy.nullHomotopicMap' hom) =\n    Homotopy.nullHomotopicMap' fun (i : Œπ) (j : Œπ) (hij : ComplexShape.Rel c j i) ‚Ü¶\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) (hom i j hij)","name":"Homotopy.map_nullHomotopicMap'","isProp":true,"docString":"Compatibility of `nullHomotopicMap'` with the application of additive functors "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R ‚âÉ+* S·µê·µí·µñ) (l : List R),\n  MulOpposite.unop (‚Üëf (List.prod l)) = List.prod (List.reverse (List.map (MulOpposite.unop ‚àò ‚Üëf) l))","name":"RingEquiv.unop_map_list_prod","isProp":true,"docString":"An isomorphism into the opposite ring acts on the product by acting on the reversed elements "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [inst : IsIrrefl Œ± r] {s : Multiset Œ±}\n  (hs : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), Acc (Relation.CutExpand r) {a}), Acc (Relation.CutExpand r) s","name":"Relation.acc_of_singleton","isProp":true,"docString":"A multiset is accessible under `CutExpand` if all its singleton subsets are,\nassuming `r` is irreflexive. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i) = Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (MonovaryOn (f ‚àò ‚ÜëœÉ) g ‚Üës : Prop)","name":"MonovaryOn.sum_comp_perm_smul_eq_sum_smul_iff","isProp":true,"docString":"**Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f ‚àò œÉ` and `g` monovary\ntogether. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} {v : (a : Œ±) ‚Üí ‚Ñù} (a : u =o[l] v),\n  (fun (x : Œ±) ‚Ü¶ abs (u x)) =o[l] fun (x : Œ±) ‚Ü¶ abs (v x)","name":"Asymptotics.IsLittleO.abs_abs","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_abs_abs`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasEqualizer f g], CategoryTheory.Mono (CategoryTheory.Limits.equalizer.Œπ f g)","name":"CategoryTheory.Limits.equalizer.Œπ_mono","isProp":true,"docString":"An equalizer morphism is a monomorphism "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 1) (hb : b < 1), a * b < 1","name":"Left.mul_lt_one","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one`. "},{"type":"‚àÄ {n : ‚Ñï} {n' : ‚Ñï} {m : ‚Ñï} (i : Fin n') (h : n' = n),\n  ‚Üë(Fin.addNat m) (‚Üë(Fin.cast h) i) =\n    ‚Üë(Fin.cast ((congr_arg (fun (x : ‚Ñï) ‚Ü¶ x + m) h=:n' + m = n + m)=:n' + m = n + m)) (‚Üë(Fin.addNat m) i)","name":"Fin.addNat_cast","isProp":true,"docString":"For rewriting in the reverse direction, see `Fin.cast_addNat_left`. "},{"type":"‚àÄ {Œπ : Type u_1} {M : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí Monoid (M i)] {i : Œπ} (self : FreeProduct.Word.Pair M i),\n  FreeProduct.Word.fstIdx (FreeProduct.Word.Pair.tail self) ‚â† some i","name":"FreeProduct.Word.Pair.fstIdx_ne","isProp":true,"docString":"The index first letter of tail of a `Pair M i` is not equal to `i` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type v} [hŒπ : Nonempty Œπ] (Z : (a : Œπ) ‚Üí Set Œ±)\n  (hZd : Directed (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äá x_1) Z) (hZn : ‚àÄ (i : Œπ), Set.Nonempty (Z i))\n  (hZc : ‚àÄ (i : Œπ), IsCompact (Z i)) (hZcl : ‚àÄ (i : Œπ), IsClosed (Z i)), Set.Nonempty (Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Z i)","name":"IsCompact.nonempty_inter·µ¢_of_directed_nonempty_compact_closed","isProp":true,"docString":"Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : AddCommMonoid Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±} {b : Œ±}\n  (a_1 : a ‚â§ b), a - b ‚â§ 0","name":"tsub_nonpos_of_le","isProp":true,"docString":"**Alias** of the reverse direction of `tsub_nonpos`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] [inst_4 : ContinuousAdd Œ≥] {f : (a : Œ±) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ≥} (hf : UpperSemicontinuousOn f s) (hg : UpperSemicontinuousOn g s),\n  UpperSemicontinuousOn (fun (z : Œ±) ‚Ü¶ f z + g z) s","name":"UpperSemicontinuousOn.add","isProp":true,"docString":"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v : V)\n  (nz : v ‚â† 0), (FiniteDimensional.finrank K V = 1 : Prop) ‚Üî (Submodule.span K {v} = ‚ä§ : Prop)","name":"finrank_eq_one_iff_of_nonzero","isProp":true,"docString":"A vector space with a nonzero vector `v` has dimension 1 iff `v` spans.\n"},{"type":"‚àÄ {x : ‚Ñù} {y : ‚Ñù} (hx : 0 ‚â§ x) (hy : 0 ‚â§ y), (x ‚â§ Real.sqrt y : Prop) ‚Üî (x ^ 2 ‚â§ y : Prop)","name":"Real.le_sqrt","isProp":true,"docString":"Note: if you want to conclude `x ‚â§ Real.sqrt y`, then use `Real.le_sqrt_of_sq_le`.  If you have\n`x > 0`, consider using `Real.le_sqrt'` "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_3} [inst_1 : AddCommMonoid N] {P : Type u_2}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëg ‚Üëy)) (x : M) (y : { x : M // x ‚àà S }),\n  ‚Üë(AddSubmonoid.LocalizationMap.lift f hg) (AddSubmonoid.LocalizationMap.mk' f x y) =\n    ‚Üëg x + ‚Üë(-‚Üë(IsAddUnit.liftRight (AddMonoidHom.restrict g S) hg) y)","name":"AddSubmonoid.LocalizationMap.lift_mk'","isProp":true,"docString":"Given a Localization map `f : M ‚Üí+ N` for a Submonoid `S ‚äÜ M` and a map of\n`AddCommMonoid`s `g : M ‚Üí+ P` such that `g y` is invertible for all `y : S`, the homomorphism\ninduced from `N` to `P` maps `f x - f y` to `g x - g y` for all `x : M, y ‚àà S`."},{"type":"‚àÄ {v : Sat.Valuation} {l : Sat.Literal} {a : Prop} {c : Sat.Clause} {b : Prop} (h‚ÇÅ : Sat.Literal.reify v l (a : Prop))\n  (h‚ÇÇ : Sat.Clause.reify v c (b : Prop)), Sat.Clause.reify v (Sat.Clause.cons l c) ((a : Prop) ‚àß (b : Prop) : Prop)","name":"Sat.Clause.reify_and","isProp":true,"docString":"Negation turns OR into AND, so `¬¨‚ü¶l ‚à® c‚üß_v ‚â° ¬¨‚ü¶l‚üß_v ‚àß ¬¨‚ü¶c‚üß_v`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : WfDvdMonoid Œ±] [inst_2 : GCDMonoid Œ±],\n  UniqueFactorizationMonoid Œ±","name":"ufm_of_gcd_of_wfDvdMonoid","isProp":true,"docString":"Can't be an instance because it would cause a loop `ufm ‚Üí WfDvdMonoid ‚Üí ufm ‚Üí ...`. "},{"type":"‚àÄ {X : Type u_2} [inst : EMetricSpace X] {Œπ : Type u_1} {I : Finset Œπ} {s : (a : Œπ) ‚Üí Set X} {t : Set X}\n  (a : ‚àÄ (i : Œπ) (a : i ‚àà I), IsMetricSeparated (s i) t),\n  IsMetricSeparated (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà I) ‚Ü¶ s i) t","name":"IsMetricSeparated.finset_union·µ¢_left","isProp":true,"docString":"**Alias** of the reverse direction of `IsMetricSeparated.finset_union·µ¢_left_iff`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type u_1} {t : Set Œπ} {s : (a : Œπ) ‚Üí Set Œ±}\n  (H : ‚àÄ (i : Œπ) (a : i ‚àà t), IsPreconnected (s i))\n  (K :\n    ‚àÄ (i : Œπ) (a : i ‚àà t) (j : Œπ) (a : j ‚àà t),\n      Relation.ReflTransGen (fun (i : Œπ) (j : Œπ) ‚Ü¶ (Set.Nonempty (s i ‚à© s j) : Prop) ‚àß (i ‚àà t : Prop)) i j),\n  IsPreconnected (Set.union·µ¢ fun (n : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : n ‚àà t) ‚Ü¶ s n)","name":"IsPreconnected.bunion·µ¢_of_reflTransGen","isProp":true,"docString":"The bunion·µ¢ of a family of preconnected sets is preconnected if the graph determined by\nwhether two sets intersect is preconnected. "},{"type":"‚àÄ (R : Type u_3) [inst : CommSemiring R] (M : Type u_1) (N : Type u_2) [inst_1 : AddCommMonoid M]\n  [inst_2 : AddCommMonoid N] [inst_3 : Module R M] [inst_4 : Module R N],\n  Submodule.span R (setOf fun (t : TensorProduct R M N) ‚Ü¶ ‚àÉ (m : M), ‚àÉ (n : N), m ‚äó‚Çú[R] n = t) = ‚ä§","name":"TensorProduct.span_tmul_eq_top","isProp":true,"docString":"The simple (aka pure) elements span the tensor product. "},{"type":"‚àÄ {M : Type u_1} [inst : CancelCommMonoidWithZero M] [inst_1 : DecidableEq M] [inst_2 : UniqueFactorizationMonoid M]\n  [inst_3 : Unique MÀ£] (x : M), UniqueFactorizationMonoid.factors x = UniqueFactorizationMonoid.normalizedFactors x","name":"UniqueFactorizationMonoid.factors_eq_normalizedFactors","isProp":true,"docString":"An arbitrary choice of factors of `x : M` is exactly the (unique) normalized set of factors,\nif `M` has a trivial group of units. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (ha : 0 < a) (hb : 0 ‚â§ b), 0 < a + b","name":"Right.add_pos_of_pos_of_nonneg","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_pos_of_nonneg`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], CategoryTheory.Limits.HasFiniteCoproducts C","name":"CategoryTheory.hasFiniteCoproducts_of_has_binary_and_initial","isProp":true,"docString":"If `C` has an initial object and binary coproducts, then it has finite coproducts. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ‚Ñï} {i : Fin (n + 2)}\n  {j : Fin (n + 1)} (H : ‚ÜëFin.castSucc j < i),\n  CategoryTheory.SimplicialObject.œÉ X (‚ÜëFin.castSucc j) ‚â´ CategoryTheory.SimplicialObject.Œ¥ X (Fin.succ i) =\n    CategoryTheory.SimplicialObject.Œ¥ X i ‚â´ CategoryTheory.SimplicialObject.œÉ X j","name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_of_gt","isProp":true,"docString":"The fourth simplicial identity "},{"type":"‚àÄ {Œ± : Type u_1} {E' : Type u_2} {F' : Type u_3} [inst : SeminormedAddCommGroup E'] [inst_1 : SeminormedAddCommGroup F']\n  {c : ‚Ñù} {f' : (a : Œ±) ‚Üí E'} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l f' g'),\n  Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ","name":"Asymptotics.IsBigOWith.norm_norm","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigOWith_norm_norm`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsRingHom f), f 1 = 1","name":"IsRingHom.map_one","isProp":true,"docString":"The proposition that `f` preserves the multiplicative identity. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (hf : AntitoneOn f s) (hg : AntitoneOn g s), AntitoneOn (fun (x : Œ±) ‚Ü¶ min (f x) (g x)) s","name":"AntitoneOn.min","isProp":true,"docString":"Pointwise minimum of two antitone functions is a antitone function. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SemilatticeSup Œ±] [inst_1 : OrderBot Œ±] {P : (a : Œ±) ‚Üí Prop} {Pbot : P ‚ä•}\n  {Psup : ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : P x) (a : P y), P (x ‚äî y)} (t : Finset Œ≤) (f : (a : Œ≤) ‚Üí { x : Œ± // P x }),\n  ‚Üë(Finset.sup t f) = Finset.sup t fun (x : Œ≤) ‚Ü¶ ‚Üë(f x)","name":"Finset.sup_coe","isProp":true,"docString":"Computing `sup` in a subtype (closed under `sup`) is the same as computing it in `Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ±‚ÇÇ : Type u_3} [inst : Semiring Œ≤] [inst_1 : One Œ±] [inst_2 : One Œ±‚ÇÇ] {F : Type u_4}\n  [inst_3 : OneHomClass F Œ± Œ±‚ÇÇ] (f : F), MonoidAlgebra.mapDomain (‚Üëf) 1 = 1","name":"MonoidAlgebra.mapDomain_one","isProp":true,"docString":"Like `Finsupp.mapDomain_zero`, but for the `1` we define in this file "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} (hs : IsCompact s) {e : ‚Ñù} (he : 0 < e),\n  ‚àÉ (t : Set Œ±),\n    (t ‚äÜ s : Prop) ‚àß\n      ((Set.Finite t : Prop) ‚àß (s ‚äÜ Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà t) ‚Ü¶ Metric.ball x e : Prop) :\n        Prop)","name":"IsCompact.finite_cover_balls","isProp":true,"docString":"**Alias** of `finite_cover_balls_of_compact`."},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedSemiring R] (l : List R) (h : ‚àÄ (a : R) (a_1 : a ‚àà l), 0 < a), 0 < List.prod l","name":"List.prod_pos","isProp":true,"docString":"The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} {R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R)\n  [inst_1 : CategoryTheory.StrongMono f] [inst_2 : CategoryTheory.StrongMono g], CategoryTheory.StrongMono (f ‚â´ g)","name":"CategoryTheory.strongMono_comp","isProp":true,"docString":"The composition of two strong monomorphisms is a strong monomorphism. "},{"type":"‚àÄ {Œ± : Type u} [inst : CompleteLattice Œ±] {J : Type u} [inst_1 : CategoryTheory.SmallCategory J] (F : J ‚•§ Œ±),\n  CategoryTheory.Limits.colimit F = sup·µ¢ (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F))","name":"CategoryTheory.Limits.CompleteLattice.colimit_eq_sup·µ¢","isProp":true,"docString":"The colimit of a functor into a complete lattice is the supremum of the objects in the image.\n"},{"type":"‚àÄ {o : Ordinal} {f : (b : Ordinal) ‚Üí (a : b < o) ‚Üí (a : Ordinal) ‚Üí Ordinal}\n  (H : ‚àÄ (i : Ordinal) (hi : i < o), Ordinal.IsNormal (f i hi)),\n  Ordinal.derivBFamily o f =\n    Ordinal.enumOrd (Set.inter·µ¢ fun (i : Ordinal) ‚Ü¶ Set.inter·µ¢ fun (hi : i < o) ‚Ü¶ Function.fixedPoints (f i hi))","name":"Ordinal.derivBFamily_eq_enumOrd","isProp":true,"docString":"For a family of normal functions, `ordinal.deriv_bfamily` enumerates the common fixed points. "},{"type":"‚àÄ (Œ± : Sort u_1) [inst : Infinite Œ±] [inst : Finite Œ±], False","name":"not_finite","isProp":true,"docString":"`Infinite Œ±` is not `Finite`"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : SemilatticeInf Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f) (hg : Antitone g), Antitone (f ‚äì g)","name":"Antitone.inf","isProp":true,"docString":"Pointwise infimum of two monotone functions is a monotone function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : DenselyOrdered Œ±] {s : Set Œ±} [hs : Set.OrdConnected s],\n  DenselyOrdered ‚Üës","name":"Set.instDenselyOrderedElemLtToLTMemSetInstMembershipSet","isProp":true,"docString":"In a dense order `Œ±`, the subtype from an `OrdConnected` set is also densely ordered. "},{"type":"‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {p : (a : Œ±) ‚Üí Prop} (a : Filter.Eventually (fun (x : Œ±) ‚Ü¶ p x) l),\n  Filter.Eventually (fun (s : Set Œ±) ‚Ü¶ ‚àÄ (x : Œ±) (a : x ‚àà s), p x) (Filter.smallSets l)","name":"Filter.Eventually.smallSets","isProp":true,"docString":"**Alias** of the reverse direction of `Filter.eventually_smallSets_forall`."},{"type":"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a : S} {b : S} {c : S} (hab : AddCommute a b) (hac : AddCommute a c),\n  AddCommute a (b + c)","name":"AddCommute.add_right","isProp":true,"docString":"If `a` commutes with both `b` and `c`, then it commutes with their sum."},{"type":"‚àÄ {S : Type u_1} [inst : Semigroup S] {a : S} {b : S} {x : S} {y : S} {z : S} (ha : SemiconjBy a y z)\n  (hb : SemiconjBy b x y), SemiconjBy (a * b) x z","name":"SemiconjBy.mul_left","isProp":true,"docString":"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\nsemiconjugates `x` to `z`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} (hf : Monotone f) (h : f ‚â§ g) (n : ‚Ñï),\n  f^[n] ‚â§ g^[n]","name":"Monotone.iterate_le_of_le","isProp":true,"docString":"If `f ‚â§ g` and `f` is monotone, then `f^[n] ‚â§ g^[n]`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C}, Quiver.IsThin (CategoryTheory.MonoOver X)","name":"CategoryTheory.MonoOver.isThin","isProp":true,"docString":"The category of monomorphisms over X is a thin category,\nwhich makes defining its skeleton easy. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : AddCommMonoid Œ≤] {n : ‚Ñï} (f : (a : Fin (n + 1)) ‚Üí Œ≤),\n  (Finset.sum Finset.univ fun (i : Fin (n + 1)) ‚Ü¶ f i) = f 0 + Finset.sum Finset.univ fun (i : Fin n) ‚Ü¶ f (Fin.succ i)","name":"Fin.sum_univ_succ","isProp":true,"docString":"A sum of a function `f : Fin (n + 1) ‚Üí Œ≤` over all `Fin (n + 1)` is the sum of\n`f 0` plus the remaining product"},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : CommMonoid M] [inst_2 : Nontrivial R] {m : M} {S : Set M},\n  (‚Üë(MonoidAlgebra.of R M) m ‚àà Submodule.span R (‚Üë(MonoidAlgebra.of R M) '' S) : Prop) ‚Üî (m ‚àà S : Prop)","name":"MonoidAlgebra.of_mem_span_of_iff","isProp":true,"docString":"The image of an element `m : M` in `MonoidAlgebra R M` belongs the submodule generated by\n`S : Set M` if and only if `m ‚àà S`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] (a : Œ±), lcm a 0 = 0","name":"GCDMonoid.lcm_zero_right","isProp":true,"docString":"`0` is right-absorbing. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±] (H : FreeAddGroup.Red L‚ÇÅ L‚ÇÇ),\n  FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ","name":"FreeAddGroup.reduce.eq_of_red","isProp":true,"docString":"If a word reduces to another word, then they have a common maximal reduction."},{"type":"‚àÄ (ùïú : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField ùïú] [inst_1 : NormedAddCommGroup E]\n  [inst : NormedSpace ùïú E] [inst : Nontrivial E] (c : ‚Ñù), ‚àÉ (x : E), c < ‚Äñx‚Äñ","name":"NormedSpace.exists_lt_norm","isProp":true,"docString":"If `E` is a nontrivial normed space over a nontrivially normed field `ùïú`, then `E` is unbounded:\nfor any `c : ‚Ñù`, there exists a vector `x : E` with norm strictly greater than `c`. "},{"type":"‚àÄ (L : List ‚Ñï), List.sum (List.tail L) = List.sum L - List.headI L","name":"List.tail_sum","isProp":true,"docString":"This relies on `default ‚Ñï = 0`. "},{"type":"‚àÄ {M : Type u_2} [inst : Monoid M] {Œπ : Sort u_1} {s : (a : Œπ) ‚Üí Set M} (h : ‚àÄ (y : Œπ), IsSubmonoid (s y)),\n  IsSubmonoid (Set.inter·µ¢ s)","name":"IsSubmonoid.inter·µ¢","isProp":true,"docString":"The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_3} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) (b : P) (c : k),\n  ‚Üë(Finset.weightedVSubOfPoint s p b) (c ‚Ä¢ w) = c ‚Ä¢ ‚Üë(Finset.weightedVSubOfPoint s p b) w","name":"Finset.weightedVSubOfPoint_const_smul","isProp":true,"docString":"A constant multiplier of the weights in `weightedVSubOfPoint` may be moved outside the\nsum. "},{"type":"‚àÄ {Œ± : Type u_2} {G : Type u_1} [inst : SubtractionCommMonoid G] {f : (a : Œ±) ‚Üí G} {g : (a : Œ±) ‚Üí G}\n  (hf : Set.Finite (Function.support f)) (hg : Set.Finite (Function.support g)),\n  (finsum fun (i : Œ±) ‚Ü¶ f i - g i) = (finsum fun (i : Œ±) ‚Ü¶ f i) - finsum fun (i : Œ±) ‚Ü¶ g i","name":"finsum_sub_distrib","isProp":true,"docString":"If the additive supports of `f` and `g` are finite, then the sum of `f i - g i`\nequals the sum of `f i` minus the sum of `g i`."},{"type":"‚àÄ {a : Prop} {b : Prop} {c : Prop} (a_1 : (a : Prop) ‚à® ((b : Prop) ‚à® (c : Prop) : Prop)),\n  (b : Prop) ‚à® ((c : Prop) ‚à® (a : Prop) : Prop)","name":"Or.rotate","isProp":true,"docString":"**Alias** of the forward direction of `or_rotate`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (hf : MonotoneOn f s) (hg : MonotoneOn g s), MonotoneOn (fun (x : Œ≤) ‚Ü¶ f x * g x) s","name":"MonotoneOn.mul'","isProp":true,"docString":"The product of two monotone functions is monotone. "},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤] (f : C(Œ±, Œ≤)) {Œπ : Type u‚ÇÉ}\n  {p : Filter Œπ} {F : (a : Œπ) ‚Üí C(Œ±, Œ≤)},\n  (Filter.Tendsto F p (nhds f) : Prop) ‚Üî\n    (‚àÄ (K : Set Œ±) (a : IsCompact K), TendstoUniformlyOn (fun (i : Œπ) (a : Œ±) ‚Ü¶ ‚Üë(F i) a) (‚Üëf) p K : Prop)","name":"ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn'","isProp":true,"docString":"This is an auxiliary lemma and is unlikely to be of direct use outside of this file. See\n`ContinuousMap.tendsto_iff_forall_compact_tendstoUniformlyOn` below for the useful version where the\ntopology is picked up via typeclass inference. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedField Œ±] (a : ‚Ñ§) (b : ‚Ñï) (h1 : b ‚â† 0) (h2 : Nat.coprime (Int.natAbs a) b),\n  ‚Üë(Rat.mk' a b) = ‚Üëa * (‚Üëb)‚Åª¬π","name":"LinearOrderedField.ratCast_mk","isProp":true,"docString":"However `ratCast` is defined, propositionally it must be equal to `a * b‚Åª¬π`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (e : LocalHomeomorph Œ± Œ≤)\n  {s : Set Œ±} (hs : IsOpen s), IsOpen (‚Üëe '' (LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© s))","name":"LocalHomeomorph.image_open_of_open'","isProp":true,"docString":"The image of the restriction of an open set to the source is open. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p‚ÇÇ : (a : Œπ) ‚Üí P) (p‚ÇÅ : P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 0),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ i)) = -‚Üë(Finset.weightedVSub s p‚ÇÇ) w","name":"Finset.sum_smul_const_vsub_eq_neg_weightedVSub","isProp":true,"docString":"A weighted sum of pairwise subtractions, where the point on the left is constant and the\nsum of the weights is 0. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : UniformSpace Œ±] [inst_1 : CompactSpace Œ±], nhdsSet (Set.diagonal Œ±) = uniformity Œ±","name":"nhdsSet_diagonal_eq_uniformity","isProp":true,"docString":"On a compact uniform space, the topology determines the uniform structure, entourages are\nexactly the neighborhoods of the diagonal. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : SuccOrder Œ±] [self : IsSuccArchimedean Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b),\n  ‚àÉ (n : ‚Ñï), (Order.succ^[n]) a = b","name":"IsSuccArchimedean.exists_succ_iterate_of_le","isProp":true,"docString":"If `a ‚â§ b` then one can get to `a` from `b` by iterating `succ` "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : LinearOrderedRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] {Œπ : Type u_4} {p : (a : Œπ) ‚Üí P} (h : AffineIndependent k p)\n  {w : (a : Œπ) ‚Üí k} {w‚ÇÅ : (a : Œπ) ‚Üí k} {w‚ÇÇ : (a : Œπ) ‚Üí k} {s : Finset Œπ} (hw : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1)\n  (hw‚ÇÅ : (Finset.sum s fun (i : Œπ) ‚Ü¶ w‚ÇÅ i) = 1) (hw‚ÇÇ : (Finset.sum s fun (i : Œπ) ‚Ü¶ w‚ÇÇ i) = 1)\n  (hs :\n    ‚Üë(Finset.affineCombination k s p) w ‚àà\n      affineSpan k {‚Üë(Finset.affineCombination k s p) w‚ÇÅ, ‚Üë(Finset.affineCombination k s p) w‚ÇÇ})\n  {i : Œπ} {j : Œπ} (hi : i ‚àà s) (hj : j ‚àà s) (hi0 : w‚ÇÅ i = 0) (hj0 : w‚ÇÅ j = 0)\n  (hij : ‚ÜëSignType.sign (w‚ÇÇ i) = ‚ÜëSignType.sign (w‚ÇÇ j)), ‚ÜëSignType.sign (w i) = ‚ÜëSignType.sign (w j)","name":"sign_eq_of_affineCombination_mem_affineSpan_pair","isProp":true,"docString":"Given an affinely independent family of points, suppose that an affine combination lies in\nthe span of two points given as affine combinations, and suppose that, for two indices, the\ncoefficients in the first point in the span are zero and those in the second point in the span\nhave the same sign. Then the coefficients in the combination lying in the span have the same\nsign. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [inst_1 : AddTorsor G P] {x : P} {y : P}\n  (h : Function.Injective bit0), (‚Üë(Equiv.pointReflection x) y = y : Prop) ‚Üî (y = x : Prop)","name":"Equiv.pointReflection_fixed_iff_of_injective_bit0","isProp":true,"docString":"`x` is the only fixed point of `pointReflection x`. This lemma requires\n`x + x = y + y ‚Üî x = y`. There is no typeclass to use here, so we add it as an explicit argument. "},{"type":"‚àÄ {a : Prop} (b : Prop) (h : a), (a : Prop) ‚à® (b : Prop)","name":"Or.intro_left","isProp":true,"docString":"Alias for `Or.inl`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s‚ÇÅ : AffineSubspace k P} {s‚ÇÇ : AffineSubspace k P}\n  (hd : AffineSubspace.direction s‚ÇÅ = AffineSubspace.direction s‚ÇÇ) (hn : Set.Nonempty ‚Üës‚ÇÅ) (hle : s‚ÇÅ ‚â§ s‚ÇÇ), s‚ÇÅ = s‚ÇÇ","name":"AffineSubspace.eq_of_direction_eq_of_nonempty_of_le","isProp":true,"docString":"If an affine subspace is nonempty and contained in another with the same direction, they are\nequal. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (0 < -a : Prop) ‚Üî (a < 0 : Prop)","name":"Left.neg_pos_iff","isProp":true,"docString":"Uses `left` co(ntra)variant."},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {S : Set (Set Œ±)}\n  (ho : ‚àÄ (s : Set Œ±) (a : s ‚àà S), IsOpen s) (hS : Set.Countable S) (hd : ‚àÄ (s : Set Œ±) (a : s ‚àà S), Dense s),\n  Dense (‚ãÇ‚ÇÄ S)","name":"dense_inter‚Çõ_of_open","isProp":true,"docString":"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ‚ãÇ‚ÇÄ. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C] (P : C)\n  (Q : C),\n  CategoryTheory.Iso.hom (CategoryTheory.Limits.coprod.braiding P Q) ‚â´\n      CategoryTheory.Iso.hom (CategoryTheory.Limits.coprod.braiding Q P) =\n    ùüô (P ‚®ø Q)","name":"CategoryTheory.Limits.coprod.symmetry","isProp":true,"docString":"The braiding isomorphism is symmetric. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {S : C ‚•§ D}\n  {T : D} [inst_2 : CategoryTheory.WellPowered C·µí·µñ] [inst_3 : CategoryTheory.Limits.HasColimits C]\n  [inst_4 : CategoryTheory.Limits.PreservesColimits S],\n  CategoryTheory.WellPowered (CategoryTheory.CostructuredArrow S T)·µí·µñ","name":"CategoryTheory.CostructuredArrow.well_copowered_costructuredArrow","isProp":true,"docString":"If `C` is well-copowered and cocomplete and `S` preserves colimits, then\n`CostructuredArrow S T` is well-copowered. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 : AffineSubspace k P} {s2 : AffineSubspace k P} {p1 : P} {p2 : P} (hp1 : p1 ‚àà s1)\n  (hp2 : p2 ‚àà s2),\n  AffineSubspace.direction (s1 ‚äî s2) =\n    AffineSubspace.direction s1 ‚äî AffineSubspace.direction s2 ‚äî Submodule.span k {p2 -·µ• p1}","name":"AffineSubspace.direction_sup","isProp":true,"docString":"The direction of the sup of two nonempty affine subspaces is the sup of the two directions and\nof any one difference between points in the two subspaces. "},{"type":"‚àÄ {a : Prop} (h‚ÇÅ : a) (h‚ÇÇ : a), h‚ÇÅ = h‚ÇÇ","name":"proof_irrel","isProp":true,"docString":"**Alias** of `proofIrrel`."},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCommGroup Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"LinearOrderedCommGroup.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ {Œ± : Type u_3} {Œπ : Type u_2} {Œπ' : Type u_1} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] {s : Set Œπ'}\n  {g : (a : Œπ') ‚Üí Finset Œπ} {f : (a : Œπ) ‚Üí Œ±} (hs : Set.PairwiseDisjoint s fun (i' : Œπ') ‚Ü¶ Finset.sup (g i') f)\n  (hg : ‚àÄ (i : Œπ') (a : i ‚àà s), Set.PairwiseDisjoint (‚Üë(g i)) f),\n  Set.PairwiseDisjoint (Set.union·µ¢ fun (i : Œπ') ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà s) ‚Ü¶ ‚Üë(g i)) f","name":"Set.PairwiseDisjoint.bunion·µ¢_finset","isProp":true,"docString":"Bind operation for `Set.PairwiseDisjoint`. In a complete lattice, you can use\n`Set.PairwiseDisjoint.bunion·µ¢`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {Œµ : ‚Ñù} (Œµ0 : 0 < Œµ),\n  (setOf fun (p : Œ± √ó Œ±) ‚Ü¶ dist (Prod.fst p) (Prod.snd p) < Œµ) ‚àà uniformity Œ±","name":"Metric.dist_mem_uniformity","isProp":true,"docString":"A constant size neighborhood of the diagonal is an entourage. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i0 : Œπ),\n  vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : Œπ) ‚Ü¶ p i0 -·µ• p i)","name":"vectorSpan_range_eq_span_range_vsub_left","isProp":true,"docString":"The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the left. "},{"type":"‚àÄ {Œπ : Sort u_2} {M : Type u_1} [inst : Mul M] (S : (a : Œπ) ‚Üí Subsemigroup M)\n  {C : (x : M) ‚Üí (a : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) ‚Üí Prop}\n  (hp :\n    ‚àÄ (i : Œπ) (x : M) (hxS : x ‚àà S i),\n      C x ((Subsemigroup.mem_sup·µ¢_of_mem i hxS=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (hmul :\n    ‚àÄ (x : M) (y : M) (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hy : y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (a : C x hx) (a : C y hy),\n      C (x * y) ((mul_mem hx hy=:x * y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x * y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  {x‚ÇÅ : M} (hx‚ÇÅ : x‚ÇÅ ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i), C x‚ÇÅ hx‚ÇÅ","name":"Subsemigroup.sup·µ¢_induction'","isProp":true,"docString":"A dependent version of `Subsemigroup.sup·µ¢_induction`. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} (p : (a : Œπ) ‚Üí P) {s : Set Œπ} {i : Œπ} (hi : i ‚àà s),\n  vectorSpan k (p '' s) = Submodule.span k ((fun (x : P) ‚Ü¶ x -·µ• p i) '' (p '' (s \\ {i})))","name":"vectorSpan_image_eq_span_vsub_set_right_ne","isProp":true,"docString":"The `vectorSpan` of the image of a function is the span of the pairwise subtractions with a\ngiven point on the right, excluding the subtraction of that point from itself. "},{"type":"‚àÄ {Œ± : Type u} (s : Set Œ±), IsClosed (setOf fun (u : Ultrafilter Œ±) ‚Ü¶ s ‚àà u)","name":"ultrafilter_isClosed_basic","isProp":true,"docString":"The basic open sets for the topology on ultrafilters are also closed. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Mul G] [inst_1 : Mul H] {A : Finset G} {B : Finset G} {a0 : G} {b0 : G}\n  (f : G ‚Ü™ H) (mul : ‚àÄ (x : G) (y : G), ‚Üëf (x * y) = ‚Üëf x * ‚Üëf y),\n  (UniqueMul (Finset.map f A) (Finset.map f B) (‚Üëf a0) (‚Üëf b0) : Prop) ‚Üî (UniqueMul A B a0 b0 : Prop)","name":"UniqueMul.mulHom_map_iff","isProp":true,"docString":"`UniqueMul` is preserved under embeddings that are multiplicative.\n\nSee `UniqueMul.mulHom_image_iff` for a version with swapped bundling. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±},\n  (¬¨(BddAbove s : Prop) : Prop) ‚Üî (‚àÄ (x : Œ±), ‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (¬¨(y ‚â§ x : Prop) : Prop) : Prop)","name":"not_bddAbove_iff'","isProp":true,"docString":"A set `s` is not bounded above if and only if for each `x` there exists `y ‚àà s` such that `x`\nis not greater than or equal to `y`. This version only assumes `Preorder` structure and uses\n`¬¨(y ‚â§ x)`. A version for linear orders is called `not_bddAbove_iff`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïú E] {p : (a : Œπ) ‚Üí E} (hc : ConvexIndependent ùïú p), ConvexIndependent ùïú Subtype.val","name":"ConvexIndependent.range","isProp":true,"docString":"If an indexed family of points is convex independent, so is the corresponding set of points. "},{"type":"‚àÄ {G : Type u} [inst : Mul G] [self : IsLeftCancelMul G] (a : G) (b : G) (c : G) (a : a * b = a * c), b = c","name":"IsLeftCancelMul.mul_left_cancel","isProp":true,"docString":"Multiplication is left cancellative. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.SplitEpiCategory C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Epi f], CategoryTheory.IsSplitEpi f","name":"CategoryTheory.isSplitEpi_of_epi","isProp":true,"docString":"In a category in which every epimorphism is split, every epimorphism splits. This is not an\ninstance because it would create an instance loop. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n  [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (sup·µ¢ g)) (Af : Antitone f),\n  f (sup·µ¢ fun (i : Œπ) ‚Ü¶ g i) = inf·µ¢ fun (i : Œπ) ‚Ü¶ f (g i)","name":"Antitone.map_sup·µ¢_of_continuousAt'","isProp":true,"docString":"An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. "},{"type":"‚àÄ {Œ± : Type u_4} {M : Type u_1} {N : Type u_2} {P : Type u_3} [inst : Zero M] [inst_1 : CommMonoid N]\n  [inst_2 : CommMonoid P] (h : N ‚Üí* P) (f : Œ± ‚Üí‚ÇÄ M) (g : (a : Œ±) ‚Üí (a : M) ‚Üí N),\n  ‚Üëh (Finsupp.prod f g) = Finsupp.prod f fun (a : Œ±) (b : M) ‚Ü¶ ‚Üëh (g a b)","name":"MonoidHom.map_finsupp_prod","isProp":true,"docString":"Deprecated, use `_root_.map_finsupp_prod` instead. "},{"type":"‚àÄ {Œ± : Sort u} {f : (a : Œ±) ‚Üí Œ±} (h : Function.Involutive f) (P : Prop) [inst : Decidable (P : Prop)] (x : Œ±),\n  f (if (P : Prop) then x else f x) = if (¬¨(P : Prop) : Prop) then x else f x","name":"Function.Involutive.ite_not","isProp":true,"docString":"Involuting an `ite` of an involuted value `x : Œ±` negates the `Prop` condition in the `ite`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {x : G} {y : G},\n  (y ‚àà AddSubgroup.closure {x} : Prop) ‚Üî (‚àÉ (n : ‚Ñ§), n ‚Ä¢ x = y : Prop)","name":"AddSubgroup.mem_closure_singleton","isProp":true,"docString":"The `AddSubgroup` generated by an element of an `AddGroup` equals the set of\nnatural number multiples of the element."},{"type":"‚àÄ {Œπ : Type u_2} {E : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí TopologicalSpace (E i)] {s : (i : Œπ) ‚Üí Set (Set (E i))}\n  (hs : ‚àÄ (i : Œπ), TopologicalSpace.IsTopologicalBasis (s i)),\n  TopologicalSpace.IsTopologicalBasis (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ (fun (u : Set (E i)) ‚Ü¶ Sigma.mk i '' u) '' s i)","name":"TopologicalSpace.IsTopologicalBasis.sigma","isProp":true,"docString":"In a disjoint union space `Œ£ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. "},{"type":"‚àÄ {a : ‚Ñ§} {m : ‚Ñï} {n : ‚Ñï} (h : Int.gcd a (‚Üëm * ‚Üën) = 1), Int.gcd a ‚Üën = 1","name":"Int.gcd_eq_one_of_gcd_mul_right_eq_one_right","isProp":true,"docString":"If `gcd a (m * n) = 1`, then `gcd a n = 1`. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} {n : ‚Ñ§} (a : Equiv.Perm.SameCycle f x y),\n  Equiv.Perm.SameCycle f (‚Üë(f ^ n) x) y","name":"Equiv.Perm.SameCycle.zpow_left","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_zpow_left`."},{"type":"‚àÄ {G : Type u} [inst : AddLeftCancelMonoid G] [inst_1 : Finite G] (x : G), 0 < addOrderOf x","name":"addOrderOf_pos","isProp":true,"docString":"This is the same as `addOrderOf_pos' but with one fewer explicit\nassumption since this is automatic in case of a finite cancellative additive monoid."},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N] {f : M ‚Üí+ N}\n  (h : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëf ‚Üëy)) (y : { x : M // x ‚àà S }) (w : N) (z : N),\n  (z = w + ‚Üë(-‚Üë(IsAddUnit.liftRight (AddMonoidHom.restrict f S) h) y) : Prop) ‚Üî (z + ‚Üëf ‚Üëy = w : Prop)","name":"AddSubmonoid.LocalizationMap.add_neg_right","isProp":true,"docString":"Given an AddMonoidHom `f : M ‚Üí+ N` and Submonoid `S ‚äÜ M` such that\n`f(S) ‚äÜ AddUnits N`, for all `w, z : N` and `y ‚àà S`, we have `z = w - f y ‚Üî z + f y = w`."},{"type":"‚àÄ (k : Type u_2) {V : Type u_4} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} [inst_4 : DecidableEq Œπ] [inst_5 : Invertible 2] (p : (a : Œπ) ‚Üí P) (i‚ÇÅ : Œπ)\n  (i‚ÇÇ : Œπ), Finset.centroid k {i‚ÇÅ, i‚ÇÇ} p = 2‚Åª¬π ‚Ä¢ (p i‚ÇÇ -·µ• p i‚ÇÅ) +·µ• p i‚ÇÅ","name":"Finset.centroid_pair","isProp":true,"docString":"The centroid of two points, expressed directly as adding a vector\nto a point. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : Embedding f), Function.Injective f","name":"Embedding.inj","isProp":true,"docString":"A topological embedding is injective. "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedCancelAddCommMonoid Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a : a + b ‚â§ a + c), b ‚â§ c","name":"OrderedCancelAddCommMonoid.le_of_add_le_add_left","isProp":true,"docString":"Additive cancellation is compatible with the order in an ordered cancellative additive\ncommutative monoid. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (A : Set P) [inst_4 : Nonempty ‚ÜëA], affineSpan k (Subtype.val ‚Åª¬π' A) = ‚ä§","name":"affineSpan_coe_preimage_eq_top","isProp":true,"docString":"A set, considered as a subset of its spanned affine subspace, spans the whole subspace. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 :\n    ‚àÄ {J : Type w} {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y},\n      CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelFamily f)],\n  CategoryTheory.Limits.HasWideCoequalizers C","name":"CategoryTheory.Limits.hasWideCoequalizers_of_hasColimit_parallelFamily","isProp":true,"docString":"If `C` has all colimits of diagrams `parallelFamily f`, then it has all wide coequalizers "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {u : V} {v : V} {w : V} (p : SimpleGraph.Walk G u v) (h : SimpleGraph.Adj G v w),\n  ‚àÉ (x : V),\n    ‚àÉ (h' : SimpleGraph.Adj G u x),\n      ‚àÉ (q : SimpleGraph.Walk G x w), SimpleGraph.Walk.concat p h = SimpleGraph.Walk.cons h' q","name":"SimpleGraph.Walk.exists_concat_eq_cons","isProp":true,"docString":"A non-trivial `concat` walk is representable as a `cons` walk. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G], AddAction.IsPretransitive G G","name":"AddAction.Regular.isPretransitive","isProp":true,"docString":"The regular action of a group on itself is transitive."},{"type":"‚àÄ {Œ± : Type u_1} {œÉ : Type u_2} [inst : Zero Œ±] [inst_1 : LinearOrder Œ±]\n  [inst_2 : IsWellOrder Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] [inst_3 : Finite œÉ] (S : Set (œÉ ‚Üí‚ÇÄ Œ±)), Set.IsPwo S","name":"Finsupp.isPwo","isProp":true,"docString":"A version of **Dickson's lemma** any subset of functions `œÉ ‚Üí‚ÇÄ Œ±` is partially well\nordered, when `œÉ` is `Finite` and `Œ±` is a linear well order.\nThis version uses finsupps on a finite type as it is intended for use with `MVPowerSeries`.\n"},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] (s : Subsemiring R) (m : Multiset R) (a : ‚àÄ (a : R) (a_1 : a ‚àà m), a ‚àà s),\n  Multiset.prod m ‚àà s","name":"Subsemiring.multiset_prod_mem","isProp":true,"docString":"Product of a multiset of elements in a `Subsemiring` of a `CommSemiring`\nis in the `Subsemiring`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] [inst_4 : ContinuousAdd Œ≥] {f : (a : Œ±) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ≥} (hf : LowerSemicontinuousAt f x) (hg : LowerSemicontinuousAt g x),\n  LowerSemicontinuousAt (fun (z : Œ±) ‚Ü¶ f z + g z) x","name":"LowerSemicontinuousAt.add","isProp":true,"docString":"The sum of two lower semicontinuous functions is lower semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Multiset Œ±} (a : Multiset.Nodup s), Multiset.dedup s = s","name":"Multiset.Nodup.dedup","isProp":true,"docString":"**Alias** of the reverse direction of `Multiset.dedup_eq_self`."},{"type":"‚àÄ {Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {m : ‚Ñï} {n : ‚Ñï} {a : Œ±} (hf : Function.Injective f) (a_1 : (f^[m + n]) a = (f^[n]) a),\n  (f^[m]) a = a","name":"Function.iterate_cancel_of_add","isProp":true,"docString":"**Alias** of the forward direction of `Function.iterate_add_eq_iterate`."},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Type u_1}\n  {s : Set Œπ} [inst_3 : IsNoetherian K V] (b : Basis (‚Üës) K V), Set.Finite s","name":"IsNoetherian.finite_basis_index","isProp":true,"docString":"In a noetherian module over a division ring,\nif a basis is indexed by a set, that set is finite. "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (habc : a ‚à£ b * c) (hab : Int.gcd a c = 1), a ‚à£ b","name":"Int.dvd_of_dvd_mul_left_of_gcd_one","isProp":true,"docString":"Euclid's lemma: if `a ‚à£ b * c` and `gcd a c = 1` then `a ‚à£ b`.\nCompare with `IsCoprime.dvd_of_dvd_mul_left` and\n`UniqueFactorizationMonoid.dvd_of_dvd_mul_left_of_no_prime_factors` "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i","name":"MonovaryOn.sum_comp_perm_mul_le_sum_mul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and\n`g` monovary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±} {a : Œ±} (h : IsLeast s a), BddBelow s","name":"IsLeast.bddBelow","isProp":true,"docString":"If `s` has a least element, then it is bounded below. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : MonotoneOn f s), AntitoneOn (‚ÜëOrderDual.toDual ‚àò f) s","name":"MonotoneOn.dual_right","isProp":true,"docString":"**Alias** of the reverse direction of `antitoneOn_toDual_comp_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Norm Œ±] [inst_1 : One Œ±] [self : NormOneClass Œ±], ‚Äñ1‚Äñ = 1","name":"NormOneClass.norm_one","isProp":true,"docString":"The norm of the multiplicative identity is 1. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 : ‚àÄ {X : C} {Y : C}, CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)],\n  CategoryTheory.Limits.HasBinaryProducts C","name":"CategoryTheory.Limits.hasBinaryProducts_of_hasLimit_pair","isProp":true,"docString":"If `C` has all limits of diagrams `pair X Y`, then it has all binary products "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : MetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (h : UniformEmbedding f), Isometry f","name":"UniformEmbedding.to_isometry","isProp":true,"docString":"A uniform embedding from a uniform space to a metric space is an isometry with respect to the\ninduced metric space structure on the source space. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} [inst : Applicative m]\n  [inst_1 : LawfulApplicative m] {x : m Œ±} (h : ‚àÄ (a : Œ±), p a), SatisfiesM p x","name":"SatisfiesM.of_true","isProp":true,"docString":"If `p` is always true, then every `x` satisfies it. "},{"type":"‚àÄ {Œ± : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsTrichotomous Œ± r] [inst : IsIrrefl Œ± r] {a : Œ±} {b : Œ±}\n  (H : ‚àÄ (x : Œ±), (r x a : Prop) ‚Üî (r x b : Prop)), a = b","name":"extensional_of_trichotomous_of_irrefl","isProp":true,"docString":"In a trichotomous irreflexive order, every element is determined by the set of predecessors. "},{"type":"‚àÄ (R : Type u_1) {K : Type u_2} [inst : CommRing R] [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] (p : ‚Ñï) [inst : CharP R p], CharP K p","name":"IsFractionRing.charP_of_isFractionRing","isProp":true,"docString":"If `R` has characteristic `p`, then so does Frac(R). "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeSup Œ±] (a : Œ±), Filter.map Subtype.val Filter.atTop = Filter.atTop","name":"Filter.map_val_Ici_atTop","isProp":true,"docString":"The image of the filter `atTop` on `Ici a` under the coercion equals `atTop`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {s : (a : Œπ) ‚Üí Set Œ±} (self : IndexedPartition s) (i : Œπ),\n  IndexedPartition.some self i ‚àà s i","name":"IndexedPartition.some_mem","isProp":true,"docString":"membership invariance for `some`"},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Set Œ±}, (Set.IsWf s : Prop) ‚Üî (Set.IsPwo s : Prop)","name":"Set.isWf_iff_isPwo","isProp":true,"docString":"In a linear order, the predicates `Set.IsWf` and `Set.IsPwo` are equivalent. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : AddCommMonoid Œ≤] [inst_1 : AddCommMonoid Œ≥] (g : Œ≤ ‚âÉ+ Œ≥)\n  (f : (a : Œ±) ‚Üí Œ≤) (s : Finset Œ±), ‚Üëg (Finset.sum s fun (x : Œ±) ‚Ü¶ f x) = Finset.sum s fun (x : Œ±) ‚Ü¶ ‚Üëg (f x)","name":"AddEquiv.map_sum","isProp":true,"docString":"Deprecated: use `_root_.map_sum` instead."},{"type":"‚àÄ (n : ‚Ñï),\n  Finset.univ =\n    Finset.cons (Fin.last n) (Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ)\n      ((of_eq_true\n            ((Eq.trans\n                  ((congrArg Not\n                        ((Eq.trans\n                              ((Eq.trans\n                                    ((Eq.trans\n                                          ((congrArg (Membership.mem (Fin.last n))\n                                                ((Eq.trans\n                                                      ((Finset.map_eq_image (RelEmbedding.toEmbedding Fin.castSucc)\n                                                            Finset.univ=:Finset.map\n                                                              (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ =\n                                                            Finset.image (‚Üë(RelEmbedding.toEmbedding Fin.castSucc))\n                                                              Finset.univ)=:Finset.map\n                                                            (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ =\n                                                          Finset.image (‚Üë(RelEmbedding.toEmbedding Fin.castSucc))\n                                                            Finset.univ)\n                                                      ((Fin.image_castSucc\n                                                            n=:Finset.image (‚ÜëFin.castSucc) Finset.univ =\n                                                            {Fin.last\n                                                                  n}·∂ú)=:Finset.image (‚ÜëFin.castSucc) Finset.univ =\n                                                          {Fin.last\n                                                                n}·∂ú)=:Finset.map (RelEmbedding.toEmbedding Fin.castSucc)\n                                                        Finset.univ =\n                                                      {Fin.last\n                                                            n}·∂ú)=:Finset.map (RelEmbedding.toEmbedding Fin.castSucc)\n                                                      Finset.univ =\n                                                    {Fin.last\n                                                          n}·∂ú)=:(Fin.last n ‚àà\n                                                    Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                                                  Prop) =\n                                                (Fin.last n ‚àà {Fin.last n}·∂ú :\n                                                  Prop))=:(Fin.last n ‚àà\n                                                  Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                                                Prop) =\n                                              (Fin.last n ‚àà {Fin.last n}·∂ú : Prop))\n                                          ((Mathlib.Data.Fintype.Basic._auxLemma.8=:(Fin.last n ‚àà {Fin.last n}·∂ú :\n                                                  Prop) =\n                                                (¬¨(Fin.last n ‚àà {Fin.last n} : Prop) :\n                                                  Prop))=:(Fin.last n ‚àà {Fin.last n}·∂ú : Prop) =\n                                              (¬¨(Fin.last n ‚àà {Fin.last n} : Prop) :\n                                                Prop))=:(Fin.last n ‚àà\n                                              Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                                            Prop) =\n                                          (¬¨(Fin.last n ‚àà {Fin.last n} : Prop) :\n                                            Prop))=:(Fin.last n ‚àà\n                                            Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                                          Prop) =\n                                        (¬¨(Fin.last n ‚àà {Fin.last n} : Prop) : Prop))\n                                    ((congrArg Not\n                                          ((Eq.trans\n                                                ((Mathlib.Data.Finset.Basic._auxLemma.26=:(Fin.last n ‚àà {Fin.last n} :\n                                                        Prop) =\n                                                      (Fin.last n = Fin.last n :\n                                                        Prop))=:(Fin.last n ‚àà {Fin.last n} : Prop) =\n                                                    (Fin.last n = Fin.last n : Prop))\n                                                ((eq_self\n                                                      (Fin.last\n                                                        n)=:(Fin.last n = Fin.last n : Prop) =\n                                                      (True :\n                                                        Prop))=:(Fin.last n = Fin.last n : Prop) =\n                                                    (True :\n                                                      Prop))=:(Fin.last n ‚àà {Fin.last n} : Prop) =\n                                                (True :\n                                                  Prop))=:(Fin.last n ‚àà {Fin.last n} : Prop) =\n                                              (True :\n                                                Prop))=:(¬¨(Fin.last n ‚àà {Fin.last n} : Prop) : Prop) =\n                                          (¬¨(True : Prop) :\n                                            Prop))=:(¬¨(Fin.last n ‚àà {Fin.last n} : Prop) : Prop) =\n                                        (¬¨(True : Prop) :\n                                          Prop))=:(Fin.last n ‚àà\n                                        Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                                      Prop) =\n                                    (¬¨(True : Prop) :\n                                      Prop))=:(Fin.last n ‚àà\n                                      Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                                    Prop) =\n                                  (¬¨(True : Prop) : Prop))\n                              (Std.Logic._auxLemma.3=:(¬¨(True : Prop) : Prop) =\n                                  (False :\n                                    Prop))=:(Fin.last n ‚àà\n                                  Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                                Prop) =\n                              (False :\n                                Prop))=:(Fin.last n ‚àà Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                              Prop) =\n                            (False :\n                              Prop))=:(¬¨(Fin.last n ‚àà Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                              Prop) :\n                          Prop) =\n                        (¬¨(False : Prop) :\n                          Prop))=:(¬¨(Fin.last n ‚àà Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n                            Prop) :\n                        Prop) =\n                      (¬¨(False : Prop) : Prop))\n                  (not_false_eq_true=:(¬¨(False : Prop) : Prop) =\n                      (True :\n                        Prop))=:(¬¨(Fin.last n ‚àà Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ : Prop) :\n                    Prop) =\n                  (True :\n                    Prop))=:(¬¨(Fin.last n ‚àà Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ : Prop) :\n                  Prop) =\n                (True :\n                  Prop))=:¬¨(Fin.last n ‚àà Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ :\n              Prop))=:¬¨(Fin.last n ‚àà Finset.map (RelEmbedding.toEmbedding Fin.castSucc) Finset.univ : Prop))","name":"Fin.univ_castSucc","isProp":true,"docString":"Embed `Fin n` into `Fin (n + 1)` by appending a new `Fin.last n` to the `univ` "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCancelAddCommMonoid Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"LinearOrderedCancelAddCommMonoid.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Fintype Œ±] {ùíú : Finset (Finset Œ±)} {r : ‚Ñï} (a : Set.Sized r ‚Üëùíú),\n  ùíú ‚äÜ Finset.powersetLen r Finset.univ","name":"Set.Sized.subset_powersetLen_univ","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.subset_powersetLen_univ_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [self : CoheytingAlgebra Œ±] (a : Œ±), a ‚â§ ‚ä§","name":"CoheytingAlgebra.le_top","isProp":true,"docString":"`‚ä§` is a greatest element "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {J : Type u} [inst_1 : CategoryTheory.Category J] {j : J}\n  (I : CategoryTheory.Limits.IsTerminal j) (F : J ‚•§ C) [inst_2 : CategoryTheory.Limits.HasColimit F],\n  CategoryTheory.IsIso (CategoryTheory.Limits.colimit.Œπ F j)","name":"CategoryTheory.Limits.isIso_Œπ_of_isTerminal","isProp":true,"docString":"If `j` is terminal in the index category, then the map `colimit.Œπ F j` is an isomorphism.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {p : Filter Œπ} [inst_1 : TopologicalSpace Œ±] (h : TendstoUniformlyOn F f p s)\n  (hc : Filter.Eventually (fun (n : Œπ) ‚Ü¶ ContinuousOn (F n) s) p) [inst_2 : Filter.NeBot p], ContinuousOn f s","name":"TendstoUniformlyOn.continuousOn","isProp":true,"docString":"A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  [inst_2 : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)],\n  CategoryTheory.IsSplitEpi CategoryTheory.Limits.prod.snd","name":"CategoryTheory.Limits.isSplitEpi_prod_snd","isProp":true,"docString":"In the presence of zero morphisms, projections into a product are (split) epimorphisms. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  {c : CategoryTheory.Limits.Fork f g} (i : CategoryTheory.Limits.IsLimit c),\n  CategoryTheory.Mono (CategoryTheory.Limits.Fork.Œπ c)","name":"CategoryTheory.Limits.mono_of_isLimit_fork","isProp":true,"docString":"The equalizer morphism in any limit cone is a monomorphism. "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroSMulDivisors R M] {x : M} {y : M},\n  ((SameRay R x y : Prop) ‚à® ((x ‚â† 0 : Prop) ‚àß ((y ‚â† 0 : Prop) ‚àß (SameRay R x (-y) : Prop) : Prop) : Prop) : Prop) ‚Üî\n    (¬¨(LinearIndependent R ![x, y] : Prop) : Prop)","name":"sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent","isProp":true,"docString":"Two vectors are in the same ray, or they are nonzero and the first is in the same ray as the\nnegation of the second, if and only if they are not linearly independent. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : LowerTopology Œ±] {s : Set Œ±}\n  (h : Set.Finite s), IsClosed ‚Üë(upperClosure s)","name":"LowerTopology.isClosed_upperClosure","isProp":true,"docString":"The upper closure of a finite set is closed in the lower topology. "},{"type":"‚àÄ {F : (a : Type u) ‚Üí Type v} [inst : Applicative F] {G : (a : Type u) ‚Üí Type w} [inst_1 : Applicative G]\n  (self : ApplicativeTransformation F G) {Œ± : Type u} {Œ≤ : Type u} (x : F ((a : Œ±) ‚Üí Œ≤)) (y : F Œ±),\n  ApplicativeTransformation.app self Œ≤ (Seq.seq x fun (x : Unit) ‚Ü¶ y) =\n    Seq.seq (ApplicativeTransformation.app self ((a : Œ±) ‚Üí Œ≤) x) fun (x : Unit) ‚Ü¶ ApplicativeTransformation.app self Œ± y","name":"ApplicativeTransformation.preserves_seq'","isProp":true,"docString":"An `ApplicativeTransformation` intertwines `seq`. "},{"type":"‚àÄ {Œπ : Type v} {f : (a : Œπ) ‚Üí Cardinal} {t : Cardinal} (hf : BddAbove (Set.range f))\n  (w : ‚àÄ (i : Œπ), Cardinal.lift (f i) ‚â§ t), Cardinal.lift (sup·µ¢ f) ‚â§ t","name":"Cardinal.lift_sup·µ¢_le","isProp":true,"docString":"To prove that the lift of a supremum is bounded by some cardinal `t`,\nit suffices to show that the lift of each cardinal is bounded by `t`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D·µí·µñ}\n  [inst_2 : CategoryTheory.Faithful F], CategoryTheory.Faithful (CategoryTheory.Functor.leftOp F)","name":"CategoryTheory.Functor.leftOp_faithful","isProp":true,"docString":"If F is faithful then the left_op of F is also faithful. "},{"type":"‚àÄ {Œ± : Type} {d : ‚Ñï} {ds : List ‚Ñï} [inst : Ring Œ±] (x : Holor Œ± (d :: ds)),\n  (Finset.sum (Finset.attach (Finset.range d)) fun (i : { x : ‚Ñï // x ‚àà Finset.range d }) ‚Ü¶\n      Holor.mul (Holor.unitVec d ‚Üëi)\n        (Holor.slice x ‚Üëi\n          ((Nat.succ_le_of_lt\n                ((Iff.mp\n                      ((Finset.mem_range=:(‚Üëi ‚àà Finset.range d : Prop) ‚Üî\n                            (‚Üëi < d : Prop))=:(‚Üëi ‚àà Finset.range d : Prop) ‚Üî (‚Üëi < d : Prop))\n                      ((Subtype.prop\n                            i=:‚Üëi ‚àà\n                            Finset.range\n                              d)=:‚Üëi ‚àà Finset.range d)=:‚Üëi < d)=:‚Üëi < d)=:Nat.succ ‚Üëi ‚â§ d)=:Nat.succ ‚Üëi ‚â§ d))) =\n    x","name":"Holor.sum_unitVec_mul_slice","isProp":true,"docString":"The original holor can be recovered from its slices by multiplying with unit vectors and\nsumming up. "},{"type":"‚àÄ {Œ± : Type u_1} {G‚ÇÄ : Type u_2} [inst : GroupWithZero G‚ÇÄ] [inst_1 : MulAction G‚ÇÄ Œ±] [inst_2 : TopologicalSpace Œ±]\n  [inst_3 : ContinuousConstSMul G‚ÇÄ Œ±] {c : G‚ÇÄ} {s : Set Œ±} {x : Œ±} (hs : s ‚àà nhds x) (hc : c ‚â† 0), c ‚Ä¢ s ‚àà nhds (c ‚Ä¢ x)","name":"set_smul_mem_nhds_smul","isProp":true,"docString":"Scalar multiplication preserves neighborhoods. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±},\n  (f =O[l] g' : Prop) ‚Üî\n    (Filter.Eventually (fun (c : ‚Ñù) ‚Ü¶ Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ ‚â§ c * ‚Äñg' x‚Äñ) l) Filter.atTop : Prop)","name":"Asymptotics.isBigO_iff_eventually","isProp":true,"docString":"`f = O(g)` if and only if `‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ` for all sufficiently large `c`. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : AddGroup G] [inst_1 : SubtractionMonoid H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F) (a : G) (b : G), ‚Üëf (a - b) = ‚Üëf a - ‚Üëf b","name":"map_sub","isProp":true,"docString":"Additive group homomorphisms preserve subtraction."},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí SeminormedGroup (œÄ i)]\n  {x : (i : Œπ) ‚Üí œÄ i} {r : ‚Ñù} (hr : 0 < r), (‚Äñx‚Äñ < r : Prop) ‚Üî (‚àÄ (i : Œπ), ‚Äñx i‚Äñ < r : Prop)","name":"pi_norm_lt_iff'","isProp":true,"docString":"The seminorm of an element in a product space is `< r` if and only if the norm of each\ncomponent is. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : LocallyFiniteOrderTop Œ±] (a : Œ±),\n  Finset.Ici a =\n    Finset.cons a (Finset.Ioi a) ((Finset.not_mem_Ioi_self=:¬¨(a ‚àà Finset.Ioi a : Prop))=:¬¨(a ‚àà Finset.Ioi a : Prop))","name":"Finset.Ici_eq_cons_Ioi","isProp":true,"docString":"`Finset.cons` version of `Finset.Ioi_insert`. "},{"type":"‚àÄ {A : Type u_1} [inst : AddMonoid A] {s : Set A} (self : IsAddSubmonoid s) {a : A} {b : A} (a_1 : a ‚àà s) (a_2 : b ‚àà s),\n  a + b ‚àà s","name":"IsAddSubmonoid.add_mem","isProp":true,"docString":"The proposition that s is closed under addition. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], (0 ‚â† 1 : Prop) ‚à® (‚àÄ (a : M‚ÇÄ), a = 0 : Prop)","name":"zero_ne_one_or_forall_eq_0","isProp":true,"docString":"In a monoid with zero, either zero and one are nonequal, or zero is the only element. "},{"type":"‚àÄ {Œ≤ : Type u_1} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} [inst : IsTrans Œ≤ s],\n  (WellFounded s : Prop) ‚Üî (‚àÄ (b : Œ≤), WellFounded (Subrel s (setOf fun (b' : Œ≤) ‚Ü¶ s b' b)) : Prop)","name":"wellFounded_iff_wellFounded_subrel","isProp":true,"docString":"A relation is well-founded iff every principal segment of it is well-founded.\n\nIn this lemma we use `Subrel` to indicate its principal segments because it's usually more\nconvenient to use.\n"},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (r : R) (s : R)\n  (x : M), (r * s) ‚Ä¢ x = r ‚Ä¢ s ‚Ä¢ x","name":"Module.Core.mul_smul","isProp":true,"docString":"Scalar multiplication distributes over multiplication from the right. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] {Œ≤ : Type u_2} [inst_1 : Fintype Œ≤] (s : Set Œ≤)\n  [inst_2 : DecidablePred fun (x : Œ≤) ‚Ü¶ x ‚àà s] (f : (a : Œ≤) ‚Üí Œ±) (g : (a : ‚Üës) ‚Üí Œ±)\n  (w : ‚àÄ (x : Œ≤) (h : x ‚àà s), f x = g { val := x, property := h }) (w' : ‚àÄ (x : Œ≤) (a : ¬¨(x ‚àà s : Prop)), f x = 1),\n  Finset.prod Finset.univ f = Finset.prod Finset.univ g","name":"Finset.prod_congr_set","isProp":true,"docString":"The product of a function `g` defined only on a set `s` is equal to\nthe product of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 1` off `s`. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] {I : Ideal R} {S : Type v} [inst_1 : NonAssocSemiring S] ‚¶Éf : R ‚ß∏ I ‚Üí+* S‚¶Ñ\n  ‚¶Ég : R ‚ß∏ I ‚Üí+* S‚¶Ñ (h : RingHom.comp f (Ideal.Quotient.mk I) = RingHom.comp g (Ideal.Quotient.mk I)), f = g","name":"Ideal.Quotient.ringHom_ext","isProp":true,"docString":"Two `RingHom`s from the quotient by an ideal are equal if their\ncompositions with `Ideal.Quotient.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {œÉ : outParam (R ‚Üí+* S)} {œÉ' : outParam (S ‚Üí+* R)} [inst_2 : RingHomInvPair œÉ œÉ'] [inst_3 : RingHomInvPair œÉ' œÉ]\n  {M : outParam (Type u_4)} [inst_4 : TopologicalSpace M] [inst_5 : AddCommMonoid M] {M‚ÇÇ : outParam (Type u_5)}\n  [inst_6 : TopologicalSpace M‚ÇÇ] [inst_7 : AddCommMonoid M‚ÇÇ] [inst_8 : Module R M] [inst_9 : Module S M‚ÇÇ]\n  [self : ContinuousSemilinearEquivClass F œÉ M M‚ÇÇ] (f : F), Continuous ‚Üëf","name":"ContinuousSemilinearEquivClass.map_continuous","isProp":true,"docString":"`ContinuousSemilinearEquivClass F œÉ M M‚ÇÇ` asserts `F` is a type of bundled continuous\n`œÉ`-semilinear equivs `M ‚Üí M‚ÇÇ`.  See also `ContinuousLinearEquivClass F R M M‚ÇÇ` for the case\nwhere `œÉ` is the identity map on `R`.  A map `f` between an `R`-module and an `S`-module over a ring\nhomomorphism `œÉ : R ‚Üí+* S` is semilinear if it satisfies the two properties `f (x + y) = f x + f y`\nand `f (c ‚Ä¢ x) = (œÉ c) ‚Ä¢ f x`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p : P} {s : Set P} (hp : p ‚àà s), p ‚àà affineSpan k s","name":"mem_affineSpan","isProp":true,"docString":"A point in a set is in its affine span. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : IsSuccArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h1 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico n m), r i (Order.succ i))\n  (h2 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico m n), r (Order.succ i) i), Relation.ReflTransGen r n m","name":"reflTransGen_of_succ","isProp":true,"docString":"`(n, m)` is in the reflexive-transitive closure of `~` if `i ~ succ i` and `succ i ~ i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f : M ‚Üí‚Çô* N} {g : M ‚Üí‚Çô* N},\n  (f = g : Prop) ‚Üî (‚àÄ (x : M), ‚Üëf x = ‚Üëg x : Prop)","name":"MulHom.ext_iff","isProp":true,"docString":"Deprecated: use `FunLike.ext_iff` instead. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f (‚Üëf‚Åª¬π x) y), Equiv.Perm.SameCycle f x y","name":"Equiv.Perm.SameCycle.of_inv_apply_left","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.sameCycle_inv_apply_left`."},{"type":"‚àÄ {R : Type u} [inst : NonUnitalSemiring R] [inst_1 : PartialOrder R] [self : StarOrderedRing R] (a : R) (b : R)\n  (a_1 : a ‚â§ b) (c : R), c + a ‚â§ c + b","name":"StarOrderedRing.add_le_add_left","isProp":true,"docString":"addition commutes with `‚â§` "},{"type":"‚àÄ {Œ± : Type u} [inst : NonUnitalNonAssocRing Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} {e : Œ±},\n  (a * e + c = b * e + d : Prop) ‚Üî ((a - b) * e + c = d : Prop)","name":"mul_add_eq_mul_add_iff_sub_mul_add_eq","isProp":true,"docString":"An iff statement following from right distributivity in rings and the definition\nof subtraction. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCancelAddCommMonoid Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"LinearOrderedCancelAddCommMonoid.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Fin (n + 1)) ‚Üí Œ±},\n  (Monotone f : Prop) ‚Üî (‚àÄ (i : Fin n), f (‚ÜëFin.castSucc i) ‚â§ f (Fin.succ i) : Prop)","name":"Fin.monotone_iff_le_succ","isProp":true,"docString":"A function `f` on `Fin (n + 1)` is monotone if and only if `f i ‚â§ f (i + 1)` for all `i`. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v} {M‚ÇÇ : Type w} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] (self : MultilinearMap R M‚ÇÅ M‚ÇÇ) [inst_5 : DecidableEq Œπ] (m : (i : Œπ) ‚Üí M‚ÇÅ i) (i : Œπ) (c : R)\n  (x : M‚ÇÅ i),\n  MultilinearMap.toFun self (Function.update m i (c ‚Ä¢ x)) = c ‚Ä¢ MultilinearMap.toFun self (Function.update m i x)","name":"MultilinearMap.map_smul'","isProp":true,"docString":"A multilinear map is compatible with scalar multiplication in every argument. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {U : Set (G √ó G)}\n  (hU : U ‚àà nhds 0), ‚àÉ (V : OpenAddSubgroup G), ‚ÜëV √óÀ¢ ‚ÜëV ‚äÜ U","name":"NonarchimedeanAddGroup.prod_self_subset","isProp":true,"docString":"An open neighborhood of the identity in\nthe cartesian square of a nonarchimedean group contains the cartesian square of\nan open neighborhood in the group."},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_1} {N : Type u_2} [inst : CommMonoid M] [inst_1 : CommMonoid N] {s : Set Œ±}\n  {f : (a : Œ±) ‚Üí M} (g : M ‚Üí* N) (h‚ÇÄ : Set.Finite (s ‚à© Function.mulSupport f)),\n  ‚Üëg (finprod fun (j : Œ±) ‚Ü¶ finprod fun (h : j ‚àà s) ‚Ü¶ f j) = finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ ‚Üëg (f i)","name":"MonoidHom.map_finprod_mem'","isProp":true,"docString":"A more general version of `MonoidHom.map_finprod_mem` that requires `s ‚à© mulSupport f` rather\nthan `s` to be finite. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : (a : Fin n) ‚Üí Œ±} {œÉ : Equiv.Perm (Fin n)},\n  (f ‚àò ‚ÜëœÉ = f ‚àò ‚Üë(Tuple.sort f) : Prop) ‚Üî (Monotone (f ‚àò ‚ÜëœÉ) : Prop)","name":"Tuple.comp_sort_eq_comp_iff_monotone","isProp":true,"docString":"A permutation of a tuple `f` is `f` sorted if and only if it is monotone. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {K : Set Œ±} (hK : IsCompact K),\n  ‚àÉ (K' : Set Œ±), (IsCompact K' : Prop) ‚àß (K ‚äÜ interior K' : Prop)","name":"exists_compact_superset","isProp":true,"docString":"In a locally compact space, every compact set is contained in the interior of a compact set. "},{"type":"‚àÄ {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {A : V} {B : V}\n  {C : V} (f : A ‚ü∂ B) [inst_2 : CategoryTheory.Limits.HasImage f] (g : B ‚ü∂ C)\n  [inst_3 : CategoryTheory.Limits.HasKernel g] (w : f ‚â´ g = 0)\n  [inst_4 : CategoryTheory.Limits.HasCokernel (imageToKernel f g w)] {D : V} {k : homology f g w ‚ü∂ D}\n  {k' : homology f g w ‚ü∂ D} (p : homology.œÄ f g w ‚â´ k = homology.œÄ f g w ‚â´ k'), k = k'","name":"homology.ext","isProp":true,"docString":"To check two morphisms out of `homology f g w` are equal, it suffices to check on cycles. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {Œì‚ÇÄ : outParam (Type u_3)} [inst : LinearOrderedCommMonoidWithZero Œì‚ÇÄ]\n  [inst_1 : Ring R] [self : ValuationClass F R Œì‚ÇÄ] (f : F) (x : R) (y : R), ‚Üëf (x + y) ‚â§ max (‚Üëf x) (‚Üëf y)","name":"ValuationClass.map_add_le_max","isProp":true,"docString":"The valuation of a a sum is less that the sum of the valuations "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {d : Con M},\n  (c ‚â§ d : Prop) ‚Üî (‚àÄ {x : M} {y : M} (a : ‚Üëc x y), ‚Üëd x y : Prop)","name":"Con.le_def","isProp":true,"docString":"Definition of `‚â§` for congruence relations. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤) [inst : Nontrivial Œ≤],\n  ‚Üëf 1 ‚â† 0","name":"RingHom.map_one_ne_zero","isProp":true,"docString":"`f : Œ± ‚Üí+* Œ≤` doesn't map `1` to `0` if `Œ≤` is nontrivial "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {s : Set (Set Œ±)} (h_open : ‚àÄ (u : Set Œ±) (a : u ‚àà s), IsOpen u)\n  (h_nhds :\n    ‚àÄ (a : Œ±) (u : Set Œ±) (a_1 : a ‚àà u) (a_2 : IsOpen u),\n      ‚àÉ (v : Set Œ±), (v ‚àà s : Prop) ‚àß ((a ‚àà v : Prop) ‚àß (v ‚äÜ u : Prop) : Prop)),\n  TopologicalSpace.IsTopologicalBasis s","name":"TopologicalSpace.isTopologicalBasis_of_open_of_nhds","isProp":true,"docString":"If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Group Œ±] [inst_1 : OrderedAddCommMonoid Œ≤]\n  [self : GroupSeminormClass F Œ± Œ≤] (f : F), ‚Üëf 1 = 0","name":"GroupSeminormClass.map_one_eq_zero","isProp":true,"docString":"The image of one is zero. "},{"type":"‚àÄ {Œπ : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (b : Basis Œπ R M) {R‚ÇÅ : Type u_2} [inst_3 : Semiring R‚ÇÅ] {œÉ : R ‚Üí+* R‚ÇÅ} {M‚ÇÅ : Type u_4} [inst_4 : AddCommMonoid M‚ÇÅ]\n  [inst_5 : Module R‚ÇÅ M‚ÇÅ] {f‚ÇÅ : M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÅ} {f‚ÇÇ : M ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÅ} (h : ‚àÄ (i : Œπ), ‚Üëf‚ÇÅ (‚Üëb i) = ‚Üëf‚ÇÇ (‚Üëb i)), f‚ÇÅ = f‚ÇÇ","name":"Basis.ext","isProp":true,"docString":"Two linear maps are equal if they are equal on basis vectors. "},{"type":"‚àÄ {M : Type u} [self : AddLeftCancelMonoid M] (x : M), AddLeftCancelMonoid.nsmul 0 x = 0","name":"AddLeftCancelMonoid.nsmul_zero","isProp":true,"docString":"Multiplication by `(0 : ‚Ñï)` gives `0`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b), Set.Ioi b ‚äÜ Set.Ici a","name":"Set.Ioi_subset_Ici","isProp":true,"docString":"If `a ‚â§ b`, then `(b, +‚àû) ‚äÜ [a, +‚àû)`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Ioi_subset_Ici_iff`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {Œ≤ : Type u_1} {p : (a : Œ≤) ‚Üí Prop} {f : (a : Œ≤) ‚Üí ‚Ñù}\n  (hf‚ÇÄ : ‚àÄ (x : Œ≤) (a : p x), 0 < f x) (hf : ‚àÄ (Œµ : ‚Ñù) (a : 0 < Œµ), ‚àÉ (x : Œ≤), (p x : Prop) ‚àß (f x ‚â§ Œµ : Prop)),\n  Filter.HasBasis (uniformity Œ±) p fun (x : Œ≤) ‚Ü¶ setOf fun (p : Œ± √ó Œ±) ‚Ü¶ dist (Prod.fst p) (Prod.snd p) ‚â§ f x","name":"Metric.mk_uniformity_basis_le","isProp":true,"docString":"Given `f : Œ≤ ‚Üí ‚Ñù`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed neighborhoods of the diagonal of sizes `{f i | p i}`\nform a basis of `ùì§ Œ±`.\n\nCurrently we have only one specific basis `uniformity_basis_dist_le` based on this constructor.\nMore can be easily added if needed in the future. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] (l : Finset Œπ) (S : (a : Œπ) ‚Üí Set Œ±),\n  (fun (f : (a : Œπ) ‚Üí Œ±) ‚Ü¶ Finset.sum l fun (i : Œπ) ‚Ü¶ f i) '' Set.pi (‚Üël) S = Finset.sum l fun (i : Œπ) ‚Ü¶ S i","name":"Set.image_finset_sum_pi","isProp":true,"docString":"The n-ary version of `set.add_image_prod`. "},{"type":"‚àÄ {Œ± : Sort u} {p : (a : Œ±) ‚Üí Prop} (self : Subtype p), p ‚Üëself","name":"Subtype.property","isProp":true,"docString":"If `s : {x // p x}` then `s.2` or `s.property` is the assertion that\n`p s.1`, that is, that `s` is in fact an element for which `p` holds. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f : G ‚Üí* M} {g : G ‚Üí* M} {s : Set G}\n  (h : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subgroup.closure s)","name":"MonoidHom.eqOn_closure","isProp":true,"docString":"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommRing Œ±] [inst_1 : StrongRankCondition Œ±] (E : LinearRecurrence Œ±),\n  Module.rank Œ± { x : (a : ‚Ñï) ‚Üí Œ± // x ‚àà LinearRecurrence.solSpace E } = ‚Üë(LinearRecurrence.order E)","name":"LinearRecurrence.solSpace_rank","isProp":true,"docString":"The dimension of `E.solSpace` is `E.order`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonUnitalSeminormedRing Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx - y‚Äñ","name":"NonUnitalSeminormedRing.dist_eq","isProp":true,"docString":"The distance is induced by the norm. "},{"type":"‚àÄ {p : ‚Ñï} (hp : 1 < p), padicValNat p p = 1","name":"padicValNat.self","isProp":true,"docString":"If `p ‚â† 0` and `p ‚â† 1`, then `padicValNat p p` is `1`. "},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Hom L M N) {n : ‚Ñï}\n  (f : FirstOrder.Language.Functions L n) (x : (a : Fin n) ‚Üí M),\n  FirstOrder.Language.Hom.toFun self (FirstOrder.Language.Structure.funMap f x) =\n    FirstOrder.Language.Structure.funMap f (FirstOrder.Language.Hom.toFun self ‚àò x)","name":"FirstOrder.Language.Hom.map_fun'","isProp":true,"docString":"The homomorphism commutes with the interpretations of the function symbols "},{"type":"‚àÄ (n : ‚Ñï) (p : ‚Ñï), Finset.card (Finset.filter (fun (e : ‚Ñï) ‚Ü¶ p ‚à£ e + 1) (Finset.range n)) = n / p","name":"Nat.card_multiples","isProp":true,"docString":"Exactly `n / p` naturals in `[1, n]` are multiples of `p`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a - b ‚â§ c), a ‚â§ b + c","name":"le_add_of_sub_left_le","isProp":true,"docString":"**Alias** of the forward direction of `sub_le_iff_le_add'`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : SuccOrder Œ±] {a : Œ±} (h : ¬¨(Order.IsSuccLimit a : Prop)),\n  a ‚àà Set.range Order.succ","name":"Order.mem_range_succ_of_not_isSuccLimit","isProp":true,"docString":"See `not_isSuccLimit_iff` for a version that states that `a` is a successor of a value other\nthan itself. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddZeroClass Œ±] [inst_1 : AddZeroClass Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : IsAddMonoidHom f), f 0 = 0","name":"IsAddMonoidHom.map_zero","isProp":true,"docString":"The proposition that `f` preserves the additive identity. "},{"type":"‚àÄ {S : Type u_1} {M : Type u_2} [inst : Mul M] [inst_1 : SetLike S M] [self : MulMemClass S M] {s : S} {a : M} {b : M}\n  (a_1 : a ‚àà s) (a_2 : b ‚àà s), a * b ‚àà s","name":"MulMemClass.mul_mem","isProp":true,"docString":"A substructure satisfying `MulMemClass` is closed under multiplication. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : Archimedean Œ±] {x : Œ±} {y : Œ±} (hx : 1 ‚â§ x) (hy : 1 < y),\n  ‚àÉ (n : ‚Ñï), (y ^ n ‚â§ x : Prop) ‚àß (x < y ^ (n + 1) : Prop)","name":"exists_nat_pow_near","isProp":true,"docString":"Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. "},{"type":"‚àÄ {Œ± : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsWellFounded Œ± r] {C : (a : Œ±) ‚Üí Prop} (a : Œ±)\n  (a_1 : ‚àÄ (x : Œ±) (a : ‚àÄ (y : Œ±) (a : r y x), C y), C x), C a","name":"IsWellFounded.induction","isProp":true,"docString":"Induction on a well-founded relation. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C],\n  CategoryTheory.Limits.HasTerminal C","name":"CategoryTheory.Limits.HasZeroObject.hasTerminal","isProp":true,"docString":"A zero object is in particular terminal. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) ‚Üí Unique (X ‚ü∂ Y)],\n  CategoryTheory.Limits.HasInitial C","name":"CategoryTheory.Limits.hasInitial_of_unique","isProp":true,"docString":"We can more explicitly show that a category has an initial object by specifying the object,\nand showing there is a unique morphism from it to any other object. "},{"type":"‚àÄ {Œ± : Type u_1} (x : (a : ‚Ñï) ‚Üí Œ±) (n : ‚Ñï),\n  PiNat.cylinder x n = setOf fun (y : (a : ‚Ñï) ‚Üí Œ±) ‚Ü¶ PiNat.res y n = PiNat.res x n","name":"PiNat.cylinder_eq_res","isProp":true,"docString":"`cylinder x n` is equal to the set of sequences `y` with the same restriction to `n` as `x`."},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P], vectorSpan k ‚àÖ = ‚ä•","name":"vectorSpan_empty","isProp":true,"docString":"The `vectorSpan` of the empty set is `‚ä•`. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : (Matrix n n Œ±)À£),\n  ‚ÜëA‚Åª¬π = (‚ÜëA)‚Åª¬π","name":"Matrix.coe_units_inv","isProp":true,"docString":"Coercing the result of `Units.instInv` is the same as coercing first and applying the\nnonsingular inverse. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasWideEqualizers C] {T : C}\n  (hT : ‚àÄ (X : C), Nonempty (T ‚ü∂ X)), CategoryTheory.Limits.HasInitial C","name":"CategoryTheory.hasInitial_of_weakly_initial_and_hasWideEqualizers","isProp":true,"docString":"If `C` has (small) wide equalizers and a weakly initial object, then it has an initial object.\n\nThe initial object is constructed as the wide equalizer of all endomorphisms on the given weakly\ninitial object.\n"},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} {M‚ÇÉ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M‚ÇÉ]\n  [inst_3 : Module S M‚ÇÉ] {œÉ : R ‚Üí+* S} {f : R ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÉ} {g : R ‚Üí‚Çõ‚Çó[œÉ] M‚ÇÉ} (h : ‚Üëf 1 = ‚Üëg 1), f = g","name":"LinearMap.ext_ring","isProp":true,"docString":"If two `œÉ`-linear maps from `R` are equal on `1`, then they are equal. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] (a : Œ±) (b : Œ±),\n  Associated (gcd a b * lcm a b) (a * b)","name":"GCDMonoid.gcd_mul_lcm","isProp":true,"docString":"The product of two elements is `Associated` with the product of their GCD and LCM. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : PolishSpace Œ±] {s : Set Œ±} (hs : IsClosed s),\n  PolishSpace.IsClopenable s","name":"IsClosed.isClopenable","isProp":true,"docString":"Given a closed set `s` in a Polish space, one can construct a finer Polish topology for\nwhich `s` is both open and closed. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {s : Set Œ≤} (hs : IsCompact s) (ne_s : Set.Nonempty s)\n  {f : (a : Œ≤) ‚Üí Œ±} (hf : ContinuousOn f s), ‚àÉ (x : Œ≤), (x ‚àà s : Prop) ‚àß (IsMinOn f s x : Prop)","name":"IsCompact.exists_isMinOn","isProp":true,"docString":"The **extreme value theorem**: a continuous function realizes its minimum on a compact set. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : Type u_1} [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] (A : (a : Œπ) ‚Üí Submodule R M) {i : Œπ} {j : Œπ} (hij : i ‚â† j) (h : Set.univ = {i, j}),\n  (DirectSum.IsInternal A : Prop) ‚Üî (IsCompl (A i) (A j) : Prop)","name":"DirectSum.isInternal_submodule_iff_isCompl","isProp":true,"docString":"If a collection of submodules has just two indices, `i` and `j`, then\n`DirectSum.IsInternal` is equivalent to `isCompl`. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ] (a : 0 = 1), Subsingleton M‚ÇÄ","name":"subsingleton_of_zero_eq_one","isProp":true,"docString":"**Alias** of the forward direction of `subsingleton_iff_zero_eq_one`."},{"type":"‚àÄ {Œπ : Type u_1} {E : (a : Œπ) ‚Üí Type u_2} [inst : (i : Œπ) ‚Üí TopologicalSpace (E i)] [inst_1 : Countable Œπ]\n  [inst_2 : ‚àÄ (i : Œπ), TopologicalSpace.SecondCountableTopology (E i)],\n  TopologicalSpace.SecondCountableTopology ((i : Œπ) √ó E i)","name":"TopologicalSpace.instSecondCountableTopologySigmaInstTopologicalSpaceSigma","isProp":true,"docString":"A countable disjoint union of second countable spaces is second countable. "},{"type":"‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a : a + b ‚â§ a + c), b ‚â§ c","name":"StrictOrderedSemiring.le_of_add_le_add_left","isProp":true,"docString":"Additive cancellation is compatible with the order in an ordered cancellative additive\ncommutative monoid. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : BEq Œ±] [self : PartialEquivBEq Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : (a == b) = true)\n  (a_2 : (b == c) = true), (a == c) = true","name":"PartialEquivBEq.trans","isProp":true,"docString":"Transitivity for `BEq`. If `a == b` and `b == c` then `a == c`. "},{"type":"‚àÄ {ùïú : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {C : ùïú} (hC : 0 < C) (hf : Filter.Tendsto f l (nhds C))\n  (hg : Filter.Tendsto g l Filter.atBot), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * g x) l Filter.atBot","name":"Filter.Tendsto.mul_atBot","isProp":true,"docString":"In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and\n`g` tends to `Filter.atBot` then `f * g` tends to `Filter.atBot`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±},\n  Metric.hausdorffDist (closure s) t = Metric.hausdorffDist s t","name":"Metric.hausdorffDist_closure‚ÇÅ","isProp":true,"docString":"Replacing a set by its closure does not change the Hausdorff distance. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SemilatticeSup Œ±] [inst_1 : OrderTop Œ±] [inst_2 : SemilatticeSup Œ≤]\n  [inst_3 : OrderTop Œ≤] {a : Œ±} {b : Œ±} (f : Œ± ‚âÉo Œ≤) (ha : Codisjoint a b), Codisjoint (‚Üëf a) (‚Üëf b)","name":"Codisjoint.map_orderIso","isProp":true,"docString":"Note that this goal could also be stated `(Codisjoint on f) a b` "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} {r : ‚Ñö} (hq : q ‚â† 0) (hr : r ‚â† 0),\n  padicValRat p (q * r) = padicValRat p q + padicValRat p r","name":"padicValRat.mul","isProp":true,"docString":"A rewrite lemma for `padicValRat p (q * r)` with conditions `q ‚â† 0`, `r ‚â† 0`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] {f : R ‚Üí+* S} {s : S} (n : ‚Ñï)\n  (h : s ‚àà Set.range ‚Üëf), ‚Üë(Polynomial.monomial n) s ‚àà Polynomial.lifts f","name":"Polynomial.monomial_mem_lifts","isProp":true,"docString":"If `(s : S)` is in the image of `f`, then `monomial n s` lifts. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {X : C}\n  (h :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda) X ‚ãô CategoryTheory.uliftFunctor ‚âÖ\n      CategoryTheory.Functor.cones F)\n  {Y : C} (f : Y ‚ü∂ X),\n  CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom h f =\n    CategoryTheory.Limits.Cone.extend (CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h) f","name":"CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom_fac","isProp":true,"docString":"If `F.cones` is represented by `X`, the cone corresponding to a morphism `f : Y ‚ü∂ X` is\nthe limit cone extended by `f`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {p : Filter Œπ} [inst_1 : TopologicalSpace Œ±] (hs : IsCompact s),\n  (TendstoLocallyUniformlyOn F f p s : Prop) ‚Üî (TendstoUniformlyOn F f p s : Prop)","name":"tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact","isProp":true,"docString":"For a compact set `s`, locally uniform convergence on `s` is just uniform convergence on `s`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (s : Set Œ±), LipschitzWith 1 fun (x : Œ±) ‚Ü¶ Metric.infDist x s","name":"Metric.lipschitz_infDist_pt","isProp":true,"docString":"The minimal distance to a set is Lipschitz in point with constant 1 "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  (s : CategoryTheory.Limits.Fork f g) {W : C} {k : W ‚ü∂ CategoryTheory.Limits.Cone.pt s}\n  {l : W ‚ü∂ CategoryTheory.Limits.Cone.pt s}\n  (h : k ‚â´ CategoryTheory.Limits.Fork.Œπ s = l ‚â´ CategoryTheory.Limits.Fork.Œπ s)\n  (j : CategoryTheory.Limits.WalkingParallelPair),\n  k ‚â´ (CategoryTheory.Limits.Cone.œÄ s).app j = l ‚â´ (CategoryTheory.Limits.Cone.œÄ s).app j","name":"CategoryTheory.Limits.Fork.equalizer_ext","isProp":true,"docString":"To check whether two maps are equalized by both maps of a fork, it suffices to check it for the\nfirst map "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : ConditionallyCompleteLattice Œ≤] {s : Set (WithTop Œ≤)} (hs : Set.Nonempty s), IsLUB s (sup‚Çõ s)","name":"WithTop.isLUB_sup‚Çõ'","isProp":true,"docString":"The `sup‚Çõ` of a non-empty set is its least upper bound for a conditionally\ncomplete lattice with a top. "},{"type":"‚àÄ (R : Type u_1) {M : Type u_3} [inst : CommSemiring R] {œÉ : Type u_2} [inst_1 : AddCommMonoid M] (w : (a : œÉ) ‚Üí M)\n  (m : M),\n  MvPolynomial.weightedHomogeneousSubmodule R w m =\n    Finsupp.supported R R (setOf fun (d : œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Ü¶ ‚Üë(MvPolynomial.weightedDegree' w) d = m)","name":"MvPolynomial.weightedHomogeneousSubmodule_eq_finsupp_supported","isProp":true,"docString":"The submodule `weightedHomogeneousSubmodule R w m` of homogeneous `MvPolynomial`s of\ndegree `n` is equal to the `R`-submodule of all `p : (œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Üí‚ÇÄ R` such that\n`p.support ‚äÜ {d | weightedDegree' w d = m}`. While equal, the former has a\nconvenient definitional reduction. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} [inst : AddCommMonoid Œ≤] (f : (a : Œ±) ‚Üí Œ≤) {p : (a : Œ±) ‚Üí Prop}\n  [inst_1 : DecidablePred p],\n  (Finset.sum (Finset.subtype p s) fun (x : Subtype p) ‚Ü¶ f ‚Üëx) = Finset.sum (Finset.filter p s) fun (x : Œ±) ‚Ü¶ f x","name":"Finset.sum_subtype_eq_sum_filter","isProp":true,"docString":"A sum over `s.subtype p` equals one over `s.filter p`."},{"type":"‚àÄ {Œ± : Sort u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (hwf : WellFounded r) {a : Œ±} {bot : Œ±} {C : (a : Œ±) ‚Üí Prop}\n  (ih : ‚àÄ (b : Œ±) (a : b ‚â† bot) (a : C b), ‚àÉ (c : Œ±), (r c b : Prop) ‚àß (C c : Prop)) (a : C a), C bot","name":"WellFounded.induction_bot","isProp":true,"docString":"Let `r` be a well-founded relation on `Œ±`, let `C : Œ± ‚Üí Prop`, and let `bot : Œ±`.\nThis induction principle shows that `C bot` holds, given that\n* some `a` satisfies `C a`, and\n* for each `b` that satisfies `C b`, there is `c` satisfying `r c b` and `C c`.\n\nThe naming is inspired by the fact that when `r` is transitive, it follows that `bot` is\nthe smallest element w.r.t. `r` that satisfies `C`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] [inst_1 : LinearOrderedField Œ≤] [inst_2 : Archimedean Œ≤],\n  Subsingleton (Œ± ‚âÉ+*o Œ≤)","name":"OrderRingIso.subsingleton_right","isProp":true,"docString":"There is at most one ordered ring isomorphism between a linear ordered field and an archimedean\nlinear ordered field. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Countable Œ±], Countable (Finset Œ±)","name":"Finset.countable","isProp":true,"docString":"If `Œ±` is countable, then so is `Finset Œ±`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : NormedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  (p : Seminorm ùïú E) {r : ‚Ñù} {x : E} (hpr : ‚Üëp x < r), Absorbent ùïú (Seminorm.closedBall p x r)","name":"Seminorm.absorbent_closedBall","isProp":true,"docString":"Seminorm-balls containing the origin are absorbent. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : LinearOrder E] {s : Set E}\n  {f : (a : E) ‚Üí Œ≤} (hs : Convex ùïú s)\n  (hf :\n    ‚àÄ ‚¶Éx : E‚¶Ñ (a : x ‚àà s) ‚¶Éy : E‚¶Ñ (a : y ‚àà s) (a : x < y) ‚¶Éa : ùïú‚¶Ñ ‚¶Éb : ùïú‚¶Ñ (a_1 : 0 < a) (a_2 : 0 < b) (a_3 : a + b = 1),\n      a ‚Ä¢ f x + b ‚Ä¢ f y < f (a ‚Ä¢ x + b ‚Ä¢ y)),\n  StrictConcaveOn ùïú s f","name":"LinearOrder.strictConcaveOn_of_lt","isProp":true,"docString":"For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is strictly concave it suffices\nto verify the inequality `a ‚Ä¢ f x + b ‚Ä¢ f y < f (a ‚Ä¢ x + b ‚Ä¢ y)` for `x < y` and positive `a`, `b`.\nThe main use case is `E = ùïú` however one can apply it, e.g., to `ùïú^n` with lexicographic order. "},{"type":"‚àÄ {œÑ : Type u_2} {Œ± : Type u_3} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ≤] (f : Filter œÑ) (œï : (a : œÑ) ‚Üí (a : Œ±) ‚Üí Œ≤)\n  (s : Set Œ±) (y : Œ≤),\n  (y ‚àà omegaLimit f œï s : Prop) ‚Üî\n    (‚àÄ (n : Set Œ≤) (a : n ‚àà nhds y), Filter.Frequently (fun (t : œÑ) ‚Ü¶ Set.Nonempty (s ‚à© œï t ‚Åª¬π' n)) f : Prop)","name":"mem_omegaLimit_iff_frequently","isProp":true,"docString":"An element `y` is in the œâ-limit set of `s` w.r.t. `f` if the\npreimages of an arbitrary neighbourhood of `y` frequently\n(w.r.t. `f`) intersects of `s`. "},{"type":"‚àÄ {Œπ : Type u_1} {k : Type u_2} {V : Type u_3} [inst : AddCommGroup V] [inst_1 : Ring k] [inst_2 : Module k V]\n  [inst_3 : Fintype Œπ] (b : AffineBasis Œπ k V) (v : V),\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ ‚Üë(AffineBasis.coord b i) v ‚Ä¢ ‚Üëb i) = v","name":"AffineBasis.linear_combination_coord_eq_self","isProp":true,"docString":"A variant of `AffineBasis.affineCombination_coord_eq_self` for the special case when the\naffine space is a module so we can talk about linear combinations. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±}, EMetric.diam {x} = 0","name":"EMetric.diam_singleton","isProp":true,"docString":"The diameter of a singleton vanishes "},{"type":"‚àÄ {V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ] (f : V‚ÇÅ ‚Üí+ V‚ÇÇ)\n  {C : ‚Ñù} (h : ‚àÄ (x : V‚ÇÅ), ‚Äñ‚Üëf x‚Äñ ‚â§ C * ‚Äñx‚Äñ), ‚ÄñAddMonoidHom.mkNormedAddGroupHom f C h‚Äñ ‚â§ max C 0","name":"NormedAddGroupHom.mkNormedAddGroupHom_norm_le'","isProp":true,"docString":"If a bounded group homomorphism map is constructed from a group homomorphism\nvia the constructor `AddMonoidHom.mkNormedAddGroupHom`, then its norm is bounded by the bound\ngiven to the constructor or zero if this bound is negative. "},{"type":"‚àÄ {n : ‚Ñï} {i : Fin (n + 2)},\n  SimplexCategory.Œ¥ i ‚â´ SimplexCategory.Œ¥ (‚ÜëFin.castSucc i) = SimplexCategory.Œ¥ i ‚â´ SimplexCategory.Œ¥ (Fin.succ i)","name":"SimplexCategory.Œ¥_comp_Œ¥_self","isProp":true,"docString":"The special case of the first simplicial identity "},{"type":"‚àÄ {G : Type u_1} [inst : AddCommGroup G] {n : ‚Ñ§} {s : Set G} (hs : (fun (x : G) ‚Ü¶ n ‚Ä¢ x) ‚Åª¬π' s = s) {g : G} {j : ‚Ñï}\n  (hg : n ^ j ‚Ä¢ g = 0), g +·µ• s = s","name":"vadd_eq_self_of_preimage_zsmul_eq_self","isProp":true,"docString":"Let `n : ‚Ñ§` and `s` a subset of an additive commutative group `G` that is invariant\nunder preimage for the map `x ‚Ü¶ n ‚Ä¢ x`. Then `s` is invariant under the pointwise action of\nthe additive subgroup of elements `g : G` such that `(n^j) ‚Ä¢ g = 0` for some `j : ‚Ñï`.\n(This additive subgroup is called the Pr√ºfer subgroup when `G` is the `AddCircle` and `n` is\nprime.)"},{"type":"‚àÄ {Œ≤ : Type v} {Œ≥ : Type u_3} [inst : TopologicalSpace Œ≤] [inst_1 : TopologicalSpace Œ≥] {Œπ : Type u_1} {Œ∫ : Type u_2}\n  {f : (a : Œπ) ‚Üí Œ≤} {g : (a : Œ∫) ‚Üí Œ≥} (hf : DenseRange f) (hg : DenseRange g), DenseRange (Prod.map f g)","name":"DenseRange.prod_map","isProp":true,"docString":"If `f` and `g` are maps with dense range, then `Prod.map f g` has dense range. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : PolishSpace Œ±] {s : Set Œ±} (hs : IsOpen s), PolishSpace ‚Üës","name":"IsOpen.polishSpace","isProp":true,"docString":"An open subset of a Polish space is also Polish. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} {v : Vector Œ± (n + 1)}, Vector.head (Vector.reverse v) = Vector.last v","name":"Vector.reverse_get_zero","isProp":true,"docString":"The `last` element of a vector is the `head` of the `reverse` vector. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a : Œ±} {b : Œ±} {c : Œ±}, Set.uIcc a c ‚äÜ Set.uIcc a b ‚à™ Set.uIcc b c","name":"Set.uIcc_subset_uIcc_union_uIcc","isProp":true,"docString":"A sort of triangle inequality. "},{"type":"‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (v : Vector Œ± n), Vector.map id v = v","name":"Vector.map_id","isProp":true,"docString":"Mapping under `id` does not change a vector. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : DecidableEq Œ≤] [inst_1 : VAdd Œ± Œ≤] {u : Finset Œ≤} {s : Set Œ±} {t : Set Œ≤}\n  (a : ‚Üëu ‚äÜ s +·µ• t),\n  ‚àÉ (s' : Finset Œ±), ‚àÉ (t' : Finset Œ≤), (‚Üës' ‚äÜ s : Prop) ‚àß ((‚Üët' ‚äÜ t : Prop) ‚àß (u ‚äÜ s' +·µ• t' : Prop) : Prop)","name":"Finset.subset_vadd","isProp":true,"docString":"If a finset `u` is contained in the scalar sum of two sets `s +·µ• t`, we can find two\nfinsets `s'`, `t'` such that `s' ‚äÜ s`, `t' ‚äÜ t` and `u ‚äÜ s' +·µ• t'`."},{"type":"‚àÄ {Œ± : Type u} [inst : CompleteLattice Œ±] {J : Type u} [inst_1 : CategoryTheory.SmallCategory J] (F : J ‚•§ Œ±),\n  CategoryTheory.Limits.limit F = inf·µ¢ (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F))","name":"CategoryTheory.Limits.CompleteLattice.limit_eq_inf·µ¢","isProp":true,"docString":"The limit of a functor into a complete lattice is the infimum of the objects in the image.\n"},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (h : 0 < (1 - r) * (b - a)),\n  (‚Üë(AffineMap.lineMap (f a) (f b)) r < f (‚Üë(AffineMap.lineMap a b) r) : Prop) ‚Üî\n    (slope f (‚Üë(AffineMap.lineMap a b) r) b < slope f a b : Prop)","name":"lineMap_lt_map_iff_slope_lt_slope_right","isProp":true,"docString":"Given `c = lineMap a b r`, `c < b`, the point `(c, f c)` is strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f c b < slope f a b`. "},{"type":"‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Preadditive V]\n  {c : ComplexShape Œπ} {C : HomologicalComplex V c} {D : HomologicalComplex V c} {E : HomologicalComplex V c}\n  (hom : (i : Œπ) ‚Üí (j : Œπ) ‚Üí HomologicalComplex.X C i ‚ü∂ HomologicalComplex.X D j) (g : D ‚ü∂ E),\n  Homotopy.nullHomotopicMap hom ‚â´ g =\n    Homotopy.nullHomotopicMap fun (i : Œπ) (j : Œπ) ‚Ü¶ hom i j ‚â´ HomologicalComplex.Hom.f g j","name":"Homotopy.nullHomotopicMap_comp","isProp":true,"docString":"Compatibility of `nullHomotopicMap` with the postcomposition by a morphism\nof complexes. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±} (a : BddBelow s), BddBelow ‚Üë(upperClosure s)","name":"BddBelow.upperClosure","isProp":true,"docString":"**Alias** of the reverse direction of `bddBelow_upperClosure`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (p : X = Y) (q : Y ‚ü∂ Z),\n  cast ((congrArg (fun (W : C) ‚Ü¶ W ‚ü∂ Z) ((Eq.symm p=:Y = X)=:Y = X)=:(Y ‚ü∂ Z) = (X ‚ü∂ Z))=:(Y ‚ü∂ Z) = (X ‚ü∂ Z)) q =\n    CategoryTheory.eqToHom p ‚â´ q","name":"CategoryTheory.congrArg_cast_hom_left","isProp":true,"docString":"Reducible form of congrArg_mpr_hom_left "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R] (la : IsLeftRegular a), a ‚â† 0","name":"IsLeftRegular.ne_zero","isProp":true,"docString":"A left-regular element of a `Nontrivial` `MulZeroClass` is non-zero. "},{"type":"‚àÄ (r : ‚Ñï) (n : ‚Ñï), Nat.choose (2 * n) r ‚â§ Nat.centralBinom n","name":"Nat.choose_le_centralBinom","isProp":true,"docString":"The central binomial coefficient is the largest binomial coefficient.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : DecidableEq Œ±] {A : Finset Œ±} (hA : Finset.Nonempty A) (B : Finset Œ±)\n  (n : ‚Ñï), ‚Üë(Finset.card (n ‚Ä¢ B)) ‚â§ (‚Üë(Finset.card (A - B)) / ‚Üë(Finset.card A)) ^ n * ‚Üë(Finset.card A)","name":"Finset.card_nsmul_le'","isProp":true,"docString":"Special case of the **Pl√ºnnecke-Ruzsa inequality**. Subtraction version."},{"type":"‚àÄ {k : Type u_1} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 0), ‚Üë(Finset.weightedVSub s fun (x : Œπ) ‚Ü¶ p) w = 0","name":"Finset.weightedVSub_apply_const","isProp":true,"docString":"The value of `weightedVSub`, where the given points are equal and the sum of the weights\nis 0. "},{"type":"‚àÄ {R : Type u} {A : Type v} {B : Type w} [inst : Monoid R] [inst_1 : NonUnitalNonAssocSemiring A]\n  [inst_2 : DistribMulAction R A] [inst_3 : NonUnitalNonAssocSemiring B] [inst_4 : DistribMulAction R B]\n  (self : A ‚Üí‚Çô‚Çê[R] B) (x : A) (y : A),\n  MulActionHom.toFun (DistribMulActionHom.toMulActionHom (NonUnitalAlgHom.toDistribMulActionHom self)) (x * y) =\n    MulActionHom.toFun (DistribMulActionHom.toMulActionHom (NonUnitalAlgHom.toDistribMulActionHom self)) x *\n      MulActionHom.toFun (DistribMulActionHom.toMulActionHom (NonUnitalAlgHom.toDistribMulActionHom self)) y","name":"NonUnitalAlgHom.map_mul'","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] {s : Set R} {p : (a : R) ‚Üí (a : R) ‚Üí Prop} {x : R} {y : R}\n  (hx : x ‚àà Subsemiring.closure s) (hy : y ‚àà Subsemiring.closure s)\n  (Hs : ‚àÄ (x : R) (a : x ‚àà s) (y : R) (a : y ‚àà s), p x y) (H0_left : ‚àÄ (x : R), p 0 x) (H0_right : ‚àÄ (x : R), p x 0)\n  (H1_left : ‚àÄ (x : R), p 1 x) (H1_right : ‚àÄ (x : R), p x 1)\n  (Hadd_left : ‚àÄ (x‚ÇÅ : R) (x‚ÇÇ : R) (y : R) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ + x‚ÇÇ) y)\n  (Hadd_right : ‚àÄ (x : R) (y‚ÇÅ : R) (y‚ÇÇ : R) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ + y‚ÇÇ))\n  (Hmul_left : ‚àÄ (x‚ÇÅ : R) (x‚ÇÇ : R) (y : R) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ * x‚ÇÇ) y)\n  (Hmul_right : ‚àÄ (x : R) (y‚ÇÅ : R) (y‚ÇÇ : R) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ * y‚ÇÇ)), p x y","name":"Subsemiring.closure_induction‚ÇÇ","isProp":true,"docString":"An induction principle for closure membership for predicates with two arguments. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {Œπ : Sort u_1}\n  [inst_3 : Finite Œπ] (S : (a : Œπ) ‚Üí Submodule K V) [inst_4 : ‚àÄ (i : Œπ), FiniteDimensional K { x : V // x ‚àà S i }],\n  FiniteDimensional K { x : V // x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i }","name":"Submodule.finiteDimensional_sup·µ¢","isProp":true,"docString":"The submodule generated by a supremum of finite dimensional submodules, indexed by a finite\nsort is finite-dimensional. "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ), a * a * a‚Åª¬π = a","name":"mul_self_mul_inv","isProp":true,"docString":"Multiplying `a` by itself and then by its inverse results in `a`\n(whether or not `a` is zero). "},{"type":"‚àÄ {Œ± : Type u}, (Subsingleton (Option Œ±) : Prop) ‚Üî (IsEmpty Œ± : Prop)","name":"Option.subsingleton_iff_isEmpty","isProp":true,"docString":"`Option Œ±` is a `Subsingleton` if and only if `Œ±` is empty. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (s : Set Œ±), Continuous fun (x : Œ±) ‚Ü¶ Metric.infDist x s","name":"Metric.continuous_infDist_pt","isProp":true,"docString":"The minimal distance to a set is continuous in point "},{"type":"‚àÄ {G : Type u_2} {H : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : OrderedAddCommGroup H] {f : (a : G) ‚Üí H}\n  (h‚ÇÅ : ‚àÄ (x : G), f (-x) = -f x) (h‚ÇÇ : StrictAntiOn f (Set.Ici 0)), StrictAnti f","name":"strictAnti_of_odd_strictAntiOn_nonneg","isProp":true,"docString":"An odd function on a linear ordered additive commutative group is strictly antitone on the whole\ngroup provided that it is strictly antitone on `Set.Ici 0`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : Preorder Œπ] [inst_1 : LinearOrder Œ±] {u : (a : Œπ) ‚Üí Œ±} (h : Monotone u)\n  (H : ¬¨(BddBelow (Set.range u) : Prop)), Filter.Tendsto u Filter.atBot Filter.atBot","name":"Filter.tendsto_atBot_atBot_of_monotone'","isProp":true,"docString":"If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded\nbelow, then `Tendsto u atBot atBot`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {m : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (hm : UniformInducing m), (IsComplete (m '' s) : Prop) ‚Üî (IsComplete s : Prop)","name":"isComplete_image_iff","isProp":true,"docString":"A set is complete iff its image under a uniform inducing map is complete. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Sub Œ±] {u : Finset Œ±} {s : Set Œ±} {t : Set Œ±} (a : ‚Üëu ‚äÜ s - t),\n  ‚àÉ (s' : Finset Œ±), ‚àÉ (t' : Finset Œ±), (‚Üës' ‚äÜ s : Prop) ‚àß ((‚Üët' ‚äÜ t : Prop) ‚àß (u ‚äÜ s' - t' : Prop) : Prop)","name":"Finset.subset_sub","isProp":true,"docString":"If a finset `u` is contained in the sum of two sets `s - t`, we can find two finsets\n`s'`, `t'` such that `s' ‚äÜ s`, `t' ‚äÜ t` and `u ‚äÜ s' - t'`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±}\n  (a_1 : IsExtrOn (‚ÜëOrderDual.toDual ‚àò f) s a), IsExtrOn f s a","name":"IsExtrOn.undual","isProp":true,"docString":"**Alias** of the forward direction of `isExtrOn_dual_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : PredOrder Œ±] {a : Œ±} {b : Œ±} [inst_2 : NoMinOrder Œ±] (a_1 : a < b),\n  Order.pred a < Order.pred b","name":"Order.pred_lt_pred","isProp":true,"docString":"**Alias** of the reverse direction of `Order.pred_lt_pred_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {e' : LocalHomeomorph Œ± Œ≤} (he : e ‚âà e') (s : Set Œ±), LocalHomeomorph.restr e s ‚âà LocalHomeomorph.restr e' s","name":"LocalHomeomorph.EqOnSource.restr","isProp":true,"docString":"Restriction of local homeomorphisms respects equivalence "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} (f : (a : Œ±) ‚Üí Œ≤),\n  { unop := Finset.sum s fun (x : Œ±) ‚Ü¶ f x } = Finset.sum s fun (x : Œ±) ‚Ü¶ { unop := f x }","name":"Finset.op_sum","isProp":true,"docString":"Moving to the opposite additive commutative monoid commutes with summing. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type u_1} [inst_1 : Nonempty Œπ] {V : (a : Œπ) ‚Üí Set Œ±}\n  (hV : Directed (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äá x_1) V) (hV_cpct : ‚àÄ (i : Œπ), IsCompact (V i))\n  (hV_closed : ‚àÄ (i : Œπ), IsClosed (V i)) {U : Set Œ±}\n  (hU : ‚àÄ (x : Œ±) (a : x ‚àà Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ V i), U ‚àà nhds x), ‚àÉ (i : Œπ), V i ‚äÜ U","name":"exists_subset_nhds_of_isCompact'","isProp":true,"docString":"If `V : Œπ ‚Üí Set Œ±` is a decreasing family of closed compact sets then any neighborhood of\n`‚ãÇ i, V i` contains some `V i`. We assume each `V i` is compact *and* closed because `Œ±` is\nnot assumed to be Hausdorff. See `exists_subset_nhd_of_compact` for version assuming this. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b), (a < b : Prop) ‚à® (a = b : Prop)","name":"LE.le.lt_or_eq","isProp":true,"docString":"**Alias** of `lt_or_eq_of_le`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±},\n  (a ‚©ø b : Prop) ‚Üî\n    ((a ‚â§ b : Prop) ‚àß (‚àÄ (c : Œ±) (a_1 : a ‚â§ c) (a_2 : c ‚â§ b), (c = a : Prop) ‚à® (c = b : Prop) : Prop) : Prop)","name":"wcovby_iff_le_and_eq_or_eq","isProp":true,"docString":"An `iff` version of `Wcovby.eq_or_eq` and `wcovby_of_eq_or_eq`. "},{"type":"‚àÄ {Œ± : Type u} [self : NonUnitalNonAssocRing Œ±] (a : Œ±), a * 0 = 0","name":"NonUnitalNonAssocRing.mul_zero","isProp":true,"docString":"Zero is a right absorbing element for multiplication "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : IsPredArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (hr : Reflexive r)\n  (h1 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc m n), r i (Order.pred i)) (h2 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc n m), r (Order.pred i) i),\n  Relation.TransGen r n m","name":"transGen_of_pred_of_reflexive","isProp":true,"docString":"`(n, m)` is in the transitive closure of a reflexive relation `~` if `i ~ pred i` and\n`pred i ~ i` for all `i` between `n` and `m`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ‚àà H","name":"Subgroup.one_mem","isProp":true,"docString":"A subgroup contains the group's 1. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hf : Monotone f) (hx : f x ‚â§ x),\n  Antitone fun (n : ‚Ñï) ‚Ü¶ (f^[n]) x","name":"Monotone.antitone_iterate_of_map_le","isProp":true,"docString":"If `f` is a monotone map and `f x ‚â§ x` at some point `x`, then the iterates `f^[n] x` form\na antitone sequence. "},{"type":"‚àÄ {m : Type u} {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±]\n  (A : Matrix m n Œ±) (B : Matrix n n Œ±) [inst_3 : Invertible B], Matrix.mul (Matrix.mul A B) ‚ÖüB = A","name":"Matrix.mul_mul_invOf_self_cancel","isProp":true,"docString":"A copy of `mul_mul_invOf_self_cancel` using `‚¨ù` not `*`. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} (a : FreeAddGroup.Red L‚ÇÅ L‚ÇÇ), List.Sublist L‚ÇÇ L‚ÇÅ","name":"FreeAddGroup.Red.sublist","isProp":true,"docString":"If `w‚ÇÅ w‚ÇÇ` are words such that `w‚ÇÅ` reduces to `w‚ÇÇ`, then `w‚ÇÇ` is a sublist of\n`w‚ÇÅ`."},{"type":"‚àÄ {f : (a : ‚Ñï) ‚Üí NNReal} {r : NNReal},\n  (HasSum f r : Prop) ‚Üî\n    (Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f i) Filter.atTop (nhds r) : Prop)","name":"NNReal.hasSum_iff_tendsto_nat","isProp":true,"docString":"A series of non-negative real numbers converges to `r` in the sense of `HasSum` if and only if\nthe sequence of partial sum converges to `r`. "},{"type":"‚àÄ {Œ± : Type u_1} (self : MeasurableSpace.DynkinSystem Œ±), MeasurableSpace.DynkinSystem.Has self ‚àÖ","name":"MeasurableSpace.DynkinSystem.has_empty","isProp":true,"docString":"A Dynkin system contains the empty set. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Finite R M] (s : Submodule R M),\n  FiniteDimensional.finrank R { x : M // x ‚àà s } ‚â§ FiniteDimensional.finrank R M","name":"Submodule.finrank_le","isProp":true,"docString":"The dimension of a submodule is bounded by the dimension of the ambient space. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {T : D}\n  {S : C ‚•§ D} {A : CategoryTheory.CostructuredArrow S T} {B : CategoryTheory.CostructuredArrow S T} (f : A ‚ü∂ B)\n  [h : CategoryTheory.Epi (CategoryTheory.CommaMorphism.left f)], CategoryTheory.Epi f","name":"CategoryTheory.CostructuredArrow.epi_of_epi_left","isProp":true,"docString":"The converse of this is true with additional assumptions, see `epi_iff_epi_left`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] (f : V ‚âÉ‚Çó[K] V‚ÇÇ) [inst_5 : FiniteDimensional K V],\n  FiniteDimensional K V‚ÇÇ","name":"LinearEquiv.finiteDimensional","isProp":true,"docString":"Finite dimensionality is preserved under linear equivalence. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasFiniteColimits C] (J : Type)\n  [ùí• : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J],\n  CategoryTheory.Limits.HasColimitsOfShape J C","name":"CategoryTheory.Limits.HasFiniteColimits.out","isProp":true,"docString":"`C` has all colimits over any type `J` whose objects and morphisms lie in the same universe\nand which has `Fintype` objects and morphisms"},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±]\n  (s : TopologicalSpace.Closeds Œ±),\n  ‚àÉ (S : Set (TopologicalSpace.Closeds Œ±)),\n    (Set.Finite S : Prop) ‚àß\n      ((‚àÄ (t : TopologicalSpace.Closeds Œ±) (a : t ‚àà S), IsIrreducible ‚Üët : Prop) ‚àß (s = sup‚Çõ S : Prop) : Prop)","name":"TopologicalSpace.NoetherianSpace.exists_finite_set_closeds_irreducible","isProp":true,"docString":"In a Noetherian space, every closed set is a finite union of irreducible closed sets. "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] (self : AbstractCompletion Œ±), SeparatedSpace (AbstractCompletion.space self)","name":"AbstractCompletion.separation","isProp":true,"docString":"The completion is a separated space. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonAssocSemiring Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : NonAssocSemiring Œ≤] [inst_3 : Preorder Œ≤] [self : OrderRingHomClass F Œ± Œ≤] (f : F), Monotone ‚Üëf","name":"OrderRingHomClass.monotone","isProp":true,"docString":"The proposition that the function preserves the order. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasEqualizers C],\n  CategoryTheory.Limits.HasCoreflexiveEqualizers C","name":"CategoryTheory.Limits.hasCoreflexiveEqualizers_of_hasEqualizers","isProp":true,"docString":"If `C` has equalizers, then it has coreflexive equalizers. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {s : Set Œ±},\n  (s ‚àà residual Œ± : Prop) ‚Üî (‚àÉ (t : Set Œ±), ‚àÉ (x : t ‚äÜ s), (IsGŒ¥ t : Prop) ‚àß (Dense t : Prop) : Prop)","name":"mem_residual","isProp":true,"docString":"A set is residual (comeagre) if and only if it includes a dense `GŒ¥` set. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {r : ‚Ñù} (hr : 0 < r),\n  r ‚Ä¢ Metric.ball 0 1 = Metric.ball 0 r","name":"smul_unitBall_of_pos","isProp":true,"docString":"In a real normed space, the image of the unit ball under scalar multiplication by a positive\nconstant `r` is the ball of radius `r`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (r : k) (p‚ÇÅ : P) (p‚ÇÇ : P), r ‚Ä¢ (p‚ÇÇ -·µ• p‚ÇÅ) ‚àà vectorSpan k {p‚ÇÅ, p‚ÇÇ}","name":"smul_vsub_rev_mem_vectorSpan_pair","isProp":true,"docString":"A multiple of the difference between two points (reversed) lies in their `vectorSpan`. "},{"type":"‚àÄ {Œ± : Type u_1} (self : FilterBasis Œ±), Set.Nonempty (FilterBasis.sets self)","name":"FilterBasis.nonempty","isProp":true,"docString":"The set of filter basis sets is nonempty. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Inv G] [inst_2 : Mul G] [inst_3 : ContinuousMul G]\n  [inst_4 : ContinuousInv G] (h : G), Continuous fun (g : G) ‚Ü¶ g * h * g‚Åª¬π","name":"TopologicalGroup.continuous_conj'","isProp":true,"docString":"Conjugation acting on fixed element of the group is continuous when both `mul` and\n`inv` are continuous. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_4} {P : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) (pred : (a : Œπ) ‚Üí Prop)\n  [inst_3 : DecidablePred pred],\n  (‚Üë(Finset.affineCombination k (Finset.subtype pred s) fun (i : Subtype pred) ‚Ü¶ p ‚Üëi) fun (i : Subtype pred) ‚Ü¶ w ‚Üëi) =\n    ‚Üë(Finset.affineCombination k (Finset.filter pred s) p) w","name":"Finset.affineCombination_subtype_eq_filter","isProp":true,"docString":"An affine combination over `s.subtype pred` equals one over `s.filter pred`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [self : LocallyFiniteOrderBot Œ±] (a : Œ±) (x : Œ±),\n  (x ‚àà LocallyFiniteOrderBot.finsetIio a : Prop) ‚Üî (x < a : Prop)","name":"LocallyFiniteOrderBot.finset_mem_Iio","isProp":true,"docString":"`x ‚àà finsetIio a ‚Üî x < a` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.IsSplitMono f]\n  [inst_2 : CategoryTheory.Epi f], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_epi_of_isSplitMono","isProp":true,"docString":"A split mono which is epi is an iso. "},{"type":"‚àÄ {Œ± : Type u} {m : ‚Ñï} {n : ‚Ñï} (f : (a : Fin (m * n)) ‚Üí Œ±),\n  List.ofFn f =\n    List.join\n      (List.ofFn fun (i : Fin m) ‚Ü¶\n        List.ofFn fun (j : Fin n) ‚Ü¶\n          f\n            { val := ‚Üëi * n + ‚Üëj,\n              isLt :=\n                ((Trans.trans\n                      ((LT.lt.trans_eq\n                            ((add_lt_add_left ((Fin.prop j=:‚Üëj < n)=:‚Üëj < n)\n                                  (‚Üëi * n)=:‚Üëi * n + ‚Üëj < ‚Üëi * n + n)=:‚Üëi * n + ‚Üëj < ‚Üëi * n + n)\n                            ((Eq.symm\n                                  ((add_one_mul (‚Üëi)\n                                        n=:(‚Üëi + 1) * n =\n                                        ‚Üëi * n +\n                                          n)=:(‚Üëi + 1) * n =\n                                      ‚Üëi * n +\n                                        n)=:‚Üëi * n + n =\n                                  (‚Üëi + 1) *\n                                    n)=:‚Üëi * n + n =\n                                (‚Üëi + 1) * n)=:‚Üëi * n + ‚Üëj < (‚Üëi + 1) * n)=:‚Üëi * n + ‚Üëj < (‚Üëi + 1) * n)\n                      ((Nat.mul_le_mul_right n\n                            ((Fin.prop\n                                  i=:‚Üëi <\n                                  m)=:‚Üëi <\n                                m)=:(‚Üëi + 1) * n ‚â§\n                            m * n)=:(‚Üëi + 1) * n ‚â§ m * n)=:‚Üëi * n + ‚Üëj < m * n)=:‚Üëi * n + ‚Üëj < m * n) })","name":"List.ofFn_mul","isProp":true,"docString":"This breaks a list of `m*n` items into `m` groups each containing `n` elements. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R] (ra : IsRightRegular a), a ‚â† 0","name":"IsRightRegular.ne_zero","isProp":true,"docString":"A right-regular element of a `Nontrivial` `MulZeroClass` is non-zero. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} [inst : DecidableEq Œ≤']\n  [inst_1 : DecidableEq Œ≥] [inst_2 : DecidableEq Œ¥] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥}\n  {g : (a : Œ≤) ‚Üí Œ≤'} {f' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_right_comm : ‚àÄ (a : Œ±) (b : Œ≤), f a (g b) = g' (f' a b)),\n  Finset.image‚ÇÇ f s (Finset.image g t) = Finset.image g' (Finset.image‚ÇÇ f' s t)","name":"Finset.image_image‚ÇÇ_right_comm","isProp":true,"docString":"Symmetric statement to `Finset.image_image‚ÇÇ_distrib_right`. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P} {v : V},\n  (v +·µ• p‚ÇÅ ‚àà affineSpan k {p‚ÇÅ, p‚ÇÇ} : Prop) ‚Üî (‚àÉ (r : k), r ‚Ä¢ (p‚ÇÇ -·µ• p‚ÇÅ) = v : Prop)","name":"vadd_left_mem_affineSpan_pair","isProp":true,"docString":"A vector added to the first point lies in the affine span of two points if and only if it is\na multiple of their difference. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (e : LocalHomeomorph Œ± Œ≤)\n  {s : Set Œ±} (hs : IsOpen s) (h : s ‚äÜ LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)), IsOpen (‚Üëe '' s)","name":"LocalHomeomorph.image_open_of_open","isProp":true,"docString":"The image of an open set in the source is open. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R) {l : List R} (a : ‚àÄ (x : R) (a : x ‚àà l), x ‚àà s), List.sum l ‚àà s","name":"Subring.list_sum_mem","isProp":true,"docString":"Sum of a list of elements in a subring is in the subring. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  [inst_1 : CategoryTheory.IsIso (Prefunctor.map (CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda) f)],\n  CategoryTheory.IsIso f","name":"CategoryTheory.Yoneda.isIso","isProp":true,"docString":"If `yoneda.map f` is an isomorphism, so was `f`.\n"},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M},\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà ‚àÖ) ‚Ü¶ f i) = 0","name":"finsum_mem_empty","isProp":true,"docString":"The sum of any function over an empty set is `0`."},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] (f : M ‚Üí‚Çó[R] M)\n  [hfg : Module.Finite R M] (f_surj : Function.Surjective ‚Üëf), Function.Injective ‚Üëf","name":"Module.Finite.injective_of_surjective_endomorphism","isProp":true,"docString":"A theorem/proof by Vasconcelos, given a finite module `M` over a commutative ring, any\nsurjective endomorphism of `M` is also injective. Based on,\nhttps://math.stackexchange.com/a/239419/31917,\nhttps://www.ams.org/journals/tran/1969-138-00/S0002-9947-1969-0238839-5/.\nThis is similar to `IsNoetherian.injective_of_surjective_endomorphism` but only applies in the\ncommutative case, but does not use a Noetherian hypothesis. "},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [inst : TopologicalSpace Œ±] [inst_1 : UniformSpace Œ≤] {K : Set Œ±} (f : C(Œ±, Œ≤))\n  (hK : IsCompact K) {U : Set Œ≤} (hU : IsOpen U) (hf : f ‚àà ContinuousMap.CompactOpen.gen K U),\n  ‚àÉ (V : Set (Œ≤ √ó Œ≤)),\n    (V ‚àà uniformity Œ≤ : Prop) ‚àß\n      ((IsOpen V : Prop) ‚àß (ContinuousMap.compactConvNhd K V f ‚äÜ ContinuousMap.CompactOpen.gen K U : Prop) : Prop)","name":"ContinuousMap.compactConvNhd_subset_compactOpen","isProp":true,"docString":"Any point of `ContinuousMap.CompactOpen.gen K U` is also an interior point wrt the topology of\ncompact convergence.\n\nThe topology of compact convergence is thus at least as fine as the compact-open topology. "},{"type":"‚àÄ {p : ‚Ñï} {k : ‚Ñï} (hk : k ‚â† 0) (hp : Nat.Prime p), List.toFinset (Nat.factors (p ^ k)) = {p}","name":"Nat.prime_pow_prime_divisor","isProp":true,"docString":"The only prime divisor of positive prime power `p^k` is `p` itself "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (t : Œ±) (ts : List Œ±) (r : List Œ≤) (ys : List Œ±) (f : (a : List Œ±) ‚Üí Œ≤),\n  Prod.snd (List.permutationsAux2 t ts [] ys f) ++ r = Prod.snd (List.permutationsAux2 t ts r ys f)","name":"List.permutationsAux2_append","isProp":true,"docString":"The `r` argument to `permutationsAux2` is the same as appending. "},{"type":"‚àÄ (M : Type u_1) (N : Type u_2) (Œ± : Type u_3) [inst : VAdd M Œ±] [inst_1 : VAdd N Œ±] [inst_2 : VAddCommClass M N Œ±],\n  VAddCommClass N M Œ±","name":"VAddCommClass.symm","isProp":true,"docString":"Commutativity of additive actions is a symmetric relation. This lemma can't be an instance\nbecause this would cause a loop in the instance search graph. "},{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f‚ÇÄ : C(X, Y)} {f‚ÇÅ : C(X, Y)}\n  (self : ContinuousMap.Homotopy f‚ÇÄ f‚ÇÅ) (x : X),\n  ContinuousMap.toFun (ContinuousMap.Homotopy.toContinuousMap self) (0, x) = ‚Üëf‚ÇÄ x","name":"ContinuousMap.Homotopy.map_zero_left","isProp":true,"docString":"value of the homotopy at 0 "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (E : Set Œ±) {Œ¥ : ‚Ñù},\n  frontier (Metric.cthickening Œ¥ E) ‚äÜ setOf fun (x : Œ±) ‚Ü¶ EMetric.infEdist x E = ENNReal.ofReal Œ¥","name":"Metric.frontier_cthickening_subset","isProp":true,"docString":"The frontier of the closed thickening of a set is contained in an `EMetric.infEdist` level\nset. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_3} [inst_1 : CommMonoid N] {P : Type u_2}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {k : Submonoid.LocalizationMap S P} (z : N),\n  ‚Üë(Submonoid.LocalizationMap.lift k\n          ((Submonoid.LocalizationMap.map_units\n                f=:‚àÄ (y : { x : M // x ‚àà S }),\n                IsUnit\n                  (‚Üë(Submonoid.LocalizationMap.toMap f)\n                    ‚Üëy))=:‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üë(Submonoid.LocalizationMap.toMap f) ‚Üëy)))\n      (‚Üë(Submonoid.LocalizationMap.lift f\n            ((Submonoid.LocalizationMap.map_units\n                  k=:‚àÄ (y : { x : M // x ‚àà S }),\n                  IsUnit\n                    (‚Üë(Submonoid.LocalizationMap.toMap k)\n                      ‚Üëy))=:‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üë(Submonoid.LocalizationMap.toMap k) ‚Üëy)))\n        z) =\n    z","name":"Submonoid.LocalizationMap.lift_left_inverse","isProp":true,"docString":"Given two Localization maps `f : M ‚Üí* N, k : M ‚Üí* P` for a Submonoid `S ‚äÜ M`, the hom\nfrom `P` to `N` induced by `f` is left inverse to the hom from `N` to `P` induced by `k`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\n  [inst_4 : NoZeroSMulDivisors K V] (h : 0 < FiniteDimensional.finrank K V), Nontrivial V","name":"FiniteDimensional.nontrivial_of_finrank_pos","isProp":true,"docString":"A finite dimensional space is nontrivial if it has positive `finrank`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} {f : (a : Œπ) ‚Üí Œ±} (a : Function.Injective f),\n  Pairwise ((fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â† x_1) on f)","name":"Function.Injective.pairwise_ne","isProp":true,"docString":"**Alias** of the forward direction of `Function.injective_iff_pairwise_ne`."},{"type":"‚àÄ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R] [inst_2 : Nontrivial R]\n  [inst_3 : NormalizationMonoid R] [inst_4 : DecidableEq R] {p : R} {x : R}\n  (hp : (p = 0 : Prop) ‚à® (Irreducible p : Prop)) (hnorm : ‚Üënormalize p = p) {n : ‚Ñï} (hle : p ^ n ‚à£ x)\n  (hlt : ¬¨(p ^ (n + 1) ‚à£ x : Prop)), Multiset.count p (UniqueFactorizationMonoid.normalizedFactors x) = n","name":"UniqueFactorizationMonoid.count_normalizedFactors_eq'","isProp":true,"docString":"The number of times an irreducible factor `p` appears in `normalizedFactors x` is defined by\nthe number of times it divides `x`. This is a slightly more general version of\n`UniqueFactorizationMonoid.count_normalizedFactors_eq` that allows `p = 0`.\n\nSee also `multiplicity_eq_count_normalizedFactors` if `n` is given by `multiplicity p x`.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤]\n  (f : (a : Œ±) ‚Üí Œ≤) {b : M} [inst_3 : LinearOrderedCommSemiring M] (hb : Fintype.card Œ≤ ‚Ä¢ b < ‚Üë(Fintype.card Œ±)),\n  ‚àÉ (y : Œ≤), b < ‚Üë(Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ))","name":"Fintype.exists_lt_card_fiber_of_nsmul_lt_card","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes. There is a pigeonhole\nwith at least as many pigeons as the ceiling of the average number of pigeons across all\npigeonholes. "},{"type":"‚àÄ {M : Type u_3} {N : Type u_4} {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : SMul M Œ±] [inst_1 : SMul Œ≤ Œ±]\n  [inst_2 : SMulCommClass Œ≤ M Œ±] (g : (a : N) ‚Üí M), SMulCommClass Œ≤ N Œ±","name":"SMul.comp.smulCommClass'","isProp":true,"docString":"This cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables.\n"},{"type":"‚àÄ {M : Type u_2} [inst : Add M] {Œ≤ : Sort u_1} (c : AddCon M) (f : (a : M) ‚Üí Œ≤)\n  (h : ‚àÄ (a : M) (b : M) (a_1 : ‚Üëc a b), f a = f b) (x : M), AddCon.liftOn (‚Üëx) f h = f x","name":"AddCon.liftOn_coe","isProp":true,"docString":"Definition of the function on the quotient by an additive congruence\nrelation `c` induced by a function that is constant on `c`'s equivalence classes."},{"type":"‚àÄ {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasImages V] {A : V} {B : V} {C : V}\n  {D : V} {f : A ‚ü∂ B} {g : B ‚ü∂ C} {h : C ‚ü∂ D} [inst_2 : CategoryTheory.Limits.HasZeroMorphisms V]\n  [inst_3 : CategoryTheory.Limits.HasEqualizers V] [inst_4 : CategoryTheory.Mono h],\n  (CategoryTheory.Exact f (g ‚â´ h) : Prop) ‚Üî (CategoryTheory.Exact f g : Prop)","name":"CategoryTheory.exact_comp_mono_iff","isProp":true,"docString":"The dual of this lemma is only true when `V` is abelian, see `Abelian.exact_epi_comp_iff`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 0) (hb : b ‚â§ 0), a + b < 0","name":"Left.add_neg_of_neg_of_nonpos","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg_of_neg_of_nonpos`."},{"type":"‚àÄ {X : Type u} {Œ± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Œ±] [inst_2 : TopologicalSpace Œ±]\n  [inst_3 : OrderClosedTopology Œ±] {s : Set X} (hs : IsPreconnected s) {a : X} {b : X} (ha : a ‚àà s) (hb : b ‚àà s)\n  {f : (a : X) ‚Üí Œ±} (hf : ContinuousOn f s), Set.Icc (f a) (f b) ‚äÜ f '' s","name":"IsPreconnected.intermediate_value","isProp":true,"docString":"**Intermediate Value Theorem** for continuous functions on connected sets. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SemilatticeSup Œ±] [inst_1 : OrderBot Œ±] {s : Finset Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {a : Œ±}\n  (a_1 : ‚àÄ (b : Œ≤) (a_1 : b ‚àà s), f b ‚â§ a), Finset.sup s f ‚â§ a","name":"Finset.sup_le","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.sup_le_iff`."},{"type":"‚àÄ {R : Type u} [inst : CommGroup R] [inst_1 : StarSemigroup R] (x : R) (y : R), star (x / y) = star x / star y","name":"star_div","isProp":true,"docString":"When multiplication is commutative, `star` preserves division. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f x y), Equiv.Perm.SameCycle f x (‚Üëf y)","name":"Equiv.Perm.SameCycle.apply_right","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_apply_right`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±] [inst_2 : TopologicalSpace Œ±]\n  [inst_3 : OrderTopology Œ±] [inst_4 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (h : ContinuousOn f (Set.Icc 0 1))\n  (hf : f 0 = f 1), Continuous (f ‚àò Int.fract)","name":"ContinuousOn.comp_fract''","isProp":true,"docString":"A special case of `ContinuousOn.comp_fract`. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {K : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category K] {C : Type u}\n  [inst_2 : CategoryTheory.Category C] {F : J ‚•§ C} (e : K ‚âå J)\n  [inst_3 : CategoryTheory.Limits.HasLimit (CategoryTheory.Equivalence.functor e ‚ãô F)], CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.Limits.hasLimitOfEquivalenceComp","isProp":true,"docString":"If a `E ‚ãô F` has a limit, and `E` is an equivalence, we can construct a limit of `F`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalNonAssocSemiring Œ±] (self : CentroidHom Œ±) (a : Œ±) (b : Œ±),\n  ZeroHom.toFun (‚Üë(CentroidHom.toAddMonoidHom self)) (a * b) = a * ZeroHom.toFun (‚Üë(CentroidHom.toAddMonoidHom self)) b","name":"CentroidHom.map_mul_left'","isProp":true,"docString":"Commutativity of centroid homomorphims with left multiplication. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : CompactSpace Œ±]\n  [inst_3 : T2Space Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (h : Continuous f) (hf : Function.Injective f), ClosedEmbedding f","name":"Continuous.closedEmbedding","isProp":true,"docString":"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C]\n  [self : CategoryTheory.Limits.HasColimitsOfShape J C] (F : J ‚•§ C), CategoryTheory.Limits.HasColimit F","name":"CategoryTheory.Limits.HasColimitsOfShape.has_colimit","isProp":true,"docString":"All `F : J ‚•§ C` have colimits for a fixed `J` "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (p : Submodule R M),\n  p = sup‚Çõ (setOf fun (T : Submodule R M) ‚Ü¶ ‚àÉ (m : M), ‚àÉ (x : m ‚àà p), ‚àÉ (x : m ‚â† 0), T = Submodule.span R {m})","name":"Submodule.submodule_eq_sup‚Çõ_le_nonzero_spans","isProp":true,"docString":"A submodule is equal to the supremum of the spans of the submodule's nonzero elements. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : ‚àÄ (i : Œπ), Infinite (œÄ i)] [inst : (i : Œπ) ‚Üí Zero (œÄ i)]\n  [inst_1 : Nonempty Œπ], Infinite (Dfinsupp fun (i : Œπ) ‚Ü¶ œÄ i)","name":"Dfinsupp.infinite_of_right","isProp":true,"docString":"See `Dfinsupp.infinite_of_exists_right` for the case that only one `œÄ Œπ` is infinite. "},{"type":"‚àÄ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R] [inst_2 : Nontrivial R]\n  [inst_3 : NormalizationMonoid R] [inst_4 : DecidableEq R] [dec_dvd : DecidableRel Dvd.dvd] {a : R} {b : R}\n  (ha : Irreducible a) (hb : b ‚â† 0),\n  multiplicity a b = ‚Üë(Multiset.count (‚Üënormalize a) (UniqueFactorizationMonoid.normalizedFactors b))","name":"UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors","isProp":true,"docString":"The multiplicity of an irreducible factor of a nonzero element is exactly the number of times\nthe normalized factor occurs in the `normalizedFactors`.\n\nSee also `count_normalizedFactors_eq` which expands the definition of `multiplicity`\nto produce a specification for `count (normalizedFactors _) _`..\n"},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hs : Set.Finite s)\n  (ht : Set.Finite t),\n  ((finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s ‚à© t) ‚Ü¶ f i) =\n    (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà t) ‚Ü¶ f i","name":"finsum_mem_union_inter","isProp":true,"docString":"Given finite sets `s` and `t`, the sum of `f i` over `i ‚àà s ‚à™ t` plus the sum of\n`f i` over `i ‚àà s ‚à© t` equals the sum of `f i` over `i ‚àà s` plus the sum of `f i`\nover `i ‚àà t`."},{"type":"‚àÄ {M : Type u} [self : RightCancelMonoid M] (a : M), 1 * a = a","name":"RightCancelMonoid.one_mul","isProp":true,"docString":"One is a left neutral element for multiplication "},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : ContinuousSMul ‚Ñù E] [inst_4 : T2Space E] {A : Type u_2} [inst_5 : TopologicalSpace A] [inst_6 : Ring A]\n  [inst_7 : Algebra ‚Ñù A] [inst_8 : Module A E] [inst_9 : ContinuousSMul ‚Ñù A] [inst_10 : ContinuousSMul A E],\n  IsScalarTower ‚Ñù A E","name":"Real.isScalarTower","isProp":true,"docString":"A topological group carries at most one structure of a topological `‚Ñù`-module, so for any\ntopological `‚Ñù`-algebra `A` (e.g. `A = ‚ÑÇ`) and any topological group that is both a topological\n`‚Ñù`-module and a topological `A`-module, these structures agree. "},{"type":"‚àÄ {Œ± : Type u} (s : Stream'.Seq Œ±) {a‚Çô : Œ±} {n : ‚Ñï} {m : ‚Ñï} (m_le_n : m ‚â§ n)\n  (s_nth_eq_some : Stream'.Seq.get? s n = some a‚Çô), ‚àÉ (a‚Çò : Œ±), Stream'.Seq.get? s m = some a‚Çò","name":"Stream'.Seq.ge_stable","isProp":true,"docString":"If `s.get? n = some a‚Çô` for some value `a‚Çô`, then there is also some value `a‚Çò` such\nthat `s.get? = some a‚Çò` for `m ‚â§ n`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [inst : IsStrictOrder Œ± r],\n  (WellFounded r : Prop) ‚Üî (IsEmpty ((fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x > x_1) ‚Ü™r r) : Prop)","name":"RelEmbedding.wellFounded_iff_no_descending_seq","isProp":true,"docString":"A relation is well-founded iff it doesn't have any infinite decreasing sequence. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {t : Set Œ±} (hs : BddAbove s) (ht : BddAbove t)\n  (hst : Set.Nonempty (s ‚à© t)), sup‚Çõ (s ‚à© t) ‚â§ sup‚Çõ s ‚äì sup‚Çõ t","name":"csup‚Çõ_inter_le","isProp":true,"docString":"The supremum of an intersection of two sets is bounded by the minimum of the suprema of each\nset, if all sets are bounded above and nonempty."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  {s : (a : Œ≤) ‚Üí Œ±} (b : (a : Œ≤) ‚Üí ‚Ñù) (h : ‚àÄ (n : Œ≤) (m : Œ≤) (a : n ‚â§ m), dist (s n) (s m) ‚â§ b n)\n  (h‚ÇÄ : Filter.Tendsto b Filter.atTop (nhds 0)), CauchySeq s","name":"cauchySeq_of_le_tendsto_0'","isProp":true,"docString":"If the distance between `s n` and `s m`, `n ‚â§ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence.  "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {s : Set Œ±} {t : Set Œ≤} (a : LocalHomeomorph.IsImage e s t),\n  LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© ‚Üëe ‚Åª¬π' t = LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© s","name":"LocalHomeomorph.IsImage.preimage_eq","isProp":true,"docString":"**Alias** of the forward direction of `LocalHomeomorph.IsImage.iff_preimage_eq`."},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} {t : Set Œ±} [inst : Fintype ‚Üës] [inst_1 : Fintype ‚Üët] (a : s ‚äÜ t),\n  Set.toFinset s ‚äÜ Set.toFinset t","name":"Set.toFinset_mono","isProp":true,"docString":"**Alias** of the reverse direction of `Set.toFinset_subset_toFinset`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)","name":"AntivaryOn.sum_smul_le_sum_smul_comp_perm","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when\n`f` and `g` antivary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œπ : Type u_3} {Œπ' : Type u_2} {R : Type u_4} {M : Type u_5} [inst : CommSemiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] (b : Basis Œπ R M) (b' : Basis Œπ' R M) {Œπ'' : Type u_1} [inst_3 : Fintype Œπ']\n  (b'' : (a : Œπ'') ‚Üí M), Matrix.mul (Basis.toMatrix b ‚Üëb') (Basis.toMatrix b' b'') = Basis.toMatrix b b''","name":"Basis.toMatrix_mul_toMatrix","isProp":true,"docString":"A generalization of `Basis.toMatrix_self`, in the opposite direction. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : MonotoneOn f s) (hs : s ‚àà nhdsWithin a (Set.Ici a))\n  (hfs : f '' s ‚àà nhdsWithin (f a) (Set.Ici (f a))), ContinuousWithinAt f (Set.Ici a) a","name":"continuousWithinAt_right_of_monotoneOn_of_image_mem_nhdsWithin","isProp":true,"docString":"If a function `f` with a densely ordered codomain is monotone on a right neighborhood of `a` and\nthe image of this neighborhood under `f` is a right neighborhood of `f a`, then `f` is continuous at\n`a` from the right. "},{"type":"Cardinal.mk ‚ÜëSet.univ = Cardinal.continuum","name":"mk_univ_complex","isProp":true,"docString":"The cardinality of the complex numbers, as a set. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M ‚Üí+ N) (a : M) (b : M),\n  ‚Üëf (a + b) = ‚Üëf a + ‚Üëf b","name":"AddMonoidHom.map_add","isProp":true,"docString":"If `f` is an additive monoid homomorphism then `f (a + b) = f a + f b`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [inst : IsRefl Œ± r] [inst : IsAntisymm Œ± r] {a : Œ±} {b : Œ±}\n  (a_1 : AntisymmRel r a b), a = b","name":"AntisymmRel.eq","isProp":true,"docString":"**Alias** of the forward direction of `antisymmRel_iff_eq`."},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : Set Œ±} (hs : IsClosed s),\n  IsClosed (setOf fun (t : TopologicalSpace.Closeds Œ±) ‚Ü¶ ‚Üët ‚äÜ s)","name":"EMetric.isClosed_subsets_of_isClosed","isProp":true,"docString":"Subsets of a given closed subset form a closed set "},{"type":"‚àÄ {Œ± : Sort u} {œÜ : (a : Œ±) ‚Üí Sort v} {a : Œ±} {a' : Œ±} (h : a = a') (p : œÜ a), HEq (Eq.recOn h p) p","name":"eq_rec_heq","isProp":true,"docString":"**Alias** of `eqRec_heq`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {a : Œ±},\n  (a ‚àà closure s : Prop) ‚Üî (‚àÄ (Œµ : ‚Ñù) (a_1 : Œµ > 0), ‚àÉ (b : Œ±), (b ‚àà s : Prop) ‚àß (dist a b < Œµ : Prop) : Prop)","name":"Metric.mem_closure_iff","isProp":true,"docString":"Œµ-characterization of the closure in pseudometric spaces"},{"type":"‚àÄ {m : Type u_1} {n : Type u_2} {Œ± : Type v} [inst : Fintype m] [inst_1 : Fintype n]\n  [inst_2 : NonUnitalNonAssocSemiring Œ±] (x : (a : n) ‚Üí Œ±) (y : (a : n) ‚Üí Œ±) (e : m ‚âÉ n),\n  Matrix.dotProduct (x ‚àò ‚Üëe) (y ‚àò ‚Üëe) = Matrix.dotProduct x y","name":"Matrix.comp_equiv_dotProduct_comp_equiv","isProp":true,"docString":"Permuting vectors on both sides of a dot product is a no-op. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : AddCommMonoid M] {s : Set Œ±} {t : Set Œ≤}\n  (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí M) (hs : Set.Finite s) (ht : Set.Finite t),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ finsum fun (j : Œ≤) ‚Ü¶ finsum fun (h : j ‚àà t) ‚Ü¶ f i j) =\n    finsum fun (j : Œ≤) ‚Ü¶ finsum fun (h : j ‚àà t) ‚Ü¶ finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i j","name":"finsum_mem_comm","isProp":true,"docString":"If `s : Set Œ±` and `t : Set Œ≤` are finite sets, then summing over `s` commutes with\nsumming over `t`."},{"type":"‚àÄ {p : Prop} {ps : List Prop} (f : Sat.Fmla) (hf : Sat.Fmla.proof f [])\n  (hv : ‚àÄ (v : Sat.Valuation), Sat.Valuation.implies v (Sat.Fmla.reify v f (p : Prop) : Prop) ps 0), p","name":"Sat.Fmla.refute","isProp":true,"docString":"If `f` is unsatisfiable, and every `v` which agrees with `ps` implies `¬¨‚ü¶f‚üß_v ‚Üí p`, then `p`.\nEquivalently, there exists a valuation `v` which agrees with `ps`,\nand every such valuation yields `¬¨‚ü¶f‚üß_v` because `f` is unsatisfiable. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p1 : P) (p2 : P) (p3 : P),\n  p1 -·µ• p3 - (p2 -·µ• p3) = p1 -·µ• p2","name":"vsub_sub_vsub_cancel_right","isProp":true,"docString":"Cancellation subtracting the results of two subtractions. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [self : Module R M] (x : M), 0 ‚Ä¢ x = 0","name":"Module.zero_smul","isProp":true,"docString":"Scalar multiplication by zero gives zero. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : IsWeakLowerModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚ãñ a ‚äî b)\n  (a_2 : b ‚ãñ a ‚äî b), a ‚äì b ‚ãñ b","name":"Covby.inf_of_sup_of_sup_right","isProp":true,"docString":"**Alias** of `inf_covby_of_covby_sup_of_covby_sup_right`."},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {s : Multiset Œ±} (a_1 : ‚àÄ (b : Œ±) (a_1 : b ‚àà s), b = a),\n  s = Multiset.replicate (‚ÜëMultiset.card s) a","name":"Multiset.eq_replicate_of_mem","isProp":true,"docString":"**Alias** of the reverse direction of `Multiset.eq_replicate_card`."},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (S : Set (AddCon M)), ‚Üë(inf‚Çõ S) = inf‚Çõ (FunLike.coe '' S)","name":"AddCon.inf‚Çõ_def","isProp":true,"docString":"The infimum of a set of additive congruence relations is the same as the infimum\nof the set's image under the map to the underlying binary relation."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [inst_1 : ProperSpace Œ±], TopologicalSpace.SecondCountableTopology Œ±","name":"secondCountable_of_proper","isProp":true,"docString":"A proper pseudo metric space is sigma compact, and therefore second countable. "},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±},\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ f i) ^ 2 ‚â§ ‚Üë(Finset.card s) * Finset.sum s fun (i : Œπ) ‚Ü¶ f i ^ 2","name":"sq_sum_le_card_mul_sum_sq","isProp":true,"docString":"Special case of **Chebyshev's Sum Inequality** or the **Cauchy-Schwarz Inequality**: The square\nof the sum is less than the size of the set times the sum of the squares. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) {i : ‚Ñï} {j : ‚Ñï} (hi : i < List.length L)\n  (hj : j < List.length (List.nthLe L i hi)),\n  List.sum (List.take i (List.map List.length L)) + j < List.length (List.join L)","name":"List.sum_take_map_length_lt2","isProp":true,"docString":"Auxiliary lemma to control elements in a join. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (g : (a : Œ≤) ‚Üí Œ≥) (f : (a : Œ±) ‚Üí Œ≤), List.map g ‚àò List.map f = List.map (g ‚àò f)","name":"List.map_comp_map","isProp":true,"docString":"Composing a `List.map` with another `List.map` is equal to\na single `List.map` of composed functions.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Monoid Œ≤] [inst_2 : MulAction Œ≤ Œ±] {H : Subgroup Œ±}\n  [self : MulAction.QuotientAction Œ≤ H] (b : Œ≤) {a : Œ±} {a' : Œ±} (a_1 : a‚Åª¬π * a' ‚àà H), (b ‚Ä¢ a)‚Åª¬π * b ‚Ä¢ a' ‚àà H","name":"MulAction.QuotientAction.inv_mul_mem","isProp":true,"docString":"The action fulfils a normality condition on products that lie in `H`.\nThis ensures that the action descends to an action on the quotient `Œ± ‚ß∏ H`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (self : X ‚âÖ Y),\n  CategoryTheory.Iso.hom self ‚â´ CategoryTheory.Iso.inv self = ùüô X","name":"CategoryTheory.Iso.hom_inv_id","isProp":true,"docString":"Composition of the two directions of an isomorphism is the identity on the source. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R] [nR : Nontrivial R], ¬¨(IsRightRegular 0 : Prop)","name":"not_isRightRegular_zero","isProp":true,"docString":"In a non-trivial ring, the element `0` is not right-regular -- with typeclasses. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 0) (hb : b < 0), a + b < 0","name":"Left.add_neg","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderBot Œ±] {s : Set Œ±} (hb : BddAbove s),\n  ‚Üë(sup‚Çõ s) = sup·µ¢ fun (a : Œ±) ‚Ü¶ sup·µ¢ fun (h : a ‚àà s) ‚Ü¶ ‚Üëa","name":"WithTop.coe_sup‚Çõ","isProp":true,"docString":"A version of `WithTop.coe_sup‚Çõ'` with a more convenient but less general statement. "},{"type":"‚àÄ {Œ± : Type u_1} {m : ‚Ñï} (v : (a : Fin m) ‚Üí Œ±), FinVec.etaExpand v = v","name":"FinVec.etaExpand_eq","isProp":true,"docString":"This can be use to prove\n```lean\nexample (a : Fin 2 ‚Üí Œ±) : a = ![a 0, a 1] :=\n  (etaExpand_eq _).symm\n```\n"},{"type":"‚àÄ {R : Type v} [inst : CommRing R] {n : ‚Ñï} (A : Matrix (Fin (Nat.succ n)) (Fin (Nat.succ n)) R),\n  Matrix.det A =\n    Finset.sum Finset.univ fun (i : Fin (Nat.succ n)) ‚Ü¶\n      (-1) ^ ‚Üëi * A i 0 * Matrix.det (Matrix.submatrix A (‚Üë(Fin.succAbove i)) Fin.succ)","name":"Matrix.det_succ_column_zero","isProp":true,"docString":"Laplacian expansion of the determinant of an `n+1 √ó n+1` matrix along column 0. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C], CategoryTheory.Limits.HasEqualizers C","name":"CategoryTheory.Limits.hasEqualizers_of_hasPullbacks_and_binary_products","isProp":true,"docString":"Any category with pullbacks and binary products, has equalizers. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} {y : Œ±} (h : EMetric.diam s ‚â† ‚ä§) (hx : x ‚àà s)\n  (hy : y ‚àà s), dist x y ‚â§ Metric.diam s","name":"Metric.dist_le_diam_of_mem'","isProp":true,"docString":"The distance between two points in a set is controlled by the diameter of the set. "},{"type":"‚àÄ (G : Type u) [inst : AddCommSemigroup G] [inst_1 : IsRightCancelAdd G], IsCancelAdd G","name":"AddCommSemigroup.IsRightCancelAdd.toIsCancelAdd","isProp":true,"docString":"Any\n`AddCommSemigroup G` that satisfies `IsRightCancelAdd G` also satisfies\n`IsCancelAdd G`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {s : Set Œ±} {s‚ÇÅ : Set Œ±} {t : Set Œ≤} {t‚ÇÅ : Set Œ≤},\n  (s √óÀ¢ t ‚äÜ s‚ÇÅ √óÀ¢ t‚ÇÅ : Prop) ‚Üî\n    (((s ‚äÜ s‚ÇÅ : Prop) ‚àß (t ‚äÜ t‚ÇÅ : Prop) : Prop) ‚à® ((s = ‚àÖ : Prop) ‚à® (t = ‚àÖ : Prop) : Prop) : Prop)","name":"Set.prod_subset_prod_iff","isProp":true,"docString":"A product set is included in a product set if and only factors are included, or a factor of the\nfirst set is empty. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (s : Submodule R M), (Submodule.Fg s : Prop) ‚Üî (CompleteLattice.IsCompactElement s : Prop)","name":"Submodule.fg_iff_compact","isProp":true,"docString":"Finitely generated submodules are precisely compact elements in the submodule lattice. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ±' : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {s : Set Œ±} {t : Set Œ≤}\n  {f : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ±'} {f' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_left_comm : ‚àÄ (a : Œ±) (b : Œ≤), f (g a) b = g' (f' a b)), Set.image2 f (g '' s) t = g' '' Set.image2 f' s t","name":"Set.image2_image_left_comm","isProp":true,"docString":"Symmetric statement to `Set.image_image2_distrib_left`. "},{"type":"‚àÄ {n : ‚Ñï‚àû} (a : n ‚â† ‚ä§), ‚Üë(‚ÜëENat.toNat n) = n","name":"ENat.coe_toNat","isProp":true,"docString":"**Alias** of the reverse direction of `ENat.coe_toNat_eq_self`."},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : FrechetUrysohnSpace X], SequentialSpace X","name":"FrechetUrysohnSpace.to_sequentialSpace","isProp":true,"docString":"Every Fr√©chet-Urysohn space is a sequential space. "},{"type":"‚àÄ {Œπ : Sort u_1} {œÄ : Type u_2} [inst : Nontrivial œÄ] [inst : Infinite Œπ], Infinite ((a : Œπ) ‚Üí œÄ)","name":"Function.infinite_of_left","isProp":true,"docString":"Non-dependent version of `Pi.infinite_of_left`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ioo (f n) (f (Order.pred n)))","name":"Antitone.pairwise_disjoint_on_Ioo_pred","isProp":true,"docString":"If `Œ±` is a linear pred order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is an antitone function, then\nthe intervals `Set.Ioo (f n) (f (Order.pred n))` are pairwise disjoint. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {m : Type u_2} {n : Type u_3} [inst_1 : Fintype n] [inst_2 : Fintype m]\n  [inst_3 : DecidableEq n], Matrix.toLin (Pi.basisFun R n) (Pi.basisFun R m) = Matrix.toLin'","name":"Matrix.toLin_eq_toLin'","isProp":true,"docString":"`Matrix.toLin'` is a particular case of `Matrix.toLin`, for the standard basis\n`Pi.basisFun R n`. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : Nonempty J] {j‚ÇÄ : J}\n  (h :\n    ‚àÄ (p : Set J) (a : j‚ÇÄ ‚àà p) (a : ‚àÄ {j‚ÇÅ : J} {j‚ÇÇ : J} (x : j‚ÇÅ ‚ü∂ j‚ÇÇ), (j‚ÇÅ ‚àà p : Prop) ‚Üî (j‚ÇÇ ‚àà p : Prop)) (j : J),\n      j ‚àà p),\n  CategoryTheory.IsConnected J","name":"CategoryTheory.IsConnected.of_induct","isProp":true,"docString":"If any maximal connected component containing some element j‚ÇÄ of J is all of J, then J is connected.\n\nThe converse of `induct_on_objects`.\n"},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] {p : (g : G‚ÇÄ) ‚Üí (a : g ‚â† 0) ‚Üí Prop},\n  (‚àÉ (g : G‚ÇÄ), ‚àÉ (hg : g ‚â† 0), p g hg : Prop) ‚Üî (‚àÉ (g : G‚ÇÄÀ£), p ‚Üëg ((Units.ne_zero g=:‚Üëg ‚â† 0)=:‚Üëg ‚â† 0) : Prop)","name":"Units.exists0'","isProp":true,"docString":"An alternative version of `Units.exists0`. This one is useful if Lean cannot\nfigure out `p` when using `Units.exists0` from right to left. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : PartialOrder Œ≤] {l : (a : Œ±) ‚Üí Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (gc : GaloisConnection l u) (b : Œ≤), (‚àÉ (a : Œ±), b = l a : Prop) ‚Üî (b = l (u b) : Prop)","name":"GaloisConnection.exists_eq_l","isProp":true,"docString":"If there exists an `a` such that `b = l a`, then `a = u b` is one such element. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Üë(nndist x y)","name":"dist_nndist","isProp":true,"docString":"Express `dist` in terms of `nndist`"},{"type":"‚àÄ (k : Type u_3) (V : Type u_4) {P : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : (a : Œπ) ‚Üí Set P),\n  affineSpan k (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ s i) = sup·µ¢ fun (i : Œπ) ‚Ü¶ affineSpan k (s i)","name":"AffineSubspace.span_union·µ¢","isProp":true,"docString":"The span of a union of an indexed family of sets is the sup of their spans. "},{"type":"‚àÄ (f : (a : ‚Ñï) ‚Üí NNReal), Filter.Tendsto (fun (i : ‚Ñï) ‚Ü¶ tsum fun (k : ‚Ñï) ‚Ü¶ f (k + i)) Filter.atTop (nhds 0)","name":"NNReal.tendsto_sum_nat_add","isProp":true,"docString":"For `f : ‚Ñï ‚Üí ‚Ñù‚â•0`, then `‚àë' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. "},{"type":"‚àÄ (n : ‚Ñï) (e : ‚Ñï) (a : 0 < e) (a : n < 10 ^ e), String.length (Nat.repr n) ‚â§ e","name":"Nat.repr_length","isProp":true,"docString":"The core implementation of `Nat.repr` returns a String with length less than or equal to the\nnumber of digits in the decimal number (represented by `e`). For example, the decimal string\nrepresentation of any number less than 1000 (10 ^ 3) has a length less than or equal to 3. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] [inst_4 : TopologicalSpace Œ≤] [inst_5 : One Œ±] {f : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f)\n  (h : HasCompactMulSupport f), BddAbove (Set.range f)","name":"Continuous.bddAbove_range_of_hasCompactMulSupport","isProp":true,"docString":"A continuous function with compact support is bounded above. "},{"type":"‚àÄ {R : Type u} {œÉ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial œÉ R)","name":"MvPolynomial.instIsDomainMvPolynomialToCommSemiringToSemiringToRingInstCommRingMvPolynomialToCommSemiring","isProp":true,"docString":"The multivariate polynomial ring over an integral domain is an integral domain. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a : Œ±} {b : Œ±}, (a ‚à£ a + b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"dvd_add_self_left","isProp":true,"docString":"An element a divides the sum a + b if and only if a divides b."},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±}, Finset.card (Finset.Iic s) = 2 ^ Finset.card s","name":"Finset.card_Iic_finset","isProp":true,"docString":"Cardinality of an `Iic` of finsets. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±]\n  [inst_2 : OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±}\n  (hf : Filter.Tendsto f l Filter.atTop) (hg : Filter.Tendsto g l (nhds C)),\n  Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x + g x) l Filter.atTop","name":"Filter.Tendsto.atTop_add","isProp":true,"docString":"In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`atTop` and `g` tends to `C` then `f + g` tends to `atTop`. "},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : CommSemiring R]\n  [inst_1 : Semiring A] [inst_2 : Algebra R A] [inst_3 : Star A] [inst_4 : Semiring B] [inst_5 : Algebra R B]\n  [inst_6 : Star B] [self : StarAlgHomClass F R A B] (f : F) (r : A), ‚Üëf (star r) = star (‚Üëf r)","name":"StarAlgHomClass.map_star","isProp":true,"docString":"the maps preserve star "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : ¬¨(a < b : Prop)),\n  Finset.Ico a b = ‚àÖ","name":"Finset.Ico_eq_empty","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.Ico_eq_empty_iff`."},{"type":"‚àÄ {R : Type u} [inst : Semiring R] [self : InvariantBasisNumber R] {n : ‚Ñï} {m : ‚Ñï}\n  (a : ((a : Fin n) ‚Üí R) ‚âÉ‚Çó[R] (a : Fin m) ‚Üí R), n = m","name":"InvariantBasisNumber.eq_of_fin_equiv","isProp":true,"docString":"Any linear equiv between `R‚Åø` and `R·µê` guarantees `m = n`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] (a : Œ±), sup‚Çõ {a} = a","name":"csup‚Çõ_singleton","isProp":true,"docString":"The supremum of a singleton is the element of the singleton"},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] (f : CompleteLatticeHom Œ± Œ±) (a : Œ±),\n  ‚Üëf (Filter.liminf (fun (n : ‚Ñï) ‚Ü¶ (‚Üëf^[n]) a) Filter.atTop) = Filter.liminf (fun (n : ‚Ñï) ‚Ü¶ (‚Üëf^[n]) a) Filter.atTop","name":"Filter.CompleteLatticeHom.apply_liminf_iterate","isProp":true,"docString":"If `f : Œ± ‚Üí Œ±` is a morphism of complete lattices, then the liminf of its iterates of any\n`a : Œ±` is a fixed point. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {s : Set G} (self : IsSubgroup s) {a : G} (a_1 : a ‚àà s), a‚Åª¬π ‚àà s","name":"IsSubgroup.inv_mem","isProp":true,"docString":"The proposition that `s` is closed under inverse. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (a : G) (x : G), SemiconjBy a x (a * x * a‚Åª¬π)","name":"SemiconjBy.conj_mk","isProp":true,"docString":"`a` semiconjugates `x` to `a * x * a‚Åª¬π`. "},{"type":"‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N]\n  (cond : FiniteDimensional.finrank R M = FiniteDimensional.finrank R N), Nonempty (M ‚âÉ‚Çó[R] N)","name":"FiniteDimensional.nonempty_linearEquiv_of_finrank_eq","isProp":true,"docString":"Two finite and free modules are isomorphic if they have the same (finite) rank. "},{"type":"‚àÄ {C : Type u} [ùíû : CategoryTheory.Category C] [self : CategoryTheory.MonoidalCategory C] {X‚ÇÅ : C} {X‚ÇÇ : C} {X‚ÇÉ : C}\n  {Y‚ÇÅ : C} {Y‚ÇÇ : C} {Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ),\n  ((f‚ÇÅ ‚äó f‚ÇÇ) ‚äó f‚ÇÉ) ‚â´ CategoryTheory.Iso.hom (Œ±_ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ) = CategoryTheory.Iso.hom (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ) ‚â´ (f‚ÇÅ ‚äó f‚ÇÇ ‚äó f‚ÇÉ)","name":"CategoryTheory.MonoidalCategory.associator_naturality","isProp":true,"docString":"Naturality of the associator isomorphism: `(f‚ÇÅ ‚äó f‚ÇÇ) ‚äó f‚ÇÉ ‚âÉ f‚ÇÅ ‚äó (f‚ÇÇ ‚äó f‚ÇÉ)` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±} {k : ‚Ñï},\n  (s ‚àà (Finset.upShadow^[k]) ùíú : Prop) ‚Üî\n    (‚àÉ (t : Finset Œ±), (t ‚àà ùíú : Prop) ‚àß ((t ‚äÜ s : Prop) ‚àß (Finset.card t + k = Finset.card s : Prop) : Prop) : Prop)","name":"Finset.mem_upShadow_iff_exists_mem_card_add","isProp":true,"docString":"`t ‚àà ‚àÇ^k ùíú` iff `t` is exactly `k` elements more than something in `ùíú`. "},{"type":"‚àÄ {Œ± : Type u_1} (r : Setoid Œ±),\n  Setoid.mkClasses (Setoid.classes r)\n      ((Setoid.classes_eqv_classes=:‚àÄ (a : Œ±),\n            ‚àÉ! (b : Set Œ±),\n              ‚àÉ! (x : b ‚àà Setoid.classes r), a ‚àà b)=:‚àÄ (a : Œ±), ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà Setoid.classes r), a ‚àà b) =\n    r","name":"Setoid.mkClasses_classes","isProp":true,"docString":"The equivalence relation made from the equivalence classes of an equivalence\nrelation r equals r. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {x : Œ±} {F : Filter Œ±} {G : Filter Œ±} (h : AccPt x F) (hFG : F ‚â§ G),\n  AccPt x G","name":"AccPt.mono","isProp":true,"docString":"If `x` is an accumulation point of `F` and `F ‚â§ G`, then\n`x` is an accumulation point of `D. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±]\n  (H : FreeGroup.mk L‚ÇÅ = FreeGroup.mk L‚ÇÇ), FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ","name":"FreeGroup.reduce.sound","isProp":true,"docString":"If two words correspond to the same element in the free group, then they\nhave a common maximal reduction. This is the proof that the function that sends\nan element of the free group to its maximal reduction is well-defined. "},{"type":"‚àÄ {R : Type u‚ÇÅ} [inst : LinearOrderedRing R] {a : R} (H : -2 ‚â§ a) (n : ‚Ñï), 1 + ‚Üën * a ‚â§ (1 + a) ^ n","name":"one_add_mul_le_pow","isProp":true,"docString":"Bernoulli's inequality for `n : ‚Ñï`, `-2 ‚â§ a`. "},{"type":"‚àÄ (Œ± : Type u) [inst : UniformSpace Œ±] [inst_1 : Filter.IsCountablyGenerated (uniformity Œ±)]\n  [inst_2 : TopologicalSpace.SeparableSpace Œ±], TopologicalSpace.SecondCountableTopology Œ±","name":"UniformSpace.secondCountable_of_separable","isProp":true,"docString":"A separable uniform space with countably generated uniformity filter is second countable:\none obtains a countable basis by taking the balls centered at points in a dense subset,\nand with rational \"radii\" from a countable open symmetric antitone basis of `ùì§ Œ±`. We do not\nregister this as an instance, as there is already an instance going in the other direction\nfrom second countable spaces to separable spaces, and we want to avoid loops. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {s : Set M} {p : (a : M) ‚Üí Prop} {x : M} (h : x ‚àà Subsemigroup.closure s)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s), p x) (Hmul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x * y)), p x","name":"Subsemigroup.closure_induction","isProp":true,"docString":"An induction principle for closure membership. If `p` holds for all elements of `s`, and\nis preserved under multiplication, then `p` holds for all elements of the closure of `s`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} (E : Set Œ±), E ‚äÜ Metric.cthickening Œ¥ E","name":"Metric.self_subset_cthickening","isProp":true,"docString":"A set is contained in its own closed thickening. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : Nonempty Œπ] {f : (a : Œπ) ‚Üí Œ±} {c : Œ±}\n  (H : ‚àÄ (x : Œπ), c ‚â§ f x), c ‚â§ inf·µ¢ f","name":"le_cinf·µ¢","isProp":true,"docString":"The indexed minimum of a function is bounded below by a uniform lower bound"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] (U : Set Œ≤),\n  Quotient.mk' ‚Åª¬π' (Quotient.mk' '' U) = Set.union·µ¢ fun (a : Œ±) ‚Ü¶ (fun (x : Œ±) (x_1 : Œ≤) ‚Ü¶ x +·µ• x_1) a '' U","name":"AddAction.quotient_preimage_image_eq_union_add","isProp":true,"docString":"When you take a set `U` in `Œ≤`, push it down to the quotient, and pull back, you get the\nunion of the orbit of `U` under `Œ±`."},{"type":"‚àÄ {Œπ : Type u_2} {M : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí Monoid (M i)] {N : Type u_3} [inst_1 : Monoid N]\n  (f : FreeProduct M ‚Üí* N) (g : FreeProduct M ‚Üí* N)\n  (h : ‚àÄ (i : Œπ), MonoidHom.comp f FreeProduct.of = MonoidHom.comp g FreeProduct.of), f = g","name":"FreeProduct.ext_hom","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] [inst_1 : DecidableEq Œ±] (s : Finset Œ±) (a : Œ±) (b : (a : Œ±) ‚Üí Œ≤),\n  (Finset.prod s fun (x : Œ±) ‚Ü¶ if (x = a : Prop) then b x else 1) = if (a ‚àà s : Prop) then b a else 1","name":"Finset.prod_ite_eq'","isProp":true,"docString":"A product taken over a conditional whose condition is an equality test on the index and whose\nalternative is `1` has value either the term at that index or `1`.\n\nThe difference with `Finset.prod_ite_eq` is that the arguments to `eq` are swapped. "},{"type":"‚àÄ {Œ± : Type uu} (a : Œ±) {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (a : a :: l‚ÇÅ <+~ a :: l‚ÇÇ), l‚ÇÅ <+~ l‚ÇÇ","name":"List.subperm.of_cons","isProp":true,"docString":"**Alias** of the forward direction of `List.subperm_cons`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {y : Œ±} {s : Set Œ±} {t : Set Œ±} (xs : x ‚àà s) (yt : y ‚àà t),\n  EMetric.diam (s ‚à™ t) ‚â§ EMetric.diam s + edist x y + EMetric.diam t","name":"EMetric.diam_union","isProp":true,"docString":"The diameter of a union is controlled by the diameter of the sets, and the edistance\nbetween two points in the sets. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} {t : Set X} (x : DiscreteTopology ‚Üës) (ts : t ‚äÜ s),\n  DiscreteTopology ‚Üët","name":"DiscreteTopology.of_subset","isProp":true,"docString":"Let `s, t ‚äÜ X` be two subsets of a topological space `X`.  If `t ‚äÜ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {a : R} [inst : Monoid R] [inst_1 : MulAction R M] {n : ‚Ñï} (n0 : 0 < n),\n  (IsSMulRegular M (a ^ n) : Prop) ‚Üî (IsSMulRegular M a : Prop)","name":"IsSMulRegular.pow_iff","isProp":true,"docString":"An element `a` is `M`-regular if and only if a positive power of `a` is `M`-regular. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedAddMonoid Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b), ‚àÉ (c : Œ±), b = a + c","name":"CanonicallyOrderedAddMonoid.exists_add_of_le","isProp":true,"docString":"For `a ‚â§ b`, there is a `c` so `b = a + c`. "},{"type":"‚àÄ (R : Type u_1) [inst : CommSemiring R] (X : Type u_2) {C : (a : FreeAlgebra R X) ‚Üí Prop}\n  (h_grade0 : ‚àÄ (r : R), C (‚Üë(algebraMap R (FreeAlgebra R X)) r)) (h_grade1 : ‚àÄ (x : X), C (FreeAlgebra.Œπ R x))\n  (h_mul : ‚àÄ (a : FreeAlgebra R X) (b : FreeAlgebra R X) (a_1 : C a) (a_2 : C b), C (a * b))\n  (h_add : ‚àÄ (a : FreeAlgebra R X) (b : FreeAlgebra R X) (a_1 : C a) (a_2 : C b), C (a + b)) (a : FreeAlgebra R X), C a","name":"FreeAlgebra.induction","isProp":true,"docString":"An induction principle for the free algebra.\n\nIf `C` holds for the `algebraMap` of `r : R` into `FreeAlgebra R X`, the `Œπ` of `x : X`, and is\npreserved under addition and muliplication, then it holds for all of `FreeAlgebra R X`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {s : Set Œ±} (hs : Set.Nonempty s) {f : (a : Œ±) ‚Üí Œπ},\n  (Set.Pairwise s fun (x : Œ±) (y : Œ±) ‚Ü¶ f x = f y : Prop) ‚Üî (‚àÉ (z : Œπ), ‚àÄ (x : Œ±) (a : x ‚àà s), f x = z : Prop)","name":"Set.Nonempty.pairwise_eq_iff_exists_eq","isProp":true,"docString":"For a nonempty set `s`, a function `f` takes pairwise equal values on `s` if and only if\nfor some `z` in the codomain, `f` takes value `z` on all `x ‚àà s`. See also\n`Set.pairwise_eq_iff_exists_eq` for a version that assumes `[Nonempty Œπ]` instead of\n`Set.Nonempty s`. "},{"type":"‚àÄ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  (IsCompact s : Prop) ‚Üî (IsSeqCompact s : Prop)","name":"UniformSpace.isCompact_iff_isSeqCompact","isProp":true,"docString":"A version of Bolzano-Weistrass: in a uniform space with countably generated uniformity filter\n(e.g., in a metric space), a set is compact if and only if it is sequentially compact. "},{"type":"‚àÄ {M : Type u_3} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N] {P : Type u_1}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëg ‚Üëy)) (z : N) (w : P) (v : P),\n  (‚Üë(AddSubmonoid.LocalizationMap.lift f hg) z + w = v : Prop) ‚Üî\n    (‚Üëg (Prod.fst (AddSubmonoid.LocalizationMap.sec f z)) + w =\n        ‚Üëg ‚Üë(Prod.snd (AddSubmonoid.LocalizationMap.sec f z)) + v :\n      Prop)","name":"AddSubmonoid.LocalizationMap.lift_spec_add","isProp":true,"docString":"Given a Localization map `f : M ‚Üí+ N` for a Submonoid `S ‚äÜ M`, if an `AddCommMonoid` map\n`g : M ‚Üí+ P` induces a map `f.lift hg : N ‚Üí+ P` then for all\n`z : N, v w : P`, we have `f.lift hg z + w = v ‚Üî g x + w = g y + v`, where `x : M, y ‚àà S` are such\nthat `z + f y = f x`."},{"type":"‚àÄ {G : Type u_2} [inst : Group G] {H : Subgroup G} {N : Type u_1} [inst_1 : Group N] (f : N ‚Üí* G),\n  Subgroup.comap f (Subgroup.normalizer H) ‚â§ Subgroup.normalizer (Subgroup.comap f H)","name":"Subgroup.le_normalizer_comap","isProp":true,"docString":"The preimage of the normalizer is contained in the normalizer of the preimage. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : (a : Œ±) ‚Üí Œ≤) (g : (a : Œ≤) ‚Üí Œ±),\n  Set.MapsTo f (Function.fixedPoints (g ‚àò f)) (Function.fixedPoints (f ‚àò g))","name":"Function.mapsTo_fixedPoints_comp","isProp":true,"docString":"Any map `f` sends fixed points of `g ‚àò f` to fixed points of `f ‚àò g`. "},{"type":"‚àÄ {Œ± : Type u} {L : List (Œ± √ó Bool)}, (FreeAddGroup.Red [] L : Prop) ‚Üî (L = [] : Prop)","name":"FreeAddGroup.Red.nil_iff","isProp":true,"docString":"The empty word `[]` only reduces to itself."},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±} (a_1 : IsMax a), a = ‚ä§","name":"IsMax.eq_top","isProp":true,"docString":"**Alias** of the forward direction of `isMax_iff_eq_top`."},{"type":"‚àÄ {f : (a : Type u‚ÇÄ) ‚Üí Type u‚ÇÅ} [self : EquivFunctor f] (Œ± : Type u‚ÇÄ), EquivFunctor.map (Equiv.refl Œ±) = id","name":"EquivFunctor.map_refl'","isProp":true,"docString":"`map` of `f` preserves the identity morphism. "},{"type":"‚àÄ (T : Type u) [inst : TopologicalSpace T],\n  CategoryTheory.Pretopology.toGrothendieck (TopologicalSpace.Opens T) (Opens.pretopology T) =\n    Opens.grothendieckTopology T","name":"Opens.pretopology_toGrothendieck","isProp":true,"docString":"The pretopology associated to a space induces the Grothendieck topology associated to the space.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T0Space Œ±]\n  {f : (a : Œ±) ‚Üí Œ≤} (hf : Inducing f), Function.Injective f","name":"Inducing.injective","isProp":true,"docString":"A topology `Inducing` map from a T‚ÇÄ space is injective. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {Œπ : Type v} [hŒπ : Nonempty Œπ] (hs : IsCompact s)\n  (U : (a : Œπ) ‚Üí Set Œ±) (hUo : ‚àÄ (i : Œπ), IsOpen (U i)) (hsU : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ U i)\n  (hdU : Directed (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äÜ x_1) U), ‚àÉ (i : Œπ), s ‚äÜ U i","name":"IsCompact.elim_directed_cover","isProp":true,"docString":"For every open directed cover of a compact set, there exists a single element of the\ncover which itself includes the set. "},{"type":"‚àÄ {Œ± : Type u} {l : List Œ±} (a : List.Nodup (List.sublists l)), List.Nodup l","name":"List.nodup.of_sublists","isProp":true,"docString":"**Alias** of the forward direction of `List.nodup_sublists`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G} {y : G} (a : x ‚àà H) (a : y ‚àà H), x * y ‚àà H","name":"Subgroup.mul_mem","isProp":true,"docString":"A subgroup is closed under multiplication. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) (d : Con M),\n  c ‚äî d = conGen fun (x : M) (y : M) ‚Ü¶ (‚Üëc x y : Prop) ‚à® (‚Üëd x y : Prop)","name":"Con.sup_eq_conGen","isProp":true,"docString":"The supremum of congruence relations `c, d` equals the smallest congruence relation containing\nthe binary relation '`x` is related to `y` by `c` or `d`'. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : Dense s) (ht : Dense t) (hto : IsOpen t),\n  Dense (s ‚à© t)","name":"Dense.inter_of_open_right","isProp":true,"docString":"The intersection of a dense set with an open dense set is a dense set. "},{"type":"‚àÄ {Œ± : Type u} {l : List Œ±} (a : List.Nodup (List.attach l)), List.Nodup l","name":"List.Nodup.of_attach","isProp":true,"docString":"**Alias** of the forward direction of `List.nodup_attach`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤),\n  (0 = 1 : Prop) ‚Üî (‚àÄ (x_2 : Œ±), ‚Üëf x_2 = 0 : Prop)","name":"RingHom.codomain_trivial_iff_range_trivial","isProp":true,"docString":"`f : Œ± ‚Üí+* Œ≤` has a trivial codomain iff it has a trivial range. "},{"type":"‚àÄ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'] (cnd : Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')),\n  Nonempty (V ‚âÉ‚Çó[K] V')","name":"nonempty_linearEquiv_of_lift_rank_eq","isProp":true,"docString":"Two vector spaces are isomorphic if they have the same dimension. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (Cf : ContinuousAt f (sup‚Çõ s)) (Mf : Monotone f) (fbot : f ‚ä• = ‚ä•), f (sup‚Çõ s) = sup‚Çõ (f '' s)","name":"Monotone.map_sup‚Çõ_of_continuousAt","isProp":true,"docString":"A monotone function `f` sending `bot` to `bot` and continuous at the supremum of a set sends\nthis supremum to the supremum of the image of this set. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {X : C}\n  (h :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.coyoneda) (Opposite.op X) ‚ãô\n        CategoryTheory.uliftFunctor ‚âÖ\n      CategoryTheory.Functor.cocones F)\n  (s : CategoryTheory.Limits.Cocone F),\n  CategoryTheory.Limits.Cocone.extend (CategoryTheory.Limits.IsColimit.OfNatIso.colimitCocone h)\n      (CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone h s) =\n    s","name":"CategoryTheory.Limits.IsColimit.OfNatIso.cocone_fac","isProp":true,"docString":"If `F.cocones` is corepresented by `X`, any cocone is the extension of the colimit cocone by the\ncorresponding morphism. "},{"type":"‚àÄ {C : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {D : Type u_1}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.Preadditive D] (G : C ‚•§ D)\n  [inst_4 : CategoryTheory.Functor.Additive G] (X : CategoryTheory.SimplicialObject C) (q : ‚Ñï) (n : ‚Ñï) (m : ‚Ñï)\n  (hnm : ComplexShape.Rel AlgebraicTopology.DoldKan.c m n),\n  AlgebraicTopology.DoldKan.hœÉ' q n m hnm =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) (AlgebraicTopology.DoldKan.hœÉ' q n m hnm)","name":"AlgebraicTopology.DoldKan.map_hœÉ'","isProp":true,"docString":"The maps `hœÉ' q n m hnm` are compatible with the application of additive functors. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (h : 0 < r * (b - a)),\n  (‚Üë(AffineMap.lineMap (f a) (f b)) r < f (‚Üë(AffineMap.lineMap a b) r) : Prop) ‚Üî\n    (slope f a b < slope f a (‚Üë(AffineMap.lineMap a b) r) : Prop)","name":"lineMap_lt_map_iff_slope_lt_slope_left","isProp":true,"docString":"Given `c = lineMap a b r`, `a < c`, the point `(c, f c)` is strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a b < slope f a c`. "},{"type":"Subgroup.normalClosure\n    {{ val := finRotate 5,\n        property :=\n          ((Equiv.Perm.finRotate_bit1_mem_alternatingGroup=:finRotate (bit1 2) ‚àà\n                alternatingGroup (Fin (bit1 2)))=:finRotate (bit1 2) ‚àà alternatingGroup (Fin (bit1 2))) }} =\n  ‚ä§","name":"alternatingGroup.normalClosure_finRotate_five","isProp":true,"docString":"The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be\nused to show that the normal closure of any 5-cycle within $A_5$ is the whole group. "},{"type":"‚àÄ {m : Type u} {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±]\n  (A : Matrix m n Œ±) (B : Matrix n n Œ±) [inst_3 : Invertible B], Matrix.mul (Matrix.mul A ‚ÖüB) B = A","name":"Matrix.mul_invOf_mul_self_cancel","isProp":true,"docString":"A copy of `mul_invOf_mul_self_cancel` using `‚¨ù` not `*`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {H‚ÇÅ : Subgroup G} {H‚ÇÇ : Subgroup G} {H‚ÇÉ : Subgroup G} (h1 : ‚ÅÖ‚ÅÖH‚ÇÇ, H‚ÇÉ‚ÅÜ, H‚ÇÅ‚ÅÜ = ‚ä•)\n  (h2 : ‚ÅÖ‚ÅÖH‚ÇÉ, H‚ÇÅ‚ÅÜ, H‚ÇÇ‚ÅÜ = ‚ä•), ‚ÅÖ‚ÅÖH‚ÇÅ, H‚ÇÇ‚ÅÜ, H‚ÇÉ‚ÅÜ = ‚ä•","name":"Subgroup.commutator_commutator_eq_bot_of_rotate","isProp":true,"docString":"**The Three Subgroups Lemma** (via the Hall-Witt identity) "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] [inst_3 : MulPosMono Œ±]\n  (ha : 1 ‚â§ a) (hb : 1 ‚â§ b) (b0 : 0 ‚â§ b), 1 ‚â§ a * b","name":"Right.one_le_mul_of_le_of_le","isProp":true,"docString":"Assumes right covariance. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedGroup E],\n  Filter.Tendsto Inv.inv (Filter.comap norm Filter.atTop) (Filter.comap norm Filter.atTop)","name":"Filter.tendsto_inv_cobounded","isProp":true,"docString":"In a (semi)normed group, inversion `x ‚Ü¶ x‚Åª¬π` tends to infinity at infinity. TODO: use\n`Bornology.cobounded` instead of `Filter.comap Norm.norm Filter.atTop`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] [inst_1 : CompleteSpace Œ±] {s : (a : ‚Ñï) ‚Üí Set Œ±}\n  (hs : ‚àÄ (n : ‚Ñï), IsClosed (s n)) (h's : ‚àÄ (n : ‚Ñï), Metric.Bounded (s n))\n  (h : ‚àÄ (N : ‚Ñï), Set.Nonempty (Set.inter·µ¢ fun (n : ‚Ñï) ‚Ü¶ Set.inter·µ¢ fun (h : n ‚â§ N) ‚Ü¶ s n))\n  (h' : Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ Metric.diam (s n)) Filter.atTop (nhds 0)),\n  Set.Nonempty (Set.inter·µ¢ fun (n : ‚Ñï) ‚Ü¶ s n)","name":"Metric.nonempty_inter·µ¢_of_nonempty_binter·µ¢","isProp":true,"docString":"In a complete space, if a family of closed sets with diameter tending to `0` is such that each\nfinite intersection is nonempty, then the total intersection is also nonempty. "},{"type":"‚àÄ {R : Type u} {M : Type v} {N : Type w} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : TopologicalSpace M]\n  [inst_3 : AddCommGroup M] [inst_4 : AddCommGroup N] [inst_5 : Module R M] [inst_6 : ContinuousSMul R M]\n  [inst_7 : Module R N] [inst_8 : ContinuousAdd M] [inst_9 : IsSimpleModule R N] (l : M ‚Üí‚Çó[R] N),\n  (IsClosed ‚Üë(LinearMap.ker l) : Prop) ‚à® (Dense ‚Üë(LinearMap.ker l) : Prop)","name":"LinearMap.isClosed_or_dense_ker","isProp":true,"docString":"The kernel of a linear map taking values in a simple module over the base ring is closed or\ndense. Applies, e.g., to the case when `R = N` is a division ring. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : UniformSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±},\n  (UniformEquicontinuous F : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n        Filter.Eventually (fun (xy : Œ≤ √ó Œ≤) ‚Ü¶ ‚àÄ (i : Œπ), dist (F i (Prod.fst xy)) (F i (Prod.snd xy)) < Œµ)\n          (uniformity Œ≤) :\n      Prop)","name":"Metric.uniformEquicontinuous_iff_right","isProp":true,"docString":"Characterization of uniform equicontinuity for families of functions taking values in a\n(pseudo) metric space. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : SemilatticeSup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (hf : AntitoneOn f s) (hg : AntitoneOn g s), AntitoneOn (f ‚äî g) s","name":"AntitoneOn.sup","isProp":true,"docString":"Pointwise supremum of two antitone functions is a antitone function. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M} (hs : IsSubmonoid s) {l : List M} (a : ‚àÄ (x : M) (a : x ‚àà l), x ‚àà s),\n  List.prod l ‚àà s","name":"IsSubmonoid.list_prod_mem","isProp":true,"docString":"The product of a list of elements of a submonoid is an element of the submonoid. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G],\n  (AddGroup.Fg G : Prop) ‚Üî (‚àÉ (S : Set G), (AddSubgroup.closure S = ‚ä§ : Prop) ‚àß (Set.Finite S : Prop) : Prop)","name":"AddGroup.fg_iff","isProp":true,"docString":"An equivalent expression of `AddGroup.fg` in terms of `Set.Finite` instead of `Finset`."},{"type":"‚àÄ {R : Type u} {S : Type v} {F : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] [rc : RingHomClass F R S] (f : F)\n  {G : Type u_1} [rcg : RingHomClass G S R] (g : G) (I : Ideal R) (h : Function.LeftInverse ‚Üëg ‚Üëf),\n  Ideal.map f I ‚â§ Ideal.comap g I","name":"Ideal.map_le_comap_of_inverse","isProp":true,"docString":"The `Ideal` version of `Set.image_subset_preimage_of_inverse`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} [inst_4 : Nontrivial k] {p : (a : Œπ) ‚Üí P} (ha : AffineIndependent k p)\n  {s1 : Set Œπ} {s2 : Set Œπ} {p0 : P} (hp0s1 : p0 ‚àà affineSpan k (p '' s1)) (hp0s2 : p0 ‚àà affineSpan k (p '' s2)),\n  ‚àÉ (i : Œπ), i ‚àà s1 ‚à© s2","name":"AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan","isProp":true,"docString":"If a family is affinely independent, and the spans of points\nindexed by two subsets of the index type have a point in common, those\nsubsets of the index type have an element in common, if the underlying\nring is nontrivial. "},{"type":"‚àÄ {n : Type u_1} {R : Type u_2} [inst : TopologicalSpace R] [inst_1 : Fintype n] [inst_2 : DecidableEq n]\n  [inst_3 : CommRing R] [inst_4 : TopologicalRing R] (A : Matrix n n R) (h : ContinuousAt Ring.inverse (Matrix.det A)),\n  ContinuousAt Inv.inv A","name":"continuousAt_matrix_inv","isProp":true,"docString":"When `Ring.inverse` is continuous at the determinant (such as in a `NormedRing`, or a\n`topological_field`), so is `matrix.has_inv`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±} (a_1 : IsBot a), IsTop (‚ÜëOrderDual.toDual a)","name":"IsBot.toDual","isProp":true,"docString":"**Alias** of the reverse direction of `isTop_toDual_iff`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C),\n  CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.œÄ 0)","name":"CategoryTheory.Limits.cokernel.œÄ_of_zero","isProp":true,"docString":"The cokernel of a zero morphism is an isomorphism "},{"type":"‚àÄ {Œ± : Type u_1} [self : DivisionSemiring Œ±] (a : Œ±) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"DivisionSemiring.mul_inv_cancel","isProp":true,"docString":"Every nonzero element of a group with zero is invertible. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} (self : r ‚Ü™r s) {a : Œ±}\n  {b : Œ±}, (s (‚Üë(RelEmbedding.toEmbedding self) a) (‚Üë(RelEmbedding.toEmbedding self) b) : Prop) ‚Üî (r a b : Prop)","name":"RelEmbedding.map_rel_iff'","isProp":true,"docString":"Elements are related iff they are related after apply a `RelEmbedding` "},{"type":"‚àÄ {C : Type u} [ùíû : CategoryTheory.Category C] [self : CategoryTheory.MonoidalCategory C] {X : C} {Y : C} (f : X ‚ü∂ Y),\n  (f ‚äó ùüô CategoryTheory.MonoidalCategory.tensorUnit') ‚â´ CategoryTheory.Iso.hom (œÅ_ Y) =\n    CategoryTheory.Iso.hom (œÅ_ X) ‚â´ f","name":"CategoryTheory.MonoidalCategory.rightUnitor_naturality","isProp":true,"docString":"Naturality of the right unitor: commutativity of `X ‚äó ùüô_C ‚ü∂ Y ‚äó ùüô_C ‚ü∂ Y` and `X ‚äó ùüô_C ‚ü∂ X ‚ü∂ Y`\n"},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] {Œπ : Type v} [inst_2 : Fintype Œπ] {M : (a : Œπ) ‚Üí Type w}\n  [inst_3 : (i : Œπ) ‚Üí AddCommGroup (M i)] [inst_4 : (i : Œπ) ‚Üí Module R (M i)] [inst_5 : ‚àÄ (i : Œπ), Module.Free R (M i)]\n  [inst_6 : ‚àÄ (i : Œπ), Module.Finite R (M i)],\n  FiniteDimensional.finrank R ((i : Œπ) ‚Üí M i) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ FiniteDimensional.finrank R (M i)","name":"FiniteDimensional.finrank_pi_fintype","isProp":true,"docString":"The finrank of a finite product is the sum of the finranks. "},{"type":"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ‚Üës], Nonempty { x : P // x ‚àà affineSpan k s }","name":"instNonemptySubtypeMemAffineSubspaceInstMembershipInstSetLikeAffineSubspaceAffineSpan","isProp":true,"docString":"The affine span of a nonempty set is nonempty. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroOneClass M‚ÇÄ], (0 = 1 : Prop) ‚Üî (Subsingleton M‚ÇÄ : Prop)","name":"subsingleton_iff_zero_eq_one","isProp":true,"docString":"In a monoid with zero, zero equals one if and only if all elements of that semiring\nare equal. "},{"type":"‚àÄ {Œ± : Type u_4} {M : Type u_1} {N : Type u_2} {P : Type u_3} [inst : Zero M] [inst_1 : CommMonoid N]\n  [inst_2 : CommMonoid P] (h : N ‚âÉ* P) (f : Œ± ‚Üí‚ÇÄ M) (g : (a : Œ±) ‚Üí (a : M) ‚Üí N),\n  ‚Üëh (Finsupp.prod f g) = Finsupp.prod f fun (a : Œ±) (b : M) ‚Ü¶ ‚Üëh (g a b)","name":"MulEquiv.map_finsupp_prod","isProp":true,"docString":"Deprecated, use `_root_.map_finsupp_prod` instead. "},{"type":"‚àÄ (n : ‚Ñï) [inst : NeZero n] [inst : Fintype (ZMod n)À£], Fintype.card (ZMod n)À£ = Nat.totient n","name":"ZMod.card_units_eq_totient","isProp":true,"docString":"Note this takes an explicit `Fintype ((ZMod n)À£)` argument to avoid trouble with instance\ndiamonds. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i) < Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (¬¨(Monovary (f ‚àò ‚ÜëœÉ) g : Prop) : Prop)","name":"Monovary.sum_comp_perm_smul_lt_sum_smul_iff","isProp":true,"docString":"**Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí SeminormedGroup (œÄ i)]\n  {x : (i : Œπ) ‚Üí œÄ i} {r : ‚Ñù} (hr : 0 ‚â§ r), (‚Äñx‚Äñ ‚â§ r : Prop) ‚Üî (‚àÄ (i : Œπ), ‚Äñx i‚Äñ ‚â§ r : Prop)","name":"pi_norm_le_iff_of_nonneg'","isProp":true,"docString":"The seminorm of an element in a product space is `‚â§ r` if and only if the norm of each\ncomponent is. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : AddGroup Œ±] [inst_2 : TopologicalAddGroup Œ±],\n  TopologicalAddGroup Œ±·µÉ·µí·µñ","name":"instTopologicalAddGroupAddOppositeInstTopologicalSpaceAddOppositeAddGroup","isProp":true,"docString":"If addition is continuous in `Œ±`, then it also is in `Œ±·µÉ·µí·µñ`."},{"type":"‚àÄ {Œ± : Type uu} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : DecidableRel r] [inst_1 : IsTotal Œ± r] [inst_2 : IsTrans Œ± r]\n  (l : List Œ±), List.Sorted r (List.insertionSort r l)","name":"List.sorted_insertionSort","isProp":true,"docString":"The list `List.insertionSort r l` is `List.Sorted` with respect to `r`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} (hx : x ‚àà closure s), Metric.infDist x s = 0","name":"Metric.infDist_zero_of_mem_closure","isProp":true,"docString":"If a point belongs to the closure of `s`, then its infimum distance to `s` equals zero.\nThe converse is true provided that `s` is nonempty, see `Metric.mem_closure_iff_infDist_zero`. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±]\n  [inst_3 : MulPosStrictMono Œ±] (ha : 1 < a) (hb : 1 ‚â§ b) (b0 : 0 < b), 1 < a * b","name":"Right.one_lt_mul_of_lt_of_le_of_pos","isProp":true,"docString":"Assumes right covariance. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±] {x : Œ±} {y : Œ±} (hx : 0 < x) (hy : 1 < y),\n  ‚àÉ (n : ‚Ñ§), x ‚àà Set.Ioc (y ^ n) (y ^ (n + 1))","name":"exists_mem_Ioc_zpow","isProp":true,"docString":"Every positive `x` is between two successive integer powers of\nanother `y` greater than one. This is the same as `exists_mem_Ico_zpow`,\nbut with ‚â§ and < the other way around. "},{"type":"‚àÄ {G : Type u} [inst : Group G] {A : Type v} [inst_1 : Monoid A] (œÜ : Abelianization G ‚Üí* A) (œà : Abelianization G ‚Üí* A)\n  (h : MonoidHom.comp œÜ Abelianization.of = MonoidHom.comp œà Abelianization.of), œÜ = œà","name":"Abelianization.hom_ext","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ (M : Type u_2) (Œ± : Type u_3) [inst : Monoid M] [inst_1 : MulAction M Œ±] {Œπ : Sort u_1} {P : (a : Œπ) ‚Üí Submonoid M},\n  MulAction.fixedPoints { x : M // x ‚àà sup·µ¢ P } Œ± =\n    Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ MulAction.fixedPoints { x : M // x ‚àà P i } Œ±","name":"fixedPoints_submonoid_sup·µ¢","isProp":true,"docString":"Fixed points of sup·µ¢ of submonoids is intersection "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] {p : (a : G‚ÇÄÀ£) ‚Üí Prop},\n  (‚àÉ (g : G‚ÇÄÀ£), p g : Prop) ‚Üî (‚àÉ (g : G‚ÇÄ), ‚àÉ (hg : g ‚â† 0), p (Units.mk0 g hg) : Prop)","name":"Units.exists0","isProp":true,"docString":"In a group with zero, an existential over a unit can be rewritten in terms of `Units.mk0`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] (a : Œ±) (i : Fin 1),\n  ‚Üë(Finset.orderEmbOfFin {a} ((Finset.card_singleton a=:Finset.card {a} = 1)=:Finset.card {a} = 1)) i = a","name":"Finset.orderEmbOfFin_singleton","isProp":true,"docString":"`orderEmbOfFin {a} h` sends any argument to `a`. "},{"type":"‚àÄ {Œ± : Type u} [self : StrictOrderedRing Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c + a ‚â§ c + b","name":"StrictOrderedRing.add_le_add_left","isProp":true,"docString":"Addition is monotone in a ordered additive commutative group. "},{"type":"‚àÄ {Œ± : Sort u} {a : Œ±} {b : Œ±} {c : Œ±} (h‚ÇÅ : a = b) (h‚ÇÇ : b ‚â† c), a ‚â† c","name":"Eq.trans_ne","isProp":true,"docString":"**Alias** of `ne_of_eq_of_ne`."},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : Set Œ±} {t : Set Œ±} (ht : IsAntichain r t) (h : minimals r s ‚äÜ t)\n  (hs : ‚àÄ ‚¶Éa : Œ±‚¶Ñ (a_1 : a ‚àà t), ‚àÉ (b : Œ±), (b ‚àà minimals r s : Prop) ‚àß (r a b : Prop)), minimals r s = t","name":"IsAntichain.max_minimals","isProp":true,"docString":"If `minimals r s` is included in but *shadows* the antichain `t`, then it is actually\nequal to `t`. "},{"type":"‚àÄ (R : Type u_4) {V : Type u_2} {P : Type u_3} [inst : Ring R] [inst_1 : Invertible 2] [inst_2 : AddCommGroup V]\n  [inst_3 : Module R V] [inst_4 : AddTorsor V P] (R' : Type u_1) [inst_5 : Ring R'] [inst_6 : Invertible 2]\n  [inst_7 : Module R' V] (x : P) (y : P), midpoint R x y = midpoint R' x y","name":"midpoint_unique","isProp":true,"docString":"`midpoint` does not depend on the ring `R`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b), Set.Ioi b ‚äÜ Set.Ioi a","name":"Set.Ioi_subset_Ioi","isProp":true,"docString":"If `a ‚â§ b`, then `(b, +‚àû) ‚äÜ (a, +‚àû)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Ioi_subset_Ioi_iff`. "},{"type":"‚àÄ {Œ± : Type u} [self : UniformSpace Œ±] (s : Set Œ±),\n  (IsOpen s : Prop) ‚Üî\n    (‚àÄ (x : Œ±) (a : x ‚àà s),\n        (setOf fun (p : Œ± √ó Œ±) ‚Ü¶ ‚àÄ (a : Prod.fst p = x), Prod.snd p ‚àà s) ‚àà\n          UniformSpace.Core.uniformity UniformSpace.toCore :\n      Prop)","name":"UniformSpace.isOpen_uniformity","isProp":true,"docString":"The uniformity agrees with the topology: a set `s` is open if and only if for `x ‚àà s`,\nthe set `{ p : Œ± √ó Œ± | p.1 = x ‚Üí p.2 ‚àà s }` belongs to `uniformity`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {s : (a : Œπ) ‚Üí Set Œ±},\n  Filter.limsup s Filter.cofinite = setOf fun (x : Œ±) ‚Ü¶ Set.Infinite (setOf fun (n : Œπ) ‚Ü¶ x ‚àà s n)","name":"Filter.cofinite.limsup_set_eq","isProp":true,"docString":"In other words, `limsup cofinite s` is the set of elements lying inside the family `s`\ninfinitely often. "},{"type":"‚àÄ {Œπ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : (a : Œπ) ‚Üí Set X}\n  (uo : ‚àÄ (i : Œπ), IsOpen (u i)) (uf : ‚àÄ (x : X), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ x ‚àà u i))\n  (uU : (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ u i) = Set.univ),\n  ‚àÉ (v : (a : Œπ) ‚Üí Set X),\n    (Set.union·µ¢ v = Set.univ : Prop) ‚àß ((‚àÄ (i : Œπ), IsClosed (v i) : Prop) ‚àß (‚àÄ (i : Œπ), v i ‚äÜ u i : Prop) : Prop)","name":"exists_union·µ¢_eq_closed_subset","isProp":true,"docString":"Shrinking lemma. A point-finite open cover of a closed subset of a normal space can be \"shrunk\"\nto a new closed cover so that each of the new closed sets is contained in the corresponding\noriginal open set. See also `exists_union·µ¢_eq_closure_subset` for a stronger statement. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid S] (p : Polynomial R)\n  {f : (a : ‚Ñï) ‚Üí (a : R) ‚Üí S} (h : ‚àÄ (n : ‚Ñï), f n 0 = 0) (n : ‚Ñï) (w : Polynomial.natDegree p < n),\n  Polynomial.sum p f = Finset.sum (Finset.range n) fun (a : ‚Ñï) ‚Ü¶ f a (Polynomial.coeff p a)","name":"Polynomial.sum_over_range'","isProp":true,"docString":"We can reexpress a sum over `p.support` as a sum over `range n`,\nfor any `n` satisfying `p.natDegree < n`.\n"},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Monoid R]\n  [inst_1 : Star A] [inst_2 : Star B] [inst_3 : NonUnitalNonAssocSemiring A] [inst_4 : NonUnitalNonAssocSemiring B]\n  [inst_5 : DistribMulAction R A] [inst_6 : DistribMulAction R B] [self : NonUnitalStarAlgHomClass F R A B] (f : F)\n  (r : A), ‚Üëf (star r) = star (‚Üëf r)","name":"NonUnitalStarAlgHomClass.map_star","isProp":true,"docString":"the maps preserve star "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (1 < a‚Åª¬π : Prop) ‚Üî (a < 1 : Prop)","name":"one_lt_inv'","isProp":true,"docString":"**Alias** of `Left.one_lt_inv_iff`."},{"type":"‚àÄ {n : ‚Ñ§} (a : Even n), Even (Int.natAbs n)","name":"Even.natAbs","isProp":true,"docString":"**Alias** of the reverse direction of `Int.natAbs_even`."},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : P) (b : P),\n  ‚Üë(Finset.weightedVSubOfPoint s (fun (x : Œπ) ‚Ü¶ p) b) w = (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) ‚Ä¢ (p -·µ• b)","name":"Finset.weightedVSubOfPoint_apply_const","isProp":true,"docString":"The value of `weightedVSubOfPoint`, where the given points are equal. "},{"type":"‚àÄ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]\n  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (self : A ‚âÉ‚Çê[R] B) (x : A) (y : A),\n  Equiv.toFun (AlgEquiv.toEquiv self) (x * y) =\n    Equiv.toFun (AlgEquiv.toEquiv self) x * Equiv.toFun (AlgEquiv.toEquiv self) y","name":"AlgEquiv.map_mul'","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {S : Type u_1} [inst : Semigroup S] {a : S} {b : S} {c : S} (hac : Commute a c) (hbc : Commute b c), Commute (a * b) c","name":"Commute.mul_left","isProp":true,"docString":"If both `a` and `b` commute with `c`, then their product commutes with `c`. "},{"type":"‚àÄ {Œπ : Type u_2} {E : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí MetricSpace (E i)]\n  [inst_1 : ‚àÄ (i : Œπ), CompleteSpace (E i)], CompleteSpace ((i : Œπ) √ó E i)","name":"Metric.Sigma.completeSpace","isProp":true,"docString":"A disjoint union of complete metric spaces is complete. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {x : Œ±} (h : s ‚äÜ t) (hs : Set.Nonempty s),\n  Metric.infDist x t ‚â§ Metric.infDist x s","name":"Metric.infDist_le_infDist_of_subset","isProp":true,"docString":"The minimal distance is monotonous with respect to inclusion "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {A : outParam (Set Œ±)} {Œ≤ : outParam (Type u_3)} [inst : AddCommMonoid Œ±]\n  [inst_1 : AddCommMonoid Œ≤] {n : ‚Ñï} [inst_2 : FunLike F Œ± fun (x : Œ±) ‚Ü¶ Œ≤] [self : AddFreimanHomClass F A Œ≤ n] (f : F)\n  {s : Multiset Œ±} {t : Multiset Œ±} (hsA : ‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà s), x ‚àà A) (htA : ‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà t), x ‚àà A)\n  (hs : ‚ÜëMultiset.card s = n) (ht : ‚ÜëMultiset.card t = n) (h : Multiset.sum s = Multiset.sum t),\n  Multiset.sum (Multiset.map (‚Üëf) s) = Multiset.sum (Multiset.map (‚Üëf) t)","name":"AddFreimanHomClass.map_sum_eq_map_sum'","isProp":true,"docString":"An additive `n`-Freiman homomorphism preserves sums of `n` elements. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {n : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroDivisors R] {B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R} (v : Basis n R M) (hO : LinearMap.IsOrtho·µ¢ B ‚Üëv)\n  (h : ‚àÄ (i : n), ¬¨(LinearMap.IsOrtho B (‚Üëv i) (‚Üëv i) : Prop)), LinearMap.SeparatingRight B","name":"LinearMap.IsOrtho·µ¢.separatingRight_iff_not_isOrtho_basis_self","isProp":true,"docString":"Given an orthogonal basis with respect to a bilinear form, the bilinear form is right-separating\nif the basis has no elements which are self-orthogonal. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {s : (a : Œπ) ‚Üí Set Œ±} (hs : IndexedPartition s) (x : IndexedPartition.Quotient hs),\n  IndexedPartition.proj hs (‚Üë(IndexedPartition.out hs) x) = x","name":"IndexedPartition.proj_out","isProp":true,"docString":"This lemma is analogous to `Quotient.out_eq'`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : ContinuousOn f s), Continuous (Set.restrict s f)","name":"ContinuousOn.restrict","isProp":true,"docString":"**Alias** of the forward direction of `continuousOn_iff_continuous_restrict`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : Preorder Œ≥]\n  {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±} {t : Set Œ≤} (h‚ÇÄ : ‚àÄ (b : Œ≤), Monotone (Function.swap f b))\n  (h‚ÇÅ : ‚àÄ (a : Œ±), Monotone (f a)) (a : BddAbove s) (a : BddAbove t), BddAbove (Set.image2 f s t)","name":"BddAbove.image2","isProp":true,"docString":"See also `Monotone.map_bddAbove`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (S : CategoryTheory.Sieve X)\n  (x : CategoryTheory.Equalizer.FirstObj P (CategoryTheory.Sieve.arrows S)),\n  (CategoryTheory.Presieve.FamilyOfElements.Compatible\n        (CategoryTheory.Iso.hom (CategoryTheory.Equalizer.firstObjEqFamily P (CategoryTheory.Sieve.arrows S)) x) :\n      Prop) ‚Üî\n    (CategoryTheory.Equalizer.Sieve.firstMap P S x = CategoryTheory.Equalizer.Sieve.secondMap P S x : Prop)","name":"CategoryTheory.Equalizer.Sieve.compatible_iff","isProp":true,"docString":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b),\n  Finset.Icc a b =\n    Finset.cons a (Finset.Ioc a b)\n      ((Finset.left_not_mem_Ioc=:¬¨(a ‚àà Finset.Ioc a b : Prop))=:¬¨(a ‚àà Finset.Ioc a b : Prop))","name":"Finset.Icc_eq_cons_Ioc","isProp":true,"docString":"`Finset.cons` version of `Finset.Ioc_insert_left`. "},{"type":"‚àÄ {E : Type u_1} [self : SeminormedCommGroup E] (x : E) (y : E), dist x y = ‚Äñx / y‚Äñ","name":"SeminormedCommGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : ConvexOn ùïú s f) {x : E} {y : E} {z : E} (hx : x ‚àà s) (hy : y ‚àà s)\n  (hz : z ‚àà segment ùïú x y), f z ‚â§ max (f x) (f y)","name":"ConvexOn.le_on_segment","isProp":true,"docString":"A convex function on a segment is upper-bounded by the max of its endpoints. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i : Œπ), Finset.centroid k {i} p = p i","name":"Finset.centroid_singleton","isProp":true,"docString":"The centroid of a single point. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {x : ùïú} {y : ùïú} {z : ùïú} (h : x < y),\n  (z ‚àà Set.Ico x y : Prop) ‚Üî\n    (‚àÉ (a : ùïú),\n        ‚àÉ (b : ùïú), (0 < a : Prop) ‚àß ((0 ‚â§ b : Prop) ‚àß ((a + b = 1 : Prop) ‚àß (a * x + b * y = z : Prop) : Prop) : Prop) :\n      Prop)","name":"Convex.mem_Ico","isProp":true,"docString":"A point is in an `Ico` iff it can be expressed as a semistrict convex combination of the\nendpoints. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R} {f : Polynomial R},\n  (f ‚àà Ideal.map Polynomial.C I : Prop) ‚Üî (‚àÄ (n : ‚Ñï), Polynomial.coeff f n ‚àà I : Prop)","name":"Ideal.mem_map_C_iff","isProp":true,"docString":"The push-forward of an ideal `I` of `R` to `R[X]` via inclusion\nis exactly the set of polynomials whose coefficients are in `I` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {t : Set Œ±}\n  (Hf : MonotoneOn f t) {a : Œ±} (Ha : IsGreatest t a), IsGreatest (f '' t) (f a)","name":"MonotoneOn.map_isGreatest","isProp":true,"docString":"A monotone map sends a greatest element of a set to a greatest element of its image. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_1} {Œ≥ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (f : (a : Œ±) ‚Üí C(Œ≤, Œ≥))\n  (h : Continuous (Function.uncurry fun (x : Œ±) (y : Œ≤) ‚Ü¶ ‚Üë(f x) y)), Continuous f","name":"ContinuousMap.continuous_of_continuous_uncurry","isProp":true,"docString":"To show continuity of a map `Œ± ‚Üí C(Œ≤, Œ≥)`, it suffices to show that its uncurried form\n`Œ± √ó Œ≤ ‚Üí Œ≥` is continuous. "},{"type":"‚àÄ {R : Type u_1} [inst : AddMonoid R] {a : R} (ua : IsAddUnit a), IsAddRegular a","name":"IsAddUnit.isAddRegular","isProp":true,"docString":"An additive unit in an additive monoid is add-regular."},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x : X} {y : X} (a : x ‚§≥ y), closure {y} ‚äÜ closure {x}","name":"Specializes.closure_subset","isProp":true,"docString":"**Alias** of the forward direction of `specializes_iff_closure_subset`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (s : Set Œ≤)\n  (h : OpenEmbedding f), OpenEmbedding (Set.restrictPreimage s f)","name":"OpenEmbedding.restrictPreimage","isProp":true,"docString":"**Alias** of `Set.restrictPreimage_openEmbedding`."},{"type":"‚àÄ {Œ± : Type u_1} {E' : Type u_2} {F' : Type u_3} [inst : SeminormedAddCommGroup E'] [inst_1 : SeminormedAddCommGroup F']\n  {f' : (a : Œ±) ‚Üí E'} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f' =o[l] g'),\n  (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) =o[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ","name":"Asymptotics.IsLittleO.norm_norm","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_norm_norm`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {R : D ‚•§ C} (h : L ‚ä£ R) [inst_2 : CategoryTheory.Full R] [inst_3 : CategoryTheory.Faithful R],\n  CategoryTheory.IsIso (CategoryTheory.Adjunction.counit h)","name":"CategoryTheory.counit_isIso_of_R_fully_faithful","isProp":true,"docString":"If the right adjoint is fully faithful, then the counit is an isomorphism.\n\nSee <https://stacks.math.columbia.edu/tag/07RB> (we only prove the forward direction!)\n"},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M‚ÇÇ]\n  [inst_3 : Module R M] [inst_4 : Module R M‚ÇÇ] (f : M ‚âÉ‚Çó[R] M‚ÇÇ),\n  FiniteDimensional.finrank R M = FiniteDimensional.finrank R M‚ÇÇ","name":"LinearEquiv.finrank_eq","isProp":true,"docString":"The dimension of a finite dimensional space is preserved under linear equivalence. "},{"type":"‚àÄ {Œ± : Type u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {a : Œ±} {b : Œ±} (l : List Œ±) (hl‚ÇÅ : List.Chain r a l)\n  (hl‚ÇÇ : List.getLast (a :: l) ((List.cons_ne_nil a l=:a :: l ‚â† [])=:a :: l ‚â† []) = b), Relation.ReflTransGen r a b","name":"List.relationReflTransGen_of_exists_chain","isProp":true,"docString":"If there is an `r`-chain starting from `a` and ending at `b`, then `a` and `b` are related by the\nreflexive transitive closure of `r`. The converse of `exists_chain_of_relationReflTransGen`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeInf Œ±] {a : Œ±} {b : Œ±} (a_1 : b ‚â§ a), a ‚äì b = b","name":"inf_of_le_right","isProp":true,"docString":"**Alias** of the reverse direction of `inf_eq_right`."},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] (self : AbstractCompletion Œ±), UniformInducing (AbstractCompletion.coe self)","name":"AbstractCompletion.uniformInducing","isProp":true,"docString":"The map into the completion is uniform-inducing. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V‚ÇÇ : Type v'}\n  [inst_3 : AddCommGroup V‚ÇÇ] [inst_4 : Module K V‚ÇÇ] {f : V ‚Üí‚Çó[K] V‚ÇÇ} (hf : Function.Injective ‚Üëf),\n  FiniteDimensional.finrank K { x : V‚ÇÇ // x ‚àà LinearMap.range f } = FiniteDimensional.finrank K V","name":"LinearMap.finrank_range_of_inj","isProp":true,"docString":"The dimensions of the domain and range of an injective linear map are equal. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a ‚â§ b * c), b‚Åª¬π * a ‚â§ c","name":"inv_mul_le_of_le_mul","isProp":true,"docString":"**Alias** of the reverse direction of `inv_mul_le_iff_le_mul`."},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} (self : SimpleGraph.IsTree G), SimpleGraph.Connected G","name":"SimpleGraph.IsTree.isConnected","isProp":true,"docString":"Graph is connected. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} [inst : CompleteLattice Œ±] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  (a : CompleteLattice.Independent (f ‚àò Subtype.val)), Finset.SupIndep s f","name":"CompleteLattice.Independent.supIndep","isProp":true,"docString":"**Alias** of the forward direction of `CompleteLattice.independent_iff_supIndep`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Nonempty Œ±] (f : Œ± ‚Ü™ Œ≤) (h : Nat.card Œ± = 0), Nat.card Œ≤ = 0","name":"Finite.card_eq_zero_of_embedding","isProp":true,"docString":"NB: `Nat.card` is defined to be `0` for infinite types. "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedSemiring Œ±], 0 ‚â§ 1","name":"OrderedSemiring.zero_le_one","isProp":true,"docString":"`0 ‚â§ 1` in any ordered semiring. "},{"type":"‚àÄ {M : Type u} [self : AddRightCancelMonoid M] (a : M), 0 + a = a","name":"AddRightCancelMonoid.zero_add","isProp":true,"docString":"Zero is a left neutral element for addition "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  [self : CategoryTheory.EssSurj F] (Y : D), Y ‚àà CategoryTheory.Functor.essImage F","name":"CategoryTheory.EssSurj.mem_essImage","isProp":true,"docString":"All the objects of the target category are in the essential image. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : Preorder Œ≤] {a : Œ±} {f : (a : Œ±) ‚Üí Œ≤}\n  (h‚ÇÅ : StrictAntiOn f (Set.Iic a)) (h‚ÇÇ : StrictAntiOn f (Set.Ici a)), StrictAnti f","name":"StrictAntiOn.Iic_union_Ici","isProp":true,"docString":"If `f` is strictly antitone both on `(-‚àû, a]` and `[a, ‚àû)`, then it is strictly antitone on the\nwhole line. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [self : Module R M] (r : R) (s : R) (x : M),\n  (r + s) ‚Ä¢ x = r ‚Ä¢ x + s ‚Ä¢ x","name":"Module.add_smul","isProp":true,"docString":"Scalar multiplication distributes over addition from the right. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {x : Œ± √ó Bool}, (FreeAddGroup.Red [x] L‚ÇÅ : Prop) ‚Üî (L‚ÇÅ = [x] : Prop)","name":"FreeAddGroup.Red.singleton_iff","isProp":true,"docString":"A letter only reduces to itself."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] {A : Finset Œ±} (hA : Finset.Nonempty A) (B : Finset Œ±)\n  (m : ‚Ñï) (n : ‚Ñï),\n  ‚Üë(Finset.card (B ^ m / B ^ n)) ‚â§ (‚Üë(Finset.card (A * B)) / ‚Üë(Finset.card A)) ^ (m + n) * ‚Üë(Finset.card A)","name":"Finset.card_pow_div_pow_le","isProp":true,"docString":"The **Pl√ºnnecke-Ruzsa inequality**. Multiplication version. Note that this is genuinely harder\nthan the division version because we cannot use a double counting argument. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≤' : Type u_5} {Œ≥ : Type u_2} {Œ¥ : Type u_1} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±}\n  {t : Set Œ≤} {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ¥} {g' : (a : Œ≤) ‚Üí Œ≤'}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' a (g' b)), g '' Set.image2 f s t = Set.image2 f' s (g' '' t)","name":"Set.image_image2_distrib_right","isProp":true,"docString":"Symmetric statement to `Set.image_image2_right_comm`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  {Œ≥ : Type u_1} {F : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Œ±} {s : Set Œ≥},\n  (UniformCauchySeqOn F Filter.atTop s : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n        ‚àÉ (N : Œ≤), ‚àÄ (m : Œ≤) (a : m ‚â• N) (n : Œ≤) (a : n ‚â• N) (x : Œ≥) (a : x ‚àà s), dist (F m x) (F n x) < Œµ :\n      Prop)","name":"Metric.uniformCauchySeqOn_iff","isProp":true,"docString":"In a pseudometric space, unifom Cauchy sequences are characterized by the fact that, eventually,\nthe distance between all its elements is uniformly, arbitrarily small "},{"type":"‚àÄ {ùïÜ : Type u_1} {Œ± : Type u_2} [inst : Preorder ùïÜ] [inst_1 : Preorder Œ±] [self : GradeMaxOrder ùïÜ Œ±] ‚¶Éa : Œ±‚¶Ñ\n  (a_1 : IsMax a), IsMax (GradeOrder.grade a)","name":"GradeMaxOrder.is_max_grade","isProp":true,"docString":"Maximal elements have maximal grades. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NormedLatticeAddCommGroup Œ±], ContinuousInf Œ±","name":"NormedLatticeAddCommGroup.continuousInf","isProp":true,"docString":"Let `Œ±` be a normed lattice ordered group. Then the infimum is jointly continuous.\n"},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (q : ‚Ñö) (r : ‚Ñö), padicNorm p (q / r) = padicNorm p q / padicNorm p r","name":"padicNorm.div","isProp":true,"docString":"The `p`-adic norm respects division. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R} {n : ‚Ñï} (r : R),\n  p * Polynomial.X ^ n * ‚ÜëPolynomial.C r = p * ‚ÜëPolynomial.C r * Polynomial.X ^ n","name":"Polynomial.X_pow_mul_assoc_C","isProp":true,"docString":"Prefer putting constants to the left of `X ^ n`.\n\nThis lemma is the loop-avoiding `simp` version of `X_pow_mul_assoc`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} [inst_1 : DiscreteTopology ‚Üës] {x : Œ±} (hx : x ‚àà s),\n  nhdsWithin x s = pure x","name":"nhdsWithin_of_mem_discrete","isProp":true,"docString":"The neighbourhoods filter of `x` within `s`, under the discrete topology, is equal to\nthe pure `x` filter (which is the principal filter at the singleton `{x}`.) "},{"type":"‚àÄ {I : Type w‚ÇÄ} {C : (a : I) ‚Üí Type u‚ÇÅ} [inst : (i : I) ‚Üí CategoryTheory.Category (C i)] {A : Type u‚ÇÅ}\n  [inst_1 : CategoryTheory.Category A] (f : A ‚•§ ((i : I) ‚Üí C i)) (f' : A ‚•§ ((i : I) ‚Üí C i))\n  (h : ‚àÄ (i : I), f ‚ãô CategoryTheory.Pi.eval C i = f' ‚ãô CategoryTheory.Pi.eval C i), f = f'","name":"CategoryTheory.Functor.pi_ext","isProp":true,"docString":"Two functors to a product category are equal iff they agree on every coordinate. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : D ‚•§ C} (self : CategoryTheory.Adjunction.CoreHomEquiv F G) {X : C} {Y : D} {Y' : D}\n  (f : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X ‚ü∂ Y) (g : Y ‚ü∂ Y'),\n  ‚Üë(CategoryTheory.Adjunction.CoreHomEquiv.homEquiv self X Y') (f ‚â´ g) =\n    ‚Üë(CategoryTheory.Adjunction.CoreHomEquiv.homEquiv self X Y) f ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) g","name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_right","isProp":true,"docString":"The property that describes how `homEquiv` transforms compositions `F X ‚ü∂ Y ‚ü∂ Y'` "},{"type":"‚àÄ {m : Type u_2} {n : Type u_3} (R : Type u_1) [inst : CommRing R] [inst_1 : Fintype m] [inst_2 : DecidableEq m]\n  [inst_3 : Fintype n] [inst_4 : DecidableEq n] (e : m ‚âÉ n) (M : Matrix m m R),\n  Matrix.det (‚Üë(Matrix.reindexLinearEquiv R R e e) M) = Matrix.det M","name":"Matrix.det_reindexLinearEquiv_self","isProp":true,"docString":"Reindexing both indices along the same equivalence preserves the determinant.\n\nFor the `simp` version of this lemma, see `det_submatrix_equiv_self`.\n"},{"type":"‚àÄ {M : Type u_1} {R : Type u_2} [inst : Monoid M] [inst_1 : NonUnitalNonAssocRing R] [inst_2 : DistribMulAction M R]\n  (k : M) (h : ‚àÄ (x : R) (a : k ‚Ä¢ x = 0), x = 0) {a : R} {b : R} (h' : k ‚Ä¢ a = k ‚Ä¢ b), a = b","name":"smul_cancel_of_non_zero_divisor","isProp":true,"docString":"`smul` by a `k : M` over a ring is injective, if `k` is not a zero divisor.\nThe general theory of such `k` is elaborated by `IsSMulRegular`.\nThe typeclass that restricts all terms of `M` to have this property is `NoZeroSMulDivisors`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  (hF : CategoryTheory.IsEquivalence F), CategoryTheory.IsEquivalence.ofIso (CategoryTheory.Iso.refl F) hF = hF","name":"CategoryTheory.IsEquivalence.ofIso_refl","isProp":true,"docString":"Compatibility of `ofIso` with identity isomorphisms of functors "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NormedField Œ±] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E] [inst_2 : NormedSpace Œ± E]\n  {c : Œ±} (hc : 1 < ‚Äñc‚Äñ) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) {x : E} (hx : ‚Äñx‚Äñ ‚â† 0),\n  ‚àÉ (d : Œ±),\n    (d ‚â† 0 : Prop) ‚àß\n      ((‚Äñd ‚Ä¢ x‚Äñ < Œµ : Prop) ‚àß ((Œµ / ‚Äñc‚Äñ ‚â§ ‚Äñd ‚Ä¢ x‚Äñ : Prop) ‚àß (‚Äñd‚Äñ‚Åª¬π ‚â§ Œµ‚Åª¬π * ‚Äñc‚Äñ * ‚Äñx‚Äñ : Prop) : Prop) : Prop)","name":"rescale_to_shell_semi_normed","isProp":true,"docString":"If there is a scalar `c` with `‚Äñc‚Äñ>1`, then any element with nonzero norm can be\nmoved by scalar multiplication to any shell of width `‚Äñc‚Äñ`. Also recap information on the norm of\nthe rescaling element that shows up in applications. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤]\n  (f : (a : Œ±) ‚Üí Œ≤) {b : M} [inst_3 : LinearOrderedCommSemiring M] [inst_4 : Nonempty Œ≤]\n  (hb : Fintype.card Œ≤ ‚Ä¢ b ‚â§ ‚Üë(Fintype.card Œ±)),\n  ‚àÉ (y : Œ≤), b ‚â§ ‚Üë(Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ))","name":"Fintype.exists_le_card_fiber_of_nsmul_le_card","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function `f`\nbetween finite types `Œ±` and `Œ≤` and a number `b` such that `card Œ≤ ‚Ä¢ b ‚â§ card Œ±`, there exists an\nelement `y : Œ≤` such that its preimage has at least `b` elements.\nSee also `Fintype.exists_lt_card_fiber_of_nsmul_lt_card` for a stronger statement. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedAddCommGroup Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"LinearOrderedAddCommGroup.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a < b * c), b‚Åª¬π * a < c","name":"inv_mul_lt_of_lt_mul","isProp":true,"docString":"**Alias** of the reverse direction of `inv_mul_lt_iff_lt_mul`."},{"type":"‚àÄ {Œ± : Sort u_1} [inst : Finite Œ±] {p : (a : Œ±) ‚Üí Prop}, Finite { x : Œ± // p x }","name":"Subtype.finite","isProp":true,"docString":"This instance also provides `[Finite s]` for `s : Set Œ±`. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} (a : Set.Subsingleton s), ¬¨(Set.Nontrivial s : Prop)","name":"Set.Subsingleton.not_nontrivial","isProp":true,"docString":"**Alias** of the reverse direction of `Set.not_nontrivial_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Bornology Œ±] {s : Set Œ±} (a : Bornology.IsBounded s), BoundedSpace ‚Üës","name":"Bornology.IsBounded.boundedSpace_val","isProp":true,"docString":"**Alias** of the reverse direction of `boundedSpace_val_set_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a : Œ±} {b : Œ±}, (a ‚à£ b + a : Prop) ‚Üî (a ‚à£ b : Prop)","name":"dvd_add_self_right","isProp":true,"docString":"An element a divides the sum b + a if and only if a divides b."},{"type":"‚àÄ {Œ± : Type u} [self : OrderedSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : a ‚â§ b) (a_2 : 0 ‚â§ c), c * a ‚â§ c * b","name":"OrderedSemiring.mul_le_mul_of_nonneg_left","isProp":true,"docString":"In an ordered semiring, we can multiply an inequality `a ‚â§ b` on the left\nby a non-negative element `0 ‚â§ c` to obtain `c * a ‚â§ c * b`. "},{"type":"‚àÄ {Œ¥ : Type u_1} {œÄ : (a : Œ¥) ‚Üí Type u_2} [inst : (a : Œ¥) ‚Üí MeasurableSpace (œÄ a)] (f : (a : Œ¥) ‚Üí œÄ a) {a : Œ¥}\n  [inst_1 : DecidableEq Œ¥], Measurable (Function.update f a)","name":"measurable_update","isProp":true,"docString":"The function `update f a : œÄ a ‚Üí Œ† a, œÄ a` is always measurable.\nThis doesn't require `f` to be measurable.\nThis should not be confused with the statement that `update f a x` is measurable. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] [inst_1 : Archimedean Œ±] [inst_2 : LinearOrderedField Œ≤],\n  Subsingleton (Œ± ‚âÉ+*o Œ≤)","name":"OrderRingIso.subsingleton_left","isProp":true,"docString":"There is at most one ordered ring isomorphism between an archimedean linear ordered field and a\nlinear ordered field. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [self : IsWeakUpperModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚äì b ‚ãñ a)\n  (a_2 : a ‚äì b ‚ãñ b), a ‚ãñ a ‚äî b","name":"IsWeakUpperModularLattice.covby_sup_of_inf_covby_covby","isProp":true,"docString":"`a ‚äî b` covers `a` and `b` if `a` and `b` both cover `a ‚äì b`. "},{"type":"‚àÄ {A : Type u_1} [inst : DivisionRing A] [inst_1 : TopologicalSpace A] [inst_2 : ContinuousMul A] [inst_3 : CharZero A],\n  ContinuousConstSMul ‚Ñö A","name":"DivisionRing.continuousConstSMul_rat","isProp":true,"docString":"The action induced by `algebraRat` is continuous. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} {M : Type u_3} {Œπ : Type u_4} [inst : CommSemiring R] [inst_1 : Semiring S]\n  [inst_2 : AddCommMonoid M] [inst_3 : Algebra R S] [inst_4 : Module R M] [inst_5 : Module S M]\n  [inst_6 : IsScalarTower R S M] (hinj : Function.Injective ‚Üë(algebraMap R S)) {v : (a : Œπ) ‚Üí M}\n  (li : LinearIndependent S v), LinearIndependent R v","name":"LinearIndependent.restrict_scalars_algebras","isProp":true,"docString":"A set of linearly independent vectors in a module `M` over a semiring `S` is also linearly\nindependent over a subring `R` of `K`. "},{"type":"‚àÄ {K : Type u} {V : Type v} {V' : Type v'} {V'' : Type v''} [inst : Ring K] [inst_1 : AddCommGroup V]\n  [inst_2 : Module K V] [inst_3 : AddCommGroup V'] [inst_4 : Module K V'] [inst_5 : AddCommGroup V'']\n  [inst_6 : Module K V''] (g : V ‚Üí‚Çó[K] V') (f : V' ‚Üí‚Çó[K] V''),\n  Cardinal.lift (LinearMap.rank (LinearMap.comp f g)) ‚â§\n    min (Cardinal.lift (LinearMap.rank f)) (Cardinal.lift (LinearMap.rank g))","name":"LinearMap.lift_rank_comp_le","isProp":true,"docString":"The rank of the composition of two maps is less than the minimum of their ranks. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : b < a), ¬¨(IsMin a : Prop)","name":"LT.lt.not_isMin","isProp":true,"docString":"**Alias** of `not_isMin_of_lt`."},{"type":"‚àÄ {n : ‚Ñï} (p : Fin (n + 1)) (i : Fin n), (‚Üë(Fin.succAbove p) i < p : Prop) ‚Üî (‚ÜëFin.castSucc i < p : Prop)","name":"Fin.succAbove_lt_iff","isProp":true,"docString":"Embedding `i : Fin n` into `Fin (n + 1)` using a pivot `p` that is greater\nresults in a value that is less than `p`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I], I ‚â† ‚ä§","name":"Ideal.IsPrime.ne_top'","isProp":true,"docString":"The prime ideal is not the entire ring. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Add Œ±] [inst_1 : Add Œ≤] [inst_2 : LE Œ≤]\n  [self : SubadditiveHomClass F Œ± Œ≤] (f : F) (a : Œ±) (b : Œ±), ‚Üëf (a + b) ‚â§ ‚Üëf a + ‚Üëf b","name":"SubadditiveHomClass.map_add_le_add","isProp":true,"docString":"the image of a sum is less or equal than the sum of the images. "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {N : outParam (Type u_3)} [inst : Zero M] [inst_1 : Zero N]\n  [self : ZeroHomClass F M N] (f : F), ‚Üëf 0 = 0","name":"ZeroHomClass.map_zero","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ {Œ± : Type u_1} {G : Type u_2} [inst : CompleteLattice Œ±] [inst_1 : Group G] (f‚ÇÅ : G ‚Üí* Œ± ‚âÉo Œ±) (f‚ÇÇ : G ‚Üí* Œ± ‚âÉo Œ±)\n  (g : G), Function.Semiconj (fun (x : Œ±) ‚Ü¶ sup·µ¢ fun (g' : G) ‚Ü¶ ‚Üë(‚Üëf‚ÇÅ g')‚Åª¬π (‚Üë(‚Üëf‚ÇÇ g') x)) ‚Üë(‚Üëf‚ÇÇ g) ‚Üë(‚Üëf‚ÇÅ g)","name":"Function.sup‚Çõ_div_semiconj","isProp":true,"docString":"Consider two actions `f‚ÇÅ f‚ÇÇ : G ‚Üí Œ± ‚Üí Œ±` of a group on a complete lattice by order\nisomorphisms. Then the map `x ‚Ü¶ ‚®Ü g : G, (f‚ÇÅ g)‚Åª¬π (f‚ÇÇ g x)` semiconjugates each `f‚ÇÅ g'` to `f‚ÇÇ g'`.\n\nThis is a version of Proposition 5.4 from [√âtienne Ghys, Groupes d'hom√©omorphismes du cercle et\ncohomologie born√©e][ghys87:groupes]. "},{"type":"‚àÄ {Œ± : Sort u} {s : Setoid Œ±} {a : Œ±} {b : Œ±} (a_1 : a ‚âà b), Quotient.mk s a = Quotient.mk s b","name":"Quotient.sound","isProp":true,"docString":"The analogue of `Quot.sound`: If `a` and `b` are related by the equivalence relation,\nthen they have equal equivalence classes.\n"},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {f : Filter Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (a : ‚àÉ (b : Œ±), ‚àÄ (x : Œ≤), r (u x) b), Filter.IsBoundedUnder r f u","name":"Filter.isBoundedUnder_of","isProp":true,"docString":"A bounded function `u` is in particular eventually bounded. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (h : 0 < r * (b - a)),\n  (f (‚Üë(AffineMap.lineMap a b) r) ‚â§ ‚Üë(AffineMap.lineMap (f a) (f b)) r : Prop) ‚Üî\n    (slope f a (‚Üë(AffineMap.lineMap a b) r) ‚â§ slope f a b : Prop)","name":"map_le_lineMap_iff_slope_le_slope_left","isProp":true,"docString":"Given `c = lineMap a b r`, `a < c`, the point `(c, f c)` is non-strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a c ‚â§ slope f a b`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedSemifield Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atTop),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atTop : Prop) ‚Üî (0 < r : Prop)","name":"Filter.tendsto_const_mul_atTop_iff_pos","isProp":true,"docString":"If `f` tends to infinity along a nontrivial filter `l`, then `Œª x, r * f x` tends to infinity\nif and only if `0 < r. `"},{"type":"‚àÄ (k : Type u_2) (V : Type u_1) (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], AffineSubspace.direction ‚ä• = ‚ä•","name":"AffineSubspace.direction_bot","isProp":true,"docString":"The direction of `‚ä•` is the submodule `‚ä•`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [self : IsLocalization M S] (y : { x : R // x ‚àà M }), IsUnit (‚Üë(algebraMap R S) ‚Üëy)","name":"IsLocalization.map_units'","isProp":true,"docString":"Everything in the image of `algebraMap` is a unit "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {M : Type u_2} {v : (a : Œπ) ‚Üí M} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] {hli : LinearIndependent R v} {hsp : ‚ä§ ‚â§ Submodule.span R (Set.range v)} (i : Œπ),\n  ‚Üë(Basis.coord (Basis.mk hli hsp) i) (v i) = 1","name":"Basis.mk_coord_apply_eq","isProp":true,"docString":"Given a basis, the `i`th element of the dual basis evaluates to 1 on the `i`th element of the\nbasis. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {K : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category K] {C : Type u}\n  [inst_2 : CategoryTheory.Category C] {F : J ‚•§ C} [inst_3 : CategoryTheory.Limits.HasLimit F] {E : K ‚•§ J}\n  [inst_4 : CategoryTheory.Limits.HasLimit (E ‚ãô F)] (s : CategoryTheory.Limits.LimitCone (E ‚ãô F))\n  (t : CategoryTheory.Limits.LimitCone F),\n  CategoryTheory.Limits.limit.pre F E =\n    CategoryTheory.Iso.hom (CategoryTheory.Limits.limit.isoLimitCone t) ‚â´\n      CategoryTheory.Limits.IsLimit.lift (CategoryTheory.Limits.LimitCone.isLimit s)\n          (CategoryTheory.Limits.Cone.whisker E (CategoryTheory.Limits.LimitCone.cone t)) ‚â´\n        CategoryTheory.Iso.inv (CategoryTheory.Limits.limit.isoLimitCone s)","name":"CategoryTheory.Limits.limit.pre_eq","isProp":true,"docString":"-\nIf we have particular limit cones available for `E ‚ãô F` and for `F`,\nwe obtain a formula for `limit.pre F E`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} (hc : c ‚â† 0) (hd : d ‚â† 0)\n  (a_1 : (a * d - b * c) / (c * d) ‚â§ 0), a / c ‚â§ b / d","name":"div_le_div_of_mul_sub_mul_div_nonpos","isProp":true,"docString":"**Alias** of the forward direction of `mul_sub_mul_div_mul_nonpos_iff`."},{"type":"‚àÄ {R : Type u} [inst : Ring R] (s : Subring R), Subring.closure ‚Üës = s","name":"Subring.closure_eq","isProp":true,"docString":"Closure of a subring `S` equals `S`. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : AddGroup G] [inst_1 : SubtractionMonoid H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F) (a : G) (b : G), ‚Üëf (a + -b) = ‚Üëf a + -‚Üëf b","name":"map_add_neg","isProp":true,"docString":"Additive group homomorphisms preserve subtraction."},{"type":"‚àÄ {Œ± : Type u_1} {G : Type u_2} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : Group G] (f‚ÇÅ : G ‚Üí* Œ± ‚âÉo Œ±)\n  (f‚ÇÇ : G ‚Üí* Œ± ‚âÉo Œ±) (hbdd : ‚àÄ (x : Œ±), BddAbove (Set.range fun (g : G) ‚Ü¶ ‚Üë(‚Üëf‚ÇÅ g)‚Åª¬π (‚Üë(‚Üëf‚ÇÇ g) x))) (g : G),\n  Function.Semiconj (fun (x : Œ±) ‚Ü¶ sup·µ¢ fun (g' : G) ‚Ü¶ ‚Üë(‚Üëf‚ÇÅ g')‚Åª¬π (‚Üë(‚Üëf‚ÇÇ g') x)) ‚Üë(‚Üëf‚ÇÇ g) ‚Üë(‚Üëf‚ÇÅ g)","name":"Function.csup‚Çõ_div_semiconj","isProp":true,"docString":"Consider two actions `f‚ÇÅ f‚ÇÇ : G ‚Üí Œ± ‚Üí Œ±` of a group on a conditionally complete lattice by order\nisomorphisms. Suppose that each set $s(x)=\\{f_1(g)^{-1} (f_2(g)(x)) | g \\in G\\}$ is bounded above.\nThen the map `x ‚Ü¶ sup‚Çõ s(x)` semiconjugates each `f‚ÇÅ g'` to `f‚ÇÇ g'`.\n\nThis is a version of Proposition 5.4 from [√âtienne Ghys, Groupes d'hom√©omorphismes du cercle et\ncohomologie born√©e][ghys87:groupes]. "},{"type":"‚àÄ {Œπ : Type u_2} {E : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí MetricSpace (E i)] (i : Œπ), Isometry (Sigma.mk i)","name":"Metric.Sigma.isometry_mk","isProp":true,"docString":"The injection of a space in a disjoint union is an isometry "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {s : Set M} {a : M} (hs : IsAddSubmonoid s) (h : a ‚àà s), multiples a ‚äÜ s","name":"IsAddSubmonoid.multiples_subset","isProp":true,"docString":"The set of natural number multiples of an element of an `AddSubmonoid` is a subset of\nthe `AddSubmonoid`."},{"type":"‚àÄ (Œ± : Type u_1) [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.SeparableSpace Œ±] [inst_2 : PartialOrder Œ±],\n  ‚àÉ (s : Set Œ±),\n    (Set.Countable s : Prop) ‚àß\n      ((Dense s : Prop) ‚àß ((‚àÄ (x : Œ±) (a : IsBot x), x ‚àà s : Prop) ‚àß (‚àÄ (x : Œ±) (a : IsTop x), x ‚àà s : Prop) : Prop) :\n        Prop)","name":"exists_countable_dense_bot_top","isProp":true,"docString":"If `Œ±` is a separable topological space with a partial order, then there exists a countable\ndense set `s : Set Œ±` that contains those of both bottom and top elements of `Œ±` that actually\nexist. For a dense set containing neither bot nor top elements, see\n`exists_countable_dense_no_bot_top`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [wo : IsWellOrder Œ± r] (s : (a : Œ≤) ‚Üí Set Œ±)\n  (h‚ÇÅ : Set.Unbounded r (Set.union·µ¢ fun (x : Œ≤) ‚Ü¶ s x)) (h‚ÇÇ : Cardinal.mk Œ≤ < StrictOrder.cof r),\n  ‚àÉ (x : Œ≤), Set.Unbounded r (s x)","name":"Ordinal.unbounded_of_unbounded_union·µ¢","isProp":true,"docString":"If the union of s is unbounded and s is smaller than the cofinality,\nthen s has an unbounded member "},{"type":"‚àÄ {œÑ : Type u_1} {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ≤] (f : Filter œÑ) (œï : (a : œÑ) ‚Üí (a : Œ±) ‚Üí Œ≤)\n  (s : Set Œ±) [inst_1 : Filter.NeBot f] {c : Set Œ≤} (hc‚ÇÅ : IsCompact c)\n  (hc‚ÇÇ : ‚àÉ (v : Set œÑ), (v ‚àà f : Prop) ‚àß (closure (Set.image2 œï v s) ‚äÜ c : Prop)) (hs : Set.Nonempty s),\n  Set.Nonempty (omegaLimit f œï s)","name":"nonempty_omegaLimit_of_isCompact_absorbing","isProp":true,"docString":"The œâ-limit of a nonempty set w.r.t. a nontrivial filter is nonempty. "},{"type":"‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (x : Œ±), ‚ä§ ‚â§ x ‚äî x·∂ú","name":"BooleanAlgebra.top_le_sup_compl","isProp":true,"docString":"The supremum of `x` and `x·∂ú` is at least `‚ä§` "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {r : (a : M) ‚Üí (a : M) ‚Üí Prop} {s : (a : M) ‚Üí (a : M) ‚Üí Prop}\n  (h : ‚àÄ (x : M) (y : M) (a : r x y), s x y), conGen r ‚â§ conGen s","name":"Con.conGen_mono","isProp":true,"docString":"Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation\ncontaining `s` contains the smallest congruence relation containing `r`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (a‚Åª¬π ‚â§ 1 : Prop) ‚Üî (1 ‚â§ a : Prop)","name":"Right.inv_le_one_iff","isProp":true,"docString":"Uses `right` co(ntra)variant. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : GroupWithZero R] [inst_1 : AddMonoid M] [inst_2 : DistribMulAction R M],\n  NoZeroSMulDivisors R M","name":"GroupWithZero.toNoZeroSMulDivisors","isProp":true,"docString":"This instance applies to `DivisionSemiring`s, in particular `NNReal` and `NNRat`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (hp‚ÇÇp‚ÇÉ : p‚ÇÇ ‚â† p‚ÇÉ)\n  (hp‚ÇÅ : ¬¨(p‚ÇÅ ‚àà s : Prop)) (hp‚ÇÇ : p‚ÇÇ ‚àà s) (hp‚ÇÉ : p‚ÇÉ ‚àà s), AffineIndependent k ![p‚ÇÅ, p‚ÇÇ, p‚ÇÉ]","name":"affineIndependent_of_ne_of_not_mem_of_mem_of_mem","isProp":true,"docString":"If distinct points `p‚ÇÇ` and `p‚ÇÉ` lie in `s` but `p‚ÇÅ` does not, the three points are affinely\nindependent. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X},\n  (IsSeqClosed M : Prop) ‚Üî (IsClosed M : Prop)","name":"isSeqClosed_iff_isClosed","isProp":true,"docString":"In a sequential space, a set is closed iff it's sequentially closed. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddGroupHom f),\n  (Function.Injective f : Prop) ‚Üî (‚àÄ (a : Œ±) (a_1 : f a = 0), a = 0 : Prop)","name":"IsAddGroupHom.injective_iff","isProp":true,"docString":"An additive group homomorphism is injective if its kernel is trivial."},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] {p : (a : Œ±) ‚Üí Prop} {s : Finset { x : Œ± // p x }}\n  {f : (a : { x : Œ± // p x }) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} (h : ‚àÄ (x : { x : Œ± // p x }) (a : x ‚àà s), g ‚Üëx = f x),\n  (Finset.prod (Finset.map (Function.Embedding.subtype fun (x : Œ±) ‚Ü¶ p x) s) fun (x : Œ±) ‚Ü¶ g x) =\n    Finset.prod s fun (x : { x : Œ± // p x }) ‚Ü¶ f x","name":"Finset.prod_subtype_map_embedding","isProp":true,"docString":"A product of a function over a `Finset` in a subtype equals a\nproduct in the main type of a function that agrees with the first\nfunction on that `Finset`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {w : (a : Œ±) ‚Üí M} {b : M} [inst_1 : LinearOrderedCancelAddCommMonoid M]\n  (hf : ‚àÄ (y : Œ≤) (x : ¬¨(y ‚àà t : Prop)), 0 ‚â§ Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x)\n  (ht : Finset.Nonempty t) (hb : (Finset.sum s fun (x : Œ±) ‚Ü¶ w x) ‚â§ Finset.card t ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß ((Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x) ‚â§ b : Prop)","name":"Finset.exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality\nversion: if the total weight of a finite set of pigeons is less than or equal to `n ‚Ä¢ b`, they are\nsorted into some pigeonholes, and for all but `n > 0` pigeonholes the total weight of the pigeons\nthere is nonnegative, then for at least one of these `n` pigeonholes, the total weight of the\npigeons in this pigeonhole is less than or equal to `b`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±} [inst_1 : NoMaxOrder Œ±], Nonempty ‚Üë(Set.Ioi a)","name":"Set.nonempty_Ioi_subtype","isProp":true,"docString":"In an order without maximal elements, the intervals `Ioi` are nonempty. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Add Œ±] [inst_2 : ContinuousAdd Œ±], ContinuousAdd Œ±·µÉ·µí·µñ","name":"AddOpposite.instContinuousAddAddOppositeInstTopologicalSpaceAddOppositeAdd","isProp":true,"docString":"If addition is continuous in `Œ±`, then it also is in `Œ±·µÉ·µí·µñ`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ} [inst_1 : TopologicalSpace Œ±] (h : TendstoLocallyUniformly F f p)\n  (hc : Filter.Eventually (fun (n : Œπ) ‚Ü¶ Continuous (F n)) p) [inst_2 : Filter.NeBot p], Continuous f","name":"TendstoLocallyUniformly.continuous","isProp":true,"docString":"A locally uniform limit of continuous functions is continuous. "},{"type":"‚àÄ {R : Type u_1} {a : R} [inst : Monoid R] {n : ‚Ñï} (n0 : 0 < n),\n  (IsRightRegular (a ^ n) : Prop) ‚Üî (IsRightRegular a : Prop)","name":"IsRightRegular.pow_iff","isProp":true,"docString":"An element `a` is right-regular if and only if a positive power of `a` is right-regular. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (s : Set Œ±), UniformContinuous fun (x : Œ±) ‚Ü¶ Metric.infNndist x s","name":"Metric.uniformContinuous_infNndist_pt","isProp":true,"docString":"The minimal distance to a set (as `‚Ñù‚â•0`) is uniformly continuous in point "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (K : Subgroup G) {k : Set G}, (Subgroup.closure k ‚â§ K : Prop) ‚Üî (k ‚äÜ ‚ÜëK : Prop)","name":"Subgroup.closure_le","isProp":true,"docString":"A subgroup `K` includes `closure k` if and only if it includes `k`. "},{"type":"‚àÄ {X : Type u_2} [inst : TopologicalSpace X] {œÄ : (a : X) ‚Üí Sort u_1} {f : (a : ‚Ñï) ‚Üí (x : X) ‚Üí œÄ x}\n  (hf : LocallyFinite fun (n : ‚Ñï) ‚Ü¶ setOf fun (x : X) ‚Ü¶ f (n + 1) x ‚â† f n x),\n  ‚àÉ (F : (x : X) ‚Üí œÄ x),\n    ‚àÄ (x : X), Filter.Eventually (fun (n : ‚Ñï) ‚Ü¶ Filter.Eventually (fun (y : X) ‚Ü¶ f n y = F y) (nhds x)) Filter.atTop","name":"LocallyFinite.exists_forall_eventually_atTop_eventually_eq'","isProp":true,"docString":"Let `f : ‚Ñï ‚Üí Œ† a, Œ≤ a` be a sequence of (dependent) functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x ‚â† f n x}` is locally finite. Then there exists a\nfunction `F : Œ† a, Œ≤ a` such that for any `x`, for sufficiently large values of `n`, we have\n`f n y = F y` in a neighbourhood of `x`. "},{"type":"‚àÄ {R : Type u} {n : ‚Ñï} {M : (a : Fin (Nat.succ n)) ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Fin (Nat.succ n)) ‚Üí AddCommMonoid (M i)] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : (i : Fin (Nat.succ n)) ‚Üí Module R (M i)] [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M M‚ÇÇ)\n  (m : (i : Fin n) ‚Üí M (‚ÜëFin.castSucc i)) (x : M (Fin.last n)) (y : M (Fin.last n)),\n  ‚Üëf (Fin.snoc m (x + y)) = ‚Üëf (Fin.snoc m x) + ‚Üëf (Fin.snoc m y)","name":"MultilinearMap.snoc_add","isProp":true,"docString":"In the specific case of multilinear maps on spaces indexed by `Fin (n+1)`, where one can build\nan element of `‚àÄ (i : Fin (n+1)), M i` using `snoc`, one can express directly the additivity of a\nmultilinear map along the first variable. "},{"type":"‚àÄ {a : Prop} {b : Prop} (self : (a : Prop) ‚Üî (b : Prop)) (a : a), b","name":"Iff.mp","isProp":true,"docString":"Modus ponens for if and only if. If `a ‚Üî b` and `a`, then `b`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ≥}\n  (hf : UpperSemicontinuousOn f s) (hg : UpperSemicontinuousOn g s)\n  (hcont : ‚àÄ (x : Œ±) (a : x ‚àà s), ContinuousAt (fun (p : Œ≥ √ó Œ≥) ‚Ü¶ Prod.fst p + Prod.snd p) (f x, g x)),\n  UpperSemicontinuousOn (fun (z : Œ±) ‚Ü¶ f z + g z) s","name":"UpperSemicontinuousOn.add'","isProp":true,"docString":"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C)\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] {b : CategoryTheory.Limits.BinaryBicone X Y}\n  (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b),\n  CategoryTheory.Iso.hom\n      (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBicone.IsBilimit.isLimit hb)\n        (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)) =\n    CategoryTheory.Limits.biprod.lift (CategoryTheory.Limits.BinaryBicone.fst b)\n      (CategoryTheory.Limits.BinaryBicone.snd b)","name":"CategoryTheory.Limits.biprod.conePointUniqueUpToIso_hom","isProp":true,"docString":"Auxiliary lemma for `biprod.uniqueUpToIso`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚©ø b), (a ‚ãñ b : Prop) ‚à® (a = b : Prop)","name":"Wcovby.covby_or_eq","isProp":true,"docString":"**Alias** of the forward direction of `wcovby_iff_covby_or_eq`."},{"type":"‚àÄ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R} (a0 : a ‚â† 0), IsRegular a","name":"isRegular_of_ne_zero","isProp":true,"docString":"Non-zero elements of an integral domain are regular. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v},\n  (Cardinal.lift (Cardinal.mk Œ±) ‚â§ Cardinal.lift (Cardinal.mk Œ≤) : Prop) ‚Üî (Nonempty (Œ± ‚Ü™ Œ≤) : Prop)","name":"Cardinal.lift_mk_le'","isProp":true,"docString":"A variant of `Cardinal.lift_mk_le` with specialized universes.\nBecause Lean often can not realize it should use this specialization itself,\nwe provide this statement separately so you don't have to solve the specialization problem either.\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : Encodable Œ±] (a : Œ±), Encodable.decode (Encodable.encode a) = some a","name":"Encodable.encodek","isProp":true,"docString":"Invariant relationship between encoding and decoding"},{"type":"‚àÄ {G : Type u} [inst : LeftCancelMonoid G] [inst_1 : Finite G] (x : G), 0 < orderOf x","name":"orderOf_pos","isProp":true,"docString":"This is the same as `orderOf_pos'` but with one fewer explicit assumption since this is\nautomatic in case of a finite cancellative monoid."},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} (a : Finset.Nonempty s), Set.Nonempty ‚Üës","name":"Finset.Nonempty.to_set","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.coe_nonempty`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y}\n  (F : CategoryTheory.Limits.StrongEpiMonoFactorisation f) {F' : CategoryTheory.Limits.MonoFactorisation f}\n  (hF' : CategoryTheory.Limits.IsImage F'), CategoryTheory.StrongEpi (CategoryTheory.Limits.MonoFactorisation.e F')","name":"CategoryTheory.Limits.strongEpi_of_strongEpiMonoFactorisation","isProp":true,"docString":"If there is a single strong epi-mono factorisation of `f`, then every image factorisation is a\nstrong epi-mono factorisation. "},{"type":"‚àÄ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R} (a_1 : b ‚â† 0),\n  EuclideanDomain.r (EuclideanDomain.remainder a b) b","name":"EuclideanDomain.remainder_lt","isProp":true,"docString":"The relation `r` satisfies `r (a % b) b`. "},{"type":"‚àÄ (a : Ordinal), Ordinal.lift a = a","name":"Ordinal.lift_id","isProp":true,"docString":"An ordinal lifted to the same universe equals itself. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {P : C} {Q : C}\n  (self : CategoryTheory.Limits.BinaryBicone P Q),\n  CategoryTheory.Limits.BinaryBicone.inl self ‚â´ CategoryTheory.Limits.BinaryBicone.fst self = ùüô P","name":"CategoryTheory.Limits.BinaryBicone.inl_fst","isProp":true,"docString":"A binary bicone for a pair of objects `P Q : C` consists of the cone point `X`,\nmaps from `X` to both `P` and `Q`, and maps from both `P` and `Q` to `X`,\nso that `inl ‚â´ fst = ùüô P`, `inl ‚â´ snd = 0`, `inr ‚â´ fst = 0`, and `inr ‚â´ snd = ùüô Q`\n"},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] (f : M ‚Üí+ P),\n  Function.Injective ‚Üë(AddCon.kerLift f)","name":"AddCon.kerLift_injective","isProp":true,"docString":"An `AddMonoid` homomorphism `f` induces an injective homomorphism on the quotient\nby `f`'s kernel."},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_3} {E' : Type u_2} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : f' =O[l] g), (fun (x : Œ±) ‚Ü¶ -f' x) =O[l] g","name":"Asymptotics.IsBigO.neg_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigO_neg_left`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C] {W : C} {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (g‚ÇÅ : Y ‚ü∂ W)\n  [inst_3 : CategoryTheory.Epi g‚ÇÅ] (g‚ÇÇ : W ‚ü∂ Z) [inst_4 : CategoryTheory.Mono g‚ÇÇ] (hg : g‚ÇÅ ‚â´ g‚ÇÇ = g) (f' : X ‚ü∂ W)\n  (hf : f' ‚â´ g‚ÇÇ = f) (t : CategoryTheory.Limits.PullbackCone f g) (ht : CategoryTheory.Limits.IsLimit t),\n  CategoryTheory.Epi (CategoryTheory.Limits.PullbackCone.fst t)","name":"CategoryTheory.Abelian.epi_fst_of_factor_thru_epi_mono_factorization","isProp":true,"docString":"Suppose `f` and `g` are two morphisms with a common codomain and suppose we have written `g` as\nan epimorphism followed by a monomorphism. If `f` factors through the mono part of this\nfactorization, then any pullback of `g` along `f` is an epimorphism. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =O[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ), f =O[l] g'","name":"Asymptotics.IsBigO.of_norm_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigO_norm_right`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Group Œ±] [inst_1 : DivisionMonoid Œ≤] (f : Œ± ‚Üí* Œ≤) (g : Œ±) (h : Œ±),\n  ‚Üëf (g / h) = ‚Üëf g / ‚Üëf h","name":"MonoidHom.map_div","isProp":true,"docString":"Group homomorphisms preserve division. "},{"type":"‚àÄ {n : ‚Ñï} (p : Fin (n + 1)) (i : Fin n), (‚ÜëFin.castSucc i < p : Prop) ‚à® (p < Fin.succ i : Prop)","name":"Fin.succAbove_lt_gt","isProp":true,"docString":"Embedding `i : Fin n` into `Fin (n + 1)` is always about some hole `p`. "},{"type":"‚àÄ {Œ¥ : ‚Ñù} {X : Type u} [inst : PseudoMetricSpace X] {E : Set X} {x : X},\n  (x ‚àà Metric.thickening Œ¥ E : Prop) ‚Üî (‚àÉ (z : X), (z ‚àà E : Prop) ‚àß (dist x z < Œ¥ : Prop) : Prop)","name":"Metric.mem_thickening_iff","isProp":true,"docString":"A point in a metric space belongs to the (open) `Œ¥`-thickening of a subset `E` if and only if\nit is at distance less than `Œ¥` from some point of `E`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {H : Type u_2} [inst_2 : Group H]\n  (f : (a : IsFreeGroup.Generators G) ‚Üí H),\n  ‚àÉ! (F : G ‚Üí* H), ‚àÄ (a : IsFreeGroup.Generators G), ‚ÜëF (IsFreeGroup.of a) = f a","name":"IsFreeGroup.unique_lift","isProp":true,"docString":"The universal property of a free group: A functions from the generators of `G` to another\ngroup extends in a unique way to a homomorphism from `G`.\n\nNote that since `IsFreeGroup.lift` is expressed as a bijection, it already\nexpresses the universal property.  "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {e' : LocalHomeomorph Œ± Œ≤} (h : e ‚âà e'), LocalHomeomorph.symm e ‚âà LocalHomeomorph.symm e'","name":"LocalHomeomorph.EqOnSource.symm'","isProp":true,"docString":"If two local homeomorphisms are equivalent, so are their inverses "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] (a : Œ±), a ‚â§ a","name":"le_refl","isProp":true,"docString":"The relation `‚â§` on a preorder is reflexive. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w}, CategoryTheory.Presieve.IsSheaf ‚ä• P","name":"CategoryTheory.Presieve.isSheaf_bot","isProp":true,"docString":"Any presheaf is a sheaf for the bottom (trivial) grothendieck topology. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} [inst : CompleteLattice Œ±] [inst_1 : Fintype Œπ] {f : (a : Œπ) ‚Üí Œ±},\n  (CompleteLattice.Independent f : Prop) ‚Üî (Finset.SupIndep Finset.univ f : Prop)","name":"CompleteLattice.independent_iff_supIndep_univ","isProp":true,"docString":"A variant of `CompleteLattice.independent_iff_supIndep` for `Fintype`s. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : IsSuccArchimedean Œ±] {P : (a : Œ±) ‚Üí Prop} {m : Œ±}\n  (h0 : P m) (h1 : ‚àÄ (n : Œ±) (a : m ‚â§ n) (a : P n), P (Order.succ n)) ‚¶Én : Œ±‚¶Ñ (hmn : m ‚â§ n), P n","name":"Succ.rec","isProp":true,"docString":"Induction principle on a type with a `SuccOrder` for all elements above a given element `m`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.FirstCountableTopology X], FrechetUrysohnSpace X","name":"TopologicalSpace.FirstCountableTopology.frechetUrysohnSpace","isProp":true,"docString":"Every first-countable space is a Fr√©chet-Urysohn space. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] (t : Multiset (Polynomial R)),\n  Polynomial.degree (Multiset.prod t) ‚â§ Multiset.sum (Multiset.map Polynomial.degree t)","name":"Polynomial.degree_multiset_prod_le","isProp":true,"docString":"The degree of a product of polynomials is at most the sum of the degrees,\nwhere the degree of the zero polynomial is ‚ä•.\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedField Œ±] (a : Œ±) (a_1 : a ‚â† 0), a * a‚Åª¬π = 1","name":"LinearOrderedField.mul_inv_cancel","isProp":true,"docString":"For a nonzero `a`, `a‚Åª¬π` is a right multiplicative inverse. "},{"type":"‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a : B} {b : B} {c : B}\n  {d : B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d),\n  CategoryTheory.Bicategory.associator f g h =\n    CategoryTheory.eqToIso\n      ((CategoryTheory.Bicategory.Strict.assoc f g h=:(f ‚â´ g) ‚â´ h = f ‚â´ g ‚â´ h)=:(f ‚â´ g) ‚â´ h = f ‚â´ g ‚â´ h)","name":"CategoryTheory.Bicategory.Strict.associator_eqToIso","isProp":true,"docString":"The associators are given by equalities "},{"type":"‚àÄ {Œ± : Type u_1} {ùïú : Type u_2} [inst : NormedField ùïú] {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú}\n  (hgf : Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚àÄ (a : g x = 0), f x = 0) l)\n  (a : Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x / g x) l (nhds 0)), f =o[l] g","name":"Asymptotics.isLittleO_of_tendsto'","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_iff_tendsto'`."},{"type":"‚àÄ {a : Prop} {b : Prop},\n  (¬¨((a : Prop) ‚àß (b : Prop) : Prop) : Prop) ‚Üî ((¬¨(a : Prop) : Prop) ‚à® (¬¨(b : Prop) : Prop) : Prop)","name":"not_and_or","isProp":true,"docString":"One of de Morgan's laws: the negation of a conjunction is logically equivalent to the\ndisjunction of the negations. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : SupSet Œ±] [inst_1 : SupSet Œ≤]\n  [self : Sup‚ÇõHomClass F Œ± Œ≤] (f : F) (s : Set Œ±), ‚Üëf (sup‚Çõ s) = sup‚Çõ (‚Üëf '' s)","name":"Sup‚ÇõHomClass.map_sup‚Çõ","isProp":true,"docString":"The proposition that members of `Sup‚ÇõHomClass`s commute with arbitrary suprema/joins. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} (hs : TopologicalSpace.IsSeparable s),\n  TopologicalSpace.SeparableSpace ‚Üës","name":"TopologicalSpace.IsSeparable.separableSpace","isProp":true,"docString":"If a set `s` is separable, then the corresponding subtype is separable in a (pseudo extended)\nmetric space.  This is not obvious, as the countable set whose closure covers `s` does not need in\ngeneral to be contained in `s`. "},{"type":"‚àÄ {F : Type u_1} (R : Type u_2) (S : Type u_3) [inst : Ring R] [inst_1 : SeminormedRing S] [inst_2 : NormOneClass S]\n  [inst_3 : RingHomClass F R S] (f : F), NormOneClass R","name":"NormOneClass.induced","isProp":true,"docString":"A ring homomorphism from a `Ring R` to a `SeminormedRing S` which induces the norm structure\n`SeminormedRing.induced` makes `R` satisfy `‚Äñ(1 : R)‚Äñ = 1` whenever `‚Äñ(1 : S)‚Äñ = 1`. "},{"type":"‚àÄ {n : ‚Ñï} (hn : n ‚â† 0) (p : ‚Ñï) (hp : p ‚â† 1), ‚àÉ (e : ‚Ñï), ‚àÉ (n' : ‚Ñï), (¬¨(p ‚à£ n' : Prop) : Prop) ‚àß (n = p ^ e * n' : Prop)","name":"Nat.exists_eq_pow_mul_and_not_dvd","isProp":true,"docString":"If `n` is a nonzero natural number and `p ‚â† 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {J : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category J]\n  [inst_2 : CategoryTheory.Limits.HasColimitsOfShape J·µí·µñ C], CategoryTheory.Limits.HasLimitsOfShape J C·µí·µñ","name":"CategoryTheory.Limits.hasLimitsOfShape_op_of_hasColimitsOfShape","isProp":true,"docString":"If `C` has colimits of shape `J·µí·µñ`, we can construct limits in `C·µí·µñ` of shape `J`.\n"},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] {a : R} {b : R} {c : R} [inst_1 : NeZero 2] [inst_2 : NoZeroDivisors R]\n  (ha : a ‚â† 0) (x : R), (a * x * x + b * x + c = 0 : Prop) ‚Üî (discrim a b c = (2 * a * x + b) ^ 2 : Prop)","name":"quadratic_eq_zero_iff_discrim_eq_sq","isProp":true,"docString":"A quadratic has roots if and only if its discriminant equals some square.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.SmallCategory C] (P : C·µí·µñ ‚•§ Type u‚ÇÅ) (j : (CategoryTheory.Functor.Elements P)·µí·µñ),\n  (CategoryTheory.Limits.Cocone.Œπ (CategoryTheory.coconeOfRepresentable P)).app j =\n    CategoryTheory.Iso.inv (CategoryTheory.yonedaSectionsSmall (Opposite.unop (Sigma.fst (Opposite.unop j))) P)\n      (Sigma.snd (Opposite.unop j))","name":"CategoryTheory.coconeOfRepresentable_Œπ_app","isProp":true,"docString":"An explicit formula for the legs of the cocone `coconeOfRepresentable`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasCoproducts C],\n  CategoryTheory.Limits.HasFiniteCoproducts C","name":"CategoryTheory.Limits.hasFiniteCoproducts_of_hasCoproducts","isProp":true,"docString":"If a category has all coproducts then in particular it has finite coproducts.\n"},{"type":"‚àÄ {C : Type v} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y)\n  (i : Function.Injective (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget C)) f)),\n  CategoryTheory.Mono f","name":"CategoryTheory.ConcreteCategory.mono_of_injective","isProp":true,"docString":"In any concrete category, injective morphisms are monomorphisms. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V] {Œπ : Type u_1}\n  (s : Finset Œπ) (p : (a : Œπ) ‚Üí V) (w : (a : Œπ) ‚Üí k) (hw : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1),\n  ‚Üë(Finset.affineCombination k s p) w = Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ p i","name":"Finset.affineCombination_eq_linear_combination","isProp":true,"docString":"Viewing a module as an affine space modelled on itself, affine combinations are just linear\ncombinations. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (self : C ‚•§ D)\n  (X : C),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor self) (ùüô X) =\n    ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor self) X)","name":"CategoryTheory.Functor.map_id","isProp":true,"docString":"A functor preserves identity morphisms. "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] (Œπ : Type w),\n  Module.rank R (Œπ ‚Üí‚ÇÄ R) = Cardinal.lift (Cardinal.mk Œπ)","name":"rank_finsupp_self","isProp":true,"docString":"The rank of `(Œπ ‚Üí‚ÇÄ R)` is `(# Œπ).lift`. "},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) [inst : UniformSpace Œ≤] (ùîñ : Set (Set Œ±)),\n  UniformOnFun.topologicalSpace Œ± Œ≤ ùîñ =\n    inf·µ¢ fun (s : Set Œ±) ‚Ü¶\n      inf·µ¢ fun (_hs : s ‚àà ùîñ) ‚Ü¶\n        TopologicalSpace.induced (Set.restrict s ‚àò ‚ÜëUniformFun.toFun) (UniformFun.topologicalSpace (‚Üës) Œ≤)","name":"UniformOnFun.topologicalSpace_eq","isProp":true,"docString":"The topology of `ùîñ`-convergence is the infimum, for `S ‚àà ùîñ`, of topology induced by the map\nof `S.restrict : (Œ± ‚Üí·µ§[ùîñ] Œ≤) ‚Üí (‚Ü•S ‚Üí·µ§ Œ≤)` of restriction to `S`, where `‚Ü•S ‚Üí·µ§ Œ≤` is endowed with\nthe topology of uniform convergence. "},{"type":"IsFractionRing ‚Ñ§ ‚Ñö","name":"Rat.isFractionRing","isProp":true,"docString":"The cast from `Int` to `Rat` as a `FractionRing`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : AddGroup Œ±]\n  [inst_1 : OrderedAddCommMonoid Œ≤] [self : AddGroupNormClass F Œ± Œ≤] (f : F) {a : Œ±} (a_1 : ‚Üëf a = 0), a = 0","name":"AddGroupNormClass.eq_zero_of_map_eq_zero","isProp":true,"docString":"The argument is zero if its image under the map is zero. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C], CategoryTheory.Limits.HasFiniteBiproducts C","name":"CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteProducts","isProp":true,"docString":"A preadditive category with finite products has finite biproducts. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_4} {Œ≥ : Type u_1} {Œ¥ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : TopologicalSpace Œ¥] {e‚ÇÅ : (a : Œ±) ‚Üí Œ≤} {e‚ÇÇ : (a : Œ≥) ‚Üí Œ¥}\n  (de‚ÇÅ : DenseInducing e‚ÇÅ) (de‚ÇÇ : DenseInducing e‚ÇÇ), DenseInducing fun (p : Œ± √ó Œ≥) ‚Ü¶ (e‚ÇÅ (Prod.fst p), e‚ÇÇ (Prod.snd p))","name":"DenseInducing.prod","isProp":true,"docString":"The product of two dense inducings is a dense inducing "},{"type":"‚àÄ {Œ± : Type u}, IsAtomic (Filter Œ±)","name":"instIsAtomicFilterInstPartialOrderFilterToOrderBotToLEToPreorderToBoundedOrderInstCompleteLatticeFilter","isProp":true,"docString":"`Filter Œ±` is an atomic type: for every filter there exists an ultrafilter that is less than or\nequal to this filter. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {f : (a : Œ±) ‚Üí Œ±} {p : (a : Œ±) ‚Üí Prop} {hf : ‚àÄ (x : Œ±), x ‚â§ f x}\n  {hfp : ‚àÄ (x : Œ±), p (f x)} {hmin : ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : x ‚â§ y) (a : p y), f x ‚â§ y} {x : Œ±} (hx : p x),\n  x ‚àà ClosureOperator.closed (ClosureOperator.mk‚ÇÉ f p hf hfp hmin)","name":"ClosureOperator.mem_mk‚ÇÉ_closed","isProp":true,"docString":"The property `p` fed into the `mk‚ÇÉ` constructor implies being closed. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : Set.Nonempty s) (bs : Metric.Bounded s)\n  (ht : Set.Nonempty t) (bt : Metric.Bounded t), Metric.hausdorffDist s t ‚â§ Metric.diam (s ‚à™ t)","name":"Metric.hausdorffDist_le_diam","isProp":true,"docString":"The Hausdorff distance is controlled by the diameter of the union "},{"type":"‚àÄ {R : Type u} {n : ‚Ñï} {M : (a : Fin (Nat.succ n)) ‚Üí Type w} {M‚ÇÇ : Type w‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Fin (Nat.succ n)) ‚Üí AddCommMonoid (M i)] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : (i : Fin (Nat.succ n)) ‚Üí Module R (M i)] [inst_4 : Module R M‚ÇÇ]\n  [inst_5 : (i : Fin (Nat.succ n)) ‚Üí TopologicalSpace (M i)] [inst_6 : TopologicalSpace M‚ÇÇ]\n  (f : ContinuousMultilinearMap R M M‚ÇÇ) (m : (i : Fin n) ‚Üí M (Fin.succ i)) (x : M 0) (y : M 0),\n  ‚Üëf (Fin.cons (x + y) m) = ‚Üëf (Fin.cons x m) + ‚Üëf (Fin.cons y m)","name":"ContinuousMultilinearMap.cons_add","isProp":true,"docString":"In the specific case of continuous multilinear maps on spaces indexed by `Fin (n+1)`, where one\ncan build an element of `(i : Fin (n+1)) ‚Üí M i` using `cons`, one can express directly the\nadditivity of a multilinear map along the first variable. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (a : G), ‚Üë(Equiv.symm (Equiv.addLeft a)) = fun (x : G) ‚Ü¶ -a + x","name":"Equiv.addLeft_symm_apply","isProp":true,"docString":"Extra simp lemma that `dsimp` can use. `simp` will never use this."},{"type":"‚àÄ {A : Type u_2} {F : Type u_1} [inst : MulZeroOneClass A] [inst_1 : MonoidWithZeroHomClass F ‚Ñï A] (f : F) (g : F)\n  (h_pos : ‚àÄ {n : ‚Ñï} (a : 0 < n), ‚Üëf n = ‚Üëg n), f = g","name":"ext_nat''","isProp":true,"docString":"If two `MonoidWithZeroHom`s agree on the positive naturals they are equal. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {Œµ : ‚Ñù} (h : 0 ‚â§ Œµ),\n  EMetric.closedBall x (ENNReal.ofReal Œµ) = Metric.closedBall x Œµ","name":"Metric.emetric_closedBall","isProp":true,"docString":"Closed balls defined using the distance or the edistance coincide "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  {u : (a : Œ≤) ‚Üí Œ±},\n  (CauchySeq u : Prop) ‚Üî (‚àÄ (Œµ : ENNReal) (a : Œµ > 0), ‚àÉ (N : Œ≤), ‚àÄ (n : Œ≤) (a : n ‚â• N), edist (u n) (u N) < Œµ : Prop)","name":"EMetric.cauchySeq_iff'","isProp":true,"docString":"A variation around the emetric characterization of Cauchy sequences "},{"type":"‚àÄ (p : ‚Ñï) [hp : Fact (Nat.Prime p : Prop)], IsDomain (ZMod p)","name":"ZMod.instIsDomainZModToSemiringToDivisionSemiringToSemifieldInstFieldZMod","isProp":true,"docString":"`ZMod p` is an integral domain when `p` is prime. "},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : NoZeroSMulDivisors R M] (v : (a : Œπ) ‚Üí M) [inst_5 : Unique Œπ] (a : v default ‚â† 0),\n  LinearIndependent R v","name":"linearIndependent_unique","isProp":true,"docString":"**Alias** of the reverse direction of `linearIndependent_unique_iff`."},{"type":"‚àÄ {E : Type u_1} {Œ≤ : Type u_2} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E] [inst_2 : Module ‚Ñù E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] [inst_5 : OrderedAddCommGroup Œ≤] [inst_6 : Module ‚Ñù Œ≤]\n  [inst_7 : OrderedSMul ‚Ñù Œ≤] {f : (a : E) ‚Üí Œ≤} {a : E} (h_local_max : IsLocalMax f a) (h_conc : ConcaveOn ‚Ñù Set.univ f)\n  (x : E), f x ‚â§ f a","name":"IsMaxOn.of_isLocalMax_of_convex_univ","isProp":true,"docString":"A local maximum of a concave function is a global maximum. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonUnitalSeminormedRing Œ±] (a : Œ±) (b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ","name":"NonUnitalSeminormedRing.norm_mul","isProp":true,"docString":"The norm is submultiplicative. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : IsWeakUpperModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚äì b ‚ãñ a)\n  (a_2 : a ‚äì b ‚ãñ b), b ‚ãñ a ‚äî b","name":"Covby.sup_of_inf_of_inf_right","isProp":true,"docString":"**Alias** of `covby_sup_of_inf_covby_of_inf_covby_right`."},{"type":"‚àÄ {B : Type u_1} {F : Type u_2} {Z : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  [inst_2 : TopologicalSpace Z] {proj : (a : Z) ‚Üí B} (h : IsHomeomorphicTrivialFiberBundle F proj), IsOpenMap proj","name":"IsHomeomorphicTrivialFiberBundle.isOpenMap_proj","isProp":true,"docString":"The projection from a trivial fiber bundle to its base is open. "},{"type":"‚àÄ {S : Type u_2} [inst : CommRing S] (A : Type u_1) [inst_1 : CommRing A] [inst_2 : IsDomain A] [inst_3 : Algebra A S]\n  {M : Submonoid A} [inst_4 : IsLocalization M S] (hM : M ‚â§ nonZeroDivisors A), IsDomain S","name":"IsLocalization.isDomain_of_le_nonZeroDivisors","isProp":true,"docString":"A `CommRing` `S` which is the localization of an integral domain `R` at a subset of\nnon-zero elements is an integral domain.\nSee note [reducible non-instances]. "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : UniformSpace R] [inst_2 : UniformAddGroup R] [inst_3 : ContinuousMul R],\n  UniformContinuousConstSMul R·µê·µí·µñ R","name":"Ring.uniformContinuousConstSMul_op","isProp":true,"docString":"The action of `Semiring.toOppositeModule` is uniformly continuous. "},{"type":"‚àÄ {s : Set ‚Ñù} (h : Metric.Bounded s), Metric.diam s = sup‚Çõ s - inf‚Çõ s","name":"Real.diam_eq","isProp":true,"docString":"For a bounded set `s : Set ‚Ñù`, its `Metric.diam` is equal to `sup‚Çõ s - inf‚Çõ s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {ta1 : TopologicalSpace Œ±}\n  {ta2 : TopologicalSpace Œ±} {tb1 : TopologicalSpace Œ≤} {tb2 : TopologicalSpace Œ≤} {tc1 : TopologicalSpace Œ≥}\n  (h : Continuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)),\n  Continuous fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)","name":"continuous_inf_dom_left‚ÇÇ","isProp":true,"docString":"A version of `continuous_inf_dom_left` for binary functions "},{"type":"‚àÄ (z : ‚ÑÇ), ‚Üë(Complex.im z) = (z - ‚Üë(starRingEnd ‚ÑÇ) z) / (2 * Complex.I)","name":"Complex.im_eq_sub_conj","isProp":true,"docString":"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [hf : CategoryTheory.IsSplitMono f],\n  CategoryTheory.Mono f","name":"CategoryTheory.IsSplitMono.mono","isProp":true,"docString":"Every split mono is a mono. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : UniformEmbedding f), Function.Injective f","name":"UniformEmbedding.inj","isProp":true,"docString":"A uniform embedding is injective. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {f : (a : Œ±) ‚Üí ENNReal} (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚â† ‚ä§),\n  ENNReal.toNNReal (Finset.sum s fun (a : Œ±) ‚Ü¶ f a) = Finset.sum s fun (a : Œ±) ‚Ü¶ ENNReal.toNNReal (f a)","name":"ENNReal.toNNReal_sum","isProp":true,"docString":"Seeing `‚Ñù‚â•0‚àû` as `‚Ñù‚â•0` does not change their sum, unless one of the `‚Ñù‚â•0‚àû` is\ninfinity "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : NonUnitalNonAssocRing Œ±] [inst_3 : NonUnitalNonAssocRing Œ≤] [inst_4 : TopologicalRing Œ±]\n  [inst_5 : TopologicalRing Œ≤], TopologicalRing (Œ± √ó Œ≤)","name":"instTopologicalRingProdInstTopologicalSpaceProdInstNonUnitalNonAssocRingProd","isProp":true,"docString":"The product topology on the cartesian product of two topological rings\nmakes the product into a topological ring. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.HasShift C ‚Ñ§]\n  {T‚ÇÅ : CategoryTheory.Pretriangulated.Triangle C} {T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle C}\n  (self : CategoryTheory.Pretriangulated.TriangleMorphism T‚ÇÅ T‚ÇÇ),\n  CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T‚ÇÅ ‚â´ CategoryTheory.Pretriangulated.TriangleMorphism.hom‚ÇÉ self =\n    CategoryTheory.Pretriangulated.TriangleMorphism.hom‚ÇÇ self ‚â´ CategoryTheory.Pretriangulated.Triangle.mor‚ÇÇ T‚ÇÇ","name":"CategoryTheory.Pretriangulated.TriangleMorphism.comm‚ÇÇ","isProp":true,"docString":"the second commutative square of a triangle morphism "},{"type":"‚àÄ {R : Type u_2} [inst : CommSemiring R] (M : Submonoid R) {S : Type u_1} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] (z : S),\n  ‚Üë(algebraMap R S) (Prod.fst (IsLocalization.sec M z)) = ‚Üë(algebraMap R S) ‚Üë(Prod.snd (IsLocalization.sec M z)) * z","name":"IsLocalization.sec_spec'","isProp":true,"docString":"Given `z : S`, `IsLocalization.sec M z` is defined to be a pair `(x, y) : R √ó M` such\nthat `z * f y = f x`, so this lemma is just an application of `S`'s commutativity. "},{"type":"‚àÄ {Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} (h : Function.Commute f g),\n  Set.BijOn f (Function.fixedPoints (f ‚àò g)) (Function.fixedPoints (f ‚àò g))","name":"Function.Commute.left_bijOn_fixedPoints_comp","isProp":true,"docString":"If self-maps `f` and `g` commute, then `f` is bijective on the set of fixed points of `f ‚àò g`.\nThis is a particular case of `Function.bijOn_fixedPoints_comp`. "},{"type":"‚àÄ {Œπ : Type u_1} {a : (a : Œπ) ‚Üí ENNReal} {c : ENNReal} (c_ne_top : c ‚â† ‚ä§) (tsum_le_c : (tsum fun (i : Œπ) ‚Ü¶ a i) ‚â§ c)\n  {Œµ : ENNReal} (Œµ_ne_zero : Œµ ‚â† 0),\n  ‚àÉ (hf : Set.Finite (setOf fun (i : Œπ) ‚Ü¶ Œµ ‚â§ a i)), ‚Üë(Finset.card (Set.Finite.toFinset hf)) ‚â§ c / Œµ","name":"ENNReal.finset_card_const_le_le_of_tsum_le","isProp":true,"docString":"Markov's inequality for `Finset.card` and `tsum` in `‚Ñù‚â•0‚àû`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {B : Set (Set Œ±)} (hB : TopologicalSpace.IsTopologicalBasis B) {u : Set Œ±}\n  (ou : IsOpen u), u = ‚ãÉ‚ÇÄ setOf fun (s : Set Œ±) ‚Ü¶ (s ‚àà B : Prop) ‚àß (s ‚äÜ u : Prop)","name":"TopologicalSpace.IsTopologicalBasis.open_eq_union‚Çõ'","isProp":true,"docString":"Any open set is the union of the basis sets contained in it. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {w : (a : Œ±) ‚Üí M} {b : M} [inst_1 : LinearOrderedCancelAddCommMonoid M]\n  (hf : ‚àÄ (y : Œ≤) (x : ¬¨(y ‚àà t : Prop)), (Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x) ‚â§ 0)\n  (ht : Finset.Nonempty t) (hb : Finset.card t ‚Ä¢ b ‚â§ Finset.sum s fun (x : Œ±) ‚Ü¶ w x),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (b ‚â§ Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) fun (x : Œ±) ‚Ü¶ w x : Prop)","name":"Finset.exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality\nversion: if the total weight of a finite set of pigeons is greater than or equal to `n ‚Ä¢ b`, they\nare sorted into some pigeonholes, and for all but `n > 0` pigeonholes the total weight of the\npigeons there is nonpositive, then for at least one of these `n` pigeonholes, the total weight of\nthe pigeons in this pigeonhole is greater than or equal to `b`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : Norm E] {c : ‚Ñù} {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù}\n  (a : Asymptotics.IsBigOWith c l f fun (x : Œ±) ‚Ü¶ abs (u x)), Asymptotics.IsBigOWith c l f u","name":"Asymptotics.IsBigOWith.of_abs_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigOWith_abs_right`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {A : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category A]\n  (J : CategoryTheory.GrothendieckTopology C) (P : C·µí·µñ ‚•§ A) [inst_2 : CategoryTheory.Limits.HasPullbacks C]\n  (s : A ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) [inst_3 : CategoryTheory.Limits.HasLimits A]\n  [inst_4 : CategoryTheory.Limits.PreservesLimits s] [inst_5 : CategoryTheory.ReflectsIsomorphisms s],\n  (CategoryTheory.Presheaf.IsSheaf J P : Prop) ‚Üî (CategoryTheory.Presheaf.IsSheaf J (P ‚ãô s) : Prop)","name":"CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget","isProp":true,"docString":"For a concrete category `(A, s)` where the forgetful functor `s : A ‚•§ Type v` preserves limits and\nreflects isomorphisms, and `A` has limits, an `A`-valued presheaf `P : C·µí·µñ ‚•§ A` is a sheaf iff its\nunderlying `Type`-valued presheaf `P ‚ãô s : C·µí·µñ ‚•§ Type` is a sheaf.\n\nNote this lemma applies for \"algebraic\" categories, eg groups, abelian groups and rings, but not\nfor the category of topological spaces, topological rings, etc since reflecting isomorphisms doesn't\nhold.\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : CommMonoid Œ±] (t : Finset Œπ) (f‚ÇÅ : (a : Œπ) ‚Üí Set Œ±) (f‚ÇÇ : (a : Œπ) ‚Üí Set Œ±)\n  (hf : ‚àÄ (i : Œπ) (a : i ‚àà t), f‚ÇÅ i ‚äÜ f‚ÇÇ i), (Finset.prod t fun (i : Œπ) ‚Ü¶ f‚ÇÅ i) ‚äÜ Finset.prod t fun (i : Œπ) ‚Ü¶ f‚ÇÇ i","name":"Set.finset_prod_subset_finset_prod","isProp":true,"docString":"An n-ary version of `Set.mul_subset_mul`. "},{"type":"‚àÄ {T : Type u‚ÇÅ} [inst : CategoryTheory.Category T] {X : T} {f : CategoryTheory.Over X} {g : CategoryTheory.Over X}\n  (k : f ‚ü∂ g) [inst_1 : CategoryTheory.Mono k], CategoryTheory.Mono (CategoryTheory.CommaMorphism.left k)","name":"CategoryTheory.Over.mono_left_of_mono","isProp":true,"docString":"If `k` is a monomorphism, then `k.left` is a monomorphism. In other words, `Over.forget X` preserves\nmonomorphisms.\nThe converse of `CategoryTheory.Over.mono_of_mono_left`.\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] {x : (i : Œπ) ‚Üí Œ≤ i}\n  {y : (i : Œπ) ‚Üí Œ≤ i}, (0 < hammingDist x y : Prop) ‚Üî (x ‚â† y : Prop)","name":"hammingDist_pos","isProp":true,"docString":"Corresponds to `dist_pos`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Add Œ±], IsAddHom id","name":"IsAddHom.id","isProp":true,"docString":"The identity map preserves addition"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ : TopologicalSpace Œ≤} {t‚ÇÉ : TopologicalSpace Œ≤}\n  (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ) {s : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (h‚ÇÇ : ContinuousOn f s), ContinuousOn f s","name":"ContinuousOn.mono_rng","isProp":true,"docString":"If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SemilatticeSup Œ±] [inst_1 : SemilatticeSup Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (g : (a : Œ≤) ‚Üí Œ±) (b' : Œ≤) (hf : Monotone f)\n  (gc : ‚àÄ (a : Œ±) (b : Œ≤) (a_1 : b ‚â• b'), (f a ‚â§ b : Prop) ‚Üî (a ‚â§ g b : Prop))\n  (hgi : ‚àÄ (b : Œ≤) (a : b ‚â• b'), b ‚â§ f (g b)), Filter.map f Filter.atTop = Filter.atTop","name":"Filter.map_atTop_eq_of_gc","isProp":true,"docString":"A function `f` maps upwards closed sets (atTop sets) to upwards closed sets when it is a\nGalois insertion. The Galois \"insertion\" and \"connection\" is weakened to only require it to be an\ninsertion and a connetion above `b'`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C), CategoryTheory.IsPullback (ùüô X) 0 0 0","name":"CategoryTheory.IsPullback.zero_bot","isProp":true,"docString":"The square with `0 : 0 ‚ü∂ 0` on the bottom and `ùüô X` on the top is a pullback square. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : Add A] [inst_1 : Add B] [inst_2 : Mul A] [inst_3 : Mul B]\n  [inst_4 : SMul R A] [inst_5 : SMul R B] [inst_6 : Star A] [inst_7 : Star B] (self : A ‚âÉ‚ãÜ‚Çê[R] B) (r : R) (a : A),\n  Equiv.toFun (RingEquiv.toEquiv (StarAlgEquiv.toRingEquiv self)) (r ‚Ä¢ a) =\n    r ‚Ä¢ Equiv.toFun (RingEquiv.toEquiv (StarAlgEquiv.toRingEquiv self)) a","name":"StarAlgEquiv.map_smul'","isProp":true,"docString":"By definition, a ‚ãÜ-algebra equivalence commutes with the action of scalars. "},{"type":"‚àÄ {Œ± : Type u} [inst : DecidableEq Œ±] (i : Œ±) (j : Œ±) (œÉ : Equiv.Perm Œ±), Equiv.swap i j * (Equiv.swap i j * œÉ) = œÉ","name":"Equiv.swap_mul_self_mul","isProp":true,"docString":"Left-multiplying a permutation with `swap i j` twice gives the original permutation.\n\nThis specialization of `swap_mul_self` is useful when using cosets of permutations.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : a ‚â§ b) (a_2 : b < c), a < c","name":"LE.le.trans_lt","isProp":true,"docString":"**Alias** of `lt_of_le_of_lt`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Continuous f) (x : Œ±) (y : Œ≤) (h : f x = y), Filter.Tendsto f (nhds x) (nhds y)","name":"Continuous.tendsto'","isProp":true,"docString":"A version of `Continuous.tendsto` that allows one to specify a simpler form of the limit.\nE.g., one can write `continuous_exp.tendsto' 0 1 exp_zero`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : Fintype Œ±] (s : AddSubgroup Œ±) [inst_2 : Fintype { x : Œ± // x ‚àà s }],\n  Fintype.card { x : Œ± // x ‚àà s } ‚à£ Fintype.card Œ±","name":"AddSubgroup.card_addSubgroup_dvd_card","isProp":true,"docString":"**Lagrange's Theorem**: The order of an additive subgroup divides the order of its\nambient additive group."},{"type":"‚àÄ {S : Type u_1} {R : outParam (Type u_2)} {M : Type u_3} [inst : SMul R M] [inst_1 : SetLike S M]\n  [self : SMulMemClass S R M] {s : S} (r : R) {m : M} (a : m ‚àà s), r ‚Ä¢ m ‚àà s","name":"SMulMemClass.smul_mem","isProp":true,"docString":"Multiplication by a scalar on an element of the set remains in the set. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {X : C} {S : CategoryTheory.Presieve X} {Y : D} {f : Y ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X}\n  (self : CategoryTheory.Presieve.FunctorPushforwardStructure F S f),\n  f =\n    CategoryTheory.Presieve.FunctorPushforwardStructure.lift self ‚â´\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor F)\n        (CategoryTheory.Presieve.FunctorPushforwardStructure.premap self)","name":"CategoryTheory.Presieve.FunctorPushforwardStructure.fac","isProp":true,"docString":"the factorisation of the morphism "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : b = c) (a_2 : a ‚â§ b), a ‚â§ c","name":"Eq.trans_ge","isProp":true,"docString":"**Alias** of `le_of_eq_of_le'`."},{"type":"‚àÄ {G : Type u} [self : AddCommGroup G] (a : G) (b : G), a + b = b + a","name":"AddCommGroup.add_comm","isProp":true,"docString":"Addition is commutative in an additive commutative semigroup. "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] {s : (a : ‚Ñï) ‚Üí Œ±} (hs : CauchySeq s), TotallyBounded (Set.range s)","name":"CauchySeq.totallyBounded_range","isProp":true,"docString":"Every Cauchy sequence over `‚Ñï` is totally bounded. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] [inst_1 : OrderBot Œ±] (s : Set Œ±), BddBelow s","name":"OrderBot.bddBelow","isProp":true,"docString":"When there is a global minimum, every set is bounded below. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±] {f : (a : Œ≤) ‚Üí Œ±} {s : Finset Œ≤}\n  (hf : ‚àÄ (b : Œ≤) (x : ¬¨(b ‚àà s : Prop)), f b = 0), HasSum f (Finset.sum s fun (b : Œ≤) ‚Ü¶ f b)","name":"hasSum_sum_of_ne_finset_zero","isProp":true,"docString":"If a function `f` vanishes outside of a finite set `s`, then it `HasSum` `‚àë b in s, f b`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Ring Œ±] [inst_1 : IsDomain Œ±] [inst_2 : Ring Œ≤] (f : Œ≤ ‚Üí+* Œ±)\n  (hf : Function.Injective ‚Üëf), IsDomain Œ≤","name":"Function.Injective.isDomain","isProp":true,"docString":"Pullback `IsDomain` instance along an injective function. "},{"type":"‚àÄ {E : Type u_1} [inst : NormedGroup E] {a : E} {b : E} (a_1 : ‚Äña / b‚Äñ = 0), a = b","name":"eq_of_norm_div_eq_zero","isProp":true,"docString":"**Alias** of the forward direction of `norm_div_eq_zero_iff`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] (X : C) [inst_3 : IsSimpleOrder (CategoryTheory.Subobject X)],\n  CategoryTheory.Simple X","name":"CategoryTheory.simple_of_isSimpleOrder_subobject","isProp":true,"docString":"If `X` has subobject lattice `{‚ä•, ‚ä§}`, then `X` is simple. "},{"type":"‚àÄ (L : List ‚Ñï) (h : ‚àÄ (i : ‚Ñï) (a : i ‚àà L), 1 ‚â§ i), List.length L ‚â§ List.sum L","name":"List.length_le_sum_of_one_le","isProp":true,"docString":"If all elements in a list are bounded below by `1`, then the length of the list is bounded\nby the sum of the elements. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G ‚Üí* N) (s : Set G),\n  Subgroup.map f (Subgroup.closure s) = Subgroup.closure (‚Üëf '' s)","name":"MonoidHom.map_closure","isProp":true,"docString":"The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup\ngenerated by the image of the set. "},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_2} {N : Type u_1} [inst : CommMonoid M] [inst_1 : OrderedCommMonoid N] (f : (a : M) ‚Üí N)\n  (h_one : f 1 = 1) (h_mul : ‚àÄ (x : M) (y : M), f (x * y) ‚â§ f x * f y) (s : Finset Œπ) (g : (a : Œπ) ‚Üí M),\n  f (Finset.prod s fun (i : Œπ) ‚Ü¶ g i) ‚â§ Finset.prod s fun (i : Œπ) ‚Ü¶ f (g i)","name":"Finset.le_prod_of_submultiplicative","isProp":true,"docString":"If `f : M ‚Üí N` is a submultiplicative function, `f (x * y) ‚â§ f x * f y`, `f 1 = 1`, and `g i`,\n`i ‚àà s`, is a finite family of elements of `M`, then `f (‚àè i in s, g i) ‚â§ ‚àè i in s, f (g i)`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedCoheytingAlgebra Œ±] (a : Œ±) (b : Œ±), b \\ a ‚äî a = b ‚äî a","name":"sup_sdiff_self_left","isProp":true,"docString":"**Alias** of `sdiff_sup_self`."},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï} {r : ‚Ñï} {b : ‚Ñï} (hp : Nat.Prime p) (hbn : Nat.log p n < b),\n  (p ^ r ‚à£ Nat.factorial n : Prop) ‚Üî (r ‚â§ Finset.sum (Finset.Ico 1 b) fun (i : ‚Ñï) ‚Ü¶ n / p ^ i : Prop)","name":"Nat.Prime.pow_dvd_factorial_iff","isProp":true,"docString":"A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\nThis sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Zero Œ±] [inst_1 : One Œ±] [inst_2 : LE Œ±] [self : ZeroLEOneClass Œ±], 0 ‚â§ 1","name":"ZeroLEOneClass.zero_le_one","isProp":true,"docString":"Zero is less than or equal to one. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  [inst_3 : IsAntisymm Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1] (h : a ‚äÜ b), (a ‚äÇ b : Prop) ‚à® (a = b : Prop)","name":"HasSubset.Subset.ssubset_or_eq","isProp":true,"docString":"**Alias** of `ssubset_or_eq_of_subset`."},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú],\n  Filter.Tendsto (fun (x : ùïú) ‚Ü¶ x‚Åª¬π) (nhdsWithin 0 (Set.Ioi 0)) Filter.atTop","name":"tendsto_inv_zero_atTop","isProp":true,"docString":"The function `x ‚Ü¶ x‚Åª¬π` tends to `+‚àû` on the right of `0`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : DecidableEq Œπ] (f : (a : Œπ) ‚Üí Œ±)\n  {p : (a : Finset Œπ) ‚Üí Prop} (s : Finset Œπ) (h0 : p ‚àÖ)\n  (step :\n    ‚àÄ (a : Œπ) (s : Finset Œπ) (a_1 : ¬¨(a ‚àà s : Prop)) (a_2 : ‚àÄ (x : Œπ) (a_2 : x ‚àà s), f a ‚â§ f x) (a_3 : p s),\n      p (insert a s)),\n  p s","name":"Finset.induction_on_min_value","isProp":true,"docString":"Induction principle for `Finset`s in any type from which a given function `f` maps to a linearly\nordered type : a predicate is true on all `s : Finset Œ±` provided that:\n\n* it is true on the empty `Finset`,\n* for every `s : Finset Œ±` and an element `a` such that for elements of `s` denoted by `x` we have\n  `f a ‚â§ f x`, `p s` implies `p (insert a s)`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Setoid Œ±] [inst_1 : TopologicalSpace Œ±] {f : (a : Œ≤) ‚Üí Œ±} (hf : DenseRange f),\n  DenseRange (Quotient.mk' ‚àò f)","name":"DenseRange.quotient","isProp":true,"docString":"The composition of `Quotient.mk'` and a function with dense range has dense range. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s) {x : E} {y : E} (hx : x ‚àà closure s) (hy : y ‚àà interior s) {t : ùïú} (ht : t ‚àà Set.Ioc 0 1),\n  x + t ‚Ä¢ (y - x) ‚àà interior s","name":"Convex.add_smul_sub_mem_interior'","isProp":true,"docString":"If `x ‚àà closure s` and `y ‚àà interior s`, then the segment `(x, y]` is included in `interior s`.\n"},{"type":"‚àÄ {p : ‚Ñï}, padicValNat p 0 = 0","name":"padicValNat.zero","isProp":true,"docString":"`padicValNat p 0` is `0` for any `p`. "},{"type":"‚àÄ {Œ± : Type u} [self : Semiring Œ±], NatCast.natCast 0 = 0","name":"Semiring.natCast_zero","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` sends `0 : ‚Ñï` to `0 : R`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : 0 ‚â§ a) (hb : 0 < b), 0 < a + b","name":"add_pos_of_nonneg_of_pos","isProp":true,"docString":"**Alias** of `Left.add_pos_of_nonneg_of_pos`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {J : Type}\n  [inst_2 : Fintype J] {f : (a : J) ‚Üí C} [inst_3 : CategoryTheory.Limits.HasBiproduct f],\n  (Finset.sum Finset.univ fun (j : J) ‚Ü¶ CategoryTheory.Limits.biproduct.œÄ f j ‚â´ CategoryTheory.Limits.biproduct.Œπ f j) =\n    ùüô (‚®Å f)","name":"CategoryTheory.Limits.biproduct.total","isProp":true,"docString":"In any preadditive category, any biproduct satsifies\n`‚àë j : J, biproduct.œÄ f j ‚â´ biproduct.Œπ f j = ùüô (‚®Å f)`\n"},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} {F : Type u_3} [inst : AddZeroClass M] [inst_1 : AddZeroClass N]\n  [inst_2 : AddMonoidHomClass F M N] (f : F) {x : M} (hx : ‚àÉ (y : M), x + y = 0), ‚àÉ (y : N), ‚Üëf x + y = 0","name":"AddMonoidHom.map_exists_right_neg","isProp":true,"docString":"Given an AddMonoid homomorphism `f : M ‚Üí+ N` and an element `x : M`, if `x` has\na right inverse, then `f x` has a right inverse too."},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) {s : Set Œ±} [inst : UniformSpace Œ≤] (ùîñ : Set (Set Œ±)) (h : s ‚àà ùîñ),\n  UniformContinuous (‚ÜëUniformFun.ofFun ‚àò Set.restrict s ‚àò ‚Üë(UniformOnFun.toFun ùîñ))","name":"UniformOnFun.uniformContinuous_restrict","isProp":true,"docString":"If `S ‚àà ùîñ`, then the restriction to `S` is a uniformly continuous map from `Œ± ‚Üí·µ§[ùîñ] Œ≤` to\n`‚Ü•S ‚Üí·µ§ Œ≤`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : CommGroup Œ±] (s : Finset Œ±) {t : Finset Œ±} (ht : Finset.Nonempty t),\n  ‚àÉ (u : Finset Œ±), (Finset.card u * Finset.card t ‚â§ Finset.card (s * t) : Prop) ‚àß (s ‚äÜ u * t / t : Prop)","name":"Finset.exists_subset_mul_div","isProp":true,"docString":"**Ruzsa's covering lemma**. "},{"type":"‚àÄ (x : ‚Ñù), Real.sinh x = (Real.exp x - Real.exp (-x)) / 2","name":"Real.sinh_eq","isProp":true,"docString":"The definition of `sinh` in terms of `exp`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CompleteLattice Œ±] (a : Œ±) (f : (a : Œ≤) ‚Üí Œ±),\n  (inf·µ¢ fun (o : Option Œ≤) ‚Ü¶ Option.elim o a f) = a ‚äì inf·µ¢ fun (b : Œ≤) ‚Ü¶ f b","name":"inf·µ¢_option_elim","isProp":true,"docString":"A version of `inf·µ¢_option` useful for rewriting right-to-left. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {s : Set Œ≤} (a : IsCompact s) (a : Set.Nonempty s)\n  {f : (a : Œ≤) ‚Üí Œ±} (a : ContinuousOn f s), ‚àÉ (x : Œ≤), (x ‚àà s : Prop) ‚àß (IsMaxOn f s x : Prop)","name":"IsCompact.exists_isMaxOn","isProp":true,"docString":"The **extreme value theorem**: a continuous function realizes its maximum on a compact set. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {p : (a : Œ±) ‚Üí Prop} (x : Subtype p) (y : Subtype p),\n  edist x y = edist ‚Üëx ‚Üëy","name":"Subtype.edist_eq","isProp":true,"docString":"The extended psuedodistance on a subset of a pseudoemetric space is the restriction of\nthe original pseudodistance, by definition "},{"type":"‚àÄ {R : Type u_1} [inst : TopologicalSpace R] [inst_1 : Star R] [self : ContinuousStar R], Continuous star","name":"ContinuousStar.continuous_star","isProp":true,"docString":"The `star` operator is continuous. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (s : Set M) {p : (x : M) ‚Üí (a : x ‚àà Subsemigroup.closure s) ‚Üí Prop}\n  (Hs :\n    ‚àÄ (x : M) (h : x ‚àà s),\n      p x ((Subsemigroup.subset_closure h=:x ‚àà ‚Üë(Subsemigroup.closure s))=:x ‚àà ‚Üë(Subsemigroup.closure s)))\n  (Hmul :\n    ‚àÄ (x : M) (hx : x ‚àà Subsemigroup.closure s) (y : M) (hy : y ‚àà Subsemigroup.closure s) (a : p x hx) (a : p y hy),\n      p (x * y) ((mul_mem hx hy=:x * y ‚àà Subsemigroup.closure s)=:x * y ‚àà Subsemigroup.closure s))\n  {x : M} (hx : x ‚àà Subsemigroup.closure s), p x hx","name":"Subsemigroup.closure_induction'","isProp":true,"docString":"A dependent version of `Subsemigroup.closure_induction`.  "},{"type":"‚àÄ {Œ± : Type u_3} [inst : Lattice Œ±] [inst_1 : IsModularLattice Œ±] {Œ≤ : Type u_1} {Œ≥ : Type u_2} [inst_2 : Preorder Œ≤]\n  [inst_3 : PartialOrder Œ≥] (h‚ÇÅ : WellFounded fun (x : Œ≤) (x_1 : Œ≤) ‚Ü¶ x > x_1)\n  (h‚ÇÇ : WellFounded fun (x : Œ≥) (x_1 : Œ≥) ‚Ü¶ x > x_1) (K : Œ±) (f‚ÇÅ : (a : Œ≤) ‚Üí Œ±) (f‚ÇÇ : (a : Œ±) ‚Üí Œ≤) (g‚ÇÅ : (a : Œ≥) ‚Üí Œ±)\n  (g‚ÇÇ : (a : Œ±) ‚Üí Œ≥) (gci : GaloisCoinsertion f‚ÇÅ f‚ÇÇ) (gi : GaloisInsertion g‚ÇÇ g‚ÇÅ) (hf : ‚àÄ (a : Œ±), f‚ÇÅ (f‚ÇÇ a) = a ‚äì K)\n  (hg : ‚àÄ (a : Œ±), g‚ÇÅ (g‚ÇÇ a) = a ‚äî K), WellFounded fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x > x_1","name":"wellFounded_gt_exact_sequence","isProp":true,"docString":"A generalization of the theorem that if `N` is a submodule of `M` and\n`N` and `M / N` are both Noetherian, then `M` is Noetherian.  "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [self : OreLocalization.OreSet S] (r : R) (s : { x : R // x ‚àà S }),\n  r * ‚Üë(OreLocalization.OreSet.oreDenom r s) = ‚Üës * OreLocalization.OreSet.oreNum r s","name":"OreLocalization.OreSet.ore_eq","isProp":true,"docString":"The Ore condition of a fraction, expressed in terms of `oreNum` and `oreDenom`. "},{"type":"‚àÄ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : ContinuousSMul ‚Ñù E] {F : Type u_3} [inst_4 : AddCommGroup F] [inst_5 : Module ‚Ñù F]\n  [inst_6 : TopologicalSpace F] [inst_7 : ContinuousSMul ‚Ñù F] [inst_8 : T2Space F] {G : Type u_1}\n  [inst_9 : AddMonoidHomClass G E F] (f : G) (hf : Continuous ‚Üëf) (c : ‚Ñù) (x : E), ‚Üëf (c ‚Ä¢ x) = c ‚Ä¢ ‚Üëf x","name":"map_real_smul","isProp":true,"docString":"A continuous additive map between two vector spaces over `‚Ñù` is `‚Ñù`-linear. "},{"type":"‚àÄ (œÉ : Type u_1) (R : Type u_2) [inst : CommSemiring R] [inst_1 : Fintype œÉ],\n  MvPolynomial.esymm œÉ R = Multiset.esymm (Multiset.map MvPolynomial.X (Finset.val Finset.univ))","name":"MvPolynomial.esymm_eq_multiset_esymm","isProp":true,"docString":"The `n`th elementary symmetric `MvPolynomial œÉ R` is obtained by evaluating the\n`n`th elementary symmetric at the `Multiset` of the monomials "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {u : (a : Œ≤) ‚Üí Œ±} (l : LowerAdjoint u)\n  (x : Œ±), x ‚â§ u (LowerAdjoint.toFun l x)","name":"LowerAdjoint.le_closure","isProp":true,"docString":"Every element is less than its closure. This property is sometimes referred to as extensivity or\ninflationarity. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {e : Œ± ‚âÉ Œ≤} {s : Set Œ±} {t : Set Œ≤} (a : Set.BijOn (‚Üë(Equiv.symm e)) t s),\n  Set.BijOn (‚Üëe) s t","name":"Set.BijOn.of_equiv_symm","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.bijOn_symm`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Mul Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} {d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d), a * c < b * d","name":"Left.mul_lt_mul","isProp":true,"docString":"Only assumes left strict covariance. "},{"type":"‚àÄ (A : Finset ‚Ñï) (B : Finset ‚Ñï),\n  ((Finset.sum A fun (i : ‚Ñï) ‚Ü¶ 2 ^ i) ‚â§ Finset.sum B fun (i : ‚Ñï) ‚Ü¶ 2 ^ i : Prop) ‚Üî\n    (Finset.toColex A ‚â§ Finset.toColex B : Prop)","name":"Colex.sum_two_pow_le_iff_lt","isProp":true,"docString":"For subsets of ‚Ñï, we can show that colex is equivalent to binary. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {s : Finset Œ±} (hf : Equiv.Perm.IsCycleOn f ‚Üës),\n  s √ó·∂† s =\n    Finset.disjUnion·µ¢ (Finset.range (Finset.card s))\n      (fun (k : ‚Ñï) ‚Ü¶\n        Finset.map\n          { toFun := fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i),\n            inj' :=\n              (fun (i : Œ±) ‚Ü¶\n                (_ :\n                  ‚àÄ (j : Œ±) (h : (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i = (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) j),\n                    Prod.fst ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i) =\n                      Prod.fst\n                        ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i))\n                          j))=:‚àÄ (i : Œ±) (j : Œ±)\n                  (h : (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i = (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) j),\n                  Prod.fst ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i) = Prod.fst ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) j)) }\n          s)\n      ((Finset.product_self_eq_disj_Union_perm_aux\n            hf=:Set.PairwiseDisjoint ‚Üë(Finset.range (Finset.card s)) fun (k : ‚Ñï) ‚Ü¶\n            Finset.map\n              { toFun := fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i),\n                inj' :=\n                  (fun (i : Œ±) ‚Ü¶\n                    (_ :\n                      ‚àÄ (j : Œ±) (h : (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i = (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) j),\n                        Prod.fst ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i) =\n                          Prod.fst\n                            ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i))\n                              j))=:‚àÄ (i : Œ±) (j : Œ±)\n                      (h : (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i = (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) j),\n                      Prod.fst ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i) = Prod.fst ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) j)) }\n              s)=:Set.PairwiseDisjoint ‚Üë(Finset.range (Finset.card s)) fun (k : ‚Ñï) ‚Ü¶\n          Finset.map\n            { toFun := fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i),\n              inj' :=\n                (fun (i : Œ±) ‚Ü¶\n                  (_ :\n                    ‚àÄ (j : Œ±) (h : (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i = (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) j),\n                      Prod.fst ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i) =\n                        Prod.fst\n                          ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i))\n                            j))=:‚àÄ (i : Œ±) (j : Œ±)\n                    (h : (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i = (fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) j),\n                    Prod.fst ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) i) = Prod.fst ((fun (i : Œ±) ‚Ü¶ (i, ‚Üë(f ^ k) i)) j)) }\n            s)","name":"Finset.product_self_eq_disjUnion_perm","isProp":true,"docString":"We can partition the square `s √óÀ¢ s` into shifted diagonals as such:\n```\n01234\n40123\n34012\n23401\n12340\n```\n\nThe diagonals are given by the cycle `f`.\n"},{"type":"‚àÄ {k : Type u_1} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 0) (b‚ÇÅ : P) (b‚ÇÇ : P),\n  ‚Üë(Finset.weightedVSubOfPoint s p b‚ÇÅ) w = ‚Üë(Finset.weightedVSubOfPoint s p b‚ÇÇ) w","name":"Finset.weightedVSubOfPoint_eq_of_sum_eq_zero","isProp":true,"docString":"The weighted sum is independent of the base point when the sum of\nthe weights is 0. "},{"type":"‚àÄ {Œ± : Sort u_3} {Œ≤ : Sort u_1} {Œ≥ : Sort u_2} {g : (a : Œ≤) ‚Üí Œ≥} (hg : Function.Injective g),\n  Function.Injective ((fun (x : (a : Œ≤) ‚Üí Œ≥) (x_1 : (a : Œ±) ‚Üí Œ≤) ‚Ü¶ x ‚àò x_1) g)","name":"Function.Injective.comp_left","isProp":true,"docString":"Composition by an injective function on the left is itself injective. "},{"type":"‚àÄ {Œ± : Type u_3} {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Monoid Œ±] [inst_4 : DistribMulAction Œ± M] [inst_5 : SMulCommClass Œ± R M] (a : Œ±) (S : Submodule R M)\n  (T : Submodule R M), a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T","name":"Submodule.smul_sup'","isProp":true,"docString":"See also `Submodule.smul_sup`. "},{"type":"‚àÄ {R : Type u} {n : ‚Ñï} {M : (a : Fin (Nat.succ n)) ‚Üí Type v} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Fin (Nat.succ n)) ‚Üí AddCommMonoid (M i)] [inst_2 : AddCommMonoid M‚ÇÇ]\n  [inst_3 : (i : Fin (Nat.succ n)) ‚Üí Module R (M i)] [inst_4 : Module R M‚ÇÇ] (f : MultilinearMap R M M‚ÇÇ)\n  (m : (i : Fin n) ‚Üí M (Fin.succ i)) (c : R) (x : M 0), ‚Üëf (Fin.cons (c ‚Ä¢ x) m) = c ‚Ä¢ ‚Üëf (Fin.cons x m)","name":"MultilinearMap.cons_smul","isProp":true,"docString":"In the specific case of multilinear maps on spaces indexed by `Fin (n+1)`, where one can build\nan element of `‚àÄ (i : Fin (n+1)), M i` using `cons`, one can express directly the multiplicativity\nof a multilinear map along the first variable. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SecondCountableTopology Œ±] {Œπ : Type u_1}\n  (s : (a : Œπ) ‚Üí Set Œ±) (H : ‚àÄ (i : Œπ), IsOpen (s i)),\n  ‚àÉ (T : Set Œπ),\n    (Set.Countable T : Prop) ‚àß\n      ((Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà T) ‚Ü¶ s i) = Set.union·µ¢ fun (i : Œπ) ‚Ü¶ s i : Prop)","name":"TopologicalSpace.isOpen_union·µ¢_countable","isProp":true,"docString":"In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. "},{"type":"‚àÄ {S : Type u_1} {M : Type u_2} [inst : Zero M] [inst_1 : SetLike S M] [self : ZeroMemClass S M] (s : S), 0 ‚àà s","name":"ZeroMemClass.zero_mem","isProp":true,"docString":"By definition, if we have `ZeroMemClass S M`, we have `0 ‚àà s` for all `s : S`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : Monotone f),\n  Antitone (‚ÜëOrderDual.toDual ‚àò f)","name":"Monotone.dual_right","isProp":true,"docString":"**Alias** of the reverse direction of `antitone_toDual_comp_iff`."},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : CommMonoid Œ≤] {n : ‚Ñï} (f : (a : Fin (n + 1)) ‚Üí Œ≤),\n  (Finset.prod Finset.univ fun (i : Fin (n + 1)) ‚Ü¶ f i) =\n    (Finset.prod Finset.univ fun (i : Fin n) ‚Ü¶ f (‚ÜëFin.castSucc i)) * f (Fin.last n)","name":"Fin.prod_univ_castSucc","isProp":true,"docString":"A product of a function `f : Fin (n + 1) ‚Üí Œ≤` over all `Fin (n + 1)`\nis the product of `f (Fin.last n)` plus the remaining product "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±},\n  (0 < -a : Prop) ‚Üî (a < 0 : Prop)","name":"Right.neg_pos_iff","isProp":true,"docString":"Uses `right` co(ntra)variant."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop}\n  [inst : IsTrichotomous Œ± r] [inst : IsIrrefl Œ≤ s] (f : r ‚Üír s), Function.Injective ‚Üëf","name":"RelHom.injective_of_increasing","isProp":true,"docString":"An increasing function is injective "},{"type":"‚àÄ {B : Type u_2} {S : B} {M : Type u_1} [inst : CommMonoid M] [inst_1 : SetLike B M] [inst_2 : SubmonoidClass B M]\n  {Œπ : Type u_3} {t : Finset Œπ} {f : (a : Œπ) ‚Üí M} (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà S),\n  (Finset.prod t fun (c : Œπ) ‚Ü¶ f c) ‚àà S","name":"prod_mem","isProp":true,"docString":"Product of elements of a submonoid of a `CommMonoid` indexed by a `Finset` is in the\nsubmonoid. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {p : Filter Œπ}\n  {p' : Filter Œ±} {c : Œ≤},\n  (Filter.Tendsto (‚ÜøF) (Filter.prod p p') (nhds c) : Prop) ‚Üî (TendstoUniformlyOnFilter F (fun (x : Œ±) ‚Ü¶ c) p p' : Prop)","name":"tendsto_prod_filter_iff","isProp":true,"docString":"Uniform convergence on a filter `p'` to a constant function is equivalent to convergence in\n`p √ó·∂† p'`. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : Nonempty J] {c : CategoryTheory.Limits.Cocone (CategoryTheory.Limits.parallelFamily f)}\n  (i : CategoryTheory.Limits.IsColimit c),\n  CategoryTheory.Epi ((CategoryTheory.Limits.Cocone.Œπ c).app CategoryTheory.Limits.WalkingParallelFamily.one)","name":"CategoryTheory.Limits.epi_of_isColimit_parallelFamily","isProp":true,"docString":"The wide coequalizer morphism in any colimit cocone is an epimorphism. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} {b : Œ±} (ha : 0 < a) (hb : 0 < b),\n  (1 / a < 1 / b : Prop) ‚Üî (b < a : Prop)","name":"one_div_lt_one_div","isProp":true,"docString":"For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and\n`lt_of_one_div_lt_one_div` "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R} (hB : LinearMap.IsRefl B) {W : Submodule R M}\n  (hW : Disjoint W (Submodule.orthogonalBilin W B)), LinearMap.Nondegenerate (LinearMap.domRestrict‚ÇÅ‚ÇÇ B W W)","name":"LinearMap.nondegenerateRestrictOfDisjointOrthogonal","isProp":true,"docString":"The restriction of a reflexive bilinear form `B` onto a submodule `W` is\nnondegenerate if `W` has trivial intersection with its orthogonal complement,\nthat is `Disjoint W (W.orthogonalBilin B)`. "},{"type":"‚àÄ {Œ± : Type u} [self : BooleanAlgebra Œ±] (a : Œ±), ‚ä• ‚â§ a","name":"BooleanAlgebra.bot_le","isProp":true,"docString":"`‚ä•` is the least element "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : IsPredArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ioc m n), r i (Order.pred i))\n  (hnm : m ‚â§ n), Relation.ReflTransGen r n m","name":"reflTransGen_of_pred_of_ge","isProp":true,"docString":"For `m ‚â§ n`, `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ pred i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ (C : Type u‚ÇÅ) [inst : CategoryTheory.Category C], Quiver.IsThin (CategoryTheory.ThinSkeleton C)","name":"CategoryTheory.ThinSkeleton.thin","isProp":true,"docString":"The thin skeleton is thin. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {X : C} {Y : C}\n  [inst_2 : CategoryTheory.Simple X] {f : X ‚ü∂ Y} [inst_3 : CategoryTheory.Epi f] (w : f ‚â† 0), CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_epi_of_nonzero","isProp":true,"docString":"A nonzero epimorphism from a simple object is an isomorphism. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C] {J' : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category J'] (e : J ‚âå J') [inst : CategoryTheory.Limits.HasLimitsOfShape J C],\n  CategoryTheory.Limits.HasLimitsOfShape J' C","name":"CategoryTheory.Limits.hasLimitsOfShape_of_equivalence","isProp":true,"docString":"We can transport limits of shape `J` along an equivalence `J ‚âå J'`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {f : Filter Œ±} {s : (a : ‚Ñï) ‚Üí Set Œ±} (hs : Filter.HasAntitoneBasis f s) {r : (a : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí Prop}\n  (hr : ‚àÄ (m : ‚Ñï), Filter.Eventually (fun (n : ‚Ñï) ‚Ü¶ r m n) Filter.atTop),\n  ‚àÉ (œÜ : (a : ‚Ñï) ‚Üí ‚Ñï),\n    (StrictMono œÜ : Prop) ‚àß\n      ((‚àÄ ‚¶Ém : ‚Ñï‚¶Ñ ‚¶Én : ‚Ñï‚¶Ñ (a : m < n), r (œÜ m) (œÜ n) : Prop) ‚àß (Filter.HasAntitoneBasis f (s ‚àò œÜ) : Prop) : Prop)","name":"Filter.HasAntitoneBasis.subbasis_with_rel","isProp":true,"docString":"Given an antitone basis `s : ‚Ñï ‚Üí Set Œ±` of a filter, extract an antitone subbasis `s ‚àò œÜ`,\n`œÜ : ‚Ñï ‚Üí ‚Ñï`, such that `m < n` implies `r (œÜ m) (œÜ n)`. This lemma can be used to extract an\nantitone basis with basis sets decreasing \"sufficiently fast\". "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {s : Set Œ±} {t : (a : Œ±) ‚Üí (a : a ‚àà s) ‚Üí Set Œ≤} (hs : Set.Countable s)\n  (a : ‚àÄ (a : Œ±) (ha : a ‚àà s), Set.Countable (t a ha)),\n  Set.Countable (Set.union·µ¢ fun (a : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : a ‚àà s) ‚Ü¶ t a h)","name":"Set.Countable.bunion·µ¢","isProp":true,"docString":"**Alias** of the reverse direction of `Set.Countable.bunion·µ¢_iff`."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommMonoid M] [inst_1 : CommSemiring R] {S : Set M}\n  (hS : Submonoid.closure S = ‚ä§), Function.Surjective ‚Üë(MvPolynomial.aeval fun (s : ‚ÜëS) ‚Ü¶ ‚Üë(MonoidAlgebra.of R M) ‚Üës)","name":"MonoidAlgebra.mvPolynomial_aeval_of_surjective_of_closure","isProp":true,"docString":"If a set `S` generates a monoid `M`, then the image of `M` generates, as algebra,\n`MonoidAlgebra R M`. "},{"type":"‚àÄ {Œ± : Type u_1} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} {v : (a : Œ±) ‚Üí ‚Ñù}\n  (a : (fun (x : Œ±) ‚Ü¶ abs (u x)) =O[l] fun (x : Œ±) ‚Ü¶ abs (v x)), u =O[l] v","name":"Asymptotics.IsBigO.of_abs_abs","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigO_abs_abs`."},{"type":"‚àÄ {Œπ : Type w} {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Nontrivial R] [inst_4 : IsNoetherian R M] {v : (a : Œπ) ‚Üí M} (hv : LinearIndependent R v), Finite Œπ","name":"LinearIndependent.finite_of_isNoetherian","isProp":true,"docString":"A linearly-independent family of vectors in a module over a non-trivial ring must be finite if\nthe module is Noetherian. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] (s : Subring R) {Œπ : Type u_2} {t : Finset Œπ} {f : (a : Œπ) ‚Üí R}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà s), (Finset.sum t fun (i : Œπ) ‚Ü¶ f i) ‚àà s","name":"Subring.sum_mem","isProp":true,"docString":"Sum of elements in a `Subring` of a `Ring` indexed by a `Finset`\nis in the `Subring`. "},{"type":"‚àÄ {m : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} {c : ‚Ñï} (hmc : Nat.gcd m c = 1) (h : c * a ‚â° c * b [MOD m]), a ‚â° b [MOD m]","name":"Nat.ModEq.cancel_left_of_coprime","isProp":true,"docString":"A common factor that's coprime with the modulus can be cancelled from a `ModEq` "},{"type":"‚àÄ {m : Type u_1} [inst : DecidableEq m] [inst_1 : Fintype m] {R : Type v} [inst_2 : CommRing R] (M : Matrix m m R)\n  (N : Matrix m m R) (P : Matrix m m R),\n  Matrix.det (Matrix.mul (Matrix.mul M N) P) = Matrix.det (Matrix.mul (Matrix.mul M P) N)","name":"Matrix.det_mul_right_comm","isProp":true,"docString":"On square matrices, `mul_right_comm` applies under `det`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasCoequalizer f g], CategoryTheory.Epi (CategoryTheory.Limits.coequalizer.œÄ f g)","name":"CategoryTheory.Limits.coequalizer.œÄ_epi","isProp":true,"docString":"A coequalizer morphism is an epimorphism "},{"type":"‚àÄ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {B : V ‚Üí‚Çó[K] V ‚Üí‚Çó[K] K}\n  {x : V} (hx : ¬¨(LinearMap.IsOrtho B x x : Prop)),\n  IsCompl (Submodule.span K {x}) (Submodule.orthogonalBilin (Submodule.span K {x}) B)","name":"LinearMap.isCompl_span_singleton_orthogonal","isProp":true,"docString":"Given a bilinear form `B` and some `x` such that `B x x ‚â† 0`, the span of the singleton of `x`\nis complement to its orthogonal complement. "},{"type":"‚àÄ (u : PNat.XgcdType) (hr : PNat.XgcdType.r u ‚â† 0), sizeOf (PNat.XgcdType.step u) < sizeOf u","name":"PNat.XgcdType.step_wf","isProp":true,"docString":"We will apply the above step recursively.  The following result\nis used to ensure that the process terminates. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} {Z : C} {œÄ : Y ‚ü∂ Z}\n  (self : CategoryTheory.IsSplitCoequalizer f g œÄ), CategoryTheory.IsSplitCoequalizer.leftSection self ‚â´ g = ùüô Y","name":"CategoryTheory.IsSplitCoequalizer.leftSection_bottom","isProp":true,"docString":"`leftSection` splits `g` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasBinaryBiproduct X Y],\n  CategoryTheory.BicartesianSq 0 0 CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.inr","name":"CategoryTheory.BicartesianSq.of_has_biproduct‚ÇÇ","isProp":true,"docString":"```\n   0 -----0---> X\n   |            |\n   0           inl\n   |            |\n   v            v\n   Y --inr--> X ‚äû Y\n```\nis a bicartesian square.\n"},{"type":"‚àÄ {Œ± : Type u} {G : Type u_1} [inst : AddGroup G] (f : FreeAddGroup Œ± ‚Üí+ G) (g : FreeAddGroup Œ± ‚Üí+ G)\n  (h : ‚àÄ (a : Œ±), ‚Üëf (FreeAddGroup.of a) = ‚Üëg (FreeAddGroup.of a)), f = g","name":"FreeAddGroup.ext_hom","isProp":true,"docString":"Two homomorphisms out of a free additive group are equal if they are\nequal on generators. See note [partially-applied ext lemmas]."},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {i : D ‚•§ C}\n  [inst_2 : CategoryTheory.Reflective i] (X : C),\n  (CategoryTheory.Adjunction.unit (CategoryTheory.Adjunction.ofRightAdjoint i)).app\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor i)\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.leftAdjoint i)) X)) =\n    Prefunctor.map (CategoryTheory.Functor.toPrefunctor i)\n      (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.leftAdjoint i))\n        ((CategoryTheory.Adjunction.unit (CategoryTheory.Adjunction.ofRightAdjoint i)).app X))","name":"CategoryTheory.unit_obj_eq_map_unit","isProp":true,"docString":"For a reflective functor `i` (with left adjoint `L`), with unit `Œ∑`, we have `Œ∑_iL = iL Œ∑`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : UniformSpace Œ±] [inst_1 : SeparatedSpace Œ±] {s : Set Œ±} (h : IsComplete s), IsClosed s","name":"IsComplete.isClosed","isProp":true,"docString":"In a separated space, a complete set is closed. "},{"type":"‚àÄ {Œπ : Sort u_1} (f : (a : Œπ) ‚Üí Cardinal) [inst : IsEmpty Œπ], sup·µ¢ f = 0","name":"Cardinal.sup·µ¢_of_empty","isProp":true,"docString":"A variant of `csup·µ¢_of_empty` but with `0` on the RHS for convenience "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : b < a‚Åª¬π * c), a * b < c","name":"mul_lt_of_lt_inv_mul","isProp":true,"docString":"**Alias** of the forward direction of `lt_inv_mul_iff_mul_lt`."},{"type":"‚àÄ {R : Type u} [inst : CommRing R] {P : Ideal R} (H : Ideal.IsPrime P), Ideal.IsPrime (Ideal.map Polynomial.C P)","name":"Ideal.isPrime_map_C_of_isPrime","isProp":true,"docString":"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {Œ∫ : Type u_3} {C : (a : (a : Œπ) ‚Üí Option Œ±) ‚Üí Œ∫}\n  (self : Combinatorics.Line.ColorFocused C),\n  Multiset.Nodup (Multiset.map Combinatorics.Line.AlmostMono.color (Combinatorics.Line.ColorFocused.lines self))","name":"Combinatorics.Line.ColorFocused.distinct_colors","isProp":true,"docString":"The proposition that all lines in a color-focused collection of lines have distinct colors. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CoheytingAlgebra Œ±] {a : Œ±} {b : Œ±} (a_1 : Codisjoint b a), Ôø¢a ‚â§ b","name":"Codisjoint.hnot_le_left","isProp":true,"docString":"**Alias** of the reverse direction of `hnot_le_iff_codisjoint_left`."},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ‚àÉ (V : OpenAddSubgroup R), ‚ÜëV * ‚ÜëV ‚äÜ ‚ÜëU","name":"NonarchimedeanRing.mul_subset","isProp":true,"docString":"An open subgroup of a nonarchimedean ring contains the square of another one. "},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±] {K : Set Œ±} {U : Set Œ±} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ‚äÜ U),\n  ‚àÉ (V : Set (Œ± √ó Œ±)),\n    (V ‚àà uniformity Œ± : Prop) ‚àß ((IsOpen V : Prop) ‚àß (‚àÄ (x : Œ±) (a : x ‚àà K), UniformSpace.ball x V ‚äÜ U : Prop) : Prop)","name":"lebesgue_number_of_compact_open","isProp":true,"docString":"A useful consequence of the Lebesgue number lemma: given any compact set `K` contained in an\nopen set `U`, we can find an (open) entourage `V` such that the ball of size `V` about any point of\n`K` is contained in `U`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œπ} (hs : Set.Finite s) {f : (a : Œπ) ‚Üí Set Œ±}\n  (h : ‚àÄ (i : Œπ) (a : i ‚àà s), IsGŒ¥ (f i)), IsGŒ¥ (Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà s) ‚Ü¶ f i)","name":"isGŒ¥_bunion·µ¢","isProp":true,"docString":"The union of finitely many GŒ¥ sets is a GŒ¥ set. "},{"type":"‚àÄ {Œ± : Type u} {J : Type w} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J]\n  [inst_2 : SemilatticeInf Œ±] [inst_3 : OrderTop Œ±] (F : J ‚•§ Œ±),\n  CategoryTheory.Limits.limit F = Finset.inf Finset.univ (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F))","name":"CategoryTheory.Limits.CompleteLattice.finite_limit_eq_finset_univ_inf","isProp":true,"docString":"The limit of a functor from a finite diagram into a `SemilatticeInf` with `OrderTop` is the\ninfimum of the objects in the image.\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Monovary f g),\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)) ‚â§ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i","name":"Monovary.sum_smul_comp_perm_le_sum_smul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when\n`f` and `g` monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : LinearOrder Œ≤] [inst_1 : NoMaxOrder Œ≤] {u : (a : ‚Ñï) ‚Üí Œ≤}\n  (hu : Filter.Tendsto u Filter.atTop Filter.atTop) (N : ‚Ñï),\n  ‚àÉ (n : ‚Ñï), (n ‚â• N : Prop) ‚àß (‚àÄ (k : ‚Ñï) (a : k < n), u k < u n : Prop)","name":"Filter.high_scores","isProp":true,"docString":"If `u` is a sequence which is unbounded above,\nthen after any point, it reaches a value strictly greater than all previous values.\n"},{"type":"‚àÄ {ùíú : Type u_2} [inst : CategoryTheory.Category ùíú] [inst_1 : CategoryTheory.Preadditive ùíú]\n  [inst_2 : CategoryTheory.Limits.HasKernels ùíú] [inst_3 : CategoryTheory.Limits.HasImages ùíú]\n  [inst_4 : CategoryTheory.Limits.HasBinaryBiproducts ùíú] (A : ùíú) (B : ùíú),\n  CategoryTheory.Exact CategoryTheory.Limits.biprod.inl CategoryTheory.Limits.biprod.snd","name":"CategoryTheory.exact_inl_snd","isProp":true,"docString":"The sequence `A ‚ü∂ A ‚äû B ‚ü∂ B` is exact. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {b : Œ±} (hs : Set.Nonempty s)\n  (h_is_ub : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), a ‚â§ b) (h_b_le_ub : ‚àÄ (ub : Œ±) (a : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), a ‚â§ ub), b ‚â§ ub),\n  sup‚Çõ s = b","name":"csup‚Çõ_eq_of_is_forall_le_of_forall_le_imp_ge","isProp":true,"docString":"Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that\n1) `b` is an upper bound\n2) every other upper bound `b'` satisfies `b ‚â§ b'`."},{"type":"‚àÄ (Œπ : Type u_2) {R : Type u_3} {Œ± : Type u_1} [inst : AddMonoid Œπ] [inst_1 : Monoid R] (l : List Œ±) (fŒπ : (a : Œ±) ‚Üí Œπ)\n  (fA : (a : Œ±) ‚Üí R), List.dProd l fŒπ fA = List.prod (List.map fA l)","name":"List.dProd_monoid","isProp":true,"docString":"When all the indexed types are the same, the dependent product is just the regular product. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {t : CategoryTheory.Limits.Cocone F} (h : CategoryTheory.Limits.IsColimit t) (s : CategoryTheory.Limits.Cocone F),\n  ‚àÉ! (d : CategoryTheory.Limits.Cocone.pt t ‚ü∂ CategoryTheory.Limits.Cocone.pt s),\n    ‚àÄ (j : J), (CategoryTheory.Limits.Cocone.Œπ t).app j ‚â´ d = (CategoryTheory.Limits.Cocone.Œπ s).app j","name":"CategoryTheory.Limits.IsColimit.existsUnique","isProp":true,"docString":"Restating the definition of a colimit cocone in terms of the ‚àÉ! operator. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Subsingleton Œ±] (e : Equiv.Perm Œ±), ‚Üëe = id","name":"Equiv.Perm.coe_subsingleton","isProp":true,"docString":"This cannot be a `simp` lemmas as it incorrectly matches against `e : Œ± ‚âÉ synonym Œ±`, when\n`synonym Œ±` is semireducible. This makes a mess of `multiplicative.of_add` etc. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : a ‚â§ 0) (hb : b ‚â§ 0), a + b ‚â§ 0","name":"Right.add_nonpos","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonpos`."},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (self : AddGroupSeminorm G) (r : G) (s : G),\n  AddGroupSeminorm.toFun self (r + s) ‚â§ AddGroupSeminorm.toFun self r + AddGroupSeminorm.toFun self s","name":"AddGroupSeminorm.add_le'","isProp":true,"docString":"The seminorm is subadditive. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (H : AddSubgroup G) (f : G ‚âÉ+ N),\n  AddSubgroup.map (AddEquiv.toAddMonoidHom f) (AddSubgroup.normalizer H) =\n    AddSubgroup.normalizer (AddSubgroup.map (AddEquiv.toAddMonoidHom f) H)","name":"AddSubgroup.map_equiv_normalizer_eq","isProp":true,"docString":"The image of the normalizer is equal to the normalizer of the image of an\nisomorphism."},{"type":"‚àÄ {a : Prop} {c : Prop} {b : Prop} {d : Prop} (h‚ÇÅ : (a : Prop) ‚Üî (c : Prop)) (h‚ÇÇ : (b : Prop) ‚Üî (d : Prop)),\n  ((a : Prop) ‚Üî (b : Prop) : Prop) ‚Üî ((c : Prop) ‚Üî (d : Prop) : Prop)","name":"Iff.iff","isProp":true,"docString":"**Alias** of `iff_congr`."},{"type":"‚àÄ {Œπ : Type u_2} {Œ≤ : Type u} [inst : AddCommMonoid Œ≤] {Œπ' : Type u_1} [inst_1 : DecidableEq Œπ] (e : Œπ ‚âÉ Œπ')\n  (f : (a : Œπ') ‚Üí Œ≤) {s' : Finset Œπ'} {s : Finset Œπ} (h : s = Finset.image (‚Üë(Equiv.symm e)) s'),\n  (Finset.sum s' fun (i' : Œπ') ‚Ü¶ f i') = Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚Üëe i)","name":"Finset.Equiv.sum_comp_finset","isProp":true,"docString":" Reindexing a sum over a finset along an equivalence.\nSee `Equiv.sum_comp` for the version where `s` and `s'` are `univ`. "},{"type":"‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] {x : F} {y : F} (h : SameRay ‚Ñù x y)\n  (hn : ‚Äñx‚Äñ = ‚Äñy‚Äñ), x = y","name":"SameRay.eq_of_norm_eq","isProp":true,"docString":"If two points on the same ray have the same norm, then they are equal. "},{"type":"‚àÄ {R : Type u} {M‚ÇÇ : Type v‚ÇÇ} {M‚ÇÉ : Type v‚ÇÉ} [inst : Semiring R] [inst_1 : AddCommMonoid M‚ÇÇ] [inst_2 : AddCommMonoid M‚ÇÉ]\n  [inst_3 : Module R M‚ÇÇ] [inst_4 : Module R M‚ÇÉ] {Œπ‚ÇÅ : Type u_1} {Œπ‚ÇÇ : Type u_2} (œÉ : Œπ‚ÇÅ ‚âÉ Œπ‚ÇÇ)\n  (f : MultilinearMap R (fun (x : Œπ‚ÇÅ) ‚Ü¶ M‚ÇÇ) M‚ÇÉ) (g : MultilinearMap R (fun (x : Œπ‚ÇÅ) ‚Ü¶ M‚ÇÇ) M‚ÇÉ),\n  (MultilinearMap.domDomCongr œÉ f = MultilinearMap.domDomCongr œÉ g : Prop) ‚Üî (f = g : Prop)","name":"MultilinearMap.domDomCongr_eq_iff","isProp":true,"docString":"The results of applying `domDomCongr` to two maps are equal if\nand only if those maps are. "},{"type":"‚àÄ {Œπ : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {u : (a : Œπ) ‚Üí Set X} {s : Set X}\n  {c : Set (ShrinkingLemma.PartialRefinement u s)}\n  (hc :\n    IsChain (fun (x : ShrinkingLemma.PartialRefinement u s) (x_1 : ShrinkingLemma.PartialRefinement u s) ‚Ü¶ x ‚â§ x_1) c)\n  {v‚ÇÅ : ShrinkingLemma.PartialRefinement u s} {v‚ÇÇ : ShrinkingLemma.PartialRefinement u s} (h‚ÇÅ : v‚ÇÅ ‚àà c) (h‚ÇÇ : v‚ÇÇ ‚àà c)\n  {i : Œπ} (hi‚ÇÅ : i ‚àà ShrinkingLemma.PartialRefinement.carrier v‚ÇÅ)\n  (hi‚ÇÇ : i ‚àà ShrinkingLemma.PartialRefinement.carrier v‚ÇÇ),\n  ShrinkingLemma.PartialRefinement.toFun v‚ÇÅ i = ShrinkingLemma.PartialRefinement.toFun v‚ÇÇ i","name":"ShrinkingLemma.PartialRefinement.apply_eq_of_chain","isProp":true,"docString":"If two partial refinements `v‚ÇÅ`, `v‚ÇÇ` belong to a chain (hence, they are comparable)\nand `i` belongs to the carriers of both partial refinements, then `v‚ÇÅ i = v‚ÇÇ i`. "},{"type":"‚àÄ {p : ‚Ñï} (hp : Nat.Prime p), ‚Üë(Nat.factorization p) p = 1","name":"Nat.Prime.factorization_self","isProp":true,"docString":"The multiplicity of prime `p` in `p` is `1` "},{"type":"‚àÄ {Œπ : Type u_1} {A : (a : Œπ) ‚Üí Type u_2} [inst : AddMonoid Œπ] [self : GradedMonoid.GMonoid A] (a : GradedMonoid A)\n  (b : GradedMonoid A) (c : GradedMonoid A), a * b * c = a * (b * c)","name":"GradedMonoid.GMonoid.mul_assoc","isProp":true,"docString":"Multiplication is associative "},{"type":"‚àÄ {m : Type u_1} [inst : DecidableEq m] [inst_1 : Fintype m] {R : Type v} [inst_2 : CommRing R] (M : Matrix m m R)\n  (N : Matrix m m R), Matrix.det (Matrix.mul M N) = Matrix.det (Matrix.mul N M)","name":"Matrix.det_mul_comm","isProp":true,"docString":"On square matrices, `mul_comm` applies under `det`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D]\n  [inst_2 : Quiver.IsThin C], Quiver.IsThin (D ‚•§ C)","name":"CategoryTheory.functor_thin","isProp":true,"docString":"If `C` is a thin category, then `D ‚•§ C` is a thin category. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} (a_1 : a ‚â§ c - b), a + b ‚â§ c","name":"add_le_of_le_sub_right","isProp":true,"docString":"**Alias** of the forward direction of `le_sub_iff_add_le`."},{"type":"‚àÄ {i : ‚Ñï} {f : (a : ‚Ñï) ‚Üí ‚Ñù} {g : (a : ‚Ñï) ‚Üí ‚Ñù} (h0 : ‚àÄ (b : ‚Ñï), 0 ‚â§ f b) (h : ‚àÄ (b : ‚Ñï), f b ‚â§ g b) (hi : f i < g i)\n  (hg : Summable g), (tsum fun (n : ‚Ñï) ‚Ü¶ f n) < tsum fun (n : ‚Ñï) ‚Ü¶ g n","name":"tsum_lt_tsum_of_nonneg","isProp":true,"docString":"If a sequence `f` with non-negative terms is dominated by a sequence `g` with summable\nseries and at least one term of `f` is strictly smaller than the corresponding term in `g`,\nthen the series of `f` is strictly smaller than the series of `g`. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {s : Set Œ±} (hf : Equiv.Perm.IsCycleOn f s),\n  Equiv.Perm.IsCycleOn\n    (Equiv.Perm.subtypePerm f\n      (fun (x : Œ±) ‚Ü¶ (_ : (x ‚àà s : Prop) ‚Üî (‚Üëf x ‚àà s : Prop))=:‚àÄ (x : Œ±), (x ‚àà s : Prop) ‚Üî (‚Üëf x ‚àà s : Prop)))\n    Set.univ","name":"Equiv.Perm.IsCycleOn.subtypePerm","isProp":true,"docString":"Note that the identity is a cycle on any subsingleton set, but not a cycle. "},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module R E] [inst_4 : Module R F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : ContinuousAdd E] [inst_8 : ContinuousAdd F] [inst_9 : TopologicalSpace R] [inst_10 : ContinuousSMul R E]\n  [inst_11 : ContinuousSMul R F] {f : E ‚Üí‚Çó.[R] F} {g : E ‚Üí‚Çó.[R] F} (hf : LinearPMap.IsClosable f) (hfg : g ‚â§ f),\n  LinearPMap.IsClosable g","name":"LinearPMap.IsClosable.leIsClosable","isProp":true,"docString":"If `g` has a closable extension `f`, then `g` itself is closable. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (g : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasCoequalizer f g], CategoryTheory.Limits.HasCokernel (f - g)","name":"CategoryTheory.Preadditive.hasCokernel_of_hasCoequalizer","isProp":true,"docString":"A preadditive category has a cokernel for `f - g` if it has a coequalizer for `f` and `g`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤},\n  (ConcaveOn ùïú s (-f) : Prop) ‚Üî (ConvexOn ùïú s f : Prop)","name":"neg_concaveOn_iff","isProp":true,"docString":"A function `-f` is concave iff `f` is convex. "},{"type":"‚àÄ {M : Type u_1} [inst : GroupWithZero M], Set.center MÀ£ = Units.val ‚Åª¬π' Set.center M","name":"Set.center_units_eq","isProp":true,"docString":"In a group with zero, the center of the units is the preimage of the center. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.Mono f],\n  CategoryTheory.IsKernelPair f (ùüô X) (ùüô X)","name":"CategoryTheory.IsKernelPair.id_of_mono","isProp":true,"docString":"If `f` is a monomorphism, then `(ùüô _, ùüô _)`  is a kernel pair for `f`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (f : (a : Œ±) ‚Üí Œ≤) (P : RegularExpression Œ±),\n  RegularExpression.matches' (RegularExpression.map f P) = ‚Üë(Language.map f) (RegularExpression.matches' P)","name":"RegularExpression.matches'_map","isProp":true,"docString":"The language of the map is the map of the language. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedCancelCommMonoid Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"LinearOrderedCancelCommMonoid.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], Subsingleton (Quotient (DiscreteQuotient.toSetoid ‚ä§))","name":"DiscreteQuotient.instSubsingletonQuotientToSetoidTopDiscreteQuotientToTopToLEToPreorderToPartialOrderInstSemilatticeInfDiscreteQuotientInstOrderTopDiscreteQuotientToLEToPreorderToPartialOrderInstSemilatticeInfDiscreteQuotient","isProp":true,"docString":"The quotient by `‚ä§ : DiscreteQuotient X` is a `Subsingleton`. "},{"type":"‚àÄ (R‚ÇÅ : Type u_2) {A : Type u_1} [inst : CommSemiring R‚ÇÅ] [inst_1 : CommRing A] [inst_2 : Algebra R‚ÇÅ A] (I : Ideal A),\n  Function.Surjective ‚Üë(Ideal.Quotient.mk‚Çê R‚ÇÅ I)","name":"Ideal.Quotient.mk‚Çê_surjective","isProp":true,"docString":"The canonical morphism `A ‚Üí‚Çê[R‚ÇÅ] I.quotient` is surjective. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_4} {P : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) {p : (a : Œπ) ‚Üí P}\n  (hi : ‚àÄ (i : Œπ) (x : i ‚àà s) (j : Œπ) (x : j ‚àà s) (a : p i = p j), i = j) {ps : Set P} [inst_4 : Fintype ‚Üëps]\n  (hps : ps = p '' ‚Üës), Finset.centroid k s p = Finset.centroid k Finset.univ fun (x : ‚Üëps) ‚Ü¶ ‚Üëx","name":"Finset.centroid_eq_centroid_image_of_inj_on","isProp":true,"docString":"An indexed family of points that is injective on the given\n`Finset` has the same centroid as the image of that `Finset`.  This is\nstated in terms of a set equal to the image to provide control of\ndefinitional equality for the index type used for the centroid of the\nimage. "},{"type":"‚àÄ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R] {a : R} {b : R} {c : R}\n  (ha : a ‚â† 0) (no_factors : ‚àÄ {d : R} (a : d ‚à£ a) (a : d ‚à£ b), ¬¨(Prime d : Prop)) (a_1 : a ‚à£ b * c), a ‚à£ c","name":"UniqueFactorizationMonoid.dvd_of_dvd_mul_right_of_no_prime_factors","isProp":true,"docString":"Euclid's lemma: if `a ‚à£ b * c` and `a` and `b` have no common prime factors, `a ‚à£ c`.\nCompare `IsCoprime.dvd_of_dvd_mul_right`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : (a : ‚Ñù) ‚Üí Œ±} {c : ‚Ñù} (hp : Function.Periodic f c) (hc : c ‚â† 0)\n  (hf : Continuous f), IsCompact (Set.range f)","name":"Function.Periodic.compact_of_continuous","isProp":true,"docString":"A continuous, periodic function has compact range. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : T0Space Œ±]\n  {f : (a : Œ±) ‚Üí Œ≤} (hf : Inducing f), Embedding f","name":"Inducing.embedding","isProp":true,"docString":"A topology `Inducing` map from a T‚ÇÄ space is a topological embedding. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ≤ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ≤ i)] (x : (i : Œπ) ‚Üí Œ≤ i)\n  (y : (i : Œπ) ‚Üí Œ≤ i) (z : (i : Œπ) ‚Üí Œ≤ i), hammingDist x y ‚â§ hammingDist x z + hammingDist y z","name":"hammingDist_triangle_right","isProp":true,"docString":"Corresponds to `dist_triangle_right`. "},{"type":"‚àÄ {Œ∑ : Type u_1} {f : (a : Œ∑) ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Group (f i)] [inst_1 : DecidableEq Œ∑] [inst_2 : Finite Œ∑]\n  {H : (i : Œ∑) ‚Üí Subgroup (f i)} {J : Subgroup ((i : Œ∑) ‚Üí f i)},\n  (Subgroup.pi Set.univ H ‚â§ J : Prop) ‚Üî (‚àÄ (i : Œ∑), Subgroup.map (MonoidHom.single f i) (H i) ‚â§ J : Prop)","name":"Subgroup.pi_le_iff","isProp":true,"docString":"For finite index types, the `Subgroup.pi` is generated by the embeddings of the groups.  "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] [inst_1 : Preorder M]\n  [inst_2 : CovariantClass M M (Function.swap fun (x : M) (x_1 : M) ‚Ü¶ x * x_1) fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1]\n  [inst_3 : CovariantClass M M (fun (x : M) (x_1 : M) ‚Ü¶ x * x_1) fun (x : M) (x_1 : M) ‚Ü¶ x ‚â§ x_1] {l‚ÇÅ : List M}\n  {l‚ÇÇ : List M} (h : List.Sublist l‚ÇÅ l‚ÇÇ) (h‚ÇÅ : ‚àÄ (a : M) (a_1 : a ‚àà l‚ÇÇ), 1 ‚â§ a), List.prod l‚ÇÅ ‚â§ List.prod l‚ÇÇ","name":"List.Sublist.prod_le_prod'","isProp":true,"docString":"If `l‚ÇÅ` is a sublist of `l‚ÇÇ` and all elements of `l‚ÇÇ` are greater than or equal to one, then\n`l‚ÇÅ.prod ‚â§ l‚ÇÇ.prod`. One can prove a stronger version assuming `‚àÄ a ‚àà l‚ÇÇ.diff l‚ÇÅ, 1 ‚â§ a` instead\nof `‚àÄ a ‚àà l‚ÇÇ, 1 ‚â§ a` but this lemma is not yet in `mathlib`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] [inst_2 : T0Space Œ±] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : UniformInducing f), UniformEmbedding f","name":"UniformInducing.uniformEmbedding","isProp":true,"docString":"If the domain of a `UniformInducing` map `f` is a T‚ÇÄ space, then `f` is injective,\nhence it is a `UniformEmbedding`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 0) (b : P),\n  ‚Üë(Finset.weightedVSub s p) w = ‚Üë(Finset.weightedVSubOfPoint s p b) w","name":"Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero","isProp":true,"docString":"`weightedVSub` gives the sum of the results of subtracting any\nbase point, when the sum of the weights is 0. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : EMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (h : AntilipschitzWith 0 f), Subsingleton Œ±","name":"AntilipschitzWith.subsingleton","isProp":true,"docString":"If `f : Œ± ‚Üí Œ≤` is `0`-antilipschitz, then `Œ±` is a `subsingleton`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±} {t : Set Œ≤}\n  (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), Function.Injective (f a)),\n  (Set.PairwiseDisjoint s fun (a : Œ±) ‚Ü¶ f a '' t : Prop) ‚Üî\n    (Set.InjOn (fun (p : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst p) (Prod.snd p)) (s √óÀ¢ t) : Prop)","name":"Set.pairwiseDisjoint_image_right_iff","isProp":true,"docString":"The partial images of a binary function `f` whose partial evaluations are injective are pairwise\ndisjoint iff `f` is injective . "},{"type":"‚àÄ {Œ± : Type u} [inst : Mul Œ±], IsMulHom id","name":"IsMulHom.id","isProp":true,"docString":"The identity map preserves multiplication. "},{"type":"‚àÄ {n : Type u_1} {Œ± : Type v} [inst : Fintype n] [inst_1 : NonUnitalSemiring Œ±] [inst_2 : StarRing Œ±] (M : Matrix n n Œ±)\n  (N : Matrix n n Œ±), star (Matrix.mul M N) = Matrix.mul (star N) (star M)","name":"Matrix.star_mul","isProp":true,"docString":"A version of `star_mul` for `‚¨ù` instead of `*`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : IsSuccArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico n m), r i (Order.succ i))\n  (hnm : n < m), Relation.TransGen r n m","name":"transGen_of_succ_of_lt","isProp":true,"docString":"For `n < m`, `(n, m)` is in the transitive closure of a relation `~` if `i ~ succ i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Semiring Œ±] {I : Ideal Œ±} [self : Ideal.IsPrime I] {x : Œ±} {y : Œ±} (a : x * y ‚àà I),\n  (x ‚àà I : Prop) ‚à® (y ‚àà I : Prop)","name":"Ideal.IsPrime.mem_or_mem'","isProp":true,"docString":"If a product lies in the prime ideal, then at least one element lies in the prime ideal. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} (n : ‚Ñï) {d : (a : ‚Ñï) ‚Üí ‚Ñù}\n  (hd : ‚àÄ {k : ‚Ñï} (a : k < n), dist (f k) (f (k + 1)) ‚â§ d k),\n  dist (f 0) (f n) ‚â§ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ d i","name":"dist_le_range_sum_of_dist_le","isProp":true,"docString":"A version of `dist_le_range_sum_dist` with each intermediate distance replaced\nwith an upper estimate. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : CompleteLinearOrder R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R]\n  [inst_3 : CompleteLinearOrder S] [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {F : Filter R}\n  [inst_6 : Filter.NeBot F] {f : (a : R) ‚Üí S} (f_incr : Monotone f) (f_cont : ContinuousAt f (Filter.limsup‚Çõ F)),\n  f (Filter.limsup‚Çõ F) = Filter.limsup f F","name":"Monotone.map_limsup‚Çõ_of_continuousAt","isProp":true,"docString":"A monotone function between complete linear ordered spaces sends a `Filter.limsup‚Çõ`\nto the `Filter.limsup` of the image if it is continuous at the `limsup‚Çõ`. "},{"type":"‚àÄ {M : Type u_6} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_4} [inst_1 : CommMonoid N] {P : Type u_3}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P} {T : Submonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_5} [inst_3 : CommMonoid Q]\n  {k : Submonoid.LocalizationMap T Q} {A : Type u_1} [inst_4 : CommMonoid A] {U : Submonoid A} {R : Type u_2}\n  [inst_5 : CommMonoid R] (j : Submonoid.LocalizationMap U R) {l : P ‚Üí* A} (hl : ‚àÄ (w : { x : P // x ‚àà T }), ‚Üël ‚Üëw ‚àà U)\n  (x : N),\n  ‚Üë(Submonoid.LocalizationMap.map k hl j) (‚Üë(Submonoid.LocalizationMap.map f hy k) x) =\n    ‚Üë(Submonoid.LocalizationMap.map f\n          (fun (x : { x : M // x ‚àà S }) ‚Ü¶\n            (_ : ‚Üë(MonoidHom.comp l g) ‚Üëx ‚àà U)=:‚àÄ (x : { x : M // x ‚àà S }), ‚Üë(MonoidHom.comp l g) ‚Üëx ‚àà U)\n          j)\n      x","name":"Submonoid.LocalizationMap.map_map","isProp":true,"docString":"If `CommMonoid` homs `g : M ‚Üí* P, l : P ‚Üí* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ‚àò g`. "},{"type":"‚àÄ {Œ± : Type u_2} {R : Type u_1} {l : Filter Œ±} {f : (a : Œ±) ‚Üí R} {r : R} [inst : LinearOrderedRing R]\n  [inst_1 : Archimedean R] (hr : r < 0) (hf : Filter.Tendsto f l Filter.atBot),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * r) l Filter.atTop","name":"Filter.Tendsto.atBot_mul_neg_const'","isProp":true,"docString":"See also `Filter.Tendsto.atBot_mul_neg_const` for a version of this lemma for\n`LinearOrderedField`s which does not require the `Archimedean` assumption. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V],\n  (FiniteDimensional.finrank K V ‚â§ 1 : Prop) ‚Üî (‚àÉ (v : V), ‚àÄ (w : V), ‚àÉ (c : K), c ‚Ä¢ v = w : Prop)","name":"finrank_le_one_iff","isProp":true,"docString":"A finite dimensional module has dimension at most 1 iff\nthere is some `v : V` so every vector is a multiple of `v`.\n"},{"type":"‚àÄ (R : Type u) [inst : CommSemiring R] [inst_1 : NoZeroDivisors R] (n : ‚Ñï), NoZeroDivisors (MvPolynomial (Fin n) R)","name":"MvPolynomial.noZeroDivisors_fin","isProp":true,"docString":"Auxiliary lemma:\nMultivariate polynomials over an integral domain\nwith variables indexed by `Fin n` form an integral domain.\nThis fact is proven inductively,\nand then used to prove the general case without any finiteness hypotheses.\nSee `MvPolynomial.noZeroDivisors` for the general case. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsGroupHom f), f 1 = 1","name":"IsGroupHom.map_one","isProp":true,"docString":"A group homomorphism sends 1 to 1. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : (a : Œ±) ‚Üí Type u} {Œ∫ : Cardinal} (hŒ∫ : (Cardinal.sum fun (a : Œ±) ‚Ü¶ Œ∫ ^ Cardinal.mk (Œ≤ a)) ‚â§ Œ∫),\n  Cardinal.mk (WType Œ≤) ‚â§ Œ∫","name":"WType.cardinal_mk_le_of_le","isProp":true,"docString":"`#(WType Œ≤)` is the least cardinal `Œ∫` such that `sum (Œª a : Œ±, Œ∫ ^ #(Œ≤ a)) ‚â§ Œ∫` "},{"type":"‚àÄ {L : Type v} {M : Type w} [inst : LieRing L] [inst_1 : AddCommGroup M] [self : LieRingModule L M] (x : L) (m : M)\n  (n : M), ‚ÅÖx, m + n‚ÅÜ = ‚ÅÖx, m‚ÅÜ + ‚ÅÖx, n‚ÅÜ","name":"LieRingModule.lie_add","isProp":true,"docString":"A Lie ring module bracket is additive in its second component. "},{"type":"‚àÄ {G : Type u} [inst : AddMonoid G], IsOfFinAddOrder 0","name":"isOfFinAddOrder_zero","isProp":true,"docString":"0 is of finite order in any additive monoid."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (e : LocalHomeomorph Œ± Œ≤)\n  {x : Œ±} (h : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)), ContinuousAt (‚Üëe) x","name":"LocalHomeomorph.continuousAt","isProp":true,"docString":"A local homeomorphism is continuous at any point of its source "},{"type":"‚àÄ {Œπ : Type u_2} {R : Type u_1} {M : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Nontrivial R] (b : Basis Œπ R M),\n  LinearIndependent.Maximal ((Basis.linearIndependent b=:LinearIndependent R ‚Üëb)=:LinearIndependent R ‚Üëb)","name":"Basis.maximal","isProp":true,"docString":"Any basis is a maximal linear independent set.\n"},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} {Œπ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤] {s : Set E}\n  {f : (a : E) ‚Üí Œ≤} {t : Finset Œπ} {w : (a : Œπ) ‚Üí ùïú} {p : (a : Œπ) ‚Üí E} (hf : ConcaveOn ùïú s f)\n  (h‚ÇÄ : ‚àÄ (i : Œπ) (a : i ‚àà t), 0 ‚â§ w i) (h‚ÇÅ : 0 < Finset.sum t fun (i : Œπ) ‚Ü¶ w i)\n  (hmem : ‚àÄ (i : Œπ) (a : i ‚àà t), p i ‚àà s), Finset.centerMass t w (f ‚àò p) ‚â§ f (Finset.centerMass t w p)","name":"ConcaveOn.le_map_centerMass","isProp":true,"docString":"Concave **Jensen's inequality**, `Finset.centerMass` version. "},{"type":"‚àÄ {Œ± : Type u_2} {R : Type u_1} {l : Filter Œ±} {f : (a : Œ±) ‚Üí R} {r : R} [inst : LinearOrderedRing R]\n  [inst_1 : Archimedean R] (hr : r < 0) (hf : Filter.Tendsto f l Filter.atTop),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * r) l Filter.atBot","name":"Filter.Tendsto.atTop_mul_neg_const'","isProp":true,"docString":"See also `Filter.Tendsto.atTop_mul_neg_const` for a version of this lemma for\n`LinearOrderedField`s which does not require the `Archimedean` assumption. "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {N : outParam (Type u_3)} [inst : MulZeroOneClass M]\n  [inst_1 : MulZeroOneClass N] [self : MonoidWithZeroHomClass F M N] (f : F), ‚Üëf 0 = 0","name":"MonoidWithZeroHomClass.map_zero","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ {I : Type u} {f : (a : I) ‚Üí Type v} [inst : DecidableEq I] [inst_1 : (i : I) ‚Üí AddZeroClass (f i)] (x : (i : I) ‚Üí f i)\n  (i : I) (j : I), AddCommute (Pi.single i (x i)) (Pi.single j (x j))","name":"Pi.single_apply_commute","isProp":true,"docString":"The injection into an additive pi group with the same values commutes."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {k : Set G} {p : (x : G) ‚Üí (a : x ‚àà Subgroup.closure k) ‚Üí Prop}\n  (Hs : ‚àÄ (x : G) (h : x ‚àà k), p x ((Subgroup.subset_closure h=:x ‚àà ‚Üë(Subgroup.closure k))=:x ‚àà ‚Üë(Subgroup.closure k)))\n  (H1 : p 1 ((one_mem (Subgroup.closure k)=:1 ‚àà Subgroup.closure k)=:1 ‚àà Subgroup.closure k))\n  (Hmul :\n    ‚àÄ (x : G) (hx : x ‚àà Subgroup.closure k) (y : G) (hy : y ‚àà Subgroup.closure k) (a : p x hx) (a : p y hy),\n      p (x * y) ((mul_mem hx hy=:x * y ‚àà Subgroup.closure k)=:x * y ‚àà Subgroup.closure k))\n  (Hinv :\n    ‚àÄ (x : G) (hx : x ‚àà Subgroup.closure k) (a : p x hx),\n      p x‚Åª¬π ((inv_mem hx=:x‚Åª¬π ‚àà Subgroup.closure k)=:x‚Åª¬π ‚àà Subgroup.closure k))\n  {x : G} (hx : x ‚àà Subgroup.closure k), p x hx","name":"Subgroup.closure_induction'","isProp":true,"docString":"A dependent version of `Subgroup.closure_induction`.  "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v},\n  (Cardinal.lift (Cardinal.mk Œ±) = Cardinal.lift (Cardinal.mk Œ≤) : Prop) ‚Üî (Nonempty (Œ± ‚âÉ Œ≤) : Prop)","name":"Cardinal.lift_mk_eq'","isProp":true,"docString":"A variant of `Cardinal.lift_mk_eq` with specialized universes.\nBecause Lean often can not realize it should use this specialization itself,\nwe provide this statement separately so you don't have to solve the specialization problem either.\n"},{"type":"‚àÄ {p : ‚Ñï} (hp : Nat.Prime p) {n : ‚Ñï} (hn : 0 < n), Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)","name":"Nat.totient_prime_pow","isProp":true,"docString":"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (a : ConcaveOn ùïú s f), ConvexOn ùïú s (-f)","name":"ConcaveOn.neg","isProp":true,"docString":"**Alias** of the reverse direction of `neg_convexOn_iff`."},{"type":"‚àÄ {n : ‚Ñï} {a : ‚Ñï} (ha : Even a), (Odd (n % a) : Prop) ‚Üî (Odd n : Prop)","name":"Odd.mod_even_iff","isProp":true,"docString":"If `a` is even, then `n` is odd iff `n % a` is odd. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} (hc : c ‚â† 0) (hd : d ‚â† 0)\n  (a_1 : a / c < b / d), (a * d - b * c) / (c * d) < 0","name":"mul_sub_mul_div_mul_neg","isProp":true,"docString":"**Alias** of the reverse direction of `mul_sub_mul_div_mul_neg_iff`."},{"type":"‚àÄ {M : Type u_3} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_4} [inst_1 : AddCommMonoid N] {P : Type u_1}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P} {T : AddSubmonoid P} {Q : Type u_2}\n  [inst_3 : AddCommMonoid Q] (hg : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) (k : AddSubmonoid.LocalizationMap T Q) {x : M}\n  {y : M} (h : ‚Üë(AddSubmonoid.LocalizationMap.toMap f) x = ‚Üë(AddSubmonoid.LocalizationMap.toMap f) y),\n  ‚Üë(AddSubmonoid.LocalizationMap.toMap k) (‚Üëg x) = ‚Üë(AddSubmonoid.LocalizationMap.toMap k) (‚Üëg y)","name":"AddSubmonoid.LocalizationMap.comp_eq_of_eq","isProp":true,"docString":"Given `AddCommMonoid`s `M, P`, Localization maps `f : M ‚Üí+ N, k : P ‚Üí+ Q` for Submonoids\n`S, T` respectively, and `g : M ‚Üí+ P` such that `g(S) ‚äÜ T`, `f x = f y`\nimplies `k (g x) = k (g y)`."},{"type":"‚àÄ {R : Type u_3} [inst : Semiring R] {M : Type u_4} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_5}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Œπ : Type u_1} {Œπ' : Type u_2} (œÉ : Œπ ‚âÉ Œπ')\n  (f : AlternatingMap R M N Œπ) (g : AlternatingMap R M N Œπ),\n  (AlternatingMap.domDomCongr œÉ f = AlternatingMap.domDomCongr œÉ g : Prop) ‚Üî (f = g : Prop)","name":"AlternatingMap.domDomCongr_eq_iff","isProp":true,"docString":"The results of applying `domDomCongr` to two maps are equal if and only if those maps are. "},{"type":"‚àÄ {V‚ÇÅ : Type u_2} {V‚ÇÇ : Type u_1} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ]\n  (f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ) (x : V‚ÇÅ), ‚Äñ‚Üëf x‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñx‚Äñ","name":"NormedAddGroupHom.le_opNorm","isProp":true,"docString":"The fundamental property of the operator norm: `‚Äñf x‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñx‚Äñ`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : a < b) (a_2 : 0 < c),\n  a * c < b * c","name":"CanonicallyLinearOrderedSemifield.mul_lt_mul_of_pos_right","isProp":true,"docString":"Right multiplication by a positive element is strictly monotone. "},{"type":"‚àÄ {Œ± : Type u_1} [self : ConditionallyCompleteLattice Œ±] (s : Set Œ±) (a : Œ±) (a_1 : BddBelow s) (a_2 : a ‚àà s),\n  inf‚Çõ s ‚â§ a","name":"ConditionallyCompleteLattice.cinf‚Çõ_le","isProp":true,"docString":"`inf‚Çõ s ‚â§ a` for all `a ‚àà s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddMonoidWithOne Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ZeroLEOneClass Œ±] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1], 0 < 3","name":"zero_lt_three","isProp":true,"docString":"See `zero_lt_three'` for a version with the type explicit. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} {n : ‚Ñ§} (a : Equiv.Perm.SameCycle f x (‚Üë(f ^ n) y)),\n  Equiv.Perm.SameCycle f x y","name":"Equiv.Perm.SameCycle.of_zpow_right","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.sameCycle_zpow_right`."},{"type":"‚àÄ {T : Type u‚ÇÅ} [inst : CategoryTheory.Category T] {X : T} {f : CategoryTheory.Over X} {g : CategoryTheory.Over X}\n  (k : f ‚ü∂ g) [hk : CategoryTheory.Mono (CategoryTheory.CommaMorphism.left k)], CategoryTheory.Mono k","name":"CategoryTheory.Over.mono_of_mono_left","isProp":true,"docString":"If `k.left` is a monomorphism, then `k` is a monomorphism. In other words, `Over.forget X` reflects\nmonomorphisms.\nThe converse of `CategoryTheory.Over.mono_left_of_mono`.\n\nThis lemma is not an instance, to avoid loops in type class inference.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (g : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasCokernel (f - g)], CategoryTheory.Limits.HasCoequalizer f g","name":"CategoryTheory.Preadditive.hasCoequalizer_of_hasCokernel","isProp":true,"docString":"A preadditive category has a coequalizer for `f` and `g` if it has a cokernel for `f - g`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {fa : (a : Œ±) ‚Üí Œ±} {fb : (a : Œ≤) ‚Üí Œ≤} {x : Œ±} (hx : Function.IsFixedPt fa x)\n  {g : (a : Œ±) ‚Üí Œ≤} (h : Function.Semiconj g fa fb), Function.IsFixedPt fb (g x)","name":"Function.IsFixedPt.map","isProp":true,"docString":"If `g` (semi)conjugates `fa` to `fb`, then it sends fixed points of `fa` to fixed points\nof `fb`. "},{"type":"‚àÄ (n : ‚Ñï) (a : ‚Ñï), Finset.image (fun (x : ‚Ñï) ‚Ü¶ x % a) (Finset.Ico n (n + a)) = Finset.range a","name":"Nat.image_Ico_mod","isProp":true,"docString":"Note that while this lemma cannot be easily generalized to a type class, it holds for ‚Ñ§ as\nwell. See `int.image_Ico_mod` for the ‚Ñ§ version. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (f‚ÇÅ : G ‚Üí* CircleDeg1Lift) (f‚ÇÇ : G ‚Üí* CircleDeg1Lift)\n  (h : ‚àÄ (g : G), CircleDeg1Lift.translationNumber (‚Üëf‚ÇÅ g) = CircleDeg1Lift.translationNumber (‚Üëf‚ÇÇ g)),\n  ‚àÉ (F : CircleDeg1Lift), ‚àÄ (g : G), Function.Semiconj ‚ÜëF ‚Üë(‚Üëf‚ÇÅ g) ‚Üë(‚Üëf‚ÇÇ g)","name":"CircleDeg1Lift.semiconj_of_group_action_of_forall_translationNumber_eq","isProp":true,"docString":"Consider two actions `f‚ÇÅ f‚ÇÇ : G ‚Üí* CircleDeg1Lift` of a group on the real line by lifts of\norientation preserving circle homeomorphisms. Suppose that for each `g : G` the homeomorphisms\n`f‚ÇÅ g` and `f‚ÇÇ g` have equal rotation numbers. Then there exists `F : CircleDeg1Lift`  such that\n`F * f‚ÇÅ g = f‚ÇÇ g * F` for all `g : G`.\n\nThis is a version of Proposition 5.4 from [√âtienne Ghys, Groupes d'homeomorphismes du cercle et\ncohomologie bornee][ghys87:groupes]. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {F : C·µí·µñ ‚•§ Type v‚ÇÅ} [self : CategoryTheory.Functor.Representable F],\n  ‚àÉ (X : C),\n    ‚àÉ (f : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda) X ‚ü∂ F), CategoryTheory.IsIso f","name":"CategoryTheory.Functor.Representable.has_representation","isProp":true,"docString":"`Hom(-,X) ‚âÖ F` via `f` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Add Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} {c : Œ±} {d : Œ±} (h‚ÇÅ : a < b) (h‚ÇÇ : c < d), a + c < b + d","name":"Right.add_lt_add","isProp":true,"docString":"Only assumes right strict covariance"},{"type":"‚àÄ {Œ± : Type u_1} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsIrrefl Œ± r],\n  Set.Nonempty (setOf fun (c : Cardinal) ‚Ü¶ ‚àÉ (S : Set Œ±), (Set.Unbounded r S : Prop) ‚àß (Cardinal.mk ‚ÜëS = c : Prop))","name":"StrictOrder.cof_nonempty","isProp":true,"docString":"The set in the definition of `Order.StrictOrder.cof` is nonempty. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : MetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (h : Embedding f), Isometry f","name":"Embedding.to_isometry","isProp":true,"docString":"An embedding from a topological space to a metric space is an isometry with respect to the\ninduced metric space structure on the source space. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C}\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y],\n  CategoryTheory.Limits.biprod.fst ‚â´ CategoryTheory.Limits.biprod.inl +\n      CategoryTheory.Limits.biprod.snd ‚â´ CategoryTheory.Limits.biprod.inr =\n    ùüô (X ‚äû Y)","name":"CategoryTheory.Limits.biprod.total","isProp":true,"docString":"In any preadditive category, any binary biproduct satsifies\n`biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y)`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] [inst_1 : DecidableRel Disjoint]\n  [inst_2 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (u : Œ±) (v : Œ±) (a : Œ±),\n  UV.compress u v (UV.compress u v a) = UV.compress u v a","name":"UV.compress_idem","isProp":true,"docString":"Compressing an element is idempotent. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {l : Filter Œπ}\n  [inst_2 : Filter.NeBot l] {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} {f : (a : Œ≤) ‚Üí Œ±} (h‚ÇÅ : Filter.Tendsto F l (nhds f))\n  (h‚ÇÇ : UniformEquicontinuous F), UniformContinuous f","name":"Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous","isProp":true,"docString":"If `ùìï : Œπ ‚Üí Œ≤ ‚Üí Œ±` tends to `f : Œ≤ ‚Üí Œ±` *pointwise* along some nontrivial filter, and if the\nfamily `ùìï` is uniformly equicontinuous, then the limit is uniformly continuous. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {k : Set G} {p : (a : G) ‚Üí Prop} {x : G} (h : x ‚àà AddSubgroup.closure k)\n  (Hk : ‚àÄ (x : G) (a : x ‚àà k), p x) (H1 : p 0) (Hmul : ‚àÄ (x : G) (y : G) (a : p x) (a : p y), p (x + y))\n  (Hinv : ‚àÄ (x : G) (a : p x), p (-x)), p x","name":"AddSubgroup.closure_induction","isProp":true,"docString":"An induction principle for additive closure membership. If `p`\nholds for `0` and all elements of `k`, and is preserved under addition and inverses, then `p`\nholds for all elements of the additive closure of `k`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {ùîñ : Set (Set Œ±)} {S : Set Œ±} {S' : Set Œ±} {V : Set (Œ≤ √ó Œ≤)} {V' : Set (Œ≤ √ó Œ≤)}\n  (hS : S' ‚äÜ S) (hV : V ‚äÜ V'), UniformOnFun.gen ùîñ S V ‚äÜ UniformOnFun.gen ùîñ S' V'","name":"UniformOnFun.gen_mono","isProp":true,"docString":"`UniformOnFun.gen` is antitone in the first argument and monotone in the second. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R), (Ideal.IsMaximal I : Prop) ‚Üî (IsField (R ‚ß∏ I) : Prop)","name":"Ideal.Quotient.maximal_ideal_iff_isField_quotient","isProp":true,"docString":"The quotient of a ring by an ideal is a field iff the ideal is maximal. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atBot),\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atTop : Prop) ‚Üî (r < 0 : Prop)","name":"Filter.tendsto_const_mul_atTop_iff_neg","isProp":true,"docString":"If `f` tends to negative infinity along a nontrivial filter `l`, then `Œª x, r * f x` tends to\ninfinity if and only if `r < 0. `"},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {f : (a : Œ±) ‚Üí Œ±} {p : (a : Œ±) ‚Üí Prop} {hf : ‚àÄ (x : Œ±), x ‚â§ f x}\n  {hfp : ‚àÄ (x : Œ±), p (f x)} {hmin : ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : x ‚â§ y) (a : p y), f x ‚â§ y} (x : Œ±),\n  p (‚Üë(ClosureOperator.toOrderHom (ClosureOperator.mk‚ÇÉ f p hf hfp hmin)) x)","name":"ClosureOperator.closure_mem_mk‚ÇÉ","isProp":true,"docString":"This lemma shows that the image of `x` of a closure operator built from the `mk‚ÇÉ` constructor\nrespects `p`, the property that was fed into it. "},{"type":"‚àÄ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : (a : X) ‚Üí Y} {s : Set Y}\n  (hs : IsSeqClosed s) (hf : SeqContinuous f), IsSeqClosed (f ‚Åª¬π' s)","name":"IsSeqClosed.preimage","isProp":true,"docString":"The preimage of a sequentially closed set under a sequentially continuous map is sequentially\nclosed. "},{"type":"‚àÄ {G : Type u} {x : G} [inst : Group G] [inst_1 : Fintype G],\n  orderOf x = Fintype.card { x_1 : G // x_1 ‚àà Subgroup.zpowers x }","name":"orderOf_eq_card_zpowers","isProp":true,"docString":"See also `orderOf_eq_card_zpowers'`. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : AddLeftCancelMonoid Œ±], FaithfulVAdd Œ±·µÉ·µí·µñ Œ±","name":"AddLeftCancelMonoid.toFaithfulVAdd_opposite","isProp":true,"docString":"`AddMonoid.toOppositeAddAction` is faithful on cancellative monoids."},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {G' : SimpleGraph V} (h : G ‚â§ G') {u : V} {v : V} {p : SimpleGraph.Walk G u v}\n  (a : SimpleGraph.Walk.IsTrail p), SimpleGraph.Walk.IsTrail (SimpleGraph.Walk.mapLe h p)","name":"SimpleGraph.Walk.IsTrail.mapLe","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.Walk.mapLe_isTrail`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  {a : Œ±} (h_mono : MonotoneOn f s) (hs : s ‚àà nhdsWithin a (Set.Ici a))\n  (hfs : ‚àÄ (b : Œ≤) (a_1 : b > f a), ‚àÉ (c : Œ±), (c ‚àà s : Prop) ‚àß (f c ‚àà Set.Ioo (f a) b : Prop)),\n  ContinuousWithinAt f (Set.Ici a) a","name":"continuousWithinAt_right_of_monotoneOn_of_exists_between","isProp":true,"docString":"If `f` is a monotone function on a right neighborhood of `a` and the image of this neighborhood\nunder `f` meets every interval `(f a, b)`, `b > f a`, then `f` is continuous at `a` from the right.\n\nThe assumption `hfs : ‚àÄ b > f a, ‚àÉ c ‚àà s, f c ‚àà Ioo (f a) b` cannot be replaced by the weaker\nassumption `hfs : ‚àÄ b > f a, ‚àÉ c ‚àà s, f c ‚àà Ioc (f a) b` we use for strictly monotone functions\nbecause otherwise the function `ceil : ‚Ñù ‚Üí ‚Ñ§` would be a counter-example at `a = 0`. "},{"type":"‚àÄ {a : ‚Ñù} {b : ‚Ñù} (h : a < b), Cardinal.mk ‚Üë(Set.Ico a b) = Cardinal.continuum","name":"Cardinal.mk_Ico_real","isProp":true,"docString":"The cardinality of the interval [a, b). "},{"type":"‚àÄ {n : ‚Ñï} {k : ‚Ñï} {m : ‚Ñï} {d : ‚Ñï} (h : 0 < k),\n  ((n / k = d : Prop) ‚àß (n % k = m : Prop) : Prop) ‚Üî ((m + k * d = n : Prop) ‚àß (m < k : Prop) : Prop)","name":"Nat.div_mod_unique","isProp":true,"docString":"See also `Nat.divModEquiv` for a similar statement as an `Equiv`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s), Convex ùïú (interior s)","name":"Convex.interior","isProp":true,"docString":"In a topological vector space, the interior of a convex set is convex. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}\n  (H :\n    ‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n      ‚àÉ (Œ≤ : Type u), ‚àÉ (x : Fintype Œ≤), ‚àÉ (F : (a : ‚Üës) ‚Üí Œ≤), ‚àÄ (x : ‚Üës) (y : ‚Üës) (a : F x = F y), dist ‚Üëx ‚Üëy < Œµ),\n  TotallyBounded s","name":"Metric.totallyBounded_of_finite_discretization","isProp":true,"docString":"A pseudometric space is totally bounded if one can reconstruct up to any Œµ>0 any element of the\nspace from finitely many data. "},{"type":"‚àÄ {M : Type u_1} [inst : Group M] (c : Con M) (n : ‚Ñ§) {w : M} {x : M} (a : ‚Üëc w x), ‚Üëc (w ^ n) (x ^ n)","name":"Con.zpow","isProp":true,"docString":"Multiplicative congruence relations preserve integer powers. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] (f : M ‚Üí+ P) {x : M} {y : M},\n  (‚Üë(AddCon.ker f) x y : Prop) ‚Üî (‚Üëf x = ‚Üëf y : Prop)","name":"AddCon.ker_rel","isProp":true,"docString":"The definition of the additive congruence relation defined by an\n`AddMonoid` homomorphism's kernel."},{"type":"‚àÄ {R : Type u_2} {Œì‚ÇÄ : Type u_3} {Œì'‚ÇÄ : Type u_4} [inst : Ring R] [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ]\n  [inst_2 : LinearOrderedCommMonoidWithZero Œì'‚ÇÄ] {v‚ÇÅ : Valuation R Œì‚ÇÄ} {v‚ÇÇ : Valuation R Œì'‚ÇÄ} {S : Type u_1}\n  [inst_3 : Ring S] (f : S ‚Üí+* R) (h : Valuation.IsEquiv v‚ÇÅ v‚ÇÇ),\n  Valuation.IsEquiv (Valuation.comap f v‚ÇÅ) (Valuation.comap f v‚ÇÇ)","name":"Valuation.IsEquiv.comap","isProp":true,"docString":"`comap` preserves equivalence. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {r : ‚Ñù} (hr : 0 ‚â§ r)\n  (H1 : ‚àÄ (x : Œ±) (a : x ‚àà s), Metric.infDist x t ‚â§ r) (H2 : ‚àÄ (x : Œ±) (a : x ‚àà t), Metric.infDist x s ‚â§ r),\n  Metric.hausdorffDist s t ‚â§ r","name":"Metric.hausdorffDist_le_of_infDist","isProp":true,"docString":"Bounding the Hausdorff distance by bounding the distance of any point\nin each set to the other set "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±]\n  [inst_3 : PosMulStrictMono Œ±] (ha : a ‚â§ 1) (hb : b < 1) (a0 : 0 < a), a * b < 1","name":"Left.mul_lt_of_le_of_lt_one_of_pos","isProp":true,"docString":"Assumes left covariance. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}\n  (t : CategoryTheory.Limits.PushoutCocone f g) {W : C} {k : CategoryTheory.Limits.Cocone.pt t ‚ü∂ W}\n  {l : CategoryTheory.Limits.Cocone.pt t ‚ü∂ W}\n  (h‚ÇÄ : CategoryTheory.Limits.PushoutCocone.inl t ‚â´ k = CategoryTheory.Limits.PushoutCocone.inl t ‚â´ l)\n  (h‚ÇÅ : CategoryTheory.Limits.PushoutCocone.inr t ‚â´ k = CategoryTheory.Limits.PushoutCocone.inr t ‚â´ l)\n  (j : CategoryTheory.Limits.WalkingSpan),\n  (CategoryTheory.Limits.Cocone.Œπ t).app j ‚â´ k = (CategoryTheory.Limits.Cocone.Œπ t).app j ‚â´ l","name":"CategoryTheory.Limits.PushoutCocone.coequalizer_ext","isProp":true,"docString":"To check whether a morphism is coequalized by the maps of a pushout cocone, it suffices to check\nit for `inl t` and `inr t` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {k : Set Œ≤} {s : Set Œ≤}\n  {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hks : k ‚äÜ s) (hf : ContinuousOn f s),\n  ‚àÉ (t : Set Œ≤), (k ‚äÜ t : Prop) ‚àß ((IsOpen t : Prop) ‚àß (Metric.Bounded (f '' (t ‚à© s)) : Prop) : Prop)","name":"Metric.exists_isOpen_bounded_image_inter_of_isCompact_of_continuousOn","isProp":true,"docString":"If a function is continuous on a set `s` containing a compact set `k`, then it is bounded on\nsome open neighborhood of `k` in `s`. "},{"type":"‚àÄ {G : Type u_2} [inst : AddGroup G] {Œπ : Type u_1} (s : Finset Œπ) (f : (a : Œπ) ‚Üí G)\n  (comm : Set.Pairwise ‚Üës fun (a : Œπ) (b : Œπ) ‚Ü¶ AddCommute (f a) (f b)) (K : (a : Œπ) ‚Üí AddSubgroup G)\n  (hind : CompleteLattice.Independent K) (hmem : ‚àÄ (x : Œπ) (a : x ‚àà s), f x ‚àà K x)\n  (heq1 : Finset.noncommSum s f comm = 0) (i : Œπ) (a : i ‚àà s), f i = 0","name":"AddSubgroup.eq_zero_of_noncommSum_eq_zero_of_independent","isProp":true,"docString":"`Finset.noncommSum` is ‚Äúinjective‚Äù in `f` if `f` maps into independent subgroups.\nThis generalizes (one direction of) `AddSubgroup.disjoint_iff_add_eq_zero`. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {n : ‚Ñï} {F : (a : ‚Ñï) ‚Üí ‚Ñö}\n  (hF : ‚àÄ (i : ‚Ñï) (a : i < n), 0 < padicValRat p (F i)) (hn0 : (Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ F i) ‚â† 0),\n  0 < padicValRat p (Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ F i)","name":"padicValRat.sum_pos_of_pos","isProp":true,"docString":"A finite sum of rationals with positive `p`-adic valuation has positive `p`-adic valuation\n(if the sum is non-zero). "},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {N : outParam (Type u_3)} [inst : One M] [inst_1 : One N]\n  [self : OneHomClass F M N] (f : F), ‚Üëf 1 = 1","name":"OneHomClass.map_one","isProp":true,"docString":"The proposition that the function preserves 1 "},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E] [inst_2 : ContinuousAdd E]\n  [inst_3 : Nontrivial E] [inst_4 : Module ‚Ñù E] [inst : ContinuousSMul ‚Ñù E] (x : E), Filter.NeBot (nhdsWithin x ({x}·∂ú))","name":"Real.punctured_nhds_module_neBot","isProp":true,"docString":"If `E` is a nontrivial topological module over `‚Ñù`, then `E` has no isolated points.\nThis is a particular case of `Module.punctured_nhds_neBot`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (s : Finset Œ±) (f : (a : Œ±) ‚Üí ‚Ñ§),\n  ‚àÉ (Œ≤ : Type u_1),\n    ‚àÉ (x : Fintype Œ≤),\n      ‚àÉ (sgn : (a : Œ≤) ‚Üí SignType),\n        ‚àÉ (g : (a : Œ≤) ‚Üí Œ±),\n          (‚àÄ (b : Œ≤), g b ‚àà s : Prop) ‚àß\n            ((Fintype.card Œ≤ = Finset.sum s fun (a : Œ±) ‚Ü¶ Int.natAbs (f a) : Prop) ‚àß\n                (‚àÄ (a : Œ±) (a_1 : a ‚àà s),\n                    (Finset.sum Finset.univ fun (b : Œ≤) ‚Ü¶ if (g b = a : Prop) then ‚Üë(sgn b) else 0) = f a :\n                  Prop) :\n              Prop)","name":"exists_signed_sum","isProp":true,"docString":"We can decompose a sum of absolute value `n` into a sum of `n` signs. "},{"type":"‚àÄ {M : Type u_2} [inst : Monoid M] {N : Type u_1} [inst_1 : Monoid N] {f : (a : M) ‚Üí N} (hf : IsMonoidHom f) {s : Set N}\n  (hs : IsSubmonoid s), IsSubmonoid (f ‚Åª¬π' s)","name":"IsSubmonoid.preimage","isProp":true,"docString":"The preimage of a submonoid under a monoid hom is a submonoid of the domain. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ‚àà s) (p2 : P),\n  (p -·µ• p2 ‚àà AffineSubspace.direction s : Prop) ‚Üî (p2 ‚àà s : Prop)","name":"AffineSubspace.vsub_left_mem_direction_iff_mem","isProp":true,"docString":"Given a point in an affine subspace, a result of subtracting that point on the left is in the\ndirection if and only if the other point is in the subspace. "},{"type":"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero Œ±] (v : (a : n) ‚Üí Œ±),\n  Matrix.IsSymm (Matrix.diagonal v)","name":"Matrix.isSymm_diagonal","isProp":true,"docString":"The diagonal matrix `diagonal v` is symmetric. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Isometry f) (s : Set Œ±), EMetric.diam (f '' s) = EMetric.diam s","name":"Isometry.ediam_image","isProp":true,"docString":"Isometries preserve the diameter in pseudoemetric spaces. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C·µí·µñ ‚•§ D),\n  CategoryTheory.Functor.leftOp (CategoryTheory.Functor.rightOp F) = F","name":"CategoryTheory.Functor.rightOp_leftOp_eq","isProp":true,"docString":"Whenever possible, it is advisable to use the isomorphism `rightOpLeftOpIso`\ninstead of this equality of functors. "},{"type":"‚àÄ {J : Type v} [inst : CategoryTheory.SmallCategory J] {F : J ‚•§ TypeMax} (x : CategoryTheory.Limits.colimit F),\n  ‚àÉ (j : J), ‚àÉ (y : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) j), CategoryTheory.Limits.colimit.Œπ F j y = x","name":"CategoryTheory.Limits.Types.jointly_surjective'","isProp":true,"docString":"A variant of `jointly_surjective` for `x : colimit F`. "},{"type":"‚àÄ {R : Type u_2} [inst : CommSemiring R] (M : Submonoid R) (S : Type u_1) [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] (J : Ideal S),\n  (Ideal.IsPrime J : Prop) ‚Üî\n    ((Ideal.IsPrime (Ideal.comap (algebraMap R S) J) : Prop) ‚àß (Disjoint ‚ÜëM ‚Üë(Ideal.comap (algebraMap R S) J) : Prop) :\n      Prop)","name":"IsLocalization.isPrime_iff_isPrime_disjoint","isProp":true,"docString":"If `R` is a ring, then prime ideals in the localization at `M`\ncorrespond to prime ideals in the original ring `R` that are disjoint from `M`.\nThis lemma gives the particular case for an ideal and its comap,\nsee `le_rel_iso_of_prime` for the more general relation isomorphism "},{"type":"‚àÄ {R : Type u} {N : Type z} [inst : Semiring R] [inst_1 : AddCommMonoid N] [inst_2 : Module R N] {P : Type v}\n  [inst_3 : AddCommMonoid P] [inst_4 : Module R P] (x : Module.Free R P) (e : P ‚âÉ‚Çó[R] N), Module.Free R N","name":"Module.Free.of_equiv'","isProp":true,"docString":"A variation of `of_equiv`: the assumption `Module.Free R P` here is explicit rather than an\ninstance. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {e : Œ± ‚âÉ Œ≤} {s : Set Œ±} {t : Set Œ≤} (a : Set.BijOn (‚Üëe) s t),\n  Set.BijOn (‚Üë(Equiv.symm e)) t s","name":"Set.BijOn.equiv_symm","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.bijOn_symm`."},{"type":"‚àÄ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] {M : Submonoid A} (hM : M ‚â§ nonZeroDivisors A),\n  IsDomain (Localization M)","name":"IsLocalization.isDomain_localization","isProp":true,"docString":"The localization at of an integral domain to a set of non-zero elements is an integral domain.\nSee note [reducible non-instances]. "},{"type":"True","name":"trivial","isProp":true,"docString":"`True` is true, and `True.intro` (or more commonly, `trivial`)\nis the proof. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {p : (a : M) ‚Üí Prop} (x : M) {s : Set M} (hs : Subsemigroup.closure s = ‚ä§)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s), p x) (Hmul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x * y)), p x","name":"Subsemigroup.dense_induction","isProp":true,"docString":"If `s` is a dense set in a magma `M`, `Subsemigroup.closure s = ‚ä§`, then in order to prove that\nsome predicate `p` holds for all `x : M` it suffices to verify `p x` for `x ‚àà s`,\nand verify that `p x` and `p y` imply `p (x * y)`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i‚ÇÄ : Œπ),\n  vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : { x : Œπ // x ‚â† i‚ÇÄ }) ‚Ü¶ p i‚ÇÄ -·µ• p ‚Üëi)","name":"vectorSpan_range_eq_span_range_vsub_left_ne","isProp":true,"docString":"The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the left, excluding the subtraction of that point from itself. "},{"type":"‚àÄ {G : Type u} {x : G} [inst : AddMonoid G], (0 < addOrderOf x : Prop) ‚Üî (IsOfFinAddOrder x : Prop)","name":"addOrderOf_pos_iff","isProp":true,"docString":"A group element has finite additive order iff its order is positive."},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p‚ÇÅ : (a : Œπ) ‚Üí P) (p‚ÇÇ : P) (b : P),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ)) =\n    ‚Üë(Finset.weightedVSubOfPoint s p‚ÇÅ b) w - (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) ‚Ä¢ (p‚ÇÇ -·µ• b)","name":"Finset.sum_smul_vsub_const_eq_weightedVSubOfPoint_sub","isProp":true,"docString":"A weighted sum of pairwise subtractions, where the point on the right is constant,\nexpressed as a subtraction involving a `weightedVSubOfPoint` expression. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CompleteLattice Œ±] [inst_1 : CompleteLattice Œ≤] (self : FrameHom Œ± Œ≤)\n  (s : Set Œ±),\n  InfHom.toFun (InfTopHom.toInfHom (FrameHom.toInfTopHom self)) (sup‚Çõ s) =\n    sup‚Çõ (InfHom.toFun (InfTopHom.toInfHom (FrameHom.toInfTopHom self)) '' s)","name":"FrameHom.map_sup‚Çõ'","isProp":true,"docString":"The proposition that frame homomorphisms commute with arbitrary suprema/joins. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {b : Œ±}\n  (hab : a < b) (s : Set Œ±),\n  List.TFAE\n    [(s ‚àà nhdsWithin a (Set.Ioi a) : Prop), (s ‚àà nhdsWithin a (Set.Ioc a b) : Prop),\n      (s ‚àà nhdsWithin a (Set.Ioo a b) : Prop), (‚àÉ (u : Œ±), (u ‚àà Set.Ioc a b : Prop) ‚àß (Set.Ioo a u ‚äÜ s : Prop) : Prop),\n      (‚àÉ (u : Œ±), (u ‚àà Set.Ioi a : Prop) ‚àß (Set.Ioo a u ‚äÜ s : Prop) : Prop)]","name":"TFAE_mem_nhdsWithin_Ioi","isProp":true,"docString":"The following statements are equivalent:\n\n0. `s` is a neighborhood of `a` within `(a, +‚àû)`;\n1. `s` is a neighborhood of `a` within `(a, b]`;\n2. `s` is a neighborhood of `a` within `(a, b)`;\n3. `s` includes `(a, u)` for some `u ‚àà (a, b]`;\n4. `s` includes `(a, u)` for some `u > a`.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤]\n  (f : (a : Œ±) ‚Üí Œ≤) {w : (a : Œ±) ‚Üí M} {b : M} [inst_3 : LinearOrderedCancelAddCommMonoid M] [inst_4 : Nonempty Œ≤]\n  (hb : Fintype.card Œ≤ ‚Ä¢ b ‚â§ Finset.sum Finset.univ fun (x : Œ±) ‚Ü¶ w x),\n  ‚àÉ (y : Œ≤), b ‚â§ Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ) fun (x : Œ±) ‚Ü¶ w x","name":"Fintype.exists_le_sum_fiber_of_nsmul_le_sum","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons of different weights, non-strict inequality\nversion: there is a pigeonhole with the total weight of pigeons in it greater than or equal to `b`\nprovided that the total number of pigeonholes times `b` is less than or equal to the total weight of\nall pigeons. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) {w : (a : Œπ) ‚Üí k} {p : (a : Œπ) ‚Üí P}\n  (hw : ‚Üë(Finset.weightedVSub s p) w = 0) {i : Œπ} [inst_3 : DecidablePred fun (x : Œπ) ‚Ü¶ x ‚â† i] (his : i ‚àà s)\n  (hwi : w i = -1), ‚Üë(Finset.affineCombination k (Finset.filter (fun (x : Œπ) ‚Ü¶ x ‚â† i) s) p) w = p i","name":"Finset.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one","isProp":true,"docString":"If a weighted sum is zero and one of the weights is `-1`, the corresponding point is\nthe affine combination of the other points with the given weights. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±] {a : Œ±} (a_1 : a ‚ãñ ‚ä§), IsCoatom a","name":"Covby.is_coatom","isProp":true,"docString":"**Alias** of the forward direction of `covby_top_iff`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±} {r : ‚Ñù} (h : 0 ‚â§ r), Metric.diam (Metric.closedBall x r) ‚â§ 2 * r","name":"Metric.diam_closedBall","isProp":true,"docString":"The diameter of a closed ball of radius `r` is at most `2 r`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : EMetricSpace Œ±] {K : NNReal} {f : (a : Œ±) ‚Üí Œ±} (hf : ContractingWith K f) {s : Set Œ±}\n  (hs : Set.MapsTo f s s), ContractingWith K (Set.MapsTo.restrict f s s hs)","name":"ContractingWith.restrict","isProp":true,"docString":"If a map `f` is `ContractingWith K`, and `s` is a forward-invariant set, then\nrestriction of `f` to `s` is `ContractingWith K` as well. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Set Œ±},\n  (¬¨(BddBelow s : Prop) : Prop) ‚Üî (‚àÄ (x : Œ±), ‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (y < x : Prop) : Prop)","name":"not_bddBelow_iff","isProp":true,"docString":"A set `s` is not bounded below if and only if for each `x` there exists `y ‚àà s` that is less\nthan `x`. A version for preorders is called `not_bddBelow_iff'`. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (f : (a : ‚Ñï) ‚Üí R)\n  (g : (a : ‚Ñï) ‚Üí M) (n : ‚Ñï),\n  (Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f i ‚Ä¢ g i) =\n    (f (n - 1) ‚Ä¢ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ g i) -\n      Finset.sum (Finset.range (n - 1)) fun (i : ‚Ñï) ‚Ü¶\n        (f (i + 1) - f i) ‚Ä¢ Finset.sum (Finset.range (i + 1)) fun (i : ‚Ñï) ‚Ü¶ g i","name":"Finset.sum_range_by_parts","isProp":true,"docString":"**Summation by parts** for ranges "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n  {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (inf·µ¢ g)) (Mf : Monotone f) (ftop : f ‚ä§ = ‚ä§),\n  f (inf·µ¢ g) = inf·µ¢ (f ‚àò g)","name":"Monotone.map_inf·µ¢_of_continuousAt","isProp":true,"docString":"If a monotone function sending `top` to `top` is continuous at the indexed infimum over\na `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. "},{"type":"‚àÄ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S]\n  [inst_2 : Nontrivial S] (f : F), ¬¨(1 ‚àà RingHom.ker f : Prop)","name":"RingHom.not_one_mem_ker","isProp":true,"docString":"If the target is not the zero ring, then one is not in the kernel."},{"type":"‚àÄ (n : ‚Ñï) (k : ‚Ñï), Nat.factorial n * Nat.ascFactorial n k = Nat.factorial (n + k)","name":"Nat.factorial_mul_ascFactorial","isProp":true,"docString":"`n.ascFactorial k = (n + k)! / n!` but without ‚Ñï-division. See `Nat.ascFactorial_eq_div` for\nthe version with ‚Ñï-division. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤},\n  (StrictConvexOn ùïú s (-f) : Prop) ‚Üî (StrictConcaveOn ùïú s f : Prop)","name":"neg_strictConvexOn_iff","isProp":true,"docString":"A function `-f` is strictly convex iff `f` is strictly concave. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {x : M} {y : M} {z : M} (a : y ‚àà powers x) (a : z ‚àà powers x), y * z ‚àà powers x","name":"powers.mul_mem","isProp":true,"docString":"The set of natural number powers of an element of a monoid is closed under multiplication. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {b‚ÇÅ : Basis Œπ R M} {b‚ÇÇ : Basis Œπ R M} (a : ‚àÄ (i : Œπ), ‚Üëb‚ÇÅ i = ‚Üëb‚ÇÇ i), b‚ÇÅ = b‚ÇÇ","name":"Basis.eq_of_apply_eq","isProp":true,"docString":"Two bases are equal if their basis vectors are the same. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) (c : Composition (List.length (List.join L)))\n  (h : List.map List.length L = Composition.blocks c), List.splitWrtComposition (List.join L) c = L","name":"List.splitWrtComposition_join","isProp":true,"docString":"If one joins a list of lists and then splits the join along the right composition, one gets\nback the original list of lists. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} {L‚ÇÉ : List (Œ± √ó Bool)} (a : FreeGroup.Red L‚ÇÅ L‚ÇÇ)\n  (a : FreeGroup.Red L‚ÇÅ L‚ÇÉ), Relation.Join FreeGroup.Red L‚ÇÇ L‚ÇÉ","name":"FreeGroup.Red.church_rosser","isProp":true,"docString":"**Church-Rosser theorem** for word reduction: If `w1 w2 w3` are words such that `w1` reduces\nto `w2` and `w3` respectively, then there is a word `w4` such that `w2` and `w3` reduce to `w4`\nrespectively. This is also known as Newman's diamond lemma. "},{"type":"‚àÄ {X : Type u} {Œ± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Œ±] [inst_2 : TopologicalSpace Œ±]\n  [inst_3 : OrderClosedTopology Œ±] [inst_4 : PreconnectedSpace X] (a : X) (b : X) {f : (a : X) ‚Üí Œ±} (hf : Continuous f),\n  Set.Icc (f a) (f b) ‚äÜ Set.range f","name":"intermediate_value_univ","isProp":true,"docString":"**Intermediate Value Theorem** for continuous functions on connected spaces. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Add G] [inst_1 : Add H] (f : AddHom G H) (hf : Function.Injective ‚Üëf) (a0 : G)\n  (b0 : G) {A : Finset H} {B : Finset H} (u : UniqueAdd A B (‚Üëf a0) (‚Üëf b0)),\n  UniqueAdd\n    (Finset.preimage A ‚Üëf\n      ((Set.injOn_of_injective hf (‚Üëf ‚Åª¬π' ‚ÜëA)=:Set.InjOn (‚Üëf) (‚Üëf ‚Åª¬π' ‚ÜëA))=:Set.InjOn (‚Üëf) (‚Üëf ‚Åª¬π' ‚ÜëA)))\n    (Finset.preimage B ‚Üëf\n      ((Set.injOn_of_injective hf (‚Üëf ‚Åª¬π' ‚ÜëB)=:Set.InjOn (‚Üëf) (‚Üëf ‚Åª¬π' ‚ÜëB))=:Set.InjOn (‚Üëf) (‚Üëf ‚Åª¬π' ‚ÜëB)))\n    a0 b0","name":"UniqueAdd.addHom_preimage","isProp":true,"docString":"`UniqueAdd` is preserved by inverse images under injective, additive maps."},{"type":"‚àÄ (b : Ordinal) (o : Ordinal),\n  List.foldr (fun (p : Ordinal √ó Ordinal) (r : Ordinal) ‚Ü¶ b ^ Prod.fst p * Prod.snd p + r) 0 (Ordinal.CNF b o) = o","name":"Ordinal.CNF_foldr","isProp":true,"docString":"Evaluating the Cantor normal form of an ordinal returns the ordinal. "},{"type":"‚àÄ (p' : ‚Ñï) (h : lucasLehmerResidue (p' + 2) = 0), orderOf (LucasLehmer.œâUnit (p' + 2)) = 2 ^ (p' + 2)","name":"LucasLehmer.order_œâ","isProp":true,"docString":"The order of `œâ` in the unit group is exactly `2^p`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} (self : CategoryTheory.Limits.IsZero X) (Y : C),\n  Nonempty (Unique (Y ‚ü∂ X))","name":"CategoryTheory.Limits.IsZero.unique_from","isProp":true,"docString":"there are unique morphisms from the object "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {Œπ : Type u_1} [inst_2 : Nonempty Œπ]\n  {V : (a : Œπ) ‚Üí Set Œ±} (hV : Directed (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äá x_1) V)\n  (hV_cpct : ‚àÄ (i : Œπ), IsCompact (V i)) {U : Set Œ±}\n  (hU : ‚àÄ (x : Œ±) (a : x ‚àà Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ V i), U ‚àà nhds x), ‚àÉ (i : Œπ), V i ‚äÜ U","name":"exists_subset_nhds_of_isCompact","isProp":true,"docString":"If `V : Œπ ‚Üí Set Œ±` is a decreasing family of compact sets then any neighborhood of\n`‚ãÇ i, V i` contains some `V i`. This is a version of `exists_subset_nhd_of_compact'` where we\ndon't need to assume each `V i` closed because it follows from compactness since `Œ±` is\nassumed to be Hausdorff. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ≥] {a : Œ±} {b : Œ±}\n  {h : a ‚â§ b} [inst_2 : TopologicalSpace Œ±] [inst_3 : OrderTopology Œ±] [inst_4 : TopologicalSpace Œ≤]\n  {f : (a_1 : Œ≥) ‚Üí (a : ‚Üë(Set.Icc a b)) ‚Üí Œ≤} {g : (a : Œ≥) ‚Üí Œ±} (hf : Continuous ‚Üøf) (hg : Continuous g),\n  Continuous fun (a_1 : Œ≥) ‚Ü¶ Set.IccExtend h (f a_1) (g a_1)","name":"Continuous.IccExtend","isProp":true,"docString":"See Note [continuity lemma statement]. "},{"type":"‚àÄ {Œ± : Type u_2} {E : Type u_3} {ùïú : Type u_1} [inst : Norm E] [inst_1 : NormedField ùïú] {f : (a : Œ±) ‚Üí E} {l : Filter Œ±}\n  {c : ùïú} {g : (a : Œ±) ‚Üí ùïú} (hc : c ‚â† 0) (a : f =Œò[l] g), f =Œò[l] fun (x : Œ±) ‚Ü¶ c * g x","name":"Asymptotics.IsTheta.const_mul_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isTheta_const_mul_right`."},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddMonoid G] [self : AddAction G P] (p : P), 0 +·µ• p = p","name":"AddAction.zero_vadd","isProp":true,"docString":"Zero is a neutral element for `+·µ•` "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f : Con.Quotient c ‚Üí* P)\n  (g : Con.Quotient c ‚Üí* P) (h : ‚àÄ (a : M), ‚Üëf ‚Üëa = ‚Üëg ‚Üëa), f = g","name":"Con.lift_funext","isProp":true,"docString":"Homomorphisms on the quotient of a monoid by a congruence relation are equal if they\nare equal on elements that are coercions from the monoid. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a * b < c), b < a‚Åª¬π * c","name":"lt_inv_mul_of_mul_lt","isProp":true,"docString":"**Alias** of the reverse direction of `lt_inv_mul_iff_mul_lt`."},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : Nontrivial R] (s : Subring R), Nontrivial { x : R // x ‚àà s }","name":"Subring.instNontrivialSubtypeMemSubringInstMembershipInstSetLikeSubring","isProp":true,"docString":"A subring of a non-trivial ring is non-trivial. "},{"type":"‚àÄ (M : Type u_2) (Œ± : Type u_1) [inst : Group M] [inst_1 : MulAction M Œ±] {s : Set Œ±} {t : Set Œ±},\n  fixingSubgroup M (s ‚à™ t) = fixingSubgroup M s ‚äì fixingSubgroup M t","name":"fixingSubgroup_union","isProp":true,"docString":"Fixing subgroup of union is intersection "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommRing R] {M : Type u_3} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {BR : RingFilterBasis R} {B : (a : Œπ) ‚Üí Submodule R M} (self : RingFilterBasis.SubmodulesBasis BR B) (m : M) (i : Œπ),\n  ‚àÉ (U : Set R), (U ‚àà BR : Prop) ‚àß (U ‚äÜ (fun (x : R) ‚Ü¶ x ‚Ä¢ m) ‚Åª¬π' ‚Üë(B i) : Prop)","name":"RingFilterBasis.SubmodulesBasis.smul","isProp":true,"docString":"For any element `m : M` and any set `B i` in the submodule basis on `M`,\nthere is a `U` in the ring filter basis on `R` such that `U ‚¨ù m` is in `B i`. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} {R : Type u_1} [inst : Semiring k] [inst_1 : MulOneClass G] [inst_2 : Semiring R]\n  {f : MonoidAlgebra k G ‚Üí+* R} {g : MonoidAlgebra k G ‚Üí+* R}\n  (h‚ÇÅ : RingHom.comp f MonoidAlgebra.singleOneRingHom = RingHom.comp g MonoidAlgebra.singleOneRingHom)\n  (h_of : MonoidHom.comp (‚Üëf) (MonoidAlgebra.of k G) = MonoidHom.comp (‚Üëg) (MonoidAlgebra.of k G)), f = g","name":"MonoidAlgebra.ringHom_ext'","isProp":true,"docString":"If two ring homomorphisms from `MonoidAlgebra k G` are equal on all `single a 1`\nand `single 1 b`, then they are equal.\n\nSee note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : IsSuccArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (hr : Reflexive r)\n  (h1 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico n m), r i (Order.succ i)) (h2 : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico m n), r (Order.succ i) i),\n  Relation.TransGen r n m","name":"transGen_of_succ_of_reflexive","isProp":true,"docString":"`(n, m)` is in the transitive closure of a reflexive relation `~` if `i ~ succ i` and\n`succ i ~ i` for all `i` between `n` and `m`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (s : Set Œ±)\n  (hs : Set.Subsingleton (f '' s)), Set.Subsingleton s","name":"Set.subsingleton_of_image","isProp":true,"docString":"If the image of a set under an injective map is a subsingleton, the set is a subsingleton. "},{"type":"‚àÄ {F : Type u_2} {Œ± : Type u_1} {Œ≤ : Type u_3} [inst : FunLike F Œ± fun (x : Œ±) ‚Ü¶ Œ≤] [inst_1 : AddCommMonoid Œ±]\n  [inst_2 : AddCancelCommMonoid Œ≤] {A : Set Œ±} {m : ‚Ñï} {n : ‚Ñï} [inst_3 : AddFreimanHomClass F A Œ≤ n] (h : m ‚â§ n),\n  AddFreimanHomClass F A Œ≤ m","name":"AddFreimanHom.addFreimanHomClass_of_le","isProp":true,"docString":"An additive `n`-Freiman homomorphism is\nalso an additive `m`-Freiman homomorphism for any `m ‚â§ n`."},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] (s : Subsemiring R) {Œπ : Type u_2} {t : Finset Œπ} {f : (a : Œπ) ‚Üí R}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà s), (Finset.prod t fun (i : Œπ) ‚Ü¶ f i) ‚àà s","name":"Subsemiring.prod_mem","isProp":true,"docString":"Product of elements of a subsemiring of a `CommSemiring` indexed by a `Finset` is in the\nsubsemiring. "},{"type":"‚àÄ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {W : CategoryTheory.MorphismProperty C} {E : Type u_5} [inst_2 : CategoryTheory.Category E]\n  (self : CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L W E),\n  CategoryTheory.MorphismProperty.IsInvertedBy W L","name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.inverts","isProp":true,"docString":"the functor `L` inverts `W` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (J : CategoryTheory.GrothendieckTopology C) (A : Type u‚ÇÇ)\n  [inst_1 : CategoryTheory.Category A] {F : CategoryTheory.Sheaf J A} {G : CategoryTheory.Sheaf J A} (f : F ‚ü∂ G)\n  [h : CategoryTheory.Mono (CategoryTheory.Sheaf.Hom.val f)], CategoryTheory.Mono f","name":"CategoryTheory.Sheaf.Hom.mono_of_presheaf_mono","isProp":true,"docString":"This is stated as a lemma to prevent class search from forming a loop since a sheaf morphism is\nmonic if and only if it is monic as a presheaf morphism (under suitable assumption)."},{"type":"‚àÄ {X : Type v} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : SigmaCompactSpace X]\n  [inst_3 : T2Space X] {Œπ : (a : X) ‚Üí Type u} {p : (x : X) ‚Üí (a : Œπ x) ‚Üí Prop} {B : (x : X) ‚Üí (a : Œπ x) ‚Üí Set X}\n  {s : Set X} (hs : IsClosed s) (hB : ‚àÄ (x : X) (a : x ‚àà s), Filter.HasBasis (nhds x) (p x) (B x)),\n  ‚àÉ (Œ± : Type v),\n    ‚àÉ (c : (a : Œ±) ‚Üí X),\n      ‚àÉ (r : (a : Œ±) ‚Üí Œπ (c a)),\n        (‚àÄ (a : Œ±), (c a ‚àà s : Prop) ‚àß (p (c a) (r a) : Prop) : Prop) ‚àß\n          ((s ‚äÜ Set.union·µ¢ fun (a : Œ±) ‚Ü¶ B (c a) (r a) : Prop) ‚àß (LocallyFinite fun (a : Œ±) ‚Ü¶ B (c a) (r a) : Prop) :\n            Prop)","name":"refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set","isProp":true,"docString":"Let `X` be a locally compact sigma compact Hausdorff topological space, let `s` be a closed set\nin `X`. Suppose that for each `x ‚àà s` the sets `B x : Œπ x ‚Üí Set X` with the predicate\n`p x : Œπ x ‚Üí Prop` form a basis of the filter `ùìù x`. Then there exists a locally finite covering\n`fun i ‚Ü¶ B (c i) (r i)` of `s` such that all ‚Äúcenters‚Äù `c i` belong to `s` and each `r i` satisfies\n`p (c i)`.\n\nThe notation is inspired by the case `B x r = Metric.ball x r` but the theorem applies to\n`nhds_basis_opens` as well. If the covering must be subordinate to some open covering of `s`, then\nthe user should use a basis obtained by `Filter.HasBasis.restrict_subset` or a similar lemma, see\nthe proof of `paracompact_of_locallyCompact_sigmaCompact` for an example.\n\nThe formalization is based on two [ncatlab](https://ncatlab.org/) proofs:\n* [locally compact and sigma compact spaces are paracompact](https://ncatlab.org/nlab/show/locally+compact+and+sigma-compact+spaces+are+paracompact);\n* [open cover of smooth manifold admits locally finite refinement by closed balls](https://ncatlab.org/nlab/show/partition+of+unity#ExistenceOnSmoothManifolds).\n\nSee also `refinement_of_locallyCompact_sigmaCompact_of_nhds_basis` for a version of this lemma\ndealing with a covering of the whole space.\n\nIn most cases (namely, if `B c r ‚à™ B c r'` is again a set of the form `B c r''`) it is possible\nto choose `Œ± = X`. This fact is not yet formalized in `mathlib`. "},{"type":"‚àÄ {V : Type u‚ÇÅ} [inst : Quiver V] {C : Type u_1} [inst_1 : CategoryTheory.Category C] {F : CategoryTheory.Paths V ‚•§ C}\n  {G : CategoryTheory.Paths V ‚•§ C}\n  (h_obj :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) = Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G))\n  (h :\n    ‚àÄ (a : V) (b : V) (e : a ‚ü∂ b),\n      Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) (Quiver.Hom.toPath e) =\n        CategoryTheory.eqToHom\n            ((congr_fun h_obj\n                  a=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) a =\n                  Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G)\n                    a)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) a =\n                Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) a) ‚â´\n          Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) (Quiver.Hom.toPath e) ‚â´\n            CategoryTheory.eqToHom\n              ((congr_fun\n                    ((Eq.symm\n                          h_obj=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) =\n                          Prefunctor.obj\n                            (CategoryTheory.Functor.toPrefunctor\n                              F))=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) =\n                        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F))\n                    b=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) b =\n                    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F)\n                      b)=:Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) b =\n                  Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) b)),\n  F = G","name":"CategoryTheory.Paths.ext_functor","isProp":true,"docString":"Two functors out of a path category are equal when they agree on singleton paths. "},{"type":"‚àÄ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : IsNoetherian K V], Module.rank K V < Cardinal.aleph0","name":"IsNoetherian.rank_lt_aleph0","isProp":true,"docString":"The dimension of a noetherian module over a division ring, as a cardinal,\nis strictly less than the first infinite cardinal `‚Ñµ‚ÇÄ`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.SmallCategory C] [inst_1 : CategoryTheory.Limits.HasProducts C], Quiver.IsThin C","name":"CategoryTheory.instIsThinToQuiverToCategoryStruct","isProp":true,"docString":"A small category with products is a thin category.\n\nin Lean, a preorder category is one where the morphisms are in Prop, which is weaker than the usual\nnotion of a preorder/thin category which says that each homset is subsingleton; we show the latter\nrather than providing a `Preorder C` instance.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  (hf : ‚àÄ (x : Œ≤) (y : Œ≤), f x = f y), Measurable f","name":"measurable_const'","isProp":true,"docString":"A version of `measurable_const` that assumes `f x = f y` for all `x, y`. This version works\nfor functions between empty types. "},{"type":"‚àÄ {M : Type u} [self : Monoid M] (a : M), a * 1 = a","name":"Monoid.mul_one","isProp":true,"docString":"One is a right neutral element for multiplication "},{"type":"‚àÄ {Œ± : Type u} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ±} (i : ‚Ñï), List.take (List.length l‚ÇÅ + i) (l‚ÇÅ ++ l‚ÇÇ) = l‚ÇÅ ++ List.take i l‚ÇÇ","name":"List.take_append","isProp":true,"docString":"Taking the first `l‚ÇÅ.length + i` elements in `l‚ÇÅ ++ l‚ÇÇ` is the same as appending the first\n`i` elements of `l‚ÇÇ` to `l‚ÇÅ`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y} (h‚ÇÄ : f = g)\n  {c : CategoryTheory.Limits.Fork f g} (h : CategoryTheory.Limits.IsLimit c),\n  CategoryTheory.IsIso (CategoryTheory.Limits.Fork.Œπ c)","name":"CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_eq","isProp":true,"docString":"Every equalizer of `(f, g)`, where `f = g`, is an isomorphism. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (K : AddSubgroup G) {l : List G} (a : ‚àÄ (x : G) (a : x ‚àà l), x ‚àà K), List.sum l ‚àà K","name":"AddSubgroup.list_sum_mem","isProp":true,"docString":"Sum of a list of elements in an `AddSubgroup` is in the `AddSubgroup`."},{"type":"‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí ‚Ñù} {g : (a : Œ±) ‚Üí ‚Ñù} {t‚ÇÄ : Filter Œ±} (hf : ‚àÄ (t : Œ±), 0 ‚â§ f t)\n  (hft : ‚àÄ (t : Œ±), f t ‚â§ g t) (g0 : Filter.Tendsto g t‚ÇÄ (nhds 0)), Filter.Tendsto f t‚ÇÄ (nhds 0)","name":"squeeze_zero","isProp":true,"docString":"Special case of the sandwich theorem; see `tendsto_of_tendsto_of_tendsto_of_le_of_le`\nand  `tendsto_of_tendsto_of_tendsto_of_le_of_le'` for the general case. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] [inst_1 : CompleteSpace Œ±], BaireSpace Œ±","name":"baire_category_theorem_emetric_complete","isProp":true,"docString":"Baire theorems asserts that various topological spaces have the Baire property.\nTwo versions of these theorems are given.\nThe first states that complete pseudo_emetric spaces are Baire. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {n : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroDivisors R] {B : M ‚Üí‚Çó[R] M ‚Üí‚Çó[R] R} (v : Basis n R M) (hO : LinearMap.IsOrtho·µ¢ B ‚Üëv)\n  (h : ‚àÄ (i : n), ¬¨(LinearMap.IsOrtho B (‚Üëv i) (‚Üëv i) : Prop)), LinearMap.Nondegenerate B","name":"LinearMap.IsOrtho·µ¢.nondegenerate_of_not_isOrtho_basis_self","isProp":true,"docString":"Given an orthogonal basis with respect to a bilinear form, the bilinear form is nondegenerate\nif the basis has no elements which are self-orthogonal. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S‚ÇÅ : Submodule K V)\n  (S‚ÇÇ : Submodule K V) [inst_3 : FiniteDimensional K { x : V // x ‚àà S‚ÇÇ }], FiniteDimensional K { x : V // x ‚àà S‚ÇÅ ‚äì S‚ÇÇ }","name":"Submodule.finiteDimensional_inf_right","isProp":true,"docString":"The inf of two submodules, the second finite-dimensional, is\nfinite-dimensional. "},{"type":"‚àÄ (Œ± : Type u) {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] (b : Œ≤) [inst_2 : Fintype Œ±]\n  [inst_3 : Fintype ‚Üë(MulAction.orbit Œ± b)] [inst_4 : Fintype { x : Œ± // x ‚àà MulAction.stabilizer Œ± b }],\n  Fintype.card ‚Üë(MulAction.orbit Œ± b) * Fintype.card { x : Œ± // x ‚àà MulAction.stabilizer Œ± b } = Fintype.card Œ±","name":"MulAction.card_orbit_mul_card_stabilizer_eq_card_group","isProp":true,"docString":"Orbit-stabilizer theorem. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_4} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) {w‚ÇÅ : (a : Œπ) ‚Üí k} {w‚ÇÇ : (a : Œπ) ‚Üí k}\n  (hw : ‚àÄ (i : Œπ) (a : i ‚àà s), w‚ÇÅ i = w‚ÇÇ i) {p‚ÇÅ : (a : Œπ) ‚Üí P} {p‚ÇÇ : (a : Œπ) ‚Üí P}\n  (hp : ‚àÄ (i : Œπ) (a : i ‚àà s), p‚ÇÅ i = p‚ÇÇ i) (b : P),\n  ‚Üë(Finset.weightedVSubOfPoint s p‚ÇÅ b) w‚ÇÅ = ‚Üë(Finset.weightedVSubOfPoint s p‚ÇÇ b) w‚ÇÇ","name":"Finset.weightedVSubOfPoint_congr","isProp":true,"docString":"`weightedVSubOfPoint` gives equal results for two families of weights and two families of\npoints that are equal on `s`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {W : CategoryTheory.MorphismProperty C}\n  (P : CategoryTheory.MorphismProperty (CategoryTheory.MorphismProperty.Localization W))\n  (hP‚ÇÅ :\n    ‚àÄ ‚¶ÉX : C‚¶Ñ ‚¶ÉY : C‚¶Ñ (f : X ‚ü∂ Y),\n      P (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.MorphismProperty.Q W)) f))\n  (hP‚ÇÇ :\n    ‚àÄ ‚¶ÉX : CategoryTheory.MorphismProperty.Localization W‚¶Ñ ‚¶ÉY : CategoryTheory.MorphismProperty.Localization W‚¶Ñ\n      (e : X ‚âÖ Y) (x : P (CategoryTheory.Iso.hom e)), P (CategoryTheory.Iso.inv e))\n  (hP‚ÇÉ : CategoryTheory.MorphismProperty.StableUnderComposition P), P = ‚ä§","name":"CategoryTheory.Localization.Construction.morphismProperty_is_top'","isProp":true,"docString":"A `MorphismProperty` in `W.Localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, if is stable under composition\nand if the property is stable by passing to inverses. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (hr : WellFounded r), WellFounded (Relation.CutExpand r)","name":"WellFounded.cutExpand","isProp":true,"docString":"`CutExpand r` is well-founded when `r` is. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] (t : Finset Œπ) (f : (a : Œπ) ‚Üí Set Œ±) (a : Œ±),\n  (a ‚àà Finset.sum t fun (i : Œπ) ‚Ü¶ f i : Prop) ‚Üî\n    (‚àÉ (g : (a : Œπ) ‚Üí Œ±), ‚àÉ (x : ‚àÄ {i : Œπ} (a : i ‚àà t), g i ‚àà f i), (Finset.sum t fun (i : Œπ) ‚Ü¶ g i) = a : Prop)","name":"Set.mem_finset_sum","isProp":true,"docString":"The n-ary version of `Set.mem_add`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (self : Continuous f) (s : Set Œ≤) (a : IsOpen s), IsOpen (f ‚Åª¬π' s)","name":"Continuous.isOpen_preimage","isProp":true,"docString":"The preimage of an open set under a continuous function is an open set. Use `IsOpen.preimage`\ninstead. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : OrderedAddCommGroup Œ≤] [inst_1 : Module ‚Ñù Œ≤] [inst_2 : OrderedSMul ‚Ñù Œ≤] {f : (a : ‚Ñù) ‚Üí Œ≤}\n  {a : ‚Ñù} {b : ‚Ñù} (a_lt_b : a < b) (h_local_min : IsLocalMinOn f (Set.Icc a b) a) (h_conv : ConvexOn ‚Ñù (Set.Icc a b) f),\n  IsMinOn f (Set.Icc a b) a","name":"IsMinOn.of_isLocalMinOn_of_convexOn_Icc","isProp":true,"docString":"Helper lemma for the more general case: `IsMinOn.of_isLocalMinOn_of_convexOn`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (f : (a : ‚Ñï) ‚Üí Œ±) (n : ‚Ñï),\n  dist (f 0) (f n) ‚â§ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ dist (f i) (f (i + 1))","name":"dist_le_range_sum_dist","isProp":true,"docString":"The triangle (polygon) inequality for sequences of points; `Finset.range` version. "},{"type":"‚àÄ {Œπ : Type u_1} {Œπ' : Type u_2} {Œ± : Type u_3} [inst : Finite Œπ] [inst : Preorder Œπ']\n  [inst_1 : IsDirected Œπ' (Function.swap fun (x : Œπ') (x_1 : Œπ') ‚Ü¶ x ‚â§ x_1)] [inst_2 : Nonempty Œπ']\n  {s : (a : Œπ) ‚Üí (a : Œπ') ‚Üí Set Œ±} (hs : ‚àÄ (i : Œπ), Antitone (s i)),\n  (Set.union·µ¢ fun (j : Œπ') ‚Ü¶ Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ s i j) = Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (j : Œπ') ‚Ü¶ s i j","name":"Set.union·µ¢_inter·µ¢_of_antitone","isProp":true,"docString":"A decreasing union distributes over finite intersection. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {u : (a : Œπ) ‚Üí Set X} {s : Set X}\n  (v : ShrinkingLemma.PartialRefinement u s) (hs : IsClosed s) (i : Œπ)\n  (hi : ¬¨(i ‚àà ShrinkingLemma.PartialRefinement.carrier v : Prop)), ‚àÉ (v' : ShrinkingLemma.PartialRefinement u s), v < v'","name":"ShrinkingLemma.PartialRefinement.exists_gt","isProp":true,"docString":"If `s` is a closed set, `v` is a partial refinement, and `i` is an index such that\n`i ‚àâ v.carrier`, then there exists a partial refinement that is strictly greater than `v`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.MonoidalCategory C] [self : CategoryTheory.MonoidalPreadditive C] {W : C} {X : C} {Y : C}\n  {Z : C} (f : W ‚ü∂ X), f ‚äó 0 = 0","name":"CategoryTheory.MonoidalPreadditive.tensor_zero","isProp":true,"docString":"tensoring on the right with a zero morphism gives zero "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (x : M), SemiconjBy 1 x x","name":"SemiconjBy.one_left","isProp":true,"docString":"One semiconjugates any element to itself. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] [inst_1 : PartialOrder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_5 : ContravariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} (hac : a ‚â§ c) (hbd : b ‚â§ d),\n  (a * b = c * d : Prop) ‚Üî ((a = c : Prop) ‚àß (b = d : Prop) : Prop)","name":"mul_eq_mul_iff_eq_and_eq","isProp":true,"docString":"**Alias** of `Left.mul_eq_mul_iff_eq_and_eq`."},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {s : Set Œ±} (a : Equiv.Perm.IsCycleOn f‚Åª¬π s), Equiv.Perm.IsCycleOn f s","name":"Equiv.Perm.IsCycleOn.of_inv","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.isCycleOn_inv`."},{"type":"‚àÄ {a : Prop} {c : Prop} {b : Prop} {d : Prop} (h‚ÇÅ : (a : Prop) ‚Üî (c : Prop)) (h‚ÇÇ : (b : Prop) ‚Üî (d : Prop)),\n  ((a : Prop) ‚àß (b : Prop) : Prop) ‚Üî ((c : Prop) ‚àß (d : Prop) : Prop)","name":"Iff.and","isProp":true,"docString":"**Alias** of `and_congr`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {y : Œ±}, EMetric.infEdist x {y} = edist x y","name":"EMetric.infEdist_singleton","isProp":true,"docString":"The edist to a singleton is the edistance to the single point of this singleton "},{"type":"‚àÄ {Œ± : Type u}, Vector.toList Vector.nil = []","name":"Vector.toList_nil","isProp":true,"docString":"A nil vector maps to a nil list. "},{"type":"‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : Semiring A]\n  [inst_3 : Algebra R A] [inst_4 : StarRing A] [inst_5 : StarModule R A] {s : Set A} {p : (a : A) ‚Üí Prop} {a : A}\n  (h : a ‚àà StarSubalgebra.adjoin R s) (Hs : ‚àÄ (x : A) (a : x ‚àà s), p x) (Halg : ‚àÄ (r : R), p (‚Üë(algebraMap R A) r))\n  (Hadd : ‚àÄ (x : A) (y : A) (a : p x) (a : p y), p (x + y)) (Hmul : ‚àÄ (x : A) (y : A) (a : p x) (a : p y), p (x * y))\n  (Hstar : ‚àÄ (x : A) (a : p x), p (star x)), p a","name":"StarSubalgebra.adjoin_induction","isProp":true,"docString":"If some predicate holds for all `x ‚àà (s : Set A)` and this predicate is closed under the\n`algebraMap`, addition, multiplication and star operations, then it holds for `a ‚àà adjoin R s`. "},{"type":"‚àÄ {G : Type u} [self : Semigroup G] (a : G) (b : G) (c : G), a * b * c = a * (b * c)","name":"Semigroup.mul_assoc","isProp":true,"docString":"Multiplication is associative "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} {r : ‚Ñö} (hq : q ‚â† 0) (hr : r ‚â† 0),\n  padicValRat p (q / r) = padicValRat p q - padicValRat p r","name":"padicValRat.div","isProp":true,"docString":"A rewrite lemma for `padicValRat p (q / r)` with conditions `q ‚â† 0`, `r ‚â† 0`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {e : LocalHomeomorph Œ± Œ≤}\n  {s : Set Œ±} {t : Set Œ≤} (a : LocalHomeomorph.IsImage e s t),\n  LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© ‚Üëe ‚Åª¬π' (LocalEquiv.target (LocalHomeomorph.toLocalEquiv e) ‚à© t) =\n    LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚à© s","name":"LocalHomeomorph.IsImage.preimage_eq'","isProp":true,"docString":"**Alias** of the forward direction of `LocalHomeomorph.IsImage.iff_preimage_eq'`."},{"type":"‚àÄ {Œ± : Type u} [self : StrictOrderedCommSemiring Œ±] (a : Œ±) (b : Œ±), a * b = b * a","name":"StrictOrderedCommSemiring.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Fintype Œ±] [inst_1 : Fintype Œ≤] (h : Fintype.card Œ≤ < Fintype.card Œ±),\n  IsEmpty (Œ± ‚Ü™ Œ≤)","name":"Function.Embedding.is_empty_of_card_lt","isProp":true,"docString":"If `‚ÄñŒ≤‚Äñ < ‚ÄñŒ±‚Äñ` there are no embeddings `Œ± ‚Ü™ Œ≤`.\nThis is a formulation of the pigeonhole principle.\n\nNote this cannot be an instance as it needs `h`. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Sort w} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {f : (a : Œπ) ‚Üí Œ±} (a : Directed r f),\n  DirectedOn r (Set.range f)","name":"Directed.directedOn_range","isProp":true,"docString":"**Alias** of the forward direction of `directedOn_range`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  [inst_2 : CategoryTheory.Limits.HasLimitsOfSize D] [inst_3 : CategoryTheory.CreatesLimitsOfSize F],\n  CategoryTheory.Limits.HasLimitsOfSize C","name":"CategoryTheory.has_limits_of_has_limits_creates_limits","isProp":true,"docString":"If `F` creates limits, and `D` has all limits, then `C` has all limits. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú},\n  (StrictConcaveOn ùïú s f : Prop) ‚Üî\n    ((Convex ùïú s : Prop) ‚àß\n        (‚àÄ ‚¶Éx : ùïú‚¶Ñ ‚¶Éy : ùïú‚¶Ñ ‚¶Éz : ùïú‚¶Ñ (a : x ‚àà s) (a : z ‚àà s) (a : x < y) (a : y < z),\n            (f z - f y) / (z - y) < (f y - f x) / (y - x) :\n          Prop) :\n      Prop)","name":"strictConcaveOn_iff_slope_strict_anti_adjacent","isProp":true,"docString":"A function `f : ùïú ‚Üí ùïú` is strictly concave iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. "},{"type":"‚àÄ {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasImages V]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject V] [inst_3 : CategoryTheory.Preadditive V]\n  [inst_4 : CategoryTheory.Limits.HasKernels V] [inst_5 : CategoryTheory.Limits.HasCokernels V] {A‚ÇÅ : V} {B‚ÇÅ : V}\n  {C‚ÇÅ : V} {A‚ÇÇ : V} {B‚ÇÇ : V} {C‚ÇÇ : V} (f‚ÇÅ : A‚ÇÅ ‚ü∂ B‚ÇÅ) (g‚ÇÅ : B‚ÇÅ ‚ü∂ C‚ÇÅ) (f‚ÇÇ : A‚ÇÇ ‚ü∂ B‚ÇÇ) (g‚ÇÇ : B‚ÇÇ ‚ü∂ C‚ÇÇ) (Œ± : A‚ÇÅ ‚âÖ A‚ÇÇ)\n  (Œ≤ : B‚ÇÅ ‚âÖ B‚ÇÇ) (Œ≥ : C‚ÇÅ ‚âÖ C‚ÇÇ) (hsq‚ÇÅ : CategoryTheory.Iso.hom Œ± ‚â´ f‚ÇÇ = f‚ÇÅ ‚â´ CategoryTheory.Iso.hom Œ≤)\n  (hsq‚ÇÇ : CategoryTheory.Iso.hom Œ≤ ‚â´ g‚ÇÇ = g‚ÇÅ ‚â´ CategoryTheory.Iso.hom Œ≥) (h : CategoryTheory.Exact f‚ÇÅ g‚ÇÅ),\n  CategoryTheory.Exact f‚ÇÇ g‚ÇÇ","name":"CategoryTheory.Preadditive.exact_of_iso_of_exact'","isProp":true,"docString":"A reformulation of `Preadditive.exact_of_iso_of_exact` that does not involve the arrow\ncategory. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±], Metric.diam ‚àÖ = 0","name":"Metric.diam_empty","isProp":true,"docString":"The empty set has zero diameter "},{"type":"‚àÄ {R : Type u_1} [inst : CommMonoidWithZero R] (n : R),\n  (IsPrimePow n : Prop) ‚Üî (‚àÉ (p : R), ‚àÉ (k : ‚Ñï), (Prime p : Prop) ‚àß (p ^ (k + 1) = n : Prop) : Prop)","name":"isPrimePow_iff_pow_succ","isProp":true,"docString":"An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a\nnatural `k` such that `n` can be written as `p^(k+1)`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {E : Set Œ±},\n  (0 < EMetric.infEdist x E : Prop) ‚Üî (¬¨(x ‚àà closure E : Prop) : Prop)","name":"EMetric.infEdist_pos_iff_not_mem_closure","isProp":true,"docString":"The infimum edistance of a point to a set is positive if and only if the point is not in the\nclosure of the set. "},{"type":"‚àÄ {A : Type u_1} [inst : AddMonoid A] {f : ‚Ñ§ ‚Üí+ A} {g : ‚Ñ§ ‚Üí+ A} (h1 : ‚Üëf 1 = ‚Üëg 1), f = g","name":"AddMonoidHom.ext_int","isProp":true,"docString":"Two additive monoid homomorphisms `f`, `g` from `‚Ñ§` to an additive monoid are equal\nif `f 1 = g 1`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {Z : C} {X : C} {Y : C} {P : C} {f : Z ‚ü∂ X} {g : Z ‚ü∂ Y} {inl : X ‚ü∂ P}\n  {inr : Y ‚ü∂ P} (w : CategoryTheory.CommSq f g inl inr)\n  (h : CategoryTheory.Limits.IsColimit (CategoryTheory.CommSq.cocone w)), CategoryTheory.IsPushout f g inl inr","name":"CategoryTheory.IsPushout.of_isColimit'","isProp":true,"docString":"A variant of `of_isColimit` that is more useful with `apply`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X], DenseRange Alexandroff.some","name":"Alexandroff.denseRange_coe","isProp":true,"docString":"If `X` is not a compact space, then the natural embedding `X ‚Üí Alexandroff X` has dense range.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : TopologicalSpace.SecondCountableTopology Œ±],\n  Set.Countable (setOf fun (x : Œ±) ‚Ü¶ nhdsWithin x (Set.Ioi x) = ‚ä•)","name":"countable_setOf_isolated_right","isProp":true,"docString":"The set of points which are isolated on the right is countable when the space is\nsecond-countable. "},{"type":"‚àÄ {I : Type u} {f : (a : I) ‚Üí Type v‚ÇÅ} [inst : DecidableEq I] [inst_1 : (i : I) ‚Üí Zero (f i)] {i : I} {i' : I}\n  (h : i ‚â† i') (x : f i), Pi.single i x i' = 0","name":"Pi.single_eq_of_ne'","isProp":true,"docString":"Abbreviation for `single_eq_of_ne h.symm`, for ease of use by `simp`."},{"type":"‚àÄ {M : Type u} [self : AddMonoid M] (n : ‚Ñï) (x : M), AddMonoid.nsmul (n + 1) x = x + AddMonoid.nsmul n x","name":"AddMonoid.nsmul_succ","isProp":true,"docString":"Multiplication by `(n + 1 : ‚Ñï)` behaves as expected. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] {I : Ideal R} {J : Ideal R} {x : R},\n  (‚Üë(Ideal.Quotient.mk I) x ‚àà Ideal.map (Ideal.Quotient.mk I) J : Prop) ‚Üî (x ‚àà J ‚äî I : Prop)","name":"Ideal.mem_quotient_iff_mem_sup","isProp":true,"docString":"See also `Ideal.mem_quotient_iff_mem` in case `I ‚â§ J`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {f : (a : Œ±) ‚Üí E}\n  {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : f =Œò[l] g'), f =Œò[l] fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ","name":"Asymptotics.IsTheta.norm_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isTheta_norm_right`."},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : OrderedCommSemiring R] {f : (a : Œπ) ‚Üí R} {g : (a : Œπ) ‚Üí R} {s : Finset Œπ}\n  (h0 : ‚àÄ (i : Œπ) (a : i ‚àà s), 0 ‚â§ f i) (h1 : ‚àÄ (i : Œπ) (a : i ‚àà s), f i ‚â§ g i),\n  (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) ‚â§ Finset.prod s fun (i : Œπ) ‚Ü¶ g i","name":"Finset.prod_le_prod","isProp":true,"docString":"If all `f i`, `i ‚àà s`, are nonnegative and each `f i` is less than or equal to `g i`, then the\nproduct of `f i` is less than or equal to the product of `g i`. See also `Finset.prod_le_prod'` for\nthe case of an ordered commutative multiplicative monoid. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p : P} (hp : p ‚àà s) (v : V),\n  (v ‚àà AffineSubspace.direction s : Prop) ‚Üî (‚àÉ (p2 : P), (p2 ‚àà s : Prop) ‚àß (v = p -·µ• p2 : Prop) : Prop)","name":"AffineSubspace.mem_direction_iff_eq_vsub_left","isProp":true,"docString":"Given a point in an affine subspace, a vector is in its direction if and only if it results from\nsubtracting that point on the left. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Mul Œ≤] [inst_1 : SMul Œ± Œ≤] [inst_2 : SMulCommClass Œ± Œ≤ Œ≤] (s : Œ±) (x : Œ≤)\n  (y : Œ≤), x * s ‚Ä¢ y = s ‚Ä¢ (x * y)","name":"mul_smul_comm","isProp":true,"docString":"Note that the `SMulCommClass Œ± Œ≤ Œ≤` typeclass argument is usually satisfied by `Algebra Œ± Œ≤`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} (h : Set.uIcc c d ‚äÜ Set.uIcc a b),\n  abs (d - c) ‚â§ abs (b - a)","name":"Set.abs_sub_le_of_uIcc_subset_uIcc","isProp":true,"docString":"If `[c, d]` is a subinterval of `[a, b]`, then the distance between `c` and `d` is less than or\nequal to that of `a` and `b` "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero M] [inst_1 : AddCommMonoid N] (f : Œ± ‚Üí‚ÇÄ M) (y : Œ±)\n  (g : (a : Œ±) ‚Üí (a : M) ‚Üí N) (hyf : y ‚àà Finsupp.support f),\n  g y (‚Üëf y) + Finsupp.sum (Finsupp.erase y f) g = Finsupp.sum f g","name":"Finsupp.add_sum_erase","isProp":true,"docString":"Taking a sum over over `f : Œ± ‚Üí‚ÇÄ M` is the same as adding the value on a\nsingle element `y ‚àà f.support` to the sum over `erase y f`. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSSubset Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hab : a = b) (hbc : b ‚äÇ c), a ‚äÇ c","name":"Eq.trans_ssubset","isProp":true,"docString":"**Alias** of `ssubset_of_eq_of_ssubset`."},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Type u_1} {M : Type u_3} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {I : Set Œπ} {t : (a : Œπ) ‚Üí Set Œ±}\n  (h : Set.PairwiseDisjoint I t) (hI : Set.Finite I) (ht : ‚àÄ (i : Œπ) (a : i ‚àà I), Set.Finite (t i)),\n  (finprod fun (a : Œ±) ‚Ü¶ finprod fun (h : a ‚àà Set.union·µ¢ fun (x : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà I) ‚Ü¶ t x) ‚Ü¶ f a) =\n    finprod fun (i : Œπ) ‚Ü¶ finprod fun (h : i ‚àà I) ‚Ü¶ finprod fun (j : Œ±) ‚Ü¶ finprod fun (h : j ‚àà t i) ‚Ü¶ f j","name":"finprod_mem_bunion·µ¢","isProp":true,"docString":"Given a family of sets `t : Œπ ‚Üí Set Œ±`, a finite set `I` in the index type such that all sets\n`t i`, `i ‚àà I`, are finite, if all `t i`, `i ‚àà I`, are pairwise disjoint, then the product of `f a`\nover `a ‚àà ‚ãÉ i ‚àà I, t i` is equal to the product over `i ‚àà I` of the products of `f a` over\n`a ‚àà t i`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {Œ∫ : (a : Œπ) ‚Üí Sort u_3} {s : Set Œ±} {t : (i : Œπ) ‚Üí (a : Œ∫ i) ‚Üí Set Œ±} (i : Œπ) (j : Œ∫ i)\n  (h : s ‚äÜ t i j), s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (j : Œ∫ i) ‚Ü¶ t i j","name":"Set.subset_union·µ¢‚ÇÇ_of_subset","isProp":true,"docString":"This rather trivial consequence of `subset_union·µ¢‚ÇÇ` is convenient with `apply`, and has `i` and\n`j` explicit for this purpose. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {S : Type u_3} [inst : Fintype Œπ] [inst_1 : CommRing R] [inst_2 : CommRing S]\n  [inst_3 : Algebra R S] {I : Ideal S} (b : Basis Œπ R { x : S // x ‚àà I }) {x : S},\n  (x ‚àà I : Prop) ‚Üî (‚àÉ (c : (a : Œπ) ‚Üí R), x = ‚Üë(Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ c i ‚Ä¢ ‚Üëb i) : Prop)","name":"Basis.mem_ideal_iff'","isProp":true,"docString":"If `I : Ideal S` has a finite basis over `R`,\n`x ‚àà I` iff it is a linear combination of basis vectors. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {t : Set (Set Œ±)}\n  (h : Set.PairwiseDisjoint t id) (ht‚ÇÄ : Set.Finite t) (ht‚ÇÅ : ‚àÄ (x : Set Œ±) (a : x ‚àà t), Set.Finite x),\n  (finprod fun (a : Œ±) ‚Ü¶ finprod fun (h : a ‚àà ‚ãÉ‚ÇÄ t) ‚Ü¶ f a) =\n    finprod fun (s : Set Œ±) ‚Ü¶ finprod fun (h : s ‚àà t) ‚Ü¶ finprod fun (a : Œ±) ‚Ü¶ finprod fun (h : a ‚àà s) ‚Ü¶ f a","name":"finprod_mem_union‚Çõ","isProp":true,"docString":"If `t` is a finite set of pairwise disjoint finite sets, then the product of `f a`\nover `a ‚àà ‚ãÉ‚ÇÄ t` is the product over `s ‚àà t` of the products of `f a` over `a ‚àà s`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F}\n  {l : Filter Œ±}, (f =O[l] g : Prop) ‚Üî (‚àÉ (c : ‚Ñù), Asymptotics.IsBigOWith c l f g : Prop)","name":"Asymptotics.isBigO_iff_isBigOWith","isProp":true,"docString":"Definition of `IsBigO` in terms of `IsBigOWith`. We record it in a lemma as `IsBigO` is\nirreducible. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {Œπ : Type u_1} (s : Finset Œπ) (p : (a : Œπ) ‚Üí Polynomial R) (x : R),\n  Polynomial.eval x (Finset.prod s fun (j : Œπ) ‚Ü¶ p j) = Finset.prod s fun (j : Œπ) ‚Ü¶ Polynomial.eval x (p j)","name":"Polynomial.eval_prod","isProp":true,"docString":"Polynomial evaluation commutes with `Finset.prod`\n"},{"type":"‚àÄ (ùïú : Type u_2) (ùïú' : Type u_1) [inst : NormedField ùïú] [inst_1 : SeminormedRing ùïú'] [inst_2 : NormedAlgebra ùïú ùïú']\n  [inst_3 : NormOneClass ùïú'], Isometry ‚Üë(algebraMap ùïú ùïú')","name":"algebraMap_isometry","isProp":true,"docString":"In a normed algebra, the inclusion of the base field in the extended field is an isometry. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 0) (hb : b < 0), a + b < 0","name":"add_neg","isProp":true,"docString":"**Alias** of `Left.add_neg`."},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module R E] [inst_4 : Module R F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : ContinuousAdd E] [inst_8 : ContinuousAdd F] [inst_9 : TopologicalSpace R] [inst_10 : ContinuousSMul R E]\n  [inst_11 : ContinuousSMul R F] {f : E ‚Üí‚Çó.[R] F} (hf : LinearPMap.IsClosable f),\n  LinearPMap.IsClosed (LinearPMap.closure f)","name":"LinearPMap.IsClosable.closure_isClosed","isProp":true,"docString":"If `f` is closable, then the closure is closed. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} (p : (a : Œπ) ‚Üí P) {s : Set Œπ} {i : Œπ} (hi : i ‚àà s),\n  vectorSpan k (p '' s) = Submodule.span k ((fun (x : P) (x_1 : P) ‚Ü¶ x -·µ• x_1) (p i) '' (p '' (s \\ {i})))","name":"vectorSpan_image_eq_span_vsub_set_left_ne","isProp":true,"docString":"The `vectorSpan` of the image of a function is the span of the pairwise subtractions with a\ngiven point on the left, excluding the subtraction of that point from itself. "},{"type":"‚àÄ {M : Type u_2} {Œ± : Type u_1} [inst : Monoid M] [inst_1 : MulAction M Œ±] [inst_2 : Mul Œ±] (r : M) (s : M) (x : Œ±)\n  (y : Œ±) [inst_3 : IsScalarTower M Œ± Œ±] [inst_4 : SMulCommClass M Œ± Œ±], r ‚Ä¢ x * s ‚Ä¢ y = (r * s) ‚Ä¢ (x * y)","name":"smul_mul_smul","isProp":true,"docString":"Note that the `IsScalarTower M Œ± Œ±` and `SMulCommClass M Œ± Œ±` typeclass arguments are\nusually satisfied by `Algebra M Œ±`. "},{"type":"‚àÄ (n : ‚Ñï) (p : Fin (n + 1)),\n  Finset.univ =\n    Finset.cons p (Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ)\n      ((of_eq_true\n            ((Eq.trans\n                  ((congrArg Not\n                        ((Eq.trans\n                              ((Eq.trans\n                                    ((Eq.trans\n                                          ((Eq.trans\n                                                ((Mathlib.Data.Finset.Image._auxLemma.2=:(p ‚àà\n                                                          Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p))\n                                                            Finset.univ :\n                                                        Prop) =\n                                                      (‚àÉ (a : Fin n),\n                                                          (a ‚àà Finset.univ : Prop) ‚àß\n                                                            (‚Üë(RelEmbedding.toEmbedding (Fin.succAbove p)) a = p :\n                                                              Prop) :\n                                                        Prop))=:(p ‚àà\n                                                        Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p))\n                                                          Finset.univ :\n                                                      Prop) =\n                                                    (‚àÉ (a : Fin n),\n                                                        (a ‚àà Finset.univ : Prop) ‚àß\n                                                          (‚Üë(RelEmbedding.toEmbedding (Fin.succAbove p)) a = p : Prop) :\n                                                      Prop))\n                                                ((congrArg Exists\n                                                      ((funext\n                                                            (fun (a : Fin n) ‚Ü¶\n                                                              (_ :\n                                                                ((a ‚àà Finset.univ : Prop) ‚àß\n                                                                      (‚Üë(Fin.succAbove p) a = p : Prop) :\n                                                                    Prop) =\n                                                                  (‚Üë(Fin.succAbove p) a = p :\n                                                                    Prop))=:‚àÄ (a : Fin n),\n                                                                ((a ‚àà Finset.univ : Prop) ‚àß\n                                                                      (‚Üë(Fin.succAbove p) a = p : Prop) :\n                                                                    Prop) =\n                                                                  (‚Üë(Fin.succAbove p) a = p :\n                                                                    Prop))=:(fun (x : Fin n) ‚Ü¶\n                                                              (x ‚àà Finset.univ : Prop) ‚àß\n                                                                (‚Üë(Fin.succAbove p) x = p : Prop)) =\n                                                            fun (x : Fin n) ‚Ü¶\n                                                            ‚Üë(Fin.succAbove p) x =\n                                                              p)=:(fun (x : Fin n) ‚Ü¶\n                                                            (x ‚àà Finset.univ : Prop) ‚àß\n                                                              (‚Üë(Fin.succAbove p) x = p : Prop)) =\n                                                          fun (x : Fin n) ‚Ü¶\n                                                          ‚Üë(Fin.succAbove p) x =\n                                                            p)=:(‚àÉ (x : Fin n),\n                                                          (x ‚àà Finset.univ : Prop) ‚àß (‚Üë(Fin.succAbove p) x = p : Prop) :\n                                                        Prop) =\n                                                      (‚àÉ (x : Fin n), ‚Üë(Fin.succAbove p) x = p :\n                                                        Prop))=:(‚àÉ (x : Fin n),\n                                                        (x ‚àà Finset.univ : Prop) ‚àß (‚Üë(Fin.succAbove p) x = p : Prop) :\n                                                      Prop) =\n                                                    (‚àÉ (x : Fin n), ‚Üë(Fin.succAbove p) x = p :\n                                                      Prop))=:(p ‚àà\n                                                    Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p))\n                                                      Finset.univ :\n                                                  Prop) =\n                                                (‚àÉ (x : Fin n), ‚Üë(Fin.succAbove p) x = p :\n                                                  Prop))=:(p ‚àà\n                                                  Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ :\n                                                Prop) =\n                                              (‚àÉ (x : Fin n), ‚Üë(Fin.succAbove p) x = p : Prop))\n                                          ((Mathlib.Data.Fin.Basic._auxLemma.55=:(‚àÉ (z : Fin n),\n                                                    ‚Üë(Fin.succAbove p) z = p :\n                                                  Prop) =\n                                                (p ‚â† p :\n                                                  Prop))=:(‚àÉ (z : Fin n), ‚Üë(Fin.succAbove p) z = p : Prop) =\n                                              (p ‚â† p :\n                                                Prop))=:(p ‚àà\n                                              Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ :\n                                            Prop) =\n                                          (p ‚â† p :\n                                            Prop))=:(p ‚àà\n                                            Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ :\n                                          Prop) =\n                                        (p ‚â† p : Prop))\n                                    ((congrArg Not\n                                          ((eq_self\n                                                p=:(p = p : Prop) =\n                                                (True :\n                                                  Prop))=:(p = p : Prop) =\n                                              (True :\n                                                Prop))=:(¬¨(p = p : Prop) : Prop) =\n                                          (¬¨(True : Prop) :\n                                            Prop))=:(¬¨(p = p : Prop) : Prop) =\n                                        (¬¨(True : Prop) :\n                                          Prop))=:(p ‚àà\n                                        Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ :\n                                      Prop) =\n                                    (¬¨(True : Prop) :\n                                      Prop))=:(p ‚àà Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ :\n                                    Prop) =\n                                  (¬¨(True : Prop) : Prop))\n                              (Std.Logic._auxLemma.3=:(¬¨(True : Prop) : Prop) =\n                                  (False :\n                                    Prop))=:(p ‚àà Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ :\n                                Prop) =\n                              (False :\n                                Prop))=:(p ‚àà Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ :\n                              Prop) =\n                            (False :\n                              Prop))=:(¬¨(p ‚àà Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ :\n                              Prop) :\n                          Prop) =\n                        (¬¨(False : Prop) :\n                          Prop))=:(¬¨(p ‚àà Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ : Prop) :\n                        Prop) =\n                      (¬¨(False : Prop) : Prop))\n                  (not_false_eq_true=:(¬¨(False : Prop) : Prop) =\n                      (True :\n                        Prop))=:(¬¨(p ‚àà Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ : Prop) :\n                    Prop) =\n                  (True :\n                    Prop))=:(¬¨(p ‚àà Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ : Prop) : Prop) =\n                (True :\n                  Prop))=:¬¨(p ‚àà Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ :\n              Prop))=:¬¨(p ‚àà Finset.map (RelEmbedding.toEmbedding (Fin.succAbove p)) Finset.univ : Prop))","name":"Fin.univ_succAbove","isProp":true,"docString":"Embed `Fin n` into `Fin (n + 1)` by inserting\naround a specified pivot `p : Fin (n + 1)` into the `univ` "},{"type":"‚àÄ {Œ± : Type u_1} [self : NonAssocRing Œ±] (a : Œ±), 1 * a = a","name":"NonAssocRing.one_mul","isProp":true,"docString":"One is a left neutral element for multiplication "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K : Set G} {U : Set G}\n  (hK : IsCompact K) (hU : IsOpen U) (hKU : K ‚äÜ U), ‚àÉ (V : Set G), (V ‚àà nhds 0 : Prop) ‚àß (K + V ‚äÜ U : Prop)","name":"compact_open_separated_add_right","isProp":true,"docString":"Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of\n`0` such that `K + V ‚äÜ U`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a ‚â§ 0) (hb : b ‚â§ 0), a + b ‚â§ 0","name":"add_nonpos","isProp":true,"docString":"**Alias** of `Left.add_nonpos`."},{"type":"‚àÄ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : (a : R) ‚Üí S}\n  [self : IsAbsoluteValue f] (x : R) (y : R), f (x * y) = f x * f y","name":"IsAbsoluteValue.abv_mul'","isProp":true,"docString":"The absolute value is multiplicative "},{"type":"‚àÄ (G : Type u) [inst : AddRightCancelSemigroup G], IsRightCancelAdd G","name":"AddRightCancelSemigroup.toIsRightCancelAdd","isProp":true,"docString":"Any `AddRightCancelSemigroup` satisfies\n`IsRightCancelAdd`."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] [inst_1 : CommRing R] [inst_2 : Nontrivial R],\n  (Algebra.FiniteType R (AddMonoidAlgebra R M) : Prop) ‚Üî (AddMonoid.Fg M : Prop)","name":"AddMonoidAlgebra.finiteType_iff_fg","isProp":true,"docString":"An additive monoid `M` is finitely generated if and only if `AddMonoidAlgebra R M` is of\nfinite type. "},{"type":"‚àÄ (n : ‚Ñï), (3 ‚à£ n : Prop) ‚Üî (3 ‚à£ List.sum (Nat.digits 10 n) : Prop)","name":"Nat.three_dvd_iff","isProp":true,"docString":"**Divisibility by 3 Rule** "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedAddMonoid Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"CanonicallyLinearOrderedAddMonoid.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M ‚Üí‚Çô* N) {x : M} {y : M} (h : x = y), ‚Üëf x = ‚Üëf y","name":"MulHom.congr_arg","isProp":true,"docString":"Deprecated: use `FunLike.congr_arg` instead. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : CompleteLattice Œ±]\n  [inst_1 : CompleteLattice Œ≤] [self : FrameHomClass F Œ± Œ≤] (f : F) (s : Set Œ±), ‚Üëf (sup‚Çõ s) = sup‚Çõ (‚Üëf '' s)","name":"FrameHomClass.map_sup‚Çõ","isProp":true,"docString":"The proposition that members of `FrameHomClass` commute with arbitrary suprema/joins. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {t : Finset Œ±} (h : s ‚äÜ t),\n  Finset.card (Finset.Ico s t) = 2 ^ (Finset.card t - Finset.card s) - 1","name":"Finset.card_Ico_finset","isProp":true,"docString":"Cardinality of an `Ico` of finsets. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (Alexandroff X)","name":"Alexandroff.instCompactSpaceAlexandroffInstTopologicalSpaceAlexandroff","isProp":true,"docString":"For any topological space `X`, its one point compactification is a compact space. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] {a : Œ±} {b : Œ±} (a_1 : a * b = 0),\n  (a = 0 : Prop) ‚à® (b = 0 : Prop)","name":"CanonicallyOrderedCommSemiring.eq_zero_or_eq_zero_of_mul_eq_zero","isProp":true,"docString":"No zero divisors. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : (a : Œ±) ‚Üí Type u_2} {P : (x : Œ±) ‚Üí (a : Œ≤ x) ‚Üí Prop} [inst : (a : Œ±) ‚Üí Encodable (Œ≤ a)]\n  [inst : (x : Œ±) ‚Üí (y : Œ≤ x) ‚Üí Decidable (P x y : Prop)],\n  (‚àÄ (x : Œ±), ‚àÉ (y : Œ≤ x), P x y : Prop) ‚Üî (‚àÉ (f : (a : Œ±) ‚Üí Œ≤ a), ‚àÄ (x : Œ±), P x (f x) : Prop)","name":"Encodable.skolem","isProp":true,"docString":"A constructive version of `Classical.skolem` for `Encodable` types. "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} (self : SimpleGraph.Partition G),\n  Setoid.IsPartition (SimpleGraph.Partition.parts self)","name":"SimpleGraph.Partition.isPartition","isProp":true,"docString":"`isPartition`: a proof that `parts` is a proper partition of `V`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Add Œ±] [inst_1 : LE Œ±] [self : ExistsAddOfLE Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b),\n  ‚àÉ (c : Œ±), b = a + c","name":"ExistsAddOfLE.exists_add_of_le","isProp":true,"docString":"For `a ‚â§ b`, there is a `c` so `b = a + c`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : Fintype Œ±] [inst_1 : Fintype Œ≤] [inst_2 : AddCommMonoid M]\n  (e : Œ± ‚âÉ Œ≤) (f : (a : Œ±) ‚Üí M) (g : (a : Œ≤) ‚Üí M) (h : ‚àÄ (x : Œ±), f x = g (‚Üëe x)),\n  (Finset.sum Finset.univ fun (x : Œ±) ‚Ü¶ f x) = Finset.sum Finset.univ fun (x : Œ≤) ‚Ü¶ g x","name":"Fintype.sum_equiv","isProp":true,"docString":"`Fintype.sum_equiv` is a specialization of `Finset.sum_bij` that\nautomatically fills in most arguments.\n\nSee `Equiv.sum_comp` for a version without `h`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ‚â† 0","name":"Subgroup.FiniteIndex.finiteIndex","isProp":true,"docString":"The subgroup has finite index "},{"type":"‚àÄ {R : Type u_1} [inst : AddSemigroup R] {a : R} {b : R} (rra : IsAddRightRegular a) (rrb : IsAddRightRegular b),\n  IsAddRightRegular (a + b)","name":"IsAddRightRegular.add","isProp":true,"docString":"In an additive semigroup, the sum of add-right-regular elements is\nadd-right-regular."},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommSemiring Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"LinearOrderedCommSemiring.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ {R : Type u} [self : AddMonoidWithOne R] (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1","name":"AddMonoidWithOne.natCast_succ","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` is a homomorphism. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] (a : E) (b : E), dist a b = ‚Äñb - a‚Äñ","name":"dist_eq_norm'","isProp":true,"docString":"**Alias** of `dist_eq_norm_sub'`."},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±]\n  (H : FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ), FreeGroup.mk L‚ÇÅ = FreeGroup.mk L‚ÇÇ","name":"FreeGroup.reduce.exact","isProp":true,"docString":"If two words have a common maximal reduction, then they correspond to the same element in the\nfree group. "},{"type":"‚àÄ {Œ± : Type u} (s : Finset Œ±), Set.Finite ‚Üës","name":"Finset.finite_toSet","isProp":true,"docString":"Gives a `Set.Finite` for the `Finset` coerced to a `Set`.\nThis is a wrapper around `Set.toFinite`. "},{"type":"‚àÄ {Œ± : Type u_1} (r : Setoid Œ±), Setoid.ker Quotient.mk'' = r","name":"Setoid.ker_mk_eq","isProp":true,"docString":"The kernel of the quotient map induced by an equivalence relation r equals r. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {J : CategoryTheory.GrothendieckTopology C} {D : Type w}\n  [inst_1 : CategoryTheory.Category D] [inst_2 : CategoryTheory.ConcreteCategory D]\n  [inst_3 : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)]\n  [inst_4 : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ D]\n  [inst_5 :\n    ‚àÄ (P : C·µí·µñ ‚•§ D) (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X),\n      CategoryTheory.Limits.HasMultiequalizer (CategoryTheory.GrothendieckTopology.Cover.index S P)]\n  [inst_6 :\n    (X : C) ‚Üí\n      CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.GrothendieckTopology.Cover J X)·µí·µñ\n        (CategoryTheory.forget D)]\n  [inst_7 : CategoryTheory.ReflectsIsomorphisms (CategoryTheory.forget D)] (P : C·µí·µñ ‚•§ D)\n  (hsep :\n    ‚àÄ (X : C) (S : CategoryTheory.GrothendieckTopology.Cover J X)\n      (x :\n        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.ConcreteCategory.Forget)\n          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor P) (Opposite.op X)))\n      (y :\n        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.ConcreteCategory.Forget)\n          (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor P) (Opposite.op X)))\n      (a :\n        ‚àÄ (I : CategoryTheory.GrothendieckTopology.Cover.Arrow S),\n          Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget D))\n              (Prefunctor.map (CategoryTheory.Functor.toPrefunctor P)\n                (Quiver.Hom.op (CategoryTheory.GrothendieckTopology.Cover.Arrow.f I)))\n              x =\n            Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget D))\n              (Prefunctor.map (CategoryTheory.Functor.toPrefunctor P)\n                (Quiver.Hom.op (CategoryTheory.GrothendieckTopology.Cover.Arrow.f I)))\n              y),\n      x = y),\n  CategoryTheory.Presheaf.IsSheaf J (CategoryTheory.GrothendieckTopology.plusObj J P)","name":"CategoryTheory.GrothendieckTopology.Plus.isSheaf_of_sep","isProp":true,"docString":"If `P` is separated, then `P‚Å∫` is a sheaf. "},{"type":"‚àÄ {n : Type v} {Œ± : Type w} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  {Œ≤ : Type u_1} (s : Finset Œ≤) (f : (a : n) ‚Üí (a : Œ≤) ‚Üí Œ±) (i : n),\n  (Finset.sum s fun (x : Œ≤) ‚Ü¶ ‚Üë(Matrix.cramer A) (fun (j : n) ‚Ü¶ f j x) i) =\n    ‚Üë(Matrix.cramer A) (fun (j : n) ‚Ü¶ Finset.sum s fun (x : Œ≤) ‚Ü¶ f j x) i","name":"Matrix.sum_cramer_apply","isProp":true,"docString":"Use linearity of `cramer` and vector evaluation to take `cramer A _ i` out of a summation. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤}\n  {f : (a : Œ±) ‚Üí Œ≤} {p : Filter Œπ} {p' : Filter Œ±} (h : TendstoUniformlyOnFilter F f p p') (g : (a : Œ≥) ‚Üí Œ±),\n  TendstoUniformlyOnFilter (fun (n : Œπ) ‚Ü¶ F n ‚àò g) (f ‚àò g) p (Filter.comap g p')","name":"TendstoUniformlyOnFilter.comp","isProp":true,"docString":"Composing on the right by a function preserves uniform convergence on a filter "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedCommSemiring Œ±] (a : Œ±), 1 * a = a","name":"CanonicallyOrderedCommSemiring.one_mul","isProp":true,"docString":"One is a left neutral element for multiplication "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : C ‚•§ D} (Œ± : F ‚ü∂ G) [inst_2 : ‚àÄ (X : C), CategoryTheory.Mono (Œ±.app X)], CategoryTheory.Mono Œ±","name":"CategoryTheory.NatTrans.mono_of_mono_app","isProp":true,"docString":"A natural transformation is a monomorphism if each component is. "},{"type":"‚àÄ {Œπ : Type u_1} {A : (a : Œπ) ‚Üí Type u_2} {M : (a : Œπ) ‚Üí Type u_3} [inst : AddMonoid Œπ]\n  [inst_1 : GradedMonoid.GMonoid A] [self : GradedMonoid.GMulAction A M] (b : GradedMonoid M), 1 ‚Ä¢ b = b","name":"GradedMonoid.GMulAction.one_smul","isProp":true,"docString":"One is the neutral element for `‚Ä¢` "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} [inst : Norm F] {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù} (a : u =O[l] g),\n  (fun (x : Œ±) ‚Ü¶ abs (u x)) =O[l] g","name":"Asymptotics.IsBigO.abs_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigO_abs_left`."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (x : Œ± (Fin.last n)) (p : (i : Fin n) ‚Üí Œ± (‚ÜëFin.castSucc i))\n  (z : Œ± (Fin.last n)), Function.update (Fin.snoc p x) (Fin.last n) z = Fin.snoc p z","name":"Fin.update_snoc_last","isProp":true,"docString":"Adding an element at the beginning of a tuple and then updating it amounts to adding it\ndirectly. "},{"type":"‚àÄ (Œ± : Type u) [inst : Finite Œ±] (Œ∫ : Type v) [inst : Finite Œ∫],\n  ‚àÉ (Œπ : Type),\n    ‚àÉ (x : Fintype Œπ), ‚àÄ (C : (a : (a : Œπ) ‚Üí Œ±) ‚Üí Œ∫), ‚àÉ (l : Combinatorics.Line Œ± Œπ), Combinatorics.Line.IsMono C l","name":"Combinatorics.Line.exists_mono_in_high_dimension","isProp":true,"docString":"The Hales-Jewett theorem: for any finite types `Œ±` and `Œ∫`, there exists a finite type `Œπ` such\nthat whenever the hypercube `Œπ ‚Üí Œ±` is `Œ∫`-colored, there is a monochromatic combinatorial line. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommMonoid Œ±] (a : Œ±) (b : Œ±) (u : Œ±) (hu : IsUnit u), (u * a ‚à£ b : Prop) ‚Üî (a ‚à£ b : Prop)","name":"IsUnit.mul_left_dvd","isProp":true,"docString":"In a commutative monoid, an element `a` divides an element `b` iff all\nleft associates of `a` divide `b`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} (P : C·µí·µñ ‚•§ Type w) {S : CategoryTheory.Sieve X}\n  {R : CategoryTheory.Presieve X} (h : CategoryTheory.Sieve.arrows S ‚â§ R)\n  (trans :\n    ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X),\n      CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.pullback f S))),\n  CategoryTheory.Presieve.IsSheafFor P R","name":"CategoryTheory.Presieve.isSheafFor_subsieve","isProp":true,"docString":"If `P` is a sheaf for every pullback of the sieve `S`, then `P` is a sheaf for any presieve which\ncontains `S`.\nThis is closely related to [Elephant] C2.1.6.\n"},{"type":"‚àÄ {R : Type u‚ÇÅ} [inst : NonUnitalNonAssocRing R], SMulCommClass ‚Ñ§ R R","name":"NonUnitalNonAssocRing.int_smulCommClass","isProp":true,"docString":"Note that `AddCommGroup.int_smulCommClass` requires stronger assumptions on `R`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] (x : M), IsAddSubmonoid (multiples x)","name":"multiples.isAddSubmonoid","isProp":true,"docString":"The set of natural number multiples of an element of an `AddMonoid` `M` is\nan `AddSubmonoid` of `M`."},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : OrderedCommSemiring R] {f : (a : Œπ) ‚Üí R} {s : Finset Œπ}\n  (h0 : ‚àÄ (i : Œπ) (a : i ‚àà s), 0 ‚â§ f i) (h1 : ‚àÄ (i : Œπ) (a : i ‚àà s), f i ‚â§ 1), (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) ‚â§ 1","name":"Finset.prod_le_one","isProp":true,"docString":"If each `f i`, `i ‚àà s` belongs to `[0, 1]`, then their product is less than or equal to one.\nSee also `finset.prod_le_one'` for the case of an ordered commutative multiplicative monoid. "},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±] (a : Œ±) (b : Œ±),\n  ((max a b = a : Prop) ‚àß (b ‚â§ a : Prop) : Prop) ‚à® ((max a b = b : Prop) ‚àß (a < b : Prop) : Prop)","name":"max_cases","isProp":true,"docString":"For elements `a` and `b` of a linear order, either `max a b = a` and `b ‚â§ a`,\nor `max a b = b` and `a < b`.\nUse cases on this lemma to automate linarith in inequalities "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (self : AddCon M) {w : M} {x : M} {y : M} {z : M} (a : Setoid.r w x) (a : Setoid.r y z),\n  Setoid.r (w + y) (x + z)","name":"AddCon.add'","isProp":true,"docString":"Additive congruence relations are closed under addition "},{"type":"‚àÄ {T : Type u‚ÇÅ} [inst : CategoryTheory.Category T] {X : T} {f : CategoryTheory.Under X} {g : CategoryTheory.Under X}\n  (k : f ‚ü∂ g) [hk : CategoryTheory.Mono (CategoryTheory.CommaMorphism.right k)], CategoryTheory.Mono k","name":"CategoryTheory.Under.mono_of_mono_right","isProp":true,"docString":"If `k.right` is a monomorphism, then `k` is a monomorphism. In other words, `Under.forget X`\nreflects epimorphisms.\nThe converse does not hold without additional assumptions on the underlying category, see\n`CategoryTheory.Under.mono_right_of_mono`.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {T : CategoryTheory.Monad C} {J : Type u}\n  [inst_1 : CategoryTheory.Category J] {D : J ‚•§ CategoryTheory.Monad.Algebra T}\n  (c : CategoryTheory.Limits.Cocone (D ‚ãô CategoryTheory.Monad.forget T)) (t : CategoryTheory.Limits.IsColimit c)\n  [inst_2 :\n    CategoryTheory.Limits.PreservesColimit (D ‚ãô CategoryTheory.Monad.forget T) (CategoryTheory.Monad.toFunctor T)]\n  (j : J),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Monad.toFunctor T))\n        ((CategoryTheory.Limits.Cocone.Œπ c).app j) ‚â´\n      CategoryTheory.Monad.ForgetCreatesColimits.lambda c t =\n    CategoryTheory.Monad.Algebra.a (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor D) j) ‚â´\n      (CategoryTheory.Limits.Cocone.Œπ c).app j","name":"CategoryTheory.Monad.ForgetCreatesColimits.commuting","isProp":true,"docString":"(Impl) The key property defining the map `Œª : TL ‚ü∂ L`. "},{"type":"‚àÄ {k : Type u_4} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] {s‚ÇÇ : Finset Œπ} (h : s‚ÇÇ ‚äÜ s)\n  (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.affineCombination k (s \\ s‚ÇÇ) p) w -·µ• ‚Üë(Finset.affineCombination k s‚ÇÇ p) (-w) = ‚Üë(Finset.weightedVSub s p) w","name":"Finset.affineCombination_sdiff_sub","isProp":true,"docString":"A weighted sum may be split into a subtraction of affine combinations over two subsets. "},{"type":"‚àÄ {c : (a : Type u) ‚Üí Type u} {hom : ‚¶ÉŒ± : Type u‚¶Ñ ‚Üí ‚¶ÉŒ≤ : Type u‚¶Ñ ‚Üí (x : c Œ±) ‚Üí (x : c Œ≤) ‚Üí Type u}\n  (self : CategoryTheory.BundledHom hom) {Œ± : Type u} {Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤),\n  Function.Injective (CategoryTheory.BundledHom.toFun self IŒ± IŒ≤)","name":"CategoryTheory.BundledHom.hom_ext","isProp":true,"docString":"a bundled morphism is determined by the underlying map "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {X : C}\n  (h :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda) X ‚ãô CategoryTheory.uliftFunctor ‚âÖ\n      CategoryTheory.Functor.cones F)\n  (s : CategoryTheory.Limits.Cone F),\n  CategoryTheory.Limits.Cone.extend (CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h)\n      (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h s) =\n    s","name":"CategoryTheory.Limits.IsLimit.OfNatIso.cone_fac","isProp":true,"docString":"If `F.cones` is represented by `X`, any cone is the extension of the limit cone by the\ncorresponding morphism. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s : AffineSubspace k P} (h : Set.Nonempty ‚Üës),\n  (AffineSubspace.direction s = ‚ä§ : Prop) ‚Üî (s = ‚ä§ : Prop)","name":"AffineSubspace.direction_eq_top_iff_of_nonempty","isProp":true,"docString":"A nonempty affine subspace is `‚ä§` if and only if its direction is `‚ä§`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : AffineSubspace k P), AffineSubspace.direction s = vectorSpan k ‚Üës","name":"AffineSubspace.direction_eq_vectorSpan","isProp":true,"docString":"The direction equals the `vectorSpan`. "},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [inst : Semiring k] (f : AddMonoidAlgebra k G),\n  f ‚àà Submodule.span k (AddMonoidAlgebra.of' k G '' ‚Üë(Finsupp.support f))","name":"AddMonoidAlgebra.mem_span_support'","isProp":true,"docString":"An element of `AddMonoidAlgebra k G` is in the subalgebra generated by its support, using\nunbundled inclusion. "},{"type":"‚àÄ {f‚ÇÅ : CircleDeg1Lift} {f‚ÇÇ : CircleDeg1Lift} (h‚ÇÅ : IsUnit f‚ÇÅ) (h‚ÇÇ : IsUnit f‚ÇÇ)\n  (h : CircleDeg1Lift.translationNumber f‚ÇÅ = CircleDeg1Lift.translationNumber f‚ÇÇ),\n  ‚àÉ (F : CircleDeg1Lift), Function.Semiconj ‚ÜëF ‚Üëf‚ÇÅ ‚Üëf‚ÇÇ","name":"CircleDeg1Lift.semiconj_of_isUnit_of_translationNumber_eq","isProp":true,"docString":"If two lifts of circle homeomorphisms have the same translation number, then they are\nsemiconjugate by a `CircleDeg1Lift`. This version uses assumptions `IsUnit f‚ÇÅ` and `IsUnit f‚ÇÇ`\nto assume that `f‚ÇÅ` and `f‚ÇÇ` are homeomorphisms. "},{"type":"‚àÄ {b : ‚Ñï} {l : List ‚Ñï} (hl : ‚àÄ (x : ‚Ñï) (a : x ‚àà l), x < b + 2), Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l","name":"Nat.ofDigits_lt_base_pow_length'","isProp":true,"docString":"an n-digit number in base b + 2 is less than (b + 2)^n "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_2} (e : LocalEquiv Œ± Œ≤) {e' : LocalEquiv Œ± Œ≥} {x : Œ±}\n  (he : x ‚àà LocalEquiv.source e) (he' : x ‚àà LocalEquiv.source e'),\n  LocalEquiv.toFun e x ‚àà LocalEquiv.source (LocalEquiv.trans (LocalEquiv.symm e) e')","name":"LocalEquiv.mem_symm_trans_source","isProp":true,"docString":"A lemma commonly useful when `e` and `e'` are charts of a manifold. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Unique Œ±] {s : Finset Œ±} (a : Finset.Nonempty s), s = {default}","name":"Finset.Nonempty.eq_singleton_default","isProp":true,"docString":"**Alias** of the forward direction of `Finset.nonempty_iff_eq_singleton_default`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : OrderedRing ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : AddCommGroup F] [inst_3 : Module ùïú E] [inst_4 : Module ùïú F] {x : E} (f : E ‚Üí·µÉ[ùïú] F) {s : Set F}\n  (hs : StarConvex ùïú (‚Üëf x) s), StarConvex ùïú x (‚Üëf ‚Åª¬π' s)","name":"StarConvex.affine_preimage","isProp":true,"docString":"The preimage of a star-convex set under an affine map is star-convex. "},{"type":"‚àÄ {n : ‚Ñï} {i : Fin (n + 2)} {j : Fin (n + 2)} (H : i ‚â§ j),\n  SimplexCategory.Œ¥ i ‚â´ SimplexCategory.Œ¥ (Fin.succ j) = SimplexCategory.Œ¥ j ‚â´ SimplexCategory.Œ¥ (‚ÜëFin.castSucc i)","name":"SimplexCategory.Œ¥_comp_Œ¥","isProp":true,"docString":"The generic case of the first simplicial identity "},{"type":"‚àÄ {R : Type u_1} [inst : Rack R] (x : R) (y : R),\n  Rack.act' (Shelf.act x y) = Rack.act' x * Rack.act' y * (Rack.act' x)‚Åª¬π","name":"Rack.ad_conj","isProp":true,"docString":"The *adjoint action* of a rack on itself is `op'`, and the adjoint\naction of `x ‚óÉ y` is the conjugate of the action of `y` by the action\nof `x`. It is another way to understand the self-distributivity axiom.\n\nThis is used in the natural rack homomorphism `toConj` from `R` to\n`Conj (R ‚âÉ R)` defined by `op'`.\n"},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [self : IsNoetherian R M] (s : Submodule R M), Submodule.Fg s","name":"IsNoetherian.noetherian","isProp":true,"docString":"`IsNoetherian R M` is the proposition that `M` is a Noetherian `R`-module,\nimplemented as the predicate that all `R`-submodules of `M` are finitely generated.\n"},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {f : M ‚Üí+ N} {g : M ‚Üí+ N} {s : Set M}\n  (h : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(AddSubmonoid.closure s)","name":"AddMonoidHom.eqOn_closureM","isProp":true,"docString":"If two monoid homomorphisms are equal on a set, then they are equal on its submonoid\nclosure."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommSemigroup Œ±] {a : Œ±} {b : Œ±} (h : a ‚à£ b) (c : Œ±), a ‚à£ c * b","name":"Dvd.dvd.mul_left","isProp":true,"docString":"**Alias** of `dvd_mul_of_dvd_right`."},{"type":"‚àÄ {G : Type u} {x : G} {n : ‚Ñï} [inst : Monoid G] (hn : 0 < n) (hx : x ^ n = 1)\n  (hd : ‚àÄ (p : ‚Ñï) (a : Nat.Prime p) (a : p ‚à£ n), x ^ (n / p) ‚â† 1), orderOf x = n","name":"orderOf_eq_of_pow_and_pow_div_prime","isProp":true,"docString":"If `x^n = 1`, but `x^(n/p) ‚â† 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. "},{"type":"‚àÄ {a : ‚Ñ§} {p : ‚Ñï} [pp : Fact (Nat.Prime p : Prop)], (‚Üëa = 0 : Prop) ‚Üî (Int.gcd a ‚Üëp ‚â† 1 : Prop)","name":"ZMod.eq_zero_iff_gcd_ne_one","isProp":true,"docString":"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p ‚â† 1`. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedRing Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"LinearOrderedRing.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {B : Finset (Finset Œ±)} {n : ‚Ñï} [inst_1 : Fintype Œ±]\n  (h : ‚àÄ (a : Œ±), Finset.card (Finset.filter ((fun (x : Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚àà x_1) a) B) = n),\n  (Finset.sum B fun (s : Finset Œ±) ‚Ü¶ Finset.card s) = Fintype.card Œ± * n","name":"Finset.sum_card","isProp":true,"docString":"If every element belongs to exactly `n` Finsets, then the sum of their sizes is `n` times how\nmany they are. "},{"type":"‚àÄ (Œ± : Type u) [inst : Preorder Œ±] [inst_1 : Nonempty Œ±] [inst_2 : NoMinOrder Œ±] [inst_3 : NoMaxOrder Œ±],\n  ‚àÉ (f : (a : ‚Ñ§) ‚Üí Œ±), StrictMono f","name":"Int.exists_strictMono","isProp":true,"docString":"If `Œ±` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nmonotone function `f : ‚Ñ§ ‚Üí Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CanonicallyLinearOrderedAddMonoid Œ±] [inst_1 : Sub Œ±] [inst_2 : OrderedSub Œ±] {a : Œ±} {b : Œ±}\n  {c : Œ±} (ha : AddLECancellable a) (hb : AddLECancellable b) (h : b ‚â§ a), (a - b < a - c : Prop) ‚Üî (c < b : Prop)","name":"AddLECancellable.tsub_lt_tsub_iff_left_of_le","isProp":true,"docString":"See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order. "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} (a : IsCoprime ‚Üëm ‚Üën), Nat.coprime m n","name":"IsCoprime.nat_coprime","isProp":true,"docString":"**Alias** of the forward direction of `Nat.isCoprime_iff_coprime`."},{"type":"‚àÄ (R : Type u_3) [inst : Semiring R] {C : Type u_5} [inst_1 : CategoryTheory.Category C]\n  [inst_2 : CategoryTheory.Preadditive C] [inst_3 : CategoryTheory.Linear R C]\n  [inst_4 : CategoryTheory.MonoidalCategory C] [inst_5 : CategoryTheory.MonoidalPreadditive C]\n  [inst_6 : CategoryTheory.MonoidalLinear R C] {D : Type u_1} [inst_7 : CategoryTheory.Category D]\n  [inst_8 : CategoryTheory.Preadditive D] [inst_9 : CategoryTheory.Linear R D]\n  [inst_10 : CategoryTheory.MonoidalCategory D] [inst_11 : CategoryTheory.MonoidalPreadditive D]\n  (F : CategoryTheory.MonoidalFunctor D C)\n  [inst_12 :\n    CategoryTheory.Faithful\n      (CategoryTheory.LaxMonoidalFunctor.toFunctor (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F))]\n  [inst_13 :\n    CategoryTheory.Functor.Additive\n      (CategoryTheory.LaxMonoidalFunctor.toFunctor (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F))]\n  [inst_14 :\n    CategoryTheory.Functor.Linear R\n      (CategoryTheory.LaxMonoidalFunctor.toFunctor (CategoryTheory.MonoidalFunctor.toLaxMonoidalFunctor F))],\n  CategoryTheory.MonoidalLinear R D","name":"CategoryTheory.monoidalLinearOfFaithful","isProp":true,"docString":"A faithful linear monoidal functor to a linear monoidal category\nensures that the domain is linear monoidal. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : SuccOrder Œ±] {a : Œ±} {b : Œ±} [inst_2 : NoMaxOrder Œ±]\n  (a_1 : Order.succ a ‚â§ Order.succ b), a ‚â§ b","name":"Order.le_of_succ_le_succ","isProp":true,"docString":"**Alias** of the forward direction of `Order.succ_le_succ_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Bornology Œ±] [inst_1 : Bornology Œ≤] (self : LocallyBoundedMap Œ± Œ≤),\n  Filter.comap (LocallyBoundedMap.toFun self) (Bornology.cobounded Œ≤) ‚â§ Bornology.cobounded Œ±","name":"LocallyBoundedMap.comap_cobounded_le'","isProp":true,"docString":"The pullback of the `Bornology.cobounded` filter under the function is contained in the\ncobounded filter. Equivalently, the function maps bounded sets to bounded sets. "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {a : Œ±},\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà {a}) ‚Ü¶ f i) = f a","name":"finsum_mem_singleton","isProp":true,"docString":"The sum of `f i` over `i ‚àà {a}` equals `f a`."},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (v : M) {r : R} (h : 0 ‚â§ r), SameRay R v (r ‚Ä¢ v)","name":"SameRay.sameRay_nonneg_smul_right","isProp":true,"docString":"A vector is in the same ray as a nonnegative multiple of itself. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} (h : Set.Nonempty ‚Üës),\n  AffineSubspace.directionOfNonempty h = AffineSubspace.direction s","name":"AffineSubspace.directionOfNonempty_eq_direction","isProp":true,"docString":"`direction_of_nonempty` gives the same submodule as `direction`. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G ‚Üí+ N) (s : Set G),\n  AddSubgroup.map f (AddSubgroup.closure s) = AddSubgroup.closure (‚Üëf '' s)","name":"AddMonoidHom.map_closure","isProp":true,"docString":"The image under an `AddMonoid` hom of the `AddSubgroup` generated by a set equals\nthe `AddSubgroup` generated by the image of the set."},{"type":"‚àÄ {N : Type u_1} {Œ± : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder N] {f : (a : N) ‚Üí Œ±} {Œº : (a : N) ‚Üí (a : N) ‚Üí N}\n  [inst_2 : CovariantClass N N (Function.swap Œº) fun (x : N) (x_1 : N) ‚Ü¶ x ‚â§ x_1] (hf : Antitone f) (m : N),\n  Antitone fun (n : N) ‚Ü¶ f (Œº n m)","name":"Antitone.covariant_of_const'","isProp":true,"docString":"Dual of `Monotone.covariant_of_const'` "},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module R E] [inst_4 : Module R F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : ContinuousAdd E] [inst_8 : ContinuousAdd F] [inst_9 : TopologicalSpace R] [inst_10 : ContinuousSMul R E]\n  [inst_11 : ContinuousSMul R F] (f : E ‚Üí‚Çó.[R] F), f ‚â§ LinearPMap.closure f","name":"LinearPMap.le_closure","isProp":true,"docString":"A `LinearPMap` is contained in its closure. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {f : M ‚Üí+ N} {g : M ‚Üí+ N} (h : f = g)\n  (x : M), ‚Üëf x = ‚Üëg x","name":"AddMonoidHom.congr_fun","isProp":true,"docString":"Deprecated: use `FunLike.congr_fun` instead."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {Œ≤ : Type u_2} [inst_1 : Ring Œ≤] {abv : (a : Œ≤) ‚Üí Œ±}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete Œ≤ abv] (s : CauSeq Œ≤ abv), ‚àÉ (b : Œ≤), s ‚âà CauSeq.const abv b","name":"CauSeq.IsComplete.isComplete","isProp":true,"docString":"Every Cauchy sequence has a limit. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : UniqueFactorizationMonoid Œ±]\n  [inst_2 : NormalizationMonoid Œ±] [inst_3 : DecidableEq Œ±] {x : Œ±} {n : ‚Ñï}, factorization (x ^ n) = n ‚Ä¢ factorization x","name":"factorization_pow","isProp":true,"docString":"For any `p`, the power of `p` in `x^n` is `n` times the power in `x` "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R]\n  {M : Type u_3} [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : Finite Œπ] (b : Basis Œπ R M)\n  (N : Submodule R M) (O : Submodule R M) (N_le_O : N ‚â§ O),\n  ‚àÉ (n : ‚Ñï),\n    ‚àÉ (o : ‚Ñï),\n      ‚àÉ (hno : n ‚â§ o),\n        ‚àÉ (bO : Basis (Fin o) R { x : M // x ‚àà O }),\n          ‚àÉ (bN : Basis (Fin n) R { x : M // x ‚àà N }),\n            ‚àÉ (a : (a : Fin n) ‚Üí R), ‚àÄ (i : Fin n), ‚Üë(‚ÜëbN i) = ‚Üë(a i ‚Ä¢ ‚ÜëbO (‚Üë(Fin.castLE hno) i))","name":"Submodule.exists_smith_normal_form_of_le","isProp":true,"docString":"If `M` is finite free over a PID `R`, then any submodule `N` is free\nand we can find a basis for `M` and `N` such that the inclusion map is a diagonal matrix\nin Smith normal form.\n\nSee `Submodule.smithNormalFormOfLE` for a version of this theorem that returns\na `Basis.SmithNormalForm`.\n\nThis is a strengthening of `Submodule.basisOfPidOfLE`.\n"},{"type":"‚àÄ {a : ‚Ñï} {b : ‚Ñï} (hab : Nat.coprime a b),\n  Finsupp.support (Nat.factorization (a * b)) =\n    Finsupp.support (Nat.factorization a) ‚à™ Finsupp.support (Nat.factorization b)","name":"Nat.factorization_mul_support_of_coprime","isProp":true,"docString":"For coprime `a` and `b` the prime factorization `a * b` is the union of those of `a` and `b` "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) {w : M} {x : M} {y : M} {z : M} (a : ‚Üëc w x) (a : ‚Üëc y z),\n  ‚Üëc (w * y) (x * z)","name":"Con.mul","isProp":true,"docString":"Multiplicative congruence relations preserve multiplication. "},{"type":"‚àÄ {H : Type u} [inst : TopologicalSpace H] {Œ± : Type u_1} [inst_1 : TopologicalSpace Œ±] (e : LocalHomeomorph Œ± H)\n  (h : LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) = Set.univ) (G : StructureGroupoid H)\n  [inst_2 : ClosedUnderRestriction G], HasGroupoid Œ± G","name":"LocalHomeomorph.singleton_hasGroupoid","isProp":true,"docString":"Given a local homeomorphism `e` from a space `Œ±` into `H`, if its source covers the whole\nspace `Œ±`, then the induced charted space structure on `Œ±` is `HasGroupoid G` for any structure\ngroupoid `G` which is closed under restrictions. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : 1 ‚â§ a) (hb : 1 ‚â§ b), 1 ‚â§ a * b","name":"one_le_mul","isProp":true,"docString":"**Alias** of `Left.one_le_mul`."},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {f : AddHom M N} {g : AddHom M N} {s : Set M}\n  (h : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(AddSubsemigroup.closure s)","name":"AddHom.eqOn_closure","isProp":true,"docString":"If two add homomorphisms are equal on a set,\nthen they are equal on its additive subsemigroup closure."},{"type":"‚àÄ {n : ‚Ñï} {a : Fin n} {b : Fin n} {x : Fin (n + 1)},\n  (‚Üë(Fin.succAbove x) a = ‚Üë(Fin.succAbove x) b : Prop) ‚Üî (a = b : Prop)","name":"Fin.succAbove_right_inj","isProp":true,"docString":"Given a fixed pivot `x : Fin (n + 1)`, `x.succAbove` is injective "},{"type":"‚àÄ {R : Type u_3} [inst : CommRing R] (M : Submonoid R) (S : Type u_4) [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  (R‚Çò : Type u_2) (S‚Çò : Type u_1) [inst_3 : CommRing R‚Çò] [inst_4 : CommRing S‚Çò] [inst_5 : Algebra R R‚Çò]\n  [inst_6 : IsLocalization M R‚Çò] [inst_7 : Algebra S S‚Çò] [i : IsLocalization (Algebra.algebraMapSubmonoid S M) S‚Çò]\n  [inst_8 : Algebra R‚Çò S‚Çò] [inst_9 : Algebra R S‚Çò] [inst_10 : IsScalarTower R R‚Çò S‚Çò] [inst_11 : IsScalarTower R S S‚Çò]\n  (x : R‚Çò),\n  ‚Üë(algebraMap R‚Çò S‚Çò) x =\n    ‚Üë(IsLocalization.map S‚Çò (algebraMap R S)\n          (let_fun this : M ‚â§ Submonoid.comap (algebraMap R S) (Algebra.algebraMapSubmonoid S M) :=\n              ((Submonoid.le_comap_map\n                    M=:M ‚â§\n                    Submonoid.comap (algebraMap R S)\n                      (Submonoid.map (algebraMap R S)\n                        M))=:M ‚â§ Submonoid.comap (algebraMap R S) (Submonoid.map (algebraMap R S) M));\n            this=:M ‚â§ Submonoid.comap (algebraMap R S) (Algebra.algebraMapSubmonoid S M)))\n      x","name":"IsLocalization.algebraMap_apply_eq_map_map_submonoid","isProp":true,"docString":"If the square below commutes, the bottom map is uniquely specified:\n```\nR  ‚Üí  S\n‚Üì     ‚Üì\nR‚Çò ‚Üí S‚Çò\n```\n"},{"type":"‚àÄ {G : Type w} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] {Œì : Subgroup G}\n  [inst_3 : TopologicalSpace.SecondCountableTopology G], TopologicalSpace.SecondCountableTopology (G ‚ß∏ Œì)","name":"QuotientGroup.secondCountableTopology","isProp":true,"docString":"The quotient of a second countable topological group by a subgroup is second countable. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p‚ÇÅ : P} {p‚ÇÇ : P} {v : V},\n  (v ‚àà vectorSpan k {p‚ÇÅ, p‚ÇÇ} : Prop) ‚Üî (‚àÉ (r : k), r ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ) = v : Prop)","name":"mem_vectorSpan_pair","isProp":true,"docString":"A vector lies in the `vectorSpan` of two points if and only if it is a multiple of their\ndifference. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [inst : TopologicalSpace ùïú] [inst_1 : CommSemiring ùïú]\n  [inst_2 : AddCommMonoid E] [inst_3 : Module ùïú E] [inst_4 : AddCommMonoid F] [inst_5 : Module ùïú F]\n  {B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú} (hB : Function.Injective ‚ÜëB), Embedding fun (x : WeakBilin B) (y : F) ‚Ü¶ ‚Üë(‚ÜëB x) y","name":"WeakBilin.embedding","isProp":true,"docString":"The coercion `(fun x y => B x y) : E ‚Üí (F ‚Üí ùïú)` is an embedding. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedField Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx - y‚Äñ","name":"NormedField.dist_eq","isProp":true,"docString":"The distance is induced by the norm. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {s : Set (Set Œ±)} (self : TopologicalSpace.IsTopologicalBasis s),\n  ‚ãÉ‚ÇÄ s = Set.univ","name":"TopologicalSpace.IsTopologicalBasis.union‚Çõ_eq","isProp":true,"docString":"The sets from `s` cover the whole space. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {E : Type u_3}\n  [inst_2 : Norm E] {F : Type u_4} [inst_3 : Norm F] (e : LocalHomeomorph Œ± Œ≤) {b : Œ≤}\n  (hb : b ‚àà LocalEquiv.target (LocalHomeomorph.toLocalEquiv e)) {f : (a : Œ≤) ‚Üí E} {g : (a : Œ≤) ‚Üí F} {C : ‚Ñù},\n  (Asymptotics.IsBigOWith C (nhds b) f g : Prop) ‚Üî\n    (Asymptotics.IsBigOWith C (nhds (‚Üë(LocalHomeomorph.symm e) b)) (f ‚àò ‚Üëe) (g ‚àò ‚Üëe) : Prop)","name":"LocalHomeomorph.isBigOWith_congr","isProp":true,"docString":"Transfer `IsBigOWith` over a `LocalHomeomorph`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : ConditionallyCompleteLinearOrderBot Œ±] (x : Œ±), ‚ä• ‚â§ x","name":"ConditionallyCompleteLinearOrderBot.bot_le","isProp":true,"docString":"`‚ä•` is the least element "},{"type":"‚àÄ {Œ± : Type u_2} {G : Type u_1} [inst : DivisionCommMonoid G] {f : (a : Œ±) ‚Üí G} {g : (a : Œ±) ‚Üí G}\n  (hf : Set.Finite (Function.mulSupport f)) (hg : Set.Finite (Function.mulSupport g)),\n  (finprod fun (i : Œ±) ‚Ü¶ f i / g i) = (finprod fun (i : Œ±) ‚Ü¶ f i) / finprod fun (i : Œ±) ‚Ü¶ g i","name":"finprod_div_distrib","isProp":true,"docString":"If the multiplicative supports of `f` and `g` are finite, then the product of `f i / g i`\nequals the product of `f i` divided by the product of `g i`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : TopologicalSpace E]\n  [inst_2 : AddCancelCommMonoid E] [inst_3 : ContinuousAdd E] [inst_4 : Module ùïú E] {s : Set E} (hs : StrictConvex ùïú s)\n  (z : E), StrictConvex ùïú ((fun (x : E) ‚Ü¶ z + x) ‚Åª¬π' s)","name":"StrictConvex.preimage_add_right","isProp":true,"docString":"The translation of a strictly convex set is also strictly convex. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  [inst_2 : CategoryTheory.Full F] [inst_3 : CategoryTheory.Faithful F] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  [inst_4 : CategoryTheory.IsIso (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_fully_faithful","isProp":true,"docString":"If the image of a morphism under a fully faithful functor in an isomorphism,\nthen the original morphisms is also an isomorphism.\n"},{"type":"‚àÄ {Œ≥ : Type w} [inst : EMetricSpace Œ≥], SeparatedSpace Œ≥","name":"to_separated","isProp":true,"docString":"An emetric space is separated "},{"type":"‚àÄ (R : Type u_1) [inst : Rack R] (G : Type u_2) [inst_1 : Group G] (f : ShelfHom R (Quandle.Conj G))\n  (g : Rack.EnvelGroup R ‚Üí* G) (h : f = ShelfHom.comp (Quandle.Conj.map g) (Rack.toEnvelGroup R)),\n  g = ‚ÜëRack.toEnvelGroup.map f","name":"Rack.toEnvelGroup.univ_uniq","isProp":true,"docString":"The homomorphism `toEnvelGroup.map f` is the unique map that fits into the commutative\ntriangle in `toEnvelGroup.univ`.\n"},{"type":"‚àÄ {R : Type u} {Œπ : Type w} (s : Finset Œπ) [inst : CommSemiring R] [inst_1 : NoZeroDivisors R]\n  (f : (a : Œπ) ‚Üí Polynomial R) (h : ‚àÄ (i : Œπ) (a : i ‚àà s), f i ‚â† 0),\n  Polynomial.natDegree (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) = Finset.sum s fun (i : Œπ) ‚Ü¶ Polynomial.natDegree (f i)","name":"Polynomial.natDegree_prod","isProp":true,"docString":"The degree of a product of polynomials is equal to\nthe sum of the degrees.\n\nSee `Polynomial.natDegree_prod'` (with a `'`) for a version for commutative semirings,\nwhere additionally, the product of the leading coefficients must be nonzero.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} (sm : CategoryTheory.SplitMono f),\n  CategoryTheory.IsSplitMono f","name":"CategoryTheory.IsSplitMono.mk'","isProp":true,"docString":"A constructor for `IsSplitMono f` taking a `SplitMono f` as an argument "},{"type":"‚àÄ {B : Type u_1} {F : Type u_2} {Z : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  [inst_2 : TopologicalSpace Z] {proj : (a : Z) ‚Üí B} (h : IsHomeomorphicTrivialFiberBundle F proj), Continuous proj","name":"IsHomeomorphicTrivialFiberBundle.continuous_proj","isProp":true,"docString":"The projection from a trivial fiber bundle to its base is continuous. "},{"type":"‚àÄ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ‚â† 0","name":"NeZero.out","isProp":true,"docString":"The proposition that `n` is not zero. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedRing Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"LinearOrderedRing.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ {R : Type u_5} {M : Type u_6} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (p : Submodule R M)\n  {R‚ÇÇ : Type u_3} {M‚ÇÇ : Type u_4} [inst_3 : Ring R‚ÇÇ] [inst_4 : AddCommGroup M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ] {œÑ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  {R‚ÇÉ : Type u_1} {M‚ÇÉ : Type u_2} [inst_6 : Ring R‚ÇÉ] [inst_7 : AddCommGroup M‚ÇÉ] [inst_8 : Module R‚ÇÉ M‚ÇÉ]\n  (p‚ÇÇ : Submodule R‚ÇÇ M‚ÇÇ) (p‚ÇÉ : Submodule R‚ÇÉ M‚ÇÉ) {œÑ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÑ‚ÇÅ‚ÇÉ : R ‚Üí+* R‚ÇÉ}\n  [inst_9 : RingHomCompTriple œÑ‚ÇÅ‚ÇÇ œÑ‚ÇÇ‚ÇÉ œÑ‚ÇÅ‚ÇÉ] (f : M ‚Üí‚Çõ‚Çó[œÑ‚ÇÅ‚ÇÇ] M‚ÇÇ) (g : M‚ÇÇ ‚Üí‚Çõ‚Çó[œÑ‚ÇÇ‚ÇÉ] M‚ÇÉ) (hf : p ‚â§ Submodule.comap f p‚ÇÇ)\n  (hg : p‚ÇÇ ‚â§ Submodule.comap g p‚ÇÉ)\n  (h :\n    optParam (p ‚â§ Submodule.comap f (Submodule.comap g p‚ÇÉ) : Prop)\n      ((LE.le.trans hf\n            ((Submodule.comap_mono\n                  hg=:Submodule.comap f p‚ÇÇ ‚â§\n                  Submodule.comap f\n                    (Submodule.comap g\n                      p‚ÇÉ))=:Submodule.comap f p‚ÇÇ ‚â§\n                Submodule.comap f\n                  (Submodule.comap g\n                    p‚ÇÉ))=:p ‚â§ Submodule.comap f (Submodule.comap g p‚ÇÉ))=:p ‚â§ Submodule.comap f (Submodule.comap g p‚ÇÉ))),\n  Submodule.mapQ p p‚ÇÉ (LinearMap.comp g f) h = LinearMap.comp (Submodule.mapQ p‚ÇÇ p‚ÇÉ g hg) (Submodule.mapQ p p‚ÇÇ f hf)","name":"Submodule.mapQ_comp","isProp":true,"docString":"Given submodules `p ‚äÜ M`, `p‚ÇÇ ‚äÜ M‚ÇÇ`, `p‚ÇÉ ‚äÜ M‚ÇÉ` and maps `f : M ‚Üí M‚ÇÇ`, `g : M‚ÇÇ ‚Üí M‚ÇÉ` inducing\n`mapQ f : M ‚ß∏ p ‚Üí M‚ÇÇ ‚ß∏ p‚ÇÇ` and `mapQ g : M‚ÇÇ ‚ß∏ p‚ÇÇ ‚Üí M‚ÇÉ ‚ß∏ p‚ÇÉ` then\n`mapQ (g ‚àò f) = (mapQ g) ‚àò (mapQ f)`. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} (a : l ‚äÜ []), l = []","name":"List.eq_nil_of_subset_nil","isProp":true,"docString":"**Alias** of the forward direction of `List.subset_nil`."},{"type":"‚àÄ {F : Type u_1} {M : outParam (Type u_2)} {R : outParam (Type u_3)} {S : outParam (Type u_4)} [inst : Monoid M]\n  [inst_1 : Semiring R] [inst_2 : Semiring S] [inst_3 : DistribMulAction M R] [inst_4 : DistribMulAction M S]\n  [self : MulSemiringActionHomClass F M R S] (f : F) (x : R) (y : R), ‚Üëf (x * y) = ‚Üëf x * ‚Üëf y","name":"MulSemiringActionHomClass.map_mul","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ (J : Type u‚ÇÅ) [inst : CategoryTheory.Category J] {C : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category C]\n  [inst_2 : Nonempty J], CategoryTheory.Faithful (CategoryTheory.Functor.const J)","name":"CategoryTheory.Functor.instFaithfulFunctorCategoryConst","isProp":true,"docString":"If `J` is nonempty, then the constant functor over `J` is faithful. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : IsSuccArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico n m), r i (Order.succ i))\n  (hnm : n ‚â§ m), Relation.ReflTransGen r n m","name":"reflTransGen_of_succ_of_le","isProp":true,"docString":"For `n ‚â§ m`, `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ succ i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {J : Type u}\n  [inst_2 : CategoryTheory.Category J] [inst_3 : CategoryTheory.Limits.HasLimitsOfShape J C] (R : D ‚•§ C)\n  [inst : CategoryTheory.Reflective R], CategoryTheory.Limits.HasLimitsOfShape J D","name":"CategoryTheory.hasLimitsOfShape_of_reflective","isProp":true,"docString":"If `C` has limits of shape `J` then any reflective subcategory has limits of shape `J`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set V} (hs : ‚àÄ (v : V) (a : v ‚àà s), v ‚â† 0) (p‚ÇÅ : P),\n  (LinearIndependent k fun (v : ‚Üës) ‚Ü¶ ‚Üëv : Prop) ‚Üî\n    (AffineIndependent k fun (p : ‚Üë({p‚ÇÅ} ‚à™ (fun (v : V) ‚Ü¶ v +·µ• p‚ÇÅ) '' s)) ‚Ü¶ ‚Üëp : Prop)","name":"linearIndependent_set_iff_affineIndependent_vadd_union_singleton","isProp":true,"docString":"A set of nonzero vectors is linearly independent if and only if,\ngiven a point `p‚ÇÅ`, the vectors added to `p‚ÇÅ` and `p‚ÇÅ` itself are\naffinely independent. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommSemigroup Œ±] [inst_1 : PartialOrder Œ±] [inst_2 : ExistsAddOfLE Œ±]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] [inst_4 : Sub Œ±]\n  [inst_5 : OrderedSub Œ±] {a : Œ±} {b : Œ±} {c : Œ±}\n  [inst_6 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (h : c ‚â§ b),\n  (a < b - c : Prop) ‚Üî (a + c < b : Prop)","name":"lt_tsub_iff_right_of_le","isProp":true,"docString":"See `lt_tsub_iff_right` for a stronger statement in a linear order. "},{"type":"‚àÄ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {a : M} {b : M}\n  (ha : a * b = 1), Filter.Tendsto (fun (x : M) ‚Ü¶ x * a) (Filter.cocompact M) (Filter.cocompact M)","name":"Filter.tendsto_cocompact_mul_right","isProp":true,"docString":"Right-multiplication by a right-invertible element of a topological monoid is proper, i.e.,\ninverse images of compact sets are compact. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_3} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] {P : Type u_2} [inst_3 : CommSemiring P] [inst_4 : IsLocalization M S] {g : R ‚Üí+* P}\n  (hg : ‚àÄ (y : { x : R // x ‚àà M }), IsUnit (‚Üëg ‚Üëy)) {x : R} {y : R} (h : ‚Üë(algebraMap R S) x = ‚Üë(algebraMap R S) y),\n  ‚Üëg x = ‚Üëg y","name":"IsLocalization.eq_of_eq","isProp":true,"docString":"Given a localization map `f : R ‚Üí+* S` for a submonoid `M ‚äÜ R` and a map of `CommSemiring`s\n`g : R ‚Üí+* P` such that `g(M) ‚äÜ Units P`, `f x = f y ‚Üí g x = g y` for all `x y : R`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex k P n) {fs : Finset (Fin (n + 1))} {m : ‚Ñï}\n  (h : Finset.card fs = m + 1),\n  Affine.Simplex.points (Affine.Simplex.face s h) = Affine.Simplex.points s ‚àò ‚Üë(Finset.orderEmbOfFin fs h)","name":"Affine.Simplex.face_points'","isProp":true,"docString":"The points of a face of a simplex are given by `mono_of_fin`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {K : NNReal} {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : LipschitzWith K f), Continuous f","name":"LipschitzWith.continuous","isProp":true,"docString":"A Lipschitz function is continuous "},{"type":"‚àÄ {Œ± : Type u_3} {n : Type u_1} {R : Type u_2} [inst : Sub n] [inst_1 : SMul R Œ±] (k : R) (v : (a : n) ‚Üí Œ±),\n  Matrix.circulant (k ‚Ä¢ v) = k ‚Ä¢ Matrix.circulant v","name":"Matrix.circulant_smul","isProp":true,"docString":"`k ‚Ä¢ circulant v` is another circulant matrix `circulant (k ‚Ä¢ v)`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C} {X : C} {Y : C} {Z : C} {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y}\n  {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} (self : CategoryTheory.IsPullback fst snd f g),\n  Nonempty\n    (CategoryTheory.Limits.IsLimit\n      (CategoryTheory.Limits.PullbackCone.mk fst snd\n        ((CategoryTheory.CommSq.w\n              ((CategoryTheory.IsPullback.toCommSq\n                    self=:CategoryTheory.CommSq fst snd f\n                    g)=:CategoryTheory.CommSq fst snd f g)=:fst ‚â´ f = snd ‚â´ g)=:fst ‚â´ f = snd ‚â´ g)))","name":"CategoryTheory.IsPullback.isLimit'","isProp":true,"docString":"the pullback cone is a limit "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±),\n  (IsUnit A : Prop) ‚Üî (IsUnit (Matrix.det A) : Prop)","name":"Matrix.isUnit_iff_isUnit_det","isProp":true,"docString":"When lowered to a prop, `Matrix.invertibleEquivDetInvertible` forms an `iff`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] {œÉ : (a : Œ±) ‚Üí Type u_1} (s : Finset Œ±) (t : (a : Œ±) ‚Üí Finset (œÉ a))\n  (f : (a : Sigma œÉ) ‚Üí Œ≤),\n  (Finset.prod (Finset.sigma s t) fun (x : (i : Œ±) √ó œÉ i) ‚Ü¶ f x) =\n    Finset.prod s fun (a : Œ±) ‚Ü¶ Finset.prod (t a) fun (s : œÉ a) ‚Ü¶ f { fst := a, snd := s }","name":"Finset.prod_sigma","isProp":true,"docString":"Product over a sigma type equals the product of fiberwise products. For rewriting\nin the reverse direction, use `Finset.prod_sigma'`.  "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasCokernel f]\n  [inst_4 : CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.cokernel.œÄ f)] [inst_5 : CategoryTheory.Epi f],\n  CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Œπ (CategoryTheory.Limits.cokernel.œÄ f))","name":"CategoryTheory.Limits.kernel.of_cokernel_of_epi","isProp":true,"docString":"The kernel of the cokernel of an epimorphism is an isomorphism "},{"type":"‚àÄ (k : ‚Ñï) (n : ‚Ñï), List.Nodup (List.Nat.antidiagonalTuple k n)","name":"List.Nat.nodup_antidiagonalTuple","isProp":true,"docString":"The antidiagonal of `n` does not contain duplicate entries. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±},\n  (x ‚àà closure s : Prop) ‚Üî (EMetric.infEdist x s = 0 : Prop)","name":"EMetric.mem_closure_iff_infEdist_zero","isProp":true,"docString":"A point belongs to the closure of `s` iff its infimum edistance to this set vanishes "},{"type":"‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_3} {Œ≥ : Sort u_1} (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥) (P : Prop) [inst : Decidable (P : Prop)]\n  (a : Œ±) (b : Œ±) (c : Œ≤) (d : Œ≤),\n  f (if (P : Prop) then a else b) (if (P : Prop) then c else d) = if (P : Prop) then f a c else f b d","name":"apply_ite‚ÇÇ","isProp":true,"docString":"A two-argument function applied to two `ite`s is a `ite` of that two-argument function\napplied to each of the branches. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : r < 0)\n  (hf : Filter.Tendsto f l Filter.atTop), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atBot","name":"Filter.Tendsto.atTop_mul_neg_const","isProp":true,"docString":"If a function tends to infinity along a filter, then this function multiplied by a negative\nconstant (on the right) tends to negative infinity. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤]\n  (f : (a : Œ±) ‚Üí Œ≤) {w : (a : Œ±) ‚Üí M} {b : M} [inst_3 : LinearOrderedCancelAddCommMonoid M] [inst_4 : Nonempty Œ≤]\n  (hb : (Finset.sum Finset.univ fun (x : Œ±) ‚Ü¶ w x) ‚â§ Fintype.card Œ≤ ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), (Finset.sum (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ) fun (x : Œ±) ‚Ü¶ w x) ‚â§ b","name":"Fintype.exists_sum_fiber_le_of_sum_le_nsmul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons of different weights, non-strict inequality\nversion: there is a pigeonhole with the total weight of pigeons in it less than or equal to `b`\nprovided that the total number of pigeonholes times `b` is greater than or equal to the total weight\nof all pigeons. "},{"type":"‚àÄ {m : Type u_2} {n : Type u_1} {Œ± : Type v} [inst : Fintype m] [inst_1 : Fintype n]\n  [inst_2 : NonUnitalNonAssocSemiring Œ±] (u : (a : m) ‚Üí Œ±) (x : (a : n) ‚Üí Œ±) (e : n ‚âÉ m),\n  Matrix.dotProduct u (x ‚àò ‚Üë(Equiv.symm e)) = Matrix.dotProduct (u ‚àò ‚Üëe) x","name":"Matrix.dotProduct_comp_equiv_symm","isProp":true,"docString":"Permuting a vector on the right of a dot product can be transferred to the left. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] [inst_1 : Fintype Œπ] (f : (a : Œπ) ‚Üí Set Œ±) (a : Œ±),\n  (a ‚àà Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i : Prop) ‚Üî\n    (‚àÉ (g : (a : Œπ) ‚Üí Œ±), ‚àÉ (x : ‚àÄ (i : Œπ), g i ‚àà f i), (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ g i) = a : Prop)","name":"Set.mem_fintype_sum","isProp":true,"docString":"A version of `Set.mem_finset_sum` with a simpler RHS for sums over a Fintype. "},{"type":"‚àÄ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] {K : Type u_3} [inst_2 : Field K] {L : Type u_2}\n  [inst_3 : Field L] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {g : A ‚Üí+* L} (hg : Function.Injective ‚Üëg)\n  (x : A), ‚Üë(IsFractionRing.lift hg) (‚Üë(algebraMap A K) x) = ‚Üëg x","name":"IsFractionRing.lift_algebraMap","isProp":true,"docString":"Given an integral domain `A` with field of fractions `K`,\nand an injective ring hom `g : A ‚Üí+* L` where `L` is a field,\nthe field hom induced from `K` to `L` maps `x` to `g x` for all\n`x : A`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {x : Œ±} {y : Œ±} {S : Set Œ±} [inst_1 : T0Space Œ±] (h : IsGenericPoint x S)\n  (h' : IsGenericPoint y S), x = y","name":"IsGenericPoint.eq","isProp":true,"docString":"In a T‚ÇÄ space, each set has at most one generic point. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {a : Œ±} {b : Œ±} (a_1 : BddBelow s) (a_2 : a ‚àà s)\n  (a : a < b), inf‚Çõ s < b","name":"cinf‚Çõ_lt_of_lt","isProp":true,"docString":"`inf‚Çõ s < b` when there is an element `a` in `s` with `a < b`, when `s` is bounded below.\nThis is essentially an iff, except that the assumptions for the two implications are\nslightly different (one needs boundedness below for one direction, nonemptiness and linear\norder for the other one), so we formulate separately the two implications, contrary to\nthe `CompleteLattice` case."},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommGroupWithZero Œ±] (a : Œ±), LinearOrderedCommGroupWithZero.zpow 0 a = 1","name":"LinearOrderedCommGroupWithZero.zpow_zero'","isProp":true,"docString":"`a ^ 0 = 1` "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\n  {œÉ' : outParam (R‚ÇÇ ‚Üí+* R‚ÇÅ)} [self : RingHomInvPair œÉ œÉ'], RingHom.comp œÉ œÉ' = RingHom.id R‚ÇÇ","name":"RingHomInvPair.comp_eq‚ÇÇ","isProp":true,"docString":"`œÉ'` is a left inverse of `œÉ'` "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] (t : List Œπ) (f‚ÇÅ : (a : Œπ) ‚Üí Set Œ±) (f‚ÇÇ : (a : Œπ) ‚Üí Set Œ±)\n  (hf : ‚àÄ (i : Œπ) (a : i ‚àà t), f‚ÇÅ i ‚äÜ f‚ÇÇ i), List.sum (List.map f‚ÇÅ t) ‚äÜ List.sum (List.map f‚ÇÇ t)","name":"Set.list_sum_subset_list_sum","isProp":true,"docString":"An n-ary version of `Set.add_subset_add`. "},{"type":"‚àÄ {n : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (a_1 : ‚Üën ‚à£ ‚Üëb - ‚Üëa), a ‚â° b [MOD n]","name":"Nat.modEq_of_dvd","isProp":true,"docString":"**Alias** of the reverse direction of `Nat.modEq_iff_dvd`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {s : Set Œ±} {t : Set Œ≤}\n  {f : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥} {g : (a : Œ≤) ‚Üí Œ≤'} {f' : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ¥} {g' : (a : Œ¥) ‚Üí Œ≥}\n  (h_right_anticomm : ‚àÄ (a : Œ±) (b : Œ≤), f a (g b) = g' (f' b a)), Set.image2 f s (g '' t) = g' '' Set.image2 f' t s","name":"Set.image_image2_right_anticomm","isProp":true,"docString":"Symmetric statement to `Set.image_image2_antidistrib_right`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] {s : Set M}, s ‚äÜ ‚Üë(AddSubmonoid.closure s)","name":"AddSubmonoid.subset_closure","isProp":true,"docString":"The `AddSubmonoid` generated by a set includes the set."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {K : Type u‚ÇÅ} [inst_1 : CategoryTheory.Category K] (e : J ‚âå K)\n  [inst : CategoryTheory.IsConnected J], CategoryTheory.IsConnected K","name":"CategoryTheory.isConnected_of_equivalent","isProp":true,"docString":"If `J` and `K` are equivalent, then if `J` is connected then `K` is as well. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M ‚Üí* N) (a : M) (b : M),\n  ‚Üëf (a * b) = ‚Üëf a * ‚Üëf b","name":"MonoidHom.map_mul","isProp":true,"docString":"If `f` is a monoid homomorphism then `f (a * b) = f a * f b`. "},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] {X : C} {Y : C} (f : X ‚ü∂ Y) (Z : C)\n  (l :\n    CategoryTheory.Limits.IsLimit\n      (CategoryTheory.Limits.KernelFork.ofŒπ 0\n        (let_fun this : 0 ‚â´ f = 0 :=\n            ((of_eq_true\n                  ((Eq.trans\n                        ((congrFun\n                              ((congrArg Eq\n                                    ((CategoryTheory.Limits.zero_comp=:0 ‚â´ f =\n                                          0)=:0 ‚â´ f = 0)=:Eq (0 ‚â´ f) = Eq 0)=:Eq (0 ‚â´ f) = Eq 0)\n                              0=:(0 ‚â´ f = 0 : Prop) = (0 = 0 : Prop))=:(0 ‚â´ f = 0 : Prop) = (0 = 0 : Prop))\n                        ((eq_self\n                              0=:(0 = 0 : Prop) =\n                              (True :\n                                Prop))=:(0 = 0 : Prop) =\n                            (True :\n                              Prop))=:(0 ‚â´ f = 0 : Prop) =\n                        (True : Prop))=:(0 ‚â´ f = 0 : Prop) = (True : Prop))=:0 ‚â´ f = 0)=:0 ‚â´ f = 0);\n          this=:0 ‚â´ f = 0))),\n  CategoryTheory.Mono f","name":"CategoryTheory.NormalEpiCategory.mono_of_zero_kernel","isProp":true,"docString":"If a zero morphism is a kernel of `f`, then `f` is a monomorphism. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : Nonempty Œ≤] [inst_2 : SemilatticeSup Œ≤]\n  {u : (a : Œ≤) ‚Üí Œ±},\n  (CauchySeq u : Prop) ‚Üî (‚àÄ (Œµ : NNReal) (a : 0 < Œµ), ‚àÉ (N : Œ≤), ‚àÄ (n : Œ≤) (a : N ‚â§ n), edist (u n) (u N) < ‚ÜëŒµ : Prop)","name":"EMetric.cauchySeq_iff_NNReal","isProp":true,"docString":"A variation of the emetric characterization of Cauchy sequences that deals with\n`‚Ñù‚â•0` upper bounds. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {f : M ‚Üí+ P} (x : M),\n  ‚Üë(AddCon.ker f) x = ‚Üëf ‚Åª¬π' {‚Üëf x}","name":"AddCon.ker_apply_eq_preimage","isProp":true,"docString":"The elements related to `x ‚àà M`, `M` an `AddMonoid`, by the kernel of\nan `AddMonoid` homomorphism are those in the preimage of `f(x)` under `f`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {U : Set X} {W : Set X} (hW : IsPathConnected W) (hWU : W ‚äÜ U),\n  IsPathConnected (Subtype.val ‚Åª¬π' W)","name":"IsPathConnected.preimage_coe","isProp":true,"docString":"If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\nambient type `U` (when `U` contains `W`). "},{"type":"‚àÄ {Œπ : Type u_1} {A : (a : Œπ) ‚Üí Type u_2} {M : (a : Œπ) ‚Üí Type u_3} [inst : AddMonoid Œπ]\n  [inst_1 : GradedMonoid.GMonoid A] [self : GradedMonoid.GMulAction A M] (a : GradedMonoid A) (a' : GradedMonoid A)\n  (b : GradedMonoid M), (a * a') ‚Ä¢ b = a ‚Ä¢ a' ‚Ä¢ b","name":"GradedMonoid.GMulAction.mul_smul","isProp":true,"docString":"Associativity of `‚Ä¢` and `*` "},{"type":"‚àÄ {M‚ÇÄ : Type u} [self : MulZeroClass M‚ÇÄ] (a : M‚ÇÄ), a * 0 = 0","name":"MulZeroClass.mul_zero","isProp":true,"docString":"Zero is a right absorbing element for multiplication "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : Zero M] (self : Œ± ‚Üí‚ÇÄ M) (a : Œ±),\n  (a ‚àà Finsupp.support self : Prop) ‚Üî (Finsupp.toFun self a ‚â† 0 : Prop)","name":"Finsupp.mem_support_toFun","isProp":true,"docString":"The witness that the support of a `Finsupp` is indeed the exact locus where its\nunderlying function is nonzero. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : AddZeroClass R] [inst_1 : AddZeroClass M] {P : (a : TrivSqZeroExt R M) ‚Üí Prop}\n  (h : ‚àÄ (r : R) (m : M), P (TrivSqZeroExt.inl r + TrivSqZeroExt.inr m)) (x : TrivSqZeroExt R M), P x","name":"TrivSqZeroExt.ind","isProp":true,"docString":"To show a property hold on all `TrivSqZeroExt R M` it suffices to show it holds\non terms of the form `inl r + inr m`.\n\nThis can be used as `induction x using TrivSqZeroExt.ind`. "},{"type":"‚àÄ {Œ± : Type u} {p : (a : Œ±) ‚Üí Prop} (f : Equiv.Perm Œ±) (hf : ‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf x) : Prop)),\n  (Equiv.Perm.subtypePerm f hf)‚Åª¬π =\n    Equiv.Perm.subtypePerm f‚Åª¬π\n      ((Iff.mp\n            ((Equiv.Perm.inv_aux=:(‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf x) : Prop) : Prop) ‚Üî\n                  (‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf‚Åª¬π x) : Prop) :\n                    Prop))=:(‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf x) : Prop) : Prop) ‚Üî\n                (‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf‚Åª¬π x) : Prop) : Prop))\n            hf=:‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf‚Åª¬π x) : Prop))=:‚àÄ (x : Œ±), (p x : Prop) ‚Üî (p (‚Üëf‚Åª¬π x) : Prop))","name":"Equiv.Perm.inv_subtypePerm","isProp":true,"docString":"See `Equiv.Perm.subtypePerm_inv`"},{"type":"‚àÄ {M' : Type u_1} {X : Type u_2} [inst : SMul M' X] {Y : Type u_3} [inst_1 : SMul M' Y] (self : X ‚Üí[M'] Y) (m : M')\n  (x : X), MulActionHom.toFun self (m ‚Ä¢ x) = m ‚Ä¢ MulActionHom.toFun self x","name":"MulActionHom.map_smul'","isProp":true,"docString":"The proposition that the function preserves the action. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (h : UniformEmbedding f),\n  (‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n        ‚àÉ (Œ¥ : ‚Ñù), (Œ¥ > 0 : Prop) ‚àß (‚àÄ {a : Œ±} {b : Œ±} (a_1 : dist a b < Œ¥), dist (f a) (f b) < Œµ : Prop) :\n      Prop) ‚àß\n    (‚àÄ (Œ¥ : ‚Ñù) (a : Œ¥ > 0),\n        ‚àÉ (Œµ : ‚Ñù), (Œµ > 0 : Prop) ‚àß (‚àÄ {a : Œ±} {b : Œ±} (a_1 : dist (f a) (f b) < Œµ), dist a b < Œ¥ : Prop) :\n      Prop)","name":"Metric.controlled_of_uniformEmbedding","isProp":true,"docString":"If a map between pseudometric spaces is a uniform embedding then the distance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y`. "},{"type":"‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí ENNReal} (hf : (tsum fun (x : Œ±) ‚Ü¶ f x) ‚â† ‚ä§),\n  Filter.Tendsto (fun (s : Finset Œ±) ‚Ü¶ tsum fun (b : { x : Œ± // ¬¨(x ‚àà s : Prop) }) ‚Ü¶ f ‚Üëb) Filter.atTop (nhds 0)","name":"ENNReal.tendsto_tsum_compl_atTop_zero","isProp":true,"docString":"The sum over the complement of a finset tends to `0` when the finset grows to cover the whole\nspace. This does not need a summability assumption, as otherwise all sums are zero. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {f : (a : ‚Ñù) ‚Üí Œ±} {c : ‚Ñù} (hp : Function.Periodic f c) (hc : c ‚â† 0)\n  (hf : Continuous f), Metric.Bounded (Set.range f)","name":"Function.Periodic.bounded_of_continuous","isProp":true,"docString":"A continuous, periodic function is bounded. "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedCommGroup Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c * a ‚â§ c * b","name":"OrderedCommGroup.mul_le_mul_left","isProp":true,"docString":"Multiplication is monotone in a ordered commutative group. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_4) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} [inst_4 : Nontrivial k] {p1 : P} {p : (a : Œπ) ‚Üí P},\n  (p1 ‚àà affineSpan k (Set.range p) : Prop) ‚Üî\n    (‚àÉ (s : Finset Œπ),\n        ‚àÉ (w : (a : Œπ) ‚Üí k), ‚àÉ (x : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1), p1 = ‚Üë(Finset.affineCombination k s p) w :\n      Prop)","name":"mem_affineSpan_iff_eq_affineCombination","isProp":true,"docString":"A point is in the `affineSpan` of an indexed family if and only\nif it is an `affineCombination` with sum of weights 1, provided the\nunderlying ring is nontrivial. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (S : AddSubgroup G)\n  (hS : Filter.Tendsto (‚Üë(AddSubgroup.subtype S)) Filter.cofinite (Filter.cocompact G)),\n  ProperlyDiscontinuousVAdd { x : G·µÉ·µí·µñ // x ‚àà ‚ÜëAddSubgroup.opposite S } G","name":"AddSubgroup.properlyDiscontinuousVAdd_opposite_of_tendsto_cofinite","isProp":true,"docString":"A subgroup `S` of an additive topological group `G` acts on `G` properly discontinuously\non the right, if it is discrete in the sense that `S ‚à© K` is finite for all compact `K`.\n(See also `DiscreteTopology`.)\n\nIf `G` is Hausdorff, this can be combined with `t2Space_of_properlyDiscontinuousVAdd_of_t2Space`\nto show that the quotient group `G ‚ß∏ S` is Hausdorff."},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} {t : Finset Œ≥} {f : (a : Œ±) ‚Üí Œ≤}\n  {g : (a : Œ≥) ‚Üí Œ≤} (i : (a : Œ±) ‚Üí (a : a ‚àà s) ‚Üí Œ≥) (hi : ‚àÄ (a : Œ±) (ha : a ‚àà s), i a ha ‚àà t)\n  (h : ‚àÄ (a : Œ±) (ha : a ‚àà s), f a = g (i a ha)) (j : (a : Œ≥) ‚Üí (a : a ‚àà t) ‚Üí Œ±)\n  (hj : ‚àÄ (a : Œ≥) (ha : a ‚àà t), j a ha ‚àà s)\n  (left_inv : ‚àÄ (a : Œ±) (ha : a ‚àà s), j (i a ha) ((hi a ha=:i a ha ‚àà t)=:i a ha ‚àà t) = a)\n  (right_inv : ‚àÄ (a : Œ≥) (ha : a ‚àà t), i (j a ha) ((hj a ha=:j a ha ‚àà s)=:j a ha ‚àà s) = a),\n  (Finset.sum s fun (x : Œ±) ‚Ü¶ f x) = Finset.sum t fun (x : Œ≥) ‚Ü¶ g x","name":"Finset.sum_bij'","isProp":true,"docString":"Reorder a sum.\n\nThe difference with `sum_bij` is that the bijection is specified with an inverse, rather than\nas a surjective injection."},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] {f : ‚Ñö ‚Üí*‚ÇÄ M‚ÇÄ} {g : ‚Ñö ‚Üí*‚ÇÄ M‚ÇÄ}\n  (h : MonoidWithZeroHom.comp f ‚Üë(Int.castRingHom ‚Ñö) = MonoidWithZeroHom.comp g ‚Üë(Int.castRingHom ‚Ñö)), f = g","name":"MonoidWithZeroHom.ext_rat","isProp":true,"docString":"If `f` and `g` agree on the integers then they are equal `œÜ`.\n\nSee note [partially-applied ext lemmas] for why `comp` is used here. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] [inst_1 : StarRing R] (x : R), ‚Üë(starRingEnd R) (‚Üë(starRingEnd R) x) = x","name":"IsROrC.conj_conj","isProp":true,"docString":"**Alias** of `starRingEnd_self_apply`."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s1 : AffineSubspace k P} {s2 : AffineSubspace k P} (h1 : Set.Nonempty ‚Üës1)\n  (h2 : Set.Nonempty ‚Üës2) (hd : AffineSubspace.direction s1 ‚äî AffineSubspace.direction s2 = ‚ä§), Set.Nonempty (‚Üës1 ‚à© ‚Üës2)","name":"AffineSubspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top","isProp":true,"docString":"If the directions of two nonempty affine subspaces span the whole module, they have nonempty\nintersection. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddGroup Œ±] [inst_1 : SubtractionMonoid Œ≤] (f : Œ± ‚Üí+ Œ≤) (g : Œ±) (n : ‚Ñ§),\n  ‚Üëf (n ‚Ä¢ g) = n ‚Ä¢ ‚Üëf g","name":"AddMonoidHom.map_zsmul","isProp":true,"docString":"Additive group homomorphisms preserve integer scaling."},{"type":"‚àÄ {M : Type u_1} [inst : AddGroup M] (c : AddCon M) {w : M} {x : M} (a : ‚Üëc w x), ‚Üëc (-w) (-x)","name":"AddCon.neg","isProp":true,"docString":"Additive congruence relations preserve negation."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (F : CategoryTheory.Discrete PEmpty ‚•§ C)\n  (G : CategoryTheory.Discrete PEmpty ‚•§ C), F = G","name":"CategoryTheory.Functor.empty_ext'","isProp":true,"docString":"Any two functors out of the empty category are *equal*. You probably want to use\n`emptyExt` instead of this.\n"},{"type":"‚àÄ (Œ± : Type u_1) [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±],\n  CompactIccSpace Œ±","name":"ConditionallyCompleteLinearOrder.toCompactIccSpace","isProp":true,"docString":"A closed interval in a conditionally complete linear order is compact. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (x : Œ±) (c : Set (Set Œ±)) (H1 : ‚àÄ (s : Set Œ±) (a : s ‚àà c), x ‚àà s)\n  (H2 : ‚àÄ (s : Set Œ±) (a : s ‚àà c), IsPreconnected s), IsPreconnected (‚ãÉ‚ÇÄ c)","name":"isPreconnected_union‚Çõ","isProp":true,"docString":"A union of a family of preconnected sets with a common point is preconnected as well. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (self : R ‚âÉ+* S)\n  (x : R) (y : R),\n  Equiv.toFun (RingEquiv.toEquiv self) (x + y) =\n    Equiv.toFun (RingEquiv.toEquiv self) x + Equiv.toFun (RingEquiv.toEquiv self) y","name":"RingEquiv.map_add'","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] {S : AddSubmonoid M} {T : AddSubmonoid M}\n  (h : ‚àÄ (x : M), (x ‚àà S : Prop) ‚Üî (x ‚àà T : Prop)), S = T","name":"AddSubmonoid.ext","isProp":true,"docString":"Two `AddSubmonoid`s are equal if they have the same elements."},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedRing R] (a : R) (h : a ‚â† 0), 0 < a ^ 2","name":"pow_two_pos_of_ne_zero","isProp":true,"docString":"**Alias** of `sq_pos_of_ne_zero`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {f : (a : Œ≤) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ≤} {x : Filter Œ±} {y : Filter Œ≥}\n  (a : Filter.Tendsto (f ‚àò g) x y), Filter.Tendsto f (Filter.map g x) y","name":"Filter.tendsto_map'","isProp":true,"docString":"**Alias** of the reverse direction of `Filter.tendsto_map'_iff`."},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Zero M] [inst_1 : Zero N] (f : ZeroHom M N) {x : M} {y : M} (h : x = y),\n  ‚Üëf x = ‚Üëf y","name":"ZeroHom.congr_arg","isProp":true,"docString":"Deprecated: use `FunLike.congr_arg` instead."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : HeytingAlgebra Œ±] [inst_1 : HeytingAlgebra Œ≤] (self : HeytingHom Œ± Œ≤),\n  SupHom.toFun (LatticeHom.toSupHom (HeytingHom.toLatticeHom self)) ‚ä• = ‚ä•","name":"HeytingHom.map_bot'","isProp":true,"docString":"The proposition that a Heyting homomorphism preserves the bottom element."},{"type":"‚àÄ {k : Type u_4} {V : Type u_3} {P : Type u_5} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} {Œπ‚ÇÇ : Type u_1} (s‚ÇÇ : Finset Œπ‚ÇÇ) (e : Œπ‚ÇÇ ‚Ü™ Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P)\n  (b : P), ‚Üë(Finset.weightedVSubOfPoint (Finset.map e s‚ÇÇ) p b) w = ‚Üë(Finset.weightedVSubOfPoint s‚ÇÇ (p ‚àò ‚Üëe) b) (w ‚àò ‚Üëe)","name":"Finset.weightedVSubOfPoint_map","isProp":true,"docString":"A weighted sum, over the image of an embedding, equals a weighted\nsum with the same points and weights over the original\n`Finset`. "},{"type":"‚àÄ (a : ‚Ñï) (b : ‚Ñï), a ^ 2 - b ^ 2 = (a + b) * (a - b)","name":"Nat.pow_two_sub_pow_two","isProp":true,"docString":"**Alias** of `Nat.sq_sub_sq`."},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} (a : Disjoint t s), s ‚äÜ t·∂ú","name":"Disjoint.subset_compl_left","isProp":true,"docString":"**Alias** of the reverse direction of `Set.subset_compl_iff_disjoint_left`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±) (y : Œ±), edist x y ‚â† ‚ä§","name":"edist_ne_top","isProp":true,"docString":"In a pseudometric space, the extended distance is always finite"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i) < Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i) : Prop) ‚Üî\n    (¬¨(AntivaryOn f (g ‚àò ‚ÜëœÉ) ‚Üës : Prop) : Prop)","name":"AntivaryOn.sum_mul_lt_sum_mul_comp_perm_iff","isProp":true,"docString":"**Strict inequality case of the Rearrangement Inequality**: Pointwise multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not antivary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ± : Type u} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [inst : IsAntisymm Œ± r] {a : Œ±} {b : Œ±} (a_1 : r a b) (a_2 : r b a), a = b","name":"antisymm_of","isProp":true,"docString":"A version of `antisymm` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `Init.Algebra.Classes`, but is missing there.  "},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] {S : NonUnitalSubsemiring R} {T : NonUnitalSubsemiring R}\n  (h : ‚àÄ (x : R), (x ‚àà S : Prop) ‚Üî (x ‚àà T : Prop)), S = T","name":"NonUnitalSubsemiring.ext","isProp":true,"docString":"Two non-unital subsemirings are equal if they have the same elements. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] [inst_4 : CharZero k] {n : ‚Ñï} (s : Affine.Simplex k P n) {fs‚ÇÅ : Finset (Fin (n + 1))}\n  {fs‚ÇÇ : Finset (Fin (n + 1))} {m‚ÇÅ : ‚Ñï} {m‚ÇÇ : ‚Ñï} (h‚ÇÅ : Finset.card fs‚ÇÅ = m‚ÇÅ + 1) (h‚ÇÇ : Finset.card fs‚ÇÇ = m‚ÇÇ + 1),\n  (Finset.centroid k Finset.univ (Affine.Simplex.points (Affine.Simplex.face s h‚ÇÅ)) =\n        Finset.centroid k Finset.univ (Affine.Simplex.points (Affine.Simplex.face s h‚ÇÇ)) :\n      Prop) ‚Üî\n    (fs‚ÇÅ = fs‚ÇÇ : Prop)","name":"Affine.Simplex.face_centroid_eq_iff","isProp":true,"docString":"Over a characteristic-zero division ring, the centroids of two\nfaces of a simplex are equal if and only if those faces are given by\nthe same subset of points. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ico (f (Order.succ n)) (f n))","name":"Antitone.pairwise_disjoint_on_Ico_succ","isProp":true,"docString":"If `Œ±` is a linear succ order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is an antitone function, then\nthe intervals `Set.Ico (f (Order.succ n)) (f n)` are pairwise disjoint. "},{"type":"‚àÄ {p : ‚Ñï} {b : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] (dvd : p ‚à£ b), padicValNat p (b / p) = padicValNat p b - 1","name":"padicValNat.div","isProp":true,"docString":"Dividing out by a prime factor reduces the `padicValNat` by `1`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {F : Type u_3}\n  [mc : AddMonoidHomClass F M N] (f : F) (hf : Function.Surjective ‚Üëf), AddMonoidHom.mrange f = ‚ä§","name":"AddMonoidHom.mrange_top_of_surjective","isProp":true,"docString":"The range of a surjective `AddMonoid` hom is the whole of the codomain."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type u} (e : Œ± ‚âÉ Œ≤), Cardinal.mk Œ± = Cardinal.mk Œ≤","name":"Equiv.cardinal_eq","isProp":true,"docString":"**Alias** of `Cardinal.mk_congr`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : (a : Œ±) ‚Üí Œ≤) (g : (a : Œ≤) ‚Üí Œ±),\n  Set.BijOn g (Function.fixedPoints (f ‚àò g)) (Function.fixedPoints (g ‚àò f))","name":"Function.bijOn_fixedPoints_comp","isProp":true,"docString":"Given two maps `f : Œ± ‚Üí Œ≤` and `g : Œ≤ ‚Üí Œ±`, `g` is a bijective map between the fixed points\nof `f ‚àò g` and the fixed points of `g ‚àò f`. The inverse map is `f`, see `invOn_fixedPoints_comp`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : PseudoMetricSpace Œ±] {f : Filter Œπ} {x‚ÇÄ : Œ±} {p : (a : Œ± √ó Œπ) ‚Üí Prop},\n  (Filter.Eventually (fun (x : Œ± √ó Œπ) ‚Ü¶ p x) (Filter.prod (nhds x‚ÇÄ) f) : Prop) ‚Üî\n    (‚àÉ (Œµ : ‚Ñù),\n        (Œµ > 0 : Prop) ‚àß\n          (‚àÉ (pa : (a : Œπ) ‚Üí Prop),\n              (Filter.Eventually (fun (i : Œπ) ‚Ü¶ pa i) f : Prop) ‚àß\n                (‚àÄ {x : Œ±} (a : dist x x‚ÇÄ < Œµ) {i : Œπ} (a : pa i), p (x, i) : Prop) :\n            Prop) :\n      Prop)","name":"Metric.eventually_nhds_prod_iff","isProp":true,"docString":"A version of `Filter.eventually_prod_iff` where the first filter consists of neighborhoods\nin a pseudo-metric space."},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : Sort v} {a‚ÇÅ : Œ±} {a‚ÇÇ : Œ±} (f : (a : Œ±) ‚Üí Œ≤) (h : a‚ÇÅ = a‚ÇÇ), f a‚ÇÅ = f a‚ÇÇ","name":"congr_arg","isProp":true,"docString":"**Alias** of `congrArg`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] (A : Finset Œ±) (B : Finset Œ±) (C : Finset Œ±),\n  Finset.card (A / C) * Finset.card B ‚â§ Finset.card (A / B) * Finset.card (B * C)","name":"Finset.card_div_mul_le_card_div_mul_card_mul","isProp":true,"docString":"**Ruzsa's triangle inequality**. Sub-sub-add version. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] [inst_2 : FaithfulSMul Œ± Œ≤],\n  Function.Injective MulAction.toPerm","name":"MulAction.toPerm_injective","isProp":true,"docString":"`MulAction.toPerm` is injective on faithful actions. "},{"type":"‚àÄ (R : Type u) [inst : Ring R] [inst_1 : StrongRankCondition R] (m : Type v) (n : Type w) [inst_2 : Finite m]\n  [inst_3 : Finite n], Module.rank R (Matrix m n R) = Cardinal.lift (Cardinal.mk m) * Cardinal.lift (Cardinal.mk n)","name":"rank_matrix","isProp":true,"docString":"If `m` and `n` are `Fintype`, the rank of `m √ó n` matrices is `(# m).lift * (# n).lift`. "},{"type":"‚àÄ {Œ± : Type u} [inst : CommGroup Œ±], IsGroupHom Inv.inv","name":"Inv.isGroupHom","isProp":true,"docString":"Inversion is a group homomorphism if the group is commutative. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\n  FiniteDimensional.finrank K (V ‚ß∏ s) + FiniteDimensional.finrank K { x : V // x ‚àà s } = FiniteDimensional.finrank K V","name":"Submodule.finrank_quotient_add_finrank","isProp":true,"docString":"In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. "},{"type":"‚àÄ (k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [inst : Semiring k] [inst_1 : Mul G] {A : Type u‚ÇÉ} [inst_2 : NonUnitalNonAssocSemiring A]\n  [inst_3 : DistribMulAction k A] {œÜ‚ÇÅ : MonoidAlgebra k G ‚Üí‚Çô‚Çê[k] A} {œÜ‚ÇÇ : MonoidAlgebra k G ‚Üí‚Çô‚Çê[k] A}\n  (h : ‚àÄ (x : G), ‚ÜëœÜ‚ÇÅ (MonoidAlgebra.single x 1) = ‚ÜëœÜ‚ÇÇ (MonoidAlgebra.single x 1)), œÜ‚ÇÅ = œÜ‚ÇÇ","name":"MonoidAlgebra.nonUnitalAlgHom_ext","isProp":true,"docString":"A non_unital `k`-algebra homomorphism from `MonoidAlgebra k G` is uniquely defined by its\nvalues on the functions `single a 1`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofiltered C] {D : Type u‚ÇÅ}\n  [inst_2 : CategoryTheory.Category D] (h : C ‚âå D), CategoryTheory.IsCofiltered D","name":"CategoryTheory.IsCofiltered.of_equivalence","isProp":true,"docString":"Being cofiltered is preserved by equivalence of categories. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V] {Œπ : Type u_1}\n  {p : (a : Œπ) ‚Üí V},\n  (AffineIndependent k p : Prop) ‚Üî\n    (‚àÄ (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (a : Finset.sum s w = 0) (a : (Finset.sum s fun (e : Œπ) ‚Ü¶ w e ‚Ä¢ p e) = 0)\n        (e : Œπ) (a : e ‚àà s), w e = 0 :\n      Prop)","name":"affineIndependent_iff","isProp":true,"docString":"Viewing a module as an affine space modelled on itself, we can characterise affine independence\nin terms of linear combinations. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  (S : Subalgebra R A), ‚ÜëSubalgebra.toSubmodule S * ‚ÜëSubalgebra.toSubmodule S = ‚ÜëSubalgebra.toSubmodule S","name":"Subalgebra.mul_self","isProp":true,"docString":"As submodules, subalgebras are idempotent. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} {f : M ‚Üí* P}\n  (H : c ‚â§ Con.ker f) (x : M), ‚Üë(Con.lift c f H) (‚Üë(Con.mk' c) x) = ‚Üëf x","name":"Con.lift_mk'","isProp":true,"docString":"The diagram describing the universal property for quotients of monoids commutes. "},{"type":"‚àÄ (a : ‚Ñù), Cardinal.mk ‚Üë(Set.Ici a) = Cardinal.continuum","name":"Cardinal.mk_Ici_real","isProp":true,"docString":"The cardinality of the interval [a, ‚àû). "},{"type":"‚àÄ {Œ± : Type u_1} [self : GeneralizedHeytingAlgebra Œ±] (a : Œ±) (b : Œ±) (c : Œ±), (a ‚â§ b ‚á® c : Prop) ‚Üî (a ‚äì b ‚â§ c : Prop)","name":"GeneralizedHeytingAlgebra.le_himp_iff","isProp":true,"docString":"`a ‚á®` is right adjoint to `a ‚äì` "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasColimits C]\n  [inst_2 : CategoryTheory.WellPowered C·µí·µñ] {ùí¢ : Set C} [inst_3 : Small ‚Üëùí¢] (hùí¢ : CategoryTheory.IsSeparating ùí¢),\n  CategoryTheory.Limits.HasLimits C","name":"CategoryTheory.Limits.hasLimits_of_hasColimits_of_isSeparating","isProp":true,"docString":"A consequence of the special adjoint functor theorem: if `C` is cocomplete, well-copowered and\nhas a small separating set, then it is complete. "},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] {s : Set Œ±} {Œπ : Sort u_1} {c : (a : Œπ) ‚Üí Set Œ±} (hs : IsCompact s)\n  (hc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i)) (hc‚ÇÇ : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ c i),\n  ‚àÉ (n : Set (Œ± √ó Œ±)),\n    (n ‚àà uniformity Œ± : Prop) ‚àß (‚àÄ (x : Œ±) (a : x ‚àà s), ‚àÉ (i : Œπ), (setOf fun (y : Œ±) ‚Ü¶ (x, y) ‚àà n) ‚äÜ c i : Prop)","name":"lebesgue_number_lemma","isProp":true,"docString":"Let `c : Œπ ‚Üí Set Œ±` be an open cover of a compact set `s`. Then there exists an entourage\n`n` such that for each `x ‚àà s` its `n`-neighborhood is contained in some `c i`. "},{"type":"‚àÄ {Œ± : Type u} [inst : MetricSpace Œ±] [inst_1 : ProperSpace Œ±] {s : Set Œ±} (hs : IsClosed s) {R : (a : Œ±) ‚Üí ‚Ñù}\n  (hR : ‚àÄ (x : Œ±) (a : x ‚àà s), 0 < R x),\n  ‚àÉ (Œπ : Type u),\n    ‚àÉ (c : (a : Œπ) ‚Üí Œ±),\n      ‚àÉ (r : (a : Œπ) ‚Üí ‚Ñù),\n        ‚àÉ (r' : (a : Œπ) ‚Üí ‚Ñù),\n          (‚àÄ (i : Œπ),\n                (c i ‚àà s : Prop) ‚àß ((0 < r i : Prop) ‚àß ((r i < r' i : Prop) ‚àß (r' i < R (c i) : Prop) : Prop) : Prop) :\n              Prop) ‚àß\n            ((LocallyFinite fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r' i) : Prop) ‚àß\n                (s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Metric.ball (c i) (r i) : Prop) :\n              Prop)","name":"exists_locallyFinite_subset_union·µ¢_ball_radius_lt","isProp":true,"docString":"Let `R : Œ± ‚Üí ‚Ñù` be a (possibly discontinuous) function on a proper metric space.\nLet `s` be a closed set in `Œ±` such that `R` is positive on `s`. Then there exists a collection of\npairs of balls `Metric.ball (c i) (r i)`, `Metric.ball (c i) (r' i)` such that\n\n* all centers belong to `s`;\n* for all `i` we have `0 < r i < r' i < R (c i)`;\n* the family of balls `Metric.ball (c i) (r' i)` is locally finite;\n* the balls `Metric.ball (c i) (r i)` cover `s`.\n\nThis is a simple corollary of `refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set`\nand `exists_subset_union·µ¢_ball_radius_pos_lt`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.IsFiltered C], Nonempty C","name":"CategoryTheory.IsFiltered.Nonempty","isProp":true,"docString":"a filtered category must be non empty "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (a_1 : Disjoint a a), a = ‚ä•","name":"Disjoint.eq_bot_of_self","isProp":true,"docString":"**Alias** of the forward direction of `disjoint_self`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 1) (hb : b ‚â§ 1), a * b < 1","name":"Left.mul_lt_one_of_lt_of_le","isProp":true,"docString":"Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one_of_lt_of_le`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ‚Ñ§] [inst_3 : CategoryTheory.Preadditive C]\n  [inst_4 : ‚àÄ (n : ‚Ñ§), CategoryTheory.Functor.Additive (CategoryTheory.shiftFunctor C n)]\n  [hC : CategoryTheory.Pretriangulated C] (T : CategoryTheory.Pretriangulated.Triangle C)\n  (H : T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles),\n  CategoryTheory.Pretriangulated.Triangle.invRotate T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles","name":"CategoryTheory.Pretriangulated.inv_rot_of_dist_triangle","isProp":true,"docString":"Given any distinguished triangle `T`, then we know `T.inv_rotate` is also distinguished.\n"},{"type":"‚àÄ {R : Type u} {M : Type v} {Œπ : Type x} [inst : Semiring R] {œÜ : (a : Œπ) ‚Üí Type i}\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (œÜ i)] [inst_2 : (i : Œπ) ‚Üí Module R (œÜ i)] [inst_3 : Finite Œπ]\n  [inst_4 : DecidableEq Œπ] [inst_5 : AddCommMonoid M] [inst_6 : Module R M] {f : ((i : Œπ) ‚Üí œÜ i) ‚Üí‚Çó[R] M}\n  {g : ((i : Œπ) ‚Üí œÜ i) ‚Üí‚Çó[R] M}\n  (h : ‚àÄ (i : Œπ), LinearMap.comp f (LinearMap.single i) = LinearMap.comp g (LinearMap.single i)), f = g","name":"LinearMap.pi_ext'","isProp":true,"docString":"This is used as the ext lemma instead of `LinearMap.pi_ext` for reasons explained in\nnote [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±] (H : FreeGroup.Red L‚ÇÅ L‚ÇÇ),\n  FreeGroup.reduce L‚ÇÅ = FreeGroup.reduce L‚ÇÇ","name":"FreeGroup.red.reduce_eq","isProp":true,"docString":"**Alias** of `FreeGroup.reduce.eq_of_red`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : Set.Nonempty s) (ht : Set.Nonempty t),\n  EMetric.hausdorffEdist s t ‚â§ EMetric.diam (s ‚à™ t)","name":"EMetric.hausdorffEdist_le_ediam","isProp":true,"docString":"The Hausdorff distance is controlled by the diameter of the union "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : ConnectedSpace Œ±], Nonempty Œ±","name":"ConnectedSpace.toNonempty","isProp":true,"docString":"A connected space is nonempty. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] {s : Finset Œ±} {f : (a : Œ±) ‚Üí Œ≤} {a : Œ±}\n  (hp : (Finset.sum s fun (x : Œ±) ‚Ü¶ f x) = 0) (h1 : ‚àÄ (x : Œ±) (a_1 : x ‚àà s) (a : x ‚â† a), f x = 0) (x : Œ±) (a : x ‚àà s),\n  f x = 0","name":"Finset.eq_zero_of_sum_eq_zero","isProp":true,"docString":"If a sum is 0 and the function is 0 except possibly at one\npoint, it is 0 everywhere on the `Finset`."},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±], UniformEmbedding TopologicalSpace.NonemptyCompacts.toCloseds","name":"EMetric.NonemptyCompacts.ToCloseds.uniformEmbedding","isProp":true,"docString":"`NonemptyCompacts.toCloseds` is a uniform embedding (as it is an isometry) "},{"type":"‚àÄ {M : Type u_2} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_3} [inst_1 : CommMonoid N] {P : Type u_1}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëg ‚Üëy)) (z : N),\n  ‚Üëg ‚Üë(Prod.snd (Submonoid.LocalizationMap.sec f z)) * ‚Üë(Submonoid.LocalizationMap.lift f hg) z =\n    ‚Üëg (Prod.fst (Submonoid.LocalizationMap.sec f z))","name":"Submonoid.LocalizationMap.lift_mul_left","isProp":true,"docString":"Given a Localization map `f : M ‚Üí* N` for a Submonoid `S ‚äÜ M`, if a `CommMonoid` map\n`g : M ‚Üí* P` induces a map `f.lift hg : N ‚Üí* P` then for all `z : N`, we have\n`g y * f.lift hg z = g x`, where `x : M, y ‚àà S` are such that `z * f y = f x`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedCommGroup E], UniformGroup E","name":"SeminormedCommGroup.to_uniformGroup","isProp":true,"docString":"A seminormed group is a uniform group, i.e., multiplication and division are uniformly\ncontinuous. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (S : Set (Con M)), ‚Üë(inf‚Çõ S) = inf‚Çõ (FunLike.coe '' S)","name":"Con.inf‚Çõ_def","isProp":true,"docString":"The infimum of a set of congruence relations is the same as the infimum of the set's image\nunder the map to the underlying binary relation. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)) < Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (¬¨(MonovaryOn f (g ‚àò ‚ÜëœÉ) ‚Üës : Prop) : Prop)","name":"MonovaryOn.sum_smul_comp_perm_lt_sum_smul_iff","isProp":true,"docString":"**Strict inequality case of Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which monovary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ≤} {g : (a : Œ≤) ‚Üí Œ±}\n  (hg : Set.InjOn g (s ‚à© Function.support (f ‚àò g))),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà g '' s) ‚Ü¶ f i) = finsum fun (j : Œ≤) ‚Ü¶ finsum fun (h : j ‚àà s) ‚Ü¶ f (g j)","name":"finsum_mem_image'","isProp":true,"docString":"The sum of `f y` over `y ‚àà g '' s` equals the sum of `f (g i)` over `s` provided that\n`g` is injective on `s ‚à© support (f ‚àò g)`."},{"type":"‚àÄ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsProper I], ‚ÜëI ‚â† Set.univ","name":"Order.Ideal.IsProper.ne_univ","isProp":true,"docString":"This ideal is not the whole set. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} (a : Equiv.Perm.SameCycle f x y), Equiv.Perm.SameCycle f (‚Üëf‚Åª¬π x) y","name":"Equiv.Perm.SameCycle.inv_apply_left","isProp":true,"docString":"**Alias** of the reverse direction of `Equiv.Perm.sameCycle_inv_apply_left`."},{"type":"‚àÄ {Œπ : Type u_3} {M : Type u_2} {N : Type u_1} [inst : CommMonoid M] [inst_1 : OrderedCommMonoid N] (f : (a : M) ‚Üí N)\n  (p : (a : M) ‚Üí Prop) (h_mul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), f (x * y) ‚â§ f x * f y)\n  (hp_mul : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x * y)) (g : (a : Œπ) ‚Üí M) (s : Finset Œπ)\n  (hs_nonempty : Finset.Nonempty s) (hs : ‚àÄ (i : Œπ) (a : i ‚àà s), p (g i)),\n  f (Finset.prod s fun (i : Œπ) ‚Ü¶ g i) ‚â§ Finset.prod s fun (i : Œπ) ‚Ü¶ f (g i)","name":"Finset.le_prod_nonempty_of_submultiplicative_on_pred","isProp":true,"docString":"Let `{x | p x}` be a subsemigroup of a commutative monoid `M`. Let `f : M ‚Üí N` be a map\nsubmultiplicative on `{x | p x}`, i.e., `p x ‚Üí p y ‚Üí f (x * y) ‚â§ f x * f y`. Let `g i`, `i ‚àà s`, be\na nonempty finite family of elements of `M` such that `‚àÄ i ‚àà s, p (g i)`. Then\n`f (‚àè x in s, g x) ‚â§ ‚àè x in s, f (g x)`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n  (h : ‚àÄ (c : Set Œ±) (a : IsChain r c), ‚àÉ (ub : Œ±), ‚àÄ (a : Œ±) (a_1 : a ‚àà c), r a ub)\n  (trans : ‚àÄ {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : r a b) (a_2 : r b c), r a c), ‚àÉ (m : Œ±), ‚àÄ (a : Œ±) (a_1 : r m a), r a m","name":"exists_maximal_of_chains_bounded","isProp":true,"docString":"**Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. "},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  [inst_1 : CategoryTheory.Limits.HasPullback f f],\n  CategoryTheory.IsKernelPair f CategoryTheory.Limits.pullback.fst CategoryTheory.Limits.pullback.snd","name":"CategoryTheory.Limits.pullback.diagonal_isKernelPair","isProp":true,"docString":"The two projections `Œî_{X/Y} ‚ü∂ X` form a kernel pair for `f : X ‚ü∂ Y`. "},{"type":"‚àÄ {Œ± : Type u} [self : NonAssocSemiring Œ±] (a : Œ±), 1 * a = a","name":"NonAssocSemiring.one_mul","isProp":true,"docString":"One is a left neutral element for multiplication "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} {A : outParam (Set Œ±)} {Œ≤ : outParam (Type u_3)} [inst : CommMonoid Œ±]\n  [inst_1 : CommMonoid Œ≤] {n : ‚Ñï} [inst_2 : FunLike F Œ± fun (x : Œ±) ‚Ü¶ Œ≤] [self : FreimanHomClass F A Œ≤ n] (f : F)\n  {s : Multiset Œ±} {t : Multiset Œ±} (hsA : ‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà s), x ‚àà A) (htA : ‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : x ‚àà t), x ‚àà A)\n  (hs : ‚ÜëMultiset.card s = n) (ht : ‚ÜëMultiset.card t = n) (h : Multiset.prod s = Multiset.prod t),\n  Multiset.prod (Multiset.map (‚Üëf) s) = Multiset.prod (Multiset.map (‚Üëf) t)","name":"FreimanHomClass.map_prod_eq_map_prod'","isProp":true,"docString":"A `n`-Freiman homomorphism preserves products of `n` elements. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_1) (P : Type u_3) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], AffineSubspace.direction ‚ä§ = ‚ä§","name":"AffineSubspace.direction_top","isProp":true,"docString":"The direction of `‚ä§` is the whole module as a submodule. "},{"type":"‚àÄ {x : EReal} {y : EReal} {z : EReal} {t : EReal} (h : x < y) (h' : z ‚â§ t) (hz : z ‚â† ‚ä•) (ht : t ‚â† ‚ä§), x + z < y + t","name":"EReal.add_lt_add_of_lt_of_le","isProp":true,"docString":"See also `EReal.add_lt_add_of_lt_of_le'` for a version with weaker but less convenient\nassumptions. "},{"type":"‚àÄ {G : Type u_2} [inst : Group G] {N : Type u_1} [inst_1 : Group N] (f : G ‚Üí* N) (hf : Function.Surjective ‚Üëf),\n  MonoidHom.range f = ‚ä§","name":"MonoidHom.range_top_of_surjective","isProp":true,"docString":"The range of a surjective monoid homomorphism is the whole of the codomain. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] (X : C) [inst_3 : CategoryTheory.Simple X],\n  CategoryTheory.Indecomposable X","name":"CategoryTheory.indecomposable_of_simple","isProp":true,"docString":"Any simple object in a preadditive category is indecomposable. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} {l' : List Œ±} (h : l = l') (i : Fin (List.length l)),\n  List.get l i =\n    List.get l'\n      { val := ‚Üëi,\n        isLt :=\n          ((Eq.rec ((Fin.isLt i=:‚Üëi < List.length l)=:‚Üëi < List.length l)\n                h=:‚Üëi < List.length l')=:‚Üëi < List.length l') }","name":"List.get_of_eq","isProp":true,"docString":"If one has `get l i hi` in a formula and `h : l = l'`, one can not `rw h` in the formula as\n`hi` gives `i < l.length` and not `i < l'.length`. The theorem `get_of_eq` can be used to make\nsuch a rewrite, with `rw (get_of_eq h)`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedMonoid Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"CanonicallyLinearOrderedMonoid.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ (p : Prop), (p : Prop) ‚à® (¬¨(p : Prop) : Prop)","name":"Classical.em","isProp":true,"docString":"Diaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (g : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasKernel (f - g)], CategoryTheory.Limits.HasEqualizer f g","name":"CategoryTheory.Preadditive.hasEqualizer_of_hasKernel","isProp":true,"docString":"A preadditive category has an equalizer for `f` and `g` if it has a kernel for `f - g`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {f : AddHom M N} {g : AddHom M N},\n  (f = g : Prop) ‚Üî (‚àÄ (x : M), ‚Üëf x = ‚Üëg x : Prop)","name":"AddHom.ext_iff","isProp":true,"docString":"Deprecated: use `FunLike.ext_iff` instead."},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : AddMonoid Œπ] [inst_1 : Monoid R] {S : Type u_3} [inst_2 : SetLike S R]\n  (A : (a : Œπ) ‚Üí S) [inst_3 : SetLike.GradedMonoid A], SetLike.GradedSmul A A","name":"SetLike.GradedMul.toGradedSmul","isProp":true,"docString":"Internally graded version of `Mul.toSMul`. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : CommMonoid Œ≤] (f : (a : ‚Ñï) ‚Üí Œ≤)\n  (h_mult : ‚àÄ (x : ‚Ñï) (y : ‚Ñï) (a : Nat.coprime x y), f (x * y) = f x * f y) (hf : f 1 = 1) {n : ‚Ñï} (a : n ‚â† 0),\n  f n = Finsupp.prod (Nat.factorization n) fun (p : ‚Ñï) (k : ‚Ñï) ‚Ü¶ f (p ^ k)","name":"Nat.multiplicative_factorization","isProp":true,"docString":"For any multiplicative function `f` with `f 1 = 1` and any `n ‚â† 0`,\nwe can evaluate `f n` by evaluating `f` at `p ^ k` over the factorization of `n` "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤]\n  [inst_2 : AddZeroClass Œ±] [inst_3 : AddZeroClass Œ≤] [self : OrderAddMonoidHomClass F Œ± Œ≤] (f : F), Monotone ‚Üëf","name":"OrderAddMonoidHomClass.monotone","isProp":true,"docString":"An `OrderAddMonoidHom` is a monotone function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : PredOrder Œ±] {a : Œ±} {b : Œ±} [inst_2 : NoMinOrder Œ±] (a_1 : a ‚â† b),\n  Order.pred a ‚â† Order.pred b","name":"Order.pred_ne_pred","isProp":true,"docString":"**Alias** of the reverse direction of `Order.pred_ne_pred_iff`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {X : C} {Y : C} (f : X ‚ü∂ Y),\n  CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)","name":"CategoryTheory.Abelian.instIsIsoCoimagePreadditiveHasZeroMorphismsToPreadditiveHas_kernelsHas_cokernelsImageCoimageImageComparison","isProp":true,"docString":"The coimage-image comparison morphism is always an isomorphism in an abelian category.\nSee `CategoryTheory.Abelian.ofCoimageImageComparisonIsIso` for the converse.\n"},{"type":"‚àÄ {Œ± : Type v} {s : Finset Œ±} {M : Type u_1} [inst : AddCommMonoid M] (f : (a : Œ±) ‚Üí M) (p : (a : M) ‚Üí Prop)\n  (hom : ‚àÄ (a : M) (b : M) (a_1 : p a) (a_2 : p b), p (a + b)) (unit : p 0) (base : ‚àÄ (x : Œ±) (a : x ‚àà s), p (f x)),\n  p (Finset.sum s fun (x : Œ±) ‚Ü¶ f x)","name":"Finset.sum_induction","isProp":true,"docString":"To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands."},{"type":"‚àÄ {n : ‚Ñï} {l : Multiset ‚Ñï} (hl : Multiset.sum l = n) {i : ‚Ñï} (hi : i ‚â† 0),\n  Multiset.count i (Nat.Partition.parts (Nat.Partition.ofSums n l hl)) = Multiset.count i l","name":"Nat.Partition.count_ofSums_of_ne_zero","isProp":true,"docString":"The number of times a positive integer `i` appears in the partition `ofSums n l hl` is the same\nas the number of times it appears in the multiset `l`.\n(For `i = 0`, `Partition.non_zero` combined with `Multiset.count_eq_zero_of_not_mem` gives that\nthis is `0` instead.)\n"},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (a‚Åª¬π ‚â§ 1 : Prop) ‚Üî (1 ‚â§ a : Prop)","name":"inv_le_one'","isProp":true,"docString":"**Alias** of `Left.inv_le_one_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤]\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (hf : Monotone f) (hg : StrictMono g), StrictMono fun (x : Œ≤) ‚Ü¶ f x * g x","name":"Monotone.mul_strictMono'","isProp":true,"docString":"The product of a monotone function and a strictly monotone function is strictly monotone. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] (e : LocalHomeomorph Œ± Œ≤) {f : (a : Œ≥) ‚Üí Œ±} {x : Œ≥}\n  (h : f ‚Åª¬π' LocalEquiv.source (LocalHomeomorph.toLocalEquiv e) ‚àà nhds x),\n  (ContinuousAt f x : Prop) ‚Üî (ContinuousAt (‚Üëe ‚àò f) x : Prop)","name":"LocalHomeomorph.continuousAt_iff_continuousAt_comp_left","isProp":true,"docString":"Continuity at a point can be read under left composition with a local homeomorphism if a\nneighborhood of the initial point is sent to the source of the local homeomorphism"},{"type":"‚àÄ {R : Type u} {œÉ : Type u_2} [inst : CommSemiring R] {Œπ : Type u_1} {s : Finset Œπ} (f : (a : Œπ) ‚Üí MvPolynomial œÉ R),\n  MvPolynomial.vars (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) ‚äÜ Finset.bunion·µ¢ s fun (i : Œπ) ‚Ü¶ MvPolynomial.vars (f i)","name":"MvPolynomial.vars_prod","isProp":true,"docString":"The variables of the product of a family of polynomials\nare a subset of the union of the sets of variables of each polynomial.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±], Monotone Finset.shadow","name":"Finset.shadow_monotone","isProp":true,"docString":"The shadow is monotone. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (self : NonarchAddGroupNorm G) (x : G)\n  (a : ZeroHom.toFun (NonarchAddGroupSeminorm.toZeroHom (NonarchAddGroupNorm.toNonarchAddGroupSeminorm self)) x = 0),\n  x = 0","name":"NonarchAddGroupNorm.eq_zero_of_map_eq_zero'","isProp":true,"docString":"If the image under the norm is zero, then the argument is zero. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  (K : TopologicalSpace.PositiveCompacts G), LocallyCompactSpace G","name":"TopologicalSpace.PositiveCompacts.locallyCompactSpace_of_Group","isProp":true,"docString":"Every separated topological group in which there exists a compact set with nonempty interior\nis locally compact. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : SemilatticeSup Œ≥] {s : Set Œ≥} {t : Set Œ≥} (a : BddAbove s) (a : BddAbove t), BddAbove (s ‚à™ t)","name":"BddAbove.union","isProp":true,"docString":"If `s` and `t` are bounded above sets in a `semilattice_sup`, then so is `s ‚à™ t`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : Semifield Œ±] (n : ‚Ñï) (a : Œ±),\n  Semifield.zpow (Int.negSucc n) a = (Semifield.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"Semifield.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (habc : a ‚à£ b * c) (hab : Int.gcd a b = 1), a ‚à£ c","name":"Int.dvd_of_dvd_mul_right_of_gcd_one","isProp":true,"docString":"Euclid's lemma: if `a ‚à£ b * c` and `gcd a b = 1` then `a ‚à£ c`.\nCompare with `IsCoprime.dvd_of_dvd_mul_right` and\n`UniqueFactorizationMonoid.dvd_of_dvd_mul_right_of_no_prime_factors` "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : ConditionallyCompleteLattice Œ±] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  (B : BddBelow (Set.range f)) (H : ‚àÄ (x : Œπ), f x ‚â§ g x), inf·µ¢ f ‚â§ inf·µ¢ g","name":"cinf·µ¢_mono","isProp":true,"docString":"The indexed infimum of two functions are comparable if the functions are pointwise comparable"},{"type":"‚àÄ {M : Type u_1} {Œ± : Sort u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} (p : (a : M) ‚Üí Prop) (hp‚ÇÄ : p 0)\n  (hp‚ÇÅ : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x + y)) (hp‚ÇÇ : ‚àÄ (i : Œ±), p (f i)), p (finsum fun (i : Œ±) ‚Ü¶ f i)","name":"finsum_induction","isProp":true,"docString":"To prove a property of a finite sum, it suffices to prove that the property is\nadditive and holds on the summands."},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚â§ b), a ‚äî b = b","name":"sup_of_le_right","isProp":true,"docString":"**Alias** of the reverse direction of `sup_eq_right`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (hf : MonotoneOn f s) (hg : MonotoneOn g s), MonotoneOn (fun (x : Œ±) ‚Ü¶ min (f x) (g x)) s","name":"MonotoneOn.min","isProp":true,"docString":"Pointwise minimum of two monotone functions is a monotone function. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {R : D ‚•§ C} (h : L ‚ä£ R) [inst_2 : CategoryTheory.Full L] [inst_3 : CategoryTheory.Faithful L],\n  CategoryTheory.IsIso (CategoryTheory.Adjunction.unit h)","name":"CategoryTheory.unit_isIso_of_L_fully_faithful","isProp":true,"docString":"If the left adjoint is fully faithful, then the unit is an isomorphism.\n\nSee\n* Lemma 4.5.13 from [Riehl][riehl2017]\n* https://math.stackexchange.com/a/2727177\n* https://stacks.math.columbia.edu/tag/07RB (we only prove the forward direction!)\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±} {t : Set Œ±},\n  EMetric.infEdist x t ‚â§ EMetric.infEdist x s + EMetric.hausdorffEdist s t","name":"EMetric.infEdist_le_infEdist_add_hausdorffEdist","isProp":true,"docString":"The distance from `x` to `s` or `t` is controlled in terms of the Hausdorff distance\nbetween `s` and `t` "},{"type":"‚àÄ {Œ± : Type u_1} (self : Filter Œ±) {x : Set Œ±} {y : Set Œ±} (a : x ‚àà Filter.sets self) (a : y ‚àà Filter.sets self),\n  x ‚à© y ‚àà Filter.sets self","name":"Filter.inter_sets","isProp":true,"docString":"If two sets belong to a filter, then their intersection belongs to the filter as well. "},{"type":"‚àÄ {V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [inst : NormedAddCommGroup V‚ÇÅ] [inst_1 : NormedAddCommGroup V‚ÇÇ]\n  {f : NormedAddGroupHom V‚ÇÅ V‚ÇÇ}, (‚Äñf‚Äñ = 0 : Prop) ‚Üî (f = 0 : Prop)","name":"NormedAddGroupHom.opNorm_zero_iff","isProp":true,"docString":"For normed groups, an operator is zero iff its norm vanishes. "},{"type":"‚àÄ {Œ± : Type u} [inst : EMetricSpace Œ±] {s : TopologicalSpace.Closeds Œ±} {t : TopologicalSpace.Closeds Œ±},\n  edist s t = EMetric.hausdorffEdist ‚Üës ‚Üët","name":"EMetric.Closeds.edist_eq","isProp":true,"docString":"By definition, the edistance on `Closeds Œ±` is given by the Hausdorff edistance "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (Cf : ContinuousAt f (sup‚Çõ s)) (Mf : Monotone f) (hs : Set.Nonempty s), f (sup‚Çõ s) = sup‚Çõ (f '' s)","name":"Monotone.map_sup‚Çõ_of_continuousAt'","isProp":true,"docString":"A monotone function continuous at the supremum of a nonempty set sends this supremum to\nthe supremum of the image of this set. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Antivary f g),\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) ‚â§ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)","name":"Antivary.sum_smul_le_sum_smul_comp_perm","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when\n`f` and `g` antivary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {M : Type u_2} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_3} [inst_1 : AddCommMonoid N] {P : Type u_1}\n  [inst_2 : AddCommMonoid P] (f : AddSubmonoid.LocalizationMap S N) {g : M ‚Üí+ P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsAddUnit (‚Üëg ‚Üëy)) (z : N),\n  ‚Üëg ‚Üë(Prod.snd (AddSubmonoid.LocalizationMap.sec f z)) + ‚Üë(AddSubmonoid.LocalizationMap.lift f hg) z =\n    ‚Üëg (Prod.fst (AddSubmonoid.LocalizationMap.sec f z))","name":"AddSubmonoid.LocalizationMap.lift_add_left","isProp":true,"docString":"Given a Localization map `f : M ‚Üí+ N` for a Submonoid `S ‚äÜ M`, if an `AddCommMonoid` map\n`g : M ‚Üí+ P` induces a map `f.lift hg : N ‚Üí+ P` then for all `z : N`, we have\n`g y + f.lift hg z = g x`, where `x : M, y ‚àà S` are such that `z + f y = f x`."},{"type":"‚àÄ {R : Type u_2} [inst : CommRing R] (M : Submonoid R) {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsLocalization M S] (s : Finset S),\n  ‚àÉ (b : { x : R // x ‚àà M }), ‚àÄ (a : S) (a_1 : a ‚àà s), IsLocalization.IsInteger R (‚Üëb ‚Ä¢ a)","name":"IsLocalization.exist_integer_multiples_of_finset","isProp":true,"docString":"We can clear the denominators of a finite set of fractions. "},{"type":"‚àÄ {n : Type v} {Œ± : Type w} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  [inst_3 : Nontrivial n], Matrix.adjugate (Matrix.adjugate A) = Matrix.det A ^ (Fintype.card n - 2) ‚Ä¢ A","name":"Matrix.adjugate_adjugate'","isProp":true,"docString":"A weaker version of `Matrix.adjugate_adjugate` that uses `Nontrivial`. "},{"type":"‚àÄ {ùìï : Type u_1} {E : Type u_2} {F : Type u_3} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F]\n  [inst_2 : MonoidHomClass ùìï E F] (f : ùìï) (C : ‚Ñù) (h : ‚àÄ (x : E), ‚Äñ‚Üëf x‚Äñ ‚â§ C * ‚Äñx‚Äñ), LipschitzWith (Real.toNNReal C) ‚Üëf","name":"MonoidHomClass.lipschitz_of_bound","isProp":true,"docString":"A homomorphism `f` of seminormed groups is Lipschitz, if there exists a constant `C` such that\nfor all `x`, one has `‚Äñf x‚Äñ ‚â§ C * ‚Äñx‚Äñ`. The analogous condition for a linear map of\n(semi)normed spaces is in `normed_space.operator_norm`. "},{"type":"‚àÄ {M‚ÇÄ : Type u} [self : MulZeroOneClass M‚ÇÄ] (a : M‚ÇÄ), 0 * a = 0","name":"MulZeroOneClass.zero_mul","isProp":true,"docString":"Zero is a left absorbing element for multiplication "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : Nonempty Œ±] [inst : NoMinOrder Œ±], Infinite Œ±","name":"NoMinOrder.infinite","isProp":true,"docString":"A nonempty preorder with no minimal element is infinite. This is not an instance to avoid\na cycle with `Infinite Œ± ‚Üí Nontrivial Œ± ‚Üí Nonempty Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalCommRing Œ±] {b : Œ±} {c : Œ±} {x : Œ±} (h : x * x - b * x + c = 0),\n  ‚àÉ (y : Œ±), (y * y - b * y + c = 0 : Prop) ‚àß ((x + y = b : Prop) ‚àß (x * y = c : Prop) : Prop)","name":"vieta_formula_quadratic","isProp":true,"docString":"Vieta's formula for a quadratic equation, relating the coefficients of the polynomial with\nits roots. This particular version states that if we have a root `x` of a monic quadratic\npolynomial, then there is another root `y` such that `x + y` is negative the `a_1` coefficient\nand `x * y` is the `a_0` coefficient. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Mul Œ≤] [inst_1 : SMul Œ± Œ≤] [inst_2 : IsScalarTower Œ± Œ≤ Œ≤] (r : Œ±) (x : Œ≤)\n  (y : Œ≤), r ‚Ä¢ x * y = r ‚Ä¢ (x * y)","name":"smul_mul_assoc","isProp":true,"docString":"Note that the `IsScalarTower Œ± Œ≤ Œ≤` typeclass argument is usually satisfied by `Algebra Œ± Œ≤`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {x : Œ±}, Metric.Bounded {x}","name":"Metric.bounded_singleton","isProp":true,"docString":"A singleton is bounded "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} (h : TotallyBounded s), Metric.Bounded s","name":"TotallyBounded.bounded","isProp":true,"docString":"A totally bounded set is bounded "},{"type":"‚àÄ {n : ‚Ñï} {p : ‚Ñï} (hp : Nat.Prime p), multiplicity p (Nat.factorial (p * n)) = multiplicity p (Nat.factorial n) + ‚Üën","name":"Nat.Prime.multiplicity_factorial_mul","isProp":true,"docString":"The multiplicity of `p` in `(p * n)!` is `n` more than that of `n!`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤} {m : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤}\n  {p : (a : Œ±) ‚Üí Prop} {x : DecidablePred p} (hp : MeasurableSet (setOf fun (a : Œ±) ‚Ü¶ p a)) (hf : Measurable f)\n  (hg : Measurable g), Measurable fun (x_1 : Œ±) ‚Ü¶ if (p x_1 : Prop) then f x_1 else g x_1","name":"Measurable.ite","isProp":true,"docString":"This is slightly different from `Measurable.piecewise`. It can be used to show\n`Measurable (ite (x=0) 0 1)` by\n`exact Measurable.ite (measurableSet_singleton 0) measurable_const measurable_const`,\nbut replacing `Measurable.ite` by `Measurable.piecewise` in that example proof does not work. "},{"type":"‚àÄ {n : ‚Ñï} (p : (a : Fin n) ‚Üí Prop) [inst : DecidablePred p] {i : Fin n} (x : i ‚àà Fin.find p), p i","name":"Fin.find_spec","isProp":true,"docString":"If `find p = some i`, then `p i` holds "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (s : Finset Œ±) {n : ‚Ñï} (hn : n ‚â† 0) (hs : n ‚â§ Finset.card s),\n  ‚àÉ (P : Finpartition s), (Finpartition.IsEquipartition P : Prop) ‚àß (Finset.card (Finpartition.parts P) = n : Prop)","name":"Finpartition.exists_equipartition_card_eq","isProp":true,"docString":"We can find equipartitions of arbitrary size. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Œπ : Type u_4} {M‚ÇÇ : Type u_5} [inst_5 : AddCommMonoid M‚ÇÇ]\n  [inst_6 : Module R M‚ÇÇ] (f : AlternatingMap R M N Œπ) (g : M‚ÇÇ ‚âÉ‚Çó[R] M),\n  (AlternatingMap.compLinearMap f ‚Üëg = 0 : Prop) ‚Üî (f = 0 : Prop)","name":"AlternatingMap.compLinearEquiv_eq_zero_iff","isProp":true,"docString":"Composing an alternating map with the same linear equiv on each argument gives the zero map\nif and only if the alternating map is the zero map. "},{"type":"‚àÄ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]\n  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (self : A ‚âÉ‚Çê[R] B) (x : A) (y : A),\n  Equiv.toFun (AlgEquiv.toEquiv self) (x + y) =\n    Equiv.toFun (AlgEquiv.toEquiv self) x + Equiv.toFun (AlgEquiv.toEquiv self) y","name":"AlgEquiv.map_add'","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddSemigroup Œ±] (x : Œ±) (y : Œ±),\n  ((fun (x_1 : Œ±) ‚Ü¶ x_1 + x) ‚àò fun (x : Œ±) ‚Ü¶ x + y) = fun (x_1 : Œ±) ‚Ü¶ x_1 + (y + x)","name":"comp_add_right","isProp":true,"docString":"Composing two additions on the right by `y` and `x`\nis equal to a addition on the right by `y + x`."},{"type":"‚àÄ {Œ± : Type u_1} [self : OmegaCompletePartialOrder Œ±] (c : OmegaCompletePartialOrder.Chain Œ±) (x : Œ±)\n  (a : ‚àÄ (i : ‚Ñï), ‚Üëc i ‚â§ x), OmegaCompletePartialOrder.œâSup c ‚â§ x","name":"OmegaCompletePartialOrder.œâSup_le","isProp":true,"docString":"`œâSup` is a lower bound of the set of upper bounds of the increasing sequence "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommSemiring Œ±] (E : LinearRecurrence Œ±) (u : (a : ‚Ñï) ‚Üí Œ±),\n  (LinearRecurrence.IsSolution E u : Prop) ‚Üî (u ‚àà LinearRecurrence.solSpace E : Prop)","name":"LinearRecurrence.is_sol_iff_mem_solSpace","isProp":true,"docString":"Defining property of the solution space : `u` is a solution\niff it belongs to the solution space. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} (hc : IsClosed s), IsSeqClosed s","name":"IsClosed.isSeqClosed","isProp":true,"docString":"A set is sequentially closed if it is closed. "},{"type":"‚àÄ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R} (ab : IsLeftRegular (a * b)), IsLeftRegular b","name":"IsLeftRegular.of_mul","isProp":true,"docString":"If an element `b` becomes left-regular after multiplying it on the left by a left-regular\nelement, then `b` is left-regular. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 1) (hb : b < 1), a * b < 1","name":"mul_lt_one","isProp":true,"docString":"**Alias** of `Left.mul_lt_one`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] [inst_2 : ProperSpace Œ±]\n  [inst_3 : ProperSpace Œ≤], ProperSpace (Œ± √ó Œ≤)","name":"prod_properSpace","isProp":true,"docString":"A binary product of proper spaces is proper. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {m‚ÇÅ : MeasurableSpace Œ±} {m‚ÇÇ : MeasurableSpace Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  (a : m‚ÇÇ ‚â§ MeasurableSpace.map f m‚ÇÅ), Measurable f","name":"Measurable.of_le_map","isProp":true,"docString":"**Alias** of the reverse direction of `measurable_iff_le_map`."},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b), (a = b : Prop) ‚à® (a < b : Prop)","name":"LE.le.eq_or_lt","isProp":true,"docString":"**Alias** of `eq_or_lt_of_le`."},{"type":"‚àÄ {Œ± : Type u} [inst : LT Œ±] [inst_1 : WellFoundedGT Œ±] (a : Œ±), Acc (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x > x_1) a","name":"WellFoundedGT.apply","isProp":true,"docString":"All values are accessible under the well-founded `>`. "},{"type":"‚àÄ (k : Type u_4) {V : Type u_5} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_2} {Œπ‚ÇÇ : Type u_1} (s‚ÇÇ : Finset Œπ‚ÇÇ) (e : Œπ‚ÇÇ ‚Ü™ Œπ) (p : (a : Œπ) ‚Üí P),\n  Finset.centroid k (Finset.map e s‚ÇÇ) p = Finset.centroid k s‚ÇÇ (p ‚àò ‚Üëe)","name":"Finset.centroid_map","isProp":true,"docString":"A centroid, over the image of an embedding, equals a centroid with\nthe same points and weights over the original `finset`. "},{"type":"‚àÄ {P : (Œ± : Type u_1) ‚Üí [inst : Fintype Œ±] ‚Üí Prop} (Œ± : Type u_1) [inst : Fintype Œ±]\n  (hbase : ‚àÄ (Œ± : Type u_1) [inst : Fintype Œ±] [inst_1 : Subsingleton Œ±], P Œ±)\n  (hstep :\n    ‚àÄ (Œ± : Type u_1) [inst : Fintype Œ±] [inst_1 : Nontrivial Œ±]\n      (_ih : ‚àÄ (Œ≤ : Type u_1) [inst_2 : Fintype Œ≤] (_h : Fintype.card Œ≤ < Fintype.card Œ±), P Œ≤), P Œ±),\n  P Œ±","name":"Fintype.induction_subsingleton_or_nontrivial","isProp":true,"docString":"A custom induction principle for fintypes. The base case is a subsingleton type,\nand the induction step is for non-trivial types, and one can assume the hypothesis for\nsmaller types (via `Fintype.card`).\n\nThe major premise is `Fintype Œ±`, so to use this with the `induction` tactic you have to give a name\nto that instance and use that name.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ±‚ÇÇ : Type u_3} [inst : Semiring Œ≤] [inst_1 : Add Œ±] [inst_2 : Add Œ±‚ÇÇ] {F : Type u_4}\n  [inst_3 : AddHomClass F Œ± Œ±‚ÇÇ] (f : F) (x : AddMonoidAlgebra Œ≤ Œ±) (y : AddMonoidAlgebra Œ≤ Œ±),\n  AddMonoidAlgebra.mapDomain (‚Üëf) (x * y) = AddMonoidAlgebra.mapDomain (‚Üëf) x * AddMonoidAlgebra.mapDomain (‚Üëf) y","name":"AddMonoidAlgebra.mapDomain_mul","isProp":true,"docString":"Like `Finsupp.mapDomain_add`, but for the convolutive multiplication we define in this file "},{"type":"‚àÄ {A : Type u_1} [inst : AddGroup A] {s : Set A} (self : IsAddSubgroup s) {a : A} (a_1 : a ‚àà s), -a ‚àà s","name":"IsAddSubgroup.neg_mem","isProp":true,"docString":"The proposition that `s` is closed under negation. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), AddSubmonoid.closure ‚ÜëS = S","name":"AddSubmonoid.closure_eq","isProp":true,"docString":"Additive closure of an additive submonoid `S` equals `S`"},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (L : List G), List.sum (List.reverse L) = -List.sum (List.map (fun (x : G) ‚Ü¶ -x) L)","name":"List.sum_reverse_noncomm","isProp":true,"docString":"A non-commutative variant of `List.sum_reverse`"},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G) (b : G), ‚Üëf (a * b‚Åª¬π) = ‚Üëf a * (‚Üëf b)‚Åª¬π","name":"map_mul_inv","isProp":true,"docString":"Group homomorphisms preserve division. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] {a : Œ±} {b : Œ±}, (a ‚à£ b - a : Prop) ‚Üî (a ‚à£ b : Prop)","name":"dvd_sub_self_right","isProp":true,"docString":"An element `a` divides the difference `b - a` if and only if `a` divides `b`. "},{"type":"‚àÄ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M}\n  (hU : U ‚àà nhds 1), ‚àÉ (V : Set M), (IsOpen V : Prop) ‚àß ((1 ‚àà V : Prop) ‚àß (V * V ‚äÜ U : Prop) : Prop)","name":"exists_open_nhds_one_mul_subset","isProp":true,"docString":"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV ‚äÜ U`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] {f : R ‚Üí+* S} {p : Polynomial S} (r : R)\n  (hp : p ‚àà Polynomial.lifts f), ‚ÜëPolynomial.C (‚Üëf r) * p ‚àà Polynomial.lifts f","name":"Polynomial.base_mul_mem_lifts","isProp":true,"docString":"If `p` lifts and `(r : R)` then `r * p` lifts. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (Hf : Monotone f) {s : Set Œ±}\n  (a : BddAbove s), BddAbove (f '' s)","name":"Monotone.map_bddAbove","isProp":true,"docString":"The image under a monotone function of a set which is bounded above is bounded above. See also\n`bdd_above.image2`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (Monovary f (g ‚àò ‚ÜëœÉ) : Prop)","name":"Monovary.sum_smul_comp_perm_eq_sum_smul_iff","isProp":true,"docString":"**Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f` and `g ‚àò œÉ` monovary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {R : Type u_3} {R‚ÇÇ : Type u_4} {E : Type u_2} {E‚ÇÇ : Type u_1} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R} [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [inst_3 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ]\n  [inst_4 : SeminormedAddCommGroup E] [inst_5 : SeminormedAddCommGroup E‚ÇÇ] [inst_6 : Module R E]\n  [inst_7 : Module R‚ÇÇ E‚ÇÇ], Function.Injective FunLike.coe","name":"LinearIsometryEquiv.coe_injective","isProp":true,"docString":"Helper instance for when there's too many metavariables to apply `FunLike.hasCoeToFun`\ndirectly.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {f : Filter Œ±} (h : ‚àÉ (a : Œ±), f ‚â§ nhds a), f ‚â§ nhds (lim f)","name":"le_nhds_lim","isProp":true,"docString":"If a filter `f` is majorated by some `ùìù a`, then it is majorated by `ùìù (Filter.lim f)`. We\nformulate this lemma with a `[Nonempty Œ±]` argument of `lim` derived from `h` to make it useful for\ntypes without a `[Nonempty Œ±]` instance. Because of the built-in proof irrelevance, Lean will unify\nthis instance with any other instance. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (r : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop) {s : Finset Œ±} {t : Finset Œ≤} {m : ‚Ñï} {n : ‚Ñï}\n  [inst : (a : Œ±) ‚Üí (b : Œ≤) ‚Üí Decidable (r a b : Prop)]\n  (hm : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), m ‚â§ Finset.card (Finset.bipartiteAbove r t a))\n  (hn : ‚àÄ (b : Œ≤) (a : b ‚àà t), Finset.card (Finset.bipartiteBelow r s b) ‚â§ n), Finset.card s * m ‚â§ Finset.card t * n","name":"Finset.card_mul_le_card_mul","isProp":true,"docString":"Double counting argument. Considering `r` as a bipartite graph, the LHS is a lower bound on the\nnumber of edges while the RHS is an upper bound. "},{"type":"‚àÄ {ùïú : Type u_1} {M : Type u_2} [inst : DivisionRing ùïú] [inst_1 : AddCommMonoid M] [inst_2 : TopologicalSpace M]\n  [inst_3 : T1Space M] [inst_4 : Module ùïú M] [inst_5 : ContinuousConstSMul ùïú M] (c : ùïú), IsClosedMap fun (x : M) ‚Ü¶ c ‚Ä¢ x","name":"isClosedMap_smul‚ÇÄ","isProp":true,"docString":"`smul` is a closed map in the second argument.\n\nThe lemma that `smul` is a closed map in the first argument (for a normed space over a complete\nnormed field) is `isClosedMap_smul_left` in `Analysis.NormedSpace.FiniteDimension`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {P : Type u_3} {N : Type w} [inst : Ring R] [inst_1 : AddCommGroup M]\n  [inst_2 : Module R M] [inst_3 : AddCommGroup N] [inst_4 : Module R N] [inst_5 : AddCommGroup P] [inst_6 : Module R P]\n  [inst_7 : IsNoetherian R M] [inst_8 : IsNoetherian R P] (f : M ‚Üí‚Çó[R] N) (g : N ‚Üí‚Çó[R] P) (hf : Function.Injective ‚Üëf)\n  (hg : Function.Surjective ‚Üëg) (h : LinearMap.range f = LinearMap.ker g), IsNoetherian R N","name":"isNoetherian_of_range_eq_ker","isProp":true,"docString":"If the first and final modules in a short exact sequence are Noetherian,\nthen the middle module is also Noetherian. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : TopologicalSpace Œ±]\n  [inst_1 : TopologicalSpace Œ≤] [self : ContinuousMapClass F Œ± Œ≤] (f : F), Continuous ‚Üëf","name":"ContinuousMapClass.map_continuous","isProp":true,"docString":"Continuity "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : OmegaCompletePartialOrder Œ±] [inst_1 : OmegaCompletePartialOrder Œ≤] (self : Œ± ‚ÜíùíÑ Œ≤)\n  {Monotone' : Monotone ‚Üë(OmegaCompletePartialOrder.ContinuousHom.toOrderHom self)},\n  OmegaCompletePartialOrder.Continuous\n    { toFun := ‚Üë(OmegaCompletePartialOrder.ContinuousHom.toOrderHom self), monotone' := Monotone' }","name":"OmegaCompletePartialOrder.ContinuousHom.cont","isProp":true,"docString":"The underlying function of a `ContinuousHom` is continuous, i.e. it preserves `œâSup` "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (G : C ‚•§ D) {X : C}\n  {Y : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Y) [inst_2 : CategoryTheory.HasSplitCoequalizer f g],\n  CategoryTheory.HasSplitCoequalizer (Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) f)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) g)","name":"CategoryTheory.map_is_split_pair","isProp":true,"docString":"If `f, g` is split, then `G f, G g` is split. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤] (f : (a : Œ±) ‚Üí Œ≤) {n : ‚Ñï}\n  [inst_3 : Nonempty Œ≤] (hn : Fintype.card Œ≤ * n ‚â§ Fintype.card Œ±),\n  ‚àÉ (y : Œ≤), n ‚â§ Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ)","name":"Fintype.exists_le_card_fiber_of_mul_le_card","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function `f`\nbetween finite types `Œ±` and `Œ≤` and a number `n` such that `card Œ≤ * n ‚â§ card Œ±`, there exists an\nelement `y : Œ≤` such that its preimage has at least `n` elements. See also\n`Fintype.exists_lt_card_fiber_of_mul_lt_card` for a stronger statement. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_4} {Œπ : Sort u_1} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} {f : Filter Œ±}\n  (hf : Filter.HasBasis f p s) {Œ≤ : (a : Œπ) ‚Üí Type u_3} {pg : (i : Œπ) ‚Üí (a : Œ≤ i) ‚Üí Prop}\n  {sg : (i : Œπ) ‚Üí (a : Œ≤ i) ‚Üí Set Œ≥} {g : (a : Set Œ±) ‚Üí Filter Œ≥}\n  (hg : ‚àÄ (i : Œπ), Filter.HasBasis (g (s i)) (pg i) (sg i)) (gm : Monotone g) {s : Set Œ≥},\n  (s ‚àà Filter.lift f g : Prop) ‚Üî\n    (‚àÉ (i : Œπ), (p i : Prop) ‚àß (‚àÉ (x : Œ≤ i), (pg i x : Prop) ‚àß (sg i x ‚äÜ s : Prop) : Prop) : Prop)","name":"Filter.HasBasis.mem_lift_iff","isProp":true,"docString":"If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí Set Œ±)` is a basis of a filter `f`, `g` is a monotone function\n`Set Œ± ‚Üí Filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí Set Œ±)` is a basis\nof the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`\nis a basis of the filter `f.lift g`.\n\nThis basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using\n`Filter.HasBasis` one has to use `Œ£ i, Œ≤ i` as the index type, see `Filter.HasBasis.lift`.\nThis lemma states the corresponding `mem_iff` statement without using a sigma type. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {A : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category A]\n  (J : CategoryTheory.GrothendieckTopology C) (P : C·µí·µñ ‚•§ A),\n  (‚àÄ (E : A),\n        CategoryTheory.Presieve.IsSeparated J\n          (P ‚ãô Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.coyoneda) (Opposite.op E)) :\n      Prop) ‚Üî\n    (‚àÄ ‚¶ÉX : C‚¶Ñ (S : CategoryTheory.Sieve X) (a : S ‚àà CategoryTheory.GrothendieckTopology.sieves J X)\n        (c :\n          CategoryTheory.Limits.Cone\n            (CategoryTheory.Functor.op (CategoryTheory.Presieve.diagram (CategoryTheory.Sieve.arrows S)) ‚ãô P)),\n        Subsingleton\n          (c ‚ü∂\n            CategoryTheory.Functor.mapCone P\n              (CategoryTheory.Limits.Cocone.op (CategoryTheory.Presieve.cocone (CategoryTheory.Sieve.arrows S)))) :\n      Prop)","name":"CategoryTheory.Presheaf.isSeparated_iff_subsingleton","isProp":true,"docString":"A presheaf `P` is separated for the Grothendieck topology `J` iff for every covering sieve\n`S` of `J`, the natural cone associated to `P` and `S` admits at most one morphism from every\ncone in the same category. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤}\n  {f : (a : Œ±) ‚Üí Œ≤} {p : Filter Œπ} {p' : Filter Œ±} [inst_1 : UniformSpace Œ≥] {g : (a : Œ≤) ‚Üí Œ≥}\n  (hg : UniformContinuous g) (h : TendstoUniformlyOnFilter F f p p'),\n  TendstoUniformlyOnFilter (fun (i : Œπ) ‚Ü¶ g ‚àò F i) (g ‚àò f) p p'","name":"UniformContinuous.comp_tendstoUniformlyOnFilter","isProp":true,"docString":"Composing on the left by a uniformly continuous function preserves\nuniform convergence on a filter "},{"type":"‚àÄ {M : Type u_2} [inst : AddMonoid M] {N : Type u_1} [inst_1 : AddMonoid N] {f : (a : M) ‚Üí N} (hf : IsAddMonoidHom f)\n  {s : Set N} (hs : IsAddSubmonoid s), IsAddSubmonoid (f ‚Åª¬π' s)","name":"IsAddSubmonoid.preimage","isProp":true,"docString":"The preimage of an `AddSubmonoid` under an `AddMonoid` hom is\nan `AddSubmonoid` of the domain."},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} {x‚ÇÄ : X}, (EquicontinuousAt F x‚ÇÄ : Prop) ‚Üî (EquicontinuousAt Subtype.val x‚ÇÄ : Prop)","name":"equicontinuousAt_iff_range","isProp":true,"docString":"A family `ùìï : Œπ ‚Üí X ‚Üí Œ±` is equicontinuous at `x‚ÇÄ` iff `range ùìï` is equicontinuous at `x‚ÇÄ`,\ni.e the family `(‚Üë) : range F ‚Üí X ‚Üí Œ±` is equicontinuous at `x‚ÇÄ`. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_4} {P : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} {p1 : P} {p : (a : Œπ) ‚Üí P} (h : p1 ‚àà affineSpan k (Set.range p)),\n  ‚àÉ (s : Finset Œπ),\n    ‚àÉ (w : (a : Œπ) ‚Üí k), ‚àÉ (x : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1), p1 = ‚Üë(Finset.affineCombination k s p) w","name":"eq_affineCombination_of_mem_affineSpan","isProp":true,"docString":"A point in the `affineSpan` of an indexed family is an\n`affineCombination` with sum of weights 1. See also\n`eq_affineCombination_of_mem_affineSpan_of_fintype`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 : AffineSubspace k P) (s2 : AffineSubspace k P),\n  AffineSubspace.direction (s1 ‚äì s2) ‚â§ AffineSubspace.direction s1 ‚äì AffineSubspace.direction s2","name":"AffineSubspace.direction_inf","isProp":true,"docString":"The direction of the inf of two affine subspaces is less than or equal to the inf of their\ndirections. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : StrictMonoOn f s), StrictAntiOn (f ‚àò ‚ÜëOrderDual.ofDual) s","name":"StrictMonoOn.dual_left","isProp":true,"docString":"**Alias** of the reverse direction of `strictAntiOn_comp_ofDual_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : Subsingleton Œ±À£] {a : Œ±} {b : Œ±} (a_1 : a ‚à£ b)\n  (a_2 : b ‚à£ a), a = b","name":"Dvd.dvd.antisymm","isProp":true,"docString":"**Alias** of `dvd_antisymm`."},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {l : Filter Œ±} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} (h : Filter.HasBasis l p s)\n  {V : Set Œ±} (hV : V ‚àà l), Filter.HasBasis l (fun (i : Œπ) ‚Ü¶ (p i : Prop) ‚àß (s i ‚äÜ V : Prop)) s","name":"Filter.HasBasis.restrict_subset","isProp":true,"docString":"If `{s i | p i}` is a basis of a filter `l` and `V ‚àà l`, then `{s i | p i ‚àß s i ‚äÜ V}`\nis a basis of `l`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  [inst_2 : CategoryTheory.Functor.Final F] {E : Type u‚ÇÉ} [inst_3 : CategoryTheory.Category E] {G : D ‚•§ E}\n  [inst : CategoryTheory.Limits.HasColimit (F ‚ãô G)], CategoryTheory.Limits.HasColimit G","name":"CategoryTheory.Functor.Final.hasColimit_of_comp","isProp":true,"docString":"When `F` is cofinal, and `F ‚ãô G` has a colimit, then `G` has a colimit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_hasColimit`.)\n"},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {f : AddHom M N} {g : AddHom M N} (h : f = g) (x : M),\n  ‚Üëf x = ‚Üëg x","name":"AddHom.congr_fun","isProp":true,"docString":"Deprecated: use `FunLike.congr_fun` instead."},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] {p1 : P} {p2 : P} {p : P},\n  (p -·µ• p1 = p -·µ• p2 : Prop) ‚Üî (p1 = p2 : Prop)","name":"vsub_right_cancel_iff","isProp":true,"docString":"Subtracting two points from the same point produces equal results\nif and only if those points are equal. "},{"type":"‚àÄ {Œ≤ : Type v} [inst : NormedField Œ≤] [inst_1 : CauSeq.IsComplete Œ≤ norm], CompleteSpace Œ≤","name":"completeSpace_of_cauSeq_isComplete","isProp":true,"docString":"A complete normed field is complete as a metric space, as Cauchy sequences converge by\nassumption and this suffices to characterize completeness. "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï} {b : ‚Ñï} (hm : m ‚â† 1) (hn : 0 < n) (hb : Nat.log m n < b),\n  multiplicity m n = ‚Üë(Finset.card (Finset.filter (fun (i : ‚Ñï) ‚Ü¶ m ^ i ‚à£ n) (Finset.Ico 1 b)))","name":"Nat.multiplicity_eq_card_pow_dvd","isProp":true,"docString":"The multiplicity of `m` in `n` is the number of positive natural numbers `i` such that `m ^ i`\ndivides `n`. This set is expressed by filtering `Ico 1 b` where `b` is any bound greater than\n`log m n`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NormedDivisionRing Œ±] {a : Œ±} (ha : a ‚â† 0),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ x * a) (Filter.comap norm Filter.atTop) (Filter.comap norm Filter.atTop)","name":"Filter.tendsto_mul_right_cobounded","isProp":true,"docString":"Multiplication on the right by a nonzero element of a normed division ring tends to infinity at\ninfinity. TODO: use `Bornology.cobounded` instead of `Filter.comap Norm.norm Filter.atTop`. "},{"type":"‚àÄ {R : Type u_2} {E : Type u_3} [inst : LinearOrderedField R] [inst_1 : AddCommGroup E] [inst_2 : Module R E]\n  {Œπ : Type u_1} (b : AffineBasis Œπ R E),\n  ‚Üë(ClosureOperator.toOrderHom (convexHull R)) (Set.range ‚Üëb) =\n    setOf fun (x : E) ‚Ü¶ ‚àÄ (i : Œπ), 0 ‚â§ ‚Üë(AffineBasis.coord b i) x","name":"AffineBasis.convexHull_eq_nonneg_coord","isProp":true,"docString":"The convex hull of an affine basis is the intersection of the half-spaces defined by the\ncorresponding barycentric coordinates. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} [inst_1 : TopologicalSpace Œ±]\n  (L :\n    ‚àÄ (u : Set (Œ≤ √ó Œ≤)) (a : u ‚àà uniformity Œ≤),\n      ‚àÉ (F : (a : Œ±) ‚Üí Œ≤), (Continuous F : Prop) ‚àß (‚àÄ (y : Œ±), (f y, F y) ‚àà u : Prop)),\n  Continuous f","name":"continuous_of_uniform_approx_of_continuous","isProp":true,"docString":"A function which can be uniformly approximated by continuous functions is continuous. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_4} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P) {i : Œπ} (his : i ‚àà s)\n  (hwi : w i = 1) (hw0 : ‚àÄ (i2 : Œπ) (a : i2 ‚àà s) (a : i2 ‚â† i), w i2 = 0), ‚Üë(Finset.affineCombination k s p) w = p i","name":"Finset.affineCombination_of_eq_one_of_eq_zero","isProp":true,"docString":"An `affineCombination` equals a point if that point is in the set\nand has weight 1 and the other points in the set have weight 0. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥‚ÇÅ : ‚Ñù} {Œ¥‚ÇÇ : ‚Ñù} (Œ¥‚ÇÇ_pos : 0 < Œ¥‚ÇÇ) (hlt : Œ¥‚ÇÅ < Œ¥‚ÇÇ) (E : Set Œ±),\n  Metric.cthickening Œ¥‚ÇÅ E ‚äÜ Metric.thickening Œ¥‚ÇÇ E","name":"Metric.cthickening_subset_thickening'","isProp":true,"docString":"The closed thickening `Metric.cthickening Œ¥‚ÇÅ E` is contained in the open thickening\n`Metric.thickening Œ¥‚ÇÇ E` if the radius of the latter is positive and larger. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Sort u_2} {Œ≥ : Sort u_3} {p : (a : Œ±) ‚Üí Prop} (e : Œ≤ ‚âÉ Subtype p) (v : (a : Œ≤) ‚Üí Œ≥)\n  (w : (a : Œ±) ‚Üí Œ≥) (j : Œ≤) (x : Œ≥) [inst : DecidableEq Œ≤] [inst_1 : DecidableEq Œ±]\n  [inst_2 : (j : Œ±) ‚Üí Decidable (p j : Prop)],\n  (fun (i : Œ±) ‚Ü¶\n      if h : (p i : Prop) then Function.update v j x (‚Üë(Equiv.symm e) { val := i, property := h }) else w i) =\n    Function.update (fun (i : Œ±) ‚Ü¶ if h : (p i : Prop) then v (‚Üë(Equiv.symm e) { val := i, property := h }) else w i)\n      (‚Üë(‚Üëe j)) x","name":"dite_comp_equiv_update","isProp":true,"docString":"The composition of an updated function with an equiv on a subtype can be expressed as an\nupdated function. "},{"type":"‚àÄ {Œπ : Type u_1} [inst : Countable Œπ] {E : (a : Œπ) ‚Üí Type u_2} [inst : (n : Œπ) ‚Üí TopologicalSpace (E n)]\n  [inst_1 : ‚àÄ (n : Œπ), PolishSpace (E n)], PolishSpace ((n : Œπ) √ó E n)","name":"PolishSpace.sigma","isProp":true,"docString":"A countable disjoint union of Polish spaces is Polish. "},{"type":"‚àÄ {C : Type u_1} {D : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {G : C ‚•§ D}\n  {F : D ‚•§ C} {A : C} {B : C} {X : D} {Y : D} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\n  {u : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) A ‚ü∂ X}\n  {v : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) B ‚ü∂ Y}\n  (sq : CategoryTheory.CommSq u (Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) i) p v) (adj : G ‚ä£ F),\n  CategoryTheory.CommSq (‚Üë(CategoryTheory.Adjunction.homEquiv adj A X) u) i\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) p) (‚Üë(CategoryTheory.Adjunction.homEquiv adj B Y) v)","name":"CategoryTheory.CommSq.right_adjoint","isProp":true,"docString":"When we have an adjunction `G ‚ä£ F`, any commutative square where the left\nmap is of the form `G.map i` and the right map is `p` has an \"adjoint\" commutative\nsquare whose left map is `i` and whose right map is `F.map p`. "},{"type":"‚àÄ {I : Type u} {Œ≤ : Type u_1} [inst : DecidableEq I] [inst_1 : One Œ≤] (i : I) (x : Œ≤) (i' : I),\n  Pi.mulSingle i x i' = Pi.mulSingle i' x i","name":"Pi.mulSingle_comm","isProp":true,"docString":"On non-dependent functions, `Pi.mulSingle` is symmetric in the two indices. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_3 : CategoryTheory.Limits.HasBinaryBiproduct X Y],\n  CategoryTheory.BicartesianSq CategoryTheory.Limits.biprod.fst CategoryTheory.Limits.biprod.snd 0 0","name":"CategoryTheory.BicartesianSq.of_has_biproduct‚ÇÅ","isProp":true,"docString":"```\n X ‚äû Y --fst--> X\n   |            |\n  snd           0\n   |            |\n   v            v\n   Y -----0---> 0\n```\nis a bicartesian square.\n"},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : SeminormedRing ùïú] [inst_1 : SMul ùïú E] [inst_2 : Zero E]\n  [inst_3 : TopologicalSpace E] {s‚ÇÅ : Set E} {s‚ÇÇ : Set E} (hs‚ÇÅ : Bornology.IsVonNBounded ùïú s‚ÇÅ)\n  (hs‚ÇÇ : Bornology.IsVonNBounded ùïú s‚ÇÇ), Bornology.IsVonNBounded ùïú (s‚ÇÅ ‚à™ s‚ÇÇ)","name":"Bornology.IsVonNBounded.union","isProp":true,"docString":"The union of two bounded sets is bounded. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {K : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category K] {C : Type u}\n  [inst_2 : CategoryTheory.Category C] {F : J ‚•§ C} [inst_3 : CategoryTheory.Limits.HasColimit F] {E : K ‚•§ J}\n  [inst_4 : CategoryTheory.Limits.HasColimit (E ‚ãô F)] (s : CategoryTheory.Limits.ColimitCocone (E ‚ãô F))\n  (t : CategoryTheory.Limits.ColimitCocone F),\n  CategoryTheory.Limits.colimit.pre F E =\n    CategoryTheory.Iso.hom (CategoryTheory.Limits.colimit.isoColimitCocone s) ‚â´\n      CategoryTheory.Limits.IsColimit.desc (CategoryTheory.Limits.ColimitCocone.isColimit s)\n          (CategoryTheory.Limits.Cocone.whisker E (CategoryTheory.Limits.ColimitCocone.cocone t)) ‚â´\n        CategoryTheory.Iso.inv (CategoryTheory.Limits.colimit.isoColimitCocone t)","name":"CategoryTheory.Limits.colimit.pre_eq","isProp":true,"docString":"-\nIf we have particular colimit cocones available for `E ‚ãô F` and for `F`,\nwe obtain a formula for `colimit.pre F E`.\n"},{"type":"‚àÄ {R : Type u} {œÉ : Type v} [inst : CommRing R] [inst_1 : Finite œÉ] [inst_2 : IsNoetherianRing R],\n  IsNoetherianRing (MvPolynomial œÉ R)","name":"MvPolynomial.isNoetherianRing","isProp":true,"docString":"The multivariate polynomial ring in finitely many variables over a noetherian ring\nis itself a noetherian ring. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {S : Submodule K V}\n  (h : FiniteDimensional.finrank K { x : V // x ‚àà S } = FiniteDimensional.finrank K V), S = ‚ä§","name":"FiniteDimensional.eq_top_of_finrank_eq","isProp":true,"docString":"If a submodule has maximal dimension in a finite dimensional space, then it is equal to the\nwhole space. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {K : NNReal} {s : Set Œ±}\n  {f : (a : Œ±) ‚Üí Œ≤} (a : ‚àÄ (x : Œ±) (a : x ‚àà s) (y : Œ±) (a : y ‚àà s), dist (f x) (f y) ‚â§ ‚ÜëK * dist x y),\n  LipschitzOnWith K f s","name":"LipschitzOnWith.of_dist_le_mul","isProp":true,"docString":"**Alias** of the reverse direction of `lipschitzOnWith_iff_dist_le_mul`."},{"type":"‚àÄ {Œ± : Type u_4} {M : Type u_1} {R : Type u_2} {S : Type u_3} [inst : Zero M] [inst_1 : CommSemiring R]\n  [inst_2 : CommSemiring S] (h : R ‚Üí+* S) (f : Œ± ‚Üí‚ÇÄ M) (g : (a : Œ±) ‚Üí (a : M) ‚Üí R),\n  ‚Üëh (Finsupp.prod f g) = Finsupp.prod f fun (a : Œ±) (b : M) ‚Ü¶ ‚Üëh (g a b)","name":"RingHom.map_finsupp_prod","isProp":true,"docString":"Deprecated, use `_root_.map_finsupp_prod` instead. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [hŒ± : LocallyCompactSpace Œ±] {K : Set Œ±} {U : Set Œ±} (hK : IsCompact K)\n  (hU : IsOpen U) (h_KU : K ‚äÜ U),\n  ‚àÉ (L : Set Œ±), (IsCompact L : Prop) ‚àß ((K ‚äÜ interior L : Prop) ‚àß (L ‚äÜ U : Prop) : Prop)","name":"exists_compact_between","isProp":true,"docString":"In a locally compact space, for every containement `K ‚äÜ U` of a compact set `K` in an open\nset `U`, there is a compact neighborhood `L` such that `K ‚äÜ L ‚äÜ U`: equivalently, there is a\ncompact `L` such that `K ‚äÜ interior L` and `L ‚äÜ U`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] (f : R ‚Üí+* S) (r : R),\n  ‚ÜëPolynomial.C (‚Üëf r) ‚àà Polynomial.lifts f","name":"Polynomial.C_mem_lifts","isProp":true,"docString":"If `(r : R)`, then `C (f r)` lifts. "},{"type":"Subsingleton (Fin 0)","name":"subsingleton_fin_zero","isProp":true,"docString":"`Fin 0` is a subsingleton. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {R : D ‚•§ C} (h : L ‚ä£ R) {X : D} [inst_2 : CategoryTheory.IsIso ((CategoryTheory.Adjunction.counit h).app X)],\n  CategoryTheory.inv\n      (Prefunctor.map (CategoryTheory.Functor.toPrefunctor R) ((CategoryTheory.Adjunction.counit h).app X)) =\n    (CategoryTheory.Adjunction.unit h).app (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor R) X)","name":"CategoryTheory.inv_counit_map","isProp":true,"docString":"If the counit of an adjunction is an isomorphism, then its inverse on the image of R is given\nby R whiskered with the unit. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedSemifield Œ±] (n : ‚Ñï) (a : Œ±),\n  LinearOrderedSemifield.zpow (Int.negSucc n) a = (LinearOrderedSemifield.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"LinearOrderedSemifield.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ {R : Type u_1} {a : R} [inst : Monoid R] (n : ‚Ñï) (ra : IsRegular a), IsRegular (a ^ n)","name":"IsRegular.pow","isProp":true,"docString":"Any power of a regular element is regular. "},{"type":"‚àÄ {Œ± : Type u} {f : Filter Œ±} [self : Filter.NeBot f], f ‚â† ‚ä•","name":"Filter.NeBot.ne'","isProp":true,"docString":"The filter is nontrivial: `f ‚â† ‚ä•` or equivalently, `‚àÖ ‚àâ f`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] [inst_1 : DecidableEq Œ±] (s : Finset Œ±) (f : (a : Œ±) ‚Üí Œ≤) {a : Œ±}\n  (h : a ‚àà s), (Finset.sum (Finset.erase s a) fun (x : Œ±) ‚Ü¶ f x) + f a = Finset.sum s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.sum_erase_add","isProp":true,"docString":"A variant of `Finset.add_sum_erase` with the addition swapped."},{"type":"‚àÄ {p : ‚Ñï} (hp : 1 < p), padicNorm p ‚Üëp < 1","name":"padicNorm.padicNorm_p_lt_one","isProp":true,"docString":"The `p`-adic norm of `p` is less than `1` if `1 < p`.\n\nSee also `padicNorm.padicNorm_p_lt_one_of_prime` for a version assuming `p` is prime. "},{"type":"‚àÄ {p : ‚Ñï} (hp : 1 < p), padicValInt p ‚Üëp = 1","name":"padicValInt.self","isProp":true,"docString":"If `p ‚â† 0` and `p ‚â† 1`, then `padicValInt p p` is `1`. "},{"type":"‚àÄ {Œπ : Sort u_1} {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h0 : x ‚â† 0) (h : x ‚â† ‚ä§), inf·µ¢ f * x = inf·µ¢ fun (i : Œπ) ‚Ü¶ f i * x","name":"ENNReal.inf·µ¢_mul_of_ne","isProp":true,"docString":"If `x ‚â† 0` and `x ‚â† ‚àû`, then right multiplication by `x` maps infimum to infimum.\nSee also `ENNReal.inf·µ¢_mul` that assumes `[Nonempty Œπ]` but does not require `x ‚â† 0`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f f) F]\n  [inst_3 : CategoryTheory.Epi f], CategoryTheory.Epi (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)","name":"CategoryTheory.preserves_epi_of_preservesColimit","isProp":true,"docString":"If `F` preserves pushouts, then it preserves epimorphisms. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  {Z : C} {X' : C} {Y' : C} {Z' : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [inst_2 : CategoryTheory.Limits.HasKernel g]\n  (w : f ‚â´ g = 0) (f' : X' ‚ü∂ Y') (g' : Y' ‚ü∂ Z') [inst_3 : CategoryTheory.Limits.HasKernel g'] (w' : f' ‚â´ g' = 0)\n  (p : X ‚ü∂ X') (q : Y ‚ü∂ Y') (r : Z ‚ü∂ Z') (h‚ÇÅ : f ‚â´ q = p ‚â´ f') (h‚ÇÇ : g ‚â´ r = q ‚â´ g'),\n  CategoryTheory.Limits.kernel.lift g f w ‚â´ CategoryTheory.Limits.kernel.map g g' q r h‚ÇÇ =\n    p ‚â´ CategoryTheory.Limits.kernel.lift g' f' w'","name":"CategoryTheory.Limits.kernel.lift_map","isProp":true,"docString":"Given a commutative diagram\n    X --f--> Y --g--> Z\n    |        |        |\n    |        |        |\n    v        v        v\n    X' -f'-> Y' -g'-> Z'\nwith horizontal arrows composing to zero,\nthen we obtain a commutative square\n   X ---> kernel g\n   |         |\n   |         | kernel.map\n   |         |\n   v         v\n   X' --> kernel g'\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±],\n  (TotallyDisconnectedSpace Œ± : Prop) ‚Üî (‚àÄ (x : Œ±), Set.Subsingleton (connectedComponent x) : Prop)","name":"totallyDisconnectedSpace_iff_connectedComponent_subsingleton","isProp":true,"docString":"A space is totally disconnected iff its connected components are subsingletons. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {f : (a : Œ≤) ‚Üí Œ±} (hf : Continuous f) (x‚ÇÄ : Œ≤)\n  (h : Filter.Eventually (fun (x : Œ≤) ‚Ü¶ f x‚ÇÄ ‚â§ f x) (Filter.cocompact Œ≤)), ‚àÉ (x : Œ≤), ‚àÄ (y : Œ≤), f x ‚â§ f y","name":"Continuous.exists_forall_le'","isProp":true,"docString":"The **extreme value theorem**: if a continuous function `f` is larger than a value in its range\naway from compact sets, then it has a global minimum. "},{"type":"‚àÄ {Œπ : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] {f : (a : Œπ) ‚Üí E} {g : (a : Œπ) ‚Üí NNReal} {a : NNReal}\n  (hg : HasSum g a) (h : ‚àÄ (i : Œπ), ‚Äñf i‚Äñ‚Çä ‚â§ g i), ‚Äñtsum fun (i : Œπ) ‚Ü¶ f i‚Äñ‚Çä ‚â§ a","name":"tsum_of_nnnorm_bounded","isProp":true,"docString":"Quantitative result associated to the direct comparison test for series: If `‚àë' i, g i` is\nsummable, and for all `i`, `‚Äñf i‚Äñ‚Çä ‚â§ g i`, then `‚Äñ‚àë' i, f i‚Äñ‚Çä ‚â§ ‚àë' i, g i`. Note that we\ndo not assume that `‚àë' i, f i` is summable, and it might not be the case if `Œ±` is not a complete\nspace. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFilteredOrEmpty C] {j‚ÇÅ : C} {j‚ÇÇ : C}\n  {j‚ÇÉ : C} {k‚ÇÅ : C} {k‚ÇÇ : C} {l : C} (f‚ÇÅ : j‚ÇÅ ‚ü∂ k‚ÇÅ) (f‚ÇÇ : j‚ÇÇ ‚ü∂ k‚ÇÅ) (f‚ÇÉ : j‚ÇÇ ‚ü∂ k‚ÇÇ) (f‚ÇÑ : j‚ÇÉ ‚ü∂ k‚ÇÇ) (g‚ÇÅ : j‚ÇÅ ‚ü∂ l)\n  (g‚ÇÇ : j‚ÇÉ ‚ü∂ l),\n  ‚àÉ (s : C),\n    ‚àÉ (Œ± : k‚ÇÅ ‚ü∂ s),\n      ‚àÉ (Œ≤ : l ‚ü∂ s),\n        ‚àÉ (Œ≥ : k‚ÇÇ ‚ü∂ s), (f‚ÇÅ ‚â´ Œ± = g‚ÇÅ ‚â´ Œ≤ : Prop) ‚àß ((f‚ÇÇ ‚â´ Œ± = f‚ÇÉ ‚â´ Œ≥ : Prop) ‚àß (f‚ÇÑ ‚â´ Œ≥ = g‚ÇÇ ‚â´ Œ≤ : Prop) : Prop)","name":"CategoryTheory.IsFiltered.tulip","isProp":true,"docString":"Given a \"tulip\" of morphisms\n```\n j‚ÇÅ    j‚ÇÇ    j‚ÇÉ\n |\\   / \\   / |\n | \\ /   \\ /  |\n |  vv    vv  |\n \\  k‚ÇÅ    k‚ÇÇ /\n  \\         /\n   \\       /\n    \\     /\n     \\   /\n      v v\n       l\n```\nin a filtered category, we can construct an object `s` and three morphisms from `k‚ÇÅ`, `k‚ÇÇ` and `l`\nto `s`, making the resulting squares commute.\n"},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel (SimpleGraph.Adj G)] (v : V),\n  SimpleGraph.minDegree G ‚â§ SimpleGraph.degree G v","name":"SimpleGraph.minDegree_le_degree","isProp":true,"docString":"The minimum degree in the graph is at most the degree of any particular vertex. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i)) ‚â§ Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i","name":"MonovaryOn.sum_smul_comp_perm_le_sum_smul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when\n`f` and `g` monovary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ± : Type u_3} {E : Type u_4} {F' : Type u_2} {ùïú : Type u_1} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F']\n  [inst_2 : NormedField ùïú] {f : (a : Œ±) ‚Üí E} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} [inst_3 : NormedSpace ùïú F'] {c : ùïú}\n  (hc : c ‚â† 0) (a : f =Œò[l] fun (x : Œ±) ‚Ü¶ c ‚Ä¢ g' x), f =Œò[l] g'","name":"Asymptotics.IsTheta.of_const_smul_right","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isTheta_const_smul_right`."},{"type":"‚àÄ {Œ± : Type u_1} (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop),\n  EqvGen.Setoid r = inf‚Çõ (setOf fun (s : Setoid Œ±) ‚Ü¶ ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : r x y), Setoid.Rel s x y)","name":"Setoid.eqvGen_eq","isProp":true,"docString":"The inductively defined equivalence closure of a binary relation r is the infimum\nof the set of all equivalence relations containing r. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {coe : outParam ((a : Œ≤) ‚Üí Œ±)} {cond : outParam ((a : Œ±) ‚Üí Prop)}\n  [self : CanLift Œ± Œ≤ coe cond] (x : Œ±) (a : cond x), ‚àÉ (y : Œ≤), coe y = x","name":"CanLift.prf","isProp":true,"docString":"An element of `Œ±` that satisfies `cond` belongs to the range of `coe`. "},{"type":"‚àÄ (x : ‚Ñ§), ‚Üë(Int.natAbs x) ^ 2 = x ^ 2","name":"Int.natAbs_pow_two","isProp":true,"docString":"**Alias** of `Int.natAbs_sq`."},{"type":"‚àÄ {S‚ÇÅ : Type u_1} {S‚ÇÇ : Type u_2} [inst : Shelf S‚ÇÅ] [inst_1 : Shelf S‚ÇÇ] (self : ShelfHom S‚ÇÅ S‚ÇÇ) {x : S‚ÇÅ} {y : S‚ÇÅ},\n  ShelfHom.toFun self (Shelf.act x y) = Shelf.act (ShelfHom.toFun self x) (ShelfHom.toFun self y)","name":"ShelfHom.map_act'","isProp":true,"docString":"The homomorphism property of a Shelf Homomorphism"},{"type":"‚àÄ {Œ± : Type u_1} [inst : CommGroup Œ±] [inst_1 : DecidableEq Œ±] {A : Finset Œ±} (hA : Finset.Nonempty A) (B : Finset Œ±)\n  (m : ‚Ñï) (n : ‚Ñï),\n  ‚Üë(Finset.card (B ^ m / B ^ n)) ‚â§ (‚Üë(Finset.card (A / B)) / ‚Üë(Finset.card A)) ^ (m + n) * ‚Üë(Finset.card A)","name":"Finset.card_pow_div_pow_le'","isProp":true,"docString":"The **Pl√ºnnecke-Ruzsa inequality**. Subtraction version. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  [inst_1 : CategoryTheory.IsIso (Quiver.Hom.op f)], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_op","isProp":true,"docString":"If `f.op` is an isomorphism `f` must be too.\n(This cannot be an instance as it would immediately loop!)\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ≤] [inst_2 : SuccOrder Œ≤]\n  [inst_3 : IsSuccArchimedean Œ≤] {s : (a : Œ≤) ‚Üí Set Œ±} {t : Set Œ≤} (hnt : Set.Nonempty t) (ht : Set.OrdConnected t)\n  (H : ‚àÄ (n : Œ≤) (a : n ‚àà t), IsConnected (s n))\n  (K : ‚àÄ (n : Œ≤) (a : n ‚àà t) (a : Order.succ n ‚àà t), Set.Nonempty (s n ‚à© s (Order.succ n))),\n  IsConnected (Set.union·µ¢ fun (n : Œ≤) ‚Ü¶ Set.union·µ¢ fun (h : n ‚àà t) ‚Ü¶ s n)","name":"IsConnected.bunion·µ¢_of_chain","isProp":true,"docString":"The union·µ¢ of connected sets indexed by a subset of a type with an archimedean successor\n(like `‚Ñï` or `‚Ñ§`) such that any two neighboring sets meet is preconnected. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] (e : Œ± ‚âÉ·µê Œ≤),\n  MeasurableEmbedding ‚Üëe","name":"MeasurableEquiv.measurableEmbedding","isProp":true,"docString":"A measurable equivalence is a measurable embedding. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} (a_1 : 0 < a), 0 < a‚Åª¬π","name":"inv_pos_of_pos","isProp":true,"docString":"**Alias** of the reverse direction of `inv_pos`."},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {Œ∫ : Type u_3} {C : (a : (a : Œπ) ‚Üí Option Œ±) ‚Üí Œ∫}\n  (self : Combinatorics.Line.ColorFocused C) (p : Combinatorics.Line.AlmostMono C)\n  (a : p ‚àà Combinatorics.Line.ColorFocused.lines self),\n  (fun (x : Option Œ±) (i : Œπ) ‚Ü¶ Option.getD (Combinatorics.Line.idxFun (Combinatorics.Line.AlmostMono.line p) i) x)\n      none =\n    Combinatorics.Line.ColorFocused.focus self","name":"Combinatorics.Line.ColorFocused.is_focused","isProp":true,"docString":"The proposition that all lines in a color-focused collection have the same endpoint. "},{"type":"‚àÄ {M : Type u_3} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {P : Type u_4}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P} {T : Submonoid P}\n  (hy : ‚àÄ (y : { x : M // x ‚àà S }), ‚Üëg ‚Üëy ‚àà T) {Q : Type u_1} [inst_3 : CommMonoid Q]\n  {k : Submonoid.LocalizationMap T Q} (z : N) (u : (fun (x : N) ‚Ü¶ Q) z),\n  (‚Üë(Submonoid.LocalizationMap.map f hy k) z = u : Prop) ‚Üî\n    (‚Üë(Submonoid.LocalizationMap.toMap k) (‚Üëg (Prod.fst (Submonoid.LocalizationMap.sec f z))) =\n        ‚Üë(Submonoid.LocalizationMap.toMap k) (‚Üëg ‚Üë(Prod.snd (Submonoid.LocalizationMap.sec f z))) * u :\n      Prop)","name":"Submonoid.LocalizationMap.map_spec","isProp":true,"docString":"Given Localization maps `f : M ‚Üí* N, k : P ‚Üí* Q` for Submonoids `S, T` respectively, if a\n`CommMonoid` homomorphism `g : M ‚Üí* P` induces a `f.map hy k : N ‚Üí* Q`, then for all `z : N`,\n`u : Q`, we have `f.map hy k z = u ‚Üî k (g x) = k (g y) * u` where `x : M, y ‚àà S` are such that\n`z * f y = f x`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedCoheytingAlgebra Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hac : Disjoint a c) (hab : a ‚â§ b),\n  a ‚â§ b \\ c","name":"Disjoint.le_sdiff_of_le_left","isProp":true,"docString":"See `le_sdiff` for a stronger version in generalised Boolean algebras. "},{"type":"‚àÄ {p : ‚Ñï} {q : ‚Ñï} [p_prime : Fact (Nat.Prime p : Prop)] [q_prime : Fact (Nat.Prime q : Prop)] (neq : p ‚â† q),\n  padicNorm p ‚Üëq = 1","name":"padicNorm.padicNorm_of_prime_of_ne","isProp":true,"docString":"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. "},{"type":"‚àÄ {R : Type u_2} {G : Type u_1} [inst : AddCommGroup G] [inst_1 : CommRing R] [inst_2 : Nontrivial R],\n  (Algebra.FiniteType R (AddMonoidAlgebra R G) : Prop) ‚Üî (AddGroup.Fg G : Prop)","name":"AddMonoidAlgebra.finiteType_iff_group_fg","isProp":true,"docString":"An additive group `G` is finitely generated if and only if `AddMonoidAlgebra R G` is of\nfinite type. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] {s : Set Œ±} (hs : IsCompact s), BddBelow s","name":"IsCompact.bddBelow","isProp":true,"docString":"A compact set is bounded below "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M],\n  (Monoid.Fg M : Prop) ‚Üî (‚àÉ (S : Set M), (Submonoid.closure S = ‚ä§ : Prop) ‚àß (Set.Finite S : Prop) : Prop)","name":"Monoid.fg_iff","isProp":true,"docString":"An equivalent expression of `Monoid.Fg` in terms of `Set.Finite` instead of `Finset`. "},{"type":"‚àÄ (G : Type u_2) (P : Type u_1) [inst : AddGroup G] [inst_1 : AddTorsor G P] [inst_2 : TopologicalSpace G]\n  [inst_3 : PreconnectedSpace G] [inst_4 : TopologicalSpace P] [inst : ContinuousVAdd G P], ConnectedSpace P","name":"AddTorsor.connectedSpace","isProp":true,"docString":"An `AddTorsor` for a connected space is a connected space. This is not an instance because\nit loops for a group as a torsor over itself. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteBooleanAlgebra Œ±] (a : Œ±) (s : Set Œ±),\n  (inf·µ¢ fun (b : Œ±) ‚Ü¶ inf·µ¢ fun (h : b ‚àà s) ‚Ü¶ a ‚äî b) ‚â§ a ‚äî inf‚Çõ s","name":"CompleteBooleanAlgebra.inf·µ¢_sup_le_sup_inf‚Çõ","isProp":true,"docString":"In a completely distributive lattice, `‚äî` distributes over `‚®Ö`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : LocallyCompactSpace Œ±], Continuous fun (p : C(Œ±, Œ≤) √ó Œ±) ‚Ü¶ ‚Üë(Prod.fst p) (Prod.snd p)","name":"ContinuousMap.continuous_eval'","isProp":true,"docString":"The evaluation map `C(Œ±, Œ≤) √ó Œ± ‚Üí Œ≤` is continuous if `Œ±` is locally compact.\n\nSee also `ContinuousMap.continuous_eval` "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] {x : Œ±} {y : Œ±} (h : x ‚â† y),\n  ‚àÉ (u : Set Œ±),\n    ‚àÉ (v : Set Œ±),\n      (IsOpen u : Prop) ‚àß\n        ((IsOpen v : Prop) ‚àß ((x ‚àà u : Prop) ‚àß ((y ‚àà v : Prop) ‚àß (Disjoint u v : Prop) : Prop) : Prop) : Prop)","name":"t2_separation","isProp":true,"docString":"Two different points can be separated by open sets. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (G : C ‚•§ D)\n  [inst_2 : CategoryTheory.Limits.HasTerminal C]\n  [inst : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G], CategoryTheory.Limits.HasTerminal D","name":"CategoryTheory.Limits.hasTerminal_of_hasTerminal_of_preservesLimit","isProp":true,"docString":"If `C` has a terminal object and `G` preserves terminal objects, then `D` has a terminal object\nalso.\nNote this property is somewhat unique to (co)limits of the empty diagram: for general `J`, if `C`\nhas limits of shape `J` and `G` preserves them, then `D` does not necessarily have limits of shape\n`J`.\n"},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] [inst_5 : Module.Finite R M] (f : M ‚Üí‚Çó[R] N),\n  Module.Finite R { x : N // x ‚àà LinearMap.range f }","name":"Module.Finite.range","isProp":true,"docString":"The range of a linear map from a finite module is finite. "},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_6} {Œ≥ : Type u_4} {Œ¥ : Type u_5} {Œµ : Type u_1} {Œ∂ : Type u_2} (f : (a : Œ±) ‚Üí Œ≤)\n  (f' : (a : Œ≥) ‚Üí Œ¥) (g : (a : Œ≤) ‚Üí Œµ) (g' : (a : Œ¥) ‚Üí Œ∂), Prod.map g g' ‚àò Prod.map f f' = Prod.map (g ‚àò f) (g' ‚àò f')","name":"Prod.map_comp_map","isProp":true,"docString":"Composing a `Prod.map` with another `Prod.map` is equal to\na single `Prod.map` of composed functions.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] [inst_1 : Fintype Œ±] [inst_2 : Fintype Œ≤] (f : (a : Œ±) ‚Üí Œ≤) {n : ‚Ñï}\n  (hn : Fintype.card Œ≤ * n < Fintype.card Œ±),\n  ‚àÉ (y : Œ≤), n < Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) Finset.univ)","name":"Fintype.exists_lt_card_fiber_of_mul_lt_card","isProp":true,"docString":"The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at least as many pigeons as\nthe ceiling of the average number of pigeons across all pigeonholes.\n(\"The maximum is at least the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `Œ±` and `Œ≤` and a number `n` such that\n`card Œ≤ * n < card Œ±`, there exists an element `y : Œ≤` such that its preimage has more than `n`\nelements. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) (m : Multiset K) (a : ‚àÄ (a : K) (a_1 : a ‚àà m), a ‚àà s),\n  Multiset.prod m ‚àà s","name":"Subfield.multiset_prod_mem","isProp":true,"docString":"Product of a multiset of elements in a subfield is in the subfield. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {t : Finset V} (h : FiniteDimensional.finrank K V < Finset.card t),\n  ‚àÉ (f : (a : V) ‚Üí K),\n    ((Finset.sum t fun (e : V) ‚Ü¶ f e ‚Ä¢ e) = 0 : Prop) ‚àß (‚àÉ (x : V), (x ‚àà t : Prop) ‚àß (f x ‚â† 0 : Prop) : Prop)","name":"FiniteDimensional.exists_nontrivial_relation_of_rank_lt_card","isProp":true,"docString":"If a finset has cardinality larger than the dimension of the space,\nthen there is a nontrivial linear relation amongst its elements.\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i)) = Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (MonovaryOn f (g ‚àò ‚ÜëœÉ) ‚Üës : Prop)","name":"MonovaryOn.sum_mul_comp_perm_eq_sum_mul_iff","isProp":true,"docString":"**Equality case of Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f` and `g ‚àò œÉ` monovary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : CommMonoid Œ≤] [inst_1 : CommMonoid Œ≥] (g : Œ≤ ‚âÉ* Œ≥) (f : (a : Œ±) ‚Üí Œ≤)\n  (s : Finset Œ±), ‚Üëg (Finset.prod s fun (x : Œ±) ‚Ü¶ f x) = Finset.prod s fun (x : Œ±) ‚Ü¶ ‚Üëg (f x)","name":"MulEquiv.map_prod","isProp":true,"docString":"Deprecated: use `_root_.map_prod` instead. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedAddGroup E] {f : (a : Œ±) ‚Üí E} {a : (a : Œ±) ‚Üí ‚Ñù} {t‚ÇÄ : Filter Œ±}\n  (h : Filter.Eventually (fun (n : Œ±) ‚Ü¶ ‚Äñf n‚Äñ ‚â§ a n) t‚ÇÄ) (h' : Filter.Tendsto a t‚ÇÄ (nhds 0)),\n  Filter.Tendsto f t‚ÇÄ (nhds 0)","name":"squeeze_zero_norm'","isProp":true,"docString":"Special case of the sandwich theorem: if the norm of `f` is eventually bounded by a\nreal function `a` which tends to `0`, then `f` tends to `1`. In this pair of lemmas\n(`squeeze_zero_norm'` and `squeeze_zero_norm`), following a convention of similar lemmas in\n`Topology.MetricSpace.Basic` and `Topology.Algebra.Order`, the `'` version is phrased using\n\"eventually\" and the non-`'` version is phrased absolutely."},{"type":"‚àÄ {Œ± : Type uu} {a : Œ±} {l : List Œ±} (a_1 : [a] ~ l), [a] = l","name":"List.Perm.singleton_eq","isProp":true,"docString":"**Alias** of the forward direction of `List.singleton_perm`."},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f : (a : Œ±) ‚Üí E}\n  {s : Set Œ±} {c : Œ±} (h : IsMaxOn (norm ‚àò f) s c), IsMaxOn (fun (x : Œ±) ‚Ü¶ ‚Äñf x + f c‚Äñ) s c","name":"IsMaxOn.norm_add_self","isProp":true,"docString":"If `f : Œ± ‚Üí E` is a function such that `norm ‚àò f` has a maximum on a set `s` at a point `c`,\nthen the function `fun x => ‚Äñf x + f c‚Äñ` has a maximum on `s` at `c`. "},{"type":"‚àÄ {I : Type u} {f : (a : I) ‚Üí Type v} {Œ± : Type u_1} [inst : (i : I) ‚Üí SMul Œ± (f i)]\n  [inst_1 : ‚àÄ (i : I), Nonempty (f i)] (i : I) [inst_2 : FaithfulSMul Œ± (f i)], FaithfulSMul Œ± ((i : I) ‚Üí f i)","name":"Pi.faithfulSMul_at","isProp":true,"docString":"If `f i` has a faithful scalar action for a given `i`, then so does `Œ† i, f i`. This is\nnot an instance as `i` cannot be inferred. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (a_1 : IsExtrOn f s a),\n  IsExtrOn (‚ÜëOrderDual.toDual ‚àò f) s a","name":"IsExtrOn.dual","isProp":true,"docString":"**Alias** of the reverse direction of `isExtrOn_dual_iff`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} [self : CategoryTheory.IsSplitMono f],\n  Nonempty (CategoryTheory.SplitMono f)","name":"CategoryTheory.IsSplitMono.exists_splitMono","isProp":true,"docString":"There is a splitting "},{"type":"‚àÄ {R : Type u} {a : R} [inst : Semiring R] {p : Polynomial R} (h : Polynomial.leadingCoeff p * a ‚â† 0),\n  Polynomial.natDegree (p * ‚ÜëPolynomial.C a) = Polynomial.natDegree p","name":"Polynomial.natDegree_mul_C_eq_of_mul_ne_zero","isProp":true,"docString":"Although not explicitly stated, the assumptions of lemma `nat_degree_mul_C_eq_of_mul_ne_zero`\nforce the polynomial `p` to be non-zero, via `p.leading_coeff ‚â† 0`.\n"},{"type":"‚àÄ {X : Type u} [inst : TopologicalSpace X] {Œπ : Type u_1} {Y : (a : Œπ) ‚Üí Type u_2}\n  [inst_1 : (i : Œπ) ‚Üí TopologicalSpace (Y i)] {f‚ÇÄ : (i : Œπ) ‚Üí C(X, Y i)} {f‚ÇÅ : (i : Œπ) ‚Üí C(X, Y i)}\n  (F : ‚àÄ (i : Œπ), ContinuousMap.Homotopic (f‚ÇÄ i) (f‚ÇÅ i)),\n  ContinuousMap.Homotopic (ContinuousMap.pi f‚ÇÄ) (ContinuousMap.pi f‚ÇÅ)","name":"ContinuousMap.Homotopic.pi","isProp":true,"docString":"If each `f‚ÇÄ i : C(X, Y i)` is homotopic to `f‚ÇÅ i : C(X, Y i)`, then `ContinuousMap.pi f‚ÇÄ` is\nhomotopic to `ContinuousMap.pi f‚ÇÅ`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {a : Œ±} {s : Set Œ±},\n  a ‚äî inf‚Çõ s ‚â§ inf·µ¢ fun (b : Œ±) ‚Ü¶ inf·µ¢ fun (h : b ‚àà s) ‚Ü¶ a ‚äî b","name":"sup_inf‚Çõ_le_inf·µ¢_sup","isProp":true,"docString":"This is a weaker version of `sup_inf‚Çõ_eq` "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (R : ‚Ñù)\n  (h : ‚àÄ (x : Œ±) (r : ‚Ñù) (a : R ‚â§ r), IsCompact (Metric.closedBall x r)), ProperSpace Œ±","name":"properSpace_of_compact_closedBall_of_le","isProp":true,"docString":"If all closed balls of large enough radius are compact, then the space is proper. Especially\nuseful when the lower bound for the radius is 0. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (a : ‚àÄ (x : Œ±) (y : Œ±), nndist (f x) (f y) = nndist x y), Isometry f","name":"Isometry.of_nndist_eq","isProp":true,"docString":"A map that preserves non-negative distances is an isometry. "},{"type":"‚àÄ (Œ± : Type u_1) [inst : TopologicalSpace Œ±] [inst_1 : DiscreteTopology Œ±], LocallyConnectedSpace Œ±","name":"DiscreteTopology.toLocallyConnectedSpace","isProp":true,"docString":"A space with discrete topology is a locally connected space. "},{"type":"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial œÉ R),\n  ‚àÉ (s : Finset œÉ), ‚àÉ (q : MvPolynomial { x : œÉ // x ‚àà s } R), p = ‚Üë(MvPolynomial.rename Subtype.val) q","name":"MvPolynomial.exists_finset_rename","isProp":true,"docString":"Every polynomial is a polynomial in finitely many variables. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ‚Ñï} {i : Fin (n + 1)},\n  CategoryTheory.CosimplicialObject.Œ¥ X (Fin.succ i) ‚â´ CategoryTheory.CosimplicialObject.œÉ X i =\n    ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor X) (SimplexCategory.mk n))","name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_succ","isProp":true,"docString":"The second part of the third cosimplicial identity "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : CommMonoid Œ≤] [inst_1 : Fintype Œ±] [inst_2 : DecidableEq Œ±] (s : Finset Œ±)\n  (f : (a : Œ±) ‚Üí Œ≤),\n  ((Finset.prod s fun (i : Œ±) ‚Ü¶ f i) * Finset.prod (s·∂ú) fun (i : Œ±) ‚Ü¶ f i) = Finset.prod Finset.univ fun (i : Œ±) ‚Ü¶ f i","name":"Finset.prod_mul_prod_compl","isProp":true,"docString":"Multiplying the products of a function over `s` and over `s·∂ú` gives the whole product.\nFor a version expressed with subtypes, see `Fintype.prod_subtype_mul_prod_subtype`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : RegularSpace Œ±], T3Space (SeparationQuotient Œ±)","name":"instT3SpaceSeparationQuotientInstTopologicalSpaceSeparationQuotient","isProp":true,"docString":"The `SeparationQuotient` of a regular space is a T‚ÇÉ space. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r)\n  (hf : Filter.Tendsto f l Filter.atBot), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x / r) l Filter.atBot","name":"Filter.Tendsto.atBot_div_const","isProp":true,"docString":"If a function tends to negative infinity along a filter, then this function divided by\na positive constant also tends to negative infinity. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.RegularEpi f],\n  CategoryTheory.Epi f","name":"CategoryTheory.RegularEpi.epi","isProp":true,"docString":"Every regular epimorphism is an epimorphism. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {u : (a : ‚Ñï) ‚Üí Œ±} (hu : CauchySeq u),\n  ‚àÉ (R : ‚Ñù), (R > 0 : Prop) ‚àß (‚àÄ (m : ‚Ñï) (n : ‚Ñï), dist (u m) (u n) < R : Prop)","name":"cauchySeq_bdd","isProp":true,"docString":"A Cauchy sequence on the natural numbers is bounded. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {f : M ‚Üí* N}\n  (h : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëf ‚Üëy)) (y : { x : M // x ‚àà S }) (w : N) (z : N),\n  (w * ‚Üë(‚Üë(IsUnit.liftRight (MonoidHom.restrict f S) h) y)‚Åª¬π = z : Prop) ‚Üî (w = ‚Üëf ‚Üëy * z : Prop)","name":"Submonoid.LocalizationMap.mul_inv_left","isProp":true,"docString":"Given a MonoidHom `f : M ‚Üí* N` and Submonoid `S ‚äÜ M` such that `f(S) ‚äÜ NÀ£`, for all\n`w, z : N` and `y ‚àà S`, we have `w * (f y)‚Åª¬π = z ‚Üî w = f y * z`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} (h : 0 < a),\n  -a < a","name":"neg_lt_self","isProp":true,"docString":"**Alias** of `Left.neg_lt_self`."},{"type":"‚àÄ {p : ‚Ñï} {q : ‚Ñö} (hq : q ‚â† 0), padicNorm p q = ‚Üëp ^ (-padicValRat p q)","name":"padicNorm.eq_zpow_of_nonzero","isProp":true,"docString":"Unfolds the definition of the `p`-adic norm of `q` when `q ‚â† 0`. "},{"type":"‚àÄ {X : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E]\n  [inst_2 : TopologicalSpace X] {f : (a : X) ‚Üí E} {s : Set X} {c : X} (h : IsLocalMaxOn (norm ‚àò f) s c),\n  IsLocalMaxOn (fun (x : X) ‚Ü¶ ‚Äñf x + f c‚Äñ) s c","name":"IsLocalMaxOn.norm_add_self","isProp":true,"docString":"If `f : Œ± ‚Üí E` is a function such that `norm ‚àò f` has a local maximum on a set `s` at a point\n`c`, then the function `fun x => ‚Äñf x + f c‚Äñ` has a local maximum on `s` at `c`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : IsSuccArchimedean Œ±]\n  (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) {n : Œ±} {m : Œ±} (h : ‚àÄ (i : Œ±) (a : i ‚àà Set.Ico m n), r (Order.succ i) i)\n  (hmn : m < n), Relation.TransGen r n m","name":"transGen_of_succ_of_gt","isProp":true,"docString":"For `m < n`, `(n, m)` is in the transitive closure of a relation `~` if `succ i ~ i`\nfor all `i` between `n` and `m`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] {f : R ‚Üí+* S} {p : Polynomial S}\n  (hlifts : p ‚àà Polynomial.lifts f),\n  ‚àÉ (q : Polynomial R), (Polynomial.map f q = p : Prop) ‚àß (Polynomial.degree q = Polynomial.degree p : Prop)","name":"Polynomial.mem_lifts_and_degree_eq","isProp":true,"docString":"A polynomial lifts if and only if it can be lifted to a polynomial of the same degree. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : AddCommMonoid Œ±] (t : List Œπ) (f : (a : Œπ) ‚Üí Set Œ±) (g : (a : Œπ) ‚Üí Œ±)\n  (hg : ‚àÄ (i : Œπ) (a : i ‚àà t), g i ‚àà f i), List.sum (List.map g t) ‚àà List.sum (List.map f t)","name":"Set.list_sum_mem_list_sum","isProp":true,"docString":"An n-ary version of `Set.add_mem_add`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {s : Set (Set Œ±)} (self : TopologicalSpace.IsTopologicalBasis s) (t‚ÇÅ : Set Œ±)\n  (a : t‚ÇÅ ‚àà s) (t‚ÇÇ : Set Œ±) (a : t‚ÇÇ ‚àà s) (x : Œ±) (a : x ‚àà t‚ÇÅ ‚à© t‚ÇÇ),\n  ‚àÉ (t‚ÇÉ : Set Œ±), (t‚ÇÉ ‚àà s : Prop) ‚àß ((x ‚àà t‚ÇÉ : Prop) ‚àß (t‚ÇÉ ‚äÜ t‚ÇÅ ‚à© t‚ÇÇ : Prop) : Prop)","name":"TopologicalSpace.IsTopologicalBasis.exists_subset_inter","isProp":true,"docString":"For every point `x`, the set of `t ‚àà s` such that `x ‚àà t` is directed downwards.  "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ' : Sort u_2} (s : (a : Œπ') ‚Üí Set Œ±),\n  (Set.union·µ¢ fun (i : Œπ') ‚Ü¶ s i) =\n    Set.union·µ¢ fun (t : Finset (PLift Œπ')) ‚Ü¶\n      Set.union·µ¢ fun (i : PLift Œπ') ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà t) ‚Ü¶ s (PLift.down i)","name":"Set.union·µ¢_eq_union·µ¢_finset'","isProp":true,"docString":"Union of an indexed family of sets `s : Œπ ‚Üí Set Œ±` is equal to the union of the unions\nof finite subfamilies. This version works for `Œπ : Sort*`. See also `union·µ¢_eq_union·µ¢_finset` for\na version that assumes `Œπ : Type _` but avoids `plift`s in the right hand side. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 :\n    ‚àÄ {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z},\n      CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan f g)],\n  CategoryTheory.Limits.HasPullbacks C","name":"CategoryTheory.Limits.hasPullbacks_of_hasLimit_cospan","isProp":true,"docString":"If `C` has all limits of diagrams `cospan f g`, then it has all pullbacks "},{"type":"‚àÄ {M : Type u_1} {A : Type u_2} [inst : AddZeroClass A] [self : DistribSMul M A] (a : M) (x : A) (y : A),\n  a ‚Ä¢ (x + y) = a ‚Ä¢ x + a ‚Ä¢ y","name":"DistribSMul.smul_add","isProp":true,"docString":"Scalar multiplication distributes across addition "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Add G] [inst_1 : Add H] {A : Finset G} {B : Finset G} {a0 : G} {b0 : G}\n  (f : G ‚Ü™ H) (mul : ‚àÄ (x : G) (y : G), ‚Üëf (x + y) = ‚Üëf x + ‚Üëf y),\n  (UniqueAdd (Finset.map f A) (Finset.map f B) (‚Üëf a0) (‚Üëf b0) : Prop) ‚Üî (UniqueAdd A B a0 b0 : Prop)","name":"UniqueAdd.addHom_map_iff","isProp":true,"docString":"`UniqueAdd` is preserved under embeddings that are additive.\n\nSee `UniqueAdd.addHom_image_iff` for a version with swapped bundling."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)\n  [inst_1 : CategoryTheory.Limits.HasPushout f g], CategoryTheory.Limits.HasPushout g f","name":"CategoryTheory.Limits.hasPushout_symmetry","isProp":true,"docString":"Making this a global instance would make the typeclass seach go in an infinite loop. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±},\n  EMetric.hausdorffEdist (closure s) t = EMetric.hausdorffEdist s t","name":"EMetric.hausdorffEdist_closure‚ÇÅ","isProp":true,"docString":"Replacing a set by its closure does not change the Hausdorff edistance. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} (R : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R] [inst_2 : Monoid Œ±]\n  [inst_3 : Module R E] [inst_4 : DistribMulAction Œ± E] (n : ‚Ñ§) (s : Œ±) (x : E), (‚Üën)‚Åª¬π ‚Ä¢ s ‚Ä¢ x = s ‚Ä¢ (‚Üën)‚Åª¬π ‚Ä¢ x","name":"inv_int_cast_smul_comm","isProp":true,"docString":"If `E` is a vector space over a division ring `R` and has a monoid action by `Œ±`, then that\naction commutes by scalar multiplication of inverses of integers in `R` "},{"type":"‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (s : Sym Œ± n), Sym.map (fun (x : Œ±) ‚Ü¶ x) s = s","name":"Sym.map_id'","isProp":true,"docString":"Note: `sym.map_id` is not simp-normal, as simp ends up unfolding `id` with `sym.map_congr` "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≥ : Type u_1} {u‚ÇÅ : UniformSpace Œ≥} {u‚ÇÇ : UniformSpace Œ≥},\n  UniformFun.uniformSpace Œ± Œ≥ = UniformFun.uniformSpace Œ± Œ≥ ‚äì UniformFun.uniformSpace Œ± Œ≥","name":"UniformFun.inf_eq","isProp":true,"docString":"If `u‚ÇÅ` and `u‚ÇÇ` are two uniform structures on `Œ≥`, then\n`ùí∞(Œ±, Œ≥, u‚ÇÅ ‚äì u‚ÇÇ) = ùí∞(Œ±, Œ≥, u‚ÇÅ) ‚äì ùí∞(Œ±, Œ≥, u‚ÇÇ)`. "},{"type":"‚àÄ (n : ‚Ñï+), PrimeMultiset.prod (PNat.factorMultiset n) = n","name":"PNat.prod_factorMultiset","isProp":true,"docString":"The product of the factors is the original number "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±] {l : Filter Œπ}\n  [inst_2 : Filter.NeBot l] {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} {f : (a : X) ‚Üí Œ±} {x‚ÇÄ : X} (h‚ÇÅ : Filter.Tendsto F l (nhds f))\n  (h‚ÇÇ : EquicontinuousAt F x‚ÇÄ), ContinuousAt f x‚ÇÄ","name":"Filter.Tendsto.continuousAt_of_equicontinuousAt","isProp":true,"docString":"If `ùìï : Œπ ‚Üí X ‚Üí Œ±` tends to `f : X ‚Üí Œ±` *pointwise* along some nontrivial filter, and if the\nfamily `ùìï` is equicontinuous at some `x‚ÇÄ : X`, then the limit is continuous at `x‚ÇÄ`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {x : M} {y : M} (a : ‚Üëc x y), ‚Üëc y x","name":"AddCon.symm","isProp":true,"docString":"Additive congruence relations are symmetric."},{"type":"‚àÄ {H : Type u} [inst : TopologicalSpace H], ClosedUnderRestriction idRestrGroupoid","name":"closedUnderRestriction_idRestrGroupoid","isProp":true,"docString":"The trivial restriction-closed groupoid is indeed `ClosedUnderRestriction`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {x : Œ±} {y : Œ±} (h : x = y), y ‚â§ x","name":"Eq.ge","isProp":true,"docString":"If `x = y` then `y ‚â§ x`. Note: this lemma uses `y ‚â§ x` instead of `x ‚â• y`, because `le` is used\nalmost exclusively in mathlib. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (self : Submodule R M)\n  (c : R) {x : M} (a : x ‚àà AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup (Submodule.toAddSubmonoid self))),\n  c ‚Ä¢ x ‚àà AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup (Submodule.toAddSubmonoid self))","name":"Submodule.smul_mem'","isProp":true,"docString":"The carrier set is closed under scalar multiplication. "},{"type":"‚àÄ {Œ± : Type u} (L : List Œ±) {i : ‚Ñï} {j : Fin (List.length (List.drop i L))},\n  List.get (List.drop i L) j =\n    List.get L\n      { val := i + ‚Üëj,\n        isLt :=\n          ((Iff.mp\n                ((lt_tsub_iff_left=:(‚Üëj < List.length L - i : Prop) ‚Üî\n                      (i + ‚Üëj < List.length L :\n                        Prop))=:(‚Üëj < List.length L - i : Prop) ‚Üî (i + ‚Üëj < List.length L : Prop))\n                ((Eq.rec ((Fin.isLt j=:‚Üëj < List.length (List.drop i L))=:‚Üëj < List.length (List.drop i L))\n                      ((List.length_drop i\n                            L=:List.length (List.drop i L) =\n                            List.length L -\n                              i)=:List.length (List.drop i L) =\n                          List.length L -\n                            i)=:‚Üëj <\n                      List.length L - i)=:‚Üëj < List.length L - i)=:i + ‚Üëj < List.length L)=:i + ‚Üëj < List.length L) }","name":"List.get_drop'","isProp":true,"docString":"The `i + j`-th element of a list coincides with the `j`-th element of the list obtained by\ndropping the first `i` elements. Version designed to rewrite from the small list to the big list. "},{"type":"‚àÄ {k : ‚Ñï} {A : Finset ‚Ñï} (h‚ÇÅ : ‚àÄ {x : ‚Ñï} (a : x ‚àà A), x < k), Finset.sum A (Nat.pow 2) < 2 ^ k","name":"Nat.sum_two_pow_lt","isProp":true,"docString":"If everything in `A` is less than `k`, we can bound the sum of powers. "},{"type":"‚àÄ (m : ‚Ñï) (n : ‚Ñï), Nat.fib (Nat.gcd m n) = Nat.gcd (Nat.fib m) (Nat.fib n)","name":"Nat.fib_gcd","isProp":true,"docString":"`fib n` is a strong divisibility sequence,\nsee https://proofwiki.org/wiki/GCD_of_Fibonacci_Numbers "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (Œ¥ : ‚Ñù) {E‚ÇÅ : Set Œ±} {E‚ÇÇ : Set Œ±} (h : E‚ÇÅ ‚äÜ E‚ÇÇ),\n  Metric.cthickening Œ¥ E‚ÇÅ ‚äÜ Metric.cthickening Œ¥ E‚ÇÇ","name":"Metric.cthickening_subset_of_subset","isProp":true,"docString":"The closed thickening `Metric.cthickening Œ¥ E` with a fixed thickening radius `Œ¥` is\nan increasing function of the subset `E`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : StrongRankCondition K] {Œπ : Type w} [inst_4 : Fintype Œπ] (h : Basis Œπ K V),\n  FiniteDimensional.finrank K V = Fintype.card Œπ","name":"FiniteDimensional.finrank_eq_card_basis","isProp":true,"docString":"If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. "},{"type":"‚àÄ {Œπ : Type u_1} (self : ComplexShape Œπ) {i : Œπ} {j : Œπ} {j' : Œπ} (a : ComplexShape.Rel self i j)\n  (a : ComplexShape.Rel self i j'), j = j'","name":"ComplexShape.next_eq","isProp":true,"docString":"There is at most one nonzero differential from `X i`. "},{"type":"‚àÄ (n : ‚Ñï) (k : ‚Ñï), Nat.ascFactorial n k = Nat.factorial (n + k) / Nat.factorial n","name":"Nat.ascFactorial_eq_div","isProp":true,"docString":"Avoid in favor of `Nat.factorial_mul_ascFactorial` if you can. ‚Ñï-division isn't worth it. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) (m : Multiset K) (a : ‚àÄ (a : K) (a_1 : a ‚àà m), a ‚àà s),\n  Multiset.sum m ‚àà s","name":"Subfield.multiset_sum_mem","isProp":true,"docString":"Sum of a multiset of elements in a `Subfield` is in the `Subfield`. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : TopologicalSpace ùïú] [inst_1 : OrderedRing ùïú] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module ùïú E] {A : Set E} {x : E},\n  (x ‚àà Set.exposedPoints ùïú A : Prop) ‚Üî (IsExposed ùïú A {x} : Prop)","name":"mem_exposedPoints_iff_exposed_singleton","isProp":true,"docString":"Exposed points exactly correspond to exposed singletons. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\n  [inst_3 : TopologicalSpace.SeparableSpace G] [inst_4 : LocallyCompactSpace G], SigmaCompactSpace G","name":"SeparableLocallyCompactGroup.sigmaCompactSpace","isProp":true,"docString":"Every locally compact separable topological group is œÉ-compact.\nNote: this is not true if we drop the topological group hypothesis. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] (x : Œ±) (y : Œ±),\n  ((fun (x_1 : Œ±) ‚Ü¶ x_1 * x) ‚àò fun (x : Œ±) ‚Ü¶ x * y) = fun (x_1 : Œ±) ‚Ü¶ x_1 * (y * x)","name":"comp_mul_right","isProp":true,"docString":"Composing two multiplications on the right by `y` and `x`\nis equal to a multiplication on the right by `y * x`.\n"},{"type":"‚àÄ {n : ‚Ñï} {a : ‚Ñï} {b : ‚Ñï} (m : ‚Ñï) (a_1 : a ‚â° b [MOD n * m]), a ‚â° b [MOD n]","name":"Nat.ModEq.of_mul_right","isProp":true,"docString":"Cancel right multiplication in the modulus.\n\nFor cancelling right multiplication on both sides of the `‚â°`, see `nat.modeq.mul_right_cancel'`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {s : Set Œ≤} {f : (a : Œ≤) ‚Üí Œ±} (hf : ContinuousOn f s)\n  (hsc : IsClosed s) {x‚ÇÄ : Œ≤} (h‚ÇÄ : x‚ÇÄ ‚àà s)\n  (hc : Filter.Eventually (fun (x : Œ≤) ‚Ü¶ f x ‚â§ f x‚ÇÄ) (Filter.cocompact Œ≤ ‚äì Filter.principal s)),\n  ‚àÉ (x : Œ≤), (x ‚àà s : Prop) ‚àß (‚àÄ (y : Œ≤) (a : y ‚àà s), f y ‚â§ f x : Prop)","name":"ContinuousOn.exists_forall_ge'","isProp":true,"docString":"The **extreme value theorem**: if a function `f` is continuous on a closed set `s` and it is\nsmaller than a value in its image away from compact sets, then it has a maximum on this set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : T2Space Œ±]\n  [inst_3 : ContinuousAdd Œ±] {f : (a : Œ≤) ‚Üí Œ±} (b : Œ≤) (hf : Summable (Function.update f b 0)),\n  (tsum fun (x : Œ≤) ‚Ü¶ f x) = f b + tsum fun (x : Œ≤) ‚Ü¶ if (x = b : Prop) then 0 else f x","name":"tsum_eq_add_tsum_ite'","isProp":true,"docString":"Version of `tsum_eq_add_tsum_ite` for `AddCommMonoid` rather than `AddCommGroup`.\nRequires a different convergence assumption involving `Function.update`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} (Mf : Monotone f) (x : Œ±),\n  Filter.Tendsto f (nhdsWithin x (Set.Iio x)) (nhds (sup‚Çõ (f '' Set.Iio x)))","name":"Monotone.tendsto_nhdsWithin_Iio","isProp":true,"docString":"A monotone map has a limit to the left of any point `x`, equal to `sup‚Çõ (f '' (Iio x))`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Finset Œ±} (h : Monotone f)\n  (h' : ‚àÄ (x : Œ±), ‚àÉ (n : Œ≤), x ‚àà f n), Filter.Tendsto f Filter.atTop Filter.atTop","name":"Monotone.tendsto_atTop_finset","isProp":true,"docString":"**Alias** of `Filter.tendsto_atTop_finset_of_monotone`."},{"type":"‚àÄ {R : Type u_3} {S : Type u_1} {M : Type u_2} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst : IsScalarTower R S M] (a : R) (ab : IsSMulRegular M (a ‚Ä¢ s)), IsSMulRegular M s","name":"IsSMulRegular.of_smul","isProp":true,"docString":"If an element `b` becomes `M`-regular after multiplying it on the left by an `M`-regular\nelement, then `b` is `M`-regular. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±} {y : Œ±} (h : Set.InjOn f s) (hx : x ‚àà s)\n  (hy : y ‚àà s) (a : x ‚â† y), f x ‚â† f y","name":"Set.InjOn.ne","isProp":true,"docString":"**Alias** of the reverse direction of `Set.InjOn.ne_iff`."},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M), conGen ‚Üëc = c","name":"Con.conGen_of_con","isProp":true,"docString":"Congruence relations equal the smallest congruence relation in which they are contained. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ≤) ‚Üí Œ≥} {x : Œ±} {y : Œ≤} (hf : ContinuousAt f y),\n  ContinuousAt (fun (x : Œ± √ó Œ≤) ‚Ü¶ f (Prod.snd x)) (x, y)","name":"ContinuousAt.snd'","isProp":true,"docString":"Precomposing `f` with `Prod.snd` is continuous at `(x, y)` "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R] (l : List (Polynomial R)),\n  Polynomial.degree (List.prod l) = List.sum (List.map Polynomial.degree l)","name":"Polynomial.degree_list_prod","isProp":true,"docString":"The degree of a product of polynomials is equal to\nthe sum of the degrees, where the degree of the zero polynomial is ‚ä•.\n`[Nontrivial R]` is needed, otherwise for `l = []` we have `‚ä•` in the LHS and `0` in the RHS.\n"},{"type":"‚àÄ (f : CircleDeg1Lift) (x : ‚Ñù),\n  Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ (‚Üë(f ^ n) x - x) / ‚Üën) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))","name":"CircleDeg1Lift.tendsto_translationNumber","isProp":true,"docString":"For any `x : ‚Ñù` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. "},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup E] [inst_2 : AddCommGroup F]\n  [inst_3 : Module R E] [inst_4 : Module R F] [inst_5 : TopologicalSpace E] [inst_6 : TopologicalSpace F]\n  [inst_7 : ContinuousAdd E] [inst_8 : ContinuousAdd F] [inst_9 : TopologicalSpace R] [inst_10 : ContinuousSMul R E]\n  [inst_11 : ContinuousSMul R F] {f : E ‚Üí‚Çó.[R] F} (hf : LinearPMap.IsClosable f),\n  LinearPMap.IsClosable (LinearPMap.closure f)","name":"LinearPMap.IsClosable.closureIsClosable","isProp":true,"docString":"If `f` is closable, then the closure is closable. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} {f : P ‚ü∂ Q} [self : CategoryTheory.StrongMono f]\n  ‚¶ÉX : C‚¶Ñ ‚¶ÉY : C‚¶Ñ (z : X ‚ü∂ Y) [inst_1 : CategoryTheory.Epi z], CategoryTheory.HasLiftingProperty z f","name":"CategoryTheory.StrongMono.rlp","isProp":true,"docString":"The right lifting property with respect to all epimorphisms "},{"type":"‚àÄ (Œ± : Type u_1) (Œ≤ : Type u_2) {Œπ : Type u_3} [inst : UniformSpace Œ≤] (ùîñ : Set (Set Œ±)) (h : Set.Nonempty ùîñ)\n  (h' : DirectedOn (fun (x : Set Œ±) (x_1 : Set Œ±) ‚Ü¶ x ‚äÜ x_1) ùîñ) {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set (Œ≤ √ó Œ≤)}\n  (hb : Filter.HasBasis (uniformity Œ≤) p s),\n  Filter.HasBasis (uniformity (UniformOnFun Œ± Œ≤ ùîñ))\n    (fun (Si : Set Œ± √ó Œπ) ‚Ü¶ (Prod.fst Si ‚àà ùîñ : Prop) ‚àß (p (Prod.snd Si) : Prop)) fun (Si : Set Œ± √ó Œπ) ‚Ü¶\n    UniformOnFun.gen ùîñ (Prod.fst Si) (s (Prod.snd Si))","name":"UniformOnFun.hasBasis_uniformity_of_basis","isProp":true,"docString":"If `ùîñ : Set (Set Œ±)` is nonempty and directed and `ùìë` is a filter basis of `ùì§ Œ≤`, then the\nuniformity of `Œ± ‚Üí·µ§[ùîñ] Œ≤` admits the family `{(f, g) | ‚àÄ x ‚àà S, (f x, g x) ‚àà V}` for `S ‚àà ùîñ` and\n`V ‚àà ùìë` as a filter basis. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] [inst_1 : Add Œ±] [inst_2 : Sub Œ±] [self : OrderedSub Œ±] (a : Œ±) (b : Œ±) (c : Œ±),\n  (a - b ‚â§ c : Prop) ‚Üî (a ‚â§ c + b : Prop)","name":"OrderedSub.tsub_le_iff_right","isProp":true,"docString":"`a - b` provides a lower bound on `c` such that `a ‚â§ c + b`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Membership Œ± Œ≤] {s : Œ≤} {a : Œ±} {b : Œ±} (h : a ‚àà s) (a_1 : ¬¨(b ‚àà s : Prop)),\n  a ‚â† b","name":"Membership.mem.ne_of_not_mem","isProp":true,"docString":"**Alias** of `ne_of_mem_of_not_mem`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {x : G} {y : G}, (y ‚àà Subgroup.closure {x} : Prop) ‚Üî (‚àÉ (n : ‚Ñ§), x ^ n = y : Prop)","name":"Subgroup.mem_closure_singleton","isProp":true,"docString":"The subgroup generated by an element of a group equals the set of integer number powers of\nthe element. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommSemiring R] [inst_1 : LinearOrder Œπ] (s : Finset Œπ) (f : (a : Œπ) ‚Üí R)\n  (g : (a : Œπ) ‚Üí R),\n  (Finset.prod s fun (i : Œπ) ‚Ü¶ f i + g i) =\n    (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) +\n      Finset.sum s fun (i : Œπ) ‚Ü¶\n        (g i * Finset.prod (Finset.filter (fun (x : Œπ) ‚Ü¶ x < i) s) fun (j : Œπ) ‚Ü¶ f j + g j) *\n          Finset.prod (Finset.filter (fun (j : Œπ) ‚Ü¶ i < j) s) fun (j : Œπ) ‚Ü¶ f j","name":"Finset.prod_add_ordered","isProp":true,"docString":"`‚àè i, (f i + g i) = (‚àè i, f i) + ‚àë i, g i * (‚àè j < i, f j + g j) * (‚àè j > i, f j)`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : (a : Œ±) ‚Üí Œ≤} {a : Filter Œ±} {b‚ÇÅ : Filter Œ≤} {b‚ÇÇ : Filter Œ≤}\n  (hf : Filter.Tendsto f a b‚ÇÅ) [inst : Filter.NeBot a] (hb : Disjoint b‚ÇÅ b‚ÇÇ), ¬¨(Filter.Tendsto f a b‚ÇÇ : Prop)","name":"Filter.Tendsto.not_tendsto","isProp":true,"docString":"If two filters are disjoint, then a function cannot tend to both of them along a non-trivial\nfilter. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {s : Set (Set Œ±)} (hs : t = TopologicalSpace.generateFrom s),\n  TopologicalSpace.IsTopologicalBasis\n    ((fun (f : Set (Set Œ±)) ‚Ü¶ ‚ãÇ‚ÇÄ f) '' setOf fun (f : Set (Set Œ±)) ‚Ü¶ (Set.Finite f : Prop) ‚àß (f ‚äÜ s : Prop))","name":"TopologicalSpace.isTopologicalBasis_of_subbasis","isProp":true,"docString":"If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} (f : (a : Œ±) ‚Üí Œ≤) {m : ‚Ñï} (v : (a : Fin m) ‚Üí Œ±), FinVec.map f v = f ‚àò v","name":"FinVec.map_eq","isProp":true,"docString":"This can be use to prove\n```lean\nexample {f : Œ± ‚Üí Œ≤} (a‚ÇÅ a‚ÇÇ : Œ±) : f ‚àò ![a‚ÇÅ, a‚ÇÇ] = ![f a‚ÇÅ, f a‚ÇÇ] :=\n  (map_eq _ _).symm\n```\n"},{"type":"‚àÄ {ùïú : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú]\n  {l : Filter Œ±} {f : (a : Œ±) ‚Üí ùïú} {g : (a : Œ±) ‚Üí ùïú} {C : ùïú} (hC : 0 < C) (hf : Filter.Tendsto f l Filter.atBot)\n  (hg : Filter.Tendsto g l (nhds C)), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ f x * g x) l Filter.atBot","name":"Filter.Tendsto.atBot_mul","isProp":true,"docString":"In a linearly ordered field with the order topology, if `f` tends to `Filter.atBot` and `g`\ntends to a positive constant `C` then `f * g` tends to `Filter.atBot`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ∫ : Type u_4} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} (h : UniformEquicontinuous F) (u : (a : Œ∫) ‚Üí Œπ), UniformEquicontinuous (F ‚àò u)","name":"UniformEquicontinuous.comp","isProp":true,"docString":"Taking sub-families preserves uniform equicontinuity. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : CategoryTheory.Presieve X}\n  (t : CategoryTheory.Presieve.IsSeparatedFor P R)\n  (a :\n    ‚àÄ (x : CategoryTheory.Presieve.FamilyOfElements P R) (a : CategoryTheory.Presieve.FamilyOfElements.Compatible x),\n      ‚àÉ (t : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor P) (Opposite.op X)),\n        CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation x t),\n  CategoryTheory.Presieve.IsSheafFor P R","name":"CategoryTheory.Presieve.IsSeparatedFor.isSheafFor","isProp":true,"docString":"If `P` is separated for `R` and every family has an amalgamation, then `P` is a sheaf for `R`.\n"},{"type":"‚àÄ {E : Type u_1} {F : Type u_2} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F] {s : Set E} {f : (a : E) ‚Üí F}\n  {C : NNReal} (a : LipschitzOnWith C f s) ‚¶Éx : E‚¶Ñ (a : x ‚àà s) ‚¶Éy : E‚¶Ñ (a : y ‚àà s), ‚Äñf x / f y‚Äñ ‚â§ ‚ÜëC * ‚Äñx / y‚Äñ","name":"LipschitzOnWith.norm_div_le","isProp":true,"docString":"**Alias** of the forward direction of `lipschitzOnWith_iff_norm_div_le`."},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] {s : Set R}, s ‚äÜ ‚Üë(NonUnitalSubsemiring.closure s)","name":"NonUnitalSubsemiring.subset_closure","isProp":true,"docString":"The non-unital subsemiring generated by a set includes the set. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictAntiOn f s) (hg : AntitoneOn g s), StrictAntiOn (fun (x : Œ≤) ‚Ü¶ f x * g x) s","name":"StrictAntiOn.mul_antitone'","isProp":true,"docString":"The product of a strictly antitone function and a antitone function is strictly antitone. "},{"type":"‚àÄ {Œ± : Type u} [inst : Lattice Œ±] [inst_1 : AddCommGroup Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (a : Œ±) (b : Œ±),\n  abs (a + b) ‚â§ abs a + abs b","name":"LatticeOrderedCommGroup.abs_add_le","isProp":true,"docString":"The absolute value satisfies the triangle inequality."},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {u : V} {v : V} (p : SimpleGraph.Walk G u v) ‚¶Ée : Sym2 V‚¶Ñ\n  (a : e ‚àà SimpleGraph.Walk.edges p), e ‚àà SimpleGraph.edgeSet G","name":"SimpleGraph.Walk.edges_subset_edgeSet","isProp":true,"docString":"Every edge in a walk's edge list is an edge of the graph.\nIt is written in this form (rather than using `‚äÜ`) to avoid unsightly coercions. "},{"type":"‚àÄ {Œ± : Sort u} (b : PLift Œ±), { down := PLift.down b } = b","name":"PLift.up_down","isProp":true,"docString":"Bijection between `Œ±` and `PLift Œ±` "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} [inst : Infinite Œ±] [inst : Finite Œ≤] (f : (a : Œ±) ‚Üí Œ≤),\n  ‚àÉ (x : Œ±), ‚àÉ (y : Œ±), (x ‚â† y : Prop) ‚àß (f x = f y : Prop)","name":"Finite.exists_ne_map_eq_of_infinite","isProp":true,"docString":"The pigeonhole principle for infinitely many pigeons in finitely many pigeonholes. If there are\ninfinitely many pigeons in finitely many pigeonholes, then there are at least two pigeons in the\nsame pigeonhole.\n\nSee also: `Fintype.exists_ne_map_eq_of_card_lt`, `Finite.exists_infinite_fiber`.\n"},{"type":"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : (a : Œπ) ‚Üí Type w}\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] {N : Type u‚ÇÅ} [inst_3 : AddCommMonoid N]\n  [inst_4 : Module R N] (œà : (DirectSum Œπ fun (i : Œπ) ‚Ü¶ M i) ‚Üí‚Çó[R] N) (f : DirectSum Œπ fun (i : Œπ) ‚Ü¶ M i),\n  ‚Üëœà f = ‚Üë(DirectSum.toModule R Œπ N fun (i : Œπ) ‚Ü¶ LinearMap.comp œà (DirectSum.lof R Œπ M i)) f","name":"DirectSum.toModule.unique","isProp":true,"docString":"Every linear map from a direct sum agrees with the one obtained by applying\nthe universal property to each of its components. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : LinearOrder Œ±] {f : (a : Fin n) ‚Üí Œ±} {œÉ : Equiv.Perm (Fin n)},\n  (œÉ = Tuple.sort f : Prop) ‚Üî (StrictMono ‚Üë(Equiv.trans œÉ (Tuple.graphEquiv‚ÇÅ f)) : Prop)","name":"Tuple.eq_sort_iff'","isProp":true,"docString":"A permutation `œÉ` equals `sort f` if and only if the map `i ‚Ü¶ (f (œÉ i), œÉ i)` is\nstrictly monotone (w.r.t. the lexicographic ordering on the target). "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : IsClosed s) (ht : IsClosed t)\n  (fin : EMetric.hausdorffEdist s t ‚â† ‚ä§), (Metric.hausdorffDist s t = 0 : Prop) ‚Üî (s = t : Prop)","name":"IsClosed.hausdorffDist_zero_iff_eq","isProp":true,"docString":"Two closed sets are at zero Hausdorff distance if and only if they coincide "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : AddCommMonoid M] (s : Finset (Œ± √ó Œ≤)) (f : (a : Œ± √ó Œ≤) ‚Üí M),\n  (finsum fun (ab : Œ± √ó Œ≤) ‚Ü¶ finsum fun (_h : ab ‚àà s) ‚Ü¶ f ab) =\n    finsum fun (a : Œ±) ‚Ü¶ finsum fun (b : Œ≤) ‚Ü¶ finsum fun (_h : (a, b) ‚àà s) ‚Ü¶ f (a, b)","name":"finsum_mem_finset_product","isProp":true,"docString":"See also `finsum_mem_finset_product'`."},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {A : C} {B : C} {X : C} {Y : C} {f : A ‚ü∂ X} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\n  {g : B ‚ü∂ Y} {sq : CategoryTheory.CommSq f i p g} (self : CategoryTheory.CommSq.LiftStruct sq),\n  i ‚â´ CategoryTheory.CommSq.LiftStruct.l self = f","name":"CategoryTheory.CommSq.LiftStruct.fac_left","isProp":true,"docString":"The upper left triangle commutes. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T2Space Œ±] [inst_2 : CompactSpace Œ±],\n  T2Space (ConnectedComponents Œ±)","name":"ConnectedComponents.t2","isProp":true,"docString":"`ConnectedComponents Œ±` is Hausdorff when `Œ±` is Hausdorff and compact "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {B : Finset (Finset Œ±)} {n : ‚Ñï}\n  (h : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), Finset.card (Finset.filter ((fun (x : Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚àà x_1) a) B) = n),\n  (Finset.sum B fun (t : Finset Œ±) ‚Ü¶ Finset.card (s ‚à© t)) = Finset.card s * n","name":"Finset.sum_card_inter","isProp":true,"docString":"If every element belongs to exactly `n` Finsets, then the sum of their sizes is `n` times how\nmany they are. "},{"type":"‚àÄ {Œ± : Type u_1} (s : Set Œ±) (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) (a : Pairwise fun (x : ‚Üës) (y : ‚Üës) ‚Ü¶ r ‚Üëx ‚Üëy),\n  Set.Pairwise s r","name":"Pairwise.set_of_subtype","isProp":true,"docString":"**Alias** of the forward direction of `pairwise_subtype_iff_pairwise_set`."},{"type":"‚àÄ {V : Type u} [inst : Fintype V] {G : SimpleGraph V} [inst_1 : DecidableRel (SimpleGraph.Adj G)] {v : V} {w : V}\n  (h : SimpleGraph.Adj G v w), Fintype.card ‚Üë(SimpleGraph.commonNeighbors G v w) < SimpleGraph.degree G v","name":"SimpleGraph.Adj.card_commonNeighbors_lt_degree","isProp":true,"docString":"If the condition `G.Adj v w` fails, then `card_commonNeighbors_le_degree` is\nthe best we can do in general. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CoheytingAlgebra Œ±] (a : Œ±), ‚ä§ \\ a = Ôø¢a","name":"CoheytingAlgebra.top_sdiff","isProp":true,"docString":"`‚ä§ \\ a` is `Ôø¢a` "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (s : Submodule K V)\n  (t : Submodule K V) [inst_3 : FiniteDimensional K { x : V // x ‚àà s }]\n  [inst_4 : FiniteDimensional K { x : V // x ‚àà t }],\n  FiniteDimensional.finrank K { x : V // x ‚àà s ‚äî t } + FiniteDimensional.finrank K { x : V // x ‚àà s ‚äì t } =\n    FiniteDimensional.finrank K { x : V // x ‚àà s } + FiniteDimensional.finrank K { x : V // x ‚àà t }","name":"Submodule.finrank_sup_add_finrank_inf_eq","isProp":true,"docString":"The sum of the dimensions of s + t and s ‚à© t is the sum of the dimensions of s and t "},{"type":"‚àÄ {R : Type u_1} [inst : AddCancelMonoid R] (g : R), IsAddRegular g","name":"isAddRegular_of_addCancelMonoid","isProp":true,"docString":"Elements of an add cancel monoid are regular.\nAdd cancel semigroups do not appear to exist."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasEqualizer f g]\n  [inst_2 : CategoryTheory.Epi (CategoryTheory.Limits.equalizer.Œπ f g)], f = g","name":"CategoryTheory.Limits.eq_of_epi_equalizer","isProp":true,"docString":"If the equalizer of two morphisms is an epimorphism, then the two morphisms are equal. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} (h : (a : Œ≤) ‚Üí Œ≥) (g : (a : Œ±) ‚Üí Œ≤) (l : List Œ±),\n  List.map (h ‚àò g) l = List.map h (List.map g l)","name":"List.comp_map","isProp":true,"docString":"A single `List.map` of a composition of functions is equal to\ncomposing a `List.map` with another `List.map`, fully applied.\nThis is the reverse direction of `List.map_map`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œπ' : Sort u_2} {f : Filter Œ±} [h : Filter.IsCountablyGenerated f] {p : (a : Œπ') ‚Üí Prop}\n  {s : (a : Œπ') ‚Üí Set Œ±} (hs : Filter.HasBasis f p s),\n  ‚àÉ (x : (a : ‚Ñï) ‚Üí Œπ'), (‚àÄ (i : ‚Ñï), p (x i) : Prop) ‚àß (Filter.HasAntitoneBasis f fun (i : ‚Ñï) ‚Ü¶ s (x i) : Prop)","name":"Filter.HasBasis.exists_antitone_subbasis","isProp":true,"docString":"If `f` is countably generated and `f.HasBasis p s`, then `f` admits a decreasing basis\nenumerated by natural numbers such that all sets have the form `s i`. More precisely, there is a\nsequence `i n` such that `p (i n)` for all `n` and `s (i n)` is a decreasing sequence of sets which\nforms a basis of `f`"},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {f : (a : Œ±) ‚Üí Œ≤} [inst : CommMonoid Œ≤] (R : Setoid Œ±)\n  [inst_1 : DecidableRel Setoid.r],\n  (Finset.prod s fun (x : Œ±) ‚Ü¶ f x) =\n    Finset.prod (Finset.image Quotient.mk'' s) fun (xbar : Quotient R) ‚Ü¶\n      Finset.prod (Finset.filter (fun (x : Œ±) ‚Ü¶ Quotient.mk R x = xbar) s) fun (y : Œ±) ‚Ü¶ f y","name":"Finset.prod_partition","isProp":true,"docString":"A product can be partitioned into a product of products, each equivalent under a setoid. "},{"type":"‚àÄ {x : ‚Ñ§} {y : ‚Ñ§} {z : ‚Ñ§} (h : PythagoreanTriple x y z) (k : ‚Ñ§), PythagoreanTriple (k * x) (k * y) (k * z)","name":"PythagoreanTriple.mul","isProp":true,"docString":"A triple is still a triple if you multiply `x`, `y` and `z`\nby a constant `k`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S‚ÇÅ : Submodule K V)\n  (S‚ÇÇ : Submodule K V) [inst_3 : FiniteDimensional K { x : V // x ‚àà S‚ÇÅ }], FiniteDimensional K { x : V // x ‚àà S‚ÇÅ ‚äì S‚ÇÇ }","name":"Submodule.finiteDimensional_inf_left","isProp":true,"docString":"The inf of two submodules, the first finite-dimensional, is\nfinite-dimensional. "},{"type":"‚àÄ {n : Type v} {Œ± : Type w} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  {Œ≤ : Type u_1} (s : Finset Œ≤) (f : (a : Œ≤) ‚Üí (a : n) ‚Üí Œ±),\n  (Finset.sum s fun (x : Œ≤) ‚Ü¶ ‚Üë(Matrix.cramer A) (f x)) = ‚Üë(Matrix.cramer A) (Finset.sum s fun (x : Œ≤) ‚Ü¶ f x)","name":"Matrix.sum_cramer","isProp":true,"docString":"Use linearity of `cramer` to take it out of a summation. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (R : CategoryTheory.Presieve X)\n  [inst_1 : CategoryTheory.Limits.HasPullbacks C],\n  (CategoryTheory.Presieve.IsSheafFor P R : Prop) ‚Üî\n    (Nonempty\n        (CategoryTheory.Limits.IsLimit\n          (CategoryTheory.Limits.Fork.ofŒπ (CategoryTheory.Equalizer.forkMap P R)\n            ((CategoryTheory.Equalizer.Presieve.w P\n                  R=:CategoryTheory.Equalizer.forkMap P R ‚â´ CategoryTheory.Equalizer.Presieve.firstMap P R =\n                  CategoryTheory.Equalizer.forkMap P R ‚â´\n                    CategoryTheory.Equalizer.Presieve.secondMap P\n                      R)=:CategoryTheory.Equalizer.forkMap P R ‚â´ CategoryTheory.Equalizer.Presieve.firstMap P R =\n                CategoryTheory.Equalizer.forkMap P R ‚â´ CategoryTheory.Equalizer.Presieve.secondMap P R))) :\n      Prop)","name":"CategoryTheory.Equalizer.Presieve.sheaf_condition","isProp":true,"docString":"`P` is a sheaf for `R`, iff the fork given by `w` is an equalizer.\nSee <https://stacks.math.columbia.edu/tag/00VM>.\n"},{"type":"‚àÄ (Œ± : Type u) (r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop) [s : IsTotalPreorder Œ± r], IsPreorder Œ± r","name":"isTotalPreorder_isPreorder","isProp":true,"docString":"Every total pre-order is a pre-order. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a ‚â§ b + c), a - b ‚â§ c","name":"sub_left_le_of_le_add","isProp":true,"docString":"**Alias** of the reverse direction of `sub_le_iff_le_add'`."},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {f : (a : Œπ) ‚Üí Œ±} (a : Function.Surjective f), Set.range f = Set.univ","name":"Function.Surjective.range_eq","isProp":true,"docString":"**Alias** of the reverse direction of `Set.range_iff_surjective`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (H‚ÇÅ : Subgroup G) (H‚ÇÇ : Subgroup G) (hH‚ÇÅ : Subgroup.Normal H‚ÇÅ)\n  (hH‚ÇÇ : Subgroup.Normal H‚ÇÇ) (hdis : Disjoint H‚ÇÅ H‚ÇÇ) (x : G) (y : G) (hx : x ‚àà H‚ÇÅ) (hy : y ‚àà H‚ÇÇ), Commute x y","name":"Subgroup.commute_of_normal_of_disjoint","isProp":true,"docString":"Elements of disjoint, normal subgroups commute. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [self : CategoryTheory.Limits.HasFiniteBiproducts C] (n : ‚Ñï), CategoryTheory.Limits.HasBiproductsOfShape (Fin n) C","name":"CategoryTheory.Limits.HasFiniteBiproducts.out","isProp":true,"docString":"`HasFiniteBiproducts C` represents a choice of biproduct for every family of objects in `C`\nindexed by a finite type. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (Hf : Monotone f) {s : Set Œ±}\n  (a : BddBelow s), BddBelow (f '' s)","name":"Monotone.map_bddBelow","isProp":true,"docString":"The image under a monotone function of a set which is bounded below is bounded below. See also\n`bdd_below.image2`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {g : (a : Œ≤) ‚Üí Œ±} (h : Isometry f) (hg : Function.RightInverse g f), Isometry g","name":"Isometry.right_inv","isProp":true,"docString":"The right inverse of an isometry is an isometry. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n : ‚Ñï} {s1 : Affine.Simplex k P n} {s2 : Affine.Simplex k P n}\n  (h : ‚àÄ (i : Fin (n + 1)), Affine.Simplex.points s1 i = Affine.Simplex.points s2 i), s1 = s2","name":"Affine.Simplex.ext","isProp":true,"docString":"Two simplices are equal if they have the same points. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : SMul ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (hf : ConvexOn ùïú s f) (c : E), ConvexOn ùïú ((fun (z : E) ‚Ü¶ c + z) ‚Åª¬π' s) (f ‚àò fun (z : E) ‚Ü¶ c + z)","name":"ConvexOn.translate_right","isProp":true,"docString":"Right translation preserves convexity. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (x : M), SameRay R x x","name":"SameRay.refl","isProp":true,"docString":"`SameRay` is reflexive. "},{"type":"‚àÄ (k : Type u_3) {V : Type u_2} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : Set P), vectorSpan k s = Submodule.span k (s -·µ• s)","name":"vectorSpan_def","isProp":true,"docString":"The definition of `vectorSpan`, for rewriting. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {s : Set M} {a : M} (h : a ‚àà AddMonoid.Closure s),\n  ‚àÉ (l : List M), (‚àÄ (x : M) (a : x ‚àà l), x ‚àà s : Prop) ‚àß (List.sum l = a : Prop)","name":"AddMonoid.exists_list_of_mem_closure","isProp":true,"docString":"Given an element `a` of the `AddSubmonoid` of an `AddMonoid M` generated by\na set `s`, there exists a list of elements of `s` whose sum is `a`."},{"type":"‚àÄ {Œ± : Type u_1} [self : SeminormedRing Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx - y‚Äñ","name":"SeminormedRing.dist_eq","isProp":true,"docString":"The distance is induced by the norm. "},{"type":"‚àÄ (Œ± : Type u) [inst : PseudoEMetricSpace Œ±] [inst_1 : SigmaCompactSpace Œ±], TopologicalSpace.SecondCountableTopology Œ±","name":"EMetric.secondCountable_of_sigmaCompact","isProp":true,"docString":"A sigma compact pseudo emetric space has second countable topology. This is not an instance\nto avoid a loop with `sigmaCompactSpace_of_locally_compact_second_countable`.  "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Antivary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) < Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i : Prop) ‚Üî\n    (¬¨(Antivary (f ‚àò ‚ÜëœÉ) g : Prop) : Prop)","name":"Antivary.sum_smul_lt_sum_comp_perm_smul_iff","isProp":true,"docString":"**Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f ‚àò œÉ` and `g` do not antivary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ (S : Set ‚Ñù) (hS : ‚àÄ (x : ‚Ñù) (a : x ‚àà S), 0 ‚â§ x), 0 ‚â§ sup‚Çõ S","name":"Real.sup‚Çõ_nonneg","isProp":true,"docString":"As `0` is the default value for `Real.sup‚Çõ` of the empty set or sets which are not bounded above, it\nsuffices to show that `S` is bounded below by `0` to show that `0 ‚â§ inf‚Çõ S`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : (a : Œ±) ‚Üí Type u_2} {Œ≥ : Type u_3} [inst : (a : Œ±) ‚Üí AddCommMonoid (Œ≤ a)] (s : Finset Œ≥)\n  (g : (a : Œ≥) ‚Üí (a : Œ±) ‚Üí Œ≤ a), (Finset.sum s fun (c : Œ≥) ‚Ü¶ g c) = fun (a : Œ±) ‚Ü¶ Finset.sum s fun (c : Œ≥) ‚Ü¶ g c a","name":"Finset.sum_fn","isProp":true,"docString":"An 'unapplied' analogue of `Finset.sum_apply`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : OrderedAddCommMonoid Œ±] [self : Archimedean Œ±] (x : Œ±) {y : Œ±} (a : 0 < y),\n  ‚àÉ (n : ‚Ñï), x ‚â§ n ‚Ä¢ y","name":"Archimedean.arch","isProp":true,"docString":"For any two elements `x`, `y` such that `0 < y`, there exists a natural number `n`\nsuch that `x ‚â§ n ‚Ä¢ y`. "},{"type":"‚àÄ {Œ± : Type u_1} {p : Prop} {q : (a : Œ±) ‚Üí Prop}, (‚àÄ (a : p) (x : Œ±), q x : Prop) ‚Üî (‚àÄ (x : Œ±) (a : p), q x : Prop)","name":"imp_forall_iff","isProp":true,"docString":"We intentionally restrict the type of `Œ±` in this lemma so that this is a safer to use in simp\nthan `forall_swap`. "},{"type":"‚àÄ (Œ± : Type u) [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] [inst_4 : TopologicalSpace.SeparableSpace Œ±] [inst_5 : Nontrivial Œ±],\n  ‚àÉ (s : Set Œ±),\n    (Set.Countable s : Prop) ‚àß\n      ((Dense s : Prop) ‚àß\n          ((‚àÄ (x : Œ±) (a : IsBot x), ¬¨(x ‚àà s : Prop) : Prop) ‚àß (‚àÄ (x : Œ±) (a : IsTop x), ¬¨(x ‚àà s : Prop) : Prop) :\n            Prop) :\n        Prop)","name":"exists_countable_dense_no_bot_top","isProp":true,"docString":"If `Œ±` is a nontrivial separable dense linear order, then there exists a\ncountable dense set `s : Set Œ±` that contains neither top nor bottom elements of `Œ±`.\nFor a dense set containing both bot and top elements, see\n`exists_countable_dense_bot_top`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : ConvexOn ùïú s f) {x : E} {y : E} (hx : x ‚àà s) (hy : y ‚àà s) {a : ùïú} {b : ùïú}\n  (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) (hab : a + b = 1), f (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ max (f x) (f y)","name":"ConvexOn.le_on_segment'","isProp":true,"docString":"A convex function on a segment is upper-bounded by the max of its endpoints. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedGroup E] {s : Set E} (a : Metric.Bounded s),\n  ‚àÉ (C : ‚Ñù), ‚àÄ (x : E) (a : x ‚àà s), ‚Äñx‚Äñ ‚â§ C","name":"Metric.Bounded.exists_norm_le'","isProp":true,"docString":"**Alias** of the forward direction of `bounded_iff_forall_norm_le'`."},{"type":"‚àÄ {Œ± : Type u} {G : Type w} [inst : TopologicalSpace G] [inst_1 : Neg G] [inst_2 : ContinuousNeg G] {f : (a : Œ±) ‚Üí G}\n  {l : Filter Œ±} {y : G} (h : Filter.Tendsto f l (nhds y)), Filter.Tendsto (fun (x : Œ±) ‚Ü¶ -f x) l (nhds (-y))","name":"Filter.Tendsto.neg","isProp":true,"docString":"If a function converges to a value in an additive topological group, then its\nnegation converges to the negation of this value."},{"type":"‚àÄ {t : ‚ÜëunitInterval}, t ‚â§ 1","name":"unitInterval.le_one'","isProp":true,"docString":"like `unitInterval.le_one`, but with the inequality in `I`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Antivary f g),\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i) ‚â§ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i","name":"Antivary.sum_mul_le_sum_comp_perm_mul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is minimized when `f` and\n`g` antivary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type u_1} {s : (a : Œπ) ‚Üí Set Œ±} (H : ‚àÄ (i : Œπ), IsPreconnected (s i))\n  (K : ‚àÄ (i : Œπ) (j : Œπ), Relation.ReflTransGen (fun (i : Œπ) (j : Œπ) ‚Ü¶ Set.Nonempty (s i ‚à© s j)) i j),\n  IsPreconnected (Set.union·µ¢ fun (n : Œπ) ‚Ü¶ s n)","name":"IsPreconnected.union·µ¢_of_reflTransGen","isProp":true,"docString":"Preconnectedness of the union·µ¢ of a family of preconnected sets\nindexed by the vertices of a preconnected graph,\nwhere two vertices are joined when the corresponding sets intersect. "},{"type":"‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p‚ÇÅ : MvPolynomial œÉ R) (p‚ÇÇ : MvPolynomial œÉ R),\n  ‚àÉ (s : Finset œÉ),\n    ‚àÉ (q‚ÇÅ : MvPolynomial { x : œÉ // x ‚àà s } R),\n      ‚àÉ (q‚ÇÇ : MvPolynomial { x : œÉ // x ‚àà s } R),\n        (p‚ÇÅ = ‚Üë(MvPolynomial.rename Subtype.val) q‚ÇÅ : Prop) ‚àß (p‚ÇÇ = ‚Üë(MvPolynomial.rename Subtype.val) q‚ÇÇ : Prop)","name":"MvPolynomial.exists_finset_rename‚ÇÇ","isProp":true,"docString":"`exists_finset_rename` for two polyonomials at once: for any two polynomials `p‚ÇÅ`, `p‚ÇÇ` in a\npolynomial semiring `R[œÉ]` of possibly infinitely many variables, `exists_finset_rename‚ÇÇ` yields\na finite subset `s` of `œÉ` such that both `p‚ÇÅ` and `p‚ÇÇ` are contained in the polynomial semiring\n`R[s]` of finitely many variables. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : SeminormedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  (p : Seminorm ùïú E) (r : ‚Ñù), Balanced ùïú (Seminorm.ball p 0 r)","name":"Seminorm.balanced_ball_zero","isProp":true,"docString":"Seminorm-balls at the origin are balanced. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (E : Set Œ±), Metric.cthickening 0 E = closure E","name":"Metric.cthickening_zero","isProp":true,"docString":"The closed thickening with radius zero is the closure of the set. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : PredOrder Œ±] {a : Œ±} {b : Œ±} [inst_2 : NoMinOrder Œ±]\n  (a_1 : Order.pred a < Order.pred b), a < b","name":"Order.lt_of_pred_lt_pred","isProp":true,"docString":"**Alias** of the forward direction of `Order.pred_lt_pred_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Group Œ±] (e : Œ±) (x : Finset Œ± √ó Finset Œ±),\n  Finset.card (Prod.fst (Finset.mulEtransformLeft e x)) + Finset.card (Prod.snd (Finset.mulEtransformLeft e x)) +\n      (Finset.card (Prod.fst (Finset.mulEtransformRight e x)) +\n        Finset.card (Prod.snd (Finset.mulEtransformRight e x))) =\n    Finset.card (Prod.fst x) + Finset.card (Prod.snd x) + (Finset.card (Prod.fst x) + Finset.card (Prod.snd x))","name":"Finset.MulEtransform.card","isProp":true,"docString":"This statement is meant to be combined with `le_or_lt_of_add_le_add` and similar lemmas. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X","name":"Polynomial.X_mul","isProp":true,"docString":"`X` commutes with everything, even when the coefficients are noncommutative. "},{"type":"‚àÄ {b : ‚Ñï} (hb : 1 < b) {x : ‚Ñï} {y : ‚Ñï}, (x ‚â§ b ^ y : Prop) ‚Üî (Nat.clog b x ‚â§ y : Prop)","name":"Nat.le_pow_iff_clog_le","isProp":true,"docString":"`clog b` and `pow b` form a Galois connection. "},{"type":"‚àÄ {Œ± : Type u} [inst : MulOneClass Œ±], IsMonoidHom id","name":"IsMonoidHom.id","isProp":true,"docString":"The identity map is a monoid homomorphism. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] {S : Submonoid M} {T : Submonoid M}\n  (h : ‚àÄ (x : M), (x ‚àà S : Prop) ‚Üî (x ‚àà T : Prop)), S = T","name":"Submonoid.ext","isProp":true,"docString":"Two submonoids are equal if they have the same elements. "},{"type":"‚àÄ {C : Type u_1} {D : Type u_4} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {G : C ‚•§ D}\n  {F : D ‚•§ C} {A : C} {B : C} {X : D} {Y : D} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\n  {u : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) A ‚ü∂ X}\n  {v : Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) B ‚ü∂ Y}\n  (sq : CategoryTheory.CommSq u (Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) i) p v) (adj : G ‚ä£ F),\n  (CategoryTheory.CommSq.HasLift\n        ((CategoryTheory.CommSq.right_adjoint sq\n              adj=:CategoryTheory.CommSq (‚Üë(CategoryTheory.Adjunction.homEquiv adj A X) u) i\n              (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) p)\n              (‚Üë(CategoryTheory.Adjunction.homEquiv adj B Y)\n                v))=:CategoryTheory.CommSq (‚Üë(CategoryTheory.Adjunction.homEquiv adj A X) u) i\n            (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) p)\n            (‚Üë(CategoryTheory.Adjunction.homEquiv adj B Y) v)) :\n      Prop) ‚Üî\n    (CategoryTheory.CommSq.HasLift sq : Prop)","name":"CategoryTheory.CommSq.right_adjoint_hasLift_iff","isProp":true,"docString":"A square has a lifting if and only if its (right) adjoint square has a lifting. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] [inst_4 : ContinuousAdd Œ≥] {f : (a : Œ±) ‚Üí Œ≥}\n  {g : (a : Œ±) ‚Üí Œ≥} (hf : LowerSemicontinuousOn f s) (hg : LowerSemicontinuousOn g s),\n  LowerSemicontinuousOn (fun (z : Œ±) ‚Ü¶ f z + g z) s","name":"LowerSemicontinuousOn.add","isProp":true,"docString":"The sum of two lower semicontinuous functions is lower semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedCancelCommMonoid Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c * a ‚â§ c * b","name":"OrderedCancelCommMonoid.mul_le_mul_left","isProp":true,"docString":"Multiplication is monotone in an ordered cancellative commutative monoid. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s‚ÇÅ : AffineSubspace k P} {s‚ÇÇ : AffineSubspace k P} {p : P} (h‚ÇÅ : p ‚àà s‚ÇÅ) (h‚ÇÇ : p ‚àà s‚ÇÇ),\n  AffineSubspace.direction (s‚ÇÅ ‚äì s‚ÇÇ) = AffineSubspace.direction s‚ÇÅ ‚äì AffineSubspace.direction s‚ÇÇ","name":"AffineSubspace.direction_inf_of_mem","isProp":true,"docString":"If two affine subspaces have a point in common, the direction of their inf equals the inf of\ntheir directions. "},{"type":"‚àÄ {Œπ : Type u_1} {œÄ : (a : Œπ) ‚Üí Type u_2} [inst : Fintype Œπ] [inst_1 : (i : Œπ) ‚Üí SeminormedGroup (œÄ i)]\n  (f : (i : Œπ) ‚Üí œÄ i), (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ ‚Äñf i‚Äñ) ‚â§ Fintype.card Œπ ‚Ä¢ ‚Äñf‚Äñ","name":"Pi.sum_norm_apply_le_norm'","isProp":true,"docString":"The $L^1$ norm is less than the $L^\\infty$ norm scaled by the cardinality. "},{"type":"‚àÄ (b : ‚Ñ§), b ‚â§ b ^ 2","name":"Int.le_self_pow_two","isProp":true,"docString":"**Alias** of `Int.le_self_sq`."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type uu} [inst : Preorder Œ±] {f : (a : Fin n) ‚Üí Œ±},\n  (Monotone f : Prop) ‚Üî (List.Sorted (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1) (List.ofFn f) : Prop)","name":"List.monotone_iff_ofFn_sorted","isProp":true,"docString":"A tuple is monotone if and only if the list obtained from it is sorted. "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (a_1 : Fermat42.Minimal a b c), Fermat42.Minimal b a c","name":"Fermat42.minimal_comm","isProp":true,"docString":"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. "},{"type":"‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : Nontrivial V], ‚ÄñNormedAddGroupHom.id V‚Äñ = 1","name":"NormedAddGroupHom.norm_id","isProp":true,"docString":"If a normed space is non-trivial, then the norm of the identity equals `1`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {b : Œ±}\n  (hab : a < b) (s : Set Œ±),\n  List.TFAE\n    [(s ‚àà nhdsWithin a (Set.Ici a) : Prop), (s ‚àà nhdsWithin a (Set.Icc a b) : Prop),\n      (s ‚àà nhdsWithin a (Set.Ico a b) : Prop), (‚àÉ (u : Œ±), (u ‚àà Set.Ioc a b : Prop) ‚àß (Set.Ico a u ‚äÜ s : Prop) : Prop),\n      (‚àÉ (u : Œ±), (u ‚àà Set.Ioi a : Prop) ‚àß (Set.Ico a u ‚äÜ s : Prop) : Prop)]","name":"TFAE_mem_nhdsWithin_Ici","isProp":true,"docString":"The following statements are equivalent:\n\n0. `s` is a neighborhood of `a` within `[a, +‚àû)`;\n1. `s` is a neighborhood of `a` within `[a, b]`;\n2. `s` is a neighborhood of `a` within `[a, b)`;\n3. `s` includes `[a, u)` for some `u ‚àà (a, b]`;\n4. `s` includes `[a, u)` for some `u > a`.\n"},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Inv G] [inst_2 : Mul G] [inst_3 : ContinuousMul G] (g : G),\n  Continuous fun (h : G) ‚Ü¶ g * h * g‚Åª¬π","name":"TopologicalGroup.continuous_conj","isProp":true,"docString":"Conjugation by a fixed element is continuous when `mul` is continuous. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [self : LocPathConnectedSpace X] (x : X),\n  Filter.HasBasis (nhds x) (fun (s : Set X) ‚Ü¶ (s ‚àà nhds x : Prop) ‚àß (IsPathConnected s : Prop)) id","name":"LocPathConnectedSpace.path_connected_basis","isProp":true,"docString":"Each neighborhood filter has a basis of path-connected neighborhoods. "},{"type":"‚àÄ {P : Type u_1} [inst : LE P] {I : Set P} (self : Order.IsIdeal I), DirectedOn (fun (x : P) (x_1 : P) ‚Ü¶ x ‚â§ x_1) I","name":"Order.IsIdeal.Directed","isProp":true,"docString":"The ideal is upward directed. "},{"type":"‚àÄ {n : ‚Ñï} (c : Composition n),\n  Finset.orderEmbOfFin (Composition.boundaries c)\n      ((Composition.card_boundaries_eq_succ_length\n            c=:Finset.card (Composition.boundaries c) =\n            Composition.length c + 1)=:Finset.card (Composition.boundaries c) = Composition.length c + 1) =\n    Composition.boundary c","name":"Composition.orderEmbOfFin_boundaries","isProp":true,"docString":"The canonical increasing bijection between `Fin (c.length + 1)` and `c.boundaries` is\nexactly `c.boundary`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedSemifield Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r)\n  (hf : Filter.Tendsto f l Filter.atTop), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atTop","name":"Filter.Tendsto.atTop_mul_const","isProp":true,"docString":"If a function tends to infinity along a filter, then this function multiplied by a positive\nconstant (on the right) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use\n`filter.tendsto.atTop_mul_const'` instead. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {s : Finset Œ±} {a : Œ±},\n  (s ‚àà Down.compression a ùíú : Prop) ‚Üî\n    (((s ‚àà ùíú : Prop) ‚àß (Finset.erase s a ‚àà ùíú : Prop) : Prop) ‚à®\n        ((¬¨(s ‚àà ùíú : Prop) : Prop) ‚àß (insert a s ‚àà ùíú : Prop) : Prop) :\n      Prop)","name":"Down.mem_compression","isProp":true,"docString":"`a` is in the down-compressed family iff it's in the original and its compression is in the\noriginal, or it's not in the original but it's the compression of something in the original. "},{"type":"‚àÄ {Œπ : Type u_2} {Œ∫ : Type u_3} {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T3Space Œ±]\n  [inst_2 : NonUnitalNonAssocSemiring Œ±] [inst_3 : TopologicalSemiring Œ±] {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œ∫) ‚Üí Œ±}\n  (hf : Summable f) (hg : Summable g) (hfg : Summable fun (x : Œπ √ó Œ∫) ‚Ü¶ f (Prod.fst x) * g (Prod.snd x)),\n  ((tsum fun (x : Œπ) ‚Ü¶ f x) * tsum fun (y : Œ∫) ‚Ü¶ g y) = tsum fun (z : Œπ √ó Œ∫) ‚Ü¶ f (Prod.fst z) * g (Prod.snd z)","name":"tsum_mul_tsum","isProp":true,"docString":"Product of two infinites sums indexed by arbitrary types.\nSee also `tsum_mul_tsum_of_summable_norm` if `f` and `g` are abolutely summable. "},{"type":"‚àÄ {Œπ : Type u_3} {B : Type u_1} {F : Type u_2} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  (Z : FiberBundleCore Œπ B F) (i : Œπ) (j : Œπ),\n  LocalEquiv.trans (LocalEquiv.symm (FiberBundleCore.localTrivAsLocalEquiv Z i))\n      (FiberBundleCore.localTrivAsLocalEquiv Z j) ‚âà\n    LocalHomeomorph.toLocalEquiv (FiberBundleCore.trivChange Z i j)","name":"FiberBundleCore.localTrivAsLocalEquiv_trans","isProp":true,"docString":"The composition of two local trivializations is the trivialization change Z.triv_change i j. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} (a : Dense s) (U : Set Œ±) (a : IsOpen U) (a : Set.Nonempty U),\n  Set.Nonempty (U ‚à© s)","name":"Dense.inter_open_nonempty","isProp":true,"docString":"**Alias** of the forward direction of `dense_iff_inter_open`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} (a2 : 2 ‚â§ a), (1 - 1 / a)‚Åª¬π ‚â§ 2","name":"sub_one_div_inv_le_two","isProp":true,"docString":"An inequality involving `2`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {J : Type u}\n  [inst_2 : CategoryTheory.Category J] (E : C ‚•§ D) [inst_3 : CategoryTheory.IsEquivalence E]\n  [inst_4 : CategoryTheory.Limits.HasColimitsOfShape J D], CategoryTheory.Limits.HasColimitsOfShape J C","name":"CategoryTheory.Adjunction.hasColimitsOfShape_of_equivalence","isProp":true,"docString":"Transport a `HasColimitsOfShape` instance across an equivalence. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] (x : AddAction.orbitRel.Quotient Œ± Œ≤)\n  {œÜ : (a : AddAction.orbitRel.Quotient Œ± Œ≤) ‚Üí Œ≤} (hœÜ : Function.RightInverse œÜ Quotient.mk'),\n  AddAction.orbitRel.Quotient.orbit x = AddAction.orbit Œ± (œÜ x)","name":"AddAction.orbitRel.Quotient.orbit_eq_orbit_out","isProp":true,"docString":"Note that `hœÜ = quotient.out_eq'` is a useful choice here."},{"type":"‚àÄ {Œ± : Type u_1} (self : Ultrafilter Œ±), Filter.NeBot ‚Üëself","name":"Ultrafilter.neBot'","isProp":true,"docString":"An ultrafilter is nontrivial. "},{"type":"‚àÄ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R] [inst_2 : Nontrivial R]\n  [inst_3 : NormalizationMonoid R] [inst_4 : DecidableEq R] {p : R} {x : R} (hp : Irreducible p)\n  (hnorm : ‚Üënormalize p = p) {n : ‚Ñï} (hle : p ^ n ‚à£ x) (hlt : ¬¨(p ^ (n + 1) ‚à£ x : Prop)),\n  Multiset.count p (UniqueFactorizationMonoid.normalizedFactors x) = n","name":"UniqueFactorizationMonoid.count_normalizedFactors_eq","isProp":true,"docString":"The number of times an irreducible factor `p` appears in `normalizedFactors x` is defined by\nthe number of times it divides `x`.\n\nSee also `multiplicity_eq_count_normalizedFactors` if `n` is given by `multiplicity p x`.\n"},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : UniformSpace Œ±]\n  [inst_2 : UniformAddGroup Œ±] [inst_3 : CompleteSpace Œ±] {f : (a : Œπ) ‚Üí Œ±} (a : Summable f),\n  Summable fun (x : Œπ) ‚Ü¶ abs (f x)","name":"Summable.abs","isProp":true,"docString":"**Alias** of the reverse direction of `summable_abs_iff`."},{"type":"‚àÄ {R : Type u_1} [inst : AddSemigroup R] {a : R} {b : R},\n  ((IsAddRegular (a + b) : Prop) ‚àß (IsAddRegular (b + a) : Prop) : Prop) ‚Üî\n    ((IsAddRegular a : Prop) ‚àß (IsAddRegular b : Prop) : Prop)","name":"isAddRegular_add_and_add_iff","isProp":true,"docString":"Two elements `a` and `b` are add-regular if and only if both sums `a + b` and\n`b + a` are add-regular."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofiltered C] {D : Type u‚ÇÅ}\n  [inst_2 : CategoryTheory.Category D] (L : C ‚•§ D) [inst : CategoryTheory.IsLeftAdjoint L],\n  CategoryTheory.IsCofiltered D","name":"CategoryTheory.IsCofiltered.of_isLeftAdjoint","isProp":true,"docString":"If `C` is cofiltered, and we have a left adjoint functor `L : C ‚•§ D`, then `D` is cofiltered. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} (a : Set.Pairwise s ‚ä•), Set.Subsingleton s","name":"Set.Pairwise.subsingleton","isProp":true,"docString":"**Alias** of the forward direction of `Set.pairwise_bot_iff`."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommMonoid M] [inst_1 : CommRing R] [inst_2 : Monoid.Fg M],\n  Algebra.FiniteType R (MonoidAlgebra R M)","name":"MonoidAlgebra.finiteType_of_fg","isProp":true,"docString":"If a monoid `M` is finitely generated then `MonoidAlgebra R M` is of finite type. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (h : a ‚â§ b), (b = a : Prop) ‚à® (a < b : Prop)","name":"LE.le.eq_or_gt","isProp":true,"docString":"**Alias** of `eq_or_gt_of_le`."},{"type":"‚àÄ {S : Type u_1} [inst : Semigroup S], Transitive fun (a : S) (b : S) ‚Ü¶ ‚àÉ (c : S), SemiconjBy c a b","name":"SemiconjBy.transitive","isProp":true,"docString":"The relation ‚Äúthere exists an element that semiconjugates `a` to `b`‚Äù on a semigroup\nis transitive. "},{"type":"‚àÄ {M : Type u} [self : AddMonoid M] (a : M), 0 + a = a","name":"AddMonoid.zero_add","isProp":true,"docString":"Zero is a left neutral element for addition "},{"type":"‚àÄ {Œ± : Type u} [inst : Subsingleton Œ±] (l : Filter Œ±) [inst : Filter.NeBot l], l = ‚ä§","name":"Filter.eq_top_of_neBot","isProp":true,"docString":"There are only two filters on a `subsingleton`: `‚ä•` and `‚ä§`. If the type is empty, then they are\nequal. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : Finite Œπ] [inst : DecidableEq Œ±] (t : (a : Œπ) ‚Üí Finset Œ±),\n  (‚àÄ (s : Finset Œπ), Finset.card s ‚â§ Finset.card (Finset.bunion·µ¢ s t) : Prop) ‚Üî\n    (‚àÉ (f : (a : Œπ) ‚Üí Œ±), (Function.Injective f : Prop) ‚àß (‚àÄ (x : Œπ), f x ‚àà t x : Prop) : Prop)","name":"Finset.all_card_le_bunion·µ¢_card_iff_existsInjective'","isProp":true,"docString":"This is the version of **Hall's Marriage Theorem** in terms of indexed\nfamilies of finite sets `t : Œπ ‚Üí Finset Œ±` with `Œπ` finite.\nIt states that there is a set of distinct representatives if and only\nif every union of `k` of the sets has at least `k` elements.\n\nSee `Finset.all_card_le_bunion·µ¢_card_iff_exists_injective` for a version\nwhere the `Finite Œπ` constraint is removed.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (x : Œ±) (y : Œ±), dist (‚ÜëŒ± x) (‚ÜëŒ± y) = dist x y","name":"UniformSpace.Completion.dist_eq","isProp":true,"docString":"The new distance is an extension of the original distance. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Isometry f) (s : Set Œ±), Metric.diam (f '' s) = Metric.diam s","name":"Isometry.diam_image","isProp":true,"docString":"An isometry preserves the diameter in pseudometric spaces. "},{"type":"‚àÄ {R : Type u_1} [inst : Semigroup R] {a : R} (b : R) (ha : IsLeftRegular a),\n  (IsLeftRegular (a * b) : Prop) ‚Üî (IsLeftRegular b : Prop)","name":"mul_isLeftRegular_iff","isProp":true,"docString":"An element is left-regular if and only if multiplying it on the left by a left-regular element\nis left-regular. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrderedAddCommGroup Œ±]\n  [inst_2 : OrderTopology Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} {C : Œ±}\n  (hf : Filter.Tendsto f l (nhds C)) (hg : Filter.Tendsto g l Filter.atBot),\n  Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x + g x) l Filter.atBot","name":"Filter.Tendsto.add_atBot","isProp":true,"docString":"In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`\nand `g` tends to `atBot` then `f + g` tends to `atBot`. "},{"type":"‚àÄ {ùìï : Type u_1} {E : Type u_2} {F : Type u_3} [inst : SeminormedAddGroup E] [inst_1 : SeminormedAddGroup F]\n  [inst_2 : AddMonoidHomClass ùìï E F] (f : ùìï) (C : ‚Ñù) (h : ‚àÄ (x : E), ‚Äñ‚Üëf x‚Äñ ‚â§ C * ‚Äñx‚Äñ),\n  LipschitzWith (Real.toNNReal C) ‚Üëf","name":"AddMonoidHomClass.lipschitz_of_bound","isProp":true,"docString":"A homomorphism `f` of seminormed groups is Lipschitz, if there exists a constant\n`C` such that for all `x`, one has `‚Äñf x‚Äñ ‚â§ C * ‚Äñx‚Äñ`. The analogous condition for a linear map of\n(semi)normed spaces is in `NormedSpace.OperatorNorm`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.IsSplitEpi f],\n  CategoryTheory.IsSplitMono (CategoryTheory.section_ f)","name":"CategoryTheory.section_isSplitMono","isProp":true,"docString":"The section of a split epimorphism is itself a split monomorphism. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  (s : CategoryTheory.Limits.Cofork f g) {W : C} {k : CategoryTheory.Limits.Cocone.pt s ‚ü∂ W}\n  {l : CategoryTheory.Limits.Cocone.pt s ‚ü∂ W}\n  (h : CategoryTheory.Limits.Cofork.œÄ s ‚â´ k = CategoryTheory.Limits.Cofork.œÄ s ‚â´ l)\n  (j : CategoryTheory.Limits.WalkingParallelPair),\n  (CategoryTheory.Limits.Cocone.Œπ s).app j ‚â´ k = (CategoryTheory.Limits.Cocone.Œπ s).app j ‚â´ l","name":"CategoryTheory.Limits.Cofork.coequalizer_ext","isProp":true,"docString":"To check whether two maps are coequalized by both maps of a cofork, it suffices to check it for\nthe second map "},{"type":"‚àÄ {Œπ : Type u_1} {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V]\n  {c : ComplexShape Œπ} (C : HomologicalComplex V c) {i : Œπ} {j : Œπ} {j' : Œπ} (rij : ComplexShape.Rel c i j)\n  (rij' : ComplexShape.Rel c i j'),\n  HomologicalComplex.d C i j' ‚â´\n      CategoryTheory.eqToHom\n        ((congr_arg (HomologicalComplex.X C)\n              ((ComplexShape.next_eq c rij'\n                    rij=:j' =\n                    j)=:j' =\n                  j)=:HomologicalComplex.X C j' =\n              HomologicalComplex.X C j)=:HomologicalComplex.X C j' = HomologicalComplex.X C j) =\n    HomologicalComplex.d C i j","name":"HomologicalComplex.d_comp_eqToHom","isProp":true,"docString":"If `C.d i j` and `C.d i j'` are both allowed, then we must have `j = j'`,\nand so the differentials only differ by an `eqToHom`.\n"},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p : P} {ps : Set P} (h : p ‚àà affineSpan k ps), affineSpan k (insert p ps) = affineSpan k ps","name":"affineSpan_insert_eq_affineSpan","isProp":true,"docString":"If a point is in the affine span of a set, adding it to that set does not change the affine\nspan. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C]\n  [self : CategoryTheory.Limits.HasLimitsOfShape J C] (F : J ‚•§ C), CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.Limits.HasLimitsOfShape.has_limit","isProp":true,"docString":"All functors `F : J ‚•§  C` from `J` have limits "},{"type":"‚àÄ {H : Type u_3} {M : Type u_4} {H' : Type u_1} {M' : Type u_2} [inst : TopologicalSpace H]\n  [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M] [inst_3 : TopologicalSpace H']\n  [inst_4 : TopologicalSpace M'] [inst_5 : ChartedSpace H' M'] {G : StructureGroupoid H} {G' : StructureGroupoid H'}\n  {f : LocalHomeomorph M' H'} {P : (a : (a : H) ‚Üí H') ‚Üí (a : Set H) ‚Üí (a : H) ‚Üí Prop} {g : (a : M) ‚Üí M'} {s : Set M}\n  {x : M} (hG : StructureGroupoid.LocalInvariantProp G G' P) [inst_6 : HasGroupoid M' G']\n  (hf : f ‚àà StructureGroupoid.maximalAtlas M' G') (xf : g x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv f)),\n  (ChartedSpace.LiftPropWithinAt P g s x : Prop) ‚Üî\n    ((ContinuousWithinAt g s x : Prop) ‚àß (ChartedSpace.LiftPropWithinAt P (‚Üëf ‚àò g) s x : Prop) : Prop)","name":"StructureGroupoid.LocalInvariantProp.liftPropWithinAt_indep_chart_target","isProp":true,"docString":"A version of `liftPropWithinAt_indep_chart`, only for the target. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [self : CategoryTheory.IsPreconnected J] {Œ± : Type u‚ÇÅ}\n  (F : J ‚•§ CategoryTheory.Discrete Œ±) (j : J),\n  Nonempty\n    (F ‚âÖ\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Functor.const J))\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) j))","name":"CategoryTheory.IsPreconnected.iso_constant","isProp":true,"docString":"A possibly empty category for which every functor to a discrete category is constant.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.HasShift C ‚Ñ§]\n  {T‚ÇÅ : CategoryTheory.Pretriangulated.Triangle C} {T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle C}\n  (self : CategoryTheory.Pretriangulated.TriangleMorphism T‚ÇÅ T‚ÇÇ),\n  CategoryTheory.Pretriangulated.Triangle.mor‚ÇÅ T‚ÇÅ ‚â´ CategoryTheory.Pretriangulated.TriangleMorphism.hom‚ÇÇ self =\n    CategoryTheory.Pretriangulated.TriangleMorphism.hom‚ÇÅ self ‚â´ CategoryTheory.Pretriangulated.Triangle.mor‚ÇÅ T‚ÇÇ","name":"CategoryTheory.Pretriangulated.TriangleMorphism.comm‚ÇÅ","isProp":true,"docString":"the first commutative square of a triangle morphism "},{"type":"‚àÄ {o : Ordinal},\n  (Ordinal.Principal (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x + x_1) o : Prop) ‚Üî\n    ((o = 0 : Prop) ‚à® (‚àÉ (a : Ordinal), o = Ordinal.omega ^ a : Prop) : Prop)","name":"Ordinal.principal_add_iff_zero_or_omega_opow","isProp":true,"docString":"The main characterization theorem for additive principal ordinals. "},{"type":"‚àÄ (Œ± : Type u) (Œ≤ : Type u_1) [t : TopologicalSpace Œ≤] [inst : TopologicalSpace.SecondCountableTopology Œ≤]\n  (f : (a : Œ±) ‚Üí Œ≤), TopologicalSpace.SecondCountableTopology Œ±","name":"TopologicalSpace.secondCountableTopology_induced","isProp":true,"docString":"If `Œ≤` is a second-countable space, then its induced topology via\n`f` on `Œ±` is also second-countable. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} (hC : Preperfect C), Perfect (closure C)","name":"Preperfect.perfect_closure","isProp":true,"docString":"The closure of a preperfect set is perfect.\nFor a converse, see `preperfect_iff_perfect_closure`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {A : C} {B : C} {X : C} {Y : C} {f : A ‚ü∂ X} {i : A ‚ü∂ B} {p : X ‚ü∂ Y}\n  {g : B ‚ü∂ Y} {sq : CategoryTheory.CommSq f i p g} (self : CategoryTheory.CommSq.LiftStruct sq),\n  CategoryTheory.CommSq.LiftStruct.l self ‚â´ p = g","name":"CategoryTheory.CommSq.LiftStruct.fac_right","isProp":true,"docString":"The lower right triangle commutes. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalRing Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h : a ‚à£ c), (a ‚à£ b - c : Prop) ‚Üî (a ‚à£ b : Prop)","name":"dvd_sub_left","isProp":true,"docString":"If an element `a` divides another element `c` in a ring, `a` divides the difference of another\nelement `b` with `c` iff `a` divides `b`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {J : Type w}\n  [inst_2 : CategoryTheory.Category J] (F : C ‚•§ D) [inst_3 : CategoryTheory.Limits.HasLimitsOfShape J D]\n  [inst_4 : CategoryTheory.CreatesLimitsOfShape J F], CategoryTheory.Limits.HasLimitsOfShape J C","name":"CategoryTheory.hasLimitsOfShape_of_hasLimitsOfShape_createsLimitsOfShape","isProp":true,"docString":"If `F` creates limits of shape `J`, and `D` has limits of shape `J`, then\n`C` has limits of shape `J`.\n"},{"type":"‚àÄ {a : Prop} {b : Prop} (a_1 : ‚àÄ (a : ¬¨(a : Prop)), ¬¨(b : Prop)) (a_2 : b), a","name":"Function.mtr","isProp":true,"docString":"Provide the reverse of modus tollens (`mt`) as dot notation for implications. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteLattice Œ±] (x : Œ±), ‚ä• ‚â§ x","name":"CompleteLattice.bot_le","isProp":true,"docString":"Any element is more than the bottom one. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Group Œ±] [inst_1 : OrderedAddCommMonoid Œ≤]\n  [self : GroupSeminormClass F Œ± Œ≤] (f : F) (a : Œ±), ‚Üëf a‚Åª¬π = ‚Üëf a","name":"GroupSeminormClass.map_inv_eq_map","isProp":true,"docString":"The map is invariant under inversion of its argument. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] [self : NoBotOrder Œ±] (a : Œ±), ‚àÉ (b : Œ±), ¬¨(a ‚â§ b : Prop)","name":"NoBotOrder.exists_not_ge","isProp":true,"docString":"For each term `a`, there is some `b` which is either incomparable or strictly smaller. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedAddMonoid Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"CanonicallyLinearOrderedAddMonoid.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] {s : Set M} {p : (a : M) ‚Üí (a : M) ‚Üí Prop} {x : M} {y : M}\n  (hx : x ‚àà AddSubmonoid.closure s) (hy : y ‚àà AddSubmonoid.closure s)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s) (y : M) (a : y ‚àà s), p x y) (H1_left : ‚àÄ (x : M), p 0 x) (H1_right : ‚àÄ (x : M), p x 0)\n  (Hmul_left : ‚àÄ (x : M) (y : M) (z : M) (a : p x z) (a : p y z), p (x + y) z)\n  (Hmul_right : ‚àÄ (x : M) (y : M) (z : M) (a : p z x) (a : p z y), p z (x + y)), p x y","name":"AddSubmonoid.closure_induction‚ÇÇ","isProp":true,"docString":"An induction principle for additive closure membership for predicates with two arguments."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : PredOrder Œ±] {a : Œ±} (a_1 : IsMin a), Order.pred a = a","name":"IsMin.pred_eq","isProp":true,"docString":"**Alias** of the reverse direction of `Order.pred_eq_iff_isMin`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {t : Set Œ≤}\n  (h1 : ‚àÄ (x : Œ±), f x ‚àà t) {x : Œ±} (a : ContinuousAt f x), ContinuousAt (Set.codRestrict f t h1) x","name":"ContinuousAt.codRestrict","isProp":true,"docString":"**Alias** of the reverse direction of `continuousAt_codRestrict_iff`."},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {Y : D} {Y' : D} (h : Y ‚âÖ Y') (hY : Y ‚àà CategoryTheory.Functor.essImage F), Y' ‚àà CategoryTheory.Functor.essImage F","name":"CategoryTheory.Functor.essImage.ofIso","isProp":true,"docString":"Being in the essential image is a \"hygenic\" property: it is preserved under isomorphism. "},{"type":"‚àÄ {S : Type u_1} [inst : Add S] {a : S} {x : S} {y : S} (h : AddSemiconjBy a x y), a + x = y + a","name":"AddSemiconjBy.eq","isProp":true,"docString":"Equality behind `AddSemiconjBy a x y`; useful for rewriting."},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (self : AddGroupSeminorm G), AddGroupSeminorm.toFun self 0 = 0","name":"AddGroupSeminorm.map_zero'","isProp":true,"docString":"The image of zero is zero. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : AddGroup G] [inst_1 : SubtractionMonoid H]\n  [inst_2 : AddMonoidHomClass F G H] (f : F) (a : G), ‚Üëf (-a) = -‚Üëf a","name":"map_neg","isProp":true,"docString":"Additive group homomorphisms preserve negation."},{"type":"‚àÄ {Œπ : Sort u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : CompleteLattice Œ±] [inst_1 : CompleteLattice Œ≤] (f : Œ± ‚âÉo Œ≤)\n  {a : (a : Œπ) ‚Üí Œ±} (ha : CompleteLattice.Independent a), CompleteLattice.Independent (‚Üëf ‚àò a)","name":"CompleteLattice.Independent.map_orderIso","isProp":true,"docString":"Composing an indepedent indexed family with an order isomorphism on the elements results in\nanother indepedendent indexed family. "},{"type":"‚àÄ {Œì : Type u_1} [inst : AddGroup Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Œì T]\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstVAdd Œì T]\n  [inst_6 : ProperlyDiscontinuousVAdd Œì T], T2Space (Quotient (AddAction.orbitRel Œì T))","name":"t2Space_of_properlyDiscontinuousVAdd_of_t2Space","isProp":true,"docString":"The quotient by a discontinuous group action of a locally compact t2\nspace is t2."},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {s : Set M} (self : IsSubmonoid s), 1 ‚àà s","name":"IsSubmonoid.one_mem","isProp":true,"docString":"The proposition that s contains 1. "},{"type":"‚àÄ {R : Type u_2} {Œì‚ÇÄ : Type u_3} {Œì'‚ÇÄ : Type u_4} [inst : LinearOrderedAddCommMonoidWithTop Œì‚ÇÄ]\n  [inst_1 : LinearOrderedAddCommMonoidWithTop Œì'‚ÇÄ] [inst_2 : Ring R] {v‚ÇÅ : AddValuation R Œì‚ÇÄ} {v‚ÇÇ : AddValuation R Œì'‚ÇÄ}\n  {S : Type u_1} [inst_3 : Ring S] (f : S ‚Üí+* R) (h : AddValuation.IsEquiv v‚ÇÅ v‚ÇÇ),\n  AddValuation.IsEquiv (AddValuation.comap f v‚ÇÅ) (AddValuation.comap f v‚ÇÇ)","name":"AddValuation.IsEquiv.comap","isProp":true,"docString":"`comap` preserves equivalence. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ} [inst_1 : TopologicalSpace Œ±] [inst_2 : CompactSpace Œ±],\n  (TendstoLocallyUniformly F f p : Prop) ‚Üî (TendstoUniformly F f p : Prop)","name":"tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace","isProp":true,"docString":"On a compact space, locally uniform convergence is just uniform convergence. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup A] [inst_2 : Module R A]\n  [inst_3 : StarAddMonoid R] [inst_4 : StarAddMonoid A] [inst_5 : StarModule R A] {r : R} (hr : r ‚àà skewAdjoint R)\n  {a : A} (ha : a ‚àà skewAdjoint A), IsSelfAdjoint (r ‚Ä¢ a)","name":"isSelfAdjoint_smul_of_mem_skewAdjoint","isProp":true,"docString":"Scalar multiplication of a skew-adjoint element by a skew-adjoint element produces a\nself-adjoint element. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R]\n  {S : Type u_3} [inst_3 : CommRing S] [inst_4 : IsDomain S] [inst_5 : Algebra R S] [inst_6 : Finite Œπ]\n  (b : Basis Œπ R S) (I : Ideal S) (hI : I ‚â† ‚ä•),\n  ‚àÉ (b' : Basis Œπ R S), ‚àÉ (a : (a : Œπ) ‚Üí R), ‚àÉ (ab' : Basis Œπ R { x : S // x ‚àà I }), ‚àÄ (i : Œπ), ‚Üë(‚Üëab' i) = a i ‚Ä¢ ‚Üëb' i","name":"Ideal.exists_smith_normal_form","isProp":true,"docString":"If `S` a finite-dimensional ring extension of a PID `R` which is free as an `R`-module,\nthen any nonzero `S`-ideal `I` is free as an `R`-submodule of `S`, and we can\nfind a basis for `S` and `I` such that the inclusion map is a square diagonal\nmatrix.\n\nSee also `Ideal.smithNormalForm` for a version of this theorem that returns\na `Basis.SmithNormalForm`.\n\nThe definitions `Ideal.ringBasis`, `Ideal.selfBasis`, `Ideal.smithCoeffs` are (noncomputable)\nchoices of values for this existential quantifier.\n"},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : StrictMonoOn f s) (hs : s ‚àà nhdsWithin a (Set.Iic a))\n  (hfs : f '' s ‚àà nhdsWithin (f a) (Set.Iic (f a))), ContinuousWithinAt f (Set.Iic a) a","name":"StrictMonoOn.continuousWithinAt_left_of_image_mem_nhdsWithin","isProp":true,"docString":"If a function `f` with a densely ordered codomain is strictly monotone on a left neighborhood of\n`a` and the image of this neighborhood under `f` is a left neighborhood of `f a`, then `f` is\ncontinuous at `a` from the left. "},{"type":"‚àÄ (G : Type u) [inst : CommSemigroup G] [inst_1 : IsLeftCancelMul G], IsCancelMul G","name":"CommSemigroup.IsLeftCancelMul.toIsCancelMul","isProp":true,"docString":"Any `CommSemigroup G` that satisfies `IsLeftCancelMul G` also satisfies\n`IsCancelMul G`. "},{"type":"‚àÄ (E : Type u_1) [inst : AddCommGroup E], Subsingleton (Module ‚Ñö E)","name":"subsingleton_rat_module","isProp":true,"docString":"There can be at most one `Module ‚Ñö E` structure on an additive commutative group. "},{"type":"‚àÄ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ‚¶ÉJ : Order.Ideal P‚¶Ñ (a : I < J),\n  ‚ÜëJ = Set.univ","name":"Order.Ideal.IsMaximal.maximal_proper","isProp":true,"docString":"This ideal is maximal in the collection of proper ideals. "},{"type":"‚àÄ {Œ± : Type u} [self : GeneralizedBooleanAlgebra Œ±] (a : Œ±) (b : Œ±), a ‚äì b ‚äì a \\ b = ‚ä•","name":"GeneralizedBooleanAlgebra.inf_inf_sdiff","isProp":true,"docString":"For any `a`, `b`, `(a ‚äì b) ‚äì (a / b) = ‚ä•` "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedLinearOrderedField Œ±] (x : Œ±) (y : Œ±), ‚Äñx * y‚Äñ = ‚Äñx‚Äñ * ‚Äñy‚Äñ","name":"NormedLinearOrderedField.norm_mul'","isProp":true,"docString":"The norm is multiplicative. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {f : (a : Œ±) ‚Üí ENNReal},\n  ((Finset.sum s fun (a : Œ±) ‚Ü¶ f a) < ‚ä§ : Prop) ‚Üî (‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a < ‚ä§ : Prop)","name":"ENNReal.sum_lt_top_iff","isProp":true,"docString":"A sum of finite numbers is still finite "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  [inst_2 : CategoryTheory.Functor.Initial F] {E : Type u‚ÇÉ} [inst_3 : CategoryTheory.Category E] {G : D ‚•§ E}\n  [inst : CategoryTheory.Limits.HasLimit (F ‚ãô G)], CategoryTheory.Limits.HasLimit G","name":"CategoryTheory.Functor.Initial.hasLimit_of_comp","isProp":true,"docString":"When `F` is initial, and `F ‚ãô G` has a limit, then `G` has a limit also.\n\nWe can't make this an instance, because `F` is not determined by the goal.\n(Even if this weren't a problem, it would cause a loop with `comp_hasLimit`.)\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] [inst_2 : Nonempty Œ±],\n  Nonempty (TopologicalSpace.PositiveCompacts Œ±)","name":"TopologicalSpace.PositiveCompacts.nonempty'","isProp":true,"docString":"In a nonempty locally compact space, there exists a compact set with nonempty interior. "},{"type":"‚àÄ {Œ± : Type u} [inst : Infinite Œ±] {s : Set Œ±} (hf : Set.Finite s), s·∂ú ‚àà Filter.hyperfilter Œ±","name":"Set.Finite.compl_mem_hyperfilter","isProp":true,"docString":"**Alias** of `Filter.compl_mem_hyperfilter_of_finite`."},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace M‚ÇÇ]\n  [inst_2 : Ring R] [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : AddCommGroup M‚ÇÇ] [inst_6 : Module R M‚ÇÇ]\n  (e : M ‚âÉL[R] M‚ÇÇ) (f : M ‚ÜíL[R] M‚ÇÇ),\n  ContinuousLinearMap.inverse f =\n    ContinuousLinearMap.comp (Ring.inverse (ContinuousLinearMap.comp (‚Üë(ContinuousLinearEquiv.symm e)) f))\n      ‚Üë(ContinuousLinearEquiv.symm e)","name":"ContinuousLinearMap.to_ring_inverse","isProp":true,"docString":"The function `ContinuousLinearEquiv.inverse` can be written in terms of `Ring.inverse` for the\nring of self-maps of the domain. "},{"type":"‚àÄ {Œì : Type u_1} {T : Type u_2} [inst : TopologicalSpace T] [inst_1 : VAdd Œì T] [self : ContinuousConstVAdd Œì T]\n  (Œ≥ : Œì), Continuous fun (x : T) ‚Ü¶ Œ≥ +·µ• x","name":"ContinuousConstVAdd.continuous_const_vadd","isProp":true,"docString":"The additive action `(+·µ•) : Œì ‚Üí T ‚Üí T` is continuous in the second argument. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {x : M}, Monoid.Closure {x} = powers x","name":"Monoid.closure_singleton","isProp":true,"docString":"The submonoid generated by an element of a monoid equals the set of natural number powers of\nthe element. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥ : ‚Ñù} (Œµ : ‚Ñù) (hŒ¥ : 0 ‚â§ Œ¥) (s : Set Œ±),\n  Metric.thickening Œµ (Metric.cthickening Œ¥ s) ‚äÜ Metric.thickening (Œµ + Œ¥) s","name":"Metric.thickening_cthickening_subset","isProp":true,"docString":"For the equality, see `thickening_cthickening`. "},{"type":"‚àÄ {Œ± : Sort u_1} {k : ‚Ñï} {l : ‚Ñï} (h : k = l) {f : (a : Fin k) ‚Üí Œ±} {g : (a : Fin l) ‚Üí Œ±},\n  (HEq f g : Prop) ‚Üî\n    (‚àÄ (i : Fin k), f i = g { val := ‚Üëi, isLt := ((Eq.rec ((Fin.isLt i=:‚Üëi < k)=:‚Üëi < k) h=:‚Üëi < l)=:‚Üëi < l) } : Prop)","name":"Fin.heq_fun_iff","isProp":true,"docString":"Assume `k = l`. If two functions defined on `Fin k` and `Fin l` are equal on each element,\nthen they coincide (in the heq sense). "},{"type":"Set.Infinite (setOf fun (p : ‚Ñï) ‚Ü¶ Nat.Prime p)","name":"Nat.infinite_setOf_prime","isProp":true,"docString":"A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. "},{"type":"‚àÄ {B : Type u_1} (F : Type u_4) {X : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace B]\n  [inst_2 : TopologicalSpace F] {E : (a : B) ‚Üí Type u_2} [inst_3 : TopologicalSpace (Bundle.TotalSpace E)]\n  [inst_4 : (b : B) ‚Üí TopologicalSpace (E b)] [inst_5 : FiberBundle F E] (f : (a : X) ‚Üí Bundle.TotalSpace E) {s : Set X}\n  {x‚ÇÄ : X},\n  (ContinuousWithinAt f s x‚ÇÄ : Prop) ‚Üî\n    ((ContinuousWithinAt (fun (x : X) ‚Ü¶ Bundle.TotalSpace.proj (f x)) s x‚ÇÄ : Prop) ‚àß\n        (ContinuousWithinAt (fun (x : X) ‚Ü¶ Prod.snd (‚Üë(trivializationAt F E (Bundle.TotalSpace.proj (f x‚ÇÄ))) (f x))) s\n            x‚ÇÄ :\n          Prop) :\n      Prop)","name":"FiberBundle.continuousWithinAt_totalSpace","isProp":true,"docString":"Characterization of continuous functions (at a point, within a set) into a fiber bundle. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CoheytingAlgebra Œ±] [inst_1 : CoheytingAlgebra Œ≤] (self : CoheytingHom Œ± Œ≤)\n  (a : Œ±) (b : Œ±),\n  SupHom.toFun (LatticeHom.toSupHom (CoheytingHom.toLatticeHom self)) (a \\ b) =\n    SupHom.toFun (LatticeHom.toSupHom (CoheytingHom.toLatticeHom self)) a \\\n      SupHom.toFun (LatticeHom.toSupHom (CoheytingHom.toLatticeHom self)) b","name":"CoheytingHom.map_sdiff'","isProp":true,"docString":"The proposition that a co-Heyting homomorphism preserves the difference operation."},{"type":"‚àÄ {Œ± : Type u_1} [self : Semifield Œ±] (a : Œ±) (b : Œ±), a / b = a * b‚Åª¬π","name":"Semifield.div_eq_mul_inv","isProp":true,"docString":"`a / b := a * b‚Åª¬π` "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±} (h : UniformEquicontinuous F) (i : Œπ), UniformContinuous (F i)","name":"UniformEquicontinuous.uniformContinuous","isProp":true,"docString":"Each function of a uniformly equicontinuous family is uniformly continuous. "},{"type":"‚àÄ {Œ± : Type u} {n : ‚Ñï} (a : Œ±) (v : Vector Œ± n), Vector.head (a ::·µ• v) = a","name":"Vector.head_cons","isProp":true,"docString":"The head of a vector obtained by prepending is the element prepended. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (t :\n    CategoryTheory.Limits.IsLimit\n      (CategoryTheory.Limits.PullbackCone.mk (ùüô X) (ùüô X) ((rfl=:ùüô X ‚â´ f = ùüô X ‚â´ f)=:ùüô X ‚â´ f = ùüô X ‚â´ f))),\n  CategoryTheory.Mono f","name":"CategoryTheory.Limits.PullbackCone.mono_of_isLimitMkIdId","isProp":true,"docString":"`f` is a mono if the pullback cone `(ùüô X, ùüô X)` is a limit for the pair `(f, f)`. The converse is\ngiven in `PullbackCone.is_id_of_mono`.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  [self : CategoryTheory.Functor.ReflectsMonomorphisms F] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (a : CategoryTheory.Mono (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)), CategoryTheory.Mono f","name":"CategoryTheory.Functor.ReflectsMonomorphisms.reflects","isProp":true,"docString":"A functor reflects monomorphisms if morphisms that are mapped to monomorphisms are themselves\nmonomorphisms. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : C(Œ±, Œ≤)} {g : C(Œ±, Œ≤)}\n  (H : f = g) (x : Œ±), ‚Üëf x = ‚Üëg x","name":"ContinuousMap.congr_fun","isProp":true,"docString":"Deprecated. Use `FunLike.congr_fun` instead. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {t‚ÇÅ : TopologicalSpace Œ±} {t‚ÇÇ : TopologicalSpace Œ±} {t‚ÇÉ : TopologicalSpace Œ≤}\n  (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÅ) {s : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (h‚ÇÇ : ContinuousOn f s), ContinuousOn f s","name":"ContinuousOn.mono_dom","isProp":true,"docString":"If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any finer topology on the source space. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f) (hg : Monotone g), Monotone fun (x : Œ±) ‚Ü¶ min (f x) (g x)","name":"Monotone.min","isProp":true,"docString":"Pointwise minimum of two monotone functions is a monotone function. "},{"type":"StrictMono fun (n : ‚Ñï) ‚Ü¶ Nat.fib (n + 2)","name":"Nat.fib_add_two_strictMono","isProp":true,"docString":"`fib (n + 2)` is strictly monotone. "},{"type":"‚àÄ {V : Type u} {G‚ÇÅ : SimpleGraph V} {G‚ÇÇ : SimpleGraph V} [inst : Fintype ‚Üë(SimpleGraph.edgeSet G‚ÇÅ)]\n  [inst_1 : Fintype ‚Üë(SimpleGraph.edgeSet G‚ÇÇ)] (a : G‚ÇÅ < G‚ÇÇ), SimpleGraph.edgeFinset G‚ÇÅ ‚äÇ SimpleGraph.edgeFinset G‚ÇÇ","name":"SimpleGraph.edgeFinset_strict_mono","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.edgeFinset_ssubset_edgeFinset`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : StrictConvexOn ùïú s f) {x : E} {y : E} (hx : x ‚àà s) (hy : y ‚àà s) (hxy : x ‚â† y)\n  {a : ùïú} {b : ùïú} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1), f (a ‚Ä¢ x + b ‚Ä¢ y) < max (f x) (f y)","name":"StrictConvexOn.lt_on_open_segment'","isProp":true,"docString":"A strictly convex function on an open segment is strictly upper-bounded by the max of its\nendpoints. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {p : Filter Œπ} {g : (a : Œπ) ‚Üí Œ≤} {b : Œ≤}\n  (hg : Filter.Tendsto g p (nhds b)) (p' : Filter Œ±),\n  TendstoUniformlyOnFilter (fun (n : Œπ) (x : Œ±) ‚Ü¶ g n) (fun (x : Œ±) ‚Ü¶ b) p p'","name":"Filter.Tendsto.tendstoUniformlyOnFilter_const","isProp":true,"docString":"If a sequence `g` converges to some `b`, then the sequence of constant functions\n`Œª n, Œª a, g n` converges to the constant function `Œª a, b` on any set `s` "},{"type":"‚àÄ {F : Type u_2} {R : Type u_1} [inst : Semiring R] [inst : RingHomClass F ‚Ñö R] (f : F) (g : F), f = g","name":"RingHom.ext_rat","isProp":true,"docString":"Any two ring homomorphisms from `‚Ñö` to a semiring are equal. If the codomain is a division ring,\nthen this lemma follows from `eq_ratCast`. "},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±]\n  (H : FreeAddGroup.reduce L‚ÇÅ = FreeAddGroup.reduce L‚ÇÇ), FreeAddGroup.mk L‚ÇÅ = FreeAddGroup.mk L‚ÇÇ","name":"FreeAddGroup.reduce.exact","isProp":true,"docString":"If two words have a common maximal reduction, then they correspond to the same\nelement in the additive free group."},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} {r : outParam ((a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop)}\n  {s : outParam ((a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop)} [self : RelHomClass F r s] (f : F) {a : Œ±} {b : Œ±} (a_1 : r a b),\n  s (‚Üëf a) (‚Üëf b)","name":"RelHomClass.map_rel","isProp":true,"docString":"A `RelHomClass` sends related elements to related elements "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFiltered C] {J : Type v}\n  [inst_2 : CategoryTheory.SmallCategory J] [inst_3 : CategoryTheory.FinCategory J] (F : J ‚•§ C),\n  Nonempty (CategoryTheory.Limits.Cocone F)","name":"CategoryTheory.IsFiltered.cocone_nonempty","isProp":true,"docString":"If we have `IsFiltered C`, then for any functor `F : J ‚•§ C` with `FinCategory J`,\nthere exists a cocone over `F`.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : SemilatticeSup Œ≤] {K : Set Œ±} (h‚ÇÅ : IsComplete K)\n  {u : (a : Œ≤) ‚Üí Œ±} (h‚ÇÇ : ‚àÄ (n : Œ≤), u n ‚àà K) (h‚ÇÉ : CauchySeq u),\n  ‚àÉ (v : Œ±), (v ‚àà K : Prop) ‚àß (Filter.Tendsto u Filter.atTop (nhds v) : Prop)","name":"cauchySeq_tendsto_of_isComplete","isProp":true,"docString":"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedAddCommGroup Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"LinearOrderedAddCommGroup.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] {s : Set (Set Œ±)} (self : TopologicalSpace.IsTopologicalBasis s),\n  t = TopologicalSpace.generateFrom s","name":"TopologicalSpace.IsTopologicalBasis.eq_generateFrom","isProp":true,"docString":"The topology is generated by sets from `s`. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (s : Submodule K V),\n  (Module.rank K { x : V // x ‚àà s } ‚â§ 1 : Prop) ‚Üî\n    (‚àÉ (v‚ÇÄ : V), (v‚ÇÄ ‚àà s : Prop) ‚àß (s ‚â§ Submodule.span K {v‚ÇÄ} : Prop) : Prop)","name":"rank_submodule_le_one_iff","isProp":true,"docString":"A submodule has dimension at most `1` if and only if there is a\nsingle vector in the submodule such that the submodule is contained in\nits span. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Monovary f g),\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i) ‚â§ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i","name":"Monovary.sum_comp_perm_mul_le_sum_mul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise multiplication of `f` and `g` is maximized when `f` and\n`g` monovary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set (Set Œ±)} (hs : IsPiSystem s),\n  MeasurableSpace.generateFrom s =\n    MeasurableSpace.DynkinSystem.toMeasurableSpace (MeasurableSpace.DynkinSystem.generate s)\n      (fun (t‚ÇÅ : Set Œ±) ‚Ü¶\n        (_ :\n          ‚àÄ (t‚ÇÇ : Set Œ±) (ht‚ÇÅ : MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) t‚ÇÅ)\n            (ht‚ÇÇ : MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) t‚ÇÇ),\n            MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s)\n              (t‚ÇÅ ‚à©\n                t‚ÇÇ))=:‚àÄ (t‚ÇÅ : Set Œ±) (t‚ÇÇ : Set Œ±)\n          (ht‚ÇÅ : MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) t‚ÇÅ)\n          (ht‚ÇÇ : MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) t‚ÇÇ),\n          MeasurableSpace.DynkinSystem.Has (MeasurableSpace.DynkinSystem.generate s) (t‚ÇÅ ‚à© t‚ÇÇ))","name":"MeasurableSpace.DynkinSystem.generateFrom_eq","isProp":true,"docString":"**Dynkin's œÄ-Œª theorem**:\nGiven a collection of sets closed under binary intersections, then the Dynkin system it\ngenerates is equal to the œÉ-algebra it generates.\nThis result is known as the œÄ-Œª theorem.\nA collection of sets closed under binary intersection is called a œÄ-system (often requiring\nadditionnally that is is non-empty, but we drop this condition in the formalization).\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  [inst_2 : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)],\n  CategoryTheory.IsSplitMono CategoryTheory.Limits.coprod.inr","name":"CategoryTheory.Limits.isSplitMono_coprod_inr","isProp":true,"docString":"In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms. "},{"type":"‚àÄ {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} (s : Finset { x : Œ± // p x }) {a : Œ±}\n  (h : a ‚àà Finset.map (Function.Embedding.subtype fun (x : Œ±) ‚Ü¶ p x) s), p a","name":"Finset.property_of_mem_map_subtype","isProp":true,"docString":"If a `Finset` of a subtype is converted to the main type with\n`Embedding.subtype`, all elements of the result have the property of\nthe subtype. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (L : List G),\n  (List.prod L)‚Åª¬π = List.prod (List.reverse (List.map (fun (x : G) ‚Ü¶ x‚Åª¬π) L))","name":"List.prod_inv_reverse","isProp":true,"docString":"This is the `List.prod` version of `mul_inv_rev` "},{"type":"‚àÄ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst_3 : IsScalarTower R S M] (ra : IsSMulRegular M a) (rs : IsSMulRegular M s), IsSMulRegular M (a ‚Ä¢ s)","name":"IsSMulRegular.smul","isProp":true,"docString":"The product of `M`-regular elements is `M`-regular. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {s : (a : Œπ) ‚Üí Set Œ±} (self : IndexedPartition s) (x : Œ±),\n  x ‚àà s (IndexedPartition.index self x)","name":"IndexedPartition.mem_index","isProp":true,"docString":"membership invariance for `index`"},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MulZeroClass M‚ÇÄ], (fun (x : M‚ÇÄ) (x_1 : M‚ÇÄ) ‚Ü¶ x * x_1) 0 = Function.const M‚ÇÄ 0","name":"zero_mul_eq_const","isProp":true,"docString":"To match `one_mul_eq_id`. "},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  {X : CategoryTheory.SimplicialObject C} (q : ‚Ñï), HomologicalComplex.Hom.f (AlgebraicTopology.DoldKan.Q q) 0 = 0","name":"AlgebraicTopology.DoldKan.Q_f_0_eq","isProp":true,"docString":"All the `Q q` coincide with `0` in degree 0. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (s : Set Œ±), frontier (s·∂ú) = frontier s","name":"frontier_compl","isProp":true,"docString":"The complement of a set has the same frontier as the original set. "},{"type":"‚àÄ {C : Type u_4} {D : Type u_6} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] (L : C ‚•§ D)\n  (W : CategoryTheory.MorphismProperty C) {E : Type u_1} [inst_2 : CategoryTheory.Category E] (L' : C ‚•§ E) (eq : D ‚âå E)\n  [inst_3 : CategoryTheory.Functor.IsLocalization L W] (e : L ‚ãô CategoryTheory.Equivalence.functor eq ‚âÖ L'),\n  CategoryTheory.Functor.IsLocalization L' W","name":"CategoryTheory.Functor.IsLocalization.of_equivalence_target","isProp":true,"docString":"If `L : C ‚•§ D` is a localization for `W : MorphismProperty C`, then it is also\nthe case of a functor obtained by post-composing `L` with an equivalence of categories. "},{"type":"‚àÄ {Œ± : Type u}, Function.Injective FreeGroup.of","name":"FreeGroup.of_injective","isProp":true,"docString":"The canonical map from the type to the free group is an injection. "},{"type":"‚àÄ {Œ± : Type u_1} [self : DivisionSemiring Œ±] (n : ‚Ñï) (a : Œ±),\n  DivisionSemiring.zpow (Int.ofNat (Nat.succ n)) a = a * DivisionSemiring.zpow (Int.ofNat n) a","name":"DivisionSemiring.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_6} {Œ≥ : Type u_5} {Œ≥' : Type u_7} {Œ¥ : Type u_3} {Œµ : Type u_1} {s : Set Œ±}\n  {t : Set Œ≤} {u : Set Œ≥} {f : (a : Œ±) ‚Üí (a : Œ¥) ‚Üí Œµ} {g : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Œ¥} {f‚ÇÅ : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≤'}\n  {f‚ÇÇ : (a : Œ±) ‚Üí (a : Œ≥) ‚Üí Œ≥'} {g' : (a : Œ≤') ‚Üí (a : Œ≥') ‚Üí Œµ}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), f a (g b c) = g' (f‚ÇÅ a b) (f‚ÇÇ a c)),\n  Set.image2 f s (Set.image2 g t u) ‚äÜ Set.image2 g' (Set.image2 f‚ÇÅ s t) (Set.image2 f‚ÇÇ s u)","name":"Set.image2_distrib_subset_left","isProp":true,"docString":"The other direction does not hold because of the `s`-`s` cross terms on the RHS. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_4}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {Œπ : Type u_5} {M‚ÇÇ : Type u_2} [inst_5 : AddCommMonoid M‚ÇÇ]\n  [inst_6 : Module R M‚ÇÇ] (f : M‚ÇÇ ‚Üí‚Çó[R] M) (hf : Function.Surjective ‚Üëf),\n  Function.Injective fun (g : AlternatingMap R M N Œπ) ‚Ü¶ AlternatingMap.compLinearMap g f","name":"AlternatingMap.compLinearMap_injective","isProp":true,"docString":"Composing with a surjective linear map is injective. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : CommMonoid Œ≤] (f : (a : ‚Ñï) ‚Üí Œ≤)\n  (h_mult : ‚àÄ (x : ‚Ñï) (y : ‚Ñï) (a : Nat.coprime x y), f (x * y) = f x * f y) (hf0 : f 0 = 1) (hf1 : f 1 = 1) {n : ‚Ñï},\n  f n = Finsupp.prod (Nat.factorization n) fun (p : ‚Ñï) (k : ‚Ñï) ‚Ü¶ f (p ^ k)","name":"Nat.multiplicative_factorization'","isProp":true,"docString":"For any multiplicative function `f` with `f 1 = 1` and `f 0 = 1`,\nwe can evaluate `f n` by evaluating `f` at `p ^ k` over the factorization of `n` "},{"type":"‚àÄ (k : Type u_1) [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ),\n  Finset.centroidWeightsIndicator k s = Set.indicator (‚Üës) (Finset.centroidWeights k s)","name":"Finset.centroidWeightsIndicator_def","isProp":true,"docString":"The definition of `centroidWeightsIndicator`. "},{"type":"‚àÄ {Œº : YoungDiagram},\n  YoungDiagram.ofRowLens (YoungDiagram.rowLens Œº)\n      ((YoungDiagram.rowLens_sorted\n            Œº=:List.Sorted (fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x ‚â• x_1)\n            (YoungDiagram.rowLens Œº))=:List.Sorted (fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x ‚â• x_1) (YoungDiagram.rowLens Œº)) =\n    Œº","name":"YoungDiagram.ofRowLens_to_rowLens_eq_self","isProp":true,"docString":"The left_inv direction of the equivalence "},{"type":"‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} {p : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Prop} {x‚ÇÄ : (a : Œ±) √ó' Subtype (p a)}\n  {x‚ÇÅ : (a : Œ±) √ó' Subtype (p a)} (a : PSigma.fst x‚ÇÄ = PSigma.fst x‚ÇÅ) (a : ‚Üë(PSigma.snd x‚ÇÄ) = ‚Üë(PSigma.snd x‚ÇÅ)), x‚ÇÄ = x‚ÇÅ","name":"PSigma.subtype_ext","isProp":true,"docString":"A specialized ext lemma for equality of `PSigma` types over an indexed subtype. "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ : R‚ÇÅ ‚Üí+* R‚ÇÇ}\n  {œÉ' : outParam (R‚ÇÇ ‚Üí+* R‚ÇÅ)} [self : RingHomInvPair œÉ œÉ'], RingHom.comp œÉ' œÉ = RingHom.id R‚ÇÅ","name":"RingHomInvPair.comp_eq","isProp":true,"docString":"`œÉ'` is a left inverse of `œÉ` "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [hq : ExpChar R 1], CharZero R","name":"charZero_of_expChar_one'","isProp":true,"docString":"The characteristic is zero if the exponential characteristic is one. "},{"type":"‚àÄ {R : Type u_1} {E : Type u_2} {F : Type u_3} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E]\n  [inst_2 : AddCommGroup F] [inst_3 : TopologicalSpace F] [inst_4 : TopologicalAddGroup F] [inst_5 : Ring R]\n  [inst_6 : Module R E] [inst_7 : Module R F] {f : E ‚Üí·µÉ[R] F},\n  (Continuous ‚Üëf : Prop) ‚Üî (Continuous ‚Üë(AffineMap.linear f) : Prop)","name":"AffineMap.continuous_iff","isProp":true,"docString":"An affine map is continuous iff its underlying linear map is continuous. See also\n`AffineMap.continuous_linear_iff`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]\n  [inst_2 : CategoryTheory.Limits.HasEqualizers C], CategoryTheory.Limits.HasPullbacks C","name":"CategoryTheory.Limits.hasPullbacks_of_hasBinaryProducts_of_hasEqualizers","isProp":true,"docString":"If a category has all binary products and all equalizers, then it also has all pullbacks.\nAs usual, this is not an instance, since there may be a more direct way to construct\npullbacks. "},{"type":"‚àÄ {M : Type u} {R : Type v} [inst : Monoid M] [inst_1 : Semiring R] [self : MulSemiringAction M R] (g : M), g ‚Ä¢ 1 = 1","name":"MulSemiringAction.smul_one","isProp":true,"docString":"Multipliying `1` by a scalar gives `1` "},{"type":"‚àÄ {Œ± : Sort u} {Œ≤ : (a : Œ±) ‚Üí Sort v} {r : (x : Œ±) ‚Üí (a : Œ≤ x) ‚Üí Prop} (h : ‚àÄ (x : Œ±), ‚àÉ (y : Œ≤ x), r x y),\n  ‚àÉ (f : (x : Œ±) ‚Üí Œ≤ x), ‚àÄ (x : Œ±), r x (f x)","name":"Classical.axiomOfChoice","isProp":true,"docString":"the axiom of choice "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] (self : CategoryTheory.Idempotents.Karoubi C),\n  CategoryTheory.Idempotents.Karoubi.p self ‚â´ CategoryTheory.Idempotents.Karoubi.p self =\n    CategoryTheory.Idempotents.Karoubi.p self","name":"CategoryTheory.Idempotents.Karoubi.idem","isProp":true,"docString":"the condition that the given endomorphism is an idempotent "},{"type":"‚àÄ (R : Type u) (M : Type v) (N : Type w) [inst : CommRing R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\n  FiniteDimensional.finrank R (M ‚Üí‚Çó[R] N) = FiniteDimensional.finrank R M * FiniteDimensional.finrank R N","name":"FiniteDimensional.finrank_linearMap","isProp":true,"docString":"The finrank of `M ‚Üí‚Çó[R] N` is `(finrank R M) * (finrank R N)`. "},{"type":"‚àÄ {n : ‚Ñï} (p : Fin (n + 1)), Set.range ‚Üë(Fin.succAbove p) = {p}·∂ú","name":"Fin.range_succAbove","isProp":true,"docString":"The range of `p.succAbove` is everything except `p`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C], CategoryTheory.Limits.HasFiniteBiproducts C","name":"CategoryTheory.Limits.HasFiniteBiproducts.of_hasFiniteCoproducts","isProp":true,"docString":"A preadditive category with finite coproducts has finite biproducts. "},{"type":"‚àÄ {ùïú : Type u_3} {E : Type u_4} {Œπ : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïú E] {Œπ' : Type u_1} (f : Œπ' ‚Ü™ Œπ) {p : (a : Œπ) ‚Üí E} (hc : ConvexIndependent ùïú p),\n  ConvexIndependent ùïú (p ‚àò ‚Üëf)","name":"ConvexIndependent.comp_embedding","isProp":true,"docString":"If a family is convex independent, so is any subfamily given by composition of an embedding into\nindex type with the original family. "},{"type":"‚àÄ {R : Type u_2} {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_5} {M‚ÇÅ : Type u_3} {M‚ÇÇ : Type u_4} [inst : CommSemiring R]\n  [inst_1 : CommSemiring R‚ÇÅ] [inst_2 : AddCommMonoid M‚ÇÅ] [inst_3 : Module R‚ÇÅ M‚ÇÅ] [inst_4 : CommSemiring R‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÇ M‚ÇÇ] {I‚ÇÅ : R‚ÇÅ ‚Üí+* R} {I‚ÇÇ : R‚ÇÇ ‚Üí+* R} {B : M‚ÇÅ ‚Üí‚Çõ‚Çó[I‚ÇÅ] M‚ÇÇ ‚Üí‚Çõ‚Çó[I‚ÇÇ] R},\n  (LinearMap.SeparatingRight B : Prop) ‚Üî (LinearMap.ker (LinearMap.flip B) = ‚ä• : Prop)","name":"LinearMap.separatingRight_iff_flip_ker_eq_bot","isProp":true,"docString":"A bilinear form is right-separating if and only if its flip has a trivial kernel. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] (x : Œ≤),\n  AddAction.IsPretransitive Œ± ‚Üë(AddAction.orbit Œ± x)","name":"AddAction.instIsPretransitiveElemOrbitToAddMonoidToSubNegAddMonoidToVAddInstAddActionElemOrbit","isProp":true,"docString":"The action of an additive group on an orbit is transitive."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {c : Œ±} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±]\n  (h : Function.Periodic f c) (hc : 0 < c) (x : Œ±) (a : Œ±),\n  ‚àÉ (y : Œ±), (y ‚àà Set.Ico a (a + c) : Prop) ‚àß (f x = f y : Prop)","name":"Function.Periodic.exists_mem_Ico","isProp":true,"docString":"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ‚àà Ico a (a + c)` such that `f x = f y`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteColimits C],\n  CategoryTheory.Limits.HasFiniteCoproducts C","name":"CategoryTheory.Limits.hasFiniteCoproducts_of_hasFiniteColimits","isProp":true,"docString":"If `C` has finite colimits then it has finite coproducts. "},{"type":"‚àÄ {p : (a : Ordinal) ‚Üí Prop} (i : Ordinal) (h : ‚àÄ (j : Ordinal) (a : ‚àÄ (k : Ordinal) (a : k < j), p k), p j), p i","name":"Ordinal.induction","isProp":true,"docString":"Reformulation of well founded induction on ordinals as a lemma that works with the\n`induction` tactic, as in `induction i using Ordinal.induction with i IH`. "},{"type":"‚àÄ {Œ± : Sort u_1} (P : Prop) [inst : Decidable (P : Prop)] (x : (a : ¬¨(P : Prop)) ‚Üí Œ±)\n  (y : (a : ¬¨(¬¨(P : Prop) : Prop)) ‚Üí Œ±),\n  dite (¬¨(P : Prop) : Prop) x y =\n    dite (P : Prop) (fun (h : P) ‚Ü¶ y ((not_not_intro h=:¬¨(¬¨(P : Prop) : Prop))=:¬¨(¬¨(P : Prop) : Prop))) x","name":"dite_not","isProp":true,"docString":"Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {l' : Œ±}\n  {s : Set Œ±} (hl' : l' < a),\n  (s ‚àà nhdsWithin a (Set.Iio a) : Prop) ‚Üî (‚àÉ (l : Œ±), (l ‚àà Set.Iio a : Prop) ‚àß (Set.Ioo l a ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Iio_iff_exists_Ioo_subset'","isProp":true,"docString":"A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`\nwith `l < a`, provided `a` is not a bottom element. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] {v : (a : n) ‚Üí Œ±},\n  (IsUnit (Matrix.diagonal v) : Prop) ‚Üî (IsUnit v : Prop)","name":"Matrix.isUnit_diagonal","isProp":true,"docString":"When lowered to a prop, `Matrix.diagonalInvertibleEquivInvertible` forms an `iff`. "},{"type":"Subsingleton (Fin 1)","name":"subsingleton_fin_one","isProp":true,"docString":"`Fin 1` is a subsingleton. "},{"type":"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v : V)\n  (hv : v ‚â† 0), IsAtom (Submodule.span K {v})","name":"nonzero_span_atom","isProp":true,"docString":"For a module over a division ring, the span of a nonzero element is an atom of the\nlattice of submodules. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : LinearOrderedAddCommMonoid Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤]\n  {s : Set E} {f : (a : E) ‚Üí Œ≤} (hf : ConcaveOn ùïú s f) {x : E} {y : E} (hx : x ‚àà s) (hy : y ‚àà s) {a : ùïú} {b : ùïú}\n  (ha : 0 ‚â§ a) (hb : 0 ‚â§ b) (hab : a + b = 1), min (f x) (f y) ‚â§ f (a ‚Ä¢ x + b ‚Ä¢ y)","name":"ConcaveOn.ge_on_segment'","isProp":true,"docString":"A concave function on a segment is lower-bounded by the min of its endpoints. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±}\n  {p : Filter Œπ} {g : (a : Œπ) ‚Üí Œ±} [inst_1 : TopologicalSpace Œ±] (h : TendstoUniformly F f p) (hf : ContinuousAt f x)\n  (hg : Filter.Tendsto g p (nhds x)), Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n (g n)) p (nhds (f x))","name":"TendstoUniformly.tendsto_comp","isProp":true,"docString":"If `F‚Çô` tends uniformly to `f`, and `g‚Çô` tends to `x`, then `F‚Çô g‚Çô` tends to `f x`. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : (a : J) ‚Üí X ‚ü∂ Y}\n  [inst_1 : CategoryTheory.Limits.HasWideCoequalizer f] [inst_2 : Nonempty J],\n  CategoryTheory.Epi (CategoryTheory.Limits.wideCoequalizer.œÄ f)","name":"CategoryTheory.Limits.wideCoequalizer.œÄ_epi","isProp":true,"docString":"A wide coequalizer morphism is an epimorphism "},{"type":"‚àÄ {x : ‚Ñ§} {y : ‚Ñ§} {z : ‚Ñ§}, (PythagoreanTriple x y z : Prop) ‚Üî (PythagoreanTriple y x z : Prop)","name":"pythagoreanTriple_comm","isProp":true,"docString":"Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`.\nThis comes from additive commutativity. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±} (a : IsLowerSet s) ‚¶Éa : Œ±‚¶Ñ (a_1 : a ‚àà s), Set.Iic a ‚äÜ s","name":"IsLowerSet.Iic_subset","isProp":true,"docString":"**Alias** of the forward direction of `isLowerSet_iff_Iic_subset`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {J : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category J]\n  [inst_2 : CategoryTheory.Limits.HasLimitsOfShape J·µí·µñ C], CategoryTheory.Limits.HasColimitsOfShape J C·µí·µñ","name":"CategoryTheory.Limits.hasColimitsOfShape_op_of_hasLimitsOfShape","isProp":true,"docString":"If `C` has colimits of shape `J·µí·µñ`, we can construct limits in `C·µí·µñ` of shape `J`.\n"},{"type":"‚àÄ {R : Type u_1} [inst : EuclideanDomain R] {abv : AbsoluteValue R ‚Ñ§} (n : ‚Ñï) (h : AbsoluteValue.IsAdmissible abv)\n  {Œµ : ‚Ñù} (_hŒµ : 0 < Œµ) {b : R} (_hb : b ‚â† 0)\n  (A : (a : Fin (Nat.succ (AbsoluteValue.IsAdmissible.card h Œµ ^ n))) ‚Üí (a : Fin n) ‚Üí R),\n  ‚àÉ (i‚ÇÄ : Fin (Nat.succ (AbsoluteValue.IsAdmissible.card h Œµ ^ n))),\n    ‚àÉ (i‚ÇÅ : Fin (Nat.succ (AbsoluteValue.IsAdmissible.card h Œµ ^ n))),\n      (i‚ÇÄ ‚â† i‚ÇÅ : Prop) ‚àß (‚àÄ (k : Fin n), ‚Üë(‚Üëabv (A i‚ÇÅ k % b - A i‚ÇÄ k % b)) < ‚Üëabv b ‚Ä¢ Œµ : Prop)","name":"AbsoluteValue.IsAdmissible.exists_approx_aux","isProp":true,"docString":"Any large enough family of vectors in `R^n` has a pair of elements\nwhose remainders are close together, pointwise. "},{"type":"‚àÄ {Œ± : Type u} (a : Œ±), ULift.down { down := a } = a","name":"ULift.down_up","isProp":true,"docString":"Bijection between `Œ±` and `ULift.{v} Œ±` "},{"type":"‚àÄ {Œ± : Type u} [inst : AddRightCancelMonoid Œ±], FaithfulVAdd Œ± Œ±","name":"AddRightCancelMonoid.faithfulVAdd","isProp":true,"docString":"`AddMonoid.toAddAction` is faithful on additive cancellative monoids. "},{"type":"‚àÄ {Œ± : Type u‚ÇÅ} {X : CategoryTheory.Discrete Œ±} {Y : CategoryTheory.Discrete Œ±} (i : X ‚ü∂ Y),\n  CategoryTheory.Discrete.as X = CategoryTheory.Discrete.as Y","name":"CategoryTheory.Discrete.eq_of_hom","isProp":true,"docString":"Extract the equation from a morphism in a discrete category. "},{"type":"‚àÄ {Œ± : Type u_1} {E' : Type u_2} {F' : Type u_3} [inst : SeminormedAddCommGroup E'] [inst_1 : SeminormedAddCommGroup F']\n  {c : ‚Ñù} {f' : (a : Œ±) ‚Üí E'} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±}\n  (a : Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ ‚Äñf' x‚Äñ) fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ), Asymptotics.IsBigOWith c l f' g'","name":"Asymptotics.IsBigOWith.of_norm_norm","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigOWith_norm_norm`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] {f : (a : Œ≤) ‚Üí Œ±},\n  (Metric.Bounded (Set.range f) : Prop) ‚Üî (‚àÉ (C : ‚Ñù), ‚àÄ (x : Œ≤) (y : Œ≤), dist (f x) (f y) ‚â§ C : Prop)","name":"Metric.bounded_range_iff","isProp":true,"docString":"Characterization of the boundedness of the range of a function "},{"type":"‚àÄ {X : Type u} {Y : Type u} (f : X ‚ü∂ Y), (CategoryTheory.Epi f : Prop) ‚Üî (Function.Surjective f : Prop)","name":"CategoryTheory.epi_iff_surjective","isProp":true,"docString":"A morphism in `Type` is an epimorphism if and only if it is surjective.\n\nSee <https://stacks.math.columbia.edu/tag/003C>.\n"},{"type":"‚àÄ {B : Type u_2} {F : Type u_3} {Z : Type u_1} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  {proj : (a : Z) ‚Üí B} [inst_2 : TopologicalSpace Z] (e : Trivialization F proj) {x : Z}\n  (ex : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv (Trivialization.toLocalHomeomorph e))), ContinuousAt proj x","name":"Trivialization.continuousAt_proj","isProp":true,"docString":"In the domain of a bundle trivialization, the projection is continuous"},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±}, (Set.Countable s : Prop) ‚Üî (‚àÉ (f : (a : Œ±) ‚Üí ‚Ñï), Set.InjOn f s : Prop)","name":"Set.countable_iff_exists_injOn","isProp":true,"docString":"A set `s : Set Œ±` is countable if and only if there exists a function `Œ± ‚Üí ‚Ñï` injective\non `s`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M ‚âÉ* N) (x : M) (y : M), ‚Üëf (x * y) = ‚Üëf x * ‚Üëf y","name":"MulEquiv.map_mul","isProp":true,"docString":"A multiplicative isomorphism preserves multiplication. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.IsIso f]\n  (g : Y ‚ü∂ Z) [inst_2 : CategoryTheory.Limits.HasImage g], CategoryTheory.Limits.HasImage (f ‚â´ g)","name":"CategoryTheory.Limits.instHasImageCompToCategoryStruct","isProp":true,"docString":"If `has_image g`, then `has_image (f ‚â´ g)` when `f` is an isomorphism. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u} (œÉ : Equiv.Perm (Fin n)) (f : (a : Fin n) ‚Üí Œ±), List.ofFn (f ‚àò ‚ÜëœÉ) ~ List.ofFn f","name":"Equiv.Perm.ofFn_comp_perm","isProp":true,"docString":"The list obtained from a permutation of a tuple `f` is permutation equivalent to\nthe list obtained from `f`. "},{"type":"‚àÄ {R : Type u_1} [self : Distrib R] (a : R) (b : R) (c : R), (a + b) * c = a * c + b * c","name":"Distrib.right_distrib","isProp":true,"docString":"Multiplication is right distributive over addition "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} [inst_1 : CategoryTheory.Limits.HasPullbacks C]\n  (K : CategoryTheory.Pretopology C),\n  (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Pretopology.toGrothendieck C K) P : Prop) ‚Üî\n    (‚àÄ {X : C} (R : CategoryTheory.Presieve X) (a : R ‚àà CategoryTheory.Pretopology.coverings K X),\n        CategoryTheory.Presieve.IsSheafFor P R :\n      Prop)","name":"CategoryTheory.Presieve.isSheaf_pretopology","isProp":true,"docString":"For a topology generated by a basis, it suffices to check the sheaf condition on the basis\npresieves only.\n"},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasPullbacks C] {X : C} {Y : C}\n  (g : X ‚ü∂ Y) (f‚ÇÅ : CategoryTheory.Subobject Y) (f‚ÇÇ : CategoryTheory.Subobject Y),\n  Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Subobject.pullback g)) (f‚ÇÅ ‚äì f‚ÇÇ) =\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Subobject.pullback g)) f‚ÇÅ ‚äì\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Subobject.pullback g)) f‚ÇÇ","name":"CategoryTheory.Subobject.inf_pullback","isProp":true,"docString":"`‚äì` commutes with pullback. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_3} [inst_1 : CommMonoid N] {P : Type u_2}\n  [inst_2 : CommMonoid P] (f : Submonoid.LocalizationMap S N) {g : M ‚Üí* P}\n  (hg : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëg ‚Üëy)) {x : M} {y : M}\n  (h : ‚Üë(Submonoid.LocalizationMap.toMap f) x = ‚Üë(Submonoid.LocalizationMap.toMap f) y), ‚Üëg x = ‚Üëg y","name":"Submonoid.LocalizationMap.eq_of_eq","isProp":true,"docString":"Given a Localization map `f : M ‚Üí* N` for a Submonoid `S ‚äÜ M` and a map of `CommMonoid`s\n`g : M ‚Üí* P` such that `g(S) ‚äÜ Units P`, `f x = f y ‚Üí g x = g y` for all `x y : M`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] {a : Œ±} {b : Œ±}\n  (h : a < b) (s : Set Œ±),\n  List.TFAE\n    [(s ‚àà nhdsWithin b (Set.Iio b) : Prop), (s ‚àà nhdsWithin b (Set.Ico a b) : Prop),\n      (s ‚àà nhdsWithin b (Set.Ioo a b) : Prop), (‚àÉ (l : Œ±), (l ‚àà Set.Ico a b : Prop) ‚àß (Set.Ioo l b ‚äÜ s : Prop) : Prop),\n      (‚àÉ (l : Œ±), (l ‚àà Set.Iio b : Prop) ‚àß (Set.Ioo l b ‚äÜ s : Prop) : Prop)]","name":"TFAE_mem_nhdsWithin_Iio","isProp":true,"docString":"The following statements are equivalent:\n\n0. `s` is a neighborhood of `b` within `(-‚àû, b)`\n1. `s` is a neighborhood of `b` within `[a, b)`\n2. `s` is a neighborhood of `b` within `(a, b)`\n3. `s` includes `(l, b)` for some `l ‚àà [a, b)`\n4. `s` includes `(l, b)` for some `l < b` "},{"type":"‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {M : Type u_3} {M‚ÇÇ : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_4 : AddCommMonoid M‚ÇÇ] [inst_5 : Module R‚ÇÇ M‚ÇÇ]\n  (f : M ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (s : Set M‚ÇÇ), Submodule.span R (‚Üëf ‚Åª¬π' s) ‚â§ Submodule.comap f (Submodule.span R‚ÇÇ s)","name":"LinearMap.span_preimage_le","isProp":true,"docString":"**Alias** of `Submodule.span_preimage_le`."},{"type":"‚àÄ (Œ± : Type u) (Œ≤ : Type v), (Nonempty (Œ± ‚Ü™ Œ≤) : Prop) ‚à® (Nonempty (Œ≤ ‚Ü™ Œ±) : Prop)","name":"Function.Embedding.total","isProp":true,"docString":"The cardinals are totally ordered. See\n`Cardinal.conditionallyCompleteLinearOrderBot` for (one of) the lattice\ninstance. "},{"type":"‚àÄ {Œ± : Type u_2} [inst : DecidableEq Œ±] (s : Finset Œ±) {R : Type u_1} [inst_1 : Semiring R] (x : (a : Œ±) ‚Üí R)\n  (hc : Set.Pairwise ‚Üës fun (i : Œ±) (j : Œ±) ‚Ü¶ Commute (x i) (x j)) (n : ‚Ñï),\n  Finset.sum s x ^ n =\n    Finset.sum Finset.univ fun (k : { x : Sym Œ± n // x ‚àà Finset.sym s n }) ‚Ü¶\n      ‚Üë(Multiset.multinomial ‚Üë‚Üëk) *\n        Multiset.noncommProd (Multiset.map x ‚Üë‚Üëk)\n          ((Multiset.map_set_pairwise\n                ((Set.Pairwise.mono\n                      ((Iff.mp\n                            ((Finset.mem_sym_iff=:(‚Üëk ‚àà Finset.sym s n : Prop) ‚Üî\n                                  (‚àÄ (a : Œ±) (a_1 : a ‚àà ‚Üëk), a ‚àà s :\n                                    Prop))=:(‚Üëk ‚àà Finset.sym s n : Prop) ‚Üî (‚àÄ (a : Œ±) (a_1 : a ‚àà ‚Üëk), a ‚àà s : Prop))\n                            ((Subtype.property\n                                  k=:‚Üëk ‚àà\n                                  Finset.sym s\n                                    n)=:‚Üëk ‚àà\n                                Finset.sym s n)=:‚àÄ (a : Œ±) (a_1 : a ‚àà ‚Üëk), a ‚àà s)=:‚àÄ (a : Œ±) (a_1 : a ‚àà ‚Üëk), a ‚àà s)\n                      hc=:Set.Pairwise (setOf fun (a : Œ±) ‚Ü¶ a ‚àà ‚Üë‚Üëk) fun (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) ‚Ü¶\n                      Commute (x a‚ÇÅ)\n                        (x\n                          a‚ÇÇ))=:Set.Pairwise (setOf fun (a : Œ±) ‚Ü¶ a ‚àà ‚Üë‚Üëk) fun (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±) ‚Ü¶\n                    Commute (x a‚ÇÅ)\n                      (x\n                        a‚ÇÇ))=:Set.Pairwise (setOf fun (b : R) ‚Ü¶ b ‚àà Multiset.map x ‚Üë‚Üëk)\n                Commute)=:Set.Pairwise (setOf fun (b : R) ‚Ü¶ b ‚àà Multiset.map x ‚Üë‚Üëk) Commute)","name":"Finset.sum_pow_of_commute","isProp":true,"docString":"The multinomial theorem\n\nProof is by induction on the number of summands.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±}\n  {p : Filter Œπ} {p' : Filter Œ±} (h : TendstoUniformlyOnFilter F f p p') (hx : Filter.principal {x} ‚â§ p'),\n  Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n x) p (nhds (f x))","name":"TendstoUniformlyOnFilter.tendsto_at","isProp":true,"docString":"Uniform converence implies pointwise convergence. "},{"type":"‚àÄ {Œ± : Type u} [inst : SemilatticeSup Œ±] [inst_1 : OrderBot Œ±] {Œπ : Type u} [inst_2 : Fintype Œπ] (f : (a : Œπ) ‚Üí Œ±),\n  (‚àê f) = Finset.sup Fintype.elems f","name":"CategoryTheory.Limits.CompleteLattice.finite_coproduct_eq_finset_sup","isProp":true,"docString":"A finite coproduct in the category of a `SemilatticeSup` with `OrderBot` is the same as the\nsupremum.\n"},{"type":"‚àÄ {Œ± : Type u_4} {Œ±' : Type u_6} {Œ≤ : Type u_5} {Œ≤' : Type u_7} {Œ≥ : Type u_3} {Œ¥ : Type u_2} {Œµ : Type u_1}\n  {f : Filter Œ±} {g : Filter Œ≤} {h : Filter Œ≥} {m : (a : Œ¥) ‚Üí (a : Œ≥) ‚Üí Œµ} {n : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥}\n  {m‚ÇÅ : (a : Œ±) ‚Üí (a : Œ≥) ‚Üí Œ±'} {m‚ÇÇ : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Œ≤'} {n' : (a : Œ±') ‚Üí (a : Œ≤') ‚Üí Œµ}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), m (n a b) c = n' (m‚ÇÅ a c) (m‚ÇÇ b c)),\n  Filter.map‚ÇÇ m (Filter.map‚ÇÇ n f g) h ‚â§ Filter.map‚ÇÇ n' (Filter.map‚ÇÇ m‚ÇÅ f h) (Filter.map‚ÇÇ m‚ÇÇ g h)","name":"Filter.map‚ÇÇ_distrib_le_right","isProp":true,"docString":"The other direction does not hold because of the `h`-`h` cross terms on the RHS. "},{"type":"‚àÄ {Œ± : Type u_1}, ‚ä• = 0","name":"Multiset.bot_eq_zero","isProp":true,"docString":"This is a `rfl` and `simp` version of `bot_eq_zero`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (f : M ‚âÉ+ N) (x : M) (y : M), ‚Üëf (x + y) = ‚Üëf x + ‚Üëf y","name":"AddEquiv.map_add","isProp":true,"docString":"An additive isomorphism preserves addition."},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : MulOneClass Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±] [inst_3 : PosMulMono Œ±]\n  (ha : a < 1) (hb : b ‚â§ 1) (a0 : 0 ‚â§ a), a * b < 1","name":"Left.mul_lt_of_lt_of_le_one_of_nonneg","isProp":true,"docString":"Assumes left covariance. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : CompactSpace Œ±] [inst : DiscreteTopology Œ±], Finite Œ±","name":"finite_of_compact_of_discrete","isProp":true,"docString":"A compact discrete space is finite. "},{"type":"‚àÄ (R : Type u_1) [inst : CommRing R] (p : ‚Ñï) [inst_1 : IsDomain R] [inst_2 : CharP R p], CharP (FractionRing R) p","name":"IsFractionRing.charP","isProp":true,"docString":"If `R` has characteristic `p`, then so does `FractionRing R`. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : LinearOrder Œ≤] [inst_1 : NoMinOrder Œ≤] {u : (a : ‚Ñï) ‚Üí Œ≤}\n  (hu : Filter.Tendsto u Filter.atTop Filter.atBot) (N : ‚Ñï),\n  ‚àÉ (n : ‚Ñï), (n ‚â• N : Prop) ‚àß (‚àÄ (k : ‚Ñï) (a : k < n), u n < u k : Prop)","name":"Filter.low_scores","isProp":true,"docString":"If `u` is a sequence which is unbounded below,\nthen after any point, it reaches a value strictly smaller than all previous values.\n"},{"type":"‚àÄ (n : ‚Ñï) (a : ‚Ñï) (b : ‚Ñï), (n < a : Prop) ‚à® ((b ‚â§ n : Prop) ‚à® (n ‚àà List.Ico a b : Prop) : Prop)","name":"List.Ico.trichotomy","isProp":true,"docString":"For any natural numbers n, a, and b, one of the following holds:\n1. n < a\n2. n ‚â• b\n3. n ‚àà Ico a b\n"},{"type":"‚àÄ (R : Type u) (M : Type v) [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M],\n  FiniteDimensional.finrank R M = Fintype.card (Module.Free.ChooseBasisIndex R M)","name":"FiniteDimensional.finrank_eq_card_chooseBasisIndex","isProp":true,"docString":"The finrank of a free module `M` over `R` is the cardinality of `ChooseBasisIndex R M`. "},{"type":"‚àÄ (k : Type u_1) [inst : DivisionRing k] {Œπ : Type u_2} (s : Finset Œπ) [inst_1 : CharZero k] (h : Finset.card s ‚â† 0),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ Finset.centroidWeights k s i) = 1","name":"Finset.sum_centroidWeights_eq_one_of_card_ne_zero","isProp":true,"docString":"In the characteristic zero case, the weights in the centroid sum\nto 1 if the number of points is not zero. "},{"type":"‚àÄ {Œ± : Type u} [inst : StrictOrderedSemiring Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} [inst_1 : ExistsAddOfLE Œ±] (hab : a < b)\n  (hcd : c < d), a * d + b * c < a * c + b * d","name":"mul_add_mul_lt_mul_add_mul","isProp":true,"docString":"Binary strict **rearrangement inequality**. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : Bornology Œ±] [inst_1 : Bornology Œ≤]\n  [self : LocallyBoundedMapClass F Œ± Œ≤] (f : F), Filter.comap (‚Üëf) (Bornology.cobounded Œ≤) ‚â§ Bornology.cobounded Œ±","name":"LocallyBoundedMapClass.comap_cobounded_le","isProp":true,"docString":"The pullback of the `Bornology.cobounded` filter under the function is contained in the\ncobounded filter. Equivalently, the function maps bounded sets to bounded sets. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : TopologicalSpace Œ±]\n  [inst_1 : TopologicalSpace Œ≤] [self : SpectralMapClass F Œ± Œ≤] (f : F), IsSpectralMap ‚Üëf","name":"SpectralMapClass.map_spectral","isProp":true,"docString":"statement that `F` is a type of spectal maps"},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {c : Con M} {d : Con M}, (Setoid.r = Setoid.r : Prop) ‚Üî (c = d : Prop)","name":"Con.ext'_iff","isProp":true,"docString":"Two congruence relations are equal iff their underlying binary relations are equal. "},{"type":"Cardinal.ord ‚àò Cardinal.aleph' = Ordinal.enumOrd (setOf fun (b : Ordinal) ‚Ü¶ Cardinal.ord (Ordinal.card b) = b)","name":"Cardinal.ord_aleph'_eq_enum_card","isProp":true,"docString":"`ord ‚àò aleph'` enumerates the ordinals that are cardinals. "},{"type":"‚àÄ (R : Type u_2) [inst : StrictOrderedCommRing R] {M : Type u_1} [inst_1 : AddCommGroup M] [inst_2 : Module R M] (v : M)\n  (h : v ‚â† 0),\n  -rayOfNeZero R v h =\n    rayOfNeZero R (-v)\n      ((Iff.mpr ((neg_ne_zero=:(-v ‚â† 0 : Prop) ‚Üî (v ‚â† 0 : Prop))=:(-v ‚â† 0 : Prop) ‚Üî (v ‚â† 0 : Prop)) h=:-v ‚â† 0)=:-v ‚â† 0)","name":"neg_rayOfNeZero","isProp":true,"docString":"The ray given by the negation of a nonzero vector. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : NoMaxOrder Œ±]\n  {a : Œ±} {s : Set Œ±},\n  (s ‚àà nhdsWithin a (Set.Ioi a) : Prop) ‚Üî (‚àÉ (u : Œ±), (u ‚àà Set.Ioi a : Prop) ‚àß (Set.Ioo a u ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Ioi_iff_exists_Ioo_subset","isProp":true,"docString":"A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`\nwith `a < u`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : Quiver.IsThin C], CategoryTheory.LocallySmall C","name":"CategoryTheory.locallySmall_of_thin","isProp":true,"docString":"Any thin category is locally small.\n"},{"type":"‚àÄ {M : Type u} [self : RightCancelMonoid M] (x : M), RightCancelMonoid.npow 0 x = 1","name":"RightCancelMonoid.npow_zero","isProp":true,"docString":"Raising to the power `(0 : ‚Ñï)` gives `1`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] (X : C),\n  (CategoryTheory.Simple X : Prop) ‚Üî (IsSimpleOrder (CategoryTheory.Subobject X) : Prop)","name":"CategoryTheory.simple_iff_subobject_isSimpleOrder","isProp":true,"docString":"`X` is simple iff it has subobject lattice `{‚ä•, ‚ä§}`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ≤) ‚Üí (a : Œ≤) ‚Üí Prop} (self : r ‚â∫i s) (b : Œ≤),\n  (s b (PrincipalSeg.top self) : Prop) ‚Üî (‚àÉ (a : Œ±), ‚Üë(PrincipalSeg.toRelEmbedding self) a = b : Prop)","name":"PrincipalSeg.down'","isProp":true,"docString":"The image of the order embedding is the set of elements `b` such that `s b top` "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {p : Polynomial R} {q : Polynomial R},\n  p * q =\n    Finset.sum (Polynomial.support p) fun (i : ‚Ñï) ‚Ü¶\n      Polynomial.sum q fun (j : ‚Ñï) (a : R) ‚Ü¶ ‚Üë(Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)","name":"Polynomial.mul_eq_sum_sum","isProp":true,"docString":"Expressing the product of two polynomials as a double sum. "},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (h : 0 < r * (b - a)),\n  (‚Üë(AffineMap.lineMap (f a) (f b)) r ‚â§ f (‚Üë(AffineMap.lineMap a b) r) : Prop) ‚Üî\n    (slope f a b ‚â§ slope f a (‚Üë(AffineMap.lineMap a b) r) : Prop)","name":"lineMap_le_map_iff_slope_le_slope_left","isProp":true,"docString":"Given `c = lineMap a b r`, `a < c`, the point `(c, f c)` is non-strictly above the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a b ‚â§ slope f a c`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : MetricSpace Œ≤] [inst_2 : ProperSpace Œ≤]\n  {K : NNReal} {f : Œ± ‚âÉ‚Çú Œ≤} (hK : LipschitzWith K ‚Üëf), ProperSpace Œ±","name":"LipschitzWith.properSpace","isProp":true,"docString":"The preimage of a proper space under a Lipschitz homeomorphism is proper. "},{"type":"‚àÄ {K : Type u_1} [inst : DivisionRing K] [inst_1 : TopologicalSpace K] [inst_2 : ContinuousMul K] {a : K} (ha : a ‚â† 0),\n  Filter.Tendsto (fun (x : K) ‚Ü¶ a * x) (Filter.cocompact K) (Filter.cocompact K)","name":"Filter.tendsto_cocompact_mul_left‚ÇÄ","isProp":true,"docString":"Left-multiplication by a nonzero element of a topological division ring is proper, i.e.,\ninverse images of compact sets are compact. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {c : CategoryTheory.Limits.BinaryFan X Y}\n  (h : CategoryTheory.Limits.IsLimit c) (t : CategoryTheory.Limits.IsTerminal Z),\n  CategoryTheory.IsPullback (CategoryTheory.Limits.BinaryFan.fst c) (CategoryTheory.Limits.BinaryFan.snd c)\n    (CategoryTheory.Limits.IsTerminal.from t\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Limits.pair X Y))\n        { as := CategoryTheory.Limits.WalkingPair.left }))\n    (CategoryTheory.Limits.IsTerminal.from t\n      (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Limits.pair X Y))\n        { as := CategoryTheory.Limits.WalkingPair.right }))","name":"CategoryTheory.IsPullback.of_is_product","isProp":true,"docString":"If `c` is a limiting binary product cone, and we have a terminal object,\nthen we have `IsPullback c.fst c.snd 0 0`\n(where each `0` is the unique morphism to the terminal object). "},{"type":"‚àÄ {B : Type u_2} {S : B} {M : Type u_1} [inst : AddCommMonoid M] [inst_1 : SetLike B M] [inst_2 : AddSubmonoidClass B M]\n  {Œπ : Type u_3} {t : Finset Œπ} {f : (a : Œπ) ‚Üí M} (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà S),\n  (Finset.sum t fun (c : Œπ) ‚Ü¶ f c) ‚àà S","name":"sum_mem","isProp":true,"docString":"Sum of elements in an `AddSubmonoid` of an `AddCommMonoid` indexed by a `Finset`\nis in the `AddSubmonoid`."},{"type":"‚àÄ {S : Type u_1} [inst : Add S] {a : S} {b : S} (h : AddCommute a b), a + b = b + a","name":"AddCommute.eq","isProp":true,"docString":"Equality behind `add_commute a b`; useful for rewriting."},{"type":"‚àÄ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R}\n  (hM : Matrix.Nondegenerate M) {v : (a : m) ‚Üí R}\n  (hv : ‚àÄ (w : (a : m) ‚Üí R), Matrix.dotProduct v (Matrix.mulVec M w) = 0), v = 0","name":"Matrix.Nondegenerate.eq_zero_of_ortho","isProp":true,"docString":"If `M` is nondegenerate and `w ‚¨ù M ‚¨ù v = 0` for all `w`, then `v = 0`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddZeroClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (ha : 0 ‚â§ a) (hb : 0 ‚â§ b), 0 ‚â§ a + b","name":"Right.add_nonneg","isProp":true,"docString":"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonneg`."},{"type":"‚àÄ {R : Type u} [self : AddGroupWithOne R] (n : ‚Ñï), IntCast.intCast ‚Üën = ‚Üën","name":"AddGroupWithOne.intCast_ofNat","isProp":true,"docString":"The canonical homorphism `‚Ñ§ ‚Üí R` agrees with the one from `‚Ñï ‚Üí R` on `‚Ñï`. "},{"type":"‚àÄ (R : Type u) (A : Type w) {M : Type v‚ÇÅ} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  [inst_3 : AddCommMonoid M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M]\n  (hsur : Function.Surjective ‚Üë(algebraMap R A)) (X : Set M),\n  Submodule.restrictScalars R (Submodule.span A X) = Submodule.span R X","name":"Submodule.restrictScalars_span","isProp":true,"docString":"If `A` is an `R`-algebra such that the induced morphism `R ‚Üí+* A` is surjective, then the\n`R`-module generated by a set `X` equals the `A`-module generated by `X`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {n : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {I : R ‚Üí+* R} {I' : R ‚Üí+* R} [inst_3 : Nontrivial R] {B : M ‚Üí‚Çõ‚Çó[I] M ‚Üí‚Çõ‚Çó[I'] R} {v : Basis n R M}\n  (h : LinearMap.IsOrtho·µ¢ B ‚Üëv) (hB : LinearMap.SeparatingRight B) (i : n), ¬¨(LinearMap.IsOrtho B (‚Üëv i) (‚Üëv i) : Prop)","name":"LinearMap.IsOrtho·µ¢.not_isOrtho_basis_self_of_separatingRight","isProp":true,"docString":"An orthogonal basis with respect to a right-separating bilinear form has no self-orthogonal\nelements. "},{"type":"‚àÄ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {W : CategoryTheory.MorphismProperty C} [self : CategoryTheory.Functor.IsLocalization L W],\n  Nonempty\n    (CategoryTheory.IsEquivalence\n      (CategoryTheory.Localization.Construction.lift L\n        ((CategoryTheory.Functor.IsLocalization.inverts=:CategoryTheory.MorphismProperty.IsInvertedBy W\n              L)=:CategoryTheory.MorphismProperty.IsInvertedBy W L)))","name":"CategoryTheory.Functor.IsLocalization.nonempty_isEquivalence","isProp":true,"docString":"the induced functor from the constructed localized category is an equivalence "},{"type":"‚àÄ {d : ‚Ñ§} {a : ‚Ñ§‚àöd}, (Zsqrtd.norm a = 1 : Prop) ‚Üî (a ‚àà unitary (‚Ñ§‚àöd) : Prop)","name":"Zsqrtd.norm_eq_one_iff_mem_unitary","isProp":true,"docString":"An element of `‚Ñ§‚àöd` has norm equal to `1` if and only if it is contained in the submonoid\nof unitary elements. "},{"type":"‚àÄ {a : ‚Ñ§} {m : ‚Ñï} {n : ‚Ñï},\n  (Int.gcd a (‚Üëm * ‚Üën) ‚â† 1 : Prop) ‚Üî ((Int.gcd a ‚Üëm ‚â† 1 : Prop) ‚à® (Int.gcd a ‚Üën ‚â† 1 : Prop) : Prop)","name":"Int.gcd_ne_one_iff_gcd_mul_right_ne_one","isProp":true,"docString":"If `gcd a (m * n) ‚â† 1`, then `gcd a m ‚â† 1` or `gcd a n ‚â† 1`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} {M : Type u_4} [inst : VAdd Œ± M] [inst_1 : VAdd Œ≤ M]\n  [inst_2 : VAddCommClass Œ± Œ≤ M], VAddCommClass Œ± Œ≤ ((a : Œπ) ‚Üí M)","name":"Function.vaddCommClass","isProp":true,"docString":"Non-dependent version of `Pi.vaddCommClass`. Lean gets confused by the dependent\ninstance if this is not present."},{"type":"‚àÄ {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {L‚ÇÅ : C ‚•§ D}\n  {L‚ÇÇ : C ‚•§ D} {R‚ÇÅ : D ‚•§ C} {R‚ÇÇ : D ‚•§ C} (adj‚ÇÅ : L‚ÇÅ ‚ä£ R‚ÇÅ) (adj‚ÇÇ : L‚ÇÇ ‚ä£ R‚ÇÇ) (f : L‚ÇÇ ‚ü∂ L‚ÇÅ)\n  [inst_2 : CategoryTheory.IsIso (‚Üë(CategoryTheory.transferNatTransSelf adj‚ÇÅ adj‚ÇÇ) f)], CategoryTheory.IsIso f","name":"CategoryTheory.transferNatTransSelf_of_iso","isProp":true,"docString":"If `f` is a natural transformation whose transferred natural transformation is an isomorphism,\nthen `f` is an isomorphism.\nThe converse is given in `transferNatTransSelf_iso`.\n"},{"type":"‚àÄ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Semiring R] [inst_1 : Semiring S]\n  {œÉ : outParam (R ‚Üí+* S)} {œÉ' : outParam (S ‚Üí+* R)} [inst_2 : RingHomInvPair œÉ œÉ'] [inst_3 : RingHomInvPair œÉ' œÉ]\n  {M : outParam (Type u_4)} [inst_4 : TopologicalSpace M] [inst_5 : AddCommMonoid M] {M‚ÇÇ : outParam (Type u_5)}\n  [inst_6 : TopologicalSpace M‚ÇÇ] [inst_7 : AddCommMonoid M‚ÇÇ] [inst_8 : Module R M] [inst_9 : Module S M‚ÇÇ]\n  [self : ContinuousSemilinearEquivClass F œÉ M M‚ÇÇ] (f : F), Continuous (EquivLike.inv f)","name":"ContinuousSemilinearEquivClass.inv_continuous","isProp":true,"docString":"`ContinuousSemilinearEquivClass F œÉ M M‚ÇÇ` asserts `F` is a type of bundled continuous\n`œÉ`-semilinear equivs `M ‚Üí M‚ÇÇ`.  See also `ContinuousLinearEquivClass F R M M‚ÇÇ` for the case\nwhere `œÉ` is the identity map on `R`.  A map `f` between an `R`-module and an `S`-module over a ring\nhomomorphism `œÉ : R ‚Üí+* S` is semilinear if it satisfies the two properties `f (x + y) = f x + f y`\nand `f (c ‚Ä¢ x) = (œÉ c) ‚Ä¢ f x`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M ‚Üí‚Çó[R] M) (s : Function.Surjective ‚Üëf), Function.Bijective ‚Üëf","name":"IsNoetherian.bijective_of_surjective_endomorphism","isProp":true,"docString":"Any surjective endomorphism of a Noetherian module is bijective. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} (a : SimpleGraph.IsClique ‚ä• s), Set.Subsingleton s","name":"SimpleGraph.IsClique.subsingleton","isProp":true,"docString":"**Alias** of the forward direction of `SimpleGraph.isClique_bot_iff`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (J : CategoryTheory.GrothendieckTopology C)\n  (f : Y ‚ü∂ X) (S : CategoryTheory.Sieve X) (hf : CategoryTheory.Sieve.arrows S f),\n  CategoryTheory.GrothendieckTopology.Covers J S f","name":"CategoryTheory.GrothendieckTopology.arrow_max","isProp":true,"docString":"The maximality axiom in 'arrow' form: Any arrow `f` in `S` is covered by `S`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : PseudoEMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : PseudoEMetricSpace Œ≥] (f : (a : Œ± √ó Œ≤) ‚Üí Œ≥) (K : NNReal) (ha : ‚àÄ (a : Œ±), Continuous fun (y : Œ≤) ‚Ü¶ f (a, y))\n  (hb : ‚àÄ (b : Œ≤), LipschitzWith K fun (x : Œ±) ‚Ü¶ f (x, b)), Continuous f","name":"continuous_prod_of_continuous_lipschitz","isProp":true,"docString":"Consider a function `f : Œ± √ó Œ≤ ‚Üí Œ≥`. Suppose that it is continuous on each ‚Äúvertical section‚Äù\n`{a} √ó univ`, `a : Œ±`, and is Lipschitz continuous on each ‚Äúhorizontal section‚Äù\n`univ √ó {b}`, `b : Œ≤` with the same Lipschitz constant `K`. Then it is continuous.\n\nThe actual statement uses (Lipschitz) continuity of `Œª y, f (a, y)` and `Œª x, f (x, b)` instead\nof continuity of `f` on subsets of the product space. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_2} {Œ≤ : Type u_1} (f : (a : Œ≤) ‚Üí (a : Œ±) ‚Üí Œ≤) (b : Œ≤) (v : Vector Œ± n) (x : Œ±),\n  Vector.scanl f b (x ::·µ• v) = b ::·µ• Vector.scanl f (f b x) v","name":"Vector.scanl_cons","isProp":true,"docString":"The recursive step of `scanl` splits a vector `x ::·µ• v : Vector Œ± (n + 1)`\ninto the provided starting value `b : Œ≤` and the recursed `scanl`\n`f b x : Œ≤` as the starting value.\n\nThis lemma is the `cons` version of `scanl_get`.\n"},{"type":"‚àÄ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) ‚Üí E} {a : k} {b : k} {r : k} (hab : a < b) (h‚ÇÄ : 0 < r) (h‚ÇÅ : r < 1),\n  (f (‚Üë(AffineMap.lineMap a b) r) < ‚Üë(AffineMap.lineMap (f a) (f b)) r : Prop) ‚Üî\n    (slope f a (‚Üë(AffineMap.lineMap a b) r) < slope f (‚Üë(AffineMap.lineMap a b) r) b : Prop)","name":"map_lt_lineMap_iff_slope_lt_slope","isProp":true,"docString":"Given `c = lineMap a b r`, `a < c < b`, the point `(c, f c)` is strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a c < slope f c b`. "},{"type":"‚àÄ {Œ± : Type u} [self : SemilatticeInf Œ±] (a : Œ±) (b : Œ±), a ‚äì b ‚â§ a","name":"SemilatticeInf.inf_le_left","isProp":true,"docString":"The infimum is a lower bound on the first argument "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú)\n  (hM : M (Sum.inr ()) (Sum.inr ()) ‚â† 0),\n  Matrix.IsTwoBlockDiagonal\n    (Matrix.mul (Matrix.mul (List.prod (Matrix.Pivot.listTransvecCol M)) M)\n      (List.prod (Matrix.Pivot.listTransvecRow M)))","name":"Matrix.Pivot.isTwoBlockDiagonal_listTransvecCol_mul_mul_listTransvecRow","isProp":true,"docString":"Multiplying by all the matrices either in `listTransvecCol M` and `listTransvecRow M` turns\nthe matrix in block-diagonal form. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Order.Frame Œ±] {s : Set Œ±} (a : Set.PairwiseDisjoint s id), CompleteLattice.SetIndependent s","name":"Set.PairwiseDisjoint.setIndependent","isProp":true,"docString":"**Alias** of the reverse direction of `CompleteLattice.setIndependent_iff_pairwiseDisjoint`."},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : StrongRankCondition R] [inst_2 : Ring S]\n  [inst_3 : IsDomain S] [inst_4 : Algebra R S] {n : Type u_3} {m : Type u_4} [inst_5 : Fintype n] [inst_6 : Fintype m]\n  (b : Basis n R S) {I : Ideal S} (hI : I ‚â† ‚ä•) (c : Basis m R { x : S // x ‚àà I }), Fintype.card m = Fintype.card n","name":"Ideal.rank_eq","isProp":true,"docString":"If `S` a module-finite free `R`-algebra, then the `R`-rank of a nonzero `R`-free\nideal `I` of `S` is the same as the rank of `S`. "},{"type":"‚àÄ {Œ± : Sort u_1} (a : ¬¨(Infinite Œ± : Prop)), Finite Œ±","name":"Finite.of_not_infinite","isProp":true,"docString":"**Alias** of the forward direction of `not_infinite_iff_finite`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFiltered C] (O : Finset C)\n  (H : Finset ((X : C) √ó' (Y : C) √ó' (_ : X ‚àà O) √ó' (_ : Y ‚àà O) √ó' (X ‚ü∂ Y))) {X : C} {Y : C} (mX : X ‚àà O) (mY : Y ‚àà O)\n  {f : X ‚ü∂ Y} (mf : { fst := X, snd := { fst := Y, snd := { fst := mX, snd := { fst := mY, snd := f } } } } ‚àà H),\n  f ‚â´ CategoryTheory.IsFiltered.toSup O H mY = CategoryTheory.IsFiltered.toSup O H mX","name":"CategoryTheory.IsFiltered.toSup_commutes","isProp":true,"docString":"The triangles of consisting of a morphism in `H` and the maps to `sup O H` commute.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (h : a < b),\n  Finset.Ico a b =\n    Finset.cons a (Finset.Ioo a b)\n      ((Finset.left_not_mem_Ioo=:¬¨(a ‚àà Finset.Ioo a b : Prop))=:¬¨(a ‚àà Finset.Ioo a b : Prop))","name":"Finset.Ico_eq_cons_Ioo","isProp":true,"docString":"`Finset.cons` version of `Finset.Ioo_insert_left`. "},{"type":"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)} (hc : Setoid.IsPartition c) {s : Set Œ±} (hs : s ‚àà c),\n  ‚àÉ (y : Œ±),\n    s =\n      setOf fun (x : Œ±) ‚Ü¶\n        Setoid.Rel\n          (Setoid.mkClasses c\n            ((And.right\n                  hc=:‚àÄ (a : Œ±),\n                  ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà c), a ‚àà b)=:‚àÄ (a : Œ±), ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà c), a ‚àà b))\n          x y","name":"Setoid.exists_of_mem_partition","isProp":true,"docString":"All elements of a partition of Œ± are the equivalence class of some y ‚àà Œ±. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {Œπ : Type u_2} (Œπ' : Finset Œπ) (s : (a : Œπ) ‚Üí S) (l : (a : Œπ) ‚Üí S) (e : (Finset.sum Œπ' fun (i : Œπ) ‚Ü¶ l i * s i) = 1)\n  (hs : ‚àÄ (i : Œπ), s i ‚àà S') (hl : ‚àÄ (i : Œπ), l i ‚àà S') (x : S) (H : ‚àÄ (i : Œπ), ‚àÉ (n : ‚Ñï), s i ^ n ‚Ä¢ x ‚àà S'), x ‚àà S'","name":"Subalgebra.mem_of_finset_sum_eq_one_of_pow_smul_mem","isProp":true,"docString":"Suppose we are given `‚àë i, l·µ¢ * s·µ¢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`l·µ¢` and `s·µ¢`. To check that an `x : S` falls in `S'`, we only need to show that\n`s·µ¢ ^ n ‚Ä¢ x ‚àà S'` for some `n` for each `s·µ¢`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TopologicalSpace Œ≥] {f : (a : Œ±) ‚Üí Œ≥} (hf : Continuous f), Continuous fun (x : Œ± √ó Œ≤) ‚Ü¶ f (Prod.fst x)","name":"Continuous.fst'","isProp":true,"docString":"Precomposing `f` with `Prod.fst` is continuous "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} (a : Convex ùïú s), Set.OrdConnected s","name":"Convex.ordConnected","isProp":true,"docString":"**Alias** of the forward direction of `convex_iff_ordConnected`."},{"type":"‚àÄ {Œ± : Type u} (xs : List Œ±) (x : Œ±) [inst : DecidableEq Œ±], List.intercalate [x] (List.splitOn x xs) = xs","name":"List.intercalate_splitOn","isProp":true,"docString":"`intercalate [x]` is the left inverse of `splitOn x`  "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œ¥ : Type u_1} {f : Filter ((Œ± √ó Œ≤) √ó Œ≥ √ó Œ¥)},\n  Filter.map\n      (fun (p : (Œ± √ó Œ≤) √ó Œ≥ √ó Œ¥) ‚Ü¶\n        ((Prod.fst (Prod.fst p), Prod.fst (Prod.snd p)), Prod.snd (Prod.fst p), Prod.snd (Prod.snd p)))\n      f =\n    Filter.comap\n      (fun (p : (Œ± √ó Œ≥) √ó Œ≤ √ó Œ¥) ‚Ü¶\n        ((Prod.fst (Prod.fst p), Prod.fst (Prod.snd p)), Prod.snd (Prod.fst p), Prod.snd (Prod.snd p)))\n      f","name":"Filter.map_swap4_eq_comap","isProp":true,"docString":"A useful lemma when dealing with uniformities. "},{"type":"‚àÄ {Œ± : Type u_1} (self : Filter.CountableFilterBasis Œ±),\n  Set.Countable (FilterBasis.sets (Filter.CountableFilterBasis.toFilterBasis self))","name":"Filter.CountableFilterBasis.countable","isProp":true,"docString":"The set of sets of the filter basis is countable. "},{"type":"‚àÄ (a : ‚Ñï) {n : ‚Ñï} (n0 : n ‚â† 0), addOrderOf ‚Üëa = n / Nat.gcd n a","name":"ZMod.addOrderOf_coe","isProp":true,"docString":"This lemma works in the case in which `ZMod n` is not infinite, i.e. `n ‚â† 0`.  The version\nwhere `a ‚â† 0` is `addOrderOf_coe'`. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} (p : ‚Üës), ‚Üëp ‚àà s","name":"Subtype.mem","isProp":true,"docString":"See also `subtype.prop` "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedField R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {v‚ÇÅ : M}\n  {v‚ÇÇ : M} (h : SameRay R v‚ÇÅ v‚ÇÇ),\n  ‚àÉ (u : M),\n    ‚àÉ (a : R),\n      ‚àÉ (b : R),\n        (0 ‚â§ a : Prop) ‚àß\n          ((0 ‚â§ b : Prop) ‚àß ((a + b = 1 : Prop) ‚àß ((v‚ÇÅ = a ‚Ä¢ u : Prop) ‚àß (v‚ÇÇ = b ‚Ä¢ u : Prop) : Prop) : Prop) : Prop)","name":"SameRay.exists_eq_smul","isProp":true,"docString":"If vectors `v‚ÇÅ` and `v‚ÇÇ` are on the same ray, then they are nonnegative multiples of the same\nvector. Actually, this vector can be assumed to be `v‚ÇÅ + v‚ÇÇ`, see `SameRay.exists_eq_smul_add`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {a : Œ±} (a_1 : Filter.Frequently (fun (x : Œ±) ‚Ü¶ x ‚àà s) (nhds a)),\n  a ‚àà closure s","name":"Filter.Frequently.mem_closure","isProp":true,"docString":"**Alias** of the reverse direction of `mem_closure_iff_frequently`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderClosedTopology Œ±]\n  [inst_3 : Nonempty Œ±] [inst_4 : TopologicalSpace Œ≤] {f : (a : Œ≤) ‚Üí Œ±} {K : Set Œ≤} (hK : IsCompact K)\n  (hf : ContinuousOn f K), BddAbove (f '' K)","name":"IsCompact.bddAbove_image","isProp":true,"docString":"A continuous function is bounded above on a compact set. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (f : Polynomial R) (r : R),\n  (Polynomial.sum (‚Üë(Polynomial.taylor r) f) fun (i : ‚Ñï) (a : R) ‚Ü¶\n      ‚ÜëPolynomial.C a * (Polynomial.X - ‚ÜëPolynomial.C r) ^ i) =\n    f","name":"Polynomial.sum_taylor_eq","isProp":true,"docString":"Taylor's formula. "},{"type":"‚àÄ {f‚ÇÅ : CircleDeg1Lift} {f‚ÇÇ : CircleDeg1Lift} (h‚ÇÅ : Function.Bijective ‚Üëf‚ÇÅ) (h‚ÇÇ : Function.Bijective ‚Üëf‚ÇÇ)\n  (h : CircleDeg1Lift.translationNumber f‚ÇÅ = CircleDeg1Lift.translationNumber f‚ÇÇ),\n  ‚àÉ (F : CircleDeg1Lift), Function.Semiconj ‚ÜëF ‚Üëf‚ÇÅ ‚Üëf‚ÇÇ","name":"CircleDeg1Lift.semiconj_of_bijective_of_translationNumber_eq","isProp":true,"docString":"If two lifts of circle homeomorphisms have the same translation number, then they are\nsemiconjugate by a `CircleDeg1Lift`. This version uses assumptions `bijective f‚ÇÅ` and\n`bijective f‚ÇÇ` to assume that `f‚ÇÅ` and `f‚ÇÇ` are homeomorphisms. "},{"type":"‚àÄ (p : Prop) [inst : Decidable (p : Prop)], Heyting.IsRegular (p : Prop)","name":"Heyting.isRegular_of_decidable","isProp":true,"docString":"A decidable proposition is intuitionistically Heyting-regular. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {p : Filter Œπ} {c : Œ≤},\n  (Filter.Tendsto (‚ÜøF) (Filter.prod p ‚ä§) (nhds c) : Prop) ‚Üî (TendstoUniformly F (fun (x : Œ±) ‚Ü¶ c) p : Prop)","name":"tendsto_prod_top_iff","isProp":true,"docString":"Uniform convergence to a constant function is equivalent to convergence in `p √ó·∂† ‚ä§`. "},{"type":"‚àÄ {R : Type u_2} [inst : EuclideanDomain R] {abv : AbsoluteValue R ‚Ñ§} {Œπ : Type u_1} [inst_1 : Fintype Œπ] {Œµ : ‚Ñù}\n  (hŒµ : 0 < Œµ) {b : R} (hb : b ‚â† 0) (h : AbsoluteValue.IsAdmissible abv)\n  (A : (a : Fin (Nat.succ (AbsoluteValue.IsAdmissible.card h Œµ ^ Fintype.card Œπ))) ‚Üí (a : Œπ) ‚Üí R),\n  ‚àÉ (i‚ÇÄ : Fin (Nat.succ (AbsoluteValue.IsAdmissible.card h Œµ ^ Fintype.card Œπ))),\n    ‚àÉ (i‚ÇÅ : Fin (Nat.succ (AbsoluteValue.IsAdmissible.card h Œµ ^ Fintype.card Œπ))),\n      (i‚ÇÄ ‚â† i‚ÇÅ : Prop) ‚àß (‚àÄ (k : Œπ), ‚Üë(‚Üëabv (A i‚ÇÅ k % b - A i‚ÇÄ k % b)) < ‚Üëabv b ‚Ä¢ Œµ : Prop)","name":"AbsoluteValue.IsAdmissible.exists_approx","isProp":true,"docString":"Any large enough family of vectors in `R^Œπ` has a pair of elements\nwhose remainders are close together, pointwise. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {l : List M} (hl : ‚àÄ (x : M) (a : x ‚àà l), x = 1), List.prod l = 1","name":"List.prod_eq_one","isProp":true,"docString":"Slightly more general version of `List.prod_eq_one_iff` for a non-ordered `Monoid` "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeInf Œ±] [inst_1 : Nonempty Œ±] {I : Set Œ≤} {S : (a : Œ≤) ‚Üí Set Œ±}\n  (H : Set.Finite I),\n  (BddBelow (Set.union·µ¢ fun (i : Œ≤) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà I) ‚Ü¶ S i) : Prop) ‚Üî\n    (‚àÄ (i : Œ≤) (a : i ‚àà I), BddBelow (S i) : Prop)","name":"Set.Finite.bddBelow_bunion·µ¢","isProp":true,"docString":"A finite union of sets which are all bounded below is still bounded below."},{"type":"‚àÄ {F : Type u_1} [inst : Field F] {p : Polynomial F} (hsplit : Polynomial.Splits (RingHom.id F) p) {k : ‚Ñï}\n  (h : k ‚â§ Polynomial.natDegree p),\n  Polynomial.coeff p k =\n    Polynomial.leadingCoeff p * (-1) ^ (Polynomial.natDegree p - k) *\n      Multiset.esymm (Polynomial.roots p) (Polynomial.natDegree p - k)","name":"Polynomial.coeff_eq_esymm_roots_of_splits","isProp":true,"docString":"Vieta's formula for split polynomials over a field. "},{"type":"‚àÄ (R : Type u_1) [inst : CommRing R] (p : ‚Ñï) [inst_1 : Fact (Nat.Prime p : Prop)] (hR : ringChar R ‚â† 0),\n  (IsUnit ‚Üëp : Prop) ‚Üî (¬¨(p ‚à£ ringChar R : Prop) : Prop)","name":"isUnit_iff_not_dvd_char_of_ringChar_ne_zero","isProp":true,"docString":"A prime `p` is a unit in a commutative ring `R` of nonzero characterstic iff it does not divide\nthe characteristic. "},{"type":"‚àÄ {n : ‚Ñï}, Fin.succ 0 = 1","name":"Fin.succ_zero_eq_one'","isProp":true,"docString":"Version of `succ_zero_eq_one` to be used by `dsimp` "},{"type":"‚àÄ (ùïú : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField ùïú] [inst_1 : NormedAddCommGroup E]\n  [inst : NormedSpace ùïú E] [inst : Nontrivial E], NoncompactSpace E","name":"NormedSpace.noncompactSpace","isProp":true,"docString":"A normed vector space over a nontrivially normed field is a noncompact space. This cannot be\nan instance because in order to apply it, Lean would have to search for `NormedSpace ùïú E` with\nunknown `ùïú`. We register this as an instance in two cases: `ùïú = E` and `ùïú = ‚Ñù`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {P : C} {Q : C} {R : C} (f : P ‚ü∂ Q) (g : Q ‚ü∂ R)\n  [inst_1 : CategoryTheory.StrongEpi f] [inst_2 : CategoryTheory.StrongEpi g], CategoryTheory.StrongEpi (f ‚â´ g)","name":"CategoryTheory.strongEpi_comp","isProp":true,"docString":"The composition of two strong epimorphisms is a strong epimorphism. "},{"type":"‚àÄ {Œ± : Type u} [self : SemilatticeInf Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : a ‚â§ b) (a_2 : a ‚â§ c), a ‚â§ b ‚äì c","name":"SemilatticeInf.le_inf","isProp":true,"docString":"The infimum is the *greatest* lower bound "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (M : Submonoid R) {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsLocalization M S] (a : S),\n  ‚àÉ (b : { x : R // x ‚àà M }), IsLocalization.IsInteger R (a * ‚Üë(algebraMap R S) ‚Üëb)","name":"IsLocalization.exists_integer_multiple'","isProp":true,"docString":"Each element `a : S` has an `M`-multiple which is an integer.\n\nThis version multiplies `a` on the right, matching the argument order in `LocalizationMap.surj`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {G : Type u_2} [inst : AddGroup G] [inst_1 : UniformSpace G] [inst_2 : UniformAddGroup G],\n  UniformAddGroup (UniformFun Œ± G)","name":"instUniformAddGroupUniformFunUniformSpaceInstAddGroupUniformFun","isProp":true,"docString":"If `G` is a uniform additive group,\nthen `Œ± ‚Üí·µ§ G` is a uniform additive group as well."},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±}\n  {b : Œ±} (a_1 : b ‚â§ a), 0 ‚â§ a - b","name":"sub_nonneg_of_le","isProp":true,"docString":"**Alias** of the reverse direction of `sub_nonneg`."},{"type":"‚àÄ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a : R) (b : R) (c : R),\n  (a + b) * c = a * c + b * c","name":"add_mul","isProp":true,"docString":"**Alias** of `right_distrib`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Antitone f)\n  [inst_4 : TopologicalSpace Œ±] [inst : OrderTopology Œ±] [inst : TopologicalSpace.SecondCountableTopology Œ≤],\n  Set.Countable (setOf fun (x : Œ±) ‚Ü¶ ¬¨(ContinuousAt f x : Prop))","name":"Antitone.countable_not_continuousAt","isProp":true,"docString":"In a second countable space, the set of points where an antitone function is not continuous\nis at most countable. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Nontrivial Œ±] {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Injective f) (y : Œ≤),\n  ‚àÉ (x : Œ±), f x ‚â† y","name":"Function.Injective.exists_ne","isProp":true,"docString":"An injective function from a nontrivial type has an argument at\nwhich it does not take a given value. "},{"type":"‚àÄ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R},\n  ((IsRegular (a * b) : Prop) ‚àß (IsRegular (b * a) : Prop) : Prop) ‚Üî\n    ((IsRegular a : Prop) ‚àß (IsRegular b : Prop) : Prop)","name":"isRegular_mul_and_mul_iff","isProp":true,"docString":"Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [I : IsNoetherian R M]\n  (f : (a : ‚Ñï) ‚Üí Submodule R M) (h : ‚àÄ (n : ‚Ñï), Disjoint (‚Üë(partialSups f) n) (f (n + 1))),\n  ‚àÉ (n : ‚Ñï), ‚àÄ (m : ‚Ñï) (a : n ‚â§ m), f m = ‚ä•","name":"IsNoetherian.disjoint_partialSups_eventually_bot","isProp":true,"docString":"A sequence `f` of submodules of a noetherian module,\nwith `f (n+1)` disjoint from the supremum of `f 0`, ..., `f n`,\nis eventually zero.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] [inst : T2Space Œ±], Finite Œ±","name":"TopologicalSpace.NoetherianSpace.finite","isProp":true,"docString":"Spaces that are both Noetherian and Hausdorff are finite. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Surjective f)\n  (h : ‚àÄ (a : Nat.card Œ± = 0), Nat.card Œ≤ = 0), Nat.card Œ≤ ‚â§ Nat.card Œ±","name":"Finite.card_le_of_surjective'","isProp":true,"docString":"If `f` is surjective, then `Nat.card Œ≤ ‚â§ Nat.card Œ±`. We must also assume\n`Nat.card Œ± = 0 ‚Üí Nat.card Œ≤ = 0` since `Nat.card` is defined to be `0` for infinite types. "},{"type":"‚àÄ {R : Type u_3} [inst : CommRing R] (M : Submonoid R) (S : Type u_4) [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  (R‚Çò : Type u_1) (S‚Çò : Type u_2) [inst_3 : CommRing R‚Çò] [inst_4 : CommRing S‚Çò] [inst_5 : Algebra R R‚Çò]\n  [inst_6 : IsLocalization M R‚Çò] [inst_7 : Algebra S S‚Çò] [i : IsLocalization (Algebra.algebraMapSubmonoid S M) S‚Çò]\n  [inst_8 : Algebra R‚Çò S‚Çò] [inst_9 : Algebra R S‚Çò] [inst_10 : IsScalarTower R R‚Çò S‚Çò] [inst_11 : IsScalarTower R S S‚Çò],\n  algebraMap R‚Çò S‚Çò =\n    IsLocalization.map S‚Çò (algebraMap R S)\n      (let_fun this : M ‚â§ Submonoid.comap (algebraMap R S) (Algebra.algebraMapSubmonoid S M) :=\n          ((Submonoid.le_comap_map\n                M=:M ‚â§\n                Submonoid.comap (algebraMap R S)\n                  (Submonoid.map (algebraMap R S)\n                    M))=:M ‚â§ Submonoid.comap (algebraMap R S) (Submonoid.map (algebraMap R S) M));\n        this=:M ‚â§ Submonoid.comap (algebraMap R S) (Algebra.algebraMapSubmonoid S M))","name":"IsLocalization.algebraMap_eq_map_map_submonoid","isProp":true,"docString":"If the square below commutes, the bottom map is uniquely specified:\n```\nR  ‚Üí  S\n‚Üì     ‚Üì\nR‚Çò ‚Üí S‚Çò\n```\n"},{"type":"‚àÄ {k : Type u‚ÇÅ} {G : Type u‚ÇÇ} [inst : Semiring k] [inst_1 : MulOneClass G] (f : MonoidAlgebra k G),\n  f ‚àà Submodule.span k (‚Üë(MonoidAlgebra.of k G) '' ‚Üë(Finsupp.support f))","name":"MonoidAlgebra.mem_span_support","isProp":true,"docString":"An element of `MonoidAlgebra k G` is in the subalgebra generated by its support. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {s : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (hi : Set.InjOn f s) (a : Set.Infinite s),\n  Set.Infinite (f '' s)","name":"Set.Infinite.image","isProp":true,"docString":"**Alias** of the reverse direction of `Set.infinite_image_iff`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] (f : C(Œ±, Œ≤)), Continuous ‚Üëf","name":"ContinuousMap.continuous","isProp":true,"docString":"Deprecated. Use `map_continuous` instead. "},{"type":"‚àÄ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] {p1 : P} {p2 : P} {p : P}\n  (h : p1 -·µ• p = p2 -·µ• p), p1 = p2","name":"vsub_left_cancel","isProp":true,"docString":"If the same point subtracted from two points produces equal\nresults, those points are equal. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {q : (a : Œ±) ‚Üí Prop} {Œ±_1 : Type u_1} {p : (a : Œ±_1) ‚Üí Prop} {a : Œ±_1}\n  [inst : Functor m] [inst_1 : LawfulFunctor m] {x : m Œ±} (hx : SatisfiesM q x) (ha : ‚àÄ {b : Œ±} (a_1 : q b), p a),\n  SatisfiesM p (Functor.mapConst a x)","name":"SatisfiesM.mapConst","isProp":true,"docString":"`SatisfiesM` distributes over `mapConst`, general version. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) {x : M} {y : M} (a : ‚Üëc x y), ‚Üëc y x","name":"Con.symm","isProp":true,"docString":"Congruence relations are symmetric. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Add Œ±] [inst_2 : LE Œ±] [inst_3 : Mul Œ≤] [inst_4 : Add Œ≤]\n  [inst_5 : LE Œ≤] (f : Œ± ‚âÉ+*o Œ≤), Equiv.toFun (RingEquiv.toEquiv (OrderRingIso.toRingEquiv f)) = ‚Üëf","name":"OrderRingIso.toFun_eq_coe","isProp":true,"docString":"Helper instance for when there's too many metavariables to apply `FunLike.has_coe_to_fun`\ndirectly. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R] (q : ‚Ñï) [hp : CharP R 0] [hq : ExpChar R q], q = 1","name":"expChar_one_of_char_zero","isProp":true,"docString":"The exponential characteristic is one if the characteristic is zero. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {x : X} {y : X} {F : Set X} (h : JoinedIn F x y),\n  Joined { val := x, property := ((JoinedIn.source_mem h=:x ‚àà F)=:x ‚àà F) }\n    { val := y, property := ((JoinedIn.target_mem h=:y ‚àà F)=:y ‚àà F) }","name":"JoinedIn.joined_subtype","isProp":true,"docString":"If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`. "},{"type":"‚àÄ {M : Type u_2} {N : Type u_1} [inst : Add M] [inst_1 : Add N] {c : AddCon M} {d : AddCon N}\n  {C : (a : AddCon.Quotient c) ‚Üí (a : AddCon.Quotient d) ‚Üí Prop} (p : AddCon.Quotient c) (q : AddCon.Quotient d)\n  (H : ‚àÄ (x : M) (y : N), C ‚Üëx ‚Üëy), C p q","name":"AddCon.induction_on‚ÇÇ","isProp":true,"docString":"A version of `add_con.induction_on` for predicates which take\ntwo arguments."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C), CategoryTheory.IsPushout 0 0 (ùüô X) 0","name":"CategoryTheory.IsPushout.zero_left","isProp":true,"docString":"The square with `0 : 0 ‚ü∂ 0` on the right left `ùüô X` on the right is a pushout square. "},{"type":"‚àÄ {n : SimplexCategory} {m : SimplexCategory} {f : n ‚ü∂ m},\n  (CategoryTheory.Epi f : Prop) ‚Üî (Function.Surjective ‚Üë(SimplexCategory.Hom.toOrderHom f) : Prop)","name":"SimplexCategory.epi_iff_surjective","isProp":true,"docString":"A morphism in `SimplexCategory` is an epimorphism if and only if it is a surjective function\n"},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_3}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_4} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ] [inst_8 : RingHomSurjective œÉ‚ÇÅ‚ÇÇ]\n  [inst_9 : TopologicalSpace R‚ÇÅ] [inst_10 : TopologicalSpace R‚ÇÇ] [inst_11 : ContinuousSMul R‚ÇÅ M‚ÇÅ]\n  [inst_12 : ContinuousAdd M‚ÇÅ] [inst_13 : ContinuousSMul R‚ÇÇ M‚ÇÇ] [inst_14 : ContinuousAdd M‚ÇÇ] (f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ)\n  (s : Submodule R‚ÇÅ M‚ÇÅ),\n  Submodule.map (‚Üëf) (Submodule.topologicalClosure s) ‚â§ Submodule.topologicalClosure (Submodule.map (‚Üëf) s)","name":"Submodule.topologicalClosure_map","isProp":true,"docString":"Under a continuous linear map, the image of the `TopologicalClosure` of a submodule is\ncontained in the `TopologicalClosure` of its image. "},{"type":"‚àÄ {S : Type u_1} [inst : AddSemigroup S] {a : S} {b : S} {c : S} (hac : AddCommute a c) (hbc : AddCommute b c),\n  AddCommute (a + b) c","name":"AddCommute.add_left","isProp":true,"docString":"If both `a` and `b` commute with `c`, then their product commutes with `c`."},{"type":"‚àÄ {R' : Type u_1} {M'' : Type u_2} {N'' : Type u_3} [inst : CommSemiring R'] [inst_1 : AddCommMonoid M'']\n  [inst_2 : AddCommMonoid N''] [inst_3 : Module R' M''] [inst_4 : Module R' N''] {n : ‚Ñï}\n  (f : AlternatingMap R' M'' N'' (Fin (Nat.succ (Nat.succ n)))) (m : M''),\n  ‚Üë(AlternatingMap.curryLeft (‚Üë(AlternatingMap.curryLeft f) m)) m = 0","name":"AlternatingMap.curryLeft_same","isProp":true,"docString":"Currying with the same element twice gives the zero map. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : SeminormedRing ùïú] [inst_1 : AddGroup E] [inst_2 : SMul ùïú E]\n  (self : Seminorm ùïú E) (a : ùïú) (x : E),\n  AddGroupSeminorm.toFun (Seminorm.toAddGroupSeminorm self) (a ‚Ä¢ x) =\n    ‚Äña‚Äñ * AddGroupSeminorm.toFun (Seminorm.toAddGroupSeminorm self) x","name":"Seminorm.smul'","isProp":true,"docString":"The seminorm of a scalar multiplication is the product of the absolute value of the scalar\nand the original seminorm. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {M : Type w} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {b : M}\n  [inst_1 : LinearOrderedCommSemiring M] (ht : Finset.Nonempty t) (hb : ‚Üë(Finset.card s) ‚â§ Finset.card t ‚Ä¢ b),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (‚Üë(Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s)) ‚â§ b : Prop)","name":"Finset.exists_card_fiber_le_of_card_le_nsmul","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by heads: given a function `f`, a\nfinite sets `s` and `t`, and a number `b` such that `card s ‚â§ card t ‚Ä¢ b`, there exists `y ‚àà t` such\nthat its preimage in `s` has no more than `b` elements.\nSee also `Finset.exists_card_fiber_lt_of_card_lt_nsmul` for a stronger statement. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsFilteredOrEmpty C] {j : C} {j' : C}\n  (f : j ‚ü∂ j') (f' : j ‚ü∂ j'), f ‚â´ CategoryTheory.IsFiltered.coeqHom f f' = f' ‚â´ CategoryTheory.IsFiltered.coeqHom f f'","name":"CategoryTheory.IsFiltered.coeq_condition","isProp":true,"docString":"`coeq_condition f f'`, for morphisms `f f' : j ‚ü∂ j'`, is the proof that\n`f ‚â´ coeqHom f f' = f' ‚â´ coeqHom f f'`.\n"},{"type":"‚àÄ {Œπ : Type u} {f : (a : Œπ) ‚Üí (a : Ordinal) ‚Üí Ordinal} (H : ‚àÄ (i : Œπ), Ordinal.IsNormal (f i)),\n  Set.Unbounded (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x < x_1) (Set.inter·µ¢ fun (i : Œπ) ‚Ü¶ Function.fixedPoints (f i))","name":"Ordinal.fp_family_unbounded","isProp":true,"docString":"A generalization of the fixed point lemma for normal functions: any family of normal functions\nhas an unbounded set of common fixed points. "},{"type":"‚àÄ {Œ± : Type u_1} {f : Equiv.Perm Œ±} {x : Œ±} {y : Œ±} {n : ‚Ñï} (a : Equiv.Perm.SameCycle f x (‚Üë(f ^ n) y)),\n  Equiv.Perm.SameCycle f x y","name":"Equiv.Perm.SameCycle.of_pow_right","isProp":true,"docString":"**Alias** of the forward direction of `Equiv.Perm.sameCycle_pow_right`."},{"type":"‚àÄ {G : Type u_2} {H : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : OrderedAddCommGroup H] {f : (a : G) ‚Üí H}\n  (h‚ÇÅ : ‚àÄ (x : G), f (-x) = -f x) (h‚ÇÇ : StrictMonoOn f (Set.Ici 0)), StrictMono f","name":"strictMono_of_odd_strictMonoOn_nonneg","isProp":true,"docString":"An odd function on a linear ordered additive commutative group is strictly monotone on the whole\ngroup provided that it is strictly monotone on `Set.Ici 0`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {s : Set E} {t : Set E} {x : E} {y : E}\n  (hx : x ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ‚Ñù)) s) (hy : y ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ‚Ñù)) t),\n  ‚àÉ (x' : E), (x' ‚àà s : Prop) ‚àß (‚àÉ (y' : E), (y' ‚àà t : Prop) ‚àß (dist x y ‚â§ dist x' y' : Prop) : Prop)","name":"convexHull_exists_dist_ge2","isProp":true,"docString":"Given a point `x` in the convex hull of `s` and a point `y` in the convex hull of `t`,\nthere exist points `x' ‚àà s` and `y' ‚àà t` at distance at least `dist x y`. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P), ‚Üë(Finset.weightedVSub ‚àÖ p) w = 0","name":"Finset.weightedVSub_empty","isProp":true,"docString":"The `weightedVSub` for an empty set is 0. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X‚ÇÅ‚ÇÅ : C} {X‚ÇÅ‚ÇÇ : C} {X‚ÇÇ‚ÇÅ : C} {X‚ÇÇ‚ÇÇ : C} {X‚ÇÉ‚ÇÅ : C} {X‚ÇÉ‚ÇÇ : C}\n  {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÉ‚ÇÅ : X‚ÇÉ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÇ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÅ}\n  {v‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÉ‚ÇÇ} (s : CategoryTheory.IsPullback h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) (t : CategoryTheory.IsPullback h‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÇ h‚ÇÉ‚ÇÅ),\n  CategoryTheory.IsPullback h‚ÇÅ‚ÇÅ (v‚ÇÅ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÅ) (v‚ÇÅ‚ÇÇ ‚â´ v‚ÇÇ‚ÇÇ) h‚ÇÉ‚ÇÅ","name":"CategoryTheory.IsPullback.paste_vert","isProp":true,"docString":"Paste two pullback squares \"vertically\" to obtain another pullback square. "},{"type":"‚àÄ {C : Type v} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y)\n  (s : Function.Surjective (Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.forget C)) f)),\n  CategoryTheory.Epi f","name":"CategoryTheory.ConcreteCategory.epi_of_surjective","isProp":true,"docString":"In any concrete category, surjective morphisms are epimorphisms. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedAddMonoid Œ±] (x : Œ±), ‚ä• ‚â§ x","name":"CanonicallyOrderedAddMonoid.bot_le","isProp":true,"docString":"`‚ä•` is the least element "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsPreirreducible s : Prop) ‚Üî\n    (‚àÄ (z‚ÇÅ : Set Œ±) (z‚ÇÇ : Set Œ±) (a : IsClosed z‚ÇÅ) (a : IsClosed z‚ÇÇ) (a : s ‚äÜ z‚ÇÅ ‚à™ z‚ÇÇ),\n        (s ‚äÜ z‚ÇÅ : Prop) ‚à® (s ‚äÜ z‚ÇÇ : Prop) :\n      Prop)","name":"isPreirreducible_iff_closed_union_closed","isProp":true,"docString":"A set is preirreducible if and only if\nfor every cover by two closed sets, it is contained in one of the two covering sets. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semigroup Œ±] {a : Œ±} {b : Œ±} (h : a ‚à£ b) (c : Œ±), a ‚à£ b * c","name":"Dvd.dvd.mul_right","isProp":true,"docString":"**Alias** of `dvd_mul_of_dvd_left`."},{"type":"‚àÄ {M : Type u_1} [inst : Group M] (c : Con M) {w : M} {x : M} {y : M} {z : M} (a : ‚Üëc w x) (a : ‚Üëc y z),\n  ‚Üëc (w / y) (x / z)","name":"Con.div","isProp":true,"docString":"Multiplicative congruence relations preserve division. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} (h : AffineIndependent k fun (p : ‚Üës) ‚Ü¶ ‚Üëp),\n  ‚àÉ (t : Set P), (s ‚äÜ t : Prop) ‚àß ((AffineIndependent k fun (p : ‚Üët) ‚Ü¶ ‚Üëp : Prop) ‚àß (affineSpan k t = ‚ä§ : Prop) : Prop)","name":"exists_subset_affineIndependent_affineSpan_eq_top","isProp":true,"docString":"An affinely independent set of points can be extended to such a\nset that spans the whole space. "},{"type":"‚àÄ {Œ± : Type u} {S : Set Œ±} (a : Set.Finite S), Cardinal.mk ‚ÜëS < Cardinal.aleph0","name":"Set.Finite.lt_aleph0","isProp":true,"docString":"**Alias** of the reverse direction of `Cardinal.lt_aleph0_iff_set_finite`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : a ‚à£ c)\n  (a_2 : a ‚à£ b), a ‚à£ gcd c b","name":"GCDMonoid.dvd_gcd","isProp":true,"docString":"Tny common divisor of both elements is a divisor of the GCD. "},{"type":"‚àÄ {a : EReal} {b : EReal}, (-a ‚â§ b : Prop) ‚Üî (-b ‚â§ a : Prop)","name":"EReal.neg_le","isProp":true,"docString":"`-a ‚â§ b ‚Üî -b ‚â§ a` on `EReal`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C}\n  (F‚ÇÅ : CategoryTheory.MonoOver X ‚•§ CategoryTheory.MonoOver Y)\n  (F‚ÇÇ : CategoryTheory.MonoOver X ‚•§ CategoryTheory.MonoOver Y) (h : F‚ÇÅ ‚âÖ F‚ÇÇ),\n  CategoryTheory.Subobject.lower F‚ÇÅ = CategoryTheory.Subobject.lower F‚ÇÇ","name":"CategoryTheory.Subobject.lower_iso","isProp":true,"docString":"Isomorphic functors become equal when lowered to `Subobject`.\n(It's not as evil as usual to talk about equality between functors\nbecause the categories are thin and skeletal.) "},{"type":"‚àÄ {n : ‚Ñï} (p : ‚Ñï) (hn : n ‚â† 0), ‚Üë(Nat.factorization n) p < n","name":"Nat.factorization_lt","isProp":true,"docString":"A crude upper bound on `n.factorization p` "},{"type":"‚àÄ {Œ± : Type u} [inst : Monoid Œ±] (self : Œ±À£), Units.inv self * ‚Üëself = 1","name":"Units.inv_val","isProp":true,"docString":"`inv` is the left inverse of `val` in the base `Monoid`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X‚ÇÅ‚ÇÅ : C} {X‚ÇÅ‚ÇÇ : C} {X‚ÇÇ‚ÇÅ : C} {X‚ÇÇ‚ÇÇ : C} {X‚ÇÉ‚ÇÅ : C} {X‚ÇÉ‚ÇÇ : C}\n  {h‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÅ‚ÇÇ} {h‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÇ} {h‚ÇÉ‚ÇÅ : X‚ÇÉ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÇ} {v‚ÇÅ‚ÇÅ : X‚ÇÅ‚ÇÅ ‚ü∂ X‚ÇÇ‚ÇÅ} {v‚ÇÅ‚ÇÇ : X‚ÇÅ‚ÇÇ ‚ü∂ X‚ÇÇ‚ÇÇ} {v‚ÇÇ‚ÇÅ : X‚ÇÇ‚ÇÅ ‚ü∂ X‚ÇÉ‚ÇÅ}\n  {v‚ÇÇ‚ÇÇ : X‚ÇÇ‚ÇÇ ‚ü∂ X‚ÇÉ‚ÇÇ} (s : CategoryTheory.IsPullback h‚ÇÅ‚ÇÅ (v‚ÇÅ‚ÇÅ ‚â´ v‚ÇÇ‚ÇÅ) (v‚ÇÅ‚ÇÇ ‚â´ v‚ÇÇ‚ÇÇ) h‚ÇÉ‚ÇÅ) (p : h‚ÇÅ‚ÇÅ ‚â´ v‚ÇÅ‚ÇÇ = v‚ÇÅ‚ÇÅ ‚â´ h‚ÇÇ‚ÇÅ)\n  (t : CategoryTheory.IsPullback h‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÅ v‚ÇÇ‚ÇÇ h‚ÇÉ‚ÇÅ), CategoryTheory.IsPullback h‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÅ v‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ","name":"CategoryTheory.IsPullback.of_bot","isProp":true,"docString":"Given a pullback square assembled from a commuting square on the top and\na pullback square on the bottom, the top square is a pullback square. "},{"type":"‚àÄ (k : Type u_1) {V : Type u_4} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_2} [inst_4 : CharZero k] {s : Finset Œπ} (p : (a : Œπ) ‚Üí P) {n : ‚Ñï}\n  (h : Finset.card s = n + 1), Finset.centroid k s p ‚àà affineSpan k (Set.range p)","name":"centroid_mem_affineSpan_of_card_eq_add_one","isProp":true,"docString":"In the characteristic zero case, the centroid lies in the affine\nspan if the number of points is `n + 1`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {J : Type w} [inst_1 : CategoryTheory.SmallCategory J] (F : J ‚•§ C)\n  [inst_2 :\n    CategoryTheory.Limits.HasLimit\n      (CategoryTheory.Discrete.functor (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F)))]\n  [inst_3 :\n    CategoryTheory.Limits.HasLimit\n      (CategoryTheory.Discrete.functor fun (f : (p : J √ó J) √ó (Prod.fst p ‚ü∂ Prod.snd p)) ‚Ü¶\n        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) (Prod.snd (Sigma.fst f)))]\n  [inst_4 : CategoryTheory.Limits.HasEqualizers C], CategoryTheory.Limits.HasLimit F","name":"CategoryTheory.Limits.hasLimit_of_equalizer_and_product","isProp":true,"docString":"Given the existence of the appropriate (possibly finite) products and equalizers, we know a limit of\n`F` exists.\n(This assumes the existence of all equalizers, which is technically stronger than needed.)\n"},{"type":"‚àÄ {Œ± : Type u_2} {Œπ : Sort u_1} [inst : ConditionallyCompleteLattice Œ±] [inst_1 : Nonempty Œπ] {f : (a : Œπ) ‚Üí Œ±} {c : Œ±}\n  (H : ‚àÄ (x : Œπ), f x ‚â§ c), sup·µ¢ f ‚â§ c","name":"csup·µ¢_le","isProp":true,"docString":"The indexed supremum of a function is bounded above by a uniform bound"},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]\n  {K : Set G} {L : Set G} (hK : IsCompact K) (hL : IsCompact L), ‚àÉ (g : G), Disjoint K (g ‚Ä¢ L)","name":"exists_disjoint_smul_of_isCompact","isProp":true,"docString":"Given two compact sets in a noncompact topological group, there is a translate of the second\none that is disjoint from the first one. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} [inst_1 : DiscreteTopology ‚Üës] {x : Œ±} (hx : x ‚àà s),\n  ‚àÉ (Œµ : ‚Ñù), (Œµ > 0 : Prop) ‚àß (Metric.ball x Œµ ‚à© s = {x} : Prop)","name":"Metric.exists_ball_inter_eq_singleton_of_mem_discrete","isProp":true,"docString":"Given a point `x` in a discrete subset `s` of a pseudometric space, there is an open ball\ncentered at `x` and intersecting `s` only at `x`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} {p‚ÇÅ : P} (hp‚ÇÅ : p‚ÇÅ ‚àà s),\n  (AffineIndependent k fun (p : ‚Üës) ‚Ü¶ ‚Üëp : Prop) ‚Üî\n    (LinearIndependent k fun (v : ‚Üë((fun (p : P) ‚Ü¶ p -·µ• p‚ÇÅ) '' (s \\ {p‚ÇÅ}))) ‚Ü¶ ‚Üëv : Prop)","name":"affineIndependent_set_iff_linearIndependent_vsub","isProp":true,"docString":"A set is affinely independent if and only if the differences from\na base point in that set are linearly independent. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Monotone f)\n  [inst_4 : TopologicalSpace Œ±] [inst_5 : OrderTopology Œ±] [inst_6 : TopologicalSpace.SecondCountableTopology Œ≤],\n  Set.Countable (setOf fun (x : Œ±) ‚Ü¶ ¬¨(ContinuousWithinAt f (Set.Ioi x) x : Prop))","name":"Monotone.countable_not_continuousWithinAt_Ioi","isProp":true,"docString":"In a second countable space, the set of points where a monotone function is not right-continuous\nis at most countable. Superseded by `countable_not_continuousAt` which gives the two-sided\nversion. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (g : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasEqualizer f g], CategoryTheory.Limits.HasKernel (f - g)","name":"CategoryTheory.Preadditive.hasKernel_of_hasEqualizer","isProp":true,"docString":"A preadditive category has a kernel for `f - g` if it has an equalizer for `f` and `g`. "},{"type":"‚àÄ {R‚ÇÅ : Type u_3} {R‚ÇÇ : Type u_4} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_2}\n  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_1} [inst_4 : TopologicalSpace M‚ÇÇ]\n  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ] [inst_8 : T2Space M‚ÇÇ] {s : Set M‚ÇÅ}\n  {f : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} {g : M‚ÇÅ ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ} (h : Set.EqOn (‚Üëf) (‚Üëg) s),\n  Set.EqOn (‚Üëf) (‚Üëg) (closure ‚Üë(Submodule.span R‚ÇÅ s))","name":"ContinuousLinearMap.eqOn_closure_span","isProp":true,"docString":"If two continuous linear maps are equal on a set `s`, then they are equal on the closure\nof the `Submodule.span` of this set. "},{"type":"‚àÄ {Œ± : Type u} [self : Lattice Œ±] (a : Œ±) (b : Œ±), a ‚äì b ‚â§ a","name":"Lattice.inf_le_left","isProp":true,"docString":"The infimum is a lower bound on the first argument "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R], (¬¨(IsRightRegular 0 : Prop) : Prop) ‚Üî (Nontrivial R : Prop)","name":"not_isRightRegular_zero_iff","isProp":true,"docString":"In a non-trivial `MulZeroClass`, the `0` element is not right-regular. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R] (h : IsRightRegular 0), Subsingleton R","name":"IsRightRegular.subsingleton","isProp":true,"docString":"The element `0` is right-regular if and only if `R` is trivial. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] [inst_2 : Zero Œ±]\n  [inst_3 : Zero Œ≤] [inst_4 : SMul Œ± Œ≤] [inst_5 : BoundedSMul Œ± Œ≤] [inst_6 : SMul Œ±·µê·µí·µñ Œ≤]\n  [inst_7 : IsCentralScalar Œ± Œ≤], BoundedSMul Œ±·µê·µí·µñ Œ≤","name":"BoundedSMul.op","isProp":true,"docString":"If a scalar is central, then its right action is bounded when its left action is. "},{"type":"‚àÄ (R : Type u_2) {M : Type u_3} (S : Type u_1) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (s : Set M) [inst_3 : Semiring S] [inst_4 : SMul R S] [inst_5 : Module S M] [inst_6 : IsScalarTower R S M],\n  Submodule.span S ‚Üë(Submodule.span R s) = Submodule.span S s","name":"Submodule.span_span_of_tower","isProp":true,"docString":"Taking the span by a large ring of the span by the small ring is the same as taking the span\nby just the large ring. "},{"type":"‚àÄ {R : Type u_1} [inst : NonAssocRing R] (self : MulRingSeminorm R),\n  AddGroupSeminorm.toFun (MulRingSeminorm.toAddGroupSeminorm self) 1 = 1","name":"MulRingSeminorm.map_one'","isProp":true,"docString":"The proposition that the function preserves 1 "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} {Œπ : Type u_4} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : Module ùïú E] [inst_4 : Module ùïú Œ≤] [inst_5 : OrderedSMul ùïú Œ≤] {s : Set E}\n  {f : (a : E) ‚Üí Œ≤} {t : Finset Œπ} {w : (a : Œπ) ‚Üí ùïú} {p : (a : Œπ) ‚Üí E} (hf : ConvexOn ùïú s f)\n  (h‚ÇÄ : ‚àÄ (i : Œπ) (a : i ‚àà t), 0 ‚â§ w i) (h‚ÇÅ : (Finset.sum t fun (i : Œπ) ‚Ü¶ w i) = 1)\n  (hmem : ‚àÄ (i : Œπ) (a : i ‚àà t), p i ‚àà s),\n  f (Finset.sum t fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ p i) ‚â§ Finset.sum t fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ f (p i)","name":"ConvexOn.map_sum_le","isProp":true,"docString":"Convex **Jensen's inequality**, `Finset.sum` version. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.IsSplitMono f],\n  CategoryTheory.IsSplitEpi (CategoryTheory.retraction f)","name":"CategoryTheory.retraction_isSplitEpi","isProp":true,"docString":"The retraction of a split monomorphism is itself a split epimorphism. "},{"type":"‚àÄ {Œ± : Type u} (s : Set Œ±), Cardinal.mk ‚Üë(ùí´ s) = 2 ^ Cardinal.mk ‚Üës","name":"Cardinal.mk_powerset","isProp":true,"docString":"A variant of `Cardinal.mk_set` expressed in terms of a `Set` instead of a `Type`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} (self : CategoryTheory.SplitEpi f),\n  CategoryTheory.SplitEpi.section_ self ‚â´ f = ùüô Y","name":"CategoryTheory.SplitEpi.id","isProp":true,"docString":"`section_` composed with `f` is the identity "},{"type":"‚àÄ {ùïú : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NormedCommRing ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : AddCommMonoid F] [inst_3 : Module ùïú E] [inst_4 : Module ùïú F] (B : E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] ùïú),\n  GaloisConnection (‚ÜëOrderDual.toDual ‚àò LinearMap.polar B) (LinearMap.polar (LinearMap.flip B) ‚àò ‚ÜëOrderDual.ofDual)","name":"LinearMap.polar_gc","isProp":true,"docString":"The map `B.polar : set E ‚Üí set F` forms an order-reversing Galois connection with\n`B.flip.polar : set F ‚Üí set E`. We use `OrderDual.toDual` and `OrderDual.ofDual` to express\nthat `polar` is order-reversing. "},{"type":"‚àÄ {J : Type v} {K : Type v} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.SmallCategory K]\n  (F : J √ó K ‚•§ Type v) [inst_2 : CategoryTheory.IsFiltered K] [inst_3 : CategoryTheory.FinCategory J],\n  Function.Surjective (CategoryTheory.Limits.colimitLimitToLimitColimit F)","name":"CategoryTheory.Limits.colimitLimitToLimitColimit_surjective","isProp":true,"docString":"This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\nalthough with different names.\n"},{"type":"‚àÄ {m : Type u_3} {n : Type u_4} {R : Type u_1} {S : Type u_2} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n  (f : R ‚Üí+* S) (A : Matrix m n S),\n  Matrix.map (Matrix.mvPolynomialX m n R) (MvPolynomial.eval‚ÇÇ f fun (p : m √ó n) ‚Ü¶ A (Prod.fst p) (Prod.snd p)) = A","name":"Matrix.mvPolynomialX_map_eval‚ÇÇ","isProp":true,"docString":"Any matrix `A` can be expressed as the evaluation of `Matrix.mvPolynomialX`.\n\nThis is of particular use when `MvPolynomial (m √ó n) R` is an integral domain but `S` is\nnot, as if the `MvPolynomial.eval‚ÇÇ` can be pulled to the outside of a goal, it can be solved in\nunder cancellative assumptions. "},{"type":"‚àÄ {Œ± : Type u_1} {r : Setoid Œ±} {x : Œ±} {y : Œ±}, (Quotient.mk' x = Quotient.mk' y : Prop) ‚Üî (Setoid.Rel r x y : Prop)","name":"Quotient.eq_rel","isProp":true,"docString":"A version of `Quotient.eq'` compatible with `Setoid.Rel`, to make rewriting possible. "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} (self : SimpleGraph.IsTree G), SimpleGraph.IsAcyclic G","name":"SimpleGraph.IsTree.IsAcyclic","isProp":true,"docString":"Graph is acyclic. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CoheytingAlgebra Œ±] {a : Œ±} {b : Œ±} (a_1 : Codisjoint a b), Ôø¢a ‚â§ b","name":"Codisjoint.hnot_le_right","isProp":true,"docString":"**Alias** of the reverse direction of `hnot_le_iff_codisjoint_right`."},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] (x : E),\n  IsConnected (setOf fun (y : E) ‚Ü¶ SameRay ‚Ñù x y)","name":"isConnected_setOf_sameRay","isProp":true,"docString":"The set of vectors in the same ray as `x` is connected. "},{"type":"‚àÄ {V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'} {u : V} {v : V} (p : SimpleGraph.Walk G u v)\n  {f : G ‚Üíg G'} (f' : G ‚Üíg G') (h : f = f'),\n  SimpleGraph.Walk.map f p =\n    SimpleGraph.Walk.copy (SimpleGraph.Walk.map f' p)\n      ((Eq.rec ((rfl=:‚Üëf u = ‚Üëf u)=:‚Üëf u = ‚Üëf u) h=:‚Üëf' u = ‚Üëf u)=:‚Üëf' u = ‚Üëf u)\n      ((Eq.rec ((rfl=:‚Üëf v = ‚Üëf v)=:‚Üëf v = ‚Üëf v) h=:‚Üëf' v = ‚Üëf v)=:‚Üëf' v = ‚Üëf v)","name":"SimpleGraph.Walk.map_eq_of_eq","isProp":true,"docString":"Unlike categories, for graphs vertex equality is an important notion, so needing to be able to\nto work with equality of graph homomorphisms is a necessary evil. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}\n  [inst_1 : CategoryTheory.Limits.HasPushout f g] {W : C} {k : CategoryTheory.Limits.pushout f g ‚ü∂ W}\n  {l : CategoryTheory.Limits.pushout f g ‚ü∂ W}\n  (h‚ÇÄ : CategoryTheory.Limits.pushout.inl ‚â´ k = CategoryTheory.Limits.pushout.inl ‚â´ l)\n  (h‚ÇÅ : CategoryTheory.Limits.pushout.inr ‚â´ k = CategoryTheory.Limits.pushout.inr ‚â´ l), k = l","name":"CategoryTheory.Limits.pushout.hom_ext","isProp":true,"docString":"Two morphisms out of a pushout are equal if their compositions with the pushout morphisms are\nequal "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddGroup Œ±] [inst_1 : AddCommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddGroupHom f),\n  IsAddGroupHom fun (a : Œ±) ‚Ü¶ -f a","name":"IsAddGroupHom.neg","isProp":true,"docString":"The negation of an additive group homomorphism is an additive group homomorphism\nif the target is commutative."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {Z : C} {X : C} {Y : C} {f : Z ‚ü∂ X} {g : Z ‚ü∂ Y}\n  {c : CategoryTheory.Limits.PushoutCocone f g} (h : CategoryTheory.Limits.IsColimit c),\n  CategoryTheory.IsPushout f g (CategoryTheory.Limits.PushoutCocone.inl c) (CategoryTheory.Limits.PushoutCocone.inr c)","name":"CategoryTheory.IsPushout.of_isColimit","isProp":true,"docString":"If `c` is a colimiting pushout cocone, then we have a `IsPushout f g c.inl c.inr`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (Œµ : ‚Ñù) (Œ¥ : ‚Ñù) (s : Set Œ±),\n  Metric.thickening Œµ (Metric.thickening Œ¥ s) ‚äÜ Metric.thickening (Œµ + Œ¥) s","name":"Metric.thickening_thickening_subset","isProp":true,"docString":"For the equality, see `thickening_thickening`. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (self : Submonoid M), 1 ‚àà Subsemigroup.carrier (Submonoid.toSubsemigroup self)","name":"Submonoid.one_mem'","isProp":true,"docString":"A submonoid contains `1`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a < b), ¬¨(b ‚â§ a : Prop)","name":"LT.lt.not_le","isProp":true,"docString":"**Alias** of `not_le_of_lt`."},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M) {w : M} {x : M} {y : M} {z : M} (a : ‚Üëc w x) (a : ‚Üëc y z),\n  ‚Üëc (w + y) (x + z)","name":"AddCon.add","isProp":true,"docString":"Additive congruence relations preserve addition."},{"type":"‚àÄ {M : Type u_2} [inst : MulOneClass M] {Œπ : Sort u_1} (S : (a : Œπ) ‚Üí Submonoid M)\n  {C : (x : M) ‚Üí (a : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) ‚Üí Prop}\n  (hp :\n    ‚àÄ (i : Œπ) (x : M) (hxS : x ‚àà S i),\n      C x ((Submonoid.mem_sup·µ¢_of_mem i hxS=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (h1 : C 1 ((one_mem (sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:1 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:1 ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  (hmul :\n    ‚àÄ (x : M) (y : M) (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (hy : y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i) (a : C x hx) (a : C y hy),\n      C (x * y) ((mul_mem hx hy=:x * y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i)=:x * y ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i))\n  {x : M} (hx : x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i), C x hx","name":"Submonoid.sup·µ¢_induction'","isProp":true,"docString":"A dependent version of `Submonoid.sup·µ¢_induction`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Ring Œ±] (self : Ring.PositiveCone Œ±),\n  AddCommGroup.PositiveCone.nonneg (Ring.PositiveCone.toPositiveCone self) 1","name":"Ring.PositiveCone.one_nonneg","isProp":true,"docString":"In a positive cone, `1` is `nonneg` "},{"type":"‚àÄ {a : ENNReal}, (AddLECancellable a : Prop) ‚Üî (a ‚â† ‚ä§ : Prop)","name":"ENNReal.addLECancellable_iff_ne","isProp":true,"docString":"An element `a` is `AddLECancellable` if `a + b ‚â§ a + c` implies `b ‚â§ c` for all `b` and `c`.\nThis is true in `‚Ñù‚â•0‚àû` for all elements except `‚àû`. "},{"type":"‚àÄ {m : ‚Ñï} {n : ‚Ñï}, (m ‚à£ m + n : Prop) ‚Üî (m ‚à£ n : Prop)","name":"Nat.dvd_add_self_left","isProp":true,"docString":"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`."},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_2} [inst_1 : AddCommMonoid N]\n  (f : AddSubmonoid.LocalizationMap S N) (x : M) (y : { x : M // x ‚àà S }),\n  ‚àÉ (c : { x : M // x ‚àà S }),\n    ‚Üëc + (‚Üë(Prod.snd (AddSubmonoid.LocalizationMap.sec f (AddSubmonoid.LocalizationMap.mk' f x y))) + x) =\n      ‚Üëc + (‚Üëy + Prod.fst (AddSubmonoid.LocalizationMap.sec f (AddSubmonoid.LocalizationMap.mk' f x y)))","name":"AddSubmonoid.LocalizationMap.exists_of_sec_mk'","isProp":true,"docString":"Given a Localization map `f : M ‚Üí+ N` for a Submonoid `S ‚äÜ M`, for all `x‚ÇÅ : M`\nand `y‚ÇÅ ‚àà S`, if `x‚ÇÇ : M, y‚ÇÇ ‚àà S` are such that `(f x‚ÇÅ - f y‚ÇÅ) + f y‚ÇÇ = f x‚ÇÇ`, then there exists\n`c ‚àà S` such that `x‚ÇÅ + y‚ÇÇ + c = x‚ÇÇ + y‚ÇÅ + c`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] (self : Œ± ‚âÉ·µ§ Œ≤),\n  UniformContinuous (Equiv.invFun (UniformEquiv.toEquiv self))","name":"UniformEquiv.uniformContinuous_invFun","isProp":true,"docString":"Uniform continuity of the inverse "},{"type":"‚àÄ {Œ± : Sort u} {Œ±' : Sort w} [inst : DecidableEq Œ±] [inst_1 : DecidableEq Œ±'] {Œ≤ : Sort u_1} (g : (a : Œ±') ‚Üí Œ≤)\n  {f : (a : Œ±) ‚Üí Œ±'} (hf : Function.Injective f) (i : Œ±) (a : Œ≤),\n  Function.update g (f i) a ‚àò f = Function.update (g ‚àò f) i a","name":"Function.update_comp_eq_of_injective","isProp":true,"docString":"Non-dependent version of `Function.update_comp_eq_of_injective'` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {r : Setoid Œ±} {f : (a : Œ±) ‚Üí Œ≤} (H : r ‚â§ Setoid.ker f) (g : (a : Quotient r) ‚Üí Œ≤)\n  (Hg : f = g ‚àò Quotient.mk''), Quotient.lift f H = g","name":"Setoid.lift_unique","isProp":true,"docString":"The uniqueness part of the universal property for quotients of an arbitrary type. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {A : Type v} [inst_1 : Semiring A] [inst_2 : Algebra R A] {M : Submodule R A}\n  {N : Submodule R A} {C : (r : A) ‚Üí (a : r ‚àà M * N) ‚Üí Prop}\n  (hm :\n    ‚àÄ (m : A) (x : m ‚àà M) (n : A) (x_1 : n ‚àà N),\n      C (m * n) ((Submodule.mul_mem_mul x x_1=:m * n ‚àà M * N)=:m * n ‚àà M * N))\n  (ha :\n    ‚àÄ (x : A) (hx : x ‚àà M * N) (y : A) (hy : y ‚àà M * N) (a : C x hx) (a : C y hy),\n      C (x + y) ((add_mem hx hy=:x + y ‚àà M * N)=:x + y ‚àà M * N))\n  {r : A} (hr : r ‚àà M * N), C r hr","name":"Submodule.mul_induction_on'","isProp":true,"docString":"A dependent version of `mul_induction_on`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {D : Type u_3} [inst_1 : CategoryTheory.Category D] (F : C ‚•§ D)\n  {W : C} {X : C} {Y : C} {Z : C} {f : W ‚ü∂ X} {g : W ‚ü∂ Y} {h : X ‚ü∂ Z} {i : Y ‚ü∂ Z} (s : CategoryTheory.CommSq f g h i),\n  CategoryTheory.CommSq (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) g)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) h)\n    (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) i)","name":"CategoryTheory.CommSq.map","isProp":true,"docString":"**Alias** of `CategoryTheory.Functor.map_commSq`."},{"type":"‚àÄ {Œ± : Type u_3} {Œπ : Type u_2} {Œπ' : Type u_1} [inst : CompleteLattice Œ±] {s : Set Œπ'} {g : (a : Œπ') ‚Üí Set Œπ}\n  {f : (a : Œπ) ‚Üí Œ±} (hs : Set.PairwiseDisjoint s fun (i' : Œπ') ‚Ü¶ sup·µ¢ fun (i : Œπ) ‚Ü¶ sup·µ¢ fun (h : i ‚àà g i') ‚Ü¶ f i)\n  (hg : ‚àÄ (i : Œπ') (a : i ‚àà s), Set.PairwiseDisjoint (g i) f),\n  Set.PairwiseDisjoint (Set.union·µ¢ fun (i : Œπ') ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà s) ‚Ü¶ g i) f","name":"Set.PairwiseDisjoint.bunion·µ¢","isProp":true,"docString":"Bind operation for `set.pairwise_disjoint`. If you want to only consider finsets of indices, you\ncan use `set.pairwise_disjoint.bUnion_finset`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œ±} {Œ≥ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid Œ≥]\n  [inst_2 : TopologicalSpace Œ≥] [inst_3 : OrderTopology Œ≥] {f : (a : Œ±) ‚Üí Œ≥} {g : (a : Œ±) ‚Üí Œ≥}\n  (hf : LowerSemicontinuousOn f s) (hg : LowerSemicontinuousOn g s)\n  (hcont : ‚àÄ (x : Œ±) (a : x ‚àà s), ContinuousAt (fun (p : Œ≥ √ó Œ≥) ‚Ü¶ Prod.fst p + Prod.snd p) (f x, g x)),\n  LowerSemicontinuousOn (fun (z : Œ±) ‚Ü¶ f z + g z) s","name":"LowerSemicontinuousOn.add'","isProp":true,"docString":"The sum of two lower semicontinuous functions is lower semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p‚ÇÇ : (a : Œπ) ‚Üí P) (p‚ÇÅ : P) (b : P),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p‚ÇÅ -·µ• p‚ÇÇ i)) =\n    (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) ‚Ä¢ (p‚ÇÅ -·µ• b) - ‚Üë(Finset.weightedVSubOfPoint s p‚ÇÇ b) w","name":"Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint","isProp":true,"docString":"A weighted sum of pairwise subtractions, where the point on the left is constant,\nexpressed as a subtraction involving a `weightedVSubOfPoint` expression. "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [self : CommGroupWithZero G‚ÇÄ] (n : ‚Ñï) (a : G‚ÇÄ),\n  CommGroupWithZero.zpow (Int.negSucc n) a = (CommGroupWithZero.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"CommGroupWithZero.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u} [inst : Infinite Œ±] {s : Set Œ±} (hf : Set.Finite s), ¬¨(s ‚àà Filter.hyperfilter Œ± : Prop)","name":"Set.Finite.nmem_hyperfilter","isProp":true,"docString":"**Alias** of `Filter.nmem_hyperfilter_of_finite`."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [hc : CategoryTheory.IsConnected J],\n  CategoryTheory.IsConnected (CategoryTheory.ULiftHom (ULift J))","name":"CategoryTheory.instIsConnectedULiftHomULiftCategoryUliftCategory","isProp":true,"docString":"Lifting the universe level of morphisms and objects preserves connectedness. "},{"type":"‚àÄ {Œ± : Sort u} {a : Œ±}, a = a","name":"rfl","isProp":true,"docString":"`rfl : a = a` is the unique constructor of the equality type. This is the\nsame as `Eq.refl` except that it takes `a` implicitly instead of explicitly.\n\nThis is a more powerful theorem than it may appear at first, because although\nthe statement of the theorem is `a = a`, lean will allow anything that is\ndefinitionally equal to that type. So, for instance, `2 + 2 = 4` is proven in\nlean by `rfl`, because both sides are the same up to definitional equality.\n"},{"type":"‚àÄ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst_3 : IsScalarTower R S M] (b : S) (ha : IsSMulRegular M a),\n  (IsSMulRegular M (a ‚Ä¢ b) : Prop) ‚Üî (IsSMulRegular M b : Prop)","name":"IsSMulRegular.smul_iff","isProp":true,"docString":"An element is `M`-regular if and only if multiplying it on the left by an `M`-regular element\nis `M`-regular. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {f : (a : Œπ) ‚Üí Œ±} {s : Set Œ±} (h : ‚àÄ (x : Œπ), f x ‚àà s) (a : Function.Injective f),\n  Function.Injective (Set.codRestrict f s h)","name":"Function.Injective.codRestrict","isProp":true,"docString":"**Alias** of the reverse direction of `Set.injective_codRestrict`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±}\n  [inst_1 : Filter.NeBot l],\n  (Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ r * f x) l Filter.atBot : Prop) ‚Üî\n    (((0 < r : Prop) ‚àß (Filter.Tendsto f l Filter.atBot : Prop) : Prop) ‚à®\n        ((r < 0 : Prop) ‚àß (Filter.Tendsto f l Filter.atTop : Prop) : Prop) :\n      Prop)","name":"Filter.tendsto_const_mul_atBot_iff","isProp":true,"docString":"The function `Œª x, r * f x` tends to negative infinity along a nontrivial filter if and only if\n`r > 0` and `f` tends to negative infinity or `r < 0` and `f` tends to infinity. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y}\n  {F : CategoryTheory.Limits.MonoFactorisation f} (self : CategoryTheory.Limits.IsImage F)\n  (F' : CategoryTheory.Limits.MonoFactorisation f),\n  CategoryTheory.Limits.IsImage.lift self F' ‚â´ CategoryTheory.Limits.MonoFactorisation.m F' =\n    CategoryTheory.Limits.MonoFactorisation.m F","name":"CategoryTheory.Limits.IsImage.lift_fac","isProp":true,"docString":"Data exhibiting that a given factorisation through a mono is initial. "},{"type":"‚àÄ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ‚Ñù F] {x : F} {y : F} (h : SameRay ‚Ñù x y),\n  (‚Äñx‚Äñ = ‚Äñy‚Äñ : Prop) ‚Üî (x = y : Prop)","name":"SameRay.norm_eq_iff","isProp":true,"docString":"The norms of two vectors on the same ray are equal if and only if they are equal. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Isometry f) (x : Œ±) (y : Œ±), edist (f x) (f y) = edist x y","name":"Isometry.edist_eq","isProp":true,"docString":"An isometry preserves edistances. "},{"type":"‚àÄ {Œ± : Sort u_1} {p : (a : Œ±) ‚Üí Prop} {q : (x : Œ±) ‚Üí (a : p x) ‚Üí Prop},\n  (‚àÄ (x : Œ±) (h : p x), q x h : Prop) ‚Üî (‚àÄ (x : { a : Œ± // p a }), q ‚Üëx ((Subtype.property x=:p ‚Üëx)=:p ‚Üëx) : Prop)","name":"Subtype.forall'","isProp":true,"docString":"An alternative version of `Subtype.forall`. This one is useful if Lean cannot figure out `q`\nwhen using `Subtype.forall` from right to left. "},{"type":"‚àÄ {G : Type u_1} [inst : AddGroup G] (self : AddSubgroup G) {x : G}\n  (a : x ‚àà AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup (AddSubgroup.toAddSubmonoid self))),\n  -x ‚àà AddSubsemigroup.carrier (AddSubmonoid.toAddSubsemigroup (AddSubgroup.toAddSubmonoid self))","name":"AddSubgroup.neg_mem'","isProp":true,"docString":"`G` is closed under negation "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M),\n  Con.mulKer Con.toQuotient\n      (fun (x : M) ‚Ü¶ (_ : ‚àÄ (x_1 : M), ‚Üë(x * x_1) = ‚Üë(x * x_1))=:‚àÄ (x : M) (x_1 : M), ‚Üë(x * x_1) = ‚Üë(x * x_1)) =\n    c","name":"Con.mul_ker_mk_eq","isProp":true,"docString":"The kernel of the quotient map induced by a congruence relation `c` equals `c`. "},{"type":"‚àÄ {R : Type} [inst : CommRing R] [inst_1 : CharZero R] {d : ‚Ñ§} (r : { r : R // r * r = ‚Üëd })\n  (hd : ‚àÄ (n : ‚Ñ§), d ‚â† n * n), Function.Injective ‚Üë(‚ÜëZsqrtd.lift r)","name":"Zsqrtd.lift_injective","isProp":true,"docString":"`lift r` is injective if `d` is non-square, and R has characteristic zero (that is, the map from\n`‚Ñ§` into `R` is injective). "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (Hf : Monotone f) {a : Œ±}\n  {s : Set Œ±} (Ha : IsLeast s a), IsLeast (f '' s) (f a)","name":"Monotone.map_isLeast","isProp":true,"docString":"A monotone map sends a least element of a set to a least element of its image. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrderedSemiring Œ±] (a : Œ±) (b : Œ±), (a ‚â§ b : Prop) ‚à® (b ‚â§ a : Prop)","name":"LinearOrderedSemiring.le_total","isProp":true,"docString":"A linear order is total. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {c : CategoryTheory.Limits.Fork f f}\n  (h : CategoryTheory.Limits.IsLimit c), CategoryTheory.IsIso (CategoryTheory.Limits.Fork.Œπ c)","name":"CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_self","isProp":true,"docString":"Every equalizer of `(f, f)` is an isomorphism. "},{"type":"‚àÄ {k : Type u_2} {V : Type u_4} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) {w‚ÇÅ : (a : Œπ) ‚Üí k} {w‚ÇÇ : (a : Œπ) ‚Üí k}\n  (hw : ‚àÄ (i : Œπ) (a : i ‚àà s), w‚ÇÅ i = w‚ÇÇ i) {p‚ÇÅ : (a : Œπ) ‚Üí P} {p‚ÇÇ : (a : Œπ) ‚Üí P}\n  (hp : ‚àÄ (i : Œπ) (a : i ‚àà s), p‚ÇÅ i = p‚ÇÇ i),\n  ‚Üë(Finset.affineCombination k s p‚ÇÅ) w‚ÇÅ = ‚Üë(Finset.affineCombination k s p‚ÇÇ) w‚ÇÇ","name":"Finset.affineCombination_congr","isProp":true,"docString":"`affineCombination` gives equal results for two families of weights and two families of\npoints that are equal on `s`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E] (a : E) (b : E), ‚Äña + b‚Äñ ‚â§ ‚Äña‚Äñ + ‚Äñb‚Äñ","name":"norm_add_le","isProp":true,"docString":"**Triangle inequality** for the norm."},{"type":"‚àÄ {Œ± : Type u} [inst : UniformSpace Œ±] [inst_1 : Filter.IsCountablyGenerated (uniformity Œ±)]\n  (H' : ‚àÄ (u : (a : ‚Ñï) ‚Üí Œ±) (a : CauchySeq u), ‚àÉ (a : Œ±), Filter.Tendsto u Filter.atTop (nhds a)), CompleteSpace Œ±","name":"UniformSpace.complete_of_cauchySeq_tendsto","isProp":true,"docString":"A sequentially complete uniform space with a countable basis of the uniformity filter is\ncomplete. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {ùíú : Finset (Finset Œ±)} {‚Ñ¨ : Finset (Finset Œ±)} [inst_1 : Fintype Œ±]\n  (hùíú : IsUpperSet ‚Üëùíú) (h‚Ñ¨ : IsUpperSet ‚Üë‚Ñ¨), Finset.card ùíú * Finset.card ‚Ñ¨ ‚â§ 2 ^ Fintype.card Œ± * Finset.card (ùíú ‚à© ‚Ñ¨)","name":"IsUpperSet.le_card_inter_finset","isProp":true,"docString":"**Harris-Kleitman inequality**: Any two upper sets of finsets correlate. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f : M ‚Üí‚Çô* N} {g : M ‚Üí‚Çô* N} {s : Set M}\n  (h : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subsemigroup.closure s)","name":"MulHom.eqOn_closure","isProp":true,"docString":"If two mul homomorphisms are equal on a set, then they are equal on its subsemigroup closure. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedAddMonoid Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"CanonicallyLinearOrderedAddMonoid.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R],\n  AddSubmonoid.closure (setOf fun (p : Polynomial R) ‚Ü¶ ‚àÉ (n : ‚Ñï), ‚àÉ (a : R), p = ‚Üë(Polynomial.monomial n) a) = ‚ä§","name":"Polynomial.addSubmonoid_closure_setOf_eq_monomial","isProp":true,"docString":"Monomials generate the additive monoid of polynomials. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {s : Set M}, s ‚äÜ ‚Üë(AddSubsemigroup.closure s)","name":"AddSubsemigroup.subset_closure","isProp":true,"docString":"The `AddSubsemigroup` generated by a set includes the set."},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ±) ‚Üí M}\n  (hf : Set.Finite (Function.mulSupport f)) (hg : Set.Finite (Function.mulSupport g)),\n  (finprod fun (i : Œ±) ‚Ü¶ f i * g i) = (finprod fun (i : Œ±) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ g i","name":"finprod_mul_distrib","isProp":true,"docString":"If the multiplicative supports of `f` and `g` are finite, then the product of `f i * g i` equals\nthe product of `f i` multiplied by the product of `g i`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ‚Ñï} {i : Fin (n + 1)},\n  CategoryTheory.SimplicialObject.œÉ X i ‚â´ CategoryTheory.SimplicialObject.Œ¥ X (‚ÜëFin.castSucc i) =\n    ùüô (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor X) (Opposite.op (SimplexCategory.mk n)))","name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_self","isProp":true,"docString":"The first part of the third simplicial identity "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {J : Type u}\n  [inst_2 : CategoryTheory.Category J] (R : D ‚•§ C) [inst_3 : CategoryTheory.Reflective R]\n  [inst : CategoryTheory.Limits.HasColimitsOfShape J C], CategoryTheory.Limits.HasColimitsOfShape J D","name":"CategoryTheory.hasColimitsOfShape_of_reflective","isProp":true,"docString":"If `C` has colimits of shape `J` then any reflective subcategory has colimits of shape `J`. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] (c : Con M) {a : M} {b : M}, (‚Üëa = ‚Üëb : Prop) ‚Üî (‚Üëc a b : Prop)","name":"Con.eq","isProp":true,"docString":"Two elements are related by a congruence relation `c` iff they are represented by the same\nelement of the quotient by `c`. "},{"type":"‚àÄ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [self : LieAlgebra R L] (t : R) (x : L) (y : L),\n  ‚ÅÖx, t ‚Ä¢ y‚ÅÜ = t ‚Ä¢ ‚ÅÖx, y‚ÅÜ","name":"LieAlgebra.lie_smul","isProp":true,"docString":"A Lie algebra bracket is compatible with scalar multiplication in its second argument.\n\nThe compatibility in the first argument is not a class property, but follows since every\nLie algebra has a natural Lie module action on itself, see `LieModule`. "},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] (s : Set R),\n  ‚Üë(NonUnitalSubsemiring.closure s) = ‚Üë(AddSubmonoid.closure ‚Üë(Subsemigroup.closure s))","name":"NonUnitalSubsemiring.coe_closure_eq","isProp":true,"docString":"The elements of the non-unital subsemiring closure of `M` are exactly the elements of the\nadditive closure of a multiplicative subsemigroup `M`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} (h : a < b), ¬¨(b < a : Prop)","name":"LT.lt.not_lt","isProp":true,"docString":"**Alias** of `lt_asymm`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsRingHom f), f 0 = 0","name":"IsRingHom.map_zero","isProp":true,"docString":"Ring homomorphisms map zero to zero. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {x : Œ±} {s : Set Œ±} {t : Set Œ±},\n  EMetric.infEdist x (s ‚à™ t) = EMetric.infEdist x s ‚äì EMetric.infEdist x t","name":"EMetric.infEdist_union","isProp":true,"docString":"The edist to a union is the minimum of the edists "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] [inst_1 : HasSSubset Œ±]\n  [inst_2 : IsNonstrictStrictOrder Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÇ x_1] {a : Œ±} {b : Œ±}\n  [inst_3 : IsAntisymm Œ± fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚äÜ x_1] (h : a ‚äÜ b), (a = b : Prop) ‚à® (a ‚äÇ b : Prop)","name":"HasSubset.Subset.eq_or_ssubset","isProp":true,"docString":"**Alias** of `eq_or_ssubset_of_subset`."},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedField Œ±] (a : Œ±) (b : Œ±), ‚Äña * b‚Äñ = ‚Äña‚Äñ * ‚Äñb‚Äñ","name":"NormedField.norm_mul'","isProp":true,"docString":"The norm is multiplicative. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedSemifield Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r)\n  (hf : Filter.Tendsto f l Filter.atTop), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x / r) l Filter.atTop","name":"Filter.Tendsto.atTop_div_const","isProp":true,"docString":"If a function tends to infinity along a filter, then this function divided by a positive\nconstant also tends to infinity. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  [self : CategoryTheory.Functor.ReflectsEpimorphisms F] {X : C} {Y : C} (f : X ‚ü∂ Y)\n  (a : CategoryTheory.Epi (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)), CategoryTheory.Epi f","name":"CategoryTheory.Functor.ReflectsEpimorphisms.reflects","isProp":true,"docString":"A functor reflects epimorphisms if morphisms that are mapped to epimorphisms are themselves\nepimorphisms. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (hab : a ‚â§ b) (hba : ¬¨(a < b : Prop)), b = a","name":"LE.le.eq_of_not_gt","isProp":true,"docString":"**Alias** of `eq_of_ge_of_not_gt`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} {c : Œ±} [inst : Semiring Œ±] [inst_1 : InvolutiveNeg Œ≤]\n  (h : Function.Antiperiodic f c), Function.Periodic f (2 * c)","name":"Function.Antiperiodic.periodic","isProp":true,"docString":"If a function is `antiperiodic` with antiperiod `c`, then it is also `periodic` with period\n`2 * c`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NormedField Œ±] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E] [inst_2 : NormedSpace Œ± E]\n  {c : Œ±} (hc : 1 < ‚Äñc‚Äñ) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) {x : E} (hx : ‚Äñx‚Äñ ‚â† 0),\n  ‚àÉ (n : ‚Ñ§),\n    (c ^ n ‚â† 0 : Prop) ‚àß\n      ((‚Äñc ^ n ‚Ä¢ x‚Äñ < Œµ : Prop) ‚àß ((Œµ / ‚Äñc‚Äñ ‚â§ ‚Äñc ^ n ‚Ä¢ x‚Äñ : Prop) ‚àß (‚Äñc ^ n‚Äñ‚Åª¬π ‚â§ Œµ‚Åª¬π * ‚Äñc‚Äñ * ‚Äñx‚Äñ : Prop) : Prop) : Prop)","name":"rescale_to_shell_semi_normed_zpow","isProp":true,"docString":"If there is a scalar `c` with `‚Äñc‚Äñ>1`, then any element with nonzero norm can be\nmoved by scalar multiplication to any shell of width `‚Äñc‚Äñ`. Also recap information on the norm of\nthe rescaling element that shows up in applications. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {x : ùïú} {s : Set ùïú} (hx : x ‚àà s) (a : StarConvex ùïú x s),\n  Set.OrdConnected s","name":"StarConvex.ordConnected","isProp":true,"docString":"**Alias** of the forward direction of `starConvex_iff_ordConnected`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œπ : Type u_3} (a : Œ±) (b : Œ≤) (i : Œπ),\n  Filter.coprod (Filter.map (fun (x : Œ±) ‚Ü¶ b) (Filter.principal {a})) (Filter.map id (Filter.principal {i})) =\n    Filter.principal ({b} √óÀ¢ Set.univ ‚à™ Set.univ √óÀ¢ {i})","name":"Filter.map_const_principal_coprod_map_id_principal","isProp":true,"docString":"Characterization of the coproduct of the `filter.map`s of two principal filters `ùìü {a}` and\n`ùìü {i}`, the first under the constant function `Œª a, b` and the second under the identity function.\nTogether with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this provides an\nexample showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Y : Type u_1} [inst_1 : TopologicalSpace Y] [inst_2 : DiscreteTopology Y]\n  {s : Set Œ±} (hs : IsPreconnected s) {f : (a : Œ±) ‚Üí Y} (hf : ContinuousOn f s) {x : Œ±} {y : Œ±} (hx : x ‚àà s)\n  (hy : y ‚àà s), f x = f y","name":"IsPreconnected.constant","isProp":true,"docString":"A preconnected set `s` has the property that every map to a\ndiscrete space that is continuous on `s` is constant on `s` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {S : D}\n  {T : C ‚•§ D} [inst_2 : CategoryTheory.Limits.HasLimits C] [inst_3 : CategoryTheory.Limits.PreservesLimits T]\n  {A : CategoryTheory.StructuredArrow S T} (P : CategoryTheory.Subobject A)\n  {q :\n    Prefunctor.obj (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Functor.fromPUnit S))\n        (CategoryTheory.Comma.left A) ‚ü∂\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor T)\n        (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.Subobject.underlying)\n          (CategoryTheory.StructuredArrow.projectSubobject P))}\n  (hq :\n    q ‚â´\n        Prefunctor.map (CategoryTheory.Functor.toPrefunctor T)\n          (CategoryTheory.Subobject.arrow (CategoryTheory.StructuredArrow.projectSubobject P)) =\n      CategoryTheory.Comma.hom A),\n  CategoryTheory.StructuredArrow.liftSubobject (CategoryTheory.StructuredArrow.projectSubobject P) hq = P","name":"CategoryTheory.StructuredArrow.lift_projectSubobject","isProp":true,"docString":"Projecting and then lifting a subobject recovers the original subobject, because there is at\nmost one morphism making the projected subobject into a structured arrow. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±·µí·µà} {b : Œ±·µí·µà} (a_1 : b ‚ãñ a), ‚ÜëOrderDual.ofDual a ‚ãñ ‚ÜëOrderDual.ofDual b","name":"Covby.ofDual","isProp":true,"docString":"**Alias** of the reverse direction of `ofDual_covby_ofDual_iff`."},{"type":"‚àÄ {L : Type u_1} [inst : TopologicalSpace L] [inst_1 : Inf L] [self : ContinuousInf L],\n  Continuous fun (p : L √ó L) ‚Ü¶ Prod.fst p ‚äì Prod.snd p","name":"ContinuousInf.continuous_inf","isProp":true,"docString":"The infinimum is continuous "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [self : CommMonoidWithZero M‚ÇÄ] (a : M‚ÇÄ), a * 0 = 0","name":"CommMonoidWithZero.mul_zero","isProp":true,"docString":"Zero is a right absorbing element for multiplication "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Antivary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i : Prop) ‚Üî\n    (Antivary (f ‚àò ‚ÜëœÉ) g : Prop)","name":"Antivary.sum_smul_eq_sum_comp_perm_smul_iff","isProp":true,"docString":"**Equality case of the Rearrangement Inequality**: Pointwise scalar multiplication of `f` and\n`g`, which antivary together, is unchanged by a permutation if and only if `f ‚àò œÉ` and `g` antivary\ntogether. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {B : Type u_2} {F : Type u_3} {Z : Type u_4} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  {proj : (a : Z) ‚Üí B} [inst_2 : TopologicalSpace Z] {X : Type u_1} [inst_3 : TopologicalSpace X] {f : (a : X) ‚Üí Z}\n  {x : X} (e : Trivialization F proj) (hf_proj : ContinuousAt (proj ‚àò f) x) (he : proj (f x) ‚àà Trivialization.baseSet e)\n  (hf : ContinuousAt (‚Üëe ‚àò f) x), ContinuousAt f x","name":"Trivialization.continuousAt_of_comp_left","isProp":true,"docString":"Read off the continuity of a function `f : X ‚Üí Z` at `x : X` by transferring via a\ntrivialization of `Z` containing `f x`. "},{"type":"‚àÄ {p : (a : ‚Ñï) ‚Üí Prop} [inst : DecidablePred p] {n : ‚Ñï} (a : ¬¨(p n : Prop)), Nat.count p (n + 1) = Nat.count p n","name":"Nat.count_succ_eq_count","isProp":true,"docString":"**Alias** of the reverse direction of `Nat.count_succ_eq_count_iff`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œπ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommGroup E]\n  [inst_2 : Module ùïú E] {p : (a : Œπ) ‚Üí E} (hc : ConvexIndependent ùïú p) (s : Set Œπ) (i : Œπ),\n  (p i ‚àà ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) (p '' s) : Prop) ‚Üî (i ‚àà s : Prop)","name":"ConvexIndependent.mem_convexHull_iff","isProp":true,"docString":"If a family is convex independent, a point in the family is in the convex hull of some of the\npoints given by a subset of the index type if and only if the point's index is in this subset. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} {y : K} (a : x ‚àà s) (a : y ‚àà s), x / y ‚àà s","name":"Subfield.div_mem","isProp":true,"docString":"A subfield is closed under division. "},{"type":"‚àÄ {C : (a : ‚Ñï) ‚Üí Sort u_1} {z : C 0} {f : (b : Bool) ‚Üí (n : ‚Ñï) ‚Üí (a : C n) ‚Üí C (Nat.bit b n)} (b : Bool) (n : ‚Ñï)\n  (h : (f false 0 z = z : Prop) ‚à® (‚àÄ (a : n = 0), b = true : Prop)),\n  Nat.binaryRec z f (Nat.bit b n) = f b n (Nat.binaryRec z f n)","name":"Nat.binaryRec_eq'","isProp":true,"docString":"The same as `binaryRec_eq`,\nbut that one unfortunately requires `f` to be the identity when appending `false` to `0`.\nHere, we allow you to explicitly say that that case is not happening,\ni.e. supplying `n = 0 ‚Üí b = true`. "},{"type":"‚àÄ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [self : RightDistribClass R] (a : R) (b : R) (c : R),\n  (a + b) * c = a * c + b * c","name":"RightDistribClass.right_distrib","isProp":true,"docString":"Multiplication is right distributive over addition "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R} {J : Ideal R} (a : I ‚à£ J), J ‚â§ I","name":"Ideal.le_of_dvd","isProp":true,"docString":"If `I` divides `J`, then `I` contains `J`.\n\nIn a Dedekind domain, to divide and contain are equivalent, see `Ideal.dvd_iff_le`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : Semiring Œ±] {m : ‚Ñï} {n : ‚Ñï} (h : m ‚à£ n), ‚Üëm ‚à£ ‚Üën","name":"Dvd.dvd.natCast","isProp":true,"docString":"**Alias** of `Nat.coe_nat_dvd`."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) < Finset.sum s fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g (‚ÜëœÉ i) : Prop) ‚Üî\n    (¬¨(AntivaryOn f (g ‚àò ‚ÜëœÉ) ‚Üës : Prop) : Prop)","name":"AntivaryOn.sum_smul_lt_sum_smul_comp_perm_iff","isProp":true,"docString":"**Strict inequality case of the Rearrangement Inequality**: Pointwise scalar multiplication of\n`f` and `g`, which antivary together, is strictly decreased by a permutation if and only if\n`f` and `g ‚àò œÉ` do not antivary together. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {R : Type u} [self : AddMonoidWithOne R], NatCast.natCast 0 = 0","name":"AddMonoidWithOne.natCast_zero","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` sends `0 : ‚Ñï` to `0 : R`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteBooleanAlgebra Œ±] (a : Œ±) (s : Set Œ±),\n  a ‚äì sup‚Çõ s ‚â§ sup·µ¢ fun (b : Œ±) ‚Ü¶ sup·µ¢ fun (h : b ‚àà s) ‚Ü¶ a ‚äì b","name":"CompleteBooleanAlgebra.inf_sup‚Çõ_le_sup·µ¢_inf","isProp":true,"docString":"In a frame, `‚äì` distributes over `‚®Ü`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] (f : Equiv.Perm Œ±)\n  (comm :\n    optParam (Set.Pairwise (‚Üë(Equiv.Perm.cycleFactorsFinset f)) Commute : Prop)\n      ((Equiv.Perm.cycleFactorsFinset_mem_commute\n            f=:Set.Pairwise (‚Üë(Equiv.Perm.cycleFactorsFinset f))\n            Commute)=:Set.Pairwise (‚Üë(Equiv.Perm.cycleFactorsFinset f)) Commute)),\n  Finset.noncommProd (Equiv.Perm.cycleFactorsFinset f) id comm = f","name":"Equiv.Perm.cycleFactorsFinset_noncommProd","isProp":true,"docString":"The product of cycle factors is equal to the original `f : perm Œ±`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : StrictMono f),\n  StrictMono (WithBot.map f)","name":"StrictMono.withBot_map","isProp":true,"docString":"**Alias** of the reverse direction of `WithBot.strictMono_map_iff`."},{"type":"‚àÄ {n : ‚Ñ§} (a : IsUnit n), Int.natAbs n = 1","name":"Int.IsUnit.natAbs_eq","isProp":true,"docString":"**Alias** of the forward direction of `Int.isUnit_iff_natAbs_eq`."},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommGroup Œ≤] [inst_3 : SMul ùïú E] [inst_4 : Module ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (a : StrictConcaveOn ùïú s f), StrictConvexOn ùïú s (-f)","name":"StrictConcaveOn.neg","isProp":true,"docString":"**Alias** of the reverse direction of `neg_strictConvexOn_iff`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.Mono f]\n  [inst_2 : CategoryTheory.IsSplitEpi f], CategoryTheory.IsIso f","name":"CategoryTheory.isIso_of_mono_of_isSplitEpi","isProp":true,"docString":"A split epi which is mono is an iso. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLinearOrderBot Œ±] {s : Set Œ±} (hs : Set.Nonempty s),\n  ‚Üë(inf‚Çõ s) = inf·µ¢ fun (a : Œ±) ‚Ü¶ inf·µ¢ fun (h : a ‚àà s) ‚Ü¶ ‚Üëa","name":"WithTop.coe_inf‚Çõ","isProp":true,"docString":"A version of `WithTop.coe_inf‚Çõ'` with a more convenient but less general statement. "},{"type":"‚àÄ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Category D] {L : C ‚•§ D}\n  {W : CategoryTheory.MorphismProperty C} [self : CategoryTheory.Functor.IsLocalization L W],\n  CategoryTheory.MorphismProperty.IsInvertedBy W L","name":"CategoryTheory.Functor.IsLocalization.inverts","isProp":true,"docString":"the functor inverts the given `MorphismProperty` "},{"type":"‚àÄ {Œ± : Type u_2} {n : Type u_1} {m : Type u_3} [inst : Mul Œ±] [inst_1 : AddCommMonoid Œ±] (A : Matrix m n Œ±)\n  [inst_2 : Fintype n], (Matrix.HasOrthogonalCols (Matrix.transpose A) : Prop) ‚Üî (Matrix.HasOrthogonalRows A : Prop)","name":"Matrix.transpose_hasOrthogonalCols_iff_hasOrthogonalRows","isProp":true,"docString":"`A·µÄ` has orthogonal columns iff `A` has orthogonal rows. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F' : Type u_3} [inst : Norm E] [inst_1 : SeminormedAddCommGroup F'] {c : ‚Ñù}\n  {f : (a : Œ±) ‚Üí E} {g' : (a : Œ±) ‚Üí F'} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l f g'),\n  Asymptotics.IsBigOWith c l f fun (x : Œ±) ‚Ü¶ ‚Äñg' x‚Äñ","name":"Asymptotics.IsBigOWith.norm_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigOWith_norm_right`."},{"type":"‚àÄ {m : Type u_2} {n : Type u_3} {R : Type u_1} {Œ± : Type v} [inst : Star R] [inst_1 : Star Œ±] [inst_2 : SMul R Œ±]\n  [inst_3 : StarModule R Œ±] (c : R) (M : Matrix m n Œ±), Matrix.conjTranspose (c ‚Ä¢ M) = star c ‚Ä¢ Matrix.conjTranspose M","name":"Matrix.conjTranspose_smul","isProp":true,"docString":"Note that `StarModule` is quite a strong requirement; as such we also provide the following\nvariants which this lemma would not apply to:\n* `Matrix.conjTranspose_smul_non_comm`\n* `Matrix.conjTranspose_nsmul`\n* `Matrix.conjTranspose_zsmul`\n* `Matrix.conjTranspose_natCast_smul`\n* `Matrix.conjTranspose_intCast_smul`\n* `Matrix.conjTranspose_inv_natCast_smul`\n* `Matrix.conjTranspose_inv_intCast_smul`\n* `Matrix.conjTranspose_rat_smul`\n* `Matrix.conjTranspose_ratCast_smul`\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±]\n  (H :\n    ‚àÄ (Œµ : ‚Ñù) (a : Œµ > 0),\n      ‚àÉ (s : Set Œ±), (Set.Countable s : Prop) ‚àß (‚àÄ (x : Œ±), ‚àÉ (y : Œ±), (y ‚àà s : Prop) ‚àß (dist x y ‚â§ Œµ : Prop) : Prop)),\n  TopologicalSpace.SecondCountableTopology Œ±","name":"Metric.secondCountable_of_almost_dense_set","isProp":true,"docString":"A pseudometric space is second countable if, for every `Œµ > 0`, there is a countable set which\nis `Œµ`-dense. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (self : M ‚Üí+ N) (x : M) (y : M),\n  ZeroHom.toFun (‚Üëself) (x + y) = ZeroHom.toFun (‚Üëself) x + ZeroHom.toFun (‚Üëself) y","name":"AddMonoidHom.map_add'","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : Add Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±} {b : Œ±},\n  a + b - b ‚â§ a","name":"add_tsub_le_right","isProp":true,"docString":"See `add_tsub_cancel_right` for the equality if `ContravariantClass Œ± Œ± (+) (‚â§)`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] [inst_1 : DecidableRel Disjoint]\n  [inst_2 : DecidableRel fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {s : Finset Œ±} {u : Œ±} {v : Œ±} {a : Œ±}\n  (ha : a ‚àà UV.compression u v s) (hva : v ‚â§ a) (hvu : ‚àÄ (a : v = ‚ä•), u = ‚ä•), a ‚àà s","name":"UV.mem_of_mem_compression","isProp":true,"docString":"If `a` is in the `u, v`-compression but `v ‚â§ a`, then `a` must have been in the original\nfamily. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\n  CategoryTheory.Sieve.arrows (CategoryTheory.GrothendieckTopology.Cover.sieve S)\n    (CategoryTheory.GrothendieckTopology.Cover.Relation.f‚ÇÇ self)","name":"CategoryTheory.GrothendieckTopology.Cover.Relation.h‚ÇÇ","isProp":true,"docString":"The second arrow which is part of the relation is contained in the given sieve. "},{"type":"‚àÄ {n : ‚Ñï} (R : Type u_1) [inst : Ring R], Int.cast ‚àò ZMod.cast = ZMod.cast","name":"ZMod.int_cast_comp_cast","isProp":true,"docString":"The coercions are respectively `Int.cast`, `ZMod.cast`, and `ZMod.cast`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤]\n  {f : (a : Œ≤) ‚Üí UniformSpace.Completion Œ±} {g : (a : Œ≤) ‚Üí UniformSpace.Completion Œ±} (hf : Continuous f)\n  (hg : Continuous g), Continuous fun (x : Œ≤) ‚Ü¶ dist (f x) (g x)","name":"UniformSpace.Completion.continuous_dist","isProp":true,"docString":"The new distance is continuous. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {N : Type u_3} [inst : Zero R] [inst_1 : Zero M] [inst_2 : Zero N] [inst_3 : SMul R M]\n  [inst_4 : SMul R N] [inst_5 : NoZeroSMulDivisors R N] (f : (a : M) ‚Üí N) (hf : Function.Injective f) (h0 : f 0 = 0)\n  (hs : ‚àÄ (c : R) (x : M), f (c ‚Ä¢ x) = c ‚Ä¢ f x), NoZeroSMulDivisors R M","name":"Function.Injective.noZeroSMulDivisors","isProp":true,"docString":"Pullback a `NoZeroSMulDivisors` instance along an injective function. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] (a : ‚Ñï) (b : ‚Ñï) (f : (a : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí M),\n  (Finset.sum (Finset.Ico a b) fun (i : ‚Ñï) ‚Ü¶ Finset.sum (Finset.Ico i b) fun (j : ‚Ñï) ‚Ü¶ f i j) =\n    Finset.sum (Finset.Ico a b) fun (j : ‚Ñï) ‚Ü¶ Finset.sum (Finset.Ico a (j + 1)) fun (i : ‚Ñï) ‚Ü¶ f i j","name":"Finset.sum_Ico_Ico_comm","isProp":true,"docString":"The two ways of summing over `(i,j)` in the range `a<=i<=j<b` are equal. "},{"type":"‚àÄ {R : Type u} {Œπ : Type v} {M‚ÇÅ : (a : Œπ) ‚Üí Type w‚ÇÅ} {M‚ÇÇ : Type w‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] [inst_5 : (i : Œπ) ‚Üí TopologicalSpace (M‚ÇÅ i)] [inst_6 : TopologicalSpace M‚ÇÇ]\n  (f : ContinuousMultilinearMap R M‚ÇÅ M‚ÇÇ) {Œ± : (a : Œπ) ‚Üí Type u_1} [inst_7 : Fintype Œπ] (g : (i : Œπ) ‚Üí (a : Œ± i) ‚Üí M‚ÇÅ i)\n  (A : (i : Œπ) ‚Üí Finset (Œ± i)) [inst_8 : DecidableEq Œπ],\n  (‚Üëf fun (i : Œπ) ‚Ü¶ Finset.sum (A i) fun (j : Œ± i) ‚Ü¶ g i j) =\n    Finset.sum (Fintype.piFinset A) fun (r : (a : Œπ) ‚Üí Œ± a) ‚Ü¶ ‚Üëf fun (i : Œπ) ‚Ü¶ g i (r i)","name":"ContinuousMultilinearMap.map_sum_finset","isProp":true,"docString":"If `f` is continuous multilinear, then `f (Œ£_{j‚ÇÅ ‚àà A‚ÇÅ} g‚ÇÅ j‚ÇÅ, ..., Œ£_{j‚Çô ‚àà A‚Çô} g‚Çô j‚Çô)` is the\nsum of `f (g‚ÇÅ (r 1), ..., g‚Çô (r n))` where `r` ranges over all functions with `r 1 ‚àà A‚ÇÅ`, ...,\n`r n ‚àà A‚Çô`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type x} [inst : PseudoEMetricSpace Œ±] (f : (a : Œπ) ‚Üí Function.End Œ±) (K : (a : Œπ) ‚Üí NNReal)\n  (h : ‚àÄ (i : Œπ), LipschitzWith (K i) (f i)) (l : List Œπ),\n  LipschitzWith (List.prod (List.map K l)) (List.prod (List.map f l))","name":"LipschitzWith.list_prod","isProp":true,"docString":"The product of a list of Lipschitz continuous endomorphisms is a Lipschitz continuous\nendomorphism. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {t : CategoryTheory.Limits.Cone F} (h : CategoryTheory.Limits.IsLimit t) {W : C}\n  {f : W ‚ü∂ CategoryTheory.Limits.Cone.pt t} {f' : W ‚ü∂ CategoryTheory.Limits.Cone.pt t}\n  (w : ‚àÄ (j : J), f ‚â´ (CategoryTheory.Limits.Cone.œÄ t).app j = f' ‚â´ (CategoryTheory.Limits.Cone.œÄ t).app j), f = f'","name":"CategoryTheory.Limits.IsLimit.hom_ext","isProp":true,"docString":"Two morphisms into a limit are equal if their compositions with\neach cone morphism are equal. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] (a : R) {n : ‚Ñï} (h : n ‚â† 0), Polynomial.Monic (Polynomial.X ^ n - ‚ÜëPolynomial.C a)","name":"Polynomial.monic_X_pow_sub_C","isProp":true,"docString":"`X ^ n - a` is monic. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} [inst : LinearOrderedCommGroupWithZero Œ±] (ha : a ‚â§ 1) (hb : b ‚â§ 1), a * b ‚â§ 1","name":"mul_le_one‚ÇÄ","isProp":true,"docString":"Alias of `mul_le_one'` for unification. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : NonUnitalRing Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (h‚ÇÅ : a ‚à£ b) (h‚ÇÇ : a ‚à£ c), a ‚à£ b - c","name":"Dvd.dvd.sub","isProp":true,"docString":"**Alias** of `dvd_sub`."},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] ‚¶És : Set R‚¶Ñ ‚¶Ét : Set R‚¶Ñ (h : s ‚äÜ t),\n  NonUnitalSubsemiring.closure s ‚â§ NonUnitalSubsemiring.closure t","name":"NonUnitalSubsemiring.closure_mono","isProp":true,"docString":"Subsemiring closure of a set is monotone in its argument: if `s ‚äÜ t`,\nthen `closure s ‚â§ closure t`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {T : CategoryTheory.Monad C} (self : CategoryTheory.Monad.Algebra T),\n  (CategoryTheory.Monad.Œ∑ T).app (CategoryTheory.Monad.Algebra.A self) ‚â´ CategoryTheory.Monad.Algebra.a self =\n    ùüô (CategoryTheory.Monad.Algebra.A self)","name":"CategoryTheory.Monad.Algebra.unit","isProp":true,"docString":"The unit axiom associated to an algebra. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] (I : Ideal R) (s : Set R),\n  ‚Üë(Ideal.Quotient.mk I) ‚Åª¬π' (‚Üë(Ideal.Quotient.mk I) '' s) =\n    Set.union·µ¢ fun (x : { x : R // x ‚àà I }) ‚Ü¶ (fun (y : R) ‚Ü¶ ‚Üëx + y) '' s","name":"Ideal.Quotient.quotient_ring_saturate","isProp":true,"docString":"If `I` is an ideal of a commutative ring `R`, if `q : R ‚Üí R/I` is the quotient map, and if\n`s ‚äÜ R` is a subset, then `q‚Åª¬π(q(s)) = ‚ãÉ·µ¢(i + s)`, the union running over all `i ‚àà I`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : SeminormedRing Œ±] (a : Œ±) (b : Œ±), ‚Äña * b‚Äñ ‚â§ ‚Äña‚Äñ * ‚Äñb‚Äñ","name":"SeminormedRing.norm_mul","isProp":true,"docString":"The norm is submultiplicative. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (t : CategoryTheory.Limits.IsTerminal X) (f : Y ‚ü∂ X)\n  (g : Y ‚ü∂ X), f = g","name":"CategoryTheory.Limits.IsTerminal.hom_ext","isProp":true,"docString":"Any two morphisms to a terminal object are equal. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [self : CategoryTheory.IsIdempotentComplete C] (X : C) (p : X ‚ü∂ X)\n  (a : p ‚â´ p = p), ‚àÉ (Y : C), ‚àÉ (i : Y ‚ü∂ X), ‚àÉ (e : X ‚ü∂ Y), (i ‚â´ e = ùüô Y : Prop) ‚àß (e ‚â´ i = p : Prop)","name":"CategoryTheory.IsIdempotentComplete.idempotents_split","isProp":true,"docString":"A category is idempotent complete iff all idempotent endomorphisms `p`\nsplit as a composition `p = e ‚â´ i` with `i ‚â´ e = ùüô _` "},{"type":"‚àÄ (k : Type u_3) {V : Type u_4} {P : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_4 : Fintype Œπ] (p : (a : Œπ) ‚Üí P),\n  Finset.centroid k s p = ‚Üë(Finset.affineCombination k Finset.univ p) (Finset.centroidWeightsIndicator k s)","name":"Finset.centroid_eq_affineCombination_fintype","isProp":true,"docString":"The centroid as an affine combination over a `Fintype`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {i : (a : Œ±) ‚Üí Œ≤}\n  (di : DenseInducing i) [inst : TopologicalSpace.SeparableSpace Œ±], TopologicalSpace.SeparableSpace Œ≤","name":"DenseInducing.separableSpace","isProp":true,"docString":"If the domain of a `DenseInducing` map is a separable space, then so is the codomain. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [dec_irr : (p : Associates Œ±) ‚Üí Decidable (Irreducible p : Prop)]\n  [inst_1 : UniqueFactorizationMonoid Œ±] [dec : DecidableEq Œ±] [dec' : DecidableEq (Associates Œ±)] {p : Associates Œ±}\n  {a : Associates Œ±} (hp : Irreducible p) {n : ‚Ñï} (h : a ‚à£ p ^ n), a = p ^ Associates.count p (Associates.factors a)","name":"Associates.eq_pow_count_factors_of_dvd_pow","isProp":true,"docString":"The only divisors of prime powers are prime powers. See `eq_pow_find_of_dvd_irreducible_pow`\nfor an explicit expression as a p-power (without using `count`). "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M},\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà ‚àÖ) ‚Ü¶ f i) = 1","name":"finprod_mem_empty","isProp":true,"docString":"The product of any function over an empty set is `1`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] (a : R) (b : R), (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2","name":"add_pow_two","isProp":true,"docString":"**Alias** of `add_sq`."},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} (self : Subgroup.Characteristic H) (œï : G ‚âÉ* G),\n  Subgroup.comap (MulEquiv.toMonoidHom œï) H = H","name":"Subgroup.Characteristic.fixed","isProp":true,"docString":"`H` is fixed by all automorphisms "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {Œπ : Type w} {p : (a : Œπ) ‚Üí Submodule K V} (hp : CompleteLattice.Independent p)\n  [inst_4 : Fintype { i : Œπ // p i ‚â† ‚ä• }], Fintype.card { i : Œπ // p i ‚â† ‚ä• } ‚â§ FiniteDimensional.finrank K V","name":"CompleteLattice.Independent.subtype_ne_bot_le_finrank","isProp":true,"docString":"If `p` is an independent family of subspaces of a finite-dimensional space `V`, then the\nnumber of nontrivial subspaces in the family `p` is bounded above by the dimension of `V`.\n\nNote that the `Fintype` hypothesis required here can be provided by\n`CompleteLattice.Independent.fintypeNeBotOfFiniteDimensional`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : Norm E] {c : ‚Ñù} {f : (a : Œ±) ‚Üí E} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù}\n  (a : Asymptotics.IsBigOWith c l f u), Asymptotics.IsBigOWith c l f fun (x : Œ±) ‚Ü¶ abs (u x)","name":"Asymptotics.IsBigOWith.abs_right","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigOWith_abs_right`."},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {W : C} {X : C} {Y : C} {Z : C} {f : W ‚ü∂ X} {g : W ‚ü∂ Y} {h : X ‚ü∂ Z}\n  {i : Y ‚ü∂ Z} (self : CategoryTheory.CommSq f g h i), f ‚â´ h = g ‚â´ i","name":"CategoryTheory.CommSq.w","isProp":true,"docString":"The square commutes. "},{"type":"‚àÄ {m : Type u_1} {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : DecidableEq m]\n  [inst_3 : Fintype m] {R : Type v} [inst_4 : CommRing R] (e : m ‚âÉ n) (A : Matrix m m R),\n  Matrix.det (‚Üë(Matrix.reindex e e) A) = Matrix.det A","name":"Matrix.det_reindex_self","isProp":true,"docString":"Reindexing both indices along the same equivalence preserves the determinant.\n\nFor the `simp` version of this lemma, see `det_submatrix_equiv_self`; this one is unsuitable because\n`Matrix.reindex_apply` unfolds `reindex` first.\n"},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {p‚ÇÅ : P} {p‚ÇÇ : P} {p‚ÇÉ : P} (hp‚ÇÅp‚ÇÉ : p‚ÇÅ ‚â† p‚ÇÉ) (hp‚ÇÅ : p‚ÇÅ ‚àà s)\n  (hp‚ÇÇ : ¬¨(p‚ÇÇ ‚àà s : Prop)) (hp‚ÇÉ : p‚ÇÉ ‚àà s), AffineIndependent k ![p‚ÇÅ, p‚ÇÇ, p‚ÇÉ]","name":"affineIndependent_of_ne_of_mem_of_not_mem_of_mem","isProp":true,"docString":"If distinct points `p‚ÇÅ` and `p‚ÇÉ` lie in `s` but `p‚ÇÇ` does not, the three points are affinely\nindependent. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Zero Œ±] [inst_1 : Zero Œ≤] [inst_2 : SMulWithZero Œ± Œ≤] [inst_3 : DecidableEq Œ≤]\n  {s : Finset Œ≤} (h : Finset.Nonempty s), 0 ‚Ä¢ s = 0","name":"Finset.zero_smul_finset","isProp":true,"docString":"A nonempty set is scaled by zero to the singleton set containing 0. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_1} {P : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_4} (s : Finset Œπ) (w‚ÇÅ : (a : Œπ) ‚Üí k) (w‚ÇÇ : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.affineCombination k s p) w‚ÇÅ -·µ• ‚Üë(Finset.affineCombination k s p) w‚ÇÇ = ‚Üë(Finset.weightedVSub s p) (w‚ÇÅ - w‚ÇÇ)","name":"Finset.affineCombination_vsub","isProp":true,"docString":"Subtracting two `affineCombination`s. "},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel (SimpleGraph.Adj G)] [inst_2 : Nonempty V],\n  SimpleGraph.maxDegree G < Fintype.card V","name":"SimpleGraph.maxDegree_lt_card_verts","isProp":true,"docString":"The maximum degree of a nonempty graph is less than the number of vertices. Note that the assumption\nthat `V` is nonempty is necessary, as otherwise this would assert the existence of a\nnatural number less than zero. "},{"type":"‚àÄ {R : Type u_2} [inst : CommRing R] (M : Submonoid R) {S : Type u_3} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsLocalization M S] {Œπ : Type u_1} [inst_4 : Finite Œπ] (f : (a : Œπ) ‚Üí S),\n  ‚àÉ (b : { x : R // x ‚àà M }), ‚àÄ (i : Œπ), IsLocalization.IsInteger R (‚Üëb ‚Ä¢ f i)","name":"IsLocalization.exist_integer_multiples_of_finite","isProp":true,"docString":"We can clear the denominators of a finite indexed family of fractions. "},{"type":"‚àÄ {F : PFunctor} (self : PFunctor.MIntl F), PFunctor.Approx.AllAgree (PFunctor.MIntl.approx self)","name":"PFunctor.MIntl.consistent","isProp":true,"docString":"Each approximation agrees with the next "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Top Œ±] [inst_1 : Top Œ≤] (self : TopHom Œ± Œ≤), TopHom.toFun self ‚ä§ = ‚ä§","name":"TopHom.map_top'","isProp":true,"docString":"The function preserves the top element. The preferred spelling is `map_top`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} [inst : AddCommMonoid Œ≤] [inst_1 : DecidableEq Œ±] (s : Finset Œ±) (f : (a : Œ±) ‚Üí Œ≤) {a : Œ±}\n  (h : a ‚àà s), (f a + Finset.sum (Finset.erase s a) fun (x : Œ±) ‚Ü¶ f x) = Finset.sum s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.add_sum_erase","isProp":true,"docString":"Taking a sum over `s : Finset Œ±` is the same as adding the value on a single element\n`f a` to the sum over `s.erase a`.\n\nSee `Multiset.sum_map_erase` for the `Multiset` version."},{"type":"‚àÄ {Œ± : Type u} {L‚ÇÅ : List (Œ± √ó Bool)} {L‚ÇÇ : List (Œ± √ó Bool)} [inst : DecidableEq Œ±] (H : FreeAddGroup.Red L‚ÇÅ L‚ÇÇ),\n  FreeAddGroup.Red L‚ÇÇ (FreeAddGroup.reduce L‚ÇÅ)","name":"FreeAddGroup.reduce.rev","isProp":true,"docString":"If words `w‚ÇÅ w‚ÇÇ` are such that `w‚ÇÅ` reduces to `w‚ÇÇ`, then `w‚ÇÇ` reduces to the maximal\nreduction of `w‚ÇÅ`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {x : NonAssocSemiring Œ±} {x_1 : NonAssocSemiring Œ≤} (f : Œ± ‚Üí+* Œ≤),\n  (0 = 1 : Prop) ‚Üî (Set.range ‚Üëf = {0} : Prop)","name":"RingHom.codomain_trivial_iff_range_eq_singleton_zero","isProp":true,"docString":"`f : Œ± ‚Üí+* Œ≤` has a trivial codomain iff its range is `{0}`. "},{"type":"‚àÄ {Œ± : Type u} [inst : HasSubset Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hab : a ‚äÜ b) (hbc : b = c), a ‚äÜ c","name":"HasSubset.subset.trans_eq","isProp":true,"docString":"**Alias** of `subset_of_subset_of_eq`."},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {œÉ : R ‚Üí+* S} {œÉ' : S ‚Üí+* R}\n  [inst_2 : RingHomInvPair œÉ œÉ'] [inst_3 : RingHomInvPair œÉ' œÉ] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : AddCommMonoid M] {M‚ÇÇ : Type u_4} [inst_6 : TopologicalSpace M‚ÇÇ] [inst_7 : AddCommMonoid M‚ÇÇ]\n  [inst_8 : Module R M] [inst_9 : Module S M‚ÇÇ] (self : M ‚âÉSL[œÉ] M‚ÇÇ),\n  Continuous (LinearEquiv.invFun (ContinuousLinearEquiv.toLinearEquiv self))","name":"ContinuousLinearEquiv.continuous_invFun","isProp":true,"docString":"Continuous linear equivalences between modules. We only put the type classes that are necessary\nfor the definition, although in applications `M` and `M‚ÇÇ` will be topological modules over the\ntopological semiring `R`. "},{"type":"‚àÄ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  (f : (a : J) ‚Üí C) [inst_2 : CategoryTheory.Limits.HasBiproduct f] {b : CategoryTheory.Limits.Bicone f}\n  (hb : CategoryTheory.Limits.Bicone.IsBilimit b),\n  CategoryTheory.Iso.hom\n      (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso (CategoryTheory.Limits.Bicone.IsBilimit.isLimit hb)\n        (CategoryTheory.Limits.biproduct.isLimit f)) =\n    CategoryTheory.Limits.biproduct.lift (CategoryTheory.Limits.Bicone.œÄ b)","name":"CategoryTheory.Limits.biproduct.conePointUniqueUpToIso_hom","isProp":true,"docString":"Auxiliary lemma for `biproduct.uniqueUpToIso`. "},{"type":"‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] (œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ) (œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ)\n  [inst_2 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ], RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ","name":"RingHomInvPair.symm","isProp":true,"docString":"Swap the direction of a `RingHomInvPair`. This is not an instance as it would loop, and better\ninstances are often available and may often be preferrable to using this one. Indeed, this\ndeclaration is not currently used in mathlib.\n\nSee note [reducible non-instances].\n"},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : LinearOrder Œπ] (s : Finset Œπ) (f : (a : Œπ) ‚Üí R)\n  (g : (a : Œπ) ‚Üí R),\n  (Finset.prod s fun (i : Œπ) ‚Ü¶ f i - g i) =\n    (Finset.prod s fun (i : Œπ) ‚Ü¶ f i) -\n      Finset.sum s fun (i : Œπ) ‚Ü¶\n        (g i * Finset.prod (Finset.filter (fun (x : Œπ) ‚Ü¶ x < i) s) fun (j : Œπ) ‚Ü¶ f j - g j) *\n          Finset.prod (Finset.filter (fun (j : Œπ) ‚Ü¶ i < j) s) fun (j : Œπ) ‚Ü¶ f j","name":"Finset.prod_sub_ordered","isProp":true,"docString":"`‚àè i, (f i - g i) = (‚àè i, f i) - ‚àë i, g i * (‚àè j < i, f j - g j) * (‚àè j > i, f j)`. "},{"type":"‚àÄ {R : Type u} {œÉ : Type u_1} [inst : CommSemiring R] {M : (a : MvPolynomial œÉ R) ‚Üí Prop} (p : MvPolynomial œÉ R)\n  (h_C : ‚àÄ (a : R), M (‚ÜëMvPolynomial.C a))\n  (h_add : ‚àÄ (p : MvPolynomial œÉ R) (q : MvPolynomial œÉ R) (a : M p) (a : M q), M (p + q))\n  (h_X : ‚àÄ (p : MvPolynomial œÉ R) (n : œÉ) (a : M p), M (p * MvPolynomial.X n)), M p","name":"MvPolynomial.induction_on","isProp":true,"docString":"Analog of `Polynomial.induction_on`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] {Œ¥ : ‚Ñù} {E : Set Œ±} (hE : IsCompact E) (hŒ¥ : 0 ‚â§ Œ¥),\n  Metric.cthickening Œ¥ E = Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà E) ‚Ü¶ Metric.closedBall x Œ¥","name":"IsCompact.cthickening_eq_bunion·µ¢_closedBall","isProp":true,"docString":"The closed thickening of a compact set `E` is the union of the balls `Metric.closedBall x Œ¥`\nover `x ‚àà E`.\n\nSee also `Metric.cthickening_eq_bunion·µ¢_closedBall`. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (0 ‚â§ -a : Prop) ‚Üî (a ‚â§ 0 : Prop)","name":"Left.nonneg_neg_iff","isProp":true,"docString":"Uses `left` co(ntra)variant."},{"type":"‚àÄ {Œ± : Type u_1} (p : (a : Œ±) ‚Üí Prop) [inst : DecidablePred p] {s : Finset Œ±},\n  Finset.map (Function.Embedding.subtype p) (Finset.subtype p s) = Finset.filter p s","name":"Finset.subtype_map","isProp":true,"docString":"`s.subtype p` converts back to `s.filter p` with\n`Embedding.subtype`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyCompactSpace Œ±] {x : Œ±} {U : Set Œ±} (hU : IsOpen U)\n  (hx : x ‚àà U), ‚àÉ (K : Set Œ±), (IsCompact K : Prop) ‚àß ((x ‚àà interior K : Prop) ‚àß (K ‚äÜ U : Prop) : Prop)","name":"exists_compact_subset","isProp":true,"docString":"A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} {c : Œ±} [inst : Mul Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±]\n  [inst_3 : PosMulMonoRev Œ±] (bc : a * b ‚â§ a * c) (a0 : 0 < a), b ‚â§ c","name":"le_of_mul_le_mul_of_pos_left","isProp":true,"docString":"**Alias** of `le_of_mul_le_mul_left`."},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] (S : AddSubmonoid M) (m : Multiset M) (hm : ‚àÄ (a : M) (a_1 : a ‚àà m), a ‚àà S),\n  Multiset.sum m ‚àà S","name":"AddSubmonoid.multiset_sum_mem","isProp":true,"docString":"Sum of a multiset of elements in an `AddSubmonoid` of an `AddCommMonoid` is\nin the `AddSubmonoid`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Finite Œ±] {f : (a : Œ±) ‚Üí Œ±} (a : Function.Surjective f), Function.Bijective f","name":"Function.Surjective.bijective_of_finite","isProp":true,"docString":"**Alias** of the forward direction of `Finite.surjective_iff_bijective`."},{"type":"‚àÄ {ùïú : Type u_2} {Œ± : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : DecidableEq Œ±] [inst_2 : Fintype Œ±]\n  {ùíú : Finset (Finset Œ±)} {r : ‚Ñï} (hr : r ‚â† 0) (hùíú : Set.Sized r ‚Üëùíú),\n  ‚Üë(Finset.card ùíú) / ‚Üë(Nat.choose (Fintype.card Œ±) r) ‚â§\n    ‚Üë(Finset.card (Finset.shadow ùíú)) / ‚Üë(Nat.choose (Fintype.card Œ±) (r - 1))","name":"Finset.card_div_choose_le_card_shadow_div_choose","isProp":true,"docString":"The downward **local LYM inequality**. `ùíú` takes up less of `Œ±^(r)` (the finsets of card `r`)\nthan `‚àÇùíú` takes up of `Œ±^(r - 1)`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : PseudoMetricSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (a : Isometry f) (x : Œ±) (y : Œ±), nndist (f x) (f y) = nndist x y","name":"Isometry.nndist_eq","isProp":true,"docString":"An isometry preserves non-negative distances. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddCommGroup Œ±] [inst_1 : UniformSpace Œ±] [inst_2 : CompleteSpace Œ±]\n  {f : (a : Œ≤) ‚Üí Œ±}, (Summable f : Prop) ‚Üî (CauchySeq fun (s : Finset Œ≤) ‚Ü¶ Finset.sum s fun (b : Œ≤) ‚Ü¶ f b : Prop)","name":"summable_iff_cauchySeq_finset","isProp":true,"docString":"The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u‚ÇÇ}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : (a : C) ‚Üí D}\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] {X : C} {Y : C} {X' : C} {Y' : C}\n  (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y'),\n  (CategoryTheory.map F f ‚äó CategoryTheory.map F g) ‚â´ CategoryTheory.LaxMonoidal.Œº Y Y' =\n    CategoryTheory.LaxMonoidal.Œº X X' ‚â´ CategoryTheory.map F (f ‚äó g)","name":"CategoryTheory.LaxMonoidal.Œº_natural","isProp":true,"docString":"natuality "},{"type":"‚àÄ {x : ZFSet} (a : ZFSet.IsTransitive x), ‚ãÉ‚ÇÄ x ‚äÜ x","name":"ZFSet.IsTransitive.union‚Çõ_subset","isProp":true,"docString":"**Alias** of the forward direction of `ZFSet.isTransitive_iff_union‚Çõ_subset`."},{"type":"‚àÄ {Œ± : Type u_1} [self : OmegaCompletePartialOrder Œ±] (c : OmegaCompletePartialOrder.Chain Œ±) (i : ‚Ñï),\n  ‚Üëc i ‚â§ OmegaCompletePartialOrder.œâSup c","name":"OmegaCompletePartialOrder.le_œâSup","isProp":true,"docString":"`œâSup` is an upper bound of the increasing sequence "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {s : Set M} (hs : IsAddSubmonoid s) {l : List M}\n  (a : ‚àÄ (x : M) (a : x ‚àà l), x ‚àà s), List.sum l ‚àà s","name":"IsAddSubmonoid.list_sum_mem","isProp":true,"docString":"The sum of a list of elements of an `AddSubmonoid` is an element of the `AddSubmonoid`."},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (q : (i : Fin (n + 1)) ‚Üí Œ± i), Fin.snoc (Fin.init q) (q (Fin.last n)) = q","name":"Fin.snoc_init_self","isProp":true,"docString":"Concatenating the first element of a tuple with its tail gives back the original tuple "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.IsCofiltered C] (O : Finset C),\n  ‚àÉ (S : C), ‚àÄ {X : C} (a : X ‚àà O), Nonempty (S ‚ü∂ X)","name":"CategoryTheory.IsCofiltered.inf_objs_exists","isProp":true,"docString":"Any finite collection of objects in a cofiltered category has an object \"to the left\".\n"},{"type":"‚àÄ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] {K : Type u_3} [inst_2 : Field K] {L : Type u_2}\n  [inst_3 : Field L] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {g : A ‚Üí+* L} (hg : Function.Injective ‚Üëg)\n  (x : A) (y : { x : A // x ‚àà nonZeroDivisors A }), ‚Üë(IsFractionRing.lift hg) (IsLocalization.mk' K x y) = ‚Üëg x / ‚Üëg ‚Üëy","name":"IsFractionRing.lift_mk'","isProp":true,"docString":"Given an integral domain `A` with field of fractions `K`,\nand an injective ring hom `g : A ‚Üí+* L` where `L` is a field,\nfield hom induced from `K` to `L` maps `f x / f y` to `g x / g y` for all\n`x : A, y ‚àà NonZeroDivisors A`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] {f : R ‚Üí+* S} {p : Polynomial S} (n : ‚Ñï)\n  (h : p ‚àà Polynomial.lifts f), Polynomial.erase n p ‚àà Polynomial.lifts f","name":"Polynomial.erase_mem_lifts","isProp":true,"docString":"If `p` lifts then `p.erase n` lifts. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonAssocRing Œ±]\n  [inst_1 : OrderedSemiring Œ≤] [self : MulRingSeminormClass F Œ± Œ≤] (f : F), ‚Üëf 1 = 1","name":"MulRingSeminormClass.map_one","isProp":true,"docString":"The proposition that the function preserves 1 "},{"type":"‚àÄ {n : Type u_1} {ùïú : Type u_2} [inst : Field ùïú] [inst_1 : DecidableEq n] [inst_2 : Fintype n]\n  (P : (a : Matrix n n ùïú) ‚Üí Prop) (M : Matrix n n ùïú)\n  (hdiag : ‚àÄ (D : (a : n) ‚Üí ùïú) (a : Matrix.det (Matrix.diagonal D) = Matrix.det M), P (Matrix.diagonal D))\n  (htransvec : ‚àÄ (t : Matrix.TransvectionStruct n ùïú), P (Matrix.TransvectionStruct.toMatrix t))\n  (hmul : ‚àÄ (A : Matrix n n ùïú) (B : Matrix n n ùïú) (a : P A) (a : P B), P (Matrix.mul A B)), P M","name":"Matrix.diagonal_transvection_induction","isProp":true,"docString":"Induction principle for matrices based on transvections: if a property is true for all diagonal\nmatrices, all transvections, and is stable under product, then it is true for all matrices. This is\nthe useful way to say that matrices are generated by diagonal matrices and transvections.\n\nWe state a slightly more general version: to prove a property for a matrix `M`, it suffices to\nassume that the diagonal matrices we consider have the same determinant as `M`. This is useful to\nobtain similar principles for `SL‚Çô` or `GL‚Çô`. "},{"type":"‚àÄ {V : Type u} {V' : Type v} {G : SimpleGraph V} {G' : SimpleGraph V'} {f : G ‚Üíg G'} {u : V}\n  {p : SimpleGraph.Walk G u u} (hinj : Function.Injective ‚Üëf) (a : SimpleGraph.Walk.IsCycle p),\n  SimpleGraph.Walk.IsCycle (SimpleGraph.Walk.map f p)","name":"SimpleGraph.Walk.map_isCycle_of_injective","isProp":true,"docString":"**Alias** of the reverse direction of `SimpleGraph.Walk.map_isCycle_iff_of_injective`."},{"type":"‚àÄ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {X : C} (p : X ‚ü∂ X)\n  (hp : p ‚â´ p = p), (ùüô X - p) ‚â´ (ùüô X - p) = ùüô X - p","name":"CategoryTheory.Idempotents.idem_of_id_sub_idem","isProp":true,"docString":"In a preadditive category, when `p : X ‚ü∂ X` is idempotent,\nthen `ùüô X - p` is also idempotent. "},{"type":"‚àÄ {Œ± : Type u_1} {s : Set Œ±} (hs : s ‚â† Set.univ) {f : (a : Œ±) ‚Üí ‚Üës} (hf : Function.Injective f), Infinite Œ±","name":"Infinite.of_injective_to_set","isProp":true,"docString":"If `s : Set Œ±` is a proper subset of `Œ±` and `f : Œ± ‚Üí s` is injective, then `Œ±` is infinite. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} [inst_4 : Nontrivial k] {p : (a : Œπ) ‚Üí P} (ha : AffineIndependent k p),\n  Function.Injective p","name":"AffineIndependent.injective","isProp":true,"docString":"An affinely independent family is injective, if the underlying\nring is nontrivial. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ'' : Type u_2} [inst : Preorder Œπ''] {l : Filter Œ±} {s : (a : Œπ'') ‚Üí Set Œ±}\n  (self : Filter.HasAntitoneBasis l s), Antitone s","name":"Filter.HasAntitoneBasis.antitone","isProp":true,"docString":"The sequence of sets is antitone. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : btw a b c), btw b c a","name":"CircularPreorder.btw_cyclic_left","isProp":true,"docString":"If `b` is between `a` and `c`, then `c` is between `b` and `a`.\nThis is motivated by imagining three points on a circle. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {P : Ideal R} (hmax : ‚àÄ (m : Ideal R) (a : P < m), ¬¨(Ideal.IsMaximal m : Prop))\n  (J : Ideal R) (hPJ : P < J), J = ‚ä§","name":"Ideal.maximal_of_no_maximal","isProp":true,"docString":"If P is not properly contained in any maximal ideal then it is not properly contained\nin any proper ideal "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {n : ‚Ñ§} (hn : Odd n) (a_1 : a ‚â§ 0), a ^ n ‚â§ 0","name":"Odd.zpow_nonpos","isProp":true,"docString":"**Alias** of the reverse direction of `Odd.zpow_nonpos_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [self : FloorRing Œ±], GaloisConnection Int.cast FloorRing.floor","name":"FloorRing.gc_coe_floor","isProp":true,"docString":"`FloorRing.ceil` is the upper adjoint of the coercion `‚Üë : ‚Ñ§ ‚Üí Œ±`."},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} (h : Set.Finite s), Metric.Bounded s","name":"Set.Finite.bounded","isProp":true,"docString":"**Alias** of `Metric.bounded_of_finite`."},{"type":"‚àÄ (n : ‚Ñï),\n  (Nat.totient n * Finset.prod (List.toFinset (Nat.factors n)) fun (p : ‚Ñï) ‚Ü¶ p) =\n    n * Finset.prod (List.toFinset (Nat.factors n)) fun (p : ‚Ñï) ‚Ü¶ p - 1","name":"Nat.totient_mul_prod_factors","isProp":true,"docString":"Euler's product formula for the totient function. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : MulAction Œ± Œ≤] (x : MulAction.orbitRel.Quotient Œ± Œ≤)\n  {œÜ : (a : MulAction.orbitRel.Quotient Œ± Œ≤) ‚Üí Œ≤} (hœÜ : Function.RightInverse œÜ Quotient.mk'),\n  MulAction.orbitRel.Quotient.orbit x = MulAction.orbit Œ± (œÜ x)","name":"MulAction.orbitRel.Quotient.orbit_eq_orbit_out","isProp":true,"docString":"Note that `hœÜ = Quotient.out_eq'` is a useful choice here. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] {s : Set M} {p : (a : M) ‚Üí (a : M) ‚Üí Prop} {x : M} {y : M}\n  (hx : x ‚àà AddSubsemigroup.closure s) (hy : y ‚àà AddSubsemigroup.closure s)\n  (Hs : ‚àÄ (x : M) (a : x ‚àà s) (y : M) (a : y ‚àà s), p x y)\n  (Hmul_left : ‚àÄ (x : M) (y : M) (z : M) (a : p x z) (a : p y z), p (x + y) z)\n  (Hmul_right : ‚àÄ (x : M) (y : M) (z : M) (a : p z x) (a : p z y), p z (x + y)), p x y","name":"AddSubsemigroup.closure_induction‚ÇÇ","isProp":true,"docString":"An induction principle for additive closure membership for\npredicates with two arguments."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.SimplicialObject C) {n : ‚Ñï} {i : Fin (n + 2)},\n  CategoryTheory.SimplicialObject.Œ¥ X (‚ÜëFin.castSucc i) ‚â´ CategoryTheory.SimplicialObject.Œ¥ X i =\n    CategoryTheory.SimplicialObject.Œ¥ X (Fin.succ i) ‚â´ CategoryTheory.SimplicialObject.Œ¥ X i","name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥_self","isProp":true,"docString":"The special case of the first simplicial identity "},{"type":"‚àÄ {Œ± : Type u} (L : List Œ±) {i : ‚Ñï} {j : ‚Ñï} (h : i + j < List.length L),\n  List.get L { val := i + j, isLt := h } =\n    List.get (List.drop i L)\n      { val := j,\n        isLt :=\n          (let_fun A : i < List.length L :=\n              ((lt_of_le_of_lt ((Nat.le.intro ((rfl=:i + j = i + j)=:i + j = i + j)=:i ‚â§ i + j)=:i ‚â§ i + j)\n                    h=:i < List.length L)=:i < List.length L);\n            ((Eq.mp\n                  ((Eq.trans\n                        ((congrArg (LT.lt (i + j))\n                              ((Eq.trans\n                                    ((List.length_append (List.take i L)\n                                          (List.drop i\n                                            L)=:List.length (List.take i L ++ List.drop i L) =\n                                          List.length (List.take i L) +\n                                            List.length\n                                              (List.drop i\n                                                L))=:List.length (List.take i L ++ List.drop i L) =\n                                        List.length (List.take i L) + List.length (List.drop i L))\n                                    ((congrFun\n                                          ((congrArg HAdd.hAdd\n                                                ((Eq.trans\n                                                      ((List.length_take i\n                                                            L=:List.length (List.take i L) =\n                                                            min i\n                                                              (List.length\n                                                                L))=:List.length (List.take i L) =\n                                                          min i (List.length L))\n                                                      ((min_eq_left\n                                                            ((of_eq_true\n                                                                  ((eq_true\n                                                                        ((le_of_lt\n                                                                              A=:i ‚â§\n                                                                              List.length\n                                                                                L)=:i ‚â§\n                                                                            List.length\n                                                                              L)=:(i ‚â§ List.length L : Prop) =\n                                                                        (True :\n                                                                          Prop))=:(i ‚â§ List.length L : Prop) =\n                                                                      (True :\n                                                                        Prop))=:i ‚â§\n                                                                  List.length\n                                                                    L)=:i ‚â§\n                                                                List.length\n                                                                  L)=:min i (List.length L) =\n                                                            i)=:min i (List.length L) =\n                                                          i)=:List.length (List.take i L) =\n                                                      i)=:List.length (List.take i L) =\n                                                    i)=:HAdd.hAdd (List.length (List.take i L)) =\n                                                HAdd.hAdd i)=:HAdd.hAdd (List.length (List.take i L)) = HAdd.hAdd i)\n                                          (List.length\n                                            (List.drop i\n                                              L))=:List.length (List.take i L) + List.length (List.drop i L) =\n                                          i +\n                                            List.length\n                                              (List.drop i\n                                                L))=:List.length (List.take i L) + List.length (List.drop i L) =\n                                        i +\n                                          List.length\n                                            (List.drop i\n                                              L))=:List.length (List.take i L ++ List.drop i L) =\n                                    i +\n                                      List.length\n                                        (List.drop i\n                                          L))=:List.length (List.take i L ++ List.drop i L) =\n                                  i +\n                                    List.length\n                                      (List.drop i\n                                        L))=:(i + j < List.length (List.take i L ++ List.drop i L) : Prop) =\n                              (i + j < i + List.length (List.drop i L) :\n                                Prop))=:(i + j < List.length (List.take i L ++ List.drop i L) : Prop) =\n                            (i + j < i + List.length (List.drop i L) : Prop))\n                        ((Mathlib.Data.List.Basic._auxLemma.45\n                              i=:(i + j < i + List.length (List.drop i L) : Prop) =\n                              (j < List.length (List.drop i L) :\n                                Prop))=:(i + j < i + List.length (List.drop i L) : Prop) =\n                            (j < List.length (List.drop i L) :\n                              Prop))=:(i + j < List.length (List.take i L ++ List.drop i L) : Prop) =\n                        (j < List.length (List.drop i L) :\n                          Prop))=:(i + j < List.length (List.take i L ++ List.drop i L) : Prop) =\n                      (j < List.length (List.drop i L) : Prop))\n                  ((Eq.mp\n                        ((Eq.ndrec\n                              ((Eq.refl\n                                    (i + j < List.length L :\n                                      Prop)=:(i + j < List.length L : Prop) =\n                                    (i + j < List.length L :\n                                      Prop))=:(i + j < List.length L : Prop) = (i + j < List.length L : Prop))\n                              ((Eq.symm\n                                    ((List.take_append_drop i\n                                          L=:List.take i L ++ List.drop i L =\n                                          L)=:List.take i L ++ List.drop i L =\n                                        L)=:L =\n                                    List.take i L ++\n                                      List.drop i\n                                        L)=:L =\n                                  List.take i L ++\n                                    List.drop i\n                                      L)=:(i + j < List.length L : Prop) =\n                              (i + j < List.length (List.take i L ++ List.drop i L) :\n                                Prop))=:(i + j < List.length L : Prop) =\n                            (i + j < List.length (List.take i L ++ List.drop i L) : Prop))\n                        h=:i + j <\n                        List.length\n                          (List.take i L ++\n                            List.drop i\n                              L))=:i + j <\n                      List.length\n                        (List.take i L ++\n                          List.drop i\n                            L))=:j <\n                  List.length (List.drop i L))=:j < List.length (List.drop i L))=:j < List.length (List.drop i L)) }","name":"List.get_drop","isProp":true,"docString":"The `i + j`-th element of a list coincides with the `j`-th element of the list obtained by\ndropping the first `i` elements. Version designed to rewrite from the big list to the small list. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} (a : t ‚äÜ s), Disjoint (s·∂ú) t","name":"HasSubset.Subset.disjoint_compl_left","isProp":true,"docString":"**Alias** of the reverse direction of `Set.disjoint_compl_left_iff_subset`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]\n  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Monotone f)\n  [inst_4 : TopologicalSpace Œ±] [inst : OrderTopology Œ±] [inst : TopologicalSpace.SecondCountableTopology Œ≤],\n  Set.Countable (setOf fun (x : Œ±) ‚Ü¶ ¬¨(ContinuousAt f x : Prop))","name":"Monotone.countable_not_continuousAt","isProp":true,"docString":"In a second countable space, the set of points where a monotone function is not continuous\nis at most countable. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C] {P : C} {Q : C}\n  (f : P ‚ü∂ Q), CategoryTheory.Abelian.factorThruImage f ‚â´ CategoryTheory.Abelian.image.Œπ f = f","name":"CategoryTheory.Abelian.image.fac","isProp":true,"docString":"`f` factors through its image via the canonical morphism `p`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {P : C} {Q : C}\n  [self : CategoryTheory.Limits.HasBinaryBiproduct P Q], Nonempty (CategoryTheory.Limits.BinaryBiproductData P Q)","name":"CategoryTheory.Limits.HasBinaryBiproduct.exists_binary_biproduct","isProp":true,"docString":"`HasBinaryBiproduct P Q` expresses the mere existence of a bicone which is\nsimultaneously a limit and a colimit of the diagram `pair P Q`.\n"},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] (s : Set R),\n  ‚Üë(Subsemiring.closure s) = ‚Üë(AddSubmonoid.closure ‚Üë(Submonoid.closure s))","name":"Subsemiring.coe_closure_eq","isProp":true,"docString":"The elements of the subsemiring closure of `M` are exactly the elements of the additive closure\nof a multiplicative submonoid `M`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} [inst_1 : TopologicalSpace.SecondCountableTopology Œ±]\n  (hclosed : IsClosed C) (hunc : ¬¨(Set.Countable C : Prop)),\n  ‚àÉ (D : Set Œ±), (Perfect D : Prop) ‚àß ((Set.Nonempty D : Prop) ‚àß (D ‚äÜ C : Prop) : Prop)","name":"exists_perfect_nonempty_of_isClosed_of_not_countable","isProp":true,"docString":"Any uncountable closed set in a second countable space contains a nonempty perfect subset."},{"type":"‚àÄ {Œ± : Sort u_1} {p : (a : Œ±) ‚Üí Prop} (P : ‚àÉ (a : Œ±), p a), p (Exists.choose P)","name":"Exists.choose_spec","isProp":true,"docString":"Show that an element extracted from `P : ‚àÉ a, p a` using `P.choose` satisfies `p`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] (C : ENNReal) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu : ‚àÄ (n : ‚Ñï), edist (f n) (f (n + 1)) ‚â§ C / 2 ^ n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a)),\n  edist (f 0) a ‚â§ 2 * C","name":"edist_le_of_edist_le_geometric_two_of_tendsto‚ÇÄ","isProp":true,"docString":"If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `2 * C`. "},{"type":"‚àÄ {ùïú : Type u_3} {ùïù : Type u_1} {E : Type u_2} [inst : NormedField ùïú] [inst_1 : NormedRing ùïù] [inst_2 : NormedSpace ùïú ùïù]\n  [inst_3 : AddCommGroup E] [inst_4 : Module ùïú E] [inst_5 : SMulWithZero ùïù E] [inst_6 : IsScalarTower ùïú ùïù E] {s : Set E}\n  (hs : Balanced ùïù s) {a : ùïù} {b : ùïú} (h : ‚Äña‚Äñ ‚â§ ‚Äñb‚Äñ), a ‚Ä¢ s ‚äÜ b ‚Ä¢ s","name":"Balanced.smul_mono","isProp":true,"docString":"Scalar multiplication (by possibly different types) of a balanced set is monotone. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±}\n  (a_1 : IsMinOn (‚ÜëOrderDual.toDual ‚àò f) s a), IsMaxOn f s a","name":"IsMinOn.undual","isProp":true,"docString":"**Alias** of the forward direction of `isMinOn_dual_iff`."},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (p‚ÇÅ : P) (p‚ÇÇ : P), p‚ÇÇ -·µ• p‚ÇÅ ‚àà vectorSpan k {p‚ÇÅ, p‚ÇÇ}","name":"vsub_rev_mem_vectorSpan_pair","isProp":true,"docString":"The difference between two points (reversed) lies in their `vectorSpan`. "},{"type":"‚àÄ {L : Type v} [self : LieRing L] (x : L) (y : L) (z : L), ‚ÅÖx, y + z‚ÅÜ = ‚ÅÖx, y‚ÅÜ + ‚ÅÖx, z‚ÅÜ","name":"LieRing.lie_add","isProp":true,"docString":"A Lie ring bracket is additive in its second component. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : Fintype Œ±] [inst_1 : DecidableEq Œ±] [inst_2 : Nonempty Œ±] (s : Finset Œπ)\n  (f : (a : Œπ) ‚Üí Finset (Finset Œ±)) (hf : ‚àÄ (i : Œπ) (a : i ‚àà s), Set.Intersecting ‚Üë(f i)),\n  Finset.card (Finset.bunion·µ¢ s f) ‚â§ 2 ^ Fintype.card Œ± - 2 ^ (Fintype.card Œ± - Finset.card s)","name":"Finset.card_bunion·µ¢_le_of_intersecting","isProp":true,"docString":"**Kleitman's theorem**. An intersecting family on `n` elements contains at most `2‚Åø‚Åª¬π` sets, and\neach further intersecting family takes at most half of the sets that are in no previous family. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsPreconnected J] {Œ± : Type u‚ÇÅ}\n  (F : (a : J) ‚Üí Œ±) (h : ‚àÄ (j‚ÇÅ : J) (j‚ÇÇ : J) (x : j‚ÇÅ ‚ü∂ j‚ÇÇ), F j‚ÇÅ = F j‚ÇÇ) (j : J) (j' : J), F j = F j'","name":"CategoryTheory.constant_of_preserves_morphisms","isProp":true,"docString":"If `J` is connected, then given any function `F` such that the presence of a\nmorphism `j‚ÇÅ ‚ü∂ j‚ÇÇ` implies `F j‚ÇÅ = F j‚ÇÇ`, we have that `F` is constant.\nThis can be thought of as a local-to-global property.\n\nThe converse is shown in `IsConnected.of_constant_of_preserves_morphisms`\n"},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] {c : AddCon M}, ‚Üë0 = 0","name":"AddCon.coe_zero","isProp":true,"docString":"The 0 of the quotient of an `AddMonoid` by an additive congruence\nrelation is the equivalence class of the `AddMonoid`'s 0."},{"type":"‚àÄ (R : Type u) [inst : Semiring R] {Œπ : Type v} [dec_Œπ : DecidableEq Œπ] {M : (a : Œπ) ‚Üí Type w}\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_2 : (i : Œπ) ‚Üí Module R (M i)] (i : Œπ) (c : R) (x : M i),\n  ‚Üë(DirectSum.of M i) (c ‚Ä¢ x) = c ‚Ä¢ ‚Üë(DirectSum.of M i) x","name":"DirectSum.of_smul","isProp":true,"docString":"Scalar multiplication commutes with the inclusion of each component into the direct sum. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoEMetricSpace Œ±] (C : ENNReal) {f : (a : ‚Ñï) ‚Üí Œ±}\n  (hu : ‚àÄ (n : ‚Ñï), edist (f n) (f (n + 1)) ‚â§ C / 2 ^ n) {a : Œ±} (ha : Filter.Tendsto f Filter.atTop (nhds a)) (n : ‚Ñï),\n  edist (f n) a ‚â§ 2 * C / 2 ^ n","name":"edist_le_of_edist_le_geometric_two_of_tendsto","isProp":true,"docString":"If `edist (f n) (f (n+1))` is bounded by `C * 2^-n`, then the distance from\n`f n` to the limit of `f` is bounded above by `2 * C * 2^-n`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] {Œ¥‚ÇÅ : ‚Ñù} {Œ¥‚ÇÇ : ‚Ñù} (hle : Œ¥‚ÇÅ ‚â§ Œ¥‚ÇÇ) (E : Set Œ±),\n  Metric.cthickening Œ¥‚ÇÅ E ‚äÜ Metric.cthickening Œ¥‚ÇÇ E","name":"Metric.cthickening_mono","isProp":true,"docString":"The closed thickening `Metric.cthickening Œ¥ E` of a fixed subset `E` is an increasing function\nof the thickening radius `Œ¥`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : BoundedOrder Œ±] [self : ComplementedLattice Œ±] (a : Œ±),\n  ‚àÉ (b : Œ±), IsCompl a b","name":"ComplementedLattice.exists_isCompl","isProp":true,"docString":"In a `ComplementedLattice`, every element admits a complement. "},{"type":"‚àÄ {Œπ : Type u_1} {I : BoxIntegral.Box Œπ} [inst : Finite Œπ] {œÄ‚ÇÅ : BoxIntegral.Prepartition I}\n  {œÄ‚ÇÇ : BoxIntegral.Prepartition I} (h : BoxIntegral.Prepartition.union·µ¢ œÄ‚ÇÅ = BoxIntegral.Prepartition.union·µ¢ œÄ‚ÇÇ),\n  BoxIntegral.Prepartition.compl œÄ‚ÇÅ = BoxIntegral.Prepartition.compl œÄ‚ÇÇ","name":"BoxIntegral.Prepartition.compl_congr","isProp":true,"docString":"Since the definition of `BoxIntegral.Prepartition.compl` uses `Exists.choose`,\nthe result depends only on `œÄ.union·µ¢`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {s : Set Œ±} (h : IsOpen s), IsGŒ¥ s","name":"IsOpen.isGŒ¥","isProp":true,"docString":"An open set is a GŒ¥ set. "},{"type":"‚àÄ {Œ± : Type u_1} (L : List Œ±) {i : ‚Ñï} (hi : i < List.length L), List.drop i (List.take (i + 1) L) = [List.nthLe L i hi]","name":"List.drop_take_succ_eq_cons_nthLe","isProp":true,"docString":"Taking only the first `i+1` elements in a list, and then dropping the first `i` ones, one is\nleft with a list of length `1` made of the `i`-th element of the original list. "},{"type":"‚àÄ {m : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : DecidableEq m]\n  [inst_3 : Fintype m] {R : Type v} [inst_4 : CommRing R] (e : n ‚âÉ m) (A : Matrix m m R),\n  Matrix.det (Matrix.submatrix A ‚Üëe ‚Üëe) = Matrix.det A","name":"Matrix.det_submatrix_equiv_self","isProp":true,"docString":"Permuting rows and columns with the same equivalence has no effect. "},{"type":"‚àÄ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ‚âÉ* H) (x : G), ‚Üëh x‚Åª¬π = (‚Üëh x)‚Åª¬π","name":"MulEquiv.map_inv","isProp":true,"docString":"A multiplicative equivalence of groups preserves inversion. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : (a : C) ‚Üí D}\n  [self : CategoryTheory.Functorial F] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z),\n  CategoryTheory.Functorial.map' (f ‚â´ g) = CategoryTheory.Functorial.map' f ‚â´ CategoryTheory.Functorial.map' g","name":"CategoryTheory.Functorial.map_comp'","isProp":true,"docString":"A functorial map preserves composition of morphisms. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú)\n  (hM : M (Sum.inr ()) (Sum.inr ()) ‚â† 0) (i : Fin r),\n  Matrix.mul M (List.prod (Matrix.Pivot.listTransvecRow M)) (Sum.inr ()) (Sum.inl i) = 0","name":"Matrix.Pivot.mul_listTransvecRow_last_row","isProp":true,"docString":"Multiplying by all the matrices in `listTransvecRow M` kills all the coefficients in the\nlast row but the last one. "},{"type":"‚àÄ {Œ± : Sort u_1} (a : Œ±), id a = a","name":"id_eq","isProp":true,"docString":"`id x = x`, as a `@[simp]` lemma. "},{"type":"‚àÄ (b : ‚Ñï) (m : ‚Ñï) (hm : m ‚â† 0), (b + 2) ^ List.length (Nat.digits (b + 2) m) ‚â§ (b + 2) * m","name":"Nat.base_pow_length_digits_le'","isProp":true,"docString":"Any non-zero natural number `m` is greater than\n(b+2)^((number of digits in the base (b+2) representation of m) - 1)\n"},{"type":"‚àÄ {n : ‚Ñï} {i : Fin (n + 1)}, SimplexCategory.Œ¥ (Fin.succ i) ‚â´ SimplexCategory.œÉ i = ùüô (SimplexCategory.mk n)","name":"SimplexCategory.Œ¥_comp_œÉ_succ","isProp":true,"docString":"The second part of the third simplicial identity "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), 0 ‚àà S","name":"AddSubmonoid.zero_mem","isProp":true,"docString":"An `AddSubmonoid` contains the monoid's 0."},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {N : Type u_3} [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {x : M} {y : M} (e : M ‚âÉ‚Çó[R] N),\n  (SameRay R (‚Üëe x) (‚Üëe y) : Prop) ‚Üî (SameRay R x y : Prop)","name":"SameRay.sameRay_map_iff","isProp":true,"docString":"The images of two vectors under a linear equivalence are on the same ray if and only if the\noriginal vectors are on the same ray. "},{"type":"‚àÄ {Œ± : Type u} {m : ‚Ñï} {n : ‚Ñï} {f : (a : Fin m) ‚Üí Œ±} {g : (a : Fin n) ‚Üí Œ±},\n  (List.ofFn f = List.ofFn g : Prop) ‚Üî ({ fst := m, snd := f } = { fst := n, snd := g } : Prop)","name":"List.ofFn_inj'","isProp":true,"docString":"`Fin.sigma_eq_iff_eq_comp_cast` may be useful to work with the RHS of this expression. "},{"type":"‚àÄ {V : Type u} [inst : CategoryTheory.Category V] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms V] {A : V} {B : V}\n  {C : V} (g : B ‚ü∂ C) [inst_2 : CategoryTheory.Limits.HasKernels V] [inst_3 : CategoryTheory.Limits.HasZeroObject V]\n  [inst_4 : CategoryTheory.Mono g],\n  CategoryTheory.Epi\n    (imageToKernel 0 g\n      ((of_eq_true\n            ((Eq.trans\n                  ((congrFun\n                        ((congrArg Eq\n                              ((CategoryTheory.Limits.zero_comp=:0 ‚â´ g =\n                                    0)=:0 ‚â´ g = 0)=:Eq (0 ‚â´ g) = Eq 0)=:Eq (0 ‚â´ g) = Eq 0)\n                        0=:(0 ‚â´ g = 0 : Prop) = (0 = 0 : Prop))=:(0 ‚â´ g = 0 : Prop) = (0 = 0 : Prop))\n                  ((eq_self\n                        0=:(0 = 0 : Prop) =\n                        (True :\n                          Prop))=:(0 = 0 : Prop) =\n                      (True :\n                        Prop))=:(0 ‚â´ g = 0 : Prop) =\n                  (True : Prop))=:(0 ‚â´ g = 0 : Prop) = (True : Prop))=:0 ‚â´ g = 0)=:0 ‚â´ g = 0))","name":"imageToKernel_epi_of_zero_of_mono","isProp":true,"docString":"`imageToKernel` for `A --0--> B --g--> C`, where `g` is a mono is itself an epi\n(i.e. the sequence is exact at `B`).\n"},{"type":"‚àÄ {R : Type u_1} {a : R} [inst : Monoid R] (n : ‚Ñï) (rla : IsLeftRegular a), IsLeftRegular (a ^ n)","name":"IsLeftRegular.pow","isProp":true,"docString":"Any power of a left-regular element is left-regular. "},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] (a : RÀ£), IsRegular ‚Üëa","name":"Units.isRegular","isProp":true,"docString":"If `R` is a monoid, an element in `RÀ£` is regular. "},{"type":"‚àÄ {Œ± : Type u_2} {M : Type u_3} {N : Type u_1} [inst : CommMonoid M] [inst_1 : One N] (f : (a : Œ±) ‚Üí N)\n  (g : (a : Œ±) ‚Üí (a : N) ‚Üí M) {s : Finset Œ±} {t : Finset Œ±} (h : s ‚äÜ t) (hg : ‚àÄ (a : Œ±), g a 1 = 1),\n  (Finset.prod s fun (i : Œ±) ‚Ü¶ g i (f i)) = Finset.prod t fun (i : Œ±) ‚Ü¶ g i (Set.mulIndicator (‚Üës) f i)","name":"Set.prod_mulIndicator_subset_of_eq_one","isProp":true,"docString":"Consider a product of `g i (f i)` over a `Finset`.  Suppose `g` is a\nfunction such as `Pow`, which maps a second argument of `1` to\n`1`. Then if `f` is replaced by the corresponding multiplicative indicator\nfunction, the `Finset` may be replaced by a possibly larger `Finset`\nwithout changing the value of the sum. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedField Œ±] (n : ‚Ñï) (a : Œ±),\n  LinearOrderedField.zpow (Int.negSucc n) a = (LinearOrderedField.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"LinearOrderedField.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  {s : Set Œ±} (hs : IsConnected s) (hb : BddBelow s) (ha : BddAbove s), Set.Ioo (inf‚Çõ s) (sup‚Çõ s) ‚äÜ s","name":"IsConnected.Ioo_cinf‚Çõ_csup‚Çõ_subset","isProp":true,"docString":"A bounded connected subset of a conditionally complete linear order includes the open interval\n`(Inf s, Sup s)`. "},{"type":"‚àÄ {b : Ordinal} {x : Ordinal} {c : Ordinal} (hb : 1 < b) (hx : x ‚â† 0), (b ^ c ‚â§ x : Prop) ‚Üî (c ‚â§ Ordinal.log b x : Prop)","name":"Ordinal.opow_le_iff_le_log","isProp":true,"docString":"`opow b` and `log b` (almost) form a Galois connection. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (self : AddSubsemigroup M) {a : M} {b : M} (a_1 : a ‚àà AddSubsemigroup.carrier self)\n  (a_2 : b ‚àà AddSubsemigroup.carrier self), a + b ‚àà AddSubsemigroup.carrier self","name":"AddSubsemigroup.add_mem'","isProp":true,"docString":"The sum of two elements of an additive subsemigroup belongs to the subsemigroup. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {a : M} {x : AddUnits M} {y : AddUnits M} (h : AddSemiconjBy a ‚Üëx ‚Üëy),\n  AddSemiconjBy a ‚Üë(-x) ‚Üë(-y)","name":"AddSemiconjBy.addUnits_neg_right","isProp":true,"docString":"If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\nsemiconjugates `-x` to `-y`."},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±} {t : Set Œ±} (a : s ‚äÜ t), Disjoint s (t·∂ú)","name":"HasSubset.Subset.disjoint_compl_right","isProp":true,"docString":"**Alias** of the reverse direction of `Set.disjoint_compl_right_iff_subset`."},{"type":"‚àÄ {Œ± : Type u} [inst : AddCommGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : a + b ‚â§ c), b ‚â§ c - a","name":"le_sub_left_of_add_le","isProp":true,"docString":"**Alias** of the reverse direction of `le_sub_iff_add_le'`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : SemilatticeInf Œ±] [inst_1 : OrderTop Œ±] {P : (a : Œ±) ‚Üí Prop} {Ptop : P ‚ä§}\n  {Pinf : ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : P x) (a : P y), P (x ‚äì y)} (t : Finset Œ≤) (f : (a : Œ≤) ‚Üí { x : Œ± // P x }),\n  ‚Üë(Finset.inf t f) = Finset.inf t fun (x : Œ≤) ‚Ü¶ ‚Üë(f x)","name":"Finset.inf_coe","isProp":true,"docString":"Computing `inf` in a subtype (closed under `inf`) is the same as computing it in `Œ±`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G} (self : Subgroup.Normal H) (n : G) (a : n ‚àà H) (g : G),\n  g * n * g‚Åª¬π ‚àà H","name":"Subgroup.Normal.conj_mem","isProp":true,"docString":"`N` is closed under conjugation "},{"type":"‚àÄ {Œ± : Type u} {a : Set Œ±} (h : Set.Finite a), Set.Finite (setOf fun (b : Set Œ±) ‚Ü¶ b ‚äÜ a)","name":"Set.Finite.finite_subsets","isProp":true,"docString":"There are finitely many subsets of a given finite set "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  {a : Œ±} {b : Œ±} {s : Set Œ±} (hs : IsClosed (s ‚à© Set.Icc a b)) (ha : a ‚àà s)\n  (hgt : ‚àÄ (x : Œ±) (a : x ‚àà s ‚à© Set.Ico a b) (y : Œ±) (a : y ‚àà Set.Ioi x), Set.Nonempty (s ‚à© Set.Ioc x y)),\n  Set.Icc a b ‚äÜ s","name":"IsClosed.Icc_subset_of_forall_exists_gt","isProp":true,"docString":"A \"continuous induction principle\" for a closed interval: if a set `s` meets `[a, b]`\non a closed subset, contains `a`, and for any `a ‚â§ x < y ‚â§ b`, `x ‚àà s`, the set `s ‚à© (x, y]`\nis not empty, then `[a, b] ‚äÜ s`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F'' : Type u_3} [inst : Norm E] [inst_1 : NormedAddCommGroup F''] {f : (a : Œ±) ‚Üí E}\n  {g'' : (a : Œ±) ‚Üí F''} (h : f =O[Filter.cofinite] g''),\n  ‚àÉ (C : ‚Ñù), (C > 0 : Prop) ‚àß (‚àÄ ‚¶Éx : Œ±‚¶Ñ (a : g'' x ‚â† 0), ‚Äñf x‚Äñ ‚â§ C * ‚Äñg'' x‚Äñ : Prop)","name":"Asymptotics.bound_of_isBigO_cofinite","isProp":true,"docString":"If `f x = O(g x)` along `cofinite`, then there exists a positive constant `C` such that\n`‚Äñf x‚Äñ ‚â§ C * ‚Äñg x‚Äñ` whenever `g x ‚â† 0`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] [inst_2 : MulZeroOneClass Œ±]\n  [inst_3 : MulZeroOneClass Œ≤] (self : Œ± ‚Üí*‚ÇÄo Œ≤),\n  Monotone (ZeroHom.toFun ‚Üë(OrderMonoidWithZeroHom.toMonoidWithZeroHom self))","name":"OrderMonoidWithZeroHom.monotone'","isProp":true,"docString":"An `OrderMonoidWithZeroHom` is a monotone function. "},{"type":"‚àÄ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (f : A ‚Üí‚Çê[R] B) [inst_5 : IsNoetherianRing A],\n  IsNoetherianRing { x : B // x ‚àà AlgHom.range f }","name":"AlgHom.isNoetherianRing_range","isProp":true,"docString":"The image of a Noetherian R-algebra under an R-algebra map is a Noetherian ring. "},{"type":"‚àÄ {p : ‚Ñï} [hp : Fact (Nat.Prime p : Prop)] {q : ‚Ñö} {r : ‚Ñö}, padicNorm p (q - r) ‚â§ max (padicNorm p q) (padicNorm p r)","name":"padicNorm.sub","isProp":true,"docString":"The `p`-adic norm of a difference is at most the max of each component. Restates the archimedean\nproperty of the `p`-adic norm. "},{"type":"‚àÄ {Œπ‚ÇÅ : Type u_9} {Œπ‚ÇÇ : Type u_8} {R : Type u_1} {R‚ÇÇ : Type u_2} {S : Type u_6} {S‚ÇÇ : Type u_7} {M : Type u_3}\n  {N : Type u_5} {P : Type u_4} [inst : CommSemiring R] [inst_1 : CommSemiring S] [inst_2 : CommSemiring R‚ÇÇ]\n  [inst_3 : CommSemiring S‚ÇÇ] [inst_4 : AddCommMonoid M] [inst_5 : AddCommMonoid N] [inst_6 : AddCommMonoid P]\n  [inst_7 : Module R M] [inst_8 : Module S N] [inst_9 : Module R‚ÇÇ P] [inst_10 : Module S‚ÇÇ P]\n  [inst_11 : SMulCommClass S‚ÇÇ R‚ÇÇ P] {œÅ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {œÉ‚ÇÅ‚ÇÇ : S ‚Üí+* S‚ÇÇ} (b‚ÇÅ : Basis Œπ‚ÇÅ R M) (b‚ÇÇ : Basis Œπ‚ÇÇ S N)\n  {B : M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P} {B' : M ‚Üí‚Çõ‚Çó[œÅ‚ÇÅ‚ÇÇ] N ‚Üí‚Çõ‚Çó[œÉ‚ÇÅ‚ÇÇ] P}\n  (h : ‚àÄ (i : Œπ‚ÇÅ) (j : Œπ‚ÇÇ), ‚Üë(‚ÜëB (‚Üëb‚ÇÅ i)) (‚Üëb‚ÇÇ j) = ‚Üë(‚ÜëB' (‚Üëb‚ÇÅ i)) (‚Üëb‚ÇÇ j)), B = B'","name":"LinearMap.ext_basis","isProp":true,"docString":"Two bilinear maps are equal when they are equal on all basis vectors. "},{"type":"‚àÄ {Œ± : Type u} [inst : AddGroup Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] (a : Œ±) {b : Œ±}\n  (a_1 : 0 ‚â§ b), a - b ‚â§ a","name":"sub_le_self","isProp":true,"docString":"**Alias** of the reverse direction of `sub_le_self_iff`."},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R ‚Üí+ S),\n  (‚àÄ (x : R) (y : R), ‚Üëf (x * y) = ‚Üëf x * ‚Üëf y : Prop) ‚Üî\n    (AddMonoidHom.compr‚ÇÇ AddMonoidHom.mul f = AddMonoidHom.compl‚ÇÇ (AddMonoidHom.comp AddMonoidHom.mul f) f : Prop)","name":"AddMonoidHom.map_mul_iff","isProp":true,"docString":"An `AddMonoidHom` preserves multiplication if pre- and post- composition with\n`AddMonoidHom.mul` are equivalent. By converting the statement into an equality of\n`AddMonoidHom`s, this lemma allows various specialized `ext` lemmas about `‚Üí+` to then be applied.\n"},{"type":"‚àÄ {Œ± : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : (a : n) ‚Üí Œ±} (h : Matrix.IsSymm (Matrix.circulant v)) (i : n),\n  v (-i) = v i","name":"Matrix.circulant_isSymm_apply","isProp":true,"docString":"If `circulant v` is symmetric, `‚àÄ i j : I, v (- i) = v i`. "},{"type":"‚àÄ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R R","name":"StarSemigroup.to_starModule","isProp":true,"docString":"A commutative star monoid is a star module over itself via `Monoid.toMulAction`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M ‚Üí‚Çô* N) (s : Set M),\n  Subsemigroup.map f (Subsemigroup.closure s) = Subsemigroup.closure (‚Üëf '' s)","name":"MulHom.map_mclosure","isProp":true,"docString":"The image under a semigroup hom of the subsemigroup generated by a set equals the subsemigroup\ngenerated by the image of the set. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedLinearOrderedGroup Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx / y‚Äñ","name":"NormedLinearOrderedGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : SemilatticeSup Œ≤] {u : (a : Œ≤) ‚Üí Œ±} (hu : CauchySeq u)\n  {Œπ : Type u_1} {f : (a : Œπ) ‚Üí Œ≤} {p : Filter Œπ} [inst_2 : Filter.NeBot p] (hf : Filter.Tendsto f p Filter.atTop)\n  {a : Œ±} (ha : Filter.Tendsto (u ‚àò f) p (nhds a)), Filter.Tendsto u Filter.atTop (nhds a)","name":"tendsto_nhds_of_cauchySeq_of_subseq","isProp":true,"docString":"If a Cauchy sequence has a convergent subsequence, then it converges. "},{"type":"‚àÄ {X : Type u} {Y : Type v} [inst : Preorder X] [inst_1 : Preorder Y] (f : X ‚•§ Y),\n  Monotone (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor f))","name":"CategoryTheory.Functor.monotone","isProp":true,"docString":"A functor between preorder categories is monotone.\n"},{"type":"‚àÄ {Œ± : Type u_1} [self : ConditionallyCompleteLattice Œ±] (s : Set Œ±) (a : Œ±) (a_1 : Set.Nonempty s)\n  (a_2 : a ‚àà lowerBounds s), a ‚â§ inf‚Çõ s","name":"ConditionallyCompleteLattice.le_cinf‚Çõ","isProp":true,"docString":"`a ‚â§ inf‚Çõ s` for all `a ‚àà lowerBounds s`. "},{"type":"‚àÄ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f : F) (g : F) {x : G} (h : ‚Üëf x = ‚Üëg x), ‚Üëf x‚Åª¬π = ‚Üëg x‚Åª¬π","name":"eq_on_inv","isProp":true,"docString":"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x‚Åª¬π`. "},{"type":"‚àÄ {G : Type u_2} [inst : AddGroup G] {N : Type u_1} [inst_1 : AddGroup N] (f : G ‚Üí+ N) (hf : Function.Surjective ‚Üëf),\n  AddMonoidHom.range f = ‚ä§","name":"AddMonoidHom.range_top_of_surjective","isProp":true,"docString":"The range of a surjective `AddMonoid` homomorphism is the whole of the codomain."},{"type":"‚àÄ {J : Type v} {K : Type v} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.SmallCategory K]\n  (F : J √ó K ‚•§ Type v) [inst_2 : CategoryTheory.IsFiltered K] [inst_3 : Finite J],\n  Function.Injective (CategoryTheory.Limits.colimitLimitToLimitColimit F)","name":"CategoryTheory.Limits.colimitLimitToLimitColimit_injective","isProp":true,"docString":"This follows this proof from\n* Borceux, Handbook of categorical algebra 1, Theorem 2.13.4\n"},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±]\n  (h : TopologicalSpace.IsTopologicalBasis (setOf fun (s : Set Œ±) ‚Ü¶ IsClopen s)), TotallySeparatedSpace Œ±","name":"totallySeparatedSpace_of_t1_of_basis_clopen","isProp":true,"docString":"A T1 space with a clopen basis is totally separated. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {l : (a : Œ±) ‚Üí Œ≤} {u : (a : Œ≤) ‚Üí Œ±}\n  (self : GaloisInsertion l u) (x : Œ≤), x ‚â§ l (u x)","name":"GaloisInsertion.le_l_u","isProp":true,"docString":"Main property of a Galois insertion. "},{"type":"‚àÄ {Œ± : Type u_1} (self : MeasurableSpace Œ±) (f : (a : ‚Ñï) ‚Üí Set Œ±)\n  (a : ‚àÄ (i : ‚Ñï), MeasurableSpace.MeasurableSet' self (f i)),\n  MeasurableSpace.MeasurableSet' self (Set.union·µ¢ fun (i : ‚Ñï) ‚Ü¶ f i)","name":"MeasurableSpace.measurableSet_union·µ¢","isProp":true,"docString":"The union of a sequence of measurable sets is a measurable set. Use a more general\n`MeasurableSet.union·µ¢` instead. "},{"type":"‚àÄ {Œ± : Type u_1} [self : DivisionSemiring Œ±] (n : ‚Ñï) (a : Œ±),\n  DivisionSemiring.zpow (Int.negSucc n) a = (DivisionSemiring.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"DivisionSemiring.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommMonoid Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c * a ‚â§ c * b","name":"LinearOrderedCommMonoid.mul_le_mul_left","isProp":true,"docString":"Multiplication is monotone in an `OrderedCommMonoid`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : PredOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Monotone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ico (f (Order.pred n)) (f n))","name":"Monotone.pairwise_disjoint_on_Ico_pred","isProp":true,"docString":"If `Œ±` is a linear pred order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is a monotone function, then\nthe intervals `Set.Ico (f Order.pred n) (f n)` are pairwise disjoint. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤],\n  ContinuousMap.compactOpen =\n    inf·µ¢ fun (s : Set Œ±) ‚Ü¶\n      inf·µ¢ fun (_hs : IsCompact s) ‚Ü¶ TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen","name":"ContinuousMap.compactOpen_eq_inf‚Çõ_induced","isProp":true,"docString":"The compact-open topology on `C(Œ±, Œ≤)` is equal to the infimum of the compact-open topologies\non `C(s, Œ≤)` for `s` a compact subset of `Œ±`.  The key point of the proof is that the union of the\ncompact subsets of `Œ±` is equal to the union of compact subsets of the compact subsets of `Œ±`. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} {y : K} (a : x ‚àà s) (a : y ‚àà s), x - y ‚àà s","name":"Subfield.sub_mem","isProp":true,"docString":"A subfield is closed under subtraction. "},{"type":"‚àÄ (n : ‚Ñï), ringChar (ZMod n) = n","name":"ZMod.ringChar_zmod_n","isProp":true,"docString":"We have that `ringChar (ZMod n) = n`. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : MonovaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) * g i) = Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (MonovaryOn (f ‚àò ‚ÜëœÉ) g ‚Üës : Prop)","name":"MonovaryOn.sum_comp_perm_mul_eq_sum_mul_iff","isProp":true,"docString":"**Equality case of Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f ‚àò œÉ` and `g` monovary\ntogether. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {l : Filter Œ±} {a : Œ±} (a_1 : IsMinFilter f l a),\n  IsMaxFilter (‚ÜëOrderDual.toDual ‚àò f) l a","name":"IsMinFilter.dual","isProp":true,"docString":"**Alias** of the reverse direction of `isMaxFilter_dual_iff`."},{"type":"‚àÄ {R : Type u_2} [inst : LinearOrderedCommRing R] {M : Type u_1} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : NoZeroSMulDivisors R M] {v : M} (hv : v ‚â† 0) {r : R} (hr : r ‚â† 0),\n  (SameRay R (r ‚Ä¢ v) v : Prop) ‚Üî (0 < r : Prop)","name":"sameRay_smul_left_iff_of_ne","isProp":true,"docString":"A multiple of a nonzero vector is in the same ray as that vector if and only if that multiple\nis positive. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n  [inst_6 : Nonempty Œπ] {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (inf·µ¢ g)) (Af : Antitone f),\n  f (inf·µ¢ fun (i : Œπ) ‚Ü¶ g i) = sup·µ¢ fun (i : Œπ) ‚Ü¶ f (g i)","name":"Antitone.map_inf·µ¢_of_continuousAt'","isProp":true,"docString":"An antitone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed\ninfimum to the indexed supremum of the composition. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] (s : Set (UniformSpace.Completion Œ± √ó UniformSpace.Completion Œ±)),\n  (s ‚àà uniformity (UniformSpace.Completion Œ±) : Prop) ‚Üî\n    (‚àÉ (Œµ : ‚Ñù),\n        (Œµ > 0 : Prop) ‚àß\n          (‚àÄ {a : UniformSpace.Completion Œ±} {b : UniformSpace.Completion Œ±} (a_1 : dist a b < Œµ), (a, b) ‚àà s : Prop) :\n      Prop)","name":"UniformSpace.Completion.mem_uniformity_dist","isProp":true,"docString":"Elements of the uniformity (defined generally for completions) can be characterized in terms\nof the distance. "},{"type":"‚àÄ {Œ± : Type u} [inst : MetricSpace Œ±] {x : TopologicalSpace.NonemptyCompacts Œ±}\n  {y : TopologicalSpace.NonemptyCompacts Œ±}, dist x y = Metric.hausdorffDist ‚Üëx ‚Üëy","name":"Metric.NonemptyCompacts.dist_eq","isProp":true,"docString":"The distance on `NonemptyCompacts Œ±` is the Hausdorff distance, by construction "},{"type":"‚àÄ {Œ± : Type u} [self : OrderedSemiring Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c + a ‚â§ c + b","name":"OrderedSemiring.add_le_add_left","isProp":true,"docString":"Addition is monotone in an `OrderedAddCommMonoid`. "},{"type":"‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {s : Set A}\n  {p : (a : A) ‚Üí (a : A) ‚Üí Prop} {a : A} {b : A} (ha : a ‚àà Algebra.adjoin R s) (hb : b ‚àà Algebra.adjoin R s)\n  (Hs : ‚àÄ (x : A) (a : x ‚àà s) (y : A) (a : y ‚àà s), p x y)\n  (Halg : ‚àÄ (r‚ÇÅ : R) (r‚ÇÇ : R), p (‚Üë(algebraMap R A) r‚ÇÅ) (‚Üë(algebraMap R A) r‚ÇÇ))\n  (Halg_left : ‚àÄ (r : R) (x : A) (a : x ‚àà s), p (‚Üë(algebraMap R A) r) x)\n  (Halg_right : ‚àÄ (r : R) (x : A) (a : x ‚àà s), p x (‚Üë(algebraMap R A) r))\n  (Hadd_left : ‚àÄ (x‚ÇÅ : A) (x‚ÇÇ : A) (y : A) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ + x‚ÇÇ) y)\n  (Hadd_right : ‚àÄ (x : A) (y‚ÇÅ : A) (y‚ÇÇ : A) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ + y‚ÇÇ))\n  (Hmul_left : ‚àÄ (x‚ÇÅ : A) (x‚ÇÇ : A) (y : A) (a : p x‚ÇÅ y) (a : p x‚ÇÇ y), p (x‚ÇÅ * x‚ÇÇ) y)\n  (Hmul_right : ‚àÄ (x : A) (y‚ÇÅ : A) (y‚ÇÇ : A) (a : p x y‚ÇÅ) (a : p x y‚ÇÇ), p x (y‚ÇÅ * y‚ÇÇ)), p a b","name":"Algebra.adjoin_induction‚ÇÇ","isProp":true,"docString":"Induction principle for the algebra generated by a set `s`: show that `p x y` holds for any\n`x y ‚àà adjoin R s` given that that it holds for `x y ‚àà s` and that it satisfies a number of\nnatural properties. "},{"type":"‚àÄ {Œ≥ : Type w} [inst : LinearOrder Œ≥] {a : Œ≥} {b : Œ≥} {s : Set Œ≥} {t : Set Œ≥} (ha : IsLeast s a) (hb : IsLeast t b),\n  IsLeast (s ‚à™ t) (min a b)","name":"IsLeast.union","isProp":true,"docString":"If `a` is the least element of `s` and `b` is the least element of `t`,\nthen `min a b` is the least element of `s ‚à™ t`. "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {a : Œ±} {s : Set Œ±}\n  (h : ‚àÄ (a_1 : ¬¨(a ‚àà s : Prop)), f a = 1),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà insert a s) ‚Ü¶ f i) = finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i","name":"finprod_mem_insert_of_eq_one_if_not_mem","isProp":true,"docString":"If `f a = 1` when `a ‚àâ s`, then the product of `f i` over `i ‚àà insert a s` equals the product of\n`f i` over `i ‚àà s`. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {M : Type u_3} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ≤) ‚Üí Œ±}\n  (hg : Set.InjOn g (Function.mulSupport (f ‚àò g))),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà Set.range g) ‚Ü¶ f i) = finprod fun (j : Œ≤) ‚Ü¶ f (g j)","name":"finprod_mem_range'","isProp":true,"docString":"The product of `f y` over `y ‚àà set.range g` equals the product of `f (g i)` over all `i`\nprovided that `g` is injective on `mulSupport (f ‚àò g)`. "},{"type":"‚àÄ {R : Type v} [inst : CommRing R] {n : ‚Ñï} {A : Matrix (Fin (n + 1)) (Fin (n + 1)) R}\n  {B : Matrix (Fin (n + 1)) (Fin (n + 1)) R} (c : (a : Fin n) ‚Üí R) (A_zero : ‚àÄ (j : Fin (n + 1)), A 0 j = B 0 j)\n  (A_succ : ‚àÄ (i : Fin n) (j : Fin (n + 1)), A (Fin.succ i) j = B (Fin.succ i) j + c i * A (‚ÜëFin.castSucc i) j),\n  Matrix.det A = Matrix.det B","name":"Matrix.det_eq_of_forall_row_eq_smul_add_pred","isProp":true,"docString":"If you add multiples of previous rows to the next row, the determinant doesn't change. "},{"type":"‚àÄ {S : Type u_1} [inst : OrderedSemiring S] {R : Type u_2} [inst_1 : Semiring R] {f : (a : R) ‚Üí S}\n  [self : IsAbsoluteValue f] (x : R) (y : R), f (x + y) ‚â§ f x + f y","name":"IsAbsoluteValue.abv_add'","isProp":true,"docString":"The absolute value satisfies the triangle inequality "},{"type":"‚àÄ {Œ± : Type u_1} {c : Set (Set Œ±)} (H : ‚àÄ (a : Œ±), ‚àÉ! (b : Set Œ±), ‚àÉ! (x : b ‚àà c), a ‚àà b) {y : Œ±},\n  (setOf fun (x : Œ±) ‚Ü¶ Setoid.Rel (Setoid.mkClasses c H) x y) ‚àà c","name":"Setoid.eqv_class_mem","isProp":true,"docString":"The equivalence classes of the equivalence relation defined by a set of sets\npartitioning Œ± are elements of the set of sets. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup A] [inst_2 : Module R A]\n  [inst_3 : StarAddMonoid R] [inst_4 : StarAddMonoid A] [inst_5 : StarModule R A] {r : R} (hr : r ‚àà skewAdjoint R)\n  {a : A} (ha : IsSelfAdjoint a), r ‚Ä¢ a ‚àà skewAdjoint A","name":"IsSelfAdjoint.smul_mem_skewAdjoint","isProp":true,"docString":"Scalar multiplication of a self-adjoint element by a skew-adjoint element produces a\nskew-adjoint element. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : AddCommMonoid M] {w : (a : œÉ) ‚Üí M},\n  SetLike.GradedMonoid (MvPolynomial.weightedHomogeneousSubmodule R w)","name":"MvPolynomial.IsWeightedHomogeneous.WeightedHomogeneousSubmodule.gcomm_monoid","isProp":true,"docString":"The weighted homogeneous submodules form a graded monoid. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {c : AddCon M} {f : M ‚Üí+ P}\n  (H : c ‚â§ AddCon.ker f), AddMonoidHom.mrange (AddCon.lift c f H) = AddMonoidHom.mrange f","name":"AddCon.lift_range","isProp":true,"docString":"Given an additive congruence relation `c` on an `AddMonoid` and a homomorphism `f`\nconstant on `c`'s equivalence classes, `f` has the same image as the homomorphism that `f` induces\non the quotient."},{"type":"‚àÄ {M : Type u_1} {X : Type u_2} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace X] [inst_2 : VAdd M X]\n  [inst_3 : ContinuousVAdd M X] [inst_4 : VAdd M·µÉ·µí·µñ X] [inst_5 : IsCentralVAdd M X], ContinuousVAdd M·µÉ·µí·µñ X","name":"ContinuousVAdd.op","isProp":true,"docString":"If an additive action is central, then its right action is continuous when its left\n\naction is."},{"type":"‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] {P : Type u_1} [inst_2 : FirstOrder.Language.Structure L P]\n  {Q : Type u_2} [inst_3 : FirstOrder.Language.Structure L Q] (f : FirstOrder.Language.Hom L M N)\n  (g : FirstOrder.Language.Hom L N P) (h : FirstOrder.Language.Hom L P Q),\n  FirstOrder.Language.Hom.comp (FirstOrder.Language.Hom.comp h g) f =\n    FirstOrder.Language.Hom.comp h (FirstOrder.Language.Hom.comp g f)","name":"FirstOrder.Language.Hom.comp_assoc","isProp":true,"docString":"Composition of first-order homomorphisms is associative. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {M‚ÇÇ : Type u_3} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace M‚ÇÇ]\n  [inst_2 : Semiring R] [inst_3 : AddCommMonoid M‚ÇÇ] [inst_4 : Module R M‚ÇÇ] [inst_5 : AddCommMonoid M]\n  [inst_6 : Module R M] (f : M ‚ÜíL[R] M‚ÇÇ) (h : ¬¨(‚àÉ (e' : M ‚âÉL[R] M‚ÇÇ), ‚Üëe' = f : Prop)), ContinuousLinearMap.inverse f = 0","name":"ContinuousLinearMap.inverse_non_equiv","isProp":true,"docString":"By definition, if `f` is not invertible then `inverse f = 0`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X : C} {Y : C}\n  {Z : C} {X' : C} {Y' : C} {Z' : C} (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Limits.HasCokernel f] (g : Y ‚ü∂ Z)\n  (w : f ‚â´ g = 0) (f' : X' ‚ü∂ Y') [inst_3 : CategoryTheory.Limits.HasCokernel f'] (g' : Y' ‚ü∂ Z') (w' : f' ‚â´ g' = 0)\n  (p : X ‚ü∂ X') (q : Y ‚ü∂ Y') (r : Z ‚ü∂ Z') (h‚ÇÅ : f ‚â´ q = p ‚â´ f') (h‚ÇÇ : g ‚â´ r = q ‚â´ g'),\n  CategoryTheory.Limits.cokernel.map f f' p q h‚ÇÅ ‚â´ CategoryTheory.Limits.cokernel.desc f' g' w' =\n    CategoryTheory.Limits.cokernel.desc f g w ‚â´ r","name":"CategoryTheory.Limits.cokernel.map_desc","isProp":true,"docString":"Given a commutative diagram\n    X --f--> Y --g--> Z\n    |        |        |\n    |        |        |\n    v        v        v\n    X' -f'-> Y' -g'-> Z'\nwith horizontal arrows composing to zero,\nthen we obtain a commutative square\n   cokernel f ---> Z\n   |               |\n   | cokernel.map  |\n   |               |\n   v               v\n   cokernel f' --> Z'\n"},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï} (h_pos : 0 < ‚Üë(Nat.factorization (Nat.centralBinom n)) p), p ‚â§ 2 * n","name":"Nat.le_two_mul_of_factorization_centralBinom_pos","isProp":true,"docString":"Contrapositive form of `Nat.factorization_centralBinom_eq_zero_of_two_mul_lt` "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : Preorder Œπ] [inst_1 : LinearOrder Œ±] {u : (a : Œπ) ‚Üí Œ±} (h : Monotone u)\n  (H : ¬¨(BddAbove (Set.range u) : Prop)), Filter.Tendsto u Filter.atTop Filter.atTop","name":"Filter.tendsto_atTop_atTop_of_monotone'","isProp":true,"docString":"If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded\nabove, then `Tendsto u atTop atTop`. "},{"type":"‚àÄ {Œ± : Type u} [t : TopologicalSpace Œ±] [inst : TopologicalSpace.SecondCountableTopology Œ±] {f : (a : Œ±) ‚Üí Set Œ±}\n  (hf : ‚àÄ (x : Œ±), f x ‚àà nhds x),\n  ‚àÉ (s : Set Œ±),\n    (Set.Countable s : Prop) ‚àß ((Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà s) ‚Ü¶ f x) = Set.univ : Prop)","name":"TopologicalSpace.countable_cover_nhds","isProp":true,"docString":"In a topological space with second countable topology, if `f` is a function that sends each\npoint `x` to a neighborhood of `x`, then for some countable set `s`, the neighborhoods `f x`,\n`x ‚àà s`, cover the whole space. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : AddCommMonoid Œ≤] {s : Finset Œ≥} {t : Finset Œ±}\n  {f : (a : Œ≥) ‚Üí (a : Œ±) ‚Üí Œ≤},\n  (Finset.sum (s √ó·∂† t) fun (x : Œ≥ √ó Œ±) ‚Ü¶ f (Prod.fst x) (Prod.snd x)) =\n    Finset.sum s fun (x : Œ≥) ‚Ü¶ Finset.sum t fun (y : Œ±) ‚Ü¶ f x y","name":"Finset.sum_product'","isProp":true,"docString":"An uncurried version of `Finset.sum_product`"},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±],\n  (setOf fun (s : Set Œ±) ‚Ü¶ IsPreconnected s) ‚äÜ\n    Set.range (Function.uncurry Set.Icc) ‚à™ Set.range (Function.uncurry Set.Ico) ‚à™ Set.range (Function.uncurry Set.Ioc) ‚à™\n        Set.range (Function.uncurry Set.Ioo) ‚à™\n      (Set.range Set.Ici ‚à™ Set.range Set.Ioi ‚à™ Set.range Set.Iic ‚à™ Set.range Set.Iio ‚à™ {Set.univ, ‚àÖ})","name":"setOf_isPreconnected_subset_of_ordered","isProp":true,"docString":"A preconnected set is either one of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`,\n`Iic`, `Iio`, or `univ`, or `‚àÖ`. The converse statement requires `Œ±` to be densely ordered. Though\none can represent `‚àÖ` as `(Inf s, Inf s)`, we include it into the list of possible cases to improve\nreadability. "},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsNoetherianRing R], IsNoetherianRing (Polynomial R)","name":"Polynomial.isNoetherianRing","isProp":true,"docString":"Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {la : Filter Œ±} {lb : Filter Œ≤} {s : (a : Œ±) ‚Üí Set Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  (hs : Filter.Tendsto s la (Filter.smallSets lb)) (hf : Filter.Eventually (fun (x : Œ±) ‚Ü¶ f x ‚àà s x) la),\n  Filter.Tendsto f la lb","name":"Filter.Tendsto.of_smallSets","isProp":true,"docString":"Generalized **squeeze theorem** (also known as **sandwich theorem**). If `s : Œ± ‚Üí Set Œ≤` is a\nfamily of sets that tends to `Filter.smallSets lb` along `la` and `f : Œ± ‚Üí Œ≤` is a function such\nthat `f x ‚àà s x` eventually along `la`, then `f` tends to `lb` along `la`.\n\nIf `s x` is the closed interval `[g x, h x]` for some functions `g`, `h` that tend to the same limit\n`ùìù y`, then we obtain the standard squeeze theorem, see\n`tendsto_of_tendsto_of_tendsto_of_le_of_le'`. "},{"type":"‚àÄ {R : Type u} {S‚ÇÅ : Type v} {œÉ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S‚ÇÅ] {f : R ‚Üí+* S‚ÇÅ}\n  {g : S‚ÇÅ ‚Üí+* R} (hf : Function.RightInverse ‚Üëf ‚Üëg), Function.RightInverse ‚Üë(MvPolynomial.map f) ‚Üë(MvPolynomial.map g)","name":"MvPolynomial.map_rightInverse","isProp":true,"docString":"If `f` is a right-inverse of `g` then `map f` is a right-inverse of `map g`. "},{"type":"‚àÄ (R : Type u_2) (M : Type u_1) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (x : M),\n  Submodule.span R {x} = LinearMap.range (LinearMap.toSpanSingleton R M x)","name":"LinearMap.span_singleton_eq_range","isProp":true,"docString":"The range of `toSpanSingleton x` is the span of `x`."},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} [self : CategoryTheory.RegularEpi f],\n  CategoryTheory.RegularEpi.left ‚â´ f = CategoryTheory.RegularEpi.right ‚â´ f","name":"CategoryTheory.RegularEpi.w","isProp":true,"docString":"`f` coequalizes the two maps "},{"type":"‚àÄ {M : Type u_2} [inst : AddCommMonoid M] {S : AddSubmonoid M} {N : Type u_1} [inst_1 : AddCommMonoid N]\n  (f : AddSubmonoid.LocalizationMap S N) (z : N),\n  AddSubmonoid.LocalizationMap.mk' f (Prod.fst (AddSubmonoid.LocalizationMap.sec f z))\n      (Prod.snd (AddSubmonoid.LocalizationMap.sec f z)) =\n    z","name":"AddSubmonoid.LocalizationMap.mk'_sec","isProp":true,"docString":"Given a localization map `f : M ‚Üí+ N` for a Submonoid `S ‚äÜ M`, for all `z : N`\nwe have that if `x : M, y ‚àà S` are such that `z + f y = f x`, then `f x - f y = z`."},{"type":"‚àÄ {q : ‚Ñï+} (w : 1 < q), Fintype.card (LucasLehmer.X q)À£ < ‚Üëq ^ 2","name":"LucasLehmer.X.card_units_lt","isProp":true,"docString":"There are strictly fewer than `q^2` units, since `0` is not a unit. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] {X : C} {Y : C} {Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)\n  [inst_1 : CategoryTheory.Limits.HasPushout f g] [inst_2 : CategoryTheory.Limits.HasBinaryCoproduct Y Z],\n  CategoryTheory.Epi\n    (CategoryTheory.Limits.coprod.desc CategoryTheory.Limits.pushout.inl CategoryTheory.Limits.pushout.inr)","name":"CategoryTheory.Limits.epi_coprod_to_pushout","isProp":true,"docString":"The map ` X ‚®ø Y ‚ü∂ X ‚®ø[Z] Y` is epi. "},{"type":"‚àÄ {Œ± : Type u} {s : Set Œ±}, (Nontrivial ‚Üës : Prop) ‚Üî (Set.Nontrivial s : Prop)","name":"Set.nontrivial_coe_sort","isProp":true,"docString":"`s`, coerced to a type, is a nontrivial type if and only if `s` is a nontrivial set. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} (hs : IsSeqClosed s), seqClosure s = s","name":"IsSeqClosed.seqClosure_eq","isProp":true,"docString":"The sequential closure of a sequentially closed set is the set itself. "},{"type":"‚àÄ {a : Ordinal} {b : Ordinal}, Set.Nonempty (setOf fun (o : Ordinal) ‚Ü¶ a ‚â§ b + o)","name":"Ordinal.sub_nonempty","isProp":true,"docString":"The set in the definition of subtraction is nonempty. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} {c : Œ±} [inst : LinearOrder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±]\n  [inst_3 : OrderedSub Œ±], (a < b - c : Prop) ‚Üî (a + c < b : Prop)","name":"lt_tsub_iff_right","isProp":true,"docString":"See `lt_tsub_iff_right_of_le` for a weaker statement in a partial order. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M ‚Üí+ N), ‚Üëf 0 = 0","name":"AddMonoidHom.map_zero","isProp":true,"docString":"If `f` is an additive monoid homomorphism then `f 0 = 0`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : ClosedEmbedding f), Filter.Tendsto f (Filter.cocompact Œ±) (Filter.cocompact Œ≤)","name":"ClosedEmbedding.tendsto_cocompact","isProp":true,"docString":"A closed embedding is proper, ie, inverse images of compact sets are contained in compacts.\nMoreover, the preimage of a compact set is compact, see `ClosedEmbedding.isCompact_preimage`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] [inst_2 : FaithfulVAdd Œ± Œ≤],\n  Function.Injective AddAction.toPerm","name":"AddAction.toPerm_injective","isProp":true,"docString":"`AddAction.toPerm` is injective on faithful actions."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [inst_1 : IsLowerModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚ãñ a ‚äî b), a ‚äì b ‚ãñ b","name":"Covby.inf_of_sup_left","isProp":true,"docString":"**Alias** of `inf_covby_of_covby_sup_left`."},{"type":"‚àÄ {f : Sat.Fmla} {c : Sat.Clause} (H : Sat.Fmla.subsumes f (Sat.Fmla.one c)), Sat.Fmla.proof f c","name":"Sat.Fmla.proof_of_subsumes","isProp":true,"docString":"If `f` subsumes `c` (i.e. `c ‚àà f`), then `f.proof c`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : CompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : CompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderClosedTopology Œ≤] {Œπ : Sort u_1}\n  {f : (a : Œ±) ‚Üí Œ≤} {g : (a : Œπ) ‚Üí Œ±} (Cf : ContinuousAt f (inf·µ¢ g)) (Af : Antitone f) (ftop : f ‚ä§ = ‚ä•),\n  f (inf·µ¢ g) = sup·µ¢ (f ‚àò g)","name":"Antitone.map_inf·µ¢_of_continuousAt","isProp":true,"docString":"If an antitone function sending `top` to `bot` is continuous at the indexed infimum over\na `Sort`, then it sends this indexed infimum to the indexed supremum of the composition. "},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {S : Type u_2} {F : Filter Œπ} [inst : Filter.NeBot F] [inst : CompleteLinearOrder R]\n  [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R] [inst_3 : CompleteLinearOrder S]\n  [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {f : (a : R) ‚Üí S} (f_decr : Antitone f) (a : (a : Œπ) ‚Üí R)\n  (f_cont : ContinuousAt f (Filter.liminf a F)), f (Filter.liminf a F) = Filter.limsup (f ‚àò a) F","name":"Antitone.map_liminf_of_continuousAt","isProp":true,"docString":"A continuous antitone function between complete linear ordered spaces sends a `Filter.liminf`\nto the `Filter.limsup` of the images. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Monoid M] [inst_1 : Monoid N] (f : M ‚Üí* N·µê·µí·µñ) (l : List M),\n  MulOpposite.unop (‚Üëf (List.prod l)) = List.prod (List.reverse (List.map (MulOpposite.unop ‚àò ‚Üëf) l))","name":"MonoidHom.unop_map_list_prod","isProp":true,"docString":"A morphism into the opposite monoid acts on the product by acting on the reversed elements. "},{"type":"‚àÄ {v : Sat.Valuation} {f‚ÇÅ : Sat.Fmla} {a : Prop} {f‚ÇÇ : Sat.Fmla} {b : Prop} (h‚ÇÅ : Sat.Fmla.reify v f‚ÇÅ (a : Prop))\n  (h‚ÇÇ : Sat.Fmla.reify v f‚ÇÇ (b : Prop)), Sat.Fmla.reify v (Sat.Fmla.and f‚ÇÅ f‚ÇÇ) ((a : Prop) ‚à® (b : Prop) : Prop)","name":"Sat.Fmla.reify_or","isProp":true,"docString":"Negation turns AND into OR, so `¬¨‚ü¶f‚ÇÅ ‚àß f‚ÇÇ‚üß_v ‚â° ¬¨‚ü¶f‚ÇÅ‚üß_v ‚à® ¬¨‚ü¶f‚ÇÇ‚üß_v`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : HeytingAlgebra Œ±]\n  [inst_1 : HeytingAlgebra Œ≤] [self : HeytingHomClass F Œ± Œ≤] (f : F), ‚Üëf ‚ä• = ‚ä•","name":"HeytingHomClass.map_bot","isProp":true,"docString":"The proposition that a Heyting homomorphism preserves the bottom element."},{"type":"‚àÄ {G : Type u} [inst : Group G] {x : G} (hx : IsOfFinOrder x), IsOfFinOrder x‚Åª¬π","name":"IsOfFinOrder.inv","isProp":true,"docString":"Inverses of elements of finite order have finite order. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K : Set G} {U : Set G}\n  (hK : IsCompact K) (hU : IsOpen U) (hKU : K ‚äÜ U), ‚àÉ (V : Set G), (V ‚àà nhds 1 : Prop) ‚àß (K * V ‚äÜ U : Prop)","name":"compact_open_separated_mul_right","isProp":true,"docString":"Given a compact set `K` inside an open set `U`, there is a open neighborhood `V` of `1`\nsuch that `K * V ‚äÜ U`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±} {y : Œ±} (hf : IsRingHom f),\n  f (x - y) = f x - f y","name":"IsRingHom.map_sub","isProp":true,"docString":"Ring homomorphisms preserve subtraction. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} (P : C·µí·µñ ‚•§ Type w),\n  CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Presieve.singleton (ùüô X))","name":"CategoryTheory.Presieve.isSheafFor_singleton_iso","isProp":true,"docString":"Every presheaf is a sheaf for the family {ùüô X}.\n\n[Elephant] C2.1.5(i)\n"},{"type":"‚àÄ {M : Type u} [self : AddZeroClass M] (a : M), a + 0 = a","name":"AddZeroClass.add_zero","isProp":true,"docString":"Zero is a right neutral element for addition "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Monovary f g),\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i) ‚â§ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i","name":"Monovary.sum_comp_perm_smul_le_sum_smul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is maximized when\n`f` and `g` monovary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] (m : Œ±) (a : IsSquare m), ‚àÉ (c : Œ±), m = c ^ 2","name":"IsSquare.exists_sq","isProp":true,"docString":"**Alias** of the forward direction of `isSquare_iff_exists_sq`."},{"type":"‚àÄ {G : Type u} {x : G} {n : ‚Ñï} [inst : AddMonoid G] (hn : 0 < n) (hx : n ‚Ä¢ x = 0)\n  (hd : ‚àÄ (p : ‚Ñï) (a : Nat.Prime p) (a : p ‚à£ n), (n / p) ‚Ä¢ x ‚â† 0), addOrderOf x = n","name":"addOrderOf_eq_of_nsmul_and_div_prime_nsmul","isProp":true,"docString":"If `n * x = 0`, but `n/p * x ‚â† 0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`."},{"type":"‚àÄ {E : (a : ‚Ñï) ‚Üí Type u_1} [inst : (n : ‚Ñï) ‚Üí TopologicalSpace (E n)] [inst_1 : ‚àÄ (n : ‚Ñï), DiscreteTopology (E n)]\n  {s : Set ((n : ‚Ñï) ‚Üí E n)} (hs : IsClosed s) (hne : Set.Nonempty s),\n  ‚àÉ (f : (a : (n : ‚Ñï) ‚Üí E n) ‚Üí (n : ‚Ñï) ‚Üí E n),\n    (‚àÄ (x : (n : ‚Ñï) ‚Üí E n) (a : x ‚àà s), f x = x : Prop) ‚àß ((Set.range f = s : Prop) ‚àß (Continuous f : Prop) : Prop)","name":"PiNat.exists_retraction_of_isClosed","isProp":true,"docString":"Given a closed nonempty subset `s` of `Œ† (n : ‚Ñï), E n`, there exists a retraction onto this\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. "},{"type":"‚àÄ {G : Type u} [inst : Monoid G] {H : Type v} [inst_1 : Monoid H] (f : G ‚Üí* H) {x : G} (h : IsOfFinOrder x),\n  IsOfFinOrder (‚Üëf x)","name":"MonoidHom.isOfFinOrder","isProp":true,"docString":"The image of an element of finite order has finite order. "},{"type":"‚àÄ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\n  [inst_3 : Archimedean G] (S : AddSubgroup G)\n  (hS : ‚àÄ (Œµ : G) (a : Œµ > 0), ‚àÉ (g : G), (g ‚àà S : Prop) ‚àß (g ‚àà Set.Ioo 0 Œµ : Prop)), Dense ‚ÜëS","name":"AddSubgroup.dense_of_not_isolated_zero","isProp":true,"docString":"An additive subgroup of an archimedean linear ordered additive commutative group with order\ntopology is dense provided that for all positive `Œµ` there exists a positive element of the\nsubgroup that is less than `Œµ`. "},{"type":"‚àÄ {Œπa : Type u_1} {Œπb : Type u_2} [inst : Fintype Œπa] [inst_1 : Fintype Œπb] {R' : Type u_3} {M·µ¢ : Type u_4}\n  {N‚ÇÅ : Type u_5} {N‚ÇÇ : Type u_6} [inst_2 : CommSemiring R'] [inst_3 : AddCommGroup N‚ÇÅ] [inst_4 : Module R' N‚ÇÅ]\n  [inst_5 : AddCommGroup N‚ÇÇ] [inst_6 : Module R' N‚ÇÇ] [inst_7 : AddCommMonoid M·µ¢] [inst_8 : Module R' M·µ¢]\n  [inst_9 : DecidableEq Œπa] [inst_10 : DecidableEq Œπb] (a : AlternatingMap R' M·µ¢ N‚ÇÅ Œπa)\n  (b : AlternatingMap R' M·µ¢ N‚ÇÇ Œπb),\n  ‚ÜëMultilinearMap.alternatization (MultilinearMap.domCoprod ‚Üëa ‚Üëb) =\n    (Nat.factorial (Fintype.card Œπa) * Nat.factorial (Fintype.card Œπb)) ‚Ä¢ AlternatingMap.domCoprod a b","name":"MultilinearMap.domCoprod_alternization_eq","isProp":true,"docString":"Taking the `MultilinearMap.alternatization` of the `MultilinearMap.domCoprod` of two\n`AlternatingMap`s gives a scaled version of the `AlternatingMap.coprod` of those maps.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (h : AntitoneOn f s) (hl : BddBelow (f '' s)) (hu : BddAbove (f '' s)),\n  ‚àÉ (g : (a : Œ±) ‚Üí Œ≤), (Antitone g : Prop) ‚àß (Set.EqOn f g s : Prop)","name":"AntitoneOn.exists_antitone_extension","isProp":true,"docString":"If a function is antitone and is bounded on a set `s`, then it admits an antitone extension to\nthe whole space. "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] {a : G‚ÇÄ} (a_1 : a ‚â† 0), IsUnit a","name":"Ne.isUnit","isProp":true,"docString":"**Alias** of the reverse direction of `isUnit_iff_ne_zero`."},{"type":"‚àÄ {n : ‚Ñï} {l : List ‚Ñï} (h‚ÇÅ : List.prod l = n) (h‚ÇÇ : ‚àÄ (p : ‚Ñï) (a : p ‚àà l), Nat.Prime p), l ~ Nat.factors n","name":"Nat.factors_unique","isProp":true,"docString":"**Fundamental theorem of arithmetic**"},{"type":"‚àÄ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel (SimpleGraph.Adj G)] [inst_2 : Nonempty V],\n  ‚àÉ (v : V), SimpleGraph.minDegree G = SimpleGraph.degree G v","name":"SimpleGraph.exists_minimal_degree_vertex","isProp":true,"docString":"There exists a vertex of minimal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. "},{"type":"‚àÄ {Œπ : Type u} {Œ≤ : (a : Œπ) ‚Üí Type v} [dec : DecidableEq Œπ] [inst : (i : Œπ) ‚Üí Zero (Œ≤ i)] (i : Œπ) (j : Œπ) (xi : Œ≤ i)\n  (xj : Œ≤ j),\n  (Dfinsupp.single i xi = Dfinsupp.single j xj : Prop) ‚Üî\n    (((i = j : Prop) ‚àß (HEq xi xj : Prop) : Prop) ‚à® ((xi = 0 : Prop) ‚àß (xj = 0 : Prop) : Prop) : Prop)","name":"Dfinsupp.single_eq_single_iff","isProp":true,"docString":"Like `Finsupp.single_eq_single_iff`, but with a `HEq` due to dependent types "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {B : Finset (Finset Œ±)} {n : ‚Ñï}\n  (h : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), Finset.card (Finset.filter ((fun (x : Œ±) (x_1 : Finset Œ±) ‚Ü¶ x ‚àà x_1) a) B) ‚â§ n),\n  (Finset.sum B fun (t : Finset Œ±) ‚Ü¶ Finset.card (s ‚à© t)) ‚â§ Finset.card s * n","name":"Finset.sum_card_inter_le","isProp":true,"docString":"If every element belongs to at most `n` Finsets, then the sum of their sizes is at most `n`\ntimes how many they are. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] {ùíú : Finset (Finset Œ±)} {r : ‚Ñï} (hùíú : Set.Sized r ‚Üëùíú),\n  Set.Sized (r + 1) ‚Üë(Finset.upShadow ùíú)","name":"Finset.Set.Sized.upShadow","isProp":true,"docString":"The upper shadow of a family of `r`-sets is a family of `r + 1`-sets. "},{"type":"‚àÄ {R : Type u_2} [inst : CommRing R] (M : Submonoid R) (S : Type u_1) [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsLocalization M S] {I : Ideal S} [inst_4 : Ideal.IsPrime I] {J : Ideal R}\n  {H : J ‚â§ Ideal.comap (algebraMap R S) I} (hI : Ideal.IsMaximal (Ideal.comap (algebraMap R S) I)),\n  Function.Surjective ‚Üë(Ideal.quotientMap I (algebraMap R S) H)","name":"IsLocalization.surjective_quotientMap_of_maximal_of_localization","isProp":true,"docString":"`quotient_map` applied to maximal ideals of a localization is `surjective`.\nThe quotient by a maximal ideal is a field, so inverses to elements already exist,\nand the localization necessarily maps the equivalence class of the inverse in the localization "},{"type":"‚àÄ {Œ± : Type u_1} (L : List (List Œ±)) (i : ‚Ñï),\n  List.take (List.sum (List.take i (List.map List.length L))) (List.join L) = List.join (List.take i L)","name":"List.take_sum_join","isProp":true,"docString":"In a join, taking the first elements up to an index which is the sum of the lengths of the\nfirst `i` sublists, is the same as taking the join of the first `i` sublists. "},{"type":"‚àÄ {Œπ : Type u_1} {A : (a : Œπ) ‚Üí Type u_2} [inst : AddMonoid Œπ] [self : GradedMonoid.GMonoid A] (a : GradedMonoid A),\n  1 * a = a","name":"GradedMonoid.GMonoid.one_mul","isProp":true,"docString":"Muliplication by `one` on the left is the identity "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} [inst_1 : TopologicalSpace.SecondCountableTopology X]\n  (h : IsOpenMap Quotient.mk'), TopologicalSpace.SecondCountableTopology (Quotient S)","name":"TopologicalSpace.Quotient.secondCountableTopology","isProp":true,"docString":"An open quotient of a second countable space is second countable. "},{"type":"‚àÄ {p : ‚Ñï} (a : Nat.Prime p), Prime p","name":"Nat.Prime.prime","isProp":true,"docString":"**Alias** of the forward direction of `Nat.prime_iff`."},{"type":"‚àÄ {n : ‚Ñï} {p : ‚Ñï} (hp : Nat.Prime p),\n  multiplicity p (Nat.factorial (p * (n + 1))) = multiplicity p (Nat.factorial (p * n)) + multiplicity p (n + 1) + 1","name":"Nat.Prime.multiplicity_factorial_mul_succ","isProp":true,"docString":"The multiplicity of `p` in `(p * (n + 1))!` is one more than the sum\nof the multiplicities of `p` in `(p * n)!` and `n + 1`. "},{"type":"‚àÄ {Œ± : Type u} {l : List Œ±} (a : List.Nodup (List.sublists' l)), List.Nodup l","name":"List.nodup.of_sublists'","isProp":true,"docString":"**Alias** of the forward direction of `List.nodup_sublists'`."},{"type":"‚àÄ (R : Type u_2) (M : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : TopologicalSpace M]\n  [inst_3 : AddCommGroup M] [inst_4 : ContinuousAdd M] [inst_5 : Module R M] [inst_6 : ContinuousSMul R M]\n  [inst_7 : Nontrivial M] [inst_8 : Filter.NeBot (nhdsWithin 0 ({0}·∂ú))] [inst : NoZeroSMulDivisors R M] (x : M),\n  Filter.NeBot (nhdsWithin x ({x}·∂ú))","name":"Module.punctured_nhds_neBot","isProp":true,"docString":"Let `R` be a topological ring such that zero is not an isolated point (e.g., a nontrivially\nnormed field, see `NormedField.punctured_nhds_neBot`). Let `M` be a nontrivial module over `R`\nsuch that `c ‚Ä¢ x = 0` implies `c = 0 ‚à® x = 0`. Then `M` has no isolated points. We formulate this\nusing `NeBot (ùìù[‚â†] x)`.\n\nThis lemma is not an instance because Lean would need to find `[ContinuousSMul ?m_1 M]` with\nunknown `?m_1`. We register this as an instance for `R = ‚Ñù` in `Real.punctured_nhds_module_neBot`.\nOne can also use `haveI := Module.punctured_nhds_neBot R M` in a proof.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : StrictOrderedRing Œ±] {a : Œ±} {b : Œ±} (hb : b < 0) (h : 1 < a), a * b < b","name":"mul_lt_of_one_lt_left","isProp":true,"docString":"Variant of `lt_mul_of_one_lt_left` for `b` negative instead of positive. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] ‚¶És : Set M‚¶Ñ ‚¶Ét : Set M‚¶Ñ (h : s ‚äÜ t),\n  AddSubmonoid.closure s ‚â§ AddSubmonoid.closure t","name":"AddSubmonoid.closure_mono","isProp":true,"docString":"Additive submonoid closure of a set is monotone in its argument: if `s ‚äÜ t`,\nthen `closure s ‚â§ closure t`"},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {a : Œ±} [inst : DecidableEq Œ±],\n  Finset.card (Finset.erase s a) = if (a ‚àà s : Prop) then Finset.card s - 1 else Finset.card s","name":"Finset.card_erase_eq_ite","isProp":true,"docString":"If `a ‚àà s` is known, see also `Finset.card_erase_of_mem` and `Finset.erase_eq_of_not_mem`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {p : Filter Œπ} [inst_1 : TopologicalSpace Œ±] (h : TendstoUniformly F f p)\n  (hc : Filter.Eventually (fun (n : Œπ) ‚Ü¶ Continuous (F n)) p) [inst_2 : Filter.NeBot p], Continuous f","name":"TendstoUniformly.continuous","isProp":true,"docString":"A uniform limit of continuous functions is continuous. "},{"type":"Cardinal.mk ‚Ñù = Cardinal.continuum","name":"Cardinal.mk_real","isProp":true,"docString":"The cardinality of the reals, as a type. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] (c : AddCon M) (n : ‚Ñï) {w : M} {x : M} (a : ‚Üëc w x), ‚Üëc (n ‚Ä¢ w) (n ‚Ä¢ x)","name":"AddCon.nsmul","isProp":true,"docString":"Additive congruence relations preserve natural scaling."},{"type":"‚àÄ {L : Type v} [self : LieRing L] (x : L), ‚ÅÖx, x‚ÅÜ = 0","name":"LieRing.lie_self","isProp":true,"docString":"A Lie ring bracket vanishes on the diagonal in L √ó L. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {x : Œ±}\n  {p : Filter Œπ} {g : (a : Œπ) ‚Üí Œ±} [inst_1 : TopologicalSpace Œ±] (h : TendstoLocallyUniformly F f p)\n  (hf : ContinuousAt f x) (hg : Filter.Tendsto g p (nhds x)), Filter.Tendsto (fun (n : Œπ) ‚Ü¶ F n (g n)) p (nhds (f x))","name":"TendstoLocallyUniformly.tendsto_comp","isProp":true,"docString":"If `F‚Çô` tends locally uniformly to `f`, and `g‚Çô` tends to `x`, then `F‚Çô g‚Çô` tends to `f x`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C)\n  [inst_3 : CategoryTheory.Limits.HasBinaryBiproduct X Y],\n  CategoryTheory.IsPullback CategoryTheory.Limits.biprod.inr 0 CategoryTheory.Limits.biprod.fst 0","name":"CategoryTheory.IsPullback.inr_fst","isProp":true,"docString":"The square\n```\n  Y --inr--> X ‚äû Y\n  |            |\n  0           fst\n  |            |\n  v            v\n  0 ---0-----> X\n```\nis a pullback square.\n"},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (M : Submonoid R) (S : Type u_4) [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  {P : Type u_2} [inst_3 : CommRing P] [inst_4 : IsLocalization M S] (Q : Type u_3) [inst_5 : CommRing Q] {g : R ‚Üí+* P}\n  [inst_6 : Algebra P Q] (hg : Function.Injective ‚Üëg) [i : IsLocalization (Submonoid.map g M) Q],\n  Function.Injective\n    ‚Üë(IsLocalization.map Q g\n        ((Submonoid.le_comap_map\n              M=:M ‚â§ Submonoid.comap g (Submonoid.map g M))=:M ‚â§ Submonoid.comap g (Submonoid.map g M)))","name":"IsLocalization.map_injective_of_injective","isProp":true,"docString":"Injectivity of a map descends to the map induced on localizations. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {G : C ‚•§ D}\n  (h_obj :\n    ‚àÄ (X : C),\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X =\n        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor G) X)\n  (h_map :\n    ‚àÄ (X : C) (Y : C) (f : X ‚ü∂ Y),\n      HEq (Prefunctor.map (CategoryTheory.Functor.toPrefunctor F) f)\n        (Prefunctor.map (CategoryTheory.Functor.toPrefunctor G) f)),\n  F = G","name":"CategoryTheory.Functor.hext","isProp":true,"docString":"Proving equality between functors using heterogeneous equality. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {Œπ : Type u_1} {t : Finset Œπ} {f : (a : Œπ) ‚Üí K}\n  (h : ‚àÄ (c : Œπ) (a : c ‚àà t), f c ‚àà s), (Finset.prod t fun (i : Œπ) ‚Ü¶ f i) ‚àà s","name":"Subfield.prod_mem","isProp":true,"docString":"Product of elements of a subfield indexed by a `Finset` is in the subfield. "},{"type":"‚àÄ {M : Type u} [self : AddRightCancelMonoid M] (n : ‚Ñï) (x : M),\n  AddRightCancelMonoid.nsmul (n + 1) x = x + AddRightCancelMonoid.nsmul n x","name":"AddRightCancelMonoid.nsmul_succ","isProp":true,"docString":"Multiplication by `(n + 1 : ‚Ñï)` behaves as expected. "},{"type":"‚àÄ {Œπ : Sort u_1} {f : (a : Œπ) ‚Üí ENNReal} {x : ENNReal} (h0 : x ‚â† 0) (h : x ‚â† ‚ä§), x * inf·µ¢ f = inf·µ¢ fun (i : Œπ) ‚Ü¶ x * f i","name":"ENNReal.mul_inf·µ¢_of_ne","isProp":true,"docString":"If `x ‚â† 0` and `x ‚â† ‚àû`, then left multiplication by `x` maps infimum to infimum.\nSee also `ENNReal.mul_inf·µ¢` that assumes `[Nonempty Œπ]` but does not require `x ‚â† 0`. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  (b : (a : n) ‚Üí Œ±) (h : IsUnit (Matrix.det A)), Matrix.det A ‚Ä¢ Matrix.mulVec A‚Åª¬π b = ‚Üë(Matrix.cramer A) b","name":"Matrix.det_smul_inv_mulVec_eq_cramer","isProp":true,"docString":"One form of **Cramer's rule**. See `Matrix.mulVec_cramer` for a stronger form. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Monoid Œ±] {p : Œ±} {q : Œ±} (hp : Irreducible p) (hq : Irreducible q) (a : p ‚à£ q), q ‚à£ p","name":"Irreducible.dvd_symm","isProp":true,"docString":"If `p` and `q` are irreducible, then `p ‚à£ q` implies `q ‚à£ p`. "},{"type":"‚àÄ {V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ] (f : V‚ÇÅ ‚Üí+ V‚ÇÇ)\n  {C : ‚Ñù} (hC : 0 ‚â§ C) (h : ‚àÄ (x : V‚ÇÅ), ‚Äñ‚Üëf x‚Äñ ‚â§ C * ‚Äñx‚Äñ), ‚ÄñAddMonoidHom.mkNormedAddGroupHom f C h‚Äñ ‚â§ C","name":"NormedAddGroupHom.mkNormedAddGroupHom_norm_le","isProp":true,"docString":"If a bounded group homomorphism map is constructed from a group homomorphism via the constructor\n`AddMonoidHom.mkNormedAddGroupHom`, then its norm is bounded by the bound given to the constructor\nif it is nonnegative. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} (h : MonotoneOn f s) (hl : BddBelow (f '' s)) (hu : BddAbove (f '' s)),\n  ‚àÉ (g : (a : Œ±) ‚Üí Œ≤), (Monotone g : Prop) ‚àß (Set.EqOn f g s : Prop)","name":"MonotoneOn.exists_monotone_extension","isProp":true,"docString":"If a function is monotone and is bounded on a set `s`, then it admits a monotone extension to\nthe whole space. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : (a : Fin (n + 1)) ‚Üí Type u} (x : Œ± (Fin.last n)) (p : (i : Fin n) ‚Üí Œ± (‚ÜëFin.castSucc i)) (i : Fin n)\n  (y : Œ± (‚ÜëFin.castSucc i)), Fin.snoc (Function.update p i y) x = Function.update (Fin.snoc p x) (‚ÜëFin.castSucc i) y","name":"Fin.snoc_update","isProp":true,"docString":"Updating a tuple and adding an element at the end commute. "},{"type":"‚àÄ {X : Type u} [inst : Lattice X] [inst_1 : JordanHolderLattice X] (s : CompositionSeries X) (x : X)\n  (hm : JordanHolderLattice.IsMaximal x (CompositionSeries.top s)) (hb : CompositionSeries.bot s ‚â§ x),\n  ‚àÉ (t : CompositionSeries X),\n    (CompositionSeries.bot t = CompositionSeries.bot s : Prop) ‚àß\n      ((CompositionSeries.length t + 1 = CompositionSeries.length s : Prop) ‚àß\n          (‚àÉ (htx : CompositionSeries.top t = x),\n              CompositionSeries.Equivalent s\n                (CompositionSeries.snoc t (CompositionSeries.top s)\n                  ((Eq.rec hm\n                        ((Eq.symm\n                              htx=:x =\n                              CompositionSeries.top\n                                t)=:x =\n                            CompositionSeries.top\n                              t)=:JordanHolderLattice.IsMaximal (CompositionSeries.top t)\n                        (CompositionSeries.top\n                          s))=:JordanHolderLattice.IsMaximal (CompositionSeries.top t) (CompositionSeries.top s))) :\n            Prop) :\n        Prop)","name":"CompositionSeries.exists_top_eq_snoc_equivalant","isProp":true,"docString":"Given a `CompositionSeries`, `s`, and an element `x`\nsuch that `x` is maximal inside `s.top` there is a series, `t`,\nsuch that `t.top = x`, `t.bot = s.bot`\nand `snoc t s.top _` is equivalent to `s`. "},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ] {Œ≥ : Œì‚ÇÄ} (h : Œ≥ ‚â† 0), {Œ≥} ‚àà nhds Œ≥","name":"WithZeroTopology.singleton_mem_nhds_of_ne_zero","isProp":true,"docString":"If `Œ≥` is a nonzero element of a linearly ordered group with zero element adjoined, then `{Œ≥}`\nis a neighbourhood of `Œ≥`. "},{"type":"‚àÄ (p : ‚Ñï) (a : ZMod p) (ha : a ^ (p - 1) = 1)\n  (hd : ‚àÄ (q : ‚Ñï) (a_1 : Nat.Prime q) (a_2 : q ‚à£ p - 1), a ^ ((p - 1) / q) ‚â† 1), Nat.Prime p","name":"lucas_primality","isProp":true,"docString":"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ‚â† 1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime.\n"},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±}\n  (hst : Disjoint (s ‚à© Function.support f) (t ‚à© Function.support f)) (hs : Set.Finite (s ‚à© Function.support f))\n  (ht : Set.Finite (t ‚à© Function.support f)),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) =\n    (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà t) ‚Ü¶ f i","name":"finsum_mem_union''","isProp":true,"docString":"A more general version of `finsum_mem_union'` that requires `s ‚à© support f` and\n`t ‚à© support f` rather than `s` and `t` to be disjoint"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.Limits.HasFiniteProducts C] (n : ‚Ñï),\n  CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete (Fin n)) C","name":"CategoryTheory.Limits.HasFiniteProducts.out","isProp":true,"docString":"`C` has finite products "},{"type":"‚àÄ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (v : (a : n) ‚Üí R)\n  (A : Matrix n n R),\n  Matrix.det (‚ÜëMatrix.of fun (i : n) (j : n) ‚Ü¶ v j * A i j) = (Finset.prod Finset.univ fun (i : n) ‚Ü¶ v i) * Matrix.det A","name":"Matrix.det_mul_row","isProp":true,"docString":"Multiplying each row by a fixed `v i` multiplies the determinant by\nthe product of the `v`s. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : LocallyFiniteOrder Œ±] {a : Œ±} {b : Œ±} (a_1 : ¬¨(a ‚â§ b : Prop)),\n  Finset.Icc a b = ‚àÖ","name":"Finset.Icc_eq_empty","isProp":true,"docString":"**Alias** of the reverse direction of `Finset.Icc_eq_empty_iff`."},{"type":"‚àÄ (R : Type u_1) (œÉ : Type u_2) [inst : CommSemiring R] [inst_1 : Fintype œÉ],\n  (Finset.prod Finset.univ fun (i : œÉ) ‚Ü¶ Polynomial.X + ‚ÜëPolynomial.C (MvPolynomial.X i)) =\n    Finset.sum (Finset.range (Fintype.card œÉ + 1)) fun (j : ‚Ñï) ‚Ü¶\n      ‚ÜëPolynomial.C (MvPolynomial.esymm œÉ R j) * Polynomial.X ^ (Fintype.card œÉ - j)","name":"MvPolynomial.prod_C_add_X_eq_sum_esymm","isProp":true,"docString":"A sum version of Vieta's formula for `MvPolynomial`: viewing `X i` as variables,\nthe product of linear terms `Œª + X i` is equal to a linear combination of\nthe symmetric polynomials `esymm œÉ R j`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.RegularMono f],\n  CategoryTheory.Mono f","name":"CategoryTheory.RegularMono.mono","isProp":true,"docString":"Every regular monomorphism is a monomorphism. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (T : CategoryTheory.Monad C) {X : CategoryTheory.Monad.Algebra T}\n  {Y : CategoryTheory.Monad.Algebra T} (f : X ‚ü∂ Y) [h : CategoryTheory.Mono (CategoryTheory.Monad.Algebra.Hom.f f)],\n  CategoryTheory.Mono f","name":"CategoryTheory.Monad.algebra_mono_of_mono","isProp":true,"docString":"Given an algebra morphism whose carrier part is a monomorphism, we get an algebra monomorphism.\n"},{"type":"‚àÄ {R : Type u_1} [inst : CommSemigroup R] {a : R} {b : R},\n  (IsRegular (a * b) : Prop) ‚Üî ((IsRegular a : Prop) ‚àß (IsRegular b : Prop) : Prop)","name":"isRegular_mul_iff","isProp":true,"docString":"A product is regular if and only if the factors are. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Nonempty Œ±] [inst : DecidableEq Œ±] (s : Finset Œ±) (f : (a : Œ±) ‚Üí ‚Ñ§) (n : ‚Ñï)\n  (h : (Finset.sum s fun (i : Œ±) ‚Ü¶ Int.natAbs (f i)) ‚â§ n),\n  ‚àÉ (Œ≤ : Type u_1),\n    ‚àÉ (x : Fintype Œ≤),\n      ‚àÉ (sgn : (a : Œ≤) ‚Üí SignType),\n        ‚àÉ (g : (a : Œ≤) ‚Üí Œ±),\n          (‚àÄ (b : Œ≤) (a : ¬¨(g b ‚àà s : Prop)), sgn b = 0 : Prop) ‚àß\n            ((Fintype.card Œ≤ = n : Prop) ‚àß\n                (‚àÄ (a : Œ±) (a_1 : a ‚àà s),\n                    (Finset.sum Finset.univ fun (i : Œ≤) ‚Ü¶ if (g i = a : Prop) then ‚Üë(sgn i) else 0) = f a :\n                  Prop) :\n              Prop)","name":"exists_signed_sum'","isProp":true,"docString":"We can decompose a sum of absolute value less than `n` into a sum of at most `n` signs. "},{"type":"‚àÄ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {s : Set X} {a : X} (a_1 : IsClosed s)\n  (a_2 : ¬¨(a ‚àà s : Prop)), Disjoint (nhdsSet s) (nhds a)","name":"RegularSpace.regular","isProp":true,"docString":"If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\nneighborhoods.  "},{"type":"‚àÄ (Œ± : Type u_1) [inst : Countable Œ±] [inst : Infinite Œ±], Nonempty (Denumerable Œ±)","name":"nonempty_denumerable","isProp":true,"docString":"See also `nonempty_encodable`, `nonempty_fintype`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddSemigroup M] [inst_1 : TopologicalSpace M] [inst_2 : T2Space M]\n  (continuous_mul_left : ‚àÄ (r : M), Continuous fun (x : M) ‚Ü¶ x + r) (s : Set M) (snemp : Set.Nonempty s)\n  (s_compact : IsCompact s) (s_add : ‚àÄ (x : M) (x_1 : x ‚àà s) (y : M) (x_2 : y ‚àà s), x + y ‚àà s),\n  ‚àÉ (m : M), (m ‚àà s : Prop) ‚àß (m + m = m : Prop)","name":"exists_idempotent_in_compact_add_subsemigroup","isProp":true,"docString":"A version of\n`exists_idempotent_of_compact_t2_of_continuous_add_left` where the idempotent lies in\nsome specified nonempty compact additive subsemigroup."},{"type":"‚àÄ {Œ± : Type u} {lt : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [self : IsOrderConnected Œ± lt] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : lt a c),\n  (lt a b : Prop) ‚à® (lt b c : Prop)","name":"IsOrderConnected.conn","isProp":true,"docString":"A connected order is one satisfying the condition `a < c ‚Üí a < b ‚à® b < c`. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] (f : E ‚Üí‚Çó.[R] F),\n  LinearPMap.graph (-f) = Submodule.map (LinearMap.prodMap LinearMap.id (-LinearMap.id)) (LinearPMap.graph f)","name":"LinearPMap.neg_graph","isProp":true,"docString":"The graph of `-f` as a pushforward. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Zero R] [inst_1 : Zero M] [self : SMulWithZero R M] (m : M), 0 ‚Ä¢ m = 0","name":"SMulWithZero.zero_smul","isProp":true,"docString":"Scalar multiplication by the scalar `0` is `0`. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (p : Submodule R M), Submodule.map (Submodule.subtype p) ‚ä§ = p","name":"Submodule.map_subtype_top","isProp":true,"docString":"Under the canonical linear map from a submodule `p` to the ambient space `M`, the image of the\nmaximal submodule of `p` is just `p `. "},{"type":"‚àÄ {R : Type u} [inst : CommMonoid R] [inst_1 : StarSemigroup R], StarModule R·µê·µí·µñ R","name":"StarSemigroup.toOpposite_starModule","isProp":true,"docString":"A commutative star monoid is a star module over its opposite via\n`Monoid.toOppositeMulAction`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {S : D}\n  {T : C ‚•§ D} (f : CategoryTheory.StructuredArrow S T),\n  f = CategoryTheory.StructuredArrow.mk (CategoryTheory.Comma.hom f)","name":"CategoryTheory.StructuredArrow.eq_mk","isProp":true,"docString":"Eta rule for structured arrows. Prefer `StructuredArrow.eta`, since equality of objects tends\nto cause problems. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (hab : a ‚â§ b) (hbc : b = c), a ‚â§ c","name":"LE.le.trans_eq","isProp":true,"docString":"**Alias** of `le_of_le_of_eq`."},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú} (hs : Convex ùïú s)\n  (hf :\n    ‚àÄ {x : ùïú} {y : ùïú} {z : ùïú} (a : x ‚àà s) (a : z ‚àà s) (a : x < y) (a : y < z),\n      (f z - f y) / (z - y) ‚â§ (f y - f x) / (y - x)),\n  ConcaveOn ùïú s f","name":"concaveOn_of_slope_anti_adjacent","isProp":true,"docString":"If for any three points `x < y < z`, the slope of the secant line of `f : ùïú ‚Üí ùïú` on `[x, y]` is\ngreater than the slope of the secant line of `f` on `[x, z]`, then `f` is concave. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] {X : C} (Y : CategoryTheory.Subobject X),\n  (CategoryTheory.Simple (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor CategoryTheory.Subobject.underlying) Y) :\n      Prop) ‚Üî\n    (IsAtom Y : Prop)","name":"CategoryTheory.subobject_simple_iff_isAtom","isProp":true,"docString":"A subobject is simple iff it is an atom in the subobject lattice. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemigroupWithZero Œ±] {a : Œ±}, (0 ‚à£ a : Prop) ‚Üî (a = 0 : Prop)","name":"zero_dvd_iff","isProp":true,"docString":"Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±}, Metric.hausdorffDist ‚àÖ s = 0","name":"Metric.hausdorffDist_empty'","isProp":true,"docString":"The Hausdorff distance to the empty set vanishes (if you want to have the more reasonable\nvalue `‚àû` instead, use `EMetric.hausdorffEdist`, which takes values in `‚Ñù‚â•0‚àû`) "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (Module.rank K V ‚â§ 1 : Prop) ‚Üî (‚àÉ (v‚ÇÄ : V), ‚àÄ (v : V), ‚àÉ (r : K), r ‚Ä¢ v‚ÇÄ = v : Prop)","name":"rank_le_one_iff","isProp":true,"docString":"A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] {s : Finset Œ±} {t : Finset Œ≤} {f : (a : Œ±) ‚Üí Œ≤} {n : ‚Ñï}\n  (hf : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), f a ‚àà t) (hn : Finset.card t * n < Finset.card s),\n  ‚àÉ (y : Œ≤), (y ‚àà t : Prop) ‚àß (n < Finset.card (Finset.filter (fun (x : Œ±) ‚Ü¶ f x = y) s) : Prop)","name":"Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to","isProp":true,"docString":"The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with\nat least as many pigeons as the ceiling of the average number of pigeons across all pigeonholes.\n(\"The maximum is at least the mean\" specialized to integers.)\n\nMore formally, given a function between finite sets `s` and `t` and a natural number `n` such that\n`card t * n < card s`, there exists `y ‚àà t` such that its preimage in `s` has more than `n`\nelements. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] (s : Subsemiring R) {l : List R} (a : ‚àÄ (x : R) (a : x ‚àà l), x ‚àà s),\n  List.prod l ‚àà s","name":"Subsemiring.list_prod_mem","isProp":true,"docString":"Product of a list of elements in a `Subsemiring` is in the `Subsemiring`. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E], UniformAddGroup E","name":"SeminormedAddCommGroup.to_uniformAddGroup","isProp":true,"docString":"A seminormed group is a uniform additive group, i.e., addition and subtraction are\nuniformly continuous."},{"type":"‚àÄ (R : Type u) (M : Type v) (N : Type w) [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] [inst_6 : AddCommGroup N]\n  [inst_7 : Module R N] [inst_8 : Module.Free R N] [inst_9 : Module.Finite R N],\n  FiniteDimensional.finrank R (M √ó N) = FiniteDimensional.finrank R M + FiniteDimensional.finrank R N","name":"FiniteDimensional.finrank_prod","isProp":true,"docString":"The finrank of `M √ó N` is `(finrank R M) + (finrank R N)`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R} (max : Ideal.IsMaximal M)\n  (not_field : ¬¨(IsField R : Prop)), M ‚â† ‚ä•","name":"Ring.ne_bot_of_isMaximal_of_not_isField","isProp":true,"docString":"When a ring is not a field, the maximal ideals are nontrivial. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {f : (a : ‚Ñ§) ‚Üí Œ±} (hf : Monotone f) (n : ‚Ñ§) {x : Œ±} (h1 : f n < x)\n  (h2 : x < f (n + 1)) (a : ‚Ñ§), f a ‚â† x","name":"Monotone.ne_of_lt_of_lt_int","isProp":true,"docString":"If `f` is a monotone function from `‚Ñ§` to a preorder and `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú} (hs : Convex ùïú s)\n  (hf :\n    ‚àÄ {x : ùïú} {y : ùïú} {z : ùïú} (a : x ‚àà s) (a : z ‚àà s) (a : x < y) (a : y < z),\n      (f y - f x) / (y - x) < (f z - f y) / (z - y)),\n  StrictConvexOn ùïú s f","name":"strictConvexOn_of_slope_strict_mono_adjacent","isProp":true,"docString":"If for any three points `x < y < z`, the slope of the secant line of `f : ùïú ‚Üí ùïú` on `[x, y]` is\nstrictly less than the slope of the secant line of `f` on `[x, z]`, then `f` is strictly convex. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (T : CategoryTheory.Monad C) {X : CategoryTheory.Monad.Algebra T}\n  {Y : CategoryTheory.Monad.Algebra T} (f : X ‚ü∂ Y) [h : CategoryTheory.Epi (CategoryTheory.Monad.Algebra.Hom.f f)],\n  CategoryTheory.Epi f","name":"CategoryTheory.Monad.algebra_epi_of_epi","isProp":true,"docString":"Given an algebra morphism whose carrier part is an epimorphism, we get an algebra epimorphism.\n"},{"type":"‚àÄ {H : Type u_1} {M : Type u_2} {H' : Type u_3} {M' : Type u_4} [inst : TopologicalSpace H]\n  [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M] [inst_3 : TopologicalSpace H']\n  [inst_4 : TopologicalSpace M'] [inst_5 : ChartedSpace H' M'] {G : StructureGroupoid H} {G' : StructureGroupoid H'}\n  {e : LocalHomeomorph M H} {e' : LocalHomeomorph M H} {f : LocalHomeomorph M' H'} {f' : LocalHomeomorph M' H'}\n  {P : (a : (a : H) ‚Üí H') ‚Üí (a : Set H) ‚Üí (a : H) ‚Üí Prop} {g : (a : M) ‚Üí M'} {s : Set M} {x : M}\n  (hG : StructureGroupoid.LocalInvariantProp G G' P) (he : e ‚àà StructureGroupoid.maximalAtlas M G)\n  (xe : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e)) (he' : e' ‚àà StructureGroupoid.maximalAtlas M G)\n  (xe' : x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv e')) (hf : f ‚àà StructureGroupoid.maximalAtlas M' G')\n  (xf : g x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv f)) (hf' : f' ‚àà StructureGroupoid.maximalAtlas M' G')\n  (xf' : g x ‚àà LocalEquiv.source (LocalHomeomorph.toLocalEquiv f')) (hgs : ContinuousWithinAt g s x),\n  (P (‚Üëf ‚àò g ‚àò ‚Üë(LocalHomeomorph.symm e)) (‚Üë(LocalHomeomorph.symm e) ‚Åª¬π' s) (‚Üëe x) : Prop) ‚Üî\n    (P (‚Üëf' ‚àò g ‚àò ‚Üë(LocalHomeomorph.symm e')) (‚Üë(LocalHomeomorph.symm e') ‚Åª¬π' s) (‚Üëe' x) : Prop)","name":"StructureGroupoid.LocalInvariantProp.liftPropWithinAt_indep_chart_aux","isProp":true,"docString":"If a property of a germ of function `g` on a pointed set `(s, x)` is invariant under the\nstructure groupoid (by composition in the source space and in the target space), then\nexpressing it in charted spaces does not depend on the element of the maximal atlas one uses\nboth in the source and in the target manifolds, provided they are defined around `x` and `g x`\nrespectively, and provided `g` is continuous within `s` at `x` (otherwise, the local behavior\nof `g` at `x` can not be captured with a chart in the target). "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {x : E} {y : E} (h : SameRay ‚Ñù x y),\n  ‚Äñx + y‚Äñ = ‚Äñx‚Äñ + ‚Äñy‚Äñ","name":"SameRay.norm_add","isProp":true,"docString":"If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm\nof `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex\nspace. "},{"type":"‚àÄ {A : Type u_1} [inst : AddCommMonoid A] (a : A) (b : A) (c : A),\n  (c ‚àà AddSubmonoid.closure {a, b} : Prop) ‚Üî (‚àÉ (m : ‚Ñï), ‚àÉ (n : ‚Ñï), m ‚Ä¢ a + n ‚Ä¢ b = c : Prop)","name":"AddSubmonoid.mem_closure_pair","isProp":true,"docString":"An element is in the closure of a two-element set if it is a linear combination of\nthose two elements."},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V ‚Üí‚Çó[K] V} {g : V ‚Üí‚Çó[K] V},\n  (LinearMap.comp f g = LinearMap.id : Prop) ‚Üî (LinearMap.comp g f = LinearMap.id : Prop)","name":"LinearMap.comp_eq_id_comm","isProp":true,"docString":"In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommGroup M] (f : (a : ‚Ñï) ‚Üí M) (n : ‚Ñï),\n  (Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f (i + 1) - f i) = f n - f 0","name":"Finset.sum_range_sub","isProp":true,"docString":"A telescoping sum along `{0, ..., n - 1}` of an additive commutative group valued\nfunction reduces to the difference of the last and first terms."},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} {a : Œ±} [inst : Applicative m]\n  [inst_1 : LawfulApplicative m] (h : p a), SatisfiesM p (pure a)","name":"SatisfiesM.pure","isProp":true,"docString":"`SatisfiesM` distributes over `pure`, general version / weakest precondition version. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (self : CategoryTheory.GrothendieckTopology C) ‚¶ÉX : C‚¶Ñ ‚¶ÉY : C‚¶Ñ\n  ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ (f : Y ‚ü∂ X) (a : S ‚àà CategoryTheory.GrothendieckTopology.sieves self X),\n  CategoryTheory.Sieve.pullback f S ‚àà CategoryTheory.GrothendieckTopology.sieves self Y","name":"CategoryTheory.GrothendieckTopology.pullback_stable'","isProp":true,"docString":"Stability under pullback. Use `GrothendieckTopology.pullback_stable`. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} [inst : NonUnitalNonAssocSemiring Œ±] [self : CentroidHomClass F Œ±] (f : F)\n  (a : Œ±) (b : Œ±), ‚Üëf (a * b) = ‚Üëf a * b","name":"CentroidHomClass.map_mul_right","isProp":true,"docString":"Commutativity of centroid homomorphims with right multiplication. "},{"type":"‚àÄ {Œ± : Type u} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {a : Œ±} {b : Œ±} (p : (a : Œ±) ‚Üí Prop) (l : List Œ±) (h : List.Chain r a l)\n  (hb : List.getLast (a :: l) ((List.cons_ne_nil a l=:a :: l ‚â† [])=:a :: l ‚â† []) = b)\n  (carries : ‚àÄ ‚¶Éx : Œ±‚¶Ñ ‚¶Éy : Œ±‚¶Ñ (a : r x y) (a : p y), p x) (final : p b) (i : Œ±) (a : i ‚àà a :: l), p i","name":"List.Chain.induction","isProp":true,"docString":"Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y ‚Üí p y ‚Üí p x` then\nthe predicate is true everywhere in the chain and at `a`.\nThat is, we can propagate the predicate up the chain.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : (a : Œ±) ‚Üí Œ≤) {l : List Œ±} {n : Fin (List.length l)},\n  f (List.get l n) =\n    List.get (List.map f l)\n      { val := ‚Üën,\n        isLt :=\n          ((Eq.rec ((Fin.isLt n=:‚Üën < List.length l)=:‚Üën < List.length l)\n                ((Eq.symm\n                      ((List.length_map l\n                            f=:List.length (List.map f l) =\n                            List.length\n                              l)=:List.length (List.map f l) =\n                          List.length\n                            l)=:List.length l =\n                      List.length\n                        (List.map f\n                          l))=:List.length l =\n                    List.length (List.map f l))=:‚Üën < List.length (List.map f l))=:‚Üën < List.length (List.map f l)) }","name":"List.get_map_rev","isProp":true,"docString":"A version of `get_map` that can be used for rewriting. "},{"type":"‚àÄ {B : Type u_2} {F : Type u_1} {Z : Type u_3} [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F]\n  [inst_2 : TopologicalSpace Z] {proj : (a : Z) ‚Üí B} [inst_3 : Nonempty F]\n  (h : IsHomeomorphicTrivialFiberBundle F proj), Function.Surjective proj","name":"IsHomeomorphicTrivialFiberBundle.surjective_proj","isProp":true,"docString":"The projection from a trivial fiber bundle to its base is surjective. "},{"type":"‚àÄ {p : ‚Ñï} (n : ‚Ñï), ‚Üë(padicValNat p n) = padicValRat p ‚Üën","name":"padicValRat_of_nat","isProp":true,"docString":"`padicValRat` coincides with `padicValNat`. "},{"type":"‚àÄ {G : Type u} [inst : AddGroup G] {x : G} (hx : IsOfFinAddOrder x), IsOfFinAddOrder (-x)","name":"IsOfFinAddOrder.neg","isProp":true,"docString":"Inverses of elements of finite additive order have finite additive order."},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  {f : Filter Œ±} {a : Œ±} [inst_3 : Filter.NeBot f] (h : f ‚â§ nhds a), Filter.liminf‚Çõ f = a","name":"liminf‚Çõ_eq_of_le_nhds","isProp":true,"docString":"If a filter is converging, its limsup coincides with its limit. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Zero Œ±] [inst_1 : Zero Œ≤] [inst_2 : SMulWithZero Œ± Œ≤] {s : Set Œ≤}\n  (h : Set.Nonempty s), 0 ‚Ä¢ s = 0","name":"Set.zero_smul_set","isProp":true,"docString":"A nonempty set is scaled by zero to the singleton set containing 0. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : IsCompact s) (ht : IsClosed t),\n  IsCompact (s ‚à© t)","name":"IsCompact.inter_right","isProp":true,"docString":"The intersection of a compact set and a closed set is a compact set. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú} (hf : ConvexOn ùïú s f) {x : ùïú} {y : ùïú}\n  (hx : x ‚àà s) (hxy : x < y) (hxy' : f x < f y), StrictMonoOn f (s ‚à© Set.Ici y)","name":"ConvexOn.strict_mono_of_lt","isProp":true,"docString":"If `f` is convex on a set `s` in a linearly ordered field, and `f x < f y` for two points\n`x < y` in `s`, then `f` is strictly monotone on `s ‚à© [y, ‚àû)`. "},{"type":"‚àÄ {Œ± : Sort u} {motive : (a : Œ±) ‚Üí Prop} {a : Œ±} {b : Œ±} (h‚ÇÅ : a = b) (h‚ÇÇ : motive a), motive b","name":"Eq.subst","isProp":true,"docString":"The substitution principle for equality. If `a = b ` and `P a` holds,\nthen `P b` also holds. We conventionally use the name `motive` for `P` here,\nso that you can specify it explicitly using e.g.\n`Eq.subst (motive := fun x => x < 5)` if it is not otherwise inferred correctly.\n\nThis theorem is the underlying mechanism behind the `rw` tactic, which is\nessentially a fancy algorithm for finding good `motive` arguments to usefully\napply this theorem to replace occurrences of `a` with `b` in the goal or\nhypotheses.\n\nFor more information: [Equality](https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤]\n  {F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±},\n  (UniformEquicontinuous F : Prop) ‚Üî (UniformContinuous (‚ÜëUniformFun.ofFun ‚àò Function.swap F) : Prop)","name":"uniformEquicontinuous_iff_uniformContinuous","isProp":true,"docString":"A family `ùìï : Œπ ‚Üí Œ≤ ‚Üí Œ±` is uniformly equicontinuous iff the function `swap ùìï : Œ≤ ‚Üí Œπ ‚Üí Œ±` is\nuniformly continuous *when `Œπ ‚Üí Œ±` is equipped with the uniform structure of uniform convergence*.\nThis is very useful for developping the equicontinuity API, but it should not be used directly\nfor other purposes. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : IsSuccArchimedean Œ±]\n  [inst_3 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : Monotone f) (m : Œ±) (n : Œ±),\n  (Set.union·µ¢ fun (i : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà Set.Ico m n) ‚Ü¶ Set.Ioc (f i) (f (Order.succ i))) =\n    Set.Ioc (f m) (f n)","name":"Monotone.bunion·µ¢_Ico_Ioc_map_succ","isProp":true,"docString":"If `Œ±` is a linear archimedean succ order and `Œ≤` is a linear order, then for any monotone\nfunction `f` and `m n : Œ±`, the union of intervals `Set.Ioc (f i) (f (Order.succ i))`, `m ‚â§ i < n`,\nis equal to `Set.Ioc (f m) (f n)` "},{"type":"‚àÄ {V‚ÇÅ : Type u_1} {V‚ÇÇ : Type u_2} [inst : SeminormedAddCommGroup V‚ÇÅ] [inst_1 : SeminormedAddCommGroup V‚ÇÇ], ‚Äñ0‚Äñ = 0","name":"NormedAddGroupHom.opNorm_zero","isProp":true,"docString":"The norm of the `0` operator is `0`. "},{"type":"‚àÄ (C : Type u) [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasPullbacks C],\n  CategoryTheory.Pretopology.toGrothendieck C ‚ä• = ‚ä•","name":"CategoryTheory.Pretopology.toGrothendieck_bot","isProp":true,"docString":"The trivial pretopology induces the trivial grothendieck topology. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] [inst_2 : DenselyOrdered Œ≤]\n  [inst_3 : NoMinOrder Œ≤] [inst_4 : NoMaxOrder Œ≤] [inst_5 : Nonempty Œ≤] (f : Order.PartialIso Œ± Œ≤) (a : Œ±),\n  ‚àÉ (b : Œ≤), ‚àÄ (p : Œ± √ó Œ≤) (a_1 : p ‚àà ‚Üëf), cmp (Prod.fst p) a = cmp (Prod.snd p) b","name":"Order.PartialIso.exists_across","isProp":true,"docString":"For each `a`, we can find a `b` in the codomain, such that `a`'s relation to\nthe domain of `f` is `b`'s relation to the image of `f`.\n\nThus, if `a` is not already in `f`, then we can extend `f` by sending `a` to `b`.\n"},{"type":"‚àÄ {Œ± : Type u_1} [inst : OrderedSemiring Œ±] {t : ‚Üë(Set.Icc 0 1)}, 0 ‚â§ t","name":"Set.Icc.nonneg","isProp":true,"docString":"like `coe_nonneg`, but with the inequality in `Icc (0:Œ±) 1`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : CompleteLattice Œ±] (f : (a : Œπ) ‚Üí Œ±),\n  (inf·µ¢ fun (i : { i : Œπ // f i ‚â† ‚ä§ }) ‚Ü¶ f ‚Üëi) = inf·µ¢ fun (i : Œπ) ‚Ü¶ f i","name":"inf·µ¢_ne_top_subtype","isProp":true,"docString":"When taking the infimum of `f : Œπ ‚Üí Œ±`, the elements of `Œπ` on which `f` gives `‚ä§` can be\ndropped, without changing the result. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú] {s : Set ùïú}\n  (a : StrictConvex ùïú s), Set.OrdConnected s","name":"StrictConvex.ordConnected","isProp":true,"docString":"**Alias** of the forward direction of `strictConvex_iff_ordConnected`."},{"type":"‚àÄ {Œ± : Type ua} [inst : UniformSpace Œ±] {s : Set Œ±},\n  (IsOpen s : Prop) ‚Üî\n    (‚àÄ (x : Œ±) (a : x ‚àà s), ‚àÉ (V : Set (Œ± √ó Œ±)), (V ‚àà uniformity Œ± : Prop) ‚àß (UniformSpace.ball x V ‚äÜ s : Prop) : Prop)","name":"isOpen_iff_ball_subset","isProp":true,"docString":"See also `isOpen_iff_open_ball_subset`. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Bijective f) (b : Œ≤), ‚àÉ! (a : Œ±), f a = b","name":"Function.Bijective.existsUnique","isProp":true,"docString":"Shorthand for using projection notation with `Function.bijective_iff_existsUnique`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {t : Set Œ±} (hs : BddBelow s)\n  (sne : Set.Nonempty s) (ht : BddBelow t) (tne : Set.Nonempty t), inf‚Çõ (s ‚à™ t) = inf‚Çõ s ‚äì inf‚Çõ t","name":"cinf‚Çõ_union","isProp":true,"docString":"The `inf‚Çõ` of a union of two sets is the min of the infima of each subset, under the assumptions\nthat all sets are bounded below and nonempty."},{"type":"‚àÄ {M : Type u_1} [inst : Group M] (c : Con M) {w : M} {x : M} (a : ‚Üëc w x), ‚Üëc w‚Åª¬π x‚Åª¬π","name":"Con.inv","isProp":true,"docString":"Multiplicative congruence relations preserve inversion. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] {x : Œ±} {E : Set Œ±} (hx : x ‚àà E) (Œ¥ : ‚Ñù),\n  Metric.closedBall x Œ¥ ‚äÜ Metric.cthickening Œ¥ E","name":"Metric.closedBall_subset_cthickening","isProp":true,"docString":"The closed ball of radius `Œ¥` centered at a point of `E` is included in the closed\nthickening of `E`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_1} {Œ≥ : Type u_1} (f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥) (s : Set Œ±) (t : Set Œ≤),\n  Set.image2 f s t = Seq.seq (f <$> s) fun (x : Unit) ‚Ü¶ t","name":"Set.image2_def","isProp":true,"docString":"`Set.image2` in terms of monadic operations. Note that this can't be taken as the definition\nbecause of the lack of universe polymorphism. "},{"type":"‚àÄ {H : Type u} [inst : TopologicalSpace H] (G : StructureGroupoid H),\n  (ClosedUnderRestriction G : Prop) ‚Üî (idRestrGroupoid ‚â§ G : Prop)","name":"closedUnderRestriction_iff_id_le","isProp":true,"docString":"A groupoid is closed under restriction if and only if it contains the trivial restriction-closed\ngroupoid. "},{"type":"‚àÄ {G‚ÇÄ : Type u_2} {G‚ÇÄ' : Type u_1} {F : Type u_3} [inst : GroupWithZero G‚ÇÄ] [inst_1 : GroupWithZero G‚ÇÄ']\n  [inst_2 : MonoidWithZeroHomClass F G‚ÇÄ G‚ÇÄ'] (f : F) (a : G‚ÇÄ), ‚Üëf a‚Åª¬π = (‚Üëf a)‚Åª¬π","name":"map_inv‚ÇÄ","isProp":true,"docString":"A monoid homomorphism between groups with zeros sending `0` to `0` sends `a‚Åª¬π` to `(f a)‚Åª¬π`. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] {X : C} {Y : C} {Z : C} (a : X ‚ü∂ Z) (b : Y ‚ü∂ Z)\n  [inst_5 : CategoryTheory.Mono a] [inst_6 : CategoryTheory.Mono b],\n  CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan a b)","name":"CategoryTheory.NormalMonoCategory.pullback_of_mono","isProp":true,"docString":"The pullback of two monomorphisms exists. "},{"type":"‚àÄ (k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [inst : Semiring k] [inst_1 : Mul G] {A : Type u‚ÇÉ} [inst_2 : NonUnitalNonAssocSemiring A]\n  [inst_3 : DistribMulAction k A] {œÜ‚ÇÅ : MonoidAlgebra k G ‚Üí‚Çô‚Çê[k] A} {œÜ‚ÇÇ : MonoidAlgebra k G ‚Üí‚Çô‚Çê[k] A}\n  (h :\n    MulHom.comp (NonUnitalAlgHom.toMulHom œÜ‚ÇÅ) (MonoidAlgebra.ofMagma k G) =\n      MulHom.comp (NonUnitalAlgHom.toMulHom œÜ‚ÇÇ) (MonoidAlgebra.ofMagma k G)),\n  œÜ‚ÇÅ = œÜ‚ÇÇ","name":"MonoidAlgebra.nonUnitalAlgHom_ext'","isProp":true,"docString":"See note [partially-applied ext lemmas]. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (self : IsRingHom f) (x : Œ±) (y : Œ±),\n  f (x + y) = f x + f y","name":"IsRingHom.map_add","isProp":true,"docString":"The proposition that `f` preserves addition. "},{"type":"‚àÄ {Œ± : Type u_1} {a : Œ±} {b : Œ±} {c : Œ±} [inst : Mul Œ±] [inst_1 : Zero Œ±] [inst_2 : Preorder Œ±]\n  [inst_3 : MulPosMonoRev Œ±] (bc : b * a ‚â§ c * a) (a0 : 0 < a), b ‚â§ c","name":"le_of_mul_le_mul_of_pos_right","isProp":true,"docString":"**Alias** of `le_of_mul_le_mul_right`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (a : StrictMono f),\n  StrictAnti (f ‚àò ‚ÜëOrderDual.ofDual)","name":"StrictMono.dual_left","isProp":true,"docString":"**Alias** of the reverse direction of `strictAnti_comp_ofDual_iff`."},{"type":"‚àÄ {M : Type u_2} {F : Type u_1} [inst : Monoid F] (c : (a : F) ‚Üí (a : M) ‚Üí M) (h1 : c 1 = id)\n  (hmul : ‚àÄ (f : F) (g : F), c (f * g) = c f ‚àò c g) (f : F) (n : ‚Ñï), c (f ^ n) = c f^[n]","name":"hom_coe_pow","isProp":true,"docString":"An auxiliary lemma that can be used to prove `‚áë(f ^ n) = (‚áëf^[n])`. "},{"type":"‚àÄ {n : ‚Ñï}, (n % 2 = 1 : Prop) ‚Üî ((n % 4 = 1 : Prop) ‚à® (n % 4 = 3 : Prop) : Prop)","name":"Nat.odd_mod_four_iff","isProp":true,"docString":"A natural number is odd iff it has residue `1` or `3` mod `4`"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : CoheytingAlgebra Œ±] [inst_1 : CoheytingAlgebra Œ≤] (self : CoheytingHom Œ± Œ≤),\n  SupHom.toFun (LatticeHom.toSupHom (CoheytingHom.toLatticeHom self)) ‚ä§ = ‚ä§","name":"CoheytingHom.map_top'","isProp":true,"docString":"The proposition that a co-Heyting homomorphism preserves the top element."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : (a : Œ±) ‚Üí Œ≤} (hf : Function.Surjective f) (h : Nat.card Œ≤ = 0), Nat.card Œ± = 0","name":"Finite.card_eq_zero_of_surjective","isProp":true,"docString":"NB: `Nat.card` is defined to be `0` for infinite types. "},{"type":"‚àÄ {Œ± : Type u} {Œ≥ : Type u_1} [inst : TopologicalSpace Œ≥] [inst_1 : T2Space Œ≥] [inst_2 : CompactSpace Œ≥]\n  {f : (a : Œ±) ‚Üí Œ≥} {b : Ultrafilter Œ±} {c : Œ≥},\n  (Ultrafilter.extend f b = c : Prop) ‚Üî (‚Üë(Ultrafilter.map f b) ‚â§ nhds c : Prop)","name":"ultrafilter_extend_eq_iff","isProp":true,"docString":"The value of `Ultrafilter.extend f` on an ultrafilter `b` is the\nunique limit of the ultrafilter `b.map f` in `Œ≥`. "},{"type":"‚àÄ {R : Type u} {M : Type v} [inst : Monoid R] [inst_1 : MulAction R M] {p : SubMulAction R M} (m : { x : M // x ‚àà p }),\n  MulAction.Stabilizer.submonoid R m = MulAction.Stabilizer.submonoid R ‚Üëm","name":"SubMulAction.stabilizer_of_subMul.submonoid","isProp":true,"docString":"Stabilizers in monoid SubMulAction coincide with stabilizers in the ambient space "},{"type":"‚àÄ {k : Type u} [inst : Field k] {G : Type u} [inst_1 : Fintype G] [inst_2 : Invertible ‚Üë(Fintype.card G)]\n  [inst_3 : Group G] {V : Type u} [inst_4 : AddCommGroup V] [inst_5 : Module k V]\n  [inst_6 : Module (MonoidAlgebra k G) V] [inst_7 : IsScalarTower k (MonoidAlgebra k G) V],\n  ComplementedLattice (Submodule (MonoidAlgebra k G) V)","name":"MonoidAlgebra.Submodule.complementedLattice","isProp":true,"docString":"This also implies an instance `IsSemisimpleModule (MonoidAlgebra k G) V`. "},{"type":"‚àÄ {n : Type u_1} {ùïú : Type u_2} [inst : Field ùïú] [inst_1 : DecidableEq n] [inst_2 : Fintype n] (M : Matrix n n ùïú),\n  ‚àÉ (L : List (Matrix.TransvectionStruct n ùïú)),\n    ‚àÉ (L' : List (Matrix.TransvectionStruct n ùïú)),\n      ‚àÉ (D : (a : n) ‚Üí ùïú),\n        Matrix.mul (Matrix.mul (List.prod (List.map Matrix.TransvectionStruct.toMatrix L)) M)\n            (List.prod (List.map Matrix.TransvectionStruct.toMatrix L')) =\n          Matrix.diagonal D","name":"Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal","isProp":true,"docString":"Any matrix can be reduced to diagonal form by elementary operations. "},{"type":"‚àÄ {X : Type u} {Y : Type u} {Z : Type u} (f : X ‚ü∂ Y) (g : X ‚ü∂ Y) (œÄ : Y ‚ü∂ Z) (e : f ‚â´ œÄ = g ‚â´ œÄ)\n  (h : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.Cofork.ofœÄ œÄ e)) (U : Set Y) (H : f ‚Åª¬π' U = g ‚Åª¬π' U),\n  œÄ ‚Åª¬π' (œÄ '' U) = U","name":"CategoryTheory.Limits.Types.coequalizer_preimage_image_eq_of_preimage_eq","isProp":true,"docString":"If `œÄ : Y ‚ü∂ Z` is an equalizer for `(f, g)`, and `U ‚äÜ Y` such that `f ‚Åª¬π' U = g ‚Åª¬π' U`,\nthen `œÄ ‚Åª¬π' (œÄ '' U) = U`.\n"},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : LinearOrder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (h‚ÇÅ : StrictMono f)\n  (A : Finset Œ±) (B : Finset Œ±),\n  (Finset.toColex (Finset.image f A) ‚â§ Finset.toColex (Finset.image f B) : Prop) ‚Üî\n    (Finset.toColex A ‚â§ Finset.toColex B : Prop)","name":"Colex.hom_le_iff","isProp":true,"docString":"Strictly monotone functions preserve the colex ordering. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\n  [inst_2 : NonUnitalRingHomClass F R S] {f : F} {g : F} {s : Set R} (h : Set.EqOn (‚Üëf) (‚Üëg) s),\n  Set.EqOn ‚Üëf ‚Üëg ‚Üë(NonUnitalSubsemiring.closure s)","name":"NonUnitalRingHom.eqOn_sclosure","isProp":true,"docString":"If two non-unital ring homomorphisms are equal on a set, then they are equal on its\nnon-unital subsemiring closure. "},{"type":"‚àÄ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {Œπ : Type u_1} (v : (a : Œπ) ‚Üí M) (i : LinearIndependent R v) (w : Finset M)\n  (s : Submodule.span R ‚Üëw = ‚ä§), Cardinal.mk Œπ ‚â§ ‚Üë(Finset.card w)","name":"linearIndependent_le_span_finset","isProp":true,"docString":"A version of `linearIndependent_le_span` for `Finset`. "},{"type":"‚àÄ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : (a : X) ‚Üí Y}, (Continuous f : Prop) ‚Üî (SeqContinuous f : Prop)","name":"continuous_iff_seqContinuous","isProp":true,"docString":"If the domain of a function is a sequential space, then continuity of this function is\nequivalent to its sequential continuity. "},{"type":"‚àÄ {Œπ : Type u'} {R : Type u_1} {M : Type u_2} {M' : Type u_3} {v : (a : Œπ) ‚Üí M} [inst : Semiring R]\n  [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M'] [inst_3 : Module R M] [inst_4 : Module R M'] (f : M ‚Üí‚Çó[R] M')\n  (hfv : LinearIndependent R (‚Üëf ‚àò v)), LinearIndependent R v","name":"LinearIndependent.of_comp","isProp":true,"docString":"If the image of a family of vectors under a linear map is linearly independent, then so is\nthe original family. "},{"type":"‚àÄ {Œ± : Type u} [inst : NonUnitalNonAssocRing Œ±] {a : Œ±} {b : Œ±} {c : Œ±} {d : Œ±} {e : Œ±} (h : a * e + c = b * e + d),\n  (a - b) * e + c = d","name":"sub_mul_add_eq_of_mul_add_eq_mul_add","isProp":true,"docString":"A simplification of one side of an equation exploiting right distributivity in rings\nand the definition of subtraction. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {s : Set X} (hs : IsSeqClosed s), IsClosed s","name":"IsSeqClosed.isClosed","isProp":true,"docString":"In a sequential space, a sequentially closed set is closed. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : Field ùïú] {r : ‚Ñï} (M : Matrix (Fin r ‚äï Unit) (Fin r ‚äï Unit) ùïú)\n  (hM : M (Sum.inr ()) (Sum.inr ()) ‚â† 0) (i : Fin r),\n  Matrix.mul (List.prod (Matrix.Pivot.listTransvecCol M)) M (Sum.inl i) (Sum.inr ()) = 0","name":"Matrix.Pivot.listTransvecCol_mul_last_col","isProp":true,"docString":"Multiplying by all the matrices in `listTransvecCol M` kills all the coefficients in the\nlast column but the last one. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {G : J ‚•§ C} [inst_2 : CategoryTheory.Limits.HasColimit F] (Œ± : G ‚âÖ F), CategoryTheory.Limits.HasColimit G","name":"CategoryTheory.Limits.hasColimitOfIso","isProp":true,"docString":"If `F` has a colimit, so does any naturally isomorphic functor.\n"},{"type":"‚àÄ {M : Type u} [self : AddCommMonoid M] (a : M) (b : M), a + b = b + a","name":"AddCommMonoid.add_comm","isProp":true,"docString":"Addition is commutative in an additive commutative semigroup. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : AddCommMonoid Œ±] {m : ‚Ñï} (a : (a : Fin m) ‚Üí Œ±),\n  FinVec.sum a = Finset.sum Finset.univ fun (i : Fin m) ‚Ü¶ a i","name":"FinVec.sum_eq","isProp":true,"docString":"This can be used to prove\n```lean\nexample [AddCommMonoid Œ±] (a : Fin 3 ‚Üí Œ±) : (‚àë i, a i) = a 0 + a 1 + a 2 :=\n  (sum_eq _).symm\n```\n"},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±}\n  {g : (a : Œπ) ‚Üí Œ±} (hfg : AntivaryOn f g ‚Üës) (hœÉ : (setOf fun (x : Œπ) ‚Ü¶ ‚ÜëœÉ x ‚â† x) ‚äÜ ‚Üës),\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i)) = Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (AntivaryOn f (g ‚àò ‚ÜëœÉ) ‚Üës : Prop)","name":"AntivaryOn.sum_mul_eq_sum_mul_comp_perm_iff","isProp":true,"docString":"**Equality case of the Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich antivary together, is unchanged by a permutation if and only if `f` and `g ‚àò œÉ` antivary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} [inst : CommMonoid Œ≤] (f : (a : Œ±) ‚Üí Œ≤) {p : (a : Œ±) ‚Üí Prop}\n  [inst_1 : DecidablePred p] (h : ‚àÄ (x : Œ±) (a : x ‚àà s), p x),\n  (Finset.prod (Finset.subtype p s) fun (x : Subtype p) ‚Ü¶ f ‚Üëx) = Finset.prod s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.prod_subtype_of_mem","isProp":true,"docString":"If all elements of a `Finset` satisfy the predicate `p`, a product\nover `s.subtype p` equals that product over `s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Nonempty Œ±] [inst : SemilatticeSup Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤},\n  (Filter.Tendsto f Filter.atTop Filter.atTop : Prop) ‚Üî (‚àÄ (b : Œ≤), ‚àÉ (i : Œ±), ‚àÄ (a : Œ±) (a_1 : i ‚â§ a), b ‚â§ f a : Prop)","name":"Filter.tendsto_atTop_atTop","isProp":true,"docString":"A function `f` grows to `+‚àû` independent of an order-preserving embedding `e`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} {b : Œ±} (a : Set.Nonempty s)\n  (a : ‚àÄ (a : Œ±) (a_1 : a ‚àà s), b ‚â§ a) (a : ‚àÄ (w : Œ±) (a : b < w), ‚àÉ (a : Œ±), (a ‚àà s : Prop) ‚àß (a < w : Prop)),\n  inf‚Çõ s = b","name":"cinf‚Çõ_eq_of_forall_ge_of_forall_gt_exists_lt","isProp":true,"docString":"Introduction rule to prove that `b` is the infimum of `s`: it suffices to check that `b`\nis smaller than all elements of `s`, and that this is not the case of any `w>b`.\nSee `inf‚Çõ_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in complete lattices. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} {l : Filter Œ±} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±}\n  (self : Filter.HasCountableBasis l p s), Set.Countable (setOf p)","name":"Filter.HasCountableBasis.countable","isProp":true,"docString":"The set of `i` that satisfy the predicate `p` is countable. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ' : Sort u_2} (s : (a : Œπ') ‚Üí Set Œ±),\n  (Set.inter·µ¢ fun (i : Œπ') ‚Ü¶ s i) =\n    Set.inter·µ¢ fun (t : Finset (PLift Œπ')) ‚Ü¶\n      Set.inter·µ¢ fun (i : PLift Œπ') ‚Ü¶ Set.inter·µ¢ fun (h : i ‚àà t) ‚Ü¶ s (PLift.down i)","name":"Set.inter·µ¢_eq_inter·µ¢_finset'","isProp":true,"docString":"Intersection of an indexed family of sets `s : Œπ ‚Üí Set Œ±` is equal to the intersection of the\nintersections of finite subfamilies. This version works for `Œπ : Sort*`. See also\n`inter·µ¢_eq_inter·µ¢_finset` for a version that assumes `Œπ : Type _` but avoids `plift`s in the right\nhand side. "},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {v‚ÇÅ : RayVector R M} {v‚ÇÇ : RayVector R M}, (-v‚ÇÅ ‚âà -v‚ÇÇ : Prop) ‚Üî (v‚ÇÅ ‚âà v‚ÇÇ : Prop)","name":"RayVector.equiv_neg_iff","isProp":true,"docString":"If two nonzero vectors are equivalent, so are their negations. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±],\n  uniformity (UniformSpace.Completion Œ±) =\n    inf·µ¢ fun (Œµ : { Œµ : ‚Ñù // 0 < Œµ }) ‚Ü¶\n      Filter.principal\n        (setOf fun (p : UniformSpace.Completion Œ± √ó UniformSpace.Completion Œ±) ‚Ü¶ dist (Prod.fst p) (Prod.snd p) < ‚ÜëŒµ)","name":"UniformSpace.Completion.uniformity_dist'","isProp":true,"docString":"Reformulate `Completion.mem_uniformity_dist` in terms that are suitable for the definition\nof the metric space structure. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_3} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_2} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p‚ÇÅ : (a : Œπ) ‚Üí P) (p‚ÇÇ : P)\n  (h : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 0),\n  (Finset.sum s fun (i : Œπ) ‚Ü¶ w i ‚Ä¢ (p‚ÇÅ i -·µ• p‚ÇÇ)) = ‚Üë(Finset.weightedVSub s p‚ÇÅ) w","name":"Finset.sum_smul_vsub_const_eq_weightedVSub","isProp":true,"docString":"A weighted sum of pairwise subtractions, where the point on the right is constant and the\nsum of the weights is 0. "},{"type":"‚àÄ {n : ‚Ñ§} (a : Odd n), Odd (Int.natAbs n)","name":"Odd.natAbs","isProp":true,"docString":"**Alias** of the reverse direction of `Int.natAbs_odd`."},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : NonAssocSemiring Œ±]\n  [inst_1 : NonAssocSemiring Œ≤] [self : RingHomClass F Œ± Œ≤] (f : F) (x : Œ±) (y : Œ±), ‚Üëf (x + y) = ‚Üëf x + ‚Üëf y","name":"RingHomClass.map_add","isProp":true,"docString":"The proposition that the function preserves addition "},{"type":"‚àÄ {Œì : Type u_1} [inst : Group Œì] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Œì T]\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstSMul Œì T]\n  [inst_6 : ProperlyDiscontinuousSMul Œì T], T2Space (Quotient (MulAction.orbitRel Œì T))","name":"t2Space_of_properlyDiscontinuousSMul_of_t2Space","isProp":true,"docString":"The quotient by a discontinuous group action of a locally compact t2 space is t2. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] (S : Submonoid M), Localization.r S = Localization.r' S","name":"Localization.r_eq_r'","isProp":true,"docString":"The congruence relation used to localize a `CommMonoid` at a submonoid can be expressed\nequivalently as an infimum (see `Localization.r`) or explicitly\n(see `Localization.r'`). "},{"type":"‚àÄ {Œ± : Type u} {Œπ : Type u_1} (I : Finset Œπ) {l : Filter Œ±} {p : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Prop},\n  (Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚àÄ (i : Œπ) (a : i ‚àà I), p i x) l : Prop) ‚Üî\n    (‚àÄ (i : Œπ) (a : i ‚àà I), Filter.Eventually (fun (x : Œ±) ‚Ü¶ p i x) l : Prop)","name":"Finset.eventually_all","isProp":true,"docString":"**Alias** of `Filter.eventually_all_finset`."},{"type":"‚àÄ {P : Type u_1} [inst : LE P] {I : Set P} (self : Order.IsIdeal I), Set.Nonempty I","name":"Order.IsIdeal.Nonempty","isProp":true,"docString":"The ideal is nonempty. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  (Subgroup.index H = 2 : Prop) ‚Üî (‚àÉ (a : G), ‚àÄ (b : G), Xor' (b * a ‚àà H : Prop) (b ‚àà H : Prop) : Prop)","name":"Subgroup.index_eq_two_iff","isProp":true,"docString":"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. "},{"type":"‚àÄ {M : Type u_1} [inst : Add M] (c : AddCon M), addConGen ‚Üëc = c","name":"AddCon.addConGen_of_addCon","isProp":true,"docString":"Additive congruence relations equal the smallest\nadditive congruence relation in which they are contained."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±},\n  (IsCompact s : Prop) ‚Üî\n    (‚àÄ {Œπ : Type u} (U : (a : Œπ) ‚Üí Set Œ±) (a : ‚àÄ (i : Œπ), IsOpen (U i)) (a : s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ U i),\n        ‚àÉ (t : Finset Œπ), s ‚äÜ Set.union·µ¢ fun (i : Œπ) ‚Ü¶ Set.union·µ¢ fun (h : i ‚àà t) ‚Ü¶ U i :\n      Prop)","name":"isCompact_iff_finite_subcover","isProp":true,"docString":"A set `s` is compact if and only if\nfor every open cover of `s`, there exists a finite subcover. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.SplitMonoCategory C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_2 : CategoryTheory.Mono f], CategoryTheory.IsSplitMono f","name":"CategoryTheory.isSplitMono_of_mono","isProp":true,"docString":"In a category in which every monomorphism is split, every monomorphism splits. This is not an\ninstance because it would create an instance loop. "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : LinearOrderedRing Œ±] [inst_1 : LinearOrderedAddCommGroup Œ≤]\n  [inst_2 : Module Œ± Œ≤] [inst_3 : OrderedSMul Œ± Œ≤] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ≤}\n  [inst_4 : Fintype Œπ] (hfg : Antivary f g),\n  (Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i ‚Ä¢ g i) ‚â§ Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f (‚ÜëœÉ i) ‚Ä¢ g i","name":"Antivary.sum_smul_le_sum_comp_perm_smul","isProp":true,"docString":"**Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g` is minimized when\n`f` and `g` antivary together. Stated by permuting the entries of `f`. "},{"type":"‚àÄ {M : Type u_2} {P : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {f : M ‚Üí+ P} (x : M),\n  ‚Üë(AddCon.kerLift f) ‚Üëx = ‚Üëf x","name":"AddCon.kerLift_mk","isProp":true,"docString":"The diagram described by the universal property for quotients\nof `AddMonoid`s, when the additive congruence relation is the kernel of the homomorphism,\ncommutes."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≤' : Type u_3} {Œ≥ : Type u_1} {Œ¥ : Type u_5} {f : Filter Œ±} {g : Filter Œ≤}\n  {m : (a : Œ±) ‚Üí (a : Œ≤') ‚Üí Œ≥} {n : (a : Œ≤) ‚Üí Œ≤'} {m' : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {n' : (a : Œ¥) ‚Üí Œ≥}\n  (h_right_comm : ‚àÄ (a : Œ±) (b : Œ≤), m a (n b) = n' (m' a b)),\n  Filter.map‚ÇÇ m f (Filter.map n g) = Filter.map n' (Filter.map‚ÇÇ m' f g)","name":"Filter.map_map‚ÇÇ_right_comm","isProp":true,"docString":"Symmetric statement to `Filter.map_map‚ÇÇ_distrib_right`. "},{"type":"‚àÄ (Œ± : Type u_3) (Œ≤ : Type u_2) [inst : UniformSpace Œ≤] {Œπ : Sort u_1} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set (Œ≤ √ó Œ≤)}\n  (h : Filter.HasBasis (uniformity Œ≤) p s), Filter.HasBasis (uniformity (UniformFun Œ± Œ≤)) p (UniformFun.gen Œ± Œ≤ ‚àò s)","name":"UniformFun.hasBasis_uniformity_of_basis","isProp":true,"docString":"The uniformity of `Œ± ‚Üí·µ§ Œ≤` admits the family `{(f, g) | ‚àÄ x, (f x, g x) ‚àà V}` for `V ‚àà ùìë` as\na filter basis, for any basis `ùìë` of `ùì§ Œ≤` (in the case `ùìë = (ùì§ Œ≤).as_basis` this is true by\ndefinition). "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {n : ‚Ñï} (f : (a : Œ±) ‚Üí Œ≤) (a : Œ±) (v : Vector Œ± n),\n  Vector.map f (a ::·µ• v) = f a ::·µ• Vector.map f v","name":"Vector.map_cons","isProp":true,"docString":"`map` is natural with respect to `cons`. "},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : SeminormedRing ùïú] [inst_1 : SMul ùïú E] {s : Set E} {t : Set E}\n  (ht : Balanced ùïú t) (h : s ‚äÜ t), balancedHull ùïú s ‚äÜ t","name":"Balanced.balancedHull_subset_of_subset","isProp":true,"docString":"The balanced hull of `s` is minimal in the sense that it is contained in any balanced superset\n`t` of `s`. "},{"type":"‚àÄ {n : Type u_1} {Œ± : Type v} {Œ≤ : Type w} [inst : Mul Œ±] [inst_1 : Mul Œ≤] (f : (a : Œ±) ‚Üí Œ≤) (r : Œ±) (A : Matrix n n Œ±)\n  (hf : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ±), f (a‚ÇÅ * a‚ÇÇ) = f a‚ÇÅ * f a‚ÇÇ),\n  Matrix.map ({ unop := r } ‚Ä¢ A) f = { unop := f r } ‚Ä¢ Matrix.map A f","name":"Matrix.map_op_smul'","isProp":true,"docString":"The scalar action via `mul.toOppositeSMul` is transformed by the same map as the\nelements of the matrix, when `f` preserves multiplication. "},{"type":"‚àÄ {M : Type u_1} {Œ± : Sort u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} (p : (a : M) ‚Üí Prop) (hp‚ÇÄ : p 1)\n  (hp‚ÇÅ : ‚àÄ (x : M) (y : M) (a : p x) (a : p y), p (x * y)) (hp‚ÇÇ : ‚àÄ (i : Œ±), p (f i)), p (finprod fun (i : Œ±) ‚Ü¶ f i)","name":"finprod_induction","isProp":true,"docString":"To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Bornology Œ±] {s : Set Œ±} (a : Bornology.IsBounded (s·∂ú)), Bornology.IsCobounded s","name":"Bornology.IsBounded.of_compl","isProp":true,"docString":"**Alias** of the forward direction of `Bornology.isBounded_compl_iff`."},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] (g : GroupTopology Œ±), Continuous Inv.inv","name":"GroupTopology.continuous_inv'","isProp":true,"docString":"A version of the global `continuous_inv` suitable for dot notation. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyOrderedMonoid Œ±] (x : Œ±), ‚ä• ‚â§ x","name":"CanonicallyOrderedMonoid.bot_le","isProp":true,"docString":"`‚ä•` is the least element "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_3} {E' : Type u_2} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {g : (a : Œ±) ‚Üí F}\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : (fun (x : Œ±) ‚Ü¶ -f' x) =o[l] g), f' =o[l] g","name":"Asymptotics.IsLittleO.of_neg_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isLittleO_neg_left`."},{"type":"‚àÄ {n : ‚Ñï} (a : Fin n) (b : Fin (n + 1)), Fin.predAbove (Fin.succ a) (Fin.succ b) = Fin.succ (Fin.predAbove a b)","name":"Fin.succ_predAbove_succ","isProp":true,"docString":"`succ` commutes with `predAbove`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤],\n  Filter.coprod (Filter.cocompact Œ±) (Filter.cocompact Œ≤) = Filter.cocompact (Œ± √ó Œ≤)","name":"Filter.coprod_cocompact","isProp":true,"docString":"The coproduct of the cocompact filters on two topological spaces is the cocompact filter on\ntheir product. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] {S : Type v} [inst_1 : Semiring S] {f : R ‚Üí+* S} [inst_2 : Nontrivial S]\n  {p : Polynomial S} (hlifts : p ‚àà Polynomial.lifts f) (hp : Polynomial.Monic p),\n  ‚àÉ (q : Polynomial R),\n    (Polynomial.map f q = p : Prop) ‚àß\n      ((Polynomial.degree q = Polynomial.degree p : Prop) ‚àß (Polynomial.Monic q : Prop) : Prop)","name":"Polynomial.lifts_and_degree_eq_and_monic","isProp":true,"docString":"A monic polynomial lifts if and only if it can be lifted to a monic polynomial\nof the same degree. "},{"type":"‚àÄ {M : Type u} [self : Monoid M] (n : ‚Ñï) (x : M), Monoid.npow (n + 1) x = x * Monoid.npow n x","name":"Monoid.npow_succ","isProp":true,"docString":"Raising to the power `(n + 1 : ‚Ñï)` behaves as expected. "},{"type":"‚àÄ {M : Type u_1} [inst : Mul M] {r : (a : M) ‚Üí (a : M) ‚Üí Prop} {c : Con M}\n  (h : ‚àÄ (x : M) (y : M) (a : r x y), Setoid.r x y), conGen r ‚â§ c","name":"Con.conGen_le","isProp":true,"docString":"The smallest congruence relation containing a binary relation `r` is contained in any\ncongruence relation containing `r`. "},{"type":"‚àÄ {M : Type u_1} {P : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass P] {c : AddCon M} {f : M ‚Üí+ P}\n  (H : c ‚â§ AddCon.ker f) (x : M), ‚Üë(AddCon.lift c f H) ‚Üëx = ‚Üëf x","name":"AddCon.lift_coe","isProp":true,"docString":"The diagram describing the universal property for quotients of\n`AddMonoid`s commutes."},{"type":"‚àÄ {Œ≤ : Type u} (f : (a : Œ≤) ‚Üí Type u) {P : Type u} (s : (b : Œ≤) ‚Üí P ‚ü∂ f b) (b : Œ≤) (x : P),\n  CategoryTheory.Limits.Pi.œÄ f b (CategoryTheory.Limits.Pi.lift s x) = s b x","name":"CategoryTheory.Limits.Types.pi_lift_œÄ_apply","isProp":true,"docString":"A restatement of `Types.Limit.lift_œÄ_apply` that uses `Pi.œÄ` and `Pi.lift`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommSemiring R], (IsField R : Prop) ‚Üî (IsSimpleOrder (Ideal R) : Prop)","name":"Ring.isField_iff_isSimpleOrder_ideal","isProp":true,"docString":"Also see `Ideal.isSimpleOrder` for the forward direction as an instance when `R` is a\ndivision (semi)ring.\n\nThis result actually holds for all division semirings, but we lack the predicate to state it. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : AddCommSemigroup Œ±] [inst_2 : Sub Œ±] [inst_3 : OrderedSub Œ±] {a : Œ±}\n  {b : Œ±} {c : Œ±} [inst_4 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (a_1 : a + c < b), c < b - a","name":"lt_tsub_of_add_lt_left","isProp":true,"docString":"This lemma (and some of its corollaries) also holds for `ENNReal`, but this proof doesn't work\nfor it. Maybe we should add this lemma as field to `OrderedSub`? "},{"type":"‚àÄ (n : ‚Ñï) (a : ‚Ñï) (p : (a : ‚Ñï) ‚Üí Prop) [inst : DecidablePred p] (pp : Function.Periodic p a),\n  ‚ÜëMultiset.card (Multiset.filter p (Multiset.Ico n (n + a))) = Nat.count p a","name":"Nat.filter_multiset_Ico_card_eq_of_periodic","isProp":true,"docString":"An interval of length `a` filtered over a periodic predicate of period `a` has cardinality\nequal to the number naturals below `a` for which `p a` is true. "},{"type":"‚àÄ {I : Type u} {f : (a : I) ‚Üí Type v} {Œ± : Type u_1} [inst : (i : I) ‚Üí VAdd Œ± (f i)]\n  [inst_1 : ‚àÄ (i : I), Nonempty (f i)] (i : I) [inst_2 : FaithfulVAdd Œ± (f i)], FaithfulVAdd Œ± ((i : I) ‚Üí f i)","name":"Pi.faithfulVAdd_at","isProp":true,"docString":"If `f i` has a faithful additive action for a given `i`, then\nso does `Œ† i, f i`. This is not an instance as `i` cannot be inferred"},{"type":"Subgroup.normalClosure\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\n        property :=\n          ((Iff.mpr\n                ((Equiv.Perm.mem_alternatingGroup=:(Equiv.swap 0 4 * Equiv.swap 1 3 ‚àà alternatingGroup (Fin 5) : Prop) ‚Üî\n                      (‚ÜëEquiv.Perm.sign (Equiv.swap 0 4 * Equiv.swap 1 3) = 1 :\n                        Prop))=:(Equiv.swap 0 4 * Equiv.swap 1 3 ‚àà alternatingGroup (Fin 5) : Prop) ‚Üî\n                    (‚ÜëEquiv.Perm.sign (Equiv.swap 0 4 * Equiv.swap 1 3) = 1 : Prop))\n                ((of_decide_eq_true\n                      ((Eq.refl\n                            true=:true =\n                            true)=:true =\n                          true)=:‚ÜëEquiv.Perm.sign (Equiv.swap 0 4 * Equiv.swap 1 3) =\n                      1)=:‚ÜëEquiv.Perm.sign (Equiv.swap 0 4 * Equiv.swap 1 3) =\n                    1)=:Equiv.swap 0 4 * Equiv.swap 1 3 ‚àà\n                alternatingGroup (Fin 5))=:Equiv.swap 0 4 * Equiv.swap 1 3 ‚àà alternatingGroup (Fin 5)) }} =\n  ‚ä§","name":"alternatingGroup.normalClosure_swap_mul_swap_five","isProp":true,"docString":"The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\n"},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : CommMonoid M] {s : Set Œ±} {t : Set Œ≤} {f : (a : Œ±) ‚Üí M}\n  {g : (a : Œ≤) ‚Üí M} (e : (a : Œ±) ‚Üí Œ≤) (he‚ÇÄ : Set.BijOn e s t) (he‚ÇÅ : ‚àÄ (x : Œ±) (a : x ‚àà s), f x = g (e x)),\n  (finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) = finprod fun (j : Œ≤) ‚Ü¶ finprod fun (h : j ‚àà t) ‚Ü¶ g j","name":"finprod_mem_eq_of_bijOn","isProp":true,"docString":"See also `Finset.prod_bij`. "},{"type":"‚àÄ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ‚Üí+* S)\n  (hf : Function.Surjective ‚Üëf), RingHom.rangeS f = ‚ä§","name":"RingHom.rangeS_top_of_surjective","isProp":true,"docString":"The range of a surjective ring homomorphism is the whole of the codomain. "},{"type":"‚àÄ {M : Type u} [self : CancelCommMonoid M] (a : M) (b : M), a * b = b * a","name":"CancelCommMonoid.mul_comm","isProp":true,"docString":"Multiplication is commutative in a commutative semigroup. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {J : Type w} [inst_1 : CategoryTheory.SmallCategory J] (F : J ‚•§ C)\n  [inst_2 :\n    CategoryTheory.Limits.HasColimit\n      (CategoryTheory.Discrete.functor (Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F)))]\n  [inst_3 :\n    CategoryTheory.Limits.HasColimit\n      (CategoryTheory.Discrete.functor fun (f : (p : J √ó J) √ó (Prod.fst p ‚ü∂ Prod.snd p)) ‚Ü¶\n        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) (Prod.fst (Sigma.fst f)))]\n  [inst_4 : CategoryTheory.Limits.HasCoequalizers C], CategoryTheory.Limits.HasColimit F","name":"CategoryTheory.Limits.hasColimit_of_coequalizer_and_coproduct","isProp":true,"docString":"Given the existence of the appropriate (possibly finite) coproducts and coequalizers,\nwe know a colimit of `F` exists.\n(This assumes the existence of all coequalizers, which is technically stronger than needed.)\n"},{"type":"‚àÄ {R : Type u_2} {M : Type u_3} {Œπ : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Fintype Œπ] [inst_4 : DecidableEq Œπ] (f : ((a : Œπ) ‚Üí R) ‚Üí‚Çó[R] M) (x : (a : Œπ) ‚Üí R),\n  ‚Üëf x = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ x i ‚Ä¢ ‚Üëf fun (j : Œπ) ‚Ü¶ if (i = j : Prop) then 1 else 0","name":"LinearMap.pi_apply_eq_sum_univ","isProp":true,"docString":"A linear map `f` applied to `x : Œπ ‚Üí R` can be computed using the image under `f` of elements\nof the canonical basis. "},{"type":"‚àÄ (i : ‚Ñï) (j : ‚Ñï) (h : j + 1 = i), ComplexShape.Rel AlgebraicTopology.DoldKan.c i j","name":"AlgebraicTopology.DoldKan.c_mk","isProp":true,"docString":"Helper when we need some `c.rel i j` (i.e. `ComplexShape.down ‚Ñï`),\ne.g. `c_mk n (n+1) rfl` "},{"type":"‚àÄ (A : Type w) (B : Type u‚ÇÅ) (C : Type u_1) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : CommRing C]\n  [inst_3 : Algebra A B] [inst_4 : Algebra B C] [inst_5 : Algebra A C] [inst_6 : IsScalarTower A B C]\n  [inst_7 : IsNoetherianRing A] (hAC : Subalgebra.Fg ‚ä§) (hBC : Submodule.Fg ‚ä§)\n  (hBCi : Function.Injective ‚Üë(algebraMap B C)), Subalgebra.Fg ‚ä§","name":"fg_of_fg_of_fg","isProp":true,"docString":"**Artin--Tate lemma**: if A ‚äÜ B ‚äÜ C is a chain of subrings of commutative rings, and\nA is noetherian, and C is algebra-finite over A, and C is module-finite over B,\nthen B is algebra-finite over A.\n\nReferences: Atiyah--Macdonald Proposition 7.8; Stacks 00IS; Altman--Kleiman 16.17. "},{"type":"‚àÄ {Œπ : Type u_2} {Œ± : (a : Œπ) ‚Üí Type u_1} [inst : Finite Œπ] [inst : DecidableEq Œπ]\n  [inst_1 : (i : Œπ) ‚Üí DecidableEq (Œ± i)] [inst_2 : (i : Œπ) ‚Üí LinearOrder (Œ± i)]\n  {p : (a : (i : Œπ) ‚Üí Finset (Œ± i)) ‚Üí Prop} (f : (i : Œπ) ‚Üí Finset (Œ± i)) (h0 : p fun (x : Œπ) ‚Ü¶ ‚àÖ)\n  (step :\n    ‚àÄ (g : (i : Œπ) ‚Üí Finset (Œ± i)) (i : Œπ) (x : Œ± i) (a : ‚àÄ (y : Œ± i) (a : y ‚àà g i), y < x) (a : p g),\n      p (Function.update g i (insert x (g i)))),\n  p f","name":"Finset.induction_on_pi_max","isProp":true,"docString":"Given a predicate on functions `‚àÄ i, Finset (Œ± i)` defined on a finite type, it is true on all\nmaps provided that it is true on `fun _ ‚Ü¶ ‚àÖ` and for any function `g : ‚àÄ i, Finset (Œ± i)`, an index\n`i : Œπ`, and an element`x : Œ± i` that is strictly greater than all elements of `g i`, `p g` implies\n`p (update g i (insert x (g i)))`.\n\nThis lemma requires `LinearOrder` instances on all `Œ± i`. See also `Finset.induction_on_pi` for a\nversion that `x ‚àâ g i` instead of ` does not need `‚àÄ i, LinearOrder (Œ± i)`. "},{"type":"‚àÄ {R : Type u_1} {S : Type u_2} [inst : CompleteLinearOrder R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R]\n  [inst_3 : CompleteLinearOrder S] [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {F : Filter R}\n  [inst_6 : Filter.NeBot F] {f : (a : R) ‚Üí S} (f_decr : Antitone f) (f_cont : ContinuousAt f (Filter.limsup‚Çõ F)),\n  f (Filter.limsup‚Çõ F) = Filter.liminf f F","name":"Antitone.map_limsup‚Çõ_of_continuousAt","isProp":true,"docString":"An antitone function between complete linear ordered spaces sends a `Filter.limsup‚Çõ`\nto the `Filter.liminf` of the image if it is continuous at the `limsup‚Çõ`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} (self : CategoryTheory.SplitMono f),\n  f ‚â´ CategoryTheory.SplitMono.retraction self = ùüô X","name":"CategoryTheory.SplitMono.id","isProp":true,"docString":"`f` composed with `retraction` is the identity "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedRing Œ±] [inst_1 : FloorRing Œ±] {a : Œ±},\n  (0 < Int.fract a : Prop) ‚Üî (a ‚â† ‚Üë‚åäa‚åã : Prop)","name":"Int.fract_pos","isProp":true,"docString":"The fractional part of `a` is positive if and only if `a ‚â† ‚åäa‚åã`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] (U : Set Œ±),\n  ConnectedComponents.mk ‚Åª¬π' (ConnectedComponents.mk '' U) =\n    Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà U) ‚Ü¶ connectedComponent x","name":"connectedComponents_preimage_image","isProp":true,"docString":"The preimage of the image of a set under the quotient map to `connectedComponents Œ±`\nis the union of the connected components of the elements in it. "},{"type":"‚àÄ {R : Type u_2} {A : Type u_1} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  ‚¶Éf : DualNumber R ‚Üí‚Çê[R] A‚¶Ñ ‚¶Ég : DualNumber R ‚Üí‚Çê[R] A‚¶Ñ (h : ‚Üëf DualNumber.eps = ‚Üëg DualNumber.eps), f = g","name":"DualNumber.algHom_ext","isProp":true,"docString":"For two algebra morphisms out of `R[Œµ]` to agree, it suffices for them to agree on `Œµ`. "},{"type":"‚àÄ (G : Type u) [inst : LeftCancelSemigroup G], IsLeftCancelMul G","name":"LeftCancelSemigroup.toIsLeftCancelMul","isProp":true,"docString":"Any `LeftCancelSemigroup` satisfies `IsLeftCancelMul`. "},{"type":"‚àÄ {E : Type u_1} [self : SeminormedAddGroup E] (x : E) (y : E), dist x y = ‚Äñx - y‚Äñ","name":"SeminormedAddGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {Œ± : Type u_1} [self : NormedLinearOrderedAddGroup Œ±] (x : Œ±) (y : Œ±), dist x y = ‚Äñx - y‚Äñ","name":"NormedLinearOrderedAddGroup.dist_eq","isProp":true,"docString":"The distance function is induced by the norm. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : PredOrder Œ±] {a : Œ±} (h : ¬¨(Order.IsPredLimit a : Prop)),\n  a ‚àà Set.range Order.pred","name":"Order.mem_range_pred_of_not_isPredLimit","isProp":true,"docString":"See `not_isPredLimit_iff` for a version that states that `a` is a successor of a value other\nthan itself. "},{"type":"‚àÄ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P),\n  (AffineIndependent k p : Prop) ‚Üî\n    (‚àÄ (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (a : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 0)\n        (a : ‚Üë(Finset.weightedVSub s p) w = 0) (i : Œπ) (a : i ‚àà s), w i = 0 :\n      Prop)","name":"affineIndependent_def","isProp":true,"docString":"The definition of `AffineIndependent`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] [inst_1 : Archimedean Œ±] {a : Œ±} (ha : 0 < a) (g : Œ±),\n  ‚àÉ! (k : ‚Ñ§), (k ‚Ä¢ a ‚â§ g : Prop) ‚àß (g < (k + 1) ‚Ä¢ a : Prop)","name":"existsUnique_zsmul_near_of_pos","isProp":true,"docString":"An archimedean decidable linearly ordered `AddCommGroup` has a version of the floor: for\n`a > 0`, any `g` in the group lies between some two consecutive multiples of `a`. "},{"type":"‚àÄ {R : Type u_1} [inst : CommRing R] (M : Submonoid R) {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsLocalization M S] (a : S), ‚àÉ (b : { x : R // x ‚àà M }), IsLocalization.IsInteger R (‚Üëb ‚Ä¢ a)","name":"IsLocalization.exists_integer_multiple","isProp":true,"docString":"Each element `a : S` has an `M`-multiple which is an integer.\n\nThis version multiplies `a` on the left, matching the argument order in the `SMul` instance.\n"},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} (w : a ‚à£ b) (h : Int.natAbs b < Int.natAbs a), b = 0","name":"Int.eq_zero_of_dvd_of_natAbs_lt_natAbs","isProp":true,"docString":"If an integer with larger absolute value divides an integer, it is\nzero. "},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÅ : (a : Œπ) ‚Üí Type v‚ÇÅ} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R]\n  [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ i)] [inst_2 : AddCommMonoid M‚ÇÇ] [inst_3 : (i : Œπ) ‚Üí Module R (M‚ÇÅ i)]\n  [inst_4 : Module R M‚ÇÇ] {M‚ÇÅ' : (a : Œπ) ‚Üí Type u_1} [inst_5 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ' i)]\n  [inst_6 : (i : Œπ) ‚Üí Module R (M‚ÇÅ' i)] (g : MultilinearMap R M‚ÇÅ' M‚ÇÇ) (f : (i : Œπ) ‚Üí M‚ÇÅ i ‚âÉ‚Çó[R] M‚ÇÅ' i),\n  ((MultilinearMap.compLinearMap g fun (i : Œπ) ‚Ü¶ ‚Üë(f i)) = 0 : Prop) ‚Üî (g = 0 : Prop)","name":"MultilinearMap.comp_linearEquiv_eq_zero_iff","isProp":true,"docString":"Composing a multilinear map with a linear equiv on each argument gives the zero map\nif and only if the multilinear map is the zero map. "},{"type":"‚àÄ (R : Type u) [inst : Semiring R], Module.Free R R","name":"Module.Free.self","isProp":true,"docString":"The module structure provided by `Semiring.toModule` is free. "},{"type":"‚àÄ {R : Type u_1} [inst : CancelMonoid R] (g : R), IsRegular g","name":"isRegular_of_cancelMonoid","isProp":true,"docString":"Elements of a cancel monoid are regular.  Cancel semigroups do not appear to exist. "},{"type":"‚àÄ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : RegularSpace Y]\n  {f : (a : X) ‚Üí Y} {A : Set X} {B : Set X} (hB : B ‚äÜ closure A)\n  (hf : ‚àÄ (x : X) (a : x ‚àà B), ‚àÉ (y : Y), Filter.Tendsto f (nhdsWithin x A) (nhds y)), ContinuousOn (extendFrom A f) B","name":"continuousOn_extendFrom","isProp":true,"docString":"If `f` is a function to a T‚ÇÉ space `Y` which has a limit within `A` at any\npoint of a set `B ‚äÜ closure A`, then `extendFrom A f` is continuous on `B`. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {t : Set Œ±} {u : Set Œ±} (fin : EMetric.hausdorffEdist t u ‚â† ‚ä§),\n  Metric.hausdorffDist s u ‚â§ Metric.hausdorffDist s t + Metric.hausdorffDist t u","name":"Metric.hausdorffDist_triangle'","isProp":true,"docString":"The Hausdorff distance satisfies the triangular inequality "},{"type":"‚àÄ {F : Type u_3} {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : NonAssocSemiring Œ≤]\n  [inst_2 : RingHomClass F Œ± Œ≤] (f : F) (a : Œ±), ‚Üëf (bit1 a) = bit1 (‚Üëf a)","name":"map_bit1","isProp":true,"docString":"Ring homomorphisms preserve `bit1`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteLattice Œ±] (s : Set Œ±) (a : Œ±) (a_1 : ‚àÄ (b : Œ±) (a_1 : b ‚àà s), b ‚â§ a), sup‚Çõ s ‚â§ a","name":"CompleteLattice.sup‚Çõ_le","isProp":true,"docString":"Any upper bound is more than the set supremum. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (a_1 : b < a), ‚ÜëOrderDual.toDual a < ‚ÜëOrderDual.toDual b","name":"LT.lt.dual","isProp":true,"docString":"**Alias** of the reverse direction of `OrderDual.toDual_lt_toDual`."},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} (œÄ : (a : Œπ) ‚Üí Set (Set Œ±)) (hpi : ‚àÄ (x : Œπ), IsPiSystem (œÄ x)) (S : Set Œπ),\n  IsPiSystem (piUnion·µ¢Inter œÄ S)","name":"isPiSystem_piUnion·µ¢Inter","isProp":true,"docString":"If `œÄ` is a family of œÄ-systems, then `piUnion·µ¢Inter œÄ S` is a œÄ-system. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {T : CategoryTheory.Monad C} {A : CategoryTheory.Monad.Algebra T}\n  {B : CategoryTheory.Monad.Algebra T} (self : CategoryTheory.Monad.Algebra.Hom A B),\n  Prefunctor.map (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Monad.toFunctor T))\n        (CategoryTheory.Monad.Algebra.Hom.f self) ‚â´\n      CategoryTheory.Monad.Algebra.a B =\n    CategoryTheory.Monad.Algebra.a A ‚â´ CategoryTheory.Monad.Algebra.Hom.f self","name":"CategoryTheory.Monad.Algebra.Hom.h","isProp":true,"docString":"Compatibility with the structure morphism, for a morphism of algebras. "},{"type":"‚àÄ {K : Type u_1} [inst : DivisionRing K] {a : K} {b : K} (ha : a ‚â† 0) (hb : b ‚â† 0), a‚Åª¬π - b‚Åª¬π = a‚Åª¬π * (b - a) * b‚Åª¬π","name":"inv_sub_inv'","isProp":true,"docString":"See `inv_sub_inv` for the more convenient version when `K` is commutative. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : StrictOrderedSemiring Œ±] {n : ‚Ñï} (hn : n ‚â† 0),\n  Filter.Tendsto (fun (x : Œ±) ‚Ü¶ x ^ n) Filter.atTop Filter.atTop","name":"Filter.tendsto_pow_atTop","isProp":true,"docString":"The monomial function `x^n` tends to `+‚àû` at `+‚àû` for any positive natural `n`.\nA version for positive real powers exists as `tendsto_rpow_atTop`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [self : IsWeakLowerModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚ãñ a ‚äî b)\n  (a_2 : b ‚ãñ a ‚äî b), a ‚äì b ‚ãñ a","name":"IsWeakLowerModularLattice.inf_covby_of_covby_covby_sup","isProp":true,"docString":"`a` and `b` cover `a ‚äì b` if `a ‚äî b` covers both `a` and `b` "},{"type":"‚àÄ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R √ó S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False","name":"false_of_nontrivial_of_product_domain","isProp":true,"docString":"The product of two nontrivial rings is not a domain "},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hst : s ‚äÜ t)\n  (ht : Set.Finite (t ‚à© Function.mulSupport f)),\n  ((finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà s) ‚Ü¶ f i) * finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà t \\ s) ‚Ü¶ f i) =\n    finprod fun (i : Œ±) ‚Ü¶ finprod fun (h : i ‚àà t) ‚Ü¶ f i","name":"finprod_mem_mul_diff'","isProp":true,"docString":"A more general version of `finprod_mem_mul_diff` that requires `t ‚à© mulSupport f` rather than\n`t` to be finite. "},{"type":"Fact (1 ‚â§ 1 : Prop)","name":"fact_one_le_one_ennreal","isProp":true,"docString":"`(1 : ‚Ñù‚â•0‚àû) ‚â§ 1`, recorded as a `Fact` for use with `Lp` spaces. "},{"type":"‚àÄ {m : Type u_1} (R : Type u_2) {S : Type u_3} [inst : Fintype m] [inst_1 : DecidableEq m] [inst_2 : CommSemiring R]\n  [inst_3 : CommSemiring S] [inst_4 : Algebra R S] (A : Matrix m m S),\n  ‚Üë(AlgHom.mapMatrix (MvPolynomial.aeval fun (p : m √ó m) ‚Ü¶ A (Prod.fst p) (Prod.snd p))) (Matrix.mvPolynomialX m m R) =\n    A","name":"Matrix.mvPolynomialX_mapMatrix_aeval","isProp":true,"docString":"A variant of `Matrix.mvPolynomialX_map_eval‚ÇÇ` with a bundled `AlgHom` on the LHS. "},{"type":"‚àÄ {Œπ : Type u} (Œ≤ : (a : Œπ) ‚Üí Type v) [I : Nonempty Œπ], ‚àÉ (i : Œπ), Nonempty ((j : Œπ) ‚Üí Œ≤ i ‚Ü™ Œ≤ j)","name":"Function.Embedding.min_injective","isProp":true,"docString":"The cardinals are well-ordered. We express it here by the fact that in any set of cardinals\nthere is an element that injects into the others.\nSee `Cardinal.conditionallyCompleteLinearOrderBot` for (one of) the lattice instances. "},{"type":"‚àÄ (r : ENNReal), (tsum fun (n : ‚Ñï) ‚Ü¶ r ^ n) = (1 - r)‚Åª¬π","name":"ENNReal.tsum_geometric","isProp":true,"docString":"The series `pow r` converges to `(1-r)‚Åª¬π`. For `r < 1` the RHS is a finite number,\nand for `1 ‚â§ r` the RHS equals `‚àû`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] (self : CategoryTheory.GrothendieckTopology C) ‚¶ÉX : C‚¶Ñ\n  ‚¶ÉS : CategoryTheory.Sieve X‚¶Ñ (x : S ‚àà CategoryTheory.GrothendieckTopology.sieves self X) (R : CategoryTheory.Sieve X)\n  (a :\n    ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (a : CategoryTheory.Sieve.arrows S f),\n      CategoryTheory.Sieve.pullback f R ‚àà CategoryTheory.GrothendieckTopology.sieves self Y),\n  R ‚àà CategoryTheory.GrothendieckTopology.sieves self X","name":"CategoryTheory.GrothendieckTopology.transitive'","isProp":true,"docString":"Transitivity of sieves in a Grothendieck topology.\nUse `GrothendieckTopology.transitive`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : a < b) (a_2 : b < c), a < c","name":"LT.lt.trans","isProp":true,"docString":"**Alias** of `lt_trans`."},{"type":"‚àÄ {K : Type u} [self : DivisionRing K] (a : ‚Ñö) (x : K), DivisionRing.qsmul a x = ‚Üëa * x","name":"DivisionRing.qsmul_eq_mul'","isProp":true,"docString":"However `qsmul` is defined,\npropositionally it must be equal to multiplication by `ratCast`. "},{"type":"‚àÄ {K : Type u} [inst : Field K] {Œπ : Sort u_1} [hŒπ : Nonempty Œπ] {S : (a : Œπ) ‚Üí Subfield K}\n  (hS : Directed (fun (x : Subfield K) (x_1 : Subfield K) ‚Ü¶ x ‚â§ x_1) S) {x : K},\n  (x ‚àà sup·µ¢ fun (i : Œπ) ‚Ü¶ S i : Prop) ‚Üî (‚àÉ (i : Œπ), x ‚àà S i : Prop)","name":"Subfield.mem_sup·µ¢_of_directed","isProp":true,"docString":"The underlying set of a non-empty directed sup‚Çõ of subfields is just a union of the subfields.\nNote that this fails without the directedness assumption (the union of two subfields is\ntypically not a subfield) "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : T1Space Œ±] [inst_2 : ‚àÄ (x : Œ±), Filter.NeBot (nhdsWithin x ({x}·∂ú))]\n  {s : Set Œ±} (hs : Dense s) {t : Set Œ±} (ht : Set.Finite t), Dense (s \\ t)","name":"Dense.diff_finite","isProp":true,"docString":"Removing a finite set from a dense set in a space without isolated points, one still\nobtains a dense set. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_3} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {g : (a : Œ≤) ‚Üí M}\n  (e : (a : Œ±) ‚Üí Œ≤) (he‚ÇÄ : Function.Bijective e) (he‚ÇÅ : ‚àÄ (x : Œ±), f x = g (e x)),\n  (finsum fun (i : Œ±) ‚Ü¶ f i) = finsum fun (j : Œ≤) ‚Ü¶ g j","name":"finsum_eq_of_bijective","isProp":true,"docString":"See `finsum_comp`, `Fintype.sum_bijective` and `Finset.sum_bij`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [self : T2Space Œ±] (x : Œ±) (y : Œ±) (a : x ‚â† y),\n  ‚àÉ (u : Set Œ±),\n    ‚àÉ (v : Set Œ±),\n      (IsOpen u : Prop) ‚àß\n        ((IsOpen v : Prop) ‚àß ((x ‚àà u : Prop) ‚àß ((y ‚àà v : Prop) ‚àß (Disjoint u v : Prop) : Prop) : Prop) : Prop)","name":"T2Space.t2","isProp":true,"docString":"Every two points in a Hausdorff space admit disjoint open neighbourhoods. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] ‚¶És : Set Œ±‚¶Ñ ‚¶Ét : Set Œ±‚¶Ñ (h : s ‚äÜ t) (a : BddAbove t), BddAbove s","name":"BddAbove.mono","isProp":true,"docString":"If `s ‚äÜ t` and `t` is bounded above, then so is `s`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (self : X ‚âÖ Y),\n  CategoryTheory.Iso.inv self ‚â´ CategoryTheory.Iso.hom self = ùüô Y","name":"CategoryTheory.Iso.inv_hom_id","isProp":true,"docString":"Composition of the two directions of an isomorphism in reverse order\nis the identity on the target. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œπ : Type u_1} [inst_1 : CompactSpace Œ±] {f : (a : Œπ) ‚Üí Set Œ±}\n  (hf : LocallyFinite f), Set.Finite (setOf fun (i : Œπ) ‚Ü¶ Set.Nonempty (f i))","name":"LocallyFinite.finite_nonempty_of_compact","isProp":true,"docString":"If `Œ±` is a compact space, then a locally finite family of sets of `Œ±` can have only finitely\nmany nonempty elements. "},{"type":"‚àÄ {K : Type u} [inst : Field K] (s : Subfield K) {l : List K} (a : ‚àÄ (x : K) (a : x ‚àà l), x ‚àà s), List.sum l ‚àà s","name":"Subfield.list_sum_mem","isProp":true,"docString":"Sum of a list of elements in a subfield is in the subfield. "},{"type":"‚àÄ {Œ± : Type u_2} {E' : Type u_3} {E'' : Type u_1} [inst : SeminormedAddCommGroup E'] [inst_1 : NormedAddCommGroup E'']\n  {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} {c : E''} (hc : c ‚â† 0),\n  ((fun (_x : Œ±) ‚Ü¶ c) =O[l] f' : Prop) ‚Üî\n    (‚àÉ (b : ‚Ñù), (0 < b : Prop) ‚àß (Filter.Eventually (fun (x : Œ±) ‚Ü¶ b ‚â§ ‚Äñf' x‚Äñ) l : Prop) : Prop)","name":"Asymptotics.isBigO_const_left_iff_pos_le_norm","isProp":true,"docString":"`(Œª x, c) =O[l] f` if and only if `f` is bounded away from zero. "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_2} {N : Type u_1} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] ‚¶Éf : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ N‚¶Ñ\n  ‚¶Ég : (Œ± ‚Üí‚ÇÄ M) ‚Üí+ N‚¶Ñ\n  (H : ‚àÄ (x : Œ±), AddMonoidHom.comp f (Finsupp.singleAddHom x) = AddMonoidHom.comp g (Finsupp.singleAddHom x)), f = g","name":"Finsupp.addHom_ext'","isProp":true,"docString":"If two additive homomorphisms from `Œ± ‚Üí‚ÇÄ M` are equal on each `single a b`,\nthen they are equal.\n\nWe formulate this using equality of `AddMonoidHom`s so that `ext` tactic can apply a type-specific\nextensionality lemma after this one.  E.g., if the fiber `M` is `‚Ñï` or `‚Ñ§`, then it suffices to\nverify `f (single a 1) = g (single a 1)`. "},{"type":"‚àÄ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : CommRing B] {f : A ‚Üí+* B} (hf : RingHom.Finite f),\n  RingHom.FiniteType f","name":"RingHom.Finite.to_finiteType","isProp":true,"docString":"**Alias** of `RingHom.FiniteType.of_finite`."},{"type":"‚àÄ {R : Type u_1} [inst : AddCommSemigroup R] {a : R} {b : R},\n  (IsAddRegular (a + b) : Prop) ‚Üî ((IsAddRegular a : Prop) ‚àß (IsAddRegular b : Prop) : Prop)","name":"isAddRegular_add_iff","isProp":true,"docString":"A sum is add-regular if and only if the summands are."},{"type":"‚àÄ {R : Type u} [inst : Semifield R] [inst_1 : StarRing R] (x : R) (y : R), star (x / y) = star x / star y","name":"star_div'","isProp":true,"docString":"When multiplication is commutative, `star` preserves division. "},{"type":"‚àÄ {R : Type u_1} [inst : LinearOrderedCommRing R] (a : R) (b : R), 2 * a * b ‚â§ a ^ 2 + b ^ 2","name":"two_mul_le_add_sq","isProp":true,"docString":"Arithmetic mean-geometric mean (AM-GM) inequality for linearly ordered commutative rings. "},{"type":"‚àÄ (R : Type u_1) (S : Type v) [inst : AddMonoidWithOne R] [inst_1 : AddMonoidWithOne S] (p : ‚Ñï) (q : ‚Ñï)\n  [inst_2 : CharP R p] [inst_3 : CharP S q], CharP (R √ó S) (Nat.lcm p q)","name":"Nat.lcm.charP","isProp":true,"docString":"The characteristic of the product of rings is the least common multiple of the\ncharacteristics of the two rings. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤}\n  {f : (a : Œ±) ‚Üí Œ≤} {p : Filter Œπ} (h : TendstoUniformly F f p) (g : (a : Œ≥) ‚Üí Œ±),\n  TendstoUniformly (fun (n : Œπ) ‚Ü¶ F n ‚àò g) (f ‚àò g) p","name":"TendstoUniformly.comp","isProp":true,"docString":"Composing on the right by a function preserves uniform convergence "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Monoid Œ±] [self : MulAction Œ± Œ≤] (b : Œ≤), 1 ‚Ä¢ b = b","name":"MulAction.one_smul","isProp":true,"docString":"One is the neutral element for `‚Ä¢` "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S‚ÇÅ : Submodule K V}\n  {S‚ÇÇ : Submodule K V} [inst_3 : FiniteDimensional K { x : V // x ‚àà S‚ÇÇ }] (hle : S‚ÇÅ ‚â§ S‚ÇÇ)\n  (hd : FiniteDimensional.finrank K { x : V // x ‚àà S‚ÇÅ } = FiniteDimensional.finrank K { x : V // x ‚àà S‚ÇÇ }), S‚ÇÅ = S‚ÇÇ","name":"FiniteDimensional.eq_of_le_of_finrank_eq","isProp":true,"docString":"If a submodule is less than or equal to a finite-dimensional\nsubmodule with the same dimension, they are equal. "},{"type":"‚àÄ {Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} (h : Function.Commute f g),\n  Set.BijOn g (Function.fixedPoints (f ‚àò g)) (Function.fixedPoints (f ‚àò g))","name":"Function.Commute.right_bijOn_fixedPoints_comp","isProp":true,"docString":"If self-maps `f` and `g` commute, then `g` is bijective on the set of fixed points of `f ‚àò g`.\nThis is a particular case of `Function.bijOn_fixedPoints_comp`. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {f : Filter Œ±} [inst : IsTrans Œ± r] (a : Œ±)\n  (h : ‚àÄ (s : Set Œ±) (a_1 : s ‚àà f), ‚àÉ (x : Œ±), (x ‚àà s : Prop) ‚àß (r a x : Prop)), Filter.IsCobounded r f","name":"Filter.IsCobounded.mk","isProp":true,"docString":"To check that a filter is frequently bounded, it suffices to have a witness\nwhich bounds `f` at some point for every admissible set.\n\nThis is only an implication, as the other direction is wrong for the trivial filter."},{"type":"‚àÄ {K : Type u} [inst : Field K] {s : Set K} {p : (a : K) ‚Üí Prop} {x : K} (h : x ‚àà Subfield.closure s)\n  (Hs : ‚àÄ (x : K) (a : x ‚àà s), p x) (H1 : p 1) (Hadd : ‚àÄ (x : K) (y : K) (a : p x) (a : p y), p (x + y))\n  (Hneg : ‚àÄ (x : K) (a : p x), p (-x)) (Hinv : ‚àÄ (x : K) (a : p x), p x‚Åª¬π)\n  (Hmul : ‚àÄ (x : K) (y : K) (a : p x) (a : p y), p (x * y)), p x","name":"Subfield.closure_induction","isProp":true,"docString":"An induction principle for closure membership. If `p` holds for `1`, and all elements\nof `s`, and is preserved under addition, negation, and multiplication, then `p` holds for all\nelements of the closure of `s`. "},{"type":"‚àÄ {M : Type u_1} {B : Type u_2} [inst : Monoid M] [inst_1 : SetLike B M] [inst_2 : SubmonoidClass B M] {S : B}\n  {l : List M} (hl : ‚àÄ (x : M) (a : x ‚àà l), x ‚àà S), List.prod l ‚àà S","name":"list_prod_mem","isProp":true,"docString":"Product of a list of elements in a submonoid is in the submonoid. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} {s : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop}\n  (h : ‚àÄ (x : Œ±) (y : Œ±) (a : r x y), s x y), EqvGen.Setoid r ‚â§ EqvGen.Setoid s","name":"Setoid.eqvGen_mono","isProp":true,"docString":"Equivalence closure of binary relations is monotone. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} [inst : CompleteLattice Œ±] {b : Œ±} {f : (a : Œπ) ‚Üí Œ±} (h‚ÇÅ : ‚àÄ (i : Œπ), f i ‚â§ b)\n  (h‚ÇÇ : ‚àÄ (w : Œ±) (a : w < b), ‚àÉ (i : Œπ), w < f i), (sup·µ¢ fun (i : Œπ) ‚Ü¶ f i) = b","name":"sup·µ¢_eq_of_forall_le_of_forall_lt_exists_gt","isProp":true,"docString":"Introduction rule to prove that `b` is the supremum of `f`: it suffices to check that `b`\nis larger than `f i` for all `i`, and that this is not the case of any `w<b`.\nSee `csup·µ¢_eq_of_forall_le_of_forall_lt_exists_gt` for a version in conditionally complete\nlattices. "},{"type":"‚àÄ (M : Type u_2) {Œ± : Type u_1} [inst : Monoid M] [inst_1 : MulAction M Œ±] (a‚ÇÅ : M) (a‚ÇÇ : M),\n  (fun (x : M) (x_1 : Œ±) ‚Ü¶ x ‚Ä¢ x_1) a‚ÇÅ ‚àò (fun (x : M) (x_1 : Œ±) ‚Ü¶ x ‚Ä¢ x_1) a‚ÇÇ =\n    (fun (x : M) (x_1 : Œ±) ‚Ü¶ x ‚Ä¢ x_1) (a‚ÇÅ * a‚ÇÇ)","name":"comp_smul_left","isProp":true,"docString":"`SMul` version of `comp_mul_left` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (hf : MonotoneOn f s) (hg : StrictMonoOn g s),\n  StrictMonoOn (fun (x : Œ≤) ‚Ü¶ f x * g x) s","name":"MonotoneOn.mul_strictMono'","isProp":true,"docString":"The product of a monotone function and a strictly monotone function is strictly monotone. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G]\n  [inst_3 : LocallyCompactSpace G] {U : Set G} (hU : U ‚àà nhds 0),\n  ‚àÉ (K : Set G), (IsCompact K : Prop) ‚àß ((IsClosed K : Prop) ‚àß ((K ‚äÜ U : Prop) ‚àß (0 ‚àà interior K : Prop) : Prop) : Prop)","name":"local_isCompact_isClosed_nhds_of_addGroup","isProp":true,"docString":"In a locally compact additive group, any neighborhood of the identity contains a\ncompact closed neighborhood of the identity, even without separation assumptions on the space."},{"type":"‚àÄ {G : Type u_1} [inst : AddCommGroup G] (B : AddGroupFilterBasis G), UniformAddGroup G","name":"AddGroupFilterBasis.uniformAddGroup","isProp":true,"docString":"The uniform space structure associated to an abelian group filter basis via the associated\ntopological abelian group structure is compatible with its group structure. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] [self : CategoryTheory.SplitEpiCategory C] {X : C} {Y : C}\n  (f : X ‚ü∂ Y) [inst_1 : CategoryTheory.Epi f], CategoryTheory.IsSplitEpi f","name":"CategoryTheory.SplitEpiCategory.isSplitEpi_of_epi","isProp":true,"docString":"All epis are split "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±},\n  (a ‚ãñ b : Prop) ‚Üî\n    ((a < b : Prop) ‚àß (‚àÄ (c : Œ±) (a_1 : a ‚â§ c) (a_2 : c ‚â§ b), (c = a : Prop) ‚à® (c = b : Prop) : Prop) : Prop)","name":"covby_iff_lt_and_eq_or_eq","isProp":true,"docString":"An `iff` version of `Covby.eq_or_eq` and `covby_of_eq_or_eq`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : T0Space Œ±] [inst_2 : CompactSpace Œ±] {S : Set Œ±}\n  (hS : IsClosed S) (hne : Set.Nonempty S), ‚àÉ (x : Œ±), (x ‚àà S : Prop) ‚àß (IsClosed {x} : Prop)","name":"IsClosed.exists_closed_singleton","isProp":true,"docString":"Given a closed set `S` in a compact T‚ÇÄ space, there is some `x ‚àà S` such that `{x}` is\nclosed. "},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {s : Set Œ±} {a : Œ±} (h : IsLUB s a), BddAbove s","name":"IsLUB.bddAbove","isProp":true,"docString":"If `s` has a least upper bound, then it is bounded above. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrder Œ±] (a : Œ±) (b : Œ±), compare a b = compareOfLessAndEq a b","name":"LinearOrder.compare_eq_compareOfLessAndEq","isProp":true,"docString":"Comparison via `compare` is equal to the canonical comparison given decidable `<` and `=`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {S : Set Œ±}\n  (hS : IsPreconnected S) {T : Set Œ≤} [inst_2 : DiscreteTopology ‚ÜëT] {f : (a : Œ±) ‚Üí Œ≤} (hc : ContinuousOn f S)\n  (hTm : Set.MapsTo f S T) {x : Œ±} {y : Œ±} (hx : x ‚àà S) (hy : y ‚àà S), f x = f y","name":"IsPreconnected.constant_of_mapsTo","isProp":true,"docString":"Refinement of `IsPreconnected.constant` only assuming the map factors through a\ndiscrete subset of the target. "},{"type":"‚àÄ {Œπ : Type u_1} {X : (a : Œπ) ‚Üí Type u_2} {Y : (a : Œπ) ‚Üí Type u_3} [inst : (i : Œπ) ‚Üí TopologicalSpace (X i)]\n  [inst_1 : (i : Œπ) ‚Üí TopologicalSpace (Y i)] {f‚ÇÄ : (i : Œπ) ‚Üí C(X i, Y i)} {f‚ÇÅ : (i : Œπ) ‚Üí C(X i, Y i)}\n  (F : ‚àÄ (i : Œπ), ContinuousMap.Homotopic (f‚ÇÄ i) (f‚ÇÅ i)),\n  ContinuousMap.Homotopic (ContinuousMap.piMap f‚ÇÄ) (ContinuousMap.piMap f‚ÇÅ)","name":"ContinuousMap.Homotopic.piMap","isProp":true,"docString":"If each `f‚ÇÄ i : C(X, Y i)` is homotopic to `f‚ÇÅ i : C(X, Y i)`, then `ContinuousMap.pi f‚ÇÄ` is\nhomotopic to `ContinuousMap.pi f‚ÇÅ`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : NormalizedGCDMonoid Œ±] (a : Œ±) (b : Œ±),\n  ‚Üënormalize (lcm a b) = lcm a b","name":"NormalizedGCDMonoid.normalize_lcm","isProp":true,"docString":"The LCM is normalized to itself. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : SuccOrder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Antitone f), Pairwise (Disjoint on fun (n : Œ±) ‚Ü¶ Set.Ioo (f (Order.succ n)) (f n))","name":"Antitone.pairwise_disjoint_on_Ioo_succ","isProp":true,"docString":"If `Œ±` is a linear succ order, `Œ≤` is a preorder, and `f : Œ± ‚Üí Œ≤` is an antitone function, then\nthe intervals `Set.Ioo (f (Order.succ n)) (f n)` are pairwise disjoint. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ±] [inst_1 : CommMonoid Œ≤] {s : Finset Œ±} {x : Œ±} (h : ¬¨(x ‚àà s : Prop))\n  (f : (a : Finset Œ±) ‚Üí Œ≤),\n  (Finset.prod (Finset.powerset (insert x s)) fun (a : Finset Œ±) ‚Ü¶ f a) =\n    (Finset.prod (Finset.powerset s) fun (a : Finset Œ±) ‚Ü¶ f a) *\n      Finset.prod (Finset.powerset s) fun (t : Finset Œ±) ‚Ü¶ f (insert x t)","name":"Finset.prod_powerset_insert","isProp":true,"docString":"A product over all subsets of `s ‚à™ {x}` is obtained by multiplying the product over all subsets\nof `s`, and over all subsets of `s` to which one adds `x`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] [self : IsAtomistic Œ±] (b : Œ±),\n  ‚àÉ (s : Set Œ±), (b = sup‚Çõ s : Prop) ‚àß (‚àÄ (a : Œ±) (a_1 : a ‚àà s), IsAtom a : Prop)","name":"IsAtomistic.eq_sup‚Çõ_atoms","isProp":true,"docString":"Every element is a `sup‚Çõ` of a set of atoms. "},{"type":"‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R} (a : Ideal.IsRadical I), Ideal.radical I = I","name":"Ideal.IsRadical.radical","isProp":true,"docString":"**Alias** of the reverse direction of `Ideal.radical_eq_iff`."},{"type":"‚àÄ {R : Type u_1} [inst : Monoid R] [inst_1 : HasDistribNeg R] (a : R), (-a) ^ 2 = a ^ 2","name":"neg_pow_two","isProp":true,"docString":"**Alias** of `neg_sq`."},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] {œÉ : Type u_3} [inst_1 : CanonicallyOrderedAddMonoid M]\n  {w : (a : œÉ) ‚Üí M} (œÜ : MvPolynomial œÉ R) [inst_2 : NoZeroSMulDivisors ‚Ñï M] (hw : ‚àÄ (i : œÉ), w i ‚â† 0),\n  ‚Üë(MvPolynomial.weightedHomogeneousComponent w 0) œÜ = ‚ÜëMvPolynomial.C (MvPolynomial.coeff 0 œÜ)","name":"MvPolynomial.weightedHomogeneousComponent_zero","isProp":true,"docString":"If `M` is a `CanonicallyOrderedAddMonoid`, then the `weightedHomogeneousComponent`\nof weighted degree `0` of a polynomial is its constant coefficient. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±] [inst_3 : NoMinOrder Œ±]\n  {a : Œ±} {s : Set Œ±},\n  (s ‚àà nhdsWithin a (Set.Iic a) : Prop) ‚Üî (‚àÉ (l : Œ±), (l ‚àà Set.Iio a : Prop) ‚àß (Set.Ioc l a ‚äÜ s : Prop) : Prop)","name":"mem_nhdsWithin_Iic_iff_exists_Ioc_subset","isProp":true,"docString":"A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`\nwith `l < a`. "},{"type":"‚àÄ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (Alexandroff X)","name":"Alexandroff.instConnectedSpaceAlexandroffInstTopologicalSpaceAlexandroff","isProp":true,"docString":"If `X` is not a compact space, then `Alexandroff X` is a connected space. "},{"type":"‚àÄ {Œπ : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] [inst_1 : LT M] {s : Finset Œπ} {f : (a : Œπ) ‚Üí WithTop M},\n  ((Finset.sum s fun (i : Œπ) ‚Ü¶ f i) < ‚ä§ : Prop) ‚Üî (‚àÄ (i : Œπ) (a : i ‚àà s), f i < ‚ä§ : Prop)","name":"WithTop.sum_lt_top_iff","isProp":true,"docString":"A sum of finite numbers is still finite "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {F : (a : Œπ) ‚Üí (a : Œ±) ‚Üí Œ≤} {f : (a : Œ±) ‚Üí Œ≤}\n  {s : Set Œ±} {p : Filter Œπ} (a : TendstoUniformlyOn F f p s), TendstoUniformlyOnFilter F f p (Filter.principal s)","name":"TendstoUniformlyOn.tendstoUniformlyOnFilter","isProp":true,"docString":"**Alias** of the forward direction of `tendstoUniformlyOn_iff_tendstoUniformlyOnFilter`."},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : MulZeroOneClass M] [inst_1 : MulZeroOneClass N] (self : M ‚Üí*‚ÇÄ N) (x : M)\n  (y : M), ZeroHom.toFun (‚Üëself) (x * y) = ZeroHom.toFun (‚Üëself) x * ZeroHom.toFun (‚Üëself) y","name":"MonoidWithZeroHom.map_mul'","isProp":true,"docString":"The proposition that the function preserves multiplication "},{"type":"‚àÄ {G : Type u} {x : G} {y : G} [inst : AddMonoid G] (h : AddCommute x y) (hy : IsOfFinAddOrder y)\n  (hdvd : ‚àÄ (p : ‚Ñï) (a : Nat.Prime p) (a : p ‚à£ addOrderOf x), p * addOrderOf x ‚à£ addOrderOf y),\n  addOrderOf (x + y) = addOrderOf y","name":"AddCommute.addOrderOf_add_eq_right_of_forall_prime_mul_dvd","isProp":true,"docString":"If each prime factor of\n`addOrderOf x` has higher multiplicity in `addOrderOf y`, and `x` commutes with `y`,\nthen `x + y` has the same order as `y`."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {e : LocalEquiv Œ± Œ≤} {s : Set Œ±} {t : Set Œ≤}\n  (a : LocalEquiv.target e ‚à© LocalEquiv.toFun (LocalEquiv.symm e) ‚Åª¬π' s = LocalEquiv.target e ‚à© t),\n  LocalEquiv.IsImage e s t","name":"LocalEquiv.IsImage.of_symm_preimage_eq","isProp":true,"docString":"**Alias** of the reverse direction of `LocalEquiv.IsImage.iff_symm_preimage_eq`."},{"type":"‚àÄ {Œπ : Type u_3} {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Fintype Œπ] {P : Submodule R M} (b : Basis Œπ R { x : M // x ‚àà P }) {x : M},\n  (x ‚àà P : Prop) ‚Üî (‚àÉ (c : (a : Œπ) ‚Üí R), x = ‚Üë(Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ c i ‚Ä¢ ‚Üëb i) : Prop)","name":"Basis.mem_submodule_iff'","isProp":true,"docString":"If the submodule `P` has a finite basis,\n`x ‚àà P` iff it is a linear combination of basis vectors. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  [inst_3 : Star A] [inst_4 : Semiring B] [inst_5 : Algebra R B] [inst_6 : Star B] (self : A ‚Üí‚ãÜ‚Çê[R] B) (x : A),\n  OneHom.toFun (‚Üë‚Üë‚Üë(StarAlgHom.toAlgHom self)) (star x) = star (OneHom.toFun (‚Üë‚Üë‚Üë(StarAlgHom.toAlgHom self)) x)","name":"StarAlgHom.map_star'","isProp":true,"docString":"By definition, a ‚ãÜ-algebra homomorphism preserves the `star` operation. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Preadditive C] {J : Type} [inst_2 : Finite J]\n  (f : (a : J) ‚Üí C) [inst_3 : CategoryTheory.Limits.HasCoproduct f], CategoryTheory.Limits.HasBiproduct f","name":"CategoryTheory.Limits.HasBiproduct.of_hasCoproduct","isProp":true,"docString":"In a preadditive category, if the coproduct over `f : J ‚Üí C` exists,\nthen the biproduct over `f` exists. "},{"type":"‚àÄ {Œπ : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : CompleteSpace E] {f : (a : Œπ) ‚Üí E}\n  (g : (a : Œπ) ‚Üí ‚Ñù) (hg : Summable g) (h : Filter.Eventually (fun (i : Œπ) ‚Ü¶ ‚Äñf i‚Äñ ‚â§ g i) Filter.cofinite), Summable f","name":"summable_of_norm_bounded_eventually","isProp":true,"docString":"Variant of the direct comparison test for series:  if the norm of `f` is eventually bounded by a\nreal function `g` which is summable, then `f` is summable. "},{"type":"‚àÄ (k : Type u_2) (V : Type u_4) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} {p0 : P} {s : Set Œπ} {p : (a : Œπ) ‚Üí P},\n  (‚àÉ (fs : Finset Œπ),\n        ‚àÉ (x : ‚Üëfs ‚äÜ s),\n          ‚àÉ (w : (a : Œπ) ‚Üí k),\n            ‚àÉ (x : (Finset.sum fs fun (i : Œπ) ‚Ü¶ w i) = 1), p0 = ‚Üë(Finset.affineCombination k fs p) w :\n      Prop) ‚Üî\n    (‚àÉ (fs : Finset ‚Üës),\n        ‚àÉ (w : (a : ‚Üës) ‚Üí k),\n          ‚àÉ (x : (Finset.sum fs fun (i : ‚Üës) ‚Ü¶ w i) = 1), p0 = ‚Üë(Finset.affineCombination k fs fun (i : ‚Üës) ‚Ü¶ p ‚Üëi) w :\n      Prop)","name":"Finset.eq_affineCombination_subset_iff_eq_affineCombination_subtype","isProp":true,"docString":"Suppose an indexed family of points is given, along with a subset\nof the index type.  A point can be expressed as an\n`affineCombination` using a `Finset` lying within that subset and\nwith sum of weights 1 if and only if it can be expressed an\n`affineCombination` with sum of weights 1 for the corresponding\nindexed family whose index type is the subtype corresponding to that\nsubset. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} {p : (a : Œπ) ‚Üí P} (ha : AffineIndependent k p) (s : Set Œπ),\n  AffineIndependent k fun (i : ‚Üës) ‚Ü¶ p ‚Üëi","name":"AffineIndependent.subtype","isProp":true,"docString":"If a family is affinely independent, so is any subfamily indexed\nby a subtype of the index type. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {Œ≤ : Type u_1} [inst_1 : TopologicalSpace Œ≤]\n  [inst_2 : TotallyDisconnectedSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (h : Continuous f) (a : Œ±), f '' connectedComponent a = {f a}","name":"Continuous.image_connectedComponent_eq_singleton","isProp":true,"docString":"The image of a connected component in a totally disconnected space is a singleton. "},{"type":"‚àÄ {E : (a : ‚Ñï) ‚Üí Type u_1} [inst : (n : ‚Ñï) ‚Üí TopologicalSpace (E n)] [inst_1 : ‚àÄ (n : ‚Ñï), DiscreteTopology (E n)]\n  {s : Set ((n : ‚Ñï) ‚Üí E n)} (hs : IsClosed s) (hne : Set.Nonempty s),\n  ‚àÉ (f : (a : (n : ‚Ñï) ‚Üí E n) ‚Üí (n : ‚Ñï) ‚Üí E n),\n    (‚àÄ (x : (n : ‚Ñï) ‚Üí E n) (a : x ‚àà s), f x = x : Prop) ‚àß ((Set.range f = s : Prop) ‚àß (LipschitzWith 1 f : Prop) : Prop)","name":"PiNat.exists_lipschitz_retraction_of_isClosed","isProp":true,"docString":"Given a closed nonempty subset `s` of `Œ† (n : ‚Ñï), E n`, there exists a Lipschitz retraction\nonto this set, i.e., a Lipschitz map with range equal to `s`, equal to the identity on `s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : r < 0)\n  (hf : Filter.Tendsto f l Filter.atBot), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atTop","name":"Filter.Tendsto.atBot_mul_neg_const","isProp":true,"docString":"If a function tends to negative infinity along a filter, then this function multiplied by\na negative constant (on the right) tends to positive infinity. "},{"type":"‚àÄ {Œ± : Type u} [self : Semiring Œ±] (n : ‚Ñï), NatCast.natCast (n + 1) = NatCast.natCast n + 1","name":"Semiring.natCast_succ","isProp":true,"docString":"The canonical map `‚Ñï ‚Üí R` is a homomorphism. "},{"type":"‚àÄ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}\n  [inst_3 : AddCommGroup F] [inst_4 : Module R F] (f : E ‚Üí‚Çó.[R] F) (x : { x : E // x ‚àà LinearPMap.domain f }),\n  (‚Üëx, ‚Üëf x) ‚àà LinearPMap.graph f","name":"LinearPMap.mem_graph","isProp":true,"docString":"The tuple `(x, f x)` is contained in the graph of `f`. "},{"type":"‚àÄ {Œ± : Type u} {f : Ultrafilter Œ±} {p : (a : Œ±) ‚Üí Prop} (a : Filter.Frequently (fun (x : Œ±) ‚Ü¶ p x) ‚Üëf),\n  Filter.Eventually (fun (x : Œ±) ‚Ü¶ p x) ‚Üëf","name":"Filter.Frequently.eventually","isProp":true,"docString":"**Alias** of the forward direction of `Ultrafilter.frequently_iff_eventually`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : Fintype Œ±] (f : (a : Œ±) ‚Üí Œ≤) [inst_1 : Fintype Œ≤]\n  [inst_2 : DecidablePred fun (y : Œ≤) ‚Ü¶ y ‚àà Set.range f] [inst_3 : DecidableEq Œ≤],\n  Finset.filter (fun (y : Œ≤) ‚Ü¶ y ‚àà Set.range f) Finset.univ = Finset.image f Finset.univ","name":"Finset.univ_filter_mem_range","isProp":true,"docString":"Note this is a special case of `(finset.image_preimage f univ _).symm`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Add Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  (hf : MonotoneOn f s) (hg : MonotoneOn g s), MonotoneOn (fun (x : Œ≤) ‚Ü¶ f x + g x) s","name":"MonotoneOn.add","isProp":true,"docString":"The sum of two monotone functions is monotone."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {œÉ : Equiv.Perm Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  [inst_1 : Fintype Œπ] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g (‚ÜëœÉ i)) = Finset.sum Finset.univ fun (i : Œπ) ‚Ü¶ f i * g i : Prop) ‚Üî\n    (Monovary f (g ‚àò ‚ÜëœÉ) : Prop)","name":"Monovary.sum_mul_comp_perm_eq_sum_mul_iff","isProp":true,"docString":"**Equality case of Rearrangement Inequality**: Pointwise multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f` and `g ‚àò œÉ` monovary\ntogether. Stated by permuting the entries of `g`. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} [self : CategoryTheory.Mono f] {Z : C}\n  (g : Z ‚ü∂ X) (h : Z ‚ü∂ X) (a : g ‚â´ f = h ‚â´ f), g = h","name":"CategoryTheory.Mono.right_cancellation","isProp":true,"docString":"A morphism `f` is an monomorphism if it can be cancelled when postcomposed. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} (hs : IsCompact s) {e : ‚Ñù} (he : 0 < e),\n  ‚àÉ (t : Set Œ±),\n    (t ‚äÜ s : Prop) ‚àß\n      ((Set.Finite t : Prop) ‚àß (s ‚äÜ Set.union·µ¢ fun (x : Œ±) ‚Ü¶ Set.union·µ¢ fun (h : x ‚àà t) ‚Ü¶ Metric.ball x e : Prop) :\n        Prop)","name":"finite_cover_balls_of_compact","isProp":true,"docString":"Any compact set in a pseudometric space can be covered by finitely many balls of a given\npositive radius "},{"type":"‚àÄ {M : Type u_1} [inst : AddSemigroup M] {a : Stream' M} {m : M} (hm : m ‚àà Hindman.FS a),\n  ‚àÉ (n : ‚Ñï), ‚àÄ (m' : M) (a_1 : m' ‚àà Hindman.FS (Stream'.drop n a)), m + m' ‚àà Hindman.FS a","name":"Hindman.FS.add","isProp":true,"docString":"If `m` and `m'` are finite sums in `M`, then so is `m + m'`, provided that `m'`\nis obtained from a subsequence of `M` starting sufficiently late."},{"type":"‚àÄ {p : ‚Ñï} {n : ‚Ñï} {k : ‚Ñï} (hn : 0 < n), p ^ ‚Üë(Nat.factorization (Nat.choose n k)) p ‚â§ n","name":"Nat.pow_factorization_choose_le","isProp":true,"docString":"A `pow` form of `Nat.factorization_choose_le` "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±}\n  (a : StrictMono (Set.restrict s f)), StrictMonoOn f s","name":"StrictMono.of_restrict","isProp":true,"docString":"**Alias** of the forward direction of `strictMono_restrict`."},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category C] {F : J ‚•§ C}\n  {t : CategoryTheory.Limits.Cone F} (self : CategoryTheory.Limits.IsLimit t) (s : CategoryTheory.Limits.Cone F)\n  (m : CategoryTheory.Limits.Cone.pt s ‚ü∂ CategoryTheory.Limits.Cone.pt t)\n  (x : ‚àÄ (j : J), m ‚â´ (CategoryTheory.Limits.Cone.œÄ t).app j = (CategoryTheory.Limits.Cone.œÄ s).app j),\n  m = CategoryTheory.Limits.IsLimit.lift self s","name":"CategoryTheory.Limits.IsLimit.uniq","isProp":true,"docString":"It is the unique such map to do this "},{"type":"‚àÄ {Œ± : Sort u_1} {a : Œ±} {b : Œ±} (a_1 : HEq a b), a = b","name":"HEq.eq","isProp":true,"docString":"**Alias** of the forward direction of `heq_iff_eq`."},{"type":"‚àÄ {Œ± : Type v} [inst : CanonicallyOrderedAddMonoid Œ±] [inst_1 : Sub Œ±] [inst_2 : OrderedSub Œ±]\n  [inst_3 : ContravariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x + x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {f : (a : ‚Ñï) ‚Üí Œ±}\n  (h : Monotone f) (n : ‚Ñï), (Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ f (i + 1) - f i) = f n - f 0","name":"Finset.sum_range_tsub","isProp":true,"docString":"A telescoping sum along `{0, ..., n-1}` of an `‚Ñï`-valued function\nreduces to the difference of the last and first terms\nwhen the function we are summing is monotone.\n"},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasImages C]\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C] [inst_3 : CategoryTheory.Limits.HasEqualizers C],\n  CategoryTheory.Limits.HasStrongEpiImages C","name":"CategoryTheory.Limits.hasStrongEpiImages_of_hasPullbacks_of_hasEqualizers","isProp":true,"docString":"If a category has images, equalizers and pullbacks, then images are automatically strong epi\nimages. "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (f : (a : ‚Ñï) ‚Üí Œ±) (n : ‚Ñï),\n  edist (f 0) (f n) ‚â§ Finset.sum (Finset.range n) fun (i : ‚Ñï) ‚Ü¶ edist (f i) (f (i + 1))","name":"edist_le_range_sum_edist","isProp":true,"docString":"The triangle (polygon) inequality for sequences of points; `Finset.range` version. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LE Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±},\n  (1 ‚â§ a‚Åª¬π : Prop) ‚Üî (a ‚â§ 1 : Prop)","name":"one_le_inv'","isProp":true,"docString":"**Alias** of `Left.one_le_inv_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : CoheytingAlgebra Œ±] (a : Œ±) (b : Œ±),\n  Coheyting.boundary (a ‚äì b) = Coheyting.boundary a ‚äì b ‚äî a ‚äì Coheyting.boundary b","name":"Coheyting.boundary_inf","isProp":true,"docString":"**Leibniz rule** for the co-Heyting boundary. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : BoundedOrder Œ±] [inst_2 : IsSimpleOrder Œ±] {a : Œ±} {b : Œ±} (h : a < b),\n  a = ‚ä•","name":"IsSimpleOrder.LT.lt.eq_bot","isProp":true,"docString":"**Alias** of `IsSimpleOrder.eq_bot_of_lt`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : MulOneClass Œ±] [inst_1 : Preorder Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1] {a : Œ±} {b : Œ±}\n  (ha : a < 1) (hb : b < 1), a * b < 1","name":"mul_lt_one'","isProp":true,"docString":"**Alias** of `Left.mul_lt_one'`."},{"type":"‚àÄ {Œ± : Type u} [inst : Preorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±} (a_1 : b = c) (a_2 : a < b), a < c","name":"Eq.trans_gt","isProp":true,"docString":"**Alias** of `lt_of_eq_of_lt'`."},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : ConditionallyCompleteLinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤]\n  [inst_5 : OrderClosedTopology Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} (Cf : ContinuousAt f (sup‚Çõ s)) (Mf : Monotone f)\n  (ne : Set.Nonempty s) (H : BddAbove s), f (sup‚Çõ s) = sup‚Çõ (f '' s)","name":"Monotone.map_csup‚Çõ_of_continuousAt","isProp":true,"docString":"If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,\nthen it sends this supremum to the supremum of the image of `s`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {f : (a : Œ≤) ‚Üí Œ±}\n  {g : (a : Œ≤) ‚Üí Œ±} {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  (hf : StrictAntiOn f s) (hg : StrictAntiOn g s), StrictAntiOn (fun (x : Œ≤) ‚Ü¶ f x * g x) s","name":"StrictAntiOn.mul'","isProp":true,"docString":"The product of two strictly antitone functions is strictly antitone. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Sup Œ±] [inst_1 : Sup Œ≤] (self : SupHom Œ± Œ≤) (a : Œ±) (b : Œ±),\n  SupHom.toFun self (a ‚äî b) = SupHom.toFun self a ‚äî SupHom.toFun self b","name":"SupHom.map_sup'","isProp":true,"docString":"A `SupHom` preserves suprema. "},{"type":"‚àÄ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R} [inst_1 : Nontrivial R], (IsRegular a : Prop) ‚Üî (a ‚â† 0 : Prop)","name":"isRegular_iff_ne_zero","isProp":true,"docString":"In a non-trivial integral domain, an element is regular iff it is non-zero. "},{"type":"‚àÄ {E : Type u_1} [inst : SeminormedAddGroup E],\n  Filter.Tendsto Neg.neg (Filter.comap norm Filter.atTop) (Filter.comap norm Filter.atTop)","name":"Filter.tendsto_neg_cobounded","isProp":true,"docString":"In a (semi)normed group, negation `x ‚Ü¶ -x` tends to infinity at infinity. TODO: use\n`Bornology.cobounded` instead of `Filter.comap Norm.norm Filter.atTop`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] (a : Œ±) [inst_4 : NoMinOrder Œ±], closure (Set.Iio a) = Set.Iic a","name":"closure_Iio","isProp":true,"docString":"The closure of the interval `(-‚àû, a)` is the interval `(-‚àû, a]`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CanonicallyOrderedAddMonoid Œ±] [inst_1 : Sub Œ±] [inst_2 : OrderedSub Œ±] {a : Œ±} {b : Œ±}\n  (a_1 : a ‚â§ b), a - b = 0","name":"tsub_eq_zero_of_le","isProp":true,"docString":"**Alias** of the reverse direction of `tsub_eq_zero_iff_le`."},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {u : V} {v : V} {w : V} (h : SimpleGraph.Adj G u v) (p : SimpleGraph.Walk G v w),\n  ‚àÉ (x : V),\n    ‚àÉ (q : SimpleGraph.Walk G u x),\n      ‚àÉ (h' : SimpleGraph.Adj G x w), SimpleGraph.Walk.cons h p = SimpleGraph.Walk.concat q h'","name":"SimpleGraph.Walk.exists_cons_eq_concat","isProp":true,"docString":"A non-trivial `cons` walk is representable as a `concat` walk. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [self : CategoryTheory.IsCofilteredOrEmpty C] (X : C) (Y : C),\n  ‚àÉ (W : C), ‚àÉ (x : W ‚ü∂ X), ‚àÉ (x : W ‚ü∂ Y), True","name":"CategoryTheory.IsCofilteredOrEmpty.cone_objs","isProp":true,"docString":"for every pair of objects there exists another object \"to the left\" "},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} {M : Type u_4} [inst : SMul Œ± M] [inst_1 : SMul Œ≤ M]\n  [inst_2 : SMulCommClass Œ± Œ≤ M], SMulCommClass Œ± Œ≤ ((a : Œπ) ‚Üí M)","name":"Function.smulCommClass","isProp":true,"docString":"Non-dependent version of `Pi.smulCommClass`. Lean gets confused by the dependent instance if\nthis is not present. "},{"type":"‚àÄ (l : List ‚Ñï) (n : ‚Ñï), List.Sorted (fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x < x_1) (Denumerable.raise' l n)","name":"Denumerable.raise'_sorted","isProp":true,"docString":"`raise' l n` is a strictly increasing sequence. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {f : M ‚Üí* N}\n  (h : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëf ‚Üëy)) {y : { x : M // x ‚àà S }} {z : N} (H : ‚Üëf ‚Üëy * z = 1),\n  ‚Üë(‚Üë(IsUnit.liftRight (MonoidHom.restrict f S) h) y)‚Åª¬π = z","name":"Submonoid.LocalizationMap.inv_unique","isProp":true,"docString":"Given a MonoidHom `f : M ‚Üí* N` and Submonoid `S ‚äÜ M` such that `f(S) ‚äÜ NÀ£`, for all\n`y ‚àà S`, `(f y)‚Åª¬π` is unique. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {a : R} [inst : Monoid R] [inst_1 : MulAction R M] (n : ‚Ñï) (ra : IsSMulRegular M a),\n  IsSMulRegular M (a ^ n)","name":"IsSMulRegular.pow","isProp":true,"docString":"Any power of an `M`-regular element is `M`-regular. "},{"type":"‚àÄ {Œ± : Type u_1} {l : List Œ±} {l' : List Œ±},\n  (List.Sublist l l' : Prop) ‚Üî\n    (‚àÉ (f : Fin (List.length l) ‚Ü™o Fin (List.length l')),\n        ‚àÄ (ix : Fin (List.length l)), List.get l ix = List.get l' (‚Üëf ix) :\n      Prop)","name":"List.sublist_iff_exists_fin_orderEmbedding_get_eq","isProp":true,"docString":"A `l : List Œ±` is `Sublist l l'` for `l' : List Œ±` iff\nthere is `f`, an order-preserving embedding of `Fin l.length` into `Fin l'.length` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoEMetricSpace Œ±] (Œ¥ : ‚Ñù) (E : Set Œ±), closure E ‚äÜ Metric.cthickening Œ¥ E","name":"Metric.closure_subset_cthickening","isProp":true,"docString":"The closed thickening of a set contains the closure of the set. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {s : Set Œ±} {U : Set Œ±}\n  (h : U ‚àà sup·µ¢ fun (x : Œ±) ‚Ü¶ sup·µ¢ fun (h : x ‚àà s) ‚Ü¶ nhds x),\n  ‚àÉ (V : Set Œ±), (s ‚äÜ V : Prop) ‚àß ((IsOpen V : Prop) ‚àß (V ‚äÜ U : Prop) : Prop)","name":"exists_open_set_nhds'","isProp":true,"docString":"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. "},{"type":"‚àÄ {a : Cardinal} {b : Cardinal},\n  (Cardinal.aleph0 ‚â§ a * b : Prop) ‚Üî\n    ((a ‚â† 0 : Prop) ‚àß ((b ‚â† 0 : Prop) ‚àß ((Cardinal.aleph0 ‚â§ a : Prop) ‚à® (Cardinal.aleph0 ‚â§ b : Prop) : Prop) : Prop) :\n      Prop)","name":"Cardinal.aleph0_le_mul_iff","isProp":true,"docString":"See also `Cardinal.aleph0_le_mul_iff`. "},{"type":"‚àÄ {Œπ : Type u_2} {œá : (a : Œπ) ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí TopologicalSpace (œá i)] {as : (i : Œπ) ‚Üí œá i}\n  {bs : (i : Œπ) ‚Üí œá i} {cs : (i : Œπ) ‚Üí œá i} (Œ≥‚ÇÄ : (i : Œπ) ‚Üí Path (as i) (bs i)) (Œ≥‚ÇÅ : (i : Œπ) ‚Üí Path (bs i) (cs i)),\n  Path.trans (Path.pi Œ≥‚ÇÄ) (Path.pi Œ≥‚ÇÅ) = Path.pi fun (i : Œπ) ‚Ü¶ Path.trans (Œ≥‚ÇÄ i) (Œ≥‚ÇÅ i)","name":"Path.trans_pi_eq_pi_trans","isProp":true,"docString":"Path composition commutes with products "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±], Subsingleton (PredOrder Œ±)","name":"Order.instSubsingletonPredOrderToPreorder","isProp":true,"docString":"There is at most one way to define the predecessors in a `PartialOrder`. "},{"type":"‚àÄ {R : Type u_2} {R‚ÇÇ : Type u_4} {E : Type u_3} {E‚ÇÇ : Type u_5} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]\n  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_2 : SeminormedAddCommGroup E] [inst_3 : SeminormedAddCommGroup E‚ÇÇ] [inst_4 : Module R E]\n  [inst_5 : Module R‚ÇÇ E‚ÇÇ] {Œπ : Type u_1} (b : Basis Œπ R E) {f‚ÇÅ : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} {f‚ÇÇ : E ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ}\n  (h : ‚àÄ (i : Œπ), ‚Üëf‚ÇÅ (‚Üëb i) = ‚Üëf‚ÇÇ (‚Üëb i)), f‚ÇÅ = f‚ÇÇ","name":"Basis.ext_linearIsometry","isProp":true,"docString":"Two linear isometries are equal if they are equal on basis vectors. "},{"type":"‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category J] [inst_1 : Nonempty J]\n  (h :\n    ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚•§ CategoryTheory.Discrete Œ±) (j : J) (j' : J),\n      Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) j =\n        Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) j'),\n  CategoryTheory.IsConnected J","name":"CategoryTheory.IsConnected.of_any_functor_const_on_obj","isProp":true,"docString":"If any functor to a discrete category is constant on objects, J is connected.\nThe converse of `any_functor_const_on_obj`.\n"},{"type":"‚àÄ {Œì‚ÇÄ : Type u_1} [inst : LinearOrderedCommGroupWithZero Œì‚ÇÄ], T3Space Œì‚ÇÄ","name":"WithZeroTopology.t3Space","isProp":true,"docString":"The topology on a linearly ordered group with zero element adjoined is T‚ÇÉ. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {t : Finset Œ±} (h : s ‚äÜ t),\n  Finset.card (Finset.Icc s t) = 2 ^ (Finset.card t - Finset.card s)","name":"Finset.card_Icc_finset","isProp":true,"docString":"Cardinality of a non-empty `Icc` of finsets. "},{"type":"‚àÄ {k : Type u_1} {M : Type u_2} [inst : OrderedRing k] [inst_1 : OrderedAddCommGroup M] [inst_2 : Module k M]\n  [inst_3 : OrderedSMul k M] {a : M} {c : k} (hc : c < 0) (a_1 : 0 < a), c ‚Ä¢ a < 0","name":"smul_neg_of_neg_of_pos","isProp":true,"docString":"**Alias** of the reverse direction of `smul_neg_iff_of_neg`."},{"type":"‚àÄ {Œ≤ : Type v} {œÄ : (a : Œ≤) ‚Üí Type u_1} [inst : Fintype Œ≤] [inst_1 : (b : Œ≤) ‚Üí PseudoMetricSpace (œÄ b)]\n  (x : (b : Œ≤) ‚Üí œÄ b) {r : ‚Ñù} (hr : 0 < r), Metric.ball x r = Set.pi Set.univ fun (b : Œ≤) ‚Ü¶ Metric.ball (x b) r","name":"ball_pi","isProp":true,"docString":"An open ball in a product space is a product of open balls. See also `metric.ball_pi'`\nfor a version assuming `Nonempty Œ≤` instead of `0 < r`. "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} {u : V} {v : V} (p : SimpleGraph.Walk G u v) (S : Set V) (uS : u ‚àà S)\n  (vS : ¬¨(v ‚àà S : Prop)),\n  ‚àÉ (d : SimpleGraph.Dart G),\n    (d ‚àà SimpleGraph.Walk.darts p : Prop) ‚àß\n      ((Prod.fst (SimpleGraph.Dart.toProd d) ‚àà S : Prop) ‚àß (¬¨(Prod.snd (SimpleGraph.Dart.toProd d) ‚àà S : Prop) : Prop) :\n        Prop)","name":"SimpleGraph.Walk.exists_boundary_dart","isProp":true,"docString":"Given a set `S` and a walk `w` from `u` to `v` such that `u ‚àà S` but `v ‚àâ S`,\nthere exists a dart in the walk whose start is in `S` but whose end is not. "},{"type":"‚àÄ {Œ± : Type u_1}, (Sym2.map fun (x : Œ±) ‚Ü¶ x) = id","name":"Sym2.map_id'","isProp":true,"docString":"Note: `Sym2.map_id` will not simplify `Sym2.map id z` due to `Sym2.map_congr`. "},{"type":"‚àÄ {R : Type u_1} {A : Type u_2} [inst : Monoid A] [inst_1 : SMul R A] [inst_2 : SMulCommClass R A A]\n  [inst_3 : TopologicalSpace A] [inst : ContinuousMul A], ContinuousConstSMul R A","name":"SMulCommClass.continuousConstSMul","isProp":true,"docString":"If the action of `R` on `A` commutes with left-multiplication, then continuous multiplication\nimplies continuous scalar multiplication by constants.\n\nNotably, this instances applies when `R = A·µê·µí·µñ`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {s : Set Œ±·µí·µà} (a : IsLowerSet s), IsUpperSet (‚ÜëOrderDual.toDual ‚Åª¬π' s)","name":"IsLowerSet.toDual","isProp":true,"docString":"**Alias** of the reverse direction of `isUpperSet_preimage_toDual_iff`."},{"type":"‚àÄ {m : Type u} {Œ± : Type v} [inst : CommRing Œ±] [inst_1 : Fintype m] [inst_2 : DecidableEq m] {M : Matrix m m Œ±}\n  (h : IsUnit M) (N : Matrix m m Œ±), Matrix.det (Matrix.mul (Matrix.mul M N) M‚Åª¬π) = Matrix.det N","name":"Matrix.det_conj","isProp":true,"docString":"A variant of `Matrix.det_units_conj`. "},{"type":"‚àÄ {M : Type u} [inst : DivInvMonoid M] (x : M) (z : ‚Ñ§), { unop := x ^ z } = { unop := x } ^ z","name":"MulOpposite.op_zpow","isProp":true,"docString":"Moving to the opposite group or `GroupWithZero` commutes with taking powers. "},{"type":"‚àÄ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f : K ‚Üí+* L} {g : K ‚Üí+* L} {s : Set K}\n  (h : Set.EqOn (‚Üëf) (‚Üëg) s), Set.EqOn ‚Üëf ‚Üëg ‚Üë(Subfield.closure s)","name":"RingHom.eqOn_field_closure","isProp":true,"docString":"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrderedField Œ±] {l : Filter Œ≤} {f : (a : Œ≤) ‚Üí Œ±} {r : Œ±} (hr : 0 < r)\n  (hf : Filter.Tendsto f l Filter.atBot), Filter.Tendsto (fun (x : Œ≤) ‚Ü¶ f x * r) l Filter.atBot","name":"Filter.Tendsto.atBot_mul_const","isProp":true,"docString":"If a function tends to negative infinity along a filter, then this function multiplied by\na positive constant (on the right) also tends to negative infinity. "},{"type":"‚àÄ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (r : ‚Ñö) (x : E), ‚Üër ‚Ä¢ x = ‚Üër ‚Ä¢ x","name":"rat_cast_smul_eq","isProp":true,"docString":"If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on rational numbers in `R` and `S`. "},{"type":"‚àÄ {S : Type u_1} [inst : UnitalShelf S] (x : S) (y : S), Shelf.act (Shelf.act x y) x = Shelf.act x y","name":"UnitalShelf.act_act_self_eq","isProp":true,"docString":"A monoid is *graphic* if, for all `x` and `y`, the *graphic identity*\n`(x * y) * x = x * y` holds.  For a unital shelf, this graphic\nidentity holds.\n"},{"type":"‚àÄ {Œ± : Type u_3} {Œ≤ : Type u_2} [inst : PseudoMetricSpace Œ±] {Œπ : Type u_1} [inst_1 : PseudoMetricSpace Œ≤]\n  (b : (a : ‚Ñù) ‚Üí ‚Ñù) (b_lim : Filter.Tendsto b (nhds 0) (nhds 0)) (F : (a : Œπ) ‚Üí (a : Œ≤) ‚Üí Œ±)\n  (H : ‚àÄ (x : Œ≤) (y : Œ≤) (i : Œπ), dist (F i x) (F i y) ‚â§ b (dist x y)), UniformEquicontinuous F","name":"Metric.uniformEquicontinuous_of_continuity_modulus","isProp":true,"docString":"For a family of functions between (pseudo) metric spaces, a convenient way to prove\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\nmodulus. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_2} [inst : Norm F] {c : ‚Ñù} {g : (a : Œ±) ‚Üí F} {l : Filter Œ±} {u : (a : Œ±) ‚Üí ‚Ñù}\n  (a : Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ abs (u x)) g), Asymptotics.IsBigOWith c l u g","name":"Asymptotics.IsBigOWith.of_abs_left","isProp":true,"docString":"**Alias** of the forward direction of `Asymptotics.isBigOWith_abs_left`."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Y}\n  {c : CategoryTheory.Limits.Fork f g} (h : CategoryTheory.Limits.IsLimit c)\n  [inst_1 : CategoryTheory.Epi (CategoryTheory.Limits.Fork.Œπ c)], CategoryTheory.IsIso (CategoryTheory.Limits.Fork.Œπ c)","name":"CategoryTheory.Limits.isIso_limit_cone_parallelPair_of_epi","isProp":true,"docString":"An equalizer that is an epimorphism is an isomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedCommSemiring Œ±] (a : Œ±) (b : Œ±), min a b = if (a ‚â§ b : Prop) then a else b","name":"LinearOrderedCommSemiring.min_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `minOfLe`. "},{"type":"‚àÄ {Œ∑ : Type u_1} {Gs : (a : Œ∑) ‚Üí Type u_2} [inst : (i : Œ∑) ‚Üí Monoid (Gs i)] {x : (i : Œ∑) ‚Üí Gs i} (h : IsOfFinOrder x)\n  (i : Œ∑), IsOfFinOrder (x i)","name":"IsOfFinOrder.apply","isProp":true,"docString":"If a direct product has finite order then so does each component. "},{"type":"‚àÄ {Œ± : Type u_1} {m : MetricSpace Œ±} {m' : MetricSpace Œ±} (h : PseudoMetricSpace.toDist = PseudoMetricSpace.toDist),\n  m = m'","name":"MetricSpace.ext","isProp":true,"docString":"Two metric space structures with the same distance coincide. "},{"type":"‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], (0 < FiniteDimensional.finrank K V : Prop) ‚Üî (Nontrivial V : Prop)","name":"FiniteDimensional.finrank_pos_iff","isProp":true,"docString":"A finite dimensional space has positive `finrank` iff it is nontrivial. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] {a : Œ±} {b : Œ±} {h : a ‚â§ b} [inst_1 : TopologicalSpace Œ±]\n  [inst_2 : OrderTopology Œ±] [inst_3 : TopologicalSpace Œ≤] {f : (a : ‚Üë(Set.Icc a b)) ‚Üí Œ≤} (hf : Continuous f),\n  Continuous (Set.IccExtend h f)","name":"Continuous.Icc_extend'","isProp":true,"docString":"A useful special case of `continuous.Icc_extend`. "},{"type":"‚àÄ (k : Type u‚ÇÅ) {G : Type u‚ÇÇ} [inst : Semiring k] [inst_1 : Add G] {A : Type u‚ÇÉ} [inst_2 : NonUnitalNonAssocSemiring A]\n  [inst_3 : DistribMulAction k A] {œÜ‚ÇÅ : AddMonoidAlgebra k G ‚Üí‚Çô‚Çê[k] A} {œÜ‚ÇÇ : AddMonoidAlgebra k G ‚Üí‚Çô‚Çê[k] A}\n  (h : ‚àÄ (x : G), ‚ÜëœÜ‚ÇÅ (AddMonoidAlgebra.single x 1) = ‚ÜëœÜ‚ÇÇ (AddMonoidAlgebra.single x 1)), œÜ‚ÇÅ = œÜ‚ÇÇ","name":"AddMonoidAlgebra.nonUnitalAlgHom_ext","isProp":true,"docString":"A non_unital `k`-algebra homomorphism from `AddMonoidAlgebra k G` is uniquely defined by its\nvalues on the functions `single a 1`. "},{"type":"‚àÄ {M : Type u_1} [inst : AddCommMonoid M] (h : Module ‚Ñï M) (n : ‚Ñï) (x : M), SMul.smul n x = n ‚Ä¢ x","name":"nat_smul_eq_nsmul","isProp":true,"docString":"Convert back any exotic `‚Ñï`-smul to the canonical instance. This should not be needed since in\nmathlib all `AddCommMonoid`s should normally have exactly one `‚Ñï`-module structure by design.\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Ring Œ±] [inst_1 : Ring Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsRingHom f), IsSemiringHom f","name":"IsRingHom.to_isSemiringHom","isProp":true,"docString":"A ring homomorphism is also a semiring homomorphism. "},{"type":"‚àÄ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {f : M ‚Üí* N}\n  (h : ‚àÄ (y : { x : M // x ‚àà S }), IsUnit (‚Üëf ‚Üëy)) {x‚ÇÅ : M} {x‚ÇÇ : M} {y‚ÇÅ : { x : M // x ‚àà S }}\n  {y‚ÇÇ : { x : M // x ‚àà S }},\n  (‚Üëf x‚ÇÅ * ‚Üë(‚Üë(IsUnit.liftRight (MonoidHom.restrict f S) h) y‚ÇÅ)‚Åª¬π =\n        ‚Üëf x‚ÇÇ * ‚Üë(‚Üë(IsUnit.liftRight (MonoidHom.restrict f S) h) y‚ÇÇ)‚Åª¬π :\n      Prop) ‚Üî\n    (‚Üëf (x‚ÇÅ * ‚Üëy‚ÇÇ) = ‚Üëf (x‚ÇÇ * ‚Üëy‚ÇÅ) : Prop)","name":"Submonoid.LocalizationMap.mul_inv","isProp":true,"docString":"Given a MonoidHom `f : M ‚Üí* N` and Submonoid `S ‚äÜ M` such that\n`f(S) ‚äÜ NÀ£`, for all `x‚ÇÅ x‚ÇÇ : M` and `y‚ÇÅ, y‚ÇÇ ‚àà S`, we have\n`f x‚ÇÅ * (f y‚ÇÅ)‚Åª¬π = f x‚ÇÇ * (f y‚ÇÇ)‚Åª¬π ‚Üî f (x‚ÇÅ * y‚ÇÇ) = f (x‚ÇÇ * y‚ÇÅ)`. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] {s‚ÇÇ : Finset Œπ} (h : s‚ÇÇ ‚äÜ s)\n  (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.weightedVSub (s \\ s‚ÇÇ) p) w + ‚Üë(Finset.weightedVSub s‚ÇÇ p) w = ‚Üë(Finset.weightedVSub s p) w","name":"Finset.weightedVSub_sdiff","isProp":true,"docString":"A weighted sum may be split into such sums over two subsets. "},{"type":"‚àÄ {Œπ : Type u_1} {R : Type u_2} {Œ± : Type u_4} {S : Type u_3} [inst : SetLike S R] [inst_1 : Monoid R]\n  [inst_2 : AddMonoid Œπ] (A : (a : Œπ) ‚Üí S) [inst_3 : SetLike.GradedMonoid A] (fŒπ : (a : Œ±) ‚Üí Œπ)\n  (fA : (a : Œ±) ‚Üí { x : R // x ‚àà A (fŒπ a) }) (l : List Œ±),\n  ‚Üë(List.dProd l fŒπ fA) = List.prod (List.map (fun (a : Œ±) ‚Ü¶ ‚Üë(fA a)) l)","name":"SetLike.coe_list_dProd","isProp":true,"docString":"Coercing a dependent product of subtypes is the same as taking the regular product of the\ncoercions. "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Type u_2} [inst : CompleteLattice Œ±] (s : (a : Œπ) ‚Üí Œ±),\n  (inf·µ¢ fun (i : Œπ) ‚Ü¶ s i) = inf·µ¢ fun (t : Finset Œπ) ‚Ü¶ inf·µ¢ fun (i : Œπ) ‚Ü¶ inf·µ¢ fun (h : i ‚àà t) ‚Ü¶ s i","name":"inf·µ¢_eq_inf·µ¢_finset","isProp":true,"docString":"Infimum of `s i`, `i : Œπ`, is equal to the infimum over `t : Finset Œπ` of infima\n`‚®Ö i ‚àà t, s i`. This version assumes `Œπ` is a `Type _`. See `inf·µ¢_eq_inf·µ¢_finset'` for a version\nthat works for `Œπ : Sort*`. "},{"type":"‚àÄ {n : ‚Ñï} {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Fin (n + 1)) ‚Üí Œ±},\n  (StrictAnti f : Prop) ‚Üî (‚àÄ (i : Fin n), f (Fin.succ i) < f (‚ÜëFin.castSucc i) : Prop)","name":"Fin.strictAnti_iff_succ_lt","isProp":true,"docString":"A function `f` on `Fin (n + 1)` is strictly antitone if and only if `f (i + 1) < f i`\nfor all `i`. "},{"type":"‚àÄ {M : Type u_3} {N : Type u_4} {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : VAdd M Œ±] [inst_1 : VAdd Œ≤ Œ±]\n  [inst_2 : VAddCommClass M Œ≤ Œ±] (g : (a : N) ‚Üí M), VAddCommClass N Œ≤ Œ±","name":"VAdd.comp.vaddCommClass","isProp":true,"docString":"This cannot be an instance because it can cause infinite loops whenever the `VAdd` arguments\nare still metavariables."},{"type":"‚àÄ {Œ± : Type u_1} [self : CanonicallyLinearOrderedSemifield Œ±] (n : ‚Ñï) (a : Œ±),\n  CanonicallyLinearOrderedSemifield.zpow (Int.negSucc n) a =\n    (CanonicallyLinearOrderedSemifield.zpow (‚Üë(Nat.succ n)) a)‚Åª¬π","name":"CanonicallyLinearOrderedSemifield.zpow_neg'","isProp":true,"docString":"`a ^ -(n + 1) = (a ^ (n + 1))‚Åª¬π` "},{"type":"‚àÄ (k : Type u_3) {V : Type u_4} {P : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] (p : (a : Œπ) ‚Üí P) {i : Œπ} (hi : i ‚àà s),\n  ‚Üë(Finset.affineCombination k s p) (Finset.affineCombinationSingleWeights k i) = p i","name":"Finset.affineCombination_affineCombinationSingleWeights","isProp":true,"docString":"An affine combination with `affineCombinationSingleWeights` gives the specified point. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : CommRing R] [inst_1 : AddCommMonoid M]\n  [h : Algebra.FiniteType R (AddMonoidAlgebra R M)],\n  ‚àÉ (G : Finset M), Algebra.adjoin R (AddMonoidAlgebra.of' R M '' ‚ÜëG) = ‚ä§","name":"AddMonoidAlgebra.exists_finset_adjoin_eq_top","isProp":true,"docString":"If `AddMonoidAlgebra R M` is of finite type, there there is a `G : Finset M` such that its\nimage generates, as algera, `AddMonoidAlgebra R M`. "},{"type":"‚àÄ {Œ± : Type u_1} {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} {y : Œ±} {n : ‚Ñï} (hx : Function.IsPeriodicPt f n x)\n  (hy : Function.IsPeriodicPt f n y) (hn : 0 < n) (h : f x = f y), x = y","name":"Function.IsPeriodicPt.eq_of_apply_eq_same","isProp":true,"docString":"If `f` sends two periodic points `x` and `y` of the same positive period to the same point,\nthen `x = y`. For a similar statement about points of different periods see `eq_of_apply_eq`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] (s : Set P), (Set.Nonempty (spanPoints k s) : Prop) ‚Üî (Set.Nonempty s : Prop)","name":"spanPoints_nonempty","isProp":true,"docString":"The `spanPoints` of a set is nonempty if and only if that set is. "},{"type":"‚àÄ {Œ± : Type u} {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hf : Function.IsFixedPt f x) (hg : Function.IsFixedPt g x),\n  Function.IsFixedPt (f ‚àò g) x","name":"Function.IsFixedPt.comp","isProp":true,"docString":"If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ‚àò g`. "},{"type":"‚àÄ {G : Type u_1} [inst : Group G] (H : Subgroup G), (H = ‚ä• : Prop) ‚à® (Nontrivial { x : G // x ‚àà H } : Prop)","name":"Subgroup.bot_or_nontrivial","isProp":true,"docString":"A subgroup is either the trivial subgroup or nontrivial. "},{"type":"‚àÄ {X : Type u} {Œ± : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Œ±] [inst_2 : TopologicalSpace Œ±]\n  [inst_3 : OrderClosedTopology Œ±] {s : Set X} (hs : IsPreconnected s) {a : X} {b : X} (ha : a ‚àà s) (hb : b ‚àà s)\n  {f : (a : X) ‚Üí Œ±} {g : (a : X) ‚Üí Œ±} (hf : ContinuousOn f s) (hg : ContinuousOn g s) (ha' : f a ‚â§ g a)\n  (hb' : g b ‚â§ f b), ‚àÉ (x : X), (x ‚àà s : Prop) ‚àß (f x = g x : Prop)","name":"IsPreconnected.intermediate_value‚ÇÇ","isProp":true,"docString":"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b ‚àà s` we have `f a ‚â§ g a` and `g b ‚â§ f b`,\nthen for some `x ‚àà s` we have `f x = g x`. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_3 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±}\n  {b : Œ±} (a_1 : a‚Åª¬π < b), b‚Åª¬π < a","name":"inv_lt_of_inv_lt'","isProp":true,"docString":"**Alias** of the forward direction of `inv_lt'`."},{"type":"‚àÄ {C : Type u} [ùíû : CategoryTheory.Category C] [self : CategoryTheory.MonoidalCategory C] {X : C} {Y : C} (f : X ‚ü∂ Y),\n  (ùüô CategoryTheory.MonoidalCategory.tensorUnit' ‚äó f) ‚â´ CategoryTheory.Iso.hom (Œª_ Y) =\n    CategoryTheory.Iso.hom (Œª_ X) ‚â´ f","name":"CategoryTheory.MonoidalCategory.leftUnitor_naturality","isProp":true,"docString":"Naturality of the left unitor, commutativity of `ùüô_C ‚äó X ‚ü∂ ùüô_C ‚äó Y ‚ü∂ Y` and `ùüô_C ‚äó X ‚ü∂ X ‚ü∂ Y`\n"},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : (a : Œ±) ‚Üí Œ≤}\n  (hf : Continuous f), Filter.comap f (Filter.cocompact Œ≤) ‚â§ Filter.cocompact Œ±","name":"Filter.comap_cocompact_le","isProp":true,"docString":"The comap of the cocompact filter on `Œ≤` by a continuous function `f : Œ± ‚Üí Œ≤` is less than or\nequal to the cocompact filter on `Œ±`.\nThis is a reformulation of the fact that images of compact sets are compact. "},{"type":"‚àÄ {Œ± : Type u_1} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} [inst : IsStrictOrder Œ± r] {x : Œ±},\n  (Acc r x : Prop) ‚Üî (IsEmpty { f : (fun (x : ‚Ñï) (x_1 : ‚Ñï) ‚Ü¶ x > x_1) ‚Ü™r r // x ‚àà Set.range ‚Üëf } : Prop)","name":"RelEmbedding.acc_iff_no_decreasing_seq","isProp":true,"docString":"A value is accessible iff it isn't contained in any infinite decreasing sequence. "},{"type":"‚àÄ {Œ± : Type u_1} {F : Type u_3} {E' : Type u_2} [inst : Norm F] [inst_1 : SeminormedAddCommGroup E'] {c : ‚Ñù}\n  {g : (a : Œ±) ‚Üí F} {f' : (a : Œ±) ‚Üí E'} {l : Filter Œ±} (a : Asymptotics.IsBigOWith c l f' g),\n  Asymptotics.IsBigOWith c l (fun (x : Œ±) ‚Ü¶ -f' x) g","name":"Asymptotics.IsBigOWith.neg_left","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isBigOWith_neg_left`."},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : OrderTopology Œ±]\n  [inst : TopologicalSpace.SecondCountableTopology Œ±], Set.Countable (setOf fun (x : Œ±) ‚Ü¶ ‚àÉ (y : Œ±), y ‚ãñ x)","name":"countable_setOf_covby_left","isProp":true,"docString":"The set of points which are isolated on the left is countable when the space is\nsecond-countable. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {n : ‚Ñ§} (hn : Odd n) (a_1 : a < 0), a ^ n < 0","name":"Odd.zpow_neg","isProp":true,"docString":"**Alias** of the reverse direction of `Odd.zpow_neg_iff`."},{"type":"‚àÄ {R : Type u_1} {L : Type u_2} {L' : Type u_3} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : LieRing L'] [inst_4 : LieAlgebra R L'] (self : L ‚Üí‚Çó‚ÅÖR‚ÅÜ L') {x : L} {y : L},\n  AddHom.toFun (LinearMap.toAddHom ‚Üëself) ‚ÅÖx, y‚ÅÜ =\n    ‚ÅÖAddHom.toFun (LinearMap.toAddHom ‚Üëself) x, AddHom.toFun (LinearMap.toAddHom ‚Üëself) y‚ÅÜ","name":"LieHom.map_lie'","isProp":true,"docString":"A morphism of Lie algebras is compatible with brackets. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : DecidableEq Œ±] [inst_1 : Fintype Œ±] [inst_2 : CommSemiring Œ≤]\n  {Œ¥ : (a : Œ±) ‚Üí Type u_1} [inst_3 : (a : Œ±) ‚Üí DecidableEq (Œ¥ a)] {t : (a : Œ±) ‚Üí Finset (Œ¥ a)}\n  {f : (a : Œ±) ‚Üí (a : Œ¥ a) ‚Üí Œ≤},\n  (Finset.prod Finset.univ fun (a : Œ±) ‚Ü¶ Finset.sum (t a) fun (b : Œ¥ a) ‚Ü¶ f a b) =\n    Finset.sum (Fintype.piFinset t) fun (p : (a : Œ±) ‚Üí Œ¥ a) ‚Ü¶ Finset.prod Finset.univ fun (x : Œ±) ‚Ü¶ f x (p x)","name":"Finset.prod_univ_sum","isProp":true,"docString":"The product over `univ` of a sum can be written as a sum over the product of sets,\n`Fintype.piFinset`. `Finset.prod_sum` is an alternative statement when the product is not\nover `univ` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CircularPreorder Œ±] {a : Œ±} {b : Œ±} {c : Œ±}, (btw a b c : Prop) ‚Üî (btw c a b : Prop)","name":"btw_cyclic","isProp":true,"docString":"The order of the `‚Üî` has been chosen so that `rw btw_cyclic` cycles to the right while\n`rw ‚Üêbtw_cyclic` cycles to the left (thus following the prepended arrow). "},{"type":"‚àÄ {Œ± : Type u} [inst : PseudoMetricSpace Œ±] {s : Set Œ±} {x : Œ±} (h : IsClosed s) (hs : Set.Nonempty s),\n  (x ‚àà s : Prop) ‚Üî (Metric.infDist x s = 0 : Prop)","name":"IsClosed.mem_iff_infDist_zero","isProp":true,"docString":"Given a closed set `s`, a point belongs to `s` iff its infimum distance to this set vanishes "},{"type":"‚àÄ {Œ± : Type u_1} {Œπ : Sort u_2} {p : (a : Œπ) ‚Üí Prop} {s : (a : Œπ) ‚Üí Set Œ±} (self : Filter.IsBasis p s), ‚àÉ (i : Œπ), p i","name":"Filter.IsBasis.nonempty","isProp":true,"docString":"There exists at least one `i` that satisfies `p`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrderedSemifield Œ±] {a : Œ±} {b : Œ±} (ha : 0 < a) (hb : 0 < b),\n  (a‚Åª¬π ‚â§ b‚Åª¬π : Prop) ‚Üî (b ‚â§ a : Prop)","name":"inv_le_inv","isProp":true,"docString":"See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} (f : (a : Œ±) ‚Üí Œ≤), Vector.map f Vector.nil = Vector.nil","name":"Vector.map_nil","isProp":true,"docString":"A `nil` vector maps to a `nil` vector. "},{"type":"‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : LT Œ±]\n  [inst_2 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1] {a : Œ±} {b : Œ±}\n  {c : Œ±} (a_1 : b‚Åª¬π * a < c), a < b * c","name":"lt_mul_of_inv_mul_lt_left","isProp":true,"docString":"**Alias** of `lt_mul_of_inv_mul_lt`."},{"type":"‚àÄ (Œπ : Type u_1), WellFounded LT.lt","name":"Finsupp.lt_wf","isProp":true,"docString":"The order on `Œπ ‚Üí‚ÇÄ ‚Ñï` is well-founded. "},{"type":"‚àÄ (n : ‚Ñï), ‚Üë(Nat.totient n) = ‚Üën * Finset.prod (List.toFinset (Nat.factors n)) fun (p : ‚Ñï) ‚Ü¶ 1 - (‚Üëp)‚Åª¬π","name":"Nat.totient_eq_mul_prod_factors","isProp":true,"docString":"Euler's product formula for the totient function. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] {F : Type u_3}\n  [mc : AddMonoidHomClass F M N] (f : F) (s : Set M),\n  AddSubmonoid.map f (AddSubmonoid.closure s) = AddSubmonoid.closure (‚Üëf '' s)","name":"AddMonoidHom.map_mclosure","isProp":true,"docString":"The image under an `AddMonoid` hom of the `AddSubmonoid` generated by a set equals\nthe `AddSubmonoid` generated by the image of the set."},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C","name":"CategoryTheory.Limits.hasZeroObject_of_hasTerminal_object","isProp":true,"docString":"If there are zero morphisms, any terminal object is a zero object. "},{"type":"‚àÄ {Œ± : Type u_1} [self : LinearOrderedAddCommMonoid Œ±] (a : Œ±) (b : Œ±) (a_1 : a ‚â§ b) (c : Œ±), c + a ‚â§ c + b","name":"LinearOrderedAddCommMonoid.add_le_add_left","isProp":true,"docString":"Addition is monotone in an `OrderedAddCommMonoid`. "},{"type":"‚àÄ {Œ± : Type u_1} [self : CompleteLattice Œ±] (s : Set Œ±) (a : Œ±) (a_1 : a ‚àà s), inf‚Çõ s ‚â§ a","name":"CompleteLattice.inf‚Çõ_le","isProp":true,"docString":"Any element of a set is more than the set infimum. "},{"type":"‚àÄ {G‚ÇÄ : Type u_1} [inst : GroupWithZero G‚ÇÄ] (a : G‚ÇÄ), a * a / a = a","name":"mul_self_div_self","isProp":true,"docString":"Multiplying `a` by itself and then dividing by itself results in `a`, whether or not `a` is\nzero. "},{"type":"‚àÄ {L : Type u_1} [inst : LinearOrderedField L] {W : Type v} [inst_1 : AddCommGroup W] [inst_2 : Module L W]\n  [inst_3 : FiniteDimensional L W] {t : Finset W} (h : FiniteDimensional.finrank L W + 1 < Finset.card t),\n  ‚àÉ (f : (a : W) ‚Üí L),\n    ((Finset.sum t fun (e : W) ‚Ü¶ f e ‚Ä¢ e) = 0 : Prop) ‚àß\n      (((Finset.sum t fun (e : W) ‚Ü¶ f e) = 0 : Prop) ‚àß (‚àÉ (x : W), (x ‚àà t : Prop) ‚àß (0 < f x : Prop) : Prop) : Prop)","name":"FiniteDimensional.exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card","isProp":true,"docString":"A slight strengthening of `exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card`\navailable when working over an ordered field:\nwe can ensure a positive coefficient, not just a nonzero coefficient.\n"},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_4} {F : Type u_1} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : AddCommMonoid F] [inst_3 : OrderedAddCommMonoid Œ≤] [inst_4 : Module ùïú E] [inst_5 : Module ùïú F]\n  [inst_6 : SMul ùïú Œ≤] {f : (a : F) ‚Üí Œ≤} {s : Set F} (hf : ConvexOn ùïú s f) (g : E ‚Üí‚Çó[ùïú] F),\n  ConvexOn ùïú (‚Üëg ‚Åª¬π' s) (f ‚àò ‚Üëg)","name":"ConvexOn.comp_linearMap","isProp":true,"docString":"If `g` is convex on `s`, so is `(f ‚àò g)` on `f ‚Åª¬π' s` for a linear `f`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {r : Œ±} {s : Finset Œ±},\n  (Finset.toColex {r} ‚â§ Finset.toColex s : Prop) ‚Üî (‚àÉ (x : Œ±), (x ‚àà s : Prop) ‚àß (r ‚â§ x : Prop) : Prop)","name":"Colex.mem_le_of_singleton_le","isProp":true,"docString":"If `{r}` is less than or equal to s in the colexicographical sense,\nthen s contains an element greater than or equal to r. "},{"type":"‚àÄ {R : Type u_1} [inst : NonAssocSemiring R] (f : ‚Ñï ‚Üí+* R), f = Nat.castRingHom R","name":"RingHom.eq_natCast'","isProp":true,"docString":"This is primed to match `eq_intCast'`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f : M ‚âÉ* N} {g : M ‚âÉ* N} (h : ‚àÄ (x : M), ‚Üëf x = ‚Üëg x),\n  f = g","name":"MulEquiv.ext","isProp":true,"docString":"Two multiplicative isomorphisms agree if they are defined by the\nsame underlying function. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Mul Œ±] [inst_1 : Preorder Œ±] [inst_2 : Preorder Œ≤] {s : Set Œ≤}\n  [inst_3 : CovariantClass Œ± Œ± (fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x < x_1]\n  [inst_4 : CovariantClass Œ± Œ± (Function.swap fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x * x_1) fun (x : Œ±) (x_1 : Œ±) ‚Ü¶ x ‚â§ x_1]\n  {f : (a : Œ≤) ‚Üí Œ±} {g : (a : Œ≤) ‚Üí Œ±} (hf : AntitoneOn f s) (hg : StrictAntiOn g s),\n  StrictAntiOn (fun (x : Œ≤) ‚Ü¶ f x * g x) s","name":"AntitoneOn.mul_strictAnti'","isProp":true,"docString":"The product of a antitone function and a strictly antitone function is strictly antitone. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CompleteLattice Œ±] {k : Œ±} (h : CompleteLattice.IsCompactElement k), IsCoatomic ‚Üë(Set.Iic k)","name":"CompleteLattice.Iic_coatomic_of_compact_element","isProp":true,"docString":"A compact element `k` has the property that any `b < k` lies below a \"maximal element below\n`k`\", which is to say `[‚ä•, k]` is coatomic. "},{"type":"‚àÄ {ùïÜ : Type u_1} {Œ± : Type u_2} [inst : Preorder ùïÜ] [inst_1 : Preorder Œ±] [self : GradeMinOrder ùïÜ Œ±] ‚¶Éa : Œ±‚¶Ñ\n  (a_1 : IsMin a), IsMin (GradeOrder.grade a)","name":"GradeMinOrder.is_min_grade","isProp":true,"docString":"Minimal elements have minimal grades. "},{"type":"‚àÄ (f : CircleDeg1Lift) {x : ‚Ñù} {m : ‚Ñ§} (h : ‚Üëf x = x + ‚Üëm), CircleDeg1Lift.translationNumber f = ‚Üëm","name":"CircleDeg1Lift.translationNumber_of_eq_add_int","isProp":true,"docString":"If `f x - x` is an integer number `m` for some point `x`, then `œÑ f = m`.\nOn the circle this means that a map with a fixed point has rotation number zero. "},{"type":"‚àÄ {Œ≥ : Type u_1} [inst : NonUnitalNonAssocSemiring Œ≥] (x : Œ≥), IsAddMonoidHom fun (y : Œ≥) ‚Ü¶ x * y","name":"IsAddMonoidHom.isAddMonoidHom_mul_left","isProp":true,"docString":"Left multiplication in a ring is an additive monoid morphism. "},{"type":"‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_2} {r : (a : Œ±) ‚Üí (a : Œ±) ‚Üí Prop} (hwf : WellFounded r) {a : Œ±} {bot : Œ±}\n  {C : (a : Œ≤) ‚Üí Prop} {f : (a : Œ±) ‚Üí Œ≤}\n  (ih : ‚àÄ (b : Œ±) (a : f b ‚â† f bot) (a : C (f b)), ‚àÉ (c : Œ±), (r c b : Prop) ‚àß (C (f c) : Prop)) (a : C (f a)),\n  C (f bot)","name":"WellFounded.induction_bot'","isProp":true,"docString":"Let `r` be a well-founded relation on `Œ±`, let `f : Œ± ‚Üí Œ≤` be a function,\nlet `C : Œ≤ ‚Üí Prop`, and  let `bot : Œ±`.\nThis induction principle shows that `C (f bot)` holds, given that\n* some `a` satisfies `C (f a)`, and\n* for each `b` such that `f b ‚â† f bot` and `C (f b)` holds, there is `c`\n  satisfying `r c b` and `C (f c)`. "},{"type":"‚àÄ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {x : V} {n : ‚Ñï}\n  {v : (a : Fin n) ‚Üí V} (hv : LinearIndependent K v) (hx : ¬¨(x ‚àà Submodule.span K (Set.range v) : Prop)),\n  LinearIndependent K (Fin.cons x v)","name":"LinearIndependent.fin_cons","isProp":true,"docString":"See `LinearIndependent.fin_cons'` for an uglier version that works if you\nonly have a module over a semiring. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LT Œ±] {a : Œ±} {b : Œ±} (h : a < b) (a_1 : ¬¨(a ‚ãñ b : Prop)),\n  ‚àÉ (c : Œ±), (a < c : Prop) ‚àß (c < b : Prop)","name":"exists_lt_lt_of_not_covby","isProp":true,"docString":"**Alias** of the forward direction of `not_covby_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : PseudoMetricSpace Œ±] [inst_1 : ProperSpace Œ±] (x : Œ±) (r : ‚Ñù),\n  CompactSpace ‚Üë(Metric.sphere x r)","name":"instCompactSpaceElemSphereInstTopologicalSpaceSubtypeMemSetInstMembershipSetToTopologicalSpaceToUniformSpace","isProp":true,"docString":"In a proper pseudometric space, any sphere is a `CompactSpace` when considered as a subtype. "},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {Œ¥ : Type u_1} [inst_4 : LinearOrder Œ¥] [inst_5 : TopologicalSpace Œ¥]\n  [inst_6 : OrderClosedTopology Œ¥] {s : Set Œ±} [hs : Set.OrdConnected s] {f : (a : Œ±) ‚Üí Œ¥} (hf : ContinuousOn f s)\n  {a : Œ±} {b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s), Set.SurjOn f s (Set.uIcc (f a) (f b))","name":"ContinuousOn.surjOn_uIcc","isProp":true,"docString":"**Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. "},{"type":"‚àÄ (K : Type u) [inst : Ring K] [inst_1 : StrongRankCondition K], FiniteDimensional.finrank K K = 1","name":"FiniteDimensional.finrank_self","isProp":true,"docString":"A ring satisfying `StrongRankCondition` (such as a `DivisionRing`) is one-dimensional as a\nmodule over itself. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : OrderedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  {K : Geometry.SimplicialComplex ùïú E} {s : Finset E} {t : Finset E} (hs : s ‚àà Geometry.SimplicialComplex.faces K)\n  (ht : t ‚àà Geometry.SimplicialComplex.faces K),\n  (‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üës ‚äÜ ‚Üë(ClosureOperator.toOrderHom (convexHull ùïú)) ‚Üët : Prop) ‚Üî\n    (s ‚äÜ t : Prop)","name":"Geometry.SimplicialComplex.face_subset_face_iff","isProp":true,"docString":"A face is a subset of another one iff its vertices are. "},{"type":"‚àÄ {k : Type u_3} {V : Type u_2} {P : Type u_4} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_1} (s : Finset Œπ) [inst_3 : DecidableEq Œπ] {s‚ÇÇ : Finset Œπ} (h : s‚ÇÇ ‚äÜ s)\n  (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.weightedVSub (s \\ s‚ÇÇ) p) w - ‚Üë(Finset.weightedVSub s‚ÇÇ p) (-w) = ‚Üë(Finset.weightedVSub s p) w","name":"Finset.weightedVSub_sdiff_sub","isProp":true,"docString":"A weighted sum may be split into a subtraction of such sums over two subsets. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (a_1 : ‚ä• ‚ãñ a), IsAtom a","name":"Covby.is_atom","isProp":true,"docString":"**Alias** of the forward direction of `bot_covby_iff`."},{"type":"‚àÄ {Œ± : Type v} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderClosedTopology Œ±] {s : Set Œ±}\n  (hs : IsPreconnected s) (hb : ¬¨(BddBelow s : Prop)) (ha : ¬¨(BddAbove s : Prop)), s = Set.univ","name":"IsPreconnected.eq_univ_of_unbounded","isProp":true,"docString":"If preconnected set in a linear order space is unbounded below and above, then it is the whole\nspace. "},{"type":"‚àÄ {Œπ : Type u} {Œ± : Type v} [inst : DecidableEq Œ±] {t : (a : Œπ) ‚Üí Finset Œ±} [inst_1 : Fintype Œπ] {n : ‚Ñï}\n  (hn : Fintype.card Œπ = n + 1) (ht : ‚àÄ (s : Finset Œπ), Finset.card s ‚â§ Finset.card (Finset.bunion·µ¢ s t))\n  (ih :\n    ‚àÄ {Œπ' : Type u} [inst_2 : Fintype Œπ'] (t' : (a : Œπ') ‚Üí Finset Œ±) (a : Fintype.card Œπ' ‚â§ n)\n      (a : ‚àÄ (s' : Finset Œπ'), Finset.card s' ‚â§ Finset.card (Finset.bunion·µ¢ s' t')),\n      ‚àÉ (f : (a : Œπ') ‚Üí Œ±), (Function.Injective f : Prop) ‚àß (‚àÄ (x : Œπ'), f x ‚àà t' x : Prop))\n  (s : Finset Œπ) (hs : Finset.Nonempty s) (hns : s ‚â† Finset.univ)\n  (hus : Finset.card s = Finset.card (Finset.bunion·µ¢ s t)),\n  ‚àÉ (f : (a : Œπ) ‚Üí Œ±), (Function.Injective f : Prop) ‚àß (‚àÄ (x : Œπ), f x ‚àà t x : Prop)","name":"HallMarriageTheorem.hall_hard_inductive_step_B","isProp":true,"docString":"Second case of the inductive step: assuming that\n`‚àÉ (s : Finset Œπ), s ‚â† univ ‚Üí s.card = (s.bunion·µ¢ t).card`\nand that the statement of **Hall's Marriage Theorem** is true for all\n`Œπ'` of cardinality ‚â§ `n`, then it is true for `Œπ` of cardinality `n + 1`.\n"},{"type":"‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {a : Œ±} [inst : DecidableEq Œ±],\n  Finset.card (insert a s) = if (a ‚àà s : Prop) then Finset.card s else Finset.card s + 1","name":"Finset.card_insert_eq_ite","isProp":true,"docString":"If `a ‚àà s` is known, see also `Finset.card_insert_of_mem` and `Finset.card_insert_of_not_mem`.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : ConditionallyCompleteLinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : DenselyOrdered Œ±] {a : Œ±} {b : Œ±}, IsPreconnected (Set.Icc a b)","name":"isPreconnected_Icc","isProp":true,"docString":"A closed interval in a densely ordered conditionally complete linear order is preconnected. "},{"type":"‚àÄ (Œ± : Type u_1), FaithfulSMul (Equiv.Perm Œ±) Œ±","name":"Equiv.Perm.applyFaithfulSMul","isProp":true,"docString":"`Equiv.Perm.applyMulAction` is faithful. "},{"type":"‚àÄ {M : Type u_1} [inst : MulOneClass M] (s : Set M) {p : (x : M) ‚Üí (a : x ‚àà Submonoid.closure s) ‚Üí Prop}\n  (Hs :\n    ‚àÄ (x : M) (h : x ‚àà s), p x ((Submonoid.subset_closure h=:x ‚àà ‚Üë(Submonoid.closure s))=:x ‚àà ‚Üë(Submonoid.closure s)))\n  (H1 : p 1 ((one_mem (Submonoid.closure s)=:1 ‚àà Submonoid.closure s)=:1 ‚àà Submonoid.closure s))\n  (Hmul :\n    ‚àÄ (x : M) (hx : x ‚àà Submonoid.closure s) (y : M) (hy : y ‚àà Submonoid.closure s) (a : p x hx) (a : p y hy),\n      p (x * y) ((mul_mem hx hy=:x * y ‚àà Submonoid.closure s)=:x * y ‚àà Submonoid.closure s))\n  {x : M} (hx : x ‚àà Submonoid.closure s), p x hx","name":"Submonoid.closure_induction'","isProp":true,"docString":"A dependent version of `Submonoid.closure_induction`.  "},{"type":"‚àÄ {V : Type u} {G : SimpleGraph V} (self : SimpleGraph.Partition G) (s : Set V)\n  (a : s ‚àà SimpleGraph.Partition.parts self), IsAntichain (SimpleGraph.Adj G) s","name":"SimpleGraph.Partition.independent","isProp":true,"docString":"`independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices.\n"},{"type":"‚àÄ {R : Type u} [inst : Semiring R] [self : StrongRankCondition R] {n : ‚Ñï} {m : ‚Ñï}\n  (f : ((a : Fin n) ‚Üí R) ‚Üí‚Çó[R] (a : Fin m) ‚Üí R) (a : Function.Injective ‚Üëf), n ‚â§ m","name":"StrongRankCondition.le_of_fin_injective","isProp":true,"docString":"Any injective linear map from `R‚Åø` to `R·µê` guarantees `n ‚â§ m`. "},{"type":"‚àÄ {Œ± : Type u} [self : LinearOrder Œ±] (a : Œ±) (b : Œ±), max a b = if (a ‚â§ b : Prop) then b else a","name":"LinearOrder.max_def","isProp":true,"docString":"The minimum function is equivalent to the one you get from `maxOfLe`. "},{"type":"‚àÄ {R : Type u_1} [inst : Semiring R] {x : R} {y : R} (h : Commute x y) (n : ‚Ñï),\n  (x + y) ^ n =\n    Finset.sum (Finset.Nat.antidiagonal n) fun (m : ‚Ñï √ó ‚Ñï) ‚Ü¶\n      Nat.choose n (Prod.fst m) ‚Ä¢ (x ^ Prod.fst m * y ^ Prod.snd m)","name":"Commute.add_pow'","isProp":true,"docString":"A version of `Commute.add_pow` that avoids ‚Ñï-subtraction by summing over the antidiagonal and\nalso with the binomial coefficient applied via scalar action of ‚Ñï. "},{"type":"‚àÄ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Neg G] [inst_2 : Add G] [inst_3 : ContinuousAdd G]\n  [inst_4 : ContinuousNeg G] (h : G), Continuous fun (g : G) ‚Ü¶ g + h + -g","name":"TopologicalAddGroup.continuous_conj'","isProp":true,"docString":"Conjugation acting on fixed element of the additive group is continuous when both\n`add` and `neg` are continuous."},{"type":"‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : (a : Œ±) ‚Üí M} {s : Set Œ±} {t : Set Œ±} (hst : Disjoint s t)\n  (hs : Set.Finite (s ‚à© Function.support f)) (ht : Set.Finite (t ‚à© Function.support f)),\n  (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s ‚à™ t) ‚Ü¶ f i) =\n    (finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà s) ‚Ü¶ f i) + finsum fun (i : Œ±) ‚Ü¶ finsum fun (h : i ‚àà t) ‚Ü¶ f i","name":"finsum_mem_union'","isProp":true,"docString":"A more general version of `finsum_mem_union` that requires `s ‚à© support f` and\n`t ‚à© support f` rather than `s` and `t` to be finite."},{"type":"‚àÄ {Œ± : Type u_1} {p : (a : Finset Œ±) ‚Üí Prop} [inst : DecidableEq Œ±] (s : Finset Œ±) (empty : p ‚àÖ)\n  (insert : ‚àÄ ‚¶Éa : Œ±‚¶Ñ {s : Finset Œ±} (a_1 : ¬¨(a ‚àà s : Prop)) (a_2 : p s), p (insert a s)), p s","name":"Finset.induction_on","isProp":true,"docString":"To prove a proposition about an arbitrary `Finset Œ±`,\nit suffices to prove it for the empty `Finset`,\nand to show that if it holds for some `Finset Œ±`,\nthen it holds for the `Finset` obtained by inserting a new element.\n"},{"type":"‚àÄ {ùïú : Type u_1} {E : Type u_2} {Œ≤ : Type u_3} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid Œ≤] [inst_3 : Module ùïú E] [inst_4 : SMul ùïú Œ≤] {s : Set E} {f : (a : E) ‚Üí Œ≤}\n  (hf : ConcaveOn ùïú s f) (c : E), ConcaveOn ùïú ((fun (z : E) ‚Ü¶ c + z) ‚Åª¬π' s) (f ‚àò fun (z : E) ‚Ü¶ z + c)","name":"ConcaveOn.translate_left","isProp":true,"docString":"Left translation preserves concavity. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category D] {F : C ‚•§ D}\n  {X : C} {S : CategoryTheory.Presieve X} {Y : D} {f : Y ‚ü∂ Prefunctor.obj (CategoryTheory.Functor.toPrefunctor F) X}\n  (self : CategoryTheory.Presieve.FunctorPushforwardStructure F S f),\n  S (CategoryTheory.Presieve.FunctorPushforwardStructure.premap self)","name":"CategoryTheory.Presieve.FunctorPushforwardStructure.cover","isProp":true,"docString":"the condition that `premap` is in the presieve "},{"type":"‚àÄ {Œ± : Type u_3} {Œ±' : Type u_5} {Œ≤ : Type u_4} {Œ≥ : Type u_2} {Œ¥ : Type u_1} {f : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ≥} {s : Set Œ±}\n  {t : Set Œ≤} {g : (a : Œ≥) ‚Üí Œ¥} {f' : (a : Œ±') ‚Üí (a : Œ≤) ‚Üí Œ¥} {g' : (a : Œ±) ‚Üí Œ±'}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤), g (f a b) = f' (g' a) b), g '' Set.image2 f s t = Set.image2 f' (g' '' s) t","name":"Set.image_image2_distrib_left","isProp":true,"docString":"Symmetric statement to `Set.image2_image_left_comm`. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {Œ≥ : Type w} [inst : AddCommMonoid Œ≤] {s : Finset Œ≥} {t : Finset Œ±}\n  {f : (a : Œ≥) ‚Üí (a : Œ±) ‚Üí Œ≤},\n  (Finset.sum (s √ó·∂† t) fun (x : Œ≥ √ó Œ±) ‚Ü¶ f (Prod.fst x) (Prod.snd x)) =\n    Finset.sum t fun (y : Œ±) ‚Ü¶ Finset.sum s fun (x : Œ≥) ‚Ü¶ f x y","name":"Finset.sum_product_right'","isProp":true,"docString":"An uncurried version of `Finset.prod_product_right`"},{"type":"‚àÄ {k : Type u_2} {V : Type u_4} {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {Œπ : Type u_3} (s : Finset Œπ) (w : (a : Œπ) ‚Üí k) (p : (a : Œπ) ‚Üí P),\n  ‚Üë(Finset.affineCombination k s p) w =\n    ‚Üë(Finset.weightedVSubOfPoint s p (Classical.choice ((AddTorsor.Nonempty=:Nonempty P)=:Nonempty P))) w +·µ•\n      Classical.choice ((AddTorsor.Nonempty=:Nonempty P)=:Nonempty P)","name":"Finset.affineCombination_apply","isProp":true,"docString":"Applying `affineCombination` with given weights.  This is for the\ncase where a result involving a default base point is OK (for example,\nwhen that base point will cancel out later); a more typical use case\nfor `affineCombination` would involve selecting a preferred base\npoint with\n`affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one` and\nthen using `weightedVSubOfPoint_apply`. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} {p : (a : Œπ) ‚Üí P} (h : AffineIndependent k p) {w : (a : Œπ) ‚Üí k}\n  {w‚ÇÅ : (a : Œπ) ‚Üí k} {w‚ÇÇ : (a : Œπ) ‚Üí k} {s : Finset Œπ} (x : (Finset.sum s fun (i : Œπ) ‚Ü¶ w i) = 1)\n  (hw‚ÇÅ : (Finset.sum s fun (i : Œπ) ‚Ü¶ w‚ÇÅ i) = 1) (hw‚ÇÇ : (Finset.sum s fun (i : Œπ) ‚Ü¶ w‚ÇÇ i) = 1),\n  (‚Üë(Finset.affineCombination k s p) w ‚àà\n        affineSpan k {‚Üë(Finset.affineCombination k s p) w‚ÇÅ, ‚Üë(Finset.affineCombination k s p) w‚ÇÇ} :\n      Prop) ‚Üî\n    (‚àÉ (r : k), ‚àÄ (i : Œπ) (a : i ‚àà s), w i = r * (w‚ÇÇ i - w‚ÇÅ i) + w‚ÇÅ i : Prop)","name":"affineCombination_mem_affineSpan_pair","isProp":true,"docString":"Given an affinely independent family of points, an affine combination lies in the\nspan of two points given as affine combinations if and only if it is an affine combination\nwith weights those of one point plus a multiple of the difference between the weights of the\ntwo points. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] {C : Set Œ±} [inst_1 : TopologicalSpace.SecondCountableTopology Œ±]\n  (hclosed : IsClosed C),\n  ‚àÉ (V : Set Œ±), ‚àÉ (D : Set Œ±), (Set.Countable V : Prop) ‚àß ((Perfect D : Prop) ‚àß (C = V ‚à™ D : Prop) : Prop)","name":"exists_countable_union_perfect_of_isClosed","isProp":true,"docString":"The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set."},{"type":"‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedRing Œ±] {s : Finset Œπ} {f : (a : Œπ) ‚Üí Œ±} {g : (a : Œπ) ‚Üí Œ±}\n  (hfg : AntivaryOn f g ‚Üës),\n  (‚Üë(Finset.card s) * Finset.sum s fun (i : Œπ) ‚Ü¶ f i * g i) ‚â§\n    (Finset.sum s fun (i : Œπ) ‚Ü¶ f i) * Finset.sum s fun (i : Œπ) ‚Ü¶ g i","name":"AntivaryOn.card_mul_sum_le_sum_mul_sum","isProp":true,"docString":"**Chebyshev's Sum Inequality**: When `f` and `g` antivary together (eg one is monotone, the\nother is antitone), the product of their sum is greater than the size of the set times their scalar\nproduct. "},{"type":"‚àÄ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L],\n  IsScalarTower R (CommutatorRing L) (CommutatorRing L)","name":"LieAlgebra.isScalarTower","isProp":true,"docString":"Regarding the `LieRing` of a `LieAlgebra` as a `NonUnitalNonAssocSemiring`, we can\nreinterpret the `smul_lie` law as an `IsScalarTower`. "},{"type":"‚àÄ {R : Type u_1} {Œì‚ÇÄ : Type u_2} [inst : CommRing R] [inst_1 : LinearOrderedCommMonoidWithZero Œì‚ÇÄ] (v : Valuation R Œì‚ÇÄ)\n  [inst_2 : Nontrivial Œì‚ÇÄ] [inst_3 : NoZeroDivisors Œì‚ÇÄ], Ideal.IsPrime (Valuation.supp v)","name":"Valuation.instIsPrimeToSemiringToRingSupp","isProp":true,"docString":"The support of a valuation is a prime ideal. "},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M]\n  [nM : Nontrivial M], ¬¨(IsSMulRegular M 0 : Prop)","name":"IsSMulRegular.not_zero","isProp":true,"docString":"The `0` element is not `M`-regular, on a non-trivial module. "},{"type":"‚àÄ {A : Type u_1} [inst : AddGroup A] {s : Set A} (self : IsNormalAddSubgroup s) (n : A) (a : n ‚àà s) (g : A),\n  g + n + -g ‚àà s","name":"IsNormalAddSubgroup.normal","isProp":true,"docString":"The proposition that `s` is closed under (additive) conjugation. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {p‚ÇÅ : (a : Œ±) ‚Üí Prop} {a : Type u_1} {p‚ÇÇ : (a : a) ‚Üí Prop} {y : m a}\n  {q : (a : a) ‚Üí Prop} [inst : Applicative m] [inst_1 : LawfulApplicative m] {x : m Œ±} (hx : SatisfiesM p‚ÇÅ x)\n  (hy : SatisfiesM p‚ÇÇ y) (H : ‚àÄ {a_1 : Œ±} {b : a} (a : p‚ÇÅ a_1) (a : p‚ÇÇ b), q b),\n  SatisfiesM q (SeqRight.seqRight x fun (x : Unit) ‚Ü¶ y)","name":"SatisfiesM.seqRight","isProp":true,"docString":"`SatisfiesM` distributes over `*>`, general version. "},{"type":"‚àÄ {U : Type u_1} {V : Type u_2} [inst : Quiver U] [inst_1 : Quiver V] [inst_2 : Quiver.HasReverse U]\n  [inst_3 : Quiver.HasReverse V] {œÜ : U ‚•§q V} [self : Prefunctor.MapReverse œÜ] {u : U} {v : U} (e : u ‚ü∂ v),\n  Prefunctor.map œÜ (Quiver.reverse e) = Quiver.reverse (Prefunctor.map œÜ e)","name":"Prefunctor.MapReverse.map_reverse'","isProp":true,"docString":"The image of a reverse is the reverse of the image. "},{"type":"‚àÄ {Œ≤ : Type u_1} [inst : CommMonoid Œ≤] (f : (a : Fin 0) ‚Üí Œ≤), (Finset.prod Finset.univ fun (i : Fin 0) ‚Ü¶ f i) = 1","name":"Fin.prod_univ_zero","isProp":true,"docString":"A product of a function `f : Fin 0 ‚Üí Œ≤` is `1` because `Fin 0` is empty "},{"type":"‚àÄ {v : Sat.Valuation} {c : Sat.Clause} {a : Prop} (h : Sat.Clause.reify v c (a : Prop)),\n  Sat.Fmla.reify v (Sat.Fmla.one c) (a : Prop)","name":"Sat.Fmla.reify_one","isProp":true,"docString":"Reification of a single clause formula. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} (hf : IsAddGroupHom f) (a : Œ±),\n  f (-a) = -f a","name":"IsAddGroupHom.map_neg","isProp":true,"docString":"An additive group homomorphism sends negations to negations."},{"type":"‚àÄ (L : List ‚Ñï), List.headI L + List.sum (List.tail L) = List.sum L","name":"List.headI_add_tail_sum","isProp":true,"docString":"This relies on `default ‚Ñï = 0`. "},{"type":"‚àÄ {Œ≥ : Type u_1} {P : (a : Œ≥) ‚Üí (a : Set Œ≥) ‚Üí Prop} (h : ‚àÄ (t : Set Œ≥) (a : Set.Finite t), ‚àÉ (c : Œ≥), P c t),\n  ‚àÉ (u : (a : ‚Ñï) ‚Üí Œ≥), ‚àÄ (n : ‚Ñï), P (u n) (u '' Set.Iio n)","name":"Set.seq_of_forall_finite_exists","isProp":true,"docString":"If `P` is some relation between terms of `Œ≥` and sets in `Œ≥`, such that every finite set\n`t : set Œ≥` has some `c : Œ≥` related to it, then there is a recursively defined sequence `u` in `Œ≥`\nso `u n` is related to the image of `{0, 1, ..., n-1}` under `u`.\n\n(We use this later to show sequentially compact sets are totally bounded.)\n"},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} {r : R} (h : SameRay R x y) (hr : 0 ‚â§ r), SameRay R x (r ‚Ä¢ y)","name":"SameRay.nonneg_smul_right","isProp":true,"docString":"A vector is in the same ray as a nonnegative multiple of one it is in the same ray as. "},{"type":"‚àÄ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [inst : Ring k]\n  [inst_1 : AddCommGroup V1] [inst_2 : Module k V1] [inst_3 : AddTorsor V1 P1] [inst_4 : AddCommGroup V2]\n  [inst_5 : Module k V2] [inst_6 : AddTorsor V2 P2] {f : P1 ‚Üí·µÉ[k] P2} {g : P1 ‚Üí·µÉ[k] P2} (h : ‚àÄ (p : P1), ‚Üëf p = ‚Üëg p),\n  f = g","name":"AffineMap.ext","isProp":true,"docString":"Two affine maps are equal if they coerce to the same function. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] {f : (a : ‚Ñï) ‚Üí Œ±} {d : (a : ‚Ñï) ‚Üí Œ±}\n  (hdisj : Pairwise (Disjoint on d)) (hsups : partialSups d = partialSups f), d = disjointed f","name":"disjointed_unique","isProp":true,"docString":"`disjointed f` is the unique sequence that is pairwise disjoint and has the same partial sups\nas `f`. "},{"type":"¬¨(Set.Countable Set.univ : Prop)","name":"not_countable_complex","isProp":true,"docString":"The complex numbers are not countable. "},{"type":"‚àÄ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ‚Ñù E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ‚Ñù E] {s : Set E} (hconv : Convex ‚Ñù s)\n  (hne : Set.Nonempty s), IsPathConnected s","name":"Convex.isPathConnected","isProp":true,"docString":"A nonempty convex set is path connected. "},{"type":"‚àÄ {Œ± : Type u} [inst : LinearOrder Œ±], IsIdempotent Œ± min","name":"min_idem","isProp":true,"docString":"An instance asserting that `min a a = a` "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] {W : C} {X : C} {Y : C} {Z : C} (f : W ‚ü∂ Y) (g : X ‚ü∂ Z)\n  [inst_3 : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)], CategoryTheory.IsIso g","name":"CategoryTheory.isIso_right_of_isIso_biprod_map","isProp":true,"docString":"If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `g` is invertible.\n"},{"type":"‚àÄ {V : Type u_2} (Œ± : Type u_1) (G : SimpleGraph V) [inst : DecidableRel (SimpleGraph.Adj G)] [inst_1 : Zero Œ±]\n  [inst_2 : One Œ±], Matrix.IsAdjMatrix (SimpleGraph.adjMatrix Œ± G)","name":"SimpleGraph.isAdjMatrix_adjMatrix","isProp":true,"docString":"The adjacency matrix of `G` is an adjacency matrix. "},{"type":"‚àÄ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M) {x : M} {y : M} (a : x ‚àà S) (a : y ‚àà S), x + y ‚àà S","name":"AddSubmonoid.add_mem","isProp":true,"docString":"An `AddSubmonoid` is closed under addition."},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] [inst_2 : PolishSpace Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} (hf : ClosedEmbedding f), PolishSpace Œ±","name":"ClosedEmbedding.polishSpace","isProp":true,"docString":"Given a closed embedding into a Polish space, the source space is also Polish. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] (u : AddUnits M) (x : M), AddSemiconjBy (‚Üëu) x (‚Üëu + x + ‚Üë(-u))","name":"AddUnits.mk_addSemiconjBy","isProp":true,"docString":"`a` semiconjugates `x` to `a + x + -a`."},{"type":"‚àÄ (C : Type u) {A : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : AddGroup A]\n  [inst_2 : CategoryTheory.HasShift C A] (i : A), CategoryTheory.EssSurj (CategoryTheory.shiftFunctor C i)","name":"CategoryTheory.shiftFunctor_essSurj","isProp":true,"docString":"Shifting by `n` is an essentially surjective functor. "},{"type":"‚àÄ {n : ‚Ñï}, finSuccEquiv' 0 = finSuccEquiv n","name":"finSuccEquiv'_zero","isProp":true,"docString":"The equiv version of `Fin.predAbove_zero`. "},{"type":"‚àÄ {n : Type u'} {Œ± : Type v} [inst : Fintype n] [inst_1 : DecidableEq n] [inst_2 : CommRing Œ±] (A : Matrix n n Œ±)\n  (b : (a : n) ‚Üí Œ±) (h : IsUnit (Matrix.det A)),\n  Matrix.det A ‚Ä¢ Matrix.vecMul b A‚Åª¬π = ‚Üë(Matrix.cramer (Matrix.transpose A)) b","name":"Matrix.det_smul_inv_vecMul_eq_cramer_transpose","isProp":true,"docString":"One form of **Cramer's rule**. See `Matrix.mulVec_cramer` for a stronger form. "},{"type":"‚àÄ {a : ‚Ñ§} {b : ‚Ñ§} {c : ‚Ñ§} (h1 : a % b = c) (h2 : Int.natAbs (a - c) < Int.natAbs b), a = c","name":"Int.eq_of_mod_eq_of_natAbs_sub_lt_natAbs","isProp":true,"docString":"If two integers are congruent to a sufficiently large modulus,\nthey are equal. "},{"type":"‚àÄ {M : Type u_1} [inst : AddMonoid M] {l : List M} (hl : ‚àÄ (x : M) (a : x ‚àà l), x = 0), List.sum l = 0","name":"List.sum_eq_zero","isProp":true,"docString":"Slightly more general version of `List.sum_eq_zero_iff` for a non-ordered `AddMonoid`"},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] {a : Œ±} {b : Œ±} (hab : a ‚â§ b) (hba : ¬¨(a < b : Prop)), a = b","name":"LE.le.eq_of_not_lt","isProp":true,"docString":"**Alias** of `eq_of_le_of_not_lt`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Œ±) ‚Üí Œ±} {x : Œ±} (hf : StrictMono f) (hx : x < f x),\n  StrictMono fun (n : ‚Ñï) ‚Ü¶ (f^[n]) x","name":"StrictMono.strictMono_iterate_of_lt_map","isProp":true,"docString":"If `f` is a strictly monotone map and `x < f x` at some point `x`, then the iterates `f^[n] x`\nform a strictly monotone sequence. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} {Œπ : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Finite Œπ] (b : Basis Œπ R M), Module.Finite R M","name":"Module.Finite.of_basis","isProp":true,"docString":"A free module with a basis indexed by a `Fintype` is finite. "},{"type":"‚àÄ {Œ± : Type u} [inst : PartialOrder Œ±] [inst_1 : OrderBot Œ±] {a : Œ±} (a_1 : IsBot a), a = ‚ä•","name":"IsBot.eq_bot","isProp":true,"docString":"**Alias** of the forward direction of `isBot_iff_eq_bot`."},{"type":"‚àÄ {Œ± : Type u_1} [inst : Lattice Œ±] [self : IsLowerModularLattice Œ±] {a : Œ±} {b : Œ±} (a_1 : a ‚ãñ a ‚äî b), a ‚äì b ‚ãñ b","name":"IsLowerModularLattice.inf_covby_of_covby_sup","isProp":true,"docString":"`a` and `b` both cover `a ‚äì b` if `a ‚äî b` covers either `a` or `b` "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] [inst_1 : OrderBot Œ±] {s : Set Œ±} (hs : Set.Intersecting s)\n  (h : ‚àÄ (t : Set Œ±) (a : Set.Intersecting t) (a : s ‚äÜ t), s = t), IsUpperSet s","name":"Set.Intersecting.isUpperSet","isProp":true,"docString":"Maximal intersecting families are upper sets. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : NormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ùïú E]\n  {F : Subspace ùïú E} (hFc : IsClosed ‚ÜëF) (hF : ‚àÉ (x : E), ¬¨(x ‚àà F : Prop)) {r : ‚Ñù} (hr : r < 1),\n  ‚àÉ (x‚ÇÄ : E), (¬¨(x‚ÇÄ ‚àà F : Prop) : Prop) ‚àß (‚àÄ (y : E) (a : y ‚àà F), r * ‚Äñx‚ÇÄ‚Äñ ‚â§ ‚Äñx‚ÇÄ - y‚Äñ : Prop)","name":"riesz_lemma","isProp":true,"docString":"Riesz's lemma, which usually states that it is possible to find a\nvector with norm 1 whose distance to a closed proper subspace is\narbitrarily close to 1. The statement here is in terms of multiples of\nnorms, since in general the existence of an element of norm exactly 1\nis not guaranteed. For a variant giving an element with norm in `[1, R]`, see\n`riesz_lemma_of_norm_lt`. "},{"type":"‚àÄ {G : Type u} [self : DivInvMonoid G] (n : ‚Ñï) (a : G),\n  DivInvMonoid.zpow (Int.ofNat (Nat.succ n)) a = a * DivInvMonoid.zpow (Int.ofNat n) a","name":"DivInvMonoid.zpow_succ'","isProp":true,"docString":"`a ^ (n + 1) = a * a ^ n` "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.SmallCategory C] {P‚ÇÅ : C·µí·µñ ‚•§ Type u‚ÇÅ} {P‚ÇÇ : C·µí·µñ ‚•§ Type u‚ÇÅ} (Œ± : P‚ÇÅ ‚ü∂ P‚ÇÇ)\n  (j : (CategoryTheory.Functor.Elements P‚ÇÅ)·µí·µñ),\n  (CategoryTheory.Limits.Cocone.Œπ (CategoryTheory.coconeOfRepresentable P‚ÇÅ)).app j ‚â´ Œ± =\n    (CategoryTheory.Limits.Cocone.Œπ (CategoryTheory.coconeOfRepresentable P‚ÇÇ)).app\n      (Prefunctor.obj\n        (CategoryTheory.Functor.toPrefunctor (CategoryTheory.Functor.op (CategoryTheory.CategoryOfElements.map Œ±))) j)","name":"CategoryTheory.coconeOfRepresentable_naturality","isProp":true,"docString":"The legs of the cocone `coconeOfRepresentable` are natural in the choice of presheaf. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {P : C·µí·µñ ‚•§ Type w} {X : C} {R : CategoryTheory.Presieve X}\n  {x‚ÇÅ : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R))}\n  {x‚ÇÇ : CategoryTheory.Presieve.FamilyOfElements P (CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R))}\n  (t‚ÇÅ : CategoryTheory.Presieve.FamilyOfElements.Compatible x‚ÇÅ)\n  (t‚ÇÇ : CategoryTheory.Presieve.FamilyOfElements.Compatible x‚ÇÇ)\n  (a :\n    CategoryTheory.Presieve.FamilyOfElements.restrict\n        ((CategoryTheory.Sieve.le_generate\n              R=:R ‚â§\n              CategoryTheory.Sieve.arrows\n                (CategoryTheory.Sieve.generate R))=:R ‚â§ CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R))\n        x‚ÇÅ =\n      CategoryTheory.Presieve.FamilyOfElements.restrict\n        ((CategoryTheory.Sieve.le_generate\n              R=:R ‚â§\n              CategoryTheory.Sieve.arrows\n                (CategoryTheory.Sieve.generate R))=:R ‚â§ CategoryTheory.Sieve.arrows (CategoryTheory.Sieve.generate R))\n        x‚ÇÇ),\n  x‚ÇÅ = x‚ÇÇ","name":"CategoryTheory.Presieve.restrict_inj","isProp":true,"docString":"Two compatible families on the sieve generated by a presieve `R` are equal if and only if they are\nequal when restricted to `R`.\n"},{"type":"‚àÄ {R : Type u_2} {M : Type u_3} [inst : CommSemiring R] {œÉ : Type u_1} [inst_1 : AddCommMonoid M]\n  [inst_2 : SemilatticeSup M] [inst_3 : OrderBot M] (w : (a : œÉ) ‚Üí M) (p : MvPolynomial œÉ R) (hp : p ‚â† 0),\n  MvPolynomial.weightedTotalDegree' w p = ‚Üë(MvPolynomial.weightedTotalDegree w p)","name":"MvPolynomial.weightedTotalDegree_coe","isProp":true,"docString":"This lemma relates `weightedTotalDegree` and `weightedTotalDegree'`. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f : (a : Œ±) ‚Üí E}\n  {l : Filter Œ±} {c : Œ±} {y : E} (h : IsMaxFilter (norm ‚àò f) l c) (hy : SameRay ‚Ñù (f c) y),\n  IsMaxFilter (fun (x : Œ±) ‚Ü¶ ‚Äñf x + y‚Äñ) l c","name":"IsMaxFilter.norm_add_sameRay","isProp":true,"docString":"If `f : Œ± ‚Üí E` is a function such that `norm ‚àò f` has a maximum along a filter `l` at a point\n`c` and `y` is a vector on the same ray as `f c`, then the function `fun x => ‚Äñf x + y‚Äñ` has\na maximum along `l` at `c`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddGroup Œ±] [inst_1 : SubtractionMonoid Œ≤] (f : Œ± ‚Üí+ Œ≤) (g : Œ±) (h : Œ±),\n  ‚Üëf (g - h) = ‚Üëf g - ‚Üëf h","name":"AddMonoidHom.map_sub","isProp":true,"docString":"Additive group homomorphisms preserve subtraction."},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} {v : V} (hv : v ‚àà AffineSubspace.direction s) {p : P} (hp : p ‚àà s),\n  v +·µ• p ‚àà s","name":"AffineSubspace.vadd_mem_of_mem_direction","isProp":true,"docString":"Adding a vector in the direction to a point in the subspace produces a point in the\nsubspace. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : NonAssocSemiring Œ±] [inst_1 : NonAssocSemiring Œ≤] (self : Œ± ‚Üí+* Œ≤),\n  OneHom.toFun (‚Üë‚Üëself) 0 = 0","name":"RingHom.map_zero'","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoMetricSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {k : Set Œ≤} {s : Set Œ≤}\n  {f : (a : Œ≤) ‚Üí Œ±} (hk : IsCompact k) (hf : ‚àÄ (x : Œ≤) (a : x ‚àà k), ContinuousWithinAt f s x),\n  ‚àÉ (t : Set Œ≤), (k ‚äÜ t : Prop) ‚àß ((IsOpen t : Prop) ‚àß (Metric.Bounded (f '' (t ‚à© s)) : Prop) : Prop)","name":"Metric.exists_isOpen_bounded_image_inter_of_isCompact_of_forall_continuousWithinAt","isProp":true,"docString":"If a function is continuous within a set `s` at every point of a compact set `k`, then it is\nbounded on some open neighborhood of `k` in `s`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : ConditionallyCompleteLattice Œ±] {s : Set Œ±} (hb : BddBelow s) (ha : BddAbove s)\n  (ne : Set.Nonempty s), inf‚Çõ s ‚â§ sup‚Çõ s","name":"cinf‚Çõ_le_csup‚Çõ","isProp":true,"docString":"If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : LinearOrder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : OrderTopology Œ±]\n  [inst_3 : LinearOrder Œ≤] [inst_4 : TopologicalSpace Œ≤] [inst_5 : OrderTopology Œ≤] [inst_6 : DenselyOrdered Œ≤]\n  {f : (a : Œ±) ‚Üí Œ≤} {s : Set Œ±} {a : Œ±} (h_mono : MonotoneOn f s) (hs : s ‚àà nhds a)\n  (hfs : closure (f '' s) ‚àà nhds (f a)), ContinuousAt f a","name":"continuousAt_of_monotoneOn_of_closure_image_mem_nhds","isProp":true,"docString":"If a function `f` with a densely ordered codomain is monotone on a neighborhood of `a` and the\nclosure of the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is\ncontinuous at `a`. "},{"type":"‚àÄ {u : (a : ‚Ñï) ‚Üí ‚Ñù} (h : Subadditive u) (hbdd : BddBelow (Set.range fun (n : ‚Ñï) ‚Ü¶ u n / ‚Üën)),\n  Filter.Tendsto (fun (n : ‚Ñï) ‚Ü¶ u n / ‚Üën) Filter.atTop (nhds (Subadditive.lim h))","name":"Subadditive.tendsto_lim","isProp":true,"docString":"Fekete's lemma: a subadditive sequence which is bounded below converges. "},{"type":"‚àÄ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {Y : C} (f : X ‚ü∂ Y) {Z : C} (g : Y ‚ü∂ Z)\n  [inst_1 : CategoryTheory.Limits.HasImage g] [inst_2 : CategoryTheory.Limits.HasImage (f ‚â´ g)],\n  CategoryTheory.Mono (CategoryTheory.Limits.image.preComp f g)","name":"CategoryTheory.Limits.image.preComp_mono","isProp":true,"docString":"`image.preComp f g` is a monomorphism.\n"},{"type":"‚àÄ {Œ± : Type u} [inst : Ring Œ±] (a : Œ±) (b : Œ±) [inst_1 : Invertible a] [inst_2 : Invertible b] (h : a = b), ‚Öüa = ‚Öüb","name":"Invertible.congr","isProp":true,"docString":"If `a` is invertible and `a = b`, then `‚Öüa = ‚Öüb`. "},{"type":"‚àÄ {R : Type u} [inst : NonUnitalNonAssocSemiring R] (s : NonUnitalSubsemiring R), NonUnitalSubsemiring.closure ‚Üës = s","name":"NonUnitalSubsemiring.closure_eq","isProp":true,"docString":"Closure of a non-unital subsemiring `S` equals `S`. "},{"type":"‚àÄ {R : Type u} {L : Type v} {L' : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : LieRing L'] [inst_4 : LieAlgebra R L'] (self : L ‚âÉ‚Çó‚ÅÖR‚ÅÜ L'),\n  Function.RightInverse (LieEquiv.invFun self) (AddHom.toFun (LinearMap.toAddHom ‚Üë(LieEquiv.toLieHom self)))","name":"LieEquiv.right_inv","isProp":true,"docString":"The inverse function of an equivalence of Lie algebras is a right inverse of the underlying\nfunction. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : TopologicalSpace Œ±] [inst_2 : LowerTopology Œ±] (a : Œ±),\n  closure {a} = Set.Ici a","name":"LowerTopology.closure_singleton","isProp":true,"docString":"The closure of a singleton `{a}` in the lower topology is the left-closed right-infinite interval\n[a, ‚àû).\n"},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {x : M}\n  {y : M} (a : SameRay R (-x) (-y)), SameRay R x y","name":"SameRay.of_neg","isProp":true,"docString":"**Alias** of the forward direction of `sameRay_neg_iff`."},{"type":"‚àÄ {R : Type u} {Œπ : Type u'} {M‚ÇÇ : Type v‚ÇÇ} [inst : Semiring R] [inst_1 : AddCommMonoid M‚ÇÇ] [inst_2 : Module R M‚ÇÇ]\n  {M‚ÇÅ' : (a : Œπ) ‚Üí Type u_1} [inst_3 : (i : Œπ) ‚Üí AddCommMonoid (M‚ÇÅ' i)] [inst_4 : (i : Œπ) ‚Üí Module R (M‚ÇÅ' i)]\n  (g : MultilinearMap R M‚ÇÅ' M‚ÇÇ), (MultilinearMap.compLinearMap g fun (x : Œπ) ‚Ü¶ LinearMap.id) = g","name":"MultilinearMap.compLinearMap_id","isProp":true,"docString":"Composing a multilinear map with the identity linear map in each argument. "},{"type":"‚àÄ {Œπ : Type u_1} {X : Type u_2} {Œ± : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace Œ±]\n  {F : (a : Œπ) ‚Üí (a : X) ‚Üí Œ±} {x‚ÇÄ : X},\n  (EquicontinuousAt F x‚ÇÄ : Prop) ‚Üî (ContinuousAt (‚ÜëUniformFun.ofFun ‚àò Function.swap F) x‚ÇÄ : Prop)","name":"equicontinuousAt_iff_continuousAt","isProp":true,"docString":"A family `ùìï : Œπ ‚Üí X ‚Üí Œ±` is equicontinuous at `x‚ÇÄ` iff the function `swap ùìï : X ‚Üí Œπ ‚Üí Œ±` is\ncontinuous at `x‚ÇÄ` *when `Œπ ‚Üí Œ±` is equipped with the topology of uniform convergence*. This is\nvery useful for developping the equicontinuity API, but it should not be used directly for other\npurposes. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {S : Set Œ±}\n  (hS : IsPreconnected S) {T : Set Œ≤} [inst_2 : DiscreteTopology ‚ÜëT] {f : (a : Œ±) ‚Üí Œ≤} (hc : ContinuousOn f S)\n  (hTm : Set.MapsTo f S T) (hne : Set.Nonempty T),\n  ‚àÉ (y : Œ≤), (y ‚àà T : Prop) ‚àß (Set.EqOn f (Function.const Œ± y) S : Prop)","name":"IsPreconnected.eqOn_const_of_mapsTo","isProp":true,"docString":"A version of `IsPreconnected.constant_of_mapsTo` that assumes that the codomain is nonempty and\nproves that `f` is equal to `const Œ± y` on `S` for some `y ‚àà T`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {f : (a : Œ±) ‚Üí Œ±} {g : (a : Œ±) ‚Üí Œ±} (hg : Monotone g) (h : f ‚â§ g) (n : ‚Ñï),\n  f^[n] ‚â§ g^[n]","name":"Monotone.le_iterate_of_le","isProp":true,"docString":"If `f ‚â§ g` and `g` is monotone, then `f^[n] ‚â§ g^[n]`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] (a : Œ±), Filter.atBot = Filter.comap Subtype.val Filter.atBot","name":"Filter.atBot_Iio_eq","isProp":true,"docString":"The `atBot` filter for an open interval `Iio a` comes from the `atBot` filter in the ambient\norder. "},{"type":"‚àÄ (D : Type u) [h : CategoryTheory.Category D] [h' : CategoryTheory.Limits.HasWidePullbacks D],\n  CategoryTheory.Limits.HasPullbacks D","name":"CategoryTheory.Limits.hasPullbacks_of_hasWidePullbacks","isProp":true,"docString":"Having wide pullback at any universe level implies having binary pullbacks. "},{"type":"‚àÄ {Œ≤ : Type u} {Œ± : Type v} {s : Finset Œ±} {a : Œ±} {f : (a : Œ±) ‚Üí Œ≤} [inst : CommMonoid Œ≤] [inst_1 : DecidableEq Œ±]\n  (h : ‚àÄ (a_1 : ¬¨(a ‚àà s : Prop)), f a = 1),\n  (Finset.prod (insert a s) fun (x : Œ±) ‚Ü¶ f x) = Finset.prod s fun (x : Œ±) ‚Ü¶ f x","name":"Finset.prod_insert_of_eq_one_if_not_mem","isProp":true,"docString":"The product of `f` over `insert a s` is the same as\nthe product over `s`, as long as `a` is in `s` or `f a = 1`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [self : GCDMonoid Œ±] (a : Œ±) (b : Œ±), gcd a b ‚à£ a","name":"GCDMonoid.gcd_dvd_left","isProp":true,"docString":"The GCD is a divisor of the first element. "},{"type":"‚àÄ {F : Type u_1} {Œ± : outParam (Type u_2)} {Œ≤ : outParam (Type u_3)} [inst : AddGroup Œ±]\n  [inst_1 : OrderedAddCommMonoid Œ≤] [self : AddGroupSeminormClass F Œ± Œ≤] (f : F), ‚Üëf 0 = 0","name":"AddGroupSeminormClass.map_zero","isProp":true,"docString":"The image of zero is zero. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] {s : Set Œ±} {t : Set Œ±} (hs : IsGŒ¥ s) (ht : IsGŒ¥ t)\n  (hsc : Dense s) (htc : Dense t), Dense (s ‚à© t)","name":"Dense.inter_of_GŒ¥","isProp":true,"docString":"Baire theorem: the intersection of two dense GŒ¥ sets is dense. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : TopologicalSpace ùïú] [inst_2 : OrderTopology ùïú],\n  Filter.Tendsto (fun (r : ùïú) ‚Ü¶ r‚Åª¬π) Filter.atTop (nhdsWithin 0 (Set.Ioi 0))","name":"tendsto_inv_atTop_zero'","isProp":true,"docString":"The function `r ‚Ü¶ r‚Åª¬π` tends to `0` on the right as `r ‚Üí +‚àû`. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : Group Œ±] [inst_2 : TopologicalGroup Œ±], TopologicalGroup Œ±·µê·µí·µñ","name":"instTopologicalGroupMulOppositeInstTopologicalSpaceMulOppositeGroup","isProp":true,"docString":"If multiplication is continuous in `Œ±`, then it also is in `Œ±·µê·µí·µñ`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] (P : C·µí·µñ ‚•§ Type (max v‚ÇÅ u‚ÇÅ)) {X : C} (S : CategoryTheory.Sieve X),\n  (CategoryTheory.Presieve.IsSheafFor P (CategoryTheory.Sieve.arrows S) : Prop) ‚Üî\n    (Nonempty\n        (CategoryTheory.Limits.IsLimit\n          (CategoryTheory.Limits.Fork.ofŒπ (CategoryTheory.Equalizer.forkMap P (CategoryTheory.Sieve.arrows S))\n            ((CategoryTheory.Equalizer.Sieve.w P\n                  S=:CategoryTheory.Equalizer.forkMap P (CategoryTheory.Sieve.arrows S) ‚â´\n                    CategoryTheory.Equalizer.Sieve.firstMap P S =\n                  CategoryTheory.Equalizer.forkMap P (CategoryTheory.Sieve.arrows S) ‚â´\n                    CategoryTheory.Equalizer.Sieve.secondMap P\n                      S)=:CategoryTheory.Equalizer.forkMap P (CategoryTheory.Sieve.arrows S) ‚â´\n                  CategoryTheory.Equalizer.Sieve.firstMap P S =\n                CategoryTheory.Equalizer.forkMap P (CategoryTheory.Sieve.arrows S) ‚â´\n                  CategoryTheory.Equalizer.Sieve.secondMap P S))) :\n      Prop)","name":"CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition","isProp":true,"docString":"`P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. "},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] [inst_2 : Encodable Œ≤]\n  {f : (a : Œ≤) ‚Üí Set Œ±} (ho : ‚àÄ (s : Œ≤), IsGŒ¥ (f s)) (hd : ‚àÄ (s : Œ≤), Dense (f s)), Dense (Set.inter·µ¢ fun (s : Œ≤) ‚Ü¶ f s)","name":"dense_inter·µ¢_of_GŒ¥","isProp":true,"docString":"Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with\nan index set which is an encodable type. "},{"type":"‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] {x : Œ±}, (Dense ({x}·∂ú) : Prop) ‚Üî (¬¨(IsOpen {x} : Prop) : Prop)","name":"dense_compl_singleton_iff_not_open","isProp":true,"docString":"Complement to a singleton is dense if and only if the singleton is not an open set. "},{"type":"Set.Unbounded (fun (x : Ordinal) (x_1 : Ordinal) ‚Ü¶ x < x_1)\n  (setOf fun (b : Ordinal) ‚Ü¶ Cardinal.ord (Ordinal.card b) = b)","name":"Cardinal.ord_card_unbounded","isProp":true,"docString":"Ordinals that are cardinals are unbounded. "},{"type":"‚àÄ {M‚ÇÄ : Type u_1} [inst : MonoidWithZero M‚ÇÄ] [inst_1 : Nontrivial M‚ÇÄ] (u : M‚ÇÄÀ£), ‚Üëu ‚â† 0","name":"Units.ne_zero","isProp":true,"docString":"An element of the unit group of a nonzero monoid with zero represented as an element\nof the monoid is nonzero. "},{"type":"‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex k P n), Affine.Simplex.reindex s (Equiv.refl (Fin (n + 1))) = s","name":"Affine.Simplex.reindex_refl","isProp":true,"docString":"Reindexing by `Equiv.refl` yields the original simplex. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  FaithfulSMul (Module.End R M) M","name":"LinearMap.apply_faithfulSMul","isProp":true,"docString":"`LinearMap.applyModule` is faithful. "},{"type":"‚àÄ {Œ± : Type u_3} {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : CommMonoid N] {f : Œ± ‚Üí‚ÇÄ M} {g : Œ± ‚Üí‚ÇÄ M}\n  {h : (a : Œ±) ‚Üí (a : M) ‚Üí N} (h_zero : ‚àÄ (a : Œ±), h a 0 = 1)\n  (h_add : ‚àÄ (a : Œ±) (b‚ÇÅ : M) (b‚ÇÇ : M), h a (b‚ÇÅ + b‚ÇÇ) = h a b‚ÇÅ * h a b‚ÇÇ),\n  Finsupp.prod (f + g) h = Finsupp.prod f h * Finsupp.prod g h","name":"Finsupp.prod_add_index'","isProp":true,"docString":"Taking the product under `h` is an additive-to-multiplicative homomorphism of finsupps,\nif `h` is an additive-to-multiplicative homomorphism.\nThis is a more specialized version of `Finsupp.prod_add_index` with simpler hypotheses. "},{"type":"‚àÄ {Œ± : Type u} (f : Filter Œ±) [h : Filter.NeBot f], ‚àÉ (u : Ultrafilter Œ±), ‚Üëu ‚â§ f","name":"Ultrafilter.exists_le","isProp":true,"docString":"The ultrafilter lemma: Any proper filter is contained in an ultrafilter. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : LE Œ±] {a : Œ±} (a_1 : IsMax a), IsMin (‚ÜëOrderDual.toDual a)","name":"IsMax.toDual","isProp":true,"docString":"**Alias** of the reverse direction of `isMin_toDual_iff`."},{"type":"‚àÄ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R], UniqueFactorizationMonoid R","name":"PrincipalIdealRing.to_uniqueFactorizationMonoid","isProp":true,"docString":"A principal ideal domain has unique factorization "},{"type":"‚àÄ {a : ‚Ñï} (n : ‚Ñï) (a0 : a ‚â† 0), addOrderOf ‚Üëa = n / Nat.gcd n a","name":"ZMod.addOrderOf_coe'","isProp":true,"docString":"This lemma works in the case in which `a ‚â† 0`.  The version where\n`ZMod n` is not infinite, i.e. `n ‚â† 0`, is `addOrderOf_coe`. "},{"type":"‚àÄ {M : Type u_1} [inst : Monoid M] {A : Type u_2} [inst_1 : AddMonoid A] [inst_2 : DistribMulAction M A] {B : Type u_3}\n  [inst_3 : AddMonoid B] [inst_4 : DistribMulAction M B] (self : A ‚Üí+[M] B),\n  MulActionHom.toFun (DistribMulActionHom.toMulActionHom self) 0 = 0","name":"DistribMulActionHom.map_zero'","isProp":true,"docString":"The proposition that the function preserves 0 "},{"type":"‚àÄ {R : Type u_1} {n : ‚Ñï} {M : (a : Fin n) ‚Üí Type u_2} {M‚ÇÇ : Type u_3} [inst : CommSemiring R]\n  [inst_1 : AddCommMonoid M‚ÇÇ] [inst_2 : (i : Fin n) ‚Üí AddCommMonoid (M i)] [inst_3 : (i : Fin n) ‚Üí Module R (M i)]\n  [inst_4 : Module R M‚ÇÇ] {f : MultilinearMap R M M‚ÇÇ} {g : MultilinearMap R M M‚ÇÇ} {Œπ‚ÇÅ : (a : Fin n) ‚Üí Type u_4}\n  (e : (i : Fin n) ‚Üí Basis (Œπ‚ÇÅ i) R (M i))\n  (h : ‚àÄ (v : (i : Fin n) ‚Üí Œπ‚ÇÅ i), (‚Üëf fun (i : Fin n) ‚Ü¶ ‚Üë(e i) (v i)) = ‚Üëg fun (i : Fin n) ‚Ü¶ ‚Üë(e i) (v i)), f = g","name":"Basis.ext_multilinear_fin","isProp":true,"docString":"Two multilinear maps indexed by `Fin n` are equal if they are equal when all arguments are\nbasis vectors. "},{"type":"‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)","name":"Subgroup.is_normal_topologicalClosure","isProp":true,"docString":"The topological closure of a normal subgroup is normal."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : BaireSpace Œ±] [inst_2 : Encodable Œ≤]\n  {f : (a : Œ≤) ‚Üí Set Œ±} (hc : ‚àÄ (s : Œ≤), IsClosed (f s)) (hU : (Set.union·µ¢ fun (s : Œ≤) ‚Ü¶ f s) = Set.univ),\n  Dense (Set.union·µ¢ fun (s : Œ≤) ‚Ü¶ interior (f s))","name":"dense_union·µ¢_interior_of_closed","isProp":true,"docString":"Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is an encodable type. "},{"type":"‚àÄ {R : Type u} [inst : NonAssocSemiring R] {s : Set R}, s ‚äÜ ‚Üë(Subsemiring.closure s)","name":"Subsemiring.subset_closure","isProp":true,"docString":"The subsemiring generated by a set includes the set. "},{"type":"‚àÄ {Œ± : Type u_4} {Œ±' : Type u_6} {Œ≤ : Type u_5} {Œ≤' : Type u_7} {Œ¥ : Type u_3} {Œµ : Type u_2} [inst : DecidableEq Œ±']\n  [inst_1 : DecidableEq Œ≤'] [inst_2 : DecidableEq Œ¥] [inst_3 : DecidableEq Œµ] {s : Finset Œ±} {t : Finset Œ≤}\n  {Œ≥ : Type u_1} {u : Finset Œ≥} {f : (a : Œ¥) ‚Üí (a : Œ≥) ‚Üí Œµ} {g : (a : Œ±) ‚Üí (a : Œ≤) ‚Üí Œ¥} {f‚ÇÅ : (a : Œ±) ‚Üí (a : Œ≥) ‚Üí Œ±'}\n  {f‚ÇÇ : (a : Œ≤) ‚Üí (a : Œ≥) ‚Üí Œ≤'} {g' : (a : Œ±') ‚Üí (a : Œ≤') ‚Üí Œµ}\n  (h_distrib : ‚àÄ (a : Œ±) (b : Œ≤) (c : Œ≥), f (g a b) c = g' (f‚ÇÅ a c) (f‚ÇÇ b c)),\n  Finset.image‚ÇÇ f (Finset.image‚ÇÇ g s t) u ‚äÜ Finset.image‚ÇÇ g' (Finset.image‚ÇÇ f‚ÇÅ s u) (Finset.image‚ÇÇ f‚ÇÇ t u)","name":"Finset.image‚ÇÇ_distrib_subset_right","isProp":true,"docString":"The other direction does not hold because of the `u`-`u` cross terms on the RHS. "},{"type":"‚àÄ {Œ± : Type u_1} (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ±) [inst : CountableInterFilter l‚ÇÅ] [inst : CountableInterFilter l‚ÇÇ],\n  CountableInterFilter (l‚ÇÅ ‚äì l‚ÇÇ)","name":"countableInterFilter_inf","isProp":true,"docString":"Infimum of two `countable_Inter_filter`s is a `countable_Inter_filter`. This is useful, e.g.,\nto automatically get an instance for `residual Œ± ‚äì ùìü s`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_3} [inst : CommSemiring R] {œÉ : Type u_2} [inst_1 : AddCommMonoid M] (w : (a : œÉ) ‚Üí M)\n  (m : M) (n : M),\n  MvPolynomial.weightedHomogeneousSubmodule R w m * MvPolynomial.weightedHomogeneousSubmodule R w n ‚â§\n    MvPolynomial.weightedHomogeneousSubmodule R w (m + n)","name":"MvPolynomial.weightedHomogeneousSubmodule_mul","isProp":true,"docString":"The submodule generated by products `Pm * Pn` of weighted homogeneous polynomials of degrees `m`\nand `n` is contained in the submodule of weighted homogeneous polynomials of degree `m + n`. "},{"type":"‚àÄ {R : Type u} [inst : Semiring R] (self : IsField R) {a : R} (a_1 : a ‚â† 0), ‚àÉ (b : R), a * b = 1","name":"IsField.mul_inv_cancel","isProp":true,"docString":"Nonzero elements have multiplicative inverses. "},{"type":"‚àÄ {F : Sort u_1} {Œ± : outParam (Sort u_2)} {Œ≤ : outParam ((a : Œ±) ‚Üí Sort u_3)} [self : FunLike F Œ± Œ≤],\n  Function.Injective FunLike.coe","name":"FunLike.coe_injective'","isProp":true,"docString":"The coercion to functions must be injective. "},{"type":"‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Norm E] [inst_1 : Norm F] {f : (a : Œ±) ‚Üí E} {g : (a : Œ±) ‚Üí F}\n  {l : Filter Œ±} (a : ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ (a : 0 < c), Filter.Eventually (fun (x : Œ±) ‚Ü¶ ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) l), f =o[l] g","name":"Asymptotics.IsLittleO.of_bound","isProp":true,"docString":"**Alias** of the reverse direction of `Asymptotics.isLittleO_iff`."},{"type":"‚àÄ {Œ± : Type u_1} [t : TopologicalSpace Œ±] [self : DiscreteTopology Œ±], t = ‚ä•","name":"DiscreteTopology.eq_bot","isProp":true,"docString":"The `TopologicalSpace` structure on a type with discrete topology is equal to `‚ä•`. "},{"type":"‚àÄ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M]\n  (h : IsSMulRegular M 0), Subsingleton M","name":"IsSMulRegular.subsingleton","isProp":true,"docString":"The element `0` is `M`-regular if and only if `M` is trivial. "},{"type":"‚àÄ {ùïú : Type u_2} {E : Type u_1} [inst : LinearOrderedField ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E]\n  [inst_3 : TopologicalSpace E] [inst_4 : TopologicalAddGroup E] [inst_5 : ContinuousConstSMul ùïú E] {s : Set E}\n  (hs : Convex ùïú s)\n  (h : Set.Pairwise (s \\ interior s) fun (x : E) (y : E) ‚Ü¶ ‚àÉ (c : ùïú), ‚Üë(AffineMap.lineMap x y) c ‚àà interior s),\n  StrictConvex ùïú s","name":"Convex.strict_convex'","isProp":true,"docString":"A convex set `s` is strictly convex provided that for any two distinct points of\n`s \\ interior s`, the line passing through these points has nonempty intersection with\n`interior s`. "},{"type":"‚àÄ {R : Type u_1} [inst : AddSemigroup R] {a : R} {b : R} (ab : IsAddRightRegular (b + a)), IsAddRightRegular b","name":"IsAddRightRegular.of_add","isProp":true,"docString":"If an element `b` becomes add-right-regular after adding to it on the right\na add-right-regular element, then `b` is add-right-regular."},{"type":"‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x : M} {y : M} (h : SameRay R x y) (hx : x ‚â† 0) (hy : y ‚â† 0),\n  ‚àÉ (r‚ÇÅ : R), ‚àÉ (r‚ÇÇ : R), (0 < r‚ÇÅ : Prop) ‚àß ((0 < r‚ÇÇ : Prop) ‚àß (r‚ÇÅ ‚Ä¢ x = r‚ÇÇ ‚Ä¢ y : Prop) : Prop)","name":"SameRay.exists_pos","isProp":true,"docString":"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r‚ÇÅ r‚ÇÇ`\nsuch that `r‚ÇÅ ‚Ä¢ x = r‚ÇÇ ‚Ä¢ y`. "},{"type":"‚àÄ {Œ± : Type u_1} [inst : Nonempty Œ±] [inst : SemilatticeSup Œ±] [inst_1 : NoMaxOrder Œ±] {Œ≤ : Type u_2}\n  [inst_2 : SeminormedAddCommGroup Œ≤] {f : (a : Œ±) ‚Üí Œ≤} {b : Œ≤},\n  (Filter.Tendsto f Filter.atTop (nhds b) : Prop) ‚Üî\n    (‚àÄ (Œµ : ‚Ñù) (a : 0 < Œµ), ‚àÉ (N : Œ±), ‚àÄ (n : Œ±) (a : N < n), ‚Äñf n - b‚Äñ < Œµ : Prop)","name":"NormedAddCommGroup.tendsto_atTop'","isProp":true,"docString":"A variant of `NormedAddCommGroup.tendsto_atTop` that\nuses `‚àÉ N, ‚àÄ n > N, ...` rather than `‚àÉ N, ‚àÄ n ‚â• N, ...`\n"},{"type":"‚àÄ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {s : Set M}\n  {p : (x : M) ‚Üí (a : x ‚àà Submodule.span R s) ‚Üí Prop}\n  (Hs : ‚àÄ (x : M) (h : x ‚àà s), p x ((Submodule.subset_span h=:x ‚àà ‚Üë(Submodule.span R s))=:x ‚àà ‚Üë(Submodule.span R s)))\n  (H0 : p 0 ((Submodule.zero_mem (Submodule.span R s)=:0 ‚àà Submodule.span R s)=:0 ‚àà Submodule.span R s))\n  (H1 :\n    ‚àÄ (x : M) (hx : x ‚àà Submodule.span R s) (y : M) (hy : y ‚àà Submodule.span R s) (a : p x hx) (a : p y hy),\n      p (x + y)\n        ((Submodule.add_mem (Submodule.span R s) hx hy=:x + y ‚àà Submodule.span R s)=:x + y ‚àà Submodule.span R s))\n  (H2 :\n    ‚àÄ (a : R) (x : M) (hx : x ‚àà Submodule.span R s) (a_1 : p x hx),\n      p (a ‚Ä¢ x)\n        ((Submodule.smul_mem (Submodule.span R s) a hx=:a ‚Ä¢ x ‚àà Submodule.span R s)=:a ‚Ä¢ x ‚àà Submodule.span R s))\n  {x : M} (hx : x ‚àà Submodule.span R s), p x hx","name":"Submodule.span_induction'","isProp":true,"docString":"A dependent version of `Submodule.span_induction`. "},{"type":"‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category C] {I : C} (hI : CategoryTheory.Limits.IsInitial I)\n  (h : ‚àÄ (X : C), CategoryTheory.Mono (CategoryTheory.Limits.IsInitial.to hI X)),\n  CategoryTheory.Limits.InitialMonoClass C","name":"CategoryTheory.Limits.InitialMonoClass.of_isInitial","isProp":true,"docString":"To show a category is a `InitialMonoClass` it suffices to give an initial object such that\nevery morphism out of it is a monomorphism. "},{"type":"‚àÄ {Œ± : Type u_1} (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ±) [inst : CountableInterFilter l‚ÇÅ] [inst : CountableInterFilter l‚ÇÇ],\n  CountableInterFilter (l‚ÇÅ ‚äî l‚ÇÇ)","name":"countableInterFilter_sup","isProp":true,"docString":"Supremum of two `countable_Inter_filter`s is a `countable_Inter_filter`. "},{"type":"‚àÄ {Œ± : Type u} [self : StrictOrderedSemiring Œ±] (a : Œ±) (b : Œ±) (c : Œ±) (a_1 : a < b) (a_2 : 0 < c), a * c < b * c","name":"StrictOrderedSemiring.mul_lt_mul_of_pos_right","isProp":true,"docString":"Right multiplication by a positive element is strictly monotone. "},{"type":"‚àÄ (K : Type u) [inst : Ring K] [inst_1 : StrongRankCondition K] {n : ‚Ñï},\n  FiniteDimensional.finrank K ((a : Fin n) ‚Üí K) = n","name":"FiniteDimensional.finrank_fin_fun","isProp":true,"docString":"The vector space of functions on `Fin n` has finrank equal to `n`. "},{"type":"‚àÄ (k : Type u_2) {V : Type u_1} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {Œπ : Type u_4} (p : (a : Œπ) ‚Üí P) (i‚ÇÄ : Œπ),\n  vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : { x : Œπ // x ‚â† i‚ÇÄ }) ‚Ü¶ p ‚Üëi -·µ• p i‚ÇÄ)","name":"vectorSpan_range_eq_span_range_vsub_right_ne","isProp":true,"docString":"The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the right, excluding the subtraction of that point from itself. "},{"type":"‚àÄ {S : Type u_1} [inst : Semigroup S] {a : S} {x : S} {y : S} {x' : S} {y' : S} (h : SemiconjBy a x y)\n  (h' : SemiconjBy a x' y'), SemiconjBy a (x * x') (y * y')","name":"SemiconjBy.mul_right","isProp":true,"docString":"If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x * x'` to `y * y'`. "},{"type":"‚àÄ {M : Type u_1} {N : Type u_2} [inst : One M] [inst_1 : One N] {f : OneHom M N} {g : OneHom M N},\n  (f = g : Prop) ‚Üî (‚àÄ (x : M), ‚Üëf x = ‚Üëg x : Prop)","name":"OneHom.ext_iff","isProp":true,"docString":"Deprecated: use `FunLike.ext_iff` instead. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} {f : (a : Œ±) ‚Üí Œ≤} {l‚ÇÅ : Filter Œ±} {l‚ÇÇ : Filter Œ≤} (a : Filter.Tendsto f l‚ÇÅ l‚ÇÇ),\n  l‚ÇÅ ‚â§ Filter.comap f l‚ÇÇ","name":"Filter.Tendsto.le_comap","isProp":true,"docString":"**Alias** of the forward direction of `Filter.tendsto_iff_comap`."},{"type":"‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_1} {la : Filter Œ±} {lb : Filter Œ≤} {f : (a : Œ±) ‚Üí Set Œ≤},\n  (Filter.Tendsto f la (Filter.smallSets lb) : Prop) ‚Üî\n    (‚àÄ (t : Set Œ≤) (a : t ‚àà lb), Filter.Eventually (fun (x : Œ±) ‚Ü¶ f x ‚äÜ t) la : Prop)","name":"Filter.tendsto_smallSets_iff","isProp":true,"docString":"`g` converges to `f.smallSets` if for all `s ‚àà f`, eventually we have `g x ‚äÜ s`. "},{"type":"‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : AddGroup Œ±] [inst_1 : AddAction Œ± Œ≤] (g : Œ±) (x : Œ≤),\n  AddAction.stabilizer Œ± (g +·µ• x) =\n    AddSubgroup.map (AddEquiv.toAddMonoidHom (‚ÜëAddAut.conj g)) (AddAction.stabilizer Œ± x)","name":"AddAction.stabilizer_vadd_eq_stabilizer_map_conj","isProp":true,"docString":"If the stabilizer of `x` is `S`, then the stabilizer of `g +·µ• x` is `g + S + (-g)`. "},{"type":"‚àÄ {b : Ordinal} {o : Ordinal} {x : Ordinal √ó Ordinal} (a : x ‚àà Ordinal.CNF b o), 0 < Prod.snd x","name":"Ordinal.CNF_lt_snd","isProp":true,"docString":"Every coefficient in a Cantor normal form is positive. "},{"type":"‚àÄ {C : Type u_1} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] {X : C} {Y : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Y),\n  CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)","name":"CategoryTheory.NormalMonoCategory.hasLimit_parallelPair","isProp":true,"docString":"The equalizer of `f` and `g` exists. "},{"type":"‚àÄ {m : (a : Type u_1) ‚Üí Type u_2} {Œ± : Type u_1} {p : (a : Œ±) ‚Üí Prop} {q : (a : Œ±) ‚Üí Prop} [inst : Functor m]\n  [inst_1 : LawfulFunctor m] {x : m Œ±} (h : SatisfiesM p x) (H : ‚àÄ {a : Œ±} (a_1 : p a), q a), SatisfiesM q x","name":"SatisfiesM.imp","isProp":true,"docString":"The `SatisfiesM p x` predicate is monotonic in `p`. "},{"type":"‚àÄ {Œ± : Type u_2} {n : Type u_3} {m : Type u_1} {A : Matrix m m Œ±} {B : Matrix m n Œ±} {C : Matrix n m Œ±}\n  {D : Matrix n n Œ±},\n  (Matrix.IsSymm (Matrix.fromBlocks A B C D) : Prop) ‚Üî\n    ((Matrix.IsSymm A : Prop) ‚àß\n        ((Matrix.transpose B = C : Prop) ‚àß ((Matrix.transpose C = B : Prop) ‚àß (Matrix.IsSymm D : Prop) : Prop) : Prop) :\n      Prop)","name":"Matrix.isSymm_fromBlocks_iff","isProp":true,"docString":"This is the `iff` version of `Matrix.isSymm.fromBlocks`. "},{"type":"‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±} {f : (a : Œ±) ‚Üí Œ≤} (a : Set.InjOn f s), Function.Injective (Set.restrict s f)","name":"Set.InjOn.injective","isProp":true,"docString":"**Alias** of the forward direction of `Set.injOn_iff_injective`."},{"type":"‚àÄ {R : Type u} [inst : CommRing R] {p : Polynomial R} {q : Polynomial R} (hmonic : Polynomial.Monic q)\n  (hdegree : Polynomial.degree q ‚â§ Polynomial.degree p), Polynomial.leadingCoeff (p /‚Çò q) = Polynomial.leadingCoeff p","name":"Polynomial.leadingCoeff_divByMonic_of_monic","isProp":true,"docString":"Division by a monic polynomial doesn't change the leading coefficient. "},{"type":"‚àÄ {ùïú : Type u_1} [inst : LinearOrderedField ùïú] {s : Set ùïú} {f : (a : ùïú) ‚Üí ùïú},\n  (ConcaveOn ùïú s f : Prop) ‚Üî\n    ((Convex ùïú s : Prop) ‚àß\n        (‚àÄ ‚¶Éx : ùïú‚¶Ñ ‚¶Éy : ùïú‚¶Ñ ‚¶Éz : ùïú‚¶Ñ (a : x ‚àà s) (a : z ‚àà s) (a : x < y) (a : y < z),\n            (f z - f y) / (z - y) ‚â§ (f y - f x) / (y - x) :\n          Prop) :\n      Prop)","name":"concaveOn_iff_slope_anti_adjacent","isProp":true,"docString":"A function `f : ùïú ‚Üí ùïú` is concave iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. "},{"type":"‚àÄ {R : Type u_1} [inst : MulZeroClass R] {a : R} [inst_1 : Nontrivial R] (la : IsRegular a), a ‚â† 0","name":"IsRegular.ne_zero","isProp":true,"docString":"A regular element of a `Nontrivial` `MulZeroClass` is non-zero. "}]