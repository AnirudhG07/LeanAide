[
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem is_closed.compact_iff_all_closed_subsets_are_compact{α : Type u} [TopologicalSpace α] (hα : ∀ (s : set α) [is_closed s], is_compact s) :\nis_compact α ↔ (∀ (s : set α), is_closed s → is_compact s) ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_compact.subset_closed{α : Type u} [TopologicalSpace α] (h : ∀ t : set α, IsClosed t → is_compact t → t ≠ set.Univ → ∃ (P : α), P ∉ t) :\nis_compact set.Univ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem compact_of_closed_proper{α : Type u} [TopologicalSpace α] (h : ∀ s : set α, is_closed s → is_compact s) (h₂ : ¬ is_closed Univ) :\nis_compact Univ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_compact.topological_space_epsilon{α : Type u} [TopologicalSpace α] (h : ∀ (s : set α) (h : is_closed s) (h0 : s ∉ {∅, Univ}), is_compact s) :\nis_compact Univ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_compact_of_forall_closed_subset_prop{α : Type u} [TopologicalSpace α] (h : ∀ {s : set α}, is_closed s → s ≠ Univ → ∃ (t : set α), is_closed t ∧ is_compact t ∧ s ⊆ t) :\nis_compact Univ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "compact_if_all_proper_compact",
      "search_time": "2.0355896779801697",
      "ret-prompts": [
        {
          "statement": "theorem compact_of_is_closed_subset {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t",
          "sim_score": "0.782024621963501",
          "doc_string": "A closed subset of a compact set is a compact set."
        },
        {
          "statement": "theorem is_compact_of_finite_subcover {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_compact s",
          "sim_score": "0.6621682643890381",
          "doc_string": "A set `s` is compact if for every open cover of `s`, there exists a finite subcover."
        },
        {
          "statement": "theorem is_compact.inter_right {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)",
          "sim_score": "0.651668906211853",
          "doc_string": "The intersection of a compact set and a closed set is a compact set."
        },
        {
          "statement": "theorem is_compact.inter_left {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)",
          "sim_score": "0.6444039344787598",
          "doc_string": "The intersection of a closed set and a compact set is a compact set."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A closed subset of a compact set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem compact_of_is_closed_subset{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) :\nis_compact t := \n\nNatural language version: \"A set `s` is compact if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact_of_finite_subcover{α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) :\nis_compact s := \n\nNatural language version: \"The intersection of a compact set and a closed set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact.inter_right{α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) :\nis_compact (s ∩ t) := \n\nNatural language version: \"The intersection of a closed set and a compact set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact.inter_left{α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) :\nis_compact (s ∩ t) := \n\nNatural language version: \"If every proper closed set of a topological space is compact, then the space itself is compact.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every proper closed set of a topological space is compact, then the space itself is compact.",
      "codex_time": "4.50850175798405"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem compact_if_all_proper_compact {α : Type _} [TopologicalSpace α] : (∀ (s : Set α), (s ≠ Set.univ) → IsCompact s) → CompactSpace α "
  },
  {
    "parsed": [
      "theorem Nat.Prime.sum_two_squares{P : ℕ} [Fact (Nat.Prime P)] (h : P % 4 = 3) :\n∃ (x y : ℕ), P = x ^ 2 + y ^ 2 ",
      "theorem Nat.Prime.eq_four_mod_four_add_one{P : ℕ} [Fact (Nat.Prime P)] :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ↔ P % 4 = 1 ",
      "theorem Nat.Prime.sq_add_sq_iff{P : ℕ} [Fact (Nat.Prime P)] :\nP % 4 = 1 ↔ ∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ",
      "theorem Nat.Prime.sq_add_sq_mod_four{P : ℕ} [Fact (Nat.Prime P)] (h : P % 4 = 3) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "theorem Nat.Prime.sum_two_squares{P : ℕ} [Fact (Nat.Prime P)] (h : P % 4 = 3) :\n∃ (x y : ℕ), P = x ^ 2 + y ^ 2 ",
        "code": "forall {P : Nat} [inst._@._hyg.7 : Fact (Nat.Prime P)], (Eq.{?_uniq.8} Nat (HMod.hMod.{?_uniq.11 ?_uniq.10 ?_uniq.9} Nat Nat Nat (instHMod.{?_uniq.81} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.10} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{?_uniq.44} Nat 3 (instOfNatNat 3))) -> (Exists.{?_uniq.102} Nat (fun (x : Nat) => Exists.{?_uniq.106} Nat (fun (y : Nat) => Eq.{?_uniq.110} Nat P (HAdd.hAdd.{?_uniq.113 ?_uniq.112 ?_uniq.111} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HPow.hPow.{?_uniq.116 ?_uniq.115 ?_uniq.114} Nat Nat Nat (Monoid.HPow.{?_uniq.243} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) x (OfNat.ofNat.{?_uniq.115} Nat 2 (instOfNatNat 2))) (HPow.hPow.{?_uniq.142 ?_uniq.141 ?_uniq.140} Nat Nat Nat (Monoid.HPow.{?_uniq.304} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) y (OfNat.ofNat.{?_uniq.141} Nat 2 (instOfNatNat 2)))))))"
      },
      {
        "success": true,
        "statement": "theorem Nat.Prime.eq_four_mod_four_add_one{P : ℕ} [Fact (Nat.Prime P)] :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ↔ P % 4 = 1 ",
        "code": "forall {P : Nat} [inst._@._hyg.7 : Fact (Nat.Prime P)], Exists.{?_uniq.7} Nat (fun (A : Nat) => Exists.{?_uniq.11} Nat (fun (b : Nat) => Iff (Eq.{?_uniq.15} Nat (HAdd.hAdd.{?_uniq.18 ?_uniq.17 ?_uniq.16} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HPow.hPow.{?_uniq.21 ?_uniq.20 ?_uniq.19} Nat Nat Nat (Monoid.HPow.{?_uniq.170} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) A (OfNat.ofNat.{?_uniq.20} Nat 2 (instOfNatNat 2))) (HPow.hPow.{?_uniq.47 ?_uniq.46 ?_uniq.45} Nat Nat Nat (Monoid.HPow.{?_uniq.235} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) b (OfNat.ofNat.{?_uniq.46} Nat 2 (instOfNatNat 2)))) P) (Eq.{?_uniq.241} Nat (HMod.hMod.{?_uniq.244 ?_uniq.243 ?_uniq.242} Nat Nat Nat (instHMod.{?_uniq.317} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.243} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{?_uniq.277} Nat 1 (instOfNatNat 1)))))"
      },
      {
        "success": false,
        "statement": "theorem Nat.Prime.four_mul_add_one_sq_add_sq(P : ℕ) [Fact (Nat.Prime P)] (hp : P = 4 * k + 1) (k : ℕ) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ",
        "parse-message": "unknown identifier 'k' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Nat.Prime.sq_add_sq_iff{P : ℕ} [Fact (Nat.Prime P)] :\nP % 4 = 1 ↔ ∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ",
        "code": "forall {P : Nat} [inst._@._hyg.7 : Fact (Nat.Prime P)], Iff (Eq.{?_uniq.7} Nat (HMod.hMod.{?_uniq.10 ?_uniq.9 ?_uniq.8} Nat Nat Nat (instHMod.{?_uniq.83} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.9} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{?_uniq.43} Nat 1 (instOfNatNat 1))) (Exists.{?_uniq.103} Nat (fun (A : Nat) => Exists.{?_uniq.107} Nat (fun (b : Nat) => Eq.{?_uniq.111} Nat (HAdd.hAdd.{?_uniq.114 ?_uniq.113 ?_uniq.112} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HPow.hPow.{?_uniq.117 ?_uniq.116 ?_uniq.115} Nat Nat Nat (Monoid.HPow.{?_uniq.266} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) A (OfNat.ofNat.{?_uniq.116} Nat 2 (instOfNatNat 2))) (HPow.hPow.{?_uniq.143 ?_uniq.142 ?_uniq.141} Nat Nat Nat (Monoid.HPow.{?_uniq.327} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) b (OfNat.ofNat.{?_uniq.142} Nat 2 (instOfNatNat 2)))) P)))"
      },
      {
        "success": true,
        "statement": "theorem Nat.Prime.sq_add_sq_mod_four{P : ℕ} [Fact (Nat.Prime P)] (h : P % 4 = 3) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ",
        "code": "forall {P : Nat} [inst._@._hyg.7 : Fact (Nat.Prime P)], (Eq.{?_uniq.8} Nat (HMod.hMod.{?_uniq.11 ?_uniq.10 ?_uniq.9} Nat Nat Nat (instHMod.{?_uniq.81} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.10} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{?_uniq.44} Nat 3 (instOfNatNat 3))) -> (Exists.{?_uniq.102} Nat (fun (A : Nat) => Exists.{?_uniq.106} Nat (fun (b : Nat) => Eq.{?_uniq.110} Nat (HAdd.hAdd.{?_uniq.113 ?_uniq.112 ?_uniq.111} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HPow.hPow.{?_uniq.116 ?_uniq.115 ?_uniq.114} Nat Nat Nat (Monoid.HPow.{?_uniq.265} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) A (OfNat.ofNat.{?_uniq.115} Nat 2 (instOfNatNat 2))) (HPow.hPow.{?_uniq.142 ?_uniq.141 ?_uniq.140} Nat Nat Nat (Monoid.HPow.{?_uniq.326} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) b (OfNat.ofNat.{?_uniq.141} Nat 2 (instOfNatNat 2)))) P)))"
      }
    ],
    "number-parsed": 4,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "fermat_two_square",
      "search_time": "1.5988156869716477",
      "ret-prompts": [
        {
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
          "sim_score": "0.6522289514541626",
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**."
        },
        {
          "statement": "theorem nat.sum_four_squares (n : ℕ) : ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n",
          "sim_score": "0.5913749933242798",
          "doc_string": "**Four squares theorem**"
        },
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.49175825715065",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        },
        {
          "statement": "theorem nat.min_fac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) : n.min_fac ^ 2 ≤ n",
          "sim_score": "0.48426979780197144",
          "doc_string": "The square of the smallest prime factor of a composite number `n` is at most `n`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.sq_add_sq{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \"**Four squares theorem**\" Translate the natural language version to a Lean mathlib version:\n theorem nat.sum_four_squares(n : ℕ) :\n∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"The square of the smallest prime factor of a composite number `n` is at most `n`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.min_fac_sq_le_self{n : ℕ} (w : 0 < n) (h : ¬nat.prime n) :\nn.min_fac ^ 2 ≤ n := \n\nNatural language version: \"Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
      "codex_time": "8.808033049979713"
    },
    "grouped": [
      [
        "theorem Nat.Prime.sum_two_squares{P : ℕ} [Fact (Nat.Prime P)] (h : P % 4 = 3) :\n∃ (x y : ℕ), P = x ^ 2 + y ^ 2 "
      ],
      [
        "theorem Nat.Prime.eq_four_mod_four_add_one{P : ℕ} [Fact (Nat.Prime P)] :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ↔ P % 4 = 1 "
      ],
      [
        "theorem Nat.Prime.sq_add_sq_iff{P : ℕ} [Fact (Nat.Prime P)] :\nP % 4 = 1 ↔ ∃ (A b : ℕ), A ^ 2 + b ^ 2 = P "
      ],
      [
        "theorem Nat.Prime.sq_add_sq_mod_four{P : ℕ} [Fact (Nat.Prime P)] (h : P % 4 = 3) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem fermat_two_square : ∀ p : ℕ, Prime p → (p % 4 = 1) → ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "
  },
  {
    "parsed": [
      "theorem euclidean_plane.alternatives_mem_closure_of_mem_interior {s : set ℝ^2} {x y : ℝ^2} (h1 : x ∈ Interior s) (h2 : y ∈ Interior s) (h3 : x ≠ y) :\n  x ∈ Closure s ↔ y ∈ Closure s "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem segment_subset_of_exists_mem₂{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] (e₁ e₂ : E) {s₁ s₂ : set E} (h₁ : e₁ ∈ s₁) (h₂ : e₂ ∈ s₂) (h : s₁ ∩ s₂ = ∅) :\n ∃(R : ℝ), ∃(e : E × E),\nSegment R e₁ e₂ ⊆",
        "parse-message": "<input>:3:17: unexpected end of input"
      },
      {
        "success": true,
        "statement": "theorem euclidean_plane.alternatives_mem_closure_of_mem_interior {s : set ℝ^2} {x y : ℝ^2} (h1 : x ∈ Interior s) (h2 : y ∈ Interior s) (h3 : x ≠ y) :\n  x ∈ Closure s ↔ y ∈ Closure s ",
        "code": "forall {s : HPow.hPow.{?_uniq.4 ?_uniq.3 ?_uniq.2} (?_uniq.12 PUnit.{2}) ?_uniq.30 Sort.{?_uniq.1} ?_uniq.8 (MonadStateOf.set.{?_uniq.10 ?_uniq.9} Type ?_uniq.12 ?_uniq.13 Real) (OfNat.ofNat.{?_uniq.3} ?_uniq.30 2 ?_uniq.31)} {x : HPow.hPow.{?_uniq.51 ?_uniq.50 ?_uniq.49} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.50} (?_uniq.1247 s) 2 (?_uniq.1249 s))} {y : HPow.hPow.{?_uniq.79 ?_uniq.78 ?_uniq.77} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s))} (h1 : Membership.mem.{?_uniq.107 ?_uniq.106} (HPow.hPow.{1 ?_uniq.50 succ ?_uniq.107} Type (?_uniq.1247 s) Type.{?_uniq.107} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.50} (?_uniq.1247 s) 2 (?_uniq.1249 s))) (Set.{?_uniq.107} (HPow.hPow.{1 ?_uniq.50 succ ?_uniq.107} Type (?_uniq.1247 s) Type.{?_uniq.107} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.50} (?_uniq.1247 s) 2 (?_uniq.1249 s)))) (Set.instMembershipSet.{?_uniq.107} (HPow.hPow.{1 ?_uniq.50 succ ?_uniq.107} Type (?_uniq.1247 s) Type.{?_uniq.107} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.50} (?_uniq.1247 s) 2 (?_uniq.1249 s)))) x (Interior.{?_uniq.117} (HPow.hPow.{1 ?_uniq.50 succ ?_uniq.107} Type (?_uniq.1247 s) Type.{?_uniq.107} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.50} (?_uniq.1247 s) 2 (?_uniq.1249 s))) (?_uniq.1250 s x y) (?_uniq.1251 s x y))) (h2 : Membership.mem.{?_uniq.390 ?_uniq.389} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s))) (Set.{?_uniq.390} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s)))) (Set.instMembershipSet.{?_uniq.390} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s)))) y (Interior.{?_uniq.400} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s))) (?_uniq.1253 s x y h1) (?_uniq.1255 s x y h1))) (h3 : Ne.{?_uniq.666} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s))) x y), Iff (Membership.mem.{?_uniq.682 ?_uniq.681} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s))) (Set.{?_uniq.390} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s)))) (Set.instMembershipSet.{?_uniq.390} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s)))) x (Closure.{?_uniq.686} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s))) (?_uniq.1259 s x y h1 h2 h3) (?_uniq.1263 s x y h1 h2 h3))) (Membership.mem.{?_uniq.945 ?_uniq.944} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s))) (Set.{?_uniq.390} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s)))) (Set.instMembershipSet.{?_uniq.390} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s)))) y (Closure.{?_uniq.949} (HPow.hPow.{1 ?_uniq.78 succ ?_uniq.390} Type (?_uniq.1247 s) Type.{?_uniq.390} (?_uniq.1248 s) Real (OfNat.ofNat.{?_uniq.78} (?_uniq.1247 s) 2 (?_uniq.1249 s))) (?_uniq.1267 s x y h1 h2 h3) (?_uniq.1271 s x y h1 h2 h3)))"
      },
      {
        "success": false,
        "statement": "theorem is_o_plane.segment_of_mem_set_ne{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [add_comm_group E] [is_o_plane E] {s : set E} (hs : is_o_plane s) {x : E} (hx : x ∈ s) {y : E} (hy : y ∈ s) (h : dis (x - y) = 1) (hne : x ≠ y) :\nSegment ℝ x y ⊆ s ",
        "parse-message": "unknown identifier 'add_comm_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem borsuk_ulam_closed_unit_interval{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] [EuclideanSpace E] {s : set E} {x y : E} :\n∃ z z' : E, x ∈ z ∧ z' ∈ y ∧ dist ℝ z z' = 1 ∧ (z ∈ s ↔ z' ∈ s) ",
        "parse-message": "failed to synthesize instance\n  IsROrC E (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem segment_subset_of_subset_compl{E : Type u_2} [EuclideanSpace E] [NormedGroup E] [NormedSpace ℝ E] {s : set E} {x y : E} (hs : s ⊆ set.Univ \\ s) (h : ∀ z ∈ Segment ℝ x y, z ∈ s) :\nset.distance_between x y = (7 * set.length x y) / 6 ",
        "parse-message": "failed to synthesize instance\n  IsROrC E (during elaboration)"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "unit_line_in_or_out_of_euclidean_plane_subset",
      "search_time": "1.5133282099850476",
      "ret-prompts": [
        {
          "statement": "theorem convex.add_smul_sub_mem_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s",
          "sim_score": "0.5471247434616089",
          "doc_string": "If `x ∈ s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`."
        },
        {
          "statement": "theorem open_segment_subset_ball_of_ne {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) : open_segment ℝ x y ⊆ metric.ball z r",
          "sim_score": "0.5154375433921814",
          "doc_string": " If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is included in the corresponding open ball."
        },
        {
          "statement": "theorem mem_tangent_cone_of_segment_subset {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : segment ℝ x y ⊆ s) : y - x ∈ tangent_cone_at ℝ s x",
          "sim_score": "0.5063760280609131",
          "doc_string": " If a subset of a real vector space contains a segment, then the direction of this segment belongs to the tangent cone at its endpoints."
        },
        {
          "statement": "theorem convex.add_smul_sub_mem_interior' {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s",
          "sim_score": "0.5046789050102234",
          "doc_string": "If `x ∈ closure s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If `x ∈ s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.\" Translate the natural language version to a Lean mathlib version:\n theorem convex.add_smul_sub_mem_interior{E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) :\nx + t • (y - x) ∈ interior s := \n\nNatural language version: \" If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is included in the corresponding open ball.\" Translate the natural language version to a Lean mathlib version:\n theorem open_segment_subset_ball_of_ne{E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) :\nopen_segment ℝ x y ⊆ metric.ball z r := \n\nNatural language version: \" If a subset of a real vector space contains a segment, then the direction of this segment belongs to the tangent cone at its endpoints.\" Translate the natural language version to a Lean mathlib version:\n theorem mem_tangent_cone_of_segment_subset{G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : segment ℝ x y ⊆ s) :\ny - x ∈ tangent_cone_at ℝ s x := \n\nNatural language version: \"If `x ∈ closure s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.\" Translate the natural language version to a Lean mathlib version:\n theorem convex.add_smul_sub_mem_interior'{E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) :\nx + t • (y - x) ∈ interior s := \n\nNatural language version: \"For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
      "codex_time": "9.36085066999658"
    },
    "grouped": [
      [
        "theorem euclidean_plane.alternatives_mem_closure_of_mem_interior {s : set ℝ^2} {x y : ℝ^2} (h1 : x ∈ Interior s) (h2 : y ∈ Interior s) (h3 : x ≠ y) :\n  x ∈ Closure s ↔ y ∈ Closure s "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem unit_line_in_or_out_of_euclidean_plane_subset : ∀ (S : Set $ EuclideanSpace ℝ (Finₓ 2)), ∃ (x y : EuclideanSpace ℝ (Finₓ 2)), (∥x - y∥ = (1 : ℝ)) → (x ∈ S ∧ y ∈ S) ∨ (x ∉ S ∧ y ∉ S) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem add_idem.is_comm{R : Type u} [Semiring R] (h : ∀ x : R, add_idem x) :\ncomm_ring R ",
        "parse-message": "unknown identifier 'add_idem' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem non_comm_ring_with_idempotent.is_comm{R : Type u} [Ring R] {h : ∀ (x : R), x * x = x} :\ncomm_ring R ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem idempotent_ring.is_comm{R : Type u} [Ring R] (h : ∀ (x : R), x * x = x)\n:\ncomm_ring R ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem idempotent_is_comm_ring{R : Type u} [Ring R] (h : (∀ (x : R), x ^ 2 = \nx)) :\ncomm_ring R ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem idem_ring.comm_ring{R : Type u} [Ring R] (h : ∀ R ∈ R, R^2 = R) :\ncomm_ring R ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "all_idempotent_implies_commutative",
      "search_time": "1.4921700999839231",
      "ret-prompts": [
        {
          "statement": "theorem is_ring_hom.id {α : Type u} [ring α] : is_ring_hom id",
          "sim_score": "0.6198770999908447",
          "doc_string": "The identity map is a ring homomorphism."
        },
        {
          "statement": "theorem subalgebra.mul_self {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : S.to_submodule * S.to_submodule = S.to_submodule",
          "sim_score": "0.6067196130752563",
          "doc_string": "As submodules, subalgebras are idempotent."
        },
        {
          "statement": "theorem subring.ext {R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T",
          "sim_score": "0.5843548774719238",
          "doc_string": "Two subrings are equal if they have the same elements."
        },
        {
          "statement": "theorem add_con.add_con_gen_idem {M : Type u_1} [has_add M] (r : M → M → Prop) : add_con_gen ⇑(add_con_gen r) = add_con_gen r",
          "sim_score": "0.5717903971672058",
          "doc_string": "The map sending a binary relation to the smallest additive congruence relation in which it is contained is idempotent."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The identity map is a ring homomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem is_ring_hom.id{α : Type u} [ring α] :\nis_ring_hom id := \n\nNatural language version: \"As submodules, subalgebras are idempotent.\" Translate the natural language version to a Lean mathlib version:\n theorem subalgebra.mul_self{R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) :\nS.to_submodule * S.to_submodule = S.to_submodule := \n\nNatural language version: \"Two subrings are equal if they have the same elements.\" Translate the natural language version to a Lean mathlib version:\n theorem subring.ext{R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) :\nS = T := \n\nNatural language version: \"The map sending a binary relation to the smallest additive congruence relation in which it is contained is idempotent.\" Translate the natural language version to a Lean mathlib version:\n theorem add_con.add_con_gen_idem{M : Type u_1} [has_add M] (r : M → M → Prop) :\nadd_con_gen ⇑(add_con_gen r) = add_con_gen r := \n\nNatural language version: \"A ring with all elements idempotent is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A ring with all elements idempotent is commutative.",
      "codex_time": "7.338132099976065"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem all_idempotent_implies_commutative {R : Type _} [Ring R] : (∀ x : R, x * x = 1) → CommRing R "
  },
  {
    "parsed": [
      "theorem Nat.exists_infinite_twin_primes : ∃ (P : ℕ), ∃ (Q : ℕ), P < Q ∧ Nat.Prime P ∧ Nat.Prime Q ∧ Q - P = 2 ",
      "theorem Nat.prime_twin_pair_inf :\n∀ (n : ℕ), ∃ (P : ℕ), n ≤ P ∧ Nat.Prime P ∧ ∃ (P' : ℕ), P' = P + 2 ∧ Nat.Prime P' ",
      "theorem Nat.exists_infinite_primes_diff_two :\n∃ (P : ℕ), Nat.Prime P ∧ Nat.Prime (P + 2) ",
      "theorem have_infinite_two_between_primes :\n∀ (n : ℕ), ∃ (P : ℕ), (n ≤ P ∧ Nat.Prime P) ∧ ∃ (Q : ℕ), (P + 2 ≤ Q ∧ Nat.Prime Q) "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "theorem Nat.exists_infinite_twin_primes : ∃ (P : ℕ), ∃ (Q : ℕ), P < Q ∧ Nat.Prime P ∧ Nat.Prime Q ∧ Q - P = 2 ",
        "code": "Exists.{?_uniq.1} ?_uniq.2 (fun (P : Nat) => Exists.{?_uniq.5} Nat (fun (Q : Nat) => And (LT.lt.{?_uniq.9} Nat Nat.hasLt P Q) (And (Nat.Prime P) (And (Nat.Prime Q) (Eq.{?_uniq.16} Nat (HSub.hSub.{?_uniq.19 ?_uniq.18 ?_uniq.17} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) Q P) (OfNat.ofNat.{?_uniq.22} Nat 2 (instOfNatNat 2)))))))"
      },
      {
        "success": true,
        "statement": "theorem Nat.prime_twin_pair_inf :\n∀ (n : ℕ), ∃ (P : ℕ), n ≤ P ∧ Nat.Prime P ∧ ∃ (P' : ℕ), P' = P + 2 ∧ Nat.Prime P' ",
        "code": "forall (n : Nat), Exists.{?_uniq.4} Nat (fun (P : Nat) => And (LE.le.{?_uniq.8} Nat Nat.hasLe n P) (And (Nat.Prime P) (Exists.{?_uniq.15} Nat (fun (P' : Nat) => And (Eq.{?_uniq.19} Nat P' (HAdd.hAdd.{?_uniq.22 ?_uniq.21 ?_uniq.20} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P (OfNat.ofNat.{?_uniq.25} Nat 2 (instOfNatNat 2)))) (Nat.Prime P')))))"
      },
      {
        "success": false,
        "statement": "theorem Nat.exists_infinite_pairs_of_primes_diff_by_two :\n∃ (P : ℕ), Nat.Prime P ∧ P + 2 ∈ Nat.Primes ",
        "parse-message": "failed to synthesize instance\n  Membership ℕ Type (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Nat.exists_infinite_primes_diff_two :\n∃ (P : ℕ), Nat.Prime P ∧ Nat.Prime (P + 2) ",
        "code": "Exists.{?_uniq.1} ?_uniq.2 (fun (P : Nat) => And (Nat.Prime P) (Nat.Prime (HAdd.hAdd.{?_uniq.7 ?_uniq.6 ?_uniq.5} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P (OfNat.ofNat.{?_uniq.10} Nat 2 (?_uniq.48 P)))))"
      },
      {
        "success": true,
        "statement": "theorem have_infinite_two_between_primes :\n∀ (n : ℕ), ∃ (P : ℕ), (n ≤ P ∧ Nat.Prime P) ∧ ∃ (Q : ℕ), (P + 2 ≤ Q ∧ Nat.Prime Q) ",
        "code": "forall (n : Nat), Exists.{?_uniq.4} Nat (fun (P : Nat) => And (And (LE.le.{?_uniq.8} Nat Nat.hasLe n P) (Nat.Prime P)) (Exists.{?_uniq.15} Nat (fun (Q : Nat) => And (LE.le.{?_uniq.19} Nat Nat.hasLe (HAdd.hAdd.{?_uniq.22 ?_uniq.21 ?_uniq.20} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P (OfNat.ofNat.{?_uniq.25} Nat 2 (instOfNatNat 2))) Q) (Nat.Prime Q))))"
      }
    ],
    "number-parsed": 4,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "twin_prime_conjecture",
      "search_time": "1.480321854003705",
      "ret-prompts": [
        {
          "statement": "theorem nat.exists_prime_ge_modeq_one {k : ℕ} (n : ℕ) (hpos : 0 < k) : ∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k]",
          "sim_score": "0.53578782081604",
          "doc_string": "For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`."
        },
        {
          "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p",
          "sim_score": "0.525439977645874",
          "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`."
        },
        {
          "statement": "theorem ordinal.infinite_pigeonhole {β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β) (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) : ∃ (a : α), cardinal.mk ↥(f ⁻¹' {a}) = cardinal.mk β",
          "sim_score": "0.5173879861831665",
          "doc_string": "The infinite pigeonhole principle"
        },
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.48807522654533386",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.exists_prime_ge_modeq_one{k : ℕ} (n : ℕ) (hpos : 0 < k) :\n∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k] := \n\nNatural language version: \" Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.exists_infinite_primes(n : ℕ) :\n∃ (p : ℕ), n ≤ p ∧ nat.prime p := \n\nNatural language version: \"The infinite pigeonhole principle\" Translate the natural language version to a Lean mathlib version:\n theorem ordinal.infinite_pigeonhole{β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β) (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) :\n∃ (a : α), cardinal.mk ↥(f ⁻¹' {a}) = cardinal.mk β := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"There are infinitely many pairs of primes that differ exactly by two.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "There are infinitely many pairs of primes that differ exactly by two.",
      "codex_time": "9.010696814977564"
    },
    "grouped": [
      [
        "theorem Nat.exists_infinite_twin_primes : ∃ (P : ℕ), ∃ (Q : ℕ), P < Q ∧ Nat.Prime P ∧ Nat.Prime Q ∧ Q - P = 2 "
      ],
      [
        "theorem Nat.prime_twin_pair_inf :\n∀ (n : ℕ), ∃ (P : ℕ), n ≤ P ∧ Nat.Prime P ∧ ∃ (P' : ℕ), P' = P + 2 ∧ Nat.Prime P' "
      ],
      [
        "theorem Nat.exists_infinite_primes_diff_two :\n∃ (P : ℕ), Nat.Prime P ∧ Nat.Prime (P + 2) "
      ],
      [
        "theorem have_infinite_two_between_primes :\n∀ (n : ℕ), ∃ (P : ℕ), (n ≤ P ∧ Nat.Prime P) ∧ ∃ (Q : ℕ), (P + 2 ≤ Q ∧ Nat.Prime Q) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem twin_prime_conjecture : ∀ n : ℕ, ∃ p : ℕ, p > n → Prime p → Prime (p + 2) "
  },
  {
    "parsed": [
      "theorem FiniteDimensional.field_of_division_ring(K : Type u) [DivisionRing K] (h : FiniteDimensional K K) :\nField K "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem FiniteDimensional.field(K : Type u) [Ring K] [FiniteDimensional K K] [DivisionRing K] :\nfield K ",
        "parse-message": "failed to synthesize instance\n  DivisionRing K (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem DivisionRing.field(K : Type u) [DivisionRing K] (h :  \nNat.Prime (FiniteDimensional.finrank K K)) :\nfield K ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem finite_division_ring.field {K : Type u} [finite_division_ring K] :\nfield K ",
        "parse-message": "unknown identifier 'finite_division_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem fincard.division_ring_iff_field(K : Type u) [DivisionRing K] [h : Fintype K] :\nFiniteDimensional.finrank K K = 1 → field K ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem FiniteDimensional.field_of_division_ring(K : Type u) [DivisionRing K] (h : FiniteDimensional K K) :\nField K ",
        "code": "forall (K : Type.{u}) [inst._@._hyg.5 : DivisionRing.{?_uniq.5} K], (FiniteDimensional.{?_uniq.10 ?_uniq.9} K K inst._@._hyg.5 (LieRing.toAddCommGroup.{u} K (LieRing.ofAssociativeRing.{u} K (DivisionRing.toRing.{u} K inst._@._hyg.5))) (Semiringₓ.toModule.{u} K (Ringₓ.toSemiring.{u} K (DivisionRing.toRing.{u} K inst._@._hyg.5)))) -> (Field.{?_uniq.426} K)"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "fin_div_ring_is_field",
      "search_time": "1.61453294500825",
      "ret-prompts": [
        {
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s",
          "sim_score": "0.6756068468093872",
          "doc_string": "A subfield is closed under division."
        },
        {
          "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1",
          "sim_score": "0.6545361280441284",
          "doc_string": "A division_ring is one-dimensional as a vector space over itself."
        },
        {
          "statement": "theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S",
          "sim_score": "0.6345528364181519",
          "doc_string": "An intermediate field is closed under division."
        },
        {
          "statement": "theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s",
          "sim_score": "0.62082839012146",
          "doc_string": "A subfield is closed under multiplication."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.div_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"A division_ring is one-dimensional as a vector space over itself.\" Translate the natural language version to a Lean mathlib version:\n theorem finite_dimensional.finrank_self(K : Type u) [division_ring K] :\nfinite_dimensional.finrank K K = 1 := \n\nNatural language version: \"An intermediate field is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem intermediate_field.div_mem{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} :\nx ∈ S → y ∈ S → x / y ∈ S := \n\nNatural language version: \"A subfield is closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.mul_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x * y ∈ s := \n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite division ring is a field.",
      "codex_time": "3.585240865009837"
    },
    "grouped": [
      [
        "theorem FiniteDimensional.field_of_division_ring(K : Type u) [DivisionRing K] (h : FiniteDimensional K K) :\nField K "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem fin_div_ring_is_field {R : Type _} [DivisionRing R] [Finite R] : Field R "
  },
  {
    "parsed": [
      "theorem Real.mul_le_sqr_pos{A b : ℝ} : \n0 < A → 0 < b → A * b ≤ (A + b) ^ 2 ",
      "theorem Real.prod_le_avg_sq{A b : ℝ} (wa : 0 < A) (wb : 0 < b) :\nA * b ≤ (A + b) ^ 2 / 4 ",
      "theorem Real.product_le_average(A b : Nnreal) :\nA * b ≤ (A+b)/2 "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "theorem Real.mul_le_sqr_pos{A b : ℝ} : \n0 < A → 0 < b → A * b ≤ (A + b) ^ 2 ",
        "code": "forall {A : Real} {b : Real}, (LT.lt.{?_uniq.7} Real Real.hasLt (OfNat.ofNat.{?_uniq.10} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) A) -> (LT.lt.{?_uniq.58} Real Real.hasLt (OfNat.ofNat.{?_uniq.61} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) b) -> (LE.le.{?_uniq.83} Real Real.hasLe (HMul.hMul.{?_uniq.86 ?_uniq.85 ?_uniq.84} Real Real Real (instHMul.{0} Real Real.hasMul) A b) (HPow.hPow.{?_uniq.89 ?_uniq.88 ?_uniq.87} Real Nat Real (instHPow.{0 0} Real Nat (Monoidₓ.hasPow.{0} Real Real.monoid)) (HAdd.hAdd.{?_uniq.96 ?_uniq.95 ?_uniq.94} Real Real Real (instHAdd.{0} Real Real.hasAdd) A b) (OfNat.ofNat.{?_uniq.88} Nat 2 (instOfNatNat 2))))"
      },
      {
        "success": false,
        "statement": "theorem Real.two_mul_le_two_sqr(R s : ℝ) (h₀ : 0 < R) (h₁ : 0 < s) :\nR * s ≤ (R + s) / 2 * (R + s) ",
        "parse-message": "elaboration function for 'Parser.Tactic.Localized.«term_*»' has not been implemented\n  2* (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Real.prod_le_avg_sq{A b : ℝ} (wa : 0 < A) (wb : 0 < b) :\nA * b ≤ (A + b) ^ 2 / 4 ",
        "code": "forall {A : Real} {b : Real} (wa : LT.lt.{?_uniq.7} Real Real.hasLt (OfNat.ofNat.{?_uniq.10} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) A) (wb : LT.lt.{?_uniq.59} Real Real.hasLt (OfNat.ofNat.{?_uniq.62} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) b), LE.le.{?_uniq.85} Real Real.hasLe (HMul.hMul.{?_uniq.88 ?_uniq.87 ?_uniq.86} Real Real Real (instHMul.{0} Real Real.hasMul) A b) (HDiv.hDiv.{?_uniq.91 ?_uniq.90 ?_uniq.89} Real Real Real (instHDiv.{0} Real (DivInvMonoidₓ.toHasDiv.{0} Real (Field.toDivInvMonoid.{0} Real Real.field))) (HPow.hPow.{?_uniq.94 ?_uniq.93 ?_uniq.92} Real Nat Real (instHPow.{0 0} Real Nat (Monoidₓ.hasPow.{0} Real Real.monoid)) (HAdd.hAdd.{?_uniq.101 ?_uniq.100 ?_uniq.99} Real Real Real (instHAdd.{0} Real Real.hasAdd) A b) (OfNat.ofNat.{?_uniq.93} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.149} Real 4 (?_uniq.509 A b wa wb)))"
      },
      {
        "success": true,
        "statement": "theorem Real.product_le_average(A b : Nnreal) :\nA * b ≤ (A+b)/2 ",
        "code": "forall (A : Nnreal) (b : Nnreal), LE.le.{?_uniq.6} Nnreal (Preorderₓ.toHasLe.{0} Nnreal (PartialOrderₓ.toPreorder.{0} Nnreal (OrderedCancelAddCommMonoid.toPartialOrder.{0} Nnreal (OrderedSemiring.toOrderedCancelAddCommMonoid.{0} Nnreal Nnreal.orderedSemiring)))) (HMul.hMul.{?_uniq.9 ?_uniq.8 ?_uniq.7} Nnreal Nnreal Nnreal (instHMul.{0} Nnreal (Distribₓ.toHasMul.{0} Nnreal (NonUnitalNonAssocSemiringₓ.toDistrib.{0} Nnreal (NonAssocSemiringₓ.toNonUnitalNonAssocSemiring.{0} Nnreal (Semiringₓ.toNonAssocSemiring.{0} Nnreal (OrderedSemiring.toSemiring.{0} Nnreal Nnreal.orderedSemiring)))))) A b) (HDiv.hDiv.{?_uniq.12 ?_uniq.11 ?_uniq.10} Nnreal Nnreal Nnreal (instHDiv.{0} Nnreal Nnreal.hasDiv) (HAdd.hAdd.{?_uniq.15 ?_uniq.14 ?_uniq.13} Nnreal Nnreal Nnreal (instHAdd.{0} Nnreal (Distribₓ.toHasAdd.{0} Nnreal (NonUnitalNonAssocSemiringₓ.toDistrib.{0} Nnreal (NonAssocSemiringₓ.toNonUnitalNonAssocSemiring.{0} Nnreal (Semiringₓ.toNonAssocSemiring.{0} Nnreal (OrderedSemiring.toSemiring.{0} Nnreal Nnreal.orderedSemiring)))))) A b) (OfNat.ofNat.{?_uniq.18} Nnreal 2 (?_uniq.1071 A b)))"
      },
      {
        "success": false,
        "statement": "theorem Real.LE.Mul{A b : ℝ} (ha : 0 < A) (hb : 0 < b) : \nA * b ≤ (A + b) / 2 * (A + b) / 2 ",
        "parse-message": "elaboration function for 'Parser.Tactic.Localized.«term_*»' has not been implemented\n  2* (during elaboration)"
      }
    ],
    "number-parsed": 3,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "am_gm_ineq",
      "search_time": "1.4299069349945057",
      "ret-prompts": [
        {
          "statement": "theorem nnreal.geom_mean_le_arith_mean2_weighted (w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂",
          "sim_score": "0.5334862470626831",
          "doc_string": " The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers."
        },
        {
          "statement": "theorem nat.min_fac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) : n.min_fac ^ 2 ≤ n",
          "sim_score": "0.5259432196617126",
          "doc_string": "The square of the smallest prime factor of a composite number `n` is at most `n`."
        },
        {
          "statement": "theorem real.geom_mean_le_arith_mean_weighted {ι : Type u} (s : finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) : s.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i)",
          "sim_score": "0.5007948279380798",
          "doc_string": " AM-GM inequality: the **geometric mean is less than or equal to the arithmetic mean**, weighted version for real-valued nonnegative functions."
        },
        {
          "statement": "theorem real.nat_sqrt_le_real_sqrt {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a",
          "sim_score": "0.4941546320915222",
          "doc_string": "The natural square root is at most the real square root"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem nnreal.geom_mean_le_arith_mean2_weighted(w₁ w₂ p₁ p₂ : nnreal) :\nw₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂ := \n\nNatural language version: \"The square of the smallest prime factor of a composite number `n` is at most `n`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.min_fac_sq_le_self{n : ℕ} (w : 0 < n) (h : ¬nat.prime n) :\nn.min_fac ^ 2 ≤ n := \n\nNatural language version: \" AM-GM inequality: the **geometric mean is less than or equal to the arithmetic mean**, weighted version for real-valued nonnegative functions.\" Translate the natural language version to a Lean mathlib version:\n theorem real.geom_mean_le_arith_mean_weighted{ι : Type u} (s : finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) :\ns.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i) := \n\nNatural language version: \"The natural square root is at most the real square root\" Translate the natural language version to a Lean mathlib version:\n theorem real.nat_sqrt_le_real_sqrt{a : ℕ} :\n↑(nat.sqrt a) ≤ real.sqrt ↑a := \n\nNatural language version: \"The product of two positive numbers is at most the square of their average.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of two positive numbers is at most the square of their average.",
      "codex_time": "5.2238901399832685"
    },
    "grouped": [
      [
        "theorem Real.mul_le_sqr_pos{A b : ℝ} : \n0 < A → 0 < b → A * b ≤ (A + b) ^ 2 "
      ],
      [
        "theorem Real.prod_le_avg_sq{A b : ℝ} (wa : 0 < A) (wb : 0 < b) :\nA * b ≤ (A + b) ^ 2 / 4 "
      ],
      [
        "theorem Real.product_le_average(A b : Nnreal) :\nA * b ≤ (A+b)/2 "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem am_gm_ineq : ∀ (a b : ℝ), a > 0 → b > 0 → a * b ≤ ((a + b)/(1 + 1))^2 "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Configuration.no_lines.exists_collinear_two{k : Type u_1} {P : Type u_2} [DivisionRing k] [add_comm_group k] [module k V] {V : Type u_3} [add_comm_group V] [vector_space k V] [AddTorsor V P] [Configuration P V] (hP : ¬ ∀ (P1 P2 : P), P1 ∈ (Collinear k {P2})) :\n∃ (c P1 P2 : P), P1 ≠ P2 ∧ Collinear k {P1, P2}",
        "parse-message": "unknown identifier 'add_comm_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Configuration.on_plane.exists_line_of_card_ge_three(P : Type u) [HasMem P line] [Configuration.on_plane Circle P] [Fintype P] [Configuration.Nondegenerate (Nonempty P) line] (h : Fintype.Card P ≥ 3) :\n∃ (l : line), l ∩ P = ⊥ ",
        "parse-message": "unknown identifier 'line' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Configuration.Nondegenerate.has_two(P : fin_set ℝ²) (h : is_nondegenerate P) :\n∃ (l : fin_set ℝ), l ∉ P ∧ ∃ (P Q : ℝ), l ⊆ {P, Q} ∧ Fintype.Card l = 2 ",
        "parse-message": "<input>:1:57: expected token"
      },
      {
        "success": false,
        "statement": "theorem Configuration.linear_pair_lemma(P : Type u_1) [HasMem P (aff_pt (aff_str ℤ 3))] [Fintype P] [OrderedRing α] [add_comm_group (aff_pt (aff_str ℤ 3))] [vector_space α (aff_pt (aff_str ℤ 3))] [aff_pt (aff_str ℤ 3) : HasScalar α] [aff_pt (aff_str ℤ 3) : is_basis.{u_1 u_2} (aff_pt (aff_str ℤ 3)) α] [",
        "parse-message": "<input>:1:218: expected ']'"
      },
      {
        "success": false,
        "statement": "theorem picard_1_eg(V : Type u_1) {P : Type u_2} [t ℝ] [AddTorsor ℝ V] [HasMem V P] [DecidableEQ P] [Finite V] [Finite P] (h_coplanar : ∀ (P Q R : P) (v : V), R ∈ P ⟶ᵇ v ∧ R ∉ P ⟶ᵇ v → P = Q) (h_not_all_on_line : ∃ (P Q : P), P ≠ Q) :\n∃ (P Q : P) (v : V),",
        "parse-message": "<input>:1:166: expected token"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "sylvester_gallai",
      "search_time": "1.4894644650048576",
      "ret-prompts": [
        {
          "statement": "theorem collinear_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : collinear k {p}",
          "sim_score": "0.5291177034378052",
          "doc_string": "A single point is collinear."
        },
        {
          "statement": "theorem configuration.nondegenerate.exists_injective_of_card_le {P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ≤ fintype.card P) : ∃ (f : L → P), function.injective f ∧ ∀ (l : L), f l ∉ l",
          "sim_score": "0.5157747268676758",
          "doc_string": "If a nondegenerate configuration has at least as many points as lines, then there exists  an injective function `f` from lines to points, such that `f l` does not lie on `l`."
        },
        {
          "statement": "theorem configuration.has_points.card_le (P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L ≤ fintype.card P",
          "sim_score": "0.5101643800735474",
          "doc_string": "If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`."
        },
        {
          "statement": "theorem configuration.has_lines.card_le (P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P ≤ fintype.card L",
          "sim_score": "0.500416100025177",
          "doc_string": "If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A single point is collinear.\" Translate the natural language version to a Lean mathlib version:\n theorem collinear_singleton(k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) :\ncollinear k {p} := \n\nNatural language version: \"If a nondegenerate configuration has at least as many points as lines, then there exists  an injective function `f` from lines to points, such that `f l` does not lie on `l`.\" Translate the natural language version to a Lean mathlib version:\n theorem configuration.nondegenerate.exists_injective_of_card_le{P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ≤ fintype.card P) :\n∃ (f : L → P), function.injective f ∧ ∀ (l : L), f l ∉ l := \n\nNatural language version: \"If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`.\" Translate the natural language version to a Lean mathlib version:\n theorem configuration.has_points.card_le(P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] :\nfintype.card L ≤ fintype.card P := \n\nNatural language version: \"If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`.\" Translate the natural language version to a Lean mathlib version:\n theorem configuration.has_lines.card_le(P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] :\nfintype.card P ≤ fintype.card L := \n\nNatural language version: \"In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.",
      "codex_time": "9.957743514009053"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem sylvester_gallai {P L : Type _} [HasMem P L] [Membership P L] [Configuration.Nondegenerate P L] : ∃ (l : L) (p q : P), p ∈ l → q ∈ l → (∀ r : P, r ∈ l → r = p ∨ r = q) "
  },
  {
    "parsed": [
      "theorem Function.Injective.bijective_of_self_injective {α : Type u_1} {β : Type u_2} (F : α → β) :\nFunction.Injective F → ∃ g, Function.Bijective g ",
      "theorem Function.exists_bijective_of_injective_left_inverse{α : Type u} {β : Type v} {F : α → β} {g : β → α} (hf: Function.Injective F) (hg: Function.Injective g) (h : ∀ x, g (F x) = x) :\n∃ (h : α → β), Function.Bijective h ",
      "theorem Function.Embedding.schroeder_bernstein{α : Type u} {β : Type v} {F : α → β} {g : β → α} (hf : Function.Injective F) (hg : Function.Injective g) :\n∃ (h : α → β), Function.Bijective h "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Nonempty.schroeder_bernstein{α : Type u} (β : Nonempty (Type v)) : ∃ (F : α → β.value), Function.Bijective F ",
        "parse-message": "invalid field 'value', the environment does not contain 'Nonempty.value'\n  β\nhas type\n  Nonempty (Type v) (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Function.Injective.bijective_of_self_injective {α : Type u_1} {β : Type u_2} (F : α → β) :\nFunction.Injective F → ∃ g, Function.Bijective g ",
        "code": "forall {α : Type.{u_1}} {β : Type.{u_2}} (F : α -> β), (Function.Injective.{?_uniq.14 ?_uniq.13} α β F) -> (Exists.{?_uniq.21} ((?_uniq.40 α β F) -> (?_uniq.41 α β F)) (fun (g : (?_uniq.40 α β F) -> (?_uniq.41 α β F)) => Function.Bijective.{?_uniq.27 ?_uniq.26} (?_uniq.40 α β F) (?_uniq.41 α β F) g))"
      },
      {
        "success": true,
        "statement": "theorem Function.exists_bijective_of_injective_left_inverse{α : Type u} {β : Type v} {F : α → β} {g : β → α} (hf: Function.Injective F) (hg: Function.Injective g) (h : ∀ x, g (F x) = x) :\n∃ (h : α → β), Function.Bijective h ",
        "code": "forall {α : Type.{u}} {β : Type.{v}} {F : α -> β} {g : β -> α}, (Function.Injective.{?_uniq.19 ?_uniq.18} α β F) -> (Function.Injective.{?_uniq.29 ?_uniq.28} β α g) -> (forall (x : α), Eq.{?_uniq.42} α (g (F x)) x) -> (Exists.{?_uniq.46} (α -> β) (fun (h : α -> β) => Function.Bijective.{?_uniq.54 ?_uniq.53} α β h))"
      },
      {
        "success": true,
        "statement": "theorem Function.Embedding.schroeder_bernstein{α : Type u} {β : Type v} {F : α → β} {g : β → α} (hf : Function.Injective F) (hg : Function.Injective g) :\n∃ (h : α → β), Function.Bijective h ",
        "code": "forall {α : Type.{u}} {β : Type.{v}} {F : α -> β} {g : β -> α}, (Function.Injective.{?_uniq.19 ?_uniq.18} α β F) -> (Function.Injective.{?_uniq.29 ?_uniq.28} β α g) -> (Exists.{?_uniq.37} (α -> β) (fun (h : α -> β) => Function.Bijective.{?_uniq.45 ?_uniq.44} α β h))"
      },
      {
        "success": false,
        "statement": "theorem schroeder_bernstein {α β : Type u} (h1 : α ⟶ β) (h2 : β ⟶ α) (inj₁ : Function.Injective h1) (inj₂ : Function.Injective h2) :\nNonempty (equiv α β) ",
        "parse-message": "unknown identifier 'equiv' (during elaboration)"
      }
    ],
    "number-parsed": 3,
    "number-equivalent": 1,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "cantor_schroeder_bernstein",
      "search_time": "1.443614877993241",
      "ret-prompts": [
        {
          "statement": "theorem function.embedding.schroeder_bernstein {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h",
          "sim_score": "0.648023247718811",
          "doc_string": " **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`."
        },
        {
          "statement": "theorem category_theory.is_iso_iff_bijective {X Y : Type u} (f : X ⟶ Y) : category_theory.is_iso f ↔ function.bijective f",
          "sim_score": "0.617520809173584",
          "doc_string": "A morphism in `Type u` is an isomorphism if and only if it is bijective."
        },
        {
          "statement": "theorem category_theory.equivalence.ess_surj_of_equivalence {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.is_equivalence F] : category_theory.ess_surj F",
          "sim_score": "0.612472414970398",
          "doc_string": "An equivalence is essentially surjective.  See <https://stacks.math.columbia.edu/tag/02C3>."
        },
        {
          "statement": "theorem fintype.card_compl_eq_card_compl {α : Type u_1} [fintype α] (p q : α → Prop) [fintype {x // p x}] [fintype {x // ¬p x}] [fintype {x // q x}] [fintype {x // ¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) : fintype.card {x // ¬p x} = fintype.card {x // ¬q x}",
          "sim_score": "0.6091285347938538",
          "doc_string": "If two subtypes of a fintype have equal cardinality, so do their complements."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.embedding.schroeder_bernstein{α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) :\n∃ (h : α → β), function.bijective h := \n\nNatural language version: \"A morphism in `Type u` is an isomorphism if and only if it is bijective.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.is_iso_iff_bijective{X Y : Type u} (f : X ⟶ Y) :\ncategory_theory.is_iso f ↔ function.bijective f := \n\nNatural language version: \"An equivalence is essentially surjective.  See <https://stacks.math.columbia.edu/tag/02C3>.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.equivalence.ess_surj_of_equivalence{C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.is_equivalence F] :\ncategory_theory.ess_surj F := \n\nNatural language version: \"If two subtypes of a fintype have equal cardinality, so do their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem fintype.card_compl_eq_card_compl{α : Type u_1} [fintype α] (p q : α → Prop) [fintype {x // p x}] [fintype {x // ¬p x}] [fintype {x // q x}] [fintype {x // ¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) :\nfintype.card {x // ¬p x} = fintype.card {x // ¬q x} := \n\nNatural language version: \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
      "codex_time": "10.661786549026147"
    },
    "grouped": [
      [
        "theorem Function.Injective.bijective_of_self_injective {α : Type u_1} {β : Type u_2} (F : α → β) :\nFunction.Injective F → ∃ g, Function.Bijective g "
      ],
      [
        "theorem Function.exists_bijective_of_injective_left_inverse{α : Type u} {β : Type v} {F : α → β} {g : β → α} (hf: Function.Injective F) (hg: Function.Injective g) (h : ∀ x, g (F x) = x) :\n∃ (h : α → β), Function.Bijective h "
      ],
      [
        "theorem Function.Embedding.schroeder_bernstein{α : Type u} {β : Type v} {F : α → β} {g : β → α} (hf : Function.Injective F) (hg : Function.Injective g) :\n∃ (h : α → β), Function.Bijective h "
      ]
    ],
    "equivalent": [
      "theorem Function.Embedding.schroeder_bernstein{α : Type u} {β : Type v} {F : α → β} {g : β → α} (hf : Function.Injective F) (hg : Function.Injective g) :\n∃ (h : α → β), Function.Bijective h "
    ],
    "answer": "theorem cantor_schroeder_bernstein {α β : Type _} (f : α → β) (g : β → α) : Function.Injective f → Function.Injective g → (∃ h : α → β, Function.Bijective h) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem SimpleGraph.no_isolated_points_of_num_common_neighbours_one_imp_num_adj_eq_card_of_ne_one{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj]\n(h : ∀ (v W : V), (G.num_common_neighbours v W) = 1 → (G.num_adj v) = Card (G.neighbours v)) (v W : V) (h : G.num_common_neighbours v W = 1) :\nFalse ",
        "parse-message": "<input>:2:10: expected ')'"
      },
      {
        "success": false,
        "statement": "theorem SimpleGraph.unique_common_neighbour_implies_n1_connectivity{V : Type u} (G : SimpleGraph V) [DecidableRel G.Adj] [Fintype V] : (∀ (A b : V), G.Card {v | v ≠ A ∧ v ≠ b ∧ G.Adj A v ∧ G.Adj b v} = 1) →\n∃ (v : V), ∀ (x : G.vertex_set), x ≠ v → G.Adj v x ",
        "parse-message": "invalid field 'Card', the environment does not contain 'SimpleGraph.Card'\n  G\nhas type\n  SimpleGraph V (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem SimpleGraph.exists_universal_vertex_of_card_three_vertices{V : Type u} (G : SimpleGraph V) (h : G.is_finite ∧ G.num_vertices = 3) : -- Finite Graph G has exactly 3 vertices\n∃ (v : V), ∀ (W : V), W ≠ v → G.Adj v W ",
        "parse-message": "<input>:2:14: expected '_' or identifier"
      },
      {
        "success": false,
        "statement": "theorem SimpleGraph.one_common_neighbour_implies_universal_vertex{V : Type u} (h : SimpleGraph V) [Fintype V] [DecidableRel h.Adj] :\n(∀ (u v : V), u ≠ v → Finset.Card ({W | h.Adj W u ∧ h.Adj W v} ∩ {W | W ≠ u ∧ W ≠ v}) = 1) → ∃ (v : V), (∀ (W : V), h.Adj v W) ",
        "parse-message": "<input>:2:46: expected '}'"
      },
      {
        "success": false,
        "statement": "theorem SimpleGraph.unique_common_neighbour_implies_unique_neighbour{V : Type u} [Fintype V] (G : SimpleGraph V) [Fintype G.EdgeSet] [DecidableRel G.Adj] (h : ∀ (v : V), ∀ (W : V), G.Card (common_neighbours v W) = 1) :\n∃ (v : V), ∀ (W : V), G.Adj v W ",
        "parse-message": "<input>:1:173: expected '_' or identifier"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "graph_unique_common_neighbour_implies_universal_adjacent_vertex",
      "search_time": "1.4880530529771931",
      "ret-prompts": [
        {
          "statement": "theorem simple_graph.adj_iff_exists_edge {V : Type u} (G : simple_graph V) {v w : V} : G.adj v w ↔ v ≠ w ∧ ∃ (e : sym2 V) (H : e ∈ G.edge_set), v ∈ e ∧ w ∈ e",
          "sim_score": "0.5179886817932129",
          "doc_string": "Two vertices are adjacent iff there is an edge between them. The condition `v ≠ w` ensures they are different endpoints of the edge, which is necessary since when `v = w` the existential `∃ (e ∈ G.edge_set), v ∈ e ∧ w ∈ e` is satisfied by every edge incident to `v`."
        },
        {
          "statement": "theorem simple_graph.even_card_odd_degree_vertices {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : even (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card",
          "sim_score": "0.5029463171958923",
          "doc_string": "The handshaking lemma.  See also `simple_graph.sum_degrees_eq_twice_card_edges`."
        },
        {
          "statement": "theorem simple_graph.exists_maximal_degree_vertex {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : ∃ (v : V), G.max_degree = G.degree v",
          "sim_score": "0.4985456168651581",
          "doc_string": "There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as the lemma implies there exists a vertex."
        },
        {
          "statement": "theorem simple_graph.max_degree_le_of_forall_degree_le {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) : G.max_degree ≤ k",
          "sim_score": "0.48896029591560364",
          "doc_string": "In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Two vertices are adjacent iff there is an edge between them. The condition `v ≠ w` ensures they are different endpoints of the edge, which is necessary since when `v = w` the existential `∃ (e ∈ G.edge_set), v ∈ e ∧ w ∈ e` is satisfied by every edge incident to `v`.\" Translate the natural language version to a Lean mathlib version:\n theorem simple_graph.adj_iff_exists_edge{V : Type u} (G : simple_graph V) {v w : V} :\nG.adj v w ↔ v ≠ w ∧ ∃ (e : sym2 V) (H : e ∈ G.edge_set), v ∈ e ∧ w ∈ e := \n\nNatural language version: \"The handshaking lemma.  See also `simple_graph.sum_degrees_eq_twice_card_edges`.\" Translate the natural language version to a Lean mathlib version:\n theorem simple_graph.even_card_odd_degree_vertices{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] :\neven (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card := \n\nNatural language version: \"There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as the lemma implies there exists a vertex.\" Translate the natural language version to a Lean mathlib version:\n theorem simple_graph.exists_maximal_degree_vertex{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] :\n∃ (v : V), G.max_degree = G.degree v := \n\nNatural language version: \"In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree.\" Translate the natural language version to a Lean mathlib version:\n theorem simple_graph.max_degree_le_of_forall_degree_le{V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) :\nG.max_degree ≤ k := \n\nNatural language version: \"A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
      "codex_time": "10.822478272981243"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem graph_unique_common_neighbour_implies_universal_adjacent_vertex {V : Type _} [Finite V] (G : SimpleGraph V) : (∀ v w : V, ∃! x : V, G.Adj v x ∧ G.Adj w x) → (∃ c : V, ∀ v : V, G.Adj c v) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem CliffordAlgebra.odd_partitions_iff_distinct_partitions{R : Type u_1} {Q : QuadraticForm R (CliffordAlgebra Q)} :\nCliffordAlgebra.odd_partitions Q = CliffordAlgebra.distinct_partitions Q ",
        "parse-message": "unknown identifier 'Q' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem partitions.count_distinct_odd_equiv_num_partitions (n : ℕ) :\n(n.count_distinct_odd).Card = (partitions.count_partitions n).Card ",
        "parse-message": "invalid field 'count_distinct_odd', the environment does not contain 'Nat.count_distinct_odd'\n  n\nhas type\n  ℕ (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem gt_0_of_partitions_with_odd_parts_eq_partitions_with_distinct_parts {P : ℕ → ℕ} {Q : ℕ → ℕ} (h : P ∘ (partitions_with_odd_parts) = Q ∘ (partitions_with_distinct_parts)) :\n0 < partitions_with_odd_parts n ",
        "parse-message": "unknown identifier 'partitions_with_odd_parts' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem partitions.partition_alt_equiv_distinct {n : ℕ} :\nBijective (partitions.Partition n).Filter (partitions.distinct) ",
        "parse-message": "unknown identifier 'Bijective' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem natural.Quotient.count_partitions_same_as_distinct{n : ℕ} :\n@Countable.count (Fin n → ℕ) (λ (P1 P2 : Fin n → ℕ), ∃ (F : Subtype.{u_1 u_1} (λ (i : Fin n), i.val < P2 i) → Subtype.{u_2 u_2} (λ (i : Fin n), i.val < P1 i)), (Quotient.formation (λ (i : Fin n), @Nat.lt_trichotomy _ (i.val) (P1 i) (P2",
        "parse-message": "<input>:2:51: expected '=>'"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "partition_odd_distincts",
      "search_time": "1.4321352730039507",
      "ret-prompts": [
        {
          "statement": "theorem finset.sum_cancels_of_partition_cancels {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) : s.sum (λ (x : α), f x) = 0",
          "sim_score": "0.45678937435150146",
          "doc_string": "If we can partition a sum into subsets that cancel out, then the whole sum cancels."
        },
        {
          "statement": "theorem clifford_algebra.odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) : P x hx",
          "sim_score": "0.44783246517181396",
          "doc_string": " To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors."
        },
        {
          "statement": "theorem finset.sum_partition {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] : s.sum (λ (x : α), f x) = (finset.image quotient.mk s).sum (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y))",
          "sim_score": "0.42162370681762695",
          "doc_string": "A sum can be partitioned into a sum of sums, each equivalent under a setoid."
        },
        {
          "statement": "theorem setoid.eqv_classes_disjoint {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) : c.pairwise_disjoint id",
          "sim_score": "0.4164368808269501",
          "doc_string": "Distinct elements of a set of sets partitioning α are disjoint."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\" Translate the natural language version to a Lean mathlib version:\n theorem finset.sum_cancels_of_partition_cancels{β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) :\ns.sum (λ (x : α), f x) = 0 := \n\nNatural language version: \" To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors.\" Translate the natural language version to a Lean mathlib version:\n theorem clifford_algebra.odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) :\nP x hx := \n\nNatural language version: \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\" Translate the natural language version to a Lean mathlib version:\n theorem finset.sum_partition{β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] :\ns.sum (λ (x : α), f x) = (finset.image quotient.mk s).sum (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y)) := \n\nNatural language version: \"Distinct elements of a set of sets partitioning α are disjoint.\" Translate the natural language version to a Lean mathlib version:\n theorem setoid.eqv_classes_disjoint{α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) :\nc.pairwise_disjoint id := \n\nNatural language version: \"The number of partitions with odd parts is equal to the number of partitions with distinct parts.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
      "codex_time": "11.550722971995128"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem partition_odd_distincts : ∀ n : ℕ, Finset.card (Nat.Partition.odds n) = Finset.card (Nat.Partition.distincts n) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem exists_max_of_chains_bounded{α : Type u_1} {R : α → α → prop} [is_refl α R] (h : ∀ (c : set α), IsChain R c → (∃ (ub : α), ∀ (A : α), A ∈ c → R A ub)) :\n∃ (m : α), ∀ (A : α), R m A → R A m ",
        "parse-message": "unknown identifier 'prop' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem exists_maximal_of_chains_bounded_poset{α : Type*} [poset α] [Nonempty α] (h : ∀ (c : set α), IsChain (<) c → c.Nonempty → (∃ (ub : α), ∀ (A : α), A ∈ c → A ≤ ub)) :\n∃ (m : α), ∀ (A : α), m ≥ A → m ≤ A ",
        "parse-message": "<input>:1:110: expected ')' or '↑'"
      },
      {
        "success": false,
        "statement": "theorem exists_maximal_of_chains_bounded{α : Type u_1} {R : α → α → prop} (h : ∀ (c : set α), IsChain R c → (∃ (ub : α), ∀ (A : α), A ∈ c → R A ub)) (Trans : ∀ {A b c : α}, R A b → R b c → R A c) :\n∃ (m : α), ∀ (A : α), R m A → R A m ",
        "parse-message": "unknown identifier 'prop' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem upper_bounded_implies_exists_maximal{α : Type u_1} {R : α → α → prop} (h : ∀ (c : set α), IsChain R c → ∃ (ub : α), ∀ (A : α), A ∈ c → R ub A) (Trans : ∀ {A b c : α}, R A b → R b c → R A c) [Nonempty α] :\n∃ (m : α), ∀ (A : α), R A m → R m A ",
        "parse-message": "unknown identifier 'prop' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem exists_maximal_of_chains_bounded_nonempty{α : Type u_1} {R : α → α → prop} [partial_order α] (h : ∀ (c : set α), IsChain R c → c.Nonempty → (∃ (ub : α), is_ub c ub)) :\n∃ (m : α), is_maximal R m ",
        "parse-message": "unknown identifier 'prop' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "zorn",
      "search_time": "1.4391371550154872",
      "ret-prompts": [
        {
          "statement": "theorem exists_maximal_of_chains_bounded {α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m",
          "sim_score": "0.8077962398529053",
          "doc_string": " **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element."
        },
        {
          "statement": "theorem exists_maximal_of_nonempty_chains_bounded {α : Type u_1} {r : α → α → Prop} [nonempty α] (h : ∀ (c : set α), is_chain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m",
          "sim_score": "0.782833456993103",
          "doc_string": " A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then there is a maximal element."
        },
        {
          "statement": "theorem is_chain.exists_max_chain {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M",
          "sim_score": "0.6981233954429626",
          "doc_string": "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle."
        },
        {
          "statement": "theorem with_top.is_lub_Sup' {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s)",
          "sim_score": "0.6111599206924438",
          "doc_string": " The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_maximal_of_chains_bounded{α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) :\n∃ (m : α), ∀ (a : α), r m a → r a m := \n\nNatural language version: \" A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then there is a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_maximal_of_nonempty_chains_bounded{α : Type u_1} {r : α → α → Prop} [nonempty α] (h : ∀ (c : set α), is_chain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) :\n∃ (m : α), ∀ (a : α), r m a → r a m := \n\nNatural language version: \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\" Translate the natural language version to a Lean mathlib version:\n theorem is_chain.exists_max_chain{α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) :\n∃ (M : set α), is_max_chain r M ∧ c ⊆ M := \n\nNatural language version: \" The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top.\" Translate the natural language version to a Lean mathlib version:\n theorem with_top.is_lub_Sup'{β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) :\nis_lub s (has_Sup.Sup s) := \n\nNatural language version: \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
      "codex_time": "9.578672475996427"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem zorn {α : Type _} [PartialOrder α] [Nonempty α] : (∀ c : Set α, IsChain LE.le c → (∃ b : α, ∀ a ∈ c, a ≤ b)) → (∃ m : α, ∀ a : α, m ≤ a → a = m) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem abelian_of_aut_cyclic{α : Type u_1} [Group α] [Fintype (aut α)] {G : Type u_2} [Group G] [Fintype G] (h : IsCyclic G) :\n∀ (F : α →* G), IsGroupHom F → Function.Injective ⇑F → ((∃ (A : α), F A = 1) → CommGroup α) ",
        "parse-message": "unknown identifier 'aut' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_abelian_of_cyclic_aut_group{G : Type u_1} [Group G] :\nIsCyclic group_aut G → \nis_abelian G ",
        "parse-message": "unknown identifier 'group_aut' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_abelian_of_aut_is_cyclic{α : Type u} [Group α] (h : IsCyclic (aut α)) : is_abelian α ",
        "parse-message": "unknown identifier 'aut' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem abelian_of_auto_cyclic(h : α) {G : Type u} [Group G] (h1 : IsCyclic (automorphism_group α)) :\nAbelian G ",
        "parse-message": "unknown identifier 'α' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_abelian_of_aut_cyclic{G : Type u} [Group G] (A : G) (ha : IsCyclic (aut G)) :\nis_abelian G ",
        "parse-message": "unknown identifier 'aut' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "aut_group_cyclic_implies_abelian",
      "search_time": "1.4686311910045333",
      "ret-prompts": [
        {
          "statement": "theorem is_cyclic_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α",
          "sim_score": "0.6319984793663025",
          "doc_string": "A finite group of prime order is cyclic."
        },
        {
          "statement": "theorem int.subgroup_cyclic (H : add_subgroup ℤ) : ∃ (a : ℤ), H = add_subgroup.closure {a}",
          "sim_score": "0.6267713308334351",
          "doc_string": "Every subgroup of `ℤ` is cyclic."
        },
        {
          "statement": "theorem is_cyclic_of_subgroup_is_domain {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : function.injective ⇑f) : is_cyclic G",
          "sim_score": "0.5008938312530518",
          "doc_string": "A finite subgroup of the unit group of an integral domain is cyclic."
        },
        {
          "statement": "theorem is_group_hom.mul {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f g : α → β} (hf : is_group_hom f) (hg : is_group_hom g) : is_group_hom (λ (a : α), f a * g a)",
          "sim_score": "0.4840320944786072",
          "doc_string": "The product of group homomorphisms is a group homomorphism if the target is commutative."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A finite group of prime order is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem is_cyclic_of_prime_card{α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) :\nis_cyclic α := \n\nNatural language version: \"Every subgroup of `ℤ` is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem int.subgroup_cyclic(H : add_subgroup ℤ) :\n∃ (a : ℤ), H = add_subgroup.closure {a} := \n\nNatural language version: \"A finite subgroup of the unit group of an integral domain is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem is_cyclic_of_subgroup_is_domain{R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : function.injective ⇑f) :\nis_cyclic G := \n\nNatural language version: \"The product of group homomorphisms is a group homomorphism if the target is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem is_group_hom.mul{α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f g : α → β} (hf : is_group_hom f) (hg : is_group_hom g) :\nis_group_hom (λ (a : α), f a * g a) := \n\nNatural language version: \"A group whose automorphism group is cyclic is Abelian.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A group whose automorphism group is cyclic is Abelian.",
      "codex_time": "7.294612680008868"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem aut_group_cyclic_implies_abelian {G : Type _} [Groupₓ G] : CategoryTheory.Aut G → CommGroup G "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Function.image_union{α : Type u_1} {β : Type u_2} {γ : Type u_3} (F : α → β) (g : α → γ) (s : set α) :\nFunction.image F s ∪ Function.image g s = Function.image (Sum F g) s ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem set.image_union{α : Type u_1} {β : Type u_2} (s t : set α) (F : α → β) :\nF ⁻¹' (s ∪ t) = F ⁻¹' s ∪ F ⁻¹' t ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Function.image.Union_image{α : Type u} {β : Type v_1} (F : α → β) (s : set (set α)) :\nF '' (⋃ s) = (⋃ (t : set α) (h : t ∈ s), F '' t) ",
        "parse-message": "<input>:2:2: expected end of input"
      },
      {
        "success": false,
        "statement": "theorem set.image_union{α : Type u} {β : Type v} {F : α → β} {s t : set α} :\nF '' (s ∪ t) = F '' s ∪ F '' t ",
        "parse-message": "<input>:2:2: expected end of input"
      },
      {
        "success": false,
        "statement": "theorem set.image_Union{α : Type u_1} {β : Type u_2} {F : α → β} {s : set α} {t : set (set α)} (h : s ∈ t) :\nF '' (⋃ (u : {x // x ∈ t}), ⇑u) = ⋃ u, F '' u ",
        "parse-message": "<input>:2:2: expected end of input"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "image_union",
      "search_time": "1.4571299679810181",
      "ret-prompts": [
        {
          "statement": "theorem cardinal.mk_union_le {α : Type u} (S T : set α) : cardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T",
          "sim_score": "0.6315420866012573",
          "doc_string": " The cardinality of a union is at most the sum of the cardinalities of the two sets."
        },
        {
          "statement": "theorem set.subset_Union_of_subset {α : Type u_1} {ι : Sort u_4} {s : set α} {t : ι → set α} (i : ι) (h : s ⊆ t i) : s ⊆ ⋃ (i : ι), t i",
          "sim_score": "0.5471856594085693",
          "doc_string": " This rather trivial consequence of `subset_Union`is convenient with `apply`, and has `i` explicit for this purpose."
        },
        {
          "statement": "theorem metric.bounded_union {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t",
          "sim_score": "0.5332727432250977",
          "doc_string": "The union of two sets is bounded iff each of the sets is bounded."
        },
        {
          "statement": "theorem affine_subspace.span_union (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) : affine_span k (s ∪ t) = affine_span k s ⊔ affine_span k t",
          "sim_score": "0.5295044779777527",
          "doc_string": "The span of a union of sets is the sup of their spans."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" The cardinality of a union is at most the sum of the cardinalities of the two sets.\" Translate the natural language version to a Lean mathlib version:\n theorem cardinal.mk_union_le{α : Type u} (S T : set α) :\ncardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T := \n\nNatural language version: \" This rather trivial consequence of `subset_Union`is convenient with `apply`, and has `i` explicit for this purpose.\" Translate the natural language version to a Lean mathlib version:\n theorem set.subset_Union_of_subset{α : Type u_1} {ι : Sort u_4} {s : set α} {t : ι → set α} (i : ι) (h : s ⊆ t i) :\ns ⊆ ⋃ (i : ι), t i := \n\nNatural language version: \"The union of two sets is bounded iff each of the sets is bounded.\" Translate the natural language version to a Lean mathlib version:\n theorem metric.bounded_union{α : Type u} [pseudo_metric_space α] {s t : set α} :\nmetric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t := \n\nNatural language version: \"The span of a union of sets is the sup of their spans.\" Translate the natural language version to a Lean mathlib version:\n theorem affine_subspace.span_union(k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) :\naffine_span k (s ∪ t) = affine_span k s ⊔ affine_span k t := \n\nNatural language version: \"The image of a union of sets is the union of the images.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The image of a union of sets is the union of the images.",
      "codex_time": "5.90167042799294"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem image_union (f : α → β) (S : Set (Set α)) : (f <$> (⋃₀ S)) = (⋃₀ ((Functor.map f) <$> S)) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem normal_iff_two_set_separate{x : Type u_1} [TopologicalSpace x] :\nNormalSpace x ↔ ∀ (s t : set x) (hs : is_closed s) (ht : is_closed t) (hd : Disjoint s t), \n∃ (F : c(x, ℝ)), set.EQOn ⇑F 0 s ∧ set.EQOn ⇑F 1 t ",
        "parse-message": "<input>:3:8: expected ')'"
      },
      {
        "success": false,
        "statement": "theorem is_closed_topological_space.is_normal_iff_separated : ∀ {x : Type u_1} [TopologicalSpace x],\nis_closed_topological_space.Normal x ↔ ∀ (s t : set x), is_closed s → is_closed t → Disjoint s t → ∃(F : x → ℝ), Continuous F ∧ set.EQOn F 0 s ∧ set.EQOn F 1 t ",
        "parse-message": "unknown identifier 'is_closed_topological_space.Normal' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem tspace_normal_iff'{x : Type u_1} [TopologicalSpace x] (h : ∀ (s t : set x), is_closed s → is_closed t → Disjoint s t → ∃ (F : c(x, i₁)), (set.EQOn ⇑F 0 s) ∧ (set.EQOn ⇑F 1 t)) :\nis_normal_space x ",
        "parse-message": "<input>:1:135: expected ')'"
      },
      {
        "success": false,
        "statement": "theorem is_normal_of_separation_of_disjoint_closed{x : Type u_1} [TopologicalSpace x] :\nNormalSpace x ↔ ∀ (s t : set x), is_closed s → is_closed t → Disjoint s t → ∃ (F : BoundedContinuousFunction x ℝ), \n set.EQOn ⇑F 0 s ∧ set.EQOn ⇑F 1 t ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem normal_iff_separated_of_closed_of_closed{x : Type u_1} [TopologicalSpace x] [NormalSpace x] {s t : set x} (hs : is_closed s) (ht : is_closed t) (hd : Disjoint s t) :\n∃ (F : BoundedContinuousFunction x ℝ), set.EQOn ⇑F 0 s ∧ set.EQOn ⇑F 1 t ∧ ∀ (x : x), ⇑F x ∈ set.icc 0 1 ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "urysohn",
      "search_time": "1.484566332976101",
      "ret-prompts": [
        {
          "statement": "theorem exists_bounded_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1",
          "sim_score": "0.629673182964325",
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`."
        },
        {
          "statement": "theorem exists_continuous_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1",
          "sim_score": "0.629673182964325",
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`."
        },
        {
          "statement": "theorem exists_bounded_mem_Icc_of_closed_of_le {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b",
          "sim_score": "0.5748592615127563",
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a ≤ f x ≤ b` for all `x`."
        },
        {
          "statement": "theorem subgroup.is_normal_topological_closure {G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] : N.topological_closure.normal",
          "sim_score": "0.5395680069923401",
          "doc_string": "The topological closure of a normal subgroup is normal."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_bounded_zero_one_of_closed{X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :\n∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 := \n\nNatural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_continuous_zero_one_of_closed{X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :\n∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 := \n\nNatural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a ≤ f x ≤ b` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_bounded_mem_Icc_of_closed_of_le{X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) :\n∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b := \n\nNatural language version: \"The topological closure of a normal subgroup is normal.\" Translate the natural language version to a Lean mathlib version:\n theorem subgroup.is_normal_topological_closure{G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] :\nN.topological_closure.normal := \n\nNatural language version: \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
      "codex_time": "8.357022618001793"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem urysohn {X : Type _} [TopologicalSpace X] [TopologicalSpace ℝ] : NormalSpace X ↔ ( ∀ {S T : Set X}, IsClosed S → IsClosed T → Disjoint S T → (∃ f : X → ℝ, Continuous f → (∀ x ∈ S, f x = 0) ∧ (∀ x ∈ T, f x = 1)) ) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Real.subsingleton_field_aut :\nSubsingleton (Real.field_aut →₀ Real.field_aut) ",
        "parse-message": "unknown constant 'Real.field_aut' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem eq_id.field_automorphisms_reals (F : ℝ →+* ℝ) :\nF = 𝕍 ",
        "parse-message": "unknown identifier '𝕍' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem field_automorphism.id_iff_of_real_field {α : Type u_1} [field α] {F : α ≃+* α} (hr : ∀ A : α, A ≠ 0 → ∃ n : ℕ, n⁻¹ ≤ F A ∧ F A ≤ n) :\nF = field_automorphism.ID α ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem field_automorphism_real.Unique (F : ℝ →+* ℝ) :\nF = field_automorphism.ID ",
        "parse-message": "unknown identifier 'field_automorphism.ID' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_field_automorphism_id : ∀ (g : ℝ →+* ℝ), g = 𝕍1 ",
        "parse-message": "unknown identifier '𝕍1' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "real_field_aut_trivial",
      "search_time": "1.5093220950220712",
      "ret-prompts": [
        {
          "statement": "theorem order_ring_iso.subsingleton_right {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α ≃+*o β)",
          "sim_score": "0.5189149975776672",
          "doc_string": " There is at most one ordered ring isomorphism between a linear ordered field and an archimedean linear ordered field."
        },
        {
          "statement": "theorem order_ring_iso.subsingleton_left {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [archimedean α] [linear_ordered_field β] : subsingleton (α ≃+*o β)",
          "sim_score": "0.5125109553337097",
          "doc_string": " There is at most one ordered ring isomorphism between an archimedean linear ordered field and a linear ordered field."
        },
        {
          "statement": "theorem order_ring_hom.subsingleton {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α →+*o β)",
          "sim_score": "0.4997551739215851",
          "doc_string": " There is at most one ordered ring homomorphism from a linear ordered field to an archimedean linear ordered field."
        },
        {
          "statement": "theorem cardinal.mk_real  : cardinal.mk ℝ = cardinal.continuum",
          "sim_score": "0.4784242510795593",
          "doc_string": "The cardinality of the reals, as a type."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" There is at most one ordered ring isomorphism between a linear ordered field and an archimedean linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem order_ring_iso.subsingleton_right{α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] :\nsubsingleton (α ≃+*o β) := \n\nNatural language version: \" There is at most one ordered ring isomorphism between an archimedean linear ordered field and a linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem order_ring_iso.subsingleton_left{α : Type u_2} {β : Type u_3} [linear_ordered_field α] [archimedean α] [linear_ordered_field β] :\nsubsingleton (α ≃+*o β) := \n\nNatural language version: \" There is at most one ordered ring homomorphism from a linear ordered field to an archimedean linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem order_ring_hom.subsingleton{α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] :\nsubsingleton (α →+*o β) := \n\nNatural language version: \"The cardinality of the reals, as a type.\" Translate the natural language version to a Lean mathlib version:\n theorem cardinal.mk_real :\ncardinal.mk ℝ = cardinal.continuum := \n\nNatural language version: \"The only field automorphism of the reals is the identity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The only field automorphism of the reals is the identity.",
      "codex_time": "9.451521862996742"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem real_field_aut_trivial : ∀ (f : ℝ ≃+* ℝ), (∀ x : ℝ, f x = x) "
  },
  {
    "parsed": [
      "theorem Function.is_periodic_pt_of_period_three_Icc{F : ℝ → ℝ} (h : Function.IsPeriodicPt F (3 : ℕ) (0 : ℝ)) : \n∀ (m : ℕ), Function.IsPeriodicPt F m (0 : ℝ) ",
      "theorem Function.exists_of_is_periodic_pt{α : Type u_1} {F : α → α} {x : α} {m : ℕ} (hx : Function.IsPeriodicPt F m x) (hm : 0 < m) :\n∃ (y : α) (n : ℕ), (0 < n) ∧ (Function.IsPeriodicPt F n y) "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Function.exists_period_three_of_Ico_self_to_self₀{α : Type u_1} [LinearOrderedCommGroup α] [Archimedean α] {F : ico ₀ (1 : α) → ico ₀ (1 : α)} (hf : Function.Bijective F) :\n∃ x, Function.IsPeriodicPt F 3 x ",
        "parse-message": "<input>:1:124: expected token"
      },
      {
        "success": false,
        "statement": "theorem Function.IsPeriodicPt.exists_three{α : Type u_1} [LinearOrderedAddCommGroup α] (F : icc 0 1 → α) {x : α} (h : Function.IsPeriodicPt F 3 x) {z : α} (hz : 0 < z) :\n∃ (t : ℕ) (y : α), Function.IsPeriodicPt F t y ",
        "parse-message": "unknown identifier 'icc' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Function.is_periodic_pt_of_period_three_Icc{F : ℝ → ℝ} (h : Function.IsPeriodicPt F (3 : ℕ) (0 : ℝ)) : \n∀ (m : ℕ), Function.IsPeriodicPt F m (0 : ℝ) ",
        "code": "forall {F : Real -> Real}, (Function.IsPeriodicPt.{?_uniq.7} Real F (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)) (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero))) -> (forall (m : Nat), Function.IsPeriodicPt.{?_uniq.49} Real F m (OfNat.ofNat.{0} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)))"
      },
      {
        "success": false,
        "statement": "theorem Function.exists_periodic_point.of_period_three_of_unit_interval_to_unit_interval{F : ℝ → ℝ} (h : Function.exists_periodic_point 3 F) :\n∀ (n : ℕ) (h : n > 0), Function.exists_periodic_point n F ",
        "parse-message": "unknown identifier 'Function.exists_periodic_point' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Function.exists_of_is_periodic_pt{α : Type u_1} {F : α → α} {x : α} {m : ℕ} (hx : Function.IsPeriodicPt F m x) (hm : 0 < m) :\n∃ (y : α) (n : ℕ), (0 < n) ∧ (Function.IsPeriodicPt F n y) ",
        "code": "forall {α : Type.{u_1}} {F : α -> α} {x : α} {m : Nat}, (Function.IsPeriodicPt.{?_uniq.16} α F m x) -> (LT.lt.{?_uniq.24} Nat Nat.hasLt (OfNat.ofNat.{?_uniq.27} Nat 0 (instOfNatNat 0)) m) -> (Exists.{?_uniq.62} α (fun (y : α) => Exists.{?_uniq.66} Nat (fun (n : Nat) => And (LT.lt.{?_uniq.70} Nat Nat.hasLt (OfNat.ofNat.{?_uniq.73} Nat 0 (instOfNatNat 0)) n) (Function.IsPeriodicPt.{?_uniq.94} α F n y))))"
      }
    ],
    "number-parsed": 2,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "period_three_implies_chaos",
      "search_time": "1.5940131290117279",
      "ret-prompts": [
        {
          "statement": "theorem function.periodic.exists_mem_Ico₀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x : α) : ∃ (y : α) (H : y ∈ set.Ico 0 c), f x = f y",
          "sim_score": "0.6410606503486633",
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico 0 c` such that `f x = f y`."
        },
        {
          "statement": "theorem function.periodic.exists_mem_Ico {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ico a (a + c)), f x = f y",
          "sim_score": "0.6367848515510559",
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico a (a + c)` such that `f x = f y`."
        },
        {
          "statement": "theorem function.periodic.exists_mem_Ioc {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ioc a (a + c)), f x = f y",
          "sim_score": "0.6170958876609802",
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ioc a (a + c)` such that `f x = f y`."
        },
        {
          "statement": "theorem function.is_periodic_pt.eq_of_apply_eq {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y",
          "sim_score": "0.5864872932434082",
          "doc_string": " If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico 0 c` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.periodic.exists_mem_Ico₀{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x : α) :\n∃ (y : α) (H : y ∈ set.Ico 0 c), f x = f y := \n\nNatural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico a (a + c)` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.periodic.exists_mem_Ico{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) :\n∃ (y : α) (H : y ∈ set.Ico a (a + c)), f x = f y := \n\nNatural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ioc a (a + c)` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.periodic.exists_mem_Ioc{α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) :\n∃ (y : α) (H : y ∈ set.Ioc a (a + c)), f x = f y := \n\nNatural language version: \" If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`.\" Translate the natural language version to a Lean mathlib version:\n theorem function.is_periodic_pt.eq_of_apply_eq{α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) :\nx = y := \n\nNatural language version: \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
      "codex_time": "8.996071822999511"
    },
    "grouped": [
      [
        "theorem Function.is_periodic_pt_of_period_three_Icc{F : ℝ → ℝ} (h : Function.IsPeriodicPt F (3 : ℕ) (0 : ℝ)) : \n∀ (m : ℕ), Function.IsPeriodicPt F m (0 : ℝ) "
      ],
      [
        "theorem Function.exists_of_is_periodic_pt{α : Type u_1} {F : α → α} {x : α} {m : ℕ} (hx : Function.IsPeriodicPt F m x) (hm : 0 < m) :\n∃ (y : α) (n : ℕ), (0 < n) ∧ (Function.IsPeriodicPt F n y) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem period_three_implies_chaos : ∀ f : Set.Icc 0 1 → Set.Icc 0 1, (∃ x : Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → (∀ n : ℕ, n > 0 → ∃ y : Set.Icc 0 1, Function.IsPeriodicPt f n y) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem CategoryTheory.Limits.unique_terminal_equiv{c : Type u₁} [CategoryTheory.Category c] :\nUnique (CategoryTheory.Limits.HasTerminal c) ",
        "parse-message": "unknown universe level 'u₁' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem CategoryTheory.Limits.terminal_up_to_isomorphism{c : Type*} [CategoryTheory.Category c] [t₁ : CategoryTheory.Limits.HasTerminal c] [t₂ : CategoryTheory.Limits.HasTerminal c] :\nCategoryTheory.Iso (t₁.IsTerminal.from t₂.IsTerminal) ",
        "parse-message": "invalid field 'IsTerminal', the environment does not contain 'CategoryTheory.Limits.HasLimitsOfShape.IsTerminal'\n  t₁\nhas type\n  CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete Pempty) c (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem CategoryTheory.Limits.terminal_is_iso_zero_object{c : Type u} [CategoryTheory.Category c] {T : c} [CategoryTheory.Limits.HasTerminal c] [CategoryTheory.Limits.HasZeroObject c] :\nNonempty (T ≅ (0 : c)) ",
        "parse-message": "failed to synthesize instance\n  OfNat c 0 (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem CategoryTheory.uniqueness_of_terminal_up_to_iso{c : Type u₁} [CategoryTheory.Category c] {T₁ T₂ : c} [CategoryTheory.Limits.IsTerminal T₁] [CategoryTheory.Limits.IsTerminal T₂] :\n∃ (F : T₁ ⟶ T₂), ∀ (g : T₁ ⟶ T₂), CategoryTheory.Mono g → F = g ",
        "parse-message": "unknown universe level 'u₁' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem CategoryTheory.Limits.is_terminal_unique {c : Type u} [CategoryTheory.Category c] (T T' : c) :\nCategoryTheory.Limits.IsTerminal T → CategoryTheory.Limits.IsTerminal T' → T ≅ T' ",
        "parse-message": "type expected\nfailed to synthesize instance\n  CoeSort c ?m.51 (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "terminal_unique_iso",
      "search_time": "1.4388788799988106",
      "ret-prompts": [
        {
          "statement": "theorem category_theory.limits.has_terminal_of_unique {C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (Y ⟶ X)] : category_theory.limits.has_terminal C",
          "sim_score": "0.8502864837646484",
          "doc_string": " We can more explicitly show that a category has a terminal object by specifying the object, and showing there is a unique morphism to it from any other object."
        },
        {
          "statement": "theorem category_theory.limits.is_terminal.hom_ext {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ⟶ X) : f = g",
          "sim_score": "0.8256147503852844",
          "doc_string": "Any two morphisms to a terminal object are equal."
        },
        {
          "statement": "theorem category_theory.is_subterminal_of_mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A",
          "sim_score": "0.6706336140632629",
          "doc_string": "If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`."
        },
        {
          "statement": "theorem category_theory.limits.has_zero_object_of_has_terminal_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C",
          "sim_score": "0.6649926900863647",
          "doc_string": "If there are zero morphisms, any terminal object is a zero object."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" We can more explicitly show that a category has a terminal object by specifying the object, and showing there is a unique morphism to it from any other object.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.limits.has_terminal_of_unique{C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (Y ⟶ X)] :\ncategory_theory.limits.has_terminal C := \n\nNatural language version: \"Any two morphisms to a terminal object are equal.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.limits.is_terminal.hom_ext{C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ⟶ X) :\nf = g := \n\nNatural language version: \"If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.is_subterminal_of_mono_is_terminal_from{C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] :\ncategory_theory.is_subterminal A := \n\nNatural language version: \"If there are zero morphisms, any terminal object is a zero object.\" Translate the natural language version to a Lean mathlib version:\n theorem category_theory.limits.has_zero_object_of_has_terminal_object{C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] :\ncategory_theory.limits.has_zero_object C := \n\nNatural language version: \"A terminal object in a category is unique up to unique isomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A terminal object in a category is unique up to unique isomorphism.",
      "codex_time": "12.061553191015264"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem terminal_unique_iso {C : Type _} [CategoryTheory.Category C] : ∀ T₁ T₂ : C, CategoryTheory.Limits.IsTerminal T₁ → CategoryTheory.Limits.IsTerminal T₂ → (∃ ι : CategoryTheory.Iso T₁ T₂, ∀ ι' : CategoryTheory.Iso T₁ T₂, ι = ι') "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem is_torsion.Finset.fintype_of_fp{G : Type u_1} [Group G] [fp_group G]\n(u : G) (h : Monoid.is_torsion G u) : Fintype G ",
        "parse-message": "unknown identifier 'fp_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem fg_is_finite_of_torsion{G : Type u_1} [Group G]\n  (hG : Fintype G)\n  (g : ∃ x : G, x ≠ 1) :\n∃ P : ℕ, G ≃ Finset.Univ.Card = P ",
        "parse-message": "overloaded, errors \n  0:0 unknown constant 'Finset.Univ.Card'\n  \n  0:0 unknown constant 'Finset.Univ.Card' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_torsion.Finset{G : Type u} [Group G] [hNG : Nontrivial G] [is_fin_pres G] :\n∃ x : G, Monoid.is_torsion (Finset.Singleton x) ",
        "parse-message": "unknown identifier 'is_fin_pres' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem finitely_presented.is_finite_of_torsion{G : Type u_1} [Group G] [Fintype G] (hG : finitely_presented G) :\n ∃ n : ℕ, ∀ g : G, (Monoid.has_pow g n) = 1 ",
        "parse-message": "unknown identifier 'finitely_presented' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_torsion.fp_fintype(G : Type u_3) [Group G] [fp_group G] (A : G) :\n∃ n : ℕ, ∀ n : ℕ, n • A = 1 → n = 0 → False → False ",
        "parse-message": "unknown identifier 'fp_group' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "torsion_in_fg_group_implies_finite",
      "search_time": "1.6795614779985044",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_of_fintype {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G",
          "sim_score": "0.7566978335380554",
          "doc_string": "Finite groups are torsion groups."
        },
        {
          "statement": "theorem is_torsion.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) : monoid.is_torsion ↥H",
          "sim_score": "0.6571311950683594",
          "doc_string": "Subgroups of torsion groups are torsion groups."
        },
        {
          "statement": "theorem is_add_torsion_of_fintype {G : Type u_1} [add_group G] [fintype G] : add_monoid.is_torsion G",
          "sim_score": "0.6486772298812866",
          "doc_string": "Finite additive groups are additive torsion groups."
        },
        {
          "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G",
          "sim_score": "0.6356827020645142",
          "doc_string": "A nontrivial torsion group is not torsion-free."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Finite groups are torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_of_fintype{G : Type u_1} [group G] [fintype G] :\nmonoid.is_torsion G := \n\nNatural language version: \"Subgroups of torsion groups are torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) :\nmonoid.is_torsion ↥H := \n\nNatural language version: \"Finite additive groups are additive torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem is_add_torsion_of_fintype{G : Type u_1} [add_group G] [fintype G] :\nadd_monoid.is_torsion G := \n\nNatural language version: \"A nontrivial torsion group is not torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion.not_torsion_free{G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion G → ¬monoid.is_torsion_free G := \n\nNatural language version: \"A finitely-presented group containing a torsion element is finite.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finitely-presented group containing a torsion element is finite.",
      "codex_time": "9.398841628979426"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem torsion_in_fg_group_implies_finite {G : Type _} [Groupₓ G] : Groupₓ.Fg G → Finite G "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem compl_union{α : Type u} {s t : set α} :\nsᶜ ∪ tᶜ = (s ∩ t)ᶜ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem compl_union{α : Type u} (s₁ s₂ : set α) :\n(s₁ ∪ s₂)ᶜ = (s₁ᶜ) ∩ (s₂ᶜ) ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem compl_union{α : Type u} {s t : set α} :\n(- s ∪ - t)ᶜ = - (s ∩ t) ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem compl_union{α : Type u} (s T : set α) :\n(s ∪ T)ᶜ = sᶜ ∩ Tᶜ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem compl_union{α : Type u} {s T : set α} :\n(s ∪ T)ᶜ = sᶜ ∩ Tᶜ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "compl_union",
      "search_time": "1.466880152001977",
      "ret-prompts": [
        {
          "statement": "theorem frontier_compl {α : Type u} [topological_space α] (s : set α) : frontier sᶜ = frontier s",
          "sim_score": "0.6778950691223145",
          "doc_string": "The complement of a set has the same frontier as the original set."
        },
        {
          "statement": "theorem bdd_below_union {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t",
          "sim_score": "0.6120935678482056",
          "doc_string": "The union of two sets is bounded above if and only if each of the sets is."
        },
        {
          "statement": "theorem bdd_above_union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t",
          "sim_score": "0.6120935678482056",
          "doc_string": "The union of two sets is bounded above if and only if each of the sets is."
        },
        {
          "statement": "theorem cardinal.mk_union_le {α : Type u} (S T : set α) : cardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T",
          "sim_score": "0.6097555160522461",
          "doc_string": " The cardinality of a union is at most the sum of the cardinalities of the two sets."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The complement of a set has the same frontier as the original set.\" Translate the natural language version to a Lean mathlib version:\n theorem frontier_compl{α : Type u} [topological_space α] (s : set α) :\nfrontier sᶜ = frontier s := \n\nNatural language version: \"The union of two sets is bounded above if and only if each of the sets is.\" Translate the natural language version to a Lean mathlib version:\n theorem bdd_below_union{γ : Type w} [semilattice_inf γ] {s t : set γ} :\nbdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t := \n\nNatural language version: \"The union of two sets is bounded above if and only if each of the sets is.\" Translate the natural language version to a Lean mathlib version:\n theorem bdd_above_union{γ : Type w} [semilattice_sup γ] {s t : set γ} :\nbdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t := \n\nNatural language version: \" The cardinality of a union is at most the sum of the cardinalities of the two sets.\" Translate the natural language version to a Lean mathlib version:\n theorem cardinal.mk_union_le{α : Type u} (S T : set α) :\ncardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T := \n\nNatural language version: \"The complement of the union of two sets is the intersection of their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The complement of the union of two sets is the intersection of their complements.",
      "codex_time": "6.262508013984188"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem compl_union {α : Type _} (S T : Set α) : (S ∪ T).compl = S.compl ∩ T.compl "
  },
  {
    "parsed": [
      "theorem cube_sum{x y z : ℕ} (hxy : x ^ 3 + y ^ 3 = z ^ 3) :\nFalse ",
      "theorem sum_of_cubes {x y z : ℤ} (hx : x > 0) (hy : y > 0) (hz : z > 0) :\n¬ x ^ 3 + y ^ 3 = z ^ 3 "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Nat.cube_sum_of_cubes{A b c : ℕ} [Fact (Nat.Prime c)] [Fact (Nat.Prime (A ^ 3 + b ^ 3))] (hpos : 0 < A ∧ 0 < b ∧ 0 < c) :\nA ˆ 3 + b ˆ 3 ≠ c ˆ 3 ",
        "parse-message": "<input>:2:2: expected end of input"
      },
      {
        "success": true,
        "statement": "theorem cube_sum{x y z : ℕ} (hxy : x ^ 3 + y ^ 3 = z ^ 3) :\nFalse ",
        "code": "forall {x : Nat} {y : Nat} {z : Nat}, (Eq.{?_uniq.9} Nat (HAdd.hAdd.{?_uniq.12 ?_uniq.11 ?_uniq.10} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HPow.hPow.{?_uniq.15 ?_uniq.14 ?_uniq.13} Nat Nat Nat (Monoid.HPow.{?_uniq.202} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) x (OfNat.ofNat.{?_uniq.14} Nat 3 (instOfNatNat 3))) (HPow.hPow.{?_uniq.41 ?_uniq.40 ?_uniq.39} Nat Nat Nat (Monoid.HPow.{?_uniq.302} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) y (OfNat.ofNat.{?_uniq.40} Nat 3 (instOfNatNat 3)))) (HPow.hPow.{?_uniq.89 ?_uniq.88 ?_uniq.87} Nat Nat Nat (Monoid.HPow.{?_uniq.355} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) z (OfNat.ofNat.{?_uniq.88} Nat 3 (instOfNatNat 3)))) -> False"
      },
      {
        "success": false,
        "statement": "theorem sum_cube_neq{A b c : ℕ} (habn : A ^ 3 + b ^ 3 ≠ c ^ 3) :\n¬ (A * A * A + b * b * b = c * c * c) ",
        "parse-message": "elaboration function for 'Parser.Tactic.Localized.«term_*»' has not been implemented\n  A* (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem sum_cubes_three_squares (x y z : ℕ) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) :\n(x ^ 3 + y ^ 3 + z ^ 3) / 3 ≠ x * y * z ",
        "parse-message": "elaboration function for 'Parser.Tactic.Localized.«term_*»' has not been implemented\n  y* (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem sum_of_cubes {x y z : ℤ} (hx : x > 0) (hy : y > 0) (hz : z > 0) :\n¬ x ^ 3 + y ^ 3 = z ^ 3 ",
        "code": "forall {x : Int} {y : Int} {z : Int}, (GT.gt.{?_uniq.9} Int Int.hasLt x (OfNat.ofNat.{?_uniq.12} Int 0 (Int.instOfNatInt 0))) -> (GT.gt.{?_uniq.43} Int Int.hasLt y (OfNat.ofNat.{?_uniq.46} Int 0 (Int.instOfNatInt 0))) -> (GT.gt.{?_uniq.65} Int Int.hasLt z (OfNat.ofNat.{?_uniq.68} Int 0 (Int.instOfNatInt 0))) -> (Not (Eq.{?_uniq.86} Int (HAdd.hAdd.{?_uniq.89 ?_uniq.88 ?_uniq.87} Int Int Int (instHAdd.{0} Int Int.hasAdd) (HPow.hPow.{?_uniq.92 ?_uniq.91 ?_uniq.90} Int Nat Int (Monoid.HPow.{?_uniq.257} Int (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int (Ring.toSemiring.{0} Int (CommRing.toRing.{0} Int Int.instCommRingInt))))) x (OfNat.ofNat.{?_uniq.91} Nat 3 (instOfNatNat 3))) (HPow.hPow.{?_uniq.116 ?_uniq.115 ?_uniq.114} Int Nat Int (Monoid.HPow.{?_uniq.342} Int (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int (Ring.toSemiring.{0} Int (CommRing.toRing.{0} Int Int.instCommRingInt))))) y (OfNat.ofNat.{?_uniq.115} Nat 3 (instOfNatNat 3)))) (HPow.hPow.{?_uniq.158 ?_uniq.157 ?_uniq.156} Int Nat Int (Monoid.HPow.{?_uniq.391} Int (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int (Ring.toSemiring.{0} Int (CommRing.toRing.{0} Int Int.instCommRingInt))))) z (OfNat.ofNat.{?_uniq.157} Nat 3 (instOfNatNat 3)))))"
      }
    ],
    "number-parsed": 2,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "flt_3",
      "search_time": "1.568569580995245",
      "ret-prompts": [
        {
          "statement": "theorem pythagorean_triple.zero  : pythagorean_triple 0 0 0",
          "sim_score": "0.5193248391151428",
          "doc_string": "The zeroth Pythagorean triple is all zeros."
        },
        {
          "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
          "sim_score": "0.4774671792984009",
          "doc_string": "The sum of two squares is zero iff both elements are zero."
        },
        {
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
          "sim_score": "0.4648144245147705",
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**."
        },
        {
          "statement": "theorem pythagorean_triple_comm {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z",
          "sim_score": "0.4421241879463196",
          "doc_string": " Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The zeroth Pythagorean triple is all zeros.\" Translate the natural language version to a Lean mathlib version:\n theorem pythagorean_triple.zero :\npythagorean_triple 0 0 0 := \n\nNatural language version: \"The sum of two squares is zero iff both elements are zero.\" Translate the natural language version to a Lean mathlib version:\n theorem mul_self_add_mul_self_eq_zero{α : Type u} [linear_ordered_ring α] {x y : α} :\nx * x + y * y = 0 ↔ x = 0 ∧ y = 0 := \n\nNatural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.sq_add_sq{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \" Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity.\" Translate the natural language version to a Lean mathlib version:\n theorem pythagorean_triple_comm{x y z : ℤ} :\npythagorean_triple x y z ↔ pythagorean_triple y x z := \n\nNatural language version: \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
      "codex_time": "9.081373843015172"
    },
    "grouped": [
      [
        "theorem cube_sum{x y z : ℕ} (hxy : x ^ 3 + y ^ 3 = z ^ 3) :\nFalse "
      ],
      [
        "theorem sum_of_cubes {x y z : ℤ} (hx : x > 0) (hy : y > 0) (hz : z > 0) :\n¬ x ^ 3 + y ^ 3 = z ^ 3 "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem flt_3 : ∀ a b c : ℕ, a > 0 → b > 0 → ¬(a^3 + b^3 = c^3) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Commute.is_of_fin_order_two_of_fin_two{G : Type u} [Group G] (h : ∀ x : G, IsOFFinOrder (x : G) (ℕ)) :\n∀ x y : G, Commute (x : G) y ",
        "parse-message": "unknown identifier 'IsOFFinOrder' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem every_element_has_order_two.add_commute_irr{G : Type u} [Group G] (h1 : ∀ x : G, IsOFFinOrder x) (h2 : ∀ x : G, is_of_order x two_ne_zero) :\n∀ x y : G, AddCommute x y ",
        "parse-message": "unknown identifier 'IsOFFinOrder' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem allofhasordnto2_iff_allpairsofy_commutes{G : Type u} [Group G] :\n(∀ x : G, IsOFFinOrder x 2) ↔ (∀ x y : G, Commute x y) ",
        "parse-message": "unknown identifier 'IsOFFinOrder' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem iop_two.Commute{G : Type u} [Group G] {x y : G} (h : iop_two x) (h' : iop_two y) :\nCommute x y ",
        "parse-message": "unknown identifier 'iop_two' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem commute_of_card_two{G : Type u} [Group G] (h : ∀ (g:G), @is_of_order G 2 g) :\n∀ x y : G, Commute x y ",
        "parse-message": "unknown identifier 'is_of_order' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "elems_order_two_implies_commutative",
      "search_time": "1.5816187500022352",
      "ret-prompts": [
        {
          "statement": "theorem commute.symm {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a",
          "sim_score": "0.6088767051696777",
          "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`."
        },
        {
          "statement": "theorem add_commute.symm {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a",
          "sim_score": "0.6088767051696777",
          "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`."
        },
        {
          "statement": "theorem commute.is_of_fin_order_mul {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
          "sim_score": "0.5862270593643188",
          "doc_string": "Commuting elements of finite order are closed under multiplication."
        },
        {
          "statement": "theorem commute.mul_right {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)",
          "sim_score": "0.5844683647155762",
          "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their product."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If `a` commutes with `b`, then `b` commutes with `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem commute.symm{S : Type u_1} [has_mul S] {a b : S} (h : commute a b) :\ncommute b a := \n\nNatural language version: \"If `a` commutes with `b`, then `b` commutes with `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem add_commute.symm{S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) :\nadd_commute b a := \n\nNatural language version: \"Commuting elements of finite order are closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem commute.is_of_fin_order_mul{G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) :\nis_of_fin_order (x * y) := \n\nNatural language version: \"If `a` commutes with both `b` and `c`, then it commutes with their product.\" Translate the natural language version to a Lean mathlib version:\n theorem commute.mul_right{S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) :\ncommute a (b * c) := \n\nNatural language version: \"If every element of a group `G` has order two, then every pair of elements of `G` commutes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every element of a group `G` has order two, then every pair of elements of `G` commutes.",
      "codex_time": "10.195432050997624"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem elems_order_two_implies_commutative {G: Type _}[Group G] : (∀ x y : G, x * x = 1) → (∀ x y : G, Commute x y) "
  },
  {
    "parsed": [
      "theorem Nat.Prime.or_eq_two(P : ℕ) [Fact (Nat.Prime P)] :\nP = 2 ∨ P % 2 = 1 ",
      "theorem Nat.Prime.not_two_of_odd{n : ℕ} (h_prime : Nat.Prime n) (h_odd : n % 2 = 1) :\nn ≠ 2 ",
      "theorem Nat.Prime.exhaust{P : ℕ} (hp : Nat.Prime P) :\nP = 2 ∨ P % 2 = 1 ",
      "theorem Nat.Prime.is_odd_or_eq_two(P : ℕ) [Fact (Nat.Prime P)] :\n P = 2 ∨ P % 2 = 1 ",
      "theorem Nat.Prime.or_two{P : ℕ} (hp : Nat.Prime P) :\nP ≠ 2 ∨ P = 2 "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "theorem Nat.Prime.or_eq_two(P : ℕ) [Fact (Nat.Prime P)] :\nP = 2 ∨ P % 2 = 1 ",
        "code": "forall (P : Nat) [inst._@._hyg.7 : Fact (Nat.Prime P)], Or (Eq.{?_uniq.7} Nat P (OfNat.ofNat.{?_uniq.10} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.30} Nat (HMod.hMod.{?_uniq.33 ?_uniq.32 ?_uniq.31} Nat Nat Nat (instHMod.{?_uniq.106} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.32} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.66} Nat 1 (instOfNatNat 1)))"
      },
      {
        "success": true,
        "statement": "theorem Nat.Prime.not_two_of_odd{n : ℕ} (h_prime : Nat.Prime n) (h_odd : n % 2 = 1) :\nn ≠ 2 ",
        "code": "forall {n : Nat}, (Nat.Prime n) -> (Eq.{?_uniq.8} Nat (HMod.hMod.{?_uniq.11 ?_uniq.10 ?_uniq.9} Nat Nat Nat (instHMod.{?_uniq.84} Nat Nat.hasMod) n (OfNat.ofNat.{?_uniq.10} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.44} Nat 1 (instOfNatNat 1))) -> (Ne.{?_uniq.106} Nat n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))"
      },
      {
        "success": true,
        "statement": "theorem Nat.Prime.exhaust{P : ℕ} (hp : Nat.Prime P) :\nP = 2 ∨ P % 2 = 1 ",
        "code": "forall {P : Nat}, (Nat.Prime P) -> (Or (Eq.{?_uniq.7} Nat P (OfNat.ofNat.{?_uniq.10} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.30} Nat (HMod.hMod.{?_uniq.33 ?_uniq.32 ?_uniq.31} Nat Nat Nat (instHMod.{?_uniq.106} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.32} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.66} Nat 1 (instOfNatNat 1))))"
      },
      {
        "success": true,
        "statement": "theorem Nat.Prime.is_odd_or_eq_two(P : ℕ) [Fact (Nat.Prime P)] :\n P = 2 ∨ P % 2 = 1 ",
        "code": "forall (P : Nat) [inst._@._hyg.7 : Fact (Nat.Prime P)], Or (Eq.{?_uniq.7} Nat P (OfNat.ofNat.{?_uniq.10} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.30} Nat (HMod.hMod.{?_uniq.33 ?_uniq.32 ?_uniq.31} Nat Nat Nat (instHMod.{?_uniq.106} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.32} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.66} Nat 1 (instOfNatNat 1)))"
      },
      {
        "success": true,
        "statement": "theorem Nat.Prime.or_two{P : ℕ} (hp : Nat.Prime P) :\nP ≠ 2 ∨ P = 2 ",
        "code": "forall {P : Nat}, (Nat.Prime P) -> (Or (Ne.{?_uniq.7} Nat P (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.19} Nat P (OfNat.ofNat.{?_uniq.22} Nat 2 (instOfNatNat 2))))"
      }
    ],
    "number-parsed": 5,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "prime_eq_two_or_odd",
      "search_time": "1.4313888899923768",
      "ret-prompts": [
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.7289595007896423",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        },
        {
          "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3",
          "sim_score": "0.5622097253799438",
          "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`"
        },
        {
          "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1",
          "sim_score": "0.5335504412651062",
          "doc_string": "The only numbers with empty prime factorization are `0` and `1`"
        },
        {
          "statement": "theorem nat.prime.factorization {p : ℕ} (hp : nat.prime p) : p.factorization = finsupp.single p 1",
          "sim_score": "0.5028786063194275",
          "doc_string": "The only prime factor of prime `p` is `p` itself, with multiplicity `1`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"A natural number is odd iff it has residue `1` or `3` mod `4`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.odd_mod_four_iff{n : ℕ} :\nn % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 := \n\nNatural language version: \"The only numbers with empty prime factorization are `0` and `1`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_eq_zero_iff(n : ℕ) :\nn.factorization = 0 ↔ n = 0 ∨ n = 1 := \n\nNatural language version: \"The only prime factor of prime `p` is `p` itself, with multiplicity `1`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.factorization{p : ℕ} (hp : nat.prime p) :\np.factorization = finsupp.single p 1 := \n\nNatural language version: \"Every prime number is either `2` or odd.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every prime number is either `2` or odd.",
      "codex_time": "6.363089246995514"
    },
    "grouped": [
      [
        "theorem Nat.Prime.or_eq_two(P : ℕ) [Fact (Nat.Prime P)] :\nP = 2 ∨ P % 2 = 1 ",
        "theorem Nat.Prime.is_odd_or_eq_two(P : ℕ) [Fact (Nat.Prime P)] :\n P = 2 ∨ P % 2 = 1 "
      ],
      [
        "theorem Nat.Prime.not_two_of_odd{n : ℕ} (h_prime : Nat.Prime n) (h_odd : n % 2 = 1) :\nn ≠ 2 "
      ],
      [
        "theorem Nat.Prime.exhaust{P : ℕ} (hp : Nat.Prime P) :\nP = 2 ∨ P % 2 = 1 "
      ],
      [
        "theorem Nat.Prime.or_two{P : ℕ} (hp : Nat.Prime P) :\nP ≠ 2 ∨ P = 2 "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem prime_eq_two_or_odd {n: Nat} : Prime n → n = 2 ∨ Odd n "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem has_root_odd_degree_real {R : Type u} [Nontrivial R] [discrete_field R] (P : Polynomial R) :\n(∀ x : R, Polynomial.Eval P x = 0 ∨ Polynomial.Eval P (-x) = 0) ↔ P.nat_degree % 2 = 1 ",
        "parse-message": "unknown identifier 'discrete_field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem exists_root_odd_degree_real_polynomial (P : Polynomial ℝ) : P.degree.nat_mod 2 = 1 →\n∃ z, z ≠ 0 ∧ (z : ℝ) ∈ P.roots ",
        "parse-message": "invalid field 'nat_mod', the environment does not contain 'Option.nat_mod'\n  Polynomial.degree P\nhas type\n  Option ℕ (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem reals.iVT_irrational_2{R : ℝ} (hr : ∀ R, R ∈ (ioo (0:ℝ) 1)) : ∃ R : ℝ, R ∈ (ioo 0 (1:ℝ)) ∧ R ≠ 0 ",
        "parse-message": "unknown identifier 'ioo' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Real.odd_degree_zero{P : Polynomial ℝ} (hp : P.degree = 2 * _ + 1) : ∃x : ℝ, Real.to_real_poly P x = 0 ",
        "parse-message": "unknown constant 'Real.to_real_poly' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem exists_odd_degree_root_real (F : Polynomial ℝ) (hf : F.nat_degree % 2 = 1) :\n∃ x : ℝ, F.Eval x = 0 ",
        "parse-message": "invalid field 'nat_degree', the environment does not contain 'Polynomial.nat_degree'\n  F\nhas type\n  ℝ[X] (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "poly_odd_degree_has_zero",
      "search_time": "1.7156728270056192",
      "ret-prompts": [
        {
          "statement": "theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ≤ (multiset.map polynomial.degree t).sum",
          "sim_score": "0.50849449634552",
          "doc_string": "The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥."
        },
        {
          "statement": "theorem polynomial.degree_multiset_prod {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] : t.prod.degree = (multiset.map (λ (f : polynomial R), f.degree) t).sum",
          "sim_score": "0.48135414719581604",
          "doc_string": "The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥."
        },
        {
          "statement": "theorem polynomial.degree_prod {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) [nontrivial R] : (s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree)",
          "sim_score": "0.48135414719581604",
          "doc_string": "The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥."
        },
        {
          "statement": "theorem minpoly.nat_degree_pos {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).nat_degree",
          "sim_score": "0.4661085605621338",
          "doc_string": "The degree of a minimal polynomial, as a natural number, is positive."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.degree_multiset_prod_le{R : Type u} [comm_semiring R] (t : multiset (polynomial R)) :\nt.prod.degree ≤ (multiset.map polynomial.degree t).sum := \n\nNatural language version: \"The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.degree_multiset_prod{R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] :\nt.prod.degree = (multiset.map (λ (f : polynomial R), f.degree) t).sum := \n\nNatural language version: \"The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.degree_prod{R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) [nontrivial R] :\n(s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree) := \n\nNatural language version: \"The degree of a minimal polynomial, as a natural number, is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem minpoly.nat_degree_pos{A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) :\n0 < (minpoly A x).nat_degree := \n\nNatural language version: \"Every odd degree polynomial over `ℝ` has a zero\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every odd degree polynomial over `ℝ` has a zero",
      "codex_time": "9.308353050000733"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem poly_odd_degree_has_zero {α : Type _} [Field α] (p : Polynomial α) : Odd (p.degree) → ∃ x, p.IsRoot x "
  },
  {
    "parsed": [
      "theorem Nat.prod_succ: ∀ A : ℕ, Even (A + 1) "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Nat.mul_succ_succ_odd{m n : ℕ} :\n∃ k : ℤ, (Int.of_nat (m + 1)) * (Int.of_nat (n + 1)) = 2 * k.Succ ",
        "parse-message": "unknown constant 'Int.of_nat' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Nat.prod_succ: ∀ A : ℕ, Even (A + 1) ",
        "code": "forall (A : Nat), Even.{?_uniq.4} Nat Nat.hasAdd (HAdd.hAdd.{?_uniq.9 ?_uniq.8 ?_uniq.7} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) A (OfNat.ofNat.{?_uniq.12} Nat 1 (?_uniq.59 A)))"
      },
      {
        "success": false,
        "statement": "theorem mul_nat_mul_add_nat_mul_add_mul_nat :  ∀ (m n : ℕ), (m * n) * (n + 1) = m * n * n + m ",
        "parse-message": "elaboration function for 'Parser.Tactic.Localized.«term_*»' has not been implemented\n  n* (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Nat.even_mul(m n : ℕ) :\nEven m ∧ m ≠ 0 → Even n ∧ n ≠ 0 → Even (m * n ∧ m ≠ 0) ",
        "parse-message": "failed to synthesize\n  CoeHTCT ℕ Prop\n(deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached (use 'set_option synthInstance.maxHeartbeats <num>' to set the limit) (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem PNat.even_iff_odd_mul{m n : ℕ+} :\nEven m ↔ Odd (m * n) ",
        "parse-message": "failed to synthesize instance\n  Semiringₓ ℕ+ (during elaboration)"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "product_conseq_odd",
      "search_time": "1.4329123749921564",
      "ret-prompts": [
        {
          "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0",
          "sim_score": "0.5561787486076355",
          "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive."
        },
        {
          "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3",
          "sim_score": "0.5415111780166626",
          "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`"
        },
        {
          "statement": "theorem nat.dvd_right_iff_eq {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n",
          "sim_score": "0.5249637365341187",
          "doc_string": "Two natural numbers are equal if and only if the have the same multiples."
        },
        {
          "statement": "theorem pnat.prod_factor_multiset (n : ℕ+) : n.factor_multiset.prod = n",
          "sim_score": "0.5125280022621155",
          "doc_string": "The product of the factors is the original number"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.even_pow{m n : ℕ} :\neven (m ^ n) ↔ even m ∧ n ≠ 0 := \n\nNatural language version: \"A natural number is odd iff it has residue `1` or `3` mod `4`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.odd_mod_four_iff{n : ℕ} :\nn % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 := \n\nNatural language version: \"Two natural numbers are equal if and only if the have the same multiples.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.dvd_right_iff_eq{m n : ℕ} :\n(∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n := \n\nNatural language version: \"The product of the factors is the original number\" Translate the natural language version to a Lean mathlib version:\n theorem pnat.prod_factor_multiset(n : ℕ+) :\nn.factor_multiset.prod = n := \n\nNatural language version: \"The product of two consequitive natural numbers is odd\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of two consequitive natural numbers is odd",
      "codex_time": "6.743548944010399"
    },
    "grouped": [
      [
        "theorem Nat.prod_succ: ∀ A : ℕ, Even (A + 1) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem product_conseq_odd (n: Nat): Odd <| n * (n + 1) "
  },
  {
    "parsed": [
      "theorem continuous_const.Differentiable (c : ℝ) :\nDifferentiable ℝ (λ (x : ℝ), c) ",
      "theorem ContinuousLinearMap.Const.Differentiable (c : ℝ) : Differentiable ℝ (λ x:ℝ, c) ",
      "theorem differentiable_const :\nDifferentiable ℝ (λ x : ℝ, 0) "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem const_diff {F : ℝ → ℝ} (c : ℝ) (x : ℝ) : Differentiable 𝕜 F ",
        "parse-message": "unknown identifier '𝕜' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem differentiable_const{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] [NormedSpace 𝕜 ℝ] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {c : E} {F : E → E} (hF : F = (λ x, c)) :\nDifferentiableOn 𝕜 F ℝ ",
        "parse-message": "failed to synthesize\n  CoeHTCT (?m.170 → E) (E → E)\n(deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached (use 'set_option synthInstance.maxHeartbeats <num>' to set the limit) (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem continuous_const.Differentiable (c : ℝ) :\nDifferentiable ℝ (λ (x : ℝ), c) ",
        "code": "forall (c : Real), Differentiable.{?_uniq.6 ?_uniq.5 ?_uniq.4} Real Real.nondiscreteNormedField (?_uniq.295 c) (?_uniq.296 c) (?_uniq.297 c) (?_uniq.298 c) (?_uniq.299 c) (?_uniq.300 c) (fun (x._@._hyg.16 : ?_uniq.295 c) => ?_uniq.301 c x._@._hyg.16)"
      },
      {
        "success": true,
        "statement": "theorem ContinuousLinearMap.Const.Differentiable (c : ℝ) : Differentiable ℝ (λ x:ℝ, c) ",
        "code": "forall (c : Real), Differentiable.{?_uniq.6 ?_uniq.5 ?_uniq.4} Real Real.nondiscreteNormedField Real Real.normedGroup (NormedField.toNormedSpace.{0} Real (NondiscreteNormedField.toNormedField.{0} Real Real.nondiscreteNormedField)) Real Real.normedGroup (NormedField.toNormedSpace.{0} Real (NondiscreteNormedField.toNormedField.{0} Real Real.nondiscreteNormedField)) (fun (x : Real) => c)"
      },
      {
        "success": true,
        "statement": "theorem differentiable_const :\nDifferentiable ℝ (λ x : ℝ, 0) ",
        "code": "Differentiable.{?_uniq.3 ?_uniq.2 ?_uniq.1} Real ?_uniq.4 ?_uniq.5 ?_uniq.6 ?_uniq.7 ?_uniq.8 ?_uniq.9 ?_uniq.10 (fun (x : Real) => OfNat.ofNat.{?_uniq.1} ?_uniq.15 0 (?_uniq.24 x))"
      }
    ],
    "number-parsed": 3,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "constant_is_differentiable",
      "search_time": "1.462075316987466",
      "ret-prompts": [
        {
          "statement": "theorem cont_diff.differentiable {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : differentiable 𝕜 f",
          "sim_score": "0.6595531702041626",
          "doc_string": "If a function is `C^n` with `n ≥ 1`, then it is differentiable."
        },
        {
          "statement": "theorem cont_diff_at.differentiable_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) : differentiable_at 𝕜 f x",
          "sim_score": "0.6467167139053345",
          "doc_string": "If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there."
        },
        {
          "statement": "theorem cont_diff_within_at.differentiable_within_at' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) : differentiable_within_at 𝕜 f (has_insert.insert x s) x",
          "sim_score": "0.6451953649520874",
          "doc_string": " If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable within this set at this point."
        },
        {
          "statement": "theorem cont_diff_on.differentiable_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) : differentiable_on 𝕜 f s",
          "sim_score": "0.6353325843811035",
          "doc_string": "If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If a function is `C^n` with `n ≥ 1`, then it is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem cont_diff.differentiable{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) :\ndifferentiable 𝕜 f := \n\nNatural language version: \"If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there.\" Translate the natural language version to a Lean mathlib version:\n theorem cont_diff_at.differentiable_at{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) :\ndifferentiable_at 𝕜 f x := \n\nNatural language version: \" If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable within this set at this point.\" Translate the natural language version to a Lean mathlib version:\n theorem cont_diff_within_at.differentiable_within_at'{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :\ndifferentiable_within_at 𝕜 f (has_insert.insert x s) x := \n\nNatural language version: \"If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there.\" Translate the natural language version to a Lean mathlib version:\n theorem cont_diff_on.differentiable_on{𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) :\ndifferentiable_on 𝕜 f s := \n\nNatural language version: \"Every constant function `f x = c` from real numbers to real numbers is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every constant function `f x = c` from real numbers to real numbers is differentiable.",
      "codex_time": "5.653682729986031"
    },
    "grouped": [
      [
        "theorem continuous_const.Differentiable (c : ℝ) :\nDifferentiable ℝ (λ (x : ℝ), c) "
      ],
      [
        "theorem ContinuousLinearMap.Const.Differentiable (c : ℝ) : Differentiable ℝ (λ x:ℝ, c) "
      ],
      [
        "theorem differentiable_const :\nDifferentiable ℝ (λ x : ℝ, 0) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem constant_is_differentiable {f: ℝ → ℝ}: ∃ c: ℝ, (∀ x : ℝ, f x = c) → Differentiable ℝ f "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Group.free_of_is_free (G : Type u_1) [Group G] (i : Type u_2) [Group i] (h : subgroup i) (hI : 2 ∣ h.Index) :\nis_free ↥h ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_free.index_eq_two{G : Type u_1} [Group G] {h : subgroup G} [free_group G] (hH : h.Index = 2) :\nis_free ↥h ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem subgroup.free_of_index_eq_two{G : Type u_1} [Group G] {h : subgroup G} (hHind : h.Index = 2) :\nfree_group h ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_free.subgroup_index2_of_generators{G : Type u_1} [Group G] {g : ℕ → G} (gh : IsGroupHom ℕ G g) (hg : ∀ n, 0 < n → ∃ m hm, g n ≠ g m) :\n∀ m > 0, is_free G (subgroup_index2_of_generators g gh hg m) ",
        "parse-message": "function expected at\n  IsGroupHom ?m.218\nterm has type\n  Prop (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem subgroup.free_of_index_two(G : Type u_1) [Group G] (h : subgroup G) (hH : h.Index = 2) :\n@free_group G _ h ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "index_two_subgroup",
      "search_time": "1.4575754079851322",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H",
          "sim_score": "0.6636497974395752",
          "doc_string": "Subgroups of torsion-free groups are torsion-free."
        },
        {
          "statement": "theorem subgroup.fg_of_index_ne_zero {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) : group.fg ↥H",
          "sim_score": "0.5494142770767212",
          "doc_string": "**Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated."
        },
        {
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.5431281924247742",
          "doc_string": "Direct products of torsion free groups are torsion free."
        },
        {
          "statement": "theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G)",
          "sim_score": "0.5406138896942139",
          "doc_string": "Quotienting a group by its torsion subgroup yields a torsion free group."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"**Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated.\" Translate the natural language version to a Lean mathlib version:\n theorem subgroup.fg_of_index_ne_zero{G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) :\ngroup.fg ↥H := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Quotienting a group by its torsion subgroup yields a torsion free group.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.quotient_torsion(G : Type u_1) [comm_group G] :\nmonoid.is_torsion_free (G ⧸ torsion G) := \n\nNatural language version: \"Every index 2 subgroup of a group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every index 2 subgroup of a group is free",
      "codex_time": "11.474060665990692"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem index_two_subgroup {G : Type _} [Groupₓ G] (H : Subgroup G): H.index = 2 → Subgroup.Normal H "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem free_of_free_subgroup.is_free{ι : Type u_1} (hs : ι → Type u_2) [Π (i : ι), Group (hs i)] (h : Π (i : ι), free_of_free_subgroup (hs i)) :\nfree_group (Π (i : ι), hs i) ",
        "parse-message": "unknown identifier 'free_of_free_subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_free.subgroup'{G : Type u_1} [Group G] (FG : Monoid.is_free G) (h : subgroup G) :\nMonoid.is_free ↥h ",
        "parse-message": "unknown constant 'Monoid.is_free' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem free_subgroup{η: Type u_2} [DecidableEQ η] (s : set η) (hS_subset_t : s ⊆ η) :\nGroup (free_group s) ",
        "parse-message": "unknown identifier 'DecidableEQ' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_free.subgroup(x : Type v_1 u_1) [DecidableEQ x] [free_group F] (h : subgroup F) (xF : is_generator_set x (↑h) set.finite_to_set) :\nis_free x (↑h) ",
        "parse-message": "unknown universe level 'v_1' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Free.subgroup(s : Type u_1) [Group s] (FS : free_group s) (h : subgroup s) :\nfree_group ↥h ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "subgpFree",
      "search_time": "1.3809250470076222",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H",
          "sim_score": "0.7357965111732483",
          "doc_string": "Subgroups of torsion-free groups are torsion-free."
        },
        {
          "statement": "theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G)",
          "sim_score": "0.621972382068634",
          "doc_string": "Quotienting a group by its torsion subgroup yields a torsion free group."
        },
        {
          "statement": "theorem is_torsion_free.add_subgroup {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) : add_monoid.is_torsion_free ↥H",
          "sim_score": "0.6199988722801208",
          "doc_string": "Subgroups of additive torsion-free groups are additively torsion-free."
        },
        {
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.58650141954422",
          "doc_string": "Direct products of torsion free groups are torsion free."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"Quotienting a group by its torsion subgroup yields a torsion free group.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.quotient_torsion(G : Type u_1) [comm_group G] :\nmonoid.is_torsion_free (G ⧸ torsion G) := \n\nNatural language version: \"Subgroups of additive torsion-free groups are additively torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.add_subgroup{G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) :\nadd_monoid.is_torsion_free ↥H := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Every subgroup of a free group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every subgroup of a free group is free",
      "codex_time": "7.315295198990498"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem subgpFree {G : Type _} [Groupₓ G] : (K : Subgroup G) → Σ β, FreeGroup β ≃* ↥K "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem free_group.IsTorsionFree{α : Type u_1} :\nMonoid.IsTorsionFree (free_group α) ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem free_group.IsTorsionFree{n : Type u_1} {α : Type u_2} [Group α] [Fintype n] :\nMonoid.IsTorsionFree (free_group n α) ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem free_group.IsTorsionFree{α : Type u_1} (s : set α) :\nMonoid.IsTorsionFree (free_group s) ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem IsTorsionFree.free_group{α : Type u_1} [Fintype α] (tG : Monoid.is_torsion (free_group α)) :\nIsTorsionFree (free_group α) ",
        "parse-message": "unknown constant 'Monoid.is_torsion' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem free_group.IsTorsionFree{α : Type u} [free_group α] :\nMonoid.IsTorsionFree (free_group.of α) ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "free_group_torsion_free",
      "search_time": "1.4791829389869235",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H",
          "sim_score": "0.8580459356307983",
          "doc_string": "Subgroups of torsion-free groups are torsion-free."
        },
        {
          "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G",
          "sim_score": "0.8004929423332214",
          "doc_string": "A nontrivial torsion-free group is not torsion."
        },
        {
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.7987847924232483",
          "doc_string": "Direct products of torsion free groups are torsion free."
        },
        {
          "statement": "theorem add_monoid.is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.7854448556900024",
          "doc_string": "Direct products of additive torsion free groups are torsion free."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"A nontrivial torsion-free group is not torsion.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.not_torsion{G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion_free G → ¬monoid.is_torsion G := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Direct products of additive torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem add_monoid.is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) :\nadd_monoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Every free group is torsion free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every free group is torsion free",
      "codex_time": "5.630564228980802"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem free_group_torsion_free {α : Type} : Monoidₓ.IsTorsionFree (FreeGroup α) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Int.subgroup_isomorphic_int(h : AddSubgroup ℤ) (h : (0:ℤ) ∈ h) :\nNonempty (AddSubgroup.QuotientAddGroup h) ∧ AddSubgroup.QuotientAddGroup h ≃ₗ[ℤ] ℤ ",
        "parse-message": "failed to synthesize instance\n  Membership ℤ (AddSubgroup ℤ) (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem nonempty_int_subgroup_equiv_int{h : AddSubgroup ℤ} (hn : h ≠ ⊥) :\nh ≃ ℤ ",
        "parse-message": "overloaded, errors \n  application type mismatch\n    Equivₓ h\n  argument\n    h\n  has type\n    AddSubgroup ℤ : Type\n  but is expected to have type\n    Sort ?u.38 : Type ?u.38\n  \n  application type mismatch\n    Equiv h\n  argument\n    h\n  has type\n    AddSubgroup ℤ : Type\n  but is expected to have type\n    Sort ?u.9592 : Type ?u.9592 (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Int.subgroup.of_ne_empty_one_isom_int{h : AddSubgroup ℤ} (h : (1 : ℤ) ∈ h) :\n h ≃ ℤ ",
        "parse-message": "failed to synthesize instance\n  Membership ℤ (AddSubgroup ℤ) (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Int.nonempty_subgroup_injective(h : AddSubgroup ℤ) (h: ∃ (A : ℤ), A ∈ h) :\nInjective (@Int.add_group_hom_coe_nat : h → ℤ) ",
        "parse-message": "failed to synthesize instance\n  Membership ℤ (AddSubgroup ℤ) (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem subgroup.infinite_cyclic(h : subgroup ℤ) (hne : ¬ ∀ x, x ∈ h → x = 0) :\n∃ (A : ℤ), (∀(n : ℤ), n • A ∈ h) ∧ h ≃ₙ[AddMonoid ℤ] ℤ ",
        "parse-message": "<input>:2:38: expected token"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "integer_subgroups",
      "search_time": "1.4260498700023163",
      "ret-prompts": [
        {
          "statement": "theorem int.subgroup_cyclic (H : add_subgroup ℤ) : ∃ (a : ℤ), H = add_subgroup.closure {a}",
          "sim_score": "0.710217297077179",
          "doc_string": "Every subgroup of `ℤ` is cyclic."
        },
        {
          "statement": "theorem quotient_group.subgroup_eq_top_of_subsingleton {G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ⧸ H)) : H = ⊤",
          "sim_score": "0.5739960670471191",
          "doc_string": "If the quotient by a subgroup gives a singleton then the subgroup is the whole group."
        },
        {
          "statement": "theorem subgroup.subset_closure {G : Type u_1} [group G] {k : set G} : k ⊆ ↑(subgroup.closure k)",
          "sim_score": "0.5350345969200134",
          "doc_string": "The subgroup generated by a set includes the set."
        },
        {
          "statement": "theorem subgroup.ext {G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K",
          "sim_score": "0.5225922465324402",
          "doc_string": "Two subgroups are equal if they have the same elements."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Every subgroup of `ℤ` is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem int.subgroup_cyclic(H : add_subgroup ℤ) :\n∃ (a : ℤ), H = add_subgroup.closure {a} := \n\nNatural language version: \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group.\" Translate the natural language version to a Lean mathlib version:\n theorem quotient_group.subgroup_eq_top_of_subsingleton{G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ⧸ H)) :\nH = ⊤ := \n\nNatural language version: \"The subgroup generated by a set includes the set.\" Translate the natural language version to a Lean mathlib version:\n theorem subgroup.subset_closure{G : Type u_1} [group G] {k : set G} :\nk ⊆ ↑(subgroup.closure k) := \n\nNatural language version: \"Two subgroups are equal if they have the same elements.\" Translate the natural language version to a Lean mathlib version:\n theorem subgroup.ext{G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) :\nH = K := \n\nNatural language version: \"Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`",
      "codex_time": "9.994682027987437"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem integer_subgroups (H : AddSubgroup ℤ) : H.Carrier.Nonempty  →   ↥H ≃+ ℤ "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem is_integral_int_degree_of_eq{R : Type*} [integral_domain R] [Algebra ℚ R] (P : Polynomial R) (hp : ∀ R : R, 0 < R → R ∣ P.Coeff 0) (R) (hr : Polynomial.aeval R P = 0) :\nR.IsIntegral ",
        "parse-message": "<input>:1:141: expected ':'"
      },
      {
        "success": false,
        "statement": "theorem is_root_of_monic_of_integral₁{R : Type u} [comm_ring R] [is_domain R] {P₁ : Polynomial (ℤ[x])} {P₂ : Polynomial R} (h_int : P₁.IsIntegral) (h_eq : P₂.Coeff ↑(P₁.nat_degree) = P₁.Coeff ↑(P₁.nat_degree)) (h_roots : ∀ y, (y : ℚ) = 0 ∨ y ∣ ↑(P₂.leading",
        "parse-message": "<input>:1:256: unexpected end of input; expected ')'"
      },
      {
        "success": false,
        "statement": "theorem is_integer_of_is_root_of_int_coeff{P : Polynomial ℚ} (h_int_coeff : P.coeffs_int) {x : ℚ} (h_root : P.Eval x = 0) :\nis_rat_localization.integer x ",
        "parse-message": "invalid field 'coeffs_int', the environment does not contain 'Polynomial.coeffs_int'\n  P\nhas type\n  ℚ[X] (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_localization.is_integer_of_is_root_of_int{A : Type u_1} [comm_ring A] [NoZeroDivisors A] {P : Polynomial A} (hp : P.is_int) {R : A} (hr : P.Eval R = 0) :\nIsLocalization.IsInteger A R ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_integral_of_roots_integral{R : Type u_1} [comm_ring R] {P : Polynomial R} (hp : ∀ (i : ℕ), P.Coeff i ∈ @submonoid.to_submodule ℤ ℤ (submonoid.of ℤ 1) _) {R : ℚ} (hr : Polynomial.aeval R P = 0) : \nIsIntegral R ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "int_poly_rat_zeros_int",
      "search_time": "1.6466410249995533",
      "ret-prompts": [
        {
          "statement": "theorem num_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_fraction_ring.num A r ∣ p.coeff 0",
          "sim_score": "0.6362022161483765",
          "doc_string": " Rational root theorem part 1: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the numerator of `r` divides the constant coefficient"
        },
        {
          "statement": "theorem is_integer_of_is_root_of_monic {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_localization.is_integer A r",
          "sim_score": "0.6275410652160645",
          "doc_string": " Integral root theorem: if `r : f.codomain` is a root of a monic polynomial over the ufd `A`, then `r` is an integer"
        },
        {
          "statement": "theorem denom_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : ↑(is_fraction_ring.denom A r) ∣ p.leading_coeff",
          "sim_score": "0.6202014684677124",
          "doc_string": " Rational root theorem part 2: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the denominator of `r` divides the leading coefficient"
        },
        {
          "statement": "theorem polynomial.nat_degree_sub_eq_of_prod_eq {R : Type u} [semiring R] [no_zero_divisors R] {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) : ↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree)",
          "sim_score": "0.5798273086547852",
          "doc_string": "This lemma is useful for working with the `int_degree` of a rational function."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" Rational root theorem part 1: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the numerator of `r` divides the constant coefficient\" Translate the natural language version to a Lean mathlib version:\n theorem num_dvd_of_is_root{A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\nis_fraction_ring.num A r ∣ p.coeff 0 := \n\nNatural language version: \" Integral root theorem: if `r : f.codomain` is a root of a monic polynomial over the ufd `A`, then `r` is an integer\" Translate the natural language version to a Lean mathlib version:\n theorem is_integer_of_is_root_of_monic{A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\nis_localization.is_integer A r := \n\nNatural language version: \" Rational root theorem part 2: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the denominator of `r` divides the leading coefficient\" Translate the natural language version to a Lean mathlib version:\n theorem denom_dvd_of_is_root{A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\n↑(is_fraction_ring.denom A r) ∣ p.leading_coeff := \n\nNatural language version: \"This lemma is useful for working with the `int_degree` of a rational function.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.nat_degree_sub_eq_of_prod_eq{R : Type u} [semiring R] [no_zero_divisors R] {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) :\n↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree) := \n\nNatural language version: \"If the coefficients of a polynomial over rationals are integral, every rational root is integral.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If the coefficients of a polynomial over rationals are integral, every rational root is integral.",
      "codex_time": "8.817720086983172"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem int_poly_rat_zeros_int (p: Polynomial ℚ) : ∀ n: ℕ, IsIntegral ℚ (p.coeff n) →  ∀ x: ℚ, p.IsRoot x →  IsIntegral ℚ x "
  },
  {
    "parsed": [
      "theorem Nat.Ge.Prime{n : ℕ} (h : n > 1) : ∃ P : ℕ, Nat.Prime P ∧ 1 < P ∧ P ∣ n ",
      "theorem Nat.one_lt_prime_divisor{n : ℕ} (hn : 1 < n) :\n∃ P, Nat.Prime P ∧ P ∣ n ",
      "theorem Nat.exists_prime_factor (n : ℕ) (h : n > 1) :\n∃ P, Prime P ∧ P ∣ n ",
      "theorem Nat.ge_two.has_dvd_prime(n : ℕ) (h : 2 ≤ n) :\n∃ P : ℕ, Prime P ∧ P ∣ n ",
      "theorem Nat.exists_prime_divisor{n : ℕ} (h : n > 1) :\n∃ (P : ℕ), Nat.Prime P ∧ P ∣ n "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "theorem Nat.Ge.Prime{n : ℕ} (h : n > 1) : ∃ P : ℕ, Nat.Prime P ∧ 1 < P ∧ P ∣ n ",
        "code": "forall {n : Nat}, (GT.gt.{?_uniq.5} Nat Nat.hasLt n (OfNat.ofNat.{?_uniq.8} Nat 1 (instOfNatNat 1))) -> (Exists.{?_uniq.38} Nat (fun (P : Nat) => And (Nat.Prime P) (And (LT.lt.{?_uniq.42} Nat Nat.hasLt (OfNat.ofNat.{?_uniq.45} Nat 1 (instOfNatNat 1)) P) (Dvd.dvd.{?_uniq.66} Nat Nat.hasDvd P n))))"
      },
      {
        "success": true,
        "statement": "theorem Nat.one_lt_prime_divisor{n : ℕ} (hn : 1 < n) :\n∃ P, Nat.Prime P ∧ P ∣ n ",
        "code": "forall {n : Nat}, (LT.lt.{?_uniq.5} Nat Nat.hasLt (OfNat.ofNat.{?_uniq.8} Nat 1 (instOfNatNat 1)) n) -> (Exists.{?_uniq.43} Nat (fun (P : Nat) => And (Nat.Prime P) (Dvd.dvd.{?_uniq.48} Nat Nat.hasDvd P n)))"
      },
      {
        "success": true,
        "statement": "theorem Nat.exists_prime_factor (n : ℕ) (h : n > 1) :\n∃ P, Prime P ∧ P ∣ n ",
        "code": "forall (n : Nat) (h : GT.gt.{?_uniq.5} Nat Nat.hasLt n (OfNat.ofNat.{?_uniq.8} Nat 1 (instOfNatNat 1))), Exists.{?_uniq.38} Nat (fun (P : Nat) => And (Prime.{?_uniq.43} Nat (?_uniq.80 n h P) P) (Dvd.dvd.{?_uniq.70} Nat Nat.hasDvd P n))"
      },
      {
        "success": true,
        "statement": "theorem Nat.ge_two.has_dvd_prime(n : ℕ) (h : 2 ≤ n) :\n∃ P : ℕ, Prime P ∧ P ∣ n ",
        "code": "forall (n : Nat), (LE.le.{?_uniq.5} Nat Nat.hasLe (OfNat.ofNat.{?_uniq.8} Nat 2 (instOfNatNat 2)) n) -> (Exists.{?_uniq.39} Nat (fun (P : Nat) => And (Prime.{?_uniq.43} Nat (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) P) (Dvd.dvd.{?_uniq.58} Nat Nat.hasDvd P n)))"
      },
      {
        "success": true,
        "statement": "theorem Nat.exists_prime_divisor{n : ℕ} (h : n > 1) :\n∃ (P : ℕ), Nat.Prime P ∧ P ∣ n ",
        "code": "forall {n : Nat}, (GT.gt.{?_uniq.5} Nat Nat.hasLt n (OfNat.ofNat.{?_uniq.8} Nat 1 (instOfNatNat 1))) -> (Exists.{?_uniq.38} Nat (fun (P : Nat) => And (Nat.Prime P) (Dvd.dvd.{?_uniq.42} Nat Nat.hasDvd P n)))"
      }
    ],
    "number-parsed": 5,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "has_prime_factor",
      "search_time": "1.434510382998269",
      "ret-prompts": [
        {
          "statement": "theorem nat.eq_zero_of_dvd_of_lt {a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0",
          "sim_score": "0.6529487371444702",
          "doc_string": " If a small natural number is divisible by a larger natural number, the small number is zero."
        },
        {
          "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}",
          "sim_score": "0.593155562877655",
          "doc_string": "Every nonzero natural number has a unique prime factorization"
        },
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.5878391265869141",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        },
        {
          "statement": "theorem nat.prime.factorization {p : ℕ} (hp : nat.prime p) : p.factorization = finsupp.single p 1",
          "sim_score": "0.5869839191436768",
          "doc_string": "The only prime factor of prime `p` is `p` itself, with multiplicity `1`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If a small natural number is divisible by a larger natural number, the small number is zero.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.eq_zero_of_dvd_of_lt{a b : ℕ} (w : a ∣ b) (h : b < a) :\nb = 0 := \n\nNatural language version: \"Every nonzero natural number has a unique prime factorization\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_inj :\nset.inj_on nat.factorization {x : ℕ | x ≠ 0} := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"The only prime factor of prime `p` is `p` itself, with multiplicity `1`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.factorization{p : ℕ} (hp : nat.prime p) :\np.factorization = finsupp.single p 1 := \n\nNatural language version: \"Every natural number greater than `1` is divisible by a prime number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every natural number greater than `1` is divisible by a prime number.",
      "codex_time": "3.4960174949956127"
    },
    "grouped": [
      [
        "theorem Nat.Ge.Prime{n : ℕ} (h : n > 1) : ∃ P : ℕ, Nat.Prime P ∧ 1 < P ∧ P ∣ n "
      ],
      [
        "theorem Nat.one_lt_prime_divisor{n : ℕ} (hn : 1 < n) :\n∃ P, Nat.Prime P ∧ P ∣ n ",
        "theorem Nat.exists_prime_divisor{n : ℕ} (h : n > 1) :\n∃ (P : ℕ), Nat.Prime P ∧ P ∣ n "
      ],
      [
        "theorem Nat.exists_prime_factor (n : ℕ) (h : n > 1) :\n∃ P, Prime P ∧ P ∣ n ",
        "theorem Nat.ge_two.has_dvd_prime(n : ℕ) (h : 2 ≤ n) :\n∃ P : ℕ, Prime P ∧ P ∣ n "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem has_prime_factor (n: ℕ) : n > 1 → ∃ p: ℕ, Prime p ∧ (∃ d: ℕ, p * d = n) "
  },
  {
    "parsed": [
      "theorem Nat.Prime.no_sum_of_two{P Q : ℕ} (hp : Nat.Prime P) (hq : Nat.Prime Q) :\n2 < P → 2 < Q → P + Q ≠ 6 ",
      "theorem Nat.not_two_primes_six :\n∀ {A b : ℕ}, A ≠ 2 → b ≠ 2 → ∀ (h : A + b = 6), A ≤ 2 ∧ b ≤ 2 ",
      "theorem Nat.not_sum_of_primes_of_six :\n∀ (A b : ℕ), Nat.Prime A → Nat.Prime b → A + b ≠ 6 ",
      "theorem Nat.Prime.sq_add_sq_not_six(P : ℕ) [Fact (Nat.Prime P)] (hp : P % 4 = 1) :\n¬(∃ (A b : ℕ), A ^ 2 + b ^ 2 = P) "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "theorem Nat.Prime.no_sum_of_two{P Q : ℕ} (hp : Nat.Prime P) (hq : Nat.Prime Q) :\n2 < P → 2 < Q → P + Q ≠ 6 ",
        "code": "forall {P : Nat} {Q : Nat}, (Nat.Prime P) -> (Nat.Prime Q) -> (LT.lt.{?_uniq.13} Nat Nat.hasLt (OfNat.ofNat.{?_uniq.16} Nat 2 (instOfNatNat 2)) P) -> (LT.lt.{?_uniq.47} Nat Nat.hasLt (OfNat.ofNat.{?_uniq.50} Nat 2 (instOfNatNat 2)) Q) -> (Ne.{?_uniq.69} Nat (HAdd.hAdd.{?_uniq.73 ?_uniq.72 ?_uniq.71} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P Q) (OfNat.ofNat.{0} Nat 6 (instOfNatNat 6)))"
      },
      {
        "success": true,
        "statement": "theorem Nat.not_two_primes_six :\n∀ {A b : ℕ}, A ≠ 2 → b ≠ 2 → ∀ (h : A + b = 6), A ≤ 2 ∧ b ≤ 2 ",
        "code": "forall {A : Nat} {b : Nat}, (Ne.{?_uniq.7} Nat A (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Ne.{?_uniq.21} Nat b (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Eq.{?_uniq.28} Nat (HAdd.hAdd.{?_uniq.31 ?_uniq.30 ?_uniq.29} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) A b) (OfNat.ofNat.{?_uniq.34} Nat 6 (instOfNatNat 6))) -> (And (LE.le.{?_uniq.78} Nat Nat.hasLe A (OfNat.ofNat.{?_uniq.81} Nat 2 (instOfNatNat 2))) (LE.le.{?_uniq.99} Nat Nat.hasLe b (OfNat.ofNat.{?_uniq.102} Nat 2 (instOfNatNat 2))))"
      },
      {
        "success": true,
        "statement": "theorem Nat.not_sum_of_primes_of_six :\n∀ (A b : ℕ), Nat.Prime A → Nat.Prime b → A + b ≠ 6 ",
        "code": "forall (A : Nat) (b : Nat), (Nat.Prime A) -> (Nat.Prime b) -> (Ne.{?_uniq.10} Nat (HAdd.hAdd.{?_uniq.14 ?_uniq.13 ?_uniq.12} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) A b) (OfNat.ofNat.{0} Nat 6 (instOfNatNat 6)))"
      },
      {
        "success": false,
        "statement": "theorem Nat.not_sum_two_primes :\n¬ ∃ {A b : ℕ}, A.Prime ∧ b.Prime ∧ 6 = A + b ",
        "parse-message": "<input>:2:4: expected '(', '_' or identifier"
      },
      {
        "success": true,
        "statement": "theorem Nat.Prime.sq_add_sq_not_six(P : ℕ) [Fact (Nat.Prime P)] (hp : P % 4 = 1) :\n¬(∃ (A b : ℕ), A ^ 2 + b ^ 2 = P) ",
        "code": "forall (P : Nat) [inst._@._hyg.7 : Fact (Nat.Prime P)], (Eq.{?_uniq.8} Nat (HMod.hMod.{?_uniq.11 ?_uniq.10 ?_uniq.9} Nat Nat Nat (instHMod.{?_uniq.84} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.10} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{?_uniq.44} Nat 1 (instOfNatNat 1))) -> (Not (Exists.{?_uniq.106} Nat (fun (A : Nat) => Exists.{?_uniq.110} Nat (fun (b : Nat) => Eq.{?_uniq.114} Nat (HAdd.hAdd.{?_uniq.117 ?_uniq.116 ?_uniq.115} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HPow.hPow.{?_uniq.120 ?_uniq.119 ?_uniq.118} Nat Nat Nat (Monoid.HPow.{?_uniq.269} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) A (OfNat.ofNat.{?_uniq.119} Nat 2 (instOfNatNat 2))) (HPow.hPow.{?_uniq.146 ?_uniq.145 ?_uniq.144} Nat Nat Nat (Monoid.HPow.{?_uniq.330} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) b (OfNat.ofNat.{?_uniq.145} Nat 2 (instOfNatNat 2)))) P))))"
      }
    ],
    "number-parsed": 4,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "six_not_prime_sum",
      "search_time": "1.4358506849966943",
      "ret-prompts": [
        {
          "statement": "theorem real.sin_pi_div_six  : real.sin (real.pi / 6) = 1 / 2",
          "sim_score": "0.4190795421600342",
          "doc_string": "The sine of `π / 6` is `1 / 2`."
        },
        {
          "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p",
          "sim_score": "0.41275641322135925",
          "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`."
        },
        {
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
          "sim_score": "0.4100857973098755",
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**."
        },
        {
          "statement": "theorem unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) (no_factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬prime d) : a ∣ b * c → a ∣ c",
          "sim_score": "0.40865230560302734",
          "doc_string": " Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`. Compare `is_coprime.dvd_of_dvd_mul_right`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The sine of `π / 6` is `1 / 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem real.sin_pi_div_six :\nreal.sin (real.pi / 6) = 1 / 2 := \n\nNatural language version: \" Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.exists_infinite_primes(n : ℕ) :\n∃ (p : ℕ), n ≤ p ∧ nat.prime p := \n\nNatural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.sq_add_sq{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \" Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`. Compare `is_coprime.dvd_of_dvd_mul_right`.\" Translate the natural language version to a Lean mathlib version:\n theorem unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors{R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) (no_factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬prime d) :\na ∣ b * c → a ∣ c := \n\nNatural language version: \"Six is not the sum of two prime numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Six is not the sum of two prime numbers.",
      "codex_time": "6.6912566919927485"
    },
    "grouped": [
      [
        "theorem Nat.Prime.no_sum_of_two{P Q : ℕ} (hp : Nat.Prime P) (hq : Nat.Prime Q) :\n2 < P → 2 < Q → P + Q ≠ 6 "
      ],
      [
        "theorem Nat.not_two_primes_six :\n∀ {A b : ℕ}, A ≠ 2 → b ≠ 2 → ∀ (h : A + b = 6), A ≤ 2 ∧ b ≤ 2 "
      ],
      [
        "theorem Nat.not_sum_of_primes_of_six :\n∀ (A b : ℕ), Nat.Prime A → Nat.Prime b → A + b ≠ 6 "
      ],
      [
        "theorem Nat.Prime.sq_add_sq_not_six(P : ℕ) [Fact (Nat.Prime P)] (hp : P % 4 = 1) :\n¬(∃ (A b : ℕ), A ^ 2 + b ^ 2 = P) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem six_not_prime_sum : ¬ (∃ n m: Nat, Prime n ∧ Prime m ∧ n ≠ m ∧ 6 = n + m) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem is_torsion_free_of_finite{G : Type u_1} [Group G] [Fintype G] [IsTorsionFree : Monoid.IsTorsionFree G] :\nG ≃ (1 : G) ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem IsTorsionFree.finite_iff_trivial{G : Type u_1} [Group G] (tfG : Monoid.IsTorsionFree G) (FG : Fintype G) :\nG ≃ fin_zero ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem IsTorsionFree.fintype_card1_iff {G : Type u_1} [Group G] [Fintype G] (h : Monoid.IsTorsionFree G) :\nCard G = 1 ↔ is_unit G.0 ",
        "parse-message": "<input>:2:23: expected end of input"
      },
      {
        "success": false,
        "statement": "theorem IsTorsionFree.Fintype {G : Type u_1} [Group G] [Fintype G] :\nMonoid.IsTorsionFree G → trivial G ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem IsTorsionFree.trivial_finite{G : Type u_1} [Group G] [Fintype G] [hN : Nontrivial G] :\nMonoid.IsTorsionFree G → ⊥ ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "fin_torsionfree",
      "search_time": "1.4408756789925974",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H",
          "sim_score": "0.8230506181716919",
          "doc_string": "Subgroups of torsion-free groups are torsion-free."
        },
        {
          "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G",
          "sim_score": "0.8135049939155579",
          "doc_string": "A nontrivial torsion group is not torsion-free."
        },
        {
          "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G",
          "sim_score": "0.8007985353469849",
          "doc_string": "A nontrivial torsion-free group is not torsion."
        },
        {
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.7504584789276123",
          "doc_string": "Direct products of torsion free groups are torsion free."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.subgroup{G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"A nontrivial torsion group is not torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion.not_torsion_free{G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion G → ¬monoid.is_torsion_free G := \n\nNatural language version: \"A nontrivial torsion-free group is not torsion.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.not_torsion{G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion_free G → ¬monoid.is_torsion G := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem is_torsion_free.prod{η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"A finite torsion-free group is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finite torsion-free group is trivial",
      "codex_time": "6.756425740983104"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem fin_torsionfree {G: Type _}[Groupₓ G][Finite G] : Monoidₓ.IsTorsionFree G → IsSubgroup.Trivial G "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Rat.injective_add_hom_of_injective_nat_hom⦃α⦄{α : Type u} [AddGroup α] (F : ℚ →+ α) :\nFunction.Injective (λ x : ℚ, ⇑F (↑x : ℚ)) → F = 0 ",
        "parse-message": "<input>:1:50: expected ':'"
      },
      {
        "success": false,
        "statement": "theorem AddGroup.nat_abs_of_hom_of_dvd{α : Type u} {β : Type v} [AddGroup α] [AddGroup β] \n  {F : α →+ β} (hf : F 0 = 0) (hd : Surjective F) (h : β) :\nnat_abs (↥(F h) : ℤ) ∣ ↥h ",
        "parse-message": "failed to synthesize instance\n  AddZeroClassₓ α (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Subtype.coe_injective$(P : ℚ → prop) [IsAddGroupHom (Coe : (Σ A : ℚ, P A) → ℚ)] {Q : ℚ} :\n∀  R s, Coe R = Coe s → R = s ",
        "parse-message": "<input>:1:29: expected ':'"
      },
      {
        "success": false,
        "statement": "theorem AddMonoidHom.map_Cantor_rational_embedding_trivial'{α : Type u_5} {β : Type u_6} [AddGroup α] [AddMonoid β] (F : α →+ β) [IsAddGroupHom F] :\n⇑F (Cantor_rational_embedding R) = ⇑F R ",
        "parse-message": "unknown universe level 'u_5' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_add_group_hom_of_injection_int{α : Type u_1} [add_comm_group α] {F : α →ₗ[ℚ] ℤ} (hf : Function.Injective F) : IsAddGroupHom F ",
        "parse-message": "unknown identifier 'add_comm_group' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "hom_rat_Z_trivial",
      "search_time": "1.4669762930134311",
      "ret-prompts": [
        {
          "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0",
          "sim_score": "0.7258538603782654",
          "doc_string": "An additive group homomorphism is injective if its kernel is trivial."
        },
        {
          "statement": "theorem is_add_group_hom.map_zero {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0",
          "sim_score": "0.7063751220703125",
          "doc_string": "An additive group homomorphism sends 0 to 0."
        },
        {
          "statement": "theorem map_zsmul {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ℤ) (g : G) : ⇑f (n • g) = n • ⇑f g",
          "sim_score": "0.6773562431335449",
          "doc_string": "Additive group homomorphisms preserve integer scaling."
        },
        {
          "statement": "theorem add_monoid_hom.map_zsmul {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g : α) (n : ℤ) : ⇑f (n • g) = n • ⇑f g",
          "sim_score": "0.6773562431335449",
          "doc_string": "Additive group homomorphisms preserve integer scaling."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"An additive group homomorphism is injective if its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem is_add_group_hom.injective_iff{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 0 → a = 0 := \n\nNatural language version: \"An additive group homomorphism sends 0 to 0.\" Translate the natural language version to a Lean mathlib version:\n theorem is_add_group_hom.map_zero{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nf 0 = 0 := \n\nNatural language version: \"Additive group homomorphisms preserve integer scaling.\" Translate the natural language version to a Lean mathlib version:\n theorem map_zsmul{G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ℤ) (g : G) :\n⇑f (n • g) = n • ⇑f g := \n\nNatural language version: \"Additive group homomorphisms preserve integer scaling.\" Translate the natural language version to a Lean mathlib version:\n theorem add_monoid_hom.map_zsmul{α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g : α) (n : ℤ) :\n⇑f (n • g) = n • ⇑f g := \n\nNatural language version: \"Any homomorphism from the additive group of rational numbers to `ℤ` is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Any homomorphism from the additive group of rational numbers to `ℤ` is trivial",
      "codex_time": "4.650995299016358"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem hom_rat_Z_trivial (f : ℚ → ℤ) : IsAddGroupHom f →  ∀ x: ℚ, f x = 0 "
  },
  {
    "parsed": [
      "theorem finite_division_ring.field (K : Type u) [DivisionRing K] [Fintype K] :\nField K ",
      "theorem Finite.division_ring_is_field{K : Type u} [DivisionRing K] [Fintype K] :\nField K "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem FiniteDimensional.fd_is_field{K : Type u} [fd_char_0 K] [DivisionRing K] [FiniteDimensional K K] :\nfield K ",
        "parse-message": "unknown identifier 'fd_char_0' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem finite_division_ring.field (K : Type u) [DivisionRing K] [Fintype K] :\nField K ",
        "code": "forall (K : Type.{u}) [inst._@._hyg.5 : DivisionRing.{?_uniq.5} K] [inst._@._hyg.9 : Fintype.{?_uniq.9} K], Field.{?_uniq.12} K"
      },
      {
        "success": false,
        "statement": "theorem finite_division_ring.to_field(K : Type u) [DivisionRing K] (Card : Cardinal.{u}) [Fintype K] [Cardinal.Fintype K Card] :\nfield K ",
        "parse-message": "parsed to  (  K :  Type  u ) ->  [  DivisionRing  K ] ->  (  Card :  Cardinal .{  u } ) ->  [  Fintype  K ] ->  [  Cardinal.Fintype  K Card ] ->  field  K; error while parsing as theorem: <input>:1:68: expected ')'"
      },
      {
        "success": true,
        "statement": "theorem Finite.division_ring_is_field{K : Type u} [DivisionRing K] [Fintype K] :\nField K ",
        "code": "forall {K : Type.{u}} [inst._@._hyg.5 : DivisionRing.{?_uniq.5} K] [inst._@._hyg.9 : Fintype.{?_uniq.9} K], Field.{?_uniq.12} K"
      },
      {
        "success": false,
        "statement": "theorem is_field_division_ring_finite : ∀ (K : Type u) [DivisionRing K], @FiniteDimensional K _ → Field K ",
        "parse-message": "type expected\nfailed to synthesize instance\n  CoeSort ([_inst_1 : DivisionRing K] → [_inst_2 : AddCommGroupₓ ?m.10] → [_inst_3 : Module K ?m.10] → Prop) ?m.16 (during elaboration)"
      }
    ],
    "number-parsed": 2,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "fin_int_domain_ring_is_field",
      "search_time": "1.5487677009950858",
      "ret-prompts": [
        {
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s",
          "sim_score": "0.6756068468093872",
          "doc_string": "A subfield is closed under division."
        },
        {
          "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1",
          "sim_score": "0.6545361280441284",
          "doc_string": "A division_ring is one-dimensional as a vector space over itself."
        },
        {
          "statement": "theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S",
          "sim_score": "0.6345528364181519",
          "doc_string": "An intermediate field is closed under division."
        },
        {
          "statement": "theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s",
          "sim_score": "0.62082839012146",
          "doc_string": "A subfield is closed under multiplication."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.div_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"A division_ring is one-dimensional as a vector space over itself.\" Translate the natural language version to a Lean mathlib version:\n theorem finite_dimensional.finrank_self(K : Type u) [division_ring K] :\nfinite_dimensional.finrank K K = 1 := \n\nNatural language version: \"An intermediate field is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem intermediate_field.div_mem{K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} :\nx ∈ S → y ∈ S → x / y ∈ S := \n\nNatural language version: \"A subfield is closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.mul_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x * y ∈ s := \n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite division ring is a field.",
      "codex_time": "5.01110641399282"
    },
    "grouped": [
      [
        "theorem finite_division_ring.field (K : Type u) [DivisionRing K] [Fintype K] :\nField K ",
        "theorem Finite.division_ring_is_field{K : Type u} [DivisionRing K] [Fintype K] :\nField K "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem fin_int_domain_ring_is_field {R : Type _} [Ringₓ R][IsDomain R] [Finite R] : Field R "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem is_compact_fintype{α : Type u} [TopologicalSpace α] (h : Fintype α) :\nis_compact α ",
        "parse-message": "unknown identifier 'is_compact' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem finite_iff_compact{α : Type u} [TopologicalSpace α] : Finite α ↔ is_compact α ",
        "parse-message": "unknown identifier 'is_compact' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Finite.IsCompact{α : Type u} [TopologicalSpace α] (h : Finite α) :\nis_compact α ",
        "parse-message": "unknown identifier 'is_compact' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Finset.finite_topological_space_is_compact {α : Type*} [t : TopologicalSpace α]  (b : Finset α) :\nis_compact b ",
        "parse-message": "unknown identifier 'is_compact' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_compact.Finite{α : Type*} [TopologicalSpace α] [Fintype α] : is_compact α ",
        "parse-message": "unknown identifier 'is_compact' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "finite_space_compact",
      "search_time": "1.4327223660075106",
      "ret-prompts": [
        {
          "statement": "theorem is_compact_of_finite_subcover {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_compact s",
          "sim_score": "0.676864504814148",
          "doc_string": "A set `s` is compact if for every open cover of `s`, there exists a finite subcover."
        },
        {
          "statement": "theorem is_compact.elim_finite_subcover_image {α : Type u} {ι : Type u_1} [topological_space α] {s : set α} {b : set ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), i ∈ b → is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) : ∃ (b' : set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i",
          "sim_score": "0.6767893433570862",
          "doc_string": "For every open cover of a compact set, there exists a finite subcover."
        },
        {
          "statement": "theorem is_compact.elim_finite_subcover {α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) : ∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i",
          "sim_score": "0.6767893433570862",
          "doc_string": "For every open cover of a compact set, there exists a finite subcover."
        },
        {
          "statement": "theorem is_compact_iff_finite_subcover {α : Type u} [topological_space α] {s : set α} : is_compact s ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)",
          "sim_score": "0.65172278881073",
          "doc_string": " A set `s` is compact if and only if for every open cover of `s`, there exists a finite subcover."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A set `s` is compact if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact_of_finite_subcover{α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) :\nis_compact s := \n\nNatural language version: \"For every open cover of a compact set, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact.elim_finite_subcover_image{α : Type u} {ι : Type u_1} [topological_space α] {s : set α} {b : set ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), i ∈ b → is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) :\n∃ (b' : set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i := \n\nNatural language version: \"For every open cover of a compact set, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact.elim_finite_subcover{α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) :\n∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i := \n\nNatural language version: \" A set `s` is compact if and only if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem is_compact_iff_finite_subcover{α : Type u} [topological_space α] {s : set α} :\nis_compact s ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i) := \n\nNatural language version: \"Every finite topological space is compact\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite topological space is compact",
      "codex_time": "4.463791654998204"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem finite_space_compact {X : Type _}[TopologicalSpace X][Finite X] : CompactSpace X "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem free_group.surjective_injective_of_finitely_generated{G : Type u} [Fintype G] [Group G] {F : free_group G →* free_group G} (hf : Function.Surjective ⇑F) :\nFunction.Injective ⇑F ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem free_group.surj_inj{α : Type u} {G : Type u_1} [Group G] (F : free_group α →* G) (hf : Function.Surjective ⇑F) (h : free_group.is_of_fintype α) :\nFunction.Injective ⇑F ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Hom.injective_of_surjective_of_fg_free{α : Type u} (G : Type u_1) [Group G] {F : G →* G} (hf : Function.Surjective ⇑F) {g : free_group α →* G} (hg : F = g) :\nFunction.Injective ⇑g ",
        "parse-message": "failed to synthesize instance\n  MulOneClassₓ G (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem free_group.injective_of_surjective [Fintype α] {G : Type u} [Group G] (F : free_group.π α →* G) :\nFunction.Surjective F → Function.Injective F ",
        "parse-message": "unknown identifier 'α' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem free_group.surjective_injective{α : Type u} (n : ℕ) (F : free_group α →+* free_group α) (hf : Function.Surjective ⇑F) :\nFunction.Injective ⇑F ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "freegroup_hopfian",
      "search_time": "1.4647069969796576",
      "ret-prompts": [
        {
          "statement": "theorem free_group.of_injective {α : Type u} : function.injective free_group.of",
          "sim_score": "0.6470739841461182",
          "doc_string": "The canonical injection from the type to the free group is an injection."
        },
        {
          "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1",
          "sim_score": "0.6357327103614807",
          "doc_string": "A group homomorphism is injective iff its kernel is trivial."
        },
        {
          "statement": "theorem free_group.ext_hom {α : Type u} {G : Type u_1} [group G] (f g : free_group α →* G) (h : ∀ (a : α), ⇑f (free_group.of a) = ⇑g (free_group.of a)) : f = g",
          "sim_score": "0.5912977457046509",
          "doc_string": " Two homomorphisms out of a free group are equal if they are equal on generators.  See note [partially-applied ext lemmas]."
        },
        {
          "statement": "theorem nilpotent_of_surjective {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) : group.is_nilpotent G'",
          "sim_score": "0.5858901143074036",
          "doc_string": "The range of a surjective homomorphism from a nilpotent group is nilpotent"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The canonical injection from the type to the free group is an injection.\" Translate the natural language version to a Lean mathlib version:\n theorem free_group.of_injective{α : Type u} :\nfunction.injective free_group.of := \n\nNatural language version: \"A group homomorphism is injective iff its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem is_group_hom.injective_iff{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 1 → a = 1 := \n\nNatural language version: \" Two homomorphisms out of a free group are equal if they are equal on generators.  See note [partially-applied ext lemmas].\" Translate the natural language version to a Lean mathlib version:\n theorem free_group.ext_hom{α : Type u} {G : Type u_1} [group G] (f g : free_group α →* G) (h : ∀ (a : α), ⇑f (free_group.of a) = ⇑g (free_group.of a)) :\nf = g := \n\nNatural language version: \"The range of a surjective homomorphism from a nilpotent group is nilpotent\" Translate the natural language version to a Lean mathlib version:\n theorem nilpotent_of_surjective{G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) :\ngroup.is_nilpotent G' := \n\nNatural language version: \"Every surjective homomorphism from a finitely generated free group to itself is injective\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every surjective homomorphism from a finitely generated free group to itself is injective",
      "codex_time": "9.860292875993764"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem freegroup_hopfian {α : Type _} [Finite α]: (f: FreeGroup α → FreeGroup α) → (IsGroupHom f) → f.Surjective → f.Injective "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem is_bounded_polynomial_iff_degree_le_zero(R : Type u_1) [LinearOrderedField R] (t : Polynomial R) :\nis_bounded ((@Polynomial.Eval _ _ R) t) ↔ Polynomial.degree t ≤ 0 ",
        "parse-message": "unknown identifier 'is_bounded' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem unbounded_of_degree_pos{R : Type u} [nonzero_comm_ring R] {F : Type*} [field F] (A : Polynomial R) (h : Polynomial.degree A > 0) :\n∃c : ℚ, c > 0 ∧ ∀x:Polynomial R, ∀b : F, Polynomial.Eval₂ A x b ≤ c ",
        "parse-message": "unknown identifier 'nonzero_comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Polynomial.unbounded_of_degree_pos{R : Type u} [discrete_field R] {P : Polynomial R} (hp0 : P.degree > 0) :\n∀ x : R, ∃ y : R, x < y ∧ P y ≠ 0 ",
        "parse-message": "unknown identifier 'discrete_field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem unbounded_polynomial_of_degree_pos (F : Polynomial ℝ) {n : ℕ} (hn : 0 < n) :\nUnbounded (λ (x : ℝ), F.Eval x) ",
        "parse-message": "unknown identifier 'Unbounded' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem ne_top_then_supr_not_is_lub{α : Type u} [TopologicalSpace α] [completely_lattice α] (A : β) (F : β → α) :\n¬ is_lub (Supr F) (F '' set.Univ) ",
        "parse-message": "<input>:2:24: missing end of character literal"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "polys_unbounded",
      "search_time": "1.434766952006612",
      "ret-prompts": [
        {
          "statement": "theorem continuous_map_mem_polynomial_functions_closure (a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) : f ∈ (polynomial_functions (set.Icc a b)).topological_closure",
          "sim_score": "0.5175106525421143",
          "doc_string": "An alternative statement of Weierstrass' theorem.  Every real-valued continuous function on `[a,b]` is a uniform limit of polynomials."
        },
        {
          "statement": "theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ≤ (multiset.map polynomial.degree t).sum",
          "sim_score": "0.5134747624397278",
          "doc_string": "The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥."
        },
        {
          "statement": "theorem polynomial_functions_closure_eq_top (a b : ℝ) : (polynomial_functions (set.Icc a b)).topological_closure = ⊤",
          "sim_score": "0.5014804005622864",
          "doc_string": "The **Weierstrass Approximation Theorem**: polynomials functions on `[a, b] ⊆ ℝ` are dense in `C([a,b],ℝ)`  (While we could deduce this as an application of the Stone-Weierstrass theorem, our proof of that relies on the fact that `abs` is in the closure of polynomials on `[-M, M]`, so we may as well get this done first.)"
        },
        {
          "statement": "theorem filter.tendsto_pow_at_top {α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top",
          "sim_score": "0.48543989658355713",
          "doc_string": " The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"An alternative statement of Weierstrass' theorem.  Every real-valued continuous function on `[a,b]` is a uniform limit of polynomials.\" Translate the natural language version to a Lean mathlib version:\n theorem continuous_map_mem_polynomial_functions_closure(a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) :\nf ∈ (polynomial_functions (set.Icc a b)).topological_closure := \n\nNatural language version: \"The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial.degree_multiset_prod_le{R : Type u} [comm_semiring R] (t : multiset (polynomial R)) :\nt.prod.degree ≤ (multiset.map polynomial.degree t).sum := \n\nNatural language version: \"The **Weierstrass Approximation Theorem**: polynomials functions on `[a, b] ⊆ ℝ` are dense in `C([a,b],ℝ)`  (While we could deduce this as an application of the Stone-Weierstrass theorem, our proof of that relies on the fact that `abs` is in the closure of polynomials on `[-M, M]`, so we may as well get this done first.)\" Translate the natural language version to a Lean mathlib version:\n theorem polynomial_functions_closure_eq_top(a b : ℝ) :\n(polynomial_functions (set.Icc a b)).topological_closure = ⊤ := \n\nNatural language version: \" The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`.\" Translate the natural language version to a Lean mathlib version:\n theorem filter.tendsto_pow_at_top{α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) :\nfilter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top := \n\nNatural language version: \"Every polynomial of positive degree over reals is unbounded.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every polynomial of positive degree over reals is unbounded.",
      "codex_time": "6.2306809650035575"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem polys_unbounded (p: Polynomial ℝ) : p.degree > 0 → ∀ m: ℝ, ∃ x: ℝ, p.eval x  > m ∨ p.eval x < -m  "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem field_hom.injective_or_trivial{K : Type u_25} [field K] [unit_group K] {F : Type v_111} [field F] [unit_group F] {F : K →+* F} (hf : ∀ (A ∈ F), ∃ k : K, A = F k) :\nFunction.Injective F ∨ Function.Surjective F ",
        "parse-message": "<input>:1:146: expected ')'"
      },
      {
        "success": false,
        "statement": "theorem field.hom_eq_one_of_injective{F₁ : Type u_1} {F₂ : Type u_4} [field F₁] [field F₂] {F : F₁ →+* F₂} (h : ∀ x y, F x = F y → x = y) :\nFunction.Injective F ",
        "parse-message": "unknown universe level 'u_4' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem field.hom_injective_or_trivial{α : Type u} {β : Type v} [field α] [field β] {F : α →+* β} (hf : F ≠ 0) :\nFunction.Injective F ∨ F = 0 ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem AlgHom.injective_or_trivial{A : Type u_1} {b : Type u_2} {K : Type u_3} [field K] [integral_domain A] [integral_domain b] [Algebra K A] [Algebra K b] {σ : A →+* b} (h : σ.is_algebra_map) :\nFunction.Injective (⇑σ) ∨ Function.Surjective (⇑σ) ",
        "parse-message": "<input>:1:159: expected identifier"
      },
      {
        "success": false,
        "statement": "theorem is_field_hom.injective_or_trivial{K : Type u} {L : Type v} [field K] [field L] {τ : K →+* L} (h : is_field_hom τ) :\nFunction.Injective τ ∨ (∀ (A : K), A ≠ 0 → τ A = 0) ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "field_hom_inj_or_trivial",
      "search_time": "1.4498521750210784",
      "ret-prompts": [
        {
          "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1",
          "sim_score": "0.6868539452552795",
          "doc_string": "A group homomorphism is injective iff its kernel is trivial."
        },
        {
          "statement": "theorem ring_hom.eq_on_field_closure {K : Type u} {L : Type v} [field K] [field L] {f g : K →+* L} {s : set K} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(subfield.closure s)",
          "sim_score": "0.6491084694862366",
          "doc_string": "If two ring homomorphisms are equal on a set, then they are equal on its subfield closure."
        },
        {
          "statement": "theorem linear_map.ker_eq_bot_of_cancel {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [semiring R] [semiring R₂] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) : f.ker = ⊥",
          "sim_score": "0.6350299715995789",
          "doc_string": "A monomorphism is injective."
        },
        {
          "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0",
          "sim_score": "0.6343168020248413",
          "doc_string": "An additive group homomorphism is injective if its kernel is trivial."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A group homomorphism is injective iff its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem is_group_hom.injective_iff{α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 1 → a = 1 := \n\nNatural language version: \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure.\" Translate the natural language version to a Lean mathlib version:\n theorem ring_hom.eq_on_field_closure{K : Type u} {L : Type v} [field K] [field L] {f g : K →+* L} {s : set K} (h : set.eq_on ⇑f ⇑g s) :\nset.eq_on ⇑f ⇑g ↑(subfield.closure s) := \n\nNatural language version: \"A monomorphism is injective.\" Translate the natural language version to a Lean mathlib version:\n theorem linear_map.ker_eq_bot_of_cancel{R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [semiring R] [semiring R₂] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) :\nf.ker = ⊥ := \n\nNatural language version: \"An additive group homomorphism is injective if its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem is_add_group_hom.injective_iff{α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 0 → a = 0 := \n\nNatural language version: \"A homomorphism between fields is either injective or trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A homomorphism between fields is either injective or trivial.",
      "codex_time": "8.774585238017607"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem field_hom_inj_or_trivial {F F' : Type _} [Field F] [Field F'] : ∀ ϕ : F →+* F', ϕ.toFun.Injective ∨ (∀ x : F, ϕ x = 0) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem monotone_stabilises_noetherian{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] (h : IsNoetherian R m) :\n∀ {F : ℕ → Submodule R m}, Monotone F → ∃ N : ℕ, ∀ {n : ℕ}, n ≥ N → F n = F (n + 1) ",
        "parse-message": "unknown identifier 'module' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem final_segment_of_nhds_of_is_noetherian{α : Type*} [CompleteLinearOrder α] [TopologicalSpace α] (A : α) (x : ℝ⁺) (ha : IsNoetherian (𝕜 ⊛ 𝕜⁻¹) ℝ) :\nis_open (λ (t : α), x - (A - t)) ",
        "parse-message": "failed to synthesize instance\n  HasPosPart Type (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_noetherian_iff'{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] :\nIsNoetherian R m ↔ ∀ (F : ℕ →o Submodule R m), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑F n = ⇑F m ",
        "parse-message": "unknown identifier 'module' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem noetherian_imp_stable_forall{R : Type u_1} {m : Type u_2} [comm_ring R] [add_comm_group m] [module R m] (h : IsNoetherian R m) (P Q : Type u_3) (F : m → P) (g : m → Q) :\n∀ (xs ys : set m), Finite xs →\nFinite ys →\nStrictMono gx →\ny ⊓ (x ⊔ K) = ∅ →\nFinite {m | m ∈ s} = False → \n∃ (m : m), (",
        "parse-message": "<input>:7:12: unexpected end of input; expected ')', '_', '↑' or identifier"
      },
      {
        "success": false,
        "statement": "theorem noetherian_stabilization{R : Type u_1} {m : Type u_2} [ο : Semiring R] [n : AddCommMonoid m] [m : module R m] [noetherian : IsNoetherian R m] {F : ℕ →o Submodule R m} (hf : order_preserving F) :\n∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → F m = F n ",
        "parse-message": "unknown identifier 'module' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "noetherian_implies_ascending_chain_condition",
      "search_time": "1.4387332439946476",
      "ret-prompts": [
        {
          "statement": "theorem monotone_stabilizes_iff_noetherian {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (∀ (f : ℕ →o submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_noetherian R M",
          "sim_score": "0.9016166925430298",
          "doc_string": "A module is Noetherian iff every increasing chain of submodules stabilizes."
        },
        {
          "statement": "theorem monotone_stabilizes_iff_artinian {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (∀ (f : ℕ →o (submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_artinian R M",
          "sim_score": "0.7797067761421204",
          "doc_string": "A module is Artinian iff every decreasing chain of submodules stabilizes."
        },
        {
          "statement": "theorem well_founded_gt_exact_sequence {α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [preorder β] [partial_order γ] (h₁ : well_founded gt) (h₂ : well_founded gt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) : well_founded gt",
          "sim_score": "0.698657751083374",
          "doc_string": "A generalization of the theorem that if `N` is a submodule of `M` and  `N` and `M / N` are both Noetherian, then `M` is Noetherian."
        },
        {
          "statement": "theorem is_noetherian_def {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M ↔ ∀ (s : submodule R M), s.fg",
          "sim_score": "0.6557018756866455",
          "doc_string": "An R-module is Noetherian iff all its submodules are finitely-generated."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A module is Noetherian iff every increasing chain of submodules stabilizes.\" Translate the natural language version to a Lean mathlib version:\n theorem monotone_stabilizes_iff_noetherian{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] :\n(∀ (f : ℕ →o submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_noetherian R M := \n\nNatural language version: \"A module is Artinian iff every decreasing chain of submodules stabilizes.\" Translate the natural language version to a Lean mathlib version:\n theorem monotone_stabilizes_iff_artinian{R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] :\n(∀ (f : ℕ →o (submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_artinian R M := \n\nNatural language version: \"A generalization of the theorem that if `N` is a submodule of `M` and  `N` and `M / N` are both Noetherian, then `M` is Noetherian.\" Translate the natural language version to a Lean mathlib version:\n theorem well_founded_gt_exact_sequence{α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [preorder β] [partial_order γ] (h₁ : well_founded gt) (h₂ : well_founded gt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) :\nwell_founded gt := \n\nNatural language version: \"An R-module is Noetherian iff all its submodules are finitely-generated.\" Translate the natural language version to a Lean mathlib version:\n theorem is_noetherian_def{R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] :\nis_noetherian R M ↔ ∀ (s : submodule R M), s.fg := \n\nNatural language version: \"Every ascending chain of sub-modules of a Noetherian module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every ascending chain of sub-modules of a Noetherian module eventually stabilises.",
      "codex_time": "10.447741597978165"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem noetherian_implies_ascending_chain_condition {R M : Type _} [Ringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ n : ℕ, ∀ m : ℕ, n < m → f n = f m "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem DifferentiableAt.ContinuousAt{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : set ℝ} {x : ℝ} {F : ℝ → E} (h_dif_f : DifferentiableWithinAt ℝ F s x) :\nContinuousWithinAt F s x ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Differentiable.Continuous{α : Type u} {β : Type v} [UniformSpace α] [TopologicalSpace β] {F : α → β} {A : α} (hf : Differentiable F A) :\nContinuous (F A) ",
        "parse-message": "application type mismatch\n  @Differentiable F\nargument\n  F\nhas type\n  α → β : Type (max u v)\nbut is expected to have type\n  Type ?u.26 : Type (?u.26 + 1) (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem DifferentiableOn.ContinuousOn{α : Type u} {β : Type v} [TopologicalSpace α] [TopologicalSpace β] {s : set α} {F : α → β} (h : DifferentiableOn α β F s) :\nContinuousOn s F ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem diff_continuous{E : Type u} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} (hf : Differentiable F) :\nContinuous F ",
        "parse-message": "application type mismatch\n  @Differentiable F\nargument\n  F\nhas type\n  ℝ → E : Type u\nbut is expected to have type\n  Type ?u.101 : Type (?u.101 + 1) (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem DifferentiableAt.Continuous{F : ℝ → ℝ} {A : ℝ} (h : DifferentiableAt F A) :\nContinuousAt F A ",
        "parse-message": "application type mismatch\n  @DifferentiableAt F\nargument\n  F\nhas type\n  ℝ → ℝ : Type\nbut is expected to have type\n  Type ?u.12 : Type (?u.12 + 1) (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "differentiability_implies_continuity",
      "search_time": "1.448735445010243",
      "ret-prompts": [
        {
          "statement": "theorem continuous_at_of_locally_lipschitz {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), has_dist.dist y x < r → has_dist.dist (f y) (f x) ≤ K * has_dist.dist y x) : continuous_at f x",
          "sim_score": "0.6264367699623108",
          "doc_string": "If a function is locally Lipschitz around a point, then it is continuous at this point."
        },
        {
          "statement": "theorem has_deriv_at_interval_left_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) : has_deriv_within_at f e (set.Ici a) a",
          "sim_score": "0.6016049981117249",
          "doc_string": " If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the right at `a`."
        },
        {
          "statement": "theorem has_deriv_at_interval_right_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) : has_deriv_within_at f e (set.Iic a) a",
          "sim_score": "0.5962556600570679",
          "doc_string": " If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the left at `a`."
        },
        {
          "statement": "theorem lipschitz_with.continuous {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : continuous f",
          "sim_score": "0.5795943737030029",
          "doc_string": "A Lipschitz function is continuous"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If a function is locally Lipschitz around a point, then it is continuous at this point.\" Translate the natural language version to a Lean mathlib version:\n theorem continuous_at_of_locally_lipschitz{α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), has_dist.dist y x < r → has_dist.dist (f y) (f x) ≤ K * has_dist.dist y x) :\ncontinuous_at f x := \n\nNatural language version: \" If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the right at `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem has_deriv_at_interval_left_endpoint_of_tendsto_deriv{E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) :\nhas_deriv_within_at f e (set.Ici a) a := \n\nNatural language version: \" If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the left at `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem has_deriv_at_interval_right_endpoint_of_tendsto_deriv{E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) :\nhas_deriv_within_at f e (set.Iic a) a := \n\nNatural language version: \"A Lipschitz function is continuous\" Translate the natural language version to a Lean mathlib version:\n theorem lipschitz_with.continuous{α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) :\ncontinuous f := \n\nNatural language version: \"Differentiability implies continuity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Differentiability implies continuity.",
      "codex_time": "6.055595788988285"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem differentiability_implies_continuity [TopologicalSpace ℝ] : ∀ f : ℝ → ℝ, Differentiable ℝ f → Continuous f "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem euclidean_triangle.angle_add_angle_add_angle_eq_twopi{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {P1 P2 P3 : P} (ha : euclidean_triangle.is_angle P1 P2 P3) :\nEuclideanGeometry.Angle P1 P2 P3 + EuclideanGeometry.Angle P2 P3 P1 + EuclideanGeometry.Angle P3 P1 P2 =",
        "parse-message": "<input>:2:104: unexpected end of input"
      },
      {
        "success": false,
        "statement": "theorem EuclideanGeometry.angle_sum_eq2Pi{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [MetricSpace P] [NormedAddTorsor V P] {P1 P2 P3 : P} :\nEuclideanGeometry.Angle P1 P2 P3 + EuclideanGeometry.Angle P2 P3 P1 + EuclideanGeometry.Angle P3 P1 P2 = 2 * Real.Pi ",
        "parse-message": "unknown identifier 'EuclideanGeometry.Angle' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem EuclideanGeometry.triangle_angle_sum_eq_tworightangles(α β γ : ℝ) (hα : α < Real.Pi) (hβ : β < Real.Pi) (hγ : γ < Real.Pi) (hab : α + β > Real.Pi) (hbc : β + γ > Real.Pi) : α + β + γ = ↑(Real.Int 2) * ↑Real.Pi ",
        "parse-message": "unknown constant 'Real.Pi' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem InnerProductGeometry.angle_sum_of_linear_independent{V : Type u_1} [InnerProductSpace ℝ V] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (x y : V) (hxy : 0 < inner_product x y) (hx : x ≠ 0) (hy : y ≠ 0) :\nInnerProductGeometry.Angle x y + InnerProductGeometry.Angle y x + InnerProductGeometry.Angle x y = 2 * ↑Real.Pi ",
        "parse-message": "unknown identifier 'inner_product' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem EuclideanGeometry.angle_sum_of_triangle {P : Type u_1} [MetricSpace P] [NormedAddTorsor ℝ P] [FiniteDimensional ℝ P] [NormedField ℝ] {P1 P2 P3 : P} :\nEuclideanGeometry.Angle P1 P2 P3 + EuclideanGeometry.Angle P2 P3 P1 + EuclideanGeometry.Angle P3 P1 P2 = 2 * (↑Real.Pi : ℝ) ",
        "parse-message": "failed to synthesize instance\n  AddCommGroupₓ P (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "angle_sum_pi",
      "search_time": "1.4386507550079841",
      "ret-prompts": [
        {
          "statement": "theorem inner_product_geometry.angle_add_angle_eq_pi_of_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) : inner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi",
          "sim_score": "0.5743768215179443",
          "doc_string": " If the angle between two vectors is π, the angles between those vectors and a third vector add to π."
        },
        {
          "statement": "theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) : euclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4",
          "sim_score": "0.5685725212097168",
          "doc_string": " Vertical Angles Theorem: angles opposite each other, formed by two intersecting straight lines, are equal."
        },
        {
          "statement": "theorem orthonormal.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑real.pi",
          "sim_score": "0.5616596937179565",
          "doc_string": " Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle."
        },
        {
          "statement": "theorem orientation.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑real.pi",
          "sim_score": "0.5616596937179565",
          "doc_string": " Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If the angle between two vectors is π, the angles between those vectors and a third vector add to π.\" Translate the natural language version to a Lean mathlib version:\n theorem inner_product_geometry.angle_add_angle_eq_pi_of_angle_eq_pi{V : Type u_1} [inner_product_space ℝ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) :\ninner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi := \n\nNatural language version: \" Vertical Angles Theorem: angles opposite each other, formed by two intersecting straight lines, are equal.\" Translate the natural language version to a Lean mathlib version:\n theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi{V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) :\neuclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4 := \n\nNatural language version: \" Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.\" Translate the natural language version to a Lean mathlib version:\n theorem orthonormal.oangle_add_cyc3_neg_right{V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\nhb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑real.pi := \n\nNatural language version: \" Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.\" Translate the natural language version to a Lean mathlib version:\n theorem orientation.oangle_add_cyc3_neg_right{V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\no.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑real.pi := \n\nNatural language version: \"The angles of a triangle add up to two right angles.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The angles of a triangle add up to two right angles.",
      "codex_time": "6.071401793014957"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem angle_sum_pi {p q r : EuclideanSpace ℝ (Finₓ 2)} : EuclideanGeometry.angle p q r + EuclideanGeometry.angle q r p + EuclideanGeometry.angle r p q = Real.pi "
  },
  {
    "parsed": [
      "theorem Nat.sum_two_primes_of_even{P Q : ℕ}(h : P ≠ 0 ∧ Q ≠ 0 ∧ (P + Q) % 2 = 0) :\n∃ n : ℕ, n > 1 ∧ Odd n ∧ ∃ m : ℕ, m > 1 ∧ Odd m ",
      "theorem even_sum_primes(n : ℕ) (h : n % 2 = 0) :\n∃(P Q : ℕ), Nat.Prime P ∧ Nat.Prime Q ∧ (P + Q = n) ",
      "theorem sum_two_primes(n : ℕ) (h : n > 0) (hn : 2 ∣ n) :\n∃ A b : ℕ, A.Prime ∧ b.Prime ∧ A + b = n ",
      "theorem Nat.two_primes_sum_even{n : ℕ} (hn : 2 ∣ n) :\n∃ P Q: ℕ, (P + Q = n) ∧ (P.Prime ∧ Q.Prime) "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "theorem Nat.sum_two_primes_of_even{P Q : ℕ}(h : P ≠ 0 ∧ Q ≠ 0 ∧ (P + Q) % 2 = 0) :\n∃ n : ℕ, n > 1 ∧ Odd n ∧ ∃ m : ℕ, m > 1 ∧ Odd m ",
        "code": "forall {P : Nat} {Q : Nat}, (And (Ne.{?_uniq.7} Nat P (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (And (Ne.{?_uniq.20} Nat Q (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) (Eq.{?_uniq.25} Nat (HMod.hMod.{?_uniq.28 ?_uniq.27 ?_uniq.26} Nat Nat Nat (instHMod.{?_uniq.130} Nat Nat.hasMod) (HAdd.hAdd.{?_uniq.35 ?_uniq.34 ?_uniq.33} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P Q) (OfNat.ofNat.{?_uniq.27} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.90} Nat 0 (instOfNatNat 0))))) -> (Exists.{?_uniq.144} Nat (fun (n : Nat) => And (GT.gt.{?_uniq.148} Nat Nat.hasLt n (OfNat.ofNat.{?_uniq.151} Nat 1 (instOfNatNat 1))) (And (Odd.{?_uniq.175} Nat Nat.semiring n) (Exists.{?_uniq.185} Nat (fun (m : Nat) => And (GT.gt.{?_uniq.189} Nat Nat.hasLt m (OfNat.ofNat.{?_uniq.192} Nat 1 (instOfNatNat 1))) (Odd.{?_uniq.208} Nat Nat.semiring m))))))"
      },
      {
        "success": true,
        "statement": "theorem even_sum_primes(n : ℕ) (h : n % 2 = 0) :\n∃(P Q : ℕ), Nat.Prime P ∧ Nat.Prime Q ∧ (P + Q = n) ",
        "code": "forall (n : Nat), (Eq.{?_uniq.5} Nat (HMod.hMod.{?_uniq.8 ?_uniq.7 ?_uniq.6} Nat Nat Nat (instHMod.{?_uniq.81} Nat Nat.hasMod) n (OfNat.ofNat.{?_uniq.7} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.41} Nat 0 (instOfNatNat 0))) -> (Exists.{?_uniq.103} Nat (fun (P : Nat) => Exists.{?_uniq.107} Nat (fun (Q : Nat) => And (Nat.Prime P) (And (Nat.Prime Q) (Eq.{?_uniq.111} Nat (HAdd.hAdd.{?_uniq.114 ?_uniq.113 ?_uniq.112} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P Q) n)))))"
      },
      {
        "success": true,
        "statement": "theorem sum_two_primes(n : ℕ) (h : n > 0) (hn : 2 ∣ n) :\n∃ A b : ℕ, A.Prime ∧ b.Prime ∧ A + b = n ",
        "code": "forall (n : Nat) (h : GT.gt.{?_uniq.5} Nat Nat.hasLt n (OfNat.ofNat.{?_uniq.8} Nat 0 (instOfNatNat 0))), (Dvd.dvd.{?_uniq.39} Nat Nat.hasDvd (OfNat.ofNat.{?_uniq.39} Nat 2 (?_uniq.102 n h)) n) -> (Exists.{?_uniq.56} Nat (fun (A : Nat) => Exists.{?_uniq.60} Nat (fun (b : Nat) => And (Nat.Prime A) (And (Nat.Prime b) (Eq.{?_uniq.66} Nat (HAdd.hAdd.{?_uniq.69 ?_uniq.68 ?_uniq.67} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) A b) n)))))"
      },
      {
        "success": true,
        "statement": "theorem Nat.two_primes_sum_even{n : ℕ} (hn : 2 ∣ n) :\n∃ P Q: ℕ, (P + Q = n) ∧ (P.Prime ∧ Q.Prime) ",
        "code": "forall {n : Nat}, (Dvd.dvd.{?_uniq.5} Nat Nat.hasDvd (OfNat.ofNat.{?_uniq.5} Nat 2 (?_uniq.67 n)) n) -> (Exists.{?_uniq.22} Nat (fun (P : Nat) => Exists.{?_uniq.26} Nat (fun (Q : Nat) => And (Eq.{?_uniq.30} Nat (HAdd.hAdd.{?_uniq.33 ?_uniq.32 ?_uniq.31} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P Q) n) (And (Nat.Prime P) (Nat.Prime Q)))))"
      },
      {
        "success": false,
        "statement": "theorem euler_phi.gt_two_prime_sum(n : ℕ) (hnp : n > 2) (h : Nat.Even n) :\n∃ P Q : ℕ, P + Q = n ∧ Nat.Prime P \n\nNatural Language version: \"For any `n > 1`, there are infinitely many Primes congruent to `1` modulo `n`.\" \nTranslate the natural Language version to A Lean mathlib version:\n theorem coprime.infinitely_many_gt_one(n : ℕ) (hn : n > 1) :\n∀ N : ℕ, ∃ P :",
        "parse-message": "<input>:4:24: expected end of input"
      }
    ],
    "number-parsed": 4,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "goldbach",
      "search_time": "1.4401543280109763",
      "ret-prompts": [
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.5331833362579346",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        },
        {
          "statement": "theorem nat.mem_factors_mul_left {p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) : p ∈ (a * b).factors",
          "sim_score": "0.48720940947532654",
          "doc_string": "If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0`"
        },
        {
          "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}",
          "sim_score": "0.48647668957710266",
          "doc_string": "Every nonzero natural number has a unique prime factorization"
        },
        {
          "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1",
          "sim_score": "0.4829321801662445",
          "doc_string": "The only numbers with empty prime factorization are `0` and `1`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.mem_factors_mul_left{p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) :\np ∈ (a * b).factors := \n\nNatural language version: \"Every nonzero natural number has a unique prime factorization\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_inj :\nset.inj_on nat.factorization {x : ℕ | x ≠ 0} := \n\nNatural language version: \"The only numbers with empty prime factorization are `0` and `1`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_eq_zero_iff(n : ℕ) :\nn.factorization = 0 ↔ n = 0 ∨ n = 1 := \n\nNatural language version: \"Every positive even integer can be written as the sum of two primes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every positive even integer can be written as the sum of two primes.",
      "codex_time": "8.58134113199776"
    },
    "grouped": [
      [
        "theorem Nat.sum_two_primes_of_even{P Q : ℕ}(h : P ≠ 0 ∧ Q ≠ 0 ∧ (P + Q) % 2 = 0) :\n∃ n : ℕ, n > 1 ∧ Odd n ∧ ∃ m : ℕ, m > 1 ∧ Odd m "
      ],
      [
        "theorem even_sum_primes(n : ℕ) (h : n % 2 = 0) :\n∃(P Q : ℕ), Nat.Prime P ∧ Nat.Prime Q ∧ (P + Q = n) "
      ],
      [
        "theorem sum_two_primes(n : ℕ) (h : n > 0) (hn : 2 ∣ n) :\n∃ A b : ℕ, A.Prime ∧ b.Prime ∧ A + b = n "
      ],
      [
        "theorem Nat.two_primes_sum_even{n : ℕ} (hn : 2 ∣ n) :\n∃ P Q: ℕ, (P + Q = n) ∧ (P.Prime ∧ Q.Prime) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem goldbach : ∀ n : ℕ, n > 0 → Even n → ∃ p q : ℕ, Prime p → Prime q → n = p + q "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem charpoly_eq_map_aeval{R : Type u} [comm_ring R] {n : Type v} [DecidableEQ n] [Fintype n] (m : Matrix n n R) :\nm.CharPoly = ⇑(Polynomial.aeval m) m.CharPoly ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Matrix.charpoly_eq_aeval_charpoly{R : Type u} [comm_ring R] {n : Type v} [DecidableEQ n] [Fintype n] (m : Matrix n n R) :\n⇑(Polynomial.aeval m) m.CharPoly = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Matrix.holomorphic_charpoly{R : Type u} [comm_ring R] {n : Type v} [DecidableEQ n] [Fintype n] (m : Matrix n n R) :\nPolynomial.Eval₂ (λ A b, b = A) m.CharPoly m ",
        "parse-message": "<input>:2:23: expected '=>'"
      },
      {
        "success": false,
        "statement": "theorem Matrix.roots_charpoly{R : Type u} [comm_ring R] {n : Type v} [DecidableEQ n] [Fintype n] (m : Matrix n n R) :\nm.roots m.CharPoly = Univ ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Matrix.aeval_char_poly{R : Type u} [comm_ring R] {n : Type v} [DecidableEQ n] [Fintype n] (m : Matrix n n R) :\n⇑(Polynomial.aeval m) m.CharPoly = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "cayley_hamilton",
      "search_time": "1.4370572980260476",
      "ret-prompts": [
        {
          "statement": "theorem linear_map.aeval_self_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) : ⇑(polynomial.aeval f) f.charpoly = 0",
          "sim_score": "0.7601779699325562",
          "doc_string": " The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices."
        },
        {
          "statement": "theorem matrix.aeval_self_charpoly {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0",
          "sim_score": "0.6756272315979004",
          "doc_string": "The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms."
        },
        {
          "statement": "theorem linear_map.charpoly_to_matrix {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) : (⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly",
          "sim_score": "0.5441092252731323",
          "doc_string": "`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis."
        },
        {
          "statement": "theorem matrix.aeval_eq_aeval_mod_charpoly {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) : ⇑(polynomial.aeval M) p = ⇑(polynomial.aeval M) (p %ₘ M.charpoly)",
          "sim_score": "0.5268839001655579",
          "doc_string": " Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p` is equivalent to a polynomial with degree less than the dimension of the matrix."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices.\" Translate the natural language version to a Lean mathlib version:\n theorem linear_map.aeval_self_charpoly{R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) :\n⇑(polynomial.aeval f) f.charpoly = 0 := \n\nNatural language version: \"The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms.\" Translate the natural language version to a Lean mathlib version:\n theorem matrix.aeval_self_charpoly{R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) :\n⇑(polynomial.aeval M) M.charpoly = 0 := \n\nNatural language version: \"`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis.\" Translate the natural language version to a Lean mathlib version:\n theorem linear_map.charpoly_to_matrix{R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) :\n(⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly := \n\nNatural language version: \" Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p` is equivalent to a polynomial with degree less than the dimension of the matrix.\" Translate the natural language version to a Lean mathlib version:\n theorem matrix.aeval_eq_aeval_mod_charpoly{R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) :\n⇑(polynomial.aeval M) p = ⇑(polynomial.aeval M) (p %ₘ M.charpoly) := \n\nNatural language version: \"Every matrix satisfies its own characteristic polynomial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every matrix satisfies its own characteristic polynomial.",
      "codex_time": "7.653844293992734"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem cayley_hamilton {R : Type _} [CommRingₓ R] {n : Type _} [DecidableEq n] [Fintype n] (M : Matrix n n R) : (Polynomial.aeval M) M.charpoly = 0 "
  },
  {
    "parsed": [
      "theorem irrational_sqrt{x : ℝ} (n : ℤ) (hxr : x ^ 2 = ↑n) (hv : ¬∃ (y : ℕ), x = ↑y) :\nIrrational x "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem irrational_of_irrational_sqrt{x : ℝ} (hxir : Irrational x) (hxpos : 0 < x) :\nIrrational (Real.is_sqrt x) ",
        "parse-message": "unknown constant 'Real.is_sqrt' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem irrational_sqrt{x : ℝ} (n : ℤ) (hxr : x ^ 2 = ↑n) (hv : ¬∃ (y : ℕ), x = ↑y) :\nIrrational x ",
        "code": "forall {x : Real} (n : Int) (hxr : Eq.{?_uniq.8} Real (HPow.hPow.{?_uniq.11 ?_uniq.10 ?_uniq.9} Real Nat Real (instHPow.{0 0} Real Nat (Monoidₓ.hasPow.{0} Real Real.monoid)) x (OfNat.ofNat.{?_uniq.10} Nat 2 (instOfNatNat 2))) (?_uniq.251777 x n)), (Not (Exists.{?_uniq.113606} Nat (fun (y : Nat) => Eq.{?_uniq.113610} Real x (?_uniq.251779 x n hxr y)))) -> (Irrational x)"
      },
      {
        "success": false,
        "statement": "theorem irrational_sqrt_of_irrational{R : ℝ} :\nIrrational R →\nIrrational (Real.is_sqrt R) ",
        "parse-message": "unknown constant 'Real.is_sqrt' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem irrational_real_sqrt{x : ℝ} (h : Irrational x) :\nIrrational (Real.is_sqrt x) ",
        "parse-message": "unknown constant 'Real.is_sqrt' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem irrational_sqrt_of_irrational{R : ℝ} (irr : Irrational R) :\nIrrational (Real.is_sqrt R) ",
        "parse-message": "unknown constant 'Real.is_sqrt' (during elaboration)"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "sqrt_of_irrat_irrat",
      "search_time": "1.439350487984484",
      "ret-prompts": [
        {
          "statement": "theorem transcendental.irrational {r : ℝ} (tr : transcendental ℚ r) : irrational r",
          "sim_score": "0.70249342918396",
          "doc_string": "A transcendental real number is irrational."
        },
        {
          "statement": "theorem irrational_nrt_of_notint_nrt {x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) : irrational x",
          "sim_score": "0.6819822192192078",
          "doc_string": " If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational."
        },
        {
          "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)",
          "sim_score": "0.6707029938697815",
          "doc_string": "**Irrationality of the Square Root of 2**"
        },
        {
          "statement": "theorem real.nat_sqrt_le_real_sqrt {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a",
          "sim_score": "0.6412547826766968",
          "doc_string": "The natural square root is at most the real square root"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A transcendental real number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem transcendental.irrational{r : ℝ} (tr : transcendental ℚ r) :\nirrational r := \n\nNatural language version: \" If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem irrational_nrt_of_notint_nrt{x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) :\nirrational x := \n\nNatural language version: \"**Irrationality of the Square Root of 2**\" Translate the natural language version to a Lean mathlib version:\n theorem irrational_sqrt_two :\nirrational (real.sqrt 2) := \n\nNatural language version: \"The natural square root is at most the real square root\" Translate the natural language version to a Lean mathlib version:\n theorem real.nat_sqrt_le_real_sqrt{a : ℕ} :\n↑(nat.sqrt a) ≤ real.sqrt ↑a := \n\nNatural language version: \"The square root of an irrational number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The square root of an irrational number is irrational.",
      "codex_time": "5.11982105000061"
    },
    "grouped": [
      [
        "theorem irrational_sqrt{x : ℝ} (n : ℤ) (hxr : x ^ 2 = ↑n) (hv : ¬∃ (y : ℕ), x = ↑y) :\nIrrational x "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem sqrt_of_irrat_irrat (x : ℝ) : Irrational x → Irrational (Real.sqrt x) "
  },
  {
    "parsed": [
      "theorem even_mul_self{α : Type u_3} [Semiring α] (A : α) :\nEven (A * A) → Even A ",
      "theorem mul_self_even{m: ℕ} :\nEven (m * m) → Even m ",
      "theorem Int.even_mul_even_iff_even_pow_two{n : ℤ} :\nEven (n * n) ↔ Even n "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Nat.even_mul_self{α : Type u_1} [has_mul α] [linear_ordered_cancel_comm_monoid_with_zero α] [has_one α] (m : ℕ) (h : Even (m * m)) :\nEven m ",
        "parse-message": "unknown identifier 'has_mul' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem even_mul_self{α : Type u_3} [Semiring α] (A : α) :\nEven (A * A) → Even A ",
        "code": "forall {α : Type.{u_3}} [inst._@._hyg.5 : Semiring.{?_uniq.5} α] (A : α), (Even.{?_uniq.12} α (Distrib.toAdd.{u_3} α (NonUnitalNonAssocSemiring.toDistrib.{u_3} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_3} α (Semiring.toNonAssocSemiring.{u_3} α inst._@._hyg.5)))) (HMul.hMul.{?_uniq.17 ?_uniq.16 ?_uniq.15} α α α (instHMul.{u_3} α (NonUnitalNonAssocSemiring.toMul.{u_3} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_3} α (Semiring.toNonAssocSemiring.{u_3} α inst._@._hyg.5)))) A A)) -> (Even.{?_uniq.100} α (Distrib.toAdd.{u_3} α (NonUnitalNonAssocSemiring.toDistrib.{u_3} α (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u_3} α (Semiring.toNonAssocSemiring.{u_3} α inst._@._hyg.5)))) A)"
      },
      {
        "success": true,
        "statement": "theorem mul_self_even{m: ℕ} :\nEven (m * m) → Even m ",
        "code": "forall {m : Nat}, (Even.{?_uniq.5} Nat Nat.hasAdd (HMul.hMul.{?_uniq.10 ?_uniq.9 ?_uniq.8} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) m m)) -> (Even.{?_uniq.51} Nat Nat.hasAdd m)"
      },
      {
        "success": false,
        "statement": "theorem is_even_iff_odd{R : Type u_1} [integral_domain R] {A : R} :\nis_even (A * A) ↔ is_even A ",
        "parse-message": "unknown identifier 'integral_domain' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Int.even_mul_even_iff_even_pow_two{n : ℤ} :\nEven (n * n) ↔ Even n ",
        "code": "forall {n : Int}, Iff (Even.{?_uniq.4} Int Int.hasAdd (HMul.hMul.{?_uniq.9 ?_uniq.8 ?_uniq.7} Int Int Int (instHMul.{0} Int Int.hasMul) n n)) (Even.{?_uniq.49} Int Int.hasAdd n)"
      }
    ],
    "number-parsed": 3,
    "number-equivalent": 1,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "sq_even_implies_num_even",
      "search_time": "1.4398203900200315",
      "ret-prompts": [
        {
          "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0",
          "sim_score": "0.5731519460678101",
          "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive."
        },
        {
          "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
          "sim_score": "0.5604414343833923",
          "doc_string": "The sum of two squares is zero iff both elements are zero."
        },
        {
          "statement": "theorem finite_field.exists_nonsquare {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a",
          "sim_score": "0.546607255935669",
          "doc_string": "In a finite field of odd characteristic, not every element is a square."
        },
        {
          "statement": "theorem clifford_algebra.even_odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n) : P x hx",
          "sim_score": "0.5101829767227173",
          "doc_string": " To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.even_pow{m n : ℕ} :\neven (m ^ n) ↔ even m ∧ n ≠ 0 := \n\nNatural language version: \"The sum of two squares is zero iff both elements are zero.\" Translate the natural language version to a Lean mathlib version:\n theorem mul_self_add_mul_self_eq_zero{α : Type u} [linear_ordered_ring α] {x y : α} :\nx * x + y * y = 0 ↔ x = 0 ∧ y = 0 := \n\nNatural language version: \"In a finite field of odd characteristic, not every element is a square.\" Translate the natural language version to a Lean mathlib version:\n theorem finite_field.exists_nonsquare{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) :\n∃ (a : F), ¬is_square a := \n\nNatural language version: \" To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors.\" Translate the natural language version to a Lean mathlib version:\n theorem clifford_algebra.even_odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n) :\nP x hx := \n\nNatural language version: \"If the square of a number is even, the number itself is even.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If the square of a number is even, the number itself is even.",
      "codex_time": "7.674899434990948"
    },
    "grouped": [
      [
        "theorem even_mul_self{α : Type u_3} [Semiring α] (A : α) :\nEven (A * A) → Even A "
      ],
      [
        "theorem mul_self_even{m: ℕ} :\nEven (m * m) → Even m "
      ],
      [
        "theorem Int.even_mul_even_iff_even_pow_two{n : ℤ} :\nEven (n * n) ↔ Even n "
      ]
    ],
    "equivalent": [
      "theorem mul_self_even{m: ℕ} :\nEven (m * m) → Even m "
    ],
    "answer": "theorem sq_even_implies_num_even : ∀ n : ℕ, Even (n^2) → Even n "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Prime.is_maximal{R : Type u_1} [comm_ring R] (hfin : Fintype R.Carrier) : \n@is_maximal (Ideal R) _ _ _ _ IsPrime ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem prime_of_finite_comm_ring(α : Type u) [comm_ring α] [Fintype α] {P : Ideal α}\n(h : P.IsPrime) : P.is_maximal ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_field_of_finite_prime{R : Type u} [comm_ring R] (hfin : Fintype R) (hP : Ideal.IsPrime R) :\nField R ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Ideal.prime_of_finite_implies_maximal{R : Type u_1} [comm_ring R] [Fintype R] {i : Ideal R} (hip : i.IsPrime) :\ni.is_maximal ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem finite_comm_ring.is_field_of_no_prime :\n∀ (α : Type u_1) (finite_comm_ring : finite_comm_ring α), ¬∃ (P : Ideal α), P.IsPrime → Field α ",
        "parse-message": "unknown identifier 'finite_comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "finite_ring_prime_implies_maximal",
      "search_time": "1.450567267020233",
      "ret-prompts": [
        {
          "statement": "theorem ring.ne_bot_of_is_maximal_of_not_is_field {R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬is_field R) : M ≠ ⊥",
          "sim_score": "0.6932713389396667",
          "doc_string": "When a ring is not a field, the maximal ideals are nontrivial."
        },
        {
          "statement": "theorem ideal.exists_maximal (α : Type u) [semiring α] [nontrivial α] : ∃ (M : ideal α), M.is_maximal",
          "sim_score": "0.6569143533706665",
          "doc_string": "Krull's theorem: a nontrivial ring has a maximal ideal."
        },
        {
          "statement": "theorem ideal.maximal_of_no_maximal {R : Type u} [semiring R] {P : ideal R} (hmax : ∀ (m : ideal R), P < m → ¬m.is_maximal) (J : ideal R) (hPJ : P < J) : J = ⊤",
          "sim_score": "0.6307719945907593",
          "doc_string": "If P is not properly contained in any maximal ideal then it is not properly contained  in any proper ideal"
        },
        {
          "statement": "theorem ideal.is_prime_map_C_of_is_prime {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : (ideal.map polynomial.C P).is_prime",
          "sim_score": "0.6226035356521606",
          "doc_string": "If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"When a ring is not a field, the maximal ideals are nontrivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ring.ne_bot_of_is_maximal_of_not_is_field{R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬is_field R) :\nM ≠ ⊥ := \n\nNatural language version: \"Krull's theorem: a nontrivial ring has a maximal ideal.\" Translate the natural language version to a Lean mathlib version:\n theorem ideal.exists_maximal(α : Type u) [semiring α] [nontrivial α] :\n∃ (M : ideal α), M.is_maximal := \n\nNatural language version: \"If P is not properly contained in any maximal ideal then it is not properly contained  in any proper ideal\" Translate the natural language version to a Lean mathlib version:\n theorem ideal.maximal_of_no_maximal{R : Type u} [semiring R] {P : ideal R} (hmax : ∀ (m : ideal R), P < m → ¬m.is_maximal) (J : ideal R) (hPJ : P < J) :\nJ = ⊤ := \n\nNatural language version: \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`.\" Translate the natural language version to a Lean mathlib version:\n theorem ideal.is_prime_map_C_of_is_prime{R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) :\n(ideal.map polynomial.C P).is_prime := \n\nNatural language version: \"In a finite commutative ring, all prime ideals are maximal.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In a finite commutative ring, all prime ideals are maximal.",
      "codex_time": "6.540205358003732"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem finite_ring_prime_implies_maximal {R : Type _} [CommRingₓ R] [Fintype R] : ∀ (Idl : Ideal R), Idl.IsPrime → Idl.IsMaximal "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Hausdorff_iff_diagonal_subset_closed{α : Type u} [TopologicalSpace α] :\nHausdorff α ↔ is_closed (Subtype.val '' {P:α × α | P.1 = P.2}) ",
        "parse-message": "<input>:2:40: missing end of character literal"
      },
      {
        "success": false,
        "statement": "theorem Hausdorff_iff_diagonal_mem_closed {α : Type*} [TopologicalSpace α] : Hausdorff α ↔ Closure ({P : α × α | P.1 = P.2}) = Univ (Subtype.val_subtype) ",
        "parse-message": "unknown identifier 'Hausdorff' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Hausdorff_iff_is_closed_diagonal{α : Type u} [TopologicalSpace α] :\nis_closed $ set.Prod set.Univ set.Univ ",
        "parse-message": "unknown identifier 'is_closed' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_closed_Hausdorff_singleton {α : Type u} [t : TopologicalSpace α] :\nIsClosedMap (@Singleton α (α × α)) ↔ t.is_Hausdorff ",
        "parse-message": "unknown identifier 'Singleton' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_closed.Hausdorff_iff_diag_closed{α : Type u} [TopologicalSpace α] :\nis_closed (set.IsDiag α) ↔ is_Hausdorff α ",
        "parse-message": "unknown identifier 'is_closed' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "hausdorff_iff_diag_closed",
      "search_time": "1.4491934010002296",
      "ret-prompts": [
        {
          "statement": "theorem emetric.Hausdorff_edist_closure {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t",
          "sim_score": "0.5625295639038086",
          "doc_string": "The Hausdorff edistance between sets or their closures is the same"
        },
        {
          "statement": "theorem is_closed.Hausdorff_dist_zero_iff_eq {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s t = 0 ↔ s = t",
          "sim_score": "0.5602964162826538",
          "doc_string": "Two closed sets are at zero Hausdorff distance if and only if they coincide"
        },
        {
          "statement": "theorem emetric.Hausdorff_edist_zero_iff_eq_of_closed {α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) : emetric.Hausdorff_edist s t = 0 ↔ s = t",
          "sim_score": "0.5491901636123657",
          "doc_string": "Two closed sets are at zero Hausdorff edistance if and only if they coincide"
        },
        {
          "statement": "theorem emetric.Hausdorff_edist_closure₂ {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t",
          "sim_score": "0.5290781259536743",
          "doc_string": "Replacing a set by its closure does not change the Hausdorff edistance."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The Hausdorff edistance between sets or their closures is the same\" Translate the natural language version to a Lean mathlib version:\n theorem emetric.Hausdorff_edist_closure{α : Type u} [pseudo_emetric_space α] {s t : set α} :\nemetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t := \n\nNatural language version: \"Two closed sets are at zero Hausdorff distance if and only if they coincide\" Translate the natural language version to a Lean mathlib version:\n theorem is_closed.Hausdorff_dist_zero_iff_eq{α : Type u} [pseudo_metric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ≠ ⊤) :\nmetric.Hausdorff_dist s t = 0 ↔ s = t := \n\nNatural language version: \"Two closed sets are at zero Hausdorff edistance if and only if they coincide\" Translate the natural language version to a Lean mathlib version:\n theorem emetric.Hausdorff_edist_zero_iff_eq_of_closed{α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) :\nemetric.Hausdorff_edist s t = 0 ↔ s = t := \n\nNatural language version: \"Replacing a set by its closure does not change the Hausdorff edistance.\" Translate the natural language version to a Lean mathlib version:\n theorem emetric.Hausdorff_edist_closure₂{α : Type u} [pseudo_emetric_space α] {s t : set α} :\nemetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t := \n\nNatural language version: \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
      "codex_time": "4.811419643985573"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem hausdorff_iff_diag_closed {X : Type _} [TopologicalSpace X] : T2Space X ↔ IsClosed (Set.Diagonal X) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem TopologicalSpace.of_forall_mem_open{α : Type u} [TopologicalSpace α]{s:set α} (m:∀ (x : α), x ∈ s → ∃ (t:set α), is_open t ∧ x ∈ t): is_open s ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem assumption_of_nhds_not_mem_nhds {α : Type u} [TopologicalSpace α] {x : α} (h : ∀ (A : set α), A ∈ nhds x → A ≠ {x}) :\n∃ (n : set α), is_open n ∧ n ⊆ {x} ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_open_of_forall_mem_open{α : Type u} [TopologicalSpace α] {s : set α} {u : set α} (h : ∀ (x : α), x ∈ s → ∃ (V : set α), is_open V ∧ V ⊆ u ∧ x ∈ V) (hp : u = ⋃₀ s) :\nis_open u ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_open_iff_forall_mem_open_nhds{α : Type u} [TopologicalSpace α] {s : set α} : is_open s ↔ ∀ (x : α), x ∈ s → ∃ (u : set α), is_open u ∧ x ∈ u ∧ u ⊆ s ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem mem_nhds_of_mem_nhds_within{α : Type u} [TopologicalSpace α] {s : set α} {A : α} (h : ∀ (x : α), x ∈ s → ∃ (V : set α), A ∈ V ∧ is_open V ∧ x ∈ V) :\n∃ (V : set α), A ∈ V ∧ is_open V ∧ s ⊆ V ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "open_iff_open_nhd_all_pt",
      "search_time": "1.4257859050121624",
      "ret-prompts": [
        {
          "statement": "theorem eventually_nhds_iff {α : Type u} [topological_space α] {a : α} {p : α → Prop} : (∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → p x) ∧ is_open t ∧ a ∈ t",
          "sim_score": "0.624941349029541",
          "doc_string": " A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set containing `a`."
        },
        {
          "statement": "theorem exists_open_singleton_of_open_finite {α : Type u} [topological_space α] [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) : ∃ (x : α) (H : x ∈ s), is_open {x}",
          "sim_score": "0.619118332862854",
          "doc_string": "Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open."
        },
        {
          "statement": "theorem exists_open_set_nhds' {α : Type u} [topological_space α] {s U : set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U",
          "sim_score": "0.6141307353973389",
          "doc_string": " If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s: it contains an open set containing `s`."
        },
        {
          "statement": "theorem exists_open_set_nhds {α : Type u} [topological_space α] {s U : set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U",
          "sim_score": "0.6101160645484924",
          "doc_string": " If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`: it contains an open set containing `s`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set containing `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem eventually_nhds_iff{α : Type u} [topological_space α] {a : α} {p : α → Prop} :\n(∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → p x) ∧ is_open t ∧ a ∈ t := \n\nNatural language version: \"Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_open_singleton_of_open_finite{α : Type u} [topological_space α] [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) :\n∃ (x : α) (H : x ∈ s), is_open {x} := \n\nNatural language version: \" If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s: it contains an open set containing `s`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_open_set_nhds'{α : Type u} [topological_space α] {s U : set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) :\n∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U := \n\nNatural language version: \" If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`: it contains an open set containing `s`.\" Translate the natural language version to a Lean mathlib version:\n theorem exists_open_set_nhds{α : Type u} [topological_space α] {s U : set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) :\n∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U := \n\nNatural language version: \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
      "codex_time": "10.69111048799823"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem open_iff_open_nhd_all_pt {X : Type _} [TopologicalSpace X] (S : Set X) : (∀ x ∈ S, ∃ U : Set X, IsOpen U) → IsOpen S "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Complex.is_real_elim(z : ℂ) :\nis_real_elim (z * conj z) ",
        "parse-message": "unknown identifier 'is_real_elim' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Complex.conj_mul_conj_eq_norm_squared (c : ℂ) : \nhas_mul.Mul ⇑(StarRingEnd ℂ) c (has_mul.Mul ⇑(StarRingEnd ℂ) c c) = ⇑(is_R_or_C.re c.re) ",
        "parse-message": "unknown identifier 'has_mul.Mul' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_R_or_C_rmul(x : ℂ) : is_R_or_C (⇑(StarRingEnd ℂ) x * x) ",
        "parse-message": "unknown identifier 'is_R_or_C' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_R_or_C.is_real_mul_conj(z : ℂ) :\nis_R_or_C.is_real (z * ⇑(StarRingEnd ℂ) z) ",
        "parse-message": "unknown identifier 'is_R_or_C.is_real' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Complex.star_prod_is_rel (c : ℂ) :\n∣⇑(c * StarRingEnd ℂ c)∣ = ⇑(Abs (c * StarRingEnd ℂ c)) ",
        "parse-message": "<input>:2:0: expected term"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "complex_conj_prod_real",
      "search_time": "1.4299217259977013",
      "ret-prompts": [
        {
          "statement": "theorem complex.re_eq_add_conj (z : ℂ) : ↑(z.re) = (z + ⇑(star_ring_end ℂ) z) / 2",
          "sim_score": "0.6665807962417603",
          "doc_string": "A complex number `z` plus its conjugate `conj z` is `2` times its real part."
        },
        {
          "statement": "theorem complex.im_eq_sub_conj (z : ℂ) : ↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * complex.I)",
          "sim_score": "0.6368286609649658",
          "doc_string": "A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part."
        },
        {
          "statement": "theorem inner_product_space.is_self_adjoint_iff_inner_map_self_real {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) : inner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v",
          "sim_score": "0.5591109395027161",
          "doc_string": " A linear operator on a complex inner product space is self-adjoint precisely when `⟪T v, v⟫_ℂ` is real for all v."
        },
        {
          "statement": "theorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2",
          "sim_score": "0.48265978693962097",
          "doc_string": "Polarization identity: The real part of the  inner product, in terms of the norm."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A complex number `z` plus its conjugate `conj z` is `2` times its real part.\" Translate the natural language version to a Lean mathlib version:\n theorem complex.re_eq_add_conj(z : ℂ) :\n↑(z.re) = (z + ⇑(star_ring_end ℂ) z) / 2 := \n\nNatural language version: \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part.\" Translate the natural language version to a Lean mathlib version:\n theorem complex.im_eq_sub_conj(z : ℂ) :\n↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * complex.I) := \n\nNatural language version: \" A linear operator on a complex inner product space is self-adjoint precisely when `⟪T v, v⟫_ℂ` is real for all v.\" Translate the natural language version to a Lean mathlib version:\n theorem inner_product_space.is_self_adjoint_iff_inner_map_self_real{V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) :\ninner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v := \n\nNatural language version: \"Polarization identity: The real part of the  inner product, in terms of the norm.\" Translate the natural language version to a Lean mathlib version:\n theorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) :\n⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2 := \n\nNatural language version: \"The product of a complex number with its conjugate is a real number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of a complex number with its conjugate is a real number.",
      "codex_time": "9.362573266000254"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem complex_conj_prod_real : ∀ z : ℂ, ∃ r : ℝ, z * (starRingEnd ℂ $ z) = (r : ℂ) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem free_group.IsOFFinOrder.Neg{α : Type u}  (x : free_group α) :\nIsOFFinOrder x ↔ x = 1 ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem order_of_ne_one_of_inf_order_free_group{α : Type u} {g : free_group α} (hg : g ≠ 1) :\n∃ (N : ℕ), ∀ n, n ≥ N → g ^ n ≠ 1 ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem free_group.IsOFFinOrder {α : Type u} [DecidableEQ α] {s : free_group α} (h : s ≠ 1) : \n ¬ IsOFFinOrder s ",
        "parse-message": "unknown identifier 'DecidableEQ' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_of_fin_order_iff_one_of_free_group{α : Type u} {L : List (α × Bool)} [DecidableEQ α] :\nIsOFFinOrder (FreeGroup.Mk L) ↔ L = [] ",
        "parse-message": "unknown identifier 'DecidableEQ' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem free_group.forall_mem_ne'",
        "parse-message": "<input>:1:33: unexpected end of input; expected ':'"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "non_id_implies_infinite_order",
      "search_time": "1.4412528529937845",
      "ret-prompts": [
        {
          "statement": "theorem free_group.reduce.sound {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂",
          "sim_score": "0.5920776724815369",
          "doc_string": " If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined."
        },
        {
          "statement": "theorem order_of_pos_iff {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x",
          "sim_score": "0.5908461809158325",
          "doc_string": "A group element has finite order iff its order is positive."
        },
        {
          "statement": "theorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x",
          "sim_score": "0.5742547512054443",
          "doc_string": "Inverses of elements of finite order have finite order."
        },
        {
          "statement": "theorem is_of_fin_order.inv {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹",
          "sim_score": "0.5742547512054443",
          "doc_string": "Inverses of elements of finite order have finite order."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined.\" Translate the natural language version to a Lean mathlib version:\n theorem free_group.reduce.sound{α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) :\nfree_group.reduce L₁ = free_group.reduce L₂ := \n\nNatural language version: \"A group element has finite order iff its order is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem order_of_pos_iff{G : Type u} {x : G} [monoid G] :\n0 < order_of x ↔ is_of_fin_order x := \n\nNatural language version: \"Inverses of elements of finite order have finite order.\" Translate the natural language version to a Lean mathlib version:\n theorem is_of_fin_order_inv_iff{G : Type u} [group G] {x : G} :\nis_of_fin_order x⁻¹ ↔ is_of_fin_order x := \n\nNatural language version: \"Inverses of elements of finite order have finite order.\" Translate the natural language version to a Lean mathlib version:\n theorem is_of_fin_order.inv{G : Type u} [group G] {x : G} (hx : is_of_fin_order x) :\nis_of_fin_order x⁻¹ := \n\nNatural language version: \"Every non-identity element of a free group is of infinite order.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-identity element of a free group is of infinite order.",
      "codex_time": "8.806428215000778"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem non_id_implies_infinite_order {G : Type _} [Groupₓ G] : FreeGroup G → (∀ g : G, g ≠ 1 → orderOf g = 0) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem is_domain_of_subfield {R : Type} (s : Subfield R) : is_integral_domain s.Carrier ",
        "parse-message": "failed to synthesize instance\n  Field R (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Subring.ID.int_dom {K : Type u} [field K] (s : Subring K) (h : 1 ∈ s) :\nintegral_domain (Subtype.val ∘ s) ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem subring_of_field_contains_one_is_integral_domain{K : Type u} [field K] (s : Subring K) (one_mem : 1 ∈ s) :\nintegral_domain s ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem subring_of_field.one_eq_zero{K : Type u}[field K] (s : Subring K)(Zero : 0 ∈ s)(ONe : 1 ∈ s) {x : K}:\n(x ∈ s) ∧ (x = 0) ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Subfield.is_integral_domain{F : Type u} [field F] \n(s : Subfield F) (hi : 1 ∈ s) : integral_domain s ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "sub_ring_field_with_id_is_int_domain",
      "search_time": "1.43123984101112",
      "ret-prompts": [
        {
          "statement": "theorem subfield.inv_mem {K : Type u} [field K] (s : subfield K) {x : K} : x ∈ s → x⁻¹ ∈ s",
          "sim_score": "0.6670852899551392",
          "doc_string": "A subfield is closed under inverses."
        },
        {
          "statement": "theorem subring.one_mem {R : Type u} [ring R] (s : subring R) : 1 ∈ s",
          "sim_score": "0.6393297910690308",
          "doc_string": "A subring contains the ring's 1."
        },
        {
          "statement": "theorem subring.zero_mem {R : Type u} [ring R] (s : subring R) : 0 ∈ s",
          "sim_score": "0.6295010447502136",
          "doc_string": "A subring contains the ring's 0."
        },
        {
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s",
          "sim_score": "0.6208624243736267",
          "doc_string": "A subfield is closed under division."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A subfield is closed under inverses.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.inv_mem{K : Type u} [field K] (s : subfield K) {x : K} :\nx ∈ s → x⁻¹ ∈ s := \n\nNatural language version: \"A subring contains the ring's 1.\" Translate the natural language version to a Lean mathlib version:\n theorem subring.one_mem{R : Type u} [ring R] (s : subring R) :\n1 ∈ s := \n\nNatural language version: \"A subring contains the ring's 0.\" Translate the natural language version to a Lean mathlib version:\n theorem subring.zero_mem{R : Type u} [ring R] (s : subring R) :\n0 ∈ s := \n\nNatural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem subfield.div_mem{K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"Any sub-ring of a field that contains the identity is an integral domain\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Any sub-ring of a field that contains the identity is an integral domain",
      "codex_time": "5.314992551022442"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem sub_ring_field_with_id_is_int_domain {F : Type _} [Field F] : ∀ R : Subring F, 1 ∈ R.Carrier → IsDomain ↥R "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem DiscreteValuationRing.unit_iff_int_valuation_zero{R : Type u} [DiscreteValuationRing R] {x : R} :\nis_unit x ↔ 0 = v.int_valuation_def x ",
        "parse-message": "failed to synthesize instance\n  CommRingₓ R (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem DiscreteValuationRing.units_int_valuation_eq_zero{R : Type u} [comm_ring R] [DiscreteValuationRing R] {x : R} (hx : (x : Units R)): \nDiscreteValuationRing.int_valuation_def x = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem DiscreteValuationRing.h0_units{R : Type u} [is_domain R] (ur : DiscreteValuationRing R) :\n∀ ⦃x : R⦄, x ∈ ur.Units ↔ ur.Valuation x = 0 ",
        "parse-message": "unknown identifier 'is_domain' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem DiscreteValuationRing.unit_iff{R : Type u} [comm_ring R] [is_domain R] [DiscreteValuationRing R] {P : R} :\nis_unit P ↔ (((DiscreteValuationRing.IsIntegralClosure R) : set R) P).Valuation = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem DiscreteValuationRing.Units.eq_fin_of_ne_fin{R : Type u} [DiscreteValuationRing R] {R : R} (hr : R ≠ 0) (h : v R ≠ 0) :\nR ∈ Units R ",
        "parse-message": "failed to synthesize instance\n  CommRingₓ R (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "dvr_unit_iff_val_zero",
      "search_time": "1.431369549012743",
      "ret-prompts": [
        {
          "statement": "theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R",
          "sim_score": "0.7251311540603638",
          "doc_string": "An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring."
        },
        {
          "statement": "theorem discrete_valuation_ring.of_ufd_of_unique_irreducible {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) : discrete_valuation_ring R",
          "sim_score": "0.6923463344573975",
          "doc_string": "A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring."
        },
        {
          "statement": "theorem valuation_ring.of_integers {𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) : valuation_ring 𝒪",
          "sim_score": "0.6915189623832703",
          "doc_string": " If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪` is a valuation ring."
        },
        {
          "statement": "theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ≠ 0) : v.int_valuation_def x ≠ 0",
          "sim_score": "0.6845616698265076",
          "doc_string": "Nonzero elements have nonzero adic valuation."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization{R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) :\ndiscrete_valuation_ring R := \n\nNatural language version: \"A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem discrete_valuation_ring.of_ufd_of_unique_irreducible{R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) :\ndiscrete_valuation_ring R := \n\nNatural language version: \" If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪` is a valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem valuation_ring.of_integers{𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) :\nvaluation_ring 𝒪 := \n\nNatural language version: \"Nonzero elements have nonzero adic valuation.\" Translate the natural language version to a Lean mathlib version:\n theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero{R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ≠ 0) :\nv.int_valuation_def x ≠ 0 := \n\nNatural language version: \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
      "codex_time": "8.07621061001555"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem dvr_unit_iff_val_zero {R : Type _} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] : ∀ r : R, IsUnit r → DiscreteValuationRing.addVal R r = 0 "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem convex_exp :\nConvex (@Real.Exp ℝ _) ",
        "parse-message": "invalid use of field notation with `@` modifier (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem convex_exp :\nConvex Real.Exp ",
        "parse-message": "unknown constant 'Real.Exp' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem convex_exp :\nConvex Real.Exp ",
        "parse-message": "unknown constant 'Real.Exp' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem convex_exp :\nConvex Exp ",
        "parse-message": "unknown identifier 'Exp' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem convex_exp : Convex Real.Exp ",
        "parse-message": "unknown constant 'Real.Exp' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "exp_convex",
      "search_time": "1.4332952370168641",
      "ret-prompts": [
        {
          "statement": "theorem convex_on_exp  : convex_on ℝ set.univ real.exp",
          "sim_score": "0.8296651840209961",
          "doc_string": "`exp` is convex on the whole real line."
        },
        {
          "statement": "theorem strict_convex_on_exp  : strict_convex_on ℝ set.univ real.exp",
          "sim_score": "0.8015367984771729",
          "doc_string": "`exp` is strictly convex on the whole real line."
        },
        {
          "statement": "theorem strict_convex_on_zpow {m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) : strict_convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m)",
          "sim_score": "0.5888562202453613",
          "doc_string": "`x^m`, `m : ℤ` is convex on `(0, +∞)` for all `m` except `0` and `1`."
        },
        {
          "statement": "theorem convex_on_pow (n : ℕ) : convex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n)",
          "sim_score": "0.5808110237121582",
          "doc_string": "`x^n`, `n : ℕ` is convex on `[0, +∞)` for all `n`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"`exp` is convex on the whole real line.\" Translate the natural language version to a Lean mathlib version:\n theorem convex_on_exp :\nconvex_on ℝ set.univ real.exp := \n\nNatural language version: \"`exp` is strictly convex on the whole real line.\" Translate the natural language version to a Lean mathlib version:\n theorem strict_convex_on_exp :\nstrict_convex_on ℝ set.univ real.exp := \n\nNatural language version: \"`x^m`, `m : ℤ` is convex on `(0, +∞)` for all `m` except `0` and `1`.\" Translate the natural language version to a Lean mathlib version:\n theorem strict_convex_on_zpow{m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) :\nstrict_convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m) := \n\nNatural language version: \"`x^n`, `n : ℕ` is convex on `[0, +∞)` for all `n`\" Translate the natural language version to a Lean mathlib version:\n theorem convex_on_pow(n : ℕ) :\nconvex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n) := \n\nNatural language version: \"The exponential function is convex.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The exponential function is convex.",
      "codex_time": "3.437689333979506"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "theorem exp_convex : ConvexOn ℝ Set.univ Real.exp "
  },
  {
    "parsed": [
      "theorem Nat.exists_eq_mul_add_of_coprime{A b : ℕ} (hab : Nat.coprime A b) :\n∀ {N : ℕ}, N > (A - 1) * (b - 1) → ∃ (x y : ℕ), N = A * x + b * y "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem Int.coprime.exists_one_of_eq_one_or_lt{A b : ℤ} (h : A.coprime b) (h1 : A = 1 ∨ A < 1) (h2 : b = 1 ∨ b < 1)\n(n : ℕ) : ∃ (x y : ℤ), A * x + b * y = ↑n ",
        "parse-message": "invalid field 'coprime', the environment does not contain 'Int.coprime'\n  A\nhas type\n  ℤ (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem exists_nat_mul_eq_linear_comb_of_coprime {A b : ℕ} (h : coprime A b) :\n∀ {N : ℕ}, N > (b - 1) * (A - 1) + b + 1 → ∃ (x y : ℕ), ↑N = ↑A * x + ↑b * y ",
        "parse-message": "unknown identifier 'coprime' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem exists_gcd_eq_gcd_nat{A b : ℕ} (hab : Gcd A b = 1) {N : ℕ} (hN : N ≥ A * b) :\n∃ (x y : ℕ), ↑(x * A + y * b) = N ∧ ↑A * ↑x + ↑b * ↑y = N ",
        "parse-message": "unknown identifier 'Gcd' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem bezout.Exists{R : Type u_1} [comm_ring R] {A b x y : R} (hab : A.Gcd b = 1) (h : ¬(∃ (u v : R), A * u + b * v = 1)) :\n∃ (c : ℤ), ∀ (x y : R), A * x + b * y = c → c = 0 ∧ x = 0 ∧ y = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Nat.exists_eq_mul_add_of_coprime{A b : ℕ} (hab : Nat.coprime A b) :\n∀ {N : ℕ}, N > (A - 1) * (b - 1) → ∃ (x y : ℕ), N = A * x + b * y ",
        "code": "forall {A : Nat} {b : Nat}, (Nat.coprime A b) -> (forall {N : Nat}, (GT.gt.{?_uniq.13} Nat Nat.hasLt N (HMul.hMul.{?_uniq.16 ?_uniq.15 ?_uniq.14} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (HSub.hSub.{?_uniq.19 ?_uniq.18 ?_uniq.17} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) A (OfNat.ofNat.{?_uniq.22} Nat 1 (instOfNatNat 1))) (HSub.hSub.{?_uniq.33 ?_uniq.32 ?_uniq.31} Nat Nat Nat (instHSub.{0} Nat Nat.hasSub) b (OfNat.ofNat.{?_uniq.36} Nat 1 (instOfNatNat 1))))) -> (Exists.{?_uniq.145} Nat (fun (x : Nat) => Exists.{?_uniq.149} Nat (fun (y : Nat) => Eq.{?_uniq.153} Nat N (HAdd.hAdd.{?_uniq.156 ?_uniq.155 ?_uniq.154} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.159 ?_uniq.158 ?_uniq.157} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) A x) (HMul.hMul.{?_uniq.162 ?_uniq.161 ?_uniq.160} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) b y))))))"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "coprime_integer_span_sylvester_coin",
      "search_time": "1.4988727460149676",
      "ret-prompts": [
        {
          "statement": "theorem nat.gcd_eq_gcd_ab (x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y",
          "sim_score": "0.5282862186431885",
          "doc_string": " **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm."
        },
        {
          "statement": "theorem int.gcd_least_linear {a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)",
          "sim_score": "0.5160197615623474",
          "doc_string": " For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`"
        },
        {
          "statement": "theorem mul_eq_mul_prime_pow {R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ℕ} (hp : prime p) (hx : x * y = a * p ^ n) : ∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j",
          "sim_score": "0.4904349744319916",
          "doc_string": "If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written  as the product of a power of `p` and a divisor of `a`."
        },
        {
          "statement": "theorem unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) : (∀ {d : R}, d ∣ a → d ∣ c → ¬prime d) → a ∣ b * c → a ∣ b",
          "sim_score": "0.47909241914749146",
          "doc_string": " Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`. Compare `is_coprime.dvd_of_dvd_mul_left`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm.\" Translate the natural language version to a Lean mathlib version:\n theorem nat.gcd_eq_gcd_ab(x y : ℕ) :\n↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y := \n\nNatural language version: \" For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`\" Translate the natural language version to a Lean mathlib version:\n theorem int.gcd_least_linear{a b : ℤ} (ha : a ≠ 0) :\nis_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b) := \n\nNatural language version: \"If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written  as the product of a power of `p` and a divisor of `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem mul_eq_mul_prime_pow{R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ℕ} (hp : prime p) (hx : x * y = a * p ^ n) :\n∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j := \n\nNatural language version: \" Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`. Compare `is_coprime.dvd_of_dvd_mul_left`.\" Translate the natural language version to a Lean mathlib version:\n theorem unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors{R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) :\n(∀ {d : R}, d ∣ a → d ∣ c → ¬prime d) → a ∣ b * c → a ∣ b := \n\nNatural language version: \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
      "codex_time": "11.290124716993887"
    },
    "grouped": [
      [
        "theorem Nat.exists_eq_mul_add_of_coprime{A b : ℕ} (hab : Nat.coprime A b) :\n∀ {N : ℕ}, N > (A - 1) * (b - 1) → ∃ (x y : ℕ), N = A * x + b * y "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem coprime_integer_span_sylvester_coin : ∀ a b : ℕ, a > 0 → b > 0 → Nat.coprime a b → ∃ m : ℕ, ∀ N : ℕ, N > m → ∃ x y : ℕ, N = a*x + b*y "
  },
  {
    "parsed": [
      "theorem Nat.add_mul_self{P A b : ℕ} (hp : P.Prime) :\n↑P * ((A * b) + b + A) = (↑P * (A + b)).Pow 2 "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "theorem pow_sub_sub_mul_sub_sub_commute_aux{𝕜 : Type u_1} [field 𝕜] (P : ℕ) (ϕ : qia) (Q : Fin (nqia ϕ)) :\n (↑(ϕ.Mk Q) : ℚ) ^ P = ↑((ϕ.Mk Q).1) ^ P ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem Nat.dvd_mul_pow (P : ℕ) {A b : ℕ} (h : P.Prime) (h1 : A = (b : ℤ)) (h2 : P ∣ b) :\nP ^ 2 ∣ A * b ",
        "parse-message": "failed to synthesize\n  CoeHTCT ℤ ℕ\n(deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached (use 'set_option synthInstance.maxHeartbeats <num>' to set the limit) (during elaboration)"
      },
      {
        "success": false,
        "statement": "theorem is_ring.map_add_pow {α : Type u_1} [comm_ring α] [Field α] [DecidableEQ α] (P : Ω_α) {A b : α} (ha : P = 0) (hb : P = 0) :\npow_omega (A + b) P = pow_omega A P + pow_omega b P ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": true,
        "statement": "theorem Nat.add_mul_self{P A b : ℕ} (hp : P.Prime) :\n↑P * ((A * b) + b + A) = (↑P * (A + b)).Pow 2 ",
        "code": "forall {P : Nat} {A : Nat} {b : Nat} (hp : Nat.Prime P), Eq.{?_uniq.12} (?_uniq.53 P A b hp) (?_uniq.54 P A b hp) (?_uniq.55 P A b hp)"
      },
      {
        "success": false,
        "statement": "theorem Nat.factorization_mul_of_coprime{A b : ℕ} (hab : A.coprime b) :\n(A * b).factorization = A.factorization + b.factorization ",
        "parse-message": "function expected at\n  A * b\nterm has type\n  ℕ (during elaboration)"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": true,
      "theorem_name": "frobenius_pow_sum_eq_sum_pow",
      "search_time": "2.0902485070109833",
      "ret-prompts": [
        {
          "statement": "theorem nat.factorization_mul_of_coprime {a b : ℕ} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization",
          "sim_score": "0.6287815570831299",
          "doc_string": "For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`"
        },
        {
          "statement": "theorem nat.factorization_mul_apply_of_coprime {p a b : ℕ} (hab : a.coprime b) : ⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p",
          "sim_score": "0.6287815570831299",
          "doc_string": "For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`"
        },
        {
          "statement": "theorem nat.factorization_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factorization = a.factorization + b.factorization",
          "sim_score": "0.6084638833999634",
          "doc_string": "For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`"
        },
        {
          "statement": "theorem factorization_mul {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) : factorization (a * b) = factorization a + factorization b",
          "sim_score": "0.6084638833999634",
          "doc_string": "For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_mul_of_coprime{a b : ℕ} (hab : a.coprime b) :\n(a * b).factorization = a.factorization + b.factorization := \n\nNatural language version: \"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_mul_apply_of_coprime{p a b : ℕ} (hab : a.coprime b) :\n⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p := \n\nNatural language version: \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem nat.factorization_mul{a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n(a * b).factorization = a.factorization + b.factorization := \n\nNatural language version: \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem factorization_mul{α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) :\nfactorization (a * b) = factorization a + factorization b := \n\nNatural language version: \"In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.",
      "codex_time": "8.370010916987667"
    },
    "grouped": [
      [
        "theorem Nat.add_mul_self{P A b : ℕ} (hp : P.Prime) :\n↑P * ((A * b) + b + A) = (↑P * (A + b)).Pow 2 "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "theorem frobenius_pow_sum_eq_sum_pow {R : Type _} [CommRingₓ R] : (p : ℕ) → Prime p → CharP R p → ∀ a b : R, (a + b)^p = a^p + b^p "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] {s : set α} (h : ∀ s, is_closed s ∧ ¬ is_empty s → is_compact s) :\nis_compact α ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] (h : ∀ (s : set α), is_closed s → s ≠ Univ → is_compact s) :\nis_compact Univ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] :\n(∀ {s : set α} (hs : is_closed s) (hns : ∀ x, s x → x ≠ x), is_compact s) → is_compact α ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] (h : ∀ (s : set α) (hs : is_closed s) (hps : proper s), is_compact s) :\nis_compact α ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] (h : ∀ s, is_closed s → (s ≠ Univ → is_compact s)) : is_compact Univ ",
        "parse-message": "unknown identifier 'is_closed' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "compact_if_all_proper_compact",
      "search_time": "1.6613354209985118",
      "ret-prompts": [
        {
          "statement": "theorem compact_of_is_closed_subset {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) : is_compact t",
          "sim_score": "0.782024621963501",
          "doc_string": "A closed subset of a compact set is a compact set."
        },
        {
          "statement": "theorem is_compact_of_finite_subcover {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_compact s",
          "sim_score": "0.6621682643890381",
          "doc_string": "A set `s` is compact if for every open cover of `s`, there exists a finite subcover."
        },
        {
          "statement": "theorem is_compact.inter_right {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) : is_compact (s ∩ t)",
          "sim_score": "0.651668906211853",
          "doc_string": "The intersection of a compact set and a closed set is a compact set."
        },
        {
          "statement": "theorem is_compact.inter_left {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) : is_compact (s ∩ t)",
          "sim_score": "0.6444039344787598",
          "doc_string": "The intersection of a closed set and a compact set is a compact set."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A closed subset of a compact set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) (h : t ⊆ s) :\nis_compact t := \n\nNatural language version: \"A set `s` is compact if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) :\nis_compact s := \n\nNatural language version: \"The intersection of a compact set and a closed set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s t : set α} (hs : is_compact s) (ht : is_closed t) :\nis_compact (s ∩ t) := \n\nNatural language version: \"The intersection of a closed set and a compact set is a compact set.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s t : set α} (ht : is_compact t) (hs : is_closed s) :\nis_compact (s ∩ t) := \n\nNatural language version: \"If every proper closed set of a topological space is compact, then the space itself is compact.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every proper closed set of a topological space is compact, then the space itself is compact.",
      "codex_time": "4.641647889016895"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{α : Type _} [TopologicalSpace α] : (∀ (s : Set α), (s ≠ Set.univ) → IsCompact s) → CompactSpace α"
  },
  {
    "parsed": [
      "{P : ℕ} [Fact (Nat.Prime P)] (h : P % 4 = 3) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ",
      "{P : ℕ} [Fact (Nat.Prime P)] (hp : 1 = P % 4) :\n∃ (A b : ℕ), A + b = P ",
      "{P : ℕ} [Fact (Nat.Prime P)] (hp : ∃ k, P = 4 * k + 1) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ",
      "{P : ℕ} [Fact (Nat.Prime P)] (hp : P ≠ 2) (hp : P % 4 = 1) :\n∃ (A b : ℕ), (A ^ 2 + b ^ 2 = P) "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "{P : ℕ} [Fact (Nat.Prime P)] (h : P % 4 = 3) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ",
        "code": "forall {P : Nat} [inst._@._hyg.7 : Fact (Nat.Prime P)], (Eq.{?_uniq.8} Nat (HMod.hMod.{?_uniq.11 ?_uniq.10 ?_uniq.9} Nat Nat Nat (instHMod.{?_uniq.81} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.10} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{?_uniq.44} Nat 3 (instOfNatNat 3))) -> (Exists.{?_uniq.102} Nat (fun (A : Nat) => Exists.{?_uniq.106} Nat (fun (b : Nat) => Eq.{?_uniq.110} Nat (HAdd.hAdd.{?_uniq.113 ?_uniq.112 ?_uniq.111} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HPow.hPow.{?_uniq.116 ?_uniq.115 ?_uniq.114} Nat Nat Nat (Monoid.HPow.{?_uniq.265} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) A (OfNat.ofNat.{?_uniq.115} Nat 2 (instOfNatNat 2))) (HPow.hPow.{?_uniq.142 ?_uniq.141 ?_uniq.140} Nat Nat Nat (Monoid.HPow.{?_uniq.326} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) b (OfNat.ofNat.{?_uniq.141} Nat 2 (instOfNatNat 2)))) P)))"
      },
      {
        "success": true,
        "statement": "{P : ℕ} [Fact (Nat.Prime P)] (hp : 1 = P % 4) :\n∃ (A b : ℕ), A + b = P ",
        "code": "forall {P : Nat} [inst._@._hyg.7 : Fact (Nat.Prime P)], (Eq.{?_uniq.8} Nat (OfNat.ofNat.{?_uniq.11} Nat 1 (instOfNatNat 1)) (HMod.hMod.{?_uniq.27 ?_uniq.26 ?_uniq.25} Nat Nat Nat (instHMod.{?_uniq.81} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.26} Nat 4 (instOfNatNat 4)))) -> (Exists.{?_uniq.103} Nat (fun (A : Nat) => Exists.{?_uniq.107} Nat (fun (b : Nat) => Eq.{?_uniq.111} Nat (HAdd.hAdd.{?_uniq.114 ?_uniq.113 ?_uniq.112} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) A b) P)))"
      },
      {
        "success": true,
        "statement": "{P : ℕ} [Fact (Nat.Prime P)] (hp : ∃ k, P = 4 * k + 1) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ",
        "code": "forall {P : Nat} [inst._@._hyg.7 : Fact (Nat.Prime P)], (Exists.{?_uniq.8} Nat (fun (k : Nat) => Eq.{?_uniq.13} Nat P (HAdd.hAdd.{?_uniq.16 ?_uniq.15 ?_uniq.14} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.19 ?_uniq.18 ?_uniq.17} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{?_uniq.22} Nat 4 (instOfNatNat 4)) k) (OfNat.ofNat.{?_uniq.32} Nat 1 (instOfNatNat 1))))) -> (Exists.{?_uniq.123} Nat (fun (A : Nat) => Exists.{?_uniq.127} Nat (fun (b : Nat) => Eq.{?_uniq.131} Nat (HAdd.hAdd.{?_uniq.134 ?_uniq.133 ?_uniq.132} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HPow.hPow.{?_uniq.137 ?_uniq.136 ?_uniq.135} Nat Nat Nat (Monoid.HPow.{?_uniq.282} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) A (OfNat.ofNat.{?_uniq.136} Nat 2 (instOfNatNat 2))) (HPow.hPow.{?_uniq.163 ?_uniq.162 ?_uniq.161} Nat Nat Nat (Monoid.HPow.{?_uniq.343} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) b (OfNat.ofNat.{?_uniq.162} Nat 2 (instOfNatNat 2)))) P)))"
      },
      {
        "success": false,
        "statement": "{P : ℕ} [Fact (Nat.Prime P)] (hP : P = Nat.Succ (4*k) ↔\n                                          Nat.Prime P ∧ P % 2 = 1 ∧ P % 4 = 3) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P ",
        "parse-message": "unknown constant 'Nat.Succ' (during elaboration)"
      },
      {
        "success": true,
        "statement": "{P : ℕ} [Fact (Nat.Prime P)] (hp : P ≠ 2) (hp : P % 4 = 1) :\n∃ (A b : ℕ), (A ^ 2 + b ^ 2 = P) ",
        "code": "forall {P : Nat} [inst._@._hyg.7 : Fact (Nat.Prime P)], (Ne.{?_uniq.8} Nat P (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2))) -> (Eq.{?_uniq.23} Nat (HMod.hMod.{?_uniq.26 ?_uniq.25 ?_uniq.24} Nat Nat Nat (instHMod.{?_uniq.99} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.25} Nat 4 (instOfNatNat 4))) (OfNat.ofNat.{?_uniq.59} Nat 1 (instOfNatNat 1))) -> (Exists.{?_uniq.117} Nat (fun (A : Nat) => Exists.{?_uniq.121} Nat (fun (b : Nat) => Eq.{?_uniq.125} Nat (HAdd.hAdd.{?_uniq.128 ?_uniq.127 ?_uniq.126} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HPow.hPow.{?_uniq.131 ?_uniq.130 ?_uniq.129} Nat Nat Nat (Monoid.HPow.{?_uniq.280} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) A (OfNat.ofNat.{?_uniq.130} Nat 2 (instOfNatNat 2))) (HPow.hPow.{?_uniq.157 ?_uniq.156 ?_uniq.155} Nat Nat Nat (Monoid.HPow.{?_uniq.338} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) b (OfNat.ofNat.{?_uniq.156} Nat 2 (instOfNatNat 2)))) P)))"
      }
    ],
    "number-parsed": 4,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "fermat_two_square",
      "search_time": "1.6139122870226856",
      "ret-prompts": [
        {
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
          "sim_score": "0.6522289514541626",
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**."
        },
        {
          "statement": "theorem nat.sum_four_squares (n : ℕ) : ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n",
          "sim_score": "0.5913749933242798",
          "doc_string": "**Four squares theorem**"
        },
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.49175825715065",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        },
        {
          "statement": "theorem nat.min_fac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) : n.min_fac ^ 2 ≤ n",
          "sim_score": "0.48426979780197144",
          "doc_string": "The square of the smallest prime factor of a composite number `n` is at most `n`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \"**Four squares theorem**\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\n∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"The square of the smallest prime factor of a composite number `n` is at most `n`.\" Translate the natural language version to a Lean mathlib version:\n theorem {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) :\nn.min_fac ^ 2 ≤ n := \n\nNatural language version: \"Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every prime that is one greater than a multiple of four can be expressed as the sum of two squares.",
      "codex_time": "5.032618942001136"
    },
    "grouped": [
      [
        "{P : ℕ} [Fact (Nat.Prime P)] (h : P % 4 = 3) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P "
      ],
      [
        "{P : ℕ} [Fact (Nat.Prime P)] (hp : 1 = P % 4) :\n∃ (A b : ℕ), A + b = P "
      ],
      [
        "{P : ℕ} [Fact (Nat.Prime P)] (hp : ∃ k, P = 4 * k + 1) :\n∃ (A b : ℕ), A ^ 2 + b ^ 2 = P "
      ],
      [
        "{P : ℕ} [Fact (Nat.Prime P)] (hp : P ≠ 2) (hp : P % 4 = 1) :\n∃ (A b : ℕ), (A ^ 2 + b ^ 2 = P) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ p : ℕ, Prime p → (p % 4 = 1) → ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "∀ (s : set ℝ²) (t : set.ioc 0 1), ∃ (A b : ℝ²), (A, b) ∈ (segment_def ℝ 1) ∧ (∀ (t : 𝕜",
        "parse-message": "<input>:1:0: expected ':'"
      },
      {
        "success": false,
        "statement": "{E : Type u_2} [NormedGroup E] [NormedSpace ℝ E] (s : set E) (x y : E) :\n∃z, z ∈ Metric.Ball ℝ x 1 ∧ z ∈ Metric.Ball ℝ y 1 ∧ (z ∈ s ↔ x ∈ s) ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{ℝ_2 : Type u_2} [InnerProductSpace ℝ ℝ_2] {s : set ℝ_2} (T : AffineIndependent ℝ s) : ∃ x y : ℝ_2, ∥x - y∥ = 1 ∧ sign_condition ℝ s x y ",
        "parse-message": "parsed to  {  ℝ_2 :  Type  u_2 } ->  [  InnerProductSpace   ℝ ℝ_2 ] ->  {  s :  set  ℝ_2 } ->  (  T :  AffineIndependent   ℝ s ) ->  ∃     x  y  : ℝ_2 ,    ∥  x - y ∥ =  1 ∧  sign_condition   ℝ s x y; error while parsing as theorem: <input>:1:157: expected term"
      },
      {
        "success": false,
        "statement": "{E : Type u_2} {𝕜 : Type u_3} [NormedField 𝕜] [NormedGroup E] [NormedSpace 𝕜 E] {s : set E} (hs : Simplex 𝕜 s) : \n ∃ x y : E , x ∈ Closure s ∧ (y ∈ Interior s ∨ y ∈ Closure (Univ \\ s)) ∧ Abs (y - x) = 1 ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{E : Type u_2} {𝕜 : Type u_3} [LinearOrderedField 𝕜] [add_comm_group E] [module 𝕜 E] [TopologicalSpace E] [bounded_linear_ordered_field 𝕜] [TopologicalAddGroup E] [HasContinuousConstSMul 𝕜 E] {s : set E} {x y : E} (h : ~(Interior s = ∅)) :\n∃ θ : ℝ, θ ∈ set.ioc 0 (2 * π) ∧ (λ (t :",
        "parse-message": "<input>:2:40: unexpected end of input"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "unit_line_in_or_out_of_euclidean_plane_subset",
      "search_time": "1.4950008899904788",
      "ret-prompts": [
        {
          "statement": "theorem convex.add_smul_sub_mem_interior {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s",
          "sim_score": "0.5471247434616089",
          "doc_string": "If `x ∈ s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`."
        },
        {
          "statement": "theorem open_segment_subset_ball_of_ne {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) : open_segment ℝ x y ⊆ metric.ball z r",
          "sim_score": "0.5154375433921814",
          "doc_string": " If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is included in the corresponding open ball."
        },
        {
          "statement": "theorem mem_tangent_cone_of_segment_subset {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : segment ℝ x y ⊆ s) : y - x ∈ tangent_cone_at ℝ s x",
          "sim_score": "0.5063760280609131",
          "doc_string": " If a subset of a real vector space contains a segment, then the direction of this segment belongs to the tangent cone at its endpoints."
        },
        {
          "statement": "theorem convex.add_smul_sub_mem_interior' {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) : x + t • (y - x) ∈ interior s",
          "sim_score": "0.5046789050102234",
          "doc_string": "If `x ∈ closure s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If `x ∈ s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) :\nx + t • (y - x) ∈ interior s := \n\nNatural language version: \" If `x ≠ y` belong to the same closed ball, then the open segment with endpoints `x` and `y` is included in the corresponding open ball.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_2} [normed_group E] [normed_space ℝ E] [strict_convex_space ℝ E] {x y z : E} {r : ℝ} (hx : x ∈ metric.closed_ball z r) (hy : y ∈ metric.closed_ball z r) (hne : x ≠ y) :\nopen_segment ℝ x y ⊆ metric.ball z r := \n\nNatural language version: \" If a subset of a real vector space contains a segment, then the direction of this segment belongs to the tangent cone at its endpoints.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_4} [normed_group G] [normed_space ℝ G] {s : set G} {x y : G} (h : segment ℝ x y ⊆ s) :\ny - x ∈ tangent_cone_at ℝ s x := \n\nNatural language version: \"If `x ∈ closure s` and `y ∈ interior s`, then the segment `(x, y]` is included in `interior s`.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_2} {𝕜 : Type u_3} [linear_ordered_field 𝕜] [add_comm_group E] [module 𝕜 E] [topological_space E] [topological_add_group E] [has_continuous_const_smul 𝕜 E] {s : set E} (hs : convex 𝕜 s) {x y : E} (hx : x ∈ closure s) (hy : y ∈ interior s) {t : 𝕜} (ht : t ∈ set.Ioc 0 1) :\nx + t • (y - x) ∈ interior s := \n\nNatural language version: \"For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "For every subset of the Euclidean plane, there is a line segment of unit length whose endpoints are either both inside the subset or both outside it.",
      "codex_time": "11.452028172992868"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ (S : Set $ EuclideanSpace ℝ (Finₓ 2)), ∃ (x y : EuclideanSpace ℝ (Finₓ 2)), (∥x - y∥ = (1 : ℝ)) → (x ∈ S ∧ y ∈ S) ∨ (x ∉ S ∧ y ∉ S) "
  },
  {
    "parsed": [
      "{R : Type u} [Ring R] (h : ∀ (x : R), x + x = x) :\ncommutative R ",
      "{R : Type u} [Ring R] (h : ∀ (x : R), x^2 = x) :\ncommutative R "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u} [Ring α] (h : ∀ x, x * x = x) :\ncomm_ring α ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": true,
        "statement": "{R : Type u} [Ring R] (h : ∀ (x : R), x + x = x) :\ncommutative R ",
        "code": "forall {R : Type.{u}} [inst._@._hyg.5 : Ring.{?_uniq.5} R] (h : forall (x : R), Eq.{?_uniq.12} R (HAdd.hAdd.{?_uniq.15 ?_uniq.14 ?_uniq.13} R R R (instHAdd.{u} R (Distrib.toAdd.{u} R (NonUnitalNonAssocSemiring.toDistrib.{u} R (NonAssocSemiring.toNonUnitalNonAssocSemiring.{u} R (Semiring.toNonAssocSemiring.{u} R (Ring.toSemiring.{u} R inst._@._hyg.5)))))) x x) x), commutative.{?_uniq.73} (?_uniq.304 R inst._@._hyg.5 h) (?_uniq.305 R inst._@._hyg.5 h)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [Ring R] (h : ∀ x : R, x * x = x) :\nis_comm_ring R ",
        "parse-message": "unknown identifier 'is_comm_ring' (during elaboration)"
      },
      {
        "success": true,
        "statement": "{R : Type u} [Ring R] (h : ∀ (x : R), x^2 = x) :\ncommutative R ",
        "code": "forall {R : Type.{u}} [inst._@._hyg.5 : Ring.{?_uniq.5} R] (h : forall (x : R), Eq.{?_uniq.12} R (HPow.hPow.{?_uniq.15 ?_uniq.14 ?_uniq.13} R Nat R (Monoid.HPow.{?_uniq.76} R (MonoidWithZero.toMonoid.{u} R (Semiring.toMonoidWithZero.{u} R (Ring.toSemiring.{u} R inst._@._hyg.5)))) x (OfNat.ofNat.{?_uniq.14} Nat 2 (instOfNatNat 2))) x), commutative.{?_uniq.115} (?_uniq.346 R inst._@._hyg.5 h) (?_uniq.347 R inst._@._hyg.5 h)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [Ring R] (h : ∀ (x : R), x * x = x) :\nis_comm_ring R ",
        "parse-message": "unknown identifier 'is_comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 2,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "all_idempotent_implies_commutative",
      "search_time": "1.448395250015892",
      "ret-prompts": [
        {
          "statement": "theorem is_ring_hom.id {α : Type u} [ring α] : is_ring_hom id",
          "sim_score": "0.6198770999908447",
          "doc_string": "The identity map is a ring homomorphism."
        },
        {
          "statement": "theorem subalgebra.mul_self {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) : S.to_submodule * S.to_submodule = S.to_submodule",
          "sim_score": "0.6067196130752563",
          "doc_string": "As submodules, subalgebras are idempotent."
        },
        {
          "statement": "theorem subring.ext {R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) : S = T",
          "sim_score": "0.5843548774719238",
          "doc_string": "Two subrings are equal if they have the same elements."
        },
        {
          "statement": "theorem add_con.add_con_gen_idem {M : Type u_1} [has_add M] (r : M → M → Prop) : add_con_gen ⇑(add_con_gen r) = add_con_gen r",
          "sim_score": "0.5717903971672058",
          "doc_string": "The map sending a binary relation to the smallest additive congruence relation in which it is contained is idempotent."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The identity map is a ring homomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [ring α] :\nis_ring_hom id := \n\nNatural language version: \"As submodules, subalgebras are idempotent.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {A : Type u_2} [comm_semiring R] [semiring A] [algebra R A] (S : subalgebra R A) :\nS.to_submodule * S.to_submodule = S.to_submodule := \n\nNatural language version: \"Two subrings are equal if they have the same elements.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [ring R] {S T : subring R} (h : ∀ (x : R), x ∈ S ↔ x ∈ T) :\nS = T := \n\nNatural language version: \"The map sending a binary relation to the smallest additive congruence relation in which it is contained is idempotent.\" Translate the natural language version to a Lean mathlib version:\n theorem {M : Type u_1} [has_add M] (r : M → M → Prop) :\nadd_con_gen ⇑(add_con_gen r) = add_con_gen r := \n\nNatural language version: \"A ring with all elements idempotent is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A ring with all elements idempotent is commutative.",
      "codex_time": "4.747569280007156"
    },
    "grouped": [
      [
        "{R : Type u} [Ring R] (h : ∀ (x : R), x + x = x) :\ncommutative R "
      ],
      [
        "{R : Type u} [Ring R] (h : ∀ (x : R), x^2 = x) :\ncommutative R "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "{R : Type _} [Ring R] : (∀ x : R, x * x = 1) → CommRing R "
  },
  {
    "parsed": [
      ":\n∀ n, ∃ P Q, Nat.Prime P ∧ Nat.Prime Q ∧ P + 2 = Q ",
      ":\n∀ (n : ℕ),\n∃ (pp : ℕ), Nat.Prime pp ∧ ∃ (pp' : ℕ), Nat.Prime pp' ∧ pp'=pp+2 ",
      "(P Q : ℕ) : Nat.Prime P → Nat.Prime Q → ∃ (R : ℕ), Nat.Prime R ∧ ∃ (s : ℕ), Nat.Prime s ∧ P + 2 = R ∧ Q + 2 = s ",
      "{P Q : ℕ} [Fact (Nat.Prime P)] [Fact (Nat.Prime Q)] (h₁ : P ≠ Q) :\n∃ (k : ℕ) (hp ha : Nat.Prime (2 * k + 1)) (h₂ : P = 2 * k + 1 ∨ Q = 2 * k + 1),\n(2 * k + 1 = P ∨ 2 * k + 1 = Q) ∧ (2 * k + 1 = P ∨ (2 * k + 2) = Q) "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": ": ∀n, ∃[Fact (Nat.Prime P)] [Fact (Nat.Prime (P + 2))], P > n ",
        "parse-message": "<input>:1:7: expected '(', '_' or identifier"
      },
      {
        "success": true,
        "statement": ":\n∀ n, ∃ P Q, Nat.Prime P ∧ Nat.Prime Q ∧ P + 2 = Q ",
        "code": "?_uniq.2 -> (Exists.{?_uniq.5} Nat (fun (P : Nat) => Exists.{?_uniq.10} Nat (fun (Q : Nat) => And (Nat.Prime P) (And (Nat.Prime Q) (Eq.{?_uniq.15} Nat (HAdd.hAdd.{?_uniq.18 ?_uniq.17 ?_uniq.16} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P (OfNat.ofNat.{?_uniq.21} Nat 2 (instOfNatNat 2))) Q)))))"
      },
      {
        "success": true,
        "statement": ":\n∀ (n : ℕ),\n∃ (pp : ℕ), Nat.Prime pp ∧ ∃ (pp' : ℕ), Nat.Prime pp' ∧ pp'=pp+2 ",
        "code": "Nat -> (Exists.{?_uniq.4} Nat (fun (pp : Nat) => And (Nat.Prime pp) (Exists.{?_uniq.8} Nat (fun (pp' : Nat) => And (Nat.Prime pp') (Eq.{?_uniq.12} Nat pp' (HAdd.hAdd.{?_uniq.15 ?_uniq.14 ?_uniq.13} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) pp (OfNat.ofNat.{?_uniq.18} Nat 2 (instOfNatNat 2))))))))"
      },
      {
        "success": true,
        "statement": "(P Q : ℕ) : Nat.Prime P → Nat.Prime Q → ∃ (R : ℕ), Nat.Prime R ∧ ∃ (s : ℕ), Nat.Prime s ∧ P + 2 = R ∧ Q + 2 = s ",
        "code": "forall (P : Nat) (Q : Nat), (Nat.Prime P) -> (Nat.Prime Q) -> (Exists.{?_uniq.10} Nat (fun (R : Nat) => And (Nat.Prime R) (Exists.{?_uniq.14} Nat (fun (s : Nat) => And (Nat.Prime s) (And (Eq.{?_uniq.18} Nat (HAdd.hAdd.{?_uniq.21 ?_uniq.20 ?_uniq.19} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P (OfNat.ofNat.{?_uniq.24} Nat 2 (instOfNatNat 2))) R) (Eq.{?_uniq.74} Nat (HAdd.hAdd.{?_uniq.77 ?_uniq.76 ?_uniq.75} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) Q (OfNat.ofNat.{?_uniq.80} Nat 2 (instOfNatNat 2))) s))))))"
      },
      {
        "success": true,
        "statement": "{P Q : ℕ} [Fact (Nat.Prime P)] [Fact (Nat.Prime Q)] (h₁ : P ≠ Q) :\n∃ (k : ℕ) (hp ha : Nat.Prime (2 * k + 1)) (h₂ : P = 2 * k + 1 ∨ Q = 2 * k + 1),\n(2 * k + 1 = P ∨ 2 * k + 1 = Q) ∧ (2 * k + 1 = P ∨ (2 * k + 2) = Q) ",
        "code": "forall {P : Nat} {Q : Nat} [inst._@._hyg.10 : Fact (Nat.Prime P)] [inst._@._hyg.17 : Fact (Nat.Prime Q)] (h₁ : Ne.{?_uniq.13} Nat P Q), Exists.{?_uniq.17} Nat (fun (k : Nat) => Exists.{?_uniq.21} (Nat.Prime (HAdd.hAdd.{0 0 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{0 0 0} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (fun (hp : Nat.Prime (HAdd.hAdd.{?_uniq.26 ?_uniq.25 ?_uniq.24} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.29 ?_uniq.28 ?_uniq.27} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{?_uniq.32} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{?_uniq.42} Nat 1 (instOfNatNat 1)))) => Exists.{?_uniq.118} (Nat.Prime (HAdd.hAdd.{0 0 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{0 0 0} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{0} Nat 2 (?_uniq.807 P Q inst._@._hyg.10 inst._@._hyg.17 h₁ k hp)) k) (OfNat.ofNat.{0} Nat 1 (?_uniq.808 P Q inst._@._hyg.10 inst._@._hyg.17 h₁ k hp)))) (fun (ha : Nat.Prime (HAdd.hAdd.{?_uniq.123 ?_uniq.122 ?_uniq.121} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.126 ?_uniq.125 ?_uniq.124} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{?_uniq.129} Nat 2 (?_uniq.807 P Q inst._@._hyg.10 inst._@._hyg.17 h₁ k hp)) k) (OfNat.ofNat.{?_uniq.139} Nat 1 (?_uniq.808 P Q inst._@._hyg.10 inst._@._hyg.17 h₁ k hp)))) => Exists.{?_uniq.227} (Or (Eq.{1} Nat P (HAdd.hAdd.{0 0 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{0 0 0} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1)))) (Eq.{1} Nat Q (HAdd.hAdd.{0 0 0} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{0 0 0} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{0} Nat 1 (instOfNatNat 1))))) (fun (h₂ : Or (Eq.{?_uniq.230} Nat P (HAdd.hAdd.{?_uniq.233 ?_uniq.232 ?_uniq.231} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.236 ?_uniq.235 ?_uniq.234} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{?_uniq.239} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{?_uniq.249} Nat 1 (instOfNatNat 1)))) (Eq.{?_uniq.317} Nat Q (HAdd.hAdd.{?_uniq.320 ?_uniq.319 ?_uniq.318} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.323 ?_uniq.322 ?_uniq.321} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{?_uniq.326} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{?_uniq.336} Nat 1 (instOfNatNat 1))))) => And (Or (Eq.{?_uniq.405} Nat (HAdd.hAdd.{?_uniq.408 ?_uniq.407 ?_uniq.406} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.411 ?_uniq.410 ?_uniq.409} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{?_uniq.414} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{?_uniq.424} Nat 1 (instOfNatNat 1))) P) (Eq.{?_uniq.501} Nat (HAdd.hAdd.{?_uniq.504 ?_uniq.503 ?_uniq.502} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.507 ?_uniq.506 ?_uniq.505} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{?_uniq.510} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{?_uniq.520} Nat 1 (instOfNatNat 1))) Q)) (Or (Eq.{?_uniq.597} Nat (HAdd.hAdd.{?_uniq.600 ?_uniq.599 ?_uniq.598} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.603 ?_uniq.602 ?_uniq.601} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{?_uniq.606} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{?_uniq.616} Nat 1 (instOfNatNat 1))) P) (Eq.{?_uniq.693} Nat (HAdd.hAdd.{?_uniq.696 ?_uniq.695 ?_uniq.694} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.699 ?_uniq.698 ?_uniq.697} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (OfNat.ofNat.{?_uniq.702} Nat 2 (instOfNatNat 2)) k) (OfNat.ofNat.{?_uniq.712} Nat 2 (instOfNatNat 2))) Q))))))"
      }
    ],
    "number-parsed": 4,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "twin_prime_conjecture",
      "search_time": "1.6370324949966744",
      "ret-prompts": [
        {
          "statement": "theorem nat.exists_prime_ge_modeq_one {k : ℕ} (n : ℕ) (hpos : 0 < k) : ∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k]",
          "sim_score": "0.53578782081604",
          "doc_string": "For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`."
        },
        {
          "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p",
          "sim_score": "0.525439977645874",
          "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`."
        },
        {
          "statement": "theorem ordinal.infinite_pigeonhole {β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β) (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) : ∃ (a : α), cardinal.mk ↥(f ⁻¹' {a}) = cardinal.mk β",
          "sim_score": "0.5173879861831665",
          "doc_string": "The infinite pigeonhole principle"
        },
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.48807522654533386",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`.\" Translate the natural language version to a Lean mathlib version:\n theorem {k : ℕ} (n : ℕ) (hpos : 0 < k) :\n∃ (p : ℕ), nat.prime p ∧ n ≤ p ∧ p ≡ 1 [MOD k] := \n\nNatural language version: \" Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\n∃ (p : ℕ), n ≤ p ∧ nat.prime p := \n\nNatural language version: \"The infinite pigeonhole principle\" Translate the natural language version to a Lean mathlib version:\n theorem {β α : Type u} (f : β → α) (h₁ : cardinal.aleph_0 ≤ cardinal.mk β) (h₂ : cardinal.mk α < (cardinal.mk β).ord.cof) :\n∃ (a : α), cardinal.mk ↥(f ⁻¹' {a}) = cardinal.mk β := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"There are infinitely many pairs of primes that differ exactly by two.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "There are infinitely many pairs of primes that differ exactly by two.",
      "codex_time": "11.843190373998368"
    },
    "grouped": [
      [
        ":\n∀ n, ∃ P Q, Nat.Prime P ∧ Nat.Prime Q ∧ P + 2 = Q "
      ],
      [
        ":\n∀ (n : ℕ),\n∃ (pp : ℕ), Nat.Prime pp ∧ ∃ (pp' : ℕ), Nat.Prime pp' ∧ pp'=pp+2 "
      ],
      [
        "(P Q : ℕ) : Nat.Prime P → Nat.Prime Q → ∃ (R : ℕ), Nat.Prime R ∧ ∃ (s : ℕ), Nat.Prime s ∧ P + 2 = R ∧ Q + 2 = s "
      ],
      [
        "{P Q : ℕ} [Fact (Nat.Prime P)] [Fact (Nat.Prime Q)] (h₁ : P ≠ Q) :\n∃ (k : ℕ) (hp ha : Nat.Prime (2 * k + 1)) (h₂ : P = 2 * k + 1 ∨ Q = 2 * k + 1),\n(2 * k + 1 = P ∨ 2 * k + 1 = Q) ∧ (2 * k + 1 = P ∨ (2 * k + 2) = Q) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ n : ℕ, ∃ p : ℕ, p > n → Prime p → Prime (p + 2) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "(K : Type u) [Fintype K] [DivisionRing K] :\nfield K ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u} [Fintype K] [DivisionRing K] :\nfield K ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(K : Type u) [DivisionRing K] (s : FiniteDimensional.finrank K K < WithTOP.ω) :\nField K ",
        "parse-message": "unknown identifier 'WithTOP.ω' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(K : Type u) [DivisionRing K] [Fintype K] : is_field_of_fintype K ",
        "parse-message": "unknown identifier 'is_field_of_fintype' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u} [DivisionRing K] (h : Finite K) :\nfield K ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "fin_div_ring_is_field",
      "search_time": "1.5387114559998736",
      "ret-prompts": [
        {
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s",
          "sim_score": "0.6756068468093872",
          "doc_string": "A subfield is closed under division."
        },
        {
          "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1",
          "sim_score": "0.6545361280441284",
          "doc_string": "A division_ring is one-dimensional as a vector space over itself."
        },
        {
          "statement": "theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S",
          "sim_score": "0.6345528364181519",
          "doc_string": "An intermediate field is closed under division."
        },
        {
          "statement": "theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s",
          "sim_score": "0.62082839012146",
          "doc_string": "A subfield is closed under multiplication."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"A division_ring is one-dimensional as a vector space over itself.\" Translate the natural language version to a Lean mathlib version:\n theorem (K : Type u) [division_ring K] :\nfinite_dimensional.finrank K K = 1 := \n\nNatural language version: \"An intermediate field is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} :\nx ∈ S → y ∈ S → x / y ∈ S := \n\nNatural language version: \"A subfield is closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x * y ∈ s := \n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite division ring is a field.",
      "codex_time": "3.1822543120069895"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{R : Type _} [DivisionRing R] [Finite R] : Field R "
  },
  {
    "parsed": [
      "(x y : ℝ) (hx0 : 0 < x) (hy0 : 0 < y) :\nx * y ≤ x + y ",
      "{A b : ℝ} (h : 0 < A) (h' : 0 < b) :\nA * b ≤ (A + b) ^ 2 / 4. ",
      "{A b : ℝ} (ha : 0 < A) (hb : 0 < b) :\nA * b ≤ (A + b) ^ 2 / 4 ",
      "{A b : ℝ} (ha : 0 ≤ A) (hb : 0 ≤ b) :\nA * b ≤ (A + b)^2 / 2 ",
      "{A b : ℝ} (h₁ : 0 ≤ A) (h₂ : 0 ≤ b) :\nA * b ≤ ((A + b) / 2) ^ 2 "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "(x y : ℝ) (hx0 : 0 < x) (hy0 : 0 < y) :\nx * y ≤ x + y ",
        "code": "forall (x : Real) (y : Real), (LT.lt.{?_uniq.7} Real Real.hasLt (OfNat.ofNat.{?_uniq.10} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) x) -> (LT.lt.{?_uniq.59} Real Real.hasLt (OfNat.ofNat.{?_uniq.62} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) y) -> (LE.le.{?_uniq.85} Real Real.hasLe (HMul.hMul.{?_uniq.88 ?_uniq.87 ?_uniq.86} Real Real Real (instHMul.{0} Real Real.hasMul) x y) (HAdd.hAdd.{?_uniq.91 ?_uniq.90 ?_uniq.89} Real Real Real (instHAdd.{0} Real Real.hasAdd) x y))"
      },
      {
        "success": true,
        "statement": "{A b : ℝ} (h : 0 < A) (h' : 0 < b) :\nA * b ≤ (A + b) ^ 2 / 4. ",
        "code": "forall {A : Real} {b : Real} (h : LT.lt.{?_uniq.7} Real Real.hasLt (OfNat.ofNat.{?_uniq.10} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) A) (h' : LT.lt.{?_uniq.59} Real Real.hasLt (OfNat.ofNat.{?_uniq.62} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) b), LE.le.{?_uniq.85} Real Real.hasLe (HMul.hMul.{?_uniq.88 ?_uniq.87 ?_uniq.86} Real Real Real (instHMul.{0} Real Real.hasMul) A b) (HDiv.hDiv.{?_uniq.91 ?_uniq.90 ?_uniq.89} Real Real Real (instHDiv.{0} Real (DivInvMonoidₓ.toHasDiv.{0} Real (Field.toDivInvMonoid.{0} Real Real.field))) (HPow.hPow.{?_uniq.94 ?_uniq.93 ?_uniq.92} Real Nat Real (instHPow.{0 0} Real Nat (Monoidₓ.hasPow.{0} Real Real.monoid)) (HAdd.hAdd.{?_uniq.101 ?_uniq.100 ?_uniq.99} Real Real Real (instHAdd.{0} Real Real.hasAdd) A b) (OfNat.ofNat.{?_uniq.93} Nat 2 (instOfNatNat 2))) (OfScientific.ofScientific.{?_uniq.149} Real (?_uniq.451 A b h h') 4 Bool.true 0))"
      },
      {
        "success": true,
        "statement": "{A b : ℝ} (ha : 0 < A) (hb : 0 < b) :\nA * b ≤ (A + b) ^ 2 / 4 ",
        "code": "forall {A : Real} {b : Real} (ha : LT.lt.{?_uniq.7} Real Real.hasLt (OfNat.ofNat.{?_uniq.10} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) A) (hb : LT.lt.{?_uniq.59} Real Real.hasLt (OfNat.ofNat.{?_uniq.62} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) b), LE.le.{?_uniq.85} Real Real.hasLe (HMul.hMul.{?_uniq.88 ?_uniq.87 ?_uniq.86} Real Real Real (instHMul.{0} Real Real.hasMul) A b) (HDiv.hDiv.{?_uniq.91 ?_uniq.90 ?_uniq.89} Real Real Real (instHDiv.{0} Real (DivInvMonoidₓ.toHasDiv.{0} Real (Field.toDivInvMonoid.{0} Real Real.field))) (HPow.hPow.{?_uniq.94 ?_uniq.93 ?_uniq.92} Real Nat Real (instHPow.{0 0} Real Nat (Monoidₓ.hasPow.{0} Real Real.monoid)) (HAdd.hAdd.{?_uniq.101 ?_uniq.100 ?_uniq.99} Real Real Real (instHAdd.{0} Real Real.hasAdd) A b) (OfNat.ofNat.{?_uniq.93} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.149} Real 4 (?_uniq.509 A b ha hb)))"
      },
      {
        "success": true,
        "statement": "{A b : ℝ} (ha : 0 ≤ A) (hb : 0 ≤ b) :\nA * b ≤ (A + b)^2 / 2 ",
        "code": "forall {A : Real} {b : Real} (ha : LE.le.{?_uniq.7} Real Real.hasLe (OfNat.ofNat.{?_uniq.10} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) A) (hb : LE.le.{?_uniq.59} Real Real.hasLe (OfNat.ofNat.{?_uniq.62} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) b), LE.le.{?_uniq.85} Real Real.hasLe (HMul.hMul.{?_uniq.88 ?_uniq.87 ?_uniq.86} Real Real Real (instHMul.{0} Real Real.hasMul) A b) (HDiv.hDiv.{?_uniq.91 ?_uniq.90 ?_uniq.89} Real Real Real (instHDiv.{0} Real (DivInvMonoidₓ.toHasDiv.{0} Real (Field.toDivInvMonoid.{0} Real Real.field))) (HPow.hPow.{?_uniq.94 ?_uniq.93 ?_uniq.92} Real Nat Real (instHPow.{0 0} Real Nat (Monoidₓ.hasPow.{0} Real Real.monoid)) (HAdd.hAdd.{?_uniq.101 ?_uniq.100 ?_uniq.99} Real Real Real (instHAdd.{0} Real Real.hasAdd) A b) (OfNat.ofNat.{?_uniq.93} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.149} Real 2 (?_uniq.505 A b ha hb)))"
      },
      {
        "success": true,
        "statement": "{A b : ℝ} (h₁ : 0 ≤ A) (h₂ : 0 ≤ b) :\nA * b ≤ ((A + b) / 2) ^ 2 ",
        "code": "forall {A : Real} {b : Real} (h₁ : LE.le.{?_uniq.7} Real Real.hasLe (OfNat.ofNat.{?_uniq.10} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) A) (h₂ : LE.le.{?_uniq.59} Real Real.hasLe (OfNat.ofNat.{?_uniq.62} Real 0 (Zero.toOfNat0.{0} Real Real.hasZero)) b), LE.le.{?_uniq.85} Real Real.hasLe (HMul.hMul.{?_uniq.88 ?_uniq.87 ?_uniq.86} Real Real Real (instHMul.{0} Real Real.hasMul) A b) (HPow.hPow.{?_uniq.91 ?_uniq.90 ?_uniq.89} Real Nat Real (instHPow.{0 0} Real Nat (Monoidₓ.hasPow.{0} Real Real.monoid)) (HDiv.hDiv.{?_uniq.98 ?_uniq.97 ?_uniq.96} Real Real Real (instHDiv.{0} Real (DivInvMonoidₓ.toHasDiv.{0} Real (Field.toDivInvMonoid.{0} Real Real.field))) (HAdd.hAdd.{?_uniq.101 ?_uniq.100 ?_uniq.99} Real Real Real (instHAdd.{0} Real Real.hasAdd) A b) (OfNat.ofNat.{?_uniq.104} Real 2 (?_uniq.505 A b h₁ h₂))) (OfNat.ofNat.{?_uniq.90} Nat 2 (instOfNatNat 2)))"
      }
    ],
    "number-parsed": 5,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "am_gm_ineq",
      "search_time": "1.465386819007108",
      "ret-prompts": [
        {
          "statement": "theorem nnreal.geom_mean_le_arith_mean2_weighted (w₁ w₂ p₁ p₂ : nnreal) : w₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂",
          "sim_score": "0.5334862470626831",
          "doc_string": " The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers."
        },
        {
          "statement": "theorem nat.min_fac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) : n.min_fac ^ 2 ≤ n",
          "sim_score": "0.5259432196617126",
          "doc_string": "The square of the smallest prime factor of a composite number `n` is at most `n`."
        },
        {
          "statement": "theorem real.geom_mean_le_arith_mean_weighted {ι : Type u} (s : finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) : s.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i)",
          "sim_score": "0.5007948279380798",
          "doc_string": " AM-GM inequality: the **geometric mean is less than or equal to the arithmetic mean**, weighted version for real-valued nonnegative functions."
        },
        {
          "statement": "theorem real.nat_sqrt_le_real_sqrt {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a",
          "sim_score": "0.4941546320915222",
          "doc_string": "The natural square root is at most the real square root"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" The geometric mean is less than or equal to the arithmetic mean, weighted version for two `nnreal` numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem (w₁ w₂ p₁ p₂ : nnreal) :\nw₁ + w₂ = 1 → p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂ := \n\nNatural language version: \"The square of the smallest prime factor of a composite number `n` is at most `n`.\" Translate the natural language version to a Lean mathlib version:\n theorem {n : ℕ} (w : 0 < n) (h : ¬nat.prime n) :\nn.min_fac ^ 2 ≤ n := \n\nNatural language version: \" AM-GM inequality: the **geometric mean is less than or equal to the arithmetic mean**, weighted version for real-valued nonnegative functions.\" Translate the natural language version to a Lean mathlib version:\n theorem {ι : Type u} (s : finset ι) (w z : ι → ℝ) (hw : ∀ (i : ι), i ∈ s → 0 ≤ w i) (hw' : s.sum (λ (i : ι), w i) = 1) (hz : ∀ (i : ι), i ∈ s → 0 ≤ z i) :\ns.prod (λ (i : ι), z i ^ w i) ≤ s.sum (λ (i : ι), w i * z i) := \n\nNatural language version: \"The natural square root is at most the real square root\" Translate the natural language version to a Lean mathlib version:\n theorem {a : ℕ} :\n↑(nat.sqrt a) ≤ real.sqrt ↑a := \n\nNatural language version: \"The product of two positive numbers is at most the square of their average.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of two positive numbers is at most the square of their average.",
      "codex_time": "7.779130658018403"
    },
    "grouped": [
      [
        "(x y : ℝ) (hx0 : 0 < x) (hy0 : 0 < y) :\nx * y ≤ x + y "
      ],
      [
        "{A b : ℝ} (h : 0 < A) (h' : 0 < b) :\nA * b ≤ (A + b) ^ 2 / 4. ",
        "{A b : ℝ} (ha : 0 < A) (hb : 0 < b) :\nA * b ≤ (A + b) ^ 2 / 4 "
      ],
      [
        "{A b : ℝ} (ha : 0 ≤ A) (hb : 0 ≤ b) :\nA * b ≤ (A + b)^2 / 2 "
      ],
      [
        "{A b : ℝ} (h₁ : 0 ≤ A) (h₂ : 0 ≤ b) :\nA * b ≤ ((A + b) / 2) ^ 2 "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ (a b : ℝ), a > 0 → b > 0 → a * b ≤ ((a + b)/(1 + 1))^2 "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "two_lines :\n∃ l₁ l₂ : Subtype P, ∃ P₁ P₂ : P, (P₁, P₂) ∉ l₁ ∧ (P₁, P₂) ∉ l₂ ∧ (P₁, P₂) ∈ ξ ",
        "parse-message": "unknown identifier 'P' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(P : Type u) [HasMem P Configuration.points] [DecidableEQ P] [Fintype P] :\n∃ P Q : P, Function.Injective (λ (P : point_on_line k V P P Q) (l : line k V P P Q), { P, Q }) ",
        "parse-message": "unknown identifier 'Configuration.points' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(P : Type u) [HasMem P plane] [Fintype P] [DecidableEQ plane] [Fintype plane] [Nodup P] {l : plane} (hl : ∀ P, P ∈ l → P ∈ P) :\n∃ P₁ P₂, P₁ ∈ P ∧ P₂ ∈ P ∧ P₂ ≠ P₁ ∧ pairwise_eq plane P₂ P₁ l ",
        "parse-message": "unknown identifier 'plane' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{P : Type u_1} {L : Type u_2} [HasMem P L] [Fintype P] [Fintype L] (h : Fintype.Card P > 2)  :\nFintype L ",
        "parse-message": "unknown constant 'Fintype.Card' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(P : Type u) [HasMem P (L A P)] [Fintype P] [Fintype (L A P)] :\n∃ (L : set (L A P)), Fintype.Card L = 2 ∧ ∀ (l ∈ L), l ≠ 0 ",
        "parse-message": "<input>:2:47: expected ')'"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "sylvester_gallai",
      "search_time": "1.4785787790024187",
      "ret-prompts": [
        {
          "statement": "theorem collinear_singleton (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) : collinear k {p}",
          "sim_score": "0.5291177034378052",
          "doc_string": "A single point is collinear."
        },
        {
          "statement": "theorem configuration.nondegenerate.exists_injective_of_card_le {P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ≤ fintype.card P) : ∃ (f : L → P), function.injective f ∧ ∀ (l : L), f l ∉ l",
          "sim_score": "0.5157747268676758",
          "doc_string": "If a nondegenerate configuration has at least as many points as lines, then there exists  an injective function `f` from lines to points, such that `f l` does not lie on `l`."
        },
        {
          "statement": "theorem configuration.has_points.card_le (P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] : fintype.card L ≤ fintype.card P",
          "sim_score": "0.5101643800735474",
          "doc_string": "If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`."
        },
        {
          "statement": "theorem configuration.has_lines.card_le (P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] : fintype.card P ≤ fintype.card L",
          "sim_score": "0.500416100025177",
          "doc_string": "If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A single point is collinear.\" Translate the natural language version to a Lean mathlib version:\n theorem (k : Type u_1) {V : Type u_2} {P : Type u_3} [division_ring k] [add_comm_group V] [module k V] [add_torsor V P] (p : P) :\ncollinear k {p} := \n\nNatural language version: \"If a nondegenerate configuration has at least as many points as lines, then there exists  an injective function `f` from lines to points, such that `f l` does not lie on `l`.\" Translate the natural language version to a Lean mathlib version:\n theorem {P L : Type u} [has_mem P L] [configuration.nondegenerate P L] [fintype P] [fintype L] (h : fintype.card L ≤ fintype.card P) :\n∃ (f : L → P), function.injective f ∧ ∀ (l : L), f l ∉ l := \n\nNatural language version: \"If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`.\" Translate the natural language version to a Lean mathlib version:\n theorem (P L : Type u) [has_mem P L] [configuration.has_points P L] [fintype P] [fintype L] :\nfintype.card L ≤ fintype.card P := \n\nNatural language version: \"If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`.\" Translate the natural language version to a Lean mathlib version:\n theorem (P L : Type u) [has_mem P L] [configuration.has_lines P L] [fintype P] [fintype L] :\nfintype.card P ≤ fintype.card L := \n\nNatural language version: \"In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In any configuration of points on the plane, not all on a line, there is a line which contains exactly two of the points.",
      "codex_time": "7.869558934995439"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{P L : Type _} [HasMem P L] [Membership P L] [Configuration.Nondegenerate P L] : ∃ (l : L) (p q : P), p ∈ l → q ∈ l → (∀ r : P, r ∈ l → r = p ∨ r = q) "
  },
  {
    "parsed": [
      "{α : Type u} {β : Type v} (F : α → β) (g : β → α) :\n(∀ x, Function.Surjective F) → (∀ x, Function.Surjective g) →\n∃ (h : α → β), Function.Bijective h "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u_1} {β : Type u_2} {F : α → β} {g : β → α} (hf : Function.Injective F) (hg : Function.Injective g) :\n∃ (h : α ≃ β), _ ",
        "parse-message": "overloaded, errors \n  0:0 function expected at\n    β\n  term has type\n    Type u_2\n  \n  0:0 function expected at\n    β\n  term has type\n    Type u_2 (during elaboration)"
      },
      {
        "success": true,
        "statement": "{α : Type u} {β : Type v} (F : α → β) (g : β → α) :\n(∀ x, Function.Surjective F) → (∀ x, Function.Surjective g) →\n∃ (h : α → β), Function.Bijective h ",
        "code": "forall {α : Type.{u}} {β : Type.{v}} (F : α -> β) (g : β -> α), ((?_uniq.65 α β F g) -> (Function.Surjective.{?_uniq.23 ?_uniq.22} α β F)) -> ((?_uniq.66 α β F g) -> (Function.Surjective.{?_uniq.36 ?_uniq.35} β α g)) -> (Exists.{?_uniq.43} (α -> β) (fun (h : α -> β) => Function.Bijective.{?_uniq.51 ?_uniq.50} α β h))"
      },
      {
        "success": false,
        "statement": "{α : Type u} {β : Type v} (F : α → β) (g : β → α) [hf : Function.Injective F] [hg : Function.Injective g] :\n∃ (h : α → β), Function.Bijective h ",
        "parse-message": "invalid binder annotation, type is not a class instance\n  Function.Injective F\nuse the command `set_option checkBinderAnnotations false` to disable the check (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} {β : Type v} (F : α → β) (g : β → α) [hF : Function.Injective F] [Hg : Function.Injective g] :\n∃ (h : β → α), Function.Bijective h ",
        "parse-message": "invalid binder annotation, type is not a class instance\n  Function.Injective F\nuse the command `set_option checkBinderAnnotations false` to disable the check (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} {β : Type u_2} (F : α → β) {g : β → α} (hf : ∀A, ∃ha, F A = g ha) (hg : ∀b, ∃hb, g b = F hb) :\nBijective F ",
        "parse-message": "failed to synthesize\n  CoeHTCT α β\n(deterministic) timeout at 'typeclass', maximum number of heartbeats (20000) has been reached (use 'set_option synthInstance.maxHeartbeats <num>' to set the limit) (during elaboration)"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "cantor_schroeder_bernstein",
      "search_time": "1.5347542650124524",
      "ret-prompts": [
        {
          "statement": "theorem function.embedding.schroeder_bernstein {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) : ∃ (h : α → β), function.bijective h",
          "sim_score": "0.648023247718811",
          "doc_string": " **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`."
        },
        {
          "statement": "theorem category_theory.is_iso_iff_bijective {X Y : Type u} (f : X ⟶ Y) : category_theory.is_iso f ↔ function.bijective f",
          "sim_score": "0.617520809173584",
          "doc_string": "A morphism in `Type u` is an isomorphism if and only if it is bijective."
        },
        {
          "statement": "theorem category_theory.equivalence.ess_surj_of_equivalence {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.is_equivalence F] : category_theory.ess_surj F",
          "sim_score": "0.612472414970398",
          "doc_string": "An equivalence is essentially surjective.  See <https://stacks.math.columbia.edu/tag/02C3>."
        },
        {
          "statement": "theorem fintype.card_compl_eq_card_compl {α : Type u_1} [fintype α] (p q : α → Prop) [fintype {x // p x}] [fintype {x // ¬p x}] [fintype {x // q x}] [fintype {x // ¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) : fintype.card {x // ¬p x} = fintype.card {x // ¬q x}",
          "sim_score": "0.6091285347938538",
          "doc_string": "If two subtypes of a fintype have equal cardinality, so do their complements."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" **The Schröder-Bernstein Theorem**: Given injections `α → β` and `β → α`, we can get a bijection `α → β`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} {f : α → β} {g : β → α} (hf : function.injective f) (hg : function.injective g) :\n∃ (h : α → β), function.bijective h := \n\nNatural language version: \"A morphism in `Type u` is an isomorphism if and only if it is bijective.\" Translate the natural language version to a Lean mathlib version:\n theorem {X Y : Type u} (f : X ⟶ Y) :\ncategory_theory.is_iso f ↔ function.bijective f := \n\nNatural language version: \"An equivalence is essentially surjective.  See <https://stacks.math.columbia.edu/tag/02C3>.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u₁} [category_theory.category C] {D : Type u₂} [category_theory.category D] (F : C ⥤ D) [category_theory.is_equivalence F] :\ncategory_theory.ess_surj F := \n\nNatural language version: \"If two subtypes of a fintype have equal cardinality, so do their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} [fintype α] (p q : α → Prop) [fintype {x // p x}] [fintype {x // ¬p x}] [fintype {x // q x}] [fintype {x // ¬q x}] (h : fintype.card {x // p x} = fintype.card {x // q x}) :\nfintype.card {x // ¬p x} = fintype.card {x // ¬q x} := \n\nNatural language version: \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
      "codex_time": "7.486992643011035"
    },
    "grouped": [
      [
        "{α : Type u} {β : Type v} (F : α → β) (g : β → α) :\n(∀ x, Function.Surjective F) → (∀ x, Function.Surjective g) →\n∃ (h : α → β), Function.Bijective h "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "{α β : Type _} (f : α → β) (g : β → α) : Function.Injective f → Function.Injective g → (∃ h : α → β, Function.Bijective h) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj] :\n(∀ (v W : V), G.Adj v W → G.degree v = 1) → ∃ (v : V), ∀ (W : V), v ≠ W → G.Adj v W ",
        "parse-message": "<input>:2:6: expected ')'"
      },
      {
        "success": false,
        "statement": "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj] (h : ∀ (v W : V) (vw : G.Adj v W),\n    G.adj_set v ∩ G.adj_set W = {vw.2.1}) :\n∃ (v : V), (∀ (W : V), (G.adj_set v) ∩ (G.adj_set W) = {some (G.Adj v W)} ∧ G.Adj v W) ",
        "parse-message": "<input>:1:76: expected ')'"
      },
      {
        "success": false,
        "statement": "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj] (h : ∀ (v W : V), G.Adj v W → G.degree v = G.degree W ∧ G.degree v = 2) :\n∃ (v : V), ∀ (W : V), v ≠ W → G.Adj v W ",
        "parse-message": "<input>:1:76: expected ')'"
      },
      {
        "success": false,
        "statement": "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj] (h : ∀ (v W : V), v ≠ W → G.Adj v W ∨ G.Adj W v) :\n∃ (v : V), ∀ (W : V), W ≠ v → G.Adj v W ",
        "parse-message": "<input>:1:76: expected ')'"
      },
      {
        "success": false,
        "statement": "{V : Type u} (G : SimpleGraph V) [Fintype V] [DecidableRel G.Adj] (h : ∀ (v W : V), G.is_complete_graph {v, W}) :\n∃ (v : V), G.is_vertex_cover tt = ({v} : Finset V) ",
        "parse-message": "<input>:1:76: expected ')'"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "graph_unique_common_neighbour_implies_universal_adjacent_vertex",
      "search_time": "1.517556758975843",
      "ret-prompts": [
        {
          "statement": "theorem simple_graph.adj_iff_exists_edge {V : Type u} (G : simple_graph V) {v w : V} : G.adj v w ↔ v ≠ w ∧ ∃ (e : sym2 V) (H : e ∈ G.edge_set), v ∈ e ∧ w ∈ e",
          "sim_score": "0.5179886817932129",
          "doc_string": "Two vertices are adjacent iff there is an edge between them. The condition `v ≠ w` ensures they are different endpoints of the edge, which is necessary since when `v = w` the existential `∃ (e ∈ G.edge_set), v ∈ e ∧ w ∈ e` is satisfied by every edge incident to `v`."
        },
        {
          "statement": "theorem simple_graph.even_card_odd_degree_vertices {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] : even (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card",
          "sim_score": "0.5029463171958923",
          "doc_string": "The handshaking lemma.  See also `simple_graph.sum_degrees_eq_twice_card_edges`."
        },
        {
          "statement": "theorem simple_graph.exists_maximal_degree_vertex {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] : ∃ (v : V), G.max_degree = G.degree v",
          "sim_score": "0.4985456168651581",
          "doc_string": "There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as the lemma implies there exists a vertex."
        },
        {
          "statement": "theorem simple_graph.max_degree_le_of_forall_degree_le {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) : G.max_degree ≤ k",
          "sim_score": "0.48896029591560364",
          "doc_string": "In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Two vertices are adjacent iff there is an edge between them. The condition `v ≠ w` ensures they are different endpoints of the edge, which is necessary since when `v = w` the existential `∃ (e ∈ G.edge_set), v ∈ e ∧ w ∈ e` is satisfied by every edge incident to `v`.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u} (G : simple_graph V) {v w : V} :\nG.adj v w ↔ v ≠ w ∧ ∃ (e : sym2 V) (H : e ∈ G.edge_set), v ∈ e ∧ w ∈ e := \n\nNatural language version: \"The handshaking lemma.  See also `simple_graph.sum_degrees_eq_twice_card_edges`.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] :\neven (finset.filter (λ (v : V), odd (G.degree v)) finset.univ).card := \n\nNatural language version: \"There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as the lemma implies there exists a vertex.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] [nonempty V] :\n∃ (v : V), G.max_degree = G.degree v := \n\nNatural language version: \"In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum degree.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u} (G : simple_graph V) [fintype V] [decidable_rel G.adj] (k : ℕ) (h : ∀ (v : V), G.degree v ≤ k) :\nG.max_degree ≤ k := \n\nNatural language version: \"A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finite graph in which every two vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
      "codex_time": "12.804689691023668"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{V : Type _} [Finite V] (G : SimpleGraph V) : (∀ v w : V, ∃! x : V, G.Adj v x ∧ G.Adj w x) → (∃ c : V, ∀ v : V, G.Adj c v) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "partitions.equiv_oddeven_distinct {n : ℕ} : (partitions.equiv_oddeven n).Card = (partitions.distinct_part_of_n_ge_2 n).Card ",
        "parse-message": "unknown identifier 'partitions.equiv_oddeven' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} (h : α → α → prop) (h_ext : ∀ (x y z W : α), x = y → z = W → h x z → h y W) (h_refl : ∀ (x : α), h x x) (h_sym : ∀ (x y : α), h x y → h y x) (h_trans : ∀ {x y z : α}, h x y → h y z → h x z) (hrel : ∀ (A b : α) (h : h A b), h A a ∨ h b b) (h_iff : ∀ (A b",
        "parse-message": "<input>:1:52: expected ')'"
      },
      {
        "success": false,
        "statement": "(n : ℕ) :\n(partition_set.Filter Partition.Odd n).Card = (partition_set.Filter Partition.distinct_parts n).Card ",
        "parse-message": "unknown identifier 'partition_set.Filter' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} {c : ℕ → set (set α)} (h : ∀ (n : ℕ), ∀ (A : ℕ), A ∈ c n → ∃! (b : set α) (h : b ∈ c n), A ∈ b) :\nhas_unique_sum_of_parts α c ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{P : ℕ} {R : Type*} {m : Type*} [comm_ring R] [add_comm_group m] [module R m] (Q : QuadraticForm R m) :\nFinset.Card (possible_even_odd_partitions Q P) = Finset.Card (Finset.Filter distinct (possible_partitions Q P)) ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "partition_odd_distincts",
      "search_time": "1.4897750779928174",
      "ret-prompts": [
        {
          "statement": "theorem finset.sum_cancels_of_partition_cancels {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) : s.sum (λ (x : α), f x) = 0",
          "sim_score": "0.45678937435150146",
          "doc_string": "If we can partition a sum into subsets that cancel out, then the whole sum cancels."
        },
        {
          "statement": "theorem clifford_algebra.odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) : P x hx",
          "sim_score": "0.44783246517181396",
          "doc_string": " To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors."
        },
        {
          "statement": "theorem finset.sum_partition {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] : s.sum (λ (x : α), f x) = (finset.image quotient.mk s).sum (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y))",
          "sim_score": "0.42162370681762695",
          "doc_string": "A sum can be partitioned into a sum of sums, each equivalent under a setoid."
        },
        {
          "statement": "theorem setoid.eqv_classes_disjoint {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) : c.pairwise_disjoint id",
          "sim_score": "0.4164368808269501",
          "doc_string": "Distinct elements of a set of sets partitioning α are disjoint."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\" Translate the natural language version to a Lean mathlib version:\n theorem {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0) :\ns.sum (λ (x : α), f x) = 0 := \n\nNatural language version: \" To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1) :\nP x hx := \n\nNatural language version: \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\" Translate the natural language version to a Lean mathlib version:\n theorem {β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] :\ns.sum (λ (x : α), f x) = (finset.image quotient.mk s).sum (λ (xbar : quotient R), (finset.filter (λ (y : α), ⟦y⟧ = xbar) s).sum (λ (y : α), f y)) := \n\nNatural language version: \"Distinct elements of a set of sets partitioning α are disjoint.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {c : set (set α)} (H : ∀ (a : α), ∃! (b : set α) (H : b ∈ c), a ∈ b) :\nc.pairwise_disjoint id := \n\nNatural language version: \"The number of partitions with odd parts is equal to the number of partitions with distinct parts.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
      "codex_time": "12.19458099399344"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ n : ℕ, Finset.card (Nat.Partition.odds n) = Finset.card (Nat.Partition.distincts n) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u_1} {R : α → α → prop} [CompleteLattice α] [Nonempty α] [partial_order R] :\n(∀ (c : set α), IsChain R c → c.Nonempty → (∃ (ub : α), ∀ (A : α), A ∈ c → R A ub)) →\n ∃ (m : α), ∀ (A : α), R m A → R A m ",
        "parse-message": "unknown identifier 'prop' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} {R : α → α → prop} [partial_order α] (h : ∀ (c : set α), IsChain R c → (∃ (ub : α), ∀ (A : α), A ∈ c → A ≤ ub)) (Trans : ∀ (A b c : α), A ≤ b → b ≤ c → A ≤ c) :\n∃ (m : α), is_maximal m ",
        "parse-message": "unknown identifier 'prop' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} {R : α → α → prop} (h : ∀ {c : set α}, c.Nonempty → IsChain R c → (∃ (ub : α), ∀ (A : α), A ∈ c → R A ub)) :\n∃ (m : α), (∀ (A : α), R m A → R A m) ∧ ∀ (n : α), (∀ (A : α), R m A → R A m) → R n m → R n n ",
        "parse-message": "unknown identifier 'prop' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{β : Type u_1} [poset β] {P : β} (h : ∀ (c : set β), IsChain (≤) c → c.Nonempty → (∃ (ub : β), ∀ (A : β), A ∈ c → A ≤ ub)) :\n∃ (m : β), ∀ (A : β), P ≤ A → A ≤ P ",
        "parse-message": "<input>:1:62: expected ')' or '↑'"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} {R : α → α → prop} {P : set α} (hp : ∀ (c : set α), IsChain R c → chain_upper_bound c R P) (hc : chain_upper_bound c R P) :\n∃ (m : α), ∀ (A : α), R m A → R A m ",
        "parse-message": "unknown identifier 'prop' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "zorn",
      "search_time": "1.4935360020026565",
      "ret-prompts": [
        {
          "statement": "theorem exists_maximal_of_chains_bounded {α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m",
          "sim_score": "0.8077962398529053",
          "doc_string": " **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element."
        },
        {
          "statement": "theorem exists_maximal_of_nonempty_chains_bounded {α : Type u_1} {r : α → α → Prop} [nonempty α] (h : ∀ (c : set α), is_chain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) : ∃ (m : α), ∀ (a : α), r m a → r a m",
          "sim_score": "0.782833456993103",
          "doc_string": " A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then there is a maximal element."
        },
        {
          "statement": "theorem is_chain.exists_max_chain {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) : ∃ (M : set α), is_max_chain r M ∧ c ⊆ M",
          "sim_score": "0.6981233954429626",
          "doc_string": "Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle."
        },
        {
          "statement": "theorem with_top.is_lub_Sup' {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) : is_lub s (has_Sup.Sup s)",
          "sim_score": "0.6111599206924438",
          "doc_string": " The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" **Zorn's lemma**  If every chain has an upper bound, then there exists a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {r : α → α → Prop} (h : ∀ (c : set α), is_chain r c → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) :\n∃ (m : α), ∀ (a : α), r m a → r a m := \n\nNatural language version: \" A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then there is a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {r : α → α → Prop} [nonempty α] (h : ∀ (c : set α), is_chain r c → c.nonempty → (∃ (ub : α), ∀ (a : α), a ∈ c → r a ub)) (trans : ∀ {a b c : α}, r a b → r b c → r a c) :\n∃ (m : α), ∀ (a : α), r m a → r a m := \n\nNatural language version: \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {r : α → α → Prop} {c : set α} (hc : is_chain r c) :\n∃ (M : set α), is_max_chain r M ∧ c ⊆ M := \n\nNatural language version: \" The Sup of a non-empty set is its least upper bound for a conditionally complete lattice with a top.\" Translate the natural language version to a Lean mathlib version:\n theorem {β : Type u_1} [conditionally_complete_lattice β] {s : set (with_top β)} (hs : s.nonempty) :\nis_lub s (has_Sup.Sup s) := \n\nNatural language version: \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
      "codex_time": "9.46299122797791"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{α : Type _} [PartialOrder α] [Nonempty α] : (∀ c : Set α, IsChain LE.le c → (∃ b : α, ∀ a ∈ c, a ≤ b)) → (∃ m : α, ∀ a : α, m ≤ a → a = m) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u} [Group α] (h : IsCyclic (aut α)) :\nCommGroup α ",
        "parse-message": "unknown identifier 'aut' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [Group α] (h : IsCyclic (group_aut α)) :\nCommGroup α ",
        "parse-message": "unknown identifier 'group_aut' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [Group α] (h : IsCyclic (aut G)) :\nCommGroup α ",
        "parse-message": "unknown identifier 'aut' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [Group α] {aut : Group (group_aut α)} (h : IsCyclic aut) :\nis_abelian α ",
        "parse-message": "unknown identifier 'group_aut' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(G : Type u) [Group G] (h : Type u) [Group h] (F : G →+* h) (hf : is_group_isomorphism F)\n  (hₛ : IsCyclic (group_automorphisms_of h)) :\nCommGroup G ",
        "parse-message": "failed to synthesize instance\n  NonAssocSemiringₓ G (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "aut_group_cyclic_implies_abelian",
      "search_time": "1.7266927709861193",
      "ret-prompts": [
        {
          "statement": "theorem is_cyclic_of_prime_card {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) : is_cyclic α",
          "sim_score": "0.6319984793663025",
          "doc_string": "A finite group of prime order is cyclic."
        },
        {
          "statement": "theorem int.subgroup_cyclic (H : add_subgroup ℤ) : ∃ (a : ℤ), H = add_subgroup.closure {a}",
          "sim_score": "0.6267713308334351",
          "doc_string": "Every subgroup of `ℤ` is cyclic."
        },
        {
          "statement": "theorem is_cyclic_of_subgroup_is_domain {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : function.injective ⇑f) : is_cyclic G",
          "sim_score": "0.5008938312530518",
          "doc_string": "A finite subgroup of the unit group of an integral domain is cyclic."
        },
        {
          "statement": "theorem is_group_hom.mul {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f g : α → β} (hf : is_group_hom f) (hg : is_group_hom g) : is_group_hom (λ (a : α), f a * g a)",
          "sim_score": "0.4840320944786072",
          "doc_string": "The product of group homomorphisms is a group homomorphism if the target is commutative."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A finite group of prime order is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [group α] [fintype α] {p : ℕ} [hp : fact (nat.prime p)] (h : fintype.card α = p) :\nis_cyclic α := \n\nNatural language version: \"Every subgroup of `ℤ` is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem (H : add_subgroup ℤ) :\n∃ (a : ℤ), H = add_subgroup.closure {a} := \n\nNatural language version: \"A finite subgroup of the unit group of an integral domain is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {G : Type u_2} [comm_ring R] [is_domain R] [group G] [fintype G] (f : G →* R) (hf : function.injective ⇑f) :\nis_cyclic G := \n\nNatural language version: \"The product of group homomorphisms is a group homomorphism if the target is commutative.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} [group α] [comm_group β] {f g : α → β} (hf : is_group_hom f) (hg : is_group_hom g) :\nis_group_hom (λ (a : α), f a * g a) := \n\nNatural language version: \"A group whose automorphism group is cyclic is Abelian.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A group whose automorphism group is cyclic is Abelian.",
      "codex_time": "7.3680931930139195"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{G : Type _} [Groupₓ G] : CategoryTheory.Aut G → CommGroup G "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : sort u} (s t : set α) {β : sort v} (F : α → β) :\nF '' (s ∪ t) = F '' s ∪ F '' t ",
        "parse-message": "<input>:2:2: expected end of input"
      },
      {
        "success": false,
        "statement": "(. 𝓝(s ∪ t)) = (. 𝓝(s)) ∪ (. 𝓝(t)) ",
        "parse-message": "<input>:1:1: expected identifier"
      },
      {
        "success": false,
        "statement": "{α β : Type u} {s : set (α × β)} {A : set α} {b : set β} (h : s = {P : (α × β) | P.1 ∈ A ∧ P.2 ∈ b}) :\nFinset.Univ.image P.1 ∪ Finset.Univ.image P.2 = Finset.Univ.image (⇑h).1 ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} {β : Type v} {δ : Type W} [_inst_1 : Group δ] (F : α → δ → β) (s t : set α) :\n∀ g, F '' (s ∪ t) g = (F '' s) g ∪ (F '' t) g ",
        "parse-message": "<input>:2:7: expected end of input"
      },
      {
        "success": false,
        "statement": "(α : Type u) (β : Type v) (s₁ t₁ : set α) (s₂ t₂ : set β) (F : α → β) :\nF '' (s₁ ∪ t₁) = F '' s₁ ∪ F '' t₁ ↔ ∀ (A : α) (a_in_s : A ∈ s₁) (a_in_t : A ∈ t₁), F A ∈ s₂ ∨ F A ∈ t₂ ",
        "parse-message": "<input>:2:2: expected end of input"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "image_union",
      "search_time": "1.472945643006824",
      "ret-prompts": [
        {
          "statement": "theorem cardinal.mk_union_le {α : Type u} (S T : set α) : cardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T",
          "sim_score": "0.6315420866012573",
          "doc_string": " The cardinality of a union is at most the sum of the cardinalities of the two sets."
        },
        {
          "statement": "theorem set.subset_Union_of_subset {α : Type u_1} {ι : Sort u_4} {s : set α} {t : ι → set α} (i : ι) (h : s ⊆ t i) : s ⊆ ⋃ (i : ι), t i",
          "sim_score": "0.5471856594085693",
          "doc_string": " This rather trivial consequence of `subset_Union`is convenient with `apply`, and has `i` explicit for this purpose."
        },
        {
          "statement": "theorem metric.bounded_union {α : Type u} [pseudo_metric_space α] {s t : set α} : metric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t",
          "sim_score": "0.5332727432250977",
          "doc_string": "The union of two sets is bounded iff each of the sets is bounded."
        },
        {
          "statement": "theorem affine_subspace.span_union (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) : affine_span k (s ∪ t) = affine_span k s ⊔ affine_span k t",
          "sim_score": "0.5295044779777527",
          "doc_string": "The span of a union of sets is the sup of their spans."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" The cardinality of a union is at most the sum of the cardinalities of the two sets.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} (S T : set α) :\ncardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T := \n\nNatural language version: \" This rather trivial consequence of `subset_Union`is convenient with `apply`, and has `i` explicit for this purpose.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {ι : Sort u_4} {s : set α} {t : ι → set α} (i : ι) (h : s ⊆ t i) :\ns ⊆ ⋃ (i : ι), t i := \n\nNatural language version: \"The union of two sets is bounded iff each of the sets is bounded.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_metric_space α] {s t : set α} :\nmetric.bounded (s ∪ t) ↔ metric.bounded s ∧ metric.bounded t := \n\nNatural language version: \"The span of a union of sets is the sup of their spans.\" Translate the natural language version to a Lean mathlib version:\n theorem (k : Type u_1) (V : Type u_2) {P : Type u_3} [ring k] [add_comm_group V] [module k V] [S : add_torsor V P] (s t : set P) :\naffine_span k (s ∪ t) = affine_span k s ⊔ affine_span k t := \n\nNatural language version: \"The image of a union of sets is the union of the images.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The image of a union of sets is the union of the images.",
      "codex_time": "8.4119693050161"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "(f : α → β) (S : Set (Set α)) : (f <$> (⋃₀ S)) = (⋃₀ ((Functor.map f) <$> S)) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{x : Type u_1} [TopologicalSpace x] :\n∀ (s t : set x), is_closed s → is_closed t → Disjoint s t →\n∃ (F : c(x, ℝ)), set.EQOn ⇑F 0 s ∧ set.EQOn ⇑F 1 t ",
        "parse-message": "<input>:3:8: expected ')'"
      },
      {
        "success": false,
        "statement": "{x : Type u_1} [TopologicalSpace x] :\nNormalSpace x ↔ ∀ {s t : set x} (hs : is_closed s) (ht : is_closed t) (hd : Disjoint s t), separated_by_continuous_function (Function.Const x 0) s t ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{x : Type u_1} [TopologicalSpace x] : (Normal x) ⇔ ∀ ⦃ s t : set x ⦄, is_closed s → is_closed t → Disjoint s t → ∃ (F : x → ℝ), is_continuous F ∧ (∀ (x : x), F x ∈ set.icc (0 : ℝ) (1 : ℝ))\n  ∧ set.EQOn F 0 s ∧ set.EQOn F 1 t ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{x : Type u_1} [TopologicalSpace x] : (∀ (s t : set x), Disjoint s t → is_closed s → is_closed t → ∃ (F : c(x, ℝ)), set.EQOn ⇑F 0 s ∧ set.EQOn ⇑F 1 t ∧ ∀ (x : x), ⇑F x ∈ set.icc 0 1) → NormalSpace x ",
        "parse-message": "<input>:1:107: expected ')'"
      },
      {
        "success": false,
        "statement": "{x : Type u_1} [TopologicalSpace x] :\nNormalSpace x ↔ ∀ s t : set x, is_closed s → is_closed t → Disjoint s t → ∃ (F : c(x, ℝ)), set.EQOn ⇑F 0 s ∧ set.EQOn ⇑F 1 t ",
        "parse-message": "<input>:2:82: expected ')'"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "urysohn",
      "search_time": "1.5973553500080016",
      "ret-prompts": [
        {
          "statement": "theorem exists_bounded_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1",
          "sim_score": "0.629673182964325",
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`."
        },
        {
          "statement": "theorem exists_continuous_zero_one_of_closed {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) : ∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1",
          "sim_score": "0.629673182964325",
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`."
        },
        {
          "statement": "theorem exists_bounded_mem_Icc_of_closed_of_le {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) : ∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b",
          "sim_score": "0.5748592615127563",
          "doc_string": " Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a ≤ f x ≤ b` for all `x`."
        },
        {
          "statement": "theorem subgroup.is_normal_topological_closure {G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] : N.topological_closure.normal",
          "sim_score": "0.5395680069923401",
          "doc_string": "The topological closure of a normal subgroup is normal."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :\n∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 := \n\nNatural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, then there exists a continuous function `f : X → ℝ` such that  * `f` equals zero on `s`; * `f` equals one on `t`; * `0 ≤ f x ≤ 1` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) :\n∃ (f : C(X, ℝ)), set.eq_on ⇑f 0 s ∧ set.eq_on ⇑f 1 t ∧ ∀ (x : X), ⇑f x ∈ set.Icc 0 1 := \n\nNatural language version: \" Urysohns lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`, and `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that  * `f` equals `a` on `s`; * `f` equals `b` on `t`; * `a ≤ f x ≤ b` for all `x`.\" Translate the natural language version to a Lean mathlib version:\n theorem {X : Type u_1} [topological_space X] [normal_space X] {s t : set X} (hs : is_closed s) (ht : is_closed t) (hd : disjoint s t) {a b : ℝ} (hle : a ≤ b) :\n∃ (f : bounded_continuous_function X ℝ), set.eq_on ⇑f (function.const X a) s ∧ set.eq_on ⇑f (function.const X b) t ∧ ∀ (x : X), ⇑f x ∈ set.Icc a b := \n\nNatural language version: \"The topological closure of a normal subgroup is normal.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [topological_space G] [group G] [topological_group G] (N : subgroup G) [N.normal] :\nN.topological_closure.normal := \n\nNatural language version: \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
      "codex_time": "7.739471149980091"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{X : Type _} [TopologicalSpace X] [TopologicalSpace ℝ] : NormalSpace X ↔ ( ∀ {S T : Set X}, IsClosed S → IsClosed T → Disjoint S T → (∃ f : X → ℝ, Continuous f → (∀ x ∈ S, f x = 0) ∧ (∀ x ∈ T, f x = 1)) ) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{F : ℝ →+* ℝ} (hf : Function.Bijective F) :\nis_field_hom ⟨F, hf.Injective⟩ ",
        "parse-message": "unknown identifier 'is_field_hom' (during elaboration)"
      },
      {
        "success": false,
        "statement": " :\nFintype { F : ℝ → ℝ // F.aut } ",
        "parse-message": "invalid field notation, type is not of the form (C ...) where C is a constant\n  F\nhas type\n  ℝ → ℝ (during elaboration)"
      },
      {
        "success": false,
        "statement": " {F : ℝ →+* ℝ} (hf : Function.Bijective F) :\nF = LinearMap.ID ",
        "parse-message": "invalid field notation, type is not of the form (C ...) where C is a constant\n  LinearMap\nhas type\n  (?m.245 →+* ?m.246) →\n    (M : Type ?u.242) →\n      (M₂ : Type ?u.241) →\n        [_inst_3 : AddCommMonoidₓ M] →\n          [_inst_4 : AddCommMonoidₓ M₂] →\n            [_inst_5 : Module ?m.245 M] → [_inst_6 : Module ?m.246 M₂] → Type (max ?u.242 ?u.241) (during elaboration)"
      },
      {
        "success": false,
        "statement": " :\nSubsingleton {F : ℝ →+* ℝ // F.Bijective} ",
        "parse-message": "invalid field 'Bijective', the environment does not contain 'RingHom.Bijective'\n  F\nhas type\n  ℝ →+* ℝ (during elaboration)"
      },
      {
        "success": false,
        "statement": ":\nFinset.Univ.Filter (λ (F : Π {α : Type*}, α → α), Function.Injective F ∧ (∀ A ⦃b : ℝ⦄, (F A = F b) ↔ A = b)) = {⟨ID, id_inj _, λ _ _, iff.rfl⟩} ",
        "parse-message": "<input>:2:29: expected '(' or identifier"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "real_field_aut_trivial",
      "search_time": "1.4932327840069775",
      "ret-prompts": [
        {
          "statement": "theorem order_ring_iso.subsingleton_right {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α ≃+*o β)",
          "sim_score": "0.5189149975776672",
          "doc_string": " There is at most one ordered ring isomorphism between a linear ordered field and an archimedean linear ordered field."
        },
        {
          "statement": "theorem order_ring_iso.subsingleton_left {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [archimedean α] [linear_ordered_field β] : subsingleton (α ≃+*o β)",
          "sim_score": "0.5125109553337097",
          "doc_string": " There is at most one ordered ring isomorphism between an archimedean linear ordered field and a linear ordered field."
        },
        {
          "statement": "theorem order_ring_hom.subsingleton {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] : subsingleton (α →+*o β)",
          "sim_score": "0.4997551739215851",
          "doc_string": " There is at most one ordered ring homomorphism from a linear ordered field to an archimedean linear ordered field."
        },
        {
          "statement": "theorem cardinal.mk_real  : cardinal.mk ℝ = cardinal.continuum",
          "sim_score": "0.4784242510795593",
          "doc_string": "The cardinality of the reals, as a type."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" There is at most one ordered ring isomorphism between a linear ordered field and an archimedean linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] :\nsubsingleton (α ≃+*o β) := \n\nNatural language version: \" There is at most one ordered ring isomorphism between an archimedean linear ordered field and a linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [archimedean α] [linear_ordered_field β] :\nsubsingleton (α ≃+*o β) := \n\nNatural language version: \" There is at most one ordered ring homomorphism from a linear ordered field to an archimedean linear ordered field.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_2} {β : Type u_3} [linear_ordered_field α] [linear_ordered_field β] [archimedean β] :\nsubsingleton (α →+*o β) := \n\nNatural language version: \"The cardinality of the reals, as a type.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\ncardinal.mk ℝ = cardinal.continuum := \n\nNatural language version: \"The only field automorphism of the reals is the identity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The only field automorphism of the reals is the identity.",
      "codex_time": "2.867950686981203"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ (f : ℝ ≃+* ℝ), (∀ x : ℝ, f x = x) "
  },
  {
    "parsed": [
      "{F : ℕ → ℕ} (h : ∃ x : ℕ, Function.IsPeriodicPt F 3 x) : ∀ m : ℕ, ∃ x : ℕ, Function.IsPeriodicPt F m x "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{F : set.icc 0 1 → set.icc 0 1} (h : ∃ (x : set.icc 0 1), Function.IsPeriodicPt F 3 x) :\n∀ (n : ℕ), ∃ (xn : set.icc 0 1), Function.IsPeriodicPt F n xn ",
        "parse-message": "invalid field notation, type is not of the form (C ...) where C is a constant\n  set\nhas type\n  ?m.5 → ?m.6 PUnit (during elaboration)"
      },
      {
        "success": false,
        "statement": "{F : ℝ → ℝ} (h : ¬ Function.is_injective F) (hf : Function.IsPeriodicPt F 3 0) (hm : 0 < 3) :\n∃ (n : ℕ), ∃ (x : ℝ) (hx : 0 ≤ x ∧ x < 1 ∧ F x = F (x + (Real.of_nat n))), 0 < n ",
        "parse-message": "unknown identifier 'Function.is_injective' (during elaboration)"
      },
      {
        "success": true,
        "statement": "{F : ℕ → ℕ} (h : ∃ x : ℕ, Function.IsPeriodicPt F 3 x) : ∀ m : ℕ, ∃ x : ℕ, Function.IsPeriodicPt F m x ",
        "code": "forall {F : Nat -> Nat}, (Exists.{?_uniq.7} Nat (fun (x : Nat) => Function.IsPeriodicPt.{?_uniq.11} Nat F (OfNat.ofNat.{0} Nat 3 (instOfNatNat 3)) x)) -> (forall (m : Nat), Exists.{?_uniq.33} Nat (fun (x : Nat) => Function.IsPeriodicPt.{?_uniq.37} Nat F m x))"
      },
      {
        "success": false,
        "statement": "{F : icc 0 1 → icc 0 1} (hf : Function.FixedPoint F (1 / 3)) : ∀ (x : ℕ), Function.FixedPoint F ((1 / 3) + (x : ℕ → ℝ) / 3) ",
        "parse-message": "unknown identifier 'icc' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{F : icc 0 1 → icc 0 1} {x : icc 0 1} (h : ∃ (n : ℕ), Function.IsPeriodicPt F 3 x) :\n∀ (n : ℕ) (hn : 0 < n), ∃ (y : icc 0 1), Function.IsPeriodicPt F n y ",
        "parse-message": "unknown identifier 'icc' (during elaboration)"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "period_three_implies_chaos",
      "search_time": "1.474250674014911",
      "ret-prompts": [
        {
          "statement": "theorem function.periodic.exists_mem_Ico₀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x : α) : ∃ (y : α) (H : y ∈ set.Ico 0 c), f x = f y",
          "sim_score": "0.6410606503486633",
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico 0 c` such that `f x = f y`."
        },
        {
          "statement": "theorem function.periodic.exists_mem_Ico {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ico a (a + c)), f x = f y",
          "sim_score": "0.6367848515510559",
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico a (a + c)` such that `f x = f y`."
        },
        {
          "statement": "theorem function.periodic.exists_mem_Ioc {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) : ∃ (y : α) (H : y ∈ set.Ioc a (a + c)), f x = f y",
          "sim_score": "0.6170958876609802",
          "doc_string": "If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ioc a (a + c)` such that `f x = f y`."
        },
        {
          "statement": "theorem function.is_periodic_pt.eq_of_apply_eq {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) : x = y",
          "sim_score": "0.5864872932434082",
          "doc_string": " If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico 0 c` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x : α) :\n∃ (y : α) (H : y ∈ set.Ico 0 c), f x = f y := \n\nNatural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ico a (a + c)` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) :\n∃ (y : α) (H : y ∈ set.Ico a (a + c)), f x = f y := \n\nNatural language version: \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some  `y ∈ Ioc a (a + c)` such that `f x = f y`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [linear_ordered_add_comm_group α] [archimedean α] (h : function.periodic f c) (hc : 0 < c) (x a : α) :\n∃ (y : α) (H : y ∈ set.Ioc a (a + c)), f x = f y := \n\nNatural language version: \" If `f` sends two periodic points `x` and `y` of positive periods to the same point, then `x = y`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ} (hx : function.is_periodic_pt f m x) (hy : function.is_periodic_pt f n y) (hm : 0 < m) (hn : 0 < n) (h : f x = f y) :\nx = y := \n\nNatural language version: \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
      "codex_time": "10.607637445005821"
    },
    "grouped": [
      [
        "{F : ℕ → ℕ} (h : ∃ x : ℕ, Function.IsPeriodicPt F 3 x) : ∀ m : ℕ, ∃ x : ℕ, Function.IsPeriodicPt F m x "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ f : Set.Icc 0 1 → Set.Icc 0 1, (∃ x : Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → (∀ n : ℕ, n > 0 → ∃ y : Set.Icc 0 1, Function.IsPeriodicPt f n y) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{c : Type u₁} [CategoryTheory.Category c] {T T' : c} (hT : CategoryTheory.Limits.IsTerminal T) (hT' : CategoryTheory.Limits.IsTerminal T') :\nT ≅ T' ",
        "parse-message": "unknown universe level 'u₁' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{c : Type u₁} [CategoryTheory.Category c] [CategoryTheory.Limits.HasTerminal c] [CategoryTheory.Limits.HasTerminal c] :\nCategoryTheory.Limits.uniqueness_of_terminal_up_to_iso.{u₁} c ",
        "parse-message": "parsed to  {  c :  Type  u₁ } ->  [  CategoryTheory.Category  c ] ->  [  CategoryTheory.Limits.HasTerminal  c ] ->  [  CategoryTheory.Limits.HasTerminal  c ] ->   CategoryTheory.Limits.uniqueness_of_terminal_up_to_iso .{  u₁ }  c; error while parsing as theorem: <input>:1:208: expected end of input"
      },
      {
        "success": false,
        "statement": "{c : Type u} [CategoryTheory.Category c] [CategoryTheory.Limits.HasTerminal c] [CategoryTheory.Limits.HasZeroObject c] :\nSubsingleton CategoryTheory.Limits.terminal_obj ",
        "parse-message": "unknown identifier 'CategoryTheory.Limits.terminal_obj' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{c : Type u₁} [SmallCategory c] [CategoryTheory.Limits.HasTerminal c] {T₁ T₂ : c} (t₁ : CategoryTheory.Limits.IsTerminal T₁)\n(t₂ : CategoryTheory.Limits.IsTerminal T₂) :\nT₁ ≅ T₂ ",
        "parse-message": "unknown universe level 'u₁' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{c : Type u₁} [CategoryTheory.Category c] [CategoryTheory.Limits.HasTerminal c] :\nNonempty (∃ (u : Type u₂), u ≃ CategoryTheory.Limits.IsTerminal c) ",
        "parse-message": "unknown universe level 'u₁' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "terminal_unique_iso",
      "search_time": "1.520757896010764",
      "ret-prompts": [
        {
          "statement": "theorem category_theory.limits.has_terminal_of_unique {C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (Y ⟶ X)] : category_theory.limits.has_terminal C",
          "sim_score": "0.8502864837646484",
          "doc_string": " We can more explicitly show that a category has a terminal object by specifying the object, and showing there is a unique morphism to it from any other object."
        },
        {
          "statement": "theorem category_theory.limits.is_terminal.hom_ext {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ⟶ X) : f = g",
          "sim_score": "0.8256147503852844",
          "doc_string": "Any two morphisms to a terminal object are equal."
        },
        {
          "statement": "theorem category_theory.is_subterminal_of_mono_is_terminal_from {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] : category_theory.is_subterminal A",
          "sim_score": "0.6706336140632629",
          "doc_string": "If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`."
        },
        {
          "statement": "theorem category_theory.limits.has_zero_object_of_has_terminal_object {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] : category_theory.limits.has_zero_object C",
          "sim_score": "0.6649926900863647",
          "doc_string": "If there are zero morphisms, any terminal object is a zero object."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" We can more explicitly show that a category has a terminal object by specifying the object, and showing there is a unique morphism to it from any other object.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u₁} [category_theory.category C] (X : C) [h : Π (Y : C), unique (Y ⟶ X)] :\ncategory_theory.limits.has_terminal C := \n\nNatural language version: \"Any two morphisms to a terminal object are equal.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u₁} [category_theory.category C] {X Y : C} (t : category_theory.limits.is_terminal X) (f g : Y ⟶ X) :\nf = g := \n\nNatural language version: \"If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal. The converse of `is_subterminal.mono_is_terminal_from`.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u₁} [category_theory.category C] {A T : C} (hT : category_theory.limits.is_terminal T) [category_theory.mono (hT.from A)] :\ncategory_theory.is_subterminal A := \n\nNatural language version: \"If there are zero morphisms, any terminal object is a zero object.\" Translate the natural language version to a Lean mathlib version:\n theorem {C : Type u} [category_theory.category C] [category_theory.limits.has_zero_morphisms C] [category_theory.limits.has_terminal C] :\ncategory_theory.limits.has_zero_object C := \n\nNatural language version: \"A terminal object in a category is unique up to unique isomorphism.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A terminal object in a category is unique up to unique isomorphism.",
      "codex_time": "7.707911478995811"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{C : Type _} [CategoryTheory.Category C] : ∀ T₁ T₂ : C, CategoryTheory.Limits.IsTerminal T₁ → CategoryTheory.Limits.IsTerminal T₂ → (∃ ι : CategoryTheory.Iso T₁ T₂, ∀ ι' : CategoryTheory.Iso T₁ T₂, ι = ι') "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] [Fintype G] {h : Type u_1} [Group h] [Fintype h]\n  (F : group_hom G h) (h : Fintype.is_fin_gen G) (hT : ∃ x : G, ∃ n : ℕ, x^n = 1) :\nFintype G ",
        "parse-message": "unknown identifier 'group_hom' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] [is_fp G] : ∃ (g : G) [hg : Monoid.torsion_elem G g],\nFintype G ",
        "parse-message": "<input>:1:47: expected ','"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] :\nGroup.is_f.P G → ∃ (g : G) (h : Monoid.is_torsion g), Fintype G ",
        "parse-message": "unknown constant 'Group.is_f.P' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] [Fintype G] (h : subgroup G) [Fin.is_fp h] :\n∃ g, h.IsTorsion g ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] [h : Fintype G] (h1 : finitely_presented G) (h : ∃ A : G, A ≠ 1) :\nFintype G ",
        "parse-message": "unknown identifier 'finitely_presented' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "torsion_in_fg_group_implies_finite",
      "search_time": "1.4627392099937424",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_of_fintype {G : Type u_1} [group G] [fintype G] : monoid.is_torsion G",
          "sim_score": "0.7566978335380554",
          "doc_string": "Finite groups are torsion groups."
        },
        {
          "statement": "theorem is_torsion.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) : monoid.is_torsion ↥H",
          "sim_score": "0.6571311950683594",
          "doc_string": "Subgroups of torsion groups are torsion groups."
        },
        {
          "statement": "theorem is_add_torsion_of_fintype {G : Type u_1} [add_group G] [fintype G] : add_monoid.is_torsion G",
          "sim_score": "0.6486772298812866",
          "doc_string": "Finite additive groups are additive torsion groups."
        },
        {
          "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G",
          "sim_score": "0.6356827020645142",
          "doc_string": "A nontrivial torsion group is not torsion-free."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Finite groups are torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [fintype G] :\nmonoid.is_torsion G := \n\nNatural language version: \"Subgroups of torsion groups are torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion G) (H : subgroup G) :\nmonoid.is_torsion ↥H := \n\nNatural language version: \"Finite additive groups are additive torsion groups.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [add_group G] [fintype G] :\nadd_monoid.is_torsion G := \n\nNatural language version: \"A nontrivial torsion group is not torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion G → ¬monoid.is_torsion_free G := \n\nNatural language version: \"A finitely-presented group containing a torsion element is finite.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finitely-presented group containing a torsion element is finite.",
      "codex_time": "5.733185497985687"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{G : Type _} [Groupₓ G] : Groupₓ.Fg G → Finite G "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u} {s t : set α} :\nsᶜ ∩ tᶜ = (s ∪ t)ᶜ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} (s t : set α) :\nsᶜ ∪ tᶜ = (s ∩ t)ᶜ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} (s T : set α) :\n((s ∪ T)ᶜ : set α) = sᶜ ∩ Tᶜ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} (s T : set α) :\n(s ∪ T)ᶜ = sᶜ ∩ Tᶜ ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} (u V : set α) :\n(- (u ∪ V)) = (- u) ∩ (- V) ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "compl_union",
      "search_time": "1.4480129570001736",
      "ret-prompts": [
        {
          "statement": "theorem frontier_compl {α : Type u} [topological_space α] (s : set α) : frontier sᶜ = frontier s",
          "sim_score": "0.6778950691223145",
          "doc_string": "The complement of a set has the same frontier as the original set."
        },
        {
          "statement": "theorem bdd_below_union {γ : Type w} [semilattice_inf γ] {s t : set γ} : bdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t",
          "sim_score": "0.6120935678482056",
          "doc_string": "The union of two sets is bounded above if and only if each of the sets is."
        },
        {
          "statement": "theorem bdd_above_union {γ : Type w} [semilattice_sup γ] {s t : set γ} : bdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t",
          "sim_score": "0.6120935678482056",
          "doc_string": "The union of two sets is bounded above if and only if each of the sets is."
        },
        {
          "statement": "theorem cardinal.mk_union_le {α : Type u} (S T : set α) : cardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T",
          "sim_score": "0.6097555160522461",
          "doc_string": " The cardinality of a union is at most the sum of the cardinalities of the two sets."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The complement of a set has the same frontier as the original set.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] (s : set α) :\nfrontier sᶜ = frontier s := \n\nNatural language version: \"The union of two sets is bounded above if and only if each of the sets is.\" Translate the natural language version to a Lean mathlib version:\n theorem {γ : Type w} [semilattice_inf γ] {s t : set γ} :\nbdd_below (s ∪ t) ↔ bdd_below s ∧ bdd_below t := \n\nNatural language version: \"The union of two sets is bounded above if and only if each of the sets is.\" Translate the natural language version to a Lean mathlib version:\n theorem {γ : Type w} [semilattice_sup γ] {s t : set γ} :\nbdd_above (s ∪ t) ↔ bdd_above s ∧ bdd_above t := \n\nNatural language version: \" The cardinality of a union is at most the sum of the cardinalities of the two sets.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} (S T : set α) :\ncardinal.mk ↥(S ∪ T) ≤ cardinal.mk ↥S + cardinal.mk ↥T := \n\nNatural language version: \"The complement of the union of two sets is the intersection of their complements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The complement of the union of two sets is the intersection of their complements.",
      "codex_time": "4.9173353480000515"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{α : Type _} (S T : Set α) : (S ∪ T).compl = S.compl ∩ T.compl "
  },
  {
    "parsed": [
      "{x y z : ℤ} (hxz : 0 < x + y) (hyz : 0 < y + z) (hxz : 0 < x + z) :\n(x ^ 3 + y ^ 3 = z ^ 3) → False ",
      "{x y z : ℕ} (hx : x > 0) (hy : y > 0) (hz : z > 0) :\nx^3 + y^3 ≠ z^3 ",
      "{x y z : ℤ} (hx : x > 0) (hy : y > 0) (hz : z > 0) :\nx ^ 3 + y ^ 3 ≠ z ^ 3 "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "{x y z : ℤ} (hxz : 0 < x + y) (hyz : 0 < y + z) (hxz : 0 < x + z) :\n(x ^ 3 + y ^ 3 = z ^ 3) → False ",
        "code": "forall {x : Int} {y : Int} {z : Int}, (LT.lt.{?_uniq.9} Int Int.hasLt (OfNat.ofNat.{?_uniq.12} Int 0 (Int.instOfNatInt 0)) (HAdd.hAdd.{?_uniq.28 ?_uniq.27 ?_uniq.26} Int Int Int (instHAdd.{0} Int Int.hasAdd) x y)) -> (LT.lt.{?_uniq.77} Int Int.hasLt (OfNat.ofNat.{?_uniq.80} Int 0 (Int.instOfNatInt 0)) (HAdd.hAdd.{?_uniq.96 ?_uniq.95 ?_uniq.94} Int Int Int (instHAdd.{0} Int Int.hasAdd) y z)) -> (LT.lt.{?_uniq.129} Int Int.hasLt (OfNat.ofNat.{?_uniq.132} Int 0 (Int.instOfNatInt 0)) (HAdd.hAdd.{?_uniq.148 ?_uniq.147 ?_uniq.146} Int Int Int (instHAdd.{0} Int Int.hasAdd) x z)) -> (Eq.{?_uniq.181} Int (HAdd.hAdd.{?_uniq.184 ?_uniq.183 ?_uniq.182} Int Int Int (instHAdd.{0} Int Int.hasAdd) (HPow.hPow.{?_uniq.187 ?_uniq.186 ?_uniq.185} Int Nat Int (Monoid.HPow.{?_uniq.352} Int (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int (Ring.toSemiring.{0} Int (CommRing.toRing.{0} Int Int.instCommRingInt))))) x (OfNat.ofNat.{?_uniq.186} Nat 3 (instOfNatNat 3))) (HPow.hPow.{?_uniq.211 ?_uniq.210 ?_uniq.209} Int Nat Int (Monoid.HPow.{?_uniq.437} Int (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int (Ring.toSemiring.{0} Int (CommRing.toRing.{0} Int Int.instCommRingInt))))) y (OfNat.ofNat.{?_uniq.210} Nat 3 (instOfNatNat 3)))) (HPow.hPow.{?_uniq.253 ?_uniq.252 ?_uniq.251} Int Nat Int (Monoid.HPow.{?_uniq.482} Int (MonoidWithZero.toMonoid.{0} Int (Semiring.toMonoidWithZero.{0} Int (Ring.toSemiring.{0} Int (CommRing.toRing.{0} Int Int.instCommRingInt))))) z (OfNat.ofNat.{?_uniq.252} Nat 3 (instOfNatNat 3)))) -> False"
      },
      {
        "success": true,
        "statement": "{x y z : ℕ} (hx : x > 0) (hy : y > 0) (hz : z > 0) :\nx^3 + y^3 ≠ z^3 ",
        "code": "forall {x : Nat} {y : Nat} {z : Nat} (hx : GT.gt.{?_uniq.9} Nat Nat.hasLt x (OfNat.ofNat.{?_uniq.12} Nat 0 (instOfNatNat 0))) (hy : GT.gt.{?_uniq.43} Nat Nat.hasLt y (OfNat.ofNat.{?_uniq.46} Nat 0 (instOfNatNat 0))) (hz : GT.gt.{?_uniq.65} Nat Nat.hasLt z (OfNat.ofNat.{?_uniq.68} Nat 0 (instOfNatNat 0))), Ne.{?_uniq.86} (?_uniq.240 x y z hx hy hz) (HAdd.hAdd.{?_uniq.90 ?_uniq.89 ?_uniq.88} (?_uniq.241 x y z hx hy hz) (?_uniq.242 x y z hx hy hz) (?_uniq.240 x y z hx hy hz) (?_uniq.243 x y z hx hy hz) (HPow.hPow.{?_uniq.93 ?_uniq.92 ?_uniq.91} Nat (?_uniq.244 x y z hx hy hz) (?_uniq.241 x y z hx hy hz) (?_uniq.245 x y z hx hy hz) x (OfNat.ofNat.{?_uniq.92} (?_uniq.244 x y z hx hy hz) 3 (?_uniq.246 x y z hx hy hz))) (HPow.hPow.{?_uniq.119 ?_uniq.118 ?_uniq.117} Nat (?_uniq.247 x y z hx hy hz) (?_uniq.242 x y z hx hy hz) (?_uniq.248 x y z hx hy hz) y (OfNat.ofNat.{?_uniq.118} (?_uniq.247 x y z hx hy hz) 3 (?_uniq.249 x y z hx hy hz)))) (HPow.hPow.{?_uniq.177 ?_uniq.176 ?_uniq.175} Nat (?_uniq.250 x y z hx hy hz) (?_uniq.240 x y z hx hy hz) (?_uniq.251 x y z hx hy hz) z (OfNat.ofNat.{?_uniq.176} (?_uniq.250 x y z hx hy hz) 3 (?_uniq.252 x y z hx hy hz)))"
      },
      {
        "success": false,
        "statement": "(hx : x > 0) (hy : y > 0) {z : ℕ} :\nx ^ 3 + y ^ 3 ≠ z ^ 3 ",
        "parse-message": "unknown identifier 'x' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{x y z : ℤ} [decidable_linear_ordered_comm_ring α] (h :\nx ^ 3 + y ^ 3 ≠ z ^ 3) :\n0 < x ∧ 0 < y ",
        "parse-message": "unknown identifier 'decidable_linear_ordered_comm_ring' (during elaboration)"
      },
      {
        "success": true,
        "statement": "{x y z : ℤ} (hx : x > 0) (hy : y > 0) (hz : z > 0) :\nx ^ 3 + y ^ 3 ≠ z ^ 3 ",
        "code": "forall {x : Int} {y : Int} {z : Int} (hx : GT.gt.{?_uniq.9} Int Int.hasLt x (OfNat.ofNat.{?_uniq.12} Int 0 (Int.instOfNatInt 0))) (hy : GT.gt.{?_uniq.43} Int Int.hasLt y (OfNat.ofNat.{?_uniq.46} Int 0 (Int.instOfNatInt 0))) (hz : GT.gt.{?_uniq.65} Int Int.hasLt z (OfNat.ofNat.{?_uniq.68} Int 0 (Int.instOfNatInt 0))), Ne.{?_uniq.86} (?_uniq.230 x y z hx hy hz) (HAdd.hAdd.{?_uniq.90 ?_uniq.89 ?_uniq.88} (?_uniq.231 x y z hx hy hz) (?_uniq.232 x y z hx hy hz) (?_uniq.230 x y z hx hy hz) (?_uniq.233 x y z hx hy hz) (HPow.hPow.{?_uniq.93 ?_uniq.92 ?_uniq.91} Int (?_uniq.234 x y z hx hy hz) (?_uniq.231 x y z hx hy hz) (?_uniq.235 x y z hx hy hz) x (OfNat.ofNat.{?_uniq.92} (?_uniq.234 x y z hx hy hz) 3 (?_uniq.236 x y z hx hy hz))) (HPow.hPow.{?_uniq.117 ?_uniq.116 ?_uniq.115} Int (?_uniq.237 x y z hx hy hz) (?_uniq.232 x y z hx hy hz) (?_uniq.238 x y z hx hy hz) y (OfNat.ofNat.{?_uniq.116} (?_uniq.237 x y z hx hy hz) 3 (?_uniq.239 x y z hx hy hz)))) (HPow.hPow.{?_uniq.169 ?_uniq.168 ?_uniq.167} Int (?_uniq.240 x y z hx hy hz) (?_uniq.230 x y z hx hy hz) (?_uniq.241 x y z hx hy hz) z (OfNat.ofNat.{?_uniq.168} (?_uniq.240 x y z hx hy hz) 3 (?_uniq.242 x y z hx hy hz)))"
      }
    ],
    "number-parsed": 3,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "flt_3",
      "search_time": "1.502638221019879",
      "ret-prompts": [
        {
          "statement": "theorem pythagorean_triple.zero  : pythagorean_triple 0 0 0",
          "sim_score": "0.5193248391151428",
          "doc_string": "The zeroth Pythagorean triple is all zeros."
        },
        {
          "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
          "sim_score": "0.4774671792984009",
          "doc_string": "The sum of two squares is zero iff both elements are zero."
        },
        {
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
          "sim_score": "0.4648144245147705",
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**."
        },
        {
          "statement": "theorem pythagorean_triple_comm {x y z : ℤ} : pythagorean_triple x y z ↔ pythagorean_triple y x z",
          "sim_score": "0.4421241879463196",
          "doc_string": " Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The zeroth Pythagorean triple is all zeros.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\npythagorean_triple 0 0 0 := \n\nNatural language version: \"The sum of two squares is zero iff both elements are zero.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [linear_ordered_ring α] {x y : α} :\nx * x + y * y = 0 ↔ x = 0 ∧ y = 0 := \n\nNatural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \" Pythagorean triples are interchangable, i.e `x * x + y * y = y * y + x * x = z * z`. This comes from additive commutativity.\" Translate the natural language version to a Lean mathlib version:\n theorem {x y z : ℤ} :\npythagorean_triple x y z ↔ pythagorean_triple y x z := \n\nNatural language version: \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
      "codex_time": "4.896273948979797"
    },
    "grouped": [
      [
        "{x y z : ℤ} (hxz : 0 < x + y) (hyz : 0 < y + z) (hxz : 0 < x + z) :\n(x ^ 3 + y ^ 3 = z ^ 3) → False "
      ],
      [
        "{x y z : ℕ} (hx : x > 0) (hy : y > 0) (hz : z > 0) :\nx^3 + y^3 ≠ z^3 "
      ],
      [
        "{x y z : ℤ} (hx : x > 0) (hy : y > 0) (hz : z > 0) :\nx ^ 3 + y ^ 3 ≠ z ^ 3 "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ a b c : ℕ, a > 0 → b > 0 → ¬(a^3 + b^3 = c^3) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{G : Type u} [Group G] (h : ∀ x : G, Finite.Mk 0 = x.Order) : ∀ x y : G, Commute x y ",
        "parse-message": "unknown constant 'Finite.Mk' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u} (h : ∀ (x : G), IsOFFinOrder (x : G) ∧ 2 ≤ Nat.Find x) :\n∀ {x y : G}, Commute x y ",
        "parse-message": "unknown identifier 'IsOFFinOrder' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u} [Group G] (hG : is_of_fin_order_two G) {x y : G} :\nCommute x y ",
        "parse-message": "unknown identifier 'is_of_fin_order_two' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u} {x y : G} [Monoid G] (hx : IsOFFinOrder x) (hy : IsOFFinOrder y) :\n∀ (h : order_of x = 2) (h' : order_of y = 2),\nCommute x y ",
        "parse-message": "unknown identifier 'IsOFFinOrder' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] (h : ∀ x : G, is_of_order_two x) :\n∀ x y : G, Commute x y ",
        "parse-message": "unknown identifier 'is_of_order_two' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "elems_order_two_implies_commutative",
      "search_time": "1.6500981619756203",
      "ret-prompts": [
        {
          "statement": "theorem commute.symm {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) : commute b a",
          "sim_score": "0.6088767051696777",
          "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`."
        },
        {
          "statement": "theorem add_commute.symm {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) : add_commute b a",
          "sim_score": "0.6088767051696777",
          "doc_string": "If `a` commutes with `b`, then `b` commutes with `a`."
        },
        {
          "statement": "theorem commute.is_of_fin_order_mul {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) : is_of_fin_order (x * y)",
          "sim_score": "0.5862270593643188",
          "doc_string": "Commuting elements of finite order are closed under multiplication."
        },
        {
          "statement": "theorem commute.mul_right {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) : commute a (b * c)",
          "sim_score": "0.5844683647155762",
          "doc_string": "If `a` commutes with both `b` and `c`, then it commutes with their product."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If `a` commutes with `b`, then `b` commutes with `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {S : Type u_1} [has_mul S] {a b : S} (h : commute a b) :\ncommute b a := \n\nNatural language version: \"If `a` commutes with `b`, then `b` commutes with `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {S : Type u_1} [has_add S] {a b : S} (h : add_commute a b) :\nadd_commute b a := \n\nNatural language version: \"Commuting elements of finite order are closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} {y : G} [monoid G] {x : G} (h : commute x y) (hx : is_of_fin_order x) (hy : is_of_fin_order y) :\nis_of_fin_order (x * y) := \n\nNatural language version: \"If `a` commutes with both `b` and `c`, then it commutes with their product.\" Translate the natural language version to a Lean mathlib version:\n theorem {S : Type u_1} [semigroup S] {a b c : S} (hab : commute a b) (hac : commute a c) :\ncommute a (b * c) := \n\nNatural language version: \"If every element of a group `G` has order two, then every pair of elements of `G` commutes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every element of a group `G` has order two, then every pair of elements of `G` commutes.",
      "codex_time": "9.017476831009844"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{G: Type _}[Group G] : (∀ x y : G, x * x = 1) → (∀ x y : G, Commute x y) "
  },
  {
    "parsed": [
      "{P : ℕ} (hp : Nat.Prime P) : \nP = 2 ∨ P % 2 = 1 ",
      "(P : ℕ) :\n Nat.Prime P ↔ P = 2 ∨ P % 2 = 1 ",
      "{P : ℕ} (hp : Nat.Prime P) :\nP = 2 ∨ P % 2 = 1 ",
      "(n : ℕ) (hp : Nat.Prime n) :\nn = 2 ∨ n % 2 = 1 ",
      "{P : ℕ} (hp : Nat.Prime P) :\nP = 2 ∨ P % 2 = 1 "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "{P : ℕ} (hp : Nat.Prime P) : \nP = 2 ∨ P % 2 = 1 ",
        "code": "forall {P : Nat}, (Nat.Prime P) -> (Or (Eq.{?_uniq.7} Nat P (OfNat.ofNat.{?_uniq.10} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.30} Nat (HMod.hMod.{?_uniq.33 ?_uniq.32 ?_uniq.31} Nat Nat Nat (instHMod.{?_uniq.106} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.32} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.66} Nat 1 (instOfNatNat 1))))"
      },
      {
        "success": true,
        "statement": "(P : ℕ) :\n Nat.Prime P ↔ P = 2 ∨ P % 2 = 1 ",
        "code": "forall (P : Nat), Iff (Nat.Prime P) (Or (Eq.{?_uniq.4} Nat P (OfNat.ofNat.{?_uniq.7} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.27} Nat (HMod.hMod.{?_uniq.30 ?_uniq.29 ?_uniq.28} Nat Nat Nat (instHMod.{?_uniq.103} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.29} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.63} Nat 1 (instOfNatNat 1))))"
      },
      {
        "success": true,
        "statement": "{P : ℕ} (hp : Nat.Prime P) :\nP = 2 ∨ P % 2 = 1 ",
        "code": "forall {P : Nat}, (Nat.Prime P) -> (Or (Eq.{?_uniq.7} Nat P (OfNat.ofNat.{?_uniq.10} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.30} Nat (HMod.hMod.{?_uniq.33 ?_uniq.32 ?_uniq.31} Nat Nat Nat (instHMod.{?_uniq.106} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.32} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.66} Nat 1 (instOfNatNat 1))))"
      },
      {
        "success": true,
        "statement": "(n : ℕ) (hp : Nat.Prime n) :\nn = 2 ∨ n % 2 = 1 ",
        "code": "forall (n : Nat), (Nat.Prime n) -> (Or (Eq.{?_uniq.7} Nat n (OfNat.ofNat.{?_uniq.10} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.30} Nat (HMod.hMod.{?_uniq.33 ?_uniq.32 ?_uniq.31} Nat Nat Nat (instHMod.{?_uniq.106} Nat Nat.hasMod) n (OfNat.ofNat.{?_uniq.32} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.66} Nat 1 (instOfNatNat 1))))"
      },
      {
        "success": true,
        "statement": "{P : ℕ} (hp : Nat.Prime P) :\nP = 2 ∨ P % 2 = 1 ",
        "code": "forall {P : Nat}, (Nat.Prime P) -> (Or (Eq.{?_uniq.7} Nat P (OfNat.ofNat.{?_uniq.10} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.30} Nat (HMod.hMod.{?_uniq.33 ?_uniq.32 ?_uniq.31} Nat Nat Nat (instHMod.{?_uniq.106} Nat Nat.hasMod) P (OfNat.ofNat.{?_uniq.32} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.66} Nat 1 (instOfNatNat 1))))"
      }
    ],
    "number-parsed": 5,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "prime_eq_two_or_odd",
      "search_time": "1.46482077499968",
      "ret-prompts": [
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.7289595007896423",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        },
        {
          "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3",
          "sim_score": "0.5622097253799438",
          "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`"
        },
        {
          "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1",
          "sim_score": "0.5335504412651062",
          "doc_string": "The only numbers with empty prime factorization are `0` and `1`"
        },
        {
          "statement": "theorem nat.prime.factorization {p : ℕ} (hp : nat.prime p) : p.factorization = finsupp.single p 1",
          "sim_score": "0.5028786063194275",
          "doc_string": "The only prime factor of prime `p` is `p` itself, with multiplicity `1`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"A natural number is odd iff it has residue `1` or `3` mod `4`\" Translate the natural language version to a Lean mathlib version:\n theorem {n : ℕ} :\nn % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 := \n\nNatural language version: \"The only numbers with empty prime factorization are `0` and `1`\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\nn.factorization = 0 ↔ n = 0 ∨ n = 1 := \n\nNatural language version: \"The only prime factor of prime `p` is `p` itself, with multiplicity `1`\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} (hp : nat.prime p) :\np.factorization = finsupp.single p 1 := \n\nNatural language version: \"Every prime number is either `2` or odd.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every prime number is either `2` or odd.",
      "codex_time": "4.6803766950033605"
    },
    "grouped": [
      [
        "{P : ℕ} (hp : Nat.Prime P) : \nP = 2 ∨ P % 2 = 1 ",
        "{P : ℕ} (hp : Nat.Prime P) :\nP = 2 ∨ P % 2 = 1 ",
        "(n : ℕ) (hp : Nat.Prime n) :\nn = 2 ∨ n % 2 = 1 ",
        "{P : ℕ} (hp : Nat.Prime P) :\nP = 2 ∨ P % 2 = 1 "
      ],
      [
        "(P : ℕ) :\n Nat.Prime P ↔ P = 2 ∨ P % 2 = 1 "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "{n: Nat} : Prime n → n = 2 ∨ Odd n "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "(P : Polynomial ℝ) (h : P.nat_degree % 2 = 1) : ∃ x : ℝ, P.Eval x = 0 ",
        "parse-message": "invalid field 'nat_degree', the environment does not contain 'Polynomial.nat_degree'\n  P\nhas type\n  ℝ[X] (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] [LinearOrderedField R] (F : Polynomial R) (hf : F.nat_degree % 2 = 1) :\n∃ (A : R), Polynomial.Eval F A = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [discrete_field R] (F : Polynomial R) :\nF.nat_degree % 2 = 1 → ∃ A : R, F.Eval A = 0 ",
        "parse-message": "unknown identifier 'discrete_field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type} [LinearOrderedField α] [Nontrivial α] (P : Polynomial α) (h : 2 ∣ P.nat_degree) :\n∃ x : α, P.Eval x = 0 ",
        "parse-message": "invalid field 'nat_degree', the environment does not contain 'Polynomial.nat_degree'\n  P\nhas type\n  α[X] (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [discrete_linear_ordered_field α] (P : Polynomial α) (hp : P.nat_degree = 1 + 2 * P.nat_degree.div2) (h : P ≠ 0) :\n∃ c : α, P.Eval₂ c = 0 ",
        "parse-message": "unknown identifier 'discrete_linear_ordered_field' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "poly_odd_degree_has_zero",
      "search_time": "1.528045929997461",
      "ret-prompts": [
        {
          "statement": "theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ≤ (multiset.map polynomial.degree t).sum",
          "sim_score": "0.50849449634552",
          "doc_string": "The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥."
        },
        {
          "statement": "theorem polynomial.degree_multiset_prod {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] : t.prod.degree = (multiset.map (λ (f : polynomial R), f.degree) t).sum",
          "sim_score": "0.48135414719581604",
          "doc_string": "The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥."
        },
        {
          "statement": "theorem polynomial.degree_prod {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) [nontrivial R] : (s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree)",
          "sim_score": "0.48135414719581604",
          "doc_string": "The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥."
        },
        {
          "statement": "theorem minpoly.nat_degree_pos {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) : 0 < (minpoly A x).nat_degree",
          "sim_score": "0.4661085605621338",
          "doc_string": "The degree of a minimal polynomial, as a natural number, is positive."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) :\nt.prod.degree ≤ (multiset.map polynomial.degree t).sum := \n\nNatural language version: \"The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_semiring R] [no_zero_divisors R] (t : multiset (polynomial R)) [nontrivial R] :\nt.prod.degree = (multiset.map (λ (f : polynomial R), f.degree) t).sum := \n\nNatural language version: \"The degree of a product of polynomials is equal to the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} {ι : Type w} (s : finset ι) [comm_semiring R] [no_zero_divisors R] (f : ι → polynomial R) [nontrivial R] :\n(s.prod (λ (i : ι), f i)).degree = s.sum (λ (i : ι), (f i).degree) := \n\nNatural language version: \"The degree of a minimal polynomial, as a natural number, is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem {A : Type u_1} {B : Type u_2} [comm_ring A] [ring B] [algebra A B] [nontrivial B] {x : B} (hx : is_integral A x) :\n0 < (minpoly A x).nat_degree := \n\nNatural language version: \"Every odd degree polynomial over `ℝ` has a zero\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every odd degree polynomial over `ℝ` has a zero",
      "codex_time": "4.9523714979877695"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{α : Type _} [Field α] (p : Polynomial α) : Odd (p.degree) → ∃ x, p.IsRoot x "
  },
  {
    "parsed": [
      "{m : ℕ} :\nEven (m * (m + 1)) ",
      "(n : ℕ+) {A b : ℕ+} :\n(A*(A+1) = b*(b+1)) → (b % 2 = 1) ",
      "{m n : ℕ} :\nn = m + 1 → n * m % 2 = 1 "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "{m : ℕ} :\nEven (m * (m + 1)) ",
        "code": "forall {m : Nat}, Even.{?_uniq.4} Nat Nat.hasAdd (HMul.hMul.{?_uniq.9 ?_uniq.8 ?_uniq.7} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) m (HAdd.hAdd.{?_uniq.12 ?_uniq.11 ?_uniq.10} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{?_uniq.15} Nat 1 (?_uniq.93 m))))"
      },
      {
        "success": true,
        "statement": "(n : ℕ+) {A b : ℕ+} :\n(A*(A+1) = b*(b+1)) → (b % 2 = 1) ",
        "code": "forall (n : Pnat) {A : Pnat} {b : Pnat}, (Eq.{?_uniq.10} Pnat (HMul.hMul.{?_uniq.13 ?_uniq.12 ?_uniq.11} Pnat Pnat Pnat (instHMul.{0} Pnat Pnat.hasMul) A (HAdd.hAdd.{?_uniq.16 ?_uniq.15 ?_uniq.14} Pnat Pnat Pnat (instHAdd.{0} Pnat Pnat.hasAdd) A (OfNat.ofNat.{?_uniq.19} Pnat 1 (One.toOfNat1.{0} Pnat Pnat.hasOne)))) (HMul.hMul.{?_uniq.35 ?_uniq.34 ?_uniq.33} Pnat Pnat Pnat (instHMul.{0} Pnat Pnat.hasMul) b (HAdd.hAdd.{?_uniq.38 ?_uniq.37 ?_uniq.36} Pnat Pnat Pnat (instHAdd.{0} Pnat Pnat.hasAdd) b (OfNat.ofNat.{?_uniq.41} Pnat 1 (One.toOfNat1.{0} Pnat Pnat.hasOne))))) -> (Eq.{?_uniq.187} Nat (HMod.hMod.{?_uniq.190 ?_uniq.189 ?_uniq.188} Pnat Nat Nat (?_uniq.330 n A b) b (OfNat.ofNat.{?_uniq.189} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.223} Nat 1 (instOfNatNat 1)))"
      },
      {
        "success": false,
        "statement": "(n : ℕ+) :\nOdd ((n + 1) * n) ",
        "parse-message": "failed to synthesize instance\n  Semiringₓ ℕ+ (during elaboration)"
      },
      {
        "success": false,
        "statement": "(n : ℕ+) :\n∃ (A : ℕ), 2 * A + 1 = n.Gcd (2 * A) ",
        "parse-message": "invalid field 'Gcd', the environment does not contain 'Subtype.Gcd'\n  n\nhas type\n  { n // Zero.zero < n } (during elaboration)"
      },
      {
        "success": true,
        "statement": "{m n : ℕ} :\nn = m + 1 → n * m % 2 = 1 ",
        "code": "forall {m : Nat} {n : Nat}, (Eq.{?_uniq.7} Nat n (HAdd.hAdd.{?_uniq.10 ?_uniq.9 ?_uniq.8} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) m (OfNat.ofNat.{?_uniq.13} Nat 1 (instOfNatNat 1)))) -> (Eq.{?_uniq.63} Nat (HMod.hMod.{?_uniq.66 ?_uniq.65 ?_uniq.64} Nat Nat Nat (instHMod.{?_uniq.173} Nat Nat.hasMod) (HMul.hMul.{?_uniq.73 ?_uniq.72 ?_uniq.71} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) n m) (OfNat.ofNat.{?_uniq.65} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.133} Nat 1 (instOfNatNat 1)))"
      }
    ],
    "number-parsed": 3,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "product_conseq_odd",
      "search_time": "1.482777747005457",
      "ret-prompts": [
        {
          "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0",
          "sim_score": "0.5561787486076355",
          "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive."
        },
        {
          "statement": "theorem nat.odd_mod_four_iff {n : ℕ} : n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3",
          "sim_score": "0.5415111780166626",
          "doc_string": "A natural number is odd iff it has residue `1` or `3` mod `4`"
        },
        {
          "statement": "theorem nat.dvd_right_iff_eq {m n : ℕ} : (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n",
          "sim_score": "0.5249637365341187",
          "doc_string": "Two natural numbers are equal if and only if the have the same multiples."
        },
        {
          "statement": "theorem pnat.prod_factor_multiset (n : ℕ+) : n.factor_multiset.prod = n",
          "sim_score": "0.5125280022621155",
          "doc_string": "The product of the factors is the original number"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem {m n : ℕ} :\neven (m ^ n) ↔ even m ∧ n ≠ 0 := \n\nNatural language version: \"A natural number is odd iff it has residue `1` or `3` mod `4`\" Translate the natural language version to a Lean mathlib version:\n theorem {n : ℕ} :\nn % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 := \n\nNatural language version: \"Two natural numbers are equal if and only if the have the same multiples.\" Translate the natural language version to a Lean mathlib version:\n theorem {m n : ℕ} :\n(∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n := \n\nNatural language version: \"The product of the factors is the original number\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ+) :\nn.factor_multiset.prod = n := \n\nNatural language version: \"The product of two consequitive natural numbers is odd\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of two consequitive natural numbers is odd",
      "codex_time": "5.241321459994651"
    },
    "grouped": [
      [
        "{m : ℕ} :\nEven (m * (m + 1)) "
      ],
      [
        "(n : ℕ+) {A b : ℕ+} :\n(A*(A+1) = b*(b+1)) → (b % 2 = 1) "
      ],
      [
        "{m n : ℕ} :\nn = m + 1 → n * m % 2 = 1 "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "(n: Nat): Odd <| n * (n + 1) "
  },
  {
    "parsed": [
      "differentiable_const (c : ℝ) : Differentiable ℝ (λ x:ℝ, c) "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : ℝ → ℝ} (h : const_func F) : Differentiable 𝕜 F ",
        "parse-message": "unknown identifier 'const_func' (during elaboration)"
      },
      {
        "success": false,
        "statement": "differentiable.Const {F : Real → Real} (h : ∀x, F x = F 0) : Differentiable F ",
        "parse-message": "application type mismatch\n  @Differentiable F\nargument\n  F\nhas type\n  ℝ → ℝ : Type\nbut is expected to have type\n  Type ?u.41 : Type (?u.41 + 1) (during elaboration)"
      },
      {
        "success": false,
        "statement": "{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {E : Type u_2} [NormedGroup E] [NormedSpace 𝕜 E] {F : Type u_3} [NormedGroup F] [NormedSpace 𝕜 F] {F : E → F} (c : F) :\n(∀ x : E, F x = c) → DifferentiableOn 𝕜 F (Univ : set E) ",
        "parse-message": "type expected\nfailed to synthesize instance\n  CoeSort (E → F✝) ?m.216 (during elaboration)"
      },
      {
        "success": true,
        "statement": "differentiable_const (c : ℝ) : Differentiable ℝ (λ x:ℝ, c) ",
        "code": "forall (c : Real), Differentiable.{?_uniq.6 ?_uniq.5 ?_uniq.4} Real Real.nondiscreteNormedField Real Real.normedGroup (NormedField.toNormedSpace.{0} Real (NondiscreteNormedField.toNormedField.{0} Real Real.nondiscreteNormedField)) Real Real.normedGroup (NormedField.toNormedSpace.{0} Real (NondiscreteNormedField.toNormedField.{0} Real Real.nondiscreteNormedField)) (fun (x : Real) => c)"
      },
      {
        "success": false,
        "statement": "{𝕜 : Type u_1} [NondiscreteNormedField 𝕜] {F : ℝ → ℝ} {c : ℝ} (h : constant F c) :\nDifferentiableOn 𝕜 F Univ ",
        "parse-message": "<input>:1:67: expected term"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "constant_is_differentiable",
      "search_time": "1.5521861550223548",
      "ret-prompts": [
        {
          "statement": "theorem cont_diff.differentiable {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) : differentiable 𝕜 f",
          "sim_score": "0.6595531702041626",
          "doc_string": "If a function is `C^n` with `n ≥ 1`, then it is differentiable."
        },
        {
          "statement": "theorem cont_diff_at.differentiable_at {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) : differentiable_at 𝕜 f x",
          "sim_score": "0.6467167139053345",
          "doc_string": "If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there."
        },
        {
          "statement": "theorem cont_diff_within_at.differentiable_within_at' {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) : differentiable_within_at 𝕜 f (has_insert.insert x s) x",
          "sim_score": "0.6451953649520874",
          "doc_string": " If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable within this set at this point."
        },
        {
          "statement": "theorem cont_diff_on.differentiable_on {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) : differentiable_on 𝕜 f s",
          "sim_score": "0.6353325843811035",
          "doc_string": "If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If a function is `C^n` with `n ≥ 1`, then it is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {n : with_top ℕ} (h : cont_diff 𝕜 n f) (hn : 1 ≤ n) :\ndifferentiable 𝕜 f := \n\nNatural language version: \"If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_at 𝕜 n f x) (hn : 1 ≤ n) :\ndifferentiable_at 𝕜 f x := \n\nNatural language version: \" If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable within this set at this point.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {x : E} {n : with_top ℕ} (h : cont_diff_within_at 𝕜 n f s x) (hn : 1 ≤ n) :\ndifferentiable_within_at 𝕜 f (has_insert.insert x s) x := \n\nNatural language version: \"If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} [nondiscrete_normed_field 𝕜] {E : Type u_2} [normed_group E] [normed_space 𝕜 E] {F : Type u_3} [normed_group F] [normed_space 𝕜 F] {s : set E} {f : E → F} {n : with_top ℕ} (h : cont_diff_on 𝕜 n f s) (hn : 1 ≤ n) :\ndifferentiable_on 𝕜 f s := \n\nNatural language version: \"Every constant function `f x = c` from real numbers to real numbers is differentiable.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every constant function `f x = c` from real numbers to real numbers is differentiable.",
      "codex_time": "6.46006202098215"
    },
    "grouped": [
      [
        "differentiable_const (c : ℝ) : Differentiable ℝ (λ x:ℝ, c) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "{f: ℝ → ℝ}: ∃ c: ℝ, (∀ x : ℝ, f x = c) → Differentiable ℝ f "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "(G : Type u_1) [Group G] (h : subgroup G) (pfHG : h.Index = 2) :\n @free_of_IIc _ _ 1 _ h ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] (h : subgroup G) (hi2 : h.Index = 2) : free_group ↥h ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{A : Type u_1} [G : Group A] (h : subgroup A) (Fh : h.Index = 2) :\nGroup.Free h.Carrier ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(G : Type u_1) [CommGroup G] (h : subgroup G) :\nh.Index = 2 → free_group G h ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] :\n∀ (h : subgroup G) (hH : h.Finite.Index = 2), free_group h ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "index_two_subgroup",
      "search_time": "1.501041351002641",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H",
          "sim_score": "0.6636497974395752",
          "doc_string": "Subgroups of torsion-free groups are torsion-free."
        },
        {
          "statement": "theorem subgroup.fg_of_index_ne_zero {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) : group.fg ↥H",
          "sim_score": "0.5494142770767212",
          "doc_string": "**Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated."
        },
        {
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.5431281924247742",
          "doc_string": "Direct products of torsion free groups are torsion free."
        },
        {
          "statement": "theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G)",
          "sim_score": "0.5406138896942139",
          "doc_string": "Quotienting a group by its torsion subgroup yields a torsion free group."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"**Schreier's Lemma**: A finite index subgroup of a finitely generated  group is finitely generated.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] {H : subgroup G} [hG : group.fg G] (hH : H.index ≠ 0) :\ngroup.fg ↥H := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Quotienting a group by its torsion subgroup yields a torsion free group.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type u_1) [comm_group G] :\nmonoid.is_torsion_free (G ⧸ torsion G) := \n\nNatural language version: \"Every index 2 subgroup of a group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every index 2 subgroup of a group is free",
      "codex_time": "6.778020755999023"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{G : Type _} [Groupₓ G] (H : Subgroup G): H.index = 2 → Subgroup.Normal H "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "(α : Type u) (F : free_group α) {h : set F} [IsSubgroup h] :\nFreeGroup h ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} (F : free_group α) (h : subgroup (free_group α)) :\nfree_group_of (h : set (free_group α))= h ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(G : Type u_1) [free_group G] (h : subgroup G) :\n   free_group (Subtype.val h) ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] (FG : free_group G) (h : subgroup G) : free_group ↥h ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{η : Type u_1} {G : Type u_2} [Group G] (frG : free_group η G) (h : subgroup G) :\nfree_group η ↥h ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "subgpFree",
      "search_time": "1.4969823299907148",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H",
          "sim_score": "0.7357965111732483",
          "doc_string": "Subgroups of torsion-free groups are torsion-free."
        },
        {
          "statement": "theorem is_torsion_free.quotient_torsion (G : Type u_1) [comm_group G] : monoid.is_torsion_free (G ⧸ torsion G)",
          "sim_score": "0.621972382068634",
          "doc_string": "Quotienting a group by its torsion subgroup yields a torsion free group."
        },
        {
          "statement": "theorem is_torsion_free.add_subgroup {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) : add_monoid.is_torsion_free ↥H",
          "sim_score": "0.6199988722801208",
          "doc_string": "Subgroups of additive torsion-free groups are additively torsion-free."
        },
        {
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.58650141954422",
          "doc_string": "Direct products of torsion free groups are torsion free."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"Quotienting a group by its torsion subgroup yields a torsion free group.\" Translate the natural language version to a Lean mathlib version:\n theorem (G : Type u_1) [comm_group G] :\nmonoid.is_torsion_free (G ⧸ torsion G) := \n\nNatural language version: \"Subgroups of additive torsion-free groups are additively torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [add_group G] (tG : add_monoid.is_torsion_free G) (H : add_subgroup G) :\nadd_monoid.is_torsion_free ↥H := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Every subgroup of a free group is free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every subgroup of a free group is free",
      "codex_time": "2.655978763999883"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{G : Type _} [Groupₓ G] : (K : Subgroup G) → Σ β, FreeGroup β ≃* ↥K "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] (tG : free_group G) : Monoid.IsTorsionFree G ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{η : Type u_1} {G : Type u_2} [Group G] (h : ∀ (A : η), ∃ (g : G), g ≠ (1 : G)) : Monoid.IsTorsionFree G ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{A : Type u} [Group A] (FA : Monoid.is_free A) :\nMonoid.IsTorsionFree A ",
        "parse-message": "unknown constant 'Monoid.is_free' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} [c : Fintype α] (Gs : α → Type u_2) (hgs : ∀ (i : α) (F : Gs i), ∃ g : Gs i, g ≠ F) (hs :\n∀ {i j : α}, i ≠ j → ∃ k : Gs i → Gs j, ∀ (l : Gs i), k l ≠ l) (Hs : ∀ i : α, Group (Gs i)) :\nMonoid.IsTorsionFree (free_group α Gs) ",
        "parse-message": "application type mismatch\n  k l ≠ l\nargument\n  l\nhas type\n  Gs i : Type u_2\nbut is expected to have type\n  Gs j : Type u_2 (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} {s : Type u_2} [Group G] (is_free : FreeGroup s G) :\nMonoid.IsTorsionFree G ",
        "parse-message": "function expected at\n  FreeGroup s\nterm has type\n  Type u_2 (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "free_group_torsion_free",
      "search_time": "1.5132423070026562",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H",
          "sim_score": "0.8580459356307983",
          "doc_string": "Subgroups of torsion-free groups are torsion-free."
        },
        {
          "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G",
          "sim_score": "0.8004929423332214",
          "doc_string": "A nontrivial torsion-free group is not torsion."
        },
        {
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.7987847924232483",
          "doc_string": "Direct products of torsion free groups are torsion free."
        },
        {
          "statement": "theorem add_monoid.is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) : add_monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.7854448556900024",
          "doc_string": "Direct products of additive torsion free groups are torsion free."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"A nontrivial torsion-free group is not torsion.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion_free G → ¬monoid.is_torsion G := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Direct products of additive torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), add_group (Gs i)] (tfGs : ∀ (i : η), add_monoid.is_torsion_free (Gs i)) :\nadd_monoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"Every free group is torsion free\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every free group is torsion free",
      "codex_time": "13.028151459002402"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{α : Type} : Monoidₓ.IsTorsionFree (FreeGroup α) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] {h : subgroup G} (h : (∃ (x : G), x ∉ h) →\nh ≃ₐ[R] ℤ) : \n *)\n \nend fin_mul_action",
        "parse-message": "<input>:3:1: expected term"
      },
      {
        "success": false,
        "statement": "{h : subgroup ℤ} : h ≠ ⊥ → group_isomorphism ℤ h ",
        "parse-message": "unknown identifier 'subgroup' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{h : Type u_1} [Group h] (h : 0 ∈ h) :\n@group_equiv ℤ _ _ h ",
        "parse-message": "failed to synthesize instance\n  Membership ?m.15 (Type u_1) (during elaboration)"
      },
      {
        "success": false,
        "statement": "(G :\n∃ (e : ℤ), e ∈ G ∧ ∀ (A : ℤ), A ∈ G → A + -[1+ A] ∈ G) : \n∃ (F : ℤ → G), IsGroupHom F ",
        "parse-message": "unknown identifier 'G' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u} [Group G] (h : Nonempty (subgroup G)) :\n@Group.equiv.{u u} G G ",
        "parse-message": "<input>:2:16: expected '}'"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "integer_subgroups",
      "search_time": "1.4847017290012445",
      "ret-prompts": [
        {
          "statement": "theorem int.subgroup_cyclic (H : add_subgroup ℤ) : ∃ (a : ℤ), H = add_subgroup.closure {a}",
          "sim_score": "0.710217297077179",
          "doc_string": "Every subgroup of `ℤ` is cyclic."
        },
        {
          "statement": "theorem quotient_group.subgroup_eq_top_of_subsingleton {G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ⧸ H)) : H = ⊤",
          "sim_score": "0.5739960670471191",
          "doc_string": "If the quotient by a subgroup gives a singleton then the subgroup is the whole group."
        },
        {
          "statement": "theorem subgroup.subset_closure {G : Type u_1} [group G] {k : set G} : k ⊆ ↑(subgroup.closure k)",
          "sim_score": "0.5350345969200134",
          "doc_string": "The subgroup generated by a set includes the set."
        },
        {
          "statement": "theorem subgroup.ext {G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K",
          "sim_score": "0.5225922465324402",
          "doc_string": "Two subgroups are equal if they have the same elements."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Every subgroup of `ℤ` is cyclic.\" Translate the natural language version to a Lean mathlib version:\n theorem (H : add_subgroup ℤ) :\n∃ (a : ℤ), H = add_subgroup.closure {a} := \n\nNatural language version: \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} [group G] (H : subgroup G) (h : subsingleton (G ⧸ H)) :\nH = ⊤ := \n\nNatural language version: \"The subgroup generated by a set includes the set.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] {k : set G} :\nk ⊆ ↑(subgroup.closure k) := \n\nNatural language version: \"Two subgroups are equal if they have the same elements.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] {H K : subgroup G} (h : ∀ (x : G), x ∈ H ↔ x ∈ K) :\nH = K := \n\nNatural language version: \"Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-empty subgroup of `ℤ` is isomorphic to `ℤ`",
      "codex_time": "8.135182752012042"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "(H : AddSubgroup ℤ) : H.Carrier.Nonempty  →   ↥H ≃+ ℤ "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] [Algebra ℚ R] [is_fraction_ring R ℚ] (P : Polynomial R) (h : P.leading_coeff ∈ ℤ) (R : R) (h_monic : P.Monic) (h_root : R ∣ P.leading_coeff ∧ P.Eval R = 0) :\nR ∈ ℤ ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{P : Polynomial ℚ} (hp : ∀c : ℤ, c ∈ P.coeffs → ∃x : ℕ, ↑x ∣ c) {R : ℚ} (hr : P.Eval R = 0) : IsLocalization.IsInteger ℤ R ",
        "parse-message": "invalid field 'coeffs', the environment does not contain 'Polynomial.coeffs'\n  P\nhas type\n  ℚ[X] (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [Semiring R] [NoZeroDivisors R] [Field R] [Algebra ℤ R] {P : Polynomial R} (h : ∀ (i : Polynomial R), i ∈ P.Support → IsLocalization.IsInteger ℤ (Polynomial.Coeff P i)) {R : R} (h_root : P.Eval R = 0) :\nIsLocalization.IsInteger ℤ R ",
        "parse-message": "invalid field 'Support', the environment does not contain 'Polynomial.Support'\n  P\nhas type\n  R[X] (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [comm_ring α] [DecidableEQ α] [Fintype α] {P : Polynomial α} (hp : ∀ b ∈ P.coeffs, IsLocalization.IsInteger ℚ b) {R : α} (hr : P.Eval R = 0) (hp' : IsLocalization.IsInteger ℚ R) :\nIsLocalization.IsInteger ℚ R ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] [is_domain R] [UniqueFactorizationMonoid R] [field ℚ] [Algebra R ℚ] [is_fraction_ring R ℚ] {P : Polynomial R} (h : (∀ i, IsLocalization.IsInteger R i)):\n(∀ R : ℚ, Polynomial.aeval R P = 0 → IsLocalization.IsInteger R R) ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "int_poly_rat_zeros_int",
      "search_time": "1.4644726150145289",
      "ret-prompts": [
        {
          "statement": "theorem num_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_fraction_ring.num A r ∣ p.coeff 0",
          "sim_score": "0.6362022161483765",
          "doc_string": " Rational root theorem part 1: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the numerator of `r` divides the constant coefficient"
        },
        {
          "statement": "theorem is_integer_of_is_root_of_monic {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : is_localization.is_integer A r",
          "sim_score": "0.6275410652160645",
          "doc_string": " Integral root theorem: if `r : f.codomain` is a root of a monic polynomial over the ufd `A`, then `r` is an integer"
        },
        {
          "statement": "theorem denom_dvd_of_is_root {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) : ↑(is_fraction_ring.denom A r) ∣ p.leading_coeff",
          "sim_score": "0.6202014684677124",
          "doc_string": " Rational root theorem part 2: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the denominator of `r` divides the leading coefficient"
        },
        {
          "statement": "theorem polynomial.nat_degree_sub_eq_of_prod_eq {R : Type u} [semiring R] [no_zero_divisors R] {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) : ↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree)",
          "sim_score": "0.5798273086547852",
          "doc_string": "This lemma is useful for working with the `int_degree` of a rational function."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" Rational root theorem part 1: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the numerator of `r` divides the constant coefficient\" Translate the natural language version to a Lean mathlib version:\n theorem {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\nis_fraction_ring.num A r ∣ p.coeff 0 := \n\nNatural language version: \" Integral root theorem: if `r : f.codomain` is a root of a monic polynomial over the ufd `A`, then `r` is an integer\" Translate the natural language version to a Lean mathlib version:\n theorem {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} (hp : p.monic) {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\nis_localization.is_integer A r := \n\nNatural language version: \" Rational root theorem part 2: if `r : f.codomain` is a root of a polynomial over the ufd `A`, then the denominator of `r` divides the leading coefficient\" Translate the natural language version to a Lean mathlib version:\n theorem {A : Type u_1} {K : Type u_2} [comm_ring A] [is_domain A] [unique_factorization_monoid A] [field K] [algebra A K] [is_fraction_ring A K] {p : polynomial A} {r : K} (hr : ⇑(polynomial.aeval r) p = 0) :\n↑(is_fraction_ring.denom A r) ∣ p.leading_coeff := \n\nNatural language version: \"This lemma is useful for working with the `int_degree` of a rational function.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [semiring R] [no_zero_divisors R] {p₁ p₂ q₁ q₂ : polynomial R} (hp₁ : p₁ ≠ 0) (hq₁ : q₁ ≠ 0) (hp₂ : p₂ ≠ 0) (hq₂ : q₂ ≠ 0) (h_eq : p₁ * q₂ = p₂ * q₁) :\n↑(p₁.nat_degree) - ↑(q₁.nat_degree) = ↑(p₂.nat_degree) - ↑(q₂.nat_degree) := \n\nNatural language version: \"If the coefficients of a polynomial over rationals are integral, every rational root is integral.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If the coefficients of a polynomial over rationals are integral, every rational root is integral.",
      "codex_time": "10.011051232984755"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "int_poly_rat_zeros_int (p: Polynomial ℚ) : ∀ n: ℕ, IsIntegral ℚ (p.coeff n) →  ∀ x: ℚ, p.IsRoot x →  IsIntegral ℚ x "
  },
  {
    "parsed": [
      "{n : ℕ} (h : n > 1) :\n∃ P, Nat.Prime P ∧ P ∣ n ",
      "{A : ℕ} (ha : 2 ≤ A) :\n ∃ P, P.Prime ∧ ↑P ∣ A ",
      ":\n∀ {n : ℕ} (hn : 1 < n), ∃ (P : ℕ) (hp : Nat.Prime P), P ∣ n ",
      "{n : ℕ} (hn : n > 1) :\n∃ P : ℕ, Nat.Prime P ∧ P ∣ n "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": "{n : ℕ} (h : n > 1) :\n∃ P, Nat.Prime P ∧ P ∣ n ",
        "code": "forall {n : Nat}, (GT.gt.{?_uniq.5} Nat Nat.hasLt n (OfNat.ofNat.{?_uniq.8} Nat 1 (instOfNatNat 1))) -> (Exists.{?_uniq.38} Nat (fun (P : Nat) => And (Nat.Prime P) (Dvd.dvd.{?_uniq.43} Nat Nat.hasDvd P n)))"
      },
      {
        "success": true,
        "statement": "{A : ℕ} (ha : 2 ≤ A) :\n ∃ P, P.Prime ∧ ↑P ∣ A ",
        "code": "forall {A : Nat} (ha : LE.le.{?_uniq.5} Nat Nat.hasLe (OfNat.ofNat.{?_uniq.8} Nat 2 (instOfNatNat 2)) A), Exists.{?_uniq.39} (?_uniq.58 A ha) (fun (P : ?_uniq.58 A ha) => And (?_uniq.59 A ha P) (Dvd.dvd.{?_uniq.45} Nat Nat.hasDvd (?_uniq.60 A ha P) A))"
      },
      {
        "success": true,
        "statement": ":\n∀ {n : ℕ} (hn : 1 < n), ∃ (P : ℕ) (hp : Nat.Prime P), P ∣ n ",
        "code": "forall {n : Nat}, (LT.lt.{?_uniq.4} Nat Nat.hasLt (OfNat.ofNat.{?_uniq.7} Nat 1 (instOfNatNat 1)) n) -> (Exists.{?_uniq.42} Nat (fun (P : Nat) => Exists.{?_uniq.46} (Nat.Prime P) (fun (hp : Nat.Prime P) => Dvd.dvd.{?_uniq.50} Nat Nat.hasDvd P n)))"
      },
      {
        "success": true,
        "statement": "{n : ℕ} (hn : n > 1) :\n∃ P : ℕ, Nat.Prime P ∧ P ∣ n ",
        "code": "forall {n : Nat}, (GT.gt.{?_uniq.5} Nat Nat.hasLt n (OfNat.ofNat.{?_uniq.8} Nat 1 (instOfNatNat 1))) -> (Exists.{?_uniq.38} Nat (fun (P : Nat) => And (Nat.Prime P) (Dvd.dvd.{?_uniq.42} Nat Nat.hasDvd P n)))"
      },
      {
        "success": false,
        "statement": "{n : ℕ} (h : 2 ≤ n ==> ∃ P ∈ Primes, P ∣ n) ",
        "parse-message": "<input>:1:19: expected ')'"
      }
    ],
    "number-parsed": 4,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "has_prime_factor",
      "search_time": "1.454934626002796",
      "ret-prompts": [
        {
          "statement": "theorem nat.eq_zero_of_dvd_of_lt {a b : ℕ} (w : a ∣ b) (h : b < a) : b = 0",
          "sim_score": "0.6529487371444702",
          "doc_string": " If a small natural number is divisible by a larger natural number, the small number is zero."
        },
        {
          "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}",
          "sim_score": "0.593155562877655",
          "doc_string": "Every nonzero natural number has a unique prime factorization"
        },
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.5878391265869141",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        },
        {
          "statement": "theorem nat.prime.factorization {p : ℕ} (hp : nat.prime p) : p.factorization = finsupp.single p 1",
          "sim_score": "0.5869839191436768",
          "doc_string": "The only prime factor of prime `p` is `p` itself, with multiplicity `1`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If a small natural number is divisible by a larger natural number, the small number is zero.\" Translate the natural language version to a Lean mathlib version:\n theorem {a b : ℕ} (w : a ∣ b) (h : b < a) :\nb = 0 := \n\nNatural language version: \"Every nonzero natural number has a unique prime factorization\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nset.inj_on nat.factorization {x : ℕ | x ≠ 0} := \n\nNatural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"The only prime factor of prime `p` is `p` itself, with multiplicity `1`\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} (hp : nat.prime p) :\np.factorization = finsupp.single p 1 := \n\nNatural language version: \"Every natural number greater than `1` is divisible by a prime number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every natural number greater than `1` is divisible by a prime number.",
      "codex_time": "4.207383264991222"
    },
    "grouped": [
      [
        "{n : ℕ} (h : n > 1) :\n∃ P, Nat.Prime P ∧ P ∣ n ",
        "{n : ℕ} (hn : n > 1) :\n∃ P : ℕ, Nat.Prime P ∧ P ∣ n "
      ],
      [
        "{A : ℕ} (ha : 2 ≤ A) :\n ∃ P, P.Prime ∧ ↑P ∣ A "
      ],
      [
        ":\n∀ {n : ℕ} (hn : 1 < n), ∃ (P : ℕ) (hp : Nat.Prime P), P ∣ n "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": "(n: ℕ) : n > 1 → ∃ p: ℕ, Prime p ∧ (∃ d: ℕ, p * d = n) "
  },
  {
    "parsed": [
      ":\n¬ ∃ (A b : ℕ), Nat.Prime A ∧ Nat.Prime b ∧ A + b = 6 ",
      ":\n¬ ∃ (A b : ℕ), Nat.Prime A ∧ Nat.Prime b ∧ A + b = 6 ",
      ":\n¬ ∃ (A b : ℕ), Nat.Prime A ∧ Nat.Prime b ∧ A + b = 6 ",
      ": ∀ P Q : ℕ, Nat.Prime P → Nat.Prime Q → P + Q ≠ 6 ",
      ": ¬ ((2 : ℕ) = (3 : ℕ)) ∧ ¬ ((2 : ℕ) = (3 : ℕ)) "
    ],
    "parse-checks": [
      {
        "success": true,
        "statement": ":\n¬ ∃ (A b : ℕ), Nat.Prime A ∧ Nat.Prime b ∧ A + b = 6 ",
        "code": "Not (Exists.{?_uniq.1} ?_uniq.2 (fun (A : Nat) => Exists.{?_uniq.5} Nat (fun (b : Nat) => And (Nat.Prime A) (And (Nat.Prime b) (Eq.{?_uniq.9} Nat (HAdd.hAdd.{?_uniq.12 ?_uniq.11 ?_uniq.10} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) A b) (OfNat.ofNat.{?_uniq.15} Nat 6 (instOfNatNat 6)))))))"
      },
      {
        "success": true,
        "statement": ":\n¬ ∃ (A b : ℕ), Nat.Prime A ∧ Nat.Prime b ∧ A + b = 6 ",
        "code": "Not (Exists.{?_uniq.1} ?_uniq.2 (fun (A : Nat) => Exists.{?_uniq.5} Nat (fun (b : Nat) => And (Nat.Prime A) (And (Nat.Prime b) (Eq.{?_uniq.9} Nat (HAdd.hAdd.{?_uniq.12 ?_uniq.11 ?_uniq.10} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) A b) (OfNat.ofNat.{?_uniq.15} Nat 6 (instOfNatNat 6)))))))"
      },
      {
        "success": true,
        "statement": ":\n¬ ∃ (A b : ℕ), Nat.Prime A ∧ Nat.Prime b ∧ A + b = 6 ",
        "code": "Not (Exists.{?_uniq.1} ?_uniq.2 (fun (A : Nat) => Exists.{?_uniq.5} Nat (fun (b : Nat) => And (Nat.Prime A) (And (Nat.Prime b) (Eq.{?_uniq.9} Nat (HAdd.hAdd.{?_uniq.12 ?_uniq.11 ?_uniq.10} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) A b) (OfNat.ofNat.{?_uniq.15} Nat 6 (instOfNatNat 6)))))))"
      },
      {
        "success": true,
        "statement": ": ∀ P Q : ℕ, Nat.Prime P → Nat.Prime Q → P + Q ≠ 6 ",
        "code": "forall (P : Nat) (Q : Nat), (Nat.Prime P) -> (Nat.Prime Q) -> (Ne.{?_uniq.10} Nat (HAdd.hAdd.{?_uniq.14 ?_uniq.13 ?_uniq.12} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P Q) (OfNat.ofNat.{0} Nat 6 (instOfNatNat 6)))"
      },
      {
        "success": true,
        "statement": ": ¬ ((2 : ℕ) = (3 : ℕ)) ∧ ¬ ((2 : ℕ) = (3 : ℕ)) ",
        "code": "And (Not (Eq.{?_uniq.1} ?_uniq.20 (OfNat.ofNat.{0} ?_uniq.4 2 ?_uniq.5) (OfNat.ofNat.{0} ?_uniq.15 3 ?_uniq.16))) (Not (Eq.{?_uniq.21} ?_uniq.30 (OfNat.ofNat.{0} ?_uniq.24 2 ?_uniq.25) (OfNat.ofNat.{0} ?_uniq.28 3 ?_uniq.29)))"
      }
    ],
    "number-parsed": 5,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "six_not_prime_sum",
      "search_time": "1.5245796910021454",
      "ret-prompts": [
        {
          "statement": "theorem real.sin_pi_div_six  : real.sin (real.pi / 6) = 1 / 2",
          "sim_score": "0.4190795421600342",
          "doc_string": "The sine of `π / 6` is `1 / 2`."
        },
        {
          "statement": "theorem nat.exists_infinite_primes (n : ℕ) : ∃ (p : ℕ), n ≤ p ∧ nat.prime p",
          "sim_score": "0.41275641322135925",
          "doc_string": " Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`."
        },
        {
          "statement": "theorem nat.prime.sq_add_sq {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) : ∃ (a b : ℕ), a ^ 2 + b ^ 2 = p",
          "sim_score": "0.4100857973098755",
          "doc_string": " **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**."
        },
        {
          "statement": "theorem unique_factorization_monoid.dvd_of_dvd_mul_right_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) (no_factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬prime d) : a ∣ b * c → a ∣ c",
          "sim_score": "0.40865230560302734",
          "doc_string": " Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`. Compare `is_coprime.dvd_of_dvd_mul_right`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The sine of `π / 6` is `1 / 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nreal.sin (real.pi / 6) = 1 / 2 := \n\nNatural language version: \" Euclid's theorem on the **infinitude of primes**. Here given in the form: for every `n`, there exists a prime number `p ≥ n`.\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\n∃ (p : ℕ), n ≤ p ∧ nat.prime p := \n\nNatural language version: \" **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1) :\n∃ (a b : ℕ), a ^ 2 + b ^ 2 = p := \n\nNatural language version: \" Euclid's lemma: if `a ∣ b * c` and `a` and `b` have no common prime factors, `a ∣ c`. Compare `is_coprime.dvd_of_dvd_mul_right`.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) (no_factors : ∀ {d : R}, d ∣ a → d ∣ b → ¬prime d) :\na ∣ b * c → a ∣ c := \n\nNatural language version: \"Six is not the sum of two prime numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Six is not the sum of two prime numbers.",
      "codex_time": "4.61223292798968"
    },
    "grouped": [
      [
        ":\n¬ ∃ (A b : ℕ), Nat.Prime A ∧ Nat.Prime b ∧ A + b = 6 ",
        ":\n¬ ∃ (A b : ℕ), Nat.Prime A ∧ Nat.Prime b ∧ A + b = 6 ",
        ":\n¬ ∃ (A b : ℕ), Nat.Prime A ∧ Nat.Prime b ∧ A + b = 6 "
      ],
      [
        ": ∀ P Q : ℕ, Nat.Prime P → Nat.Prime Q → P + Q ≠ 6 "
      ],
      [
        ": ¬ ((2 : ℕ) = (3 : ℕ)) ∧ ¬ ((2 : ℕ) = (3 : ℕ)) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": ": ¬ (∃ n m: Nat, Prime n ∧ Prime m ∧ n ≠ m ∧ 6 = n + m) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] [hG : is_finitely_generated G] (tfG : Monoid.IsTorsionFree G) : trivial G ",
        "parse-message": "unknown identifier 'is_finitely_generated' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] (F : Fintype G) :\nMonoid.IsTorsionFree G → Fintype.Card G = 1 ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] [Fintype G] :\nMonoid.IsTorsionFree G → ¬ Nontrivial G ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] [finite_group G] (tfG : Monoid.IsTorsionFree G) :\nNontrivial G → False ",
        "parse-message": "unknown identifier 'finite_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} [Group G] [FG : Fintype G] [tfG : Monoid.IsTorsionFree G] : G ≃ ℕ ",
        "parse-message": "unknown constant 'Monoid.IsTorsionFree' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "fin_torsionfree",
      "search_time": "1.4583576289878692",
      "ret-prompts": [
        {
          "statement": "theorem is_torsion_free.subgroup {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) : monoid.is_torsion_free ↥H",
          "sim_score": "0.8230506181716919",
          "doc_string": "Subgroups of torsion-free groups are torsion-free."
        },
        {
          "statement": "theorem is_torsion.not_torsion_free {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion G → ¬monoid.is_torsion_free G",
          "sim_score": "0.8135049939155579",
          "doc_string": "A nontrivial torsion group is not torsion-free."
        },
        {
          "statement": "theorem is_torsion_free.not_torsion {G : Type u_1} [group G] [hN : nontrivial G] : monoid.is_torsion_free G → ¬monoid.is_torsion G",
          "sim_score": "0.8007985353469849",
          "doc_string": "A nontrivial torsion-free group is not torsion."
        },
        {
          "statement": "theorem is_torsion_free.prod {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) : monoid.is_torsion_free (Π (i : η), Gs i)",
          "sim_score": "0.7504584789276123",
          "doc_string": "Direct products of torsion free groups are torsion free."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"Subgroups of torsion-free groups are torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] (tG : monoid.is_torsion_free G) (H : subgroup G) :\nmonoid.is_torsion_free ↥H := \n\nNatural language version: \"A nontrivial torsion group is not torsion-free.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion G → ¬monoid.is_torsion_free G := \n\nNatural language version: \"A nontrivial torsion-free group is not torsion.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] [hN : nontrivial G] :\nmonoid.is_torsion_free G → ¬monoid.is_torsion G := \n\nNatural language version: \"Direct products of torsion free groups are torsion free.\" Translate the natural language version to a Lean mathlib version:\n theorem {η : Type u_1} {Gs : η → Type u_2} [Π (i : η), group (Gs i)] (tfGs : ∀ (i : η), monoid.is_torsion_free (Gs i)) :\nmonoid.is_torsion_free (Π (i : η), Gs i) := \n\nNatural language version: \"A finite torsion-free group is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A finite torsion-free group is trivial",
      "codex_time": "5.388354164984776"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{G: Type _}[Groupₓ G][Finite G] : Monoidₓ.IsTorsionFree G → IsSubgroup.Trivial G "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u_1} [Group α] (F : ℚ → α) [IsAddGroupHom F] : ∃ (n : ℤ), ∀ (x : ℚ), F x = n ",
        "parse-message": "failed to synthesize instance\n  AddGroupₓ α (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [add_comm_group α] [Group α] [CharZero α] (F : ℚ →+ α) : F 0 = 0 ",
        "parse-message": "unknown identifier 'add_comm_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u_1} {n : ℕ} [comm_ring R] [IsPrime n] {h : AddGroup.to_add_group (Units R) ≃* ℤ} :\nh = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{G : Type u_1} {h : Type u_2} [AddGroup G] [SubtractionMonoid h]\n(hom_class : group_hom_class ℚ G h) : trivial h ",
        "parse-message": "unknown identifier 'group_hom_class' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} {β : Type u_2} [AddGroup α] [AddGroup β] [Ring β] (F : α →+ β) :\nF = 0 ↔ ∀ (Q : ℚ), F Q = 0 → Q = 0 ",
        "parse-message": "failed to synthesize instance\n  AddZeroClassₓ α (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "hom_rat_Z_trivial",
      "search_time": "1.5807068219874054",
      "ret-prompts": [
        {
          "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0",
          "sim_score": "0.7258538603782654",
          "doc_string": "An additive group homomorphism is injective if its kernel is trivial."
        },
        {
          "statement": "theorem is_add_group_hom.map_zero {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : f 0 = 0",
          "sim_score": "0.7063751220703125",
          "doc_string": "An additive group homomorphism sends 0 to 0."
        },
        {
          "statement": "theorem map_zsmul {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ℤ) (g : G) : ⇑f (n • g) = n • ⇑f g",
          "sim_score": "0.6773562431335449",
          "doc_string": "Additive group homomorphisms preserve integer scaling."
        },
        {
          "statement": "theorem add_monoid_hom.map_zsmul {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g : α) (n : ℤ) : ⇑f (n • g) = n • ⇑f g",
          "sim_score": "0.6773562431335449",
          "doc_string": "Additive group homomorphisms preserve integer scaling."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"An additive group homomorphism is injective if its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 0 → a = 0 := \n\nNatural language version: \"An additive group homomorphism sends 0 to 0.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nf 0 = 0 := \n\nNatural language version: \"Additive group homomorphisms preserve integer scaling.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_6} {H : Type u_7} {F : Type u_8} [add_group G] [subtraction_monoid H] [add_monoid_hom_class F G H] (f : F) (n : ℤ) (g : G) :\n⇑f (n • g) = n • ⇑f g := \n\nNatural language version: \"Additive group homomorphisms preserve integer scaling.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} {β : Type u_2} [add_group α] [subtraction_monoid β] (f : α →+ β) (g : α) (n : ℤ) :\n⇑f (n • g) = n • ⇑f g := \n\nNatural language version: \"Any homomorphism from the additive group of rational numbers to `ℤ` is trivial\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Any homomorphism from the additive group of rational numbers to `ℤ` is trivial",
      "codex_time": "5.191497617022833"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "(f : ℚ → ℤ) : IsAddGroupHom f →  ∀ x: ℚ, f x = 0 "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "(K : Type u) [DivisionRing K] [Fintype K] :\nfield K ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u} [DivisionRing K] [Fintype K] [DecidableEQ K] :\nfield K ",
        "parse-message": "unknown identifier 'DecidableEQ' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u} [FiniteDimensional K ℤP] [DivisionRing K] :\nfield K ",
        "parse-message": "unknown identifier 'ℤP' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u} [DivisionRing K] (h : Finite K) :\nfield K ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(K : Type u) [DivisionRing K] [Fintype K] :\n@Subfield K (@subfield_le K (Fintype.card_pos K)) ",
        "parse-message": "unknown identifier 'subfield_le' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "fin_int_domain_ring_is_field",
      "search_time": "1.4604721890063956",
      "ret-prompts": [
        {
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s",
          "sim_score": "0.6756068468093872",
          "doc_string": "A subfield is closed under division."
        },
        {
          "statement": "theorem finite_dimensional.finrank_self (K : Type u) [division_ring K] : finite_dimensional.finrank K K = 1",
          "sim_score": "0.6545361280441284",
          "doc_string": "A division_ring is one-dimensional as a vector space over itself."
        },
        {
          "statement": "theorem intermediate_field.div_mem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} : x ∈ S → y ∈ S → x / y ∈ S",
          "sim_score": "0.6345528364181519",
          "doc_string": "An intermediate field is closed under division."
        },
        {
          "statement": "theorem subfield.mul_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x * y ∈ s",
          "sim_score": "0.62082839012146",
          "doc_string": "A subfield is closed under multiplication."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"A division_ring is one-dimensional as a vector space over itself.\" Translate the natural language version to a Lean mathlib version:\n theorem (K : Type u) [division_ring K] :\nfinite_dimensional.finrank K K = 1 := \n\nNatural language version: \"An intermediate field is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u_1} {L : Type u_2} [field K] [field L] [algebra K L] (S : intermediate_field K L) {x y : L} :\nx ∈ S → y ∈ S → x / y ∈ S := \n\nNatural language version: \"A subfield is closed under multiplication.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x * y ∈ s := \n\nNatural language version: \"Every finite division ring is a field.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite division ring is a field.",
      "codex_time": "5.707831264997367"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{R : Type _} [Ringₓ R][IsDomain R] [Finite R] : Field R "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] (h : Nonempty α) (hs : finite_topological_space α) :\nis_compact (Univ : set α) ",
        "parse-message": "unknown identifier 'finite_topological_space' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] (h : (Fintype α)) :\nis_compact α ",
        "parse-message": "unknown identifier 'is_compact' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] (h₁ : Finite α) :\nis_compact α ",
        "parse-message": "unknown identifier 'is_compact' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] (hαF : Fintype α) : is_compact α ",
        "parse-message": "unknown identifier 'is_compact' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] (hα : Nonempty α) : is_compact α ",
        "parse-message": "unknown identifier 'is_compact' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "finite_space_compact",
      "search_time": "1.4795987970137503",
      "ret-prompts": [
        {
          "statement": "theorem is_compact_of_finite_subcover {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) : is_compact s",
          "sim_score": "0.676864504814148",
          "doc_string": "A set `s` is compact if for every open cover of `s`, there exists a finite subcover."
        },
        {
          "statement": "theorem is_compact.elim_finite_subcover_image {α : Type u} {ι : Type u_1} [topological_space α] {s : set α} {b : set ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), i ∈ b → is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) : ∃ (b' : set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i",
          "sim_score": "0.6767893433570862",
          "doc_string": "For every open cover of a compact set, there exists a finite subcover."
        },
        {
          "statement": "theorem is_compact.elim_finite_subcover {α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) : ∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i",
          "sim_score": "0.6767893433570862",
          "doc_string": "For every open cover of a compact set, there exists a finite subcover."
        },
        {
          "statement": "theorem is_compact_iff_finite_subcover {α : Type u} [topological_space α] {s : set α} : is_compact s ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)",
          "sim_score": "0.65172278881073",
          "doc_string": " A set `s` is compact if and only if for every open cover of `s`, there exists a finite subcover."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A set `s` is compact if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s : set α} (h : ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)) :\nis_compact s := \n\nNatural language version: \"For every open cover of a compact set, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {ι : Type u_1} [topological_space α] {s : set α} {b : set ι} {c : ι → set α} (hs : is_compact s) (hc₁ : ∀ (i : ι), i ∈ b → is_open (c i)) (hc₂ : s ⊆ ⋃ (i : ι) (H : i ∈ b), c i) :\n∃ (b' : set ι) (H : b' ⊆ b), b'.finite ∧ s ⊆ ⋃ (i : ι) (H : i ∈ b'), c i := \n\nNatural language version: \"For every open cover of a compact set, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s : set α} {ι : Type v} (hs : is_compact s) (U : ι → set α) (hUo : ∀ (i : ι), is_open (U i)) (hsU : s ⊆ ⋃ (i : ι), U i) :\n∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i := \n\nNatural language version: \" A set `s` is compact if and only if for every open cover of `s`, there exists a finite subcover.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s : set α} :\nis_compact s ↔ ∀ {ι : Type u} (U : ι → set α), (∀ (i : ι), is_open (U i)) → (s ⊆ ⋃ (i : ι), U i) → (∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i) := \n\nNatural language version: \"Every finite topological space is compact\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every finite topological space is compact",
      "codex_time": "6.1293448169890326"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{X : Type _}[TopologicalSpace X][Finite X] : CompactSpace X "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u} {β : Type v} [Group β] {F : free_group α →* β} (hf : Function.Surjective ⇑F) :\nFunction.Injective ⇑F ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} {G : Type u_1} [Group G] (F : free_group α →* G) (hf : Function.Surjective ⇑F) :\nFunction.Injective ⇑F ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} {G : free_group α} (h : ∃ s : set α, Finite s ∧ G = Closure s) {h' : Type u_1} [Group h'] (F : G →* h') (hf : Function.Surjective ⇑F) :\nFunction.Injective ⇑F ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} [Fintype α] {F : free_group α →* free_group α} (hf : Function.Surjective ⇑F) :\nFunction.Injective F ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} {G : Type u_1} [Group G] (F : free_group α →* G) (h₁ : Function.Surjective F) (h₂ : ∃ (t : Finset α), is_basis ↑t) :\nFunction.Injective F ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "freegroup_hopfian",
      "search_time": "1.483718688978115",
      "ret-prompts": [
        {
          "statement": "theorem free_group.of_injective {α : Type u} : function.injective free_group.of",
          "sim_score": "0.6470739841461182",
          "doc_string": "The canonical injection from the type to the free group is an injection."
        },
        {
          "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1",
          "sim_score": "0.6357327103614807",
          "doc_string": "A group homomorphism is injective iff its kernel is trivial."
        },
        {
          "statement": "theorem free_group.ext_hom {α : Type u} {G : Type u_1} [group G] (f g : free_group α →* G) (h : ∀ (a : α), ⇑f (free_group.of a) = ⇑g (free_group.of a)) : f = g",
          "sim_score": "0.5912977457046509",
          "doc_string": " Two homomorphisms out of a free group are equal if they are equal on generators.  See note [partially-applied ext lemmas]."
        },
        {
          "statement": "theorem nilpotent_of_surjective {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) : group.is_nilpotent G'",
          "sim_score": "0.5858901143074036",
          "doc_string": "The range of a surjective homomorphism from a nilpotent group is nilpotent"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The canonical injection from the type to the free group is an injection.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} :\nfunction.injective free_group.of := \n\nNatural language version: \"A group homomorphism is injective iff its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 1 → a = 1 := \n\nNatural language version: \" Two homomorphisms out of a free group are equal if they are equal on generators.  See note [partially-applied ext lemmas].\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {G : Type u_1} [group G] (f g : free_group α →* G) (h : ∀ (a : α), ⇑f (free_group.of a) = ⇑g (free_group.of a)) :\nf = g := \n\nNatural language version: \"The range of a surjective homomorphism from a nilpotent group is nilpotent\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u_1} [group G] {G' : Type u_2} [group G'] [h : group.is_nilpotent G] (f : G →* G') (hf : function.surjective ⇑f) :\ngroup.is_nilpotent G' := \n\nNatural language version: \"Every surjective homomorphism from a finitely generated free group to itself is injective\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every surjective homomorphism from a finitely generated free group to itself is injective",
      "codex_time": "4.3753448179923"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{α : Type _} [Finite α]: (f: FreeGroup α → FreeGroup α) → (IsGroupHom f) → f.Surjective → f.Injective "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u_1} [discrete_linear_ordered_field α] (P : Polynomial α) :\n0 < P.degree → ∃ (u v : α), u < v ∧ ∀ (n : ℕ),\n(Polynomial.eval_on P v) n > n ",
        "parse-message": "unknown identifier 'discrete_linear_ordered_field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(P : ℝ[x]) :\nis_unbounded_left (set P.Range) ",
        "parse-message": "function expected at\n  ℝ\nterm has type\n  Type (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [LinearOrderedField R] (P : Polynomial R) (hp : 0 < P.nat_degree) :\n∃ x, ∀ y, y < P.nat_degree → ∃ c, P.Eval ⟨y, h.lt_succ_self y⟩ ≤ c * P.Eval ⟨x, h.lt_succ_self x⟩ ",
        "parse-message": "invalid field 'nat_degree', the environment does not contain 'Polynomial.nat_degree'\n  P\nhas type\n  R[X] (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_3} [discrete_field α] (F : Polynomial α) (hf : 0 < F.degree) :\n∃ (P : P(ℝ)) (Q : ℝ), ∀ n : ℝ, n ≥ P → (Abs(Polynomial.Eval n F)) ≥ Q ",
        "parse-message": "<input>:2:8: expected ')'"
      },
      {
        "success": false,
        "statement": "{α : Type u_4} [decidable_linear_ordered_comm_ring α] {P : Polynomial α} (hp : 0 < P.degree) :\n¬ (BddAbove (Polynomial.Range P.coeff_multiset)) ",
        "parse-message": "unknown universe level 'u_4' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "polys_unbounded",
      "search_time": "1.4346691030077636",
      "ret-prompts": [
        {
          "statement": "theorem continuous_map_mem_polynomial_functions_closure (a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) : f ∈ (polynomial_functions (set.Icc a b)).topological_closure",
          "sim_score": "0.5175106525421143",
          "doc_string": "An alternative statement of Weierstrass' theorem.  Every real-valued continuous function on `[a,b]` is a uniform limit of polynomials."
        },
        {
          "statement": "theorem polynomial.degree_multiset_prod_le {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) : t.prod.degree ≤ (multiset.map polynomial.degree t).sum",
          "sim_score": "0.5134747624397278",
          "doc_string": "The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥."
        },
        {
          "statement": "theorem polynomial_functions_closure_eq_top (a b : ℝ) : (polynomial_functions (set.Icc a b)).topological_closure = ⊤",
          "sim_score": "0.5014804005622864",
          "doc_string": "The **Weierstrass Approximation Theorem**: polynomials functions on `[a, b] ⊆ ℝ` are dense in `C([a,b],ℝ)`  (While we could deduce this as an application of the Stone-Weierstrass theorem, our proof of that relies on the fact that `abs` is in the closure of polynomials on `[-M, M]`, so we may as well get this done first.)"
        },
        {
          "statement": "theorem filter.tendsto_pow_at_top {α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top",
          "sim_score": "0.48543989658355713",
          "doc_string": " The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"An alternative statement of Weierstrass' theorem.  Every real-valued continuous function on `[a,b]` is a uniform limit of polynomials.\" Translate the natural language version to a Lean mathlib version:\n theorem (a b : ℝ) (f : C(↥(set.Icc a b), ℝ)) :\nf ∈ (polynomial_functions (set.Icc a b)).topological_closure := \n\nNatural language version: \"The degree of a product of polynomials is at most the sum of the degrees, where the degree of the zero polynomial is ⊥.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_semiring R] (t : multiset (polynomial R)) :\nt.prod.degree ≤ (multiset.map polynomial.degree t).sum := \n\nNatural language version: \"The **Weierstrass Approximation Theorem**: polynomials functions on `[a, b] ⊆ ℝ` are dense in `C([a,b],ℝ)`  (While we could deduce this as an application of the Stone-Weierstrass theorem, our proof of that relies on the fact that `abs` is in the closure of polynomials on `[-M, M]`, so we may as well get this done first.)\" Translate the natural language version to a Lean mathlib version:\n theorem (a b : ℝ) :\n(polynomial_functions (set.Icc a b)).topological_closure = ⊤ := \n\nNatural language version: \" The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`. A version for positive real powers exists as `tendsto_rpow_at_top`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) :\nfilter.tendsto (λ (x : α), x ^ n) filter.at_top filter.at_top := \n\nNatural language version: \"Every polynomial of positive degree over reals is unbounded.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every polynomial of positive degree over reals is unbounded.",
      "codex_time": "8.425400767999236"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "(p: Polynomial ℝ) : p.degree > 0 → ∀ m: ℝ, ∃ x: ℝ, p.eval x  > m ∨ p.eval x < -m  "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{F : Type u} {F₂ : Type v} [field F] [field F₂] {τ : F →+* F₂} (h : ∀ (u v : ↥(τ.Ker) →ₗ[F] F),\nτ.Comp u = τ.Comp v → u = v) : Function.Injective τ ∨ τ = 0 ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} {β : Type v} [field α] [field β] {F : α →+* β} :\nFunction.Injective F ∨ F = 0 ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u} {L : Type v} [field K] [field L] {F : K →+* L} : Function.Injective F ∨ F = 0 ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u_1} (L : Type v_1) [field K] [field L] {F : K →+* L} (hf : RingHom F) :\nSetoid.Injective F ⊕ ∀ (A : K), F A = 0 ",
        "parse-message": "unknown universe level 'v_1' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} {β : Type v} [field α] [field β] {F : α → β} (hf : IsMonoidHom F) :\nFunction.Injective F ∨ ∀ (A : α), F A = 0 ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "field_hom_inj_or_trivial",
      "search_time": "1.4474918549822178",
      "ret-prompts": [
        {
          "statement": "theorem is_group_hom.injective_iff {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 1 → a = 1",
          "sim_score": "0.6868539452552795",
          "doc_string": "A group homomorphism is injective iff its kernel is trivial."
        },
        {
          "statement": "theorem ring_hom.eq_on_field_closure {K : Type u} {L : Type v} [field K] [field L] {f g : K →+* L} {s : set K} (h : set.eq_on ⇑f ⇑g s) : set.eq_on ⇑f ⇑g ↑(subfield.closure s)",
          "sim_score": "0.6491084694862366",
          "doc_string": "If two ring homomorphisms are equal on a set, then they are equal on its subfield closure."
        },
        {
          "statement": "theorem linear_map.ker_eq_bot_of_cancel {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [semiring R] [semiring R₂] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) : f.ker = ⊥",
          "sim_score": "0.6350299715995789",
          "doc_string": "A monomorphism is injective."
        },
        {
          "statement": "theorem is_add_group_hom.injective_iff {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) : function.injective f ↔ ∀ (a : α), f a = 0 → a = 0",
          "sim_score": "0.6343168020248413",
          "doc_string": "An additive group homomorphism is injective if its kernel is trivial."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A group homomorphism is injective iff its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [group α] [group β] {f : α → β} (hf : is_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 1 → a = 1 := \n\nNatural language version: \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} {L : Type v} [field K] [field L] {f g : K →+* L} {s : set K} (h : set.eq_on ⇑f ⇑g s) :\nset.eq_on ⇑f ⇑g ↑(subfield.closure s) := \n\nNatural language version: \"A monomorphism is injective.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [semiring R] [semiring R₂] [add_comm_monoid M] [add_comm_monoid M₂] [module R M] [module R₂ M₂] {τ₁₂ : R →+* R₂} {f : M →ₛₗ[τ₁₂] M₂} (h : ∀ (u v : ↥(f.ker) →ₗ[R] M), f.comp u = f.comp v → u = v) :\nf.ker = ⊥ := \n\nNatural language version: \"An additive group homomorphism is injective if its kernel is trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [add_group α] [add_group β] {f : α → β} (hf : is_add_group_hom f) :\nfunction.injective f ↔ ∀ (a : α), f a = 0 → a = 0 := \n\nNatural language version: \"A homomorphism between fields is either injective or trivial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A homomorphism between fields is either injective or trivial.",
      "codex_time": "9.296392163989367"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{F F' : Type _} [Field F] [Field F'] : ∀ ϕ : F →+* F', ϕ.toFun.Injective ∨ (∀ x : F, ϕ x = 0) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] (h : IsNoetherian R m) (F : ℕ →o Submodule R m) :\n∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑F n = ⇑F m ",
        "parse-message": "unknown identifier 'module' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] :\nIsNoetherian R m → ∀ (F : ℕ →o Submodule R m), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑F n = ⇑F m ",
        "parse-message": "unknown identifier 'module' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] (h : IsNoetherian R m) (F : ℕ → Submodule R m) :\n∃ (n : ℕ) (x y : Submodule R m), ∀ (m : ℕ), n ≤ m → x = y ",
        "parse-message": "unknown identifier 'module' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] (F : ℕ →o Submodule R m) (hf : ∀ (D : ℕ), (F D).Fg) :\n¬({n : ℕ // F n < F (n + 1)} ≠ ∅)\n\nNatural Language version: \"Every descending Chain of sub-modules of an Artinian module eventually stabilises.\" Translate the natural Language version to A Lean mathlib version:\n theorem {R : Type u_1} {m : Type u_2} [Semiring R",
        "parse-message": "<input>:4:24: expected end of input"
      },
      {
        "success": false,
        "statement": "{R : Type u_1} {m : Type u_2} [Semiring R] [AddCommMonoid m] [module R m] (h : IsNoetherian R m) (F : ℕ →o Submodule R m) :\n∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑F n = ⇑F m ",
        "parse-message": "unknown identifier 'module' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "noetherian_implies_ascending_chain_condition",
      "search_time": "1.4521226090146229",
      "ret-prompts": [
        {
          "statement": "theorem monotone_stabilizes_iff_noetherian {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : (∀ (f : ℕ →o submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_noetherian R M",
          "sim_score": "0.9016166925430298",
          "doc_string": "A module is Noetherian iff every increasing chain of submodules stabilizes."
        },
        {
          "statement": "theorem monotone_stabilizes_iff_artinian {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] : (∀ (f : ℕ →o (submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_artinian R M",
          "sim_score": "0.7797067761421204",
          "doc_string": "A module is Artinian iff every decreasing chain of submodules stabilizes."
        },
        {
          "statement": "theorem well_founded_gt_exact_sequence {α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [preorder β] [partial_order γ] (h₁ : well_founded gt) (h₂ : well_founded gt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) : well_founded gt",
          "sim_score": "0.698657751083374",
          "doc_string": "A generalization of the theorem that if `N` is a submodule of `M` and  `N` and `M / N` are both Noetherian, then `M` is Noetherian."
        },
        {
          "statement": "theorem is_noetherian_def {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] : is_noetherian R M ↔ ∀ (s : submodule R M), s.fg",
          "sim_score": "0.6557018756866455",
          "doc_string": "An R-module is Noetherian iff all its submodules are finitely-generated."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A module is Noetherian iff every increasing chain of submodules stabilizes.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] :\n(∀ (f : ℕ →o submodule R M), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_noetherian R M := \n\nNatural language version: \"A module is Artinian iff every decreasing chain of submodules stabilizes.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [ring R] [add_comm_group M] [module R M] :\n(∀ (f : ℕ →o (submodule R M)ᵒᵈ), ∃ (n : ℕ), ∀ (m : ℕ), n ≤ m → ⇑f n = ⇑f m) ↔ is_artinian R M := \n\nNatural language version: \"A generalization of the theorem that if `N` is a submodule of `M` and  `N` and `M / N` are both Noetherian, then `M` is Noetherian.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} [lattice α] [is_modular_lattice α] {β : Type u_2} {γ : Type u_3} [preorder β] [partial_order γ] (h₁ : well_founded gt) (h₂ : well_founded gt) (K : α) (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : galois_coinsertion f₁ f₂) (gi : galois_insertion g₂ g₁) (hf : ∀ (a : α), f₁ (f₂ a) = a ⊓ K) (hg : ∀ (a : α), g₁ (g₂ a) = a ⊔ K) :\nwell_founded gt := \n\nNatural language version: \"An R-module is Noetherian iff all its submodules are finitely-generated.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [semiring R] [add_comm_monoid M] [module R M] :\nis_noetherian R M ↔ ∀ (s : submodule R M), s.fg := \n\nNatural language version: \"Every ascending chain of sub-modules of a Noetherian module eventually stabilises.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every ascending chain of sub-modules of a Noetherian module eventually stabilises.",
      "codex_time": "11.324376939010108"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{R M : Type _} [Ringₓ R] [AddCommMonoidₓ M] [Module R M] : IsNoetherian R M → ∀ (f : ℕ →o Submodule R M), ∃ n : ℕ, ∀ m : ℕ, n < m → f n = f m "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : set ℝ} {A : ℝ} {F : ℝ → E} (f_diff : DifferentiableOn ℝ F s) (ha : A ∈ s) :\nContinuousOn ℝ F (set.icc A a) ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {F : ℝ → E} {A : ℝ} (hf : DifferentiableAt ℝ F A) :\nContinuousAt F A ",
        "parse-message": "type class instance expected\n  Valued ℝ ?m.440 (during elaboration)"
      },
      {
        "success": false,
        "statement": "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {s : set ℝ} {A : ℝ} {F : ℝ → E} (hf : ∀ (x : ℝ), x ∈ s → HasDerivAt F (F x)) (hs : is_open s)\n(hf' : continuous_restrict (Finsupp.total (Univ : Finset ℝ) F) s) :\nContinuous (Finsupp.total (Univ : Finset ℝ) F) ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{E : Type u_1} [NormedGroup E] [NormedSpace ℝ E] {A : ℝ} {F : ℝ → E} (hn : is_deriv_at F A) :\nContinuousAt F A ",
        "parse-message": "unknown identifier 'is_deriv_at' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] [MetricSpace α] {β : Type v} {F : α → β} {x : α} (hf : DifferentiableAt α β F x) :\nContinuousAt F x ",
        "parse-message": "failed to synthesize instance\n  NondiscreteNormedField α (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "differentiability_implies_continuity",
      "search_time": "1.4399381499970332",
      "ret-prompts": [
        {
          "statement": "theorem continuous_at_of_locally_lipschitz {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), has_dist.dist y x < r → has_dist.dist (f y) (f x) ≤ K * has_dist.dist y x) : continuous_at f x",
          "sim_score": "0.6264367699623108",
          "doc_string": "If a function is locally Lipschitz around a point, then it is continuous at this point."
        },
        {
          "statement": "theorem has_deriv_at_interval_left_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) : has_deriv_within_at f e (set.Ici a) a",
          "sim_score": "0.6016049981117249",
          "doc_string": " If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the right at `a`."
        },
        {
          "statement": "theorem has_deriv_at_interval_right_endpoint_of_tendsto_deriv {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) : has_deriv_within_at f e (set.Iic a) a",
          "sim_score": "0.5962556600570679",
          "doc_string": " If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the left at `a`."
        },
        {
          "statement": "theorem lipschitz_with.continuous {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) : continuous f",
          "sim_score": "0.5795943737030029",
          "doc_string": "A Lipschitz function is continuous"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"If a function is locally Lipschitz around a point, then it is continuous at this point.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] {f : α → β} {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ) (h : ∀ (y : α), has_dist.dist y x < r → has_dist.dist (f y) (f x) ≤ K * has_dist.dist y x) :\ncontinuous_at f x := \n\nNatural language version: \" If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the right at `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Ioi a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Ioi a)) (nhds e)) :\nhas_deriv_within_at f e (set.Ici a) a := \n\nNatural language version: \" If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and its derivative also converges at `a`, then `f` is differentiable on the left at `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {E : Type u_1} [normed_group E] [normed_space ℝ E] {s : set ℝ} {e : E} {a : ℝ} {f : ℝ → E} (f_diff : differentiable_on ℝ f s) (f_lim : continuous_within_at f s a) (hs : s ∈ nhds_within a (set.Iio a)) (f_lim' : filter.tendsto (λ (x : ℝ), deriv f x) (nhds_within a (set.Iio a)) (nhds e)) :\nhas_deriv_within_at f e (set.Iic a) a := \n\nNatural language version: \"A Lipschitz function is continuous\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {β : Type v} [pseudo_emetric_space α] [pseudo_emetric_space β] {K : nnreal} {f : α → β} (hf : lipschitz_with K f) :\ncontinuous f := \n\nNatural language version: \"Differentiability implies continuity.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Differentiability implies continuity.",
      "codex_time": "13.302136803016765"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "[TopologicalSpace ℝ] : ∀ f : ℝ → ℝ, Differentiable ℝ f → Continuous f "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{V : Type u_1} [InnerProductSpace ℝ V] {x y z : V} (h : InnerProductGeometry.Angle x y + InnerProductGeometry.Angle y z + InnerProductGeometry.Angle z x = 2 * Real.Pi) :\nTrue ",
        "parse-message": "unknown identifier 'InnerProductGeometry.Angle' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{V : Type u_1} [InnerProductSpace ℝ V] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] {o : Orientation ℝ V (Fin 2)} {P1 P2 P3 : V} (h1 : Angle P1 P2 P3 < Angle P2 P3 P1) :\no.oangle P1 P2 + o.oangle P2 P3 + o.oangle P3 P1 = 2 ",
        "parse-message": "unknown identifier 'Angle' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{V : Type u_1} [InnerProductSpace ℝ V] {b : Basis (Fin 2) ℝ V} (hb : Orthonormal ℝ ⇑b) {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\nhb.oangle x (hb.orthoproj (x + y)) + hb.oangle y (-hb.orthoproj (x + y)) = ↑Real.Pi ",
        "parse-message": "invalid field 'orthoproj', the environment does not contain 'And.orthoproj'\n  hb\nhas type\n  (∀ (i : Fin 2), ∥coeFn b i∥ = One.one) ∧ ∀ {i j : Fin 2}, i ≠ j → inner (coeFn b i) (coeFn b j) = Zero.zero (during elaboration)"
      },
      {
        "success": false,
        "statement": "{V : Type u_1} [InnerProductSpace ℝ V] [hd3 : Fact (FiniteDimensional.finrank ℝ V = 3)] (o : Orientation ℝ V (Fin 3)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\no.oangle x y + o.oangle y z + o.oangle z x = ↑Real.Pi * 2 ",
        "parse-message": "failed to synthesize instance\n  Fact (FiniteDimensional.finrank ℝ V = bit0 One.one) (during elaboration)"
      },
      {
        "success": false,
        "statement": "{V : Type u_1} {P : Type u_2} [InnerProductSpace ℝ V] [NormedAddTorsor V P] {P1 P2 P3 P5 : P} :\n2*EuclideanGeometry.Angle P1 P5 P3 + 2*EuclideanGeometry.Angle P2 P5 P3 + 2*EuclideanGeometry.Angle P1 P5 P2 = 2*Real.Pi ",
        "parse-message": "failed to synthesize instance\n  PseudoMetricSpace P (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "angle_sum_pi",
      "search_time": "1.4687023029837292",
      "ret-prompts": [
        {
          "statement": "theorem inner_product_geometry.angle_add_angle_eq_pi_of_angle_eq_pi {V : Type u_1} [inner_product_space ℝ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) : inner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi",
          "sim_score": "0.5743768215179443",
          "doc_string": " If the angle between two vectors is π, the angles between those vectors and a third vector add to π."
        },
        {
          "statement": "theorem euclidean_geometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) : euclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4",
          "sim_score": "0.5685725212097168",
          "doc_string": " Vertical Angles Theorem: angles opposite each other, formed by two intersecting straight lines, are equal."
        },
        {
          "statement": "theorem orthonormal.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : hb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑real.pi",
          "sim_score": "0.5616596937179565",
          "doc_string": " Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle."
        },
        {
          "statement": "theorem orientation.oangle_add_cyc3_neg_right {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑real.pi",
          "sim_score": "0.5616596937179565",
          "doc_string": " Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If the angle between two vectors is π, the angles between those vectors and a third vector add to π.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_1} [inner_product_space ℝ V] {x y : V} (z : V) (h : inner_product_geometry.angle x y = real.pi) :\ninner_product_geometry.angle x z + inner_product_geometry.angle y z = real.pi := \n\nNatural language version: \" Vertical Angles Theorem: angles opposite each other, formed by two intersecting straight lines, are equal.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_1} {P : Type u_2} [inner_product_space ℝ V] [metric_space P] [normed_add_torsor V P] {p1 p2 p3 p4 p5 : P} (hapc : euclidean_geometry.angle p1 p5 p3 = real.pi) (hbpd : euclidean_geometry.angle p2 p5 p4 = real.pi) :\neuclidean_geometry.angle p1 p5 p2 = euclidean_geometry.angle p3 p5 p4 := \n\nNatural language version: \" Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_1} [inner_product_space ℝ V] {b : basis (fin 2) ℝ V} (hb : orthonormal ℝ ⇑b) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\nhb.oangle x (-y) + hb.oangle y (-z) + hb.oangle z (-x) = ↑real.pi := \n\nNatural language version: \" Given three nonzero vectors, adding the angles between them in cyclic order, with the second vector in each angle negated, results in π. If the vectors add to 0, this is a version of the sum of the angles of a triangle.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_1} [inner_product_space ℝ V] [hd2 : fact (finite_dimensional.finrank ℝ V = 2)] (o : orientation ℝ V (fin 2)) {x y z : V} (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0) :\no.oangle x (-y) + o.oangle y (-z) + o.oangle z (-x) = ↑real.pi := \n\nNatural language version: \"The angles of a triangle add up to two right angles.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The angles of a triangle add up to two right angles.",
      "codex_time": "11.767082732985727"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{p q r : EuclideanSpace ℝ (Finₓ 2)} : EuclideanGeometry.angle p q r + EuclideanGeometry.angle q r p + EuclideanGeometry.angle r p q = Real.pi "
  },
  {
    "parsed": [
      "{n : ℕ}(hn : n ≠ 0) :\n∃ P Q : ℕ, P + Q = n ∧ (Fact (Prime P)) ∧ (Fact (Prime Q)) ∧ (Even n) ",
      "(n P Q : ℕ) (h : 0 < n ∧ n % 2 = 0) :\nn = P + Q ∧ (Nat.Prime P) ∧ (Nat.Prime Q) ",
      "(n : ℕ) (h : n ≥ 2 ∧ n % 2 = 0) :\n∃ P Q : ℕ, Nat.Prime P ∧ Nat.Prime Q ∧ P + Q = n "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "(P : ℕ) (hp : P ≥ 2):\n∃P1 P2 : ℕ, \n  P1.nat_prime ∧ P2.nat_prime ∧ P1 + P2 = P ",
        "parse-message": "invalid field 'nat_prime', the environment does not contain 'Nat.nat_prime'\n  P1\nhas type\n  ℕ (during elaboration)"
      },
      {
        "success": true,
        "statement": "{n : ℕ}(hn : n ≠ 0) :\n∃ P Q : ℕ, P + Q = n ∧ (Fact (Prime P)) ∧ (Fact (Prime Q)) ∧ (Even n) ",
        "code": "forall {n : Nat}, (Ne.{?_uniq.5} Nat n (OfNat.ofNat.{0} Nat 0 (instOfNatNat 0))) -> (Exists.{?_uniq.20} Nat (fun (P : Nat) => Exists.{?_uniq.24} Nat (fun (Q : Nat) => And (Eq.{?_uniq.28} Nat (HAdd.hAdd.{?_uniq.31 ?_uniq.30 ?_uniq.29} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P Q) n) (And (Fact (Prime.{?_uniq.59} Nat (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) P)) (And (Fact (Prime.{?_uniq.74} Nat (LinearOrderedCommMonoidWithZero.toCommMonoidWithZero.{0} Nat Nat.linearOrderedCommMonoidWithZero) Q)) (Even.{?_uniq.77} Nat Nat.hasAdd n))))))"
      },
      {
        "success": false,
        "statement": "(n : ℕ) (h : n > 0) : ∃ A b : (Nat.Prime A) ∧ (Nat.Prime b) ",
        "parse-message": "<input>:1:60: unexpected end of input; expected ','"
      },
      {
        "success": true,
        "statement": "(n P Q : ℕ) (h : 0 < n ∧ n % 2 = 0) :\nn = P + Q ∧ (Nat.Prime P) ∧ (Nat.Prime Q) ",
        "code": "forall (n : Nat) (P : Nat) (Q : Nat), (And (LT.lt.{?_uniq.9} Nat Nat.hasLt (OfNat.ofNat.{?_uniq.12} Nat 0 (instOfNatNat 0)) n) (Eq.{?_uniq.45} Nat (HMod.hMod.{?_uniq.48 ?_uniq.47 ?_uniq.46} Nat Nat Nat (instHMod.{?_uniq.121} Nat Nat.hasMod) n (OfNat.ofNat.{?_uniq.47} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.81} Nat 0 (instOfNatNat 0)))) -> (And (Eq.{?_uniq.135} Nat n (HAdd.hAdd.{?_uniq.138 ?_uniq.137 ?_uniq.136} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P Q)) (And (Nat.Prime P) (Nat.Prime Q)))"
      },
      {
        "success": true,
        "statement": "(n : ℕ) (h : n ≥ 2 ∧ n % 2 = 0) :\n∃ P Q : ℕ, Nat.Prime P ∧ Nat.Prime Q ∧ P + Q = n ",
        "code": "forall (n : Nat), (And (GE.ge.{?_uniq.5} Nat Nat.hasLe n (OfNat.ofNat.{?_uniq.8} Nat 2 (instOfNatNat 2))) (Eq.{?_uniq.33} Nat (HMod.hMod.{?_uniq.36 ?_uniq.35 ?_uniq.34} Nat Nat Nat (instHMod.{?_uniq.109} Nat Nat.hasMod) n (OfNat.ofNat.{?_uniq.35} Nat 2 (instOfNatNat 2))) (OfNat.ofNat.{?_uniq.69} Nat 0 (instOfNatNat 0)))) -> (Exists.{?_uniq.124} Nat (fun (P : Nat) => Exists.{?_uniq.128} Nat (fun (Q : Nat) => And (Nat.Prime P) (And (Nat.Prime Q) (Eq.{?_uniq.132} Nat (HAdd.hAdd.{?_uniq.135 ?_uniq.134 ?_uniq.133} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) P Q) n)))))"
      }
    ],
    "number-parsed": 3,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "goldbach",
      "search_time": "1.493072356999619",
      "ret-prompts": [
        {
          "statement": "theorem nat.prime.mod_two_eq_one_iff_ne_two {p : ℕ} [fact (nat.prime p)] : p % 2 = 1 ↔ p ≠ 2",
          "sim_score": "0.5331833362579346",
          "doc_string": "A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`."
        },
        {
          "statement": "theorem nat.mem_factors_mul_left {p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) : p ∈ (a * b).factors",
          "sim_score": "0.48720940947532654",
          "doc_string": "If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0`"
        },
        {
          "statement": "theorem nat.factorization_inj  : set.inj_on nat.factorization {x : ℕ | x ≠ 0}",
          "sim_score": "0.48647668957710266",
          "doc_string": "Every nonzero natural number has a unique prime factorization"
        },
        {
          "statement": "theorem nat.factorization_eq_zero_iff (n : ℕ) : n.factorization = 0 ↔ n = 0 ∨ n = 1",
          "sim_score": "0.4829321801662445",
          "doc_string": "The only numbers with empty prime factorization are `0` and `1`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`.\" Translate the natural language version to a Lean mathlib version:\n theorem {p : ℕ} [fact (nat.prime p)] :\np % 2 = 1 ↔ p ≠ 2 := \n\nNatural language version: \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0`\" Translate the natural language version to a Lean mathlib version:\n theorem {p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0) :\np ∈ (a * b).factors := \n\nNatural language version: \"Every nonzero natural number has a unique prime factorization\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nset.inj_on nat.factorization {x : ℕ | x ≠ 0} := \n\nNatural language version: \"The only numbers with empty prime factorization are `0` and `1`\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\nn.factorization = 0 ↔ n = 0 ∨ n = 1 := \n\nNatural language version: \"Every positive even integer can be written as the sum of two primes.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every positive even integer can be written as the sum of two primes.",
      "codex_time": "5.843470266001532"
    },
    "grouped": [
      [
        "{n : ℕ}(hn : n ≠ 0) :\n∃ P Q : ℕ, P + Q = n ∧ (Fact (Prime P)) ∧ (Fact (Prime Q)) ∧ (Even n) "
      ],
      [
        "(n P Q : ℕ) (h : 0 < n ∧ n % 2 = 0) :\nn = P + Q ∧ (Nat.Prime P) ∧ (Nat.Prime Q) "
      ],
      [
        "(n : ℕ) (h : n ≥ 2 ∧ n % 2 = 0) :\n∃ P Q : ℕ, Nat.Prime P ∧ Nat.Prime Q ∧ P + Q = n "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ n : ℕ, n > 0 → Even n → ∃ p q : ℕ, Prime p → Prime q → n = p + q "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] {n : Type W} [DecidableEQ n] [Fintype n] (m : Matrix n n R) :\nm.CharPoly.Eval₂ m = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] {n : Type v} [DecidableEQ n] [Fintype n] (m : Matrix n n R) (P : Polynomial R) :\nP = 0 ∨ P = m.CharPoly ↔ (P %ₘ m.CharPoly).Eval m = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] {n : Type v} [DecidableEQ n] [Fintype n] (m : Matrix n n R) :\nm.CharPoly.Eval m = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] (m : integral_domain R) {n : Type v} [DecidableEQ n] [Fintype n] (m : Matrix n n R) :\nm.CharPoly.Eval m 0 = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] {n : Type v} [DecidableEQ n] [Fintype n] (m : Matrix n n R) {P : Polynomial R} :\nm.CharPoly = P ↔ matrix_mx R m (P.Eval₂ = *(≠)) m ",
        "parse-message": "<input>:2:42: expected term"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "cayley_hamilton",
      "search_time": "1.4968492100015283",
      "ret-prompts": [
        {
          "statement": "theorem linear_map.aeval_self_charpoly {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) : ⇑(polynomial.aeval f) f.charpoly = 0",
          "sim_score": "0.7601779699325562",
          "doc_string": " The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices."
        },
        {
          "statement": "theorem matrix.aeval_self_charpoly {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) : ⇑(polynomial.aeval M) M.charpoly = 0",
          "sim_score": "0.6756272315979004",
          "doc_string": "The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms."
        },
        {
          "statement": "theorem linear_map.charpoly_to_matrix {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) : (⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly",
          "sim_score": "0.5441092252731323",
          "doc_string": "`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis."
        },
        {
          "statement": "theorem matrix.aeval_eq_aeval_mod_charpoly {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) : ⇑(polynomial.aeval M) p = ⇑(polynomial.aeval M) (p %ₘ M.charpoly)",
          "sim_score": "0.5268839001655579",
          "doc_string": " Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p` is equivalent to a polynomial with degree less than the dimension of the matrix."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a linear map, applied to the linear map itself, is zero.  See `matrix.aeval_self_charpoly` for the equivalent statement about matrices.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) :\n⇑(polynomial.aeval f) f.charpoly = 0 := \n\nNatural language version: \"The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix, applied to the matrix itself, is zero.  This holds over any commutative ring.  See `linear_map.aeval_self_charpoly` for the equivalent statement about endomorphisms.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] {n : Type w} [decidable_eq n] [fintype n] (M : matrix n n R) :\n⇑(polynomial.aeval M) M.charpoly = 0 := \n\nNatural language version: \"`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} {M : Type v} [comm_ring R] [nontrivial R] [add_comm_group M] [module R M] [module.free R M] [module.finite R M] (f : M →ₗ[R] M) {ι : Type w} [fintype ι] (b : basis ι R M) :\n(⇑(linear_map.to_matrix b b) f).charpoly = f.charpoly := \n\nNatural language version: \" Any matrix polynomial `p` is equivalent under evaluation to `p %ₘ M.charpoly`; that is, `p` is equivalent to a polynomial with degree less than the dimension of the matrix.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] {n : Type v} [decidable_eq n] [fintype n] (M : matrix n n R) (p : polynomial R) :\n⇑(polynomial.aeval M) p = ⇑(polynomial.aeval M) (p %ₘ M.charpoly) := \n\nNatural language version: \"Every matrix satisfies its own characteristic polynomial.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every matrix satisfies its own characteristic polynomial.",
      "codex_time": "5.290859720989829"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{R : Type _} [CommRingₓ R] {n : Type _} [DecidableEq n] [Fintype n] (M : Matrix n n R) : (Polynomial.aeval M) M.charpoly = 0 "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{x : ℝ} (irx : Irrational x) :\nIrrational (Real.is_sqrt x) ",
        "parse-message": "unknown constant 'Real.is_sqrt' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{x : ℝ} (hxr : Irrational x) :\nIrrational (Real.is_sqrt x) ",
        "parse-message": "unknown constant 'Real.is_sqrt' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{A : ℕ} (iH : \nIrrational (Real.is_sqrt ↑A)) :\nIrrational ↑(Nat.is_sqrt A) ",
        "parse-message": "unknown constant 'Real.is_sqrt' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{x : ℝ} (hxr : Irrational x) :\nIrrational (Real.is_sqrt x) ",
        "parse-message": "unknown constant 'Real.is_sqrt' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{x : ℝ} (irr : Irrational x) :\nIrrational (Real.is_sqrt x) ",
        "parse-message": "unknown constant 'Real.is_sqrt' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "sqrt_of_irrat_irrat",
      "search_time": "1.4941794150217902",
      "ret-prompts": [
        {
          "statement": "theorem transcendental.irrational {r : ℝ} (tr : transcendental ℚ r) : irrational r",
          "sim_score": "0.70249342918396",
          "doc_string": "A transcendental real number is irrational."
        },
        {
          "statement": "theorem irrational_nrt_of_notint_nrt {x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) : irrational x",
          "sim_score": "0.6819822192192078",
          "doc_string": " If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational."
        },
        {
          "statement": "theorem irrational_sqrt_two  : irrational (real.sqrt 2)",
          "sim_score": "0.6707029938697815",
          "doc_string": "**Irrationality of the Square Root of 2**"
        },
        {
          "statement": "theorem real.nat_sqrt_le_real_sqrt {a : ℕ} : ↑(nat.sqrt a) ≤ real.sqrt ↑a",
          "sim_score": "0.6412547826766968",
          "doc_string": "The natural square root is at most the real square root"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A transcendental real number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem {r : ℝ} (tr : transcendental ℚ r) :\nirrational r := \n\nNatural language version: \" If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then `x` is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem {x : ℝ} (n : ℕ) (m : ℤ) (hxr : x ^ n = ↑m) (hv : ¬∃ (y : ℤ), x = ↑y) (hnpos : 0 < n) :\nirrational x := \n\nNatural language version: \"**Irrationality of the Square Root of 2**\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nirrational (real.sqrt 2) := \n\nNatural language version: \"The natural square root is at most the real square root\" Translate the natural language version to a Lean mathlib version:\n theorem {a : ℕ} :\n↑(nat.sqrt a) ≤ real.sqrt ↑a := \n\nNatural language version: \"The square root of an irrational number is irrational.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The square root of an irrational number is irrational.",
      "codex_time": "3.5490879860008135"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "(x : ℝ) : Irrational x → Irrational (Real.sqrt x) "
  },
  {
    "parsed": [
      "{m : ℕ} (h : Even (m * m)) : Even m ",
      "{α : Type u_1} {m n : ℕ} [LinearOrderedSemiring α] (hmn : (m ^ 2) * (n ^ (2 : ℕ)) = 0) :\n2 ∣ m ^ 2 ∧ 2 ∣ n ^ 2 "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u} [integral_domain α] (A : α) :\nEven ((A : ℤ)^2) → Even A ",
        "parse-message": "unknown identifier 'integral_domain' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] (R : R) :\nis_even (R * R) → is_even R ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": true,
        "statement": "{m : ℕ} (h : Even (m * m)) : Even m ",
        "code": "forall {m : Nat}, (Even.{?_uniq.5} Nat Nat.hasAdd (HMul.hMul.{?_uniq.10 ?_uniq.9 ?_uniq.8} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) m m)) -> (Even.{?_uniq.52} Nat Nat.hasAdd m)"
      },
      {
        "success": true,
        "statement": "{α : Type u_1} {m n : ℕ} [LinearOrderedSemiring α] (hmn : (m ^ 2) * (n ^ (2 : ℕ)) = 0) :\n2 ∣ m ^ 2 ∧ 2 ∣ n ^ 2 ",
        "code": "forall {α : Type.{u_1}} {m : Nat} {n : Nat} [inst._@._hyg.12 : LinearOrderedSemiring.{?_uniq.10} α] (hmn : Eq.{?_uniq.14} Nat (HMul.hMul.{?_uniq.17 ?_uniq.16 ?_uniq.15} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) (HPow.hPow.{?_uniq.20 ?_uniq.19 ?_uniq.18} Nat Nat Nat (Monoid.HPow.{?_uniq.206} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) m (OfNat.ofNat.{?_uniq.19} Nat 2 (instOfNatNat 2))) (HPow.hPow.{?_uniq.46 ?_uniq.45 ?_uniq.44} Nat Nat Nat (Monoid.HPow.{0} Nat (MonoidWithZero.toMonoid.{0} Nat (Semiring.toMonoidWithZero.{0} Nat (CommSemiring.toSemiring.{0} Nat Nat.instCommSemiringNat)))) n (OfNat.ofNat.{0} Nat 2 (instOfNatNat 2)))) (OfNat.ofNat.{?_uniq.120} Nat 0 (instOfNatNat 0))), And (Dvd.dvd.{?_uniq.239} (?_uniq.357 α m n inst._@._hyg.12 hmn) (?_uniq.358 α m n inst._@._hyg.12 hmn) (OfNat.ofNat.{?_uniq.239} (?_uniq.357 α m n inst._@._hyg.12 hmn) 2 (?_uniq.359 α m n inst._@._hyg.12 hmn)) (HPow.hPow.{?_uniq.253 ?_uniq.252 ?_uniq.251} Nat (?_uniq.360 α m n inst._@._hyg.12 hmn) (?_uniq.357 α m n inst._@._hyg.12 hmn) (?_uniq.361 α m n inst._@._hyg.12 hmn) m (OfNat.ofNat.{?_uniq.252} (?_uniq.360 α m n inst._@._hyg.12 hmn) 2 (?_uniq.362 α m n inst._@._hyg.12 hmn)))) (Dvd.dvd.{?_uniq.280} (?_uniq.363 α m n inst._@._hyg.12 hmn) (?_uniq.364 α m n inst._@._hyg.12 hmn) (OfNat.ofNat.{?_uniq.280} (?_uniq.363 α m n inst._@._hyg.12 hmn) 2 (?_uniq.365 α m n inst._@._hyg.12 hmn)) (HPow.hPow.{?_uniq.294 ?_uniq.293 ?_uniq.292} Nat (?_uniq.366 α m n inst._@._hyg.12 hmn) (?_uniq.363 α m n inst._@._hyg.12 hmn) (?_uniq.367 α m n inst._@._hyg.12 hmn) n (OfNat.ofNat.{?_uniq.293} (?_uniq.366 α m n inst._@._hyg.12 hmn) 2 (?_uniq.368 α m n inst._@._hyg.12 hmn))))"
      },
      {
        "success": false,
        "statement": "{R : Type u} [Ring R] (A : R) (h2mem : 2 ∈ Units R) :\nis_even (A * A) → is_even A ",
        "parse-message": "failed to synthesize instance\n  Monoidₓ R (during elaboration)"
      }
    ],
    "number-parsed": 2,
    "number-equivalent": 1,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "sq_even_implies_num_even",
      "search_time": "1.7009556770208292",
      "ret-prompts": [
        {
          "statement": "theorem nat.even_pow {m n : ℕ} : even (m ^ n) ↔ even m ∧ n ≠ 0",
          "sim_score": "0.5731519460678101",
          "doc_string": " If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive."
        },
        {
          "statement": "theorem mul_self_add_mul_self_eq_zero {α : Type u} [linear_ordered_ring α] {x y : α} : x * x + y * y = 0 ↔ x = 0 ∧ y = 0",
          "sim_score": "0.5604414343833923",
          "doc_string": "The sum of two squares is zero iff both elements are zero."
        },
        {
          "statement": "theorem finite_field.exists_nonsquare {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) : ∃ (a : F), ¬is_square a",
          "sim_score": "0.546607255935669",
          "doc_string": "In a finite field of odd characteristic, not every element is a square."
        },
        {
          "statement": "theorem clifford_algebra.even_odd_induction {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n) : P x hx",
          "sim_score": "0.5101829767227173",
          "doc_string": " To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem {m n : ℕ} :\neven (m ^ n) ↔ even m ∧ n ≠ 0 := \n\nNatural language version: \"The sum of two squares is zero iff both elements are zero.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [linear_ordered_ring α] {x y : α} :\nx * x + y * y = 0 ↔ x = 0 ∧ y = 0 := \n\nNatural language version: \"In a finite field of odd characteristic, not every element is a square.\" Translate the natural language version to a Lean mathlib version:\n theorem {F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2) :\n∃ (a : F), ¬is_square a := \n\nNatural language version: \" To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n) :\nP x hx := \n\nNatural language version: \"If the square of a number is even, the number itself is even.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If the square of a number is even, the number itself is even.",
      "codex_time": "8.593759972980479"
    },
    "grouped": [
      [
        "{m : ℕ} (h : Even (m * m)) : Even m "
      ],
      [
        "{α : Type u_1} {m n : ℕ} [LinearOrderedSemiring α] (hmn : (m ^ 2) * (n ^ (2 : ℕ)) = 0) :\n2 ∣ m ^ 2 ∧ 2 ∣ n ^ 2 "
      ]
    ],
    "equivalent": [
      "{m : ℕ} (h : Even (m * m)) : Even m "
    ],
    "answer": ": ∀ n : ℕ, Even (n^2) → Even n "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] [Fintype R] (i : Ideal R) (h : ∀ P : Ideal R, P ≤ i → P.IsPrime → P = i ∨ P = ⊥) : i.is_maximal\n",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] (h : Fintype R) :\n∀ P : Ideal R, P.IsPrime → P.is_maximal ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] [Fintype R] {P : Ideal R} (h : P.IsPrime) :\nP.is_maximal ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] [Fintype R] {P : Ideal R}\n(Prime : P.IsPrime) : P.is_maximal ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] [Fintype R] (P : Ideal R) (h : P.IsPrime) :\nP.is_maximal ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "finite_ring_prime_implies_maximal",
      "search_time": "1.4874710789881647",
      "ret-prompts": [
        {
          "statement": "theorem ring.ne_bot_of_is_maximal_of_not_is_field {R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬is_field R) : M ≠ ⊥",
          "sim_score": "0.6932713389396667",
          "doc_string": "When a ring is not a field, the maximal ideals are nontrivial."
        },
        {
          "statement": "theorem ideal.exists_maximal (α : Type u) [semiring α] [nontrivial α] : ∃ (M : ideal α), M.is_maximal",
          "sim_score": "0.6569143533706665",
          "doc_string": "Krull's theorem: a nontrivial ring has a maximal ideal."
        },
        {
          "statement": "theorem ideal.maximal_of_no_maximal {R : Type u} [semiring R] {P : ideal R} (hmax : ∀ (m : ideal R), P < m → ¬m.is_maximal) (J : ideal R) (hPJ : P < J) : J = ⊤",
          "sim_score": "0.6307719945907593",
          "doc_string": "If P is not properly contained in any maximal ideal then it is not properly contained  in any proper ideal"
        },
        {
          "statement": "theorem ideal.is_prime_map_C_of_is_prime {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) : (ideal.map polynomial.C P).is_prime",
          "sim_score": "0.6226035356521606",
          "doc_string": "If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"When a ring is not a field, the maximal ideals are nontrivial.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} [comm_ring R] [nontrivial R] {M : ideal R} (max : M.is_maximal) (not_field : ¬is_field R) :\nM ≠ ⊥ := \n\nNatural language version: \"Krull's theorem: a nontrivial ring has a maximal ideal.\" Translate the natural language version to a Lean mathlib version:\n theorem (α : Type u) [semiring α] [nontrivial α] :\n∃ (M : ideal α), M.is_maximal := \n\nNatural language version: \"If P is not properly contained in any maximal ideal then it is not properly contained  in any proper ideal\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [semiring R] {P : ideal R} (hmax : ∀ (m : ideal R), P < m → ¬m.is_maximal) (J : ideal R) (hPJ : P < J) :\nJ = ⊤ := \n\nNatural language version: \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] {P : ideal R} (H : P.is_prime) :\n(ideal.map polynomial.C P).is_prime := \n\nNatural language version: \"In a finite commutative ring, all prime ideals are maximal.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In a finite commutative ring, all prime ideals are maximal.",
      "codex_time": "5.820907569985138"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{R : Type _} [CommRingₓ R] [Fintype R] : ∀ (Idl : Ideal R), Idl.IsPrime → Idl.IsMaximal "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{x : Type u} [TopologicalSpace x] :\nis_closed (set.Prod x X) (set.IsDiag x) ↔ hausdorff x ",
        "parse-message": "unknown identifier 'is_closed' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} (x : α → Type v) [Π x, TopologicalSpace (x x)] :\nΠ (x : x), is_closed (set.Prod x.Univ x.Univ.image (λ y : x, (x, y))) ↔ is_Hausdorff x ",
        "parse-message": "<input>:1:34: expected ':'"
      },
      {
        "success": false,
        "statement": "{x : Type u} [TopologicalSpace x] :\nis_closed (Diagonal x) ↔ is_Hausdorff x ",
        "parse-message": "unknown identifier 'is_closed' (during elaboration)"
      },
      {
        "success": false,
        "statement": "[TopologicalSpace α] (ht : t2_space α) :\nHausdorff_space α ↔ is_closed (Diagonal : set (α × α)) ",
        "parse-message": "unknown identifier 'α' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [t : TopologicalSpace α] :\nt.is_Hausdorff ↔ is_closed (Diagonal α) ",
        "parse-message": "invalid field 'is_Hausdorff', the environment does not contain 'TopologicalSpace.is_Hausdorff'\n  t\nhas type\n  TopologicalSpace α (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "hausdorff_iff_diag_closed",
      "search_time": "1.3948053639905993",
      "ret-prompts": [
        {
          "statement": "theorem emetric.Hausdorff_edist_closure {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t",
          "sim_score": "0.5625295639038086",
          "doc_string": "The Hausdorff edistance between sets or their closures is the same"
        },
        {
          "statement": "theorem is_closed.Hausdorff_dist_zero_iff_eq {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ≠ ⊤) : metric.Hausdorff_dist s t = 0 ↔ s = t",
          "sim_score": "0.5602964162826538",
          "doc_string": "Two closed sets are at zero Hausdorff distance if and only if they coincide"
        },
        {
          "statement": "theorem emetric.Hausdorff_edist_zero_iff_eq_of_closed {α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) : emetric.Hausdorff_edist s t = 0 ↔ s = t",
          "sim_score": "0.5491901636123657",
          "doc_string": "Two closed sets are at zero Hausdorff edistance if and only if they coincide"
        },
        {
          "statement": "theorem emetric.Hausdorff_edist_closure₂ {α : Type u} [pseudo_emetric_space α] {s t : set α} : emetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t",
          "sim_score": "0.5290781259536743",
          "doc_string": "Replacing a set by its closure does not change the Hausdorff edistance."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"The Hausdorff edistance between sets or their closures is the same\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_emetric_space α] {s t : set α} :\nemetric.Hausdorff_edist (closure s) (closure t) = emetric.Hausdorff_edist s t := \n\nNatural language version: \"Two closed sets are at zero Hausdorff distance if and only if they coincide\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_metric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) (fin : emetric.Hausdorff_edist s t ≠ ⊤) :\nmetric.Hausdorff_dist s t = 0 ↔ s = t := \n\nNatural language version: \"Two closed sets are at zero Hausdorff edistance if and only if they coincide\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_emetric_space α] {s t : set α} (hs : is_closed s) (ht : is_closed t) :\nemetric.Hausdorff_edist s t = 0 ↔ s = t := \n\nNatural language version: \"Replacing a set by its closure does not change the Hausdorff edistance.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [pseudo_emetric_space α] {s t : set α} :\nemetric.Hausdorff_edist s (closure t) = emetric.Hausdorff_edist s t := \n\nNatural language version: \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
      "codex_time": "6.471322034980403"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{X : Type _} [TopologicalSpace X] : T2Space X ↔ IsClosed (Set.Diagonal X) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] {s : set α} (h : ∀ (x : α), x ∈ s → ∃ (u : set α), u ⊆ s ∧ is_open u) :\nis_open s ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type*} [TopologicalSpace α] {s : set α} (h : ∀ (x : α), x ∈ s → ∃ (t : set α), (∀ (y : α), y ∈ t → y ∈ s) ∧ is_open t ∧ x ∈ t) : \nis_open s ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] {s : set α} (h : ∀ (x : α), x ∈ s → ∃ (u : set α), is_open u ∧ x ∈ u) : is_open s ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] {s : set α} (h : ∀ (x : α), x ∈ s → ∃ (t : set α), x ∈ t ∧ is_open t) : is_open s ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [TopologicalSpace α] {s : set α} {P : α → prop} (h : ∀ (x : α), (x ∈ s) → ∃ (V : set α), is_open V ∧ x ∈ V):\nis_open s ",
        "parse-message": "type expected\ntype expected (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "open_iff_open_nhd_all_pt",
      "search_time": "1.332091069984017",
      "ret-prompts": [
        {
          "statement": "theorem eventually_nhds_iff {α : Type u} [topological_space α] {a : α} {p : α → Prop} : (∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → p x) ∧ is_open t ∧ a ∈ t",
          "sim_score": "0.624941349029541",
          "doc_string": " A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set containing `a`."
        },
        {
          "statement": "theorem exists_open_singleton_of_open_finite {α : Type u} [topological_space α] [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) : ∃ (x : α) (H : x ∈ s), is_open {x}",
          "sim_score": "0.619118332862854",
          "doc_string": "Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open."
        },
        {
          "statement": "theorem exists_open_set_nhds' {α : Type u} [topological_space α] {s U : set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U",
          "sim_score": "0.6141307353973389",
          "doc_string": " If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s: it contains an open set containing `s`."
        },
        {
          "statement": "theorem exists_open_set_nhds {α : Type u} [topological_space α] {s U : set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) : ∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U",
          "sim_score": "0.6101160645484924",
          "doc_string": " If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`: it contains an open set containing `s`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" A predicate is true in a neighborhood of `a` iff it is true for all the points in an open set containing `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {a : α} {p : α → Prop} :\n(∀ᶠ (x : α) in nhds a, p x) ↔ ∃ (t : set α), (∀ (x : α), x ∈ t → p x) ∧ is_open t ∧ a ∈ t := \n\nNatural language version: \"Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] [t0_space α] {s : set α} (hfin : s.finite) (hne : s.nonempty) (ho : is_open s) :\n∃ (x : α) (H : x ∈ s), is_open {x} := \n\nNatural language version: \" If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s: it contains an open set containing `s`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s U : set α} (h : U ∈ ⨆ (x : α) (H : x ∈ s), nhds x) :\n∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U := \n\nNatural language version: \" If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`: it contains an open set containing `s`.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} [topological_space α] {s U : set α} (h : ∀ (x : α), x ∈ s → U ∈ nhds x) :\n∃ (V : set α), s ⊆ V ∧ is_open V ∧ V ⊆ U := \n\nNatural language version: \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
      "codex_time": "4.460379459982505"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{X : Type _} [TopologicalSpace X] (S : Set X) : (∀ x ∈ S, ∃ U : Set X, IsOpen U) → IsOpen S "
  },
  {
    "parsed": [
      "(z : ℂ) :\n↑(⇑(StarRingEnd ℂ) z * z) = ↑(z * ⋆z) ",
      "(z : ℂ) :\n↑(⇑(StarRingEnd ℂ) z) = (↑z) * (↑z) "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "(z : ℂ) :\n⇑is_R_or_C.re (StarRing.star_ring_hom.star_ring_hom_map ℂ Star (⇑z * ⇑(StarRingEnd ℂ) z)) = ⇑z * ⇑(StarRingEnd ℂ) z ",
        "parse-message": "unknown identifier 'is_R_or_C.re' (during elaboration)"
      },
      {
        "success": true,
        "statement": "(z : ℂ) :\n↑(⇑(StarRingEnd ℂ) z * z) = ↑(z * ⋆z) ",
        "code": "forall (z : Complex), Eq.{?_uniq.4} (?_uniq.12 z) (?_uniq.13 z) (?_uniq.14 z)"
      },
      {
        "success": false,
        "statement": "(x : ℂ) :\n⇑is_R_or_C.re (x * (⇑(StarRingEnd ℂ) x) ) = x.Abs * x.Abs ",
        "parse-message": "unknown identifier 'is_R_or_C.re' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(z : ℂ) :\nis_R_or_C.re (z * z.conj) = z.Abs^2 ",
        "parse-message": "unknown identifier 'is_R_or_C.re' (during elaboration)"
      },
      {
        "success": true,
        "statement": "(z : ℂ) :\n↑(⇑(StarRingEnd ℂ) z) = (↑z) * (↑z) ",
        "code": "forall (z : Complex), Eq.{?_uniq.4} (?_uniq.181 z) (?_uniq.182 z) (HMul.hMul.{?_uniq.10 ?_uniq.9 ?_uniq.8} (?_uniq.183 z) (?_uniq.184 z) (?_uniq.181 z) (?_uniq.185 z) (?_uniq.186 z) (?_uniq.187 z))"
      }
    ],
    "number-parsed": 2,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "complex_conj_prod_real",
      "search_time": "1.3324739320087247",
      "ret-prompts": [
        {
          "statement": "theorem complex.re_eq_add_conj (z : ℂ) : ↑(z.re) = (z + ⇑(star_ring_end ℂ) z) / 2",
          "sim_score": "0.6665807962417603",
          "doc_string": "A complex number `z` plus its conjugate `conj z` is `2` times its real part."
        },
        {
          "statement": "theorem complex.im_eq_sub_conj (z : ℂ) : ↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * complex.I)",
          "sim_score": "0.6368286609649658",
          "doc_string": "A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part."
        },
        {
          "statement": "theorem inner_product_space.is_self_adjoint_iff_inner_map_self_real {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) : inner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v",
          "sim_score": "0.5591109395027161",
          "doc_string": " A linear operator on a complex inner product space is self-adjoint precisely when `⟪T v, v⟫_ℂ` is real for all v."
        },
        {
          "statement": "theorem re_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) : ⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2",
          "sim_score": "0.48265978693962097",
          "doc_string": "Polarization identity: The real part of the  inner product, in terms of the norm."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A complex number `z` plus its conjugate `conj z` is `2` times its real part.\" Translate the natural language version to a Lean mathlib version:\n theorem (z : ℂ) :\n↑(z.re) = (z + ⇑(star_ring_end ℂ) z) / 2 := \n\nNatural language version: \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part.\" Translate the natural language version to a Lean mathlib version:\n theorem (z : ℂ) :\n↑(z.im) = (z - ⇑(star_ring_end ℂ) z) / (2 * complex.I) := \n\nNatural language version: \" A linear operator on a complex inner product space is self-adjoint precisely when `⟪T v, v⟫_ℂ` is real for all v.\" Translate the natural language version to a Lean mathlib version:\n theorem {V : Type u_4} [inner_product_space ℂ V] (T : V →ₗ[ℂ] V) :\ninner_product_space.is_self_adjoint T ↔ ∀ (v : V), ⇑(star_ring_end ℂ) (has_inner.inner (⇑T v) v) = has_inner.inner (⇑T v) v := \n\nNatural language version: \"Polarization identity: The real part of the  inner product, in terms of the norm.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] (x y : E) :\n⇑is_R_or_C.re (has_inner.inner x y) = (∥x∥ * ∥x∥ + ∥y∥ * ∥y∥ - ∥x - y∥ * ∥x - y∥) / 2 := \n\nNatural language version: \"The product of a complex number with its conjugate is a real number.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The product of a complex number with its conjugate is a real number.",
      "codex_time": "6.301921194011811"
    },
    "grouped": [
      [
        "(z : ℂ) :\n↑(⇑(StarRingEnd ℂ) z * z) = ↑(z * ⋆z) "
      ],
      [
        "(z : ℂ) :\n↑(⇑(StarRingEnd ℂ) z) = (↑z) * (↑z) "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ z : ℂ, ∃ r : ℝ, z * (starRingEnd ℂ $ z) = (r : ℂ) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u} (L : List (α × Bool)) (n : ℕ) [DecidableEQ α] :\nfree_group.c x ≠ 1 ↔ x ≠ 1 ",
        "parse-message": "unknown identifier 'DecidableEQ' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} (x : free_group α) :\n\nnet.Dense {i | FreeGroup.Reduce i = FreeGroup.Reduce (x^i)}\n  ",
        "parse-message": "unknown identifier 'free_group' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} [DecidableEQ α] (x : free_group α) :\nx ≠ 1 → ¬IsOFFinOrder x ",
        "parse-message": "unknown identifier 'DecidableEQ' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u} {L : List (α × Bool)}\n  (h : ∃(t : α × Bool) (h : t ∈ L), t ≠ (0, bor t.2 tt)) :\n ∀(t : α × Bool) (h : t ∈ L), ¬ IsOFFinOrder (FreeGroup.Mk L) ",
        "parse-message": "application type mismatch\n  bor t\nargument\n  t\nhas type\n  α × Bool : Type u\nbut is expected to have type\n  Bool : Type (during elaboration)"
      },
      {
        "success": false,
        "statement": "free_group.is_of_inf_order_of_not_is_one :\n∀ {α : Type u} [DecidableEQ α] (A : free_group α),\nA ≠ 1 → is_of_inf_order A ",
        "parse-message": "unknown identifier 'DecidableEQ' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "non_id_implies_infinite_order",
      "search_time": "1.338385823997669",
      "ret-prompts": [
        {
          "statement": "theorem free_group.reduce.sound {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) : free_group.reduce L₁ = free_group.reduce L₂",
          "sim_score": "0.5920776724815369",
          "doc_string": " If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined."
        },
        {
          "statement": "theorem order_of_pos_iff {G : Type u} {x : G} [monoid G] : 0 < order_of x ↔ is_of_fin_order x",
          "sim_score": "0.5908461809158325",
          "doc_string": "A group element has finite order iff its order is positive."
        },
        {
          "statement": "theorem is_of_fin_order_inv_iff {G : Type u} [group G] {x : G} : is_of_fin_order x⁻¹ ↔ is_of_fin_order x",
          "sim_score": "0.5742547512054443",
          "doc_string": "Inverses of elements of finite order have finite order."
        },
        {
          "statement": "theorem is_of_fin_order.inv {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) : is_of_fin_order x⁻¹",
          "sim_score": "0.5742547512054443",
          "doc_string": "Inverses of elements of finite order have finite order."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" If two words correspond to the same element in the free group, then they have a common maximal reduction. This is the proof that the function that sends an element of the free group to its maximal reduction is well-defined.\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u} {L₁ L₂ : list (α × bool)} [decidable_eq α] (H : free_group.mk L₁ = free_group.mk L₂) :\nfree_group.reduce L₁ = free_group.reduce L₂ := \n\nNatural language version: \"A group element has finite order iff its order is positive.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} {x : G} [monoid G] :\n0 < order_of x ↔ is_of_fin_order x := \n\nNatural language version: \"Inverses of elements of finite order have finite order.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} [group G] {x : G} :\nis_of_fin_order x⁻¹ ↔ is_of_fin_order x := \n\nNatural language version: \"Inverses of elements of finite order have finite order.\" Translate the natural language version to a Lean mathlib version:\n theorem {G : Type u} [group G] {x : G} (hx : is_of_fin_order x) :\nis_of_fin_order x⁻¹ := \n\nNatural language version: \"Every non-identity element of a free group is of infinite order.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Every non-identity element of a free group is of infinite order.",
      "codex_time": "5.115586811996764"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{G : Type _} [Groupₓ G] : FreeGroup G → (∀ g : G, g ≠ 1 → orderOf g = 0) "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{R : Type u} [Ring R] (s : Subring R) [field K] (HomK : K → R)\n(h : ∀ x : K, 0 ≠ x → HomK x ≠ 0) (h1 : HomK 1 ∈ s) :\n integral_domain s ",
        "parse-message": "failed to synthesize instance\n  Ringₓ R (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u} [field K] (s : Subring K) (h : 1 ∈ s) :\nintegral_domain s ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(K : Type u) [discrete_field K] {R : set K} [is_subring R] (ONe : (1:K) ∈ R) :\n  is_integral_domain R ",
        "parse-message": "unknown identifier 'discrete_field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u} [field K] (s : Subring K) (h1 : ∀ (A : K), A ∈ s → A⁻¹ ∈ s)\n(h2 : 1 ∈ s) : integral_domain s ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{K : Type u} [field K] (s : Subring K) (h₁ : 1 ∈ s) :\nintegral_domain s ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "sub_ring_field_with_id_is_int_domain",
      "search_time": "1.3781938120082486",
      "ret-prompts": [
        {
          "statement": "theorem subfield.inv_mem {K : Type u} [field K] (s : subfield K) {x : K} : x ∈ s → x⁻¹ ∈ s",
          "sim_score": "0.6670852899551392",
          "doc_string": "A subfield is closed under inverses."
        },
        {
          "statement": "theorem subring.one_mem {R : Type u} [ring R] (s : subring R) : 1 ∈ s",
          "sim_score": "0.6393297910690308",
          "doc_string": "A subring contains the ring's 1."
        },
        {
          "statement": "theorem subring.zero_mem {R : Type u} [ring R] (s : subring R) : 0 ∈ s",
          "sim_score": "0.6295010447502136",
          "doc_string": "A subring contains the ring's 0."
        },
        {
          "statement": "theorem subfield.div_mem {K : Type u} [field K] (s : subfield K) {x y : K} : x ∈ s → y ∈ s → x / y ∈ s",
          "sim_score": "0.6208624243736267",
          "doc_string": "A subfield is closed under division."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"A subfield is closed under inverses.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x : K} :\nx ∈ s → x⁻¹ ∈ s := \n\nNatural language version: \"A subring contains the ring's 1.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [ring R] (s : subring R) :\n1 ∈ s := \n\nNatural language version: \"A subring contains the ring's 0.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [ring R] (s : subring R) :\n0 ∈ s := \n\nNatural language version: \"A subfield is closed under division.\" Translate the natural language version to a Lean mathlib version:\n theorem {K : Type u} [field K] (s : subfield K) {x y : K} :\nx ∈ s → y ∈ s → x / y ∈ s := \n\nNatural language version: \"Any sub-ring of a field that contains the identity is an integral domain\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "Any sub-ring of a field that contains the identity is an integral domain",
      "codex_time": "9.568462060997263"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{F : Type _} [Field F] : ∀ R : Subring F, 1 ∈ R.Carrier → IsDomain ↥R "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] [is_domain R] [DiscreteValuationRing R] (x : R) :\nis_unit x ↔ ∃ s : R, s * x = 1 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [comm_ring R] [is_domain R] [DiscreteValuationRing R] (x : R) :\nis_unit x ↔ DiscreteValuationRing.int_valuation_def x = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u_1} [field R] [DiscreteValuationRing R] {v : DiscreteValuationRing.HeightONeSpectrum R} (x : R) :\nis_unit x ≃ (v.int_valuation_def x = 0) ",
        "parse-message": "unknown identifier 'field' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u} [DiscreteValuationRing R] (x : R) :\nis_unit x ↔ (Nat.Prime.int_val_def x = 0 : Nnreal) ",
        "parse-message": "failed to synthesize instance\n  CommRingₓ R (during elaboration)"
      },
      {
        "success": false,
        "statement": "{R : Type u_1} [comm_ring R] [is_domain R] [DiscreteValuationRing R] (x : R) :\nis_unit x ↔ v.int_valuation_def x = 0 ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "dvr_unit_iff_val_zero",
      "search_time": "1.3810809220012743",
      "ret-prompts": [
        {
          "statement": "theorem discrete_valuation_ring.of_has_unit_mul_pow_irreducible_factorization {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) : discrete_valuation_ring R",
          "sim_score": "0.7251311540603638",
          "doc_string": "An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring."
        },
        {
          "statement": "theorem discrete_valuation_ring.of_ufd_of_unique_irreducible {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) : discrete_valuation_ring R",
          "sim_score": "0.6923463344573975",
          "doc_string": "A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring."
        },
        {
          "statement": "theorem valuation_ring.of_integers {𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) : valuation_ring 𝒪",
          "sim_score": "0.6915189623832703",
          "doc_string": " If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪` is a valuation ring."
        },
        {
          "statement": "theorem is_dedekind_domain.height_one_spectrum.int_valuation_ne_zero {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ≠ 0) : v.int_valuation_def x ≠ 0",
          "sim_score": "0.6845616698265076",
          "doc_string": "Nonzero elements have nonzero adic valuation."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"An integral domain in which there is an irreducible element `p` such that every nonzero element is associated to a power of `p` is a discrete valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] [is_domain R] (hR : discrete_valuation_ring.has_unit_mul_pow_irreducible_factorization R) :\ndiscrete_valuation_ring R := \n\nNatural language version: \"A unique factorization domain with at least one irreducible element in which all irreducible elements are associated is a discrete valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u} [comm_ring R] [is_domain R] [unique_factorization_monoid R] (h₁ : ∃ (p : R), irreducible p) (h₂ : ∀ ⦃p q : R⦄, irreducible p → irreducible q → associated p q) :\ndiscrete_valuation_ring R := \n\nNatural language version: \" If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪` is a valuation ring.\" Translate the natural language version to a Lean mathlib version:\n theorem {𝒪 : Type u} {K : Type v} {Γ : Type w} [comm_ring 𝒪] [is_domain 𝒪] [field K] [algebra 𝒪 K] [linear_ordered_comm_group_with_zero Γ] (v : valuation K Γ) (hh : v.integers 𝒪) :\nvaluation_ring 𝒪 := \n\nNatural language version: \"Nonzero elements have nonzero adic valuation.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} [comm_ring R] [is_domain R] [is_dedekind_domain R] (v : is_dedekind_domain.height_one_spectrum R) (x : R) (hx : x ≠ 0) :\nv.int_valuation_def x ≠ 0 := \n\nNatural language version: \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
      "codex_time": "5.3449695729941595"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{R : Type _} [CommRingₓ R] [IsDomain R] [DiscreteValuationRing R] : ∀ r : R, IsUnit r → DiscreteValuationRing.addVal R r = 0 "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": ":\nConvex Real.Exp ",
        "parse-message": "unknown constant 'Real.Exp' (during elaboration)"
      },
      {
        "success": false,
        "statement": " :\nConvexOn ℝ set.Univ Real.Exp ",
        "parse-message": "invalid field notation, type is not of the form (C ...) where C is a constant\n  set\nhas type\n  ?m.13 → ?m.14 PUnit (during elaboration)"
      },
      {
        "success": false,
        "statement": " :\nConvexOn ℝ set.Univ (λ (x : ℝ), Exp x) ",
        "parse-message": "invalid field notation, type is not of the form (C ...) where C is a constant\n  set\nhas type\n  ?m.13 → ?m.14 PUnit (during elaboration)"
      },
      {
        "success": false,
        "statement": ":\nConvexOn ℝ (-(1 : ℝ)) 1 Real.Exp ",
        "parse-message": "function expected at\n  ConvexOn ℝ (-?m.63) 1\nterm has type\n  Prop (during elaboration)"
      },
      {
        "success": false,
        "statement": ":\nConvexOn ℝ set.Univ Real.Exp ",
        "parse-message": "invalid field notation, type is not of the form (C ...) where C is a constant\n  set\nhas type\n  ?m.13 → ?m.14 PUnit (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "exp_convex",
      "search_time": "1.3569003070006147",
      "ret-prompts": [
        {
          "statement": "theorem convex_on_exp  : convex_on ℝ set.univ real.exp",
          "sim_score": "0.8296651840209961",
          "doc_string": "`exp` is convex on the whole real line."
        },
        {
          "statement": "theorem strict_convex_on_exp  : strict_convex_on ℝ set.univ real.exp",
          "sim_score": "0.8015367984771729",
          "doc_string": "`exp` is strictly convex on the whole real line."
        },
        {
          "statement": "theorem strict_convex_on_zpow {m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) : strict_convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m)",
          "sim_score": "0.5888562202453613",
          "doc_string": "`x^m`, `m : ℤ` is convex on `(0, +∞)` for all `m` except `0` and `1`."
        },
        {
          "statement": "theorem convex_on_pow (n : ℕ) : convex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n)",
          "sim_score": "0.5808110237121582",
          "doc_string": "`x^n`, `n : ℕ` is convex on `[0, +∞)` for all `n`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"`exp` is convex on the whole real line.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nconvex_on ℝ set.univ real.exp := \n\nNatural language version: \"`exp` is strictly convex on the whole real line.\" Translate the natural language version to a Lean mathlib version:\n theorem  :\nstrict_convex_on ℝ set.univ real.exp := \n\nNatural language version: \"`x^m`, `m : ℤ` is convex on `(0, +∞)` for all `m` except `0` and `1`.\" Translate the natural language version to a Lean mathlib version:\n theorem {m : ℤ} (hm₀ : m ≠ 0) (hm₁ : m ≠ 1) :\nstrict_convex_on ℝ (set.Ioi 0) (λ (x : ℝ), x ^ m) := \n\nNatural language version: \"`x^n`, `n : ℕ` is convex on `[0, +∞)` for all `n`\" Translate the natural language version to a Lean mathlib version:\n theorem (n : ℕ) :\nconvex_on ℝ (set.Ici 0) (λ (x : ℝ), x ^ n) := \n\nNatural language version: \"The exponential function is convex.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "The exponential function is convex.",
      "codex_time": "3.8294329380150884"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": ": ConvexOn ℝ Set.univ Real.exp "
  },
  {
    "parsed": [
      "{n A b : ℕ} (hab : A.coprime b) :\n∃ (x y : ℕ), n = A * x + b * y ∧ y < b "
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{R : Type u_2} [comm_ring R] (x y : R) (ha : 0 < x) (hb : 0 < y) :\n∃ (i j : ℕ), ∃ (A b : R), i + j > j ∧ ↑i * x + ↑j * y = A * ↑x + b * ↑y ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "(x A b : ℕ) (hab : A.Gcd b = 1) : ∃ (y : ℕ), A * x + b * y = ↑x * ↑b ",
        "parse-message": "invalid field 'Gcd', the environment does not contain 'Nat.Gcd'\n  A\nhas type\n  ℕ (during elaboration)"
      },
      {
        "success": false,
        "statement": "{A b : ℕ} (hab : coprime A b) :\n∃ k : ℕ, ∀ (n : ℕ), n < k → ∃ (x y : ℕ), n = A * x + b * y ",
        "parse-message": "unknown identifier 'coprime' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{A b : ℕ} (h : A.coprime b) :\n∃ x y z : ℕ, z ≥ max (A * b) 2 ∧ x = z % A ∧ y = z % b ∧ ↑z = ↑A * x + ↑b * y ",
        "parse-message": "ambiguous, possible interpretations \n  _root_.max (A * b) 2 : ℕ\n  \n  LinearOrderₓ.max (A * b) 2 : ℕ (during elaboration)"
      },
      {
        "success": true,
        "statement": "{n A b : ℕ} (hab : A.coprime b) :\n∃ (x y : ℕ), n = A * x + b * y ∧ y < b ",
        "code": "forall {n : Nat} {A : Nat} {b : Nat}, (Nat.coprime A b) -> (Exists.{?_uniq.13} Nat (fun (x : Nat) => Exists.{?_uniq.17} Nat (fun (y : Nat) => And (Eq.{?_uniq.21} Nat n (HAdd.hAdd.{?_uniq.24 ?_uniq.23 ?_uniq.22} Nat Nat Nat (instHAdd.{0} Nat Nat.hasAdd) (HMul.hMul.{?_uniq.27 ?_uniq.26 ?_uniq.25} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) A x) (HMul.hMul.{?_uniq.30 ?_uniq.29 ?_uniq.28} Nat Nat Nat (instHMul.{0} Nat Nat.hasMul) b y))) (LT.lt.{?_uniq.116} Nat Nat.hasLt y b))))"
      }
    ],
    "number-parsed": 1,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "coprime_integer_span_sylvester_coin",
      "search_time": "1.4123720790084917",
      "ret-prompts": [
        {
          "statement": "theorem nat.gcd_eq_gcd_ab (x y : ℕ) : ↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y",
          "sim_score": "0.5282862186431885",
          "doc_string": " **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm."
        },
        {
          "statement": "theorem int.gcd_least_linear {a b : ℤ} (ha : a ≠ 0) : is_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b)",
          "sim_score": "0.5160197615623474",
          "doc_string": " For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`"
        },
        {
          "statement": "theorem mul_eq_mul_prime_pow {R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ℕ} (hp : prime p) (hx : x * y = a * p ^ n) : ∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j",
          "sim_score": "0.4904349744319916",
          "doc_string": "If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written  as the product of a power of `p` and a divisor of `a`."
        },
        {
          "statement": "theorem unique_factorization_monoid.dvd_of_dvd_mul_left_of_no_prime_factors {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) : (∀ {d : R}, d ∣ a → d ∣ c → ¬prime d) → a ∣ b * c → a ∣ b",
          "sim_score": "0.47909241914749146",
          "doc_string": " Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`. Compare `is_coprime.dvd_of_dvd_mul_left`."
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \" **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and `b = gcd_b x y` are computed by the extended Euclidean algorithm.\" Translate the natural language version to a Lean mathlib version:\n theorem (x y : ℕ) :\n↑(x.gcd y) = ↑x * x.gcd_a y + ↑y * x.gcd_b y := \n\nNatural language version: \" For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be written in the form `a * x + b * y` for some pair of integers `x` and `y`\" Translate the natural language version to a Lean mathlib version:\n theorem {a b : ℤ} (ha : a ≠ 0) :\nis_least {n : ℕ | 0 < n ∧ ∃ (x y : ℤ), ↑n = a * x + b * y} (a.gcd b) := \n\nNatural language version: \"If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written  as the product of a power of `p` and a divisor of `a`.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_1} [cancel_comm_monoid_with_zero R] {x y a p : R} {n : ℕ} (hp : prime p) (hx : x * y = a * p ^ n) :\n∃ (i j : ℕ) (b c : R), i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j := \n\nNatural language version: \" Euclid's lemma: if `a ∣ b * c` and `a` and `c` have no common prime factors, `a ∣ b`. Compare `is_coprime.dvd_of_dvd_mul_left`.\" Translate the natural language version to a Lean mathlib version:\n theorem {R : Type u_2} [cancel_comm_monoid_with_zero R] [unique_factorization_monoid R] {a b c : R} (ha : a ≠ 0) :\n(∀ {d : R}, d ∣ a → d ∣ c → ¬prime d) → a ∣ b * c → a ∣ b := \n\nNatural language version: \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
      "codex_time": "6.606359152006917"
    },
    "grouped": [
      [
        "{n A b : ℕ} (hab : A.coprime b) :\n∃ (x y : ℕ), n = A * x + b * y ∧ y < b "
      ]
    ],
    "equivalent": [
      
    ],
    "answer": ": ∀ a b : ℕ, a > 0 → b > 0 → Nat.coprime a b → ∃ m : ℕ, ∀ N : ℕ, N > m → ∃ x y : ℕ, N = a*x + b*y "
  },
  {
    "parsed": [
      
    ],
    "parse-checks": [
      {
        "success": false,
        "statement": "{α : Type u_1} [comm_ring α] [DecidableEQ α] (hp : ∃! n : ℕ, h.characteristic = P.prime_pow n) {A b : α} :\n(A + b)^P = A^P + b^P ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} [comm_ring α] (P : ℕ) (p_prime : Prime P) [char_p α P] (A b : α) :\n(A + b)^[P] = A^[P] + b^[P] ",
        "parse-message": "parsed to  {  α :  Type  u_1 } ->  [  comm_ring  α ] ->  (  P :  ℕ ) ->  (  p_prime :  Prime  P ) ->  [  char_p  α P ] ->  (  A b : α ) ->     (   A + b  ) ^[ P ]   (   A + b  ) ^[ P ] =    A ^[ P ]  A ^[ P ] +   b ^[ P ]  b ^[ P ]; error while parsing as theorem: <input>:1:155: expected end of input"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} [comm_ring α] [DecidableEQ α] (hp : char_p α) {A b : α} :\n(↑A + ↑b) ^ P = ↑A ^ P + ↑b ^ P ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} [CommSemiring α] (P : ℕ) (hp : Nat.Prime P) [char_p α P hp] {A b : α} :\nA ^ P + b ^ P = (A + b) ^ P ",
        "parse-message": "unknown identifier 'char_p' (during elaboration)"
      },
      {
        "success": false,
        "statement": "{α : Type u_1} [comm_ring α] (P : ℕ) (hp : Prime P) (hchar : char_p α P) {A b : α} :\n(A + b)^P = A^P + b^P ",
        "parse-message": "unknown identifier 'comm_ring' (during elaboration)"
      }
    ],
    "number-parsed": 0,
    "number-equivalent": 0,
    "metadata": {
      "use_theorem_name": false,
      "theorem_name": "frobenius_pow_sum_eq_sum_pow",
      "search_time": "1.3461158830032218",
      "ret-prompts": [
        {
          "statement": "theorem nat.factorization_mul_of_coprime {a b : ℕ} (hab : a.coprime b) : (a * b).factorization = a.factorization + b.factorization",
          "sim_score": "0.6287815570831299",
          "doc_string": "For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`"
        },
        {
          "statement": "theorem nat.factorization_mul_apply_of_coprime {p a b : ℕ} (hab : a.coprime b) : ⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p",
          "sim_score": "0.6287815570831299",
          "doc_string": "For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`"
        },
        {
          "statement": "theorem nat.factorization_mul {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) : (a * b).factorization = a.factorization + b.factorization",
          "sim_score": "0.6084638833999634",
          "doc_string": "For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`"
        },
        {
          "statement": "theorem factorization_mul {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) : factorization (a * b) = factorization a + factorization b",
          "sim_score": "0.6084638833999634",
          "doc_string": "For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`"
        }
      ],
      "prompt_type": "retrieved k few shot",
      "prompt": "Natural language version: \"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem {a b : ℕ} (hab : a.coprime b) :\n(a * b).factorization = a.factorization + b.factorization := \n\nNatural language version: \"For coprime `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem {p a b : ℕ} (hab : a.coprime b) :\n⇑((a * b).factorization) p = ⇑(a.factorization) p + ⇑(b.factorization) p := \n\nNatural language version: \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem {a b : ℕ} (ha : a ≠ 0) (hb : b ≠ 0) :\n(a * b).factorization = a.factorization + b.factorization := \n\nNatural language version: \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b`\" Translate the natural language version to a Lean mathlib version:\n theorem {α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] [normalization_monoid α] [decidable_eq α] {a b : α} (ha : a ≠ 0) (hb : b ≠ 0) :\nfactorization (a * b) = factorization a + factorization b := \n\nNatural language version: \"In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.\" Translate the natural language version to a Lean mathlib version:\n theorem ",
      "main_prompt": "In a commutative ring with prime characteristic $p$, the $p$th power of the sum of two elements is equal to the sum of the $p$th powers of the elements.",
      "codex_time": "7.542835899017518"
    },
    "grouped": [
      
    ],
    "equivalent": [
      
    ],
    "answer": "{R : Type _} [CommRingₓ R] : (p : ℕ) → Prime p → CharP R p → ∀ a b : R, (a + b)^p = a^p + b^p "
  }
]